/*
 * Copyright (c) 2018, John Pettenger
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.runeprofile.utils;

import com.google.common.collect.EvictingQueue;

import java.awt.event.KeyEvent;
import java.awt.event.KeyListener;
import java.util.Arrays;
import java.util.Objects;
import java.util.Optional;
import java.util.regex.Pattern;
import javax.inject.Singleton;
import javax.swing.SwingUtilities;
import javax.swing.text.BadLocationException;
import javax.swing.text.Document;
import javax.swing.text.JTextComponent;

import com.google.inject.Inject;
import lombok.NonNull;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.Friend;
import net.runelite.api.FriendsChatManager;
import net.runelite.api.Nameable;
import net.runelite.api.NameableContainer;
import net.runelite.api.Player;
import net.runelite.api.WorldView;
import net.runelite.api.clan.ClanID;
import net.runelite.api.clan.ClanMember;
import net.runelite.api.clan.ClanSettings;

@Slf4j
@Singleton
public class UsernameAutocompleter implements KeyListener {
    /**
     * Non-breaking space character.
     */
    private static final String NBSP = Character.toString((char) 160);

    /**
     * Character class for characters that cannot be in an RSN.
     */
    private static final Pattern INVALID_CHARS = Pattern.compile("[^a-zA-Z0-9_ -]");

    private static final int MAX_SEARCH_HISTORY = 25;

    private final Client client;

    private final EvictingQueue<String> searchHistory = EvictingQueue.create(MAX_SEARCH_HISTORY);

    /**
     * The name currently being autocompleted.
     */
    private String autocompleteName;

    /**
     * Pattern for the name currently being autocompleted.
     */
    private Pattern autocompleteNamePattern;

    @Inject
    private UsernameAutocompleter(Client client) {
        this.client = client;
    }

    @Override
    public void keyPressed(KeyEvent e) {

    }

    @Override
    public void keyReleased(KeyEvent e) {

    }

    @Override
    public void keyTyped(KeyEvent e) {
        final JTextComponent input = (JTextComponent) e.getSource();
        final String inputText = input.getText();

        // Only autocomplete if the selection end is at the end of the text.
        if (input.getSelectionEnd() != inputText.length()) {
            return;
        }

        // Character to be inserted at the selection start.
        final String charToInsert = Character.toString(e.getKeyChar());

        // Don't attempt to autocomplete if the name is invalid.
        // This condition is also true when the user presses a key like backspace.
        if (INVALID_CHARS.matcher(charToInsert).find()
                || INVALID_CHARS.matcher(inputText).find()) {
            return;
        }

        // Check if we are already autocompleting.
        if (autocompleteName != null && autocompleteNamePattern.matcher(inputText).matches()) {
            if (isExpectedNext(input, charToInsert)) {
                try {
                    // Insert the character and move the selection.
                    final int insertIndex = input.getSelectionStart();
                    Document doc = input.getDocument();
                    doc.remove(insertIndex, 1);
                    doc.insertString(insertIndex, charToInsert, null);
                    input.select(insertIndex + 1, input.getSelectionEnd());
                } catch (BadLocationException ex) {
                    log.warn("Could not insert character.", ex);
                }

                // Prevent default behavior.
                e.consume();
            } else // Character to insert does not match current autocompletion. Look for another name.
            {
                newAutocomplete(e);
            }
        } else // Search for a name to autocomplete
        {
            newAutocomplete(e);
        }
    }

    private void newAutocomplete(KeyEvent e) {
        final JTextComponent input = (JTextComponent) e.getSource();
        final String inputText = input.getText();
        final String nameStart = inputText.substring(0, input.getSelectionStart()) + e.getKeyChar();

        if (findAutocompleteName(nameStart)) {
            // Assert this.autocompleteName != null
            final String name = this.autocompleteName;
            SwingUtilities.invokeLater(() ->
            {
                try {
                    input.getDocument().insertString(
                            nameStart.length(),
                            name.substring(nameStart.length()),
                            null);
                    input.select(nameStart.length(), name.length());
                } catch (BadLocationException ex) {
                    log.warn("Could not autocomplete name.", ex);
                }
            });
        }
    }

    private boolean findAutocompleteName(String nameStart) {
        final Pattern pattern;
        Optional<String> autocompleteName;

        // Pattern to match names that start with nameStart.
        // Allows spaces to be represented as common whitespaces, underscores,
        // hyphens, or non-breaking spaces.
        // Matching non-breaking spaces is necessary because the API
        // returns non-breaking spaces when a name has whitespace.
        pattern = Pattern.compile(
                "(?i)^" + nameStart.replaceAll("[ _-]", "[ _" + NBSP + "-]") + ".+?");

        // Search all previous successful queries
        autocompleteName = searchHistory.stream()
                .filter(n -> pattern.matcher(n).matches())
                .findFirst();

        // Search friends if previous searches weren't matched
        if (!autocompleteName.isPresent()) {
            NameableContainer<Friend> friendContainer = client.getFriendContainer();
            if (friendContainer != null) {
                autocompleteName = Arrays.stream(friendContainer.getMembers())
                        .map(Nameable::getName)
                        .filter(n -> pattern.matcher(n).matches())
                        .findFirst();
            }
        }

        // Search friends chat if a friend wasn't found
        if (!autocompleteName.isPresent()) {
            final FriendsChatManager friendsChatManager = client.getFriendsChatManager();
            if (friendsChatManager != null) {
                autocompleteName = Arrays.stream(friendsChatManager.getMembers())
                        .map(Nameable::getName)
                        .filter(n -> pattern.matcher(n).matches())
                        .findFirst();
            }
        }

        // Search clans
        if (!autocompleteName.isPresent()) {
            final ClanSettings[] clanSettings = {
                    client.getClanSettings(ClanID.CLAN),
                    client.getClanSettings(ClanID.GROUP_IRONMAN),
                    client.getGuestClanSettings()
            };
            autocompleteName = Arrays.stream(clanSettings)
                    .filter(Objects::nonNull)
                    .flatMap(cs -> cs.getMembers().stream())
                    .map(ClanMember::getName)
                    .filter(n -> pattern.matcher(n).matches())
                    .findFirst();
        }

        // Search cached players if a friend wasn't found
        if (!autocompleteName.isPresent()) {
            WorldView wv = client.getTopLevelWorldView();
            autocompleteName = wv.players().stream()
                    .filter(Objects::nonNull)
                    .map(Player::getName)
                    .filter(Objects::nonNull)
                    .filter(n -> pattern.matcher(n).matches())
                    .findFirst();
        }

        if (autocompleteName.isPresent()) {
            this.autocompleteName = autocompleteName.get().replace(NBSP, " ");
            this.autocompleteNamePattern = Pattern.compile(
                    "(?i)^" + this.autocompleteName.replaceAll("[ _-]", "[ _-]") + "$");
        } else {
            this.autocompleteName = null;
            this.autocompleteNamePattern = null;
        }

        return autocompleteName.isPresent();
    }

    void addToSearchHistory(@NonNull String name) {
        if (!searchHistory.contains(name)) {
            searchHistory.offer(name);
        }
    }

    private boolean isExpectedNext(JTextComponent input, String nextChar) {
        String expected;
        if (input.getSelectionStart() < input.getSelectionEnd()) {
            try {
                expected = input.getText(input.getSelectionStart(), 1);
            } catch (BadLocationException ex) {
                log.warn("Could not get first character from input selection.", ex);
                return false;
            }
        } else {
            expected = "";
        }
        return nextChar.equalsIgnoreCase(expected);
    }
}
package com.runeprofile.utils;

@FunctionalInterface
public interface SupplierWithException<T, E extends Exception> {
    T get() throws E;
}

package com.runeprofile.utils;

import lombok.Getter;

@Getter
public class RuneProfileApiException extends RuntimeException {
    public RuneProfileApiException(String message) {
        super(message);
    }
}
package com.runeprofile.utils;

import net.runelite.api.Client;

import java.nio.charset.StandardCharsets;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.util.Base64;

public class AccountHash {
    public static String getHashed(Client client) {
        long accountHashLong = client.getAccountHash();

        if (accountHashLong == -1) {
            return null;
        }

        String accountHashString = String.valueOf(accountHashLong);

        MessageDigest digest;

        try {
            digest = MessageDigest.getInstance("SHA-1");
        } catch (NoSuchAlgorithmException e) {
            throw new RuntimeException(e);
        }

        byte[] hash = digest.digest(accountHashString.getBytes(StandardCharsets.UTF_8));

        return Base64.getEncoder().encodeToString(hash);
    }
}

package com.runeprofile;

import com.runeprofile.panels.InvalidPanel;
import com.runeprofile.panels.LayoutPluginPanel;
import com.runeprofile.panels.HeaderPanel;
import lombok.extern.slf4j.Slf4j;

import javax.inject.Inject;
import javax.swing.*;
import java.awt.*;

@Slf4j
public class RuneProfilePanel extends net.runelite.client.ui.PluginPanel {
    private final LayoutPluginPanel layoutPluginPanel;
    private InvalidPanel invalidPanel;

    @Inject
    public RuneProfilePanel(HeaderPanel headerPanel, LayoutPluginPanel layoutPluginPanel) {
        super(false);
        setLayout(new BorderLayout());

        this.layoutPluginPanel = layoutPluginPanel;

        add(headerPanel, BorderLayout.NORTH);
        loadInvalidState();
    }

    public void loadValidState() {
        SwingUtilities.invokeLater(() -> {
            if (invalidPanel != null) {
                remove(invalidPanel);
            }

            add(layoutPluginPanel, BorderLayout.CENTER);
            revalidate();
            repaint();
        });
    }

    public void loadInvalidState() {
        SwingUtilities.invokeLater(() -> {
            if (layoutPluginPanel != null) {
                remove(layoutPluginPanel);
            }

            if (invalidPanel == null) {
                invalidPanel = new InvalidPanel();
            }

            invalidPanel.setHintText("Login to use this plugin.");
            add(invalidPanel, BorderLayout.CENTER);
            revalidate();
            repaint();
        });
    }

    public void loadInvalidRequestState() {
        SwingUtilities.invokeLater(() -> {
            if (layoutPluginPanel != null) {
                remove(layoutPluginPanel);
            }

            if (invalidPanel == null) {
                invalidPanel = new InvalidPanel();
            }

            invalidPanel.setHintText("Invalid world/mode.");
            add(invalidPanel, BorderLayout.CENTER);
            revalidate();
            repaint();
        });
    }
}

package com.runeprofile.data;

import lombok.Data;

@Data
public class AchievementDiaryTierData {
    private final int areaId;
    private final int tierIndex;
    private final int completedCount;
}

package com.runeprofile.data;

import lombok.Data;

@Data
public class PlayerClanData {
    private final String name;
    private final int rank;
    private final int icon;
    private final String title;
}

package com.runeprofile.data;

import lombok.Getter;
import lombok.RequiredArgsConstructor;
import net.runelite.api.Client;
import net.runelite.api.gameval.VarbitID;

@Getter
@RequiredArgsConstructor
public enum CombatAchievementTier {
    EASY(1, VarbitID.CA_TOTAL_TASKS_COMPLETED_EASY),
    MEDIUM(2, VarbitID.CA_TOTAL_TASKS_COMPLETED_MEDIUM),
    HARD(3, VarbitID.CA_TOTAL_TASKS_COMPLETED_HARD),
    ELITE(4, VarbitID.CA_TOTAL_TASKS_COMPLETED_ELITE),
    MASTER(5, VarbitID.CA_TOTAL_TASKS_COMPLETED_MASTER),
    GRANDMASTER(6, VarbitID.CA_TOTAL_TASKS_COMPLETED_GRANDMASTER);

    private final int id;
    private final int varbit;

    public int getCompletedCount(Client client) {
        // https://github.com/RuneStar/cs2-scripts/blob/master/scripts/%5Bproc%2Cca_tasks_completed_tier%5D.cs2
        client.runScript(4784, id);
        return client.getIntStack()[0];
    }
}

package com.runeprofile.data;

import lombok.Data;

import javax.annotation.Nullable;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

@Data
public class PlayerData {
    private String id;
    private String username;
    private Integer accountType;

    @Nullable
    private PlayerClanData clan;

    // skill name -> xp
    private Map<String, Integer> skills = new HashMap<>();

    // quest id -> quest state
    private Map<Integer, Integer> quests = new HashMap<>();

    // tier id -> completed count
    private Map<Integer, Integer> combatAchievementTiers = new HashMap<>();

    private List<AchievementDiaryTierData> achievementDiaryTiers = new ArrayList<>();

    // item id -> quantity
    private Map<Integer, Integer> items = new HashMap<>();
}

package com.runeprofile.data;

import lombok.Data;

@Data
public class DefaultClogPageData {
    // account id
    private final String id;
    // clog page name
    private final String page;
}

package com.runeprofile.data;


import lombok.Getter;
import lombok.RequiredArgsConstructor;

import javax.annotation.Nullable;

@RequiredArgsConstructor
@Getter
public class PlayerModelData {
    private final String accountHash;
    private final byte[] model;
    @Nullable
    private final byte[] petModel;
}

package com.runeprofile.data;

import lombok.Data;

import java.util.List;

@Data
public class CollectionLogPage {
    private final String name;
    private final List<CollectionLogItem> items;
}

package com.runeprofile.data;

import lombok.Getter;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;

@Slf4j
@Getter
@RequiredArgsConstructor
public enum AchievementDiary {
    KARAMJA(0),
    ARDOUGNE(1),
    FALADOR(2),
    FREMENNIK(3),
    KANDARIN(4),
    DESERT(5),
    LUMBRIDGE(6),
    MORYTANIA(7),
    VARROCK(8),
    WILDERNESS(9),
    WESTERN_PROVINCES(10),
    KOUREND(11);

    private final int id;

    public int[] getTiersCompletedCount(Client client) {
        // https://github.com/RuneStar/cs2-scripts/blob/master/scripts/%5Bproc%2Cdiary_completion_info%5D.cs2
        client.runScript(2200, id);
        int[] stack = client.getIntStack();

        int easy = stack[0];
        int medium = stack[3];
        int hard = stack[6];
        int elite = stack[9];

        return new int[]{easy, medium, hard, elite};
    }
}

package com.runeprofile.data;

import lombok.Data;

@Data
public class CollectionLogItem {
    private final int id;
    private final int quantity;
}
package com.runeprofile.data;

import lombok.Data;


@Data
public class ProfileSearchResult {
    private final String username;
}

package com.runeprofile.panels;

import com.runeprofile.RuneProfileApiClient;
import com.runeprofile.RuneProfilePlugin;
import com.runeprofile.data.DefaultClogPageData;
import com.runeprofile.utils.AccountHash;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.StructComposition;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.ui.PluginPanel;

import javax.inject.Inject;
import javax.swing.*;
import java.awt.*;
import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.CompletableFuture;

@Slf4j
public class DefaultClogPagePanel extends JPanel {
    private final RuneProfileApiClient runeProfileApiClient;
    private final ClientThread clientThread;
    private final Client client;

    private final String DEFAULT_CLOG_PAGE_KEY = "default_clog_page";

    private static final int COLLECTION_LOG_GROUPS = 2102;
    private static final int COLLECTION_LOG_TAB_ENUM = 683;
    private static final int COLLECTION_LOG_PAGE_NAME = 689;

    @Inject
    public DefaultClogPagePanel(ClientThread clientThread, Client client, ConfigManager configManager, RuneProfileApiClient runeProfileApiClient) {
        this.runeProfileApiClient = runeProfileApiClient;
        this.clientThread = clientThread;
        this.client = client;

        clientThread.invokeLater(() -> {
            List<String> clogPageNames = new ArrayList<>();

            int[] tabIds = client.getEnum(COLLECTION_LOG_GROUPS).getIntVals();
            for (int tabId : tabIds) {
                StructComposition tabStruct = client.getStructComposition(tabId);
                int[] pageIds = client.getEnum(tabStruct.getIntValue(COLLECTION_LOG_TAB_ENUM)).getIntVals();
                for (int pageId : pageIds) {
                    StructComposition pageStruct = client.getStructComposition(pageId);
                    String pageName = pageStruct.getStringValue(COLLECTION_LOG_PAGE_NAME);
                    clogPageNames.add(pageName);
                }
            }

            SwingUtilities.invokeLater(() -> {
                JLabel title = new JLabel("Default Collection Log Page");
                title.setAlignmentX(Component.LEFT_ALIGNMENT);


                JComboBox<String> selectMenu = new JComboBox<>(clogPageNames.toArray(new String[0]));
                selectMenu.setPreferredSize(new Dimension(PluginPanel.PANEL_WIDTH - 20, 30));
                selectMenu.setMinimumSize(new Dimension(0, 30));
                selectMenu.setAlignmentX(Component.LEFT_ALIGNMENT);
                selectMenu.setAlignmentY(Component.TOP_ALIGNMENT);
                selectMenu.setToolTipText("Select the collection log page that will be displayed by default on your profile when opened.");

                String storedPage = configManager.getRSProfileConfiguration(RuneProfilePlugin.CONFIG_GROUP, DEFAULT_CLOG_PAGE_KEY);
                int storedPageIndex = clogPageNames.indexOf(storedPage);
                selectMenu.setSelectedIndex(storedPageIndex == -1 ? 0 : storedPageIndex);

                selectMenu.addActionListener(e -> {
                    String selectedPage = (String) selectMenu.getSelectedItem();
                    if (selectedPage != null) {
                        configManager.setRSProfileConfiguration(RuneProfilePlugin.CONFIG_GROUP, DEFAULT_CLOG_PAGE_KEY, selectedPage);
                        handlePageSelection(selectedPage);
                    }
                });

                setLayout(new BoxLayout(this, BoxLayout.Y_AXIS));
                add(title);
                add(Box.createVerticalStrut(5));
                add(selectMenu);
            });
        });
    }

    private void handlePageSelection(String selectedPage) {
        CompletableFuture<DefaultClogPageData> dataFuture = new CompletableFuture<>();

        clientThread.invokeLater(() -> {
            dataFuture.complete(
                    new DefaultClogPageData(
                            AccountHash.getHashed(client),
                            selectedPage
                    )
            );
        });

        dataFuture.thenCompose(runeProfileApiClient::setDefaultClogPage);
    }
}

package com.runeprofile.panels;

import com.runeprofile.Icon;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.FontManager;
import net.runelite.client.util.LinkBrowser;
import net.runelite.client.util.SwingUtil;

import javax.inject.Inject;
import javax.swing.*;
import javax.swing.border.EmptyBorder;
import javax.swing.plaf.basic.BasicButtonUI;
import java.awt.*;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;

public class HeaderPanel extends JPanel {
    private static final int iconSize = 16;
    private final JPanel buttonsContainer;

    @Inject
    public HeaderPanel() {
        setLayout(new BorderLayout());
        setBorder(new EmptyBorder(10, 10, 10, 10));

        JLabel title = new JLabel("RuneProfile");
        title.setForeground(Color.WHITE);
        title.setFont(FontManager.getRunescapeBoldFont());

        buttonsContainer = new JPanel();
        buttonsContainer.setLayout(new GridLayout(1, 2, 4, 0));

        addHeaderButton(Icon.DISCORD.getIcon(iconSize, iconSize), "Join the Discord", "https://discord.com/invite/6XgBcePAfj");
        addHeaderButton(Icon.WEB.getIcon(iconSize, iconSize), "Visit the website.", "https://runeprofile.com");
        addHeaderButton(Icon.GITHUB.getIcon(iconSize, iconSize), "Report issues or contribute.", "https://github.com/ReinhardtR/runeprofile");

        add(title, BorderLayout.WEST);
        add(buttonsContainer, BorderLayout.EAST);
    }

    private void addHeaderButton(ImageIcon icon, String tooltip, String url) {
        JButton button = new JButton();
        SwingUtil.removeButtonDecorations(button);

        button.setIcon(icon);
        button.setToolTipText(tooltip);
        button.addActionListener(e -> LinkBrowser.browse(url));

        button.setUI(new BasicButtonUI());
        button.setBackground(ColorScheme.DARK_GRAY_COLOR);
        button.addMouseListener(new MouseAdapter() {
            @Override
            public void mouseEntered(MouseEvent e) {
                button.setBackground(ColorScheme.DARK_GRAY_HOVER_COLOR);
            }

            @Override
            public void mouseExited(MouseEvent e) {
                button.setBackground(ColorScheme.DARK_GRAY_COLOR);
            }
        });

        buttonsContainer.add(button);
    }
}

package com.runeprofile.panels;

import com.runeprofile.RuneProfilePlugin;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.ChatMessageType;
import net.runelite.api.Client;
import net.runelite.client.callback.ClientThread;

import javax.inject.Inject;
import javax.swing.*;
import java.awt.*;


@Slf4j
public class MainButtonsPanel extends JPanel {
    @Inject
    public MainButtonsPanel(RuneProfilePlugin plugin, Client client, ClientThread clientThread) {
        setLayout(new BorderLayout());
        JPanel wrapper = new JPanel(new GridLayout(0, 1, 0, 6));

        // Update Model
        JButton updateModelButton = createButton("Update Player Model");
        updateModelButton.addActionListener((e) -> {
            clientThread.invokeLater(() -> {
                client.addChatMessage(ChatMessageType.CONSOLE, "RuneProfile", "Updating player model...", "RuneProfile");
            });
            plugin.updateModelAsync();
        });
        wrapper.add(updateModelButton);

        // Open Profile
        JButton openProfileButton = createButton("Open Profile");
        openProfileButton.addActionListener(e -> {
            String username = RuneProfilePlugin.getClient().getLocalPlayer().getName();
            if (username == null) return;
            plugin.openProfileInBrowser(username);
        });

        wrapper.add(openProfileButton);

        if (plugin.isDeveloperMode()) {
            // DEV ONLY - generate hiscores icons
            JButton generateHiscoreIcons = createButton("DEV: Hiscores Icons");
            generateHiscoreIcons.addActionListener(e -> {
                plugin.DEV_generateHiscoreIconsJson();
            });
            wrapper.add(generateHiscoreIcons);

            // DEV ONLY - generate clan rank icons
            JButton generateClanRankIcons = createButton("DEV: Clan Rank Icons");
            generateClanRankIcons.addActionListener(e -> {
                plugin.DEV_generateClanRankIconsJson();
            });
            wrapper.add(generateClanRankIcons);
        }

        add(wrapper, BorderLayout.NORTH);
    }

    private JButton createButton(String text) {
        JButton button = new JButton(text);
        button.setPreferredSize(new Dimension(button.getPreferredSize().width, 30));
        return button;
    }
}


package com.runeprofile.panels;

import javax.inject.Inject;
import javax.swing.*;
import javax.swing.border.EmptyBorder;
import java.awt.*;

public class LayoutPluginPanel extends JPanel {
    @Inject
    public LayoutPluginPanel(MainButtonsPanel mainButtonsPanel, DefaultClogPagePanel defaultClogPagePanel, SearchPanel searchPanel) {
        setLayout(new BorderLayout());

        // Main content panel with vertical (flex-column-like) layout
        JPanel contentPanel = new JPanel();
        contentPanel.setLayout(new BoxLayout(contentPanel, BoxLayout.Y_AXIS));
        contentPanel.setBorder(new EmptyBorder(10, 10, 10, 10)); // padding around entire content

        // Create and add components
        mainButtonsPanel.setAlignmentX(Component.LEFT_ALIGNMENT);
        contentPanel.add(mainButtonsPanel);
        mainButtonsPanel.setMaximumSize(new Dimension(Short.MAX_VALUE, mainButtonsPanel.getPreferredSize().height)); // Limit vertical growth

        contentPanel.add(Box.createVerticalStrut(32)); // spacing between components

        defaultClogPagePanel.setAlignmentX(Component.LEFT_ALIGNMENT);
        contentPanel.add(defaultClogPagePanel);
        defaultClogPagePanel.setMaximumSize(new Dimension(Short.MAX_VALUE, defaultClogPagePanel.getPreferredSize().height));

        contentPanel.add(Box.createVerticalStrut(32));

        searchPanel.setAlignmentX(Component.LEFT_ALIGNMENT);
        contentPanel.add(searchPanel);
        searchPanel.setMaximumSize(new Dimension(Short.MAX_VALUE, searchPanel.getPreferredSize().height)); // Limit initial vertical growth

        contentPanel.add(Box.createVerticalGlue());

        JScrollPane scrollPane = new JScrollPane(contentPanel);
        scrollPane.setVerticalScrollBarPolicy(ScrollPaneConstants.VERTICAL_SCROLLBAR_AS_NEEDED);
        scrollPane.setHorizontalScrollBarPolicy(ScrollPaneConstants.HORIZONTAL_SCROLLBAR_NEVER);

        add(scrollPane, BorderLayout.CENTER);
    }
}
package com.runeprofile.panels;

import com.runeprofile.RuneProfileApiClient;
import com.runeprofile.RuneProfilePlugin;
import com.runeprofile.data.ProfileSearchResult;
import com.runeprofile.utils.RuneProfileApiException;
import com.runeprofile.utils.UsernameAutocompleter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.PluginPanel;
import net.runelite.client.ui.components.IconTextField;
import net.runelite.client.util.Text;

import javax.inject.Inject;
import javax.swing.*;
import java.awt.*;
import java.awt.event.KeyAdapter;
import java.awt.event.KeyEvent;
import java.util.Arrays;
import java.util.List;

@Slf4j
public class SearchPanel extends JPanel {
    private final RuneProfilePlugin plugin;

    private final JPanel resultsPanel;
    private final IconTextField searchField;

    @Inject
    public SearchPanel(RuneProfilePlugin plugin, RuneProfileApiClient runeProfileApiClient, UsernameAutocompleter usernameAutocompleter) {
        this.plugin = plugin;

        setLayout(new BoxLayout(this, BoxLayout.Y_AXIS));

        JLabel title = new JLabel("Search profiles");
        title.setAlignmentX(Component.LEFT_ALIGNMENT);
        add(title);

        searchField = new IconTextField();
        searchField.setIcon(IconTextField.Icon.SEARCH);
        searchField.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        searchField.setHoverBackgroundColor(ColorScheme.DARK_GRAY_HOVER_COLOR);
        searchField.setPreferredSize(new Dimension(PluginPanel.PANEL_WIDTH - 20, 30));
        searchField.setMinimumSize(new Dimension(0, 30));
        searchField.setAlignmentX(Component.LEFT_ALIGNMENT);
        searchField.setAlignmentY(Component.TOP_ALIGNMENT);

        add(Box.createVerticalStrut(5));
        add(searchField);
        add(Box.createVerticalStrut(5));

        resultsPanel = new JPanel();
        resultsPanel.setLayout(new BoxLayout(resultsPanel, BoxLayout.Y_AXIS));
        resultsPanel.setAlignmentY(Component.TOP_ALIGNMENT);
        resultsPanel.setAlignmentX(Component.LEFT_ALIGNMENT);

        searchField.addKeyListener(usernameAutocompleter);
        searchField.addKeyListener(new KeyAdapter() {
            @Override
            public void keyTyped(KeyEvent e) {
                String query = Text.sanitize(searchField.getText());
                if (query.isEmpty()) resultsPanel.removeAll();
            }
        });
        searchField.addClearListener(resultsPanel::removeAll);
        searchField.addActionListener(
                (e) -> {
                    String query = Text.sanitize(searchField.getText());
                    if (query.isEmpty()) resultsPanel.removeAll();

                    if (!query.isEmpty()) {
                        runeProfileApiClient.searchProfiles(query).whenComplete((results, ex) -> {
                            if (ex != null) {
                                log.error("Error searching profiles: ", ex);

                                if (ex instanceof RuneProfileApiException) {
                                    updateErrors("Error: " + ex.getMessage());
                                } else {
                                    updateErrors("An unexpected error occurred.");
                                }

                                return;
                            }
                            updateResults(Arrays.asList(results));
                        });
                    }
                }
        );

        add(resultsPanel);
    }

    private void updateErrors(String errorMessage) {
        resultsPanel.removeAll();
        JLabel errorLabel = new JLabel(errorMessage);
        errorLabel.setForeground(Color.RED);
        resultsPanel.add(errorLabel);
        resultsPanel.revalidate();
        resultsPanel.repaint();
    }

    private void updateResults(List<ProfileSearchResult> results) {
        resultsPanel.removeAll();

        if (results.isEmpty()) {
            JLabel noResults = new JLabel("No results found.");
            noResults.setForeground(Color.LIGHT_GRAY);
            resultsPanel.add(noResults);
        } else {
            for (int i = 0; i < results.size(); i++) {
                JButton resultButton = getResultButton(results, i);
                resultsPanel.add(resultButton);
            }
        }

        resultsPanel.revalidate();
        resultsPanel.repaint();
    }

    private JButton getResultButton(List<ProfileSearchResult> results, int i) {
        ProfileSearchResult result = results.get(i);

        JButton resultButton = new JButton(result.getUsername());
        int buttonHeight = 30;
        resultButton.setMaximumSize(new Dimension(Integer.MAX_VALUE, buttonHeight));
        resultButton.setPreferredSize(new Dimension(resultsPanel.getWidth(), buttonHeight));
        resultButton.setMinimumSize(new Dimension(0, buttonHeight));
        resultButton.setAlignmentX(Component.LEFT_ALIGNMENT);
        resultButton.setToolTipText("Open in browser");

        resultButton.addActionListener((e) -> plugin.openProfileInBrowser(result.getUsername()));
        return resultButton;
    }
}

package com.runeprofile.panels;

import net.runelite.client.ui.FontManager;

import javax.swing.*;
import javax.swing.border.EmptyBorder;
import java.awt.*;

public class InvalidPanel extends JPanel {
	private final JLabel hintText = new JLabel();

	public InvalidPanel() {
		setBorder(new EmptyBorder(50, 10, 0, 10));
		setLayout(new BorderLayout());

		JPanel wrapper = new JPanel(new BorderLayout());

		JLabel titleText = new JLabel("RuneProfile");
		titleText.setFont(FontManager.getRunescapeFont());
		titleText.setForeground(Color.WHITE);
		titleText.setHorizontalAlignment(SwingConstants.CENTER);
		wrapper.add(titleText, BorderLayout.NORTH);

		hintText.setFont(FontManager.getRunescapeSmallFont());
		hintText.setForeground(Color.GRAY);
		hintText.setHorizontalAlignment(SwingConstants.CENTER);
		wrapper.add(hintText, BorderLayout.CENTER);

		add(wrapper, BorderLayout.NORTH);
	}

	public void setHintText(String text) {
		SwingUtilities.invokeLater(() -> hintText.setText(text));
	}
}

/*
 *
 *  * Copyright (c) 2021, Senmori
 *  * All rights reserved.
 *  *
 *  * Redistribution and use in source and binary forms, with or without
 *  * modification, are permitted provided that the following conditions are met:
 *  *
 *  * 1. Redistributions of source code must retain the above copyright notice, this
 *  *    list of conditions and the following disclaimer.
 *  * 2. Redistributions in binary form must reproduce the above copyright notice,
 *  *    this list of conditions and the following disclaimer in the documentation
 *  *    and/or other materials provided with the distribution.
 *  *
 *  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 *  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 *  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 *  * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 *  * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 *  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 *  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 *  * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 *  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 *  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 */

package com.runeprofile;

import net.runelite.client.util.ImageUtil;

import javax.swing.*;
import java.awt.image.BufferedImage;

public enum Icon {
    LOGO("/logo.png"),

    WEB("/web.png"),
    DISCORD("/discord.png"),
    GITHUB("/github.png");

    private final String file;

    Icon(String file) {
        this.file = file;
    }

    public BufferedImage getImage() {
        return ImageUtil.loadImageResource(RuneProfilePlugin.class, file);
    }

    public ImageIcon getIcon(int width, int height) {
        return new ImageIcon(ImageUtil.resizeImage(getImage(), width, height));
    }
}
/*
 * Copyright (c) 2025, andmcadams
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

package com.runeprofile.ui;

import com.google.inject.Inject;
import com.runeprofile.RuneProfileConfig;
import com.runeprofile.RuneProfilePlugin;
import lombok.Getter;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.*;
import net.runelite.api.annotations.Component;
import net.runelite.api.events.ScriptPostFired;
import net.runelite.api.gameval.VarbitID;
import net.runelite.api.widgets.*;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.config.RuneLiteConfig;
import net.runelite.client.eventbus.EventBus;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.events.ConfigChanged;

import static java.lang.Math.round;

@Slf4j
public class SyncButtonManager {
    private static final int COLLECTION_LOG_SETUP = 7797;
    private static final int[] SPRITE_IDS_INACTIVE = {
            SpriteID.DIALOG_BACKGROUND,
            SpriteID.EQUIPMENT_BUTTON_METAL_CORNER_TOP_LEFT,
            SpriteID.EQUIPMENT_BUTTON_METAL_CORNER_TOP_RIGHT,
            SpriteID.EQUIPMENT_BUTTON_METAL_CORNER_BOTTOM_LEFT,
            SpriteID.EQUIPMENT_BUTTON_METAL_CORNER_BOTTOM_RIGHT,
            SpriteID.EQUIPMENT_BUTTON_EDGE_LEFT,
            SpriteID.EQUIPMENT_BUTTON_EDGE_TOP,
            SpriteID.EQUIPMENT_BUTTON_EDGE_RIGHT,
            SpriteID.EQUIPMENT_BUTTON_EDGE_BOTTOM,
    };

    private static final int[] SPRITE_IDS_ACTIVE = {
            SpriteID.RESIZEABLE_MODE_SIDE_PANEL_BACKGROUND,
            SpriteID.EQUIPMENT_BUTTON_METAL_CORNER_TOP_LEFT_HOVERED,
            SpriteID.EQUIPMENT_BUTTON_METAL_CORNER_TOP_RIGHT_HOVERED,
            SpriteID.EQUIPMENT_BUTTON_METAL_CORNER_BOTTOM_LEFT_HOVERED,
            SpriteID.EQUIPMENT_BUTTON_METAL_CORNER_BOTTOM_RIGHT_HOVERED,
            SpriteID.EQUIPMENT_BUTTON_EDGE_LEFT_HOVERED,
            SpriteID.EQUIPMENT_BUTTON_EDGE_TOP_HOVERED,
            SpriteID.EQUIPMENT_BUTTON_EDGE_RIGHT_HOVERED,
            SpriteID.EQUIPMENT_BUTTON_EDGE_BOTTOM_HOVERED,
    };

    private static final int FONT_COLOUR_INACTIVE = 0xd6d6d6;
    private static final int FONT_COLOUR_ACTIVE = 0xffffff;
    private static final int CLOSE_BUTTON_OFFSET = 28;
    private static final int BUTTON_WIDTH = 80;
    private static final int BUTTON_OFFSET = CLOSE_BUTTON_OFFSET + 5;
    private int lastAttemptedUpdate = -1;

    private final Client client;
    private final ClientThread clientThread;
    private final EventBus eventBus;
    private final ConfigManager configManager;
    private final RuneProfileConfig config;

    @Inject
    private SyncButtonManager(
            Client client,
            ClientThread clientThread,
            EventBus eventBus,
            ConfigManager configManager,
            RuneProfileConfig config
    ) {
        this.client = client;
        this.clientThread = clientThread;
        this.eventBus = eventBus;
        this.configManager = configManager;
        this.config = config;
    }

    public void startUp() {
        eventBus.register(this);

        if (config.showClogSyncButton()) {
            clientThread.invokeLater(() -> tryAddButton(this::onButtonClick));
        }
    }

    public void shutDown() {
        eventBus.unregister(this);

        clientThread.invokeLater(this::removeButton);
    }

    @Subscribe
    public void onConfigChanged(ConfigChanged event) {
        if (!event.getGroup().equals(RuneProfilePlugin.CONFIG_GROUP) || client == null) return;

        if (config.showClogSyncButton()) {
            clientThread.invokeLater(() -> tryAddButton(this::onButtonClick));
        } else {
            clientThread.invokeLater(this::removeButton);
        }
    }

    @Getter
    @RequiredArgsConstructor
    enum Screen {
        // First number is col log container (inner) and second is search button id
        COLLECTION_LOG(40697944, 40697932, 40697943);

        @Getter(onMethod_ = @Component)
        private final int parentId;

        @Getter(onMethod_ = @Component)
        private final int searchButtonId;

        @Getter(onMethod_ = @Component)
        private final int collectionLogContainer;
    }

    void tryAddButton(Runnable onClick) {
        for (Screen screen : Screen.values()) {
            addButton(screen, onClick);
        }
    }

    @Subscribe
    public void onScriptPostFired(ScriptPostFired scriptPostFired) {
        if (!config.showClogSyncButton()) return;

        if (scriptPostFired.getScriptId() == COLLECTION_LOG_SETUP) {
            removeButton();
            addButton(Screen.COLLECTION_LOG, this::onButtonClick);
        }
    }

    void onButtonClick() {
        if (lastAttemptedUpdate != -1 && lastAttemptedUpdate + 50 > client.getTickCount()) {
            client.addChatMessage(ChatMessageType.CONSOLE, "RuneProfile", "Last update within 30 seconds. You can update again in " + round((lastAttemptedUpdate + 50 - client.getTickCount()) * 0.6) + " seconds.", "RuneProfile");
            return;
        }
        lastAttemptedUpdate = client.getTickCount();

        client.menuAction(-1, 40697932, MenuAction.CC_OP, 1, -1, "Search", null);
        client.runScript(2240);
        client.addChatMessage(ChatMessageType.CONSOLE, "RuneProfile", "Updating your profile...", "RuneProfile");
    }

    void addButton(Screen screen, Runnable onClick) {
        // disallow updating from the adventure log, to avoid players updating their profile
        // while viewing other players collection logs using the POH adventure log.
        boolean isOpenedFromAdventureLog = client.getVarbitValue(VarbitID.COLLECTION_POH_HOST_BOOK_OPEN) == 1;
        if (isOpenedFromAdventureLog) return;

        Widget parent = client.getWidget(screen.getParentId());
        Widget searchButton = client.getWidget(screen.getSearchButtonId());
        Widget collectionLogContainer = client.getWidget(screen.getCollectionLogContainer());
        Widget[] containerChildren;
        Widget draggableTopbar;
        if (parent == null || searchButton == null || collectionLogContainer == null ||
                (containerChildren = collectionLogContainer.getChildren()) == null ||
                (draggableTopbar = containerChildren[0]) == null) {
            return;
        }

        final int w = BUTTON_WIDTH;
        final int h = searchButton.getOriginalHeight();
        final int x = BUTTON_OFFSET;
        final int y = searchButton.getOriginalY();
        final int cornerDim = 9;

        final Widget[] spriteWidgets = new Widget[9];

        spriteWidgets[0] = parent.createChild(-1, WidgetType.GRAPHIC)
                .setSpriteId(SPRITE_IDS_INACTIVE[0])
                .setPos(x, y)
                .setSize(w, h)
                .setXPositionMode(WidgetPositionMode.ABSOLUTE_RIGHT)
                .setYPositionMode(searchButton.getYPositionMode());

        spriteWidgets[1] = parent.createChild(-1, WidgetType.GRAPHIC)
                .setSpriteId(SPRITE_IDS_INACTIVE[1])
                .setXPositionMode(WidgetPositionMode.ABSOLUTE_RIGHT)
                .setSize(cornerDim, cornerDim)
                .setPos(x + (w - cornerDim), y);
        spriteWidgets[2] = parent.createChild(-1, WidgetType.GRAPHIC)
                .setSpriteId(SPRITE_IDS_INACTIVE[2])
                .setXPositionMode(WidgetPositionMode.ABSOLUTE_RIGHT)
                .setSize(cornerDim, cornerDim)
                .setPos(x, y);
        spriteWidgets[3] = parent.createChild(-1, WidgetType.GRAPHIC)
                .setSpriteId(SPRITE_IDS_INACTIVE[3])
                .setXPositionMode(WidgetPositionMode.ABSOLUTE_RIGHT)
                .setSize(cornerDim, cornerDim)
                .setPos(x + (w - cornerDim), y + h - cornerDim);
        spriteWidgets[4] = parent.createChild(-1, WidgetType.GRAPHIC)
                .setSpriteId(SPRITE_IDS_INACTIVE[4])
                .setXPositionMode(WidgetPositionMode.ABSOLUTE_RIGHT)
                .setSize(cornerDim, cornerDim)
                .setPos(x, y + h - cornerDim);
        // Left and right edges
        int sideWidth = 9;
        int sideHeight = 4;
        spriteWidgets[5] = parent.createChild(-1, WidgetType.GRAPHIC)
                .setSpriteId(SPRITE_IDS_INACTIVE[5])
                .setXPositionMode(WidgetPositionMode.ABSOLUTE_RIGHT)
                .setSize(sideWidth, sideHeight)
                .setPos(x + (w - sideWidth), y + cornerDim);
        spriteWidgets[7] = parent.createChild(-1, WidgetType.GRAPHIC)
                .setSpriteId(SPRITE_IDS_INACTIVE[7])
                .setXPositionMode(WidgetPositionMode.ABSOLUTE_RIGHT)
                .setSize(sideWidth, sideHeight)
                .setPos(x, y + cornerDim);

        // Top and bottom edges
        int topWidth = BUTTON_WIDTH - 2 * cornerDim;
        int topHeight = 9;
        spriteWidgets[6] = parent.createChild(-1, WidgetType.GRAPHIC)
                .setSpriteId(SPRITE_IDS_INACTIVE[6])
                .setXPositionMode(WidgetPositionMode.ABSOLUTE_RIGHT)
                .setSize(topWidth, topHeight)
                .setPos(x + cornerDim, y);
        spriteWidgets[8] = parent.createChild(-1, WidgetType.GRAPHIC)
                .setSpriteId(SPRITE_IDS_INACTIVE[8])
                .setXPositionMode(WidgetPositionMode.ABSOLUTE_RIGHT)
                .setSize(topWidth, topHeight)
                .setPos(x + cornerDim, y + h - topHeight);
        for (int i = 0; i < 9; i++) {
            spriteWidgets[i].revalidate();
        }

        final Widget text = parent.createChild(-1, WidgetType.TEXT)
                .setText("RuneProfile")
                .setTextColor(FONT_COLOUR_INACTIVE)
                .setFontId(FontID.PLAIN_11)
                .setTextShadowed(true)
                .setXPositionMode(WidgetPositionMode.ABSOLUTE_RIGHT)
                .setXTextAlignment(WidgetTextAlignment.CENTER)
                .setYTextAlignment(WidgetTextAlignment.CENTER)
                .setPos(x, y)
                .setSize(w, h)
                .setYPositionMode(searchButton.getYPositionMode());
        text.revalidate();

        // We'll give the text layer the listeners since it covers the whole area
        text.setHasListener(true);
        text.setOnMouseOverListener((JavaScriptCallback) ev ->
        {
            for (int i = 0; i <= 8; i++) {
                spriteWidgets[i].setSpriteId(SPRITE_IDS_ACTIVE[i]);
            }
            text.setTextColor(FONT_COLOUR_ACTIVE);
        });
        text.setOnMouseLeaveListener((JavaScriptCallback) ev ->
        {
            for (int i = 0; i <= 8; i++) {
                spriteWidgets[i].setSpriteId(SPRITE_IDS_INACTIVE[i]);
            }
            text.setTextColor(FONT_COLOUR_INACTIVE);
        });

        // Register a click listener
        text.setAction(0, "Update your RuneProfile");
        text.setOnOpListener((JavaScriptCallback) ev -> onClick.run());

        boolean isWikiSyncPluginEnabled = Boolean.parseBoolean(configManager.getConfiguration(RuneLiteConfig.GROUP_NAME, "wikisyncplugin"));
        if (!isWikiSyncPluginEnabled) {
            // Shrink the top bar to avoid overlapping the new button
            draggableTopbar.setOriginalWidth(draggableTopbar.getOriginalWidth() - (w + (x - CLOSE_BUTTON_OFFSET)));
        }
        draggableTopbar.revalidate();

        // recompute locations / sizes on parent
        parent.revalidate();
    }

    void removeButton() {
        for (Screen screen : Screen.values()) {
            Widget parent = client.getWidget(screen.getParentId());
            if (parent != null) {
                parent.deleteAllChildren();
                parent.revalidate();
            }
        }
    }
}
package com.runeprofile;

import net.runelite.client.config.Config;
import net.runelite.client.config.ConfigGroup;
import net.runelite.client.config.ConfigItem;

@ConfigGroup(RuneProfilePlugin.CONFIG_GROUP)
public interface RuneProfileConfig extends Config {
    @ConfigItem(
            keyName = "update_on_logout",
            name = "Update on logout",
            description = "Automatically update your RuneProfile on logout. (Excluding model and Collection Log)"
    )
    default boolean updateOnLogout() {
        return true;
    }

    @ConfigItem(
            keyName = "include_clan_data",
            name = "Include Clan in Profile",
            description = "Include your clan in your profile data when updating."
    )
    default boolean includeClanData() {
        return true;
    }

    @ConfigItem(
            keyName = "menu_lookup_option",
            name = "Menu option",
            description = "Add RuneProfile option to menus"
    )
    default boolean showMenuLookupOption() {
        return false;
    }

    @ConfigItem(
            keyName = "show_side_panel",
            name = "Show the RuneProfile side panel",
            description = "Adds RuneProfile to the RuneLite plugin side bar."
    )
    default boolean showSidePanel() {
        return true;
    }

    @ConfigItem(
            keyName = "show_clog_sync_button",
            name = "Enable RuneProfile button",
            description = "Shows the RuneProfile button in the Collection Log window."
    )
    default boolean showClogSyncButton() {
        return true;
    }

    @ConfigItem(
            keyName = "log_command",
            name = "Enable !log command",
            description = "Enables the !log command in the game chat."
    )
    default boolean enableLogCommand() {
        return true;
    }
}

package com.runeprofile;

import com.google.common.collect.ImmutableList;
import com.google.gson.Gson;
import com.google.inject.Provides;

import java.io.*;
import java.util.*;
import java.util.concurrent.ScheduledExecutorService;

import com.runeprofile.data.*;
import com.runeprofile.modelexporter.ModelExporter;
import com.runeprofile.ui.SyncButtonManager;
import com.runeprofile.utils.AccountHash;
import com.runeprofile.utils.RuneProfileApiException;
import lombok.Getter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.*;
import net.runelite.api.clan.ClanMember;
import net.runelite.api.clan.ClanRank;
import net.runelite.api.clan.ClanSettings;
import net.runelite.api.clan.ClanTitle;
import net.runelite.api.events.*;
import net.runelite.api.gameval.InterfaceID;
import net.runelite.api.gameval.VarbitID;
import net.runelite.api.widgets.WidgetUtil;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.config.RuneScapeProfileType;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.events.ConfigChanged;
import net.runelite.client.game.ItemManager;
import net.runelite.client.game.SpriteManager;
import net.runelite.client.hiscore.HiscoreSkill;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.plugins.PluginDescriptor;
import net.runelite.client.ui.ClientToolbar;
import net.runelite.client.ui.NavigationButton;
import net.runelite.client.util.ImageUtil;
import net.runelite.client.chat.ChatCommandManager;
import net.runelite.client.util.LinkBrowser;
import net.runelite.client.util.Text;

import javax.imageio.ImageIO;
import javax.inject.Inject;
import javax.inject.Named;
import java.awt.image.BufferedImage;
import java.util.concurrent.CompletableFuture;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.stream.Collectors;

@Slf4j
@PluginDescriptor(
        name = "RuneProfile",
        description = "Share your achievements on RuneProfile.com",
        tags = {"runeprofile", "rune", "profile", "collection"}
)
public class RuneProfilePlugin extends Plugin {
    public static final String CONFIG_GROUP = "runeprofile";
    private static RuneProfilePlugin instance;

    @Inject
    private Client client;

    @Inject
    private RuneProfileConfig config;

    @Inject
    private RuneProfileApiClient runeProfileApiClient;

    @Inject
    private ClientToolbar clientToolbar;

    @Inject
    private ClientThread clientThread;

    @Inject
    private ItemManager itemManager;

    @Inject
    private SpriteManager spriteManager;

    @Inject
    private ChatCommandManager chatCommandManager;

    @Inject
    private Gson gson;

    @Inject
    @Named("developerMode")
    @Getter
    private boolean developerMode;

    @Inject
    private ScheduledExecutorService scheduledExecutorService;

    private RuneProfilePanel runeProfilePanel;
    private NavigationButton navigationButton;

    @Inject
    private SyncButtonManager syncButtonManager;

    // menu option
    private static final String KICK_OPTION = "Kick";
    private static final ImmutableList<String> AFTER_OPTIONS = ImmutableList.of("Message", "Add ignore", "Remove friend", "Delete", KICK_OPTION);

    // collection log
    private final Map<Integer, Integer> playerItems = new HashMap<>();
    private int tickCollectionLogScriptFired = -1;
    private final Map<Integer, Integer> loadedItemIcons = new HashMap<>();
    private final String COLLECTION_LOG_COMMAND = "!log";
    private final Pattern COLLECTION_LOG_COMMAND_PATTERN = Pattern.compile("^(" + COLLECTION_LOG_COMMAND + ")\\s+([a-zA-Z]+(?: [a-zA-Z]+)*)$", Pattern.CASE_INSENSITIVE);

    public static Client getClient() {
        return instance.client;
    }

    @Provides
    RuneProfileConfig provideConfig(ConfigManager configManager) {
        return configManager.getConfig(RuneProfileConfig.class);
    }

    @Override
    protected void startUp() {
        instance = this;

        this.runeProfilePanel = injector.getInstance(RuneProfilePanel.class);
        final BufferedImage toolbarIcon = Icon.LOGO.getImage();

        navigationButton = NavigationButton.builder()
                .tooltip("RuneProfile")
                .icon(toolbarIcon)
                .panel(runeProfilePanel)
                .priority(4)
                .build();

        GameState state = client.getGameState();
        updatePanelState(state);

        if (config.showSidePanel()) {
            clientToolbar.addNavigation(navigationButton);
        }

        if (config.enableLogCommand()) {
            chatCommandManager.registerCommand(COLLECTION_LOG_COMMAND, this::executeLogCommand);
        }

        syncButtonManager.startUp();
    }

    @Override
    protected void shutDown() {
        clientToolbar.removeNavigation(navigationButton);
        chatCommandManager.unregisterCommand(COLLECTION_LOG_COMMAND);
        syncButtonManager.shutDown();
    }


    @Subscribe
    public void onConfigChanged(ConfigChanged event) {
        if (!event.getGroup().equals(CONFIG_GROUP) || client == null) return;

        if (config.enableLogCommand()) {
            chatCommandManager.registerCommand(COLLECTION_LOG_COMMAND, this::executeLogCommand);
        } else {
            chatCommandManager.unregisterCommand(COLLECTION_LOG_COMMAND);
        }

        if (config.showSidePanel()) {
            clientToolbar.addNavigation(navigationButton);
        } else {
            clientToolbar.removeNavigation(navigationButton);
        }
    }

    @Subscribe
    private void onGameStateChanged(GameStateChanged gameStateChanged) {
        GameState state = gameStateChanged.getGameState();

        updatePanelState(state);

        // clear player state
        switch (state) {
            case HOPPING:
            case LOGGING_IN:
            case CONNECTION_LOST:
                playerItems.clear();
                break;
        }

        if (state == GameState.LOGIN_SCREEN) {
            // update on logout
            if (config.updateOnLogout() && client.getLocalPlayer() != null) {
                new Thread(this::updateProfileAsync).start();
            }
        }
    }

    @Subscribe
    public void onGameTick(GameTick gameTick) {
        int tick = client.getTickCount();
        boolean hasClogScriptFired = tickCollectionLogScriptFired != -1;
        boolean hasBufferPassed = tickCollectionLogScriptFired + 2 < tick;
        if (hasClogScriptFired && hasBufferPassed) {
            tickCollectionLogScriptFired = -1;
            scheduledExecutorService.execute(this::updateProfileAsync);
        }
    }

    @Subscribe
    public void onScriptPreFired(ScriptPreFired preFired) {
        if (preFired.getScriptId() == 4100) {
            tickCollectionLogScriptFired = client.getTickCount();

            Object[] args = preFired.getScriptEvent().getArguments();
            int itemId = (int) args[1];
            int quantity = (int) args[2];

            playerItems.put(itemId, quantity);
        }
    }

    @Subscribe
    public void onScriptPostFired(ScriptPostFired postFired) {
        syncButtonManager.onScriptPostFired(postFired);
    }

    private void updatePanelState(GameState state) {
        if (state == GameState.LOGGED_IN) {
            if (!isValidProfileType()) {
                runeProfilePanel.loadInvalidRequestState();
            } else {
                runeProfilePanel.loadValidState();
            }
        } else {
            runeProfilePanel.loadInvalidState();
        }
    }

    @Subscribe
    public void onMenuEntryAdded(MenuEntryAdded event) {
        if (!config.showMenuLookupOption()) return;

        int groupId = WidgetUtil.componentToInterface(event.getActionParam1());
        String option = event.getOption();

        if (!AFTER_OPTIONS.contains(option)
                // prevent duplicate menu options in friends list
                || (option.equals("Delete") && groupId != InterfaceID.IGNORE)) {
            return;
        }

        boolean addMenuLookup = (groupId == InterfaceID.FRIENDS
                || groupId == InterfaceID.CHATCHANNEL_CURRENT
                || groupId == InterfaceID.CLANS_SIDEPANEL
                || groupId == InterfaceID.CLANS_GUEST_SIDEPANEL
                // prevent from adding for Kick option (interferes with the raiding party one)
                || groupId == InterfaceID.CHATBOX && !KICK_OPTION.equals(option)
                || groupId == InterfaceID.RAIDS_SIDEPANEL
                || groupId == InterfaceID.PM_CHAT
                || groupId == InterfaceID.IGNORE);

        if (addMenuLookup) {
            String username = Text.toJagexName(Text.removeTags(event.getTarget()));

            client.getMenu().createMenuEntry(-2)
                    .setTarget(event.getTarget())
                    .setOption("RuneProfile")
                    .setType(MenuAction.RUNELITE)
                    .setIdentifier(event.getIdentifier())
                    .onClick(e -> openProfileInBrowser(username));
        }
    }

    public void openProfileInBrowser(String username) {
        String url = "https://www.runeprofile.com/" + username.replace(" ", "%20");
        LinkBrowser.browse(url);
    }

    private void executeLogCommand(ChatMessage chatMessage, String message) {
        log.debug("Executing log command: {}", message);
        Matcher commandMatcher = COLLECTION_LOG_COMMAND_PATTERN.matcher(message);
        if (!commandMatcher.matches()) {
            log.debug("Invalid command format");
            return;
        }

        String pageName = commandMatcher.group(2);
        if (pageName == null || pageName.isEmpty()) {
            log.debug("Invalid page name");
            return;
        }

        String senderName = chatMessage.getType().equals(ChatMessageType.PRIVATECHATOUT)
                ? client.getLocalPlayer().getName()
                : Text.sanitize(chatMessage.getName());

        runeProfileApiClient.getCollectionLogPage(senderName, pageName).whenComplete((page, ex) -> {
            clientThread.invokeLater(() -> {
                if (ex != null) {
                    final String errorMessage = getApiErrorMessage(ex, "Failed to load collection log page.");
                    updateChatMessage(chatMessage, errorMessage);
                    return;
                }

                loadPageIcons(page);

                List<CollectionLogItem> items = page.getItems();
                StringBuilder itemBuilder = new StringBuilder();
                for (CollectionLogItem item : items) {
                    if (item.getQuantity() < 1) continue;

                    String itemString = "<img=" + loadedItemIcons.get(item.getId()) + ">";
                    if (item.getQuantity() > 1) {
                        itemString += "x" + item.getQuantity();
                    }
                    itemString += "  ";
                    itemBuilder.append(itemString);
                }

                int obtainedItemsCount = (int) items.stream().filter(item -> item.getQuantity() > 0).count();
                int totalItemsCount = items.size();

                final String replacementMessage = page.getName() + " " + "(" + obtainedItemsCount + "/" + totalItemsCount + ")" + " : " + itemBuilder;
                updateChatMessage(chatMessage, replacementMessage);
            });
        });
    }


    public void updateProfileAsync() {
        log.debug("Executing update profile method");

        isValidRequest();

        getPlayerDataAsync().thenCompose((data) -> runeProfileApiClient.updateProfileAsync(data))
                .whenComplete((result, ex) -> {
                    if (ex != null) {
                        log.error("Error updating profile", ex);

                        final String errorMessage = getApiErrorMessage(ex, "Failed to update your profile.");

                        clientThread.invokeLater(() -> {
                            client.addChatMessage(ChatMessageType.CONSOLE, "RuneProfile", errorMessage, "RuneProfile");
                        });

                        throw new RuneProfileApiException(errorMessage);
                    }

                    clientThread.invokeLater(() -> {
                        client.addChatMessage(ChatMessageType.CONSOLE, "RuneProfile", "Your profile has been updated!", "RuneProfile");
                    });
                });
    }

    public void updateModelAsync() {
        isValidRequest();

        CompletableFuture<PlayerModelData> dataFuture = new CompletableFuture<>();

        clientThread.invokeLater(() -> {
            String accountHash = AccountHash.getHashed(client);

            Player player = client.getLocalPlayer();
            Model model = player.getModel();

            byte[] modelBytes = null;
            try {
                modelBytes = ModelExporter.toBytes(model);
            } catch (IOException e) {
                dataFuture.completeExceptionally(e);
            }

            NPC pet = client.getFollower();
            Model petModel = pet != null ? pet.getModel() : null;

            byte[] petModelBytes = null;
            if (petModel != null) {
                try {
                    petModelBytes = ModelExporter.toBytes(petModel);
                } catch (IOException e) {
                    dataFuture.completeExceptionally(e);
                }
            }

            dataFuture.complete(new PlayerModelData(accountHash, modelBytes, petModelBytes));
        });

        dataFuture.thenCompose((data) -> runeProfileApiClient.updateModelAsync(data)
                .whenComplete((result, ex) -> {
                    if (ex != null) {
                        log.error("Error updating model", ex);

                        final String errorMessage = getApiErrorMessage(ex, "Failed to update your player model.");

                        clientThread.invokeLater(() -> {
                            client.addChatMessage(ChatMessageType.CONSOLE, "RuneProfile", errorMessage, "RuneProfile");
                        });

                        throw new RuneProfileApiException(errorMessage);
                    }

                    clientThread.invokeLater(() -> {
                        client.addChatMessage(ChatMessageType.CONSOLE, "RuneProfile", "Your player model has been updated!", "RuneProfile");
                    });
                }));
    }

    private CompletableFuture<PlayerData> getPlayerDataAsync() {
        CompletableFuture<PlayerData> playerDataFuture = new CompletableFuture<>();
        clientThread.invokeLater(() -> {
            PlayerData playerData = new PlayerData();

            Player player = client.getLocalPlayer();
            String username = player.getName();

            // general
            playerData.setId(AccountHash.getHashed(client));
            playerData.setUsername(username);
            playerData.setAccountType(client.getVarbitValue(VarbitID.IRONMAN));

            // clan
            playerData.setClan(getPlayerClanData(player));

            // skills
            for (Skill skill : Skill.values()) {
                String name = skill.getName();
                int xp = client.getSkillExperience(skill);
                playerData.getSkills().put(name, xp);
            }

            // quests
            for (Quest quest : Quest.values()) {
                int id = quest.getId();
                QuestState stateEnum = quest.getState(client);
                int state = 0;
                if (stateEnum == QuestState.IN_PROGRESS) {
                    state = 1;
                } else if (stateEnum == QuestState.FINISHED) {
                    state = 2;
                }
                playerData.getQuests().put(id, state);
            }

            // combat achievement tiers
            for (CombatAchievementTier tier : CombatAchievementTier.values()) {
                int id = tier.getId();
                int completedCount = tier.getCompletedCount(client);
                playerData.getCombatAchievementTiers().put(id, completedCount);
            }

            // achievement diary tiers
            for (AchievementDiary diary : AchievementDiary.values()) {
                int areaId = diary.getId();
                int[] completedCounts = diary.getTiersCompletedCount(client);
                for (int tierIndex = 0; tierIndex < completedCounts.length; tierIndex++) {
                    int completedCount = completedCounts[tierIndex];
                    playerData.getAchievementDiaryTiers().add(new AchievementDiaryTierData(areaId, tierIndex, completedCount));
                }
            }

            // items
            playerData.setItems(playerItems);

            playerDataFuture.complete(playerData);
        });
        return playerDataFuture;
    }

    private PlayerClanData getPlayerClanData(Player player) {
        if (!config.includeClanData()) return new PlayerClanData("", -1, -1, "");

        ClanSettings clanSettings = client.getClanSettings();
        if (clanSettings == null) return null;

        ClanMember member = clanSettings.findMember(player.getName());
        if (member == null) return null;

        ClanRank rank = member.getRank();
        if (rank == null) return null;

        ClanTitle title = clanSettings.titleForRank(rank);
        if (title == null) return null;

        return new PlayerClanData(clanSettings.getName(), rank.getRank(), title.getId(), title.getName());
    }

    private void isValidRequest() throws IllegalStateException {
        log.debug("Validating request");
        if (!isValidProfileType()) {
            clientThread.invokeLater(() -> {
                log.debug("Invalid profile type");
                client.addChatMessage(ChatMessageType.CONSOLE, "RuneProfile", "Invalid profile type. Please hop to a standard world.", "RuneProfile");
            });
            throw new IllegalStateException("Invalid profile type");
        }

        long accountHash = client.getAccountHash();

        if (accountHash == -1) {
            log.debug("Failed to get account hash");
            throw new IllegalStateException("Failed to get AccountHash");
        }

        Player player = client.getLocalPlayer();

        if (player == null || player.getName() == null) {
            log.debug("Failed to get player");
            throw new IllegalStateException("Failed to get Player");
        }
    }

    @SuppressWarnings("BooleanMethodIsAlwaysInverted")
    private boolean isValidProfileType() {
        RuneScapeProfileType profileType = RuneScapeProfileType.getCurrent(client);
        return profileType.equals(RuneScapeProfileType.STANDARD);
    }

    private void updateChatMessage(ChatMessage chatMessage, String message) {
        log.debug("Updating chat message: {}", message);
        chatMessage.getMessageNode().setValue(message);
        client.runScript(ScriptID.BUILD_CHATBOX);
    }

    private void loadPageIcons(CollectionLogPage page) {
        List<CollectionLogItem> itemsToLoad = page.getItems()
                .stream()
                .filter(item -> !loadedItemIcons.containsKey(item.getId()))
                .collect(Collectors.toList());

        final IndexedSprite[] modIcons = client.getModIcons();

        final IndexedSprite[] newModIcons = Arrays.copyOf(modIcons, modIcons.length + itemsToLoad.size());
        int modIconIdx = modIcons.length;

        for (int i = 0; i < itemsToLoad.size(); i++) {
            final CollectionLogItem item = itemsToLoad.get(i);
            final ItemComposition itemComposition = itemManager.getItemComposition(item.getId());
            final BufferedImage image = ImageUtil.resizeImage(itemManager.getImage(itemComposition.getId()), 18, 16);
            final IndexedSprite sprite = ImageUtil.getImageIndexedSprite(image, client);
            final int spriteIndex = modIconIdx + i;

            newModIcons[spriteIndex] = sprite;
            loadedItemIcons.put(item.getId(), spriteIndex);
        }

        client.setModIcons(newModIcons);
    }

    public static String getApiErrorMessage(Throwable ex, String defaultMessage) {
        String result = defaultMessage;

        if (ex instanceof RuneProfileApiException) {
            result = ex.getMessage();
        } else if (ex.getCause() instanceof RuneProfileApiException) {
            result = ex.getCause().getMessage();
        }

        return result;
    }

    public void DEV_generateHiscoreIconsJson() {
        clientThread.invokeLater(() -> {
            Map<String, String> icons = new HashMap<>();
            for (HiscoreSkill skill : HiscoreSkill.values()) {
                String key = skill.getName();
                int spriteId = skill.getSpriteId();

                if (spriteId == -1) {
                    continue;
                }

                final BufferedImage sprite = spriteManager.getSprite(spriteId, 0);

                if (sprite == null) {
                    log.debug("Failed to load icon for = {}", key);
                    continue;
                }

                try (ByteArrayOutputStream baos = new ByteArrayOutputStream()) {
                    ImageIO.write(sprite, "png", baos);
                    byte[] imageBytes = baos.toByteArray();
                    String base64Image = Base64.getEncoder().encodeToString(imageBytes);
                    icons.put(key, base64Image);
                } catch (IOException e) {
                    log.debug("Failed to encode icon for = {}", key);
                }
            }

            DEV_writeJsonFile("hiscore-icons.json", icons);
        });
    }

    public void DEV_generateClanRankIconsJson() {
        clientThread.invokeLater(() -> {
            Map<String, String> icons = new HashMap<>();

            final EnumComposition clanIcons = client.getEnum(EnumID.CLAN_RANK_GRAPHIC);

            for (int i = 0; i < clanIcons.size(); i++) {
                final int key = clanIcons.getKeys()[i];

                final BufferedImage sprite = spriteManager.getSprite(clanIcons.getIntValue(key), 0);

                if (sprite == null) {
                    log.debug("Failed to load icon for = {}", key);
                    continue;
                }

                try (ByteArrayOutputStream baos = new ByteArrayOutputStream()) {
                    ImageIO.write(sprite, "png", baos);
                    byte[] imageBytes = baos.toByteArray();
                    String base64Image = Base64.getEncoder().encodeToString(imageBytes);
                    icons.put(String.valueOf(key), base64Image);
                } catch (IOException e) {
                    log.debug("Failed to encode icon for = {}", key);
                }
            }

            DEV_writeJsonFile("clan-rank-icons.json", icons);
        });
    }

    private void DEV_writeJsonFile(String fileName, Object data) {
        try (FileWriter writer = new FileWriter(fileName)) {
            gson.toJson(data, writer);
            log.debug("Successfully wrote JSON to file = {}", fileName);
        } catch (IOException e) {
            log.debug("Failed to write JSON to file");
        }
    }
}

/*
 * Copyright (c) 2020 Abex
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.runeprofile.modelexporter;

import java.awt.*;

// Originally from RuneLite cache
// Additions made for calculating average of 3 colors
public final class JagexColor
{
	public static final double BRIGHTNESS_MAX = .6;
	public static final double BRIGHTNESS_HIGH = .7;
	public static final double BRIGHTNESS_LOW = .8;
	public static final double BRIGHTNESS_MIN = .9;

	private static final double HUE_OFFSET = (.5 / 64.D);
	private static final double SATURATION_OFFSET = (.5 / 8.D);

	private JagexColor()
	{
	}

	// take 3 Jagex HSL colors and make a single RGB color to represent them
	public static Color HSLtoRGBAvg(int hsl1, int hsl2, int hsl3)
	{
		Color c1 = new Color(HSLtoRGB((short) hsl1, BRIGHTNESS_MIN));
		Color c2 = new Color(HSLtoRGB((short) hsl2, BRIGHTNESS_MIN));
		Color c3 = new Color(HSLtoRGB((short) hsl3, BRIGHTNESS_MIN));

		// compute color average using squares
		// uses squared approach from https://sighack.com/post/averaging-rgb-colors-the-right-way
		int r = c1.getRed()*c1.getRed() + c2.getRed()*c2.getRed() + c3.getRed()*c3.getRed();
		int g = c1.getGreen()*c1.getGreen() + c2.getGreen()*c2.getGreen() + c3.getGreen()*c3.getGreen();
		int b = c1.getBlue()*c1.getBlue() + c2.getBlue()*c2.getBlue() + c3.getBlue()*c3.getBlue();

		r = (int) Math.round(Math.sqrt((double) r / 3.0d));
		g = (int) Math.round(Math.sqrt((double) g / 3.0d));
		b = (int) Math.round(Math.sqrt((double) b / 3.0d));

		return new Color(r, g, b);
	}

	public static short packHSL(int hue, int saturation, int luminance)
	{
		return (short) ((short) (hue & 63) << 10
				| (short) (saturation & 7) << 7
				| (short) (luminance & 127));
	}

	public static int unpackHue(short hsl)
	{
		return hsl >> 10 & 63;
	}

	public static int unpackSaturation(short hsl)
	{
		return hsl >> 7 & 7;
	}

	public static int unpackLuminance(short hsl)
	{
		return hsl & 127;
	}

	public static String formatHSL(short hsl)
	{
		return String.format("%02Xh%Xs%02Xl", unpackHue(hsl), unpackSaturation(hsl), unpackLuminance(hsl));
	}

	public static int HSLtoRGB(short hsl, double brightness)
	{
		double hue = (double) unpackHue(hsl) / 64.D + HUE_OFFSET;
		double saturation = (double) unpackSaturation(hsl) / 8.D + SATURATION_OFFSET;
		double luminance = (double) unpackLuminance(hsl) / 128.D;

		// This is just a standard hsl to rgb transform
		// the only difference is the offsets above and the brightness transform below
		double chroma = (1.D - Math.abs((2.D * luminance) - 1.D)) * saturation;
		double x = chroma * (1 - Math.abs(((hue * 6.D) % 2.D) - 1.D));
		double lightness = luminance - (chroma / 2);

		double r = lightness, g = lightness, b = lightness;
		switch ((int) (hue * 6.D))
		{
			case 0:
				r += chroma;
				g += x;
				break;
			case 1:
				g += chroma;
				r += x;
				break;
			case 2:
				g += chroma;
				b += x;
				break;
			case 3:
				b += chroma;
				g += x;
				break;
			case 4:
				b += chroma;
				r += x;
				break;
			default:
				r += chroma;
				b += x;
				break;
		}

		int rgb = ((int) (r * 256.0D) << 16)
				| ((int) (g * 256.0D) << 8)
				| (int) (b * 256.0D);

		rgb = adjustForBrightness(rgb, brightness);

		if (rgb == 0)
		{
			rgb = 1;
		}
		return rgb;
	}

	public static int adjustForBrightness(int rgb, double brightness)
	{
		double r = (double) (rgb >> 16) / 256.0D;
		double g = (double) (rgb >> 8 & 255) / 256.0D;
		double b = (double) (rgb & 255) / 256.0D;

		r = Math.pow(r, brightness);
		g = Math.pow(g, brightness);
		b = Math.pow(b, brightness);

		return ((int) (r * 256.0D) << 16)
				| ((int) (g * 256.0D) << 8)
				| (int) (b * 256.0D);
	}

	public static int[] createPalette(double brightness)
	{
		int[] colorPalette = new int[65536];
		for (int i = 0; i < colorPalette.length; i++)
		{
			colorPalette[i] = HSLtoRGB((short) i, brightness);
		}
		return colorPalette;
	}
}
/*
 * Copyright (c) 2020, bram91
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 * list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 * this list of conditions and the following disclaimer in the documentation
 * and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.runeprofile.modelexporter;

import com.runeprofile.RuneProfilePlugin;
import net.runelite.api.Client;

import java.awt.Color;
import java.util.HashMap;
import java.util.Map;

public class TextureColor
{
    private static final Map<Integer, Color> colorCache = new HashMap<>();

    // get single average color from Jagex texture id
    public static Color getColor(int textureId)
    {
        if (colorCache.containsKey(textureId))
            return colorCache.get(textureId);

        Client client = RuneProfilePlugin.getClient();
        if (client == null)
            return new Color(255, 255, 255);
        int[] pixels = client.getTextureProvider().load(textureId);

        int r = 0;
        int g = 0;
        int b = 0;
        int n = 0;
        for (int pixel : pixels)
        {
            // skip transparent (black)
            if (pixel == 0)
                continue;

            Color c = new Color(pixel);
            r += c.getRed();
            g += c.getGreen();
            b += c.getBlue();
            n++;
        }

        Color c = new Color(r/n, g/n, b/n);
        colorCache.put(textureId, c);
        return c;
    }

}
/*
 * Copyright (c) 2020, bram91
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 * list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 * this list of conditions and the following disclaimer in the documentation
 * and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.runeprofile.modelexporter;

import net.runelite.api.Model;

import java.awt.Color;
import java.io.PrintWriter;
import java.io.IOException;
import java.io.ByteArrayOutputStream;
import java.util.ArrayList;
import java.util.List;
import java.util.Objects;

public class ModelExporter {
    private final static int[] colorPalette = JagexColor.createPalette(JagexColor.BRIGHTNESS_MIN);

    public static byte[] toBytes(Model m) throws IOException {
        List<Vertex> vertices = new ArrayList<>();
        for (int fi = 0; fi < m.getFaceCount(); fi++) {
            // determine vertex colors (textured or colored?)
            Color vc1;
            Color vc2;
            Color vc3;
            int textureId = -1;
            if (m.getFaceTextures() != null)
                textureId = m.getFaceTextures()[fi];
            if (textureId != -1) {
                // get average color of texture
                vc1 = TextureColor.getColor(textureId);
                vc2 = vc1;
                vc3 = vc1;
            } else {
                if (m.getFaceColors3()[fi] == -1) {
                    // face should be shaded flat
                    int colorIndex = m.getFaceColors1()[fi];
                    int rgbColor = colorPalette[colorIndex];
                    vc1 = vc2 = vc3 = new Color(rgbColor);
                } else {
                    // get color for each vertex
                    vc1 = new Color(JagexColor.HSLtoRGB((short) m.getFaceColors1()[fi], JagexColor.BRIGHTNESS_MIN));
                    vc2 = new Color(JagexColor.HSLtoRGB((short) m.getFaceColors2()[fi], JagexColor.BRIGHTNESS_MIN));
                    vc3 = new Color(JagexColor.HSLtoRGB((short) m.getFaceColors3()[fi], JagexColor.BRIGHTNESS_MIN));
                }
            }

            int vi1 = m.getFaceIndices1()[fi];
            int vi2 = m.getFaceIndices2()[fi];
            int vi3 = m.getFaceIndices3()[fi];

            int vx1 = (int) m.getVerticesX()[vi1];
            int vx2 = (int) m.getVerticesX()[vi2];
            int vx3 = (int) m.getVerticesX()[vi3];
            int vy1 = (int) -m.getVerticesY()[vi1];
            int vy2 = (int) -m.getVerticesY()[vi2];
            int vy3 = (int) -m.getVerticesY()[vi3];
            int vz1 = (int) m.getVerticesZ()[vi1];
            int vz2 = (int) m.getVerticesZ()[vi2];
            int vz3 = (int) m.getVerticesZ()[vi3];

            vertices.add(new Vertex(vx1, vy1, vz1, vc1.getRed(), vc1.getGreen(), vc1.getBlue()));
            vertices.add(new Vertex(vx2, vy2, vz2, vc2.getRed(), vc2.getGreen(), vc2.getBlue()));
            vertices.add(new Vertex(vx3, vy3, vz3, vc3.getRed(), vc3.getGreen(), vc3.getBlue()));
        }

        ByteArrayOutputStream ply = new ByteArrayOutputStream();
        PrintWriter plyHeader = new PrintWriter(ply);
        plyHeader.println("ply");
        plyHeader.println("format binary_little_endian 1.0");
        plyHeader.println("element vertex " + vertices.size());
        plyHeader.println("property int16 x");
        plyHeader.println("property int16 y");
        plyHeader.println("property int16 z");
        plyHeader.println("property uint8 red");
        plyHeader.println("property uint8 green");
        plyHeader.println("property uint8 blue");
        plyHeader.println("element face " + m.getFaceCount());
        plyHeader.println("property list uint8 int16 vertex_indices");
        plyHeader.println("end_header");
        plyHeader.flush();

        ByteArrayOutputStream w = new ByteArrayOutputStream();

        for (Vertex v : vertices) {
            // Y and Z axes are flipped
            w.write(le(v.x));
            w.write(le(v.z));
            w.write(le(v.y));
            w.write((byte) v.r);
            w.write((byte) v.g);
            w.write((byte) v.b);
        }

        for (int i = 0; i < m.getFaceCount(); ++i) {
            int vi = i * 3;
            w.write((byte) 3);
            w.write(le(vi));
            w.write(le(vi + 1));
            w.write(le(vi + 2));
        }

        w.flush();
        ply.write(w.toByteArray());
        return ply.toByteArray();
    }

    // int to little endian byte array
    private static byte[] le(int n) {
        byte[] b = new byte[2];
        b[0] = (byte) n;
        b[1] = (byte) (n >> 8);
        return b;
    }

    private static class Vertex {
        public int x, y, z;
        public int r, g, b;

        public Vertex(int x, int y, int z, int r, int g, int b) {
            this.x = x;
            this.y = y;
            this.z = z;
            this.r = r;
            this.g = g;
            this.b = b;
        }

        @Override
        public boolean equals(Object o) {
            if (this == o) return true;
            if (o == null || getClass() != o.getClass()) return false;
            Vertex vertex = (Vertex) o;
            return x == vertex.x && y == vertex.y && z == vertex.z && r == vertex.r && g == vertex.g && b == vertex.b;
        }

        @Override
        public int hashCode() {
            return Objects.hash(x, y, z, r, g, b);
        }
    }

}
package com.runeprofile;

import com.google.gson.Gson;
import com.google.gson.JsonObject;
import com.runeprofile.data.*;
import com.runeprofile.utils.RuneProfileApiException;
import lombok.NonNull;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import net.runelite.client.RuneLiteProperties;
import okhttp3.*;

import javax.annotation.Nullable;
import javax.inject.Inject;
import java.io.IOException;
import java.util.Objects;
import java.util.concurrent.CompletableFuture;
import java.util.function.Consumer;

@Slf4j
@RequiredArgsConstructor
public class RuneProfileApiClient {
    private static final MediaType JSON_MEDIA_TYPE = Objects.requireNonNull(MediaType.parse("application/json; charset=utf-8"));

    @Inject
    private OkHttpClient okHttpClient;

    private final String userAgent;

    // increment when making breaking changes to how the plugin users the API
    private static final String version = "2.0.0";

    private final HttpUrl baseUrl;

    @Inject
    private Gson gson;

    @Inject
    public RuneProfileApiClient() {
        boolean isDevMode = false;

        String runeliteVersion = RuneLiteProperties.getVersion();
        userAgent = "RuneLite:" + runeliteVersion + "," + "Client:" + version;

        //noinspection ConstantValue
        baseUrl = isDevMode
                ? new HttpUrl.Builder().scheme("http").host("localhost").port(8787).build()
                : new HttpUrl.Builder().scheme("https").host("api.runeprofile.com").build();
    }

    private HttpUrl buildApiUrl(String... pathSegments) {
        HttpUrl.Builder urlBuilder = baseUrl.newBuilder();
        for (String segment : pathSegments) {
            urlBuilder.addPathSegment(segment);
        }
        return urlBuilder.build();
    }

    private RequestBody createJsonBody(JsonObject jsonObject) {
        return RequestBody.create(JSON_MEDIA_TYPE, jsonObject.toString());
    }

    private Request.Builder buildApiRequest(HttpUrl url, Consumer<Request.Builder> methodSetter) {
        Request.Builder builder = new Request.Builder()
                .url(url)
                .header("Content-Type", "application/json")
                .header("User-Agent", userAgent);
        methodSetter.accept(builder);
        return builder;
    }

    private CompletableFuture<Response> executeHttpRequestAsync(OkHttpClient client, Request request) {
        CompletableFuture<Response> future = new CompletableFuture<>();
        client.newCall(request).enqueue(new Callback() {
            @Override
            public void onFailure(@NonNull Call call, @NonNull IOException e) {
                log.error("Async API request failed.", e);
                future.completeExceptionally(e);
            }

            @Override
            public void onResponse(@NonNull Call call, @NonNull Response response) {
                future.complete(response);
            }
        });
        return future;
    }

    private CompletableFuture<Response> postHttpRequestAsync(HttpUrl url, String data) {
        RequestBody body = RequestBody.create(JSON_MEDIA_TYPE, data);
        Request request = buildApiRequest(url, builder -> builder.post(body)).build();
        log.debug("Sending json request to = {}, data = {}", url.toString(), data);
        return executeHttpRequestAsync(okHttpClient, request);
    }

    private CompletableFuture<Response> postHttpRequestAsync(HttpUrl url, MultipartBody data) {
        Request request = buildApiRequest(url, builder -> builder.post(data)).build();
        log.debug("Sending form data request to = {}, data = {}", url.toString(), data);
        return executeHttpRequestAsync(okHttpClient, request);
    }

    private CompletableFuture<Response> getHttpRequestAsync(HttpUrl url) {
        Request request = buildApiRequest(url, Request.Builder::get)
                .build();
        return executeHttpRequestAsync(okHttpClient, request);
    }

    private CompletableFuture<Response> deleteHttpRequestAsync(HttpUrl url) {
        Request request = buildApiRequest(url, Request.Builder::delete)
                .build();
        return executeHttpRequestAsync(okHttpClient, request);
    }

    private <T> T handleResponse(Response response, @Nullable Class<T> clazz) {
        try (Response res = response) {
            ResponseBody body = res.body();

            if (body == null) {
                throw new RuneProfileApiException("Response body is null");
            }

            String bodyString = body.string();

            if (!response.isSuccessful()) {
                JsonObject json = gson.fromJson(bodyString, JsonObject.class);
                throw new RuneProfileApiException(json.get("message").getAsString());
            }

            if (clazz == null) {
                return null;
            }

            return gson.fromJson(bodyString, clazz);
        } catch (IOException e) {
            throw new RuneProfileApiException("Error reading response body");
        }
    }

    public CompletableFuture<Void> updateProfileAsync(PlayerData data) {
        HttpUrl url = buildApiUrl("profiles");
        return postHttpRequestAsync(url, gson.toJson(data))
                .thenApply((response) -> handleResponse(response, null));
    }

    public CompletableFuture<Void> updateModelAsync(PlayerModelData data) {
        HttpUrl url = buildApiUrl("profiles", "models");

        RequestBody modelFile = RequestBody.create(MediaType.parse("model/ply"), data.getModel());

        MultipartBody.Builder bodyBuilder = new MultipartBody.Builder()
                .setType(MultipartBody.FORM)
                .addFormDataPart("accountId", data.getAccountHash())
                .addFormDataPart("model", "model.ply", modelFile);

        @Nullable
        byte[] petModel = data.getPetModel();
        if (petModel != null) {
            RequestBody petFile = RequestBody.create(MediaType.parse("model/ply"), petModel);
            bodyBuilder.addFormDataPart("petModel", "pet.ply", petFile);
        }

        MultipartBody body = bodyBuilder.build();

        return postHttpRequestAsync(url, body)
                .thenApplyAsync((response -> handleResponse(response, null)));
    }

    public CompletableFuture<CollectionLogPage> getCollectionLogPage(String username, String page) {
        HttpUrl url = buildApiUrl("profiles", username, "collection-log", page);
        return getHttpRequestAsync(url)
                .thenApplyAsync((response -> handleResponse(response, CollectionLogPage.class)));
    }

    public CompletableFuture<ProfileSearchResult[]> searchProfiles(String query) {
        HttpUrl url = buildApiUrl("profiles")
                .newBuilder()
                .addQueryParameter("q", query)
                .build();
        return getHttpRequestAsync(url)
                .thenApplyAsync((response -> handleResponse(response, ProfileSearchResult[].class)));
    }

    public CompletableFuture<Void> setDefaultClogPage(DefaultClogPageData data) {
        HttpUrl url = buildApiUrl("profiles", "set-default-clog-page");
        return postHttpRequestAsync(url, gson.toJson(data))
                .thenApplyAsync((response) -> handleResponse(response, null));
    }
}

package com.runeprofile;

import net.runelite.client.RuneLite;
import net.runelite.client.externalplugins.ExternalPluginManager;

public class RuneProfilePluginTest {
	public static void main(String[] args) throws Exception {
		ExternalPluginManager.loadBuiltin(RuneProfilePlugin.class);
		RuneLite.main(args);
	}
}
