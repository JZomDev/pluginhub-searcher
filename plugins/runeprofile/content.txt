package com.runeprofile;

import net.runelite.client.RuneLite;
import net.runelite.client.externalplugins.ExternalPluginManager;

public class RuneProfilePluginTest {
	public static void main(String[] args) throws Exception {
		ExternalPluginManager.loadBuiltin(RuneProfilePlugin.class);
		RuneLite.main(args);
	}
}
package com.runeprofile;

import com.google.gson.JsonObject;
import com.google.gson.JsonParser;
import com.runeprofile.dataobjects.PlayerData;
import com.runeprofile.dataobjects.PlayerModelData;
import com.runeprofile.utils.DateHeader;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import okhttp3.*;

import javax.inject.Inject;
import java.io.IOException;
import java.util.Objects;
import java.util.concurrent.TimeUnit;

@Slf4j
@RequiredArgsConstructor
public class RuneProfileApiClient {
	private static final MediaType JSON_MEDIA_TYPE = Objects.requireNonNull(MediaType.parse("application/json; charset=utf-8"));

	private final boolean isDevMode = false;

	@Inject
	private OkHttpClient okHttpClient;

	private HttpUrl.Builder getBaseUrl() {
		return isDevMode
						? new HttpUrl.Builder().scheme("http").host("localhost").port(3000)
						: new HttpUrl.Builder().scheme("https").host("www.runeprofile.com");
	}

	public String updateProfile(PlayerData playerData) {
		// Build URL
		HttpUrl url = getBaseUrl()
						.addPathSegment("api")
						.addPathSegment("profile")
						.build();

		// Build Request Body
		RequestBody body = RequestBody.create(JSON_MEDIA_TYPE, playerData.getJson().toString());

		// Build Request
		Request request = new Request.Builder()
						.url(url)
						.header("Content-Type", "application/json")
						.header("User-Agent", "RuneLite Plugin v1.0.5")
						.put(body)
						.build();

		OkHttpClient extendedTimeoutClient = okHttpClient.newBuilder()
						.readTimeout(30, TimeUnit.SECONDS)
						.build();

		// Request Call
		try (Response response = extendedTimeoutClient.newCall(request).execute()) {
			if (!response.isSuccessful()) {
				return "Failed";
			}

			String date = response.header("Date");
			response.close();
			return DateHeader.getDateString(date);
		} catch (IOException e) {
			log.error("Request call to RuneProfile API failed.");
		}

		return "Failed";
	}

	public String updateModel(PlayerModelData playerModelData) {
		// Build URL
		HttpUrl url = getBaseUrl()
						.addPathSegment("api")
						.addPathSegment("profile")
						.addPathSegment("model")
						.build();

		// Build Request Body
		RequestBody body = RequestBody.create(JSON_MEDIA_TYPE, playerModelData.getJson().toString());

		// Build Request
		Request request = new Request.Builder()
						.url(url)
						.header("Content-Type", "application/json")
						.header("User-Agent", "RuneLite")
						.put(body)
						.build();

		// Request Call
		try (Response response = okHttpClient.newCall(request).execute()) {
			if (!response.isSuccessful()) {
				return "Failed";
			}

			String date = response.header("Date");
			response.close();

			return DateHeader.getDateString(date);
		} catch (IOException e) {
			log.error("Request call to RuneProfile API failed.");
		}

		return "Failed";
	}

	public String updateGeneratedPath(String accountHash) throws Exception {
		// Build URL
		HttpUrl url = getBaseUrl()
						.addPathSegment("api")
						.addPathSegment("profile")
						.addPathSegment("generated-path")
						.build();

		JsonObject jsonRequestBody = new JsonObject();
		jsonRequestBody.addProperty("accountHash", accountHash);
		RequestBody requestBody = RequestBody.create(JSON_MEDIA_TYPE, jsonRequestBody.toString());

		// Build Request
		Request request = new Request.Builder()
						.url(url)
						.header("Content-Type", "application/json")
						.header("User-Agent", "RuneLite")
						.put(requestBody)
						.build();

		// Request Call
		try (Response response = okHttpClient.newCall(request).execute()) {
			JsonObject responseBody = new JsonParser().parse(Objects.requireNonNull(response.body()).string()).getAsJsonObject();
			response.close();

			return responseBody.get("generatedPath").getAsString();
		} catch (IOException e) {
			throw new Exception("Request call to RuneProfile API failed.");
		}
	}

	public String updateDescription(String accountHash, String description) throws Exception {
		// Build URL
		HttpUrl url = getBaseUrl()
						.addPathSegment("api")
						.addPathSegment("profile")
						.addPathSegment("description")
						.build();

		JsonObject jsonRequestBody = new JsonObject();
		jsonRequestBody.addProperty("accountHash", accountHash);
		jsonRequestBody.addProperty("description", description);
		RequestBody requestBody = RequestBody.create(JSON_MEDIA_TYPE, jsonRequestBody.toString());

		// Build Request
		Request request = new Request.Builder()
						.url(url)
						.header("Content-Type", "application/json")
						.header("User-Agent", "RuneLite")
						.put(requestBody)
						.build();

		// Request Call
		try (Response response = okHttpClient.newCall(request).execute()) {
			JsonObject responseBody = new JsonParser().parse(Objects.requireNonNull(response.body()).string()).getAsJsonObject();
			response.close();

			return responseBody.get("description").getAsString();
		} catch (IOException e) {
			throw new Exception("Request call to RuneProfile API failed.");
		}
	}

	public JsonObject updateIsPrivate(String accountHash, boolean isPrivate) throws Exception {
		// Build URL
		HttpUrl url = getBaseUrl()
						.addPathSegment("api")
						.addPathSegment("profile")
						.addPathSegment("private")
						.build();

		JsonObject jsonBody = new JsonObject();
		jsonBody.addProperty("accountHash", accountHash);
		jsonBody.addProperty("isPrivate", isPrivate);

		// Build Request Body
		RequestBody requestBody = RequestBody.create(JSON_MEDIA_TYPE, jsonBody.toString());

		// Build Request
		Request request = new Request.Builder()
						.url(url)
						.header("Content-Type", "application/json")
						.header("User-Agent", "RuneLite")
						.put(requestBody)
						.build();

		// Request Call
		try (Response response = okHttpClient.newCall(request).execute()) {
			JsonObject responseBody = new JsonParser().parse(Objects.requireNonNull(response.body()).string()).getAsJsonObject();
			response.close();

			log.info("Body: " + responseBody);

			return responseBody;
		} catch (IOException e) {
			throw new Exception("Request call to RuneProfile API failed.");
		}
	}

	public void deleteProfile(String accountHash) {
		// Build URL
		HttpUrl url = getBaseUrl()
						.addPathSegment("api")
						.addPathSegment("profile")
						.build();

		JsonObject requestBodyJson = new JsonObject();
		requestBodyJson.addProperty("accountHash", accountHash);
		RequestBody requestBody = RequestBody.create(JSON_MEDIA_TYPE, requestBodyJson.toString());

		// Build Request
		Request request = new Request.Builder()
						.url(url)
						.header("Content-Type", "application/json")
						.header("User-Agent", "RuneLite")
						.delete(requestBody)
						.build();

		// Request Call
		try {
			Response response = okHttpClient.newCall(request).execute();
			response.close();
		} catch (IOException e) {
			log.error("Request call to RuneProfile API failed.");
		}
	}
}

package com.runeprofile.dataobjects;


import com.google.gson.JsonObject;
import com.runeprofile.playermodel.PlayerModelExporter;
import com.runeprofile.utils.AccountHash;
import lombok.Getter;
import net.runelite.api.Client;

import java.io.IOException;

public class PlayerModelData {
	@Getter
	private final JsonObject json;

	public PlayerModelData(Client client) throws IllegalArgumentException, IOException {
		json = new JsonObject();

		json.addProperty("accountHash", AccountHash.getHashed(client));
		json.addProperty(
						"model",
						PlayerModelExporter.export(
										client.getLocalPlayer().getModel(),
										client.getLocalPlayer().getName()
						)
		);
	}
}

package com.runeprofile.dataobjects;

import com.google.common.collect.ImmutableList;
import com.google.gson.Gson;
import com.google.gson.JsonArray;
import com.google.gson.JsonObject;
import com.google.gson.JsonParser;
import com.runeprofile.RuneProfileConfig;
import com.runeprofile.RuneProfilePlugin;
import com.runeprofile.achievementdiary.AchievementDiary;
import com.runeprofile.achievementdiary.AchievementDiaryState;
import com.runeprofile.collectionlog.CollectionLog;
import com.runeprofile.combatachievements.CombatAchievementTier;
import com.runeprofile.combatachievements.CombatAchievementTierState;
import com.runeprofile.leaderboards.Leaderboards;
import com.runeprofile.utils.AccountHash;
import lombok.Getter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.*;
import net.runelite.api.vars.AccountType;
import net.runelite.client.hiscore.HiscoreResult;

import java.io.IOException;
import java.util.HashMap;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.concurrent.atomic.AtomicReference;

@Slf4j
public class PlayerData {
	private static final List<Skill> skillsOrder = ImmutableList.of(
					Skill.ATTACK,
					Skill.HITPOINTS,
					Skill.MINING,
					Skill.STRENGTH,
					Skill.AGILITY,
					Skill.SMITHING,
					Skill.DEFENCE,
					Skill.HERBLORE,
					Skill.FISHING,
					Skill.RANGED,
					Skill.THIEVING,
					Skill.COOKING,
					Skill.PRAYER,
					Skill.CRAFTING,
					Skill.FIREMAKING,
					Skill.MAGIC,
					Skill.FLETCHING,
					Skill.WOODCUTTING,
					Skill.RUNECRAFT,
					Skill.SLAYER,
					Skill.FARMING,
					Skill.CONSTRUCTION,
					Skill.HUNTER
	);

	@Getter
	private final JsonObject json;

	public PlayerData() throws IllegalArgumentException, IOException, InterruptedException {
		AtomicReference<String> accountHash = new AtomicReference<>();
		AtomicReference<String> username = new AtomicReference<>();
		AtomicReference<AccountType> accountType = new AtomicReference<>();
		AtomicInteger combatLevel = new AtomicInteger();
		AtomicInteger questPoints = new AtomicInteger();

		// Linked because the order is important.
		Map<String, Integer> skills = new LinkedHashMap<>();
		Map<AchievementDiary, AchievementDiaryState> achievementDiaries = new LinkedHashMap<>();

		Map<Quest, QuestState> quests = new HashMap<>();
		Map<CombatAchievementTier, CombatAchievementTierState> combatAchievements = new HashMap<>();

		CountDownLatch latch = new CountDownLatch(1);

		RuneProfilePlugin.getClientThread().invokeLater(() -> {
			log.info("Getting client");
			Client client = RuneProfilePlugin.getClient();

			log.info("Getting player");
			Player player = client.getLocalPlayer();

			// Misc
			log.info("Getting misc data");
			accountHash.set(AccountHash.getHashed(client));
			username.set(player.getName());
			accountType.set(client.getAccountType());

			combatLevel.set(player.getCombatLevel());

			// Skills
			log.info("Getting skills");
			skillsOrder.forEach((skill -> {
				skills.put(skill.getName(), client.getSkillExperience(skill));
			}));

			// Achievement Diaries
			log.info("Getting achievement diary data");
			for (AchievementDiary achievementDiary : AchievementDiary.values()) {
				achievementDiaries.put(achievementDiary, achievementDiary.getState(client));
			}

			// Quests
			log.info("Getting quest data");
			questPoints.set(client.getVarpValue(VarPlayer.QUEST_POINTS));

			for (Quest quest : Quest.values()) {
				quests.put(quest, quest.getState(client));
			}

			// Combat Achievements
			log.info("Getting combat achievement data");
			for (CombatAchievementTier combatAchievementTier : CombatAchievementTier.values()) {
				combatAchievements.put(combatAchievementTier, combatAchievementTier.getState(client));
			}

			latch.countDown();
		});

		latch.await();

		json = new JsonObject();

		json.addProperty("accountHash", accountHash.get());
		json.addProperty("username", username.get());
		json.addProperty("accountType", accountType.get().toString());
		json.addProperty("combatLevel", combatLevel.get());
		json.addProperty("description", getDescription());

		json.add("skills", createSkillsXPJSON(skills));
		json.add("collectionLog", createCollectionLogJSON());
		json.add("achievementDiaries", getAchievementDiariesJSON(achievementDiaries));
		json.add("combatAchievements", getCombatAchievementsJSON(combatAchievements));
		json.add("questList", getQuestsJSON(questPoints.get(), quests));
		json.add("hiscores", getHiscoresJSON(username.get()));
	}

	private String getDescription() {
		String storedDescription = RuneProfilePlugin.getConfigManager().getRSProfileConfiguration(
						RuneProfileConfig.CONFIG_GROUP,
						RuneProfileConfig.DESCRIPTION
		);

		if (storedDescription == null) {
			return "";
		}

		return storedDescription;
	}

	private JsonArray createSkillsXPJSON(Map<String, Integer> skills) {
		JsonArray skillsJSON = new JsonArray();

		int index = 0;
		for (Map.Entry<String, Integer> skill : skills.entrySet()) {
			JsonObject skillJSON = new JsonObject();

			skillJSON.addProperty("index", index);
			skillJSON.addProperty("name", skill.getKey());
			skillJSON.addProperty("xp", skill.getValue());

			skillsJSON.add(skillJSON);

			index++;
		}

		return skillsJSON;
	}

	private JsonObject createCollectionLogJSON() {
		CollectionLog collectionLog = RuneProfilePlugin.getCollectionLogManager().getCollectionLog();
		Gson gson = RuneProfilePlugin.getGson();
		String jsonString = gson.toJson(collectionLog);
		return gson.fromJson(jsonString, JsonObject.class);
	}

	private JsonArray getAchievementDiariesJSON(Map<AchievementDiary, AchievementDiaryState> achievementDiaries) {
		JsonArray diaries = new JsonArray();

		for (Map.Entry<AchievementDiary, AchievementDiaryState> entry : achievementDiaries.entrySet()) {
			AchievementDiary ad = entry.getKey();
			AchievementDiaryState adState = entry.getValue();

			JsonObject areaJson = new JsonObject();
			areaJson.addProperty("area", ad.getName());

			ImmutableList.of(
							adState.getEasyTier(),
							adState.getMediumTier(),
							adState.getHardTier(),
							adState.getEliteTier()
			).forEach((tier) -> {
				JsonObject tierJSON = new JsonObject();
				tierJSON.addProperty("completed", tier.getCompletedTasks());
				tierJSON.addProperty("total", tier.getTotalTasks());

				areaJson.add(tier.getTier().getName(), tierJSON);
			});

			diaries.add(areaJson);
		}

		return diaries;
	}

	private JsonObject getQuestsJSON(int questPoints, Map<Quest, QuestState> quests) {
		JsonObject json = new JsonObject();

		json.addProperty("points", questPoints);

		JsonArray questsArray = new JsonArray();

		for (Map.Entry<Quest, QuestState> entry : quests.entrySet()) {
			Quest quest = entry.getKey();
			QuestState questState = entry.getValue();

			JsonObject questJSON = new JsonObject();
			questJSON.addProperty("name", quest.getName());
			questJSON.addProperty("state", questState.name());

			questsArray.add(questJSON);
		}

		json.add("quests", questsArray);

		return json;
	}

	private JsonObject getCombatAchievementsJSON(Map<CombatAchievementTier, CombatAchievementTierState> combatAchievements) {
		JsonObject json = new JsonObject();

		for (Map.Entry<CombatAchievementTier, CombatAchievementTierState> entry : combatAchievements.entrySet()) {
			CombatAchievementTier caTier = entry.getKey();
			CombatAchievementTierState caState = entry.getValue();

			JsonObject caJSON = new JsonObject();
			caJSON.addProperty("completed", caState.getCompletedTasks());
			caJSON.addProperty("total", caState.getTotalTasks());

			String tierKey = caTier.getName();
			json.add(tierKey, caJSON);
		}

		return json;
	}

	private JsonObject getHiscoresJSON(String username) {
		JsonObject hiscores = new JsonObject();

		for (Leaderboards leaderboard : Leaderboards.values()) {
			JsonArray skills = new JsonArray();
			JsonArray activities = new JsonArray();
			JsonArray bosses = new JsonArray();

			HiscoreResult result = null;

			try {
				result = RuneProfilePlugin.getHiscoreClient().lookup(username, leaderboard.getEndpoint());
			} catch (IOException e) {
				log.error("Error looking up hiscores", e);
			}

			if (result == null) {
				JsonObject entry = new JsonObject();
				entry.add("skills", skills);
				entry.add("activities", activities);
				entry.add("bosses", bosses);
				hiscores.add(leaderboard.getGameMode(), entry);

				continue;
			}

			AtomicInteger index = new AtomicInteger();
			result.getSkills().forEach((hiscore, data) -> {
				JsonObject entryItem = new JsonObject();
				entryItem.addProperty("index", index.get());
				entryItem.addProperty("name", hiscore.getName());
				entryItem.addProperty("rank", data.getRank());

				switch (hiscore.getType()) {
					case OVERALL:
					case SKILL:
						entryItem.addProperty("level", data.getLevel());
						entryItem.addProperty("xp", data.getExperience());
						skills.add(entryItem);
						break;
					case ACTIVITY:
						entryItem.addProperty("score", data.getLevel());
						activities.add(entryItem);
						break;
					case BOSS:
						entryItem.addProperty("kills", data.getLevel());
						bosses.add(entryItem);
						break;
					default:
						break;
				}

				index.getAndIncrement();
			});

			JsonObject entry = new JsonObject();
			entry.add("skills", skills);
			entry.add("activities", activities);
			entry.add("bosses", bosses);
			hiscores.add(leaderboard.getGameMode(), entry);
		}

		return hiscores;
	}
}

package com.runeprofile.playermodel;

import net.runelite.api.Model;

import java.awt.*;
import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Base64;
import java.util.List;

public class PlayerModelExporter {
	public static String export(Model model, String name) throws IOException {
		List<Vertex> vertices = new ArrayList<>();
		for (int fi = 0; fi < model.getFaceCount(); fi++) {
			// determine vertex colors (textured or colored?)
			Color vc1;
			Color vc2;
			Color vc3;
			int textureId = -1;
			if (model.getFaceTextures() != null)
				textureId = model.getFaceTextures()[fi];
			if (textureId != -1) {
				// get average color of texture
				vc1 = TextureColor.getColor(textureId);
				vc2 = vc1;
				vc3 = vc1;
			} else {
				// get average color of vertices
				vc1 = new Color(JagexColor.HSLtoRGB((short) model.getFaceColors1()[fi], JagexColor.BRIGHTNESS_MIN));
				vc2 = new Color(JagexColor.HSLtoRGB((short) model.getFaceColors2()[fi], JagexColor.BRIGHTNESS_MIN));
				vc3 = new Color(JagexColor.HSLtoRGB((short) model.getFaceColors3()[fi], JagexColor.BRIGHTNESS_MIN));
			}

			int vi1 = model.getFaceIndices1()[fi];
			int vi2 = model.getFaceIndices2()[fi];
			int vi3 = model.getFaceIndices3()[fi];

			float vx1 = model.getVerticesX()[vi1];
			float vx2 = model.getVerticesX()[vi2];
			float vx3 = model.getVerticesX()[vi3];
			float vy1 = -model.getVerticesY()[vi1];
			float vy2 = -model.getVerticesY()[vi2];
			float vy3 = -model.getVerticesY()[vi3];
			float vz1 = model.getVerticesZ()[vi1];
			float vz2 = model.getVerticesZ()[vi2];
			float vz3 = model.getVerticesZ()[vi3];

			vertices.add(new Vertex(vx1, vy1, vz1, vc1.getRed(), vc1.getGreen(), vc1.getBlue()));
			vertices.add(new Vertex(vx2, vy2, vz2, vc2.getRed(), vc2.getGreen(), vc2.getBlue()));
			vertices.add(new Vertex(vx3, vy3, vz3, vc3.getRed(), vc3.getGreen(), vc3.getBlue()));
		}

		ByteArrayOutputStream w = new ByteArrayOutputStream();

		w.write(newLine("ply"));
		w.write(newLine("format binary_little_endian 1.0"));
		w.write(newLine("element vertex " + vertices.size()));
		w.write(newLine("property int16 x"));
		w.write(newLine("property int16 y"));
		w.write(newLine("property int16 z"));
		w.write(newLine("property uint8 red"));
		w.write(newLine("property uint8 green"));
		w.write(newLine("property uint8 blue"));
		w.write(newLine("element face " + model.getFaceCount()));
		w.write(newLine("property list uint8 int16 vertex_indices"));
		w.write(newLine("end_header"));

		for (Vertex v : vertices) {
			// Y and Z axes are flipped
			w.write(le(v.x));
			w.write(le(v.z));
			w.write(le(v.y));
			w.write((byte) v.r);
			w.write((byte) v.g);
			w.write((byte) v.b);
		}

		for (int i = 0; i < model.getFaceCount(); ++i) {
			int vi = i * 3;
			w.write((byte) 3);
			w.write(le(vi));
			w.write(le(vi + 1));
			w.write(le(vi + 2));
		}

		return Base64.getEncoder().encodeToString(w.toByteArray());
	}

	private static byte[] newLine(String text) {
		return (text + System.lineSeparator()).getBytes();
	}

	// int to little endian byte array
	private static byte[] le(int n) {
		byte[] b = new byte[2];
		b[0] = (byte) n;
		b[1] = (byte) (n >> 8);
		return b;
	}

	private static byte[] le(float n) {
		return le((int) n);
	}

	private static class Vertex {
		public float x, y, z;
		public int r, g, b;

		public Vertex(float x, float y, float z, int r, int g, int b) {
			this.x = x;
			this.y = y;
			this.z = z;
			this.r = r;
			this.g = g;
			this.b = b;
		}

		@Override
		public boolean equals(Object o) {
			if (this == o) return true;
			if (o == null || getClass() != o.getClass()) return false;
			Vertex vertex = (Vertex) o;
			return x == vertex.x && y == vertex.y && z == vertex.z && r == vertex.r && g == vertex.g && b == vertex.b;
		}
	}
}
/*
 * Copyright (c) 2020 Abex
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.runeprofile.playermodel;


import java.awt.*;

// Originally from RuneLite cache
// Additions made for calculating average of 3 colors
public final class JagexColor {
	public static final double BRIGHTNESS_MAX = .6;
	public static final double BRIGHTNESS_HIGH = .7;
	public static final double BRIGHTNESS_LOW = .8;
	public static final double BRIGHTNESS_MIN = .9;

	private static final double HUE_OFFSET = (.5 / 64.D);
	private static final double SATURATION_OFFSET = (.5 / 8.D);

	private JagexColor() {
	}

	// take 3 Jagex HSL colors and make a single RGB color to represent them
	public static Color HSLtoRGBAvg(int hsl1, int hsl2, int hsl3) {
		Color c1 = new Color(HSLtoRGB((short) hsl1, BRIGHTNESS_MIN));
		Color c2 = new Color(HSLtoRGB((short) hsl2, BRIGHTNESS_MIN));
		Color c3 = new Color(HSLtoRGB((short) hsl3, BRIGHTNESS_MIN));

		// compute color average using squares
		// uses squared approach from https://sighack.com/post/averaging-rgb-colors-the-right-way
		int r = c1.getRed() * c1.getRed() + c2.getRed() * c2.getRed() + c3.getRed() * c3.getRed();
		int g = c1.getGreen() * c1.getGreen() + c2.getGreen() * c2.getGreen() + c3.getGreen() * c3.getGreen();
		int b = c1.getBlue() * c1.getBlue() + c2.getBlue() * c2.getBlue() + c3.getBlue() * c3.getBlue();

		r = (int) Math.round(Math.sqrt((double) r / 3.0d));
		g = (int) Math.round(Math.sqrt((double) g / 3.0d));
		b = (int) Math.round(Math.sqrt((double) b / 3.0d));

		return new Color(r, g, b);
	}

	public static short packHSL(int hue, int saturation, int luminance) {
		return (short) ((short) (hue & 63) << 10
						| (short) (saturation & 7) << 7
						| (short) (luminance & 127));
	}

	public static int unpackHue(short hsl) {
		return hsl >> 10 & 63;
	}

	public static int unpackSaturation(short hsl) {
		return hsl >> 7 & 7;
	}

	public static int unpackLuminance(short hsl) {
		return hsl & 127;
	}

	public static String formatHSL(short hsl) {
		return String.format("%02Xh%Xs%02Xl", unpackHue(hsl), unpackSaturation(hsl), unpackLuminance(hsl));
	}

	public static int HSLtoRGB(short hsl, double brightness) {
		double hue = (double) unpackHue(hsl) / 64.D + HUE_OFFSET;
		double saturation = (double) unpackSaturation(hsl) / 8.D + SATURATION_OFFSET;
		double luminance = (double) unpackLuminance(hsl) / 128.D;

		// This is just a standard hsl to rgb transform
		// the only difference is the offsets above and the brightness transform below
		double chroma = (1.D - Math.abs((2.D * luminance) - 1.D)) * saturation;
		double x = chroma * (1 - Math.abs(((hue * 6.D) % 2.D) - 1.D));
		double lightness = luminance - (chroma / 2);

		double r = lightness, g = lightness, b = lightness;
		switch ((int) (hue * 6.D)) {
			case 0:
				r += chroma;
				g += x;
				break;
			case 1:
				g += chroma;
				r += x;
				break;
			case 2:
				g += chroma;
				b += x;
				break;
			case 3:
				b += chroma;
				g += x;
				break;
			case 4:
				b += chroma;
				r += x;
				break;
			default:
				r += chroma;
				b += x;
				break;
		}

		int rgb = ((int) (r * 256.0D) << 16)
						| ((int) (g * 256.0D) << 8)
						| (int) (b * 256.0D);

		rgb = adjustForBrightness(rgb, brightness);

		if (rgb == 0) {
			rgb = 1;
		}
		return rgb;
	}

	public static int adjustForBrightness(int rgb, double brightness) {
		double r = (double) (rgb >> 16) / 256.0D;
		double g = (double) (rgb >> 8 & 255) / 256.0D;
		double b = (double) (rgb & 255) / 256.0D;

		r = Math.pow(r, brightness);
		g = Math.pow(g, brightness);
		b = Math.pow(b, brightness);

		return ((int) (r * 256.0D) << 16)
						| ((int) (g * 256.0D) << 8)
						| (int) (b * 256.0D);
	}
}
package com.runeprofile.playermodel;

import com.runeprofile.RuneProfilePlugin;
import net.runelite.api.Client;

import java.awt.*;
import java.util.HashMap;
import java.util.Map;

public class TextureColor {

	private static final Map<Integer, Color> colorCache = new HashMap<>();

	// get single average color from Jagex texture id
	public static Color getColor(int textureId) {
		if (colorCache.containsKey(textureId))
			return colorCache.get(textureId);

		Client client = RuneProfilePlugin.getClient();
		if (client == null) {
			return new Color(255, 255, 255);
		}

		int[] pixels = client.getTextureProvider().load(textureId);

		int r = 0;
		int g = 0;
		int b = 0;
		int n = 0;
		for (int pixel : pixels) {
			// skip transparent (black)
			if (pixel == 0) {
				continue;
			}
			
			Color c = new Color(pixel);
			r += c.getRed();
			g += c.getGreen();
			b += c.getBlue();
			n++;
		}

		Color c = new Color(r / n, g / n, b / n);
		colorCache.put(textureId, c);
		return c;
	}

}
package com.runeprofile.leaderboards;

import lombok.Getter;
import lombok.RequiredArgsConstructor;
import net.runelite.api.vars.AccountType;
import net.runelite.client.hiscore.HiscoreEndpoint;

@RequiredArgsConstructor
public enum Leaderboards {
	NORMAL("NORMAL", HiscoreEndpoint.NORMAL),
	IRONMAN("IRONMAN", HiscoreEndpoint.IRONMAN),
	HARDCORE("HARDCORE_IRONMAN", HiscoreEndpoint.HARDCORE_IRONMAN),
	ULTIMATE("ULTIMATE_IRONMAN", HiscoreEndpoint.ULTIMATE_IRONMAN),
	DEFENCE_PURE("1_DEFENCE_PURE", HiscoreEndpoint.PURE),
	SKILLER("LEVEL_3_SKILLER", HiscoreEndpoint.LEVEL_3_SKILLER);

	@Getter
	private final String gameMode;

	@Getter
	private final HiscoreEndpoint endpoint;
}

package com.runeprofile.panels.settings;

import com.runeprofile.RuneProfilePlugin;

import javax.swing.*;
import javax.swing.border.EmptyBorder;
import java.awt.*;

public class SettingsPanel extends JPanel {
	public SettingsPanel(RuneProfilePlugin runeProfilePlugin) {
		setLayout(new BorderLayout());

		JPanel wrapper = new JPanel(new GridLayout(0, 1, 0, 16));

		wrapper.add(new PrivateProfilePanel(runeProfilePlugin));
		wrapper.add(new DescriptionPanel(runeProfilePlugin));

		DeleteProfilePanel deleteProfilePanel = new DeleteProfilePanel(runeProfilePlugin);
		deleteProfilePanel.setBorder(new EmptyBorder(32, 0, 0, 0));
		wrapper.add(deleteProfilePanel);

		add(wrapper, BorderLayout.NORTH);
	}
}

package com.runeprofile.panels.settings;

import com.google.gson.JsonObject;
import com.runeprofile.RuneProfileConfig;
import com.runeprofile.RuneProfilePlugin;
import lombok.extern.slf4j.Slf4j;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.FontManager;
import org.apache.commons.lang3.StringUtils;

import javax.swing.*;
import javax.swing.border.Border;
import javax.swing.border.EmptyBorder;
import java.awt.*;
import java.awt.datatransfer.Clipboard;
import java.awt.datatransfer.StringSelection;
import java.util.concurrent.atomic.AtomicReference;

@Slf4j
public class PrivateProfilePanel extends JPanel {
	private final AtomicReference<String> privateUrl = new AtomicReference<>();
	private final JLabel urlLabel = new JLabel();

	public PrivateProfilePanel(RuneProfilePlugin runeProfilePlugin) {
		setLayout(new BorderLayout());

		JPanel wrapper = new JPanel(new GridLayout(0, 1, 0, 4));

		Border buttonBorder = new EmptyBorder(8, 16, 8, 16);

		String storedUrl = RuneProfilePlugin.getConfigManager().getRSProfileConfiguration(RuneProfileConfig.CONFIG_GROUP, RuneProfileConfig.GENERATED_PATH);
		privateUrl.set(storedUrl == null ? "None" : storedUrl);
		urlLabel.setText(getHiddenURL(privateUrl.get()));

		JLabel titleLabel = new JLabel("Private Profile URL");
		titleLabel.setFont(FontManager.getRunescapeBoldFont());
		titleLabel.setForeground(Color.WHITE);
		wrapper.add(titleLabel);

		String isPrivateString = RuneProfilePlugin.getConfigManager().getRSProfileConfiguration(RuneProfileConfig.CONFIG_GROUP, RuneProfileConfig.IS_PRIVATE);
		System.out.println("isPrivateString: " + isPrivateString);
		boolean storedIsPrivate = Boolean.parseBoolean(isPrivateString);
		System.out.println("storedIsPrivate: " + storedIsPrivate);

		JCheckBox privateCheckbox = new JCheckBox("Private profile");
		privateCheckbox.setToolTipText("Disables the public username URL and generates a hidden URL instead.");
		privateCheckbox.setSelected(storedIsPrivate);
		privateCheckbox.addActionListener((event) -> {
			new Thread(() -> {
				SwingUtilities.invokeLater(() -> privateCheckbox.setEnabled(false));

				try {
					JsonObject response = runeProfilePlugin.updateIsPrivate(privateCheckbox.isSelected());

					// Sync checkbox with server state
					privateCheckbox.setSelected(response.get("isPrivate").getAsBoolean());

					// Sync url with possibly new generated path
					String path = response.get("generatedPath").getAsString();
					setNewURL(path);
				} catch (Exception e) {
					privateCheckbox.setSelected(!privateCheckbox.isSelected());
				}

				SwingUtilities.invokeLater(() -> privateCheckbox.setEnabled(true));
			}).start();
		});
		wrapper.add(privateCheckbox);

		JPanel urlContainer = new JPanel();
		urlContainer.setLayout(new BorderLayout());
		urlContainer.setBackground(ColorScheme.DARKER_GRAY_COLOR);
		urlContainer.setBorder(new EmptyBorder(4, 4, 4, 4));

		urlLabel.setFont(new Font("Courier New", Font.PLAIN, 11));
		urlContainer.add(urlLabel);
		wrapper.add(urlContainer);

		JButton copyButton = new JButton("Copy");
		copyButton.addActionListener(e -> {
			StringSelection stringSelection = new StringSelection(privateUrl.get());
			Clipboard clipboard = Toolkit.getDefaultToolkit().getSystemClipboard();
			clipboard.setContents(stringSelection, null);
		});
		copyButton.setBorder(buttonBorder);
		wrapper.add(copyButton);

		JButton newButton = new JButton("Generate New URL");
		newButton.addActionListener((event) -> {
			new Thread(() -> {
				newButton.setEnabled(false);

				try {
					String path = runeProfilePlugin.updateGeneratedPath();
					setNewURL(path);
				} catch (Exception e) {
					e.printStackTrace();
				}

				newButton.setEnabled(true);
			}).start();
		});
		newButton.setBorder(buttonBorder);
		wrapper.add(newButton);

		add(wrapper, BorderLayout.NORTH);
	}

	private void setNewURL(String path) {
		String newUrl = path.equals("None") ? path : "runeprofile.com/" + path;

		privateUrl.set(newUrl);
		SwingUtilities.invokeLater(() -> urlLabel.setText(getHiddenURL(privateUrl.get())));
	}

	private String getHiddenURL(String url) {
		if (url.equals("None")) return url;

		try {
			int charactersToShow = 4;

			String[] path = url.split("/");

			String generatedPath = path[1];
			String firstCharacters = generatedPath.substring(0, charactersToShow);
			String stars = StringUtils.repeat("*", generatedPath.length() - charactersToShow);
			String fullProfilePath = firstCharacters + stars;

			return path[0] + "/" + fullProfilePath;
		} catch (Exception e) {
			log.error("Error getting hidden URL", e);
			return "None";
		}
	}
}

package com.runeprofile.panels.settings;

import com.runeprofile.RuneProfilePlugin;
import net.runelite.client.ui.FontManager;

import javax.swing.*;
import javax.swing.border.EmptyBorder;
import java.awt.*;

public class DeleteProfilePanel extends JPanel {
	public DeleteProfilePanel(RuneProfilePlugin runeProfilePlugin) {
		setLayout(new BorderLayout());

		JPanel wrapper = new JPanel(new GridLayout(0, 1, 0, 0));

		JLabel titleLabel = new JLabel("Delete Profile");
		titleLabel.setFont(FontManager.getRunescapeBoldFont());
		titleLabel.setForeground(Color.WHITE);
		wrapper.add(titleLabel);

		// Delete profile
		JButton deleteProfileButton = new JButton("Delete Profile");
		deleteProfileButton.addActionListener((event) -> {
			SwingUtilities.invokeLater(() -> deleteProfileButton.setEnabled(false));

			runeProfilePlugin.deleteProfile();

			SwingUtilities.invokeLater(() -> deleteProfileButton.setEnabled(true));
		});
		deleteProfileButton.setBorder(new EmptyBorder(8, 16, 8, 16));

		wrapper.add(deleteProfileButton);

		add(wrapper, BorderLayout.NORTH);
	}
}

package com.runeprofile.panels.settings;

import com.runeprofile.RuneProfileConfig;
import com.runeprofile.RuneProfilePlugin;
import com.runeprofile.utils.DocumentSizeFilter;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.DynamicGridLayout;
import net.runelite.client.ui.FontManager;

import javax.swing.*;
import javax.swing.border.EmptyBorder;
import javax.swing.event.DocumentEvent;
import javax.swing.event.DocumentListener;
import javax.swing.text.AbstractDocument;
import java.awt.*;

public class DescriptionPanel extends JPanel {
	private static final int maxLength = 100;
	private final JLabel descriptionTitle = new JLabel("Description (" + "0" + "/" + maxLength + ")");
	private final JTextArea descriptionEditor = new JTextArea(9, 0);

	public DescriptionPanel(RuneProfilePlugin runeProfilePlugin) {
		setLayout(new DynamicGridLayout(0, 1, 0, 4));

		descriptionTitle.setFont(FontManager.getRunescapeBoldFont());
		descriptionTitle.setForeground(Color.WHITE);

		JPanel container = new JPanel();
		container.setLayout(new BorderLayout());
		container.setBackground(ColorScheme.DARKER_GRAY_COLOR);
		container.setBorder(new EmptyBorder(8, 8, 8, 8));

		descriptionEditor.setTabSize(2);
		descriptionEditor.setSize(new Dimension(46 * 4 + 3, 200));
		descriptionEditor.setLineWrap(true);
		descriptionEditor.setWrapStyleWord(true);
		descriptionEditor.setOpaque(false);

		initText();
		initMaxLengthFilter();
		initDocumentListener();

		container.add(descriptionEditor);

		JButton updateButton = new JButton("Update Description");
		updateButton.setBorder(new EmptyBorder(8, 16, 8, 16));
		updateButton.addActionListener((event) -> {
			new Thread(() -> {
				SwingUtilities.invokeLater(() -> updateButton.setEnabled(false));

				try {
					String newDescription = runeProfilePlugin.updateDescription(descriptionEditor.getText());

					// Sync the description with the server
					descriptionEditor.setText(newDescription);
				} catch (Exception e) {
					e.printStackTrace();
				}

				SwingUtilities.invokeLater(() -> updateButton.setEnabled(true));
			}).start();
		});

		add(descriptionTitle);
		add(container);
		add(updateButton);
	}

	private void initText() {
		String storedDescription = RuneProfilePlugin.getConfigManager().getRSProfileConfiguration(
						RuneProfileConfig.CONFIG_GROUP,
						RuneProfileConfig.DESCRIPTION
		);

		descriptionEditor.setText(storedDescription);
		updateDescriptionCount();
	}

	private void updateDescriptionCount() {
		descriptionTitle.setText("Description (" + descriptionEditor.getDocument().getLength() + "/" + maxLength + ")");
	}

	private void initMaxLengthFilter() {
		AbstractDocument document = (AbstractDocument) descriptionEditor.getDocument();
		document.setDocumentFilter(new DocumentSizeFilter(maxLength));
	}

	private void initDocumentListener() {
		descriptionEditor.getDocument().addDocumentListener(new DocumentListener() {
			@Override
			public void insertUpdate(DocumentEvent e) {
				updateDescriptionCount();
			}

			@Override
			public void removeUpdate(DocumentEvent e) {
				updateDescriptionCount();
			}

			@Override
			public void changedUpdate(DocumentEvent e) {
				updateDescriptionCount();
			}
		});
	}
}

package com.runeprofile.panels.misc;

import com.runeprofile.Icon;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.FontManager;
import net.runelite.client.util.LinkBrowser;
import net.runelite.client.util.SwingUtil;

import javax.swing.*;
import javax.swing.border.EmptyBorder;
import javax.swing.plaf.basic.BasicButtonUI;
import java.awt.*;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;

public class HeaderPanel extends JPanel {
	private static final int iconSize = 16;
	private final JPanel buttonsContainer;

	public HeaderPanel() {
		setLayout(new BorderLayout());
		setBorder(new EmptyBorder(10, 10, 10, 10));

		JLabel title = new JLabel("RuneProfile");
		title.setForeground(Color.WHITE);
		title.setFont(FontManager.getRunescapeBoldFont());

		buttonsContainer = new JPanel();
		buttonsContainer.setLayout(new GridLayout(1, 2, 4, 0));

		addHeaderButton(Icon.WEB.getIcon(iconSize, iconSize), "Visit the website.", "https://runeprofile.com");
		addHeaderButton(Icon.GITHUB.getIcon(iconSize, iconSize), "Report issues or contribute.", "https://github.com/ReinhardtR/runeprofile");

		add(title, BorderLayout.WEST);
		add(buttonsContainer, BorderLayout.EAST);
	}

	private void addHeaderButton(ImageIcon icon, String tooltip, String url) {
		JButton button = new JButton();
		SwingUtil.removeButtonDecorations(button);

		button.setIcon(icon);
		button.setToolTipText(tooltip);
		button.addActionListener(e -> LinkBrowser.browse(url));

		button.setUI(new BasicButtonUI());
		button.setBackground(ColorScheme.DARK_GRAY_COLOR);
		button.addMouseListener(new MouseAdapter() {
			@Override
			public void mouseEntered(MouseEvent e) {
				button.setBackground(ColorScheme.DARK_GRAY_HOVER_COLOR);
			}

			@Override
			public void mouseExited(MouseEvent e) {
				button.setBackground(ColorScheme.DARK_GRAY_COLOR);
			}
		});

		buttonsContainer.add(button);
	}
}

package com.runeprofile.panels;

import net.runelite.client.ui.FontManager;

import javax.swing.*;
import javax.swing.border.EmptyBorder;
import java.awt.*;

public class InvalidPanel extends JPanel {
	private final JLabel hintText = new JLabel();

	public InvalidPanel() {
		setBorder(new EmptyBorder(50, 10, 0, 10));
		setLayout(new BorderLayout());

		JPanel wrapper = new JPanel(new BorderLayout());

		JLabel titleText = new JLabel("RuneProfile");
		titleText.setFont(FontManager.getRunescapeFont());
		titleText.setForeground(Color.WHITE);
		titleText.setHorizontalAlignment(SwingConstants.CENTER);
		wrapper.add(titleText, BorderLayout.NORTH);

		hintText.setFont(FontManager.getRunescapeSmallFont());
		hintText.setForeground(Color.GRAY);
		hintText.setHorizontalAlignment(SwingConstants.CENTER);
		wrapper.add(hintText, BorderLayout.CENTER);

		add(wrapper, BorderLayout.NORTH);
	}

	public void setHintText(String text) {
		SwingUtilities.invokeLater(() -> hintText.setText(text));
	}
}

package com.runeprofile.panels.collectionlog;

import lombok.extern.slf4j.Slf4j;
import net.runelite.client.ui.ColorScheme;

import javax.swing.*;
import javax.swing.border.EmptyBorder;
import java.awt.*;
import java.util.List;

@Slf4j
public class CollectionLogPanel extends JPanel {
	private final JList<String> missingEntriesList;
	private final DefaultListModel<String> missingEntriesListModel = new DefaultListModel<>();

	public CollectionLogPanel() {
		setLayout(new BorderLayout());

		JTextArea infoText1 = createInfoText("To register your Collection Log, you need to open each entry.");
		JTextArea infoText2 = createInfoText("This list will show all missing entries for the currently selected tab.");

		JPanel infoPanel = new JPanel();
		infoPanel.setLayout(new GridLayout(2, 1, 0, 10));
		infoPanel.setBorder(new EmptyBorder(0, 0, 10, 0));
		infoPanel.add(infoText1);
		infoPanel.add(infoText2);

		add(infoPanel, BorderLayout.NORTH);

		missingEntriesList = new JList<>(missingEntriesListModel);
		missingEntriesList.setLayout(new BorderLayout());
		missingEntriesList.setBackground(ColorScheme.DARKER_GRAY_COLOR);

		JScrollPane scrollPane = new JScrollPane(missingEntriesList);

		add(scrollPane, BorderLayout.CENTER);

		loadNoMissingEntriesState();
	}

	private void loadNoMissingEntriesState() {
		SwingUtilities.invokeLater(() -> {
			missingEntriesListModel.removeAllElements();
			missingEntriesListModel.addElement("No missing entries");
			missingEntriesList.revalidate();
			missingEntriesList.repaint();
		});
	}

	public void newTabSelected(List<String> missingEntries) {
		log.info("New tab selected, missing entries: {}", missingEntries);
		SwingUtilities.invokeLater(() -> {
			if (missingEntries.size() == 0) {
				loadNoMissingEntriesState();
			} else {
				missingEntriesListModel.removeAllElements();

				for (String missingEntry : missingEntries) {
					missingEntriesListModel.addElement(missingEntry);
				}

				missingEntriesList.revalidate();
				missingEntriesList.repaint();
			}
		});
	}

	public void newEntrySelected(String entry) {
		log.info("New entry selected: {}", entry);
		SwingUtilities.invokeLater(() -> {
			missingEntriesListModel.removeElement(entry);
			missingEntriesList.revalidate();
			missingEntriesList.repaint();
		});
	}

	private JTextArea createInfoText(String text) {
		JTextArea infoText = new JTextArea(text);
		infoText.setLineWrap(true);
		infoText.setWrapStyleWord(true);
		infoText.setEditable(false);
		infoText.setFocusable(false);
		return infoText;
	}
}

package com.runeprofile.panels;

import com.runeprofile.Icon;
import com.runeprofile.RuneProfilePlugin;
import com.runeprofile.panels.collectionlog.CollectionLogPanel;
import com.runeprofile.panels.home.HomePanel;
import com.runeprofile.panels.settings.SettingsPanel;
import lombok.Getter;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.components.materialtabs.MaterialTab;
import net.runelite.client.ui.components.materialtabs.MaterialTabGroup;

import javax.swing.*;
import javax.swing.border.EmptyBorder;
import java.awt.*;

public class MainPanel extends JPanel {
	private final static int TAB_ICON_SIZE = 20;
	private final JPanel display = new JPanel();
	private final MaterialTabGroup tabGroup = new MaterialTabGroup(display);
	@Getter
	private final CollectionLogPanel collectionLogPanel;

	public MainPanel(RuneProfilePlugin runeProfilePlugin) {
		setLayout(new BorderLayout());
		setBackground(ColorScheme.DARK_GRAY_COLOR);

		display.setBorder(new EmptyBorder(10, 10, 8, 10));

		tabGroup.setLayout(new GridLayout(0, 3, 8, 8));
		tabGroup.setBorder(new EmptyBorder(10, 10, 6, 10));

		add(tabGroup, BorderLayout.NORTH);
		add(display, BorderLayout.CENTER);

		MaterialTab home = addTab(Icon.HOME.getIcon(TAB_ICON_SIZE, TAB_ICON_SIZE), "Home", new HomePanel(runeProfilePlugin));

		collectionLogPanel = new CollectionLogPanel();
		addTab(Icon.COLLECTION_LOG.getIcon(TAB_ICON_SIZE, TAB_ICON_SIZE), "Collection Log", collectionLogPanel);

		addTab(Icon.SETTINGS.getIcon(TAB_ICON_SIZE, TAB_ICON_SIZE), "Settings", new SettingsPanel(runeProfilePlugin));

		tabGroup.select(home);
	}

	private MaterialTab addTab(ImageIcon icon, String name, JPanel contentPanel) {
		JPanel wrapped = new JPanel(new BorderLayout());
		wrapped.add(contentPanel, BorderLayout.CENTER);
		wrapped.setBackground(ColorScheme.DARK_GRAY_COLOR);
		wrapped.setBorder(new EmptyBorder(0, 4, 0, 4));

		JScrollPane scroller = new JScrollPane(wrapped);
		scroller.setHorizontalScrollBarPolicy(JScrollPane.HORIZONTAL_SCROLLBAR_NEVER);
		scroller.getVerticalScrollBar().setPreferredSize(new Dimension(16, 0));
		scroller.getVerticalScrollBar().setBorder(new EmptyBorder(0, 9, 0, 0));
		scroller.setBackground(ColorScheme.DARK_GRAY_COLOR);

		MaterialTab materialTab = new MaterialTab(new ImageIcon(), tabGroup, scroller);
		materialTab.setPreferredSize(new Dimension(30, 27));
		materialTab.setName(name);
		materialTab.setToolTipText(name);
		materialTab.setIcon(icon);

		tabGroup.addTab(materialTab);

		return materialTab;
	}
}

package com.runeprofile.panels.home;

import com.runeprofile.RuneProfileConfig;
import com.runeprofile.RuneProfilePlugin;
import lombok.extern.slf4j.Slf4j;
import net.runelite.client.ui.FontManager;

import javax.swing.*;
import javax.swing.border.Border;
import javax.swing.border.EmptyBorder;
import java.awt.*;

@Slf4j
public class HomePanel extends JPanel {
	public HomePanel(RuneProfilePlugin runeProfilePlugin) {
		setLayout(new BorderLayout());

		JPanel wrapper = new JPanel(new GridLayout(0, 1, 0, 6));

		Border buttonBorder = new EmptyBorder(8, 16, 8, 16);

		// Update account label
		String updatedAccountDate = RuneProfilePlugin.getConfigManager().getRSProfileConfiguration(RuneProfileConfig.CONFIG_GROUP, RuneProfileConfig.ACCOUNT_UPDATE_DATE);
		JLabel updatedAccountLabel = new JLabel((updatedAccountDate != null) ? "Last update: " + updatedAccountDate : "Last update: Never");
		updatedAccountLabel.setFont(FontManager.getRunescapeSmallFont());

		wrapper.add(updatedAccountLabel);

		// Update profile button
		JButton updateProfileButton = new JButton("Update Profile");
		updateProfileButton.setBorder(buttonBorder);
		updateProfileButton.addActionListener((event) -> {
			new Thread(() -> {
				SwingUtilities.invokeLater(() -> updateProfileButton.setEnabled(false));

				String lastUpdated = "Failed";

				try {
					lastUpdated = runeProfilePlugin.updateProfile();
				} catch (Exception e) {
					e.printStackTrace();
				}

				String finalLastUpdated = lastUpdated;
				SwingUtilities.invokeLater(() -> {
					updatedAccountLabel.setText("Last update: " + finalLastUpdated);
					updateProfileButton.setEnabled(true);
				});
			}).start();
		});

		wrapper.add(updateProfileButton);

		// Update model label
		String updatedModelDate = RuneProfilePlugin.getConfigManager().getRSProfileConfiguration(RuneProfileConfig.CONFIG_GROUP, RuneProfileConfig.MODEL_UPDATE_DATE);
		JLabel updatedModelLabel = new JLabel((updatedModelDate != null) ? "Last update: " + updatedModelDate : "Last update: Never");
		updatedModelLabel.setFont(FontManager.getRunescapeSmallFont());

		wrapper.add(updatedModelLabel);

		// Update model button
		JButton updateModelButton = new JButton("Update Model");
		updateModelButton.setBorder(buttonBorder);
		updateModelButton.addActionListener((event) -> {
			new Thread(() -> {
				SwingUtilities.invokeLater(() -> updateModelButton.setEnabled(false));

				String lastUpdated = "Failed";

				try {
					lastUpdated = runeProfilePlugin.updateModel();
				} catch (InterruptedException e) {
					e.printStackTrace();
				}

				String finalLastUpdated = lastUpdated;
				SwingUtilities.invokeLater(() -> {
					updatedModelLabel.setText("Last update: " + finalLastUpdated);
					updateModelButton.setEnabled(true);
				});
			}).start();
		});

		wrapper.add(updateModelButton);

		add(wrapper, BorderLayout.NORTH);
	}
}

package com.runeprofile.achievementdiary;

import lombok.Getter;
import lombok.RequiredArgsConstructor;

@RequiredArgsConstructor
public class AchievementDiaryState {
	@Getter
	private final String name;

	@Getter
	private final AchievementDiaryTierState easyTier;

	@Getter
	private final AchievementDiaryTierState mediumTier;

	@Getter
	private final AchievementDiaryTierState hardTier;

	@Getter
	private final AchievementDiaryTierState eliteTier;
}

package com.runeprofile.achievementdiary;

import lombok.Getter;
import lombok.RequiredArgsConstructor;

@RequiredArgsConstructor
public enum AchievementDiaryTier {
	EASY("Easy"),
	MEDIUM("Medium"),
	HARD("Hard"),
	ELITE("Elite");
	
	@Getter
	private final String name;
}

package com.runeprofile.achievementdiary;

import lombok.Getter;
import lombok.RequiredArgsConstructor;

@RequiredArgsConstructor
public class AchievementDiaryTierState {
	@Getter
	private final AchievementDiaryTier tier;
	@Getter
	private final int completedTasks;
	@Getter
	private final int totalTasks;
}

package com.runeprofile.achievementdiary;

import lombok.Getter;
import lombok.RequiredArgsConstructor;
import net.runelite.api.Client;

@RequiredArgsConstructor
public enum AchievementDiary {
	ARDOUGNE(1, "Ardougne"),
	DESERT(5, "Desert"),
	FALADOR(2, "Falador"),
	FREMENNIK(3, "Fremennik"),
	KANDARIN(4, "Kandarin"),
	KARAMJA(0, "Karamja"),
	KOUREND(11, "Kourend & Kebos"),
	LUMBRIDGE(6, "Lumbridge & Draynor"),
	MORYTANIA(7, "Morytania"),
	VARROCK(8, "Varrock"),
	WESTERN_PROVINCES(10, "Western Provinces"),
	WILDERNESS(9, "Wilderness");

	@Getter
	private final int id;

	@Getter
	private final String name;

	public AchievementDiaryState getState(Client client) {
		// https://github.com/RuneStar/cs2-scripts/blob/master/scripts/%5Bproc%2Cdiary_completion_info%5D.cs2
		client.runScript(2200, id);

		int[] stack = client.getIntStack();

		AchievementDiaryTierState easyTierState = new AchievementDiaryTierState(
						AchievementDiaryTier.EASY,
						stack[0],
						stack[1]
		);

		AchievementDiaryTierState mediumTierState = new AchievementDiaryTierState(
						AchievementDiaryTier.MEDIUM,
						stack[3],
						stack[4]
		);

		AchievementDiaryTierState hardTierState = new AchievementDiaryTierState(
						AchievementDiaryTier.HARD,
						stack[6],
						stack[7]
		);

		AchievementDiaryTierState eliteTierState = new AchievementDiaryTierState(
						AchievementDiaryTier.ELITE,
						stack[9],
						stack[10]
		);

		return new AchievementDiaryState(name, easyTierState, mediumTierState, hardTierState, eliteTierState);
	}
}

package com.runeprofile;

import com.google.common.collect.ImmutableList;
import com.google.gson.Gson;
import com.google.gson.JsonObject;
import com.google.inject.Provides;
import com.runeprofile.collectionlog.CollectionLogManager;
import com.runeprofile.dataobjects.PlayerData;
import com.runeprofile.dataobjects.PlayerModelData;
import com.runeprofile.utils.AccountHash;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.GameState;
import net.runelite.api.Player;
import net.runelite.api.WorldType;
import net.runelite.api.events.GameStateChanged;
import net.runelite.api.events.ScriptPostFired;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.externalplugins.ExternalPluginManager;
import net.runelite.client.hiscore.HiscoreClient;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.plugins.PluginDescriptor;
import net.runelite.client.ui.ClientToolbar;
import net.runelite.client.ui.NavigationButton;

import javax.inject.Inject;
import javax.swing.*;
import java.awt.image.BufferedImage;
import java.io.IOException;
import java.util.EnumSet;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.atomic.AtomicReference;

@Slf4j
@PluginDescriptor(
				name = "RuneProfile",
				description = "Show off your achievements on RuneProfile.com",
				tags = {"rune", "profile"}
)
public class RuneProfilePlugin extends Plugin {
	private static RuneProfilePlugin instance;

	@Inject
	private Client client;

	@Inject
	private RuneProfileConfig config;

	@Inject
	private RuneProfileApiClient runeProfileApiClient;

	@Inject
	private ExternalPluginManager externalPluginManager;

	@Inject
	private ClientToolbar clientToolbar;

	@Inject
	private ClientThread clientThread;

	@Inject
	private HiscoreClient hiscoreClient;

	@Inject
	private ConfigManager configManager;

	@Inject
	private Gson gson;

	private RuneProfilePanel runeProfilePanel;
	private NavigationButton navigationButton;
	private CollectionLogManager collectionLogManager;

	public static CollectionLogManager getCollectionLogManager() {
		return instance.collectionLogManager;
	}

	public static Client getClient() {
		return instance.client;
	}

	public static ClientThread getClientThread() {
		return instance.clientThread;
	}

	public static HiscoreClient getHiscoreClient() {
		return instance.hiscoreClient;
	}

	public static ConfigManager getConfigManager() {
		return instance.configManager;
	}

	public static Gson getGson() {
		return instance.gson;
	}

	public static RuneProfilePanel getPanel() {
		return instance.runeProfilePanel;
	}

	@Provides
	RuneProfileConfig provideConfig(ConfigManager configManager) {
		return configManager.getConfig(RuneProfileConfig.class);
	}

	@Override
	protected void startUp() {
		instance = this;

		this.runeProfilePanel = new RuneProfilePanel(this);
		final BufferedImage toolbarIcon = Icon.LOGO.getImage();

		navigationButton = NavigationButton.builder()
						.tooltip("RuneProfile")
						.icon(toolbarIcon)
						.panel(runeProfilePanel)
						.priority(1)
						.build();

		clientToolbar.addNavigation(navigationButton);
	}

	@Override
	protected void shutDown() {
		clientToolbar.removeNavigation(navigationButton);
	}

	@Subscribe
	private void onGameStateChanged(GameStateChanged state) {
		if (state.getGameState() == GameState.LOGGED_IN) {
			if (!isValidWorldType(client.getWorldType())) {
				runeProfilePanel.loadInvalidRequestState();
				return;
			}

			// Collection Log Manager is null, if it's the first time logging in.
			// Need to reload the manager if it's a different account.
			if (collectionLogManager == null) {
				collectionLogManager = new CollectionLogManager(gson);
			} else {
				collectionLogManager.reloadManager();
			}

			runeProfilePanel.loadValidState();
		} else if (state.getGameState() == GameState.LOGIN_SCREEN) {
			runeProfilePanel.loadInvalidState();

			if (config.updateOnLogout() && collectionLogManager != null && client.getLocalPlayer() != null) {
				new Thread(() -> {
					try {
						updateProfile();
					} catch (InterruptedException e) {
						throw new RuntimeException(e);
					}
				}).start();
			}
		}
	}

	@Subscribe
	public void onScriptPostFired(ScriptPostFired scriptPostFired) {
		if (collectionLogManager != null) {
			collectionLogManager.onScriptPostFired(scriptPostFired);
		}
	}

	public String updateProfile() throws IllegalStateException, InterruptedException {
		isValidRequest();

		String updateDateString;

		try {
			PlayerData playerData = new PlayerData();
			updateDateString = runeProfileApiClient.updateProfile(playerData);
		} catch (IOException | InterruptedException e) {
			throw new RuntimeException(e);
		}

		log.info("NEW DATE STRING: " + updateDateString);
		configManager.setRSProfileConfiguration(
						RuneProfileConfig.CONFIG_GROUP,
						RuneProfileConfig.ACCOUNT_UPDATE_DATE,
						updateDateString
		);

		return updateDateString;
	}

	public String updateModel() throws IllegalStateException, InterruptedException {
		isValidRequest();

		AtomicReference<PlayerModelData> playerModelData = new AtomicReference<>();

		CountDownLatch clientLatch = new CountDownLatch(1);

		clientThread.invokeLater(() -> {
			try {
				playerModelData.set(new PlayerModelData(client));
			} catch (IOException e) {
				e.printStackTrace();
			} finally {
				clientLatch.countDown();
			}
		});

		clientLatch.await();

		String updateDatetimeString;

		try {
			updateDatetimeString = runeProfileApiClient.updateModel(playerModelData.get());
		} catch (RuntimeException e) {
			throw new RuntimeException(e);
		}

		configManager.setRSProfileConfiguration(
						RuneProfileConfig.CONFIG_GROUP,
						RuneProfileConfig.MODEL_UPDATE_DATE,
						updateDatetimeString
		);

		return updateDatetimeString;
	}

	public String updateGeneratedPath() throws Exception {
		isValidRequest();

		AtomicReference<String> accountHash = new AtomicReference<>();

		CountDownLatch clientLatch = new CountDownLatch(1);

		clientThread.invokeLater(() -> {
			accountHash.set(AccountHash.getHashed(client));
			clientLatch.countDown();
		});

		clientLatch.await();

		String newUrl;

		try {
			newUrl = runeProfileApiClient.updateGeneratedPath(accountHash.get());
		} catch (Exception e) {
			throw new RuntimeException(e);
		}

		if (newUrl == null) {
			throw new Exception("Failed to update generated path");
		}

		configManager.setRSProfileConfiguration(
						RuneProfileConfig.CONFIG_GROUP,
						RuneProfileConfig.GENERATED_PATH,
						newUrl
		);

		return newUrl;
	}

	public JsonObject updateIsPrivate(boolean isPrivate) throws Exception {
		isValidRequest();

		AtomicReference<String> accountHash = new AtomicReference<>();

		CountDownLatch clientLatch = new CountDownLatch(1);

		clientThread.invokeLater(() -> {
			accountHash.set(AccountHash.getHashed(client));
			clientLatch.countDown();
		});

		clientLatch.await();

		JsonObject response;

		try {
			response = runeProfileApiClient.updateIsPrivate(accountHash.get(), isPrivate);
		} catch (Exception e) {
			throw new RuntimeException(e);
		}

		log.info("RESPONSE: " + response.get("isPrivate").getAsString());
		log.info("RESPONSE: " + response.get("isPrivate").toString());

		configManager.setRSProfileConfiguration(
						RuneProfileConfig.CONFIG_GROUP,
						RuneProfileConfig.IS_PRIVATE,
						response.get("isPrivate")
		);

		configManager.setRSProfileConfiguration(
						RuneProfileConfig.CONFIG_GROUP,
						RuneProfileConfig.GENERATED_PATH,
						response.get("generatedPath")
		);

		return response;
	}

	public String updateDescription(String description) throws Exception {
		isValidRequest();

		AtomicReference<String> accountHash = new AtomicReference<>();

		CountDownLatch clientLatch = new CountDownLatch(1);

		clientThread.invokeLater(() -> {
			accountHash.set(AccountHash.getHashed(client));
			clientLatch.countDown();
		});

		clientLatch.await();

		String newDescription;

		try {
			newDescription = runeProfileApiClient.updateDescription(accountHash.get(), description);
		} catch (Exception e) {
			throw new RuntimeException(e);
		}

		if (newDescription == null) {
			throw new RuntimeException("Failed to update description");
		}

		configManager.setRSProfileConfiguration(
						RuneProfileConfig.CONFIG_GROUP,
						RuneProfileConfig.DESCRIPTION,
						newDescription
		);

		return newDescription;
	}

	public void deleteProfile() {
		isValidRequest();

		if (!isConfirmedDeletion("Are you sure you want to delete your RuneProfile?")) {
			return;
		}

		clientThread.invokeLater(() -> {
			String accountHash = AccountHash.getHashed(client);

			new Thread(() -> {
				runeProfileApiClient.deleteProfile(accountHash);
			}).start();
		});

		runeProfilePanel.loadInvalidState();
		configManager.unsetRSProfileConfiguration(RuneProfileConfig.CONFIG_GROUP, RuneProfileConfig.COLLECTION_LOG);
		configManager.unsetRSProfileConfiguration(RuneProfileConfig.CONFIG_GROUP, RuneProfileConfig.GENERATED_PATH);
		configManager.unsetRSProfileConfiguration(RuneProfileConfig.CONFIG_GROUP, RuneProfileConfig.DESCRIPTION);
		configManager.unsetRSProfileConfiguration(RuneProfileConfig.CONFIG_GROUP, RuneProfileConfig.IS_PRIVATE);
		configManager.unsetRSProfileConfiguration(RuneProfileConfig.CONFIG_GROUP, RuneProfileConfig.HAS_MODEL);
		collectionLogManager.reloadManager();
		runeProfilePanel.loadValidState();
	}

	private boolean isConfirmedDeletion(String message) {
		int confirm = JOptionPane.showConfirmDialog(
						runeProfilePanel,
						message,
						"RuneProfile",
						JOptionPane.OK_CANCEL_OPTION
		);

		return confirm == JOptionPane.YES_OPTION;
	}

	private void isValidRequest() throws IllegalStateException {
		if (!isValidWorldType(client.getWorldType())) {
			throw new IllegalStateException("Not on a valid world type");
		}

		long accountHash = client.getAccountHash();

		if (accountHash == -1) {
			throw new IllegalStateException("Failed to get AccountHash");
		}

		Player player = client.getLocalPlayer();

		if (player == null || player.getName() == null) {
			throw new IllegalStateException("Failed to get Player");
		}
	}

	private boolean isValidWorldType(EnumSet<WorldType> worldTypes) {
		return ImmutableList.of(
						WorldType.MEMBERS,
						WorldType.PVP,
						WorldType.SKILL_TOTAL,
						WorldType.HIGH_RISK,
						WorldType.LAST_MAN_STANDING
		).stream().anyMatch(worldTypes::contains);
	}
}

package com.runeprofile.collectionlog;

import lombok.RequiredArgsConstructor;

@RequiredArgsConstructor
public class CollectionLogKillCount {
	private final int index;
	private final String name;
	private final int count;
}

package com.runeprofile.collectionlog;

import lombok.RequiredArgsConstructor;

import javax.annotation.Nullable;

@RequiredArgsConstructor
public class CollectionLogPage {
	private final int index;

	private final CollectionLogItem[] items;

	@Nullable
	private final CollectionLogKillCount[] killCounts;
}

package com.runeprofile.collectionlog;

import lombok.RequiredArgsConstructor;
import lombok.Setter;

import java.util.HashMap;
import java.util.Map;

@RequiredArgsConstructor
public class CollectionLog {

	// First map is a tab, second map is the pages in the tab
	private final Map<String, Map<String, CollectionLogPage>> tabs = new HashMap<>();

	@Setter
	private int uniqueItemsTotal;

	@Setter
	private int uniqueItemsObtained;

	public Map<String, CollectionLogPage> getTab(String key) {
		if (tabs.containsKey(key)) {
			return tabs.get(key);
		}

		tabs.put(key, new HashMap<>());

		return tabs.get(key);
	}
}

package com.runeprofile.collectionlog;

import lombok.RequiredArgsConstructor;

@RequiredArgsConstructor
public class CollectionLogItem {
	private final int index;
	private final int id;
	private final String name;
	private final int quantity;
}

package com.runeprofile.collectionlog;

import lombok.Getter;
import lombok.RequiredArgsConstructor;

@RequiredArgsConstructor
public enum CollectionLogTabs {
	BOSSES("Bosses", 4, 12),
	RAIDS("Raids", 5, 16),
	CLUES("Clues", 6, 32),
	MINIGAMES("Minigames", 7, 35),
	OTHER("Other", 8, 34);

	@Getter
	private final String name;

	@Getter
	private final int id;

	@Getter
	private final int entryListId;

	public static CollectionLogTabs getByName(String name) {
		for (CollectionLogTabs tab : CollectionLogTabs.values()) {
			if (tab.getName().equals(name)) {
				return tab;
			}
		}

		return null;
	}
}

package com.runeprofile.collectionlog;

import com.google.gson.Gson;
import com.runeprofile.RuneProfileConfig;
import com.runeprofile.RuneProfilePlugin;
import lombok.Getter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.ScriptID;
import net.runelite.api.events.ScriptPostFired;
import net.runelite.api.widgets.*;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.config.ConfigManager;

import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.Set;

@Slf4j
public class CollectionLogManager {
	private static final int TAB_ACTIVE_COLOR = 16754735;
	private static final int TAB_TEXT_INDEX = 3;

	private final Client client;
	private final ClientThread clientThread;
	private final ConfigManager configManager;
	private final Gson gson;
	private String previousTab = null;
	@Getter
	private CollectionLog collectionLog;

	public CollectionLogManager(Gson gson) {
		this.gson = gson;
		this.client = RuneProfilePlugin.getClient();
		this.configManager = RuneProfilePlugin.getConfigManager();
		this.clientThread = RuneProfilePlugin.getClientThread();
		reloadManager();
	}

	public void reloadManager() {
		collectionLog = getStoredCollectionLog();
	}

	private CollectionLog getStoredCollectionLog() {
		String collectionLogString = configManager.getRSProfileConfiguration(
						RuneProfileConfig.CONFIG_GROUP,
						RuneProfileConfig.COLLECTION_LOG
		);

		if (collectionLogString == null) {
			return new CollectionLog();
		}

		try {
			return gson.fromJson(collectionLogString, CollectionLog.class);
		} catch (Exception e) {
			log.error("Error parsing collection log", e);
			return new CollectionLog();
		}
	}

	public void onScriptPostFired(ScriptPostFired scriptPostFired) {
		if (scriptPostFired.getScriptId() == ScriptID.COLLECTION_DRAW_LIST) {
			log.info("COLLECTION DRAW LIST FIRED");

			if (RuneProfilePlugin.getClient().getWidget(InterfaceID.ADVENTURE_LOG) != null) {
				log.info("Adventure Log isn't supported");
				return;
			}

			clientThread.invokeLater(this::updateCollectionLog);
			updateCollectionLogPanel();
		}
	}

	private void updateCollectionLogPanel() {
		String tabName = getTabName();

		if (tabName == null) {
			return;
		}

		if (tabName.equals(previousTab)) {
			RuneProfilePlugin.getPanel().getMainPanel().getCollectionLogPanel().newEntrySelected(getEntryName());
			return;
		}

		previousTab = tabName;

		List<String> entriesInTab = new ArrayList<>();

		Widget[] entryWidgets = getEntriesInTab();
		if (entryWidgets != null) {
			for (Widget entryWidget : entryWidgets) {
				entriesInTab.add(entryWidget.getText());
			}
		}

		Map<String, CollectionLogPage> storedTab = collectionLog.getTab(tabName);

		if (storedTab == null) {
			return;
		}

		Set<String> storedInLog = storedTab.keySet();

		List<String> missingEntries = new ArrayList<>(entriesInTab);
		missingEntries.removeAll(storedInLog);
		missingEntries.remove(getEntryName());

		RuneProfilePlugin.getPanel().getMainPanel().getCollectionLogPanel().newTabSelected(missingEntries);
	}

	private Widget[] getEntriesInTab() {
		String entryName = getEntryName();

		if (entryName == null) {
			return null;
		}

		CollectionLogTabs tab = CollectionLogTabs.getByName(getTabName());

		if (tab == null) {
			return null;
		}

		Widget entryList = client.getWidget(InterfaceID.COLLECTION_LOG, tab.getEntryListId());

		if (entryList == null) {
			return null;
		}

		return entryList.getDynamicChildren();
	}

	public CollectionLogPage getEntry() {
		String name = getEntryName();

		if (name == null) {
			return null;
		}

		int index = getEntryIndex();
		CollectionLogItem[] items = getItems().toArray(new CollectionLogItem[0]);
		CollectionLogKillCount[] killCounts = getKillCounts().toArray(new CollectionLogKillCount[0]);

		return new CollectionLogPage(index, items, killCounts.length > 0 ? killCounts : null);
	}

	public void updateCollectionLog() {
		// Get entry
		CollectionLogPage collectionLogPage = getEntry();

		if (collectionLogPage == null) {
			log.error("Failed to get entry");
			return;
		}

		// Update collection log
		String tabTitle = getTabName();
		String entryName = getEntryName();
		collectionLog.getTab(tabTitle).put(entryName, collectionLogPage);

		int uniqueItemsObtained = client.getVarpValue(2943);
		collectionLog.setUniqueItemsObtained(uniqueItemsObtained);

		int uniqueItemsTotal = client.getVarpValue(2944);
		collectionLog.setUniqueItemsTotal(uniqueItemsTotal);

		configManager.setRSProfileConfiguration(
						RuneProfileConfig.CONFIG_GROUP,
						RuneProfileConfig.COLLECTION_LOG,
						gson.toJson(collectionLog)
		);

		log.info("Updated the Collection Log");
	}

	private Widget getEntryHead() {
		return client.getWidget(ComponentID.COLLECTION_LOG_ENTRY_HEADER);
	}

	private int getEntryIndex() {
		Widget[] entries = getEntriesInTab();

		int index = -1;

		if (entries == null) {
			log.error("Failed to get entry index");
			return index;
		}

		String entryName = getEntryName();

		for (int i = 0; i < entries.length; i++) {
			String entryText = entries[i].getText();

			if (entryText.equals(entryName)) {
				index = i;
				break;
			}
		}

		log.info("ENTRY INDEX: " + index);
		return index;
	}

	private String getEntryName() {
		Widget entryHead = getEntryHead();

		if (entryHead == null) {
			return null;
		}

		Widget[] children = entryHead.getDynamicChildren();

		if (children == null || children.length == 0) {
			log.error("Failed to get entry name");
			return null;
		}

		return children[0].getText();
	}

	private String getTabName() {
		for (CollectionLogTabs tab : CollectionLogTabs.values()) {
			Widget tabWidget = client.getWidget(InterfaceID.COLLECTION_LOG, tab.getId());

			if (tabWidget == null) {
				continue;
			}

			Widget[] children = tabWidget.getDynamicChildren();

			if (children == null || TAB_TEXT_INDEX >= children.length) {
				continue;
			}

			Widget titleWidget = children[TAB_TEXT_INDEX];
			String title = titleWidget.getText();
			int color = titleWidget.getTextColor();

			if (color == TAB_ACTIVE_COLOR) {
				return title;
			}
		}

		log.error("Failed to get tab name");
		return null;
	}

	private List<CollectionLogItem> getItems() {
		List<CollectionLogItem> items = new ArrayList<>();

		Widget itemsContainer = client.getWidget(ComponentID.COLLECTION_LOG_ENTRY_ITEMS);

		if (itemsContainer == null) {
			return items;
		}

		Widget[] itemWidgets = itemsContainer.getDynamicChildren();

		for (Widget itemWidget : itemWidgets) {
			int index = itemWidget.getIndex();
			int id = itemWidget.getItemId();
			String name = unwrapText(itemWidget.getName());
			int quantity = itemWidget.getOpacity() == 0 ? itemWidget.getItemQuantity() : 0;

			items.add(new CollectionLogItem(index, id, name, quantity));
		}

		return items;
	}

	private List<CollectionLogKillCount> getKillCounts() {
		List<CollectionLogKillCount> killCounts = new ArrayList<>();

		Widget entryHead = getEntryHead();

		if (entryHead == null) {
			return killCounts;
		}

		Widget[] children = entryHead.getDynamicChildren();

		if (children == null || children.length < 3) {
			return killCounts;
		}

		// add all counters of all lines in the widget (starting from child index 2)
		for (int childIndex = 2; childIndex < children.length; childIndex++) {
			String rawKillCount = children[childIndex].getText();
			String[] killCountParts = rawKillCount.split(": ");

			// guard: make sure this is a KC line
			if (killCountParts.length <= 1) {
				continue;
			}

			String killCountName = killCountParts[0];
			int killCountAmount = Integer.parseInt(unwrapText(killCountParts[1]));

			killCounts.add(new CollectionLogKillCount(childIndex - 2, killCountName, killCountAmount));
		}

		return killCounts;
	}

	// Example
	// Input: "<col=ff9040>Abyssal whip</col>"
	// Output: "Abyssal whip"
	private String unwrapText(String text) {
		return text.split(">")[1]
						.split("<")[0]
						.replace(",", "");
	}
}

package com.runeprofile.utils;

import java.text.ParseException;
import java.text.SimpleDateFormat;

public class DateHeader {

	private static SimpleDateFormat headerFormat;
	private static SimpleDateFormat stringFormat;

	public static String getDateString(String dateString) {
		if (headerFormat == null) {
			headerFormat = new SimpleDateFormat("EEE, dd MMM yyyy HH:mm:ss zzz");
		}

		if (stringFormat == null) {
			stringFormat = new SimpleDateFormat("MM/dd/yyyy HH:mm:ss");
		}

		try {
			return stringFormat.format(headerFormat.parse(dateString));
		} catch (ParseException e) {
			return "Failed to parse";
		}
	}
}

package com.runeprofile.utils;

import net.runelite.api.Client;

import java.nio.charset.StandardCharsets;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.util.Base64;

public class AccountHash {
	public static String getHashed(Client client) {
		long accountHashLong = client.getAccountHash();

		if (accountHashLong == -1) {
			return null;
		}

		String accountHashString = String.valueOf(accountHashLong);

		MessageDigest digest = null;

		try {
			digest = MessageDigest.getInstance("SHA-1");
		} catch (NoSuchAlgorithmException e) {
			throw new RuntimeException(e);
		}

		byte[] hash = digest.digest(accountHashString.getBytes(StandardCharsets.UTF_8));

		return Base64.getEncoder().encodeToString(hash);
	}
}

package com.runeprofile.utils;

import javax.swing.text.AttributeSet;
import javax.swing.text.BadLocationException;
import javax.swing.text.DocumentFilter;
import java.awt.*;

public class DocumentSizeFilter extends DocumentFilter {
	int maxCharacters;
	boolean DEBUG = false;

	public DocumentSizeFilter(int maxChars) {
		maxCharacters = maxChars;
	}

	public void insertString(FilterBypass fb, int offs,
													 String str, AttributeSet a)
					throws BadLocationException {
		if (DEBUG) {
			System.out.println("in DocumentSizeFilter's insertString method");
		}

		//This rejects the entire insertion if it would make
		//the contents too long. Another option would be
		//to truncate the inserted string so the contents
		//would be exactly maxCharacters in length.
		if ((fb.getDocument().getLength() + str.length()) <= maxCharacters)
			super.insertString(fb, offs, str, a);
		else
			Toolkit.getDefaultToolkit().beep();
	}

	public void replace(FilterBypass fb, int offs,
											int length,
											String str, AttributeSet a)
					throws BadLocationException {
		if (DEBUG) {
			System.out.println("in DocumentSizeFilter's replace method");
		}
		//This rejects the entire replacement if it would make
		//the contents too long. Another option would be
		//to truncate the replacement string so the contents
		//would be exactly maxCharacters in length.
		if ((fb.getDocument().getLength() + str.length()
						- length) <= maxCharacters)
			super.replace(fb, offs, length, str, a);
		else
			Toolkit.getDefaultToolkit().beep();
	}

}
package com.runeprofile;

import com.runeprofile.panels.InvalidPanel;
import com.runeprofile.panels.MainPanel;
import com.runeprofile.panels.misc.HeaderPanel;
import lombok.Getter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.client.ui.PluginPanel;

import javax.swing.*;
import java.awt.*;

@Slf4j
public class RuneProfilePanel extends PluginPanel {
	private final RuneProfilePlugin runeProfilePlugin;

	@Getter
	private MainPanel mainPanel;
	private InvalidPanel invalidPanel;

	public RuneProfilePanel(RuneProfilePlugin runeProfilePlugin) {
		super(false);
		setLayout(new BorderLayout());

		this.runeProfilePlugin = runeProfilePlugin;

		add(new HeaderPanel(), BorderLayout.NORTH);
		loadInvalidState();
	}

	public void loadValidState() {
		SwingUtilities.invokeLater(() -> {
			if (invalidPanel != null) {
				remove(invalidPanel);
			}

			mainPanel = new MainPanel(runeProfilePlugin);

			add(mainPanel, BorderLayout.CENTER);
			revalidate();
			repaint();
		});
	}

	public void loadInvalidState() {
		SwingUtilities.invokeLater(() -> {
			if (mainPanel != null) {
				remove(mainPanel);
			}

			if (invalidPanel == null) {
				invalidPanel = new InvalidPanel();
			}

			invalidPanel.setHintText("Login to use this plugin.");
			add(invalidPanel, BorderLayout.CENTER);
			revalidate();
			repaint();
		});
	}

	public void loadInvalidRequestState() {
		SwingUtilities.invokeLater(() -> {
			if (mainPanel != null) {
				remove(mainPanel);
			}

			if (invalidPanel == null) {
				invalidPanel = new InvalidPanel();
			}

			invalidPanel.setHintText("Invalid world/mode.");
			add(invalidPanel, BorderLayout.CENTER);
			revalidate();
			repaint();
		});
	}
}

package com.runeprofile;

import net.runelite.client.config.Config;
import net.runelite.client.config.ConfigGroup;
import net.runelite.client.config.ConfigItem;

@ConfigGroup("runeprofile")
public interface RuneProfileConfig extends Config {
	String CONFIG_GROUP = "runeprofile";
	String COLLECTION_LOG = "collection_log";
	String DESCRIPTION = "description";
	String GENERATED_PATH = "generated_path"; // The generated path for the profile.
	String IS_PRIVATE = "is_private"; // The profile is unlisted/private.
	String HAS_MODEL = "has_model"; // A model has been submitted before.

	String MODEL_UPDATE_DATE = "model_update_date"; // The last time the model was updated.
	String ACCOUNT_UPDATE_DATE = "account_update_date"; // The last time the account was updated.

	@ConfigItem(keyName = "update_on_logout", name = "Update on logout", description = "Automatically update your RuneProfile on logout. (Excluding model)")
	default boolean updateOnLogout() {
		return true;
	}
}

package com.runeprofile.combatachievements;

import lombok.Getter;
import lombok.RequiredArgsConstructor;
import net.runelite.api.Client;

@RequiredArgsConstructor
public enum CombatAchievementTier {
	EASY(1, "Easy"),
	MEDIUM(2, "Medium"),
	HARD(3, "Hard"),
	ELITE(4, "Elite"),
	MASTER(5, "Master"),
	GRANDMASTER(6, "Grandmaster");

	@Getter
	private final int id;

	@Getter
	private final String name;

	public CombatAchievementTierState getState(Client client) {
		// CA Tasks Completed in Tier
		// https://github.com/RuneStar/cs2-scripts/blob/master/scripts/%5Bproc%2Cca_tasks_completed_tier%5D.cs2
		client.runScript(4784, id);
		int tasksCompleted = client.getIntStack()[0];

		// CA Total Tasks in Tier
		// https://github.com/RuneStar/cs2-scripts/blob/master/scripts/%5Bproc,ca_tasks_tier_total%5D.cs2
		client.runScript(4789, id);
		int totalTasks = client.getIntStack()[0];

		return new CombatAchievementTierState(this, tasksCompleted, totalTasks);
	}
}

package com.runeprofile.combatachievements;

import lombok.Getter;
import lombok.RequiredArgsConstructor;

@RequiredArgsConstructor
public enum CombatAchievementVarps {
	TASK_PROGRESS_0(3116),
	TASK_PROGRESS_1(3117),
	TASK_PROGRESS_2(3118),
	TASK_PROGRESS_3(3119),
	TASK_PROGRESS_4(3120),
	TASK_PROGRESS_5(3121),
	TASK_PROGRESS_6(3122),
	TASK_PROGRESS_7(3123),
	TASK_PROGRESS_8(3124),
	TASK_PROGRESS_9(3125),
	TASK_PROGRESS_10(3126),
	TASK_PROGRESS_11(3127),
	TASK_PROGRESS_12(3128);

	@Getter
	private final int varpId;
}

package com.runeprofile.combatachievements;

import lombok.Getter;
import lombok.RequiredArgsConstructor;

@RequiredArgsConstructor
public class CombatAchievementTierState {
	@Getter
	private final CombatAchievementTier tier;

	@Getter
	private final int completedTasks;

	@Getter
	private final int totalTasks;
}

/*
 *
 *  * Copyright (c) 2021, Senmori
 *  * All rights reserved.
 *  *
 *  * Redistribution and use in source and binary forms, with or without
 *  * modification, are permitted provided that the following conditions are met:
 *  *
 *  * 1. Redistributions of source code must retain the above copyright notice, this
 *  *    list of conditions and the following disclaimer.
 *  * 2. Redistributions in binary form must reproduce the above copyright notice,
 *  *    this list of conditions and the following disclaimer in the documentation
 *  *    and/or other materials provided with the distribution.
 *  *
 *  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 *  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 *  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 *  * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 *  * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 *  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 *  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 *  * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 *  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 *  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 */

package com.runeprofile;

import net.runelite.client.util.ImageUtil;

import javax.swing.*;
import java.awt.image.BufferedImage;

public enum Icon {
	LOGO("/logo.png"),

	WEB("/web.png"),
	DISCORD("/discord.png"),
	GITHUB("/github.png"),
	HOME("/home.png"),
	COLLECTION_LOG("/collection_log.png"),
	SETTINGS("/settings.png");

	private final String file;

	Icon(String file) {
		this.file = file;
	}

	public BufferedImage getImage() {
		return ImageUtil.loadImageResource(RuneProfilePlugin.class, file);
	}

	public ImageIcon getIcon(int width, int height) {
		return new ImageIcon(ImageUtil.resizeImage(getImage(), width, height));
	}
}
