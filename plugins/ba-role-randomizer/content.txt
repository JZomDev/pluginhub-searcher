package com.rolerandomizer;

import java.awt.Color;
import lombok.Getter;
import lombok.RequiredArgsConstructor;
import net.runelite.client.util.Text;

@RequiredArgsConstructor
public enum BaRole
{
	ATTACKER(Color.RED.darker()),
	DEFENDER(Color.BLUE.darker()),
	COLLECTOR(Color.YELLOW),
	HEALER(Color.GREEN.darker().darker());

	@Getter
	private final Color color;

	public String displayName()
	{
		return Text.titleCase(this);
	}
}

package com.rolerandomizer.exceptions;

public class CannotDetermineRolesException extends Exception
{
	public CannotDetermineRolesException()
	{
		super("Cannot determine role prefs for all 5 players");
	}
}

package com.rolerandomizer.exceptions;

public class CannotParseArgException extends Exception
{
	public CannotParseArgException(String arg)
	{
		super(arg + " is not a valid player name or role");
	}
}

/*
 * Copyright (c) 2021, Keano Porcaro <keano@ransty.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.rolerandomizer.exceptions;

public class NoPermutationException extends Exception
{
    public NoPermutationException(String message)
    {
        super(message);
    }
}

package com.rolerandomizer;

import java.util.regex.Pattern;
import lombok.Getter;
import lombok.RequiredArgsConstructor;

/**
 * Strings sent as arguments could be interpreted as player names or roles
 */
@RequiredArgsConstructor
public enum InputCandidate
{
	NAME(Pattern.compile("[A-Za-z0-9_-]{1,12}")),
	ROLE(Pattern.compile("[m2ahcd]{1,5}|fill|" + MetaRoleInfo.SLASH_SEPARATED_MATCHER));

	@Getter
	private final Pattern pattern;
}

package com.rolerandomizer;

import com.google.common.collect.ImmutableSet;
import java.util.HashSet;
import java.util.Set;
import lombok.Getter;
import lombok.RequiredArgsConstructor;

/**
 * Not to be confused with the regular BA role, this describes a more specific team role in the context of
 * the BA metagame. Currently, it distinguishes between main and second attacker roles in funs.
 *
 * @see com.rolerandomizer.BaRole
 */
@RequiredArgsConstructor
public enum MetaRoleInfo
{
	MAIN_ATTACKER("Main attacker", "m", BaRole.ATTACKER, ImmutableSet.of("m", "(?<!2)a")),
	SECOND_ATTACKER("2nd attacker", "2", BaRole.ATTACKER, ImmutableSet.of("2", "2a", "a")),
	HEALER("Healer", "h", BaRole.HEALER, ImmutableSet.of("h")),
	COLLECTOR("Collector", "c", BaRole.COLLECTOR, ImmutableSet.of("c")),
	DEFENDER("Defender", "d", BaRole.DEFENDER, ImmutableSet.of("d"));

	// one or more of any of the possible matches, separated by slashes
	public static final String SLASH_SEPARATED_MATCHER;

	static
	{
		Set<String> all = new HashSet<>();
		all.addAll(MAIN_ATTACKER.matches);
		all.addAll(SECOND_ATTACKER.matches);
		all.addAll(HEALER.matches);
		all.addAll(COLLECTOR.matches);
		all.addAll(DEFENDER.matches);
		String ors = "[" + String.join("|", all) + "]";
		SLASH_SEPARATED_MATCHER = ors + "(?:/" + ors + ")*";
	}

	@Getter
	private final String fullName;
	@Getter
	private final String shortName;
	@Getter
	private final BaRole role;
	@Getter
	private final Set<String> matches;

}

package com.rolerandomizer;

import java.util.List;
import lombok.Value;

@Value
public class PlayerPrefs
{
	String name;
	List<MetaRoleInfo> prefs;
}

package com.rolerandomizer;

import com.rolerandomizer.exceptions.CannotDetermineRolesException;
import com.rolerandomizer.exceptions.CannotParseArgException;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Comparator;
import java.util.HashSet;
import java.util.List;
import java.util.Set;
import java.util.regex.Pattern;
import java.util.stream.Collectors;

public class RoleParser
{
	private static final List<MetaRoleInfo> ALL_ROLES = Arrays.asList(MetaRoleInfo.values().clone());

	private final Set<Set<PlayerPrefs>> validPrefSets = new HashSet<>();
	private final List<String> args = new ArrayList<>();
	private final List<Set<InputCandidate>> argCandidates = new ArrayList<>();

	/**
	 * Assumptions:
	 * - rando is requested for 5 players
	 * - player names contain no spaces
	 * - no specified role means any role (fill)
	 * - correct role formats include:
	 * -- any combination of "m2ahcd" chars, concatenated without repeats, e.g., "2cd" good, "cadah" bad
	 * -- any slash-separated combination of the above, also without repeats, e.g., "2/c/d" good, "ahc/d" bad
	 * -- the exact string "fill", no more and no less
	 *
	 * @param inputs list of string input from the command (split by whitespace)
	 * @return list of PlayerPrefs, in lexicographical order by player name
	 */
	public List<PlayerPrefs> parse(List<String> inputs) throws CannotParseArgException, CannotDetermineRolesException
	{
		validPrefSets.clear();
		argCandidates.clear();
		args.clear();
		args.addAll(inputs);
		determineCandidates();
		determinePrefs();
		// out of all valid results, result with shortest char count in player names is likely most sensible
		Set<PlayerPrefs> bestResult = validPrefSets.stream()
			.min(Comparator.comparingInt(set -> set.stream().mapToInt(prefs -> prefs.getName().length()).sum()))
			.orElseThrow(CannotDetermineRolesException::new);
		return bestResult.stream()
			.sorted(Comparator.comparing(PlayerPrefs::getName))
			.collect(Collectors.toList());
	}

	private void determineCandidates() throws CannotParseArgException
	{
		// First determine whether each word could be NAME, ROLE, or both
		for (String input : args)
		{
			Set<InputCandidate> candidates = new HashSet<>();
			for (InputCandidate ic : InputCandidate.values())
			{
				boolean match = ic.getPattern().matcher(input).matches();
				switch (ic)
				{
					case NAME:
						break;
					case ROLE:
						if (!input.equals("fill"))
						{
							// Also make sure that the roles have no dupes
							Set<Character> charSet = input.chars()
								.mapToObj(e -> (char) e)
								.filter(e -> e != '/')
								.collect(Collectors.toSet());
							String noSlashInput = input.replace("/", "");
							match &= charSet.size() == noSlashInput.length();
						}
						break;
				}
				if (match)
				{
					candidates.add(ic);
				}
			}
			if (candidates.isEmpty())
			{
				throw new CannotParseArgException(input);
			}
			argCandidates.add(candidates);
		}
	}

	private void determinePrefs()
	{
		recurse(argCandidates.size() - 1, new ArrayList<>());
	}

	// i = current index of args, pending = running list of sub-divisions
	private void recurse(int i, List<PlayerPrefs> pending)
	{
		// base cases: reached beginning of input, or have more than 5 players
		if (i == -1)
		{
			if (isValid(pending))
			{
				validPrefSets.add(new HashSet<>(pending));
			}
			return;
		}
		else if (isInvalid(pending))
		{
			return;
		}
		String word = args.get(i);
		Set<InputCandidate> cands = argCandidates.get(i);
		PlayerPrefs lastPrefs = null;
		if (!pending.isEmpty())
		{
			lastPrefs = pending.get(pending.size() - 1);
		}
		if (cands.contains(InputCandidate.ROLE))
		{
			// can't have roles b2b, and can't start args with role
			if ((lastPrefs == null || !lastPrefs.getName().isEmpty()) && i > 0)
			{
				List<PlayerPrefs> newPrefs = new ArrayList<>(pending);
				newPrefs.add(new PlayerPrefs("", prefsFrom(word)));
				recurse(i - 1, newPrefs);
			}
		}
		if (cands.contains(InputCandidate.NAME))
		{
			// start a new name if we have no results yet, or the last thing we found was a name
			if (lastPrefs == null || !lastPrefs.getName().isEmpty())
			{
				List<PlayerPrefs> newPrefs = new ArrayList<>(pending);
				newPrefs.add(new PlayerPrefs(word, ALL_ROLES));
				recurse(i - 1, newPrefs);
			}
			// if we have a role but not a name, pair that name with that role
			if (lastPrefs != null && lastPrefs.getName().isEmpty())
			{
				List<PlayerPrefs> newPrefs = new ArrayList<>(pending);
				newPrefs.remove(newPrefs.size() - 1);
				newPrefs.add(new PlayerPrefs(word, lastPrefs.getPrefs()));
				recurse(i - 1, newPrefs);
			}
		}
	}

	private List<MetaRoleInfo> prefsFrom(String roleStr)
	{
		if (roleStr.equals("fill"))
		{
			return ALL_ROLES;
		}
		return Arrays.stream(MetaRoleInfo.values())
			.filter(info -> info.getMatches().stream()
				.anyMatch(s -> Pattern.compile(s).matcher(roleStr).find()))
			.collect(Collectors.toList());
	}

	// prefs are explicitly valid if there are five of them with non-empty, non-repeated names
	// note: it's possible for a pending list to be neither valid nor invalid (not enough info)
	private boolean isValid(List<PlayerPrefs> pending)
	{
		if (pending.size() != 5)
		{
			return false;
		}
		Set<String> names = new HashSet<>();
		for (PlayerPrefs pref : pending)
		{
			String name = pref.getName();
			if (name.isEmpty() || names.contains(name) || name.length() > 12)
			{
				return false;
			}
			names.add(name);
		}
		return true;
	}

	// parsing is explicitly invalid if any of the following are true:
	// >5 players, duplicate player names, multiple empty names, a player with a name longer than 12 chars
	// note: one empty name is ok since it might not have been parsed yet
	private boolean isInvalid(List<PlayerPrefs> pending)
	{
		if (pending.size() > 5)
		{
			return true;
		}
		Set<String> names = new HashSet<>();
		boolean hasEmptyNames = false;
		for (PlayerPrefs pref : pending)
		{
			String name = pref.getName();
			if (name.isEmpty())
			{
				if (hasEmptyNames)
				{
					return true;
				}
				hasEmptyNames = true;
			}
			if (names.contains(name) || name.length() > 12)
			{
				return true;
			}
			names.add(name);
		}
		return false;
	}
}


/*
 * Copyright (c) 2021-2022, Keano Porcaro <keano@ransty.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.rolerandomizer;

import java.util.HashMap;
import java.util.ArrayList;
import java.lang.Math;
import com.rolerandomizer.exceptions.NoPermutationException;

public class RoleRandomizer
{

    public HashMap<Integer, String> usernames;

    public int[] playerOnePreferences;
    public int[] playerTwoPreferences;
    public int[] playerThreePreferences;
    public int[] playerFourPreferences;
    public int[] playerFivePreferences;

    public RoleRandomizer()
    {
        usernames = new HashMap<Integer, String>();
    }

    public ArrayList generatePermutations() throws NoPermutationException
    {
        ArrayList<int[]> permutations = new ArrayList<>();
        for (int i = 0; i < 5; i++)
        {
            if (playerOnePreferences[i] != 1)
            {
                continue;
            }
            
            for (int j = 0; j < 5; j++)
            {
                if (j == i || playerTwoPreferences[j] != 1)
                {
                    continue;
                }
                
                for (int k = 0; k < 5; k++)
                {
                    if (k == i || k == j || playerThreePreferences[k] != 1)
                    {
                        continue;
                    }

                    for (int l = 0; l < 5; l++)
                    {
                        if (l == i || l == j || l == k || playerFourPreferences[l] != 1)
                        {
                            continue;
                        }

                        for (int m = 0; m < 5; m++)
                        {
                            if (m == i || m == j || m == k || m == l || playerFivePreferences[m] != 1)
                            {
                                continue;
                            }

                            int[] tempPermutation = {i, j, k, l, m};
                            permutations.add(tempPermutation);
                        }
                    }
                }
            }
        }
        return permutations;
    }

    public String[] randomize() throws NoPermutationException
    {
        if (isPreferencesSet())
        {
            ArrayList<int[]> perms = generatePermutations();
            if (perms.size() > 0)
            {
                int chosenIndex = (int) Math.floor(Math.random() * perms.size());
                return buildRolesString(perms.get(chosenIndex));
            }
            else
            {
                throw new NoPermutationException("No permutations to choose from");
            }
        }
        return null;
    }

    public boolean isPreferencesSet()
    {
        if (playerOnePreferences != null && playerOnePreferences.length > 0)
        {
            if (playerTwoPreferences != null && playerTwoPreferences.length > 0)
            {
                if (playerThreePreferences != null && playerThreePreferences.length > 0)
                {
                    if (playerFourPreferences != null && playerFourPreferences.length > 0)
                    {
                        if (playerFivePreferences != null && playerFivePreferences.length > 0)
                        {
                            return true;
                        }
                    }
                }
            }
        }
        return false;
    }

    public void setUsernames(HashMap<Integer, String> usernames)
    {
        this.usernames = usernames;
    }

    public void setPlayerOnePreferences(int[] prefs)
    {
        playerOnePreferences = prefs;
    }

    public void setPlayerTwoPreferences(int[] prefs)
    {
        playerTwoPreferences = prefs;
    }

    public void setPlayerThreePreferences(int[] prefs)
    {
        playerThreePreferences = prefs;
    }

    public void setPlayerFourPreferences(int[] prefs)
    {
        playerFourPreferences = prefs;
    }

    public void setPlayerFivePreferences(int[] prefs)
    {
        playerFivePreferences = prefs;
    }

    private String[] buildRolesString(int[] ints) throws NoPermutationException
    {
        String[] roles = new String[5];
        for (int i = 0; i < ints.length; i++)
        {
            roles[ints[i]] = usernames.get(i);
        }
        return roles;
    }

    public void popPreference(Integer key, int role) {
        if (key == 0) {
            playerOnePreferences[role] = 0;
        } else if (key == 1) {
            playerTwoPreferences[role] = 0;
        } else if (key == 2) {
            playerThreePreferences[role] = 0;
        } else if (key == 3) {
            playerFourPreferences[role] = 0;
        } else if (key == 4) {
            playerFivePreferences[role] = 0;
        }
    }
}


/*
 * Copyright (c) 2021, Keano Porcaro <keano@ransty.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.rolerandomizer;

import net.runelite.client.config.Config;
import net.runelite.client.config.ConfigGroup;
import net.runelite.client.config.ConfigItem;

@ConfigGroup("BA Role Randomizer")
public interface RoleRandomizerConfig extends Config
{
    @ConfigItem(
            keyName = "randomizeResultChatbox",
            name = "Print result to in-game chatbox",
            description = "Sends the result of the random from the UI to the in-game chatbox"
    )
    default boolean sendToChatBox()
    {
        return false;
    }

    @ConfigItem(
            keyName = "addToRando",
            name = "Add to rando",
            description = "Add option on chat messages to add to rando",
            position = 2
    )
    default boolean addToRando()
    {
        return false;
    }



}

/*
 * Copyright (c) 2021, Keano Porcaro <keano@ransty.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.rolerandomizer;

import com.google.common.collect.ImmutableList;
import com.google.inject.Provides;

import java.awt.*;
import java.awt.image.BufferedImage;
import java.util.*;
import java.util.List;
import javax.inject.Inject;

import com.rolerandomizer.ui.RoleRandomizerPluginPanel;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.*;
import net.runelite.api.events.CommandExecuted;
import net.runelite.api.events.MenuEntryAdded;
import net.runelite.api.widgets.Widget;
import net.runelite.api.widgets.WidgetInfo;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.api.events.MenuOpened;
import net.runelite.client.config.ConfigManager;
import static net.runelite.api.widgets.WidgetInfo.TO_CHILD;
import static net.runelite.api.widgets.WidgetInfo.TO_GROUP;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.plugins.PluginDescriptor;
import net.runelite.client.ui.NavigationButton;
import net.runelite.client.util.ColorUtil;
import net.runelite.client.util.ImageUtil;
import net.runelite.client.ui.ClientToolbar;
import net.runelite.client.util.Text;

@Slf4j
@PluginDescriptor(
	name = "BA Role Randomizer"
)
public class RoleRandomizerPlugin extends Plugin
{
	@Inject
	private Client client;

	@Inject
	private RoleRandomizerConfig config;

	@Inject
	private ChatMessageManager chatMessageManager;

	private final RoleParser parser = new RoleParser();

	private RoleRandomizer randomizer;

	private static final String ADD_TO_RANDOMIZER = "Add to BA Role Randomizer";
	private static final String KICK_OPTION = "Kick";
	private static final ImmutableList<String> BEFORE_OPTIONS = ImmutableList.of("Add friend", "Remove friend", KICK_OPTION);
	private static final ImmutableList<String> AFTER_OPTIONS = ImmutableList.of("Message");

	private String currentMessage = null;

	private RoleRandomizerPluginPanel panel;

	private String[] player1Prefs;
	private String[] player2Prefs;
	private String[] player3Prefs;
	private String[] player4Prefs;
	private String[] player5Prefs;
	private HashMap<Integer, String> usernames;

	private NavigationButton navButton;

	@Inject
	private ClientToolbar clientToolbar;

	private String teamRoles;

	@Override
	protected void startUp() {
		randomizer = new RoleRandomizer();
		usernames = new HashMap<>();

		panel = new RoleRandomizerPluginPanel(client, config, chatMessageManager);

		BufferedImage icon = ImageUtil.loadImageResource(RoleRandomizerPlugin.class, "icon.png");
		navButton = NavigationButton.builder()
				.tooltip("BA Role Randomizer")
				.priority(9)
				.icon(icon)
				.panel(panel)
				.build();
		clientToolbar.addNavigation(navButton);

	}

	@Override
	protected void shutDown() {
		usernames = null;
		randomizer = null;
		currentMessage = null;

		clientToolbar.removeNavigation(navButton);

		log.debug("Shutting down BA role randomizer plugin");
	}

	@Subscribe
	public void onMenuOpened(MenuOpened event)
	{
		if (event.getMenuEntries().length < 2 || !config.addToRando())
		{
			return;
		}

		final MenuEntry entry = event.getMenuEntries()[event.getMenuEntries().length - 2];

		if (entry.getType() != MenuAction.CC_OP_LOW_PRIORITY && entry.getType() != MenuAction.RUNELITE)
		{
			return;
		}

		final int groupId = TO_GROUP(entry.getParam1());
		final int childId = TO_CHILD(entry.getParam1());

		if (groupId != WidgetInfo.CHATBOX.getGroupId())
		{
			return;
		}

		final Widget widget = client.getWidget(groupId, childId);
		final Widget parent = widget.getParent();

		if (WidgetInfo.CHATBOX_MESSAGE_LINES.getId() != parent.getId())
		{
			return;
		}

		final int first = WidgetInfo.CHATBOX_FIRST_MESSAGE.getChildId();

		final int dynamicChildId = (childId - first) * 4;

		final Widget messageContents = parent.getChild(dynamicChildId);
		if (messageContents == null)
		{
			return;
		}

		String playerName = messageContents.getText();

		client.createMenuEntry(1)
				.setOption(ADD_TO_RANDOMIZER)
				.setTarget(entry.getTarget())
				.setType(MenuAction.RUNELITE)
				.onClick(e ->
				{
					panel.addPlayer(Text.removeTags(Text.toJagexName(playerName)));
				});
	}

	@Subscribe
	public void onMenuEntryAdded(MenuEntryAdded event)
	{
	        if (!config.addToRando())
		{
			return;
		}

		final int componentId = event.getActionParam1();
		int groupId = WidgetInfo.TO_GROUP(componentId);
		String option = event.getOption();

		if (groupId == WidgetInfo.FRIENDS_LIST.getGroupId() || groupId == WidgetInfo.FRIENDS_CHAT.getGroupId()
				|| componentId == WidgetInfo.CLAN_MEMBER_LIST.getId() || componentId == WidgetInfo.CLAN_GUEST_MEMBER_LIST.getId())
		{
			boolean after;

			if (AFTER_OPTIONS.contains(option))
			{
				after = true;
			}
			else if (BEFORE_OPTIONS.contains(option))
			{
				after = false;
			}
			else
			{
				return;
			}

			client.createMenuEntry(after ? -2 : -1)
					.setOption(ADD_TO_RANDOMIZER)
					.setTarget(event.getTarget())
					.setType(MenuAction.RUNELITE)
					.onClick(e ->
					{
						panel.addPlayer(Text.removeTags(Text.toJagexName(event.getTarget())));
					});
		}
	}

	public String buildPrefsPrint()
	{
		String prefs = "";
		prefs += nounCapitalize(usernames.get(0)) + " " + stripArrayExtras(player1Prefs) + "  ";
		prefs += nounCapitalize(usernames.get(1)) + " " + stripArrayExtras(player2Prefs) + "  ";
		prefs += nounCapitalize(usernames.get(2)) + " " + stripArrayExtras(player3Prefs) + "  ";
		prefs += nounCapitalize(usernames.get(3)) + " " + stripArrayExtras(player4Prefs) + "  ";
		prefs += nounCapitalize(usernames.get(4)) + " " + stripArrayExtras(player5Prefs) + "  ";
		return prefs;
	}

	public String stripArrayExtras(String[] array)
	{
		return String.join("", array)
			.replace("m2hcd", "fill")
			.replace("m2", "a");
	}

	@Subscribe
	public void onCommandExecuted(CommandExecuted commandExecuted) throws Exception
	{
		if (commandExecuted.getCommand().equals("prefs") && randomizer.isPreferencesSet())
		{
			client.addChatMessage(
				ChatMessageType.GAMEMESSAGE,
				"",
				buildPrefsPrint(),
				null
			);
		}

		if (commandExecuted.getCommand().equals("r"))
		{
			// first determine which player prefers which role
			List<PlayerPrefs> prefs = parser.parse(Arrays.asList(commandExecuted.getArguments()));
			if (prefs.size() == 5)
			{
				setUsernames(prefs);
				if (!randomizer.isPreferencesSet()) {
					collectPreferences(prefs);
					setAllPreferences(prefs);
				}
				teamRoles = generateRandom();
				client.addChatMessage(
					ChatMessageType.GAMEMESSAGE,
					"",
					teamRoles,
					null
				);
			}
		}

		if (commandExecuted.getCommand().equals("prevr") && !teamRoles.isEmpty())
		{
			client.addChatMessage(
				ChatMessageType.GAMEMESSAGE,
				"",
				teamRoles,
				null
			);
		}

		if (commandExecuted.getCommand().equals("rr") && !teamRoles.isEmpty())
		{
			teamRoles = generateRandom();
			client.addChatMessage(
				ChatMessageType.GAMEMESSAGE,
				"",
				teamRoles,
				null
			);
		}
	}

	private void setUsernames(List<PlayerPrefs> prefs)
	{
		for (int i = 0; i < prefs.size(); i++)
		{
			usernames.put(i, prefs.get(i).getName());
		}
		randomizer.setUsernames(usernames);
	}

	private void collectPreferences(List<PlayerPrefs> prefs)
	{
		player1Prefs = prefs.get(0).getPrefs().stream().map(MetaRoleInfo::getShortName).toArray(String[]::new);
		player2Prefs = prefs.get(1).getPrefs().stream().map(MetaRoleInfo::getShortName).toArray(String[]::new);
		player3Prefs = prefs.get(2).getPrefs().stream().map(MetaRoleInfo::getShortName).toArray(String[]::new);
		player4Prefs = prefs.get(3).getPrefs().stream().map(MetaRoleInfo::getShortName).toArray(String[]::new);
		player5Prefs = prefs.get(4).getPrefs().stream().map(MetaRoleInfo::getShortName).toArray(String[]::new);
	}

	private void setAllPreferences(List<PlayerPrefs> prefs)
	{
		randomizer.setPlayerOnePreferences(convertPreferences(prefs.get(0).getPrefs()));
		randomizer.setPlayerTwoPreferences(convertPreferences(prefs.get(1).getPrefs()));
		randomizer.setPlayerThreePreferences(convertPreferences(prefs.get(2).getPrefs()));
		randomizer.setPlayerFourPreferences(convertPreferences(prefs.get(3).getPrefs()));
		randomizer.setPlayerFivePreferences(convertPreferences(prefs.get(4).getPrefs()));
	}

	private String generateRandom() throws Exception
	{
		String[] roles = randomizer.randomize();
		StringBuilder shortFormRoles = new StringBuilder();
		for (int index = 0; index < 5; index++)
		{
			switch (index)
			{
				case 0:
				case 1:
					shortFormRoles.append(ColorUtil.wrapWithColorTag(
						nounCapitalize(roles[index]),
						Color.RED.darker())).append(" / "
					);
					for (Map.Entry<Integer, String> entry: randomizer.usernames.entrySet()) {
						if (Objects.equals(entry.getValue(), roles[index])) {
							randomizer.popPreference(entry.getKey(), index);
						}
					}
					break;
				case 2:
					shortFormRoles.append(ColorUtil.wrapWithColorTag(
						nounCapitalize(roles[index]),
						Color.GREEN.darker().darker())).append(" / "
					);
					for (Map.Entry<Integer, String> entry: randomizer.usernames.entrySet()) {
						if (Objects.equals(entry.getValue(), roles[index])) {
							randomizer.popPreference(entry.getKey(), index);
						}
					}
					break;
				case 3:
					shortFormRoles.append(ColorUtil.wrapWithColorTag(
						nounCapitalize(roles[index]),
						Color.YELLOW)).append(" / "
					);
					for (Map.Entry<Integer, String> entry: randomizer.usernames.entrySet()) {
						if (Objects.equals(entry.getValue(), roles[index])) {
							randomizer.popPreference(entry.getKey(), index);
						}
					}
					break;
				case 4:
					shortFormRoles.append(ColorUtil.wrapWithColorTag(
						nounCapitalize(roles[index]),
						Color.BLUE.darker())
					);
					for (Map.Entry<Integer, String> entry: randomizer.usernames.entrySet()) {
						if (Objects.equals(entry.getValue(), roles[index])) {
							randomizer.popPreference(entry.getKey(), index);
						}
					}
					break;
			}
		}
		return shortFormRoles.toString();
	}

	private String nounCapitalize(String noun)
	{
		return noun.substring(0, 1).toUpperCase() + noun.substring(1);
	}

	public int[] convertPreferences(List<MetaRoleInfo> prefs)
	{
		int[] result = {0, 0, 0, 0, 0};
		for (MetaRoleInfo pref : prefs)
		{
			result[pref.ordinal()] = 1;
		}
		return result;
	}

	@Provides
	RoleRandomizerConfig provideConfig(ConfigManager configManager)
	{
		return configManager.getConfig(RoleRandomizerConfig.class);
	}
}

package com.rolerandomizer.ui;

import net.runelite.client.util.ImageUtil;
import net.runelite.client.util.SwingUtil;

import javax.swing.*;
import javax.swing.border.EmptyBorder;
import java.awt.*;
import java.awt.image.BufferedImage;

public class OptionsPanel extends JPanel {

    private final RoleRandomizerPluginPanel panel;
    private final RoleRandomizerPanel main;
    private static final ImageIcon ON_SWITCH;
    private static final ImageIcon OFF_SWITCH;

    static
    {
        BufferedImage onSwitch = ImageUtil.loadImageResource(OptionsPanel.class, "green_egg.png");
        onSwitch = ImageUtil.resizeImage(onSwitch, 15, 20);
        BufferedImage offSwitch = ImageUtil.loadImageResource(OptionsPanel.class, "red_egg.png");
        offSwitch = ImageUtil.resizeImage(offSwitch, 15, 20);
        ON_SWITCH = new ImageIcon(onSwitch);
        OFF_SWITCH = new ImageIcon(offSwitch);
    }

    private void updateKeepRoleConfig(JToggleButton button)
    {
        button.setToolTipText(button.isSelected() ? "Disable" : "Enable");
        if (button.isSelected()) {
            main.keepPreviousRolesSelected = true;
        } else {
            main.keepPreviousRolesSelected = false;
        }
    }

    protected OptionsPanel(RoleRandomizerPluginPanel panel, RoleRandomizerPanel main)
    {
        super();

        this.panel = panel;
        this.main = main;
        setLayout(new BorderLayout());

        final JPanel container = new JPanel();
        container.setLayout(new BorderLayout());
        container.setBorder(new EmptyBorder(0, 5, 5, 5));

        JToggleButton button = new JToggleButton(OFF_SWITCH);
        button.setSelectedIcon(ON_SWITCH);
        button.setPreferredSize(new Dimension(25, 50));
        SwingUtil.removeButtonDecorations(button);
        button.addItemListener(l -> updateKeepRoleConfig(button));

        JLabel optionLabel = new JLabel("Keep previous roles selected");
        optionLabel.setBorder(new EmptyBorder(0, 0, 0, 20));
        container.add(optionLabel, BorderLayout.WEST);
        container.add(button, BorderLayout.EAST);

        add(container, BorderLayout.SOUTH);
    }
}

/*
 * Copyright (c) 2021-2022, Keano Porcaro <keano@ransty.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.rolerandomizer.ui;

import net.runelite.client.ui.FontManager;

import javax.swing.*;
import java.awt.*;

public class RandomizeResultPanel extends JPanel
{
    private final RoleRandomizerPluginPanel panel;

    public JTextArea roleRandomizerResultField;

    protected RandomizeResultPanel(RoleRandomizerPluginPanel panel)
    {
        super();

        this.panel = panel;

        setLayout(new BorderLayout());

        addResultTextComponent();

    }

    private void addResultTextComponent() {
        final JPanel container = new JPanel();
        container.setLayout(new BorderLayout());

        roleRandomizerResultField = new JTextArea(7, 0);

        roleRandomizerResultField.setEnabled(false);
        roleRandomizerResultField.setPreferredSize(new Dimension(100, this.panel.getHeight()));
        roleRandomizerResultField.setFont(FontManager.getRunescapeSmallFont());

        container.add(roleRandomizerResultField);

        add(container, BorderLayout.NORTH);
    }

    public void cleanSlate() {
        roleRandomizerResultField.setText("");
    }
}

package com.rolerandomizer.ui;

import java.awt.*;
import java.awt.event.*;
import java.util.HashMap;
import java.util.Map;
import java.util.Objects;
import javax.swing.*;
import javax.swing.border.EmptyBorder;
import com.rolerandomizer.RoleRandomizerConfig;
import com.rolerandomizer.exceptions.NoPermutationException;
import net.runelite.api.ChatMessageType;
import net.runelite.api.Client;
import net.runelite.api.GameState;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.chat.QueuedMessage;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.FontManager;
import net.runelite.client.ui.components.FlatTextField;
import lombok.extern.slf4j.Slf4j;

import com.rolerandomizer.RoleRandomizer;
import net.runelite.client.util.ColorUtil;

@Slf4j
public class RoleRandomizerPanel extends JPanel implements ActionListener {

    private final RoleRandomizerPluginPanel panel;

    public JTextField uiFieldPlayer1;
    public JCheckBox[] uiFieldPlayer1Preferences;
    public JTextField uiFieldPlayer2;
    public JCheckBox[] uiFieldPlayer2Preferences;
    public JTextField uiFieldPlayer3;
    public JCheckBox[] uiFieldPlayer3Preferences;
    public JTextField uiFieldPlayer4;
    public JCheckBox[] uiFieldPlayer4Preferences;
    public JTextField uiFieldPlayer5;
    public JCheckBox[] uiFieldPlayer5Preferences;

    public boolean[] initialPlayer1Preferences;
    public boolean isInitialPlayer1PreferencesSet;
    public boolean[] initialPlayer2Preferences;
    public boolean isInitialPlayer2PreferencesSet;
    public boolean[] initialPlayer3Preferences;
    public boolean isInitialPlayer3PreferencesSet;
    public boolean[] initialPlayer4Preferences;
    public boolean isInitialPlayer4PreferencesSet;
    public boolean[] initialPlayer5Preferences;
    public boolean isInitialPlayer5PreferencesSet;
    public boolean keepPreviousRolesSelected;

    private String[] previousRandom;

    private RoleRandomizer rr;

    private Client client;
    private RoleRandomizerConfig config;
    private final ChatMessageManager chatMessageManager;

    private JButton roleRandomizerButton;
    private JButton resetButton;

        protected RoleRandomizerPanel(Client client, RoleRandomizerConfig config, ChatMessageManager chatMessageManager, RoleRandomizerPluginPanel panel) {
            super();

            this.panel = panel;
            this.client = client;
            this.config = config;
            this.chatMessageManager = chatMessageManager;
            this.keepPreviousRolesSelected = false;

            setLayout(new GridLayout(6, 2, 5, 5));

            initializeComponents();
        }

        private void addFillListener(JCheckBox[] pPreferences) {
            pPreferences[5].addActionListener(e -> flipCheckboxes(pPreferences, pPreferences[5]));
        }

        public void addAllPreferences(JCheckBox[] pPreferences) {
            for (JCheckBox box : pPreferences) {
                box.setSelected(true);
            }
        }

        private void addCheckFillListener(JCheckBox[] playerPreferences) {
            for (int i = 0; i < playerPreferences.length - 1; i++) {
                playerPreferences[i].addActionListener(e -> {
                    if (playerPreferences[5].isSelected()) {
                        playerPreferences[5].setSelected(false);
                    } else {
                        int isFill = 0;
                        for (int box = 0; box < playerPreferences.length - 1; box++) {
                            if (!playerPreferences[box].isSelected()) {
                                break;
                            } else {
                                isFill++;
                            }
                        }

                        if (isFill == 5) {
                            playerPreferences[5].setSelected(true);
                        }
                    }
                });
            }
        }

        public void flipCheckboxes(JCheckBox[] checkboxes, JCheckBox fillBox) {
            if (fillBox.isSelected()) {
                for (int i = 0; i < checkboxes.length - 1; i++) {
                    checkboxes[i].setSelected(true);
                }
            } else {
                for (int i = 0; i < checkboxes.length - 1; i++) {
                    checkboxes[i].setSelected(false);
                }
            }

        }

        private JCheckBox[] generatePlayerPreferences(JTextField textField, boolean[] initialPreferences, int playerNumber) {
            final JCheckBox[] preferences = new JCheckBox[6];
            final JPanel container = new JPanel();
            container.setLayout(new GridLayout(2,6,0,0));

            container.add(generateRadioLabel("M"));
            container.add(generateRadioLabel("2"));
            container.add(generateRadioLabel("H"));
            container.add(generateRadioLabel("C"));
            container.add(generateRadioLabel("D"));
            container.add(generateRadioLabel("F"));

            JButton destroy = new JButton("x");
            destroy.setOpaque(false);
            destroy.setContentAreaFilled(false);
            destroy.setBorderPainted(false);
            destroy.setFocusable(false);
            destroy.setForeground(ColorScheme.PROGRESS_ERROR_COLOR);
            destroy.setBorder(null);
            destroy.addActionListener(e -> {
                clearPlayerPreferences(preferences, initialPreferences, playerNumber);
                textField.setText("");
            });
            container.add(destroy);

            for (int i = 0; i < preferences.length; i++) {
                preferences[i] = generateRadioComponent();
                container.add(preferences[i]);
            }

            add(container);
            return preferences;
        }

        private JCheckBox generateRadioComponent() {
            final JCheckBox checkbox = new JCheckBox();

            checkbox.setBackground(ColorScheme.DARKER_GRAY_COLOR);
            checkbox.setBorder(new EmptyBorder(0,0,0,0));
            checkbox.setFocusPainted(false);
            checkbox.setFocusable(false);

            return checkbox;
        }

        private JLabel generateRadioLabel(String role) {
            final JLabel label = new JLabel(role);

            label.setFont(FontManager.getRunescapeSmallFont());
            label.setBorder(new EmptyBorder(0, 5,0,0));
            label.setForeground(Color.WHITE);
            label.setFocusable(false);
            switch (role) {
                case "M":
                    label.setToolTipText("Main attacker");
                    break;
                case "2":
                    label.setToolTipText("Second attacker");
                    break;
                case "H":
                    label.setToolTipText("Healer");
                    break;
                case "C":
                    label.setToolTipText("Collector");
                    break;
                case "D":
                    label.setToolTipText("Defender");
                    break;
                case "F":
                    label.setToolTipText("Fill");
                    break;
            }

            return label;
        }

        private void clearPlayerPreferences(JCheckBox[] prefs, boolean[] initialPreferences, int playerNumber) {
            for (JCheckBox box : prefs) {
                box.setSelected(false);
            }

            for (int i = 0; i < initialPreferences.length; i++) {
                initialPreferences[i] = false;
            }

            switch(playerNumber) {
                case 1:
                    isInitialPlayer1PreferencesSet = false;
                    break;
                case 2:
                    isInitialPlayer2PreferencesSet = false;
                    break;
                case 3:
                    isInitialPlayer3PreferencesSet = false;
                    break;
                case 4:
                    isInitialPlayer4PreferencesSet = false;
                    break;
                case 5:
                    isInitialPlayer5PreferencesSet = false;
                    break;
            }
        }

    private JTextField addComponent(String label) {
        final JPanel container = new JPanel();
        container.setLayout(new BorderLayout());

        final JLabel uiLabel = new JLabel(label);
        final FlatTextField uiInput = new FlatTextField();

        uiInput.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        uiInput.setHoverBackgroundColor(ColorScheme.DARK_GRAY_HOVER_COLOR);
        uiInput.setBorder(new EmptyBorder(5, 7, 5, 7));

        uiLabel.setFont(FontManager.getRunescapeSmallFont());
        uiLabel.setBorder(new EmptyBorder(0, 0, 4, 0));
        uiLabel.setForeground(Color.WHITE);

        container.add(uiLabel, BorderLayout.NORTH);
        container.add(uiInput, BorderLayout.CENTER);

        add(container);

        return uiInput.getTextField();
    }

    private JButton addResetButtonComponent(String label) {
        final JPanel container = new JPanel();
        container.setLayout(new BorderLayout());

        JButton resetButton = new JButton(label);

        resetButton.setBackground(ColorScheme.DARK_GRAY_COLOR);
        resetButton.setBorder(new EmptyBorder(5, 7, 5, 7));
        resetButton.setToolTipText("This resets preferences!");
        resetButton.setEnabled(false);

        resetButton.addKeyListener(new KeyListener() {
            @Override
            public void keyTyped(KeyEvent e) {
                if (e.getKeyCode() == KeyEvent.VK_ENTER) {
                    resetPreferences();
                }
            }

            @Override
            public void keyPressed(KeyEvent e) {
                if (e.getKeyCode() == KeyEvent.VK_ENTER) {
                    resetPreferences();
                }
            }

            @Override
            public void keyReleased(KeyEvent e) {
                if (e.getKeyCode() == KeyEvent.VK_ENTER) {
                    resetPreferences();
                }
            }
        });

        resetButton.addActionListener(e -> resetPreferences());

        container.add(resetButton, BorderLayout.CENTER);
        add(container, BorderLayout.NORTH);

        return resetButton;
    }

    private void resetPlayerPreferences(JCheckBox[] prefs, boolean[] initial) {
            for (int i = 0; i < prefs.length; i++) {
                prefs[i].setSelected(initial[i]);
            }
    }

    private void resetPreferences() {
        panel.resultPanel.roleRandomizerResultField.setText("");
        panel.resultPanel.roleRandomizerResultField.insert("\n", 0);

        resetPlayerPreferences(uiFieldPlayer1Preferences, initialPlayer1Preferences);
        resetPlayerPreferences(uiFieldPlayer2Preferences, initialPlayer2Preferences);
        resetPlayerPreferences(uiFieldPlayer3Preferences, initialPlayer3Preferences);
        resetPlayerPreferences(uiFieldPlayer4Preferences, initialPlayer4Preferences);
        resetPlayerPreferences(uiFieldPlayer5Preferences, initialPlayer5Preferences);

        rr.playerOnePreferences = null;
        rr.playerTwoPreferences = null;
        rr.playerThreePreferences = null;
        rr.playerFourPreferences = null;
        rr.playerFivePreferences = null;

        resetButton.setEnabled(false);

    }

    private void addRandomizeButtonComponent(String label) {
        final JPanel container = new JPanel();
        container.setLayout(new BorderLayout());

        roleRandomizerButton = new JButton(label);

        roleRandomizerButton.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        roleRandomizerButton.setBorder(new EmptyBorder(5, 7, 5, 7));

        roleRandomizerButton.addActionListener(this);
        roleRandomizerButton.addKeyListener(new KeyListener() {
            @Override
            public void keyTyped(KeyEvent e) {

            }

            @Override
            public void keyPressed(KeyEvent e) {
                if (e.getKeyCode() == KeyEvent.VK_ENTER) {
                    randomize();
                }
            }

            @Override
            public void keyReleased(KeyEvent e) {

            }
        });

        container.add(roleRandomizerButton, BorderLayout.CENTER);

        add(container, BorderLayout.SOUTH);
    }

    public void getUsernames() {
        if (!uiFieldPlayer1.getText().isEmpty() &&
                !uiFieldPlayer2.getText().isEmpty() &&
                !uiFieldPlayer3.getText().isEmpty() &&
                !uiFieldPlayer4.getText().isEmpty() &&
                !uiFieldPlayer5.getText().isEmpty()) {

            HashMap<Integer, String> usernames = new HashMap<>();
            usernames.put(0, uiFieldPlayer1.getText());
            usernames.put(1, uiFieldPlayer2.getText());
            usernames.put(2, uiFieldPlayer3.getText());
            usernames.put(3, uiFieldPlayer4.getText());
            usernames.put(4, uiFieldPlayer5.getText());
            rr.setUsernames(usernames);
        }
    }

    private int[] setPreferences(JCheckBox[] prefs) {
        int[] playerPrefs = new int[prefs.length - 1];
        for (int i = 0; i < playerPrefs.length; i++) {
            if (prefs[i].isSelected()) {
                playerPrefs[i] = 1;
            } else {
                playerPrefs[i] = 0;
            }
        }
        return playerPrefs;
    }

    public void setInitialPreferences(JCheckBox[] currentPrefs, boolean[] initPrefs) {
            for (int i = 0; i < initPrefs.length; i++) {
                initPrefs[i] = currentPrefs[i].isSelected();
            }
    }

    public void getPreferences() {
        if (!isInitialPlayer1PreferencesSet) {
            setInitialPreferences(uiFieldPlayer1Preferences, initialPlayer1Preferences);
            isInitialPlayer1PreferencesSet = true;
        }
        rr.setPlayerOnePreferences(setPreferences(uiFieldPlayer1Preferences));

        if (!isInitialPlayer2PreferencesSet) {
            setInitialPreferences(uiFieldPlayer2Preferences, initialPlayer2Preferences);
            isInitialPlayer2PreferencesSet = true;
        }
        rr.setPlayerTwoPreferences(setPreferences(uiFieldPlayer2Preferences));

        if (!isInitialPlayer3PreferencesSet) {
            setInitialPreferences(uiFieldPlayer3Preferences, initialPlayer3Preferences);
            isInitialPlayer3PreferencesSet = true;
        }
        rr.setPlayerThreePreferences(setPreferences(uiFieldPlayer3Preferences));

        if (!isInitialPlayer4PreferencesSet) {
            setInitialPreferences(uiFieldPlayer4Preferences, initialPlayer4Preferences);
            isInitialPlayer4PreferencesSet = true;
        }
        rr.setPlayerFourPreferences(setPreferences(uiFieldPlayer4Preferences));

        if (!isInitialPlayer5PreferencesSet) {
            setInitialPreferences(uiFieldPlayer5Preferences, initialPlayer5Preferences);
            isInitialPlayer5PreferencesSet = true;
        }
        rr.setPlayerFivePreferences(setPreferences(uiFieldPlayer5Preferences));

        resetButton.setEnabled(true);
    }

    public void randomize() {
        panel.resultPanel.roleRandomizerResultField.setText("");
        panel.resultPanel.roleRandomizerResultField.insert("\n", 0);

        getUsernames();

        if (rr.usernames.size() != 5) {
            panel.resultPanel.roleRandomizerResultField.setText(" Set usernames in the above fields.");
            return;
        }

        // Before getting preferences, check at least 1 box is ticked per player
        if (!checkMinimumBoxesTicked()) {
            panel.resultPanel.roleRandomizerResultField.setText(" Minimum amount of roles not set!");
            return;
        }

        getPreferences();

        try {
            String[] roles = rr.randomize();
            this.previousRandom = roles;

            StringBuilder shortFormRoles = new StringBuilder();

            for (int index = 0; index < 5; index++) {
                    switch (index) {
                        case 0:
                            panel.resultPanel.roleRandomizerResultField.insert(" Main\t" + roles[index] + "\n", 1);
                            if (config.sendToChatBox()) {
                                if (client.getGameState().equals(GameState.LOGGED_IN)) {
                                    shortFormRoles.append(ColorUtil.wrapWithColorTag((roles[index]),
                                            Color.RED.darker())).append(" / "
                                    );
                                }
                            }
                            if (!keepPreviousRolesSelected) {
                                removeRolePreferences(roles, index);
                            }
                            break;
                        case 1:
                            panel.resultPanel.roleRandomizerResultField.append(" Second\t" + roles[index] + "\n");
                            if (config.sendToChatBox()) {
                                if (client.getGameState().equals(GameState.LOGGED_IN)) {
                                    shortFormRoles.append(ColorUtil.wrapWithColorTag((roles[index]),
                                            Color.RED.darker())).append(" / "
                                    );
                                }
                            }
                            if (!keepPreviousRolesSelected) {
                                removeRolePreferences(roles, index);
                            }
                            break;
                        case 2:
                            panel.resultPanel.roleRandomizerResultField.append(" Healer\t" + roles[index] + "\n");
                            if (config.sendToChatBox()) {
                                if (client.getGameState().equals(GameState.LOGGED_IN)) {
                                    shortFormRoles.append(ColorUtil.wrapWithColorTag(
                                            (roles[index]),
                                            Color.GREEN.darker().darker())).append(" / "
                                    );
                                }
                            }
                            if (!keepPreviousRolesSelected) {
                                removeRolePreferences(roles, index);
                            }
                            break;
                        case 3:
                            panel.resultPanel.roleRandomizerResultField.append(" Collector\t" + roles[index] + "\n");
                            if (config.sendToChatBox()) {
                                if (client.getGameState().equals(GameState.LOGGED_IN)) {
                                    shortFormRoles.append(ColorUtil.wrapWithColorTag(
                                            (roles[index]),
                                            Color.YELLOW)).append(" / "
                                    );
                                }
                            }
                            if (!keepPreviousRolesSelected) {
                                removeRolePreferences(roles, index);
                            }
                            break;
                        case 4:
                            panel.resultPanel.roleRandomizerResultField.append(" Defender\t" + roles[index]);
                            if (config.sendToChatBox()) {
                                if (client.getGameState().equals(GameState.LOGGED_IN)) {
                                    shortFormRoles.append(ColorUtil.wrapWithColorTag(
                                            (roles[index]),
                                            Color.BLUE.darker())
                                    );
                                }
                            }
                            if (!keepPreviousRolesSelected) {
                                removeRolePreferences(roles, index);
                            }
                            break;
                    }
            }

            if (config.sendToChatBox()) {
                if (client.getGameState().equals(GameState.LOGGED_IN)) {
                    chatMessageManager.queue(
                            QueuedMessage.builder()
                                    .type(ChatMessageType.GAMEMESSAGE)
                                    .runeLiteFormattedMessage(shortFormRoles.toString())
                                    .build()
                    );
                }
            }

        } catch (NoPermutationException ex) {
            // Determine which role is missing
            panel.resultPanel.roleRandomizerResultField.setText(missingRole());
        }
    }

    private String missingRole() {
        StringBuilder result = new StringBuilder();
        int[] p1Count = countRoles(uiFieldPlayer1Preferences);
        int[] p2Count = countRoles(uiFieldPlayer2Preferences);
        int[] p3Count = countRoles(uiFieldPlayer3Preferences);
        int[] p4Count = countRoles(uiFieldPlayer4Preferences);
        int[] p5Count = countRoles(uiFieldPlayer5Preferences);

        int main_attack = p1Count[0] + p2Count[0] + p3Count[0] + p4Count[0] + p5Count[0];
        int second_attack = p1Count[1] + p2Count[1] + p3Count[1] + p4Count[1] + p5Count[1];
        int healer = p1Count[2] + p2Count[2] + p3Count[2] + p4Count[2] + p5Count[2];
        int collector = p1Count[3] + p2Count[3] + p3Count[3] + p4Count[3] + p5Count[3];
        int defender = p1Count[4] + p2Count[4] + p3Count[4] + p4Count[4] + p5Count[4];

        if (main_attack == 0) {
            result.append(" No available Mains");
            result.append(System.getProperty("line.separator"));
        } if (second_attack == 0) {
            result.append(" No available 2nd Attackers");
            result.append(System.getProperty("line.separator"));
        } if (healer == 0) {
            result.append(" No available Healers");
            result.append(System.getProperty("line.separator"));
        } if (collector == 0) {
            result.append(" No available Collectors");
            result.append(System.getProperty("line.separator"));
        } if (defender == 0) {
            result.append(" No available Defenders");
            result.append(System.getProperty("line.separator"));
        }
        log.info(result.toString());
        return result.toString();
    }

    private int[] countRoles(JCheckBox[] rolesSelected) {
        int[] returnCount = new int[5];
        for (int i = 0; i < rolesSelected.length; i++) {
            if (rolesSelected[i].isSelected()) {
                returnCount[i] = 1;
            }
        }
        return returnCount;
    }

    private boolean checkMinimumBoxesTicked() {
        if (minimumRolesSet(uiFieldPlayer1Preferences)) {
            if (minimumRolesSet(uiFieldPlayer2Preferences)) {
                if (minimumRolesSet(uiFieldPlayer3Preferences)) {
                    if (minimumRolesSet(uiFieldPlayer4Preferences)) {
                        if (minimumRolesSet(uiFieldPlayer5Preferences)) {
                            return true;
                        }
                    }
                }
            }
        }
        return false;
    }

    private boolean minimumRolesSet(JCheckBox[] playerPreferences) {
        for (int i = 0; i < playerPreferences.length; i++) {
            if (playerPreferences[i].isSelected()) {
                // This means at least one box has been checked
                return true;
            }
        }
        return false;
    }

    public void removePreviousRoles() {
        for (int index = 0; index < 5; index++) {
            removeRolePreferences(previousRandom, index);
        }
    }
    
    private void removeRolePreferences(String[] roles, int index) {
        for (Map.Entry<Integer, String> entry: rr.usernames.entrySet()) {
            if (Objects.equals(entry.getValue(), roles[index])) {
                rr.popPreference(entry.getKey(), index);
                uncheckPreference(roles[index], index);
            }
        }
    }

    private void uncheckPreference(String username, int role) {
        if (username.equalsIgnoreCase(uiFieldPlayer1.getText())) {
            uiFieldPlayer1Preferences[role].setSelected(false);
            if (uiFieldPlayer1Preferences[5].isSelected()) {
                uiFieldPlayer1Preferences[5].setSelected(false);
            }
        } else if (username.equalsIgnoreCase(uiFieldPlayer2.getText())) {
            uiFieldPlayer2Preferences[role].setSelected(false);
            if (uiFieldPlayer2Preferences[5].isSelected()) {
                uiFieldPlayer2Preferences[5].setSelected(false);
            }
        } else if (username.equalsIgnoreCase(uiFieldPlayer3.getText())) {
            uiFieldPlayer3Preferences[role].setSelected(false);
            if (uiFieldPlayer3Preferences[5].isSelected()) {
                uiFieldPlayer3Preferences[5].setSelected(false);
            }
        } else if (username.equalsIgnoreCase(uiFieldPlayer4.getText())) {
            uiFieldPlayer4Preferences[role].setSelected(false);
            if (uiFieldPlayer4Preferences[5].isSelected()) {
                uiFieldPlayer4Preferences[5].setSelected(false);
            }
        } else if (username.equalsIgnoreCase(uiFieldPlayer5.getText())) {
            uiFieldPlayer5Preferences[role].setSelected(false);
            if (uiFieldPlayer5Preferences[5].isSelected()) {
                uiFieldPlayer5Preferences[5].setSelected(false);
            }
        }
    }

    @Override
    public void actionPerformed(ActionEvent e) {
            randomize();
    }

    private void initializeComponents() {
        uiFieldPlayer1 = addComponent("Player 1");
        uiFieldPlayer1.addFocusListener(new FocusListener() {
            @Override
            public void focusGained(FocusEvent e) {
                if (client.getGameState().equals(GameState.LOGGED_IN)) {
                    uiFieldPlayer1.setText(Objects.requireNonNull(client.getLocalPlayer()).getName());
                    addAllPreferences(uiFieldPlayer1Preferences);
                }
            }

            @Override
            public void focusLost(FocusEvent e) {

            }
        });

        isInitialPlayer1PreferencesSet = false;
        initialPlayer1Preferences = new boolean[6];
        uiFieldPlayer1Preferences = generatePlayerPreferences(uiFieldPlayer1, initialPlayer1Preferences, 1);
        addFillListener(uiFieldPlayer1Preferences);
        addCheckFillListener(uiFieldPlayer1Preferences);

        uiFieldPlayer2 = addComponent("Player 2");
        initialPlayer2Preferences = new boolean[6];
        isInitialPlayer2PreferencesSet = false;
        uiFieldPlayer2Preferences = generatePlayerPreferences(uiFieldPlayer2, initialPlayer2Preferences, 2);
        addFillListener(uiFieldPlayer2Preferences);

        addCheckFillListener(uiFieldPlayer2Preferences);

        uiFieldPlayer3 = addComponent("Player 3");
        initialPlayer3Preferences = new boolean[6];
        isInitialPlayer3PreferencesSet = false;
        uiFieldPlayer3Preferences = generatePlayerPreferences(uiFieldPlayer3, initialPlayer3Preferences, 3);
        addFillListener(uiFieldPlayer3Preferences);
        addCheckFillListener(uiFieldPlayer3Preferences);

        uiFieldPlayer4 = addComponent("Player 4");
        initialPlayer4Preferences = new boolean[6];
        isInitialPlayer4PreferencesSet = false;
        uiFieldPlayer4Preferences = generatePlayerPreferences(uiFieldPlayer4, initialPlayer4Preferences, 4);
        addFillListener(uiFieldPlayer4Preferences);
        addCheckFillListener(uiFieldPlayer4Preferences);

        uiFieldPlayer5 = addComponent("Player 5");
        initialPlayer5Preferences = new boolean[6];
        isInitialPlayer5PreferencesSet = false;
        uiFieldPlayer5Preferences = generatePlayerPreferences(uiFieldPlayer5, initialPlayer5Preferences, 5);
        addFillListener(uiFieldPlayer5Preferences);
        addCheckFillListener(uiFieldPlayer5Preferences);

        resetButton = addResetButtonComponent("Reset");
        addRandomizeButtonComponent("Randomize!");

        rr = new RoleRandomizer();
    }

    public void cleanSlate() {
        initialPlayer1Preferences = new boolean[6];
        isInitialPlayer1PreferencesSet = false;
        initialPlayer2Preferences = new boolean[6];
        isInitialPlayer2PreferencesSet = false;
        initialPlayer3Preferences = new boolean[6];
        isInitialPlayer3PreferencesSet = false;
        initialPlayer4Preferences = new boolean[6];
        isInitialPlayer4PreferencesSet = false;
        initialPlayer5Preferences = new boolean[6];
        isInitialPlayer5PreferencesSet = false;

        resetCheckBoxes(uiFieldPlayer1Preferences);
        resetCheckBoxes(uiFieldPlayer2Preferences);
        resetCheckBoxes(uiFieldPlayer3Preferences);
        resetCheckBoxes(uiFieldPlayer4Preferences);
        resetCheckBoxes(uiFieldPlayer5Preferences);

        uiFieldPlayer1.setText("");
        uiFieldPlayer2.setText("");
        uiFieldPlayer3.setText("");
        uiFieldPlayer4.setText("");
        uiFieldPlayer5.setText("");

        resetButton.setEnabled(false);

        rr = new RoleRandomizer();
    }

    private void resetCheckBoxes(JCheckBox[] boxes) {
        for (JCheckBox jCheckBox : boxes) {
            jCheckBox.setSelected(false);
        }
    }
}

/*
 * Copyright (c) 2021-2022, Keano Porcaro <keano@ransty.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.rolerandomizer.ui;

import com.rolerandomizer.RoleRandomizerConfig;
import net.runelite.api.Client;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.PluginPanel;

import javax.swing.*;
import javax.swing.border.EmptyBorder;

public class RoleRandomizerPluginPanel extends PluginPanel
{

        public RandomizeResultPanel resultPanel;
        public RoleRandomizerPanel inputPanel;
        public OptionsPanel optionsPanel;

    public RoleRandomizerPluginPanel(Client client, RoleRandomizerConfig config, ChatMessageManager chatMessageManager)
        {
            super();

            inputPanel = new RoleRandomizerPanel(client, config, chatMessageManager, this);

            resultPanel = new RandomizeResultPanel(this);

            optionsPanel = new OptionsPanel(this, inputPanel);

            JButton clearButton = new JButton("Clear");
            clearButton.setBackground(ColorScheme.PROGRESS_ERROR_COLOR);
            clearButton.setBorder(new EmptyBorder(5, 7, 5, 7));
            clearButton.setToolTipText("This wipes the slate clean!");
            clearButton.addActionListener(e -> {
                inputPanel.cleanSlate();
                resultPanel.cleanSlate();
            });

            JButton removePreviousButton = new JButton("Remove previous roles");
            removePreviousButton.setBackground(ColorScheme.DARKER_GRAY_COLOR);
            removePreviousButton.setFocusable(false);
            removePreviousButton.addActionListener(e -> {
                inputPanel.removePreviousRoles();
            });

            add(inputPanel);
            add(removePreviousButton);
            add(resultPanel);
            add(clearButton);
            add(optionsPanel);
        }

    public boolean addPlayer(String stringSelection) {
        String player = stringSelection.toString();
        // sanitize the string even more
        player = player.replaceAll("\\[.*\\]", "").trim().replace(":", "");
        // player 1 is always covered by the UI
        if (inputPanel.uiFieldPlayer2.getText().isEmpty()) {
            inputPanel.uiFieldPlayer2.setText(player);
            inputPanel.addAllPreferences(inputPanel.uiFieldPlayer2Preferences);
            return true;
        } else if (inputPanel.uiFieldPlayer3.getText().isEmpty()) {
            inputPanel.uiFieldPlayer3.setText(player);
            inputPanel.addAllPreferences(inputPanel.uiFieldPlayer3Preferences);
            return true;
        } else if (inputPanel.uiFieldPlayer4.getText().isEmpty()) {
            inputPanel.uiFieldPlayer4.setText(player);
            inputPanel.addAllPreferences(inputPanel.uiFieldPlayer4Preferences);
            return true;
        } else if (inputPanel.uiFieldPlayer5.getText().isEmpty()) {
            inputPanel.uiFieldPlayer5.setText(player);
            inputPanel.addAllPreferences(inputPanel.uiFieldPlayer5Preferences);
            return true;
        }
        return false;
    }
}

/*
 * Copyright (c) 2021, Keano Porcaro <keano@ransty.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.rolerandomizer.exceptions;

import com.rolerandomizer.RoleRandomizer;
import org.junit.Test;

public class NoPermutationExceptionTest
{
    @Test(expected = NoPermutationException.class)
    public void testNoPermutationException() throws Exception
    {
        RoleRandomizer rr = new RoleRandomizer();
        int[] badPrefs = new int[]{1, 0, 0, 0, 0};
        rr.setPlayerOnePreferences(badPrefs);
        rr.setPlayerTwoPreferences(badPrefs);
        rr.setPlayerThreePreferences(badPrefs);
        rr.setPlayerFourPreferences(badPrefs);
        rr.setPlayerFivePreferences(badPrefs);
        rr.randomize();
    }
}

package com.rolerandomizer;

import com.google.common.collect.ImmutableList;
import java.util.Arrays;
import java.util.Collections;
import java.util.List;

import com.rolerandomizer.exceptions.CannotDetermineRolesException;
import com.rolerandomizer.exceptions.CannotParseArgException;
import org.junit.Assert;
import org.junit.Before;
import org.junit.Test;

public class RoleParserTest
{
	private RoleParser parser;

	private static final List<MetaRoleInfo> FILL = Arrays.asList(MetaRoleInfo.values().clone());
	private static final List<MetaRoleInfo> A_H_C = ImmutableList.of(MetaRoleInfo.MAIN_ATTACKER,
		MetaRoleInfo.SECOND_ATTACKER, MetaRoleInfo.HEALER, MetaRoleInfo.COLLECTOR);
	private static final List<MetaRoleInfo> H_C_D = ImmutableList.of(MetaRoleInfo.HEALER, MetaRoleInfo.COLLECTOR,
		MetaRoleInfo.DEFENDER);

	private static final List<List<String>> GOOD_INPUTS = ImmutableList.of(
		ImmutableList.of("alice", "bob", "collguy", "defsabo", "egglad"),
		ImmutableList.of("lugal_ki_en", "fill", "ransty", "a/c/h", "loasted", "fill", "toohey", "fill", "equi"),
		ImmutableList.of("phil", "fill", "fill", "fill", "me", "m", "somebody", "anybody"),
		ImmutableList.of("dach", "dch", "mach", "fill", "cahd", "fill", "chad", "fill", "hesi")
	);

	private static final List<List<PlayerPrefs>> GOOD_OUTPUTS = ImmutableList.of(
		ImmutableList.of(
			new PlayerPrefs("alice", FILL),
			new PlayerPrefs("bob", FILL),
			new PlayerPrefs("collguy", FILL),
			new PlayerPrefs("defsabo", FILL),
			new PlayerPrefs("egglad", FILL)
		),
		ImmutableList.of(
			new PlayerPrefs("equi", FILL),
			new PlayerPrefs("loasted", FILL),
			new PlayerPrefs("lugal_ki_en", FILL),
			new PlayerPrefs("ransty", A_H_C),
			new PlayerPrefs("toohey", FILL)
		),
		ImmutableList.of(
			new PlayerPrefs("anybody", FILL),
			new PlayerPrefs("fill", FILL),
			new PlayerPrefs("me", Collections.singletonList(MetaRoleInfo.MAIN_ATTACKER)),
			new PlayerPrefs("phil", FILL),
			new PlayerPrefs("somebody", FILL)
		),
		ImmutableList.of(
			new PlayerPrefs("cahd", FILL),
			new PlayerPrefs("chad", FILL),
			new PlayerPrefs("dach", H_C_D),
			new PlayerPrefs("hesi", FILL),
			new PlayerPrefs("mach", FILL)
		)
	);

	private static final List<List<String>> CANNOT_DETERMINE_INPUTS = ImmutableList.of(
		ImmutableList.of("not", "enough", "for5"),
		ImmutableList.of("too", "many", "names", "for", "five", "players"),
		ImmutableList.of("b2b_roles", "2/c/d", "a/c/h", "phil", "jim", "greg")
	);

	private static final List<List<String>> BAD_ARGS_INPUTS = ImmutableList.of(
		ImmutableList.of("v_not_role", "2/h/v", "p2", "p3", "p4", "b5"),
		ImmutableList.of("no_dupe_roles", "a/a/d", "p2", "p3", "p4", "b5"),
		ImmutableList.of("bad_slash", "a/ch", "p2", "p3", "p4", "b5"),
		ImmutableList.of("end_slash", "a/c/", "p2", "p3", "p4", "b5"),
		ImmutableList.of("fill_plus", "fill/c/d", "p2", "p3", "p4", "b5")
	);

	@Before
	public void setUp()
	{
		parser = new RoleParser();
	}

	@Test
	public void testUnambiguousInputs()
	{
		Assert.assertEquals("test case inputs + outputs should be same size",
			GOOD_OUTPUTS.size(), GOOD_INPUTS.size());
		for (int i = 0; i < GOOD_INPUTS.size(); i++)
		{
			try
			{
				List<String> inputs = GOOD_INPUTS.get(i);
				List<PlayerPrefs> prefs = parser.parse(inputs);
				Assert.assertEquals(GOOD_OUTPUTS.get(i), prefs);
			}
			catch (CannotParseArgException | CannotDetermineRolesException e)
			{
				Assert.fail(e.getMessage());
			}
		}
	}

	@Test
	public void testBadArgs()
	{
		for (List<String> inputs : BAD_ARGS_INPUTS)
		{
			try
			{
				parser.parse(inputs);
				Assert.fail("should have thrown");
			}
			catch (CannotDetermineRolesException e)
			{
				Assert.fail(e.getMessage());
			}
			catch (CannotParseArgException e)
			{
				//pass
			}
		}
	}

	@Test
	public void testCannotDetermine()
	{
		for (List<String> inputs : CANNOT_DETERMINE_INPUTS)
		{
			try
			{
				parser.parse(inputs);
				Assert.fail("should have thrown");
			}
			catch (CannotDetermineRolesException e)
			{
				// pass
			}
			catch (CannotParseArgException e)
			{
				Assert.fail(e.getMessage());
			}
		}
	}
}

/*
 * Copyright (c) 2021, Keano Porcaro <keano@ransty.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.rolerandomizer;

import net.runelite.client.RuneLite;
import net.runelite.client.externalplugins.ExternalPluginManager;

public class RoleRandomizerPluginTest
{
	public static void main(String[] args) throws Exception
	{
		ExternalPluginManager.loadBuiltin(RoleRandomizerPlugin.class);
		RuneLite.main(args);
	}
}
/*
 * Copyright (c) 2021, Keano Porcaro <keano@ransty.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.rolerandomizer;

import com.rolerandomizer.exceptions.NoPermutationException;
import org.junit.Before;
import org.junit.Test;
import static org.junit.Assert.assertEquals;
import java.util.HashMap;


public class RoleRandomizerTest {

    RoleRandomizer randomizer;
    HashMap<Integer, String> users;

    @Before
    public void setUp()
    {
        randomizer = new RoleRandomizer();
        int[] aacPrefs = new int[]{1, 1, 0, 1, 0};
        int[] hcdPrefs = new int[]{0, 0, 1, 1, 1};
        users = new HashMap<>();

        for (int i = 0; i < 5; i++)
        {
            users.put(i, "");
        }

        randomizer.setUsernames(users);
        randomizer.setPlayerOnePreferences(aacPrefs);
        randomizer.setPlayerTwoPreferences(hcdPrefs);
        randomizer.setPlayerThreePreferences(aacPrefs);
        randomizer.setPlayerFourPreferences(hcdPrefs);
        randomizer.setPlayerFivePreferences(aacPrefs);
    }

    @Test
    public void testSetUsernames()
    {
        assertEquals(randomizer.usernames, users);
    }

    @Test
    public void testSetPlayerOnePreferences()
    {
        int[] prefs = {1, 0, 1, 0, 1};
        randomizer.setPlayerOnePreferences(prefs);
        assertEquals(randomizer.playerOnePreferences, prefs);
    }

    @Test
    public void testSetPlayerTwoPreferences()
    {
        int[] prefs = {1, 1, 1, 1, 1};
        randomizer.setPlayerTwoPreferences(prefs);
        assertEquals(randomizer.playerTwoPreferences, prefs);
    }

    @Test
    public void testSetPlayerThreePreferences()
    {
        int[] prefs = {1, 0, 1, 1, 1};
        randomizer.setPlayerThreePreferences(prefs);
        assertEquals(randomizer.playerThreePreferences, prefs);
    }

    @Test
    public void testSetPlayerFourPreferences()
    {
        int[] prefs = {1, 0, 0, 0, 1};
        randomizer.setPlayerFourPreferences(prefs);
        assertEquals(randomizer.playerFourPreferences, prefs);
    }

    @Test
    public void testSetPlayerFivePreferences()
    {
        int[] prefs = {1, 1, 1, 0, 1};
        randomizer.setPlayerFivePreferences(prefs);
        assertEquals(randomizer.playerFivePreferences, prefs);
    }

    @Test
    public void testRandomize()
    {
        String[] roles;
        try
        {
            roles = randomizer.randomize();
            assertEquals(users.size(), roles.length);
            assertEquals(true, roles[0].contains(""));
        }
        catch (Exception e)
        {
            e.printStackTrace();
        }
    }

    @Test(expected = NoPermutationException.class)
    public void testRandomizeNoPerms() throws Exception
    {
            int[] noPrefs = {0, 0, 0, 0, 0};
            randomizer.setPlayerOnePreferences(noPrefs);
            randomizer.setPlayerTwoPreferences(noPrefs);
            randomizer.setPlayerThreePreferences(noPrefs);
            randomizer.setPlayerFourPreferences(noPrefs);
            randomizer.setPlayerFivePreferences(noPrefs);
            randomizer.randomize();
    }

    @Test()
    public void testRandomizeNoPrefs() throws Exception
    {
        randomizer.setPlayerFivePreferences(null);
        randomizer.setPlayerFourPreferences(null);
        randomizer.setPlayerThreePreferences(null);
        randomizer.setPlayerTwoPreferences(null);
        randomizer.setPlayerOnePreferences(null);
        randomizer.randomize();
    }

    @Test
    public void testIsPreferencesSet_notSet()
    {
        randomizer.setPlayerFivePreferences(null);
        assertEquals(false, randomizer.isPreferencesSet());
        randomizer.setPlayerFourPreferences(null);
        assertEquals(false, randomizer.isPreferencesSet());
        randomizer.setPlayerThreePreferences(null);
        assertEquals(false, randomizer.isPreferencesSet());
        randomizer.setPlayerTwoPreferences(null);
        assertEquals(false, randomizer.isPreferencesSet());
        randomizer.setPlayerOnePreferences(null);
        assertEquals(false, randomizer.isPreferencesSet());
    }

    @Test
    public void testGeneratePermutations()
    {
        int[] noPrefs = {0, 0, 0, 0, 0};
        randomizer.setPlayerOnePreferences(noPrefs);
        randomizer.setPlayerTwoPreferences(noPrefs);
        randomizer.setPlayerThreePreferences(noPrefs);
        randomizer.setPlayerFourPreferences(noPrefs);
        randomizer.setPlayerFivePreferences(noPrefs);
        try {
            randomizer.generatePermutations();
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}

