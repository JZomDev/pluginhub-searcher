package rs117.hd.utils;

import com.google.common.annotations.VisibleForTesting;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonToken;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.HashSet;
import lombok.extern.slf4j.Slf4j;

@Slf4j
public class GsonUtils {
    @VisibleForTesting
    public static boolean THROW_WHEN_PARSING_FAILS = false;

	public static String location(JsonReader in) {
		var str = in.toString();
		int i = str.indexOf(" at ");
		if (i != -1)
			str = str.substring(i + 4);
		return str;
	}

	public static HashSet<Integer> parseIDArray(JsonReader in) throws IOException {
		HashSet<Integer> ids = new HashSet<>();
		in.beginArray();
		while (in.hasNext()) {
			if (in.peek() == JsonToken.NUMBER) {
				try {
					ids.add(in.nextInt());
				} catch (NumberFormatException ex) {
					String message = "Failed to parse int at " + location(in);
					if (THROW_WHEN_PARSING_FAILS)
						throw new RuntimeException(message, ex);
					log.error(message, ex);
				}
			} else {
				throw new RuntimeException("Unable to parse ID: " + in.peek() + " at " + location(in));
			}
		}
        in.endArray();
        return ids;
    }

	public static void writeIDArray(JsonWriter out, HashSet<Integer> listToWrite) throws IOException {
		if (listToWrite.isEmpty()) {
			out.nullValue();
			return;
		}

		out.beginArray();
		for (int id : listToWrite)
			out.value(id);
		out.endArray();
	}

	public static class IntegerSetAdapter extends TypeAdapter<HashSet<Integer>> {
		@Override
		public HashSet<Integer> read(JsonReader in) throws IOException {
			return parseIDArray(in);
		}

		@Override
		public void write(JsonWriter out, HashSet<Integer> value) throws IOException {
			writeIDArray(out, value);
		}
	}

	@Slf4j
	public static class DegreesToRadians extends TypeAdapter<Object> {
		@Override
		public Object read(JsonReader in) throws IOException {
			var token = in.peek();
			if (token == JsonToken.NULL)
				return null;

			if (token == JsonToken.NUMBER) {
				float angle = (float) in.nextDouble();
				return (float) Math.toRadians(angle);
			}

			if (token == JsonToken.BEGIN_ARRAY) {
				ArrayList<Float> list = new ArrayList<>();
				in.beginArray();
				while (in.hasNext() && in.peek() != JsonToken.END_ARRAY) {
					if (in.peek() == JsonToken.BEGIN_ARRAY)
						throw new IOException("Expected an array of numbers. Got nested arrays.");
					list.add((float) read(in));
				}
				in.endArray();

				float[] result = new float[list.size()];
				for (int i = 0; i < list.size(); i++)
					result[i] = list.get(i);
				return result;
			}

			throw new IOException("Expected a number or array of numbers. Got " + token);
		}

		@Override
		public void write(JsonWriter out, Object src) throws IOException {
			if (src == null) {
				out.nullValue();
				return;
			}

			if (src instanceof float[]) {
				out.beginArray();
				for (float f : (float[]) src)
					out.value(Math.toDegrees(f));
				out.endArray();
				return;
			}

			if (src instanceof Float) {
				out.value(Math.toDegrees((float) src));
			}

			throw new IOException("Expected a float or float array. Got " + src);
		}
	}
}

package rs117.hd.utils;

import java.text.DecimalFormat;
import java.util.Arrays;

public class Matrix {
	/**
	 * Utility class for working with column-major m x n matrices.
	 */

	public static float[] copy(float[] m) {
		return Arrays.copyOf(m, m.length);
	}

	public static void solve(float[] m, int rows, int columns) {
		int square = Math.min(columns, rows);
		columns:
		for (int j = 0; j < square; j++) {
			for (int i = j; i < rows; i++) {
				var f = m[j * rows + i];
				if (f == 0)
					continue;

				// Swap the row into the right position
				if (i != j) {
					for (int k = 0; k < rows * columns; k += rows) {
						var tmp = m[k + j];
						m[k + j] = m[k + i];
						m[k + i] = tmp;
					}
				}

				// Divide by the first entry of the row
				f = 1 / f;
				for (int k = 0; k < rows * columns; k += rows)
					m[k + j] *= f;

				// Add or subtract multiples to reduce other rows
				for (int r = 0; r < rows; r++) {
					if (r == j)
						continue;
					var g = m[j * rows + r];
					if (g != 0)
						for (int k = 0; k < rows * columns; k += rows)
							m[k + r] += -g * m[k + j];
				}

				continue columns;
			}

			throw new IllegalArgumentException("Linear system does not have a solution");
		}
	}

	public static String format(float[] m, int rows, int columns) {
		String[] f = new String[m.length];
		var format = new DecimalFormat("0.##");
		int maxdigits = 0;
		int maxfractions = 0;
		for (int i = 0; i < rows * columns; i++) {
			float v = m[i];
			if (Math.abs(v) < .01)
				v = 0;
			f[i] = format.format(v);
			var j = f[i].indexOf('.');
			if (j == -1) {
				maxdigits = Math.max(maxdigits, f[i].length());
			} else {
				maxdigits = Math.max(maxdigits, j);
				maxfractions = Math.max(maxfractions, f[i].length() - j);
			}
		}

		StringBuilder str = new StringBuilder();

		for (int row = 0; row < rows; row++) {
			for (int col = 0; col < columns; col++) {
				int idx = col * rows + row;
				int dot = f[idx].indexOf('.');
				if (dot == -1) {
					int padLeft = maxdigits - f[idx].length();
					if (padLeft > 0)
						f[idx] = " ".repeat(padLeft) + f[idx];
					f[idx] += " ".repeat(maxfractions);
				} else {
					int padLeft = maxdigits - dot;
					if (padLeft > 0)
						f[idx] = " ".repeat(padLeft) + f[idx];
					int padRight = maxfractions - (f[idx].length() - dot);
					if (padRight > 0)
						f[idx] += " ".repeat(padRight);
				}

				if (col == 0)
					str.append("[ ");
				str.append(f[idx]).append(" ");
				if (col == columns - 1) {
					str.append("]");
					if (idx != m.length - 1)
						str.append("\n");
				}
			}
		}

		return str.toString();
	}
}

package rs117.hd.utils;

import java.util.Arrays;

public class Vector {
	public static float[] copy(float[] v) {
		return Arrays.copyOf(v, v.length);
	}

	/**
	 * Computes a + b, storing it in the out array
	 */
	public static float[] add(float[] out, float[] a, float[] b) {
		for (int i = 0; i < out.length; i++)
			out[i] = a[i] + b[i];
		return out;
	}

	/**
	 * Computes a - b, storing it in the out array
	 */
	public static float[] subtract(float[] out, float[] a, float[] b) {
		for (int i = 0; i < out.length; i++)
			out[i] = a[i] - b[i];
		return out;
	}

	public static float dot(float[] a, float[] b) {
		float f = 0;
		int len = Math.min(a.length, b.length);
		for (int i = 0; i < len; i++)
			f += a[i] * b[i];
		return f;
	}

	public static float[] cross(float[] out, float[] a, float[] b) {
		out[0] = a[1] * b[2] - a[2] * b[1];
		out[1] = a[2] * b[0] - a[0] * b[2];
		out[2] = a[0] * b[1] - a[1] * b[0];
		return out;
	}

	public static float length(float... vector) {
		float lengthSquared = 0;
		for (float v : vector)
			lengthSquared += v * v;
		return (float) Math.sqrt(lengthSquared);
	}

	public static void normalize(float[] vector) {
		float length = length(vector);
		if (length == 0)
			return;
		length = 1 / length;
		for (int i = 0; i < vector.length; i++)
			vector[i] *= length;
	}

	public static void abs(float[] out, float[] v) {
		for (int i = 0; i < out.length; i++)
			out[i] = Math.abs(v[i]);
	}
}

package rs117.hd.utils;

@FunctionalInterface
public interface VariableSupplier {
	Object get(String variableName);
}

/*
 * Copyright (c) 2021, 117 <https://twitter.com/117scape>
 * Copyright (c) 2022, Hooder <ahooder@protonmail.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package rs117.hd.utils;

import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonToken;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import net.runelite.api.coords.*;
import rs117.hd.data.environments.Area;

import static net.runelite.api.Constants.*;

public class AABB {
	public final int minX;
	public final int minY;
	public final int minZ;
	public final int maxX;
	public final int maxY;
	public final int maxZ;

	public AABB(int regionId) {
		minX = (regionId >>> 8) << 6;
		minY = (regionId & 0xFF) << 6;
		maxX = minX + REGION_SIZE - 1;
		maxY = minY + REGION_SIZE - 1;
		minZ = Integer.MIN_VALUE;
		maxZ = Integer.MAX_VALUE;
	}

	public AABB(int x, int y) {
		minX = maxX = x;
		minY = maxY = y;
		minZ = Integer.MIN_VALUE;
		maxZ = Integer.MAX_VALUE;
	}

	public AABB(int x, int y, int z) {
		minX = maxX = x;
		minY = maxY = y;
		minZ = maxZ = z;
	}

	public AABB(int x1, int y1, int x2, int y2) {
		minX = Math.min(x1, x2);
		minY = Math.min(y1, y2);
		minZ = Integer.MIN_VALUE;
		maxX = Math.max(x1, x2);
		maxY = Math.max(y1, y2);
		maxZ = Integer.MAX_VALUE;
	}

	public AABB(int x1, int y1, int x2, int y2, int z1) {
		minX = Math.min(x1, x2);
		minY = Math.min(y1, y2);
		maxX = Math.max(x1, x2);
		maxY = Math.max(y1, y2);
		minZ = maxZ = z1;
	}

	public AABB(int x1, int y1, int z1, int x2, int y2, int z2) {
		minX = Math.min(x1, x2);
		minY = Math.min(y1, y2);
		minZ = Math.min(z1, z2);
		maxX = Math.max(x1, x2);
		maxY = Math.max(y1, y2);
		maxZ = Math.max(z1, z2);
	}

	public AABB(int[] from, int[] to) {
		this(from[0], from[1], from[2], to[0], to[1], to[2]);
	}

	public static AABB[] regions(int... regionIds) {
		return Arrays.stream(regionIds)
			.mapToObj(AABB::new)
			.toArray(AABB[]::new);
	}

	public static AABB regionBox(int fromRegionId, int toRegionId) {
		int x1 = fromRegionId >>> 8;
		int y1 = fromRegionId & 0xFF;
		int x2 = toRegionId >>> 8;
		int y2 = toRegionId & 0xFF;
		if (x1 > x2) {
			int temp = x1;
			x1 = x2;
			x2 = temp;
		}
		if (y1 > y2) {
			int temp = y1;
			y1 = y2;
			y2 = temp;
		}
		return new AABB((x1) << 6, (y1) << 6, ((x2) + 1 << 6) - 1, ((y2) + 1 << 6) - 1);
	}

	public AABB onPlane(int plane) {
		return new AABB(minX, minY, plane, maxX, maxY, plane);
	}

	public boolean hasZ() {
		return minZ != Integer.MIN_VALUE || maxZ != Integer.MAX_VALUE;
	}

	public boolean isPoint() {
		return
			minX == maxX &&
			minY == maxY &&
			(!hasZ() || minZ == maxZ);
	}

	public boolean isVolume() {
		return !isPoint();
	}

	public boolean contains(int... worldXYZ) {
		return
			minX <= worldXYZ[0] && worldXYZ[0] <= maxX &&
			minY <= worldXYZ[1] && worldXYZ[1] <= maxY &&
			(worldXYZ.length < 3 || minZ <= worldXYZ[2] && worldXYZ[2] <= maxZ);
	}

	public boolean contains(WorldPoint location) {
		return contains(location.getX(), location.getY(), location.getPlane());
	}

	public boolean contains(AABB other) {
		return
			contains(other.minX, other.minY, other.minZ) &&
			contains(other.maxX, other.maxY, other.maxZ);
	}

	public boolean intersects(int minX, int minY, int maxX, int maxY) {
		return
			minX < this.maxX && maxX > this.minX &&
			minY < this.maxY && maxY > this.minY;
	}

	public boolean intersects(int minX, int maxX, int minY, int maxY, int minZ, int maxZ) {
		return
			minX < this.maxX && maxX > this.minX &&
			minY < this.maxY && maxY > this.minY &&
			minZ < this.maxZ && maxZ > this.minZ;
	}

	public boolean intersects(AABB other) {
		return intersects(
			other.minX, other.maxX,
			other.minY, other.maxY,
			other.minZ, other.maxZ
		);
	}

	@Override
	public String toString() {
		if (hasZ())
			return String.format("AABB{min=(%d,%d,%d), max=(%d,%d,%d)}", minX, minY, minZ, maxX, maxY, maxZ);
		return String.format("AABB{min=(%d,%d), max=(%d,%d)}", minX, minY, maxX, maxY);
	}

	public String toArgs() {
		if (isPoint())
			return String.format("%d, %d", minX, minY);
		if (minZ == maxZ)
			return String.format("%d, %d, %d, %d, %d", minX, minY, maxX, maxY, minZ);
		return String.format("%d, %d, %d, %d, %d, %d", minX, minY, minZ, maxX, maxY, maxZ);
	}

	@Override
	public boolean equals(Object obj) {
		if (!(obj instanceof AABB))
			return false;

		AABB other = (AABB) obj;
		return
			other.minX == minX && other.maxX == maxX &&
			other.minY == minY && other.maxY == maxY &&
			other.minZ == minZ && other.maxZ == maxZ;
	}

	public static class JsonAdapter extends TypeAdapter<AABB[]> {
		private final Area.JsonAdapter areaAdapter = new Area.JsonAdapter();

		@Override
		public AABB[] read(JsonReader in) throws IOException {
			in.beginArray();
			ArrayList<AABB> list = new ArrayList<>();
			while (in.hasNext() && in.peek() != JsonToken.END_ARRAY) {
				if (in.peek() == JsonToken.NULL) {
					in.skipValue();
					continue;
				}

				// Parse numbers as region IDs
				if (in.peek() == JsonToken.NUMBER) {
					list.add(new AABB(in.nextInt()));
					continue;
				}

				if (in.peek() == JsonToken.STRING) {
					var area = areaAdapter.read(in);
					Collections.addAll(list, area.aabbs);
					continue;
				}

				in.beginArray();
				int[] ints = new int[6];
				int i = 0;
				while (in.hasNext()) {
					switch (in.peek()) {
						case NUMBER:
							if (i >= ints.length)
								throw new IOException(
									"Too many numbers in AABB entry (> " + ints.length + ") at " + GsonUtils.location(in));
							ints[i++] = in.nextInt();
						case END_ARRAY:
							break;
						case NULL:
							in.skipValue();
							continue;
						default:
							throw new IOException("Malformed AABB entry. Unexpected token: " + in.peek() + " at " + GsonUtils.location(in));
					}
				}
				in.endArray();

				switch (i) {
					case 1:
						list.add(new AABB(ints[0]));
						break;
					case 2:
						list.add(new AABB(ints[0], ints[1]));
						break;
					case 3:
						list.add(new AABB(ints[0], ints[1], ints[2]));
						break;
					case 4:
						list.add(new AABB(ints[0], ints[1], ints[2], ints[3]));
						break;
					case 5:
						list.add(new AABB(ints[0], ints[1], ints[2], ints[3], ints[4]));
						break;
					case 6:
						list.add(new AABB(ints[0], ints[1], ints[2], ints[3], ints[4], ints[5]));
						break;
				}
			}
			in.endArray();
			return list.toArray(new AABB[0]);
		}

		@Override
		public void write(JsonWriter out, AABB[] aabbs) throws IOException {
			if (aabbs == null || aabbs.length == 0) {
				out.nullValue();
				return;
			}

			out.beginArray();
			for (AABB aabb : aabbs) {
				out.beginArray();
				out.value(aabb.minX);
				out.value(aabb.minY);
				if (aabb.hasZ())
					out.value(aabb.minZ);
				if (aabb.isVolume()) {
					out.value(aabb.maxX);
					out.value(aabb.maxY);
					if (aabb.hasZ())
						out.value(aabb.maxZ);
				}
				out.endArray();
			}
			out.endArray();
		}
	}
}

package rs117.hd.utils;

import java.util.Properties;
import java.util.function.Supplier;
import javax.annotation.Nonnull;

import static rs117.hd.utils.ResourcePath.path;

public class Props
{
	public static boolean DEVELOPMENT;

	private static final Properties env = new Properties(System.getProperties());

	public static boolean has(String variableName)
	{
		return env.containsKey(variableName);
	}

	public static String get(String variableName)
	{
		return env.getProperty(variableName);
	}

	public static String getOrDefault(String variableName, String defaultValue)
	{
		String value = get(variableName);
		return value == null ? defaultValue : value;
	}

	public static String getOrDefault(String variableName, @Nonnull Supplier<String> defaultValueSupplier)
	{
		String value = get(variableName);
		return value == null ? defaultValueSupplier.get() : value;
	}

	public static boolean getBoolean(String variableName)
	{
		String value = get(variableName);
		if (value == null)
			return false;
		if (value.isEmpty())
			return true;
		value = value.toLowerCase();
		return value.equals("true") || value.equals("1") || value.equals("on") || value.equals("yes");
	}

	public static ResourcePath getPathOrDefault(String variableName, @Nonnull Supplier<ResourcePath> fallback) {
		String path = get(variableName);
		if (path == null)
			return fallback.get();
		return path(path);
	}

	public static void set(String variableName, boolean value)
	{
		set(variableName, value ? "true" : "false");
	}

	public static void set(String variableName, String value)
	{
		if (value == null)
		{
			unset(variableName);
		}
		else
		{
			env.put(variableName, value);
		}
	}

	public static void unset(String variableName)
	{
		env.remove(variableName);
	}
}

/*
 * Copyright (c) 2022, Hooder <ahooder@protonmail.com>
 * Copyright (c) 2022, Mark <https://github.com/Mark7625>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package rs117.hd.utils;

import com.google.gson.Gson;
import java.awt.Toolkit;
import java.awt.image.BufferedImage;
import java.io.BufferedReader;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.OutputStream;
import java.net.URL;
import java.nio.ByteBuffer;
import java.nio.channels.Channels;
import java.nio.channels.ReadableByteChannel;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.Arrays;
import java.util.Stack;
import java.util.function.BiConsumer;
import java.util.function.BiFunction;
import java.util.function.Consumer;
import java.util.function.Function;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.stream.Collectors;
import javax.annotation.Nonnull;
import javax.annotation.Nullable;
import javax.annotation.RegEx;
import javax.swing.ImageIcon;
import lombok.NonNull;
import lombok.extern.slf4j.Slf4j;
import org.lwjgl.BufferUtils;
import org.lwjgl.system.MemoryUtil;
import org.lwjgl.system.Platform;

@Slf4j
public class ResourcePath {
	private static final ResourcePath RESOURCE_PATH = Props.getPathOrDefault("rlhd.resource-path", () -> null);
    private static final FileWatcher.UnregisterCallback NOOP = () -> {};

    @Nullable
    public final ResourcePath root;
    @Nullable
    public final String path;

    public static ResourcePath path(Path path) {
        return path(path.toString());
    }

    public static ResourcePath path(String... parts) {
        return new ResourcePath(parts);
    }

    public static ResourcePath path(Class<?> root, String... parts) {
        return new ClassResourcePath(root, parts);
    }

    public static ResourcePath path(ClassLoader root, String... parts)  {
        return new ClassLoaderResourcePath(root, parts);
    }

    private ResourcePath(String... parts) {
        this(null, parts);
    }

    private ResourcePath(@Nonnull ResourcePath root) {
        this.root = root;
        this.path = null;
    }

    private ResourcePath(@Nullable ResourcePath root, String... parts) {
        this.root = root;
        this.path = normalize(parts);
    }

    public ResourcePath chroot() {
        // Encapsulate the current root and path into a new root ResourcePath.
        // Subsequent path resolutions will not include the encapsulated path.
        return new ResourcePath(this);
    }

    public ResourcePath resolve(String... parts) {
        return new ResourcePath(root, normalize(path, parts));
    }
    
    @SuppressWarnings("ResultOfMethodCallIgnored")
    public ResourcePath mkdirs() {
		var file = toFile();
		if (file.isFile())
			file = file.getParentFile();
		file.mkdirs();
        return this;
    }

	public boolean exists() {
		if (root == null)
			return toFile().exists();
		return root.resolve(path).exists();
	}

    public String getFilename() {
        if (path == null)
            return "";
        int i = path.lastIndexOf("/");
        if (i != -1)
            return path.substring(i + 1);
        return path;
    }

    public String getExtension() {
        return getExtension(0);
    }

    public String getExtension(int nthLast) {
        String filename = getFilename();
        String extension = "";
        while (nthLast-- >= 0) {
            int i = filename.lastIndexOf('.');
            if (i == -1)
                return nthLast >= 0 ? "" : filename;
            extension = filename.substring(i + 1);
            filename = filename.substring(0, i);
        }
        return extension;
    }

    public ResourcePath setExtension(String extension) {
		if (path == null)
			throw new IllegalStateException("Cannot set extension for root path: " + this);

		String path = this.path;
		int i = path.lastIndexOf('.');
		if (i != -1)
			path = path.substring(0, i);

		if (extension != null && !extension.isEmpty())
			path += '.' + extension;

		return new ResourcePath(root, path);
	}

	public boolean matches(@RegEx String posixPathRegex) {
		Pattern p = Pattern.compile(posixPathRegex);
		Matcher m = p.matcher(toPosixPath());
		return m.find();
	}

	@Override
	public boolean equals(Object other) {
		return
			other instanceof ResourcePath &&
			toAbsolute().toPosixPath().equals(((ResourcePath) other).toAbsolute().toPosixPath());
	}

	@Override
	public String toString() {
		String path = toPosixPath();
		if (root != null)
			path = normalize(root.toPosixPath(), path.startsWith("/") ? path.substring(1) : path);
		return path.isEmpty() ? "." : path;
	}

	public ResourcePath toAbsolute() {
		if (root != null) {
			Path rootPath = root.toPath().toAbsolutePath();
			Path path = toPath().toAbsolutePath();
			return new ResourcePath(root, rootPath.relativize(path).toString());
		}
		return path(toPath().toAbsolutePath());
	}

	public String toPosixPath() {
		if (root != null)
			return normalize(root.toPosixPath(), new String[] { path });
		return path;
	}

	public Path toPath() {
		if (root == null) {
			assert path != null;
			return Paths.get(path);
		}

		Path basePath = root.toPath();
		if (path == null)
			return basePath;

		String relativePath = path.startsWith("/") ? path.substring(1) : path;
		return basePath.resolve(relativePath);
	}

	public File toFile() {
		if (!isFileSystemResource())
			throw new IllegalStateException("Not a file: " + this);
		return toPath().toFile();
	}

    @NonNull
    public URL toURL() throws IOException {
        if (root == null) {
            String path = toPath().toString();
            return new URL("file:" + (isAbsolute(path) ? path : "./" + path));
        }
        URL rootURL = root.toURL();
        return new URL(rootURL, rootURL.getProtocol() + ":" + normalize(rootURL.getPath(), new String[] { path }));
    }

    public BufferedReader toReader() throws IOException {
        return new BufferedReader(new InputStreamReader(toInputStream(), StandardCharsets.UTF_8));
    }

    public InputStream toInputStream() throws IOException {
        if (path == null)
            throw new IllegalStateException("Cannot get InputStream for root path: " + this);

        if (root != null) {
            String path = this.path;
            if (path.startsWith("/"))
                path = path.substring(1);
            return root.resolve(path).toInputStream();
        }

        try {
            return Files.newInputStream(toPath());
        } catch (IOException ex) {
            throw new IOException("Unable to load resource: " + this, ex);
        }
    }

    public FileOutputStream toOutputStream() throws FileNotFoundException {
        return new FileOutputStream(toFile());
    }

    public boolean isClassResource() {
        if (root != null)
            return root.isClassResource();
        return false;
    }

	public boolean isFileSystemResource() {
		return !isClassResource();
	}

	/**
	 * Run the callback once at the start & every time the resource (or sub resource) changes.
	 *
	 * @param changeHandler Callback to call once at the start (bool = true) and every time the resource changes (bool = false)
	 * @return A runnable that can be called to unregister the watch callback
	 */
	public FileWatcher.UnregisterCallback watch(BiConsumer<ResourcePath, Boolean> changeHandler) {
		var path = this;

		// Redirect to the project folder during development
		if (RESOURCE_PATH != null)
			path = RESOURCE_PATH.chroot().resolve(toAbsolute().toPath().toString());

		// Load once up front
		changeHandler.accept(path, true);

		// Watch for changes if the resource is on the file system, which will exclude paths pointing into the JAR.
		// By default, unless paths are overridden by VM arguments, all of 117 HD's paths point into the JAR.
		if (path.isFileSystemResource())
			return FileWatcher.watchPath(path, p -> changeHandler.accept(p, false));

		return NOOP;
	}

	public FileWatcher.UnregisterCallback watch(Consumer<ResourcePath> changeHandler) {
		return watch((path, first) -> changeHandler.accept(path));
	}

	/**
	 * Run the callback once at the start & every time the resource (or sub resource) changes.
	 *
	 * @param changeHandler Callback to call once at the start and every time the resource changes
	 * @return A runnable that can be called to unregister the watch callback
	 */
	public FileWatcher.UnregisterCallback watch(@RegEx String filter, BiConsumer<ResourcePath, Boolean> changeHandler) {
		return watch((path, first) -> {
			if (path.matches(filter))
				changeHandler.accept(path, first);
		});
	}

	public FileWatcher.UnregisterCallback watch(@RegEx String filter, Consumer<ResourcePath> changeHandler) {
		return watch(filter, (path, first) -> changeHandler.accept(path));
	}

	public String loadString() throws IOException {
		try (BufferedReader reader = toReader()) {
			return reader.lines().collect(Collectors.joining(System.lineSeparator()));
		}
	}

	public <T> T loadJson(Gson gson, Class<T> type) throws IOException {
		try (BufferedReader reader = toReader()) {
			return gson.fromJson(reader, type);
		}
	}

	public BufferedImage loadImage() throws IOException {
		try (InputStream is = toInputStream()) {
			byte[] bytes = is.readAllBytes();
			var icon = new ImageIcon(Toolkit.getDefaultToolkit().createImage(bytes));
			var bufferedImage = new BufferedImage(
				icon.getIconWidth(),
				icon.getIconHeight(),
				BufferedImage.TYPE_INT_ARGB
			);
			var g = bufferedImage.createGraphics();
			icon.paintIcon(null, g, 0, 0);
			g.dispose();
			return bufferedImage;
		}
    }

    /**
     * Reads the full InputStream into a garbage-collected ByteBuffer allocated with BufferUtils.
     * @return a ByteBuffer
     * @throws IOException if the InputStream cannot be read
     */
    public ByteBuffer loadByteBuffer() throws IOException {
        return readInputStream(toInputStream(), BufferUtils::createByteBuffer, null);
    }

    /**
     * Reads the full InputStream into a ByteBuffer allocated with malloc, which must be explicitly freed.
     * @return a ByteBuffer
     * @throws IOException if the InputStream cannot be read
     */
    public ByteBuffer loadByteBufferMalloc() throws IOException {
        return readInputStream(toInputStream(), MemoryUtil::memAlloc, MemoryUtil::memRealloc);
    }

    public ResourcePath writeByteBuffer(ByteBuffer buffer) throws IOException {
		try (var os = toOutputStream(); var channel = os.getChannel()) {
			int bytesToWrite = buffer.remaining();
			int bytesWritten = channel.write(buffer);
			if (bytesWritten < bytesToWrite) {
				throw new IOException(String.format(
					"Only %d out of %d bytes were successfully written to %s",
					bytesWritten, bytesToWrite, this
				));
			}
		}
        return this;
    }

    public ResourcePath writeString(String string) throws IOException {
        try (OutputStream os = toOutputStream()) {
            os.write(string.getBytes(StandardCharsets.UTF_8));
        }
        return this;
    }

    /**
     * Reads the full InputStream into a garbage-collected ByteBuffer allocated with BufferUtils.
     * @param is the InputStream
     * @return a ByteBuffer
     * @throws IOException if the InputStream cannot be read
     */
    private static ByteBuffer readInputStream(
        InputStream is,
        Function<Integer, ByteBuffer> alloc,
        @Nullable BiFunction<ByteBuffer, Integer, ByteBuffer> realloc
    ) throws IOException {
        if (realloc == null) {
            realloc = (ByteBuffer oldBuffer, Integer newSize) -> {
                ByteBuffer newBuffer = alloc.apply(newSize);
                newBuffer.put(oldBuffer);
                return newBuffer;
            };
        }

        try (ReadableByteChannel channel = Channels.newChannel(is)) {
            // Read all currently buffered data into a ByteBuffer
            ByteBuffer buffer = alloc.apply(is.available());
            channel.read(buffer);

            // If there's more data available, double the buffer size and round up to the nearest power of 2
            if (is.available() > buffer.remaining()) {
                int newSize = (buffer.position() + is.available()) * 2;
                int nearestPow2 = 2 << (31 - Integer.numberOfLeadingZeros(newSize - 1));
                buffer = realloc.apply(buffer, nearestPow2);
            }

            // Continue reading all bytes, doubling the buffer each time it runs out of space
            while (is.available() > 0)
                if (buffer.remaining() == channel.read(buffer))
                    buffer = realloc.apply(buffer, buffer.capacity() * 2);

            channel.close();
            buffer.flip();
            return buffer;
        }
    }

    private static String normalize(String... parts) {
        return normalize(null, parts);
    }

    private static String normalize(@Nullable String workingDirectory, String[] parts) {
        Stack<String> resolvedParts = new Stack<>();
		if (workingDirectory != null && !workingDirectory.isEmpty() && !workingDirectory.equals("."))
            resolvedParts.addAll(Arrays.asList(normalizeSlashes(workingDirectory).split("/")));

        if (parts.length > 0)
            parts[0] = resolveTilde(parts[0]);

        for (String part : parts) {
			if (part == null || part.isEmpty() || part.equals("."))
                continue;

            part = normalizeSlashes(part);

            if (isAbsolute(part))
                resolvedParts.clear();

            for (String normalizedPart : part.split("/")) {
                if (normalizedPart.equals("..") &&
					!resolvedParts.isEmpty() &&
                    !resolvedParts.peek().equals("..")
                ) {
                    resolvedParts.pop();
                } else {
                    resolvedParts.push(normalizedPart);
                }
            }
        }

        return String.join("/", resolvedParts);
    }

    private static String normalizeSlashes(String path) {
        if (Platform.get() == Platform.WINDOWS)
            return path.replace("\\", "/");
        return path;
    }

    private static String resolveTilde(String path) {
        // Note: We only support ~ and ~user tilde expansion
        if (path == null || !path.startsWith("~"))
            return path;

        int slashIndex = path.indexOf('/');
        String specifiedUser = path.substring(1, slashIndex == -1 ? path.length() : slashIndex);
        String userHome = System.getProperty("user.home");
        if (userHome == null)
            throw new RuntimeException("Unable to resolve tilde path: " + path);

        Path home = Paths.get(userHome);

        // Check if the home path of a different user was specified
        if (!specifiedUser.isEmpty()) {
            // Assume the username matches the home folder name,
            // and that it's located next to the current user's home directory
            home = home.resolve("../" + specifiedUser);
        }

        if (slashIndex == -1)
            return home.toString();
        return home.resolve(path.substring(slashIndex + 1)).toString();
    }

    /**
     * Expects forward slashes as path delimiter, but accepts Windows-style drive letter prefixes.
     */
    private static boolean isAbsolute(String path) {
        if (Platform.get() == Platform.WINDOWS)
            path = path.replaceFirst("^\\w:", "");
        return path.startsWith("/");
    }

    private static class ClassResourcePath extends ResourcePath {
        public final Class<?> root;

        public ClassResourcePath(@NonNull Class<?> root, String... parts) {
            super(parts);
            this.root = root;
        }

        @Override
        public ResourcePath resolve(String... parts) {
            return new ClassResourcePath(root, normalize(path, parts));
        }

		@Override
		public boolean exists()
		{
			assert path != null;
			return root.getResource(path) != null;
		}

		@Override
        public String toString() {
            return super.toString() + " from class " + root.getName();
        }

        @Override
        public ResourcePath toAbsolute() {
            return path(root, normalize("/" + root.getPackage().getName().replace(".", "/"), path));
        }

        @Override
        public boolean isClassResource() {
            return true;
        }

        @Override
        @NonNull
        public URL toURL() throws IOException {
            assert path != null;
            URL url = root.getResource(path);
            if (url == null)
                throw new IOException("No resource found for path " + this);
            return url;
        }

        @Override
        public InputStream toInputStream() throws IOException {
            assert path != null;

            // Attempt to load resource from project resource folder if it's on the file system
			if (RESOURCE_PATH != null) {
				ResourcePath path = null;
				try {
					path = RESOURCE_PATH.chroot().resolve(toAbsolute().toPath().toString());
					return path.toInputStream();
				} catch (IOException ex) {
					throw new IOException("Failed to load resource from project resource path: " + path, ex);
				}
			} else {
				InputStream is = root.getResourceAsStream(path);
				if (is == null)
					throw new IOException("Missing resource: " + this);
				return is;
			}
        }
    }

    private static class ClassLoaderResourcePath extends ResourcePath {
        public final ClassLoader root;

        public ClassLoaderResourcePath(ClassLoader root, String... parts) {
            super(parts);
            this.root = root;
        }

        @Override
        public ResourcePath resolve(String... parts) {
            return new ClassLoaderResourcePath(root, normalize(path, parts));
        }

		@Override
		public boolean exists()
		{
			assert path != null;
			return root.getResource(path) != null;
		}

        @Override
        public String toString() {
            return super.toString() + " from class loader " + root;
        }

        @Override
        public ResourcePath toAbsolute() {
            assert path != null;
            return path.startsWith("/") ? this : path(root, "/", path);
        }

        @Override
        public boolean isClassResource() {
            return true;
        }

        @Override
        @NonNull
        public URL toURL() throws IOException {
            URL url = root.getResource(path);
            if (url == null)
                throw new IOException("No resource found for path " + this);
            return url;
        }

        @Override
        public InputStream toInputStream() throws IOException {
            assert path != null;

            // Attempt to load resource from project resource folder if it's not located in a jar
			if (RESOURCE_PATH != null) {
				ResourcePath path = null;
				try {
					path = RESOURCE_PATH.chroot().resolve(toAbsolute().toPath().toString());
					return path.toInputStream();
				} catch (Exception ex) {
					log.warn("Failed to load resource from project resource folder: {}", path, ex);
				}
			}

            InputStream is = root.getResourceAsStream(path);
            if (is == null)
                throw new IOException("Missing resource: " + this);
            return is;
        }
    }
}

/*
 * Copyright (c) 2018, Adam <Adam@sigterm.info>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package rs117.hd.utils.buffer;

import java.nio.IntBuffer;
import org.lwjgl.system.MemoryUtil;
import rs117.hd.HdPlugin;

public class GpuIntBuffer
{
	private IntBuffer buffer;

	public GpuIntBuffer()
	{
		this(65536);
	}

	public GpuIntBuffer(int initialCapacity) {
		try {
			buffer = MemoryUtil.memAllocInt(initialCapacity);
		} catch (OutOfMemoryError oom) {
			// Force garbage collection and try again
			System.gc();
			buffer = MemoryUtil.memAllocInt(initialCapacity);
		}
	}

	public void destroy() {
		if (buffer != null)
			MemoryUtil.memFree(buffer);
		buffer = null;
	}

	@Override
	@SuppressWarnings("deprecation")
	protected void finalize() {
		destroy();
	}

	public void put(int x, int y, int z) {
		buffer.put(x).put(y).put(z);
	}

	public void put(float x, float y, float z, int w) {
		buffer
			.put(Float.floatToIntBits(x))
			.put(Float.floatToIntBits(y))
			.put(Float.floatToIntBits(z))
			.put(w);
	}

	public void put(int[] ints) {
		buffer.put(ints);
	}

	public void put(IntBuffer buffer) {
		this.buffer.put(buffer);
	}

	public int position()
	{
		return buffer.position();
	}

	public void flip() {
		buffer.flip();
	}

	public GpuIntBuffer clear() {
		buffer.clear();
		return this;
	}

	public int capacity() {
		return buffer.capacity();
	}

	public GpuIntBuffer ensureCapacity(int size) {
		int capacity = buffer.capacity();
		final int position = buffer.position();
		if ((capacity - position) < size) {
			do {
				capacity *= HdPlugin.BUFFER_GROWTH_MULTIPLIER;
			}
			while ((capacity - position) < size);

			IntBuffer newB = MemoryUtil.memAllocInt(capacity);
			buffer.flip();
			newB.put(buffer);
			MemoryUtil.memFree(buffer);
			buffer = newB;
		}

		return this;
	}

	public IntBuffer getBuffer()
	{
		return buffer;
	}
}

/*
 * Copyright (c) 2018, Adam <Adam@sigterm.info>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package rs117.hd.utils.buffer;

import java.nio.FloatBuffer;
import org.lwjgl.system.MemoryUtil;
import rs117.hd.HdPlugin;

public class GpuFloatBuffer
{
	private FloatBuffer buffer;

	public GpuFloatBuffer()
	{
		this(65536);
	}

	public GpuFloatBuffer(int initialCapacity) {
		try {
			buffer = MemoryUtil.memAllocFloat(initialCapacity);
		} catch (OutOfMemoryError oom) {
			// Force garbage collection and try again
			System.gc();
			buffer = MemoryUtil.memAllocFloat(initialCapacity);
		}
	}

	public void destroy() {
		if (buffer != null)
			MemoryUtil.memFree(buffer);
		buffer = null;
	}

	@Override
	@SuppressWarnings("deprecation")
	protected void finalize() {
		destroy();
	}

	public void put(float x, float y, float z, float w) {
		buffer.put(x).put(y).put(z).put(w);
	}

	public void put(float[] floats) {
		buffer.put(floats);
	}

	public void put(FloatBuffer buffer) {
		this.buffer.put(buffer);
	}

	public int position()
	{
		return buffer.position();
	}

	public void flip() {
		buffer.flip();
	}

	public GpuFloatBuffer clear() {
		buffer.clear();
		return this;
	}

	public int capacity() {
		return buffer.capacity();
	}

	public void ensureCapacity(int size) {
		int capacity = buffer.capacity();
		final int position = buffer.position();
		if ((capacity - position) < size) {
			do {
				capacity *= HdPlugin.BUFFER_GROWTH_MULTIPLIER;
			}
			while ((capacity - position) < size);

			FloatBuffer newB = MemoryUtil.memAllocFloat(capacity);
			buffer.flip();
			newB.put(buffer);
			MemoryUtil.memFree(buffer);
			buffer = newB;
		}
	}

	public FloatBuffer getBuffer()
	{
		return buffer;
	}
}

/*
 * Copyright (c) 2021, Adam <Adam@sigterm.info>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package rs117.hd.utils.buffer;

public class GLBuffer
{
	public int glBufferId;
	public long clBuffer;
	public long size = -1;
}

/*
 * Copyright (c) 2021, 117 <https://twitter.com/117scape>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package rs117.hd.utils;

import java.util.HashSet;
import java.util.Random;
import javax.inject.Singleton;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.*;
import net.runelite.api.coords.*;
import rs117.hd.data.environments.Area;

import static net.runelite.api.Constants.SCENE_SIZE;
import static net.runelite.api.Constants.*;
import static net.runelite.api.Perspective.*;
import static rs117.hd.scene.ProceduralGenerator.VERTICES_PER_FACE;
import static rs117.hd.scene.ProceduralGenerator.faceLocalVertices;
import static rs117.hd.scene.ProceduralGenerator.isOverlayFace;

@Slf4j
@Singleton
public class HDUtils {
	public static final long KiB = 1024;
	public static final long MiB = KiB * KiB;
	public static final long GiB = MiB * KiB;
	public static final Random rand = new Random();

	// The epsilon for floating point values used by jogl
	public static final float EPSILON = 1.1920929E-7f;

	public static final float PI = (float) Math.PI;
	public static final float TWO_PI = PI * 2;
	public static final float HALF_PI = PI / 2;
	public static final float QUARTER_PI = PI / 2;

	public static final float MAX_FLOAT_WITH_128TH_PRECISION = 1 << 16;

	public static final int MAX_SNOW_LIGHTNESS = 70;

	// directional vectors approximately opposite of the directional light used by the client
	private static final float[] LIGHT_DIR_TILE = new float[] { 0.70710678f, 0.70710678f, 0f };

	public static float min(float... v) {
		float min = v[0];
		for (int i = 1; i < v.length; i++)
			if (v[i] < min)
				min = v[i];
		return min;
	}

	public static float max(float... v) {
		float max = v[0];
		for (int i = 1; i < v.length; i++)
			if (v[i] > max)
				max = v[i];
		return max;
	}

	public static float lerp(float a, float b, float t) {
		return a + (b - a) * t;
	}

	public static float[] lerp(float[] vecA, float[] vecB, float t) {
		float[] out = new float[Math.min(vecA.length, vecB.length)];
		for (int i = 0; i < out.length; i++)
			out[i] = lerp(vecA[i], vecB[i], t);
		return out;
	}

	static int[] lerp(int[] vecA, int[] vecB, float t) {
		int[] out = new int[Math.min(vecA.length, vecB.length)];
		for (int i = 0; i < out.length; i++)
			out[i] = (int) lerp(vecA[i], vecB[i], t);
		return out;
	}

	public static float hermite(float from, float to, float t) {
		float t2 = t * t;
		float t3 = t2 * t;
		return
			from * (1 - 3 * t2 + 2 * t3) +
			to * (3 * t2 - 2 * t3);
	}

	public static float[] hermite(float[] from, float[] to, float t) {
		float[] result = new float[from.length];
		for (int i = 0; i < result.length; i++)
			result[i] = hermite(from[i], to[i], t);
		return result;
	}

	public static double fract(double x) {
		return mod(x, 1);
	}

	public static float fract(float x) {
		return mod(x, 1);
	}

	/**
	 * Modulo that returns the answer with the same sign as the modulus.
	 */
	public static double mod(double x, double modulus) {
		return (x - Math.floor(x / modulus) * modulus);
	}

	/**
	 * Modulo that returns the answer with the same sign as the modulus.
	 */
	public static float mod(float x, float modulus) {
		return (float) (x - Math.floor(x / modulus) * modulus);
	}

	/**
	 * Modulo that returns the answer with the same sign as the modulus.
	 */
	public static int mod(int x, int modulus) {
		return ((x % modulus) + modulus) % modulus;
	}

	public static float clamp(float value, float min, float max) {
		return Math.min(Math.max(value, min), max);
	}

	public static int clamp(int value, int min, int max) {
		return Math.min(Math.max(value, min), max);
	}

	public static double log2(double x) {
		return Math.log(x) / Math.log(2);
	}

	public static int vertexHash(int[] vPos) {
		// simple custom hashing function for vertex position data
		StringBuilder s = new StringBuilder();
		for (int part : vPos)
			s.append(part).append(",");
		return s.toString().hashCode();
	}

	public static float[] calculateSurfaceNormals(float[] a, float[] b, float[] c) {
		Vector.subtract(b, a, b);
		Vector.subtract(c, a, c);
		float[] n = new float[3];
		return Vector.cross(n, b, c);
	}

	public static float dotLightDirectionTile(float x, float y, float z) {
		// Tile normal vectors need to be normalized
		float length = x * x + y * y + z * z;
		if (length < EPSILON)
			return 0;
		return (x * LIGHT_DIR_TILE[0] + y * LIGHT_DIR_TILE[1]) / (float) Math.sqrt(length);
	}

	public static long ceilPow2(long x) {
		return (long) Math.pow(2, Math.ceil(Math.log(x) / Math.log(2)));
	}

	public static float[] sunAngles(float altitude, float azimuth) {
		return new float[] { (float) Math.toRadians(altitude), (float) Math.toRadians(azimuth) };
	}

	public static int convertWallObjectOrientation(int orientation) {
		// Note: this is still imperfect, since the model rotation of a wall object depends on more than just the config orientation,
		// 		 i.e. extra rotation depending on wall type whatever. I'm not sure.
		// Derived from config orientation {@link HDUtils#getBakedOrientation}
		switch (orientation) {
			case 1: // east (config orientation = 0)
				return 512;
			case 2: // south (config orientation = 1)
				return 1024;
			case 4: // west (config orientation = 2)
				return 1536;
			case 8: // north (config orientation = 3)
			default:
				return 0;
			case 16: // south-east (config orientation = 0)
				return 768;
			case 32: // south-west (config orientation = 1)
				return 1280;
			case 64: // north-west (config orientation = 2)
				return 1792;
			case 128: // north-east (config orientation = 3)
				return 256;
		}
	}

	// (gameObject.getConfig() >> 6) & 3, // 2-bit orientation
	// (gameObject.getConfig() >> 8) & 1, // 1-bit interactType != 0 (supports items)
	// (gameObject.getConfig() & 0x3F), // 6-bit object type? (10 seems to mean movement blocker)
	// (gameObject.getConfig() >> 9) // should always be zero
	public static int getBakedOrientation(int config) {
		switch (config >> 6 & 3) {
			case 0: // Rotated 180 degrees
				return 1024;
			case 1: // Rotated 90 degrees counter-clockwise
				return 1536;
			case 2: // Not rotated
			default:
				return 0;
			case 3: // Rotated 90 degrees clockwise
				return 512;
		}
	}

	public static HashSet<Integer> getSceneRegionIds(Scene scene) {
		HashSet<Integer> regionIds = new HashSet<>();

		if (scene.isInstance()) {
			// If the center chunk is invalid, pick any valid chunk and hope for the best
			int[][][] chunks = scene.getInstanceTemplateChunks();
			for (int[][] plane : chunks) {
				for (int[] column : plane) {
					for (int chunk : column) {
						if (chunk == -1)
							continue;

						// Extract chunk coordinates
						int x = chunk >> 14 & 0x3FF;
						int y = chunk >> 3 & 0x7FF;
						regionIds.add((x >> 3) << 8 | y >> 3);
					}
				}
			}
		}
		else
		{
			int baseX = scene.getBaseX();
			int baseY = scene.getBaseY();
			for (int x = 0; x < SCENE_SIZE; x += REGION_SIZE)
				for (int y = 0; y < SCENE_SIZE; y += REGION_SIZE)
					regionIds.add((baseX + x >> 6) << 8 | baseY + y >> 6);
		}

		return regionIds;
	}

	/**
	 * Returns the south-west coordinate of the scene in world space, after resolving instance template chunks to their
	 * original world coordinates. If the scene is instanced, the base coordinates are computed from the center chunk.
	 *
	 * @param scene to get the south-west coordinate for
	 * @param plane to use when resolving instance template chunks
	 * @return the south-western coordinate of the scene in world space
	 */
	public static WorldPoint getSceneBase(Scene scene, int plane)
	{
		int baseX = scene.getBaseX();
		int baseY = scene.getBaseY();

		if (scene.isInstance())
		{
			// Assume the player is loaded into the center chunk, and calculate the world space position of the lower
			// left corner of the scene, assuming well-behaved template chunks are used to create the instance.
			int chunkX = 6, chunkY = 6;
			int chunk = scene.getInstanceTemplateChunks()[plane][chunkX][chunkY];
			if (chunk == -1)
			{
				// If the center chunk is invalid, pick any valid chunk and hope for the best
				int[][] chunks = scene.getInstanceTemplateChunks()[plane];
				outer:
				for (chunkX = 0; chunkX < chunks.length; chunkX++)
				{
					for (chunkY = 0; chunkY < chunks[chunkX].length; chunkY++)
					{
						chunk = chunks[chunkX][chunkY];
						if (chunk != -1)
						{
							break outer;
						}
					}
				}
			}

			// Extract chunk coordinates
			baseX = chunk >> 14 & 0x3FF;
			baseY = chunk >> 3 & 0x7FF;
			// Shift to what would be the lower left corner chunk if the template chunks were contiguous on the map
			baseX -= chunkX;
			baseY -= chunkY;
			// Transform to world coordinates
			baseX <<= 3;
			baseY <<= 3;
		}

		return new WorldPoint(baseX, baseY, plane);
	}

	/**
	 * The returned plane may be different, so it's not safe to use for indexing into overlay IDs for instance
	 */
	public static int[] localToWorld(Scene scene, int localX, int localY, int plane) {
		int sceneX = localX / LOCAL_TILE_SIZE;
		int sceneY = localY / LOCAL_TILE_SIZE;

		if (scene.isInstance() && sceneX >= 0 && sceneY >= 0 && sceneX < SCENE_SIZE && sceneY < SCENE_SIZE) {
			int chunkX = sceneX / 8;
			int chunkY = sceneY / 8;
			int templateChunk = scene.getInstanceTemplateChunks()[plane][chunkX][chunkY];
			int rotation = 4 - (templateChunk >> 1 & 3);
			int templateChunkY = (templateChunk >> 3 & 2047) * 8;
			int templateChunkX = (templateChunk >> 14 & 1023) * 8;
			int templateChunkPlane = templateChunk >> 24 & 3;
			int worldX = templateChunkX + (sceneX & 7);
			int worldY = templateChunkY + (sceneY & 7);

			int[] pos = { worldX, worldY, templateChunkPlane };

			chunkX = pos[0] & -8;
			chunkY = pos[1] & -8;
			int x = pos[0] & 7;
			int y = pos[1] & 7;
			switch (rotation) {
				case 1:
					pos[0] = chunkX + y;
					pos[1] = chunkY + (7 - x);
					break;
				case 2:
					pos[0] = chunkX + (7 - x);
					pos[1] = chunkY + (7 - y);
					break;
				case 3:
					pos[0] = chunkX + (7 - y);
					pos[1] = chunkY + x;
					break;
			}

			return pos;
		}

		return new int[] { scene.getBaseX() + sceneX, scene.getBaseY() + sceneY, plane };
	}

	public static int worldToRegionID(int[] worldPoint) {
		return worldToRegionID(worldPoint[0], worldPoint[1]);
	}

	public static int worldToRegionID(int worldX, int worldY) {
		return worldX >> 6 << 8 | worldY >> 6;
	}

	public static boolean is32Bit() {
		return System.getProperty("sun.arch.data.model", "Unknown").equals("32");
	}

	public static boolean sceneIntersects(Scene scene, int numChunksExtended, Area area) {
		return sceneIntersects(scene, numChunksExtended, area.aabbs);
	}

	public static boolean sceneIntersects(Scene scene, int numChunksExtended, AABB... aabbs) {
		if (scene.isInstance()) {
			var templateChunks = scene.getInstanceTemplateChunks();
			for (var plane : templateChunks) {
				for (var column : plane) {
					for (int chunk : column) {
						if (chunk == -1)
							continue;

						int chunkX = chunk >> 14 & 1023;
						int chunkY = chunk >> 3 & 2047;
						int minX = chunkX * CHUNK_SIZE;
						int minY = chunkY * CHUNK_SIZE;
						int maxX = (chunkX + 1) * CHUNK_SIZE - 1;
						int maxY = (chunkY + 1) * CHUNK_SIZE - 1;

						for (var aabb : aabbs)
							if (aabb.intersects(minX, minY, maxX, maxY))
								return true;
					}
				}
			}
		} else {
			int baseX = scene.getBaseX();
			int baseY = scene.getBaseX();
			int extended = numChunksExtended * CHUNK_SIZE;
			AABB sceneAabb = new AABB(
				baseX - extended,
				baseY - extended,
				baseX + SCENE_SIZE + extended - 1,
				baseY + SCENE_SIZE + extended - 1
			);

			for (var aabb : aabbs)
				if (sceneAabb.intersects(aabb))
					return true;
		}

		return false;
	}

	public static void getSouthWesternMostTileColor(int[] out, Tile tile) {
		var paint = tile.getSceneTilePaint();
		var model = tile.getSceneTileModel();
		if (paint != null) {
			ColorUtils.unpackRawHsl(out, paint.getSwColor());
		} else if (model != null) {
			int faceCount = tile.getSceneTileModel().getFaceX().length;
			final int[] faceColorsA = model.getTriangleColorA();
			final int[] faceColorsB = model.getTriangleColorB();
			final int[] faceColorsC = model.getTriangleColorC();

			int hsl = 0;
			outer:
			for (int face = 0; face < faceCount; face++) {
				if (isOverlayFace(tile, face))
					continue;

				int[][] vertices = faceLocalVertices(tile, face);
				int[] faceColors = new int[] { faceColorsA[face], faceColorsB[face], faceColorsC[face] };

				for (int vertex = 0; vertex < VERTICES_PER_FACE; vertex++) {
					hsl = faceColors[vertex];
					if (vertices[vertex][0] != LOCAL_TILE_SIZE && vertices[vertex][1] != LOCAL_TILE_SIZE)
						break outer;
				}
			}

			ColorUtils.unpackRawHsl(out, hsl);
		}
	}
}

package rs117.hd.utils;

import java.awt.BorderLayout;
import java.awt.Desktop;
import java.awt.FlowLayout;
import java.awt.Image;
import java.awt.Point;
import java.awt.image.BufferedImage;
import java.io.IOException;
import java.net.URISyntaxException;
import java.util.function.Function;
import javax.swing.BorderFactory;
import javax.swing.ImageIcon;
import javax.swing.JButton;
import javax.swing.JEditorPane;
import javax.swing.JFrame;
import javax.swing.JLabel;
import javax.swing.JPanel;
import javax.swing.JScrollPane;
import javax.swing.ScrollPaneConstants;
import javax.swing.SwingUtilities;
import javax.swing.event.HyperlinkEvent;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.*;
import rs117.hd.HdPlugin;

import static rs117.hd.utils.ResourcePath.path;

@Slf4j
public class PopupUtils {
	public static void displayPopupMessage(
		Client client,
		String title,
		String message,
		String[] buttonLabels,
		Function<Integer, Boolean> buttonIndexConsumer
	) {
		SwingUtilities.invokeLater(() -> {
			JFrame frame = new JFrame(title);

			JPanel mainPanel = new JPanel(new BorderLayout());
			mainPanel.setBorder(BorderFactory.createEmptyBorder(16, 0, 8, 8));

			try {
				BufferedImage logoImage = path(HdPlugin.class, "logo.png").loadImage();
				frame.setIconImage(logoImage);
				Image logoScaled = logoImage.getScaledInstance(96, -1, Image.SCALE_SMOOTH);
				JLabel logoLabel = new JLabel(new ImageIcon(logoScaled));
				logoLabel.setBorder(BorderFactory.createEmptyBorder(0, 8, 0, 8));
				mainPanel.add(logoLabel, BorderLayout.LINE_START);
			} catch (IOException ex) {
				log.error("Unable to load HD logo: ", ex);
			}

			String html = String.format("<html><style>a { color: #dc8a00; }</style><body>%s</body></html>", message);
			JEditorPane messagePane = new JEditorPane("text/html", html);
			messagePane.setBorder(BorderFactory.createEmptyBorder());
			messagePane.setHighlighter(null);
			messagePane.setEditable(false);
			messagePane.setOpaque(false);
			messagePane.addHyperlinkListener(e -> {
				if (Desktop.isDesktopSupported() && e.getEventType().equals(HyperlinkEvent.EventType.ACTIVATED)) {
					try {
						Desktop.getDesktop().browse(e.getURL().toURI());
					} catch (IOException | URISyntaxException ex) {
						log.error("Unable to open link: {}", e.getURL().toString(), ex);
					}
                }
            });

			JScrollPane scrollPane = new JScrollPane(messagePane);
            scrollPane.setViewportBorder(BorderFactory.createEmptyBorder());
            scrollPane.setBorder(BorderFactory.createEmptyBorder());
			scrollPane.setOpaque(false);
			scrollPane.getViewport().setOpaque(false);
			scrollPane.setVerticalScrollBarPolicy(ScrollPaneConstants.VERTICAL_SCROLLBAR_AS_NEEDED);
			scrollPane.setHorizontalScrollBarPolicy(ScrollPaneConstants.HORIZONTAL_SCROLLBAR_NEVER);
			mainPanel.add(scrollPane, BorderLayout.CENTER);

            JPanel buttonPanel = new JPanel(new FlowLayout(FlowLayout.RIGHT, 8, 8));
            for (int i = 0; i < buttonLabels.length; i++) {
                JButton button = new JButton(buttonLabels[i]);
                int index = i;
				button.addActionListener(actionEvent -> {
					if (buttonIndexConsumer.apply(index))
						frame.setVisible(false);
				});
				buttonPanel.add(button);
            }

            JPanel framePanel = new JPanel(new BorderLayout());
            framePanel.add(mainPanel, BorderLayout.CENTER);
            framePanel.add(buttonPanel, BorderLayout.PAGE_END);

            frame.setContentPane(framePanel);
            frame.pack();
            frame.setResizable(false);

            frame.setLocationRelativeTo(client.getCanvas());
            Point point = frame.getLocation();
            frame.setLocation(point.x + 5, point.y + (Constants.GAME_FIXED_HEIGHT - client.getCanvasHeight()) / 2 - 3);
            frame.setAutoRequestFocus(true);

            JFrame runeLiteWindow = (JFrame) SwingUtilities.getWindowAncestor(client.getCanvas());
            if (runeLiteWindow.isAlwaysOnTop())
                frame.setAlwaysOnTop(true);

            frame.setVisible(true);
        });
    }
}

/*
 * Copyright (c) 2022, Hooder <ahooder@protonmail.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package rs117.hd.utils;

import com.google.common.collect.ArrayListMultimap;
import com.google.common.collect.ListMultimap;
import java.io.File;
import java.io.IOException;
import java.nio.file.ClosedWatchServiceException;
import java.nio.file.FileSystems;
import java.nio.file.FileVisitResult;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.SimpleFileVisitor;
import java.nio.file.WatchEvent;
import java.nio.file.WatchKey;
import java.nio.file.WatchService;
import java.nio.file.attribute.BasicFileAttributes;
import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.DelayQueue;
import java.util.concurrent.Delayed;
import java.util.concurrent.TimeUnit;
import java.util.function.Consumer;
import lombok.AllArgsConstructor;
import lombok.NonNull;
import lombok.extern.slf4j.Slf4j;

import static java.nio.file.StandardWatchEventKinds.ENTRY_CREATE;
import static java.nio.file.StandardWatchEventKinds.ENTRY_DELETE;
import static java.nio.file.StandardWatchEventKinds.ENTRY_MODIFY;
import static java.nio.file.StandardWatchEventKinds.OVERFLOW;
import static rs117.hd.utils.ResourcePath.path;

@Slf4j
public class FileWatcher {
	private static final WatchEvent.Kind<?>[] eventKinds = { ENTRY_CREATE, ENTRY_DELETE, ENTRY_MODIFY };

	private static Thread watcherThread;
	private static Thread runnerThread;
	private static WatchService watchService;
	private static final HashMap<WatchKey, Path> watchKeys = new HashMap<>();
	private static final ListMultimap<String, Consumer<ResourcePath>> changeHandlers = ArrayListMultimap.create();
	private static final DelayQueue<PendingChange> pendingChanges = new DelayQueue<>();

	@AllArgsConstructor
	private static class PendingChange implements Delayed {
		final ResourcePath path;
		final Consumer<ResourcePath> handler;
		long delayUntilMillis;

		@Override
		public boolean equals(Object obj) {
			return
				obj instanceof PendingChange &&
				path.equals(((PendingChange) obj).path) &&
				handler.equals(((PendingChange) obj).handler);
		}

		@Override
		public long getDelay(TimeUnit timeUnit) {
			return timeUnit.convert(delayUntilMillis - System.currentTimeMillis(), TimeUnit.MILLISECONDS);
		}

		@Override
		public int compareTo(Delayed delayed) {
			return (int) (getDelay(TimeUnit.MILLISECONDS) - delayed.getDelay(TimeUnit.MILLISECONDS));
		}
	}

	private static void initialize() throws IOException {
		watchService = FileSystems.getDefault().newWatchService();
		watcherThread = new Thread(() -> {
			try {
				WatchKey watchKey;
				while ((watchKey = watchService.take()) != null) {
					Path dir = watchKeys.get(watchKey);
					if (dir == null) {
						log.error("Unknown WatchKey: " + watchKey);
						continue;
					}
					for (WatchEvent<?> event : watchKey.pollEvents()) {
						if (event.kind() == OVERFLOW)
							continue;

						Path path = dir.resolve((Path) event.context());
						if (path.toString().endsWith("~")) // Ignore temp files
							continue;

						log.trace("WatchEvent of kind {} for path {}", event.kind(), path);

						try {
							// Manually register new sub folders if not watching a file tree
							if (event.kind() == ENTRY_CREATE && path.toFile().isDirectory())
								watchRecursively(path);

							String key = path.toString();
							ResourcePath resourcePath = path(key);
							if (path.toFile().isDirectory())
								key += File.separator;

							for (Map.Entry<String, Consumer<ResourcePath>> entry : changeHandlers.entries())
								if (key.startsWith(entry.getKey()))
									queuePendingChange(resourcePath, entry.getValue());
						} catch (Exception ex) {
							log.error("Error while handling file change event:", ex);
						}
					}
					watchKey.reset();
				}
			} catch (ClosedWatchServiceException ignored) {
			} catch (InterruptedException ex) {
				log.error("Watcher thread interrupted", ex);
			}
		}, FileWatcher.class.getSimpleName() + " Watcher");
		watcherThread.setDaemon(true);
		watcherThread.start();

		runnerThread = new Thread(() -> {
			try {
				PendingChange pending;
				while ((pending = pendingChanges.poll(100, TimeUnit.DAYS)) != null) {
					try {
						pending.handler.accept(pending.path);
					} catch (Throwable throwable) {
						log.error("Error in change handler for path: {}", pending.path, throwable);
					}
				}
			} catch (InterruptedException ignored) {
			}
		}, FileWatcher.class.getSimpleName() + " Runner");
		runnerThread.setDaemon(true);
		runnerThread.start();
	}

	private static void queuePendingChange(ResourcePath path, Consumer<ResourcePath> handler) {
		var pendingChange = new PendingChange(path, handler, System.currentTimeMillis() + 200);
		var ignored = pendingChanges.remove(pendingChange);
		pendingChanges.add(pendingChange);
	}

	public static void destroy() {
		if (watchService == null)
			return;

		try {
			log.debug("Shutting down {}", FileWatcher.class.getSimpleName());
			changeHandlers.clear();
			watchKeys.clear();
			watchService.close();
			watchService = null;
			if (watcherThread.isAlive())
				watcherThread.join();
			runnerThread.interrupt();
			if (runnerThread.isAlive())
				runnerThread.join();
		} catch (IOException | InterruptedException ex) {
			throw new RuntimeException("Error while closing " + FileWatcher.class.getSimpleName(), ex);
		}
	}

	@FunctionalInterface
	public interface UnregisterCallback {
		void unregister();
	}

	public static UnregisterCallback watchPath(@NonNull ResourcePath resourcePath, @NonNull Consumer<ResourcePath> changeHandler)
	{
		if (!resourcePath.isFileSystemResource())
			throw new IllegalStateException("Only resources on the file system can be watched: " + resourcePath);

		try {
			if (watchService == null)
				initialize();

			Path path = resourcePath.toPath();

			final String key;
			final Consumer<ResourcePath> handler;
			if (path.toFile().isDirectory()) {
				watchRecursively(path);
				key = path + File.separator;
				handler = changeHandler;
			} else {
				watchFile(path);
				key = path.toString();
				handler = changed -> {
					try {
						if (Files.isSameFile(changed.toPath(), resourcePath.toPath()))
							changeHandler.accept(changed);
					} catch (IOException ex) {
						throw new RuntimeException(ex);
					}
				};
			}

			changeHandlers.put(key, handler);
			return () -> changeHandlers.remove(key, handler);
		} catch (IOException ex) {
			throw new RuntimeException("Failed to initialize " + FileWatcher.class.getSimpleName(), ex);
		}
	}

	private static void watchFile(Path path) {
		Path dir = path.getParent();
		try {
			watchKeys.put(dir.register(watchService, eventKinds), dir);
			log.debug("Watching {}", path);
		} catch (Exception ex) {
			throw new RuntimeException("Failed to register file watcher for path: " + path, ex);
		}
	}

	private static void watchRecursively(Path path) {
		try {
			log.debug("Watching {}", path);
			Files.walkFileTree(path, new SimpleFileVisitor<>() {
				@Override
				public FileVisitResult preVisitDirectory(Path dir, BasicFileAttributes attrs) throws IOException {
					WatchKey key = dir.register(watchService, eventKinds);
					watchKeys.put(key, dir);
					return FileVisitResult.CONTINUE;
				}
			});
		} catch (Exception ex) {
			throw new RuntimeException("Failed to register recursive file watcher for path: " + path, ex);
		}
	}
}

package rs117.hd.utils;

import javax.annotation.Nullable;
import net.runelite.api.*;

import static rs117.hd.utils.HDUtils.clamp;

public class ModelHash {
	// Model hashes are composed as follows:
	// | 1111 1111 1111 1 |    11 | 1  1111 1111 1111 1111 1111 1111 1111 111 |               1 |   11 |    11 1111 1 |     111 1111 |
	// |   13 unused bits | plane |                        32-bit id or index | right-clickable | type | 7-bit sceneY | 7-bit sceneX |
	//
	// type:
	// - 0 = player
	// - 1 = NPC
	// - 2 = object
	// - 3 = ground item
	//
	// id_or_index for different types:
	// - player = index
	// - NPC = index
	// - object = id
	// - ground item = always zero

	public static final int TYPE_PLAYER = 0;
	public static final int TYPE_NPC = 1;
	public static final int TYPE_OBJECT = 2;
	public static final int TYPE_GROUND_ITEM = 3;
	// 117 HD custom types
	public static final int TYPE_PROJECTILE = 4;
	public static final int TYPE_GRAPHICS_OBJECT = 5;
	public static final int TYPE_UNKNOWN = 0xF;

	public static final int UNKNOWN_ID = 0xFFFFFF;

	public static final long SCENE_X_MASK = 0x7f;
	public static final long SCENE_Y_MASK = 0x7f << 7;
	public static final long TYPE_MASK = 3L << 14;
	public static final long ID_OR_INDEX_MASK = 0xffffffffL << 17;

	private static final String[] TYPE_NAMES = {
		"Player",
		"NPC",
		"Game Object",
		"Ground item",
		"Projectile",
		"Graphics object",
		"Unknown"
	};
	private static final String[] TYPE_NAMES_SHORT = {
		"PLR",
		"NPC",
		"OBJ",
		"ITM",
		"PRJ",
		"GFX",
		"N/A"
	};

	public static String getTypeName(int type) {
		return TYPE_NAMES[clamp(type, 0, TYPE_NAMES.length - 1)];
	}

	public static String getTypeNameShort(int type) {
		return TYPE_NAMES_SHORT[clamp(type, 0, TYPE_NAMES_SHORT.length - 1)];
	}

	public static long pack(int idOrIndex, boolean rightClickable, int type, int sceneY, int sceneX) {
		return
			(idOrIndex & 0xffffffffL) << 17
			| (rightClickable ? 1L : 0L) << 16
			| ((long) type & 0x3) << 14
			| (sceneY & 0x7f) << 7
			| (sceneX & 0x7f);
	}

	public static int getSceneX(long hash) {
		return (int) (hash & SCENE_X_MASK);
	}

	public static int getSceneY(long hash) {
		return (int) ((hash & SCENE_Y_MASK) >> 7);
	}

	public static int getPlane(long hash) {
		return (int) ((hash >> TileObject.HASH_PLANE_SHIFT) & 3);
	}

	public static int getType(long hash) {
		return (int) ((hash & TYPE_MASK) >> 14);
	}

	public static int getIdOrIndex(long hash) {
		return (int) ((hash & ID_OR_INDEX_MASK) >>> 17);
	}

	/**
	 * Generate an identifier of a Renderable, consisting of the type and ID.
	 *
	 * @param client     RuneLite client instance
	 * @param hash       RuneLite draw call hash
	 * @param renderable the Renderable passed into the draw callback
	 * @return a combined identifier
	 */
	public static int generateUuid(Client client, long hash, @Nullable Renderable renderable) {
		int type = TYPE_UNKNOWN;
		int id = UNKNOWN_ID;

		if (hash == -1) {
			if (renderable instanceof Projectile) {
				type = TYPE_PROJECTILE;
				id = ((Projectile) renderable).getId();
			} else if (renderable instanceof GraphicsObject) {
				type = TYPE_GRAPHICS_OBJECT;
				id = ((GraphicsObject) renderable).getId();
			}
		} else {
			type = ModelHash.getType(hash);
			id = ModelHash.getIdOrIndex(hash);

			if (renderable instanceof DynamicObject) {
				var def = client.getObjectDefinition(id);
				if (def.getImpostorIds() != null) {
					var impostor = def.getImpostor();
					if (impostor != null)
						id = impostor.getId();
				}
			} else if (type == TYPE_NPC) {
				int index = id;
				id = UNKNOWN_ID;
				var npcs = client.getTopLevelWorldView().npcs();
				if (index >= 0 && index < 65536) {
					NPC npc = npcs.byIndex(index);
					if (npc != null)
						id = npc.getId();
				}
			}
		}

		return packUuid(type, id);
	}

	/**
	 * Pack a type ID and object/NPC/projectile/other ID into an int for use with 117 HD functions.
	 *
	 * @param type ModelHash type ID
	 * @param id   object/NPC/projectile/other ID
	 * @return a combined identifier
	 */
	public static int packUuid(int type, int id) {
		return type << 24 | id;
	}

	public static int getUuidType(int uuid) {
		return uuid >> 24;
	}

	public static int getUuidId(int uuid) {
		return uuid & 0xFFFFFF;
	}
}

package rs117.hd.utils;

import java.awt.event.InputEvent;
import java.awt.event.KeyEvent;
import javax.inject.Inject;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.events.*;
import net.runelite.client.config.Keybind;
import net.runelite.client.eventbus.EventBus;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.input.KeyListener;
import net.runelite.client.input.KeyManager;
import rs117.hd.HdPlugin;
import rs117.hd.data.environments.Area;
import rs117.hd.overlays.FrameTimerOverlay;
import rs117.hd.overlays.LightGizmoOverlay;
import rs117.hd.overlays.ShadowMapOverlay;
import rs117.hd.overlays.TileInfoOverlay;

@Slf4j
public class DeveloperTools implements KeyListener {
	// This could be part of the config if we had developer mode config sections
	private static final Keybind KEY_TOGGLE_TILE_INFO = new Keybind(KeyEvent.VK_F3, InputEvent.CTRL_DOWN_MASK);
	private static final Keybind KEY_TOGGLE_FRAME_TIMINGS = new Keybind(KeyEvent.VK_F4, InputEvent.CTRL_DOWN_MASK);
	private static final Keybind KEY_TOGGLE_SHADOW_MAP_OVERLAY = new Keybind(KeyEvent.VK_F5, InputEvent.CTRL_DOWN_MASK);
	private static final Keybind KEY_TOGGLE_LIGHT_GIZMO_OVERLAY = new Keybind(KeyEvent.VK_F6, InputEvent.CTRL_DOWN_MASK);
	private static final Keybind KEY_TOGGLE_FREEZE_FRAME = new Keybind(KeyEvent.VK_ESCAPE, InputEvent.SHIFT_DOWN_MASK);

	@Inject
	private EventBus eventBus;

	@Inject
	private KeyManager keyManager;

	@Inject
	private HdPlugin plugin;

	@Inject
	private TileInfoOverlay tileInfoOverlay;

	@Inject
	private FrameTimerOverlay frameTimerOverlay;

	@Inject
	private ShadowMapOverlay shadowMapOverlay;

	@Inject
	private LightGizmoOverlay lightGizmoOverlay;

	private boolean keyBindingsEnabled = false;
	private boolean tileInfoOverlayEnabled = false;
	private boolean frameTimingsOverlayEnabled = false;
	private boolean shadowMapOverlayEnabled = false;
	private boolean lightGizmoOverlayEnabled = false;

	public void activate() {
		// Listen for commands
		eventBus.register(this);

		// Don't do anything else unless we're in the development environment
		if (!Props.DEVELOPMENT)
			return;

		// Enable 117 HD's keybindings by default during development
		keyBindingsEnabled = true;
		keyManager.registerKeyListener(this);

		tileInfoOverlay.setActive(tileInfoOverlayEnabled);
		frameTimerOverlay.setActive(frameTimingsOverlayEnabled);
		shadowMapOverlay.setActive(shadowMapOverlayEnabled);
		lightGizmoOverlay.setActive(lightGizmoOverlayEnabled);

		// Check for any out of bounds areas
		for (Area area : Area.values()) {
			if (area == Area.ALL || area == Area.NONE)
				continue;

			for (AABB aabb : area.aabbs) {
				if (aabb.minX < -128 || aabb.minY < 1000 || aabb.maxX > 5000 || aabb.maxY > 13000) {
					throw new IllegalArgumentException(
						"Your definition for the area " + area + " has an incorrect AABB: " + aabb);
				}
			}
		}
	}

	public void deactivate() {
		eventBus.unregister(this);
		keyManager.unregisterKeyListener(this);
		tileInfoOverlay.setActive(false);
		frameTimerOverlay.setActive(false);
		shadowMapOverlay.setActive(false);
		lightGizmoOverlay.setActive(false);
	}

	@Subscribe
	public void onCommandExecuted(CommandExecuted commandExecuted) {
		if (!commandExecuted.getCommand().equalsIgnoreCase("117hd"))
			return;

		String[] args = commandExecuted.getArguments();
		if (args.length < 1)
			return;

		String action = args[0].toLowerCase();
		switch (action) {
			case "tileinfo":
				tileInfoOverlay.setActive(tileInfoOverlayEnabled = !tileInfoOverlayEnabled);
				break;
			case "timers":
				frameTimerOverlay.setActive(frameTimingsOverlayEnabled = !frameTimingsOverlayEnabled);
				break;
			case "shadowmap":
				shadowMapOverlay.setActive(shadowMapOverlayEnabled = !shadowMapOverlayEnabled);
				break;
			case "lights":
				lightGizmoOverlay.setActive(lightGizmoOverlayEnabled = !lightGizmoOverlayEnabled);
				break;
			case "keybindings":
				keyBindingsEnabled = !keyBindingsEnabled;
				if (keyBindingsEnabled) {
					keyManager.registerKeyListener(this);
				} else {
					keyManager.unregisterKeyListener(this);
				}
				break;
		}
	}

	@Override
	public void keyPressed(KeyEvent e) {
		if (KEY_TOGGLE_TILE_INFO.matches(e)) {
			tileInfoOverlay.setActive(tileInfoOverlayEnabled = !tileInfoOverlayEnabled);
		} else if (KEY_TOGGLE_FRAME_TIMINGS.matches(e)) {
			frameTimerOverlay.setActive(frameTimingsOverlayEnabled = !frameTimingsOverlayEnabled);
		} else if (KEY_TOGGLE_SHADOW_MAP_OVERLAY.matches(e)) {
			shadowMapOverlay.setActive(shadowMapOverlayEnabled = !shadowMapOverlayEnabled);
		} else if (KEY_TOGGLE_LIGHT_GIZMO_OVERLAY.matches(e)) {
			lightGizmoOverlay.setActive(lightGizmoOverlayEnabled = !lightGizmoOverlayEnabled);
		} else if (KEY_TOGGLE_FREEZE_FRAME.matches(e)) {
			plugin.toggleFreezeFrame();
		} else {
			return;
		}
		e.consume();
	}

	@Override
	public void keyReleased(KeyEvent event) {}

	@Override
	public void keyTyped(KeyEvent event) {}
}

/*
 * Copyright (c) 2022 Abex
 * Copyright 2010 JogAmp Community.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package rs117.hd.utils;

public class Mat4
{
	/**
	 * Utility class for working with column-major 4 x 4 matrices.
	 */

	public static float[] identity()
	{
		return new float[]
			{
				1, 0, 0, 0,
				0, 1, 0, 0,
				0, 0, 1, 0,
				0, 0, 0, 1,
			};
	}

	public static float[] scale(float sx, float sy, float sz)
	{
		return new float[]
			{
				sx, 0, 0, 0,
				0, sy, 0, 0,
				0, 0, sz, 0,
				0, 0, 0, 1,
			};
	}

	public static float[] translate(float tx, float ty, float tz)
	{
		return new float[]
			{
				1, 0, 0, 0,
				0, 1, 0, 0,
				0, 0, 1, 0,
				tx, ty, tz, 1,
			};
	}

	public static float[] rotateX(float rx)
	{
		float s = (float) Math.sin(rx);
		float c = (float) Math.cos(rx);

		return new float[]
			{
				1, 0, 0, 0,
				0, c, s, 0,
				0, -s, c, 0,
				0, 0, 0, 1,
			};
	}

	public static float[] rotateY(float ry)
	{
		float s = (float) Math.sin(ry);
		float c = (float) Math.cos(ry);

		return new float[]
			{
				c, 0, -s, 0,
				0, 1, 0, 0,
				s, 0, c, 0,
				0, 0, 0, 1,
			};
	}

	public static float[] projection(float w, float h, float n) {
		// Flip Y so positive is up, and reverse depth from 1 at the near plane to 0 infinitely far away
		return new float[]
			{
				2 / w, 0, 0, 0,
				0, -2 / h, 0, 0,
				0, 0, 0, 1,
				0, 0, 2 * n, 0
			};
	}

	public static float[] ortho(float w, float h, float n)
	{
		return new float[]
			{
				2 / w, 0, 0, 0,
				0, 2 / h, 0, 0,
				0, 0, -2 / n, 0,
				0, 0, 0, 1
			};
	}

	/**
	 * Multiplies matrices a and b, storing the result in matrix a.
	 *
	 * @param a column-major 4x4 matrix
	 * @param b column-major 4x4 matrix
	 */
	@SuppressWarnings("PointlessArithmeticExpression")
	public static void mul(float[] a, float[] b)
	{
		final float b00 = b[0 + 0 * 4];
		final float b10 = b[1 + 0 * 4];
		final float b20 = b[2 + 0 * 4];
		final float b30 = b[3 + 0 * 4];
		final float b01 = b[0 + 1 * 4];
		final float b11 = b[1 + 1 * 4];
		final float b21 = b[2 + 1 * 4];
		final float b31 = b[3 + 1 * 4];
		final float b02 = b[0 + 2 * 4];
		final float b12 = b[1 + 2 * 4];
		final float b22 = b[2 + 2 * 4];
		final float b32 = b[3 + 2 * 4];
		final float b03 = b[0 + 3 * 4];
		final float b13 = b[1 + 3 * 4];
		final float b23 = b[2 + 3 * 4];
		final float b33 = b[3 + 3 * 4];

		float ai0 = a[0 * 4]; // row-0 of a
		float ai1 = a[1 * 4];
		float ai2 = a[2 * 4];
		float ai3 = a[3 * 4];
		a[0 * 4] = ai0 * b00 + ai1 * b10 + ai2 * b20 + ai3 * b30;
		a[1 * 4] = ai0 * b01 + ai1 * b11 + ai2 * b21 + ai3 * b31;
		a[2 * 4] = ai0 * b02 + ai1 * b12 + ai2 * b22 + ai3 * b32;
		a[3 * 4] = ai0 * b03 + ai1 * b13 + ai2 * b23 + ai3 * b33;

		ai0 = a[1 + 0 * 4]; // row-1 of a
		ai1 = a[1 + 1 * 4];
		ai2 = a[1 + 2 * 4];
		ai3 = a[1 + 3 * 4];
		a[1 + 0 * 4] = ai0 * b00 + ai1 * b10 + ai2 * b20 + ai3 * b30;
		a[1 + 1 * 4] = ai0 * b01 + ai1 * b11 + ai2 * b21 + ai3 * b31;
		a[1 + 2 * 4] = ai0 * b02 + ai1 * b12 + ai2 * b22 + ai3 * b32;
		a[1 + 3 * 4] = ai0 * b03 + ai1 * b13 + ai2 * b23 + ai3 * b33;

		ai0 = a[2 + 0 * 4]; // row-2 of a
		ai1 = a[2 + 1 * 4];
		ai2 = a[2 + 2 * 4];
		ai3 = a[2 + 3 * 4];
		a[2 + 0 * 4] = ai0 * b00 + ai1 * b10 + ai2 * b20 + ai3 * b30;
		a[2 + 1 * 4] = ai0 * b01 + ai1 * b11 + ai2 * b21 + ai3 * b31;
		a[2 + 2 * 4] = ai0 * b02 + ai1 * b12 + ai2 * b22 + ai3 * b32;
		a[2 + 3 * 4] = ai0 * b03 + ai1 * b13 + ai2 * b23 + ai3 * b33;

		ai0 = a[3 + 0 * 4]; // row-3 of a
		ai1 = a[3 + 1 * 4];
		ai2 = a[3 + 2 * 4];
		ai3 = a[3 + 3 * 4];
		a[3 + 0 * 4] = ai0 * b00 + ai1 * b10 + ai2 * b20 + ai3 * b30;
		a[3 + 1 * 4] = ai0 * b01 + ai1 * b11 + ai2 * b21 + ai3 * b31;
		a[3 + 2 * 4] = ai0 * b02 + ai1 * b12 + ai2 * b22 + ai3 * b32;
		a[3 + 3 * 4] = ai0 * b03 + ai1 * b13 + ai2 * b23 + ai3 * b33;
	}

	/**
	 * Multiplies a 4x4 matrix with a 4x1 vector, storing the result in the output vector.
	 *
	 * @param out  where the result should be stored
	 * @param mat4 4x4 column-major matrix
	 * @param vec4 4x1 vector
	 */
	@SuppressWarnings("PointlessArithmeticExpression")
	public static void mulVec(float[] out, float[] mat4, float[] vec4) {
		float a =
			mat4[0 * 4 + 0] * vec4[0] +
			mat4[1 * 4 + 0] * vec4[1] +
			mat4[2 * 4 + 0] * vec4[2] +
			mat4[3 * 4 + 0] * vec4[3];
		float b =
			mat4[0 * 4 + 1] * vec4[0] +
			mat4[1 * 4 + 1] * vec4[1] +
			mat4[2 * 4 + 1] * vec4[2] +
			mat4[3 * 4 + 1] * vec4[3];
		float c =
			mat4[0 * 4 + 2] * vec4[0] +
			mat4[1 * 4 + 2] * vec4[1] +
			mat4[2 * 4 + 2] * vec4[2] +
			mat4[3 * 4 + 2] * vec4[3];
		float d =
			mat4[0 * 4 + 3] * vec4[0] +
			mat4[1 * 4 + 3] * vec4[1] +
			mat4[2 * 4 + 3] * vec4[2] +
			mat4[3 * 4 + 3] * vec4[3];
		out[0] = a;
		out[1] = b;
		out[2] = c;
		out[3] = d;
	}

	/**
	 * Transforms the vector by the matrix, and does a perspective divide.
	 *
	 * @param out  where the result should be stored
	 * @param mat4 4x4 column-major matrix
	 * @param vec4 4x1 vector
	 */
	public static void projectVec(float[] out, float[] mat4, float[] vec4) {
		mulVec(out, mat4, vec4);
		if (out[3] != 0) {
			// The 4th component should retain information about whether the
			// point lies behind the camera
			float reciprocal = 1 / Math.abs(out[3]);
			for (int i = 0; i < 4; i++)
				out[i] *= reciprocal;
		}
	}

	public static void transpose(float[] m) {
		for (int i = 0; i < 4; i++) {
			for (int j = i + 1; j < 4; j++) {
				int a = i * 4 + j;
				int b = j * 4 + i;
				float temp = m[a];
				m[a] = m[b];
				m[b] = temp;
			}
		}
	}

	public static float[] inverse(float[] m) {
		float[] augmented = new float[32];
		System.arraycopy(m, 0, augmented, 0, 16);
		for (int i = 0; i < 4; i++)
			augmented[16 + i * 5] = 1;

		Matrix.solve(augmented, 4, 8);

		float[] inverse = new float[16];
		System.arraycopy(augmented, 16, inverse, 0, 16);
		return inverse;
	}

	public static void extractRow(float[] out, float[] mat4, int rowIndex) {
		System.arraycopy(mat4, 4 * rowIndex, out, 0, out.length);
	}

	public static void extractColumn(float[] out, float[] mat4, int columnIndex) {
		for (int i = 0; i < out.length; i++)
			out[i] = mat4[4 * i + columnIndex];
	}

	public static String format(float[] m) {
		assert m.length == 16;
		return Matrix.format(m, 4, 4);
	}

}

package rs117.hd.utils;

import java.util.Collections;
import java.util.HashSet;
import java.util.Map;
import java.util.function.Function;
import java.util.function.Predicate;
import javax.annotation.Nonnull;
import javax.annotation.Nullable;
import lombok.AllArgsConstructor;
import lombok.RequiredArgsConstructor;

public class ExpressionParser {
	public static Predicate<VariableSupplier> parsePredicate(String expression) {
		return parsePredicate(expression, null);
	}

	public static Predicate<VariableSupplier> parsePredicate(String expression, @Nullable Map<String, Object> constants) {
		return asExpression(parseExpression(expression, constants)).toPredicate();
	}

	public static Function<VariableSupplier, Object> parseFunction(String expression) {
		return parseFunction(expression, null);
	}

	public static Function<VariableSupplier, Object> parseFunction(String expression, @Nullable Map<String, Object> constants) {
		return asFunction(parseExpression(expression, constants));
	}

	public static Object parseExpression(String expression) {
		return parseExpression(expression, null);
	}

	public static Object parseExpression(String expression, @Nullable Map<String, Object> constants) {
		return asExpression(parseExpression(expression, 0, expression.length()))
			.simplify(constants == null ? Collections.emptyMap() : constants);
	}

	public static Expression asExpression(Object object) {
		if (object instanceof Expression)
			return (Expression) object;
		return new Expression(object);
	}

	static Function<VariableSupplier, Object> asFunction(Object object) {
		if (object instanceof Expression)
			return ((Expression) object).toFunction();
		if (object instanceof String)
			return vars -> vars.get((String) object);
		return vars -> object;
	}

	public static class SyntaxError extends IllegalArgumentException {
		SyntaxError(ParserContext ctx, String message) {
			super(
				"Error at index " + ctx.index + " while parsing " +
				(ctx.op == null ? "expression" : "operator '" + ctx.op + "' in") +
				" '" + ctx.expr + "': " + message
			);
		}
	}

	@RequiredArgsConstructor
	private enum Operator {
		MOD("%", 6, 2),
		MUL("*", 6, 2),
		DIV("/", 6, 2),
		ADD("+", 5, 2),
		SUB("-", 5, 2),
		LEQUAL("<=", 4, 2),
		LESS("<", 4, 2),
		GEQUAL(">=", 4, 2),
		GREATER(">", 4, 2),
		NOTEQUAL("!=", 3, 2),
		NOT("!", 7, 1),
		EQUAL("==", 3, 2),
		AND("&&", 2, 2),
		OR("||", 1, 2),
		TERNARY("?", 0, 3);

		final String symbol;
		final int precedence;
		final int numOperands;
	}

	@AllArgsConstructor
	public static class ParserContext {
		final String expr;
		int index, endIndex;
		char c;
		Operator op;
		Object[] operands = new Object[2];
		boolean isInParentheses;
		boolean isTopLevelParser;
		int minPrecedence;

		ParserContext(String expression, int startIndex, int endIndex, boolean isTopLevelParser, int minPrecedence) {
			this.expr = expression;
			this.index = startIndex;
			this.endIndex = endIndex;
			this.isTopLevelParser = isTopLevelParser;
			this.minPrecedence = minPrecedence;
		}

		boolean done() {
			return index >= endIndex;
		}

		void read() {
			if (done())
				throw new SyntaxError(this, "Unexpected end of expression");
			c = expr.charAt(index);
		}

		void readSafe() {
			c = done() ? 0 : expr.charAt(index);
		}

		char readEnd() {
			return expr.charAt(endIndex - 1);
		}

		void readIgnoringWhitespace() {
			skipWhitespace();
			read();
		}

		void advance() {
			index++;
			readSafe();
		}

		void advanceIgnoringWhitespace() {
			advance();
			skipWhitespace();
		}

		void trim() {
			int remaining;
			do {
				remaining = remaining();
				trimWhitespace();
				trimParentheses();
			} while (remaining != remaining());
		}

		void trimParentheses() {
			isInParentheses = false;
			while (!done() && c == '(' && readEnd() == ')') {
				int i = index + 1;
				int levels = 1;
				while (i < endIndex - 2) {
					char c = expr.charAt(i++);
					if (c == '(') {
						levels++;
					} else if (c == ')') {
						levels--;
						if (levels == 0)
							return;
					}
				}

				advance();
				endIndex--;
				isInParentheses = true;
			}
		}

		void skipWhitespace() {
			while (!done()) {
				readSafe();
				if (c != ' ')
					break;
				index++;
			}
		}

		void trimWhitespaceEnd() {
			while (!done()) {
				var end = expr.charAt(endIndex - 1);
				if (end != ' ')
					break;
				endIndex--;
			}
		}

		void trimWhitespace() {
			skipWhitespace();
			trimWhitespaceEnd();
		}

		int remaining() {
			return endIndex - index;
		}

		int indexOfClosingParenthesis(int openingParenthesis) {
			int i = openingParenthesis;
			int levels = 1;
			while (++i < endIndex) {
				char c = expr.charAt(i);
				if (c == '(') {
					levels++;
				} else if (c == ')' && --levels == 0) {
					return i;
				}
			}
			throw new SyntaxError(this, "Missing closing parenthesis");
		}

		Object parseOperand() {
			if (!done()) {
				skipWhitespace();

				// Always parse parentheses in a new parsing context
				if (c == '(') {
					int end = indexOfClosingParenthesis(index);
					var exprInParentheses = parseExpression(expr, index, end + 1);
					index = end + 1;
					readSafe();
					return exprInParentheses;
				}

				// Parse all following operations with higher precedence than the current, and return that as the operand
				if (op != null) {
					var higherPrecedenceParser = new ParserContext(expr, index, endIndex, false, op.precedence + 1);
					var expr = parseExpression(higherPrecedenceParser);
					if (expr != null) {
						index = higherPrecedenceParser.index;
						endIndex = higherPrecedenceParser.endIndex;
						return expr;
					}
				}

				if (c == '+' || c == '-' || c == '.' || ('0' <= c && c <= '9'))
					return readNumber();
				if ('A' <= c && c <= 'Z' || 'a' <= c && c <= 'z' || c == '_')
					return readIdentifier();
			}
			return null;
		}

		float readNumber() {
			// Parse sign
			int sign = 1;
			while (!done()) {
				if (c == '-') {
					sign *= -1;
				} else if (c != '+') {
					break;
				}
				advanceIgnoringWhitespace();
			}

			// Parse whole part
			int wholePart = 0;
			int numDigits = 0;
			while (!done()) {
				if ('0' <= c && c <= '9') {
					wholePart *= 10;
					wholePart += c - '0';
					numDigits++;
					advance();
				} else {
					break;
				}
			}

			// Parse fractional part
			if (!done() && c == '.') {
				advance();
				int fractionalPart = 0;
				int divisor = 1;
				while (!done()) {
					if ('0' <= c && c <= '9') {
						fractionalPart += c - '0';
						divisor *= 10;
						advance();
					} else {
						break;
					}
				}

				if (divisor > 1)
					return sign * ((float) fractionalPart / divisor + wholePart);
			}

			if (numDigits == 0)
				throw new SyntaxError(this, "Expected a number");

			return sign * wholePart;
		}

		Object readIdentifier() {
			StringBuilder sb = new StringBuilder();
			while (!done()) {
				if ('A' <= c && c <= 'Z' ||
					'a' <= c && c <= 'z' ||
					'0' <= c && c <= '9' ||
					c == '_'
				) {
					sb.append(c);
					advance();
				} else {
					break;
				}
			}

			assert sb.length() > 0;
			var str = sb.toString();

			// Convert string constants
			if (str.equalsIgnoreCase("true"))
				return true;
			if (str.equalsIgnoreCase("false"))
				return false;

			return str;
		}

		Expression createExpression(Object leftOperand, Operator op, Object rightOperand) {
			if (!(leftOperand instanceof Expression)) {
				// Simple combination of left & right operands
				return new Expression(op, leftOperand, rightOperand, null, false);
			}

			Expression left = (Expression) leftOperand;
			// If the left expression is in parentheses, or has the same or higher operator precedence,
			// it should be evaluated first, so use it as the left operand in a new expression
			if (left.isInParentheses || left.op.precedence >= op.precedence)
				return new Expression(op, left, rightOperand, null, false);

			// The new operator should act on the left expression's right-most operand,
			// and should replace the right-most operand with the resulting expression
			left.right = createExpression(left.right, op, rightOperand);
			return left;
		}
	}

	public static class Expression {
		Operator op;
		Object left, right;
		Object ternary;
		boolean isInParentheses;
		public final HashSet<String> variables = new HashSet<>();

		Expression(Object value) {
			this(null, value, null, null, false);
		}

		Expression(Operator op, Object left, Object right, Object ternary, boolean isInParentheses) {
			this.op = op;
			this.left = left;
			this.right = right;
			this.ternary = ternary;
			this.isInParentheses = isInParentheses;
			registerVariables(left);
			registerVariables(right);
			registerVariables(ternary);
		}

		private Object simplify(@Nonnull Map<String, Object> constants) {
			Object l = left instanceof Expression ? ((Expression) left).simplify(constants) : left;
			Object r = right instanceof Expression ? ((Expression) right).simplify(constants) : right;

			if (l instanceof String)
				l = sanitizeValue(constants.getOrDefault(l, l));
			if (r instanceof String)
				r = sanitizeValue(constants.getOrDefault(r, r));

			if (op == Operator.TERNARY) {
				Object t = asExpression(ternary).simplify(constants);
				if (t instanceof Boolean)
					return (boolean) t ? l : r;
				return new Expression(op, l, r, asExpression(t), isInParentheses);
			}

			var expr = this;
			if (l != left || r != right)
				expr = new Expression(op, l, r, null, isInParentheses);

			if (isPrimitive(l) && isPrimitive(r))
				return expr.toFunctionInternal().apply(null);

			return expr;
		}

		public Function<VariableSupplier, Object> toFunction() {
			var func = toFunctionInternal();
			return vars -> func.apply(key -> sanitizeValue(vars.get(key)));
		}

		static Object sanitizeValue(Object value) {
			// This is kind of stupid, but it's necessary to convert
			// ints to floats here to avoid messy code later
			if (value instanceof Integer)
				return ((Integer) value).floatValue();
			return value;
		}

		private Function<VariableSupplier, Object> toFunctionInternal() {
			if (op == null)
				return asFunction(left);

			if (op == Operator.TERNARY) {
				var condition = asExpression(ternary).toPredicate();
				if (left instanceof Expression) {
					var ifTrue = ((Expression) left).toFunction();
					if (right instanceof Expression) {
						var ifFalse = ((Expression) right).toFunction();
						return vars -> condition.test(vars) ? ifTrue.apply(vars) : ifFalse.apply(vars);
					}
					return vars -> condition.test(vars) ? ifTrue.apply(vars) : right;
				} else if (right instanceof Expression) {
					var ifFalse = ((Expression) right).toFunction();
					return vars -> condition.test(vars) ? left : ifFalse.apply(vars);
				} else {
					return vars -> condition.test(vars) ? left : right;
				}
			}

			// Convert variables and constants into functions
			var l = asFunction(left);
			var r = asFunction(right);

			switch (op) {
				case AND:
					return vars -> (boolean) l.apply(vars) && (boolean) r.apply(vars);
				case OR:
					return vars -> (boolean) l.apply(vars) || (boolean) r.apply(vars);
				case NOTEQUAL:
				case EQUAL:
					boolean isBoolean =
						left instanceof Boolean || left instanceof Expression && ((Expression) left).isBoolean() ||
						right instanceof Boolean || right instanceof Expression && ((Expression) right).isBoolean();
					if (isBoolean) {
						return op == Operator.EQUAL ?
							vars -> (boolean) l.apply(vars) == (boolean) r.apply(vars) :
							vars -> (boolean) l.apply(vars) != (boolean) r.apply(vars);
					} else {
						return op == Operator.EQUAL ?
							vars -> (float) l.apply(vars) == (float) r.apply(vars) :
							vars -> (float) l.apply(vars) != (float) r.apply(vars);
					}
				case GEQUAL:
					return vars -> (float) l.apply(vars) >= (float) r.apply(vars);
				case GREATER:
					return vars -> (float) l.apply(vars) > (float) r.apply(vars);
				case LEQUAL:
					return vars -> (float) l.apply(vars) <= (float) r.apply(vars);
				case LESS:
					return vars -> (float) l.apply(vars) < (float) r.apply(vars);
				case ADD:
					return vars -> (float) l.apply(vars) + (float) r.apply(vars);
				case SUB:
					return vars -> (float) l.apply(vars) - (float) r.apply(vars);
				case MUL:
					return vars -> (float) l.apply(vars) * (float) r.apply(vars);
				case DIV:
					return vars -> (float) l.apply(vars) / (float) r.apply(vars);
				case MOD:
					return vars -> (float) l.apply(vars) % (float) r.apply(vars);
				case NOT:
					return vars -> !(boolean) r.apply(vars);
			}

			throw new UnsupportedOperationException("Unsupported operands: " + l + " " + op + " " + r);
		}

		public Predicate<VariableSupplier> toPredicate() {
			if (!isBoolean())
				throw new IllegalArgumentException("Expression does not result in a boolean");

			var func = toFunction();
			return vars -> (boolean) func.apply(vars);
		}

		boolean isBoolean() {
			if (op == null)
				return isPossiblyBoolean(left);
			switch (op) {
				case TERNARY:
					return isPossiblyBoolean(left) || isPossiblyBoolean(right);
				case EQUAL:
				case NOTEQUAL:
				case LESS:
				case LEQUAL:
				case GREATER:
				case GEQUAL:
				case AND:
				case OR:
				case NOT:
					return true;
			}
			return false;
		}

		static boolean isPossiblyBoolean(Object obj) {
			return
				obj instanceof Boolean ||
				obj instanceof String ||
				obj instanceof Expression && ((Expression) obj).isBoolean();
		}

		private boolean isPrimitive(Object obj) {
			return obj == null || obj instanceof Float || obj instanceof Boolean;
		}

		private void registerVariables(@Nullable Object dependency) {
			if (dependency instanceof String) {
				variables.add((String) dependency);
			} else if (dependency instanceof Expression) {
				variables.addAll(((Expression) dependency).variables);
			}
		}
	}

	private static Object parseExpression(String expression, int startIndex, int endIndex) {
		return parseExpression(new ParserContext(expression, startIndex, endIndex, true, 0));
	}

	private static Object parseExpression(ParserContext ctx) {
		ctx.trimWhitespace();
		if (ctx.done())
			throw new SyntaxError(ctx, "Empty expression");

		ctx.trimParentheses();
		boolean wasInParentheses = ctx.isInParentheses;
		boolean wasTopLevelParser = ctx.isTopLevelParser;
		// Since we'll be reusing the same parser context for parsing sub-expressions, mark it as not top-level
		ctx.isTopLevelParser = false;

		// The general gist:
		// 1. Begin parsing from left to right until any operator is reached
		// 2. Parse all following higher precedence operations
		// 3. Continue parsing operators regardless of precedence
		// 4. If a lower precedence operator is reached, make that the new parent node, and return to step 2
		// 5. At the end, return the left operand and parenthesis information

		ctx.operands[0] = ctx.parseOperand();

		parsing:
		while (!ctx.done()) {
			ctx.skipWhitespace();
			ctx.op = null;
			for (var op : Operator.values()) {
				// Skip lower precedence operators
				if (op.precedence >= ctx.minPrecedence && ctx.expr.startsWith(op.symbol, ctx.index)) {
					if (op == Operator.TERNARY) {
						// Parse the ternary into an expression to be the new left operand, and keep parsing
						var condition = ctx.operands[0];
						if (condition == null)
							throw new SyntaxError(ctx, "Unexpected operator '" + op.symbol + "' without preceding condition");
						ctx.index += op.symbol.length();
						var ifTrue = parseExpression(ctx);
						ctx.trim();
						if (ctx.c != ':')
							throw new SyntaxError(ctx, "Expected ':' in ternary expression");
						ctx.advance();
						var ifFalse = parseExpression(ctx);
						ctx.operands[0] = new Expression(op, ifTrue, ifFalse, condition, wasInParentheses);
						continue parsing;
					}

					if (ctx.operands[0] == null) {
						if (op.numOperands > 1)
							throw new SyntaxError(ctx, "Missing left operand for operator '" + op.symbol + "'");
					} else if (op.numOperands == 1) {
						throw new SyntaxError(ctx, "Unexpected left operand before '" + op.symbol + "'");
					}

					ctx.op = op;
					ctx.index += op.symbol.length();
					break;
				}
			}

			if (ctx.op == null)
				break;

			if (ctx.op != Operator.NOT && ctx.operands[0] == null)
				throw new SyntaxError(ctx, "Missing left operand for operator '" + ctx.op.symbol + "'");

			// Will parse all following higher precedence operations, or a single value or identifier
			ctx.operands[1] = ctx.parseOperand();
			if (ctx.operands[1] == null)
				throw new SyntaxError(ctx, "Missing right operand for operator '" + ctx.op.symbol + "'");

			ctx.operands[0] = ctx.createExpression(ctx.operands[0], ctx.op, ctx.operands[1]);
		}

		if (wasTopLevelParser && !ctx.done())
			throw new SyntaxError(ctx, "Unexpected character '" + ctx.c + "'");

		if (ctx.operands[0] instanceof Expression)
			((Expression) ctx.operands[0]).isInParentheses = wasInParentheses;

		return ctx.operands[0];
	}
}

/*
 * Color utility functions
 * Written in 2023 by Hooder <ahooder@protonmail.com>
 * To the extent possible under law, the author(s) have dedicated all copyright and related and neighboring rights
 * to this software to the public domain worldwide. This software is distributed without any warranty.
 * You should have received a copy of the CC0 Public Domain Dedication along with this software.
 * If not, see <http://creativecommons.org/publicdomain/zero/1.0/>.
 */

package rs117.hd.utils;

import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonToken;
import com.google.gson.stream.JsonWriter;
import java.awt.Color;
import java.io.IOException;
import java.util.Arrays;
import lombok.extern.slf4j.Slf4j;

public class ColorUtils {
	private static final float EPS = 1e-10f;

	/**
	 * Row-major transformation matrices for conversion between RGB and XYZ color spaces.
	 * Fairman, H. S., Brill, M. H., & Hemmendinger, H. (1997).
	 * How the CIE 1931 color-matching functions were derived from Wright-Guild data.
	 * Color Research & Application, 22(1), 11–23.
	 * doi:10.1002/(sici)1520-6378(199702)22:1<11::aid-col4>3.0.co;2-7
	 */
	private static final float[] RGB_TO_XYZ_MATRIX = {
		.49f, .31f, .2f,
		.1769f, .8124f, .0107f,
		.0f,    .0099f, .9901f
	};
	private static final float[] XYZ_TO_RGB_MATRIX = {
		2.36449f,    -.896553f,  -.467937f,
		-.514935f,   1.42633f,    .0886025f,
		 .00514883f, -.0142619f, 1.00911f
	};

	/**
	 * Approximate UV coordinates in the CIE 1960 UCS color space from a color temperature specified in degrees Kelvin.
	 * @param kelvin temperature in degrees Kelvin. Valid from 1000 to 15000.
	 * @see <a href="https://doi.org/10.1002/col.5080100109">
	 *     Krystek, M. (1985). An algorithm to calculate correlated colour temperature.
	 *     Color Research & Application, 10(1), 38–40. doi:10.1002/col.5080100109
	 * </a>
	 * @return UV coordinates in the UCS color space
	 */
	public static float[] colorTemperatureToLinearRgb(double kelvin) {
		// UV coordinates in CIE 1960 UCS color space
		double[] uv = new double[] {
			(0.860117757 + 1.54118254e-4 * kelvin + 1.28641212e-7 * kelvin * kelvin)
				/ (1 + 8.42420235e-4 * kelvin + 7.08145163e-7 * kelvin * kelvin),
			(0.317398726 + 4.22806245e-5 * kelvin + 4.20481691e-8 * kelvin * kelvin)
				/ (1 - 2.89741816e-5 * kelvin + 1.61456053e-7 * kelvin * kelvin)
		};

		// xy coordinates in CIES 1931 xyY space
		double divisor = 2 * uv[0] - 8 * uv[1] + 4;
		double[] xy = new double[] { 3 * uv[0] / divisor,  2 * uv[1] / divisor };

		// CIE XYZ space
		float Y = 1;
		float[] XYZ = { (float) (xy[0] * Y / xy[1]), Y, (float) ((1 - xy[0] - xy[1]) * Y / xy[1]) };

		return XYZtoRGB(XYZ);
	}

	/**
	 * Transform from CIE 1931 XYZ color space to linear RGB.
	 * @param XYZ coordinates
	 * @return linear RGB coordinates
	 */
	public static float[] XYZtoRGB(float[] XYZ) {
		float[] RGB = new float[3];
		mat3MulVec3(RGB, XYZ_TO_RGB_MATRIX, XYZ);
		return RGB;
	}

	/**
	 * Transform from linear RGB to CIE 1931 XYZ color space.
	 * @param RGB linear RGB color coordinates
	 * @return XYZ color coordinates
	 */
	public static float[] RGBtoXYZ(float[] RGB) {
		float[] XYZ = new float[3];
		mat3MulVec3(XYZ, RGB_TO_XYZ_MATRIX, RGB);
		return XYZ;
	}

	private static void mat3MulVec3(float[] out, float[] m, float[] v) {
		out[0] = m[0] * v[0] + m[1] * v[1] + m[2] * v[2];
		out[1] = m[3] * v[0] + m[4] * v[1] + m[5] * v[2];
		out[2] = m[6] * v[0] + m[7] * v[1] + m[8] * v[2];
	}

	// Conversion functions to and from sRGB and linear color space.
	// The implementation is based on the sRGB EOTF given in the Khronos Data Format Specification.
	// Source: https://web.archive.org/web/20220808015852/https://registry.khronos.org/DataFormat/specs/1.3/dataformat.1.3.pdf
	// Page number 130 (146 in the PDF)
	public static float linearToSrgb(float c) {
		return c <= 0.0031308 ?
			c * 12.92f :
			(float) (1.055 * Math.pow(c, 1 / 2.4) - 0.055);
	}

	public static float srgbToLinear(float c) {
		return c <= 0.04045f ?
			c / 12.92f :
			(float) Math.pow((c + 0.055) / 1.055, 2.4);
	}

	public static float[] linearToSrgb(float... c) {
		float[] result = new float[c.length];
		for (int i = 0; i < c.length; i++)
			result[i] = linearToSrgb(c[i]);
		return result;
	}

	public static float[] srgbToLinear(float... c) {
		float[] result = new float[c.length];
		for (int i = 0; i < c.length; i++)
			result[i] = srgbToLinear(c[i]);
		return result;
	}

	/**
	 * Float modulo that returns the answer with the same sign as the modulus.
	 */
	private static float mod(float x, float modulus) {
		return (float) (x - Math.floor(x / modulus) * modulus);
	}

	private static float clamp(float value, float min, float max) {
		return Math.min(Math.max(value, min), max);
	}

	private static int clamp(int value, int min, int max) {
		return Math.min(Math.max(value, min), max);
	}

	/**
	 * Convert sRGB in the range 0-1 to HSL in the range 0-1.
	 *
	 * @param srgb float[3]
	 * @return hsl float[3]
	 * @link <a href="https://web.archive.org/web/20230619214343/https://en.wikipedia.org/wiki/HSL_and_HSV#Color_conversion_formulae">Wikipedia: HSL and HSV</a>
	 */
	public static float[] srgbToHsl(float[] srgb) {
		float V = Math.max(Math.max(srgb[0], srgb[1]), srgb[2]);
		float X_min = Math.min(Math.min(srgb[0], srgb[1]), srgb[2]);
		float C = V - X_min;

		float H = 0;
		if (C > 0) {
			if (V == srgb[0]) {
				H = mod((srgb[1] - srgb[2]) / C, 6);
			} else if (V == srgb[1]) {
				H = (srgb[2] - srgb[0]) / C + 2;
			} else {
				H = (srgb[0] - srgb[1]) / C + 4;
			}
			assert H >= 0 && H <= 6;
		}

		float L = (V + X_min) / 2;
		float divisor = 1 - Math.abs(2 * L - 1);
		float S_L = Math.abs(divisor) < EPS ? 0 : C / divisor;
		return new float[] { H / 6, S_L, L };
	}

	/**
	 * Convert HSL in the range 0-1 to sRGB in the range 0-1.
	 *
	 * @param hsl float[3]
	 * @return srgb float[3]
	 * @link <a href="https://web.archive.org/web/20230619214343/https://en.wikipedia.org/wiki/HSL_and_HSV#Color_conversion_formulae">Wikipedia: HSL and HSV</a>
	 */
	public static float[] hslToSrgb(float[] hsl) {
		float C = hsl[1] * (1 - Math.abs(2 * hsl[2] - 1));
		float H_prime = hsl[0] * 6;
		float m = hsl[2] - C / 2;

		float r = clamp(Math.abs(H_prime - 3) - 1, 0, 1) * C + m;
		float g = clamp(2 - Math.abs(H_prime - 2), 0, 1) * C + m;
		float b = clamp(2 - Math.abs(H_prime - 4), 0, 1) * C + m;
		return new float[] { r, g, b };
	}

	/**
	 * Convert HSL in the range 0-1 to HSV in the range 0-1.
	 *
	 * @param hsl float[3]
	 * @return hsv float[3]
	 */
	public static float[] hslToHsv(float[] hsl) {
		float v = hsl[2] + hsl[1] * Math.min(hsl[2], 1 - hsl[2]);
		return new float[] { hsl[0], Math.abs(v) < EPS ? 0 : 2 * (1 - hsl[2] / v), v };
	}

	/**
	 * Convert HSV in the range 0-1 to HSL in the range 0-1.
	 *
	 * @param hsv float[3]
	 * @return hsl float[3]
	 */
	public static float[] hsvToHsl(float[] hsv) {
		float l = hsv[2] * (1 - hsv[1] / 2);
		float divisor = Math.min(l, 1 - l);
		return new float[] { hsv[0], Math.abs(divisor) < EPS ? 0 : (hsv[2] - l) / divisor, l };
	}

	/**
	 * Convert sRGB in the range 0-1 from sRGB to HSV (also known as HSB) in the range 0-1.
	 *
	 * @param srgb float[3]
	 * @return hsv float[3]
	 * @link <a href="https://web.archive.org/web/20230619214343/https://en.wikipedia.org/wiki/HSL_and_HSV#Color_conversion_formulae">Wikipedia: HSL and HSV</a>
	 */
	public static float[] srgbToHsv(float[] srgb) {
		return hslToHsv(srgbToHsl(srgb));
	}

	/**
	 * Convert HSV (also known as HSB) in the range 0-1 to sRGB in the range 0-1.
	 *
	 * @param hsv float[3]
	 * @return srgb float[3]
	 * @link <a href="https://web.archive.org/web/20230619214343/https://en.wikipedia.org/wiki/HSL_and_HSV#Color_conversion_formulae">Wikipedia: HSL and HSV</a>
	 */
	public static float[] hsvToSrgb(float[] hsv) {
		return hslToSrgb(hsvToHsl(hsv));
	}

	// Convenience functions for converting different formats into linear RGB, sRGB or packed HSL

	/**
	 * Convert red, green and blue in the range 0-255 from sRGB to linear RGB in the range 0-1.
	 *
	 * @param r red color
	 * @param g green color
	 * @param b blue color
	 * @return float[3] linear rgb values from 0-1
	 */
	public static float[] rgb(float r, float g, float b) {
		return srgbToLinear(srgb(r, g, b));
	}

	/**
	 * Convert hex color from sRGB to linear RGB in the range 0-1.
	 *
	 * @param hex RGB hex color
	 * @return float[3] linear rgb values from 0-1
	 */
	public static float[] rgb(String hex) {
		return srgbToLinear(srgb(hex));
	}

	/**
	 * Convert sRGB color packed as an int to linear RGB in the range 0-1.
	 *
	 * @param srgb packed sRGB
	 * @return float[3] linear rgb values from 0-1
	 */
	public static float[] rgb(int srgb) {
		return srgbToLinear(srgb(srgb));
	}

	/**
	 * Convert red, green and blue in the range 0-255 from sRGB to sRGB in the range 0-1.
	 *
	 * @param r red color
	 * @param g green color
	 * @param b blue color
	 * @return float[3] non-linear sRGB values from 0-1
	 */
	public static float[] srgb(float r, float g, float b) {
		return new float[] { r / 255f, g / 255f, b / 255f };
	}

	/**
	 * Convert hex color from sRGB to sRGB in the range 0-1.
	 *
	 * @param hex RGB hex color
	 * @return float[3] non-linear sRGB values from 0-1
	 */
	public static float[] srgb(String hex) {
		Color color = Color.decode(hex);
		return srgb(color.getRed(), color.getGreen(), color.getBlue());
	}

	/**
	 * Convert sRGB color packed as an int to sRGB in the range 0-1.
	 *
	 * @param srgb packed sRGB
	 * @return float[3] non-linear sRGB values from 0-1
	 */
	public static float[] srgb(int srgb) {
		return new float[] {
			(srgb >> 16 & 0xFF) / (float) 0xFF,
			(srgb >> 8 & 0xFF) / (float) 0xFF,
			(srgb & 0xFF) / (float) 0xFF,
		};
	}

	/**
	 * Convert alpha and sRGB color packed in an int as ARGB to sRGB in the range 0-1.
	 *
	 * @param alphaSrgb packed sRGB with a preceding alpha channel
	 * @return float[4] non-linear sRGB and alpha in the range 0-1
	 */
	public static float[] srgba(int alphaSrgb) {
		return new float[] {
			(alphaSrgb >> 16 & 0xFF) / (float) 0xFF,
			(alphaSrgb >> 8 & 0xFF) / (float) 0xFF,
			(alphaSrgb & 0xFF) / (float) 0xFF,
			(alphaSrgb >> 24 & 0xFF) / (float) 0xFF
		};
	}

	/**
	 * Convert red, green and blue in the range 0-255 from sRGB to packed HSL.
	 *
	 * @param r red color
	 * @param g green color
	 * @param b blue color
	 * @return int packed HSL
	 */
	public static int hsl(float r, float g, float b) {
		return srgbToPackedHsl(srgb(r, g, b));
	}

	/**
	 * Convert hex color from sRGB to packed HSL.
	 *
	 * @param rgbHex RGB hex color
	 * @return int packed HSL
	 */
	public static int hsl(String rgbHex) {
		return srgbToPackedHsl(srgb(rgbHex));
	}

	/**
	 * Convert sRGB color packed as an int to packed HSL.
	 *
	 * @param packedSrgb RGB hex color
	 * @return int packed HSL
	 */
	public static int hsl(int packedSrgb) {
		return srgbToPackedHsl(srgb(packedSrgb));
	}

	// Integer packing and unpacking functions

	public static int packRawRgb(int... rgb) {
		return rgb[0] << 16 | rgb[1] << 8 | rgb[2];
	}

	public static int packSrgb(float[] srgb) {
		int[] ints = new int[3];
		for (int i = 0; i < 3; i++)
			ints[i] = clamp(Math.round(srgb[i] * 0xFF), 0, 0xFF);
		return packRawRgb(ints);
	}

	public static int packRawHsl(int... hsl) {
		return hsl[0] << 10 | hsl[1] << 7 | hsl[2];
	}

	public static void unpackRawHsl(int[] out, int hsl) {
		// 6-bit hue | 3-bit saturation | 7-bit lightness
		out[0] = hsl >>> 10 & 0x3F;
		out[1] = hsl >>> 7 & 0x7;
		out[2] = hsl & 0x7F;
	}

	public static int[] unpackRawHsl(int hsl) {
		int[] out = new int[3];
		unpackRawHsl(out, hsl);
		return out;
	}

	public static int packHsl(float... hsl) {
		int H = clamp(Math.round((hsl[0] - .0078125f) * (0x3F + 1)), 0, 0x3F);
		int S = clamp(Math.round((hsl[1] - .0625f) * (0x7 + 1)), 0, 0x7);
		int L = clamp(Math.round(hsl[2] * (0x7F + 1)), 0, 0x7F);
		return packRawHsl(H, S, L);
	}

	public static float[] unpackHsl(int hsl) {
		// 6-bit hue | 3-bit saturation | 7-bit lightness
		float H = (hsl >>> 10 & 0x3F) / (0x3F + 1f) + .0078125f;
		float S = (hsl >>> 7 & 0x7) / (0x7 + 1f) + .0625f;
		float L = (hsl & 0x7F) / (0x7F + 1f);
		return new float[] { H, S, L };
	}

	public static int srgbToPackedHsl(float[] srgb) {
		return packHsl(srgbToHsl(srgb));
	}

	public static float[] packedHslToSrgb(int packedHsl) {
		return hslToSrgb(unpackHsl(packedHsl));
	}

	public static int linearRgbToPackedHsl(float[] linearRgb) {
		return srgbToPackedHsl(linearToSrgb(linearRgb));
	}

	public static float[] packedHslToLinearRgb(int hsl) {
		return srgbToLinear(packedHslToSrgb(hsl));
	}

	public static String srgbToHex(float... srgb) {
		return String.format("#%h", packSrgb(srgb));
	}

	public static String rgbToHex(float... linearRgb) {
		return srgbToHex(linearToSrgb(linearRgb));
	}

	@Slf4j
	public static class SrgbAdapter extends TypeAdapter<float[]> {
		private final float[] rgba = { 0, 0, 0, 1 };
		private final int[] rgbaInt = { 0, 0, 0, 255 };

		@Override
		public float[] read(JsonReader in) throws IOException {
			var token = in.peek();
			if (token == JsonToken.STRING)
				return ColorUtils.srgb(in.nextString());

			if (token != JsonToken.BEGIN_ARRAY)
				throw new IOException("Expected hex color code or array of color channels at " + GsonUtils.location(in));

			in.beginArray();

			int i = 0;
			while (in.hasNext() && in.peek() != JsonToken.END_ARRAY) {
				if (in.peek() == JsonToken.NULL) {
					log.warn("Skipping null value in color array at {}", GsonUtils.location(in));
					in.skipValue();
					continue;
				}

				if (in.peek() == JsonToken.NUMBER) {
					if (i > 3) {
						log.warn("Skipping extra elements in color array at {}", GsonUtils.location(in));
						break;
					}

					rgba[i++] = (float) in.nextDouble();
					continue;
				}

				throw new IOException("Unexpected type in color array: " + in.peek() + " at " + GsonUtils.location(in));
			}
			in.endArray();

			if (i < 3)
				throw new IOException("Too few elements in color array: " + i + " at " + GsonUtils.location(in));

			for (int j = 0; j < i; j++)
				rgba[j] /= 255;

			if (i == 4)
				return rgba;

			float[] rgb = new float[3];
			System.arraycopy(rgba, 0, rgb, 0, 3);
			return rgb;
		}

		@Override
		public void write(JsonWriter out, float[] src) throws IOException {
			if (src == null || src.length == 0) {
				out.nullValue();
				return;
			}

			if (src.length != 3 && src.length != 4)
				throw new IOException("The number of components must be 3 or 4 in a color array. Got " + Arrays.toString(src));

			for (int i = 0; i < src.length; i++)
				rgba[i] = src[i] * 255;

			// See if it can fit in a hex color code
			boolean canfit = true;
			for (int i = 0; i < src.length; i++) {
				float f = rgba[i];
				rgbaInt[i] = Math.round(f);
				if (Math.abs(f - rgbaInt[i]) > EPS) {
					canfit = false;
					break;
				}
			}

			if (canfit) {
				// Serialize it as a hex color code
				if (src.length == 3) {
					out.value(String.format("#%02x%02x%02x", rgbaInt[0], rgbaInt[1], rgbaInt[2]));
				} else {
					out.value(String.format("#%02x%02x%02x%02x", rgbaInt[0], rgbaInt[1], rgbaInt[2], rgbaInt[3]));
				}
			} else {
				out.beginArray();
				for (int i = 0; i < src.length; i++) {
					out.value(rgba[i]);
				}
				out.endArray();
			}
		}
	}

	@Slf4j
	public static class SrgbToLinearAdapter extends SrgbAdapter {
		@Override
		public float[] read(JsonReader in) throws IOException {
			return srgbToLinear(super.read(in));
		}

		@Override
		public void write(JsonWriter out, float[] src) throws IOException {
			super.write(out, linearToSrgb(src));
		}
	}
}

package rs117.hd.overlays;

import com.google.inject.Inject;
import com.google.inject.Singleton;
import java.awt.Color;
import java.awt.Dimension;
import java.awt.Graphics2D;
import java.io.IOException;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.*;
import net.runelite.api.events.*;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.eventbus.EventBus;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.ui.overlay.Overlay;
import net.runelite.client.ui.overlay.OverlayLayer;
import net.runelite.client.ui.overlay.OverlayManager;
import net.runelite.client.ui.overlay.OverlayPosition;
import rs117.hd.HdPlugin;
import rs117.hd.opengl.shader.ShaderException;

import static org.lwjgl.opengl.GL20C.*;
import static rs117.hd.HdPlugin.TEXTURE_UNIT_BASE;
import static rs117.hd.HdPlugin.TEXTURE_UNIT_SHADOW_MAP;

@Slf4j
@Singleton
public class ShadowMapOverlay extends Overlay {
	@Inject
	private Client client;

	@Inject
	private ClientThread clientThread;

	@Inject
	private EventBus eventBus;

	@Inject
	private OverlayManager overlayManager;

	@Inject
	private HdPlugin plugin;

	private boolean isActive;

	public ShadowMapOverlay() {
		setLayer(OverlayLayer.ABOVE_WIDGETS);
		setPosition(OverlayPosition.TOP_LEFT);
		setResizable(true);
	}

	public void setActive(boolean activate) {
		if (activate == isActive)
			return;
		isActive = activate;

		if (activate) {
			overlayManager.add(this);
			plugin.enableShadowMapOverlay = true;
			eventBus.register(this);
		} else {
			overlayManager.remove(this);
			plugin.enableShadowMapOverlay = false;
			eventBus.unregister(this);
		}

		clientThread.invoke(() -> {
			try {
				plugin.recompilePrograms();
			} catch (ShaderException | IOException ex) {
				log.error("Error while recompiling shaders:", ex);
				plugin.stopPlugin();
			}
		});
	}

	@Subscribe
	public void onGameStateChanged(GameStateChanged gameStateChanged) {
		if (gameStateChanged.getGameState() == GameState.LOGIN_SCREEN) {
			glUseProgram(plugin.glUiProgram);
			int uniBounds = glGetUniformLocation(plugin.glUiProgram, "shadowMapOverlayDimensions");
			if (uniBounds != -1)
				glUniform4i(uniBounds, 0, 0, 0, 0);
		}
	}

	@Override
	public Dimension render(Graphics2D g) {
		var bounds = getBounds();

		clientThread.invoke(() -> {
			if (plugin.glUiProgram == 0)
				return;

			glUseProgram(plugin.glUiProgram);
			int uniShadowMap = glGetUniformLocation(plugin.glUiProgram, "shadowMap");
			if (uniShadowMap != -1)
				glUniform1i(uniShadowMap, TEXTURE_UNIT_SHADOW_MAP - TEXTURE_UNIT_BASE);
			int uniBounds = glGetUniformLocation(plugin.glUiProgram, "shadowMapOverlayDimensions");
			if (uniBounds != -1) {
				if (client.getGameState().getState() < GameState.LOGGED_IN.getState()) {
					glUniform4i(uniBounds, 0, 0, 0, 0);
				} else {
					int canvasWidth = client.getCanvasWidth();
					int canvasHeight = client.getCanvasHeight();
					float scaleX = 1;
					float scaleY = 1;
					if (client.isStretchedEnabled()) {
						var stretchedDims = client.getStretchedDimensions();
						scaleX = (float) stretchedDims.width / canvasWidth;
						scaleY = (float) stretchedDims.height / canvasHeight;
					}
					glUniform4i(uniBounds,
						(int) Math.floor((bounds.x + 1) * scaleX), (int) Math.floor((canvasHeight - bounds.height - bounds.y) * scaleY),
						(int) Math.ceil((bounds.width - 1) * scaleX), (int) Math.ceil((bounds.height - 1) * scaleY)
					);
				}
			}

			plugin.checkGLErrors();
		});

		g.setColor(Color.BLACK);
		g.drawRect(0, 0, bounds.width, bounds.height);

		return getPreferredSize() == null ? new Dimension(256, 256) : getPreferredSize();
	}
}

package rs117.hd.overlays;

import com.google.inject.Singleton;
import java.awt.BasicStroke;
import java.awt.Color;
import java.awt.Dimension;
import java.awt.FontMetrics;
import java.awt.Graphics2D;
import java.awt.Polygon;
import java.awt.Rectangle;
import java.awt.Toolkit;
import java.awt.datatransfer.Clipboard;
import java.awt.datatransfer.StringSelection;
import java.awt.event.MouseEvent;
import java.awt.event.MouseWheelEvent;
import java.awt.geom.Rectangle2D;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.function.Function;
import javax.annotation.Nonnull;
import javax.annotation.Nullable;
import javax.inject.Inject;
import javax.swing.SwingUtilities;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.*;
import net.runelite.api.coords.*;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.input.MouseListener;
import net.runelite.client.input.MouseManager;
import net.runelite.client.input.MouseWheelListener;
import net.runelite.client.ui.FontManager;
import net.runelite.client.ui.overlay.Overlay;
import net.runelite.client.ui.overlay.OverlayLayer;
import net.runelite.client.ui.overlay.OverlayManager;
import net.runelite.client.ui.overlay.OverlayPosition;
import net.runelite.client.ui.overlay.OverlayUtil;
import net.runelite.client.util.ColorUtil;
import org.apache.commons.lang3.tuple.Pair;
import rs117.hd.HdPlugin;
import rs117.hd.data.materials.Material;
import rs117.hd.scene.ProceduralGenerator;
import rs117.hd.scene.SceneContext;
import rs117.hd.scene.TileOverrideManager;
import rs117.hd.utils.AABB;
import rs117.hd.utils.HDUtils;
import rs117.hd.utils.ModelHash;

import static net.runelite.api.Constants.*;
import static net.runelite.api.Perspective.*;
import static rs117.hd.scene.SceneUploader.SCENE_OFFSET;
import static rs117.hd.scene.tile_overrides.TileOverride.OVERLAY_FLAG;
import static rs117.hd.utils.HDUtils.clamp;

@Slf4j
@Singleton
public class TileInfoOverlay extends Overlay implements MouseListener, MouseWheelListener {
	@Inject
	private Client client;

	@Inject
	private ClientThread clientThread;

	@Inject
	private OverlayManager overlayManager;

	@Inject
	private MouseManager mouseManager;

	@Inject
	private HdPlugin plugin;

	@Inject
	private TileOverrideManager tileOverrideManager;

	@Inject
	private ProceduralGenerator proceduralGenerator;

	private Point mousePos;
	private boolean ctrlHeld;
	private boolean ctrlToggled;
	private boolean shiftHeld;
	private boolean shiftToggled;
	private float fontSize = 12;
	private float zoom = 1;

	private int aabbMarkingStage = 0;
	private final int[][] markedWorldPoints = new int[2][];
	private final int[] markedHeights = new int[2];
	private int[] hoveredWorldPoint = new int[3];
	private int hoveredHeight;
	private int targetPlane = MAX_Z - 1;

	public TileInfoOverlay() {
		setLayer(OverlayLayer.ABOVE_WIDGETS);
		setPosition(OverlayPosition.DYNAMIC);
	}

	public void setActive(boolean activate) {
		if (activate) {
			overlayManager.add(this);
			mouseManager.registerMouseListener(this);
			mouseManager.registerMouseWheelListener(this);
		} else {
			overlayManager.remove(this);
			mouseManager.unregisterMouseListener(this);
			mouseManager.unregisterMouseWheelListener(this);
		}
		tileOverrideManager.setTrackReplacements(activate);
	}

	@Override
	public Dimension render(Graphics2D g) {
		var sceneContext = plugin.getSceneContext();
		if (sceneContext == null)
			return null;

		boolean ctrlPressed = client.isKeyPressed(KeyCode.KC_CONTROL);
		if (ctrlHeld != ctrlPressed) {
			ctrlHeld = ctrlPressed;
			if (ctrlPressed)
				ctrlToggled = !ctrlToggled;
		}
		boolean shiftPressed = client.isKeyPressed(KeyCode.KC_SHIFT);
		if (shiftHeld != shiftPressed) {
			shiftHeld = shiftPressed;
			if (shiftPressed)
				shiftToggled = !shiftToggled;
		}

		if (shiftToggled) {
			drawAllIds(g, sceneContext);
			return null;
		}

		mousePos = client.getMouseCanvasPosition();
		if (mousePos == null || mousePos.getX() != -1 || mousePos.getY() != -1) {
			g.setFont(FontManager.getRunescapeFont());
			g.setStroke(new BasicStroke(1, BasicStroke.CAP_BUTT, BasicStroke.JOIN_ROUND));

			Tile[][][] tiles = sceneContext.scene.getExtendedTiles();
			var heights = sceneContext.scene.getTileHeights();
			int maxPlane = client.getPlane();
			int minPlane = 0;
			if (ctrlHeld)
				minPlane = maxPlane = targetPlane;
			tileLoop:
			for (int z = maxPlane; z >= minPlane; z--) {
				for (int isBridge = 1; isBridge >= 0; isBridge--) {
					for (int x = 0; x < EXTENDED_SCENE_SIZE; x++) {
						for (int y = 0; y < EXTENDED_SCENE_SIZE; y++) {
							Tile tile = tiles[z][x][y];
							boolean shouldDraw = tile != null && (isBridge == 0 || tile.getBridge() != null);
							if (shouldDraw && drawTileInfo(g, sceneContext, tile)) {
								int tileZ = tile.getRenderLevel();
								hoveredWorldPoint = sceneContext.extendedSceneToWorld(x, y, tileZ);
								hoveredHeight = heights[tileZ][x][y];
								break tileLoop;
							}
						}
					}
				}
			}
		}

		// Update second selection point each frame
		if (aabbMarkingStage == 1) {
			markedWorldPoints[1] = hoveredWorldPoint;
			markedHeights[1] = hoveredHeight;
		}

		// Draw selection box
		if (markedWorldPoints[0] != null) {
			g.setColor(Color.RED);
			int[] from = sceneContext.worldToLocal(markedWorldPoints[0]);
			int[] to = sceneContext.worldToLocal(markedWorldPoints[1]);
			int x1 = Math.min(from[0], to[0]);
			int y1 = Math.min(from[1], to[1]);
			int z1 = Math.min(markedHeights[0], markedHeights[1]);
			int x2 = Math.max(from[0], to[0]) + LOCAL_TILE_SIZE;
			int y2 = Math.max(from[1], to[1]) + LOCAL_TILE_SIZE;
			int z2 = Math.max(markedHeights[0], markedHeights[1]);
			var bsw = localToCanvas(client, x1, y1, z1);
			var bnw = localToCanvas(client, x1, y2, z1);
			var bne = localToCanvas(client, x2, y2, z1);
			var bse = localToCanvas(client, x2, y1, z1);
			var tsw = localToCanvas(client, x1, y1, z2);
			var tnw = localToCanvas(client, x1, y2, z2);
			var tne = localToCanvas(client, x2, y2, z2);
			var tse = localToCanvas(client, x2, y1, z2);
			// Draw bottom rect
			if (bsw != null && bnw != null)
				g.drawLine(bsw.getX(), bsw.getY(), bnw.getX(), bnw.getY());
			if (bnw != null && bne != null)
				g.drawLine(bnw.getX(), bnw.getY(), bne.getX(), bne.getY());
			if (bne != null && bse != null)
				g.drawLine(bne.getX(), bne.getY(), bse.getX(), bse.getY());
			if (bse != null && bsw != null)
				g.drawLine(bse.getX(), bse.getY(), bsw.getX(), bsw.getY());
			// Draw top rect
			if (tsw != null && tnw != null)
				g.drawLine(tsw.getX(), tsw.getY(), tnw.getX(), tnw.getY());
			if (tnw != null && tne != null)
				g.drawLine(tnw.getX(), tnw.getY(), tne.getX(), tne.getY());
			if (tne != null && tse != null)
				g.drawLine(tne.getX(), tne.getY(), tse.getX(), tse.getY());
			if (tse != null && tsw != null)
				g.drawLine(tse.getX(), tse.getY(), tsw.getX(), tsw.getY());
			// Connect rect corners
			if (bsw != null && tsw != null)
				g.drawLine(bsw.getX(), bsw.getY(), tsw.getX(), tsw.getY());
			if (bnw != null && tnw != null)
				g.drawLine(bnw.getX(), bnw.getY(), tnw.getX(), tnw.getY());
			if (bne != null && tne != null)
				g.drawLine(bne.getX(), bne.getY(), tne.getX(), tne.getY());
			if (bse != null && tse != null)
				g.drawLine(bse.getX(), bse.getY(), tse.getX(), tse.getY());
		}

		return null;
	}

	private boolean drawTileInfo(Graphics2D g, SceneContext sceneContext, Tile tile) {
		boolean infoDrawn = false;

		if (tile != null) {
			Rectangle rect = null;
			Polygon poly;

			Tile bridge = tile.getBridge();
			if (bridge != null) {
				poly = getCanvasTilePoly(client, sceneContext.scene, bridge);
				if (poly != null && poly.contains(mousePos.getX(), mousePos.getY())) {
					rect = drawTileInfo(g, sceneContext, bridge, poly, null);
					if (rect != null) {
						infoDrawn = true;
					}
				}
			}

			poly = getCanvasTilePoly(client, sceneContext.scene, tile);
			if (poly != null && poly.contains(mousePos.getX(), mousePos.getY())) {
				rect = drawTileInfo(g, sceneContext, tile, poly, rect);
				if (rect != null) {
					infoDrawn = true;
				}
			}
		}

		return infoDrawn;
	}

	private Rectangle drawTileInfo(Graphics2D g, SceneContext sceneContext, Tile tile, Polygon poly, Rectangle dodgeRect)
	{
		SceneTilePaint paint = tile.getSceneTilePaint();
		SceneTileModel model = tile.getSceneTileModel();

		if (!ctrlHeld && (paint == null || (paint.getNeColor() == 12345678 && tile.getBridge() == null)) && model == null)
			return null;

		ArrayList<String> lines = new ArrayList<>();

		if (tile.getBridge() != null)
			lines.add("Bridge");

		Scene scene = sceneContext.scene;
		int tileX = tile.getSceneLocation().getX();
		int tileY = tile.getSceneLocation().getY();
		int tileZ = tile.getRenderLevel();
		int tileExX = tileX + SCENE_OFFSET;
		int tileExY = tileY + SCENE_OFFSET;
		int[] worldPos = sceneContext.sceneToWorld(tileX, tileY, tileZ);

		lines.add("Scene point: " + tileX + ", " + tileY + ", " + tileZ);
		lines.add("World point: " + Arrays.toString(worldPos));
		lines.add(String.format(
			"Region ID: %d (%d, %d)",
			HDUtils.worldToRegionID(worldPos),
			worldPos[0] >> 6,
			worldPos[1] >> 6
		));

		int overlayId = scene.getOverlayIds()[tileZ][tileExX][tileExY];
		var overlay = tileOverrideManager.getOverrideBeforeReplacements(worldPos, OVERLAY_FLAG | overlayId);
		var replacementPath = new StringBuilder(overlay.toString());
		while (true) {
			var replacement = tileOverrideManager.resolveNextReplacement(overlay, tile);
			if (replacement == overlay)
				break;
			replacementPath.append("\n\t⤷ ").append(replacement);
			overlay = replacement;
		}
		lines.add(String.format("Overlay: ID %d -> %s", overlayId, replacementPath));
		lines.add("GroundMaterial: " + overlay.groundMaterial);

		int underlayId = scene.getUnderlayIds()[tileZ][tileExX][tileExY];
		var underlay = tileOverrideManager.getOverrideBeforeReplacements(worldPos, underlayId);
		replacementPath = new StringBuilder(underlay.toString());
		while (true) {
			var replacement = tileOverrideManager.resolveNextReplacement(underlay, tile);
			if (replacement == underlay)
				break;
			replacementPath.append("\n\t⤷ ").append(replacement);
			underlay = replacement;
		}
		lines.add(String.format("Underlay: ID %d -> %s", underlayId, replacementPath));
		lines.add("GroundMaterial: " + underlay.groundMaterial);

		Color polyColor = Color.LIGHT_GRAY;
		if (paint != null)
		{
			polyColor = Color.CYAN;
			lines.add("Tile type: Paint");
			Material material = Material.fromVanillaTexture(paint.getTexture());
			lines.add(String.format("Material: %s (%d)", material.name(), paint.getTexture()));
			int[] hsl = new int[3];
			HDUtils.getSouthWesternMostTileColor(hsl, tile);
			lines.add(String.format("HSL: %s", Arrays.toString(hsl)));

			var override = tileOverrideManager.getOverride(scene, tile, worldPos, OVERLAY_FLAG | overlayId, underlayId);
			lines.add("WaterType: " + proceduralGenerator.seasonalWaterType(override, paint.getTexture()));
		}
		else if (model != null)
		{
			polyColor = Color.ORANGE;
			lines.add("Tile type: Model");
			lines.add(String.format("Face count: %d", model.getFaceX().length));

			HashSet<String> uniqueMaterials = new HashSet<>();
			int numChars = 0;
			if (model.getTriangleTextureId() != null)
			{
				for (int texture : model.getTriangleTextureId())
				{
					String material = String.format("%s (%d)", Material.fromVanillaTexture(texture).name(), texture);
					boolean unique = uniqueMaterials.add(material);
					if (unique)
					{
						numChars += material.length();
					}
				}
			}

			ArrayList<String> materials = new ArrayList<>(uniqueMaterials);
			Collections.sort(materials);

			if (materials.size() <= 1 || numChars < 26)
			{
				StringBuilder sb = new StringBuilder("Materials: { ");
				if (materials.isEmpty())
				{
					sb.append("null");
				}
				else
				{
					String prefix = "";
					for (String m : materials)
					{
						sb.append(prefix).append(m);
						prefix = ", ";
					}
				}
				sb.append(" }");
				lines.add(sb.toString());
			}
			else
			{
				Iterator<String> iter = materials.iterator();
				lines.add("Materials: { " + iter.next() + ",");
				while (iter.hasNext())
				{
					lines.add("\t  " + iter.next() + (iter.hasNext() ? "," : " }"));
				}
			}

			int[] hsl = new int[3];
			HDUtils.getSouthWesternMostTileColor(hsl, tile);
			lines.add(String.format("HSL: %s", Arrays.toString(hsl)));
		}

		GroundObject groundObject = tile.getGroundObject();
		if (groundObject != null) {
			lines.add(String.format(
				"Ground Object: ID=%s preori=%d",
				getIdAndImpostorId(groundObject, groundObject.getRenderable()),
				HDUtils.getBakedOrientation(groundObject.getConfig())
			));
		}

		WallObject wallObject = tile.getWallObject();
		if (wallObject != null) {
			lines.add(String.format(
				"Wall Object: ID=%s bakedOri=%d oriA=%d oriB=%d",
				getIdAndImpostorId(wallObject, wallObject.getRenderable1()),
				HDUtils.getBakedOrientation(wallObject.getConfig()),
				wallObject.getOrientationA(),
				wallObject.getOrientationB()
			));
		}

		GameObject[] gameObjects = tile.getGameObjects();
		for (GameObject gameObject : gameObjects) {
			if (gameObject == null)
				continue;
			int height = -1;
			var renderable = gameObject.getRenderable();
			if (renderable != null)
				height = renderable.getModelHeight();

			lines.add(String.format(
				"%s: ID=%s preori=%d ori=%d height=%d",
				ModelHash.getTypeName(ModelHash.getType(gameObject.getHash())),
				getIdAndImpostorId(gameObject, renderable),
				HDUtils.getBakedOrientation(gameObject.getConfig()),
				gameObject.getModelOrientation(),
				height
			));
		}

		for (GraphicsObject graphicsObject : client.getGraphicsObjects()) {
			var lp = graphicsObject.getLocation();
			if (lp.getSceneX() == tileX && lp.getSceneY() == tileY)
				lines.add(String.format("Graphics Object: ID=%s", graphicsObject.getId()));
		}

		for (int i = 0; i < lines.size(); i++) {
			var moreLines = lines.get(i).split("\\n");
			if (moreLines.length > 1) {
				//noinspection SuspiciousListRemoveInLoop
				lines.remove(i);
				lines.addAll(i, List.of(moreLines));
			}
		}

		int padding = 4;
		int xPadding = padding * 2;
		FontMetrics fm = g.getFontMetrics();
		int lineHeight = fm.getHeight();
		int totalHeight = lineHeight * lines.size() + padding * 3;
		int space = fm.stringWidth(": ");
		int indent = fm.stringWidth("{ ");

		int leftWidth = 0;
		int rightWidth = 0;

		Function<String, Pair<String, String>> splitter = line ->
		{
			int i = line.indexOf(":");
			String left = line;
			String right = "";
			if (left.startsWith("\t"))
			{
				right = left;
				left = "";
			} else if (i != -1)
			{
				left = line.substring(0, i);
				right = line.substring(i + 1);
			}

			return Pair.of(left, right);
		};

		for (String line : lines)
		{
			Pair<String, String> pair = splitter.apply(line);
			if (pair.getRight().isEmpty())
			{
				int halfWidth = fm.stringWidth(pair.getLeft()) / 2;
				leftWidth = Math.max(leftWidth, halfWidth);
				rightWidth = Math.max(rightWidth, halfWidth);
			}
			else
			{
				leftWidth = Math.max(leftWidth, fm.stringWidth(pair.getLeft()));
				rightWidth = Math.max(rightWidth, fm.stringWidth(pair.getRight()));
			}
		}

		Rectangle2D polyBounds = poly.getBounds2D();
		Point tileCenter = new Point((int) polyBounds.getCenterX(), (int) polyBounds.getCenterY());

		var bounds = g.getClipBounds();

		int totalWidth = leftWidth + rightWidth + space + xPadding * 2;
		Rectangle rect = new Rectangle(
			clamp(tileCenter.getX() - totalWidth / 2, bounds.x, bounds.x + bounds.width - totalWidth),
			clamp(tileCenter.getY() - totalHeight - padding, bounds.y, bounds.y + bounds.height - totalHeight),
			totalWidth,
			totalHeight
		);
		if (dodgeRect != null && dodgeRect.intersects(rect))
		{
			// Avoid overlapping with other tile info
			rect.y = dodgeRect.y - rect.height - padding;
		}

		if (tile.getBridge() != null)
		{
			polyColor = Color.MAGENTA;
		}
		g.setColor(polyColor);
		g.drawPolygon(poly);

		g.setColor(new Color(0, 0, 0, 100));
		g.fillRect(rect.x, rect.y, rect.width, rect.height);

		int offsetY = 0;
		for (String line : lines)
		{
			Pair<String, String> pair = splitter.apply(line);
			offsetY += lineHeight;
			Point p;
			if (pair.getRight().isEmpty())
			{
				// centered
				p = new Point(
					rect.x + rect.width / 2 - fm.stringWidth(pair.getLeft()) / 2,
					rect.y + padding + offsetY);
			}
			else
			{
				// left & right
				p = new Point(
					rect.x + xPadding + leftWidth - fm.stringWidth(pair.getLeft()) + (pair.getRight().startsWith("\t") ? indent : 0),
					rect.y + padding + offsetY);
			}
			OverlayUtil.renderTextLocation(g, p, line, Color.WHITE);
		}

		return rect;
	}

	private String getIdAndImpostorId(TileObject object, @Nullable Renderable renderable) {
		int id = object.getId();
		int impostorId = getIdOrImpostorId(object, renderable);
		return id + (id == impostorId ? "" : " -> " + impostorId);
	}

	private int getIdOrImpostorId(TileObject object, @Nullable Renderable renderable) {
		return ModelHash.getUuidId(ModelHash.generateUuid(client, object.getHash(), renderable));
	}

	/**
	 * Returns a polygon representing a tile.
	 *
	 * @param client the game client
	 * @param tile   the tile
	 * @return a polygon representing the tile
	 */
	public static Polygon getCanvasTilePoly(@Nonnull Client client, Scene scene, Tile tile) {
		LocalPoint lp = tile.getLocalLocation();
		int tileExX = lp.getSceneX() + SCENE_OFFSET;
		int tileExY = lp.getSceneY() + SCENE_OFFSET;
		int plane = tile.getRenderLevel();
		if (tileExX < 0 || tileExY < 0 || tileExX >= EXTENDED_SCENE_SIZE || tileExY >= EXTENDED_SCENE_SIZE) {
			return null;
		}

		final int swX = lp.getX() - LOCAL_TILE_SIZE / 2;
		final int swY = lp.getY() - LOCAL_TILE_SIZE / 2;

		final int neX = lp.getX() + LOCAL_TILE_SIZE / 2;
		final int neY = lp.getY() + LOCAL_TILE_SIZE / 2;

		final int swHeight = getHeight(scene, swX, swY, plane);
		final int nwHeight = getHeight(scene, neX, swY, plane);
		final int neHeight = getHeight(scene, neX, neY, plane);
		final int seHeight = getHeight(scene, swX, neY, plane);

		Point p1 = localToCanvas(client, swX, swY, swHeight);
		Point p2 = localToCanvas(client, neX, swY, nwHeight);
		Point p3 = localToCanvas(client, neX, neY, neHeight);
		Point p4 = localToCanvas(client, swX, neY, seHeight);

		if (p1 == null || p2 == null || p3 == null || p4 == null) {
			return null;
		}

		Polygon poly = new Polygon();
		poly.addPoint(p1.getX(), p1.getY());
		poly.addPoint(p2.getX(), p2.getY());
		poly.addPoint(p3.getX(), p3.getY());
		poly.addPoint(p4.getX(), p4.getY());

		return poly;
	}

	private static int getHeight(Scene scene, int localX, int localY, int plane) {
		int sceneX = (localX >> LOCAL_COORD_BITS) + SCENE_OFFSET;
		int sceneY = (localY >> LOCAL_COORD_BITS) + SCENE_OFFSET;
		if (sceneX < 0 || sceneY < 0 || sceneX >= EXTENDED_SCENE_SIZE || sceneY >= EXTENDED_SCENE_SIZE)
			return 0;

		int[][][] tileHeights = scene.getTileHeights();
		int x = localX & (LOCAL_TILE_SIZE - 1);
		int y = localY & (LOCAL_TILE_SIZE - 1);
		int var8 =
			x * tileHeights[plane][sceneX + 1][sceneY] + (LOCAL_TILE_SIZE - x) * tileHeights[plane][sceneX][sceneY] >> LOCAL_COORD_BITS;
		int var9 = tileHeights[plane][sceneX][sceneY + 1] * (LOCAL_TILE_SIZE - x) + x * tileHeights[plane][sceneX + 1][sceneY + 1]
				   >> LOCAL_COORD_BITS;
		return (LOCAL_TILE_SIZE - y) * var8 + y * var9 >> 7;
	}

	private static Point localToCanvas(@Nonnull Client client, int x, int y, int z) {
		x -= client.getCameraX();
		y -= client.getCameraY();
		z -= client.getCameraZ();
		int cameraPitch = client.getCameraPitch();
		int cameraYaw = client.getCameraYaw();
		long pitchSin = SINE[cameraPitch];
		long pitchCos = COSINE[cameraPitch];
		long yawSin = SINE[cameraYaw];
		long yawCos = COSINE[cameraYaw];
		long x1 = x * yawCos + y * yawSin >> 16;
		long y1 = y * yawCos - x * yawSin >> 16;
		long y2 = z * pitchCos - y1 * pitchSin >> 16;
		long z1 = y1 * pitchCos + z * pitchSin >> 16;
		if (z1 >= 1) {
			long scale = client.getScale();
			long pointX = client.getViewportWidth() / 2 + x1 * scale / z1;
			long pointY = client.getViewportHeight() / 2 + y2 * scale / z1;
			return new Point((int) (pointX + client.getViewportXOffset()), (int) (pointY + client.getViewportYOffset()));
		}

		return null;
	}

	private static String hslString(int color) {
		if (color == 12345678)
			return "HIDDEN";
		return color + " (" + (color >> 10 & 0x3F) + ", " + (color >> 7 & 7) + ", " + (color & 0x7F) + ")";
	}

	private void drawAllIds(Graphics2D g, SceneContext ctx) {
		zoom = client.get3dZoom() / 1000.f;
		if (zoom > 1.2f) {
			fontSize = Math.min(16, 11 * zoom);
		} else {
			fontSize = Math.max(7.8f, 14 * (float) Math.sqrt(zoom));
		}
		g.setFont(FontManager.getDefaultFont().deriveFont(fontSize));
		g.setColor(new Color(255, 255, 255, 127));

		Tile[][][] tiles = ctx.scene.getExtendedTiles();
		int plane = ctrlHeld ? MAX_Z - 1 : client.getPlane();
		for (int z = plane; z >= 0; z--) {
			for (int x = 0; x < EXTENDED_SCENE_SIZE; x++) {
				for (int y = 0; y < EXTENDED_SCENE_SIZE; y++) {
					Tile tile = tiles[z][x][y];
					if (tile == null)
						continue;

					var lp = tile.getLocalLocation();
					int lines = 0;
					for (int isBridge = 1; isBridge >= 0; isBridge--) {
						var t = tile;
						if (isBridge == 1) {
							t = tile.getBridge();
							if (t == null)
								continue;
						}

						GroundObject groundObject = t.getGroundObject();
						if (groundObject != null)
							drawTileObjectInfo(g, lp, groundObject, groundObject.getRenderable(), lines++);

						WallObject wallObject = t.getWallObject();
						if (wallObject != null)
							drawTileObjectInfo(g, lp, wallObject, wallObject.getRenderable1(), lines++);

						for (GameObject gameObject : t.getGameObjects())
							if (gameObject != null)
								drawTileObjectInfo(g, lp, gameObject, gameObject.getRenderable(), lines++);
					}
				}
			}
		}
	}

	private void drawTileObjectInfo(Graphics2D g, LocalPoint lp, TileObject object, Renderable renderable, int line) {
		int type = ModelHash.getType(object.getHash());
		String str;
		if (zoom > 1.2f) {
			str = ModelHash.getTypeName(type) + ": " + getIdAndImpostorId(object, renderable);
		} else {
			str = ModelHash.getTypeNameShort(type) + ": " + getIdOrImpostorId(object, renderable);
		}
		var p = Perspective.getCanvasTextLocation(client, g, lp, str, object.getPlane() * 240);
		if (p == null)
			return;
		g.drawString(str, p.getX(), p.getY() + line * fontSize);
	}

	@Override
	public MouseEvent mouseClicked(MouseEvent e) {
		return e;
	}

	@Override
	public MouseEvent mousePressed(MouseEvent e) {
		if (shiftToggled)
			return e;

		if (e.isAltDown()) {
			e.consume();

			if (SwingUtilities.isRightMouseButton(e)) {
				// Reset selection
				aabbMarkingStage = 0;
				markedWorldPoints[0] = null;
			} else if (SwingUtilities.isLeftMouseButton(e)) {
				if (aabbMarkingStage == 0) {
					// Marking first
					markedWorldPoints[0] = hoveredWorldPoint;
					markedHeights[0] = hoveredHeight;
				} else {
					// Done marking
					var markedAabb = new AABB(markedWorldPoints[0], markedWorldPoints[1]);
					Clipboard clipboard = Toolkit.getDefaultToolkit().getSystemClipboard();
					StringSelection string = new StringSelection("new AABB(" + markedAabb.toArgs() + "),\n");
					clipboard.setContents(string, null);
					clientThread.invoke(() -> client.addChatMessage(
						ChatMessageType.GAMEMESSAGE,
						"117 HD",
						ColorUtil.wrapWithColorTag("[117 HD] Copied AABB to clipboard: " + markedAabb.toArgs(), Color.GREEN),
						"117 HD"
					));
				}
				aabbMarkingStage = (aabbMarkingStage + 1) % 2;
			}
		}

		return e;
	}

	@Override
	public MouseEvent mouseReleased(MouseEvent e) {
		return e;
	}

	@Override
	public MouseEvent mouseEntered(MouseEvent e) {
		return e;
	}

	@Override
	public MouseEvent mouseExited(MouseEvent e) {
		return e;
	}

	@Override
	public MouseEvent mouseDragged(MouseEvent e) {
		return e;
	}

	@Override
	public MouseEvent mouseMoved(MouseEvent e) {
		return e;
	}

	@Override
	public MouseWheelEvent mouseWheelMoved(MouseWheelEvent e) {
		if (ctrlHeld && !shiftToggled) {
			e.consume();
			targetPlane = HDUtils.clamp(targetPlane + e.getWheelRotation(), 0, MAX_Z - 1);
		}

		return e;
	}
}

package rs117.hd.overlays;

import java.util.Arrays;

public class FrameTimings {
	final long frameTimestamp;
	final long[] timers;

	public FrameTimings(long frameTimestamp, long[] timers) {
		this.frameTimestamp = frameTimestamp;
		this.timers = Arrays.copyOf(timers, timers.length);
	}
}

package rs117.hd.overlays;

import java.awt.BasicStroke;
import java.awt.Color;
import java.awt.Dimension;
import java.awt.FontMetrics;
import java.awt.Graphics;
import java.awt.Graphics2D;
import java.awt.MouseInfo;
import java.awt.Stroke;
import java.awt.Toolkit;
import java.awt.datatransfer.Clipboard;
import java.awt.datatransfer.StringSelection;
import java.awt.event.KeyEvent;
import java.awt.event.MouseEvent;
import java.util.ArrayDeque;
import java.util.ArrayList;
import java.util.Arrays;
import javax.inject.Inject;
import javax.inject.Singleton;
import javax.swing.SwingUtilities;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.*;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.input.KeyListener;
import net.runelite.client.input.KeyManager;
import net.runelite.client.input.MouseListener;
import net.runelite.client.input.MouseManager;
import net.runelite.client.ui.FontManager;
import net.runelite.client.ui.overlay.Overlay;
import net.runelite.client.ui.overlay.OverlayLayer;
import net.runelite.client.ui.overlay.OverlayManager;
import net.runelite.client.ui.overlay.OverlayPosition;
import net.runelite.client.util.ColorUtil;
import org.apache.commons.lang3.NotImplementedException;
import rs117.hd.HdPlugin;
import rs117.hd.scene.lights.Alignment;
import rs117.hd.scene.lights.Light;
import rs117.hd.scene.lights.LightType;
import rs117.hd.utils.ColorUtils;
import rs117.hd.utils.Mat4;
import rs117.hd.utils.Vector;

import static net.runelite.api.Perspective.*;
import static rs117.hd.HdPlugin.NEAR_PLANE;

@Slf4j
@Singleton
public class LightGizmoOverlay extends Overlay implements MouseListener, KeyListener {
	private static final Color ORANGE = Color.decode("#ff9f2c");

	@Inject
	private Client client;

	@Inject
	private ClientThread clientThread;

	@Inject
	private OverlayManager overlayManager;

	@Inject
	private MouseManager mouseManager;

	@Inject
	private KeyManager keyManager;

	@Inject
	private HdPlugin plugin;

	private boolean hideInvisibleLights;
	private boolean hideRadiusRings = true;
	private boolean hideAnimLights;
	private boolean hideLabels;
	private boolean hideInfo = true;
	private boolean toggleBlackColor;
	private boolean liveInfo;
	private boolean showDuplicationInfo;
	private boolean toggleOpacity = true;
	private boolean followMouse;

	private Action action = Action.SELECT;
	private final double[] rawMousePos = new double[2];
	private final double[] rawMousePosPrev = new double[2];
	private final double[] mouseDelta = new double[2];
	private final float[] cameraOrientation = new float[2];
	private Alignment originalLightAlignment = Alignment.CUSTOM;
	private final int[] originalLightPosition = new int[3];
	private final int[] originalLightOffset = new int[3];
	private final int[] currentLightOffset = new int[3];
	private int freezeMode = 0;
	private final boolean[] frozenAxes = { false, true, false }; // by default, restrict movement to the same height
	private final ArrayList<Light> selections = new ArrayList<>();
	private final ArrayList<Light> hovers = new ArrayList<>();
	private boolean isProbablyRotatingCamera;

	private static final int RELATIVE_TO_CAMERA = 0;
	private static final int RELATIVE_TO_ORIGIN = 1;
	private static final int RELATIVE_TO_POSITION = 2;

	// TODO: implement undo & redo
	private ArrayDeque<Change> history = new ArrayDeque<>();

	interface Change {
		void undo();
		void redo();
	}

	enum Action {
		SELECT, GRAB, SCALE
	}

	public LightGizmoOverlay() {
		setLayer(OverlayLayer.ABOVE_SCENE);
		setPosition(OverlayPosition.DYNAMIC);
	}

	public void setActive(boolean activate) {
		if (activate) {
			overlayManager.add(this);
			mouseManager.registerMouseListener(this);
			keyManager.registerKeyListener(this);
		} else {
			overlayManager.remove(this);
			mouseManager.unregisterMouseListener(this);
			keyManager.unregisterKeyListener(this);
			action = Action.SELECT;
			selections.clear();
		}
	}

	@Override
	public Dimension render(Graphics2D g) {
		var sceneContext = plugin.getSceneContext();
		if (sceneContext == null)
			return null;

		// If the orientation changed, don't consider mouse movement
		boolean wasCameraReoriented = isProbablyRotatingCamera;
		for (int j = 0; j < 2; j++) {
			if (cameraOrientation[j] != plugin.cameraOrientation[j]) {
				wasCameraReoriented = true;
				break;
			}
		}
		System.arraycopy(plugin.cameraOrientation, 0, cameraOrientation, 0, 2);

		boolean isCtrlHeld = client.isKeyPressed(KeyCode.KC_CONTROL);
		boolean isShiftHeld = client.isKeyPressed(KeyCode.KC_SHIFT);
		boolean isAltHeld = client.isKeyPressed(KeyCode.KC_ALT);

		var rawMouse = MouseInfo.getPointerInfo().getLocation();
		rawMousePos[0] = (float) rawMouse.getX();
		rawMousePos[1] = (float) rawMouse.getY();
		if (wasCameraReoriented) {
			if (action == Action.GRAB) {
				assert !selections.isEmpty();
				// Rotation & moving the light with the mouse don't mix very well, so apply the offset and reset mouseDelta when rotating
				if (mouseDelta[0] != 0 || mouseDelta[1] != 0) {
					Arrays.fill(mouseDelta, 0);
					var selection = selections.get(0);
					System.arraycopy(selection.offset, 0, currentLightOffset, 0, 3);
				}
			}
		} else if (!isAltHeld) {
			double scalingFactor = isShiftHeld ? .1 : 1;
			for (int j = 0; j < 2; j++)
				mouseDelta[j] += (rawMousePos[j] - rawMousePosPrev[j]) * scalingFactor;
		}
		System.arraycopy(rawMousePos, 0, rawMousePosPrev, 0, 2);

		var mousePoint = new java.awt.Point((int) Math.round(rawMousePos[0]), (int) Math.round(rawMousePos[1]));
		SwingUtilities.convertPointFromScreen(mousePoint, client.getCanvas());
		int[] mousePos = { mousePoint.x, mousePoint.y };

		Point mousePosCanvas = client.getMouseCanvasPosition();
		if (mousePosCanvas != null && (mousePosCanvas.getX() == -1 || mousePosCanvas.getY() == -1))
			mousePosCanvas = null;

		g.setFont(FontManager.getRunescapeSmallFont());

		final int innerDotDiameter = 6;
		final int innerHandleRingDiameter = 19;
		final int outerHandleRingDiameter = 25;
		final int hoverDistanceMargin = 5;

		Stroke thickLine = new BasicStroke(2);
		Stroke thinLine = new BasicStroke(1);
		Stroke thinnerLine = new BasicStroke(.75f);
		Stroke thinDashedLine = new BasicStroke(
			1, BasicStroke.CAP_BUTT, BasicStroke.JOIN_BEVEL,
			0, new float[] { 3 }, 0
		);
		Stroke thinLongDashedLine = new BasicStroke(
			1, BasicStroke.CAP_BUTT, BasicStroke.JOIN_BEVEL,
			0, new float[] { 10 }, 0
		);
		Stroke thickDashedLine = new BasicStroke(
			1.5f, BasicStroke.CAP_BUTT, BasicStroke.JOIN_BEVEL,
			0, new float[] { 3 }, 0
		);

		float[] projectionMatrix = Mat4.identity();
		int viewportWidth = client.getViewportWidth();
		int viewportHeight = client.getViewportHeight();
		Mat4.mul(projectionMatrix, Mat4.translate(client.getViewportXOffset(), client.getViewportYOffset(), 0));
		Mat4.mul(projectionMatrix, Mat4.scale(viewportWidth, viewportHeight, 1));
		Mat4.mul(projectionMatrix, Mat4.translate(.5f, .5f, .5f));
		Mat4.mul(projectionMatrix, Mat4.scale(.5f, -.5f, .5f));
		// NDC clip space
		Mat4.mul(projectionMatrix, Mat4.scale(client.getScale(), client.getScale(), 1));
		Mat4.mul(projectionMatrix, Mat4.projection(viewportWidth, viewportHeight, NEAR_PLANE));
		Mat4.mul(projectionMatrix, Mat4.rotateX(plugin.cameraOrientation[1]));
		Mat4.mul(projectionMatrix, Mat4.rotateY(plugin.cameraOrientation[0]));
		Mat4.mul(projectionMatrix, Mat4.translate(
			-plugin.cameraPosition[0],
			-plugin.cameraPosition[1],
			-plugin.cameraPosition[2]
		));

		float[] inverseProjection = null;
		try {
			inverseProjection = Mat4.inverse(projectionMatrix);
		} catch (IllegalArgumentException ex) {
			log.warn("Not invertible:\n{}", Mat4.format(projectionMatrix));
		}

		int numFrozenAxes = 0;
		if (freezeMode > 0)
			for (int i = 0; i < 3; i++)
				if (frozenAxes[i])
					numFrozenAxes++;

		hovers.clear();
		int counter = 0;
		final float[] lightToCamera = new float[3];
		var lights = sceneContext.lights;

		float[] point = new float[4];
		int selectedIndex = -1;
		for (int i = lights.size() - 1; i >= -1; i--) {
			// Draw the selected light last
			int lightIndex = i;
			if (i == -1) {
				lightIndex = selectedIndex;
				if (lightIndex == -1)
					continue;
			}

			Light l = lights.get(lightIndex);

			if (hideInvisibleLights && !l.def.visibleFromOtherPlanes &&
				(l.plane < client.getPlane() && l.belowFloor || l.plane > client.getPlane() && l.aboveFloor))
				continue;

			if (hideAnimLights && !l.def.animationIds.isEmpty() && !l.parentExists)
				continue;

			boolean isHovered = !hovers.isEmpty() && hovers.get(0) == l;
			boolean isSelected = selections.contains(l);

			// Skip the selected light until the end
			if (i != -1 && isSelected) {
				selectedIndex = i;
				continue;
			}

			if (isSelected && !wasCameraReoriented && inverseProjection != null) {
				if (action == Action.GRAB) {
					float[] oldLightPos = new float[4];
					float[] newLightPos = new float[4];

					float radians = (float) (l.orientation * UNIT);
					float sin = (float) Math.sin(radians);
					float cos = (float) Math.cos(radians);

					// Project the light's current position into screen space
					for (int j = 0; j < 3; j++)
						oldLightPos[j] = l.origin[j];
					float x = currentLightOffset[0];
					float z = currentLightOffset[2];
					oldLightPos[0] += -cos * x - sin * z;
					oldLightPos[1] += currentLightOffset[1];
					oldLightPos[2] += -cos * z + sin * x;
					oldLightPos[3] = 1;
					Mat4.projectVec(point, projectionMatrix, oldLightPos);

					if (followMouse) {
						// Move the light to the mouse position
						for (int j = 0; j < 2; j++)
							point[j] = mousePos[j];
					} else {
						// Shift the position with mouse movement
						for (int j = 0; j < 2; j++)
							point[j] += (float) mouseDelta[j];
					}

					if (numFrozenAxes == 0) { // restrict to same depth plane
						// Project the screen position back into the new light position
						Mat4.projectVec(newLightPos, inverseProjection, point);
						if (point[3] <= 0)
							continue;
					} else {
						// p1 & v1 = ray from the camera in the hovered direction
						var p1 = plugin.cameraPosition;
						var v1 = new float[3];

						// Compute a vector from the camera to the target mouse position
						Mat4.projectVec(point, inverseProjection, point);
						for (int j = 0; j < 3; j++)
							v1[j] = point[j] - p1[j];

						if (numFrozenAxes == 1) {
							// restrict to basis plane
							// ax + by + cz = d
							// n = (a, b, c)
							float[] n = new float[3];
							for (int j = 0; j < 3; j++) {
								if (frozenAxes[j]) {
									n[j] = 1;
									break;
								}
							}

							if (freezeMode == RELATIVE_TO_ORIGIN) {
								for (int j = 0; j < 3; j++)
									oldLightPos[j] = l.origin[j];
								oldLightPos[3] = 1;
								Mat4.projectVec(point, projectionMatrix, oldLightPos);
							}

							float d = Vector.dot(n, oldLightPos);

							// dot(p1 + v1 * t, n) = d
							// dot(p1, n) + dot(v1 * t, n) = d
							// dot(p1, n) + dot(v1, n) * t = d
							// t = (d - dot(p1, n)) / dot(v1, n)
							float t = (d - Vector.dot(p1, n)) / Vector.dot(v1, n);

							for (int j = 0; j < 3; j++)
								newLightPos[j] = p1[j] + v1[j] * t;
						} else if (numFrozenAxes == 2) {
							// restrict to axis
							int axis = 0;
							for (int j = 0; j < 3; j++) {
								if (!frozenAxes[j]) {
									axis = j;
									break;
								}
							}

							// p2 & v2 = ray from the light's origin in the direction of the target axis
							var p2 = new float[3];
							var origin = freezeMode == RELATIVE_TO_ORIGIN ? l.origin : originalLightPosition;
							for (int j = 0; j < 3; j++)
								p2[j] = origin[j];
							var v2 = new float[3];
							v2[axis] = 1;

							// v3 is the direction perpendicular to both v1 and v2, which is the direction
							// for the shortest path between two points on the two rays
							var v3 = new float[3];
							Vector.cross(v3, v1, v2);

							try {
								// Solve the following set of linear equations to find t2; the distance
								// from p2 along v2 until the closest point between the two rays:
								// p1 + v1 * t1 + v3 * t3 = p2 + v2 * t2

								// Solve for t2:
								float t2 = -p1[0] * v1[1] * v3[2] + p1[0] * v1[2] * v3[1] + p1[1] * v1[0] * v3[2] - p1[1] * v1[2] * v3[0]
										   - p1[2] * v1[0] * v3[1] + p1[2] * v1[1] * v3[0] + p2[0] * v1[1] * v3[2] - p2[0] * v1[2] * v3[1]
										   - p2[1] * v1[0] * v3[2] + p2[1] * v1[2] * v3[0] + p2[2] * v1[0] * v3[1] - p2[2] * v1[1] * v3[0];
								t2 /= v1[0] * v2[1] * v3[2] - v1[0] * v2[2] * v3[1] - v1[1] * v2[0] * v3[2] + v1[1] * v2[2] * v3[0]
									  + v1[2] * v2[0] * v3[1] - v1[2] * v2[1] * v3[0];

								for (int j = 0; j < 3; j++)
									newLightPos[j] = p2[j] + v2[j] * t2;
							} catch (IllegalArgumentException ex) {
								log.debug("No solution:", ex);
							}
						}
					}

					float gridSize = isCtrlHeld ? 128f / (isShiftHeld ? 8 : 1) : 1;

					float[] relativePos = new float[3];
					for (int j = 0; j < 3; j++)
						relativePos[j] = newLightPos[j] - l.origin[j];

					x = relativePos[0];
					z = relativePos[2];
					relativePos[0] = -cos * x + sin * z;
					relativePos[2] = -cos * z - sin * x;

					for (int j = 0; j < 3; j++)
						l.offset[j] = (int) (Math.round(relativePos[j] / gridSize) * gridSize);

					x = l.offset[0];
					z = l.offset[2];
					l.pos[0] = l.origin[0] + (int) (-cos * x - sin * z);
					l.pos[1] = l.origin[1] + l.offset[1];
					l.pos[2] = l.origin[2] + (int) (-cos * z + sin * x);
				}
			}

			for (int j = 0; j < 3; j++)
				point[j] = l.pos[j];
			point[3] = 1;

			Vector.subtract(lightToCamera, plugin.cameraPosition, point);
			float distanceFromCamera = Vector.length(lightToCamera);

			Mat4.projectVec(point, projectionMatrix, point);
			if (point[3] <= 0)
				continue;
			int x = Math.round(point[0]);
			int y = Math.round(point[1]);

			// Take perspective depth into account
			int currentDiameter = Math.round(l.radius * 2 / distanceFromCamera * client.getScale());
			float definedDiameter = l.def.radius * 2 / distanceFromCamera * client.getScale();
			float fRange = l.def.range / 100f;
			int minDiameter = Math.round(definedDiameter * (1 - fRange));
			int maxDiameter = Math.round(definedDiameter * (1 + fRange));

			if (mousePosCanvas != null) {
				float d = Vector.length(mousePosCanvas.getX() - x, mousePosCanvas.getY() - y);
				if (d <= outerHandleRingDiameter / 2f + hoverDistanceMargin ||
					!hideRadiusRings && Math.abs(d - currentDiameter / 2f) < hoverDistanceMargin * 2)
					hovers.add(l);
			}

			int mainOpacity = toggleOpacity ?
				(l.visible ? 255 : 100) :
				(l.visible ? 100 : 30);
			int rangeOpacity = 70;
			Color baseColor = toggleBlackColor ? Color.BLACK : Color.WHITE;
			Color radiusRingColor = alpha(baseColor, mainOpacity);
			Color rangeRingsColor = alpha(baseColor, rangeOpacity);
			Color handleRingsColor = radiusRingColor;
			Color textColor = Color.WHITE;
			Stroke handleRingsStroke = thinDashedLine;

			if (isSelected) {
				handleRingsColor = radiusRingColor = rangeRingsColor = ORANGE;
				handleRingsStroke = thickDashedLine;
			} else if (isHovered) {
				radiusRingColor = Color.YELLOW;
				handleRingsColor = Color.WHITE;
			} else {
				textColor = alpha(textColor, mainOpacity);
			}

			// Draw handle rings
			drawRing(g, x, y, innerHandleRingDiameter, handleRingsColor, handleRingsStroke);
			drawRing(g, x, y, outerHandleRingDiameter, handleRingsColor, handleRingsStroke);

			// Draw radius rings
			if (!hideRadiusRings) {
				drawRing(g, x, y, currentDiameter, radiusRingColor, thinnerLine);
				if (l.def.type == LightType.PULSE && Math.abs(currentDiameter) > .001f) {
					drawRing(g, x, y, minDiameter, rangeRingsColor, thinLongDashedLine);
					drawRing(g, x, y, maxDiameter, rangeRingsColor, thinLongDashedLine);
				}
			}

			// Only the selected dot has a filled dot in the center
			if (isSelected) {
				fillOutlinedCircle(g, x, y, innerDotDiameter, ORANGE, handleRingsColor, thinLine);
			} else {
				drawCircleOutline(g, x, y, innerDotDiameter, handleRingsColor, thinLine);
			}

			g.setColor(textColor);
			if (!hideLabels) {
				String info = l.def.description;
				if (showDuplicationInfo) {
					int newlines = (counter++ % 5) + 1;
					info += "\n".repeat(newlines);
					info += counter + ": " + l.hash;
					info += "\n".repeat(5 - newlines);
				}
				if (isSelected && !hideInfo) {
					info += String.format("\nradius: %d", liveInfo ? l.radius : l.def.radius);
					info += String.format("\nstrength: %.1f", liveInfo ? l.strength : l.def.strength);
					var color = ColorUtils.linearToSrgb(l.def.color);
					info += String.format("\ncolor: [%.0f, %.0f, %.0f]", color[0] * 255, color[1] * 255, color[2] * 255);
					// Technically negative Y is up, but invert this in the info shown
					info += String.format(
						"\norigin: [%d, %d%s, %d]",
						l.origin[0],
						-(l.origin[1] + l.def.height),
						l.def.height == 0 ? "" : " + " + l.def.height,
						l.origin[2]
					);
					info += String.format("\noffset: [%d, %d, %d]", l.offset[0], -l.offset[1], l.offset[2]);
					info += String.format("\norientation: %d", l.orientation);
				}
				drawAlignedString(g, info, x, y + 25, TextAlignment.CENTER_ON_COLONS);
			}
		}

		if (!selections.isEmpty()) {
			switch (action) {
				case GRAB:
					Light l = selections.get(0);
					var lightOrigin = freezeMode == RELATIVE_TO_ORIGIN ? l.origin : originalLightPosition;
					for (int i = 0; i < 3; i++)
						point[i] = lightOrigin[i];
					point[3] = 1;
					float[] origin = new float[4];
					Mat4.projectVec(origin, projectionMatrix, point);
					if (point[3] <= 0)
						break;

					if (numFrozenAxes > 0) {
						Color[] axisColors = {
							new Color(0xef738c),
							new Color(0x9fd853),
							new Color(0x75ace1),
						};
						g.setStroke(thickLine);

						float[] stepAlongAxis = new float[4];
						for (int i = 0; i < 3; i++) {
							if (!frozenAxes[i]) {
								int stepSize = 1000;
								point[i] += stepSize;
								Mat4.projectVec(stepAlongAxis, projectionMatrix, point);
								point[i] -= stepSize;

								g.setColor(axisColors[i]);
								drawLineSpan(g, origin, stepAlongAxis);
							}
						}
					}

					for (int i = 0; i < 3; i++)
						point[i] = l.pos[i];
					point[3] = 1;
					float[] pos = new float[4];
					Mat4.projectVec(pos, projectionMatrix, point);
					if (point[3] <= 0)
						break;

					g.setColor(Color.YELLOW);
					drawLineSegment(g, origin, pos);
					break;
				case SCALE:
					break;
			}
		}

		return null;
	}

	private void drawLineSegment(Graphics2D g, float[] a, float[] b) {
		g.drawLine(
			Math.round(a[0]),
			Math.round(a[1]),
			Math.round(b[0]),
			Math.round(b[1])
		);
	}

	private void drawLineSpan(Graphics2D g, float[] a, float[] b) {
		float[] v = new float[2];
		Vector.subtract(v, b, a);
		if (v[0] == 0 && v[1] == 0)
			return;

		float[] p = new float[2];
		System.arraycopy(a, 0, p, 0, 2);

		var clipBounds = g.getClipBounds();
		float[][] axisBounds = {
			{ 0, clipBounds.width },
			{ 0, clipBounds.height }
		};

		final float INF = Float.POSITIVE_INFINITY;
		final float EPS = 1f;

		// First intersection with an edge within the screen bounds
		float t = INF;
		int intersectedEdge = -1;
		outer:
		for (int axis = 0; axis < 2; axis++) {
			if (v[axis] == 0)
				continue;
			for (int edge = 0; edge < 2; edge++) {
				float d = (axisBounds[axis][edge] - p[axis]) / v[axis];
				int oppositeAxis = (axis + 1) % 2;
				float[] bounds = axisBounds[oppositeAxis];
				float coord = p[oppositeAxis] + v[oppositeAxis] * d;
				if (bounds[0] - EPS < coord && coord < bounds[1] + EPS) {
					t = d;
					intersectedEdge = axis * 2 + edge;
					break outer;
				}
			}
		}
		if (t == INF)
			return;

		// Move the point to the selected edge
		for (int i = 0; i < 2; i++)
			p[i] += v[i] * t;

		t = INF;
		outer:
		for (int axis = 0; axis < 2; axis++) {
			if (v[axis] == 0)
				continue;
			for (int edge = 0; edge < 2; edge++) {
				// Skip the edge we've already intersected with
				if (axis * 2 + edge == intersectedEdge)
					continue;

				float d = (axisBounds[axis][edge] - p[axis]) / v[axis];
				int oppositeAxis = (axis + 1) % 2;
				float[] bounds = axisBounds[oppositeAxis];
				float coord = p[oppositeAxis] + v[oppositeAxis] * d;
				if (bounds[0] - EPS < coord && coord < bounds[1] + EPS) {
					t = d;
					break outer;
				}
			}
		}
		if (t == INF)
			return;

		int x1 = Math.round(p[0]);
		int y1 = Math.round(p[1]);
		int x2 = Math.round(p[0] + v[0] * t);
		int y2 = Math.round(p[1] + v[1] * t);
		g.drawLine(x1, y1, x2, y2);
	}

	private void fillCircle(Graphics2D g, int centerX, int centerY, int diameter, Color color) {
		int r = diameter / 2;
		g.setColor(color);
		g.fillOval(centerX - r, centerY - r, diameter, diameter);
	}

	private void drawRing(Graphics2D g, int centerX, int centerY, int diameter, Color strokeColor, Stroke stroke) {
		// Round down to an odd number
		diameter = (int) Math.ceil(diameter / 2.f) * 2 - 1;
		int r = (int) Math.ceil(diameter / 2.f);
		g.setColor(strokeColor);
		g.setStroke(stroke);
		g.drawOval(centerX - r, centerY - r, diameter, diameter);
	}

	private void fillOutlinedCircle(
		Graphics2D g, int centerX, int centerY, int diameter, Color fillColor, Color strokeColor, Stroke stroke
	) {
		fillCircle(g, centerX, centerY, diameter - 2, fillColor);
		drawCircleOutline(g, centerX, centerY, diameter, strokeColor, stroke);
	}

	private void drawCircleOutline(
		Graphics2D g, int centerX, int centerY, int diameter, Color strokeColor, Stroke stroke
	) {
		int r = (int) Math.ceil(diameter / 2.f);
		int s = diameter - 1;
		g.setColor(strokeColor);
		g.setStroke(stroke);
		g.drawRoundRect(centerX - r, centerY - r, s, s, s - 1, s - 1);
	}

	private enum TextAlignment {
		LEFT, RIGHT, CENTER, CENTER_ON_COLONS
	}

	private void drawCenteredString(Graphics g, String text, int centerX, int centerY, TextAlignment alignment) {
		drawCenteredString(g, text.split("\\n"), centerX, centerY, alignment);
	}

	private void drawCenteredString(Graphics g, String[] lines, int centerX, int centerY, TextAlignment alignment) {
		FontMetrics metrics = g.getFontMetrics();
		int yOffset = metrics.getAscent() - (lines.length * metrics.getHeight()) / 2;
		drawAlignedString(g, lines, centerX, centerY + yOffset, alignment);
	}

	private void drawAlignedString(Graphics g, String text, int centerX, int topY, TextAlignment alignment) {
		drawAlignedString(g, text.split("\\n"), centerX, topY, alignment);
	}

	private void drawAlignedString(Graphics g, String[] lines, int centerX, int topY, TextAlignment alignment) {
		var color = g.getColor();
		var shadow = alpha(Color.BLACK, color.getAlpha());
		FontMetrics metrics = g.getFontMetrics();
		int fontHeight = metrics.getHeight();
		int yOffset = 0;

		if (alignment == TextAlignment.CENTER_ON_COLONS) {
			int longestLeft = 0, longestRight = 0;
			for (String line : lines) {
				int dotIndex = line.indexOf(":");
				String left, right;
				if (dotIndex == -1) {
					left = line;
					right = "";
				} else {
					left = line.substring(0, dotIndex);
					right = line.substring(dotIndex + 1);
				}
				int leftLen = metrics.stringWidth(left);
				if (leftLen > longestLeft) {
					longestLeft = leftLen;
				}
				int rightLen = metrics.stringWidth(right);
				if (rightLen > longestRight) {
					longestRight = rightLen;
				}
			}

			int dotOffset = -metrics.stringWidth(":") / 2;

			for (String line : lines) {
				int dotIndex = line.indexOf(":");
				int xOffset = dotOffset;
				if (dotIndex == -1) {
					xOffset -= metrics.stringWidth(line) / 2;
				} else {
					xOffset -= metrics.stringWidth(line.substring(0, dotIndex));
				}
				g.setColor(shadow);
				g.drawString(line, centerX + xOffset + 1, topY + yOffset + 1);
				g.setColor(color);
				g.drawString(line, centerX + xOffset, topY + yOffset);
				yOffset += fontHeight;
			}
		} else {
			int longestLine = 0;
			if (alignment != TextAlignment.CENTER) {
				for (String line : lines) {
					int length = metrics.stringWidth(line);
					if (longestLine < length) {
						longestLine = length;
					}
				}
			}
			for (String line : lines) {
				int xOffset;
				switch (alignment) {
					case LEFT:
						xOffset = -longestLine / 2;
						break;
					case RIGHT:
						int length = metrics.stringWidth(line);
						xOffset = longestLine / 2 - length;
						break;
					case CENTER:
						xOffset = -metrics.stringWidth(line) / 2;
						break;
					default:
						throw new NotImplementedException("Alignment " + alignment + " has not been implemented");
				}
				g.setColor(shadow);
				g.drawString(line, centerX + xOffset + 1, topY + yOffset + 1);
				g.setColor(color);
				g.drawString(line, centerX + xOffset, topY + yOffset);
				yOffset += fontHeight;
			}
		}
	}

	private Color alpha(Color rgb, int alpha) {
		if (alpha == 255)
			return rgb;
		return new Color(rgb.getRed(), rgb.getGreen(), rgb.getBlue(), alpha);
	}

	private boolean applyPendingChange() {
		if (action == Action.SELECT || selections.isEmpty())
			return false;

		action = Action.SELECT;
		return true;
	}

	private boolean discardPendingChange() {
		if (action == Action.SELECT) {
			if (!selections.isEmpty())
				selections.clear();
			return false;
		}

		if (selections.isEmpty())
			return false;

		if (action == Action.GRAB) {
			// Reset the light back to its original offset
			var l = selections.get(0);
			l.alignment = originalLightAlignment;
			System.arraycopy(originalLightOffset, 0, l.offset, 0, 3);
		}

		action = Action.SELECT;
		return true;
	}

	@Override
	public MouseEvent mouseClicked(MouseEvent e) {
		return e;
	}

	@Override
	public MouseEvent mousePressed(MouseEvent e) {
		if (SwingUtilities.isMiddleMouseButton(e))
			isProbablyRotatingCamera = true;

		switch (action) {
			case SELECT:
				if (SwingUtilities.isLeftMouseButton(e) && e.isControlDown()) {
					e.consume();

					selections.clear();
					if (!hovers.isEmpty()) {
						selections.add(hovers.get(0));
					} else {
						action = Action.SELECT;
					}
				}
				break;
			case GRAB:
				if (SwingUtilities.isLeftMouseButton(e)) {
					if (applyPendingChange())
						e.consume();
				} else if (SwingUtilities.isRightMouseButton(e)) {
					if (discardPendingChange())
						e.consume();
				}
				break;
			case SCALE:
				break;
		}
		return e;
	}

	@Override
	public MouseEvent mouseReleased(MouseEvent e) {
		if (SwingUtilities.isMiddleMouseButton(e))
			isProbablyRotatingCamera = false;
		return e;
	}

	@Override
	public MouseEvent mouseEntered(MouseEvent e) {
		return e;
	}

	@Override
	public MouseEvent mouseExited(MouseEvent e) {
		return e;
	}

	@Override
	public MouseEvent mouseDragged(MouseEvent e) {
		return e;
	}

	@Override
	public MouseEvent mouseMoved(MouseEvent e) {
		return e;
	}

	@Override
	public void keyTyped(KeyEvent e) {}

	@Override
	public void keyPressed(KeyEvent e) {
//		if (e.isControlDown() && e.isShiftDown() && e.getKeyCode() == KeyCode.KC_S) {
//			// TODO: Save changes to JSON
//			// Every time the JSON is updated, either through the file system or exporting changes,
//			// create a checkpoint. Store all checkpoints in memory throughout the client session.
//			// Implement ctrl Z and ctrl shift Z to redo. Forget reverted checkpoints upon file change.
//		}

		// Interaction with selected object
		if (!selections.isEmpty()) {
			var l = selections.get(0);

			if (e.isControlDown() && e.getKeyCode() == KeyEvent.VK_C) {
				String str = "\n    \"offset\": [ " + l.offset[0] + ", " + -l.offset[1] + ", " + l.offset[2] + " ],";

				Clipboard clipboard = Toolkit.getDefaultToolkit().getSystemClipboard();
				StringSelection string = new StringSelection(str);
				clipboard.setContents(string, null);
				clientThread.invoke(() -> client.addChatMessage(
					ChatMessageType.GAMEMESSAGE,
					"117 HD",
					ColorUtil.wrapWithColorTag("[117 HD] Copied offset (must remove alignment): " + str.trim(), Color.GREEN),
					"117 HD"
				));
			}

			if (action == Action.SELECT) {
				switch (e.getKeyCode()) {
					case KeyEvent.VK_G:
						action = Action.GRAB;
						Arrays.fill(mouseDelta, 0);

						originalLightAlignment = l.alignment;
						System.arraycopy(l.offset, 0, originalLightOffset, 0, 3);
						System.arraycopy(l.pos, 0, originalLightPosition, 0, 3);

						l.alignment = Alignment.CUSTOM;
						for (int i = 0; i < 3; i++)
							l.offset[i] = l.pos[i] - l.origin[i];
						System.arraycopy(l.offset, 0, currentLightOffset, 0, 3);
						break;
					case KeyEvent.VK_S:
						action = Action.SCALE;
						break;
				}
			} else if (action == Action.GRAB) {
				int axis = -1;
				boolean cycleFreezeMode = false;
				switch (e.getKeyCode()) {
					case KeyEvent.VK_X:
						axis = 0;
						break;
					case KeyEvent.VK_Y:
						axis = 1;
						break;
					case KeyEvent.VK_Z:
						axis = 2;
						break;
					case KeyEvent.VK_G:
						cycleFreezeMode = true;
						break;
				}
				if (axis != -1) {
					boolean invert = e.isShiftDown();
					boolean modified = false;
					for (int i = 0; i < 3; i++) {
						boolean shouldFreeze = i == axis == invert;
						if (shouldFreeze != frozenAxes[i])
							modified = true;
						frozenAxes[i] = shouldFreeze;
					}
					if (modified) {
						// Reset current offset
						if (freezeMode == 0)
							freezeMode = 1;
						System.arraycopy(originalLightOffset, 0, l.offset, 0, 3);
					} else {
						cycleFreezeMode = true;
					}
				}
				if (cycleFreezeMode) {
					// If the same combination is repeated, cycle through different modes
					freezeMode++;
					freezeMode %= 3;
				}
			}

			switch (e.getKeyCode()) {
				case KeyEvent.VK_ESCAPE:
					if (discardPendingChange())
						e.consume();
					break;
				case KeyEvent.VK_ENTER:
					if (applyPendingChange())
						e.consume();
					break;
				case KeyEvent.VK_BACK_SPACE:
					// Reset light back to its defined offset
					l.alignment = l.def.alignment;
					System.arraycopy(l.def.offset, 0, l.offset, 0, 3);
					System.arraycopy(l.offset, 0, currentLightOffset, 0, 3);
					System.arraycopy(l.offset, 0, originalLightOffset, 0, 3);
					Arrays.fill(mouseDelta, 0);
					break;
			}
		}

		// Toggles
		if (e.isControlDown()) {
			switch (e.getKeyCode()) {
				case KeyEvent.VK_A:
					hideAnimLights = !hideAnimLights;
					break;
				case KeyEvent.VK_B:
					toggleBlackColor = !toggleBlackColor;
					break;
				case KeyEvent.VK_D:
					showDuplicationInfo = !showDuplicationInfo;
					break;
				case KeyEvent.VK_H:
					hideInvisibleLights = !hideInvisibleLights;
					break;
				case KeyEvent.VK_I:
					hideInfo = !hideInfo;
					break;
				case KeyEvent.VK_L:
					hideLabels = !hideLabels;
					break;
				case KeyEvent.VK_M:
					followMouse = !followMouse;
					break;
				case KeyEvent.VK_O:
					toggleOpacity = !toggleOpacity;
					break;
				case KeyEvent.VK_R:
					hideRadiusRings = !hideRadiusRings;
					break;
				case KeyEvent.VK_U:
					liveInfo = !liveInfo;
					break;
			}
		}
	}

	@Override
	public void keyReleased(KeyEvent e) {}
}

package rs117.hd.overlays;

import java.util.ArrayDeque;
import java.util.Arrays;
import javax.inject.Inject;
import javax.inject.Singleton;
import lombok.extern.slf4j.Slf4j;
import net.runelite.client.callback.ClientThread;
import rs117.hd.HdPlugin;

import static org.lwjgl.opengl.GL33C.*;

@Slf4j
@Singleton
public class FrameTimer {
	@Inject
	private ClientThread clientThread;

	@Inject
	private HdPlugin plugin;

	private final int numTimers = Timer.values().length;
	private final int numGpuTimers = (int) Arrays.stream(Timer.values()).filter(t -> t.isGpuTimer).count();
	private final boolean[] activeTimers = new boolean[numTimers];
	private final long[] timings = new long[numTimers];
	private final int[] gpuQueries = new int[numTimers * 2];
	private final ArrayDeque<Listener> listeners = new ArrayDeque<>();

	private boolean isInactive = true;
	private long cumulativeError = 0;

	private void initialize() {
		clientThread.invokeLater(() -> {
			int[] queryNames = new int[numGpuTimers * 2];
			glGenQueries(queryNames);
			int queryIndex = 0;
			for (var timer : Timer.values())
				if (timer.isGpuTimer)
					for (int j = 0; j < 2; ++j)
						gpuQueries[timer.ordinal() * 2 + j] = queryNames[queryIndex++];

			isInactive = false;
			plugin.enableDetailedTimers = true;
		});
	}

	private void destroy() {
		clientThread.invokeLater(() -> {
			isInactive = true;
			plugin.enableDetailedTimers = false;

			glDeleteQueries(gpuQueries);
			Arrays.fill(gpuQueries, 0);
			reset();
		});
	}

	@FunctionalInterface
	public interface Listener {
		void onFrameCompletion(FrameTimings timings);
	}

	public void addTimingsListener(Listener listener) {
		if (listeners.isEmpty())
			initialize();
		listeners.add(listener);
	}

	public void removeTimingsListener(Listener listener) {
		listeners.remove(listener);
		if (listeners.isEmpty())
			destroy();
	}

	public void removeAllListeners() {
		listeners.clear();
		destroy();
	}

	private void reset() {
		Arrays.fill(timings, 0);
		Arrays.fill(activeTimers, false);
	}

	public void begin(Timer timer) {
		if (isInactive)
			return;

		if (timer.isGpuTimer) {
			if (activeTimers[timer.ordinal()])
				throw new UnsupportedOperationException("Cumulative GPU timing isn't supported");
			glQueryCounter(gpuQueries[timer.ordinal() * 2], GL_TIMESTAMP);
		} else if (!activeTimers[timer.ordinal()]) {
			timings[timer.ordinal()] -= System.nanoTime() - cumulativeError;
		}
		activeTimers[timer.ordinal()] = true;
	}

	public void end(Timer timer) {
		if (isInactive || !activeTimers[timer.ordinal()])
			return;

		if (timer.isGpuTimer) {
			glQueryCounter(gpuQueries[timer.ordinal() * 2 + 1], GL_TIMESTAMP);
			// leave the GPU timer active, since it needs to be gathered at a later point
		} else {
			cumulativeError += 17; // compensate slightly for the timer's own overhead
			timings[timer.ordinal()] += System.nanoTime() - cumulativeError;
			activeTimers[timer.ordinal()] = false;
		}
	}

	public void endFrameAndReset() {
		if (isInactive)
			return;

		long frameEnd = System.nanoTime();

		int[] available = { 0 };
		for (var timer : Timer.values()) {
			int i = timer.ordinal();
			if (timer.isGpuTimer) {
				if (!activeTimers[i])
					continue;

				for (int j = 0; j < 2; j++) {
					while (available[0] == 0)
						glGetQueryObjectiv(gpuQueries[i * 2 + j], GL_QUERY_RESULT_AVAILABLE, available);
					timings[i] += (j * 2L - 1) * glGetQueryObjectui64(gpuQueries[i * 2 + j], GL_QUERY_RESULT);
				}
			} else {
				if (activeTimers[i]) {
					// End the CPU timer automatically, but warn about it
					log.warn("Timer {} was never ended", timer);
					timings[i] += frameEnd;
				}
			}
		}

		var frameTimings = new FrameTimings(frameEnd, timings);
		for (var listener : listeners)
			listener.onFrameCompletion(frameTimings);

		reset();
	}
}

package rs117.hd.overlays;

import javax.annotation.Nonnull;
import lombok.RequiredArgsConstructor;

@RequiredArgsConstructor
public enum Timer {
	DRAW_FRAME,
	DRAW_SCENE,
	DRAW_RENDERABLE,
	GET_MODEL,
	VISIBILITY_CHECK,
	CLICKBOX_CHECK,
	MODEL_BATCHING,
	MODEL_PUSHING,
	MODEL_PUSHING_VERTEX,
	MODEL_PUSHING_NORMAL,
	MODEL_PUSHING_UV(false, "Model pushing UV"),
	UPDATE_ENVIRONMENT,
	UPDATE_LIGHTS,
	IMPOSTOR_TRACKING,
	REPLACE_FISHING_SPOTS,
	UPLOAD_GEOMETRY(true),
	UPLOAD_UI(true, "Upload UI"),
	COMPUTE(true),
	CLEAR_SCENE(true),
	RENDER_SHADOWS(true),
	RENDER_SCENE(true),
	RENDER_UI(true, "Render UI"),
	SWAP_BUFFERS,
	;

	public final boolean isGpuTimer;
	public final String name;

	Timer() {
		isGpuTimer = false;
		name = enumToName(name());
	}

	Timer(boolean isGpuTimer) {
		this.isGpuTimer = isGpuTimer;
		name = enumToName(name());
	}

	Timer(@Nonnull String name) {
		isGpuTimer = false;
		this.name = name;
	}

	private static String enumToName(String name) {
		name = name.replace('_', ' ');
		return name.substring(0, 1).toUpperCase() + name.substring(1).toLowerCase();
	}

	@Override
	public String toString() {
		return name;
	}
}

package rs117.hd.overlays;

import com.google.inject.Inject;
import com.google.inject.Singleton;
import java.awt.Dimension;
import java.awt.Graphics2D;
import java.util.ArrayDeque;
import net.runelite.client.ui.FontManager;
import net.runelite.client.ui.overlay.OverlayLayer;
import net.runelite.client.ui.overlay.OverlayManager;
import net.runelite.client.ui.overlay.OverlayPanel;
import net.runelite.client.ui.overlay.OverlayPosition;
import net.runelite.client.ui.overlay.components.LineComponent;
import net.runelite.client.ui.overlay.components.TitleComponent;
import rs117.hd.HdPlugin;

@Singleton
public class FrameTimerOverlay extends OverlayPanel implements FrameTimer.Listener {
	@Inject
	private OverlayManager overlayManager;

	@Inject
	private FrameTimer frameTimer;

	private final ArrayDeque<FrameTimings> frames = new ArrayDeque<>();

	@Inject
	public FrameTimerOverlay(HdPlugin plugin) {
		super(plugin);
		setLayer(OverlayLayer.ABOVE_SCENE);
		setPosition(OverlayPosition.TOP_RIGHT);
		panelComponent.setPreferredSize(new Dimension(215, 200));
	}

	public void setActive(boolean activate) {
		if (activate) {
			frameTimer.addTimingsListener(this);
			overlayManager.add(this);
		} else {
			frameTimer.removeTimingsListener(this);
			overlayManager.remove(this);
			frames.clear();
		}
	}

	@Override
	public void onFrameCompletion(FrameTimings timings) {
		long now = System.nanoTime();
		while (!frames.isEmpty()) {
			if (now - frames.peekFirst().frameTimestamp < 3e9) // remove entries older than 3 seconds
				break;
			frames.removeFirst();
		}
		frames.addLast(timings);
	}

	@Override
	public Dimension render(Graphics2D g) {
		var timings = getAverageTimings();
		if (timings.length != Timer.values().length) {
			panelComponent.getChildren().add(TitleComponent.builder()
				.text("Waiting for data...")
				.build());
		} else {
			long cpuTime = timings[Timer.DRAW_FRAME.ordinal()];
			addTiming("CPU", cpuTime, true);
			for (var t : Timer.values())
				if (!t.isGpuTimer && t != Timer.DRAW_FRAME)
					addTiming(t, timings);

			long gpuTime = 0;
			for (var t : Timer.values())
				if (t.isGpuTimer)
					gpuTime += timings[t.ordinal()];
			addTiming("GPU", gpuTime, true);
			for (var t : Timer.values())
				if (t.isGpuTimer)
					addTiming(t, timings);

			panelComponent.getChildren().add(LineComponent.builder()
				.leftFont(FontManager.getRunescapeBoldFont())
				.left("Estimated bottleneck:")
				.rightFont(FontManager.getRunescapeBoldFont())
				.right(cpuTime > gpuTime ? "CPU" : "GPU")
				.build());

			panelComponent.getChildren().add(LineComponent.builder()
				.leftFont(FontManager.getRunescapeBoldFont())
				.left("Estimated FPS:")
				.rightFont(FontManager.getRunescapeBoldFont())
				.right(String.format("%.1f FPS", 1 / (Math.max(cpuTime, gpuTime) / 1e9)))
				.build());
		}

		return super.render(g);
	}

	private long[] getAverageTimings() {
		if (frames.isEmpty())
			return new long[0];

		long[] timers = new long[Timer.values().length];
		for (var frame : frames)
			for (int i = 0; i < frame.timers.length; i++)
				timers[i] += frame.timers[i];

		for (int i = 0; i < timers.length; i++)
			timers[i] /= frames.size();

		return timers;
	}

	private void addTiming(Timer timer, long[] timings) {
		addTiming(timer.name, timings[timer.ordinal()], false);
	}

	private void addTiming(String name, long nanos, boolean bold) {
		if (nanos == 0)
			return;

		// Round timers to zero if they are less than a microsecond off
		String formatted = nanos < 3e3 && nanos > -1e5 ? "~0 ms" : String.format("%.3f ms", nanos / 1e6);
		var font = bold ? FontManager.getRunescapeBoldFont() : FontManager.getRunescapeFont();
		panelComponent.getChildren().add(LineComponent.builder()
			.left(name + ":")
			.leftFont(font)
			.right(formatted)
			.rightFont(font)
			.build());
	}
}

/*
 * Copyright (c) 2021, 117 <https://twitter.com/117scape>
 * Copyright (c) 2022, Hooder <ahooder@protonmail.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package rs117.hd.data;

import java.util.function.Consumer;
import lombok.Setter;
import lombok.experimental.Accessors;
import rs117.hd.data.materials.Material;

import static rs117.hd.utils.ColorUtils.hsl;
import static rs117.hd.utils.ColorUtils.rgb;
import static rs117.hd.utils.ColorUtils.srgb;

public enum WaterType
{
	NONE,
	WATER,
	WATER_FLAT(WATER, true),
	SWAMP_WATER(b -> b
		.specularStrength(.1f)
		.specularGloss(100)
		.normalStrength(.05f)
		.baseOpacity(.8f)
		.fresnelAmount(.3f)
		.surfaceColor(srgb(23, 33, 20))
		.foamColor(srgb(115, 120, 101))
		.depthColor(srgb(41, 82, 26))
		.causticsStrength(0)
		.duration(1.2f)
		.fishingSpotRecolor(hsl("#04730d"))),
	SWAMP_WATER_FLAT(SWAMP_WATER, true),
	POISON_WASTE(b -> b
		.specularStrength(.1f)
		.specularGloss(100)
		.normalStrength(.05f)
		.baseOpacity(.9f)
		.fresnelAmount(.3f)
		.surfaceColor(srgb(22, 23, 13))
		.foamColor(srgb(106, 108, 100))
		.depthColor(srgb(50, 52, 46))
		.causticsStrength(0)
		.duration(1.6f)),
	BLACK_TAR_FLAT(b -> b
		.specularStrength(.05f)
		.specularGloss(300)
		.normalStrength(.05f)
		.baseOpacity(.9f)
		.fresnelAmount(.02f)
		.surfaceColor(rgb(38, 40, 43))
		.foamColor(rgb(0, 0, 0))
		.depthColor(rgb(38, 40, 43))
		.causticsStrength(0)
		.duration(1.6f)
		.flat(true)),
	BLOOD(b -> b
		.specularStrength(.5f)
		.specularGloss(500)
		.normalStrength(.05f)
		.baseOpacity(.85f)
		.fresnelAmount(0)
		.surfaceColor(srgb(38, 0, 0))
		.foamColor(srgb(117, 63, 45))
		.depthColor(srgb(50, 26, 22))
		.causticsStrength(0)
		.duration(2)),
	ICE(b -> b
		.specularStrength(.3f)
		.specularGloss(200)
		.normalStrength(.04f)
		.baseOpacity(.85f)
		.fresnelAmount(1)
		.foamColor(srgb(150, 150, 150))
		.depthColor(srgb(0, 117, 142))
		.causticsStrength(.4f)
		.duration(0)
		.normalMap(Material.WATER_NORMAL_MAP_2)),
	ICE_FLAT(ICE, true),
	MUDDY_WATER(b -> b
		.specularStrength(.1f)
		.specularGloss(100)
		.normalStrength(.05f)
		.baseOpacity(.7f)
		.fresnelAmount(.3f)
		.surfaceColor(srgb(35, 10, 0))
		.foamColor(srgb(106, 108, 24))
		.depthColor(srgb(65, 23, 0))
		.causticsStrength(0)
		.duration(2.7f)),
	SCAR_SLUDGE(b -> b
		.specularStrength(0)
		.specularGloss(100)
		.normalStrength(.05f)
		.baseOpacity(.85f)
		.fresnelAmount(.3f)
		.surfaceColor(srgb(0x26, 0x26, 0x23))
		.foamColor(srgb(0x69, 0x77, 0x5e))
		.depthColor(srgb(0x69, 0x77, 0x5e))
		.causticsStrength(0)
		.duration(1.2f)),
	ABYSS_BILE(b -> b
		.specularStrength(0.2f)
		.specularGloss(100)
		.normalStrength(.08f)
		.baseOpacity(.85f)
		.fresnelAmount(.3f)
		.surfaceColor(rgb(120, 91, 0))
		.foamColor(rgb(120, 81, 0))
		.depthColor(rgb(120, 59, 0))
		.causticsStrength(0.4f)
		.duration(2.2f)),
	PLAIN_WATER(b -> b
		.depthColor(rgb(0, 0, 0))
		.foamColor(rgb(64, 64, 64))
		.causticsStrength(0)
		.flat(true)),
	DARK_BLUE_WATER(b -> b
		.specularStrength(.1f)
		.specularGloss(100)
		.normalStrength(.1f)
		.baseOpacity(.8f)
		.fresnelAmount(.2f)
		.surfaceColor(rgb("#07292f"))
		.foamColor(rgb(64, 64, 64))
		.depthColor(rgb("#000000"))
		.causticsStrength(0)
		.flat(true)),
	;

	public final boolean flat;
	public final float specularStrength;
	public final float specularGloss;
	public final float normalStrength;
	public final float baseOpacity;
	public final float fresnelAmount;
	public final Material normalMap;
	public final float[] surfaceColor;
	public final float[] foamColor;
	public final float[] depthColor;
	public final float causticsStrength;
	public final boolean hasFoam;
	public final float duration;
	public final int fishingSpotRecolor;

	@Setter
	@Accessors(fluent = true)
	private static class Builder
	{
		private boolean flat = false;
		private float specularStrength = .5f;
		private float specularGloss = 500;
		private float normalStrength = .09f;
		private float baseOpacity = .5f;
		private float fresnelAmount = 1;
		private Material normalMap = Material.WATER_NORMAL_MAP_1;
		private float[] surfaceColor = { 1, 1, 1 };
		private float[] foamColor = srgb(176, 164, 146);
		private float[] depthColor = srgb(0, 117, 142);
		private float causticsStrength = 1;
		private boolean hasFoam = true;
		private float duration = 1;
		private int fishingSpotRecolor = -1;
	}

	WaterType()
	{
		this(b -> {});
	}

	WaterType(Consumer<Builder> consumer)
	{
		Builder builder = new Builder();
		consumer.accept(builder);
		flat = builder.flat;
		specularStrength = builder.specularStrength;
		specularGloss = builder.specularGloss;
		normalStrength = builder.normalStrength;
		baseOpacity = builder.baseOpacity;
		fresnelAmount = builder.fresnelAmount;
		normalMap = builder.normalMap;
		surfaceColor = builder.surfaceColor;
		foamColor = builder.foamColor;
		depthColor = builder.depthColor;
		causticsStrength = builder.causticsStrength;
		hasFoam = builder.hasFoam;
		duration = builder.duration;
		fishingSpotRecolor = builder.fishingSpotRecolor;
	}

	WaterType(WaterType parent, boolean flat)
	{
		this.flat = flat;
		specularStrength = parent.specularStrength;
		specularGloss = parent.specularGloss;
		normalStrength = parent.normalStrength;
		baseOpacity = parent.baseOpacity;
		fresnelAmount = parent.fresnelAmount;
		normalMap = parent.normalMap;
		surfaceColor = parent.surfaceColor;
		foamColor = parent.foamColor;
		depthColor = parent.depthColor;
		causticsStrength = parent.causticsStrength;
		hasFoam = parent.hasFoam;
		duration = parent.duration;
		fishingSpotRecolor = parent.fishingSpotRecolor;
	}
}

/*
 * Copyright (c) 2021, 117 <https://twitter.com/117scape>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package rs117.hd.data.environments;

import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonToken;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.Arrays;
import lombok.Getter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.coords.*;
import rs117.hd.utils.AABB;
import rs117.hd.utils.GsonUtils;

import static rs117.hd.utils.AABB.regionBox;
import static rs117.hd.utils.AABB.regions;

@Getter
public enum Area
{
	EVIL_BOB_ISLAND(2496, 4748, 2559, 4801),
	VERTICAL_DIRT_FIX_NEAR_FALADOR(2941, 3548, 3072, 3402),

	// Tutorial Island
	TUTORIAL_ISLAND_WIZARD_BUILDING(3136, 3097, 3144, 3076),
	TUTORIAL_ISLAND_CHURCH(3114, 3111, 3129, 3102),
	TUTORIAL_ISLAND_BANK(3113, 3131, 3130, 3117),
	TUTORIAL_ISLAND_UNDERGROUND(3120, 9534, 3067, 9491),
	TUTORIAL_ISLAND_QUEST_BUILDING(3079, 3118, 3090, 3126),
	TUTORIAL_ISLAND_KITCHEN(3072, 3092, 3079, 3080),
	TUTORIAL_ISLAND_START_BUILDING(3086, 3113, 3098, 3099),
	TUTORIAL_ISLAND_THE_NODE(3084, 3048, 3124, 3006),
	TUTORIAL_ISLAND_INSTANCE(regionBox(6494, 7008)),
	TUTORIAL_ISLAND(merge(
		new AABB(3052, 3137, 3155, 3057),
		new AABB(3084, 3048, 3124, 3006), // the node
		TUTORIAL_ISLAND_INSTANCE
	)),
	TUTORIAL_ISLAND_CAVES(12436),

	// Lumbridge Interior
	LUMBRIDGE_CASTLE_BASEMENT(3205, 9613, 3220, 9626),
	LUMBRIDGE_CASTLE_ENTRYWAY(3213, 3212, 3216, 3225),
	LUMBRIDGE_CASTLE_DINING_ROOM(3205, 3218, 3212, 3226),
	LUMBRIDGE_CASTLE_COBBLE(
		new AABB(3216, 3230, 3204, 3207, 0),
		new AABB(3207, 3230, 3204, 3207, 1),
		new AABB(3213, 3225, 3208, 3212, 1),
		new AABB(3210, 3222, 3207, 3215, 2)
	),
	LUMBRIDGE_TOWER_FLOOR_INTERIOR(
		new AABB(3230, 3225, 3227, 3221, 0),
		new AABB(3230, 3216, 3227, 3212, 0)
	),

	// Lumbridge
	RFD_QUIZ(2589, 4618, 2566, 4642),
	LUM_BRIDGE(3240, 3226, 3250, 3225),
	HAM_HIDEOUT(3137, 9661, 3192, 9602),
	LUMBRIDGE_CASTLE(
		new AABB(3216, 3230, 3204, 3207),
		new AABB(3230, 3225, 3227, 3212, 2)
	),
	LUMBRIDGE_CASTLE_ENTRANCE(3218, 3219, 3217, 3218),
	LUMBRIDGE_DRAYNOR_PATH_BLEND_1(3135,3293, 3135,3295),
	LUMBRIDGE_DRAYNOR_PATH_BLEND_2(3136,3293, 3136,3296),
	LUMBRIDGE_SWAMP_PATH_FIX(3242,3184, 3244,3186),
	LUMBRIDGE_VARROCK_PATH_BLEND_FIX(
		new AABB(3250,3315,3250,3315),
		new AABB(3249,3314,3249,3314),
		new AABB(3248,3312,3248,3312),
		new AABB(3247,3311,3247,3311),
		new AABB(3246,3311,3246,3311),
		new AABB(3245,3310,3245,3310),
		new AABB(3243,3308,3343,3308),
		new AABB(3241, 3306, 3241,3306),
		new AABB(3240,3305,3240,3305)
	),
	LUMBRIDGE_VARROCK_PATH_FIX(3267,3328,3269,3329),
	LUMBRIDGE_CASTLE_INSTANCE(3400, 4847, 3447, 4808),
	LUMBRIDGE(merge(
		new AABB(3136, 3137, 3254, 3327),
		new AABB(3255, 3189, 3263, 3199),
		new AABB(3266, 3200, 3255, 3327),
		new AABB(3267, 3232, 3267, 3223),
		new AABB(3269, 3330, 3267, 3324), // Lumbridge path near Varrock
		LUMBRIDGE_CASTLE_INSTANCE
	)),
	GOBLIN_MAZE(3221 , 9660, 3307, 9602),
	LUMBRIDGE_SWAMP_CAVES(3265, 9602, 3141, 9536),
	TEARS_OF_GUTHIX(12948),

	// Dorgesh-Kaan
	DORGESHKAAN(
		new AABB(2687, 5376, 2752, 5247), // lower level
		new AABB(2751, 5440, 2816, 5311), // middle level
		new AABB(2815, 5504, 2880, 5375)  // upper level
	),

	// Varrock Indoors
	VARROCK_GUARD_POSTS(
		new AABB(3242, 3501, 3239, 3499, 0),
		new AABB(3207, 3390, 3201, 3384)
	),
	VARROCK_ZAMORAK_TEMPLE(
		new AABB(3263, 3390, 3256, 3380),
		new AABB(3255, 3385, 3253, 3380)
	),
	VARROCK_HORVIKS_ANVIL(3232, 3441, 3227, 3433),
	VARROCK_HOUSE_1(3257, 3462, 3253, 3459),
	VARROCK_HOUSE_2(
		new AABB(3238, 3386, 3230, 3382, 0),
		new AABB(3236, 3386, 3230, 3382, 1)
	),
	VARROCK_BLUE_MOON_INN(
		new AABB(3233, 3402, 3228, 3397, 0),
		new AABB(3233, 3402, 3231, 3401, 1),
		new AABB(3232, 3400, 3226, 3400, 1),
		new AABB(3232, 3399, 3218, 3393, 1),
		new AABB(3224, 3403, 3218, 3400, 1)
	),
	VARROCK_CHAMPIONS_GUILD(3194, 3362, 3188, 3352, 0),
	VARROCK_JULIETS_FAMILY_CRYPT(9288),

	// Varrock
	VARROCK_HALLOWEEN_EVENT_DIRT(3198, 3437, 3194, 3433),
	VARROCK_MUSEUM_BASEMENT(
		new AABB(1729, 4929, 1790, 4990),
		new AABB(1601, 4929, 1663, 4990)
	),
	VARROCK_MUSEUM(3253, 3442, 3267, 3455),
	VARROCK_CASTLE(
		new AABB(3224, 3497, 3201, 3467), // main
		new AABB(3225, 3473, 3225, 3470), // kingsroom bump
		new AABB(3226, 3479, 3225, 3490), // Dinning Room
		new AABB(3206, 3499, 3200, 3498), // Northwest Tower
		new AABB(3205, 3500, 3201, 3500), // Northwest Tower
		new AABB(3200, 3497, 3200, 3495), // Northwest Tower
		new AABB(3200, 3474, 3200, 3470)  // Southwest tower bump
	),
	VARROCK_CASTLE_DIRT_PATH_FIXES_1(
		new AABB(3198,3500,3198, 3499),
		new AABB(3208,3501),
		new AABB(3198,3475,3198,3474)

	),
	VARROCK_CASTLE_DIRT_PATH_FIXES_2(
		new AABB(3206,3502,3206,3501),
		new AABB(3208,3502,3207,3502)
	),
	VARROCK_JULIETS_HOUSE_FLOWER_BED(3161, 3450, 3171, 3444),
	VARROCK_JULIETS_HOUSE(3164, 3441, 3149, 3427),
	VARROCK_JOLLY_BOAR_INN(3272, 3486, 3288, 3510),
	VARROCK_SARADOMIN_CHURCH(
			new AABB(3259, 3488,3252, 3471),
			new AABB(3251, 3483, 3249, 3476)
	),
	VARROCK_ANVILS(3185, 3420, 3190, 3427),
	VARROCK_BUILDING_RUINS(
		new AABB(3185, 3416, 3194, 3427),
		new AABB(3193, 3410, 3197, 3416),
		new AABB(3254, 3406, 3263, 3411)
	),
	VARROCK_EAST_BANK_CENTER(3251, 3420, 3256, 3422),
	VARROCK_EAST_BANK(
			new AABB(3250, 3416, 3257, 3423)
	),
	VARROCK_EAST_BANK_OUTSIDE_1(
			new AABB(3250 ,3424 ,3257 ,3424)
	),
	VARROCK_MOON_INN_BALCONY(3217, 3401, 3214, 3397),
	VARROCK_MOON_INN_FLOOR(
		new AABB(3229, 3396, 3228, 3394),
		new AABB(3217, 3396, 3216, 3394),
		new AABB(3227, 3402, 3218, 3394),
		new AABB(3228, 3402, 3227, 3401),
		// South bumpout
		new AABB(3229, 3393, 3226, 3393),
		new AABB(3220, 3393, 3217, 3393),
		// Under fireplace
		new AABB(3221, 3403, 3219, 3403)
	),
	VARROCK_MOON_INN_FLOOR_FIX(
		new AABB(3225, 3393, 3225, 3393),
		new AABB(3221, 3393, 3221, 3393),
		new AABB(3216, 3393, 3216, 3393)
	),
	VARROCK_MUSEUM_SOUTH_PATH_FIX(3264, 3439, 3265, 3441),
	VARROCK_WEST_BANK_SOUTH_PATH_FIX(3182, 3432, 3183, 3432),
	VARROCK_WILDERNESS_DITCH_PATH_FIX(3242, 3519, 3275, 3526),
	VARROCK_GRAND_EXCHANGE_ROOF(3175, 3501, 3154, 3480),
	VARROCK(
		new AABB(3136, 3397, 3290, 3518),
		new AABB(3177, 3371, 3291, 3410)
	),
	VARROCK_SEWERS(3152, 9919, 3310, 9856),
	DEFENDER_OF_VARROCK_DUNGEON(regionBox(14151, 14408)),
	DEFENDER_OF_VARROCK_CASTLE_UNDER_ATTACK(regionBox(15436, 15950)),
	// Barbarian Village
	BARBARIAN_VILLAGE_EAST_PATH_FIX(3111, 3420, 3112, 3421),
	STRONGHOLD_OF_SECURITY_WAR(7505),
	STRONGHOLD_OF_SECURITY_FAMINE(8017),
	STRONGHOLD_OF_SECURITY_PESTILENCE(8530),
	STRONGHOLD_OF_SECURITY_DEATH(9297),
	STRONGHOLD_OF_SECURITY(
		STRONGHOLD_OF_SECURITY_WAR,
		STRONGHOLD_OF_SECURITY_FAMINE,
		STRONGHOLD_OF_SECURITY_PESTILENCE,
		STRONGHOLD_OF_SECURITY_DEATH
	),

	// A Soul's Bane
	TOLNA_DUNGEON_ANGER(
		new AABB(3008, 5216, 3039, 5247),
		new AABB(2963, 5228, 2995, 5198),
		new AABB(3264, 9823, 3298, 9855)
	),
	TOLNA_DUNGEON_FEAR(
		new AABB(3040, 5216, 3071, 5247),
		new AABB(3072, 5184, 3103, 5215),
		new AABB(3008, 5184, 3039, 5215),
		new AABB(3264, 9792, 3296, 9822),
		new AABB(3299, 9823, 3327, 9855)
	),
	TOLNA_DUNGEON_CONFUSION(
		new AABB(3040, 5184, 3071, 5215),
		new AABB(3297, 9792, 3327, 9822)
	),

	// Digsite
	DIGSITE_EXAM_CENTRE(
		new AABB(3367,3348,3357,3332),
		new AABB(3356, 3337,3348, 3332)
	),
	DIGSITE_DOCK(3348, 3460, 3404, 3444),

	// Draynor
	DRAYNOR_MANOR_INTERIOR(
		new AABB(3091, 3363, 3096, 3353),
		new AABB(3097, 3374, 3119, 3353),
		new AABB(3120, 3360, 3126, 3353)
	),
	DRAYNOR_MANOR(
		new AABB(3084, 3382, 3120, 3330),
		new AABB(3121, 3377, 3125, 3330),
		new AABB(3126, 3375, 3127, 3344),
		new AABB(3128, 3364, 3129, 3347),
		new AABB(3107, 3385, 3090, 3383),
		new AABB(3087, 3329, 3123, 3323),
		new AABB(3126, 3339, 3126, 3335)
	),
	DRAYNOR_MANOR_FOREST(
		new AABB(3076, 3393, 3119, 3315),
		new AABB(3120, 3315, 3144, 3387),
		new AABB(3145, 3376, 3150, 3315)
	),
	DRAYNOR_MANOR_BASEMENT(
		new AABB(3073, 9780, 3082, 9766)
	),
	DRAYNOR_NORTHERN_HOUSE_FLOOR(
		new AABB(3102, 3281, 3097, 3277)
	),
	DRAYNOR_AGGIES_HOUSE(3088, 3261, 3083, 3256),
	DRAYNOR_WOM_HOUSE_FRONT(3094, 3250, 3088, 3250),
	DRAYNOR_BANK(
		new AABB(3097, 3246, 3088, 3240),
		new AABB(2127, 4910, 2137, 4903)
	),
	DRAYNOR_PATH_BLENDING_FIXES(
		new AABB(3110,3281,3110,3281),
		new AABB(3109,3280,3109,3280),
		new AABB(3108,3279,3108,3279)
	),
	DRAYNOR_NEDS_PATH_FIXES(
		new AABB(3103,3257,3103,3256)
	),
	DRAYNOR_BANK_FRONT_PATH(3093, 3247, 3092, 3247),
	DRAYNOR_MARKET_PATH_FIX(
			new AABB(3095, 3247, 3094, 3247), // east of bank path
			new AABB(3087, 3246, 3085, 3243),
			new AABB(3091, 3247, 3087, 3247)
	),
	DRAYNOR_BANK_PATH_FIX_DARK(
			new AABB(3088, 3248, 3088, 3248), // middle of path to fix blending weirdness
			new AABB(3087, 3247, 3087, 3247),
			new AABB(3086, 3246, 3086, 3246),
			new AABB(3084, 3246, 3084, 3246)
	),
	DRAYNOR_BANK_PATH_FIX_LIGHT(
			new AABB(3095, 3248, 3095, 3248), // East of bank fix
			new AABB(3095, 3250, 3095, 3250),
			new AABB(3096, 3251, 3096, 3251)
	),
	DRAYNOR_BANK_ROBBERY_CUTSCENE(2112, 4895, 2156, 4927),
	DRAYNOR(merge(
		new AABB(3071, 3226, 3133, 3292),
		DRAYNOR_BANK_ROBBERY_CUTSCENE
	)),
	DRAYNOR_SEWERS(3075, 9701, 3127, 9642),

	// Wizards Tower
	WIZARDS_TOWER_PATH(
		new AABB(3115, 3171, 3112, 3168),
		new AABB(3117, 3169, 3116, 3166),
		new AABB(3111, 3169, 3110, 3167),
		new AABB(3115, 3167),
		new AABB(3118, 3168, 3118, 3167),
		new AABB(3109, 3168, 3108, 3168),
		new AABB(3109, 3167, 3108, 3167),
		// Partial tiles
		new AABB(3116, 3170),
		new AABB(3118, 3169),
		new AABB(3108, 3169),
		new AABB(3109, 3169)
	),
	WIZARD_TOWER_PATH_PARTIAL_TILES(
		new AABB(3111, 3170),
		new AABB(3107, 3186),
		new AABB(3114, 3167),
		new AABB(3112, 3167),
		new AABB(3107, 3167, 3107, 3168),
		new AABB(3118, 3166),
		new AABB(3115, 3166)
	),
	WIZARD_TOWER_ROOF(new AABB(3101, 3167, 3116, 3153)),
	WIZARD_TOWER_BASEMENT(new AABB(3094, 9579, 3122, 9554)),

	// Misthalin Mystery
	MISTHALIN_MYSTERY_MANOR(
		new AABB(1630, 4844, 1647, 4835),
		new AABB(1647, 4834, 1618, 4825),
		new AABB(1624, 4844, 1629, 4838),
		new AABB(1642, 4824, 1644, 4824),
		new AABB(1641, 4845, 1639, 4845),
		new AABB(1633, 4845, 1630, 4845)
	),
	MISTHALIN_MYSTERY_MANOR_REGION(1600, 4863, 1727, 4779),

	// Falador
	FALADOR_EAST_BANK_PATH_FIX_2(3006, 3348, 3006, 3346),
	FALADOR_EAST_BANK_PATH_FIX_1(3006, 3346, 3006, 3344),
	FALADOR_HAIRDRESSER(
		new AABB(2941, 3389, 2946, 3376),
		new AABB(2946, 3376, 2949, 3382)
	),
	FALADOR_PARTY_ROOM(3034, 3387, 3057, 3369),
	FALADOOR_PARTY_ROOM_STAIRS_FIX(
			new AABB(3054, 3084, 3053, 3383),
			new AABB(3038, 3084, 3037, 3383)
	),
	FALADOR_TRIANGLE_PATH_FIX_1(2973,3413,2974,3415),
	FALADOR_TRIANGLE_PATH_FIX_2(2965,3406,2968,3407),
	FALADOR_SOUTH_PATH_FIX(3006,3320,3008,3321),
	FALADOR_INSTANCE(3456, 4783, 3527, 4736),
	FALADOR(merge(
		new AABB(2932, 3306, 3068, 3401),
		new AABB(2964, 3401, 2969, 3405), // path northwards
		FALADOR_INSTANCE
	)),

	DWARVEN_MINE_DUNGEON(
		new AABB(3071, 9855, 2985, 9690),
		new AABB(2960, 9820, 2984, 9801)
	),

	MOTHERLODE_MINE(
		new AABB(3713, 5696, 3776, 5633),
		new AABB(3827, 5692, 3868, 5652)
	),

	// Edgeville
	EDGEVILLE_PATH_OVERLAY(
		new AABB(3087, 3501, 3099, 3502), // path north of bank
		new AABB(3079, 3502, 3085, 3503), // path between bank and general store
		new AABB(3105, 3508, 3113, 3507), // path south of the prison
		new AABB(3112, 3514, 3119, 3515), // path east of prison
		new AABB(3120, 3517, 3129, 3516), // path west of bridge
		new AABB(3119, 3516, 3120, 3515), // prison-bridge path join
		new AABB(3107, 3508, 3108, 3502), // path to north side of furnace
		new AABB(3079, 3502, 3080, 3501), // path to dave's house
		new AABB(3079, 3506, 3080, 3504), // path to general store
		new AABB(3100, 3496, 3099, 3501), // path east of bank
		new AABB(3104, 3498, 3103, 3499), // path west side of furnace 1
		new AABB(3103, 3499, 3102, 3500), // path west side of furnace 2
		new AABB(3101, 3500, 3102, 3501), // path west side of furnace 3
		new AABB(3084, 3502, 3088, 3501), // between well and bank
		new AABB(3113, 3514, 3114, 3509), // south prison join 1
		new AABB(3112, 3509, 3114, 3508), // south prison join 2
		new AABB(3101, 3510, 3103, 3509), // path to central building 1
		new AABB(3104, 3509, 3103, 3508), // path to central building 2
		new AABB(3104, 3507, 3105, 3506), // diagonal 1
		new AABB(3103, 3506, 3104, 3505), // diagonal 2
		new AABB(3102, 3505, 3103, 3504), // diagonal 3
		new AABB(3101, 3504, 3102, 3503), // diagonal 4
		new AABB(3100, 3503, 3101, 3502), // diagonal 5
		new AABB(3134, 3517, 3134, 3516)  // path after bridge towards Varrock
	),
	EDGEVILLE_BRIDGE(3133,3518,3130,3516),

	// Edgeville Bank overhaul
	EDGEVILLE_BANK_PERIMETER_FIX(
		new AABB(3090, 3497, 3090, 3494), // bumpout for window
		new AABB(3091, 3497, 3091, 3493)  // bumpout border correction
	),
	EDGEVILLE_BANK_TILING(
		new AABB(3098, 3498, 3098, 3498),
		new AABB(3098, 3496, 3098, 3496),
		new AABB(3098, 3494, 3098, 3494),
		new AABB(3098, 3492, 3098, 3492),
		new AABB(3098, 3490, 3098, 3490),
		new AABB(3098, 3488, 3098, 3488),
		new AABB(3097, 3499, 3097, 3499),
		new AABB(3096, 3488, 3096, 3488),
		new AABB(3095, 3499, 3095, 3499),
		new AABB(3094, 3488, 3094, 3488),
		new AABB(3093, 3499, 3093, 3499),
		new AABB(3092, 3488, 3092, 3488),
		new AABB(3091, 3489, 3091, 3489),
		new AABB(3091, 3491, 3091, 3491),
		new AABB(3091, 3493, 3091, 3493),
		new AABB(3091, 3495, 3091, 3495),
		new AABB(3091, 3497, 3091, 3497),
		new AABB(3091, 3499, 3091, 3499),
		new AABB(3090, 3494, 3090, 3494),
		new AABB(3090, 3496, 3090, 3496)
	),
	EDGEVILLE_BANK(3098, 3499, 3091, 3488),
	EDGEVILLE_BANK_SURROUNDING_PATH(
		new AABB(3091, 3501, 3089, 3500), // north part of bank
		new AABB(3093, 3502, 3089, 3492), // path north of bank
		new AABB(3093, 3500, 3091, 3498), // path west of bank (north part)
		new AABB(3088, 3502, 3086, 3485), // path west of bank
		new AABB(3090, 3492, 3089, 3490), // west path to bank
		new AABB(3092, 3489, 3088, 3483)  // path south of bank
	),
	// Edgeville buildings
	EDGEVILLE_DORIS_HOUSE(3077, 3496, 3081, 3489),
	EDGEVILLE_MONASTERY(3041, 3509, 3062, 3471),
	EDGEVILLE_GUARD_TOWER_FLOOR(
			new AABB(3111, 3517, 3107, 3511)
	),
	EDGEVILLE_FURNACE_FLOOR(
			new AABB(3110, 3501, 3105, 3496)
	),
	EDGEVILLE_MANS_HOUSE_FLOOR(
			new AABB(3100, 3513, 3091, 3507)
	),
	EDGEVILLE_GENERAL_STORE_FLOOR_FIX(
			new AABB(3082, 3507, 3078, 3507)
	),
	EDGEVILLE_GENERAL_STORE_FLOOR(
			new AABB(3084, 3513, 3076, 3507)
	),

	// Seers Indoors
	SEERS_BANK(2719, 3497, 2730, 3487),
	SEERS_HOUSES(
		new AABB(2716, 3482, 2709, 3476),
		new AABB(2705, 3476, 2699, 3470),
		new AABB(2715, 3473, 2710, 3470),
		new AABB(2709, 3473, 2706, 3471, 1),
		new AABB(2716, 3473, 2716, 3470, 1),
		new AABB(2739, 3505, 2735, 3499)
	),
	SEERS_CHURCH(
		new AABB(2703, 3466, 2690, 3459)
	),
	SEERS_BAR(
		new AABB(2700, 3498, 2689, 3488),
		new AABB(2693, 3488, 2689, 3488),
		new AABB(2696, 3488)
	),
	SEERS_BAR_ENTRANCE(2695, 3488, 2694, 3488),
	SEERS_CAMELOT_CASTLE_BLENDED(
		new AABB(2750, 3495, 2),
		new AABB(2751, 3494, 2),
		new AABB(2750, 3494, 2),
		new AABB(2766, 3495, 2),
		new AABB(2765, 3494, 2),
		new AABB(2766, 3494, 2)
	),
	SEERS_CAMELOT_CASTLE(
		new AABB(2767, 3517, 2748, 3504, 0),
		new AABB(2751, 3503, 2748, 3496, 0),
		new AABB(2768, 3503, 2765, 3496, 0),
		new AABB(2764, 3503, 2752, 3501, 1),
		new AABB(2768, 3517, 2748, 3504, 1),
		new AABB(2751, 3503, 2748, 3496, 1),
		new AABB(2768, 3503, 2765, 3496, 1),
		new AABB(2764, 3495, 2752, 3492, 1),
		new AABB(2770, 3495, 2765, 3490, 0),
		new AABB(2751, 3495, 2746, 3490, 0),
		new AABB(2770, 3495, 2765, 3490, 1),
		new AABB(2751, 3495, 2746, 3490, 1),
		new AABB(2751, 3493, 2746, 3490, 2),
		new AABB(2749, 3495, 2746, 3494, 2),
		new AABB(2770, 3493, 2765, 3490, 2),
		new AABB(2770, 3495, 2767, 3494, 2)
	),
	SEERS_CAMELOT_CASTLE_KNIGHTSWAVE_OVERWORLD(
		new AABB(2764, 3512, 2764, 3502, 2),
		new AABB(2752, 3512, 2752, 3502, 2),
		new AABB(2763, 3513, 2753, 3502, 2)
	),
	ELEMENTAL_WORKSHOP_HOUSE(
		new AABB(2711, 3498, 2709, 3496),
		new AABB(2705, 3498, 2704, 3497),
		new AABB(2708 ,3496, 2704, 3496),
		new AABB(2714, 3495, 2704, 3492),
		new AABB(2711, 3491, 2706, 3487),
		new AABB(2708, 3487, 2706, 3487),
		new AABB(2711, 3487)
	),
	ELEMENTAL_WORKSHOP_HOUSE_ENTRANCE(
		new AABB(2710, 3487, 2709, 3487)
	),
	SEERS_COURTHOUSE(2739, 3471, 2732, 3465),

	// Murder Mystery Mansion
	SINCLAIR_MANSION(
		new AABB(2747,3582,2733,3574),
		new AABB(2742,3573,2739,3573)
	),

	GOBLIN_FORT_DWARF_CANNON_UPPER_FLOORS(
		new AABB(2571, 3444, 2569, 3440, 1),
		new AABB(2571, 3444, 2567, 3442, 2)
	),
	GOBLIN_CAVE(10393),

	// Asgarnia mountains
	WHITE_WOLF_MOUNTAIN(
		new AABB(2786, 3534, 2805, 3486),
		new AABB(2830, 3544, 2806, 3490),
		new AABB(2831, 3541, 2837, 3537),
		new AABB(2831, 3536, 2848, 3533),
		new AABB(2831, 3532, 2875, 3490),
		new AABB(2861, 3533, 2872, 3535),
		new AABB(2876, 3528, 2880, 3495),
		new AABB(2876, 3494, 2877, 3490),
		new AABB(2881, 3525, 2906, 3520),
		new AABB(2885, 3517, 2881, 3519),
		new AABB(2881, 3516, 2882, 3504),
		new AABB(2881, 3503, 2886, 3495),
		new AABB(2826, 3489, 2873, 3476),
		new AABB(2877, 3489, 2874, 3486),
		new AABB(2874, 3475, 2830, 3463),
		new AABB(2833, 3462, 2874, 3461),
		new AABB(2838, 3460, 2879, 3446),
		new AABB(2843, 3445, 2879, 3443),
		new AABB(2850, 3442, 2878, 3441),
		new AABB(2853, 3440, 2879, 3438),
		new AABB(2858, 3437, 2879, 3435),
		new AABB(2862, 3434, 2879, 3432),
		new AABB(2865, 3431, 2878, 3430),
		new AABB(2866, 3429, 2872, 3424),
		new AABB(2875, 3472, 2880, 3461),
		new AABB(2880, 3460, 2881, 3453),
		new AABB(2431, 5374, 2496, 5439) // instance
	),
	ICE_MOUNTAIN(
		new AABB(2992, 3510, 3019, 3493),
		new AABB(3020, 3509, 3023, 3494),
		new AABB(2994, 3492, 3018, 3487),
		new AABB(2996, 3486, 3016, 3480),
		new AABB(2995, 3479, 3020, 3478),
		new AABB(3030, 3477, 2992, 3468),
		new AABB(3026, 3467, 2989, 3464),
		new AABB(3021, 3463, 2987, 3462),
		new AABB(3018, 3461, 2987, 3457),
		new AABB(2991, 3474, 2987, 3468),
		new AABB(3031, 3475, 3032, 3469),
		new AABB(3012, 3512, 3018, 3511)
	),
	ASGARNIA_MOUNTAINS(ICE_MOUNTAIN, WHITE_WOLF_MOUNTAIN),

	// Keep Le Faye
	KEEP_LE_FAYE_JAIL(7490),
	KEEP_LE_FAYE_INSTANCE(1670, 4230, 1721, 4280),
	KEEP_LE_FAYE(merge(
		new AABB(2747, 3415, 2782, 3389),
		KEEP_LE_FAYE_INSTANCE
	)),

	// Catherby
	CATHERBY_BEACH_OBELISK_WATER_FIX(2843, 3423, 2845, 3421),
	CATHERBY_BEACH_LADDER_FIX(2842, 3424, 2842, 3424),
	CATHERBY_BEACH_SHORELINE_FIX(
		new AABB(2870, 3414, 2869, 3416),
		new AABB(2865, 3420, 2864, 3423),
		new AABB(2863, 3423, 2851, 3426),
		new AABB(2848, 3427, 2848, 3428),
		new AABB(2847, 3429, 2847, 3429),
		new AABB(2845, 3430, 2843, 3430)
	),
	CATHERBY_BANK(2806, 3445, 2812, 3438),
	CATHERBY(
		new AABB(2863, 3413, 2789, 3432),
		new AABB(2864, 3432, 2866, 3424),
		new AABB(2863, 3433, 2857, 3436),
		new AABB(2856, 3433, 2789, 3439),
		new AABB(2860, 3437, 2857, 3437),
		new AABB(2839, 3444, 2851, 3440),
		new AABB(2851, 3441, 2854, 3440),
		new AABB(2839, 3447, 2844, 3445),
		new AABB(2845, 3445, 2845, 3445),
		new AABB(2838, 3440, 2789, 3462),
		new AABB(2839, 3460, 2842, 3453),
		new AABB(2832, 3463, 2789, 3476),
		new AABB(2802, 3412, 2805, 3410)
	),

	// South Falador
	RIMMINGTON(
		new AABB(2905, 3265, 2995, 3195),
		new AABB(2989, 3195, 2945, 3186)
	),
	PORT_SARIM_BETTYS_HOUSE(3016, 3261,3011, 3256),
	PORT_SARIM(3005, 3265, 3064, 3174),
	MUDSKIPPER_POINT(2977, 3132, 3008, 3102),
	NORTH_OF_MUDSKIPPER(2984, 3169, 3041, 3133),
	IMCANDO_PENINSULA(MUDSKIPPER_POINT, NORTH_OF_MUDSKIPPER),

	SOUTH_FALADOR_FARM(3011, 3322, 3069, 3279),
	CRAFTING_GUILD(2910, 3296, 2945, 3265),
	// entire area south of falador, encompassing all of the above
	SOUTH_FALADOR(
		new AABB(2900, 3308, 3069, 3195),
		new AABB(3060, 3195, 2971, 3100),
		new AABB(2980, 3185, 2924, 3202)
	),
	ASGARNIA_ICE_DUNGEON_SNOWY(3085, 9531, 3020, 9605),

	// Karamja
	KARAMJA_VOLCANO(2827, 3192, 2859, 3158),
	BRIMHAVEN_DOCKS_TEXTURED(2773, 3235, 2771, 3223),
	BRIMHAVEN_AGILITY_ARENA(11157),

	// Burthorpe
	HEROES_GUILD(
		new AABB(2892, 3507, 2898, 3514),
		new AABB(2894, 3504, 2896, 3517),
		new AABB(2899, 3509, 2901, 3512)
	),
	HEROES_GUILD_BASEMENT(2883, 9919, 2943, 9880),
	WARRIORS_GUILD(
		new AABB(2837, 3555, 2875, 3537),
		new AABB(2859, 3536, 2849, 3534)
	),
	WARRIORS_GUILD_FLOOR_2(2837, 3557, 2877, 3533, 1),
	BURTHORPE(
		new AABB(2830, 3533, 2938, 3576),
		new AABB(2938, 3576, 2880, 3581),
		new AABB(2838, 3538, 2928, 3553),
		new AABB(2873, 3533, 2935, 3521)
	),
	GAMES_ROOM_INNER(2221, 4973, 2194, 4946),
	GAMES_ROOM(8781),


	// Ardougne Interiors
	EAST_ARDOUGNE_FURNACE(2603, 3314, 2600, 3310),
	EAST_ARDOUGNE_BANK_NORTH(2621, 3335, 2612, 3330),
	EAST_ARDOUGNE_COBBLE_OFFICE(
		new AABB(2673, 3323, 2668, 3320),
		new AABB(2675, 3319, 2668, 3318),
		new AABB(2675, 3317, 2671, 3315),
		new AABB(2670, 3317, 2670, 3316)
	),
	EAST_ARDOUGNE_COBBLE_OFFICE_BLENDING(
		new AABB(2668, 3317),
		new AABB(2669, 3316),
		new AABB(2670, 3315)
	),
	EAST_ARDOUGNE_COBBLE_CHRUCH(2612, 3307,2609, 3304, 0),
	EAST_ARDOUGNE_COBBLE_DOCK_HOUSE(
		new AABB(2650, 3272, 2643, 3269),
		new AABB(2650, 3273, 2647, 3273)
	),
	WEST_ARDOUGNE_COBBLE_HOUSES(
		new AABB(2549, 3292, 2547, 3289),
		new AABB(2546, 3292, 2539, 3284),
		new AABB(2529, 3319, 2522, 3313),
		new AABB(2546, 3327, 2542, 3324)
	),
	KHAZARD_BATTLEFIELD_COBBLE(
		new AABB(2526, 3258, 2522, 3255),
		new AABB(2506, 3259, 2500, 3251)
	),

	// Ardougne Exteriors
	EAST_ARDOUGNE_PATHING_FIXES(
		new AABB(2570,3313),
		new AABB(2564,3306),
		new AABB(2565,3307)
	),
	EAST_ARDOUGNE_HAZEL_HOUSE(
		new AABB(2579,3278,2562,3265)
	),
	EAST_ARDOUGNE_BRIDGE(
		new AABB(2603,3298,2594,3295)
	),
	EAST_ARDOUGNE_HANDELMORT_STONE_FLOOR(2645,3327,2625,3308,0),
	EAST_ARDOUGNE_HANDELMORT_BALCONY(2640, 3320, 2630,3318,1),
	WEST_ARDOUGNE(
		new AABB(2460, 3335, 2558, 3279),
		new AABB(2558, 3279, 2510, 3264),
		new AABB(2429, 3323, 2466, 3305)
	),
	WEST_ARDOUGNE_CARPET_FIX(
		new AABB(2544, 3289, 2542, 3286),
		new AABB(2526, 3317, 2526, 3314)
	),
	SOTE_CUTSCENE_ARDOUGNE_SQUARE(13404),
	EAST_ARDOUGNE(merge(
		SOTE_CUTSCENE_ARDOUGNE_SQUARE,
		new AABB(2558, 3342, 2686, 3257)
	)),
	EAST_ARDOUGNE_CASTLE_DIRT_FIX(
		new AABB(2565, 3279, 2592, 3313)
	),
	EAST_ARDOUGNE_CASTLE_PATH_FIX(
		new AABB(2585, 3298, 2593, 3314)
	),
	EAST_ARDOUGNE_BANK(
		new AABB(2658, 3287, 2652, 3280, 0),
		new AABB(2651, 3287, 2649, 3285,0),
		new AABB(2651, 3282, 2649, 3280,0)
	),
	EAST_ARDOUGNE_DOCKS_FIX(
		new AABB(2689,3276,2667,3264)
	),
	CLOCK_TOWER_DUNGEON_COLORED_TILES(2579,9650,2578,9649),

	WITCHAVEN(
		new AABB(2693, 3298, 2744, 3262),
		new AABB(2702, 3299, 2744, 3310),
		new AABB(2714, 3311, 2744, 3320)
	),

	KHAZARD_BATTLEFIELD_COBBLE_OUTSIDE(
		new AABB(2512, 3259, 2507, 3254),
		new AABB(2509, 3251, 2508, 3250),
		new AABB(2518, 3257, 2517, 3256),
		new AABB(2520, 3250, 2514, 3248)
	),

	KANDARIN_MONISTARY(2622,3221,2590,3203),
	KANDARIN_MONISTARY_WINGS_PARTIAL_TILES(
		new AABB(2620,3213,2611,3205),
		new AABB(2601,3213,2592,3205)
	),
	KANDARIN_MONISTARY_WINGS(
			//East Wing
		new AABB(2617,3214,2614,3214),
		new AABB(2618,3213,2613,3213),
		new AABB(2619,3212,2612,3212),
		new AABB(2620,3211,2611,3207),
		new AABB(2621,3210,2621,3208),
		new AABB(2619,3206,2612,3206),
		new AABB(2618,3205,2613,3205),
		new AABB(2617,3204, 2614,3204),
			//West Wing
		new AABB(2598,3214,2595,3214),
		new AABB(2599,3213,2594,3213),
		new AABB(2600,3212,2593,3212),
		new AABB(2601,3211,2592,3207),
		new AABB(2591,3210,2591,3208),
		new AABB(2600,3206,2593,3206),
		new AABB(2599,3205,2594,3205),
		new AABB(2598,3204, 2595,3204)
	),

	// Yanille
	YANILLE_AGILITY_DUNGEON_ENTRANCE(2568, 3122, 2571, 3125),
	YANILLE_BANK(2609, 3088, 2616, 3097),
	YANILLE_WATCHTOWER_TOP(2934, 4718, 2927, 4711, 2),
	YANILLE_WATCHTOWER_MIDDLE(2550,3118, 2543, 3111, 1),
	YANILLE_WATCHTOWER_BOTTOM_DOORWAY(2550, 3115, 2550, 3114, 0),
	YANILLE_WATCHTOWER_BOTTOM(
		new AABB(2549, 3118, 2543, 3111, 0), // Main area
		new AABB(2550, 3113, 2550, 3111, 0), // South of doorway
		new AABB(2550, 3118, 2550, 3116, 0)  // North of doorway
	),

	YANILLE_MAGIC_GUILD_FLOORS(
		new AABB(2596, 3094, 2585, 3081, 1),
		new AABB(2596, 3094, 2585, 3081, 2)
	),
	YANILLE_INSTANCE(11593),
	YANILLE(merge(
		new AABB(2531, 3127, 2622, 3070),
		YANILLE_INSTANCE
	)),
	GUTANOTH_CAVE(2560, 9408, 2626, 9475),
	// Nightmare Zone
	NIGHTMARE_ZONE(2241, 4676, 2303, 4722),

	// Castle Wars
	CASTLE_WARS_LOBBY(2434, 3104, 2448, 3080),
	CASTLE_WARS_ARENA_SARADOMIN_SIDE(
		new AABB(2435, 3068, 2373, 3086),
		new AABB(3282, 3086, 2435, 3091),
		new AABB(2435, 3091, 2388, 3093),
		new AABB(2404, 3093, 2435, 3095),
		new AABB(2435, 3095, 2407, 3098),
		new AABB(2409, 3098, 2435, 3117),
		new AABB(2435, 3117, 2414, 3123),
		new AABB(2420, 3123, 2430, 3127),
		new AABB(2400, 3104, 2411, 3092),
		new AABB(2400, 3113, 2411, 3103)
	),
	CASTLE_WARS_ARENA_ZAMORAK_SIDE(
		new AABB(2364, 3139, 2423, 3125),
		new AABB(2417, 3125, 2364, 3120),
		new AABB(2364, 3120, 2412, 3114),
		new AABB(2400, 3114, 2364, 3104),
		new AABB(2364, 3105, 2399, 3093),
		new AABB(2384, 3093, 2354, 3087),
		new AABB(2364, 3087, 2374, 3082)
	),
	CASTLE_WARS_ARENA(2364, 3139, 2435, 3068),
	CASTLE_WARS_UNDERGROUND(2444, 9544, 2361, 9473),
	CASTLE_WARS(
		new AABB(2364, 3139, 2435, 3068),
		new AABB(2434, 3104, 2448, 3080)
	),

	// Last Man Standing
	LMS_ARENA_WILD_VARROCK(regionBox(13918, 14432)),
	LMS_ARENA_DESERTED_ISLAND(regionBox(13658, 13916)),

	CLAN_WARS_ARENAS_OVERWORLD(
		regionBox(13644, 13646),
		new AABB(3384, 5112, 3391, 5096)
	),
	CLAN_WARS_ARENAS_OTHER(
		regionBox(13641, 13642),
		regionBox(13133, 13135),
		new AABB(3384, 5119, 3391, 5113),
		new AABB(3384, 5095, 3391, 5080)
	),
	CLAN_WARS_ARENAS(
		CLAN_WARS_ARENAS_OVERWORLD,
		CLAN_WARS_ARENAS_OTHER
	),

	// Kharidian desert
	SMOKE_DUNGEON(3198, 9409, 3329, 9341),
	PVP_ARENA(3312, 3290, 3407, 3199),
	SHANTAY_PASS(3294, 3135, 3311, 3114),
	MAGE_TRAINING_ARENA(3347, 3327, 3374, 3288),
	AL_KHARID_GRASS_FIXES(
		new AABB(3348, 3293, 3415, 3329, 0),
		new AABB(3399, 3267, 3414, 3292, 0),
		new AABB(3393, 3269, 3398, 3292, 0),
		new AABB(3389, 3274, 3392, 3292, 0),
		new AABB(3383, 3290, 3385, 3292, 0),
		new AABB(3358, 3292, 3382, 3292, 0),
		new AABB(3365, 3291, 3375, 3291, 0),
		new AABB(3316, 3328, 3327, 3330, 0),
		new AABB(3347, 3298, 3347, 3314, 0),
		new AABB(3266, 3262, 3269, 3263, 0),
		new AABB(3275, 3294, 3275, 3295, 0),
		new AABB(3292, 3328, 3300, 3329, 0)
	),
	AL_KHARID_DIRT_FIX(
		new AABB(3328, 3310, 3344, 3327, 0),
		new AABB(3335, 3309, 3341, 3309, 0),
		new AABB(3337, 3308, 3341, 3308, 0),
		new AABB(3339, 3307, 3341, 3307, 0),
		new AABB(3301, 3328, 3303, 3330, 0),
		new AABB(3341, 3306),
		new AABB(3275, 3321, 3291, 3329, 0)
	),
	AL_KHARID_WELL(3293,3183,3293,3183),
	AL_KHARID_BUILDINGS(
		new AABB(3265, 3173, 3272, 3161),
		new AABB(3270, 3194, 3279, 3179),
		new AABB(3285, 3192, 3290, 3187),
		new AABB(3289, 3206, 3296, 3202),
		new AABB(3297, 3194, 3306, 3185),
		new AABB(3319, 3197, 3323, 3191),
		new AABB(3312, 3186, 3318, 3173),
		new AABB(3313, 3165, 3318, 3160),
		new AABB(3282, 3177, 3303, 3159)
	),
	AL_KHARID(
		new AABB(3276, 3265, 3337, 3195),
		new AABB(3259, 3201, 3345, 3135),
		new AABB(3253, 3182, 3265, 3155)
	),
	EAST_AL_KHARID(
		new AABB(3344, 3200, 3384, 3129),
		new AABB(3384, 3141, 3391, 3203),
		new AABB(3391, 3203, 3412, 3164),
		new AABB(3412, 3170, 3426, 3197)
	),
	AL_KHARID_MINE(3270, 3322, 3337, 3258),
	DESERT_MINING_CAMP(3272, 3042, 3306, 3011),
	AGILITY_PYRAMID_TOP(12105),
	// Sophanem and Menaphos
	SOPHANEM_TEMPLE_FLOORS(
		new AABB(3316, 2803, 3308, 2796, 0),
		new AABB(3307, 2803, 3307, 2801, 0),
		new AABB(3307, 2798, 3307, 2796, 0),
		new AABB(3285, 2777, 3277, 2765, 0),
		new AABB(3277, 2764, 3279, 2764, 0),
		new AABB(3285, 2764, 3283, 2764, 0)
	),
	SOPHANEM_BUILDING_FLOORS(
		new AABB(3313, 2792, 3318, 2782, 0),
		new AABB(3312, 2777, 3317, 2763, 0),
		new AABB(3312, 2758, 3316, 2753, 0),
		new AABB(3288, 2756, 3280, 2753, 0),
		new AABB(3280, 2757, 3284, 2757, 0)
	),
	SOPHANEM_UPPER_FLOORS(3268, 2810, 3322, 2747, 1),
	SOPHANEM_TEMPLE_UPPER_FLOORS(
		new AABB(3306, 2803, 3316, 2796, 1),
		new AABB(3306, 2803, 3316, 2796, 2),
		new AABB(3306, 2803, 3316, 2796, 3)
	),
	SOPHANEM_PYRAMIDS(
		new AABB(3282, 2801, 3295, 2788),
		new AABB(3287, 2780, 3302, 2765)
	),
	SOPHANEM_TEMPLE_BANK(11088),
	SOPHANEM_TRAPDOOR(new AABB(3315, 2797, 0)),
	SOPHANEM(3268, 2810, 3322, 2747),

	KHARIDIAN_DESERT_DEEP(merge(
		new AABB(3198, 2989, 3322, 2817),
		new AABB(3315, 2928, 3469, 2812),
		AGILITY_PYRAMID_TOP
	)),
	KHARIDIAN_DESERT_MID(
		new AABB(3135, 3051, 3524, 2885)
	),
	KHARIDIAN_DESERT(
		new AABB(3196, 3134, 3526, 2997),
		new AABB(3134, 3069, 3565, 2600),
		new AABB(3114, 2974, 3216, 2786)
	),
	KHARID_DESERT_REGION(
		new AABB(3268, 3321, 3414, 2672),
		new AABB(3271, 3327, 3392, 3322),
		new AABB(3356, 3328, 3392, 3329),
		new AABB(3350, 3328, 3316, 3329),
		new AABB(3319, 3330, 3322, 3330),
		new AABB(3315, 3328, 3271, 3328),
		new AABB(3271, 3329, 3306, 3329),
		new AABB(3304, 3330, 3300, 3330),
		new AABB(3267, 3321, 3267, 3233),
		new AABB(3266, 3240, 3266, 3297),
		new AABB(3265, 3254, 3265, 3247),
		new AABB(3415, 3191, 3424, 3172),
		new AABB(3415, 3171, 3480, 2748),
		new AABB(3481, 3132, 3544, 2907),
		new AABB(3267, 3135, 3175, 2671),
		new AABB(3174, 3066, 3129, 2623),
		new AABB(3267, 3203, 3266, 3136),
		new AABB(3267, 3223, 3267, 3204),
		new AABB(3265, 3148, 3254, 3183),
		new AABB(3265, 3184, 3259, 3200),
		new AABB(3265, 3201, 3265, 3202),
		new AABB(3264, 3201, 3264, 3201)
	),
	DESERT_TREASURE_PYRAMID(
		new AABB(3198, 9339, 3267, 9275),
		new AABB(2755, 4934, 2812, 4982),
		new AABB(2825, 4976, 2873, 4938),
		new AABB(2894, 4972, 2933, 4941)
	),
	PYRAMID_PLUNDER(7749),
	NECROPOLIS(
		new AABB(3275, 2749, 3405, 2670),
		new AABB(3322, 2773, 3370, 2750)
	),
	RIVER_ELID_WATERFALL(3369, 3131, 3370, 3133),
	KALPHITE_LAIR(13972),
	SCARAB_LAIR_TEMPLE(8516),
	SCARAB_LAIR_BOTTOM(9027),

	// Morytania
	CANIFIS_BAR_FLOOR(
		new AABB(3504, 3477, 3488, 3471),
		new AABB(3499, 3470, 3488, 3468),
		new AABB(3500, 3470, 3500, 3469),
		new AABB(3501, 3470),
		new AABB(3497, 3479, 3491, 3479)
	),
	CANIFIS_BAR_FLOOR_BLENDED(
		new AABB(3498, 3478),
		new AABB(3490, 3478),
		new AABB(3502, 3470),
		new AABB(3501, 3496),
		new AABB(3500, 3468)
	),
	// Slepe
	CROMBWICK_MANOR(new AABB(3713, 3350, 1, 3738, 3367, 3)),
	SLEPE_CHURCH(
		new AABB(3734, 3324, 3742, 3306),
		new AABB(3736, 3305, 3740, 3302),
		new AABB(3743, 3319, 3744, 3316),
		new AABB(3733, 3319, 3733, 3316)
	),
	SLEPE_HOUSES(
		new AABB(3740, 3340, 3751, 3333),
		new AABB(3697, 3341, 3703, 3329),
		new AABB(3692, 3316, 3698, 3313),
		new AABB(3690, 3312, 3698, 3310),
		new AABB(3690, 3309, 3695, 3306),
		new AABB(3701, 3305, 3710, 3296),
		new AABB(3714, 3308, 3721, 3301)
	),
	SLEPE(
		new AABB(3705, 3396, 3772, 3289),
		new AABB(3689, 3342, 3704, 3292),
		new AABB(3685, 3317, 3688, 3311),
		new AABB(3709, 3401, 3729, 3397),
		new AABB(3730, 3414, 3769, 3397)
	),

	// Hallowed Sepulchre
	HALLOWED_SEPULCHRE_LOBBY(2380, 5958, 2420, 6000),
	HALLOWED_SEPULCHRE_FLOOR_1(2220, 5938, 2325, 6032),
	HALLOWED_SEPULCHRE_FLOOR_2(2475, 5938, 2580, 6032),
	HALLOWED_SEPULCHRE_FLOOR_3(2350, 5800, 2455, 5906),
	HALLOWED_SEPULCHRE_FLOOR_4(2475, 5800, 2580, 5906),
	HALLOWED_SEPULCHRE_FLOOR_5(2220, 5800, 2325, 5906),
	VER_SINHAZA_WATER_FIX(
		new AABB(3682, 3257, 3682, 3257),
		new AABB(3681, 3256, 3681, 3256),
		new AABB(3684, 3259, 3678, 3263),
		new AABB(3683, 3258, 3683, 3258)
	),
	VER_SINHAZA_CUTSCENE(2087, 4903, 2064, 4880),
	VER_SINHAZA(merge(
		VER_SINHAZA_CUTSCENE,
		new AABB(3641, 3236, 3684, 3202)
	)),
	MEIYERDITCH(
		new AABB(3587, 3310, 3627, 3200),
		new AABB(3618, 3327, 3647, 3311),
		new AABB(3628, 3310, 3647, 3239),
		new AABB(3628, 3238, 3637, 3232),
		new AABB(3638, 3238, 3639, 3237),
		new AABB(3628, 3231, 3630, 3229),
		new AABB(3628, 3208, 3632, 3200),
		new AABB(3633, 3206, 3637, 3200),
		new AABB(3586, 3199, 3647, 3136)
	),
	MEIYERDITCH_MYREQUE_HIDEOUT(14486),
	MEIYERDITCH_MINES(9544),
	CASTLE_DRAKAN(3520, 3388, 3594, 3328),
	DARKMEYER(
		new AABB(3590, 3399, 3636, 3330),
		new AABB(3636, 3330, 3662, 3392),
		new AABB(3662, 3384, 3669, 3335)
	),
	PORT_PHASMATYS(
		new AABB(3649, 3508, 3688, 3456),
		new AABB(3688, 3456, 3710, 3484),
		new AABB(3670, 3503, 3684, 3514)
	),
	FENKENSTRAINS_CASTLE(3534, 3565, 3562, 3536),
	MORYTANIA_SLAYER_TOWER(3405, 3531, 3452, 3579),
	CANIFIS(13878),
	TEMPLE_TREKKING_INSTANCES(
		regionBox(8014, 8270),
		new AABB(2123, 5036, 2164, 4996),
		regionBox(8782, 9806)
	),
	MORTTON(13875),
	BARROWS_CRYPTS(3520, 9664, 3583, 9727, 3),
	BARROWS_TUNNELS(3520, 9664, 3583, 9727, 0),
	BARROWS(14131),
	BURGH_DE_ROTT(3468, 3258, 3583, 3164),
	BURGH_DE_ROTT_BASEMENT(13974),
	ABANDONED_MINE(3423, 3261, 3461, 3201),
	GROTESQUE_GUARDIANS(6727),
	MORYTANIA(merge(
		new AABB(3432, 3486, 3775, 3167),
		new AABB(3494, 3166, 3775, 3145),
		new AABB(3431, 3204, 3422, 3274),
		new AABB(3431, 3275, 3414, 3294),
		new AABB(3431, 3295, 3417, 3327),
		new AABB(3431, 3328, 3400, 3452),
		new AABB(3400, 3327, 3416, 3321),
		new AABB(3413, 3453, 3431, 3466),
		new AABB(3424, 3467, 3431, 3470),
		new AABB(3432, 3487, 3755, 3598),
		new AABB(3403, 3583, 3431, 3509),
		new AABB(3413, 3508, 3431, 3501),
		new AABB(3416, 3500, 3431, 3496),
		new AABB(3420, 3495, 3431, 3486),
		new AABB(3419, 3486, 3433, 3482),
		VER_SINHAZA_CUTSCENE,
		TEMPLE_TREKKING_INSTANCES,
		GROTESQUE_GUARDIANS
	)),

	// TzHaar
	THE_INFERNO(9043),
	TZHAAR(regionBox(9551, 10064)),

	TREE_GNOME_STRONGHOLD_INSTANCE(regionBox(7766, 8023)),
	TREE_GNOME_STRONGHOLD(merge(
		new AABB(2368, 3525, 2496, 3387),
		new AABB(2404, 3547, 2431, 3511),
		new AABB(2484, 3406, 2507, 3387),
		TREE_GNOME_STRONGHOLD_INSTANCE
	)),
	EYES_OF_GLOUPHRIE_GNOME_AND_GOBLIN_BATTLE_CUTSCENE(2165, 4928, 2112, 4991),

	// Wilderness
	REVENANT_CAVES(regionBox(12701, 12959)),
	FROZEN_WASTE_PLATEAU(
		new AABB(2939, 3970, 2988, 3904),
		new AABB(2988, 3907, 3002, 3940),
		new AABB(2980, 3909, 2939, 3865),
		new AABB(2939, 3865, 2958, 3834)
	),
	WILDERNESS_HIGH(2939, 3974, 3391, 3903),
	WILDERNESS_MID_HIGH(2939, 3903, 3391, 3806),
	WILDERNESS_MID(2939, 3806, 3391, 3730),
	WILDERNESS_MID_LOW(2939, 3730, 3391, 3558),
	WILDERNESS_LOW(2939, 3558, 3391, 3522),
	WILDERNESS(2939, 3974, 3391, 3522),
	WILDERNESS_NORTH_OF_RESOURCE_AREA(3175, 3967, 3202, 3945),
	WILDERNESS_FOUNTAIN_OF_RUNE(3373, 3892, 3375, 3894),
	MAGE_ARENA_BANK(2527, 4725, 2549, 4708),
	MAGE_ARENA_GOD_STATUES(2520, 4730, 2495, 4682),
	GIELINOR_SNOWY_NORTHERN_REGION(2942, 3711, 2748, 3980),
	RELLEKKA_SNOWY_REGION(
		new AABB(2702, 3779, 2747, 3744),
		new AABB(2726, 3802, 2748, 3780),
		new AABB(2711, 3800, 2725, 3780),
		new AABB(2723, 3743, 2758, 3710)
	),
	RELLEKKA_HUNTER_ICEBERG(
		new AABB(2699, 3839, 2741, 3810),
		new AABB(2711, 3809, 2725, 3801),
		new AABB(2726, 3809, 2738, 3803)
	),
	// Trollheim - Weiss Region
	TROLLHEIM(
		regions(
			11577,
			11321,
			11320,
			11576,
			11319,
			11063
		),
		new AABB(2751, 3753, 2726, 3662), // Mountains near Keldagrim Entrance
		new AABB(2780, 3647, 2815, 3584)  // Mountains near Golden Apple Tree
	),
	WEISS_REGION(regions(11325, 11581)),
	WEISS_UNDERGROUND(10842),
	WEISS_FIRE_PIT(2877, 3934, 2875, 3932),
	INTERIOR_WEISS_THRONE_TENT(2877, 3941, 2868, 3931),


	// Fremennik Province
	MOUNTAIN_CAMP_LAKE(
		new AABB(2754, 3707, 2789, 3675),
		new AABB(2789, 3682, 2802, 3708)
	),
	MOUNTAIN_CAMP_ENTRY_PATH(2780, 3673, 2766, 3655),
	MOUNTAIN_CAMP(
		new AABB(2750, 3711, 2815, 3671),
		new AABB(2815, 3671, 2779, 3652)
	),
	RELLEKKA(2594, 3646, 2692, 3747),
	FREMENNIK_PROVINCE(
		new AABB(2692, 3711, 2815, 3639),
		new AABB(2753, 3740, 2752, 3720),
		new AABB(2751, 3712, 2626, 3799),
		new AABB(2739, 3800, 2687, 3838),
		new AABB(2706, 3881, 2730, 3839),
		new AABB(2691, 3711, 2468, 3606),
		new AABB(2566, 3605, 2639, 3583),
		new AABB(2652, 3595, 2640, 3605),
		new AABB(2640, 3594, 2649, 3593),
		new AABB(2653, 3605, 2677, 3599),
		new AABB(2671, 3598, 2666, 3598),
		new AABB(2657, 3598, 2655, 3597),
		new AABB(2678, 3605, 2691, 3603),
		new AABB(2685, 3602, 2701, 3599),
		new AABB(2692, 3638, 2798, 3603),
		new AABB(2795, 3602, 2702, 3598),
		new AABB(2714, 3597, 2730, 3594),
		new AABB(2731, 3597, 2792, 3592),
		new AABB(2740, 3591, 2756, 3590),
		new AABB(2742, 3589, 2747, 3588),
		new AABB(2758, 3591, 2790, 3586),
		new AABB(2765, 3585, 2786, 3577)
	),
	FREMENNIK_SLAYER_DUNGEON(regions(10907, 10908, 11164)),
	KELDAGRIM_INTERIORS(
		new AABB(2841, 10215, 2834, 10204), // Bank
		new AABB(2834, 10199, 2844, 10191), // Bar
		new AABB(2861, 10212, 2897, 10185), // Palace
		new AABB(2857, 10228, 2865, 10221), // Library
		new AABB(2903, 10219, 2907, 10213), // Food Shop
		new AABB(2922, 10214, 2926, 10209), // Mining Shop
		new AABB(2909, 10196, 2918, 10192), // Brewery 1
		new AABB(2913, 10191, 2918, 10187), // Brewery 2
		new AABB(2927, 10198, 2936, 10185), // Blast Furnace 1
		new AABB(2932, 10200, 2936, 10199), // Blast Furnace 2
		new AABB(2846, 10186, 2851, 10182), // Stone Mason
		new AABB(2823, 10233, 2831, 10228), // Sword Shop 1
		new AABB(2824, 10227, 2830, 10223), // Sworp Shop 2
		new AABB(2903, 10208, 2910, 10201), // Scluptors
		new AABB(2848, 10227, 2853, 10221)
	),
	RED_AXE_REGION(7501),
	KELDAGRIM(regions(11422, 11423, 11678, 11679)),

	// Tirannwn
	GWENITH(2187, 3424, 2229, 3397),
	PRIFDDINAS(regionBox(12637, 13408)),
	ZALCANO(12126),
	MYNYDD(2119, 3453, 2215, 3384),
	LLETYA(2313, 3147, 2363, 3194),
	LLETYA_UPPER_LEVELS(
		new AABB(2313, 3147, 2363, 3194,1),
		new AABB(2313, 3147, 2363, 3194,2)
	),

	POISON_WASTE(
		new AABB(2166, 3119, 2315, 3025),
		new AABB(2181, 3117, 2280, 3131),
		new AABB(2301, 3137, 2364, 3079)
	),
	POISON_WASTE_DUNGEON(regions(5954, 5955)),
	ARANDAR_MAINLAND(2309, 3337, 2394, 3234),
	ARANDAR_PRIFDDINAS(3333, 6089, 3391, 5986),
	ARANDAR(ARANDAR_MAINLAND, ARANDAR_PRIFDDINAS),
	SOTE_GRAND_LIBRARY(regionBox(10335, 10592)),
	SOTE_LLETYA_ON_FIRE(11616),
	SOTE_LLETYA_MOSTLY_DONE_BURNING(11103),
	SOTE_TEMPLE_OF_LIGHT_SEREN_CUTSCENE(3237, 5913, 3219, 5933),
	SOTE_FRAGMENT_OF_SEREN_ARENA(3264, 5887, 3328, 5951),
	SOTE_CUTSCENE_LLETYA(regionBox(10846, 11360)),
	TYRAS_CAMP_INSTANCE(9287),
	TEMPLE_OF_LIGHT_EXCAVATION(regions(7752, 8008)),
	TEMPLE_OF_LIGHT(7496),
	EAST_ARDOUGNE_UNDERGROUND(TEMPLE_OF_LIGHT,TEMPLE_OF_LIGHT_EXCAVATION),
	TIRANNWN_MAINLAND(merge(
		SOTE_LLETYA_ON_FIRE,
		SOTE_CUTSCENE_LLETYA,
		new AABB(2116, 3455, 2320, 3021),
		new AABB(2321, 3202, 2365, 3140),
		new AABB(2392, 3334, 2321, 3227)
	)),
	TIRANNWN(TIRANNWN_MAINLAND, PRIFDDINAS),

	ZANARIS(2315, 4345, 2500, 4485),

	GOD_WARS_DUNGEON_WILDERNESS(12190),
	GOD_WARS_DUNGEON(merge(
		regionBox(11345, 11603),
		GOD_WARS_DUNGEON_WILDERNESS
	)),

	// Soul Wars
	ISLE_OF_SOULS_DUNGEON(8593),
	ISLE_OF_SOULS_MAINLAND(regionBox(8235, 9262)),
	ISLE_OF_SOULS_INSTANCE(regionBox(7515, 8542)),
	ISLE_OF_SOULS(ISLE_OF_SOULS_MAINLAND, ISLE_OF_SOULS_INSTANCE),
	ISLE_OF_SOULS_HOT_ZONES(
		new AABB(2270, 2944, 2301, 2884), // Red Base
		new AABB(2269, 2912, 2265, 2890),
		new AABB(2261, 2912, 2264, 2892),
		new AABB(2262, 2914, 2249, 2913),
		new AABB(2253, 2912, 2260, 2894),
		new AABB(2248, 2912, 2252, 2895),
		new AABB(2246, 2910, 2247, 2899),
		new AABB(2244, 2909, 2245, 2900),
		new AABB(2240, 2968, 2264, 2961), // Pyre Fiends
		new AABB(2268, 2960, 2241, 2957),
		new AABB(2266, 2956, 2245, 2952),
		new AABB(2239, 2967, 2239, 2964),
		new AABB(2266, 2963, 2266, 2961),
		new AABB(2248, 2969, 2260, 2969),
		new AABB(2250, 2970, 2253, 2970),
		new AABB(2265, 2967, 2265, 2961)
	),
	SOUL_WARS_ARENA_TUTORIAL(1921, 6018, 2110, 5950),
	SOUL_WARS_RED_BASE_TUTORIAL(
		new AABB(2080, 6018, 2110, 5982),
		new AABB(2105, 5982, 2076, 5956),
		new AABB(2081, 5963, 2048, 6010),
		new AABB(2048, 6010, 2068, 5954)
	),
	SOUL_WARS_BLUE_BASE_TUTORIAL(
		new AABB(1924, 5953, 1953, 6013),
		new AABB(1953, 6013, 1985, 5961)
	),
	SOUL_WARS_ARENA(merge(
		SOUL_WARS_ARENA_TUTORIAL,
		new AABB(2113, 2946, 2302, 2878)
	)),
	SOUL_WARS_RED_BASE(merge(
		SOUL_WARS_RED_BASE_TUTORIAL,
		new AABB(2272, 2946, 2302, 2910),
		new AABB(2297, 2910, 2268, 2884),
		new AABB(2273, 2891, 2240, 2938),
		new AABB(2240, 2938, 2260, 2882)
	)),
	SOUL_WARS_BLUE_BASE(merge(
		SOUL_WARS_BLUE_BASE_TUTORIAL,
		new AABB(2116, 2881, 2145, 2941),
		new AABB(2145, 2941, 2177, 2889)
	)),

	// Zeah
	UNDERGROUND_OLD_ONES_RUINS(regions(5274, 5276, 5532, 5785)),
	KARUULM_SLAYER_DUNGEON(
		regions(5536),
		regionBox(5022, 5023),
		regionBox(5279, 5280),
		new AABB(1344, 10239, 1354, 10231)
	),
	MOUNT_KARUULM(1245,3765,1358,3860),
	LIZARDMAN_TEMPLE(5277),
	XERICS_LOOKOUT(1580, 3526, 1596, 3534),
	SHAYZIEN_COMBAT_RING(1539, 3627, 1548, 3618),
	SHAYZIEN_ENCAMPMENT(
		new AABB(1467, 3678, 1540, 3607),
		new AABB(1540, 3613, 1559, 3650)
	),
	SHAYZIEN_SHAYZIA_RUIN(1577, 3587, 1594, 3604),
	SHAYZIEN_GRAVEYARD_OF_HEROES(1472, 3583, 1515, 3541),
	SHAYZIEN_EAST_ENTRANCE_BLEND_FIX(1556, 3577, 1556, 3575),
	SHAYZIEN(
		new AABB(1467, 3678, 1540, 3607), // encampment
		new AABB(1540, 3613, 1559, 3650), // encampment
		new AABB(1477, 3616, 1525, 3584),
		new AABB(1460, 3599, 1574, 3537),
		new AABB(1574, 3537, 1535, 3523),
		new AABB(1595, 3584, 1567, 3606)  // shayzia ruin
	),
	HOSIDIUS(1720, 3641, 1802, 3560),
	SKOTIZO(9048),
	KOUREND_CATACOMBS(merge(
		SKOTIZO,
		regionBox(6556, 6813)
	)),
	BLOOD_ALTAR(
		new AABB(1703, 3844, 1739, 3815),
		new AABB(1739, 3817, 1751, 3839),
		new AABB(1751, 3833, 1791, 3815)
	),
	DARK_ALTAR(1660, 3904, 1747, 3864),
	ARCEUUS(
		new AABB(1572, 3838, 1597, 3799),
		new AABB(1566, 3832, 1586, 3805),
		new AABB(1562, 3823, 1570, 3811),
		new AABB(1588, 3838, 1608, 3778),
		new AABB(1598, 3854, 1730, 3731),
		new AABB(1730, 3731, 1623, 3710),
		new AABB(1616, 3874, 1658, 3842),
		new AABB(1625, 3905, 1856, 3817)
	),
	ZEAH_SNOWY_NORTHERN_REGION(
		new AABB(1852, 3901, 1914, 3839),
		new AABB(1503, 3901, 1636, 3887),
		new AABB(1513, 3886, 1622, 3876),
		new AABB(1518, 3875, 1600, 3839),
		new AABB(1637, 3901, 1668, 3894),
		new AABB(1407, 3902, 1900, 3965),
		new AABB(1655, 3966, 1818, 4058),
		new AABB(1605, 3966, 1503, 4058)
	),
	WINTERTODT_ARENA(1606, 3966, 1654, 4058),
	LOVAKENGJ(
		new AABB(1421, 3844, 1560, 3788),
		new AABB(1418, 3878, 1517, 3845),
		new AABB(1518, 3871, 1525, 3845),
		new AABB(1526, 3865, 1530, 3845),
		new AABB(1422, 3889, 1508, 3879),
		new AABB(1445, 3890, 1498, 3894),
		new AABB(1457, 3900, 1473, 3895),
		new AABB(1436, 3787, 1587, 3756),
		new AABB(1438, 3755, 1582, 3745),
		new AABB(1445, 3744, 1555, 3737),
		new AABB(1473, 3736, 1555, 3734),
		new AABB(1556, 3744, 1562, 3734),
		new AABB(1552, 3733, 1502, 3730),
		new AABB(1509, 3729, 1547, 3727),
		new AABB(1517, 3726, 1544, 3724),
		new AABB(1529, 3723, 1543, 3716),
		new AABB(1561, 3810, 1562, 3788),
		new AABB(1563, 3809, 1563, 3788),
		new AABB(1564, 3808, 1564, 3788),
		new AABB(1565, 3807, 1565, 3788),
		new AABB(1566, 3806, 1566, 3788),
		new AABB(1567, 3805, 1567, 3788),
		new AABB(1568, 3804, 1568, 3788),
		new AABB(1569, 3803, 1569, 3799),
		new AABB(1570, 3802, 1570, 3799),
		new AABB(1571, 3801, 1571, 3799),
		new AABB(1572, 3800, 1572, 3799),
		new AABB(1573, 3799, 1573, 3799),
		new AABB(1569, 3798, 1583, 3788),
		new AABB(1584, 3797, 1584, 3788),
		new AABB(1428, 3787, 1435, 3780),
		new AABB(1553, 3733, 1561, 3731),
		new AABB(1553, 3730, 1556, 3730),
		new AABB(1588, 3782, 1590, 3770),
		new AABB(1591, 3773, 1597, 3770),
		new AABB(1591, 3778, 1596, 3774),
		new AABB(1591, 3781, 1591, 3779),
		new AABB(1592, 3779, 1593, 3779),
		new AABB(1588, 3783, 1589, 3783),
		new AABB(1583, 3755, 1586, 3748),
		new AABB(1563, 3744, 1577, 3743),
		new AABB(1563, 3742, 1569, 3742),
		new AABB(1420, 3844, 1419, 3815)
	),
	MOUNT_QUIDAMORTEM(
		new AABB(1194, 3594, 1292, 3520),
		new AABB(1287, 3556, 1300, 3596),
		new AABB(1300, 3596, 1308, 3580),
		new AABB(1230, 3611, 1269, 3588)
	),
	KEBOS_LOWLANDS(
		new AABB(1167, 3664, 1345, 3582),
		new AABB(1292, 3588, 1355, 3526),
		new AABB(1275, 3692, 1329, 3631)
	),
	ZEAH_WOODLAND_AREAS(
		new AABB(1430, 3677, 1897, 3383),
		new AABB(1539, 3711, 1639, 3678),
		new AABB(1548, 3732, 1617, 3712),
		new AABB(1640, 3707, 1897, 3678),
		new AABB(1735, 3708, 1856, 3815),
		new AABB(1198, 3790, 1253, 3665),
		new AABB(1254, 3772, 1287, 3693),
		new AABB(1288, 3764, 1324, 3694),
		new AABB(1325, 3755, 1351, 3694),
		new AABB(1352, 3751, 1363, 3715),
		new AABB(1272, 3692, 1254, 3666),
		new AABB(1400, 3589, 1429, 3465)
	),
	MESS_HALL_KITCHEN(1643, 3631, 1649, 3622),
	THE_STRANGLEWOOD_EXTENDED(1378, 3476, 1080, 3264),
	THE_STRANGLEWOOD(
		regionBox(4403, 4659),
		regionBox(4404, 4917)
	),
	THE_STRANGLEWOOD_QUEST_UNDERGROUND_AREAS(regionBox(4760, 4761)),
	JUDGE_OF_YAMA_BOSS(regionBox(6492, 6748)),
	XAMPHUR_BOSS(12124),
	SARACHNIS_LAIR(new AABB(1830, 9890, 1853, 9913)),
	ZEAH_UPPER_LEVELS(new AABB(1085, 4078, 1, 1938, 2870, 3)),
	ZEAH(1085, 4078, 1938, 2870),

	// Fossil Island
	FOSSIL_ISLAND_WYVERN_TASK_CAVE(14496),
	TAR_SWAMP(
		new AABB(3712, 3800, 3632, 3694),
		new AABB(3697, 3809, 3631, 3782)
	),
	FOSSIL_ISLAND_CENTRAL_BANK_FIX(
		new AABB(3744, 3805, 3742, 3802)
	),
	FOSSIL_ISLAND_HILL_HOUSE_INTERIOR(
		new AABB(3772, 3872, 3770, 3867),
		new AABB(3769, 3875, 3759, 3864),
		new AABB(3758, 3874, 3758, 3871),
		new AABB(3758, 3867, 3758, 3864)
	),
	FOSSIL_ISLAND_HILL_HOUSE_FIX(
		new AABB(3799, 3885, 3747, 3858)
	),
	FOSSIL_ISLAND_HILL_TEXTURE_FIX(
		new AABB(3845, 3900, 3657, 3720)
	),
	FOSSIL_ISLAND_VOLCANO(
		new AABB(3789, 3841, 3833, 3802),
		new AABB(3788, 3831, 3784, 3802),
		new AABB(3781, 3828, 3783, 3819),
		new AABB(3783, 3814, 3781, 3802),
		new AABB(3777, 3812, 3780, 3802),
		new AABB(3768, 3801, 3826, 3778),
		new AABB(3829, 3801, 3827, 3782),
		new AABB(3826, 3762, 3836, 3749),
		new AABB(3810, 3748, 3820, 3738),
		new AABB(3772, 3777, 3824, 3774),
		new AABB(3776, 3807, 3775, 3802),
		new AABB(3776, 3773, 3789, 3750),
		new AABB(3790, 3773, 3825, 3755)
	),
	FOSSIL_ISLAND(3626, 3908, 3851, 3693),

	APE_ATOLL_WATERFALLS(
		new AABB(2754, 2734, 2754, 2736),
		new AABB(2751, 2738, 2752, 2738)
	),

	// Karamja
	KARAMJA_INSTANCE_SOUTH_OF_MUSA_POINT(10055),
	KARAMJA_INSTANCE_SHIPYARD(2560, 4607, 2642, 4544),
	KARAMJA_INSTANCES(
		KARAMJA_INSTANCE_SOUTH_OF_MUSA_POINT,
		KARAMJA_INSTANCE_SHIPYARD
	),
	KARAMJA_VOLCANO_DUNGEON(2821, 9663, 2875, 9541),
	KARAMJA(merge(
		new AABB(2686, 3257, 2809, 3124),
		new AABB(2810, 3124, 2917, 3209),
		new AABB(2918, 3184, 2964, 3132),
		new AABB(2746, 3123, 2973, 2873),
		new AABB(2974, 2873, 3009, 3081),
		KARAMJA_INSTANCES
	)),

	// Zanaris
	COSMIC_ENTITYS_PLANE(2048, 4863, 2111, 4800),

	// islands
	VOID_KNIGHTS_OUTPOST(10537),
	PEST_CONTROL(10536),
	CRASH_ISLAND(11562),
	ENTRANA_GLASS_BUILDING_FIX(
		new AABB(2829,3347,2835,3353),
		new AABB(2829,3346,2829,3346),
		new AABB(2833,3346,2833,3346)
	),
	ENTRANA(
		new AABB(2798, 3396, 2873, 3326),
		new AABB(2873, 3326, 2882, 3344)
	),
	CRANDOR(2810, 3314, 2869, 3221),
	FISHING_PLATFORM(2756, 3295, 2799, 3268),
	MOS_LE_HARMLESS(3643, 3075, 3858, 2923),
	MOS_LE_HARMLESS_INSTANCE(1952, 5344, 1983, 5312),
	MOS_LE_HARMLESS_ALL(MOS_LE_HARMLESS, MOS_LE_HARMLESS_INSTANCE),
	BRAINDEATH_ISLAND(
		regions(8784),
		new AABB(2112, 5042, 2175, 5183)
	),
	HARMONY(15148),
	DRAGONTOOTH_ISLAND(15159),
	ICEBERG(2622, 4091, 2686, 3974),
	PENGUIN_BASE(2684, 10431, 2631, 10369),
	ISLAND_OF_STONE(9790),
	MISCELLANIA(2485, 3923, 2629, 3800),
	WATERBIRTH_ISLAND(10042),
	NEITIZNOT(9275),
	JATIZSO(9531),
	FREMENNIK_ISLES_NORTH(regionBox(9276, 9532)),
	FREMENNIK_ISLES(
		JATIZSO,
		NEITIZNOT,
		FREMENNIK_ISLES_NORTH
	),
	UNGAEL(9023),
	PIRATES_COVE(8763),

	// Lunar Isle
	LUNAR_DREAM_WORLD(
		regions(6991),
		regionBox(7247, 7250)
	),
	LUNAR_VILLAGE_HOUSE_INTERIORS_GROUND(
		new AABB(2104, 3922, 2097, 3917, 0), // Bank
		new AABB(2091, 3922, 2090, 3922, 0), // House 1
		new AABB(2092, 3921, 2089, 3917, 0), // House 1
		new AABB(2084, 3922, 2082, 3921, 0), // House 2
		new AABB(2075, 3922, 2070, 3919), // Pauline's House
		// Brazier House Start
		new AABB(2078, 3915, 0),
		new AABB(2069, 3915, 0),
		new AABB(2071, 3907, 0),
		new AABB(2081, 3914, 2066, 3913, 0),
		new AABB(2081, 3912, 2069, 3910, 0),
		new AABB(2068, 3910, 2066, 3908, 0),
		new AABB(2078, 3909, 2069, 3909, 0),
		new AABB(2078, 3908, 2075, 3908, 0),
		new AABB(2072, 3908, 2069, 3908, 0),
		// Brazier House End //
		new AABB(2090, 3909, 2086, 3904, 0), // House 3
		new AABB(2098, 3908, 2094, 3905, 0), // General Store
		// Clothing Store Start
		new AABB(2107, 3911, 0),
		new AABB(2102, 3911, 0),
		new AABB(2107, 3904, 0),
		new AABB(2103, 3904, 0),
		new AABB(2107, 3910, 2102, 3905, 0),
		// Clothing Store End //
		new AABB(2076,3899, 2072,3897), // House 4
		// House 5 Start
		new AABB(2084, 3899, 2083, 3892, 0),
		new AABB(2082, 3897, 2080, 3893, 0),
		new AABB(2082, 3892, 2081, 3892, 0),
		// House 5 End //
		new AABB(2092, 3900, 2089, 3899, 0), // House 6
		new AABB(2092, 3898, 2091, 3896, 0), // house 6
		new AABB(2101, 3898, 2099, 3897, 0), // House 7
		new AABB(2102, 3901, 2096, 3896, 0)  // House 7
	),
	LUNAR_VILLAGE_HOUSE_INTERIORS_FIRST(
		new AABB(2091, 3922, 2090, 3922, 1), // House 1
		new AABB(2092, 3921, 2089, 3917, 1), // House 1
		new AABB(2084, 3922, 2082, 3919, 1), // House 2
		// Brazier House Start
		new AABB(2078, 3915, 1),
		new AABB(2069, 3915, 1),
		new AABB(2071, 3907, 1),
		new AABB(2079, 3915, 2079, 3910, 1),
		new AABB(2078, 3915, 2076, 3908, 1),
		new AABB(2082, 3915, 2080, 3904, 1),
		new AABB(2079, 3909, 2079, 3904, 1),
		new AABB(2078, 3907, 2074, 3904, 1),
		// Brazier House End //
		new AABB(2091, 3910, 2085, 3903, 1), // House 3
		new AABB(2100, 3911, 2094, 3904, 1), // General Store
		// Clothing Store Start
		new AABB(2108, 3912, 2101, 3903, 1),
		// Clothing Store End //
		new AABB(2085, 3900, 2079, 3891, 1),
		// House 5 End //
		new AABB(2093, 3901, 2088, 3890, 1), // House 6
		new AABB(2101, 3899, 2097, 3899, 1), // House 7
		new AABB(2101, 3898, 2099, 3897, 1), // House 7
		new AABB(2102, 3901, 2096, 3896, 1)  // House 7
	),
	LUNAR_ESSENCE_MINE(9377),
	LADY_ZAY(
		new AABB(2135, 3917, 2145, 3887), // Lunar Isle
		new AABB(2219, 3814, 2229, 3784) // Pirates Cove
	),
	LUNAR_ISLE(regionBox(8252, 8509)),

	// Ape Atoll
	// Monkey Madness 2
	MM2_AIRSHIP_PLATFORM(2056, 5375, 2109, 5442),
	APE_ATOLL(regionBox(10794, 11051)),


	// Zeah
	KOUREND_CASTLE_ENTRANCE_FIX(1623, 3677, 1623, 3669, 0),
	KOUREND_CASTLE(
		new AABB(1626, 3690, 1587, 3656, 0),
		new AABB(1617, 3690, 1610, 3656, 1),
		new AABB(1619, 3690, 1618, 3684, 1),
		new AABB(1621, 3683, 1618, 3676, 1),
		new AABB(1621, 3670, 1618, 3663, 1),
		new AABB(1619, 3662, 1618, 3656, 1),
		new AABB(1609, 3683, 1608, 3676, 1),
		new AABB(1609, 3670, 1608, 3663, 1),
		new AABB(1607, 3683, 1605, 3681, 1),
		new AABB(1607, 3665, 1605, 3663, 1),
		new AABB(1604, 3685, 1586, 3661, 1),
		new AABB(1621, 3690, 1610, 3656, 2),
		new AABB(1599, 3685, 1591, 3681, 2),
		new AABB(1599, 3667, 1591, 3661, 2)
	),
	KOUREND_GUARDPOSTS(
		new AABB(1615, 3700, 1613, 3695, 0),
		new AABB(1615, 3700, 1613, 3695, 1),
		new AABB(1692, 3678, 1690, 3677, 0),
		new AABB(1692, 3678, 1690, 3677, 1),
		new AABB(1692, 3669, 1690, 3668, 0),
		new AABB(1692, 3669, 1690, 3668, 1),
		new AABB(1626, 3700, 1625, 3699, 0),
		new AABB(1632, 3700, 1631, 3699, 0),
		new AABB(1633, 3647, 1632, 3646, 0),
		new AABB(1625, 3647, 1624, 3646, 0),
		new AABB(1614, 3650, 1613, 3646, 0),
		new AABB(1614, 3650, 1613, 3646, 1)
	),
	KOUREND_HOUSES(
		new AABB(1677, 3692, 1670, 3686),
		new AABB(1683, 3683, 1669, 3677, 0),
		new AABB(1683, 3683, 1669, 3677, 1),
		new AABB(1683, 3682, 1669, 3677, 2),
		new AABB(1683, 3669, 1670, 3663),
		new AABB(1679, 3660, 1674, 3654)
	),
	SHAYZIEN_INTERIORS_COBBLE(
		new AABB(1486, 3552, 1480, 3548, 0),
		new AABB(1513, 3595, 1504, 3589),
		new AABB(1521, 3593, 1517, 3588),
		new AABB(1521, 3587, 1520, 3587),
		new AABB(1518, 3587, 1517, 3587),
		new AABB(1541, 3582, 1531, 3578),
		new AABB(1544, 3572, 1541, 3568),
		new AABB(1540, 3572, 1540, 3571),
		new AABB(1540, 3596, 1540, 3568),
		new AABB(1542, 3558, 1542, 3557),
		new AABB(1542, 3555, 1542, 3554),
		new AABB(1541, 3558, 1538, 3554),
		new AABB(1542, 3549, 1542, 3548),
		new AABB(1542, 3546, 1542, 3541),
		new AABB(1541, 3549, 1538, 3541),
		new AABB(1534, 3547, 1530, 3542),
		new AABB(1553, 3569, 1548, 3560),
		new AABB(1552, 3559, 1549, 3559),
		new AABB(1567, 3571, 1561, 3568),
		new AABB(1567, 3567, 1566, 3567),
		new AABB(1564, 3567, 1561, 3567),
		new AABB(1569, 3547, 1565, 3543)
	),
	SHAYZIEN_BANK(
		new AABB(1491, 3595, 1482, 3589)
	),
	GREAT_KOUREND_STATUE(1641, 3678, 1631, 3668),
	HOSIDIUS_WELL(1764, 3600, 1761, 3597),
	HOSIDIUS_STAIRS(
		new AABB(1763, 3608, 1762, 3607)
	),
	KEBOS_SWAMP_XERIC_DIRT(1241,3621,1234,3614),
	// Fishing Trawler
	FISHING_TRAWLER_BOAT_PORT_KHAZARD(2669, 3183, 2673, 3166),
	FISHING_TRAWLER_BOAT_FLOODED(2012, 4826, 2021, 4824),
	FISHING_TRAWLER(
		new AABB(1792, 4863, 1855, 4734),
		new AABB(1855, 4893, 1920, 4798),
		new AABB(1920, 4863, 1990, 4798),
		new AABB(1990, 4917, 2047, 4798)
	),

	// Underwater areas
	MOGRE_CAMP(11924),
	HARMONY_ISLAND_UNDERWATER_TUNNEL(3779, 9278, 3839, 9216, 1),
	FOSSIL_ISLAND_UNDERWATER_AREA(3712, 10303, 3839, 10240),

	// Runecrafting altars
	COSMIC_ALTAR(2112, 4799, 2176, 4863),
	DEATH_ALTAR(2176, 4799, 2240, 4863),
	CHAOS_ALTAR(2240, 4799, 2304, 4863),
	WRATH_ALTAR(2304, 4799, 2368, 4863),
	NATURE_ALTAR(2368, 4799, 2427, 4863),
	LAW_ALTAR(2427, 4799, 2495, 4863),
	BODY_ALTAR(2495, 4799, 2553, 4863),
	FIRE_ALTAR(2553, 4799, 2624, 4863),
	EARTH_ALTAR(2624, 4799, 2688, 4863),
	WATER_ALTAR(2688, 4799, 2752, 4863),
	MIND_ALTAR(2752, 4799, 2816, 4863),
	AIR_ALTAR(2816, 4799, 2880, 4863),
	TRUE_BLOOD_ALTAR(3200, 4862, 3262, 4800),

	// Dragon Slayer II
	LITHKREN_DUNGEON(
		regions(6223),
		regionBox(14242, 14243)
	),
	LITHKREN(3519, 4032, 3602, 3967),
	DS2_SHIPS(regionBox(6486, 6745)),

	// The Gauntlet
	THE_GAUNTLET_NORMAL(new AABB(7512).onPlane(1)),
	THE_GAUNTLET_CORRUPTED(new AABB(7768).onPlane(1)),
	THE_GAUNTLET(THE_GAUNTLET_NORMAL, THE_GAUNTLET_CORRUPTED),
	THE_GAUNTLET_LOBBY(3025, 6131, 3040, 6116),

	// POHs
	PLAYER_OWNED_HOUSE(regionBox(7257, 8026)),
	PLAYER_OWNED_HOUSE_SNOWY(regionBox(8025, 8026).onPlane(1)),

	// Blackhole
	BLACKHOLE(1616, 4728, 1623, 4735),

	// Camdozaal (Below Ice Mountain)
	CAMDOZAAL_VAULT(
		new AABB(2970, 5816, 2969, 5824),
		new AABB(2986, 5824, 2952, 5857)
	),
	CAMDOZAAL(2897, 5848, 3036, 5760),

	// Tempoross
	TEMPOROSS_COVE(3005, 3011, 3066, 2941),

	// Guardians of the Rift
	TEMPLE_OF_THE_EYE_REGULAR(3680, 9535, 3548, 9441),
	TEMPLE_OF_THE_EYE_QUEST_1(2431, 5695, 2368, 5601),
	TEMPLE_OF_THE_EYE_QUEST_2(2432, 5665, 2495, 5759),
	TEMPLE_OF_THE_EYE(
		TEMPLE_OF_THE_EYE_REGULAR,
		TEMPLE_OF_THE_EYE_QUEST_1,
		TEMPLE_OF_THE_EYE_QUEST_2
	),
	TEMPLE_OF_THE_EYE_BLEND_FIX(
		// regular
		new AABB(3613, 9474, 3613, 9474),
		new AABB(3616, 9475, 3614, 9474),
		new AABB(3617, 9475, 3617, 9474),
		// quest 1
		new AABB(2397, 5634, 2397, 5634),
		new AABB(2398, 5634, 2400, 5635),
		new AABB(2401, 5635, 2401, 5634),
		// quest 2
		new AABB(2461, 5698, 2461, 5698),
		new AABB(2462, 5698, 2464, 5699),
		new AABB(2465, 5699, 2465, 5698)
	),
	TEMPLE_OF_THE_EYE_CENTER_PLATFORM(
		new AABB(3620, 9511, 3610, 9498), // regular
		new AABB(2394, 5658, 2404, 5671), // quest 1
		new AABB(2458, 5722, 2468, 5735)  // quest 2
	),
	TEMPLE_OF_THE_EYE_ENTRANCE_BRIGHTNESS_FIX(
		new AABB(3618, 9478, 3611, 9473), // regular
		new AABB(2395, 5633, 2402, 5638), // quest 1
		new AABB(2459, 5697, 2466, 5702)  // quest 2
	),
	TEMPLE_OF_THE_EYE_ENTRANCE_FIX(
		new AABB(3613, 9471, 3617, 9481), // regular
		new AABB(2461, 5695, 2465, 5705), // quest 1
		new AABB(2397, 5631, 2401, 5641)  // quest 2
	),

	// Death's office
	DEATHS_OFFICE(3164, 5734, 3185, 5719),

	// Theatre of Blood
	TOB_ROOM_MAIDEN(3231, 4468, 3152, 4416),
	TOB_ROOM_BLOAT(3260, 4474, 3327, 4427),
	TOB_ROOM_NYCOLAS(3274, 4226, 3318, 4290),
	TOB_ROOM_SOTETSEG(3295, 4288, 3264, 4336),
	TOB_ROOM_XARPUS(3191, 4406, 3151, 4368),
	TOB_ROOM_VERZIK(3152, 4332, 3186, 4296),
	TOB_ROOM_VAULT(3224, 4334, 3250, 4305),
	THEATRE_OF_BLOOD(3151, 4226, 3327, 4474),

	// Tombs of Amascut
	TOA_ENTRANCE_LOBBY(3375, 9135, 3344, 9102),
	TOA_PATH_HUB(3520, 5183, 3583, 5120),
	TOA_LOOT_ROOM(3648, 5183, 3711, 5120),
	TOA_FINAL_BOSS_PHASE_1(3776, 5183, 3839, 5120),
	TOA_FINAL_BOSS_PHASE_2(3904, 5183, 3967, 5120),
	TOA_FINAL_BOSS(TOA_FINAL_BOSS_PHASE_1, TOA_FINAL_BOSS_PHASE_2),
	TOA_PATH_OF_SCABARAS_PUZZLE(3520, 5311, 3583, 5248),
	TOA_PATH_OF_SCABARAS_BOSS(3520, 5439, 3583, 5376),
	TOA_PATH_OF_SCABARAS(TOA_PATH_OF_SCABARAS_PUZZLE, TOA_PATH_OF_SCABARAS_BOSS),
	TOA_PATH_OF_HET_PUZZLE(3648, 5311, 3711, 5248),
	TOA_PATH_OF_HET_BOSS(3648, 5439, 3711, 5376),
	TOA_PATH_OF_HET(TOA_PATH_OF_HET_PUZZLE, TOA_PATH_OF_HET_BOSS),
	TOA_PATH_OF_APMEKEN_PUZZLE(3776, 5311, 3839, 5248),
	TOA_PATH_OF_APMEKEN_BOSS(3776, 5439, 3839, 5376),
	TOA_PATH_OF_APMEKEN(TOA_PATH_OF_APMEKEN_PUZZLE, TOA_PATH_OF_APMEKEN_BOSS),
	TOA_PATH_OF_CRONDIS_PUZZLE(3904, 5311, 3967, 5248),
	TOA_PATH_OF_CRONDIS_BOSS(3904, 5439, 3967, 5376),
	TOA_PATH_OF_CRONDIS(TOA_PATH_OF_CRONDIS_PUZZLE, TOA_PATH_OF_CRONDIS_BOSS),

	TOA_CRONDIS_ISLAND(
		new AABB(3942, 5403, 3942, 5413),
		new AABB(3941, 5400, 3926, 5416),
		new AABB(3939, 5399, 3939, 5417),
		new AABB(3938, 5399, 3929, 5418),
		new AABB(3925, 5403, 3923, 5413)
	),
	TOA_CRONDIS_ISLAND_SUBMERGED(3944, 5402, 3943, 5415),
	TOA_CRONDIS_WATER(
		new AABB(3957, 5387, 3948, 5429),
		new AABB(3947, 5389, 3943, 5427),
		new AABB(3942, 5387, 3921, 5429),
		new AABB(3920, 5388, 3920, 5428),
		new AABB(3919, 5389, 3916, 5427),
		new AABB(3915, 5390, 3915, 5426),
		new AABB(3914, 5391, 3914, 5425),
		new AABB(3913, 5392, 3913, 5424),
		new AABB(3912, 5398, 3912, 5418),
		new AABB(3911, 5399, 3906, 5417)
	),

//	TOA_RED_REGION_LEFT(3456, 5311, 3519, 5248),
//	TOA_RED_REGION_UPPER_RIGHT(3840, 5439, 3903, 5376),
//	TOA_GREY_REGION_RIGHT_1(3968, 5375, 4031, 5312),
//  TOA_GREY_REGION_RIGHT_2(3968, 5311, 4031, 5248),
//  TOA_GREY_REGION_RIGHT_3(3968, 5247, 4031, 5184),

	TOMBS_OF_AMASCUT(
		TOA_ENTRANCE_LOBBY,
		TOA_PATH_HUB,
		TOA_LOOT_ROOM,
		TOA_FINAL_BOSS_PHASE_1,
		TOA_FINAL_BOSS_PHASE_2,
		TOA_PATH_OF_SCABARAS_PUZZLE,
		TOA_PATH_OF_SCABARAS_BOSS,
		TOA_PATH_OF_HET_PUZZLE,
		TOA_PATH_OF_HET_BOSS,
		TOA_PATH_OF_APMEKEN_PUZZLE,
		TOA_PATH_OF_APMEKEN_BOSS,
		TOA_PATH_OF_CRONDIS_PUZZLE,
		TOA_PATH_OF_CRONDIS_BOSS
	),

	// Chambers of Xeric
	CHAMBERS_OF_XERIC_ICE_DEMON(3264, 5344, 3359, 5375),
	CHAMBERS_OF_XERIC(
		regions(12889, 13136),
		regionBox(13137, 13401)
	),

	// Nightmare of Ashihama
	SISTERHOOD_SANCTUARY(regionBox(14999, 15513)),
	NIGHTMARE_OF_ASHIHAMA_ARENA(15515),

	// Pest Control
	PEST_CONTROL_LANDER_WATER_FIX(
		new AABB(2660, 2644, 2663, 2638),
		new AABB(2638, 2642, 2641, 2648),
		new AABB(2632, 2649, 2635, 2655),
		new AABB(2656, 2615, 2659, 2609)
	),

	// Barbarian Assault
	BARBARIAN_ASSAULT_WAITING_ROOMS(2571, 5252, 2616, 5305),

	TARNS_LAIR(regionBox(12615, 12616)),

	// Random events
	RANDOM_EVENT_CLASSROOM(1894, 5036, 1878, 5014),
	RANDOM_EVENT_FREAKY_FORESTER(2623, 4799, 2576, 4745),
	RANDOM_EVENT_GRAVEDIGGER(1920, 5007, 1935, 4992),
	RANDOM_EVENT_BEE_KEEPER(1920, 5055, 1940, 5033),
	RANDOM_EVENT_DRILL_DEMON(12619),
	RANDOM_EVENT_FROG_CAVE(2450, 4764, 2480, 4794),
	RANDOM_EVENT_PRISON_PETE(2059, 4479, 2111, 4447),
	RANDOM_EVENT_QUIZ_MASTER(7754),

	// Holiday events
	CHURCH_OF_AYASTER(15455),

	BLACK_ROOMS(
		RFD_QUIZ,
		RANDOM_EVENT_QUIZ_MASTER
	),

	// Clan halls
	CLAN_HALL(6997),

	// Standalone and miscellaneous areas
	LIGHTHOUSE(
		new AABB(2493, 3606, 2594, 3648),
		new AABB(2564, 3582, 2600, 3613)
	),
	LIGHTHOUSE_INSTANCE(2432, 4544, 2495, 4624),
	LIGHTHOUSE_DUNGEON(
		new AABB(2496, 4608, 2542, 4666),
		new AABB(2497, 9984, 2543, 10042)
	),
	SORCERESS_GARDEN(11605),
	PURO_PURO(10307),
	RATCATCHERS_HOUSE(2821, 5059, 2875, 5114),
	CANOE_CUTSCENE(7238),
	FISHER_KINGS_REALM(
		new AABB(2815, 4799, 2624, 4624),
		new AABB(2576, 4744, 2623, 4655)
	),
	ENCHANTED_VALLEY(12102),
	GIANTS_PLATEAU_CABBAGE_PATCH(3413, 3181, 3412, 3179),
	GIANTS_FOUNDRY(3331, 11456, 3393, 11520),
	ELID_CAVE(3325, 9520, 3395, 9605),
	ANCIENT_CAVERN(
		regionBox(6482, 6483),
		regionBox(6994, 6995)
	),
	LAND_OF_GOBLINS_CUTSCENE_WATER(3903, 4352, 3840, 4415),
	SHIP_SAILING(merge(
		regions(7242, 7243, 7499, 7500, 7755, 8011, 8012),
		DS2_SHIPS
	)),

	WEISS_SALT_MINE(11425),
	SECRETS_OF_THE_NORTH_DUNGEON(
		regions(11681),
		regionBox(11619, 12132)
	),
	GOBLIN_VILLAGE_ICE_CAVE(7777),
	GOBLIN_VILLAGE_COOKS_CHAMBER_BLEND_FIX(
		new AABB(2982, 9872, 2979, 9870)
	),
	GOBLIN_VILLAGE_COOKS_CHAMBER_POST_RFD(2991, 9879, 2968, 9864),
	GOBLIN_VILLAGE_COOKS_CHAMBER_PRE_RFD(2991, 9919, 2968, 9904),
	GOBLIN_VILLAGE_COOKS_CHAMBER(
		GOBLIN_VILLAGE_COOKS_CHAMBER_PRE_RFD,
		GOBLIN_VILLAGE_COOKS_CHAMBER_POST_RFD
	),
	GOBLIN_VILLAGE_INSTANCE(9812),
	TAVERLEY_DUNGEON_BLACK_KNIGHT_KITCHEN(
		new AABB(2918, 9706, 2925, 9713)
	),
	TAVERLEY_DUNGEON(
		new AABB(2813, 9855, 2949, 9783),
		new AABB(2950, 9800, 2970, 9770),
		new AABB(2844, 9782, 2949, 9775),
		new AABB(2848, 9774, 2949, 9768),
		new AABB(2853, 9767, 2938, 9759),
		new AABB(2884, 9758, 2939, 9668)
	),
	ICE_QUEENS_DUNGEON(
		new AABB(2816, 9983, 2879, 9897),
		new AABB(2880, 9977, 2896, 9920)
	),
	TROLLWEISS_CAVES(
		new AABB(2766, 10238, 2809, 10185)
	),
	PHANTOM_MUSPAH_BOSS_ROOM(11330),
	ICY_UNDERGROUND_DARK(
		WEISS_SALT_MINE,
		SECRETS_OF_THE_NORTH_DUNGEON
	),
	ICY_UNDERGROUND_BRIGHT(
		ASGARNIA_ICE_DUNGEON_SNOWY,
		ICE_QUEENS_DUNGEON,
		GOBLIN_VILLAGE_ICE_CAVE,
		TROLLWEISS_CAVES
	),
	SHADOW_DUNGEON(regions(10575, 10831)),

	// Desert Treasure 2 areas
	THE_SCAR_MAIN_AREA(
		regions(7779),
		new AABB(1984, 6304, 2143, 6463)
	),
	THE_SCAR_QUEST_AREAS(regions(7012, 7524, 8804)),
	THE_SCAR(THE_SCAR_MAIN_AREA, THE_SCAR_QUEST_AREAS),
	LASSAR_UNDERCITY_MAIN_NORMAL(
		regions(10083),
		regionBox(10338, 10852)
	),
	LASSAR_UNDERCITY_MAIN_SHADOW_REALM(
		regions(9059),
		regionBox(9314, 9828)
	),
	LASSAR_UNDERCITY_DRAIN_NORMAL(11106),
	LASSAR_UNDERCITY_DRAIN_SHADOW_REALM(10082),
	LASSAR_UNDERCITY_SUNKEN_CATHEDRAL(
		new AABB(2372, 6397, 2428, 6333),
		new AABB(2628, 6397, 2684, 6333)
	),
	LASSAR_UNDERCITY_WATER_CUTSCENE(12898),
	LASSAR_UNDERCITY_WATER(LASSAR_UNDERCITY_MAIN_NORMAL, LASSAR_UNDERCITY_MAIN_SHADOW_REALM, LASSAR_UNDERCITY_WATER_CUTSCENE),
	LASSAR_UNDERCITY_NORMAL(
		LASSAR_UNDERCITY_MAIN_NORMAL,
		LASSAR_UNDERCITY_DRAIN_NORMAL,
		LASSAR_UNDERCITY_WATER_CUTSCENE
	),
	LASSAR_UNDERCITY_SHADOW_REALM(
		LASSAR_UNDERCITY_MAIN_SHADOW_REALM,
		LASSAR_UNDERCITY_DRAIN_SHADOW_REALM
	),
	LASSAR_UNDERCITY(
		LASSAR_UNDERCITY_NORMAL,
		LASSAR_UNDERCITY_SHADOW_REALM
	),
	ANCIENT_VAULT(13156),
	GLOD_INSTANCE(8534),
	PROBABLY_CUTSCENE_GRASS(3392, 4807, 3399, 4800),
	YU_BIUSK(15428),
	GIANT_MOLE_LAIR(regions(6992, 6993)),

	WATERBIRTH_DUNGEON_LEVEL_1(regionBox(9886, 10142).onPlane(0)),
	WATERBIRTH_DUNGEON_LEVEL_2(regionBox(7236, 7748).onPlane(1)),
	WATERBIRTH_DUNGEON_LEVEL_3(regionBox(7236, 7748).onPlane(2)),
	WATERBIRTH_DUNGEON_LEVEL_4(regionBox(7236, 7748).onPlane(3)),
	WATERBIRTH_DUNGEON_LEVEL_5(regionBox(7492, 7748).onPlane(0)),
	DAGANNOTH_KINGS_REGULAR_CAVE(new AABB(11589).onPlane(0)),
	DAGANNOTH_KINGS_SLAYER_CAVE(new AABB(11588).onPlane(0)),
	WATERBIRTH_DUNGEON(merge(
		WATERBIRTH_DUNGEON_LEVEL_1,
		WATERBIRTH_DUNGEON_LEVEL_2,
		WATERBIRTH_DUNGEON_LEVEL_3,
		WATERBIRTH_DUNGEON_LEVEL_4,
		WATERBIRTH_DUNGEON_LEVEL_5,
		DAGANNOTH_KINGS_REGULAR_CAVE,
		DAGANNOTH_KINGS_SLAYER_CAVE
	)),

	ESSENCE_MINE(11595),
	KINGDOM_OF_MISTHALIN_REGION(
		new AABB(3067, 3521, 3399, 3330),
		new AABB(3070, 3329, 3263, 3201),
		new AABB(3257, 3200, 3090, 3186),
		new AABB(3252, 3185, 3094, 3136),
		new AABB(3266, 3329, 3264, 3204),
		new AABB(3267, 3231, 3267, 3224),
		new AABB(3267, 3329, 3270, 3326),
		new AABB(3269, 3325, 3267, 3325),
		new AABB(3267, 3324, 3267, 3323),
		new AABB(3268, 3324, 3268, 3324),
		new AABB(3334, 3329, 3339, 3328),
		new AABB(3346, 3329, 3360, 3328),
		new AABB(3370, 3329, 3375, 3329),
		new AABB(3069, 3267, 3068, 3244),
		new AABB(3067, 3256, 3067, 3255),
		new AABB(3066, 3255, 3066, 3255),
		new AABB(3065, 3254, 3067, 3245),
		new AABB(3069, 3268, 3069, 3272),
		new AABB(3069, 3285, 3069, 3310),
		new AABB(3068, 3309, 3068, 3296),
		new AABB(3069, 3314, 3069, 3323),
		new AABB(3400, 3508, 3411, 3452),
		new AABB(3412, 3503, 3419, 3462),
		new AABB(3420, 3493, 3425, 3468),
		new AABB(3426, 3485, 3431, 3472),
		new AABB(3420, 3467, 3421, 3466)
	),
	KINGDOM_OF_ASGARNIA_REGION(
		new AABB(3064, 3521, 2892, 3198),
		new AABB(2934, 3197, 3063, 3169),
		new AABB(2973, 3168, 3039, 3097),
		new AABB(3067, 3257, 3065, 3453),
		new AABB(3069, 3327, 3068, 3323),
		new AABB(3068, 3322, 3068, 3309),
		new AABB(3069, 3310, 3069, 3314),
		new AABB(3068, 3296, 3068, 3267),
		new AABB(3069, 3272, 3069, 3285),
		new AABB(3066, 3256, 3065, 3256),
		new AABB(3065, 3255, 3065, 3255),
		new AABB(2891, 3344, 2881, 3521),
		new AABB(2880, 3390, 2868, 3521),
		new AABB(2937, 3522, 2882, 3578),
		new AABB(2837, 3556, 2881, 3522),
		new AABB(2854, 3578, 2881, 3557),
		new AABB(2853, 3560, 2848, 3557),
		new AABB(2836, 3551, 2784, 3526),
		new AABB(2790, 3525, 2836, 3500),
		new AABB(2790, 3499, 2836, 3495),
		new AABB(2796, 3494, 2809, 3493),
		new AABB(2826, 3494, 2836, 3491),
		new AABB(2830, 3490, 2836, 3482),
		new AABB(2832, 3481, 2836, 3475),
		new AABB(2834, 3474, 2836, 3464),
		new AABB(2837, 3521, 2867, 3464),
		new AABB(2838, 3463, 2867, 3461),
		new AABB(2842, 3460, 2867, 3448),
		new AABB(2841, 3451, 2840, 3449),
		new AABB(2845, 3447, 2867, 3446),
		new AABB(2851, 3445, 2867, 3443),
		new AABB(2854, 3442, 2867, 3441),
		new AABB(2858, 3440, 2867, 3438),
		new AABB(2867, 3430, 2866, 3437),
		new AABB(2865, 3437, 2864, 3434)
	),
	KINGDOM_OF_KANDARIN_REGION(
		new AABB(2827, 3491, 2304, 3392),
		new AABB(2303, 3458, 2286, 3491),
		new AABB(2761, 3585, 2258, 3492),
		new AABB(2258, 3586, 2414, 3708),
		new AABB(2512, 3596, 2548, 3586),
		new AABB(2758, 3586, 2747, 3588),
		new AABB(2741, 3586, 2638, 3590),
		new AABB(2646, 3591, 2652, 3592),
		new AABB(2652, 3593, 2650, 3594),
		new AABB(2653, 3596, 2716, 3591),
		new AABB(2717, 3593, 2729, 3591),
		new AABB(2697, 3597, 2672, 3598),
		new AABB(2678, 3602, 2684, 3599),
		new AABB(2658, 3597, 2666, 3598),
		new AABB(2353, 3391, 2766, 3335),
		new AABB(2431, 3334, 2801, 3255),
		new AABB(2431, 3254, 2688, 3066),
		new AABB(2689, 3254, 2705, 3237),
		new AABB(2365, 3140, 2430, 3066),
		new AABB(2400, 3202, 2430, 3141),
		new AABB(2441, 3065, 2320, 3028),
		new AABB(2324, 3078, 2364, 3066),
		new AABB(2558, 3065, 2619, 3044),
		new AABB(2555, 3065, 2557, 3063),
		new AABB(2557, 3062, 2557, 3062),
		new AABB(2554, 3065, 2554, 3065),
		new AABB(2576, 3043, 2590, 3041),
		new AABB(2579, 3040, 2586, 3037),
		new AABB(2762, 3521, 2789, 3492),
		new AABB(2834, 3449, 2828, 3474),
		new AABB(2830, 3475, 2828, 3487),
		new AABB(2835, 3461, 2841, 3452),
		new AABB(2835, 3451, 2839, 3449),
		new AABB(2842, 3448, 2828, 3411),
		new AABB(2843, 3411, 2866, 3430),
		new AABB(2865, 3431, 2843, 3433),
		new AABB(2862, 3434, 2843, 3437),
		new AABB(2843, 3446, 2847, 3438),
		new AABB(2848, 3444, 2851, 3438),
		new AABB(2852, 3440, 2853, 3438)
	),
	FREMENNIK_REGION(
		FREMENNIK_PROVINCE,
		FREMENNIK_ISLES,
		MISCELLANIA,
		PIRATES_COVE,
		LUNAR_ISLE
	),
	FELDIP_HILLS_SOUTHERN_REGION(
		new AABB(2453, 2947, 2629, 2875),
		new AABB(2472, 2874, 2613, 2847),
		new AABB(2483, 2846, 2580, 2830),
		new AABB(2482, 2960, 2502, 2948),
		new AABB(2503, 2957, 2507, 2948),
		new AABB(2570, 2948, 2591, 2954),
		new AABB(2569, 2948, 2541, 2950),
		new AABB(2508, 2952, 2513, 2948),
		new AABB(2592, 2949, 2593, 2948),
		new AABB(2605, 2948, 2617, 2950)
	),
	FELDIP_HILLS(
		new AABB(2579, 3040, 2586, 3037),
		new AABB(2762, 3521, 2789, 3492),
		new AABB(2834, 3449, 2828, 3474),
		new AABB(2830, 3475, 2828, 3487),
		new AABB(2835, 3461, 2841, 3452),
		new AABB(2835, 3451, 2839, 3449),
		new AABB(2842, 3448, 2828, 3411),
		new AABB(2843, 3411, 2866, 3430),
		new AABB(2865, 3431, 2843, 3433),
		new AABB(2862, 3434, 2843, 3437),
		new AABB(2843, 3446, 2847, 3438),
		new AABB(2848, 3444, 2851, 3438),
		new AABB(2852, 3440, 2853, 3438),
		new AABB(2442, 3065, 2554, 2997),
		new AABB(2555, 3062, 2557, 2997),
		new AABB(2558, 3043, 2575, 2997),
		new AABB(2576, 3040, 2578, 3013),
		new AABB(2579, 3036, 2652, 3013),
		new AABB(2576, 3012, 2652, 2997),
		new AABB(2438, 2996, 2657, 2816)
	),
	RED_CHINCHOMPA_HUNTING_GROUND(2510, 9308, 2533, 9286),
	CERBERUS(1216, 1216, 1406, 1343),
	// Abyss
	ABYSS(regions(12106, 12107, 12108, 11850, 11851, 12362, 12363)),

	// Varlamore
	VARLAMORE(regionBox(4908, 7476)),
	VARLAMORE_TEMPLE_CRYPT(
		new AABB(1608, 9536, 1663, 9586),
		new AABB(1664, 9433, 1727, 9548),
		new AABB(1685, 9549, 1714, 9579)
	),
	VARLAMORE_TEMPLE_CRYPT_CENTER(
		new AABB(1683, 9513, 1686, 9516, 0)
	),
	VARLAMORE_TEMPLE_CRYPT_FAKE_BRICK_TILES(
		new AABB(1678, 9523, 1679, 9526, 0),
		new AABB(1673, 9520, 1676, 9521, 0),
		new AABB(1679, 9512, 1680, 9517, 0),
		new AABB(1673, 9508, 1676, 9509, 0),
		new AABB(1678, 9503, 1679, 9506, 0),
		new AABB(1682, 9509, 1687, 9510, 0),
		new AABB(1690, 9503, 1691, 9506, 0),
		new AABB(1693, 9508, 1696, 9509, 0),
		new AABB(1689, 9512, 1690, 9517, 0),
		new AABB(1693, 9520, 1694, 9521, 0),
		new AABB(1695, 9520, 1696, 9520, 0),
		new AABB(1696, 9521),
		new AABB(1690, 9523, 1691, 9526, 0),
		new AABB(1682, 9519, 1687, 9520, 0)
	),
	VARLAMORE_TEMPLE_CRYPT_FAKE_SQUARE_TILES(
		new AABB(1677, 9507, 1681, 9511, 0),
		new AABB(1677, 9518, 1681, 9522, 0),
		new AABB(1688, 9518, 1692, 9522, 0),
		new AABB(1688, 9507, 1692, 9511, 0)
	),
	HUNTER_GUILD(6291),
	HUNTER_GUILD_SURFACE(1535, 3024, 1575, 3070),
	VARLAMORE_SNOWY_MOUNTAINS(merge(
		regionBox(5680, 5682),
		regionBox(5938, 6706)
	)),
	RALOS_RISE_LOWER(
		new AABB(1407, 3197, 1424, 3116),
		new AABB(1425, 3132, 1451, 3101),
		new AABB(1411, 3115, 1424, 3102)
	),
	RALOS_RISE_UPPER(
		new AABB(1425, 3231, 1465, 3133),
		new AABB(1419, 3171, 1424, 3122),
		new AABB(1416, 3149, 1418, 3144),
		new AABB(1447, 3132, 1462, 3124)
	),
	VARLAMORE_SAVANNA_HUNTER_PIT_TRAPS(new AABB(1731, 2992, 1764, 3024, 0)),
	VARLAMORE_CAM_TORUM_ENTRANCE_PATH_BLENDING_FIX(1443, 3104, 1444, 3105),
	CAM_TORUM(
		new AABB(1384, 9535, 1385, 9539),
		new AABB(1386, 9535, 1405, 9577),
		new AABB(1406, 9504, 1494, 9605),
		new AABB(1495, 9504, 1534, 9561),
		new AABB(1495, 9562, 1497, 9576),
		new AABB(1498, 9562, 1498, 9575),
		new AABB(1499, 9562, 1500, 9572),
		new AABB(1501, 9562, 1501, 9571),
		new AABB(1502, 9562, 1502, 9568),
		new AABB(1503, 9562, 1505, 9566),
		new AABB(1506, 9562, 1508, 9565)
	),
	EARTHBOUND_CAVERN(1344, 9664, 1407, 9747),
	STREAMBOUND_CAVERN(6039),
	ANCIENT_PRISON(1344, 9536, 1391, 9599),
	ANCIENT_SHRINE(
		new AABB(1501, 9568, 1525, 9592, 0),
		new AABB(1493, 9571, 1500, 9588, 0),
		new AABB(1506, 9593, 1520, 9598, 0),
		new AABB(1526, 9573, 1532, 9588, 0),
		new AABB(1506, 9561, 1520, 9567, 0)
	),
	THE_BLUE_MOON(
		new AABB(1434, 9649, 1446, 9663, 0),
		new AABB(1420, 9664, 1460, 9700, 0)
	),
	THE_BLOOD_MOON_ENTRANCE(new AABB(1408, 9626, 1422, 9638, 0)),
	THE_BLOOD_MOON(merge(
		THE_BLOOD_MOON_ENTRANCE,
		new AABB(1370, 9610, 1407, 9654, 0)
	)),
	THE_ECLIPSE_MOON_ENTRANCE(new AABB(1457, 9626, 1471, 9638, 0)),
	THE_ECLIPSE_MOON(merge(
		THE_ECLIPSE_MOON_ENTRANCE,
		new AABB(1472, 9610, 1510, 9654, 0)
	)),
	COLOSSEUM(7316),

	SNOWY_REGIONS(
		ASGARNIA_ICE_DUNGEON_SNOWY,
		ESSENCE_MINE,
		FREMENNIK_ISLES_NORTH,
		FROZEN_WASTE_PLATEAU,
		GIELINOR_SNOWY_NORTHERN_REGION,
		RELLEKKA_SNOWY_REGION,
		GOBLIN_VILLAGE_ICE_CAVE,
		ICEBERG,
		ICE_MOUNTAIN,
		ICE_QUEENS_DUNGEON,
		LUNAR_ISLE,
		MISCELLANIA,
		WHITE_WOLF_MOUNTAIN,
		ZEAH_SNOWY_NORTHERN_REGION,
		PLAYER_OWNED_HOUSE_SNOWY,
		TROLLHEIM,
		VARLAMORE_SNOWY_MOUNTAINS
	),

	MAINLAND(1024, 4159, 3967, 2496),
	MAINLAND_EXTENSIONS(merge(
		BRAINDEATH_ISLAND,
		CLAN_HALL,
		CLAN_WARS_ARENAS_OVERWORLD,
		EVIL_BOB_ISLAND,
		FISHER_KINGS_REALM,
		LMS_ARENA_DESERTED_ISLAND,
		LMS_ARENA_WILD_VARROCK,
		PLAYER_OWNED_HOUSE,
		PURO_PURO,
		RANDOM_EVENT_BEE_KEEPER,
		RANDOM_EVENT_CLASSROOM,
		RANDOM_EVENT_DRILL_DEMON,
		RANDOM_EVENT_FREAKY_FORESTER,
		RANDOM_EVENT_GRAVEDIGGER,
		SORCERESS_GARDEN,
		TIRANNWN_MAINLAND,
		YU_BIUSK,
		AIR_ALTAR,
		NATURE_ALTAR,
		WATER_ALTAR,
		CANOE_CUTSCENE,
		EYES_OF_GLOUPHRIE_GNOME_AND_GOBLIN_BATTLE_CUTSCENE,
		PROBABLY_CUTSCENE_GRASS,
		SOTE_CUTSCENE_ARDOUGNE_SQUARE,
		FALADOR_INSTANCE,
		GLOD_INSTANCE,
		GOBLIN_VILLAGE_INSTANCE,
		ISLE_OF_SOULS_INSTANCE,
		KARAMJA_INSTANCES,
		KEEP_LE_FAYE_INSTANCE,
		LIGHTHOUSE_INSTANCE,
		LUMBRIDGE_CASTLE_INSTANCE,
		MOS_LE_HARMLESS_INSTANCE,
		TREE_GNOME_STRONGHOLD_INSTANCE,
		TUTORIAL_ISLAND_INSTANCE,
		TYRAS_CAMP_INSTANCE,
		SHIP_SAILING,
		VER_SINHAZA_CUTSCENE,
		DEFENDER_OF_VARROCK_CASTLE_UNDER_ATTACK,
		CHURCH_OF_AYASTER,
		regions(8288, 8801, 11593)
	)),
	OVERWORLD(
		MAINLAND,
		MAINLAND_EXTENSIONS
	),
	ALL(Integer.MIN_VALUE, Integer.MIN_VALUE, Integer.MAX_VALUE, Integer.MAX_VALUE),
	NONE(0, 0, 0, 0);

	public final AABB[] aabbs;

	Area(AABB... aabbs) {
		this.aabbs = aabbs;
	}

	Area(AABB[] aabbs1, AABB... aabbs2) {
		this.aabbs = new AABB[aabbs1.length + aabbs2.length];
		System.arraycopy(aabbs1, 0, this.aabbs, 0, aabbs1.length);
		System.arraycopy(aabbs2, 0, this.aabbs, aabbs1.length, aabbs2.length);
	}

	Area(Area... areas)	{
		this.aabbs = areas(areas);
	}

	Area(int pointAX, int pointAY, int pointBX, int pointBY) {
		aabbs = new AABB[] { new AABB(pointAX, pointAY, pointBX, pointBY) };
	}

	Area(int pointAX, int pointAY, int pointBX, int pointBY, int plane) {
		aabbs = new AABB[] { new AABB(pointAX, pointAY, pointBX, pointBY, plane) };
	}

	Area(int regionId) {
		this(regions(regionId));
	}

	private static AABB[] merge(Object... objects) {
		int count = 0;
		for (var obj : objects) {
			if (obj instanceof Area) {
				count += ((Area) obj).aabbs.length;
			} else if (obj instanceof AABB[]) {
				count += ((AABB[]) obj).length;
			} else if (obj instanceof AABB) {
				count++;
			} else {
				throw new IllegalArgumentException("Not sure what to do with provided object: " + obj);
			}
		}

		AABB[] aabbs = new AABB[count];
		int i = 0;
		for (var obj : objects) {
			if (obj instanceof Area) {
				for (var aabb : ((Area) obj).aabbs)
					aabbs[i++] = aabb;
			} else if (obj instanceof AABB[]) {
				for (var aabb : ((AABB[]) obj))
					aabbs[i++] = aabb;
			} else if (obj instanceof AABB) {
				aabbs[i++] = (AABB) obj;
			}
		}

		return aabbs;
	}

	private static AABB[] areas(Area... areas) {
		return Arrays.stream(areas)
			.flatMap(a -> Arrays.stream(a.aabbs))
			.toArray(AABB[]::new);
	}

	public boolean containsPoint(int worldX, int worldY, int plane) {
		for (AABB aabb : this.getAabbs()) {
			if (aabb.contains(worldX, worldY, plane)) {
				return true;
			}
		}
		return false;
	}

	public boolean containsPoint(int[] worldPoint) {
		return containsPoint(worldPoint[0], worldPoint[1], worldPoint[2]);
	}

	public boolean containsPoint(WorldPoint worldPoint)
	{
		return containsPoint(worldPoint.getX(), worldPoint.getY(), worldPoint.getPlane());
	}

	public boolean intersects(Area otherArea) {
		if (otherArea == null)
			return false;
		for (AABB other : otherArea.aabbs)
			for (AABB self : aabbs)
				if (self.intersects(other))
					return true;
		return false;
	}

	@Slf4j
	public static class JsonAdapter extends TypeAdapter<Area> {
		@Override
		public Area read(JsonReader in) throws IOException {
			var token = in.peek();
			if (token == JsonToken.NULL)
				return null;

			if (token != JsonToken.STRING) {
				log.warn("Invalid type for area enum: '{}' at {}", token, GsonUtils.location(in), new Throwable());
				return NONE;
			}

			var str = in.nextString();
			try {
				return Area.valueOf(str);
			} catch (IllegalArgumentException ex) {
				log.warn("Area enum '{}' does not exist at {}", str, GsonUtils.location(in), new Throwable());
				return NONE;
			}
		}

		@Override
		public void write(JsonWriter out, Area area) throws IOException {
			if (area == null) {
				out.nullValue();
			} else {
				out.value(area.name());
			}
		}
	}
}

/*
 * Copyright (c) 2021, 117 <https://twitter.com/117scape>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package rs117.hd.data.materials;

import java.util.Random;
import lombok.Getter;

@Getter
public enum GroundMaterial {
	NONE(Material.NONE),
	SKULL_OBELISK(Material.SKULLS),
	TRANSPARENT(Material.TRANSPARENT),
	GRASS_1(Material.GRASS_1, Material.GRASS_2, Material.GRASS_3),
	OVERWORLD_GRASS_1(Material.GRASS_1, Material.GRASS_2, Material.GRASS_3),
	GRASS_SCROLLING(Material.GRASS_SCROLLING),
	STONE_SCROLLING(Material.STONE_SCROLLING),
	DIRT(Material.DIRT_1, Material.DIRT_2),
	VERTICAL_DIRT(Material.DIRT_1_VERT, Material.DIRT_2_VERT),
	SNOW_1(Material.SNOW_1, Material.SNOW_1, Material.SNOW_2, Material.SNOW_3, Material.SNOW_3, Material.SNOW_4),
	SNOW_2(Material.SNOW_2, Material.SNOW_4),
	GRAVEL(Material.GRAVEL),
	FALADOR_PATHS(Material.FALADOR_PATH_BRICK),
	VARROCK_PATHS(Material.JAGGED_STONE_TILE),
	VARIED_DIRT(Material.GRAVEL, Material.DIRT_1, Material.DIRT_2),
	VARIED_DIRT_SHINY(Material.GRAVEL_SHINY, Material.DIRT_1_SHINY, Material.DIRT_2_SHINY),
	TILE_SMALL(Material.TILE_SMALL_1),
	CARPET(Material.CARPET),
	BRICK(Material.BRICK),
	BRICK_BROWN(Material.BRICK_BROWN),
	GRUNGE(Material.GRUNGE_1, Material.GRUNGE_2, Material.GRUNGE_1),
	GRUNGE_2(Material.GRUNGE_2),
	SUBMERGED_GRUNGE_2(Material.SUBMERGED_GRUNGE_2),

	TILES_2x2_1(Material.TILES_2X2_1),
	TILES_2x2_2(Material.TILES_2X2_2),
	TILES_2X2_1_GLOSS(Material.TILES_2X2_1_GLOSS),
	TILES_2X2_2_GLOSS(Material.TILES_2X2_2_GLOSS),
	TILES_2X2_1_SEMIGLOSS(Material.TILES_2X2_1_SEMIGLOSS),
	TILES_2X2_2_SEMIGLOSS(Material.TILES_2X2_2_SEMIGLOSS),

	MARBLE_1(Material.MARBLE_1, Material.MARBLE_2, Material.MARBLE_3),
	MARBLE_2(Material.MARBLE_3, Material.MARBLE_1, Material.MARBLE_2),
	MARBLE_1_GLOSS(Material.MARBLE_1_GLOSS, Material.MARBLE_2_GLOSS, Material.MARBLE_3_GLOSS),
	MARBLE_2_GLOSS(Material.MARBLE_3_GLOSS, Material.MARBLE_1_GLOSS, Material.MARBLE_2_GLOSS),
	MARBLE_1_SEMIGLOSS(Material.MARBLE_1_SEMIGLOSS, Material.MARBLE_2_SEMIGLOSS, Material.MARBLE_3_SEMIGLOSS),
	MARBLE_2_SEMIGLOSS(Material.MARBLE_3_SEMIGLOSS, Material.MARBLE_1_SEMIGLOSS, Material.MARBLE_2_SEMIGLOSS),
	MARBLE_DARK(Material.MARBLE_DARK),

	LASSAR_UNDERCITY_TILES(Material.LASSAR_UNDERCITY_TILES),
	LASSAR_UNDERCITY_TILES_SUBMERGED(Material.LASSAR_UNDERCITY_TILES_SUBMERGED),

	BLANK_SEMIGLOSS(Material.BLANK_SEMIGLOSS),

	SAND(Material.SAND_1, Material.SAND_2, Material.SAND_3),

	UNDERWATER_GENERIC(Material.DIRT_1, Material.DIRT_2),

	WOOD_PLANKS_1(Material.WOOD_PLANKS_1),
	CLEAN_WOOD_FLOOR(Material.CLEAN_WOOD_FLOOR),

	HD_LAVA(
		Material.HD_LAVA_1,
		Material.HD_LAVA_2,
		Material.HD_LAVA_1,
		Material.HD_LAVA_1,
		Material.HD_LAVA_2,
		Material.HD_MAGMA_1,
		Material.HD_MAGMA_2
	),

	STONE_PATTERN(Material.STONE_PATTERN),
	CONCRETE(Material.CONCRETE),
	SAND_BRICK(Material.SAND_BRICK),
	CLEAN_TILE(Material.CLEAN_TILE),
	WORN_TILES(Material.WORN_TILES),
	WATER_FLAT(Material.WATER_FLAT),
	HD_WOOD_PLANKS_2(Material.HD_WOOD_PLANKS_2),
	ICE_1(Material.ICE_1),
	ICE_1_HIGHGLOSS(Material.ICE_1_HIGHGLOSS),
	ICE_4(Material.ICE_4),
	WINTER_JAGGED_STONE_TILE(Material.WINTER_JAGGED_STONE_TILE),
	WINTER_JAGGED_STONE_TILE_LIGHT(Material.WINTER_JAGGED_STONE_TILE_LIGHT),
	WINTER_JAGGED_STONE_TILE_LIGHT_2(Material.WINTER_JAGGED_STONE_TILE_LIGHTER),
	ROCKY_CAVE_FLOOR(Material.GRUNGE_2, Material.ROCK_2, Material.ROCK_2, Material.ROCK_1, Material.GRAVEL),
	EARTHEN_CAVE_FLOOR(Material.GRUNGE_1, Material.DIRT_2, Material.DIRT_2, Material.ROCK_1, Material.DIRT_2),
	STONE_CAVE_FLOOR(Material.STONE, Material.ROCK_1, Material.ROCK_2),
	SANDY_STONE_FLOOR(Material.SAND_2, Material.STONE_NORMALED, Material.ROCK_2, Material.STONE_NORMALED),
	PACKED_EARTH(Material.DIRT_1, Material.GRAVEL, Material.DIRT_1, Material.DIRT_1, Material.DIRT_2),
	GRASSY_DIRT(Material.GRASS_1, Material.DIRT_1, Material.GRASS_2, Material.DIRT_2, Material.GRASS_3),
	OOZE_FLOOR(Material.GRUNGE_1_SHINY, Material.GRAVEL_SHINY_LIGHT, Material.GRUNGE_2_SHINY),
	TEMPLE_OF_THE_EYE_FLOOR(
		Material.GRUNGE_1,
		Material.GRAVEL_LIGHT,
		Material.GRUNGE_2,
		Material.GRAVEL_LIGHT
	),
	OVERWORLD_ROCKY(Material.ROCK_2, Material.STONE_NORMALED_DARK, Material.ROCK_1, Material.GRAVEL),
	HD_BRICK_BROWN(Material.HD_BRICK_BROWN),
	ABYSSAL_FLOOR(Material.ABYSSAL_2, Material.ABYSSAL, Material.ABYSSAL),
	;

	private final Material[] materials;

	GroundMaterial(Material... materials) {
		this.materials = materials;
	}

	public Material getRandomMaterial(int plane, int worldX, int worldY) {
		// Generate a seed from the tile coordinates for
		// consistent 'random' results between scene loads.
		// This seed creates a patchy, varied terrain
		long seed = (long) (plane + 1) * 10 * (worldX % 100) * 20 * (worldY % 100) * 30;
		Random randomTex = new Random(seed);
		int randomInt = randomTex.nextInt(this.materials.length);
		return this.materials[randomInt];
	}
}

/*
 * Copyright (c) 2021, 117 <https://twitter.com/117scape>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package rs117.hd.data.materials;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.List;
import java.util.function.Consumer;
import java.util.function.Function;
import lombok.NonNull;
import lombok.Setter;
import net.runelite.api.*;
import rs117.hd.HdPlugin;
import rs117.hd.config.SeasonalTheme;
import rs117.hd.utils.ColorUtils;

public enum Material {
	// - Each enum entry refers to a texture file by name, in lowercase. If a texture with the specified name is found,
	//   it will be loaded and resized to fit the dimensions of the texture array.
	// - Entries that specify a vanillaTextureIndex give names to vanilla textures, and will override the vanilla
	//   texture if a corresponding texture file exists.
	// - Materials can reuse textures by inheriting from a different material.
	// - Materials can be composed of multiple textures by setting texture map fields to materials loaded before it.

	NONE, // Must be the first material
	// Special material used for vanilla textures lacking a material
	VANILLA(NONE, p -> p.setHasTransparency(true)),

	// Special materials
	UNLIT(NONE, p -> p.setUnlit(true)),
	TRANSPARENT,
	LAVA_FLOW_MAP,
	WATER_FLOW_MAP,
	UNDERWATER_FLOW_MAP,
	CAUSTICS_MAP,
	WATER_NORMAL_MAP_1,
	WATER_NORMAL_MAP_2,
	WATER_FOAM,

	// Reserve materials for known vanilla texture IDs
	WOODEN_DOOR_HANDLE(0),
	WATER_FLAT(1),
	BRICK(2),
	WOOD_PLANKS_1(3, p -> p
		.setSpecular(0.35f, 30)),
	LARGE_DOOR(4),
	DARK_WOOD(5),
	ROOF_SHINGLES_1(6, p -> p
		.setSpecular(0.5f, 30)),
	WOODEN_SCREEN(7, p -> p
		.setHasTransparency(true)),
	LEAVES_SIDE(8, p -> p
		.setHasTransparency(true)
		.setTextureScale(1.025f, 1.025f)
	),
	TREE_RINGS(9, p -> p
		.setHasTransparency(true)),
	MOSS_BRANCH(10),
	CONCRETE(11),
	IRON_BARS(12, p -> p
		.setHasTransparency(true)),
	PAINTING_LANDSCAPE(13),
	PAINTING_KING(14),
	MARBLE_DARK(15, p -> p
		.setSpecular(1.1f, 380)),
	SIMPLE_GRAIN_WOOD(16),
	WATER_DROPLETS(17, p -> p
		.setHasTransparency(true)),
	HAY(18),
	NET(19, p -> p
		.setHasTransparency(true)),
	BOOKCASE(20),
	ROOF_WOODEN_SLATE(21, p -> p
		.setHasTransparency(true)),
	CRATE(22, p -> p
		.setSpecular(0.35f, 30)),
	BRICK_BROWN(23),
	WATER_FLAT_2(24),
	SWAMP_WATER_FLAT(25),
	WEB(26, p -> p
		.setHasTransparency(true)),
	ROOF_SLATE(27),
	MOSS(28, p -> p
		.setHasTransparency(true)),
	TROPICAL_LEAF(29, p -> p
		.setBrightness(.5f)
		.setHasTransparency(true)),
	WILLOW_LEAVES(30, p -> p
		.setHasTransparency(true)
		.setTextureScale(1.025f, 1.0f)
	),
	LAVA(31, p -> p
		.setUnlit(true)
		.setOverrideBaseColor(true)
		.setFlowMap(LAVA_FLOW_MAP, 0.05f, 36, 22)
		.setScroll(0, 1 / 3f)),
	TREE_DOOR_BROWN(32),
	MAPLE_LEAVES(33, p -> p
		.setHasTransparency(true)
		.setTextureScale(1.3f, 1.025f)
	),
	MAGIC_STARS(34, p -> p
		.setHasTransparency(true)
		.setUnlit(true)
		.setOverrideBaseColor(true)),
	SAND_BRICK(35),
	DOOR_TEXTURE(36),
	BLADE(37),
	SANDSTONE(38),
	PAINTING_ELF(39),
	FIRE_CAPE(40, p -> p
		.setUnlit(true)
		.setOverrideBaseColor(true)
		.setFlowMap(LAVA_FLOW_MAP, 0.05f, 12, 4)
		.setScroll(0, 1 / -3f)),
	LEAVES_DISEASED(41, p -> p
		.setHasTransparency(true)
		.setTextureScale(1.025f, 1.025f)
	),
	MARBLE(42, p -> p
		.setSpecular(1.0f, 400)),
	CLEAN_TILE(43),
	ROOF_SHINGLES_2(44),
	ROOF_BRICK_TILE(45),
	STONE_PATTERN(46),
	TEXTURE_47(47),
	HIEROGLYPHICS(48),
	TEXTURE_49(49),
	ROOF_BRICK_TILE_GREEN(50),
	CLEAN_WOOD_FLOOR(51),
	SNOW_FLAKES(52, p -> p
		.setHasTransparency(true)),
	FROZEN_ABYSSAL_WHIP(53),
	UNUSED_UI_TEXTURE(54),
	ROOF_BRICK_TILE_DARK(55),
	RED_LAVA(56),
	SMOKE_BATTLESTAFF(57),
	UNUSED_LEAVES(58, p -> p
		.setHasTransparency(true)),
	INFERNAL_CAPE(59, p -> p
		.setUnlit(true)
		.setOverrideBaseColor(true)
		.setFlowMap(LAVA_FLOW_MAP, 0.02f, 12, 4)
		.setScroll(0, 0)),
	LEAVES_TOP(60, p -> p
		.setHasTransparency(true)),
	CLAN_SKULL(61, p -> p
		.setHasTransparency(true)),
	CLAN_PARTYHAT(62, p -> p
		.setHasTransparency(true)),
	CLAN_MAGIC_ICON(63, p -> p
		.setHasTransparency(true)),
	CLAN_MIME_HAPPY(64, p -> p
		.setHasTransparency(true)),
	CLAN_HELMET(65, p -> p
		.setHasTransparency(true)),
	CLAN_SWORDS(66, p -> p
		.setHasTransparency(true)),
	CLAN_MIME_SAD(67, p -> p
		.setHasTransparency(true)),
	CLAN_SKILLING(68, p -> p
		.setHasTransparency(true)),
	CLAN_FARMING(69, p -> p
		.setHasTransparency(true)),
	CLAN_ARROWS(70, p -> p
		.setHasTransparency(true)),
	CLAN_RUNE(71, p -> p
		.setHasTransparency(true)),
	CLAN_THIEVING(72, p -> p
		.setHasTransparency(true)),
	CLAN_BONES(73, p -> p
		.setHasTransparency(true)),
	CLAN_CABBAGE(74, p -> p
		.setHasTransparency(true)),
	CLAN_CAT(75, p -> p
		.setHasTransparency(true)),
	CLAN_COMPASS(76, p -> p
		.setHasTransparency(true)),
	CLAN_FISH(77, p -> p
		.setHasTransparency(true)),
	CLAN_HITPOINTS(78, p -> p
		.setHasTransparency(true)),
	CLAN_PRAYER(79, p -> p
		.setHasTransparency(true)),
	CLAN_HUNTER(80, p -> p
		.setHasTransparency(true)),
	CLAN_RING(81, p -> p
		.setHasTransparency(true)),
	CLAN_ROBINHOOD(82, p -> p
		.setHasTransparency(true)),
	CLAN_FLOWER(83, p -> p
		.setHasTransparency(true)),
	CLAN_DEFENCE(84, p -> p
		.setHasTransparency(true)),
	CLAN_ZAMORAK(85, p -> p
		.setHasTransparency(true)),
	CLAN_GROUP(86, p -> p
		.setHasTransparency(true)),
	CLAN_GROUP_HARDCORE(87, p -> p
		.setHasTransparency(true)),
	CLAN_EMPTY(88, p -> p
		.setHasTransparency(true)),
	SHAYZIEN_LEAVES_TOP(89, p -> p
		.setHasTransparency(true)),
	SHAYZIEN_LEAVES_SIDE(90, p -> p
		.setHasTransparency(true)
		.setTextureScale(1.025f, 1.025f)
	),
	WATER_ICE(91),
	SNOW_ROOF(92),
	SMALL_SNOWFLAKES(93),
	COLOR_MAP(94),
	CONCRETE_DARK(95),
	HIEROGLYPHICS_LARGE(96, p -> p
		.setHasTransparency(true)),
	HIEROGLYPHICS_SMALL(97, p -> p
		.setHasTransparency(true)),

	FOG_STATIC(98, p -> p
		.setHasTransparency(true)),
	FOG_VERY_SLOW(FOG_STATIC, p -> p
		.setVanillaTextureIndex(99)
		.setHasTransparency(true)),
	FOG_SLOW(FOG_STATIC, p -> p
		.setVanillaTextureIndex(100)
		.setHasTransparency(true)),
	FOG_MEDIUM(FOG_STATIC, p -> p
		.setVanillaTextureIndex(101)
		.setHasTransparency(true)),
	FOG_FAST(FOG_STATIC, p -> p
		.setVanillaTextureIndex(102)
		.setHasTransparency(true)),
	FOG_VERY_FAST(FOG_STATIC, p -> p
		.setVanillaTextureIndex(103)
		.setHasTransparency(true)),

	FOG_LIGHT_STATIC(104, p -> p
		.setHasTransparency(true)),
	FOG_LIGHT_VERY_SLOW(FOG_LIGHT_STATIC, p -> p
		.setVanillaTextureIndex(105)
		.setHasTransparency(true)),
	FOG_LIGHT_SLOW(FOG_LIGHT_STATIC, p -> p
		.setVanillaTextureIndex(106)
		.setHasTransparency(true)),
	FOG_LIGHT_MEDIUM(FOG_LIGHT_STATIC, p -> p
		.setVanillaTextureIndex(107)
		.setHasTransparency(true)),
	FOG_LIGHT_FAST(FOG_LIGHT_STATIC, p -> p
		.setVanillaTextureIndex(108)
		.setHasTransparency(true)),
	FOG_LIGHT_VERY_FAST(FOG_LIGHT_STATIC, p -> p
		.setVanillaTextureIndex(109)
		.setHasTransparency(true)),

	FOG_HEAVY_STATIC(110, p -> p
		.setHasTransparency(true)),
	FOG_HEAVY_VERY_SLOW(FOG_HEAVY_STATIC, p -> p
		.setVanillaTextureIndex(111)
		.setHasTransparency(true)),
	FOG_HEAVY_SLOW(FOG_HEAVY_STATIC, p -> p
		.setVanillaTextureIndex(112)
		.setHasTransparency(true)),
	FOG_HEAVY_MEDIUM(FOG_HEAVY_STATIC, p -> p
		.setVanillaTextureIndex(113)
		.setHasTransparency(true)),
	FOG_HEAVY_FAST(FOG_HEAVY_STATIC, p -> p
		.setVanillaTextureIndex(114)
		.setHasTransparency(true)),
	FOG_HEAVY_VERY_FAST(FOG_HEAVY_STATIC, p -> p
		.setVanillaTextureIndex(115)
		.setHasTransparency(true)),

	SKULLS(116),
	SKULLS_FOG(117),
	SKULLS_FOG_LIGHT(118),
	SKULLS_FOG_DARK(119),
	BRICK_BROWN_HORIZONTAL(120),

	WHITE(NONE),
	GRAY_75(NONE, p -> p.setBrightness(ColorUtils.srgbToLinear(.75f))),
	GRAY_65(NONE, p -> p.setBrightness(ColorUtils.srgbToLinear(.65f))),
	GRAY_50(NONE, p -> p.setBrightness(ColorUtils.srgbToLinear(.5f))),
	GRAY_25(NONE, p -> p.setBrightness(ColorUtils.srgbToLinear(.25f))),
	BLACK(NONE, p -> p.setBrightness(0)),
	PURE_BLACK(NONE, p -> p.setOverrideBaseColor(true).setBrightness(0)),

	BLANK_GLOSS(WHITE, p -> p
		.setSpecular(0.9f, 280)),
	BLANK_SEMIGLOSS(WHITE, p -> p
		.setSpecular(0.35f, 80)),

	SNOW_1_N,
	SNOW_1(p -> p.setNormalMap(SNOW_1_N).setSpecular(0.4f, 20)),
	SNOW_2_N,
	SNOW_2(p -> p.setNormalMap(SNOW_2_N).setSpecular(0.4f, 20)),
	SNOW_2_DARK(SNOW_2, p -> p.setBrightness(0.5f)),
	SNOW_3_N,
	SNOW_3(p -> p.setNormalMap(SNOW_3_N).setSpecular(0.4f, 20)),
	SNOW_4_N,
	SNOW_4(p -> p.setNormalMap(SNOW_4_N).setSpecular(0.4f, 20)),

	GRASS_1,
	GRASS_2,
	GRASS_3,
	GRASS_SCROLLING(GRASS_1, p -> p
		.setScroll(0, 1 / 0.7f)),
	DIRT_1_N,
	DIRT_1(p -> p
		.setNormalMap(DIRT_1_N)
		.setSpecular(0.25f, 18)),
	DIRT_1_VERT(DIRT_1, p -> p.setNormalMap(null)),
	DIRT_2_N,
	DIRT_2(p -> p
		.setNormalMap(DIRT_2_N)
		.setSpecular(0.25f, 18)),
	DIRT_2_VERT(DIRT_2, p -> p.setNormalMap(null)),
	GRAVEL_N,
	GRAVEL(p -> p
		.setNormalMap(GRAVEL_N)
		.setSpecular(0.4f, 130)
	),
	GRAVEL_LIGHT(GRAVEL, p -> p
		.setBrightness(1.5f)
	),

	DIRT_1_SHINY(DIRT_1, p -> p
		.setSpecular(1.1f, 380)),
	DIRT_2_SHINY(DIRT_2, p -> p
		.setSpecular(1.1f, 380)),
	GRAVEL_SHINY(GRAVEL, p -> p
		.setSpecular(1.1f, 380)),
	GRAVEL_SHINY_LIGHT(GRAVEL, p -> p
		.setSpecular(1.1f, 380)
		.setBrightness(1.55f)
	),
	SAND_1_N,
	SAND_1(p -> p
		.setNormalMap(SAND_1_N)
		.setSpecular(0.2f, 10)
	),
	SAND_2_N,
	SAND_2(p -> p
		.setNormalMap(SAND_2_N)
		.setSpecular(0.2f, 10)
	),
	SAND_3_N,
	SAND_3(p -> p
		.setNormalMap(SAND_3_N)
		.setSpecular(0.2f, 10)
	),
	GRUNGE_1,
	GRUNGE_1_SHINY(GRUNGE_1, p -> p
		.setSpecular(0.7f, 300)
	),
	GRUNGE_2,
	GRUNGE_2_SHINY(GRUNGE_2, p -> p
		.setSpecular(0.7f, 300)
	),
	SUBMERGED_GRUNGE_2(GRUNGE_2, p -> p
		.setFlowMap(UNDERWATER_FLOW_MAP)
		.setFlowMapStrength(0.075f)
		.setFlowMapDuration(new float[] { 12, -12 })),
	GRUNGE_3_N,
	GRUNGE_3(p -> p
		.setNormalMap(GRUNGE_3_N)
		.setSpecular(0.25f, 30)
	),
	ROCK_1_N,
	ROCK_1(p -> p
		.setNormalMap(ROCK_1_N)
		.setSpecular(0.35f, 40)
	),
	ROCK_1_LIGHT(ROCK_1, p -> p.setBrightness(1.4f)),
	ROCK_2_N,
	ROCK_2(p -> p
		.setNormalMap(ROCK_2_N)
		.setSpecular(0.35f, 60)
		.setBrightness(1.2f)
	),
	ROCK_3_D,
	ROCK_3_N,
	ROCK_3(p -> p
		.setNormalMap(ROCK_3_N)
		.setDisplacementMap(ROCK_3_D)
		.setDisplacementScale(.15f)
		.setSpecular(0.4f, 20)
		.setBrightness(1.2f)
	),
	ROCK_3_SMOOTH(ROCK_3, p -> p
		.setDisplacementScale(0)
		.setTextureScale(1, 1, .15f)
		.setSpecular(0.3f, 40)
	),
	ROCK_3_ORE(ROCK_3, p -> p
		.setSpecular(1, 20)
	),
	EADGARS_CAVE_FIX(ROCK_3, p -> p.setBrightness(0.65f)),
	TROLLHEIM_WALL_FIX_1(ROCK_3, p -> p.setBrightness(1.8f)),
	TROLLHEIM_WALL_FIX_2(ROCK_3, p -> p.setBrightness(1.2f)),

	ROCK_4_D,
	ROCK_4_N,
	ROCK_4(p -> p
		.setNormalMap(ROCK_4_N)
		.setDisplacementMap(ROCK_4_D)
		.setDisplacementScale(.15f)
		.setSpecular(0.4f, 20)
		.setBrightness(1.2f)
	),
	ROCK_4_ORE(ROCK_4, p -> p
		.setSpecular(1, 20)
	),
	ROCK_5_D,
	ROCK_5_N,
	ROCK_5(p -> p
		.setNormalMap(ROCK_5_N)
		.setDisplacementMap(ROCK_5_D)
		.setDisplacementScale(.15f)
		.setSpecular(0.4f, 20)
		.setBrightness(1.2f)
	),
	ROCK_5_ORE(ROCK_5, p -> p
		.setSpecular(1, 20)
	),
	CARPET,
	FINE_CARPET(CARPET, p -> p
		.setBrightness(1.4f)
		.setTextureScale(0.5f, 0.5f)),

	FALADOR_PATH_BRICK_N,
	FALADOR_PATH_BRICK(p -> p
		.setNormalMap(FALADOR_PATH_BRICK_N)
		.setSpecular(0.3f, 30)
	),
	JAGGED_STONE_TILE_D,
	JAGGED_STONE_TILE_N,
	JAGGED_STONE_TILE(p -> p
		.setDisplacementMap(JAGGED_STONE_TILE_D)
		.setDisplacementScale(.05f)
		.setNormalMap(JAGGED_STONE_TILE_N)
		.setSpecular(0.5f, 30)
	),
	POTTERY_OVEN_STONE(JAGGED_STONE_TILE, p -> p.setBrightness(0.3f)),

	TILE_SMALL_1(p -> p
		.setSpecular(0.8f, 70)),
	TILES_2X2_1_N,
	TILES_2X2_1(p -> p
		.setNormalMap(TILES_2X2_1_N)),
	TILES_2X2_1_GLOSS(TILES_2X2_1, p -> p
		.setSpecular(1.0f, 70)),
	TILES_2X2_1_SEMIGLOSS(TILES_2X2_1, p -> p
		.setSpecular(0.5f, 300)),
	TILES_2X2_2_N,
	TILES_2X2_2(p -> p
		.setNormalMap(TILES_2X2_2_N)
		.setSpecular(0.3f, 30)),
	TILES_2X2_2_GLOSS(TILES_2X2_2, p -> p
		.setSpecular(1.0f, 70)),
	TILES_2X2_2_SEMIGLOSS(TILES_2X2_2, p -> p
		.setSpecular(0.5f, 300)),

	MARBLE_1,
	MARBLE_2,
	MARBLE_3,
	MARBLE_1_GLOSS(MARBLE_1, p -> p
		.setSpecular(0.9f, 280)),
	MARBLE_2_GLOSS(MARBLE_2, p -> p
		.setSpecular(0.8f, 300)),
	MARBLE_3_GLOSS(MARBLE_3, p -> p
		.setSpecular(0.7f, 320)),
	MARBLE_1_SEMIGLOSS(MARBLE_1, p -> p
		.setSpecular(0.35f, 80)),
	MARBLE_2_SEMIGLOSS(MARBLE_2, p -> p
		.setSpecular(0.3f, 100)),
	MARBLE_3_SEMIGLOSS(MARBLE_3, p -> p
		.setSpecular(0.4f, 120)),

	LASSAR_UNDERCITY_TILE_NORMAL,
	LASSAR_UNDERCITY_TILE_DISP,
	LASSAR_UNDERCITY_TILES(MARBLE_2_SEMIGLOSS, p -> p
		.setNormalMap(LASSAR_UNDERCITY_TILE_NORMAL)
		.setDisplacementMap(LASSAR_UNDERCITY_TILE_DISP)
		.setDisplacementScale(.015f)
	),
	LASSAR_UNDERCITY_TILES_SUBMERGED(LASSAR_UNDERCITY_TILES, p -> p
		.setFlowMap(UNDERWATER_FLOW_MAP)
		.setFlowMapStrength(0.025f)
		.setFlowMapDuration(new float[] { 10, -10 })),

	HD_LAVA_1(p -> p
		.setUnlit(true)
		.setOverrideBaseColor(true)
		.setFlowMap(LAVA_FLOW_MAP, 0.04f, 36, 12)),
	HD_LAVA_2(p -> p
		.setUnlit(true)
		.setOverrideBaseColor(true)
		.setFlowMap(LAVA_FLOW_MAP, 0.04f, 36, 12)),
	HD_MAGMA_1(p -> p
		.setUnlit(true)
		.setOverrideBaseColor(true)
		.setFlowMap(LAVA_FLOW_MAP, 0.04f, 36, 12)),
	HD_MAGMA_2(p -> p
		.setUnlit(true)
		.setOverrideBaseColor(true)
		.setFlowMap(LAVA_FLOW_MAP, 0.04f, 36, 12)),
	BARK_N,
	BARK(p -> p
		.setNormalMap(BARK_N)
		.setSpecular(0.3f, 30)
	),
	LIGHT_BARK(BARK, p -> p.setBrightness(1.75f)),
	VERY_LIGHT_BARK(BARK, p -> p.setBrightness(2.75f)),
	BARK_STONEPINE_N,
	BARK_STONEPINE(p -> p
		.setNormalMap(BARK_STONEPINE_N)
		.setSpecular(0.3f, 30)
	),
	LIGHT_BARK_STONEPINE(BARK_STONEPINE, p -> p.setBrightness(1.75f)),
	WOOD_GRAIN,
	WOOD_GRAIN_LIGHT(WOOD_GRAIN, p -> p
		.setBrightness(1.5f)
	),
	WOOD_GRAIN_2_N,
	WOOD_GRAIN_2(p -> p
		.setNormalMap(WOOD_GRAIN_2_N)
		.setSpecular(0.3f, 30)
	),
	WOOD_GRAIN_2_SMOOTH(WOOD_GRAIN_2, p -> p
		.setBrightness(1.1f)
		.setTextureScale(1, 1, .2f)
	),
	WOOD_GRAIN_2_LIGHT(WOOD_GRAIN_2, p -> p
		.setBrightness(1.1f)
	),
	WOOD_GRAIN_2_SMOOTH_LIGHT(WOOD_GRAIN_2, p -> p
		.setBrightness(1.3f)
		.setTextureScale(1, 1, .2f)
	),
	WOOD_GRAIN_2_WIDE(WOOD_GRAIN_2, p -> p
		.setTextureScale(1.5f, 0.5f)
	),
	WOOD_GRAIN_3_D,
	WOOD_GRAIN_3_N,
	WOOD_GRAIN_3(p -> p
		.setDisplacementMap(WOOD_GRAIN_3_D)
		.setNormalMap(WOOD_GRAIN_3_N)
		.setSpecular(0.3f, 25)
	),
	WOOD_GRAIN_3_LIGHT(WOOD_GRAIN_3, p -> p.setBrightness(1.6f)),
	DOCK_FENCE,
	DOCK_FENCE_DARK(DOCK_FENCE, p -> p.setBrightness(0.6f)),

	HD_INFERNAL_CAPE(p -> p
		.replaceIf(plugin -> plugin.config.hdInfernalTexture(), INFERNAL_CAPE)
		.setUnlit(true)
		.setOverrideBaseColor(true)
		.setFlowMap(LAVA_FLOW_MAP, 0.02f, 12, 4)
		.setScroll(0, 1 / 3f)),

	HD_BRICK_N,
	HD_BRICK_D,
	HD_BRICK(p -> p
		.replaceIf(plugin -> plugin.configModelTextures, BRICK)
		.setNormalMap(HD_BRICK_N)
		.setDisplacementMap(HD_BRICK_D)
		.setDisplacementScale(.05f)
		.setSpecular(0.30f, 20)
	),
	HD_ROOF_SHINGLES_N,
	HD_ROOF_SHINGLES_D,
	HD_ROOF_SHINGLES_1(p -> p
		.replaceIf(plugin -> plugin.configModelTextures, ROOF_SHINGLES_1)
		.setSpecular(0.35f, 40)
		.setNormalMap(HD_ROOF_SHINGLES_N)
		.setDisplacementMap(HD_ROOF_SHINGLES_D)
		.setDisplacementScale(0.11f)
	),
	HD_MARBLE_DARK(p -> p
		.replaceIf(plugin -> plugin.configModelTextures, MARBLE_DARK)
		.setSpecular(1.1f, 380)),
	HD_BRICK_BROWN_N,
	HD_BRICK_BROWN_D,
	HD_BRICK_BROWN(p -> p
		.replaceIf(plugin -> plugin.configModelTextures, BRICK_BROWN)
		.setNormalMap(HD_BRICK_BROWN_N)
		.setDisplacementMap(HD_BRICK_BROWN_D)
		.setDisplacementScale(.05f)
		.setSpecular(0.35f, 20)
	),
	HD_LAVA_3(p -> p
		.replaceIf(plugin -> plugin.configModelTextures, LAVA)
		.setUnlit(true)
		.setOverrideBaseColor(true)
		.setFlowMap(LAVA_FLOW_MAP, 0.05f, 36, 22)
		.setScroll(0, 1 / 3f)),
	HD_ROOF_SHINGLES_2(p -> p
		.replaceIf(plugin -> plugin.configModelTextures, ROOF_SHINGLES_2)
		.setSpecular(0.3f, 30)
		.setNormalMap(HD_ROOF_SHINGLES_N)
	),
	HD_SIMPLE_GRAIN_WOOD_D,
	HD_SIMPLE_GRAIN_WOOD_N,
	HD_SIMPLE_GRAIN_WOOD(p -> p
		.replaceIf(plugin -> plugin.configModelTextures, SIMPLE_GRAIN_WOOD)
		.setSpecular(0.3f, 20)
		.setNormalMap(HD_SIMPLE_GRAIN_WOOD_N)
		.setDisplacementMap(HD_SIMPLE_GRAIN_WOOD_D)
		.setDisplacementScale(.008f)
	),

	WORN_TILES_N,
	WORN_TILES(p -> p.setNormalMap(WORN_TILES_N).setSpecular(0.2f,25)),
	HD_STONE_PATTERN_N,
	HD_STONE_PATTERN_D,
	HD_STONE_PATTERN(p -> p
		.replaceIf(plugin -> plugin.configModelTextures, STONE_PATTERN)
		.setNormalMap(HD_STONE_PATTERN_N)
		.setDisplacementMap(HD_STONE_PATTERN_D)
		.setDisplacementScale(0.08f)
		.setSpecular(0.25f, 30)
	),
	STONE_N,
	STONE,
	STONE_NORMALED(STONE, p -> p
		.setNormalMap(STONE_N)
		.setSpecular(0.3f, 30)
	),
	STONE_NORMALED_DARK(STONE_NORMALED, p -> p
		.setBrightness(0.88f)
	),
	STONE_LOWGLOSS(STONE, p -> p
		.setSpecular(0.3f, 30)
	),
	STONE_SEMIGLOSS(STONE, p -> p.setSpecular(0.6f, 100)),
	STONE_SCROLLING(STONE, p -> p
		.setScroll(0, -1 / 0.7f)),

	WALL_STONE_N,
	WALL_STONE(p -> p
		.setNormalMap(WALL_STONE_N)),
	WALL_STONE_LIGHT(WALL_STONE, p -> p
		.setNormalMap(WALL_STONE_N)
		.setBrightness(1.7f)),
	METALLIC_1_N,
	METALLIC_1(p -> p.setNormalMap(METALLIC_1_N).setSpecular(0.6f, 30)),
	METALLIC_1_SEMIGLOSS(METALLIC_1, p -> p
		.setSpecular(0.8f, 60)),
	METALLIC_1_GLOSS(METALLIC_1, p -> p
		.setSpecular(0.9f, 80)),
	METALLIC_1_HIGHGLOSS(METALLIC_1, p -> p
		.setSpecular(1.1f, 120)),
	METALLIC_1_LIGHT(METALLIC_1, p -> p.setBrightness(1.8f)),
	METALLIC_1_LIGHT_SEMIGLOSS(METALLIC_1_LIGHT, p -> p
		.setSpecular(0.7f, 80)),
	METALLIC_1_LIGHT_GLOSS(METALLIC_1_LIGHT, p -> p
		.setSpecular(0.9f, 120)),
	METALLIC_1_LIGHT_HIGHGLOSS(METALLIC_1_LIGHT, p -> p
		.setSpecular(1.1f, 160)),
	METALLIC_1_LIGHT_SUPER_HIGHGLOSS(METALLIC_1_LIGHT, p -> p
		.setSpecular(2.25f, 65)),
	METALLIC_NONE_GLOSS(NONE, p -> p
		.setSpecular(0.7f, 120)),
	WATTLE_1,
	ICE_1(SNOW_4, p -> p
		.replaceIf(SeasonalTheme.WINTER, WATER_FLAT_2, WATER_FLAT)
		.setSpecular(1.1f, 200)),
	ICE_1_HIGHGLOSS(ICE_1, p -> p
		.replaceIf(SeasonalTheme.WINTER, WATER_FLAT_2, WATER_FLAT)
		.setSpecular(3.1f, 30)),
	ICE_2(SNOW_2, p -> p
		.setSpecular(1.5f, 800)),
	ICE_3(GRUNGE_2, p -> p
		.setSpecular(1.9f, 1000)),
	ICE_4(WHITE, p -> p
		.setSpecular(1.5f, 1000)
		.setNormalMap(WATER_NORMAL_MAP_2)),
	SLIME_GRUNGE(GRUNGE_1, p -> p
		.setSpecular(4.1f, 60)),
	WATER_PUDDLE(NONE, p -> p
		.setSpecular(1.5f, 80)),
	HD_WOOD_PLANKS_1_N,
	HD_WOOD_PLANKS_1(p -> p
		.replaceIf(plugin -> plugin.configModelTextures, WOOD_PLANKS_1)
		.setNormalMap(HD_WOOD_PLANKS_1_N)
		.setSpecular(0.3f, 30)
	),
	HD_WOOD_PLANKS_2_N,
	HD_WOOD_PLANKS_2(p -> p
		.setNormalMap(HD_WOOD_PLANKS_2_N)
		.setSpecular(0.3f, 40)
		.setBrightness(1.2f)),
	HD_CRATE_N,
	HD_CRATE(p -> p
		.replaceIf(plugin -> plugin.configModelTextures, CRATE)
		.setNormalMap(HD_CRATE_N)
		.setSpecular(0.25f, 30)
		.setBrightness(0.9f)
	),
	HD_ROOF_BRICK_TILE_N,
	HD_ROOF_BRICK_TILE(p -> p
		.replaceIf(plugin -> plugin.configModelTextures, ROOF_BRICK_TILE)
		.setSpecular(0.3f, 30)
		.setNormalMap(HD_ROOF_BRICK_TILE_N)
	),
	HD_ROOF_BRICK_TILE_GREEN(ROOF_BRICK_TILE_GREEN, p -> p
		.replaceIf(plugin -> plugin.configModelTextures, ROOF_BRICK_TILE_GREEN)
		.setSpecular(0.3f, 30)
		.setNormalMap(HD_ROOF_BRICK_TILE_N)
	),
	HD_ROOF_BRICK_TILE_DARK(ROOF_BRICK_TILE_DARK, p -> p
		.replaceIf(plugin -> plugin.configModelTextures, ROOF_BRICK_TILE_DARK)
		.setSpecular(0.3f, 30)
		.setNormalMap(HD_ROOF_BRICK_TILE_N)
	),
	PLANT_GRUNGE_1(GRUNGE_1, p -> p
		.setSpecular(0.25f, 25)
	),
	PLANT_GRUNGE_2(GRUNGE_2, p -> p
		.setSpecular(0.20f, 20)
	),
	HD_CONCRETE_D,
	HD_CONCRETE_N,
	HD_CONCRETE(p -> p
		.replaceIf(plugin -> plugin.configModelTextures, CONCRETE)
		.setNormalMap(HD_CONCRETE_N)
		.setDisplacementMap(HD_CONCRETE_D)
		.setDisplacementScale(0.05f)
		.setSpecular(0.3f, 20)
		.setBrightness(0.75f)
	),
	HD_HAY_N,
	HD_HAY(p -> p
		.replaceIf(plugin -> plugin.configModelTextures, HAY)
		.setSpecular(0.3f, 20)
		.setNormalMap(HD_HAY_N)
	),
	OOZE(GRAY_65, p -> p
		.setSpecular(1.5f, 600)
	),
	BONE(GRUNGE_2, p -> p
		.setSpecular(0.25f, 20)
		.setBrightness(1.3f)
	),
	ABYSSAL_D,
	ABYSSAL_N,
	ABYSSAL(p -> p
		.setSpecular(4.5f, 400)
		.setNormalMap(ABYSSAL_N)
		.setDisplacementMap(ABYSSAL_D)
		.setDisplacementScale(0.2f)
		.setBrightness(3f)
	),
	ABYSSAL_2_D,
	ABYSSAL_2_N,
	ABYSSAL_2(p -> p
		.setSpecular(7f, 400)
		.setNormalMap(ABYSSAL_2_N)
		.setDisplacementMap(ABYSSAL_2_D)
		.setDisplacementScale(0.1f)
		.setBrightness(1.9f)
	),


	// Aliases for separately replacing textures of different trees
	LEAVES_YELLOW_SIDE(LEAVES_SIDE),
	LEAVES_YELLOW_TOP(LEAVES_TOP),
	LEAVES_RED_SIDE(LEAVES_SIDE),
	LEAVES_RED_TOP(LEAVES_TOP),
	LEAVES_ORANGE_SIDE(LEAVES_SIDE),
	LEAVES_ORANGE_TOP(LEAVES_TOP),

	// Seasonal
	AUTUMN_LEAVES_YELLOW_SIDE(p -> p
		.setHasTransparency(true)
		.setTextureScale(1.025f, 1.025f)
		.replaceIf(SeasonalTheme.AUTUMN, LEAVES_YELLOW_SIDE)
	),
	AUTUMN_LEAVES_YELLOW_TOP(p -> p
		.setHasTransparency(true)
		.setTextureScale(1.025f, 1.025f)
		.replaceIf(SeasonalTheme.AUTUMN, LEAVES_YELLOW_TOP)
	),
	AUTUMN_LEAVES_ORANGE_SIDE(p -> p
		.setHasTransparency(true)
		.setTextureScale(1.025f, 1.025f)
		.replaceIf(SeasonalTheme.AUTUMN, LEAVES_ORANGE_SIDE)
	),
	AUTUMN_LEAVES_ORANGE_TOP(p -> p
		.setHasTransparency(true)
		.setTextureScale(1.025f, 1.025f)
		.replaceIf(SeasonalTheme.AUTUMN, LEAVES_ORANGE_TOP)
	),
	AUTUMN_LEAVES_RED_SIDE(p -> p
		.setHasTransparency(true)
		.setTextureScale(1.025f, 1.025f)
		.replaceIf(SeasonalTheme.AUTUMN, LEAVES_RED_SIDE)
	),
	AUTUMN_LEAVES_RED_TOP(p -> p
		.setHasTransparency(true)
		.setTextureScale(1.025f, 1.025f)
		.replaceIf(SeasonalTheme.AUTUMN, LEAVES_RED_TOP)
	),
	AUTUMN_WILLOW_LEAVES(p -> p
		.setHasTransparency(true)
		.setTextureScale(1.025f, 1.025f)
		.replaceIf(SeasonalTheme.AUTUMN, WILLOW_LEAVES)
	),

	WINTER_WILLOW_LEAVES(p -> p
		.setHasTransparency(true)
		.setTextureScale(1.025f, 1.025f)
		.replaceIf(SeasonalTheme.WINTER, WILLOW_LEAVES)
	),
	WINTER_MAPLE_LEAVES(p -> p
		.setHasTransparency(true)
		.setTextureScale(1.3f, 1.025f)
		.replaceIf(SeasonalTheme.WINTER, MAPLE_LEAVES)
	),
	WINTER_LEAVES_SIDE(p -> p
		.setHasTransparency(true)
		.setTextureScale(1.025f, 1.025f)
		.replaceIf(SeasonalTheme.WINTER, LEAVES_SIDE, LEAVES_YELLOW_SIDE, LEAVES_ORANGE_SIDE, LEAVES_RED_SIDE)
	),
	WINTER_LEAVES_TOP(p -> p
		.setHasTransparency(true)
		.replaceIf(SeasonalTheme.WINTER, LEAVES_TOP, LEAVES_YELLOW_TOP, LEAVES_ORANGE_TOP, LEAVES_RED_TOP)
	),
	WINTER_LEAVES_DISEASED(p -> p
		.setHasTransparency(true)
		.setTextureScale(1.025f, 1.025f)
		.replaceIf(SeasonalTheme.WINTER, LEAVES_DISEASED)
	),
	WINTER_PAINTING_LANDSCAPE(p -> p
		.replaceIf(SeasonalTheme.WINTER, PAINTING_LANDSCAPE)
	),
	WINTER_PAINTING_KING(p -> p
		.replaceIf(SeasonalTheme.WINTER, PAINTING_KING)
	),
	WINTER_PAINTING_ELF(p -> p
		.replaceIf(SeasonalTheme.WINTER, PAINTING_ELF)
	),
	WINTER_HD_ROOF_SHINGLES_1(p -> p
		.replaceIf(SeasonalTheme.WINTER, HD_ROOF_SHINGLES_1)
		.setSpecular(0.5f, 30)
		.setNormalMap(HD_ROOF_SHINGLES_N)),
	WINTER_HD_ROOF_SHINGLES_2(p -> p
		.replaceIf(SeasonalTheme.WINTER, HD_ROOF_SHINGLES_2)
		.setSpecular(0.3f, 30)
		.setNormalMap(HD_ROOF_SHINGLES_N)),
	WINTER_HD_ROOF_BRICK_TILES(p -> p
		.setSpecular(0.3f, 30)
		.setNormalMap(HD_ROOF_BRICK_TILE_N)
		.replaceIf(SeasonalTheme.WINTER, HD_ROOF_BRICK_TILE, HD_ROOF_BRICK_TILE_GREEN, HD_ROOF_BRICK_TILE_DARK)
	),
	WINTER_HD_ROOF_SLATE(p -> p
		.setSpecular(0.5f, 30)
		.replaceIf(SeasonalTheme.WINTER, ROOF_SLATE)
	),
	WINTER_HD_ROOF_WOODEN_SLATE(p -> p
		.setSpecular(0.5f, 30)
		.replaceIf(SeasonalTheme.WINTER, ROOF_WOODEN_SLATE)
	),
	WINTER_JAGGED_STONE_TILE(p -> p
		.setDisplacementMap(JAGGED_STONE_TILE_D)
		.setNormalMap(JAGGED_STONE_TILE_N)
		.setSpecular(0.6f, 30)
		.setBrightness(1.4f)
	),
	WINTER_JAGGED_STONE_TILE_LIGHT(WINTER_JAGGED_STONE_TILE, p -> p.setBrightness(4)),
	WINTER_JAGGED_STONE_TILE_LIGHTER(WINTER_JAGGED_STONE_TILE, p -> p.setBrightness(12)),
	;

	public final Material parent;
	public final Material normalMap;
	public final Material displacementMap;
	public final Material roughnessMap;
	public final Material ambientOcclusionMap;
	public final Material flowMap;
	public final int vanillaTextureIndex;
	public final boolean hasTransparency;
	public final boolean overrideBaseColor;
	public final boolean unlit;
	public final boolean hasTexture;
	public final float brightness;
	public final float displacementScale;
	public final float flowMapStrength;
	public final float[] flowMapDuration;
	public final float specularStrength;
	public final float specularGloss;
	public final float[] scrollSpeed;
	public final float[] textureScale;
	public final List<Material> materialsToReplace = new ArrayList<>();
	public final Function<HdPlugin, Boolean> replacementCondition;

	@Setter
	private static class Builder {
		private Material parent;
		private Material normalMap;
		private Material displacementMap;
		private Material roughnessMap;
		private Material ambientOcclusionMap;
		private Material flowMap;
		private int vanillaTextureIndex = -1;
		private boolean hasTransparency = false;
		private boolean overrideBaseColor = false;
		private boolean unlit = false;
		private float brightness = 1;
		private float displacementScale = .1f;
		private float flowMapStrength;
		private float[] flowMapDuration = { 0, 0 };
		private float specularStrength;
		private float specularGloss;
		private float[] scrollSpeed = { 0, 0 };
		private float[] textureScale = { 1, 1, 1 };
		private List<Material> materialsToReplace = new ArrayList<>();
		private Function<HdPlugin, Boolean> replacementCondition;

		Builder apply(Consumer<Builder> consumer) {
			consumer.accept(this);
			return this;
		}

		Builder setParent(Material parent) {
			this.parent = parent;
			this.normalMap = parent.normalMap;
			this.displacementMap = parent.displacementMap;
			this.roughnessMap = parent.roughnessMap;
			this.ambientOcclusionMap = parent.ambientOcclusionMap;
			this.flowMap = parent.flowMap;
			this.vanillaTextureIndex = parent.vanillaTextureIndex;
			this.hasTransparency = parent.hasTransparency;
			this.overrideBaseColor = parent.overrideBaseColor;
			this.unlit = parent.unlit;
			this.brightness = parent.brightness;
			this.displacementScale = parent.displacementScale;
			this.flowMapStrength = parent.flowMapStrength;
			this.flowMapDuration = parent.flowMapDuration;
			this.specularStrength = parent.specularStrength;
			this.specularGloss = parent.specularGloss;
			this.scrollSpeed = parent.scrollSpeed;
			this.textureScale = parent.textureScale;
			this.materialsToReplace.addAll(parent.materialsToReplace);
			this.replacementCondition = parent.replacementCondition;
			return this;
		}

		Builder setSpecular(float specularStrength, float specularGloss) {
			this.specularStrength = specularStrength;
			this.specularGloss = specularGloss;
			return this;
		}

		Builder setFlowMap(Material flowMap, float flowMapStrength, float durationX, float durationY) {
			this.flowMap = flowMap;
			this.flowMapStrength = flowMapStrength;
			this.flowMapDuration = new float[] { durationX, durationY };
			return this;
		}

		Builder setScroll(float speedX, float speedY) {
			this.scrollSpeed = new float[] { -speedX, -speedY };
			return this;
		}

		Builder setTextureScale(float... xyz) {
			textureScale = Arrays.copyOf(textureScale, 3);
			System.arraycopy(xyz, 0, textureScale, 0, Math.min(3, xyz.length));
			return this;
		}

		Builder replaceIf(@NonNull Function<HdPlugin, Boolean> condition, @NonNull Material... materialsToReplace) {
			Collections.addAll(this.materialsToReplace, materialsToReplace);
			this.replacementCondition = condition;
			return this;
		}

		Builder replaceIf(SeasonalTheme seasonalTheme, @NonNull Material... materialsToReplace) {
			return replaceIf(plugin -> plugin.configSeasonalTheme == seasonalTheme, materialsToReplace);
		}
	}

	Material() {
		this(p -> {});
	}

	Material(int vanillaTextureIndex) {
		this(p -> p.setVanillaTextureIndex(vanillaTextureIndex));
	}

	Material(Material parent) {
		this(parent, p -> {});
	}

	Material(Material parent, Consumer<Builder> consumer) {
		this(b -> b.setParent(parent).apply(consumer));
	}

	Material(int vanillaTextureIndex, Consumer<Builder> consumer) {
		this(b -> b.setVanillaTextureIndex(vanillaTextureIndex).apply(consumer));
	}

	Material(Consumer<Builder> consumer) {
		Builder builder = new Builder();
		consumer.accept(builder);
		parent = builder.parent;
		normalMap = builder.normalMap;
		displacementMap = builder.displacementScale == 0 ? null : builder.displacementMap;
		roughnessMap = builder.roughnessMap;
		ambientOcclusionMap = builder.ambientOcclusionMap;
		flowMap = builder.flowMap;
		vanillaTextureIndex = builder.vanillaTextureIndex;
		hasTransparency = builder.hasTransparency;
		overrideBaseColor = builder.overrideBaseColor;
		unlit = builder.unlit;
		brightness = builder.brightness;
		displacementScale = builder.displacementScale;
		flowMapStrength = builder.flowMapStrength;
		flowMapDuration = builder.flowMapDuration;
		specularStrength = builder.specularStrength;
		specularGloss = builder.specularGloss;
		scrollSpeed = builder.scrollSpeed;
		textureScale = builder.textureScale;
		materialsToReplace.addAll(builder.materialsToReplace);
		replacementCondition = builder.replacementCondition;

		// Determine whether the material contains some form of texture change
		var base = this;
		while (base.parent != null)
			base = base.parent;
		hasTexture =
			base.ordinal() != 0 ||
			normalMap != null ||
			displacementMap != null ||
			roughnessMap != null ||
			ambientOcclusionMap != null ||
			flowMap != null;
	}

	private static Material[] VANILLA_TEXTURE_MAPPING = {};
	private static final Material[] REPLACEMENT_MAPPING = new Material[Material.values().length];

	public static void updateMappings(Texture[] textures, HdPlugin plugin) {
		var materials = Material.values();
		for (int i = 0; i < materials.length; ++i) {
			var material = materials[i];

			// If the material is a conditional replacement material, and the condition is not met,
			// the material shouldn't be loaded and can be mapped to NONE
			if (material.replacementCondition != null && !material.replacementCondition.apply(plugin)) {
				material = NONE;
			} else {
				// Apply material replacements from top to bottom
				for (int j = i + 1; j < materials.length; ++j) {
					var replacement = materials[j];
					if (replacement.replacementCondition != null &&
						replacement.replacementCondition.apply(plugin) &&
						replacement.materialsToReplace.contains(material)) {
						material = replacement;
						break;
					}
				}
			}

			REPLACEMENT_MAPPING[i] = material;
		}

		VANILLA_TEXTURE_MAPPING = new Material[textures.length];
		Arrays.fill(VANILLA_TEXTURE_MAPPING, Material.VANILLA);
		for (int i = 0; i < textures.length; i++) {
			for (var material : materials) {
				if (material.vanillaTextureIndex == i && material.parent == null) {
					assert VANILLA_TEXTURE_MAPPING[i] == VANILLA :
						"Material " + material + " conflicts with vanilla ID " + material.vanillaTextureIndex + " of material "
						+ VANILLA_TEXTURE_MAPPING[i];
					VANILLA_TEXTURE_MAPPING[i] = material.resolveReplacements();
				}
			}
		}
	}

	public static Material fromVanillaTexture(int vanillaTextureId) {
		if (vanillaTextureId < 0 || vanillaTextureId >= VANILLA_TEXTURE_MAPPING.length)
			return NONE;
		return VANILLA_TEXTURE_MAPPING[vanillaTextureId];
	}

	/**
	 * Returns the final material after all replacements have been made.
	 *
	 * @return the material after resolving all replacements
	 */
	public Material resolveReplacements() {
		return REPLACEMENT_MAPPING[this.ordinal()];
	}

	/**
	 * @return an array of all unique materials in use after all replacements have been accounted for, including NONE.
	 */
	public static Material[] getActiveMaterials() {
		return Arrays.stream(REPLACEMENT_MAPPING)
			.filter(m -> m != VANILLA) // The VANILLA material is used for vanilla textures lacking a material definition
			.distinct()
			.toArray(Material[]::new);
	}

	/**
	 * @return an array of all unique materials in use after all replacements have been accounted for, except NONE.
	 */
	public static Material[] getTextureMaterials() {
		return Arrays.stream(REPLACEMENT_MAPPING)
			.map(Material::resolveTextureMaterial)
			.filter(m -> m != NONE)
			.distinct()
			.toArray(Material[]::new);
	}

	public Material resolveTextureMaterial() {
		var base = this.resolveReplacements();
		while (base.parent != null)
			base = base.parent;
		return base;
	}
}

/*
 * Copyright (c) 2021, 117 <https://twitter.com/117scape>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package rs117.hd.data.materials;

public enum UvType {
	VANILLA,
	GEOMETRY,
	// TODO: move MODEL_* computation to compute shader for efficiency
	MODEL_XY(true, (uvw, i, x, y, z) -> {
		uvw[i] = x;
		uvw[i + 1] = y;
		uvw[i + 2] = z;
	}),
	MODEL_XY_MIRROR_A(MODEL_XY, UvType::mirrorDiagonally),
	MODEL_XY_MIRROR_B(MODEL_XY, (uvw, i) -> {
		uvw[i + 1] = 1 - uvw[i + 1];
		mirrorDiagonally(uvw, i);
	}),
	MODEL_XZ(true, (uvw, i, x, y, z) -> {
		uvw[i] = x;
		uvw[i + 1] = z;
		uvw[i + 2] = y;
	}),
	MODEL_XZ_MIRROR_A(MODEL_XZ, UvType::mirrorDiagonally),
	MODEL_XZ_MIRROR_B(MODEL_XZ, (uvw, i) -> {
		uvw[i + 1] = 1 - uvw[i + 1];
		mirrorDiagonally(uvw, i);
	}),
	MODEL_YZ(true, (uvw, i, x, y, z) -> {
		uvw[i] = y;
		uvw[i + 1] = z;
		uvw[i + 2] = x;
	}),
	MODEL_YZ_MIRROR_A(MODEL_YZ, UvType::mirrorDiagonally),
	MODEL_YZ_MIRROR_B(MODEL_YZ, (uvw, i) -> {
		uvw[i + 1] = 1 - uvw[i + 1];
		mirrorDiagonally(uvw, i);
	}),
	WORLD_XY(new float[] { 0, 0, -1 }),
	WORLD_XZ(new float[] { 0, -1, 0 }),
	WORLD_YZ(new float[] { -1, 0, 0 }),
	BOX,
	;

	public final boolean worldUvs;
	public final boolean orientationDependent;
	private final UvGenerator generator;

	UvType() {
		worldUvs = false;
		orientationDependent = false;
		generator = null;
	}

	UvType(boolean orientationDependent, UvGenerator generator) {
		this.worldUvs = false;
		this.orientationDependent = orientationDependent;
		this.generator = generator;
	}

	UvType(UvType inherit, UvProcessor processor) {
		worldUvs = inherit.worldUvs;
		orientationDependent = inherit.orientationDependent;
		generator = (uvw, i, x, y, z) -> {
			inherit.generator.computeUvw(uvw, i, x, y, z);
			processor.processUvw(uvw, i);
		};
	}

	UvType(float[] normal) {
		worldUvs = true;
		orientationDependent = false;
		generator = (uvw, i, scale, _1, _2) -> {
			uvw[i] = scale * normal[0];
			uvw[i + 1] = scale * normal[1];
			uvw[i + 2] = scale * normal[2];
		};
	}

	@FunctionalInterface
	public interface UvGenerator {
		void computeUvw(float[] out, int offset, float x, float y, float z);
	}

	@FunctionalInterface
	public interface UvProcessor {
		void processUvw(float[] out, int offset);
	}

	public void computeModelUvw(float[] out, int offset, float x, float y, float z) {
		assert generator != null : this + " does not support computing UVs";
		generator.computeUvw(out, offset, x, y, z);
	}

	public void computeWorldUvw(float[] out, int offset, float scale) {
		assert generator != null : this + " does not support computing UVs";
		generator.computeUvw(out, offset, scale, 0, 0);
	}

	private static void mirrorDiagonally(float[] uv, int i) {
		if (uv[i] < uv[i + 1]) {
			float temp = uv[i];
			uv[i] = uv[i + 1];
			uv[i + 1] = temp;
		}
	}
}

package rs117.hd.scene.lights;

import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import java.util.HashSet;
import javax.annotation.Nullable;
import lombok.NoArgsConstructor;
import rs117.hd.utils.AABB;
import rs117.hd.utils.ColorUtils;
import rs117.hd.utils.GsonUtils;

@NoArgsConstructor // Called by GSON when parsing JSON
public class LightDefinition {
	public String description;
	@Nullable
	public Integer worldX, worldY;
	public int plane;
	public Alignment alignment = Alignment.CUSTOM;
	public int[] offset = new int[3];
	public int height;
	public int radius = 300;
	public float strength = 5;
	@JsonAdapter(ColorUtils.SrgbToLinearAdapter.class)
	public float[] color;
	public LightType type = LightType.STATIC;
	public float duration;
	public float range;
	public int fadeInDuration = 50;
	public int fadeOutDuration = 50;
	public int spawnDelay;
	public int despawnDelay;
	public boolean fixedDespawnTime;
	public boolean visibleFromOtherPlanes;
	public int renderableIndex = -1;

	@JsonAdapter(AABB.JsonAdapter.class)
	public AABB[] areas = {};
	@JsonAdapter(GsonUtils.IntegerSetAdapter.class)
	public HashSet<Integer> npcIds = new HashSet<>();
	@JsonAdapter(GsonUtils.IntegerSetAdapter.class)
	public HashSet<Integer> objectIds = new HashSet<>();
	@JsonAdapter(GsonUtils.IntegerSetAdapter.class)
	public HashSet<Integer> projectileIds = new HashSet<>();
	@JsonAdapter(GsonUtils.IntegerSetAdapter.class)
	@SerializedName("graphicsObjectIds") // TODO: rename this
	public HashSet<Integer> spotAnimIds = new HashSet<>();
	@JsonAdapter(GsonUtils.IntegerSetAdapter.class)
	public HashSet<Integer> animationIds = new HashSet<>();

	public void normalize() {
		if (description == null)
			description = "N/A";
		if (alignment == null || alignment == Alignment.CENTER)
			alignment = Alignment.CUSTOM;
		if (offset == null || offset.length != 3) {
			offset = new int[3];
		} else {
			offset[1] *= -1;
		}
		if (color == null || color.length != 3)
			color = new float[3];
		if (type == null)
			type = LightType.STATIC;
	}
}

package rs117.hd.scene.lights;

public enum LightType
{
	STATIC, FLICKER, PULSE
}

package rs117.hd.scene.lights;

import net.runelite.api.*;
import net.runelite.api.coords.*;
import rs117.hd.utils.HDUtils;

public class Light
{
	public static final float VISIBILITY_FADE = 0.1f;

	public final float randomOffset = HDUtils.rand.nextFloat();
	public final LightDefinition def;

	public int radius;
	public float strength;
	/**
	 * Linear color space RGBA in the range [0, 1]
	 */
	public float[] color;
	public float animation = 0.5f;
	public float duration;
	public float fadeInDuration;
	public float fadeOutDuration;
	public float spawnDelay;
	public float despawnDelay;

	public boolean visible;
	public boolean parentExists;
	public boolean withinViewingDistance = true;
	public boolean hiddenTemporarily;
	public boolean markedForRemoval;
	public boolean persistent;
	public boolean replayable;

	public final boolean animationSpecific;
	public final boolean dynamicLifetime;

	public float elapsedTime;
	public float changedVisibilityAt = -1;
	public float lifetime = -1;

	public WorldPoint worldPoint;
	public boolean belowFloor;
	public boolean aboveFloor;
	public int plane;
	public int prevPlane = -1;
	public int prevTileX = -1;
	public int prevTileY = -1;
	public Alignment alignment;
	public int[] origin = new int[3];
	public int[] offset = new int[3];
	public int[] pos = new int[3];
	public int orientation;
	public int distanceSquared;

	public Actor actor;
	public Projectile projectile;
	public TileObject tileObject;
	public GraphicsObject graphicsObject;
	public int spotAnimId = -1;
	public int preOrientation;
	public int[] projectileRefCounter;
	public long hash;

	public int sizeX = 1;
	public int sizeY = 1;

	public Light(LightDefinition def) {
		this.def = def;
		System.arraycopy(def.offset, 0, offset, 0, 3);
		duration = Math.max(0, def.duration) / 1000f;
		fadeInDuration = Math.max(0, def.fadeInDuration) / 1000f;
		fadeOutDuration = Math.max(0, def.fadeOutDuration) / 1000f;
		spawnDelay = Math.max(0, def.spawnDelay) / 1000f;
		despawnDelay = Math.max(0, def.despawnDelay) / 1000f;
		color = def.color;
		radius = def.radius;
		strength = def.strength;
		alignment = def.alignment;
		plane = def.plane;
		if (def.type == LightType.PULSE)
			animation = (float) Math.random();

		// Old way of setting a fixed lifetime
		if (def.fixedDespawnTime)
			lifetime = spawnDelay + despawnDelay;

		if (lifetime == -1) {
			dynamicLifetime = true;
			// If the despawn is dynamic, ensure there's enough time for the light to fade out
			despawnDelay = Math.max(despawnDelay, fadeOutDuration);
		} else {
			dynamicLifetime = false;
		}

		animationSpecific = !def.animationIds.isEmpty();
		if (animationSpecific) {
			persistent = replayable = true;
			// Initially hide the light
			if (dynamicLifetime) {
				lifetime = 0;
			} else {
				elapsedTime = lifetime;
			}
		}
	}

	public void toggleTemporaryVisibility() {
		hiddenTemporarily = !hiddenTemporarily;
		// Begin fading in or out, while accounting for time already spent fading out or in respectively
		float beginFadeAt = elapsedTime;
		if (changedVisibilityAt != -1)
			beginFadeAt -= Math.max(0, VISIBILITY_FADE - (elapsedTime - changedVisibilityAt));
		changedVisibilityAt = beginFadeAt;
	}

	public float getTemporaryVisibilityFade() {
		float fade = 1;
		if (changedVisibilityAt != -1)
			fade = HDUtils.clamp((elapsedTime - changedVisibilityAt) / Light.VISIBILITY_FADE, 0, 1);
		if (hiddenTemporarily)
			fade = 1 - fade; // Fade out instead
		return fade;
	}

	public void applyTemporaryVisibilityFade() {
		strength *= getTemporaryVisibilityFade();
	}
}

package rs117.hd.scene.lights;

import javax.annotation.Nullable;
import net.runelite.api.*;
import net.runelite.api.coords.*;

public class TileObjectImpostorTracker {
	public TileObject tileObject;
	public final long tileObjectHash;
	public boolean justSpawned = true;
	public boolean spawnedAnyLights;
	public int[] impostorIds;
	public int impostorVarbit = -1;
	public int impostorVarp = -1;
	public int impostorId = -1;

	public TileObjectImpostorTracker(TileObject tileObject) {
		this.tileObject = tileObject;
		this.tileObjectHash = tileObjectHash(tileObject);
	}

	public long lightHash(int impostorId) {
		long hash = this.tileObjectHash;
		hash = hash * 31 + impostorId;
		return hash;
	}

	private static long tileObjectHash(@Nullable TileObject tileObject) {
		if (tileObject == null)
			return 0;

		LocalPoint lp = tileObject.getLocalLocation();
		long hash = lp.getX();
		hash = hash * 31 + lp.getY();
		hash = hash * 31 + tileObject.getPlane();
		hash = hash * 31 + tileObject.getId();
		return hash;
	}
}

package rs117.hd.scene.lights;

public enum Alignment
{
	CUSTOM(0, false, true),
	@Deprecated
	CENTER(0, false, false),

	NORTH(0, true, false),
	NORTHEAST(256, true, false),
	NORTHEAST_CORNER(256, false, false),
	EAST(512, true, false),
	SOUTHEAST(768, true, false),
	SOUTHEAST_CORNER(768, false, false),
	SOUTH(1024, true, false),
	SOUTHWEST(1280, true, false),
	SOUTHWEST_CORNER(1280, false, false),
	WEST(1536, true, false),
	NORTHWEST(1792, true, false),
	NORTHWEST_CORNER(1792, false, false),

	BACK(0, true, true),
	BACKLEFT(256, true, true),
	BACKLEFT_CORNER(256, false, true),
	LEFT(512, true, true),
	FRONTLEFT(768, true, true),
	FRONTLEFT_CORNER(768, false, true),
	FRONT(1024, true, true),
	FRONTRIGHT(1280, true, true),
	FRONTRIGHT_CORNER(1280, false, true),
	RIGHT(1536, true, true),
	BACKRIGHT(1792, true, true),
	BACKRIGHT_CORNER(1792, false, true);

	public final int orientation;
	public final boolean radial;
	public final boolean relative;

	Alignment(int orientation, boolean radial, boolean relative)
	{
		this.orientation = orientation;
		this.radial = radial;
		this.relative = relative;
	}
}

/*
 * Copyright (c) 2018, Adam <Adam@sigterm.info>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package rs117.hd.scene;

import java.awt.geom.AffineTransform;
import java.awt.image.AffineTransformOp;
import java.awt.image.BufferedImage;
import java.awt.image.DataBufferInt;
import java.nio.ByteBuffer;
import java.nio.IntBuffer;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.ScheduledFuture;
import java.util.concurrent.TimeUnit;
import javax.annotation.Nonnull;
import javax.annotation.Nullable;
import javax.inject.Inject;
import javax.inject.Singleton;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.*;
import net.runelite.client.callback.ClientThread;
import org.lwjgl.BufferUtils;
import org.lwjgl.opengl.*;
import rs117.hd.HdPlugin;
import rs117.hd.HdPluginConfig;
import rs117.hd.data.WaterType;
import rs117.hd.data.materials.Material;
import rs117.hd.utils.HDUtils;
import rs117.hd.utils.Props;
import rs117.hd.utils.ResourcePath;

import static org.lwjgl.opengl.GL43C.*;
import static rs117.hd.HdPlugin.SCALAR_BYTES;
import static rs117.hd.HdPlugin.TEXTURE_UNIT_GAME;
import static rs117.hd.HdPlugin.TEXTURE_UNIT_UI;
import static rs117.hd.utils.HDUtils.HALF_PI;
import static rs117.hd.utils.ResourcePath.path;

@Singleton
@Slf4j
public class TextureManager {
	private static final String[] SUPPORTED_IMAGE_EXTENSIONS = { "png", "jpg" };
	private static final ResourcePath TEXTURE_PATH = Props.getPathOrDefault(
		"rlhd.texture-path",
		() -> path(TextureManager.class, "textures")
	);

	@Inject
	private Client client;

	@Inject
	private ClientThread clientThread;

	@Inject
	private ScheduledExecutorService executorService;

	@Inject
	private HdPlugin plugin;

	@Inject
	private HdPluginConfig config;

	@Inject
	private ModelOverrideManager modelOverrideManager;

	private int textureArray;
	private int textureSize;

	// Temporary variables for texture loading and generating material uniforms
	private IntBuffer pixelBuffer;
	private BufferedImage scaledImage;
	private BufferedImage vanillaImage;
	private float[] vanillaTextureAnimations;
	private ArrayList<MaterialEntry> materialUniformEntries;
	private int[] materialOrdinalToTextureLayer;
	private int[] vanillaTextureIndexToTextureLayer;
	private ScheduledFuture<?> pendingReload;

	public void startUp() {
		clientThread.invoke(this::ensureMaterialsAreLoaded);

		TEXTURE_PATH.watch((path, first) -> {
			if (first) return;
			log.debug("Texture changed: {}", path);

			if (pendingReload == null || pendingReload.cancel(false) || pendingReload.isDone())
				pendingReload = executorService.schedule(this::reloadTextures, 100, TimeUnit.MILLISECONDS);
		});
	}

	public void shutDown() {
		clientThread.invoke(this::freeTextures);
	}

	public void reloadTextures() {
		clientThread.invoke(() -> {
			freeTextures();
			ensureMaterialsAreLoaded();
			modelOverrideManager.reload();
		});
	}

	private void freeTextures() {
		if (textureArray != 0)
			glDeleteTextures(textureArray);
		textureArray = 0;
	}

	@RequiredArgsConstructor
	private static class MaterialEntry {
		final Material material;
		final int vanillaIndex;
	}

	@RequiredArgsConstructor
	private static class TextureLayer {
		final Material material;
		final int vanillaIndex;
		final int index;
	}

	private final int[] materialOrdinalToMaterialUniformIndex = new int[Material.values().length];
	private int[] vanillaTextureIndexToMaterialUniformIndex = {};

	public int getMaterialIndex(@Nonnull Material material, int vanillaTextureIndex) {
		if (material == Material.VANILLA &&
			vanillaTextureIndex >= 0 &&
			vanillaTextureIndex < vanillaTextureIndexToMaterialUniformIndex.length)
			return vanillaTextureIndexToMaterialUniformIndex[vanillaTextureIndex];
		return materialOrdinalToMaterialUniformIndex[material.ordinal()];
	}

	public boolean vanillaTexturesAvailable() {
		var textureProvider = client.getTextureProvider();
		if (textureProvider == null)
			return false;

		Texture[] vanillaTextures = textureProvider.getTextures();
		if (vanillaTextures == null || vanillaTextures.length == 0)
			return false;

		// Ensure all textures are available
		for (int i = 0; i < vanillaTextures.length; i++) {
			var texture = vanillaTextures[i];
			if (texture != null) {
				int[] pixels = textureProvider.load(i);
				if (pixels == null)
					return false;
			}
		}

		return true;
	}

	private void ensureMaterialsAreLoaded() {
		if (textureArray != 0)
			return;

		assert vanillaTexturesAvailable();
		var textureProvider = client.getTextureProvider();
		Texture[] vanillaTextures = textureProvider.getTextures();
		Material.updateMappings(vanillaTextures, plugin);

		// Add material uniforms for all active material definitions
		materialUniformEntries = new ArrayList<>();
		for (var material : Material.getActiveMaterials())
			materialUniformEntries.add(new MaterialEntry(material, material.vanillaTextureIndex));

		// Add texture layers for each material that adds its own texture, after resolving replacements
		ArrayList<TextureLayer> textureLayers = new ArrayList<>();
		materialOrdinalToTextureLayer = new int[Material.values().length];
		Arrays.fill(materialOrdinalToTextureLayer, -1);
		for (var textureMaterial : Material.getTextureMaterials()) {
			int layerIndex = textureLayers.size();
			textureLayers.add(new TextureLayer(textureMaterial, textureMaterial.vanillaTextureIndex, layerIndex));
			materialOrdinalToTextureLayer[textureMaterial.ordinal()] = layerIndex;
		}

		// Prepare mappings for materials that don't provide their own textures
		for (var material : Material.values())
			if (materialOrdinalToTextureLayer[material.ordinal()] == -1)
				materialOrdinalToTextureLayer[material.ordinal()] =
					materialOrdinalToTextureLayer[material.resolveTextureMaterial().ordinal()];

		// Add material uniforms and texture layers for any vanilla textures lacking a material definition
		vanillaTextureIndexToTextureLayer = new int[vanillaTextures.length];
		Arrays.fill(vanillaTextureIndexToTextureLayer, -1);
		for (int i = 0; i < vanillaTextures.length; i++) {
			if (Material.fromVanillaTexture(i) == Material.VANILLA) {
				materialUniformEntries.add(new MaterialEntry(Material.VANILLA, i));
				int layerIndex = textureLayers.size();
				textureLayers.add(new TextureLayer(Material.VANILLA, i, layerIndex));
				vanillaTextureIndexToTextureLayer[i] = layerIndex;
			}
		}

		// Allocate texture array
		textureSize = config.textureResolution().getSize();
		textureArray = glGenTextures();
		glActiveTexture(TEXTURE_UNIT_GAME);
		glBindTexture(GL_TEXTURE_2D_ARRAY, textureArray);

		int mipLevels = 1 + (int) Math.floor(HDUtils.log2(textureSize));
		int format = GL_SRGB8_ALPHA8;
		if (plugin.glCaps.glTexStorage3D != 0) {
			glTexStorage3D(GL_TEXTURE_2D_ARRAY, mipLevels, format, textureSize, textureSize, textureLayers.size());
		} else {
			// Allocate each mip level separately
			for (int i = 0; i < mipLevels; i++) {
				int size = textureSize >> i;
				glTexImage3D(GL_TEXTURE_2D_ARRAY, i, format, size, size, textureLayers.size(), 0, GL_RGBA, GL_UNSIGNED_BYTE, 0);
			}
		}

		glTexParameteri(GL_TEXTURE_2D_ARRAY, GL_TEXTURE_WRAP_S, GL_REPEAT);
		glTexParameteri(GL_TEXTURE_2D_ARRAY, GL_TEXTURE_WRAP_T, GL_REPEAT);
		setAnisotropicFilteringLevel();

		log.debug("Allocated {}x{} texture array with {} layers", textureSize, textureSize, textureLayers.size());

		// Begin loading textures

		// Set brightness to 1.0d to upload unmodified textures to GPU
		double vanillaBrightness = textureProvider.getBrightness();
		textureProvider.setBrightness(1.0d);

		// Allocate resources for storing temporary image data
		pixelBuffer = BufferUtils.createIntBuffer(textureSize * textureSize);
		scaledImage = new BufferedImage(textureSize, textureSize, BufferedImage.TYPE_INT_ARGB);
		vanillaImage = new BufferedImage(128, 128, BufferedImage.TYPE_INT_ARGB);
		vanillaTextureAnimations = new float[vanillaTextures.length * 2];

		int vanillaTextureCount = 0;
		int hdTextureCount = 0;
		for (var textureLayer : textureLayers) {
			var material = textureLayer.material;

			BufferedImage image = null;
			// Check if HD provides a texture for the material
			if (material != Material.VANILLA) {
				image = loadTextureImage(material);
				if (image == null && material.vanillaTextureIndex == -1) {
					log.warn("No texture found for material: {}", material);
					continue;
				}
			}

			// Fallback to loading a vanilla image
			if (image == null) {
				int vanillaIndex = textureLayer.vanillaIndex;
				var texture = vanillaTextures[vanillaIndex];
				if (texture == null)
					continue;

				int[] pixels = textureProvider.load(vanillaIndex);
				if (pixels == null) {
					log.warn("No pixels for vanilla texture at index {}", vanillaIndex);
					continue;
				}
				int resolution = (int) Math.round(Math.sqrt(pixels.length));
				if (resolution * resolution != pixels.length) {
					log.warn("Unknown dimensions for vanilla texture at index {} ({} pixels)", vanillaIndex, pixels.length);
					continue;
				}

				for (int j = 0; j < pixels.length; j++) {
					int rgb = pixels[j];
					// Black is considered transparent in vanilla, with anything else being fully opaque
					int alpha = rgb == 0 ? 0 : 0xFF;
					vanillaImage.setRGB(j % 128, j / 128, alpha << 24 | rgb & 0xFFFFFF);
				}

				image = vanillaImage;
				vanillaTextureCount++;
			} else {
				hdTextureCount++;
			}

			try {
				uploadTexture(textureLayer, image);
			} catch (Exception ex) {
				log.error("Failed to load texture {}:", textureLayer.material, ex);
			}
		}

		// Convert vanilla texture animations to the same format as Material scroll parameters
		for (int i = 0; i < vanillaTextures.length; i++) {
			var texture = vanillaTextures[i];
			if (texture == null)
				continue;

			int direction = texture.getAnimationDirection();
			if (direction != 0) {
				float speed = texture.getAnimationSpeed() * 50 / 128.f;
				float radians = direction * -HALF_PI;
				vanillaTextureAnimations[i * 2] = (float) Math.cos(radians) * speed;
				vanillaTextureAnimations[i * 2 + 1] = (float) Math.sin(radians) * speed;
			}
		}

		log.debug("Loaded {} HD & {} vanilla textures", hdTextureCount, vanillaTextureCount);

		glGenerateMipmap(GL_TEXTURE_2D_ARRAY);

		vanillaTextureIndexToMaterialUniformIndex = new int[vanillaTextures.length];
		plugin.updateMaterialUniformBuffer(generateMaterialUniformBuffer());
		plugin.updateWaterTypeUniformBuffer(generateWaterTypeUniformBuffer());

		// Reset
		pixelBuffer = null;
		scaledImage = null;
		vanillaImage = null;
		vanillaTextureAnimations = null;
		materialUniformEntries = null;
		materialOrdinalToTextureLayer = null;
		vanillaTextureIndexToTextureLayer = null;
		textureProvider.setBrightness(vanillaBrightness);
		glActiveTexture(TEXTURE_UNIT_UI);
	}

	private BufferedImage loadTextureImage(Material material) {
		String textureName = material.name().toLowerCase();
		for (String ext : SUPPORTED_IMAGE_EXTENSIONS) {
			ResourcePath path = TEXTURE_PATH.resolve(textureName + "." + ext);
			try {
				return path.loadImage();
			} catch (Exception ex) {
				log.trace("Unable to load texture: {}", path, ex);
			}
		}

		return null;
	}

	private void uploadTexture(TextureLayer layer, BufferedImage image) {
		// TODO: scale and transform on the GPU for better performance
		AffineTransform t = new AffineTransform();
		if (image != vanillaImage) {
			// Flip non-vanilla textures horizontally to match vanilla UV orientation
			t.translate(textureSize, 0);
			t.scale(-1, 1);
		}
		t.scale((double) textureSize / image.getWidth(), (double) textureSize / image.getHeight());
		AffineTransformOp scaleOp = new AffineTransformOp(t, AffineTransformOp.TYPE_BICUBIC);
		scaleOp.filter(image, scaledImage);

		int[] pixels = ((DataBufferInt) scaledImage.getRaster().getDataBuffer()).getData();
		pixelBuffer.put(pixels).flip();

		// Go from TYPE_4BYTE_ABGR in the BufferedImage to RGBA
		glTexSubImage3D(GL_TEXTURE_2D_ARRAY, 0, 0, 0,
			layer.index, textureSize, textureSize, 1,
			GL_BGRA, GL_UNSIGNED_INT_8_8_8_8_REV, pixelBuffer
		);
	}

	private void setAnisotropicFilteringLevel() {
		int level = config.anisotropicFilteringLevel();
		if (level == 0) {
			//level = 0 means no mipmaps and no anisotropic filtering
			glTexParameteri(GL_TEXTURE_2D_ARRAY, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
			glTexParameteri(GL_TEXTURE_2D_ARRAY, GL_TEXTURE_MAG_FILTER, GL_NEAREST);
		} else {
			// level = 1 means with mipmaps but without anisotropic filtering GL_MAX_TEXTURE_MAX_ANISOTROPY_EXT defaults to 1.0 which is off
			// level > 1 enables anisotropic filtering. It's up to the vendor what the values mean
			// Even if anisotropic filtering isn't supported, mipmaps will be enabled with any level >= 1
			// Trilinear filtering is used for HD textures as linear filtering produces noisy textures
			// that are very noticeable on terrain
			glTexParameteri(GL_TEXTURE_2D_ARRAY, GL_TEXTURE_MIN_FILTER, GL_LINEAR_MIPMAP_LINEAR);
			glTexParameteri(GL_TEXTURE_2D_ARRAY, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
		}

		if (GL.getCapabilities().GL_EXT_texture_filter_anisotropic) {
			final float maxSamples = glGetFloat(EXTTextureFilterAnisotropic.GL_MAX_TEXTURE_MAX_ANISOTROPY_EXT);
			//Clamp from 1 to max GL says it supports.
			final float anisoLevel = Math.max(1, Math.min(maxSamples, level));
			glTexParameterf(GL_TEXTURE_2D_ARRAY, EXTTextureFilterAnisotropic.GL_TEXTURE_MAX_ANISOTROPY_EXT, anisoLevel);
		}
	}

	private ByteBuffer generateMaterialUniformBuffer() {
		final int materialBytes = 20 * SCALAR_BYTES;
		ByteBuffer buffer = BufferUtils.createByteBuffer(materialUniformEntries.size() * materialBytes);
		for (int i = 0; i < materialUniformEntries.size(); i++) {
			MaterialEntry entry = materialUniformEntries.get(i);
			materialOrdinalToMaterialUniformIndex[entry.material.ordinal()] = i;
			if (entry.vanillaIndex != -1)
				vanillaTextureIndexToMaterialUniformIndex[entry.vanillaIndex] = i;
			writeMaterialData(buffer, entry);
		}
		for (var material : Material.values())
			materialOrdinalToMaterialUniformIndex[material.ordinal()] =
				materialOrdinalToMaterialUniformIndex[material.resolveReplacements().ordinal()];
		return buffer.flip();
	}

	private int getTextureLayer(@Nullable Material material) {
		if (material == null)
			return -1;
		material = material.resolveTextureMaterial();
		return materialOrdinalToTextureLayer[material.ordinal()];
	}

	private void writeMaterialData(ByteBuffer buffer, MaterialEntry entry) {
		var m = entry.material;
		var vanillaIndex = entry.vanillaIndex;

		float scrollSpeedX = m.scrollSpeed[0];
		float scrollSpeedY = m.scrollSpeed[1];
		if (vanillaIndex != -1) {
			scrollSpeedX += vanillaTextureAnimations[vanillaIndex * 2];
			scrollSpeedY += vanillaTextureAnimations[vanillaIndex * 2 + 1];
		}

		int baseColorTextureIndex = -1;
		if (m == Material.VANILLA) {
			baseColorTextureIndex = vanillaTextureIndexToTextureLayer[vanillaIndex];
		} else if (m != Material.NONE) {
			baseColorTextureIndex = materialOrdinalToTextureLayer[m.ordinal()];
		}

		buffer
			.putInt(baseColorTextureIndex)
			.putInt(getTextureLayer(m.normalMap))
			.putInt(getTextureLayer(m.displacementMap))
			.putInt(getTextureLayer(m.roughnessMap))
			.putInt(getTextureLayer(m.ambientOcclusionMap))
			.putInt(getTextureLayer(m.flowMap))
			.putInt(
				(m.overrideBaseColor ? 1 : 0) << 2 |
				(m.unlit ? 1 : 0) << 1 |
				(m.hasTransparency ? 1 : 0)
			)
			.putFloat(m.brightness)
			.putFloat(m.displacementScale)
			.putFloat(m.specularStrength)
			.putFloat(m.specularGloss)
			.putFloat(m.flowMapStrength)
			.putFloat(m.flowMapDuration[0])
			.putFloat(m.flowMapDuration[1])
			.putFloat(scrollSpeedX)
			.putFloat(scrollSpeedY)
			.putFloat(1 / m.textureScale[0])
			.putFloat(1 / m.textureScale[1])
			.putFloat(1 / m.textureScale[2])
			.putFloat(0); // align vec4
	}

	private ByteBuffer generateWaterTypeUniformBuffer() {
		ByteBuffer buffer = BufferUtils.createByteBuffer(WaterType.values().length * 28 * SCALAR_BYTES);
		for (WaterType type : WaterType.values())
			buffer
				.putInt(type.flat ? 1 : 0)
				.putFloat(type.specularStrength)
				.putFloat(type.specularGloss)
				.putFloat(type.normalStrength)
				.putFloat(type.baseOpacity)
				.putInt(type.hasFoam ? 1 : 0)
				.putFloat(type.duration)
				.putFloat(type.fresnelAmount)
				.putFloat(type.surfaceColor[0])
				.putFloat(type.surfaceColor[1])
				.putFloat(type.surfaceColor[2])
				.putFloat(0) // pad vec4
				.putFloat(type.foamColor[0])
				.putFloat(type.foamColor[1])
				.putFloat(type.foamColor[2])
				.putFloat(0) // pad vec4
				.putFloat(type.depthColor[0])
				.putFloat(type.depthColor[1])
				.putFloat(type.depthColor[2])
				.putFloat(0) // pad vec4
				.putFloat(type.causticsStrength)
				.putInt(getTextureLayer(type.normalMap))
				.putInt(getTextureLayer(Material.WATER_FOAM))
				.putInt(getTextureLayer(Material.WATER_FLOW_MAP))
				.putInt(getTextureLayer(Material.UNDERWATER_FLOW_MAP))
				.putFloat(0).putFloat(0).putFloat(0); // pad vec4
		return buffer.flip();
	}
}

package rs117.hd.scene;

import java.io.IOException;
import java.util.HashMap;
import java.util.Objects;
import javax.annotation.Nonnull;
import javax.annotation.Nullable;
import javax.inject.Inject;
import javax.inject.Singleton;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.*;
import net.runelite.client.callback.ClientThread;
import rs117.hd.HdPlugin;
import rs117.hd.model.ModelPusher;
import rs117.hd.scene.model_overrides.ModelOverride;
import rs117.hd.utils.FileWatcher;
import rs117.hd.utils.ModelHash;
import rs117.hd.utils.Props;
import rs117.hd.utils.ResourcePath;

import static rs117.hd.utils.ResourcePath.path;

@Singleton
@Slf4j
public class ModelOverrideManager {
	private static final ResourcePath MODEL_OVERRIDES_PATH = Props.getPathOrDefault(
		"rlhd.model-overrides-path",
		() -> path(ModelOverrideManager.class, "model_overrides.json")
	);

	@Inject
	private Client client;

	@Inject
	private ClientThread clientThread;

	@Inject
	private HdPlugin plugin;

	@Inject
	private ModelPusher modelPusher;

	@Inject
	private FishingSpotReplacer fishingSpotReplacer;

	private final HashMap<Integer, ModelOverride> modelOverrides = new HashMap<>();

	private FileWatcher.UnregisterCallback fileWatcher;

	public void startUp() {
		fileWatcher = MODEL_OVERRIDES_PATH.watch((path, first) -> {
			modelOverrides.clear();

			try {
				ModelOverride[] entries = path.loadJson(plugin.getGson(), ModelOverride[].class);
				if (entries == null)
					throw new IOException("Empty or invalid: " + path);
				for (ModelOverride override : entries) {
					try {
						override.normalize(plugin.configVanillaShadowMode);
					} catch (IllegalStateException ex) {
						log.error("Invalid model override '{}': {}", override.description, ex.getMessage());
						continue;
					}

					addOverride(override);

					if (override.hideInAreas.length > 0) {
						var hider = override.copy();
						hider.hide = true;
						hider.areas = override.hideInAreas;
						addOverride(hider);
					}
				}

				log.debug("Loaded {} model overrides", modelOverrides.size());
			} catch (IOException ex) {
				log.error("Failed to load model overrides:", ex);
			}

			addOverride(fishingSpotReplacer.getModelOverride());

			if (!first) {
				clientThread.invoke(() -> {
					modelPusher.clearModelCache();
					if (client.getGameState() == GameState.LOGGED_IN)
						client.setGameState(GameState.LOADING);
				});
			}
		});
	}

	public void shutDown() {
		if (fileWatcher != null)
			fileWatcher.unregister();
		fileWatcher = null;

		modelOverrides.clear();
	}

	public void reload() {
		shutDown();
		startUp();
	}

	private void addOverride(@Nullable ModelOverride override) {
		if (override == null || override.seasonalTheme != null && override.seasonalTheme != plugin.configSeasonalTheme)
			return;

		for (int id : override.npcIds)
			addEntry(ModelHash.TYPE_NPC, id, override);
		for (int id : override.objectIds)
			addEntry(ModelHash.TYPE_OBJECT, id, override);
		for (int id : override.projectileIds)
			addEntry(ModelHash.TYPE_PROJECTILE, id, override);
		for (int id : override.graphicsObjectIds)
			addEntry(ModelHash.TYPE_GRAPHICS_OBJECT, id, override);
	}

	private void addEntry(int type, int id, ModelOverride entry) {
		int uuid = ModelHash.packUuid(type, id);
		ModelOverride current = modelOverrides.get(uuid);

		if (current != null && !Objects.equals(current.seasonalTheme, entry.seasonalTheme)) {
			// Seasonal theme overrides should take precedence
			if (current.seasonalTheme != null)
				return;
			current = null;
		}

		boolean isDuplicate = false;

		if (entry.areas.length == 0) {
			// Non-area-restricted override, of which there can only be one per UUID

			// A dummy override is used as the base if only area-specific overrides exist
			isDuplicate = current != null && !current.isDummy;

			if (current != null && current.areaOverrides != null && !current.areaOverrides.isEmpty()) {
				var areaOverrides = current.areaOverrides;
				current = entry.copy();
				current.areaOverrides = areaOverrides;
			} else {
				current = entry;
			}

			modelOverrides.put(uuid, current);
		} else {
			if (current == null)
				current = ModelOverride.NONE;

			if (current.areaOverrides == null) {
				// We need to replace the override with a copy that has a separate list of area overrides to avoid conflicts
				current = current.copy();
				current.areaOverrides = new HashMap<>();
				modelOverrides.put(uuid, current);
			}

			for (var area : entry.areas)
				current.areaOverrides.put(area, entry);
		}

		if (isDuplicate && Props.DEVELOPMENT) {
			// This should ideally not be reached, so print helpful warnings in development mode
			if (entry.hideInAreas.length > 0) {
				log.error(
					"Replacing ID {} from '{}' with hideInAreas-override '{}'. This is likely a mistake...\n",
					id, current.description, entry.description
				);
			} else {
				log.error(
					"Replacing ID {} from '{}' with '{}'. The first-mentioned override should be removed.\n",
					id, current.description, entry.description
				);
			}
		}
	}

	@Nonnull
	public ModelOverride getOverride(int uuid, int[] worldPos) {
		var override = modelOverrides.get(uuid);
		if (override == null)
			return ModelOverride.NONE;

		if (override.areaOverrides != null)
			for (var entry : override.areaOverrides.entrySet())
				if (entry.getKey().contains(worldPos))
					return entry.getValue();

		return override;
	}
}

/*
 * Copyright (c) 2019 Abex
 * Copyright (c) 2021, 117 <https://twitter.com/117scape>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package rs117.hd.scene;

import com.google.common.collect.ArrayListMultimap;
import com.google.common.collect.ListMultimap;
import com.google.gson.Gson;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashSet;
import java.util.List;
import java.util.function.Predicate;
import javax.annotation.Nonnull;
import javax.annotation.Nullable;
import javax.inject.Inject;
import javax.inject.Singleton;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.*;
import net.runelite.api.coords.*;
import net.runelite.api.events.*;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.eventbus.EventBus;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.plugins.PluginManager;
import net.runelite.client.plugins.entityhider.EntityHiderConfig;
import net.runelite.client.plugins.entityhider.EntityHiderPlugin;
import rs117.hd.HdPlugin;
import rs117.hd.HdPluginConfig;
import rs117.hd.config.MaxDynamicLights;
import rs117.hd.overlays.FrameTimer;
import rs117.hd.overlays.Timer;
import rs117.hd.scene.lights.Alignment;
import rs117.hd.scene.lights.Light;
import rs117.hd.scene.lights.LightDefinition;
import rs117.hd.scene.lights.LightType;
import rs117.hd.scene.lights.TileObjectImpostorTracker;
import rs117.hd.utils.HDUtils;
import rs117.hd.utils.ModelHash;
import rs117.hd.utils.Props;
import rs117.hd.utils.ResourcePath;

import static java.lang.Math.abs;
import static java.lang.Math.cos;
import static java.lang.Math.pow;
import static net.runelite.api.Constants.*;
import static net.runelite.api.Perspective.*;
import static rs117.hd.utils.HDUtils.TWO_PI;
import static rs117.hd.utils.HDUtils.fract;
import static rs117.hd.utils.HDUtils.mod;
import static rs117.hd.utils.ResourcePath.path;

@Singleton
@Slf4j
public class LightManager {
	private static final ResourcePath LIGHTS_PATH = Props.getPathOrDefault(
		"rlhd.lights-path",
		() -> path(LightManager.class, "lights.json")
	);

	@Inject
	private Client client;

	@Inject
	private EventBus eventBus;

	@Inject
	private PluginManager pluginManager;

	@Inject
	private ConfigManager configManager;

	@Inject
	private HdPlugin plugin;

	@Inject
	private HdPluginConfig config;

	@Inject
	private ModelOverrideManager modelOverrideManager;

	@Inject
	private EntityHiderPlugin entityHiderPlugin;

	@Inject
	private FrameTimer frameTimer;

	private final ArrayList<Light> WORLD_LIGHTS = new ArrayList<>();
	private final ListMultimap<Integer, LightDefinition> NPC_LIGHTS = ArrayListMultimap.create();
	private final ListMultimap<Integer, LightDefinition> OBJECT_LIGHTS = ArrayListMultimap.create();
	private final ListMultimap<Integer, LightDefinition> PROJECTILE_LIGHTS = ArrayListMultimap.create();
	private final ListMultimap<Integer, LightDefinition> SPOT_ANIM_LIGHTS = ArrayListMultimap.create();

	private boolean reloadLights;
	private EntityHiderConfig entityHiderConfig;

	public void loadConfig(Gson gson, ResourcePath path) {
		try {
			LightDefinition[] lights;
			try {
				lights = path.loadJson(gson, LightDefinition[].class);
				if (lights == null) {
					log.warn("Skipping empty lights.json");
					return;
				}
			} catch (IOException ex) {
				log.error("Failed to load lights", ex);
				return;
			}

			WORLD_LIGHTS.clear();
			NPC_LIGHTS.clear();
			OBJECT_LIGHTS.clear();
			PROJECTILE_LIGHTS.clear();
			SPOT_ANIM_LIGHTS.clear();

			for (LightDefinition lightDef : lights) {
				lightDef.normalize();
				if (lightDef.worldX != null && lightDef.worldY != null) {
					Light light = new Light(lightDef);
					light.worldPoint = new WorldPoint(lightDef.worldX, lightDef.worldY, lightDef.plane);
					light.persistent = true;
					WORLD_LIGHTS.add(light);
				}
				lightDef.npcIds.forEach(id -> NPC_LIGHTS.put(id, lightDef));
				lightDef.objectIds.forEach(id -> OBJECT_LIGHTS.put(id, lightDef));
				lightDef.projectileIds.forEach(id -> PROJECTILE_LIGHTS.put(id, lightDef));
				lightDef.spotAnimIds.forEach(id -> SPOT_ANIM_LIGHTS.put(id, lightDef));
			}

			log.debug("Loaded {} lights", lights.length);

			// Reload lights once on plugin startup, and whenever lights.json should be hot-swapped.
			// If we don't reload on startup, NPCs won't have lights added until RuneLite fires events
			reloadLights = true;
		} catch (Exception ex) {
			log.error("Failed to parse light configuration", ex);
		}
	}

	public void startUp() {
		entityHiderConfig = configManager.getConfig(EntityHiderConfig.class);
		LIGHTS_PATH.watch(path -> loadConfig(plugin.getGson(), path));
		eventBus.register(this);
	}

	public void shutDown() {
		eventBus.unregister(this);
	}

	public void update(@Nonnull SceneContext sceneContext) {
		assert client.isClientThread();

		if (client.getGameState() != GameState.LOGGED_IN || config.maxDynamicLights() == MaxDynamicLights.NONE) {
			sceneContext.numVisibleLights = 0;
			return;
		}

		if (reloadLights) {
			reloadLights = false;
			loadSceneLights(sceneContext, null);

			client.getNpcs().forEach(npc -> {
				addNpcLights(npc);
				addSpotAnimLights(npc);
			});
		}

		// These should never occur, but just in case...
		if (sceneContext.knownProjectiles.size() > 10000) {
			log.warn("Too many projectiles tracked: {}. Clearing...", sceneContext.knownProjectiles.size());
			sceneContext.knownProjectiles.clear();
		}
		if (sceneContext.lights.size() > 10000) {
			log.warn("Too many lights: {}. Clearing...", sceneContext.lights.size());
			sceneContext.lights.clear();
		}

		int drawDistance = plugin.getDrawDistance() * LOCAL_TILE_SIZE;
		Tile[][][] tiles = sceneContext.scene.getExtendedTiles();
		int[][][] tileHeights = sceneContext.scene.getTileHeights();
		var cachedNpcs = client.getTopLevelWorldView().npcs();
		var cachedPlayers = client.getTopLevelWorldView().players();

		for (Light light : sceneContext.lights) {
			// Ways lights may get deleted:
			// - animation-specific:
			//   effectively spawn when the animation they're attached to starts playing, and despawns when it stops,
			//   but they are typically replayable, so they don't fully despawn until marked for removal by something else
			// - spotanim & projectile lights:
			//   automatically marked for removal upon completion
			// - actor lights:
			//   may be automatically marked for removal if the actor becomes invalid
			// - other lights:
			//   despawn when marked for removal by a RuneLite despawn event
			// - fixed lifetime && !replayable:
			//   All non-replayable lights with a fixed lifetime will be automatically marked for removal when done playing

			// Light fade-in and fade-out are based on whether the parent currently exists
			// Additionally, lights have an overruling fade-out when being deprioritized

			// Whatever the light is attached to is presumed to exist if it's not marked for removal yet
			boolean parentExists = !light.markedForRemoval;
			boolean hiddenTemporarily = false;
			light.orientation = 0;

			if (light.tileObject != null) {
				if (!light.markedForRemoval && light.animationSpecific && light.tileObject instanceof GameObject) {
					int animationId = -1;
					var renderable = ((GameObject) light.tileObject).getRenderable();
					if (renderable instanceof DynamicObject) {
						var anim = ((DynamicObject) renderable).getAnimation();
						if (anim != null)
							animationId = anim.getId();
					}
					parentExists = light.def.animationIds.contains(animationId);
				}
			} else if (light.projectile != null) {
				light.origin[0] = (int) light.projectile.getX();
				light.origin[1] = (int) light.projectile.getZ() - light.def.height;
				light.origin[2] = (int) light.projectile.getY();
				if (light.projectile.getRemainingCycles() <= 0) {
					light.markedForRemoval = true;
				} else {
					hiddenTemporarily = !shouldShowProjectileLights();
					if (light.animationSpecific) {
						var animation = light.projectile.getAnimation();
						parentExists = animation != null && light.def.animationIds.contains(animation.getId());
					}
					light.orientation = (int) Math.round(
						Math.atan2(light.projectile.getVelocityZ(), light.projectile.getVelocityX()) / UNIT);
				}
			} else if (light.graphicsObject != null) {
				light.origin[0] = light.graphicsObject.getLocation().getX();
				light.origin[1] = light.graphicsObject.getZ() - light.def.height;
				light.origin[2] = light.graphicsObject.getLocation().getY();
				if (light.graphicsObject.finished()) {
					light.markedForRemoval = true;
				} else if (light.animationSpecific) {
					var animation = light.graphicsObject.getAnimation();
					parentExists = animation != null && light.def.animationIds.contains(animation.getId());
				}
			} else if (light.actor != null && !light.markedForRemoval) {
				if (light.actor instanceof NPC && light.actor != cachedNpcs.byIndex(((NPC) light.actor).getIndex()) ||
					light.actor instanceof Player && light.actor != cachedPlayers.byIndex(((Player) light.actor).getId()) ||
					light.spotAnimId != -1 && !light.actor.hasSpotAnim(light.spotAnimId)
				) {
					parentExists = false;
					light.markedForRemoval = true;
				} else {
					var lp = light.actor.getLocalLocation();
					light.origin[0] = lp.getX();
					light.origin[2] = lp.getY();
					int plane = client.getPlane();
					light.plane = plane;
					light.orientation = light.actor.getCurrentOrientation();

					if (light.animationSpecific)
						parentExists = light.def.animationIds.contains(light.actor.getAnimation());

					int tileExX = light.origin[0] / LOCAL_TILE_SIZE + SceneUploader.SCENE_OFFSET;
					int tileExY = light.origin[2] / LOCAL_TILE_SIZE + SceneUploader.SCENE_OFFSET;

					// Some NPCs, such as Crystalline Hunllef in The Gauntlet, sometimes return scene X/Y values far outside the possible range.
					Tile tile;
					if (tileExX >= 0 && tileExY >= 0 &&
						tileExX < EXTENDED_SCENE_SIZE && tileExY < EXTENDED_SCENE_SIZE &&
						(tile = tiles[plane][tileExX][tileExY]) != null
					) {
						// Check if the actor is hidden by another actor on the same tile
						for (var gameObject : tile.getGameObjects()) {
							if (gameObject == null || !(gameObject.getRenderable() instanceof Actor))
								continue;

							// Assume only the first actor at the same exact location will be rendered
							if (gameObject.getX() == light.origin[0] && gameObject.getY() == light.origin[2]) {
								hiddenTemporarily = gameObject.getRenderable() != light.actor;
								break;
							}
						}

						if (!hiddenTemporarily)
							hiddenTemporarily = !isActorLightVisible(light.actor);

						if (tileExX != light.prevTileX || tileExY != light.prevTileY) {
							light.prevTileX = tileExX;
							light.prevTileY = tileExY;

							// Tile null check is to prevent oddities caused by - once again - Crystalline Hunllef.
							// May also apply to other NPCs in instances.
							if (tile.getBridge() != null)
								plane++;

							// Interpolate between tile heights based on specific scene coordinates
							float lerpX = (light.origin[0] % LOCAL_TILE_SIZE) / (float) LOCAL_TILE_SIZE;
							float lerpY = (light.origin[2] % LOCAL_TILE_SIZE) / (float) LOCAL_TILE_SIZE;
							int baseTileX =
								(int) Math.floor(light.origin[0] / (float) LOCAL_TILE_SIZE) + SceneUploader.SCENE_OFFSET;
							int baseTileY =
								(int) Math.floor(light.origin[2] / (float) LOCAL_TILE_SIZE) + SceneUploader.SCENE_OFFSET;
							float heightNorth = HDUtils.lerp(
								tileHeights[plane][baseTileX][baseTileY + 1],
								tileHeights[plane][baseTileX + 1][baseTileY + 1],
								lerpX
							);
							float heightSouth = HDUtils.lerp(
								tileHeights[plane][baseTileX][baseTileY],
								tileHeights[plane][baseTileX + 1][baseTileY],
								lerpX
							);
							float tileHeight = HDUtils.lerp(heightSouth, heightNorth, lerpY);
							light.origin[1] = (int) tileHeight - 1 - light.def.height;
						}
					}
				}
			}

			light.pos[0] = light.origin[0];
			light.pos[1] = light.origin[1];
			light.pos[2] = light.origin[2];

			if (light.alignment.relative) {
				light.orientation += light.preOrientation;
				light.orientation += light.alignment.orientation;
			} else {
				light.orientation = 0;
			}
			light.orientation = HDUtils.mod(light.orientation, 2048);

			if (light.alignment == Alignment.CUSTOM) {
				// orientation 0 = south
				int sin = SINE[light.orientation];
				int cos = COSINE[light.orientation];
				int x = light.offset[0];
				int z = light.offset[2];
				light.pos[0] += -cos * x - sin * z >> 16;
				light.pos[1] += light.offset[1];
				light.pos[2] += -cos * z + sin * x >> 16;
			} else {
				int localSizeX = light.sizeX * LOCAL_TILE_SIZE;
				int localSizeY = light.sizeY * LOCAL_TILE_SIZE;

				float radius = localSizeX / 2f;
				if (!light.alignment.radial)
					radius = (float) Math.sqrt(localSizeX * localSizeX + localSizeX * localSizeX) / 2;

				float sine = SINE[light.orientation] / 65536f;
				float cosine = COSINE[light.orientation] / 65536f;
				cosine /= (float) localSizeX / (float) localSizeY;

				int offsetX = (int) (radius * sine);
				int offsetY = (int) (radius * cosine);

				light.pos[0] += offsetX;
				light.pos[2] += offsetY;
			}

			// This is a little bit slow, so only update it when necessary
			if (light.prevPlane != light.plane) {
				light.prevPlane = light.plane;
				light.belowFloor = false;
				light.aboveFloor = false;
				int tileExX = light.pos[0] / LOCAL_TILE_SIZE + SceneUploader.SCENE_OFFSET;
				int tileExY = light.pos[2] / LOCAL_TILE_SIZE + SceneUploader.SCENE_OFFSET;
				if (light.plane >= 0 && tileExX >= 0 && tileExY >= 0 && tileExX < EXTENDED_SCENE_SIZE && tileExY < EXTENDED_SCENE_SIZE) {
					Tile tileAbove = light.plane < 3 ? tiles[light.plane + 1][tileExX][tileExY] : null;
					if (tileAbove != null && (tileAbove.getSceneTilePaint() != null || tileAbove.getSceneTileModel() != null))
						light.belowFloor = true;

					Tile lightTile = tiles[light.plane][tileExX][tileExY];
					if (lightTile != null && (lightTile.getSceneTilePaint() != null || lightTile.getSceneTileModel() != null))
						light.aboveFloor = true;
				}
			}

			if (!hiddenTemporarily && !light.def.visibleFromOtherPlanes) {
				// Hide certain lights on planes lower than the player to prevent light 'leaking' through the floor
				if (light.plane < client.getPlane() && light.belowFloor)
					hiddenTemporarily = true;
				// Hide any light that is above the current plane and is above a solid floor
				if (light.plane > client.getPlane() && light.aboveFloor)
					hiddenTemporarily = true;
			}

			if (parentExists != light.parentExists) {
				light.parentExists = parentExists;
				if (parentExists) {
					// Reset the light if it's replayable and the parent just spawned
					if (light.replayable) {
						light.elapsedTime = 0;
						if (light.dynamicLifetime)
							light.lifetime = -1;
					}
				} else if (light.lifetime == -1) {
					// Schedule despawning of the light if the parent just despawned, and the light isn't already scheduled to despawn
					float minLifetime = light.spawnDelay + light.fadeInDuration;
					light.lifetime = Math.max(minLifetime, light.elapsedTime) + light.despawnDelay;
				}
			}

			if (hiddenTemporarily != light.hiddenTemporarily)
				light.toggleTemporaryVisibility();

			light.elapsedTime += plugin.deltaClientTime;

			light.visible = light.spawnDelay < light.elapsedTime && (light.lifetime == -1 || light.elapsedTime < light.lifetime);

			// If the light is temporarily hidden, keep it visible only while fading out
			if (light.visible && light.hiddenTemporarily)
				light.visible = light.changedVisibilityAt != -1 && light.elapsedTime - light.changedVisibilityAt < Light.VISIBILITY_FADE;

			if (light.visible) {
				// Hide lights which cannot possibly affect the visible scene
				int distFromCamera = (int) Math.max(
					Math.abs(plugin.cameraPosition[0] - light.pos[0]),
					Math.abs(plugin.cameraPosition[2] - light.pos[2])
				) - light.radius;
				if (distFromCamera > drawDistance)
					light.visible = false;
			}

			if (light.visible) {
				// Calculate the distance between the player and the light to determine which
				// lights to display based on the 'max dynamic lights' config option
				int distX = plugin.cameraFocalPoint[0] - light.pos[0];
				int distZ = plugin.cameraFocalPoint[1] - light.pos[2];
				light.distanceSquared = distX * distX + distZ * distZ + light.pos[1] * light.pos[1];
			}
		}

		// Order visible lights first, and by distance. Leave hidden lights unordered at the end.
		sceneContext.lights.sort((a, b) -> {
			// -1 = move a left of b
			if (a.visible && b.visible)
				return a.distanceSquared - b.distanceSquared;
			if (!a.visible && !b.visible)
				return 0;
			return a.visible ? -1 : 1;
		});

		// Count number of visible lights
		sceneContext.numVisibleLights = 0;
		for (Light light : sceneContext.lights) {
			// Exit early once encountering the first invisible light, or the light limit is reached
			if (!light.visible || sceneContext.numVisibleLights >= plugin.configMaxDynamicLights)
				break;

			sceneContext.numVisibleLights++;

			// If the light was temporarily hidden, begin fading in
			if (!light.withinViewingDistance && light.hiddenTemporarily)
				light.toggleTemporaryVisibility();
			light.withinViewingDistance = true;

			if (light.def.type == LightType.FLICKER) {
				double t = TWO_PI * (mod(plugin.elapsedTime, 60) / 60 + light.randomOffset);
				float flicker = (float) (
					pow(cos(11 * t), 3) +
					pow(cos(17 * t), 6) +
					pow(cos(23 * t), 2) +
					pow(cos(31 * t), 6) +
					pow(cos(71 * t), 4) +
					pow(cos(151 * t), 6) / 2
				) / 4.335f;

				float maxFlicker = 1f + (light.def.range / 100f);
				float minFlicker = 1f - (light.def.range / 100f);

				flicker = minFlicker + (maxFlicker - minFlicker) * flicker;

				light.strength = light.def.strength * flicker;
				light.radius = (int) (light.def.radius * 1.5f);
			} else if (light.def.type == LightType.PULSE) {
				light.animation = fract(light.animation + plugin.deltaClientTime / light.duration);

				float output = 1 - 2 * abs(light.animation - .5f);
				float range = light.def.range / 100f;
				float fullRange = range * 2f;
				float multiplier = (1.0f - range) + output * fullRange;

				light.radius = (int) (light.def.radius * multiplier);
				light.strength = light.def.strength * multiplier;
			} else {
				light.strength = light.def.strength;
				light.radius = light.def.radius;
				light.color = light.def.color;
			}

			// Spawn & despawn fade-in and fade-out
			if (light.fadeInDuration > 0)
				light.strength *= HDUtils.clamp((light.elapsedTime - light.spawnDelay) / light.fadeInDuration, 0, 1);
			if (light.fadeOutDuration > 0 && light.lifetime != -1)
				light.strength *= HDUtils.clamp((light.lifetime - light.elapsedTime) / light.fadeOutDuration, 0, 1);

			light.applyTemporaryVisibilityFade();
		}

		for (int i = sceneContext.lights.size() - 1; i >= sceneContext.numVisibleLights; i--) {
			Light light = sceneContext.lights.get(i);
			light.withinViewingDistance = false;

			// Automatically despawn non-replayable fixed lifetime lights when they expire
			if (!light.replayable && light.lifetime != -1 && light.lifetime < light.elapsedTime)
				light.markedForRemoval = true;

			if (light.markedForRemoval) {
				sceneContext.lights.remove(i);
				if (light.projectile != null && --light.projectileRefCounter[0] == 0)
					sceneContext.knownProjectiles.remove(light.projectile);
			}
		}
	}

	private boolean isActorLightVisible(@Nonnull Actor actor) {
		try {
			// getModel may throw an exception from vanilla client code
			if (actor.getModel() == null)
				return false;
		} catch (Exception ex) {
			// Vanilla handles exceptions thrown in `DrawCallbacks#draw` gracefully, but here we have to handle them
			return false;
		}

		boolean entityHiderEnabled = pluginManager.isPluginEnabled(entityHiderPlugin);

		if (actor instanceof NPC) {
			if (!plugin.configNpcLights)
				return false;

			if (entityHiderEnabled) {
				var npc = (NPC) actor;
				boolean isPet = npc.getComposition().isFollower();

				if (client.getFollower() != null && client.getFollower().getIndex() == npc.getIndex())
					return true;

				if (entityHiderConfig.hideNPCs() && !isPet)
					return false;

				return !entityHiderConfig.hidePets() || !isPet;
			}
		} else if (actor instanceof Player) {
			if (entityHiderEnabled) {
				var player = (Player) actor;
				Player local = client.getLocalPlayer();
				if (local == null || player.getName() == null)
					return true;

				if (player == local)
					return !entityHiderConfig.hideLocalPlayer();

				if (entityHiderConfig.hideAttackers() && player.getInteracting() == local)
					return false;

				if (player.isFriend())
					return !entityHiderConfig.hideFriends();
				if (player.isFriendsChatMember())
					return !entityHiderConfig.hideFriendsChatMembers();
				if (player.isClanMember())
					return !entityHiderConfig.hideClanChatMembers();
				if (client.getIgnoreContainer().findByName(player.getName()) != null)
					return !entityHiderConfig.hideIgnores();

				return !entityHiderConfig.hideOthers();
			}
		}

		return true;
	}

	private boolean shouldShowProjectileLights() {
		return plugin.configProjectileLights && !(pluginManager.isPluginEnabled(entityHiderPlugin) && entityHiderConfig.hideProjectiles());
	}

	public void loadSceneLights(SceneContext sceneContext, @Nullable SceneContext oldSceneContext)
	{
		assert client.isClientThread();

		if (oldSceneContext == null) {
			sceneContext.lights.clear();
			sceneContext.trackedTileObjects.clear();
			sceneContext.trackedVarps.clear();
			sceneContext.trackedVarbits.clear();
			sceneContext.knownProjectiles.clear();
		} else {
			// Copy over NPC and projectile lights from the old scene
			ArrayList<Light> lightsToKeep = new ArrayList<>();
			for (Light light : oldSceneContext.lights)
				if (light.actor != null || light.projectile != null)
					lightsToKeep.add(light);

			sceneContext.lights.addAll(lightsToKeep);
			for (var light : lightsToKeep)
				if (light.projectile != null && oldSceneContext.knownProjectiles.contains(light.projectile))
					sceneContext.knownProjectiles.add(light.projectile);
		}

		for (Light light : WORLD_LIGHTS) {
			assert light.worldPoint != null;
			int regionId = light.worldPoint.getRegionID();
			if (sceneContext.regionIds.contains(regionId))
				addWorldLight(sceneContext, light);
		}

		for (Tile[][] plane : sceneContext.scene.getExtendedTiles()) {
			for (Tile[] column : plane) {
				for (Tile tile : column) {
					if (tile == null)
						continue;

					DecorativeObject decorativeObject = tile.getDecorativeObject();
					if (decorativeObject != null)
						handleObjectSpawn(sceneContext, decorativeObject);

					WallObject wallObject = tile.getWallObject();
					if (wallObject != null)
						handleObjectSpawn(sceneContext, wallObject);

					GroundObject groundObject = tile.getGroundObject();
					if (groundObject != null && groundObject.getRenderable() != null)
						handleObjectSpawn(sceneContext, groundObject);

					for (GameObject gameObject : tile.getGameObjects()) {
						// Skip nulls, players & NPCs
						if (gameObject == null || gameObject.getRenderable() instanceof Actor)
							continue;

						handleObjectSpawn(sceneContext, gameObject);
					}
				}
			}
		}
	}

	private void removeLightIf(Predicate<Light> predicate) {
		var sceneContext = plugin.getSceneContext();
		if (sceneContext == null)
			return;
		removeLightIf(sceneContext, predicate);
	}

	private void removeLightIf(@Nonnull SceneContext sceneContext, Predicate<Light> predicate) {
		for (var light : sceneContext.lights)
			if (predicate.test(light))
				light.markedForRemoval = true;
	}

	private void addSpotAnimLights(Actor actor) {
		var sceneContext = plugin.getSceneContext();
		if (sceneContext == null)
			return;

		int[] worldPos = sceneContext.localToWorld(actor.getLocalLocation(), client.getPlane());

		for (var spotAnim : actor.getSpotAnims()) {
			int spotAnimId = spotAnim.getId();
			for (var def : SPOT_ANIM_LIGHTS.get(spotAnim.getId())) {
				if (def.areas.length > 0) {
					boolean isInArea = Arrays.stream(def.areas).anyMatch(aabb -> aabb.contains(worldPos));
					if (!isInArea)
						continue;
				}

				boolean isDuplicate = sceneContext.lights.stream()
					.anyMatch(light ->
						light.spotAnimId == spotAnimId &&
						light.actor == actor &&
						light.def == def);
				if (isDuplicate)
					continue;

				Light light = new Light(def);
				light.plane = -1;
				light.spotAnimId = spotAnimId;
				light.actor = actor;
				sceneContext.lights.add(light);
			}
		}
	}

	private void addNpcLights(NPC npc)
	{
		var sceneContext = plugin.getSceneContext();
		if (sceneContext == null)
			return;

		int uuid = ModelHash.packUuid(ModelHash.TYPE_NPC, npc.getId());
		int[] worldPos = sceneContext.localToWorld(npc.getLocalLocation(), client.getPlane());

		var modelOverride = modelOverrideManager.getOverride(uuid, worldPos);
		if (modelOverride.hide)
			return;

		for (LightDefinition def : NPC_LIGHTS.get(npc.getId())) {
			if (def.areas.length > 0) {
				boolean isInArea = Arrays.stream(def.areas).anyMatch(aabb -> aabb.contains(worldPos));
				if (!isInArea)
					continue;
			}

			// Prevent duplicate lights from being spawned for the same NPC
			boolean isDuplicate = sceneContext.lights.stream()
				.anyMatch(light ->
					light.actor == npc &&
					light.def == def &&
					!light.markedForRemoval);
			if (isDuplicate)
				continue;

			Light light = new Light(def);
			light.plane = -1;
			light.actor = npc;
			sceneContext.lights.add(light);
		}
	}

	private void handleObjectSpawn(TileObject object) {
		var sceneContext = plugin.getSceneContext();
		if (sceneContext != null)
			handleObjectSpawn(sceneContext, object);
	}

	private void handleObjectSpawn(
		@Nonnull SceneContext sceneContext,
		@Nonnull TileObject tileObject
	) {
		if (sceneContext.trackedTileObjects.containsKey(tileObject))
			return;

		var tracker = new TileObjectImpostorTracker(tileObject);
		sceneContext.trackedTileObjects.put(tileObject, tracker);

		// prevent objects at plane -1 and below from having lights
		if (tileObject.getPlane() < 0)
			return;

		ObjectComposition def = client.getObjectDefinition(tileObject.getId());
		tracker.impostorIds = def.getImpostorIds();
		if (tracker.impostorIds != null) {
			tracker.impostorVarbit = def.getVarbitId();
			tracker.impostorVarp = def.getVarPlayerId();
			if (tracker.impostorVarbit != -1)
				sceneContext.trackedVarbits.put(tracker.impostorVarbit, tracker);
			if (tracker.impostorVarp != -1)
				sceneContext.trackedVarps.put(tracker.impostorVarp, tracker);
		}

		trackImpostorChanges(sceneContext, tracker);
	}

	private void handleObjectDespawn(TileObject tileObject) {
		var sceneContext = plugin.getSceneContext();
		if (sceneContext == null)
			return;

		var tracker = sceneContext.trackedTileObjects.remove(tileObject);
		if (tracker == null)
			return;

		if (tracker.spawnedAnyLights) {
			long hash = tracker.lightHash(tracker.impostorId);
			removeLightIf(sceneContext, l -> l.hash == hash);
		}

		if (tracker.impostorVarbit != -1)
			sceneContext.trackedVarbits.remove(tracker.impostorVarbit, tracker);
		if (tracker.impostorVarp != -1)
			sceneContext.trackedVarps.remove(tracker.impostorVarp, tracker);
	}

	private void trackImpostorChanges(@Nonnull SceneContext sceneContext, TileObjectImpostorTracker tracker) {
		int impostorId = -1;
		if (tracker.impostorIds != null) {
			try {
				int impostorIndex = -1;
				if (tracker.impostorVarbit != -1) {
					impostorIndex = client.getVarbitValue(tracker.impostorVarbit);
				} else if (tracker.impostorVarp != -1) {
					impostorIndex = client.getVarpValue(tracker.impostorVarp);
				}
				if (impostorIndex >= 0)
					impostorId = tracker.impostorIds[Math.min(impostorIndex, tracker.impostorIds.length - 1)];
			} catch (Exception ex) {
				log.debug("Error getting impostor:", ex);
			}
		}

		// Don't do anything if the impostor is the same, unless the object just spawned
		if (impostorId == tracker.impostorId && !tracker.justSpawned)
			return;

		int sizeX = 1;
		int sizeY = 1;
		Renderable[] renderables = new Renderable[2];
		int[] orientations = new int[2];

		var tileObject = tracker.tileObject;
		if (tileObject instanceof GroundObject) {
			var object = (GroundObject) tileObject;
			renderables[0] = object.getRenderable();
			orientations[0] = HDUtils.getBakedOrientation(object.getConfig());
		} else if (tileObject instanceof DecorativeObject) {
			var object = (DecorativeObject) tileObject;
			renderables[0] = object.getRenderable();
			renderables[1] = object.getRenderable2();
			orientations[0] = orientations[1] = HDUtils.getBakedOrientation(object.getConfig());
		} else if (tileObject instanceof WallObject) {
			var object = (WallObject) tileObject;
			renderables[0] = object.getRenderable1();
			renderables[1] = object.getRenderable2();
			orientations[0] = HDUtils.convertWallObjectOrientation(object.getOrientationA());
			orientations[1] = HDUtils.convertWallObjectOrientation(object.getOrientationB());
		} else if (tileObject instanceof GameObject) {
			var object = (GameObject) tileObject;
			sizeX = object.sizeX();
			sizeY = object.sizeY();
			renderables[0] = object.getRenderable();
			orientations[0] = HDUtils.getBakedOrientation(object.getConfig());
		} else {
			log.warn("Unhandled TileObject type: id: {}, hash: {}", tileObject.getId(), tileObject.getHash());
			return;
		}

		// Despawn old lights, if we spawned any for the previous impostor
		if (tracker.spawnedAnyLights) {
			long oldHash = tracker.lightHash(tracker.impostorId);
			removeLightIf(sceneContext, l -> l.hash == oldHash);
			tracker.spawnedAnyLights = false;
		}

		long newHash = tracker.lightHash(impostorId);
		List<LightDefinition> lights = OBJECT_LIGHTS.get(impostorId == -1 ? tileObject.getId() : impostorId);
		HashSet<LightDefinition> onlySpawnOnce = new HashSet<>();

		LocalPoint lp = tileObject.getLocalLocation();
		int lightX = lp.getX();
		int lightZ = lp.getY();
		int plane = tileObject.getPlane();

		// Spawn animation-specific lights for each DynamicObject renderable, and non-animation-based lights
		for (int i = 0; i < 2; i++) {
			var renderable = renderables[i];
			if (renderable == null)
				continue;

			for (LightDefinition def : lights) {
				if (def.areas.length > 0) {
					int[] worldPos = sceneContext.localToWorld(lightX, lightZ, plane);
					boolean isInArea = Arrays.stream(def.areas).anyMatch(aabb -> aabb.contains(worldPos));
					if (!isInArea)
						continue;
				}

				// Rarely, it may be necessary to specify which of the two possible renderables the light should be attached to
				if (def.renderableIndex == -1) {
					// If unspecified, spawn it for the first non-null renderable
					if (onlySpawnOnce.contains(def))
						continue;
					onlySpawnOnce.add(def);
				} else if (def.renderableIndex != i) {
					continue;
				}

				int tileExX = HDUtils.clamp(lp.getSceneX() + SceneUploader.SCENE_OFFSET, 0, EXTENDED_SCENE_SIZE - 2);
				int tileExY = HDUtils.clamp(lp.getSceneY() + SceneUploader.SCENE_OFFSET, 0, EXTENDED_SCENE_SIZE - 2);
				float lerpX = (lightX % LOCAL_TILE_SIZE) / (float) LOCAL_TILE_SIZE;
				float lerpZ = (lightZ % LOCAL_TILE_SIZE) / (float) LOCAL_TILE_SIZE;
				int tileZ = HDUtils.clamp(plane, 0, MAX_Z - 1);

				Tile[][][] tiles = sceneContext.scene.getExtendedTiles();
				Tile tile = tiles[tileZ][tileExX][tileExY];
				if (tile != null && tile.getBridge() != null && tileZ < MAX_Z - 1)
					tileZ++;

				int[][][] tileHeights = sceneContext.scene.getTileHeights();
				float heightNorth = HDUtils.lerp(
					tileHeights[tileZ][tileExX][tileExY + 1],
					tileHeights[tileZ][tileExX + 1][tileExY + 1],
					lerpX
				);
				float heightSouth = HDUtils.lerp(
					tileHeights[tileZ][tileExX][tileExY],
					tileHeights[tileZ][tileExX + 1][tileExY],
					lerpX
				);
				float tileHeight = HDUtils.lerp(heightSouth, heightNorth, lerpZ);

				Light light = new Light(def);
				light.hash = newHash;
				light.tileObject = tileObject;
				light.plane = plane;
				light.preOrientation = orientations[i];
				light.origin[0] = lightX;
				light.origin[1] = (int) tileHeight - light.def.height - 1;
				light.origin[2] = lightZ;
				light.sizeX = sizeX;
				light.sizeY = sizeY;
				sceneContext.lights.add(light);
				tracker.spawnedAnyLights = true;
			}
		}

		tracker.impostorId = impostorId;
		tracker.justSpawned = false;
	}

	private void addWorldLight(SceneContext sceneContext, Light light) {
		assert light.worldPoint != null;
		var firstlp = sceneContext.worldInstanceToLocals(light.worldPoint).findFirst();
		if (firstlp.isEmpty())
			return;

		LocalPoint lp = firstlp.get();
		int tileExX = lp.getSceneX() + SceneUploader.SCENE_OFFSET;
		int tileExY = lp.getSceneY() + SceneUploader.SCENE_OFFSET;
		if (tileExX < 0 || tileExY < 0 || tileExX >= EXTENDED_SCENE_SIZE || tileExY >= EXTENDED_SCENE_SIZE)
			return;

		light.origin[0] = lp.getX() + LOCAL_HALF_TILE_SIZE;
		light.origin[1] = sceneContext.scene.getTileHeights()[light.plane][tileExX][tileExY] - light.def.height - 1;
		light.origin[2] = lp.getY() + LOCAL_HALF_TILE_SIZE;
		sceneContext.lights.add(light);
	}

	@Subscribe
	public void onProjectileMoved(ProjectileMoved projectileMoved) {
		SceneContext sceneContext = plugin.getSceneContext();
		if (sceneContext == null)
			return;

		// Since there's no spawn & despawn events for projectiles, add when they move for the first time
		Projectile projectile = projectileMoved.getProjectile();
		if (!sceneContext.knownProjectiles.add(projectile))
			return;

		int[] worldPos = sceneContext.localToWorld((int) projectile.getX(), (int) projectile.getY(), projectile.getFloor());

		int[] refCounter = { 0 };
		for (LightDefinition def : PROJECTILE_LIGHTS.get(projectile.getId())) {
			if (def.areas.length > 0) {
				boolean isInArea = Arrays.stream(def.areas).anyMatch(aabb -> aabb.contains(worldPos));
				if (!isInArea)
					continue;
			}

			Light light = new Light(def);
			light.projectile = projectile;
			light.projectileRefCounter = refCounter;
			refCounter[0]++;
			light.origin[0] = (int) projectile.getX();
			light.origin[1] = (int) projectile.getZ();
			light.origin[2] = (int) projectile.getY();
			light.plane = projectile.getFloor();

			sceneContext.lights.add(light);
		}
	}

	@Subscribe
	public void onNpcSpawned(NpcSpawned spawn) {
		NPC npc = spawn.getNpc();
		addNpcLights(npc);
		addSpotAnimLights(npc);
	}

	@Subscribe
	public void onNpcChanged(NpcChanged change) {
		// Respawn non-spotanim lights
		NPC npc = change.getNpc();
		removeLightIf(light -> light.actor == npc && light.spotAnimId == -1);
		addNpcLights(change.getNpc());
	}

	@Subscribe
	public void onNpcDespawned(NpcDespawned despawn) {
		NPC npc = despawn.getNpc();
		removeLightIf(light -> light.actor == npc);
	}

	@Subscribe
	public void onPlayerSpawned(PlayerSpawned spawn) {
		addSpotAnimLights(spawn.getPlayer());
	}

	@Subscribe
	public void onPlayerChanged(PlayerChanged change) {
		// Don't add spotAnim lights on player change events, since it breaks death & respawn lights
	}

	@Subscribe
	public void onGraphicChanged(GraphicChanged change) {
		addSpotAnimLights(change.getActor());
	}

	@Subscribe
	public void onPlayerDespawned(PlayerDespawned despawn) {
		Player player = despawn.getPlayer();
		removeLightIf(light -> light.actor == player);
	}

	@Subscribe
	public void onGraphicsObjectCreated(GraphicsObjectCreated graphicsObjectCreated) {
		SceneContext sceneContext = plugin.getSceneContext();
		if (sceneContext == null)
			return;

		GraphicsObject graphicsObject = graphicsObjectCreated.getGraphicsObject();
		var lp = graphicsObject.getLocation();
		int[] worldPos = sceneContext.localToWorld(lp, graphicsObject.getLevel());

		for (LightDefinition def : SPOT_ANIM_LIGHTS.get(graphicsObject.getId())) {
			if (def.areas.length > 0) {
				boolean isInArea = Arrays.stream(def.areas).anyMatch(aabb -> aabb.contains(worldPos));
				if (!isInArea)
					continue;
			}

			Light light = new Light(def);
			light.graphicsObject = graphicsObject;
			light.origin[0] = lp.getX();
			light.origin[1] = graphicsObject.getZ();
			light.origin[2] = lp.getY();
			light.plane = worldPos[2];
			sceneContext.lights.add(light);
		}
	}

	@Subscribe
	public void onGameObjectSpawned(GameObjectSpawned spawn) {
		handleObjectSpawn(spawn.getGameObject());
	}

	@Subscribe
	public void onGameObjectDespawned(GameObjectDespawned despawn) {
		handleObjectDespawn(despawn.getGameObject());
	}

	@Subscribe
	public void onWallObjectSpawned(WallObjectSpawned spawn) {
		handleObjectSpawn(spawn.getWallObject());
	}

	@Subscribe
	public void onWallObjectDespawned(WallObjectDespawned despawn) {
		handleObjectDespawn(despawn.getWallObject());
	}

	@Subscribe
	public void onDecorativeObjectSpawned(DecorativeObjectSpawned spawn) {
		handleObjectSpawn(spawn.getDecorativeObject());
	}

	@Subscribe
	public void onDecorativeObjectDespawned(DecorativeObjectDespawned despawn) {
		handleObjectDespawn(despawn.getDecorativeObject());
	}

	@Subscribe
	public void onGroundObjectSpawned(GroundObjectSpawned spawn) {
		handleObjectSpawn(spawn.getGroundObject());
	}

	@Subscribe
	public void onGroundObjectDespawned(GroundObjectDespawned despawn) {
		handleObjectDespawn(despawn.getGroundObject());
	}

	@Subscribe
	public void onVarbitChanged(VarbitChanged event) {
		var sceneContext = plugin.getSceneContext();
		if (sceneContext == null)
			return;

		if (plugin.enableDetailedTimers)
			frameTimer.begin(Timer.IMPOSTOR_TRACKING);
		// Check if the event is specifically a varbit change first,
		// since all varbit changes are necessarily also varp changes
		if (event.getVarbitId() != -1) {
			for (var tracker : sceneContext.trackedVarbits.get(event.getVarbitId()))
				trackImpostorChanges(sceneContext, tracker);
		} else if (event.getVarpId() != -1) {
			for (var tracker : sceneContext.trackedVarps.get(event.getVarpId()))
				trackImpostorChanges(sceneContext, tracker);
		}
		if (plugin.enableDetailedTimers)
			frameTimer.end(Timer.IMPOSTOR_TRACKING);
	}
}

/*
 * Copyright (c) 2021, 117 <https://twitter.com/117scape>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package rs117.hd.scene;

import java.io.IOException;
import java.util.HashMap;
import javax.annotation.Nonnull;
import javax.inject.Inject;
import javax.inject.Singleton;
import lombok.Getter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.*;
import net.runelite.client.callback.ClientThread;
import rs117.hd.HdPlugin;
import rs117.hd.HdPluginConfig;
import rs117.hd.config.DefaultSkyColor;
import rs117.hd.scene.environments.Environment;
import rs117.hd.utils.AABB;
import rs117.hd.utils.FileWatcher;
import rs117.hd.utils.Props;
import rs117.hd.utils.ResourcePath;

import static rs117.hd.utils.HDUtils.PI;
import static rs117.hd.utils.HDUtils.TWO_PI;
import static rs117.hd.utils.HDUtils.clamp;
import static rs117.hd.utils.HDUtils.hermite;
import static rs117.hd.utils.HDUtils.lerp;
import static rs117.hd.utils.HDUtils.mod;
import static rs117.hd.utils.HDUtils.rand;
import static rs117.hd.utils.ResourcePath.path;

@Singleton
@Slf4j
public class EnvironmentManager {
	private static final ResourcePath ENVIRONMENTS_PATH = Props.getPathOrDefault(
		"rlhd.environments-path",
		() -> path(EnvironmentManager.class, "environments.json")
	);

	@Inject
	private Client client;

	@Inject
	private ClientThread clientThread;

	@Inject
	private HdPlugin plugin;

	@Inject
	private HdPluginConfig config;

	private static final float TRANSITION_DURATION = 3; // seconds
	// distance in tiles to skip transition (e.g. entering cave, teleporting)
	// walking across a loading line causes a movement of 40-41 tiles
	private static final int SKIP_TRANSITION_DISTANCE = 41;

	// when the current transition began, relative to plugin startup
	private boolean transitionComplete = true;
	private double transitionStartTime = 0;
	private int[] previousPosition = new int[3];

	private float[] startFogColor = new float[] { 0, 0, 0 };
	public float[] currentFogColor = new float[] { 0, 0, 0 };
	private float[] targetFogColor = new float[] { 0, 0, 0 };

	private float[] startWaterColor = new float[] { 0, 0, 0 };
	public float[] currentWaterColor = new float[] { 0, 0, 0 };
	private float[] targetWaterColor = new float[] { 0, 0, 0 };

	private float startFogDepth = 0;
	public float currentFogDepth = 0;
	private float targetFogDepth = 0;

	private float startAmbientStrength = 0f;
	public float currentAmbientStrength = 0f;
	private float targetAmbientStrength = 0f;

	private float[] startAmbientColor = new float[] { 0, 0, 0 };
	public float[] currentAmbientColor = new float[] { 0, 0, 0 };
	private float[] targetAmbientColor = new float[] { 0, 0, 0 };

	private float startDirectionalStrength = 0f;
	public float currentDirectionalStrength = 0f;
	private float targetDirectionalStrength = 0f;

	private float[] startUnderwaterCausticsColor = new float[] { 0, 0, 0 };
	public float[] currentUnderwaterCausticsColor = new float[] { 0, 0, 0 };
	private float[] targetUnderwaterCausticsColor = new float[] { 0, 0, 0 };

	private float startUnderwaterCausticsStrength = 1f;
	public float currentUnderwaterCausticsStrength = 1f;
	private float targetUnderwaterCausticsStrength = 1f;

	private float[] startDirectionalColor = new float[] { 0, 0, 0 };
	public float[] currentDirectionalColor = new float[] { 0, 0, 0 };
	private float[] targetDirectionalColor = new float[] { 0, 0, 0 };

	private float startUnderglowStrength = 0f;
	public float currentUnderglowStrength = 0f;
	private float targetUnderglowStrength = 0f;

	private float[] startUnderglowColor = new float[] { 0, 0, 0 };
	public float[] currentUnderglowColor = new float[] { 0, 0, 0 };
	private float[] targetUnderglowColor = new float[] { 0, 0, 0 };

	private float startGroundFogStart = 0f;
	public float currentGroundFogStart = 0f;
	private float targetGroundFogStart = 0f;

	private float startGroundFogEnd = 0f;
	public float currentGroundFogEnd = 0f;
	private float targetGroundFogEnd = 0f;

	private float startGroundFogOpacity = 0f;
	public float currentGroundFogOpacity = 0f;
	private float targetGroundFogOpacity = 0f;

	private final float[] startSunAngles = { 0, 0 };
	public final float[] currentSunAngles = { 0, 0 };
	private final float[] targetSunAngles = { 0, 0 };

	private boolean lightningEnabled = false;
	private boolean forceNextTransition = false;

	private rs117.hd.scene.environments.Environment[] environments;
	private FileWatcher.UnregisterCallback fileWatcher;

	@Nonnull
	private Environment currentEnvironment = Environment.NONE;

	public void startUp() {
		fileWatcher = ENVIRONMENTS_PATH.watch((path, first) -> {
			try {
				environments = path.loadJson(plugin.getGson(), rs117.hd.scene.environments.Environment[].class);
				if (environments == null)
					throw new IOException("Empty or invalid: " + path);
				log.debug("Loaded {} environments", environments.length);

				HashMap<String, Environment> map = new HashMap<>();
				for (var env : environments)
					if (env.key != null)
						map.put(env.key, env);

				Environment.OVERWORLD = map.getOrDefault("OVERWORLD", Environment.DEFAULT);
				Environment.AUTUMN = map.getOrDefault("AUTUMN", Environment.DEFAULT);
				Environment.WINTER = map.getOrDefault("WINTER", Environment.DEFAULT);

				for (var env : environments)
					env.normalize();

				clientThread.invoke(() -> {
					// Force instant transition during development
					if (!first)
						reset();

					if (client.getGameState().getState() >= GameState.LOGGED_IN.getState() && plugin.getSceneContext() != null)
						loadSceneEnvironments(plugin.getSceneContext());
				});
			} catch (IOException ex) {
				log.error("Failed to load environments:", ex);
			}
		});
	}

	public void shutDown() {
		if (fileWatcher != null)
			fileWatcher.unregister();
		fileWatcher = null;
		environments = null;
		reset();
	}

	public void reset() {
		currentEnvironment = Environment.NONE;
		forceNextTransition = false;
	}

	public void triggerTransition() {
		forceNextTransition = true;
	}

	/**
	 * Updates variables used in transition effects
	 *
	 * @param sceneContext to possible environments from
	 */
	public void update(SceneContext sceneContext) {
		assert client.isClientThread();

		int[] focalPoint = sceneContext.localToWorld(
			plugin.cameraFocalPoint[0],
			plugin.cameraFocalPoint[1],
			client.getPlane()
		);

		// skip the transitional fade if the player has moved too far
		// since the previous frame. results in an instant transition when
		// teleporting, entering dungeons, etc.
		int tileChange = Math.max(
			Math.abs(focalPoint[0] - previousPosition[0]),
			Math.abs(focalPoint[1] - previousPosition[1])
		);
		previousPosition = focalPoint;

		boolean skipTransition = tileChange >= SKIP_TRANSITION_DISTANCE;
		for (var environment : sceneContext.environments) {
			if (environment.area.containsPoint(focalPoint)) {
				changeEnvironment(environment, skipTransition);
				break;
			}
		}

		updateTargetSkyColor(); // Update every frame, since other plugins may control it

		if (transitionComplete) {
			// Always write fog and water color, since they're affected by lightning
			currentFogColor = targetFogColor;
			currentWaterColor = targetWaterColor;
		} else {
			// interpolate between start and target values
			float t = clamp((float) (plugin.elapsedTime - transitionStartTime) / TRANSITION_DURATION, 0, 1);
			if (t >= 1)
				transitionComplete = true;
			currentFogColor = hermite(startFogColor, targetFogColor, t);
			currentWaterColor = hermite(startWaterColor, targetWaterColor, t);
			currentFogDepth = hermite(startFogDepth, targetFogDepth, t);
			currentAmbientStrength = hermite(startAmbientStrength, targetAmbientStrength, t);
			currentAmbientColor = hermite(startAmbientColor, targetAmbientColor, t);
			currentDirectionalStrength = hermite(startDirectionalStrength, targetDirectionalStrength, t);
			currentDirectionalColor = hermite(startDirectionalColor, targetDirectionalColor, t);
			currentUnderglowStrength = hermite(startUnderglowStrength, targetUnderglowStrength, t);
			currentUnderglowColor = hermite(startUnderglowColor, targetUnderglowColor, t);
			currentGroundFogStart = hermite(startGroundFogStart, targetGroundFogStart, t);
			currentGroundFogEnd = hermite(startGroundFogEnd, targetGroundFogEnd, t);
			currentGroundFogOpacity = hermite(startGroundFogOpacity, targetGroundFogOpacity, t);
			for (int i = 0; i < 2; i++)
				currentSunAngles[i] = hermite(startSunAngles[i], targetSunAngles[i], t);
			currentUnderwaterCausticsColor = hermite(startUnderwaterCausticsColor, targetUnderwaterCausticsColor, t);
			currentUnderwaterCausticsStrength = hermite(startUnderwaterCausticsStrength, targetUnderwaterCausticsStrength, t);
		}

		updateLightning();
	}

	/**
	 * Updates variables used in transition effects
	 *
	 * @param newEnvironment the new environment to transition to
	 * @param skipTransition whether the transition should be done instantly
	 */
	private void changeEnvironment(Environment newEnvironment, boolean skipTransition) {
		// Skip changing the environment unless the transition is forced, since reapplying
		// the overworld environment is required when switching between seasonal themes
		if (currentEnvironment == newEnvironment && !forceNextTransition)
			return;

		if (currentEnvironment == Environment.NONE) {
			skipTransition = true;
		} else if (forceNextTransition) {
			forceNextTransition = false;
			skipTransition = false;
		}

		if (currentEnvironment.instantTransition || newEnvironment.instantTransition)
			skipTransition = true;

		log.debug("changing environment from {} to {} (instant: {})", currentEnvironment, newEnvironment, skipTransition);
		currentEnvironment = newEnvironment;
		transitionComplete = false;
		transitionStartTime = plugin.elapsedTime - (skipTransition ? TRANSITION_DURATION : 0);

		// Start transitioning from the current values
		startFogColor = currentFogColor;
		startWaterColor = currentWaterColor;
		startFogDepth = currentFogDepth;
		startAmbientStrength = currentAmbientStrength;
		startAmbientColor = currentAmbientColor;
		startDirectionalStrength = currentDirectionalStrength;
		startDirectionalColor = currentDirectionalColor;
		startUnderglowStrength = currentUnderglowStrength;
		startUnderglowColor = currentUnderglowColor;
		startGroundFogStart = currentGroundFogStart;
		startGroundFogEnd = currentGroundFogEnd;
		startGroundFogOpacity = currentGroundFogOpacity;
		startUnderwaterCausticsColor = currentUnderwaterCausticsColor;
		startUnderwaterCausticsStrength = currentUnderwaterCausticsStrength;
		for (int i = 0; i < 2; i++)
			startSunAngles[i] = mod(currentSunAngles[i], TWO_PI);

		updateTargetSkyColor();

		var env = getCurrentEnvironment();
		targetFogDepth = env.fogDepth;
		targetGroundFogStart = env.groundFogStart;
		targetGroundFogEnd = env.groundFogEnd;
		targetGroundFogOpacity = env.groundFogOpacity;
		lightningEnabled = env.lightningEffects;

		var overworldEnv = getOverworldEnvironment();
		float[] sunAngles = env.sunAngles;
		if (sunAngles == null)
			sunAngles = overworldEnv.sunAngles;
		System.arraycopy(sunAngles, 0, targetSunAngles, 0, 2);

		if (!config.atmosphericLighting() && !env.force)
			env = overworldEnv;
		targetAmbientStrength = env.ambientStrength;
		targetAmbientColor = env.ambientColor;
		targetDirectionalStrength = env.directionalStrength;
		targetDirectionalColor = env.directionalColor;
		targetUnderglowStrength = env.underglowStrength;
		targetUnderglowColor = env.underglowColor;
		targetUnderwaterCausticsColor = env.waterCausticsColor;
		targetUnderwaterCausticsStrength = env.waterCausticsStrength;

		// Prevent transitions from taking the long way around
		for (int i = 0; i < 2; i++) {
			float diff = startSunAngles[i] - targetSunAngles[i];
			if (Math.abs(diff) > PI)
				targetSunAngles[i] += TWO_PI * Math.signum(diff);
		}
	}

	public void updateTargetSkyColor() {
		Environment env = getCurrentEnvironment();

		if (env.fogColor == null || env.allowSkyOverride && config.overrideSky()) {
			DefaultSkyColor sky = config.defaultSkyColor();
			targetFogColor = sky.getRgb(client);
			if (sky == DefaultSkyColor.OSRS)
				sky = DefaultSkyColor.DEFAULT;
			targetWaterColor = sky.getRgb(client);
		} else {
			targetFogColor = targetWaterColor = env.fogColor;
		}

		// Override with decoupled water/sky color if present
		if (env.waterColor != null) {
			targetWaterColor = env.waterColor;
		} else if (config.decoupleSkyAndWaterColor()) {
			targetWaterColor = DefaultSkyColor.DEFAULT.getRgb(client);
		}
	}

	/**
	 * Figures out which Areas exist in the current scene and
	 * adds them to lists for easy access.
	 */
	public void loadSceneEnvironments(SceneContext sceneContext) {
		log.debug("Adding environments for scene with regions: {}", sceneContext.regionIds);

		AABB[] regions = sceneContext.regionIds.stream()
			.map(AABB::new)
			.toArray(AABB[]::new);

		sceneContext.environments.clear();
		outer:
		for (var environment : environments) {
			for (AABB region : regions) {
				for (AABB aabb : environment.area.getAabbs()) {
					if (region.intersects(aabb)) {
						log.debug("Added environment: {}", environment);
						sceneContext.environments.add(environment);
						continue outer;
					}
				}
			}
		}

		// Fall back to the default environment
		sceneContext.environments.add(Environment.DEFAULT);
	}

	/* lightning */
	private static final float[] LIGHTNING_COLOR = new float[]{.25f, .25f, .25f};
	private static final float NEW_LIGHTNING_BRIGHTNESS = 7f;
	private static final float LIGHTNING_FADE_SPEED = 80f; // brightness units per second
	private static final float MIN_LIGHTNING_INTERVAL = 5.5f;
	private static final float MAX_LIGHTNING_INTERVAL = 17f;
	private static final float QUICK_LIGHTNING_CHANCE = .5f;
	private static final float MIN_QUICK_LIGHTNING_INTERVAL = .04f;
	private static final float MAX_QUICK_LIGHTNING_INTERVAL = .15f;

	@Getter
	private float lightningBrightness = 0f;
	private double nextLightningTime = -1;

	/**
	 * Updates lightning variables and sets water reflection and sky
	 * colors during lightning flashes.
	 */
	void updateLightning() {
		if (lightningBrightness > 0) {
			float brightnessChange = plugin.deltaTime * LIGHTNING_FADE_SPEED;
			lightningBrightness = Math.max(lightningBrightness - brightnessChange, 0);
		}

		if (nextLightningTime == -1) {
			generateNextLightningTime();
			return;
		}
		if (plugin.elapsedTime > nextLightningTime) {
			lightningBrightness = NEW_LIGHTNING_BRIGHTNESS;
			generateNextLightningTime();
		}

		if (lightningEnabled && config.flashingEffects()) {
			float t = clamp(lightningBrightness, 0, 1);
			currentFogColor = lerp(currentFogColor, LIGHTNING_COLOR, t);
			currentWaterColor = lerp(currentWaterColor, LIGHTNING_COLOR, t);
		} else {
			lightningBrightness = 0f;
		}
	}

	/**
	 * Determines when the next lighting strike will occur.
	 * Produces a short interval for a quick successive strike
	 * or a longer interval at the end of a cluster.
	 */
	void generateNextLightningTime() {
		nextLightningTime = plugin.elapsedTime;
		if (Math.random() <= QUICK_LIGHTNING_CHANCE) {
			// chain together lighting strikes in quick succession
			nextLightningTime += lerp(MIN_QUICK_LIGHTNING_INTERVAL, MAX_QUICK_LIGHTNING_INTERVAL, rand.nextFloat());
		} else {
			// cool-down period before a new lightning cluster
			nextLightningTime += lerp(MIN_LIGHTNING_INTERVAL, MAX_LIGHTNING_INTERVAL, rand.nextFloat());
		}
	}

	private Environment getCurrentEnvironment() {
		if (currentEnvironment == Environment.OVERWORLD)
			return getOverworldEnvironment();
		return currentEnvironment;
	}

	private Environment getOverworldEnvironment() {
		switch (plugin.configSeasonalTheme) {
			case AUTUMN:
				return Environment.AUTUMN;
			case WINTER:
				return Environment.WINTER;
			default:
				return Environment.OVERWORLD;
		}
	}

	public boolean isUnderwater() {
		return currentEnvironment.isUnderwater;
	}
}

/*
 * Copyright (c) 2018, Adam <Adam@sigterm.info>
 * Copyright (c) 2021, 117 <https://twitter.com/117scape>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package rs117.hd.scene;

import com.google.common.base.Stopwatch;
import javax.annotation.Nonnull;
import javax.inject.Inject;
import javax.inject.Singleton;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.*;
import rs117.hd.HdPlugin;
import rs117.hd.data.WaterType;
import rs117.hd.data.environments.Area;
import rs117.hd.data.materials.GroundMaterial;
import rs117.hd.data.materials.Material;
import rs117.hd.data.materials.UvType;
import rs117.hd.model.ModelPusher;
import rs117.hd.scene.model_overrides.ModelOverride;
import rs117.hd.scene.model_overrides.ObjectType;
import rs117.hd.scene.tile_overrides.TileOverride;
import rs117.hd.utils.HDUtils;
import rs117.hd.utils.ModelHash;

import static net.runelite.api.Perspective.*;
import static rs117.hd.HdPlugin.NORMAL_SIZE;
import static rs117.hd.HdPlugin.SCALAR_BYTES;
import static rs117.hd.HdPlugin.UV_SIZE;
import static rs117.hd.HdPlugin.VERTEX_SIZE;
import static rs117.hd.scene.tile_overrides.TileOverride.NONE;
import static rs117.hd.scene.tile_overrides.TileOverride.OVERLAY_FLAG;

@SuppressWarnings("UnnecessaryLocalVariable")
@Singleton
@Slf4j
public
class SceneUploader {
	public static final int SCENE_ID_MASK = 0xFFFF;
	public static final int EXCLUDED_FROM_SCENE_BUFFER = 0xFFFFFFFF;
	public static final int SCENE_OFFSET = (Constants.EXTENDED_SCENE_SIZE - Constants.SCENE_SIZE) / 2; // offset for sxy -> msxy

	private static final float[] UP_NORMAL = { 0, -1, 0 };

	@Inject
	private Client client;

	@Inject
	private HdPlugin plugin;

	@Inject
	private TileOverrideManager tileOverrideManager;

	@Inject
	private ModelOverrideManager modelOverrideManager;

	@Inject
	public ProceduralGenerator proceduralGenerator;

	@Inject
	private ModelPusher modelPusher;

	public void upload(SceneContext sceneContext) {
		Stopwatch stopwatch = Stopwatch.createStarted();

		for (int z = 0; z < Constants.MAX_Z; ++z) {
			for (int x = 0; x < Constants.EXTENDED_SCENE_SIZE; ++x) {
				for (int y = 0; y < Constants.EXTENDED_SCENE_SIZE; ++y) {
					Tile tile = sceneContext.scene.getExtendedTiles()[z][x][y];
					if (tile != null)
						upload(sceneContext, tile, x, y);
				}
			}
		}

		stopwatch.stop();
		log.debug(
			"Scene upload time: {}, unique models: {}, size: {} MB",
			stopwatch,
			sceneContext.uniqueModels,
			String.format(
				"%.2f",
				(
					sceneContext.getVertexOffset() * (VERTEX_SIZE + NORMAL_SIZE) * SCALAR_BYTES +
					sceneContext.getUvOffset() * UV_SIZE * SCALAR_BYTES
				) / 1e6
			)
		);
	}

	public void fillGaps(SceneContext sceneContext) {
		int sceneMin = sceneContext.expandedMapLoadingChunks * -8;
		int sceneMax = SCENE_SIZE + sceneContext.expandedMapLoadingChunks * 8;

		Tile[][][] extendedTiles = sceneContext.scene.getExtendedTiles();
		for (int tileZ = 0; tileZ < Constants.MAX_Z; ++tileZ) {
			for (int tileExX = 0; tileExX < Constants.EXTENDED_SCENE_SIZE; ++tileExX) {
				for (int tileExY = 0; tileExY < Constants.EXTENDED_SCENE_SIZE; ++tileExY) {
					int tileX = tileExX - SCENE_OFFSET;
					int tileY = tileExY - SCENE_OFFSET;
					Tile tile = extendedTiles[tileZ][tileExX][tileExY];

					SceneTilePaint paint;
					SceneTileModel model = null;
					int renderLevel = tileZ;
					if (tile != null) {
						renderLevel = tile.getRenderLevel();
						paint = tile.getSceneTilePaint();
						model = tile.getSceneTileModel();

						if (model == null) {
							boolean hasTilePaint = paint != null && paint.getNeColor() != 12345678;
							if (!hasTilePaint) {
								tile = tile.getBridge();
								if (tile != null) {
									renderLevel = tile.getRenderLevel();
									paint = tile.getSceneTilePaint();
									model = tile.getSceneTileModel();
									hasTilePaint = paint != null && paint.getNeColor() != 12345678;
								}
							}

							if (hasTilePaint)
								continue;
						}
					}

					int[] worldPoint = sceneContext.sceneToWorld(tileX, tileY, tileZ);
					boolean fillGaps =
						tileZ == 0 &&
						tileX > sceneMin &&
						tileY > sceneMin &&
						tileX < sceneMax - 1 &&
						tileY < sceneMax - 1 &&
						Area.OVERWORLD.containsPoint(worldPoint);

					if (fillGaps) {
						int tileRegionID = HDUtils.worldToRegionID(worldPoint);
						int[] regions = client.getMapRegions();

						fillGaps = false;
						for (int region : regions) {
							if (region == tileRegionID) {
								fillGaps = true;
								break;
							}
						}
					}

					if (fillGaps) {
						int vertexOffset = sceneContext.getVertexOffset();
						int uvOffset = sceneContext.getUvOffset();
						int vertexCount;

						if (model == null) {
							uploadBlackTile(sceneContext, tileExX, tileExY, renderLevel);
							vertexCount = 6;
						} else {
							int[] uploadedTileModelData = uploadHDTileModelSurface(sceneContext, tile, model, true);
							vertexCount = uploadedTileModelData[0];
						}

						if (vertexCount > 0) {
							sceneContext.staticUnorderedModelBuffer
								.ensureCapacity(8)
								.getBuffer()
								.put(vertexOffset)
								.put(uvOffset)
								.put(vertexCount / 3)
								.put(sceneContext.staticVertexCount)
								.put(0)
								.put(tileX * LOCAL_TILE_SIZE)
								.put(0)
								.put(tileY * LOCAL_TILE_SIZE);
							sceneContext.staticVertexCount += vertexCount;
						}
					}
				}
			}
		}
	}

	private void uploadModel(SceneContext sceneContext, Tile tile, int uuid, Model model, int orientation, ObjectType objectType) {
		// deduplicate hillskewed models
		if (model.getUnskewedModel() != null)
			model = model.getUnskewedModel();

		if (model.getSceneId() == EXCLUDED_FROM_SCENE_BUFFER)
			return;

		int[] worldPos = sceneContext.localToWorld(tile.getLocalLocation(), tile.getPlane());
		ModelOverride modelOverride = modelOverrideManager.getOverride(uuid, worldPos);
		int sceneId = modelOverride.hashCode() << 16 | sceneContext.id;

		// check if the model has already been uploaded
		if ((model.getSceneId() & SCENE_ID_MASK) == sceneContext.id) {
			// if the same model is being uploaded, but with a different area-specific model override,
			// exclude it from the scene buffer to avoid conflicts
			if (model.getSceneId() != sceneId)
				model.setSceneId(EXCLUDED_FROM_SCENE_BUFFER);
			return;
		}

		int vertexOffset = sceneContext.getVertexOffset();
		int uvOffset = sceneContext.getUvOffset();

		if (modelOverride.hide) {
			vertexOffset = -1;
		} else {
			modelPusher.pushModel(sceneContext, tile, uuid, model, modelOverride, objectType, orientation, false);
			if (sceneContext.modelPusherResults[1] == 0)
				uvOffset = -1;
		}

		model.setBufferOffset(vertexOffset);
		model.setUvBufferOffset(uvOffset);
		model.setSceneId(sceneId);
		++sceneContext.uniqueModels;
	}

	private void upload(SceneContext sceneContext, @Nonnull Tile tile, int tileExX, int tileExY) {
		Tile bridge = tile.getBridge();
		if (bridge != null)
			upload(sceneContext, bridge, tileExX, tileExY);

		SceneTilePaint sceneTilePaint = tile.getSceneTilePaint();
		if (sceneTilePaint != null) {
			// Set offsets before pushing new data
			int vertexOffset = sceneContext.getVertexOffset();
			int uvOffset = sceneContext.getUvOffset();
			int[] uploadedTilePaintData = upload(sceneContext, tile, sceneTilePaint);

			int vertexCount = uploadedTilePaintData[0];
			int uvCount = uploadedTilePaintData[1];
			int hasUnderwaterTerrain = uploadedTilePaintData[2];

			// Opening the right-click menu causes the game to stop drawing hidden tiles, which prevents us from drawing underwater tiles
			// below the boats at Pest Control. To work around this, we can instead draw all water tiles that never appear on top of any
			// other model, all at once at the start of the frame. This bypasses any issues with draw order, and even partially solves the
			// draw order artifacts resulting from skipped geometry updates for our extension to unlocked FPS.
			final int[][][] tileHeights = sceneContext.scene.getTileHeights();
			if (hasUnderwaterTerrain == 1 && tileHeights[tile.getRenderLevel()][tileExX][tileExY] >= -16) {
				int tileX = tileExX - SCENE_OFFSET;
				int tileY = tileExY - SCENE_OFFSET;

				// Draw the underwater tile at the start of each frame
				sceneContext.staticUnorderedModelBuffer
					.ensureCapacity(8)
					.getBuffer()
					.put(vertexOffset)
					.put(uvOffset)
					.put(2) // 2 faces
					.put(sceneContext.staticVertexCount)
					.put(0)
					.put(tileX * LOCAL_TILE_SIZE)
					.put(0)
					.put(tileY * LOCAL_TILE_SIZE);
				sceneContext.staticVertexCount += 6;

				// Since we're now drawing this tile's underwater geometry at the beginning of the frame, remove it from the draw callback
				vertexCount -= 6;
				uvCount -= 6;
				vertexOffset += 6;
				uvOffset += 6;
			}

			if (uvCount <= 0)
				uvOffset = -1;

			sceneTilePaint.setBufferLen(vertexCount);
			sceneTilePaint.setBufferOffset(vertexOffset);
			sceneTilePaint.setUvBufferOffset(uvOffset);
		}

		var sceneTileModel = tile.getSceneTileModel();
		if (sceneTileModel != null) {
			// Set offsets before pushing new data
			sceneTileModel.setBufferOffset(sceneContext.getVertexOffset());
			sceneTileModel.setUvBufferOffset(sceneContext.getUvOffset());
			int[] uploadedTileModelData = upload(sceneContext, tile, sceneTileModel);

			final int bufferLength = uploadedTileModelData[0];
			final int uvBufferLength = uploadedTileModelData[1];
			final int underwaterTerrain = uploadedTileModelData[2];
			if (uvBufferLength <= 0)
				sceneTileModel.setUvBufferOffset(-1);
			// pack a boolean into the buffer length of tiles so we can tell
			// which tiles have procedurally-generated underwater terrain
			int packedBufferLength = bufferLength << 1 | underwaterTerrain;

			sceneTileModel.setBufferLen(packedBufferLength);
		}

		WallObject wallObject = tile.getWallObject();
		if (wallObject != null) {
			Renderable renderable1 = wallObject.getRenderable1();
			if (renderable1 instanceof Model) {
				uploadModel(sceneContext, tile, ModelHash.packUuid(ModelHash.TYPE_OBJECT, wallObject.getId()), (Model) renderable1,
					HDUtils.convertWallObjectOrientation(wallObject.getOrientationA()),
					ObjectType.WALL_OBJECT
				);
			}

			Renderable renderable2 = wallObject.getRenderable2();
			if (renderable2 instanceof Model) {
				uploadModel(sceneContext, tile, ModelHash.packUuid(ModelHash.TYPE_OBJECT, wallObject.getId()), (Model) renderable2,
					HDUtils.convertWallObjectOrientation(wallObject.getOrientationB()),
					ObjectType.WALL_OBJECT
				);
			}
		}

		GroundObject groundObject = tile.getGroundObject();
		if (groundObject != null) {
			Renderable renderable = groundObject.getRenderable();
			if (renderable instanceof Model) {
				uploadModel(sceneContext, tile, ModelHash.packUuid(ModelHash.TYPE_OBJECT, groundObject.getId()), (Model) renderable,
					HDUtils.getBakedOrientation(groundObject.getConfig()),
					ObjectType.GROUND_OBJECT
				);
			}
		}

		DecorativeObject decorativeObject = tile.getDecorativeObject();
		if (decorativeObject != null) {
			Renderable renderable = decorativeObject.getRenderable();
			int orientation = HDUtils.getBakedOrientation(decorativeObject.getConfig());
			if (renderable instanceof Model) {
				uploadModel(sceneContext, tile, ModelHash.packUuid(ModelHash.TYPE_OBJECT, decorativeObject.getId()), (Model) renderable,
					orientation,
					ObjectType.DECORATIVE_OBJECT
				);
			}

			Renderable renderable2 = decorativeObject.getRenderable2();
			if (renderable2 instanceof Model) {
				uploadModel(sceneContext, tile, ModelHash.packUuid(ModelHash.TYPE_OBJECT, decorativeObject.getId()), (Model) renderable2,
					orientation,
					ObjectType.DECORATIVE_OBJECT
				);
			}
		}

		GameObject[] gameObjects = tile.getGameObjects();
		for (GameObject gameObject : gameObjects) {
			if (gameObject == null) {
				continue;
			}

			Renderable renderable = gameObject.getRenderable();
			if (renderable instanceof Model) {
				uploadModel(sceneContext,
					tile,
					ModelHash.packUuid(ModelHash.TYPE_OBJECT, gameObject.getId()),
					(Model) gameObject.getRenderable(),
					HDUtils.getBakedOrientation(gameObject.getConfig()), ObjectType.GAME_OBJECT
				);
			}
		}
	}

	private int[] upload(SceneContext sceneContext, Tile tile, SceneTilePaint paint) {
		int bufferLength = 0;
		int uvBufferLength = 0;
		int underwaterTerrain = 0;

		int[] bufferLengths;

		var override = tileOverrideManager.getOverride(sceneContext.scene, tile);
		WaterType waterType = proceduralGenerator.seasonalWaterType(override, paint.getTexture());

		bufferLengths = uploadHDTilePaintUnderwater(sceneContext, tile, waterType);
		bufferLength += bufferLengths[0];
		uvBufferLength += bufferLengths[1];
		underwaterTerrain += bufferLengths[2];

		bufferLengths = uploadHDTilePaintSurface(sceneContext, tile, paint, override, waterType);
		bufferLength += bufferLengths[0];
		uvBufferLength += bufferLengths[1];
		underwaterTerrain += bufferLengths[2];

		return new int[] { bufferLength, uvBufferLength, underwaterTerrain };
	}

	private int[] uploadHDTilePaintSurface(
		SceneContext sceneContext,
		Tile tile,
		SceneTilePaint paint,
		TileOverride override,
		WaterType waterType
	) {
		final Scene scene = sceneContext.scene;
		final Point tilePoint = tile.getSceneLocation();
		final int tileX = tilePoint.getX();
		final int tileY = tilePoint.getY();
		final int tileExX = tileX + SceneUploader.SCENE_OFFSET;
		final int tileExY = tileY + SceneUploader.SCENE_OFFSET;
		final int tileZ = tile.getRenderLevel();

		final int localX = 0;
		final int localY = 0;

		int baseX = scene.getBaseX();
		int baseY = scene.getBaseY();

		final int[][][] tileHeights = scene.getTileHeights();
		int swHeight = tileHeights[tileZ][tileExX][tileExY];
		int seHeight = tileHeights[tileZ][tileExX + 1][tileExY];
		int neHeight = tileHeights[tileZ][tileExX + 1][tileExY + 1];
		int nwHeight = tileHeights[tileZ][tileExX][tileExY + 1];

		int bufferLength = 0;
		int uvBufferLength = 0;
		int underwaterTerrain = 0;

		int localSwVertexX = localX;
		int localSwVertexY = localY;
		int localSeVertexX = localX + LOCAL_TILE_SIZE;
		int localSeVertexY = localY;
		int localNwVertexX = localX;
		int localNwVertexY = localY + LOCAL_TILE_SIZE;
		int localNeVertexX = localX + LOCAL_TILE_SIZE;
		int localNeVertexY = localY + LOCAL_TILE_SIZE;

		int[] vertexKeys = ProceduralGenerator.tileVertexKeys(scene, tile);
		int swVertexKey = vertexKeys[0];
		int seVertexKey = vertexKeys[1];
		int nwVertexKey = vertexKeys[2];
		int neVertexKey = vertexKeys[3];

		int uvOrientation = 0;
		float uvScale = 1;

		// Ignore certain tiles that aren't supposed to be visible,
		// but which we can still make a height-adjusted version of for underwater
		if (paint.getNeColor() != 12345678)
		{
			int swColor = paint.getSwColor();
			int seColor = paint.getSeColor();
			int neColor = paint.getNeColor();
			int nwColor = paint.getNwColor();

			int textureId = paint.getTexture();

			boolean neVertexIsOverlay = false;
			boolean nwVertexIsOverlay = false;
			boolean seVertexIsOverlay = false;
			boolean swVertexIsOverlay = false;

			Material swMaterial = Material.NONE;
			Material seMaterial = Material.NONE;
			Material neMaterial = Material.NONE;
			Material nwMaterial = Material.NONE;

			float[] swNormals = UP_NORMAL;
			float[] seNormals = UP_NORMAL;
			float[] neNormals = UP_NORMAL;
			float[] nwNormals = UP_NORMAL;

			if (waterType == WaterType.NONE) {
				if (textureId != -1) {
					var material = Material.fromVanillaTexture(textureId);
					// Disable tile overrides for newly introduced vanilla textures
					if (material == Material.VANILLA)
						override = NONE;
					swMaterial = seMaterial = neMaterial = nwMaterial = material;
				}

				swNormals = sceneContext.vertexTerrainNormals.getOrDefault(swVertexKey, swNormals);
				seNormals = sceneContext.vertexTerrainNormals.getOrDefault(seVertexKey, seNormals);
				neNormals = sceneContext.vertexTerrainNormals.getOrDefault(neVertexKey, neNormals);
				nwNormals = sceneContext.vertexTerrainNormals.getOrDefault(nwVertexKey, nwNormals);

				boolean useBlendedMaterialAndColor =
					plugin.configGroundBlending &&
					textureId == -1 &&
					!proceduralGenerator.useDefaultColor(tile, override);
				GroundMaterial groundMaterial = null;
				if (override != TileOverride.NONE) {
					groundMaterial = override.groundMaterial;
					uvOrientation = override.uvOrientation;
					uvScale = override.uvScale;
					if (!useBlendedMaterialAndColor) {
						swColor = override.modifyColor(swColor);
						seColor = override.modifyColor(seColor);
						nwColor = override.modifyColor(nwColor);
						neColor = override.modifyColor(neColor);
					}
				} else if (textureId == -1) {
					// Fall back to the default ground material if the tile is untextured
					groundMaterial = override.groundMaterial;
				}

				if (useBlendedMaterialAndColor) {
					// get the vertices' colors and textures from hashmaps
					swColor = sceneContext.vertexTerrainColor.getOrDefault(swVertexKey, swColor);
					seColor = sceneContext.vertexTerrainColor.getOrDefault(seVertexKey, seColor);
					neColor = sceneContext.vertexTerrainColor.getOrDefault(neVertexKey, neColor);
					nwColor = sceneContext.vertexTerrainColor.getOrDefault(nwVertexKey, nwColor);

					if (plugin.configGroundTextures) {
						swMaterial = sceneContext.vertexTerrainTexture.getOrDefault(swVertexKey, swMaterial);
						seMaterial = sceneContext.vertexTerrainTexture.getOrDefault(seVertexKey, seMaterial);
						neMaterial = sceneContext.vertexTerrainTexture.getOrDefault(neVertexKey, neMaterial);
						nwMaterial = sceneContext.vertexTerrainTexture.getOrDefault(nwVertexKey, nwMaterial);
					}
				} else if (plugin.configGroundTextures && groundMaterial != null) {
					swMaterial = groundMaterial.getRandomMaterial(tileZ, baseX + tileX, baseY + tileY);
					seMaterial = groundMaterial.getRandomMaterial(tileZ, baseX + tileX + 1, baseY + tileY);
					nwMaterial = groundMaterial.getRandomMaterial(tileZ, baseX + tileX, baseY + tileY + 1);
					neMaterial = groundMaterial.getRandomMaterial(tileZ, baseX + tileX + 1, baseY + tileY + 1);
				}
			}
			else
			{
				// set colors for the shoreline to create a foam effect in the water shader

				swColor = seColor = nwColor = neColor = 127;

				if (sceneContext.vertexIsWater.containsKey(swVertexKey) && sceneContext.vertexIsLand.containsKey(swVertexKey))
					swColor = 0;
				if (sceneContext.vertexIsWater.containsKey(seVertexKey) && sceneContext.vertexIsLand.containsKey(seVertexKey))
					seColor = 0;
				if (sceneContext.vertexIsWater.containsKey(nwVertexKey) && sceneContext.vertexIsLand.containsKey(nwVertexKey))
					nwColor = 0;
				if (sceneContext.vertexIsWater.containsKey(neVertexKey) && sceneContext.vertexIsLand.containsKey(neVertexKey))
					neColor = 0;
			}

			if (sceneContext.vertexIsOverlay.containsKey(neVertexKey) && sceneContext.vertexIsUnderlay.containsKey(neVertexKey))
				neVertexIsOverlay = true;
			if (sceneContext.vertexIsOverlay.containsKey(nwVertexKey) && sceneContext.vertexIsUnderlay.containsKey(nwVertexKey))
				nwVertexIsOverlay = true;
			if (sceneContext.vertexIsOverlay.containsKey(seVertexKey) && sceneContext.vertexIsUnderlay.containsKey(seVertexKey))
				seVertexIsOverlay = true;
			if (sceneContext.vertexIsOverlay.containsKey(swVertexKey) && sceneContext.vertexIsUnderlay.containsKey(swVertexKey))
				swVertexIsOverlay = true;


			int terrainData = packTerrainData(true, 0, waterType, tileZ);

			sceneContext.stagingBufferNormals.ensureCapacity(24);
			sceneContext.stagingBufferNormals.put(neNormals[0], neNormals[2], neNormals[1], terrainData);
			sceneContext.stagingBufferNormals.put(nwNormals[0], nwNormals[2], nwNormals[1], terrainData);
			sceneContext.stagingBufferNormals.put(seNormals[0], seNormals[2], seNormals[1], terrainData);

			sceneContext.stagingBufferNormals.put(swNormals[0], swNormals[2], swNormals[1], terrainData);
			sceneContext.stagingBufferNormals.put(seNormals[0], seNormals[2], seNormals[1], terrainData);
			sceneContext.stagingBufferNormals.put(nwNormals[0], nwNormals[2], nwNormals[1], terrainData);


			sceneContext.stagingBufferVertices.ensureCapacity(24);
			sceneContext.stagingBufferVertices.put((float) localNeVertexX, neHeight, localNeVertexY, neColor);
			sceneContext.stagingBufferVertices.put((float) localNwVertexX, nwHeight, localNwVertexY, nwColor);
			sceneContext.stagingBufferVertices.put((float) localSeVertexX, seHeight, localSeVertexY, seColor);

			sceneContext.stagingBufferVertices.put((float) localSwVertexX, swHeight, localSwVertexY, swColor);
			sceneContext.stagingBufferVertices.put((float) localSeVertexX, seHeight, localSeVertexY, seColor);
			sceneContext.stagingBufferVertices.put((float) localNwVertexX, nwHeight, localNwVertexY, nwColor);

			bufferLength += 6;


			int packedMaterialDataSW = modelPusher.packMaterialData(
				swMaterial, textureId, ModelOverride.NONE, UvType.GEOMETRY, swVertexIsOverlay);
			int packedMaterialDataSE = modelPusher.packMaterialData(
				seMaterial, textureId, ModelOverride.NONE, UvType.GEOMETRY, seVertexIsOverlay);
			int packedMaterialDataNW = modelPusher.packMaterialData(
				nwMaterial, textureId, ModelOverride.NONE, UvType.GEOMETRY, nwVertexIsOverlay);
			int packedMaterialDataNE = modelPusher.packMaterialData(
				neMaterial, textureId, ModelOverride.NONE, UvType.GEOMETRY, neVertexIsOverlay);

			float uvcos = -uvScale, uvsin = 0;
			if (uvOrientation % 2048 != 0) {
				float rad = -uvOrientation * (float) UNIT;
				uvcos = (float) Math.cos(rad) * -uvScale;
				uvsin = (float) Math.sin(rad) * -uvScale;
			}
			float uvx = baseX + tileX;
			float uvy = baseY + tileY;
			float tmp = uvx;
			uvx = uvx * uvcos - uvy * uvsin;
			uvy = tmp * uvsin + uvy * uvcos;

			sceneContext.stagingBufferUvs.ensureCapacity(24);
			sceneContext.stagingBufferUvs.put(uvx, uvy, 0, packedMaterialDataNE);
			sceneContext.stagingBufferUvs.put(uvx - uvcos, uvy - uvsin, 0, packedMaterialDataNW);
			sceneContext.stagingBufferUvs.put(uvx + uvsin, uvy - uvcos, 0, packedMaterialDataSE);

			sceneContext.stagingBufferUvs.put(uvx - uvcos + uvsin, uvy - uvsin - uvcos, 0, packedMaterialDataSW);
			sceneContext.stagingBufferUvs.put(uvx + uvsin, uvy - uvcos, 0, packedMaterialDataSE);
			sceneContext.stagingBufferUvs.put(uvx - uvcos, uvy - uvsin, 0, packedMaterialDataNW);

			uvBufferLength += 6;
		}

		return new int[]{bufferLength, uvBufferLength, underwaterTerrain};
	}

	private int[] uploadHDTilePaintUnderwater(SceneContext sceneContext, Tile tile, WaterType waterType) {
		final Scene scene = sceneContext.scene;
		final Point tilePoint = tile.getSceneLocation();
		final int tileX = tilePoint.getX();
		final int tileY = tilePoint.getY();
		final int tileExX = tileX + SceneUploader.SCENE_OFFSET;
		final int tileExY = tileY + SceneUploader.SCENE_OFFSET;
		final int tileZ = tile.getRenderLevel();

		int baseX = scene.getBaseX();
		int baseY = scene.getBaseY();

		if (baseX >= 2816 && baseX <= 2970 && baseY <= 5375 && baseY >= 5220) {
			// fix for God Wars Dungeon's water rendering over zamorak bridge
			return new int[] { 0, 0, 0 };
		}

		final int[][][] tileHeights = scene.getTileHeights();
		int swHeight = tileHeights[tileZ][tileExX][tileExY];
		int seHeight = tileHeights[tileZ][tileExX + 1][tileExY];
		int neHeight = tileHeights[tileZ][tileExX + 1][tileExY + 1];
		int nwHeight = tileHeights[tileZ][tileExX][tileExY + 1];

		int bufferLength = 0;
		int uvBufferLength = 0;
		int underwaterTerrain = 0;

		int localSwVertexX = 0;
		int localSwVertexY = 0;
		int localSeVertexX = LOCAL_TILE_SIZE;
		int localSeVertexY = 0;
		int localNwVertexX = 0;
		int localNwVertexY = LOCAL_TILE_SIZE;
		int localNeVertexX = LOCAL_TILE_SIZE;
		int localNeVertexY = LOCAL_TILE_SIZE;

		int[] vertexKeys = ProceduralGenerator.tileVertexKeys(scene, tile);
		int swVertexKey = vertexKeys[0];
		int seVertexKey = vertexKeys[1];
		int nwVertexKey = vertexKeys[2];
		int neVertexKey = vertexKeys[3];

		if (sceneContext.tileIsWater[tileZ][tileExX][tileExY]) {
			// underwater terrain

			underwaterTerrain = 1;

			int swColor = 6676;
			int seColor = 6676;
			int neColor = 6676;
			int nwColor = 6676;

			int swDepth = sceneContext.vertexUnderwaterDepth.getOrDefault(swVertexKey, 0);
			int seDepth = sceneContext.vertexUnderwaterDepth.getOrDefault(seVertexKey, 0);
			int nwDepth = sceneContext.vertexUnderwaterDepth.getOrDefault(nwVertexKey, 0);
			int neDepth = sceneContext.vertexUnderwaterDepth.getOrDefault(neVertexKey, 0);

			float[] swNormals = sceneContext.vertexTerrainNormals.getOrDefault(swVertexKey, UP_NORMAL);
			float[] seNormals = sceneContext.vertexTerrainNormals.getOrDefault(seVertexKey, UP_NORMAL);
			float[] nwNormals = sceneContext.vertexTerrainNormals.getOrDefault(nwVertexKey, UP_NORMAL);
			float[] neNormals = sceneContext.vertexTerrainNormals.getOrDefault(neVertexKey, UP_NORMAL);

			Material swMaterial = Material.NONE;
			Material seMaterial = Material.NONE;
			Material nwMaterial = Material.NONE;
			Material neMaterial = Material.NONE;

			if (plugin.configGroundTextures)
			{
				GroundMaterial groundMaterial = GroundMaterial.UNDERWATER_GENERIC;

				swMaterial = groundMaterial.getRandomMaterial(tileZ, baseX + tileX, baseY + tileY);
				seMaterial = groundMaterial.getRandomMaterial(tileZ, baseX + tileX + 1, baseY + tileY);
				nwMaterial = groundMaterial.getRandomMaterial(tileZ, baseX + tileX, baseY + tileY + 1);
				neMaterial = groundMaterial.getRandomMaterial(tileZ, baseX + tileX + 1, baseY + tileY + 1);
			}

			int swTerrainData = packTerrainData(true, Math.max(1, swDepth), waterType, tileZ);
			int seTerrainData = packTerrainData(true, Math.max(1, seDepth), waterType, tileZ);
			int nwTerrainData = packTerrainData(true, Math.max(1, nwDepth), waterType, tileZ);
			int neTerrainData = packTerrainData(true, Math.max(1, neDepth), waterType, tileZ);

			sceneContext.stagingBufferNormals.ensureCapacity(24);
			sceneContext.stagingBufferNormals.put(neNormals[0], neNormals[2], neNormals[1], neTerrainData);
			sceneContext.stagingBufferNormals.put(nwNormals[0], nwNormals[2], nwNormals[1], nwTerrainData);
			sceneContext.stagingBufferNormals.put(seNormals[0], seNormals[2], seNormals[1], seTerrainData);

			sceneContext.stagingBufferNormals.put(swNormals[0], swNormals[2], swNormals[1], swTerrainData);
			sceneContext.stagingBufferNormals.put(seNormals[0], seNormals[2], seNormals[1], seTerrainData);
			sceneContext.stagingBufferNormals.put(nwNormals[0], nwNormals[2], nwNormals[1], nwTerrainData);

			sceneContext.stagingBufferVertices.ensureCapacity(24);
			sceneContext.stagingBufferVertices.put((float) localNeVertexX, neHeight + neDepth, localNeVertexY, neColor);
			sceneContext.stagingBufferVertices.put((float) localNwVertexX, nwHeight + nwDepth, localNwVertexY, nwColor);
			sceneContext.stagingBufferVertices.put((float) localSeVertexX, seHeight + seDepth, localSeVertexY, seColor);

			sceneContext.stagingBufferVertices.put((float) localSwVertexX, swHeight + swDepth, localSwVertexY, swColor);
			sceneContext.stagingBufferVertices.put((float) localSeVertexX, seHeight + seDepth, localSeVertexY, seColor);
			sceneContext.stagingBufferVertices.put((float) localNwVertexX, nwHeight + nwDepth, localNwVertexY, nwColor);

			bufferLength += 6;

			int packedMaterialDataSW = modelPusher.packMaterialData(
				swMaterial, -1, ModelOverride.NONE, UvType.GEOMETRY, false);
			int packedMaterialDataSE = modelPusher.packMaterialData(
				seMaterial, -1, ModelOverride.NONE, UvType.GEOMETRY, false);
			int packedMaterialDataNW = modelPusher.packMaterialData(
				nwMaterial, -1, ModelOverride.NONE, UvType.GEOMETRY, false);
			int packedMaterialDataNE = modelPusher.packMaterialData(
				neMaterial, -1, ModelOverride.NONE, UvType.GEOMETRY, false);

			sceneContext.stagingBufferUvs.ensureCapacity(24);
			sceneContext.stagingBufferUvs.put(0, 0, 0, packedMaterialDataNE);
			sceneContext.stagingBufferUvs.put(1, 0, 0, packedMaterialDataNW);
			sceneContext.stagingBufferUvs.put(0, 1, 0, packedMaterialDataSE);

			sceneContext.stagingBufferUvs.put(1, 1, 0, packedMaterialDataSW);
			sceneContext.stagingBufferUvs.put(0, 1, 0, packedMaterialDataSE);
			sceneContext.stagingBufferUvs.put(1, 0, 0, packedMaterialDataNW);

			uvBufferLength += 6;
		}

		return new int[]{bufferLength, uvBufferLength, underwaterTerrain};
	}

	private int[] upload(SceneContext sceneContext, Tile tile, SceneTileModel sceneTileModel)
	{
		int bufferLength = 0;
		int uvBufferLength = 0;
		int underwaterTerrain = 0;

		int[] bufferLengths;

		bufferLengths = uploadHDTileModelSurface(sceneContext, tile, sceneTileModel, false);
		bufferLength += bufferLengths[0];
		uvBufferLength += bufferLengths[1];
		underwaterTerrain += bufferLengths[2];

		bufferLengths = uploadHDTileModelUnderwater(sceneContext, tile, sceneTileModel);
		assert bufferLengths[0] == bufferLength || bufferLengths[0] == 0;
		bufferLength += bufferLengths[0];
		uvBufferLength += bufferLengths[1];
		underwaterTerrain += bufferLengths[2];

		return new int[]{bufferLength, uvBufferLength, underwaterTerrain};
	}

	private int[] uploadHDTileModelSurface(SceneContext sceneContext, Tile tile, SceneTileModel model, boolean fillGaps) {
		final Scene scene = sceneContext.scene;
		final Point tilePoint = tile.getSceneLocation();
		final int tileX = tilePoint.getX();
		final int tileY = tilePoint.getY();
		final int tileExX = tileX + SceneUploader.SCENE_OFFSET;
		final int tileExY = tileY + SceneUploader.SCENE_OFFSET;
		final int tileZ = tile.getRenderLevel();

		int bufferLength = 0;
		int uvBufferLength = 0;
		int underwaterTerrain = 0;

		if (sceneContext.skipTile[tileZ][tileExX][tileExY]) {
			return new int[] { bufferLength, uvBufferLength, underwaterTerrain };
		}

		final int[] faceColorA = model.getTriangleColorA();
		final int[] faceColorB = model.getTriangleColorB();
		final int[] faceColorC = model.getTriangleColorC();
		final int[] faceTextures = model.getTriangleTextureId();
		final int faceCount = model.getFaceX().length;

		int baseX = scene.getBaseX();
		int baseY = scene.getBaseY();

		int[] worldPos = sceneContext.sceneToWorld(tileX, tileY, tileZ);
		int overlayId = OVERLAY_FLAG | scene.getOverlayIds()[tileZ][tileExX][tileExY];
		int underlayId = scene.getUnderlayIds()[tileZ][tileExX][tileExY];

		for (int face = 0; face < faceCount; ++face) {
			int colorA = faceColorA[face];
			int colorB = faceColorB[face];
			int colorC = faceColorC[face];

			int[][] localVertices = ProceduralGenerator.faceLocalVertices(tile, face);

			int[] vertexKeys = ProceduralGenerator.faceVertexKeys(tile, face);
			int vertexKeyA = vertexKeys[0];
			int vertexKeyB = vertexKeys[1];
			int vertexKeyC = vertexKeys[2];

			boolean vertexAIsOverlay = false;
			boolean vertexBIsOverlay = false;
			boolean vertexCIsOverlay = false;

			int textureId = -1;
			Material materialA = Material.NONE;
			Material materialB = Material.NONE;
			Material materialC = Material.NONE;

			int uvOrientation = 0;
			float uvScale = 1;

			float[] normalsA = UP_NORMAL;
			float[] normalsB = UP_NORMAL;
			float[] normalsC = UP_NORMAL;

			WaterType waterType = WaterType.NONE;

			boolean isHidden = colorA == 12345678;
			if (fillGaps) {
				if (!isHidden)
					continue;
				colorA = colorB = colorC = 0;
			} else {
				if (isHidden)
					continue;

				boolean isOverlay = ProceduralGenerator.isOverlayFace(tile, face);
				var override = tileOverrideManager.getOverride(scene, tile, worldPos, isOverlay ? overlayId : underlayId);
				textureId = faceTextures == null ? -1 : faceTextures[face];
				waterType = proceduralGenerator.seasonalWaterType(override, textureId);
				if (waterType == WaterType.NONE) {
					if (textureId != -1) {
						var material = Material.fromVanillaTexture(textureId);
						// Disable tile overrides for newly introduced vanilla textures
						if (material == Material.VANILLA)
							override = NONE;
						materialA = materialB = materialC = material;
					}

					normalsA = sceneContext.vertexTerrainNormals.getOrDefault(vertexKeyA, normalsA);
					normalsB = sceneContext.vertexTerrainNormals.getOrDefault(vertexKeyB, normalsB);
					normalsC = sceneContext.vertexTerrainNormals.getOrDefault(vertexKeyC, normalsC);

					GroundMaterial groundMaterial = null;

					boolean useBlendedMaterialAndColor =
						plugin.configGroundBlending &&
						textureId == -1 &&
						!(isOverlay && proceduralGenerator.useDefaultColor(tile, override));
					if (override != TileOverride.NONE) {
						groundMaterial = override.groundMaterial;
						uvOrientation = override.uvOrientation;
						uvScale = override.uvScale;
						if (!useBlendedMaterialAndColor) {
							colorA = override.modifyColor(colorA);
							colorB = override.modifyColor(colorB);
							colorC = override.modifyColor(colorC);
						}
					} else if (textureId == -1) {
						// Fall back to the default ground material if the tile is untextured
						groundMaterial = override.groundMaterial;
					}

					if (useBlendedMaterialAndColor) {
						// get the vertices' colors and textures from hashmaps
						colorA = sceneContext.vertexTerrainColor.getOrDefault(vertexKeyA, colorA);
						colorB = sceneContext.vertexTerrainColor.getOrDefault(vertexKeyB, colorB);
						colorC = sceneContext.vertexTerrainColor.getOrDefault(vertexKeyC, colorC);

						if (plugin.configGroundTextures) {
							materialA = sceneContext.vertexTerrainTexture.getOrDefault(vertexKeyA, materialA);
							materialB = sceneContext.vertexTerrainTexture.getOrDefault(vertexKeyB, materialB);
							materialC = sceneContext.vertexTerrainTexture.getOrDefault(vertexKeyC, materialC);
						}
					} else if (plugin.configGroundTextures && groundMaterial != null) {
						materialA = groundMaterial.getRandomMaterial(
							tileZ,
							baseX + tileX + (int) Math.floor((float) localVertices[0][0] / LOCAL_TILE_SIZE),
							baseY + tileY + (int) Math.floor((float) localVertices[0][1] / LOCAL_TILE_SIZE)
						);
						materialB = groundMaterial.getRandomMaterial(
							tileZ,
							baseX + tileX + (int) Math.floor((float) localVertices[1][0] / LOCAL_TILE_SIZE),
							baseY + tileY + (int) Math.floor((float) localVertices[1][1] / LOCAL_TILE_SIZE)
						);
						materialC = groundMaterial.getRandomMaterial(
							tileZ,
							baseX + tileX + (int) Math.floor((float) localVertices[2][0] / LOCAL_TILE_SIZE),
							baseY + tileY + (int) Math.floor((float) localVertices[2][1] / LOCAL_TILE_SIZE)
						);
					}
				} else {
					// set colors for the shoreline to create a foam effect in the water shader
					textureId = -1;
					colorA = colorB = colorC = 127;
					if (sceneContext.vertexIsWater.containsKey(vertexKeyA) && sceneContext.vertexIsLand.containsKey(vertexKeyA))
						colorA = 0;
					if (sceneContext.vertexIsWater.containsKey(vertexKeyB) && sceneContext.vertexIsLand.containsKey(vertexKeyB))
						colorB = 0;
					if (sceneContext.vertexIsWater.containsKey(vertexKeyC) && sceneContext.vertexIsLand.containsKey(vertexKeyC))
						colorC = 0;
				}

				if (sceneContext.vertexIsOverlay.containsKey(vertexKeyA) && sceneContext.vertexIsUnderlay.containsKey(vertexKeyA))
					vertexAIsOverlay = true;
				if (sceneContext.vertexIsOverlay.containsKey(vertexKeyB) && sceneContext.vertexIsUnderlay.containsKey(vertexKeyB))
					vertexBIsOverlay = true;
				if (sceneContext.vertexIsOverlay.containsKey(vertexKeyC) && sceneContext.vertexIsUnderlay.containsKey(vertexKeyC))
					vertexCIsOverlay = true;
			}

			int terrainData = packTerrainData(true, 0, waterType, tileZ);

			sceneContext.stagingBufferNormals.ensureCapacity(12);
			sceneContext.stagingBufferNormals.put(normalsA[0], normalsA[2], normalsA[1], terrainData);
			sceneContext.stagingBufferNormals.put(normalsB[0], normalsB[2], normalsB[1], terrainData);
			sceneContext.stagingBufferNormals.put(normalsC[0], normalsC[2], normalsC[1], terrainData);

			sceneContext.stagingBufferVertices.ensureCapacity(12);
			sceneContext.stagingBufferVertices.put((float) localVertices[0][0], localVertices[0][2], localVertices[0][1], colorA);
			sceneContext.stagingBufferVertices.put((float) localVertices[1][0], localVertices[1][2], localVertices[1][1], colorB);
			sceneContext.stagingBufferVertices.put((float) localVertices[2][0], localVertices[2][2], localVertices[2][1], colorC);

			bufferLength += 3;

			int[] packedMaterialData = {
				modelPusher.packMaterialData(materialA, textureId, ModelOverride.NONE, UvType.GEOMETRY, vertexAIsOverlay),
				modelPusher.packMaterialData(materialB, textureId, ModelOverride.NONE, UvType.GEOMETRY, vertexBIsOverlay),
				modelPusher.packMaterialData(materialC, textureId, ModelOverride.NONE, UvType.GEOMETRY, vertexCIsOverlay)
			};

			float uvcos = -uvScale, uvsin = 0;
			if (uvOrientation % 2048 != 0) {
				float rad = -uvOrientation * (float) UNIT;
				uvcos = (float) Math.cos(rad) * -uvScale;
				uvsin = (float) Math.sin(rad) * -uvScale;
			}

			sceneContext.stagingBufferUvs.ensureCapacity(12);
			for (int i = 0; i < 3; i++) {
				float uvx = baseX + tileX + localVertices[i][0] / 128f - 1;
				float uvy = baseY + tileY + localVertices[i][1] / 128f - 1;
				float tmp = uvx;
				uvx = uvx * uvcos - uvy * uvsin;
				uvy = tmp * uvsin + uvy * uvcos;

				sceneContext.stagingBufferUvs.put(uvx, uvy, 0, packedMaterialData[i]);
			}

			uvBufferLength += 3;
		}

		return new int[]{bufferLength, uvBufferLength, underwaterTerrain};
	}

	private int[] uploadHDTileModelUnderwater(SceneContext sceneContext, Tile tile, SceneTileModel model) {
		final Scene scene = sceneContext.scene;
		final Point tilePoint = tile.getSceneLocation();
		final int tileX = tilePoint.getX();
		final int tileY = tilePoint.getY();
		final int tileExX = tileX + SceneUploader.SCENE_OFFSET;
		final int tileExY = tileY + SceneUploader.SCENE_OFFSET;
		final int tileZ = tile.getRenderLevel();

		int bufferLength = 0;
		int uvBufferLength = 0;
		int underwaterTerrain = 0;

		if (sceneContext.skipTile[tileZ][tileExX][tileExY]) {
			return new int[] { bufferLength, uvBufferLength, underwaterTerrain };
		}

		final int[] faceColorA = model.getTriangleColorA();
		final int faceCount = model.getFaceX().length;
		final int[] faceTextures = model.getTriangleTextureId();

		int baseX = scene.getBaseX();
		int baseY = scene.getBaseY();

		if (baseX >= 2816 && baseX <= 2970 && baseY <= 5375 && baseY >= 5220) {
			// fix for God Wars Dungeon's water rendering over zamorak bridge
			return new int[] { bufferLength, uvBufferLength, underwaterTerrain };
		}

		if (sceneContext.tileIsWater[tileZ][tileExX][tileExY]) {
			underwaterTerrain = 1;

			int[] worldPos = sceneContext.sceneToWorld(tileX, tileY, tileZ);
			int overlayId = OVERLAY_FLAG | scene.getOverlayIds()[tileZ][tileExX][tileExY];
			int underlayId = scene.getUnderlayIds()[tileZ][tileExX][tileExY];

			// underwater terrain
			for (int face = 0; face < faceCount; ++face) {
				int colorA = 6676;
				int colorB = 6676;
				int colorC = 6676;

				if (faceColorA[face] == 12345678)
					continue;

				int[][] localVertices = ProceduralGenerator.faceLocalVertices(tile, face);

				Material materialA = Material.NONE;
				Material materialB = Material.NONE;
				Material materialC = Material.NONE;

				int[] vertexKeys = ProceduralGenerator.faceVertexKeys(tile, face);
				int vertexKeyA = vertexKeys[0];
				int vertexKeyB = vertexKeys[1];
				int vertexKeyC = vertexKeys[2];

				int depthA = sceneContext.vertexUnderwaterDepth.getOrDefault(vertexKeyA, 0);
				int depthB = sceneContext.vertexUnderwaterDepth.getOrDefault(vertexKeyB, 0);
				int depthC = sceneContext.vertexUnderwaterDepth.getOrDefault(vertexKeyC, 0);

				if (plugin.configGroundTextures) {
					GroundMaterial groundMaterial = GroundMaterial.UNDERWATER_GENERIC;

					int tileVertexX = Math.round((float) localVertices[0][0] / (float) LOCAL_TILE_SIZE) + tileX + baseX;
					int tileVertexY = Math.round((float) localVertices[0][1] / (float) LOCAL_TILE_SIZE) + tileY + baseY;
					materialA = groundMaterial.getRandomMaterial(tileZ, tileVertexX, tileVertexY);

					tileVertexX = Math.round((float) localVertices[1][0] / (float) LOCAL_TILE_SIZE) + tileX + baseX;
					tileVertexY = Math.round((float) localVertices[1][1] / (float) LOCAL_TILE_SIZE) + tileY + baseY;
					materialB = groundMaterial.getRandomMaterial(tileZ, tileVertexX, tileVertexY);

					tileVertexX = Math.round((float) localVertices[2][0] / (float) LOCAL_TILE_SIZE) + tileX + baseX;
					tileVertexY = Math.round((float) localVertices[2][1] / (float) LOCAL_TILE_SIZE) + tileY + baseY;
					materialC = groundMaterial.getRandomMaterial(tileZ, tileVertexX, tileVertexY);
				}

				float[] normalsA = sceneContext.vertexTerrainNormals.getOrDefault(vertexKeyA, UP_NORMAL);
				float[] normalsB = sceneContext.vertexTerrainNormals.getOrDefault(vertexKeyB, UP_NORMAL);
				float[] normalsC = sceneContext.vertexTerrainNormals.getOrDefault(vertexKeyC, UP_NORMAL);

				boolean isOverlay = ProceduralGenerator.isOverlayFace(tile, face);
				var override = tileOverrideManager.getOverride(scene, tile, worldPos, isOverlay ? overlayId : underlayId);
				int textureId = faceTextures == null ? -1 : faceTextures[face];
				WaterType waterType = proceduralGenerator.seasonalWaterType(override, textureId);

				int aTerrainData = packTerrainData(true, Math.max(1, depthA), waterType, tileZ);
				int bTerrainData = packTerrainData(true, Math.max(1, depthB), waterType, tileZ);
				int cTerrainData = packTerrainData(true, Math.max(1, depthC), waterType, tileZ);

				sceneContext.stagingBufferNormals.ensureCapacity(12);
				sceneContext.stagingBufferNormals.put(normalsA[0], normalsA[2], normalsA[1], aTerrainData);
				sceneContext.stagingBufferNormals.put(normalsB[0], normalsB[2], normalsB[1], bTerrainData);
				sceneContext.stagingBufferNormals.put(normalsC[0], normalsC[2], normalsC[1], cTerrainData);

				sceneContext.stagingBufferVertices.ensureCapacity(12);
				sceneContext.stagingBufferVertices.put(
					(float) localVertices[0][0],
					localVertices[0][2] + depthA,
					localVertices[0][1],
					colorA
				);
				sceneContext.stagingBufferVertices.put(
					(float) localVertices[1][0],
					localVertices[1][2] + depthB,
					localVertices[1][1],
					colorB
				);
				sceneContext.stagingBufferVertices.put(
					(float) localVertices[2][0],
					localVertices[2][2] + depthC,
					localVertices[2][1],
					colorC
				);

				bufferLength += 3;

				int packedMaterialDataA = modelPusher.packMaterialData(
					materialA, -1, ModelOverride.NONE, UvType.GEOMETRY, false);
				int packedMaterialDataB = modelPusher.packMaterialData(
					materialB, -1, ModelOverride.NONE, UvType.GEOMETRY, false);
				int packedMaterialDataC = modelPusher.packMaterialData(
					materialC, -1, ModelOverride.NONE, UvType.GEOMETRY, false);

				sceneContext.stagingBufferUvs.ensureCapacity(12);
				sceneContext.stagingBufferUvs.put(1 - localVertices[0][0] / 128f, 1 - localVertices[0][1] / 128f, 0, packedMaterialDataA);
				sceneContext.stagingBufferUvs.put(1 - localVertices[1][0] / 128f, 1 - localVertices[1][1] / 128f, 0, packedMaterialDataB);
				sceneContext.stagingBufferUvs.put(1 - localVertices[2][0] / 128f, 1 - localVertices[2][1] / 128f, 0, packedMaterialDataC);

				uvBufferLength += 3;
			}
		}

		return new int[] { bufferLength, uvBufferLength, underwaterTerrain };
	}

	private void uploadBlackTile(SceneContext sceneContext, int tileExX, int tileExY, int tileZ) {
		final Scene scene = sceneContext.scene;

		int color = 0;
		float fromX = 0;
		float fromY = 0;
		float toX = LOCAL_TILE_SIZE;
		float toY = LOCAL_TILE_SIZE;

		final int[][][] tileHeights = scene.getTileHeights();
		int swHeight = tileHeights[tileZ][tileExX][tileExY];
		int seHeight = tileHeights[tileZ][tileExX + 1][tileExY];
		int neHeight = tileHeights[tileZ][tileExX + 1][tileExY + 1];
		int nwHeight = tileHeights[tileZ][tileExX][tileExY + 1];

		int terrainData = packTerrainData(true, 0, WaterType.NONE, tileZ);

		sceneContext.stagingBufferNormals.ensureCapacity(24);
		sceneContext.stagingBufferNormals.put(0, -1, 0, terrainData);
		sceneContext.stagingBufferNormals.put(0, -1, 0, terrainData);
		sceneContext.stagingBufferNormals.put(0, -1, 0, terrainData);

		sceneContext.stagingBufferNormals.put(0, -1, 0, terrainData);
		sceneContext.stagingBufferNormals.put(0, -1, 0, terrainData);
		sceneContext.stagingBufferNormals.put(0, -1, 0, terrainData);

		sceneContext.stagingBufferVertices.ensureCapacity(24);
		sceneContext.stagingBufferVertices.put(toX, neHeight, toY, color);
		sceneContext.stagingBufferVertices.put(fromX, nwHeight, toY, color);
		sceneContext.stagingBufferVertices.put(toX, seHeight, fromY, color);

		sceneContext.stagingBufferVertices.put(fromX, swHeight, fromY, color);
		sceneContext.stagingBufferVertices.put(toX, seHeight, fromY, color);
		sceneContext.stagingBufferVertices.put(fromX, nwHeight, toY, color);

		int packedMaterialData = modelPusher.packMaterialData(Material.BLACK, -1, ModelOverride.NONE, UvType.GEOMETRY, false);

		sceneContext.stagingBufferUvs.ensureCapacity(24);
		sceneContext.stagingBufferUvs.put(0, 0, 0, packedMaterialData);
		sceneContext.stagingBufferUvs.put(1, 0, 0, packedMaterialData);
		sceneContext.stagingBufferUvs.put(0, 1, 0, packedMaterialData);

		sceneContext.stagingBufferUvs.put(1, 1, 0, packedMaterialData);
		sceneContext.stagingBufferUvs.put(0, 1, 0, packedMaterialData);
		sceneContext.stagingBufferUvs.put(1, 0, 0, packedMaterialData);
	}

	public static int packTerrainData(boolean isTerrain, int waterDepth, WaterType waterType, int plane) {
		// 11-bit water depth | 5-bit water type | 2-bit plane | terrain flag
		int terrainData = waterDepth << 8 | waterType.ordinal() << 3 | plane << 1 | (isTerrain ? 1 : 0);
		assert (terrainData & ~0xFFFFFF) == 0 : "Only the lower 24 bits are usable, since we pass this into shaders as a float";
		return terrainData;
	}
}

/*
 * Copyright (c) 2021, 117 <https://twitter.com/117scape>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package rs117.hd.scene;

import java.util.Arrays;
import java.util.HashMap;
import javax.inject.Inject;
import javax.inject.Singleton;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.*;
import rs117.hd.HdPlugin;
import rs117.hd.config.SeasonalTheme;
import rs117.hd.data.WaterType;
import rs117.hd.data.materials.Material;
import rs117.hd.scene.model_overrides.ModelOverride;
import rs117.hd.scene.model_overrides.ObjectType;
import rs117.hd.scene.model_overrides.TzHaarRecolorType;
import rs117.hd.scene.tile_overrides.TileOverride;

import static net.runelite.api.Constants.*;
import static net.runelite.api.Perspective.*;
import static rs117.hd.scene.SceneUploader.SCENE_OFFSET;
import static rs117.hd.scene.tile_overrides.TileOverride.OVERLAY_FLAG;
import static rs117.hd.utils.HDUtils.calculateSurfaceNormals;
import static rs117.hd.utils.HDUtils.clamp;
import static rs117.hd.utils.HDUtils.dotLightDirectionTile;
import static rs117.hd.utils.HDUtils.lerp;
import static rs117.hd.utils.HDUtils.vertexHash;
import static rs117.hd.utils.Vector.add;

@Slf4j
@Singleton
public class ProceduralGenerator {
	public static final int[] DEPTH_LEVEL_SLOPE = new int[] { 150, 300, 470, 610, 700, 750, 820, 920, 1080, 1300, 1350, 1380 };

	public static final int VERTICES_PER_FACE = 3;
	public static final boolean[][] TILE_OVERLAY_TRIS = new boolean[][]
		{
			/*  0 */ { true, true, true, true }, // Used by tilemodels of varying tri counts?
			/*  1 */ { false, true },
			/*  2 */ { false, false, true },
			/*  3 */ { false, false, true },
			/*  4 */ { false, true, true },
			/*  5 */ { false, true, true },
			/*  6 */ { false, false, true, true },
			/*  7 */ { false, false, false, true },
			/*  8 */ { false, true, true, true },
			/*  9 */ { false, false, false, true, true, true },
			/* 10 */ { true, true, true, false, false, false },
			/* 11 */ { true, true, false, false, false, false },
		};

	@Inject
	private HdPlugin plugin;

	@Inject
	private TileOverrideManager tileOverrideManager;

	public void generateSceneData(SceneContext sceneContext)
	{
		long timerTotal = System.currentTimeMillis();
		long timerCalculateTerrainNormals, timerGenerateTerrainData, timerGenerateUnderwaterTerrain;

		long startTime = System.currentTimeMillis();
		generateUnderwaterTerrain(sceneContext);
		timerGenerateUnderwaterTerrain = (int)(System.currentTimeMillis() - startTime);
		startTime = System.currentTimeMillis();
		calculateTerrainNormals(sceneContext);
		timerCalculateTerrainNormals = (int)(System.currentTimeMillis() - startTime);
		startTime = System.currentTimeMillis();
		generateTerrainData(sceneContext);
		timerGenerateTerrainData = (int)(System.currentTimeMillis() - startTime);

		log.debug("procedural data generation took {}ms to complete", (System.currentTimeMillis() - timerTotal));
		log.debug("-- calculateTerrainNormals: {}ms", timerCalculateTerrainNormals);
		log.debug("-- generateTerrainData: {}ms", timerGenerateTerrainData);
		log.debug("-- generateUnderwaterTerrain: {}ms", timerGenerateUnderwaterTerrain);
	}

	/**
	 * Iterates through all Tiles in a given Scene, producing color and
	 * material data for each vertex of each Tile. Then adds the resulting
	 * data to appropriate HashMaps.
	 */
	private void generateTerrainData(SceneContext sceneContext)
	{
		sceneContext.vertexTerrainColor = new HashMap<>();
		// used for overriding potentially undesirable vertex colors
		// for example, colors that aren't supposed to be visible
		sceneContext.highPriorityColor = new HashMap<>();
		sceneContext.vertexTerrainTexture = new HashMap<>();
		// for faces without an overlay is set to true
		sceneContext.vertexIsUnderlay = new HashMap<>();
		// for faces with an overlay is set to true
		// the result of these maps can be used to determine the vertices
		// between underlays and overlays for custom blending
		sceneContext.vertexIsOverlay = new HashMap<>();

		Tile[][][] tiles = sceneContext.scene.getExtendedTiles();
		for (int z = 0; z < MAX_Z; ++z) {
			for (int x = 0; x < EXTENDED_SCENE_SIZE; ++x)
				for (int y = 0; y < EXTENDED_SCENE_SIZE; ++y)
					if (tiles[z][x][y] != null)
						generateDataForTile(sceneContext, tiles[z][x][y], x, y);

			for (int x = 0; x < EXTENDED_SCENE_SIZE; ++x)
				for (int y = 0; y < EXTENDED_SCENE_SIZE; ++y)
					if (tiles[z][x][y] != null && tiles[z][x][y].getBridge() != null)
						generateDataForTile(sceneContext, tiles[z][x][y].getBridge(), x, y);
		}
	}

	/**
	 * Produces color and material data for the vertices of the provided Tile.
	 * Then adds the resulting data to appropriate HashMaps.
	 *
	 * @param sceneContext that the tile is associated with
	 * @param tile         to generate terrain data for
	 */
	private void generateDataForTile(SceneContext sceneContext, Tile tile, int tileExX, int tileExY)
	{
		int faceCount;
		if (tile.getSceneTilePaint() != null) {
			faceCount = 2;
		} else if (tile.getSceneTileModel() != null) {
			faceCount = tile.getSceneTileModel().getFaceX().length;
		} else {
			return;
		}

		int[] vertexHashes = new int[faceCount * VERTICES_PER_FACE];
		int[] vertexColors = new int[faceCount * VERTICES_PER_FACE];
		TileOverride[] vertexOverrides = new TileOverride[faceCount * VERTICES_PER_FACE];
		boolean[] vertexIsOverlay = new boolean[faceCount * VERTICES_PER_FACE];
		boolean[] vertexDefaultColor = new boolean[faceCount * VERTICES_PER_FACE];

		int tileX = tileExX - SCENE_OFFSET;
		int tileY = tileExY - SCENE_OFFSET;
		int tileZ = tile.getRenderLevel();
		int[] worldPos = sceneContext.sceneToWorld(tileX, tileY, tileZ);

		Scene scene = sceneContext.scene;
		if (tile.getSceneTilePaint() != null) {
			// tile paint

			var override = tileOverrideManager.getOverride(scene, tile, worldPos);
			if (override.waterType != WaterType.NONE) {
				// skip water tiles
				return;
			}

			int swColor = tile.getSceneTilePaint().getSwColor();
			int seColor = tile.getSceneTilePaint().getSeColor();
			int nwColor = tile.getSceneTilePaint().getNwColor();
			int neColor = tile.getSceneTilePaint().getNeColor();

			vertexHashes = tileVertexKeys(scene, tile);

			if (tileExX >= EXTENDED_SCENE_SIZE - 2 && tileExY >= EXTENDED_SCENE_SIZE - 2) {
				// reduce the black scene edges by assigning surrounding colors
				neColor = swColor;
				nwColor = swColor;
				seColor = swColor;
			} else if (tileExY >= EXTENDED_SCENE_SIZE - 2) {
				nwColor = swColor;
				neColor = seColor;
			} else if (tileExX >= EXTENDED_SCENE_SIZE - 2) {
				neColor = nwColor;
				seColor = swColor;
			}

			vertexColors[0] = swColor;
			vertexColors[1] = seColor;
			vertexColors[2] = nwColor;
			vertexColors[3] = neColor;

			for (int i = 0; i < 4; i++) {
				vertexOverrides[i] = override;
				vertexIsOverlay[i] = override.queriedAsOverlay;
			}
			if (useDefaultColor(tile, override))
				for (int i = 0; i < 4; i++)
					vertexDefaultColor[i] = true;
		}
		else if (tile.getSceneTileModel() != null)
		{
			// tile model

			SceneTileModel sceneTileModel = tile.getSceneTileModel();

			final int[] faceColorsA = sceneTileModel.getTriangleColorA();
			final int[] faceColorsB = sceneTileModel.getTriangleColorB();
			final int[] faceColorsC = sceneTileModel.getTriangleColorC();

			int overlayId = OVERLAY_FLAG | scene.getOverlayIds()[tileZ][tileExX][tileExY];
			int underlayId = scene.getUnderlayIds()[tileZ][tileExX][tileExY];

			for (int face = 0; face < faceCount; face++)
			{
				int[] faceColors = new int[]{faceColorsA[face], faceColorsB[face], faceColorsC[face]};

				int[] vertexKeys = faceVertexKeys(tile, face);

				for (int vertex = 0; vertex < VERTICES_PER_FACE; vertex++)
				{
					boolean isOverlay = isOverlayFace(tile, face);

					var override = tileOverrideManager.getOverride(scene, tile, worldPos, isOverlay ? overlayId : underlayId);
					if (override.waterType != WaterType.NONE)
					{
						// skip water faces
						continue;
					}

					vertexHashes[face * VERTICES_PER_FACE + vertex] = vertexKeys[vertex];

					int color = faceColors[vertex];
					vertexColors[face * VERTICES_PER_FACE + vertex] = color;

					vertexOverrides[face * VERTICES_PER_FACE + vertex] = override;
					vertexIsOverlay[face * VERTICES_PER_FACE + vertex] = isOverlay;

					if (isOverlay && useDefaultColor(tile, override))
					{
						vertexDefaultColor[face * VERTICES_PER_FACE + vertex] = true;
					}
				}
			}
		}

		for (int vertex = 0; vertex < vertexHashes.length; vertex++)
		{
			if (vertexHashes[vertex] == 0)
			{
				continue;
			}
			if (vertexColors[vertex] < 0 || vertexColors[vertex] > 65535)
			{
				// skip invalid tile color
				continue;
			}
			// if this vertex already has a 'high priority' color assigned,
			// skip assigning a 'low priority' color unless there is no color assigned.
			// Near-solid-black tiles that are used in some places under wall objects
			boolean lowPriorityColor = vertexColors[vertex] <= 2;

			int color = vertexColors[vertex];

			float lightenMultiplier = 1.5f;
			int lightenBase = 15;
			int lightenAdd = 3;
			float darkenMultiplier = 0.5f;
			int darkenBase = 0;
			int darkenAdd = 0;

			float[] vNormals = sceneContext.vertexTerrainNormals.getOrDefault(vertexHashes[vertex], new float[] { 0, 0, 0 });

			float dot = dotLightDirectionTile(vNormals[0], vNormals[1], vNormals[2]);
			int lightness = color & 0x7F;
			lightness = (int) lerp(
				lightness,
				(int) (
					Math.max((lightness - lightenAdd), 0) * lightenMultiplier
				) + lightenBase,
				Math.max(dot, 0)
			);
			lightness = (int) (
				1.25f * lerp(
					lightness,
					(int) (Math.max((lightness - darkenAdd), 0) * darkenMultiplier) + darkenBase,
					Math.abs(Math.min(dot, 0))
				)
			);
			final int maxBrightness = 55; // reduces overexposure
			lightness = Math.min(lightness, maxBrightness);
			color = color & ~0x7F | lightness;

			boolean isOverlay = false;
			Material material = Material.DIRT_1;
			var override = vertexOverrides[vertex];
			if (override != TileOverride.NONE) {
				material = override.groundMaterial.getRandomMaterial(worldPos[2], worldPos[0], worldPos[1]);
				isOverlay = vertexIsOverlay[vertex] != override.blendedAsOpposite;
				color = override.modifyColor(color);
			}

			vertexColors[vertex] = color;

			// mark the vertex as either an overlay or underlay.
			// this is used to determine how to blend between vertex colors
			if (isOverlay)
			{
				sceneContext.vertexIsOverlay.put(vertexHashes[vertex], true);
			}
			else
			{
				sceneContext.vertexIsUnderlay.put(vertexHashes[vertex], true);
			}

			// add color and texture to hashmap
			if ((!lowPriorityColor || !sceneContext.highPriorityColor.containsKey(vertexHashes[vertex])) && !vertexDefaultColor[vertex])
			{
				boolean shouldWrite = isOverlay || !sceneContext.vertexTerrainColor.containsKey(vertexHashes[vertex]);
				if (shouldWrite || !sceneContext.vertexTerrainColor.containsKey(vertexHashes[vertex]))
					sceneContext.vertexTerrainColor.put(vertexHashes[vertex], vertexColors[vertex]);

				if (shouldWrite || !sceneContext.vertexTerrainTexture.containsKey(vertexHashes[vertex]))
					sceneContext.vertexTerrainTexture.put(vertexHashes[vertex], material);

				if (!lowPriorityColor)
					sceneContext.highPriorityColor.put(vertexHashes[vertex], true);
			}
		}
	}

	/**
	 * Generates underwater terrain data by iterating through all Tiles in a given
	 * Scene, increasing the depth of each tile based on its distance from the shore.
	 * Then stores the resulting data in a HashMap.
	 */
	private void generateUnderwaterTerrain(SceneContext sceneContext)
	{
		// true if a tile contains at least 1 face which qualifies as water
		sceneContext.tileIsWater = new boolean[MAX_Z][EXTENDED_SCENE_SIZE][EXTENDED_SCENE_SIZE];
		// true if a vertex is part of a face which qualifies as water; non-existent if not
		sceneContext.vertexIsWater = new HashMap<>();
		// true if a vertex is part of a face which qualifies as land; non-existent if not
		// tiles along the shoreline will be true for both vertexIsWater and vertexIsLand
		sceneContext.vertexIsLand = new HashMap<>();
		// if true, the tile will be skipped when the scene is drawn
		// this is due to certain edge cases with water on the same X/Y on different planes
		sceneContext.skipTile = new boolean[MAX_Z][EXTENDED_SCENE_SIZE][EXTENDED_SCENE_SIZE];
		// the height adjustment for each vertex, to be applied to the vertex'
		// real height to create the underwater terrain
		sceneContext.vertexUnderwaterDepth = new HashMap<>();
		// the basic 'levels' of underwater terrain, used to sink terrain based on its distance
		// from the shore, then used to produce the world-space height offset
		// 0 = land
		sceneContext.underwaterDepthLevels = new int[MAX_Z][EXTENDED_SCENE_SIZE + 1][EXTENDED_SCENE_SIZE + 1];
		// the world-space height offsets of each vertex on the tile grid
		// these offsets are interpolated to calculate offsets for vertices not on the grid (tilemodels)
		final int[][][] underwaterDepths = new int[MAX_Z][EXTENDED_SCENE_SIZE + 1][EXTENDED_SCENE_SIZE + 1];

		for (int z = 0; z < MAX_Z; ++z)
		{
			for (int x = 0; x < EXTENDED_SCENE_SIZE; ++x) {
				// set the array to 1 initially
				// this assumes that all vertices are water;
				// we will set non-water vertices to 0 in the next loop
				Arrays.fill(sceneContext.underwaterDepthLevels[z][x], 1);
			}
		}

		Scene scene = sceneContext.scene;
		Tile[][][] tiles = scene.getExtendedTiles();

		// figure out which vertices are water and assign some data
		for (int z = 0; z < MAX_Z; ++z) {
			for (int x = 0; x < EXTENDED_SCENE_SIZE; ++x) {
				for (int y = 0; y < EXTENDED_SCENE_SIZE; ++y) {
					if (tiles[z][x][y] == null) {
						sceneContext.underwaterDepthLevels[z][x][y] = 0;
						sceneContext.underwaterDepthLevels[z][x + 1][y] = 0;
						sceneContext.underwaterDepthLevels[z][x][y + 1] = 0;
						sceneContext.underwaterDepthLevels[z][x + 1][y + 1] = 0;
						continue;
					}

					Tile tile = tiles[z][x][y];
					if (tile.getBridge() != null) {
						tile = tile.getBridge();
					}

					if (tile.getSceneTilePaint() != null) {
						int[] vertexKeys = tileVertexKeys(scene, tile);

						int[] worldPos = sceneContext.extendedSceneToWorld(x, y, tile.getRenderLevel());
						var override = tileOverrideManager.getOverride(scene, tile, worldPos);
						if (seasonalWaterType(override, tile.getSceneTilePaint().getTexture()) == WaterType.NONE) {
							for (int vertexKey : vertexKeys) {
								if (tile.getSceneTilePaint().getNeColor() != 12345678) {
									sceneContext.vertexIsLand.put(vertexKey, true);
								}
							}

							sceneContext.underwaterDepthLevels[z][x][y] = 0;
							sceneContext.underwaterDepthLevels[z][x + 1][y] = 0;
							sceneContext.underwaterDepthLevels[z][x][y + 1] = 0;
							sceneContext.underwaterDepthLevels[z][x + 1][y + 1] = 0;
						} else {
							// Stop tiles on the same X,Y coordinates on different planes from
							// each generating water. Prevents undesirable results in certain places.
							if (z > 0) {
								boolean continueLoop = false;

								for (int checkZ = 0; checkZ < z; ++checkZ) {
									if (sceneContext.tileIsWater[checkZ][x][y]) {
										sceneContext.underwaterDepthLevels[z][x][y] = 0;
										sceneContext.underwaterDepthLevels[z][x + 1][y] = 0;
										sceneContext.underwaterDepthLevels[z][x][y + 1] = 0;
										sceneContext.underwaterDepthLevels[z][x + 1][y + 1] = 0;

										sceneContext.skipTile[z][x][y] = true;

										continueLoop = true;

										break;
									}
								}

								if (continueLoop)
									continue;
							}

							sceneContext.tileIsWater[z][x][y] = true;

							for (int vertexKey : vertexKeys)
							{
								sceneContext.vertexIsWater.put(vertexKey, true);
							}
						}
					}
					else if (tile.getSceneTileModel() != null)
					{
						SceneTileModel model = tile.getSceneTileModel();

						int faceCount = model.getFaceX().length;

						int tileZ = tile.getRenderLevel();
						int[] worldPos = sceneContext.extendedSceneToWorld(x, y, tileZ);
						int overlayId = OVERLAY_FLAG | scene.getOverlayIds()[tileZ][x][y];
						int underlayId = scene.getUnderlayIds()[tileZ][x][y];

						// Stop tiles on the same X,Y coordinates on different planes from
						// each generating water. Prevents undesirable results in certain places.
						if (z > 0)
						{
							boolean tileIncludesWater = false;

							for (int face = 0; face < faceCount; face++)
							{
								boolean isOverlay = ProceduralGenerator.isOverlayFace(tile, face);
								var override = tileOverrideManager.getOverride(scene, tile, worldPos, isOverlay ? overlayId : underlayId);
								int textureId = model.getTriangleTextureId() == null ? -1 :
									model.getTriangleTextureId()[face];
								if (seasonalWaterType(override, textureId) != WaterType.NONE)
								{
									tileIncludesWater = true;
									break;
								}
							}

							if (tileIncludesWater)
							{
								boolean continueLoop = false;

								for (int checkZ = 0; checkZ < z; ++checkZ)
								{
									if (sceneContext.tileIsWater[checkZ][x][y])
									{
										sceneContext.underwaterDepthLevels[z][x][y] = 0;
										sceneContext.underwaterDepthLevels[z][x+1][y] = 0;
										sceneContext.underwaterDepthLevels[z][x][y+1] = 0;
										sceneContext.underwaterDepthLevels[z][x+1][y+1] = 0;

										sceneContext.skipTile[z][x][y] = true;

										continueLoop = true;

										break;
									}
								}

								if (continueLoop)
									continue;
							}
						}

						for (int face = 0; face < faceCount; face++)
						{
							int[][] vertices = faceVertices(tile, face);
							int[] vertexKeys = faceVertexKeys(tile, face);

							boolean isOverlay = ProceduralGenerator.isOverlayFace(tile, face);
							var override = tileOverrideManager.getOverride(scene, tile, worldPos, isOverlay ? overlayId : underlayId);
							int textureId = model.getTriangleTextureId() == null ? -1 :
								model.getTriangleTextureId()[face];
							if (seasonalWaterType(override, textureId) == WaterType.NONE)
							{
								for (int vertex = 0; vertex < VERTICES_PER_FACE; vertex++)
								{
									if (model.getTriangleColorA()[face] != 12345678)
										sceneContext.vertexIsLand.put(vertexKeys[vertex], true);

									if (vertices[vertex][0] % LOCAL_TILE_SIZE == 0 &&
										vertices[vertex][1] % LOCAL_TILE_SIZE == 0
									) {
										int vX = vertices[vertex][0] / LOCAL_TILE_SIZE + SCENE_OFFSET;
										int vY = vertices[vertex][1] / LOCAL_TILE_SIZE + SCENE_OFFSET;

										sceneContext.underwaterDepthLevels[z][vX][vY] = 0;
									}
								}
							}
							else
							{
								sceneContext.tileIsWater[z][x][y] = true;

								for (int vertex = 0; vertex < VERTICES_PER_FACE; vertex++)
								{
									sceneContext.vertexIsWater.put(vertexKeys[vertex], true);
								}
							}
						}
					}
					else
					{
						sceneContext.underwaterDepthLevels[z][x][y] = 0;
						sceneContext.underwaterDepthLevels[z][x+1][y] = 0;
						sceneContext.underwaterDepthLevels[z][x][y+1] = 0;
						sceneContext.underwaterDepthLevels[z][x+1][y+1] = 0;
					}
				}
			}
		}

		// Sink terrain further from shore by desired levels.
		for (int level = 0; level < DEPTH_LEVEL_SLOPE.length - 1; level++)
		{
			for (int z = 0; z < MAX_Z; ++z)
			{
				for (int x = 0; x < sceneContext.underwaterDepthLevels[z].length; x++)
				{
					for (int y = 0; y < sceneContext.underwaterDepthLevels[z][x].length; y++)
					{
						if (sceneContext.underwaterDepthLevels[z][x][y] == 0)
						{
							// Skip the tile if it isn't water.
							continue;
						}
						// If it's on the edge of the scene, reset the depth so
						// it creates a 'wall' to prevent fog from passing through.
						// Not incredibly effective, but better than nothing.
						if (x == 0 || y == 0 || x == EXTENDED_SCENE_SIZE || y == EXTENDED_SCENE_SIZE) {
							sceneContext.underwaterDepthLevels[z][x][y] = 0;
							continue;
						}

						int tileHeight = sceneContext.underwaterDepthLevels[z][x][y];
						if (sceneContext.underwaterDepthLevels[z][x - 1][y] < tileHeight)
						{
							// West
							continue;
						}
						if (x < sceneContext.underwaterDepthLevels[z].length - 1 && sceneContext.underwaterDepthLevels[z][x + 1][y] < tileHeight)
						{
							// East
							continue;
						}
						if (sceneContext.underwaterDepthLevels[z][x][y - 1] < tileHeight)
						{
							// South
							continue;
						}
						if (y < sceneContext.underwaterDepthLevels[z].length - 1 && sceneContext.underwaterDepthLevels[z][x][y + 1] < tileHeight)
						{
							// North
							continue;
						}
						// At this point, it's surrounded only by other depth-adjusted vertices.
						sceneContext.underwaterDepthLevels[z][x][y]++;
					}
				}
			}
		}

		// Adjust the height levels to world coordinate offsets and add to an array.
		for (int z = 0; z < MAX_Z; ++z)
		{
			for (int x = 0; x < sceneContext.underwaterDepthLevels[z].length; x++)
			{
				for (int y = 0; y < sceneContext.underwaterDepthLevels[z][x].length; y++)
				{
					if (sceneContext.underwaterDepthLevels[z][x][y] == 0)
					{
						continue;
					}
					int depth = DEPTH_LEVEL_SLOPE[sceneContext.underwaterDepthLevels[z][x][y] - 1];
					int heightOffset = (int) (depth * .55f); // legacy weirdness
					underwaterDepths[z][x][y] = heightOffset;
				}
			}
		}

		// Store the height offsets in a hashmap and calculate interpolated
		// height offsets for non-corner vertices.
		for (int z = 0; z < MAX_Z; ++z) {
			for (int x = 0; x < EXTENDED_SCENE_SIZE; ++x) {
				for (int y = 0; y < EXTENDED_SCENE_SIZE; ++y) {
					if (!sceneContext.tileIsWater[z][x][y]) {
						continue;
					}

					Tile tile = tiles[z][x][y];
					if (tile == null) {
						continue;
					}

					if (tile.getBridge() != null) {
						tile = tile.getBridge();
					}
					if (tile.getSceneTilePaint() != null) {
						int[] vertexKeys = tileVertexKeys(scene, tile);

						int swVertexKey = vertexKeys[0];
						int seVertexKey = vertexKeys[1];
						int nwVertexKey = vertexKeys[2];
						int neVertexKey = vertexKeys[3];

						sceneContext.vertexUnderwaterDepth.put(swVertexKey, underwaterDepths[z][x][y]);
						sceneContext.vertexUnderwaterDepth.put(seVertexKey, underwaterDepths[z][x + 1][y]);
						sceneContext.vertexUnderwaterDepth.put(nwVertexKey, underwaterDepths[z][x][y + 1]);
						sceneContext.vertexUnderwaterDepth.put(neVertexKey, underwaterDepths[z][x + 1][y + 1]);
					}
					else if (tile.getSceneTileModel() != null)
					{
						SceneTileModel sceneTileModel = tile.getSceneTileModel();

						int faceCount = sceneTileModel.getFaceX().length;

						for (int face = 0; face < faceCount; face++)
						{
							int[][] vertices = faceVertices(tile, face);
							int[] vertexKeys = faceVertexKeys(tile, face);

							for (int vertex = 0; vertex < VERTICES_PER_FACE; vertex++)
							{
								if (vertices[vertex][0] % LOCAL_TILE_SIZE == 0 &&
									vertices[vertex][1] % LOCAL_TILE_SIZE == 0
								) {
									// The vertex is at the corner of the tile;
									// simply use the offset in the tile grid array.

									int vX = vertices[vertex][0] / LOCAL_TILE_SIZE + SCENE_OFFSET;
									int vY = vertices[vertex][1] / LOCAL_TILE_SIZE + SCENE_OFFSET;

									sceneContext.vertexUnderwaterDepth.put(vertexKeys[vertex], underwaterDepths[z][vX][vY]);
								}
								else
								{
									// If the tile is a tile model and this vertex is shared only by faces that are water,
									// interpolate between the height offsets at each corner to get the height offset
									// of the vertex.

									int tileX = x - SCENE_OFFSET;
									int tileY = y - SCENE_OFFSET;
									int localVertexX = vertices[vertex][0] - (tileX * LOCAL_TILE_SIZE);
									int localVertexY = vertices[vertex][1] - (tileY * LOCAL_TILE_SIZE);
									float lerpX = (float) localVertexX / (float) LOCAL_TILE_SIZE;
									float lerpY = (float) localVertexY / (float) LOCAL_TILE_SIZE;
									float northHeightOffset = lerp(
										underwaterDepths[z][x][y + 1],
										underwaterDepths[z][x + 1][y + 1],
										lerpX
									);
									float southHeightOffset = lerp(underwaterDepths[z][x][y], underwaterDepths[z][x + 1][y], lerpX);
									int heightOffset = (int) lerp(southHeightOffset, northHeightOffset, lerpY);

									if (!sceneContext.vertexIsLand.containsKey(vertexKeys[vertex])) {
										sceneContext.vertexUnderwaterDepth.put(vertexKeys[vertex], heightOffset);
									}
								}
							}
						}
					}
				}
			}
		}
	}

	/**
	 * Iterates through all Tiles in a given Scene, calculating vertex normals
	 * for each one, then stores resulting normal data in a HashMap.
	 */
	private void calculateTerrainNormals(SceneContext sceneContext)
	{
		sceneContext.vertexTerrainNormals = new HashMap<>();

		for (Tile[][] plane : sceneContext.scene.getExtendedTiles()) {
			for (Tile[] column : plane) {
				for (Tile tile : column) {
					if (tile != null) {
						boolean isBridge = false;

						if (tile.getBridge() != null) {
							calculateNormalsForTile(sceneContext, tile.getBridge(), false);
							isBridge = true;
						}
						calculateNormalsForTile(sceneContext, tile, isBridge);
					}
				}
			}
		}
	}

	/**
	 * Calculates vertex normals for a given Tile,
	 * then stores resulting normal data in a HashMap.
	 *
	 * @param sceneContext that the tile is associated with
	 * @param tile         to calculate normals for
	 * @param isBridge     whether the tile is a bridge tile, i.e. tile above
	 */
	private void calculateNormalsForTile(SceneContext sceneContext, Tile tile, boolean isBridge)
	{
		// Make array of tile's tris with vertices
		int[][][] faceVertices; // Array of tile's tri vertices
		int[][] faceVertexKeys;

		if (tile.getSceneTileModel() != null)
		{
			// Tile model
			SceneTileModel tileModel = tile.getSceneTileModel();
			faceVertices = new int[tileModel.getFaceX().length][VERTICES_PER_FACE][3];
			faceVertexKeys = new int[tileModel.getFaceX().length][VERTICES_PER_FACE];

			for (int face = 0; face < tileModel.getFaceX().length; face++)
			{
				int[][] vertices = faceVertices(tile, face);

				faceVertices[face][0] = new int[]{vertices[0][0], vertices[0][1], vertices[0][2]};
				faceVertices[face][2] = new int[]{vertices[1][0], vertices[1][1], vertices[1][2]};
				faceVertices[face][1] = new int[]{vertices[2][0], vertices[2][1], vertices[2][2]};

				int[] vertexKeys = faceVertexKeys(tile, face);
				faceVertexKeys[face][0] = vertexKeys[0];
				faceVertexKeys[face][2] = vertexKeys[1];
				faceVertexKeys[face][1] = vertexKeys[2];
			}
		}
		else
		{
			faceVertices = new int[2][VERTICES_PER_FACE][3];
			faceVertexKeys = new int[VERTICES_PER_FACE][3];
			int[][] vertices = tileVertices(sceneContext.scene, tile);
			faceVertices[0] = new int[][]{vertices[3], vertices[1], vertices[2]};
			faceVertices[1] = new int[][]{vertices[0], vertices[2], vertices[1]};

			int[] vertexKeys = tileVertexKeys(sceneContext.scene, tile);
			faceVertexKeys[0] = new int[]{vertexKeys[3], vertexKeys[1], vertexKeys[2]};
			faceVertexKeys[1] = new int[]{vertexKeys[0], vertexKeys[2], vertexKeys[1]};
		}

		// Loop through tris to calculate and accumulate normals
		for (int face = 0; face < faceVertices.length; face++)
		{
			// XYZ
			int[] vertexHeights = new int[]{faceVertices[face][0][2], faceVertices[face][1][2], faceVertices[face][2][2]};
			if (!isBridge)
			{
				vertexHeights[0] += sceneContext.vertexUnderwaterDepth.getOrDefault(faceVertexKeys[face][0], 0);
				vertexHeights[1] += sceneContext.vertexUnderwaterDepth.getOrDefault(faceVertexKeys[face][1], 0);
				vertexHeights[2] += sceneContext.vertexUnderwaterDepth.getOrDefault(faceVertexKeys[face][2], 0);
			}

			float[] vertexNormals = calculateSurfaceNormals(
				new float[] {
					faceVertices[face][0][0],
					faceVertices[face][0][1],
					vertexHeights[0]
				},
				new float[] {
					faceVertices[face][1][0],
					faceVertices[face][1][1],
					vertexHeights[1]
				},
				new float[] {
					faceVertices[face][2][0],
					faceVertices[face][2][1],
					vertexHeights[2]
				}
			);

			for (int vertex = 0; vertex < VERTICES_PER_FACE; vertex++)
			{
				int vertexKey = faceVertexKeys[face][vertex];
				// accumulate normals to hashmap
				sceneContext.vertexTerrainNormals.merge(vertexKey, vertexNormals, (a, b) -> add(a, a, b));
			}
		}
	}

	public boolean useDefaultColor(Tile tile, TileOverride override)
	{
		if ((tile.getSceneTilePaint() != null && tile.getSceneTilePaint().getTexture() >= 0) ||
			(tile.getSceneTileModel() != null && tile.getSceneTileModel().getTriangleTextureId() != null))
		{
			// skip tiles with textures provided by default
			return true;
		}

		if (override == TileOverride.NONE)
			return false;

		return !override.blended;
	}

	public WaterType seasonalWaterType(TileOverride override, int textureId)
	{
		var waterType = override.waterType;

		// As a fallback, always consider vanilla textured water tiles as water
		// We purposefully ignore material replacements here such as ice from the winter theme
		if (waterType == WaterType.NONE) {
			if (textureId == Material.WATER_FLAT.vanillaTextureIndex ||
				textureId == Material.WATER_FLAT_2.vanillaTextureIndex) {
				waterType = WaterType.WATER_FLAT;
			} else if (textureId == Material.SWAMP_WATER_FLAT.vanillaTextureIndex) {
				waterType = WaterType.SWAMP_WATER_FLAT;
			}
			return waterType;
		}

		if (waterType == WaterType.WATER && plugin.configSeasonalTheme == SeasonalTheme.WINTER)
			return WaterType.ICE;

		return waterType;
	}

	private static boolean[] getTileOverlayTris(int tileShapeIndex)
	{
		if (tileShapeIndex >= TILE_OVERLAY_TRIS.length)
		{
			log.debug("getTileOverlayTris(): unknown tileShapeIndex ({})", tileShapeIndex);
			return new boolean[10]; // false
		}
		else
		{
			return TILE_OVERLAY_TRIS[tileShapeIndex];
		}
	}

	public static boolean isOverlayFace(Tile tile, int face) {
		int tileShapeIndex = tile.getSceneTileModel().getShape() - 1;
		if (face >= getTileOverlayTris(tileShapeIndex).length) {
			return false;
		}
		return getTileOverlayTris(tileShapeIndex)[face];
	}

	private static int[][] tileVertices(Scene scene, Tile tile) {
		int tileX = tile.getSceneLocation().getX();
		int tileY = tile.getSceneLocation().getY();
		int tileExX = tileX + SCENE_OFFSET;
		int tileExY = tileY + SCENE_OFFSET;
		int tileZ = tile.getRenderLevel();
		int[][][] tileHeights = scene.getTileHeights();

		int[] swVertex = new int[] {
			tileX * LOCAL_TILE_SIZE,
			tileY * LOCAL_TILE_SIZE,
			tileHeights[tileZ][tileExX][tileExY]
		};
		int[] seVertex = new int[] {
			(tileX + 1) * LOCAL_TILE_SIZE,
			tileY * LOCAL_TILE_SIZE,
			tileHeights[tileZ][tileExX + 1][tileExY]
		};
		int[] nwVertex = new int[] {
			tileX * LOCAL_TILE_SIZE,
			(tileY + 1) * LOCAL_TILE_SIZE,
			tileHeights[tileZ][tileExX][tileExY + 1]
		};
		int[] neVertex = new int[] {
			(tileX + 1) * LOCAL_TILE_SIZE,
			(tileY + 1) * LOCAL_TILE_SIZE,
			tileHeights[tileZ][tileExX + 1][tileExY + 1]
		};

		return new int[][] { swVertex, seVertex, nwVertex, neVertex };
	}

	private static int[][] faceVertices(Tile tile, int face)
	{
		SceneTileModel sceneTileModel = tile.getSceneTileModel();

		final int[] faceA = sceneTileModel.getFaceX();
		final int[] faceB = sceneTileModel.getFaceY();
		final int[] faceC = sceneTileModel.getFaceZ();

		final int[] vertexX = sceneTileModel.getVertexX();
		final int[] vertexY = sceneTileModel.getVertexY();
		final int[] vertexZ = sceneTileModel.getVertexZ();

		int vertexFacesA = faceA[face];
		int vertexFacesB = faceB[face];
		int vertexFacesC = faceC[face];

		// scene X
		int sceneVertexXA = vertexX[vertexFacesA];
		int sceneVertexXB = vertexX[vertexFacesB];
		int sceneVertexXC = vertexX[vertexFacesC];
		// scene Y
		int sceneVertexZA = vertexZ[vertexFacesA];
		int sceneVertexZB = vertexZ[vertexFacesB];
		int sceneVertexZC = vertexZ[vertexFacesC];
		// scene Z - heights
		int sceneVertexYA = vertexY[vertexFacesA];
		int sceneVertexYB = vertexY[vertexFacesB];
		int sceneVertexYC = vertexY[vertexFacesC];

		int[] vertexA = new int[] { sceneVertexXA, sceneVertexZA, sceneVertexYA };
		int[] vertexB = new int[] { sceneVertexXB, sceneVertexZB, sceneVertexYB };
		int[] vertexC = new int[] { sceneVertexXC, sceneVertexZC, sceneVertexYC };

		return new int[][] { vertexA, vertexB, vertexC };
	}

	public static int[][] faceLocalVertices(Tile tile, int face) {
		if (tile.getSceneTileModel() == null)
			return new int[0][0];

		int x = tile.getSceneLocation().getX();
		int y = tile.getSceneLocation().getY();
		int baseX = x * LOCAL_TILE_SIZE;
		int baseY = y * LOCAL_TILE_SIZE;

		int[][] vertices = faceVertices(tile, face);
		for (int[] vertex : vertices) {
			vertex[0] -= baseX;
			vertex[1] -= baseY;
		}
		return vertices;
	}

	/**
	 * Gets the vertex keys of a Tile Paint tile for use in retrieving data from hashmaps.
	 *
	 * @param scene that the tile is from
	 * @param tile  to get the vertex keys of
	 * @return Vertex keys in following order: SW, SE, NW, NE
	 */
	public static int[] tileVertexKeys(Scene scene, Tile tile)
	{
		int[][] tileVertices = tileVertices(scene, tile);
		int[] vertexHashes = new int[tileVertices.length];

		for (int vertex = 0; vertex < tileVertices.length; ++vertex)
			vertexHashes[vertex] = vertexHash(tileVertices[vertex]);

		return vertexHashes;
	}

	public static int[] faceVertexKeys(Tile tile, int face)
	{
		int[][] faceVertices = faceVertices(tile, face);
		int[] vertexHashes = new int[faceVertices.length];

		for (int vertex = 0; vertex < faceVertices.length; ++vertex)
			vertexHashes[vertex] = vertexHash(faceVertices[vertex]);

		return vertexHashes;
	}

	private static final int[] tzHaarRecolored = new int[4];
	// used when calculating the gradient to apply to the walls of TzHaar
	// to emulate the style from 2008 HD rework
	private static final int[] gradientBaseColor = new int[]{3, 4, 26};
	private static final int[] gradientDarkColor = new int[]{3, 4, 10};
	private static final int gradientBottom = 200;
	private static final int gradientTop = -200;

	public static int[] recolorTzHaar(
		ModelOverride modelOverride,
		Model model,
		int face,
		int packedAlphaPriority,
		ObjectType objectType,
		int color1,
		int color2,
		int color3
	) {
		// shift model hues from red->yellow
		int hue = 7;
		int color1H = hue;
		int color2H = hue;
		int color3H = hue;
		int color1S = color1 >> 7 & 7;
		int color1L = color1 & 0x7F;
		int color2S = color2 >> 7 & 7;
		int color2L = color2 & 0x7F;
		int color3S = color3 >> 7 & 7;
		int color3L = color3 & 0x7F;

		// recolor tzhaar to look like the 2008+ HD version
		if (objectType == ObjectType.GROUND_OBJECT) {
			// remove the black parts of floor objects to allow the ground to show
			// so we can apply textures, ground blending, etc. to it
			if (color1S <= 1)
				packedAlphaPriority = 0xFF << 24;
		}

		if (modelOverride.tzHaarRecolorType == TzHaarRecolorType.GRADIENT) {
			final int triA = model.getFaceIndices1()[face];
			final int triB = model.getFaceIndices2()[face];
			final int triC = model.getFaceIndices3()[face];
			final float[] yVertices = model.getVerticesY();
			float heightA = yVertices[triA];
			float heightB = yVertices[triB];
			float heightC = yVertices[triC];

			// apply coloring to the rocky walls
			if (color1L < 20) {
				float pos = clamp((heightA - gradientTop) / (float) gradientBottom, 0.0f, 1.0f);
				color1H = (int) lerp(gradientDarkColor[0], gradientBaseColor[0], pos);
				color1S = (int) lerp(gradientDarkColor[1], gradientBaseColor[1], pos);
				color1L = (int) lerp(gradientDarkColor[2], gradientBaseColor[2], pos);
			}

			if (color2L < 20)
			{
				float pos = clamp((heightB - gradientTop) / (float) gradientBottom, 0.0f, 1.0f);
				color2H = (int) lerp(gradientDarkColor[0], gradientBaseColor[0], pos);
				color2S = (int) lerp(gradientDarkColor[1], gradientBaseColor[1], pos);
				color2L = (int) lerp(gradientDarkColor[2], gradientBaseColor[2], pos);
			}

			if (color3L < 20)
			{
				float pos = clamp((heightC - gradientTop) / (float) gradientBottom, 0.0f, 1.0f);
				color3H = (int) lerp(gradientDarkColor[0], gradientBaseColor[0], pos);
				color3S = (int) lerp(gradientDarkColor[1], gradientBaseColor[1], pos);
				color3L = (int) lerp(gradientDarkColor[2], gradientBaseColor[2], pos);
			}
		}
		else if (modelOverride.tzHaarRecolorType == TzHaarRecolorType.HUE_SHIFT)
		{
			// objects around the entrance to The Inferno only need a hue-shift
			// and very slight lightening to match the lightened terrain
			color1L += 1;
			color2L += 1;
			color3L += 1;
		}

		tzHaarRecolored[0] = color1H << 10 | color1S << 7 | color1L;
		tzHaarRecolored[1] = color2H << 10 | color2S << 7 | color2L;
		tzHaarRecolored[2] = color3H << 10 | color3S << 7 | color3L;
		tzHaarRecolored[3] = packedAlphaPriority;

		return tzHaarRecolored;
	}
}

package rs117.hd.scene.tile_overrides;

import com.google.gson.JsonElement;
import java.util.Map;
import java.util.Set;
import java.util.function.Predicate;
import javax.annotation.Nullable;
import lombok.extern.slf4j.Slf4j;
import rs117.hd.utils.Props;
import rs117.hd.utils.VariableSupplier;

import static rs117.hd.utils.ExpressionParser.asExpression;
import static rs117.hd.utils.ExpressionParser.parseExpression;

@Slf4j
public class ExpressionBasedReplacement {
	public final TileOverride replacement;
	public final transient Predicate<VariableSupplier> predicate;

	private transient boolean isConstant;

	public boolean isConstant() {
		return isConstant;
	}

	public ExpressionBasedReplacement(
		@Nullable TileOverride replacement,
		@Nullable Map<String, Object> constants,
		JsonElement jsonExpressions
	) {
		this(replacement, constants, jsonToStringExpressions(jsonExpressions));
	}

	public ExpressionBasedReplacement(@Nullable TileOverride replacement, @Nullable Map<String, Object> constants, String... cases) {
		this.replacement = replacement;
		predicate = parse(constants, cases);
	}

	private static String[] jsonToStringExpressions(JsonElement jsonExpressions) {
		if (jsonExpressions == null || jsonExpressions.isJsonNull())
			return new String[0];

		if (jsonExpressions.isJsonPrimitive())
			return new String[] { jsonExpressions.getAsJsonPrimitive().getAsString() };

		if (jsonExpressions.isJsonArray()) {
			var array = jsonExpressions.getAsJsonArray();
			var expressions = new String[array.size()];
			int i = 0;
			for (var primitive : array)
				expressions[i++] = primitive.getAsString();
			return expressions;
		}

		throw new IllegalStateException("Unsupported expression format: '" + jsonExpressions + "'");
	}

	private Predicate<VariableSupplier> parse(@Nullable Map<String, Object> constants, String... expressions) {
		if (expressions.length == 0) {
			isConstant = true;
			return vars -> false;
		}

		Predicate<VariableSupplier> predicate = null;
		for (String expression : expressions) {
			var result = parseExpression(expression, constants);

			if (result instanceof Boolean) {
				isConstant = true;
				return vars -> (boolean) result;
			}

			var expr = asExpression(result);
			var p = expr.toPredicate();
			predicate = predicate == null ? p : predicate.or(p);

			if (Props.DEVELOPMENT) {
				// Ensure all variables are defined
				final Set<String> knownVariables = Set.of("h", "s", "l");
				for (var variable : expr.variables)
					if (!knownVariables.contains(variable))
						throw new IllegalStateException("Expression '" + expression + "' contains unknown variable '" + variable + "'");
			}
		}
		return predicate;
	}
}

package rs117.hd.scene.tile_overrides;

import com.google.gson.JsonElement;
import com.google.gson.annotations.SerializedName;
import java.util.ArrayList;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import javax.annotation.Nullable;
import lombok.AllArgsConstructor;
import lombok.NoArgsConstructor;
import lombok.NonNull;
import lombok.extern.slf4j.Slf4j;
import rs117.hd.data.WaterType;
import rs117.hd.data.environments.Area;
import rs117.hd.data.materials.GroundMaterial;
import rs117.hd.utils.Props;

import static rs117.hd.utils.HDUtils.clamp;

@Slf4j
@NoArgsConstructor
@AllArgsConstructor
public class TileOverride {
	public static final int OVERLAY_FLAG = 1 << 31;
	public static final TileOverride NONE = new TileOverride("NONE", GroundMaterial.DIRT);

	@Nullable
	public String name;
	public String description;
	public Area area = Area.NONE;
	public int[] overlayIds;
	public int[] underlayIds;
	public GroundMaterial groundMaterial = GroundMaterial.NONE;
	public WaterType waterType = WaterType.NONE;
	public boolean blended = true;
	public boolean blendedAsOpposite = false;
	public int shiftHue;
	public int minHue;
	public int maxHue = 63;
	public int shiftSaturation;
	public int minSaturation;
	public int maxSaturation = 7;
	public int shiftLightness;
	public int minLightness;
	public int maxLightness = 127;
	public int uvOrientation;
	public float uvScale = 1;
	@SerializedName("replacements")
	public LinkedHashMap<String, JsonElement> rawReplacements;

	public transient int index;
	public transient int[] ids;
	public transient List<ExpressionBasedReplacement> replacements;
	public transient boolean queriedAsOverlay;

	private TileOverride(@Nullable String name, GroundMaterial groundMaterial) {
		this.name = name;
		this.groundMaterial = groundMaterial;
		this.index = Integer.MAX_VALUE; // Prioritize any-match overrides over this
	}

	@Override
	public String toString() {
		if (name != null)
			return name;
		if (description != null)
			return description;
		if (area != null)
			return area.name();
		return "Unnamed";
	}

	public void normalize(TileOverride[] allOverrides, Map<String, Object> constants) {
		int numOverlays = overlayIds == null ? 0 : overlayIds.length;
		int numUnderlays = underlayIds == null ? 0 : underlayIds.length;
		int numIds = numOverlays + numUnderlays;
		if (numIds > 0) {
			ids = new int[numOverlays + numUnderlays];
			int i = 0;
			for (int j = 0; j < numOverlays; j++) {
				int id = overlayIds[j];
				ids[i++] = OVERLAY_FLAG | id;
			}
			for (int j = 0; j < numUnderlays; j++) {
				int id = underlayIds[j];
				ids[i++] = id;
			}
		}

		if (area == null) {
			log.warn("Undefined area in tile override: {}", this);
			area = Area.NONE;
		}
		if (groundMaterial == null) {
			log.warn("Undefined ground material in tile override: {}", this);
			groundMaterial = GroundMaterial.NONE;
		}
		if (waterType == null) {
			log.warn("Undefined water type in tile override: {}", this);
			waterType = WaterType.NONE;
		}

		// Convert UV scale to reciprocal, so we can multiply instead of dividing later
		uvScale = 1 / uvScale;

		if (rawReplacements != null) {
			replacements = new ArrayList<>();
			for (var entry : rawReplacements.entrySet()) {
				var expr = parseReplacementExpressions(entry, allOverrides, constants);

				if (expr.isConstant()) {
					if (expr.predicate.test(null)) {
						replacements.add(expr);
						// Parse unnecessary replacements only during development
						if (!Props.DEVELOPMENT)
							break;
					} else {
						continue;
					}
				}

				replacements.add(expr);
			}
		}
	}

	@NonNull
	private static ExpressionBasedReplacement parseReplacementExpressions(
		Map.Entry<String, JsonElement> expressions,
		TileOverride[] allOverrides,
		Map<String, Object> constants
	) {
		var name = expressions.getKey();
		TileOverride replacement = null;
		if (name == null) {
			log.warn("Null is reserved for future use");
			replacement = NONE;
		} else {
			if (name.equals(NONE.name)) {
				replacement = NONE;
			} else {
				for (var other : allOverrides) {
					if (name.equals(other.name)) {
						replacement = other;
						break;
					}
				}
				if (replacement == null) {
					replacement = NONE;
					if (Props.DEVELOPMENT)
						throw new IllegalStateException("Unknown tile override: '" + name + "'");
				}
			}
		}

		return new ExpressionBasedReplacement(replacement, constants, expressions.getValue());
	}

	public TileOverride resolveConstantReplacements() {
		if (replacements != null) {
			// Check if the override always resolves to the same replacement override
			for (var replacement : replacements) {
				if (!replacement.isConstant())
					break;

				if (replacement.predicate.test(null))
					return replacement.replacement;
			}
		}

		return this;
	}

	public int modifyColor(int jagexHsl) {
		int h = jagexHsl >> 10 & 0x3F;
		h += shiftHue;
		h = clamp(h, minHue, maxHue);

		int s = jagexHsl >> 7 & 7;
		s += shiftSaturation;
		s = clamp(s, minSaturation, maxSaturation);

		int l = jagexHsl & 0x7F;
		l += shiftLightness;
		l = clamp(l, minLightness, maxLightness);

		return h << 10 | s << 7 | l;
	}
}

package rs117.hd.scene;

import com.google.common.collect.Sets;
import java.util.Arrays;
import java.util.HashMap;
import java.util.Map;
import java.util.Set;
import java.util.stream.Collectors;
import javax.inject.Inject;
import net.runelite.api.*;
import net.runelite.api.events.*;
import net.runelite.client.eventbus.EventBus;
import net.runelite.client.eventbus.Subscribe;
import rs117.hd.HdPluginConfig;
import rs117.hd.overlays.FrameTimer;
import rs117.hd.overlays.Timer;
import rs117.hd.scene.model_overrides.ModelOverride;

import static rs117.hd.utils.ColorUtils.hsl;

public class FishingSpotReplacer {
	private static final int FISHING_SPOT_MODEL_ID = 41238;
	private static final int FISHING_SPOT_ANIMATION_ID = 10793;
	private static final int LAVA_SPOT_MODEL_ID = 2331;
	private static final int LAVA_SPOT_ANIMATION_ID = 525;
	private static final int LAVA_SPOT_COLOR = hsl("#837574");

	// @formatter:off
	private static final Set<Integer> FISHING_SPOT_IDS = Set.of(394, 635, 1506, 1507, 1508, 1509, 1510, 1511, 1512, 1513, 1514, 1515, 1516, 1517, 1518, 1519, 1520, 1521, 1522, 1523, 1524, 1525, 1526, 1527, 1528, 1529, 1530, 1531, 1532, 1533, 1534, 1535, 1536, 1542, 1544, 2146, 2653, 2654, 2655, 3317, 3417, 3418, 3419, 3657, 3913, 3914, 3915, 4079, 4080, 4081, 4082, 4316, 4476, 4477, 4710, 4711, 4712, 4713, 4714, 5233, 5234, 5820, 5821, 6731, 6825, 7155, 7199, 7200, 7323, 7459, 7460, 7461, 7462, 7463, 7464, 7465, 7466, 7467, 7468, 7469, 7470, 7946, 7947, 8524, 8525, 8526, 8527, 9171, 9172, 9173, 9174, 9478, 12267);
	private static final Set<Integer> LAVA_FISHING_SPOT_IDS = Set.of(4928);
	// @formatter:on
	private static final Set<Integer> NPC_IDS = Sets.union(FISHING_SPOT_IDS, LAVA_FISHING_SPOT_IDS).immutableCopy();

	@Inject
	private Client client;

	@Inject
	private EventBus eventBus;

	@Inject
	private HdPluginConfig config;

	@Inject
	private TileOverrideManager tileOverrideManager;

	@Inject
	private FrameTimer frameTimer;

	private final Map<Integer, RuneLiteObject> npcIndexToModel = new HashMap<>();
	private Animation fishingSpotAnimation;
	private Animation lavaFishingSpotAnimation;

	public void startUp() {
		eventBus.register(this);
		fishingSpotAnimation = client.loadAnimation(FISHING_SPOT_ANIMATION_ID);
		lavaFishingSpotAnimation = client.loadAnimation(LAVA_SPOT_ANIMATION_ID);
	}

	public void shutDown() {
		eventBus.unregister(this);
		despawnRuneLiteObjects();
		fishingSpotAnimation = null;
		lavaFishingSpotAnimation = null;
	}

	public void despawnRuneLiteObjects() {
		npcIndexToModel.values().forEach(rlobj -> rlobj.setActive(false));
		npcIndexToModel.clear();
	}

	public ModelOverride getModelOverride() {
		if (!config.replaceFishingSpots())
			return null;

		ModelOverride override = new ModelOverride();
		override.hide = true;
		override.npcIds = NPC_IDS;
		return override;
	}

	public void update() {
		if (!config.replaceFishingSpots())
			return;

		frameTimer.begin(Timer.REPLACE_FISHING_SPOTS);

		// Despawn fishing spots for inactive NPCs
		Set<Integer> npcIndices = client.getNpcs().stream().map(NPC::getIndex).collect(Collectors.toSet());
		npcIndexToModel.entrySet().removeIf(entry -> {
			if (npcIndices.contains(entry.getKey()))
				return false;
			entry.getValue().setActive(false);
			return true;
		});

		client.getNpcs().forEach(this::spawnFishingSpot);

		// Update the location of active fishing spots to match their corresponding NPC's current position
		npcIndexToModel.forEach((index, runeLiteObject) -> {
			NPC npc = client.getTopLevelWorldView().npcs().byIndex(index);
			if (npc != null)
				runeLiteObject.setLocation(npc.getLocalLocation(), client.getTopLevelWorldView().getPlane());
		});

		frameTimer.end(Timer.REPLACE_FISHING_SPOTS);
	}

	@Subscribe
	public void onNpcSpawned(NpcSpawned npcSpawned) {
		spawnFishingSpot(npcSpawned.getNpc());
	}

	public void spawnFishingSpot(NPC npc) {
		if (!NPC_IDS.contains(npc.getId()))
			return;

		npcIndexToModel.computeIfAbsent(npc.getIndex(), i -> {
			int modelId = FISHING_SPOT_MODEL_ID;
			Animation animation = fishingSpotAnimation;
			int recolor = -1;

			if (LAVA_FISHING_SPOT_IDS.contains(npc.getId())) {
				modelId = LAVA_SPOT_MODEL_ID;
				animation = lavaFishingSpotAnimation;
				recolor = LAVA_SPOT_COLOR;
			} else {
				var lp = npc.getLocalLocation();
				if (lp.isInScene()) {
					Tile tile = client.getScene().getTiles()[client.getPlane()][lp.getSceneX()][lp.getSceneY()];
					recolor = tileOverrideManager.getOverride(client.getScene(), tile).waterType.fishingSpotRecolor;
				}
			}

			ModelData modelData = client.loadModelData(modelId);
			if (modelData == null)
				return null;

			if (recolor != -1) {
				modelData = modelData.cloneColors();
				Arrays.fill(modelData.getFaceColors(), (short) recolor);
			}

			RuneLiteObject fishingSpot = client.createRuneLiteObject();
			fishingSpot.setAnimation(animation);
			fishingSpot.setDrawFrontTilesFirst(false);
			fishingSpot.setActive(true);
			fishingSpot.setShouldLoop(true);
			fishingSpot.setModel(modelData.light());
			return fishingSpot;
		});
	}
}

package rs117.hd.scene;

import com.google.common.collect.ArrayListMultimap;
import com.google.common.collect.ListMultimap;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Map;
import java.util.Objects;
import java.util.stream.Stream;
import javax.annotation.Nonnull;
import javax.annotation.Nullable;
import net.runelite.api.*;
import net.runelite.api.coords.*;
import rs117.hd.data.environments.Area;
import rs117.hd.data.materials.Material;
import rs117.hd.scene.environments.Environment;
import rs117.hd.scene.lights.Light;
import rs117.hd.scene.lights.TileObjectImpostorTracker;
import rs117.hd.utils.AABB;
import rs117.hd.utils.HDUtils;
import rs117.hd.utils.buffer.GpuFloatBuffer;
import rs117.hd.utils.buffer.GpuIntBuffer;

import static net.runelite.api.Perspective.*;
import static rs117.hd.HdPlugin.UV_SIZE;
import static rs117.hd.HdPlugin.VERTEX_SIZE;
import static rs117.hd.scene.SceneUploader.SCENE_OFFSET;

public class SceneContext {
	public final int id = HDUtils.rand.nextInt() & SceneUploader.SCENE_ID_MASK;
	public final Scene scene;
	public final HashSet<Integer> regionIds;
	public final int expandedMapLoadingChunks;

	public int staticVertexCount = 0;
	public GpuIntBuffer staticUnorderedModelBuffer;
	public GpuIntBuffer stagingBufferVertices;
	public GpuFloatBuffer stagingBufferUvs;
	public GpuFloatBuffer stagingBufferNormals;

	// statistics
	public int uniqueModels;

	// terrain data
	public Map<Integer, Integer> vertexTerrainColor;
	public Map<Integer, Material> vertexTerrainTexture;
	public Map<Integer, float[]> vertexTerrainNormals;
	// used for overriding potentially low quality vertex colors
	public HashMap<Integer, Boolean> highPriorityColor;

	// water-related data
	public boolean[][][] tileIsWater;
	public Map<Integer, Boolean> vertexIsWater;
	public Map<Integer, Boolean> vertexIsLand;
	public Map<Integer, Boolean> vertexIsOverlay;
	public Map<Integer, Boolean> vertexIsUnderlay;
	public boolean[][][] skipTile;
	public Map<Integer, Integer> vertexUnderwaterDepth;
	public int[][][] underwaterDepthLevels;

	public int numVisibleLights = 0;
	public final ArrayList<Light> lights = new ArrayList<>();
	public final HashSet<Projectile> knownProjectiles = new HashSet<>();
	public final HashMap<TileObject, TileObjectImpostorTracker> trackedTileObjects = new HashMap<>();
	public final ListMultimap<Integer, TileObjectImpostorTracker> trackedVarps = ArrayListMultimap.create();
	public final ListMultimap<Integer, TileObjectImpostorTracker> trackedVarbits = ArrayListMultimap.create();

	public final ArrayList<Environment> environments = new ArrayList<>();

	// model pusher arrays, to avoid simultaneous usage from different threads
	public final int[] modelFaceVertices = new int[12];
	public final float[] modelFaceNormals = new float[12];
	public final int[] modelPusherResults = new int[2];

	public SceneContext(Scene scene, int expandedMapLoadingChunks, boolean reuseBuffers, @Nullable SceneContext previous) {
		this.scene = scene;
		this.regionIds = HDUtils.getSceneRegionIds(scene);
		this.expandedMapLoadingChunks = expandedMapLoadingChunks;

		if (previous == null) {
			staticUnorderedModelBuffer = new GpuIntBuffer();
			stagingBufferVertices = new GpuIntBuffer();
			stagingBufferUvs = new GpuFloatBuffer();
			stagingBufferNormals = new GpuFloatBuffer();
		} else if (reuseBuffers) {
			// Avoid reallocating buffers whenever possible
			staticUnorderedModelBuffer = previous.staticUnorderedModelBuffer.clear();
			stagingBufferVertices = previous.stagingBufferVertices.clear();
			stagingBufferUvs = previous.stagingBufferUvs.clear();
			stagingBufferNormals = previous.stagingBufferNormals.clear();
			previous.staticUnorderedModelBuffer = null;
			previous.stagingBufferVertices = null;
			previous.stagingBufferUvs = null;
			previous.stagingBufferNormals = null;
		} else {
			staticUnorderedModelBuffer = new GpuIntBuffer(previous.staticUnorderedModelBuffer.capacity());
			stagingBufferVertices = new GpuIntBuffer(previous.stagingBufferVertices.capacity());
			stagingBufferUvs = new GpuFloatBuffer(previous.stagingBufferUvs.capacity());
			stagingBufferNormals = new GpuFloatBuffer(previous.stagingBufferNormals.capacity());
		}
	}

	public synchronized void destroy() {
		if (staticUnorderedModelBuffer != null)
			staticUnorderedModelBuffer.destroy();
		staticUnorderedModelBuffer = null;

		if (stagingBufferVertices != null)
			stagingBufferVertices.destroy();
		stagingBufferVertices = null;

		if (stagingBufferUvs != null)
			stagingBufferUvs.destroy();
		stagingBufferUvs = null;

		if (stagingBufferNormals != null)
			stagingBufferNormals.destroy();
		stagingBufferNormals = null;
	}

	public int getVertexOffset() {
		return stagingBufferVertices.position() / VERTEX_SIZE;
	}

	public int getUvOffset() {
		return stagingBufferUvs.position() / UV_SIZE;
	}

	/**
	 * Transform local coordinates into world coordinates.
	 * If the {@link LocalPoint} is not in the scene, this returns untranslated coordinates when in instances.
	 *
	 * @param localPoint to transform
	 * @param plane      which the local coordinate is on
	 * @return world coordinate
	 */
	public int[] localToWorld(LocalPoint localPoint, int plane) {
		return HDUtils.localToWorld(scene, localPoint.getX(), localPoint.getY(), plane);
	}

	public int[] localToWorld(int localX, int localY, int plane) {
		return HDUtils.localToWorld(scene, localX, localY, plane);
	}

	public int[] sceneToWorld(int sceneX, int sceneY, int plane) {
		return HDUtils.localToWorld(scene, sceneX * LOCAL_TILE_SIZE, sceneY * LOCAL_TILE_SIZE, plane);
	}

	public int[] extendedSceneToWorld(int sceneExX, int sceneExY, int plane) {
		return sceneToWorld(sceneExX - SCENE_OFFSET, sceneExY - SCENE_OFFSET, plane);
	}

	public Stream<LocalPoint> worldInstanceToLocals(WorldPoint worldPoint)
	{
		return WorldPoint.toLocalInstance(scene, worldPoint)
			.stream()
			.map(this::worldToLocal)
			.filter(Objects::nonNull);
	}

	/**
	 * Gets the local coordinate at the south-western corner of the passed tile.
	 *
	 * @param worldPoint the passed tile
	 * @return coordinate if the tile is in the current scene, otherwise null
	 */
	@Nullable
	public LocalPoint worldToLocal(WorldPoint worldPoint)
	{
		return new LocalPoint(
			(worldPoint.getX() - scene.getBaseX()) * LOCAL_TILE_SIZE,
			(worldPoint.getY() - scene.getBaseY()) * LOCAL_TILE_SIZE
		);
	}

	/**
	 * Gets the local coordinate at the south-western corner of the passed tile.
	 */
	public int[] worldToLocal(@Nonnull int[] worldPoint) {
		return new int[] { (worldPoint[0] - scene.getBaseX()) * LOCAL_TILE_SIZE, (worldPoint[1] - scene.getBaseY()) * LOCAL_TILE_SIZE };
	}

	public boolean intersects(Area area) {
		return intersects(area.aabbs);
	}

	public boolean intersects(AABB... aabbs) {
		return HDUtils.sceneIntersects(scene, expandedMapLoadingChunks, aabbs);
	}

	public int getObjectConfig(Tile tile, long hash) {
		if (tile.getWallObject() != null && tile.getWallObject().getHash() == hash)
			return tile.getWallObject().getConfig();
		if (tile.getDecorativeObject() != null && tile.getDecorativeObject().getHash() == hash)
			return tile.getDecorativeObject().getConfig();
		if (tile.getGroundObject() != null && tile.getGroundObject().getHash() == hash)
			return tile.getGroundObject().getConfig();
		for (GameObject gameObject : tile.getGameObjects())
			if (gameObject != null && gameObject.getHash() == hash)
				return gameObject.getConfig();
		return -1;
	}
}

/*
 * Copyright (c) 2021, 117 <https://twitter.com/117scape>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package rs117.hd.scene.model_overrides;

public enum ObjectType
{
	NONE, WALL_OBJECT, GROUND_OBJECT, DECORATIVE_OBJECT, GAME_OBJECT
}

package rs117.hd.scene.model_overrides;

public enum InheritTileColorType
{
	NONE, OVERLAY, UNDERLAY
}

package rs117.hd.scene.model_overrides;

import com.google.gson.annotations.JsonAdapter;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;
import lombok.AllArgsConstructor;
import lombok.NoArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.*;
import rs117.hd.config.SeasonalTheme;
import rs117.hd.config.VanillaShadowMode;
import rs117.hd.data.materials.Material;
import rs117.hd.data.materials.UvType;
import rs117.hd.utils.AABB;
import rs117.hd.utils.GsonUtils;
import rs117.hd.utils.Props;
import rs117.hd.utils.Vector;

import static net.runelite.api.Perspective.*;

@Slf4j
@NoArgsConstructor
@AllArgsConstructor
public class ModelOverride
{
	public static final ModelOverride NONE = new ModelOverride(true);

	private static final Set<Integer> EMPTY = new HashSet<>();

	public String description = "UNKNOWN";

	// When, where or what the override should apply to
	public SeasonalTheme seasonalTheme;
	@JsonAdapter(AABB.JsonAdapter.class)
	public AABB[] areas = {};
	@JsonAdapter(GsonUtils.IntegerSetAdapter.class)
	public Set<Integer> npcIds = EMPTY;
	@JsonAdapter(GsonUtils.IntegerSetAdapter.class)
	public Set<Integer> objectIds = EMPTY;
	@JsonAdapter(GsonUtils.IntegerSetAdapter.class)
	public Set<Integer> projectileIds = EMPTY;
	@JsonAdapter(GsonUtils.IntegerSetAdapter.class)
	public Set<Integer> graphicsObjectIds = EMPTY;

	public Material baseMaterial = Material.NONE;
	public Material textureMaterial = Material.NONE;
	public UvType uvType = UvType.VANILLA;
	public float uvScale = 1;
	public int uvOrientation = 0;
	public int uvOrientationX = 0;
	public int uvOrientationY = 0;
	public int uvOrientationZ = 0;
	public int rotate = 0;
	public boolean hide = false;
	public boolean retainVanillaUvs = true;
	public boolean forceMaterialChanges = false;
	public boolean flatNormals = false;
	public boolean upwardsNormals = false;
	public boolean hideVanillaShadows = false;
	public boolean retainVanillaShadowsInPvm = false;
	public boolean hideHdShadowsInPvm = false;
	public boolean castShadows = true;
	public boolean receiveShadows = true;
	public float shadowOpacityThreshold = 0;
	public TzHaarRecolorType tzHaarRecolorType = TzHaarRecolorType.NONE;
	public InheritTileColorType inheritTileColorType = InheritTileColorType.NONE;

	@JsonAdapter(AABB.JsonAdapter.class)
	public AABB[] hideInAreas = {};

	public Map<Material, ModelOverride> materialOverrides;

	public transient boolean isDummy;
	public transient Map<AABB, ModelOverride> areaOverrides;

	public void normalize(VanillaShadowMode vanillaShadowMode) {
		// Ensure there are no nulls in case of invalid configuration during development
		if (baseMaterial == null) {
			if (Props.DEVELOPMENT)
				throw new IllegalStateException("Invalid baseMaterial");
			baseMaterial = ModelOverride.NONE.baseMaterial;
		}
		if (textureMaterial == null) {
			if (Props.DEVELOPMENT)
				throw new IllegalStateException("Invalid textureMaterial");
			textureMaterial = ModelOverride.NONE.textureMaterial;
		}
		if (uvType == null) {
			if (Props.DEVELOPMENT)
				throw new IllegalStateException("Invalid uvType");
			uvType = ModelOverride.NONE.uvType;
		}
		if (tzHaarRecolorType == null) {
			if (Props.DEVELOPMENT)
				throw new IllegalStateException("Invalid tzHaarRecolorType");
			tzHaarRecolorType = ModelOverride.NONE.tzHaarRecolorType;
		}
		if (inheritTileColorType == null) {
			if (Props.DEVELOPMENT)
				throw new IllegalStateException("Invalid inheritTileColorType");
			inheritTileColorType = ModelOverride.NONE.inheritTileColorType;
		}

		if (areas == null)
			areas = new AABB[0];
		if (hideInAreas == null)
			hideInAreas = new AABB[0];

		baseMaterial = baseMaterial.resolveReplacements();
		textureMaterial = textureMaterial.resolveReplacements();

		if (materialOverrides != null) {
			var normalized = new HashMap<Material, ModelOverride>();
			for (var entry : materialOverrides.entrySet()) {
				var override = entry.getValue();
				override.normalize(vanillaShadowMode);
				normalized.put(entry.getKey().resolveReplacements(), override);
			}
			materialOverrides = normalized;
		}

		if (uvOrientationX == 0)
			uvOrientationX = uvOrientation;
		if (uvOrientationY == 0)
			uvOrientationY = uvOrientation;
		if (uvOrientationZ == 0)
			uvOrientationZ = uvOrientation;

		if (retainVanillaShadowsInPvm) {
			if (vanillaShadowMode.retainInPvm)
				hideVanillaShadows = false;
			if (vanillaShadowMode == VanillaShadowMode.PREFER_IN_PVM && hideHdShadowsInPvm)
				castShadows = false;
		}

		if (!castShadows && shadowOpacityThreshold == 0)
			shadowOpacityThreshold = 1;
	}

	public ModelOverride copy() {
		return new ModelOverride(
			description,
			seasonalTheme,
			areas,
			npcIds,
			objectIds,
			projectileIds,
			graphicsObjectIds,
			baseMaterial,
			textureMaterial,
			uvType,
			uvScale,
			uvOrientation,
			uvOrientationX,
			uvOrientationY,
			uvOrientationZ,
			rotate,
			hide,
			retainVanillaUvs,
			forceMaterialChanges,
			flatNormals,
			upwardsNormals,
			hideVanillaShadows,
			retainVanillaShadowsInPvm,
			hideHdShadowsInPvm,
			castShadows,
			receiveShadows,
			shadowOpacityThreshold,
			tzHaarRecolorType,
			inheritTileColorType,
			hideInAreas,
			materialOverrides,
			isDummy,
			areaOverrides
		);
	}

	private ModelOverride(boolean isDummy) {
		this();
		this.isDummy = isDummy;
	}

	public void computeModelUvw(float[] out, int i, float x, float y, float z, int orientation) {
		double rad, cos, sin;
		float temp;
		if (orientation % 2048 != 0) {
			// Reverse baked vertex rotation
			rad = orientation * UNIT;
			cos = Math.cos(rad);
			sin = Math.sin(rad);
			temp = (float) (x * sin + z * cos);
			x = (float) (x * cos - z * sin);
			z = temp;
		}

		x = (x / LOCAL_TILE_SIZE + .5f) / uvScale;
		y = (y / LOCAL_TILE_SIZE + .5f) / uvScale;
		z = (z / LOCAL_TILE_SIZE + .5f) / uvScale;

		uvType.computeModelUvw(out, i, x, y, z);

		if (uvOrientation % 2048 != 0) {
			rad = uvOrientation * UNIT;
			cos = Math.cos(rad);
			sin = Math.sin(rad);
			x = out[i] - .5f;
			z = out[i + 1] - .5f;
			temp = (float) (x * sin + z * cos);
			x = (float) (x * cos - z * sin);
			z = temp;
			out[i] = x + .5f;
			out[i + 1] = z + .5f;
		}
	}

	public void fillUvsForFace(float[] out, Model model, int orientation, UvType uvType, int face) {
		switch (uvType) {
			case WORLD_XY:
			case WORLD_XZ:
			case WORLD_YZ:
				uvType.computeWorldUvw(out, 0, uvScale);
				uvType.computeWorldUvw(out, 4, uvScale);
				uvType.computeWorldUvw(out, 8, uvScale);
				break;
			case MODEL_XY:
			case MODEL_XY_MIRROR_A:
			case MODEL_XY_MIRROR_B:
			case MODEL_XZ:
			case MODEL_XZ_MIRROR_A:
			case MODEL_XZ_MIRROR_B:
			case MODEL_YZ:
			case MODEL_YZ_MIRROR_A:
			case MODEL_YZ_MIRROR_B: {
				final float[] vertexX = model.getVerticesX();
				final float[] vertexY = model.getVerticesY();
				final float[] vertexZ = model.getVerticesZ();
				final int triA = model.getFaceIndices1()[face];
				final int triB = model.getFaceIndices2()[face];
				final int triC = model.getFaceIndices3()[face];

				computeModelUvw(out, 0, vertexX[triA], vertexY[triA], vertexZ[triA], orientation);
				computeModelUvw(out, 4, vertexX[triB], vertexY[triB], vertexZ[triB], orientation);
				computeModelUvw(out, 8, vertexX[triC], vertexY[triC], vertexZ[triC], orientation);
				break;
			}
			case BOX:
				computeBoxUvw(out, model, orientation, face);
				break;
			case VANILLA: {
				final byte[] textureFaces = model.getTextureFaces();
				int texFace = textureFaces == null ? -1 : textureFaces[face];
				if (texFace != -1) {
					texFace &= 0xff;

					final float[] vertexX = model.getVerticesX();
					final float[] vertexY = model.getVerticesY();
					final float[] vertexZ = model.getVerticesZ();
					final int texA = model.getTexIndices1()[texFace];
					final int texB = model.getTexIndices2()[texFace];
					final int texC = model.getTexIndices3()[texFace];

					out[0] = vertexX[texA];
					out[1] = vertexY[texA];
					out[2] = vertexZ[texA];
					out[4] = vertexX[texB];
					out[5] = vertexY[texB];
					out[6] = vertexZ[texB];
					out[8] = vertexX[texC];
					out[9] = vertexY[texC];
					out[10] = vertexZ[texC];
				}
				break;
			}
			case GEOMETRY:
			default:
				out[0] = 0;
				out[1] = 0;
				out[2] = 0;
				out[4] = 1;
				out[5] = 0;
				out[6] = 0;
				out[8] = 0;
				out[9] = 1;
				out[10] = 0;
				break;
		}
	}

	private void computeBoxUvw(float[] out, Model model, int modelOrientation, int face) {
		final float[][] vertexXYZ = {
			model.getVerticesX(),
			model.getVerticesY(),
			model.getVerticesZ()
		};
		final int[] triABC = {
			model.getFaceIndices1()[face],
			model.getFaceIndices2()[face],
			model.getFaceIndices3()[face]
		};

		float[][] v = new float[3][3];
		for (int tri = 0; tri < 3; tri++)
			for (int i = 0; i < 3; i++)
				v[tri][i] = vertexXYZ[i][triABC[tri]];

		double rad, cos, sin;
		float temp;
		if (modelOrientation % 2048 != 0) {
			// Reverse baked vertex rotation
			rad = modelOrientation * UNIT;
			cos = Math.cos(rad);
			sin = Math.sin(rad);

			for (int i = 0; i < 3; i++) {
				temp = (float) (v[i][0] * sin + v[i][2] * cos);
				v[i][0] = (float) (v[i][0] * cos - v[i][2] * sin);
				v[i][2] = temp;
			}
		}

		for (int i = 0; i < 3; i++) {
			v[i][0] = (v[i][0] / LOCAL_TILE_SIZE + .5f) / uvScale;
			v[i][1] = (v[i][1] / LOCAL_TILE_SIZE + .5f) / uvScale;
			v[i][2] = (v[i][2] / LOCAL_TILE_SIZE + .5f) / uvScale;
		}

		// Compute face normal
		float[] a = new float[3];
		float[] b = new float[3];
		Vector.subtract(a, v[1], v[0]);
		Vector.subtract(b, v[2], v[0]);
		float[] n = new float[3];
		Vector.cross(n, a, b);
		float[] absN = new float[3];
		Vector.abs(absN, n);

		out[2] = out[6] = out[10] = 0;
		if (absN[0] > absN[1] && absN[0] > absN[2]) {
			// YZ plane
			float flip = Math.signum(n[0]);
			for (int tri = 0; tri < 3; tri++) {
				out[tri * 4] = flip * -v[tri][2];
				out[tri * 4 + 1] = v[tri][1];
			}

			if (uvOrientationX % 2048 != 0) {
				rad = uvOrientationX * UNIT;
				cos = Math.cos(rad);
				sin = Math.sin(rad);

				for (int i = 0; i < 3; i++) {
					int j = i * 4;
					v[i][0] = out[j] - .5f;
					v[i][2] = out[j + 1] - .5f;
					temp = (float) (v[i][0] * sin + v[i][2] * cos);
					v[i][0] = (float) (v[i][0] * cos - v[i][2] * sin);
					v[i][2] = temp;
					out[j] = v[i][0] + .5f;
					out[j + 1] = v[i][2] + .5f;
				}
			}
		} else if (absN[1] > absN[0] && absN[1] > absN[2]) {
			// XZ
			float flip = Math.signum(n[1]);
			for (int tri = 0; tri < 3; tri++) {
				out[tri * 4] = flip * -v[tri][0];
				out[tri * 4 + 1] = v[tri][2];
			}

			if (uvOrientationY % 2048 != 0) {
				rad = uvOrientationY * UNIT;
				cos = Math.cos(rad);
				sin = Math.sin(rad);

				for (int i = 0; i < 3; i++) {
					int j = i * 4;
					v[i][0] = out[j] - .5f;
					v[i][2] = out[j + 1] - .5f;
					temp = (float) (v[i][0] * sin + v[i][2] * cos);
					v[i][0] = (float) (v[i][0] * cos - v[i][2] * sin);
					v[i][2] = temp;
					out[j] = v[i][0] + .5f;
					out[j + 1] = v[i][2] + .5f;
				}
			}
		} else {
			// XY
			float flip = Math.signum(n[2]);
			for (int tri = 0; tri < 3; tri++) {
				out[tri * 4] = flip * v[tri][0];
				out[tri * 4 + 1] = v[tri][1];
			}

			if (uvOrientationZ % 2048 != 0) {
				rad = uvOrientationZ * UNIT;
				cos = Math.cos(rad);
				sin = Math.sin(rad);

				for (int i = 0; i < 3; i++) {
					int j = i * 4;
					v[i][0] = out[j] - .5f;
					v[i][2] = out[j + 1] - .5f;
					temp = (float) (v[i][0] * sin + v[i][2] * cos);
					v[i][0] = (float) (v[i][0] * cos - v[i][2] * sin);
					v[i][2] = temp;
					out[j] = v[i][0] + .5f;
					out[j + 1] = v[i][2] + .5f;
				}
			}
		}
	}

	public void applyRotation(Model model) {
		switch (rotate) {
			case 0:
				break;
			case 90:
				model.rotateY90Ccw();
				break;
			case 180:
				model.rotateY180Ccw();
				break;
			case 270:
				model.rotateY270Ccw();
				break;
			default:
				log.debug(
					"Unsupported rotation of {} degrees in model override: '{}'",
					rotate,
					description
				);
				break;
		}
	}

	public void revertRotation(Model model) {
		switch (rotate) {
			case 90:
				model.rotateY270Ccw();
				break;
			case 180:
				model.rotateY180Ccw();
				break;
			case 270:
				model.rotateY90Ccw();
				break;
		}
	}
}

/*
 * Copyright (c) 2021, 117 <https://twitter.com/117scape>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package rs117.hd.scene.model_overrides;

public enum TzHaarRecolorType
{
	NONE, GRADIENT, HUE_SHIFT
}

package rs117.hd.scene.environments;

import com.google.gson.annotations.JsonAdapter;
import java.util.Objects;
import lombok.AccessLevel;
import lombok.NoArgsConstructor;
import lombok.Setter;
import rs117.hd.data.environments.Area;
import rs117.hd.utils.GsonUtils;
import rs117.hd.utils.HDUtils;

import static rs117.hd.utils.ColorUtils.SrgbToLinearAdapter;
import static rs117.hd.utils.ColorUtils.rgb;

@Setter(value = AccessLevel.PRIVATE)
@NoArgsConstructor // Called by GSON when parsing JSON
public class Environment {
	public static final Environment DEFAULT = new Environment()
		.setKey("DEFAULT")
		.setArea(Area.ALL)
		.setFogColor(rgb("#000000"))
		.setWaterColor(rgb("#66eaff"))
		.setSunAngles(HDUtils.sunAngles(52, 235))
		.normalize();
	public static final Environment NONE = new Environment()
		.setKey("NONE")
		.setFogColor(rgb("#ff00ff"))
		.normalize();

	public static Environment OVERWORLD, AUTUMN, WINTER;

	public String key;
	@JsonAdapter(Area.JsonAdapter.class)
	public Area area = Area.NONE;
	public boolean isOverworld = false;
	public boolean isUnderwater = false;
	public boolean force = false;
	public boolean allowSkyOverride = true;
	public boolean lightningEffects = false;
	public boolean instantTransition = false;
	@JsonAdapter(SrgbToLinearAdapter.class)
	public float[] ambientColor = rgb("#ffffff");
	public float ambientStrength = 1;
	@JsonAdapter(SrgbToLinearAdapter.class)
	public float[] directionalColor = rgb("#ffffff");
	public float directionalStrength = .25f;
	@JsonAdapter(SrgbToLinearAdapter.class)
	public float[] waterColor;
	@JsonAdapter(SrgbToLinearAdapter.class)
	public float[] waterCausticsColor;
	public float waterCausticsStrength = -1;
	@JsonAdapter(SrgbToLinearAdapter.class)
	public float[] underglowColor = rgb("#000000");
	public float underglowStrength = 0;
	@JsonAdapter(GsonUtils.DegreesToRadians.class)
	public float[] sunAngles; // horizontal coordinate system, in radians
	@JsonAdapter(SrgbToLinearAdapter.class)
	public float[] fogColor;
	public float fogDepth = 25;
	public int groundFogStart = -200;
	public int groundFogEnd = -500;
	public float groundFogOpacity = 0;

	public Environment normalize() {
		if (area != Area.ALL && area != Area.NONE) {
			isOverworld = Area.OVERWORLD.intersects(area);
			// Certain nullable fields will fall back to using the current overworld theme's values,
			// but for environments that aren't part of the overworld, we want to fall back to the default
			// environment's values for any unspecified fields
			if (!isOverworld && DEFAULT != null) {
				sunAngles = Objects.requireNonNullElse(sunAngles, DEFAULT.sunAngles);
				fogColor = Objects.requireNonNullElse(fogColor, DEFAULT.fogColor);
				waterColor = Objects.requireNonNullElse(waterColor, DEFAULT.waterColor);
			}
		}

		// Base water caustics on directional lighting by default
		if (waterCausticsColor == null)
			waterCausticsColor = directionalColor;
		if (waterCausticsStrength == -1)
			waterCausticsStrength = directionalStrength;
		return this;
	}

	@Override
	public String toString() {
		if (key != null)
			return key;
		return area.name();
	}
}

package rs117.hd.scene;

import com.google.common.collect.ArrayListMultimap;
import com.google.common.collect.ListMultimap;
import java.io.IOException;
import java.util.ArrayDeque;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;
import javax.annotation.Nonnull;
import javax.annotation.Nullable;
import javax.inject.Inject;
import javax.inject.Singleton;
import lombok.NonNull;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.*;
import net.runelite.api.coords.*;
import net.runelite.client.callback.ClientThread;
import rs117.hd.HdPlugin;
import rs117.hd.config.SeasonalTheme;
import rs117.hd.data.environments.Area;
import rs117.hd.model.ModelPusher;
import rs117.hd.scene.tile_overrides.TileOverride;
import rs117.hd.utils.FileWatcher;
import rs117.hd.utils.HDUtils;
import rs117.hd.utils.Props;
import rs117.hd.utils.ResourcePath;
import rs117.hd.utils.VariableSupplier;

import static rs117.hd.scene.tile_overrides.TileOverride.OVERLAY_FLAG;
import static rs117.hd.utils.HDUtils.localToWorld;
import static rs117.hd.utils.ResourcePath.path;

@Singleton
@Slf4j
public class TileOverrideManager {
	private static final ResourcePath TILE_OVERRIDES_PATH = Props.getPathOrDefault(
		"rlhd.tile-overrides-path",
		() -> path(TileOverrideManager.class, "tile_overrides.json")
	);

	@Inject
	private Client client;

	@Inject
	private ClientThread clientThread;

	@Inject
	private HdPlugin plugin;

	@Inject
	private ModelPusher modelPusher;

	private FileWatcher.UnregisterCallback fileWatcher;
	private ResourcePath tileOverridesPath;
	private boolean trackReplacements;
	private List<Map.Entry<Area, TileOverride>> anyMatchOverrides;
	private ListMultimap<Integer, Map.Entry<Area, TileOverride>> idMatchOverrides;
	private final HslVariables hslVars = new HslVariables();

	public void startUp() {
		fileWatcher = TILE_OVERRIDES_PATH.watch((path, first) -> {
			tileOverridesPath = path;
			reload(!first);
		});
	}

	public void shutDown() {
		if (fileWatcher != null)
			fileWatcher.unregister();
		fileWatcher = null;
		anyMatchOverrides = null;
		idMatchOverrides = null;
	}

	public void reload(boolean reloadScene) {
		if (tileOverridesPath == null)
			return;

		try {
			TileOverride[] allOverrides = tileOverridesPath.loadJson(plugin.getGson(), TileOverride[].class);
			if (allOverrides == null)
				throw new IOException("Empty or invalid: " + tileOverridesPath);

			HashSet<String> names = new HashSet<>();
			for (var override : allOverrides) {
				if (override.name != null) {
					if (!names.add(override.name)) {
						log.warn("Removing duplicate tile override name: {}", override.name);
						override.name = null;
					}
				}
			}

			checkForReplacementLoops(allOverrides);

			List<Map.Entry<Area, TileOverride>> anyMatch = new ArrayList<>();
			ListMultimap<Integer, Map.Entry<Area, TileOverride>> idMatch = ArrayListMultimap.create();

			// Substitute constants in replacement expressions and simplify
			Map<String, Object> constants = new HashMap<>();
			for (var season : SeasonalTheme.values())
				constants.put(season.name(), season.ordinal());
			constants.put("season", plugin.configSeasonalTheme.ordinal());
			constants.put("blending", plugin.configGroundBlending);
			constants.put("textures", plugin.configGroundTextures);

			for (int i = 0; i < allOverrides.length; i++) {
				var override = allOverrides[i];
				try {
					override.index = i;
					override.normalize(allOverrides, constants);
				} catch (Exception ex) {
					log.warn("Skipping invalid tile override '{}':", override.name, ex);
					continue;
				}

				if (override.area == Area.NONE)
					continue;

				var replacement = trackReplacements ? override : override.resolveConstantReplacements();
				var entry = Map.entry(override.area, replacement);
				if (override.ids != null) {
					for (int id : override.ids)
						idMatch.put(id, entry);
				} else {
					anyMatch.add(entry);
				}
			}

			anyMatchOverrides = anyMatch;
			idMatchOverrides = idMatch;

			log.debug("Loaded {} tile overrides", allOverrides.length);
		} catch (IOException ex) {
			log.error("Failed to load tile overrides:", ex);
		}

		if (reloadScene) {
			clientThread.invoke(() -> {
				modelPusher.clearModelCache();
				if (client.getGameState() == GameState.LOGGED_IN)
					client.setGameState(GameState.LOADING);
			});
		}
	}

	private void checkForReplacementLoops(TileOverride[] allOverrides) {
		Map<String, TileOverride> relevantOverrides = new HashMap<>();
		for (var override : allOverrides)
			if (override.name != null && override.rawReplacements != null)
				relevantOverrides.put(override.name, override);

		Set<String> alreadyChecked = new HashSet<>();
		for (var override : relevantOverrides.values())
			checkForReplacementLoops(relevantOverrides, alreadyChecked, override);
	}

	private static void checkForReplacementLoops(
		Map<String, TileOverride> map,
		Set<String> alreadyChecked,
		TileOverride topLevelOverride
	) {
		String name = topLevelOverride.name;
		// Only check each top-level override once
		if (alreadyChecked.add(name))
			checkForReplacementLoops(map, alreadyChecked, new ArrayDeque<>(), name, topLevelOverride);
	}

	private static void checkForReplacementLoops(
		Map<String, TileOverride> map,
		Set<String> alreadyChecked,
		ArrayDeque<String> loop,
		String topLevelOverrideName,
		TileOverride overrideToCheck
	) {
		loop.addLast(overrideToCheck.name);

		for (String replacementName : overrideToCheck.rawReplacements.keySet()) {
			// Check if the replacement introduces a loop
			if (topLevelOverrideName.equals(replacementName)) {
				log.warn(
					"Tile override contains replacement loop: {} -> {}",
					String.join(" -> ", loop),
					replacementName
				);
				// Remove the loop
				overrideToCheck.rawReplacements.put(replacementName, null);
				continue;
			}

			var replacement = map.get(replacementName);
			if (replacement == null)
				continue;

			// Before continuing to check for loops back to the top-level override,
			// we need to rule out any loops within the replacement override itself,
			// so we don't get stuck in a loop there
			checkForReplacementLoops(map, alreadyChecked, replacement);

			// The replacement might've already been removed to prevent a loop in the step above
			if (overrideToCheck.rawReplacements.get(replacementName) == null)
				continue;

			// Check if any further replacements result in a loop
			checkForReplacementLoops(map, alreadyChecked, loop, topLevelOverrideName, replacement);
		}

		loop.removeLast();
	}

	public void setTrackReplacements(boolean shouldTrackReplacements) {
		trackReplacements = shouldTrackReplacements;
		if (plugin.isActive())
			reload(true);
	}

	@NonNull
	public TileOverride getOverride(Scene scene, Tile tile) {
		return getOverride(scene, tile, null);
	}

	@NonNull
	public TileOverride getOverride(Scene scene, Tile tile, @Nullable int[] worldPos, int... ids) {
		if (worldPos == null) {
			LocalPoint lp = tile.getLocalLocation();
			worldPos = localToWorld(scene, lp.getX(), lp.getY(), tile.getRenderLevel());
		}
		if (ids.length == 0) {
			var pos = tile.getSceneLocation();
			int x = pos.getX() + SceneUploader.SCENE_OFFSET;
			int y = pos.getY() + SceneUploader.SCENE_OFFSET;
			int z = tile.getRenderLevel();
			int overlayId = OVERLAY_FLAG | scene.getOverlayIds()[z][x][y];
			int underlayId = scene.getUnderlayIds()[z][x][y];
			ids = new int[] { overlayId, underlayId };
		}
		var override = getOverrideBeforeReplacements(worldPos, ids);
		return resolveReplacements(override, tile);
	}

	@NonNull
	public TileOverride getOverrideBeforeReplacements(@Nonnull int[] worldPos, int... ids) {
		var match = TileOverride.NONE;

		outer:
		for (int id : ids) {
			var entries = idMatchOverrides.get(id);
			for (var entry : entries) {
				var area = entry.getKey();
				if (area.containsPoint(worldPos)) {
					match = entry.getValue();
					match.queriedAsOverlay = (id & OVERLAY_FLAG) != 0;
					break outer;
				}
			}
		}

		for (var entry : anyMatchOverrides) {
			var override = entry.getValue();
			if (override.index > match.index)
				break;
			var area = entry.getKey();
			if (area.containsPoint(worldPos)) {
				match = override;
				break;
			}
		}

		return match;
	}

	public TileOverride resolveReplacements(TileOverride override, Tile tile) {
		var replacement = resolveNextReplacement(override, tile);
		if (replacement != override)
			replacement = resolveReplacements(replacement, tile);
		return replacement;
	}

	public TileOverride resolveNextReplacement(TileOverride override, Tile tile) {
		if (override.replacements != null) {
			hslVars.setTile(tile);
			for (var exprReplacement : override.replacements) {
				var replacement = override;
				if (exprReplacement.predicate.test(hslVars))
					replacement = exprReplacement.replacement;
				if (replacement == null)
					return TileOverride.NONE;
				if (replacement != override) {
					replacement.queriedAsOverlay = override.queriedAsOverlay;
					return replacement;
				}
			}
			// Avoid accidentally keeping the old scene in memory
			hslVars.setTile(null);
		}

		return override;
	}

	private static class HslVariables implements VariableSupplier {
		private final String[] HSL_VARS = { "h", "s", "l" };
		private final int[] hsl = new int[3];

		private Tile tile;
		private boolean requiresHslUpdate;

		public void setTile(Tile tile) {
			if (tile == this.tile)
				return;
			this.tile = tile;
			requiresHslUpdate = true;
		}

		@Override
		public Object get(String variableName) {
			for (int i = 0; i < HSL_VARS.length; i++) {
				if (HSL_VARS[i].equals(variableName)) {
					if (requiresHslUpdate) {
						HDUtils.getSouthWesternMostTileColor(hsl, tile);
						requiresHslUpdate = false;
					}
					return hsl[i];
				}
			}

			throw new IllegalArgumentException("Undefined variable '" + variableName + "'");
		}
	}
}

/*
 * Copyright (c) 2018, Adam <Adam@sigterm.info>
 * Copyright (c) 2021, 117 <https://twitter.com/117scape>
 * Copyright (c) 2023, Hooder <ahooder@protonmail.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package rs117.hd;

import com.google.gson.Gson;
import com.google.inject.Provides;
import java.awt.Canvas;
import java.awt.Dimension;
import java.awt.GraphicsConfiguration;
import java.awt.Image;
import java.awt.geom.AffineTransform;
import java.awt.image.BufferedImage;
import java.awt.image.DataBufferInt;
import java.io.IOException;
import java.nio.ByteBuffer;
import java.nio.ByteOrder;
import java.nio.FloatBuffer;
import java.nio.IntBuffer;
import java.nio.ShortBuffer;
import java.time.ZoneOffset;
import java.time.ZonedDateTime;
import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import javax.annotation.Nonnull;
import javax.annotation.Nullable;
import javax.inject.Inject;
import javax.swing.SwingUtilities;
import lombok.Getter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.*;
import net.runelite.api.events.*;
import net.runelite.api.hooks.*;
import net.runelite.client.RuneLite;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.events.ConfigChanged;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.plugins.PluginDependency;
import net.runelite.client.plugins.PluginDescriptor;
import net.runelite.client.plugins.PluginInstantiationException;
import net.runelite.client.plugins.PluginManager;
import net.runelite.client.plugins.entityhider.EntityHiderPlugin;
import net.runelite.client.ui.ClientUI;
import net.runelite.client.ui.DrawManager;
import net.runelite.client.util.LinkBrowser;
import net.runelite.client.util.OSType;
import net.runelite.rlawt.AWTContext;
import org.lwjgl.BufferUtils;
import org.lwjgl.opengl.*;
import org.lwjgl.system.Callback;
import org.lwjgl.system.Configuration;
import rs117.hd.config.AntiAliasingMode;
import rs117.hd.config.ColorFilter;
import rs117.hd.config.SeasonalTheme;
import rs117.hd.config.ShadingMode;
import rs117.hd.config.ShadowMode;
import rs117.hd.config.UIScalingMode;
import rs117.hd.config.VanillaShadowMode;
import rs117.hd.data.WaterType;
import rs117.hd.data.environments.Area;
import rs117.hd.data.materials.Material;
import rs117.hd.model.ModelHasher;
import rs117.hd.model.ModelOffsets;
import rs117.hd.model.ModelPusher;
import rs117.hd.opengl.compute.ComputeMode;
import rs117.hd.opengl.compute.OpenCLManager;
import rs117.hd.opengl.shader.Shader;
import rs117.hd.opengl.shader.ShaderException;
import rs117.hd.opengl.shader.Template;
import rs117.hd.overlays.FrameTimer;
import rs117.hd.overlays.Timer;
import rs117.hd.scene.EnvironmentManager;
import rs117.hd.scene.FishingSpotReplacer;
import rs117.hd.scene.LightManager;
import rs117.hd.scene.ModelOverrideManager;
import rs117.hd.scene.ProceduralGenerator;
import rs117.hd.scene.SceneContext;
import rs117.hd.scene.SceneUploader;
import rs117.hd.scene.TextureManager;
import rs117.hd.scene.TileOverrideManager;
import rs117.hd.scene.lights.Light;
import rs117.hd.scene.model_overrides.ModelOverride;
import rs117.hd.scene.model_overrides.ObjectType;
import rs117.hd.utils.ColorUtils;
import rs117.hd.utils.DeveloperTools;
import rs117.hd.utils.FileWatcher;
import rs117.hd.utils.HDUtils;
import rs117.hd.utils.Mat4;
import rs117.hd.utils.ModelHash;
import rs117.hd.utils.PopupUtils;
import rs117.hd.utils.Props;
import rs117.hd.utils.ResourcePath;
import rs117.hd.utils.buffer.GLBuffer;
import rs117.hd.utils.buffer.GpuIntBuffer;

import static net.runelite.api.Constants.SCENE_SIZE;
import static net.runelite.api.Constants.*;
import static net.runelite.api.Perspective.*;
import static org.lwjgl.opencl.CL10.*;
import static org.lwjgl.opengl.GL43C.*;
import static rs117.hd.HdPluginConfig.*;
import static rs117.hd.scene.SceneUploader.SCENE_OFFSET;
import static rs117.hd.utils.HDUtils.MAX_FLOAT_WITH_128TH_PRECISION;
import static rs117.hd.utils.HDUtils.PI;
import static rs117.hd.utils.HDUtils.clamp;
import static rs117.hd.utils.ResourcePath.path;

@PluginDescriptor(
	name = "117 HD",
	description = "GPU renderer with a suite of graphical enhancements",
	tags = { "hd", "high", "detail", "graphics", "shaders", "textures", "gpu", "shadows", "lights" },
	conflicts = "GPU"
)
@PluginDependency(EntityHiderPlugin.class)
@Slf4j
public class HdPlugin extends Plugin implements DrawCallbacks {
	public static final String DISCORD_URL = "https://discord.gg/U4p6ChjgSE";
	public static final String RUNELITE_URL = "https://runelite.net";
	public static final String AMD_DRIVER_URL = "https://www.amd.com/en/support";
	public static final String INTEL_DRIVER_URL = "https://www.intel.com/content/www/us/en/support/detect.html";
	public static final String NVIDIA_DRIVER_URL = "https://www.nvidia.com/en-us/geforce/drivers/";

	public static final int TEXTURE_UNIT_BASE = GL_TEXTURE0;
	public static final int TEXTURE_UNIT_UI = TEXTURE_UNIT_BASE; // default state
	public static final int TEXTURE_UNIT_GAME = TEXTURE_UNIT_BASE + 1;
	public static final int TEXTURE_UNIT_SHADOW_MAP = TEXTURE_UNIT_BASE + 2;
	public static final int TEXTURE_UNIT_TILE_HEIGHT_MAP = TEXTURE_UNIT_BASE + 3;

	public static final int UNIFORM_BLOCK_CAMERA = 0;
	public static final int UNIFORM_BLOCK_MATERIALS = 1;
	public static final int UNIFORM_BLOCK_WATER_TYPES = 2;
	public static final int UNIFORM_BLOCK_LIGHTS = 3;

	public static final float NEAR_PLANE = 50;
	public static final int MAX_FACE_COUNT = 6144;
	public static final int MAX_DISTANCE = EXTENDED_SCENE_SIZE;
	public static final int GROUND_MIN_Y = 350; // how far below the ground models extend
	public static final int MAX_FOG_DEPTH = 100;
	public static final int SCALAR_BYTES = 4;
	public static final int VERTEX_SIZE = 4; // 4 ints per vertex
	public static final int UV_SIZE = 4; // 4 floats per vertex
	public static final int NORMAL_SIZE = 4; // 4 floats per vertex

	public static float BUFFER_GROWTH_MULTIPLIER = 2; // can be less than 2 if trying to conserve memory

	private static final float COLOR_FILTER_FADE_DURATION = 3000;

	private static final int[] eightIntWrite = new int[8];

	private static final int[] RENDERBUFFER_FORMATS_SRGB = {
		GL_SRGB8,
		GL_SRGB8_ALPHA8 // should be guaranteed
	};
	private static final int[] RENDERBUFFER_FORMATS_SRGB_WITH_ALPHA = {
		GL_SRGB8_ALPHA8 // should be guaranteed
	};
	private static final int[] RENDERBUFFER_FORMATS_LINEAR = {
		GL_RGB8,
		GL_RGBA8,
		GL_RGB, // should be guaranteed
		GL_RGBA // should be guaranteed
	};
	private static final int[] RENDERBUFFER_FORMATS_LINEAR_WITH_ALPHA = {
		GL_RGBA8,
		GL_RGBA // should be guaranteed
	};

	@Inject
	private Client client;

	@Inject
	private ClientUI clientUI;

	@Inject
	private ClientThread clientThread;

	@Inject
	private DrawManager drawManager;

	@Inject
	private PluginManager pluginManager;

	@Inject
	private OpenCLManager openCLManager;

	@Inject
	private TextureManager textureManager;

	@Inject
	private LightManager lightManager;

	@Inject
	private EnvironmentManager environmentManager;

	@Inject
	private TileOverrideManager tileOverrideManager;

	@Inject
	private ModelOverrideManager modelOverrideManager;

	@Inject
	private ProceduralGenerator proceduralGenerator;

	@Inject
	private SceneUploader sceneUploader;

	@Inject
	private ModelPusher modelPusher;

	@Inject
	private ModelHasher modelHasher;

	@Inject
	private FishingSpotReplacer fishingSpotReplacer;

	@Inject
	private DeveloperTools developerTools;

	@Inject
	private FrameTimer frameTimer;

	@Inject
	public HdPluginConfig config;

	@Getter
	private Gson gson;

	public GLCapabilities glCaps;
	private Canvas canvas;
	private AWTContext awtContext;
	private Callback debugCallback;
	private ComputeMode computeMode = ComputeMode.OPENGL;

	private static final String LINUX_VERSION_HEADER =
		"#version 420\n" +
		"#extension GL_ARB_compute_shader : require\n" +
		"#extension GL_ARB_shader_storage_buffer_object : require\n" +
		"#extension GL_ARB_explicit_attrib_location : require\n";
	private static final String WINDOWS_VERSION_HEADER = "#version 430\n";

	private static final Shader PROGRAM = new Shader()
		.add(GL_VERTEX_SHADER, "vert.glsl")
		.add(GL_GEOMETRY_SHADER, "geom.glsl")
		.add(GL_FRAGMENT_SHADER, "frag.glsl");

	private static final Shader SHADOW_PROGRAM_FAST = new Shader()
		.add(GL_VERTEX_SHADER, "shadow_vert.glsl")
		.add(GL_FRAGMENT_SHADER, "shadow_frag.glsl");

	private static final Shader SHADOW_PROGRAM_DETAILED = new Shader()
		.add(GL_VERTEX_SHADER, "shadow_vert.glsl")
		.add(GL_GEOMETRY_SHADER, "shadow_geom.glsl")
		.add(GL_FRAGMENT_SHADER, "shadow_frag.glsl");

	private static final Shader COMPUTE_PROGRAM = new Shader()
		.add(GL_COMPUTE_SHADER, "comp.glsl");

	private static final Shader UNORDERED_COMPUTE_PROGRAM = new Shader()
		.add(GL_COMPUTE_SHADER, "comp_unordered.glsl");

	private static final Shader UI_PROGRAM = new Shader()
		.add(GL_VERTEX_SHADER, "vertui.glsl")
		.add(GL_FRAGMENT_SHADER, "fragui.glsl");

	private static final ResourcePath SHADER_PATH = Props
		.getPathOrDefault("rlhd.shader-path", () -> path(HdPlugin.class))
		.chroot();

	public int glSceneProgram;
	public int glUiProgram;
	public int glShadowProgram;
	public int glModelPassthroughComputeProgram;
	public int[] glModelSortingComputePrograms = {};

	private int interfaceTexture;
	private int interfacePbo;

	private int vaoUiHandle;
	private int vboUiHandle;

	private int vaoSceneHandle;
	private int fboSceneHandle;
	private int rboSceneHandle;

	private int shadowMapResolution;
	private int fboShadowMap;
	private int texShadowMap;

	private int texTileHeightMap;

	private final GLBuffer hStagingBufferVertices = new GLBuffer(); // temporary scene vertex buffer
	private final GLBuffer hStagingBufferUvs = new GLBuffer(); // temporary scene uv buffer
	private final GLBuffer hStagingBufferNormals = new GLBuffer(); // temporary scene normal buffer
	private final GLBuffer hRenderBufferVertices = new GLBuffer(); // target vertex buffer for compute shaders
	private final GLBuffer hRenderBufferUvs = new GLBuffer(); // target uv buffer for compute shaders
	private final GLBuffer hRenderBufferNormals = new GLBuffer(); // target normal buffer for compute shaders

	private int numPassthroughModels;
	private GpuIntBuffer modelPassthroughBuffer;
	private final GLBuffer hModelPassthroughBuffer = new GLBuffer(); // scene model buffer, unordered

	// ordered by face count from small to large
	public int numSortingBins;
	public int maxComputeThreadCount;
	public int[] modelSortingBinFaceCounts; // facesPerThread * threadCount
	public int[] modelSortingBinThreadCounts;
	private int[] numModelsToSort;
	private GpuIntBuffer[] modelSortingBuffers;
	private GLBuffer[] hModelSortingBuffers;

	private final GLBuffer hUniformBufferCamera = new GLBuffer();
	private final GLBuffer hUniformBufferMaterials = new GLBuffer();
	private final GLBuffer hUniformBufferWaterTypes = new GLBuffer();
	private final GLBuffer hUniformBufferLights = new GLBuffer();
	private ByteBuffer uniformBufferCamera;
	private ByteBuffer uniformBufferLights;

	@Getter
	@Nullable
	private SceneContext sceneContext;
	private SceneContext nextSceneContext;

	private int dynamicOffsetVertices;
	private int dynamicOffsetUvs;
	private int renderBufferOffset;

	private int lastCanvasWidth;
	private int lastCanvasHeight;
	private int lastStretchedCanvasWidth;
	private int lastStretchedCanvasHeight;
	private AntiAliasingMode lastAntiAliasingMode;
	private int numSamples;

	private int viewportOffsetX;
	private int viewportOffsetY;
	private int viewportWidth;
	private int viewportHeight;

	// Uniforms
	private int uniColorBlindnessIntensity;
	private int uniUiColorBlindnessIntensity;
	private int uniUseFog;
	private int uniFogColor;
	private int uniFogDepth;
	private int uniDrawDistance;
	private int uniExpandedMapLoadingChunks;
	private int uniWaterColorLight;
	private int uniWaterColorMid;
	private int uniWaterColorDark;
	private int uniAmbientStrength;
	private int uniAmbientColor;
	private int uniLightStrength;
	private int uniLightColor;
	private int uniUnderglowStrength;
	private int uniUnderglowColor;
	private int uniGroundFogStart;
	private int uniGroundFogEnd;
	private int uniGroundFogOpacity;
	private int uniLightningBrightness;
	private int uniSaturation;
	private int uniContrast;
	private int uniLightDir;
	private int uniShadowMaxBias;
	private int uniShadowsEnabled;
	private int uniUnderwaterEnvironment;
	private int uniUnderwaterCaustics;
	private int uniUnderwaterCausticsColor;
	private int uniUnderwaterCausticsStrength;
	private int uniCameraPos;
	private int uniColorFilter;
	private int uniColorFilterPrevious;
	private int uniColorFilterFade;

	// Shadow program uniforms
	private int uniShadowLightProjectionMatrix;
	private int uniShadowElapsedTime;
	private int uniShadowCameraPos;

	// Point light uniforms
	private int uniPointLightsCount;

	private int uniProjectionMatrix;
	private int uniLightProjectionMatrix;
	private int uniShadowMap;
	private int uniUiTexture;
	private int uniTexSourceDimensions;
	private int uniTexTargetDimensions;
	private int uniUiAlphaOverlay;
	private int uniTextureArray;
	private int uniElapsedTime;

	private int uniBlockMaterials;
	private int uniBlockWaterTypes;
	private int uniBlockPointLights;

	// Configs used frequently enough to be worth caching
	public boolean configGroundTextures;
	public boolean configGroundBlending;
	public boolean configModelTextures;
	public boolean configTzhaarHD;
	public boolean configProjectileLights;
	public boolean configNpcLights;
	public boolean configHideFakeShadows;
	public boolean configLegacyGreyColors;
	public boolean configModelBatching;
	public boolean configModelCaching;
	public boolean configShadowsEnabled;
	public boolean configExpandShadowDraw;
	public boolean configUseFasterModelHashing;
	public boolean configUndoVanillaShading;
	public boolean configPreserveVanillaNormals;
	public int configMaxDynamicLights;
	public ShadowMode configShadowMode;
	public SeasonalTheme configSeasonalTheme;
	public VanillaShadowMode configVanillaShadowMode;
	public ColorFilter configColorFilter = ColorFilter.NONE;
	public ColorFilter configColorFilterPrevious;

	public boolean useLowMemoryMode;
	public boolean enableDetailedTimers;
	public boolean enableShadowMapOverlay;
	public boolean enableFreezeFrame;

	@Getter
	private boolean isActive;
	private boolean lwjglInitialized;
	private boolean hasLoggedIn;
	private boolean redrawPreviousFrame;
	private boolean isInChambersOfXeric;
	private boolean isInHouse;
	private Scene skipScene;
	private int previousPlane;

	private final ConcurrentHashMap.KeySetView<String, ?> pendingConfigChanges = ConcurrentHashMap.newKeySet();
	private final Map<Long, ModelOffsets> frameModelInfoMap = new HashMap<>();

	// Camera position and orientation may be reused from the old scene while hopping, prior to drawScene being called
	public final float[] cameraPosition = new float[3];
	public final float[] cameraOrientation = new float[2];
	public final int[] cameraFocalPoint = new int[2];
	public final int[] cameraShift = new int[2];

	public double elapsedTime;
	public double elapsedClientTime;
	public float deltaTime;
	public float deltaClientTime;
	private long lastFrameTimeMillis;
	private double lastFrameClientTime;
	private int gameTicksUntilSceneReload = 0;
	private long colorFilterChangedAt;

	@Provides
	HdPluginConfig provideConfig(ConfigManager configManager) {
		return configManager.getConfig(HdPluginConfig.class);
	}

	@Override
	protected void startUp() {
		gson = injector.getInstance(Gson.class).newBuilder().setLenient().create();

		clientThread.invoke(() -> {
			try {
				if (!textureManager.vanillaTexturesAvailable())
					return false;

				renderBufferOffset = 0;
				fboSceneHandle = rboSceneHandle = 0; // AA FBO
				fboShadowMap = 0;
				numPassthroughModels = 0;
				numModelsToSort = null;
				elapsedTime = 0;
				elapsedClientTime = 0;
				deltaTime = 0;
				deltaClientTime = 0;
				lastFrameTimeMillis = 0;
				lastFrameClientTime = 0;

				AWTContext.loadNatives();
				canvas = client.getCanvas();

				synchronized (canvas.getTreeLock()) {
					// Delay plugin startup until the client's canvas is valid
					if (!canvas.isValid())
						return false;

					awtContext = new AWTContext(canvas);
					awtContext.configurePixelFormat(0, 0, 0);
				}

				awtContext.createGLContext();

				canvas.setIgnoreRepaint(true);

				// lwjgl defaults to lwjgl- + user.name, but this breaks if the username would cause an invalid path
				// to be created.
				Configuration.SHARED_LIBRARY_EXTRACT_DIRECTORY.set("lwjgl-rl");

				glCaps = GL.createCapabilities();
				useLowMemoryMode = config.lowMemoryMode();
				BUFFER_GROWTH_MULTIPLIER = useLowMemoryMode ? 1.333f : 2;

				String glRenderer = glGetString(GL_RENDERER);
				String arch = System.getProperty("sun.arch.data.model", "Unknown");
				if (glRenderer == null)
					glRenderer = "Unknown";
				log.info("Using device: {}", glRenderer);
				log.info("Using driver: {}", glGetString(GL_VERSION));
				log.info("Client is {}-bit", arch);
				log.info("Low memory mode: {}", useLowMemoryMode);

				computeMode = OSType.getOSType() == OSType.MacOS ? ComputeMode.OPENCL : ComputeMode.OPENGL;

				List<String> fallbackDevices = List.of(
					"GDI Generic",
					"D3D12 (Microsoft Basic Render Driver)",
					"softpipe"
				);
				boolean isFallbackGpu = fallbackDevices.contains(glRenderer) && !Props.has("rlhd.allowFallbackGpu");
				boolean isUnsupportedGpu = isFallbackGpu || (computeMode == ComputeMode.OPENGL ? !glCaps.OpenGL43 : !glCaps.OpenGL31);
				if (isUnsupportedGpu) {
					log.error(
						"The GPU is lacking OpenGL {} support. Stopping the plugin...",
						computeMode == ComputeMode.OPENGL ? "4.3" : "3.1"
					);
					displayUnsupportedGpuMessage(isFallbackGpu, glRenderer);
					stopPlugin();
					return true;
				}

				lwjglInitialized = true;
				checkGLErrors();

				if (log.isDebugEnabled() && glCaps.glDebugMessageControl != 0) {
					debugCallback = GLUtil.setupDebugMessageCallback();
					if (debugCallback != null) {
						//	GLDebugEvent[ id 0x20071
						//		type Warning: generic
						//		severity Unknown (0x826b)
						//		source GL API
						//		msg Buffer detailed info: Buffer object 11 (bound to GL_ARRAY_BUFFER_ARB, and GL_SHADER_STORAGE_BUFFER (4), usage hint is GL_STREAM_DRAW) will use VIDEO memory as the source for buffer object operations.
						glDebugMessageControl(GL_DEBUG_SOURCE_API, GL_DEBUG_TYPE_OTHER,
							GL_DONT_CARE, 0x20071, false
						);

						//	GLDebugMessageHandler: GLDebugEvent[ id 0x20052
						//		type Warning: implementation dependent performance
						//		severity Medium: Severe performance/deprecation/other warnings
						//		source GL API
						//		msg Pixel-path performance warning: Pixel transfer is synchronized with 3D rendering.
						glDebugMessageControl(GL_DEBUG_SOURCE_API, GL_DEBUG_TYPE_PERFORMANCE,
							GL_DONT_CARE, 0x20052, false
						);
					}
				}

				updateCachedConfigs();
				developerTools.activate();

				modelPassthroughBuffer = new GpuIntBuffer();

				int maxComputeThreadCount;
				if (computeMode == ComputeMode.OPENCL) {
					openCLManager.startUp(awtContext);
					maxComputeThreadCount = openCLManager.getMaxWorkGroupSize();
				} else {
					maxComputeThreadCount = glGetInteger(GL_MAX_COMPUTE_WORK_GROUP_INVOCATIONS);
				}
				initModelSortingBins(maxComputeThreadCount);

				setupSyncMode();
				initVaos();
				initBuffers();

				// Materials need to be initialized before compiling shader programs
				textureManager.startUp();

				initPrograms();
				initShaderHotswapping();
				initInterfaceTexture();
				initShadowMapFbo();

				checkGLErrors();

				client.setDrawCallbacks(this);
				client.setGpuFlags(
					DrawCallbacks.GPU |
					DrawCallbacks.HILLSKEW |
					DrawCallbacks.NORMALS |
					(config.removeVertexSnapping() ? DrawCallbacks.NO_VERTEX_SNAPPING : 0)
				);
				client.setExpandedMapLoading(getExpandedMapLoadingChunks());
				// force rebuild of main buffer provider to enable alpha channel
				client.resizeCanvas();

				lastCanvasWidth = lastCanvasHeight = 0;
				lastStretchedCanvasWidth = lastStretchedCanvasHeight = 0;
				lastAntiAliasingMode = null;

				tileOverrideManager.startUp();
				modelOverrideManager.startUp();
				modelPusher.startUp();
				lightManager.startUp();
				environmentManager.startUp();
				fishingSpotReplacer.startUp();

				isActive = true;
				hasLoggedIn = client.getGameState().getState() > GameState.LOGGING_IN.getState();
				redrawPreviousFrame = false;
				skipScene = null;
				isInHouse = false;
				isInChambersOfXeric = false;

				if (client.getGameState() == GameState.LOGGED_IN) {
					// We need to force the client to reload the scene if GPU flags have changed
					client.setGameState(GameState.LOADING);
				}

				checkGLErrors();

				clientThread.invokeLater(this::displayUpdateMessage);
			}
			catch (Throwable err)
			{
				log.error("Error while starting 117HD", err);
				stopPlugin();
			}
			return true;
		});
	}

	@Override
	protected void shutDown() {
		isActive = false;
		FileWatcher.destroy();

		clientThread.invoke(() -> {
			var scene = client.getScene();
			if (scene != null)
				scene.setMinLevel(0);

			client.setGpuFlags(0);
			client.setDrawCallbacks(null);
			client.setUnlockedFps(false);
			client.setExpandedMapLoading(0);

			developerTools.deactivate();
			modelPusher.shutDown();
			tileOverrideManager.shutDown();
			modelOverrideManager.shutDown();
			lightManager.shutDown();
			environmentManager.shutDown();
			fishingSpotReplacer.shutDown();

			if (lwjglInitialized) {
				lwjglInitialized = false;
				waitUntilIdle();

				textureManager.shutDown();

				destroyBuffers();
				destroyInterfaceTexture();
				destroyPrograms();
				destroyVaos();
				destroySceneFbo();
				destroyShadowMapFbo();
				destroyTileHeightMap();
				destroyModelSortingBins();

				openCLManager.shutDown();
			}

			if (awtContext != null)
				awtContext.destroy();
			awtContext = null;

			if (debugCallback != null)
				debugCallback.free();
			debugCallback = null;

			if (sceneContext != null)
				sceneContext.destroy();
			sceneContext = null;

			synchronized (this) {
				if (nextSceneContext != null)
					nextSceneContext.destroy();
				nextSceneContext = null;
			}

			if (modelPassthroughBuffer != null)
				modelPassthroughBuffer.destroy();
			modelPassthroughBuffer = null;

			// force main buffer provider rebuild to turn off alpha channel
			client.resizeCanvas();
		});
	}

	public void stopPlugin()
	{
		SwingUtilities.invokeLater(() ->
		{
			try
			{
				pluginManager.setPluginEnabled(this, false);
				pluginManager.stopPlugin(this);
			}
			catch (PluginInstantiationException ex)
			{
				log.error("Error while stopping 117HD:", ex);
			}
		});

		shutDown();
	}

	public void restartPlugin() {
		// For some reason, it's necessary to delay this like below to prevent the canvas from locking up on Linux
		SwingUtilities.invokeLater(() -> clientThread.invokeLater(() -> {
			shutDown();
			startUp();
		}));
	}

	public void toggleFreezeFrame() {
		clientThread.invoke(() -> {
			enableFreezeFrame = !enableFreezeFrame;
			if (enableFreezeFrame)
				redrawPreviousFrame = true;
		});
	}

	private String generateFetchCases(String array, int from, int to)
	{
		int length = to - from;
		if (length <= 1)
		{
			return array + "[" + from + "]";
		}
		int middle = from + length / 2;
		return "i < " + middle +
			" ? " + generateFetchCases(array, from, middle) +
			" : " + generateFetchCases(array, middle, to);
	}

	private String generateGetter(String type, int arrayLength)
	{
		StringBuilder include = new StringBuilder();

		boolean isAppleM1 = OSType.getOSType() == OSType.MacOS && System.getProperty("os.arch").equals("aarch64");
		if (config.macosIntelWorkaround() && !isAppleM1)
		{
			// Workaround wrapper for drivers that do not support dynamic indexing,
			// particularly Intel drivers on macOS
			include
				.append(type)
				.append(" ")
				.append("get")
				.append(type)
				.append("(int i) { return ")
				.append(generateFetchCases(type + "Array", 0, arrayLength))
				.append("; }\n");
		}
		else
		{
			include
				.append("#define get")
				.append(type)
				.append("(i) ")
				.append(type)
				.append("Array[i]\n");
		}

		return include.toString();
	}

	private void initPrograms() throws ShaderException, IOException
	{
		String versionHeader = OSType.getOSType() == OSType.Linux ? LINUX_VERSION_HEADER : WINDOWS_VERSION_HEADER;
		Template template = new Template()
			.addInclude("VERSION_HEADER", versionHeader)
			.define("UI_SCALING_MODE", config.uiScalingMode().getMode())
			.define("COLOR_BLINDNESS", config.colorBlindness())
			.define("APPLY_COLOR_FILTER", configColorFilter != ColorFilter.NONE)
			.define("MATERIAL_CONSTANTS", () -> {
				StringBuilder include = new StringBuilder();
				for (Material m : Material.values())
				{
					include
						.append("#define MAT_")
						.append(m.name().toUpperCase())
						.append(" getMaterial(")
						.append(textureManager.getMaterialIndex(m, m.vanillaTextureIndex))
						.append(")\n");
				}
				return include.toString();
			})
			.define("MATERIAL_COUNT", Material.values().length)
			.define("MATERIAL_GETTER", () -> generateGetter("Material", Material.values().length))
			.define("WATER_TYPE_COUNT", WaterType.values().length)
			.define("WATER_TYPE_GETTER", () -> generateGetter("WaterType", WaterType.values().length))
			.define("LIGHT_COUNT", Math.max(1, configMaxDynamicLights))
			.define("LIGHT_GETTER", () -> generateGetter("PointLight", configMaxDynamicLights))
			.define("NORMAL_MAPPING", config.normalMapping())
			.define("PARALLAX_OCCLUSION_MAPPING", config.parallaxOcclusionMapping())
			.define("SHADOW_MODE", configShadowMode)
			.define("SHADOW_TRANSPARENCY", config.enableShadowTransparency())
			.define("VANILLA_COLOR_BANDING", config.vanillaColorBanding())
			.define("UNDO_VANILLA_SHADING", configUndoVanillaShading)
			.define("LEGACY_GREY_COLORS", configLegacyGreyColors)
			.define("DISABLE_DIRECTIONAL_SHADING", config.shadingMode() != ShadingMode.DEFAULT)
			.define("FLAT_SHADING", config.flatShading())
			.define("SHADOW_MAP_OVERLAY", enableShadowMapOverlay)
			.addIncludePath(SHADER_PATH);

		glSceneProgram = PROGRAM.compile(template);
		glUiProgram = UI_PROGRAM.compile(template);

		switch (configShadowMode) {
			case FAST:
				glShadowProgram = SHADOW_PROGRAM_FAST.compile(template);
				break;
			case DETAILED:
				glShadowProgram = SHADOW_PROGRAM_DETAILED.compile(template);
				break;
		}

		if (computeMode == ComputeMode.OPENCL) {
			openCLManager.initPrograms();
		} else {
			glModelPassthroughComputeProgram = UNORDERED_COMPUTE_PROGRAM.compile(template);

			glModelSortingComputePrograms = new int[numSortingBins];
			for (int i = 0; i < numSortingBins; i++) {
				int faceCount = modelSortingBinFaceCounts[i];
				int threadCount = modelSortingBinThreadCounts[i];
				int facesPerThread = (int) Math.ceil((float) faceCount / threadCount);
				glModelSortingComputePrograms[i] = COMPUTE_PROGRAM.compile(template
					.copy()
					.define("THREAD_COUNT", threadCount)
					.define("FACES_PER_THREAD", facesPerThread)
				);
			}
		}

		initUniforms();

		// Bind texture samplers before validating, else the validation fails
		glUseProgram(glSceneProgram);
		glUniform1i(uniTextureArray, TEXTURE_UNIT_GAME - TEXTURE_UNIT_BASE);
		glUniform1i(uniShadowMap, TEXTURE_UNIT_SHADOW_MAP - TEXTURE_UNIT_BASE);

		// Bind a VOA, else validation may fail on older Intel-based Macs
		glBindVertexArray(vaoSceneHandle);

		// Validate program
		glValidateProgram(glSceneProgram);
		if (glGetProgrami(glSceneProgram, GL_VALIDATE_STATUS) == GL_FALSE) {
			String err = glGetProgramInfoLog(glSceneProgram);
			throw new ShaderException(err);
		}

		glUseProgram(glUiProgram);
		glUniform1i(uniUiTexture, TEXTURE_UNIT_UI - TEXTURE_UNIT_BASE);

		glUseProgram(0);
	}

	private void initUniforms() {
		uniProjectionMatrix = glGetUniformLocation(glSceneProgram, "projectionMatrix");
		uniLightProjectionMatrix = glGetUniformLocation(glSceneProgram, "lightProjectionMatrix");
		uniShadowMap = glGetUniformLocation(glSceneProgram, "shadowMap");
		uniSaturation = glGetUniformLocation(glSceneProgram, "saturation");
		uniContrast = glGetUniformLocation(glSceneProgram, "contrast");
		uniUseFog = glGetUniformLocation(glSceneProgram, "useFog");
		uniFogColor = glGetUniformLocation(glSceneProgram, "fogColor");
		uniFogDepth = glGetUniformLocation(glSceneProgram, "fogDepth");
		uniWaterColorLight = glGetUniformLocation(glSceneProgram, "waterColorLight");
		uniWaterColorMid = glGetUniformLocation(glSceneProgram, "waterColorMid");
		uniWaterColorDark = glGetUniformLocation(glSceneProgram, "waterColorDark");
		uniDrawDistance = glGetUniformLocation(glSceneProgram, "drawDistance");
		uniExpandedMapLoadingChunks = glGetUniformLocation(glSceneProgram, "expandedMapLoadingChunks");
		uniAmbientStrength = glGetUniformLocation(glSceneProgram, "ambientStrength");
		uniAmbientColor = glGetUniformLocation(glSceneProgram, "ambientColor");
		uniLightStrength = glGetUniformLocation(glSceneProgram, "lightStrength");
		uniLightColor = glGetUniformLocation(glSceneProgram, "lightColor");
		uniUnderglowStrength = glGetUniformLocation(glSceneProgram, "underglowStrength");
		uniUnderglowColor = glGetUniformLocation(glSceneProgram, "underglowColor");
		uniGroundFogStart = glGetUniformLocation(glSceneProgram, "groundFogStart");
		uniGroundFogEnd = glGetUniformLocation(glSceneProgram, "groundFogEnd");
		uniGroundFogOpacity = glGetUniformLocation(glSceneProgram, "groundFogOpacity");
		uniLightningBrightness = glGetUniformLocation(glSceneProgram, "lightningBrightness");
		uniPointLightsCount = glGetUniformLocation(glSceneProgram, "pointLightsCount");
		uniColorBlindnessIntensity = glGetUniformLocation(glSceneProgram, "colorBlindnessIntensity");
		uniLightDir = glGetUniformLocation(glSceneProgram, "lightDir");
		uniShadowMaxBias = glGetUniformLocation(glSceneProgram, "shadowMaxBias");
		uniShadowsEnabled = glGetUniformLocation(glSceneProgram, "shadowsEnabled");
		uniUnderwaterEnvironment = glGetUniformLocation(glSceneProgram, "underwaterEnvironment");
		uniUnderwaterCaustics = glGetUniformLocation(glSceneProgram, "underwaterCaustics");
		uniUnderwaterCausticsColor = glGetUniformLocation(glSceneProgram, "underwaterCausticsColor");
		uniUnderwaterCausticsStrength = glGetUniformLocation(glSceneProgram, "underwaterCausticsStrength");
		uniCameraPos = glGetUniformLocation(glSceneProgram, "cameraPos");
		uniTextureArray = glGetUniformLocation(glSceneProgram, "textureArray");
		uniElapsedTime = glGetUniformLocation(glSceneProgram, "elapsedTime");

		if (configColorFilter != ColorFilter.NONE) {
			uniColorFilter = glGetUniformLocation(glSceneProgram, "colorFilter");
			uniColorFilterPrevious = glGetUniformLocation(glSceneProgram, "colorFilterPrevious");
			uniColorFilterFade = glGetUniformLocation(glSceneProgram, "colorFilterFade");
		}

		uniUiTexture = glGetUniformLocation(glUiProgram, "uiTexture");
		uniTexTargetDimensions = glGetUniformLocation(glUiProgram, "targetDimensions");
		uniTexSourceDimensions = glGetUniformLocation(glUiProgram, "sourceDimensions");
		uniUiColorBlindnessIntensity = glGetUniformLocation(glUiProgram, "colorBlindnessIntensity");
		uniUiAlphaOverlay = glGetUniformLocation(glUiProgram, "alphaOverlay");

		uniBlockMaterials = glGetUniformBlockIndex(glSceneProgram, "MaterialUniforms");
		uniBlockWaterTypes = glGetUniformBlockIndex(glSceneProgram, "WaterTypeUniforms");
		uniBlockPointLights = glGetUniformBlockIndex(glSceneProgram, "PointLightUniforms");

		if (computeMode == ComputeMode.OPENGL) {
			for (int sortingProgram : glModelSortingComputePrograms) {
				int uniBlockCamera = glGetUniformBlockIndex(sortingProgram, "CameraUniforms");
				glUniformBlockBinding(sortingProgram, uniBlockCamera, UNIFORM_BLOCK_CAMERA);
			}
		}

		// Shadow program uniforms
		switch (configShadowMode) {
			case DETAILED:
				int uniShadowBlockMaterials = glGetUniformBlockIndex(glShadowProgram, "MaterialUniforms");
				int uniShadowTextureArray = glGetUniformLocation(glShadowProgram, "textureArray");
				glUseProgram(glShadowProgram);
				glUniform1i(uniShadowTextureArray, TEXTURE_UNIT_GAME - TEXTURE_UNIT_BASE);
				glUniformBlockBinding(glShadowProgram, uniShadowBlockMaterials, UNIFORM_BLOCK_MATERIALS);
				uniShadowElapsedTime = glGetUniformLocation(glShadowProgram, "elapsedTime");
				uniShadowCameraPos = glGetUniformLocation(glShadowProgram, "cameraPos");
				// fall-through
			case FAST:
				uniShadowLightProjectionMatrix = glGetUniformLocation(glShadowProgram, "lightProjectionMatrix");
		}

		// Initialize uniform buffers that may depend on compile-time settings
		initCameraUniformBuffer();
		initLightsUniformBuffer();
	}

	private void destroyPrograms() {
		if (glSceneProgram != 0)
			glDeleteProgram(glSceneProgram);
		glSceneProgram = 0;

		if (glUiProgram != 0)
			glDeleteProgram(glUiProgram);
		glUiProgram = 0;

		if (glShadowProgram != 0)
			glDeleteProgram(glShadowProgram);
		glShadowProgram = 0;

		if (computeMode == ComputeMode.OPENGL) {
			if (glModelPassthroughComputeProgram != 0)
				glDeleteProgram(glModelPassthroughComputeProgram);
			glModelPassthroughComputeProgram = 0;

			if (glModelSortingComputePrograms != null)
				for (int program : glModelSortingComputePrograms)
					glDeleteProgram(program);
			glModelSortingComputePrograms = null;
		} else {
			openCLManager.destroyPrograms();
		}
	}

	public void recompilePrograms() throws ShaderException, IOException {
		// Avoid recompiling if we haven't already compiled once
		if (glSceneProgram == 0)
			return;

		destroyPrograms();
		initPrograms();
	}

	private void initModelSortingBins(int maxThreadCount) {
		maxComputeThreadCount = maxThreadCount;

		int[] targetFaceCounts = {
			128,
			512,
			2048,
			4096,
			MAX_FACE_COUNT
		};

		int numBins = 0;
		int[] binFaceCounts = new int[targetFaceCounts.length];
		int[] binThreadCounts = new int[targetFaceCounts.length];

		int faceCount = 0;
		for (int targetFaceCount : targetFaceCounts) {
			if (faceCount >= targetFaceCount)
				continue;

			int facesPerThread = 1;
			int threadCount;
			while (true) {
				threadCount = (int) Math.ceil((float) targetFaceCount / facesPerThread);
				if (threadCount <= maxThreadCount)
					break;
				++facesPerThread;
			}

			faceCount = threadCount * facesPerThread;
			binFaceCounts[numBins] = faceCount;
			binThreadCounts[numBins] = threadCount;
			++numBins;
		}

		numSortingBins = numBins;
		modelSortingBinFaceCounts = Arrays.copyOf(binFaceCounts, numBins);
		modelSortingBinThreadCounts = Arrays.copyOf(binThreadCounts, numBins);
		numModelsToSort = new int[numBins];

		modelSortingBuffers = new GpuIntBuffer[numSortingBins];
		for (int i = 0; i < numSortingBins; i++)
			modelSortingBuffers[i] = new GpuIntBuffer();

		hModelSortingBuffers = new GLBuffer[numSortingBins];
		for (int i = 0; i < numSortingBins; i++) {
			hModelSortingBuffers[i] = new GLBuffer();
			initGlBuffer(hModelSortingBuffers[i], GL_ARRAY_BUFFER, GL_STREAM_DRAW, CL_MEM_READ_ONLY);
		}

		log.debug("Spreading model sorting across {} bins: {}", numBins, modelSortingBinFaceCounts);
	}

	private void destroyModelSortingBins() {
		// Don't allow redrawing the previous frame if the model sorting buffers are no longer valid
		redrawPreviousFrame = false;

		numSortingBins = 0;
		modelSortingBinFaceCounts = null;
		modelSortingBinThreadCounts = null;
		numModelsToSort = null;

		if (modelSortingBuffers != null)
			for (var buffer : modelSortingBuffers)
				buffer.destroy();
		modelSortingBuffers = null;

		if (hModelSortingBuffers != null)
			for (var buffer : hModelSortingBuffers)
				destroyGlBuffer(buffer);
		hModelSortingBuffers = null;
	}

	private void initVaos() {
		// Create scene VAO
		vaoSceneHandle = glGenVertexArrays();

		// Create UI VAO
		vaoUiHandle = glGenVertexArrays();
		// Create UI buffer
		vboUiHandle = glGenBuffers();
		glBindVertexArray(vaoUiHandle);

		FloatBuffer vboUiData = BufferUtils.createFloatBuffer(5 * 4)
			.put(new float[] {
				// vertices, UVs
				1, 1, 0, 1, 0, // top right
				1, -1, 0, 1, 1, // bottom right
				-1, -1, 0, 0, 1, // bottom left
				-1, 1, 0, 0, 0  // top left
			})
			.flip();
		glBindBuffer(GL_ARRAY_BUFFER, vboUiHandle);
		glBufferData(GL_ARRAY_BUFFER, vboUiData, GL_STATIC_DRAW);

		// position attribute
		glVertexAttribPointer(0, 3, GL_FLOAT, false, 5 * Float.BYTES, 0);
		glEnableVertexAttribArray(0);

		// texture coord attribute
		glVertexAttribPointer(1, 2, GL_FLOAT, false, 5 * Float.BYTES, 3 * Float.BYTES);
		glEnableVertexAttribArray(1);
	}

	private void updateSceneVao(GLBuffer vertexBuffer, GLBuffer uvBuffer, GLBuffer normalBuffer) {
		glBindVertexArray(vaoSceneHandle);

		glEnableVertexAttribArray(0);
		glBindBuffer(GL_ARRAY_BUFFER, vertexBuffer.glBufferId);
		glVertexAttribPointer(0, 3, GL_FLOAT, false, 16, 0);

		glEnableVertexAttribArray(1);
		glBindBuffer(GL_ARRAY_BUFFER, vertexBuffer.glBufferId);
		glVertexAttribIPointer(1, 1, GL_INT, 16, 12);

		glEnableVertexAttribArray(2);
		glBindBuffer(GL_ARRAY_BUFFER, uvBuffer.glBufferId);
		glVertexAttribPointer(2, 4, GL_FLOAT, false, 0, 0);

		glEnableVertexAttribArray(3);
		glBindBuffer(GL_ARRAY_BUFFER, normalBuffer.glBufferId);
		glVertexAttribPointer(3, 4, GL_FLOAT, false, 0, 0);
	}

	private void destroyVaos() {
		if (vaoSceneHandle != 0)
			glDeleteVertexArrays(vaoSceneHandle);
		vaoSceneHandle = 0;

		if (vboUiHandle != 0)
			glDeleteBuffers(vboUiHandle);
		vboUiHandle = 0;

		if (vaoUiHandle != 0)
			glDeleteVertexArrays(vaoUiHandle);
		vaoUiHandle = 0;
	}

	private void initBuffers() {
		initGlBuffer(hUniformBufferCamera, GL_UNIFORM_BUFFER, GL_DYNAMIC_DRAW, CL_MEM_READ_ONLY);
		initGlBuffer(hUniformBufferMaterials, GL_UNIFORM_BUFFER, GL_STATIC_DRAW, CL_MEM_READ_ONLY);
		initGlBuffer(hUniformBufferWaterTypes, GL_UNIFORM_BUFFER, GL_STATIC_DRAW, CL_MEM_READ_ONLY);
		initGlBuffer(hUniformBufferLights, GL_UNIFORM_BUFFER, GL_STREAM_DRAW, CL_MEM_READ_ONLY);

		glBindBufferBase(GL_UNIFORM_BUFFER, UNIFORM_BLOCK_CAMERA, hUniformBufferCamera.glBufferId);
		glBindBufferBase(GL_UNIFORM_BUFFER, UNIFORM_BLOCK_MATERIALS, hUniformBufferMaterials.glBufferId);
		glBindBufferBase(GL_UNIFORM_BUFFER, UNIFORM_BLOCK_WATER_TYPES, hUniformBufferWaterTypes.glBufferId);
		glBindBufferBase(GL_UNIFORM_BUFFER, UNIFORM_BLOCK_LIGHTS, hUniformBufferLights.glBufferId);

		initGlBuffer(hStagingBufferVertices, GL_ARRAY_BUFFER, GL_STREAM_DRAW, CL_MEM_READ_ONLY);
		initGlBuffer(hStagingBufferUvs, GL_ARRAY_BUFFER, GL_STREAM_DRAW, CL_MEM_READ_ONLY);
		initGlBuffer(hStagingBufferNormals, GL_ARRAY_BUFFER, GL_STREAM_DRAW, CL_MEM_READ_ONLY);

		initGlBuffer(hRenderBufferVertices, GL_ARRAY_BUFFER, GL_STREAM_DRAW, CL_MEM_WRITE_ONLY);
		initGlBuffer(hRenderBufferUvs, GL_ARRAY_BUFFER, GL_STREAM_DRAW, CL_MEM_WRITE_ONLY);
		initGlBuffer(hRenderBufferNormals, GL_ARRAY_BUFFER, GL_STREAM_DRAW, CL_MEM_WRITE_ONLY);

		initGlBuffer(hModelPassthroughBuffer, GL_ARRAY_BUFFER, GL_STREAM_DRAW, CL_MEM_READ_ONLY);
	}

	private void initGlBuffer(GLBuffer glBuffer, int target, int glUsage, int clUsage) {
		glBuffer.glBufferId = glGenBuffers();
		// Initialize both GL and CL buffers to dummy buffers of a single byte,
		// to ensure that valid buffers are given to compute dispatches.
		// This is particularly important on Apple M2 Max, where an uninitialized buffer leads to a crash
		updateBuffer(glBuffer, target, 1, glUsage, clUsage);
	}

	private void destroyBuffers() {
		destroyGlBuffer(hUniformBufferCamera);
		destroyGlBuffer(hUniformBufferMaterials);
		destroyGlBuffer(hUniformBufferWaterTypes);
		destroyGlBuffer(hUniformBufferLights);

		destroyGlBuffer(hStagingBufferVertices);
		destroyGlBuffer(hStagingBufferUvs);
		destroyGlBuffer(hStagingBufferNormals);

		destroyGlBuffer(hRenderBufferVertices);
		destroyGlBuffer(hRenderBufferUvs);
		destroyGlBuffer(hRenderBufferNormals);

		destroyGlBuffer(hModelPassthroughBuffer);

		uniformBufferCamera = null;
		uniformBufferLights = null;
	}

	private void destroyGlBuffer(GLBuffer glBuffer) {
		glBuffer.size = -1;

		if (glBuffer.glBufferId != 0) {
			glDeleteBuffers(glBuffer.glBufferId);
			glBuffer.glBufferId = 0;
		}

		if (glBuffer.clBuffer != 0) {
			clReleaseMemObject(glBuffer.clBuffer);
			glBuffer.clBuffer = 0;
		}
	}

	private void initInterfaceTexture()
	{
		interfacePbo = glGenBuffers();

		interfaceTexture = glGenTextures();
		glBindTexture(GL_TEXTURE_2D, interfaceTexture);
		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);
		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
		glBindTexture(GL_TEXTURE_2D, 0);
	}

	private void destroyInterfaceTexture()
	{
		if (interfacePbo != 0)
		{
			glDeleteBuffers(interfacePbo);
			interfacePbo = 0;
		}

		if (interfaceTexture != 0)
		{
			glDeleteTextures(interfaceTexture);
			interfaceTexture = 0;
		}
	}

	private void initCameraUniformBuffer()
	{
		int size = 8 * SCALAR_BYTES;
		uniformBufferCamera = BufferUtils.createByteBuffer(size);
		updateBuffer(hUniformBufferCamera, GL_UNIFORM_BUFFER, size, GL_DYNAMIC_DRAW, CL_MEM_READ_ONLY);
		glBindBuffer(GL_UNIFORM_BUFFER, 0);
	}

	public void updateMaterialUniformBuffer(ByteBuffer buffer) {
		updateBuffer(hUniformBufferMaterials, GL_UNIFORM_BUFFER, buffer, GL_STATIC_DRAW, CL_MEM_READ_ONLY);
	}

	public void updateWaterTypeUniformBuffer(ByteBuffer buffer) {
		updateBuffer(hUniformBufferWaterTypes, GL_UNIFORM_BUFFER, buffer, GL_STATIC_DRAW, CL_MEM_READ_ONLY);
	}

	private void initLightsUniformBuffer()
	{
		// Allowing a buffer size of zero causes Apple M1/M2 to revert to software rendering
		uniformBufferLights = BufferUtils.createByteBuffer(Math.max(1, configMaxDynamicLights) * 8 * SCALAR_BYTES);
		updateBuffer(hUniformBufferLights, GL_UNIFORM_BUFFER, uniformBufferLights, GL_STREAM_DRAW, CL_MEM_READ_ONLY);
	}

	private void initSceneFbo(int width, int height, AntiAliasingMode antiAliasingMode) {
		// Bind default FBO to check whether anti-aliasing is forced
		int defaultFramebuffer = awtContext.getFramebuffer(false);
		glBindFramebuffer(GL_FRAMEBUFFER, defaultFramebuffer);
		final int forcedAASamples = glGetInteger(GL_SAMPLES);
		final int maxSamples = glGetInteger(GL_MAX_SAMPLES);
		numSamples = forcedAASamples != 0 ? forcedAASamples :
			Math.min(antiAliasingMode.getSamples(), maxSamples);

		// Since there's seemingly no reliable way to check if the default framebuffer will do sRGB conversions with GL_FRAMEBUFFER_SRGB
		// enabled, we always replace the default framebuffer with an sRGB one. We could technically support rendering to the default
		// framebuffer when sRGB conversions aren't needed, but the goal is to transition to linear blending in the future anyway.
		boolean sRGB = false; // This is currently unused

		// Some implementations (*cough* Apple) complain when blitting from an FBO without an alpha channel to a (default) FBO with alpha.
		// To work around this, we select a format which includes an alpha channel, even though we don't need it.
		int defaultColorAttachment = defaultFramebuffer == 0 ? GL_BACK_LEFT : GL_COLOR_ATTACHMENT0;
		int alphaBits = glGetFramebufferAttachmentParameteri(GL_FRAMEBUFFER, defaultColorAttachment, GL_FRAMEBUFFER_ATTACHMENT_ALPHA_SIZE);
		checkGLErrors();
		boolean alpha = alphaBits > 0;

		int[] desiredFormats = sRGB ?
			alpha ? RENDERBUFFER_FORMATS_SRGB_WITH_ALPHA : RENDERBUFFER_FORMATS_SRGB :
			alpha ? RENDERBUFFER_FORMATS_LINEAR_WITH_ALPHA : RENDERBUFFER_FORMATS_LINEAR;

		int[] resolution = applyDpiScaling(width, height);

		// Create and bind the FBO
		fboSceneHandle = glGenFramebuffers();
		glBindFramebuffer(GL_FRAMEBUFFER, fboSceneHandle);

		// Create color render buffer
		rboSceneHandle = glGenRenderbuffers();
		glBindRenderbuffer(GL_RENDERBUFFER, rboSceneHandle);

		// Flush out all pending errors, so we can check whether the next step succeeds
		clearGLErrors();

		for (int format : desiredFormats) {
			glRenderbufferStorageMultisample(GL_RENDERBUFFER, numSamples, format, resolution[0], resolution[1]);

			if (glGetError() == GL_NO_ERROR) {
				// Found a usable format. Bind the RBO to the scene FBO
				glFramebufferRenderbuffer(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_RENDERBUFFER, rboSceneHandle);
				checkGLErrors();

				// Reset
				glBindFramebuffer(GL_FRAMEBUFFER, awtContext.getFramebuffer(false));
				glBindRenderbuffer(GL_RENDERBUFFER, 0);
				return;
			}
		}

		throw new RuntimeException("No supported " + (sRGB ? "sRGB" : "linear") + " formats");
	}

	private void destroySceneFbo()
	{
		if (fboSceneHandle != 0)
		{
			glDeleteFramebuffers(fboSceneHandle);
			fboSceneHandle = 0;
		}

		if (rboSceneHandle != 0)
		{
			glDeleteRenderbuffers(rboSceneHandle);
			rboSceneHandle = 0;
		}
	}

	private void initShadowMapFbo()
	{
		// Bind shadow map, or dummy 1x1 texture
		glActiveTexture(TEXTURE_UNIT_SHADOW_MAP);

		if (configShadowsEnabled)
		{
			// Create and bind the FBO
			fboShadowMap = glGenFramebuffers();
			glBindFramebuffer(GL_FRAMEBUFFER, fboShadowMap);

			// Create texture
			texShadowMap = glGenTextures();
			glBindTexture(GL_TEXTURE_2D, texShadowMap);

			shadowMapResolution = config.shadowResolution().getValue();
			int maxResolution = glGetInteger(GL_MAX_TEXTURE_SIZE);
			if (maxResolution < shadowMapResolution) {
				log.info("Capping shadow resolution from {} to {}", shadowMapResolution, maxResolution);
				shadowMapResolution = maxResolution;
			}

			glTexImage2D(
				GL_TEXTURE_2D,
				0,
				GL_DEPTH_COMPONENT24,
				shadowMapResolution,
				shadowMapResolution,
				0,
				GL_DEPTH_COMPONENT,
				GL_FLOAT,
				0
			);
			glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
			glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);
			glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_BORDER);
			glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_BORDER);

			float[] color = { 1, 1, 1, 1 };
			glTexParameterfv(GL_TEXTURE_2D, GL_TEXTURE_BORDER_COLOR, color);

			// Bind texture
			glFramebufferTexture2D(GL_FRAMEBUFFER, GL_DEPTH_ATTACHMENT, GL_TEXTURE_2D, texShadowMap, 0);
			glDrawBuffer(GL_NONE);
			glReadBuffer(GL_NONE);

			// Reset FBO
			glBindFramebuffer(GL_FRAMEBUFFER, awtContext.getFramebuffer(false));
		}
		else
		{
			initDummyShadowMap();
		}

		// Reset active texture to UI texture
		glActiveTexture(TEXTURE_UNIT_UI);
	}

	private void initDummyShadowMap()
	{
		// Create texture
		texShadowMap = glGenTextures();
		glBindTexture(GL_TEXTURE_2D, texShadowMap);
		glTexImage2D(GL_TEXTURE_2D, 0, GL_DEPTH_COMPONENT, 1, 1, 0, GL_DEPTH_COMPONENT, GL_FLOAT, 0);
		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);
		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_BORDER);
		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_BORDER);

		// Reset
		glBindTexture(GL_TEXTURE_2D, 0);
	}

	private void destroyShadowMapFbo() {
		if (texShadowMap != 0)
			glDeleteTextures(texShadowMap);
		texShadowMap = 0;

		if (fboShadowMap != 0)
			glDeleteFramebuffers(fboShadowMap);
		fboShadowMap = 0;
	}

	private void initTileHeightMap(Scene scene) {
		final int TILE_HEIGHT_BUFFER_SIZE = Constants.MAX_Z * EXTENDED_SCENE_SIZE * EXTENDED_SCENE_SIZE * Short.BYTES;
		ShortBuffer tileBuffer = ByteBuffer
			.allocateDirect(TILE_HEIGHT_BUFFER_SIZE)
			.order(ByteOrder.nativeOrder())
			.asShortBuffer();

		int[][][] tileHeights = scene.getTileHeights();
		for (int z = 0; z < Constants.MAX_Z; ++z) {
			for (int y = 0; y < EXTENDED_SCENE_SIZE; ++y) {
				for (int x = 0; x < EXTENDED_SCENE_SIZE; ++x) {
					int h = tileHeights[z][x][y];
					assert (h & 0b111) == 0;
					h >>= 3;
					tileBuffer.put((short) h);
				}
			}
		}
		tileBuffer.flip();

		glActiveTexture(TEXTURE_UNIT_TILE_HEIGHT_MAP);

		texTileHeightMap = glGenTextures();
		glBindTexture(GL_TEXTURE_3D, texTileHeightMap);
		glTexParameteri(GL_TEXTURE_3D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
		glTexParameteri(GL_TEXTURE_3D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);
		glTexParameteri(GL_TEXTURE_3D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
		glTexParameteri(GL_TEXTURE_3D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);
		glTexImage3D(GL_TEXTURE_3D, 0, GL_R16I,
			EXTENDED_SCENE_SIZE, EXTENDED_SCENE_SIZE, Constants.MAX_Z,
			0, GL_RED_INTEGER, GL_SHORT, tileBuffer
		);

		glActiveTexture(TEXTURE_UNIT_UI); // default state
	}

	private void destroyTileHeightMap() {
		if (texTileHeightMap != 0)
			glDeleteTextures(texTileHeightMap);
		texTileHeightMap = 0;
	}

	@Override
	public void drawScene(double cameraX, double cameraY, double cameraZ, double cameraPitch, double cameraYaw, int plane) {
		if (sceneContext == null)
			return;

		frameTimer.begin(Timer.DRAW_FRAME);
		frameTimer.begin(Timer.DRAW_SCENE);

		final Scene scene = client.getScene();
		scene.setDrawDistance(getDrawDistance());

		viewportOffsetX = client.getViewportXOffset();
		viewportOffsetY = client.getViewportYOffset();
		viewportWidth = client.getViewportWidth();
		viewportHeight = client.getViewportHeight();

		if (!enableFreezeFrame) {
			if (!redrawPreviousFrame) {
				// Only reset the target buffer offset right before drawing the scene. That way if there are frames
				// after this that don't involve a scene draw, like during LOADING/HOPPING/CONNECTION_LOST, we can
				// still redraw the previous frame's scene to emulate the client behavior of not painting over the
				// viewport buffer.
				renderBufferOffset = sceneContext.staticVertexCount;

				// Push unordered models that should always be drawn at the start of each frame.
				// Used to fix issues like the right-click menu causing underwater tiles to disappear.
				var staticUnordered = sceneContext.staticUnorderedModelBuffer.getBuffer();
				modelPassthroughBuffer
					.ensureCapacity(staticUnordered.limit())
					.put(staticUnordered);
				staticUnordered.rewind();
				numPassthroughModels += staticUnordered.limit() / 8;
			}

			cameraPosition[0] = (float) cameraX;
			cameraPosition[1] = (float) cameraY;
			cameraPosition[2] = (float) cameraZ;
			cameraOrientation[0] = (float) cameraYaw;
			cameraOrientation[1] = (float) cameraPitch;

			if (sceneContext.scene == scene) {
				cameraFocalPoint[0] = client.getOculusOrbFocalPointX();
				cameraFocalPoint[1] = client.getOculusOrbFocalPointY();
				Arrays.fill(cameraShift, 0);

				try {
					frameTimer.begin(Timer.UPDATE_ENVIRONMENT);
					environmentManager.update(sceneContext);
					frameTimer.end(Timer.UPDATE_ENVIRONMENT);

					frameTimer.begin(Timer.UPDATE_LIGHTS);
					lightManager.update(sceneContext);
					frameTimer.end(Timer.UPDATE_LIGHTS);
				} catch (Exception ex) {
					log.error("Error while updating environment or lights:", ex);
					stopPlugin();
					return;
				}
			} else {
				cameraShift[0] = cameraFocalPoint[0] - client.getOculusOrbFocalPointX();
				cameraShift[1] = cameraFocalPoint[1] - client.getOculusOrbFocalPointY();
				cameraPosition[0] += cameraShift[0];
				cameraPosition[2] += cameraShift[1];
			}

			uniformBufferCamera
				.clear()
				.putFloat(cameraOrientation[0])
				.putFloat(cameraOrientation[1])
				.putInt(client.getCenterX())
				.putInt(client.getCenterY())
				.putInt(client.getScale())
				.putFloat(cameraPosition[0])
				.putFloat(cameraPosition[1])
				.putFloat(cameraPosition[2])
				.flip();
			glBindBuffer(GL_UNIFORM_BUFFER, hUniformBufferCamera.glBufferId);
			glBufferSubData(GL_UNIFORM_BUFFER, 0, uniformBufferCamera);
		}

		if (sceneContext.scene == scene) {
			// Update lights UBO
			uniformBufferLights.clear();
			assert sceneContext.numVisibleLights <= configMaxDynamicLights;
			for (int i = 0; i < sceneContext.numVisibleLights; i++) {
				Light light = sceneContext.lights.get(i);
				uniformBufferLights.putFloat(light.pos[0] + cameraShift[0]);
				uniformBufferLights.putFloat(light.pos[1]);
				uniformBufferLights.putFloat(light.pos[2] + cameraShift[1]);
				uniformBufferLights.putFloat(light.radius * light.radius);
				uniformBufferLights.putFloat(light.color[0] * light.strength);
				uniformBufferLights.putFloat(light.color[1] * light.strength);
				uniformBufferLights.putFloat(light.color[2] * light.strength);
				uniformBufferLights.putFloat(0); // pad
			}
			uniformBufferLights.flip();
			if (configMaxDynamicLights > 0) {
				glBindBuffer(GL_UNIFORM_BUFFER, hUniformBufferLights.glBufferId);
				glBufferSubData(GL_UNIFORM_BUFFER, 0, uniformBufferLights);
				glBindBuffer(GL_UNIFORM_BUFFER, 0);
			}
		}
	}

	@Override
	public void postDrawScene() {
		if (sceneContext == null)
			return;

		frameTimer.end(Timer.DRAW_SCENE);
		frameTimer.begin(Timer.UPLOAD_GEOMETRY);

		// The client only updates animations once per client tick, so we can skip updating geometry buffers,
		// but the compute shaders should still be executed in case the camera angle has changed.
		// Technically we could skip compute shaders as well when the camera is unchanged,
		// but it would only lead to micro stuttering when rotating the camera, compared to no rotation.
		if (!redrawPreviousFrame) {
			// Geometry buffers
			sceneContext.stagingBufferVertices.flip();
			sceneContext.stagingBufferUvs.flip();
			sceneContext.stagingBufferNormals.flip();
			updateBuffer(
				hStagingBufferVertices,
				GL_ARRAY_BUFFER,
				dynamicOffsetVertices * VERTEX_SIZE,
				sceneContext.stagingBufferVertices.getBuffer(),
				GL_STREAM_DRAW, CL_MEM_READ_ONLY
			);
			updateBuffer(
				hStagingBufferUvs,
				GL_ARRAY_BUFFER,
				dynamicOffsetUvs * UV_SIZE,
				sceneContext.stagingBufferUvs.getBuffer(),
				GL_STREAM_DRAW, CL_MEM_READ_ONLY
			);
			updateBuffer(
				hStagingBufferNormals,
				GL_ARRAY_BUFFER,
				dynamicOffsetVertices * NORMAL_SIZE,
				sceneContext.stagingBufferNormals.getBuffer(),
				GL_STREAM_DRAW, CL_MEM_READ_ONLY
			);
			sceneContext.stagingBufferVertices.clear();
			sceneContext.stagingBufferUvs.clear();
			sceneContext.stagingBufferNormals.clear();

			// Model buffers
			modelPassthroughBuffer.flip();
			updateBuffer(hModelPassthroughBuffer, GL_ARRAY_BUFFER, modelPassthroughBuffer.getBuffer(), GL_STREAM_DRAW, CL_MEM_READ_ONLY);
			modelPassthroughBuffer.clear();

			for (int i = 0; i < modelSortingBuffers.length; i++) {
				var buffer = modelSortingBuffers[i];
				buffer.flip();
				updateBuffer(hModelSortingBuffers[i], GL_ARRAY_BUFFER, buffer.getBuffer(), GL_STREAM_DRAW, CL_MEM_READ_ONLY);
				buffer.clear();
			}

			// Output buffers
			updateBuffer(
				hRenderBufferVertices,
				GL_ARRAY_BUFFER,
				renderBufferOffset * 16L, // each vertex is an ivec4, which is 16 bytes
				GL_STREAM_DRAW,
				CL_MEM_WRITE_ONLY
			);
			updateBuffer(
				hRenderBufferUvs,
				GL_ARRAY_BUFFER,
				renderBufferOffset * 16L, // each vertex is an ivec4, which is 16 bytes
				GL_STREAM_DRAW,
				CL_MEM_WRITE_ONLY
			);
			updateBuffer(
				hRenderBufferNormals,
				GL_ARRAY_BUFFER,
				renderBufferOffset * 16L, // each vertex is an ivec4, which is 16 bytes
				GL_STREAM_DRAW,
				CL_MEM_WRITE_ONLY
			);
			updateSceneVao(hRenderBufferVertices, hRenderBufferUvs, hRenderBufferNormals);
		}

		frameTimer.end(Timer.UPLOAD_GEOMETRY);
		frameTimer.begin(Timer.COMPUTE);

		if (computeMode == ComputeMode.OPENCL) {
			// The docs for clEnqueueAcquireGLObjects say all pending GL operations must be completed before calling
			// clEnqueueAcquireGLObjects, and recommends calling glFinish() as the only portable way to do that.
			// However, no issues have been observed from not calling it, and so will leave disabled for now.
			// glFinish();

			openCLManager.compute(
				hUniformBufferCamera,
				numPassthroughModels, numModelsToSort,
				hModelPassthroughBuffer, hModelSortingBuffers,
				hStagingBufferVertices, hStagingBufferUvs, hStagingBufferNormals,
				hRenderBufferVertices, hRenderBufferUvs, hRenderBufferNormals
			);
		} else {
			// Compute is split into a passthrough shader for unsorted models,
			// and multiple sizes of sorting shaders to better utilize the GPU

			// Bind shared buffers
			glBindBufferBase(GL_SHADER_STORAGE_BUFFER, 1, hStagingBufferVertices.glBufferId);
			glBindBufferBase(GL_SHADER_STORAGE_BUFFER, 2, hStagingBufferUvs.glBufferId);
			glBindBufferBase(GL_SHADER_STORAGE_BUFFER, 3, hStagingBufferNormals.glBufferId);
			glBindBufferBase(GL_SHADER_STORAGE_BUFFER, 4, hRenderBufferVertices.glBufferId);
			glBindBufferBase(GL_SHADER_STORAGE_BUFFER, 5, hRenderBufferUvs.glBufferId);
			glBindBufferBase(GL_SHADER_STORAGE_BUFFER, 6, hRenderBufferNormals.glBufferId);

			// unordered
			glUseProgram(glModelPassthroughComputeProgram);
			glBindBufferBase(GL_SHADER_STORAGE_BUFFER, 0, hModelPassthroughBuffer.glBufferId);
			glDispatchCompute(numPassthroughModels, 1, 1);

			for (int i = 0; i < numModelsToSort.length; i++) {
				if (numModelsToSort[i] == 0)
					continue;

				glUseProgram(glModelSortingComputePrograms[i]);
				glBindBufferBase(GL_SHADER_STORAGE_BUFFER, 0, hModelSortingBuffers[i].glBufferId);
				glDispatchCompute(numModelsToSort[i], 1, 1);
			}
		}

		frameTimer.end(Timer.COMPUTE);

		checkGLErrors();

		if (!redrawPreviousFrame) {
			numPassthroughModels = 0;
			Arrays.fill(numModelsToSort, 0);
		}
	}

	@Override
	public void drawScenePaint(Scene scene, SceneTilePaint paint, int plane, int tileX, int tileY) {
		if (redrawPreviousFrame || paint.getBufferLen() <= 0)
			return;

		int vertexCount = paint.getBufferLen();

		++numPassthroughModels;
		modelPassthroughBuffer
			.ensureCapacity(16)
			.getBuffer()
			.put(paint.getBufferOffset())
			.put(paint.getUvBufferOffset())
			.put(vertexCount / 3)
			.put(renderBufferOffset)
			.put(0)
			.put(tileX * LOCAL_TILE_SIZE)
			.put(0)
			.put(tileY * LOCAL_TILE_SIZE);

		renderBufferOffset += vertexCount;
	}

	public void initShaderHotswapping() {
		SHADER_PATH.watch("\\.(glsl|cl)$", path -> {
			log.info("Recompiling shaders: {}", path);
			clientThread.invoke(() -> {
				try {
					waitUntilIdle();
					recompilePrograms();
				} catch (ShaderException | IOException ex) {
					log.error("Error while recompiling shaders:", ex);
					stopPlugin();
				}
			});
		});
	}

	@Override
	public void drawSceneTileModel(Scene scene, SceneTileModel model, int tileX, int tileY) {
		if (redrawPreviousFrame || model.getBufferLen() <= 0)
			return;

		final int localX = tileX * LOCAL_TILE_SIZE;
		final int localY = 0;
		final int localZ = tileY * LOCAL_TILE_SIZE;

		GpuIntBuffer b = modelPassthroughBuffer;
		b.ensureCapacity(16);
		IntBuffer buffer = b.getBuffer();

		int bufferLength = model.getBufferLen();

		// we packed a boolean into the buffer length of tiles so we can tell
		// which tiles have procedurally-generated underwater terrain.
		// unpack the boolean:
		boolean underwaterTerrain = (bufferLength & 1) == 1;
		// restore the bufferLength variable:
		bufferLength = bufferLength >> 1;

		if (underwaterTerrain) {
			// draw underwater terrain tile before surface tile

			// buffer length includes the generated underwater terrain, so it must be halved
			bufferLength /= 2;

			++numPassthroughModels;

			buffer.put(model.getBufferOffset() + bufferLength);
			buffer.put(model.getUvBufferOffset() + bufferLength);
			buffer.put(bufferLength / 3);
			buffer.put(renderBufferOffset);
			buffer.put(0);
			buffer.put(localX).put(localY).put(localZ);

			renderBufferOffset += bufferLength;
		}

		++numPassthroughModels;

		buffer.put(model.getBufferOffset());
		buffer.put(model.getUvBufferOffset());
		buffer.put(bufferLength / 3);
		buffer.put(renderBufferOffset);
		buffer.put(0);
		buffer.put(localX).put(localY).put(localZ);

		renderBufferOffset += bufferLength;
	}

	private void prepareInterfaceTexture(int canvasWidth, int canvasHeight) {
		frameTimer.begin(Timer.UPLOAD_UI);

		if (canvasWidth != lastCanvasWidth || canvasHeight != lastCanvasHeight) {
			lastCanvasWidth = canvasWidth;
			lastCanvasHeight = canvasHeight;

			glBindBuffer(GL_PIXEL_UNPACK_BUFFER, interfacePbo);
			glBufferData(GL_PIXEL_UNPACK_BUFFER, canvasWidth * canvasHeight * 4L, GL_STREAM_DRAW);
			glBindBuffer(GL_PIXEL_UNPACK_BUFFER, 0);

			glBindTexture(GL_TEXTURE_2D, interfaceTexture);
			glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, canvasWidth, canvasHeight, 0, GL_BGRA, GL_UNSIGNED_BYTE, 0);
			glBindTexture(GL_TEXTURE_2D, 0);
		}

		final BufferProvider bufferProvider = client.getBufferProvider();
		final int[] pixels = bufferProvider.getPixels();
		final int width = bufferProvider.getWidth();
		final int height = bufferProvider.getHeight();

		glBindBuffer(GL_PIXEL_UNPACK_BUFFER, interfacePbo);
		ByteBuffer mappedBuffer = glMapBuffer(GL_PIXEL_UNPACK_BUFFER, GL_WRITE_ONLY);
		if (mappedBuffer == null) {
			log.error("Unable to map interface PBO. Skipping UI...");
		} else {
			mappedBuffer.asIntBuffer().put(pixels, 0, width * height);
			glUnmapBuffer(GL_PIXEL_UNPACK_BUFFER);
			glBindTexture(GL_TEXTURE_2D, interfaceTexture);
			glTexSubImage2D(GL_TEXTURE_2D, 0, 0, 0, width, height, GL_BGRA, GL_UNSIGNED_INT_8_8_8_8_REV, 0);
		}
		glBindBuffer(GL_PIXEL_UNPACK_BUFFER, 0);
		glBindTexture(GL_TEXTURE_2D, 0);

		frameTimer.end(Timer.UPLOAD_UI);
	}

	@Override
	public void draw(int overlayColor) {
		final GameState gameState = client.getGameState();
		if (gameState == GameState.STARTING) {
			frameTimer.end(Timer.DRAW_FRAME);
			return;
		}

		if (lastFrameTimeMillis > 0) {
			deltaTime = (float) ((System.currentTimeMillis() - lastFrameTimeMillis) / 1000.);

			// Restart the plugin to avoid potential buffer corruption if the computer has likely resumed from suspension
			if (deltaTime > 300) {
				log.debug("Restarting the plugin after probable OS suspend ({} second delta)", deltaTime);
				restartPlugin();
				return;
			}

			// If system time changes between frames, clamp the delta to a more sensible value
			if (Math.abs(deltaTime) > 10)
				deltaTime = 1 / 60.f;
			elapsedTime += deltaTime;

			// The client delta doesn't need clamping
			deltaClientTime = (float) (elapsedClientTime - lastFrameClientTime);
		}
		lastFrameTimeMillis = System.currentTimeMillis();
		lastFrameClientTime = elapsedClientTime;

		final int canvasWidth = client.getCanvasWidth();
		final int canvasHeight = client.getCanvasHeight();

		try {
			prepareInterfaceTexture(canvasWidth, canvasHeight);
		} catch (Exception ex) {
			// Fixes: https://github.com/runelite/runelite/issues/12930
			// Gracefully Handle loss of opengl buffers and context
			log.warn("prepareInterfaceTexture exception", ex);
			restartPlugin();
			return;
		}

		// Upon logging in, the client will draw some frames with zero geometry before it hides the login screen
		if (renderBufferOffset > 0)
			hasLoggedIn = true;

		// Draw 3d scene
		final TextureProvider textureProvider = client.getTextureProvider();
		if (
			hasLoggedIn &&
			sceneContext != null &&
			textureProvider != null &&
			client.getGameState().getState() >= GameState.LOADING.getState()
		) {
			int renderWidthOff = viewportOffsetX;
			int renderHeightOff = viewportOffsetY;
			int renderCanvasHeight = canvasHeight;
			int renderViewportHeight = viewportHeight;
			int renderViewportWidth = viewportWidth;

			if (client.isStretchedEnabled()) {
				Dimension dim = client.getStretchedDimensions();
				renderCanvasHeight = dim.height;

				double scaleFactorY = dim.getHeight() / canvasHeight;
				double scaleFactorX = dim.getWidth() / canvasWidth;

				// Pad the viewport a little because having ints for our viewport dimensions can introduce off-by-one errors.
				final int padding = 1;

				// Ceil the sizes because even if the size is 599.1 we want to treat it as size 600 (i.e. render to the x=599 pixel).
				renderViewportHeight = (int) Math.ceil(scaleFactorY * (renderViewportHeight)) + padding * 2;
				renderViewportWidth  = (int) Math.ceil(scaleFactorX * (renderViewportWidth )) + padding * 2;

				// Floor the offsets because even if the offset is 4.9, we want to render to the x=4 pixel anyway.
				renderHeightOff      = (int) Math.floor(scaleFactorY * (renderHeightOff)) - padding;
				renderWidthOff       = (int) Math.floor(scaleFactorX * (renderWidthOff )) - padding;
			}

			int[] dpiViewport = applyDpiScaling(
				renderWidthOff,
				renderCanvasHeight - renderViewportHeight - renderHeightOff,
				renderViewportWidth,
				renderViewportHeight
			);

			// Before reading the SSBOs written to from postDrawScene() we must insert a barrier
			if (computeMode == ComputeMode.OPENCL) {
				openCLManager.finish();
			} else {
				glMemoryBarrier(GL_SHADER_STORAGE_BARRIER_BIT);
			}

			glBindVertexArray(vaoSceneHandle);

			float[] lightViewMatrix = Mat4.rotateX(PI + environmentManager.currentSunAngles[0]);
			Mat4.mul(lightViewMatrix, Mat4.rotateY(PI - environmentManager.currentSunAngles[1]));

			float[] lightProjectionMatrix = Mat4.identity();
			if (configShadowsEnabled && fboShadowMap != 0 && environmentManager.currentDirectionalStrength > 0) {
				frameTimer.begin(Timer.RENDER_SHADOWS);

				// Render to the shadow depth map
				glViewport(0, 0, shadowMapResolution, shadowMapResolution);
				glBindFramebuffer(GL_FRAMEBUFFER, fboShadowMap);
				glClearDepthf(1);
				glClear(GL_DEPTH_BUFFER_BIT);
				glDepthFunc(GL_LEQUAL);

				glUseProgram(glShadowProgram);

				final int camX = cameraFocalPoint[0];
				final int camY = cameraFocalPoint[1];

				final int drawDistanceSceneUnits = Math.min(config.shadowDistance().getValue(), getDrawDistance()) * LOCAL_TILE_SIZE / 2;
				final int east = Math.min(camX + drawDistanceSceneUnits, LOCAL_TILE_SIZE * SCENE_SIZE);
				final int west = Math.max(camX - drawDistanceSceneUnits, 0);
				final int north = Math.min(camY + drawDistanceSceneUnits, LOCAL_TILE_SIZE * SCENE_SIZE);
				final int south = Math.max(camY - drawDistanceSceneUnits, 0);
				final int width = east - west;
				final int height = north - south;
				final int near = 10000;

				final int maxDrawDistance = 90;
				final float maxScale = 0.7f;
				final float minScale = 0.4f;
				final float scaleMultiplier = 1.0f - (getDrawDistance() / (maxDrawDistance * maxScale));
				float scale = HDUtils.lerp(maxScale, minScale, scaleMultiplier);
				Mat4.mul(lightProjectionMatrix, Mat4.scale(scale, scale, scale));
				Mat4.mul(lightProjectionMatrix, Mat4.ortho(width, height, near));
				Mat4.mul(lightProjectionMatrix, lightViewMatrix);
				Mat4.mul(lightProjectionMatrix, Mat4.translate(-(width / 2f + west), 0, -(height / 2f + south)));
				glUniformMatrix4fv(uniShadowLightProjectionMatrix, false, lightProjectionMatrix);

				// bind uniforms
				if (configShadowMode == ShadowMode.DETAILED) {
					glUniform1f(uniShadowElapsedTime, (float) (elapsedTime % MAX_FLOAT_WITH_128TH_PRECISION));
					glUniform3fv(uniShadowCameraPos, cameraPosition);
				}

				glEnable(GL_CULL_FACE);
				glEnable(GL_DEPTH_TEST);

				// Draw with buffers bound to scene VAO
				glDrawArrays(GL_TRIANGLES, 0, renderBufferOffset);

				glDisable(GL_CULL_FACE);
				glDisable(GL_DEPTH_TEST);

				glBindFramebuffer(GL_FRAMEBUFFER, awtContext.getFramebuffer(false));

				glUseProgram(0);

				frameTimer.end(Timer.RENDER_SHADOWS);
			}

			glUseProgram(glSceneProgram);

			final AntiAliasingMode antiAliasingMode = config.antiAliasingMode();
			final Dimension stretchedDimensions = client.getStretchedDimensions();
			final int stretchedCanvasWidth = client.isStretchedEnabled() ? stretchedDimensions.width : canvasWidth;
			final int stretchedCanvasHeight = client.isStretchedEnabled() ? stretchedDimensions.height : canvasHeight;

			// Check if scene FBO needs to be recreated
			if (lastAntiAliasingMode != antiAliasingMode ||
				lastStretchedCanvasWidth != stretchedCanvasWidth ||
				lastStretchedCanvasHeight != stretchedCanvasHeight
			) {
				lastAntiAliasingMode = antiAliasingMode;
				lastStretchedCanvasWidth = stretchedCanvasWidth;
				lastStretchedCanvasHeight = stretchedCanvasHeight;

				destroySceneFbo();
				try {
					initSceneFbo(stretchedCanvasWidth, stretchedCanvasHeight, antiAliasingMode);
				} catch (Exception ex) {
					log.error("Error while initializing scene FBO:", ex);
					stopPlugin();
					return;
				}
			}

			float[] fogColor = ColorUtils.linearToSrgb(environmentManager.currentFogColor);
			float fogDepth = 0;
			switch (config.fogDepthMode()) {
				case USER_DEFINED:
					fogDepth = config.fogDepth();
					break;
				case DYNAMIC:
					fogDepth = environmentManager.currentFogDepth;
					break;
			}
			fogDepth *= Math.min(getDrawDistance(), 90) / 10.f;
			glUniform1i(uniUseFog, fogDepth > 0 ? 1 : 0);
			glUniform1f(uniFogDepth, fogDepth);
			glUniform3fv(uniFogColor, fogColor);

			glUniform1f(uniDrawDistance, getDrawDistance());
			glUniform1i(uniExpandedMapLoadingChunks, sceneContext.expandedMapLoadingChunks);
			glUniform1f(uniColorBlindnessIntensity, config.colorBlindnessIntensity() / 100.f);

			float[] waterColorHsv = ColorUtils.srgbToHsv(environmentManager.currentWaterColor);
			float lightBrightnessMultiplier = 0.8f;
			float midBrightnessMultiplier = 0.45f;
			float darkBrightnessMultiplier = 0.05f;
			float[] waterColorLight = ColorUtils.linearToSrgb(ColorUtils.hsvToSrgb(new float[] {
				waterColorHsv[0],
				waterColorHsv[1],
				waterColorHsv[2] * lightBrightnessMultiplier
			}));
			float[] waterColorMid = ColorUtils.linearToSrgb(ColorUtils.hsvToSrgb(new float[] {
				waterColorHsv[0],
				waterColorHsv[1],
				waterColorHsv[2] * midBrightnessMultiplier
			}));
			float[] waterColorDark = ColorUtils.linearToSrgb(ColorUtils.hsvToSrgb(new float[] {
				waterColorHsv[0],
				waterColorHsv[1],
				waterColorHsv[2] * darkBrightnessMultiplier
			}));
			glUniform3fv(uniWaterColorLight, waterColorLight);
			glUniform3fv(uniWaterColorMid, waterColorMid);
			glUniform3fv(uniWaterColorDark, waterColorDark);

			float brightness = config.brightness() / 20f;
			glUniform1f(uniAmbientStrength, environmentManager.currentAmbientStrength * brightness);
			glUniform3fv(uniAmbientColor, environmentManager.currentAmbientColor);
			glUniform1f(uniLightStrength, environmentManager.currentDirectionalStrength * brightness);
			glUniform3fv(uniLightColor, environmentManager.currentDirectionalColor);

			glUniform1f(uniUnderglowStrength, environmentManager.currentUnderglowStrength);
			glUniform3fv(uniUnderglowColor, environmentManager.currentUnderglowColor);

			glUniform1f(uniGroundFogStart, environmentManager.currentGroundFogStart);
			glUniform1f(uniGroundFogEnd, environmentManager.currentGroundFogEnd);
			glUniform1f(uniGroundFogOpacity, config.groundFog() ? environmentManager.currentGroundFogOpacity : 0);

			// Lights & lightning
			glUniform1i(uniPointLightsCount, sceneContext.numVisibleLights);
			glUniform1f(uniLightningBrightness, environmentManager.getLightningBrightness());

			glUniform1f(uniSaturation, config.saturation() / 100f);
			glUniform1f(uniContrast, config.contrast() / 100f);
			glUniform1i(uniUnderwaterEnvironment, environmentManager.isUnderwater() ? 1 : 0);
			glUniform1i(uniUnderwaterCaustics, config.underwaterCaustics() ? 1 : 0);
			glUniform3fv(uniUnderwaterCausticsColor, environmentManager.currentUnderwaterCausticsColor);
			glUniform1f(uniUnderwaterCausticsStrength, environmentManager.currentUnderwaterCausticsStrength);
			glUniform1f(uniElapsedTime, (float) (elapsedTime % MAX_FLOAT_WITH_128TH_PRECISION));
			glUniform3fv(uniCameraPos, cameraPosition);

			// Extract the 3rd column from the light view matrix (the float array is column-major)
			// This produces the view matrix's forward direction vector in world space,
			// which in our case is the negative of the light's direction
			glUniform3f(uniLightDir, lightViewMatrix[2], lightViewMatrix[6], lightViewMatrix[10]);

			// use a curve to calculate max bias value based on the density of the shadow map
			float shadowPixelsPerTile = (float) shadowMapResolution / config.shadowDistance().getValue();
			float maxBias = 26f * (float) Math.pow(0.925f, (0.4f * shadowPixelsPerTile - 10f)) + 13f;
			glUniform1f(uniShadowMaxBias, maxBias / 10000f);

			glUniform1i(uniShadowsEnabled, configShadowsEnabled ? 1 : 0);

			if (configColorFilter != ColorFilter.NONE) {
				glUniform1i(uniColorFilter, configColorFilter.ordinal());
				glUniform1i(uniColorFilterPrevious, configColorFilterPrevious.ordinal());
				long timeSinceChange = System.currentTimeMillis() - colorFilterChangedAt;
				glUniform1f(uniColorFilterFade, clamp(timeSinceChange / COLOR_FILTER_FADE_DURATION, 0, 1));
			}

			// Calculate projection matrix
			float[] projectionMatrix = Mat4.scale(client.getScale(), client.getScale(), 1);
			Mat4.mul(projectionMatrix, Mat4.projection(viewportWidth, viewportHeight, NEAR_PLANE));
			Mat4.mul(projectionMatrix, Mat4.rotateX(cameraOrientation[1]));
			Mat4.mul(projectionMatrix, Mat4.rotateY(cameraOrientation[0]));
			Mat4.mul(projectionMatrix, Mat4.translate(
				-cameraPosition[0],
				-cameraPosition[1],
				-cameraPosition[2]
			));
			glUniformMatrix4fv(uniProjectionMatrix, false, projectionMatrix);

			// Bind directional light projection matrix
			glUniformMatrix4fv(uniLightProjectionMatrix, false, lightProjectionMatrix);

			// Bind uniforms
			glUniformBlockBinding(glSceneProgram, uniBlockMaterials, UNIFORM_BLOCK_MATERIALS);
			glUniformBlockBinding(glSceneProgram, uniBlockWaterTypes, UNIFORM_BLOCK_WATER_TYPES);
			glUniformBlockBinding(glSceneProgram, uniBlockPointLights, UNIFORM_BLOCK_LIGHTS);

			glBindFramebuffer(GL_DRAW_FRAMEBUFFER, fboSceneHandle);
			glToggle(GL_MULTISAMPLE, numSamples > 1);
			glViewport(dpiViewport[0], dpiViewport[1], dpiViewport[2], dpiViewport[3]);

			// Clear scene
			frameTimer.begin(Timer.CLEAR_SCENE);
			glClearColor(fogColor[0], fogColor[1], fogColor[2], 1f);
			glClear(GL_COLOR_BUFFER_BIT);
			frameTimer.end(Timer.CLEAR_SCENE);

			frameTimer.begin(Timer.RENDER_SCENE);

			// We just allow the GL to do face culling. Note this requires the priority renderer
			// to have logic to disregard culled faces in the priority depth testing.
			glEnable(GL_CULL_FACE);
			glCullFace(GL_BACK);

			// Enable blending for alpha
			glEnable(GL_BLEND);
			glBlendFuncSeparate(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA, GL_ONE, GL_ONE);

			// Draw with buffers bound to scene VAO
			glBindVertexArray(vaoSceneHandle);

			glDrawArrays(GL_TRIANGLES, 0, renderBufferOffset);

			frameTimer.end(Timer.RENDER_SCENE);

			glDisable(GL_BLEND);
			glDisable(GL_CULL_FACE);
			glDisable(GL_MULTISAMPLE);

			glUseProgram(0);

			// Blit from the scene FBO to the default FBO
			int[] dimensions = applyDpiScaling(stretchedCanvasWidth, stretchedCanvasHeight);
			glBindFramebuffer(GL_READ_FRAMEBUFFER, fboSceneHandle);
			glBindFramebuffer(GL_DRAW_FRAMEBUFFER, awtContext.getFramebuffer(false));
			glBlitFramebuffer(
				0, 0, dimensions[0], dimensions[1],
				0, 0, dimensions[0], dimensions[1],
				GL_COLOR_BUFFER_BIT, GL_NEAREST
			);

			// Reset
			glBindFramebuffer(GL_READ_FRAMEBUFFER, awtContext.getFramebuffer(false));
		} else {
			glClearColor(0, 0, 0, 1f);
			glClear(GL_COLOR_BUFFER_BIT);
		}

		// Texture on UI
		drawUi(overlayColor, canvasHeight, canvasWidth);

		try {
			frameTimer.begin(Timer.SWAP_BUFFERS);
			awtContext.swapBuffers();
			frameTimer.end(Timer.SWAP_BUFFERS);
			drawManager.processDrawComplete(this::screenshot);
		} catch (RuntimeException ex) {
			// this is always fatal
			if (!canvas.isValid()) {
				// this might be AWT shutting down on VM shutdown, ignore it
				return;
			}

			log.error("Unable to swap buffers:", ex);
		}

		glBindFramebuffer(GL_FRAMEBUFFER, awtContext.getFramebuffer(false));

		frameTimer.end(Timer.DRAW_FRAME);
		frameTimer.endFrameAndReset();
		frameModelInfoMap.clear();
		checkGLErrors();

		// Process pending config changes after the EDT is done with any pending work, which could include further config changes
		if (!pendingConfigChanges.isEmpty())
			SwingUtilities.invokeLater(this::processPendingConfigChanges);
	}

	private void drawUi(int overlayColor, final int canvasHeight, final int canvasWidth) {
		frameTimer.begin(Timer.RENDER_UI);

		// Fix vanilla bug causing the overlay to remain on the login screen in areas like Fossil Island underwater
		if (client.getGameState().getState() < GameState.LOADING.getState())
			overlayColor = 0;

		glEnable(GL_BLEND);

		glBlendFunc(GL_ONE, GL_ONE_MINUS_SRC_ALPHA);
		glBindTexture(GL_TEXTURE_2D, interfaceTexture);

		// Use the texture bound in the first pass
		glUseProgram(glUiProgram);
		glUniform2i(uniTexSourceDimensions, canvasWidth, canvasHeight);
		glUniform1f(uniUiColorBlindnessIntensity, config.colorBlindnessIntensity() / 100f);
		glUniform4fv(uniUiAlphaOverlay, ColorUtils.srgba(overlayColor));

		if (client.isStretchedEnabled()) {
			Dimension dim = client.getStretchedDimensions();
			glDpiAwareViewport(0, 0, dim.width, dim.height);
			glUniform2i(uniTexTargetDimensions, dim.width, dim.height);
		} else {
			glDpiAwareViewport(0, 0, canvasWidth, canvasHeight);
			glUniform2i(uniTexTargetDimensions, canvasWidth, canvasHeight);
		}

		// Set the sampling function used when stretching the UI.
		// This is probably better done with sampler objects instead of texture parameters, but this is easier and likely more portable.
		// See https://www.khronos.org/opengl/wiki/Sampler_Object for details.
		// GL_NEAREST makes sampling for bicubic/xBR simpler, so it should be used whenever linear isn't
		final int function = config.uiScalingMode() == UIScalingMode.LINEAR ? GL_LINEAR : GL_NEAREST;
		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, function);
		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, function);

		// Texture on UI
		glBindVertexArray(vaoUiHandle);
		glDrawArrays(GL_TRIANGLE_FAN, 0, 4);

		frameTimer.end(Timer.RENDER_UI);

		// Reset
		glBindTexture(GL_TEXTURE_2D, 0);
		glBindVertexArray(0);
		glUseProgram(0);
		glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
		glDisable(GL_BLEND);
	}

	/**
	 * Convert the front framebuffer to an Image
	 */
	private Image screenshot()
	{
		int width  = client.getCanvasWidth();
		int height = client.getCanvasHeight();

		if (client.isStretchedEnabled())
		{
			Dimension dim = client.getStretchedDimensions();
			width  = dim.width;
			height = dim.height;
		}

		final GraphicsConfiguration graphicsConfiguration = clientUI.getGraphicsConfiguration();
		final AffineTransform t = graphicsConfiguration.getDefaultTransform();
		width = getScaledValue(t.getScaleX(), width);
		height = getScaledValue(t.getScaleY(), height);

		ByteBuffer buffer = BufferUtils.createByteBuffer(width * height * 4);

		glReadBuffer(awtContext.getBufferMode());
		glReadPixels(0, 0, width, height, GL_RGBA, GL_UNSIGNED_BYTE, buffer);

		BufferedImage image = new BufferedImage(width, height, BufferedImage.TYPE_INT_RGB);
		int[] pixels = ((DataBufferInt) image.getRaster().getDataBuffer()).getData();

		for (int y = 0; y < height; ++y)
		{
			for (int x = 0; x < width; ++x)
			{
				int r = buffer.get() & 0xff;
				int g = buffer.get() & 0xff;
				int b = buffer.get() & 0xff;
				buffer.get(); // alpha

				pixels[(height - y - 1) * width + x] = (r << 16) | (g << 8) | b;
			}
		}

		return image;
	}

	@Override
	public void animate(Texture texture, int diff) {}

	@Subscribe
	public void onGameStateChanged(GameStateChanged gameStateChanged) {
		if (gameStateChanged.getGameState() == GameState.LOGIN_SCREEN) {
			renderBufferOffset = 0;
			hasLoggedIn = false;
			environmentManager.reset();
		}
	}

	public void reuploadScene() {
		assert client.isClientThread() : "Loading a scene is unsafe while the client can modify it";
		if (client.getGameState().getState() < GameState.LOGGED_IN.getState())
			return;
		Scene scene = client.getScene();
		loadScene(scene);
		if (skipScene == scene)
			skipScene = null;
		swapScene(scene);
	}

	@Override
	public void loadScene(Scene scene) {
		if (!isActive)
			return;

		if (skipScene != scene && HDUtils.sceneIntersects(scene, getExpandedMapLoadingChunks(), Area.THE_GAUNTLET)) {
			// Some game objects in The Gauntlet are spawned in too late for the initial scene load,
			// so we skip the first scene load and trigger another scene load the next game tick
			reloadSceneNextGameTick();
			skipScene = scene;
			return;
		}

		if (useLowMemoryMode)
			return; // Force scene loading to happen on the client thread

		loadSceneInternal(scene);
	}

	private synchronized void loadSceneInternal(Scene scene) {
		if (nextSceneContext != null)
			nextSceneContext.destroy();
		nextSceneContext = null;

		try {
			// Because scene contexts are always swapped on the client thread, it is guaranteed to only be
			// in use by the client thread, meaning we can reuse all of its buffers if we are loading the
			// next scene also on the client thread
			boolean reuseBuffers = client.isClientThread();
			var context = new SceneContext(scene, getExpandedMapLoadingChunks(), reuseBuffers, sceneContext);
			// noinspection SynchronizationOnLocalVariableOrMethodParameter
			synchronized (context) {
				nextSceneContext = context;
				proceduralGenerator.generateSceneData(context);
				environmentManager.loadSceneEnvironments(context);
				sceneUploader.upload(context);
			}
		} catch (OutOfMemoryError oom) {
			log.error("Ran out of memory while loading scene (32-bit: {}, low memory mode: {}, cache size: {})",
				HDUtils.is32Bit(), useLowMemoryMode, config.modelCacheSizeMiB(), oom
			);
			displayOutOfMemoryMessage();
			stopPlugin();
		} catch (Throwable ex) {
			log.error("Error while loading scene:", ex);
			stopPlugin();
		}
	}

	@Override
	public synchronized void swapScene(Scene scene) {
		if (skipScene == scene) {
			redrawPreviousFrame = true;
			return;
		}

		// If the scene wasn't loaded by a call to loadScene, load it synchronously instead
		if (nextSceneContext == null) {
			loadSceneInternal(scene);
			if (nextSceneContext == null)
				return; // Return early if scene loading failed
		}

		if (computeMode == ComputeMode.OPENCL) {
			openCLManager.uploadTileHeights(scene);
		} else {
			initTileHeightMap(scene);
		}

		lightManager.loadSceneLights(nextSceneContext, sceneContext);
		fishingSpotReplacer.despawnRuneLiteObjects();

		if (sceneContext != null)
			sceneContext.destroy();
		sceneContext = nextSceneContext;
		nextSceneContext = null;
		assert sceneContext != null;

		// Gaps need to be filled in swapScene, since map regions aren't updated earlier
		if (config.fillGapsInTerrain())
			sceneUploader.fillGaps(sceneContext);
		sceneContext.staticUnorderedModelBuffer.flip();

		dynamicOffsetVertices = sceneContext.getVertexOffset();
		dynamicOffsetUvs = sceneContext.getUvOffset();

		sceneContext.stagingBufferVertices.flip();
		sceneContext.stagingBufferUvs.flip();
		sceneContext.stagingBufferNormals.flip();
		updateBuffer(
			hStagingBufferVertices,
			GL_ARRAY_BUFFER,
			sceneContext.stagingBufferVertices.getBuffer(),
			GL_STREAM_DRAW,
			CL_MEM_READ_ONLY
		);
		updateBuffer(
			hStagingBufferUvs,
			GL_ARRAY_BUFFER,
			sceneContext.stagingBufferUvs.getBuffer(),
			GL_STREAM_DRAW,
			CL_MEM_READ_ONLY
		);
		updateBuffer(
			hStagingBufferNormals,
			GL_ARRAY_BUFFER,
			sceneContext.stagingBufferNormals.getBuffer(),
			GL_STREAM_DRAW,
			CL_MEM_READ_ONLY
		);
		sceneContext.stagingBufferVertices.clear();
		sceneContext.stagingBufferUvs.clear();
		sceneContext.stagingBufferNormals.clear();

		if (sceneContext.intersects(Area.PLAYER_OWNED_HOUSE)) {
			if (!isInHouse) {
				// POH takes 1 game tick to enter, then 2 game ticks to load per floor
				reloadSceneIn(7);
				isInHouse = true;
			}

			isInChambersOfXeric = false;
		} else {
			// Avoid an unnecessary scene reload if the player is leaving the POH
			if (isInHouse) {
				abortSceneReload();
				isInHouse = false;
			}

			isInChambersOfXeric = sceneContext.intersects(Area.CHAMBERS_OF_XERIC);
		}
	}

	public void reloadSceneNextGameTick()
	{
		reloadSceneIn(1);
	}

	public void reloadSceneIn(int gameTicks) {
		assert gameTicks > 0 : "A value <= 0 will not reload the scene";
		if (gameTicks > gameTicksUntilSceneReload)
			gameTicksUntilSceneReload = gameTicks;
	}

	public void abortSceneReload() {
		gameTicksUntilSceneReload = 0;
	}

	private void updateCachedConfigs() {
		configShadowMode = config.shadowMode();
		configShadowsEnabled = configShadowMode != ShadowMode.OFF;
		configGroundTextures = config.groundTextures();
		configGroundBlending = config.groundBlending();
		configModelTextures = config.modelTextures();
		configTzhaarHD = config.hdTzHaarReskin();
		configProjectileLights = config.projectileLights();
		configNpcLights = config.npcLights();
		configVanillaShadowMode = config.vanillaShadowMode();
		configHideFakeShadows = configVanillaShadowMode != VanillaShadowMode.SHOW;
		configLegacyGreyColors = config.legacyGreyColors();
		configModelBatching = config.modelBatching();
		configModelCaching = config.modelCaching();
		configMaxDynamicLights = config.maxDynamicLights().getValue();
		configExpandShadowDraw = config.expandShadowDraw();
		configUseFasterModelHashing = config.fasterModelHashing();
		configUndoVanillaShading = config.shadingMode() != ShadingMode.VANILLA;
		configPreserveVanillaNormals = config.preserveVanillaNormals();
		configSeasonalTheme = config.seasonalTheme();

		var newColorFilter = config.colorFilter();
		if (newColorFilter != configColorFilter) {
			configColorFilterPrevious = configColorFilter;
			configColorFilter = newColorFilter;
			colorFilterChangedAt = System.currentTimeMillis();
		}

		if (configSeasonalTheme == SeasonalTheme.AUTOMATIC) {
			var time = ZonedDateTime.now(ZoneOffset.UTC);
			switch (time.getMonth()) {
				case SEPTEMBER:
				case OCTOBER:
				case NOVEMBER:
					configSeasonalTheme = SeasonalTheme.AUTUMN;
					break;
				case DECEMBER:
				case JANUARY:
				case FEBRUARY:
					configSeasonalTheme = SeasonalTheme.WINTER;
					break;
				default:
					configSeasonalTheme = SeasonalTheme.SUMMER;
					break;
			}
		}
	}

	@Subscribe
	public void onConfigChanged(ConfigChanged event) {
		// Exit if the plugin is off, the config is unrelated to the plugin, or if switching to a profile with the plugin turned off
		if (!isActive || !event.getGroup().equals(CONFIG_GROUP) || !pluginManager.isPluginEnabled(this))
			return;

		pendingConfigChanges.add(event.getKey());
	}

	private void processPendingConfigChanges() {
		clientThread.invoke(() -> {
			if (pendingConfigChanges.isEmpty())
				return;

			try {
				// Synchronize with scene loading
				synchronized (this) {
					updateCachedConfigs();

					log.debug("Processing {} pending config changes: {}", pendingConfigChanges.size(), pendingConfigChanges);

					boolean recompilePrograms = false;
					boolean recreateShadowMapFbo = false;
					boolean reloadTexturesAndMaterials = false;
					boolean reloadEnvironments = false;
					boolean reloadModelOverrides = false;
					boolean reloadTileOverrides = false;
					boolean reloadScene = false;
					boolean clearModelCache = false;
					boolean resizeModelCache = false;

					for (var key : pendingConfigChanges) {
						switch (key) {
							case KEY_SEASONAL_THEME:
							case KEY_GROUND_BLENDING:
							case KEY_GROUND_TEXTURES:
								reloadTileOverrides = true;
								break;
						}

						switch (key) {
							case KEY_EXPANDED_MAP_LOADING_CHUNKS:
								client.setExpandedMapLoading(getExpandedMapLoadingChunks());
								if (client.getGameState() == GameState.LOGGED_IN)
									client.setGameState(GameState.LOADING);
								break;
							case KEY_COLOR_BLINDNESS:
							case KEY_MACOS_INTEL_WORKAROUND:
							case KEY_MAX_DYNAMIC_LIGHTS:
							case KEY_NORMAL_MAPPING:
							case KEY_PARALLAX_OCCLUSION_MAPPING:
							case KEY_UI_SCALING_MODE:
							case KEY_VANILLA_COLOR_BANDING:
							case KEY_COLOR_FILTER:
								recompilePrograms = true;
								break;
							case KEY_SHADOW_MODE:
							case KEY_SHADOW_TRANSPARENCY:
								recompilePrograms = true;
								// fall-through
							case KEY_SHADOW_RESOLUTION:
								recreateShadowMapFbo = true;
								break;
							case KEY_ATMOSPHERIC_LIGHTING:
								reloadEnvironments = true;
								break;
							case KEY_SEASONAL_THEME:
								reloadEnvironments = true;
								reloadModelOverrides = true;
								// fall-through
							case KEY_ANISOTROPIC_FILTERING_LEVEL:
							case KEY_GROUND_TEXTURES:
							case KEY_MODEL_TEXTURES:
							case KEY_TEXTURE_RESOLUTION:
							case KEY_HD_INFERNAL_CAPE:
								reloadTexturesAndMaterials = true;
								// fall-through
							case KEY_GROUND_BLENDING:
							case KEY_FILL_GAPS_IN_TERRAIN:
							case KEY_HD_TZHAAR_RESKIN:
								clearModelCache = true;
								reloadScene = true;
								break;
							case KEY_VANILLA_SHADOW_MODE:
								reloadModelOverrides = true;
								reloadScene = true;
								break;
							case KEY_LEGACY_GREY_COLORS:
							case KEY_PRESERVE_VANILLA_NORMALS:
							case KEY_SHADING_MODE:
							case KEY_FLAT_SHADING:
								recompilePrograms = true;
								clearModelCache = true;
								reloadScene = true;
								break;
							case KEY_FPS_TARGET:
							case KEY_UNLOCK_FPS:
							case KEY_VSYNC_MODE:
								setupSyncMode();
								break;
							case KEY_MODEL_CACHE_SIZE:
							case KEY_MODEL_CACHING:
								resizeModelCache = true;
								break;
							case KEY_LOW_MEMORY_MODE:
							case KEY_REMOVE_VERTEX_SNAPPING:
								restartPlugin();
								// since we'll be restarting the plugin anyway, skip pending changes
								return;
							case KEY_REPLACE_FISHING_SPOTS:
								reloadModelOverrides = true;
								fishingSpotReplacer.despawnRuneLiteObjects();
								clientThread.invokeLater(fishingSpotReplacer::update);
								break;
						}
					}

					if (reloadTexturesAndMaterials || recompilePrograms)
						waitUntilIdle();

					if (reloadTexturesAndMaterials) {
						textureManager.reloadTextures();
						recompilePrograms = true;
						clearModelCache = true;
					} else if (reloadModelOverrides) {
						modelOverrideManager.reload();
						clearModelCache = true;
					}

					if (reloadTileOverrides) {
						tileOverrideManager.reload(false);
						reloadScene = true;
					}

					if (recompilePrograms)
						recompilePrograms();

					if (resizeModelCache) {
						modelPusher.shutDown();
						modelPusher.startUp();
					} else if (clearModelCache) {
						modelPusher.clearModelCache();
					}

					if (reloadScene)
						reuploadScene();

					if (recreateShadowMapFbo) {
						destroyShadowMapFbo();
						initShadowMapFbo();
					}

					if (reloadEnvironments)
						environmentManager.triggerTransition();
				}
			} catch (Throwable ex) {
				log.error("Error while changing settings:", ex);
				stopPlugin();
			} finally {
				pendingConfigChanges.clear();
			}
		});
	}

	private void setupSyncMode()
	{
		final boolean unlockFps = config.unlockFps();
		client.setUnlockedFps(unlockFps);

		// Without unlocked fps, the client manages sync on its 20ms timer
		HdPluginConfig.SyncMode syncMode = unlockFps ? config.syncMode() : HdPluginConfig.SyncMode.OFF;

		int swapInterval;
		switch (syncMode)
		{
			case ON:
				swapInterval = 1;
				break;
			case ADAPTIVE:
				swapInterval = -1;
				break;
			default:
			case OFF:
				swapInterval = 0;
				break;
		}

		int actualSwapInterval = awtContext.setSwapInterval(swapInterval);
		if (actualSwapInterval != swapInterval) {
			log.info("unsupported swap interval {}, got {}", swapInterval, actualSwapInterval);
		}

		client.setUnlockedFpsTarget(actualSwapInterval == 0 ? config.fpsTarget() : 0);
		checkGLErrors();
	}

	@Override
	public boolean tileInFrustum(
		Scene scene,
		int pitchSin,
		int pitchCos,
		int yawSin,
		int yawCos,
		int cameraX,
		int cameraY,
		int cameraZ,
		int plane,
		int tileExX,
		int tileExY
	) {
		if (sceneContext == null)
			return false;

		int[][][] tileHeights = scene.getTileHeights();
		int x = ((tileExX - SCENE_OFFSET) << Perspective.LOCAL_COORD_BITS) + 64;
		int z = ((tileExY - SCENE_OFFSET) << Perspective.LOCAL_COORD_BITS) + 64;
		int y = Math.max(
			Math.max(tileHeights[plane][tileExX][tileExY], tileHeights[plane][tileExX][tileExY + 1]),
			Math.max(tileHeights[plane][tileExX + 1][tileExY], tileHeights[plane][tileExX + 1][tileExY + 1])
		) + GROUND_MIN_Y;

		if (sceneContext.scene == scene) {
			int depthLevel = sceneContext.underwaterDepthLevels[plane][tileExX][tileExY];
			if (depthLevel > 0)
				y += ProceduralGenerator.DEPTH_LEVEL_SLOPE[depthLevel - 1] - GROUND_MIN_Y;
		}

		x -= (int) cameraPosition[0];
		y -= (int) cameraPosition[1];
		z -= (int) cameraPosition[2];

		int radius = 96; // ~ 64 * sqrt(2)

		int zoom = (configShadowsEnabled && configExpandShadowDraw) ? client.get3dZoom() / 2 : client.get3dZoom();
		int Rasterizer3D_clipMidX2 = client.getRasterizer3D_clipMidX2();
		int Rasterizer3D_clipNegativeMidX = client.getRasterizer3D_clipNegativeMidX();
		int Rasterizer3D_clipNegativeMidY = client.getRasterizer3D_clipNegativeMidY();

		int var11 = yawCos * z - yawSin * x >> 16;
		int var12 = pitchSin * y + pitchCos * var11 >> 16;
		int var13 = pitchCos * radius >> 16;
		int depth = var12 + var13;
		if (depth > NEAR_PLANE) {
			int rx = z * yawSin + yawCos * x >> 16;
			int var16 = (rx - radius) * zoom;
			int var17 = (rx + radius) * zoom;
			// left && right
			if (var16 < Rasterizer3D_clipMidX2 * depth && var17 > Rasterizer3D_clipNegativeMidX * depth) {
				int ry = pitchCos * y - var11 * pitchSin >> 16;
				int ybottom = pitchSin * radius >> 16;
				int var20 = (ry + ybottom) * zoom;
				// top
				// we don't test the bottom so we don't have to find the height of all the models on the tile
				return var20 > Rasterizer3D_clipNegativeMidY * depth;
			}
		}
		return false;
	}

	/**
	 * Check is a model is visible and should be drawn.
	 */
	private boolean isOutsideViewport(Model model, int pitchSin, int pitchCos, int yawSin, int yawCos, int x, int y, int z) {
		if (sceneContext == null)
			return true;

		final int XYZMag = model.getXYZMag();
		final int bottomY = model.getBottomY();
		final int zoom = (configShadowsEnabled && configExpandShadowDraw) ? client.get3dZoom() / 2 : client.get3dZoom();
		final int modelHeight = model.getModelHeight();

		int Rasterizer3D_clipMidX2 = client.getRasterizer3D_clipMidX2();
		int Rasterizer3D_clipNegativeMidX = client.getRasterizer3D_clipNegativeMidX();
		int Rasterizer3D_clipNegativeMidY = client.getRasterizer3D_clipNegativeMidY();
		int Rasterizer3D_clipMidY2 = client.getRasterizer3D_clipMidY2();

		int var11 = yawCos * z - yawSin * x >> 16;
		int var12 = pitchSin * y + pitchCos * var11 >> 16;
		int var13 = pitchCos * XYZMag >> 16;
		int depth = var12 + var13;
		if (depth > NEAR_PLANE) {
			int rx = z * yawSin + yawCos * x >> 16;
			int var16 = (rx - XYZMag) * zoom;
			if (var16 / depth < Rasterizer3D_clipMidX2) {
				int var17 = (rx + XYZMag) * zoom;
				if (var17 / depth > Rasterizer3D_clipNegativeMidX) {
					int ry = pitchCos * y - var11 * pitchSin >> 16;
					int yheight = pitchSin * XYZMag >> 16;
					int ybottom = (pitchCos * bottomY >> 16) + yheight;
					int var20 = (ry + ybottom) * zoom;
					if (var20 / depth > Rasterizer3D_clipNegativeMidY) {
						int ytop = (pitchCos * modelHeight >> 16) + yheight;
						int var22 = (ry - ytop) * zoom;
						return var22 / depth >= Rasterizer3D_clipMidY2;
					}
				}
			}
		}
		return true;
	}

	/**
	 * Draw a Renderable in the scene
	 *
	 * @param projection
	 * @param scene
	 * @param renderable  Can be an Actor (Player or NPC), DynamicObject, GraphicsObject, TileItem, Projectile or a raw Model.
	 * @param orientation Rotation around the up-axis, from 0 to 2048 exclusive, 2048 indicating a complete rotation.
	 * @param x           The Renderable's X offset relative to {@link Client#getCameraX()}.
	 * @param y           The Renderable's Y offset relative to {@link Client#getCameraZ()}.
	 * @param z           The Renderable's Z offset relative to {@link Client#getCameraY()}.
	 * @param hash        A unique hash of the renderable consisting of some useful information. See {@link rs117.hd.utils.ModelHash} for more details.
	 */
	@Override
	public void draw(Projection projection, Scene scene, Renderable renderable, int orientation, int x, int y, int z, long hash) {
		if (sceneContext == null)
			return;

		if (enableDetailedTimers)
			frameTimer.begin(Timer.GET_MODEL);

		Model model, offsetModel;
		try {
			// getModel may throw an exception from vanilla client code
			if (renderable instanceof Model) {
				model = (Model) renderable;
				offsetModel = model.getUnskewedModel();
				if (offsetModel == null)
					offsetModel = model;
			} else {
				offsetModel = model = renderable.getModel();
			}
			if (model == null || model.getFaceCount() == 0) {
				// skip models with zero faces
				// this does seem to happen sometimes (mostly during loading)
				// should save some CPU cycles here and there
				return;
			}
		} catch (Exception ex) {
			// Vanilla happens to handle exceptions thrown here gracefully, but we handle them explicitly anyway
			return;
		} finally {
			if (enableDetailedTimers)
				frameTimer.end(Timer.GET_MODEL);
		}

		// Apply height to renderable from the model
		if (model != renderable)
			renderable.setModelHeight(model.getModelHeight());

		model.calculateBoundsCylinder();

		if (projection instanceof IntProjection) {
			var p = (IntProjection) projection;
			if (isOutsideViewport(
				model,
				p.getPitchSin(),
				p.getPitchCos(),
				p.getYawSin(),
				p.getYawCos(),
				x - p.getCameraX(),
				y - p.getCameraY(),
				z - p.getCameraZ()
			)) {
				return;
			}
		}

		client.checkClickbox(projection, model, orientation, x, y, z, hash);

		if (redrawPreviousFrame)
			return;

		if (enableDetailedTimers)
			frameTimer.begin(Timer.DRAW_RENDERABLE);

		eightIntWrite[3] = renderBufferOffset;
		eightIntWrite[4] = orientation;
		eightIntWrite[5] = x;
		eightIntWrite[6] = y;
		eightIntWrite[7] = z;

		int plane = ModelHash.getPlane(hash);

		int faceCount;
		if (sceneContext.id == (offsetModel.getSceneId() & SceneUploader.SCENE_ID_MASK)) {
			// The model is part of the static scene buffer
			assert model == renderable;

			faceCount = Math.min(MAX_FACE_COUNT, offsetModel.getFaceCount());
			int vertexOffset = offsetModel.getBufferOffset();
			int uvOffset = offsetModel.getUvBufferOffset();
			boolean hillskew = offsetModel != model;

			eightIntWrite[0] = vertexOffset;
			eightIntWrite[1] = uvOffset;
			eightIntWrite[2] = faceCount;
			eightIntWrite[4] |= (hillskew ? 1 : 0) << 26 | plane << 24;
		} else {
			// Temporary model (animated or otherwise not a static Model already in the scene buffer)
			if (enableDetailedTimers)
				frameTimer.begin(Timer.MODEL_BATCHING);
			ModelOffsets modelOffsets = null;
			long batchHash = 0;
			if (configModelBatching || configModelCaching) {
				modelHasher.setModel(model);
				// Disable model batching for models which have been excluded from the scene buffer,
				// because we want to avoid having to fetch the model override
				if (configModelBatching && offsetModel.getSceneId() != SceneUploader.EXCLUDED_FROM_SCENE_BUFFER) {
					batchHash = modelHasher.vertexHash;
					modelOffsets = frameModelInfoMap.get(batchHash);
				}
			}
			if (enableDetailedTimers)
				frameTimer.end(Timer.MODEL_BATCHING);

			if (modelOffsets != null && modelOffsets.faceCount == model.getFaceCount()) {
				faceCount = modelOffsets.faceCount;
				eightIntWrite[0] = modelOffsets.vertexOffset;
				eightIntWrite[1] = modelOffsets.uvOffset;
				eightIntWrite[2] = modelOffsets.faceCount;
			} else {
				if (enableDetailedTimers)
					frameTimer.begin(Timer.MODEL_PUSHING);

				int uuid = ModelHash.generateUuid(client, hash, renderable);
				int[] worldPos = HDUtils.localToWorld(sceneContext.scene, x, z, plane);
				ModelOverride modelOverride = modelOverrideManager.getOverride(uuid, worldPos);
				if (modelOverride.hide)
					return;

				int vertexOffset = dynamicOffsetVertices + sceneContext.getVertexOffset();
				int uvOffset = dynamicOffsetUvs + sceneContext.getUvOffset();

				int preOrientation = 0;
				if (ModelHash.getType(hash) == ModelHash.TYPE_OBJECT) {
					int tileExX = x / LOCAL_TILE_SIZE + SCENE_OFFSET;
					int tileExY = z / LOCAL_TILE_SIZE + SCENE_OFFSET;
					if (0 <= tileExX && tileExX < EXTENDED_SCENE_SIZE && 0 <= tileExY && tileExY < EXTENDED_SCENE_SIZE) {
						Tile tile = sceneContext.scene.getExtendedTiles()[plane][tileExX][tileExY];
						int config;
						if (tile != null && (config = sceneContext.getObjectConfig(tile, hash)) != -1) {
							preOrientation = HDUtils.getBakedOrientation(config);
						} else if (plane > 0) {
							// Might be on a bridge tile
							tile = sceneContext.scene.getExtendedTiles()[plane - 1][tileExX][tileExY];
							if (tile != null && tile.getBridge() != null && (config = sceneContext.getObjectConfig(tile, hash)) != -1)
								preOrientation = HDUtils.getBakedOrientation(config);
						}
					}
				}

				modelPusher.pushModel(sceneContext, null, uuid, model, modelOverride, ObjectType.NONE, preOrientation, true);

				faceCount = sceneContext.modelPusherResults[0];
				if (sceneContext.modelPusherResults[1] == 0)
					uvOffset = -1;

				if (enableDetailedTimers)
					frameTimer.end(Timer.MODEL_PUSHING);

				eightIntWrite[0] = vertexOffset;
				eightIntWrite[1] = uvOffset;
				eightIntWrite[2] = faceCount;

				// add this temporary model to the map for batching purposes
				if (configModelBatching)
					frameModelInfoMap.put(batchHash, new ModelOffsets(faceCount, vertexOffset, uvOffset));
			}
		}

		if (enableDetailedTimers)
			frameTimer.end(Timer.DRAW_RENDERABLE);

		if (eightIntWrite[0] == -1)
			return; // Hidden model

		bufferForTriangles(faceCount)
			.ensureCapacity(8)
			.put(eightIntWrite);
		renderBufferOffset += faceCount * 3;
	}

	/**
	 * returns the correct buffer based on triangle count and updates model count
	 */
	private GpuIntBuffer bufferForTriangles(int triangles) {
		for (int i = 0; i < numSortingBins; i++) {
			if (modelSortingBinFaceCounts[i] >= triangles) {
				++numModelsToSort[i];
				return modelSortingBuffers[i];
			}
		}

		throw new IllegalStateException(
			"Ran into a model with more triangles than the plugin supports (" +
			triangles + " > " + MAX_FACE_COUNT + ")");
	}

	private int getScaledValue(final double scale, final int value) {
		return (int) (value * scale + .5);
	}

	// Assumes alternating x/y
	private int[] applyDpiScaling(int... coordinates) {
		final GraphicsConfiguration graphicsConfiguration = clientUI.getGraphicsConfiguration();
		if (graphicsConfiguration == null)
			return coordinates;

		final AffineTransform t = graphicsConfiguration.getDefaultTransform();
		for (int i = 0; i < coordinates.length; i++)
			coordinates[i] = getScaledValue(i % 2 == 0 ? t.getScaleX() : t.getScaleY(), coordinates[i]);
		return coordinates;
	}

	private void glDpiAwareViewport(int... xywh) {
		applyDpiScaling(xywh);
		glViewport(xywh[0], xywh[1], xywh[2], xywh[3]);
	}

	public int getDrawDistance() {
		return clamp(config.drawDistance(), 0, MAX_DISTANCE);
	}

	private int getExpandedMapLoadingChunks() {
		if (useLowMemoryMode)
			return 0;
		return config.expandedMapLoadingChunks();
	}

	private void logBufferResize(GLBuffer glBuffer, long newSize) {
		if (!log.isTraceEnabled())
			return;

		log.trace("Buffer resize: {} {}", glBuffer, String.format("%.2f MB -> %.2f MB", glBuffer.size / 1e6, newSize / 1e6));
	}

	private void updateBuffer(@Nonnull GLBuffer glBuffer, int target, @Nonnull ByteBuffer data, int usage, long clFlags) {
		glBindBuffer(target, glBuffer.glBufferId);
		long size = data.remaining();
		if (size > glBuffer.size) {
			size = HDUtils.ceilPow2(size);
			logBufferResize(glBuffer, size);

			glBuffer.size = size;
			glBufferData(target, size, usage);

			if (computeMode == ComputeMode.OPENCL)
				openCLManager.recreateCLBuffer(glBuffer, clFlags);
		}
		glBufferSubData(target, 0, data);
	}

	private void updateBuffer(@Nonnull GLBuffer glBuffer, int target, @Nonnull IntBuffer data, int usage, long clFlags)
	{
		updateBuffer(glBuffer, target, 0, data, usage, clFlags);
	}

	private void updateBuffer(@Nonnull GLBuffer glBuffer, int target, int offset, @Nonnull IntBuffer data, int usage, long clFlags)
	{
		long size = 4L * (offset + data.remaining());
		if (size > glBuffer.size) {
			size = HDUtils.ceilPow2(size);
			logBufferResize(glBuffer, size);

			if (offset > 0) {
				int oldBuffer = glBuffer.glBufferId;
				glBuffer.glBufferId = glGenBuffers();
				glBindBuffer(target, glBuffer.glBufferId);
				glBufferData(target, size, usage);

				glBindBuffer(GL_COPY_READ_BUFFER, oldBuffer);
				glCopyBufferSubData(GL_COPY_READ_BUFFER, target, 0, 0, offset * 4L);
				glDeleteBuffers(oldBuffer);
			} else {
				glBindBuffer(target, glBuffer.glBufferId);
				glBufferData(target, size, usage);
			}

			glBuffer.size = size;

			if (computeMode == ComputeMode.OPENCL)
				openCLManager.recreateCLBuffer(glBuffer, clFlags);
		}
		else
		{
			glBindBuffer(target, glBuffer.glBufferId);
		}
		glBufferSubData(target, offset * 4L, data);
	}

	private void updateBuffer(@Nonnull GLBuffer glBuffer, int target, @Nonnull FloatBuffer data, int usage, long clFlags)
	{
		updateBuffer(glBuffer, target, 0, data, usage, clFlags);
	}

	private void updateBuffer(@Nonnull GLBuffer glBuffer, int target, int offset, @Nonnull FloatBuffer data, int usage, long clFlags)
	{
		long size = 4L * (offset + data.remaining());
		if (size > glBuffer.size) {
			size = HDUtils.ceilPow2(size);
			logBufferResize(glBuffer, size);

			if (offset > 0) {
				int oldBuffer = glBuffer.glBufferId;
				glBuffer.glBufferId = glGenBuffers();
				glBindBuffer(target, glBuffer.glBufferId);
				glBufferData(target, size, usage);

				glBindBuffer(GL_COPY_READ_BUFFER, oldBuffer);
				glCopyBufferSubData(GL_COPY_READ_BUFFER, target, 0, 0, offset * 4L);
				glDeleteBuffers(oldBuffer);
			} else {
				glBindBuffer(target, glBuffer.glBufferId);
				glBufferData(target, size, usage);
			}

			glBuffer.size = size;

			if (computeMode == ComputeMode.OPENCL)
				openCLManager.recreateCLBuffer(glBuffer, clFlags);
		} else {
			glBindBuffer(target, glBuffer.glBufferId);
		}
		glBufferSubData(target, offset * 4L, data);
	}

	private void updateBuffer(@Nonnull GLBuffer glBuffer, int target, long size, int usage, long clFlags) {
		if (size > glBuffer.size) {
			size = HDUtils.ceilPow2(size);
			logBufferResize(glBuffer, size);

			glBuffer.size = size;
			glBindBuffer(target, glBuffer.glBufferId);
			glBufferData(target, size, usage);

			if (computeMode == ComputeMode.OPENCL)
				openCLManager.recreateCLBuffer(glBuffer, clFlags);
		}
	}

	@Subscribe(priority = -1) // Run after the low detail plugin
	public void onBeforeRender(BeforeRender beforeRender) {
		if (client.getScene() == null)
			return;
		// The game runs significantly slower with lower planes in Chambers of Xeric
		client.getScene().setMinLevel(isInChambersOfXeric ? client.getPlane() : client.getScene().getMinLevel());
	}

	@Subscribe
	public void onClientTick(ClientTick clientTick) {
		elapsedClientTime += 1 / 50f;

		if (!enableFreezeFrame && skipScene != client.getScene())
			redrawPreviousFrame = false;
	}

	@Subscribe
	public void onGameTick(GameTick gameTick) {
		if (!isActive)
			return;

		if (gameTicksUntilSceneReload > 0) {
			if (gameTicksUntilSceneReload == 1)
				reuploadScene();
			--gameTicksUntilSceneReload;
		}

		fishingSpotReplacer.update();

		// reload the scene if the player is in a house and their plane changed
		// this greatly improves the performance as it keeps the scene buffer up to date
		if (isInHouse) {
			int plane = client.getPlane();
			if (previousPlane != plane) {
				reloadSceneNextGameTick();
				previousPlane = plane;
			}
		}
	}

	private void waitUntilIdle() {
		if (computeMode == ComputeMode.OPENCL)
			openCLManager.finish();
		glFinish();
	}

	private void glToggle(int target, boolean enable) {
		if (enable) {
			glEnable(target);
		} else {
			glDisable(target);
		}
	}

	@SuppressWarnings("StatementWithEmptyBody")
	public void clearGLErrors() {
		// @formatter:off
		while (glGetError() != GL_NO_ERROR);
		// @formatter:on
	}

	public void checkGLErrors() {
		if (!log.isDebugEnabled())
			return;

		while (true) {
			int err = glGetError();
			if (err == GL_NO_ERROR)
				return;

			String errStr;
			switch (err) {
				case GL_INVALID_ENUM:
					errStr = "INVALID_ENUM";
					break;
				case GL_INVALID_VALUE:
					errStr = "INVALID_VALUE";
					break;
				case GL_INVALID_OPERATION:
					errStr = "INVALID_OPERATION";
					break;
				case GL_INVALID_FRAMEBUFFER_OPERATION:
					errStr = "INVALID_FRAMEBUFFER_OPERATION";
					break;
				default:
					errStr = String.valueOf(err);
					break;
			}

			log.debug("glGetError:", new Exception(errStr));
		}
	}

	private void displayUpdateMessage() {
		int messageId = 1;
		if (config.getPluginUpdateMessage() >= messageId)
			return; // Don't show the same message multiple times

//		PopupUtils.displayPopupMessage(client, "117HD Update",
//			"<br><br>" +
//			"If you experience any issues, please report them in the <a href=\"" + DISCORD_URL +"\">117HD Discord</a>.",
//			new String[] { "Remind me later", "Got it!" },
//			i -> {
//				if (i == 1) {
//					config.setPluginUpdateMessage(messageId);
//				}
//			}
//		);
	}

	private void displayUnsupportedGpuMessage(boolean isGenericGpu, String glRenderer) {
		String hint32Bit = "";
		if (HDUtils.is32Bit()) {
			hint32Bit =
				"&nbsp;• Install the 64-bit version of RuneLite from " +
				"<a href=\"" + HdPlugin.RUNELITE_URL + "\">the official website</a>. You are currently using 32-bit.<br>";
		}

		String driverLinks =
			"<br>" +
			"Links to drivers for each graphics card vendor:<br>" +
			"&nbsp;• <a href=\"" + HdPlugin.AMD_DRIVER_URL + "\">AMD drivers</a><br>" +
			"&nbsp;• <a href=\"" + HdPlugin.INTEL_DRIVER_URL + "\">Intel drivers</a><br>" +
			"&nbsp;• <a href=\"" + HdPlugin.NVIDIA_DRIVER_URL + "\">Nvidia drivers</a><br>";

		String errorMessage =
			(
				isGenericGpu ? (
					"Your graphics driver appears to be broken.<br>"
					+ "<br>"
					+ "Some things to try:<br>"
					+ "&nbsp;• Reinstall the drivers for <b>both</b> your processor's integrated graphics <b>and</b> your graphics card.<br>"
				) :
					(
						"Your GPU is currently not supported by 117 HD.<br><br>GPU name: " + glRenderer + "<br>"
						+ "<br>"
						+ "Your computer might not be letting RuneLite access your most powerful GPU.<br>"
						+ "To find out if your system is supported, try the following steps:<br>"
						+ "&nbsp;• Reinstall the drivers for your graphics card. You can find a link below.<br>"
					)
			)
			+ hint32Bit
			+ "&nbsp;• Tell your machine to use your high performance GPU for RuneLite.<br>"
			+ "&nbsp;• If you are on a desktop PC, make sure your monitor is plugged into your graphics card instead of<br>"
			+ "&nbsp;&nbsp;&nbsp;&nbsp;your motherboard. The graphics card's display outputs are usually lower down behind the computer.<br>"
			+ driverLinks
			+ "<br>"
			+ "If the issue persists even after <b>all of the above</b>, please join our "
			+ "<a href=\"" + HdPlugin.DISCORD_URL + "\">Discord server</a>, and click the <br>"
			+ "\"Open logs folder\" button below, find the file named \"client\" or \"client.log\", then drag and drop<br>"
			+ "that file into one of our support channels.";

		PopupUtils.displayPopupMessage(client, "117 HD Error", errorMessage,
			new String[] { "Open logs folder", "Ok, let me try that..." },
			i -> {
				if (i == 0) {
					LinkBrowser.open(RuneLite.LOGS_DIR.toString());
					return false;
				}
				return true;
			}
		);
	}

	private void displayOutOfMemoryMessage() {
		String errorMessage;
		if (HDUtils.is32Bit()) {
			String lowMemoryModeHint = useLowMemoryMode ? "" : (
				"If you are unable to install 64-bit RuneLite, you can instead turn on <b>Low Memory Mode</b> in the<br>" +
				"Miscellaneous section of 117 HD settings.<br>"
			);
			errorMessage =
				"The plugin ran out of memory because you are using the 32-bit version of RuneLite.<br>"
				+ "We would recommend installing the 64-bit version from "
				+ "<a href=\"" + HdPlugin.RUNELITE_URL + "\">RuneLite's website</a> if possible.<br>"
				+ "<br>"
				+ lowMemoryModeHint
				+ "<br>"
				+ "If you need further assistance, please join our "
				+ "<a href=\"" + HdPlugin.DISCORD_URL + "\">Discord</a> server, and click the \"Open logs folder\"<br>"
				+ "button below, find the file named \"client\" or \"client.log\", then drag and drop that file into one of<br>"
				+ "our support channels.";
		} else {
			errorMessage =
				"The plugin ran out of memory. "
				+ "Try " + (useLowMemoryMode ? "" : "reducing your model cache size from " + config.modelCacheSizeMiB() + " or ") + "closing other programs.<br>"
				+ "<br>"
				+ "If the issue persists, please join our "
				+ "<a href=\"" + HdPlugin.DISCORD_URL + "\">Discord</a> server, and click the \"Open logs folder\" button<br>"
				+ "below, find the file named \"client\" or \"client.log\", then drag and drop that file into one of our<br>"
				+ "support channels.";
		}

		PopupUtils.displayPopupMessage(client, "117 HD Error", errorMessage,
			new String[] { "Open logs folder", "Ok, let me try that..." },
			i -> {
				if (i == 0) {
					LinkBrowser.open(RuneLite.LOGS_DIR.toString());
					return false;
				}
				return true;
			}
		);
	}
}

package rs117.hd.model;

import javax.inject.Inject;
import javax.inject.Singleton;
import lombok.NonNull;
import net.runelite.api.*;
import rs117.hd.HdPlugin;
import rs117.hd.data.materials.UvType;
import rs117.hd.scene.model_overrides.ModelOverride;

@Singleton
public class ModelHasher {
	@Inject
	private HdPlugin plugin;

	public long vertexHash;

	private Model model;
	private int faceCount;
	private long faceColorsOneHash;
	private long faceColorsTwoHash;
	private long faceColorsThreeHash;
	private long faceTransparenciesHash;
	private long faceTexturesHash;
	private long xVerticesHash;
	private long yVerticesHash;
	private long zVerticesHash;
	private long faceIndicesOneHash;
	private long faceIndicesTwoHash;
	private long faceIndicesThreeHash;
	private long textureTrianglesHash;

	public void setModel(Model model) {
		this.model = model;
		faceCount = model.getFaceCount();
		if (plugin.configUseFasterModelHashing) {
			faceColorsOneHash = fastHash(model.getFaceColors1());
			faceColorsTwoHash = 0;
			faceColorsThreeHash = 0;
			faceTransparenciesHash = fastByteHash(model.getFaceTransparencies());
			faceTexturesHash = fastShortHash(model.getFaceTextures());
			xVerticesHash = fastFloatHash(model.getVerticesX(), model.getVerticesCount());
			yVerticesHash = fastFloatHash(model.getVerticesY(), model.getVerticesCount());
			zVerticesHash = fastFloatHash(model.getVerticesZ(), model.getVerticesCount());
			faceIndicesOneHash = fastHash(model.getFaceIndices1());
			faceIndicesTwoHash = 0;
			faceIndicesThreeHash = 0;
			textureTrianglesHash = 0;
			final byte[] textureFaces = model.getTextureFaces();
			if (textureFaces != null) {
				boolean hasVanillaTexturedFaces = false;
				for (int textureId : textureFaces) {
					if (textureId != -1) {
						hasVanillaTexturedFaces = true;
						break;
					}
				}
				if (hasVanillaTexturedFaces) {
					final int[] texIndices1 = model.getTexIndices1();
					final int[] texIndices2 = model.getTexIndices2();
					final int[] texIndices3 = model.getTexIndices3();
					final float[] vertexX = model.getVerticesX();
					final float[] vertexY = model.getVerticesY();
					final float[] vertexZ = model.getVerticesZ();
					long h = 0;
					for (int i = 0; i < model.getFaceCount(); i++) {
						int texFace = textureFaces[i];
						if (texFace == -1)
							continue;
						texFace &= 0xff;
						final int texA = texIndices1[texFace];
						final int texB = texIndices2[texFace];
						final int texC = texIndices3[texFace];
						h = h * 31L + Float.floatToIntBits(vertexX[texA]);
						h = h * 31L + Float.floatToIntBits(vertexY[texA]);
						h = h * 31L + Float.floatToIntBits(vertexZ[texA]);
						h = h * 31L + Float.floatToIntBits(vertexX[texB]);
						h = h * 31L + Float.floatToIntBits(vertexY[texB]);
						h = h * 31L + Float.floatToIntBits(vertexZ[texB]);
						h = h * 31L + Float.floatToIntBits(vertexX[texC]);
						h = h * 31L + Float.floatToIntBits(vertexY[texC]);
						h = h * 31L + Float.floatToIntBits(vertexZ[texC]);
					}
					textureTrianglesHash = h;
				}
			}
		} else {
			faceColorsOneHash = fastHash(model.getFaceColors1());
			faceColorsTwoHash = fastHash(model.getFaceColors2());
			faceColorsThreeHash = fastHash(model.getFaceColors3());
			faceTransparenciesHash = fastByteHash(model.getFaceTransparencies());
			faceTexturesHash = fastShortHash(model.getFaceTextures());
			xVerticesHash = fastFloatHash(model.getVerticesX(), model.getVerticesCount());
			yVerticesHash = fastFloatHash(model.getVerticesY(), model.getVerticesCount());
			zVerticesHash = fastFloatHash(model.getVerticesZ(), model.getVerticesCount());
			faceIndicesOneHash = fastHash(model.getFaceIndices1());
			faceIndicesTwoHash = fastHash(model.getFaceIndices2());
			faceIndicesThreeHash = fastHash(model.getFaceIndices3());
			textureTrianglesHash = 0;
			final byte[] textureFaces = model.getTextureFaces();
			if (textureFaces != null) {
				boolean hasVanillaTexturedFaces = false;
				for (int textureId : textureFaces) {
					if (textureId != -1) {
						hasVanillaTexturedFaces = true;
						break;
					}
				}
				if (hasVanillaTexturedFaces) {
					final int[] texIndices1 = model.getTexIndices1();
					final int[] texIndices2 = model.getTexIndices2();
					final int[] texIndices3 = model.getTexIndices3();
					final float[] vertexX = model.getVerticesX();
					final float[] vertexY = model.getVerticesY();
					final float[] vertexZ = model.getVerticesZ();
					long h = 0;
					for (int i = 0; i < model.getFaceCount(); i++) {
						int texFace = textureFaces[i];
						if (texFace == -1)
							continue;
						texFace &= 0xff;
						final int texA = texIndices1[texFace];
						final int texB = texIndices2[texFace];
						final int texC = texIndices3[texFace];
						h = h * 31L + Float.floatToIntBits(vertexX[texA]);
						h = h * 31L + Float.floatToIntBits(vertexY[texA]);
						h = h * 31L + Float.floatToIntBits(vertexZ[texA]);
						h = h * 31L + Float.floatToIntBits(vertexX[texB]);
						h = h * 31L + Float.floatToIntBits(vertexY[texB]);
						h = h * 31L + Float.floatToIntBits(vertexZ[texB]);
						h = h * 31L + Float.floatToIntBits(vertexX[texC]);
						h = h * 31L + Float.floatToIntBits(vertexY[texC]);
						h = h * 31L + Float.floatToIntBits(vertexZ[texC]);
					}
					textureTrianglesHash = h;
				}
			}
		}

		vertexHash = calculateVertexCacheHash();
	}

	public long calculateVertexCacheHash() {
		long h = faceCount;
		h = h * 31L + faceColorsOneHash;
		h = h * 31L + faceColorsTwoHash;
		h = h * 31L + faceColorsThreeHash;
		h = h * 31L + faceTransparenciesHash;
		h = h * 31L + faceTexturesHash;
		h = h * 31L + xVerticesHash;
		h = h * 31L + yVerticesHash;
		h = h * 31L + zVerticesHash;
		h = h * 31L + faceIndicesOneHash;
		h = h * 31L + faceIndicesTwoHash;
		h = h * 31L + faceIndicesThreeHash;
		h = h * 31L + textureTrianglesHash;
		h = h * 31L + model.getOverrideAmount();
		h = h * 31L + model.getOverrideHue();
		h = h * 31L + model.getOverrideSaturation();
		h = h * 31L + model.getOverrideLuminance();
		return h;
	}

	public long calculateNormalCacheHash() {
		long h = faceCount;
		h = h * 31L + faceIndicesOneHash;
		h = h * 31L + faceIndicesTwoHash;
		h = h * 31L + faceIndicesThreeHash;
		h = h * 31L + fastHash(model.getVertexNormalsX());
		h = h * 31L + fastHash(model.getVertexNormalsY());
		h = h * 31L + fastHash(model.getVertexNormalsZ());
		return h;
	}

	public long calculateUvCacheHash(int orientation, @NonNull ModelOverride modelOverride) {
		long h = faceCount;
		h = h * 31L + (modelOverride.uvType == UvType.VANILLA || modelOverride.retainVanillaUvs ? textureTrianglesHash : 0);
		h = h * 31L + (modelOverride.uvType.orientationDependent ? orientation : 0);
		h = h * 31L + (modelOverride.uvType == UvType.BOX ? vertexHash : 0);
		h = h * 31L + modelOverride.hashCode();
		h = h * 31L + faceTexturesHash;
		return h;
	}

	public static long fastHash(int[] a) {
		if (a == null)
			return 0;

		int i = 0;
		long r = 1;
		int length = a.length;

		for (; i + 5 < length; i += 6)
			r = 31L * 31L * 31L * 31L * 31L * 31L * r +
				31L * 31L * 31L * 31L * 31L * a[i] +
				31L * 31L * 31L * 31L * a[i + 1] +
				31L * 31L * 31L * a[i + 2] +
				31L * 31L * a[i + 3] +
				31L * a[i + 4] +
				a[i + 5];

		for (; i < length; i++)
			r = 31L * r + a[i];

		return r;
	}

	public static long fastHash(int[] a, int length) {
		if (a == null)
			return 0;

		int i = 0;
		long r = 1;

		for (; i + 5 < length; i += 6)
			r = 31L * 31L * 31L * 31L * 31L * 31L * r +
				31L * 31L * 31L * 31L * 31L * a[i] +
				31L * 31L * 31L * 31L * a[i + 1] +
				31L * 31L * 31L * a[i + 2] +
				31L * 31L * a[i + 3] +
				31L * a[i + 4] +
				a[i + 5];

		for (; i < length; i++)
			r = 31L * r + a[i];

		return r;
	}

	public static int fastIntHash(int[] a, int actualLength) {
		if (a == null)
			return 0;

		int i = 0;
		int r = 1;
		int length = a.length;
		if (actualLength != -1)
			length = actualLength;

		for (; i + 5 < length; i += 6)
			r = 31 * 31 * 31 * 31 * 31 * 31 * r +
				31 * 31 * 31 * 31 * 31 * a[i] +
				31 * 31 * 31 * 31 * a[i + 1] +
				31 * 31 * 31 * a[i + 2] +
				31 * 31 * a[i + 3] +
				31 * a[i + 4] +
				a[i + 5];

		for (; i < length; i++)
			r = 31 * r + a[i];

		return r;
	}

	public static int fastByteHash(byte[] a) {
		if (a == null)
			return 0;

		int i = 0;
		int r = 1;

		for (; i + 5 < a.length; i += 6)
			r = 31 * 31 * 31 * 31 * 31 * 31 * r
				+ 31 * 31 * 31 * 31 * 31 * a[i]
				+ 31 * 31 * 31 * 31 * a[i + 1]
				+ 31 * 31 * 31 * a[i + 2]
				+ 31 * 31 * a[i + 3]
				+ 31 * a[i + 4]
				+ a[i + 5];

		for (; i < a.length; i++) {
			r = 31 * r + a[i];
		}

		return r;
	}

    public static int fastShortHash(short[] a) {
		if (a == null)
			return 0;

		int i = 0;
		int r = 1;

		for (; i + 5 < a.length; i += 6)
			r = 31 * 31 * 31 * 31 * 31 * 31 * r +
				31 * 31 * 31 * 31 * 31 * a[i] +
				31 * 31 * 31 * 31 * a[i + 1] +
				31 * 31 * 31 * a[i + 2] +
				31 * 31 * a[i + 3] +
				31 * a[i + 4] +
				a[i + 5];

		for (; i < a.length; i++)
			r = 31 * r + a[i];

		return r;
	}

	public static int fastFloatHash(float[] a, int length) {
		if (a == null)
			return 0;

		int i = 0;
		int r = 1;

		for (; i + 5 < length; i += 6)
			r = 31 * 31 * 31 * 31 * 31 * 31 * r +
				31 * 31 * 31 * 31 * 31 * (int) (a[i] * 100) +
				31 * 31 * 31 * 31 * (int) (a[i + 1] * 100) +
				31 * 31 * 31 * (int) (a[i + 2] * 100) +
				31 * 31 * (int) (a[i + 3] * 100) +
				31 * (int) (a[i + 4] * 100) +
				(int) (a[i + 5] * 100);

		for (; i < length; i++)
			r = 31 * r + (int) (a[i] * 100);

		return r;
	}

	public static int fastFloatHash(float[] a) {
		if (a == null)
			return 0;

		int i = 0;
		int r = 1;

		for (; i + 5 < a.length; i += 6)
			r = 31 * 31 * 31 * 31 * 31 * 31 * r +
				31 * 31 * 31 * 31 * 31 * (int) (a[i] * 100) +
				31 * 31 * 31 * 31 * (int) (a[i + 1] * 100) +
				31 * 31 * 31 * (int) (a[i + 2] * 100) +
				31 * 31 * (int) (a[i + 3] * 100) +
				31 * (int) (a[i + 4] * 100) +
				(int) (a[i + 5] * 100);

		for (; i < a.length; i++)
			r = 31 * r + (int) (a[i] * 100);

		return r;
	}
}

package rs117.hd.model;

import java.nio.FloatBuffer;
import java.nio.IntBuffer;
import java.util.Arrays;
import javax.annotation.Nonnull;
import javax.annotation.Nullable;
import javax.inject.Inject;
import javax.inject.Singleton;
import lombok.NonNull;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.*;
import net.runelite.api.kit.*;
import net.runelite.client.RuneLite;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.util.LinkBrowser;
import rs117.hd.HdPlugin;
import rs117.hd.HdPluginConfig;
import rs117.hd.data.WaterType;
import rs117.hd.data.materials.Material;
import rs117.hd.data.materials.UvType;
import rs117.hd.overlays.FrameTimer;
import rs117.hd.overlays.Timer;
import rs117.hd.scene.ProceduralGenerator;
import rs117.hd.scene.SceneContext;
import rs117.hd.scene.SceneUploader;
import rs117.hd.scene.TextureManager;
import rs117.hd.scene.TileOverrideManager;
import rs117.hd.scene.model_overrides.InheritTileColorType;
import rs117.hd.scene.model_overrides.ModelOverride;
import rs117.hd.scene.model_overrides.ObjectType;
import rs117.hd.scene.model_overrides.TzHaarRecolorType;
import rs117.hd.utils.HDUtils;
import rs117.hd.utils.ModelHash;
import rs117.hd.utils.PopupUtils;

import static rs117.hd.HdPlugin.MAX_FACE_COUNT;
import static rs117.hd.scene.tile_overrides.TileOverride.OVERLAY_FLAG;

/**
 * Pushes models
 */
@Singleton
@Slf4j
public class ModelPusher {
	@Inject
	private Client client;

	@Inject
	private ClientThread clientThread;

	@Inject
	private HdPlugin plugin;

	@Inject
	private HdPluginConfig config;

	@Inject
	private TextureManager textureManager;

	@Inject
	private TileOverrideManager tileOverrideManager;

	@Inject
	private ModelHasher modelHasher;

	@Inject
	private FrameTimer frameTimer;

	public static final int DATUM_PER_FACE = 12;
	public static final int MAX_MATERIAL_COUNT = (1 << 12) - 1;

	private static final int[] ZEROED_INTS = new int[12];

	private ModelCache modelCache;

	public void startUp() {
		if (Material.values().length - 1 >= MAX_MATERIAL_COUNT) {
			throw new IllegalStateException(
				"Too many materials (" + Material.values().length + ") to fit into packed material data.");
		}

		if (config.modelCaching() && !plugin.useLowMemoryMode) {
			final int size = config.modelCacheSizeMiB();
			try {
				modelCache = new ModelCache(size, () -> {
					shutDown();
					plugin.stopPlugin();
				});
			} catch (Throwable err) {
				log.error("Error while initializing model cache. Stopping the plugin...", err);

				if (err instanceof OutOfMemoryError) {
					PopupUtils.displayPopupMessage(client, "117 HD Error",
						"117 HD ran out of memory while trying to allocate the model cache.<br><br>" +
						(
							HDUtils.is32Bit() ?
								(
									"You are currently using 32-bit RuneLite, which heavily restricts<br>" +
									"the amount of memory RuneLite is allowed to use.<br>" +
									"Please install the 64-bit launcher from " +
									"<a href=\"" + HdPlugin.RUNELITE_URL + "\">RuneLite's website</a> and try again.<br>"
								) : (
								(
									size <= 512 ? "" :
										"Your cache size of " + size + " MiB is " + (
											size >= 4000 ?
												"very large. We would recommend reducing it.<br>" :
												"bigger than the default size. Try reducing it.<br>"
										)
								) +
								"Normally, a cache size above 512 MiB is unnecessary, and the game should<br>" +
								"run acceptably even at 128 MiB. If you have to reduce the size by a lot,<br>" +
								"you may be better off disabling model caching entirely.<br>"
							)
						)
						+ "<br>"
						+ "You can also try closing some other programs on your PC to free up memory.<br>"
						+ "<br>"
						+ "If you need further assistance, please join our "
						+ "<a href=\"" + HdPlugin.DISCORD_URL + "\">Discord</a> server, and click the <br>"
						+ "\"Open logs folder\" button below, find the file named \"client\" or \"client.log\",<br>"
						+ "then drag and drop that file into one of our support channels.",
						new String[] { "Open logs folder", "Ok, let me try that..." },
						i -> {
							if (i == 0) {
								LinkBrowser.open(RuneLite.LOGS_DIR.toString());
								return false;
							}
							return true;
						}
					);
				}

				// Allow the model pusher to be used until the plugin has cleanly shut down
				clientThread.invoke(plugin::stopPlugin);
			}
		}
	}

	public void shutDown() {
		if (modelCache != null) {
			modelCache.destroy();
			modelCache = null;
		}
	}

	public void clearModelCache() {
		if (modelCache != null) {
			modelCache.clear();
		}
	}

	/**
	 * Pushes model data to staging buffers in the provided {@link SceneContext}, and writes the pushed number of
	 * vertices and UVs to {@link SceneContext#modelPusherResults}.
	 *
	 * @param sceneContext   object for the scene to push model data for
	 * @param tile           that the model is associated with, if any
	 * @param uuid           of the model
	 * @param model          to push data from
	 * @param modelOverride  the active model override
	 * @param objectType     of the specified model. Used for TzHaar recolor
	 * @param preOrientation which the vertices have already been rotated by
	 * @param shouldCache    whether the model should be cached for future reuse, if enabled
	 */
	public void pushModel(
		SceneContext sceneContext,
		@Nullable Tile tile,
		int uuid,
		Model model,
		ModelOverride modelOverride,
		ObjectType objectType,
		int preOrientation,
		boolean shouldCache
	) {
		if (modelCache == null)
			shouldCache = false;

		final int faceCount = Math.min(model.getFaceCount(), MAX_FACE_COUNT);
		final int bufferSize = faceCount * DATUM_PER_FACE;
		int texturedFaceCount = 0;

		final short[] faceTextures = model.getFaceTextures();
		final byte[] textureFaces = model.getTextureFaces();
		boolean isVanillaTextured = faceTextures != null;
		boolean isVanillaUVMapped =
			isVanillaTextured && // Vanilla UV mapped models don't always have sensible UVs for untextured faces
			model.getTexIndices1() != null &&
			model.getTexIndices2() != null &&
			model.getTexIndices3() != null &&
			model.getTextureFaces() != null;
		Material baseMaterial = modelOverride.baseMaterial;
		Material textureMaterial = modelOverride.textureMaterial;
		if (!plugin.configModelTextures && !modelOverride.forceMaterialChanges) {
			if (baseMaterial.hasTexture)
				baseMaterial = Material.NONE;
			if (textureMaterial.hasTexture)
				textureMaterial = Material.NONE;
		}
		boolean skipUVs =
			!isVanillaTextured &&
			packMaterialData(baseMaterial, -1, modelOverride, UvType.GEOMETRY, false) == 0;

		// ensure capacity upfront
		sceneContext.stagingBufferVertices.ensureCapacity(bufferSize);
		sceneContext.stagingBufferNormals.ensureCapacity(bufferSize);
		if (!skipUVs)
			sceneContext.stagingBufferUvs.ensureCapacity(bufferSize);

		boolean foundCachedVertexData = false;
		boolean foundCachedNormalData = false;
		boolean foundCachedUvData = skipUVs;
		long vertexHash = 0;
		long normalHash = 0;
		long uvHash = 0;

		if (shouldCache) {
			assert client.isClientThread() : "Model caching isn't thread-safe";

			vertexHash = modelHasher.vertexHash;
			IntBuffer vertexData = this.modelCache.getIntBuffer(vertexHash);
			foundCachedVertexData = vertexData != null && vertexData.remaining() == bufferSize;
			if (foundCachedVertexData) {
				sceneContext.stagingBufferVertices.put(vertexData);
				vertexData.rewind();
			}

			normalHash = modelHasher.calculateNormalCacheHash();
			FloatBuffer normalData = this.modelCache.getFloatBuffer(normalHash);
			foundCachedNormalData = normalData != null && normalData.remaining() == bufferSize;
			if (foundCachedNormalData) {
				sceneContext.stagingBufferNormals.put(normalData);
				normalData.rewind();
			}

			if (!foundCachedUvData) {
				uvHash = modelHasher.calculateUvCacheHash(preOrientation, modelOverride);
				FloatBuffer uvData = this.modelCache.getFloatBuffer(uvHash);
				foundCachedUvData = uvData != null && uvData.remaining() == bufferSize;
				if (foundCachedUvData) {
					texturedFaceCount = faceCount;
					sceneContext.stagingBufferUvs.put(uvData);
					uvData.rewind();
				}
			}

			if (foundCachedVertexData && foundCachedNormalData && foundCachedUvData) {
				sceneContext.modelPusherResults[0] = faceCount;
				sceneContext.modelPusherResults[1] = texturedFaceCount;
				return;
			}
		}

		IntBuffer fullVertexData = null;
		FloatBuffer fullNormalData = null;
		FloatBuffer fullUvData = null;

		boolean shouldCacheVertexData = false;
		boolean shouldCacheNormalData = false;
		boolean shouldCacheUvData = false;
		if (shouldCache) {
			shouldCacheVertexData = !foundCachedVertexData;
			shouldCacheNormalData = !foundCachedNormalData;
			shouldCacheUvData = !foundCachedUvData;

			if (shouldCacheVertexData) {
				fullVertexData = this.modelCache.reserveIntBuffer(vertexHash, bufferSize);
				if (fullVertexData == null) {
					log.error("failed to reserve vertex buffer");
					shouldCacheVertexData = false;
				}
			}

			if (shouldCacheNormalData) {
				fullNormalData = this.modelCache.reserveFloatBuffer(normalHash, bufferSize);
				if (fullNormalData == null) {
					log.error("failed to reserve normal buffer");
					shouldCacheNormalData = false;
				}
			}

			if (shouldCacheUvData) {
				fullUvData = this.modelCache.reserveFloatBuffer(uvHash, bufferSize);
				if (fullUvData == null) {
					log.error("failed to reserve uv buffer");
					shouldCacheUvData = false;
				}
			}
		}

		if (!foundCachedVertexData) {
			if (plugin.enableDetailedTimers)
				frameTimer.begin(Timer.MODEL_PUSHING_VERTEX);

			modelOverride.applyRotation(model);
			for (int face = 0; face < faceCount; face++) {
				int[] data = getFaceVertices(sceneContext, tile, uuid, model, modelOverride, objectType, face);
				sceneContext.stagingBufferVertices.put(data);
				if (shouldCacheVertexData)
					fullVertexData.put(data);
			}
			modelOverride.revertRotation(model);

			if (plugin.enableDetailedTimers)
				frameTimer.end(Timer.MODEL_PUSHING_VERTEX);
		}

		if (!foundCachedNormalData) {
			if (plugin.enableDetailedTimers)
				frameTimer.begin(Timer.MODEL_PUSHING_NORMAL);

			for (int face = 0; face < faceCount; face++) {
				getNormalDataForFace(sceneContext, model, modelOverride, face);
				sceneContext.stagingBufferNormals.put(sceneContext.modelFaceNormals);
				if (shouldCacheNormalData)
					fullNormalData.put(sceneContext.modelFaceNormals);
			}

			if (plugin.enableDetailedTimers)
				frameTimer.end(Timer.MODEL_PUSHING_NORMAL);
		}

		if (!foundCachedUvData) {
			if (plugin.enableDetailedTimers)
				frameTimer.begin(Timer.MODEL_PUSHING_UV);

			for (int face = 0; face < faceCount; face++) {
				UvType uvType = UvType.GEOMETRY;
				Material material = baseMaterial;

				short textureId = isVanillaTextured ? faceTextures[face] : -1;
				if (textureId != -1) {
					uvType = UvType.VANILLA;
					material = textureMaterial;
					if (material == Material.NONE)
						material = Material.fromVanillaTexture(textureId);
				}

				ModelOverride materialOverride = modelOverride;
				if (modelOverride.materialOverrides != null) {
					var override = modelOverride.materialOverrides.get(material);
					if (override != null) {
						materialOverride = override;
						material = materialOverride.textureMaterial;
					}
				}

				if (material != Material.NONE) {
					uvType = materialOverride.uvType;
					if (uvType == UvType.VANILLA || (textureId != -1 && materialOverride.retainVanillaUvs))
						uvType = isVanillaUVMapped && textureFaces[face] != -1 ? UvType.VANILLA : UvType.GEOMETRY;
				}

				int materialData = packMaterialData(material, textureId, materialOverride, uvType, false);

				final float[] uvData = sceneContext.modelFaceNormals;
				if (materialData == 0) {
					Arrays.fill(uvData, 0);
				} else {
					materialOverride.fillUvsForFace(uvData, model, preOrientation, uvType, face);
					uvData[3] = uvData[7] = uvData[11] = materialData;
				}

				sceneContext.stagingBufferUvs.put(uvData);
				if (shouldCacheUvData)
					fullUvData.put(uvData);

				++texturedFaceCount;
			}

			if (plugin.enableDetailedTimers)
				frameTimer.end(Timer.MODEL_PUSHING_UV);
		}

		if (shouldCacheVertexData)
			fullVertexData.flip();
		if (shouldCacheNormalData)
			fullNormalData.flip();
		if (shouldCacheUvData)
			fullUvData.flip();

		sceneContext.modelPusherResults[0] = faceCount;
		sceneContext.modelPusherResults[1] = texturedFaceCount;
	}

	private void getNormalDataForFace(SceneContext sceneContext, Model model, @NonNull ModelOverride modelOverride, int face) {
		assert SceneUploader.packTerrainData(false, 0, WaterType.NONE, 0) == 0;
		if (modelOverride.flatNormals || !plugin.configPreserveVanillaNormals && model.getFaceColors3()[face] == -1) {
			Arrays.fill(sceneContext.modelFaceNormals, 0);
			return;
		}

		final int triA = model.getFaceIndices1()[face];
		final int triB = model.getFaceIndices2()[face];
		final int triC = model.getFaceIndices3()[face];
		final int[] xVertexNormals = model.getVertexNormalsX();
		final int[] yVertexNormals = model.getVertexNormalsY();
		final int[] zVertexNormals = model.getVertexNormalsZ();

		if (xVertexNormals == null || yVertexNormals == null || zVertexNormals == null) {
			Arrays.fill(sceneContext.modelFaceNormals, 0);
			return;
		}

		float terrainData = 0x800000; // Force undo vanilla shading in compute to not use flat normals
		sceneContext.modelFaceNormals[0] = xVertexNormals[triA];
		sceneContext.modelFaceNormals[1] = yVertexNormals[triA];
		sceneContext.modelFaceNormals[2] = zVertexNormals[triA];
		sceneContext.modelFaceNormals[3] = terrainData;
		sceneContext.modelFaceNormals[4] = xVertexNormals[triB];
		sceneContext.modelFaceNormals[5] = yVertexNormals[triB];
		sceneContext.modelFaceNormals[6] = zVertexNormals[triB];
		sceneContext.modelFaceNormals[7] = terrainData;
		sceneContext.modelFaceNormals[8] = xVertexNormals[triC];
		sceneContext.modelFaceNormals[9] = yVertexNormals[triC];
		sceneContext.modelFaceNormals[10] = zVertexNormals[triC];
		sceneContext.modelFaceNormals[11] = terrainData;
	}

	public int packMaterialData(
		@Nonnull Material material,
		int vanillaTexture,
		@Nonnull ModelOverride modelOverride,
		UvType uvType,
		boolean isOverlay
	) {
		// This needs to return zero by default, since we often fall back to writing all zeroes to UVs
		int materialIndex = textureManager.getMaterialIndex(material, vanillaTexture);
		assert materialIndex <= MAX_MATERIAL_COUNT;
		int materialData =
			(materialIndex & MAX_MATERIAL_COUNT) << 12
			| ((int) (modelOverride.shadowOpacityThreshold * 0x3F) & 0x3F) << 6
			| (!modelOverride.receiveShadows ? 1 : 0) << 5
			| (modelOverride.upwardsNormals ? 1 : 0) << 4
			| (modelOverride.flatNormals ? 1 : 0) << 3
			| (uvType.worldUvs ? 1 : 0) << 2
			| (uvType == UvType.VANILLA ? 1 : 0) << 1
			| (isOverlay ? 1 : 0);
		assert (materialData & ~0xFFFFFF) == 0 : "Only the lower 24 bits are usable, since we pass this into shaders as a float";
		return materialData;
	}

	private boolean isBakedGroundShading(Model model, int face) {
		final byte[] faceTransparencies = model.getFaceTransparencies();
		if (faceTransparencies == null || (faceTransparencies[face] & 0xFF) <= 100)
			return false;

		final short[] faceTextures = model.getFaceTextures();
		if (faceTextures != null && faceTextures[face] != -1)
			return false;

		final float[] yVertices = model.getVerticesY();
		float heightA = yVertices[model.getFaceIndices1()[face]];
		if (heightA < -8)
			return false;

		float heightB = yVertices[model.getFaceIndices2()[face]];
		float heightC = yVertices[model.getFaceIndices3()[face]];
		return heightA == heightB && heightA == heightC;
	}

	@SuppressWarnings({ "ReassignedVariable" })
	private int[] getFaceVertices(
		SceneContext sceneContext,
		Tile tile,
		int uuid,
		Model model,
		@NonNull ModelOverride modelOverride,
		ObjectType objectType,
		int face
	) {
		if (model.getFaceColors3()[face] == -2)
			return ZEROED_INTS; // Hide the face

		// Hide fake shadows or lighting that is often baked into models by making the fake shadow transparent
		if (plugin.configHideFakeShadows && isBakedGroundShading(model, face)) {
			if (modelOverride.hideVanillaShadows)
				return ZEROED_INTS; // Hide the face

			if (ModelHash.getUuidType(uuid) == ModelHash.TYPE_PLAYER) {
				int index = ModelHash.getUuidId(uuid);
				var players = client.getTopLevelWorldView().players();
				if (index >= 0 && index < 2048) {
					Player player = players.byIndex(index);
					if (player != null && player.getPlayerComposition().getEquipmentId(KitType.WEAPON) == ItemID.MAGIC_CARPET)
						return ZEROED_INTS; // Hide the face
				}
			}
		}

		int color1 = model.getFaceColors1()[face];
		int color2 = model.getFaceColors2()[face];
		int color3 = model.getFaceColors3()[face];
		final int triA = model.getFaceIndices1()[face];
		final int triB = model.getFaceIndices2()[face];
		final int triC = model.getFaceIndices3()[face];
		final float[] xVertices = model.getVerticesX();
		final float[] yVertices = model.getVerticesY();
		final float[] zVertices = model.getVerticesZ();
		final short[] faceTextures = model.getFaceTextures();
		final byte[] faceTransparencies = model.getFaceTransparencies();
		final byte[] facePriorities = model.getFaceRenderPriorities();
		boolean isTextured = faceTextures != null && faceTextures[face] != -1;

		if (color3 == -1)
			color2 = color3 = color1;

		int packedAlphaPriorityFlags = 0;
		if (faceTransparencies != null && !isTextured)
			packedAlphaPriorityFlags |= (faceTransparencies[face] & 0xFF) << 24;
		if (facePriorities != null)
			packedAlphaPriorityFlags |= (facePriorities[face] & 0xF) << 16;

		if (isTextured) {
			// Without overriding the color for textured faces, vanilla shading remains pretty noticeable even after
			// the approximate reversal above. Ardougne rooftops is a good example, where vanilla shading results in a
			// weird-looking tint. The brightness clamp afterward is required to reduce the over-exposure introduced.
			color1 = color2 = color3 = 90;

			// Let the shader know vanilla shading reversal should be skipped for this face
			packedAlphaPriorityFlags |= 1 << 20;
		} else {
			final int overrideAmount = model.getOverrideAmount() & 0xFF;
			if (overrideAmount > 0) {
				// HSL override is not applied to flat shade faces or to textured faces
				final byte overrideHue = model.getOverrideHue();
				final byte overrideSat = model.getOverrideSaturation();
				final byte overrideLum = model.getOverrideLuminance();

				if (overrideHue != -1) {
					color1 += overrideAmount * (overrideHue - (color1 >> 10 & 0x3F)) >> 7 << 10;
					color2 += overrideAmount * (overrideHue - (color2 >> 10 & 0x3F)) >> 7 << 10;
					color3 += overrideAmount * (overrideHue - (color3 >> 10 & 0x3F)) >> 7 << 10;
				}

				if (overrideSat != -1) {
					color1 += overrideAmount * (overrideSat - (color1 >> 7 & 7)) >> 7 << 7;
					color2 += overrideAmount * (overrideSat - (color2 >> 7 & 7)) >> 7 << 7;
					color3 += overrideAmount * (overrideSat - (color3 >> 7 & 7)) >> 7 << 7;
				}

				if (overrideLum != -1) {
					color1 += overrideAmount * (overrideLum - (color1 & 0x7F)) >> 7;
					color2 += overrideAmount * (overrideLum - (color2 & 0x7F)) >> 7;
					color3 += overrideAmount * (overrideLum - (color3 & 0x7F)) >> 7;
				}
			}

			if (tile != null) {
				if (modelOverride.inheritTileColorType != InheritTileColorType.NONE) {
					final Scene scene = sceneContext.scene;
					SceneTileModel tileModel = tile.getSceneTileModel();
					SceneTilePaint tilePaint = tile.getSceneTilePaint();

					if (tilePaint != null || tileModel != null) {
						// No point in inheriting tilepaint color if the ground tile does not have a color, for example above a cave wall
						if (
							tilePaint != null &&
							tilePaint.getTexture() == -1 &&
							tilePaint.getRBG() != 0 &&
							tilePaint.getNeColor() != 12345678
						) {

							// Since tile colors are guaranteed to have the same hue and saturation per face,
							// we can blend without converting from HSL to RGB
							int averageColor =
								(
									tilePaint.getSwColor() +
									tilePaint.getNwColor() +
									tilePaint.getNeColor() +
									tilePaint.getSeColor()
								) / 4;

							var override = tileOverrideManager.getOverride(scene, tile);
							averageColor = override.modifyColor(averageColor);
							color1 = color2 = color3 = averageColor;

							// Let the shader know vanilla shading reversal should be skipped for this face
							packedAlphaPriorityFlags |= 1 << 20;
						} else if (tileModel != null && tileModel.getTriangleTextureId() == null) {
							int faceColorIndex = -1;
							for (int i = 0; i < tileModel.getTriangleColorA().length; i++) {
								boolean isOverlay = ProceduralGenerator.isOverlayFace(tile, i);
								// Use underlay if the tile does not have an overlay, useful for rocks in cave corners.
								if (modelOverride.inheritTileColorType == InheritTileColorType.UNDERLAY
									|| tileModel.getModelOverlay() == 0) {
									// pulling the color from UNDERLAY is more desirable for green grass tiles
									// OVERLAY pulls in path color which is not desirable for grass next to paths
									if (!isOverlay) {
										faceColorIndex = i;
										break;
									}
								} else if (modelOverride.inheritTileColorType == InheritTileColorType.OVERLAY) {
									if (isOverlay) {
										// OVERLAY used in dirt/path/house tile color blend better with rubbles/rocks
										faceColorIndex = i;
										break;
									}
								}
							}

							if (faceColorIndex != -1) {
								int color = tileModel.getTriangleColorA()[faceColorIndex];
								if (color != 12345678) {
									var scenePos = tile.getSceneLocation();
									int tileX = scenePos.getX();
									int tileY = scenePos.getY();
									int tileZ = tile.getRenderLevel();
									int tileExX = tileX + SceneUploader.SCENE_OFFSET;
									int tileExY = tileY + SceneUploader.SCENE_OFFSET;
									int[] worldPos = sceneContext.sceneToWorld(tileX, tileY, tileZ);
									var override = tileOverrideManager.getOverride(scene, tile, worldPos,
										modelOverride.inheritTileColorType == InheritTileColorType.OVERLAY ?
											OVERLAY_FLAG | scene.getOverlayIds()[tileZ][tileExX][tileExY] :
											scene.getUnderlayIds()[tileZ][tileExX][tileExY]
									);
									color = override.modifyColor(color);
									color1 = color2 = color3 = color;

									// Let the shader know vanilla shading reversal should be skipped for this face
									packedAlphaPriorityFlags |= 1 << 20;
								}
							}
						}
					}
				}

				if (plugin.configTzhaarHD && modelOverride.tzHaarRecolorType != TzHaarRecolorType.NONE) {
					int[] tzHaarRecolored = ProceduralGenerator.recolorTzHaar(
						modelOverride,
						model,
						face,
						packedAlphaPriorityFlags,
						objectType,
						color1,
						color2,
						color3
					);
					color1 = tzHaarRecolored[0];
					color2 = tzHaarRecolored[1];
					color3 = tzHaarRecolored[2];
					packedAlphaPriorityFlags = tzHaarRecolored[3];
				}
			}
		}

		color1 |= packedAlphaPriorityFlags;
		color2 |= packedAlphaPriorityFlags;
		color3 |= packedAlphaPriorityFlags;

		int[] data = sceneContext.modelFaceVertices;
		data[0] = Float.floatToIntBits(xVertices[triA]);
		data[1] = Float.floatToIntBits(yVertices[triA]);
		data[2] = Float.floatToIntBits(zVertices[triA]);
		data[3] = color1;
		data[4] = Float.floatToIntBits(xVertices[triB]);
		data[5] = Float.floatToIntBits(yVertices[triB]);
		data[6] = Float.floatToIntBits(zVertices[triB]);
		data[7] = color2;
		data[8] = Float.floatToIntBits(xVertices[triC]);
		data[9] = Float.floatToIntBits(yVertices[triC]);
		data[10] = Float.floatToIntBits(zVertices[triC]);
		data[11] = color3;
		return data;
	}
}

package rs117.hd.model;

import lombok.RequiredArgsConstructor;

@RequiredArgsConstructor
public class ModelOffsets {
	public final int faceCount;
	public final int vertexOffset;
	public final int uvOffset;
}

package rs117.hd.model;

import java.nio.FloatBuffer;
import java.nio.IntBuffer;
import java.util.ArrayDeque;
import java.util.HashMap;
import lombok.extern.slf4j.Slf4j;
import org.lwjgl.system.MemoryUtil;

import static rs117.hd.utils.HDUtils.GiB;
import static rs117.hd.utils.HDUtils.MiB;

@Slf4j
public class ModelCache {
	private static class Allocation {
		long address;
		long byteCapacity;

		long cursor;
		long freeBytesAhead;

		Allocation(long byteCapacity) {
			assert byteCapacity > 0;
			address = MemoryUtil.nmemAllocChecked(byteCapacity);
			this.byteCapacity = byteCapacity;
			cursor = 0;
			freeBytesAhead = byteCapacity;
		}

		void destroy() {
			if (address != 0L) {
				MemoryUtil.nmemFree(address);
				address = 0;
				byteCapacity = 0;
				cursor = 0;
				freeBytesAhead = 0;
			}
		}

		long reserve(long numBytes) {
			assert numBytes > 0;
			assert numBytes <= freeBytesAhead;
			assert numBytes <= byteCapacity - cursor;
			long address = this.address + cursor;
			cursor += numBytes;
			freeBytesAhead -= numBytes;
			return address;
		}

		long bytesFromEnd() {
			return byteCapacity - cursor;
		}
	}

	private static class Buffer {
		final boolean endMarker;
		final long hash;
		final long byteCapacity;
		final IntBuffer intBuffer;
		final FloatBuffer floatBuffer;

		public Buffer(long byteCapacity) {
			endMarker = true;
			this.hash = 0;
			this.byteCapacity = byteCapacity;
			intBuffer = null;
			floatBuffer = null;
		}

		public Buffer(long hash, IntBuffer buffer) {
			endMarker = false;
			this.hash = hash;
			byteCapacity = buffer.capacity() * 4L;
			intBuffer = buffer;
			floatBuffer = null;
		}

		public Buffer(long hash, FloatBuffer buffer) {
			endMarker = false;
			this.hash = hash;
			byteCapacity = buffer.capacity() * 4L;
			intBuffer = null;
			floatBuffer = buffer;
		}
	}

	private final Runnable terminationHook;
	private final HashMap<Long, Buffer> cache = new HashMap<>();
	private final ArrayDeque<Buffer> buffers = new ArrayDeque<>();
	private final Allocation[] allocations;
	private Allocation currentAllocation;
	private int currentAllocationIndex;

	public ModelCache(int modelCacheSizeMiB, Runnable terminationHook) {
		this.terminationHook = terminationHook;

		// Limit cache size to 128 MiB for 32-bit
		if (modelCacheSizeMiB > 128 && !"64".equals(System.getProperty("sun.arch.data.model"))) {
			log.warn("Defaulting model cache to 128 MiB due to non 64-bit client");
			modelCacheSizeMiB = 128;
		}

		try {
			int totalPhysicalMemoryMiB = (int) (((com.sun.management.OperatingSystemMXBean)
				java.lang.management.ManagementFactory.getOperatingSystemMXBean()).getTotalPhysicalMemorySize() / MiB);

			// Try to limit the cache size to half of the total physical memory
			if (modelCacheSizeMiB > totalPhysicalMemoryMiB / 2) {
				log.warn(
					"Limiting cache size to {} since the selected amount ({}) exceeds half of the total system memory ({} / 2)",
					totalPhysicalMemoryMiB / 2, modelCacheSizeMiB, totalPhysicalMemoryMiB);
				modelCacheSizeMiB = totalPhysicalMemoryMiB / 2;
			}
		} catch (Throwable e) {
			log.warn("Unable to check physical memory size: " + e);
		}

		long byteCapacity = modelCacheSizeMiB * MiB;

		log.debug("Allocating {} MiB model cache", modelCacheSizeMiB);

		Allocation[] allocations = new Allocation[1];
		try {
			// Try allocating the whole size as a single chunk
			allocations[0] = new Allocation(byteCapacity);
		} catch (Throwable err) {
			log.warn("Unable to allocate {} MiB as a single chunk", modelCacheSizeMiB, err);

			try {
				// Try allocating in chunks of up to 1 GiB each
				int numChunks = (int) Math.ceil((double) byteCapacity / GiB);
				allocations = new Allocation[numChunks];
				for (int i = 0; i < numChunks; i++) {
					allocations[i] = new Allocation(Math.min(byteCapacity - i * GiB, GiB));
				}
			} catch (Throwable err2) {
				destroy();
				log.error("Unable to allocate {} MiB in chunks of up to 1 GiB each", modelCacheSizeMiB, err2);
				throw err2;
			}
		}

		this.allocations = allocations;
		currentAllocation = allocations[0];
	}

	public void destroy() {
		cache.clear();
		buffers.clear();
		currentAllocation = null;

		for (int i = 0; i < allocations.length; i++) {
			if (allocations[i] != null) {
				allocations[i].destroy();
				allocations[i] = null;
			}
		}
	}

	@Override
	@SuppressWarnings("deprecation")
	protected void finalize() throws Throwable {
		try {
			// Clean up allocations in case the plugin somehow fails to call destroy
			destroy();
		} finally {
			super.finalize();
		}
	}

	public void clear() {
		cache.clear();
		buffers.clear();
		for (Allocation allocation : allocations) {
			if (allocation != null) {
				allocation.cursor = 0;
				allocation.freeBytesAhead = allocation.byteCapacity;
			}
		}
	}

	private Buffer get(long hash) {
		return cache.get(hash);
	}

	private void nextAllocation() {
		currentAllocation.cursor = 0;
		currentAllocation.freeBytesAhead = 0;

		currentAllocationIndex++;
		currentAllocationIndex %= allocations.length;
		currentAllocation = allocations[currentAllocationIndex];
	}

	private long reserve(long numBytes) {
		assert currentAllocation != null : "model cache used after destruction";

		if (currentAllocation.bytesFromEnd() < numBytes) {
			// ### = taken, ... = free, MMM = end marker
			//                    _________ -> not enough space
			// [##################....###MM]
			// inserting a new end marker as follows will cause issues
			// [##################MMMM###MM]
			// since ### and MM will be freed next, an option is to move these to the end of the buffer list
			// another minor optimization we can make is to pretend that the buffers are shifted to the left like so
			// [##################|MMMM###MM]
			// [##################|###MMMMMM]
			// this leaves us with only a single dummy buffer at the end, and a guarantee that buffers will still be
			// freed in an appropriate order with no collisions

			// Move the existing regions to the end of the buffer list
			while (currentAllocation.bytesFromEnd() != currentAllocation.freeBytesAhead) {
				assert currentAllocation.bytesFromEnd() > currentAllocation.freeBytesAhead;
				Buffer buffer = buffers.pollFirst();
				if (buffer == null) {
					log.error("No more cache entries left to free, yet the allocation is still in use ({} != {})",
						currentAllocation.bytesFromEnd(), currentAllocation.freeBytesAhead);
					terminationHook.run();
					return 0;
				}

				if (buffer.endMarker) {
					// Shift unused space to the end of the buffer, as detailed above
					currentAllocation.freeBytesAhead += buffer.byteCapacity;
					assert currentAllocation.cursor + currentAllocation.freeBytesAhead <= currentAllocation.byteCapacity;
				} else {
					// Move the buffer to the end of the list, and pretend we've shifted it to the left as detailed above
					buffers.addLast(buffer);
					currentAllocation.cursor += buffer.byteCapacity;
				}
			}

			// Consume the remaining free bytes of the allocation
			buffers.addLast(new Buffer(currentAllocation.freeBytesAhead));
			// Advance to the next allocation, or the beginning of the same allocation if there is only one
			nextAllocation();

			if (currentAllocation.bytesFromEnd() < numBytes) {
				log.error("Failed to reserve space for {} bytes. Too large to fit in allocation {} of size {}",
					numBytes, currentAllocationIndex, currentAllocation.byteCapacity);
				terminationHook.run();
				return 0;
			}
		}

		while (currentAllocation.freeBytesAhead < numBytes) {
			if (removeOldestCacheEntry() == null) {
				log.error("No more cache entries left to free, yet there aren't enough free bytes ({} < {})",
					currentAllocation.freeBytesAhead, numBytes);
				terminationHook.run();
				return 0;
			}
		}

		return currentAllocation.reserve(numBytes);
	}

	private Buffer removeOldestCacheEntry() {
		Buffer buffer = buffers.pollFirst();

		if (buffer != null) {
			if (!buffer.endMarker) {
				cache.remove(buffer.hash, buffer);
				// Normally, these addresses will be equal, but in case they've been "shifted" as detailed in the
				// reserve function, the buffer's actual address will be larger than the cursor position
				assert currentAllocation.address + currentAllocation.cursor + currentAllocation.freeBytesAhead <=
					MemoryUtil.memAddress0(buffer.intBuffer == null ? buffer.floatBuffer : buffer.intBuffer);
			}

			currentAllocation.freeBytesAhead += buffer.byteCapacity;
			assert currentAllocation.cursor + currentAllocation.freeBytesAhead <= currentAllocation.byteCapacity;
		}

		return buffer;
	}

	public IntBuffer getIntBuffer(long hash) {
		Buffer buffer = get(hash);
		if (buffer == null)
			return null;
		return buffer.intBuffer;
	}

	public FloatBuffer getFloatBuffer(long hash) {
		Buffer buffer = get(hash);
		if (buffer == null)
			return null;
		return buffer.floatBuffer;
	}

	public IntBuffer reserveIntBuffer(long hash, int capacity) {
		long address = reserve(capacity * 4L);
		if (address == 0L)
			return null;
		Buffer buffer = new Buffer(hash, MemoryUtil.memIntBuffer(address, capacity));
		cache.put(hash, buffer);
		buffers.addLast(buffer);
		return buffer.intBuffer;
	}

	public FloatBuffer reserveFloatBuffer(long hash, int capacity) {
		long address = reserve(capacity * 4L);
		if (address == 0L)
			return null;
		Buffer buffer = new Buffer(hash, MemoryUtil.memFloatBuffer(address, capacity));
		cache.put(hash, buffer);
		buffers.addLast(buffer);
		return buffer.floatBuffer;
	}
}

package rs117.hd.config;

public enum ColorFilter {
	NONE,
	GREYSCALE,
	SEPIA,
	HIGH_CONTRAST,
	CARTOON,
	INVERT_COLORS,
	BLACK_AND_WHITE
}

/*
 * Copyright (c) 2023, Hooder <ahooder@protonmail.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package rs117.hd.config;

public enum ShadowMode
{
	OFF,
	FAST,
	DETAILED
}

/*
 * Copyright (c) 2021, 117 <https://twitter.com/117scape>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package rs117.hd.config;

import lombok.Getter;
import lombok.RequiredArgsConstructor;

@Getter
@RequiredArgsConstructor
public enum ShadowDistance
{
	DISTANCE_20("20", 20),
	DISTANCE_30("30", 30),
	DISTANCE_40("40", 40),
	DISTANCE_50("50", 50),
	DISTANCE_60("60", 60),
	DISTANCE_70("70", 70),
	DISTANCE_80("80", 80),
	DISTANCE_90("90", 90);

	private final String name;
	private final int value;

	@Override
	public String toString()
	{
		return name;
	}
}

/*
 * Copyright (c) 2018, Lotto <https://github.com/devLotto>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package rs117.hd.config;

import lombok.Getter;
import lombok.RequiredArgsConstructor;

@Getter
@RequiredArgsConstructor
public enum AntiAliasingMode
{
	DISABLED("Disabled", 0),
	MSAA_2("MSAA x2", 2),
	MSAA_4("MSAA x4", 4),
	MSAA_8("MSAA x8", 8),
	MSAA_16("MSAA x16", 16);

	private final String name;
	private final int samples;

	@Override
	public String toString()
	{
		return name;
	}
}

/*
 * Copyright (c) 2021, 117 <https://twitter.com/117scape>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package rs117.hd.config;

import lombok.Getter;
import lombok.RequiredArgsConstructor;

@Getter
@RequiredArgsConstructor
public enum MaxDynamicLights
{
	NONE("None", 0),
	FEW("Few (25)", 25),
	SOME("Some (50)", 50),
	MANY("Many (100)", 100);

	private final String name;
	private final int value;

	@Override
	public String toString()
	{
		return name;
	}
}

/*
 * Copyright (c) 2020 Ben Poulson <https://github.com/benpoulson>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package rs117.hd.config;

public enum ColorBlindMode {
	NONE,
	PROTANOPE,
	DEUTERANOPE,
	TRITANOPE
}

/*
 * Copyright (c) 2023, Hooder <ahooder@protonmail.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package rs117.hd.config;

import lombok.Getter;
import lombok.RequiredArgsConstructor;

@Getter
@RequiredArgsConstructor
public enum ShadingMode {
	DEFAULT("117 HD"),
	VANILLA("Vanilla"),
	NONE("None"),
	;

	private final String name;

	@Override
	public String toString() {
		return name;
	}
}

/*
 * Copyright (c) 2021, 117 <https://twitter.com/117scape>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package rs117.hd.config;

import lombok.Getter;
import lombok.RequiredArgsConstructor;

@Getter
@RequiredArgsConstructor
public enum Contrast
{
	HIGHER("Highest", 1.1f),
	HIGHEST("Higher", 1.05f),
	DEFAULT("Default", 1.0f),
	LOWER("Lower", 0.95f),
	LOWEST("Lowest", 0.9f);

	private final String name;
	private final float amount;

	@Override
	public String toString()
	{
		return name;
	}
}

package rs117.hd.config;

import lombok.Getter;
import lombok.RequiredArgsConstructor;

@Getter
@RequiredArgsConstructor
public enum SeasonalTheme {
	AUTOMATIC,
	SUMMER,
	AUTUMN,
	WINTER,
	;
}

/*
 * Copyright (c) 2024, Hooder <ahooder@protonmail.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package rs117.hd.config;

import lombok.Getter;
import lombok.RequiredArgsConstructor;

@Getter
@RequiredArgsConstructor
public enum VanillaShadowMode {
	SHOW("Show", true),
	SHOW_IN_PVM("Show in PvM", true),
	PREFER_IN_PVM("Prefer in PvM", true),
	HIDE("Hide", false),
	;

	private final String name;

	public final boolean retainInPvm;

	@Override
	public String toString() {
		return name;
	}
}

/*
 * Copyright (c) 2022, Hooder <ahooder@protonmail.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package rs117.hd.config;

import lombok.Getter;
import lombok.RequiredArgsConstructor;

@Getter
@RequiredArgsConstructor
public enum TextureResolution
{
	RES_128("128", 128),
	RES_256("256", 256);

	private final String name;
	private final int size;

	@Override
	public String toString()
	{
		return name;
	}
}

/*
 * Copyright (c) 2021, 117 <https://twitter.com/117scape>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package rs117.hd.config;

import lombok.Getter;
import lombok.RequiredArgsConstructor;

@Getter
@RequiredArgsConstructor
public enum FogDepthMode
{
	NONE("None", 0),
	DYNAMIC("Dynamic", 1),
	USER_DEFINED("Static", 2);

	private final String name;
	private final int mode;

	@Override
	public String toString()
	{
		return name;
	}
}

/*
 * Copyright (c) 2021, 117 <https://twitter.com/117scape>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package rs117.hd.config;

import lombok.Getter;
import lombok.RequiredArgsConstructor;
import net.runelite.api.*;
import rs117.hd.utils.ColorUtils;

@Getter
@RequiredArgsConstructor
public enum DefaultSkyColor
{
	DEFAULT("117 HD Blue", 185, 214, 255),
	RUNELITE("RuneLite Skybox", -1, -1, -1),
	OSRS("Old School Black", 0, 0, 0),
	HD2008("2008 HD Tan", 200, 192, 169);

	private final String name;
	private final int r;
	private final int g;
	private final int b;

	@Override
	public String toString()
	{
		return name;
	}

	public float[] getRgb(Client client) {
		int r = this.r;
		int g = this.g;
		int b = this.b;
		if (this == RUNELITE)
		{
			int sky = client.getSkyboxColor();
			r = sky >> 16 & 0xFF;
			g = sky >> 8 & 0xFF;
			b = sky & 0xFF;
		}
		return new float[] {
			ColorUtils.srgbToLinear(r / 255f),
			ColorUtils.srgbToLinear(g / 255f),
			ColorUtils.srgbToLinear(b / 255f)
		};
	}
}

/*
 * Copyright (c) 2019 logarrhytmic <https://github.com/logarrhythmic>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package rs117.hd.config;

import lombok.Getter;
import lombok.RequiredArgsConstructor;

@Getter
@RequiredArgsConstructor
public enum UIScalingMode
{
	NEAREST("Nearest", 0),
	LINEAR("Bilinear", 0),
	MITCHELL("Mitchell", 1),
	CATMULL_ROM("Catmull-Rom", 2),
	XBR("xBR", 3);

	private final String name;
	private final int mode;

	@Override
	public String toString()
	{
		return name;
	}
}

/*
 * Copyright (c) 2021, 117 <https://twitter.com/117scape>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package rs117.hd.config;

	import lombok.Getter;
	import lombok.RequiredArgsConstructor;

@Getter
@RequiredArgsConstructor
public enum ShadowResolution
{
	RES_1024("Low (1K)", 1024),
	RES_2048("Medium (2K)", 2048),
	RES_4096("High (4K)", 4096),
	RES_8192("Ultra (8K)", 8192),
	RES_16384("Extreme (16K)", 16384);

	private final String name;
	private final int value;

	@Override
	public String toString()
	{
		return name;
	}
}

/*
 * Copyright (c) 2021, 117 <https://twitter.com/117scape>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package rs117.hd.config;

import lombok.Getter;
import lombok.RequiredArgsConstructor;

@Getter
@RequiredArgsConstructor
public enum Saturation
{
	HIGHEST("Highest", 1.2f),
	HIGHER("Higher", 1.1f),
	DEFAULT("Default", 1.0f),
	LOWER("Lower", 0.9f),
	LOWEST("Lowest", 0.8f),
	NONE("None", 0.0f);

	private final String name;
	private final float amount;

	@Override
	public String toString()
	{
		return name;
	}
}

/*
 * Copyright (c) 2018, Adam <Adam@sigterm.info>
 * Copyright (c) 2021, 117 <https://twitter.com/117scape>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package rs117.hd;

import net.runelite.client.config.Config;
import net.runelite.client.config.ConfigGroup;
import net.runelite.client.config.ConfigItem;
import net.runelite.client.config.ConfigSection;
import net.runelite.client.config.Range;
import net.runelite.client.config.Units;
import rs117.hd.config.AntiAliasingMode;
import rs117.hd.config.ColorBlindMode;
import rs117.hd.config.ColorFilter;
import rs117.hd.config.Contrast;
import rs117.hd.config.DefaultSkyColor;
import rs117.hd.config.FogDepthMode;
import rs117.hd.config.MaxDynamicLights;
import rs117.hd.config.Saturation;
import rs117.hd.config.SeasonalTheme;
import rs117.hd.config.ShadingMode;
import rs117.hd.config.ShadowDistance;
import rs117.hd.config.ShadowMode;
import rs117.hd.config.ShadowResolution;
import rs117.hd.config.TextureResolution;
import rs117.hd.config.UIScalingMode;
import rs117.hd.config.VanillaShadowMode;

import static rs117.hd.HdPlugin.MAX_DISTANCE;
import static rs117.hd.HdPlugin.MAX_FOG_DEPTH;
import static rs117.hd.HdPluginConfig.CONFIG_GROUP;

@ConfigGroup(CONFIG_GROUP)
public interface HdPluginConfig extends Config
{
	String CONFIG_GROUP = "hd";

	/*====== General settings ======*/

	@ConfigSection(
		name = "General",
		description = "General settings",
		position = 0
	)
	String generalSettings = "generalSettings";

	@Range(
		max = MAX_DISTANCE
	)
	@ConfigItem(
		keyName = "drawDistance",
		name = "Draw Distance",
		description =
			"The number of tiles to draw in either direction from the camera, up to a maximum of 184.<br>" +
			"Depending on where the scene is centered, you might only see 16 tiles in one direction, unless you extend map loading.",
		position = 0,
		section = generalSettings
	)
	default int drawDistance() {
		return 50;
	}

	String KEY_EXPANDED_MAP_LOADING_CHUNKS = "expandedMapLoadingChunks";
	@Range(
		max = 5
	)
	@ConfigItem(
		keyName = KEY_EXPANDED_MAP_LOADING_CHUNKS,
		name = "Extended map loading",
		description =
			"How much further the map should be loaded. The maximum is 5 extra chunks.<br>" +
			"Note, extending the map can have a very high impact on performance.",
		position = 1,
		section = generalSettings
	)
	default int expandedMapLoadingChunks() {
		return 3;
	}

	@ConfigItem(
		keyName = "antiAliasingMode",
		name = "Anti-Aliasing",
		description =
			"Improves pixelated edges at the cost of significantly higher GPU usage.<br>" +
			"MSAA x16 is very expensive, so x8 is recommended if anti-aliasing is desired.",
		position = 2,
		section = generalSettings
	)
	default AntiAliasingMode antiAliasingMode()
	{
		return AntiAliasingMode.DISABLED;
	}

	String KEY_UI_SCALING_MODE = "uiScalingMode";
	@ConfigItem(
		keyName = KEY_UI_SCALING_MODE,
		name = "UI Scaling Mode",
		description =
			"The sampling function to use when the Stretched Mode plugin is enabled.<br>" +
			"Affects how the UI looks with non-integer scaling.",
		position = 3,
		section = generalSettings
	)
	default UIScalingMode uiScalingMode()
	{
		return UIScalingMode.LINEAR;
	}

	String KEY_ANISOTROPIC_FILTERING_LEVEL = "anisotropicFilteringLevel";
	@Range(
		min = 0,
		max = 16
	)
	@ConfigItem(
		keyName = KEY_ANISOTROPIC_FILTERING_LEVEL,
		name = "Anisotropic Filtering",
		description =
			"Configures whether mipmapping and anisotropic filtering should be used.<br>" +
			"At zero, mipmapping is disabled and textures look the most pixelated.<br>" +
			"At 1 through 16, mipmapping is enabled, and textures look more blurry and smoothed out.<br>" +
			"The higher you go beyond 1, the less blurry textures will look, up to a certain extent.",
		position = 4,
		section = generalSettings
	)
	default int anisotropicFilteringLevel()
	{
		return 16;
	}

	String KEY_UNLOCK_FPS = "unlockFps";
	@ConfigItem(
		keyName = KEY_UNLOCK_FPS,
		name = "Unlock FPS",
		description = "Removes the 50 FPS cap for some game content, such as camera movement and dynamic lighting.",
		position = 5,
		section = generalSettings
	)
	default boolean unlockFps()
	{
		return false;
	}

	enum SyncMode
	{
		OFF,
		ON,
		ADAPTIVE
	}

	String KEY_VSYNC_MODE = "vsyncMode";
	@ConfigItem(
		keyName = KEY_VSYNC_MODE,
		name = "VSync Mode",
		description =
			"Controls whether the frame rate should be synchronized with your monitor's refresh rate.<br>" +
			"If set to 'off', the FPS Target option will be used instead.<br>" +
			"If set to 'adaptive', FPS will be limited to your monitor's refresh rate, which saves power.<br>" +
			"If set to 'on', the game will attempt to match your monitor's refresh rate <b>exactly</b>,<br>" +
			"but if it can't keep up, FPS will be <u>halved until it catches up</u>. This option is rarely desired.<br>" +
			"Note, GPUs that don't support Adaptive VSync will silently fall back to 'on'.",
		position = 6,
		section = generalSettings
	)
	default SyncMode syncMode()
	{
		return SyncMode.ADAPTIVE;
	}

	String KEY_FPS_TARGET = "fpsTarget";
	@ConfigItem(
		keyName = KEY_FPS_TARGET,
		name = "FPS Target",
		description =
			"Controls the maximum number of frames per second.<br>" +
			"This setting only applies if Unlock FPS is enabled, and VSync Mode is set to 'off'.",
		position = 7,
		section = generalSettings
	)
	@Range(
		min = 0,
		max = 999
	)
	default int fpsTarget()
	{
		return 60;
	}

	String KEY_COLOR_BLINDNESS = "colorBlindMode";
	@ConfigItem(
		keyName = KEY_COLOR_BLINDNESS,
		name = "Color Blindness",
		description = "Adjust colors to make them more distinguishable for people with a certain type of color blindness.",
		position = 8,
		section = generalSettings
	)
	default ColorBlindMode colorBlindness()
	{
		return ColorBlindMode.NONE;
	}

	@ConfigItem(
		keyName = "colorBlindnessIntensity",
		name = "Blindness Intensity",
		description = "Specifies how intense the color blindness adjustment should be.",
		position = 9,
		section = generalSettings
	)
	@Units(Units.PERCENT)
	@Range(max = 100)
	default int colorBlindnessIntensity()
	{
		return 100;
	}

	@ConfigItem(
		keyName = "flashingEffects",
		name = "Flashing Effects",
		description = "Whether to show rapid flashing effects, such as lightning, in certain areas.",
		position = 10,
		section = generalSettings
	)
	default boolean flashingEffects()
	{
		return false;
	}

	@ConfigItem(
		keyName = "fSaturation",
		name = "Saturation",
		description = "Controls the saturation of the final rendered image.<br>" +
			"Intended to be kept between 0% and 120%.",
		position = 11,
		section = generalSettings
	)
	@Units(Units.PERCENT)
	@Range(min = -500, max = 500)
	default int saturation()
	{
		return Math.round(oldSaturationDropdown().getAmount() * 100);
	}
	@ConfigItem(keyName = "saturation", hidden = true, name = "", description = "")
	default Saturation oldSaturationDropdown()
	{
		return Saturation.DEFAULT;
	}

	@ConfigItem(
		keyName = "fContrast",
		name = "Contrast",
		description = "Controls the contrast of the final rendered image.<br>" +
			"Intended to be kept between 90% and 110%.",
		position = 12,
		section = generalSettings
	)
	@Units(Units.PERCENT)
	@Range(min = -500, max = 500)
	default int contrast()
	{
		return Math.round(oldContrastDropdown().getAmount() * 100);
	}
	@ConfigItem(keyName = "contrast", hidden = true, name = "", description = "")
	default Contrast oldContrastDropdown()
	{
		return Contrast.DEFAULT;
	}

	@Range(
		min = 1,
		max = 50
	)
	@ConfigItem(
		keyName = "brightness2",
		name = "Brightness",
		description = "Controls the brightness of environmental lighting.<br>" +
			"A brightness value of 20 is recommended.",
		position = 13,
		section = generalSettings
	)
	default int brightness() { return 20; }


	/*====== Lighting settings ======*/

	@ConfigSection(
		name = "Lighting",
		description = "Lighting settings",
		position = 1
	)
	String lightingSettings = "lightingSettings";

	String KEY_MAX_DYNAMIC_LIGHTS = "maxDynamicLights";
	@ConfigItem(
		keyName = KEY_MAX_DYNAMIC_LIGHTS,
		name = "Dynamic Lights",
		description =
			"The maximum number of dynamic lights visible at once.<br>" +
			"Reducing this may improve performance.",
		position = 1,
		section = lightingSettings
	)
	default MaxDynamicLights maxDynamicLights()
	{
		return MaxDynamicLights.SOME;
	}

	String KEY_PROJECTILE_LIGHTS = "projectileLights";
	@ConfigItem(
		keyName = KEY_PROJECTILE_LIGHTS,
		name = "Projectile Lights",
		description = "Adds dynamic lights to some projectiles.",
		position = 2,
		section = lightingSettings
	)
	default boolean projectileLights() {
		return true;
	}

	String KEY_NPC_LIGHTS = "npcLights";
	@ConfigItem(
		keyName = KEY_NPC_LIGHTS,
		name = "NPC Lights",
		description = "Adds dynamic lights to some NPCs.",
		position = 3,
		section = lightingSettings
	)
	default boolean npcLights() {
		return true;
	}

	String KEY_ATMOSPHERIC_LIGHTING = "environmentalLighting";
	@ConfigItem(
		keyName = KEY_ATMOSPHERIC_LIGHTING,
		name = "Atmospheric Lighting",
		description = "Change environmental lighting based on the current area.",
		position = 4,
		section = lightingSettings
	)
	default boolean atmosphericLighting() {
		return true;
	}

	String KEY_SHADOW_MODE = "shadowMode";
	@ConfigItem(
		keyName = KEY_SHADOW_MODE,
		name = "Shadows",
		description =
			"Render fully dynamic shadows.<br>" +
			"'Off' completely disables shadows.<br>" +
			"'Fast' enables fast shadows without any texture detail.<br>" +
			"'Detailed' enables slower shadows with support for texture detail.",
		position = 5,
		section = lightingSettings
	)
	default ShadowMode shadowMode()
	{
		return ShadowMode.DETAILED;
	}

	String KEY_SHADOW_TRANSPARENCY = "enableShadowTransparency";
	@ConfigItem(
		keyName = "enableShadowTransparency",
		name = "Shadow Transparency",
		description =
			"Enables partial support for shadows that take transparency into account.",
		position = 6,
		section = lightingSettings
	)
	default boolean enableShadowTransparency()
	{
		return true;
	}

	String KEY_SHADOW_RESOLUTION = "shadowResolution";
	@ConfigItem(
		keyName = KEY_SHADOW_RESOLUTION,
		name = "Shadow Quality",
		description =
			"The resolution of the shadow map.<br>" +
			"Higher resolutions result in higher quality shadows, at the cost of higher GPU usage.",
		position = 7,
		section = lightingSettings
	)
	default ShadowResolution shadowResolution()
	{
		return ShadowResolution.RES_4096;
	}

	@ConfigItem(
		keyName = "shadowDistance",
		name = "Shadow Distance",
		description =
			"The maximum draw distance for shadows.<br>" +
			"Shorter distances result in higher quality shadows.",
		position = 9,
		section = lightingSettings
	)
	default ShadowDistance shadowDistance()
	{
		return ShadowDistance.DISTANCE_50;
	}

	String KEY_EXPAND_SHADOW_DRAW = "expandShadowDraw";
	@ConfigItem(
		keyName = KEY_EXPAND_SHADOW_DRAW,
		name = "Expand Shadow Draw",
		description =
			"Reduces shadows popping in and out at the edge of the screen by rendering<br>" +
			"shadows for a larger portion of the scene, at the cost of higher GPU usage.",
		position = 10,
		section = lightingSettings
	)
	default boolean expandShadowDraw()
	{
		return false;
	}

	String KEY_VANILLA_SHADOW_MODE = "vanillaShadowMode";
	@ConfigItem(
		keyName = KEY_VANILLA_SHADOW_MODE,
		name = "Vanilla Shadows",
		description =
			"Choose whether shadows built into models by Jagex should be hidden. This does not affect clickboxes.<br>" +
			"'Show in PvM' will retain shadows for falling crystals during the Olm fight and other useful cases.<br>" +
			"'Prefer in PvM' will do the above and also disable 117 HD's dynamic shadows in such cases.",
		position = 11,
		section = lightingSettings
	)
	default VanillaShadowMode vanillaShadowMode() {
		return VanillaShadowMode.SHOW_IN_PVM;
	}

	String KEY_NORMAL_MAPPING = "normalMapping";
	@ConfigItem(
		keyName = KEY_NORMAL_MAPPING,
		name = "Normal Mapping",
		description = "Affects how light interacts with certain materials. Barely impacts performance.",
		position = 12,
		section = lightingSettings
	)
	default boolean normalMapping() {
		return true;
	}

	String KEY_PARALLAX_OCCLUSION_MAPPING = "parallaxOcclusionMappingToggle";
	@ConfigItem(
		keyName = KEY_PARALLAX_OCCLUSION_MAPPING,
		name = "Parallax Occlusion Mapping",
		description = "Adds more depth to some materials, at the cost of higher GPU usage.",
		position = 13,
		section = lightingSettings
	)
	default boolean parallaxOcclusionMapping() {
		return true;
	}


	/*====== Environment settings ======*/

	@ConfigSection(
		name = "Environment",
		description = "Environment settings",
		position = 2
	)
	String environmentSettings = "environmentSettings";

	String KEY_SEASONAL_THEME = "seasonalTheme";
	@ConfigItem(
		keyName = KEY_SEASONAL_THEME,
		name = "Seasonal Theme",
		description = "Festive themes for Gielinor.",
		position = 0,
		section = environmentSettings
	)
	default SeasonalTheme seasonalTheme() {
		return SeasonalTheme.AUTOMATIC;
	}

	@ConfigItem(
		keyName = "fogDepthMode",
		name = "Fog Depth Mode",
		description =
			"Determines how the fog amount is controlled.<br>" +
			"'Dynamic' changes fog depth based on the area, while<br>" +
			"'Static' respects the manually defined fog depth.",
		position = 1,
		section = environmentSettings
	)
	default FogDepthMode fogDepthMode()
	{
		return FogDepthMode.DYNAMIC;
	}

	@Range(
		max = MAX_FOG_DEPTH
	)
	@ConfigItem(
		keyName = "fogDepth",
		name = "Static Fog Depth",
		description =
			"Specify how far from the edge fog should reach.<br>" +
			"This applies only when 'Fog Depth Mode' is set to 'Static'.",
		position = 2,
		section = environmentSettings
	)
	default int fogDepth()
	{
		return 5;
	}

	@ConfigItem(
		keyName = "groundFog",
		name = "Ground Fog",
		description = "Enables a height-based fog effect that covers the ground in certain areas.",
		position = 3,
		section = environmentSettings
	)
	default boolean groundFog() {
		return true;
	}

	@ConfigItem(
		keyName = "defaultSkyColor",
		name = "Default Sky",
		description =
			"Specify a sky color to use when the current area doesn't have a sky color defined.<br>" +
			"This only applies when the default summer seasonal theme is active.<br>" +
			"If set to 'RuneLite Skybox', the sky color from RuneLite's Skybox plugin will be used.<br>" +
			"If set to 'Old School Black', the sky will be black and water will remain blue, but for any<br>" +
			"other option, the water color will be influenced by the sky color.",
		position = 4,
		section = environmentSettings
	)
	default DefaultSkyColor defaultSkyColor()
	{
		return DefaultSkyColor.DEFAULT;
	}

	@ConfigItem(
		keyName = "overrideSky",
		name = "Override Sky Color",
		description = "Forces the default sky color to be used in all environments.",
		position = 5,
		section = environmentSettings
	)
	default boolean overrideSky() {
		return false;
	}

	String KEY_MODEL_TEXTURES = "objectTextures";
	@ConfigItem(
		keyName = KEY_MODEL_TEXTURES,
		name = "Model Textures",
		description = "Adds textures to some models.",
		position = 6,
		section = environmentSettings
	)
	default boolean modelTextures() {
		return true;
	}

	String KEY_GROUND_TEXTURES = "groundTextures";
	@ConfigItem(
		keyName = KEY_GROUND_TEXTURES,
		name = "Ground Textures",
		description = "Adds textures to some ground tiles.",
		position = 7,
		section = environmentSettings
	)
	default boolean groundTextures()
	{
		return true;
	}

	String KEY_TEXTURE_RESOLUTION = "textureResolution";
	@ConfigItem(
		keyName = KEY_TEXTURE_RESOLUTION,
		name = "Texture Resolution",
		description = "Controls the resolution used for all in-game textures.",
		position = 8,
		section = environmentSettings
	)
	default TextureResolution textureResolution()
	{
		return TextureResolution.RES_256;
	}

	String KEY_GROUND_BLENDING = "groundBlending";
	@ConfigItem(
		keyName = KEY_GROUND_BLENDING,
		name = "Ground Blending",
		description = "Controls whether ground tiles should blend into each other, or have distinct edges.",
		position = 9,
		section = environmentSettings
	)
	default boolean groundBlending()
	{
		return true;
	}

	@ConfigItem(
		keyName = "underwaterCaustics",
		name = "Underwater Caustics",
		description = "Apply underwater lighting effects to imitate sunlight passing through waves on the surface.",
		position = 10,
		section = environmentSettings
	)
	default boolean underwaterCaustics()
	{
		return true;
	}

	String KEY_HD_TZHAAR_RESKIN = "tzhaarHD";
	@ConfigItem(
		keyName = KEY_HD_TZHAAR_RESKIN,
		name = "HD TzHaar Reskin",
		description = "Recolors the TzHaar city of Mor Ul Rek to give it an appearance similar to that of its 2008 HD variant.",
		position = 11,
		section = environmentSettings
	)
	default boolean hdTzHaarReskin() {
		return true;
	}


	/*====== Model caching settings ======*/

	@ConfigSection(
		name = "Model caching",
		description = "Improve performance by reusing model data",
		position = 3,
		closedByDefault = true
	)
	String modelCachingSettings = "modelCachingSettings";

	String KEY_MODEL_BATCHING = "useModelBatching";
	@ConfigItem(
		keyName = KEY_MODEL_BATCHING,
		name = "Model Batching",
		description =
			"Model batching improves performance by reusing identical models within the same frame.<br>" +
			"May cause instability and graphical bugs, particularly if Jagex makes engine changes.",
		position = 1,
		section = modelCachingSettings
	)
	default boolean modelBatching() {return true;}

	String KEY_MODEL_CACHING = "useModelCaching";
	@ConfigItem(
		keyName = KEY_MODEL_CACHING,
		name = "Model Caching",
		description =
			"Model caching improves performance by saving and reusing model data from previous frames.<br>" +
			"May cause instability or graphical bugs, particularly if Jagex makes engine changes.",
		position = 2,
		section = modelCachingSettings
	)
	default boolean modelCaching() {return true;}

	String KEY_MODEL_CACHE_SIZE = "modelCacheSizeMiBv2";
	@Range(
		min = 64,
		max = 16384
	)
	@ConfigItem(
		keyName = KEY_MODEL_CACHE_SIZE,
		name = "Cache Size (MiB)",
		description =
			"Size of the model cache in mebibytes (slightly more than megabytes).<br>" +
			"Generally, 512 MiB is plenty, with diminishing returns the higher you go.<br>" +
			"Minimum=64 MiB, maximum=16384 MiB",
		position = 3,
		section = modelCachingSettings
	)
	default int modelCacheSizeMiB() {
		return modelCacheSizeMiBv1() / 4;
	}
	@ConfigItem(keyName = "modelCacheSizeMiB", hidden = true, name = "", description = "")
	default int modelCacheSizeMiBv1()
	{
		return 2048;
	}


	/*====== Miscellaneous settings ======*/

	@ConfigSection(
		name = "Miscellaneous",
		description = "Miscellaneous settings",
		position = 4,
		closedByDefault = true
	)
	String miscellaneousSettings = "miscellaneousSettings";

	String KEY_MACOS_INTEL_WORKAROUND = "macosIntelWorkaround";
	@ConfigItem(
		keyName = KEY_MACOS_INTEL_WORKAROUND,
		name = "Fix white color issue on Macs",
		description = "Workaround for visual artifacts found on some Intel GPU drivers on macOS.",
		warning =
			"This setting can cause RuneLite to crash, and it can be difficult to undo.\n" +
			"Only enable it if you are seeing broken colors. Are you sure you want to enable this setting?",
		position = 1,
		section = miscellaneousSettings
	)
	default boolean macosIntelWorkaround()
	{
		return false;
	}

	String KEY_HD_INFERNAL_CAPE = "hdInfernalTexture";
	@ConfigItem(
		keyName = KEY_HD_INFERNAL_CAPE,
		name = "HD Infernal Cape",
		description =
			"Replace the infernal cape texture with a more detailed version.<br>" +
			"Note, with Anisotropic Filtering above zero, the cape may look blurry when zoomed out.",
		position = 2,
		section = miscellaneousSettings
	)
	default boolean hdInfernalTexture() {
		return true;
	}

	String KEY_LEGACY_GREY_COLORS = "reduceOverExposure";
	@ConfigItem(
		keyName = KEY_LEGACY_GREY_COLORS,
		name = "Legacy Grey Colors",
		description =
			"Previously, HD attempted to reduce over-exposure by capping the maximum color brightness,<br>" +
			"which changed white colors into dull shades of grey. This option brings back that old behaviour.",
		position = 4,
		section = miscellaneousSettings
	)
	default boolean legacyGreyColors() {
		return false;
	}

	String KEY_VANILLA_COLOR_BANDING = "vanillaColorBanding";
	@ConfigItem(
		keyName = KEY_VANILLA_COLOR_BANDING,
		name = "Vanilla Color Banding",
		description =
			"Blend between colors similarly to how it works in vanilla, with clearly defined bands of color.<br>" +
			"This isn't really noticeable on textured surfaces, and is intended to be used without ground textures.",
		position = 5,
		section = miscellaneousSettings
	)
	default boolean vanillaColorBanding() {
		return false;
	}

	String KEY_LOW_MEMORY_MODE = "lowMemoryMode";
	@ConfigItem(
		keyName = KEY_LOW_MEMORY_MODE,
		name = "Low Memory Mode",
		description = "Turns off features which require extra memory, such as model caching, faster scene loading & extended scene loading.",
		warning =
			"<html>This <b>will not</b> result in better performance. It is recommended only if you are unable to install<br>" +
			"the 64-bit version of RuneLite, or if your computer has a very low amount of memory available.</html>",
		position = 6,
		section = miscellaneousSettings
	)
	default boolean lowMemoryMode() {
		return false;
	}

	String KEY_REPLACE_FISHING_SPOTS = "replaceFishingSpots";
	@ConfigItem(
		keyName = KEY_REPLACE_FISHING_SPOTS,
		name = "Replace Fishing Spots",
		description = "Replace certain fishing spots with more appropriate models that are easier to see.",
		position = 7,
		section = miscellaneousSettings
	)
	default boolean replaceFishingSpots() {
		return true;
	}

	String KEY_COLOR_FILTER = "colorFilter";
	@ConfigItem(
		keyName = KEY_COLOR_FILTER,
		name = "Color Filter",
		description = "Apply a color filter to the game as a post-processing effect.",
		position = 8,
		section = miscellaneousSettings
	)
	default ColorFilter colorFilter() {
		return ColorFilter.NONE;
	}

	String KEY_REMOVE_VERTEX_SNAPPING = "removeVertexSnapping";
	@ConfigItem(
		keyName = KEY_REMOVE_VERTEX_SNAPPING,
		name = "Remove vertex snapping",
		description =
			"Removes vertex snapping from most animations.<br>" +
			"Most animations are barely affected by this, and it only has an effect if the animation smoothing plugin is turned off.<br>" +
			"To see quite clearly what impact this option has, a good example is the godsword idle animation.",
		position = 9,
		section = miscellaneousSettings
	)
	default boolean removeVertexSnapping() {
		return true;
	}


	/*====== Experimental settings ======*/

	@ConfigSection(
		name = "Experimental",
		description = "Experimental features - if you're experiencing issues you should consider disabling these",
		position = 5,
		closedByDefault = true
	)
	String experimentalSettings = "experimentalSettings";

	String KEY_FILL_GAPS_IN_TERRAIN = "experimentalFillGapsInTerrain2";
	@ConfigItem(
		keyName = KEY_FILL_GAPS_IN_TERRAIN,
		name = "Fill gaps in terrain",
		description = "Attempt to patch all holes in the ground, such as around trapdoors and ladders.",
		section = experimentalSettings
	)
	default boolean fillGapsInTerrain() {
		return true;
	}

	String KEY_FASTER_MODEL_HASHING = "experimentalFasterModelHashing";
	@ConfigItem(
		keyName = KEY_FASTER_MODEL_HASHING,
		name = "Use faster model hashing",
		description = "Should increase performance at the expense of potential graphical issues.",
		section = experimentalSettings
	)
	default boolean fasterModelHashing() {
		return true;
	}

	String KEY_PRESERVE_VANILLA_NORMALS = "experimentalPreserveVanillaNormals";
	@ConfigItem(
		keyName = KEY_PRESERVE_VANILLA_NORMALS,
		name = "Preserve vanilla normals",
		description = "Originally, 117 HD would respect vanilla normals, but these are often less accurate.",
		section = experimentalSettings
	)
	default boolean preserveVanillaNormals() {
		return false;
	}

	String KEY_SHADING_MODE = "experimentalShadingMode";
	@ConfigItem(
		keyName = KEY_SHADING_MODE,
		name = "Shading mode",
		description =
			"If you prefer playing without shadows, maybe you'll prefer vanilla shading or no shading as well.<br>" +
			"Keep in mind, with vanilla shading used alongside shadows, you can end up with double shading.",
		section = experimentalSettings
	)
	default ShadingMode shadingMode() {
		return ShadingMode.DEFAULT;
	}

	String KEY_FLAT_SHADING = "experimentalFlatShading";
	@ConfigItem(
		keyName = KEY_FLAT_SHADING,
		name = "Flat shading",
		description = "Gives a more low-poly look to the game.",
		section = experimentalSettings
	)
	default boolean flatShading() {
		return false;
	}

	String KEY_DECOUPLE_WATER_FROM_SKY_COLOR = "experimentalDecoupleWaterFromSkyColor";
	@ConfigItem(
		keyName = KEY_DECOUPLE_WATER_FROM_SKY_COLOR,
		name = "Decouple water from sky color",
		description = "Some people prefer the water staying blue even with a different sky color active.",
		section = experimentalSettings
	)
	default boolean decoupleSkyAndWaterColor() {
		return false;
	}


	/*====== Internal settings ======*/

	@ConfigItem(keyName = "pluginUpdateMessage", hidden = true, name = "", description = "")
	void setPluginUpdateMessage(int version);
	@ConfigItem(keyName = "pluginUpdateMessage", hidden = true, name = "", description = "")
	default int getPluginUpdateMessage() {
		return 0;
	}
}

/*
 * Copyright (c) 2021, Adam <Adam@sigterm.info>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package rs117.hd.opengl.compute;

import java.io.IOException;
import java.nio.ByteBuffer;
import java.nio.IntBuffer;
import java.nio.LongBuffer;
import java.nio.ShortBuffer;
import javax.inject.Inject;
import javax.inject.Singleton;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.*;
import net.runelite.client.util.OSType;
import net.runelite.rlawt.AWTContext;
import org.lwjgl.BufferUtils;
import org.lwjgl.PointerBuffer;
import org.lwjgl.opencl.*;
import org.lwjgl.system.Configuration;
import org.lwjgl.system.MemoryStack;
import rs117.hd.HdPlugin;
import rs117.hd.HdPluginConfig;
import rs117.hd.opengl.shader.ShaderException;
import rs117.hd.opengl.shader.Template;
import rs117.hd.utils.buffer.GLBuffer;

import static org.lwjgl.opencl.APPLEGLSharing.*;
import static org.lwjgl.opencl.CL10.*;
import static org.lwjgl.opencl.CL10GL.*;
import static org.lwjgl.opencl.CL12.*;
import static org.lwjgl.opencl.KHRGLSharing.*;
import static org.lwjgl.system.MemoryUtil.NULL;
import static org.lwjgl.system.MemoryUtil.memASCII;
import static org.lwjgl.system.MemoryUtil.memUTF8;

@Singleton
@Slf4j
public class OpenCLManager {
	private static final String KERNEL_NAME_PASSTHROUGH = "passthroughModel";
	private static final String KERNEL_NAME_SORT = "sortModel";

	//  struct shared_data {
	//      int totalNum[12];
	//      int totalDistance[12];
	//      int totalMappedNum[18];
	//      int min10;
	//      int dfs[0];
	//  };
	private static final int SHARED_SIZE = 12 + 12 + 18 + 1; // in ints

	@Inject
	private HdPlugin plugin;

	@Inject
	private HdPluginConfig config;

	private boolean initialized;

	private long device;
	private long context;
	private long commandQueue;

	private long passthroughProgram;
	private long[] sortingPrograms;

	private long passthroughKernel;
	private long[] sortingKernels;

	private long tileHeightMap;

	static {
		Configuration.OPENCL_EXPLICIT_INIT.set(true);
	}

	public void startUp(AWTContext awtContext) {
		CL.create();
		initialized = true;

		if (OSType.getOSType() == OSType.MacOS) {
			initContextMacOS(awtContext);
		} else {
			initContext(awtContext);
		}
		log.debug("Device CL_DEVICE_MAX_WORK_GROUP_SIZE: {}", getMaxWorkGroupSize());
		initQueue();
	}

	public void shutDown() {
		if (!initialized)
			return;

		try {
			if (tileHeightMap != 0)
				clReleaseMemObject(tileHeightMap);
			tileHeightMap = 0;

			destroyPrograms();

			if (commandQueue != 0)
				clReleaseCommandQueue(commandQueue);
			commandQueue = 0;
			if (context != 0)
				clReleaseContext(context);
			context = 0;
			if (device != 0)
				clReleaseDevice(device);
			device = 0;
		} finally {
			CL.destroy();
			initialized = false;
		}
	}

	private void initContext(AWTContext awtContext) {
		try (var stack = MemoryStack.stackPush()) {
			IntBuffer pi = stack.mallocInt(1);
			checkCLError(clGetPlatformIDs(null, pi));
			if (pi.get(0) == 0)
				throw new RuntimeException("No OpenCL platforms found.");

			PointerBuffer platforms = stack.mallocPointer(pi.get(0));
			checkCLError(clGetPlatformIDs(platforms, (IntBuffer) null));

			PointerBuffer ctxProps = stack.mallocPointer(7);
			if (OSType.getOSType() == OSType.Windows) {
				ctxProps
					.put(CL_CONTEXT_PLATFORM)
					.put(0)
					.put(CL_GL_CONTEXT_KHR)
					.put(awtContext.getGLContext())
					.put(CL_WGL_HDC_KHR)
					.put(awtContext.getWGLHDC())
					.put(0)
					.flip();
			} else if (OSType.getOSType() == OSType.Linux) {
				ctxProps
					.put(CL_CONTEXT_PLATFORM)
					.put(0)
					.put(CL_GL_CONTEXT_KHR)
					.put(awtContext.getGLContext())
					.put(CL_GLX_DISPLAY_KHR)
					.put(awtContext.getGLXDisplay())
					.put(0)
					.flip();
			} else {
				throw new RuntimeException("unsupported platform");
			}

			if (platforms.limit() == 0)
				throw new RuntimeException("Unable to find compute platform");

			IntBuffer errcode_ret = stack.callocInt(1);
			for (int p = 0; p < platforms.limit(); p++) {
				try {
					long platform = platforms.get(p);
					ctxProps.put(1, platform);

					log.debug("Platform index {}:", p);
					log.debug("\tprofile: {}", getPlatformInfoStringUTF8(platform, CL_PLATFORM_PROFILE));
					log.debug("\tversion: {}", getPlatformInfoStringUTF8(platform, CL_PLATFORM_VERSION));
					log.debug("\tname: {}", getPlatformInfoStringUTF8(platform, CL_PLATFORM_NAME));
					log.debug("\tvendor: {}", getPlatformInfoStringUTF8(platform, CL_PLATFORM_VENDOR));
					log.debug("\textensions: {}", getPlatformInfoStringUTF8(platform, CL_PLATFORM_EXTENSIONS));

					int returnCode = clGetDeviceIDs(platform, CL_DEVICE_TYPE_ALL, null, pi);
					if (returnCode == CL_INVALID_DEVICE_TYPE) {
						log.debug("\tno devices");
						continue;
					}
					checkCLError(returnCode);

					PointerBuffer devices = stack.mallocPointer(pi.get(0));
					checkCLError(clGetDeviceIDs(platform, CL_DEVICE_TYPE_ALL, devices, (IntBuffer) null));

					for (int d = 0; d < devices.capacity(); d++) {
						long device = devices.get(d);
						long deviceType = getDeviceInfoLong(device, CL_DEVICE_TYPE);

						log.debug("\tdevice index {}:", d);
						log.debug("\t\tCL_DEVICE_NAME: {}", getDeviceInfoStringUTF8(device, CL_DEVICE_NAME));
						log.debug("\t\tCL_DEVICE_VENDOR: {}", getDeviceInfoStringUTF8(device, CL_DEVICE_VENDOR));
						log.debug("\t\tCL_DRIVER_VERSION: {}", getDeviceInfoStringUTF8(device, CL_DRIVER_VERSION));
						log.debug("\t\tCL_DEVICE_PROFILE: {}", getDeviceInfoStringUTF8(device, CL_DEVICE_PROFILE));
						log.debug("\t\tCL_DEVICE_VERSION: {}", getDeviceInfoStringUTF8(device, CL_DEVICE_VERSION));
						log.debug("\t\tCL_DEVICE_EXTENSIONS: {}", getDeviceInfoStringUTF8(device, CL_DEVICE_EXTENSIONS));
						log.debug("\t\tCL_DEVICE_TYPE: {}", deviceType);
						log.debug("\t\tCL_DEVICE_VENDOR_ID: {}", getDeviceInfoInt(device, CL_DEVICE_VENDOR_ID));
						log.debug("\t\tCL_DEVICE_MAX_COMPUTE_UNITS: {}", getDeviceInfoInt(device, CL_DEVICE_MAX_COMPUTE_UNITS));
						log.debug("\t\tCL_DEVICE_MAX_WORK_ITEM_DIMENSIONS: {}", getDeviceInfoInt(device, CL_DEVICE_MAX_WORK_ITEM_DIMENSIONS));
						log.debug("\t\tCL_DEVICE_MAX_WORK_GROUP_SIZE: {}", getDeviceInfoPointer(device, CL_DEVICE_MAX_WORK_GROUP_SIZE));
						log.debug("\t\tCL_DEVICE_MAX_CLOCK_FREQUENCY: {}", getDeviceInfoInt(device, CL_DEVICE_MAX_CLOCK_FREQUENCY));
						log.debug("\t\tCL_DEVICE_ADDRESS_BITS: {}", getDeviceInfoInt(device, CL_DEVICE_ADDRESS_BITS));
						log.debug("\t\tCL_DEVICE_AVAILABLE: {}", getDeviceInfoInt(device, CL_DEVICE_AVAILABLE) != 0);
						log.debug("\t\tCL_DEVICE_COMPILER_AVAILABLE: {}", (getDeviceInfoInt(device, CL_DEVICE_COMPILER_AVAILABLE) != 0));

						if (deviceType != CL_DEVICE_TYPE_GPU)
							continue;
						CLCapabilities platformCaps = CL.createPlatformCapabilities(platform);
						CLCapabilities deviceCaps = CL.createDeviceCapabilities(device, platformCaps);
						if (!deviceCaps.cl_khr_gl_sharing && !deviceCaps.cl_APPLE_gl_sharing)
							continue;

						if (this.context == 0) {
							try {
								var callback = CLContextCallback.create((errinfo, private_info, cb, user_data) ->
									log.error("[LWJGL] cl_context_callback: {}", memUTF8(errinfo)));
								long context = clCreateContext(ctxProps, device, callback, NULL, errcode_ret);
								checkCLError(errcode_ret);

								this.device = device;
								this.context = context;
							} catch (Exception ex) {
								log.error("Error while creating context:", ex);
							}
						}
					}
				} catch (Exception ex) {
					log.error("Error while checking platform:", ex);
				}
			}

			if (this.context == 0)
				throw new RuntimeException("Unable to create suitable compute context");
		}
	}

	private void initContextMacOS(AWTContext awtContext) {
		try (var stack = MemoryStack.stackPush()) {
			PointerBuffer ctxProps = stack.mallocPointer(3);
			ctxProps
				.put(APPLEGLSharing.CL_CONTEXT_PROPERTY_USE_CGL_SHAREGROUP_APPLE)
				.put(awtContext.getCGLShareGroup())
				.put(0)
				.flip();

			IntBuffer errcode_ret = stack.callocInt(1);
			var devices = stack.mallocPointer(0);
			long context = clCreateContext(ctxProps, devices, CLContextCallback.create((errinfo, private_info, cb, user_data) ->
				log.error("[LWJGL] cl_context_callback: {}", memUTF8(errinfo))), NULL, errcode_ret);
			checkCLError(errcode_ret);

			var deviceBuf = stack.mallocPointer(1);
			checkCLError(clGetGLContextInfoAPPLE(
				context,
				awtContext.getGLContext(),
				CL_CGL_DEVICE_FOR_CURRENT_VIRTUAL_SCREEN_APPLE,
				deviceBuf,
				null
			));
			long device = deviceBuf.get(0);

			log.debug("Got macOS CLGL compute device {}", device);
			this.context = context;
			this.device = device;
		}
	}

	public int getMaxWorkGroupSize() {
		long[] maxWorkGroupSize = new long[1];
		clGetDeviceInfo(device, CL_DEVICE_MAX_WORK_GROUP_SIZE, maxWorkGroupSize, null);
		return (int) maxWorkGroupSize[0];
	}

	private void initQueue() {
		long[] l = new long[1];
		clGetDeviceInfo(device, CL_DEVICE_QUEUE_PROPERTIES, l, null);

		commandQueue = clCreateCommandQueue(context, device, l[0] & CL_QUEUE_OUT_OF_ORDER_EXEC_MODE_ENABLE, (int[]) null);
		log.debug("Created command_queue {}, properties {}", commandQueue, l[0] & CL_QUEUE_OUT_OF_ORDER_EXEC_MODE_ENABLE);
	}

	private long compileProgram(MemoryStack stack, String programSource) throws ShaderException {
		log.trace("Compiling program:\n {}", programSource);
		IntBuffer errcode_ret = stack.callocInt(1);
		long program = clCreateProgramWithSource(context, programSource, errcode_ret);
		checkCLError(errcode_ret);

		int err = clBuildProgram(program, device, "", null, 0);
		if (err != CL_SUCCESS)
			throw new ShaderException(getProgramBuildInfoStringASCII(program, device, CL_PROGRAM_BUILD_LOG));

		log.debug("Build status: {}", getProgramBuildInfoInt(program, device, CL_PROGRAM_BUILD_STATUS));
		log.debug("Binary type: {}", getProgramBuildInfoInt(program, device, CL_PROGRAM_BINARY_TYPE));
		log.debug("Build options: {}", getProgramBuildInfoStringASCII(program, device, CL_PROGRAM_BUILD_OPTIONS));
		log.debug("Build log: {}", getProgramBuildInfoStringASCII(program, device, CL_PROGRAM_BUILD_LOG));
		return program;
	}

	private long getKernel(MemoryStack stack, long program, String kernelName) {
		IntBuffer errcode_ret = stack.callocInt(1);
		long kernel = clCreateKernel(program, kernelName, errcode_ret);
		checkCLError(errcode_ret);
		log.debug("Loaded kernel {} for program {}", kernelName, program);
		return kernel;
	}

	public void initPrograms() throws ShaderException, IOException {
		try (var stack = MemoryStack.stackPush()) {
			var template = new Template()
				.define("UNDO_VANILLA_SHADING", plugin.configUndoVanillaShading)
				.define("LEGACY_GREY_COLORS", plugin.configLegacyGreyColors)
				.addIncludePath(OpenCLManager.class);
			passthroughProgram = compileProgram(stack, template.load("comp_unordered.cl"));
			passthroughKernel = getKernel(stack, passthroughProgram, KERNEL_NAME_PASSTHROUGH);

			sortingPrograms = new long[plugin.numSortingBins];
			sortingKernels = new long[plugin.numSortingBins];
			for (int i = 0; i < plugin.numSortingBins; i++) {
				int faceCount = plugin.modelSortingBinFaceCounts[i];
				int threadCount = plugin.modelSortingBinThreadCounts[i];
				int facesPerThread = (int) Math.ceil((float) faceCount / threadCount);
				sortingPrograms[i] = compileProgram(stack, template
					.copy()
					.define("THREAD_COUNT", threadCount)
					.define("FACES_PER_THREAD", facesPerThread)
					.load("comp.cl")
				);
				sortingKernels[i] = getKernel(stack, sortingPrograms[i], KERNEL_NAME_SORT);
			}
		}
	}

	public void destroyPrograms() {
		if (passthroughKernel != 0)
			clReleaseKernel(passthroughKernel);
		passthroughKernel = 0;

		if (passthroughProgram != 0)
			clReleaseProgram(passthroughProgram);
		passthroughProgram = 0;

		if (sortingKernels != null)
			for (var kernel : sortingKernels)
				if (kernel != 0)
					clReleaseKernel(kernel);
		sortingKernels = null;

		if (sortingPrograms != null)
			for (var program : sortingPrograms)
				if (program != 0)
					clReleaseProgram(program);
		sortingPrograms = null;
	}

	public void uploadTileHeights(Scene scene) {
		if (tileHeightMap != 0)
			clReleaseMemObject(tileHeightMap);
		tileHeightMap = 0;

		final int TILEHEIGHT_BUFFER_SIZE = Constants.MAX_Z * Constants.EXTENDED_SCENE_SIZE * Constants.EXTENDED_SCENE_SIZE * Short.BYTES;
		ShortBuffer tileBuffer = BufferUtils.createShortBuffer(TILEHEIGHT_BUFFER_SIZE);
		int[][][] tileHeights = scene.getTileHeights();
		for (int z = 0; z < Constants.MAX_Z; ++z) {
			for (int y = 0; y < Constants.EXTENDED_SCENE_SIZE; ++y) {
				for (int x = 0; x < Constants.EXTENDED_SCENE_SIZE; ++x) {
					int h = tileHeights[z][x][y];
					assert (h & 0b111) == 0;
					h >>= 3;
					tileBuffer.put((short) h);
				}
			}
		}
		tileBuffer.flip();

		try (MemoryStack stack = MemoryStack.stackPush()) {
			CLImageFormat imageFormat = CLImageFormat.calloc(stack);
			imageFormat.image_channel_order(CL_R);
			imageFormat.image_channel_data_type(CL_SIGNED_INT16);

			IntBuffer errcode_ret = stack.callocInt(1);
			tileHeightMap = clCreateImage3D(context, CL_MEM_READ_ONLY | CL_MEM_COPY_HOST_PTR, imageFormat,
				Constants.EXTENDED_SCENE_SIZE, Constants.EXTENDED_SCENE_SIZE, Constants.MAX_Z,
				0L, 0L,
				tileBuffer,
				errcode_ret
			);
			checkCLError(errcode_ret);
		}
	}

	public void compute(
		GLBuffer uniformBufferCamera,
		int numPassthroughModels, int[] numSortingBinModels,
		GLBuffer modelPassthroughBuffer, GLBuffer[] modelSortingBuffers,
		GLBuffer stagingBufferVertices, GLBuffer stagingBufferUvs, GLBuffer stagingBufferNormals,
		GLBuffer renderBufferVertices, GLBuffer renderBufferUvs, GLBuffer renderBufferNormals
	) {
		try (var stack = MemoryStack.stackPush()) {
			PointerBuffer glBuffers = stack.mallocPointer(8 + modelSortingBuffers.length)
				.put(uniformBufferCamera.clBuffer)
				.put(modelPassthroughBuffer.clBuffer)
				.put(stagingBufferVertices.clBuffer)
				.put(stagingBufferUvs.clBuffer)
				.put(stagingBufferNormals.clBuffer)
				.put(renderBufferVertices.clBuffer)
				.put(renderBufferUvs.clBuffer)
				.put(renderBufferNormals.clBuffer);
			for (var buffer : modelSortingBuffers)
				glBuffers.put(buffer.clBuffer);
			glBuffers.flip();

			PointerBuffer acquireEvent = stack.mallocPointer(1);
			CL10GL.clEnqueueAcquireGLObjects(commandQueue, glBuffers, null, acquireEvent);

			PointerBuffer computeEvents = stack.mallocPointer(1 + modelSortingBuffers.length);
			if (numPassthroughModels > 0) {
				clSetKernelArg1p(passthroughKernel, 0, modelPassthroughBuffer.clBuffer);
				clSetKernelArg1p(passthroughKernel, 1, stagingBufferVertices.clBuffer);
				clSetKernelArg1p(passthroughKernel, 2, stagingBufferUvs.clBuffer);
				clSetKernelArg1p(passthroughKernel, 3, stagingBufferNormals.clBuffer);
				clSetKernelArg1p(passthroughKernel, 4, renderBufferVertices.clBuffer);
				clSetKernelArg1p(passthroughKernel, 5, renderBufferUvs.clBuffer);
				clSetKernelArg1p(passthroughKernel, 6, renderBufferNormals.clBuffer);

				// queue compute call after acquireGLBuffers
				clEnqueueNDRangeKernel(commandQueue, passthroughKernel, 1, null,
					stack.pointers(numPassthroughModels * 6L), stack.pointers(6),
					acquireEvent, computeEvents
				);
				computeEvents.position(computeEvents.position() + 1);
			}

			for (int i = 0; i < numSortingBinModels.length; i++) {
				int numModels = numSortingBinModels[i];
				if (numModels == 0)
					continue;

				int faceCount = plugin.modelSortingBinFaceCounts[i];
				int threadCount = plugin.modelSortingBinThreadCounts[i];
				long kernel = sortingKernels[i];

				clSetKernelArg(kernel, 0, (long) (SHARED_SIZE + faceCount) * Integer.BYTES);
				clSetKernelArg1p(kernel, 1, modelSortingBuffers[i].clBuffer);
				clSetKernelArg1p(kernel, 2, stagingBufferVertices.clBuffer);
				clSetKernelArg1p(kernel, 3, stagingBufferUvs.clBuffer);
				clSetKernelArg1p(kernel, 4, stagingBufferNormals.clBuffer);
				clSetKernelArg1p(kernel, 5, renderBufferVertices.clBuffer);
				clSetKernelArg1p(kernel, 6, renderBufferUvs.clBuffer);
				clSetKernelArg1p(kernel, 7, renderBufferNormals.clBuffer);
				clSetKernelArg1p(kernel, 8, uniformBufferCamera.clBuffer);
				clSetKernelArg1p(kernel, 9, tileHeightMap);

				clEnqueueNDRangeKernel(commandQueue, kernel, 1, null,
					stack.pointers((long) numModels * threadCount),
					stack.pointers(threadCount),
					acquireEvent, computeEvents
				);
				computeEvents.position(computeEvents.position() + 1);
			}

			if (computeEvents.position() == 0) {
				CL10GL.clEnqueueReleaseGLObjects(commandQueue, glBuffers, null, null);
			} else {
				computeEvents.flip();
				CL10GL.clEnqueueReleaseGLObjects(commandQueue, glBuffers, computeEvents, null);
			}
		}
	}

	public void finish() {
		if (commandQueue != 0)
			clFinish(commandQueue);
	}

	private static String getPlatformInfoStringUTF8(long cl_platform_id, int param_name) {
		try (var stack = MemoryStack.stackPush()) {
			PointerBuffer pp = stack.mallocPointer(1);
			checkCLError(clGetPlatformInfo(cl_platform_id, param_name, (ByteBuffer) null, pp));
			int bytes = (int) pp.get(0);

			ByteBuffer buffer = stack.malloc(bytes);
			checkCLError(clGetPlatformInfo(cl_platform_id, param_name, buffer, null));

			return memUTF8(buffer, bytes - 1);
		}
	}

	private static long getDeviceInfoLong(long cl_device_id, int param_name) {
		try (var stack = MemoryStack.stackPush()) {
			LongBuffer pl = stack.mallocLong(1);
			checkCLError(clGetDeviceInfo(cl_device_id, param_name, pl, null));
			return pl.get(0);
		}
	}

	private static int getDeviceInfoInt(long cl_device_id, int param_name) {
		try (var stack = MemoryStack.stackPush()) {
			IntBuffer pl = stack.mallocInt(1);
			checkCLError(clGetDeviceInfo(cl_device_id, param_name, pl, null));
			return pl.get(0);
		}
	}

	private static long getDeviceInfoPointer(long cl_device_id, int param_name) {
		try (var stack = MemoryStack.stackPush()) {
			PointerBuffer pp = stack.mallocPointer(1);
			checkCLError(clGetDeviceInfo(cl_device_id, param_name, pp, null));
			return pp.get(0);
		}
	}

	private static String getDeviceInfoStringUTF8(long cl_device_id, int param_name) {
		try (var stack = MemoryStack.stackPush()) {
			PointerBuffer pp = stack.mallocPointer(1);
			checkCLError(clGetDeviceInfo(cl_device_id, param_name, (ByteBuffer) null, pp));
			int bytes = (int) pp.get(0);

			ByteBuffer buffer = stack.malloc(bytes);
			checkCLError(clGetDeviceInfo(cl_device_id, param_name, buffer, null));

			return memUTF8(buffer, bytes - 1);
		}
	}

	private static int getProgramBuildInfoInt(long cl_program_id, long cl_device_id, int param_name) {
		try (var stack = MemoryStack.stackPush()) {
			IntBuffer pl = stack.mallocInt(1);
			checkCLError(clGetProgramBuildInfo(cl_program_id, cl_device_id, param_name, pl, null));
			return pl.get(0);
		}
	}

	private static String getProgramBuildInfoStringASCII(long cl_program_id, long cl_device_id, int param_name) {
		try (var stack = MemoryStack.stackPush()) {
			PointerBuffer pp = stack.mallocPointer(1);
			checkCLError(clGetProgramBuildInfo(cl_program_id, cl_device_id, param_name, (ByteBuffer) null, pp));
			int bytes = (int) pp.get(0);

			ByteBuffer buffer = stack.malloc(bytes);
			checkCLError(clGetProgramBuildInfo(cl_program_id, cl_device_id, param_name, buffer, null));

			return memASCII(buffer, bytes - 1);
		}
	}

	private static void checkCLError(IntBuffer errcode) {
		checkCLError(errcode.get(errcode.position()));
	}

	private static void checkCLError(int errcode) {
		if (errcode != CL_SUCCESS)
			throw new RuntimeException(String.format("OpenCL error [%d]", errcode));
	}

	public void recreateCLBuffer(GLBuffer glBuffer, long clFlags) {
		// cleanup previous buffer
		if (glBuffer.clBuffer != 0)
			clReleaseMemObject(glBuffer.clBuffer);

		// allocate new
		if (glBuffer.size == 0) {
			// opencl does not allow 0-size gl buffers, it will segfault on macOS
			glBuffer.clBuffer = 0;
		} else {
			assert glBuffer.size > 0 : "Size <= 0 should not reach this point";
			glBuffer.clBuffer = clCreateFromGLBuffer(context, clFlags, glBuffer.glBufferId, (IntBuffer) null);
		}
	}
}

package rs117.hd.opengl.compute;

public enum ComputeMode
{
    OPENGL,
    OPENCL,
}
/*
 * Copyright (c) 2018, Adam <Adam@sigterm.info>
 * Copyright (c) 2020 Abex
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package rs117.hd.opengl.shader;

import com.google.common.annotations.VisibleForTesting;
import java.io.IOException;
import java.nio.ByteBuffer;
import java.util.ArrayList;
import java.util.List;
import java.util.stream.Collectors;
import lombok.Getter;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.lwjgl.BufferUtils;
import rs117.hd.utils.Props;
import rs117.hd.utils.ResourcePath;

import static org.lwjgl.opengl.GL43C.*;
import static rs117.hd.utils.ResourcePath.path;

@Slf4j
public class Shader
{
	public static final boolean DUMP_SHADERS = Props.has("rlhd.dump-shaders");

	@VisibleForTesting
	final List<Unit> units = new ArrayList<>();

	@RequiredArgsConstructor
	@VisibleForTesting
	static class Unit
	{
		@Getter
		public final int type;

		@Getter
		public final String filename;
	}

	public Shader add(int type, String name)
	{
		units.add(new Unit(type, name));
		return this;
	}

	public int compile(Template template) throws ShaderException, IOException
	{
		int program = glCreateProgram();
		int[] shaders = new int[units.size()];
		int i = 0;
		boolean ok = false;

		ResourcePath dumpPath = null;
		if (DUMP_SHADERS)
			dumpPath = path("shader-dumps").mkdirs();

		try
		{
			while (i < shaders.length) {
				Unit unit = units.get(i);
				int shader = glCreateShader(unit.type);
				if (shader == 0) {
					throw new ShaderException("Unable to create shader of type " + unit.type);
				}

				String source = template.load(unit.filename);
				if (DUMP_SHADERS)
					dumpPath.resolve(unit.filename).writeString(source);

				glShaderSource(shader, source);
				glCompileShader(shader);

				if (glGetShaderi(shader, GL_COMPILE_STATUS) != GL_TRUE)
				{
					String err = glGetShaderInfoLog(shader);
					glDeleteShader(shader);
					throw ShaderException.compileError(err, template, unit);
				}

				glAttachShader(program, shader);
				shaders[i++] = shader;
			}

			glLinkProgram(program);

			if (glGetProgrami(program, GL_LINK_STATUS) == GL_FALSE)
			{
				String err = glGetProgramInfoLog(program);
				throw ShaderException.compileError(err, template, units.toArray(new Unit[0]));
			}

			ok = true;

			if (DUMP_SHADERS) {
				int[] numFormats = { 0 };
				glGetIntegerv(GL_NUM_PROGRAM_BINARY_FORMATS, numFormats);
				if (numFormats[0] < 1) {
					log.error("OpenGL driver does not support any binary formats");
				} else {
					int[] size = { 0 };
					glGetProgramiv(program, GL_PROGRAM_BINARY_LENGTH, size);

					int[] format = { 0 };
					ByteBuffer binary = BufferUtils.createByteBuffer(size[0]);
					glGetProgramBinary(program, size, format, binary);

					String shaderName =
						units.stream()
							.map(Unit::getFilename)
							.collect(Collectors.joining(" + ")) + ".bin";
					dumpPath.resolve(shaderName).writeByteBuffer(binary);
				}
			}
		}
		finally
		{
			while (i > 0)
			{
				int shader = shaders[--i];
				glDetachShader(program, shader);
				glDeleteShader(shader);
			}

			if (!ok)
			{
				glDeleteProgram(program);
			}
		}

		return program;
	}
}

/*
 * Copyright (c) 2018, Adam <Adam@sigterm.info>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package rs117.hd.opengl.shader;

import java.util.Arrays;
import java.util.Collections;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.stream.Collectors;
import lombok.extern.slf4j.Slf4j;

@Slf4j
public class ShaderException extends Exception
{
	private static final Pattern NVIDIA_ERROR_REGEX = Pattern.compile("^(\\d+)\\((\\d+)\\) : (.*)$", Pattern.MULTILINE);

	public static ShaderException compileError(String error, Template template, Shader.Unit ...units)
	{
		StringBuilder sb = new StringBuilder();
		if (template.includeType == Template.IncludeType.GLSL) {
			Matcher m = NVIDIA_ERROR_REGEX.matcher(error);
			if (m.find()) {
				try {
					sb.append(String.format("Compile error when compiling shader%s: %s\n",
						units.length == 1 ? "" : "s",
						Arrays.stream(units)
							.map(u -> u.filename)
							.collect(Collectors.joining(", "))));

					int offset = 0;
					do {
						if (m.start() > offset)
							sb.append(error, offset, m.start());
						offset = m.end();

						int index = Integer.parseInt(m.group(1));
						int lineNumber = Integer.parseInt(m.group(2));
						String errorString = m.group(3);
						String include = template.includeList.get(index);
						sb.append(String.format(
							"%s line %d - %s",
							include, lineNumber, errorString));
					} while (m.find());
				} catch (Exception ex) {
					log.error("Error while parsing shader compilation error:", ex);
				}
			}
			else
			{
				// Unknown error format, so include a mapping from source file index to filename
				sb
					.append("Compile error while compiling shader")
					.append(units.length == 1 ? "" : "s")
					.append(": ")
					.append(Arrays.stream(units)
						.map(u -> u.filename)
						.collect(Collectors.joining(", ")))
					.append("\n")
					.append(error)
					.append("Included sources: [\n");
				for (int j = 0; j < template.includeList.size(); j++) {
					String s = String.valueOf(j);
					sb
						.append("  ")
						.append(String.join("", Collections.nCopies( // Left pad
							1 + (int) Math.log10(template.includeList.size()) - s.length(), " ")))
						.append(s)
						.append(": ")
						.append(template.includeList.get(j))
						.append("\n");
				}
				sb.append("]");
			}
		}

		return new ShaderException(sb.toString());
	}

	public ShaderException(String message)
	{
		super(message);
	}
}

/*
 * Copyright (c) 2018, Adam <Adam@sigterm.info>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package rs117.hd.opengl.shader;

import java.io.IOException;
import java.util.ArrayList;
import java.util.List;
import java.util.Stack;
import java.util.function.Supplier;
import lombok.extern.slf4j.Slf4j;
import rs117.hd.utils.ResourcePath;

@Slf4j
public class Template
{
	enum IncludeType { GLSL, C, UNKNOWN }

	@FunctionalInterface
	public interface IncludeLoader
	{
		String load(String path) throws IOException;
	}

	private final List<IncludeLoader> loaders = new ArrayList<>();

	IncludeType includeType = IncludeType.UNKNOWN;
	final Stack<Integer> includeStack = new Stack<>();
	final ArrayList<String> includeList = new ArrayList<>();

	public Template copy()
	{
		var clone = new Template();
		clone.loaders.addAll(this.loaders);
		return clone;
	}

	public String process(String str) throws IOException
	{
		StringBuilder sb = new StringBuilder();
		int lineCount = 0;
		for (String line : str.split("\r?\n"))
		{
			lineCount++;
			String trimmed = line.trim();
			if (trimmed.startsWith("#include "))
			{
				int currentIndex = includeStack.peek();
				String currentFile = includeList.get(currentIndex);

				String includeFile = trimmed.substring(9);
				int includeIndex = includeList.size();
				includeList.add(includeFile);
				includeStack.push(includeIndex);
				String includeContents = loadInternal(includeFile);
				includeStack.pop();

				int nextLineOffset = 1;
				if (Shader.DUMP_SHADERS) {
					sb.append("// Including ").append(includeFile).append('\n');
					nextLineOffset = 0;
				}

				switch (includeType)
				{
					case GLSL:
						if (includeContents.trim().startsWith("#version "))
						{
							// In GLSL, no preprocessor directive can precede #version, so handle included files
							// starting with a #version directive differently.
							sb.append(includeContents);
						}
						else
						{
							// In GLSL, the #line directive takes a line number and a source file index, which we map to
							// an include-filename through tracking the list of includes.
							// Source: https://www.khronos.org/opengl/wiki/Core_Language_(GLSL)#.23line_directive
							sb
								.append("#line 1 ") // Mark the first line of the included file
								.append(includeIndex)
								.append("\n")
								.append(includeContents)
								.append("#line ") // Return to the next line of the current file
								.append(lineCount + nextLineOffset)
								.append(" ")
								.append(currentIndex)
								.append("\n");
						}
						break;
					case C:
						// In C, #line followed by a line number sets the line number for the current file, while
						// #line followed by a line number and a string constant filename changes the line number and
						// current filename being processed, so in our case we will only be using the latter.
						// Source: https://gcc.gnu.org/onlinedocs/cpp/Line-Control.html
						sb
							.append("#line 1 \"") // Change to line 1 in the included file
							.append(includeFile)
							.append("\"\n")
							.append(includeContents)
							.append("#line ") // Return to the next line in the parent include
							.append(lineCount + nextLineOffset)
							.append(" \"")
							.append(currentFile)
							.append("\"\n");
						break;
					default:
						sb.append(includeContents);
						break;
				}

				if (Shader.DUMP_SHADERS)
					sb.append("// End include of ").append(includeFile).append('\n');
			}
			else if (trimmed.startsWith("#pragma once"))
			{
				int currentIndex = includeList.size() - 1;
				String currentInclude = includeList.get(currentIndex);
				if (includeList.indexOf(currentInclude) != currentIndex) {
					sb.append("// #pragma once - already included\n");
					break;
				} else {
					sb.append("// #pragma once - first include\n");
				}
			}
			else
			{
				sb.append(line).append('\n');
			}
		}
		return sb.toString();
	}

	private String loadInternal(String path) throws IOException
	{
		for (var loader : loaders)
		{
			String value = loader.load(path);
			if (value != null)
			{
				return process(value);
			}
		}

		return "";
	}

	public String load(String filename) throws IOException
	{
		includeList.clear();
		includeList.add(filename);
		includeStack.add(0);

		switch (ResourcePath.path(filename).getExtension().toLowerCase())
		{
			case "glsl":
				includeType = IncludeType.GLSL;
				break;
			case "c":
			case "h":
			case "cl":
				includeType = IncludeType.C;
				break;
			default:
				includeType = IncludeType.UNKNOWN;
				break;
		}

		return loadInternal(filename);
	}

	public Template addIncludeLoader(IncludeLoader resolver)
	{
		loaders.add(resolver);
		return this;
	}

	public Template addIncludePath(Class<?> clazz)
	{
		return addIncludePath(ResourcePath.path(clazz));
	}

	public Template addIncludePath(ResourcePath includePath)
	{
		return addIncludeLoader(path -> {
			ResourcePath resolved = includePath.resolve(path);
			if (resolved.exists())
				return resolved.loadString();
			return null;
		});
	}

	public Template addInclude(String identifier, String value)
	{
		return addIncludeLoader(key -> key.equals(identifier) ? value : null);
	}

	public Template define(String identifier, String value)
	{
		return addIncludeLoader(key ->
			key.equals(identifier) ? String.format("#define %s %s", identifier, value) : null);
	}

	public Template define(String identifier, boolean value)
	{
		return addIncludeLoader(key ->
			key.equals(identifier) ? String.format("#define %s %d", identifier, value ? 1 : 0) : null);
	}

	public Template define(String identifier, int value)
	{
		return addIncludeLoader(key ->
			key.equals(identifier) ? String.format("#define %s %d", identifier, value) : null);
	}

	public Template define(String identifier, double value)
	{
		return addIncludeLoader(key ->
			key.equals(identifier) ? String.format("#define %s %f", identifier, value) : null);
	}

	public Template define(String identifier, Enum<?> enumValue)
	{
		return addIncludeLoader(key ->
			key.equals(identifier) ? String.format("#define %s %d", identifier, enumValue.ordinal()) : null);
	}

	public Template define(String identifier, Supplier<String> supplier)
	{
		return addIncludeLoader(key -> key.equals(identifier) ? supplier.get() : null);
	}
}

package rs117.hd.utils;

import junit.framework.TestCase;
import org.junit.Assert;

public class Mat4Test extends TestCase {
	public void testTranspose() {
		float[] m = {
			1, 2, 3, 4,
			5, 6, 7, 8,
			9, 10, 11, 12,
			13, 14, 15, 16
		};
		System.out.println(Mat4.format(m));
		Mat4.transpose(m);
		System.out.println("\n" + Mat4.format(m));
	}

	public void testInverse() {
		float[] nonInvertible = {
			1, -2, 0, 2,
			-1, 3, 1, -2,
			-1, 5, 3, -2,
			0, 7, 7, 0
		};
		Mat4.transpose(nonInvertible);
		Assert.assertThrows(IllegalArgumentException.class, () -> Mat4.inverse(nonInvertible));

		String identity = Mat4.format(Mat4.identity());

		float[] invertible = {
			0, 0, -1, 2,
			0, 1, 0, 0,
			9, 0, 0, 0,
			0, 0, 0, 1
		};
		Mat4.transpose(invertible);
		float[] inverse = Mat4.inverse(invertible);
		Mat4.mul(inverse, invertible);
		Assert.assertEquals(identity, Mat4.format(inverse));

		invertible = new float[] {
			4, 0, 0, 0,
			0, 0, 2, 0,
			0, 1, 2, 0,
			1, 0, 0, 1
		};
		Mat4.transpose(invertible);
		inverse = Mat4.inverse(invertible);
		Mat4.mul(inverse, invertible);
		Assert.assertEquals(identity, Mat4.format(inverse));
	}
}

package rs117.hd.utils;

import java.util.HashMap;
import java.util.LinkedHashMap;
import java.util.Map;
import org.junit.Assert;
import rs117.hd.config.SeasonalTheme;

import static rs117.hd.utils.ExpressionParser.parseExpression;
import static rs117.hd.utils.ExpressionParser.parseFunction;
import static rs117.hd.utils.ExpressionParser.parsePredicate;

public class ExpressionParserTest {
	public static void main(String... args) {
		Map<String, Object> constants = new HashMap<>();
		Enum<?>[][] enums = {
			SeasonalTheme.values()
		};
		for (var anEnum : enums)
			for (var e : anEnum)
				constants.put(e.name(), e.ordinal());

		VariableSupplier vars = name -> {
			switch (name) {
				case "h":
					return 5;
				case "s":
					return 10;
				case "l":
					return 5;
				case "blending":
					return true;
				case "textures":
					return false;
			}
			return null;
		};

		Assert.assertEquals(5.f, parseExpression("5"));
		Assert.assertEquals(-5.f, parseExpression("-5"));
		Assert.assertEquals(-2.5f, parseExpression("-2.5"));
		Assert.assertEquals(-.5f, parseExpression("-0.5"));
		Assert.assertEquals(-.5f, parseExpression("-.5"));
		Assert.assertEquals(.5f, parseExpression(".5"));
		Assert.assertEquals(.5f, parseExpression("+.5"));
		Assert.assertEquals(.5f, parseExpression("++ +.5"));
		Assert.assertEquals(1f, parseExpression("--1"));
		Assert.assertEquals(.5f, parseExpression("+-++-.5"));
		Assert.assertEquals(17.f, parseFunction("5 + 12").apply(null));
		Assert.assertEquals(16.f, parseExpression("8 / 2 * (2 + 2)"));
		Assert.assertEquals(32.f, parseExpression("2 * 8 / 2 * (2 + 2)"));
		Assert.assertEquals(3.f, parseExpression("2 * 3 / 2"));
		Assert.assertEquals(0.f, parseExpression("2 * 8 - 4 * 4"));
		Assert.assertEquals(29.f, parseExpression("2 + 3 * (8 + 5 / 5)"));
		Assert.assertEquals(40.f, parseExpression("(8 - 1 + 3) * 6 - ((3 + 7) * 2)"));
		Assert.assertEquals(21.f, parseExpression("(1 + 2) * (3 + 4)"));
		Assert.assertFalse(parsePredicate("!( blending )").test(vars));
		Assert.assertEquals(false, parseExpression("!true"));
		Assert.assertEquals(true, parseExpression("SUMMER == 1", constants));

		System.out.println("Intentional errors:");
		assertThrows(() -> parseExpression("unexpected ( indeed"));
		assertThrows(() -> parseExpression("(5 + ( missing paren)"));

		LinkedHashMap<String, Boolean> testCases = new LinkedHashMap<>();
		testCases.put("h != 0", true);
		testCases.put("s == 0 || h <= 10 && s < 2", false);
		testCases.put("h == 8 && (s == 3 || s == 4) && l >= 20", false);
		testCases.put("h > 3 && s < 15 && l < 21", true);
		testCases.put("h < 3 && s < 15 && l < 21", false);
		testCases.put("h > 3 && (s < 9 || l < 19)", true);
		testCases.put("h == 5 ? s > 3 : s > 15", true);
		testCases.put("h == s || h == l", true);
		testCases.put("blending || textures", true);

		for (var entry : testCases.entrySet()) {
			var predicate = parsePredicate(entry.getKey());
			var result = predicate.test(vars);
			var passed = entry.getValue() == result;
			System.out.println(
				(passed ? "\u001B[32m" : "\u001B[31m") +
				"Case: " + entry.getKey() + " " + (passed ? "passed" : "failed") + ". Expected: " + entry.getValue() + ", got: " + result);
		}
	}

	private static void assertThrows(Runnable runnable) {
		try {
			runnable.run();
		} catch (Throwable ex) {
			System.out.println(ex);
			return;
		}
		Assert.fail("Didn't throw an exception");
	}
}

package rs117.hd.utils;

import junit.framework.TestCase;

public class MatrixTest extends TestCase {
	public void testSolve() {
		float[] invertible = {
			0, 0, -1, 2,
			0, 1, 0, 0,
			9, 0, 0, 0,
			0, 0, 0, 1
		};
		System.out.println(Matrix.format(invertible, 4, 4));
		Matrix.solve(invertible, 4, 4);
		System.out.println(Matrix.format(invertible, 4, 4));

		float[] linearSystem = {
			-1382.59f, -1, 0, 0.11f,
			1180.23f, 0, 661.96f, 0.08f,
			661.96f, 0, -1180.23f, -0.11f
		};
		System.out.println(Matrix.format(linearSystem, 3, 4));
		Matrix.solve(linearSystem, 3, 4);
		System.out.println(Matrix.format(linearSystem, 3, 4));
	}
}

package rs117.hd.utils;

import java.util.Arrays;
import org.junit.Test;

import static junit.framework.TestCase.assertEquals;
import static rs117.hd.utils.ColorUtils.linearToSrgb;
import static rs117.hd.utils.ColorUtils.packHsl;
import static rs117.hd.utils.ColorUtils.srgbToLinear;
import static rs117.hd.utils.ColorUtils.srgbToPackedHsl;
import static rs117.hd.utils.ColorUtils.unpackHsl;

public class ColorUtilsTest {
	@Test
	public void testJagexHslPacking() {
		float[] hsl;
		for (int counter = 0; (counter & ~0xFFFF) == 0; counter++) {
			int packedHslBefore = counter;
			hsl = unpackHsl(packedHslBefore);
			// Zero saturation or min/max lightness yield the same color
			if (hsl[1] <= .0625f || hsl[2] == 0 || hsl[2] >= 127f / 128) {
				hsl[0] = .0078125f;
				hsl[1] = .0625f;
				packedHslBefore = packHsl(hsl);
			}

			float[] srgbBefore = ColorUtils.packedHslToSrgb(packedHslBefore);
			float[] srgbAfter = linearToSrgb(srgbToLinear(srgbBefore));

			int packedHslAfter = srgbToPackedHsl(srgbAfter);
			if (packedHslBefore != packedHslAfter) {
				assertEquals(String.format(
					"Inaccurate color, packedHsl: %d\t->\t%d,\tHSL: %s\t->\t%s,\tRGB: %s\t->\t%s\n",
					packedHslBefore,
					packedHslAfter,
					Arrays.toString(hsl),
					Arrays.toString(unpackHsl(packedHslAfter)),
					Arrays.toString(srgbBefore),
					Arrays.toString(srgbAfter)
				), packedHslBefore, packedHslAfter);
			}
		}
	}
}

package rs117.hd.utils;

import org.junit.Assert;
import org.junit.Test;

public class AABBTest {
	@Test
	public void testRegionBox() {
		Assert.assertEquals(new AABB(3264, 5120, 3327, 5759), AABB.regionBox(13136, 13145));
		Assert.assertEquals(new AABB(3264, 5120, 3327, 5759), AABB.regionBox(13145, 13136));
		Assert.assertEquals(new AABB(3392, 5760, 3519, 5951), AABB.regionBox(13658, 13916));
	}

	@Test
	public void testRegion() {
		Assert.assertEquals(new AABB(3264, 5696, 3327, 5759), new AABB(13145));
	}
}

package rs117.hd;

import java.io.InputStream;
import java.util.Properties;
import lombok.extern.slf4j.Slf4j;
import net.runelite.client.RuneLite;
import net.runelite.client.RuneLiteProperties;
import net.runelite.client.externalplugins.ExternalPluginManager;
import rs117.hd.utils.Props;

@SuppressWarnings("unchecked")
@Slf4j
public class HdPluginTest
{
	public static void main(String[] args) throws Exception
	{
		Props.DEVELOPMENT = true;
		Props.set("rlhd.resource-path", "src/main/resources");
		ClassLoader.getSystemClassLoader().setDefaultAssertionStatus(true);
		useLatestPluginHub();
		ExternalPluginManager.loadBuiltin(HdPlugin.class);
		RuneLite.main(args);
	}

	private static void useLatestPluginHub()
	{
		if (System.getProperty("runelite.pluginhub.version") == null)
		{
			try
			{
				Properties props = new Properties();
				try (InputStream in = RuneLiteProperties.class.getResourceAsStream("runelite.properties"))
				{
					props.load(in);
				}

				String version = props.getProperty("runelite.pluginhub.version");
				String[] parts = version.split("[.-]");
				if (parts.length > 3 && parts[3].equals("SNAPSHOT"))
				{
					int patch = Integer.parseInt(parts[2]) - 1;
					version = parts[0] + "." + parts[1] + "." + patch;
					log.info("Detected SNAPSHOT version with no manually specified plugin-hub version. " +
							"Setting runelite.pluginhub.version to {}", version);
					System.setProperty("runelite.pluginhub.version", version);
				}
			}
			catch (Exception ex)
			{
				log.error("Failed to automatically use latest plugin-hub version", ex);
			}
		}
	}
}

package rs117.hd.tools;

import java.util.Arrays;
import java.util.HashSet;
import rs117.hd.data.environments.Area;
import rs117.hd.utils.AABB;

public class ExportAreasForExplv {
	public static void main(String... args) {
		StringBuilder sb = new StringBuilder();
		HashSet<AABB> aabbs = new HashSet<>();
		for (var area : Area.values()) {
			if (area == Area.ALL || area == Area.NONE)
				continue;
			aabbs.addAll(Arrays.asList(area.aabbs));
		}

		sb.append("Area[] area = { ");
		for (var aabb : aabbs)
			sb.append(String.format("new Area(%d, %d, %d, %d), ", aabb.minX, aabb.minY, aabb.maxX, aabb.maxY));
		sb.append("};");
		System.out.println(sb);
	}
}

package rs117.hd.tools;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Random;
import junit.framework.TestCase;
import rs117.hd.model.ModelHasher;

public class ModelHasherPerformanceTest extends TestCase {
    private final ArrayList<int[]> intArrays;
    private final Random random;
    private final int testDataCount;
    private final int testIterations;

    private long accumulatedHash = 0;

	public ModelHasherPerformanceTest() {
        this.intArrays = new ArrayList<>();
        this.random = new Random(1337);
        this.testDataCount = 1000;
        this.testIterations = 10000000;
    }

    private int[] generateRandomIntArray(int size) {
        int[] a = new int[size];

        for (int i = 0; i < size; i++) {
            a[i] = this.random.nextInt();
        }

        return a;
    }

	private long runStandardHasher() {
		long start = System.nanoTime();
		for (int i = 0; i < this.testIterations; i++) {
			accumulatedHash *= 31;
			accumulatedHash += Arrays.hashCode(intArrays.get(this.random.nextInt(this.testDataCount)));
		}
		return System.nanoTime() - start;
	}

	private long runFastIntHasher() {
		long start = System.nanoTime();
		for (int i = 0; i < this.testIterations; i++) {
			accumulatedHash *= 31;
			accumulatedHash += ModelHasher.fastHash(intArrays.get(this.random.nextInt(this.testDataCount)), -1);
		}
		return System.nanoTime() - start;
	}

	private long runFastHasher() {
		long start = System.nanoTime();
		for (int i = 0; i < this.testIterations; i++) {
			accumulatedHash *= 31;
			accumulatedHash += ModelHasher.fastHash(intArrays.get(this.random.nextInt(this.testDataCount)), -1);
		}
		return System.nanoTime() - start;
	}

	private double percentageDifference(long original, long changed) {
		long diff = original - changed;
		double delta = (double) diff / original;
		return delta * 100;
	}

	public void testHashPerformance() {
		System.out.printf("Java version: %s\n\n", System.getProperty("java.version"));
		System.out.printf("Comparing hash performance of with %,d test items and %,d iterations\n\n", testDataCount, testIterations);

		// small arrays (size=512)
		for (int i = 0; i < testDataCount; i++) {
			// generate random test data
			intArrays.add(generateRandomIntArray(512));
		}

		long standardBatchResult = runStandardHasher();
		System.out.printf("Standard hasher small data set:  \t%,.3f seconds\n", (double) standardBatchResult / 1e9);
		long fastIntBatchResult = runFastHasher();
		System.out.printf("Fast int hasher small data set:  \t%,.3f seconds\n", (double) fastIntBatchResult / 1e9);
		System.out.printf("Improvement =\t%.2f%%\n\n", percentageDifference(standardBatchResult, fastIntBatchResult));
		long fastBatchResult = runFastHasher();
		System.out.printf("Fast hasher small data set:      \t%,.3f seconds\n", (double) fastBatchResult / 1e9);
		System.out.printf("Improvement =\t%.2f%%\n\n", percentageDifference(standardBatchResult, fastBatchResult));

		// medium arrays (size=2048)
		intArrays.clear();
		for (int i = 0; i < testDataCount; i++) {
			intArrays.add(generateRandomIntArray(2048));
		}

		standardBatchResult = runStandardHasher();
		System.out.printf("Standard hasher medium data set:  \t%,.3f seconds\n", (double) standardBatchResult / 1e9);
		fastIntBatchResult = runFastHasher();
		System.out.printf("Fast int hasher medium data set:  \t%,.3f seconds\n", (double) fastIntBatchResult / 1e9);
		System.out.printf("Improvement =\t%.2f%%\n\n", percentageDifference(standardBatchResult, fastIntBatchResult));
		fastBatchResult = runFastHasher();
		System.out.printf("Fast hasher medium data set:      \t%,.3f seconds\n", (double) fastBatchResult / 1e9);
		System.out.printf("Improvement =\t%.2f%%\n\n", percentageDifference(standardBatchResult, fastBatchResult));

		// large arrays (size=6144)
		intArrays.clear();
		for (int i = 0; i < testDataCount; i++) {
			intArrays.add(generateRandomIntArray(6144));
		}

		standardBatchResult = runStandardHasher();
		System.out.printf("Standard hasher large data set:  \t%,.3f seconds\n", (double) standardBatchResult / 1e9);
		fastIntBatchResult = runFastHasher();
		System.out.printf("Fast int hasher large data set:  \t%,.3f seconds\n", (double) fastIntBatchResult / 1e9);
		System.out.printf("Improvement =\t%.2f%%\n\n", percentageDifference(standardBatchResult, fastIntBatchResult));
		fastBatchResult = runFastHasher();
		System.out.printf("Fast hasher large data set:      \t%,.3f seconds\n", (double) fastBatchResult / 1e9);
		System.out.printf("Improvement =\t%.2f%%\n\n", percentageDifference(standardBatchResult, fastBatchResult));

		System.out.println("Hash: " + accumulatedHash);
	}
}

package rs117.hd.tools;

import java.util.Arrays;
import java.util.stream.Collectors;
import rs117.hd.data.materials.Material;

import static rs117.hd.utils.ResourcePath.path;

public class IdentifyUnusedTextures {
	public static void main(String... args) {
		var path = path("src/main/resources/rs117/hd/scene/textures");
		var unusedTextures = Arrays.stream(path.toFile().listFiles())
			.map(f -> f.getName())
			.filter(filename -> {
				var materialName = path(filename)
					.setExtension("")
					.getFilename()
					.toUpperCase();
				try {
					Material.valueOf(materialName);
					return false;
				} catch (Exception ex) {
					return true;
				}
			})
			.collect(Collectors.toList());
		System.out.println("Unused textures:");
		for (var filename : unusedTextures)
			System.out.println(filename);
	}
}

