/*
 * Copyright (c) 2018, Lotto <https://github.com/devLotto>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package rs117.hd.config;

import lombok.Getter;
import lombok.RequiredArgsConstructor;

@Getter
@RequiredArgsConstructor
public enum AntiAliasingMode
{
	DISABLED("Disabled", 0),
	MSAA_2("MSAA x2", 2),
	MSAA_4("MSAA x4", 4),
	MSAA_8("MSAA x8", 8),
	MSAA_16("MSAA x16", 16);

	private final String name;
	private final int samples;

	@Override
	public String toString()
	{
		return name;
	}
}

/*
 * Copyright (c) 2020 Ben Poulson <https://github.com/benpoulson>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package rs117.hd.config;

public enum ColorBlindMode {
	NONE,
	PROTANOPE,
	DEUTERANOPE,
	TRITANOPE
}

package rs117.hd.config;

public enum ColorFilter {
	NONE,
	GREYSCALE,
	SEPIA,
	HIGH_CONTRAST,
	CARTOON,
	INVERT_COLORS,
	BLACK_AND_WHITE,
	CEL_SHADING
}

/*
 * Copyright (c) 2021, 117 <https://twitter.com/117scape>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package rs117.hd.config;

import lombok.Getter;
import lombok.RequiredArgsConstructor;

@Getter
@RequiredArgsConstructor
public enum Contrast
{
	HIGHER("Highest", 1.1f),
	HIGHEST("Higher", 1.05f),
	DEFAULT("Default", 1.0f),
	LOWER("Lower", 0.95f),
	LOWEST("Lowest", 0.9f);

	private final String name;
	private final float amount;

	@Override
	public String toString()
	{
		return name;
	}
}

/*
 * Copyright (c) 2021, 117 <https://twitter.com/117scape>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package rs117.hd.config;

import lombok.Getter;
import lombok.RequiredArgsConstructor;
import net.runelite.api.*;
import rs117.hd.utils.ColorUtils;

@Getter
@RequiredArgsConstructor
public enum DefaultSkyColor
{
	DEFAULT("117 HD Blue", 185, 214, 255),
	RUNELITE("RuneLite Skybox", -1, -1, -1),
	OSRS("Old School Black", 0, 0, 0),
	HD2008("2008 HD Tan", 200, 192, 169);

	private final String name;
	private final int r;
	private final int g;
	private final int b;

	@Override
	public String toString()
	{
		return name;
	}

	public float[] getRgb(Client client) {
		int r = this.r;
		int g = this.g;
		int b = this.b;
		if (this == RUNELITE)
		{
			int sky = client.getSkyboxColor();
			r = sky >> 16 & 0xFF;
			g = sky >> 8 & 0xFF;
			b = sky & 0xFF;
		}
		return new float[] {
			ColorUtils.srgbToLinear(r / 255f),
			ColorUtils.srgbToLinear(g / 255f),
			ColorUtils.srgbToLinear(b / 255f)
		};
	}
}

/*
 * Copyright (c) 2021, 117 <https://twitter.com/117scape>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package rs117.hd.config;

import lombok.Getter;
import lombok.RequiredArgsConstructor;

import static rs117.hd.utils.MathUtils.*;

@Getter
@RequiredArgsConstructor
public enum DynamicLights
{
	NONE("Disabled", 0, 0),
	FEW("Few", 4, 25),
	SOME("Some", 8, 50),
	MANY("Many", 12, 100);

	public static final int MAX_LAYERS_PER_TILE;

	static {
		int max = 0;
		for (var e : values()) {
			assert e.tiledLightingLayers % 4 == 0; // Needs to be divisible by 4
			max = max(max, e.tiledLightingLayers);
		}
		MAX_LAYERS_PER_TILE = max;
	}

	private final String name;
	private final int tiledLightingLayers;
	private final int maxSceneLights;

	@Override
	public String toString()
	{
		return name;
	}
}

/*
 * Copyright (c) 2021, 117 <https://twitter.com/117scape>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package rs117.hd.config;

import lombok.Getter;
import lombok.RequiredArgsConstructor;

@Getter
@RequiredArgsConstructor
public enum FogDepthMode
{
	NONE("None", 0),
	DYNAMIC("Dynamic", 1),
	USER_DEFINED("Static", 2);

	private final String name;
	private final int mode;

	@Override
	public String toString()
	{
		return name;
	}
}

/*
 * Copyright (c) 2021, 117 <https://twitter.com/117scape>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package rs117.hd.config;

import lombok.Getter;
import lombok.RequiredArgsConstructor;

@Getter
@RequiredArgsConstructor
public enum Saturation
{
	HIGHEST("Highest", 1.2f),
	HIGHER("Higher", 1.1f),
	DEFAULT("Default", 1.0f),
	LOWER("Lower", 0.9f),
	LOWEST("Lowest", 0.8f),
	NONE("None", 0.0f);

	private final String name;
	private final float amount;

	@Override
	public String toString()
	{
		return name;
	}
}

/*
 * Copyright (c) 2019 logarrhytmic <https://github.com/logarrhythmic>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package rs117.hd.config;

import lombok.Getter;
import lombok.RequiredArgsConstructor;

import static org.lwjgl.opengl.GL33C.*;

@Getter
@RequiredArgsConstructor
public enum SceneScalingMode {
	NEAREST("Nearest", GL_NEAREST),
	LINEAR("Bilinear", GL_LINEAR);

	private final String name;

	public final int glFilter;

	@Override
	public String toString() {
		return name;
	}
}

package rs117.hd.config;

import lombok.Getter;
import lombok.RequiredArgsConstructor;

@Getter
@RequiredArgsConstructor
public enum SeasonalHemisphere {
	NORTHERN,
	SOUTHERN
	;
}

package rs117.hd.config;

import lombok.Getter;
import lombok.RequiredArgsConstructor;

@Getter
@RequiredArgsConstructor
public enum SeasonalTheme {
	AUTOMATIC,
	SUMMER,
	AUTUMN,
	WINTER,
	;
}

/*
 * Copyright (c) 2023, Hooder <ahooder@protonmail.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package rs117.hd.config;

import lombok.Getter;
import lombok.RequiredArgsConstructor;

@Getter
@RequiredArgsConstructor
public enum ShadingMode {
	DEFAULT("117 HD", false, true, true),
	VANILLA("Vanilla", false, false, false),
	NONE("None", true, false, false),
	UNLIT("Experimental", true, false, true),
	;

	private final String name;
	public final boolean unlitFaceColors;
	public final boolean undoVanillaShading;
	public final boolean directionalShading;

	@Override
	public String toString() {
		return name;
	}
}

/*
 * Copyright (c) 2021, 117 <https://twitter.com/117scape>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package rs117.hd.config;

import lombok.Getter;
import lombok.RequiredArgsConstructor;

@Getter
@RequiredArgsConstructor
public enum ShadowDistance
{
	DISTANCE_20("20", 20),
	DISTANCE_30("30", 30),
	DISTANCE_40("40", 40),
	DISTANCE_50("50", 50),
	DISTANCE_60("60", 60),
	DISTANCE_70("70", 70),
	DISTANCE_80("80", 80),
	DISTANCE_90("90", 90);

	private final String name;
	private final int value;

	@Override
	public String toString()
	{
		return name;
	}
}

/*
 * Copyright (c) 2023, Hooder <ahooder@protonmail.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package rs117.hd.config;

public enum ShadowMode
{
	OFF,
	FAST,
	DETAILED
}

/*
 * Copyright (c) 2021, 117 <https://twitter.com/117scape>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package rs117.hd.config;

import lombok.Getter;
import lombok.RequiredArgsConstructor;

@Getter
@RequiredArgsConstructor
public enum ShadowResolution
{
	RES_1024("Low (1K)", 1024),
	RES_2048("Medium (2K)", 2048),
	RES_4096("High (4K)", 4096),
	RES_8192("Ultra (8K)", 8192),
	RES_16384("Extreme (16K)", 16384);

	private final String name;
	private final int value;

	@Override
	public String toString()
	{
		return name;
	}
}

/*
 * Copyright (c) 2022, Hooder <ahooder@protonmail.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package rs117.hd.config;

import lombok.Getter;
import lombok.RequiredArgsConstructor;

@Getter
@RequiredArgsConstructor
public enum TextureResolution
{
	RES_128("128 px", 128),
	RES_256("256 px", 256);

	private final String name;
	private final int size;

	@Override
	public String toString()
	{
		return name;
	}
}

/*
 * Copyright (c) 2019 logarrhytmic <https://github.com/logarrhythmic>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package rs117.hd.config;

import lombok.Getter;
import lombok.RequiredArgsConstructor;

import static org.lwjgl.opengl.GL33C.*;

@Getter
@RequiredArgsConstructor
public enum UIScalingMode {
	NEAREST("Nearest", GL_NEAREST),
	LINEAR("Bilinear", GL_LINEAR),
	MITCHELL("Mitchell", GL_NEAREST),
	CATMULL_ROM("Catmull-Rom", GL_NEAREST),
	XBR("xBR", GL_NEAREST),
	HYBRID("Hybrid", GL_LINEAR);

	private final String name;
	public final int glSamplingFunction;

	@Override
	public String toString()
	{
		return name;
	}
}

/*
 * Copyright (c) 2024, Hooder <ahooder@protonmail.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package rs117.hd.config;

import lombok.Getter;
import lombok.RequiredArgsConstructor;

@Getter
@RequiredArgsConstructor
public enum VanillaShadowMode {
	SHOW("Show", true),
	SHOW_IN_PVM("Show in PvM", true),
	PREFER_IN_PVM("Prefer in PvM", true),
	HIDE("Hide", false),
	;

	private final String name;

	public final boolean retainInPvm;

	@Override
	public String toString() {
		return name;
	}
}

package rs117.hd.data;

import lombok.RequiredArgsConstructor;

@RequiredArgsConstructor
public enum ObjectType {
	// Sourced from https://github.com/abextm/cache2/blob/2562ab769e4042667d6a10c3ab795b9622be6049/cache2-ts/src/types.ts#L119-L145
	WallStraight(0),
	WallDiagonalCorner(1),
	WallCorner(2),
	WallSquareCorner(3),
	WallDecorStraightNoOffset(4),
	WallDecorStraightOffset(5),
	WallDecorDiagonalOffset(6),
	WallDecorDiagonalNoOffset(7),
	WallDecorDiagonalBoth(8),
	WallDiagonal(9),
	CentrepieceStraight(10),
	CentrepieceDiagonal(11),
	RoofStraight(12),
	RoofDiagonalWithRoofEdge(13),
	RoofDiagonal(14),
	RoofCornerConcave(15),
	RoofCornerConvex(16),
	RoofFlat(17),
	RoofEdgeStraight(18),
	RoofEdgeDiagonalCorner(19),
	RoofEdgeCorner(20),
	RoofEdgeSquarecorner(21),
	GroundDecor(22),
	Unknown(-1);

	public static final ObjectType[] TYPES = values();

	public final int id;

	public static ObjectType fromConfig(int config) {
		int type = config & 0x3F;
		if (type >= TYPES.length - 1)
			return Unknown;
		return TYPES[type];
	}
}

/*
 * Copyright (c) 2018, Adam <Adam@sigterm.info>
 * Copyright (c) 2021, 117 <https://twitter.com/117scape>
 * Copyright (c) 2025, Hooder <ahooder@protonmail.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package rs117.hd;

import com.google.gson.Gson;
import com.google.inject.Binder;
import com.google.inject.Provides;
import java.awt.Canvas;
import java.awt.Dimension;
import java.awt.GraphicsConfiguration;
import java.awt.Image;
import java.awt.geom.AffineTransform;
import java.awt.image.BufferedImage;
import java.awt.image.DataBufferInt;
import java.io.IOException;
import java.nio.ByteBuffer;
import java.nio.FloatBuffer;
import java.time.ZoneOffset;
import java.time.ZonedDateTime;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.Objects;
import java.util.concurrent.ConcurrentHashMap;
import javax.annotation.Nullable;
import javax.inject.Inject;
import javax.swing.SwingUtilities;
import lombok.Getter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.*;
import net.runelite.api.events.*;
import net.runelite.api.hooks.*;
import net.runelite.client.RuneLite;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.eventbus.EventBus;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.events.ConfigChanged;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.plugins.PluginDependency;
import net.runelite.client.plugins.PluginDescriptor;
import net.runelite.client.plugins.PluginInstantiationException;
import net.runelite.client.plugins.PluginManager;
import net.runelite.client.plugins.entityhider.EntityHiderPlugin;
import net.runelite.client.ui.ClientUI;
import net.runelite.client.util.LinkBrowser;
import net.runelite.client.util.OSType;
import net.runelite.rlawt.AWTContext;
import org.lwjgl.BufferUtils;
import org.lwjgl.opengl.*;
import org.lwjgl.system.Callback;
import org.lwjgl.system.Configuration;
import rs117.hd.config.ColorFilter;
import rs117.hd.config.DynamicLights;
import rs117.hd.config.SeasonalHemisphere;
import rs117.hd.config.SeasonalTheme;
import rs117.hd.config.ShadingMode;
import rs117.hd.config.ShadowMode;
import rs117.hd.config.VanillaShadowMode;
import rs117.hd.opengl.AsyncUICopy;
import rs117.hd.opengl.shader.ShaderException;
import rs117.hd.opengl.shader.ShaderIncludes;
import rs117.hd.opengl.shader.TiledLightingShaderProgram;
import rs117.hd.opengl.shader.UIShaderProgram;
import rs117.hd.opengl.uniforms.UBOCompute;
import rs117.hd.opengl.uniforms.UBOGlobal;
import rs117.hd.opengl.uniforms.UBOLights;
import rs117.hd.opengl.uniforms.UBOUI;
import rs117.hd.overlays.FrameTimer;
import rs117.hd.overlays.GammaCalibrationOverlay;
import rs117.hd.overlays.ShadowMapOverlay;
import rs117.hd.overlays.TiledLightingOverlay;
import rs117.hd.overlays.Timer;
import rs117.hd.renderer.Renderer;
import rs117.hd.renderer.legacy.LegacyRenderer;
import rs117.hd.renderer.zone.SceneManager;
import rs117.hd.renderer.zone.ZoneRenderer;
import rs117.hd.scene.AreaManager;
import rs117.hd.scene.EnvironmentManager;
import rs117.hd.scene.FishingSpotReplacer;
import rs117.hd.scene.GamevalManager;
import rs117.hd.scene.GroundMaterialManager;
import rs117.hd.scene.LightManager;
import rs117.hd.scene.MaterialManager;
import rs117.hd.scene.ModelOverrideManager;
import rs117.hd.scene.ProceduralGenerator;
import rs117.hd.scene.SceneContext;
import rs117.hd.scene.TextureManager;
import rs117.hd.scene.TileOverrideManager;
import rs117.hd.scene.WaterTypeManager;
import rs117.hd.utils.ColorUtils;
import rs117.hd.utils.DeveloperTools;
import rs117.hd.utils.FileWatcher;
import rs117.hd.utils.GsonUtils;
import rs117.hd.utils.HDUtils;
import rs117.hd.utils.HDVariables;
import rs117.hd.utils.NpcDisplacementCache;
import rs117.hd.utils.PopupUtils;
import rs117.hd.utils.Props;
import rs117.hd.utils.ResourcePath;
import rs117.hd.utils.ShaderRecompile;

import static net.runelite.api.Constants.*;
import static org.lwjgl.opengl.GL33C.*;
import static rs117.hd.HdPluginConfig.*;
import static rs117.hd.utils.MathUtils.*;
import static rs117.hd.utils.ResourcePath.path;

@PluginDescriptor(
	name = "117 HD",
	description = "GPU renderer with a suite of graphical enhancements",
	tags = { "hd", "high", "detail", "graphics", "shaders", "textures", "gpu", "shadows", "lights" },
	conflicts = "GPU"
)
@PluginDependency(EntityHiderPlugin.class)
@Slf4j
public class HdPlugin extends Plugin {
	public static final ResourcePath PLUGIN_DIR = Props
		.getFolder("rlhd.plugin-dir", () -> path(RuneLite.RUNELITE_DIR, "117hd"));

	public static final String DISCORD_URL = "https://discord.gg/U4p6ChjgSE";
	public static final String RUNELITE_URL = "https://runelite.net";
	public static final String AMD_DRIVER_URL = "https://www.amd.com/en/support";
	public static final String INTEL_DRIVER_URL = "https://www.intel.com/content/www/us/en/support/detect.html";
	public static final String NVIDIA_DRIVER_URL = "https://www.nvidia.com/en-us/geforce/drivers/";

	public static int MAX_TEXTURE_UNITS;
	public static int TEXTURE_UNIT_COUNT = 0;
	public static final int TEXTURE_UNIT_UI = GL_TEXTURE0 + TEXTURE_UNIT_COUNT++;
	public static final int TEXTURE_UNIT_GAME = GL_TEXTURE0 + TEXTURE_UNIT_COUNT++;
	public static final int TEXTURE_UNIT_SHADOW_MAP = GL_TEXTURE0 + TEXTURE_UNIT_COUNT++;
	public static final int TEXTURE_UNIT_TILE_HEIGHT_MAP = GL_TEXTURE0 + TEXTURE_UNIT_COUNT++;
	public static final int TEXTURE_UNIT_TILED_LIGHTING_MAP = GL_TEXTURE0 + TEXTURE_UNIT_COUNT++;

	public static int MAX_IMAGE_UNITS;
	public static int IMAGE_UNIT_COUNT = 0;
	public static final int IMAGE_UNIT_TILED_LIGHTING = IMAGE_UNIT_COUNT++;

	public static int UNIFORM_BLOCK_COUNT = 0;
	public static final int UNIFORM_BLOCK_GLOBAL = UNIFORM_BLOCK_COUNT++;
	public static final int UNIFORM_BLOCK_MATERIALS = UNIFORM_BLOCK_COUNT++;
	public static final int UNIFORM_BLOCK_WATER_TYPES = UNIFORM_BLOCK_COUNT++;
	public static final int UNIFORM_BLOCK_LIGHTS = UNIFORM_BLOCK_COUNT++;
	public static final int UNIFORM_BLOCK_LIGHTS_CULLING = UNIFORM_BLOCK_COUNT++;
	public static final int UNIFORM_BLOCK_UI = UNIFORM_BLOCK_COUNT++;

	public static final float NEAR_PLANE = 50;
	public static final int MAX_FACE_COUNT = 6144;
	public static final int MAX_DISTANCE = EXTENDED_SCENE_SIZE;
	public static final int MAX_FOG_DEPTH = 100;
	public static final int TILED_LIGHTING_TILE_SIZE = 16;

	public static final float ORTHOGRAPHIC_ZOOM = .0002f;
	public static final float WIND_DISPLACEMENT_NOISE_RESOLUTION = 0.04f;

	public static float BUFFER_GROWTH_MULTIPLIER = 2; // can be less than 2 if trying to conserve memory

	public static final float COLOR_FILTER_FADE_DURATION = 500;

	public static final int[] RENDERBUFFER_FORMATS_SRGB = {
		GL_SRGB8,
		GL_SRGB8_ALPHA8 // should be guaranteed
	};
	public static final int[] RENDERBUFFER_FORMATS_SRGB_WITH_ALPHA = {
		GL_SRGB8_ALPHA8 // should be guaranteed
	};
	public static final int[] RENDERBUFFER_FORMATS_LINEAR = {
		GL_RGB8,
		GL_RGBA8,
		GL_RGB, // should be guaranteed
		GL_RGBA // should be guaranteed
	};
	public static final int[] RENDERBUFFER_FORMATS_LINEAR_WITH_ALPHA = {
		GL_RGBA8,
		GL_RGBA // should be guaranteed
	};

	public static final int PROCESSOR_COUNT = Runtime.getRuntime().availableProcessors();

	// Manually instantiate singletons and lazily inject them to avoid circular dependencies
	private static final List<Class<?>> LAZY_SINGLETONS = List.of(
		AreaManager.class,
		EnvironmentManager.class,
		GamevalManager.class,
		GroundMaterialManager.class,
		LightManager.class,
		MaterialManager.class,
		ModelOverrideManager.class,
		ProceduralGenerator.class,
		TextureManager.class,
		TileOverrideManager.class,
		WaterTypeManager.class,
		SceneManager.class
	);

	@Getter
	private Gson gson;

	@Inject
	private Client client;

	@Inject
	private ClientUI clientUI;

	@Inject
	private ClientThread clientThread;

	@Inject
	private EventBus eventBus;

	@Inject
	private PluginManager pluginManager;

	@Inject
	private HdPluginConfig config;

	@Inject
	private GamevalManager gamevalManager;

	@Inject
	private AreaManager areaManager;

	@Inject
	private LightManager lightManager;

	@Inject
	private EnvironmentManager environmentManager;

	@Inject
	private TextureManager textureManager;

	@Inject
	private MaterialManager materialManager;

	@Inject
	private WaterTypeManager waterTypeManager;

	@Inject
	private GroundMaterialManager groundMaterialManager;

	@Inject
	private TileOverrideManager tileOverrideManager;

	@Inject
	private ModelOverrideManager modelOverrideManager;

	@Inject
	private AsyncUICopy asyncUICopy;

	@Inject
	private FishingSpotReplacer fishingSpotReplacer;

	@Inject
	private NpcDisplacementCache npcDisplacementCache;

	@Inject
	private DeveloperTools developerTools;

	@Inject
	private FrameTimer frameTimer;

	@Inject
	private UIShaderProgram uiProgram;

	@Inject
	private SceneManager sceneManager;

	@Getter
	@Inject
	public TiledLightingShaderProgram tiledLightingImageStoreProgram;

	public final List<TiledLightingShaderProgram> tiledLightingShaderPrograms = new ArrayList<>();

	@Inject
	private GammaCalibrationOverlay gammaCalibrationOverlay;

	@Inject
	private ShadowMapOverlay shadowMapOverlay;

	@Inject
	private TiledLightingOverlay tiledLightingOverlay;

	@Inject
	public HDVariables vars;

	public Renderer renderer;

	public static boolean SKIP_GL_ERROR_CHECKS;
	public static GLCapabilities GL_CAPS;
	public static boolean AMD_GPU;
	public static boolean INTEL_GPU;
	public static boolean NVIDIA_GPU;
	public static boolean APPLE;
	public static boolean APPLE_ARM;

	public static boolean SUPPORTS_INDIRECT_DRAW;

	public Canvas canvas;
	public AWTContext awtContext;
	private Callback debugCallback;

	private static final String LINUX_VERSION_HEADER =
		"#version 420\n" +
		"#extension GL_ARB_compute_shader : require\n" +
		"#extension GL_ARB_shader_storage_buffer_object : require\n" +
		"#extension GL_ARB_explicit_attrib_location : require\n";
	private static final String WINDOWS_VERSION_HEADER = "#version 430\n";

	private static final ResourcePath SHADER_PATH = Props
		.getFolder("rlhd.shader-path", () -> path(HdPlugin.class));

	public int vaoQuad;
	private int vboQuad;

	public int vaoTri;
	private int vboTri;

	@Getter
	@Nullable
	private int[] uiResolution;
	private final int[] actualUiResolution = { 0, 0 }; // Includes stretched mode and DPI scaling
	private int texUi;
	private int pboUi;

	@Nullable
	public int[] sceneViewport;
	public final float[] sceneViewportScale = { 1, 1 };
	public int msaaSamples;

	public int[] sceneResolution;
	public int fboScene;
	private int rboSceneColor;
	private int rboSceneDepth;
	public int fboSceneResolve;
	private int rboSceneResolveColor;

	public int shadowMapResolution;
	public int fboShadowMap;
	private int texShadowMap;

	public int[] tiledLightingResolution;
	public int tiledLightingLayerCount;
	public int fboTiledLighting;
	public int texTiledLighting;

	public final UBOGlobal uboGlobal = new UBOGlobal();
	public final UBOLights uboLights = new UBOLights(false);
	public final UBOLights uboLightsCulling = new UBOLights(true);
	public final UBOUI uboUI = new UBOUI();

	// Configs used frequently enough to be worth caching
	public boolean configGroundTextures;
	public boolean configGroundBlending;
	public boolean configModelTextures;
	public boolean configLegacyTzHaarReskin;
	public boolean configProjectileLights;
	public boolean configNpcLights;
	public boolean configHideFakeShadows;
	public boolean configLegacyGreyColors;
	public boolean configModelBatching;
	public boolean configModelCaching;
	public boolean configShadowsEnabled;
	public boolean configRoofShadows;
	public boolean configExpandShadowDraw;
	public boolean configUseFasterModelHashing;
	public boolean configZoneStreaming;
	public boolean configUnlitFaceColors;
	public boolean configUndoVanillaShading;
	public boolean configPreserveVanillaNormals;
	public boolean configAsyncUICopy;
	public boolean configWindDisplacement;
	public boolean configCharacterDisplacement;
	public boolean configTiledLighting;
	public boolean configTiledLightingImageLoadStore;
	public int configDetailDrawDistance;
	public DynamicLights configDynamicLights;
	public ShadowMode configShadowMode;
	public SeasonalTheme configSeasonalTheme;
	public SeasonalHemisphere configSeasonalHemisphere;
	public VanillaShadowMode configVanillaShadowMode;
	public ShadingMode configShadingMode;
	public ColorFilter configColorFilter = ColorFilter.NONE;
	public ColorFilter configColorFilterPrevious;

	public boolean useLowMemoryMode;
	public boolean enableDetailedTimers;
	public boolean enableFreezeFrame;
	public boolean orthographicProjection;

	@Getter
	private boolean isActive;
	private boolean lwjglInitialized;
	public boolean hasLoggedIn;
	public boolean redrawPreviousFrame;
	public boolean justChangedArea;
	public Scene skipScene;

	public final ConcurrentHashMap.KeySetView<String, ?> pendingConfigChanges = ConcurrentHashMap.newKeySet();

	// Camera position and orientation may be reused from the old scene while hopping, prior to drawScene being called
	public final float[] cameraPosition = new float[3];
	public final int[] cameraShift = new int[2];
	public final int[] cameraFocalPoint = new int[2];
	public final float[] cameraOrientation = new float[2];
	public final float[][] cameraFrustum = new float[6][4];
	public float[] viewMatrix = new float[16];
	public float[] viewProjMatrix = new float[16];
	public float[] invViewProjMatrix = new float[16];

	@Getter
	public int drawnTileCount;
	@Getter
	public int drawnStaticRenderableCount;
	@Getter
	public int drawnDynamicRenderableCount;
	@Getter
	public long garbageCollectionCount;

	public double elapsedTime;
	public double elapsedClientTime;
	public float deltaTime;
	public float deltaClientTime;
	private long lastFrameTimeMillis;
	private double lastFrameClientTime;
	public float windOffset;
	public long colorFilterChangedAt;

	@Provides
	HdPluginConfig provideConfig(ConfigManager configManager) {
		return configManager.getConfig(HdPluginConfig.class);
	}

	@Override
	public void configure(Binder binder) {
		// Bind manually constructed instances of singletons to avoid recursive loading issues
		for (var clazz : LAZY_SINGLETONS) {
			try {
				// noinspection unchecked
				binder.bind((Class<Object>) clazz).toInstance(clazz.getDeclaredConstructor().newInstance());
			} catch (Exception ex) {
				throw new RuntimeException("Failed to instantiate singleton " + clazz, ex);
			}
		}
	}

	@Override
	protected void startUp() {
		// Lazily inject members into our singletons
		for (var clazz : LAZY_SINGLETONS)
			injector.injectMembers(injector.getInstance(clazz));

		gson = GsonUtils.wrap(injector.getInstance(Gson.class));

		clientThread.invoke(() -> {
			try {
				if (!textureManager.vanillaTexturesAvailable())
					return false;

				fboScene = 0;
				rboSceneColor = 0;
				rboSceneDepth = 0;
				fboSceneResolve = 0;
				rboSceneResolveColor = 0;
				fboShadowMap = 0;
				elapsedTime = 0;
				elapsedClientTime = 0;
				deltaTime = 0;
				deltaClientTime = 0;
				lastFrameTimeMillis = 0;
				lastFrameClientTime = 0;

				AWTContext.loadNatives();
				canvas = client.getCanvas();

				synchronized (canvas.getTreeLock()) {
					// Delay plugin startup until the client's canvas is valid
					if (!canvas.isValid())
						return false;

					awtContext = new AWTContext(canvas);
					awtContext.configurePixelFormat(0, 0, 0);
				}

				awtContext.createGLContext();

				canvas.setIgnoreRepaint(true);

				// lwjgl defaults to lwjgl- + user.name, but this breaks if the username would cause an invalid path
				// to be created.
				Configuration.SHARED_LIBRARY_EXTRACT_DIRECTORY.set("lwjgl-rl");

				SKIP_GL_ERROR_CHECKS = false;
				GL_CAPS = GL.createCapabilities();
				useLowMemoryMode = config.lowMemoryMode();
				BUFFER_GROWTH_MULTIPLIER = useLowMemoryMode ? 1.333f : 2;

				OSType osType = OSType.getOSType();
				String arch = System.getProperty("os.arch", "Unknown");
				String wordSize = System.getProperty("sun.arch.data.model", "Unknown");
				log.info("Operating system: {}", osType);
				log.info("Architecture: {}", arch);
				log.info("Client is {}-bit", wordSize);
				APPLE = osType == OSType.MacOS;
				APPLE_ARM = APPLE && arch.equals("aarch64");

				String glRenderer = Objects.requireNonNullElse(glGetString(GL_RENDERER), "Unknown");
				String glVendor = Objects.requireNonNullElse(glGetString(GL_VENDOR), "Unknown");
				log.info("Using device: {} ({})", glRenderer, glVendor);
				log.info("Using driver: {}", glGetString(GL_VERSION));
				AMD_GPU = glRenderer.contains("AMD") || glRenderer.contains("Radeon") || glVendor.contains("ATI");
				INTEL_GPU = glRenderer.contains("Intel");
				NVIDIA_GPU = glRenderer.toLowerCase().contains("nvidia");

				SUPPORTS_INDIRECT_DRAW = NVIDIA_GPU && !APPLE || config.forceIndirectDraw();

				renderer = config.legacyRenderer() ?
					injector.getInstance(LegacyRenderer.class) :
					injector.getInstance(ZoneRenderer.class);
				log.info("Using renderer: {}", renderer.getClass().getSimpleName());

				log.info("Low memory mode: {}", useLowMemoryMode);

				if (!Props.has("rlhd.skipGpuChecks")) {
					List<String> fallbackDevices = List.of(
						"GDI Generic",
						"D3D12 (Microsoft Basic Render Driver)",
						"softpipe"
					);
					boolean isFallbackGpu = fallbackDevices.contains(glRenderer);
					if (isFallbackGpu || !renderer.supportsGpu(GL_CAPS)) {
						log.error("Unsupported GPU. Stopping the plugin...");
						displayUnsupportedGpuMessage(isFallbackGpu, glRenderer, renderer);
						stopPlugin();
						return true;
					}
				}

				lwjglInitialized = true;
				checkGLErrors();

				MAX_TEXTURE_UNITS = glGetInteger(GL_MAX_TEXTURE_IMAGE_UNITS); // Not the fixed pipeline MAX_TEXTURE_UNITS
				if (MAX_TEXTURE_UNITS < TEXTURE_UNIT_COUNT)
					log.warn("The GPU only supports {} texture units", MAX_TEXTURE_UNITS);
				MAX_IMAGE_UNITS = GL_CAPS.GL_ARB_shader_image_load_store ?
					glGetInteger(ARBShaderImageLoadStore.GL_MAX_IMAGE_UNITS) : 0;
				if (MAX_IMAGE_UNITS < IMAGE_UNIT_COUNT)
					log.warn("The GPU only supports {} image units", MAX_IMAGE_UNITS);

				if (log.isDebugEnabled() && GL_CAPS.glDebugMessageControl != 0) {
					debugCallback = GLUtil.setupDebugMessageCallback();
					if (debugCallback != null) {
						// Hide our own debug group messages
						GL43C.glDebugMessageControl(
							GL43C.GL_DEBUG_SOURCE_APPLICATION,
							GL43C.GL_DEBUG_TYPE_PUSH_GROUP,
							GL43C.GL_DEBUG_SEVERITY_NOTIFICATION,
							(int[]) null,
							false
						);
						GL43C.glDebugMessageControl(
							GL43C.GL_DEBUG_SOURCE_APPLICATION,
							GL43C.GL_DEBUG_TYPE_POP_GROUP,
							GL43C.GL_DEBUG_SEVERITY_NOTIFICATION,
							(int[]) null,
							false
						);

						//	GLDebugEvent[ id 0x20071
						//		type Warning: generic
						//		severity Unknown (0x826b)
						//		source GL API
						//		msg Buffer detailed info: Buffer object 11 (bound to GL_ARRAY_BUFFER_ARB, and GL_SHADER_STORAGE_BUFFER (4), usage hint is GL_STREAM_DRAW) will use VIDEO memory as the source for buffer object operations.
						GL43C.glDebugMessageControl(
							GL43C.GL_DEBUG_SOURCE_API, GL43C.GL_DEBUG_TYPE_OTHER,
							GL_DONT_CARE, 0x20071, false
						);

						//	GLDebugMessageHandler: GLDebugEvent[ id 0x20052
						//		type Warning: implementation dependent performance
						//		severity Medium: Severe performance/deprecation/other warnings
						//		source GL API
						//		msg Pixel-path performance warning: Pixel transfer is synchronized with 3D rendering.
						GL43C.glDebugMessageControl(
							GL43C.GL_DEBUG_SOURCE_API, GL43C.GL_DEBUG_TYPE_PERFORMANCE,
							GL_DONT_CARE, 0x20052, false
						);

						// [LWJGL] OpenGL debug message
						//	ID: 0x20092
						//	Source: API
						//	Type: PERFORMANCE
						//	Severity: MEDIUM
						//	Message: Program/shader state performance warning: Vertex shader in program 20 is being recompiled based on GL state.
						GL43C.glDebugMessageControl(
							GL43C.GL_DEBUG_SOURCE_API, GL43C.GL_DEBUG_TYPE_PERFORMANCE,
							GL_DONT_CARE, 0x20092, false
						);
					}
				}

				updateCachedConfigs();
				developerTools.activate();

				setupSyncMode();
				initializeVaos();
				initializeUbos();

				// Materials need to be initialized before compiling shader programs
				textureManager.startUp();
				materialManager.startUp();
				waterTypeManager.startUp();

				renderer.initialize();
				eventBus.register(renderer);
				int gpuFlags = DrawCallbacks.GPU | renderer.gpuFlags();
				if (config.removeVertexSnapping())
					gpuFlags |= DrawCallbacks.NO_VERTEX_SNAPPING;
				if (configShadingMode.unlitFaceColors)
					gpuFlags |= DrawCallbacks.UNLIT_FACE_COLORS;

				initializeShaders();
				initializeShaderHotswapping();
				initializeUiTexture();
				initializeShadowMapFbo();

				checkGLErrors();

				client.setDrawCallbacks(renderer);
				client.setGpuFlags(gpuFlags);
				client.setExpandedMapLoading(getExpandedMapLoadingChunks());
				// force rebuild of main buffer provider to enable alpha channel
				client.resizeCanvas();

				gamevalManager.startUp();
				areaManager.startUp();
				groundMaterialManager.startUp();
				tileOverrideManager.startUp();
				modelOverrideManager.startUp();
				lightManager.startUp();
				environmentManager.startUp();
				fishingSpotReplacer.startUp();
				gammaCalibrationOverlay.initialize();
				npcDisplacementCache.initialize();

				isActive = true;
				hasLoggedIn = client.getGameState().getState() > GameState.LOGGING_IN.getState();
				redrawPreviousFrame = false;
				skipScene = null;

				// Force the client to reload the scene since we're changing GPU flags, and to restore any removed tiles
				if (client.getGameState() == GameState.LOGGED_IN)
					client.setGameState(GameState.LOADING);

				checkGLErrors();

				clientThread.invokeLater(this::displayUpdateMessage);
			} catch (Throwable err) {
				log.error("Error while starting 117 HD", err);
				stopPlugin();
			}
			return true;
		});
	}

	@Override
	protected void shutDown() {
		isActive = false;
		FileWatcher.destroy();

		clientThread.invoke(() -> {
			var scene = client.getScene();
			if (scene != null)
				scene.setMinLevel(0);

			client.setGpuFlags(0);
			client.setDrawCallbacks(null);
			client.setUnlockedFps(false);
			client.setExpandedMapLoading(0);

			asyncUICopy.complete();

			if (lwjglInitialized) {
				lwjglInitialized = false;
				renderer.waitUntilIdle();

				destroyUiTexture();
				destroyShaders();
				destroyVaos();
				destroyUbos();
				destroySceneFbo();
				destroyShadowMapFbo();
				destroyTiledLightingFbo();

				if (renderer != null) {
					eventBus.unregister(renderer);
					renderer.destroy();
				}
				renderer = null;
			}

			developerTools.deactivate();
			tileOverrideManager.shutDown();
			groundMaterialManager.shutDown();
			modelOverrideManager.shutDown();
			lightManager.shutDown();
			environmentManager.shutDown();
			fishingSpotReplacer.shutDown();
			areaManager.shutDown();
			gamevalManager.shutDown();
			gammaCalibrationOverlay.destroy();
			npcDisplacementCache.destroy();
			waterTypeManager.shutDown();
			materialManager.shutDown();
			textureManager.shutDown();

			if (awtContext != null)
				awtContext.destroy();
			awtContext = null;

			if (debugCallback != null)
				debugCallback.free();
			debugCallback = null;

			// force main buffer provider rebuild to turn off alpha channel
			client.resizeCanvas();

			// Force the client to reload the scene to reset any scene modifications & update GPU flags
			if (client.getGameState() == GameState.LOGGED_IN)
				client.setGameState(GameState.LOADING);
		});
	}

	public void stopPlugin() {
		SwingUtilities.invokeLater(() -> {
			try {
				pluginManager.setPluginEnabled(this, false);
				pluginManager.stopPlugin(this);
			} catch (PluginInstantiationException ex) {
				log.error("Error while stopping 117HD:", ex);
			}
		});

		shutDown();
	}

	public void restartPlugin() {
		clientThread.invoke(() -> {
			shutDown();
			// Validate the canvas so it becomes valid without having to manually resize the client
			canvas.validate();
			startUp();
		});
	}

	@Nullable
	public SceneContext getSceneContext() {
		return renderer == null ? null : renderer.getSceneContext();
	}

	public void toggleFreezeFrame() {
		clientThread.invoke(() -> {
			enableFreezeFrame = !enableFreezeFrame;
			if (enableFreezeFrame)
				redrawPreviousFrame = true;
		});
	}

	private String generateFetchCases(String array, int from, int to) {
		int length = to - from;
		if (length <= 1)
			return array + "[" + from + "]";
		int middle = from + length / 2;
		return "i < " + middle +
			" ? " + generateFetchCases(array, from, middle) +
			" : " + generateFetchCases(array, middle, to);
	}

	public String generateGetter(String type, int arrayLength) {
		StringBuilder include = new StringBuilder();

		if (config.macosIntelWorkaround() && !APPLE_ARM) {
			// Workaround wrapper for drivers that do not support dynamic indexing,
			// particularly Intel drivers on macOS
			include
				.append(type)
				.append(" ")
				.append("get")
				.append(type)
				.append("(int i) { return ")
				.append(generateFetchCases(type + "Array", 0, arrayLength))
				.append("; }\n");
		} else {
			include
				.append("#define get")
				.append(type)
				.append("(i) ")
				.append(type)
				.append("Array[i]\n");
		}

		return include.toString();
	}

	public ShaderIncludes getShaderIncludes() {
		var includes = new ShaderIncludes()
			.addIncludePath(SHADER_PATH)
			.addInclude("VERSION_HEADER", OSType.getOSType() == OSType.Linux ? LINUX_VERSION_HEADER : WINDOWS_VERSION_HEADER)
			.define("UI_SCALING_MODE", config.uiScalingMode())
			.define("COLOR_BLINDNESS", config.colorBlindness())
			.define("APPLY_COLOR_FILTER", configColorFilter != ColorFilter.NONE)
			.define("MATERIAL_COUNT", MaterialManager.MATERIALS.length)
			.define("WATER_TYPE_COUNT", waterTypeManager.uboWaterTypes.getCount())
			.define("DYNAMIC_LIGHTS", configDynamicLights != DynamicLights.NONE)
			.define("TILED_LIGHTING", configTiledLighting)
			.define("TILED_LIGHTING_LAYER_COUNT", configDynamicLights.getTiledLightingLayers())
			.define("TILED_LIGHTING_TILE_SIZE", TILED_LIGHTING_TILE_SIZE)
			.define("MAX_LIGHT_COUNT", configTiledLighting ? UBOLights.MAX_LIGHTS : configDynamicLights.getMaxSceneLights())
			.define("NORMAL_MAPPING", config.normalMapping())
			.define("PARALLAX_OCCLUSION_MAPPING", config.parallaxOcclusionMapping())
			.define("SHADOW_MODE", configShadowMode)
			.define("SHADOW_TRANSPARENCY", config.enableShadowTransparency())
			.define("PIXELATED_SHADOWS", config.pixelatedShadows())
			.define("VANILLA_COLOR_BANDING", config.vanillaColorBanding())
			.define("UNDO_VANILLA_SHADING", configShadingMode.undoVanillaShading)
			.define("LEGACY_GREY_COLORS", configLegacyGreyColors)
			.define("DISABLE_DIRECTIONAL_SHADING", !configShadingMode.directionalShading)
			.define("FLAT_SHADING", config.flatShading())
			.define("WIND_DISPLACEMENT", configWindDisplacement)
			.define("WIND_DISPLACEMENT_NOISE_RESOLUTION", WIND_DISPLACEMENT_NOISE_RESOLUTION)
			.define("CHARACTER_DISPLACEMENT", configCharacterDisplacement)
			.define("MAX_CHARACTER_POSITION_COUNT", max(1, UBOCompute.MAX_CHARACTER_POSITION_COUNT))
			.define("WIREFRAME", config.wireframe())
			.define("WINDOWS_HDR_CORRECTION", config.windowsHdrCorrection())
			.define("LEGACY_RENDERER", renderer instanceof LegacyRenderer)
			.define("ZONE_RENDERER", renderer instanceof ZoneRenderer)
			.define("MAX_SIMULTANEOUS_WORLD_VIEWS", 0)
			.define("WORLD_VIEW_GETTER", "")
			.addInclude(
				"MATERIAL_CONSTANTS", () -> {
					StringBuilder include = new StringBuilder();
					for (var entry : MaterialManager.MATERIAL_MAP.entrySet()) {
						include
							.append("#define MAT_")
							.append(entry.getKey().toUpperCase())
							.append(" getMaterial(")
							.append(entry.getValue().uboIndex)
							.append(")\n");
					}
					return include.toString();
				}
			)
			.addInclude("MATERIAL_GETTER", () -> generateGetter("Material", MaterialManager.MATERIALS.length))
			.addInclude("WATER_TYPE_GETTER", () -> generateGetter("WaterType", waterTypeManager.uboWaterTypes.getCount()))
			.addUniformBuffer(uboGlobal)
			.addUniformBuffer(uboLights)
			.addUniformBuffer(uboLightsCulling)
			.addUniformBuffer(uboUI)
			.addUniformBuffer(materialManager.uboMaterials)
			.addUniformBuffer(waterTypeManager.uboWaterTypes);
		renderer.addShaderIncludes(includes);
		return includes;
	}

	private void initializeShaders() throws ShaderException, IOException {
		var includes = getShaderIncludes();

		// Bind a valid VAO, otherwise validation may fail on older Intel-based Macs
		glBindVertexArray(vaoTri);

		renderer.initializeShaders(includes);
		uiProgram.compile(includes);

		if (configDynamicLights != DynamicLights.NONE && configTiledLighting) {
			if (!AMD_GPU && configTiledLightingImageLoadStore &&
				GL_CAPS.GL_ARB_shader_image_load_store &&
				tiledLightingImageStoreProgram.isViable()
			) {
				try {
					tiledLightingImageStoreProgram.compile(includes
						.define("TILED_IMAGE_STORE", true)
						.define("TILED_LIGHTING_LAYER", false));
				} catch (ShaderException ex) {
					log.warn("Disabling TILED_IMAGE_STORE due to:", ex);
				}
			}

			// Compile layered version if the image store version isn't supported or failed to compile
			if (!tiledLightingImageStoreProgram.isValid()) {
				try {
					for (int layer = 0; layer < DynamicLights.MAX_LAYERS_PER_TILE; layer++) {
						var shader = new TiledLightingShaderProgram();
						shader.compile(includes
							.define("TILED_IMAGE_STORE", false)
							.define("TILED_LIGHTING_LAYER", layer));
						tiledLightingShaderPrograms.add(shader);
					}
				} catch (ShaderException ex) {
					log.warn("Disabling TILED_LIGHTING_LAYERED due to:", ex);
					// If both tiled lighting implementations fail, fall back to the old lighting, and warn about it
					if (!Props.DEVELOPMENT) {
						config.tiledLighting(false);
						PopupUtils.displayPopupMessage(
							client, "117 HD Error",
							"Tiled lighting has been automatically disabled, since it failed to compile on your GPU.<br>" +
							"<br>GPU name: " + glGetString(GL_RENDERER) + "<br><br>" +
							"If you want to help us make it work on your system, please join our " +
							"<a href=\"" + HdPlugin.DISCORD_URL + "\">Discord</a> server, and<br>" +
							"click the \"Open logs folder\" button below, find the file named \"client\" or \"client.log\",<br>" +
							"then drag and drop that file into one of our support channels.",
							new String[] { "Open logs folder", "Ok" },
							i -> {
								if (i == 0) {
									LinkBrowser.open(RuneLite.LOGS_DIR.toString());
									return false;
								}
								return true;
							}
						);
					}
					configTiledLighting = false;
				}
			}
		}

		checkGLErrors();

		eventBus.post(new ShaderRecompile(includes));
	}

	private void destroyShaders() {
		renderer.destroyShaders();
		uiProgram.destroy();

		tiledLightingImageStoreProgram.destroy();
		for (var program : tiledLightingShaderPrograms)
			program.destroy();
		tiledLightingShaderPrograms.clear();
	}

	public void recompilePrograms() {
		// Only recompile if the programs have been compiled successfully before
		if (!uiProgram.isValid())
			return;

		clientThread.invoke(() -> {
			try {
				renderer.waitUntilIdle();
				destroyShaders();
				initializeShaders();
			} catch (ShaderException | IOException ex) {
				// TODO: If each shader compilation leaves the previous working shader intact, we wouldn't need to shut down on failure
				log.error("Error while recompiling shaders:", ex);
				stopPlugin();
			}
		});
	}

	private void initializeVaos() {
		{
			// Create quad VAO
			vaoQuad = glGenVertexArrays();
			vboQuad = glGenBuffers();
			glBindVertexArray(vaoQuad);

			FloatBuffer vboQuadData = BufferUtils.createFloatBuffer(16)
				.put(new float[] {
					// x, y, u, v
					1, 1, 1, 1, // top right
					-1, 1, 0, 1, // top left
					-1, -1, 0, 0, // bottom left
					1, -1, 1, 0 // bottom right
				})
				.flip();
			glBindBuffer(GL_ARRAY_BUFFER, vboQuad);
			glBufferData(GL_ARRAY_BUFFER, vboQuadData, GL_STATIC_DRAW);

			// position attribute
			glVertexAttribPointer(0, 2, GL_FLOAT, false, 4 * Float.BYTES, 0);
			glEnableVertexAttribArray(0);

			// texture coord attribute
			glVertexAttribPointer(1, 2, GL_FLOAT, false, 4 * Float.BYTES, 2 * Float.BYTES);
			glEnableVertexAttribArray(1);
		}

		{
			// Create tri VAO
			vaoTri = glGenVertexArrays();
			vboTri = glGenBuffers();
			glBindVertexArray(vaoTri);

			FloatBuffer vboTriData = BufferUtils.createFloatBuffer(12)
				.put(new float[] {
					// x, y, u, v
					-1, -1, 0, 0, // bottom left
					3, -1, 2, 0, // bottom right (off-screen)
					-1, 3, 0, 2 // top left (off-screen)
				})
				.flip();
			glBindBuffer(GL_ARRAY_BUFFER, vboTri);
			glBufferData(GL_ARRAY_BUFFER, vboTriData, GL_STATIC_DRAW);

			// position attribute
			glVertexAttribPointer(0, 2, GL_FLOAT, false, 4 * Float.BYTES, 0);
			glEnableVertexAttribArray(0);

			// texture coord attribute
			glVertexAttribPointer(1, 2, GL_FLOAT, false, 4 * Float.BYTES, 2 * Float.BYTES);
			glEnableVertexAttribArray(1);
		}
	}

	private void destroyVaos() {
		if (vboQuad != 0)
			glDeleteBuffers(vboQuad);
		vboQuad = 0;

		if (vaoQuad != 0)
			glDeleteVertexArrays(vaoQuad);
		vaoQuad = 0;

		if (vboTri != 0)
			glDeleteBuffers(vboTri);
		vboTri = 0;

		if (vaoTri != 0)
			glDeleteVertexArrays(vaoTri);
		vaoTri = 0;
	}

	private void initializeUbos() {
		uboGlobal.initialize(HdPlugin.UNIFORM_BLOCK_GLOBAL);
		uboLights.initialize(HdPlugin.UNIFORM_BLOCK_LIGHTS);
		uboLightsCulling.initialize(HdPlugin.UNIFORM_BLOCK_LIGHTS_CULLING);
		uboUI.initialize(HdPlugin.UNIFORM_BLOCK_UI);
	}

	private void destroyUbos() {
		uboGlobal.destroy();
		uboLights.destroy();
		uboLightsCulling.destroy();
		uboUI.destroy();
	}

	private void initializeUiTexture() {
		pboUi = glGenBuffers();

		texUi = glGenTextures();
		glActiveTexture(TEXTURE_UNIT_UI);
		glBindTexture(GL_TEXTURE_2D, texUi);
		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);
		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
	}

	private void destroyUiTexture() {
		uiResolution = null;

		if (pboUi != 0)
			glDeleteBuffers(pboUi);
		pboUi = 0;

		if (texUi != 0)
			glDeleteTextures(texUi);
		texUi = 0;
	}

	public void updateTiledLightingFbo() {
		assert configTiledLighting;

		int[] newResolution = max(ivec(1), round(divide(vec(sceneResolution), TILED_LIGHTING_TILE_SIZE)));
		int newLayerCount = configDynamicLights.getTiledLightingLayers();
		if (Arrays.equals(newResolution, tiledLightingResolution) && tiledLightingLayerCount == newLayerCount)
			return;

		destroyTiledLightingFbo();

		tiledLightingResolution = newResolution;
		tiledLightingLayerCount = newLayerCount;

		fboTiledLighting = glGenFramebuffers();
		texTiledLighting = glGenTextures();
		glActiveTexture(TEXTURE_UNIT_TILED_LIGHTING_MAP);
		glBindTexture(GL_TEXTURE_2D_ARRAY, texTiledLighting);
		glTexParameteri(GL_TEXTURE_2D_ARRAY, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
		glTexParameteri(GL_TEXTURE_2D_ARRAY, GL_TEXTURE_MAG_FILTER, GL_NEAREST);
		glTexParameteri(GL_TEXTURE_2D_ARRAY, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
		glTexParameteri(GL_TEXTURE_2D_ARRAY, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);
		glTexImage3D(
			GL_TEXTURE_2D_ARRAY,
			0,
			GL_RGBA16UI,
			tiledLightingResolution[0],
			tiledLightingResolution[1],
			tiledLightingLayerCount,
			0,
			GL_RGBA_INTEGER,
			GL_UNSIGNED_SHORT,
			0
		);

		glBindFramebuffer(GL_FRAMEBUFFER, fboTiledLighting);
		glFramebufferTexture(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, texTiledLighting, 0);
		checkGLErrors();

		if (tiledLightingImageStoreProgram.isValid())
			ARBShaderImageLoadStore.glBindImageTexture(
				IMAGE_UNIT_TILED_LIGHTING, texTiledLighting, 0, true, 0, GL_WRITE_ONLY, GL_RGBA16UI);

		glBindFramebuffer(GL_FRAMEBUFFER, awtContext.getFramebuffer(false));

		checkGLErrors();

		uboGlobal.tiledLightingResolution.set(tiledLightingResolution);
		uboGlobal.upload(); // Ensure this is up to date with rendering
	}

	private void destroyTiledLightingFbo() {
		tiledLightingResolution = null;

		if (fboTiledLighting != 0)
			glDeleteFramebuffers(fboTiledLighting);
		fboTiledLighting = 0;

		if (texTiledLighting != 0)
			glDeleteTextures(texTiledLighting);
		texTiledLighting = 0;
	}

	public void updateSceneFbo() {
		if (uiResolution == null)
			return;

		int[] viewport = {
			client.getViewportXOffset(),
			uiResolution[1] - (client.getViewportYOffset() + client.getViewportHeight()),
			client.getViewportWidth(),
			client.getViewportHeight()
		};

		// Skip rendering when there's no viewport to render to, which happens while world hopping
		if (viewport[2] == 0 || viewport[3] == 0)
			return;

		// DPI scaling and stretched mode also affects the game's viewport
		divide(sceneViewportScale, vec(actualUiResolution), vec(uiResolution));
		if (sceneViewportScale[0] != 1 || sceneViewportScale[1] != 1) {
			// Pad the viewport before scaling, so it always covers the game's viewport in the UI
			for (int i = 0; i < 2; i++) {
				viewport[i] -= 1;
				viewport[i + 2] += 2;
			}
			viewport = round(multiply(vec(viewport), sceneViewportScale));
		}

		// Check if scene FBO needs to be recreated
		if (Arrays.equals(sceneViewport, viewport))
			return;

		destroySceneFbo();
		sceneViewport = viewport;

		// Bind default FBO to check whether anti-aliasing is forced
		int defaultFramebuffer = awtContext.getFramebuffer(false);
		glBindFramebuffer(GL_FRAMEBUFFER, defaultFramebuffer);
		final int forcedAASamples = glGetInteger(GL_SAMPLES);
		msaaSamples = forcedAASamples != 0 ? forcedAASamples : min(config.antiAliasingMode().getSamples(), glGetInteger(GL_MAX_SAMPLES));

		// Since there's seemingly no reliable way to check if the default framebuffer will do sRGB conversions with GL_FRAMEBUFFER_SRGB
		// enabled, we always replace the default framebuffer with an sRGB one. We could technically support rendering to the default
		// framebuffer when sRGB conversions aren't needed, but the goal is to transition to linear blending in the future anyway.
		boolean sRGB = false; // This is currently unused

		// Some implementations (*cough* Apple) complain when blitting from an FBO without an alpha channel to a (default) FBO with alpha.
		// To work around this, we select a format which includes an alpha channel, even though we don't need it.
		int defaultColorAttachment = defaultFramebuffer == 0 ? GL_BACK_LEFT : GL_COLOR_ATTACHMENT0;
		int alphaBits = glGetFramebufferAttachmentParameteri(GL_FRAMEBUFFER, defaultColorAttachment, GL_FRAMEBUFFER_ATTACHMENT_ALPHA_SIZE);
		checkGLErrors();
		boolean alpha = alphaBits > 0;

		int[] desiredFormats = sRGB ?
			alpha ? RENDERBUFFER_FORMATS_SRGB_WITH_ALPHA : RENDERBUFFER_FORMATS_SRGB :
			alpha ? RENDERBUFFER_FORMATS_LINEAR_WITH_ALPHA : RENDERBUFFER_FORMATS_LINEAR;

		float resolutionScale = config.sceneResolutionScale() / 100f;
		sceneResolution = round(max(vec(1), multiply(slice(vec(sceneViewport), 2), resolutionScale)));
		uboGlobal.sceneResolution.set(sceneResolution);
		uboGlobal.upload(); // Ensure this is up to date with rendering

		// Create and bind the FBO
		fboScene = glGenFramebuffers();
		glBindFramebuffer(GL_FRAMEBUFFER, fboScene);

		// Create color render buffer
		rboSceneColor = glGenRenderbuffers();
		glBindRenderbuffer(GL_RENDERBUFFER, rboSceneColor);

		// Flush out all pending errors, so we can check whether the next step succeeds
		clearGLErrors();

		int format = 0;
		for (int desiredFormat : desiredFormats) {
			glRenderbufferStorageMultisample(GL_RENDERBUFFER, msaaSamples, desiredFormat, sceneResolution[0], sceneResolution[1]);

			if (glGetError() == GL_NO_ERROR) {
				format = desiredFormat;
				break;
			}
		}

		if (format == 0)
			throw new RuntimeException("No supported " + (sRGB ? "sRGB" : "linear") + " formats");

		// Found a usable format. Bind the RBO to the scene FBO
		glFramebufferRenderbuffer(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_RENDERBUFFER, rboSceneColor);
		checkGLErrors();

		// Create depth render buffer
		rboSceneDepth = glGenRenderbuffers();
		glBindRenderbuffer(GL_RENDERBUFFER, rboSceneDepth);
		glRenderbufferStorageMultisample(GL_RENDERBUFFER, msaaSamples, GL_DEPTH_COMPONENT32F, sceneResolution[0], sceneResolution[1]);
		glFramebufferRenderbuffer(GL_FRAMEBUFFER, GL_DEPTH_ATTACHMENT, GL_RENDERBUFFER, rboSceneDepth);
		checkGLErrors();

		// If necessary, create an FBO for resolving multisampling
		if (msaaSamples > 1 && resolutionScale != 1) {
			fboSceneResolve = glGenFramebuffers();
			glBindFramebuffer(GL_FRAMEBUFFER, fboSceneResolve);
			rboSceneResolveColor = glGenRenderbuffers();
			glBindRenderbuffer(GL_RENDERBUFFER, rboSceneResolveColor);
			glRenderbufferStorageMultisample(GL_RENDERBUFFER, 0, format, sceneResolution[0], sceneResolution[1]);
			glFramebufferRenderbuffer(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_RENDERBUFFER, rboSceneResolveColor);
			checkGLErrors();
		}

		// Reset
		glBindFramebuffer(GL_FRAMEBUFFER, awtContext.getFramebuffer(false));
		glBindRenderbuffer(GL_RENDERBUFFER, 0);
	}

	private void destroySceneFbo() {
		sceneViewport = null;

		if (fboScene != 0)
			glDeleteFramebuffers(fboScene);
		fboScene = 0;

		if (rboSceneColor != 0)
			glDeleteRenderbuffers(rboSceneColor);
		rboSceneColor = 0;

		if (rboSceneDepth != 0)
			glDeleteRenderbuffers(rboSceneDepth);
		rboSceneDepth = 0;

		if (fboSceneResolve != 0)
			glDeleteFramebuffers(fboSceneResolve);
		fboSceneResolve = 0;

		if (rboSceneResolveColor != 0)
			glDeleteRenderbuffers(rboSceneResolveColor);
		rboSceneResolveColor = 0;
	}

	private void initializeShadowMapFbo() {
		if (!configShadowsEnabled) {
			initializeDummyShadowMap();
			return;
		}

		// Create and bind the FBO
		fboShadowMap = glGenFramebuffers();
		glBindFramebuffer(GL_FRAMEBUFFER, fboShadowMap);

		// Create texture
		texShadowMap = glGenTextures();
		glActiveTexture(TEXTURE_UNIT_SHADOW_MAP);
		glBindTexture(GL_TEXTURE_2D, texShadowMap);

		shadowMapResolution = config.shadowResolution().getValue();
		int maxResolution = glGetInteger(GL_MAX_TEXTURE_SIZE);
		if (maxResolution < shadowMapResolution) {
			log.info("Capping shadow resolution from {} to {}", shadowMapResolution, maxResolution);
			shadowMapResolution = maxResolution;
		}

		glTexImage2D(
			GL_TEXTURE_2D,
			0,
			GL_DEPTH_COMPONENT24,
			shadowMapResolution,
			shadowMapResolution,
			0,
			GL_DEPTH_COMPONENT,
			GL_FLOAT,
			0
		);
		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);
		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_BORDER);
		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_BORDER);

		float[] color = { 1, 1, 1, 1 };
		glTexParameterfv(GL_TEXTURE_2D, GL_TEXTURE_BORDER_COLOR, color);

		// Bind texture
		glFramebufferTexture2D(GL_FRAMEBUFFER, GL_DEPTH_ATTACHMENT, GL_TEXTURE_2D, texShadowMap, 0);
		glDrawBuffer(GL_NONE);
		glReadBuffer(GL_NONE);

		// Reset FBO
		glBindFramebuffer(GL_FRAMEBUFFER, awtContext.getFramebuffer(false));
	}

	private void initializeDummyShadowMap() {
		// Create dummy texture
		texShadowMap = glGenTextures();
		glActiveTexture(TEXTURE_UNIT_SHADOW_MAP);
		glBindTexture(GL_TEXTURE_2D, texShadowMap);
		glTexImage2D(GL_TEXTURE_2D, 0, GL_DEPTH_COMPONENT, 1, 1, 0, GL_DEPTH_COMPONENT, GL_FLOAT, 0);
		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);
		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_BORDER);
		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_BORDER);
	}

	private void destroyShadowMapFbo() {
		if (texShadowMap != 0)
			glDeleteTextures(texShadowMap);
		texShadowMap = 0;

		if (fboShadowMap != 0)
			glDeleteFramebuffers(fboShadowMap);
		fboShadowMap = 0;
	}

	public void initializeShaderHotswapping() {
		SHADER_PATH.watch("\\.(glsl|cl)$", path -> {
			log.info("Recompiling shaders: {}", path);
			recompilePrograms();
		});
	}

	public void prepareInterfaceTexture() {
		int[] resolution = {
			max(1, client.getCanvasWidth()),
			max(1, client.getCanvasHeight())
		};
		boolean resize = !Arrays.equals(uiResolution, resolution);
		if (resize) {
			uiResolution = resolution;

			glBindBuffer(GL_PIXEL_UNPACK_BUFFER, pboUi);
			glBufferData(GL_PIXEL_UNPACK_BUFFER, uiResolution[0] * uiResolution[1] * 4L, GL_STREAM_DRAW);
			glBindBuffer(GL_PIXEL_UNPACK_BUFFER, 0);

			glActiveTexture(TEXTURE_UNIT_UI);
			glBindTexture(GL_TEXTURE_2D, texUi);
			glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, uiResolution[0], uiResolution[1], 0, GL_BGRA, GL_UNSIGNED_BYTE, 0);
		}

		if (client.isStretchedEnabled()) {
			Dimension dim = client.getStretchedDimensions();
			actualUiResolution[0] = dim.width;
			actualUiResolution[1] = dim.height;
		} else {
			copyTo(actualUiResolution, uiResolution);
		}
		round(actualUiResolution, multiply(vec(actualUiResolution), getDpiScaling()));

		if (configAsyncUICopy) {
			// Start copying the UI on a different thread, to be uploaded during the next frame
			asyncUICopy.prepare(pboUi, texUi);
			// If the window was just resized, upload once synchronously so there is something to show
			if (resize)
				asyncUICopy.complete();
			return;
		}

		final BufferProvider bufferProvider = client.getBufferProvider();
		final int[] pixels = bufferProvider.getPixels();
		final int width = bufferProvider.getWidth();
		final int height = bufferProvider.getHeight();

		frameTimer.begin(Timer.MAP_UI_BUFFER);
		glBindBuffer(GL_PIXEL_UNPACK_BUFFER, pboUi);
		ByteBuffer mappedBuffer = glMapBuffer(GL_PIXEL_UNPACK_BUFFER, GL_WRITE_ONLY);
		frameTimer.end(Timer.MAP_UI_BUFFER);
		if (mappedBuffer == null) {
			log.error("Unable to map interface PBO. Skipping UI...");
		} else if (width > uiResolution[0] || height > uiResolution[1]) {
			log.error("UI texture resolution mismatch ({}x{} > {}). Skipping UI...", width, height, uiResolution);
		} else {
			frameTimer.begin(Timer.COPY_UI);
			mappedBuffer.asIntBuffer().put(pixels, 0, width * height);
			frameTimer.end(Timer.COPY_UI);

			frameTimer.begin(Timer.UPLOAD_UI);
			glUnmapBuffer(GL_PIXEL_UNPACK_BUFFER);
			glActiveTexture(TEXTURE_UNIT_UI);
			glBindTexture(GL_TEXTURE_2D, texUi);
			glTexSubImage2D(GL_TEXTURE_2D, 0, 0, 0, width, height, GL_BGRA, GL_UNSIGNED_INT_8_8_8_8_REV, 0);
			frameTimer.end(Timer.UPLOAD_UI);
		}
		glBindBuffer(GL_PIXEL_UNPACK_BUFFER, 0);
	}

	public void drawUi(int overlayColor) {
		if (uiResolution == null || developerTools.isHideUiEnabled() && hasLoggedIn)
			return;

		// Fix vanilla bug causing the overlay to remain on the login screen in areas like Fossil Island underwater
		if (client.getGameState().getState() < GameState.LOADING.getState())
			overlayColor = 0;

		frameTimer.begin(Timer.RENDER_UI);

		glBindFramebuffer(GL_FRAMEBUFFER, awtContext.getFramebuffer(false));
		// Disable alpha writes, just in case the default FBO has an alpha channel
		glColorMask(true, true, true, false);

		glViewport(0, 0, actualUiResolution[0], actualUiResolution[1]);

		tiledLightingOverlay.render();

		uiProgram.use();
		uboUI.sourceDimensions.set(uiResolution);
		uboUI.targetDimensions.set(actualUiResolution);
		uboUI.alphaOverlay.set(ColorUtils.srgba(overlayColor));
		uboUI.upload();

		if (configAsyncUICopy) {
			frameTimer.begin(Timer.UPLOAD_UI);
			asyncUICopy.complete();
			frameTimer.end(Timer.UPLOAD_UI);
		}

		// Set the sampling function used when stretching the UI.
		// This is probably better done with sampler objects instead of texture parameters, but this is easier and likely more portable.
		// See https://www.khronos.org/opengl/wiki/Sampler_Object for details.
		// GL_NEAREST makes sampling for bicubic/xBR simpler, so it should be used whenever linear/pixel isn't
		final int function = config.uiScalingMode().glSamplingFunction;
		glActiveTexture(TEXTURE_UNIT_UI);
		glBindTexture(GL_TEXTURE_2D, texUi);
		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, function);
		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, function);

		glEnable(GL_BLEND);
		glBlendFuncSeparate(GL_ONE, GL_ONE_MINUS_SRC_ALPHA, GL_ZERO, GL_ONE);
		glBindVertexArray(vaoTri);
		glDrawArrays(GL_TRIANGLES, 0, 3);

		shadowMapOverlay.render();
		gammaCalibrationOverlay.render();

		// Reset
		glBlendFuncSeparate(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA, GL_ZERO, GL_ONE);
		glDisable(GL_BLEND);
		glColorMask(true, true, true, true);

		frameTimer.end(Timer.RENDER_UI);
	}

	/**
	 * Convert the front framebuffer to an Image
	 */
	public Image screenshot() {
		if (uiResolution == null)
			return null;

		int width = actualUiResolution[0];
		int height = actualUiResolution[1];

		ByteBuffer buffer = BufferUtils.createByteBuffer(width * height * 4);

		glReadBuffer(awtContext.getBufferMode());
		glReadPixels(0, 0, width, height, GL_RGBA, GL_UNSIGNED_BYTE, buffer);

		BufferedImage image = new BufferedImage(width, height, BufferedImage.TYPE_INT_RGB);
		int[] pixels = ((DataBufferInt) image.getRaster().getDataBuffer()).getData();

		for (int y = 0; y < height; ++y)
		{
			for (int x = 0; x < width; ++x)
			{
				int r = buffer.get() & 0xff;
				int g = buffer.get() & 0xff;
				int b = buffer.get() & 0xff;
				buffer.get(); // alpha

				pixels[(height - y - 1) * width + x] = (r << 16) | (g << 8) | b;
			}
		}

		return image;
	}

	@Subscribe
	public void onGameStateChanged(GameStateChanged gameStateChanged) {
		if (gameStateChanged.getGameState() == GameState.LOGIN_SCREEN) {
			hasLoggedIn = false;
			environmentManager.reset();
		}
	}

	public boolean isLoadingScene() {
		return renderer.isLoadingScene();
	}

	private void updateCachedConfigs() {
		configShadowMode = config.shadowMode();
		configShadowsEnabled = configShadowMode != ShadowMode.OFF;
		configRoofShadows = config.roofShadows();
		configGroundTextures = config.groundTextures();
		configGroundBlending = config.groundBlending();
		configModelTextures = config.modelTextures();
		configLegacyTzHaarReskin = config.legacyTzHaarReskin();
		configProjectileLights = config.projectileLights();
		configNpcLights = config.npcLights();
		configVanillaShadowMode = config.vanillaShadowMode();
		configHideFakeShadows = configVanillaShadowMode != VanillaShadowMode.SHOW;
		configLegacyGreyColors = config.legacyGreyColors();
		configModelBatching = config.modelBatching();
		configModelCaching = config.modelCaching();
		configDynamicLights = config.dynamicLights();
		configTiledLighting = config.tiledLighting();
		configTiledLightingImageLoadStore = config.tiledLightingImageLoadStore();
		configDetailDrawDistance = config.detailDrawDistance();
		configExpandShadowDraw = config.expandShadowDraw();
		configUseFasterModelHashing = config.fasterModelHashing();
		configZoneStreaming = config.zoneStreaming();
		configShadingMode = config.shadingMode();
		configUnlitFaceColors = configShadingMode.unlitFaceColors;
		configUndoVanillaShading = configShadingMode.undoVanillaShading;
		configPreserveVanillaNormals = config.preserveVanillaNormals();
		configAsyncUICopy = config.asyncUICopy();
		configWindDisplacement = config.windDisplacement();
		configCharacterDisplacement = config.characterDisplacement();
		configSeasonalTheme = config.seasonalTheme();
		configSeasonalHemisphere = config.seasonalHemisphere();

		var newColorFilter = config.colorFilter();
		if (newColorFilter != configColorFilter) {
			configColorFilterPrevious = configColorFilter;
			configColorFilter = newColorFilter;
			colorFilterChangedAt = System.currentTimeMillis();
		}
		if (configColorFilter == ColorFilter.CEL_SHADING) {
			configGroundTextures = false;
			configModelTextures = false;
		}

		if (configSeasonalTheme == SeasonalTheme.AUTOMATIC) {
			var time = ZonedDateTime.now(ZoneOffset.UTC);

			if (configSeasonalHemisphere == SeasonalHemisphere.NORTHERN) {
				switch (time.getMonth()) {
					case SEPTEMBER:
					case OCTOBER:
					case NOVEMBER:
						configSeasonalTheme = SeasonalTheme.AUTUMN;
						break;
					case DECEMBER:
					case JANUARY:
					case FEBRUARY:
						configSeasonalTheme = SeasonalTheme.WINTER;
						break;
					default:
						configSeasonalTheme = SeasonalTheme.SUMMER;
						break;
				}
			} else {
				switch (time.getMonth()) {
					case MARCH:
					case APRIL:
					case MAY:
						configSeasonalTheme = SeasonalTheme.AUTUMN;
						break;
					case JUNE:
					case JULY:
					case AUGUST:
						configSeasonalTheme = SeasonalTheme.WINTER;
						break;
					default:
						configSeasonalTheme = SeasonalTheme.SUMMER;
						break;
				}
			}
		}
	}

	@Subscribe
	public void onConfigChanged(ConfigChanged event) {
		// Exit if the plugin is off, the config is unrelated to the plugin, or if switching to a profile with the plugin turned off
		if (!isActive || !event.getGroup().equals(CONFIG_GROUP) || !pluginManager.isPluginEnabled(this))
			return;

		synchronized (this) {
			pendingConfigChanges.add(event.getKey());
			// Process pending config changes after the EDT is done with any pending work, which could include further config changes
			SwingUtilities.invokeLater(this::processPendingConfigChanges);
		}
	}

	public void processPendingConfigChanges() {
		clientThread.invoke(() -> {
			if (pendingConfigChanges.isEmpty())
				return;

			try {
				sceneManager.getLoadingLock().lock();
				sceneManager.completeAllStreaming();

				// Synchronize with scene loading
				synchronized (this) {
					updateCachedConfigs();

					log.debug("Processing {} pending config changes: {}", pendingConfigChanges.size(), pendingConfigChanges);

					renderer.processConfigChanges(pendingConfigChanges);

					boolean recompilePrograms = false;
					boolean recreateSceneFbo = false;
					boolean recreateShadowMapFbo = false;
					boolean reloadTexturesAndMaterials = false;
					boolean reloadEnvironments = false;
					boolean reloadModelOverrides = false;
					boolean reloadTileOverrides = false;
					boolean reloadScene = false;

					for (var key : pendingConfigChanges) {
						switch (key) {
							case KEY_LOW_MEMORY_MODE:
							case KEY_REMOVE_VERTEX_SNAPPING:
							case KEY_LEGACY_RENDERER:
							case KEY_FORCE_INDIRECT_DRAW:
							case KEY_SHADING_MODE:
								restartPlugin();
								// since we'll be restarting the plugin anyway, skip pending changes
								return;
							case KEY_SEASONAL_THEME:
							case KEY_SEASONAL_HEMISPHERE:
							case KEY_GROUND_BLENDING:
							case KEY_GROUND_TEXTURES:
								reloadTileOverrides = true;
								break;
							case KEY_COLOR_FILTER:
								if (configColorFilter == ColorFilter.NONE || configColorFilterPrevious == ColorFilter.NONE)
									recompilePrograms = true;
								if (configColorFilter == ColorFilter.CEL_SHADING || configColorFilterPrevious == ColorFilter.CEL_SHADING)
									reloadScene = true;
								break;
							case KEY_ASYNC_UI_COPY:
								asyncUICopy.complete();
								break;
						}

						switch (key) {
							case KEY_EXPANDED_MAP_LOADING_CHUNKS:
								client.setExpandedMapLoading(getExpandedMapLoadingChunks());
								// fall-through
							case KEY_HIDE_UNRELATED_AREAS:
								if (client.getGameState() == GameState.LOGGED_IN)
									client.setGameState(GameState.LOADING);
								break;
							case KEY_COLOR_BLINDNESS:
							case KEY_MACOS_INTEL_WORKAROUND:
							case KEY_DYNAMIC_LIGHTS:
							case KEY_TILED_LIGHTING:
							case KEY_TILED_LIGHTING_IMAGE_STORE:
							case KEY_NORMAL_MAPPING:
							case KEY_PARALLAX_OCCLUSION_MAPPING:
							case KEY_UI_SCALING_MODE:
							case KEY_VANILLA_COLOR_BANDING:
							case KEY_WIND_DISPLACEMENT:
							case KEY_CHARACTER_DISPLACEMENT:
							case KEY_WIREFRAME:
							case KEY_PIXELATED_SHADOWS:
							case KEY_WINDOWS_HDR_CORRECTION:
								recompilePrograms = true;
								break;
							case KEY_ANTI_ALIASING_MODE:
							case KEY_SCENE_RESOLUTION_SCALE:
								recreateSceneFbo = true;
								break;
							case KEY_SHADOW_MODE:
							case KEY_SHADOW_TRANSPARENCY:
								recompilePrograms = true;
								// fall-through
							case KEY_SHADOW_RESOLUTION:
								recreateShadowMapFbo = true;
								break;
							case KEY_ATMOSPHERIC_LIGHTING:
							case KEY_LEGACY_TOB_ENVIRONMENT:
								reloadEnvironments = true;
								break;
							case KEY_SEASONAL_THEME:
							case KEY_SEASONAL_HEMISPHERE:
								reloadEnvironments = true;
								reloadModelOverrides = true;
								// fall-through
							case KEY_ANISOTROPIC_FILTERING_LEVEL:
							case KEY_GROUND_TEXTURES:
							case KEY_MODEL_TEXTURES:
							case KEY_TEXTURE_RESOLUTION:
							case KEY_HD_INFERNAL_CAPE:
								reloadTexturesAndMaterials = true;
								// fall-through
							case KEY_GROUND_BLENDING:
							case KEY_FILL_GAPS_IN_TERRAIN:
							case KEY_LEGACY_TZHAAR_RESKIN:
								reloadScene = true;
								break;
							case KEY_VANILLA_SHADOW_MODE:
								reloadModelOverrides = true;
								reloadScene = true;
								break;
							case KEY_LEGACY_GREY_COLORS:
							case KEY_PRESERVE_VANILLA_NORMALS:
							case KEY_SHADING_MODE:
							case KEY_FLAT_SHADING:
								recompilePrograms = true;
								reloadScene = true;
								break;
							case KEY_FPS_TARGET:
							case KEY_UNLOCK_FPS:
							case KEY_VSYNC_MODE:
								setupSyncMode();
								break;
						}
					}

					if (reloadTexturesAndMaterials || recompilePrograms)
						renderer.waitUntilIdle();

					if (reloadTexturesAndMaterials) {
						materialManager.reload(reloadScene);
						modelOverrideManager.reload();
						recompilePrograms = true;
					} else if (reloadModelOverrides) {
						modelOverrideManager.reload();
					}

					if (reloadTileOverrides)
						tileOverrideManager.reload(reloadScene);

					if (recompilePrograms)
						recompilePrograms();

					if (recreateSceneFbo) {
						destroySceneFbo();
						updateSceneFbo();
					}

					if (reloadScene) {
						renderer.clearCaches();
						renderer.reloadScene();
					}

					if (recreateShadowMapFbo) {
						destroyShadowMapFbo();
						initializeShadowMapFbo();
					}

					if (reloadEnvironments)
						environmentManager.reload();
				}
			} catch (Throwable ex) {
				log.error("Error while changing settings:", ex);
				stopPlugin();
			} finally {
				sceneManager.getLoadingLock().unlock();
				log.trace("loadingLock unlocked - holdCount: {}", sceneManager.getLoadingLock().getHoldCount());
				pendingConfigChanges.clear();
				frameTimer.reset();
			}
		});
	}

	public void setupSyncMode() {
		// Without unlocked fps, the client manages sync on its 20ms timer
		boolean unlockFps = config.unlockFps();
		HdPluginConfig.SyncMode syncMode = unlockFps ? config.syncMode() : HdPluginConfig.SyncMode.OFF;

		if (frameTimer.isActive()) {
			unlockFps = true;
			syncMode = SyncMode.OFF;
		}

		client.setUnlockedFps(unlockFps);
		int swapInterval;
		switch (syncMode)
		{
			case ON:
				swapInterval = 1;
				break;
			case ADAPTIVE:
				swapInterval = -1;
				break;
			default:
			case OFF:
				swapInterval = 0;
				break;
		}

		int actualSwapInterval = awtContext.setSwapInterval(swapInterval);
		if (actualSwapInterval != swapInterval) {
			log.info("unsupported swap interval {}, got {}", swapInterval, actualSwapInterval);
		}

		client.setUnlockedFpsTarget(actualSwapInterval == 0 ? config.fpsTarget() : 0);
		checkGLErrors();
	}

	private float[] getDpiScaling() {
		final GraphicsConfiguration graphicsConfiguration = clientUI.getGraphicsConfiguration();
		if (graphicsConfiguration == null)
			return new float[] { 1, 1 };

		final AffineTransform t = graphicsConfiguration.getDefaultTransform();
		return new float[] { (float) t.getScaleX(), (float) t.getScaleY() };
	}

	public int getDrawDistance() {
		return clamp(config.drawDistance(), 0, MAX_DISTANCE);
	}

	public float getGammaCorrection() {
		if (config.useLegacyBrightness())
			return 1;
		return 100f / config.brightness();
	}

	public int getExpandedMapLoadingChunks() {
		if (useLowMemoryMode)
			return 0;
		return config.expandedMapLoadingChunks();
	}

	@Subscribe(priority = -1) // Run after the low detail plugin
	public void onBeforeRender(BeforeRender beforeRender) {
		SKIP_GL_ERROR_CHECKS = !log.isDebugEnabled() || developerTools.isFrameTimingsOverlayEnabled();

		if (lastFrameTimeMillis > 0) {
			deltaTime = (float) ((System.currentTimeMillis() - lastFrameTimeMillis) / 1000.);

			// Restart the to avoid potential buffer corruption if the computer has likely resumed from suspension
			if (deltaTime > 300) {
				log.debug("Restarting the after probable OS suspend ({} second delta)", deltaTime);
				restartPlugin();
			}

			// If system time changes between frames, clamp the delta to a more sensible value
			if (abs(deltaTime) > 10)
				deltaTime = 1 / 60.f;
			// The client delta doesn't need clamping
			deltaClientTime = (float) (elapsedClientTime - lastFrameClientTime);

			elapsedTime += deltaTime;
			windOffset += deltaTime * environmentManager.currentWindSpeed;
		}
		lastFrameTimeMillis = System.currentTimeMillis();
		lastFrameClientTime = elapsedClientTime;

		// The game runs significantly slower with lower planes in Chambers of Xeric
		var ctx = getSceneContext();
		if (ctx != null)
			ctx.scene.setMinLevel(ctx.isInChambersOfXeric ? client.getPlane() : ctx.scene.getMinLevel());
	}

	@Subscribe
	public void onClientTick(ClientTick clientTick) {
		elapsedClientTime += 1 / 50f;

		if (!enableFreezeFrame && skipScene != client.getScene())
			redrawPreviousFrame = false;
	}

	@Subscribe
	public void onGameTick(GameTick gameTick) {
		if (!isActive)
			return;

		fishingSpotReplacer.update();
	}

	@SuppressWarnings("StatementWithEmptyBody")
	public static void clearGLErrors() {
		// @formatter:off
		while (glGetError() != GL_NO_ERROR);
		// @formatter:on
	}

	public static void checkGLErrors() {
		if (SKIP_GL_ERROR_CHECKS)
			return;

		while (true) {
			int err = glGetError();
			if (err == GL_NO_ERROR)
				return;

			String errStr;
			switch (err) {
				case GL_INVALID_ENUM:
					errStr = "INVALID_ENUM";
					break;
				case GL_INVALID_VALUE:
					errStr = "INVALID_VALUE";
					break;
				case GL_STACK_OVERFLOW:
					errStr = "STACK_OVERFLOW";
					break;
				case GL_STACK_UNDERFLOW:
					errStr = "STACK_UNDERFLOW";
					break;
				case GL_INVALID_OPERATION:
					errStr = "INVALID_OPERATION";
					break;
				case GL_INVALID_FRAMEBUFFER_OPERATION:
					errStr = "INVALID_FRAMEBUFFER_OPERATION";
					break;
				default:
					errStr = String.format("Error code: %d", err);
					break;
			}

			log.debug("glGetError:", new Exception(errStr));
		}
	}

	private void displayUpdateMessage() {
		int messageId = 1;
		if (config.getPluginUpdateMessage() >= messageId)
			return; // Don't show the same message multiple times

//		PopupUtils.displayPopupMessage(client, "117HD Update",
//			"<br><br>" +
//			"If you experience any issues, please report them in the <a href=\"" + DISCORD_URL +"\">117HD Discord</a>.",
//			new String[] { "Remind me later", "Got it!" },
//			i -> {
//				if (i == 1) {
//					config.setPluginUpdateMessage(messageId);
//				}
//			}
//		);
	}

	private void displayUnsupportedGpuMessage(boolean isFallbackGpu, String glRenderer, Renderer renderer) {
		String hint32Bit = "";
		if (HDUtils.is32Bit()) {
			hint32Bit =
				"&nbsp; Install the 64-bit version of RuneLite from " +
				"<a href=\"" + HdPlugin.RUNELITE_URL + "\">the official website</a>. You are currently using 32-bit.<br>";
		}

		String driverLinks =
			"<br>" +
			"Links to drivers for each graphics card vendor:<br>" +
			"&nbsp; <a href=\"" + HdPlugin.AMD_DRIVER_URL + "\">AMD drivers</a><br>" +
			"&nbsp; <a href=\"" + HdPlugin.INTEL_DRIVER_URL + "\">Intel drivers</a><br>" +
			"&nbsp; <a href=\"" + HdPlugin.NVIDIA_DRIVER_URL + "\">Nvidia drivers</a><br>";

		String errorMessage =
			(
				isFallbackGpu ? (
					"Your graphics driver appears to be broken.<br>"
					+ "<br>"
					+ "Some things to try:<br>"
					+ "&nbsp; Reinstall the drivers for <b>both</b> your processor's integrated graphics <b>and</b> your graphics card.<br>"
				) :
					(
						(
							renderer instanceof LegacyRenderer && GL_CAPS.OpenGL31 ?
								"The legacy renderer does not support your GPU. Try disabling it in the Legacy settings section." :
								"Your GPU is currently not supported by 117 HD."
						)
						+ "<br><br>GPU name: " + glRenderer + "<br><br>"
						+ "Your computer might not be letting RuneLite access your most powerful GPU.<br>"
						+ "To find out if your system is supported, try the following steps:<br>"
						+ "&nbsp; Reinstall the drivers for your graphics card. You can find a link below.<br>"
					)
			)
			+ hint32Bit
			+ "&nbsp; Tell your machine to use your high performance GPU for RuneLite.<br>"
			+ "&nbsp; If you are on a desktop PC, make sure your monitor is plugged into your graphics card instead of<br>"
			+ "&nbsp;&nbsp;&nbsp;&nbsp;your motherboard. The graphics card's display outputs are usually lower down behind the computer.<br>"
			+ driverLinks
			+ "<br>"
			+ "If the issue persists even after <b>all of the above</b>, please join our "
			+ "<a href=\"" + HdPlugin.DISCORD_URL + "\">Discord server</a>, and click the <br>"
			+ "\"Open logs folder\" button below, find the file named \"client\" or \"client.log\", then drag and drop<br>"
			+ "that file into one of our support channels.";

		PopupUtils.displayPopupMessage(client, "117 HD Error", errorMessage,
			new String[] { "Open logs folder", "Ok, let me try that..." },
			i -> {
				if (i == 0) {
					LinkBrowser.open(RuneLite.LOGS_DIR.toString());
					return false;
				}
				return true;
			}
		);
	}

	public void displayOutOfMemoryMessage() {
		String errorMessage;
		if (HDUtils.is32Bit()) {
			String lowMemoryModeHint = useLowMemoryMode ? "" : (
				"If you are unable to install 64-bit RuneLite, you can instead turn on <b>Low Memory Mode</b> in the<br>" +
				"Miscellaneous section of 117 HD settings.<br>"
			);
			errorMessage =
				"The plugin ran out of memory because you are using the 32-bit version of RuneLite.<br>"
				+ "We would recommend installing the 64-bit version from "
				+ "<a href=\"" + HdPlugin.RUNELITE_URL + "\">RuneLite's website</a> if possible.<br>"
				+ "<br>"
				+ lowMemoryModeHint
				+ "<br>"
				+ "If you need further assistance, please join our "
				+ "<a href=\"" + HdPlugin.DISCORD_URL + "\">Discord</a> server, and click the \"Open logs folder\"<br>"
				+ "button below, find the file named \"client\" or \"client.log\", then drag and drop that file into one of<br>"
				+ "our support channels.";
		} else {
			errorMessage =
				"The plugin ran out of memory. "
				+ "Try " + (useLowMemoryMode ? "" : "reducing your model cache size from " + config.modelCacheSizeMiB() + " or ") + "closing other programs.<br>"
				+ "<br>"
				+ "If the issue persists, please join our "
				+ "<a href=\"" + HdPlugin.DISCORD_URL + "\">Discord</a> server, and click the \"Open logs folder\" button<br>"
				+ "below, find the file named \"client\" or \"client.log\", then drag and drop that file into one of our<br>"
				+ "support channels.";
		}

		PopupUtils.displayPopupMessage(client, "117 HD Error", errorMessage,
			new String[] { "Open logs folder", "Ok, let me try that..." },
			i -> {
				if (i == 0) {
					LinkBrowser.open(RuneLite.LOGS_DIR.toString());
					return false;
				}
				return true;
			}
		);
	}
}

/*
 * Copyright (c) 2018, Adam <Adam@sigterm.info>
 * Copyright (c) 2021, 117 <https://twitter.com/117scape>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package rs117.hd;

import net.runelite.client.config.Config;
import net.runelite.client.config.ConfigGroup;
import net.runelite.client.config.ConfigItem;
import net.runelite.client.config.ConfigSection;
import net.runelite.client.config.Range;
import net.runelite.client.config.Units;
import rs117.hd.config.AntiAliasingMode;
import rs117.hd.config.ColorBlindMode;
import rs117.hd.config.ColorFilter;
import rs117.hd.config.Contrast;
import rs117.hd.config.DefaultSkyColor;
import rs117.hd.config.DynamicLights;
import rs117.hd.config.FogDepthMode;
import rs117.hd.config.Saturation;
import rs117.hd.config.SceneScalingMode;
import rs117.hd.config.SeasonalHemisphere;
import rs117.hd.config.SeasonalTheme;
import rs117.hd.config.ShadingMode;
import rs117.hd.config.ShadowDistance;
import rs117.hd.config.ShadowMode;
import rs117.hd.config.ShadowResolution;
import rs117.hd.config.TextureResolution;
import rs117.hd.config.UIScalingMode;
import rs117.hd.config.VanillaShadowMode;

import static rs117.hd.HdPlugin.MAX_DISTANCE;
import static rs117.hd.HdPlugin.MAX_FOG_DEPTH;
import static rs117.hd.HdPluginConfig.*;
import static rs117.hd.utils.MathUtils.*;

@ConfigGroup(CONFIG_GROUP)
public interface HdPluginConfig extends Config
{
	String CONFIG_GROUP = "hd";

	/*====== General settings ======*/

	@ConfigSection(
		name = "General",
		description = "General settings",
		position = 0
	)
	String generalSettings = "generalSettings";

	@Range(
		max = MAX_DISTANCE
	)
	@Units(" tiles")
	@ConfigItem(
		keyName = "drawDistance",
		name = "Draw Distance",
		description =
			"The number of tiles to draw in either direction from the camera, up to a maximum of 184.<br>" +
			"Depending on where the scene is centered, you might only see 16 tiles in one direction, unless you extend map loading.",
		position = 1,
		section = generalSettings
	)
	default int drawDistance() {
		return 50;
	}

	@Range(
		min = 25,
		max = MAX_DISTANCE
	)
	@Units(" tiles")
	@ConfigItem(
		keyName = "detailDistance",
		name = "Detail Distance",
		description =
			"The number of tiles to draw animated models in either direction from the camera, up to a maximum of 184.<br>" +
			"Reducing this can help with performance, particularly in crowded sailing areas.",
		position = 2,
		section = generalSettings
	)
	default int detailDrawDistance() {
		return 70;
	}

	String KEY_EXPANDED_MAP_LOADING_CHUNKS = "expandedMapLoadingChunks";
	@Range(
		max = 5
	)
	@Units(" chunks")
	@ConfigItem(
		keyName = KEY_EXPANDED_MAP_LOADING_CHUNKS,
		name = "Extended map loading",
		description =
			"How much further the map should be loaded. The maximum is 5 extra chunks.<br>" +
			"Note, extending the map can have a very high impact on performance.",
		position = 3,
		section = generalSettings
	)
	default int expandedMapLoadingChunks() {
		return 3;
	}

	String KEY_HIDE_UNRELATED_AREAS = "hideUnrelatedAreas";
	@ConfigItem(
		keyName = KEY_HIDE_UNRELATED_AREAS,
		name = "Hide unrelated areas",
		description = "Hide unrelated areas which you shouldn't see from your current position.",
		position = 4,
		section = generalSettings
	)
	default boolean hideUnrelatedAreas() {
		return true;
	}

	String KEY_ANTI_ALIASING_MODE = "antiAliasingMode";
	@ConfigItem(
		keyName = KEY_ANTI_ALIASING_MODE,
		name = "Anti-Aliasing",
		description =
			"Improves pixelated edges at the cost of significantly higher GPU usage.<br>" +
			"MSAA x16 is very expensive, so x8 is recommended if anti-aliasing is desired.",
		position = 5,
		section = generalSettings
	)
	default AntiAliasingMode antiAliasingMode()
	{
		return AntiAliasingMode.DISABLED;
	}

	String KEY_SCENE_RESOLUTION_SCALE = "sceneResolutionScale";
	@ConfigItem(
		keyName = KEY_SCENE_RESOLUTION_SCALE,
		name = "Game Resolution",
		description =
			"Render the game at a different resolution and stretch it to fit the screen.<br>" +
			"Reducing this can improve performance, particularly on very high resolution displays.",
		position = 6,
		section = generalSettings
	)
	@Units(Units.PERCENT)
	@Range(min = 1, max = 200)
	default int sceneResolutionScale() {
		return 100;
	}

	@ConfigItem(
		keyName = "sceneScalingMode",
		name = "Game Scaling Mode",
		description = "The sampling function to use when upscaling the above reduced game resolution.",
		position = 7,
		section = generalSettings
	)
	default SceneScalingMode sceneScalingMode()
	{
		return SceneScalingMode.LINEAR;
	}

	String KEY_UI_SCALING_MODE = "uiScalingMode";
	@ConfigItem(
		keyName = KEY_UI_SCALING_MODE,
		name = "UI Scaling Mode",
		description =
			"The sampling function to use when the Stretched Mode plugin is enabled.<br>" +
			"Affects how the UI looks with non-integer scaling.",
		position = 8,
		section = generalSettings
	)
	default UIScalingMode uiScalingMode() {
		return UIScalingMode.HYBRID;
	}

	String KEY_ANISOTROPIC_FILTERING_LEVEL = "anisotropicFilteringLevel";
	@Range(
		min = 0,
		max = 16
	)
	@Units("x")
	@ConfigItem(
		keyName = KEY_ANISOTROPIC_FILTERING_LEVEL,
		name = "Anisotropic Filtering",
		description =
			"Configures whether mipmapping and anisotropic filtering should be used.<br>" +
			"At zero, mipmapping is disabled and textures look the most pixelated.<br>" +
			"At 1 through 16, mipmapping is enabled, and textures look more blurry and smoothed out.<br>" +
			"The higher you go beyond 1, the less blurry textures will look, up to a certain extent.",
		position = 9,
		section = generalSettings
	)
	default int anisotropicFilteringLevel()
	{
		return 16;
	}

	String KEY_UNLOCK_FPS = "unlockFps";
	@ConfigItem(
		keyName = KEY_UNLOCK_FPS,
		name = "Unlock FPS",
		description = "Removes the 50 FPS cap for some game content, such as camera movement and dynamic lighting.",
		position = 10,
		section = generalSettings
	)
	default boolean unlockFps()
	{
		return false;
	}

	enum SyncMode
	{
		OFF,
		ON,
		ADAPTIVE
	}

	String KEY_VSYNC_MODE = "vsyncMode";
	@ConfigItem(
		keyName = KEY_VSYNC_MODE,
		name = "VSync Mode",
		description =
			"Controls whether the frame rate should be synchronized with your monitor's refresh rate.<br>" +
			"If set to 'off', the FPS Target option will be used instead.<br>" +
			"If set to 'adaptive', FPS will be limited to your monitor's refresh rate, which saves power.<br>" +
			"If set to 'on', the game will attempt to match your monitor's refresh rate <b>exactly</b>,<br>" +
			"but if it can't keep up, FPS will be <u>halved until it catches up</u>. This option is rarely desired.<br>" +
			"Note, GPUs that don't support Adaptive VSync will silently fall back to 'on'.",
		position = 11,
		section = generalSettings
	)
	default SyncMode syncMode()
	{
		return SyncMode.ADAPTIVE;
	}

	String KEY_FPS_TARGET = "fpsTarget";
	@ConfigItem(
		keyName = KEY_FPS_TARGET,
		name = "FPS Target",
		description =
			"Controls the maximum number of frames per second.<br>" +
			"This setting only applies if Unlock FPS is enabled, and VSync Mode is set to 'off'.",
		position = 12,
		section = generalSettings
	)
	@Range(
		min = 0,
		max = 999
	)
	default int fpsTarget()
	{
		return 60;
	}

	String KEY_COLOR_BLINDNESS = "colorBlindMode";
	@ConfigItem(
		keyName = KEY_COLOR_BLINDNESS,
		name = "Color Blindness",
		description = "Adjust colors to make them more distinguishable for people with a certain type of color blindness.",
		position = 13,
		section = generalSettings
	)
	default ColorBlindMode colorBlindness()
	{
		return ColorBlindMode.NONE;
	}

	@ConfigItem(
		keyName = "colorBlindnessIntensity",
		name = "Blindness Intensity",
		description = "Specifies how intense the color blindness adjustment should be.",
		position = 14,
		section = generalSettings
	)
	@Units(Units.PERCENT)
	@Range(max = 100)
	default int colorBlindnessIntensity()
	{
		return 100;
	}

	@ConfigItem(
		keyName = "flashingEffects",
		name = "Flashing Effects",
		description = "Whether to show rapid flashing effects, such as lightning, in certain areas.",
		position = 15,
		section = generalSettings
	)
	default boolean flashingEffects()
	{
		return false;
	}

	@ConfigItem(
		keyName = "fSaturation",
		name = "Saturation",
		description = "Controls the saturation of the final rendered image.<br>" +
			"Intended to be kept between 0% and 120%.",
		position = 16,
		section = generalSettings
	)
	@Units(Units.PERCENT)
	@Range(min = -500, max = 500)
	default int saturation()
	{
		return round(oldSaturationDropdown().getAmount() * 100);
	}
	@ConfigItem(keyName = "saturation", hidden = true, name = "", description = "")
	default Saturation oldSaturationDropdown()
	{
		return Saturation.DEFAULT;
	}

	@ConfigItem(
		keyName = "fContrast",
		name = "Contrast",
		description = "Controls the contrast of the final rendered image.<br>" +
			"Intended to be kept between 90% and 110%.",
		position = 17,
		section = generalSettings
	)
	@Units(Units.PERCENT)
	@Range(min = -500, max = 500)
	default int contrast()
	{
		return round(oldContrastDropdown().getAmount() * 100);
	}
	@ConfigItem(keyName = "contrast", hidden = true, name = "", description = "")
	default Contrast oldContrastDropdown()
	{
		return Contrast.DEFAULT;
	}

	String KEY_BRIGHTNESS = "screenBrightness";
	@Range(
		min = 25,
		max = 400
	)
	@Units(Units.PERCENT)
	@ConfigItem(
		keyName = KEY_BRIGHTNESS,
		name = "Brightness",
		description =
			"Controls the brightness of the game, excluding UI.<br>" +
			"Adjust until the disk on the left is barely visible.",
		position = 18,
		section = generalSettings
	)
	default int brightness() {
		return 100;
	}


	/*====== Lighting settings ======*/

	@ConfigSection(
		name = "Lighting",
		description = "Lighting settings",
		position = 1,
		closedByDefault = true
	)
	String lightingSettings = "lightingSettings";

	String KEY_DYNAMIC_LIGHTS = "dynamicLights";
	@ConfigItem(
		keyName = KEY_DYNAMIC_LIGHTS,
		name = "Dynamic Lights",
		description =
			"The maximum number of dynamic lights visible at once.<br>" +
			"Reducing this may improve performance.",
		position = 0,
		section = lightingSettings
	)
	default DynamicLights dynamicLights()
	{
		return DynamicLights.SOME;
	}

	String KEY_TILED_LIGHTING = "tiledLighting";
	@ConfigItem(
		keyName = KEY_TILED_LIGHTING,
		name = "Tiled Lighting",
		description = "Allows rendering <b>a lot</b> more lights simultaneously.",
		section = lightingSettings,
		position = 1
	)
	default boolean tiledLighting() {
		return true;
	}
	@ConfigItem(keyName = KEY_TILED_LIGHTING, hidden = true, name = "", description = "")
	void tiledLighting(boolean enabled);

	String KEY_PROJECTILE_LIGHTS = "projectileLights";
	@ConfigItem(
		keyName = KEY_PROJECTILE_LIGHTS,
		name = "Projectile Lights",
		description = "Adds dynamic lights to some projectiles.",
		position = 2,
		section = lightingSettings
	)
	default boolean projectileLights() {
		return true;
	}

	String KEY_NPC_LIGHTS = "npcLights";
	@ConfigItem(
		keyName = KEY_NPC_LIGHTS,
		name = "NPC Lights",
		description = "Adds dynamic lights to some NPCs.",
		position = 3,
		section = lightingSettings
	)
	default boolean npcLights() {
		return true;
	}

	String KEY_ATMOSPHERIC_LIGHTING = "environmentalLighting";
	@ConfigItem(
		keyName = KEY_ATMOSPHERIC_LIGHTING,
		name = "Atmospheric Lighting",
		description = "Change environmental lighting based on the current area.",
		position = 4,
		section = lightingSettings
	)
	default boolean atmosphericLighting() {
		return true;
	}

	String KEY_SHADOW_MODE = "shadowMode";
	@ConfigItem(
		keyName = KEY_SHADOW_MODE,
		name = "Shadows",
		description =
			"Render fully dynamic shadows.<br>" +
			"'Off' completely disables shadows.<br>" +
			"'Fast' enables fast shadows without any texture detail.<br>" +
			"'Detailed' enables slower shadows with support for texture detail.",
		position = 5,
		section = lightingSettings
	)
	default ShadowMode shadowMode()
	{
		return ShadowMode.DETAILED;
	}

	String KEY_SHADOW_TRANSPARENCY = "enableShadowTransparency";
	@ConfigItem(
		keyName = KEY_SHADOW_TRANSPARENCY,
		name = "Shadow Transparency",
		description = "Enables partial support for shadows that take transparency into account.",
		position = 6,
		section = lightingSettings
	)
	default boolean enableShadowTransparency()
	{
		return true;
	}

	String KEY_PIXELATED_SHADOWS = "pixelatedShadows";
	@ConfigItem(
		keyName = KEY_PIXELATED_SHADOWS,
		name = "Pixelated Shadows",
		description = "Give shadows a slightly pixelated look.",
		position = 7,
		section = lightingSettings
	)
	default boolean pixelatedShadows() {
		return false;
	}

	String KEY_SHADOW_RESOLUTION = "shadowResolution";
	@ConfigItem(
		keyName = KEY_SHADOW_RESOLUTION,
		name = "Shadow Quality",
		description =
			"The resolution of the shadow map.<br>" +
			"Higher resolutions result in higher quality shadows, at the cost of higher GPU usage.",
		position = 8,
		section = lightingSettings
	)
	default ShadowResolution shadowResolution()
	{
		return ShadowResolution.RES_4096;
	}

	@ConfigItem(
		keyName = "shadowDistance",
		name = "Shadow Distance",
		description =
			"The maximum draw distance for shadows.<br>" +
			"Shorter distances result in higher quality shadows.",
		position = 9,
		section = lightingSettings
	)
	@Units(" tiles")
	default ShadowDistance shadowDistance()
	{
		return ShadowDistance.DISTANCE_50;
	}

	String KEY_EXPAND_SHADOW_DRAW = "expandShadowDraw";
	@ConfigItem(
		keyName = KEY_EXPAND_SHADOW_DRAW,
		name = "Expand Shadow Draw",
		description =
			"Reduces shadows popping in and out at the edge of the screen by rendering<br>" +
			"shadows for a larger portion of the scene, at the cost of higher GPU usage.",
		position = 10,
		section = lightingSettings
	)
	default boolean expandShadowDraw()
	{
		return false;
	}

	String KEY_VANILLA_SHADOW_MODE = "vanillaShadowMode";
	@ConfigItem(
		keyName = KEY_VANILLA_SHADOW_MODE,
		name = "Vanilla Shadows",
		description =
			"Choose whether shadows built into models by Jagex should be hidden. This does not affect clickboxes.<br>" +
			"'Show in PvM' will retain shadows for falling crystals during the Olm fight and other useful cases.<br>" +
			"'Prefer in PvM' will do the above and also disable 117 HD's dynamic shadows in such cases.",
		position = 11,
		section = lightingSettings
	)
	default VanillaShadowMode vanillaShadowMode() {
		return VanillaShadowMode.SHOW_IN_PVM;
	}

	String KEY_NORMAL_MAPPING = "normalMapping";
	@ConfigItem(
		keyName = KEY_NORMAL_MAPPING,
		name = "Normal Mapping",
		description = "Affects how light interacts with certain materials. Barely impacts performance.",
		position = 12,
		section = lightingSettings
	)
	default boolean normalMapping() {
		return true;
	}

	String KEY_PARALLAX_OCCLUSION_MAPPING = "parallaxOcclusionMappingToggle";
	@ConfigItem(
		keyName = KEY_PARALLAX_OCCLUSION_MAPPING,
		name = "Parallax Occlusion Mapping",
		description = "Adds more depth to some materials, at the cost of higher GPU usage.",
		position = 13,
		section = lightingSettings
	)
	default boolean parallaxOcclusionMapping() {
		return true;
	}


	/*====== Environment settings ======*/

	@ConfigSection(
		name = "Environment",
		description = "Environment settings",
		position = 2,
		closedByDefault = true
	)
	String environmentSettings = "environmentSettings";

	String KEY_SEASONAL_THEME = "seasonalTheme";
	@ConfigItem(
		keyName = KEY_SEASONAL_THEME,
		name = "Seasonal Theme",
		description = "Festive themes for Gielinor.",
		position = 0,
		section = environmentSettings
	)
	default SeasonalTheme seasonalTheme() {
		return SeasonalTheme.AUTOMATIC;
	}

	String KEY_SEASONAL_HEMISPHERE = "seasonalHemisphere";
	@ConfigItem(
		keyName = KEY_SEASONAL_HEMISPHERE,
		name = "Seasonal Hemisphere",
		description = "Determines which hemisphere the 'Automatic' Seasonal Theme should consider.",
		position = 1,
		section = environmentSettings
	)
	default SeasonalHemisphere seasonalHemisphere() {
		return SeasonalHemisphere.NORTHERN;
	}

	@ConfigItem(
		keyName = "fogDepthMode",
		name = "Fog Depth Mode",
		description =
			"Determines how the fog amount is controlled.<br>" +
			"'Dynamic' changes fog depth based on the area, while<br>" +
			"'Static' respects the manually defined fog depth.",
		position = 2,
		section = environmentSettings
	)
	default FogDepthMode fogDepthMode()
	{
		return FogDepthMode.DYNAMIC;
	}

	@Range(
		max = MAX_FOG_DEPTH
	)
	@Units(" tiles")
	@ConfigItem(
		keyName = "fogDepth",
		name = "Static Fog Depth",
		description =
			"Specify how far from the edge fog should reach.<br>" +
			"This applies only when 'Fog Depth Mode' is set to 'Static'.",
		position = 3,
		section = environmentSettings
	)
	default int fogDepth()
	{
		return 5;
	}

	@ConfigItem(
		keyName = "groundFog",
		name = "Ground Fog",
		description = "Enables a height-based fog effect that covers the ground in certain areas.",
		position = 4,
		section = environmentSettings
	)
	default boolean groundFog() {
		return true;
	}

	@ConfigItem(
		keyName = "defaultSkyColor",
		name = "Default Sky",
		description =
			"Specify a sky color to use when the current area doesn't have a sky color defined.<br>" +
			"This only applies when the default summer seasonal theme is active.<br>" +
			"If set to 'RuneLite Skybox', the sky color from RuneLite's Skybox plugin will be used.<br>" +
			"If set to 'Old School Black', the sky will be black and water will remain blue, but for any<br>" +
			"other option, the water color will be influenced by the sky color.",
		position = 5,
		section = environmentSettings
	)
	default DefaultSkyColor defaultSkyColor()
	{
		return DefaultSkyColor.DEFAULT;
	}

	@ConfigItem(
		keyName = "overrideSky",
		name = "Override Sky Color",
		description = "Forces the default sky color to be used in all environments.",
		position = 6,
		section = environmentSettings
	)
	default boolean overrideSky() {
		return false;
	}

	String KEY_MODEL_TEXTURES = "objectTextures";
	@ConfigItem(
		keyName = KEY_MODEL_TEXTURES,
		name = "Model Textures",
		description = "Adds new textures to most models. If disabled, the standard game textures will be used instead.",
		position = 7,
		section = environmentSettings
	)
	default boolean modelTextures() {
		return true;
	}

	String KEY_GROUND_TEXTURES = "groundTextures";
	@ConfigItem(
		keyName = KEY_GROUND_TEXTURES,
		name = "Ground Textures",
		description = "Adds new textures to most ground tiles.",
		position = 8,
		section = environmentSettings
	)
	default boolean groundTextures()
	{
		return true;
	}

	String KEY_TEXTURE_RESOLUTION = "textureResolution";
	@ConfigItem(
		keyName = KEY_TEXTURE_RESOLUTION,
		name = "Texture Resolution",
		description = "Controls the resolution used for all in-game textures.",
		position = 9,
		section = environmentSettings
	)
	default TextureResolution textureResolution()
	{
		return TextureResolution.RES_256;
	}

	String KEY_GROUND_BLENDING = "groundBlending";
	@ConfigItem(
		keyName = KEY_GROUND_BLENDING,
		name = "Ground Blending",
		description = "Controls whether ground tiles should blend into each other, or have distinct edges.",
		position = 10,
		section = environmentSettings
	)
	default boolean groundBlending()
	{
		return true;
	}

	@ConfigItem(
		keyName = "underwaterCaustics",
		name = "Underwater Caustics",
		description = "Apply underwater lighting effects to imitate sunlight passing through waves on the surface.",
		position = 11,
		section = environmentSettings
	)
	default boolean underwaterCaustics()
	{
		return true;
	}

	String KEY_WIND_DISPLACEMENT = "windDisplacement";
	@ConfigItem(
		keyName = KEY_WIND_DISPLACEMENT,
		name = "Wind Displacement",
		description = "Controls whether things like grass and leaves should be affected by wind.",
		position = 13,
		section = environmentSettings
	)
	default boolean windDisplacement() {
		return true;
	}

	String KEY_CHARACTER_DISPLACEMENT = "characterDisplacement";
	@ConfigItem(
		keyName = KEY_CHARACTER_DISPLACEMENT,
		name = "Character Displacement",
		description = "Let players & NPCs affect things like grass whilst walking around.",
		position = 14,
		section = environmentSettings
	)
	default boolean characterDisplacement() {
		return true;
	}


	/*====== Miscellaneous settings ======*/

	@ConfigSection(
		name = "Miscellaneous",
		description = "Miscellaneous settings",
		position = 4,
		closedByDefault = true
	)
	String miscellaneousSettings = "miscellaneousSettings";

	String KEY_MACOS_INTEL_WORKAROUND = "macosIntelWorkaround";
	@ConfigItem(
		keyName = KEY_MACOS_INTEL_WORKAROUND,
		name = "Fix broken colors on Intel Macs",
		description = "Workaround for visual artifacts found on some Intel GPU drivers on macOS.",
		warning =
			"This setting can cause RuneLite to crash, and it can be difficult to undo.\n" +
			"Only enable it if you are seeing broken colors. Are you sure you want to enable this setting?",
		section = miscellaneousSettings
	)
	default boolean macosIntelWorkaround()
	{
		return false;
	}

	String KEY_HD_INFERNAL_CAPE = "hdInfernalTexture";
	@ConfigItem(
		keyName = KEY_HD_INFERNAL_CAPE,
		name = "HD Infernal Cape",
		description =
			"Replace the infernal cape texture with a more detailed version.<br>" +
			"Note, with Anisotropic Filtering above zero, the cape may look blurry when zoomed out.",
		section = miscellaneousSettings
	)
	default boolean hdInfernalTexture() {
		return true;
	}

	String KEY_VANILLA_COLOR_BANDING = "vanillaColorBanding";
	@ConfigItem(
		keyName = KEY_VANILLA_COLOR_BANDING,
		name = "Vanilla Color Banding",
		description =
			"Blend between colors similarly to how it works in vanilla, with clearly defined bands of color.<br>" +
			"This isn't really noticeable on textured surfaces, and is intended to be used without ground textures.",
		section = miscellaneousSettings
	)
	default boolean vanillaColorBanding() {
		return false;
	}

	String KEY_LOW_MEMORY_MODE = "lowMemoryMode";
	@ConfigItem(
		keyName = KEY_LOW_MEMORY_MODE,
		name = "Low Memory Mode",
		description = "Turns off features which require extra memory, such as model caching, faster scene loading & extended scene loading.",
		warning =
			"<html>This <b>will not</b> result in better performance. It is recommended only if you are unable to install<br>" +
			"the 64-bit version of RuneLite, or if your computer has a very low amount of memory available.</html>",
		section = miscellaneousSettings
	)
	default boolean lowMemoryMode() {
		return false;
	}

	String KEY_COLOR_FILTER = "colorFilter";
	@ConfigItem(
		keyName = KEY_COLOR_FILTER,
		name = "Color Filter",
		description = "Apply a color filter to the game as a post-processing effect.",
		section = miscellaneousSettings
	)
	default ColorFilter colorFilter() {
		return ColorFilter.NONE;
	}

	String KEY_REMOVE_VERTEX_SNAPPING = "removeVertexSnapping";
	@ConfigItem(
		keyName = KEY_REMOVE_VERTEX_SNAPPING,
		name = "Remove vertex snapping",
		description =
			"Removes vertex snapping from most animations.<br>" +
			"Most animations are barely affected by this, and it only has an effect if the animation smoothing plugin is turned off.<br>" +
			"To see quite clearly what impact this option has, a good example is the godsword idle animation.",
		section = miscellaneousSettings
	)
	default boolean removeVertexSnapping() {
		return true;
	}

	String KEY_FILL_GAPS_IN_TERRAIN = "fillGapsInTerrain";
	@ConfigItem(
		keyName = KEY_FILL_GAPS_IN_TERRAIN,
		name = "Fill gaps in terrain",
		description = "Attempt to patch all holes in the ground, such as around trapdoors and ladders.",
		section = miscellaneousSettings
	)
	default boolean fillGapsInTerrain() {
		return true;
	}

	String KEY_FLAT_SHADING = "flatShading";
	@ConfigItem(
		keyName = KEY_FLAT_SHADING,
		name = "Flat shading",
		description = "Gives a more low-poly look to the game.",
		section = miscellaneousSettings
	)
	default boolean flatShading() {
		return false;
	}

	String KEY_WINDOWS_HDR_CORRECTION = "windowsHdrCorrection";
	@ConfigItem(
		keyName = KEY_WINDOWS_HDR_CORRECTION,
		name = "Windows HDR correction",
		description =
			"Correctly simulates SDR gamma 2.2 when Windows is in HDR mode. Note, this does not<br>" +
			"enable HDR, it only works around an issue within Windows' HDR implementation.",
		section = miscellaneousSettings
	)
	default boolean windowsHdrCorrection() {
		return false;
	}


	/*====== Legacy settings ======*/

	@ConfigSection(
		name = "Legacy",
		description = "Legacy options. If you dislike a change, you might find an option to change it back here.",
		position = 5,
		closedByDefault = true
	)
	String legacySettings = "legacySettings";

	String KEY_LEGACY_RENDERER = "legacyRenderer";
	@ConfigItem(
		keyName = KEY_LEGACY_RENDERER,
		name = "Use legacy renderer",
		description = "The new renderer is required for sailing content, but it is not 100% feature complete yet.",
		section = legacySettings,
		position = -100
	)
	default boolean legacyRenderer() {
		return false;
	}

	@ConfigItem(
		keyName = "useLegacyBrightness",
		name = "Use legacy brightness",
		description =
			"Whether the legacy brightness option below should be applied.<br>" +
			"We recommend leaving this disabled.",
		section = legacySettings,
		position = -99
	)
	default boolean useLegacyBrightness() {
		return false;
	}

	@Range(
		min = 1,
		max = 50
	)
	@ConfigItem(
		keyName = "brightness2",
		name = "Legacy brightness",
		description =
			"Controls the strength of the sun and ambient lighting.<br>" +
			"A brightness value of 20 is the default.",
		section = legacySettings,
		position = -98
	)
	default int legacyBrightness() {
		return 20;
	}

	String KEY_MODEL_BATCHING = "useModelBatching";
	@ConfigItem(
		keyName = KEY_MODEL_BATCHING,
		name = "Legacy model batching",
		description =
			"With the legacy renderer, model batching improves performance by reusing identical models within the same frame.<br>" +
			"May cause instability and graphical bugs, particularly if Jagex makes engine changes.",
		position = -97,
		section = legacySettings
	)
	default boolean modelBatching() { return true; }

	String KEY_MODEL_CACHING = "useModelCaching";
	@ConfigItem(
		keyName = KEY_MODEL_CACHING,
		name = "Legacy model caching",
		description =
			"With the legacy renderer, model caching improves performance by saving and reusing model data from previous frames.<br>" +
			"May cause instability or graphical bugs, particularly if Jagex makes engine changes.",
		position = -96,
		section = legacySettings
	)
	default boolean modelCaching() { return true; }

	String KEY_MODEL_CACHE_SIZE = "modelCacheSizeMiBv2";
	@Range(
		min = 64,
		max = 16384
	)
	@Units(" MiB")
	@ConfigItem(
		keyName = KEY_MODEL_CACHE_SIZE,
		name = "Legacy cache size",
		description =
			"Size of the model cache in mebibytes (slightly more than megabytes).<br>" +
			"Generally, 512 MiB is plenty, with diminishing returns the higher you go.<br>" +
			"Minimum=64 MiB, maximum=16384 MiB",
		position = -95,
		section = legacySettings
	)
	default int modelCacheSizeMiB() {
		return modelCacheSizeMiBv1() / 4;
	}
	@ConfigItem(keyName = "modelCacheSizeMiB", hidden = true, name = "", description = "")
	default int modelCacheSizeMiBv1() {
		return 2048;
	}

	String KEY_LEGACY_GREY_COLORS = "reduceOverExposure";
	@ConfigItem(
		keyName = KEY_LEGACY_GREY_COLORS,
		name = "Legacy gray colors",
		description =
			"Previously, HD attempted to reduce over-exposure by capping the maximum color brightness,<br>" +
			"which changed white colors into dull shades of grey. This option brings back that old behaviour.",
		section = legacySettings
	)
	default boolean legacyGreyColors() {
		return false;
	}

	String KEY_LEGACY_TOB_ENVIRONMENT = "legacyTobEnvironment";
	@ConfigItem(
		keyName = KEY_LEGACY_TOB_ENVIRONMENT,
		name = "Legacy Theatre of Blood",
		description =
			"Previously, Theatre of Blood used to look a whole lot more blue, which<br>" +
			"some people grew really used to. This option brings back that same old look.",
		section = legacySettings
	)
	default boolean legacyTobEnvironment() {
		return false;
	}

	String KEY_LEGACY_TZHAAR_RESKIN = "tzhaarHD";
	@ConfigItem(
		keyName = KEY_LEGACY_TZHAAR_RESKIN,
		name = "Legacy TzHaar city reskin",
		description = "Recolors the TzHaar city of Mor Ul Rek to give it an appearance similar to that of its 2008 HD variant.",
		section = legacySettings
	)
	default boolean legacyTzHaarReskin() {
		return false;
	}


	/*====== Experimental settings ======*/

	@ConfigSection(
		name = "Experimental",
		description = "Experimental features - if you're experiencing issues you should consider disabling these.",
		position = 6,
		closedByDefault = true
	)
	String experimentalSettings = "experimentalSettings";

	String KEY_FASTER_MODEL_HASHING = "experimentalFasterModelHashing";
	@ConfigItem(
		keyName = KEY_FASTER_MODEL_HASHING,
		name = "Use faster model hashing",
		description = "Should increase performance at the expense of potential graphical issues.",
		section = experimentalSettings
	)
	default boolean fasterModelHashing() {
		return true;
	}

	String KEY_ZONE_STREAMING = "experimentalZoneStreaming";
	@ConfigItem(
		keyName = KEY_ZONE_STREAMING,
		name = "Zone streaming",
		description =
			"Load zones in parallel in the background, switching to new scenes almost instantly.<br>" +
			"You will see zones appear when they are loaded, instead of having to wait for them all at once.",
		section = experimentalSettings
	)
	default boolean zoneStreaming() {
		return true;
	}

	String KEY_PRESERVE_VANILLA_NORMALS = "experimentalPreserveVanillaNormals";
	@ConfigItem(
		keyName = KEY_PRESERVE_VANILLA_NORMALS,
		name = "Preserve vanilla normals",
		description = "Originally, 117 HD would respect vanilla normals, but these are often less accurate.",
		section = experimentalSettings
	)
	default boolean preserveVanillaNormals() {
		return false;
	}

	String KEY_SHADING_MODE = "experimentalShadingMode";
	@ConfigItem(
		keyName = KEY_SHADING_MODE,
		name = "Shading mode",
		description =
			"If you prefer playing without shadows, maybe you'll prefer vanilla shading or no shading as well.<br>" +
			"Keep in mind, with vanilla shading used alongside shadows, you can end up with double shading.",
		section = experimentalSettings
	)
	default ShadingMode shadingMode() {
		return ShadingMode.DEFAULT;
	}

	String KEY_DECOUPLE_WATER_FROM_SKY_COLOR = "experimentalDecoupleWaterFromSkyColor";
	@ConfigItem(
		keyName = KEY_DECOUPLE_WATER_FROM_SKY_COLOR,
		name = "Decouple water from sky color",
		description = "Some people prefer the water staying blue even with a different sky color active.",
		section = experimentalSettings
	)
	default boolean decoupleSkyAndWaterColor() {
		return false;
	}

	String KEY_WIREFRAME = "wireframe";
	@ConfigItem(
		keyName = KEY_WIREFRAME,
		name = "Wireframe",
		description = "Show the edges of individual triangles in the scene.",
		section = experimentalSettings
	)
	default boolean wireframe() {
		return false;
	}

	String KEY_ASYNC_UI_COPY = "experimentalAsyncUICopy";
	@ConfigItem(
		keyName = KEY_ASYNC_UI_COPY,
		name = "Perform UI copy asynchronously",
		description = "Slightly improves performance by delaying the UI by one frame.",
		section = experimentalSettings
	)
	default boolean asyncUICopy() {
		return false;
	}

	String KEY_TILED_LIGHTING_IMAGE_STORE = "experimentalTiledLightingImageStore";
	@ConfigItem(
		keyName = KEY_TILED_LIGHTING_IMAGE_STORE,
		name = "Use tiled lighting image store",
		description = "If you experience any issues with tiled lighting, disabling this <i>might</i> help.",
		section = experimentalSettings
	)
	default boolean tiledLightingImageLoadStore() {
		return true;
	}

	String KEY_ROOF_SHADOWS = "experimentalRoofShadows";
	@ConfigItem(
		keyName = KEY_ROOF_SHADOWS,
		name = "Roof Shadows",
		description = "Always cast shadows from roofs, even when they are hidden.",
		section = experimentalSettings
	)
	default boolean roofShadows() {
		return false;
	}

	String KEY_FORCE_INDIRECT_DRAW = "experimentalForceIndirectDraw";
	@ConfigItem(
		keyName = KEY_FORCE_INDIRECT_DRAW,
		name = "Force indirect draw",
		description =
			"Indirect draw is currently only enabled automatically for Nvidia GPUs.<br>" +
			"Enabling this <i>might</i> improve performance, if it is supported by your system.",
		section = experimentalSettings
	)
	default boolean forceIndirectDraw() {
		return false;
	}

	/*====== Internal settings ======*/

	@ConfigItem(keyName = "pluginUpdateMessage", hidden = true, name = "", description = "")
	void setPluginUpdateMessage(int version);
	@ConfigItem(keyName = "pluginUpdateMessage", hidden = true, name = "", description = "")
	default int getPluginUpdateMessage() {
		return 0;
	}
}

package rs117.hd.model;

import java.nio.FloatBuffer;
import java.nio.IntBuffer;
import java.util.ArrayDeque;
import java.util.HashMap;
import lombok.extern.slf4j.Slf4j;
import org.lwjgl.system.MemoryUtil;

import static rs117.hd.utils.MathUtils.*;

@Slf4j
public class ModelCache {
	private static class Allocation {
		long address;
		long byteCapacity;

		long cursor;
		long freeBytesAhead;

		Allocation(long byteCapacity) {
			assert byteCapacity > 0;
			address = MemoryUtil.nmemAllocChecked(byteCapacity);
			this.byteCapacity = byteCapacity;
			cursor = 0;
			freeBytesAhead = byteCapacity;
		}

		void destroy() {
			if (address == 0L)
				return;

			MemoryUtil.nmemFree(address);
			address = 0;
			byteCapacity = 0;
			cursor = 0;
			freeBytesAhead = 0;
		}

		@Override
		@SuppressWarnings("deprecation")
		protected void finalize() {
			destroy();
		}

		long reserve(long numBytes) {
			assert numBytes > 0;
			assert numBytes <= freeBytesAhead;
			assert numBytes <= byteCapacity - cursor;
			long address = this.address + cursor;
			cursor += numBytes;
			freeBytesAhead -= numBytes;
			return address;
		}

		long bytesFromEnd() {
			return byteCapacity - cursor;
		}
	}

	private static class Buffer {
		final boolean endMarker;
		final long hash;
		final long byteCapacity;
		final IntBuffer intBuffer;
		final FloatBuffer floatBuffer;

		public Buffer(long byteCapacity) {
			endMarker = true;
			this.hash = 0;
			this.byteCapacity = byteCapacity;
			intBuffer = null;
			floatBuffer = null;
		}

		public Buffer(long hash, IntBuffer buffer) {
			endMarker = false;
			this.hash = hash;
			byteCapacity = buffer.capacity() * 4L;
			intBuffer = buffer;
			floatBuffer = null;
		}

		public Buffer(long hash, FloatBuffer buffer) {
			endMarker = false;
			this.hash = hash;
			byteCapacity = buffer.capacity() * 4L;
			intBuffer = null;
			floatBuffer = buffer;
		}
	}

	private final Runnable terminationHook;
	private final HashMap<Long, Buffer> cache = new HashMap<>();
	private final ArrayDeque<Buffer> buffers = new ArrayDeque<>();
	private final Allocation[] allocations;
	private Allocation currentAllocation;
	private int currentAllocationIndex;

	public ModelCache(int modelCacheSizeMiB, Runnable terminationHook) {
		this.terminationHook = terminationHook;

		// Limit cache size to 128 MiB for 32-bit
		if (modelCacheSizeMiB > 128 && !"64".equals(System.getProperty("sun.arch.data.model"))) {
			log.warn("Defaulting model cache to 128 MiB due to non 64-bit client");
			modelCacheSizeMiB = 128;
		}

		try {
			int totalPhysicalMemoryMiB = (int) (((com.sun.management.OperatingSystemMXBean)
				java.lang.management.ManagementFactory.getOperatingSystemMXBean()).getTotalPhysicalMemorySize() / MiB);

			// Try to limit the cache size to half of the total physical memory
			if (modelCacheSizeMiB > totalPhysicalMemoryMiB / 2) {
				log.warn(
					"Limiting cache size to {} since the selected amount ({}) exceeds half of the total system memory ({} / 2)",
					totalPhysicalMemoryMiB / 2, modelCacheSizeMiB, totalPhysicalMemoryMiB);
				modelCacheSizeMiB = totalPhysicalMemoryMiB / 2;
			}
		} catch (Throwable e) {
			log.warn("Unable to check physical memory size: " + e);
		}

		long byteCapacity = modelCacheSizeMiB * MiB;

		log.debug("Allocating {} MiB model cache", modelCacheSizeMiB);

		Allocation[] allocations = new Allocation[1];
		try {
			// Try allocating the whole size as a single chunk
			allocations[0] = new Allocation(byteCapacity);
		} catch (Throwable err) {
			log.warn("Unable to allocate {} MiB as a single chunk", modelCacheSizeMiB, err);

			try {
				// Try allocating in chunks of up to 1 GiB each
				int numChunks = (int) ((byteCapacity + GiB - 1) / GiB);
				allocations = new Allocation[numChunks];
				for (int i = 0; i < numChunks; i++) {
					allocations[i] = new Allocation(min(byteCapacity - i * GiB, GiB));
				}
			} catch (Throwable err2) {
				destroy();
				log.error("Unable to allocate {} MiB in chunks of up to 1 GiB each", modelCacheSizeMiB, err2);
				throw err2;
			}
		}

		this.allocations = allocations;
		currentAllocation = allocations[0];
	}

	public void destroy() {
		cache.clear();
		buffers.clear();
		currentAllocation = null;

		if (allocations != null) {
			for (int i = 0; i < allocations.length; i++) {
				if (allocations[i] != null) {
					allocations[i].destroy();
					allocations[i] = null;
				}
			}
		}
	}

	@Override
	@SuppressWarnings("deprecation")
	protected void finalize() throws Throwable {
		try {
			// Clean up allocations in case the plugin somehow fails to call destroy
			destroy();
		} finally {
			super.finalize();
		}
	}

	public void clear() {
		cache.clear();
		buffers.clear();
		for (Allocation allocation : allocations) {
			if (allocation != null) {
				allocation.cursor = 0;
				allocation.freeBytesAhead = allocation.byteCapacity;
			}
		}
	}

	private Buffer get(long hash) {
		return cache.get(hash);
	}

	private void nextAllocation() {
		currentAllocation.cursor = 0;
		currentAllocation.freeBytesAhead = 0;

		currentAllocationIndex++;
		currentAllocationIndex %= allocations.length;
		currentAllocation = allocations[currentAllocationIndex];
	}

	private long reserve(long numBytes) {
		assert currentAllocation != null : "model cache used after destruction";

		if (currentAllocation.bytesFromEnd() < numBytes) {
			// ### = taken, ... = free, MMM = end marker
			//                    _________ -> not enough space
			// [##################....###MM]
			// inserting a new end marker as follows will cause issues
			// [##################MMMM###MM]
			// since ### and MM will be freed next, an option is to move these to the end of the buffer list
			// another minor optimization we can make is to pretend that the buffers are shifted to the left like so
			// [##################|MMMM###MM]
			// [##################|###MMMMMM]
			// this leaves us with only a single dummy buffer at the end, and a guarantee that buffers will still be
			// freed in an appropriate order with no collisions

			// Move the existing regions to the end of the buffer list
			while (currentAllocation.bytesFromEnd() != currentAllocation.freeBytesAhead) {
				assert currentAllocation.bytesFromEnd() > currentAllocation.freeBytesAhead;
				Buffer buffer = buffers.pollFirst();
				if (buffer == null) {
					log.error("No more cache entries left to free, yet the allocation is still in use ({} != {})",
						currentAllocation.bytesFromEnd(), currentAllocation.freeBytesAhead);
					terminationHook.run();
					return 0;
				}

				if (buffer.endMarker) {
					// Shift unused space to the end of the buffer, as detailed above
					currentAllocation.freeBytesAhead += buffer.byteCapacity;
					assert currentAllocation.cursor + currentAllocation.freeBytesAhead <= currentAllocation.byteCapacity;
				} else {
					// Move the buffer to the end of the list, and pretend we've shifted it to the left as detailed above
					buffers.addLast(buffer);
					currentAllocation.cursor += buffer.byteCapacity;
				}
			}

			// Consume the remaining free bytes of the allocation
			buffers.addLast(new Buffer(currentAllocation.freeBytesAhead));
			// Advance to the next allocation, or the beginning of the same allocation if there is only one
			nextAllocation();

			if (currentAllocation.bytesFromEnd() < numBytes) {
				log.error("Failed to reserve space for {} bytes. Too large to fit in allocation {} of size {}",
					numBytes, currentAllocationIndex, currentAllocation.byteCapacity);
				terminationHook.run();
				return 0;
			}
		}

		while (currentAllocation.freeBytesAhead < numBytes) {
			if (removeOldestCacheEntry() == null) {
				log.error("No more cache entries left to free, yet there aren't enough free bytes ({} < {})",
					currentAllocation.freeBytesAhead, numBytes);
				terminationHook.run();
				return 0;
			}
		}

		return currentAllocation.reserve(numBytes);
	}

	private Buffer removeOldestCacheEntry() {
		Buffer buffer = buffers.pollFirst();

		if (buffer != null) {
			if (!buffer.endMarker) {
				cache.remove(buffer.hash, buffer);
				// Normally, these addresses will be equal, but in case they've been "shifted" as detailed in the
				// reserve function, the buffer's actual address will be larger than the cursor position
				assert currentAllocation.address + currentAllocation.cursor + currentAllocation.freeBytesAhead <=
					MemoryUtil.memAddress0(buffer.intBuffer == null ? buffer.floatBuffer : buffer.intBuffer);
			}

			currentAllocation.freeBytesAhead += buffer.byteCapacity;
			assert currentAllocation.cursor + currentAllocation.freeBytesAhead <= currentAllocation.byteCapacity;
		}

		return buffer;
	}

	public IntBuffer getIntBuffer(long hash) {
		Buffer buffer = get(hash);
		if (buffer == null)
			return null;
		return buffer.intBuffer;
	}

	public FloatBuffer getFloatBuffer(long hash) {
		Buffer buffer = get(hash);
		if (buffer == null)
			return null;
		return buffer.floatBuffer;
	}

	public IntBuffer reserveIntBuffer(long hash, int capacity) {
		long address = reserve(capacity * 4L);
		if (address == 0L)
			return null;
		Buffer buffer = new Buffer(hash, MemoryUtil.memIntBuffer(address, capacity));
		cache.put(hash, buffer);
		buffers.addLast(buffer);
		return buffer.intBuffer;
	}

	public FloatBuffer reserveFloatBuffer(long hash, int capacity) {
		long address = reserve(capacity * 4L);
		if (address == 0L)
			return null;
		Buffer buffer = new Buffer(hash, MemoryUtil.memFloatBuffer(address, capacity));
		cache.put(hash, buffer);
		buffers.addLast(buffer);
		return buffer.floatBuffer;
	}
}

package rs117.hd.model;

import javax.inject.Inject;
import javax.inject.Singleton;
import net.runelite.api.*;
import rs117.hd.HdPlugin;
import rs117.hd.scene.model_overrides.ModelOverride;
import rs117.hd.scene.model_overrides.UvType;

@Singleton
public class ModelHasher {
	@Inject
	private HdPlugin plugin;

	public long batchHash;
	public long vertexHash;
	public long normalHash;
	public long uvHash;

	private Model model;
	private int faceCount;
	private long faceColorsOneHash;
	private long faceColorsTwoHash;
	private long faceColorsThreeHash;
	private long faceTransparenciesHash;
	private long faceTexturesHash;
	private long xVerticesHash;
	private long yVerticesHash;
	private long zVerticesHash;
	private long faceIndicesOneHash;
	private long faceIndicesTwoHash;
	private long faceIndicesThreeHash;
	private long textureTrianglesHash;

	public void setModel(Model model, ModelOverride modelOverride, int preOrientation) {
		this.model = model;
		faceCount = model.getFaceCount();
		if (plugin.configUseFasterModelHashing) {
			faceColorsOneHash = fastHash(model.getFaceColors1());
			faceColorsTwoHash = 0;
			faceColorsThreeHash = 0;
			faceTransparenciesHash = fastByteHash(model.getFaceTransparencies());
			faceTexturesHash = fastShortHash(model.getFaceTextures());
			xVerticesHash = fastFloatHash(model.getVerticesX(), model.getVerticesCount());
			yVerticesHash = fastFloatHash(model.getVerticesY(), model.getVerticesCount());
			zVerticesHash = fastFloatHash(model.getVerticesZ(), model.getVerticesCount());
			faceIndicesOneHash = fastHash(model.getFaceIndices1());
			faceIndicesTwoHash = 0;
			faceIndicesThreeHash = 0;
			textureTrianglesHash = 0;
			final byte[] textureFaces = model.getTextureFaces();
			if (textureFaces != null) {
				boolean hasVanillaTexturedFaces = false;
				for (int textureId : textureFaces) {
					if (textureId != -1) {
						hasVanillaTexturedFaces = true;
						break;
					}
				}
				if (hasVanillaTexturedFaces) {
					final int[] texIndices1 = model.getTexIndices1();
					final int[] texIndices2 = model.getTexIndices2();
					final int[] texIndices3 = model.getTexIndices3();
					final float[] vertexX = model.getVerticesX();
					final float[] vertexY = model.getVerticesY();
					final float[] vertexZ = model.getVerticesZ();
					long h = 0;
					for (int i = 0; i < model.getFaceCount(); i++) {
						int texFace = textureFaces[i];
						if (texFace == -1)
							continue;
						texFace &= 0xff;
						final int texA = texIndices1[texFace];
						final int texB = texIndices2[texFace];
						final int texC = texIndices3[texFace];
						h = h * 31L + Float.floatToIntBits(vertexX[texA]);
						h = h * 31L + Float.floatToIntBits(vertexY[texA]);
						h = h * 31L + Float.floatToIntBits(vertexZ[texA]);
						h = h * 31L + Float.floatToIntBits(vertexX[texB]);
						h = h * 31L + Float.floatToIntBits(vertexY[texB]);
						h = h * 31L + Float.floatToIntBits(vertexZ[texB]);
						h = h * 31L + Float.floatToIntBits(vertexX[texC]);
						h = h * 31L + Float.floatToIntBits(vertexY[texC]);
						h = h * 31L + Float.floatToIntBits(vertexZ[texC]);
					}
					textureTrianglesHash = h;
				}
			}
		} else {
			faceColorsOneHash = fastHash(model.getFaceColors1());
			faceColorsTwoHash = fastHash(model.getFaceColors2());
			faceColorsThreeHash = fastHash(model.getFaceColors3());
			faceTransparenciesHash = fastByteHash(model.getFaceTransparencies());
			faceTexturesHash = fastShortHash(model.getFaceTextures());
			xVerticesHash = fastFloatHash(model.getVerticesX(), model.getVerticesCount());
			yVerticesHash = fastFloatHash(model.getVerticesY(), model.getVerticesCount());
			zVerticesHash = fastFloatHash(model.getVerticesZ(), model.getVerticesCount());
			faceIndicesOneHash = fastHash(model.getFaceIndices1());
			faceIndicesTwoHash = fastHash(model.getFaceIndices2());
			faceIndicesThreeHash = fastHash(model.getFaceIndices3());
			textureTrianglesHash = 0;
			final byte[] textureFaces = model.getTextureFaces();
			if (textureFaces != null) {
				boolean hasVanillaTexturedFaces = false;
				for (int textureId : textureFaces) {
					if (textureId != -1) {
						hasVanillaTexturedFaces = true;
						break;
					}
				}
				if (hasVanillaTexturedFaces) {
					final int[] texIndices1 = model.getTexIndices1();
					final int[] texIndices2 = model.getTexIndices2();
					final int[] texIndices3 = model.getTexIndices3();
					final float[] vertexX = model.getVerticesX();
					final float[] vertexY = model.getVerticesY();
					final float[] vertexZ = model.getVerticesZ();
					long h = 0;
					for (int i = 0; i < model.getFaceCount(); i++) {
						int texFace = textureFaces[i];
						if (texFace == -1)
							continue;
						texFace &= 0xff;
						final int texA = texIndices1[texFace];
						final int texB = texIndices2[texFace];
						final int texC = texIndices3[texFace];
						h = h * 31L + Float.floatToIntBits(vertexX[texA]);
						h = h * 31L + Float.floatToIntBits(vertexY[texA]);
						h = h * 31L + Float.floatToIntBits(vertexZ[texA]);
						h = h * 31L + Float.floatToIntBits(vertexX[texB]);
						h = h * 31L + Float.floatToIntBits(vertexY[texB]);
						h = h * 31L + Float.floatToIntBits(vertexZ[texB]);
						h = h * 31L + Float.floatToIntBits(vertexX[texC]);
						h = h * 31L + Float.floatToIntBits(vertexY[texC]);
						h = h * 31L + Float.floatToIntBits(vertexZ[texC]);
					}
					textureTrianglesHash = h;
				}
			}
		}

		vertexHash = calculateVertexCacheHash(modelOverride);
		normalHash = calculateNormalCacheHash();
		uvHash = calculateUvCacheHash(preOrientation, modelOverride);
		batchHash = vertexHash;
		batchHash = batchHash * 31 + normalHash;
		batchHash = batchHash * 31 + uvHash;
	}

	private long calculateVertexCacheHash(ModelOverride modelOverride) {
		long h = faceCount;
		h = h * 31L + faceColorsOneHash;
		h = h * 31L + faceColorsTwoHash;
		h = h * 31L + faceColorsThreeHash;
		h = h * 31L + faceTransparenciesHash;
		h = h * 31L + faceTexturesHash;
		h = h * 31L + xVerticesHash;
		h = h * 31L + yVerticesHash;
		h = h * 31L + zVerticesHash;
		h = h * 31L + faceIndicesOneHash;
		h = h * 31L + faceIndicesTwoHash;
		h = h * 31L + faceIndicesThreeHash;
		h = h * 31L + textureTrianglesHash;
		h = h * 31L + model.getOverrideAmount();
		h = h * 31L + model.getOverrideHue();
		h = h * 31L + model.getOverrideSaturation();
		h = h * 31L + model.getOverrideLuminance();
		h = h * 31L + modelOverride.hashCode();
		return h;
	}

	private long calculateNormalCacheHash() {
		long h = faceCount;
		h = h * 31L + faceIndicesOneHash;
		h = h * 31L + faceIndicesTwoHash;
		h = h * 31L + faceIndicesThreeHash;
		h = h * 31L + fastHash(model.getVertexNormalsX());
		h = h * 31L + fastHash(model.getVertexNormalsY());
		h = h * 31L + fastHash(model.getVertexNormalsZ());
		return h;
	}

	private long calculateUvCacheHash(int orientation, ModelOverride modelOverride) {
		long h = faceCount;
		h = h * 31L + (modelOverride.uvType == UvType.VANILLA || modelOverride.retainVanillaUvs ? textureTrianglesHash : 0);
		h = h * 31L + (modelOverride.uvType.orientationDependent ? orientation : 0);
		h = h * 31L + (modelOverride.uvType == UvType.BOX ? vertexHash : 0);
		h = h * 31L + modelOverride.hashCode();
		h = h * 31L + faceTexturesHash;
		return h;
	}

	public static long fastHash(int[] a) {
		if (a == null)
			return 0;

		int i = 0;
		long r = 1;
		int length = a.length;

		for (; i + 5 < length; i += 6)
			r = 31L * 31L * 31L * 31L * 31L * 31L * r +
				31L * 31L * 31L * 31L * 31L * a[i] +
				31L * 31L * 31L * 31L * a[i + 1] +
				31L * 31L * 31L * a[i + 2] +
				31L * 31L * a[i + 3] +
				31L * a[i + 4] +
				a[i + 5];

		for (; i < length; i++)
			r = 31L * r + a[i];

		return r;
	}

	public static long fastHash(int[] a, int length) {
		if (a == null)
			return 0;

		int i = 0;
		long r = 1;

		for (; i + 5 < length; i += 6)
			r = 31L * 31L * 31L * 31L * 31L * 31L * r +
				31L * 31L * 31L * 31L * 31L * a[i] +
				31L * 31L * 31L * 31L * a[i + 1] +
				31L * 31L * 31L * a[i + 2] +
				31L * 31L * a[i + 3] +
				31L * a[i + 4] +
				a[i + 5];

		for (; i < length; i++)
			r = 31L * r + a[i];

		return r;
	}

	public static int fastByteHash(byte[] a) {
		if (a == null)
			return 0;

		int i = 0;
		int r = 1;

		for (; i + 5 < a.length; i += 6)
			r = 31 * 31 * 31 * 31 * 31 * 31 * r
				+ 31 * 31 * 31 * 31 * 31 * a[i]
				+ 31 * 31 * 31 * 31 * a[i + 1]
				+ 31 * 31 * 31 * a[i + 2]
				+ 31 * 31 * a[i + 3]
				+ 31 * a[i + 4]
				+ a[i + 5];

		for (; i < a.length; i++) {
			r = 31 * r + a[i];
		}

		return r;
	}

    public static int fastShortHash(short[] a) {
		if (a == null)
			return 0;

		int i = 0;
		int r = 1;

		for (; i + 5 < a.length; i += 6)
			r = 31 * 31 * 31 * 31 * 31 * 31 * r +
				31 * 31 * 31 * 31 * 31 * a[i] +
				31 * 31 * 31 * 31 * a[i + 1] +
				31 * 31 * 31 * a[i + 2] +
				31 * 31 * a[i + 3] +
				31 * a[i + 4] +
				a[i + 5];

		for (; i < a.length; i++)
			r = 31 * r + a[i];

		return r;
	}

	public static int fastFloatHash(float[] a, int length) {
		if (a == null)
			return 0;

		int i = 0;
		int r = 1;

		for (; i + 5 < length; i += 6)
			r = 31 * 31 * 31 * 31 * 31 * 31 * r +
				31 * 31 * 31 * 31 * 31 * (int) (a[i] * 100) +
				31 * 31 * 31 * 31 * (int) (a[i + 1] * 100) +
				31 * 31 * 31 * (int) (a[i + 2] * 100) +
				31 * 31 * (int) (a[i + 3] * 100) +
				31 * (int) (a[i + 4] * 100) +
				(int) (a[i + 5] * 100);

		for (; i < length; i++)
			r = 31 * r + (int) (a[i] * 100);

		return r;
	}
}

package rs117.hd.model;

import lombok.RequiredArgsConstructor;

@RequiredArgsConstructor
public class ModelOffsets {
	public final int faceCount;
	public final int vertexOffset;
	public final int uvOffset;
}

package rs117.hd.opengl;

import java.nio.ByteBuffer;
import javax.inject.Inject;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.*;
import rs117.hd.HdPlugin;
import rs117.hd.overlays.FrameTimer;
import rs117.hd.overlays.Timer;
import rs117.hd.utils.jobs.Job;

import static org.lwjgl.opengl.GL33C.*;

@Slf4j
public final class AsyncUICopy extends Job {
	@Inject
	private Client client;

	@Inject
	private HdPlugin plugin;

	@Inject
	private FrameTimer timer;

	private ByteBuffer mappedBuffer;
	private int[] pixels;
	private int interfacePbo;
	private int interfaceTexture;
	private int width;
	private int height;
	private boolean inFlight = false;

	public void prepare(int interfacePbo, int interfaceTex) {
		// Ensure there isn't already another UI copy in progress
		if (mappedBuffer != null)
			return;

		var provider = client.getBufferProvider();
		this.pixels = provider.getPixels();
		this.width = provider.getWidth();
		this.height = provider.getHeight();
		this.interfacePbo = interfacePbo;
		this.interfaceTexture = interfaceTex;

		timer.begin(Timer.MAP_UI_BUFFER);
		glBindBuffer(GL_PIXEL_UNPACK_BUFFER, interfacePbo);
		ByteBuffer buffer = glMapBufferRange(
			GL_PIXEL_UNPACK_BUFFER,
			0,
			(long) width * height * Integer.BYTES,
			GL_MAP_WRITE_BIT | GL_MAP_INVALIDATE_BUFFER_BIT,
			mappedBuffer
		);
		glBindBuffer(GL_PIXEL_UNPACK_BUFFER, 0);
		timer.end(Timer.MAP_UI_BUFFER);

		if (buffer == null) {
			log.error("Unable to map interface PBO. Skipping UI...");
			return;
		}

		if (buffer != mappedBuffer)
			mappedBuffer = buffer;

		setExecuteAsync(client.getGameState() == GameState.LOGGED_IN);
		queue();
		inFlight = true;
	}

	public boolean complete() {
		if (mappedBuffer == null || !inFlight)
			return false;

		long timestamp = System.nanoTime();
		waitForCompletion();
		inFlight = false;

		var uiResolution = plugin.getUiResolution();
		if (uiResolution == null || width > uiResolution[0] || height > uiResolution[1]) {
			glBindBuffer(GL_PIXEL_UNPACK_BUFFER, 0);
			log.error("UI texture resolution mismatch ({}x{} > {}). Skipping UI...", width, height, uiResolution);
			return false;
		}

		glBindBuffer(GL_PIXEL_UNPACK_BUFFER, interfacePbo);
		glUnmapBuffer(GL_PIXEL_UNPACK_BUFFER);

		glActiveTexture(HdPlugin.TEXTURE_UNIT_UI);
		glBindTexture(GL_TEXTURE_2D, interfaceTexture);
		glTexSubImage2D(GL_TEXTURE_2D, 0, 0, 0, width, height, GL_BGRA, GL_UNSIGNED_INT_8_8_8_8_REV, 0);
		timer.add(Timer.COPY_UI, System.nanoTime() - timestamp);

		glBindBuffer(GL_PIXEL_UNPACK_BUFFER, 0);

		mappedBuffer = null;
		pixels = null;
		return true;
	}

	@Override
	protected void onRun() {
		mappedBuffer.asIntBuffer().put(pixels, 0, width * height);
	}

	@Override
	protected void onCancel() {}

	@Override
	protected void onReleased() {}
}

package rs117.hd.opengl.compute;

public enum ComputeMode
{
    OPENGL,
    OPENCL,
}
/*
 * Copyright (c) 2021, Adam <Adam@sigterm.info>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package rs117.hd.opengl.compute;

import java.io.IOException;
import java.nio.ByteBuffer;
import java.nio.IntBuffer;
import java.nio.LongBuffer;
import java.nio.ShortBuffer;
import javax.inject.Inject;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.*;
import net.runelite.client.util.OSType;
import net.runelite.rlawt.AWTContext;
import org.lwjgl.BufferUtils;
import org.lwjgl.PointerBuffer;
import org.lwjgl.opencl.APPLEGLSharing;
import org.lwjgl.opencl.CL;
import org.lwjgl.opencl.CL10GL;
import org.lwjgl.opencl.CL12;
import org.lwjgl.opencl.CLCapabilities;
import org.lwjgl.opencl.CLContextCallback;
import org.lwjgl.opencl.CLImageFormat;
import org.lwjgl.system.Configuration;
import org.lwjgl.system.MemoryStack;
import rs117.hd.HdPlugin;
import rs117.hd.opengl.shader.ShaderException;
import rs117.hd.opengl.shader.ShaderIncludes;
import rs117.hd.opengl.uniforms.UBOCompute;
import rs117.hd.renderer.legacy.LegacyRenderer;
import rs117.hd.utils.buffer.SharedGLBuffer;

import static org.lwjgl.opencl.APPLEGLSharing.CL_CGL_DEVICE_FOR_CURRENT_VIRTUAL_SCREEN_APPLE;
import static org.lwjgl.opencl.APPLEGLSharing.clGetGLContextInfoAPPLE;
import static org.lwjgl.opencl.CL10.*;
import static org.lwjgl.opencl.KHRGLSharing.CL_GLX_DISPLAY_KHR;
import static org.lwjgl.opencl.KHRGLSharing.CL_GL_CONTEXT_KHR;
import static org.lwjgl.opencl.KHRGLSharing.CL_WGL_HDC_KHR;
import static org.lwjgl.system.MemoryUtil.NULL;
import static org.lwjgl.system.MemoryUtil.memASCII;
import static org.lwjgl.system.MemoryUtil.memUTF8;
import static rs117.hd.utils.MathUtils.*;

@Slf4j
public class OpenCLManager {
	private static final String KERNEL_NAME_PASSTHROUGH = "passthroughModel";
	private static final String KERNEL_NAME_SORT = "sortModel";

	//  struct shared_data {
	//      int totalNum[12];
	//      int totalDistance[12];
	//      int totalMappedNum[18];
	//      int min10;
	//      int renderPris[0];
	//  };
	private static final int SHARED_SIZE = 12 + 12 + 18 + 1; // in ints

	@Inject
	private HdPlugin plugin;

	private LegacyRenderer legacyRenderer;

	public static long context;

	private boolean initialized;

	private CLCapabilities deviceCaps;
	private long device;
	private long commandQueue;

	private long passthroughProgram;
	private long[] sortingPrograms;

	private long passthroughKernel;
	private long[] sortingKernels;

	private long tileHeightMap;

	static {
		Configuration.OPENCL_EXPLICIT_INIT.set(true);
	}

	public void startUp(LegacyRenderer legacyRenderer, AWTContext awtContext) {
		this.legacyRenderer = legacyRenderer;
		CL.create();
		initialized = true;
		initializeContext(awtContext);
		log.debug("Device CL_DEVICE_MAX_WORK_GROUP_SIZE: {}", getMaxWorkGroupSize());
		initializeQueue();
	}

	public void shutDown() {
		if (!initialized)
			return;

		try {
			if (tileHeightMap != 0)
				clReleaseMemObject(tileHeightMap);
			tileHeightMap = 0;

			destroyPrograms();

			if (commandQueue != 0)
				clReleaseCommandQueue(commandQueue);
			commandQueue = 0;
			if (context != 0)
				clReleaseContext(context);
			context = 0;
			if (device != 0 && deviceCaps.OpenCL12)
				CL12.clReleaseDevice(device);
			device = 0;
		} finally {
			CL.destroy();
			initialized = false;
		}
	}

	private void initializeContext(AWTContext awtContext) {
		try (var stack = MemoryStack.stackPush()) {
			IntBuffer pi = stack.mallocInt(1);
			checkCLError(clGetPlatformIDs(null, pi));
			if (pi.get(0) == 0)
				throw new RuntimeException("No OpenCL platforms found.");

			PointerBuffer platforms = stack.mallocPointer(pi.get(0));
			checkCLError(clGetPlatformIDs(platforms, (IntBuffer) null));
			if (platforms.limit() == 0)
				throw new RuntimeException("Unable to find compute platform");

			PointerBuffer ctxProps = stack.mallocPointer(7)
				.put(CL_CONTEXT_PLATFORM)
				.put(0);
			switch (OSType.getOSType()) {
				case Windows:
					ctxProps
						.put(CL_GL_CONTEXT_KHR)
						.put(awtContext.getGLContext())
						.put(CL_WGL_HDC_KHR)
						.put(awtContext.getWGLHDC());
					break;
				case Linux:
					ctxProps
						.put(CL_GL_CONTEXT_KHR)
						.put(awtContext.getGLContext())
						.put(CL_GLX_DISPLAY_KHR)
						.put(awtContext.getGLXDisplay());
					break;
				case MacOS:
					ctxProps
						.put(APPLEGLSharing.CL_CONTEXT_PROPERTY_USE_CGL_SHAREGROUP_APPLE)
						.put(awtContext.getCGLShareGroup());
					break;
				default:
					throw new RuntimeException("unsupported platform");
			}
			ctxProps.put(0).flip();

			IntBuffer errcode_ret = stack.callocInt(1);
			for (int p = 0; p < platforms.limit(); p++) {
				try {
					long platform = platforms.get(p);
					ctxProps.put(1, platform);

					log.debug("Platform index {}:", p);
					log.debug("\tprofile: {}", getPlatformInfoStringUTF8(platform, CL_PLATFORM_PROFILE));
					log.debug("\tversion: {}", getPlatformInfoStringUTF8(platform, CL_PLATFORM_VERSION));
					log.debug("\tname: {}", getPlatformInfoStringUTF8(platform, CL_PLATFORM_NAME));
					log.debug("\tvendor: {}", getPlatformInfoStringUTF8(platform, CL_PLATFORM_VENDOR));
					log.debug("\textensions: {}", getPlatformInfoStringUTF8(platform, CL_PLATFORM_EXTENSIONS));

					int returnCode = clGetDeviceIDs(platform, CL_DEVICE_TYPE_ALL, null, pi);
					if (returnCode == CL_INVALID_DEVICE_TYPE) {
						log.debug("\tno devices");
						continue;
					}
					checkCLError(returnCode);

					PointerBuffer devices = stack.mallocPointer(pi.get(0));
					checkCLError(clGetDeviceIDs(platform, CL_DEVICE_TYPE_ALL, devices, (IntBuffer) null));

					for (int d = 0; d < devices.capacity(); d++) {
						long device = devices.get(d);
						long deviceType = getDeviceInfoLong(device, CL_DEVICE_TYPE);

						log.debug("\tdevice index {}:", d);
						log.debug("\t\tCL_DEVICE_NAME: {}", getDeviceInfoStringUTF8(device, CL_DEVICE_NAME));
						log.debug("\t\tCL_DEVICE_VENDOR: {}", getDeviceInfoStringUTF8(device, CL_DEVICE_VENDOR));
						log.debug("\t\tCL_DRIVER_VERSION: {}", getDeviceInfoStringUTF8(device, CL_DRIVER_VERSION));
						log.debug("\t\tCL_DEVICE_PROFILE: {}", getDeviceInfoStringUTF8(device, CL_DEVICE_PROFILE));
						log.debug("\t\tCL_DEVICE_VERSION: {}", getDeviceInfoStringUTF8(device, CL_DEVICE_VERSION));
						log.debug("\t\tCL_DEVICE_EXTENSIONS: {}", getDeviceInfoStringUTF8(device, CL_DEVICE_EXTENSIONS));
						log.debug("\t\tCL_DEVICE_TYPE: {}", deviceType);
						log.debug("\t\tCL_DEVICE_VENDOR_ID: {}", getDeviceInfoInt(device, CL_DEVICE_VENDOR_ID));
						log.debug("\t\tCL_DEVICE_MAX_COMPUTE_UNITS: {}", getDeviceInfoInt(device, CL_DEVICE_MAX_COMPUTE_UNITS));
						log.debug("\t\tCL_DEVICE_MAX_WORK_ITEM_DIMENSIONS: {}", getDeviceInfoInt(device, CL_DEVICE_MAX_WORK_ITEM_DIMENSIONS));
						log.debug("\t\tCL_DEVICE_MAX_WORK_GROUP_SIZE: {}", getDeviceInfoPointer(device, CL_DEVICE_MAX_WORK_GROUP_SIZE));
						log.debug("\t\tCL_DEVICE_MAX_CLOCK_FREQUENCY: {}", getDeviceInfoInt(device, CL_DEVICE_MAX_CLOCK_FREQUENCY));
						log.debug("\t\tCL_DEVICE_ADDRESS_BITS: {}", getDeviceInfoInt(device, CL_DEVICE_ADDRESS_BITS));
						log.debug("\t\tCL_DEVICE_AVAILABLE: {}", getDeviceInfoInt(device, CL_DEVICE_AVAILABLE) != 0);
						log.debug("\t\tCL_DEVICE_COMPILER_AVAILABLE: {}", (getDeviceInfoInt(device, CL_DEVICE_COMPILER_AVAILABLE) != 0));

						if (deviceType != CL_DEVICE_TYPE_GPU)
							continue;
						CLCapabilities platformCaps = CL.createPlatformCapabilities(platform);
						deviceCaps = CL.createDeviceCapabilities(device, platformCaps);
						if (!deviceCaps.cl_khr_gl_sharing && !deviceCaps.cl_APPLE_gl_sharing)
							continue;

						// Initialize a context from the device if one hasn't already been created
						if (context == 0) {
							try {
								var callback = CLContextCallback.create((errinfo, private_info, cb, user_data) ->
									log.error("[LWJGL] cl_context_callback: {}", memUTF8(errinfo)));
								long context = clCreateContext(ctxProps, device, callback, NULL, errcode_ret);
								checkCLError(errcode_ret);

								if (HdPlugin.APPLE) {
									var buf = stack.mallocPointer(1);
									checkCLError(clGetGLContextInfoAPPLE(
										context,
										awtContext.getGLContext(),
										CL_CGL_DEVICE_FOR_CURRENT_VIRTUAL_SCREEN_APPLE,
										buf,
										null
									));
									if (buf.get(0) != device) {
										log.debug("Skipping capable but not current virtual screen device...");
										clReleaseContext(context);
										continue;
									}
								}

								log.debug("Choosing the above device for OpenCL");
								this.device = device;
								OpenCLManager.context = context;
							} catch (Exception ex) {
								log.error("Error while creating context:", ex);
							}
						}
					}
				} catch (Exception ex) {
					log.error("Error while checking platform:", ex);
				}
			}

			if (context == 0)
				throw new RuntimeException("Unable to create suitable compute context");
		}
	}

	public int getMaxWorkGroupSize() {
		long[] maxWorkGroupSize = new long[1];
		clGetDeviceInfo(device, CL_DEVICE_MAX_WORK_GROUP_SIZE, maxWorkGroupSize, null);
		return (int) (maxWorkGroupSize[0] * 0.6f); // Workaround for https://github.com/117HD/RLHD/issues/598
	}

	private void initializeQueue() {
		long[] l = new long[1];
		clGetDeviceInfo(device, CL_DEVICE_QUEUE_PROPERTIES, l, null);

		commandQueue = clCreateCommandQueue(context, device, l[0] & CL_QUEUE_OUT_OF_ORDER_EXEC_MODE_ENABLE, (int[]) null);
		log.debug("Created command_queue {}, properties {}", commandQueue, l[0] & CL_QUEUE_OUT_OF_ORDER_EXEC_MODE_ENABLE);
	}

	private long compileProgram(MemoryStack stack, String path, ShaderIncludes includes) throws ShaderException, IOException {
		String source = includes.loadFile(path);
		log.trace("Compiling program:\n {}", source);
		IntBuffer errcode_ret = stack.callocInt(1);
		long program = clCreateProgramWithSource(context, source, errcode_ret);
		checkCLError(errcode_ret);

		int err = clBuildProgram(program, device, "", null, 0);
		if (err != CL_SUCCESS)
			throw ShaderException.compileError(
				includes,
				source,
				getProgramBuildInfoStringASCII(program, device, CL_PROGRAM_BUILD_LOG),
				path
			);

		log.debug("Build status: {}", getProgramBuildInfoInt(program, device, CL_PROGRAM_BUILD_STATUS));
		if (deviceCaps.OpenCL12)
			log.debug("Binary type: {}", getProgramBuildInfoInt(program, device, CL12.CL_PROGRAM_BINARY_TYPE));
		log.debug("Build options: {}", getProgramBuildInfoStringASCII(program, device, CL_PROGRAM_BUILD_OPTIONS));
		log.debug("Build log: {}", getProgramBuildInfoStringASCII(program, device, CL_PROGRAM_BUILD_LOG));
		return program;
	}

	private long getKernel(MemoryStack stack, long program, String kernelName) {
		IntBuffer errcode_ret = stack.callocInt(1);
		long kernel = clCreateKernel(program, kernelName, errcode_ret);
		checkCLError(errcode_ret);
		log.debug("Loaded kernel {} for program {}", kernelName, program);
		return kernel;
	}

	public void initializePrograms() throws ShaderException, IOException {
		try (var stack = MemoryStack.stackPush()) {
			var includes = new ShaderIncludes()
				.define("UNDO_VANILLA_SHADING", plugin.configUndoVanillaShading)
				.define("LEGACY_GREY_COLORS", plugin.configLegacyGreyColors)
				.define("WIND_DISPLACEMENT", plugin.configWindDisplacement)
				.define("WIND_DISPLACEMENT_NOISE_RESOLUTION", HdPlugin.WIND_DISPLACEMENT_NOISE_RESOLUTION)
				.define("CHARACTER_DISPLACEMENT", plugin.configCharacterDisplacement)
				.define("MAX_CHARACTER_POSITION_COUNT", UBOCompute.MAX_CHARACTER_POSITION_COUNT)
				.addIncludePath(OpenCLManager.class);
			passthroughProgram = compileProgram(stack, "comp_unordered.cl", includes);
			passthroughKernel = getKernel(stack, passthroughProgram, KERNEL_NAME_PASSTHROUGH);

			sortingPrograms = new long[legacyRenderer.numSortingBins];
			sortingKernels = new long[legacyRenderer.numSortingBins];
			for (int i = 0; i < legacyRenderer.numSortingBins; i++) {
				int faceCount = legacyRenderer.modelSortingBinFaceCounts[i];
				int threadCount = legacyRenderer.modelSortingBinThreadCounts[i];
				int facesPerThread = ceil((float) faceCount / threadCount);
				includes = includes
					.define("THREAD_COUNT", threadCount)
					.define("FACES_PER_THREAD", facesPerThread);
				sortingPrograms[i] = compileProgram(stack, "comp.cl", includes);
				sortingKernels[i] = getKernel(stack, sortingPrograms[i], KERNEL_NAME_SORT);
			}
		}
	}

	public void destroyPrograms() {
		if (passthroughKernel != 0)
			clReleaseKernel(passthroughKernel);
		passthroughKernel = 0;

		if (passthroughProgram != 0)
			clReleaseProgram(passthroughProgram);
		passthroughProgram = 0;

		if (sortingKernels != null)
			for (var kernel : sortingKernels)
				if (kernel != 0)
					clReleaseKernel(kernel);
		sortingKernels = null;

		if (sortingPrograms != null)
			for (var program : sortingPrograms)
				if (program != 0)
					clReleaseProgram(program);
		sortingPrograms = null;
	}

	public void uploadTileHeights(Scene scene) {
		if (tileHeightMap != 0)
			clReleaseMemObject(tileHeightMap);
		tileHeightMap = 0;

		final int TILEHEIGHT_BUFFER_SIZE = Constants.MAX_Z * Constants.EXTENDED_SCENE_SIZE * Constants.EXTENDED_SCENE_SIZE * Short.BYTES;
		ShortBuffer tileBuffer = BufferUtils.createShortBuffer(TILEHEIGHT_BUFFER_SIZE);
		int[][][] tileHeights = scene.getTileHeights();
		for (int z = 0; z < Constants.MAX_Z; ++z) {
			for (int y = 0; y < Constants.EXTENDED_SCENE_SIZE; ++y) {
				for (int x = 0; x < Constants.EXTENDED_SCENE_SIZE; ++x) {
					int h = tileHeights[z][x][y];
					assert (h & 0b111) == 0;
					h >>= 3;
					tileBuffer.put((short) h);
				}
			}
		}
		tileBuffer.flip();

		try (MemoryStack stack = MemoryStack.stackPush()) {
			CLImageFormat imageFormat = CLImageFormat.calloc(stack);
			imageFormat.image_channel_order(CL_R);
			imageFormat.image_channel_data_type(CL_SIGNED_INT16);

			IntBuffer errcode_ret = stack.callocInt(1);
			tileHeightMap = clCreateImage3D(context, CL_MEM_READ_ONLY | CL_MEM_COPY_HOST_PTR, imageFormat,
				Constants.EXTENDED_SCENE_SIZE, Constants.EXTENDED_SCENE_SIZE, Constants.MAX_Z,
				0L, 0L,
				tileBuffer,
				errcode_ret
			);
			checkCLError(errcode_ret);
		}
	}

	public void compute(
		SharedGLBuffer uboCompute,
		int numPassthroughModels, int[] numSortingBinModels,
		SharedGLBuffer modelPassthroughBuffer, SharedGLBuffer[] modelSortingBuffers,
		SharedGLBuffer stagingBufferVertices, SharedGLBuffer stagingBufferUvs, SharedGLBuffer stagingBufferNormals,
		SharedGLBuffer renderBufferVertices, SharedGLBuffer renderBufferUvs, SharedGLBuffer renderBufferNormals
	) {
		try (var stack = MemoryStack.stackPush()) {
			PointerBuffer glBuffers = stack.mallocPointer(8 + modelSortingBuffers.length)
				.put(uboCompute.clId)
				.put(modelPassthroughBuffer.clId)
				.put(stagingBufferVertices.clId)
				.put(stagingBufferUvs.clId)
				.put(stagingBufferNormals.clId)
				.put(renderBufferVertices.clId)
				.put(renderBufferUvs.clId)
				.put(renderBufferNormals.clId);
			for (var buffer : modelSortingBuffers)
				glBuffers.put(buffer.clId);
			glBuffers.flip();

			PointerBuffer acquireEvent = stack.callocPointer(1);
			CL10GL.clEnqueueAcquireGLObjects(commandQueue, glBuffers, null, acquireEvent);

			PointerBuffer computeEvents = stack.callocPointer(1 + modelSortingBuffers.length);
			if (numPassthroughModels > 0) {
				clSetKernelArg1p(passthroughKernel, 0, modelPassthroughBuffer.clId);
				clSetKernelArg1p(passthroughKernel, 1, stagingBufferVertices.clId);
				clSetKernelArg1p(passthroughKernel, 2, stagingBufferUvs.clId);
				clSetKernelArg1p(passthroughKernel, 3, stagingBufferNormals.clId);
				clSetKernelArg1p(passthroughKernel, 4, renderBufferVertices.clId);
				clSetKernelArg1p(passthroughKernel, 5, renderBufferUvs.clId);
				clSetKernelArg1p(passthroughKernel, 6, renderBufferNormals.clId);

				// queue compute call after acquireGLBuffers
				clEnqueueNDRangeKernel(commandQueue, passthroughKernel, 1, null,
					stack.pointers(numPassthroughModels * 6L), stack.pointers(6),
					acquireEvent, computeEvents
				);
				computeEvents.position(computeEvents.position() + 1);
			}

			for (int i = 0; i < numSortingBinModels.length; i++) {
				int numModels = numSortingBinModels[i];
				if (numModels == 0)
					continue;

				int faceCount = legacyRenderer.modelSortingBinFaceCounts[i];
				int threadCount = legacyRenderer.modelSortingBinThreadCounts[i];
				long kernel = sortingKernels[i];

				clSetKernelArg(kernel, 0, (long) (SHARED_SIZE + faceCount) * Integer.BYTES);
				clSetKernelArg1p(kernel, 1, modelSortingBuffers[i].clId);
				clSetKernelArg1p(kernel, 2, stagingBufferVertices.clId);
				clSetKernelArg1p(kernel, 3, stagingBufferUvs.clId);
				clSetKernelArg1p(kernel, 4, stagingBufferNormals.clId);
				clSetKernelArg1p(kernel, 5, renderBufferVertices.clId);
				clSetKernelArg1p(kernel, 6, renderBufferUvs.clId);
				clSetKernelArg1p(kernel, 7, renderBufferNormals.clId);
				clSetKernelArg1p(kernel, 8, uboCompute.clId);
				clSetKernelArg1p(kernel, 9, tileHeightMap);

				clEnqueueNDRangeKernel(commandQueue, kernel, 1, null,
					stack.pointers((long) numModels * threadCount),
					stack.pointers(threadCount),
					acquireEvent, computeEvents
				);
				computeEvents.position(computeEvents.position() + 1);
			}

			computeEvents.flip();
			CL10GL.clEnqueueReleaseGLObjects(commandQueue, glBuffers, computeEvents.hasRemaining() ? computeEvents : null, null);

			// Release OpenCL events to prevent memory leak
			// Events are reference-counted host memory objects that must be explicitly freed
			long pointer = acquireEvent.get(0);
			if (pointer != 0L)
				clReleaseEvent(pointer);

			for (int i = 0; i < computeEvents.limit(); ++i) {
				pointer = computeEvents.get(i);
				if (pointer != 0L)
					clReleaseEvent(pointer);
			}
		}
	}

	public void finish() {
		if (commandQueue != 0)
			clFinish(commandQueue);
	}

	private static String getPlatformInfoStringUTF8(long cl_platform_id, int param_name) {
		try (var stack = MemoryStack.stackPush()) {
			PointerBuffer pp = stack.mallocPointer(1);
			checkCLError(clGetPlatformInfo(cl_platform_id, param_name, (ByteBuffer) null, pp));
			int bytes = (int) pp.get(0);

			ByteBuffer buffer = stack.malloc(bytes);
			checkCLError(clGetPlatformInfo(cl_platform_id, param_name, buffer, null));

			return memUTF8(buffer, bytes - 1);
		}
	}

	private static long getDeviceInfoLong(long cl_device_id, int param_name) {
		try (var stack = MemoryStack.stackPush()) {
			LongBuffer pl = stack.mallocLong(1);
			checkCLError(clGetDeviceInfo(cl_device_id, param_name, pl, null));
			return pl.get(0);
		}
	}

	private static int getDeviceInfoInt(long cl_device_id, int param_name) {
		try (var stack = MemoryStack.stackPush()) {
			IntBuffer pl = stack.mallocInt(1);
			checkCLError(clGetDeviceInfo(cl_device_id, param_name, pl, null));
			return pl.get(0);
		}
	}

	private static long getDeviceInfoPointer(long cl_device_id, int param_name) {
		try (var stack = MemoryStack.stackPush()) {
			PointerBuffer pp = stack.mallocPointer(1);
			checkCLError(clGetDeviceInfo(cl_device_id, param_name, pp, null));
			return pp.get(0);
		}
	}

	private static String getDeviceInfoStringUTF8(long cl_device_id, int param_name) {
		try (var stack = MemoryStack.stackPush()) {
			PointerBuffer pp = stack.mallocPointer(1);
			checkCLError(clGetDeviceInfo(cl_device_id, param_name, (ByteBuffer) null, pp));
			int bytes = (int) pp.get(0);

			ByteBuffer buffer = stack.malloc(bytes);
			checkCLError(clGetDeviceInfo(cl_device_id, param_name, buffer, null));

			return memUTF8(buffer, bytes - 1);
		}
	}

	private static int getProgramBuildInfoInt(long cl_program_id, long cl_device_id, int param_name) {
		try (var stack = MemoryStack.stackPush()) {
			IntBuffer pl = stack.mallocInt(1);
			checkCLError(clGetProgramBuildInfo(cl_program_id, cl_device_id, param_name, pl, null));
			return pl.get(0);
		}
	}

	private static String getProgramBuildInfoStringASCII(long cl_program_id, long cl_device_id, int param_name) {
		try (var stack = MemoryStack.stackPush()) {
			PointerBuffer pp = stack.mallocPointer(1);
			checkCLError(clGetProgramBuildInfo(cl_program_id, cl_device_id, param_name, (ByteBuffer) null, pp));
			int bytes = (int) pp.get(0);

			ByteBuffer buffer = stack.malloc(bytes);
			checkCLError(clGetProgramBuildInfo(cl_program_id, cl_device_id, param_name, buffer, null));

			return memASCII(buffer, bytes - 1);
		}
	}

	private static void checkCLError(IntBuffer errcode) {
		checkCLError(errcode.get(errcode.position()));
	}

	private static void checkCLError(int errcode) {
		if (errcode != CL_SUCCESS)
			throw new RuntimeException(String.format("OpenCL error [%d]", errcode));
	}
}

package rs117.hd.opengl;

import java.util.Arrays;
import java.util.HashSet;
import java.util.Objects;
import java.util.Set;
import java.util.function.Supplier;

public abstract class GLState<T> {
	public T owner;
	protected boolean hasValue;
	protected boolean hasApplied;

	public void reset() {
		hasValue = hasApplied = false;
	}

	public void apply() {
		if (hasValue) {
			internalApply();
			hasValue = false;
			hasApplied = true;
		}
	}

	abstract void internalApply();

	public abstract static class SingleState<T, K> extends GLState<T> {
		private K value;
		private K appliedValue;

		public void set(K v) {
			hasValue = true;
			value = v;
		}

		@Override
		void internalApply() {
			if (!hasApplied || !Objects.equals(value, appliedValue)) {
				applyValue(value);
				appliedValue = value;
			}
		}

		protected abstract void applyValue(K value);
	}

	public abstract static class PrimitiveArrayState<T, K> extends GLState<T> {
		private final K[] value;
		private final K[] appliedValue;

		protected PrimitiveArrayState(Supplier<K[]> supplier) {
			this.value = supplier.get();
			this.appliedValue = supplier.get();
		}

		public void set(K... v) {
			hasValue = true;
			System.arraycopy(v, 0, value, 0, v.length);
		}

		@Override
		void internalApply() {
			if (!hasApplied || !Arrays.equals(value, appliedValue)) {
				applyValues(value);
				System.arraycopy(value, 0, appliedValue, 0, value.length);
			}
		}

		protected abstract void applyValues(K[] values);
	}

	public abstract static class GLFlagSetState<T> extends GLState<T> {
		private final Set<Integer> targets = new HashSet<>();

		public void add(int target) {
			hasValue = true;
			targets.add(target);
		}

		public void remove(int target) {
			targets.remove(target);
			hasApplied = !targets.isEmpty();
		}

		@Override
		void internalApply() {
			for (int t : targets) applyTarget(t);
			targets.clear();
		}

		@Override
		public void reset() {
			super.reset();
			targets.clear();
		}

		protected abstract void applyTarget(int target);
	}
}

package rs117.hd.opengl.shader;

import org.lwjgl.opengl.*;

public class ModelPassthroughComputeProgram extends ShaderProgram {
	public ModelPassthroughComputeProgram() {
		super(t -> t.add(GL43C.GL_COMPUTE_SHADER, "comp_unordered.glsl"));
	}
}

package rs117.hd.opengl.shader;

import java.io.IOException;
import org.lwjgl.opengl.*;

import static rs117.hd.HdPlugin.TEXTURE_UNIT_TILE_HEIGHT_MAP;

public class ModelSortingComputeProgram extends ShaderProgram {
	public final int threadCount, facesPerThread;

	private final UniformTexture uniTileHeightMap = addUniformTexture("tileHeightMap");

	public ModelSortingComputeProgram(int threadCount, int facesPerThread) {
		super(t -> t.add(GL43C.GL_COMPUTE_SHADER, "comp.glsl"));
		this.threadCount = threadCount;
		this.facesPerThread = facesPerThread;
	}

	@Override
	protected void initialize() {
		uniTileHeightMap.set(TEXTURE_UNIT_TILE_HEIGHT_MAP);
	}

	@Override
	public void compile(ShaderIncludes includes) throws ShaderException, IOException {
		super.compile(includes
			.define("THREAD_COUNT", threadCount)
			.define("FACES_PER_THREAD", facesPerThread));
	}
}

package rs117.hd.opengl.shader;

import static org.lwjgl.opengl.GL33C.*;
import static rs117.hd.HdPlugin.TEXTURE_UNIT_GAME;
import static rs117.hd.HdPlugin.TEXTURE_UNIT_SHADOW_MAP;
import static rs117.hd.HdPlugin.TEXTURE_UNIT_TILED_LIGHTING_MAP;

public class SceneShaderProgram extends ShaderProgram {
	private final UniformTexture uniTextureArray = addUniformTexture("textureArray");
	private final UniformTexture uniShadowMap = addUniformTexture("shadowMap");
	private final UniformTexture uniTiledLightingTextureArray = addUniformTexture("tiledLightingArray");

	public SceneShaderProgram() {
		super(t -> t
			.add(GL_VERTEX_SHADER, "scene_vert.glsl")
			.add(GL_GEOMETRY_SHADER, "scene_geom.glsl")
			.add(GL_FRAGMENT_SHADER, "scene_frag.glsl"));
		uniTiledLightingTextureArray.ignoreMissing = true;
	}

	@Override
	protected void initialize() {
		uniTextureArray.set(TEXTURE_UNIT_GAME);
		uniShadowMap.set(TEXTURE_UNIT_SHADOW_MAP);
		uniTiledLightingTextureArray.set(TEXTURE_UNIT_TILED_LIGHTING_MAP);
	}
}

/*
 * Copyright (c) 2018, Adam <Adam@sigterm.info>
 * Copyright (c) 2025, Hooder <ahooder@protonmail.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package rs117.hd.opengl.shader;

import java.util.regex.Matcher;
import java.util.regex.Pattern;
import lombok.extern.slf4j.Slf4j;

@Slf4j
public class ShaderException extends Exception
{
	private static final Pattern NVIDIA_GL_ERROR_REGEX = Pattern.compile("^(\\d+)\\((\\d+)\\) : (.*)$", Pattern.MULTILINE);
	private static final Pattern NVIDIA_CL_ERROR_REGEX = Pattern.compile("^<kernel>:(\\d+):(\\d+): (.*)$", Pattern.MULTILINE);
	private static final Pattern CL_LINE_REGEX = Pattern.compile("^#line (\\d+) \"(.*)\"", Pattern.MULTILINE);

	public ShaderException(String message) {
		super(message);
	}

	public static ShaderException compileError(ShaderIncludes includes, String source, String error, String... paths)
	{
		boolean linkerError = paths.length > 1;

		StringBuilder sb = new StringBuilder();
		sb.append("Error when ");
		if (linkerError) {
			sb.append("linking shaders");
		} else {
			sb.append("compiling shader");
		}
		sb.append(": ");
		for (int i = 0; i < paths.length; i++) {
			if (i > 0)
				sb.append(" & ");
			sb.append(paths[i]);
		}
		sb.append('\n');

		// We can't parse linker errors without making line directives unique across different shader units
		if (linkerError)
			return new ShaderException(sb.append(error).toString());

		switch (includes.includeType) {
			case GLSL: {
				Matcher m = NVIDIA_GL_ERROR_REGEX.matcher(error);
				if (m.find()) {
					try {
						int prevEnd = 0;
						do {
							if (m.start() > prevEnd)
								sb.append(error, prevEnd, m.start());
							prevEnd = m.end();

							int index = Integer.parseInt(m.group(1));
							int lineNumber = Integer.parseInt(m.group(2));
							String errorString = m.group(3);
							String include = includes.includeList.get(index);
							sb.append(String.format("%s line %d - %s", include, lineNumber, errorString));
						} while (m.find());
						return new ShaderException(sb.toString());
					} catch (Exception ex) {
						log.error("Error while parsing shader compilation error:", ex);
						break;
					}
				}
				break;
			}
			case C:
				Matcher m = NVIDIA_CL_ERROR_REGEX.matcher(error);
				if (m.find()) {
					try {
						int prevEnd = 0;
						do {
							if (m.start() > prevEnd)
								sb.append(error, prevEnd, m.start());
							prevEnd = m.end();

							int lineNumber = Integer.parseInt(m.group(1));
							String errorString = m.group(3);
							String include = "Unknown source";

							var lm = CL_LINE_REGEX.matcher("");
							String[] lines = source.split("\n", lineNumber);
							for (int i = lineNumber - 2; i >= 0; i--) {
								lm.reset(lines[i]);
								if (lm.find()) {
									lineNumber += Integer.parseInt(lm.group(1)) - i - 2;
									include = lm.group(2).replaceAll("\\\\\"", "\"");
									break;
								}
							}

							sb.append(String.format("%s line %d - %s", include, lineNumber, errorString));
						} while (m.find());
						return new ShaderException(sb.toString());
					} catch (Exception ex) {
						log.error("Error while parsing shader compilation error:", ex);
						break;
					}
				}
				break;
		}

		// Unknown error format, so include a mapping from source file indices to paths
		sb.append(error).append("Included sources: [\n");
		int maxIndexWidth = String.valueOf(includes.includeList.size() - 1).length();
		String indexFormat = String.format("%%%dd", maxIndexWidth + 2);
		for (int i = 0; i < includes.includeList.size(); i++)
			sb
				.append(String.format(indexFormat, i))
				.append(": ")
				.append(includes.includeList.get(i))
				.append('\n');
		sb.append("]");

		return new ShaderException(error);
	}
}

/*
 * Copyright (c) 2018, Adam <Adam@sigterm.info>
 * Copyright (c) 2025, Hooder <ahooder@protonmail.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package rs117.hd.opengl.shader;

import java.io.IOException;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.Stack;
import java.util.function.Supplier;
import java.util.regex.Pattern;
import lombok.extern.slf4j.Slf4j;
import rs117.hd.opengl.uniforms.UniformBuffer;
import rs117.hd.utils.Props;
import rs117.hd.utils.ResourcePath;

import static rs117.hd.utils.ResourcePath.path;

@Slf4j
public class ShaderIncludes {
	public static final ResourcePath SHADER_DUMP_PATH = Props.getFolder("rlhd.dump-shaders", () -> null);

	enum Type { GLSL, C, UNKNOWN }

	private static final Pattern IDENTIFIER_PATTERN = Pattern.compile("^[a-zA-Z_]\\w*");

	@FunctionalInterface
	public interface IncludeProcessor {
		String process(String expression) throws IOException;
	}

	private final List<IncludeProcessor> includeProcessors = new ArrayList<>();
	private final List<ResourcePath> includePaths = new ArrayList<>();
	private final Map<String, Supplier<String>> includeMap = new HashMap<>();

	public final Set<UniformBuffer<?>> uniformBuffers = new HashSet<>();

	Type includeType = Type.UNKNOWN;
	final Stack<Integer> includeStack = new Stack<>();
	final List<String> includeList = new ArrayList<>();

	public ShaderIncludes copy() {
		var clone = new ShaderIncludes();
		clone.includeProcessors.addAll(includeProcessors);
		clone.includePaths.addAll(includePaths);
		clone.includeMap.putAll(includeMap);
		clone.uniformBuffers.addAll(uniformBuffers);
		return clone;
	}

	private static int nextUnescapedMatch(String s, int offset, char targetChar) {
		int i;
		while ((i = s.indexOf(targetChar, offset)) != -1) {
			// Check if the char was escaped
			int j = i - 1;
			while (j >= 0 && s.charAt(j) == '\\')
				j--;
			if ((i - j) % 2 != 0)
				break; // Not escaped
			offset = i + 1;
		}
		return i;
	}

	private static boolean isCommentOrEmpty(String expression) {
		expression = expression.stripLeading();
		if (expression.isEmpty())
			return true;

		if (expression.length() < 2 || expression.charAt(0) != '/')
			return false;

		switch (expression.charAt(1)) {
			case '/':
				return true;
			case '*':
				int i = expression.indexOf("*/");
				return i == -1 || isCommentOrEmpty(expression.substring(i + 2));
		}

		return false;
	}

	private ShaderException syntaxError(int lineNumber, String error) {
		String currentFile = includeList.get(includeStack.peek());
		return new ShaderException(String.format(
			"Syntax error in shader include in '%s' on line %d: %s", currentFile, lineNumber, error));
	}

	private ShaderException includeError(int lineNumber, String include) {
		String currentFile = includeList.get(includeStack.peek());
		return new ShaderException(String.format(
			"Failed to load shader include in '%s' on line %d: #include %s", currentFile, lineNumber, include));
	}

	private String parse(String source) throws ShaderException, IOException {
		StringBuilder sb = new StringBuilder();
		int lineNumber = 0;
		for (String line : source.split("\r?\n")) {
			lineNumber++;
			String trimmed = line.stripLeading();
			if (trimmed.startsWith("#include ")) {
				int currentIncludeIndex = includeList.size();
				int parentIncludeIndex = includeStack.peek();
				String currentFile = includeList.get(parentIncludeIndex);

				String expression = trimmed.substring(9).stripLeading();
				if (expression.isEmpty())
					throw syntaxError(lineNumber, "Empty include");

				String includeContents = null;
				char endChar = '"';
				int commentIndex = -1;
				switch (expression.charAt(0)) {
					case '<':
						endChar = '>';
					case '"':
						// Process path includes
						int endIndex = nextUnescapedMatch(expression, 1, endChar);
						if (endIndex == -1)
							throw syntaxError(lineNumber, "Expected closing '" + endChar + "' in include");

						commentIndex = endIndex + 1;
						if (!isCommentOrEmpty(expression.substring(commentIndex)))
							throw syntaxError(
								lineNumber,
								"Unexpected characters after closing '" + endChar + "' in include. Only comments are allowed."
							);

						// Valid include
						String include = expression.substring(1, endIndex);
						if (endChar == '"')
							include = ResourcePath.normalize(currentFile, "..", include);

						includeContents = loadFileInternal(include);
						if (includeContents == null)
							throw includeError(lineNumber, expression.substring(0, endIndex + 1));
						break;
					default:
						// Process constant identifier includes
						var m = IDENTIFIER_PATTERN.matcher(expression);
						if (m.find() && isCommentOrEmpty(expression.substring(m.end()))) {
							commentIndex = m.end();
							var supplier = includeMap.get(m.group());
							if (supplier == null)
								throw includeError(lineNumber, m.group());
							includeContents = supplier.get();
							break;
						}

						// Fall back to custom include processors
						for (var processor : includeProcessors)
							if ((includeContents = processor.process(expression)) != null)
								break;
				}

				if (includeContents == null) {
					log.error("Include not found. Did you forget quotes?", includeError(lineNumber, expression));
					includeContents = String.format("// Not found: %s", expression);
				}

				if (SHADER_DUMP_PATH != null) {
					sb.append("// Include: ").append(expression).append('\n');
					includeContents += String.format("\n// End include: %s", expression);
				}

				switch (includeType) {
					case GLSL:
						if (includeContents.stripLeading().startsWith("#version ")) {
							// In GLSL, no preprocessor directive can precede #version, so handle included files
							// starting with a #version directive differently.
							sb.append(includeContents);
						} else {
							// In GLSL, the #line directive takes a line number and a source file index, which we map to
							// an include-filename through tracking the list of includes.
							// Source: https://www.khronos.org/opengl/wiki/Core_Language_(GLSL)#.23line_directive
							sb
								.append("#line 1 ") // Mark the first line of the included file
								.append(currentIncludeIndex)
								.append('\n')
								.append(includeContents)
								.append('\n')
								.append("#line ") // Return to the next line of the current file
								.append(lineNumber + 1)
								.append(" ")
								.append(parentIncludeIndex)
								.append('\n');
						}
						break;
					case C:
						// In C, #line followed by a line number sets the line number for the current file, while
						// #line followed by a line number and a string constant filename changes the line number and
						// current filename being processed, so in our case we will only be using the latter.
						// Source: https://gcc.gnu.org/onlinedocs/cpp/Line-Control.html
						sb
							.append("#line 1 \"") // Change to line 1 in the included file
							.append(expression.replaceAll("\"", "\\\\\""))
							.append("\"\n")
							.append(includeContents)
							.append('\n')
							.append("#line ") // Return to the next line in the parent include
							.append(lineNumber + 1)
							.append(" \"")
							.append(currentFile)
							.append("\"\n");
						break;
					default:
						sb.append(includeContents).append('\n');
						break;
				}

				String comment = commentIndex == -1 ? "" : expression.substring(commentIndex).stripLeading();
				if (!comment.isEmpty())
					sb.append(comment).append('\n');
			} else if (trimmed.startsWith("#pragma once")) {
				int currentIndex = includeList.size() - 1;
				String currentInclude = includeList.get(currentIndex);
				sb.append("// #pragma once: ");
				if (includeList.indexOf(currentInclude) != currentIndex) {
					sb.append("already included\n");
					break;
				} else {
					sb.append("first include\n");
				}
			} else {
				sb.append(line).append('\n');
			}
		}
		return sb.toString();
	}

	private String loadFileInternal(String path) throws ShaderException, IOException {
		includeStack.push(includeList.size());
		includeList.add(path);

		String source = null;
		for (var includePath : includePaths) {
			var resourcePath = includePath.resolve(path);
			if (resourcePath.exists()) {
				source = parse(resourcePath.loadString());
				if (SHADER_DUMP_PATH != null)
					SHADER_DUMP_PATH.resolve(resourcePath.path).mkdirs().writeString(source);
				break;
			}
		}

		includeStack.pop();
		return source;
	}

	public String loadFile(String path) throws ShaderException, IOException {
		includeList.clear();

		switch (path(path).getExtension().toLowerCase()) {
			case "glsl":
				includeType = Type.GLSL;
				break;
			case "c":
			case "h":
			case "cl":
				includeType = Type.C;
				break;
			default:
				includeType = Type.UNKNOWN;
				break;
		}

		String source = loadFileInternal(path);
		if (source != null)
			return source;

		throw new IOException("Failed to load file: " + path);
	}

	public ShaderIncludes addIncludePath(Class<?> clazz) {
		return addIncludePath(path(clazz));
	}

	public ShaderIncludes addIncludePath(ResourcePath includePath) {
		includePaths.add(includePath.chroot());
		return this;
	}

	public ShaderIncludes addInclude(String identifier, Supplier<String> supplier) {
		includeMap.put(identifier, supplier);
		return this;
	}

	public ShaderIncludes addInclude(String identifier, String value) {
		return addInclude(identifier, () -> value);
	}

	public ShaderIncludes addUniformBuffer(UniformBuffer<?> ubo) {
		uniformBuffers.add(ubo);
		return this;
	}

	public ShaderIncludes define(String identifier, String value) {
		return addInclude(identifier, String.format("#define %s %s", identifier, value));
	}

	public ShaderIncludes define(String identifier, boolean value) {
		return define(identifier, String.format("%d", value ? 1 : 0));
	}

	public ShaderIncludes define(String identifier, int value) {
		return define(identifier, String.format("%d", value));
	}

	/**
	 * Define a single-precision float shader constant. OpenCL warns when using doubles in float contexts.
	 */
	public ShaderIncludes define(String identifier, float value) {
		return define(identifier, String.format("%ff", value));
	}

	/**
	 * Define a double-precision float shader constant.
	 */
	public ShaderIncludes define(String identifier, double value) {
		return define(identifier, String.format("%f", value));
	}

	public ShaderIncludes define(String identifier, Enum<?> enumValue) {
		return define(identifier, String.format("%d", enumValue.ordinal()));
	}
}

package rs117.hd.opengl.shader;

import java.io.IOException;
import java.util.ArrayList;
import java.util.List;
import java.util.function.Consumer;
import lombok.Getter;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import rs117.hd.opengl.uniforms.UniformBuffer;

import static org.lwjgl.opengl.GL33C.*;

@Slf4j
public class ShaderProgram {
	@RequiredArgsConstructor
	private static class UniformBufferBlockPair {
		public final UniformBuffer<?> buffer;
		public final int uboProgramIndex;
	}

	private final List<UniformProperty> uniformProperties = new ArrayList<>();
	private final List<UniformBufferBlockPair> uniformBlockMappings = new ArrayList<>();

	protected final ShaderTemplate shaderTemplate;

	private int program;
	@Getter
	private boolean viable = true;

	public ShaderProgram(Consumer<ShaderTemplate> templateConsumer) {
		shaderTemplate = new ShaderTemplate();
		templateConsumer.accept(shaderTemplate);
	}

	public void compile(ShaderIncludes includes) throws ShaderException, IOException {
		int newProgram;
		try {
			newProgram = shaderTemplate.compile(includes);
		} catch (ShaderException ex) {
			viable = false;
			throw ex;
		}

		if (isValid())
			destroy();

		program = newProgram;
		assert isValid();

		for (var prop : uniformProperties) {
			prop.uniformIndex = glGetUniformLocation(program, prop.uniformName);
			if (prop.uniformIndex == -1 && !prop.ignoreMissing)
				log.warn("{} has missing or unused {}: {}", getClass().getSimpleName(), prop.getClass().getSimpleName(), prop.uniformName);
		}

		for (var ubo : includes.uniformBuffers) {
			int bindingIndex = glGetUniformBlockIndex(program, ubo.getUniformBlockName());
			if (bindingIndex != -1)
				uniformBlockMappings.add(new UniformBufferBlockPair(ubo, bindingIndex));
		}

		use();
		initialize();

		glValidateProgram(program);
		if (glGetProgrami(program, GL_VALIDATE_STATUS) == GL_FALSE) {
			String err = glGetProgramInfoLog(program);
			log.error("Failed to validate shader program: {}", getClass().getSimpleName(), new ShaderException(err));
		}
	}

	protected void initialize() {}

	public boolean isValid() {
		return program != 0;
	}

	public boolean isActive() {
		// Meant for debugging only
		return program == glGetInteger(GL_CURRENT_PROGRAM);
	}

	@SuppressWarnings("unchecked")
	public <T extends UniformBuffer<?>> T getUniformBufferBlock(int UniformBlockIndex) {
		for (UniformBufferBlockPair pair : uniformBlockMappings)
			if (pair.buffer.getBindingIndex() == UniformBlockIndex)
				return (T) pair.buffer;
		return null;
	}

	public void use() {
		assert program != 0;
		glUseProgram(program);

		for (UniformBufferBlockPair pair : uniformBlockMappings)
			glUniformBlockBinding(program, pair.uboProgramIndex, pair.buffer.getBindingIndex());
	}

	public void destroy() {
		viable = true;
		if (program == 0)
			return;

		glDeleteProgram(program);
		program = 0;

		for (var prop : uniformProperties)
			prop.destroy();

		uniformBlockMappings.clear();
	}

	private static class UniformProperty {
		ShaderProgram program;
		String uniformName;
		int uniformIndex;
		boolean ignoreMissing;

		void destroy() {
			uniformIndex = -1;
		}
	}

	private <T extends UniformProperty> T addUniform(T property, String uniformName) {
		property.program = this;
		property.uniformName = uniformName;
		uniformProperties.add(property);
		return property;
	}

	public static class UniformBool extends UniformProperty {
		public void set(boolean bool) {
			assert program.isActive();
			glUniform1i(uniformIndex, bool ? 1 : 0);
		}
	}

	public UniformBool addUniformBool(String uniformName) {
		return addUniform(new UniformBool(), uniformName);
	}

	public static class UniformTexture extends UniformProperty {
		public void set(int textureUnit) {
			assert textureUnit >= GL_TEXTURE0 : "Did you accidentally pass in an image unit?";
			assert program.isActive();
			glUniform1i(uniformIndex, textureUnit - GL_TEXTURE0);
		}
	}

	public UniformTexture addUniformTexture(String uniformName) {
		return addUniform(new UniformTexture(), uniformName);
	}

	public static class UniformImage extends UniformProperty {
		public void set(int imageUnit) {
			assert imageUnit < GL_TEXTURE0 : "Did you accidentally pass in a texture unit?";
			assert program.isActive();
			glUniform1i(uniformIndex, imageUnit);
		}
	}

	public UniformImage addUniformImage(String uniformName) {
		return addUniform(new UniformImage(), uniformName);
	}

	public static class Uniform1i extends UniformProperty {
		public void set(int value) {
			assert program.isActive();
			glUniform1i(uniformIndex, value);
		}
	}

	public Uniform1i addUniform1i(String uniformName) {
		return addUniform(new Uniform1i(), uniformName);
	}

	public static class Uniform2i extends UniformProperty {
		public void set(int x, int y) {
			assert program.isActive();
			glUniform2i(uniformIndex, x, y);
		}

		public void set(int... ivec2) {
			assert program.isActive();
			glUniform2iv(uniformIndex, ivec2);
		}
	}

	public Uniform2i addUniform2i(String uniformName) {
		return addUniform(new Uniform2i(), uniformName);
	}

	public static class Uniform3i extends UniformProperty {
		public void set(int x, int y, int z) {
			assert program.isActive();
			glUniform3i(uniformIndex, x, y, z);
		}

		public void set(int... ivec3) {
			assert program.isActive();
			glUniform3iv(uniformIndex, ivec3);
		}
	}

	public Uniform3i addUniform3i(String uniformName) {
		return addUniform(new Uniform3i(), uniformName);
	}

	public static class Uniform4i extends UniformProperty {
		public void set(int x, int y, int z, int w) {
			assert program.isActive();
			glUniform4i(uniformIndex, x, y, z, w);
		}

		public void set(int... ivec4) {
			assert program.isActive();
			glUniform4iv(uniformIndex, ivec4);
		}
	}

	public Uniform4i addUniform4i(String uniformName) {
		return addUniform(new Uniform4i(), uniformName);
	}

	public static class Uniform1f extends UniformProperty {
		public void set(float value) {
			assert program.isActive();
			glUniform1f(uniformIndex, value);
		}
	}

	public Uniform1f addUniform1f(String uniformName) {
		return addUniform(new Uniform1f(), uniformName);
	}

	public static class Uniform2f extends UniformProperty {
		public void set(float x, float y) {
			assert program.isActive();
			glUniform2f(uniformIndex, x, y);
		}

		public void set(float... vec2) {
			assert program.isActive();
			glUniform2fv(uniformIndex, vec2);
		}
	}

	public Uniform2f addUniform2f(String uniformName) {
		return addUniform(new Uniform2f(), uniformName);
	}

	public static class Uniform3f extends UniformProperty {
		public void set(float x, float y, float z) {
			assert program.isActive();
			glUniform3f(uniformIndex, x, y, z);
		}

		public void set(float... vec3) {
			assert program.isActive();
			glUniform3fv(uniformIndex, vec3);
		}
	}

	public Uniform3f addUniform3f(String uniformName) {
		return addUniform(new Uniform3f(), uniformName);
	}

	public static class Uniform4f extends UniformProperty {
		public void set(float x, float y, float z, float w) {
			assert program.isActive();
			glUniform4f(uniformIndex, x, y, z, w);
		}

		public void set(float... vec4) {
			assert program.isActive();
			glUniform4fv(uniformIndex, vec4);
		}
	}

	public Uniform4f addUniform4f(String uniformName) {
		return addUniform(new Uniform4f(), uniformName);
	}

	public static class UniformMat4 extends UniformProperty {
		public void set(float[] mat4) {
			assert program.isActive();
			glUniformMatrix4fv(uniformIndex, false, mat4);
		}
	}

	public UniformMat4 addUniformMat4(String uniformName) {
		return addUniform(new UniformMat4(), uniformName);
	}
}

/*
 * Copyright (c) 2018, Adam <Adam@sigterm.info>
 * Copyright (c) 2020 Abex
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package rs117.hd.opengl.shader;

import java.io.IOException;
import java.nio.ByteBuffer;
import java.util.HashMap;
import java.util.Map;
import lombok.extern.slf4j.Slf4j;
import org.lwjgl.BufferUtils;
import org.lwjgl.opengl.*;

import static org.lwjgl.opengl.GL33C.*;
import static rs117.hd.opengl.shader.ShaderIncludes.SHADER_DUMP_PATH;

@Slf4j
public class ShaderTemplate
{
	private final Map<Integer, String> shaderTypePaths = new HashMap<>();

	public ShaderTemplate add(int type, String name) {
		shaderTypePaths.put(type, name);
		return this;
	}

	public ShaderTemplate remove(int type) {
		shaderTypePaths.remove(type);
		return this;
	}

	public int compile(ShaderIncludes includes) throws ShaderException, IOException {
		int program = glCreateProgram();
		int[] shaders = new int[shaderTypePaths.size()];
		int i = 0;
		boolean ok = false;

		try
		{
			for (var entry : shaderTypePaths.entrySet()) {
				int shader = glCreateShader(entry.getKey());
				if (shader == 0)
					throw new ShaderException("Unable to create shader of type " + entry.getKey());

				String source = includes.loadFile(entry.getValue());
				glShaderSource(shader, source);
				glCompileShader(shader);

				if (glGetShaderi(shader, GL_COMPILE_STATUS) != GL_TRUE) {
					String error = glGetShaderInfoLog(shader);
					glDeleteShader(shader);
					throw ShaderException.compileError(includes, source, error, entry.getValue());
				}

				glAttachShader(program, shader);
				shaders[i++] = shader;
			}

			glLinkProgram(program);

			String[] paths = shaderTypePaths.values().toArray(String[]::new);
			String combinedName = String.join(" + ", paths);
			if (glGetProgrami(program, GL_LINK_STATUS) == GL_FALSE) {
				throw ShaderException.compileError(
					includes,
					"// Linking " + combinedName,
					glGetProgramInfoLog(program),
					paths
				);
			}

			ok = true;

			if (SHADER_DUMP_PATH != null) {
				int[] numFormats = { 0 };
				glGetIntegerv(GL41C.GL_NUM_PROGRAM_BINARY_FORMATS, numFormats);
				if (numFormats[0] < 1) {
					log.error("OpenGL driver does not support any binary formats");
				} else {
					int[] size = { 0 };
					glGetProgramiv(program, GL41C.GL_PROGRAM_BINARY_LENGTH, size);

					int[] format = { 0 };
					ByteBuffer binary = BufferUtils.createByteBuffer(size[0]);
					GL41C.glGetProgramBinary(program, size, format, binary);

					SHADER_DUMP_PATH.resolve("binaries", combinedName + ".bin").mkdirs().writeByteBuffer(binary);
				}
			}
		} finally {
			while (i > 0) {
				int shader = shaders[--i];
				glDetachShader(program, shader);
				glDeleteShader(shader);
			}

			if (!ok)
				glDeleteProgram(program);
		}

		return program;
	}
}

package rs117.hd.opengl.shader;

import java.io.IOException;
import rs117.hd.config.ShadowMode;

import static org.lwjgl.opengl.GL33C.*;
import static rs117.hd.HdPlugin.TEXTURE_UNIT_GAME;

public class ShadowShaderProgram extends ShaderProgram {
	private ShadowMode mode;
	private final UniformTexture uniShadowMap = addUniformTexture("textureArray");

	public ShadowShaderProgram() {
		super(t -> t
			.add(GL_VERTEX_SHADER, "shadow_vert.glsl")
			.add(GL_FRAGMENT_SHADER, "shadow_frag.glsl"));
	}

	@Override
	protected void initialize() {
		uniShadowMap.set(TEXTURE_UNIT_GAME);
	}

	@Override
	public void compile(ShaderIncludes includes) throws ShaderException, IOException {
		super.compile(includes.copy().define("SHADOW_MODE", mode));
	}

	public void setMode(ShadowMode mode) {
		this.mode = mode;
		if (mode == ShadowMode.DETAILED) {
			shaderTemplate.add(GL_GEOMETRY_SHADER, "shadow_geom.glsl");
		} else {
			shaderTemplate.remove(GL_GEOMETRY_SHADER);
		}
	}

	public static class Fast extends ShadowShaderProgram {
		public Fast() {
			super();
			setMode(ShadowMode.FAST);
		}
	}

	public static class Detailed extends ShadowShaderProgram {
		public Detailed() {
			super();
			setMode(ShadowMode.DETAILED);
		}
	}
}

package rs117.hd.opengl.shader;

import static org.lwjgl.opengl.GL33C.*;
import static rs117.hd.HdPlugin.IMAGE_UNIT_TILED_LIGHTING;
import static rs117.hd.HdPlugin.TEXTURE_UNIT_TILED_LIGHTING_MAP;

public class TiledLightingShaderProgram extends ShaderProgram {
	private final UniformTexture uniTiledLightingTextureArray = addUniformTexture("tiledLightingArray");
	private final UniformImage uniTiledLightingTextureStore = addUniformImage("tiledLightingImage");

	public TiledLightingShaderProgram() {
		super(t -> t
			.add(GL_VERTEX_SHADER, "tiled_lighting_vert.glsl")
			.add(GL_FRAGMENT_SHADER, "tiled_lighting_frag.glsl"));
		uniTiledLightingTextureArray.ignoreMissing = true;
		uniTiledLightingTextureStore.ignoreMissing = true;
	}

	@Override
	protected void initialize() {
		uniTiledLightingTextureArray.set(TEXTURE_UNIT_TILED_LIGHTING_MAP);
		uniTiledLightingTextureStore.set(IMAGE_UNIT_TILED_LIGHTING);
	}
}

package rs117.hd.opengl.shader;

import static org.lwjgl.opengl.GL33C.*;
import static rs117.hd.HdPlugin.TEXTURE_UNIT_UI;

public class UIShaderProgram extends ShaderProgram {
	private final UniformTexture uniUiTexture = addUniformTexture("uiTexture");

	public UIShaderProgram() {
		super(t -> t
			.add(GL_VERTEX_SHADER, "ui_vert.glsl")
			.add(GL_FRAGMENT_SHADER, "ui_frag.glsl"));
	}

	@Override
	protected void initialize() {
		uniUiTexture.set(TEXTURE_UNIT_UI);
	}
}

package rs117.hd.opengl.uniforms;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import rs117.hd.utils.buffer.SharedGLBuffer;

import static org.lwjgl.opencl.CL10.*;
import static org.lwjgl.opengl.GL33C.*;
import static rs117.hd.utils.MathUtils.*;

public class UBOCompute extends UniformBuffer<SharedGLBuffer> {
	public static final int MAX_CHARACTER_POSITION_COUNT = 50;

	private static final Comparator<CharacterPositionPair> CHARACTER_POSITION_PAIR_COMPARATOR =
		Comparator.comparingDouble(p -> p.dist);

	// Camera uniforms
	public Property yaw = addProperty(PropertyType.Float, "yaw");
	public Property pitch = addProperty(PropertyType.Float, "pitch");
	public Property centerX = addProperty(PropertyType.Int, "centerX");
	public Property centerY = addProperty(PropertyType.Int, "centerY");
	public Property zoom = addProperty(PropertyType.Int, "zoom");
	public Property cameraX = addProperty(PropertyType.Float, "cameraX");
	public Property cameraY = addProperty(PropertyType.Float, "cameraY");
	public Property cameraZ = addProperty(PropertyType.Float, "cameraZ");

	// Wind uniforms
	public Property windDirectionX = addProperty(PropertyType.Float, "windDirectionX");
	public Property windDirectionZ = addProperty(PropertyType.Float, "windDirectionZ");
	public Property windStrength = addProperty(PropertyType.Float, "windStrength");
	public Property windCeiling = addProperty(PropertyType.Float, "windCeiling");
	public Property windOffset = addProperty(PropertyType.Float, "windOffset");

	private final Property characterPositionCount = addProperty(PropertyType.Int, "characterPositionCount");
	private final Property[] characterPositions = addPropertyArray(PropertyType.FVec3, "characterPositions", MAX_CHARACTER_POSITION_COUNT);

	private final ArrayList<CharacterPositionPair> characterPositionsPairs = new ArrayList<>(characterPositions.length);
	private int writtenCharacterPositions;
	private float playerPosX, playerPosZ;

	private static class CharacterPositionPair {
		public float x;
		public float z;
		public float radius;
		public float dist = Float.MAX_VALUE;
	}

	public UBOCompute() {
		super(GL_DYNAMIC_DRAW, CL_MEM_READ_ONLY);
	}

	private CharacterPositionPair getCharacterPositionPair() {
		if (writtenCharacterPositions >= characterPositionsPairs.size()) {
			CharacterPositionPair newPair = new CharacterPositionPair();
			characterPositionsPairs.add(newPair);
			return newPair;
		}

		return characterPositionsPairs.get(writtenCharacterPositions);
	}

	public void addCharacterPosition(int localX, int localZ, int modelRadius) {
		int writeIndex = writtenCharacterPositions;
		CharacterPositionPair pair = getCharacterPositionPair();
		characterPositionsPairs.remove(writeIndex);

		pair.x = localX;
		pair.z = localZ;
		pair.radius = modelRadius * 1.25f;

		if (writeIndex == 0) {
			playerPosX = pair.x;
			playerPosZ = pair.z;
			pair.dist = 0.0f;
		} else {
			pair.dist = abs(playerPosX - pair.x) + abs(playerPosZ - pair.z);

			if (writeIndex > 1) {
				int index = Collections.binarySearch(
					characterPositionsPairs.subList(1, writeIndex),
					pair,
					CHARACTER_POSITION_PAIR_COMPARATOR
				);

				writeIndex = index >= 0 ? index : -index - 1;
			}
		}

		characterPositionsPairs.add(writeIndex, pair);
		writtenCharacterPositions++;
	}

	@Override
	protected void preUpload() {
		for (int i = 0; i < writtenCharacterPositions; i++) {
			CharacterPositionPair pair = characterPositionsPairs.get(i);
			pair.dist = Float.MAX_VALUE;

			if (i < characterPositions.length)
				characterPositions[i].set(pair.x, pair.z, pair.radius);
		}
		characterPositionCount.set(min(writtenCharacterPositions, characterPositions.length));
		writtenCharacterPositions = 0;
	}
}

package rs117.hd.opengl.uniforms;

import rs117.hd.utils.buffer.GLBuffer;

import static org.lwjgl.opengl.GL33C.*;

public class UBOGlobal extends UniformBuffer<GLBuffer> {
	public UBOGlobal() {
		super(GL_DYNAMIC_DRAW);
	}

	@Override
	public void initialize() {
		super.initialize();
	}

	public Property expandedMapLoadingChunks = addProperty(PropertyType.Int, "expandedMapLoadingChunks");
	public Property drawDistance = addProperty(PropertyType.Float, "drawDistance");

	public Property colorBlindnessIntensity = addProperty(PropertyType.Float, "colorBlindnessIntensity");
	public Property gammaCorrection = addProperty(PropertyType.Float, "gammaCorrection");
	public Property saturation = addProperty(PropertyType.Float, "saturation");
	public Property contrast = addProperty(PropertyType.Float, "contrast");
	public Property colorFilterPrevious = addProperty(PropertyType.Int, "colorFilterPrevious");
	public Property colorFilter = addProperty(PropertyType.Int, "colorFilter");
	public Property colorFilterFade = addProperty(PropertyType.Float, "colorFilterFade");

	public Property sceneResolution = addProperty(PropertyType.IVec2, "sceneResolution");
	public Property tiledLightingResolution = addProperty(PropertyType.IVec2, "tiledLightingResolution");

	public Property ambientColor = addProperty(PropertyType.FVec3, "ambientColor");
	public Property ambientStrength = addProperty(PropertyType.Float, "ambientStrength");
	public Property lightColor = addProperty(PropertyType.FVec3, "lightColor");
	public Property lightStrength = addProperty(PropertyType.Float, "lightStrength");
	public Property underglowColor = addProperty(PropertyType.FVec3, "underglowColor");
	public Property underglowStrength = addProperty(PropertyType.Float, "underglowStrength");

	public Property useFog = addProperty(PropertyType.Int, "useFog");
	public Property fogDepth = addProperty(PropertyType.Float, "fogDepth");
	public Property fogColor = addProperty(PropertyType.FVec3, "fogColor");
	public Property groundFogStart = addProperty(PropertyType.Float, "groundFogStart");
	public Property groundFogEnd = addProperty(PropertyType.Float, "groundFogEnd");
	public Property groundFogOpacity = addProperty(PropertyType.Float, "groundFogOpacity");

	public Property waterColorLight = addProperty(PropertyType.FVec3, "waterColorLight");
	public Property waterColorMid = addProperty(PropertyType.FVec3, "waterColorMid");
	public Property waterColorDark = addProperty(PropertyType.FVec3, "waterColorDark");

	public Property underwaterEnvironment = addProperty(PropertyType.Int, "underwaterEnvironment");
	public Property underwaterCaustics = addProperty(PropertyType.Int, "underwaterCaustics");
	public Property underwaterCausticsColor = addProperty(PropertyType.FVec3, "underwaterCausticsColor");
	public Property underwaterCausticsStrength = addProperty(PropertyType.Float, "underwaterCausticsStrength");

	public Property lightDir = addProperty(PropertyType.FVec3, "lightDir");

	public Property pointLightsCount = addProperty(PropertyType.Int, "pointLightsCount");

	public Property cameraPos = addProperty(PropertyType.FVec3, "cameraPos");
	public Property viewMatrix = addProperty(PropertyType.Mat4, "viewMatrix");
	public Property projectionMatrix = addProperty(PropertyType.Mat4, "projectionMatrix");
	public Property invProjectionMatrix = addProperty(PropertyType.Mat4, "invProjectionMatrix");
	public Property lightProjectionMatrix = addProperty(PropertyType.Mat4, "lightProjectionMatrix");

	public Property lightningBrightness = addProperty(PropertyType.Float, "lightningBrightness");
	public Property elapsedTime = addProperty(PropertyType.Float, "elapsedTime");
}

package rs117.hd.opengl.uniforms;

import rs117.hd.utils.buffer.GLBuffer;

import static org.lwjgl.opengl.GL33C.*;

public class UBOLights extends UniformBuffer<GLBuffer> {

	public static final int MAX_LIGHTS = 1000; // Struct is 64 Bytes, UBO Max size is 64 KB
	private final LightStruct[] lights;
	private final Property[] lightPositions;

	public UBOLights(boolean isCullingUBO) {
		super(GL_DYNAMIC_DRAW);
		lightPositions = isCullingUBO ? addPropertyArray(PropertyType.FVec4, "lightPositions", MAX_LIGHTS) : null;
		lights = !isCullingUBO ? addStructs(new LightStruct[MAX_LIGHTS], LightStruct::new) : null;
	}

	@Override
	public String getUniformBlockName() {
		return lights != null ? "UBOLights" : "UBOLightsCulling";
	}

	public void setLight(int lightIdx, float[] position, float[] color) {
		if (lightIdx >= 0 && lightIdx < MAX_LIGHTS) {
			if (lights != null) {
				var struct = lights[lightIdx];
				struct.position.set(position);
				struct.color.set(color);
			} else {
				lightPositions[lightIdx].set(position);
			}
		}
	}

	public static class LightStruct extends UniformBuffer.StructProperty {
		public Property position = addProperty(PropertyType.FVec4, "position");
		public Property color = addProperty(PropertyType.FVec4, "color");
	}
}

package rs117.hd.opengl.uniforms;

import lombok.extern.slf4j.Slf4j;
import net.runelite.api.*;
import rs117.hd.HdPlugin;
import rs117.hd.scene.materials.Material;
import rs117.hd.utils.buffer.GLBuffer;

import static org.lwjgl.opengl.GL33C.*;
import static rs117.hd.utils.MathUtils.*;

@Slf4j
public class UBOMaterials extends UniformBuffer<GLBuffer> {
	public static class MaterialStruct extends StructProperty {
		public Property colorMap = addProperty(PropertyType.Int, "colorMap");
		public Property normalMap = addProperty(PropertyType.Int, "normalMap");
		public Property displacementMap = addProperty(PropertyType.Int, "displacementMap");
		public Property roughnessMap = addProperty(PropertyType.Int, "roughnessMap");
		public Property ambientOcclusionMap = addProperty(PropertyType.Int, "ambientOcclusionMap");
		public Property flowMap = addProperty(PropertyType.Int, "flowMap");
		public Property flags = addProperty(PropertyType.Int, "flags");
		public Property brightness = addProperty(PropertyType.Float, "brightness");
		public Property displacementScale = addProperty(PropertyType.Float, "displacementScale");
		public Property specularStrength = addProperty(PropertyType.Float, "specularStrength");
		public Property specularGloss = addProperty(PropertyType.Float, "specularGloss");
		public Property flowMapStrength = addProperty(PropertyType.Float, "flowMapStrength");
		public Property flowMapDuration = addProperty(PropertyType.FVec2, "flowMapDuration");
		public Property scrollDuration = addProperty(PropertyType.FVec2, "scrollDuration");
		public Property textureScale = addProperty(PropertyType.FVec3, "textureScale");
	}

	public MaterialStruct[] uboStructs;
	public Material[] materials;

	public UBOMaterials(int materialCount) {
		super(GL_STATIC_DRAW);
		assert materialCount - 1 <= Material.MAX_MATERIAL_INDEX :
			"Too many materials (" + materialCount + ") to fit into packed material data.";
		uboStructs = addStructs(new MaterialStruct[materialCount], MaterialStruct::new);
		initialize(HdPlugin.UNIFORM_BLOCK_MATERIALS);
	}

	public void update(Material[] materials, Texture[] vanillaTextures) {
		this.materials = materials;

		for (int i = 0; i < materials.length; i++) {
			var mat = materials[i];
			mat.uboIndex = i;
			float vanillaScrollX = 0;
			float vanillaScrollY = 0;
			// Replacement materials will only apply vanilla scrolling if they also specify a vanillaTextureIndex
			if (mat.vanillaTextureIndex != -1) {
				var texture = vanillaTextures[mat.vanillaTextureIndex];
				if (texture != null) {
					int direction = texture.getAnimationDirection();
					if (direction != 0) {
						// Convert vanilla texture animations to the same format as Material scroll parameters
						float speed = texture.getAnimationSpeed() * 50 / 128.f;
						float radians = direction * -HALF_PI;
						vanillaScrollX = cos(radians) * speed;
						vanillaScrollY = sin(radians) * speed;
					}
				}
			}
			mat.fillMaterialStruct(uboStructs[i], vanillaScrollX, vanillaScrollY);
		}

		upload();
	}
}

package rs117.hd.opengl.uniforms;

import rs117.hd.utils.buffer.GLBuffer;

import static org.lwjgl.opengl.GL33C.*;

public class UBOUI extends UniformBuffer<GLBuffer> {
	public UBOUI() {
		super(GL_DYNAMIC_DRAW);
	}

	public Property sourceDimensions = addProperty(PropertyType.IVec2, "sourceDimensions");
	public Property targetDimensions = addProperty(PropertyType.IVec2, "targetDimensions");
	public Property alphaOverlay = addProperty(PropertyType.FVec4, "alphaOverlay");
}

package rs117.hd.opengl.uniforms;

import rs117.hd.HdPlugin;
import rs117.hd.scene.water_types.WaterType;
import rs117.hd.utils.buffer.GLBuffer;

import static org.lwjgl.opengl.GL33C.*;

public class UBOWaterTypes extends UniformBuffer<GLBuffer> {
	public static class WaterTypeStruct extends StructProperty {
		public final Property isFlat = addProperty(PropertyType.Int, "isFlat");
		public final Property specularStrength = addProperty(PropertyType.Float, "specularStrength");
		public final Property specularGloss = addProperty(PropertyType.Float, "specularGloss");
		public final Property normalStrength = addProperty(PropertyType.Float, "normalStrength");
		public final Property baseOpacity = addProperty(PropertyType.Float, "baseOpacity");
		public final Property hasFoam = addProperty(PropertyType.Int, "hasFoam");
		public final Property duration = addProperty(PropertyType.Float, "duration");
		public final Property fresnelAmount = addProperty(PropertyType.Float, "fresnelAmount");
		public final Property surfaceColor = addProperty(PropertyType.FVec3, "surfaceColor");
		public final Property foamColor = addProperty(PropertyType.FVec3, "foamColor");
		public final Property depthColor = addProperty(PropertyType.FVec3, "depthColor");
		public final Property normalMap = addProperty(PropertyType.Int, "normalMap");
	}

	private final WaterTypeStruct[] uboStructs;
	private final WaterType[] waterTypes;

	public UBOWaterTypes(WaterType[] waterTypes) {
		super(GL_STATIC_DRAW);
		this.waterTypes = waterTypes;
		uboStructs = addStructs(new WaterTypeStruct[waterTypes.length], WaterTypeStruct::new);
		initialize(HdPlugin.UNIFORM_BLOCK_WATER_TYPES);
		update();
	}

	public int getCount() {
		return uboStructs.length;
	}

	public void update() {
		for (int i = 0; i < waterTypes.length; i++)
			waterTypes[i].fillStruct(uboStructs[i]);
		upload();
	}
}

package rs117.hd.opengl.uniforms;

import java.util.ArrayDeque;
import java.util.Arrays;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.*;
import rs117.hd.utils.Mat4;
import rs117.hd.utils.buffer.GLBuffer;

import static org.lwjgl.opengl.GL33C.*;
import static rs117.hd.utils.MathUtils.*;

@Slf4j
public class UBOWorldViews extends UniformBuffer<GLBuffer> {
	// The max concurrent visible worldviews is 25
	// Source: https://discord.com/channels/886733267284398130/1419633364817674351/1429129853592146041
	public static final int MAX_SIMULTANEOUS_WORLD_VIEWS = 128;
	private static final float[] IDENTITY_MATRIX = Mat4.identity();

	@RequiredArgsConstructor
	public class WorldViewStruct extends StructProperty {
		public final int worldViewIdx;

		public final Property projection = addProperty(PropertyType.Mat4, "projection");
		public final Property tint = addProperty(PropertyType.IVec4, "tint");

		public WorldView worldView;

		private final float[] currentProjection = new float[16];
		private final int[] currentTint = new int[4];
		private final int[] newTint = new int[4];

		public void update() {
			float[] newProjection = IDENTITY_MATRIX;
			final Projection worldViewProjection = worldView.getMainWorldProjection();
			if (worldViewProjection instanceof FloatProjection)
				newProjection = ((FloatProjection) worldViewProjection).getProjection();

			if (!Arrays.equals(currentProjection, newProjection)) {
				projection.set(newProjection);
				copyTo(currentProjection, newProjection);
			}

			newTint[3] = 0;
			Scene scene = worldView.getScene();
			if (scene != null) {
				newTint[0] = scene.getOverrideHue();
				newTint[1] = scene.getOverrideSaturation();
				newTint[2] = scene.getOverrideLuminance();
				newTint[3] = scene.getOverrideAmount();
			}
			if (!Arrays.equals(currentTint, newTint)) {
				tint.set(newTint);
				copyTo(currentTint, newTint);
			}
		}

		public synchronized void free() {
			freeIndices.add(worldViewIdx);
			worldView = null;
		}
	}

	private final WorldViewStruct[] uboStructs = new WorldViewStruct[MAX_SIMULTANEOUS_WORLD_VIEWS];
	private final ArrayDeque<Integer> freeIndices = new ArrayDeque<>();

	public UBOWorldViews() {
		super(GL_DYNAMIC_DRAW);
		for (int i = 0; i < MAX_SIMULTANEOUS_WORLD_VIEWS; i++) {
			uboStructs[i] = addStruct(new WorldViewStruct(i));
			freeIndices.add(i);
		}
	}

	public synchronized WorldViewStruct acquire(WorldView worldView) {
		if (freeIndices.isEmpty()) {
			log.warn("Too many world views at once: {}", MAX_SIMULTANEOUS_WORLD_VIEWS);
			return null;
		}

		WorldViewStruct struct = uboStructs[freeIndices.poll()];
		struct.worldView = worldView;
		struct.update();
		return struct;
	}
}

package rs117.hd.opengl.uniforms;

import java.nio.ByteBuffer;
import java.nio.FloatBuffer;
import java.nio.IntBuffer;
import java.util.ArrayList;
import java.util.List;
import javax.annotation.Nullable;
import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.lwjgl.BufferUtils;
import rs117.hd.utils.RenderState;
import rs117.hd.utils.buffer.GLBuffer;
import rs117.hd.utils.buffer.SharedGLBuffer;

import static org.lwjgl.opengl.GL33C.*;
import static rs117.hd.utils.MathUtils.*;

@Slf4j
public abstract class UniformBuffer<GLBUFFER extends GLBuffer> {
	@RequiredArgsConstructor
	protected enum PropertyType {
		Int(4, 4, 1),
		IVec2(8, 8, 2),
		IVec3(12, 16, 3),
		IVec4(16, 16, 4),

		Float(4, 4, 1),
		FVec2(8, 8, 2),
		FVec3(12, 16, 3),
		FVec4(16, 16, 4),

		Mat3(48, 16, 9),
		Mat4(64, 16, 16);

		private final int size;
		private final int alignment;
		private final int elementCount;
		private final boolean isInt = name().startsWith("I");
	}

	@AllArgsConstructor
	@RequiredArgsConstructor
	public static class Property {
		private UniformBuffer<?> owner;
		private int position;
		private int offset = -1;
		private final PropertyType type;
		private final String name;

		private void log(String message) {
			log.warn("{}.{} - {}", owner.glBuffer.name, name, message);
		}

		private boolean isUninitialized() {
			if (offset >= 0)
				return false;
			log("Hasn't been initialized yet!");
			return true;
		}

		public final void set(int... values) {
			if (isUninitialized())
				return;

			if (!type.isInt) {
				log("Int setter was used with a non-int property type");
				return;
			}

			if (values == null) {
				log("Int setter was provided with null value");
				return;
			}

			if (values.length != type.elementCount) {
				log(String.format("Int setter was provided with incorrect number of elements: %d != %d", values.length, type.elementCount));
				return;
			}

			owner.dataInt.position(offset).put(values);
			owner.markWaterLine(position, type.size);
		}

		public final void set(int x) {
			if (isUninitialized())
				return;

			if (type != PropertyType.Int) {
				log("Int setter was used with the wrong property type: " + type);
				return;
			}

			owner.dataInt.position(offset).put(x);
			owner.markWaterLine(position, type.size);
		}

		public final void set(int x, int y) {
			if (isUninitialized())
				return;

			if (type != PropertyType.IVec2) {
				log("Int setter was used with the wrong property type: " + type);
				return;
			}

			owner.dataInt.position(offset).put(x).put(y);
			owner.markWaterLine(position, type.size);
		}

		public final void set(int x, int y, int z) {
			if (isUninitialized())
				return;

			if (type != PropertyType.IVec3) {
				log("Int setter was used with the wrong property type: " + type);
				return;
			}

			owner.dataInt.position(offset).put(x).put(y).put(z);
			owner.markWaterLine(position, type.size);
		}

		public final void set(int x, int y, int z, int w) {
			if (isUninitialized())
				return;

			if (type != PropertyType.IVec4) {
				log("Int setter was used with the wrong property type: " + type);
				return;
			}

			owner.dataInt.position(offset).put(x).put(y).put(z).put(w);
			owner.markWaterLine(position, type.size);
		}

		public final void set(float... values) {
			if (isUninitialized())
				return;

			if (type.isInt) {
				log("Float setter was used with an int property type");
				return;
			}

			if (values == null) {
				log("Float setter was provided with null value");
				return;
			}

			if (values.length != type.elementCount) {
				log(String.format(
					"Float setter was provided with incorrect number of elements: %d != %d",
					values.length,
					type.elementCount
				));
				return;
			}

			owner.dataFloat.position(offset);
			if (type == PropertyType.Mat3) {
				// Pad each column to a vec4
				for (int i = 0; i < 3; i++)
					owner.dataFloat.put(values, i * 3, 3).put(0);
			} else {
				owner.dataFloat.put(values);
			}
			owner.markWaterLine(position, type.size);
		}

		public final void set(float x) {
			if (isUninitialized())
				return;

			if (type != PropertyType.Float) {
				log("Float setter was used with the wrong property type: " + type);
				return;
			}

			owner.dataFloat.position(offset).put(x);
			owner.markWaterLine(position, type.size);
		}

		public final void set(float x, float y) {
			if (isUninitialized())
				return;

			if (type != PropertyType.FVec2) {
				log("Float setter was used with the wrong property type: " + type);
				return;
			}

			owner.dataFloat.position(offset).put(x).put(y);
			owner.markWaterLine(position, type.size);
		}

		public final void set(float x, float y, float z) {
			if (isUninitialized())
				return;

			if (type != PropertyType.FVec3) {
				log("Float setter was used with the wrong property type: " + type);
				return;
			}

			owner.dataFloat.position(offset).put(x).put(y).put(z);
			owner.markWaterLine(position, type.size);
		}

		public final void set(float x, float y, float z, float w) {
			if (isUninitialized())
				return;

			if (type != PropertyType.FVec4) {
				log("Float setter was used with the wrong property type: " + type);
				return;
			}

			owner.dataFloat.position(offset).put(x).put(y).put(z).put(w);
			owner.markWaterLine(position, type.size);
		}
	}

	public interface CreateStructProperty<T extends StructProperty> {
		T create();
	}

	public abstract static class StructProperty {
		protected List<Property> properties = new ArrayList<>();

		protected final Property addProperty(PropertyType type, String name) {
			Property property = new Property(type, name);
			properties.add(property);
			return property;
		}
	}

	public final GLBUFFER glBuffer;

	private int size;
	private int dirtyLowTide = Integer.MAX_VALUE;
	private int dirtyHighTide = 0;
	private ByteBuffer data;
	private IntBuffer dataInt;
	private FloatBuffer dataFloat;
	private final List<Property> properties = new ArrayList<>();

	@Getter
	private int bindingIndex;

	@SuppressWarnings("unchecked")
	public UniformBuffer(int glUsage) {
		glBuffer = (GLBUFFER) new GLBuffer(getClass().getSimpleName(), GL_UNIFORM_BUFFER, glUsage);
	}

	@SuppressWarnings("unchecked")
	public UniformBuffer(int glUsage, int clUsage) {
		glBuffer = (GLBUFFER) new SharedGLBuffer(getClass().getSimpleName(), GL_UNIFORM_BUFFER, glUsage, clUsage);
	}

	public boolean isDirty() {
		return dirtyHighTide > 0 && dirtyLowTide < glBuffer.size;
	}

	protected final <T extends StructProperty> T addStruct(T newStructProp) {
		for (Property property : newStructProp.properties)
			appendToBuffer(property);

		// Structs need to align to 16 bytes
		size += (16 - (size % 16)) % 16;

		newStructProp.properties.clear();
		return newStructProp;
	}

	protected final <T extends StructProperty> T[] addStructs(T[] newStructPropArray, CreateStructProperty<T> createFunction) {
		for (int i = 0; i < newStructPropArray.length; i++) {
			newStructPropArray[i] = createFunction.create();
			addStruct(newStructPropArray[i]);
		}

		return newStructPropArray;
	}

	protected Property addProperty(PropertyType type, String name) {
		return appendToBuffer(new Property(type, name));
	}

	protected Property[] addPropertyArray(PropertyType type, String name, int size) {
		Property[] result = new Property[size];
		for (int i = 0; i < size; i++)
			result[i] = addProperty(type, name);
		return result;
	}

	private Property appendToBuffer(Property property) {
		property.owner = this;

		int padding = (property.type.alignment - (size % property.type.alignment)) % property.type.alignment;
		property.position = size + padding;

		size += property.type.size + padding;
		properties.add(property);

		if (size > 65536)
			log.warn("Uniform buffer {} is too large! ({} bytes)", glBuffer.name, size);

		return property;
	}

	private void markWaterLine(int position, int size) {
		dirtyLowTide = min(dirtyLowTide, position);
		dirtyHighTide = max(dirtyHighTide, position + size);
	}

	public void initialize() {
		if (data != null)
			destroy();

		glBuffer.initialize(size);
		data = BufferUtils.createByteBuffer(size);
		dataInt = data.asIntBuffer();
		dataFloat = data.asFloatBuffer();

		// Since everything is aligned to a multiple of 4 bytes, we can easily define offsets into dataInt and dataFloat
		for (Property prop : properties)
			prop.offset = prop.position / 4;
	}

	public void initialize(int bindingIndex) {
		initialize();
		bind(bindingIndex);
	}

	public String getUniformBlockName() {
		return glBuffer.name;
	}

	public void bind(int bindingIndex) {
		this.bindingIndex = bindingIndex;
		glBindBufferBase(GL_UNIFORM_BUFFER, bindingIndex, glBuffer.id);
	}

	protected void preUpload() {}

	public final void upload() {
		upload(null);
	}

	public final void upload(@Nullable RenderState state) {
		if (data == null)
			return;

		preUpload();

		if (!isDirty())
			return;

		data.position(dirtyLowTide);
		data.limit(dirtyHighTide);

		if (state != null) {
			state.ubo.set(glBuffer.id);
			state.ubo.apply();
		} else {
			glBindBuffer(GL_UNIFORM_BUFFER, glBuffer.id);
		}
		glBufferSubData(GL_UNIFORM_BUFFER, dirtyLowTide, data);

		data.clear();

		dirtyLowTide = Integer.MAX_VALUE;
		dirtyHighTide = 0;
	}

	public final void destroy() {
		if (data == null)
			return;

		for (Property prop : properties)
			prop.offset = -1;

		glBuffer.destroy();
		data = null;
		dataInt = null;
		dataFloat = null;
	}
}

package rs117.hd.overlays;

import java.lang.management.GarbageCollectorMXBean;
import java.lang.management.ManagementFactory;
import java.util.ArrayDeque;
import java.util.Arrays;
import java.util.List;
import javax.inject.Inject;
import javax.inject.Singleton;
import lombok.Getter;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import net.runelite.client.callback.ClientThread;
import org.lwjgl.opengl.*;
import rs117.hd.HdPlugin;

import static org.lwjgl.opengl.GL33C.*;

@Slf4j
@Singleton
public class FrameTimer {
	@Inject
	private ClientThread clientThread;

	@Inject
	private HdPlugin plugin;

	private static final int NUM_TIMERS = Timer.TIMERS.length;
	private static final int NUM_GPU_TIMERS = (int) Arrays.stream(Timer.TIMERS).filter(t -> t.isGpuTimer).count();
	private static final int NUM_GPU_DEBUG_GROUPS = (int) Arrays.stream(Timer.TIMERS).filter(t -> t.gpuDebugGroup).count();

	private final AutoTimer[] autoTimers = new AutoTimer[NUM_TIMERS];
	private final boolean[] activeTimers = new boolean[NUM_TIMERS];
	private final long[] timings = new long[NUM_TIMERS];
	private final int[] gpuQueries = new int[NUM_TIMERS * 2];
	private final ArrayDeque<Timer> glDebugGroupStack = new ArrayDeque<>(NUM_GPU_DEBUG_GROUPS);
	private final ArrayDeque<Listener> listeners = new ArrayDeque<>();
	private long[] lastGCTimes;

	@RequiredArgsConstructor
	public class AutoTimer implements AutoCloseable {
		private final Timer timer;

		@Override
		public void close() {
			end(timer);
		}
	}

	@SuppressWarnings("resource")
	public FrameTimer() {
		for (int i = 0; i < NUM_TIMERS; i++)
			autoTimers[i] = new AutoTimer(Timer.TIMERS[i]);
	}

	@Getter
	private boolean isActive = false;

	public long cumulativeError;
	public long errorCompensation;

	private void initialize() {
		clientThread.invoke(() -> {
			int[] queryNames = new int[NUM_GPU_TIMERS * 2];
			glGenQueries(queryNames);
			int queryIndex = 0;
			for (var timer : Timer.TIMERS)
				if (timer.isGpuTimer)
					for (int j = 0; j < 2; ++j)
						gpuQueries[timer.ordinal() * 2 + j] = queryNames[queryIndex++];

			isActive = true;
			plugin.setupSyncMode();
			plugin.enableDetailedTimers = true;

			// Estimate the timer's own runtime, with a warm-up run first
			final int iterations = 100000;
			final int compensation = 1950000; // additional manual correction
			for (int i = 0; i < 2; i++) {
				errorCompensation = 0;
				for (int j = 0; j < iterations; j++) {
					begin(Timer.DRAW_FRAME);
					end(Timer.DRAW_FRAME);
				}
				errorCompensation = (timings[Timer.DRAW_FRAME.ordinal()] + compensation) / iterations;
				timings[Timer.DRAW_FRAME.ordinal()] = 0;
			}
			log.debug("Estimated the overhead of timers to be around {} ns", errorCompensation);
		});
	}

	private void destroy() {
		clientThread.invoke(() -> {
			if (!isActive)
				return;

			isActive = false;
			plugin.setupSyncMode();
			plugin.enableDetailedTimers = false;

			glDeleteQueries(gpuQueries);
			Arrays.fill(gpuQueries, 0);
			reset();
		});
	}

	@FunctionalInterface
	public interface Listener {
		void onFrameCompletion(FrameTimings timings);
	}

	public void addTimingsListener(Listener listener) {
		if (listeners.isEmpty())
			initialize();
		listeners.add(listener);
	}

	public void removeTimingsListener(Listener listener) {
		listeners.remove(listener);
		if (listeners.isEmpty())
			destroy();
	}

	public void removeAllListeners() {
		listeners.clear();
		destroy();
	}

	public void reset() {
		Arrays.fill(timings, 0);
		Arrays.fill(activeTimers, false);
		cumulativeError = 0;
	}

	public AutoTimer begin(Timer timer) {
		int index = timer.ordinal();
		if (log.isDebugEnabled() && timer.gpuDebugGroup && HdPlugin.GL_CAPS.OpenGL43) {
			if (glDebugGroupStack.contains(timer)) {
				log.warn("The debug group {} is already on the stack", timer.name());
			} else {
				glDebugGroupStack.push(timer);
				GL43C.glPushDebugGroup(GL43C.GL_DEBUG_SOURCE_APPLICATION, index, timer.name);
			}
		}

		if (!isActive)
			return null;

		if (timer.isGpuTimer) {
			if (activeTimers[index])
				throw new UnsupportedOperationException("Cumulative GPU timing isn't supported");
			glQueryCounter(gpuQueries[index * 2], GL_TIMESTAMP);
		} else if (!activeTimers[index]) {
			cumulativeError += errorCompensation + 1 >> 1;
			timings[index] -= System.nanoTime() - cumulativeError;
		}
		activeTimers[index] = true;

		return autoTimers[index];
	}

	public void end(Timer timer) {
		if (log.isDebugEnabled() && timer.gpuDebugGroup && HdPlugin.GL_CAPS.OpenGL43) {
			if (glDebugGroupStack.peek() != timer) {
				log.warn("The debug group {} was popped out of order", timer.name());
			} else {
				glDebugGroupStack.pop();
				GL43C.glPopDebugGroup();
			}
		}

		if (!isActive || !activeTimers[timer.ordinal()])
			return;

		if (timer.isGpuTimer) {
			glQueryCounter(gpuQueries[timer.ordinal() * 2 + 1], GL_TIMESTAMP);
			// leave the GPU timer active, since it needs to be gathered at a later point
		} else {
			cumulativeError += errorCompensation >> 1;
			timings[timer.ordinal()] += System.nanoTime() - cumulativeError;
			activeTimers[timer.ordinal()] = false;
		}
	}

	public void add(Timer timer, long nanos) {
		if (isActive)
			timings[timer.ordinal()] += nanos;
	}

	public void endFrameAndReset() {
		if (HdPlugin.GL_CAPS.OpenGL43) {
			while (!glDebugGroupStack.isEmpty()) {
				log.warn("The debug group {} was never popped", glDebugGroupStack.pop().name());
				GL43C.glPopDebugGroup();
			}
		}

		if (!isActive)
			return;

		long frameEndNanos = System.nanoTime();
		long frameEndTimestamp = System.currentTimeMillis();

		trackGarbageCollection();

		int[] available = { 0 };
		for (var timer : Timer.TIMERS) {
			int i = timer.ordinal();
			if (timer.isGpuTimer) {
				if (!activeTimers[i])
					continue;

				for (int j = 0; j < 2; j++) {
					while (available[0] == 0)
						glGetQueryObjectiv(gpuQueries[i * 2 + j], GL_QUERY_RESULT_AVAILABLE, available);
					timings[i] += (j * 2L - 1) * glGetQueryObjectui64(gpuQueries[i * 2 + j], GL_QUERY_RESULT);
				}
			} else {
				if (activeTimers[i]) {
					// End the CPU timer automatically, but warn about it
					log.warn("Timer {} was never ended", timer);
					timings[i] += frameEndNanos;
				}
			}
		}

		var frameTimings = new FrameTimings(frameEndTimestamp, timings);
		for (var listener : listeners)
			listener.onFrameCompletion(frameTimings);

		reset();
	}

	private void trackGarbageCollection() {
		List<GarbageCollectorMXBean> garbageCollectors = ManagementFactory.getGarbageCollectorMXBeans();
		if (lastGCTimes == null || lastGCTimes.length != garbageCollectors.size())
			lastGCTimes = new long[garbageCollectors.size()];

		plugin.garbageCollectionCount = 0;
		long elapsedDuration = 0;
		for (int i = 0; i < garbageCollectors.size(); i++) {
			var gc = garbageCollectors.get(i);
			long time = gc.getCollectionTime();
			if (time > 0 && time != lastGCTimes[i]) {
				long duration = time - lastGCTimes[i];
				lastGCTimes[i] = time;
				elapsedDuration += duration;
			}
			plugin.garbageCollectionCount += gc.getCollectionCount();
		}

		add(Timer.GARBAGE_COLLECTION, elapsedDuration * 1_000_000L);
	}
}

package rs117.hd.overlays;

import com.google.inject.Inject;
import com.google.inject.Singleton;
import java.awt.Dimension;
import java.awt.Graphics2D;
import java.util.ArrayDeque;
import java.util.Arrays;
import java.util.HashMap;
import java.util.Map;
import net.runelite.client.ui.FontManager;
import net.runelite.client.ui.overlay.OverlayLayer;
import net.runelite.client.ui.overlay.OverlayManager;
import net.runelite.client.ui.overlay.OverlayPanel;
import net.runelite.client.ui.overlay.OverlayPosition;
import net.runelite.client.ui.overlay.components.LineComponent;
import net.runelite.client.ui.overlay.components.TitleComponent;
import rs117.hd.HdPlugin;
import rs117.hd.renderer.zone.SceneManager;
import rs117.hd.renderer.zone.WorldViewContext;
import rs117.hd.utils.FrameTimingsRecorder;
import rs117.hd.utils.NpcDisplacementCache;
import rs117.hd.utils.jobs.JobSystem;

import static rs117.hd.renderer.zone.SceneManager.MAX_WORLDVIEWS;
import static rs117.hd.utils.MathUtils.*;

@Singleton
public class FrameTimerOverlay extends OverlayPanel implements FrameTimer.Listener {
	@Inject
	private OverlayManager overlayManager;

	@Inject
	private HdPlugin plugin;

	@Inject
	private FrameTimer frameTimer;

	@Inject
	private FrameTimingsRecorder frameTimingsRecorder;

	@Inject
	private NpcDisplacementCache npcDisplacementCache;

	@Inject
	private JobSystem jobSystem;

	@Inject
	private SceneManager sceneManager;

	private final ArrayDeque<FrameTimings> frames = new ArrayDeque<>();
	private final long[] timings = new long[Timer.TIMERS.length];
	private final Map<String, LineComponent> componentMap = new HashMap<>();
	private final StringBuilder sb = new StringBuilder();

	@Inject
	public FrameTimerOverlay(HdPlugin plugin) {
		super(plugin);
		setLayer(OverlayLayer.ABOVE_SCENE);
		setPosition(OverlayPosition.TOP_RIGHT);
		panelComponent.setPreferredSize(new Dimension(215, 200));
	}

	public void setActive(boolean activate) {
		if (activate) {
			frameTimer.addTimingsListener(this);
			overlayManager.add(this);
		} else {
			frameTimer.removeTimingsListener(this);
			overlayManager.remove(this);
			frames.clear();
		}
	}

	@Override
	public void onFrameCompletion(FrameTimings timings) {
		long now = System.currentTimeMillis();
		while (!frames.isEmpty()) {
			if (now - frames.peekFirst().frameTimestamp < 10e3) // remove older entries
				break;
			frames.removeFirst();
		}
		frames.addLast(timings);
	}

	@Override
	public Dimension render(Graphics2D g) {
		long time = System.nanoTime();
		var boldFont = FontManager.getRunescapeBoldFont();

		var children = panelComponent.getChildren();
		if (!getAverageTimings()) {
			children.add(TitleComponent.builder()
				.text("Waiting for data...")
				.build());
		} else {
			long cpuTime = timings[Timer.DRAW_FRAME.ordinal()];
			addTiming("CPU", cpuTime, true);
			for (var t : Timer.TIMERS)
				if (!t.isGpuTimer && t != Timer.DRAW_FRAME)
					addTiming(t, timings);

			children.add(LineComponent.builder()
				.left("Garbage Collection Count:")
				.right(String.valueOf(plugin.getGarbageCollectionCount()))
				.build());

			long gpuTime = timings[Timer.RENDER_FRAME.ordinal()];
			addTiming("GPU", gpuTime, true);
			for (var t : Timer.TIMERS)
				if (t.isGpuTimer && t != Timer.RENDER_FRAME)
					addTiming(t, timings);

			children.add(LineComponent.builder()
				.leftFont(boldFont)
				.left("Estimated bottleneck:")
				.rightFont(boldFont)
				.right(cpuTime > gpuTime ? "CPU" : "GPU")
				.build());

			children.add(LineComponent.builder()
				.leftFont(boldFont)
				.left("Estimated FPS:")
				.rightFont(boldFont)
				.right(String.format("%.1f FPS", 1e9 / max(cpuTime, gpuTime)))
				.build());

			children.add(LineComponent.builder()
				.left("Error compensation:")
				.right(String.format("%d ns", frameTimer.errorCompensation))
				.build());

			children.add(LineComponent.builder()
				.leftFont(boldFont)
				.left("Scene Stats:")
				.build());

			if (plugin.getSceneContext() != null) {
				var sceneContext = plugin.getSceneContext();
				children.add(LineComponent.builder()
					.left("Lights:")
					.right(String.format("%d/%d", sceneContext.numVisibleLights, sceneContext.lights.size()))
					.build());
			}

			children.add(LineComponent.builder()
				.left("Tiles:")
				.right(String.valueOf(plugin.getDrawnTileCount()))
				.build());

			children.add(LineComponent.builder()
				.left("Static Renderables:")
				.right(String.valueOf(plugin.getDrawnStaticRenderableCount()))
				.build());

			children.add(LineComponent.builder()
				.left("Dynamic Renderables:")
				.right(String.valueOf(plugin.getDrawnDynamicRenderableCount()))
				.build());

			children.add(LineComponent.builder()
				.left("NPC Displacement Cache Size:")
				.right(String.valueOf(npcDisplacementCache.size()))
				.build());

			children.add(LineComponent.builder()
				.leftFont(boldFont)
				.left("Streaming Stats:")
				.build());

			WorldViewContext root = sceneManager.getRoot();
			addTiming("Root Scene Load", root.loadTime, false);
			addTiming("Root Scene Upload", root.uploadTime, false);
			addTiming("Root Scene Swap", root.sceneSwapTime, false);

			// TODO: Maybe this should be calculated somewhere else
			int subSceneCount = 0;
			long subSceneLoadTime = 0;
			long subSceneUploadTime = 0;
			long subSceneSwapTime = 0;

			for (int worldViewId = 0; worldViewId < MAX_WORLDVIEWS; worldViewId++) {
				WorldViewContext subscene = sceneManager.getContext(worldViewId);
				if (subscene != null) {
					subSceneCount++;
					subSceneLoadTime += subscene.loadTime;
					subSceneUploadTime += subscene.uploadTime;
					subSceneSwapTime += subscene.sceneSwapTime;
				}
			}

			if (subSceneCount > 0) {
				addTiming("Avg SubScene Load", subSceneLoadTime / subSceneCount, false);
				addTiming("Avg SubScene Upload", subSceneUploadTime / subSceneCount, false);
				addTiming("Avg SubScene Swap", subSceneSwapTime / subSceneCount, false);
			}

			children.add(LineComponent.builder()
				.left("Sub Scene Count:")
				.right(String.valueOf(subSceneCount))
				.build());


			children.add(LineComponent.builder()
				.left("Streaming Zones:")
				.right(String.valueOf(jobSystem.getWorkQueueSize()))
				.build());


			children.add(LineComponent.builder()
				.leftFont(boldFont)
				.left("Job System:")
				.build());

			children.add(LineComponent.builder()
				.left("Workers Inflight:")
				.right(String.valueOf(jobSystem.getInflightWorkerCount()))
				.build());

			children.add(LineComponent.builder()
				.left("Work Queue:")
				.right(String.valueOf(jobSystem.getWorkQueueSize()))
				.build());

			if (frameTimingsRecorder.isCapturingSnapshot())
				children.add(LineComponent.builder()
					.leftFont(boldFont)
					.left("Capturing Snapshot...")
					.rightFont(boldFont)
					.right(String.format("%d%%", frameTimingsRecorder.getProgressPercentage()))
					.build());
		}

		var result = super.render(g);
		frameTimer.cumulativeError += System.nanoTime() - time;
		return result;
	}

	private boolean getAverageTimings() {
		if (frames.isEmpty())
			return false;

		Arrays.fill(timings, 0);
		for (var frame : frames)
			for (int i = 0; i < frame.timers.length; i++)
				timings[i] += frame.timers[i];

		for (int i = 0; i < timings.length; i++)
			timings[i] = max(0, timings[i] / frames.size());

		return true;
	}

	private void addTiming(Timer timer, long[] timings) {
		addTiming(timer.name, timings[timer.ordinal()], false);
	}

	private void addTiming(String name, long nanos, boolean bold) {
		if (nanos == 0)
			return;

		// Round timers to zero if they are less than a microsecond off
		String result = "~0 ms";
		if (abs(nanos) > 1e3) {
			result = sb.append(round(nanos / 1e3) / 1e3).append(" ms").toString();
			sb.setLength(0);
		}

		LineComponent component = componentMap.get(name);
		if (component == null) {
			var font = bold ? FontManager.getRunescapeBoldFont() : FontManager.getRunescapeFont();
			component = LineComponent.builder()
				.left(name + ":")
				.leftFont(font)
				.right(result)
				.rightFont(font)
				.build();
			componentMap.put(name, component);
		} else {
			component.setRight(result);
		}

		panelComponent.getChildren().add(component);
	}
}

package rs117.hd.overlays;

import java.util.Arrays;

public class FrameTimings {
	public final long frameTimestamp;
	public final long[] timers;

	public FrameTimings(long frameTimestamp, long[] timers) {
		this.frameTimestamp = frameTimestamp;
		this.timers = Arrays.copyOf(timers, timers.length);
	}
}

package rs117.hd.overlays;

import com.google.inject.Singleton;
import javax.inject.Inject;
import javax.swing.SwingUtilities;
import lombok.extern.slf4j.Slf4j;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.events.ConfigChanged;
import rs117.hd.HdPluginConfig;

import static org.lwjgl.opengl.GL33C.*;
import static rs117.hd.HdPluginConfig.*;
import static rs117.hd.utils.MathUtils.*;

@Slf4j
@Singleton
public class GammaCalibrationOverlay extends ShaderOverlay<GammaCalibrationOverlay.Shader> {
	@Inject
	private HdPluginConfig config;

	static class Shader extends ShaderOverlay.Shader {
		public Uniform1f uniCalibrationTimer = addUniform1f("calibrationTimer");

		public Shader() {
			super(t -> t.add(GL_FRAGMENT_SHADER, "overlays/gamma_calibration_frag.glsl"));
		}
	}

	private long brightnessChangedAt;

	public GammaCalibrationOverlay() {
		setBorderless(true);
		setCentered(true);
		setMaintainAspectRatio(true);
		setInitialSize(300, 100);
	}

	private float getTimeout() {
		final int gammaCalibrationTimeout = 3000;
		long t = System.currentTimeMillis() - brightnessChangedAt;
		return saturate(1 - (float) t / gammaCalibrationTimeout);
	}

	@Override
	public boolean isHidden() {
		return super.isHidden() || getTimeout() <= 0 || config.useLegacyBrightness();
	}

	@Override
	protected void updateUniforms() {
		shader.uniCalibrationTimer.set(getTimeout());
	}

	@Subscribe
	public void onConfigChanged(ConfigChanged event) {
		// Try showing the overlay only in response to manually changing the brightness setting
		if (event.getGroup().equals(CONFIG_GROUP) &&
			event.getKey().equals(KEY_BRIGHTNESS) &&
			event.getOldValue() != null &&
			SwingUtilities.isEventDispatchThread())
			brightnessChangedAt = System.currentTimeMillis();
	}
}

package rs117.hd.overlays;

import java.awt.BasicStroke;
import java.awt.Color;
import java.awt.Dimension;
import java.awt.FontMetrics;
import java.awt.Graphics;
import java.awt.Graphics2D;
import java.awt.MouseInfo;
import java.awt.Stroke;
import java.awt.Toolkit;
import java.awt.datatransfer.Clipboard;
import java.awt.datatransfer.StringSelection;
import java.awt.event.KeyEvent;
import java.awt.event.MouseEvent;
import java.util.ArrayList;
import java.util.Arrays;
import javax.inject.Inject;
import javax.inject.Singleton;
import javax.swing.SwingUtilities;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.*;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.input.KeyListener;
import net.runelite.client.input.KeyManager;
import net.runelite.client.input.MouseListener;
import net.runelite.client.input.MouseManager;
import net.runelite.client.ui.FontManager;
import net.runelite.client.ui.overlay.Overlay;
import net.runelite.client.ui.overlay.OverlayLayer;
import net.runelite.client.ui.overlay.OverlayManager;
import net.runelite.client.ui.overlay.OverlayPosition;
import net.runelite.client.util.ColorUtil;
import org.apache.commons.lang3.NotImplementedException;
import rs117.hd.HdPlugin;
import rs117.hd.scene.lights.Alignment;
import rs117.hd.scene.lights.Light;
import rs117.hd.scene.lights.LightType;
import rs117.hd.utils.ColorUtils;
import rs117.hd.utils.Mat4;

import static rs117.hd.utils.MathUtils.*;

@Slf4j
@Singleton
public class LightGizmoOverlay extends Overlay implements MouseListener, KeyListener {
	private static final Color ORANGE = Color.decode("#ff9f2c");

	@Inject
	private Client client;

	@Inject
	private ClientThread clientThread;

	@Inject
	private OverlayManager overlayManager;

	@Inject
	private MouseManager mouseManager;

	@Inject
	private KeyManager keyManager;

	@Inject
	private HdPlugin plugin;

	private boolean hideInvisibleLights;
	private boolean hideRadiusRings = true;
	private boolean hideAnimLights;
	private boolean hideLabels;
	private boolean hideInfo = true;
	private boolean toggleBlackColor;
	private boolean liveInfo;
	private boolean showDuplicationInfo;
	private boolean toggleOpacity = true;
	private boolean followMouse;

	private Action action = Action.SELECT;
	private final float[] rawMousePos = new float[2];
	private final float[] rawMousePosPrev = new float[2];
	private final float[] mouseDelta = new float[2];
	private final float[] cameraOrientation = new float[2];
	private Alignment originalLightAlignment = Alignment.CUSTOM;
	private final float[] originalLightPosition = new float[3];
	private final float[] originalLightOffset = new float[3];
	private final float[] currentLightOffset = new float[3];
	private int freezeMode = 0;
	private final boolean[] frozenAxes = { false, true, false }; // by default, restrict movement to the same height
	private final ArrayList<Light> selections = new ArrayList<>();
	private final ArrayList<Light> hovers = new ArrayList<>();
	private boolean isProbablyRotatingCamera;

	private static final int RELATIVE_TO_CAMERA = 0;
	private static final int RELATIVE_TO_ORIGIN = 1;
	private static final int RELATIVE_TO_POSITION = 2;

	enum Action {
		SELECT, GRAB, SCALE
	}

	public LightGizmoOverlay() {
		setLayer(OverlayLayer.ABOVE_SCENE);
		setPosition(OverlayPosition.DYNAMIC);
	}

	public void setActive(boolean activate) {
		if (activate) {
			overlayManager.add(this);
			mouseManager.registerMouseListener(this);
			keyManager.registerKeyListener(this);
		} else {
			overlayManager.remove(this);
			mouseManager.unregisterMouseListener(this);
			keyManager.unregisterKeyListener(this);
			action = Action.SELECT;
			selections.clear();
		}
	}

	@Override
	public Dimension render(Graphics2D g) {
		var sceneContext = plugin.getSceneContext();
		if (sceneContext == null)
			return null;

		// If the orientation changed, don't consider mouse movement
		boolean wasCameraReoriented = isProbablyRotatingCamera;
		for (int j = 0; j < 2; j++) {
			if (cameraOrientation[j] != plugin.cameraOrientation[j]) {
				wasCameraReoriented = true;
				break;
			}
		}
		copyTo(cameraOrientation, plugin.cameraOrientation);

		boolean isCtrlHeld = client.isKeyPressed(KeyCode.KC_CONTROL);
		boolean isShiftHeld = client.isKeyPressed(KeyCode.KC_SHIFT);
		boolean isAltHeld = client.isKeyPressed(KeyCode.KC_ALT);

		var rawMouse = MouseInfo.getPointerInfo().getLocation();
		rawMousePos[0] = (float) rawMouse.getX();
		rawMousePos[1] = (float) rawMouse.getY();
		if (wasCameraReoriented) {
			if (action == Action.GRAB) {
				assert !selections.isEmpty();
				// Rotation & moving the light with the mouse don't mix very well, so apply the offset and reset mouseDelta when rotating
				if (mouseDelta[0] != 0 || mouseDelta[1] != 0) {
					Arrays.fill(mouseDelta, 0);
					var selection = selections.get(0);
					System.arraycopy(selection.offset, 0, currentLightOffset, 0, 3);
				}
			}
		} else if (!isAltHeld) {
			float scalingFactor = isShiftHeld ? .1f : 1f;
			for (int j = 0; j < 2; j++)
				mouseDelta[j] += (rawMousePos[j] - rawMousePosPrev[j]) * scalingFactor;
		}
		copyTo(rawMousePosPrev, rawMousePos);

		var mousePoint = new java.awt.Point(round(rawMousePos[0]), round(rawMousePos[1]));
		SwingUtilities.convertPointFromScreen(mousePoint, client.getCanvas());
		int[] mousePos = { mousePoint.x, mousePoint.y };

		Point mousePosCanvas = client.getMouseCanvasPosition();
		if (mousePosCanvas != null && (mousePosCanvas.getX() == -1 || mousePosCanvas.getY() == -1))
			mousePosCanvas = null;

		g.setFont(FontManager.getRunescapeSmallFont());

		final int innerDotDiameter = 6;
		final int innerHandleRingDiameter = 19;
		final int outerHandleRingDiameter = 25;
		final int hoverDistanceMargin = 5;

		Stroke thickLine = new BasicStroke(2);
		Stroke thinLine = new BasicStroke(1);
		Stroke thinnerLine = new BasicStroke(.75f);
		Stroke thinDashedLine = new BasicStroke(
			1, BasicStroke.CAP_BUTT, BasicStroke.JOIN_BEVEL,
			0, new float[] { 3 }, 0
		);
		Stroke thinLongDashedLine = new BasicStroke(
			1, BasicStroke.CAP_BUTT, BasicStroke.JOIN_BEVEL,
			0, new float[] { 10 }, 0
		);
		Stroke thickDashedLine = new BasicStroke(
			1.5f, BasicStroke.CAP_BUTT, BasicStroke.JOIN_BEVEL,
			0, new float[] { 3 }, 0
		);

		float[] projectionMatrix = Mat4.identity();
		int viewportWidth = client.getViewportWidth();
		int viewportHeight = client.getViewportHeight();
		Mat4.mul(projectionMatrix, Mat4.translate(client.getViewportXOffset(), client.getViewportYOffset(), 0));
		Mat4.mul(projectionMatrix, Mat4.scale(viewportWidth, viewportHeight, 1));
		Mat4.mul(projectionMatrix, Mat4.translate(.5f, .5f, .5f));
		Mat4.mul(projectionMatrix, Mat4.scale(.5f, -.5f, .5f));
		Mat4.mul(projectionMatrix, plugin.viewProjMatrix);

		float[] inverseProjection = null;
		try {
			inverseProjection = Mat4.inverse(projectionMatrix);
		} catch (IllegalArgumentException ex) {
			log.warn("Not invertible:\n{}", Mat4.format(projectionMatrix));
		}

		int numFrozenAxes = 0;
		if (freezeMode > 0)
			for (int i = 0; i < 3; i++)
				if (frozenAxes[i])
					numFrozenAxes++;

		hovers.clear();
		int counter = 0;
		final float[] lightToCamera = new float[3];
		var lights = sceneContext.lights;

		float[] point = new float[4];
		int selectedIndex = -1;
		for (int i = lights.size() - 1; i >= -1; i--) {
			// Draw the selected light last
			int lightIndex = i;
			if (i == -1) {
				lightIndex = selectedIndex;
				if (lightIndex == -1)
					continue;
			}

			Light l = lights.get(lightIndex);

			if (hideInvisibleLights && !l.def.visibleFromOtherPlanes &&
				(l.plane < client.getPlane() && l.belowFloor || l.plane > client.getPlane() && l.aboveFloor))
				continue;

			if (hideAnimLights && !l.def.animationIds.isEmpty() && !l.parentExists)
				continue;

			boolean isHovered = !hovers.isEmpty() && hovers.get(0) == l;
			boolean isSelected = selections.contains(l);

			// Skip the selected light until the end
			if (i != -1 && isSelected) {
				selectedIndex = i;
				continue;
			}

			if (isSelected && !wasCameraReoriented && inverseProjection != null) {
				if (action == Action.GRAB) {
					float[] oldLightPos = new float[4];
					float[] newLightPos = new float[4];

					float radians = l.orientation * JAU_TO_RAD;
					float sin = sin(radians);
					float cos = cos(radians);

					// Project the light's current position into screen space
					System.arraycopy(l.origin, 0, oldLightPos, 0, 3);
					float x = currentLightOffset[0];
					float z = currentLightOffset[2];
					oldLightPos[0] += -cos * x - sin * z;
					oldLightPos[1] += currentLightOffset[1];
					oldLightPos[2] += -cos * z + sin * x;
					oldLightPos[3] = 1;
					Mat4.projectVec(point, projectionMatrix, oldLightPos);

					if (followMouse) {
						// Move the light to the mouse position
						for (int j = 0; j < 2; j++)
							point[j] = mousePos[j];
					} else {
						// Shift the position with mouse movement
						for (int j = 0; j < 2; j++)
							point[j] += mouseDelta[j];
					}

					if (numFrozenAxes == 0) { // restrict to same depth plane
						// Project the screen position back into the new light position
						Mat4.projectVec(newLightPos, inverseProjection, point);
						if (point[3] <= 0)
							continue;
					} else {
						// p1 & v1 = ray from the camera in the hovered direction
						var p1 = plugin.cameraPosition;
						var v1 = new float[3];

						// Compute a vector from the camera to the target mouse position
						Mat4.projectVec(point, inverseProjection, point);
						for (int j = 0; j < 3; j++)
							v1[j] = point[j] - p1[j];

						if (numFrozenAxes == 1) {
							// restrict to basis plane
							// ax + by + cz = d
							// n = (a, b, c)
							float[] n = new float[3];
							for (int j = 0; j < 3; j++) {
								if (frozenAxes[j]) {
									n[j] = 1;
									break;
								}
							}

							if (freezeMode == RELATIVE_TO_ORIGIN) {
								copyTo(oldLightPos, l.origin);
								oldLightPos[3] = 1;
								Mat4.projectVec(point, projectionMatrix, oldLightPos);
							}

							float d = dot(n, oldLightPos);

							// dot(p1 + v1 * t, n) = d
							// dot(p1, n) + dot(v1 * t, n) = d
							// dot(p1, n) + dot(v1, n) * t = d
							// t = (d - dot(p1, n)) / dot(v1, n)
							float t = (d - dot(p1, n)) / dot(v1, n);

							for (int j = 0; j < 3; j++)
								newLightPos[j] = p1[j] + v1[j] * t;
						} else if (numFrozenAxes == 2) {
							// restrict to axis
							int axis = 0;
							for (int j = 0; j < 3; j++) {
								if (!frozenAxes[j]) {
									axis = j;
									break;
								}
							}

							// p2 & v2 = ray from the light's origin in the direction of the target axis
							var p2 = freezeMode == RELATIVE_TO_ORIGIN ? l.origin : originalLightPosition;
							var v2 = new float[3];
							v2[axis] = 1;

							// v3 is the direction perpendicular to both v1 and v2, which is the direction
							// for the shortest path between two points on the two rays
							var v3 = cross(v1, v2);

							try {
								// Solve the following set of linear equations to find t2; the distance
								// from p2 along v2 until the closest point between the two rays:
								// p1 + v1 * t1 + v3 * t3 = p2 + v2 * t2

								// Solve for t2:
								float t2 = -p1[0] * v1[1] * v3[2] + p1[0] * v1[2] * v3[1] + p1[1] * v1[0] * v3[2] - p1[1] * v1[2] * v3[0]
										   - p1[2] * v1[0] * v3[1] + p1[2] * v1[1] * v3[0] + p2[0] * v1[1] * v3[2] - p2[0] * v1[2] * v3[1]
										   - p2[1] * v1[0] * v3[2] + p2[1] * v1[2] * v3[0] + p2[2] * v1[0] * v3[1] - p2[2] * v1[1] * v3[0];
								t2 /= v1[0] * v2[1] * v3[2] - v1[0] * v2[2] * v3[1] - v1[1] * v2[0] * v3[2] + v1[1] * v2[2] * v3[0]
									  + v1[2] * v2[0] * v3[1] - v1[2] * v2[1] * v3[0];

								for (int j = 0; j < 3; j++)
									newLightPos[j] = p2[j] + v2[j] * t2;
							} catch (IllegalArgumentException ex) {
								log.debug("No solution:", ex);
							}
						}
					}

					int gridSize = isCtrlHeld ? 128 / (isShiftHeld ? 8 : 1) : 1;

					float[] relativePos = new float[3];
					for (int j = 0; j < 3; j++)
						relativePos[j] = newLightPos[j] - l.origin[j];

					x = relativePos[0];
					z = relativePos[2];
					relativePos[0] = -cos * x + sin * z;
					relativePos[2] = -cos * z - sin * x;

					for (int j = 0; j < 3; j++)
						l.offset[j] = round(relativePos[j] / gridSize) * gridSize;

					x = l.offset[0];
					z = l.offset[2];
					l.pos[0] = l.origin[0] + (int) (-cos * x - sin * z);
					l.pos[1] = l.origin[1] + l.offset[1];
					l.pos[2] = l.origin[2] + (int) (-cos * z + sin * x);
				}
			}

			copyTo(point, l.pos);
			point[3] = 1;

			subtract(lightToCamera, plugin.cameraPosition, point);
			float distanceFromCamera = length(lightToCamera);

			Mat4.projectVec(point, projectionMatrix, point);
			if (point[3] <= 0)
				continue;
			int x = round(point[0]);
			int y = round(point[1]);

			// Take perspective depth into account
			int currentDiameter = round(l.radius * 2 / distanceFromCamera * client.getScale());
			float definedDiameter = l.def.radius * 2 / distanceFromCamera * client.getScale();
			float fRange = l.def.range / 100f;
			int minDiameter = round(definedDiameter * (1 - fRange));
			int maxDiameter = round(definedDiameter * (1 + fRange));

			if (mousePosCanvas != null) {
				float d = length(mousePosCanvas.getX() - x, mousePosCanvas.getY() - y);
				if (d <= outerHandleRingDiameter / 2f + hoverDistanceMargin ||
					!hideRadiusRings && abs(d - currentDiameter / 2f) < hoverDistanceMargin * 2)
					hovers.add(l);
			}

			int mainOpacity = toggleOpacity ?
				(l.visible ? 255 : 100) :
				(l.visible ? 100 : 30);
			int rangeOpacity = 70;
			Color baseColor = toggleBlackColor ? Color.BLACK : Color.WHITE;
			Color radiusRingColor = alpha(baseColor, mainOpacity);
			Color rangeRingsColor = alpha(baseColor, rangeOpacity);
			Color handleRingsColor = radiusRingColor;
			Color textColor = Color.WHITE;
			Stroke handleRingsStroke = thinDashedLine;

			if (isSelected) {
				handleRingsColor = radiusRingColor = rangeRingsColor = ORANGE;
				handleRingsStroke = thickDashedLine;
			} else if (isHovered) {
				radiusRingColor = Color.YELLOW;
				handleRingsColor = Color.WHITE;
			} else {
				textColor = alpha(textColor, mainOpacity);
			}

			// Draw handle rings
			drawRing(g, x, y, innerHandleRingDiameter, handleRingsColor, handleRingsStroke);
			drawRing(g, x, y, outerHandleRingDiameter, handleRingsColor, handleRingsStroke);

			// Draw radius rings
			if (!hideRadiusRings) {
				drawRing(g, x, y, currentDiameter, radiusRingColor, thinnerLine);
				if (l.def.type == LightType.PULSE && abs(currentDiameter) > .001f) {
					drawRing(g, x, y, minDiameter, rangeRingsColor, thinLongDashedLine);
					drawRing(g, x, y, maxDiameter, rangeRingsColor, thinLongDashedLine);
				}
			}

			// Only the selected dot has a filled dot in the center
			if (isSelected) {
				fillOutlinedCircle(g, x, y, innerDotDiameter, ORANGE, handleRingsColor, thinLine);
			} else {
				drawCircleOutline(g, x, y, innerDotDiameter, handleRingsColor, thinLine);
			}

			g.setColor(textColor);
			if (!hideLabels) {
				String info = l.def.description;
				if (showDuplicationInfo) {
					int newlines = (counter++ % 5) + 1;
					info += "\n".repeat(newlines);
					info += counter + ": " + l.tileObjectId;
					info += "\n".repeat(5 - newlines);
				}
				if (!hideInfo) {
					info += String.format("\nradius: %.0f", liveInfo ? l.radius : l.def.radius);
					info += String.format("\nstrength: %.1f", liveInfo ? l.strength : l.def.strength);
					var color = ColorUtils.linearToSrgb(l.def.color);
					info += String.format("\ncolor: [%.0f, %.0f, %.0f]", color[0] * 255, color[1] * 255, color[2] * 255);
					// Technically negative Y is up, but invert this in the info shown
					info += String.format(
						"\norigin: [%.0f, %.0f%s, %.0f]",
						l.origin[0],
						-(l.origin[1] + l.def.height),
						l.def.height == 0 ? "" : " + " + l.def.height,
						l.origin[2]
					);
					info += String.format("\noffset: [%.0f, %.0f, %.0f]", l.offset[0], -l.offset[1], l.offset[2]);
					info += String.format("\norientation: %d", l.orientation);
				}
				drawAlignedString(g, info, x, y + 25, TextAlignment.CENTER_ON_COLONS);
			}
		}

		if (!selections.isEmpty()) {
			switch (action) {
				case GRAB:
					Light l = selections.get(0);
					var lightOrigin = freezeMode == RELATIVE_TO_ORIGIN ? l.origin : originalLightPosition;
					System.arraycopy(lightOrigin, 0, point, 0, 3);
					point[3] = 1;
					float[] origin = new float[4];
					Mat4.projectVec(origin, projectionMatrix, point);
					if (point[3] <= 0)
						break;

					if (numFrozenAxes > 0) {
						Color[] axisColors = {
							new Color(0xef738c),
							new Color(0x9fd853),
							new Color(0x75ace1),
						};
						g.setStroke(thickLine);

						float[] stepAlongAxis = new float[4];
						for (int i = 0; i < 3; i++) {
							if (!frozenAxes[i]) {
								int stepSize = 1000;
								point[i] += stepSize;
								Mat4.projectVec(stepAlongAxis, projectionMatrix, point);
								point[i] -= stepSize;

								g.setColor(axisColors[i]);
								drawLineSpan(g, origin, stepAlongAxis);
							}
						}
					}

					copyTo(point, l.pos);
					point[3] = 1;
					float[] pos = new float[4];
					Mat4.projectVec(pos, projectionMatrix, point);
					if (point[3] <= 0)
						break;

					g.setColor(Color.YELLOW);
					drawLineSegment(g, origin, pos);
					break;
				case SCALE:
					break;
			}
		}

		return null;
	}

	private void drawLineSegment(Graphics2D g, float[] a, float[] b) {
		g.drawLine(round(a[0]), round(a[1]), round(b[0]), round(b[1]));
	}

	private void drawLineSpan(Graphics2D g, float[] a, float[] b) {
		float[] v = subtract(b, a);
		if (v[0] == 0 && v[1] == 0)
			return;

		float[] p = new float[2];
		System.arraycopy(a, 0, p, 0, 2);

		var clipBounds = g.getClipBounds();
		float[][] axisBounds = {
			{ 0, clipBounds.width },
			{ 0, clipBounds.height }
		};

		final float INF = Float.POSITIVE_INFINITY;
		final float EPS = 1f;

		// First intersection with an edge within the screen bounds
		float t = INF;
		int intersectedEdge = -1;
		outer:
		for (int axis = 0; axis < 2; axis++) {
			if (v[axis] == 0)
				continue;
			for (int edge = 0; edge < 2; edge++) {
				float d = (axisBounds[axis][edge] - p[axis]) / v[axis];
				int oppositeAxis = (axis + 1) % 2;
				float[] bounds = axisBounds[oppositeAxis];
				float coord = p[oppositeAxis] + v[oppositeAxis] * d;
				if (bounds[0] - EPS < coord && coord < bounds[1] + EPS) {
					t = d;
					intersectedEdge = axis * 2 + edge;
					break outer;
				}
			}
		}
		if (t == INF)
			return;

		// Move the point to the selected edge
		for (int i = 0; i < 2; i++)
			p[i] += v[i] * t;

		t = INF;
		outer:
		for (int axis = 0; axis < 2; axis++) {
			if (v[axis] == 0)
				continue;
			for (int edge = 0; edge < 2; edge++) {
				// Skip the edge we've already intersected with
				if (axis * 2 + edge == intersectedEdge)
					continue;

				float d = (axisBounds[axis][edge] - p[axis]) / v[axis];
				int oppositeAxis = (axis + 1) % 2;
				float[] bounds = axisBounds[oppositeAxis];
				float coord = p[oppositeAxis] + v[oppositeAxis] * d;
				if (bounds[0] - EPS < coord && coord < bounds[1] + EPS) {
					t = d;
					break outer;
				}
			}
		}
		if (t == INF)
			return;

		int x1 = round(p[0]);
		int y1 = round(p[1]);
		int x2 = round(p[0] + v[0] * t);
		int y2 = round(p[1] + v[1] * t);
		g.drawLine(x1, y1, x2, y2);
	}

	private void fillCircle(Graphics2D g, int centerX, int centerY, int diameter, Color color) {
		int r = diameter / 2;
		g.setColor(color);
		g.fillOval(centerX - r, centerY - r, diameter, diameter);
	}

	private void drawRing(Graphics2D g, int centerX, int centerY, int diameter, Color strokeColor, Stroke stroke) {
		// Round down to an odd number
		diameter = ceil(diameter / 2.f) * 2 - 1;
		int r = ceil(diameter / 2.f);
		g.setColor(strokeColor);
		g.setStroke(stroke);
		g.drawOval(centerX - r, centerY - r, diameter, diameter);
	}

	private void fillOutlinedCircle(
		Graphics2D g, int centerX, int centerY, int diameter, Color fillColor, Color strokeColor, Stroke stroke
	) {
		fillCircle(g, centerX, centerY, diameter - 2, fillColor);
		drawCircleOutline(g, centerX, centerY, diameter, strokeColor, stroke);
	}

	private void drawCircleOutline(
		Graphics2D g, int centerX, int centerY, int diameter, Color strokeColor, Stroke stroke
	) {
		int r = ceil(diameter / 2.f);
		int s = diameter - 1;
		g.setColor(strokeColor);
		g.setStroke(stroke);
		g.drawRoundRect(centerX - r, centerY - r, s, s, s - 1, s - 1);
	}

	private enum TextAlignment {
		LEFT, RIGHT, CENTER, CENTER_ON_COLONS
	}

	private void drawCenteredString(Graphics g, String text, int centerX, int centerY, TextAlignment alignment) {
		drawCenteredString(g, text.split("\\n"), centerX, centerY, alignment);
	}

	private void drawCenteredString(Graphics g, String[] lines, int centerX, int centerY, TextAlignment alignment) {
		FontMetrics metrics = g.getFontMetrics();
		int yOffset = metrics.getAscent() - (lines.length * metrics.getHeight()) / 2;
		drawAlignedString(g, lines, centerX, centerY + yOffset, alignment);
	}

	private void drawAlignedString(Graphics g, String text, int centerX, int topY, TextAlignment alignment) {
		drawAlignedString(g, text.split("\\n"), centerX, topY, alignment);
	}

	private void drawAlignedString(Graphics g, String[] lines, int centerX, int topY, TextAlignment alignment) {
		var color = g.getColor();
		var shadow = alpha(Color.BLACK, color.getAlpha());
		FontMetrics metrics = g.getFontMetrics();
		int fontHeight = metrics.getHeight();
		int yOffset = 0;

		if (alignment == TextAlignment.CENTER_ON_COLONS) {
			int longestLeft = 0, longestRight = 0;
			for (String line : lines) {
				int dotIndex = line.indexOf(":");
				String left, right;
				if (dotIndex == -1) {
					left = line;
					right = "";
				} else {
					left = line.substring(0, dotIndex);
					right = line.substring(dotIndex + 1);
				}
				int leftLen = metrics.stringWidth(left);
				if (leftLen > longestLeft) {
					longestLeft = leftLen;
				}
				int rightLen = metrics.stringWidth(right);
				if (rightLen > longestRight) {
					longestRight = rightLen;
				}
			}

			int dotOffset = -metrics.stringWidth(":") / 2;

			for (String line : lines) {
				int dotIndex = line.indexOf(":");
				int xOffset = dotOffset;
				if (dotIndex == -1) {
					xOffset -= metrics.stringWidth(line) / 2;
				} else {
					xOffset -= metrics.stringWidth(line.substring(0, dotIndex));
				}
				g.setColor(shadow);
				g.drawString(line, centerX + xOffset + 1, topY + yOffset + 1);
				g.setColor(color);
				g.drawString(line, centerX + xOffset, topY + yOffset);
				yOffset += fontHeight;
			}
		} else {
			int longestLine = 0;
			if (alignment != TextAlignment.CENTER) {
				for (String line : lines) {
					int length = metrics.stringWidth(line);
					if (longestLine < length) {
						longestLine = length;
					}
				}
			}
			for (String line : lines) {
				int xOffset;
				switch (alignment) {
					case LEFT:
						xOffset = -longestLine / 2;
						break;
					case RIGHT:
						int length = metrics.stringWidth(line);
						xOffset = longestLine / 2 - length;
						break;
					case CENTER:
						xOffset = -metrics.stringWidth(line) / 2;
						break;
					default:
						throw new NotImplementedException("Alignment " + alignment + " has not been implemented");
				}
				g.setColor(shadow);
				g.drawString(line, centerX + xOffset + 1, topY + yOffset + 1);
				g.setColor(color);
				g.drawString(line, centerX + xOffset, topY + yOffset);
				yOffset += fontHeight;
			}
		}
	}

	private Color alpha(Color rgb, int alpha) {
		if (alpha == 255)
			return rgb;
		return new Color(rgb.getRed(), rgb.getGreen(), rgb.getBlue(), alpha);
	}

	private boolean applyPendingChange() {
		if (action == Action.SELECT || selections.isEmpty())
			return false;

		action = Action.SELECT;
		return true;
	}

	private boolean discardPendingChange() {
		if (action == Action.SELECT) {
			if (!selections.isEmpty())
				selections.clear();
			return false;
		}

		if (selections.isEmpty())
			return false;

		if (action == Action.GRAB) {
			// Reset the light back to its original offset
			var l = selections.get(0);
			l.alignment = originalLightAlignment;
			copyTo(l.offset, originalLightOffset);
		}

		action = Action.SELECT;
		return true;
	}

	@Override
	public MouseEvent mouseClicked(MouseEvent e) {
		return e;
	}

	@Override
	public MouseEvent mousePressed(MouseEvent e) {
		if (SwingUtilities.isMiddleMouseButton(e))
			isProbablyRotatingCamera = true;

		switch (action) {
			case SELECT:
				if (SwingUtilities.isLeftMouseButton(e) && e.isControlDown()) {
					e.consume();

					selections.clear();
					if (!hovers.isEmpty()) {
						selections.add(hovers.get(0));
					} else {
						action = Action.SELECT;
					}
				}
				break;
			case GRAB:
				if (SwingUtilities.isLeftMouseButton(e)) {
					if (applyPendingChange())
						e.consume();
				} else if (SwingUtilities.isRightMouseButton(e)) {
					if (discardPendingChange())
						e.consume();
				}
				break;
			case SCALE:
				break;
		}
		return e;
	}

	@Override
	public MouseEvent mouseReleased(MouseEvent e) {
		if (SwingUtilities.isMiddleMouseButton(e))
			isProbablyRotatingCamera = false;
		return e;
	}

	@Override
	public MouseEvent mouseEntered(MouseEvent e) {
		return e;
	}

	@Override
	public MouseEvent mouseExited(MouseEvent e) {
		return e;
	}

	@Override
	public MouseEvent mouseDragged(MouseEvent e) {
		return e;
	}

	@Override
	public MouseEvent mouseMoved(MouseEvent e) {
		return e;
	}

	@Override
	public void keyTyped(KeyEvent e) {}

	@Override
	public void keyPressed(KeyEvent e) {
//		if (e.isControlDown() && e.isShiftDown() && e.getKeyCode() == KeyCode.KC_S) {
//			// TODO: Save changes to JSON
//			// Every time the JSON is updated, either through the file system or exporting changes,
//			// create a checkpoint. Store all checkpoints in memory throughout the client session.
//			// Implement ctrl Z and ctrl shift Z to redo. Forget reverted checkpoints upon file change.
//		}

		// Interaction with selected object
		if (!selections.isEmpty()) {
			var l = selections.get(0);

			if (e.isControlDown() && e.getKeyCode() == KeyEvent.VK_C) {
				String str = "\n    \"offset\": [ " + l.offset[0] + ", " + -l.offset[1] + ", " + l.offset[2] + " ],";

				Clipboard clipboard = Toolkit.getDefaultToolkit().getSystemClipboard();
				StringSelection string = new StringSelection(str);
				clipboard.setContents(string, null);
				clientThread.invoke(() -> client.addChatMessage(
					ChatMessageType.GAMEMESSAGE,
					"117 HD",
					ColorUtil.wrapWithColorTag("[117 HD] Copied offset (must remove alignment): " + str.trim(), Color.GREEN),
					"117 HD"
				));
			}

			if (action == Action.SELECT) {
				switch (e.getKeyCode()) {
					case KeyEvent.VK_G:
						action = Action.GRAB;
						Arrays.fill(mouseDelta, 0);

						originalLightAlignment = l.alignment;
						copyTo(originalLightOffset, l.offset);
						copyTo(originalLightPosition, l.pos);

						l.alignment = Alignment.CUSTOM;
						for (int i = 0; i < 3; i++)
							l.offset[i] = l.pos[i] - l.origin[i];
						System.arraycopy(l.offset, 0, currentLightOffset, 0, 3);
						break;
					case KeyEvent.VK_S:
						action = Action.SCALE;
						break;
				}
			} else if (action == Action.GRAB) {
				int axis = -1;
				boolean cycleFreezeMode = false;
				switch (e.getKeyCode()) {
					case KeyEvent.VK_X:
						axis = 0;
						break;
					case KeyEvent.VK_Y:
						axis = 1;
						break;
					case KeyEvent.VK_Z:
						axis = 2;
						break;
					case KeyEvent.VK_G:
						cycleFreezeMode = true;
						break;
				}
				if (axis != -1) {
					boolean invert = e.isShiftDown();
					boolean modified = false;
					for (int i = 0; i < 3; i++) {
						boolean shouldFreeze = i == axis == invert;
						if (shouldFreeze != frozenAxes[i])
							modified = true;
						frozenAxes[i] = shouldFreeze;
					}
					if (modified) {
						// Reset current offset
						if (freezeMode == 0)
							freezeMode = 1;
						copyTo(l.offset, originalLightOffset);
					} else {
						cycleFreezeMode = true;
					}
				}
				if (cycleFreezeMode) {
					// If the same combination is repeated, cycle through different modes
					freezeMode++;
					freezeMode %= 3;
				}
			}

			switch (e.getKeyCode()) {
				case KeyEvent.VK_ESCAPE:
					if (discardPendingChange())
						e.consume();
					break;
				case KeyEvent.VK_ENTER:
					if (applyPendingChange())
						e.consume();
					break;
				case KeyEvent.VK_BACK_SPACE:
					// Reset light back to its defined offset
					l.alignment = l.def.alignment;
					System.arraycopy(l.def.offset, 0, l.offset, 0, 3);
					copyTo(currentLightOffset, l.offset);
					copyTo(originalLightOffset, l.offset);
					Arrays.fill(mouseDelta, 0);
					break;
			}
		}

		// Toggles
		if (e.isControlDown()) {
			switch (e.getKeyCode()) {
				case KeyEvent.VK_A:
					hideAnimLights = !hideAnimLights;
					break;
				case KeyEvent.VK_B:
					toggleBlackColor = !toggleBlackColor;
					break;
				case KeyEvent.VK_D:
					showDuplicationInfo = !showDuplicationInfo;
					break;
				case KeyEvent.VK_I:
					hideInfo = !hideInfo;
					break;
				case KeyEvent.VK_L:
					hideLabels = !hideLabels;
					break;
				case KeyEvent.VK_M:
					followMouse = !followMouse;
					break;
				case KeyEvent.VK_O:
					toggleOpacity = !toggleOpacity;
					break;
				case KeyEvent.VK_R:
					hideRadiusRings = !hideRadiusRings;
					break;
				case KeyEvent.VK_U:
					liveInfo = !liveInfo;
					break;
			}
		} else {
			switch (e.getKeyCode()) {
				case KeyEvent.VK_H:
					hideInvisibleLights = !hideInvisibleLights;
					break;
			}
		}
	}

	@Override
	public void keyReleased(KeyEvent e) {}
}

/*
 * Copyright (c) 2025, Hooder <ahooder@protonmail.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package rs117.hd.overlays;

import com.google.inject.Singleton;
import java.awt.Color;
import java.awt.Cursor;
import java.awt.Dimension;
import java.awt.Graphics2D;
import java.awt.Point;
import java.awt.Rectangle;
import java.io.IOException;
import java.util.function.Consumer;
import javax.inject.Inject;
import lombok.Getter;
import lombok.Setter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.*;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.eventbus.EventBus;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.ui.ClientUI;
import net.runelite.client.ui.overlay.Overlay;
import net.runelite.client.ui.overlay.OverlayLayer;
import net.runelite.client.ui.overlay.OverlayManager;
import net.runelite.client.ui.overlay.OverlayPosition;
import rs117.hd.HdPlugin;
import rs117.hd.opengl.shader.ShaderException;
import rs117.hd.opengl.shader.ShaderProgram;
import rs117.hd.opengl.shader.ShaderTemplate;
import rs117.hd.utils.ShaderRecompile;

import static org.lwjgl.opengl.GL33C.*;
import static rs117.hd.utils.MathUtils.*;

@Slf4j
@Singleton
public class ShaderOverlay<T extends ShaderOverlay.Shader> extends Overlay {
	@Inject
	private Client client;

	@Inject
	private ClientUI clientUI;

	@Inject
	private ClientThread clientThread;

	@Inject
	private EventBus eventBus;

	@Inject
	private OverlayManager overlayManager;

	@Inject
	private HdPlugin plugin;

	@Inject
	public T shader;

	@Getter
	@Setter
	private boolean borderless;

	@Getter
	private boolean centered;

	@Setter
	private boolean maintainAspectRatio;

	@Getter
	private boolean fullscreen;

	private boolean movable = true;
	private boolean snappable = true;

	private boolean initialized;
	private final Dimension initialSize = new Dimension(256, 256);
	private long becameHiddenAt;
	private boolean isHidden = true;
	private boolean skipNextGetPreferredLocation;
	private boolean isProbablyStartingResize;
	private Rectangle resizeStartingBounds = new Rectangle();
	private final float[] aspectRatioRoundingError = { 0, 0 };

	public static class Shader extends ShaderProgram {
		protected final Uniform4f uniTransform = addUniform4f("transform");

		public Shader(Consumer<ShaderTemplate> templateConsumer) {
			super(template -> {
				template
					.add(GL_VERTEX_SHADER, "overlays/overlay_vert.glsl")
					.add(GL_FRAGMENT_SHADER, "overlays/overlay_frag.glsl");
				templateConsumer.accept(template);
			});
		}
	}

	public ShaderOverlay() {
		setLayer(OverlayLayer.ABOVE_WIDGETS);
		setResizable(true);
	}

	public void initialize() {
		try {
			shader.compile(plugin.getShaderIncludes());
		} catch (Exception ex) {
			log.error("Failed to compile shader:", ex);
			return;
		}
		overlayManager.add(this);
		eventBus.register(this);
		initialized = true;
	}

	public void destroy() {
		initialized = false;
		isHidden = true;
		becameHiddenAt = 0;
		overlayManager.remove(this);
		eventBus.unregister(this);
		shader.destroy();
	}

	public void setActive(boolean activate) {
		if (activate == initialized)
			return;

		clientThread.invoke(() -> {
			if (activate) {
				initialize();
			} else {
				destroy();
			}
		});
	}

	@Override
	protected void setMovable(boolean movable) {
		super.setMovable(movable);
		this.movable = movable;
	}

	@Override
	protected void setSnappable(boolean snappable) {
		super.setSnappable(snappable);
		this.snappable = snappable;
	}

	protected void setFullscreen(boolean fullscreen) {
		this.fullscreen = fullscreen;
		if (fullscreen) {
			setPosition(OverlayPosition.DYNAMIC);
		} else {
			setPosition(OverlayPosition.TOP_LEFT);
		}
	}

	protected void setCentered(boolean centered) {
		this.centered = centered;
		setPosition(centered ? OverlayPosition.DYNAMIC : OverlayPosition.TOP_LEFT);
		super.setMovable(movable);
		super.setSnappable(snappable);
	}

	public boolean shouldMaintainAspectRatio() {
		return maintainAspectRatio;
	}

	protected void setInitialSize(int width, int height) {
		initialSize.setSize(width, height);
	}

	@Override
	public Dimension getPreferredSize() {
		if (isFullscreen())
			return null;
		var size = super.getPreferredSize();
		return size != null ? size : new Dimension(initialSize);
	}

	private boolean isLoggedIn() {
		return client != null && client.getGameState().getState() >= GameState.LOGGED_IN.getState();
	}

	private boolean shouldKeepCentered() {
		// If centered & not at a custom position & not in a snap corner & currently logged in to interact with overlays
		return centered && getPreferredLocation() == null && getPreferredPosition() == null && isLoggedIn();
	}

	@Override
	public Rectangle getBounds() {
		var bounds = super.getBounds();
		if (shouldKeepCentered()) {
			bounds.setSize(getPreferredSize());
			bounds.x = (client.getCanvasWidth() - bounds.width) / 2;
			bounds.y = (client.getCanvasHeight() - bounds.height) / 2;
		}
		if (isProbablyStartingResize) {
			isProbablyStartingResize = false;
			resizeStartingBounds = new Rectangle(bounds);
		}
		return bounds;
	}

	@Override
	public Point getPreferredLocation() {
		// Hacky way to prevent RuneLite from updating the location during resizing
		if (skipNextGetPreferredLocation) {
			skipNextGetPreferredLocation = false;
			return null;
		}
		return super.getPreferredLocation();
	}

	@Override
	public void setPreferredLocation(Point preferredLocation) {
		// Reset the hide timer while resizing
		if (!resizeStartingBounds.isEmpty())
			resetHideTimer();
		super.setPreferredLocation(preferredLocation);
	}

	@Override
	public boolean isResizable() {
		isProbablyStartingResize = true;
		return super.isResizable();
	}

	@Override
	public void setPreferredSize(Dimension size) {
		if (size != null) {
			// Reset the hide timer while resizing
			if (!resizeStartingBounds.isEmpty())
				resetHideTimer();

			int minWidth, minHeight;
			minWidth = minHeight = getMinimumSize();
			int maxWidth = client.getCanvasWidth() - 1;
			int maxHeight = client.getCanvasHeight() - 1;
			var cursor = clientUI.getCurrentCursor().getType();

			// Take over resizing when centered
			if (shouldKeepCentered()) {
				var prev = getPreferredSize();
				var mouse = client.getMouseCanvasPosition();
				if (size.width != prev.width)
					size.width = 2 * mouse.getX() - maxWidth;
				if (size.height != prev.height)
					size.height = 2 * mouse.getY() - maxHeight;

				switch (cursor) {
					case Cursor.NW_RESIZE_CURSOR:
						size.height *= -1;
					case Cursor.W_RESIZE_CURSOR:
					case Cursor.SW_RESIZE_CURSOR:
						size.width *= -1;
						break;
					case Cursor.N_RESIZE_CURSOR:
					case Cursor.NE_RESIZE_CURSOR:
						size.height *= -1;
						break;
				}

				size.width = clamp(size.width, minWidth, maxWidth);
				size.height = clamp(size.height, minHeight, maxHeight);
			}

			if (shouldMaintainAspectRatio()) {
				float aspectRatio = (float) initialSize.width / initialSize.height;
				if (aspectRatio > 1) {
					minWidth = round(minHeight * aspectRatio);
					maxHeight = round(maxWidth / aspectRatio);
				} else {
					minHeight = round(minWidth / aspectRatio);
					maxWidth = round(maxHeight * aspectRatio);
				}

				boolean resizingHeight = cursor == Cursor.N_RESIZE_CURSOR || cursor == Cursor.S_RESIZE_CURSOR;
				if (resizingHeight) {
					size.width = round(size.height * aspectRatio);
				} else {
					size.height = round(size.width / aspectRatio);
				}

				size.width = clamp(size.width, minWidth, maxWidth);
				size.height = clamp(size.height, minHeight, maxHeight);

				var loc = getPreferredLocation();
				if (loc != null) {
					var prevSize = getPreferredSize();
					int widthChange = size.width - prevSize.width;
					int heightChange = size.height - prevSize.height;

					// Since we'll be skipping RuneLite's location adjustment, we must add it in ourselves
					switch (cursor) {
						case Cursor.N_RESIZE_CURSOR:
						case Cursor.NE_RESIZE_CURSOR:
							loc.y -= heightChange;
							break;
						case Cursor.W_RESIZE_CURSOR:
						case Cursor.SW_RESIZE_CURSOR:
							loc.x -= widthChange;
							break;
						case Cursor.NW_RESIZE_CURSOR:
							loc.x -= widthChange;
							loc.y -= heightChange;
							break;
					}

					// If adjusting along one dimension, automatically adjust the other dimension to maintain the aspect ratio
					switch (cursor) {
						case Cursor.N_RESIZE_CURSOR:
						case Cursor.S_RESIZE_CURSOR:
						case Cursor.E_RESIZE_CURSOR:
						case Cursor.W_RESIZE_CURSOR:
							if (resizingHeight) {
								float shouldSubtract = widthChange / 2f + aspectRatioRoundingError[0];
								int willSubtract = (int) shouldSubtract;
								aspectRatioRoundingError[0] = shouldSubtract - willSubtract;
								loc.x -= willSubtract;
							} else {
								float shouldSubtract = heightChange / 2f + aspectRatioRoundingError[1];
								int willSubtract = (int) shouldSubtract;
								aspectRatioRoundingError[1] = shouldSubtract - willSubtract;
								loc.y -= willSubtract;
							}
							break;
					}

					// Update the location and skip the next location update to ignore RuneLite's resize location change
					setPreferredLocation(loc);
					skipNextGetPreferredLocation = true;
				}
			}
		}

		super.setPreferredSize(size);
	}

	@Subscribe
	public void onShaderRecompile(ShaderRecompile event) throws ShaderException, IOException {
		shader.compile(event.includes);
	}

	public boolean isHidden() {
		return !initialized || !shader.isValid() || !isLoggedIn();
	}

	public boolean isManageable() {
		return isMovable() || isResizable();
	}

	private void updateTransform() {
		assert shader.isActive();
		if (isFullscreen()) {
			shader.uniTransform.set(0, 0, 1, 1);
		} else {
			int[] resolution = plugin.getUiResolution();
			if (resolution == null)
				return;
			var bounds = getBounds();
			// Calculate translation and scale in NDC
			float[] rect = { bounds.x + 1, bounds.y + 1, bounds.width - 1, bounds.height - 1 };
			rect[0] += rect[0] + rect[2];
			rect[1] += rect[1] + rect[3];
			for (int i = 0; i < 2; i++) {
				rect[i * 2] /= resolution[0];
				rect[i * 2 + 1] /= resolution[1];
				rect[i] -= 1;
			}
			rect[1] *= -1;
			shader.uniTransform.set(rect);
		}
	}

	public void render() {
		if (isHidden())
			return;

		shader.use();
		updateTransform();
		updateUniforms();
		renderShader();
	}

	protected void updateUniforms() {}

	protected void renderShader() {
		glEnable(GL_BLEND);
		glBlendFuncSeparate(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA, GL_ZERO, GL_ONE);
		if (fullscreen) {
			glBindVertexArray(plugin.vaoTri);
			glDrawArrays(GL_TRIANGLES, 0, 3);
		} else {
			glBindVertexArray(plugin.vaoQuad);
			glDrawArrays(GL_TRIANGLE_FAN, 0, 4);
		}
	}

	private void resetHideTimer() {
		becameHiddenAt = System.currentTimeMillis();
	}

	private long getTimeSinceHiding() {
		return System.currentTimeMillis() - becameHiddenAt;
	}

	private boolean getUpdatedHiddenState() {
		boolean isHidden = isHidden();
		if (isHidden && !this.isHidden)
			resetHideTimer();
		return this.isHidden = isHidden;
	}

	@Override
	public Dimension render(Graphics2D g) {
		var bounds = getBounds();
		if (getUpdatedHiddenState()) {
			// When the overlay is hidden, keep it manageable for a minute by not returning null
			if (!isManageable() || getTimeSinceHiding() >= 60000) {
				resizeStartingBounds.setSize(0, 0);
				return null;
			}
		} else if (!borderless) {
			g.setColor(Color.BLACK);
			g.drawRect(0, 0, bounds.width, bounds.height);
		}
		return bounds.getSize();
	}

	protected void drawStringShadowed(Graphics2D g, String s, float x, float y) {
		var c = g.getColor();
		g.setColor(Color.BLACK);
		g.drawString(s, x + 1, y + 1);
		g.setColor(c);
		g.drawString(s, x, y);
	}

	protected void drawStringCentered(Graphics2D g, String s, float x, float y) {
		var m = g.getFontMetrics();
		drawStringShadowed(g, s, x - m.stringWidth(s) / 2.f, y + m.getHeight() / 2.f);
	}

	protected void drawStringCentered(Graphics2D g, String s) {
		var b = g.getClipBounds();
		drawStringCentered(g, s, b.width / 2.f, b.height / 2.f);
	}
}

package rs117.hd.overlays;

import com.google.inject.Singleton;
import lombok.extern.slf4j.Slf4j;

import static org.lwjgl.opengl.GL33C.*;
import static rs117.hd.HdPlugin.TEXTURE_UNIT_SHADOW_MAP;

@Slf4j
@Singleton
public class ShadowMapOverlay extends ShaderOverlay<ShadowMapOverlay.Shader> {
	static class Shader extends ShaderOverlay.Shader {
		private final UniformTexture uniShadowMap = addUniformTexture("shadowMap");

		public Shader() {
			super(t -> t.add(GL_FRAGMENT_SHADER, "overlays/shadow_map_frag.glsl"));
		}

		@Override
		protected void initialize() {
			uniShadowMap.set(TEXTURE_UNIT_SHADOW_MAP);
		}
	}
}

package rs117.hd.overlays;

import java.awt.Color;
import java.awt.Dimension;
import java.awt.Graphics2D;
import javax.inject.Inject;
import javax.inject.Singleton;
import lombok.extern.slf4j.Slf4j;
import net.runelite.client.ui.overlay.OverlayLayer;
import rs117.hd.HdPlugin;
import rs117.hd.config.DynamicLights;

import static org.lwjgl.opengl.GL33C.*;
import static rs117.hd.HdPlugin.TEXTURE_UNIT_TILED_LIGHTING_MAP;

@Slf4j
@Singleton
public class TiledLightingOverlay extends ShaderOverlay<TiledLightingOverlay.Shader> {
	static class Shader extends ShaderOverlay.Shader {
		private final UniformTexture uniTiledLightingTextureArray = addUniformTexture("tiledLightingArray");

		public Shader() {
			super(t -> t.add(GL_FRAGMENT_SHADER, "overlays/tiled_lighting_overlay_frag.glsl"));
		}

		@Override
		protected void initialize() {
			uniTiledLightingTextureArray.set(TEXTURE_UNIT_TILED_LIGHTING_MAP);
		}
	}

	@Inject
	private HdPlugin plugin;

	public TiledLightingOverlay() {
		setLayer(OverlayLayer.ABOVE_SCENE);
		setFullscreen(true);
	}

	@Override
	public boolean isHidden() {
		return super.isHidden() || plugin.configDynamicLights == DynamicLights.NONE || !plugin.configTiledLighting;
	}

	@Override
	public Dimension render(Graphics2D g) {
		if (!super.isHidden()) {
			g.setColor(Color.YELLOW);
			boolean usingImageLoadStore = plugin.getTiledLightingImageStoreProgram().isValid();
			drawStringShadowed(g, String.format("Using GL_ARB_shader_image_load_store: %B", usingImageLoadStore), 4, 32);
			if (plugin.configDynamicLights == DynamicLights.NONE) {
				drawStringCentered(g, "Dynamic lights are disabled");
			} else if (!plugin.configTiledLighting) {
				drawStringCentered(g, "Tiled lighting is disabled");
			}
		}
		return super.render(g);
	}
}

package rs117.hd.overlays;

import com.google.inject.Singleton;
import java.awt.BasicStroke;
import java.awt.Color;
import java.awt.Dimension;
import java.awt.Font;
import java.awt.FontMetrics;
import java.awt.Graphics2D;
import java.awt.Polygon;
import java.awt.Rectangle;
import java.awt.RenderingHints;
import java.awt.Toolkit;
import java.awt.datatransfer.Clipboard;
import java.awt.datatransfer.StringSelection;
import java.awt.event.MouseEvent;
import java.awt.event.MouseWheelEvent;
import java.awt.geom.Rectangle2D;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Objects;
import java.util.function.Function;
import java.util.regex.Pattern;
import javax.annotation.Nonnull;
import javax.annotation.Nullable;
import javax.inject.Inject;
import javax.swing.SwingUtilities;
import lombok.Getter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.*;
import net.runelite.api.coords.*;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.input.MouseListener;
import net.runelite.client.input.MouseManager;
import net.runelite.client.input.MouseWheelListener;
import net.runelite.client.ui.FontManager;
import net.runelite.client.ui.overlay.Overlay;
import net.runelite.client.ui.overlay.OverlayLayer;
import net.runelite.client.ui.overlay.OverlayManager;
import net.runelite.client.ui.overlay.OverlayPosition;
import net.runelite.client.util.Text;
import org.apache.commons.lang3.tuple.Pair;
import rs117.hd.HdPlugin;
import rs117.hd.data.ObjectType;
import rs117.hd.scene.AreaManager;
import rs117.hd.scene.GamevalManager;
import rs117.hd.scene.MaterialManager;
import rs117.hd.scene.ProceduralGenerator;
import rs117.hd.scene.SceneContext;
import rs117.hd.scene.TileOverrideManager;
import rs117.hd.scene.areas.AABB;
import rs117.hd.scene.areas.Area;
import rs117.hd.scene.materials.Material;
import rs117.hd.utils.ColorUtils;
import rs117.hd.utils.HDUtils;
import rs117.hd.utils.ModelHash;

import static net.runelite.api.Constants.*;
import static net.runelite.api.Constants.SCENE_SIZE;
import static net.runelite.api.Perspective.*;
import static rs117.hd.HdPlugin.ORTHOGRAPHIC_ZOOM;
import static rs117.hd.scene.tile_overrides.TileOverride.OVERLAY_FLAG;
import static rs117.hd.utils.HDUtils.HIDDEN_HSL;
import static rs117.hd.utils.MathUtils.*;

@Slf4j
@Singleton
public class TileInfoOverlay extends Overlay implements MouseListener, MouseWheelListener {
	private static final Font MONOSPACE_FONT = new Font("Courier New", Font.PLAIN, 12);
	private static final Color BACKDROP_COLOR = new Color(0, 0, 0, 100);
	private static final Color TRANSPARENT_YELLOW_50 = new Color(255, 255, 0, 50);
	private static final Color TRANSPARENT_YELLOW_100 = new Color(255, 255, 0, 100);
	private static final Color TRANSPARENT_WHITE_100 = new Color(255, 255, 255, 100);

	@Inject
	private Client client;

	@Inject
	private ClientThread clientThread;

	@Inject
	private OverlayManager overlayManager;

	@Inject
	private MouseManager mouseManager;

	@Inject
	private HdPlugin plugin;

	@Inject
	private MaterialManager materialManager;

	@Inject
	private TileOverrideManager tileOverrideManager;

	@Inject
	private GamevalManager gamevalManager;

	@Inject
	private ProceduralGenerator proceduralGenerator;

	@Getter
	private boolean active;

	private float[] mousePos;
	private boolean ctrlHeld;
	private boolean ctrlToggled;
	private boolean shiftHeld;
	private boolean altHeld;
	private float zoom = 1;

	private static final int MODE_TILE_INFO = 0;
	private static final int MODE_MODEL_INFO = 1;
	private static final int MODE_SCENE_AABBS = 2;
	private static final int MODE_OBJECT_IDS = 3;

	private int mode;
	private int aabbMarkingStage;
	private AABB pendingSelection;
	private final ArrayList<AABB> selections = new ArrayList<>();
	private final int[] selectedAreaAabb = { -1, 0 };
	private final int[] hoveredAreaAabb = { -1, 0 };
	private final int[][] markedWorldPoints = new int[2][3];
	private int[] hoveredWorldPoint = new int[3];
	private int targetPlane = MAX_Z - 1;
	private boolean selectionIncludeZ;

	private SceneContext currentSceneContext;
	private Area[] visibleAreas = new Area[0];
	private final AABB dummyAabb = new AABB(0, 0);
	private int[] sceneBase;
	private final ArrayList<String> hoveredGamevals = new ArrayList<>();
	private int hoveredGamevalsIndex;
	private int hoveredGamevalsHash;
	private int copiedGamevalsHash;

	public TileInfoOverlay() {
		setLayer(OverlayLayer.ABOVE_SCENE);
		setPosition(OverlayPosition.DYNAMIC);
	}

	public void setActive(boolean activate) {
		this.active = activate;
		if (activate) {
			overlayManager.add(this);
			// Listen to events before they're possibly consumed in DeveloperTools
			mouseManager.registerMouseListener(0, this);
			mouseManager.registerMouseWheelListener(this);
		} else {
			overlayManager.remove(this);
			mouseManager.unregisterMouseListener(this);
			mouseManager.unregisterMouseWheelListener(this);
		}
		tileOverrideManager.setTrackReplacements(activate);
	}

	@Override
	public synchronized Dimension render(Graphics2D g) {
		// Disable the overlay while loading a scene, since tile overrides aren't thread safe
		if (plugin.isLoadingScene())
			return null;

		var ctx = plugin.getSceneContext();
		if (ctx == null)
			return null;

		if (ctx != currentSceneContext) {
			currentSceneContext = ctx;

			hoveredAreaAabb[0] = -1;
			hoveredAreaAabb[1] = 0;
			copyTo(selectedAreaAabb, hoveredAreaAabb);

			sceneBase = Objects.requireNonNullElseGet(
				ctx.sceneBase,
				() -> HDUtils.getSceneBaseBestGuess(ctx.scene, client.getPlane())
			);

			if (ctx.sceneBase == null) {
				visibleAreas = new Area[0];
			} else {
				visibleAreas = Arrays
					.stream(AreaManager.AREAS)
					.map(area -> {
						var copy = new Area(area.name);
						copy.regions = area.regions;
						copy.regionBoxes = area.regionBoxes;
						copy.rawAabbs = area.rawAabbs;
						copy.normalize();
						copy.unhideAreas = area.unhideAreas;
						copy.aabbs = Arrays
							.stream(copy.aabbs)
							.map(aabb -> ctx.sceneBounds.intersects(aabb) ? aabb : dummyAabb)
							.toArray(AABB[]::new);
						return copy;
					})
					.filter(area -> Arrays.stream(area.aabbs)
						.anyMatch(aabb -> aabb != dummyAabb))
					.toArray(Area[]::new);
			}
		}

		boolean ctrlPressed = client.isKeyPressed(KeyCode.KC_CONTROL);
		if (ctrlHeld != ctrlPressed) {
			ctrlHeld = ctrlPressed;
			if (ctrlPressed)
				ctrlToggled = !ctrlToggled;
		}
		boolean shiftPressed = client.isKeyPressed(KeyCode.KC_SHIFT);
		if (shiftHeld != shiftPressed) {
			shiftHeld = shiftPressed;
			if (shiftPressed)
				mode = (mode + 1) % 4;
		}
		altHeld = client.isKeyPressed(KeyCode.KC_ALT);

		Tile[][][] tiles = ctx.scene.getExtendedTiles();
		int[][][] templateChunks = ctx.scene.isInstance() ? ctx.scene.getInstanceTemplateChunks() : null;
		Point canvasMousePos = client.getMouseCanvasPosition();
		mousePos = null;
		if (canvasMousePos != null && canvasMousePos.getX() != -1 && canvasMousePos.getY() != -1)
			mousePos = new float[] { canvasMousePos.getX(), canvasMousePos.getY() };
		hoveredGamevals.clear();

		int maxPlane = client.getPlane();
		int minPlane = 0;
		if (ctrlHeld)
			minPlane = maxPlane = targetPlane;

		if (mousePos != null) {
			g.setFont(FontManager.getRunescapeFont());
			g.setStroke(new BasicStroke(1, BasicStroke.CAP_BUTT, BasicStroke.JOIN_ROUND));

			tileLoop:
			for (int secondTry = 0; secondTry <= 1; secondTry++) {
				for (int z = maxPlane; z >= minPlane; z--) {
					for (int isBridge = 1; isBridge >= 0; isBridge--) {
						for (int x = 0; x < EXTENDED_SCENE_SIZE; x++) {
							for (int y = 0; y < EXTENDED_SCENE_SIZE; y++) {
								Tile tile = tiles[z][x][y];
								boolean shouldDraw = tile != null && (isBridge == 0 || tile.getBridge() != null);
								if (shouldDraw) {
									if (templateChunks != null) {
										int sx = x - ctx.sceneOffset;
										int sy = y - ctx.sceneOffset;
										if (sx < 0 || sy < 0 || sx >= SCENE_SIZE || sy >= SCENE_SIZE)
											continue;
										int chunk = templateChunks[z][sx / CHUNK_SIZE][sy / CHUNK_SIZE];
										if (chunk == -1 && !ctrlHeld)
											continue;
									}

									if (secondTry == 0) {
										var paint = tile.getSceneTilePaint();
										if ((paint == null || paint.getNeColor() == HIDDEN_HSL) && tile.getSceneTileModel() == null)
											continue;
									}

									if (mode == MODE_TILE_INFO || mode == MODE_MODEL_INFO) {
										if (!drawTileInfo(g, ctx, tile))
											continue;
									} else {
										if (altHeld) {
											g.setColor(Color.YELLOW);
										} else {
											g.setColor(Color.CYAN);
											if (isBridge == 1 && tile.getBridge() != null) {
												g.setColor(Color.MAGENTA);
												tile = tile.getBridge();
											}
										}
										var poly = getCanvasTilePoly(client, ctx, tile);
										if (poly == null || !poly.contains(mousePos[0], mousePos[1]))
											continue;
										g.drawPolygon(poly);
									}

									int tileZ = tile.getRenderLevel();
									hoveredWorldPoint = ctx.extendedSceneToWorld(x, y, tileZ);

									break tileLoop;
								}
							}
						}
					}
				}
			}
		}

		hoveredGamevalsHash = hoveredGamevals.hashCode();

		switch (mode) {
			case MODE_OBJECT_IDS:
				drawAllIds(g, ctx);
				break;
			case MODE_SCENE_AABBS:
				g.setFont(FontManager.getRunescapeSmallFont());

				drawLoadingLines(g);
				drawRegionBoxes(g, ctx);

				if (mousePos != null) {
					hoveredAreaAabb[0] = -1;
					hoveredAreaAabb[1] = 0;
					float[] v = new float[2];
					outer:
					for (int i = 0; i < visibleAreas.length; i++) {
						var area = visibleAreas[i];
						for (int j = 0; j < area.aabbs.length; j++) {
							if (i == selectedAreaAabb[0] && j == selectedAreaAabb[1])
								continue;

							var aabb = toLocalAabb(ctx, cropAabb(ctx, area.aabbs[j]));
							var p = getAabbCanvasCenter(aabb);
							if (p != null) {
								subtract(v, mousePos, p);
								if (dot(v) < 26 * 26) {
									hoveredAreaAabb[0] = i;
									hoveredAreaAabb[1] = j;
									break outer;
								}
							}
						}
					}
				}

				for (int i = 0; i < visibleAreas.length; i++) {
					var area = visibleAreas[i];
					if (area.name.equals("ALL"))
						continue;

					boolean areaHovered = i == hoveredAreaAabb[0];
					boolean areaSelected = i == selectedAreaAabb[0];
					for (int j = 0; j < area.aabbs.length; j++) {
						AABB aabb = area.aabbs[j];
						if (aabb == dummyAabb)
							continue;

						boolean hovered = areaHovered && j == hoveredAreaAabb[1];
						boolean selected = areaSelected && j == selectedAreaAabb[1];
						if (hovered || selected)
							continue;

						String label = aabb.toArgs();
						if (aabb.isVolume())
							label = area.name + "[" + j + "]\n" + label;
						if (ctx.currentArea != null && ctx.currentArea.name.equals(area.name))
							label = "CURRENT\n" + label;

						// Since we have a bunch of AABBs spanning all planes,
						// it would be a bit obnoxious to always render the full AABB
						AABB croppedAabb = cropAabb(ctx, aabb);
						var localAabb = toLocalAabb(ctx, croppedAabb);

						g.setColor(TRANSPARENT_WHITE_100);
						drawLocalAabb(g, localAabb);

						g.setColor(Color.LIGHT_GRAY);
						drawLocalAabbLabel(g, localAabb, label, false);
					}

					for (int j = 0; j < area.unhideAreas.length; j++) {
						AABB aabb = area.unhideAreas[j];
						String label = aabb.toArgs();
						if (aabb.isVolume())
							label = area.name + ".unhide[" + j + "]\n" + label;
						if (ctx.currentArea != null && ctx.currentArea.name.equals(area.name))
							label = "CURRENT\n" + label;

						var localAabb = toLocalAabb(ctx, cropAabb(ctx, aabb));
						g.setColor(Color.PINK);
						drawLocalAabb(g, localAabb);
						drawLocalAabbLabel(g, localAabb, label, false);
					}
				}

				if (hoveredAreaAabb[0] != -1) {
					var area = visibleAreas[hoveredAreaAabb[0]];
					var aabb = area.aabbs[hoveredAreaAabb[1]];
					g.setColor(Color.WHITE);

					var localAabb = toLocalAabb(ctx, aabb);
					drawLocalAabb(g, localAabb);
					drawLocalAabbLabel(g, localAabb, area.name + "[" + hoveredAreaAabb[1] + "]\n" + aabb.toArgs(), false);
				}

				if (selectedAreaAabb[0] != -1) {
					var area = visibleAreas[selectedAreaAabb[0]];
					var aabb = area.aabbs[selectedAreaAabb[1]];
					g.setColor(Color.CYAN);

					var localAabb = toLocalAabb(ctx, aabb);
					drawLocalAabb(g, localAabb);
					drawLocalAabbLabel(g, localAabb, area.name + "[" + selectedAreaAabb[1] + "]\n" + aabb.toArgs(), true);
				}

				break;
		}

		// Update second selection point each frame
		if (aabbMarkingStage == 1) {
			System.arraycopy(hoveredWorldPoint, 0, markedWorldPoints[1], 0, 3);
			if (selectionIncludeZ || markedWorldPoints[0][2] != markedWorldPoints[1][2]) {
				pendingSelection = new AABB(markedWorldPoints[0], markedWorldPoints[1]);
			} else {
				pendingSelection = new AABB(
					markedWorldPoints[0][0],
					markedWorldPoints[0][1],
					markedWorldPoints[1][0],
					markedWorldPoints[1][1]
				);
			}
		}

		for (int i = 0; i < selections.size(); i++) {
			var aabb = selections.get(i);
			var localAabb = toLocalAabb(ctx, aabb);
			// Draw selection boxes
			g.setColor(Color.YELLOW);
			drawLocalAabb(g, localAabb);
			g.setFont(FontManager.getRunescapeFont());
			drawLocalAabbLabel(g, localAabb, "Selection[" + i + "]\n" + aabb.toArgs(), true);
		}

		if (pendingSelection != null) {
			var localAabb = toLocalAabb(ctx, pendingSelection);
			// Draw current selection box
			g.setColor(Color.YELLOW);
			drawLocalAabb(g, localAabb);
			g.setFont(FontManager.getRunescapeFont());
			drawLocalAabbLabel(g, localAabb, "Selection[" + selections.size() + "]\n" + pendingSelection.toArgs(), true);
		}

		if (ctx.sceneBase == null) {
			g.setColor(Color.RED);
			g.setFont(FontManager.getRunescapeFont());
			var b = g.getClipBounds();
			var str = "This is a non-contiguous instance. AABBs may not work.";
			int w = g.getFontMetrics().stringWidth(str);
			g.drawString(str, (int) (b.x + b.getWidth() / 2 - w / 2.f), 16);
		}

		return null;
	}

	private boolean drawTileInfo(Graphics2D g, SceneContext ctx, Tile tile) {
		boolean infoDrawn = false;

		if (tile != null) {
			Rectangle rect = null;
			Polygon poly;

			Tile bridge = tile.getBridge();
			if (bridge != null) {
				poly = getCanvasTilePoly(client, ctx, bridge);
				if (poly != null && poly.contains(mousePos[0], mousePos[1])) {
					rect = drawTileInfo(g, ctx, bridge, poly, null);
					infoDrawn = true;
				}
			}

			poly = getCanvasTilePoly(client, ctx, tile);
			if (poly != null && poly.contains(mousePos[0], mousePos[1])) {
				drawTileInfo(g, ctx, tile, poly, rect);
				infoDrawn = true;
			}
		}

		return infoDrawn;
	}

	private Rectangle drawTileInfo(Graphics2D g, SceneContext ctx, Tile tile, Polygon poly, Rectangle dodgeRect)
	{
		SceneTilePaint tilePaint = tile.getSceneTilePaint();
		SceneTileModel tileModel = tile.getSceneTileModel();

		Scene scene = ctx.scene;
		int tileX = tile.getSceneLocation().getX();
		int tileY = tile.getSceneLocation().getY();
		int tileZ = tile.getRenderLevel();
		int tileExX = tileX + ctx.sceneOffset;
		int tileExY = tileY + ctx.sceneOffset;
		int[] worldPos = ctx.sceneToWorld(tileX, tileY, tileZ);

		ArrayList<String> lines = new ArrayList<>();

		Color polyColor = Color.LIGHT_GRAY;
		if (mode == MODE_TILE_INFO) {
			ctx.tileOverrideVars.get().setTile(tile);
			if (tile.getBridge() != null)
				lines.add("Bridge");

			lines.add("Zone: " + (tileExX / 8) + ", " + (tileExY / 8) + ", " + tileZ);
			lines.add("Scene point: " + tileX + ", " + tileY + ", " + tileZ);
			lines.add("World point: " + Arrays.toString(worldPos));
			lines.add(String.format(
				"Region ID: %d (%d, %d)",
				HDUtils.worldToRegionID(worldPos),
				worldPos[0] >> 6,
				worldPos[1] >> 6
			));

			for (var environment : ctx.environments) {
				if (environment.area.containsPoint(worldPos)) {
					lines.add("Environment: " + environment);
					break;
				}
			}

			int overlayId = scene.getOverlayIds()[tileZ][tileExX][tileExY];
			var overlay = tileOverrideManager.getOverrideBeforeReplacements(worldPos, OVERLAY_FLAG | overlayId);
			var replacementPath = new StringBuilder(overlay.toString());
			while (true) {
				var replacement = overlay.resolveNextReplacement(ctx.tileOverrideVars.get());
				if (replacement == overlay)
					break;
				replacementPath.append("\n\t ").append(replacement);
				overlay = replacement;
			}
			lines.add(String.format("Overlay: ID %d -> %s", overlayId, replacementPath));
			lines.add(String.format(
				"GroundMaterial: %s -> %s",
				overlay.groundMaterial,
				overlay.groundMaterial.getRandomMaterial(worldPos)
			));

			int underlayId = scene.getUnderlayIds()[tileZ][tileExX][tileExY];
			var underlay = tileOverrideManager.getOverrideBeforeReplacements(worldPos, underlayId);
			replacementPath = new StringBuilder(underlay.toString());
			while (true) {
				var replacement = underlay.resolveNextReplacement(ctx.tileOverrideVars.get());
				if (replacement == underlay)
					break;
				replacementPath.append("\n\t ").append(replacement);
				underlay = replacement;
			}
			lines.add(String.format("Underlay: ID %d -> %s", underlayId, replacementPath));
			lines.add(String.format(
				"GroundMaterial: %s -> %s",
				underlay.groundMaterial,
				underlay.groundMaterial.getRandomMaterial(worldPos)
			));

			if (tilePaint != null) {
				polyColor = client.isKeyPressed(KeyCode.KC_ALT) ? Color.YELLOW : Color.CYAN;
				lines.add("Tile type: Paint");
				Material material = materialManager.fromVanillaTexture(tilePaint.getTexture());
				lines.add(String.format("Material: %s (%d)", material.name, tilePaint.getTexture()));
				lines.add(String.format("HSL: %s", hslString(tile)));

				var override = tileOverrideManager.getOverride(ctx, tile, worldPos, OVERLAY_FLAG | overlayId, underlayId);
				lines.add("WaterType: " + proceduralGenerator.seasonalWaterType(override, tilePaint.getTexture()));
			} else if (tileModel != null) {
				polyColor = Color.ORANGE;
				lines.add("Tile type: Model");
				lines.add(String.format("Face count: %d", tileModel.getFaceX().length));

				HashSet<String> uniqueMaterials = new HashSet<>();
				int numChars = 0;
				if (tileModel.getTriangleTextureId() != null) {
					for (int texture : tileModel.getTriangleTextureId()) {
						String material = String.format("%s (%d)", materialManager.fromVanillaTexture(texture).name, texture);
						boolean unique = uniqueMaterials.add(material);
						if (unique) {
							numChars += material.length();
						}
					}
				}

				ArrayList<String> materials = new ArrayList<>(uniqueMaterials);
				Collections.sort(materials);

				if (materials.size() <= 1 || numChars < 26) {
					StringBuilder sb = new StringBuilder("Materials: { ");
					if (materials.isEmpty()) {
						sb.append("null");
					} else {
						String prefix = "";
						for (String m : materials) {
							sb.append(prefix).append(m);
							prefix = ", ";
						}
					}
					sb.append(" }");
					lines.add(sb.toString());
				} else {
					Iterator<String> iter = materials.iterator();
					lines.add("Materials: { " + iter.next() + ",");
					while (iter.hasNext()) {
						lines.add("\t  " + iter.next() + (iter.hasNext() ? "," : " }"));
					}
				}

				lines.add(String.format("HSL: %s", hslString(tile)));
			}

			ctx.tileOverrideVars.get().setTile(null); // Avoid accidentally keeping the old scene in memory
		}

		var decorObject = tile.getDecorativeObject();
		if (decorObject != null) {
			lines.add(String.format(
				"Decor Object: %s preori=%d ori=%d offset=[%d, %d] type=%s %s",
				getIdAndImpostorId(decorObject, decorObject.getRenderable()),
				HDUtils.getModelPreOrientation(decorObject.getConfig()),
				HDUtils.getModelOrientation(decorObject.getConfig()),
				decorObject.getXOffset(),
				decorObject.getYOffset(),
				ObjectType.fromConfig(decorObject.getConfig()),
				getModelInfo(decorObject.getRenderable())
			));
			lines.add("Decor Type: " + ObjectType.fromConfig(decorObject.getConfig()));
		}

		GroundObject groundObject = tile.getGroundObject();
		if (groundObject != null) {
			lines.add(String.format(
				"Ground Object: %s preori=%d ori=%d%s",
				getIdAndImpostorId(groundObject, groundObject.getRenderable()),
				HDUtils.getModelPreOrientation(groundObject.getConfig()),
				HDUtils.getModelOrientation(groundObject.getConfig()),
				getModelInfo(groundObject.getRenderable())
			));
			lines.add("Ground Type: " + ObjectType.fromConfig(groundObject.getConfig()));
		}

		WallObject wallObject = tile.getWallObject();
		if (wallObject != null) {
			if (wallObject.getRenderable1() != null) {
				lines.add(String.format(
					"Wall Object 1: %s bakedOri=%d ori=%d wallori=%d%s",
					getIdAndImpostorId(wallObject, wallObject.getRenderable1()),
					HDUtils.getModelPreOrientation(wallObject.getConfig()),
					HDUtils.getModelOrientation(wallObject.getConfig()),
					wallObject.getOrientationA(),
					getModelInfo(wallObject.getRenderable1())
				));
			}
			if (wallObject.getRenderable2() != null) {
				lines.add(String.format(
					"Wall Object 2: %s bakedOri=%d ori=%d wallori=%d%s",
					getIdAndImpostorId(wallObject, wallObject.getRenderable2()),
					HDUtils.getModelPreOrientation(wallObject.getConfig()),
					HDUtils.getModelOrientation(wallObject.getConfig()),
					wallObject.getOrientationB(),
					getModelInfo(wallObject.getRenderable2())
				));
			}
			lines.add("Wall Type: " + ObjectType.fromConfig(wallObject.getConfig()));
		}

		GameObject[] gameObjects = tile.getGameObjects();
		for (GameObject gameObject : gameObjects) {
			if (gameObject == null)
				continue;
			int height = -1;
			int animationId = -1;
			int faceCount = 0;
			String id = "";
			var renderable = gameObject.getRenderable();
			if (renderable != null) {
				Model model = renderable instanceof Model ? (Model) renderable : renderable.getModel();
				if (model != null)
					faceCount = model.getFaceCount();

				if (renderable instanceof NPC)
					continue;

				height = renderable.getModelHeight();

				if (renderable instanceof Player) {
					id = "name=" + ((Player) renderable).getName();
				} else {
					id = getIdAndImpostorId(gameObject, renderable);
					if (renderable instanceof DynamicObject) {
						var anim = ((DynamicObject) renderable).getAnimation();
						if (anim != null)
							animationId = anim.getId();
					}
				}
				id += " ";
			}

			lines.add(String.format(
				"%s: %spreori=%d ori=%d objori=%d height=%d anim=%d faces=%d%s",
				ModelHash.getTypeName(ModelHash.getType(gameObject.getHash())),
				id,
				HDUtils.getModelPreOrientation(gameObject.getConfig()),
				HDUtils.getModelOrientation(gameObject.getConfig()),
				gameObject.getModelOrientation(),
				height,
				animationId,
				faceCount,
				getModelInfo(renderable)
			));
			lines.add("Object Type: " + ObjectType.fromConfig(gameObject.getConfig()));
		}

		for (var npc : client.getTopLevelWorldView().npcs()) {
			var lp = npc.getLocalLocation();
			int size = npc.getComposition().getSize() / 2;
			int x = lp.getSceneX();
			int y = lp.getSceneY();
			if (x - size <= tileX && tileX <= x + size && y - size <= tileY && tileY <= y + size) {
				var name = gamevalManager.getNpcName(npc.getId());
				hoveredGamevals.add(name);
				lines.add(String.format(
					"NPC: %s (%d) name=%s ori=[%d,%d] anim=%d impostor=?%s",
					name,
					npc.getId(),
					npc.getName(),
					npc.getOrientation(),
					npc.getCurrentOrientation(),
					npc.getAnimation(),
					getModelInfo(npc)
				));
			}
		}

		for (GraphicsObject graphicsObject : client.getGraphicsObjects()) {
			var lp = graphicsObject.getLocation();
			if (lp.getSceneX() == tileX && lp.getSceneY() == tileY) {
				var name = gamevalManager.getSpotanimName(graphicsObject.getId());
				hoveredGamevals.add(name);
				lines.add(String.format(
					"Graphics Object: %s (%d)%s",
					name,
					graphicsObject.getId(),
					getModelInfo(graphicsObject)
				));
			}
		}

		if (tile.getBridge() != null)
			polyColor = Color.MAGENTA;
		g.setColor(polyColor);
		g.drawPolygon(poly);

		if (lines.isEmpty())
			return null;

		for (int i = 0; i < lines.size(); i++) {
			var moreLines = lines.get(i).split("\\n");
			if (moreLines.length > 1) {
				//noinspection SuspiciousListRemoveInLoop
				lines.remove(i);
				lines.addAll(i, List.of(moreLines));
			}
		}

		int padding = 4;
		int xPadding = padding * 2;
		FontMetrics fm = g.getFontMetrics();
		int lineHeight = fm.getHeight();
		int totalHeight = lineHeight * lines.size() + padding * 3;
		int space = fm.stringWidth(": ");
		int indent = fm.stringWidth("{ ");

		int leftWidth = 0;
		int rightWidth = 0;

		Function<String, Pair<String, String>> splitter = line ->
		{
			int i = line.indexOf(":");
			String left = line;
			String right = "";
			if (left.startsWith("\t"))
			{
				right = left;
				left = "";
			} else if (i != -1)
			{
				left = line.substring(0, i);
				right = line.substring(i + 1);
			}

			return Pair.of(left, right);
		};

		Font f = g.getFont();
		for (String line : lines)
		{
			Pair<String, String> pair = splitter.apply(line);
			if (pair.getRight().isEmpty())
			{
				int halfWidth = fm.stringWidth(Text.removeTags(pair.getLeft())) / 2;
				leftWidth = max(leftWidth, halfWidth);
				rightWidth = max(rightWidth, halfWidth);
			}
			else
			{
				leftWidth = max(leftWidth, fm.stringWidth(Text.removeTags(pair.getLeft())));
				var rfm = fm;
				if (pair.getRight().contains("<tt>"))
					rfm = g.getFontMetrics(MONOSPACE_FONT);
				rightWidth = max(rightWidth, rfm.stringWidth(Text.removeTags(pair.getRight())));
			}
		}

		Rectangle2D polyBounds = poly.getBounds2D();
		float centerX = (float) polyBounds.getCenterX();
		float centerY = (float) (polyBounds.getCenterY() - polyBounds.getHeight() / 2.f);

		var bounds = g.getClipBounds();

		int totalWidth = leftWidth + rightWidth + space + xPadding * 2;
		Rectangle rect = new Rectangle(
			(int) clamp(centerX - totalWidth / 2.f, bounds.x, bounds.x + bounds.width - totalWidth),
			(int) clamp(centerY - totalHeight - padding, bounds.y + 16, bounds.y + bounds.height - totalHeight),
			totalWidth,
			totalHeight
		);
		if (dodgeRect != null && dodgeRect.intersects(rect))
		{
			// Avoid overlapping with other tile info
			rect.y = dodgeRect.y - rect.height - padding;
		}

		g.setColor(BACKDROP_COLOR);
		g.fillRect(rect.x, rect.y, rect.width, rect.height);

		g.setColor(Color.WHITE);

		int offsetY = 0;
		for (String line : lines)
		{
			boolean dropShadow = true;

			Pair<String, String> pair = splitter.apply(line);
			offsetY += lineHeight;
			float x, y;
			if (pair.getRight().isEmpty())
			{
				// centered
				x = rect.x + rect.width / 2.f - fm.stringWidth(pair.getLeft()) / 2.f;
				y = rect.y + padding + offsetY;
			}
			else
			{
				boolean indented = pair.getRight().startsWith("\t");
				if (pair.getRight().contains("<tt>")) {
					g.setFont(MONOSPACE_FONT);
					dropShadow = false;
				}

				// left & right
				x = rect.x + xPadding + leftWidth - fm.stringWidth(pair.getLeft()) + (indented ? indent : 0);
				y = rect.y + padding + offsetY;
			}

			drawString(g, line, (int) x, (int) y, dropShadow);

			g.setFont(f);
		}

		return rect;
	}

	private String getIdAndImpostorId(TileObject object, @Nullable Renderable renderable) {
		int id = object.getId();
		int impostorId = getIdOrImpostorId(object, renderable);
		String name = gamevalManager.getObjectName(id);
		if (id == impostorId) {
			hoveredGamevals.add(name);
			return String.format("%s (%d)", name, id);
		}

		String impostorName = gamevalManager.getObjectName(impostorId);
		hoveredGamevals.add(impostorName);
		return String.format("%s (%d) -> %s (%d)", name, id, impostorName, impostorId);
	}

	private int getIdOrImpostorId(TileObject object, @Nullable Renderable renderable) {
		return ModelHash.getUuidId(ModelHash.generateUuid(client, object.getHash(), renderable));
	}

	private String getModelInfo(Renderable renderable) {
		if (renderable == null)
			return " null renderable";

		Model model = renderable instanceof Model ? (Model) renderable : renderable.getModel();
		if (model == null)
			return " null model";

		switch (mode) {
			case MODE_TILE_INFO:
				return
					"  " + (
						renderable instanceof Model ? "<col=#00ff00>static</col>" :
						(renderable instanceof DynamicObject || renderable instanceof Actor) ?
							"<col=#ff0000>dynamic</col>" : "<col=#ffff00>maybe dynamic</col>"
					);
			case MODE_MODEL_INFO:
				int[] faceColors = model.getFaceColors1();
				byte[] faceTransparencies = model.getFaceTransparencies();
				int[] faceAhsl = new int[model.getFaceCount()];
				for (int i = 0; i < faceAhsl.length; i++)
					faceAhsl[i] = (faceTransparencies == null ? 0xFF : 0xFF - (faceTransparencies[i] & 0xFF)) << 16 | faceColors[i];
				var colors = Arrays.stream(faceAhsl)
					.distinct()
					.sorted()
					.mapToObj(ahsl -> {
						var hsl = ColorUtils.unpackRawHsl(ahsl);
						var alpha = ahsl >> 16;
						return String.format(
							"<col=%s>%5d [%3d %2d %1d %3d]</col>",
							String.format("#%08x", ColorUtils.packSrgb(ColorUtils.packedHslToSrgb(ahsl)) << 8 | alpha),
							ahsl & 0xFFFF, alpha, hsl[0], hsl[1], hsl[2]
						);
					})
					.toArray(String[]::new);

				int columns = clamp(round(sqrt(colors.length / 5f)), 3, 8);
				int rows = ceil(colors.length / (float) columns);

				StringBuilder str = new StringBuilder("\nFace colors: ").append(colors.length);
				for (int i = 0; i < rows; i++) {
					str.append("\n\t<tt>");
					for (int j = 0; j < columns; j++) {
						int idx = i * columns + j;
						if (idx < colors.length)
							str.append(colors[idx]);
					}
				}

				if (model.getFaceTextures() != null) {
					var textureIds = new HashSet<Integer>();
					for (int textureId : model.getFaceTextures())
						textureIds.add(textureId);
					textureIds.remove(-1);
					if (!textureIds.isEmpty()) {
						str.append("\nTexture IDs: [ ");
						String prefix = "";
						for (int id : textureIds) {
							str.append(prefix).append(id);
							prefix = ", ";
						}
						str.append("]");
					}
				}

				return str.toString();
		}

		return "";
	}

	public Polygon getCanvasTilePoly(@Nonnull Client client, SceneContext ctx, Tile tile) {
		if (tile == null)
			return null;
		var l = tile.getSceneLocation();
		return getCanvasTilePoly(client, ctx, l.getX(), l.getY(), tile.getPlane());
	}

	public Polygon getCanvasTilePoly(@Nonnull Client client, SceneContext ctx, int... sceneXYplane) {
		final int wx = sceneXYplane[0] * LOCAL_TILE_SIZE;
		final int sy = sceneXYplane[1] * LOCAL_TILE_SIZE;
		final int ex = (sceneXYplane[0] + 1) * LOCAL_TILE_SIZE;
		final int ny = (sceneXYplane[1] + 1) * LOCAL_TILE_SIZE;

		final int sw = getHeight(ctx, wx, sy, sceneXYplane[2]);
		final int se = getHeight(ctx, ex, sy, sceneXYplane[2]);
		final int ne = getHeight(ctx, ex, ny, sceneXYplane[2]);
		final int nw = getHeight(ctx, wx, ny, sceneXYplane[2]);

		float[] p1 = localToCanvas(client, wx, sy, sw);
		float[] p2 = localToCanvas(client, ex, sy, se);
		float[] p3 = localToCanvas(client, ex, ny, ne);
		float[] p4 = localToCanvas(client, wx, ny, nw);
		if (p1 == null || p2 == null || p3 == null || p4 == null)
			return null;

		Polygon poly = new Polygon();
		poly.addPoint((int) p1[0], (int) p1[1]);
		poly.addPoint((int) p2[0], (int) p2[1]);
		poly.addPoint((int) p3[0], (int) p3[1]);
		poly.addPoint((int) p4[0], (int) p4[1]);

		return poly;
	}

	private static int getHeight(SceneContext ctx, int localX, int localY, int plane) {
		int sceneExX = clamp((localX >> LOCAL_COORD_BITS) + ctx.sceneOffset, 0, EXTENDED_SCENE_SIZE - 1);
		int sceneExY = clamp((localY >> LOCAL_COORD_BITS) + ctx.sceneOffset, 0, EXTENDED_SCENE_SIZE - 1);

		int[][][] tileHeights = ctx.scene.getTileHeights();
		int x = localX & (LOCAL_TILE_SIZE - 1);
		int y = localY & (LOCAL_TILE_SIZE - 1);
		int var8 = x * tileHeights[plane][sceneExX + 1][sceneExY] +
				   (LOCAL_TILE_SIZE - x) * tileHeights[plane][sceneExX][sceneExY] >> LOCAL_COORD_BITS;
		int var9 = x * tileHeights[plane][sceneExX + 1][sceneExY + 1] +
				   (LOCAL_TILE_SIZE - x) * tileHeights[plane][sceneExX][sceneExY + 1] >> LOCAL_COORD_BITS;
		return y * var9 + (LOCAL_TILE_SIZE - y) * var8 >> 7;
	}

	private float[] localToCanvas(@Nonnull Client client, int x, int y, int z) {
		// Using floats to support coordinates much larger than normal local coordinates
		x -= client.getCameraX();
		y -= client.getCameraY();
		z -= client.getCameraZ();
		int cameraPitch = client.getCameraPitch();
		int cameraYaw = client.getCameraYaw();
		float pitchSin = sin(cameraPitch * JAU_TO_RAD);
		float pitchCos = cos(cameraPitch * JAU_TO_RAD);
		float yawSin = sin(cameraYaw * JAU_TO_RAD);
		float yawCos = cos(cameraYaw * JAU_TO_RAD);
		float x1 = x * yawCos + y * yawSin;
		float y1 = y * yawCos - x * yawSin;
		float y2 = z * pitchCos - y1 * pitchSin;
		float z1 = y1 * pitchCos + z * pitchSin;
		if (z1 >= 1) {
			float scale = client.getScale();
			float screenX = x1 * scale;
			float screenY = y2 * scale;
			if (plugin.orthographicProjection) {
				screenX *= ORTHOGRAPHIC_ZOOM;
				screenY *= ORTHOGRAPHIC_ZOOM;
			} else {
				screenX /= z1;
				screenY /= z1;
			}

			screenX += client.getViewportWidth() / 2.f;
			screenY += client.getViewportHeight() / 2.f;

			return new float[] {
				(screenX + client.getViewportXOffset()),
				(screenY + client.getViewportYOffset()),
				min(Integer.MAX_VALUE, z1)
			};
		}

		return null;
	}

	private static String hslString(Tile tile) {
		int[] hsl = new int[3];
		int rawHsl = HDUtils.getSouthWesternMostTileColor(hsl, tile);
		if (rawHsl == HIDDEN_HSL)
			return "HIDDEN";
		return rawHsl + " " + Arrays.toString(hsl);
	}

	private void drawAllIds(Graphics2D g, SceneContext ctx) {
		g.setFont(FontManager.getRunescapeSmallFont());
		g.setColor(new Color(255, 255, 255, 127));

		Tile[][][] tiles = ctx.scene.getExtendedTiles();
		int plane = ctrlHeld ? MAX_Z - 1 : client.getPlane();
		for (int z = plane; z >= 0; z--) {
			for (int x = 0; x < EXTENDED_SCENE_SIZE; x++) {
				for (int y = 0; y < EXTENDED_SCENE_SIZE; y++) {
					Tile tile = tiles[z][x][y];
					if (tile == null)
						continue;

					var lp = tile.getLocalLocation();
					int lines = 0;
					for (int isBridge = 1; isBridge >= 0; isBridge--) {
						var t = tile;
						if (isBridge == 1) {
							t = tile.getBridge();
							if (t == null)
								continue;
						}

						GroundObject groundObject = t.getGroundObject();
						if (groundObject != null)
							drawTileObjectInfo(g, lp, groundObject, groundObject.getRenderable(), lines++);

						WallObject wallObject = t.getWallObject();
						if (wallObject != null)
							drawTileObjectInfo(g, lp, wallObject, wallObject.getRenderable1(), lines++);

						for (GameObject gameObject : t.getGameObjects())
							if (gameObject != null)
								drawTileObjectInfo(g, lp, gameObject, gameObject.getRenderable(), lines++);
					}
				}
			}
		}
	}

	private void drawTileObjectInfo(Graphics2D g, LocalPoint lp, TileObject object, Renderable renderable, int line) {
		int type = ModelHash.getType(object.getHash());
		String str;
		if (zoom > 1.2f) {
			str = ModelHash.getTypeName(type) + ": " + getIdAndImpostorId(object, renderable);
		} else {
			str = ModelHash.getTypeNameShort(type) + ": " + getIdOrImpostorId(object, renderable);
		}
		var p = localToCanvas(client, lp.getX(), lp.getY(),
			Perspective.getTileHeight(client, lp, object.getPlane())
		);
		if (p == null)
			return;

		var fm = g.getFontMetrics();
		int w = fm.stringWidth(str);

		drawString(g, str, (int) (p[0] - w / 2.f), (int) (p[1] + line * fm.getHeight()), true);
	}

	private void drawString(Graphics2D g2d, String str, int x, int y, boolean dropShadow) {
		Color origColor = g2d.getColor();

		setAntiAliasing(g2d, false);

		String stripped = Text.removeTags(str);
		if (dropShadow) {
			g2d.setColor(Color.BLACK);
			g2d.drawString(stripped, x + 1, y + 1);
			g2d.setColor(origColor);
		}

		if (!str.contains("<col=")) {
			g2d.drawString(stripped, x, y);
			return;
		}

		var fm = g2d.getFontMetrics();
		final Pattern pattern = Pattern.compile("<col=#?([a-fA-F0-9]{3,8})>(.*?)</col>");
		var m = pattern.matcher(str);
		int end = 0;
		while (m.find()) {
			if (end < m.start()) {
				var s = Text.removeTags(str.substring(end, m.start()));
				g2d.setColor(origColor);
				g2d.drawString(s, x, y);
				x += fm.stringWidth(s);
			}
			end = m.end();

			var hex = m.group(1);
			int i = (int) Long.parseLong(hex, 16);
			int r, g, b, a = 0xFF;
			if (hex.length() == 3) {
				r = (i >>> 8) * 2;
				g = (i >>> 4 & 0xF) * 2;
				b = (i & 0xF) * 2;
			} else if (hex.length() == 6) {
				r = i >>> 16;
				g = i >>> 8 & 0xFF;
				b = i & 0xFF;
			} else if (hex.length() == 8) {
				r = i >>> 24;
				g = i >>> 16 & 0xFF;
				b = i >>> 8 & 0xFF;
				a = i & 0xFF;
			} else {
				g2d.drawString(m.group(0), x, y);
				x += fm.stringWidth(m.group(0));
				continue;
			}

			var withBrackets = m.group(2);
			var withoutBrackets = withBrackets.replaceAll("[\\[\\]]", " ");
			var onlyBrackets = withBrackets.replaceAll("[^\\[\\]]", " ");

			var c = new Color(r, g, b, a);
			g2d.setColor(c);
			int w = fm.stringWidth(withoutBrackets);
			int h = fm.getHeight();
			g2d.fillRect(x - 2, y - fm.getAscent() + fm.getLeading() - 2, w + 4, h + 2);
			g2d.setColor(getContrastColor(c));
			g2d.drawString(withoutBrackets, x, y);
			g2d.drawString(onlyBrackets, x, y - 1);

			x += fm.stringWidth(withoutBrackets);
		}

		g2d.setColor(origColor);
		if (end < str.length())
			g2d.drawString(str.substring(end), x, y);
	}

	private Color getContrastColor(Color color) {
		double y = (299. * color.getRed() + 587 * color.getGreen() + 114 * color.getBlue()) / 1000;
		return y >= 128 ? Color.black : Color.white;
	}

	/**
	 * Draw line given local scene coordinates
	 */
	private void drawLine(Graphics2D g, int x1, int y1, int z1, int x2, int y2, int z2) {
		// Using floats to support coordinates much larger than normal local coordinates
		float yawSin = sin(plugin.cameraOrientation[0]);
		float yawCos = cos(plugin.cameraOrientation[0]);
		float pitchSin = sin(plugin.cameraOrientation[1]);
		float pitchCos = cos(plugin.cameraOrientation[1]);

		x1 -= client.getCameraX();
		y1 -= client.getCameraY();
		z1 -= client.getCameraZ();
		x2 -= client.getCameraX();
		y2 -= client.getCameraY();
		z2 -= client.getCameraZ();

		float ax = x1 * yawCos + y1 * yawSin;
		float aUnpitchedZ = y1 * yawCos - x1 * yawSin;
		float ay = z1 * pitchCos - aUnpitchedZ * pitchSin;
		float az = aUnpitchedZ * pitchCos + z1 * pitchSin;

		float bx = x2 * yawCos + y2 * yawSin;
		float bUnpitchedZ = y2 * yawCos - x2 * yawSin;
		float by = z2 * pitchCos - bUnpitchedZ * pitchSin;
		float bz = bUnpitchedZ * pitchCos + z2 * pitchSin;

		if (!plugin.orthographicProjection) {
			// Project points which lie behind the camera onto the
			// near plane, so lines can still be drawn accurately

			// Both behind the near plane
			if (az < 1 && bz < 1)
				return;

			float vx = bx - ax;
			float vy = by - ay;
			float vz = bz - az;

			if (az < 1) {
				// A is behind the near plane
				// az + (bz - az) * t = 1
				// t = (1 - az) / (bz - az)
				double t = (1.f - az) / vz;
				ax += (float) (vx * t);
				ay += (float) (vy * t);
				az = 1;
			} else if (bz < 1) {
				// B is behind the near plane
				double t = (1.f - bz) / vz;
				bx += (float) (vx * t);
				by += (float) (vy * t);
				bz = 1;
			}
		}

		if (plugin.orthographicProjection) {
			ax *= ORTHOGRAPHIC_ZOOM;
			ay *= ORTHOGRAPHIC_ZOOM;
			bx *= ORTHOGRAPHIC_ZOOM;
			by *= ORTHOGRAPHIC_ZOOM;
		} else {
			ax /= az;
			ay /= az;
			bx /= bz;
			by /= bz;
		}

		int scale = client.getScale();
		ax *= scale;
		ay *= scale;
		bx *= scale;
		by *= scale;

		int w = client.getViewportWidth();
		int h = client.getViewportHeight();

		float offsetX = client.getViewportXOffset() + w / 2.f;
		float offsetY = client.getViewportYOffset() + h / 2.f;
		ax += offsetX;
		ay += offsetY;
		bx += offsetX;
		by += offsetY;

		float vx = bx - ax;
		float vy = by - ay;

		// a + v * t = edge
		// t = (edge - a) / v
		if (ax < 0) {
			ay += -ax / vx * vy;
			ax = 0;
		} else if (ax > w) {
			ay += (w - ax) / vx * vy;
			ax = w;
		}
		if (ay < 0) {
			ax += -ay / vy * vx;
			ay = 0;
		} else if (ay > h) {
			ax += (h - ay) / vy * vx;
			ay = h;
		}

		if (bx < 0) {
			by += -bx / vx * vy;
			bx = 0;
		} else if (bx > w) {
			by += (w - bx) / vx * vy;
			bx = w;
		}
		if (by < 0) {
			bx += -by / vy * vx;
			by = 0;
		} else if (by > h) {
			bx += (h - by) / vy * vx;
			by = h;
		}

		int fromX = round(ax);
		int fromY = round(ay);
		int toX = round(bx);
		int toY = round(by);

		if (fromX == toX && fromY == toY)
			return;

		g.drawLine(fromX, fromY, toX, toY);
	}

	private void setAntiAliasing(Graphics2D g, boolean state) {
		g.setRenderingHint(
			RenderingHints.KEY_TEXT_ANTIALIASING,
			state ? RenderingHints.VALUE_TEXT_ANTIALIAS_ON : RenderingHints.VALUE_TEXT_ANTIALIAS_OFF
		);
	}

	private AABB toLocalAabb(SceneContext ctx, AABB aabb) {
		return toLocalAabb(ctx, aabb, 1);
	}

	private AABB toLocalAabb(SceneContext ctx, AABB aabb, float scale) {
		int x1 = (aabb.minX - sceneBase[0]) * LOCAL_TILE_SIZE;
		int y1 = (aabb.minY - sceneBase[1]) * LOCAL_TILE_SIZE;
		int x2 = (aabb.maxX + 1 - sceneBase[0]) * LOCAL_TILE_SIZE;
		int y2 = (aabb.maxY + 1 - sceneBase[1]) * LOCAL_TILE_SIZE;

		int minZ = 0, maxZ = MAX_Z;
		if (aabb.hasZ()) {
			minZ = clamp(aabb.minZ, 0, MAX_Z);
			maxZ = clamp(aabb.maxZ, 0, MAX_Z) + 1;
		}
		int z1 = Integer.MAX_VALUE;
		int z2 = Integer.MIN_VALUE;

		for (int i = minZ; i < maxZ; i++) {
			int sw = getHeight(ctx, x1, y1, i);
			int nw = getHeight(ctx, x1, y2, i);
			int ne = getHeight(ctx, x2, y2, i);
			int se = getHeight(ctx, x2, y1, i);
			if (sw != -1) {
				z1 = min(z1, sw);
				z2 = max(z2, sw);
			}
			if (nw != -1) {
				z1 = min(z1, nw);
				z2 = max(z2, nw);
			}
			if (ne != -1) {
				z1 = min(z1, ne);
				z2 = max(z2, ne);
			}
			if (se != -1) {
				z1 = min(z1, se);
				z2 = max(z2, se);
			}
		}

		if (scale == 1)
			return new AABB(x1, y1, z1, x2, y2, z2);

		float cx = (x1 + x2) / 2.f;
		float cy = (y1 + y2) / 2.f;
		float cz = (z1 + z2) / 2.f;
		int sx = (int) ((x2 - x1) / 2.f);
		int sy = (int) ((y2 - y1) / 2.f);
		int sz = (int) ((z2 - z1) / 2.f);

		return new AABB(
			round(cx - sx * scale),
			round(cy - sy * scale),
			round(cz - sz * scale),
			round(cx + sx * scale),
			round(cy + sy * scale),
			round(cz + sz * scale)
		);
	}

	private AABB cropAabb(SceneContext ctx, AABB aabb) {
		if (aabb.isPoint()) {
			int sceneExX = aabb.minX - (sceneBase[0] - ctx.sceneOffset);
			int sceneExY = aabb.minY - (sceneBase[1] - ctx.sceneOffset);
			if (sceneExX >= 0 && sceneExY >= 0 && sceneExX < EXTENDED_SCENE_SIZE && sceneExY < EXTENDED_SCENE_SIZE) {
				int minZ = MAX_Z - 1;
				int maxZ = 0;
				int filled = ctx.filledTiles[sceneExX][sceneExY];
				for (int plane = 0; plane < MAX_Z; plane++) {
					if ((filled & (1 << plane)) != 0) {
						minZ = min(minZ, plane);
						maxZ = max(maxZ, plane);
					}
				}
				return new AABB(aabb.minX, aabb.minY, minZ, aabb.minX, aabb.minY, maxZ);
			}
		}

		return aabb;
	}

	private void drawLocalAabb(Graphics2D g, AABB aabb) {
		setAntiAliasing(g, true);

		// Draw bottom rect
		drawLine(g, aabb.minX, aabb.minY, aabb.minZ, aabb.minX, aabb.maxY, aabb.minZ);
		drawLine(g, aabb.minX, aabb.maxY, aabb.minZ, aabb.maxX, aabb.maxY, aabb.minZ);
		drawLine(g, aabb.maxX, aabb.maxY, aabb.minZ, aabb.maxX, aabb.minY, aabb.minZ);
		drawLine(g, aabb.maxX, aabb.minY, aabb.minZ, aabb.minX, aabb.minY, aabb.minZ);

		if (aabb.minZ != aabb.maxZ) {
			// Draw top rect
			drawLine(g, aabb.minX, aabb.minY, aabb.maxZ, aabb.minX, aabb.maxY, aabb.maxZ);
			drawLine(g, aabb.minX, aabb.maxY, aabb.maxZ, aabb.maxX, aabb.maxY, aabb.maxZ);
			drawLine(g, aabb.maxX, aabb.maxY, aabb.maxZ, aabb.maxX, aabb.minY, aabb.maxZ);
			drawLine(g, aabb.maxX, aabb.minY, aabb.maxZ, aabb.minX, aabb.minY, aabb.maxZ);

			// Connect corners
			drawLine(g, aabb.minX, aabb.minY, aabb.minZ, aabb.minX, aabb.minY, aabb.maxZ);
			drawLine(g, aabb.minX, aabb.maxY, aabb.minZ, aabb.minX, aabb.maxY, aabb.maxZ);
			drawLine(g, aabb.maxX, aabb.maxY, aabb.minZ, aabb.maxX, aabb.maxY, aabb.maxZ);
			drawLine(g, aabb.maxX, aabb.minY, aabb.minZ, aabb.maxX, aabb.minY, aabb.maxZ);
		}
	}

	private float[] getAabbCanvasCenter(AABB aabb) {
		float[] c = aabb.getCenter();
		return localToCanvas(client, (int) c[0], (int) c[1], (int) c[2]);
	}

	private void drawLocalAabbLabel(Graphics2D g, AABB aabb, String text, boolean backdrop) {
		var p = getAabbCanvasCenter(aabb);
		if (p == null)
			return;

		String[] lines = text.split("\\n");

		Color c = g.getColor();

		FontMetrics fm = g.getFontMetrics();
		int lineHeight = fm.getHeight();
		int totalHeight = lineHeight * lines.length;

		if (backdrop) {
			int totalWidth = 0;
			for (String line : lines)
				totalWidth = max(totalWidth, fm.stringWidth(line));

			g.setColor(BACKDROP_COLOR);
			int pad = 4;
			g.fillRect(
				(int) (p[0] - totalWidth / 2.f - pad),
				(int) (p[1] - totalHeight / 2.f - lineHeight / 2.f - pad),
				totalWidth + pad * 2,
				totalHeight + pad * 2
			);
		}

		for (int i = 0; i < lines.length; i++) {
			String line = lines[i];
			int width = fm.stringWidth(line);
			int px = (int) (p[0] - width / 2.f);
			int py = (int) (p[1] - totalHeight / 2.f + lineHeight * i + lineHeight / 2.f);
			g.setColor(Color.BLACK);
			g.drawString(line, px + 1, py + 1);
			g.setColor(c);
			g.drawString(line, px, py);
		}
	}

	private void drawLoadingLines(Graphics2D g) {
		g.setColor(Color.BLUE);
		int min = 16 * LOCAL_TILE_SIZE;
		int max = (SCENE_SIZE - 16) * LOCAL_TILE_SIZE;
		var localAabb = new AABB(min, min, max, max, 0);
		drawLocalAabb(g, localAabb);
	}

	private void drawRegionBoxes(Graphics2D g, SceneContext ctx) {
		if (ctx.sceneBase == null)
			return;
		int regionSize = CHUNK_SIZE * 8;

		for (int x = 0; x < EXTENDED_SCENE_SIZE; x += regionSize) {
			for (int y = 0; y < EXTENDED_SCENE_SIZE; y += regionSize) {
				int regionX = (ctx.sceneBase[0] + x) / regionSize;
				int regionY = (ctx.sceneBase[1] + y) / regionSize;
				int regionId = regionX << 8 | regionY;
				int worldX = regionX * regionSize;
				int worldY = regionY * regionSize;
				var aabb = new AABB(
					worldX,
					worldY,
					worldX + regionSize - 1,
					worldY + regionSize - 1,
					ctx.sceneBase[2] + client.getPlane()
				);
				var localAabb = toLocalAabb(ctx, aabb, .996f);
				g.setColor(TRANSPARENT_YELLOW_50);
				drawLocalAabb(g, localAabb);
				g.setColor(TRANSPARENT_YELLOW_100);
				drawLocalAabbLabel(g, localAabb, "Region ID\n" + regionId, false);
			}
		}
	}

	private void copyToClipboard(String toCopy) {
		copyToClipboard(toCopy, null);
	}

	private void copyToClipboard(String toCopy, @Nullable String description) {
		Clipboard clipboard = Toolkit.getDefaultToolkit().getSystemClipboard();
		StringSelection string = new StringSelection(toCopy);
		clipboard.setContents(string, null);
		clientThread.invoke(() -> client.addChatMessage(
			ChatMessageType.GAMEMESSAGE,
			"117 HD",
			"<col=006600>[117 HD] " + (
				description == null ?
					"Copied to clipboard: " + toCopy :
					description
			),
			"117 HD"
		));
	}

	@Override
	public MouseEvent mouseClicked(MouseEvent e) {
		return e;
	}

	@Override
	public synchronized MouseEvent mousePressed(MouseEvent e) {
		var sceneContext = plugin.getSceneContext();
		if (sceneContext == null)
			return e;

		if (e.isAltDown()) {
			e.consume();

			if (SwingUtilities.isLeftMouseButton(e)) {
				if (!Arrays.equals(selectedAreaAabb, hoveredAreaAabb)) {
					if (TileInfoOverlay.this.hoveredAreaAabb[0] != -1)
						copyToClipboard(visibleAreas[TileInfoOverlay.this.hoveredAreaAabb[0]]
							.aabbs[TileInfoOverlay.this.hoveredAreaAabb[1]]
							.toArgs());

					copyTo(selectedAreaAabb, hoveredAreaAabb);
					return e;
				}

				if (aabbMarkingStage == 0) {
					// Marking first
					System.arraycopy(hoveredWorldPoint, 0, markedWorldPoints[0], 0, 3);
				} else {
					// Done marking
					selections.add(pendingSelection);

					if (selections.size() == 1) {
						copyToClipboard(pendingSelection.toArgs());
					} else {
						StringBuilder sb = new StringBuilder();
						for (int i = 0; i < selections.size(); i++) {
							if (i > 0)
								sb.append(",\n");
							sb.append(selections.get(i).toArgs());
						}
						copyToClipboard(sb.toString(), "Copied " + selections.size() + " AABBs to clipboard");
					}

					pendingSelection = null;
				}
				aabbMarkingStage = (aabbMarkingStage + 1) % 2;
			} else if (SwingUtilities.isRightMouseButton(e)) {
				// Reset selection
				aabbMarkingStage = 0;
				selections.clear();
				pendingSelection = null;
			}
		} else if (SwingUtilities.isRightMouseButton(e)) {
			if (!hoveredGamevals.isEmpty()) {
				if (copiedGamevalsHash != hoveredGamevalsHash) {
					copiedGamevalsHash = hoveredGamevalsHash;
					hoveredGamevalsIndex = 0;
				}
				copyToClipboard('"' + hoveredGamevals.get(hoveredGamevalsIndex) + '"');
				hoveredGamevalsIndex = (hoveredGamevalsIndex + 1) % hoveredGamevals.size();
			}
		}

		return e;
	}

	@Override
	public MouseEvent mouseReleased(MouseEvent e) {
		return e;
	}

	@Override
	public MouseEvent mouseEntered(MouseEvent e) {
		return e;
	}

	@Override
	public MouseEvent mouseExited(MouseEvent e) {
		return e;
	}

	@Override
	public MouseEvent mouseDragged(MouseEvent e) {
		return e;
	}

	@Override
	public MouseEvent mouseMoved(MouseEvent e) {
		return e;
	}

	@Override
	public MouseWheelEvent mouseWheelMoved(MouseWheelEvent e) {
		if (ctrlHeld) {
			e.consume();
			targetPlane = clamp(targetPlane + e.getWheelRotation(), 0, MAX_Z - 1);
		} else if (altHeld) {
			e.consume();
			selectionIncludeZ = !selectionIncludeZ;
		}

		return e;
	}
}

package rs117.hd.overlays;

import javax.annotation.Nonnull;
import lombok.RequiredArgsConstructor;

@RequiredArgsConstructor
public enum Timer {
	DRAW_FRAME,
	DRAW_SCENE,
	DRAW_RENDERABLE,
	DRAW_TILED_LIGHTING,
	GET_MODEL,
	VISIBILITY_CHECK,
	CLICKBOX_CHECK,
	MODEL_BATCHING,
	MODEL_PUSHING,
	MODEL_PUSHING_VERTEX,
	MODEL_PUSHING_NORMAL,
	MODEL_PUSHING_UV(false, "Model pushing UV"),
	UPDATE_SCENE,
	UPDATE_ENVIRONMENT,
	UPDATE_LIGHTS,
	UPDATE_AREA_HIDING,
	IMPOSTOR_TRACKING,
	REPLACE_FISHING_SPOTS,
	CHARACTER_DISPLACEMENT,
	SWAP_BUFFERS,
	GARBAGE_COLLECTION,
	MAP_UI_BUFFER(false, "Map UI Buffer"),
	COPY_UI(false, "Copy UI"),
	RENDER_FRAME(true, false),
	RENDER_TILED_LIGHTING(true),
	UPLOAD_GEOMETRY(true),
	UPLOAD_UI(true, "Upload UI"),
	COMPUTE(true),
	CLEAR_SCENE(true),
	RENDER_SHADOWS(true),
	RENDER_SCENE(true),
	RENDER_UI(true, "Render UI"),
	;

	public static final Timer[] TIMERS = values();
	public final String name;
	public final boolean isGpuTimer;
	public final boolean gpuDebugGroup;

	Timer() {
		name = enumToName(name());
		isGpuTimer = false;
		gpuDebugGroup = false;
	}

	Timer(boolean isGpuTimer) {
		name = enumToName(name());
		this.isGpuTimer = isGpuTimer;
		gpuDebugGroup = isGpuTimer;
	}

	Timer(boolean isGpuTimer, @Nonnull String name) {
		this.name = name;
		this.isGpuTimer = isGpuTimer;
		gpuDebugGroup = isGpuTimer;
	}

	Timer(boolean isGpuTimer, boolean gpuDebugGroup) {
		name = enumToName(name());
		this.isGpuTimer = isGpuTimer;
		this.gpuDebugGroup = gpuDebugGroup;
	}

	Timer(@Nonnull String name) {
		this.name = name;
		isGpuTimer = false;
		gpuDebugGroup = false;
	}

	private static String enumToName(String name) {
		name = name.replace('_', ' ');
		return name.substring(0, 1).toUpperCase() + name.substring(1).toLowerCase();
	}

	@Override
	public String toString() {
		return name;
	}
}

package rs117.hd.renderer.legacy;

import java.nio.FloatBuffer;
import java.nio.IntBuffer;
import java.util.Arrays;
import javax.annotation.Nonnull;
import javax.annotation.Nullable;
import javax.inject.Inject;
import javax.inject.Singleton;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.*;
import net.runelite.api.gameval.ItemID;
import net.runelite.api.kit.*;
import net.runelite.client.RuneLite;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.util.LinkBrowser;
import rs117.hd.HdPlugin;
import rs117.hd.HdPluginConfig;
import rs117.hd.model.ModelCache;
import rs117.hd.model.ModelHasher;
import rs117.hd.overlays.FrameTimer;
import rs117.hd.overlays.Timer;
import rs117.hd.scene.MaterialManager;
import rs117.hd.scene.ProceduralGenerator;
import rs117.hd.scene.SceneContext;
import rs117.hd.scene.TileOverrideManager;
import rs117.hd.scene.materials.Material;
import rs117.hd.scene.model_overrides.InheritTileColorType;
import rs117.hd.scene.model_overrides.ModelOverride;
import rs117.hd.scene.model_overrides.TzHaarRecolorType;
import rs117.hd.scene.model_overrides.UvType;
import rs117.hd.scene.model_overrides.WindDisplacement;
import rs117.hd.scene.water_types.WaterType;
import rs117.hd.utils.HDUtils;
import rs117.hd.utils.ModelHash;
import rs117.hd.utils.PopupUtils;

import static rs117.hd.HdPlugin.MAX_FACE_COUNT;
import static rs117.hd.scene.tile_overrides.TileOverride.OVERLAY_FLAG;
import static rs117.hd.utils.HDUtils.HIDDEN_HSL;
import static rs117.hd.utils.HDUtils.packTerrainData;
import static rs117.hd.utils.MathUtils.*;

@Singleton
@Slf4j
public class LegacyModelPusher {
	@Inject
	private Client client;

	@Inject
	private ClientThread clientThread;

	@Inject
	private HdPlugin plugin;

	@Inject
	private HdPluginConfig config;

	@Inject
	private MaterialManager materialManager;

	@Inject
	private TileOverrideManager tileOverrideManager;

	@Inject
	private ModelHasher modelHasher;

	@Inject
	private FrameTimer frameTimer;

	public static final int DATUM_PER_FACE = 12;

	private static final int[] ZEROED_INTS = new int[12];

	private ModelCache modelCache;

	public void startUp() {
		assert WindDisplacement.values().length - 1 <= 0x7;

		if (plugin.configModelCaching && !plugin.useLowMemoryMode) {
			final int size = config.modelCacheSizeMiB();
			try {
				modelCache = new ModelCache(size, () -> {
					shutDown();
					plugin.stopPlugin();
				});
			} catch (Throwable err) {
				log.error("Error while initializing model cache. Stopping the plugin...", err);

				if (err instanceof OutOfMemoryError) {
					PopupUtils.displayPopupMessage(client, "117 HD Error",
						"117 HD ran out of memory while trying to allocate the model cache.<br><br>" +
						(
							HDUtils.is32Bit() ?
								(
									"You are currently using 32-bit RuneLite, which heavily restricts<br>" +
									"the amount of memory RuneLite is allowed to use.<br>" +
									"Please install the 64-bit launcher from " +
									"<a href=\"" + HdPlugin.RUNELITE_URL + "\">RuneLite's website</a> and try again.<br>"
								) : (
								(
									size <= 512 ? "" :
										"Your cache size of " + size + " MiB is " + (
											size >= 4000 ?
												"very large. We would recommend reducing it.<br>" :
												"bigger than the default size. Try reducing it.<br>"
										)
								) +
								"Normally, a cache size above 512 MiB is unnecessary, and the game should<br>" +
								"run acceptably even at 128 MiB. If you have to reduce the size by a lot,<br>" +
								"you may be better off disabling model caching entirely.<br>"
							)
						)
						+ "<br>"
						+ "You can also try closing some other programs on your PC to free up memory.<br>"
						+ "<br>"
						+ "If you need further assistance, please join our "
						+ "<a href=\"" + HdPlugin.DISCORD_URL + "\">Discord</a> server, and click the <br>"
						+ "\"Open logs folder\" button below, find the file named \"client\" or \"client.log\",<br>"
						+ "then drag and drop that file into one of our support channels.",
						new String[] { "Open logs folder", "Ok, let me try that..." },
						i -> {
							if (i == 0) {
								LinkBrowser.open(RuneLite.LOGS_DIR.toString());
								return false;
							}
							return true;
						}
					);
				}

				// Allow the model pusher to be used until the plugin has cleanly shut down
				clientThread.invoke(plugin::stopPlugin);
			}
		}
	}

	public void shutDown() {
		if (modelCache != null) {
			modelCache.destroy();
			modelCache = null;
		}
	}

	public void clearModelCache() {
		if (modelCache != null) {
			modelCache.clear();
		}
	}

	/**
	 * Pushes model data to staging buffers in the provided {@link SceneContext}, and writes the pushed number of
	 * vertices and UVs to {@link SceneContext#modelPusherResults}.
	 *
	 * @param sceneContext   object for the scene to push model data for
	 * @param tile           that the model is associated with, if any
	 * @param uuid           of the model
	 * @param model          to push data from
	 * @param modelOverride  the active model override
	 * @param preOrientation which the vertices have already been rotated by
	 * @param needsCaching   whether the model should be cached for future reuse, if enabled
	 */
	public void pushModel(
		LegacySceneContext sceneContext,
		@Nullable Tile tile,
		int uuid,
		Model model,
		ModelOverride modelOverride,
		int preOrientation,
		boolean needsCaching
	) {
		boolean useCache = needsCaching;
		if (modelCache == null)
			useCache = false;

		final int faceCount = min(model.getFaceCount(), MAX_FACE_COUNT);
		final int bufferSize = faceCount * DATUM_PER_FACE;
		int texturedFaceCount = 0;

		final short[] faceTextures = model.getFaceTextures();
		final byte[] textureFaces = model.getTextureFaces();
		boolean isVanillaTextured = faceTextures != null;
		boolean isVanillaUVMapped =
			isVanillaTextured && // Vanilla UV mapped models don't always have sensible UVs for untextured faces
			model.getTexIndices1() != null &&
			model.getTexIndices2() != null &&
			model.getTexIndices3() != null &&
			model.getTextureFaces() != null;

		Material baseMaterial = modelOverride.baseMaterial;
		Material textureMaterial = modelOverride.textureMaterial;

		boolean skipUVs =
			!isVanillaTextured &&
			baseMaterial.packMaterialData(modelOverride, UvType.GEOMETRY, false, false) == 0 &&
			modelOverride.colorOverrides == null;

		// ensure capacity upfront
		sceneContext.stagingBufferVertices.ensureCapacity(bufferSize);
		sceneContext.stagingBufferNormals.ensureCapacity(bufferSize);
		if (!skipUVs)
			sceneContext.stagingBufferUvs.ensureCapacity(bufferSize);

		boolean foundCachedVertexData = false;
		boolean foundCachedNormalData = false;
		boolean foundCachedUvData = skipUVs;

		if (useCache) {
			assert client.isClientThread() : "Model caching isn't thread-safe";

			IntBuffer vertexData = this.modelCache.getIntBuffer(modelHasher.vertexHash);
			foundCachedVertexData = vertexData != null && vertexData.remaining() == bufferSize;
			if (foundCachedVertexData) {
				sceneContext.stagingBufferVertices.put(vertexData);
				vertexData.rewind();
			}

			FloatBuffer normalData = this.modelCache.getFloatBuffer(modelHasher.normalHash);
			foundCachedNormalData = normalData != null && normalData.remaining() == bufferSize;
			if (foundCachedNormalData) {
				sceneContext.stagingBufferNormals.put(normalData);
				normalData.rewind();
			}

			if (!foundCachedUvData) {
				FloatBuffer uvData = this.modelCache.getFloatBuffer(modelHasher.uvHash);
				foundCachedUvData = uvData != null && uvData.remaining() == bufferSize;
				if (foundCachedUvData) {
					texturedFaceCount = faceCount;
					sceneContext.stagingBufferUvs.put(uvData);
					uvData.rewind();
				}
			}

			if (foundCachedVertexData && foundCachedNormalData && foundCachedUvData) {
				sceneContext.modelPusherResults[0] = faceCount;
				sceneContext.modelPusherResults[1] = texturedFaceCount;
				return;
			}
		}

		IntBuffer fullVertexData = null;
		FloatBuffer fullNormalData = null;
		FloatBuffer fullUvData = null;

		boolean cacheVertexData = false;
		boolean cacheNormalData = false;
		boolean cacheUvData = false;
		if (useCache) {
			cacheVertexData = !foundCachedVertexData;
			cacheNormalData = !foundCachedNormalData;
			cacheUvData = !foundCachedUvData;

			if (cacheVertexData) {
				fullVertexData = this.modelCache.reserveIntBuffer(modelHasher.vertexHash, bufferSize);
				if (fullVertexData == null) {
					log.error("failed to reserve vertex buffer");
					cacheVertexData = false;
				}
			}

			if (cacheNormalData) {
				fullNormalData = this.modelCache.reserveFloatBuffer(modelHasher.normalHash, bufferSize);
				if (fullNormalData == null) {
					log.error("failed to reserve normal buffer");
					cacheNormalData = false;
				}
			}

			if (cacheUvData) {
				fullUvData = this.modelCache.reserveFloatBuffer(modelHasher.uvHash, bufferSize);
				if (fullUvData == null) {
					log.error("failed to reserve uv buffer");
					cacheUvData = false;
				}
			}
		}

		if (!foundCachedVertexData) {
			if (plugin.enableDetailedTimers)
				frameTimer.begin(Timer.MODEL_PUSHING_VERTEX);

			modelOverride.applyRotation(model);
			for (int face = 0; face < faceCount; face++) {
				int[] data = getFaceVertices(sceneContext, tile, uuid, model, modelOverride, face);
				sceneContext.stagingBufferVertices.put(data);
				if (cacheVertexData)
					fullVertexData.put(data);
			}
			modelOverride.revertRotation(model);

			if (plugin.enableDetailedTimers)
				frameTimer.end(Timer.MODEL_PUSHING_VERTEX);
		}

		if (!foundCachedNormalData) {
			if (plugin.enableDetailedTimers)
				frameTimer.begin(Timer.MODEL_PUSHING_NORMAL);

			for (int face = 0; face < faceCount; face++) {
				getNormalDataForFace(sceneContext, model, modelOverride, face);
				sceneContext.stagingBufferNormals.put(sceneContext.modelFaceNormals);
				if (cacheNormalData)
					fullNormalData.put(sceneContext.modelFaceNormals);
			}

			if (plugin.enableDetailedTimers)
				frameTimer.end(Timer.MODEL_PUSHING_NORMAL);
		}

		if (!foundCachedUvData) {
			if (plugin.enableDetailedTimers)
				frameTimer.begin(Timer.MODEL_PUSHING_UV);

			int[] faceColors = model.getFaceColors1();
			byte[] faceTransparencies = model.getFaceTransparencies();
			for (int face = 0; face < faceCount; face++) {
				short textureId = isVanillaTextured ? faceTextures[face] : -1;
				UvType uvType = UvType.GEOMETRY;
				Material material = baseMaterial;
				ModelOverride faceOverride = modelOverride;

				if (textureId != -1) {
					uvType = UvType.VANILLA;
					if (textureMaterial != Material.NONE) {
						material = textureMaterial;
					} else {
						material = materialManager.fromVanillaTexture(textureId);
						if (modelOverride.materialOverrides != null) {
							var override = modelOverride.materialOverrides.get(material);
							if (override != null) {
								faceOverride = override;
								material = faceOverride.textureMaterial;
							}
						}
					}
				} else if (modelOverride.colorOverrides != null && (cacheUvData || !needsCaching)) {
					// Color overrides are heavy. Only apply them if the UVs will be cached or don't need caching
					int ahsl = (faceTransparencies == null ? 0xFF : 0xFF - (faceTransparencies[face] & 0xFF)) << 16 | faceColors[face];
					for (var override : modelOverride.colorOverrides) {
						if (override.ahslCondition.test(ahsl)) {
							faceOverride = override;
							material = faceOverride.baseMaterial;
							break;
						}
					}
				}

				if (material != Material.NONE) {
					uvType = faceOverride.uvType;
					if (uvType == UvType.VANILLA || (textureId != -1 && faceOverride.retainVanillaUvs))
						uvType = isVanillaUVMapped && textureFaces[face] != -1 ? UvType.VANILLA : UvType.GEOMETRY;
				}

				int materialData = material.packMaterialData(faceOverride, uvType, false, textureId != -1);

				final float[] uvData = sceneContext.modelFaceUvs;
				if (materialData == 0) {
					Arrays.fill(uvData, 0);
				} else {
					faceOverride.fillUvsForFace(uvData, model, preOrientation, uvType, face, sceneContext.modelFaceNormals);
					uvData[3] = uvData[7] = uvData[11] = Float.intBitsToFloat(materialData);
				}

				sceneContext.stagingBufferUvs.put(uvData);
				if (cacheUvData)
					fullUvData.put(uvData);

				++texturedFaceCount;
			}

			if (plugin.enableDetailedTimers)
				frameTimer.end(Timer.MODEL_PUSHING_UV);
		}

		if (cacheVertexData)
			fullVertexData.flip();
		if (cacheNormalData)
			fullNormalData.flip();
		if (cacheUvData)
			fullUvData.flip();

		sceneContext.modelPusherResults[0] = faceCount;
		sceneContext.modelPusherResults[1] = texturedFaceCount;
	}

	private void getNormalDataForFace(SceneContext sceneContext, Model model, @Nonnull ModelOverride modelOverride, int face) {
		assert packTerrainData(false, 0, WaterType.NONE, 0) == 0;
		if (modelOverride.flatNormals || !plugin.configPreserveVanillaNormals && model.getFaceColors3()[face] == -1) {
			Arrays.fill(sceneContext.modelFaceNormals, 0);
			return;
		}

		final int[] xVertexNormals = model.getVertexNormalsX();
		final int[] yVertexNormals = model.getVertexNormalsY();
		final int[] zVertexNormals = model.getVertexNormalsZ();

		if (xVertexNormals == null || yVertexNormals == null || zVertexNormals == null) {
			Arrays.fill(sceneContext.modelFaceNormals, 0);
			return;
		}

		final int triA = model.getFaceIndices1()[face];
		final int triB = model.getFaceIndices2()[face];
		final int triC = model.getFaceIndices3()[face];

		float terrainData = 0;
		sceneContext.modelFaceNormals[0] = xVertexNormals[triA];
		sceneContext.modelFaceNormals[1] = yVertexNormals[triA];
		sceneContext.modelFaceNormals[2] = zVertexNormals[triA];
		sceneContext.modelFaceNormals[3] = terrainData;
		sceneContext.modelFaceNormals[4] = xVertexNormals[triB];
		sceneContext.modelFaceNormals[5] = yVertexNormals[triB];
		sceneContext.modelFaceNormals[6] = zVertexNormals[triB];
		sceneContext.modelFaceNormals[7] = terrainData;
		sceneContext.modelFaceNormals[8] = xVertexNormals[triC];
		sceneContext.modelFaceNormals[9] = yVertexNormals[triC];
		sceneContext.modelFaceNormals[10] = zVertexNormals[triC];
		sceneContext.modelFaceNormals[11] = terrainData;
	}

	@SuppressWarnings({ "ReassignedVariable" })
	private int[] getFaceVertices(
		SceneContext sceneContext,
		Tile tile,
		int uuid,
		Model model,
		@Nonnull ModelOverride modelOverride,
		int face
	) {
		if (model.getFaceColors3()[face] == -2)
			return ZEROED_INTS; // Hide the face

		// Hide fake shadows or lighting that is often baked into models by making the fake shadow transparent
		if (plugin.configHideFakeShadows && HDUtils.isBakedGroundShading(model, face)) {
			if (modelOverride.hideVanillaShadows)
				return ZEROED_INTS; // Hide the face

			if (ModelHash.getUuidType(uuid) == ModelHash.TYPE_PLAYER) {
				int index = ModelHash.getUuidId(uuid);
				var players = client.getTopLevelWorldView().players();
				if (index >= 0 && index < 2048) {
					Player player = players.byIndex(index);
					if (player != null && player.getPlayerComposition().getEquipmentId(KitType.WEAPON) == ItemID.MAGIC_CARPET)
						return ZEROED_INTS; // Hide the face
				}
			}
		}

		int color1 = model.getFaceColors1()[face];
		int color2 = model.getFaceColors2()[face];
		int color3 = model.getFaceColors3()[face];
		final int triA = model.getFaceIndices1()[face];
		final int triB = model.getFaceIndices2()[face];
		final int triC = model.getFaceIndices3()[face];
		final float[] xVertices = model.getVerticesX();
		final float[] yVertices = model.getVerticesY();
		final float[] zVertices = model.getVerticesZ();
		final short[] faceTextures = model.getFaceTextures();
		final byte[] faceTransparencies = model.getFaceTransparencies();
		final byte[] facePriorities = model.getFaceRenderPriorities();
		boolean isTextured = faceTextures != null && faceTextures[face] != -1;

		if (color3 == -1)
			color2 = color3 = color1;

		int packedAlphaPriorityFlags = 0;
		if (faceTransparencies != null && !isTextured)
			packedAlphaPriorityFlags |= (faceTransparencies[face] & 0xFF) << 24;
		if (facePriorities != null)
			packedAlphaPriorityFlags |= (facePriorities[face] & 0xF) << 16;

		if (isTextured) {
			// Without overriding the color for textured faces, vanilla shading remains pretty noticeable even after
			// the approximate reversal above. Ardougne rooftops is a good example, where vanilla shading results in a
			// weird-looking tint. The brightness clamp afterward is required to reduce the over-exposure introduced.
			color1 = color2 = color3 = 90;

			// Let the shader know vanilla shading reversal should be skipped for this face
			packedAlphaPriorityFlags |= 1 << 20;
		} else {
			final int overrideAmount = model.getOverrideAmount() & 0xFF;
			if (overrideAmount > 0) {
				// HSL override is not applied to flat shade faces or to textured faces
				final byte overrideHue = model.getOverrideHue();
				final byte overrideSat = model.getOverrideSaturation();
				final byte overrideLum = model.getOverrideLuminance();

				if (overrideHue != -1) {
					color1 += overrideAmount * (overrideHue - (color1 >> 10 & 0x3F)) >> 7 << 10;
					color2 += overrideAmount * (overrideHue - (color2 >> 10 & 0x3F)) >> 7 << 10;
					color3 += overrideAmount * (overrideHue - (color3 >> 10 & 0x3F)) >> 7 << 10;
				}

				if (overrideSat != -1) {
					color1 += overrideAmount * (overrideSat - (color1 >> 7 & 7)) >> 7 << 7;
					color2 += overrideAmount * (overrideSat - (color2 >> 7 & 7)) >> 7 << 7;
					color3 += overrideAmount * (overrideSat - (color3 >> 7 & 7)) >> 7 << 7;
				}

				if (overrideLum != -1) {
					color1 += overrideAmount * (overrideLum - (color1 & 0x7F)) >> 7;
					color2 += overrideAmount * (overrideLum - (color2 & 0x7F)) >> 7;
					color3 += overrideAmount * (overrideLum - (color3 & 0x7F)) >> 7;
				}
			}

			if (tile != null) {
				if (modelOverride.inheritTileColorType != InheritTileColorType.NONE) {
					final Scene scene = sceneContext.scene;
					SceneTileModel tileModel = tile.getSceneTileModel();
					SceneTilePaint tilePaint = tile.getSceneTilePaint();

					if (tilePaint != null || tileModel != null) {
						// No point in inheriting tilepaint color if the ground tile does not have a color, for example above a cave wall
						if (
							tilePaint != null &&
							tilePaint.getTexture() == -1 &&
							tilePaint.getRBG() != 0 &&
							tilePaint.getNeColor() != HIDDEN_HSL
						) {

							// Since tile colors are guaranteed to have the same hue and saturation per face,
							// we can blend without converting from HSL to RGB
							int averageColor =
								(
									tilePaint.getSwColor() +
									tilePaint.getNwColor() +
									tilePaint.getNeColor() +
									tilePaint.getSeColor()
								) / 4;

							var override = tileOverrideManager.getOverride(sceneContext, tile);
							averageColor = override.modifyColor(averageColor);
							color1 = color2 = color3 = averageColor;

							// Let the shader know vanilla shading reversal should be skipped for this face
							packedAlphaPriorityFlags |= 1 << 20;
						} else if (tileModel != null && tileModel.getTriangleTextureId() == null) {
							int faceColorIndex = -1;
							for (int i = 0; i < tileModel.getTriangleColorA().length; i++) {
								boolean isOverlay = ProceduralGenerator.isOverlayFace(tile, i);
								// Use underlay if the tile does not have an overlay, useful for rocks in cave corners.
								if (modelOverride.inheritTileColorType == InheritTileColorType.UNDERLAY
									|| tileModel.getModelOverlay() == 0) {
									// pulling the color from UNDERLAY is more desirable for green grass tiles
									// OVERLAY pulls in path color which is not desirable for grass next to paths
									if (!isOverlay) {
										faceColorIndex = i;
										break;
									}
								} else if (modelOverride.inheritTileColorType == InheritTileColorType.OVERLAY) {
									if (isOverlay) {
										// OVERLAY used in dirt/path/house tile color blend better with rubbles/rocks
										faceColorIndex = i;
										break;
									}
								}
							}

							if (faceColorIndex != -1) {
								int color = tileModel.getTriangleColorA()[faceColorIndex];
								if (color != HIDDEN_HSL) {
									var scenePos = tile.getSceneLocation();
									int tileX = scenePos.getX();
									int tileY = scenePos.getY();
									int tileZ = tile.getRenderLevel();
									int tileExX = tileX + sceneContext.sceneOffset;
									int tileExY = tileY + sceneContext.sceneOffset;
									int[] worldPos = sceneContext.sceneToWorld(tileX, tileY, tileZ);
									int tileId = modelOverride.inheritTileColorType == InheritTileColorType.OVERLAY ?
										OVERLAY_FLAG | scene.getOverlayIds()[tileZ][tileExX][tileExY] :
										scene.getUnderlayIds()[tileZ][tileExX][tileExY];
									var override = tileOverrideManager.getOverride(sceneContext, tile, worldPos, tileId);
									color = override.modifyColor(color);
									color1 = color2 = color3 = color;

									// Let the shader know vanilla shading reversal should be skipped for this face
									packedAlphaPriorityFlags |= 1 << 20;
								}
							}
						}
					}
				}

				if (plugin.configLegacyTzHaarReskin && modelOverride.tzHaarRecolorType != TzHaarRecolorType.NONE) {
					int[] tzHaarRecolored = ProceduralGenerator.recolorTzHaar(
						uuid,
						modelOverride,
						model,
						face,
						color1,
						color2,
						color3
					);
					color1 = tzHaarRecolored[0];
					color2 = tzHaarRecolored[1];
					color3 = tzHaarRecolored[2];
					packedAlphaPriorityFlags |= tzHaarRecolored[3] << 24;
				}
			}
		}

		color1 |= packedAlphaPriorityFlags;
		color2 |= packedAlphaPriorityFlags;
		color3 |= packedAlphaPriorityFlags;

		int[] data = sceneContext.modelFaceVertices;
		data[0] = Float.floatToIntBits(xVertices[triA]);
		data[1] = Float.floatToIntBits(yVertices[triA]);
		data[2] = Float.floatToIntBits(zVertices[triA]);
		data[3] = color1;
		data[4] = Float.floatToIntBits(xVertices[triB]);
		data[5] = Float.floatToIntBits(yVertices[triB]);
		data[6] = Float.floatToIntBits(zVertices[triB]);
		data[7] = color2;
		data[8] = Float.floatToIntBits(xVertices[triC]);
		data[9] = Float.floatToIntBits(yVertices[triC]);
		data[10] = Float.floatToIntBits(zVertices[triC]);
		data[11] = color3;
		return data;
	}
}

package rs117.hd.renderer.legacy;

import java.io.IOException;
import java.nio.ByteBuffer;
import java.nio.ByteOrder;
import java.nio.IntBuffer;
import java.nio.ShortBuffer;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;
import javax.annotation.Nullable;
import javax.inject.Inject;
import lombok.Getter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.*;
import net.runelite.api.events.*;
import net.runelite.api.hooks.*;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.ui.DrawManager;
import org.lwjgl.opengl.*;
import rs117.hd.HdPlugin;
import rs117.hd.HdPluginConfig;
import rs117.hd.config.ColorFilter;
import rs117.hd.config.DynamicLights;
import rs117.hd.model.ModelHasher;
import rs117.hd.model.ModelOffsets;
import rs117.hd.opengl.compute.ComputeMode;
import rs117.hd.opengl.compute.OpenCLManager;
import rs117.hd.opengl.shader.ModelPassthroughComputeProgram;
import rs117.hd.opengl.shader.ModelSortingComputeProgram;
import rs117.hd.opengl.shader.SceneShaderProgram;
import rs117.hd.opengl.shader.ShaderException;
import rs117.hd.opengl.shader.ShaderIncludes;
import rs117.hd.opengl.shader.ShadowShaderProgram;
import rs117.hd.opengl.uniforms.UBOCompute;
import rs117.hd.opengl.uniforms.UBOLights;
import rs117.hd.overlays.FrameTimer;
import rs117.hd.overlays.Timer;
import rs117.hd.renderer.Renderer;
import rs117.hd.scene.AreaManager;
import rs117.hd.scene.EnvironmentManager;
import rs117.hd.scene.FishingSpotReplacer;
import rs117.hd.scene.LightManager;
import rs117.hd.scene.ModelOverrideManager;
import rs117.hd.scene.ProceduralGenerator;
import rs117.hd.scene.areas.Area;
import rs117.hd.scene.lights.Light;
import rs117.hd.scene.model_overrides.ModelOverride;
import rs117.hd.utils.ColorUtils;
import rs117.hd.utils.HDUtils;
import rs117.hd.utils.Mat4;
import rs117.hd.utils.ModelHash;
import rs117.hd.utils.NpcDisplacementCache;
import rs117.hd.utils.buffer.GLBuffer;
import rs117.hd.utils.buffer.GpuIntBuffer;
import rs117.hd.utils.buffer.SharedGLBuffer;
import rs117.hd.utils.jobs.JobSystem;

import static org.lwjgl.opencl.CL10.*;
import static org.lwjgl.opengl.GL33C.*;
import static rs117.hd.HdPlugin.COLOR_FILTER_FADE_DURATION;
import static rs117.hd.HdPlugin.MAX_FACE_COUNT;
import static rs117.hd.HdPlugin.NEAR_PLANE;
import static rs117.hd.HdPlugin.ORTHOGRAPHIC_ZOOM;
import static rs117.hd.HdPlugin.TEXTURE_UNIT_TILE_HEIGHT_MAP;
import static rs117.hd.HdPlugin.checkGLErrors;
import static rs117.hd.HdPluginConfig.*;
import static rs117.hd.utils.MathUtils.*;

@Slf4j
public class LegacyRenderer implements Renderer {
	public static final int GROUND_MIN_Y = 350; // how far below the ground models extend
	public static final int VERTEX_SIZE = 4; // 4 ints per vertex
	public static final int UV_SIZE = 4; // 4 floats per vertex
	public static final int NORMAL_SIZE = 4; // 4 floats per vertex

	private static int UNIFORM_BLOCK_COUNT = HdPlugin.UNIFORM_BLOCK_COUNT;
	public static final int UNIFORM_BLOCK_COMPUTE = UNIFORM_BLOCK_COUNT++;

	@Inject
	private Client client;

	@Inject
	private DrawManager drawManager;

	@Inject
	private HdPlugin plugin;

	@Inject
	private HdPluginConfig config;

	@Inject
	private OpenCLManager clManager;

	@Inject
	private AreaManager areaManager;

	@Inject
	private LightManager lightManager;

	@Inject
	private EnvironmentManager environmentManager;

	@Inject
	private ModelOverrideManager modelOverrideManager;

	@Inject
	private LegacySceneUploader sceneUploader;

	@Inject
	private LegacyModelPusher modelPusher;

	@Inject
	private ModelHasher modelHasher;

	@Inject
	private FishingSpotReplacer fishingSpotReplacer;

	@Inject
	private NpcDisplacementCache npcDisplacementCache;

	@Inject
	private FrameTimer frameTimer;

	@Inject
	public SceneShaderProgram sceneProgram;

	@Inject
	public ModelPassthroughComputeProgram modelPassthroughComputeProgram;

	@Inject
	public ShadowShaderProgram shadowProgram;

	@Inject
	private JobSystem jobSystem;

	private final ComputeMode computeMode = HdPlugin.APPLE ? ComputeMode.OPENCL : ComputeMode.OPENGL;
	private final List<ModelSortingComputeProgram> modelSortingComputePrograms = new ArrayList<>();

	public int vaoScene;
	public int texTileHeightMap;
	public SharedGLBuffer hStagingBufferVertices;
	public SharedGLBuffer hStagingBufferUvs;
	public SharedGLBuffer hStagingBufferNormals;
	public SharedGLBuffer hRenderBufferVertices;
	public SharedGLBuffer hRenderBufferUvs;
	public SharedGLBuffer hRenderBufferNormals;
	public int numPassthroughModels;
	public GpuIntBuffer modelPassthroughBuffer;
	public SharedGLBuffer hModelPassthroughBuffer;
	// ordered by face count from small to large
	public int numSortingBins;
	public int[] modelSortingBinFaceCounts; // facesPerThread * threadCount
	public int[] modelSortingBinThreadCounts;
	public int[] numModelsToSort;
	public GpuIntBuffer[] modelSortingBuffers;
	public SharedGLBuffer[] hModelSortingBuffers;
	public int dynamicOffsetVertices;
	public int dynamicOffsetUvs;
	public int renderBufferOffset;
	public final Map<Long, ModelOffsets> frameModelInfoMap = new HashMap<Long, ModelOffsets>();
	// Camera position and orientation may be reused from the old scene while hopping, prior to drawScene being called
	public int visibilityCheckZoom;
	public boolean tileVisibilityCached;
	public final boolean[][][] tileIsVisible = new boolean[Constants.MAX_Z][Constants.EXTENDED_SCENE_SIZE][Constants.EXTENDED_SCENE_SIZE];

	private final int[] eightIntWrite = new int[8];

	@Getter
	@Nullable
	private LegacySceneContext sceneContext;
	private LegacySceneContext nextSceneContext;
	private int gameTicksUntilSceneReload;

	private UBOCompute uboCompute;

	@Override
	public boolean supportsGpu(GLCapabilities glCaps) {
		return computeMode == ComputeMode.OPENGL ? glCaps.OpenGL43 : glCaps.OpenGL31;
	}

	@Override
	public int gpuFlags() {
		return
			DrawCallbacks.NORMALS |
			DrawCallbacks.HILLSKEW;
	}

	@Override
	public void initialize() {
		modelPusher.startUp();

		jobSystem.initialize();

		renderBufferOffset = 0;
		numPassthroughModels = 0;
		numModelsToSort = null;

		// Create scene VAO
		vaoScene = glGenVertexArrays();

		int maxComputeThreadCount;
		if (computeMode == ComputeMode.OPENCL) {
			clManager.startUp(this, plugin.awtContext);
			maxComputeThreadCount = clManager.getMaxWorkGroupSize();
		} else {
			maxComputeThreadCount = glGetInteger(GL43C.GL_MAX_COMPUTE_WORK_GROUP_INVOCATIONS);
		}
		initializeModelSortingBins(maxComputeThreadCount);

		initializeBuffers();
	}

	@Override
	public synchronized void destroy() {
		modelPusher.shutDown();

		if (vaoScene != 0)
			glDeleteVertexArrays(vaoScene);
		vaoScene = 0;

		jobSystem.destroy();

		destroyBuffers();
		destroyTileHeightMap();
		destroyModelSortingBins();
		if (modelPassthroughBuffer != null)
			modelPassthroughBuffer.destroy();
		modelPassthroughBuffer = null;

		if (sceneContext != null)
			sceneContext.destroy();
		sceneContext = null;

		if (nextSceneContext != null)
			nextSceneContext.destroy();
		nextSceneContext = null;

		clManager.shutDown();
	}

	@Override
	public void waitUntilIdle() {
		if (computeMode == ComputeMode.OPENCL)
			clManager.finish();
		glFinish();
	}

	@Subscribe
	public void onGameTick(GameTick gameTick) {
		if (gameTicksUntilSceneReload > 0) {
			if (gameTicksUntilSceneReload == 1)
				reloadScene();
			--gameTicksUntilSceneReload;
		}
	}

	@Override
	public void processConfigChanges(Set<String> keys) {
		if (keys.contains(KEY_MODEL_CACHING) || keys.contains(KEY_MODEL_CACHE_SIZE)) {
			modelPusher.shutDown();
			modelPusher.startUp();
		}
	}

	@Override
	public void clearCaches() {
		modelPusher.clearModelCache();
	}

	@Override
	public void addShaderIncludes(ShaderIncludes includes) {
		includes.addUniformBuffer(uboCompute);
	}

	@Override
	public void initializeShaders(ShaderIncludes includes) throws ShaderException, IOException {
		sceneProgram.compile(includes);

		shadowProgram.setMode(plugin.configShadowMode);
		shadowProgram.compile(includes);

		if (computeMode == ComputeMode.OPENCL) {
			clManager.initializePrograms();
		} else {
			modelPassthroughComputeProgram.compile(includes);

			for (int i = 0; i < numSortingBins; i++) {
				int faceCount = modelSortingBinFaceCounts[i];
				int threadCount = modelSortingBinThreadCounts[i];
				int facesPerThread = ceil((float) faceCount / threadCount);
				var program = new ModelSortingComputeProgram(threadCount, facesPerThread);
				modelSortingComputePrograms.add(program);
				program.compile(includes);
			}
		}
	}

	@Override
	public void destroyShaders() {
		sceneProgram.destroy();
		shadowProgram.destroy();

		if (computeMode == ComputeMode.OPENGL) {
			modelPassthroughComputeProgram.destroy();
			for (var program : modelSortingComputePrograms)
				program.destroy();
			modelSortingComputePrograms.clear();
		} else {
			clManager.destroyPrograms();
		}
	}

	public void initializeModelSortingBins(int maxThreadCount) {
		int[] targetFaceCounts = {
			128,
			512,
			2048,
			4096,
			MAX_FACE_COUNT
		};

		int numBins = 0;
		int[] binFaceCounts = new int[targetFaceCounts.length];
		int[] binThreadCounts = new int[targetFaceCounts.length];

		int faceCount = 0;
		for (int targetFaceCount : targetFaceCounts) {
			if (faceCount >= targetFaceCount)
				continue;

			int facesPerThread = 1;
			int threadCount;
			while (true) {
				threadCount = ceil((float) targetFaceCount / facesPerThread);
				if (threadCount <= maxThreadCount)
					break;
				++facesPerThread;
			}

			faceCount = threadCount * facesPerThread;
			binFaceCounts[numBins] = faceCount;
			binThreadCounts[numBins] = threadCount;
			++numBins;
		}

		numSortingBins = numBins;
		modelSortingBinFaceCounts = Arrays.copyOf(binFaceCounts, numBins);
		modelSortingBinThreadCounts = Arrays.copyOf(binThreadCounts, numBins);
		numModelsToSort = new int[numBins];

		modelSortingBuffers = new GpuIntBuffer[numSortingBins];
		for (int i = 0; i < numSortingBins; i++)
			modelSortingBuffers[i] = new GpuIntBuffer();

		hModelSortingBuffers = new SharedGLBuffer[numSortingBins];
		for (int i = 0; i < numSortingBins; i++) {
			hModelSortingBuffers[i] = new SharedGLBuffer(
				"Model Sorting " + modelSortingBinFaceCounts[i], GL_ARRAY_BUFFER, GL_STREAM_DRAW, CL_MEM_READ_ONLY);
			// Initialize each model sorting buffer with capacity for 64 models
			hModelSortingBuffers[i].initialize();
		}

		log.debug("Spreading model sorting across {} bins: {}", numBins, modelSortingBinFaceCounts);
	}

	public void destroyModelSortingBins() {
		// Don't allow redrawing the previous frame if the model sorting buffers are no longer valid
		plugin.redrawPreviousFrame = false;

		numSortingBins = 0;
		modelSortingBinFaceCounts = null;
		modelSortingBinThreadCounts = null;
		numModelsToSort = null;

		if (modelSortingBuffers != null)
			for (var buffer : modelSortingBuffers)
				buffer.destroy();
		modelSortingBuffers = null;

		if (hModelSortingBuffers != null)
			for (var buffer : hModelSortingBuffers)
				buffer.destroy();
		hModelSortingBuffers = null;
	}

	public void updateSceneVao(GLBuffer vertexBuffer, GLBuffer uvBuffer, GLBuffer normalBuffer) {
		glBindVertexArray(vaoScene);

		// Position
		glEnableVertexAttribArray(0);
		glBindBuffer(GL_ARRAY_BUFFER, vertexBuffer.id);
		glVertexAttribPointer(0, 3, GL_FLOAT, false, 16, 0);

		// UVs
		glEnableVertexAttribArray(1);
		glBindBuffer(GL_ARRAY_BUFFER, uvBuffer.id);
		glVertexAttribPointer(1, 3, GL_FLOAT, false, 16, 0);

		// Normals
		glEnableVertexAttribArray(2);
		glBindBuffer(GL_ARRAY_BUFFER, normalBuffer.id);
		glVertexAttribPointer(2, 3, GL_FLOAT, false, 16, 0);

		// Alpha, HSL
		glEnableVertexAttribArray(3);
		glBindBuffer(GL_ARRAY_BUFFER, vertexBuffer.id);
		glVertexAttribIPointer(3, 1, GL_INT, 16, 12);

		// Material data
		glEnableVertexAttribArray(4);
		glBindBuffer(GL_ARRAY_BUFFER, uvBuffer.id);
		glVertexAttribIPointer(4, 1, GL_INT, 16, 12);

		// Terrain data
		glEnableVertexAttribArray(5);
		glBindBuffer(GL_ARRAY_BUFFER, normalBuffer.id);
		glVertexAttribIPointer(5, 1, GL_INT, 16, 12);
	}

	private void initializeBuffers() {
		hStagingBufferVertices = new SharedGLBuffer("Staging Vertices", GL_ARRAY_BUFFER, GL_DYNAMIC_DRAW, CL_MEM_READ_ONLY);
		hStagingBufferUvs = new SharedGLBuffer("Staging UVs", GL_ARRAY_BUFFER, GL_DYNAMIC_DRAW, CL_MEM_READ_ONLY);
		hStagingBufferNormals = new SharedGLBuffer("Staging Normals", GL_ARRAY_BUFFER, GL_DYNAMIC_DRAW, CL_MEM_READ_ONLY);
		hRenderBufferVertices = new SharedGLBuffer("Render Vertices", GL_ARRAY_BUFFER, GL_STREAM_COPY, CL_MEM_WRITE_ONLY);
		hRenderBufferUvs = new SharedGLBuffer("Render UVs", GL_ARRAY_BUFFER, GL_STREAM_COPY, CL_MEM_WRITE_ONLY);
		hRenderBufferNormals = new SharedGLBuffer("Render Normals", GL_ARRAY_BUFFER, GL_STREAM_COPY, CL_MEM_WRITE_ONLY);
		hModelPassthroughBuffer = new SharedGLBuffer("Model Passthrough", GL_ARRAY_BUFFER, GL_STREAM_DRAW, CL_MEM_READ_ONLY);

		uboCompute = new UBOCompute();
		uboCompute.initialize(UNIFORM_BLOCK_COMPUTE);

		modelPassthroughBuffer = new GpuIntBuffer();

		hStagingBufferVertices.initialize();
		hStagingBufferUvs.initialize();
		hStagingBufferNormals.initialize();

		hRenderBufferVertices.initialize();
		hRenderBufferUvs.initialize();
		hRenderBufferNormals.initialize();

		hModelPassthroughBuffer.initialize();
	}

	private void destroyBuffers() {
		uboCompute.destroy();
		uboCompute = null;

		hStagingBufferVertices.destroy();
		hStagingBufferUvs.destroy();
		hStagingBufferNormals.destroy();

		hRenderBufferVertices.destroy();
		hRenderBufferUvs.destroy();
		hRenderBufferNormals.destroy();

		hModelPassthroughBuffer.destroy();

		hStagingBufferVertices = null;
		hStagingBufferUvs = null;
		hStagingBufferNormals = null;
		hRenderBufferVertices = null;
		hRenderBufferUvs = null;
		hRenderBufferNormals = null;
		hModelPassthroughBuffer = null;

		clManager.shutDown();
	}

	public void initializeTileHeightMap(Scene scene) {
		final int TILE_HEIGHT_BUFFER_SIZE = Constants.MAX_Z * Constants.EXTENDED_SCENE_SIZE * Constants.EXTENDED_SCENE_SIZE * Short.BYTES;
		ShortBuffer tileBuffer = ByteBuffer
			.allocateDirect(TILE_HEIGHT_BUFFER_SIZE)
			.order(ByteOrder.nativeOrder())
			.asShortBuffer();

		int[][][] tileHeights = scene.getTileHeights();
		for (int z = 0; z < Constants.MAX_Z; ++z) {
			for (int y = 0; y < Constants.EXTENDED_SCENE_SIZE; ++y) {
				for (int x = 0; x < Constants.EXTENDED_SCENE_SIZE; ++x) {
					int h = tileHeights[z][x][y];
					assert (h & 0b111) == 0;
					h >>= 3;
					tileBuffer.put((short) h);
				}
			}
		}
		tileBuffer.flip();

		texTileHeightMap = glGenTextures();
		glActiveTexture(TEXTURE_UNIT_TILE_HEIGHT_MAP);
		glBindTexture(GL_TEXTURE_3D, texTileHeightMap);
		glTexParameteri(GL_TEXTURE_3D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
		glTexParameteri(GL_TEXTURE_3D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);
		glTexParameteri(GL_TEXTURE_3D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
		glTexParameteri(GL_TEXTURE_3D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);
		glTexImage3D(
			GL_TEXTURE_3D, 0, GL_R16I,
			Constants.EXTENDED_SCENE_SIZE, Constants.EXTENDED_SCENE_SIZE, Constants.MAX_Z,
			0, GL_RED_INTEGER, GL_SHORT, tileBuffer
		);
	}

	public void destroyTileHeightMap() {
		if (texTileHeightMap != 0)
			glDeleteTextures(texTileHeightMap);
		texTileHeightMap = 0;
	}

	@Override
	public void drawScene(double cameraX, double cameraY, double cameraZ, double cameraPitch, double cameraYaw, int plane) {
		plugin.updateSceneFbo();

		if (sceneContext == null || plugin.sceneViewport == null)
			return;

		frameTimer.begin(Timer.DRAW_FRAME);
		frameTimer.begin(Timer.DRAW_SCENE);

		final Scene scene = client.getTopLevelWorldView().getScene();
		int drawDistance = plugin.getDrawDistance();
		boolean drawDistanceChanged = false;
		if (scene.getDrawDistance() != drawDistance) {
			scene.setDrawDistance(drawDistance);
			drawDistanceChanged = true;
		}

		boolean updateUniforms = true;

		Player localPlayer = client.getLocalPlayer();
		var lp = localPlayer.getLocalLocation();
		if (sceneContext.enableAreaHiding) {
			assert sceneContext.sceneBase != null;
			int[] worldPos = {
				sceneContext.sceneBase[0] + lp.getSceneX(),
				sceneContext.sceneBase[1] + lp.getSceneY(),
				sceneContext.sceneBase[2] + client.getTopLevelWorldView().getPlane()
			};

			// We need to check all areas contained in the scene in the order they appear in the list,
			// in order to ensure lower floors can take precedence over higher floors which include tiny
			// portions of the floor beneath around stairs and ladders
			Area newArea = null;
			for (var area : sceneContext.possibleAreas) {
				if (area.containsPoint(false, worldPos)) {
					newArea = area;
					break;
				}
			}

			// Force a scene reload if the player is no longer in the same area
			if (newArea != sceneContext.currentArea) {
				if (plugin.justChangedArea) {
					// Prevent getting stuck in a scene reloading loop if this breaks for any reason
					sceneContext.forceDisableAreaHiding = true;
					log.error(
						"Force disabling area hiding after moving from {} to {} at {}",
						sceneContext.currentArea,
						newArea,
						worldPos
					);
				} else {
					plugin.justChangedArea = true;
				}
				// Reload the scene to reapply area hiding
				client.setGameState(GameState.LOADING);
				updateUniforms = false;
				plugin.redrawPreviousFrame = true;
			} else {
				plugin.justChangedArea = false;
			}
		} else {
			plugin.justChangedArea = false;
		}

		if (!plugin.enableFreezeFrame) {
			if (!plugin.redrawPreviousFrame) {
				// Only reset the target buffer offset right before drawing the scene. That way if there are frames
				// after this that don't involve a scene draw, like during LOADING/HOPPING/CONNECTION_LOST, we can
				// still redraw the previous frame's scene to emulate the client behavior of not painting over the
				// viewport buffer.
				renderBufferOffset = sceneContext.staticVertexCount;

				plugin.drawnTileCount = 0;
				plugin.drawnStaticRenderableCount = 0;
				plugin.drawnDynamicRenderableCount = 0;

				// TODO: this could be done only once during scene swap, but is a bit of a pain to do
				// Push unordered models that should always be drawn at the start of each frame.
				// Used to fix issues like the right-click menu causing underwater tiles to disappear.
				var staticUnordered = sceneContext.staticUnorderedModelBuffer.getBuffer();
				modelPassthroughBuffer
					.ensureCapacity(staticUnordered.limit())
					.put(staticUnordered);
				staticUnordered.rewind();
				numPassthroughModels += staticUnordered.limit() / 8;
			}

			if (updateUniforms) {
				float[] newCameraPosition = { (float) cameraX, (float) cameraY, (float) cameraZ };
				float[] newCameraOrientation = { (float) cameraYaw, (float) cameraPitch };
				int newZoom = plugin.configShadowsEnabled && plugin.configExpandShadowDraw ?
					client.get3dZoom() / 2 :
					client.get3dZoom();
				if (!Arrays.equals(plugin.cameraPosition, newCameraPosition) ||
					!Arrays.equals(plugin.cameraOrientation, newCameraOrientation) ||
					visibilityCheckZoom != newZoom ||
					drawDistanceChanged
				) {
					copyTo(plugin.cameraPosition, newCameraPosition);
					copyTo(plugin.cameraOrientation, newCameraOrientation);
					visibilityCheckZoom = newZoom;
					tileVisibilityCached = false;
				}

				if (sceneContext.scene == scene) {
					plugin.cameraFocalPoint[0] = (int) client.getCameraFocalPointX();
					plugin.cameraFocalPoint[1] = (int) client.getCameraFocalPointZ();
					Arrays.fill(plugin.cameraShift, 0);
				} else {
					plugin.cameraShift[0] = plugin.cameraFocalPoint[0] - (int) client.getCameraFocalPointX();
					plugin.cameraShift[1] = plugin.cameraFocalPoint[1] - (int) client.getCameraFocalPointZ();
					plugin.cameraPosition[0] += plugin.cameraShift[0];
					plugin.cameraPosition[2] += plugin.cameraShift[1];
				}

				uboCompute.yaw.set(plugin.cameraOrientation[0]);
				uboCompute.pitch.set(plugin.cameraOrientation[1]);
				uboCompute.centerX.set(client.getCenterX());
				uboCompute.centerY.set(client.getCenterY());
				uboCompute.zoom.set(client.getScale());
				uboCompute.cameraX.set(plugin.cameraPosition[0]);
				uboCompute.cameraY.set(plugin.cameraPosition[1]);
				uboCompute.cameraZ.set(plugin.cameraPosition[2]);

				uboCompute.windDirectionX.set(cos(environmentManager.currentWindAngle));
				uboCompute.windDirectionZ.set(sin(environmentManager.currentWindAngle));
				uboCompute.windStrength.set(environmentManager.currentWindStrength);
				uboCompute.windCeiling.set(environmentManager.currentWindCeiling);
				uboCompute.windOffset.set(plugin.windOffset);

				if (plugin.configCharacterDisplacement) {
					// The local player needs to be added first for distance culling
					Model playerModel = localPlayer.getModel();
					if (playerModel != null)
						uboCompute.addCharacterPosition(lp.getX(), lp.getY(), (int) (Perspective.LOCAL_TILE_SIZE * 1.33f));
				}

				// Calculate the viewport dimensions before scaling in order to include the extra padding
				int viewportWidth = (int) (plugin.sceneViewport[2] / plugin.sceneViewportScale[0]);
				int viewportHeight = (int) (plugin.sceneViewport[3] / plugin.sceneViewportScale[1]);

				// Calculate projection matrix
				float[] projectionMatrix = Mat4.scale(client.getScale(), client.getScale(), 1);
				if (plugin.orthographicProjection) {
					Mat4.mul(projectionMatrix, Mat4.scale(ORTHOGRAPHIC_ZOOM, ORTHOGRAPHIC_ZOOM, -1));
					Mat4.mul(projectionMatrix, Mat4.orthographic(viewportWidth, viewportHeight, 40000));
				} else {
					Mat4.mul(projectionMatrix, Mat4.perspective(viewportWidth, viewportHeight, NEAR_PLANE));
				}


				// Calculate view matrix
				plugin.viewMatrix = Mat4.rotateX(plugin.cameraOrientation[1]);
				Mat4.mul(plugin.viewMatrix, Mat4.rotateY(plugin.cameraOrientation[0]));
				Mat4.mul(
					plugin.viewMatrix,
					Mat4.translate(-plugin.cameraPosition[0], -plugin.cameraPosition[1], -plugin.cameraPosition[2])
				);

				// Calculate view proj & inv matrix
				plugin.viewProjMatrix = Mat4.identity();
				Mat4.mul(plugin.viewProjMatrix, projectionMatrix);
				Mat4.mul(plugin.viewProjMatrix, plugin.viewMatrix);
				Mat4.extractPlanes(plugin.viewProjMatrix, plugin.cameraFrustum);
				plugin.invViewProjMatrix = Mat4.inverse(plugin.viewProjMatrix);

				if (sceneContext.scene == scene) {
					try {
						frameTimer.begin(Timer.UPDATE_ENVIRONMENT);
						environmentManager.update(sceneContext);
						frameTimer.end(Timer.UPDATE_ENVIRONMENT);

						frameTimer.begin(Timer.UPDATE_LIGHTS);
						lightManager.update(sceneContext, plugin.cameraShift, plugin.cameraFrustum);
						frameTimer.end(Timer.UPDATE_LIGHTS);
					} catch (Exception ex) {
						log.error("Error while updating environment or lights:", ex);
						plugin.stopPlugin();
						return;
					}
				}

				plugin.uboGlobal.cameraPos.set(plugin.cameraPosition);
				plugin.uboGlobal.viewMatrix.set(plugin.viewMatrix);
				plugin.uboGlobal.projectionMatrix.set(plugin.viewProjMatrix);
				plugin.uboGlobal.invProjectionMatrix.set(plugin.invViewProjMatrix);
				plugin.uboGlobal.pointLightsCount.set(sceneContext.numVisibleLights);
				plugin.uboGlobal.upload();
			}
		}

		if (plugin.configDynamicLights != DynamicLights.NONE && sceneContext.scene == scene && updateUniforms) {
			// Update lights UBO
			assert sceneContext.numVisibleLights <= UBOLights.MAX_LIGHTS;

			frameTimer.begin(Timer.UPDATE_LIGHTS);
			final float[] lightPosition = new float[4];
			final float[] lightColor = new float[4];
			for (int i = 0; i < sceneContext.numVisibleLights; i++) {
				final Light light = sceneContext.lights.get(i);
				final float lightRadiusSq = light.radius * light.radius;
				lightPosition[0] = light.pos[0] + plugin.cameraShift[0];
				lightPosition[1] = light.pos[1];
				lightPosition[2] = light.pos[2] + plugin.cameraShift[1];
				lightPosition[3] = lightRadiusSq;

				lightColor[0] = light.color[0] * light.strength;
				lightColor[1] = light.color[1] * light.strength;
				lightColor[2] = light.color[2] * light.strength;
				lightColor[3] = 0.0f;

				plugin.uboLights.setLight(i, lightPosition, lightColor);

				if (plugin.configTiledLighting) {
					// Pre-calculate the view space position of the light, to save having to do the multiplication in the culling shader
					lightPosition[3] = 1.0f;
					Mat4.mulVec(lightPosition, plugin.viewMatrix, lightPosition);
					lightPosition[3] = lightRadiusSq; // Restore lightRadiusSq
					plugin.uboLightsCulling.setLight(i, lightPosition, lightColor);
				}
			}

			plugin.uboLights.upload();
			plugin.uboLightsCulling.upload();
			frameTimer.end(Timer.UPDATE_LIGHTS);

			// Perform tiled lighting culling before the compute memory barrier, so it's performed asynchronously
			if (plugin.configTiledLighting) {
				plugin.updateTiledLightingFbo();
				assert plugin.fboTiledLighting != 0;

				frameTimer.begin(Timer.DRAW_TILED_LIGHTING);
				frameTimer.begin(Timer.RENDER_TILED_LIGHTING);

				glViewport(0, 0, plugin.tiledLightingResolution[0], plugin.tiledLightingResolution[1]);
				glBindFramebuffer(GL_FRAMEBUFFER, plugin.fboTiledLighting);

				glBindVertexArray(plugin.vaoTri);

				if (plugin.tiledLightingImageStoreProgram.isValid()) {
					plugin.tiledLightingImageStoreProgram.use();
					glDrawBuffer(GL_NONE);
					glDrawArrays(GL_TRIANGLES, 0, 3);
				} else {
					glDrawBuffer(GL_COLOR_ATTACHMENT0);
					int layerCount = plugin.configDynamicLights.getTiledLightingLayers();
					for (int layer = 0; layer < layerCount; layer++) {
						plugin.tiledLightingShaderPrograms.get(layer).use();
						glFramebufferTextureLayer(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, plugin.texTiledLighting, 0, layer);
						glDrawArrays(GL_TRIANGLES, 0, 3);
					}
				}

				frameTimer.end(Timer.RENDER_TILED_LIGHTING);
				frameTimer.end(Timer.DRAW_TILED_LIGHTING);
			}
		}
	}

	@Override
	public void postDrawScene() {
		if (sceneContext == null)
			return;

		tileVisibilityCached = true;

		frameTimer.end(Timer.DRAW_SCENE);
		frameTimer.begin(Timer.RENDER_FRAME);
		frameTimer.begin(Timer.UPLOAD_GEOMETRY);

		// The client only updates animations once per client tick, so we can skip updating geometry buffers,
		// but the compute shaders should still be executed in case the camera angle has changed.
		// Technically we could skip compute shaders as well when the camera is unchanged,
		// but it would only lead to micro stuttering when rotating the camera, compared to no rotation.
		if (!plugin.redrawPreviousFrame) {
			// Geometry buffers
			sceneContext.stagingBufferVertices.flip();
			sceneContext.stagingBufferUvs.flip();
			sceneContext.stagingBufferNormals.flip();
			hStagingBufferVertices.upload(sceneContext.stagingBufferVertices, dynamicOffsetVertices * 4L * VERTEX_SIZE);
			hStagingBufferUvs.upload(sceneContext.stagingBufferUvs, dynamicOffsetUvs * 4L * UV_SIZE);
			hStagingBufferNormals.upload(sceneContext.stagingBufferNormals, dynamicOffsetVertices * 4L * NORMAL_SIZE);
			sceneContext.stagingBufferVertices.clear();
			sceneContext.stagingBufferUvs.clear();
			sceneContext.stagingBufferNormals.clear();

			// Model buffers
			modelPassthroughBuffer.flip();
			hModelPassthroughBuffer.upload(modelPassthroughBuffer);
			modelPassthroughBuffer.clear();

			for (int i = 0; i < modelSortingBuffers.length; i++) {
				var buffer = modelSortingBuffers[i];
				buffer.flip();
				hModelSortingBuffers[i].upload(buffer);
				buffer.clear();
			}

			// Output buffers
			// each vertex is an ivec4, which is 16 bytes
			hRenderBufferVertices.ensureCapacity(renderBufferOffset * 16L);
			// each vertex is an ivec4, which is 16 bytes
			hRenderBufferUvs.ensureCapacity(renderBufferOffset * 16L);
			// each vertex is an ivec4, which is 16 bytes
			hRenderBufferNormals.ensureCapacity(renderBufferOffset * 16L);
			updateSceneVao(hRenderBufferVertices, hRenderBufferUvs, hRenderBufferNormals);
		}

		frameTimer.end(Timer.UPLOAD_GEOMETRY);
		frameTimer.begin(Timer.COMPUTE);

		uboCompute.upload();

		if (computeMode == ComputeMode.OPENCL) {
			// The docs for clEnqueueAcquireGLObjects say all pending GL operations must be completed before calling
			// clEnqueueAcquireGLObjects, and recommends calling glFinish() as the only portable way to do that.
			// However, no issues have been observed from not calling it, and so will leave disabled for now.
			// glFinish();

			clManager.compute(
				uboCompute.glBuffer,
				numPassthroughModels, numModelsToSort,
				hModelPassthroughBuffer, hModelSortingBuffers,
				hStagingBufferVertices, hStagingBufferUvs, hStagingBufferNormals,
				hRenderBufferVertices, hRenderBufferUvs, hRenderBufferNormals
			);
		} else {
			// Compute is split into a passthrough shader for unsorted models,
			// and multiple sizes of sorting shaders to better utilize the GPU

			// Bind shared buffers
			glBindBufferBase(GL43C.GL_SHADER_STORAGE_BUFFER, 1, hStagingBufferVertices.id);
			glBindBufferBase(GL43C.GL_SHADER_STORAGE_BUFFER, 2, hStagingBufferUvs.id);
			glBindBufferBase(GL43C.GL_SHADER_STORAGE_BUFFER, 3, hStagingBufferNormals.id);
			glBindBufferBase(GL43C.GL_SHADER_STORAGE_BUFFER, 4, hRenderBufferVertices.id);
			glBindBufferBase(GL43C.GL_SHADER_STORAGE_BUFFER, 5, hRenderBufferUvs.id);
			glBindBufferBase(GL43C.GL_SHADER_STORAGE_BUFFER, 6, hRenderBufferNormals.id);

			// unordered
			modelPassthroughComputeProgram.use();
			glBindBufferBase(GL43C.GL_SHADER_STORAGE_BUFFER, 0, hModelPassthroughBuffer.id);
			GL43C.glDispatchCompute(numPassthroughModels, 1, 1);

			for (int i = 0; i < numModelsToSort.length; i++) {
				if (numModelsToSort[i] == 0)
					continue;

				modelSortingComputePrograms.get(i).use();
				glBindBufferBase(GL43C.GL_SHADER_STORAGE_BUFFER, 0, hModelSortingBuffers[i].id);
				GL43C.glDispatchCompute(numModelsToSort[i], 1, 1);
			}
		}

		frameTimer.end(Timer.COMPUTE);

		checkGLErrors();

		if (!plugin.redrawPreviousFrame) {
			numPassthroughModels = 0;
			Arrays.fill(numModelsToSort, 0);
		}
	}

	@Override
	public void drawScenePaint(Scene scene, SceneTilePaint paint, int plane, int tileX, int tileY) {
		if (plugin.redrawPreviousFrame || paint.getBufferLen() <= 0)
			return;

		int vertexCount = paint.getBufferLen();

		++numPassthroughModels;
		modelPassthroughBuffer
			.ensureCapacity(16)
			.getBuffer()
			.put(paint.getBufferOffset())
			.put(paint.getUvBufferOffset())
			.put(vertexCount / 3)
			.put(renderBufferOffset)
			.put(0)
			.put(tileX * Perspective.LOCAL_TILE_SIZE)
			.put(0)
			.put(tileY * Perspective.LOCAL_TILE_SIZE);

		renderBufferOffset += vertexCount;
		plugin.drawnTileCount++;
	}

	@Override
	public void drawSceneTileModel(Scene scene, SceneTileModel model, int tileX, int tileY) {
		if (plugin.redrawPreviousFrame || model.getBufferLen() <= 0)
			return;

		final int localX = tileX * Perspective.LOCAL_TILE_SIZE;
		final int localY = 0;
		final int localZ = tileY * Perspective.LOCAL_TILE_SIZE;

		GpuIntBuffer b = modelPassthroughBuffer;
		b.ensureCapacity(16);
		IntBuffer buffer = b.getBuffer();

		int bufferLength = model.getBufferLen();

		// we packed a boolean into the buffer length of tiles so we can tell
		// which tiles have procedurally-generated underwater terrain.
		// unpack the boolean:
		boolean underwaterTerrain = (bufferLength & 1) == 1;
		// restore the bufferLength variable:
		bufferLength = bufferLength >> 1;

		if (underwaterTerrain) {
			// draw underwater terrain tile before surface tile

			// buffer length includes the generated underwater terrain, so it must be halved
			bufferLength /= 2;

			++numPassthroughModels;

			buffer.put(model.getBufferOffset() + bufferLength);
			buffer.put(model.getUvBufferOffset() + bufferLength);
			buffer.put(bufferLength / 3);
			buffer.put(renderBufferOffset);
			buffer.put(0);
			buffer.put(localX).put(localY).put(localZ);

			renderBufferOffset += bufferLength;
			plugin.drawnTileCount++;
		}

		++numPassthroughModels;

		buffer.put(model.getBufferOffset());
		buffer.put(model.getUvBufferOffset());
		buffer.put(bufferLength / 3);
		buffer.put(renderBufferOffset);
		buffer.put(0);
		buffer.put(localX).put(localY).put(localZ);

		renderBufferOffset += bufferLength;
		plugin.drawnTileCount++;
	}

	@Override
	public void draw(int overlayColor) {
		final GameState gameState = client.getGameState();
		if (gameState == GameState.STARTING) {
			frameTimer.end(Timer.DRAW_FRAME);
			return;
		}

		try {
			plugin.prepareInterfaceTexture();
		} catch (Exception ex) {
			// Fixes: https://github.com/runelite/runelite/issues/12930
			// Gracefully Handle loss of opengl buffers and context
			log.warn("prepareInterfaceTexture exception", ex);
			plugin.restartPlugin();
			return;
		}

		// Upon logging in, the client will draw some frames with zero geometry before it hides the login screen
		if (gameState.getState() >= GameState.LOGGED_IN.getState() && renderBufferOffset > 0)
			plugin.hasLoggedIn = true;

		// Draw 3d scene
		if (plugin.hasLoggedIn && sceneContext != null && plugin.sceneViewport != null) {
			// Before reading the SSBOs written to from postDrawScene() we must insert a barrier
			if (computeMode == ComputeMode.OPENCL) {
				clManager.finish();
			} else {
				GL43C.glMemoryBarrier(GL43C.GL_SHADER_STORAGE_BARRIER_BIT);
			}

			float[] fogColor = ColorUtils.linearToSrgb(environmentManager.currentFogColor);
			float fogDepth = 0;
			switch (config.fogDepthMode()) {
				case USER_DEFINED:
					fogDepth = config.fogDepth();
					break;
				case DYNAMIC:
					fogDepth = environmentManager.currentFogDepth;
					break;
			}
			fogDepth *= min(plugin.getDrawDistance(), 90) / 10.f;
			plugin.uboGlobal.useFog.set(fogDepth > 0 ? 1 : 0);
			plugin.uboGlobal.fogDepth.set(fogDepth);
			plugin.uboGlobal.fogColor.set(fogColor);

			plugin.uboGlobal.drawDistance.set((float) plugin.getDrawDistance());
			plugin.uboGlobal.expandedMapLoadingChunks.set(sceneContext.expandedMapLoadingChunks);
			plugin.uboGlobal.colorBlindnessIntensity.set(config.colorBlindnessIntensity() / 100.f);

			float[] waterColorHsv = ColorUtils.srgbToHsv(environmentManager.currentWaterColor);
			float lightBrightnessMultiplier = 0.8f;
			float midBrightnessMultiplier = 0.45f;
			float darkBrightnessMultiplier = 0.05f;
			float[] waterColorLight = ColorUtils.linearToSrgb(ColorUtils.hsvToSrgb(new float[] {
				waterColorHsv[0],
				waterColorHsv[1],
				waterColorHsv[2] * lightBrightnessMultiplier
			}));
			float[] waterColorMid = ColorUtils.linearToSrgb(ColorUtils.hsvToSrgb(new float[] {
				waterColorHsv[0],
				waterColorHsv[1],
				waterColorHsv[2] * midBrightnessMultiplier
			}));
			float[] waterColorDark = ColorUtils.linearToSrgb(ColorUtils.hsvToSrgb(new float[] {
				waterColorHsv[0],
				waterColorHsv[1],
				waterColorHsv[2] * darkBrightnessMultiplier
			}));
			plugin.uboGlobal.waterColorLight.set(waterColorLight);
			plugin.uboGlobal.waterColorMid.set(waterColorMid);
			plugin.uboGlobal.waterColorDark.set(waterColorDark);

			plugin.uboGlobal.gammaCorrection.set(plugin.getGammaCorrection());
			float ambientStrength = environmentManager.currentAmbientStrength;
			float directionalStrength = environmentManager.currentDirectionalStrength;
			if (config.useLegacyBrightness()) {
				float factor = config.legacyBrightness() / 20f;
				ambientStrength *= factor;
				directionalStrength *= factor;
			}
			plugin.uboGlobal.ambientStrength.set(ambientStrength);
			plugin.uboGlobal.ambientColor.set(environmentManager.currentAmbientColor);
			plugin.uboGlobal.lightStrength.set(directionalStrength);
			plugin.uboGlobal.lightColor.set(environmentManager.currentDirectionalColor);

			plugin.uboGlobal.underglowStrength.set(environmentManager.currentUnderglowStrength);
			plugin.uboGlobal.underglowColor.set(environmentManager.currentUnderglowColor);

			plugin.uboGlobal.groundFogStart.set(environmentManager.currentGroundFogStart);
			plugin.uboGlobal.groundFogEnd.set(environmentManager.currentGroundFogEnd);
			plugin.uboGlobal.groundFogOpacity.set(config.groundFog() ?
				environmentManager.currentGroundFogOpacity :
				0);

			// Lights & lightning
			plugin.uboGlobal.pointLightsCount.set(sceneContext.numVisibleLights);
			plugin.uboGlobal.lightningBrightness.set(environmentManager.getLightningBrightness());

			plugin.uboGlobal.saturation.set(config.saturation() / 100f);
			plugin.uboGlobal.contrast.set(config.contrast() / 100f);
			plugin.uboGlobal.underwaterEnvironment.set(environmentManager.isUnderwater() ? 1 : 0);
			plugin.uboGlobal.underwaterCaustics.set(config.underwaterCaustics() ? 1 : 0);
			plugin.uboGlobal.underwaterCausticsColor.set(environmentManager.currentUnderwaterCausticsColor);
			plugin.uboGlobal.underwaterCausticsStrength.set(environmentManager.currentUnderwaterCausticsStrength);
			plugin.uboGlobal.elapsedTime.set((float) (plugin.elapsedTime % MAX_FLOAT_WITH_128TH_PRECISION));

			float[] lightViewMatrix = Mat4.rotateX(environmentManager.currentSunAngles[0]);
			Mat4.mul(lightViewMatrix, Mat4.rotateY(PI - environmentManager.currentSunAngles[1]));
			// Extract the 3rd column from the light view matrix (the float array is column-major).
			// This produces the light's direction vector in world space, which we negate in order to
			// get the light's direction vector pointing away from each fragment
			plugin.uboGlobal.lightDir.set(-lightViewMatrix[2], -lightViewMatrix[6], -lightViewMatrix[10]);

			if (plugin.configColorFilter != ColorFilter.NONE) {
				plugin.uboGlobal.colorFilter.set(plugin.configColorFilter.ordinal());
				plugin.uboGlobal.colorFilterPrevious.set(plugin.configColorFilterPrevious.ordinal());
				long timeSinceChange = System.currentTimeMillis() - plugin.colorFilterChangedAt;
				plugin.uboGlobal.colorFilterFade.set(clamp(timeSinceChange / COLOR_FILTER_FADE_DURATION, 0, 1));
			}

			if (plugin.configShadowsEnabled && plugin.fboShadowMap != 0
				&& environmentManager.currentDirectionalStrength > 0) {
				frameTimer.begin(Timer.RENDER_SHADOWS);

				// Render to the shadow depth map
				glViewport(0, 0, plugin.shadowMapResolution, plugin.shadowMapResolution);
				glBindFramebuffer(GL_FRAMEBUFFER, plugin.fboShadowMap);
				glClearDepth(1);
				glClear(GL_DEPTH_BUFFER_BIT);
				glDepthFunc(GL_LEQUAL);

				shadowProgram.use();

				final int camX = plugin.cameraFocalPoint[0];
				final int camY = plugin.cameraFocalPoint[1];

				final int drawDistanceSceneUnits =
					min(config.shadowDistance().getValue(), plugin.getDrawDistance())
					* Perspective.LOCAL_TILE_SIZE / 2;
				final int east = min(camX + drawDistanceSceneUnits, Perspective.LOCAL_TILE_SIZE * Constants.SCENE_SIZE);
				final int west = max(camX - drawDistanceSceneUnits, 0);
				final int north = min(camY + drawDistanceSceneUnits, Perspective.LOCAL_TILE_SIZE * Constants.SCENE_SIZE);
				final int south = max(camY - drawDistanceSceneUnits, 0);
				final int width = east - west;
				final int height = north - south;
				final int depthScale = 10000;

				final int maxDrawDistance = 90;
				final float maxScale = 0.7f;
				final float minScale = 0.4f;
				final float scaleMultiplier = 1.0f - (plugin.getDrawDistance() / (maxDrawDistance * maxScale));
				float scale = mix(maxScale, minScale, scaleMultiplier);
				float[] lightProjectionMatrix = Mat4.identity();
				Mat4.mul(lightProjectionMatrix, Mat4.scale(scale, scale, scale));
				Mat4.mul(lightProjectionMatrix, Mat4.orthographic(width, height, depthScale));
				Mat4.mul(lightProjectionMatrix, lightViewMatrix);
				Mat4.mul(lightProjectionMatrix, Mat4.translate(-(width / 2f + west), 0, -(height / 2f + south)));

				plugin.uboGlobal.lightProjectionMatrix.set(lightProjectionMatrix);
				plugin.uboGlobal.upload();

				glEnable(GL_CULL_FACE);
				glEnable(GL_DEPTH_TEST);

				glBindVertexArray(vaoScene);
				glDrawArrays(GL_TRIANGLES, 0, renderBufferOffset);

				glDisable(GL_CULL_FACE);
				glDisable(GL_DEPTH_TEST);

				frameTimer.end(Timer.RENDER_SHADOWS);
			}

			plugin.uboGlobal.upload();
			sceneProgram.use();

			glBindFramebuffer(GL_DRAW_FRAMEBUFFER, plugin.fboScene);
			if (plugin.msaaSamples > 1) {
				glEnable(GL_MULTISAMPLE);
			} else {
				glDisable(GL_MULTISAMPLE);
			}
			glViewport(0, 0, plugin.sceneResolution[0], plugin.sceneResolution[1]);

			// Clear scene
			frameTimer.begin(Timer.CLEAR_SCENE);

			float[] gammaCorrectedFogColor = pow(fogColor, plugin.getGammaCorrection());
			glClearColor(
				gammaCorrectedFogColor[0],
				gammaCorrectedFogColor[1],
				gammaCorrectedFogColor[2],
				1f
			);
			glClearDepth(0);
			glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
			frameTimer.end(Timer.CLEAR_SCENE);

			frameTimer.begin(Timer.RENDER_SCENE);

			// We just allow the GL to do face culling. Note this requires the priority renderer
			// to have logic to disregard culled faces in the priority depth testing.
			glEnable(GL_CULL_FACE);
			glCullFace(GL_BACK);

			// Enable blending for alpha
			glEnable(GL_BLEND);
			glBlendFuncSeparate(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA, GL_ZERO, GL_ONE);

			// Draw with buffers bound to scene VAO
			glBindVertexArray(vaoScene);

			// When there are custom tiles, we need depth testing to draw them in the correct order, but the rest of the
			// scene doesn't support depth testing, so we only write depths for custom tiles.
			if (sceneContext.staticCustomTilesVertexCount > 0) {
				// Draw gap filler tiles first, without depth testing
				if (sceneContext.staticGapFillerTilesVertexCount > 0) {
					glDisable(GL_DEPTH_TEST);
					glDrawArrays(
						GL_TRIANGLES,
						sceneContext.staticGapFillerTilesOffset,
						sceneContext.staticGapFillerTilesVertexCount
					);
				}

				glEnable(GL_DEPTH_TEST);
				glDepthFunc(GL_GREATER);

				// Draw custom tiles, writing depth
				glDepthMask(true);
				glDrawArrays(
					GL_TRIANGLES,
					sceneContext.staticCustomTilesOffset,
					sceneContext.staticCustomTilesVertexCount
				);

				// Draw the rest of the scene with depth testing, but not against itself
				glDepthMask(false);
				glDrawArrays(
					GL_TRIANGLES,
					sceneContext.staticVertexCount,
					renderBufferOffset - sceneContext.staticVertexCount
				);
			} else {
				// Draw everything without depth testing
				glDisable(GL_DEPTH_TEST);
				glDrawArrays(GL_TRIANGLES, 0, renderBufferOffset);
			}

			frameTimer.end(Timer.RENDER_SCENE);

			glDisable(GL_BLEND);
			glDisable(GL_CULL_FACE);
			glDisable(GL_MULTISAMPLE);
			glDisable(GL_DEPTH_TEST);
			glDepthMask(true);
			glUseProgram(0);

			glBindFramebuffer(GL_READ_FRAMEBUFFER, plugin.fboScene);
			if (plugin.fboSceneResolve != 0) {
				// Blit from the scene FBO to the multisample resolve FBO
				glBindFramebuffer(GL_DRAW_FRAMEBUFFER, plugin.fboSceneResolve);
				glBlitFramebuffer(
					0, 0, plugin.sceneResolution[0], plugin.sceneResolution[1],
					0, 0, plugin.sceneResolution[0], plugin.sceneResolution[1],
					GL_COLOR_BUFFER_BIT, GL_NEAREST
				);
				glBindFramebuffer(GL_READ_FRAMEBUFFER, plugin.fboSceneResolve);
			}

			// Blit from the resolved FBO to the default FBO
			glBindFramebuffer(GL_DRAW_FRAMEBUFFER, plugin.awtContext.getFramebuffer(false));
			glBlitFramebuffer(
				0,
				0,
				plugin.sceneResolution[0],
				plugin.sceneResolution[1],
				plugin.sceneViewport[0],
				plugin.sceneViewport[1],
				plugin.sceneViewport[0] + plugin.sceneViewport[2],
				plugin.sceneViewport[1] + plugin.sceneViewport[3],
				GL_COLOR_BUFFER_BIT,
				config.sceneScalingMode().glFilter
			);
		} else {
			glClearColor(0, 0, 0, 1f);
			glClear(GL_COLOR_BUFFER_BIT);
		}

		plugin.drawUi(overlayColor);

		try {
			frameTimer.begin(Timer.SWAP_BUFFERS);
			plugin.awtContext.swapBuffers();
			frameTimer.end(Timer.SWAP_BUFFERS);
			drawManager.processDrawComplete(plugin::screenshot);
		} catch (RuntimeException ex) {
			// this is always fatal
			if (!plugin.canvas.isValid()) {
				// this might be AWT shutting down on VM shutdown, ignore it
				return;
			}

			log.error("Unable to swap buffers:", ex);
		}

		glBindFramebuffer(GL_FRAMEBUFFER, plugin.awtContext.getFramebuffer(false));

		frameTimer.end(Timer.DRAW_FRAME);
		frameTimer.end(Timer.RENDER_FRAME);
		frameTimer.endFrameAndReset();
		frameModelInfoMap.clear();
		checkGLErrors();
	}

	@Override
	public void reloadScene() {
		assert client.isClientThread() : "Loading a scene is unsafe while the client can modify it";
		if (client.getGameState().getState() < GameState.LOGGED_IN.getState())
			return;

		Scene scene = client.getTopLevelWorldView().getScene();
		loadScene(scene);
		if (plugin.skipScene == scene)
			plugin.skipScene = null;
		swapScene(scene);
	}

	@Override
	public void loadScene(Scene scene) {
		if (!plugin.isActive())
			return;

		int expandedChunks = plugin.getExpandedMapLoadingChunks();
		if (HDUtils.sceneIntersects(scene, expandedChunks, areaManager.getArea("PLAYER_OWNED_HOUSE"))) {
			// Reload once the POH is done loading, upon first entering the POH
			if (sceneContext == null || !sceneContext.isInHouse)
				reloadSceneIn(2);
		} else if (plugin.skipScene != scene && HDUtils.sceneIntersects(
			scene,
			expandedChunks,
			areaManager.getArea("THE_GAUNTLET")
		)) {
			// Some game objects in The Gauntlet are spawned in too late for the initial scene load,
			// so we skip the first scene load and trigger another scene load the next game tick
			reloadSceneNextGameTick();
			plugin.skipScene = scene;
			return;
		}

		if (plugin.useLowMemoryMode)
			return; // Force scene loading to happen on the client thread

		loadSceneInternal(scene);
	}

	@Override
	public boolean isLoadingScene() {
		return nextSceneContext != null;
	}

	public synchronized void loadSceneInternal(Scene scene) {
		if (nextSceneContext != null)
			nextSceneContext.destroy();
		nextSceneContext = null;

		try {
			nextSceneContext = new LegacySceneContext(
				client,
				scene,
				plugin.getExpandedMapLoadingChunks(),
				sceneContext
			);
			// If area hiding was determined to be incorrect previously, keep it disabled
			nextSceneContext.forceDisableAreaHiding = sceneContext != null && sceneContext.forceDisableAreaHiding;

			environmentManager.loadSceneEnvironments(nextSceneContext);
			sceneUploader.upload(nextSceneContext);
		} catch (OutOfMemoryError oom) {
			log.error(
				"Ran out of memory while loading scene (32-bit: {}, low memory mode: {}, cache size: {})",
				HDUtils.is32Bit(), plugin.useLowMemoryMode, config.modelCacheSizeMiB(), oom
			);
			plugin.displayOutOfMemoryMessage();
			plugin.stopPlugin();
		} catch (Throwable ex) {
			log.error("Error while loading scene:", ex);
			plugin.stopPlugin();
		}
	}

	@Override
	public synchronized void swapScene(Scene scene) {
		if (!plugin.isActive() || plugin.skipScene == scene) {
			plugin.redrawPreviousFrame = true;
			return;
		}

		// If the scene wasn't loaded by a call to loadScene, load it synchronously instead
		if (nextSceneContext == null) {
			loadSceneInternal(scene);
			if (nextSceneContext == null)
				return; // Return early if scene loading failed
		}

		if (computeMode == ComputeMode.OPENCL) {
			clManager.uploadTileHeights(scene);
		} else {
			initializeTileHeightMap(scene);
		}

		tileVisibilityCached = false;
		lightManager.loadSceneLights(nextSceneContext, sceneContext);
		fishingSpotReplacer.despawnRuneLiteObjects();
		npcDisplacementCache.clear();

		if (sceneContext != null)
			sceneContext.destroy();
		sceneContext = nextSceneContext;
		nextSceneContext = null;
		assert sceneContext != null;

		sceneUploader.prepareBeforeSwap(sceneContext);

		sceneContext.staticUnorderedModelBuffer.flip();

		dynamicOffsetVertices = sceneContext.getVertexOffset();
		dynamicOffsetUvs = sceneContext.getUvOffset();

		sceneContext.stagingBufferVertices.flip();
		sceneContext.stagingBufferUvs.flip();
		sceneContext.stagingBufferNormals.flip();
		hStagingBufferVertices.upload(sceneContext.stagingBufferVertices);
		hStagingBufferUvs.upload(sceneContext.stagingBufferUvs);
		hStagingBufferNormals.upload(sceneContext.stagingBufferNormals);
		sceneContext.stagingBufferVertices.clear();
		sceneContext.stagingBufferUvs.clear();
		sceneContext.stagingBufferNormals.clear();

		if (sceneContext.intersects(areaManager.getArea("PLAYER_OWNED_HOUSE"))) {
			sceneContext.isInHouse = true;
			sceneContext.isInChambersOfXeric = false;
		} else {
			sceneContext.isInHouse = false;
			sceneContext.isInChambersOfXeric = sceneContext.intersects(areaManager.getArea("CHAMBERS_OF_XERIC"));
		}
	}

	private void reloadSceneNextGameTick() {
		reloadSceneIn(1);
	}

	private void reloadSceneIn(int gameTicks) {
		assert gameTicks > 0 : "A value <= 0 will not reload the scene";
		if (gameTicks > gameTicksUntilSceneReload)
			gameTicksUntilSceneReload = gameTicks;
	}

	@Override
	public boolean tileInFrustum(
		Scene scene,
		float pitchSin,
		float pitchCos,
		float yawSin,
		float yawCos,
		int cameraX,
		int cameraY,
		int cameraZ,
		int plane,
		int tileExX,
		int tileExY
	) {
		if (sceneContext == null)
			return false;

		if (plugin.orthographicProjection)
			return true;

		if (tileVisibilityCached)
			return tileIsVisible[plane][tileExX][tileExY];

		int[][][] tileHeights = scene.getTileHeights();
		int x = ((tileExX - sceneContext.sceneOffset) << Perspective.LOCAL_COORD_BITS) + 64;
		int z = ((tileExY - sceneContext.sceneOffset) << Perspective.LOCAL_COORD_BITS) + 64;
		int y = GROUND_MIN_Y + max(
			tileHeights[plane][tileExX][tileExY],
			tileHeights[plane][tileExX][tileExY + 1],
			tileHeights[plane][tileExX + 1][tileExY],
			tileHeights[plane][tileExX + 1][tileExY + 1]
		);

		if (sceneContext.scene == scene) {
			int depthLevel = sceneContext.underwaterDepthLevels[plane][tileExX][tileExY];
			if (depthLevel > 0)
				y += ProceduralGenerator.DEPTH_LEVEL_SLOPE[depthLevel - 1] - GROUND_MIN_Y;
		}

		x -= (int) plugin.cameraPosition[0];
		y -= (int) plugin.cameraPosition[1];
		z -= (int) plugin.cameraPosition[2];

		final int tileRadius = 96; // ~ 64 * sqrt(2)
		final int leftClip = client.getRasterizer3D_clipNegativeMidX();
		final int rightClip = client.getRasterizer3D_clipMidX2();
		final int topClip = client.getRasterizer3D_clipNegativeMidY();

		// Transform the local coordinates using the yaw (horizontal rotation)
		final float transformedZ = yawCos * z - yawSin * x;
		final float depth = pitchCos * tileRadius + pitchSin * y + pitchCos * transformedZ;

		boolean visible = false;

		// Check if the tile is within the near plane of the frustum
		if (depth > NEAR_PLANE) {
			final float transformedX = z * yawSin + yawCos * x;
			final float leftPoint = transformedX - tileRadius;
			// Check left and right bounds
			if (leftPoint * visibilityCheckZoom < rightClip * depth) {
				final float rightPoint = transformedX + tileRadius;
				if (rightPoint * visibilityCheckZoom > leftClip * depth) {
					// Transform the local Y using pitch (vertical rotation)
					final float transformedY = pitchCos * y - transformedZ * pitchSin;
					final float bottomPoint = transformedY + pitchSin * tileRadius;
					// Check top bound (we skip bottom bound to avoid computing model heights)
					visible = bottomPoint * visibilityCheckZoom > topClip * depth;
				}
			}
		}

		return tileIsVisible[plane][tileExX][tileExY] = visible;
	}

	/**
	 * Check is a model is visible and should be drawn.
	 */
	public boolean isOutsideViewport(
		Model model,
		int modelRadius,
		float pitchSin,
		float pitchCos,
		float yawSin,
		float yawCos,
		int x,
		int y,
		int z
	) {
		if (sceneContext == null)
			return true;

		if (plugin.orthographicProjection)
			return false;

		final int leftClip = client.getRasterizer3D_clipNegativeMidX();
		final int rightClip = client.getRasterizer3D_clipMidX2();
		final int topClip = client.getRasterizer3D_clipNegativeMidY();
		final int bottomClip = client.getRasterizer3D_clipMidY2();

		final float transformedZ = yawCos * z - yawSin * x;
		final float depth = pitchCos * modelRadius + pitchSin * y + pitchCos * transformedZ;

		if (depth > NEAR_PLANE) {
			final float transformedX = z * yawSin + yawCos * x;
			final float leftPoint = transformedX - modelRadius;
			if (leftPoint * visibilityCheckZoom < rightClip * depth) {
				final float rightPoint = transformedX + modelRadius;
				if (rightPoint * visibilityCheckZoom > leftClip * depth) {
					final float transformedY = pitchCos * y - transformedZ * pitchSin;
					final float transformedRadius = pitchSin * modelRadius;
					final float bottomExtent = pitchCos * model.getBottomY() + transformedRadius;
					final float bottomPoint = transformedY + bottomExtent;
					if (bottomPoint * visibilityCheckZoom > topClip * depth) {
						final float topExtent = pitchCos * model.getModelHeight() + transformedRadius;
						final float topPoint = transformedY - topExtent;
						return topPoint * visibilityCheckZoom >= bottomClip * depth; // inverted check
					}
				}
			}
		}
		return true;
	}

	/**
	 * Draw a Renderable in the scene
	 *
	 * @param projection  Unused
	 * @param scene      Unused
	 * @param renderable  Can be an Actor (Player or NPC), DynamicObject, GraphicsObject, TileItem, Projectile or a raw Model.
	 * @param orientation Rotation around the up-axis, from 0 to 2048 exclusive, 2048 indicating a complete rotation.
	 * @param x           The Renderable's X offset relative to {@link Client#getCameraX()}.
	 * @param y           The Renderable's Y offset relative to {@link Client#getCameraZ()}.
	 * @param z           The Renderable's Z offset relative to {@link Client#getCameraY()}.
	 * @param hash        A unique hash of the renderable consisting of some useful information. See {@link ModelHash} for more details.
	 */
	@Override
	public void draw(Projection projection, @Nullable Scene scene, Renderable renderable, int orientation, int x, int y, int z, long hash) {
		if (sceneContext == null)
			return;

		// Hide everything outside the current area if area hiding is enabled
		if (sceneContext.currentArea != null) {
			assert sceneContext.sceneBase != null;
			boolean inArea = sceneContext.currentArea.containsPoint(
				sceneContext.sceneBase[0] + (x >> Perspective.LOCAL_COORD_BITS),
				sceneContext.sceneBase[1] + (z >> Perspective.LOCAL_COORD_BITS),
				sceneContext.sceneBase[2] + client.getTopLevelWorldView().getPlane()
			);
			if (!inArea)
				return;
		}

		if (plugin.enableDetailedTimers)
			frameTimer.begin(Timer.GET_MODEL);

		Model model, offsetModel;
		try {
			// getModel may throw an exception from vanilla client code
			if (renderable instanceof Model) {
				model = (Model) renderable;
				offsetModel = model.getUnskewedModel();
				if (offsetModel == null)
					offsetModel = model;
			} else {
				offsetModel = model = renderable.getModel();
			}
			if (model == null || model.getFaceCount() == 0) {
				// skip models with zero faces
				// this does seem to happen sometimes (mostly during loading)
				// should save some CPU cycles here and there
				return;
			}
		} catch (Exception ex) {
			// Vanilla happens to handle exceptions thrown here gracefully, but we handle them explicitly anyway
			return;
		} finally {
			if (plugin.enableDetailedTimers)
				frameTimer.end(Timer.GET_MODEL);
		}

		// Apply height to renderable from the model
		int height = model.getModelHeight();
		if (model != renderable)
			renderable.setModelHeight(height);

		model.calculateBoundsCylinder();
		int modelRadius = model.getXYZMag(); // Model radius excluding height (model.getRadius() includes height)

		if (projection instanceof IntProjection) {
			var p = (IntProjection) projection;
			if (isOutsideViewport(
				model,
				modelRadius,
				p.getPitchSin(),
				p.getPitchCos(),
				p.getYawSin(),
				p.getYawCos(),
				x - p.getCameraX(),
				y - p.getCameraY(),
				z - p.getCameraZ()
			)) {
				return;
			}
		}

		client.checkClickbox(projection, model, orientation, x, y, z, hash);

		if (plugin.redrawPreviousFrame)
			return;

		if (plugin.enableDetailedTimers)
			frameTimer.begin(Timer.DRAW_RENDERABLE);

		eightIntWrite[3] = renderBufferOffset;
		eightIntWrite[4] = orientation;
		eightIntWrite[5] = x;
		eightIntWrite[6] = y << 16 | height & 0xFFFF; // Pack Y into the upper bits to easily preserve the sign
		eightIntWrite[7] = z;

		int plane = ModelHash.getPlane(hash);
		int faceCount;
		if (sceneContext.id == (offsetModel.getSceneId() & LegacySceneUploader.SCENE_ID_MASK)) {
			// The model is part of the static scene buffer. The Renderable will then almost always be the Model instance, but if the scene
			// is reuploaded without triggering the LOADING game state, it's possible for static objects which may only temporarily become
			// animated to also be uploaded. This results in the Renderable being converted to a DynamicObject, whose `getModel` returns the
			// original static Model after the animation is done playing. One such example is in the POH, after it has been reuploaded in
			// order to cache newly loaded static models, and you subsequently attempt to interact with a wardrobe triggering its animation.
			faceCount = min(MAX_FACE_COUNT, offsetModel.getFaceCount());
			int vertexOffset = offsetModel.getBufferOffset();
			int uvOffset = offsetModel.getUvBufferOffset();
			boolean hillskew = offsetModel != model;

			eightIntWrite[0] = vertexOffset;
			eightIntWrite[1] = uvOffset;
			eightIntWrite[2] = faceCount;
			eightIntWrite[4] |= (hillskew ? 1 : 0) << 26 | plane << 24;

			plugin.drawnStaticRenderableCount = plugin.drawnStaticRenderableCount + 1;
		} else {
			int uuid = ModelHash.generateUuid(client, hash, renderable);
			int[] worldPos = sceneContext.localToWorld(x, z, plane);
			ModelOverride modelOverride = modelOverrideManager.getOverride(uuid, worldPos);
			if (modelOverride.hide)
				return;

			// Disable color overrides when caching is disabled, since they are expensive on dynamic models
			if (!plugin.configModelCaching && modelOverride.colorOverrides != null)
				modelOverride = ModelOverride.NONE;

			int preOrientation = 0;
			if (ModelHash.getType(hash) == ModelHash.TYPE_OBJECT) {
				int tileExX = (x >> Perspective.LOCAL_COORD_BITS) + sceneContext.sceneOffset;
				int tileExY = (z >> Perspective.LOCAL_COORD_BITS) + sceneContext.sceneOffset;
				if (0 <= tileExX && tileExX < Constants.EXTENDED_SCENE_SIZE && 0 <= tileExY && tileExY < Constants.EXTENDED_SCENE_SIZE) {
					Tile tile = sceneContext.scene.getExtendedTiles()[plane][tileExX][tileExY];
					int config;
					if (tile != null && (config = HDUtils.getObjectConfig(tile, hash)) != -1) {
						preOrientation = HDUtils.getModelPreOrientation(config);
					} else if (plane > 0) {
						// Might be on a bridge tile
						tile = sceneContext.scene.getExtendedTiles()[plane - 1][tileExX][tileExY];
						if (tile != null && tile.getBridge() != null
							&& (config = HDUtils.getObjectConfig(tile, hash)) != -1)
							preOrientation = HDUtils.getModelPreOrientation(config);
					}
				}
			}

			// Temporary model (animated or otherwise not a static Model already in the scene buffer)
			if (plugin.enableDetailedTimers)
				frameTimer.begin(Timer.MODEL_BATCHING);
			ModelOffsets modelOffsets = null;
			if (plugin.configModelBatching || plugin.configModelCaching) {
				modelHasher.setModel(model, modelOverride, preOrientation);
				// Disable model batching for models which have been excluded from the scene buffer,
				// because we want to avoid having to fetch the model override
				if (plugin.configModelBatching && offsetModel.getSceneId() != LegacySceneUploader.EXCLUDED_FROM_SCENE_BUFFER) {
					modelOffsets = frameModelInfoMap.get(modelHasher.batchHash);
					if (modelOffsets != null && modelOffsets.faceCount != model.getFaceCount())
						modelOffsets = null; // Assume there's been a hash collision
				}
			}
			if (plugin.enableDetailedTimers)
				frameTimer.end(Timer.MODEL_BATCHING);

			if (modelOffsets != null && modelOffsets.faceCount == model.getFaceCount()) {
				faceCount = modelOffsets.faceCount;
				eightIntWrite[0] = modelOffsets.vertexOffset;
				eightIntWrite[1] = modelOffsets.uvOffset;
				eightIntWrite[2] = modelOffsets.faceCount;
			} else {
				if (plugin.enableDetailedTimers)
					frameTimer.begin(Timer.MODEL_PUSHING);

				int vertexOffset = dynamicOffsetVertices + sceneContext.getVertexOffset();
				int uvOffset = dynamicOffsetUvs + sceneContext.getUvOffset();

				modelPusher.pushModel(sceneContext, null, uuid, model, modelOverride, preOrientation, true);

				faceCount = sceneContext.modelPusherResults[0];
				if (sceneContext.modelPusherResults[1] == 0)
					uvOffset = -1;

				if (plugin.enableDetailedTimers)
					frameTimer.end(Timer.MODEL_PUSHING);

				eightIntWrite[0] = vertexOffset;
				eightIntWrite[1] = uvOffset;
				eightIntWrite[2] = faceCount;

				// add this temporary model to the map for batching purposes
				if (plugin.configModelBatching && modelOffsets == null)
					frameModelInfoMap.put(modelHasher.batchHash, new ModelOffsets(faceCount, vertexOffset, uvOffset));
			}

			if (eightIntWrite[0] != -1)
				plugin.drawnDynamicRenderableCount = plugin.drawnDynamicRenderableCount + 1;

			if (plugin.configCharacterDisplacement && renderable instanceof Actor) {
				if (plugin.enableDetailedTimers)
					frameTimer.begin(Timer.CHARACTER_DISPLACEMENT);
				if (renderable instanceof NPC) {
					var npc = (NPC) renderable;
					var entry = npcDisplacementCache.get(npc);
					if (entry.canDisplace) {
						int displacementRadius = entry.idleRadius;
						if (displacementRadius == -1) {
							displacementRadius = modelRadius; // Fallback to model radius since we don't know the idle radius yet
							if (npc.getIdlePoseAnimation() == npc.getPoseAnimation() && npc.getAnimation() == -1) {
								displacementRadius *= 2; // Double the idle radius, so that it fits most other animations
								entry.idleRadius = displacementRadius;
							}
						}
						uboCompute.addCharacterPosition(x, z, displacementRadius);
					}
				} else if (renderable instanceof Player && renderable != client.getLocalPlayer()) {
					uboCompute.addCharacterPosition(x, z, (int) (Perspective.LOCAL_TILE_SIZE * 1.33f));
				}
				if (plugin.enableDetailedTimers)
					frameTimer.end(Timer.CHARACTER_DISPLACEMENT);
			}
		}

		if (plugin.enableDetailedTimers)
			frameTimer.end(Timer.DRAW_RENDERABLE);

		if (eightIntWrite[0] == -1)
			return; // Hidden model

		bufferForTriangles(faceCount)
			.ensureCapacity(8)
			.put(eightIntWrite);
		renderBufferOffset += faceCount * 3;
	}

	/**
	 * returns the correct buffer based on triangle count and updates model count
	 */
	public GpuIntBuffer bufferForTriangles(int triangles) {
		for (int i = 0; i < numSortingBins; i++) {
			if (modelSortingBinFaceCounts[i] >= triangles) {
				++numModelsToSort[i];
				return modelSortingBuffers[i];
			}
		}

		throw new IllegalStateException(
			"Ran into a model with more triangles than the plugin supports (" +
			triangles + " > " + MAX_FACE_COUNT + ")");
	}
}

package rs117.hd.renderer.legacy;

import javax.annotation.Nullable;
import net.runelite.api.*;
import rs117.hd.scene.SceneContext;
import rs117.hd.utils.buffer.GpuFloatBuffer;
import rs117.hd.utils.buffer.GpuIntBuffer;

import static rs117.hd.utils.MathUtils.*;

public class LegacySceneContext extends SceneContext {
	public final int id = RAND.nextInt() & LegacySceneUploader.SCENE_ID_MASK;

	public boolean forceDisableAreaHiding;

	public GpuIntBuffer staticUnorderedModelBuffer;
	public GpuIntBuffer stagingBufferVertices;
	public GpuFloatBuffer stagingBufferUvs;
	public GpuFloatBuffer stagingBufferNormals;

	public LegacySceneContext(
		Client client,
		Scene scene,
		int expandedMapLoadingChunks,
		@Nullable LegacySceneContext previous
	) {
		super(client, scene, expandedMapLoadingChunks);

		if (previous == null) {
			staticUnorderedModelBuffer = new GpuIntBuffer();
			stagingBufferVertices = new GpuIntBuffer();
			stagingBufferUvs = new GpuFloatBuffer();
			stagingBufferNormals = new GpuFloatBuffer();
		} else {
			// Because scene contexts are always swapped on the client thread, it is guaranteed to only be
			// in use by the client thread, meaning we can reuse all of its buffers if we are loading the
			// next scene also on the client thread
			if (client.isClientThread()) {
				// Avoid reallocating buffers whenever possible
				staticUnorderedModelBuffer = previous.staticUnorderedModelBuffer.clear();
				stagingBufferVertices = previous.stagingBufferVertices.clear();
				stagingBufferUvs = previous.stagingBufferUvs.clear();
				stagingBufferNormals = previous.stagingBufferNormals.clear();
				previous.staticUnorderedModelBuffer = null;
				previous.stagingBufferVertices = null;
				previous.stagingBufferUvs = null;
				previous.stagingBufferNormals = null;
			} else {
				staticUnorderedModelBuffer = new GpuIntBuffer(previous.staticUnorderedModelBuffer.capacity());
				stagingBufferVertices = new GpuIntBuffer(previous.stagingBufferVertices.capacity());
				stagingBufferUvs = new GpuFloatBuffer(previous.stagingBufferUvs.capacity());
				stagingBufferNormals = new GpuFloatBuffer(previous.stagingBufferNormals.capacity());
			}
		}
	}

	@Override
	public synchronized void destroy() {
		super.destroy();

		if (stagingBufferVertices != null)
			stagingBufferVertices.destroy();
		stagingBufferVertices = null;

		if (stagingBufferUvs != null)
			stagingBufferUvs.destroy();
		stagingBufferUvs = null;

		if (stagingBufferNormals != null)
			stagingBufferNormals.destroy();
		stagingBufferNormals = null;
	}

	public int getVertexOffset() {
		return stagingBufferVertices.position() / LegacyRenderer.VERTEX_SIZE;
	}

	public int getUvOffset() {
		return stagingBufferUvs.position() / LegacyRenderer.UV_SIZE;
	}
}

/*
 * Copyright (c) 2018, Adam <Adam@sigterm.info>
 * Copyright (c) 2021, 117 <https://twitter.com/117scape>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package rs117.hd.renderer.legacy;

import com.google.common.base.Stopwatch;
import java.util.Arrays;
import java.util.stream.Collectors;
import javax.annotation.Nonnull;
import javax.annotation.Nullable;
import javax.inject.Inject;
import javax.inject.Singleton;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.*;
import rs117.hd.HdPlugin;
import rs117.hd.HdPluginConfig;
import rs117.hd.scene.AreaManager;
import rs117.hd.scene.MaterialManager;
import rs117.hd.scene.ModelOverrideManager;
import rs117.hd.scene.ProceduralGenerator;
import rs117.hd.scene.TileOverrideManager;
import rs117.hd.scene.areas.Area;
import rs117.hd.scene.ground_materials.GroundMaterial;
import rs117.hd.scene.materials.Material;
import rs117.hd.scene.model_overrides.ModelOverride;
import rs117.hd.scene.model_overrides.UvType;
import rs117.hd.scene.tile_overrides.TileOverride;
import rs117.hd.scene.water_types.WaterType;
import rs117.hd.utils.HDUtils;
import rs117.hd.utils.ModelHash;

import static net.runelite.api.Constants.*;
import static net.runelite.api.Constants.SCENE_SIZE;
import static net.runelite.api.Perspective.*;
import static rs117.hd.scene.tile_overrides.TileOverride.NONE;
import static rs117.hd.scene.tile_overrides.TileOverride.OVERLAY_FLAG;
import static rs117.hd.utils.HDUtils.HIDDEN_HSL;
import static rs117.hd.utils.HDUtils.UNDERWATER_HSL;
import static rs117.hd.utils.HDUtils.packTerrainData;
import static rs117.hd.utils.MathUtils.*;

@Slf4j
@Singleton
@SuppressWarnings("UnnecessaryLocalVariable")
public class LegacySceneUploader {
	public static final int SCENE_ID_MASK = 0xFFFF;
	public static final int EXCLUDED_FROM_SCENE_BUFFER = 0xFFFFFFFF;

	private static final int[] UP_NORMAL = { 0, -1, 0 };

	@Inject
	private Client client;

	@Inject
	private HdPlugin plugin;

	@Inject
	private HdPluginConfig config;

	@Inject
	private AreaManager areaManager;

	@Inject
	private MaterialManager materialManager;

	@Inject
	private TileOverrideManager tileOverrideManager;

	@Inject
	private ModelOverrideManager modelOverrideManager;

	@Inject
	public ProceduralGenerator proceduralGenerator;

	@Inject
	private LegacyModelPusher modelPusher;

	public void upload(LegacySceneContext sceneContext) {
		proceduralGenerator.generateSceneData(sceneContext);

		Stopwatch stopwatch = Stopwatch.createStarted();

		var scene = sceneContext.scene;
		sceneContext.enableAreaHiding =
			config.hideUnrelatedAreas() &&
			sceneContext.sceneBase != null &&
			!sceneContext.forceDisableAreaHiding;
		sceneContext.fillGaps = config.fillGapsInTerrain();

		if (sceneContext.enableAreaHiding) {
			sceneContext.possibleAreas = Arrays
				.stream(areaManager.areasWithAreaHiding)
				.filter(area -> sceneContext.sceneBounds.intersects(area.aabbs))
				.toArray(Area[]::new);

			if (log.isDebugEnabled() && sceneContext.possibleAreas.length > 0) {
				log.debug(
					"Hiding areas outside of {}",
					Arrays.stream(sceneContext.possibleAreas)
						.distinct()
						.map(Area::toString)
						.collect(Collectors.joining(", "))
				);
			}
		}

		// The scene can be prepared early when loaded synchronously
		if (client.isClientThread())
			prepareBeforeSwap(sceneContext);

		sceneContext.staticCustomTilesOffset = sceneContext.staticVertexCount;
		var tiles = scene.getExtendedTiles();
		for (int z = 0; z < MAX_Z; ++z) {
			for (int x = 0; x < EXTENDED_SCENE_SIZE; ++x) {
				for (int y = 0; y < EXTENDED_SCENE_SIZE; ++y) {
					Tile tile = tiles[z][x][y];
					if (tile != null)
						upload(sceneContext, tile, x, y);
				}
			}
		}
		sceneContext.staticCustomTilesVertexCount = sceneContext.staticVertexCount - sceneContext.staticCustomTilesOffset;

		stopwatch.stop();
		log.debug(
			"Scene upload time: {}, unique models: {}, size: {} MB",
			stopwatch,
			sceneContext.uniqueModels,
			String.format(
				"%.2f",
				(
					sceneContext.getVertexOffset() * 4L * (LegacyRenderer.VERTEX_SIZE + LegacyRenderer.NORMAL_SIZE) +
					sceneContext.getUvOffset() * 4L * LegacyRenderer.UV_SIZE
				) / 1e6
			)
		);

		proceduralGenerator.clearSceneData(sceneContext);
	}

	public void prepareBeforeSwap(LegacySceneContext sceneContext) {
		assert client.isClientThread();
		if (sceneContext.isPrepared)
			return;
		sceneContext.isPrepared = true;

		// At this point, the player's position & plane has been updated, so area hiding can be set up
		if (sceneContext.enableAreaHiding)
			removeTilesOutsideCurrentArea(sceneContext);

		// Gaps need to be filled right before scene swap, since map regions aren't updated earlier
		if (sceneContext.fillGaps) {
			sceneContext.staticGapFillerTilesOffset = sceneContext.staticVertexCount;
			fillGaps(sceneContext);
			sceneContext.staticGapFillerTilesVertexCount = sceneContext.staticVertexCount - sceneContext.staticGapFillerTilesOffset;
		}
	}

	public void updatePlayerArea(LegacySceneContext sceneContext) {
		if (!sceneContext.enableAreaHiding) {
			sceneContext.currentArea = null;
			return;
		}

		assert sceneContext.sceneBase != null;
		var lp = client.getLocalPlayer().getLocalLocation();
		int[] worldPos = {
			sceneContext.sceneBase[0] + lp.getSceneX(),
			sceneContext.sceneBase[1] + lp.getSceneY(),
			sceneContext.sceneBase[2] + client.getTopLevelWorldView().getPlane()
		};

		if (sceneContext.currentArea == null || !sceneContext.currentArea.containsPoint(false, worldPos)) {
			sceneContext.currentArea = null;
			for (var area : sceneContext.possibleAreas) {
				if (area.containsPoint(false, worldPos)) {
					sceneContext.currentArea = area;
					break;
				}
			}
		}
	}

	private void removeTilesOutsideCurrentArea(LegacySceneContext sceneContext) {
		assert sceneContext.sceneBase != null;
		updatePlayerArea(sceneContext);
		if (sceneContext.currentArea == null)
			return;

		var tiles = sceneContext.scene.getExtendedTiles();
		int baseExX = sceneContext.sceneBase[0] - sceneContext.sceneOffset;
		int baseExY = sceneContext.sceneBase[1] - sceneContext.sceneOffset;
		int basePlane = sceneContext.sceneBase[2];
		for (int z = 0; z < MAX_Z; ++z) {
			for (int x = 0; x < EXTENDED_SCENE_SIZE; ++x) {
				for (int y = 0; y < EXTENDED_SCENE_SIZE; ++y) {
					Tile tile = tiles[z][x][y];
					if (tile == null)
						continue;

					if (!sceneContext.currentArea.containsPoint(baseExX + x, baseExY + y, basePlane + z))
						sceneContext.scene.removeTile(tile);
				}
			}
		}
	}

	private void fillGaps(LegacySceneContext sceneContext) {
		if (sceneContext.sceneBase == null)
			return;

		var area = sceneContext.currentArea;
		if (area != null && !area.fillGaps)
			return;

//		log.warn("TODO: Check if scene.getMapRegions() is the same as client.getMapRegions()");

		int sceneMin = -sceneContext.expandedMapLoadingChunks * CHUNK_SIZE;
		int sceneMax = SCENE_SIZE + sceneContext.expandedMapLoadingChunks * CHUNK_SIZE;
		int baseExX = sceneContext.sceneBase[0];
		int baseExY = sceneContext.sceneBase[1];
		int basePlane = sceneContext.sceneBase[2];
		Material blackMaterial = materialManager.getMaterial("BLACK");

		Tile[][][] extendedTiles = sceneContext.scene.getExtendedTiles();
		for (int tileZ = 0; tileZ < MAX_Z; ++tileZ) {
			for (int tileExX = 0; tileExX < EXTENDED_SCENE_SIZE; ++tileExX) {
				for (int tileExY = 0; tileExY < EXTENDED_SCENE_SIZE; ++tileExY) {
					if (area != null && !area.containsPoint(baseExX + tileExX, baseExY + tileExY, basePlane + tileZ))
						continue;

					int tileX = tileExX - sceneContext.sceneOffset;
					int tileY = tileExY - sceneContext.sceneOffset;
					Tile tile = extendedTiles[tileZ][tileExX][tileExY];

					SceneTilePaint paint;
					SceneTileModel model = null;
					int renderLevel = tileZ;
					if (tile != null) {
						renderLevel = tile.getRenderLevel();
						paint = tile.getSceneTilePaint();
						model = tile.getSceneTileModel();

						if (model == null) {
							boolean hasTilePaint = paint != null && paint.getNeColor() != HIDDEN_HSL;
							if (!hasTilePaint) {
								tile = tile.getBridge();
								if (tile != null) {
									renderLevel = tile.getRenderLevel();
									paint = tile.getSceneTilePaint();
									model = tile.getSceneTileModel();
									hasTilePaint = paint != null && paint.getNeColor() != HIDDEN_HSL;
								}
							}

							if (hasTilePaint)
								continue;
						}
					}

					int[] worldPoint = sceneContext.sceneToWorld(tileX, tileY, tileZ);
					boolean fillGaps =
						tileZ == 0 &&
						tileX > sceneMin &&
						tileY > sceneMin &&
						tileX < sceneMax - 1 &&
						tileY < sceneMax - 1 &&
						Area.OVERWORLD.containsPoint(worldPoint);

					if (fillGaps) {
						int tileRegionID = HDUtils.worldToRegionID(worldPoint);
						int[] regions = client.getMapRegions();

						fillGaps = false;
						for (int region : regions) {
							if (region == tileRegionID) {
								fillGaps = true;
								break;
							}
						}
					}

					if (fillGaps) {
						int vertexOffset = sceneContext.getVertexOffset();
						int uvOffset = sceneContext.getUvOffset();
						int vertexCount;

						if (model == null) {
							uploadCustomTile(sceneContext, tileExX, tileExY, renderLevel, blackMaterial);
							vertexCount = 6;
						} else {
							int[] worldPos = sceneContext.sceneToWorld(tileX, tileY, tileZ);
							int[] uploadedTileModelData = uploadHDTileModelSurface(sceneContext, tile, worldPos, model, true);
							vertexCount = uploadedTileModelData[0];
						}

						if (vertexCount > 0) {
							sceneContext.staticUnorderedModelBuffer
								.ensureCapacity(8)
								.getBuffer()
								.put(vertexOffset)
								.put(uvOffset)
								.put(vertexCount / 3)
								.put(sceneContext.staticVertexCount)
								.put(0)
								.put(tileX * LOCAL_TILE_SIZE)
								.put(0)
								.put(tileY * LOCAL_TILE_SIZE);
							sceneContext.staticVertexCount += vertexCount;
						}
					}
				}
			}
		}
	}

	private void uploadModel(LegacySceneContext sceneContext, Tile tile, int uuid, Model model, int orientation) {
		// deduplicate hillskewed models
		if (model.getUnskewedModel() != null)
			model = model.getUnskewedModel();

		if (model.getSceneId() == EXCLUDED_FROM_SCENE_BUFFER)
			return;

		int[] worldPos = sceneContext.localToWorld(tile.getLocalLocation(), tile.getPlane());
		ModelOverride modelOverride = modelOverrideManager.getOverride(uuid, worldPos);
		int sceneId = modelOverride.hashCode() << 16 | sceneContext.id;

		// check if the model has already been uploaded
		if ((model.getSceneId() & SCENE_ID_MASK) == sceneContext.id) {
			// if the same model is being uploaded, but with a different model override,
			// exclude it from the scene buffer to avoid conflicts
			if (model.getSceneId() != sceneId)
				model.setSceneId(EXCLUDED_FROM_SCENE_BUFFER);
			return;
		}

		int vertexOffset = sceneContext.getVertexOffset();
		int uvOffset = sceneContext.getUvOffset();

		if (modelOverride.hide) {
			vertexOffset = -1;
		} else {
			modelPusher.pushModel(sceneContext, tile, uuid, model, modelOverride, orientation, false);
			if (sceneContext.modelPusherResults[1] == 0)
				uvOffset = -1;
		}

		model.setBufferOffset(vertexOffset);
		model.setUvBufferOffset(uvOffset);
		model.setSceneId(sceneId);
		++sceneContext.uniqueModels;
	}

	private void upload(LegacySceneContext sceneContext, @Nonnull Tile tile, int tileExX, int tileExY) {
		Tile bridge = tile.getBridge();
		if (bridge != null)
			upload(sceneContext, bridge, tileExX, tileExY);

		int[] worldPos = sceneContext.localToWorld(tile.getLocalLocation(), tile.getPlane());
		var override = tileOverrideManager.getOverride(sceneContext, tile, worldPos);

		SceneTilePaint sceneTilePaint = tile.getSceneTilePaint();
		if (sceneTilePaint != null || override.forced) {
			sceneContext.filledTiles[tileExX][tileExY] |= (byte) (1 << tile.getPlane());

			boolean depthTested = override.depthTested ||
								  override.forced && (sceneTilePaint == null || sceneTilePaint.getNeColor() == HIDDEN_HSL);

			// Set offsets before pushing new data
			int vertexOffset = sceneContext.getVertexOffset();
			int uvOffset = sceneContext.getUvOffset();
			int[] uploadedTilePaintData = upload(sceneContext, tile, worldPos, override, sceneTilePaint);

			int vertexCount = uploadedTilePaintData[0];
			int uvCount = uploadedTilePaintData[1];

			// Opening the right-click menu causes the game to stop drawing hidden tiles, which prevents us from drawing underwater tiles
			// below the boats at Pest Control, or any other custom tile. To work around this, we can instead draw all hidden tiles at once
			// at the start of the frame. This currently means they will only draw correctly if they're always behind everything else.
			if (vertexCount > 0 && depthTested) {
				int tileX = tileExX - sceneContext.sceneOffset;
				int tileY = tileExY - sceneContext.sceneOffset;

				// Draw the tile at the start of each frame
				sceneContext.staticUnorderedModelBuffer
					.ensureCapacity(8)
					.getBuffer()
					.put(vertexOffset)
					.put(uvOffset)
					.put(vertexCount / 3)
					.put(sceneContext.staticVertexCount)
					.put(0)
					.put(tileX * LOCAL_TILE_SIZE)
					.put(0)
					.put(tileY * LOCAL_TILE_SIZE);
				sceneContext.staticVertexCount += vertexCount;

				// Since we're now drawing this tile at the beginning of the frame, remove its vertices from the draw callback
				vertexCount = 0;
				uvCount = 0;
			}

			if (uvCount <= 0)
				uvOffset = -1;

			if (sceneTilePaint != null) {
				sceneTilePaint.setBufferLen(vertexCount);
				sceneTilePaint.setBufferOffset(vertexOffset);
				sceneTilePaint.setUvBufferOffset(uvOffset);
			}
		}

		var sceneTileModel = tile.getSceneTileModel();
		if (sceneTileModel != null) {
			sceneContext.filledTiles[tileExX][tileExY] |= (byte) (1 << tile.getPlane());

			// Set offsets before pushing new data
			sceneTileModel.setBufferOffset(sceneContext.getVertexOffset());
			sceneTileModel.setUvBufferOffset(sceneContext.getUvOffset());
			int[] uploadedTileModelData = upload(sceneContext, tile, worldPos, sceneTileModel);

			final int bufferLength = uploadedTileModelData[0];
			final int uvBufferLength = uploadedTileModelData[1];
			final int underwaterTerrain = uploadedTileModelData[2];
			if (uvBufferLength <= 0)
				sceneTileModel.setUvBufferOffset(-1);
			// pack a boolean into the buffer length of tiles so we can tell
			// which tiles have procedurally-generated underwater terrain
			int packedBufferLength = bufferLength << 1 | underwaterTerrain;

			sceneTileModel.setBufferLen(packedBufferLength);
		}

		WallObject wallObject = tile.getWallObject();
		if (wallObject != null) {
			Renderable renderable1 = wallObject.getRenderable1();
			if (renderable1 instanceof Model) {
				uploadModel(
					sceneContext,
					tile,
					ModelHash.packUuid(ModelHash.TYPE_WALL_OBJECT, wallObject.getId()),
					(Model) renderable1,
					HDUtils.convertWallObjectOrientation(wallObject.getOrientationA())
				);
			}

			Renderable renderable2 = wallObject.getRenderable2();
			if (renderable2 instanceof Model) {
				uploadModel(
					sceneContext,
					tile,
					ModelHash.packUuid(ModelHash.TYPE_WALL_OBJECT, wallObject.getId()),
					(Model) renderable2,
					HDUtils.convertWallObjectOrientation(wallObject.getOrientationB())
				);
			}
		}

		GroundObject groundObject = tile.getGroundObject();
		if (groundObject != null) {
			Renderable renderable = groundObject.getRenderable();
			if (renderable instanceof Model) {
				uploadModel(
					sceneContext,
					tile,
					ModelHash.packUuid(ModelHash.TYPE_GROUND_OBJECT, groundObject.getId()),
					(Model) renderable,
					HDUtils.getModelPreOrientation(groundObject.getConfig())
				);
			}
		}

		DecorativeObject decorativeObject = tile.getDecorativeObject();
		if (decorativeObject != null) {
			Renderable renderable = decorativeObject.getRenderable();
			int orientation = HDUtils.getModelPreOrientation(decorativeObject.getConfig());
			if (renderable instanceof Model) {
				uploadModel(
					sceneContext,
					tile,
					ModelHash.packUuid(ModelHash.TYPE_DECORATIVE_OBJECT, decorativeObject.getId()),
					(Model) renderable,
					orientation
				);
			}

			Renderable renderable2 = decorativeObject.getRenderable2();
			if (renderable2 instanceof Model) {
				uploadModel(
					sceneContext,
					tile,
					ModelHash.packUuid(ModelHash.TYPE_DECORATIVE_OBJECT, decorativeObject.getId()),
					(Model) renderable2,
					orientation
				);
			}
		}

		GameObject[] gameObjects = tile.getGameObjects();
		for (GameObject gameObject : gameObjects) {
			if (gameObject == null)
				continue;

			Renderable renderable = gameObject.getRenderable();
			if (renderable instanceof Model) {
				uploadModel(sceneContext,
					tile,
					ModelHash.packUuid(ModelHash.TYPE_GAME_OBJECT, gameObject.getId()),
					(Model) gameObject.getRenderable(),
					HDUtils.getModelPreOrientation(gameObject.getConfig())
				);
			}
		}
	}

	private int[] upload(
		LegacySceneContext sceneContext,
		Tile tile,
		int[] worldPos,
		TileOverride override,
		@Nullable SceneTilePaint paint
	) {
		int bufferLength = 0;
		int uvBufferLength = 0;
		int underwaterTerrain = 0;

		int[] bufferLengths;
		WaterType waterType = WaterType.NONE;
		if (paint != null)
			waterType = proceduralGenerator.seasonalWaterType(override, paint.getTexture());

		bufferLengths = uploadHDTilePaintUnderwater(sceneContext, tile, worldPos, waterType);
		bufferLength += bufferLengths[0];
		uvBufferLength += bufferLengths[1];
		underwaterTerrain += bufferLengths[2];

		bufferLengths = uploadHDTilePaintSurface(sceneContext, tile, worldPos, waterType, paint, override);
		bufferLength += bufferLengths[0];
		uvBufferLength += bufferLengths[1];
		underwaterTerrain += bufferLengths[2];

		return new int[] { bufferLength, uvBufferLength, underwaterTerrain };
	}

	private int[] uploadHDTilePaintSurface(
		LegacySceneContext sceneContext,
		Tile tile,
		int[] worldPos,
		WaterType waterType,
		@Nullable SceneTilePaint paint,
		TileOverride override
	) {
		final Scene scene = sceneContext.scene;
		final Point tilePoint = tile.getSceneLocation();
		final int tileX = tilePoint.getX();
		final int tileY = tilePoint.getY();
		final int tileExX = tileX + sceneContext.sceneOffset;
		final int tileExY = tileY + sceneContext.sceneOffset;
		final int tileZ = tile.getRenderLevel();

		final int localX = 0;
		final int localY = 0;

		final int[][][] tileHeights = scene.getTileHeights();
		int swHeight = tileHeights[tileZ][tileExX][tileExY];
		int seHeight = tileHeights[tileZ][tileExX + 1][tileExY];
		int neHeight = tileHeights[tileZ][tileExX + 1][tileExY + 1];
		int nwHeight = tileHeights[tileZ][tileExX][tileExY + 1];

		int bufferLength = 0;
		int uvBufferLength = 0;
		int underwaterTerrain = 0;

		int localSwVertexX = localX;
		int localSwVertexY = localY;
		int localSeVertexX = localX + LOCAL_TILE_SIZE;
		int localSeVertexY = localY;
		int localNwVertexX = localX;
		int localNwVertexY = localY + LOCAL_TILE_SIZE;
		int localNeVertexX = localX + LOCAL_TILE_SIZE;
		int localNeVertexY = localY + LOCAL_TILE_SIZE;

		int[] vertexKeys = ProceduralGenerator.tileVertexKeys(sceneContext, tile);
		int swVertexKey = vertexKeys[0];
		int seVertexKey = vertexKeys[1];
		int nwVertexKey = vertexKeys[2];
		int neVertexKey = vertexKeys[3];

		int uvOrientation = 0;
		float uvScale = 1;

		// Ignore certain tiles that aren't supposed to be visible,
		// but which we can still make a height-adjusted version of for underwater
		if ((paint != null && paint.getNeColor() != HIDDEN_HSL) || override.forced)
		{
			int swColor = 0;
			int seColor = 0;
			int neColor = 0;
			int nwColor = 0;
			int textureId = -1;

			if (paint != null) {
				swColor = paint.getSwColor();
				seColor = paint.getSeColor();
				neColor = paint.getNeColor();
				nwColor = paint.getNwColor();
				textureId = paint.getTexture();
			}

			boolean neVertexIsOverlay = false;
			boolean nwVertexIsOverlay = false;
			boolean seVertexIsOverlay = false;
			boolean swVertexIsOverlay = false;

			Material swMaterial = Material.NONE;
			Material seMaterial = Material.NONE;
			Material neMaterial = Material.NONE;
			Material nwMaterial = Material.NONE;

			int[] swNormals = UP_NORMAL;
			int[] seNormals = UP_NORMAL;
			int[] neNormals = UP_NORMAL;
			int[] nwNormals = UP_NORMAL;

			if (waterType == WaterType.NONE) {
				if (textureId != -1) {
					var material = materialManager.fromVanillaTexture(textureId);
					// Disable tile overrides for newly introduced vanilla textures
					if (material.isFallbackVanillaMaterial)
						override = NONE;
					swMaterial = seMaterial = neMaterial = nwMaterial = material;
				}

				swNormals = sceneContext.vertexTerrainNormals.getOrDefault(swVertexKey, swNormals);
				seNormals = sceneContext.vertexTerrainNormals.getOrDefault(seVertexKey, seNormals);
				neNormals = sceneContext.vertexTerrainNormals.getOrDefault(neVertexKey, neNormals);
				nwNormals = sceneContext.vertexTerrainNormals.getOrDefault(nwVertexKey, nwNormals);

				boolean useBlendedMaterialAndColor =
					plugin.configGroundBlending &&
					textureId == -1 &&
					!proceduralGenerator.useDefaultColor(tile, override);
				GroundMaterial groundMaterial = null;
				if (override != TileOverride.NONE) {
					groundMaterial = override.groundMaterial;
					uvOrientation = override.uvOrientation;
					uvScale = override.uvScale;
					if (!useBlendedMaterialAndColor) {
						swColor = override.modifyColor(swColor);
						seColor = override.modifyColor(seColor);
						nwColor = override.modifyColor(nwColor);
						neColor = override.modifyColor(neColor);
					}
					swHeight -= override.heightOffset;
					seHeight -= override.heightOffset;
					neHeight -= override.heightOffset;
					nwHeight -= override.heightOffset;
				} else if (textureId == -1) {
					// Fall back to the default ground material if the tile is untextured
					groundMaterial = override.groundMaterial;
				}

				if (useBlendedMaterialAndColor) {
					// get the vertices' colors and textures from hashmaps
					swColor = sceneContext.vertexTerrainColor.getOrDefault(swVertexKey, swColor);
					seColor = sceneContext.vertexTerrainColor.getOrDefault(seVertexKey, seColor);
					neColor = sceneContext.vertexTerrainColor.getOrDefault(neVertexKey, neColor);
					nwColor = sceneContext.vertexTerrainColor.getOrDefault(nwVertexKey, nwColor);

					if (plugin.configGroundTextures) {
						swMaterial = sceneContext.vertexTerrainTexture.getOrDefault(swVertexKey, swMaterial);
						seMaterial = sceneContext.vertexTerrainTexture.getOrDefault(seVertexKey, seMaterial);
						neMaterial = sceneContext.vertexTerrainTexture.getOrDefault(neVertexKey, neMaterial);
						nwMaterial = sceneContext.vertexTerrainTexture.getOrDefault(nwVertexKey, nwMaterial);
					}
				} else if (plugin.configGroundTextures && groundMaterial != null) {
					swMaterial = groundMaterial.getRandomMaterial(worldPos[0], worldPos[1], worldPos[2]);
					seMaterial = groundMaterial.getRandomMaterial(worldPos[0] + 1, worldPos[1], worldPos[2]);
					nwMaterial = groundMaterial.getRandomMaterial(worldPos[0], worldPos[1] + 1, worldPos[2]);
					neMaterial = groundMaterial.getRandomMaterial(worldPos[0] + 1, worldPos[1] + 1, worldPos[2]);
				}
			}
			else
			{
				// set colors for the shoreline to create a foam effect in the water shader
				swColor = seColor = nwColor = neColor = 127;

				if (sceneContext.vertexIsWater.containsKey(swVertexKey) && sceneContext.vertexIsLand.containsKey(swVertexKey))
					swColor = 0;
				if (sceneContext.vertexIsWater.containsKey(seVertexKey) && sceneContext.vertexIsLand.containsKey(seVertexKey))
					seColor = 0;
				if (sceneContext.vertexIsWater.containsKey(nwVertexKey) && sceneContext.vertexIsLand.containsKey(nwVertexKey))
					nwColor = 0;
				if (sceneContext.vertexIsWater.containsKey(neVertexKey) && sceneContext.vertexIsLand.containsKey(neVertexKey))
					neColor = 0;
			}

			if (sceneContext.vertexIsOverlay.containsKey(neVertexKey) && sceneContext.vertexIsUnderlay.containsKey(neVertexKey))
				neVertexIsOverlay = true;
			if (sceneContext.vertexIsOverlay.containsKey(nwVertexKey) && sceneContext.vertexIsUnderlay.containsKey(nwVertexKey))
				nwVertexIsOverlay = true;
			if (sceneContext.vertexIsOverlay.containsKey(seVertexKey) && sceneContext.vertexIsUnderlay.containsKey(seVertexKey))
				seVertexIsOverlay = true;
			if (sceneContext.vertexIsOverlay.containsKey(swVertexKey) && sceneContext.vertexIsUnderlay.containsKey(swVertexKey))
				swVertexIsOverlay = true;


			float terrainData = Float.intBitsToFloat(packTerrainData(true, 0, waterType, tileZ));

			sceneContext.stagingBufferNormals.ensureCapacity(24);
			sceneContext.stagingBufferNormals.put(neNormals[0], neNormals[2], neNormals[1], terrainData);
			sceneContext.stagingBufferNormals.put(nwNormals[0], nwNormals[2], nwNormals[1], terrainData);
			sceneContext.stagingBufferNormals.put(seNormals[0], seNormals[2], seNormals[1], terrainData);

			sceneContext.stagingBufferNormals.put(swNormals[0], swNormals[2], swNormals[1], terrainData);
			sceneContext.stagingBufferNormals.put(seNormals[0], seNormals[2], seNormals[1], terrainData);
			sceneContext.stagingBufferNormals.put(nwNormals[0], nwNormals[2], nwNormals[1], terrainData);


			sceneContext.stagingBufferVertices.ensureCapacity(24);
			sceneContext.stagingBufferVertices.put((float) localNeVertexX, neHeight, localNeVertexY, neColor);
			sceneContext.stagingBufferVertices.put((float) localNwVertexX, nwHeight, localNwVertexY, nwColor);
			sceneContext.stagingBufferVertices.put((float) localSeVertexX, seHeight, localSeVertexY, seColor);

			sceneContext.stagingBufferVertices.put((float) localSwVertexX, swHeight, localSwVertexY, swColor);
			sceneContext.stagingBufferVertices.put((float) localSeVertexX, seHeight, localSeVertexY, seColor);
			sceneContext.stagingBufferVertices.put((float) localNwVertexX, nwHeight, localNwVertexY, nwColor);

			bufferLength += 6;


			int packedMaterialDataSW = swMaterial.packMaterialData(ModelOverride.NONE, UvType.GEOMETRY, swVertexIsOverlay, true);
			int packedMaterialDataSE = seMaterial.packMaterialData(ModelOverride.NONE, UvType.GEOMETRY, seVertexIsOverlay, true);
			int packedMaterialDataNW = nwMaterial.packMaterialData(ModelOverride.NONE, UvType.GEOMETRY, nwVertexIsOverlay, true);
			int packedMaterialDataNE = neMaterial.packMaterialData(ModelOverride.NONE, UvType.GEOMETRY, neVertexIsOverlay, true);

			float uvcos = -uvScale, uvsin = 0;
			if (uvOrientation % 2048 != 0) {
				float rad = -uvOrientation * JAU_TO_RAD;
				uvcos = cos(rad) * -uvScale;
				uvsin = sin(rad) * -uvScale;
			}
			float uvx = worldPos[0];
			float uvy = worldPos[1];
			float tmp = uvx;
			uvx = uvx * uvcos - uvy * uvsin;
			uvy = tmp * uvsin + uvy * uvcos;

			sceneContext.stagingBufferUvs.ensureCapacity(24);
			sceneContext.stagingBufferUvs.put(uvx, uvy, 0, packedMaterialDataNE);
			sceneContext.stagingBufferUvs.put(uvx - uvcos, uvy - uvsin, 0, packedMaterialDataNW);
			sceneContext.stagingBufferUvs.put(uvx + uvsin, uvy - uvcos, 0, packedMaterialDataSE);

			sceneContext.stagingBufferUvs.put(uvx - uvcos + uvsin, uvy - uvsin - uvcos, 0, packedMaterialDataSW);
			sceneContext.stagingBufferUvs.put(uvx + uvsin, uvy - uvcos, 0, packedMaterialDataSE);
			sceneContext.stagingBufferUvs.put(uvx - uvcos, uvy - uvsin, 0, packedMaterialDataNW);

			uvBufferLength += 6;
		}

		return new int[]{bufferLength, uvBufferLength, underwaterTerrain};
	}

	private int[] uploadHDTilePaintUnderwater(LegacySceneContext sceneContext, Tile tile, int[] worldPos, WaterType waterType) {
		final Scene scene = sceneContext.scene;
		final Point tilePoint = tile.getSceneLocation();
		final int tileX = tilePoint.getX();
		final int tileY = tilePoint.getY();
		final int tileExX = tileX + sceneContext.sceneOffset;
		final int tileExY = tileY + sceneContext.sceneOffset;
		final int tileZ = tile.getRenderLevel();

		int baseX = scene.getBaseX();
		int baseY = scene.getBaseY();

		if (baseX >= 2816 && baseX <= 2970 && baseY <= 5375 && baseY >= 5220) {
			// fix for God Wars Dungeon's water rendering over zamorak bridge
			return new int[] { 0, 0, 0 };
		}

		final int[][][] tileHeights = scene.getTileHeights();
		int swHeight = tileHeights[tileZ][tileExX][tileExY];
		int seHeight = tileHeights[tileZ][tileExX + 1][tileExY];
		int neHeight = tileHeights[tileZ][tileExX + 1][tileExY + 1];
		int nwHeight = tileHeights[tileZ][tileExX][tileExY + 1];

		int bufferLength = 0;
		int uvBufferLength = 0;
		int underwaterTerrain = 0;

		int localSwVertexX = 0;
		int localSwVertexY = 0;
		int localSeVertexX = LOCAL_TILE_SIZE;
		int localSeVertexY = 0;
		int localNwVertexX = 0;
		int localNwVertexY = LOCAL_TILE_SIZE;
		int localNeVertexX = LOCAL_TILE_SIZE;
		int localNeVertexY = LOCAL_TILE_SIZE;

		int[] vertexKeys = ProceduralGenerator.tileVertexKeys(sceneContext, tile);
		int swVertexKey = vertexKeys[0];
		int seVertexKey = vertexKeys[1];
		int nwVertexKey = vertexKeys[2];
		int neVertexKey = vertexKeys[3];

		if (sceneContext.tileIsWater[tileZ][tileExX][tileExY]) {
			// underwater terrain

			underwaterTerrain = 1;

			int swColor, seColor, neColor, nwColor;
			swColor = seColor = neColor = nwColor = UNDERWATER_HSL;

			int swDepth = sceneContext.vertexUnderwaterDepth.getOrDefault(swVertexKey, 0);
			int seDepth = sceneContext.vertexUnderwaterDepth.getOrDefault(seVertexKey, 0);
			int nwDepth = sceneContext.vertexUnderwaterDepth.getOrDefault(nwVertexKey, 0);
			int neDepth = sceneContext.vertexUnderwaterDepth.getOrDefault(neVertexKey, 0);

			int[] swNormals = sceneContext.vertexTerrainNormals.getOrDefault(swVertexKey, UP_NORMAL);
			int[] seNormals = sceneContext.vertexTerrainNormals.getOrDefault(seVertexKey, UP_NORMAL);
			int[] nwNormals = sceneContext.vertexTerrainNormals.getOrDefault(nwVertexKey, UP_NORMAL);
			int[] neNormals = sceneContext.vertexTerrainNormals.getOrDefault(neVertexKey, UP_NORMAL);

			Material swMaterial = Material.NONE;
			Material seMaterial = Material.NONE;
			Material nwMaterial = Material.NONE;
			Material neMaterial = Material.NONE;

			if (plugin.configGroundTextures)
			{
				GroundMaterial groundMaterial = GroundMaterial.UNDERWATER_GENERIC;
				swMaterial = groundMaterial.getRandomMaterial(worldPos[0], worldPos[1], worldPos[2]);
				seMaterial = groundMaterial.getRandomMaterial(worldPos[0] + 1, worldPos[1], worldPos[2]);
				nwMaterial = groundMaterial.getRandomMaterial(worldPos[0], worldPos[1] + 1, worldPos[2]);
				neMaterial = groundMaterial.getRandomMaterial(worldPos[0] + 1, worldPos[1] + 1, worldPos[2]);
			}

			float swTerrainData = Float.intBitsToFloat(packTerrainData(true, max(1, swDepth), waterType, tileZ));
			float seTerrainData = Float.intBitsToFloat(packTerrainData(true, max(1, seDepth), waterType, tileZ));
			float nwTerrainData = Float.intBitsToFloat(packTerrainData(true, max(1, nwDepth), waterType, tileZ));
			float neTerrainData = Float.intBitsToFloat(packTerrainData(true, max(1, neDepth), waterType, tileZ));

			sceneContext.stagingBufferNormals.ensureCapacity(24);
			sceneContext.stagingBufferNormals.put(neNormals[0], neNormals[2], neNormals[1], neTerrainData);
			sceneContext.stagingBufferNormals.put(nwNormals[0], nwNormals[2], nwNormals[1], nwTerrainData);
			sceneContext.stagingBufferNormals.put(seNormals[0], seNormals[2], seNormals[1], seTerrainData);

			sceneContext.stagingBufferNormals.put(swNormals[0], swNormals[2], swNormals[1], swTerrainData);
			sceneContext.stagingBufferNormals.put(seNormals[0], seNormals[2], seNormals[1], seTerrainData);
			sceneContext.stagingBufferNormals.put(nwNormals[0], nwNormals[2], nwNormals[1], nwTerrainData);

			sceneContext.stagingBufferVertices.ensureCapacity(24);
			sceneContext.stagingBufferVertices.put((float) localNeVertexX, neHeight + neDepth, localNeVertexY, neColor);
			sceneContext.stagingBufferVertices.put((float) localNwVertexX, nwHeight + nwDepth, localNwVertexY, nwColor);
			sceneContext.stagingBufferVertices.put((float) localSeVertexX, seHeight + seDepth, localSeVertexY, seColor);

			sceneContext.stagingBufferVertices.put((float) localSwVertexX, swHeight + swDepth, localSwVertexY, swColor);
			sceneContext.stagingBufferVertices.put((float) localSeVertexX, seHeight + seDepth, localSeVertexY, seColor);
			sceneContext.stagingBufferVertices.put((float) localNwVertexX, nwHeight + nwDepth, localNwVertexY, nwColor);

			bufferLength += 6;

			int packedMaterialDataSW = swMaterial.packMaterialData(ModelOverride.NONE, UvType.GEOMETRY, false, true);
			int packedMaterialDataSE = seMaterial.packMaterialData(ModelOverride.NONE, UvType.GEOMETRY, false, true);
			int packedMaterialDataNW = nwMaterial.packMaterialData(ModelOverride.NONE, UvType.GEOMETRY, false, true);
			int packedMaterialDataNE = neMaterial.packMaterialData(ModelOverride.NONE, UvType.GEOMETRY, false, true);

			sceneContext.stagingBufferUvs.ensureCapacity(24);
			sceneContext.stagingBufferUvs.put(0, 0, 0, packedMaterialDataNE);
			sceneContext.stagingBufferUvs.put(1, 0, 0, packedMaterialDataNW);
			sceneContext.stagingBufferUvs.put(0, 1, 0, packedMaterialDataSE);

			sceneContext.stagingBufferUvs.put(1, 1, 0, packedMaterialDataSW);
			sceneContext.stagingBufferUvs.put(0, 1, 0, packedMaterialDataSE);
			sceneContext.stagingBufferUvs.put(1, 0, 0, packedMaterialDataNW);

			uvBufferLength += 6;
		}

		return new int[]{bufferLength, uvBufferLength, underwaterTerrain};
	}

	private int[] upload(LegacySceneContext sceneContext, Tile tile, int[] worldPos, SceneTileModel sceneTileModel)
	{
		int bufferLength = 0;
		int uvBufferLength = 0;
		int underwaterTerrain = 0;

		int[] bufferLengths;

		bufferLengths = uploadHDTileModelSurface(sceneContext, tile, worldPos, sceneTileModel, false);
		bufferLength += bufferLengths[0];
		uvBufferLength += bufferLengths[1];
		underwaterTerrain += bufferLengths[2];

		bufferLengths = uploadHDTileModelUnderwater(sceneContext, tile, worldPos, sceneTileModel);
		assert bufferLengths[0] == bufferLength || bufferLengths[0] == 0;
		bufferLength += bufferLengths[0];
		uvBufferLength += bufferLengths[1];
		underwaterTerrain += bufferLengths[2];

		return new int[]{bufferLength, uvBufferLength, underwaterTerrain};
	}

	private int[] uploadHDTileModelSurface(
		LegacySceneContext sceneContext,
		Tile tile,
		int[] worldPos,
		SceneTileModel model,
		boolean fillGaps
	) {
		final Scene scene = sceneContext.scene;
		final Point tilePoint = tile.getSceneLocation();
		final int tileX = tilePoint.getX();
		final int tileY = tilePoint.getY();
		final int tileExX = tileX + sceneContext.sceneOffset;
		final int tileExY = tileY + sceneContext.sceneOffset;
		final int tileZ = tile.getRenderLevel();

		if (!fillGaps && sceneContext.skipTile[tileZ][tileExX][tileExY])
			return new int[3];

		int bufferLength = 0;
		int uvBufferLength = 0;
		int underwaterTerrain = 0;

		final int[] faceColorA = model.getTriangleColorA();
		final int[] faceColorB = model.getTriangleColorB();
		final int[] faceColorC = model.getTriangleColorC();
		final int[] faceTextures = model.getTriangleTextureId();
		final int faceCount = model.getFaceX().length;

		int overlayId = OVERLAY_FLAG | scene.getOverlayIds()[tileZ][tileExX][tileExY];
		int underlayId = scene.getUnderlayIds()[tileZ][tileExX][tileExY];
		var overlayOverride = tileOverrideManager.getOverride(sceneContext, tile, worldPos, overlayId);
		var underlayOverride = tileOverrideManager.getOverride(sceneContext, tile, worldPos, underlayId);

		for (int face = 0; face < faceCount; ++face) {
			int colorA = faceColorA[face];
			int colorB = faceColorB[face];
			int colorC = faceColorC[face];

			int[][] localVertices = ProceduralGenerator.faceLocalVertices(tile, face);

			int[] vertexKeys = ProceduralGenerator.faceVertexKeys(tile, face);
			int vertexKeyA = vertexKeys[0];
			int vertexKeyB = vertexKeys[1];
			int vertexKeyC = vertexKeys[2];

			boolean vertexAIsOverlay = false;
			boolean vertexBIsOverlay = false;
			boolean vertexCIsOverlay = false;

			int textureId;
			Material materialA = Material.NONE;
			Material materialB = Material.NONE;
			Material materialC = Material.NONE;

			int uvOrientation = 0;
			float uvScale = 1;

			int[] normalsA = UP_NORMAL;
			int[] normalsB = UP_NORMAL;
			int[] normalsC = UP_NORMAL;

			WaterType waterType = WaterType.NONE;

			boolean isHidden = colorA == HIDDEN_HSL;
			if (fillGaps) {
				if (!isHidden)
					continue;
				colorA = colorB = colorC = 0;
			} else {
				boolean isOverlay = ProceduralGenerator.isOverlayFace(tile, face);
				var override = isOverlay ? overlayOverride : underlayOverride;
				if (isHidden && !override.forced)
					continue;

				textureId = faceTextures == null ? -1 : faceTextures[face];
				waterType = proceduralGenerator.seasonalWaterType(override, textureId);
				if (waterType == WaterType.NONE) {
					if (textureId != -1) {
						var material = materialManager.fromVanillaTexture(textureId);
						// Disable tile overrides for newly introduced vanilla textures
						if (material.isFallbackVanillaMaterial)
							override = NONE;
						materialA = materialB = materialC = material;
					}

					normalsA = sceneContext.vertexTerrainNormals.getOrDefault(vertexKeyA, normalsA);
					normalsB = sceneContext.vertexTerrainNormals.getOrDefault(vertexKeyB, normalsB);
					normalsC = sceneContext.vertexTerrainNormals.getOrDefault(vertexKeyC, normalsC);

					GroundMaterial groundMaterial = null;

					boolean useBlendedMaterialAndColor =
						plugin.configGroundBlending &&
						textureId == -1 &&
						!(isOverlay && proceduralGenerator.useDefaultColor(tile, override));
					if (override != TileOverride.NONE) {
						groundMaterial = override.groundMaterial;
						uvOrientation = override.uvOrientation;
						uvScale = override.uvScale;
						if (!useBlendedMaterialAndColor) {
							colorA = override.modifyColor(colorA);
							colorB = override.modifyColor(colorB);
							colorC = override.modifyColor(colorC);
						}
					} else if (textureId == -1) {
						// Fall back to the default ground material if the tile is untextured
						groundMaterial = override.groundMaterial;
					}

					if (useBlendedMaterialAndColor) {
						// get the vertices' colors and textures from hashmaps
						colorA = sceneContext.vertexTerrainColor.getOrDefault(vertexKeyA, colorA);
						colorB = sceneContext.vertexTerrainColor.getOrDefault(vertexKeyB, colorB);
						colorC = sceneContext.vertexTerrainColor.getOrDefault(vertexKeyC, colorC);

						if (plugin.configGroundTextures) {
							materialA = sceneContext.vertexTerrainTexture.getOrDefault(vertexKeyA, materialA);
							materialB = sceneContext.vertexTerrainTexture.getOrDefault(vertexKeyB, materialB);
							materialC = sceneContext.vertexTerrainTexture.getOrDefault(vertexKeyC, materialC);
						}
					} else if (plugin.configGroundTextures && groundMaterial != null) {
						materialA = groundMaterial.getRandomMaterial(
							worldPos[0] + (localVertices[0][0] >> LOCAL_COORD_BITS),
							worldPos[1] + (localVertices[0][1] >> LOCAL_COORD_BITS),
							worldPos[2]
						);
						materialB = groundMaterial.getRandomMaterial(
							worldPos[0] + (localVertices[1][0] >> LOCAL_COORD_BITS),
							worldPos[1] + (localVertices[1][1] >> LOCAL_COORD_BITS),
							worldPos[2]
						);
						materialC = groundMaterial.getRandomMaterial(
							worldPos[0] + (localVertices[2][0] >> LOCAL_COORD_BITS),
							worldPos[1] + (localVertices[2][1] >> LOCAL_COORD_BITS),
							worldPos[2]
						);
					}
				} else {
					// set colors for the shoreline to create a foam effect in the water shader
					colorA = colorB = colorC = 127;
					if (sceneContext.vertexIsWater.containsKey(vertexKeyA) && sceneContext.vertexIsLand.containsKey(vertexKeyA))
						colorA = 0;
					if (sceneContext.vertexIsWater.containsKey(vertexKeyB) && sceneContext.vertexIsLand.containsKey(vertexKeyB))
						colorB = 0;
					if (sceneContext.vertexIsWater.containsKey(vertexKeyC) && sceneContext.vertexIsLand.containsKey(vertexKeyC))
						colorC = 0;
				}

				if (sceneContext.vertexIsOverlay.containsKey(vertexKeyA) && sceneContext.vertexIsUnderlay.containsKey(vertexKeyA))
					vertexAIsOverlay = true;
				if (sceneContext.vertexIsOverlay.containsKey(vertexKeyB) && sceneContext.vertexIsUnderlay.containsKey(vertexKeyB))
					vertexBIsOverlay = true;
				if (sceneContext.vertexIsOverlay.containsKey(vertexKeyC) && sceneContext.vertexIsUnderlay.containsKey(vertexKeyC))
					vertexCIsOverlay = true;

				for (int i = 0; i < 3; i++)
					localVertices[i][2] -= override.heightOffset;
			}

			float terrainData = Float.intBitsToFloat(packTerrainData(true, 0, waterType, tileZ));

			sceneContext.stagingBufferNormals.ensureCapacity(12);
			sceneContext.stagingBufferNormals.put(normalsA[0], normalsA[2], normalsA[1], terrainData);
			sceneContext.stagingBufferNormals.put(normalsB[0], normalsB[2], normalsB[1], terrainData);
			sceneContext.stagingBufferNormals.put(normalsC[0], normalsC[2], normalsC[1], terrainData);

			sceneContext.stagingBufferVertices.ensureCapacity(12);
			sceneContext.stagingBufferVertices.put((float) localVertices[0][0], localVertices[0][2], localVertices[0][1], colorA);
			sceneContext.stagingBufferVertices.put((float) localVertices[1][0], localVertices[1][2], localVertices[1][1], colorB);
			sceneContext.stagingBufferVertices.put((float) localVertices[2][0], localVertices[2][2], localVertices[2][1], colorC);

			bufferLength += 3;

			int[] packedMaterialData = {
				materialA.packMaterialData(ModelOverride.NONE, UvType.GEOMETRY, vertexAIsOverlay, true),
				materialB.packMaterialData(ModelOverride.NONE, UvType.GEOMETRY, vertexBIsOverlay, true),
				materialC.packMaterialData(ModelOverride.NONE, UvType.GEOMETRY, vertexCIsOverlay, true)
			};

			float uvcos = -uvScale, uvsin = 0;
			if (uvOrientation % 2048 != 0) {
				float rad = -uvOrientation * JAU_TO_RAD;
				uvcos = cos(rad) * -uvScale;
				uvsin = sin(rad) * -uvScale;
			}

			sceneContext.stagingBufferUvs.ensureCapacity(12);
			for (int i = 0; i < 3; i++) {
				float uvx = worldPos[0] + localVertices[i][0] / 128f - 1;
				float uvy = worldPos[1] + localVertices[i][1] / 128f - 1;
				float tmp = uvx;
				uvx = uvx * uvcos - uvy * uvsin;
				uvy = tmp * uvsin + uvy * uvcos;

				sceneContext.stagingBufferUvs.put(uvx, uvy, 0, packedMaterialData[i]);
			}

			uvBufferLength += 3;
		}

		return new int[]{bufferLength, uvBufferLength, underwaterTerrain};
	}

	private int[] uploadHDTileModelUnderwater(LegacySceneContext sceneContext, Tile tile, int[] worldPos, SceneTileModel model) {
		final Scene scene = sceneContext.scene;
		final Point tilePoint = tile.getSceneLocation();
		final int tileX = tilePoint.getX();
		final int tileY = tilePoint.getY();
		final int tileExX = tileX + sceneContext.sceneOffset;
		final int tileExY = tileY + sceneContext.sceneOffset;
		final int tileZ = tile.getRenderLevel();

		int bufferLength = 0;
		int uvBufferLength = 0;
		int underwaterTerrain = 0;

		if (sceneContext.skipTile[tileZ][tileExX][tileExY])
			return new int[] { bufferLength, uvBufferLength, underwaterTerrain };

		final int[] faceColorA = model.getTriangleColorA();
		final int faceCount = model.getFaceX().length;
		final int[] faceTextures = model.getTriangleTextureId();

		int baseX = scene.getBaseX();
		int baseY = scene.getBaseY();

		if (baseX >= 2816 && baseX <= 2970 && baseY <= 5375 && baseY >= 5220) {
			// fix for God Wars Dungeon's water rendering over zamorak bridge
			return new int[] { bufferLength, uvBufferLength, underwaterTerrain };
		}

		if (sceneContext.tileIsWater[tileZ][tileExX][tileExY]) {
			underwaterTerrain = 1;

			int overlayId = OVERLAY_FLAG | scene.getOverlayIds()[tileZ][tileExX][tileExY];
			int underlayId = scene.getUnderlayIds()[tileZ][tileExX][tileExY];
			var overlayOverride = tileOverrideManager.getOverride(sceneContext, tile, worldPos, overlayId);
			var underlayOverride = tileOverrideManager.getOverride(sceneContext, tile, worldPos, underlayId);

			// underwater terrain
			for (int face = 0; face < faceCount; ++face) {
				int colorA, colorB, colorC;
				colorA = colorB = colorC = UNDERWATER_HSL;

				boolean isOverlay = ProceduralGenerator.isOverlayFace(tile, face);
				var override = isOverlay ? overlayOverride : underlayOverride;
				if (faceColorA[face] == HIDDEN_HSL && !override.forced)
					continue;

				int[][] localVertices = ProceduralGenerator.faceLocalVertices(tile, face);

				Material materialA = Material.NONE;
				Material materialB = Material.NONE;
				Material materialC = Material.NONE;

				int[] vertexKeys = ProceduralGenerator.faceVertexKeys(tile, face);
				int vertexKeyA = vertexKeys[0];
				int vertexKeyB = vertexKeys[1];
				int vertexKeyC = vertexKeys[2];

				int depthA = sceneContext.vertexUnderwaterDepth.getOrDefault(vertexKeyA, 0);
				int depthB = sceneContext.vertexUnderwaterDepth.getOrDefault(vertexKeyB, 0);
				int depthC = sceneContext.vertexUnderwaterDepth.getOrDefault(vertexKeyC, 0);

				if (plugin.configGroundTextures) {
					GroundMaterial groundMaterial = GroundMaterial.UNDERWATER_GENERIC;
					materialA = groundMaterial.getRandomMaterial(
						worldPos[0] + (localVertices[0][0] >> LOCAL_COORD_BITS),
						worldPos[1] + (localVertices[0][1] >> LOCAL_COORD_BITS),
						worldPos[2]
					);
					materialB = groundMaterial.getRandomMaterial(
						worldPos[0] + (localVertices[1][0] >> LOCAL_COORD_BITS),
						worldPos[1] + (localVertices[1][1] >> LOCAL_COORD_BITS),
						worldPos[2]
					);
					materialC = groundMaterial.getRandomMaterial(
						worldPos[0] + (localVertices[2][0] >> LOCAL_COORD_BITS),
						worldPos[1] + (localVertices[2][1] >> LOCAL_COORD_BITS),
						worldPos[2]
					);
				}

				int[] normalsA = sceneContext.vertexTerrainNormals.getOrDefault(vertexKeyA, UP_NORMAL);
				int[] normalsB = sceneContext.vertexTerrainNormals.getOrDefault(vertexKeyB, UP_NORMAL);
				int[] normalsC = sceneContext.vertexTerrainNormals.getOrDefault(vertexKeyC, UP_NORMAL);

				int textureId = faceTextures == null ? -1 : faceTextures[face];
				WaterType waterType = proceduralGenerator.seasonalWaterType(override, textureId);

				float aTerrainData = Float.intBitsToFloat(packTerrainData(true, max(1, depthA), waterType, tileZ));
				float bTerrainData = Float.intBitsToFloat(packTerrainData(true, max(1, depthB), waterType, tileZ));
				float cTerrainData = Float.intBitsToFloat(packTerrainData(true, max(1, depthC), waterType, tileZ));

				sceneContext.stagingBufferNormals.ensureCapacity(12);
				sceneContext.stagingBufferNormals.put(normalsA[0], normalsA[2], normalsA[1], aTerrainData);
				sceneContext.stagingBufferNormals.put(normalsB[0], normalsB[2], normalsB[1], bTerrainData);
				sceneContext.stagingBufferNormals.put(normalsC[0], normalsC[2], normalsC[1], cTerrainData);

				sceneContext.stagingBufferVertices.ensureCapacity(12);
				sceneContext.stagingBufferVertices.put(
					(float) localVertices[0][0],
					localVertices[0][2] + depthA,
					localVertices[0][1],
					colorA
				);
				sceneContext.stagingBufferVertices.put(
					(float) localVertices[1][0],
					localVertices[1][2] + depthB,
					localVertices[1][1],
					colorB
				);
				sceneContext.stagingBufferVertices.put(
					(float) localVertices[2][0],
					localVertices[2][2] + depthC,
					localVertices[2][1],
					colorC
				);

				bufferLength += 3;

				int packedMaterialDataA = materialA.packMaterialData(ModelOverride.NONE, UvType.GEOMETRY, false, true);
				int packedMaterialDataB = materialB.packMaterialData(ModelOverride.NONE, UvType.GEOMETRY, false, true);
				int packedMaterialDataC = materialC.packMaterialData(ModelOverride.NONE, UvType.GEOMETRY, false, true);

				sceneContext.stagingBufferUvs.ensureCapacity(12);
				sceneContext.stagingBufferUvs.put(1 - localVertices[0][0] / 128f, 1 - localVertices[0][1] / 128f, 0, packedMaterialDataA);
				sceneContext.stagingBufferUvs.put(1 - localVertices[1][0] / 128f, 1 - localVertices[1][1] / 128f, 0, packedMaterialDataB);
				sceneContext.stagingBufferUvs.put(1 - localVertices[2][0] / 128f, 1 - localVertices[2][1] / 128f, 0, packedMaterialDataC);

				uvBufferLength += 3;
			}
		}

		return new int[] { bufferLength, uvBufferLength, underwaterTerrain };
	}

	private void uploadCustomTile(LegacySceneContext sceneContext, int tileExX, int tileExY, int tileZ, Material material) {
		final Scene scene = sceneContext.scene;

		int color = 0;
		float fromX = 0;
		float fromY = 0;
		float toX = LOCAL_TILE_SIZE;
		float toY = LOCAL_TILE_SIZE;

		final int[][][] tileHeights = scene.getTileHeights();
		int swHeight = tileHeights[tileZ][tileExX][tileExY];
		int seHeight = tileHeights[tileZ][tileExX + 1][tileExY];
		int neHeight = tileHeights[tileZ][tileExX + 1][tileExY + 1];
		int nwHeight = tileHeights[tileZ][tileExX][tileExY + 1];

		float terrainData = Float.intBitsToFloat(packTerrainData(true, 0, WaterType.NONE, tileZ));

		sceneContext.stagingBufferNormals.ensureCapacity(24);
		sceneContext.stagingBufferNormals.put(0, -1, 0, terrainData);
		sceneContext.stagingBufferNormals.put(0, -1, 0, terrainData);
		sceneContext.stagingBufferNormals.put(0, -1, 0, terrainData);

		sceneContext.stagingBufferNormals.put(0, -1, 0, terrainData);
		sceneContext.stagingBufferNormals.put(0, -1, 0, terrainData);
		sceneContext.stagingBufferNormals.put(0, -1, 0, terrainData);

		sceneContext.stagingBufferVertices.ensureCapacity(24);
		sceneContext.stagingBufferVertices.put(toX, neHeight, toY, color);
		sceneContext.stagingBufferVertices.put(fromX, nwHeight, toY, color);
		sceneContext.stagingBufferVertices.put(toX, seHeight, fromY, color);

		sceneContext.stagingBufferVertices.put(fromX, swHeight, fromY, color);
		sceneContext.stagingBufferVertices.put(toX, seHeight, fromY, color);
		sceneContext.stagingBufferVertices.put(fromX, nwHeight, toY, color);

		int packedMaterialData = material.packMaterialData(ModelOverride.NONE, UvType.GEOMETRY, false, true);

		sceneContext.stagingBufferUvs.ensureCapacity(24);
		sceneContext.stagingBufferUvs.put(0, 0, 0, packedMaterialData);
		sceneContext.stagingBufferUvs.put(1, 0, 0, packedMaterialData);
		sceneContext.stagingBufferUvs.put(0, 1, 0, packedMaterialData);

		sceneContext.stagingBufferUvs.put(1, 1, 0, packedMaterialData);
		sceneContext.stagingBufferUvs.put(0, 1, 0, packedMaterialData);
		sceneContext.stagingBufferUvs.put(1, 0, 0, packedMaterialData);
	}
}

package rs117.hd.renderer;

import java.io.IOException;
import java.util.Set;
import javax.annotation.Nullable;
import net.runelite.api.hooks.*;
import org.lwjgl.opengl.*;
import rs117.hd.opengl.shader.ShaderException;
import rs117.hd.opengl.shader.ShaderIncludes;
import rs117.hd.scene.SceneContext;

public interface Renderer extends DrawCallbacks {
	default boolean supportsGpu(GLCapabilities glCaps) {
		return true;
	}
	default int gpuFlags() {
		return 0;
	}
	default void initialize() {}
	default void destroy() {}
	default void addShaderIncludes(ShaderIncludes includes) {}
	default void initializeShaders(ShaderIncludes includes) throws ShaderException, IOException {}
	default void destroyShaders() {}
	default void waitUntilIdle() {}
	default void processConfigChanges(Set<String> keys) {}
	default boolean isLoadingScene() {
		return false;
	}
	default void reloadScene() {}
	default void clearCaches() {}
	@Nullable
	default SceneContext getSceneContext() {
		return null;
	}
}

/*
 * Copyright (c) 2018, Adam <Adam@sigterm.info>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package rs117.hd.renderer.zone;

import java.nio.IntBuffer;
import java.util.Arrays;
import javax.inject.Inject;
import javax.inject.Singleton;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.*;
import rs117.hd.HdPlugin;
import rs117.hd.scene.MaterialManager;
import rs117.hd.scene.materials.Material;
import rs117.hd.scene.model_overrides.ModelOverride;
import rs117.hd.scene.model_overrides.UvType;
import rs117.hd.utils.HDUtils;
import rs117.hd.utils.buffer.GpuIntBuffer;

import static net.runelite.api.Perspective.*;
import static rs117.hd.utils.MathUtils.*;

@Slf4j
@Singleton
class FacePrioritySorter {
	private static final int[] EMPTY_NORMALS = new int[9];

	static final int[] distances;
	static final char[] distanceFaceCount;
	static final char[][] distanceToFaces;

	private static final float[] modelProjectedX;
	private static final float[] modelProjectedY;

	private static final float[] modelLocalX;
	private static final float[] modelLocalY;
	private static final float[] modelLocalZ;

	private static final float[] workingSpace;
	private static final float[] modelUvs;
	private static final int[] modelNormals;

	static final int[] numOfPriority;
	private static final int[] eq10;
	private static final int[] eq11;
	private static final int[] lt10;
	static final int[][] orderedFaces;

	private static int orientSin, orientCos;

	private static final int MAX_VERTEX_COUNT = 6500;
	private static final int MAX_DIAMETER = 6000;
	private static final int ZSORT_GROUP_SIZE = 1024; // was 512
	private static final int MAX_FACES_PER_PRIORITY = 4000; // was 2500

	private static final int[] MAX_BRIGHTNESS_LOOKUP_TABLE = new int[8];
	private static final float[] LIGHT_DIR_MODEL = new float[] { 0.57735026f, 0.57735026f, 0.57735026f };
	// subtracts the X lowest lightness levels from the formula.
	// helps keep darker colors appropriately dark
	private static final int IGNORE_LOW_LIGHTNESS = 3;
	// multiplier applied to vertex' lightness value.
	// results in greater lightening of lighter colors
	private static final float LIGHTNESS_MULTIPLIER = 3;
	// the minimum amount by which each color will be lightened
	private static final int BASE_LIGHTEN = 10;

	static {
		distances = new int[MAX_VERTEX_COUNT];
		distanceFaceCount = new char[MAX_DIAMETER];
		distanceToFaces = new char[MAX_DIAMETER][ZSORT_GROUP_SIZE];

		modelProjectedX = new float[MAX_VERTEX_COUNT];
		modelProjectedY = new float[MAX_VERTEX_COUNT];

		modelLocalX = new float[MAX_VERTEX_COUNT];
		modelLocalY = new float[MAX_VERTEX_COUNT];
		modelLocalZ = new float[MAX_VERTEX_COUNT];

		workingSpace = new float[9];
		modelUvs = new float[12];
		modelNormals = new int[9];

		numOfPriority = new int[12];
		eq10 = new int[MAX_FACES_PER_PRIORITY];
		eq11 = new int[MAX_FACES_PER_PRIORITY];
		lt10 = new int[12];
		orderedFaces = new int[12][MAX_FACES_PER_PRIORITY];

		for (int i = 0; i < 8; i++)
			MAX_BRIGHTNESS_LOOKUP_TABLE[i] = (int) (127 - 72 * Math.pow(i / 7f, .05));
	}

	@Inject
	private HdPlugin plugin;

	@Inject
	private MaterialManager materialManager;

	int uploadSortedModel(
		Projection proj,
		Model model,
		ModelOverride modelOverride,
		int preOrientation,
		int orientation,
		int x,
		int y,
		int z,
		IntBuffer opaqueBuffer,
		IntBuffer alphaBuffer
	) {
		final int vertexCount = model.getVerticesCount();
		final float[] verticesX = model.getVerticesX();
		final float[] verticesY = model.getVerticesY();
		final float[] verticesZ = model.getVerticesZ();

		final int faceCount = model.getFaceCount();
		final int[] indices1 = model.getFaceIndices1();
		final int[] indices2 = model.getFaceIndices2();
		final int[] indices3 = model.getFaceIndices3();

		final int[] faceColors3 = model.getFaceColors3();
		final byte[] faceRenderPriorities = model.getFaceRenderPriorities();

		orientation = mod(orientation, 2048);
		orientSin = SINE[orientation];
		orientCos = COSINE[orientation];
		float orientSinf = orientSin / 65536f;
		float orientCosf = orientCos / 65536f;

		float[] p = proj.project(x, y, z);
		int zero = (int) p[2];

		for (int v = 0; v < vertexCount; ++v) {
			float vertexX = verticesX[v];
			float vertexY = verticesY[v];
			float vertexZ = verticesZ[v];

			if (orientation != 0) {
				float x0 = vertexX;
				vertexX = vertexZ * orientSinf + x0 * orientCosf;
				vertexZ = vertexZ * orientCosf - x0 * orientSinf;
			}

			// move to local position
			vertexX += x;
			vertexY += y;
			vertexZ += z;

			modelLocalX[v] = vertexX;
			modelLocalY[v] = vertexY;
			modelLocalZ[v] = vertexZ;

			p = proj.project(vertexX, vertexY, vertexZ);
			if (p[2] < 50) {
				return 0;
			}

			modelProjectedX[v] = p[0] / p[2];
			modelProjectedY[v] = p[1] / p[2];
			distances[v] = (int) p[2] - zero;
		}

		model.calculateBoundsCylinder();
		final int diameter = model.getDiameter();
		final int radius = model.getRadius();
		if (diameter >= 6000) {
			return 0;
		}

		Arrays.fill(distanceFaceCount, 0, diameter, (char) 0);

		for (char i = 0; i < faceCount; ++i) {
			if (faceColors3[i] == -2)
				continue;

			final int v1 = indices1[i];
			final int v2 = indices2[i];
			final int v3 = indices3[i];

			final float
				aX = modelProjectedX[v1],
				aY = modelProjectedY[v1],
				bX = modelProjectedX[v2],
				bY = modelProjectedY[v2],
				cX = modelProjectedX[v3],
				cY = modelProjectedY[v3];
			// Back-face culling
			if ((aX - bX) * (cY - bY) - (cX - bX) * (aY - bY) <= 0)
				continue;

			int distance = radius + (distances[v1] + distances[v2] + distances[v3]) / 3;
			assert distance >= 0 && distance < diameter;
			distanceToFaces[distance][distanceFaceCount[distance]++] = i;
		}

		int len = 0;
		if (faceRenderPriorities == null) {
			for (int i = diameter - 1; i >= 0; --i) {
				final int cnt = distanceFaceCount[i];
				if (cnt > 0) {
					final char[] faces = distanceToFaces[i];
					for (int faceIdx = 0; faceIdx < cnt; ++faceIdx) {
						final int face = faces[faceIdx];
						len += pushFace(model, modelOverride, preOrientation, face, opaqueBuffer, alphaBuffer);
					}
				}
			}
		} else {
			Arrays.fill(numOfPriority, 0);
			Arrays.fill(lt10, 0);

			for (int i = diameter - 1; i >= 0; --i) {
				final int cnt = distanceFaceCount[i];
				if (cnt > 0) {
					final char[] faces = distanceToFaces[i];
					for (int faceIdx = 0; faceIdx < cnt; ++faceIdx) {
						final int face = faces[faceIdx];
						final byte pri = faceRenderPriorities[face];
						final int distIdx = numOfPriority[pri]++;

						orderedFaces[pri][distIdx] = face;
						if (pri < 10) {
							lt10[pri] += i;
						} else if (pri == 10) {
							eq10[distIdx] = i;
						} else {
							eq11[distIdx] = i;
						}
					}
				}
			}

			int avg12 = 0;
			if (numOfPriority[1] > 0 || numOfPriority[2] > 0)
				avg12 = (lt10[1] + lt10[2]) / (numOfPriority[1] + numOfPriority[2]);

			int avg34 = 0;
			if (numOfPriority[3] > 0 || numOfPriority[4] > 0)
				avg34 = (lt10[3] + lt10[4]) / (numOfPriority[3] + numOfPriority[4]);

			int avg68 = 0;
			if (numOfPriority[6] > 0 || numOfPriority[8] > 0)
				avg68 = (lt10[8] + lt10[6]) / (numOfPriority[8] + numOfPriority[6]);

			int drawnFaces = 0;
			int numDynFaces = numOfPriority[10];
			int[] dynFaces = orderedFaces[10];
			int[] dynFaceDistances = eq10;
			if (drawnFaces == numDynFaces) {
				numDynFaces = numOfPriority[11];
				dynFaces = orderedFaces[11];
				dynFaceDistances = eq11;
			}

			int currFaceDistance = drawnFaces < numDynFaces ? dynFaceDistances[drawnFaces] : -1000;

			for (int pri = 0; pri < 10; ++pri) {
				while (pri == 0 && currFaceDistance > avg12) {
					final int face = dynFaces[drawnFaces++];
					len += pushFace(model, modelOverride, preOrientation, face, opaqueBuffer, alphaBuffer);

					if (drawnFaces == numDynFaces && dynFaces != orderedFaces[11]) {
						drawnFaces = 0;
						numDynFaces = numOfPriority[11];
						dynFaces = orderedFaces[11];
						dynFaceDistances = eq11;
					}

					currFaceDistance = drawnFaces < numDynFaces ? dynFaceDistances[drawnFaces] : -1000;
				}

				while (pri == 3 && currFaceDistance > avg34) {
					final int face = dynFaces[drawnFaces++];
					len += pushFace(model, modelOverride, preOrientation, face, opaqueBuffer, alphaBuffer);

					if (drawnFaces == numDynFaces && dynFaces != orderedFaces[11]) {
						drawnFaces = 0;
						numDynFaces = numOfPriority[11];
						dynFaces = orderedFaces[11];
						dynFaceDistances = eq11;
					}

					currFaceDistance = drawnFaces < numDynFaces ? dynFaceDistances[drawnFaces] : -1000;
				}

				while (pri == 5 && currFaceDistance > avg68) {
					final int face = dynFaces[drawnFaces++];
					len += pushFace(model, modelOverride, preOrientation, face, opaqueBuffer, alphaBuffer);

					if (drawnFaces == numDynFaces && dynFaces != orderedFaces[11]) {
						drawnFaces = 0;
						numDynFaces = numOfPriority[11];
						dynFaces = orderedFaces[11];
						dynFaceDistances = eq11;
					}

					currFaceDistance = drawnFaces < numDynFaces ? dynFaceDistances[drawnFaces] : -1000;
				}

				final int priNum = numOfPriority[pri];
				final int[] priFaces = orderedFaces[pri];

				for (int faceIdx = 0; faceIdx < priNum; ++faceIdx) {
					final int face = priFaces[faceIdx];
					len += pushFace(model, modelOverride, preOrientation, face, opaqueBuffer, alphaBuffer);
				}
			}

			while (currFaceDistance != -1000) {
				final int face = dynFaces[drawnFaces++];
				len += pushFace(model, modelOverride, preOrientation, face, opaqueBuffer, alphaBuffer);

				if (drawnFaces == numDynFaces && dynFaces != orderedFaces[11]) {
					drawnFaces = 0;
					dynFaces = orderedFaces[11];
					numDynFaces = numOfPriority[11];
					dynFaceDistances = eq11;
				}

				currFaceDistance = drawnFaces < numDynFaces ? dynFaceDistances[drawnFaces] : -1000;
			}
		}

		return len;
	}

	private int pushFace(
		Model model,
		ModelOverride modelOverride,
		int preOrientation,
		int face,
		IntBuffer opaqueBuffer,
		IntBuffer alphaBuffer
	) {
		final int[] indices1 = model.getFaceIndices1();
		final int[] indices2 = model.getFaceIndices2();
		final int[] indices3 = model.getFaceIndices3();

		final short[] unlitFaceColors = plugin.configUnlitFaceColors ? model.getUnlitFaceColors() : null;
		final int[] faceColors1 = model.getFaceColors1();
		final int[] faceColors2 = model.getFaceColors2();
		final int[] faceColors3 = model.getFaceColors3();

		final int[] xVertexNormals = model.getVertexNormalsX();
		final int[] yVertexNormals = model.getVertexNormalsY();
		final int[] zVertexNormals = model.getVertexNormalsZ();
		final boolean hasVertexNormals = xVertexNormals != null && yVertexNormals != null && zVertexNormals != null;

		final byte overrideAmount = model.getOverrideAmount();
		final byte overrideHue = model.getOverrideHue();
		final byte overrideSat = model.getOverrideSaturation();
		final byte overrideLum = model.getOverrideLuminance();

		final short[] faceTextures = model.getFaceTextures();
		final byte[] textureFaces = model.getTextureFaces();
		final int[] texIndices1 = model.getTexIndices1();
		final int[] texIndices2 = model.getTexIndices2();
		final int[] texIndices3 = model.getTexIndices3();

		final byte[] transparencies = model.getFaceTransparencies();
		final byte[] bias = model.getFaceBias();


		boolean isVanillaTextured = faceTextures != null;
		boolean isVanillaUVMapped =
			isVanillaTextured && // Vanilla UV mapped models don't always have sensible UVs for untextured faces
			model.getTextureFaces() != null;
		int textureId = isVanillaTextured ? faceTextures[face] : -1;

		Material baseMaterial = modelOverride.baseMaterial;
		Material textureMaterial = modelOverride.textureMaterial;

		final int triangleA = indices1[face];
		final int triangleB = indices2[face];
		final int triangleC = indices3[face];

		float vx1 = modelLocalX[triangleA];
		float vy1 = modelLocalY[triangleA];
		float vz1 = modelLocalZ[triangleA];

		float vx2 = modelLocalX[triangleB];
		float vy2 = modelLocalY[triangleB];
		float vz2 = modelLocalZ[triangleB];

		float vx3 = modelLocalX[triangleC];
		float vy3 = modelLocalY[triangleC];
		float vz3 = modelLocalZ[triangleC];

		int color1 = faceColors1[face];
		int color2 = faceColors2[face];
		int color3 = faceColors3[face];

		if (color3 == -1)
			color2 = color3 = color1;

		// Hide fake shadows or lighting that is often baked into models by making the fake shadow transparent
		if (plugin.configHideFakeShadows && modelOverride.hideVanillaShadows && HDUtils.isBakedGroundShading(model, face))
			return 0;

		if (unlitFaceColors != null) {
			color1 = color2 = color3 = unlitFaceColors[face] & 0xFFFF;
		} else if (plugin.configUndoVanillaShading && hasVertexNormals) {
			int color1H = color1 >> 10 & 0x3F;
			int color1S = color1 >> 7 & 0x7;
			int color1L = color1 & 0x7F;
			int color2H = color2 >> 10 & 0x3F;
			int color2S = color2 >> 7 & 0x7;
			int color2L = color2 & 0x7F;
			int color3H = color3 >> 10 & 0x3F;
			int color3S = color3 >> 7 & 0x7;
			int color3L = color3 & 0x7F;

			// Approximately invert vanilla shading by brightening vertices that were likely darkened by vanilla based on
			// vertex normals. This process is error-prone, as not all models are lit by vanilla with the same light
			// direction, and some models even have baked lighting built into the model itself. In some cases, increasing
			// brightness in this way leads to overly bright colors, so we are forced to cap brightness at a relatively
			// low value for it to look acceptable in most cases.
			float[] L = LIGHT_DIR_MODEL;
			float color1Adjust =
				BASE_LIGHTEN - color1L + (color1L < IGNORE_LOW_LIGHTNESS ? 0 : (color1L - IGNORE_LOW_LIGHTNESS) * LIGHTNESS_MULTIPLIER);
			float color2Adjust =
				BASE_LIGHTEN - color2L + (color2L < IGNORE_LOW_LIGHTNESS ? 0 : (color2L - IGNORE_LOW_LIGHTNESS) * LIGHTNESS_MULTIPLIER);
			float color3Adjust =
				BASE_LIGHTEN - color3L + (color3L < IGNORE_LOW_LIGHTNESS ? 0 : (color3L - IGNORE_LOW_LIGHTNESS) * LIGHTNESS_MULTIPLIER);

			// Normals are currently unrotated, so we don't need to do any rotation for this
			float nx, ny, nz, lightDotNormal;
			nx = xVertexNormals[triangleA];
			ny = yVertexNormals[triangleA];
			nz = zVertexNormals[triangleA];
			lightDotNormal = nx * L[0] + ny * L[1] + nz * L[2];
			if (lightDotNormal > 0) {
				lightDotNormal /= sqrt(nx * nx + ny * ny + nz * nz);
				color1L += (int) (lightDotNormal * color1Adjust);
			}

			nx = xVertexNormals[triangleB];
			ny = yVertexNormals[triangleB];
			nz = zVertexNormals[triangleB];
			lightDotNormal = nx * L[0] + ny * L[1] + nz * L[2];
			if (lightDotNormal > 0) {
				lightDotNormal /= sqrt(nx * nx + ny * ny + nz * nz);
				color2L += (int) (lightDotNormal * color2Adjust);
			}

			nx = xVertexNormals[triangleC];
			ny = yVertexNormals[triangleC];
			nz = zVertexNormals[triangleC];
			lightDotNormal = nx * L[0] + ny * L[1] + nz * L[2];
			if (lightDotNormal > 0) {
				lightDotNormal /= sqrt(nx * nx + ny * ny + nz * nz);
				color3L += (int) (lightDotNormal * color3Adjust);
			}

			int maxBrightness1 = 55;
			int maxBrightness2 = 55;
			int maxBrightness3 = 55;
			if (!plugin.configLegacyGreyColors) {
				maxBrightness1 = MAX_BRIGHTNESS_LOOKUP_TABLE[color1S];
				maxBrightness2 = MAX_BRIGHTNESS_LOOKUP_TABLE[color2S];
				maxBrightness3 = MAX_BRIGHTNESS_LOOKUP_TABLE[color3S];
			}

			// Clamp brightness as detailed above
			color1L = min(color1L, maxBrightness1);
			color2L = min(color2L, maxBrightness2);
			color3L = min(color3L, maxBrightness3);

			color1 = color1H << 10 | color1S << 7 | color1L;
			color2 = color2H << 10 | color2S << 7 | color2L;
			color3 = color3H << 10 | color3S << 7 | color3L;
		}

		// HSL override is not applied to textured faces
		if (overrideAmount > 0 && textureId == -1) {
			color1 = SceneUploader.interpolateHSL(color1, overrideHue, overrideSat, overrideLum, overrideAmount);
			color2 = SceneUploader.interpolateHSL(color2, overrideHue, overrideSat, overrideLum, overrideAmount);
			color3 = SceneUploader.interpolateHSL(color3, overrideHue, overrideSat, overrideLum, overrideAmount);
		}

		int texA, texB, texC;

		if (isVanillaUVMapped && textureFaces[face] != -1) {
			int tface = textureFaces[face] & 0xff;
			texA = texIndices1[tface];
			texB = texIndices2[tface];
			texC = texIndices3[tface];
		} else {
			texA = triangleA;
			texB = triangleB;
			texC = triangleC;
		}

		int transparency = transparencies != null ? transparencies[face] & 0xFF : 0;

		UvType uvType = UvType.GEOMETRY;
		Material material = baseMaterial;
		ModelOverride faceOverride = modelOverride;

		if (textureId != -1) {
			color1 = color2 = color3 = 90;
			uvType = UvType.VANILLA;
			if (textureMaterial != Material.NONE) {
				material = textureMaterial;
			} else {
				material = materialManager.fromVanillaTexture(textureId);
				if (modelOverride.materialOverrides != null) {
					var override = modelOverride.materialOverrides.get(material);
					if (override != null) {
						faceOverride = override;
						material = faceOverride.textureMaterial;
					}
				}
			}
		} else if (modelOverride.colorOverrides != null) {
			int ahsl = (0xFF - transparency) << 16 | color1;
			for (var override : modelOverride.colorOverrides) {
				if (override.ahslCondition.test(ahsl)) {
					faceOverride = override;
					material = faceOverride.baseMaterial;
					break;
				}
			}
		}

		if (material != Material.NONE) {
			uvType = faceOverride.uvType;
			if (uvType == UvType.VANILLA || (textureId != -1 && faceOverride.retainVanillaUvs))
				uvType = isVanillaUVMapped && textureFaces[face] != -1 ? UvType.VANILLA : UvType.GEOMETRY;
		}

		boolean keepShading = true; // Skip vanilla shading reversal in the shader, since we do it on the CPU
		int materialData = material.packMaterialData(faceOverride, uvType, false, keepShading);

		if (uvType == UvType.VANILLA) {
			modelUvs[0] = modelLocalX[texA] - vx1;
			modelUvs[1] = modelLocalY[texA] - vy1;
			modelUvs[2] = modelLocalZ[texA] - vz1;
			modelUvs[4] = modelLocalX[texB] - vx2;
			modelUvs[5] = modelLocalY[texB] - vy2;
			modelUvs[6] = modelLocalZ[texB] - vz2;
			modelUvs[8] = modelLocalX[texC] - vx3;
			modelUvs[9] = modelLocalY[texC] - vy3;
			modelUvs[10] = modelLocalZ[texC] - vz3;
		} else {
			faceOverride.fillUvsForFace(modelUvs, model, preOrientation, uvType, face, workingSpace);
		}

		final int[] faceNormals;
		if (hasVertexNormals) {
			if (faceOverride.flatNormals || (!plugin.configPreserveVanillaNormals && faceColors3[face] == -1)) {
				faceNormals = EMPTY_NORMALS;
			} else {
				faceNormals = modelNormals;
				faceNormals[0] = xVertexNormals[triangleA];
				faceNormals[1] = yVertexNormals[triangleA];
				faceNormals[2] = zVertexNormals[triangleA];
				faceNormals[3] = xVertexNormals[triangleB];
				faceNormals[4] = yVertexNormals[triangleB];
				faceNormals[5] = zVertexNormals[triangleB];
				faceNormals[6] = xVertexNormals[triangleC];
				faceNormals[7] = yVertexNormals[triangleC];
				faceNormals[8] = zVertexNormals[triangleC];

				// Rotate normals
				for (int i = 0; i < 9; i += 3) {
					int x = modelNormals[i];
					int z = modelNormals[i + 2];
					modelNormals[i] = z * orientSin + x * orientCos >> 16;
					modelNormals[i + 2] = z * orientCos - x * orientSin >> 16;
				}
			}
		} else {
			faceNormals = EMPTY_NORMALS;
		}

		int depthBias = faceOverride.depthBias != -1 ? faceOverride.depthBias :
			bias == null ? 0 : bias[face] & 0xFF;
		int packedAlphaBiasHsl = transparency << 24 | depthBias << 16;
		boolean hasAlpha = material.hasTransparency || transparency != 0;
		var vb = hasAlpha ? alphaBuffer : opaqueBuffer;
		GpuIntBuffer.putFloatVertex(
			vb,
			vx1, vy1, vz1, packedAlphaBiasHsl | color1,
			modelUvs[0], modelUvs[1], modelUvs[2], materialData,
			faceNormals[0], faceNormals[1], faceNormals[2], 0
		);
		GpuIntBuffer.putFloatVertex(
			vb,
			vx2, vy2, vz2, packedAlphaBiasHsl | color2,
			modelUvs[4], modelUvs[5], modelUvs[6], materialData,
			faceNormals[3], faceNormals[4], faceNormals[5], 0
		);
		GpuIntBuffer.putFloatVertex(
			vb,
			vx3, vy3, vz3, packedAlphaBiasHsl | color3,
			modelUvs[8], modelUvs[9], modelUvs[10], materialData,
			faceNormals[6], faceNormals[7], faceNormals[8], 0
		);
		return 3;
	}
}

package rs117.hd.renderer.zone;

import com.google.common.base.Stopwatch;
import java.util.ArrayDeque;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.locks.ReentrantLock;
import java.util.stream.Collectors;
import javax.annotation.Nullable;
import javax.inject.Inject;
import javax.inject.Singleton;
import lombok.Getter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.*;
import net.runelite.client.callback.ClientThread;
import rs117.hd.HdPlugin;
import rs117.hd.HdPluginConfig;
import rs117.hd.opengl.uniforms.UBOWorldViews;
import rs117.hd.overlays.FrameTimer;
import rs117.hd.overlays.Timer;
import rs117.hd.scene.AreaManager;
import rs117.hd.scene.EnvironmentManager;
import rs117.hd.scene.FishingSpotReplacer;
import rs117.hd.scene.LightManager;
import rs117.hd.scene.ProceduralGenerator;
import rs117.hd.scene.areas.AABB;
import rs117.hd.scene.areas.Area;
import rs117.hd.utils.NpcDisplacementCache;
import rs117.hd.utils.jobs.GenericJob;

import static net.runelite.api.Constants.*;
import static net.runelite.api.Perspective.SCENE_SIZE;
import static rs117.hd.HdPlugin.checkGLErrors;
import static rs117.hd.utils.MathUtils.*;

@Slf4j
@Singleton
public class SceneManager {
	public static final int MAX_WORLDVIEWS = 4096;
	public static final int NUM_ZONES = EXTENDED_SCENE_SIZE >> 3;

	private static final int ZONE_DEFER_DIST_START = 3;

	@Inject
	private Client client;

	@Inject
	private ClientThread clientThread;

	@Inject
	private HdPlugin plugin;

	@Inject
	private HdPluginConfig config;

	@Inject
	private AreaManager areaManager;

	@Inject
	private EnvironmentManager environmentManager;

	@Inject
	private LightManager lightManager;

	@Inject
	private ProceduralGenerator proceduralGenerator;

	@Inject
	private NpcDisplacementCache npcDisplacementCache;

	@Inject
	private FishingSpotReplacer fishingSpotReplacer;

	@Inject
	private FrameTimer frameTimer;

	private UBOWorldViews uboWorldViews;

	private final Map<Integer, Integer> nextRoofChanges = new HashMap<>();
	@Getter
	private final WorldViewContext root = new WorldViewContext(this, null, null, null);
	private final WorldViewContext[] subs = new WorldViewContext[MAX_WORLDVIEWS];
	private final List<SortedZone> sortedZones = new ArrayList<>();
	private ZoneSceneContext nextSceneContext;
	private Zone[][] nextZones;
	private boolean reloadRequested;

	public boolean isZoneStreamingEnabled() {
		return plugin.configZoneStreaming;
	}

	@Getter
	public final ReentrantLock loadingLock = new ReentrantLock();

	public boolean isTopLevelValid() {
		return root.sceneContext != null;
	}

	@Nullable
	public ZoneSceneContext getSceneContext() {
		return root.sceneContext;
	}

	public boolean isRoot(WorldViewContext context) { return root == context; }

	public WorldViewContext getContext(Scene scene) {
		return getContext(scene.getWorldViewId());
	}

	public WorldViewContext getContext(WorldView wv) {
		return getContext(wv.getId());
	}

	public WorldViewContext getContext(int worldViewId) {
		if (worldViewId != -1)
			return subs[worldViewId];
		if (root.sceneContext == null)
			return null;
		return root;
	}

	public void initialize(UBOWorldViews uboWorldViews) {
		this.uboWorldViews = uboWorldViews;
	}

	public void destroy() {
		root.free();

		for (int i = 0; i < subs.length; i++) {
			if (subs[i] != null)
				subs[i].free();
			subs[i] = null;
		}

		Zone.freeZones(nextZones);
		nextZones = null;
		if (nextSceneContext != null)
			nextSceneContext.destroy();
		nextSceneContext = null;

		uboWorldViews = null;
	}

	public void update() {
		frameTimer.begin(Timer.UPDATE_AREA_HIDING);
		updateAreaHiding();
		frameTimer.end(Timer.UPDATE_AREA_HIDING);

		Zone.processPendingDeletions();

		if (reloadRequested && loadingLock.getHoldCount() == 0) {
			reloadRequested = false;
			try {
				loadingLock.lock();

				completeAllStreaming();

				if (!generateSceneDataTask.isDone())
					generateSceneDataTask.waitForCompletion();
				generateSceneDataTask.queue();

				root.invalidate();
				for (var sub : subs)
					if (sub != null)
						sub.invalidate();

				root.sceneLoadGroup.complete();
				root.streamingGroup.complete();
				root.invalidationGroup.complete();
			} finally {
				loadingLock.unlock();
				log.trace("loadingLock unlocked - holdCount: {}", loadingLock.getHoldCount());
			}
		}

		root.update(plugin.deltaTime);

		WorldView wv = client.getTopLevelWorldView();
		if (wv != null) {
			for (WorldEntity we : wv.worldEntities()) {
				WorldViewContext ctx = getContext(we.getWorldView());
				if (ctx != null)
					ctx.update(plugin.deltaTime);
			}
		}

		// TODO: Wait for zone invalidations without blocking other async loading
		// Ensure any queued zone invalidations are now completed
//		root.completeInvalidation();
//
//		if (wv != null) {
//			for (WorldEntity we : wv.worldEntities()) {
//				WorldViewContext ctx = getContext(we.getWorldView());
//				if (ctx != null)
//					ctx.completeInvalidation();
//			}
//		}
	}

	private void updateAreaHiding() {
		Player localPlayer = client.getLocalPlayer();
		if (!isTopLevelValid() || localPlayer == null || root.isLoading)
			return;

		var lp = localPlayer.getLocalLocation();
		if (root.sceneContext.enableAreaHiding) {
			var base = root.sceneContext.sceneBase;
			assert base != null;
			int[] worldPos = {
				base[0] + lp.getSceneX(),
				base[1] + lp.getSceneY(),
				base[2] + client.getTopLevelWorldView().getPlane()
			};

			// We need to check all areas contained in the scene in the order they appear in the list,
			// in order to ensure lower floors can take precedence over higher floors which include tiny
			// portions of the floor beneath around stairs and ladders
			Area newArea = null;
			for (var area : root.sceneContext.possibleAreas) {
				if (area.containsPoint(false, worldPos)) {
					newArea = area;
					break;
				}
			}

			// Force a scene reload if the player is no longer in the same area
			if (newArea != root.sceneContext.currentArea) {
				if (plugin.justChangedArea) {
					// Disable area hiding if it somehow gets stuck in a loop switching areas
					root.sceneContext.enableAreaHiding = false;
					log.error(
						"Disabling area hiding after moving from {} to {} at {}",
						root.sceneContext.currentArea,
						newArea,
						worldPos
					);
					newArea = null;
				} else {
					plugin.justChangedArea = true;
					// This should happen very rarely, so we invalidate all zones for simplicity
					root.invalidate();
				}
				root.sceneContext.currentArea = newArea;
			} else {
				plugin.justChangedArea = false;
			}
		} else {
			plugin.justChangedArea = false;
		}
	}

	public void despawnWorldView(WorldView worldView) {
		int worldViewId = worldView.getId();
		if (worldViewId > -1) {
			log.debug("WorldView despawn: {}", worldViewId);
			if (subs[worldViewId] == null) {
				log.debug("Attempted to despawn unloaded worldview: {}", worldView);
			} else {
				subs[worldViewId].free();
				subs[worldViewId] = null;
			}
		}
	}

	public void reloadScene() {
		if (!plugin.isActive() || reloadRequested)
			return;

		reloadRequested = true;
		log.debug("Scene reload requested");
	}

	public boolean isLoadingScene() { return nextSceneContext != null; }

	public void completeAllStreaming() {
		root.sceneLoadGroup.complete();
		root.streamingGroup.complete();

		root.completeInvalidation();

		WorldView wv = client.getTopLevelWorldView();
		if (wv != null) {
			for (WorldEntity we : wv.worldEntities()) {
				WorldViewContext ctx = getContext(we.getWorldView());
				if (ctx != null) {
					ctx.sceneLoadGroup.complete();
					ctx.streamingGroup.complete();

					ctx.completeInvalidation();
				}
			}
		}
	}

	public void invalidateZone(Scene scene, int zx, int zz) {
		WorldViewContext ctx = getContext(scene);
		if (ctx == null)
			return;

		Zone zone = ctx.zones[zx][zz];
		if (zone.rebuild)
			return;

		zone.rebuild = true;
		log.debug("Zone invalidated: wx={} x={} z={}", scene.getWorldViewId(), zx, zz);
	}

	private static boolean isEdgeTile(Zone[][] zones, int zx, int zz) {
		for (int x = zx - 2; x <= zx + 2; ++x) {
			if (x < 0 || x >= NUM_ZONES)
				return true;
			for (int z = zz - 2; z <= zz + 2; ++z) {
				if (z < 0 || z >= NUM_ZONES)
					return true;
				Zone zone = zones[x][z];
				if (!zone.initialized)
					return true;
				if (zone.sizeO == 0 && zone.sizeA == 0)
					return true;
			}
		}
		return false;
	}

	@Getter
	private final GenericJob generateSceneDataTask = GenericJob.build(
		"ProceduralGenerator::generateSceneData",
		(task) -> proceduralGenerator.generateSceneData(nextSceneContext != null ? nextSceneContext : root.sceneContext)
	);

	@Getter
	private final GenericJob loadSceneLightsTask = GenericJob.build(
		"LightManager::loadSceneLights",
		(task) -> lightManager.loadSceneLights(nextSceneContext, root.sceneContext)
	);

	private final GenericJob calculateRoofChangesTask = GenericJob.build(
		"calculateRoofChanges",
		(task) -> {
			Scene prev = client.getTopLevelWorldView().getScene();
			Scene scene = nextSceneContext.scene;

			// Calculate roof ids for the zone
			final int[][][] prids = prev.getRoofs();
			final int[][][] nrids = scene.getRoofs();

			final int dx = scene.getBaseX() - prev.getBaseX() >> 3;
			final int dy = scene.getBaseY() - prev.getBaseY() >> 3;

			nextRoofChanges.clear();
			for (int x = 0; x < EXTENDED_SCENE_SIZE; ++x) {
				for (int z = 0; z < EXTENDED_SCENE_SIZE; ++z) {
					int ox = x + (dx << 3);
					int oz = z + (dy << 3);

					for (int level = 0; level < 4; ++level) {
						task.workerHandleCancel();
						// old zone still in scene?
						if (ox >= 0 && oz >= 0 && ox < EXTENDED_SCENE_SIZE && oz < EXTENDED_SCENE_SIZE) {
							int prid = prids[level][ox][oz];
							int nrid = nrids[level][x][z];
							if (prid > 0 && nrid > 0 && prid != nrid) {
								Integer old = nextRoofChanges.putIfAbsent(prid, nrid);
								if (old == null) {
									log.trace("Roof change: {} -> {}", prid, nrid);
								} else if (old != nrid) {
									log.debug("Roof change mismatch: {} -> {} vs {}", prid, nrid, old);
								}
							}
						}
					}
				}
			}
		}
	);

	public synchronized void loadScene(WorldView worldView, Scene scene) {
		try {
			loadingLock.lock();
			if (scene.getWorldViewId() > -1) {
				loadSubScene(worldView, scene);
				return;
			}

			assert worldView.getId() == -1;
			if (nextZones != null)
				throw new RuntimeException("Double zone load!"); // does this happen?

			Stopwatch sw = Stopwatch.createStarted();
			root.isLoading = true;
			root.loadTime = root.uploadTime = root.sceneSwapTime = 0;

			root.sceneLoadGroup.complete();
			root.streamingGroup.complete();
			root.invalidationGroup.complete();

			if (nextSceneContext != null)
				nextSceneContext.destroy();
			nextSceneContext = null;

			nextZones = new Zone[NUM_ZONES][NUM_ZONES];
			nextSceneContext = new ZoneSceneContext(
				client,
				worldView,
				scene,
				plugin.getExpandedMapLoadingChunks(),
				root.sceneContext
			);

			WorldViewContext ctx = root;
			Scene prev = client.getTopLevelWorldView().getScene();

			nextSceneContext.enableAreaHiding = nextSceneContext.sceneBase != null && config.hideUnrelatedAreas();

			if (nextSceneContext.intersects(areaManager.getArea("PLAYER_OWNED_HOUSE"))) {
				nextSceneContext.isInHouse = true;
				nextSceneContext.isInChambersOfXeric = false;
			} else {
				nextSceneContext.isInHouse = false;
				nextSceneContext.isInChambersOfXeric = nextSceneContext.intersects(areaManager.getArea("CHAMBERS_OF_XERIC"));
			}

			environmentManager.loadSceneEnvironments(nextSceneContext);

			loadSceneLightsTask.cancel();
			calculateRoofChangesTask.cancel();

			generateSceneDataTask.queue();
			loadSceneLightsTask.queue();

			if (nextSceneContext.enableAreaHiding) {
				assert nextSceneContext.sceneBase != null;
				int centerOffset = SCENE_SIZE / 2 & ~7;
				int centerX = nextSceneContext.sceneBase[0] + centerOffset;
				int centerY = nextSceneContext.sceneBase[1] + centerOffset;

				nextSceneContext.possibleAreas = Arrays
					.stream(areaManager.areasWithAreaHiding)
					.filter(area -> nextSceneContext.sceneBounds.intersects(area.aabbs))
					.toArray(Area[]::new);

				if (log.isDebugEnabled() && nextSceneContext.possibleAreas.length > 0) {
					log.debug(
						"Area hiding areas: {}",
						Arrays.stream(nextSceneContext.possibleAreas)
							.distinct()
							.map(Area::toString)
							.collect(Collectors.joining(", "))
					);
				}

				// If area hiding can be decided based on the central chunk, apply it early
				AABB centerChunk = new AABB(centerX, centerY, centerX + 7, centerY + 7);
				for (Area possibleArea : nextSceneContext.possibleAreas) {
					if (!possibleArea.intersects(centerChunk))
						continue;

					if (nextSceneContext.currentArea != null) {
						// Multiple possible areas, so let's defer this until swapScene
						nextSceneContext.currentArea = null;
						break;
					}
					nextSceneContext.currentArea = possibleArea;
				}
			}

			for (int x = 0; x < NUM_ZONES; ++x) {
				for (int z = 0; z < NUM_ZONES; ++z) {
					Zone curZone = ctx.zones[x][z];
					curZone.cull = true;

					// Last minute chance for a streamed in zone to be reused
					ctx.handleZoneSwap(-1.0f, x, z);
					// Mark all zones to be culled, unless they get reused later
					ctx.zones[x][z].cull = true;
				}
			}

			// Queue after ensuring previous scene has been cancelled
			calculateRoofChangesTask.queue();

			final int dx = scene.getBaseX() - prev.getBaseX() >> 3;
			final int dy = scene.getBaseY() - prev.getBaseY() >> 3;

			if (ctx.sceneContext != null &&
				prev.isInstance() == scene.isInstance() &&
				client.getGameState() == GameState.LOGGED_IN && // only reuse for async loads to respect roof removal state changes
				ctx.sceneContext.expandedMapLoadingChunks == nextSceneContext.expandedMapLoadingChunks &&
				ctx.sceneContext.currentArea == nextSceneContext.currentArea) {
				for (int x = 0; x < NUM_ZONES; ++x) {
					for (int z = 0; z < NUM_ZONES; ++z) {
						int ox = x + dx;
						int oz = z + dy;
						if (ox < 0 || ox >= NUM_ZONES || oz < 0 || oz >= NUM_ZONES)
							continue;

						final Zone old = ctx.zones[ox][oz];
						if (!old.initialized || (old.sizeO == 0 && old.sizeA == 0))
							continue;

						old.needsRoofUpdate = true;

						if (old.hasWater || old.dirty || isEdgeTile(ctx.zones, ox, oz)) {
							float dist = distance(vec(x, z), vec(NUM_ZONES / 2, NUM_ZONES / 2));
							sortedZones.add(SortedZone.getZone(old, x, z, dist));
							nextSceneContext.totalDeferred++;
						} else {
							// The zone can be reused without modifications
							old.cull = false;
							nextSceneContext.totalReused++;
						}

						nextZones[x][z] = old;
					}
				}
			}

			boolean staggerLoad =
				isZoneStreamingEnabled() &&
				!nextSceneContext.isInHouse &&
				root.sceneContext != null &&
				nextSceneContext.totalReused + nextSceneContext.totalDeferred > 0;
			for (int x = 0; x < NUM_ZONES; ++x) {
				for (int z = 0; z < NUM_ZONES; ++z) {
					Zone zone = nextZones[x][z];
					if (zone == null)
						zone = nextZones[x][z] = new Zone();

					if (!zone.initialized) {
						float dist = distance(vec(x, z), vec(NUM_ZONES / 2, NUM_ZONES / 2));
						if (!staggerLoad || dist < ZONE_DEFER_DIST_START) {
							ZoneUploadJob
								.build(ctx, nextSceneContext, zone, x, z)
								.queue(ctx.sceneLoadGroup, generateSceneDataTask);
							nextSceneContext.totalMapZones++;
						} else {
							sortedZones.add(SortedZone.getZone(zone, x, z, dist));
							nextSceneContext.totalDeferred++;
						}
					}
				}
			}

			for (SortedZone sorted : sortedZones) {
				Zone newZone = new Zone();
				newZone.dirty = sorted.zone.dirty;
				if (staggerLoad) {
					// Reuse the old zone while uploading a correct one
					sorted.zone.cull = false;
					sorted.zone.uploadJob = ZoneUploadJob
						.build(ctx, nextSceneContext, newZone, sorted.x, sorted.z);
					sorted.zone.uploadJob.delay = 0.5f + clamp(sorted.dist / 15.0f, 0.0f, 1.0f) * 1.5f;
				} else {
					nextZones[sorted.x][sorted.z] = newZone;
					ZoneUploadJob
						.build(ctx, nextSceneContext, newZone, sorted.x, sorted.z)
						.queue(ctx.sceneLoadGroup, generateSceneDataTask);
				}
				sorted.free();
			}
			sortedZones.clear();

			root.loadTime = sw.elapsed(TimeUnit.NANOSECONDS);
			log.debug("loadScene time: {}", sw);
		} finally {
			loadingLock.unlock();
			log.trace("loadingLock unlocked - holdCount: {}", loadingLock.getHoldCount());
		}
	}

	public void swapScene(Scene scene) {
		if (!plugin.isActive() || plugin.skipScene == scene) {
			plugin.redrawPreviousFrame = true;
			return;
		}

		if (scene.getWorldViewId() > -1) {
			swapSubScene(scene);
			return;
		}

		if (nextSceneContext == null)
			return; // Return early if scene loading failed

		Stopwatch sw = Stopwatch.createStarted();

		fishingSpotReplacer.despawnRuneLiteObjects();
		npcDisplacementCache.clear();

		boolean isFirst = root.sceneContext == null;
		if (!isFirst)
			root.sceneContext.destroy(); // Destroy the old context before replacing it

		// Wait for roof change calculation to complete
		calculateRoofChangesTask.waitForCompletion();

		WorldViewContext ctx = root;
		if (!nextRoofChanges.isEmpty()) {
			for (int x = 0; x < ctx.sizeX; ++x) {
				for (int z = 0; z < ctx.sizeZ; ++z) {
					Zone zone = nextZones[x][z];
					if (zone.needsRoofUpdate) {
						zone.needsRoofUpdate = false;
						zone.updateRoofs(nextRoofChanges);
					}
				}
			}
		}
		long roofsTime = sw.elapsed(TimeUnit.MILLISECONDS);
		log.debug("swapScene - Roofs: {} ms", roofsTime);

		// Handle object spawns that must be processed on the client thread
		loadSceneLightsTask.waitForCompletion();

		for (var tileObject : nextSceneContext.lightSpawnsToHandleOnClientThread)
			lightManager.handleObjectSpawn(nextSceneContext, tileObject);
		nextSceneContext.lightSpawnsToHandleOnClientThread.clear();

		long lightsTime = sw.elapsed(TimeUnit.MILLISECONDS);
		log.debug("swapScene - Lights: {} ms", lightsTime - roofsTime);

		long sceneUploadTimeStart = sw.elapsed(TimeUnit.NANOSECONDS);
		int blockingCount = root.sceneLoadGroup.getPendingCount();
		root.sceneLoadGroup.complete();

		int totalOpaque = 0;
		int totalAlpha = 0;
		for (int x = 0; x < NUM_ZONES; ++x) {
			for (int z = 0; z < NUM_ZONES; ++z) {
				totalOpaque += nextZones[x][z].bufLen;
				totalAlpha += nextZones[x][z].bufLenA;
			}
		}

		root.uploadTime = sw.elapsed(TimeUnit.NANOSECONDS) - sceneUploadTimeStart;
		log.debug(
			"upload time {} reused {} deferred {} map {} sceneLoad {} len opaque {} size opaque {} KiB len alpha {} size alpha {} KiB",
			TimeUnit.MILLISECONDS.convert(root.uploadTime, TimeUnit.NANOSECONDS),
			nextSceneContext.totalReused,
			nextSceneContext.totalDeferred,
			nextSceneContext.totalMapZones,
			blockingCount,
			totalOpaque,
			(totalOpaque * Zone.VERT_SIZE * 3L) / KiB,
			totalAlpha,
			(totalAlpha * Zone.VERT_SIZE * 3L) / KiB
		);

		for (int x = 0; x < ctx.sizeX; ++x) {
			for (int z = 0; z < ctx.sizeZ; ++z) {
				Zone preZone = ctx.zones[x][z];
				Zone nextZone = nextZones[x][z];

				assert !preZone.cull || preZone != nextZone : "Zone which is marked for culling was reused!";
				if (preZone.cull)
					root.pendingCull.add(preZone);

				nextZone.setMetadata(ctx, nextSceneContext, x, z);
			}
		}

		ctx.zones = nextZones;
		root.sceneContext = nextSceneContext;
		root.isLoading = false;

		nextZones = null;
		nextSceneContext = null;

		if (isFirst) {
			// Load all pre-existing sub scenes on the first scene load
			for (WorldEntity subEntity : client.getTopLevelWorldView().worldEntities()) {
				WorldView sub = subEntity.getWorldView();
				Scene subScene = sub.getScene();
				log.debug(
					"Loading worldview: id={}, sizeX={}, sizeZ={}",
					sub.getId(),
					sub.getSizeX(),
					sub.getSizeY()
				);
				loadSubScene(sub, subScene);
				swapSubScene(subScene);
			}
		}

		checkGLErrors();
		root.sceneSwapTime = sw.elapsed(TimeUnit.NANOSECONDS);
		log.debug("swapScene time: {}", sw);
	}

	private void loadSubScene(WorldView worldView, Scene scene) {
		int worldViewId = worldView.getId();
		assert worldViewId != -1;

		log.debug("Loading world view {}", worldViewId);
		Stopwatch sw = Stopwatch.createStarted();
		final WorldViewContext prevCtx = subs[worldViewId];
		if (prevCtx != null) {
			log.error("Reload of an already loaded sub scene?");
			prevCtx.sceneLoadGroup.cancel();
			prevCtx.streamingGroup.cancel();
			clientThread.invoke(prevCtx::free);
		}

		var sceneContext = new ZoneSceneContext(client, worldView, scene, plugin.getExpandedMapLoadingChunks(), null);
		proceduralGenerator.generateSceneData(sceneContext);

		final WorldViewContext ctx = new WorldViewContext(this, worldView, sceneContext, uboWorldViews);
		subs[worldViewId] = ctx;

		for (int x = 0; x < ctx.sizeX; ++x)
			for (int z = 0; z < ctx.sizeZ; ++z)
				ZoneUploadJob
					.build(ctx, sceneContext, ctx.zones[x][z], x, z)
					.queue(ctx.sceneLoadGroup);

		ctx.loadTime = sw.elapsed(TimeUnit.NANOSECONDS);
	}

	private void swapSubScene(Scene scene) {
		WorldViewContext ctx = getContext(scene);
		if (ctx == null)
			return;

		Stopwatch sw = Stopwatch.createStarted();
		ctx.sceneLoadGroup.complete();
		ctx.uploadTime = sw.elapsed(TimeUnit.NANOSECONDS);
		ctx.initMetadata();
		ctx.isLoading = false;
		ctx.sceneSwapTime = sw.elapsed(TimeUnit.NANOSECONDS);
		log.debug("swapSubScene time {} WorldView ready: {}", ctx.sceneSwapTime, scene.getWorldViewId());
	}

	static class SortedZone implements Comparable<SortedZone> {
		private static final ArrayDeque<SortedZone> POOL = new ArrayDeque<>();

		public Zone zone;
		public int x, z;
		public float dist;

		public static SortedZone getZone(Zone zone, int x, int z, float dist) {
			SortedZone sorted = POOL.poll();
			if (sorted == null)
				sorted = new SortedZone();
			sorted.zone = zone;
			sorted.x = x;
			sorted.z = z;
			sorted.dist = dist;
			return sorted;
		}

		public void free() { POOL.add(this); }

		@Override
		public int compareTo(SortedZone o) {
			return Float.compare(dist, o.dist);
		}
	}
}

/*
 * Copyright (c) 2018, Adam <Adam@sigterm.info>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package rs117.hd.renderer.zone;

import java.nio.IntBuffer;
import java.util.HashSet;
import java.util.Set;
import javax.inject.Inject;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.*;
import net.runelite.client.callback.RenderCallbackManager;
import rs117.hd.HdPlugin;
import rs117.hd.scene.GamevalManager;
import rs117.hd.scene.MaterialManager;
import rs117.hd.scene.ModelOverrideManager;
import rs117.hd.scene.ProceduralGenerator;
import rs117.hd.scene.TileOverrideManager;
import rs117.hd.scene.ground_materials.GroundMaterial;
import rs117.hd.scene.materials.Material;
import rs117.hd.scene.model_overrides.InheritTileColorType;
import rs117.hd.scene.model_overrides.ModelOverride;
import rs117.hd.scene.model_overrides.TzHaarRecolorType;
import rs117.hd.scene.model_overrides.UvType;
import rs117.hd.scene.tile_overrides.TileOverride;
import rs117.hd.scene.water_types.WaterType;
import rs117.hd.utils.HDUtils;
import rs117.hd.utils.ModelHash;
import rs117.hd.utils.buffer.GpuIntBuffer;

import static net.runelite.api.Constants.*;
import static net.runelite.api.Perspective.*;
import static rs117.hd.scene.tile_overrides.TileOverride.NONE;
import static rs117.hd.scene.tile_overrides.TileOverride.OVERLAY_FLAG;
import static rs117.hd.utils.HDUtils.HIDDEN_HSL;
import static rs117.hd.utils.HDUtils.UNDERWATER_HSL;
import static rs117.hd.utils.MathUtils.*;

@Slf4j
public class SceneUploader {
	private static final int MAX_VERTEX_COUNT = 6500;
	private static final int[] UP_NORMAL = { 0, -1, 0 };
	private static final int[] EMPTY_NORMALS = new int[9];

	@Inject
	private RenderCallbackManager renderCallbackManager;

	@Inject
	private HdPlugin plugin;

	@Inject
	public GamevalManager gamevalManager;

	@Inject
	private MaterialManager materialManager;

	@Inject
	private TileOverrideManager tileOverrideManager;

	@Inject
	private ModelOverrideManager modelOverrideManager;

	@Inject
	public ProceduralGenerator proceduralGenerator;

	private int basex, basez, rid, level;

	private final Set<Integer> roofIds = new HashSet<>();
	private Scene currentScene;
	private Tile[][][] tiles;
	private byte[][][] settings;
	private int[][][] roofs;
	private short[][][] overlayIds;
	private short[][][] underlayIds;
	private int[][][] tileHeights;

	private final int[] worldPos = new int[3];
	private final int[][] vertices = new int[4][3];
	private final int[] vertexKeys = new int[4];
	private final float[] workingSpace = new float[9];
	private final float[] modelUvs = new float[12];
	private final int[] modelNormals = new int[9];

	private final float[] modelLocalX = new float[MAX_VERTEX_COUNT];
	private final float[] modelLocalY = new float[MAX_VERTEX_COUNT];
	private final float[] modelLocalZ = new float[MAX_VERTEX_COUNT];

	private final int[] modelLocalXI = new int[MAX_VERTEX_COUNT];
	private final int[] modelLocalYI = new int[MAX_VERTEX_COUNT];
	private final int[] modelLocalZI = new int[MAX_VERTEX_COUNT];

	public void setScene(Scene scene) {
		if (scene == currentScene)
			return;

		currentScene = scene;
		tiles = scene.getExtendedTiles();
		settings = scene.getExtendedTileSettings();
		roofs = scene.getRoofs();
		overlayIds = scene.getOverlayIds();
		underlayIds = scene.getUnderlayIds();
		tileHeights = scene.getTileHeights();
	}

	public void clear() {
		tiles = null;
		settings = null;
		roofs = null;
		overlayIds = null;
		underlayIds = null;
		tileHeights = null;
		currentScene = null;
	}

	protected void onBeforeProcessTile(Tile t, boolean isEstimate) {}

	public void estimateZoneSize(ZoneSceneContext ctx, Zone zone, int mzx, int mzz) {
		// Initialize the zone as containing only water, until a non-water tile is found
		zone.onlyWater = true;

		for (int z = 3; z >= 0; --z) {
			for (int xoff = 0; xoff < 8; ++xoff) {
				for (int zoff = 0; zoff < 8; ++zoff) {
					Tile t = tiles[z][(mzx << 3) + xoff][(mzz << 3) + zoff];
					if (t != null) {
						onBeforeProcessTile(t, true);
						estimateZoneTileSize(ctx, zone, t);
					}
				}
			}
		}
	}

	public void uploadZone(ZoneSceneContext ctx, Zone zone, int mzx, int mzz) {
		var vb = zone.vboO != null ? new GpuIntBuffer(zone.vboO.vb) : null;
		var ab = zone.vboA != null ? new GpuIntBuffer(zone.vboA.vb) : null;

		roofIds.clear();
		for (int level = 0; level <= 3; ++level) {
			for (int xoff = 0; xoff < 8; ++xoff) {
				for (int zoff = 0; zoff < 8; ++zoff) {
					int rid = roofs[level][(mzx << 3) + xoff][(mzz << 3) + zoff];
					if (rid > 0)
						roofIds.add(rid);
				}
			}
		}

		zone.rids = new int[4][roofIds.size()];
		zone.roofStart = new int[4][roofIds.size()];
		zone.roofEnd = new int[4][roofIds.size()];

		for (int z = 0; z <= 3; ++z) {
			this.level = z;

			if (z == 0) {
				uploadZoneLevel(ctx, zone, mzx, mzz, 0, false, roofIds, vb, ab);
				uploadZoneLevel(ctx, zone, mzx, mzz, 0, true, roofIds, vb, ab);
				uploadZoneLevel(ctx, zone, mzx, mzz, 1, true, roofIds, vb, ab);
				uploadZoneLevel(ctx, zone, mzx, mzz, 2, true, roofIds, vb, ab);
				uploadZoneLevel(ctx, zone, mzx, mzz, 3, true, roofIds, vb, ab);
			} else {
				uploadZoneLevel(ctx, zone, mzx, mzz, z, false, roofIds, vb, ab);
			}

			if (zone.vboO != null) {
				int pos = zone.vboO.vb.position();
				zone.levelOffsets[z] = pos;
			}
		}

		// Upload water surface tiles to be drawn after everything else
		if (zone.hasWater && vb != null) {
			uploadZoneWater(ctx, zone, mzx, mzz, vb);
			zone.levelOffsets[Zone.LEVEL_WATER_SURFACE] = vb.position();
		}
	}

	private void uploadZoneLevel(
		ZoneSceneContext ctx,
		Zone zone,
		int mzx,
		int mzz,
		int level,
		boolean visbelow,
		Set<Integer> roofIds,
		GpuIntBuffer vb,
		GpuIntBuffer ab
	) {
		int ridx = 0;

		// upload the roofs and save their positions
		for (int id : roofIds) {
			int pos = zone.vboO != null ? zone.vboO.vb.position() : 0;

			uploadZoneLevelRoof(ctx, zone, mzx, mzz, level, id, visbelow, vb, ab);

			int endpos = zone.vboO != null ? zone.vboO.vb.position() : 0;

			if (endpos > pos) {
				zone.rids[level][ridx] = id;
				zone.roofStart[level][ridx] = pos;
				zone.roofEnd[level][ridx] = endpos;
				++ridx;
			}
		}

		// upload everything else
		uploadZoneLevelRoof(ctx, zone, mzx, mzz, level, 0, visbelow, vb, ab);
	}

	private void uploadZoneLevelRoof(
		ZoneSceneContext ctx,
		Zone zone,
		int mzx,
		int mzz,
		int level,
		int roofId,
		boolean visbelow,
		GpuIntBuffer vb,
		GpuIntBuffer ab
	) {
		this.basex = (mzx - (ctx.sceneOffset >> 3)) << 10;
		this.basez = (mzz - (ctx.sceneOffset >> 3)) << 10;

		for (int xoff = 0; xoff < 8; ++xoff) {
			for (int zoff = 0; zoff < 8; ++zoff) {
				int msx = (mzx << 3) + xoff;
				int msz = (mzz << 3) + zoff;

				boolean isbridge = (settings[1][msx][msz] & Constants.TILE_FLAG_BRIDGE) != 0;
				int maplevel = level;
				if (isbridge) {
					++maplevel;
				}

				boolean isvisbelow = maplevel <= 3 && (settings[maplevel][msx][msz] & Constants.TILE_FLAG_VIS_BELOW) != 0;
				int rid;
				if (isvisbelow || maplevel == 0) {
					rid = 0;
				} else {
					rid = roofs[maplevel - 1][msx][msz];
				}

				if (isvisbelow != visbelow) {
					continue;
				}

				if (rid == roofId) {
					Tile t = tiles[level][msx][msz];
					if (t != null) {
						this.rid = rid;
						onBeforeProcessTile(t, false);
						uploadZoneTile(ctx, zone, t, false, false, vb, ab);
					}
				}
			}
		}
	}

	private void uploadZoneWater(ZoneSceneContext ctx, Zone zone, int mzx, int mzz, GpuIntBuffer vb) {
		this.basex = (mzx - (ctx.sceneOffset >> 3)) << 10;
		this.basez = (mzz - (ctx.sceneOffset >> 3)) << 10;

		for (int level = 0; level < MAX_Z; level++) {
			for (int xoff = 0; xoff < 8; ++xoff) {
				for (int zoff = 0; zoff < 8; ++zoff) {
					int msx = (mzx << 3) + xoff;
					int msz = (mzz << 3) + zoff;
					Tile t = tiles[level][msx][msz];
					if (t != null) {
						onBeforeProcessTile(t, false);
						uploadZoneTile(ctx, zone, t, false, true, vb, null);
					}
				}
			}
		}
	}

	private void estimateZoneTileSize(ZoneSceneContext ctx, Zone z, Tile t) {
		var tilePoint = t.getSceneLocation();
		ctx.sceneToWorld(tilePoint.getX(), tilePoint.getY(), t.getPlane(), worldPos);

		SceneTilePaint paint = t.getSceneTilePaint();
		if (paint != null && paint.getNeColor() != HIDDEN_HSL) {
			z.sizeO += 2;

			TileOverride override = tileOverrideManager.getOverride(ctx, t, worldPos);
			WaterType waterType = proceduralGenerator.seasonalWaterType(override, paint.getTexture());
			if (waterType != WaterType.NONE) {
				z.hasWater = true;
				// Since these are surface tiles, they should perhaps technically be in the alpha buffer,
				// but we'll render them in the correct order without needing face sorting,
				// so we might as well use the opaque buffer for simplicity
				z.sizeO += 2;
			} else {
				z.onlyWater = false;
			}
		}

		SceneTileModel model = t.getSceneTileModel();
		if (model != null) {
			int len = model.getFaceX().length;
			z.sizeO += len;

			int tileExX = tilePoint.getX() + ctx.sceneOffset;
			int tileExY = tilePoint.getY() + ctx.sceneOffset;
			int tileZ = t.getRenderLevel();
			int overlayId = OVERLAY_FLAG | overlayIds[tileZ][tileExX][tileExY];
			int underlayId = underlayIds[tileZ][tileExX][tileExY];
			var overlayOverride = tileOverrideManager.getOverride(ctx, t, worldPos, overlayId);
			var underlayOverride = tileOverrideManager.getOverride(ctx, t, worldPos, underlayId);

			final int[] triangleTextures = model.getTriangleTextureId();
			boolean isFallbackWater = false;
			if (triangleTextures != null) {
				for (int textureId : triangleTextures) {
					if (textureId != -1 && proceduralGenerator.seasonalWaterType(TileOverride.NONE, textureId) != WaterType.NONE) {
						isFallbackWater = true;
						break;
					}
				}
			}
			WaterType overlayWaterType = proceduralGenerator.seasonalWaterType(overlayOverride, 0);
			WaterType underlayWaterType = proceduralGenerator.seasonalWaterType(underlayOverride, 0);
			boolean isOverlayWater = overlayWaterType != WaterType.NONE;
			boolean isUnderlayWater = underlayWaterType != WaterType.NONE;
			if (isFallbackWater || isOverlayWater || isUnderlayWater) {
				z.hasWater = true;
				z.sizeO += len;
			} else {
				z.onlyWater = false;
			}
		}

		WallObject wallObject = t.getWallObject();
		if (wallObject != null) {
			ModelOverride modelOverride = modelOverrideManager.getOverride(wallObject, worldPos);
			if (!modelOverride.hide) {
				estimateRenderableSize(z, wallObject.getRenderable1(), modelOverride);
				estimateRenderableSize(z, wallObject.getRenderable2(), modelOverride);
			}
		}

		DecorativeObject decorativeObject = t.getDecorativeObject();
		if (decorativeObject != null) {
			ModelOverride modelOverride = modelOverrideManager.getOverride(decorativeObject, worldPos);
			if (!modelOverride.hide) {
				estimateRenderableSize(z, decorativeObject.getRenderable(), modelOverride);
				estimateRenderableSize(z, decorativeObject.getRenderable2(), modelOverride);
			}
		}

		GroundObject groundObject = t.getGroundObject();
		if (groundObject != null) {
			ModelOverride modelOverride = modelOverrideManager.getOverride(groundObject, worldPos);
			if (!modelOverride.hide)
				estimateRenderableSize(z, groundObject.getRenderable(), modelOverride);
		}

		GameObject[] gameObjects = t.getGameObjects();
		for (GameObject gameObject : gameObjects) {
			if (gameObject == null || !gameObject.getSceneMinLocation().equals(t.getSceneLocation()))
				continue;

			if (ModelHash.isTemporaryObject(gameObject.getHash()))
				continue;

			ModelOverride modelOverride = modelOverrideManager.getOverride(gameObject, worldPos);
			if (modelOverride.hide)
				continue;

			estimateRenderableSize(z, gameObject.getRenderable(), modelOverride);
		}

		Tile bridge = t.getBridge();
		if (bridge != null)
			estimateZoneTileSize(ctx, z, bridge);
	}

	private void uploadZoneTile(
		ZoneSceneContext ctx,
		Zone zone,
		Tile t,
		boolean isBridge,
		boolean onlyWaterSurface,
		GpuIntBuffer vertexBuffer,
		GpuIntBuffer alphaBuffer
	) {
		var tilePoint = t.getSceneLocation();
		int tileExX = tilePoint.getX() + ctx.sceneOffset;
		int tileExY = tilePoint.getY() + ctx.sceneOffset;
		int tileZ = t.getRenderLevel();
		ctx.sceneToWorld(tilePoint.getX(), tilePoint.getY(), t.getPlane(), worldPos);

		if (ctx.currentArea != null && !isBridge && !ctx.currentArea.containsPoint(worldPos))
			return;

		boolean drawTile = renderCallbackManager.drawTile(ctx.scene, t);

		SceneTilePaint paint = t.getSceneTilePaint();
		if (paint != null && drawTile) {
			uploadTilePaint(
				ctx,
				t,
				paint,
				onlyWaterSurface,
				tileExX, tileExY, tileZ,
				vertexBuffer,
				tilePoint.getX() * 128 - basex, tilePoint.getY() * 128 - basez
			);
		}

		SceneTileModel model = t.getSceneTileModel();
		if (model != null && drawTile)
			uploadTileModel(ctx, t, model, onlyWaterSurface, tileExX, tileExY, tileZ, basex, basez, vertexBuffer);

		if (!onlyWaterSurface)
			uploadZoneTileRenderables(ctx, zone, t, vertexBuffer, alphaBuffer);

		Tile bridge = t.getBridge();
		if (bridge != null)
			uploadZoneTile(ctx, zone, bridge, true, onlyWaterSurface, vertexBuffer, alphaBuffer);
	}

	private void uploadZoneTileRenderables(
		ZoneSceneContext ctx,
		Zone zone,
		Tile t,
		GpuIntBuffer vertexBuffer,
		GpuIntBuffer alphaBuffer
	) {
		WallObject wallObject = t.getWallObject();
		if (wallObject != null && renderCallbackManager.drawObject(ctx.scene, wallObject)) {
			int uuid = ModelHash.packUuid(ModelHash.TYPE_WALL_OBJECT, wallObject.getId());
			Renderable renderable1 = wallObject.getRenderable1();
			uploadZoneRenderable(
				ctx,
				zone,
				t,
				renderable1,
				uuid,
				HDUtils.convertWallObjectOrientation(wallObject.getOrientationA()),
				0,
				wallObject.getX(),
				wallObject.getZ(),
				wallObject.getY(),
				-1,
				-1,
				-1,
				-1,
				wallObject.getId(),
				vertexBuffer,
				alphaBuffer
			);

			Renderable renderable2 = wallObject.getRenderable2();
			uploadZoneRenderable(
				ctx,
				zone,
				t,
				renderable2,
				uuid,
				HDUtils.convertWallObjectOrientation(wallObject.getOrientationB()),
				0,
				wallObject.getX(),
				wallObject.getZ(),
				wallObject.getY(),
				-1,
				-1,
				-1,
				-1,
				wallObject.getId(),
				vertexBuffer,
				alphaBuffer
			);
		}

		DecorativeObject decorativeObject = t.getDecorativeObject();
		if (decorativeObject != null && renderCallbackManager.drawObject(ctx.scene, decorativeObject)) {
			int uuid = ModelHash.packUuid(ModelHash.TYPE_DECORATIVE_OBJECT, decorativeObject.getId());
			int preOrientation = HDUtils.getModelPreOrientation(decorativeObject.getConfig());
			Renderable renderable = decorativeObject.getRenderable();
			uploadZoneRenderable(
				ctx,
				zone,
				t,
				renderable,
				uuid,
				preOrientation,
				0,
				decorativeObject.getX() + decorativeObject.getXOffset(),
				decorativeObject.getZ(),
				decorativeObject.getY() + decorativeObject.getYOffset(),
				-1,
				-1,
				-1,
				-1,
				decorativeObject.getId(),
				vertexBuffer,
				alphaBuffer
			);

			Renderable renderable2 = decorativeObject.getRenderable2();
			uploadZoneRenderable(
				ctx,
				zone,
				t,
				renderable2,
				uuid,
				preOrientation,
				0,
				decorativeObject.getX(),
				decorativeObject.getZ(),
				decorativeObject.getY(),
				-1,
				-1,
				-1,
				-1,
				decorativeObject.getId(),
				vertexBuffer,
				alphaBuffer
			);
		}

		GroundObject groundObject = t.getGroundObject();
		if (groundObject != null && renderCallbackManager.drawObject(ctx.scene, groundObject)) {
			Renderable renderable = groundObject.getRenderable();
			uploadZoneRenderable(
				ctx,
				zone,
				t,
				renderable,
				ModelHash.packUuid(ModelHash.TYPE_GROUND_OBJECT, groundObject.getId()),
				HDUtils.getModelPreOrientation(groundObject.getConfig()),
				0,
				groundObject.getX(), groundObject.getZ(), groundObject.getY(),
				-1,
				-1, -1,
				-1,
				groundObject.getId(),
				vertexBuffer,
				alphaBuffer
			);
		}

		GameObject[] gameObjects = t.getGameObjects();
		for (GameObject gameObject : gameObjects) {
			if (gameObject == null || !renderCallbackManager.drawObject(ctx.scene, gameObject))
				continue;

			if (ModelHash.isTemporaryObject(gameObject.getHash()))
				continue;

			Point min = gameObject.getSceneMinLocation();
			if (!min.equals(t.getSceneLocation()))
				continue;

			Point max = gameObject.getSceneMaxLocation();
			Renderable renderable = gameObject.getRenderable();
			uploadZoneRenderable(
				ctx,
				zone,
				t,
				renderable,
				ModelHash.packUuid(ModelHash.TYPE_GAME_OBJECT, gameObject.getId()),
				HDUtils.getModelPreOrientation(gameObject.getConfig()),
				gameObject.getModelOrientation(),
				gameObject.getX(), gameObject.getZ(), gameObject.getY(),
				min.getX(),
				min.getY(), max.getX(),
				max.getY(),
				gameObject.getId(),
				vertexBuffer,
				alphaBuffer
			);
		}
	}

	private void estimateRenderableSize(Zone z, Renderable r, ModelOverride modelOverride) {
		boolean mightHaveTransparency = modelOverride.mightHaveTransparency;
		Model m = null;
		if (r instanceof Model) {
			m = (Model) r;
		} else if (r instanceof DynamicObject) {
			var dynamic = (DynamicObject) r;
			m = dynamic.getModelZbuf();
			if (dynamic.getRecordedObjectComposition() != null)
				mightHaveTransparency = true;
		}
		if (m == null)
			return;

		int faceCount = m.getFaceCount();
		byte[] transparencies = m.getFaceTransparencies();
		short[] faceTextures = m.getFaceTextures();
		if (transparencies == null && faceTextures == null && !mightHaveTransparency) {
			z.sizeO += faceCount;
		} else {
			z.sizeO += faceCount;
			z.sizeA += faceCount;
		}
	}

	private void uploadZoneRenderable(
		ZoneSceneContext ctx,
		Zone zone,
		Tile tile,
		Renderable r,
		int uuid,
		int preOrientation,
		int orient,
		int x,
		int y,
		int z,
		int lx,
		int lz,
		int ux,
		int uz,
		int id,
		GpuIntBuffer opaqueBuffer,
		GpuIntBuffer alphaBuffer
	) {
		Model model = null;
		if (r instanceof Model) {
			model = (Model) r;
		} else if (r instanceof DynamicObject) {
			var dynamic = (DynamicObject) r;
			model = dynamic.getModelZbuf();
			var composition = dynamic.getRecordedObjectComposition();
			if (composition != null)
				uuid = ModelHash.packUuid(ModelHash.TYPE_GAME_OBJECT, composition.getId());
		}
		if (model == null)
			return;

		ModelOverride modelOverride = modelOverrideManager.getOverride(uuid, worldPos);
		if (modelOverride.hide)
			return;

		int alphaStart = zone.vboA != null ? zone.vboA.vb.position() : 0;
		try {
			uploadStaticModel(
				ctx, tile, model, modelOverride, uuid,
				preOrientation, orient,
				x - basex, y, z - basez,
				opaqueBuffer,
				alphaBuffer
			);
		} catch (Throwable ex) {
			log.warn(
				"Error uploading {} {} {} {} (ID {}), override=\"{}\", opaque={}, alpha={}",
				r instanceof DynamicObject ? "dynamic" : "static",
				ModelHash.getTypeName(ModelHash.getUuidType(uuid)),
				ModelHash.getUuidSubType(uuid),
				gamevalManager.getObjectName(id),
				id,
				modelOverride.description,
				opaqueBuffer,
				alphaBuffer,
				ex
			);
		}

		int alphaEnd = zone.vboA != null ? zone.vboA.vb.position() : 0;
		if (alphaEnd > alphaStart) {
			if (lx > -1) {
				lx -= basex >> 7;
				lz -= basez >> 7;
				ux -= basex >> 7;
				uz -= basez >> 7;
				assert lx >= 0 : lx;
				assert lz >= 0 : lz;
				assert ux < 25 : ux; // largest object?
				assert uz < 25 : uz;
			}
			try {
				zone.addAlphaModel(
					plugin,
					materialManager,
					zone.glVaoA, model, modelOverride, alphaStart, alphaEnd,
					x - basex, y, z - basez,
					lx, lz, ux, uz,
					rid, level, id
				);
			} catch (Throwable ex) {
				log.warn(
					"Error adding alpha model for {} {} {} {} (ID {}), override=\"{}\", opaque={}, alpha={}",
					r instanceof DynamicObject ? "dynamic" : "static",
					ModelHash.getTypeName(ModelHash.getUuidType(uuid)),
					ModelHash.getUuidSubType(uuid),
					gamevalManager.getObjectName(id),
					id,
					modelOverride.description,
					opaqueBuffer,
					alphaBuffer,
					ex
				);
			}
		}
	}

	@SuppressWarnings({ "UnnecessaryLocalVariable" })
	private void uploadTilePaint(
		ZoneSceneContext ctx,
		Tile tile,
		SceneTilePaint paint,
		boolean onlyWaterSurface,
		int tileExX, int tileExY, int tileZ,
		GpuIntBuffer vb,
		int lx,
		int lz
	) {
		int swColor = paint.getSwColor();
		int seColor = paint.getSeColor();
		int neColor = paint.getNeColor();
		int nwColor = paint.getNwColor();

		if (neColor == HIDDEN_HSL)
			return;

		TileOverride override = tileOverrideManager.getOverride(ctx, tile, worldPos);
		WaterType waterType = proceduralGenerator.seasonalWaterType(override, paint.getTexture());
		if (onlyWaterSurface && waterType == WaterType.NONE)
			return;

		int swHeight = tileHeights[tileZ][tileExX][tileExY];
		int seHeight = tileHeights[tileZ][tileExX + 1][tileExY];
		int neHeight = tileHeights[tileZ][tileExX + 1][tileExY + 1];
		int nwHeight = tileHeights[tileZ][tileExX][tileExY + 1];
		int textureId = paint.getTexture();

		// 0,0
		final int lx0 = lx;
		final int lz0 = lz;

		// 1,0
		final int lx1 = lx + LOCAL_TILE_SIZE;
		final int lz1 = lz;

		// 1,1
		final int lx2 = lx + LOCAL_TILE_SIZE;
		final int lz2 = lz + LOCAL_TILE_SIZE;

		// 0,1
		final int lx3 = lx;
		final int lz3 = lz + LOCAL_TILE_SIZE;

		ProceduralGenerator.tileVertexKeys(ctx, tile, vertices, vertexKeys);
		int swVertexKey = vertexKeys[0];
		int seVertexKey = vertexKeys[1];
		int nwVertexKey = vertexKeys[2];
		int neVertexKey = vertexKeys[3];
		boolean neVertexIsOverlay = false;
		boolean nwVertexIsOverlay = false;
		boolean seVertexIsOverlay = false;
		boolean swVertexIsOverlay = false;

		int uvOrientation = 0;
		float uvScale = 1;

		Material swMaterial = Material.NONE;
		Material seMaterial = Material.NONE;
		Material neMaterial = Material.NONE;
		Material nwMaterial = Material.NONE;

		int[] swNormals = UP_NORMAL;
		int[] seNormals = UP_NORMAL;
		int[] neNormals = UP_NORMAL;
		int[] nwNormals = UP_NORMAL;

		int swTerrainData, seTerrainData, nwTerrainData, neTerrainData;
		swTerrainData = seTerrainData = nwTerrainData = neTerrainData = HDUtils.packTerrainData(true, 0, waterType, tileZ);

		if (!onlyWaterSurface) {
			swNormals = ctx.vertexTerrainNormals.getOrDefault(swVertexKey, swNormals);
			seNormals = ctx.vertexTerrainNormals.getOrDefault(seVertexKey, seNormals);
			neNormals = ctx.vertexTerrainNormals.getOrDefault(neVertexKey, neNormals);
			nwNormals = ctx.vertexTerrainNormals.getOrDefault(nwVertexKey, nwNormals);
		}

		if (waterType == WaterType.NONE) {
			if (textureId != -1) {
				var material = materialManager.fromVanillaTexture(textureId);
				// Disable tile overrides for newly introduced vanilla textures
				if (material.isFallbackVanillaMaterial)
					override = NONE;
				swMaterial = seMaterial = neMaterial = nwMaterial = material;
			}

			boolean useBlendedMaterialAndColor =
				plugin.configGroundBlending &&
				textureId == -1 &&
				!proceduralGenerator.useDefaultColor(tile, override);
			GroundMaterial groundMaterial = null;
			if (override != TileOverride.NONE) {
				groundMaterial = override.groundMaterial;
				uvOrientation = override.uvOrientation;
				uvScale = override.uvScale;
				if (!useBlendedMaterialAndColor) {
					swColor = override.modifyColor(swColor);
					seColor = override.modifyColor(seColor);
					nwColor = override.modifyColor(nwColor);
					neColor = override.modifyColor(neColor);
				}
				swHeight -= override.heightOffset;
				seHeight -= override.heightOffset;
				neHeight -= override.heightOffset;
				nwHeight -= override.heightOffset;
			} else if (textureId == -1) {
				// Fall back to the default ground material if the tile is untextured
				groundMaterial = override.groundMaterial;
			}

			if (useBlendedMaterialAndColor) {
				// get the vertices' colors and textures from hashmaps
				swColor = ctx.vertexTerrainColor.getOrDefault(swVertexKey, swColor);
				seColor = ctx.vertexTerrainColor.getOrDefault(seVertexKey, seColor);
				neColor = ctx.vertexTerrainColor.getOrDefault(neVertexKey, neColor);
				nwColor = ctx.vertexTerrainColor.getOrDefault(nwVertexKey, nwColor);

				if (plugin.configGroundTextures) {
					swMaterial = ctx.vertexTerrainTexture.getOrDefault(swVertexKey, swMaterial);
					seMaterial = ctx.vertexTerrainTexture.getOrDefault(seVertexKey, seMaterial);
					neMaterial = ctx.vertexTerrainTexture.getOrDefault(neVertexKey, neMaterial);
					nwMaterial = ctx.vertexTerrainTexture.getOrDefault(nwVertexKey, nwMaterial);
				}
			} else if (plugin.configGroundTextures && groundMaterial != null) {
				swMaterial = groundMaterial.getRandomMaterial(worldPos[0], worldPos[1], worldPos[2]);
				seMaterial = groundMaterial.getRandomMaterial(worldPos[0] + 1, worldPos[1], worldPos[2]);
				nwMaterial = groundMaterial.getRandomMaterial(worldPos[0], worldPos[1] + 1, worldPos[2]);
				neMaterial = groundMaterial.getRandomMaterial(worldPos[0] + 1, worldPos[1] + 1, worldPos[2]);
			}

			if (ctx.vertexIsOverlay.containsKey(neVertexKey) && ctx.vertexIsUnderlay.containsKey(neVertexKey))
				neVertexIsOverlay = true;
			if (ctx.vertexIsOverlay.containsKey(nwVertexKey) && ctx.vertexIsUnderlay.containsKey(nwVertexKey))
				nwVertexIsOverlay = true;
			if (ctx.vertexIsOverlay.containsKey(seVertexKey) && ctx.vertexIsUnderlay.containsKey(seVertexKey))
				seVertexIsOverlay = true;
			if (ctx.vertexIsOverlay.containsKey(swVertexKey) && ctx.vertexIsUnderlay.containsKey(swVertexKey))
				swVertexIsOverlay = true;
		} else if (onlyWaterSurface) {
			// set colors for the shoreline to create a foam effect in the water shader
			swColor = seColor = nwColor = neColor = 127;

			if (ctx.vertexIsWater.containsKey(swVertexKey) && ctx.vertexIsLand.containsKey(swVertexKey))
				swColor = 0;
			if (ctx.vertexIsWater.containsKey(seVertexKey) && ctx.vertexIsLand.containsKey(seVertexKey))
				seColor = 0;
			if (ctx.vertexIsWater.containsKey(nwVertexKey) && ctx.vertexIsLand.containsKey(nwVertexKey))
				nwColor = 0;
			if (ctx.vertexIsWater.containsKey(neVertexKey) && ctx.vertexIsLand.containsKey(neVertexKey))
				neColor = 0;

			if (seColor == 0 && nwColor == 0 && (neColor == 0 || swColor == 0))
				swColor = seColor = nwColor = neColor = 1 << 16; // Bias depth a bit if it's flush with underwater geometry
		} else {
			// Underwater geometry
			swColor = seColor = neColor = nwColor = UNDERWATER_HSL;

			if (plugin.configGroundTextures) {
				GroundMaterial groundMaterial = GroundMaterial.UNDERWATER_GENERIC;
				swMaterial = groundMaterial.getRandomMaterial(worldPos[0], worldPos[1], worldPos[2]);
				seMaterial = groundMaterial.getRandomMaterial(worldPos[0] + 1, worldPos[1], worldPos[2]);
				nwMaterial = groundMaterial.getRandomMaterial(worldPos[0], worldPos[1] + 1, worldPos[2]);
				neMaterial = groundMaterial.getRandomMaterial(worldPos[0] + 1, worldPos[1] + 1, worldPos[2]);
			}

			int swDepth = ctx.vertexUnderwaterDepth.getOrDefault(swVertexKey, 0);
			int seDepth = ctx.vertexUnderwaterDepth.getOrDefault(seVertexKey, 0);
			int nwDepth = ctx.vertexUnderwaterDepth.getOrDefault(nwVertexKey, 0);
			int neDepth = ctx.vertexUnderwaterDepth.getOrDefault(neVertexKey, 0);
			swHeight += swDepth;
			seHeight += seDepth;
			nwHeight += nwDepth;
			neHeight += neDepth;

			swTerrainData = HDUtils.packTerrainData(true, max(1, swDepth), waterType, tileZ);
			seTerrainData = HDUtils.packTerrainData(true, max(1, seDepth), waterType, tileZ);
			nwTerrainData = HDUtils.packTerrainData(true, max(1, nwDepth), waterType, tileZ);
			neTerrainData = HDUtils.packTerrainData(true, max(1, neDepth), waterType, tileZ);
		}

		int swMaterialData = swMaterial.packMaterialData(ModelOverride.NONE, UvType.GEOMETRY, swVertexIsOverlay, true);
		int seMaterialData = seMaterial.packMaterialData(ModelOverride.NONE, UvType.GEOMETRY, seVertexIsOverlay, true);
		int nwMaterialData = nwMaterial.packMaterialData(ModelOverride.NONE, UvType.GEOMETRY, nwVertexIsOverlay, true);
		int neMaterialData = neMaterial.packMaterialData(ModelOverride.NONE, UvType.GEOMETRY, neVertexIsOverlay, true);

		float uvcos = -uvScale, uvsin = 0;
		if (uvOrientation % 2048 != 0) {
			float rad = -uvOrientation * JAU_TO_RAD;
			uvcos = cos(rad) * -uvScale;
			uvsin = sin(rad) * -uvScale;
		}
		float uvx = worldPos[0];
		float uvy = worldPos[1];
		float tmp = uvx;
		uvx = fract(uvx * uvcos - uvy * uvsin);
		uvy = fract(tmp * uvsin + uvy * uvcos);

		vb.putVertex(
			lx2, neHeight, lz2, neColor,
			uvx, uvy, 0, neMaterialData,
			neNormals[0], neNormals[2], neNormals[1], neTerrainData
		);

		vb.putVertex(
			lx3, nwHeight, lz3, nwColor,
			uvx - uvcos, uvy - uvsin, 0, nwMaterialData,
			nwNormals[0], nwNormals[2], nwNormals[1], nwTerrainData
		);

		vb.putVertex(
			lx1, seHeight, lz1, seColor,
			uvx + uvsin, uvy - uvcos, 0, seMaterialData,
			seNormals[0], seNormals[2], seNormals[1], seTerrainData
		);

		vb.putVertex(
			lx0, swHeight, lz0, swColor,
			uvx - uvcos + uvsin, uvy - uvsin - uvcos, 0, swMaterialData,
			swNormals[0], swNormals[2], swNormals[1], swTerrainData
		);

		vb.putVertex(
			lx1, seHeight, lz1, seColor,
			uvx + uvsin, uvy - uvcos, 0, seMaterialData,
			seNormals[0], seNormals[2], seNormals[1], seTerrainData
		);

		vb.putVertex(
			lx3, nwHeight, lz3, nwColor,
			uvx - uvcos, uvy - uvsin, 0, nwMaterialData,
			nwNormals[0], nwNormals[2], nwNormals[1], nwTerrainData
		);
	}

	private void uploadTileModel(
		ZoneSceneContext ctx,
		Tile tile,
		SceneTileModel model,
		boolean onlyWaterSurface,
		int tileExX, int tileExY, int tileZ,
		int basex, int basez,
		GpuIntBuffer vb
	) {
		final int[] triangleTextures = model.getTriangleTextureId();
		boolean isFallbackWater = false;
		if (triangleTextures != null) {
			for (int textureId : triangleTextures) {
				if (textureId != -1 && proceduralGenerator.seasonalWaterType(TileOverride.NONE, textureId) != WaterType.NONE) {
					isFallbackWater = true;
					break;
				}
			}
		}
		int overlayId = OVERLAY_FLAG | overlayIds[tileZ][tileExX][tileExY];
		int underlayId = underlayIds[tileZ][tileExX][tileExY];
		var overlayOverride = tileOverrideManager.getOverride(ctx, tile, worldPos, overlayId);
		var underlayOverride = tileOverrideManager.getOverride(ctx, tile, worldPos, underlayId);
		WaterType overlayWaterType = proceduralGenerator.seasonalWaterType(overlayOverride, 0);
		WaterType underlayWaterType = proceduralGenerator.seasonalWaterType(underlayOverride, 0);
		boolean isOverlayWater = overlayWaterType != WaterType.NONE;
		boolean isUnderlayWater = underlayWaterType != WaterType.NONE;
		if (onlyWaterSurface && !isFallbackWater && !isOverlayWater && !isUnderlayWater)
			return;

		final int[] faceX = model.getFaceX();
		final int[] faceY = model.getFaceY();
		final int[] faceZ = model.getFaceZ();

		final int[] vertexX = model.getVertexX();
		final int[] vertexY = model.getVertexY();
		final int[] vertexZ = model.getVertexZ();

		final int[] triangleColorA = model.getTriangleColorA();
		final int[] triangleColorB = model.getTriangleColorB();
		final int[] triangleColorC = model.getTriangleColorC();

		final int faceCount = faceX.length;

		var sceneLoc = tile.getSceneLocation();
		int tileX = sceneLoc.getX();
		int tileY = sceneLoc.getY();

		for (int face = 0; face < faceCount; ++face) {
			int colorA = triangleColorA[face];
			int colorB = triangleColorB[face];
			int colorC = triangleColorC[face];
			if (colorA == HIDDEN_HSL)
				continue;

			int textureId = triangleTextures == null ? -1 : triangleTextures[face];
			boolean isOverlay = ProceduralGenerator.isOverlayFace(tile, face);
			var override = isOverlay ? overlayOverride : underlayOverride;
			WaterType waterType = proceduralGenerator.seasonalWaterType(override, textureId);
			boolean isWater = waterType != WaterType.NONE;
			if (onlyWaterSurface && !isWater)
				continue;

			final int vertex0 = faceX[face];
			final int vertex1 = faceY[face];
			final int vertex2 = faceZ[face];

			// vertexes are stored in scene local, convert to tile local
			int lx0 = vertexX[vertex0] - basex;
			int ly0 = vertexY[vertex0];
			int lz0 = vertexZ[vertex0] - basez;

			int lx1 = vertexX[vertex1] - basex;
			int ly1 = vertexY[vertex1];
			int lz1 = vertexZ[vertex1] - basez;

			int lx2 = vertexX[vertex2] - basex;
			int ly2 = vertexY[vertex2];
			int lz2 = vertexZ[vertex2] - basez;

			ProceduralGenerator.faceVertexKeys(tile, face, vertices, vertexKeys);
			ProceduralGenerator.faceLocalVertices(tile, face, vertices);

			int vertexKeyA = vertexKeys[0];
			int vertexKeyB = vertexKeys[1];
			int vertexKeyC = vertexKeys[2];

			boolean vertexAIsOverlay = false;
			boolean vertexBIsOverlay = false;
			boolean vertexCIsOverlay = false;

			Material materialA = Material.NONE;
			Material materialB = Material.NONE;
			Material materialC = Material.NONE;

			int uvOrientation = 0;
			float uvScale = 1;

			int[] normalsA = UP_NORMAL;
			int[] normalsB = UP_NORMAL;
			int[] normalsC = UP_NORMAL;

			int terrainDataA, terrainDataB, terrainDataC;
			terrainDataA = terrainDataB = terrainDataC = HDUtils.packTerrainData(true, 0, waterType, tileZ);

			if (!onlyWaterSurface) {
				normalsA = ctx.vertexTerrainNormals.getOrDefault(vertexKeyA, normalsA);
				normalsB = ctx.vertexTerrainNormals.getOrDefault(vertexKeyB, normalsB);
				normalsC = ctx.vertexTerrainNormals.getOrDefault(vertexKeyC, normalsC);
			}

			if (!isWater) {
				if (textureId != -1) {
					var material = materialManager.fromVanillaTexture(textureId);
					// Disable tile overrides for newly introduced vanilla textures
					if (material.isFallbackVanillaMaterial)
						override = NONE;
					materialA = materialB = materialC = material;
				}

				GroundMaterial groundMaterial = null;

				boolean useBlendedMaterialAndColor =
					plugin.configGroundBlending &&
					textureId == -1 &&
					!(isOverlay && proceduralGenerator.useDefaultColor(tile, override));
				if (override != TileOverride.NONE) {
					groundMaterial = override.groundMaterial;
					uvOrientation = override.uvOrientation;
					uvScale = override.uvScale;
					if (!useBlendedMaterialAndColor) {
						colorA = override.modifyColor(colorA);
						colorB = override.modifyColor(colorB);
						colorC = override.modifyColor(colorC);
					}
				} else if (textureId == -1) {
					// Fall back to the default ground material if the tile is untextured
					groundMaterial = override.groundMaterial;
				}

				if (useBlendedMaterialAndColor) {
					// get the vertices' colors and textures from hashmaps
					colorA = ctx.vertexTerrainColor.getOrDefault(vertexKeyA, colorA);
					colorB = ctx.vertexTerrainColor.getOrDefault(vertexKeyB, colorB);
					colorC = ctx.vertexTerrainColor.getOrDefault(vertexKeyC, colorC);

					if (plugin.configGroundTextures) {
						materialA = ctx.vertexTerrainTexture.getOrDefault(vertexKeyA, materialA);
						materialB = ctx.vertexTerrainTexture.getOrDefault(vertexKeyB, materialB);
						materialC = ctx.vertexTerrainTexture.getOrDefault(vertexKeyC, materialC);
					}
				} else if (plugin.configGroundTextures && groundMaterial != null) {
					materialA = groundMaterial.getRandomMaterial(
						worldPos[0] + (vertices[0][0] >> LOCAL_COORD_BITS),
						worldPos[1] + (vertices[0][1] >> LOCAL_COORD_BITS),
						worldPos[2]
					);
					materialB = groundMaterial.getRandomMaterial(
						worldPos[0] + (vertices[1][0] >> LOCAL_COORD_BITS),
						worldPos[1] + (vertices[1][1] >> LOCAL_COORD_BITS),
						worldPos[2]
					);
					materialC = groundMaterial.getRandomMaterial(
						worldPos[0] + (vertices[2][0] >> LOCAL_COORD_BITS),
						worldPos[1] + (vertices[2][1] >> LOCAL_COORD_BITS),
						worldPos[2]
					);
				}
			} else if (onlyWaterSurface) {
				// set colors for the shoreline to create a foam effect in the water shader
				colorA = colorB = colorC = 127;
				if (ctx.vertexIsWater.containsKey(vertexKeyA) && ctx.vertexIsLand.containsKey(vertexKeyA))
					colorA = 0;
				if (ctx.vertexIsWater.containsKey(vertexKeyB) && ctx.vertexIsLand.containsKey(vertexKeyB))
					colorB = 0;
				if (ctx.vertexIsWater.containsKey(vertexKeyC) && ctx.vertexIsLand.containsKey(vertexKeyC))
					colorC = 0;
				if (colorA == 0 && colorB == 0 && colorC == 0)
					colorA = colorB = colorC = 1 << 16; // Bias depth a bit if it's flush with underwater geometry
			} else {
				// Underwater geometry
				colorA = colorB = colorC = UNDERWATER_HSL;

				if (plugin.configGroundTextures) {
					GroundMaterial groundMaterial = GroundMaterial.UNDERWATER_GENERIC;
					materialA = groundMaterial.getRandomMaterial(
						worldPos[0] + (vertices[0][0] >> LOCAL_COORD_BITS),
						worldPos[1] + (vertices[0][1] >> LOCAL_COORD_BITS),
						worldPos[2]
					);
					materialB = groundMaterial.getRandomMaterial(
						worldPos[0] + (vertices[1][0] >> LOCAL_COORD_BITS),
						worldPos[1] + (vertices[1][1] >> LOCAL_COORD_BITS),
						worldPos[2]
					);
					materialC = groundMaterial.getRandomMaterial(
						worldPos[0] + (vertices[2][0] >> LOCAL_COORD_BITS),
						worldPos[1] + (vertices[2][1] >> LOCAL_COORD_BITS),
						worldPos[2]
					);
				}

				int depthA = ctx.vertexUnderwaterDepth.getOrDefault(vertexKeyA, 0);
				int depthB = ctx.vertexUnderwaterDepth.getOrDefault(vertexKeyB, 0);
				int depthC = ctx.vertexUnderwaterDepth.getOrDefault(vertexKeyC, 0);
				ly0 += depthA;
				ly1 += depthB;
				ly2 += depthC;

				terrainDataA = HDUtils.packTerrainData(true, max(1, depthA), waterType, tileZ);
				terrainDataB = HDUtils.packTerrainData(true, max(1, depthB), waterType, tileZ);
				terrainDataC = HDUtils.packTerrainData(true, max(1, depthC), waterType, tileZ);
			}

			if (ctx.vertexIsOverlay.containsKey(vertexKeyA) && ctx.vertexIsUnderlay.containsKey(vertexKeyA))
				vertexAIsOverlay = true;
			if (ctx.vertexIsOverlay.containsKey(vertexKeyB) && ctx.vertexIsUnderlay.containsKey(vertexKeyB))
				vertexBIsOverlay = true;
			if (ctx.vertexIsOverlay.containsKey(vertexKeyC) && ctx.vertexIsUnderlay.containsKey(vertexKeyC))
				vertexCIsOverlay = true;

			ly0 -= override.heightOffset;
			ly1 -= override.heightOffset;
			ly2 -= override.heightOffset;

			int materialDataA = materialA.packMaterialData(ModelOverride.NONE, UvType.GEOMETRY, vertexAIsOverlay, true);
			int materialDataB = materialB.packMaterialData(ModelOverride.NONE, UvType.GEOMETRY, vertexBIsOverlay, true);
			int materialDataC = materialC.packMaterialData(ModelOverride.NONE, UvType.GEOMETRY, vertexCIsOverlay, true);

			float uvcos = -uvScale, uvsin = 0;
			if (uvOrientation % 2048 != 0) {
				float rad = -uvOrientation * JAU_TO_RAD;
				uvcos = cos(rad) * -uvScale;
				uvsin = sin(rad) * -uvScale;
			}

			float uvx = fract(worldPos[0] * uvcos - worldPos[1] * uvsin);
			float uvy = fract(worldPos[0] * uvsin + worldPos[1] * uvcos);

			float dx, dz;
			dx = (float) lx0 / LOCAL_TILE_SIZE - tileX;
			dz = (float) lz0 / LOCAL_TILE_SIZE - tileY;
			float uvAx = uvx + dx * uvcos - dz * uvsin;
			float uvAy = uvy + dx * uvsin + dz * uvcos;
			dx = (float) lx1 / LOCAL_TILE_SIZE - tileX;
			dz = (float) lz1 / LOCAL_TILE_SIZE - tileY;
			float uvBx = uvx + dx * uvcos - dz * uvsin;
			float uvBy = uvy + dx * uvsin + dz * uvcos;
			dx = (float) lx2 / LOCAL_TILE_SIZE - tileX;
			dz = (float) lz2 / LOCAL_TILE_SIZE - tileY;
			float uvCx = uvx + dx * uvcos - dz * uvsin;
			float uvCy = uvy + dx * uvsin + dz * uvcos;

			vb.putVertex(
				lx0, ly0, lz0, colorA,
				uvAx, uvAy, 0, materialDataA,
				normalsA[0], normalsA[2], normalsA[1], terrainDataA
			);

			vb.putVertex(
				lx1, ly1, lz1, colorB,
				uvBx, uvBy, 0, materialDataB,
				normalsB[0], normalsB[2], normalsB[1], terrainDataB
			);

			vb.putVertex(
				lx2, ly2, lz2, colorC,
				uvCx, uvCy, 0, materialDataC,
				normalsC[0], normalsC[2], normalsC[1], terrainDataC
			);
		}
	}

	// scene upload
	private int uploadStaticModel(
		ZoneSceneContext ctx,
		Tile tile,
		Model model,
		ModelOverride modelOverride,
		int uuid,
		int preOrientation, int orientation,
		int x, int y, int z,
		GpuIntBuffer opaqueBuffer,
		GpuIntBuffer alphaBuffer
	) {
		final int[][][] tileHeights = ctx.scene.getTileHeights();
		final int faceCount = model.getFaceCount();
		final int vertexCount = model.getVerticesCount();

		final float[] vertexX = model.getVerticesX();
		final float[] vertexY = model.getVerticesY();
		final float[] vertexZ = model.getVerticesZ();

		final int[] indices1 = model.getFaceIndices1();
		final int[] indices2 = model.getFaceIndices2();
		final int[] indices3 = model.getFaceIndices3();

		final short[] unlitFaceColors = plugin.configUnlitFaceColors ? model.getUnlitFaceColors() : null;
		final int[] color1s = model.getFaceColors1();
		final int[] color2s = model.getFaceColors2();
		final int[] color3s = model.getFaceColors3();

		final int[] xVertexNormals = model.getVertexNormalsX();
		final int[] yVertexNormals = model.getVertexNormalsY();
		final int[] zVertexNormals = model.getVertexNormalsZ();
		final boolean modelHasNormals = xVertexNormals != null && yVertexNormals != null && zVertexNormals != null;

		final short[] faceTextures = model.getFaceTextures();
		final byte[] textureFaces = model.getTextureFaces();
		final int[] texIndices1 = model.getTexIndices1();
		final int[] texIndices2 = model.getTexIndices2();
		final int[] texIndices3 = model.getTexIndices3();

		final byte[] bias = model.getFaceBias();
		final byte[] transparencies = model.getFaceTransparencies();
		final float modelHeight = model.getModelHeight();

		int orientSin = 0;
		int orientCos = 0;
		if (orientation != 0) {
			orientation = mod(orientation, 2048);
			orientSin = SINE[orientation];
			orientCos = COSINE[orientation];
		}

		for (int v = 0; v < vertexCount; ++v) {
			int vx = (int) vertexX[v];
			int vy = (int) vertexY[v];
			int vz = (int) vertexZ[v];
			float heightFrac = modelOverride.terrainVertexSnap ? abs(vy / modelHeight) : 0.0f;

			if (orientation != 0) {
				int x0 = vx;
				vx = vz * orientSin + x0 * orientCos >> 16;
				vz = vz * orientCos - x0 * orientSin >> 16;
			}

			vx += x;
			vy += y;
			vz += z;

			if (modelOverride.terrainVertexSnap && heightFrac <= modelOverride.terrainVertexSnapThreshold) {
				int plane = tile.getRenderLevel();
				int tileExX = clamp(ctx.sceneOffset + ((vx + basex) / 128), 0, EXTENDED_SCENE_SIZE - 1);
				int tileExY = clamp(ctx.sceneOffset + ((vz + basez) / 128), 0, EXTENDED_SCENE_SIZE - 1);

				float h00 = tileHeights[plane][tileExX][tileExY];
				float h10 = tileHeights[plane][tileExX + 1][tileExY];
				float h01 = tileHeights[plane][tileExX][tileExY + 1];
				float h11 = tileHeights[plane][tileExX + 1][tileExY + 1];

				float hx0 = mix(h00, h10, (vx % 128.0f) / 128.0f);
				float hx1 = mix(h01, h11, (vx % 128.0f) / 128.0f);
				float h = mix(hx0, hx1, (vz % 128.0f) / 128.0f);

				float blend = divide(heightFrac, modelOverride.terrainVertexSnapThreshold);
				vy = (int) mix(h, vy, blend);
			}

			modelLocalXI[v] = vx;
			modelLocalYI[v] = vy;
			modelLocalZI[v] = vz;
		}

		boolean isVanillaTextured = faceTextures != null;
		boolean isVanillaUVMapped =
			isVanillaTextured && // Vanilla UV mapped models don't always have sensible UVs for untextured faces
			model.getTextureFaces() != null;

		final Material baseMaterial = modelOverride.baseMaterial;
		final Material textureMaterial = modelOverride.textureMaterial;

		int len = 0;
		for (int face = 0; face < faceCount; ++face) {
			int color1 = color1s[face];
			int color2 = color2s[face];
			int color3 = color3s[face];

			if (color3 == -1) {
				color2 = color3 = color1;
			} else if (color3 == -2) {
				continue;
			}

			if (unlitFaceColors != null)
				color1 = color2 = color3 = unlitFaceColors[face] & 0xFFFF;

			int triangleA = indices1[face];
			int triangleB = indices2[face];
			int triangleC = indices3[face];

			int vx1 = modelLocalXI[triangleA];
			int vy1 = modelLocalYI[triangleA];
			int vz1 = modelLocalZI[triangleA];

			int vx2 = modelLocalXI[triangleB];
			int vy2 = modelLocalYI[triangleB];
			int vz2 = modelLocalZI[triangleB];

			int vx3 = modelLocalXI[triangleC];
			int vy3 = modelLocalYI[triangleC];
			int vz3 = modelLocalZI[triangleC];

			int texA, texB, texC;

			if (isVanillaUVMapped && textureFaces[face] != -1) {
				int tface = textureFaces[face] & 0xff;
				texA = texIndices1[tface];
				texB = texIndices2[tface];
				texC = texIndices3[tface];
			} else {
				texA = triangleA;
				texB = triangleB;
				texC = triangleC;
			}

			int transparency = transparencies != null ? transparencies[face] & 0xFF : 0;
			int textureId = isVanillaTextured ? faceTextures[face] : -1;
			boolean isTextured = textureId != -1;
			boolean keepShading = isTextured;
			if (isTextured) {
				// Without overriding the color for textured faces, vanilla shading remains pretty noticeable even after
				// the approximate reversal above. Ardougne rooftops is a good example, where vanilla shading results in a
				// weird-looking tint. The brightness clamp afterward is required to reduce the over-exposure introduced.
				color1 = color2 = color3 = 90;
			} else {
				// Hide fake shadows or lighting that is often baked into models by making the fake shadow transparent
				if (plugin.configHideFakeShadows && modelOverride.hideVanillaShadows && HDUtils.isBakedGroundShading(model, face))
					continue;

				if (modelOverride.inheritTileColorType != InheritTileColorType.NONE) {
					final Scene scene = ctx.scene;
					SceneTileModel tileModel = tile.getSceneTileModel();
					SceneTilePaint tilePaint = tile.getSceneTilePaint();

					if (tilePaint != null || tileModel != null) {
						// No point in inheriting tilepaint color if the ground tile does not have a color, for example above a cave wall
						if (
							tilePaint != null &&
							tilePaint.getTexture() == -1 &&
							tilePaint.getRBG() != 0 &&
							tilePaint.getNeColor() != HIDDEN_HSL
						) {
							// Since tile colors are guaranteed to have the same hue and saturation per face,
							// we can blend without converting from HSL to RGB
							int averageColor =
								(tilePaint.getSwColor() + tilePaint.getNwColor() + tilePaint.getNeColor() + tilePaint.getSeColor()) / 4;

							var override = tileOverrideManager.getOverride(ctx, tile);
							averageColor = override.modifyColor(averageColor);
							color1 = color2 = color3 = averageColor;

							// Let the shader know vanilla shading reversal should be skipped for this face
							keepShading = true;
						} else if (tileModel != null && tileModel.getTriangleTextureId() == null) {
							int faceColorIndex = -1;
							for (int i = 0; i < tileModel.getTriangleColorA().length; i++) {
								boolean isOverlay = ProceduralGenerator.isOverlayFace(tile, i);
								// Use underlay if the tile does not have an overlay, useful for rocks in cave corners.
								if (modelOverride.inheritTileColorType == InheritTileColorType.UNDERLAY
									|| tileModel.getModelOverlay() == 0) {
									// pulling the color from UNDERLAY is more desirable for green grass tiles
									// OVERLAY pulls in path color which is not desirable for grass next to paths
									if (!isOverlay) {
										faceColorIndex = i;
										break;
									}
								} else if (modelOverride.inheritTileColorType == InheritTileColorType.OVERLAY) {
									if (isOverlay) {
										// OVERLAY used in dirt/path/house tile color blend better with rubbles/rocks
										faceColorIndex = i;
										break;
									}
								}
							}

							if (faceColorIndex != -1) {
								int color = tileModel.getTriangleColorA()[faceColorIndex];
								if (color != HIDDEN_HSL) {
									var scenePos = tile.getSceneLocation();
									int tileX = scenePos.getX();
									int tileY = scenePos.getY();
									int tileZ = tile.getRenderLevel();
									int tileExX = tileX + ctx.sceneOffset;
									int tileExY = tileY + ctx.sceneOffset;
									int tileId = modelOverride.inheritTileColorType == InheritTileColorType.OVERLAY ?
										OVERLAY_FLAG | scene.getOverlayIds()[tileZ][tileExX][tileExY] :
										scene.getUnderlayIds()[tileZ][tileExX][tileExY];
									var override = tileOverrideManager.getOverride(ctx, tile, worldPos, tileId);
									color = override.modifyColor(color);
									color1 = color2 = color3 = color;

									// Let the shader know vanilla shading reversal should be skipped for this face
									keepShading = true;
								}
							}
						}
					}
				}

				if (plugin.configLegacyTzHaarReskin && modelOverride.tzHaarRecolorType != TzHaarRecolorType.NONE) {
					int[] tzHaarRecolored = ProceduralGenerator.recolorTzHaar(
						uuid,
						modelOverride,
						model,
						face,
						color1,
						color2,
						color3
					);
					color1 = tzHaarRecolored[0];
					color2 = tzHaarRecolored[1];
					color3 = tzHaarRecolored[2];
					transparency |= tzHaarRecolored[3];
				}
			}

			UvType uvType = UvType.GEOMETRY;
			Material material = baseMaterial;
			ModelOverride faceOverride = modelOverride;

			if (isTextured) {
				uvType = UvType.VANILLA;
				if (textureMaterial != Material.NONE) {
					material = textureMaterial;
				} else {
					material = materialManager.fromVanillaTexture(textureId);
					if (modelOverride.materialOverrides != null) {
						var override = modelOverride.materialOverrides.get(material);
						if (override != null) {
							faceOverride = override;
							material = faceOverride.textureMaterial;
						}
					}
				}
			} else if (modelOverride.colorOverrides != null) {
				int ahsl = (0xFF - transparency) << 16 | color1;
				for (var override : modelOverride.colorOverrides) {
					if (override.ahslCondition.test(ahsl)) {
						faceOverride = override;
						material = faceOverride.baseMaterial;
						break;
					}
				}
			}

			if (material != Material.NONE) {
				uvType = faceOverride.uvType;
				if (uvType == UvType.VANILLA || (textureId != -1 && faceOverride.retainVanillaUvs))
					uvType = isVanillaUVMapped && textureFaces[face] != -1 ? UvType.VANILLA : UvType.GEOMETRY;
			}

			int materialData = material.packMaterialData(faceOverride, uvType, false, keepShading);

			if (uvType == UvType.VANILLA) {
				modelUvs[0] = modelLocalXI[texA] - vx1;
				modelUvs[1] = modelLocalYI[texA] - vy1;
				modelUvs[2] = modelLocalZI[texA] - vz1;
				modelUvs[4] = modelLocalXI[texB] - vx2;
				modelUvs[5] = modelLocalYI[texB] - vy2;
				modelUvs[6] = modelLocalZI[texB] - vz2;
				modelUvs[8] = modelLocalXI[texC] - vx3;
				modelUvs[9] = modelLocalYI[texC] - vy3;
				modelUvs[10] = modelLocalZI[texC] - vz3;
			} else {
				faceOverride.fillUvsForFace(modelUvs, model, preOrientation, uvType, face, workingSpace);
			}

			final int[] faceNormals;
			if (modelHasNormals) {
				if (faceOverride.flatNormals || (!plugin.configPreserveVanillaNormals && color3s[face] == -1)) {
					faceNormals = EMPTY_NORMALS;
				} else {
					faceNormals = modelNormals;
					faceNormals[0] = xVertexNormals[triangleA];
					faceNormals[1] = yVertexNormals[triangleA];
					faceNormals[2] = zVertexNormals[triangleA];
					faceNormals[3] = xVertexNormals[triangleB];
					faceNormals[4] = yVertexNormals[triangleB];
					faceNormals[5] = zVertexNormals[triangleB];
					faceNormals[6] = xVertexNormals[triangleC];
					faceNormals[7] = yVertexNormals[triangleC];
					faceNormals[8] = zVertexNormals[triangleC];
				}
			} else {
				faceNormals = EMPTY_NORMALS;
			}

			int depthBias = faceOverride.depthBias != -1 ? faceOverride.depthBias :
				bias == null ? 0 : bias[face] & 0xFF;
			int packedAlphaBiasHsl = transparency << 24 | depthBias << 16;
			boolean hasAlpha = material.hasTransparency || transparency != 0;
			GpuIntBuffer vb = hasAlpha ? alphaBuffer : opaqueBuffer;
			vb.putVertex(
				vx1, vy1, vz1, packedAlphaBiasHsl | color1,
				modelUvs[0], modelUvs[1], modelUvs[2], materialData,
				faceNormals[0], faceNormals[1], faceNormals[2], 0
			);

			vb.putVertex(
				vx2, vy2, vz2, packedAlphaBiasHsl | color2,
				modelUvs[4], modelUvs[5], modelUvs[6], materialData,
				faceNormals[3], faceNormals[4], faceNormals[5], 0
			);

			vb.putVertex(
				vx3, vy3, vz3, packedAlphaBiasHsl | color3,
				modelUvs[8], modelUvs[9], modelUvs[10], materialData,
				faceNormals[6], faceNormals[7], faceNormals[8], 0
			);

			len += 3;
		}

		return len;
	}

	// temp draw
	public int uploadTempModel(
		Model model,
		ModelOverride modelOverride,
		int preOrientation,
		int orientation,
		int x,
		int y,
		int z,
		IntBuffer opaqueBuffer,
		IntBuffer alphaBuffer
	) {
		final int triangleCount = model.getFaceCount();
		final int vertexCount = model.getVerticesCount();

		final float[] verticesX = model.getVerticesX();
		final float[] verticesY = model.getVerticesY();
		final float[] verticesZ = model.getVerticesZ();

		final int[] indices1 = model.getFaceIndices1();
		final int[] indices2 = model.getFaceIndices2();
		final int[] indices3 = model.getFaceIndices3();

		final short[] unlitFaceColors = plugin.configUnlitFaceColors ? model.getUnlitFaceColors() : null;
		final int[] color1s = model.getFaceColors1();
		final int[] color2s = model.getFaceColors2();
		final int[] color3s = model.getFaceColors3();

		final int[] xVertexNormals = model.getVertexNormalsX();
		final int[] yVertexNormals = model.getVertexNormalsY();
		final int[] zVertexNormals = model.getVertexNormalsZ();
		final boolean modelHasNormals = xVertexNormals != null && yVertexNormals != null && zVertexNormals != null;

		final short[] faceTextures = model.getFaceTextures();
		final byte[] textureFaces = model.getTextureFaces();
		final int[] texIndices1 = model.getTexIndices1();
		final int[] texIndices2 = model.getTexIndices2();
		final int[] texIndices3 = model.getTexIndices3();

		final byte[] bias = model.getFaceBias();
		final byte[] transparencies = model.getFaceTransparencies();

		final byte overrideAmount = model.getOverrideAmount();
		final byte overrideHue = model.getOverrideHue();
		final byte overrideSat = model.getOverrideSaturation();
		final byte overrideLum = model.getOverrideLuminance();

		float orientSine = 0;
		float orientCosine = 0;
		if (orientation != 0) {
			orientation = mod(orientation, 2048);
			orientSine = SINE[orientation] / 65536f;
			orientCosine = COSINE[orientation] / 65536f;
		}

		for (int v = 0; v < vertexCount; ++v) {
			float vertexX = verticesX[v];
			float vertexY = verticesY[v];
			float vertexZ = verticesZ[v];

			if (orientation != 0) {
				float x0 = vertexX;
				vertexX = vertexZ * orientSine + x0 * orientCosine;
				vertexZ = vertexZ * orientCosine - x0 * orientSine;
			}

			vertexX += x;
			vertexY += y;
			vertexZ += z;

			modelLocalX[v] = vertexX;
			modelLocalY[v] = vertexY;
			modelLocalZ[v] = vertexZ;
		}

		boolean isVanillaTextured = faceTextures != null;
		boolean isVanillaUVMapped =
			isVanillaTextured && // Vanilla UV mapped models don't always have sensible UVs for untextured faces
			model.getTextureFaces() != null;

		Material baseMaterial = modelOverride.baseMaterial;
		Material textureMaterial = modelOverride.textureMaterial;

		int len = 0;
		for (int face = 0; face < triangleCount; ++face) {
			int transparency = transparencies != null ? transparencies[face] & 0xFF : 0;
			if (transparency == 255)
				continue;

			int color1 = color1s[face];
			int color2 = color2s[face];
			int color3 = color3s[face];

			if (color3 == -1) {
				color2 = color3 = color1;
			} else if (color3 == -2) {
				continue;
			}

			// Hide fake shadows or lighting that is often baked into models by making the fake shadow transparent
			if (plugin.configHideFakeShadows && modelOverride.hideVanillaShadows && HDUtils.isBakedGroundShading(model, face))
				continue;

			if (unlitFaceColors != null)
				color1 = color2 = color3 = unlitFaceColors[face] & 0xFFFF;

			// HSL override is not applied to textured faces
			if (overrideAmount > 0 && (!isVanillaTextured || faceTextures[face] == -1)) {
				color1 = interpolateHSL(color1, overrideHue, overrideSat, overrideLum, overrideAmount);
				color2 = interpolateHSL(color2, overrideHue, overrideSat, overrideLum, overrideAmount);
				color3 = interpolateHSL(color3, overrideHue, overrideSat, overrideLum, overrideAmount);
			}

			int triangleA = indices1[face];
			int triangleB = indices2[face];
			int triangleC = indices3[face];

			float vx1 = modelLocalX[triangleA];
			float vy1 = modelLocalY[triangleA];
			float vz1 = modelLocalZ[triangleA];

			float vx2 = modelLocalX[triangleB];
			float vy2 = modelLocalY[triangleB];
			float vz2 = modelLocalZ[triangleB];

			float vx3 = modelLocalX[triangleC];
			float vy3 = modelLocalY[triangleC];
			float vz3 = modelLocalZ[triangleC];

			int texA, texB, texC;

			if (isVanillaUVMapped && textureFaces[face] != -1) {
				int tface = textureFaces[face] & 0xff;
				texA = texIndices1[tface];
				texB = texIndices2[tface];
				texC = texIndices3[tface];
			} else {
				texA = triangleA;
				texB = triangleB;
				texC = triangleC;
			}

			int textureId = isVanillaTextured ? faceTextures[face] : -1;

			UvType uvType = UvType.GEOMETRY;
			Material material = baseMaterial;
			ModelOverride faceOverride = modelOverride;

			if (textureId != -1) {
				color1 = color2 = color3 = 90;
				uvType = UvType.VANILLA;
				if (textureMaterial != Material.NONE) {
					material = textureMaterial;
				} else {
					material = materialManager.fromVanillaTexture(textureId);
					if (modelOverride.materialOverrides != null) {
						var override = modelOverride.materialOverrides.get(material);
						if (override != null) {
							faceOverride = override;
							material = faceOverride.textureMaterial;
						}
					}
				}
			} else if (modelOverride.colorOverrides != null) {
				int ahsl = (0xFF - transparency) << 16 | color1;
				for (var override : modelOverride.colorOverrides) {
					if (override.ahslCondition.test(ahsl)) {
						faceOverride = override;
						material = faceOverride.baseMaterial;
						break;
					}
				}
			}

			if (material != Material.NONE) {
				uvType = faceOverride.uvType;
				if (uvType == UvType.VANILLA || (textureId != -1 && faceOverride.retainVanillaUvs))
					uvType = isVanillaUVMapped && textureFaces[face] != -1 ? UvType.VANILLA : UvType.GEOMETRY;
			}

			int materialData = material.packMaterialData(faceOverride, uvType, false, textureId != -1);

			if (uvType == UvType.VANILLA) {
				modelUvs[0] = modelLocalX[texA] - vx1;
				modelUvs[1] = modelLocalY[texA] - vy1;
				modelUvs[2] = modelLocalZ[texA] - vz1;
				modelUvs[4] = modelLocalX[texB] - vx2;
				modelUvs[5] = modelLocalY[texB] - vy2;
				modelUvs[6] = modelLocalZ[texB] - vz2;
				modelUvs[8] = modelLocalX[texC] - vx3;
				modelUvs[9] = modelLocalY[texC] - vy3;
				modelUvs[10] = modelLocalZ[texC] - vz3;
			} else {
				faceOverride.fillUvsForFace(modelUvs, model, preOrientation, uvType, face, workingSpace);
			}

			final int[] faceNormals;
			if (modelHasNormals) {
				if (faceOverride.flatNormals || (!plugin.configPreserveVanillaNormals && color3s[face] == -1)) {
					faceNormals = EMPTY_NORMALS;
				} else {
					faceNormals = modelNormals;
					faceNormals[0] = xVertexNormals[triangleA];
					faceNormals[1] = yVertexNormals[triangleA];
					faceNormals[2] = zVertexNormals[triangleA];
					faceNormals[3] = xVertexNormals[triangleB];
					faceNormals[4] = yVertexNormals[triangleB];
					faceNormals[5] = zVertexNormals[triangleB];
					faceNormals[6] = xVertexNormals[triangleC];
					faceNormals[7] = yVertexNormals[triangleC];
					faceNormals[8] = zVertexNormals[triangleC];
				}
			} else {
				faceNormals = EMPTY_NORMALS;
			}

			int depthBias = faceOverride.depthBias != -1 ? faceOverride.depthBias :
				bias == null ? 0 : bias[face] & 0xFF;
			int packedAlphaBiasHsl = transparency << 24 | depthBias << 16;
			boolean hasAlpha = material.hasTransparency || transparency != 0;
			IntBuffer vb = hasAlpha ? alphaBuffer : opaqueBuffer;
			GpuIntBuffer.putFloatVertex(
				vb,
				vx1, vy1, vz1, packedAlphaBiasHsl | color1,
				modelUvs[0], modelUvs[1], modelUvs[2], materialData,
				faceNormals[0], faceNormals[1], faceNormals[2], 0
			);
			GpuIntBuffer.putFloatVertex(
				vb,
				vx2, vy2, vz2, packedAlphaBiasHsl | color2,
				modelUvs[4], modelUvs[5], modelUvs[6], materialData,
				faceNormals[3], faceNormals[4], faceNormals[5], 0
			);
			GpuIntBuffer.putFloatVertex(
				vb,
				vx3, vy3, vz3, packedAlphaBiasHsl | color3,
				modelUvs[8], modelUvs[9], modelUvs[10], materialData,
				faceNormals[6], faceNormals[7], faceNormals[8], 0
			);
			len += 3;
		}

		return len;
	}

	public static int interpolateHSL(int hsl, byte hue2, byte sat2, byte lum2, byte lerp) {
		int hue = hsl >> 10 & 63;
		int sat = hsl >> 7 & 7;
		int lum = hsl & 127;
		int lerpInt = lerp & 255;
		if (hue2 != -1)
			hue += lerpInt * (hue2 - hue) >> 7;
		if (sat2 != -1)
			sat += lerpInt * (sat2 - sat) >> 7;
		if (lum2 != -1)
			lum += lerpInt * (lum2 - lum) >> 7;
		return (hue << 10 | sat << 7 | lum) & 65535;
	}
}

package rs117.hd.renderer.zone;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import javax.annotation.Nullable;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.*;
import rs117.hd.utils.CommandBuffer;

import static org.lwjgl.opengl.GL33C.*;
import static rs117.hd.HdPlugin.GL_CAPS;
import static rs117.hd.HdPlugin.SUPPORTS_INDIRECT_DRAW;

class VAO {
	// Zone vertex format
	// pos float vec3(x, y, z)
	// uvw short vec3(u, v, w)
	// normal short vec3(nx, ny, nz)
	// alphaBiasHsl int
	// materialData int
	// terrainData int
	static final int VERT_SIZE = 36;

	// Metadata format
	// worldViewIndex int int
	static final int METADATA_SIZE = 4;

	final VBO vbo;
	int vao;
	int vboMetadata;

	VAO(int size) {
		vbo = new VBO(size);
	}

	void initialize(int ebo, @Nullable VBO vboMetadata) {
		vao = glGenVertexArrays();
		glBindVertexArray(vao);

		// The element buffer is part of VAO state
		glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, ebo);

		vbo.initialize(GL_DYNAMIC_DRAW);
		glBindBuffer(GL_ARRAY_BUFFER, vbo.bufId);

		// Position
		glEnableVertexAttribArray(0);
		glVertexAttribPointer(0, 3, GL_FLOAT, false, VERT_SIZE, 0);

		// UVs
		glEnableVertexAttribArray(1);
		glVertexAttribPointer(1, 3, GL_HALF_FLOAT, false, VERT_SIZE, 12);

		// Normals
		glEnableVertexAttribArray(2);
		glVertexAttribPointer(2, 3, GL_SHORT, false, VERT_SIZE, 18);

		// Alpha, bias & HSL
		glEnableVertexAttribArray(3);
		glVertexAttribIPointer(3, 1, GL_INT, VERT_SIZE, 24);

		// Material data
		glEnableVertexAttribArray(4);
		glVertexAttribIPointer(4, 1, GL_INT, VERT_SIZE, 28);

		// Terrain data
		glEnableVertexAttribArray(5);
		glVertexAttribIPointer(5, 1, GL_INT, VERT_SIZE, 32);

		bindMetadata(vboMetadata);

		glBindBuffer(GL_ARRAY_BUFFER, 0);
		glBindVertexArray(0);
	}

	void bindMetadata(@Nullable VBO vboMetadata) {
		glBindVertexArray(vao);
		if (vboMetadata == null) {
			this.vboMetadata = 0;
			glDisableVertexAttribArray(6);
		} else {
			this.vboMetadata = vboMetadata.bufId;
			glBindBuffer(GL_ARRAY_BUFFER, vboMetadata.bufId);

			// WorldView index (not ID)
			glEnableVertexAttribArray(6);
			glVertexAttribDivisor(6, 1);
			glVertexAttribIPointer(6, 1, GL_INT, METADATA_SIZE, 0);
		}
	}

	void destroy() {
		vbo.destroy();
		glDeleteVertexArrays(vao);
		vao = 0;
	}

	int[] lengths = new int[4];
	Scene[] scenes = new Scene[4];
	int off = 0;

	void addRange(Scene scene) {
		assert vbo.mapped;

		if (off > 0 && lengths[off - 1] == vbo.vb.position()) {
			return;
		}

		if (lengths.length == off) {
			int l = lengths.length << 1;
			lengths = Arrays.copyOf(lengths, l);
			scenes = Arrays.copyOf(scenes, l);
		}

		lengths[off] = vbo.vb.position();
		scenes[off] = scene;
		off++;
	}

	void draw(CommandBuffer cmd) {
		assert !vbo.mapped;

		cmd.BindVertexArray(vao);

		int start = 0;
		for (int i = 0; i < off; ++i) {
			int end = lengths[i];
			int count = end - start;

			if (GL_CAPS.OpenGL40 && SUPPORTS_INDIRECT_DRAW) {
				cmd.DrawArraysIndirect(
					GL_TRIANGLES,
					start / (VERT_SIZE / 4),
					count / (VAO.VERT_SIZE / 4),
					ZoneRenderer.indirectDrawCmdsStaging
				);
			} else {
				cmd.DrawArrays(GL_TRIANGLES, start / (VERT_SIZE / 4), count / (VAO.VERT_SIZE / 4));
			}

			start = end;
		}
	}

	void reset() {
		Arrays.fill(scenes, 0, off, null);
		off = 0;
	}

	@Slf4j
	@RequiredArgsConstructor
	static class VAOList {
		// this needs to be larger than the largest single model
		private static final int VAO_SIZE = 4 * 1024 * 1024;

		private int curIdx;
		private int drawCount;
		private final List<VAO> vaos = new ArrayList<>();
		private final int eboAlpha;

		VAO get(int size, @Nullable VBO vboMetadata) {
			assert size <= VAO_SIZE;

			while (curIdx < vaos.size()) {
				VAO vao = vaos.get(curIdx);
				boolean wasMapped = vao.vbo.mapped;
				if (!wasMapped)
					vao.vbo.map();

				int rem = vao.vbo.vb.remaining() * Integer.BYTES;
				if (size <= rem) {
					if (vao.vboMetadata == (vboMetadata == null ? 0 : vboMetadata.bufId))
						return vao;

					if (!wasMapped) {
						vao.bindMetadata(vboMetadata);
						return vao;
					}
				}

				curIdx++;
			}

			VAO vao = new VAO(VAO_SIZE);
			vao.initialize(eboAlpha, vboMetadata);
			vao.vbo.map();
			vaos.add(vao);
			log.debug("Allocated VAO {} request {}", vao.vao, size);
			return vao;
		}

		void unmap() {
			int sz = 0;
			for (VAO vao : vaos) {
				if (vao.vbo.mapped) {
					++sz;
					vao.vbo.unmap();
				}
			}
			curIdx = 0;
			drawCount = sz;
		}

		void free() {
			for (VAO vao : vaos) {
				vao.destroy();
			}
			vaos.clear();
			curIdx = 0;
			drawCount = 0;
		}

		void addRange(Scene scene) {
			for (int i = 0; i <= curIdx && i < vaos.size(); ++i) {
				VAO vao = vaos.get(i);
				if (vao.vbo.mapped)
					vao.addRange(scene);
			}
		}

		void drawAll(CommandBuffer cmd) {
			for (int i = 0; i < drawCount; ++i)
				vaos.get(i).draw(cmd);
		}

		void resetAll() {
			for (int i = 0; i < drawCount; ++i)
				vaos.get(i).reset();
		}
	}
}

package rs117.hd.renderer.zone;

import java.nio.ByteBuffer;
import java.nio.IntBuffer;

import static org.lwjgl.opengl.GL33C.*;

public class VBO {
	final int size;
	int glUsage;
	int bufId;
	IntBuffer vb;
	int len;
	boolean mapped;

	private ByteBuffer mappedBuffer;

	public VBO(int size) {
		this.size = size;
	}

	public void initialize(int glUsage) {
		this.glUsage = glUsage;
		bufId = glGenBuffers();
		glBindBuffer(GL_ARRAY_BUFFER, bufId);
		glBufferData(GL_ARRAY_BUFFER, size, glUsage);
		glBindBuffer(GL_ARRAY_BUFFER, 0);
	}

	void destroy() {
		if (mapped) {
			glBindBuffer(GL_ARRAY_BUFFER, bufId);
			glUnmapBuffer(GL_ARRAY_BUFFER);
			glBindBuffer(GL_ARRAY_BUFFER, 0);
			mapped = false;
		}
		glDeleteBuffers(bufId);
		bufId = 0;
		mappedBuffer = null;
		vb = null;
	}

	public void map() {
		assert !mapped;
		glBindBuffer(GL_ARRAY_BUFFER, bufId);
		ByteBuffer buf;
		if (glUsage != GL_STATIC_DRAW) {
			buf = glMapBufferRange(
				GL_ARRAY_BUFFER,
				0,
				size,
				// TODO: GL_MAP_UNSYNCHRONIZED_BIT breaks alpha on AMD GPUs
				GL_MAP_WRITE_BIT | GL_MAP_FLUSH_EXPLICIT_BIT | GL_MAP_INVALIDATE_BUFFER_BIT,
				mappedBuffer
			);
		} else {
			buf = glMapBuffer(GL_ARRAY_BUFFER, GL_WRITE_ONLY, mappedBuffer);
		}
		if (buf == null)
			throw new RuntimeException("unable to map GL buffer " + bufId + " size " + size);
		if (buf != mappedBuffer) {
			mappedBuffer = buf;
			vb = mappedBuffer.asIntBuffer();
		}
		vb.position(0);
		glBindBuffer(GL_ARRAY_BUFFER, 0);
		mapped = true;
	}

	void unmap() {
		assert mapped;
		len = vb.position();

		glBindBuffer(GL_ARRAY_BUFFER, bufId);
		if (glUsage != GL_STATIC_DRAW)
			glFlushMappedBufferRange(GL_ARRAY_BUFFER, 0, (long) len * Integer.BYTES);
		glUnmapBuffer(GL_ARRAY_BUFFER);
		glBindBuffer(GL_ARRAY_BUFFER, 0);
		mapped = false;
	}
}

package rs117.hd.renderer.zone;

import java.util.Set;
import java.util.concurrent.LinkedBlockingDeque;
import javax.annotation.Nullable;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.*;
import rs117.hd.opengl.uniforms.UBOWorldViews;
import rs117.hd.opengl.uniforms.UBOWorldViews.WorldViewStruct;
import rs117.hd.utils.jobs.JobGroup;

import static org.lwjgl.opengl.GL33C.*;
import static rs117.hd.renderer.zone.SceneManager.NUM_ZONES;

@Slf4j
public class WorldViewContext {
	final int worldViewId;
	final int sizeX, sizeZ;
	@Nullable
	WorldViewStruct uboWorldViewStruct;
	SceneManager sceneManager;
	ZoneSceneContext sceneContext;
	Zone[][] zones;
	VBO vboM;
	boolean isLoading = true;

	int minLevel, level, maxLevel;
	Set<Integer> hideRoofIds;

	public long loadTime;
	public long uploadTime;
	public long sceneSwapTime;

	final LinkedBlockingDeque<Zone> pendingCull = new LinkedBlockingDeque<>();
	final JobGroup<ZoneUploadJob> sceneLoadGroup = new JobGroup<>(true, true);
	final JobGroup<ZoneUploadJob> streamingGroup = new JobGroup<>(false, false);
	final JobGroup<ZoneUploadJob> invalidationGroup = new JobGroup<>(true, false);

	WorldViewContext(
		SceneManager sceneManager,
		@Nullable WorldView worldView,
		@Nullable ZoneSceneContext sceneContext,
		UBOWorldViews uboWorldViews
	) {
		this.sceneManager = sceneManager;
		this.worldViewId = worldView == null ? -1 : worldView.getId();
		this.sceneContext = sceneContext;
		this.sizeX = worldView == null ? NUM_ZONES : worldView.getSizeX() >> 3;
		this.sizeZ = worldView == null ? NUM_ZONES : worldView.getSizeY() >> 3;
		if (worldView != null)
			uboWorldViewStruct = uboWorldViews.acquire(worldView);
		zones = new Zone[sizeX][sizeZ];
		for (int x = 0; x < sizeX; ++x)
			for (int z = 0; z < sizeZ; ++z)
				zones[x][z] = new Zone();
	}

	void initMetadata() {
		if (vboM != null || uboWorldViewStruct == null)
			return;

		vboM = new VBO(VAO.METADATA_SIZE);
		vboM.initialize(GL_STATIC_DRAW);
		vboM.map();
		vboM.vb.put(uboWorldViewStruct.worldViewIdx + 1);
		vboM.unmap();
	}

	void handleZoneSwap(float deltaTime, int zx, int zz) {
		Zone curZone = zones[zx][zz];
		ZoneUploadJob uploadTask = curZone.uploadJob;
		if (uploadTask == null)
			return;

		if (!uploadTask.isQueued()) {
			if (deltaTime > 0.0f && uploadTask.delay >= 0.0f) {
				uploadTask.delay -= deltaTime;
				if (uploadTask.delay <= 0.0f) {
					log.trace("queueing zone({}): [{}-{},{}]", uploadTask.zone.hashCode(), worldViewId, zx, zz);
					uploadTask.delay = -1.0f;
					uploadTask.queue(streamingGroup, sceneManager.getGenerateSceneDataTask());
				}
			}
			return;
		}

		if (uploadTask.isDone()) {
			curZone.uploadJob = null;
			if (uploadTask.ranToCompletion() && !uploadTask.wasCancelled()) {
				log.trace("swapping zone({}): [{}-{},{}]", uploadTask.zone.hashCode(), worldViewId, zx, zz);

				Zone PrevZone = curZone;
				// Swap the zone out with the one we just uploaded
				zones[zx][zz] = curZone = uploadTask.zone;

				if (PrevZone != curZone)
					pendingCull.add(PrevZone);
			} else if (uploadTask.wasCancelled() && !curZone.cull) {
				boolean shouldRetry = uploadTask.encounteredError() && curZone.isFirstLoadingAttempt;
				if (shouldRetry) {
					// Cache if the previous upload task encountered an error,
					// if it encounters another one the zone will be dropped to avoid constantly rebuilding
					curZone.rebuild = true;
					curZone.isFirstLoadingAttempt = false;
				} else if (uploadTask.encounteredError()) {
					log.debug(
						"Zone({}) [{}-{},{}] was cancelled due to an error, dropping to avoid constantly rebuilding",
						curZone.hashCode(),
						worldViewId,
						zx,
						zz
					);
				}
			}
			uploadTask.release();
		}
	}

	boolean update(float deltaTime) {
		if (isLoading)
			return false;

		Zone cullZone;
		while ((cullZone = pendingCull.poll()) != null) {
			log.trace("Culling zone({})", cullZone.hashCode());
			cullZone.free();
		}

		boolean queuedWork = false;
		for (int x = 0; x < sizeX; x++) {
			for (int z = 0; z < sizeZ; z++) {
				handleZoneSwap(deltaTime, x, z);

				if (zones[x][z].rebuild) {
					zones[x][z].rebuild = false;
					invalidateZone(x, z);
					queuedWork = true;
				}
			}
		}

		return queuedWork;
	}

	void completeInvalidation() {
		if (isLoading)
			return;

		invalidationGroup.complete();

		for (int x = 0; x < sizeX; x++)
			for (int z = 0; z < sizeZ; z++)
				handleZoneSwap(-1.0f, x, z);
	}

	void free() {
		sceneLoadGroup.cancel();
		streamingGroup.cancel();

		if (sceneContext != null)
			sceneContext.destroy();
		sceneContext = null;

		if (uboWorldViewStruct != null)
			uboWorldViewStruct.free();
		uboWorldViewStruct = null;

		for (int x = 0; x < sizeX; ++x)
			for (int z = 0; z < sizeZ; ++z)
				zones[x][z].free();

		Zone cullZone;
		while ((cullZone = pendingCull.poll()) != null)
			cullZone.free();

		if (vboM != null)
			vboM.destroy();
		vboM = null;

		isLoading = true;
	}

	void invalidate() {
		log.debug("invalidate all zones for worldViewId: [{}]", worldViewId);
		for (int x = 0; x < sizeX; ++x)
			for (int z = 0; z < sizeZ; ++z)
				invalidateZone(x, z);
	}

	void invalidateZone(int zx, int zz) {
		Zone curZone = zones[zx][zz];
		float prevUploadDelay = -1.0f;
		if (curZone.uploadJob != null) {
			log.trace(
				"Invalidate Zone({}) - Cancelled upload task: [{}-{},{}] task zone({})",
				curZone.hashCode(),
				worldViewId,
				zx,
				zz,
				curZone.uploadJob.zone.hashCode()
			);
			prevUploadDelay = curZone.uploadJob.delay;
			curZone.uploadJob.cancel();
			curZone.uploadJob.release();
		}

		Zone newZone = new Zone();
		newZone.dirty = zones[zx][zz].dirty;

		curZone.uploadJob = ZoneUploadJob.build(this, sceneContext, newZone, zx, zz);
		curZone.uploadJob.delay = prevUploadDelay;
		if (curZone.uploadJob.delay < 0.0f)
			curZone.uploadJob.queue(invalidationGroup, sceneManager.getGenerateSceneDataTask());
	}
}

package rs117.hd.renderer.zone;

import java.util.ArrayDeque;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.Comparator;
import java.util.List;
import java.util.Map;
import java.util.Queue;
import java.util.concurrent.BlockingDeque;
import java.util.concurrent.LinkedBlockingDeque;
import javax.annotation.Nullable;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.*;
import rs117.hd.HdPlugin;
import rs117.hd.scene.MaterialManager;
import rs117.hd.scene.SceneContext;
import rs117.hd.scene.materials.Material;
import rs117.hd.scene.model_overrides.ModelOverride;
import rs117.hd.utils.Camera;
import rs117.hd.utils.CommandBuffer;
import rs117.hd.utils.HDUtils;

import static net.runelite.api.Perspective.*;
import static org.lwjgl.opengl.GL33C.*;
import static rs117.hd.HdPlugin.GL_CAPS;
import static rs117.hd.HdPlugin.SUPPORTS_INDIRECT_DRAW;
import static rs117.hd.HdPlugin.checkGLErrors;
import static rs117.hd.renderer.zone.FacePrioritySorter.distanceFaceCount;
import static rs117.hd.renderer.zone.FacePrioritySorter.distanceToFaces;
import static rs117.hd.utils.MathUtils.*;

@Slf4j
@RequiredArgsConstructor
public class Zone {
	// Zone vertex format
	// pos short vec3(x, y, z)
	// uvw short vec3(u, v, w)
	// normal short vec3(nx, ny, nz)
	// alphaBiasHsl int
	// materialData int
	// terrainData int
	public static final int VERT_SIZE = 32;

	// Metadata format
	// worldViewIndex int int
	// sceneOffset int vec2(x, y)
	public static final int METADATA_SIZE = 12;

	public static final int LEVEL_WATER_SURFACE = 4;

	public static final BlockingDeque<VBO> VBO_PENDING_DELETION = new LinkedBlockingDeque<>();
	public static final BlockingDeque<Integer> VAO_PENDING_DELETION = new LinkedBlockingDeque<>();

	public int glVao;
	int bufLen;

	public int glVaoA;
	public int bufLenA;

	public int sizeO, sizeA;
	@Nullable
	public VBO vboO, vboA, vboM;

	public boolean initialized; // whether the zone vao and vbos are ready
	public boolean cull; // whether the zone is queued for deletion
	public boolean needsRoofUpdate; // whether the zone needs to have its roofs updated during scene swap
	public boolean rebuild; // whether the zone is queued for rebuild
	public boolean dirty; // whether the zone has temporary modifications
	public boolean hasWater; // whether the zone has any water tiles
	public boolean onlyWater; // whether the zone only contains water tiles
	public boolean inSceneFrustum; // whether the zone is visible to the scene camera
	public boolean inShadowFrustum; // whether the zone casts shadows into the visible scene
	public boolean isFirstLoadingAttempt = true;

	ZoneUploadJob uploadJob;

	int[] levelOffsets = new int[5]; // buffer pos in ints for the end of the level

	int[][] rids;
	int[][] roofStart;
	int[][] roofEnd;

	final List<AlphaModel> alphaModels = new ArrayList<>(0);

	public void initialize(VBO o, VBO a, int eboShared) {
		assert glVao == 0;
		assert glVaoA == 0;

		if (o != null || a != null) {
			vboM = new VBO(METADATA_SIZE);
			vboM.initialize(GL_STATIC_DRAW);
		}

		if (o != null) {
			vboO = o;
			glVao = glGenVertexArrays();
			setupVao(glVao, o.bufId, vboM.bufId, eboShared);
		}

		if (a != null) {
			vboA = a;
			glVaoA = glGenVertexArrays();
			setupVao(glVaoA, a.bufId, vboM.bufId, eboShared);
		}
	}

	public static void freeZones(@Nullable Zone[][] zones) {
		if (zones == null)
			return;

		for (Zone[] column : zones)
			for (Zone zone : column)
				if (zone != null)
					zone.free();
	}

	public void free() {
		if (vboO != null) {
			vboO.destroy();
			vboO = null;
		}

		if (vboA != null) {
			vboA.destroy();
			vboA = null;
		}

		if (vboM != null) {
			vboM.destroy();
			vboM = null;
		}

		if (glVao != 0) {
			glDeleteVertexArrays(glVao);
			glVao = 0;
		}

		if (glVaoA != 0) {
			glDeleteVertexArrays(glVaoA);
			glVaoA = 0;
		}

		if (uploadJob != null) {
			uploadJob.cancel();
			uploadJob = null;
		}

		sizeO = 0;
		sizeA = 0;
		bufLen = 0;
		bufLenA = 0;

		initialized = false;
		cull = false;
		hasWater = false;
		onlyWater = false;
		inSceneFrustum = false;
		inShadowFrustum = false;

		Arrays.fill(levelOffsets, 0);
		rids = null;
		roofStart = null;
		roofEnd = null;

		// don't add permanent alphamodels to the cache as permanent alphamodels are always allocated
		// to avoid having to synchronize the cache
		alphaModels.clear();
	}

	public static void processPendingDeletions() {
		int leakCount = 0;
		VBO vbo;
		while ((vbo = VBO_PENDING_DELETION.poll()) != null) {
			vbo.destroy();
			leakCount++;
		}

		Integer vao;
		while ((vao = VAO_PENDING_DELETION.poll()) != null) {
			glDeleteVertexArrays(vao);
			leakCount++;
		}

		if (leakCount > 0)
			log.warn("Destroyed {} leaked VBOs", leakCount);
	}

	@Override
	@SuppressWarnings("deprecation")
	protected void finalize() {
		// Just in case the zone instance is no longer valid,
		// copy everything which needs to be cleaned up here
		if (vboO != null) {
			VBO_PENDING_DELETION.add(vboO);
			vboO = null;
		}

		if (vboA != null) {
			VBO_PENDING_DELETION.add(vboA);
			vboA = null;
		}

		if (vboM != null) {
			VBO_PENDING_DELETION.add(vboM);
			vboM = null;
		}

		if (glVao != 0) {
			VAO_PENDING_DELETION.add(glVao);
			glVao = 0;
		}

		if (glVaoA != 0) {
			VAO_PENDING_DELETION.add(glVaoA);
			glVaoA = 0;
		}
	}

	public void unmap() {
		if (vboO != null) {
			vboO.unmap();
		}
		if (vboA != null) {
			vboA.unmap();
		}

		if (vboO != null) {
			this.bufLen = vboO.len / (VERT_SIZE / 4);
		}

		if (vboA != null) {
			this.bufLenA = vboA.len / (VERT_SIZE / 4);
		}
	}

	private void setupVao(int vao, int buffer, int metadata, int ebo) {
		glBindVertexArray(vao);
		glBindBuffer(GL_ARRAY_BUFFER, buffer);

		// The element buffer is part of VAO state
		glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, ebo);

		// Position
		glEnableVertexAttribArray(0);
		glVertexAttribPointer(0, 3, GL_SHORT, false, VERT_SIZE, 0);

		// UVs
		glEnableVertexAttribArray(1);
		glVertexAttribPointer(1, 3, GL_HALF_FLOAT, false, VERT_SIZE, 6);

		// Normals
		glEnableVertexAttribArray(2);
		glVertexAttribPointer(2, 3, GL_SHORT, false, VERT_SIZE, 12);

		// Alpha, bias & HSL
		glEnableVertexAttribArray(3);
		glVertexAttribIPointer(3, 1, GL_INT, VERT_SIZE, 20);

		// Material data
		glEnableVertexAttribArray(4);
		glVertexAttribIPointer(4, 1, GL_INT, VERT_SIZE, 24);

		// Terrain data
		glEnableVertexAttribArray(5);
		glVertexAttribIPointer(5, 1, GL_INT, VERT_SIZE, 28);

		glBindBuffer(GL_ARRAY_BUFFER, metadata);

		// WorldView index (not ID)
		glEnableVertexAttribArray(6);
		glVertexAttribDivisor(6, 1);
		glVertexAttribIPointer(6, 1, GL_INT, METADATA_SIZE, 0);

		// Scene offset
		glEnableVertexAttribArray(7);
		glVertexAttribDivisor(7, 1);
		glVertexAttribIPointer(7, 2, GL_INT, METADATA_SIZE, 4);

		checkGLErrors();

		glBindVertexArray(0);
		glBindBuffer(GL_ARRAY_BUFFER, 0);
	}

	public void setMetadata(WorldViewContext viewContext, SceneContext sceneContext, int mx, int mz) {
		if (vboM == null)
			return;

		int baseX = (mx - (sceneContext.sceneOffset >> 3)) << 10;
		int baseZ = (mz - (sceneContext.sceneOffset >> 3)) << 10;

		vboM.map();
		vboM.vb.put(viewContext.uboWorldViewStruct != null ? viewContext.uboWorldViewStruct.worldViewIdx + 1 : 0);
		vboM.vb.put(baseX);
		vboM.vb.put(baseZ);
		vboM.unmap();
	}

	void updateRoofs(Map<Integer, Integer> updates) {
		for (int level = 0; level < 4; ++level) {
			for (int i = 0; i < rids[level].length; ++i) {
				rids[level][i] = updates.getOrDefault(rids[level][i], rids[level][i]);
			}
		}

		for (AlphaModel m : alphaModels) {
			m.rid = (short) (int) updates.getOrDefault((int) m.rid, (int) m.rid);
		}
	}

	private static final int NUM_DRAW_RANGES = 512;
	private static final int[] drawOff = new int[NUM_DRAW_RANGES];
	private static final int[] drawEnd = new int[NUM_DRAW_RANGES];
	private static int drawIdx = 0;
	private static int[] glDrawOffset, glDrawLength;

	private static final int[][] glDrawOffsetPreAlloc = new int[15][];
	private static final int[][] glDrawLengthPreAlloc = new int[15][];

	static {
		for (int i = 0; i < glDrawOffsetPreAlloc.length; ++i) {
			glDrawOffsetPreAlloc[i] = new int[i + 1];
			glDrawLengthPreAlloc[i] = new int[i + 1];
		}
	}

	private void convertForDraw(int vertSize) {
		for (int i = 0; i < drawIdx; ++i) {
			assert drawEnd[i] >= drawOff[i];

			// convert from bytes to verts
			drawOff[i] /= vertSize >> 2;
			drawEnd[i] /= vertSize >> 2;

			drawEnd[i] -= drawOff[i]; // convert from end pos to length
		}

		if (drawIdx < glDrawOffsetPreAlloc.length) {
			glDrawOffset = copyTo(glDrawOffsetPreAlloc[drawIdx], drawOff, 0, drawIdx);
			glDrawLength = copyTo(glDrawLengthPreAlloc[drawIdx], drawEnd, 0, drawIdx);
		} else {
			glDrawOffset = Arrays.copyOfRange(drawOff, 0, drawIdx);
			glDrawLength = Arrays.copyOfRange(drawEnd, 0, drawIdx);
		}
	}

	void renderOpaque(CommandBuffer cmd, WorldViewContext ctx, boolean roofShadows) {
		drawIdx = 0;

		int currentLevel = ctx.level;
		int maxLevel = ctx.maxLevel;
		var hiddenRoofIds = ctx.hideRoofIds;
		if (roofShadows) {
			maxLevel = 3;
			hiddenRoofIds = Collections.emptySet();
		}

		for (int level = ctx.minLevel; level <= maxLevel; ++level) {
			int[] rids = this.rids[level];
			int[] roofStart = this.roofStart[level];
			int[] roofEnd = this.roofEnd[level];

			if (rids.length == 0 || hiddenRoofIds.isEmpty() || level <= currentLevel) {
				// draw the whole level
				int start = level == 0 ? 0 : this.levelOffsets[level - 1];
				int end = this.levelOffsets[level];
				pushRange(start, end);
				continue;
			}

			for (int roofIdx = 0; roofIdx < rids.length; ++roofIdx) {
				int rid = rids[roofIdx];
				if (rid > 0 && !hiddenRoofIds.contains(rid)) {
					// draw the roof
					assert roofEnd[roofIdx] >= roofStart[roofIdx];
					if (roofEnd[roofIdx] > roofStart[roofIdx]) {
						pushRange(roofStart[roofIdx], roofEnd[roofIdx]);
					}
				}
			}

			// push from the end of the last roof to the end of the level
			int endpos = level == 0 ? 0 : this.levelOffsets[level - 1];
			for (int roofIdx = rids.length - 1; roofIdx >= 0; --roofIdx) {
				int rid = rids[roofIdx];
				if (rid > 0) {
					endpos = roofEnd[roofIdx];
					break;
				}
			}
			// draw the non roofs
			pushRange(endpos, this.levelOffsets[level]);
		}

		if (drawIdx == 0)
			return;

		lastDrawMode = STATIC_UNSORTED;
		lastVao = glVao;
		flush(cmd);
	}

	void renderOpaqueLevel(CommandBuffer cmd, int level) {
		drawIdx = 0;

		pushRange(this.levelOffsets[level - 1], this.levelOffsets[level]);

		if (drawIdx == 0)
			return;

		lastDrawMode = STATIC_UNSORTED;
		lastVao = glVao;
		flush(cmd);
	}

	private static void pushRange(int start, int end) {
		assert end >= start;

		if (drawIdx > 0 && drawEnd[drawIdx - 1] == start) {
			drawEnd[drawIdx - 1] = end;
		} else if (drawIdx >= NUM_DRAW_RANGES) {
			log.debug("draw ranges exhausted");
		} else {
			drawOff[drawIdx] = start;
			drawEnd[drawIdx] = end;
			drawIdx++;
		}
	}

	static class AlphaModel {
		int id;
		ModelOverride modelOverride;
		int startpos, endpos;
		short x, y, z; // local position
		short rid;
		int vao;
		byte level;
		byte lx, lz, ux, uz; // lower/upper zone coords
		byte zofx, zofz; // for temp alpha models, offset of source zone from target zone
		byte flags;

		// only set for static geometry as they require sorting
		int radius;
		int[] packedFaces;
		byte[] renderPriorities;

		static final int SKIP = 1; // temporary model is in a closer zone
		static final int TEMP = 2; // temporary model added to a closer zone

		boolean isTemp() {
			return packedFaces == null;
		}
	}

	static final Queue<AlphaModel> modelCache = new ArrayDeque<>();

	void addAlphaModel(
		HdPlugin plugin,
		MaterialManager materialManager,
		int vao,
		Model model,
		ModelOverride modelOverride,
		int startpos,
		int endpos,
		int x,
		int y,
		int z,
		int lx,
		int lz,
		int ux,
		int uz,
		int rid,
		int level,
		int id
	) {
		AlphaModel m = new AlphaModel();
		m.id = id;
		m.modelOverride = modelOverride;
		m.startpos = startpos;
		m.endpos = endpos;
		m.x = (short) x;
		m.y = (short) y;
		m.z = (short) z;
		m.vao = vao;
		m.rid = (short) rid;
		m.level = (byte) level;
		if (lx > -1) {
			m.lx = (byte) lx;
			m.lz = (byte) lz;
			m.ux = (byte) ux;
			m.uz = (byte) uz;
		} else {
			m.lx = m.lz = m.ux = m.uz = -1;
		}

		int faceCount = model.getFaceCount();
		short[] unlitColor = plugin.configUnlitFaceColors ? model.getUnlitFaceColors() : null;
		int[] color1 = model.getFaceColors1();
		int[] color3 = model.getFaceColors3();
		byte[] transparencies = model.getFaceTransparencies();
		short[] faceTextures = model.getFaceTextures();
		float[] vertexX = model.getVerticesX();
		float[] vertexY = model.getVerticesY();
		float[] vertexZ = model.getVerticesZ();
		int[] indices1 = model.getFaceIndices1();
		int[] indices2 = model.getFaceIndices2();
		int[] indices3 = model.getFaceIndices3();

		int minX = Integer.MAX_VALUE, minY = minX, minZ = minY;
		int maxX = Integer.MIN_VALUE, maxY = maxX, maxZ = maxY;

		for (int f = 0; f < faceCount; ++f) {
			if (color3[f] == -2)
				continue;

			boolean hasAlpha = modelOverride.mightHaveTransparency || transparencies != null && transparencies[f] != 0;
			if (!hasAlpha)
				continue;

			int fx = (int) (vertexX[indices1[f]] + vertexX[indices2[f]] + vertexX[indices3[f]]);
			int fy = (int) (vertexY[indices1[f]] + vertexY[indices2[f]] + vertexY[indices3[f]]);
			int fz = (int) (vertexZ[indices1[f]] + vertexZ[indices2[f]] + vertexZ[indices3[f]]);

			minX = Math.min(minX, fx);
			maxX = Math.max(maxX, fx);
			minY = Math.min(minY, fy);
			maxY = Math.max(maxY, fy);
			minZ = Math.min(minZ, fz);
			maxZ = Math.max(maxZ, fz);
		}

		int cx = (minX + maxX) / 6;
		int cy = (minY + maxY) / 6;
		int cz = (minZ + maxZ) / 6;

		int size = Math.max(
			Math.max(
				Math.max(maxX / 3 - cx, minX / -3 - cx),
				Math.max(maxY / 3 - cy, minY / -3 - cy) * 2
			),
			Math.max(maxZ / 3 - cz, minZ / -3 - cz)
		);

		int shift = 0;
		// 10 bits because we need a sign bit
		for (int v = size >> 10; v > 0; v >>= 1) {
			shift++;
		}

		int[] packedFaces = m.packedFaces = new int[(endpos - startpos) / ((3 * VERT_SIZE) >> 2)];
		int radius = 0;
		char bufferIdx = 0;
		for (int f = 0; f < faceCount; ++f) {
			if (color3[f] == -2)
				continue;

			// Hide fake shadows or lighting that is often baked into models by making the fake shadow transparent
			if (plugin.configHideFakeShadows && modelOverride.hideVanillaShadows && HDUtils.isBakedGroundShading(model, f))
				continue;

			int transparency = transparencies != null ? transparencies[f] & 0xFF : 0;
			int textureId = faceTextures != null ? faceTextures[f] : -1;

			Material material = Material.NONE;
			if (textureId != -1) {
				if (modelOverride.textureMaterial != Material.NONE) {
					material = modelOverride.textureMaterial;
				} else {
					material = materialManager.fromVanillaTexture(textureId);
					if (modelOverride.materialOverrides != null) {
						var override = modelOverride.materialOverrides.get(material);
						if (override != null) {
							material = override.textureMaterial;
						}
					}
				}
			} else if (modelOverride.colorOverrides != null) {
				int ahsl = (0xFF - transparency) << 16 | (unlitColor != null ? unlitColor[f] & 0xFFFF : color1[f]);
				for (var override : modelOverride.colorOverrides) {
					if (override.ahslCondition.test(ahsl)) {
						material = override.baseMaterial;
						break;
					}
				}
			}

			boolean hasAlpha = material.hasTransparency || transparency != 0;
			if (!hasAlpha)
				continue;

			int fx = (((int) (vertexX[indices1[f]] + vertexX[indices2[f]] + vertexX[indices3[f]]) / 3) - cx) >> shift;
			int fy = (((int) (vertexY[indices1[f]] + vertexY[indices2[f]] + vertexY[indices3[f]]) / 3) - cy) >> shift;
			int fz = (((int) (vertexZ[indices1[f]] + vertexZ[indices2[f]] + vertexZ[indices3[f]]) / 3) - cz) >> shift;

			radius = Math.max(radius, fx * fx + fy * fy + fz * fz);

			packedFaces[bufferIdx] = ((fx & ((1 << 11) - 1)) << 21)
									 | ((fy & ((1 << 10) - 1)) << 11)
									 | (fz & ((1 << 11) - 1));
			bufferIdx++;
		}

		assert radius >= 0;

		m.renderPriorities = model.getFaceRenderPriorities();
		m.radius = 2 + (int) Math.sqrt(radius);

		assert packedFaces.length > 0;
		// Normally these will be equal, but transparency is used to hide faces in the TzHaar reskin
		assert bufferIdx <= packedFaces.length : String.format("%d > %d", (int) bufferIdx, packedFaces.length);

		alphaModels.add(m);
	}

	void addTempAlphaModel(ModelOverride modelOverride, int vao, int startpos, int endpos, int level, int x, int y, int z) {
		AlphaModel m = modelCache.poll();
		if (m == null)
			m = new AlphaModel();
		m.id = -1;
		m.modelOverride = modelOverride;
		m.startpos = startpos;
		m.endpos = endpos;
		m.x = (short) x;
		m.y = (short) y;
		m.z = (short) z;
		m.vao = vao;
		m.rid = -1;
		m.level = (byte) level;
		m.lx = m.lz = m.ux = m.uz = -1;
		m.flags = 0;
		m.zofx = m.zofz = 0;
		alphaModels.add(m);
	}

	void removeTemp() {
		for (int i = alphaModels.size() - 1; i >= 0; --i) {
			AlphaModel m = alphaModels.get(i);
			if (m.isTemp() || (m.flags & AlphaModel.TEMP) != 0) {
				alphaModels.remove(i);
				m.packedFaces = null;
				m.renderPriorities = null;
				modelCache.add(m);
			}
			m.flags &= ~AlphaModel.SKIP;
		}
	}

	private static final int STATIC = 1;
	private static final int TEMP = 2;
	private static final int STATIC_UNSORTED = 3;

	private static int lastDrawMode;
	private static int lastVao;
	private static int lastzx, lastzz;

	private static final int[] numOfPriority = FacePrioritySorter.numOfPriority;
	private static final int[][] orderedFaces = FacePrioritySorter.orderedFaces;

	private Camera alphaSort_Camera;
	private int alphaSort_zx, alphaSort_zz;
	private final Comparator<AlphaModel> alphaSortComparator = Comparator.comparingInt((AlphaModel m) -> {
		final int cx = (int) alphaSort_Camera.getPositionX();
		final int cy = (int) alphaSort_Camera.getPositionY();
		final int cz = (int) alphaSort_Camera.getPositionZ();
		final int mx = m.x + ((alphaSort_zx - m.zofx) << 10);
		final int mz = m.z + ((alphaSort_zz - m.zofz) << 10);
		return (mx - cx) * (mx - cx) + (m.y - cy) * (m.y - cy) + (mz - cz) * (mz - cz);
	}).reversed();

	void alphaSort(int zx, int zz, Camera camera) {
		alphaSort_Camera = camera;
		alphaSort_zx = zx;
		alphaSort_zz = zz;
		alphaModels.sort(alphaSortComparator);
	}

	void renderAlpha(
		CommandBuffer cmd,
		int zx,
		int zz,
		int level,
		WorldViewContext ctx,
		Camera camera,
		boolean roofShadows,
		boolean skipSorting
	) {
		if (alphaModels.isEmpty())
			return;

		int currentLevel = ctx.level;
		int maxLevel = ctx.maxLevel;
		var hiddenRoofIds = ctx.hideRoofIds;
		if (roofShadows) {
			maxLevel = 3;
			hiddenRoofIds = Collections.emptySet();
		}

		cmd.DepthMask(false);

		drawIdx = 0;

		int yawSin = SINE[camera.getFixedYaw()];
		int yawCos = COSINE[camera.getFixedYaw()];
		int pitchSin = SINE[camera.getFixedPitch()];
		int pitchCos = COSINE[camera.getFixedPitch()];
		for (AlphaModel m : alphaModels) {
			if ((m.flags & AlphaModel.SKIP) != 0 || m.level != level)
				continue;

			if (level < ctx.minLevel || level > maxLevel || level > currentLevel && hiddenRoofIds.contains((int) m.rid))
				continue;

			if (lastVao != m.vao || lastzx != (zx - m.zofx) || lastzz != (zz - m.zofz))
				flush(cmd);

			lastVao = m.vao;
			lastzx = zx - m.zofx;
			lastzz = zz - m.zofz;

			if (m.isTemp()) {
				// these are already sorted and so just requires a glMultiDrawArrays() from the active vao
				lastDrawMode = TEMP;
				pushRange(m.startpos, m.endpos);
				continue;
			}

			if (skipSorting) {
				lastDrawMode = STATIC_UNSORTED;
				pushRange(m.startpos, m.endpos);
				continue;
			}

			lastDrawMode = STATIC;

			final int radius = m.radius;
			int diameter = 1 + radius * 2;
			final int[] packedFaces = m.packedFaces;
			if (diameter >= 6000)
				continue;

			Arrays.fill(distanceFaceCount, 0, diameter, (char) 0);

			for (int i = 0; i < packedFaces.length; ++i) {
				int packed = packedFaces[i];
				int x = packed >> 21;
				int y = (packed << 11) >> 22;
				int z = (packed << 21) >> 21;

				int t = z * yawCos - x * yawSin >> 16;
				int fz = y * pitchSin + t * pitchCos >> 16;
				fz += radius;

				assert fz >= 0 && fz < diameter : fz;
				distanceToFaces[fz][distanceFaceCount[fz]++] = (char) i;
			}

			ZoneRenderer.eboAlphaStaging.ensureCapacity(packedFaces.length * 3);

			byte[] faceRenderPriorities = m.renderPriorities;
			final int start = m.startpos / (VERT_SIZE >> 2); // ints to verts
			if (faceRenderPriorities == null || m.modelOverride.disablePrioritySorting) {
				for (int i = diameter - 1; i >= 0; --i) {
					final int cnt = distanceFaceCount[i];
					if (cnt > 0) {
						final char[] faces = distanceToFaces[i];

						ZoneRenderer.alphaFaceCount += cnt;
						for (int faceIdx = 0; faceIdx < cnt; ++faceIdx) {
							final int face = faces[faceIdx];
							int idx = face * 3 + start;
							ZoneRenderer.eboAlphaStaging.put(idx, idx + 1, idx + 2);
						}
					}
				}
			} else {
				// Vanilla uses priority draw order for alpha faces and not depth draw order
				// And since we don't have the full model here, only the alpha faces, we can't compute the
				// 10/11 insertion points either. Just ignore those since I think they are mostly for players,
				// which are rendered differently anyway.
				Arrays.fill(numOfPriority, 0);

				for (int i = diameter - 1; i >= 0; --i) {
					final int cnt = distanceFaceCount[i];
					if (cnt > 0) {
						final char[] faces = distanceToFaces[i];

						for (int faceIdx = 0; faceIdx < cnt; ++faceIdx) {
							final int face = faces[faceIdx];
							final byte pri = faceRenderPriorities[face];
							final int distIdx = numOfPriority[pri]++;

							orderedFaces[pri][distIdx] = face;
						}
					}
				}

				for (int pri = 0; pri < 12; ++pri) {
					final int priNum = numOfPriority[pri];
					final int[] priFaces = orderedFaces[pri];

					ZoneRenderer.alphaFaceCount += priNum;
					for (int faceIdx = 0; faceIdx < priNum; ++faceIdx) {
						final int face = priFaces[faceIdx];
						int idx = face * 3 + start;
						ZoneRenderer.eboAlphaStaging.put(idx, idx + 1, idx + 2);
					}
				}
			}
		}

		flush(cmd);
		cmd.DepthMask(true);
	}

	private void flush(CommandBuffer cmd) {
		if (lastDrawMode == STATIC) {
			if (ZoneRenderer.alphaFaceCount > 0) {
				int vertexCount = ZoneRenderer.alphaFaceCount * 3;
				long byteOffset = 4L * (ZoneRenderer.eboAlphaStaging.position() - vertexCount);
				cmd.BindVertexArray(lastVao);
				// The EBO & IDO is bound by in ZoneRenderer
				if (GL_CAPS.OpenGL40 && SUPPORTS_INDIRECT_DRAW) {
					cmd.DrawElementsIndirect(GL_TRIANGLES, vertexCount, (int) (byteOffset / 4L), ZoneRenderer.indirectDrawCmdsStaging);
				} else {
					cmd.DrawElements(GL_TRIANGLES, vertexCount, byteOffset);
				}
				ZoneRenderer.alphaFaceCount = 0;
			}
		} else if (drawIdx != 0) {
			convertForDraw(lastDrawMode == STATIC_UNSORTED ? VERT_SIZE : VAO.VERT_SIZE);
			cmd.BindVertexArray(lastVao);
			if (glDrawOffset.length == 1) {
				if (GL_CAPS.OpenGL40 && SUPPORTS_INDIRECT_DRAW) {
					cmd.DrawArraysIndirect(GL_TRIANGLES, glDrawOffset[0], glDrawLength[0], ZoneRenderer.indirectDrawCmdsStaging);
				} else {
					cmd.DrawArrays(GL_TRIANGLES, glDrawOffset[0], glDrawLength[0]);
				}
			} else {
				if (GL_CAPS.OpenGL43 && SUPPORTS_INDIRECT_DRAW) {
					cmd.MultiDrawArraysIndirect(GL_TRIANGLES, glDrawOffset, glDrawLength, ZoneRenderer.indirectDrawCmdsStaging);
				} else {
					cmd.MultiDrawArrays(GL_TRIANGLES, glDrawOffset, glDrawLength);
				}
			}
			drawIdx = 0;
		}
	}

	void multizoneLocs(SceneContext ctx, int zx, int zz, Camera camera, Zone[][] zones) {
		int offset = ctx.sceneOffset >> 3;
		int cx = (int) camera.getPositionX();
		int cz = (int) camera.getPositionZ();
		for (AlphaModel m : alphaModels) {
			if (m.lx == -1)
				continue;

			// calculate which zone this model should be drawn from
			// TODO fix for boats
			int max = Integer.MAX_VALUE;
			int closestZoneX = -50, closestZoneZ = -50;
			for (int x = m.lx >> 3; x <= m.ux >> 3; ++x) {
				for (int z = m.lz >> 3; z <= m.uz >> 3; ++z) {
					int centerX = (zx - m.zofx + x) * 8 + 4 << 7;
					int centerZ = (zz - m.zofz + z) * 8 + 4 << 7;
					int distance = (centerX - cx) * (centerX - cx) +
								   (centerZ - cz) * (centerZ - cz);
					if (distance < max) {
						max = distance;
						closestZoneX = centerX >> 10;
						closestZoneZ = centerZ >> 10;
					}
				}
			}
			assert closestZoneX != -50;
			if (closestZoneX != zx || closestZoneZ != zz) {
				assert (m.flags & AlphaModel.TEMP) == 0;

				assert closestZoneX + offset >= 0 : closestZoneX;
				assert closestZoneX + offset < zones.length : closestZoneX;
				assert closestZoneZ + offset >= 0 : closestZoneZ;
				assert closestZoneZ + offset < zones[0].length : closestZoneZ;

				Zone z = zones[closestZoneX + offset][closestZoneZ + offset];
				assert z != null;
				assert z != this;

				AlphaModel m2 = modelCache.poll();
				if (m2 == null)
					m2 = new AlphaModel();
				m2.id = m.id;
				m2.modelOverride = m.modelOverride;
				m2.startpos = m.startpos;
				m2.endpos = m.endpos;
				m2.x = m.x;
				m2.y = m.y;
				m2.z = m.z;
				m2.vao = m.vao;
				m2.rid = m.rid;
				m2.level = m.level;
				m2.lx = m.lx;
				m2.lz = m.lz;
				m2.ux = m.ux;
				m2.uz = m.uz;
				m2.zofx = (byte) (closestZoneX - zx);
				m2.zofz = (byte) (closestZoneZ - zz);

				m2.packedFaces = m.packedFaces;
				m2.renderPriorities = m.renderPriorities;
				m2.radius = m.radius;

				m2.flags = AlphaModel.TEMP;
				m.flags |= AlphaModel.SKIP;

				z.alphaModels.add(m2);
			}
		}
	}
}

/*
 * Copyright (c) 2018, Adam <Adam@sigterm.info>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package rs117.hd.renderer.zone;

import java.io.IOException;
import java.util.Arrays;
import java.util.Set;
import javax.inject.Inject;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.*;
import net.runelite.api.events.*;
import net.runelite.api.hooks.*;
import net.runelite.client.callback.RenderCallbackManager;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.ui.DrawManager;
import org.lwjgl.opengl.*;
import rs117.hd.HdPlugin;
import rs117.hd.HdPluginConfig;
import rs117.hd.config.ColorFilter;
import rs117.hd.config.DynamicLights;
import rs117.hd.config.ShadowMode;
import rs117.hd.opengl.shader.SceneShaderProgram;
import rs117.hd.opengl.shader.ShaderException;
import rs117.hd.opengl.shader.ShaderIncludes;
import rs117.hd.opengl.shader.ShadowShaderProgram;
import rs117.hd.opengl.uniforms.UBOLights;
import rs117.hd.opengl.uniforms.UBOWorldViews;
import rs117.hd.overlays.FrameTimer;
import rs117.hd.overlays.Timer;
import rs117.hd.renderer.Renderer;
import rs117.hd.scene.EnvironmentManager;
import rs117.hd.scene.LightManager;
import rs117.hd.scene.ModelOverrideManager;
import rs117.hd.scene.ProceduralGenerator;
import rs117.hd.scene.SceneContext;
import rs117.hd.scene.lights.Light;
import rs117.hd.scene.model_overrides.ModelOverride;
import rs117.hd.utils.Camera;
import rs117.hd.utils.ColorUtils;
import rs117.hd.utils.CommandBuffer;
import rs117.hd.utils.HDUtils;
import rs117.hd.utils.Mat4;
import rs117.hd.utils.ModelHash;
import rs117.hd.utils.RenderState;
import rs117.hd.utils.ShadowCasterVolume;
import rs117.hd.utils.buffer.GpuIntBuffer;
import rs117.hd.utils.jobs.GenericJob;
import rs117.hd.utils.jobs.JobSystem;

import static net.runelite.api.Constants.*;
import static net.runelite.api.Perspective.*;
import static org.lwjgl.opengl.GL33C.*;
import static org.lwjgl.opengl.GL40.GL_DRAW_INDIRECT_BUFFER;
import static rs117.hd.HdPlugin.APPLE;
import static rs117.hd.HdPlugin.COLOR_FILTER_FADE_DURATION;
import static rs117.hd.HdPlugin.NEAR_PLANE;
import static rs117.hd.HdPlugin.ORTHOGRAPHIC_ZOOM;
import static rs117.hd.HdPlugin.checkGLErrors;
import static rs117.hd.utils.Mat4.clipFrustumToDistance;
import static rs117.hd.utils.MathUtils.*;

@Slf4j
public class ZoneRenderer implements Renderer {
	private static final int ALPHA_ZSORT_CLOSE = 2048;

	private static int UNIFORM_BLOCK_COUNT = HdPlugin.UNIFORM_BLOCK_COUNT;
	public static final int UNIFORM_BLOCK_WORLD_VIEWS = UNIFORM_BLOCK_COUNT++;

	@Inject
	private Client client;

	@Inject
	private DrawManager drawManager;

	@Inject
	private RenderCallbackManager renderCallbackManager;

	@Inject
	private HdPlugin plugin;

	@Inject
	private HdPluginConfig config;

	@Inject
	private LightManager lightManager;

	@Inject
	private EnvironmentManager environmentManager;

	@Inject
	private ModelOverrideManager modelOverrideManager;

	@Inject
	private SceneManager sceneManager;

	@Inject
	private SceneUploader sceneUploader;

	@Inject
	private FacePrioritySorter facePrioritySorter;

	@Inject
	private FrameTimer frameTimer;

	@Inject
	private SceneShaderProgram sceneProgram;

	@Inject
	private ShadowShaderProgram.Fast fastShadowProgram;

	@Inject
	private ShadowShaderProgram.Detailed detailedShadowProgram;

	@Inject
	private JobSystem jobSystem;

	@Inject
	private UBOWorldViews uboWorldViews;

	private final Camera sceneCamera = new Camera();
	private final Camera directionalCamera = new Camera().setOrthographic(true);
	private final ShadowCasterVolume directionalShadowCasterVolume = new ShadowCasterVolume(directionalCamera);

	private final int[] worldPos = new int[3];

	private final RenderState renderState = new RenderState();
	private final CommandBuffer sceneCmd = new CommandBuffer(renderState);
	private final CommandBuffer directionalCmd = new CommandBuffer(renderState);

	private VAO.VAOList vaoO;
	private VAO.VAOList vaoA;
	private VAO.VAOList vaoPO;
	private VAO.VAOList vaoShadow;

	public static int indirectDrawCmds;
	public static GpuIntBuffer indirectDrawCmdsStaging;

	public static int eboAlpha;
	public static GpuIntBuffer eboAlphaStaging;
	public static int alphaFaceCount;

	private boolean sceneFboValid;
	private boolean shouldRenderScene;

	@Override
	public boolean supportsGpu(GLCapabilities glCaps) {
		return glCaps.OpenGL33;
	}

	@Override
	public int gpuFlags() {
		return
			DrawCallbacks.ZBUF |
			DrawCallbacks.ZBUF_ZONE_FRUSTUM_CHECK |
			DrawCallbacks.NORMALS;
	}

	@Override
	public void initialize() {
		initializeBuffers();

		jobSystem.initialize();
		uboWorldViews.initialize(UNIFORM_BLOCK_WORLD_VIEWS);
		sceneManager.initialize(uboWorldViews);
	}

	@Override
	public void destroy() {
		destroyBuffers();

		jobSystem.destroy();
		sceneManager.destroy();
		uboWorldViews.destroy();
	}

	@Override
	public void waitUntilIdle() {
		sceneManager.completeAllStreaming();
		glFinish();
	}

	@Override
	public void addShaderIncludes(ShaderIncludes includes) {
		includes
			.define("MAX_SIMULTANEOUS_WORLD_VIEWS", UBOWorldViews.MAX_SIMULTANEOUS_WORLD_VIEWS)
			.addInclude("WORLD_VIEW_GETTER", () -> plugin.generateGetter("WorldView", UBOWorldViews.MAX_SIMULTANEOUS_WORLD_VIEWS))
			.addUniformBuffer(uboWorldViews);
	}

	@Override
	public void initializeShaders(ShaderIncludes includes) throws ShaderException, IOException {
		sceneProgram.compile(includes);
		fastShadowProgram.compile(includes);
		detailedShadowProgram.compile(includes);
	}

	@Override
	public void destroyShaders() {
		sceneProgram.destroy();
		fastShadowProgram.destroy();
		detailedShadowProgram.destroy();
	}

	private void initializeBuffers() {
		eboAlpha = glGenBuffers();
		eboAlphaStaging = new GpuIntBuffer();

		indirectDrawCmds = glGenBuffers();
		indirectDrawCmdsStaging = new GpuIntBuffer();

		vaoO = new VAO.VAOList(eboAlpha);
		vaoA = new VAO.VAOList(eboAlpha);
		vaoPO = new VAO.VAOList(eboAlpha);
		vaoShadow = new VAO.VAOList(eboAlpha);
	}

	private void destroyBuffers() {
		vaoO.free();
		vaoA.free();
		vaoPO.free();
		vaoShadow.free();
		vaoO = vaoA = vaoPO = vaoShadow = null;

		if (eboAlpha != 0)
			glDeleteBuffers(eboAlpha);
		eboAlpha = 0;

		if (eboAlphaStaging != null)
			eboAlphaStaging.destroy();
		eboAlphaStaging = null;

		if (indirectDrawCmds != 0)
			glDeleteBuffers(indirectDrawCmds);
		indirectDrawCmds = 0;

		if (indirectDrawCmdsStaging != null)
			indirectDrawCmdsStaging.destroy();
		indirectDrawCmdsStaging = null;
	}

	@Override
	public void preSceneDraw(
		Scene scene,
		float cameraX, float cameraY, float cameraZ, float cameraPitch, float cameraYaw,
		int minLevel, int level, int maxLevel, Set<Integer> hideRoofIds
	) {
		WorldViewContext ctx = sceneManager.getContext(scene);
		if (ctx == null)
			return;

		ctx.minLevel = minLevel;
		ctx.level = level;
		ctx.maxLevel = maxLevel;
		ctx.hideRoofIds = hideRoofIds;

		if (ctx.uboWorldViewStruct != null)
			ctx.uboWorldViewStruct.update();

		if (scene.getWorldViewId() == WorldView.TOPLEVEL) {
			preSceneDrawTopLevel(scene, cameraX, cameraY, cameraZ, cameraPitch, cameraYaw);
		} else {
			Scene topLevel = client.getScene();
			vaoO.addRange(topLevel);
			vaoPO.addRange(topLevel);
			vaoShadow.addRange(topLevel);
		}
	}

	private void preSceneDrawTopLevel(
		Scene scene,
		float cameraX, float cameraY, float cameraZ, float cameraPitch, float cameraYaw
	) {
		jobSystem.processPendingClientCallbacks();

		scene.setDrawDistance(plugin.getDrawDistance());
		plugin.updateSceneFbo();

		if (!sceneManager.isTopLevelValid() || plugin.sceneViewport == null)
			return;

		WorldViewContext ctx = sceneManager.getContext(scene);

		frameTimer.begin(Timer.DRAW_FRAME);
		frameTimer.begin(Timer.DRAW_SCENE);

		boolean updateUniforms = true;

		if (!plugin.enableFreezeFrame) {
			if (!plugin.redrawPreviousFrame) {
//				// Only reset the target buffer offset right before drawing the scene. That way if there are frames
//				// after this that don't involve a scene draw, like during LOADING/HOPPING/CONNECTION_LOST, we can
//				// still redraw the previous frame's scene to emulate the client behavior of not painting over the
//				// viewport buffer.
//				renderBufferOffset = sceneContext.staticVertexCount;

				plugin.drawnTileCount = 0;
				plugin.drawnStaticRenderableCount = 0;
				plugin.drawnDynamicRenderableCount = 0;

//				// TODO: this could be done only once during scene swap, but is a bit of a pain to do
//				// Push unordered models that should always be drawn at the start of each frame.
//				// Used to fix issues like the right-click menu causing underwater tiles to disappear.
//				var staticUnordered = sceneContext.staticUnorderedModelBuffer.getBuffer();
//				modelPassthroughBuffer
//					.ensureCapacity(staticUnordered.limit())
//					.put(staticUnordered);
//				staticUnordered.rewind();
//				numPassthroughModels += staticUnordered.limit() / 8;
			}

			if (updateUniforms) {
				copyTo(plugin.cameraPosition, vec(cameraX, cameraY, cameraZ));
				copyTo(plugin.cameraOrientation, vec(cameraYaw, cameraPitch));

				if (ctx.sceneContext.scene == scene) {
					copyTo(plugin.cameraFocalPoint, ivec((int) client.getCameraFocalPointX(), (int) client.getCameraFocalPointZ()));
					Arrays.fill(plugin.cameraShift, 0);
				} else {
					plugin.cameraShift[0] = plugin.cameraFocalPoint[0] - (int) client.getCameraFocalPointX();
					plugin.cameraShift[1] = plugin.cameraFocalPoint[1] - (int) client.getCameraFocalPointZ();
					plugin.cameraPosition[0] += plugin.cameraShift[0];
					plugin.cameraPosition[2] += plugin.cameraShift[1];
				}

				// TODO: Wind & character displacement
//				plugin.uboCompute.windDirectionX.set(cos(environmentManager.currentWindAngle));
//				plugin.uboCompute.windDirectionZ.set(sin(environmentManager.currentWindAngle));
//				plugin.uboCompute.windStrength.set(environmentManager.currentWindStrength);
//				plugin.uboCompute.windCeiling.set(environmentManager.currentWindCeiling);
//				plugin.uboCompute.windOffset.set(plugin.windOffset);
//
//				if (plugin.configCharacterDisplacement) {
//					// The local player needs to be added first for distance culling
//					Model playerModel = localPlayer.getModel();
//					if (playerModel != null)
//						plugin.uboCompute.addCharacterPosition(lp.getX(), lp.getY(), (int) (Perspective.LOCAL_TILE_SIZE * 1.33f));
//				}

				float zoom = client.get3dZoom();
				float drawDistance = (float) plugin.getDrawDistance();

				if (plugin.orthographicProjection)
					zoom *= ORTHOGRAPHIC_ZOOM;

				// Calculate the viewport dimensions before scaling in order to include the extra padding
				sceneCamera.setOrthographic(plugin.orthographicProjection);
				sceneCamera.setPosition(plugin.cameraPosition);
				sceneCamera.setOrientation(plugin.cameraOrientation);
				sceneCamera.setFixedYaw(client.getCameraYaw());
				sceneCamera.setFixedPitch(client.getCameraPitch());
				sceneCamera.setViewportWidth((int) (plugin.sceneViewport[2] / plugin.sceneViewportScale[0]));
				sceneCamera.setViewportHeight((int) (plugin.sceneViewport[3] / plugin.sceneViewportScale[1]));
				sceneCamera.setNearPlane(plugin.orthographicProjection ? -40000 : NEAR_PLANE);
				sceneCamera.setZoom(zoom);

				// Calculate view matrix, view proj & inv matrix
				sceneCamera.getViewMatrix(plugin.viewMatrix);
				sceneCamera.getViewProjMatrix(plugin.viewProjMatrix);
				sceneCamera.getInvViewProjMatrix(plugin.invViewProjMatrix);
				sceneCamera.getFrustumPlanes(plugin.cameraFrustum);

				if (sceneCamera.isDirty()) {
					int shadowDrawDistance = 90 * LOCAL_TILE_SIZE;
					directionalCamera.setPitch(environmentManager.currentSunAngles[0]);
					directionalCamera.setYaw(PI - environmentManager.currentSunAngles[1]);

					// Define a Finite Plane before extracting corners
					sceneCamera.setFarPlane(drawDistance * LOCAL_TILE_SIZE);

					int maxDistance = Math.min(shadowDrawDistance, (int) sceneCamera.getFarPlane());
					final float[][] sceneFrustumCorners = sceneCamera.getFrustumCorners();
					clipFrustumToDistance(sceneFrustumCorners, maxDistance);

					directionalShadowCasterVolume.build(sceneFrustumCorners);

					sceneCamera.setFarPlane(0.0f); // Reset so Scene can use Infinite Plane instead

					final float[] sceneCenter = new float[3];
					for (float[] corner : sceneFrustumCorners)
						add(sceneCenter, sceneCenter, corner);
					divide(sceneCenter, sceneCenter, (float) sceneFrustumCorners.length);

					float minX = Float.POSITIVE_INFINITY, maxX = Float.NEGATIVE_INFINITY;
					float minZ = Float.POSITIVE_INFINITY, maxZ = Float.NEGATIVE_INFINITY;
					float radius = 0f;
					for (float[] corner : sceneFrustumCorners) {
						radius = max(radius, distance(sceneCenter, corner));

						directionalCamera.transformPoint(corner, corner);

						minX = min(minX, corner[0]);
						maxX = max(maxX, corner[0]);

						minZ = min(minZ, corner[2]);
						maxZ = max(maxZ, corner[2]);
					}
					int directionalSize = (int) max(abs(maxX - minX), abs(maxZ - minZ));

					directionalCamera.setPosition(sceneCenter);
					directionalCamera.setNearPlane(radius * 2.0f);
					directionalCamera.setZoom(1.0f);
					directionalCamera.setViewportWidth(directionalSize);
					directionalCamera.setViewportHeight(directionalSize);

					plugin.uboGlobal.lightDir.set(directionalCamera.getForwardDirection());
					plugin.uboGlobal.lightProjectionMatrix.set(directionalCamera.getViewProjMatrix());
				}

				if (ctx.sceneContext.scene == scene) {
					try {
						frameTimer.begin(Timer.UPDATE_ENVIRONMENT);
						environmentManager.update(ctx.sceneContext);
						frameTimer.end(Timer.UPDATE_ENVIRONMENT);

						frameTimer.begin(Timer.UPDATE_LIGHTS);
						lightManager.update(ctx.sceneContext, plugin.cameraShift, plugin.cameraFrustum);
						frameTimer.end(Timer.UPDATE_LIGHTS);

						frameTimer.begin(Timer.UPDATE_SCENE);
						sceneManager.update();
						frameTimer.end(Timer.UPDATE_SCENE);
					} catch (Exception ex) {
						log.error("Error while updating environment or lights:", ex);
						plugin.stopPlugin();
						return;
					}
				}

				plugin.uboGlobal.cameraPos.set(plugin.cameraPosition);
				plugin.uboGlobal.viewMatrix.set(plugin.viewMatrix);
				plugin.uboGlobal.projectionMatrix.set(plugin.viewProjMatrix);
				plugin.uboGlobal.invProjectionMatrix.set(plugin.invViewProjMatrix);
				plugin.uboGlobal.pointLightsCount.set(ctx.sceneContext.numVisibleLights);
				plugin.uboGlobal.upload();
			}
		}

		if (plugin.configDynamicLights != DynamicLights.NONE && ctx.sceneContext.scene == scene) {
			// Update lights UBO
			assert ctx.sceneContext.numVisibleLights <= UBOLights.MAX_LIGHTS;

			frameTimer.begin(Timer.UPDATE_LIGHTS);
			final float[] lightPosition = new float[4];
			final float[] lightColor = new float[4];
			for (int i = 0; i < ctx.sceneContext.numVisibleLights; i++) {
				final Light light = ctx.sceneContext.lights.get(i);
				final float lightRadiusSq = light.radius * light.radius;
				lightPosition[0] = light.pos[0] + plugin.cameraShift[0];
				lightPosition[1] = light.pos[1];
				lightPosition[2] = light.pos[2] + plugin.cameraShift[1];
				lightPosition[3] = lightRadiusSq;

				lightColor[0] = light.color[0] * light.strength;
				lightColor[1] = light.color[1] * light.strength;
				lightColor[2] = light.color[2] * light.strength;
				lightColor[3] = 0.0f;

				plugin.uboLights.setLight(i, lightPosition, lightColor);

				if (plugin.configTiledLighting) {
					// Pre-calculate the view space position of the light, to save having to do the multiplication in the culling shader
					lightPosition[3] = 1.0f;
					Mat4.mulVec(lightPosition, plugin.viewMatrix, lightPosition);
					lightPosition[3] = lightRadiusSq; // Restore lightRadiusSq
					plugin.uboLightsCulling.setLight(i, lightPosition, lightColor);
				}
			}

			plugin.uboLights.upload();
			plugin.uboLightsCulling.upload();
			frameTimer.end(Timer.UPDATE_LIGHTS);

			// Perform tiled lighting culling before the compute memory barrier, so it's performed asynchronously
			if (plugin.configTiledLighting) {
				plugin.updateTiledLightingFbo();
				assert plugin.fboTiledLighting != 0;

				frameTimer.begin(Timer.DRAW_TILED_LIGHTING);
				frameTimer.begin(Timer.RENDER_TILED_LIGHTING);

				renderState.framebuffer.set(GL_FRAMEBUFFER, plugin.fboTiledLighting);
				renderState.viewport.set(0, 0, plugin.tiledLightingResolution[0], plugin.tiledLightingResolution[1]);
				renderState.vao.set(plugin.vaoTri);

				if (plugin.tiledLightingImageStoreProgram.isValid()) {
					renderState.program.set(plugin.tiledLightingImageStoreProgram);
					renderState.drawBuffer.set(GL_NONE);
					renderState.apply();
					glDrawArrays(GL_TRIANGLES, 0, 3);
				} else {
					renderState.drawBuffer.set(GL_COLOR_ATTACHMENT0);
					int layerCount = plugin.configDynamicLights.getTiledLightingLayers();
					for (int layer = 0; layer < layerCount; layer++) {
						renderState.program.set(plugin.tiledLightingShaderPrograms.get(layer));
						renderState.framebufferTextureLayer.set(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, plugin.texTiledLighting, 0, layer);
						renderState.apply();
						glDrawArrays(GL_TRIANGLES, 0, 3);
					}
				}

				frameTimer.end(Timer.RENDER_TILED_LIGHTING);
				frameTimer.end(Timer.DRAW_TILED_LIGHTING);
			}
		}

		// Upon logging in, the client will draw some frames with zero geometry before it hides the login screen
		if (client.getGameState().getState() >= GameState.LOGGED_IN.getState())
			plugin.hasLoggedIn = true;

		float fogDepth = 0;
		switch (config.fogDepthMode()) {
			case USER_DEFINED:
				fogDepth = config.fogDepth();
				break;
			case DYNAMIC:
				fogDepth = environmentManager.currentFogDepth;
				break;
		}
		fogDepth *= min(plugin.getDrawDistance(), 90) / 10.f;
		plugin.uboGlobal.useFog.set(fogDepth > 0 ? 1 : 0);
		plugin.uboGlobal.fogDepth.set(fogDepth);
		plugin.uboGlobal.fogColor.set(ColorUtils.linearToSrgb(environmentManager.currentFogColor));

		plugin.uboGlobal.drawDistance.set((float) plugin.getDrawDistance());
		plugin.uboGlobal.expandedMapLoadingChunks.set(ctx.sceneContext.expandedMapLoadingChunks);
		plugin.uboGlobal.colorBlindnessIntensity.set(config.colorBlindnessIntensity() / 100.f);

		float[] waterColorHsv = ColorUtils.srgbToHsv(environmentManager.currentWaterColor);
		float lightBrightnessMultiplier = 0.8f;
		float midBrightnessMultiplier = 0.45f;
		float darkBrightnessMultiplier = 0.05f;
		float[] waterColorLight = ColorUtils.linearToSrgb(ColorUtils.hsvToSrgb(new float[] {
			waterColorHsv[0],
			waterColorHsv[1],
			waterColorHsv[2] * lightBrightnessMultiplier
		}));
		float[] waterColorMid = ColorUtils.linearToSrgb(ColorUtils.hsvToSrgb(new float[] {
			waterColorHsv[0],
			waterColorHsv[1],
			waterColorHsv[2] * midBrightnessMultiplier
		}));
		float[] waterColorDark = ColorUtils.linearToSrgb(ColorUtils.hsvToSrgb(new float[] {
			waterColorHsv[0],
			waterColorHsv[1],
			waterColorHsv[2] * darkBrightnessMultiplier
		}));
		plugin.uboGlobal.waterColorLight.set(waterColorLight);
		plugin.uboGlobal.waterColorMid.set(waterColorMid);
		plugin.uboGlobal.waterColorDark.set(waterColorDark);

		plugin.uboGlobal.gammaCorrection.set(plugin.getGammaCorrection());
		float ambientStrength = environmentManager.currentAmbientStrength;
		float directionalStrength = environmentManager.currentDirectionalStrength;
		if (config.useLegacyBrightness()) {
			float factor = config.legacyBrightness() / 20f;
			ambientStrength *= factor;
			directionalStrength *= factor;
		}
		plugin.uboGlobal.ambientStrength.set(ambientStrength);
		plugin.uboGlobal.ambientColor.set(environmentManager.currentAmbientColor);
		plugin.uboGlobal.lightStrength.set(directionalStrength);
		plugin.uboGlobal.lightColor.set(environmentManager.currentDirectionalColor);

		plugin.uboGlobal.underglowStrength.set(environmentManager.currentUnderglowStrength);
		plugin.uboGlobal.underglowColor.set(environmentManager.currentUnderglowColor);

		plugin.uboGlobal.groundFogStart.set(environmentManager.currentGroundFogStart);
		plugin.uboGlobal.groundFogEnd.set(environmentManager.currentGroundFogEnd);
		plugin.uboGlobal.groundFogOpacity.set(config.groundFog() ?
			environmentManager.currentGroundFogOpacity :
			0);

		// Lights & lightning
		plugin.uboGlobal.pointLightsCount.set(ctx.sceneContext.numVisibleLights);
		plugin.uboGlobal.lightningBrightness.set(environmentManager.getLightningBrightness());

		plugin.uboGlobal.saturation.set(config.saturation() / 100f);
		plugin.uboGlobal.contrast.set(config.contrast() / 100f);
		plugin.uboGlobal.underwaterEnvironment.set(environmentManager.isUnderwater() ? 1 : 0);
		plugin.uboGlobal.underwaterCaustics.set(config.underwaterCaustics() ? 1 : 0);
		plugin.uboGlobal.underwaterCausticsColor.set(environmentManager.currentUnderwaterCausticsColor);
		plugin.uboGlobal.underwaterCausticsStrength.set(environmentManager.currentUnderwaterCausticsStrength);
		plugin.uboGlobal.elapsedTime.set((float) (plugin.elapsedTime % MAX_FLOAT_WITH_128TH_PRECISION));

		if (plugin.configColorFilter != ColorFilter.NONE) {
			plugin.uboGlobal.colorFilter.set(plugin.configColorFilter.ordinal());
			plugin.uboGlobal.colorFilterPrevious.set(plugin.configColorFilterPrevious.ordinal());
			long timeSinceChange = System.currentTimeMillis() - plugin.colorFilterChangedAt;
			plugin.uboGlobal.colorFilterFade.set(clamp(timeSinceChange / COLOR_FILTER_FADE_DURATION, 0, 1));
		}

		plugin.uboGlobal.upload();

		// Reset buffers for the next frame
		eboAlphaStaging.clear();
		indirectDrawCmdsStaging.clear();
		sceneCmd.reset();
		directionalCmd.reset();
		renderState.reset();

		checkGLErrors();
	}

	@Override
	public void postSceneDraw(Scene scene) {
		jobSystem.processPendingClientCallbacks();

		if (scene.getWorldViewId() == WorldView.TOPLEVEL)
			postDrawTopLevel();
	}

	private void postDrawTopLevel() {
		if (!sceneManager.isTopLevelValid() || plugin.sceneViewport == null)
			return;

		sceneFboValid = true;

		vaoA.unmap();

		// Upload world views before rendering
		uboWorldViews.upload();

		// Scene draw state to apply before all recorded commands
		if (eboAlphaStaging.position() > 0) {
			eboAlphaStaging.flip();
			glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, eboAlpha);
			glBufferData(GL_ELEMENT_ARRAY_BUFFER, eboAlphaStaging.getBuffer(), GL_STREAM_DRAW);
		}

		if (indirectDrawCmdsStaging.position() > 0) {
			indirectDrawCmdsStaging.flip();
			glBindBuffer(GL_DRAW_INDIRECT_BUFFER, indirectDrawCmds);
			glBufferData(GL_DRAW_INDIRECT_BUFFER, indirectDrawCmdsStaging.getBuffer(), GL_STREAM_DRAW);
		}

		frameTimer.end(Timer.DRAW_SCENE);
		frameTimer.begin(Timer.RENDER_FRAME);

		// Space out GL calls on Apple, to minimize stalls from the command queue filling up
		if (APPLE)
			directionalShadowPass();
		shouldRenderScene = true;

		// The client only updates animations once per client tick, so we can skip updating geometry buffers,
		// but the compute shaders should still be executed in case the camera angle has changed.
		// Technically we could skip compute shaders as well when the camera is unchanged,
		// but it would only lead to micro stuttering when rotating the camera, compared to no rotation.
//		if (!plugin.redrawPreviousFrame) {
//			updateSceneVao(hRenderBufferVertices, hRenderBufferUvs, hRenderBufferNormals);
//		}

//		frameTimer.begin(Timer.COMPUTE);
//		plugin.uboCompute.upload();
//		frameTimer.end(Timer.COMPUTE);

		checkGLErrors();
	}

	private void directionalShadowPass() {
		if (!plugin.configShadowsEnabled || plugin.fboShadowMap == 0 || environmentManager.currentDirectionalStrength <= 0)
			return;

		frameTimer.begin(Timer.RENDER_SHADOWS);

		// Render to the shadow depth map
		renderState.framebuffer.set(GL_FRAMEBUFFER, plugin.fboShadowMap);
		renderState.viewport.set(0, 0, plugin.shadowMapResolution, plugin.shadowMapResolution);
		renderState.apply();

		glClearDepth(1);
		glClear(GL_DEPTH_BUFFER_BIT);

		renderState.enable.set(GL_DEPTH_TEST);
		renderState.disable.set(GL_CULL_FACE);
		renderState.depthFunc.set(GL_LEQUAL);

		CommandBuffer.SKIP_DEPTH_MASKING = true;
		directionalCmd.execute();
		CommandBuffer.SKIP_DEPTH_MASKING = false;

		renderState.disable.set(GL_DEPTH_TEST);

		frameTimer.end(Timer.RENDER_SHADOWS);
	}

	private void scenePass() {
		sceneProgram.use();

		frameTimer.begin(Timer.DRAW_SCENE);
		renderState.framebuffer.set(GL_DRAW_FRAMEBUFFER, plugin.fboScene);
		if (plugin.msaaSamples > 1) {
			renderState.enable.set(GL_MULTISAMPLE);
		} else {
			renderState.disable.set(GL_MULTISAMPLE);
		}
		renderState.viewport.set(0, 0, plugin.sceneResolution[0], plugin.sceneResolution[1]);
		renderState.apply();

		// Clear scene
		frameTimer.begin(Timer.CLEAR_SCENE);

		float[] fogColor = ColorUtils.linearToSrgb(environmentManager.currentFogColor);
		float[] gammaCorrectedFogColor = pow(fogColor, plugin.getGammaCorrection());
		glClearColor(
			gammaCorrectedFogColor[0],
			gammaCorrectedFogColor[1],
			gammaCorrectedFogColor[2],
			1f
		);
		glClearDepth(0);
		glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
		frameTimer.end(Timer.CLEAR_SCENE);

		frameTimer.begin(Timer.RENDER_SCENE);

		renderState.enable.set(GL_BLEND);
		renderState.enable.set(GL_CULL_FACE);
		renderState.enable.set(GL_DEPTH_TEST);
		renderState.depthFunc.set(GL_GEQUAL);
		renderState.blendFunc.set(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA, GL_ZERO, GL_ONE);

		// Render the scene
		sceneCmd.execute();

		// TODO: Filler tiles
		frameTimer.end(Timer.RENDER_SCENE);

		// Done rendering the scene
		renderState.disable.set(GL_BLEND);
		renderState.disable.set(GL_CULL_FACE);
		renderState.disable.set(GL_DEPTH_TEST);
		renderState.apply();

		frameTimer.end(Timer.DRAW_SCENE);
	}

	@Override
	public boolean zoneInFrustum(int zx, int zz, int maxY, int minY) {
		if (!sceneManager.isTopLevelValid())
			return false;

		WorldViewContext ctx = sceneManager.getRoot();
		if (plugin.enableDetailedTimers) frameTimer.begin(Timer.VISIBILITY_CHECK);
		int minX = zx * CHUNK_SIZE - ctx.sceneContext.sceneOffset;
		int minZ = zz * CHUNK_SIZE - ctx.sceneContext.sceneOffset;
		if (ctx.sceneContext.currentArea != null) {
			var base = ctx.sceneContext.sceneBase;
			assert base != null;
			boolean inArea = ctx.sceneContext.currentArea.intersects(
				true, base[0] + minX, base[1] + minZ, base[0] + minX + 7, base[1] + minZ + 7);
			if (!inArea) {
				if (plugin.enableDetailedTimers) frameTimer.end(Timer.VISIBILITY_CHECK);
				return false;
			}
		}

		minX *= LOCAL_TILE_SIZE;
		minZ *= LOCAL_TILE_SIZE;
		int maxX = minX + CHUNK_SIZE * LOCAL_TILE_SIZE;
		int maxZ = minZ + CHUNK_SIZE * LOCAL_TILE_SIZE;
		Zone zone = ctx.zones[zx][zz];
		if (zone.hasWater) {
			maxY += ProceduralGenerator.MAX_DEPTH;
			minY -= ProceduralGenerator.MAX_DEPTH;
		}

		int x = (((zx << 3) - ctx.sceneContext.sceneOffset) << 7) + 512 - (int) sceneCamera.getPositionX();
		int z = (((zz << 3) - ctx.sceneContext.sceneOffset) << 7) + 512 - (int) sceneCamera.getPositionZ();
		int y = maxY - (int) sceneCamera.getPositionY();
		int zoneRadius = 724; // ~ 512 * sqrt(2)
		int waterDepth = zone.hasWater ? ProceduralGenerator.MAX_DEPTH : 0;

		final int leftClip = client.getRasterizer3D_clipNegativeMidX();
		final int rightClip = client.getRasterizer3D_clipMidX2();
		final int topClip = client.getRasterizer3D_clipNegativeMidY();
		final int bottomClip = client.getRasterizer3D_clipMidY2();

		final int cameraYawCos = Perspective.COSINE[sceneCamera.getFixedYaw()];
		final int cameraYawSin = SINE[sceneCamera.getFixedYaw()];
		final int cameraPitchCos = COSINE[sceneCamera.getFixedPitch()];
		final int cameraPitchSin = SINE[sceneCamera.getFixedPitch()];
		final int cameraZoom = (int) sceneCamera.getZoom();

		// Check if the tile is within the near plane of the frustum
		int transformedZ = z * cameraYawCos - x * cameraYawSin >> 16;
		int depth = (y + waterDepth) * cameraPitchSin + (transformedZ + zoneRadius) * cameraPitchCos >> 16;
		if (depth > NEAR_PLANE) {
			// Check left bound
			int transformedX = z * cameraYawSin + x * cameraYawCos >> 16;
			int left = transformedX - zoneRadius;
			if (left * cameraZoom < rightClip * depth) {
				// Check right bound
				int right = transformedX + zoneRadius;
				if (right * cameraZoom > leftClip * depth) {
					// Check top bound
					int transformedY = y * cameraPitchCos - transformedZ * cameraPitchSin >> 16;
					int transformedRadius = zoneRadius * cameraPitchSin >> 16;
					int transformedWaterDepth = waterDepth * cameraPitchCos >> 16;
					int bottom = transformedY + transformedRadius + transformedWaterDepth;
					if (bottom * cameraZoom > topClip * depth) {
						// Check bottom bound
						int transformedZoneHeight = minY * cameraPitchCos >> 16;
						int top = transformedY - transformedRadius + transformedZoneHeight;
						if (top * cameraZoom < bottomClip * depth) {
							if (plugin.enableDetailedTimers)
								frameTimer.end(Timer.VISIBILITY_CHECK);
							return zone.inSceneFrustum = zone.inShadowFrustum = true;
						}
					}
				}
			}
		}

		// TODO: This leads to objects that extend past the zone being culled, e.g. the platform pieces at Akkha
//		zone.inSceneFrustum = sceneCamera.intersectsAABB(minX, minY, minZ, maxX, maxY, maxZ);
//		if (zone.inSceneFrustum) {
//			if (plugin.enableDetailedTimers)
//				frameTimer.end(Timer.VISIBILITY_CHECK);
//			return zone.inShadowFrustum = true;
//		}

		if (plugin.configShadowsEnabled && plugin.configExpandShadowDraw) {
			zone.inShadowFrustum = directionalCamera.intersectsAABB(minX, minY, minZ, maxX, maxY, maxZ);
			if (zone.inShadowFrustum) {
				int centerX = minX + (maxX - minX) / 2;
				int centerY = minY + (maxY - minY) / 2;
				int centerZ = minZ + (maxZ - minZ) / 2;
				zone.inShadowFrustum = directionalShadowCasterVolume.intersectsPoint(centerX, centerY, centerZ);
			}
			if (plugin.enableDetailedTimers)
				frameTimer.end(Timer.VISIBILITY_CHECK);
			return zone.inShadowFrustum;
		}

		if (plugin.enableDetailedTimers)
			frameTimer.end(Timer.VISIBILITY_CHECK);
		if (plugin.orthographicProjection)
			return zone.inSceneFrustum = true;

		return false;
	}

	@Override
	public void drawZoneOpaque(Projection entityProjection, Scene scene, int zx, int zz) {
		jobSystem.processPendingClientCallbacks();

		WorldViewContext ctx = sceneManager.getContext(scene);
		if (ctx == null)
			return;

		Zone z = ctx.zones[zx][zz];
		if (!z.initialized || z.sizeO == 0)
			return;

		if (!sceneManager.isRoot(ctx) || z.inSceneFrustum)
			z.renderOpaque(sceneCmd, ctx, false);

		if (!sceneManager.isRoot(ctx) || z.inShadowFrustum) {
			directionalCmd.SetShader(fastShadowProgram);
			z.renderOpaque(directionalCmd, ctx, plugin.configRoofShadows);
		}

		checkGLErrors();
	}

	@Override
	public void drawZoneAlpha(Projection entityProjection, Scene scene, int level, int zx, int zz) {
		jobSystem.processPendingClientCallbacks();

		WorldViewContext ctx = sceneManager.getContext(scene);
		if (ctx == null)
			return;

		Zone z = ctx.zones[zx][zz];
		if (!z.initialized)
			return;

		boolean renderWater = z.inSceneFrustum && level == 0 && z.hasWater;
		if (renderWater)
			z.renderOpaqueLevel(sceneCmd, Zone.LEVEL_WATER_SURFACE);

		boolean hasAlpha = z.sizeA != 0 || !z.alphaModels.isEmpty();
		if (!hasAlpha)
			return;

		int offset = ctx.sceneContext.sceneOffset >> 3;
		int dx = (int) plugin.cameraPosition[0] - ((zx - offset) << 10);
		int dz = (int) plugin.cameraPosition[2] - ((zz - offset) << 10);
		// If the zone is at sea, allow incorrect alpha ordering in the distance, for areas like north of Prifddinas
		boolean skipSorting = z.onlyWater && dx * dx + dz * dz > ALPHA_ZSORT_CLOSE * ALPHA_ZSORT_CLOSE;

		if (level == 0) {
			z.alphaSort(zx - offset, zz - offset, sceneCamera);
			z.multizoneLocs(ctx.sceneContext, zx - offset, zz - offset, sceneCamera, ctx.zones);
		}

		if (!sceneManager.isRoot(ctx) || z.inSceneFrustum) {
			z.renderAlpha(sceneCmd, zx - offset, zz - offset, level, ctx, sceneCamera, false, skipSorting);
		}

		if (!sceneManager.isRoot(ctx) || z.inShadowFrustum) {
			directionalCmd.SetShader(plugin.configShadowMode == ShadowMode.DETAILED ? detailedShadowProgram : fastShadowProgram);
			z.renderAlpha(directionalCmd, zx - offset, zz - offset, level, ctx, directionalCamera, plugin.configRoofShadows, skipSorting);
		}

		checkGLErrors();
	}

	@Override
	public void drawPass(Projection projection, Scene scene, int pass) {
		jobSystem.processPendingClientCallbacks();

		WorldViewContext ctx = sceneManager.getContext(scene);
		if (ctx == null)
			return;

		switch (pass) {
			case DrawCallbacks.PASS_OPAQUE:
				vaoO.addRange(scene);
				vaoPO.addRange(scene);
				vaoShadow.addRange(scene);

				if (scene.getWorldViewId() == -1) {
					directionalCmd.SetShader(fastShadowProgram);

					// Draw opaque
					vaoO.unmap();
					vaoO.drawAll(sceneCmd);
					vaoO.drawAll(directionalCmd);
					vaoO.resetAll();

					vaoPO.unmap();

					// Draw shadow-only models
					vaoShadow.unmap();
					vaoShadow.drawAll(directionalCmd);
					vaoShadow.resetAll();

					// Draw players opaque, without depth writes
					sceneCmd.DepthMask(false);
					vaoPO.drawAll(sceneCmd);
					sceneCmd.DepthMask(true);

					// Draw players opaque, writing only depth
					sceneCmd.ColorMask(false, false, false, false);
					vaoPO.drawAll(sceneCmd);
					sceneCmd.ColorMask(true, true, true, true);

					vaoPO.resetAll();
				}
				break;
			case DrawCallbacks.PASS_ALPHA:
				for (int x = 0; x < ctx.sizeX; ++x)
					for (int z = 0; z < ctx.sizeZ; ++z)
						ctx.zones[x][z].removeTemp();
				break;
		}

		checkGLErrors();
	}

	@Override
	public void drawDynamic(
		Projection projection,
		Scene scene,
		TileObject tileObject,
		Renderable r,
		Model m,
		int orient,
		int x,
		int y,
		int z
	) {
		jobSystem.processPendingClientCallbacks();

		WorldViewContext ctx = sceneManager.getContext(scene);
		if (ctx == null || !renderCallbackManager.drawObject(scene, tileObject))
			return;

		int offset = ctx.sceneContext.sceneOffset >> 3;
		int zx = (x >> 10) + offset;
		int zz = (z >> 10) + offset;
		Zone zone = ctx.zones[zx][zz];

		if (sceneManager.isRoot(ctx)) {
			// Cull based on detail draw distance
			float squaredDistance = sceneCamera.squaredDistanceTo(x, y, z);
			int detailDrawDistanceTiles = plugin.configDetailDrawDistance * LOCAL_TILE_SIZE;
			if (squaredDistance > detailDrawDistanceTiles * detailDrawDistanceTiles)
				return;

			// Hide everything outside the current area if area hiding is enabled
			if (ctx.sceneContext.currentArea != null) {
				var base = ctx.sceneContext.sceneBase;
				assert base != null;
				boolean inArea = ctx.sceneContext.currentArea.containsPoint(
					base[0] + (x >> Perspective.LOCAL_COORD_BITS),
					base[1] + (z >> Perspective.LOCAL_COORD_BITS),
					base[2] + client.getTopLevelWorldView().getPlane()
				);
				if (!inArea)
					return;
			}

			if (!zone.initialized)
				return;
		}

		ctx.sceneContext.localToWorld(tileObject.getLocalLocation(), tileObject.getPlane(), worldPos);
		int uuid = ModelHash.generateUuid(client, tileObject.getHash(), r);
		ModelOverride modelOverride = modelOverrideManager.getOverride(uuid, worldPos);
		if (modelOverride.hide)
			return;

		if (sceneManager.isRoot(ctx)) {
			try (var ignored = frameTimer.begin(Timer.VISIBILITY_CHECK)) {
				// Additional Culling checks to help reduce dynamic object perf impact when off screen
				if (!zone.inSceneFrustum && zone.inShadowFrustum && !modelOverride.castShadows)
					return;

				if (zone.inSceneFrustum && !modelOverride.castShadows && !sceneCamera.intersectsSphere(x, y, z, m.getRadius()))
					return;

				if (!zone.inSceneFrustum && zone.inShadowFrustum && modelOverride.castShadows &&
					!directionalShadowCasterVolume.intersectsPoint(x, y, z))
					return;
			}
		}

		int preOrientation = HDUtils.getModelPreOrientation(HDUtils.getObjectConfig(tileObject));

		int size = m.getFaceCount() * 3 * VAO.VERT_SIZE;
		VAO o = vaoO.get(size, ctx.vboM);

		boolean hasAlpha = m.getFaceTransparencies() != null || modelOverride.mightHaveTransparency;
		if (hasAlpha) {
			VAO a = vaoA.get(size, ctx.vboM);
			int start = a.vbo.vb.position();

			if (zone.inSceneFrustum) {
				try {
					facePrioritySorter.uploadSortedModel(projection, m, modelOverride, preOrientation, orient, x, y, z, o.vbo.vb, a.vbo.vb);
				} catch (Exception ex) {
					log.debug("error drawing entity", ex);
				}

				if (plugin.configShadowsEnabled) {
					// Since priority sorting of models includes back-face culling,
					// we need to upload the entire model again for shadows
					VAO vao = vaoShadow.get(size, ctx.vboM);
					sceneUploader.uploadTempModel(
						m,
						modelOverride,
						preOrientation,
						orient,
						x, y, z,
						vao.vbo.vb,
						vao.vbo.vb
					);
				}
			} else {
				sceneUploader.uploadTempModel(m, modelOverride, preOrientation, orient, x, y, z, o.vbo.vb, a.vbo.vb);
			}

			int end = a.vbo.vb.position();
			if (end > start) {
				// level is checked prior to this callback being run, in order to cull clickboxes, but
				// tileObject.getPlane()>maxLevel if visbelow is set - lower the object to the max level
				int plane = Math.min(ctx.maxLevel, tileObject.getPlane());
				// renderable modelheight is typically not set here because DynamicObject doesn't compute it on the returned model
				zone.addTempAlphaModel(modelOverride, a.vao, start, end, plane, x & 1023, y, z & 1023);
			}
		} else {
			sceneUploader.uploadTempModel(m, modelOverride, preOrientation, orient, x, y, z, o.vbo.vb, o.vbo.vb);
		}
	}

	@Override
	public void drawTemp(Projection worldProjection, Scene scene, GameObject gameObject, Model m, int orientation, int x, int y, int z) {
		jobSystem.processPendingClientCallbacks();

		WorldViewContext ctx = sceneManager.getContext(scene);
		if (ctx == null || !renderCallbackManager.drawObject(scene, gameObject))
			return;

		ctx.sceneContext.localToWorld(gameObject.getLocalLocation(), gameObject.getPlane(), worldPos);
		// Hide everything outside the current area if area hiding is enabled
		if (ctx.sceneContext.currentArea != null && scene.getWorldViewId() == -1) {
			var base = ctx.sceneContext.sceneBase;
			assert base != null;
			boolean inArea = ctx.sceneContext.currentArea.containsPoint(
				base[0] + (x >> Perspective.LOCAL_COORD_BITS),
				base[1] + (z >> Perspective.LOCAL_COORD_BITS),
				base[2] + client.getTopLevelWorldView().getPlane()
			);
			if (!inArea)
				return;
		}

		Renderable renderable = gameObject.getRenderable();
		int uuid = ModelHash.generateUuid(client, gameObject.getHash(), renderable);
		ModelOverride modelOverride = modelOverrideManager.getOverride(uuid, worldPos);
		if (modelOverride.hide)
			return;

		int preOrientation = HDUtils.getModelPreOrientation(gameObject.getConfig());

		int size = m.getFaceCount() * 3 * VAO.VERT_SIZE;
		if (renderable instanceof Player || m.getFaceTransparencies() != null) {
			int offset = ctx.sceneContext.sceneOffset >> 3;
			int zx = (gameObject.getX() >> 10) + offset;
			int zz = (gameObject.getY() >> 10) + offset;
			Zone zone = ctx.zones[zx][zz];

			boolean isSubScene = !sceneManager.isRoot(ctx);

			GenericJob shadowUploadTask = null;
			if (isSubScene || zone.inShadowFrustum) {
				final VAO o = vaoShadow.get(size, ctx.vboM);

				shadowUploadTask = GenericJob
					.build("uploadTempModel", t -> {
						// Since priority sorting of models includes back-face culling,
						// we need to upload the entire model again for shadows
						sceneUploader.uploadTempModel(
							m,
							modelOverride,
							preOrientation,
							orientation,
							x, y, z,
							o.vbo.vb,
							o.vbo.vb
						);
					})
					.setExecuteAsync(isSubScene || zone.inSceneFrustum)
					.queue(true);
			}

			if (isSubScene || zone.inSceneFrustum) {
				// opaque player faces have their own vao and are drawn in a separate pass from normal opaque faces
				// because they are not depth tested. transparent player faces don't need their own vao because normal
				// transparent faces are already not depth tested
				VAO o = renderable instanceof Player ? vaoPO.get(size, ctx.vboM) : vaoO.get(size, ctx.vboM);
				VAO a = vaoA.get(size, ctx.vboM);

				int start = a.vbo.vb.position();
				try {
					facePrioritySorter.uploadSortedModel(
						worldProjection,
						m,
						modelOverride,
						preOrientation,
						orientation,
						x, y, z,
						o.vbo.vb,
						a.vbo.vb
					);
				} catch (Exception ex) {
					log.debug("error drawing entity", ex);
				}
				int end = a.vbo.vb.position();
				if (end > start) {
					// Fix rendering projectiles from boats with hide roofs enabled
					int plane = Math.min(ctx.maxLevel, gameObject.getPlane());
					zone.addTempAlphaModel(
						modelOverride,
						a.vao,
						start,
						end,
						plane,
						x & 1023,
						y - renderable.getModelHeight() /* to render players over locs */,
						z & 1023
					);
				}
			}

			if (shadowUploadTask != null) {
				shadowUploadTask.waitForCompletion();
				shadowUploadTask.release();
			}
		} else {
			VAO o = vaoO.get(size, ctx.vboM);
			sceneUploader.uploadTempModel(
				m,
				modelOverride,
				preOrientation,
				orientation,
				x, y, z,
				o.vbo.vb,
				o.vbo.vb
			);
		}
	}

	@Override
	public void draw(int overlayColor) {
		final GameState gameState = client.getGameState();
		if (gameState == GameState.STARTING) {
			frameTimer.end(Timer.DRAW_FRAME);
			return;
		}

		try {
			plugin.prepareInterfaceTexture();
		} catch (Exception ex) {
			// Fixes: https://github.com/runelite/runelite/issues/12930
			// Gracefully Handle loss of opengl buffers and context
			log.warn("prepareInterfaceTexture exception", ex);
			plugin.restartPlugin();
			return;
		}

		if (shouldRenderScene) {
			if (!APPLE)
				directionalShadowPass();
			scenePass();
		}

		if (sceneFboValid && plugin.sceneResolution != null && plugin.sceneViewport != null) {
			glBindFramebuffer(GL_READ_FRAMEBUFFER, plugin.fboScene);
			if (plugin.fboSceneResolve != 0) {
				// Blit from the scene FBO to the multisample resolve FBO
				glBindFramebuffer(GL_DRAW_FRAMEBUFFER, plugin.fboSceneResolve);
				glBlitFramebuffer(
					0, 0, plugin.sceneResolution[0], plugin.sceneResolution[1],
					0, 0, plugin.sceneResolution[0], plugin.sceneResolution[1],
					GL_COLOR_BUFFER_BIT, GL_NEAREST
				);
				glBindFramebuffer(GL_READ_FRAMEBUFFER, plugin.fboSceneResolve);
			}

			// Blit from the resolved FBO to the default FBO
			glBindFramebuffer(GL_DRAW_FRAMEBUFFER, plugin.awtContext.getFramebuffer(false));
			glBlitFramebuffer(
				0,
				0,
				plugin.sceneResolution[0],
				plugin.sceneResolution[1],
				plugin.sceneViewport[0],
				plugin.sceneViewport[1],
				plugin.sceneViewport[0] + plugin.sceneViewport[2],
				plugin.sceneViewport[1] + plugin.sceneViewport[3],
				GL_COLOR_BUFFER_BIT,
				config.sceneScalingMode().glFilter
			);
		} else {
			glBindFramebuffer(GL_FRAMEBUFFER, plugin.awtContext.getFramebuffer(false));
			glClearColor(0, 0, 0, 1);
			glClear(GL_COLOR_BUFFER_BIT);
		}

		plugin.drawUi(overlayColor);

		jobSystem.processPendingClientCallbacks(false);

		try {
			frameTimer.begin(Timer.SWAP_BUFFERS);
			plugin.awtContext.swapBuffers();
			frameTimer.end(Timer.SWAP_BUFFERS);
			drawManager.processDrawComplete(plugin::screenshot);
		} catch (RuntimeException ex) {
			// this is always fatal
			if (!plugin.canvas.isValid()) {
				// this might be AWT shutting down on VM shutdown, ignore it
				return;
			}

			log.error("Unable to swap buffers:", ex);
		}

		glBindFramebuffer(GL_FRAMEBUFFER, plugin.awtContext.getFramebuffer(false));

		frameTimer.end(Timer.DRAW_FRAME);
		frameTimer.end(Timer.RENDER_FRAME);
		frameTimer.endFrameAndReset();
		checkGLErrors();

		shouldRenderScene = false;
	}

	@Subscribe
	public void onGameStateChanged(GameStateChanged gameStateChanged) {
		GameState state = gameStateChanged.getGameState();
		if (state.getState() < GameState.LOADING.getState()) {
			// this is to avoid scene fbo blit when going from <loading to >=loading,
			// but keep it when doing >loading to loading
			sceneFboValid = false;
		}
	}

	@Override
	public void invalidateZone(Scene scene, int zx, int zz) {
		sceneManager.invalidateZone(scene, zx, zz);
	}

	@Override
	public void reloadScene() {
		if (sceneManager.isTopLevelValid() && client.getGameState().getState() >= GameState.LOGGED_IN.getState())
			sceneManager.reloadScene();
	}

	@Override
	public SceneContext getSceneContext() {
		return sceneManager.getSceneContext();
	}

	@Override
	public boolean isLoadingScene() {
		return sceneManager.isLoadingScene();
	}

	@Override
	public void loadScene(WorldView worldView, Scene scene) {
		try {
			sceneManager.loadScene(worldView, scene);
		} catch (OutOfMemoryError oom) {
			log.error(
				"Ran out of memory while generating scene data (32-bit: {}, low memory mode: {})",
				HDUtils.is32Bit(), plugin.useLowMemoryMode, oom
			);
			plugin.displayOutOfMemoryMessage();
			plugin.stopPlugin();
		} catch (Throwable ex) {
			log.error("Error while loading scene:", ex);
			plugin.stopPlugin();
		}
	}

	@Override
	public void despawnWorldView(WorldView worldView) {
		sceneManager.despawnWorldView(worldView);
	}

	@Override
	public void swapScene(Scene scene) {
		try {
			sceneManager.swapScene(scene);
		} catch (Throwable ex) {
			log.error("Error during swapScene:", ex);
			plugin.stopPlugin();
		}
	}
}

package rs117.hd.renderer.zone;

import javax.annotation.Nullable;
import net.runelite.api.*;
import rs117.hd.scene.SceneContext;

public class ZoneSceneContext extends SceneContext {
	public int totalReused;
	public int totalDeferred;
	public int totalMapZones;

	public ZoneSceneContext(
		Client client,
		WorldView worldView,
		Scene scene,
		int expandedMapLoadingChunks,
		@Nullable SceneContext previous
	) {
		super(client, scene, expandedMapLoadingChunks);
		if (worldView.getId() != -1) {
			sceneOffset = 0;
			sizeX = worldView.getSizeX();
			sizeZ = worldView.getSizeY();
		}
	}
}

package rs117.hd.renderer.zone;

import java.util.concurrent.ConcurrentLinkedDeque;
import lombok.SneakyThrows;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.*;
import rs117.hd.utils.jobs.Job;

import static org.lwjgl.opengl.GL33C.*;
import static rs117.hd.renderer.zone.ZoneRenderer.eboAlpha;

@Slf4j
public final class ZoneUploadJob extends Job {
	private static final ConcurrentLinkedDeque<ZoneUploadJob> POOL = new ConcurrentLinkedDeque<>();
	private static final ThreadLocal<ZoneUploader> THREAD_LOCAL_SCENE_UPLOADER =
		ThreadLocal.withInitial(() -> getInjector().getInstance(ZoneUploader.class));

	private static class ZoneUploader extends SceneUploader {
		ZoneUploadJob job;

		@SneakyThrows
		@Override
		protected void onBeforeProcessTile(Tile t, boolean isEstimate) {
			job.workerHandleCancel();
		}
	}

	private WorldViewContext viewContext;
	private ZoneSceneContext sceneContext;

	Zone zone;
	int x, z;
	float delay;

	@Override
	protected void onRun() throws InterruptedException {
		final ZoneUploader sceneUploader = THREAD_LOCAL_SCENE_UPLOADER.get();
		try {
			workerHandleCancel();

			sceneUploader.job = this;
			sceneUploader.setScene(sceneContext.scene);
			sceneUploader.estimateZoneSize(sceneContext, zone, x, z);

			if (zone.sizeO > 0 || zone.sizeA > 0) {
				workerHandleCancel();

				invokeClientCallback(isHighPriority(), this::mapZoneVertexBuffers);
				workerHandleCancel();

				sceneUploader.uploadZone(sceneContext, zone, x, z);
				workerHandleCancel();

				invokeClientCallback(isHighPriority(), this::unmapZoneVertexBuffers);
			} else {
				// The zone should not be left uninitialized, as this will prevent drawing anything within it
				zone.initialized = true;
			}
		} finally {
			sceneUploader.clear();
		}
	}

	private void mapZoneVertexBuffers() {
		try {
			VBO o = null, a = null;
			int sz = zone.sizeO * Zone.VERT_SIZE * 3;
			if (sz > 0) {
				o = new VBO(sz);
				o.initialize(GL_STATIC_DRAW);
				o.map();
			}

			sz = zone.sizeA * Zone.VERT_SIZE * 3;
			if (sz > 0) {
				a = new VBO(sz);
				a.initialize(GL_STATIC_DRAW);
				a.map();
			}

			zone.initialize(o, a, eboAlpha);
			zone.setMetadata(viewContext, sceneContext, x, z);
		} catch (Throwable ex) {
			log.warn(
				"Caught exception whilst processing zone [{}, {}] worldId [{}] group priority [{}] cancelling...\n",
				x,
				z,
				viewContext.worldViewId,
				isHighPriority(),
				ex
			);
			cancel();
		}
	}

	private void unmapZoneVertexBuffers() {
		zone.unmap();
		zone.initialized = true;
	}

	@Override
	protected void onCancel() {
		if (viewContext.zones[x][z] != zone)
			viewContext.pendingCull.add(zone);

		// Avoid holding a reference to the context after the job is done
		viewContext = null;
		sceneContext = null;
	}

	@Override
	protected void onReleased() {
		viewContext = null;
		sceneContext = null;
		zone = null;
		delay = -1.0f;
		assert !POOL.contains(this) : "Task is already in pool";
		POOL.add(this);
	}

	public static ZoneUploadJob build(WorldViewContext viewContext, ZoneSceneContext sceneContext, Zone zone, int x, int z) {
		assert viewContext != null : "WorldViewContext cant be null";
		assert sceneContext != null : "ZoneSceneContext cant be null";
		assert zone != null : "Zone cant be null";
		assert !zone.initialized : "Zone is already initialized";

		ZoneUploadJob newTask = POOL.poll();
		if (newTask == null)
			newTask = new ZoneUploadJob();
		newTask.viewContext = viewContext;
		newTask.sceneContext = sceneContext;
		newTask.zone = zone;
		newTask.x = x;
		newTask.z = z;
		newTask.isReleased = false;

		return newTask;
	}

	@Override
	public String toString() {
		return String.format(
			"%s: worldViewId=%s, x=%d, z=%d",
			super.toString(),
			viewContext != null ? viewContext.worldViewId : "null",
			x, z
		);
	}

	@Override
	@SuppressWarnings("deprecation")
	protected void finalize() {
		log.debug("ZoneUploadJob finalized, it should have been pooled? - {}", this);
	}
}

package rs117.hd.scene;

import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonToken;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import javax.annotation.Nonnull;
import javax.inject.Inject;
import javax.inject.Singleton;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.*;
import net.runelite.client.callback.ClientThread;
import rs117.hd.HdPlugin;
import rs117.hd.scene.areas.Area;
import rs117.hd.utils.FileWatcher;
import rs117.hd.utils.GsonUtils;
import rs117.hd.utils.Props;
import rs117.hd.utils.ResourcePath;

import static rs117.hd.utils.ResourcePath.path;

@Slf4j
@Singleton
public class AreaManager {
	private static final ResourcePath AREA_PATH = Props
		.getFile("rlhd.area-path", () -> path(AreaManager.class, "areas.json"));

	@Inject
	private Client client;

	@Inject
	private ClientThread clientThread;

	@Inject
	private HdPlugin plugin;

	@Inject
	private EnvironmentManager environmentManager;

	@Inject
	private TileOverrideManager tileOverrideManager;

	@Inject
	private ModelOverrideManager modelOverrideManager;

	@Inject
	private LightManager lightManager;

	private FileWatcher.UnregisterCallback fileWatcher;

	public static Area[] AREAS = new Area[0];

	public Area[] areasWithAreaHiding = new Area[0];

	public void startUp() {
		fileWatcher = AREA_PATH.watch((path, first) -> {
			try {
				Area[] areas = path.loadJson(plugin.getGson(), Area[].class);
				if (areas == null)
					throw new IOException("Empty or invalid: " + path);

				clientThread.invoke(() -> {
					AREAS = Arrays.copyOf(areas, areas.length + 2);
					AREAS[AREAS.length - 2] = Area.ALL;
					AREAS[AREAS.length - 1] = Area.NONE;

					ArrayList<Area> areasWithAreaHiding = new ArrayList<>();
					for (Area area : areas) {
						area.normalize();
						if (area.hideOtherAreas)
							areasWithAreaHiding.add(area);
					}
					this.areasWithAreaHiding = areasWithAreaHiding.toArray(Area[]::new);

					Area.OVERWORLD = getArea("OVERWORLD");

					log.debug("Loaded {} areas", areas.length);

					if (!first) {
						// Reload everything which depends on area definitions
						plugin.renderer.clearCaches();
						tileOverrideManager.shutDown();
						modelOverrideManager.shutDown();
						lightManager.shutDown();
						environmentManager.shutDown();

						tileOverrideManager.startUp();
						modelOverrideManager.startUp();
						lightManager.startUp();
						environmentManager.startUp();

						// Force reload the scene to reapply area hiding
						if (client.getGameState() == GameState.LOGGED_IN)
							client.setGameState(GameState.LOADING);
					}
				});
			} catch (IOException ex) {
				log.error("Failed to load areas:", ex);
			}
		});
	}

	public void shutDown() {
		if (fileWatcher != null)
			fileWatcher.unregister();
		fileWatcher = null;
		AREAS = new Area[0];
	}

	@Nonnull
	public Area getArea(String name) {
		for (Area area : AREAS)
			if (name.equals(area.name))
				return area;
		return Area.NONE;
	}

	@Slf4j
	public static class Adapter extends TypeAdapter<Area> {
		@Override
		public Area read(JsonReader in) throws IOException {
			var token = in.peek();
			if (token == JsonToken.NULL)
				return null;

			if (token == JsonToken.BEGIN_OBJECT)
				throw new IllegalStateException(
					"This is only meant for mapping area names to existing areas, not parse new ones. Unexpected token " + token + " at "
					+ GsonUtils.location(in));

			if (token != JsonToken.STRING) {
				log.warn("Expected an area name instead of {} at {}", token, GsonUtils.location(in), new Throwable());
				return Area.NONE;
			}

			var str = in.nextString();
			for (Area area : AREAS)
				if (str.equals(area.name))
					return area;

			log.warn("No area exists with the name '{}' at {}", str, GsonUtils.location(in), new Throwable());
			return Area.NONE;
		}

		@Override
		public void write(JsonWriter out, Area area) throws IOException {
			if (area == null) {
				out.nullValue();
			} else {
				out.value(area.name);
			}
		}
	}
}

/*
 * Copyright (c) 2021, 117 <https://twitter.com/117scape>
 * Copyright (c) 2022, Hooder <ahooder@protonmail.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package rs117.hd.scene.areas;

import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonToken;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.coords.*;
import rs117.hd.scene.AreaManager;
import rs117.hd.utils.GsonUtils;

import static net.runelite.api.Constants.*;
import static rs117.hd.utils.MathUtils.*;

public class AABB {
	public final int minX;
	public final int minY;
	public final int minZ;
	public final int maxX;
	public final int maxY;
	public final int maxZ;

	public AABB(int x, int y) {
		minX = maxX = x;
		minY = maxY = y;
		minZ = Integer.MIN_VALUE;
		maxZ = Integer.MAX_VALUE;
	}

	public AABB(int x, int y, int z) {
		minX = maxX = x;
		minY = maxY = y;
		minZ = maxZ = z;
	}

	public AABB(int x1, int y1, int x2, int y2) {
		minX = min(x1, x2);
		minY = min(y1, y2);
		minZ = Integer.MIN_VALUE;
		maxX = max(x1, x2);
		maxY = max(y1, y2);
		maxZ = Integer.MAX_VALUE;
	}

	public AABB(int x1, int y1, int x2, int y2, int z1) {
		minX = min(x1, x2);
		minY = min(y1, y2);
		maxX = max(x1, x2);
		maxY = max(y1, y2);
		minZ = maxZ = z1;
	}

	public AABB(int x1, int y1, int z1, int x2, int y2, int z2) {
		minX = min(x1, x2);
		minY = min(y1, y2);
		minZ = min(z1, z2);
		maxX = max(x1, x2);
		maxY = max(y1, y2);
		maxZ = max(z1, z2);
	}

	public AABB(int[] point) {
		this(point[0], point[1], point[2]);
	}

	public AABB(int[] from, int[] to) {
		this(from[0], from[1], from[2], to[0], to[1], to[2]);
	}

	public static AABB fromRegionId(int regionId) {
		int minX = (regionId >>> 8) << 6;
		int minY = (regionId & 0xFF) << 6;
		int maxX = minX + REGION_SIZE - 1;
		int maxY = minY + REGION_SIZE - 1;
		return new AABB(minX, minY, maxX, maxY);
	}

	public AABB onPlane(int plane) {
		return new AABB(minX, minY, plane, maxX, maxY, plane);
	}

	public AABB expandTo(int[] point) {
		return new AABB(
			min(minX, point[0]),
			min(minY, point[1]),
			min(minZ, point[2]),
			max(maxX, point[0]),
			max(maxY, point[1]),
			max(maxZ, point[2])
		);
	}

	public boolean hasZ() {
		return minZ != Integer.MIN_VALUE || maxZ != Integer.MAX_VALUE;
	}

	public boolean isPoint() {
		return
			minX == maxX &&
			minY == maxY &&
			(!hasZ() || minZ == maxZ);
	}

	public boolean isVolume() {
		return !isPoint();
	}

	public boolean contains(int... worldPos) {
		assert worldPos.length >= 2 : "Expected X, Y & possibly a plane, got: " + Arrays.toString(worldPos);
		return
			minX <= worldPos[0] && worldPos[0] <= maxX &&
			minY <= worldPos[1] && worldPos[1] <= maxY &&
			(worldPos.length < 3 || minZ <= worldPos[2] && worldPos[2] <= maxZ);
	}

	public boolean contains(WorldPoint location) {
		return contains(location.getX(), location.getY(), location.getPlane());
	}

	public boolean contains(AABB other) {
		return
			contains(other.minX, other.minY, other.minZ) &&
			contains(other.maxX, other.maxY, other.maxZ);
	}

	public boolean intersects(int minX, int minY, int maxX, int maxY) {
		return
			minX <= this.maxX && maxX >= this.minX &&
			minY <= this.maxY && maxY >= this.minY;
	}

	public boolean intersects(int minX, int minY, int minZ, int maxX, int maxY, int maxZ) {
		return
			minX <= this.maxX && maxX >= this.minX &&
			minY <= this.maxY && maxY >= this.minY &&
			minZ <= this.maxZ && maxZ >= this.minZ;
	}

	public boolean intersects(AABB other) {
		return intersects(
			other.minX,
			other.minY,
			other.minZ,
			other.maxX,
			other.maxY,
			other.maxZ
		);
	}

	public boolean intersects(AABB... aabbs) {
		for (var aabb : aabbs)
			if (intersects(aabb))
				return true;
		return false;
	}

	public float[] getCenter() {
		return new float[] {
			(minX + maxX) / 2.f,
			(minY + maxY) / 2.f,
			(minZ + maxZ) / 2.f
		};
	}

	@Override
	public String toString() {
		if (hasZ())
			return String.format("AABB{min=(%d,%d,%d), max=(%d,%d,%d)}", minX, minY, minZ, maxX, maxY, maxZ);
		return String.format("AABB{min=(%d,%d), max=(%d,%d)}", minX, minY, maxX, maxY);
	}

	public String toArgs() {
		if (hasZ()) {
			if (isPoint())
				return String.format("[ %d, %d, %d ]", minX, minY, minZ);
			if (minZ == maxZ)
				return String.format("[ %d, %d, %d, %d, %d ]", minX, minY, maxX, maxY, minZ);
			return String.format("[ %d, %d, %d, %d, %d, %d ]", minX, minY, minZ, maxX, maxY, maxZ);
		}
		if (isPoint())
			return String.format("[ %d, %d ]", minX, minY);
		return String.format("[ %d, %d, %d, %d ]", minX, minY, maxX, maxY);
	}

	@Override
	public boolean equals(Object obj) {
		if (!(obj instanceof AABB))
			return false;

		AABB other = (AABB) obj;
		return
			other.minX == minX && other.maxX == maxX &&
			other.minY == minY && other.maxY == maxY &&
			other.minZ == minZ && other.maxZ == maxZ;
	}

	@Slf4j
	public static class ArrayAdapter extends TypeAdapter<AABB[]> {
		@Override
		public AABB[] read(JsonReader in) throws IOException {
			in.beginArray();
			ArrayList<AABB> list = new ArrayList<>();
			outer:
			while (in.hasNext() && in.peek() != JsonToken.END_ARRAY) {
				if (in.peek() == JsonToken.NULL) {
					in.skipValue();
					continue;
				}

				if (in.peek() == JsonToken.NUMBER) {
					log.warn("AABBs are specified by two or more numbers. Did you forget to add an array at {}?", GsonUtils.location(in));
					continue;
				}

				if (in.peek() == JsonToken.STRING) {
					String name = in.nextString();
					for (var area : AreaManager.AREAS) {
						if (name.equals(area.name)) {
							Collections.addAll(list, area.aabbs);
							continue outer;
						}
					}

					log.warn("No area exists with the name '{}' at {}", name, GsonUtils.location(in), new Throwable());
				}

				in.beginArray();
				int[] ints = new int[6];
				int i = 0;
				while (in.hasNext()) {
					switch (in.peek()) {
						case NUMBER:
							if (i >= ints.length)
								throw new IOException(
									"Too many numbers in AABB entry (> " + ints.length + ") at " + GsonUtils.location(in));
							ints[i++] = in.nextInt();
						case END_ARRAY:
							break;
						case NULL:
							in.skipValue();
							continue;
						default:
							throw new IOException("Malformed AABB entry. Unexpected token: " + in.peek() + " at " + GsonUtils.location(in));
					}
				}
				in.endArray();

				switch (i) {
					case 1:
						log.warn("AABBs are specified by two or more numbers, only one was provided at {}", GsonUtils.location(in));
						break;
					case 2:
						list.add(new AABB(ints[0], ints[1]));
						break;
					case 3:
						list.add(new AABB(ints[0], ints[1], ints[2]));
						break;
					case 4:
						list.add(new AABB(ints[0], ints[1], ints[2], ints[3]));
						break;
					case 5:
						list.add(new AABB(ints[0], ints[1], ints[2], ints[3], ints[4]));
						break;
					case 6:
						list.add(new AABB(ints[0], ints[1], ints[2], ints[3], ints[4], ints[5]));
						break;
				}
			}
			in.endArray();
			return list.toArray(AABB[]::new);
		}

		@Override
		public void write(JsonWriter out, AABB[] aabbs) throws IOException {
			if (aabbs == null || aabbs.length == 0) {
				out.nullValue();
				return;
			}

			out.beginArray();
			for (AABB aabb : aabbs) {
				// Compact JSON array
				StringBuilder sb = new StringBuilder();
				sb.append("[ ").append(aabb.minX);
				sb.append(", ").append(aabb.minY);
				if (aabb.hasZ())
					sb.append(", ").append(aabb.minZ);
				if (aabb.isVolume()) {
					sb.append(", ").append(aabb.maxX);
					sb.append(", ").append(aabb.maxY);
					if (aabb.hasZ())
						sb.append(", ").append(aabb.maxZ);
				}
				sb.append(" ]");
				out.jsonValue(sb.toString());
			}
			out.endArray();
		}
	}
}

package rs117.hd.scene.areas;

import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import java.util.ArrayList;
import java.util.Collections;
import rs117.hd.scene.AreaManager;

public class Area {
	public static final Area NONE = new Area("NONE", 0, 0, 0, 0);
	public static final Area ALL = new Area("ALL", Integer.MIN_VALUE, Integer.MIN_VALUE, Integer.MAX_VALUE, Integer.MAX_VALUE);
	public static Area OVERWORLD = NONE;

	public String name;
	public boolean hideOtherAreas;
	public boolean fillGaps = true;

	public String[] areas;
	public int[] regions;
	@JsonAdapter(RegionBox.Adapter.class)
	public RegionBox[] regionBoxes;
	@JsonAdapter(AABB.ArrayAdapter.class)
	@SerializedName("aabbs")
	public AABB[] rawAabbs;
	@JsonAdapter(AABB.ArrayAdapter.class)
	public AABB[] unhideAreas = {};

	public transient AABB[] aabbs;
	private transient boolean normalized;

	public Area(String name) {
		this.name = name;
	}

	public Area(String name, int x1, int y1, int x2, int y2) {
		this(name);
		aabbs = new AABB[] { new AABB(x1, y1, x2, y2) };
	}

	public void normalize() {
		if (normalized)
			return;
		normalized = true;

		ArrayList<AABB> aabbs = new ArrayList<>();
		if (rawAabbs != null)
			Collections.addAll(aabbs, rawAabbs);
		if (regions != null)
			for (int regionId : regions)
				aabbs.add(AABB.fromRegionId(regionId));
		if (regionBoxes != null)
			for (var box : regionBoxes)
				aabbs.add(box.toAabb());
		if (areas != null) {
			for (String area : areas) {
				for (Area other : AreaManager.AREAS) {
					if (area.equals(other.name)) {
						other.normalize();
						Collections.addAll(aabbs, other.aabbs);
						break;
					}
				}
			}
		}

		this.aabbs = aabbs.toArray(AABB[]::new);

		if (unhideAreas == null)
			unhideAreas = new AABB[0];
	}

	public boolean containsPoint(boolean includeUnhiding, int... worldPoint) {
		for (var aabb : aabbs)
			if (aabb.contains(worldPoint))
				return true;
		if (includeUnhiding)
			for (var aabb : unhideAreas)
				if (aabb.contains(worldPoint))
					return true;
		return false;
	}

	public boolean containsPoint(int... worldPoint) {
		return containsPoint(true, worldPoint);
	}

	public boolean intersects(boolean includeUnhiding, int minX, int minY, int maxX, int maxY) {
		for (AABB aabb : aabbs)
			if (aabb.intersects(minX, minY, maxX, maxY))
				return true;
		if (includeUnhiding)
			for (var aabb : unhideAreas)
				if (aabb.intersects(minX, minY, maxX, maxY))
					return true;
		return false;
	}

	public boolean intersects(Area otherArea) {
		if (otherArea == null)
			return false;
		return intersects(otherArea.aabbs);
	}

	public boolean intersects(AABB... otherAabbs) {
		for (AABB aabb : aabbs)
			if (aabb.intersects(otherAabbs))
				return true;
		return false;
	}

	@Override
	public String toString() {
		return name;
	}
}

package rs117.hd.scene.areas;

import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonToken;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.ArrayList;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import rs117.hd.utils.GsonUtils;

import static net.runelite.api.Constants.*;

@RequiredArgsConstructor
public class RegionBox {
	public final int from, to;
	public final int fromPlane, toPlane;

	public RegionBox(int regionId) {
		this(regionId, regionId);
	}

	public RegionBox(int from, int to) {
		this(from, to, 0, MAX_Z - 1);
	}

	public RegionBox(int from, int to, int plane) {
		this(from, to, plane, plane);
	}

	public AABB toAabb() {
		int x1 = from >>> 8;
		int y1 = from & 0xFF;
		int x2 = to >>> 8;
		int y2 = to & 0xFF;
		if (x1 > x2) {
			int temp = x1;
			x1 = x2;
			x2 = temp;
		}
		if (y1 > y2) {
			int temp = y1;
			y1 = y2;
			y2 = temp;
		}
		return new AABB(
			(x1) << 6,
			(y1) << 6,
			fromPlane,
			((x2) + 1 << 6) - 1,
			((y2) + 1 << 6) - 1,
			toPlane
		);
	}

	@Slf4j
	public static class Adapter extends TypeAdapter<RegionBox[]> {
		@Override
		public RegionBox[] read(JsonReader in) throws IOException {
			in.beginArray();
			ArrayList<RegionBox> list = new ArrayList<>();
			while (in.hasNext() && in.peek() != JsonToken.END_ARRAY) {
				if (in.peek() == JsonToken.NULL) {
					in.skipValue();
					continue;
				}

				in.beginArray();
				int[] ints = new int[4];
				int i = 0;
				while (in.hasNext()) {
					switch (in.peek()) {
						case NUMBER:
							if (i >= ints.length)
								throw new IOException(
									"Too many numbers in RegionBox entry (> " + ints.length + ") at " + GsonUtils.location(in));
							ints[i++] = in.nextInt();
						case END_ARRAY:
							break;
						case NULL:
							in.skipValue();
							continue;
						default:
							throw new IOException(
								"Malformed RegionBox entry. Unexpected token: " + in.peek() + " at " + GsonUtils.location(in));
					}
				}
				in.endArray();

				switch (i) {
					case 1:
						list.add(new RegionBox(ints[0]));
						break;
					case 2:
						list.add(new RegionBox(ints[0], ints[1]));
						break;
					case 3:
						list.add(new RegionBox(ints[0], ints[1], ints[2]));
						break;
					case 4:
						list.add(new RegionBox(ints[0], ints[1], ints[2], ints[3]));
						break;
				}
			}
			in.endArray();
			return list.toArray(new RegionBox[0]);
		}

		@Override
		public void write(JsonWriter out, RegionBox[] aabbs) throws IOException {
			if (aabbs == null || aabbs.length == 0) {
				out.nullValue();
				return;
			}

			out.beginArray();
			for (RegionBox box : aabbs) {
				// Compact JSON array
				if (box.fromPlane == 0 && box.toPlane == MAX_Z - 1) {
					if (box.from == box.to) {
						out.jsonValue(String.format("[ %d ]", box.from));
					} else {
						out.jsonValue(String.format("[ %d, %d ]", box.from, box.to));
					}
				} else if (box.fromPlane == box.toPlane) {
					out.jsonValue(String.format("[ %d, %d, %d ]", box.from, box.to, box.fromPlane));
				} else {
					out.jsonValue(String.format("[ %d, %d, %d, %d ]", box.from, box.to, box.fromPlane, box.toPlane));
				}
			}
			out.endArray();
		}
	}
}

/*
 * Copyright (c) 2021, 117 <https://twitter.com/117scape>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package rs117.hd.scene;

import java.io.IOException;
import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import java.util.Objects;
import javax.annotation.Nonnull;
import javax.inject.Inject;
import javax.inject.Singleton;
import lombok.Getter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.*;
import net.runelite.client.callback.ClientThread;
import rs117.hd.HdPlugin;
import rs117.hd.HdPluginConfig;
import rs117.hd.config.DefaultSkyColor;
import rs117.hd.scene.environments.Environment;
import rs117.hd.utils.FileWatcher;
import rs117.hd.utils.Props;
import rs117.hd.utils.ResourcePath;

import static rs117.hd.utils.MathUtils.*;
import static rs117.hd.utils.ResourcePath.path;

@Slf4j
@Singleton
public class EnvironmentManager {
	private static final ResourcePath ENVIRONMENTS_PATH = Props
		.getFile("rlhd.environments-path", () -> path(EnvironmentManager.class, "environments.json"));

	@Inject
	private Client client;

	@Inject
	private ClientThread clientThread;

	@Inject
	private HdPlugin plugin;

	@Inject
	private HdPluginConfig config;

	private static final float TRANSITION_DURATION = 3; // seconds
	// distance in tiles to skip transition (e.g. entering cave, teleporting)
	// walking across a loading line causes a movement of 40-41 tiles
	private static final int SKIP_TRANSITION_DISTANCE = 41;

	// when the current transition began, relative to plugin startup
	private boolean transitionComplete = true;
	private double transitionStartTime = 0;
	private int[] previousPosition = new int[3];

	private float[] startFogColor = new float[] { 0, 0, 0 };
	public float[] currentFogColor = new float[] { 0, 0, 0 };
	private float[] targetFogColor = new float[] { 0, 0, 0 };

	private float[] startWaterColor = new float[] { 0, 0, 0 };
	public float[] currentWaterColor = new float[] { 0, 0, 0 };
	private float[] targetWaterColor = new float[] { 0, 0, 0 };

	private float startFogDepth = 0;
	public float currentFogDepth = 0;
	private float targetFogDepth = 0;

	private float startAmbientStrength = 0f;
	public float currentAmbientStrength = 0f;
	private float targetAmbientStrength = 0f;

	private float[] startAmbientColor = new float[] { 0, 0, 0 };
	public float[] currentAmbientColor = new float[] { 0, 0, 0 };
	private float[] targetAmbientColor = new float[] { 0, 0, 0 };

	private float startDirectionalStrength = 0f;
	public float currentDirectionalStrength = 0f;
	private float targetDirectionalStrength = 0f;

	private float[] startUnderwaterCausticsColor = new float[] { 0, 0, 0 };
	public float[] currentUnderwaterCausticsColor = new float[] { 0, 0, 0 };
	private float[] targetUnderwaterCausticsColor = new float[] { 0, 0, 0 };

	private float startUnderwaterCausticsStrength = 1f;
	public float currentUnderwaterCausticsStrength = 1f;
	private float targetUnderwaterCausticsStrength = 1f;

	private float[] startDirectionalColor = new float[] { 0, 0, 0 };
	public float[] currentDirectionalColor = new float[] { 0, 0, 0 };
	private float[] targetDirectionalColor = new float[] { 0, 0, 0 };

	private float startUnderglowStrength = 0f;
	public float currentUnderglowStrength = 0f;
	private float targetUnderglowStrength = 0f;

	private float[] startUnderglowColor = new float[] { 0, 0, 0 };
	public float[] currentUnderglowColor = new float[] { 0, 0, 0 };
	private float[] targetUnderglowColor = new float[] { 0, 0, 0 };

	private float startGroundFogStart = 0f;
	public float currentGroundFogStart = 0f;
	private float targetGroundFogStart = 0f;

	private float startGroundFogEnd = 0f;
	public float currentGroundFogEnd = 0f;
	private float targetGroundFogEnd = 0f;

	private float startGroundFogOpacity = 0f;
	public float currentGroundFogOpacity = 0f;
	private float targetGroundFogOpacity = 0f;

	private final float[] startSunAngles = { 0, 0 };
	public final float[] currentSunAngles = { 0, 0 };
	private final float[] targetSunAngles = { 0, 0 };

	private float startWindAngle = 0f;
	public float currentWindAngle = 0f;
	private float targetWindAngle = 0f;

	private float startWindSpeed = 0f;
	public float currentWindSpeed = 0f;
	private float targetWindSpeed = 0f;

	private float startWindStrength = 0f;
	public float currentWindStrength = 0f;
	private float targetWindStrength = 0f;

	private float startWindCeiling = 0f;
	public float currentWindCeiling = 0f;
	private float targetWindCeiling = 0f;

	private boolean lightningEnabled = false;
	private boolean forceNextTransition = false;

	private Environment[] environments;
	private FileWatcher.UnregisterCallback fileWatcher;

	@Nonnull
	private Environment currentEnvironment = Environment.NONE;

	public void startUp() {
		fileWatcher = ENVIRONMENTS_PATH.watch((path, first) -> {
			try {
				environments = path.loadJson(plugin.getGson(), Environment[].class);
				if (environments == null)
					throw new IOException("Empty or invalid: " + path);
				log.debug("Loaded {} environments", environments.length);

				if (!config.legacyTobEnvironment()) {
					var legacyEnvs = List.of("TOB_ROOM_VAULT_LEGACY", "THEATRE_OF_BLOOD_LEGACY");
					environments = Arrays.stream(environments)
						.filter(env -> env.key == null || !legacyEnvs.contains(env.key))
						.toArray(Environment[]::new);
				}

				HashMap<String, Environment> map = new HashMap<>();
				for (var env : environments)
					if (env.key != null)
						map.put(env.key, env);

				Environment.OVERWORLD = map.getOrDefault("OVERWORLD", Environment.DEFAULT);
				Environment.AUTUMN = map.getOrDefault("AUTUMN", Environment.DEFAULT);
				Environment.WINTER = map.getOrDefault("WINTER", Environment.DEFAULT);

				for (var env : environments)
					env.normalize();

				clientThread.invoke(() -> {
					// Force instant transition during development
					if (!first)
						reset();

					if (client.getGameState().getState() >= GameState.LOGGED_IN.getState() && plugin.getSceneContext() != null)
						loadSceneEnvironments(plugin.getSceneContext());
				});
			} catch (IOException ex) {
				log.error("Failed to load environments:", ex);
			}
		});
	}

	public void shutDown() {
		if (fileWatcher != null)
			fileWatcher.unregister();
		fileWatcher = null;
		environments = null;
		reset();
	}

	public void reset() {
		currentEnvironment = Environment.NONE;
		forceNextTransition = false;
	}

	public void reload() {
		var previous = currentEnvironment;
		shutDown();
		startUp();
		forceNextTransition = true;
		currentEnvironment = previous;
	}

	/**
	 * Updates variables used in transition effects
	 *
	 * @param sceneContext to possible environments from
	 */
	public void update(SceneContext sceneContext) {
		assert client.isClientThread();

		int[] focalPoint = sceneContext.localToWorld(
			plugin.cameraFocalPoint[0],
			plugin.cameraFocalPoint[1],
			client.getPlane()
		);

		// skip the transitional fade if the player has moved too far
		// since the previous frame. results in an instant transition when
		// teleporting, entering dungeons, etc.
		int tileChange = (int) max(abs(subtract(vec(focalPoint), vec(previousPosition))));
		previousPosition = focalPoint;

		boolean skipTransition = tileChange >= SKIP_TRANSITION_DISTANCE;
		for (var environment : sceneContext.environments) {
			if (environment.area.containsPoint(focalPoint)) {
				changeEnvironment(environment, skipTransition);
				break;
			}
		}

		updateTargetSkyColor(); // Update every frame, since other plugins may control it

		if (transitionComplete) {
			// Always write fog and water color, since they're affected by lightning
			currentFogColor = targetFogColor;
			currentWaterColor = targetWaterColor;
		} else {
			// interpolate between start and target values
			float t = smoothstep(0, 1, (float) (plugin.elapsedTime - transitionStartTime) / TRANSITION_DURATION);
			if (t >= 1)
				transitionComplete = true;
			currentFogColor = mix(startFogColor, targetFogColor, t);
			currentWaterColor = mix(startWaterColor, targetWaterColor, t);
			currentFogDepth = mix(startFogDepth, targetFogDepth, t);
			currentAmbientStrength = mix(startAmbientStrength, targetAmbientStrength, t);
			currentAmbientColor = mix(startAmbientColor, targetAmbientColor, t);
			currentDirectionalStrength = mix(startDirectionalStrength, targetDirectionalStrength, t);
			currentDirectionalColor = mix(startDirectionalColor, targetDirectionalColor, t);
			currentUnderglowStrength = mix(startUnderglowStrength, targetUnderglowStrength, t);
			currentUnderglowColor = mix(startUnderglowColor, targetUnderglowColor, t);
			currentGroundFogStart = mix(startGroundFogStart, targetGroundFogStart, t);
			currentGroundFogEnd = mix(startGroundFogEnd, targetGroundFogEnd, t);
			currentGroundFogOpacity = mix(startGroundFogOpacity, targetGroundFogOpacity, t);
			for (int i = 0; i < 2; i++)
				currentSunAngles[i] = mix(startSunAngles[i], targetSunAngles[i], t);
			currentUnderwaterCausticsColor = mix(startUnderwaterCausticsColor, targetUnderwaterCausticsColor, t);
			currentUnderwaterCausticsStrength = mix(startUnderwaterCausticsStrength, targetUnderwaterCausticsStrength, t);
			currentWindAngle = mix(startWindAngle, targetWindAngle, t);
			currentWindSpeed = mix(startWindSpeed, targetWindSpeed, t);
			currentWindStrength = mix(startWindStrength, targetWindStrength, t);
			currentWindCeiling = mix(startWindCeiling, targetWindCeiling, t);
		}

		updateLightning();
	}

	/**
	 * Updates variables used in transition effects
	 *
	 * @param newEnvironment the new environment to transition to
	 * @param skipTransition whether the transition should be done instantly
	 */
	private void changeEnvironment(Environment newEnvironment, boolean skipTransition) {
		// Skip changing the environment unless the transition is forced, since reapplying
		// the overworld environment is required when switching between seasonal themes
		if (currentEnvironment == newEnvironment && !forceNextTransition)
			return;

		if (currentEnvironment == Environment.NONE) {
			skipTransition = true;
		} else if (forceNextTransition) {
			forceNextTransition = false;
			skipTransition = false;
		}

		if (currentEnvironment.instantTransition || newEnvironment.instantTransition)
			skipTransition = true;

		log.debug("changing environment from {} to {} (instant: {})", currentEnvironment, newEnvironment, skipTransition);
		currentEnvironment = newEnvironment;
		transitionComplete = false;
		transitionStartTime = plugin.elapsedTime - (skipTransition ? TRANSITION_DURATION : 0);

		// Start transitioning from the current values
		startFogColor = currentFogColor;
		startWaterColor = currentWaterColor;
		startFogDepth = currentFogDepth;
		startAmbientStrength = currentAmbientStrength;
		startAmbientColor = currentAmbientColor;
		startDirectionalStrength = currentDirectionalStrength;
		startDirectionalColor = currentDirectionalColor;
		startUnderglowStrength = currentUnderglowStrength;
		startUnderglowColor = currentUnderglowColor;
		startGroundFogStart = currentGroundFogStart;
		startGroundFogEnd = currentGroundFogEnd;
		startGroundFogOpacity = currentGroundFogOpacity;
		startUnderwaterCausticsColor = currentUnderwaterCausticsColor;
		startUnderwaterCausticsStrength = currentUnderwaterCausticsStrength;
		startWindAngle = currentWindAngle;
		startWindSpeed = currentWindSpeed;
		startWindStrength = currentWindStrength;
		startWindCeiling = currentWindCeiling;
		for (int i = 0; i < 2; i++)
			startSunAngles[i] = mod(currentSunAngles[i], TWO_PI);

		updateTargetSkyColor();

		var env = getCurrentEnvironment();
		targetFogDepth = env.fogDepth;
		targetGroundFogStart = env.groundFogStart;
		targetGroundFogEnd = env.groundFogEnd;
		targetGroundFogOpacity = env.groundFogOpacity;
		lightningEnabled = env.lightningEffects;

		var overworldEnv = getOverworldEnvironment();
		float[] sunAngles = env.sunAngles;
		if (sunAngles == null)
			sunAngles = Objects.requireNonNullElse(overworldEnv.sunAngles, Environment.DEFAULT_SUN_ANGLES);
		copyTo(targetSunAngles, sunAngles);

		if (!config.atmosphericLighting() && !env.force)
			env = overworldEnv;
		targetAmbientStrength = env.ambientStrength;
		targetAmbientColor = env.ambientColor;
		targetDirectionalStrength = env.directionalStrength;
		targetDirectionalColor = env.directionalColor;
		targetUnderglowStrength = env.underglowStrength;
		targetUnderglowColor = env.underglowColor;
		targetUnderwaterCausticsColor = env.waterCausticsColor;
		targetUnderwaterCausticsStrength = env.waterCausticsStrength;
		targetWindAngle = env.windAngle;
		targetWindSpeed = env.windSpeed;
		targetWindStrength = env.windStrength;
		targetWindCeiling = env.windCeiling;

		// Prevent transitions from taking the long way around
		for (int i = 0; i < 2; i++) {
			float diff = startSunAngles[i] - targetSunAngles[i];
			if (abs(diff) > PI)
				targetSunAngles[i] += TWO_PI * sign(diff);
		}
	}

	public void updateTargetSkyColor() {
		Environment env = getCurrentEnvironment();

		if (env.fogColor == null || env.allowSkyOverride && config.overrideSky()) {
			DefaultSkyColor sky = config.defaultSkyColor();
			targetFogColor = sky.getRgb(client);
			if (sky == DefaultSkyColor.OSRS)
				sky = DefaultSkyColor.DEFAULT;
			targetWaterColor = sky.getRgb(client);
		} else {
			targetFogColor = targetWaterColor = env.fogColor;
		}

		// Override with decoupled water/sky color if present
		if (env.waterColor != null) {
			targetWaterColor = env.waterColor;
		} else if (config.decoupleSkyAndWaterColor()) {
			targetWaterColor = DefaultSkyColor.DEFAULT.getRgb(client);
		}
	}

	/**
	 * Figures out which Areas exist in the current scene and
	 * adds them to lists for easy access.
	 */
	public void loadSceneEnvironments(SceneContext sceneContext) {
		log.debug("Loading environments for scene: {}", sceneContext.sceneBounds);

		sceneContext.environments.clear();
		for (var environment : environments) {
			if (sceneContext.sceneBounds.intersects(environment.area.aabbs)) {
				log.debug("Added environment: {}", environment);
				sceneContext.environments.add(environment);
			}
		}

		// Fall back to the default environment
		sceneContext.environments.add(Environment.DEFAULT);
	}

	/* lightning */
	private static final float[] LIGHTNING_COLOR = new float[]{.25f, .25f, .25f};
	private static final float NEW_LIGHTNING_BRIGHTNESS = 7f;
	private static final float LIGHTNING_FADE_SPEED = 80f; // brightness units per second
	private static final float MIN_LIGHTNING_INTERVAL = 5.5f;
	private static final float MAX_LIGHTNING_INTERVAL = 17f;
	private static final float QUICK_LIGHTNING_CHANCE = .5f;
	private static final float MIN_QUICK_LIGHTNING_INTERVAL = .04f;
	private static final float MAX_QUICK_LIGHTNING_INTERVAL = .15f;

	@Getter
	private float lightningBrightness = 0f;
	private double nextLightningTime = -1;

	/**
	 * Updates lightning variables and sets water reflection and sky
	 * colors during lightning flashes.
	 */
	void updateLightning() {
		if (lightningBrightness > 0) {
			float brightnessChange = plugin.deltaTime * LIGHTNING_FADE_SPEED;
			lightningBrightness = max(lightningBrightness - brightnessChange, 0);
		}

		if (nextLightningTime == -1) {
			generateNextLightningTime();
			return;
		}
		if (plugin.elapsedTime > nextLightningTime) {
			lightningBrightness = NEW_LIGHTNING_BRIGHTNESS;
			generateNextLightningTime();
		}

		if (lightningEnabled && config.flashingEffects()) {
			float t = clamp(lightningBrightness, 0, 1);
			currentFogColor = mix(currentFogColor, LIGHTNING_COLOR, t);
			currentWaterColor = mix(currentWaterColor, LIGHTNING_COLOR, t);
		} else {
			lightningBrightness = 0f;
		}
	}

	/**
	 * Determines when the next lighting strike will occur.
	 * Produces a short interval for a quick successive strike
	 * or a longer interval at the end of a cluster.
	 */
	void generateNextLightningTime() {
		nextLightningTime = plugin.elapsedTime;
		if (Math.random() <= QUICK_LIGHTNING_CHANCE) {
			// chain together lighting strikes in quick succession
			nextLightningTime += mix(MIN_QUICK_LIGHTNING_INTERVAL, MAX_QUICK_LIGHTNING_INTERVAL, RAND.nextFloat());
		} else {
			// cool-down period before a new lightning cluster
			nextLightningTime += mix(MIN_LIGHTNING_INTERVAL, MAX_LIGHTNING_INTERVAL, RAND.nextFloat());
		}
	}

	private Environment getCurrentEnvironment() {
		if (currentEnvironment == Environment.OVERWORLD)
			return getOverworldEnvironment();
		return currentEnvironment;
	}

	private Environment getOverworldEnvironment() {
		switch (plugin.configSeasonalTheme) {
			case AUTUMN:
				return Environment.AUTUMN;
			case WINTER:
				return Environment.WINTER;
			default:
				return Environment.OVERWORLD;
		}
	}

	public boolean isUnderwater() {
		return currentEnvironment.isUnderwater;
	}
}

package rs117.hd.scene.environments;

import com.google.gson.annotations.JsonAdapter;
import java.util.Objects;
import javax.annotation.Nullable;
import lombok.AccessLevel;
import lombok.Setter;
import rs117.hd.scene.AreaManager;
import rs117.hd.scene.areas.Area;
import rs117.hd.utils.GsonUtils.DegreesToRadians;
import rs117.hd.utils.HDUtils;

import static rs117.hd.utils.ColorUtils.SrgbToLinearAdapter;
import static rs117.hd.utils.ColorUtils.rgb;

@Setter(value = AccessLevel.PRIVATE)
public class Environment {
	public static final float[] DEFAULT_SUN_ANGLES = HDUtils.sunAngles(52, 235);
	public static final Environment DEFAULT = new Environment()
		.setKey("DEFAULT")
		.setArea(Area.ALL)
		.setFogColor(rgb("#000000"))
		.setWaterColor(rgb("#66eaff"))
		.setSunAngles(DEFAULT_SUN_ANGLES)
		.normalize();
	public static final Environment NONE = new Environment()
		.setKey("NONE")
		.setFogColor(rgb("#ff00ff"))
		.normalize();

	public static Environment OVERWORLD, AUTUMN, WINTER;

	public String key;
	@JsonAdapter(AreaManager.Adapter.class)
	public Area area = Area.NONE;
	public boolean isOverworld = false;
	public boolean isUnderwater = false;
	public boolean force = false;
	public boolean allowSkyOverride = true;
	public boolean lightningEffects = false;
	public boolean instantTransition = false;
	@JsonAdapter(SrgbToLinearAdapter.class)
	public float[] ambientColor = rgb("#ffffff");
	public float ambientStrength = 1;
	@JsonAdapter(SrgbToLinearAdapter.class)
	public float[] directionalColor = rgb("#ffffff");
	public float directionalStrength = .25f;
	@Nullable
	@JsonAdapter(SrgbToLinearAdapter.class)
	public float[] waterColor;
	@JsonAdapter(SrgbToLinearAdapter.class)
	public float[] waterCausticsColor;
	public float waterCausticsStrength = -1;
	@JsonAdapter(SrgbToLinearAdapter.class)
	public float[] underglowColor = rgb("#000000");
	public float underglowStrength = 0;
	@Nullable
	@JsonAdapter(DegreesToRadians.class)
	public float[] sunAngles; // horizontal coordinate system, in radians
	@Nullable
	@JsonAdapter(SrgbToLinearAdapter.class)
	public float[] fogColor;
	public float fogDepth = 25;
	public int groundFogStart = -200;
	public int groundFogEnd = -500;
	public float groundFogOpacity = 0;
	@JsonAdapter(DegreesToRadians.class)
	public float windAngle = 0.0f;
	public float windSpeed = 15.0f;
	public float windStrength = 0.0f;
	public float windCeiling = 1280.0f;

	public Environment normalize() {
		if (area != Area.ALL && area != Area.NONE) {
			isOverworld = Area.OVERWORLD.intersects(area);
			// Certain nullable fields will fall back to using the current overworld theme's values later,
			// but for environments that aren't part of the overworld, we want to fall back to the default
			// (underground) environment's values for any unspecified fields
			if (!isOverworld && DEFAULT != null) {
				sunAngles = Objects.requireNonNullElse(sunAngles, DEFAULT.sunAngles);
				fogColor = Objects.requireNonNullElse(fogColor, DEFAULT.fogColor);
				waterColor = Objects.requireNonNullElse(waterColor, DEFAULT.waterColor);
			}
		}

		if (sunAngles != null)
			sunAngles = HDUtils.ensureArrayLength(sunAngles, 2);

		// Base water caustics on directional lighting by default
		if (waterCausticsColor == null)
			waterCausticsColor = directionalColor;
		if (waterCausticsStrength == -1)
			waterCausticsStrength = directionalStrength;
		return this;
	}

	@Override
	public String toString() {
		if (key != null)
			return key;
		return area.name;
	}
}

package rs117.hd.scene;

import com.google.common.collect.Sets;
import java.util.Arrays;
import java.util.HashMap;
import java.util.Map;
import java.util.Set;
import javax.inject.Inject;
import net.runelite.api.*;
import net.runelite.api.events.*;
import net.runelite.client.eventbus.EventBus;
import net.runelite.client.eventbus.Subscribe;
import rs117.hd.HdPlugin;
import rs117.hd.HdPluginConfig;
import rs117.hd.overlays.FrameTimer;
import rs117.hd.overlays.Timer;
import rs117.hd.scene.model_overrides.ModelOverride;

import static rs117.hd.utils.ColorUtils.hsl;
import static rs117.hd.utils.MathUtils.*;

public class FishingSpotReplacer {
	private static final int FISHING_SPOT_MODEL_ID = 41238;
	private static final int FISHING_SPOT_ANIMATION_ID = 10793;
	private static final int LAVA_SPOT_MODEL_ID = 2331;
	private static final int LAVA_SPOT_ANIMATION_ID = 525;
	private static final int LAVA_SPOT_COLOR = hsl("#837574");

	// @formatter:off
	private static final Set<Integer> FISHING_SPOT_IDS = Set.of(394, 635, 1506, 1507, 1508, 1509, 1510, 1511, 1512, 1513, 1514, 1515, 1516, 1517, 1518, 1519, 1520, 1521, 1522, 1523, 1524, 1525, 1526, 1527, 1528, 1529, 1530, 1531, 1532, 1533, 1534, 1535, 1536, 1542, 1544, 2146, 2653, 2654, 2655, 3317, 3417, 3418, 3419, 3657, 3913, 3914, 3915, 4079, 4080, 4081, 4082, 4316, 4476, 4477, 4710, 4711, 4712, 4713, 4714, 5233, 5234, 5820, 5821, 6731, 6825, 7155, 7199, 7200, 7323, 7459, 7460, 7461, 7462, 7463, 7464, 7465, 7466, 7467, 7468, 7469, 7470, 7946, 7947, 8524, 8525, 8526, 8527, 9171, 9172, 9173, 9174, 9478, 12267);
	private static final Set<Integer> LAVA_FISHING_SPOT_IDS = Set.of(4928);
	// @formatter:on
	private static final Set<Integer> NPC_IDS = Sets.union(FISHING_SPOT_IDS, LAVA_FISHING_SPOT_IDS).immutableCopy();

	@Inject
	private Client client;

	@Inject
	private EventBus eventBus;

	@Inject
	private HdPlugin plugin;

	@Inject
	private HdPluginConfig config;

	@Inject
	private TileOverrideManager tileOverrideManager;

	@Inject
	private FrameTimer frameTimer;

	private final Map<Integer, RuneLiteObject> npcIndexToModel = new HashMap<>();

	public void startUp() {
		eventBus.register(this);
	}

	public void shutDown() {
		eventBus.unregister(this);
		despawnRuneLiteObjects();
	}

	public void despawnRuneLiteObjects() {
		for (var obj : npcIndexToModel.values())
			obj.setActive(false);
		npcIndexToModel.clear();
	}

	public ModelOverride getModelOverride() {
		ModelOverride override = new ModelOverride();
		override.hide = true;
		override.npcIds = NPC_IDS;
		return override;
	}

	public void update() {
		var sceneContext = plugin.getSceneContext();
		if (sceneContext == null)
			return;

		frameTimer.begin(Timer.REPLACE_FISHING_SPOTS);

		var worldView = client.getTopLevelWorldView();
		var npcs = worldView.npcs();
		var modelsToDespawn = new HashMap<>(npcIndexToModel);
		for (NPC npc : npcs) {
			if (!NPC_IDS.contains(npc.getId()))
				continue;

			var model = modelsToDespawn.remove(npc.getIndex());
			if (model == null) {
				// No fishing spot replacement associated with the NPC yet, so spawn one
				spawnFishingSpot(sceneContext, npc);
			} else {
				// Already associated with a fishing spot replacement, so let's update its position
				model.setLocation(npc.getLocalLocation(), worldView.getPlane());
			}
		}

		for (var entry : modelsToDespawn.entrySet()) {
			// Despawn the RuneLiteObject and stop tracking the index
			entry.getValue().setActive(false);
			npcIndexToModel.remove(entry.getKey());
		}

		frameTimer.end(Timer.REPLACE_FISHING_SPOTS);
	}

	@Subscribe
	public void onNpcSpawned(NpcSpawned npcSpawned) {
		var sceneContext = plugin.getSceneContext();
		var npc = npcSpawned.getNpc();
		if (sceneContext != null && NPC_IDS.contains(npc.getId()))
			spawnFishingSpot(sceneContext, npc);
	}

	public void spawnFishingSpot(SceneContext sceneContext, NPC npc) {
		if (npcIndexToModel.containsKey(npc.getIndex()))
			return;

		AnimationController animController;
		int modelId;
		int recolor = -1;
		if (LAVA_FISHING_SPOT_IDS.contains(npc.getId())) {
			animController = new AnimationController(client, LAVA_SPOT_ANIMATION_ID);
			modelId = LAVA_SPOT_MODEL_ID;
			recolor = LAVA_SPOT_COLOR;
		} else {
			animController = new AnimationController(client, FISHING_SPOT_ANIMATION_ID);
			modelId = FISHING_SPOT_MODEL_ID;
			var lp = npc.getLocalLocation();
			if (lp.isInScene()) {
				var worldView = client.getTopLevelWorldView();
				int plane = worldView.getPlane();
				Tile tile = worldView.getScene().getTiles()[plane][lp.getSceneX()][lp.getSceneY()];
				recolor = tileOverrideManager.getOverride(sceneContext, tile).waterType.fishingSpotRecolor;
			}
		}

		ModelData modelData = client.loadModelData(modelId);
		if (modelData == null)
			return;

		if (recolor != -1) {
			modelData = modelData.cloneColors();
			Arrays.fill(modelData.getFaceColors(), (short) recolor);
		}

		var anim = animController.getAnimation();
		if (anim != null)
			animController.setFrame(RAND.nextInt(anim.getDuration()));

		RuneLiteObject fishingSpot = client.createRuneLiteObject();
		fishingSpot.setAnimationController(animController);
		fishingSpot.setOrientation(RAND.nextInt(4) * 512);
		fishingSpot.setDrawFrontTilesFirst(false);
		fishingSpot.setActive(true);
		fishingSpot.setModel(modelData.light());
		npcIndexToModel.put(npc.getIndex(), fishingSpot);
	}
}

package rs117.hd.scene;

import com.google.gson.TypeAdapter;
import com.google.gson.reflect.TypeToken;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Map;
import java.util.stream.Collectors;
import javax.inject.Inject;
import javax.inject.Singleton;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import rs117.hd.HdPlugin;
import rs117.hd.utils.FileWatcher;
import rs117.hd.utils.GsonUtils;
import rs117.hd.utils.Props;
import rs117.hd.utils.ResourcePath;

import static rs117.hd.utils.ResourcePath.path;

@Slf4j
@Singleton
public class GamevalManager {
	private static final ResourcePath GAMEVAL_PATH = Props
		.getFile("rlhd.gameval-path", () -> path(GamevalManager.class, "gamevals.json"));

	private static final String NPC_KEY = "npcs";
	private static final String OBJECT_KEY = "objects";
	private static final String ANIM_KEY = "anims";
	private static final String SPOTANIM_KEY = "spotanims";

	@Inject
	private HdPlugin plugin;

	private FileWatcher.UnregisterCallback fileWatcher;

	private static final Map<String, Map<String, Integer>> GAMEVALS = new HashMap<>();

	static {
		clearGamevals();
	}

	private static void clearGamevals() {
		GAMEVALS.put(NPC_KEY, Collections.emptyMap());
		GAMEVALS.put(OBJECT_KEY, Collections.emptyMap());
		GAMEVALS.put(ANIM_KEY, Collections.emptyMap());
		GAMEVALS.put(SPOTANIM_KEY, Collections.emptyMap());
	}

	public void startUp() throws IOException {
		fileWatcher = GAMEVAL_PATH.watch((path, first) -> {
			try {
				Map<String, Map<String, Integer>> gamevals = plugin.getGson()
					.fromJson(path.toReader(), new TypeToken<Map<String, Map<String, Integer>>>() {}.getType());
				GAMEVALS.replaceAll((k, v) -> gamevals.getOrDefault(k, Collections.emptyMap()));
				log.debug("Loaded gameval mappings");
			} catch (IOException ex) {
				log.error("Failed to load gamevals:", ex);
			}
		});
	}

	public void shutDown() {
		if (fileWatcher != null)
			fileWatcher.unregister();
		fileWatcher = null;
		clearGamevals();
	}

	private String getName(String key, int id) {
		return GAMEVALS
			.get(key)
			.entrySet()
			.stream()
			.filter(e -> e.getValue() == id)
			.map(Map.Entry::getKey)
			.findFirst()
			.orElse(null);
	}

	public Map<String, Integer> getNpcs() {
		return GAMEVALS.get(NPC_KEY);
	}

	public Map<String, Integer> getObjects() {
		return GAMEVALS.get(OBJECT_KEY);
	}

	public Map<String, Integer> getAnims() {
		return GAMEVALS.get(ANIM_KEY);
	}

	public Map<String, Integer> getSpotanims() {
		return GAMEVALS.get(SPOTANIM_KEY);
	}

	public int getNpcId(String name) {
		return getNpcs().get(name);
	}

	public int getObjectId(String name) {
		return getObjects().get(name);
	}

	public int getAnimId(String name) {
		return getAnims().get(name);
	}

	public int getSpotanimId(String name) {
		return getSpotanims().get(name);
	}

	public String getNpcName(int id) {
		return getName(NPC_KEY, id);
	}

	public String getObjectName(int id) {
		return getName(OBJECT_KEY, id);
	}

	public String getAnimName(int id) {
		return getName(ANIM_KEY, id);
	}

	public String getSpotanimName(int id) {
		return getName(SPOTANIM_KEY, id);
	}

	@Slf4j
	@RequiredArgsConstructor
	private abstract static class GamevalAdapter extends TypeAdapter<HashSet<Integer>> {
		private final String key;

		@Override
		public HashSet<Integer> read(JsonReader in) throws IOException {
			var map = GAMEVALS.get(key);
			HashSet<Integer> result = new HashSet<>();

			in.beginArray();
			while (in.hasNext()) {
				var type = in.peek();
				switch (type) {
					case NUMBER: {
						int id = in.nextInt();
						if (id != -1)
							log.debug("Adding raw {} ID: {} at {}. Should be replaced with a gameval.", key, id, GsonUtils.location(in));
						result.add(id);
						break;
					}
					case STRING:
						String name = in.nextString();
						Integer id = map.get(name);
						if (id == null) {
							String suggestion = "";
							for (var gamevalMapEntry : GAMEVALS.entrySet()) {
								if (gamevalMapEntry.getValue().get(name) != null) {
									suggestion = String.format(", did you mean to match %s?", gamevalMapEntry.getKey());
									break;
								}
							}
							log.error("Missing {} gameval: {}{} at {}", key, name, suggestion, GsonUtils.location(in), new Throwable());
						} else {
							result.add(id);
						}
						break;
					default:
						log.error("Unexpected {} gameval type: {} at {}", key, type, GsonUtils.location(in), new Throwable());
						break;
				}
			}
			in.endArray();

			return result;
		}

		@Override
		public void write(JsonWriter out, HashSet<Integer> ids) throws IOException {
			var remainingIds = new ArrayList<>(ids);
			var map = GAMEVALS.get(key);
			var names = map.entrySet().stream()
				.filter(e -> remainingIds.remove(e.getValue()))
				.map(Map.Entry::getKey)
				.sorted()
				.toArray(String[]::new);

			if (!remainingIds.isEmpty()) {
				remainingIds.sort(Integer::compareTo);
				log.warn(
					"Exporting IDs with no corresponding gamevals: {}", remainingIds.stream()
						.filter(i -> i != -1)
						.map(Object::toString)
						.collect(Collectors.joining(", "))
				);
			}

			out.beginArray();
			for (var id : remainingIds)
				out.value(id);
			for (var name : names)
				out.value(name);
			out.endArray();
		}
	}

	public static class NpcAdapter extends GamevalAdapter {
		public NpcAdapter() {
			super(NPC_KEY);
		}
	}

	public static class ObjectAdapter extends GamevalAdapter {
		public ObjectAdapter() {
			super(OBJECT_KEY);
		}
	}

	public static class AnimationAdapter extends GamevalAdapter {
		public AnimationAdapter() {
			super(ANIM_KEY);
		}
	}

	public static class SpotanimAdapter extends GamevalAdapter {
		public SpotanimAdapter() {
			super(SPOTANIM_KEY);
		}
	}
}

package rs117.hd.scene;

import java.io.IOException;
import java.util.Arrays;
import java.util.List;
import java.util.stream.Stream;
import javax.inject.Inject;
import lombok.extern.slf4j.Slf4j;
import net.runelite.client.callback.ClientThread;
import rs117.hd.HdPlugin;
import rs117.hd.scene.ground_materials.GroundMaterial;
import rs117.hd.utils.FileWatcher;
import rs117.hd.utils.Props;
import rs117.hd.utils.ResourcePath;

import static rs117.hd.utils.ResourcePath.path;

@Slf4j
public class GroundMaterialManager {
	private static final ResourcePath GROUND_MATERIALS_PATH = Props
		.getFile("rlhd.ground-materials-path", () -> path(AreaManager.class, "ground_materials.json"));

	@Inject
	private HdPlugin plugin;

	@Inject
	private ClientThread clientThread;

	@Inject
	private MaterialManager materialManager;

	@Inject
	private TileOverrideManager tileOverrideManager;

	private FileWatcher.UnregisterCallback fileWatcher;

	public static GroundMaterial[] GROUND_MATERIALS = {};

	public void startUp() {
		fileWatcher = GROUND_MATERIALS_PATH.watch((path, first) -> clientThread.invoke(() -> {
			try {
				GroundMaterial[] groundMaterials = path.loadJson(plugin.getGson(), GroundMaterial[].class);
				if (groundMaterials == null)
					throw new IOException("Empty or invalid: " + path);

				for (var g : groundMaterials)
					g.normalize();


				var dirt1 = materialManager.getMaterial("DIRT_1");
				var dirt2 = materialManager.getMaterial("DIRT_2");
				GroundMaterial.DIRT = new GroundMaterial("DIRT", dirt1, dirt2);
				GroundMaterial.UNDERWATER_GENERIC = new GroundMaterial("UNDERWATER_GENERIC", dirt1, dirt2);

				var staticGroundMaterials = List.of(
					GroundMaterial.NONE,
					GroundMaterial.DIRT,
					GroundMaterial.UNDERWATER_GENERIC
				);
				GROUND_MATERIALS = Stream.concat(
					staticGroundMaterials.stream(),
					Arrays.stream(groundMaterials)
				).toArray(GroundMaterial[]::new);

				// Reload everything which depends on ground materials
				if (!first)
					tileOverrideManager.reload(false);
			} catch (IOException ex) {
				log.error("Failed to load ground materials:", ex);
			}
		}));
	}

	public void shutDown() {
		if (fileWatcher != null)
			fileWatcher.unregister();
		fileWatcher = null;
		GROUND_MATERIALS = new GroundMaterial[0];
	}

	public void restart() {
		shutDown();
		startUp();
	}
}

package rs117.hd.scene.ground_materials;

import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonToken;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import lombok.Getter;
import lombok.extern.slf4j.Slf4j;
import rs117.hd.scene.GroundMaterialManager;
import rs117.hd.scene.materials.Material;
import rs117.hd.utils.GsonUtils;

@Getter
@Slf4j
public class GroundMaterial {
	public static final GroundMaterial NONE = new GroundMaterial("NONE", Material.NONE);

	public static GroundMaterial DIRT;
	public static GroundMaterial UNDERWATER_GENERIC;

	public final String name;
	private final Material[] materials;

	public GroundMaterial(String name, Material... materials) {
		this.name = name;
		this.materials = materials;
	}

	public void normalize() {
		for (int j = 0; j < materials.length; j++)
			if (materials[j] == null)
				materials[j] = Material.NONE;
	}

	/**
	 * Get a random material based on the given coordinates.
	 */
	public Material getRandomMaterial(int... worldPos) {
		long hash = 0;
		for (int coord : worldPos)
			hash = hash * 31 + coord;
		long seed = (hash ^ 0x5DEECE66DL) & ((1L << 48) - 1);
		seed = (seed * 0x5DEECE66DL + 0xBL) & ((1L << 48) - 1);
		int r = (int) (seed >>> (48 - 31));
		return materials[r % materials.length];
	}

	@Override
	public String toString() {
		return name;
	}

	@Slf4j
	public static class Adapter extends TypeAdapter<GroundMaterial> {
		@Override
		public GroundMaterial read(JsonReader in) throws IOException {
			if (in.peek() == JsonToken.NULL)
				return null;

			if (in.peek() == JsonToken.STRING) {
				String name = in.nextString();
				for (var groundMaterial : GroundMaterialManager.GROUND_MATERIALS)
					if (name.equals(groundMaterial.name))
						return groundMaterial;

				log.warn("No ground material exists with the name '{}' at {}", name, GsonUtils.location(in), new Throwable());
			} else {
				log.warn("Unexpected type {} at {}", in.peek(), GsonUtils.location(in), new Throwable());
			}

			return null;
		}

		@Override
		public void write(JsonWriter out, GroundMaterial groundMaterial) throws IOException {
			if (groundMaterial == null) {
				out.nullValue();
			} else {
				out.value(groundMaterial.name);
			}
		}
	}
}

/*
 * Copyright (c) 2019 Abex
 * Copyright (c) 2021, 117 <https://twitter.com/117scape>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package rs117.hd.scene;

import com.google.common.collect.ArrayListMultimap;
import com.google.common.collect.ListMultimap;
import com.google.gson.Gson;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashSet;
import java.util.List;
import java.util.function.Predicate;
import javax.annotation.Nonnull;
import javax.annotation.Nullable;
import javax.inject.Inject;
import javax.inject.Singleton;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.*;
import net.runelite.api.coords.*;
import net.runelite.api.events.*;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.eventbus.EventBus;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.plugins.PluginManager;
import net.runelite.client.plugins.entityhider.EntityHiderConfig;
import net.runelite.client.plugins.entityhider.EntityHiderPlugin;
import rs117.hd.HdPlugin;
import rs117.hd.config.DynamicLights;
import rs117.hd.data.ObjectType;
import rs117.hd.opengl.uniforms.UBOLights;
import rs117.hd.scene.lights.Alignment;
import rs117.hd.scene.lights.Light;
import rs117.hd.scene.lights.LightDefinition;
import rs117.hd.scene.lights.LightType;
import rs117.hd.utils.HDUtils;
import rs117.hd.utils.ModelHash;
import rs117.hd.utils.Props;
import rs117.hd.utils.ResourcePath;

import static net.runelite.api.Constants.*;
import static net.runelite.api.Perspective.*;
import static rs117.hd.utils.HDUtils.isSphereIntersectingFrustum;
import static rs117.hd.utils.MathUtils.*;
import static rs117.hd.utils.ResourcePath.path;

@Singleton
@Slf4j
public class LightManager {
	private static final ResourcePath LIGHTS_PATH = Props
		.getFile("rlhd.lights-path", () -> path(LightManager.class, "lights.json"));

	@Inject
	private Client client;

	@Inject
	private ClientThread clientThread;

	@Inject
	private EventBus eventBus;

	@Inject
	private PluginManager pluginManager;

	@Inject
	private ConfigManager configManager;

	@Inject
	private HdPlugin plugin;

	@Inject
	private ModelOverrideManager modelOverrideManager;

	@Inject
	private EntityHiderPlugin entityHiderPlugin;

	private final ArrayList<Light> WORLD_LIGHTS = new ArrayList<>();
	private final ListMultimap<Integer, LightDefinition> NPC_LIGHTS = ArrayListMultimap.create();
	private final ListMultimap<Integer, LightDefinition> OBJECT_LIGHTS = ArrayListMultimap.create();
	private final ListMultimap<Integer, LightDefinition> PROJECTILE_LIGHTS = ArrayListMultimap.create();
	private final ListMultimap<Integer, LightDefinition> GRAPHICS_OBJECT_LIGHTS = ArrayListMultimap.create();

	private final Renderable[] imposterRenderables = new Renderable[2];
	private boolean reloadLights;
	private EntityHiderConfig entityHiderConfig;
	private int currentPlane;

	public void loadConfig(Gson gson, ResourcePath path) {
		LightDefinition[] lights;
		try {
			lights = path.loadJson(gson, LightDefinition[].class);
			if (lights == null) {
				log.warn("Skipping empty lights.json");
				return;
			}
		} catch (IOException ex) {
			log.error("Failed to load lights", ex);
			return;
		}

		clientThread.invoke(() -> {
			WORLD_LIGHTS.clear();
			NPC_LIGHTS.clear();
			OBJECT_LIGHTS.clear();
			PROJECTILE_LIGHTS.clear();
			GRAPHICS_OBJECT_LIGHTS.clear();

			for (LightDefinition lightDef : lights) {
				lightDef.normalize();
				if (lightDef.worldX != null && lightDef.worldY != null) {
					Light light = new Light(lightDef);
					light.worldPoint = new WorldPoint(lightDef.worldX, lightDef.worldY, lightDef.plane);
					light.persistent = true;
					WORLD_LIGHTS.add(light);
				}
				lightDef.npcIds.forEach(id -> NPC_LIGHTS.put(id, lightDef));
				lightDef.objectIds.forEach(id -> OBJECT_LIGHTS.put(id, lightDef));
				lightDef.projectileIds.forEach(id -> PROJECTILE_LIGHTS.put(id, lightDef));
				lightDef.graphicsObjectIds.forEach(id -> GRAPHICS_OBJECT_LIGHTS.put(id, lightDef));
			}

			log.debug("Loaded {} lights", lights.length);

			// Reload lights once on plugin startup, and whenever lights.json should be hot-swapped.
			// If we don't reload on startup, NPCs won't have lights added until RuneLite fires events
			reloadLights = true;
		});
	}

	public void startUp() {
		entityHiderConfig = configManager.getConfig(EntityHiderConfig.class);
		LIGHTS_PATH.watch(path -> loadConfig(plugin.getGson(), path));
		eventBus.register(this);
	}

	public void shutDown() {
		eventBus.unregister(this);
	}

	public void update(@Nonnull SceneContext sceneContext, int[] cameraShift, float[][] cameraFrustum) {
		assert client.isClientThread();

		if (plugin.configDynamicLights == DynamicLights.NONE || client.getGameState() != GameState.LOGGED_IN) {
			sceneContext.numVisibleLights = 0;
			return;
		}

		if (reloadLights) {
			reloadLights = false;
			loadSceneLights(sceneContext, null);

			client.getNpcs().forEach(npc -> {
				addNpcLights(npc);
				addSpotanimLights(npc);
			});
		}

		// These should never occur, but just in case...
		if (sceneContext.knownProjectiles.size() > 10000) {
			log.warn("Too many projectiles tracked: {}. Clearing...", sceneContext.knownProjectiles.size());
			sceneContext.knownProjectiles.clear();
		}
		if (sceneContext.lights.size() > 10000) {
			log.warn("Too many lights: {}. Clearing...", sceneContext.lights.size());
			sceneContext.lights.clear();
		}

		int drawDistance = plugin.getDrawDistance() * LOCAL_TILE_SIZE;
		Tile[][][] tiles = sceneContext.scene.getExtendedTiles();
		int[][][] tileHeights = sceneContext.scene.getTileHeights();
		var cachedNpcs = client.getTopLevelWorldView().npcs();
		var cachedPlayers = client.getTopLevelWorldView().players();
		final int plane = client.getPlane();
		boolean changedPlanes = false;

		if (plane != currentPlane) {
			currentPlane = plane;
			changedPlanes = true;
		}

		for (Light light : sceneContext.lights) {
			// Ways lights may get deleted:
			// - animation-specific:
			//   effectively spawn when the animation they're attached to starts playing, and despawns when it stops,
			//   but they are typically replayable, so they don't fully despawn until marked for removal by something else
			// - spotanim & projectile lights:
			//   automatically marked for removal upon completion
			// - actor lights:
			//   may be automatically marked for removal if the actor becomes invalid
			// - other lights:
			//   despawn when marked for removal by a RuneLite despawn event
			// - fixed lifetime && !replayable:
			//   All non-replayable lights with a fixed lifetime will be automatically marked for removal when done playing

			// Light fade-in and fade-out are based on whether the parent currently exists
			// Additionally, lights have an overruling fade-out when being deprioritized

			// Whatever the light is attached to is presumed to exist if it's not marked for removal yet
			boolean parentExists = !light.markedForRemoval;
			boolean hiddenTemporarily = false;

			if (light.tileObject != null) {
				if (!light.markedForRemoval && light.animationSpecific && light.tileObject instanceof GameObject) {
					int animationId = -1;
					var renderable = ((GameObject) light.tileObject).getRenderable();
					if (renderable instanceof DynamicObject) {
						var anim = ((DynamicObject) renderable).getAnimation();
						if (anim != null)
							animationId = anim.getId();
					}
					parentExists = light.def.animationIds.contains(animationId);
				}
			} else if (light.projectile != null) {
				light.origin[0] = (int) light.projectile.getX();
				light.origin[1] = (int) light.projectile.getZ() - light.def.height;
				light.origin[2] = (int) light.projectile.getY();
				if (light.projectile.getRemainingCycles() <= 0) {
					light.markedForRemoval = true;
				} else {
					hiddenTemporarily = !shouldShowProjectileLights();
					if (light.animationSpecific) {
						var animation = light.projectile.getAnimation();
						parentExists = animation != null && light.def.animationIds.contains(animation.getId());
					}
					light.orientation = light.projectile.getOrientation();
				}
			} else if (light.graphicsObject != null) {
				light.origin[0] = light.graphicsObject.getLocation().getX();
				light.origin[1] = light.graphicsObject.getZ() - light.def.height;
				light.origin[2] = light.graphicsObject.getLocation().getY();
				if (light.graphicsObject.finished()) {
					light.markedForRemoval = true;
				} else if (light.animationSpecific) {
					var animation = light.graphicsObject.getAnimation();
					parentExists = animation != null && light.def.animationIds.contains(animation.getId());
				}
			} else if (light.actor != null && !light.markedForRemoval) {
				if (light.actor instanceof NPC && light.actor != cachedNpcs.byIndex(((NPC) light.actor).getIndex()) ||
					light.actor instanceof Player && light.actor != cachedPlayers.byIndex(((Player) light.actor).getId()) ||
					light.spotanimId != -1 && !light.actor.hasSpotAnim(light.spotanimId)
				) {
					parentExists = false;
					light.markedForRemoval = true;
				} else {
					var lp = light.actor.getLocalLocation();
					light.origin[0] = lp.getX();
					light.origin[2] = lp.getY();
					light.plane = plane;
					light.orientation = light.actor.getCurrentOrientation();

					if (light.animationSpecific)
						parentExists = light.def.animationIds.contains(light.actor.getAnimation());

					int tileExX = ((int) light.origin[0] >> LOCAL_COORD_BITS) + sceneContext.sceneOffset;
					int tileExY = ((int) light.origin[2] >> LOCAL_COORD_BITS) + sceneContext.sceneOffset;

					// Some NPCs, such as Crystalline Hunllef in The Gauntlet, sometimes return scene X/Y values far outside the possible range.
					Tile tile;
					if (tileExX >= 0 && tileExY >= 0 &&
						tileExX < EXTENDED_SCENE_SIZE && tileExY < EXTENDED_SCENE_SIZE &&
						(tile = tiles[plane][tileExX][tileExY]) != null
					) {
						if (!light.def.ignoreActorHiding &&
							!(light.actor instanceof NPC && ((NPC) light.actor).getComposition().getSize() > 1)
						) {
							// Check if the actor is hidden by another actor on the same tile
							for (var gameObject : tile.getGameObjects()) {
								if (gameObject == null || !(gameObject.getRenderable() instanceof Actor))
									continue;

								// Assume only the first actor at the same exact location will be rendered
								if (gameObject.getX() == round(light.origin[0]) &&
									gameObject.getY() == round(light.origin[2]) &&
									gameObject.getRenderable() != light.actor
								) {
									hiddenTemporarily = true;
									break;
								}
							}
						}

						if (!hiddenTemporarily)
							hiddenTemporarily = !isActorLightVisible(light.actor);

						// Interpolate between tile heights based on specific scene coordinates
						int tileZ = plane;
						if (tile.getBridge() != null)
							tileZ++;
						float lerpX = fract(light.origin[0] / (float) LOCAL_TILE_SIZE);
						float lerpY = fract(light.origin[2] / (float) LOCAL_TILE_SIZE);
						float heightNorth = mix(
							tileHeights[tileZ][tileExX][tileExY + 1],
							tileHeights[tileZ][tileExX + 1][tileExY + 1],
							lerpX
						);
						float heightSouth = mix(
							tileHeights[tileZ][tileExX][tileExY],
							tileHeights[tileZ][tileExX + 1][tileExY],
							lerpX
						);
						float tileHeight = mix(heightSouth, heightNorth, lerpY);
						light.origin[1] = (int) tileHeight - 1 - light.def.height;
					}
				}
			}

			light.pos[0] = light.origin[0];
			light.pos[1] = light.origin[1];
			light.pos[2] = light.origin[2];

			int orientation = 0;
			if (light.alignment.relative)
				orientation = mod(light.orientation + light.alignment.orientation, 2048);

			if (light.alignment == Alignment.CUSTOM) {
				// orientation 0 = south
				float sin = sin(orientation * JAU_TO_RAD);
				float cos = cos(orientation * JAU_TO_RAD);
				float x = light.offset[0];
				float z = light.offset[2];
				light.pos[0] += -cos * x - sin * z;
				light.pos[1] += light.offset[1];
				light.pos[2] += -cos * z + sin * x;
			} else {
				int localSizeX = light.sizeX * LOCAL_TILE_SIZE;
				int localSizeY = light.sizeY * LOCAL_TILE_SIZE;

				float radius = localSizeX / 2f;
				if (!light.alignment.radial)
					radius = sqrt(localSizeX * localSizeX + localSizeX * localSizeX) / 2;

				float sine = SINE[orientation] / 65536f;
				float cosine = COSINE[orientation] / 65536f;
				cosine /= (float) localSizeX / (float) localSizeY;

				int offsetX = (int) (radius * sine);
				int offsetY = (int) (radius * cosine);

				light.pos[0] += offsetX;
				light.pos[2] += offsetY;
			}

			// This is a little bit slow, so only update it when necessary
			if (light.prevPlane != light.plane) {
				light.prevPlane = light.plane;
				light.belowFloor = false;
				light.aboveFloor = false;
				int tileExX = ((int) light.pos[0] >> LOCAL_COORD_BITS) + sceneContext.sceneOffset;
				int tileExY = ((int) light.pos[2] >> LOCAL_COORD_BITS) + sceneContext.sceneOffset;
				if (light.plane >= 0 && tileExX >= 0 && tileExY >= 0 && tileExX < EXTENDED_SCENE_SIZE && tileExY < EXTENDED_SCENE_SIZE) {
					byte hasTile = sceneContext.filledTiles[tileExX][tileExY];
					if ((hasTile & (1 << light.plane + 1)) != 0)
						light.belowFloor = true;
					if ((hasTile & (1 << light.plane)) != 0)
						light.aboveFloor = true;
				}
			}

			if (!hiddenTemporarily && !light.def.visibleFromOtherPlanes) {
				// Hide certain lights on planes lower than the player to prevent light 'leaking' through the floor
				if (light.plane < plane && light.belowFloor)
					hiddenTemporarily = true;
				// Hide any light that is above the current plane and is above a solid floor
				if (light.plane > plane && light.aboveFloor)
					hiddenTemporarily = true;
			}

			if (parentExists != light.parentExists) {
				light.parentExists = parentExists;
				if (parentExists) {
					// Reset the light if it's replayable and the parent just spawned
					if (light.replayable) {
						light.elapsedTime = 0;
						light.changedVisibilityAt = -1;
						if (light.dynamicLifetime)
							light.lifetime = -1;
					}
				} else if (light.lifetime == -1) {
					// Schedule despawning of the light if the parent just despawned, and the light isn't already scheduled to despawn
					float minLifetime = light.spawnDelay + light.fadeInDuration;
					light.lifetime = max(minLifetime, light.elapsedTime) + light.despawnDelay;
				}
			}

			if (hiddenTemporarily != light.hiddenTemporarily)
				light.toggleTemporaryVisibility(changedPlanes);

			light.elapsedTime += plugin.deltaClientTime;

			light.visible = light.spawnDelay <= light.elapsedTime && (light.lifetime == -1 || light.elapsedTime < light.lifetime);

			// If the light is temporarily hidden, keep it visible only while fading out
			if (light.visible && light.hiddenTemporarily)
				light.visible = light.changedVisibilityAt != -1 && light.elapsedTime - light.changedVisibilityAt < Light.VISIBILITY_FADE;

			if (light.visible) {
				// Prioritize lights closer to the focal point
				float distX = plugin.cameraFocalPoint[0] - light.pos[0];
				float distZ = plugin.cameraFocalPoint[1] - light.pos[2];
				light.distanceSquared = distX * distX + distZ * distZ;

				float maxRadius = light.def.radius;
				switch (light.def.type) {
					case FLICKER:
						maxRadius *= 1.5f;
						break;
					case PULSE:
						maxRadius *= 1 + light.def.range / 100f;
						break;
				}

				// Hide lights which cannot possibly affect the visible scene,
				// by either being behind the camera, or too far beyond the edge of the scene
				float near = -maxRadius * maxRadius;
				float far = drawDistance + LOCAL_HALF_TILE_SIZE + maxRadius;
				far *= far;
				light.visible = near < light.distanceSquared && light.distanceSquared < far;

				// Check that the light is within the camera's frustum specifically: left, right, bottom, top
				// The above check already covers the near plane
				if (plugin.configTiledLighting && light.visible) {
					light.visible = isSphereIntersectingFrustum(
						light.pos[0] + cameraShift[0],
						light.pos[1],
						light.pos[2] + cameraShift[1],
						maxRadius, // use max radius, since the radius hasn't been updated yet
						cameraFrustum,
						4
					);
				}
			}
		}

		// Order visible lights first, then by distance. Leave hidden lights unordered at the end.
		sceneContext.lights.sort((a, b) -> a.visible && b.visible ?
			Float.compare(a.distanceSquared, b.distanceSquared) :
			Boolean.compare(b.visible, a.visible));

		// Count number of visible lights
		sceneContext.numVisibleLights = 0;
		int maxLights = plugin.configTiledLighting ? UBOLights.MAX_LIGHTS : plugin.configDynamicLights.getMaxSceneLights();
		for (Light light : sceneContext.lights) {
			// Exit early once encountering the first invisible light, or the light limit is reached
			if (!light.visible || sceneContext.numVisibleLights >= maxLights)
				break;

			sceneContext.numVisibleLights++;

			// If the light was temporarily hidden, begin fading in
			if (!light.withinViewingDistance && light.hiddenTemporarily)
				light.toggleTemporaryVisibility(changedPlanes);
			light.withinViewingDistance = true;

			if (light.def.type == LightType.FLICKER) {
				float t = TWO_PI * (mod(plugin.elapsedTime, 60) / 60 + light.randomOffset);
				float flicker = (
					pow(cos(11 * t), 3) +
					pow(cos(17 * t), 6) +
					pow(cos(23 * t), 2) +
					pow(cos(31 * t), 6) +
					pow(cos(71 * t), 4) +
					pow(cos(151 * t), 6) / 2
				) / 4.335f;

				float maxFlicker = 1f + (light.def.range / 100f);
				float minFlicker = 1f - (light.def.range / 100f);

				flicker = minFlicker + (maxFlicker - minFlicker) * flicker;

				light.strength = light.def.strength * flicker;
				light.radius = (int) (light.def.radius * 1.5f);
			} else if (light.def.type == LightType.PULSE) {
				light.animation = fract(light.animation + plugin.deltaClientTime / light.duration);
				float output = 1 - 2 * abs(light.animation - .5f);
				float multiplier = 1 + (2 * output - 1) * light.def.range / 100;
				light.radius = light.def.radius * multiplier;
				light.strength = light.def.strength * multiplier;
			} else {
				light.strength = light.def.strength;
				light.radius = light.def.radius;
				light.color = light.def.color;
			}

			// Spawn & despawn fade-in and fade-out
			if (light.fadeInDuration > 0)
				light.strength *= saturate((light.elapsedTime - light.spawnDelay) / light.fadeInDuration);
			if (light.fadeOutDuration > 0 && light.lifetime != -1)
				light.strength *= saturate((light.lifetime - light.elapsedTime) / light.fadeOutDuration);

			light.applyTemporaryVisibilityFade();
		}

		for (int i = sceneContext.lights.size() - 1; i >= sceneContext.numVisibleLights; i--) {
			Light light = sceneContext.lights.get(i);
			light.withinViewingDistance = false;

			// Automatically despawn non-replayable fixed lifetime lights when they expire
			if (!light.replayable && light.lifetime != -1 && light.lifetime < light.elapsedTime)
				light.markedForRemoval = true;

			if (light.markedForRemoval) {
				sceneContext.lights.remove(i);
				if (light.projectile != null && --light.projectileRefCounter[0] == 0)
					sceneContext.knownProjectiles.remove(light.projectile);
			}
		}
	}

	private boolean isActorLightVisible(@Nonnull Actor actor) {
		try {
			// getModel may throw an exception from vanilla client code
			if (actor.getModel() == null)
				return false;
		} catch (Exception ex) {
			// Vanilla handles exceptions thrown in `DrawCallbacks#draw` gracefully, but here we have to handle them
			return false;
		}

		boolean entityHiderEnabled = pluginManager.isPluginEnabled(entityHiderPlugin);

		if (actor instanceof NPC) {
			if (!plugin.configNpcLights)
				return false;

			if (entityHiderEnabled) {
				var npc = (NPC) actor;
				boolean isPet = npc.getComposition().isFollower();

				if (client.getFollower() != null && client.getFollower().getIndex() == npc.getIndex())
					return true;

				if (entityHiderConfig.hideNPCs() && !isPet)
					return false;

				return !entityHiderConfig.hidePets() || !isPet;
			}
		} else if (actor instanceof Player) {
			if (entityHiderEnabled) {
				var player = (Player) actor;
				Player local = client.getLocalPlayer();
				if (local == null || player.getName() == null)
					return true;

				if (player == local)
					return !entityHiderConfig.hideLocalPlayer();

				if (entityHiderConfig.hideAttackers() && player.getInteracting() == local)
					return false;

				if (player.isFriend())
					return !entityHiderConfig.hideFriends();
				if (player.isFriendsChatMember())
					return !entityHiderConfig.hideFriendsChatMembers();
				if (player.isClanMember())
					return !entityHiderConfig.hideClanChatMembers();
				if (client.getIgnoreContainer().findByName(player.getName()) != null)
					return !entityHiderConfig.hideIgnores();

				return !entityHiderConfig.hideOthers();
			}
		}

		return true;
	}

	private boolean shouldShowProjectileLights() {
		return plugin.configProjectileLights && !(pluginManager.isPluginEnabled(entityHiderPlugin) && entityHiderConfig.hideProjectiles());
	}

	public void loadSceneLights(SceneContext sceneContext, @Nullable SceneContext oldSceneContext)
	{
		if (oldSceneContext == null) {
			sceneContext.lights.clear();
			sceneContext.knownProjectiles.clear();
		} else {
			// Copy over NPC and projectile lights from the old scene
			ArrayList<Light> lightsToKeep = new ArrayList<>();
			for (Light light : oldSceneContext.lights)
				if (light.actor != null || light.projectile != null)
					lightsToKeep.add(light);

			sceneContext.lights.addAll(lightsToKeep);
			for (var light : lightsToKeep)
				if (light.projectile != null && oldSceneContext.knownProjectiles.contains(light.projectile))
					sceneContext.knownProjectiles.add(light.projectile);
		}

		for (Light light : WORLD_LIGHTS) {
			assert light.worldPoint != null;
			if (sceneContext.sceneBounds.contains(light.worldPoint))
				addWorldLight(sceneContext, light);
		}

		for (Tile[][] plane : sceneContext.scene.getExtendedTiles()) {
			for (Tile[] column : plane) {
				for (Tile tile : column) {
					if (tile == null)
						continue;

					DecorativeObject decorativeObject = tile.getDecorativeObject();
					if (decorativeObject != null)
						handleObjectSpawn(sceneContext, decorativeObject);

					WallObject wallObject = tile.getWallObject();
					if (wallObject != null)
						handleObjectSpawn(sceneContext, wallObject);

					GroundObject groundObject = tile.getGroundObject();
					if (groundObject != null && groundObject.getRenderable() != null)
						handleObjectSpawn(sceneContext, groundObject);

					for (GameObject gameObject : tile.getGameObjects()) {
						// Skip nulls, players & NPCs
						if (gameObject == null || gameObject.getRenderable() instanceof Actor)
							continue;

						handleObjectSpawn(sceneContext, gameObject);
					}
				}
			}
		}

		// Force lights to instantly appear when spawning them as part of a new scene
		for (var light : sceneContext.lights)
			light.fadeInDuration = 0;

		// Set the plane to an unreachable plane, forcing the first `toggleTemporaryVisibility` call to not fade
		currentPlane = -1;
	}

	private void removeLightIf(Predicate<Light> predicate) {
		var sceneContext = plugin.getSceneContext();
		if (sceneContext == null)
			return;
		removeLightIf(sceneContext, predicate);
	}

	private void removeLightIf(@Nonnull SceneContext sceneContext, Predicate<Light> predicate) {
		for (var light : sceneContext.lights)
			if (predicate.test(light))
				light.markedForRemoval = true;
	}

	private void addSpotanimLights(Actor actor) {
		var sceneContext = plugin.getSceneContext();
		if (sceneContext == null)
			return;

		int[] worldPos = sceneContext.localToWorld(actor.getLocalLocation());

		for (var spotAnim : actor.getSpotAnims()) {
			int spotAnimId = spotAnim.getId();
			for (var def : GRAPHICS_OBJECT_LIGHTS.get(spotAnim.getId())) {
				if (def.areas.length > 0) {
					boolean isInArea = Arrays.stream(def.areas).anyMatch(aabb -> aabb.contains(worldPos));
					if (!isInArea)
						continue;
				}
				if (def.excludeAreas.length > 0) {
					boolean isInArea = Arrays.stream(def.excludeAreas).anyMatch(aabb -> aabb.contains(worldPos));
					if (isInArea)
						continue;
				}

				boolean isDuplicate = sceneContext.lights.stream()
					.anyMatch(light ->
						light.spotanimId == spotAnimId &&
						light.actor == actor &&
						light.def == def);
				if (isDuplicate)
					continue;

				Light light = new Light(def);
				light.plane = -1;
				light.spotanimId = spotAnimId;
				light.actor = actor;
				sceneContext.lights.add(light);
			}
		}
	}

	private void addNpcLights(NPC npc)
	{
		var sceneContext = plugin.getSceneContext();
		if (sceneContext == null)
			return;

		int uuid = ModelHash.packUuid(ModelHash.TYPE_NPC, npc.getId());
		int[] worldPos = sceneContext.localToWorld(npc.getLocalLocation());

		var modelOverride = modelOverrideManager.getOverride(uuid, worldPos);
		if (modelOverride.hide)
			return;

		for (LightDefinition def : NPC_LIGHTS.get(npc.getId())) {
			if (def.areas.length > 0) {
				boolean isInArea = Arrays.stream(def.areas).anyMatch(aabb -> aabb.contains(worldPos));
				if (!isInArea)
					continue;
			}
			if (def.excludeAreas.length > 0) {
				boolean isInArea = Arrays.stream(def.excludeAreas).anyMatch(aabb -> aabb.contains(worldPos));
				if (isInArea)
					continue;
			}

			// Prevent duplicate lights from being spawned for the same NPC
			boolean isDuplicate = sceneContext.lights.stream()
				.anyMatch(light ->
					light.actor == npc &&
					light.def == def &&
					!light.markedForRemoval);
			if (isDuplicate)
				continue;

			Light light = new Light(def);
			light.plane = -1;
			light.actor = npc;
			sceneContext.lights.add(light);
		}
	}

	private void handleObjectSpawn(TileObject object) {
		var sceneContext = plugin.getSceneContext();
		if (sceneContext != null)
			handleObjectSpawn(sceneContext, object);
	}

	private int getImpostorId(TileObject tileObject) {
		ObjectComposition def = client.getObjectDefinition(tileObject.getId());
		var impostorIds = def.getImpostorIds();
		if (impostorIds != null) {
			try {
				int impostorVarbit = def.getVarbitId();
				int impostorVarp = def.getVarPlayerId();
				int impostorIndex = -1;
				if (impostorVarbit != -1) {
					impostorIndex = client.getVarbitValue(impostorVarbit);
				} else if (impostorVarp != -1) {
					impostorIndex = client.getVarpValue(impostorVarp);
				}
				if (impostorIndex >= 0)
					return impostorIds[min(impostorIndex, impostorIds.length - 1)];
			} catch (Exception ex) {
				log.debug("Error getting impostor:", ex);
			}
		}
		return tileObject.getId();
	}

	public void handleObjectSpawn(
		@Nonnull SceneContext sceneContext,
		@Nonnull TileObject tileObject
	) {
		// prevent objects at plane -1 and below from having lights
		if (tileObject.getPlane() < 0)
			return;

		// GameObjects with DynamicObject renderables may be impostors, so handle those in swapScene
		int tileObjectId = tileObject.getId();
		if (tileObject instanceof GameObject &&
			((GameObject) tileObject).getRenderable() instanceof DynamicObject
		) {
			if (client.isClientThread()) {
				tileObjectId = getImpostorId(tileObject);
			} else {
				sceneContext.lightSpawnsToHandleOnClientThread.add(tileObject);
				return;
			}
		}

		sceneContext.lights.removeIf(light -> light.tileObject == tileObject);
		spawnLights(sceneContext, tileObject, tileObjectId);
	}

	private void handleObjectDespawn(TileObject tileObject) {
		var sceneContext = plugin.getSceneContext();
		if (sceneContext == null)
			return;

		int impostorId = getImpostorId(tileObject);
		removeLightIf(sceneContext, l -> l.tileObject == tileObject && l.tileObjectId == impostorId);
	}

	private void spawnLights(@Nonnull SceneContext sceneContext, TileObject tileObject, int impostorId) {
		int sizeX = 1;
		int sizeY = 1;
		int[] orientations = { 0, 0 };
		int[] offset = { 0, 0 };

		if (tileObject instanceof GroundObject) {
			var object = (GroundObject) tileObject;
			imposterRenderables[0] = object.getRenderable();
			orientations[0] = HDUtils.getModelOrientation(object.getConfig());
		} else if (tileObject instanceof DecorativeObject) {
			var object = (DecorativeObject) tileObject;
			imposterRenderables[0] = object.getRenderable();
			imposterRenderables[1] = object.getRenderable2();
			int ori = orientations[0] = orientations[1] = HDUtils.getModelOrientation(object.getConfig());
			switch (ObjectType.fromConfig(object.getConfig())) {
				case WallDecorDiagonalNoOffset:
				case WallDecorDiagonalOffset:
				case WallDecorDiagonalBoth:
					ori = (ori + 512) % 2048;
					offset[0] = SINE[ori] * 64 >> 16;
					offset[1] = COSINE[ori] * 64 >> 16;
					break;
			}
			offset[0] += object.getXOffset();
			offset[1] += object.getYOffset();
		} else if (tileObject instanceof WallObject) {
			var object = (WallObject) tileObject;
			imposterRenderables[0] = object.getRenderable1();
			imposterRenderables[1] = object.getRenderable2();
			orientations[0] = HDUtils.convertWallObjectOrientation(object.getOrientationA());
			orientations[1] = HDUtils.convertWallObjectOrientation(object.getOrientationB());
		} else if (tileObject instanceof GameObject) {
			var object = (GameObject) tileObject;
			sizeX = object.sizeX();
			sizeY = object.sizeY();
			imposterRenderables[0] = object.getRenderable();
			int ori = orientations[0] = HDUtils.getModelOrientation(object.getConfig());
			int offsetDist = 64;
			switch (ObjectType.fromConfig(object.getConfig())) {
				case RoofEdgeDiagonalCorner:
				case RoofDiagonalWithRoofEdge:
					ori += 1024;
					offsetDist = round(offsetDist / sqrt(2));
				case WallDiagonal:
					ori = (ori + 2048 - 256) % 2048;
					offset[0] = SINE[ori] * offsetDist >> 16;
					offset[1] = COSINE[ori] * offsetDist >> 16;
					break;
			}
		} else {
			log.warn("Unhandled TileObject type: id: {}, hash: {}", tileObject.getId(), tileObject.getHash());
			return;
		}

		List<LightDefinition> lights = OBJECT_LIGHTS.get(impostorId == -1 ? tileObject.getId() : impostorId);
		HashSet<LightDefinition> onlySpawnOnce = new HashSet<>();

		LocalPoint lp = tileObject.getLocalLocation();
		int lightX = lp.getX() + offset[0];
		int lightZ = lp.getY() + offset[1];
		int plane = tileObject.getPlane();

		// Spawn animation-specific lights for each DynamicObject renderable, and non-animation-based lights
		for (int i = 0; i < 2; i++) {
			var renderable = imposterRenderables[i];
			if (renderable == null)
				continue;

			for (LightDefinition def : lights) {
				if (def.areas.length > 0) {
					int[] worldPos = sceneContext.localToWorld(lightX, lightZ, plane);
					boolean isInArea = Arrays.stream(def.areas).anyMatch(aabb -> aabb.contains(worldPos));
					if (!isInArea)
						continue;
				}
				if (def.excludeAreas.length > 0) {
					int[] worldPos = sceneContext.localToWorld(lightX, lightZ, plane);
					boolean isInArea = Arrays.stream(def.excludeAreas).anyMatch(aabb -> aabb.contains(worldPos));
					if (isInArea)
						continue;
				}

				// Rarely, it may be necessary to specify which of the two possible renderables the light should be attached to
				if (def.renderableIndex == -1) {
					// If unspecified, spawn it for the first non-null renderable
					if (onlySpawnOnce.contains(def))
						continue;
					onlySpawnOnce.add(def);
				} else if (def.renderableIndex != i) {
					continue;
				}

				int tileExX = clamp(lp.getSceneX() + sceneContext.sceneOffset, 0, EXTENDED_SCENE_SIZE - 2);
				int tileExY = clamp(lp.getSceneY() + sceneContext.sceneOffset, 0, EXTENDED_SCENE_SIZE - 2);
				float lerpX = fract(lightX / (float) LOCAL_TILE_SIZE);
				float lerpZ = fract(lightZ / (float) LOCAL_TILE_SIZE);
				int tileZ = clamp(plane, 0, MAX_Z - 1);

				Tile[][][] tiles = sceneContext.scene.getExtendedTiles();
				Tile tile = tiles[tileZ][tileExX][tileExY];
				if (tile != null && tile.getBridge() != null && tileZ < MAX_Z - 1)
					tileZ++;

				int[][][] tileHeights = sceneContext.scene.getTileHeights();
				float heightNorth = mix(
					tileHeights[tileZ][tileExX][tileExY + 1],
					tileHeights[tileZ][tileExX + 1][tileExY + 1],
					lerpX
				);
				float heightSouth = mix(
					tileHeights[tileZ][tileExX][tileExY],
					tileHeights[tileZ][tileExX + 1][tileExY],
					lerpX
				);
				float tileHeight = mix(heightSouth, heightNorth, lerpZ);

				Light light = new Light(def);
				light.tileObject = tileObject;
				light.tileObjectId = impostorId;
				light.plane = plane;
				light.orientation = orientations[i];
				light.origin[0] = lightX;
				light.origin[1] = (int) tileHeight - light.def.height - 1;
				light.origin[2] = lightZ;
				light.sizeX = sizeX;
				light.sizeY = sizeY;
				sceneContext.lights.add(light);
			}
		}
	}

	private void addWorldLight(SceneContext sceneContext, Light light) {
		assert light.worldPoint != null;
		sceneContext.worldToLocals(light.worldPoint).forEach(local -> {
			int tileExX = local[0] / LOCAL_TILE_SIZE + sceneContext.sceneOffset;
			int tileExY = local[1] / LOCAL_TILE_SIZE + sceneContext.sceneOffset;
			if (tileExX < 0 || tileExY < 0 || tileExX >= EXTENDED_SCENE_SIZE || tileExY >= EXTENDED_SCENE_SIZE)
				return;

			var copy = new Light(light.def);
			copy.plane = local[2];
			copy.persistent = light.persistent;
			copy.origin[0] = local[0] + LOCAL_HALF_TILE_SIZE;
			copy.origin[1] = sceneContext.scene.getTileHeights()[local[2]][tileExX][tileExY] - copy.def.height - 1;
			copy.origin[2] = local[1] + LOCAL_HALF_TILE_SIZE;
			sceneContext.lights.add(copy);
		});
	}

	@Subscribe
	public void onProjectileMoved(ProjectileMoved projectileMoved) {
		SceneContext sceneContext = plugin.getSceneContext();
		if (sceneContext == null)
			return;

		// Since there's no spawn & despawn events for projectiles, add when they move for the first time
		Projectile projectile = projectileMoved.getProjectile();
		if (!sceneContext.knownProjectiles.add(projectile))
			return;

		int[] worldPos = sceneContext.localToWorld((int) projectile.getX(), (int) projectile.getY(), projectile.getFloor());

		int[] refCounter = { 0 };
		for (LightDefinition def : PROJECTILE_LIGHTS.get(projectile.getId())) {
			if (def.areas.length > 0) {
				boolean isInArea = Arrays.stream(def.areas).anyMatch(aabb -> aabb.contains(worldPos));
				if (!isInArea)
					continue;
			}
			if (def.excludeAreas.length > 0) {
				boolean isInArea = Arrays.stream(def.excludeAreas).anyMatch(aabb -> aabb.contains(worldPos));
				if (isInArea)
					continue;
			}

			Light light = new Light(def);
			light.projectile = projectile;
			light.projectileRefCounter = refCounter;
			refCounter[0]++;
			light.origin[0] = (int) projectile.getX();
			light.origin[1] = (int) projectile.getZ();
			light.origin[2] = (int) projectile.getY();
			light.plane = projectile.getFloor();

			sceneContext.lights.add(light);
		}
	}

	@Subscribe
	public void onNpcSpawned(NpcSpawned spawn) {
		NPC npc = spawn.getNpc();
		addNpcLights(npc);
		addSpotanimLights(npc);
	}

	@Subscribe
	public void onNpcChanged(NpcChanged change) {
		// Respawn non-spotanim lights
		NPC npc = change.getNpc();
		removeLightIf(light -> light.actor == npc && light.spotanimId == -1);
		addNpcLights(change.getNpc());
	}

	@Subscribe
	public void onNpcDespawned(NpcDespawned despawn) {
		NPC npc = despawn.getNpc();
		removeLightIf(light -> light.actor == npc);
	}

	@Subscribe
	public void onPlayerSpawned(PlayerSpawned spawn) {
		addSpotanimLights(spawn.getPlayer());
	}

	@Subscribe
	public void onPlayerChanged(PlayerChanged change) {
		// Don't add spotanim lights on player change events, since it breaks death & respawn lights
	}

	@Subscribe
	public void onGraphicChanged(GraphicChanged change) {
		addSpotanimLights(change.getActor());
	}

	@Subscribe
	public void onPlayerDespawned(PlayerDespawned despawn) {
		Player player = despawn.getPlayer();
		removeLightIf(light -> light.actor == player);
	}

	@Subscribe
	public void onGraphicsObjectCreated(GraphicsObjectCreated graphicsObjectCreated) {
		SceneContext sceneContext = plugin.getSceneContext();
		if (sceneContext == null)
			return;

		GraphicsObject graphicsObject = graphicsObjectCreated.getGraphicsObject();
		var lp = graphicsObject.getLocation();
		int[] worldPos = sceneContext.localToWorld(lp, graphicsObject.getLevel());

		for (LightDefinition def : GRAPHICS_OBJECT_LIGHTS.get(graphicsObject.getId())) {
			if (def.areas.length > 0) {
				boolean isInArea = Arrays.stream(def.areas).anyMatch(aabb -> aabb.contains(worldPos));
				if (!isInArea)
					continue;
			}
			if (def.excludeAreas.length > 0) {
				boolean isInArea = Arrays.stream(def.excludeAreas).anyMatch(aabb -> aabb.contains(worldPos));
				if (isInArea)
					continue;
			}

			Light light = new Light(def);
			light.graphicsObject = graphicsObject;
			light.origin[0] = lp.getX();
			light.origin[1] = graphicsObject.getZ();
			light.origin[2] = lp.getY();
			light.plane = worldPos[2];
			sceneContext.lights.add(light);
		}
	}

	@Subscribe
	public void onGameObjectSpawned(GameObjectSpawned spawn) {
		handleObjectSpawn(spawn.getGameObject());
	}

	@Subscribe
	public void onGameObjectDespawned(GameObjectDespawned despawn) {
		handleObjectDespawn(despawn.getGameObject());
	}

	@Subscribe
	public void onWallObjectSpawned(WallObjectSpawned spawn) {
		handleObjectSpawn(spawn.getWallObject());
	}

	@Subscribe
	public void onWallObjectDespawned(WallObjectDespawned despawn) {
		handleObjectDespawn(despawn.getWallObject());
	}

	@Subscribe
	public void onDecorativeObjectSpawned(DecorativeObjectSpawned spawn) {
		handleObjectSpawn(spawn.getDecorativeObject());
	}

	@Subscribe
	public void onDecorativeObjectDespawned(DecorativeObjectDespawned despawn) {
		handleObjectDespawn(despawn.getDecorativeObject());
	}

	@Subscribe
	public void onGroundObjectSpawned(GroundObjectSpawned spawn) {
		handleObjectSpawn(spawn.getGroundObject());
	}

	@Subscribe
	public void onGroundObjectDespawned(GroundObjectDespawned despawn) {
		handleObjectDespawn(despawn.getGroundObject());
	}

	// TODO: Check whether this is still necessary. If so, we could track varbits/varps within each light
//	@Subscribe
//	public void onVarbitChanged(VarbitChanged event) {
//		var ctx = plugin.getSceneContext();
//		if (!(ctx instanceof LegacySceneContext))
//			return;
//		var sceneContext = (LegacySceneContext) ctx;
//
//		if (plugin.enableDetailedTimers)
//			frameTimer.begin(Timer.IMPOSTOR_TRACKING);
//		// Check if the event is specifically a varbit change first,
//		// since all varbit changes are necessarily also varp changes
//		if (event.getVarbitId() != -1) {
//			for (var tracker : sceneContext.trackedVarbits.get(event.getVarbitId()))
//				trackImpostorChanges(sceneContext, tracker);
//		} else if (event.getVarpId() != -1) {
//			for (var tracker : sceneContext.trackedVarps.get(event.getVarpId()))
//				trackImpostorChanges(sceneContext, tracker);
//		}
//		if (plugin.enableDetailedTimers)
//			frameTimer.end(Timer.IMPOSTOR_TRACKING);
//	}
}

package rs117.hd.scene.lights;

public enum Alignment
{
	CUSTOM(0, false, true),
	@Deprecated
	CENTER(0, false, false),

	NORTH(0, true, false),
	NORTHEAST(256, true, false),
	NORTHEAST_CORNER(256, false, false),
	EAST(512, true, false),
	SOUTHEAST(768, true, false),
	SOUTHEAST_CORNER(768, false, false),
	SOUTH(1024, true, false),
	SOUTHWEST(1280, true, false),
	SOUTHWEST_CORNER(1280, false, false),
	WEST(1536, true, false),
	NORTHWEST(1792, true, false),
	NORTHWEST_CORNER(1792, false, false),

	BACK(0, true, true),
	BACKLEFT(256, true, true),
	BACKLEFT_CORNER(256, false, true),
	LEFT(512, true, true),
	FRONTLEFT(768, true, true),
	FRONTLEFT_CORNER(768, false, true),
	FRONT(1024, true, true),
	FRONTRIGHT(1280, true, true),
	FRONTRIGHT_CORNER(1280, false, true),
	RIGHT(1536, true, true),
	BACKRIGHT(1792, true, true),
	BACKRIGHT_CORNER(1792, false, true);

	public final int orientation;
	public final boolean radial;
	public final boolean relative;

	Alignment(int orientation, boolean radial, boolean relative)
	{
		this.orientation = orientation;
		this.radial = radial;
		this.relative = relative;
	}
}

package rs117.hd.scene.lights;

import net.runelite.api.*;
import net.runelite.api.coords.*;

import static rs117.hd.utils.MathUtils.*;

public class Light
{
	public static final float VISIBILITY_FADE = 0.1f;

	public final float randomOffset = RAND.nextFloat();
	public final LightDefinition def;

	public float radius;
	public float strength;
	/**
	 * Linear color space RGBA in the range [0, 1]
	 */
	public float[] color;
	public float animation = 0.5f;
	public float duration;
	public float fadeInDuration;
	public float fadeOutDuration;
	public float spawnDelay;
	public float despawnDelay;

	public boolean visible;
	public boolean parentExists;
	public boolean withinViewingDistance = true;
	public boolean hiddenTemporarily;
	public boolean markedForRemoval;
	public boolean persistent;
	public boolean replayable;

	public final boolean animationSpecific;
	public final boolean dynamicLifetime;

	public float elapsedTime;
	public float changedVisibilityAt = -1;
	public float lifetime = -1;

	public WorldPoint worldPoint;
	public boolean belowFloor;
	public boolean aboveFloor;
	public int plane;
	public int prevPlane = -1;
	public Alignment alignment;
	public float[] origin = new float[3];
	public float[] offset = new float[3];
	public float[] pos = new float[3];
	public int orientation;
	public float distanceSquared;

	public Actor actor;
	public Projectile projectile;
	public TileObject tileObject;
	public GraphicsObject graphicsObject;
	public int tileObjectId;
	public int spotanimId = -1;
	public int[] projectileRefCounter;

	public int sizeX = 1;
	public int sizeY = 1;

	public Light(LightDefinition def) {
		this.def = def;
		copyTo(offset, def.offset);
		duration = max(0, def.duration) / 1000f;
		fadeInDuration = max(0, def.fadeInDuration) / 1000f;
		fadeOutDuration = max(0, def.fadeOutDuration) / 1000f;
		spawnDelay = max(0, def.spawnDelay) / 1000f;
		despawnDelay = max(0, def.despawnDelay) / 1000f;
		color = def.color;
		radius = def.radius;
		strength = def.strength;
		alignment = def.alignment;
		plane = def.plane;
		if (def.type == LightType.PULSE)
			animation = (float) Math.random();

		// Old way of setting a fixed lifetime
		if (def.fixedDespawnTime)
			lifetime = spawnDelay + despawnDelay;

		if (lifetime == -1) {
			dynamicLifetime = true;
			// If the despawn is dynamic, ensure there's enough time for the light to fade out
			despawnDelay = max(despawnDelay, fadeOutDuration);
		} else {
			dynamicLifetime = false;
		}

		animationSpecific = !def.animationIds.isEmpty();
		if (animationSpecific) {
			persistent = replayable = true;
			// Initially hide the light
			if (dynamicLifetime) {
				lifetime = 0;
			} else {
				elapsedTime = lifetime;
			}
		}
	}

	public void toggleTemporaryVisibility(boolean changedPlanes) {
		hiddenTemporarily = !hiddenTemporarily;
		// If visibility changes due to something other than changing planes, fade in or out
		if (!changedPlanes) {
			// Begin fading in or out, while accounting for time already spent fading out or in respectively
			float beginFadeAt = elapsedTime;
			if (changedVisibilityAt != -1)
				beginFadeAt -= max(0, VISIBILITY_FADE - (elapsedTime - changedVisibilityAt));
			changedVisibilityAt = beginFadeAt;
		}
	}

	public float getTemporaryVisibilityFade() {
		float fade = 1;
		if (changedVisibilityAt != -1)
			fade = saturate((elapsedTime - changedVisibilityAt) / Light.VISIBILITY_FADE);
		if (hiddenTemporarily)
			fade = 1 - fade; // Fade out instead
		return fade;
	}

	public void applyTemporaryVisibilityFade() {
		strength *= getTemporaryVisibilityFade();
	}
}

package rs117.hd.scene.lights;

import com.google.gson.annotations.JsonAdapter;
import java.util.HashSet;
import javax.annotation.Nullable;
import rs117.hd.scene.GamevalManager;
import rs117.hd.scene.areas.AABB;
import rs117.hd.utils.ColorUtils;

public class LightDefinition {
	public String description;
	@Nullable
	public Integer worldX, worldY;
	public int plane;
	public Alignment alignment = Alignment.CUSTOM;
	public float[] offset = new float[3];
	public int height;
	public int radius = 300;
	public float strength = 5;
	@JsonAdapter(ColorUtils.SrgbToLinearAdapter.class)
	public float[] color;
	public LightType type = LightType.STATIC;
	public float duration;
	public float range;
	public int fadeInDuration = 50;
	public int fadeOutDuration = 50;
	public int spawnDelay;
	public int despawnDelay;
	public boolean fixedDespawnTime;
	public boolean visibleFromOtherPlanes;
	public boolean ignoreActorHiding;
	public int renderableIndex = -1;

	@JsonAdapter(AABB.ArrayAdapter.class)
	public AABB[] areas = {};
	@JsonAdapter(AABB.ArrayAdapter.class)
	public AABB[] excludeAreas = {};
	@JsonAdapter(GamevalManager.NpcAdapter.class)
	public HashSet<Integer> npcIds = new HashSet<>();
	@JsonAdapter(GamevalManager.ObjectAdapter.class)
	public HashSet<Integer> objectIds = new HashSet<>();
	@JsonAdapter(GamevalManager.SpotanimAdapter.class)
	public HashSet<Integer> projectileIds = new HashSet<>();
	@JsonAdapter(GamevalManager.SpotanimAdapter.class)
	public HashSet<Integer> graphicsObjectIds = new HashSet<>();
	@JsonAdapter(GamevalManager.AnimationAdapter.class)
	public HashSet<Integer> animationIds = new HashSet<>();

	public void normalize() {
		if (description == null)
			description = "N/A";
		if (alignment == null || alignment == Alignment.CENTER)
			alignment = Alignment.CUSTOM;
		if (offset == null || offset.length != 3) {
			offset = new float[3];
		} else {
			offset[1] *= -1;
		}
		if (color == null || color.length != 3)
			color = new float[3];
		if (type == null)
			type = LightType.STATIC;
	}
}

package rs117.hd.scene.lights;

public enum LightType
{
	STATIC, FLICKER, PULSE
}

package rs117.hd.scene.lights;

import javax.annotation.Nullable;
import net.runelite.api.*;
import net.runelite.api.coords.*;

public class TileObjectImpostorTracker {
	public TileObject tileObject;
	public final long tileObjectHash;
	public boolean justSpawned = true;
	public boolean spawnedAnyLights;
	public int[] impostorIds;
	public int impostorVarbit = -1;
	public int impostorVarp = -1;
	public int impostorId = -1;

	public TileObjectImpostorTracker(TileObject tileObject) {
		this.tileObject = tileObject;
		this.tileObjectHash = tileObjectHash(tileObject);
	}

	public long lightHash(int impostorId) {
		long hash = this.tileObjectHash;
		hash = hash * 31 + impostorId;
		return hash;
	}

	private static long tileObjectHash(@Nullable TileObject tileObject) {
		if (tileObject == null)
			return 0;

		LocalPoint lp = tileObject.getLocalLocation();
		long hash = lp.getX();
		hash = hash * 31 + lp.getY();
		hash = hash * 31 + tileObject.getPlane();
		hash = hash * 31 + tileObject.getId();
		return hash;
	}
}

/*
 * Copyright (c) 2025, Hooder <ahooder@protonmail.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package rs117.hd.scene;

import com.google.gson.JsonArray;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import java.io.IOException;
import java.util.ArrayDeque;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.Set;
import java.util.stream.Stream;
import javax.inject.Inject;
import javax.inject.Singleton;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.*;
import net.runelite.client.callback.ClientThread;
import org.lwjgl.opengl.*;
import rs117.hd.HdPlugin;
import rs117.hd.HdPluginConfig;
import rs117.hd.opengl.uniforms.UBOMaterials;
import rs117.hd.renderer.zone.SceneManager;
import rs117.hd.scene.materials.Material;
import rs117.hd.utils.ExpressionParser;
import rs117.hd.utils.FileWatcher;
import rs117.hd.utils.HDVariables;
import rs117.hd.utils.Props;
import rs117.hd.utils.ResourcePath;

import static org.lwjgl.opengl.GL33C.*;
import static rs117.hd.HdPlugin.TEXTURE_UNIT_GAME;
import static rs117.hd.utils.MathUtils.*;
import static rs117.hd.utils.ResourcePath.path;

@Slf4j
@Singleton
public class MaterialManager {
	private static final ResourcePath MATERIALS_PATH = Props
		.getFile("rlhd.materials-path", () -> path(MaterialManager.class, "materials.json"));

	@Inject
	private Client client;

	@Inject
	private ClientThread clientThread;

	@Inject
	private HdPlugin plugin;

	@Inject
	private HdPluginConfig config;

	@Inject
	private HDVariables vars;

	@Inject
	private TextureManager textureManager;

	@Inject
	private WaterTypeManager waterTypeManager;

	@Inject
	private GroundMaterialManager groundMaterialManager;

	@Inject
	private TileOverrideManager tileOverrideManager;

	@Inject
	private ModelOverrideManager modelOverrideManager;

	@Inject
	private SceneManager sceneManager;

	public UBOMaterials uboMaterials;

	public static class TextureLayer {
		Material material;
		boolean needsUpload = true;
	}

	public static final Map<String, Material> MATERIAL_MAP = new HashMap<>();
	public static Material[] MATERIALS;
	public static Material[] VANILLA_TEXTURE_MAPPING;

	private int texMaterialTextureArray;
	private int[] textureResolution;
	public final List<TextureLayer> textureLayers = new ArrayList<>();

	private FileWatcher.UnregisterCallback fileWatcher;

	public void startUp() {
		fileWatcher = MATERIALS_PATH.watch((path, isFirst) -> reload(isFirst));
	}

	public void shutDown() {
		if (fileWatcher != null)
			fileWatcher.unregister();
		fileWatcher = null;

		if (texMaterialTextureArray != 0)
			glDeleteTextures(texMaterialTextureArray);
		texMaterialTextureArray = 0;
		textureLayers.clear();

		if (uboMaterials != null)
			uboMaterials.destroy();
		uboMaterials = null;

		MATERIAL_MAP.clear();
		invalidateMaterials(MATERIALS);
		MATERIALS = VANILLA_TEXTURE_MAPPING = null;
	}

	public Material getMaterial(String name) {
		var mat = MATERIAL_MAP.get(name);
		if (mat != null)
			return mat;
		log.warn("Couldn't find material '{}', falling back to NONE", name);
		return Material.NONE;
	}

	public Material fromVanillaTexture(int vanillaTextureId) {
		if (vanillaTextureId < 0 || vanillaTextureId >= VANILLA_TEXTURE_MAPPING.length)
			return Material.NONE;
		return VANILLA_TEXTURE_MAPPING[vanillaTextureId];
	}

	public void reload(boolean skipSceneReload) {
		Material[] materials;
		try {
			materials = loadMaterials(MATERIALS_PATH);
			log.debug("Loaded {} materials", materials.length);
		} catch (IOException ex) {
			throw new IllegalStateException("Failed to load materials:", ex);
		}

		clientThread.invoke(() -> {
			try {
				sceneManager.getLoadingLock().lock();
				sceneManager.completeAllStreaming();
				swapMaterials(materials, skipSceneReload);
			} finally {
				sceneManager.getLoadingLock().unlock();
				log.trace("loadingLock unlocked - holdCount: {}", sceneManager.getLoadingLock().getHoldCount());
			}
		});
	}

	private Material[] loadMaterials(ResourcePath path) throws IOException {
		// Gson provides no simple way to let one object inherit defaults from another object,
		// so we parse the JSON manually into a JsonArray, which we can process to copy default
		// values from parent materials in the correct order.
		var gson = plugin.getGson();
		var rawMaterials = path.loadJson(gson, JsonArray.class);
		if (rawMaterials == null)
			throw new IOException("Empty or invalid: " + path);

		var rawMaterialMap = new HashMap<String, JsonObject>();
		var materialToParentMap = new HashMap<String, String>();

		var validMaterials = new ArrayList<JsonObject>();
		for (var element : rawMaterials) {
			if (!element.isJsonObject()) {
				log.error("Invalid material. Expected an object. Got: '{}'", element);
				continue;
			}

			var mat = element.getAsJsonObject();
			var name = mat.get("name");
			if (name == null) {
				log.error("Material missing name: '{}'", mat);
				continue;
			}
			if (!name.isJsonPrimitive() || !name.getAsJsonPrimitive().isString()) {
				log.error("Material name is not a string: '{}'", mat);
				continue;
			}

			var parent = mat.get("parent");
			if (parent != null && (!parent.isJsonPrimitive() || !parent.getAsJsonPrimitive().isString())) {
				log.error("Error in material '{}': Invalid parent name: '{}'", name.getAsString(), parent);
				continue;
			}

			if (rawMaterialMap.putIfAbsent(name.getAsString(), mat) != null) {
				log.error("Duplicate material name: '{}'", name);
				continue;
			}

			validMaterials.add(mat);
			if (parent != null)
				materialToParentMap.put(name.getAsString(), parent.getAsString());
		}

		// Check for parent loops
		var iter = materialToParentMap.entrySet().iterator();
		while (iter.hasNext()) {
			var entry = iter.next();
			var original = entry.getKey();
			var current = entry.getValue();
			while ((current = materialToParentMap.get(current)) != null) {
				if (current.equals(original)) {
					log.error("Material '{}' contains a parent loop. Removing its parent...", original);
					rawMaterialMap.get(original).remove("parent"); // Remove parent in-place
					iter.remove(); // No longer has a parent
				}
			}
		}

		// Recursively resolve parents and apply default values from them
		for (var mat : rawMaterialMap.values()) {
			var parent = mat;
			JsonElement parentField;
			while ((parentField = parent.get("parent")) != null) {
				if (!parentField.isJsonPrimitive() || !parentField.getAsJsonPrimitive().isString()) {
					log.error("Error in material '{}': Invalid parent name '{}'", parent.get("name").getAsString(), parentField);
					break;
				}
				String parentName = parentField.getAsString();
				// Don't allow inheriting from NONE. Those defaults will be inherited anyway
				if (parentName.equals(Material.NONE.name))
					break;

				var nextParent = rawMaterialMap.get(parentName);
				if (nextParent == null) {
					log.error(
						"Error in material '{}': Unknown parent name '{}'",
						parent.get("name").getAsString(),
						parentField.getAsString()
					);
					break;
				}

				for (var entry : nextParent.entrySet())
					if (!mat.has(entry.getKey()))
						mat.add(entry.getKey(), entry.getValue());

				parent = nextParent;
			}
		}

		var materialsToParse = new JsonArray();
		for (var mat : validMaterials)
			materialsToParse.add(mat);

		var materials = Stream.concat(
			Arrays.stream(Material.REQUIRED_MATERIALS),
			Arrays.stream(gson.fromJson(materialsToParse, Material.Definition[].class))
		).toArray(Material[]::new);

		var materialMap = new HashMap<String, Material>();
		int unnamedCounter = 1;
		for (var mat : materials) {
			if (mat.name == null)
				mat.name = "UNNAMED_" + unnamedCounter++;
			materialMap.put(mat.name, mat);

			if (Props.DEVELOPMENT && mat.replacementCondition instanceof ExpressionParser.SerializableExpressionPredicate) {
				// Ensure the variables are defined
				var expr = ((ExpressionParser.SerializableExpressionPredicate) mat.replacementCondition).expression;
				for (var variable : expr.variables)
					if (vars.get(variable) == null)
						throw new IllegalStateException(String.format("Unknown variable '%s' in expression: '%s'", variable, expr));
			}
		}

		for (var mat : materials)
			mat.normalize(materialMap);

		checkForReplacementLoops(materials);
		return materials;
	}

	private void swapMaterials(Material[] parsedMaterials, boolean skipSceneReload) {
		assert client.isClientThread();
		assert textureManager.vanillaTexturesAvailable();

		boolean isFirstLoad = MATERIALS == null;
		var textureProvider = client.getTextureProvider();
		var vanillaTextures = textureProvider.getTextures();
		VANILLA_TEXTURE_MAPPING = new Material[vanillaTextures.length];

		// Arbitrarily account for brightness increase from using unlit colors
		Material.NONE.brightness = plugin.configUnlitFaceColors ? 0.8f : 1;

		// Assemble the material map, accounting for replacements
		MATERIAL_MAP.clear();
		for (var original : parsedMaterials) {
			// If the material is a conditional replacement material, and the condition is not met,
			// the material shouldn't be loaded and can be mapped to NONE
			Material replacement = original;
			if (original.isInactiveReplacement(plugin.vars)) {
				replacement = Material.NONE;
			} else {
				// Apply material replacements from top to bottom
				for (var other : parsedMaterials)
					if (other.replaces(replacement.name, plugin.vars))
						replacement = other;
			}

			MATERIAL_MAP.put(original.name, replacement);

			// Add to vanilla texture mappings if the original was a vanilla replacement
			if (original.isVanillaReplacement()) {
				int i = original.vanillaTextureIndex;
				assert VANILLA_TEXTURE_MAPPING[i] == null || VANILLA_TEXTURE_MAPPING[i] == replacement : String.format(
					"Material %s conflicts with vanilla ID %s of material %s", replacement, i, VANILLA_TEXTURE_MAPPING[i]);
				VANILLA_TEXTURE_MAPPING[i] = replacement;
			}
		}

		// Add dummy materials for any vanilla textures lacking one
		for (int i = 0; i < VANILLA_TEXTURE_MAPPING.length; i++) {
			if (vanillaTextures[i] == null || VANILLA_TEXTURE_MAPPING[i] != null)
				continue;

			var m = new Material()
				.name("VANILLA_" + i)
				.vanillaTextureIndex(i)
				.isFallbackVanillaMaterial(true)
				.hasTransparency(true);
			MATERIAL_MAP.put(m.name, m);
			VANILLA_TEXTURE_MAPPING[i] = m;
		}

		// Gather all unique materials after displacements into an array
		invalidateMaterials(MATERIALS);
		MATERIALS = MATERIAL_MAP.values().stream().distinct().toArray(Material[]::new);
		// Ensure that NONE is the first material
		for (int i = 0; i < MATERIALS.length; i++) {
			if (MATERIALS[i] == Material.NONE) {
				MATERIALS[i] = MATERIALS[0];
				MATERIALS[0] = Material.NONE;
				break;
			}
		}

		// Resolve all texture-owning materials, and update the list of texture layers
		var textureMaterials = Arrays.stream(MATERIALS)
			.map(Material::resolveTextureOwner)
			.distinct()
			.filter(m -> m != Material.NONE)
			.toArray(Material[]::new);
		int previousLayerCount = textureLayers.size();
		int textureLayerIndex = 0;
		for (var mat : textureMaterials) {
			TextureLayer layer;
			if (textureLayerIndex == textureLayers.size()) {
				layer = new TextureLayer();
				textureLayers.add(layer);
			} else {
				layer = textureLayers.get(textureLayerIndex);
				layer.needsUpload = !Objects.equals(mat.getTextureName(), layer.material.getTextureName());
			}
			layer.material = mat;
			mat.textureLayer = textureLayerIndex++;
		}
		// Delete unused layers
		textureLayers.subList(textureLayerIndex, textureLayers.size()).clear();
		// Update texture layers for materials which inherit their texture
		for (var mat : MATERIALS)
			mat.textureLayer = mat.resolveTextureOwner().textureLayer;

		int textureSize = config.textureResolution().getSize();
		textureResolution = ivec(textureSize, textureSize);
		glActiveTexture(TEXTURE_UNIT_GAME);
		if (texMaterialTextureArray == 0 || previousLayerCount != textureLayers.size()) {
			if (texMaterialTextureArray != 0)
				glDeleteTextures(texMaterialTextureArray);
			texMaterialTextureArray = glGenTextures();
			glBindTexture(GL_TEXTURE_2D_ARRAY, texMaterialTextureArray);

			// Since we're reallocating the texture array, all layers need to be reuploaded
			for (var layer : textureLayers)
				layer.needsUpload = true;

			log.debug("Allocating {}x{} texture array with {} layers", textureSize, textureSize, textureLayers.size());
			int mipLevels = 1 + floor(log2(textureSize));
			int format = GL_SRGB8_ALPHA8;
			if (HdPlugin.GL_CAPS.glTexStorage3D != 0) {
				ARBTextureStorage.glTexStorage3D(GL_TEXTURE_2D_ARRAY, mipLevels, format, textureSize, textureSize, textureLayers.size());
			} else {
				// Allocate each mip level separately
				for (int i = 0; i < mipLevels; i++) {
					int size = textureSize >> i;
					glTexImage3D(GL_TEXTURE_2D_ARRAY, i, format, size, size, textureLayers.size(), 0, GL_RGBA, GL_UNSIGNED_BYTE, 0);
				}
			}

			glTexParameteri(GL_TEXTURE_2D_ARRAY, GL_TEXTURE_WRAP_S, GL_REPEAT);
			glTexParameteri(GL_TEXTURE_2D_ARRAY, GL_TEXTURE_WRAP_T, GL_REPEAT);
		}
		textureManager.setAnisotropicFilteringLevel();

		uploadTextures();

		boolean materialOrderChanged = true;
		// TODO: Fix material loading issues with profile switching
//		if (uboMaterials != null && uboMaterials.materials.length == MATERIALS.length) {
//			materialOrderChanged = false;
//			for (int i = 0; i < MATERIALS.length; i++) {
//				var a = MATERIALS[i];
//				var b = uboMaterials.materials[i];
//				if (a.vanillaTextureIndex != b.vanillaTextureIndex ||
//					a.modifiesVanillaTexture != b.modifiesVanillaTexture ||
//					!a.name.equals(b.name)
//				) {
//					materialOrderChanged = true;
//					break;
//				}
//			}
//		} else {
			if (uboMaterials != null)
				uboMaterials.destroy();
			uboMaterials = new UBOMaterials(MATERIALS.length);
//		}
		uboMaterials.update(MATERIALS, vanillaTextures);

		if (isFirstLoad)
			return;

		// Reload anything which depends on Material instances
		waterTypeManager.restart();
		groundMaterialManager.restart();
		tileOverrideManager.reload(true);
		modelOverrideManager.reload();

		if (materialOrderChanged && !skipSceneReload) {
			plugin.renderer.clearCaches();
			plugin.renderer.reloadScene();
			plugin.recompilePrograms();
		}
	}

	private void invalidateMaterials(Material[] materials) {
		// Invalidate old materials to highlight issues with keeping them around accidentally
		if (materials != null)
			for (var mat : materials)
				if (mat != Material.NONE)
					mat.isValid = false;
	}

	public void uploadTextures() {
		assert client.isClientThread();
		if (texMaterialTextureArray == 0)
			return;

		// Set brightness to 1 to upload unmodified vanilla textures
		var textureProvider = client.getTextureProvider();
		double vanillaBrightness = textureProvider.getBrightness();
		textureProvider.setBrightness(1);

		boolean uploadedAnything = false;
		for (var layer : textureLayers) {
			if (!layer.needsUpload)
				continue;

			var material = layer.material;
			var image = textureManager.loadTexture(material.getTextureName(), material.vanillaTextureIndex);
			if (image == null)
				continue;

			try {
				if (!uploadedAnything) {
					glActiveTexture(TEXTURE_UNIT_GAME);
					glBindTexture(GL_TEXTURE_2D_ARRAY, texMaterialTextureArray);
					uploadedAnything = true;
				}
				textureManager.uploadTexture(GL_TEXTURE_2D_ARRAY, material.textureLayer, textureResolution, image);
			} catch (Exception ex) {
				log.error("Failed to upload texture {}:", material, ex);
			}
		}

		// Reset the texture brightness
		textureProvider.setBrightness(vanillaBrightness);

		if (uploadedAnything)
			glGenerateMipmap(GL_TEXTURE_2D_ARRAY);
	}

	private static void checkForReplacementLoops(Material[] materials) {
		Map<String, Material> map = new HashMap<>();
		for (var mat : materials)
			if (!mat.materialsToReplace.isEmpty())
				map.put(mat.name, mat);

		Set<String> alreadyChecked = new HashSet<>();
		for (var mat : map.values())
			checkForReplacementLoops(alreadyChecked, map, mat);
	}

	private static void checkForReplacementLoops(Set<String> alreadyChecked, Map<String, Material> map, Material entryMaterial) {
		if (alreadyChecked.add(entryMaterial.name))
			checkForReplacementLoops(alreadyChecked, map, new ArrayDeque<>(), entryMaterial.name, entryMaterial);
	}

	private static void checkForReplacementLoops(
		Set<String> alreadyChecked,
		Map<String, Material> map,
		ArrayDeque<String> loop,
		String entryPointName,
		Material toCheck
	) {
		loop.addLast(toCheck.findParent(m -> m.materialsToReplace).name);

		for (int i = toCheck.materialsToReplace.size() - 1; i >= 0; i--) {
			String nameToReplace = toCheck.materialsToReplace.get(i);
			// Check if the replacement introduces a loop
			if (entryPointName.equals(nameToReplace)) {
				var original = map.get(nameToReplace).findParent(m -> m.materialsToReplace).name;
				if (!nameToReplace.equals(original))
					nameToReplace += " (parent=" + original + ")";
				log.warn("Materials contain replacement loop: {} -> {}", String.join(" -> ", loop), nameToReplace);
				// Remove the loop
				toCheck.materialsToReplace.remove(i);
				continue;
			}

			var toReplace = map.get(nameToReplace);
			if (toReplace == null)
				continue;

			// Before continuing to check for loops back to the entrypoint name,
			// we need to rule out any loops within the next material to check,
			// so we don't get stuck in a loop there
			checkForReplacementLoops(alreadyChecked, map, toReplace);

			// The replacement might've already been removed to prevent a loop in the step above
			if (!toCheck.materialsToReplace.contains(nameToReplace))
				continue;

			// Check if any further replacements result in a loop
			checkForReplacementLoops(alreadyChecked, map, loop, entryPointName, toReplace);
		}

		loop.removeLast();
	}
}

package rs117.hd.scene.materials;

import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonToken;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.function.Function;
import javax.annotation.Nonnull;
import javax.annotation.Nullable;
import lombok.NoArgsConstructor;
import lombok.Setter;
import lombok.experimental.Accessors;
import lombok.extern.slf4j.Slf4j;
import rs117.hd.opengl.uniforms.UBOMaterials;
import rs117.hd.scene.MaterialManager;
import rs117.hd.scene.model_overrides.ModelOverride;
import rs117.hd.scene.model_overrides.UvType;
import rs117.hd.utils.ColorUtils;
import rs117.hd.utils.ExpressionParser;
import rs117.hd.utils.ExpressionPredicate;
import rs117.hd.utils.GsonUtils;
import rs117.hd.utils.HDVariables;
import rs117.hd.utils.Props;

import static rs117.hd.utils.MathUtils.*;

@Slf4j
@Setter
@Accessors(fluent = true)
@JsonAdapter(Material.Adapter.class)
@NoArgsConstructor
public class Material {
	public String name;
	@JsonAdapter(Reference.Adapter.class)
	protected Material parent;
	public int vanillaTextureIndex = -1;

	@JsonAdapter(Reference.Adapter.class)
	private Material normalMap;
	@JsonAdapter(Reference.Adapter.class)
	private Material displacementMap;
	@JsonAdapter(Reference.Adapter.class)
	private Material roughnessMap;
	@JsonAdapter(Reference.Adapter.class)
	private Material ambientOcclusionMap;
	@JsonAdapter(Reference.Adapter.class)
	private Material flowMap;
	public boolean hasTransparency;
	private boolean overrideBaseColor;
	private boolean unlit;
	@JsonAdapter(ColorUtils.LinearAdapter.class)
	public float brightness = 1;
	private float displacementScale = .1f;
	private float flowMapStrength;
	private float[] flowMapDuration = { 0, 0 };
	private float specularStrength;
	private float specularGloss;
	private float[] scrollSpeed = { 0, 0 };
	private float[] textureScale = { 1, 1, 1 };
	public List<String> materialsToReplace = Collections.emptyList();
	@JsonAdapter(ExpressionParser.PredicateAdapter.class)
	public ExpressionPredicate replacementCondition;

	public transient int uboIndex;
	public transient int textureLayer = -1;
	public transient boolean modifiesVanillaTexture;
	public transient boolean isFallbackVanillaMaterial;
	public transient boolean isValid = true;

	public static final int MAX_MATERIAL_INDEX = (1 << 12) - 1;
	public static final Material NONE = new Material().name("NONE");
	public static final Material[] REQUIRED_MATERIALS = { NONE };

	public static int getTextureLayer(@Nullable Material material) {
		return material == null ? -1 : material.textureLayer;
	}

	public static boolean hasVanillaTransparency(int vanillaTextureId) {
		if (vanillaTextureId < 0 || vanillaTextureId >= MaterialManager.VANILLA_TEXTURE_MAPPING.length)
			return false;
		return MaterialManager.VANILLA_TEXTURE_MAPPING[vanillaTextureId].hasTransparency;
	}

	public void normalize(Map<String, Material> materials) {
		parent = resolveReference(parent, materials);
		if (parent == this) {
			parent = null;
		} else if (parent != null) {
			parent.normalize(materials);
		}

		normalMap = resolveReference(normalMap, materials);
		displacementMap = resolveReference(displacementMap, materials);
		roughnessMap = resolveReference(roughnessMap, materials);
		ambientOcclusionMap = resolveReference(ambientOcclusionMap, materials);
		flowMap = resolveReference(flowMap, materials);

		if (displacementScale == 0)
			displacementMap = NONE.displacementMap;
		flowMapDuration = ensureDefaults(flowMapDuration, NONE.flowMapDuration);
		scrollSpeed = ensureDefaults(scrollSpeed, NONE.scrollSpeed);
		textureScale = ensureDefaults(textureScale, NONE.textureScale);

		if (!materialsToReplace.isEmpty() && materialsToReplace.removeIf(Objects::isNull))
			log.error("Error in material '{}': Null is not allowed as a replacement material", this);

		// Unwrap the predicate in release mode, since it never needs to be serialized
		if (!Props.DEVELOPMENT && replacementCondition instanceof ExpressionParser.SerializableExpressionPredicate)
			replacementCondition = ((ExpressionParser.SerializableExpressionPredicate) replacementCondition).predicate;

		// Determine whether the material contains some form of non-vanilla texture change
		var base = this;
		while (base.parent != null)
			base = base.parent;
		modifiesVanillaTexture =
			base != NONE ||
			normalMap != null ||
			displacementMap != null ||
			roughnessMap != null ||
			ambientOcclusionMap != null ||
			flowMap != null;
	}

	@Override
	public String toString() {
		return name;
	}

	public boolean isVanillaReplacement() {
		return vanillaTextureIndex != -1 && (parent == null || parent.vanillaTextureIndex != vanillaTextureIndex);
	}

	public String getTextureName() {
		if (this == NONE || isFallbackVanillaMaterial)
			return null;
		return name.toLowerCase();
	}

	public Material resolveTextureOwner() {
		var base = this;
		while (base.parent != null)
			base = base.parent;
		return base;
	}

	public Material findParent(Function<Material, Object> propertyGetter) {
		var property = propertyGetter.apply(this);
		var source = this;
		while (source.parent != null && Objects.deepEquals(property, propertyGetter.apply(source.parent)))
			source = source.parent;
		return source;
	}

	public boolean isInactiveReplacement(HDVariables vars) {
		if (replacementCondition == null)
			return false;
		return !replacementCondition.test(vars);
	}

	public boolean replaces(String name, HDVariables vars) {
		if (replacementCondition == null || !materialsToReplace.contains(name))
			return false;
		return replacementCondition.test(vars);
	}

	public int packMaterialData(@Nonnull ModelOverride modelOverride, UvType uvType, boolean isOverlay, boolean isTextured) {
		// This needs to return zero by default, since we often fall back to writing all zeroes to UVs
		assert isValid : String.format("Material %s used after invalidation", this);
		int materialIndex = uboIndex;
		assert materialIndex <= MAX_MATERIAL_INDEX;
		return (materialIndex & MAX_MATERIAL_INDEX) << 21
			   | ((int) (modelOverride.shadowOpacityThreshold * 0x3F) & 0x3F) << 15
			   | ((modelOverride.windDisplacementModifier + 3) & 0x7) << 12
			   | (modelOverride.windDisplacementMode.ordinal() & 0x7) << 9
			   | (modelOverride.invertDisplacementStrength ? 1 : 0) << 8
			   | (modelOverride.undoVanillaShading && !isTextured ? 1 : 0) << 7
			   | (modelOverride.terrainVertexSnap ? 1 : 0) << 6
			   | (!modelOverride.receiveShadows ? 1 : 0) << 5
			   | (modelOverride.upwardsNormals ? 1 : 0) << 4
			   | (modelOverride.flatNormals ? 1 : 0) << 3
			   | (uvType.worldUvs ? 1 : 0) << 2
			   | (uvType == UvType.VANILLA ? 1 : 0) << 1
			   | (isOverlay ? 1 : 0);
	}

	public void fillMaterialStruct(
		UBOMaterials.MaterialStruct struct,
		float vanillaScrollX,
		float vanillaScrollY
	) {
		float scrollSpeedX = scrollSpeed[0] + vanillaScrollX;
		float scrollSpeedY = scrollSpeed[1] + vanillaScrollY;

		struct.colorMap.set(textureLayer);
		struct.normalMap.set(getTextureLayer(normalMap));
		struct.displacementMap.set(getTextureLayer(displacementMap));
		struct.roughnessMap.set(getTextureLayer(roughnessMap));
		struct.ambientOcclusionMap.set(getTextureLayer(ambientOcclusionMap));
		struct.flowMap.set(getTextureLayer(flowMap));
		struct.flags.set(
			(overrideBaseColor ? 1 : 0) << 2 |
			(unlit ? 1 : 0) << 1 |
			(hasTransparency ? 1 : 0)
		);
		struct.brightness.set(brightness);
		struct.displacementScale.set(displacementScale);
		struct.specularStrength.set(specularStrength);
		struct.specularGloss.set(specularGloss);
		struct.flowMapStrength.set(flowMapStrength);
		struct.flowMapDuration.set(flowMapDuration);
		struct.scrollDuration.set(scrollSpeedX, scrollSpeedY);
		struct.textureScale.set(divide(vec(1), textureScale));
	}

	private Material resolveReference(@Nullable Material material, Map<String, Material> materials) {
		if (material instanceof Reference) {
			String name = material.name;
			var m = materials.get(name);
			if (m != null)
				return m;
			log.error("Error in material '{}': Unknown material referenced: '{}'", this, name);
		}
		return material;
	}

	@GsonUtils.ExcludeDefaults
	public static class Definition extends Material implements GsonUtils.ExcludeDefaultsProvider<Material> {
		@Override
		public Material provideDefaults() {
			return parent;
		}
	}

	public static class Reference extends Material {
		public Reference(@Nonnull String name) {
			name(name);
		}

		@Slf4j
		private static class Adapter extends TypeAdapter<Material> {
			@Override
			public Material read(JsonReader in) throws IOException {
				return in.peek() == JsonToken.NULL ? null : new Reference(in.nextString());
			}

			@Override
			public void write(JsonWriter out, Material material) throws IOException {
				out.value(material == null ? null : material.name);
			}
		}
	}

	@Slf4j
	public static class Adapter extends TypeAdapter<Material> {
		@Override
		public Material read(JsonReader in) throws IOException {
			if (in.peek() == JsonToken.NULL)
				return null;

			if (in.peek() == JsonToken.STRING) {
				String name = in.nextString();
				var match = MaterialManager.MATERIAL_MAP.get(name);
				if (match != null)
					return match;
				log.error("Missing material '{}' at {}", name, GsonUtils.location(in), new Throwable());
				return null;
			}

			log.error("Unexpected type {} at {}", in.peek(), GsonUtils.location(in), new Throwable());
			return null;
		}

		@Override
		public void write(JsonWriter out, Material material) throws IOException {
			if (material == null) {
				out.nullValue();
			} else {
				out.value(material.name);
			}
		}
	}

	@Slf4j
	public static class ListAdapter extends TypeAdapter<List<Material>> {
		private static final Adapter ADAPTER = new Adapter();

		@Override
		public List<Material> read(JsonReader in) throws IOException {
			if (in.peek() == JsonToken.NULL)
				return Collections.emptyList();

			if (in.peek() == JsonToken.STRING)
				return List.of(ADAPTER.read(in));

			if (in.peek() == JsonToken.BEGIN_ARRAY) {
				in.beginArray();
				List<Material> materials = new ArrayList<>();
				while (in.peek() != JsonToken.END_ARRAY)
					materials.add(ADAPTER.read(in));
				in.endArray();
				return materials;
			}

			log.error("Unexpected type {} at {}", in.peek(), GsonUtils.location(in), new Throwable());
			return Collections.emptyList();
		}

		@Override
		public void write(JsonWriter out, List<Material> materials) throws IOException {
			if (materials == null || materials.isEmpty()) {
				out.nullValue();
			} else {
				out.beginArray();
				for (var material : materials)
					out.value(material.name);
				out.endArray();
			}
		}
	}

	@Slf4j
	public static class ArrayAdapter extends TypeAdapter<Material[]> {
		private static final ListAdapter ADAPTER = new ListAdapter();

		@Override
		public Material[] read(JsonReader in) throws IOException {
			return ADAPTER.read(in).toArray(Material[]::new);
		}

		@Override
		public void write(JsonWriter out, Material[] materials) throws IOException {
			ADAPTER.write(out, List.of(materials));
		}
	}
}

package rs117.hd.scene;

import java.io.IOException;
import java.util.HashMap;
import java.util.Objects;
import javax.annotation.Nonnull;
import javax.annotation.Nullable;
import javax.inject.Inject;
import javax.inject.Singleton;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.*;
import net.runelite.client.callback.ClientThread;
import rs117.hd.HdPlugin;
import rs117.hd.renderer.zone.SceneManager;
import rs117.hd.scene.model_overrides.ModelOverride;
import rs117.hd.utils.FileWatcher;
import rs117.hd.utils.ModelHash;
import rs117.hd.utils.Props;
import rs117.hd.utils.ResourcePath;

import static rs117.hd.utils.ResourcePath.path;

@Slf4j
@Singleton
public class ModelOverrideManager {
	private static final ResourcePath MODEL_OVERRIDES_PATH = Props
		.getFile("rlhd.model-overrides-path", () -> path(ModelOverrideManager.class, "model_overrides.json"));

	@Inject
	private ClientThread clientThread;

	@Inject
	private HdPlugin plugin;

	@Inject
	private GamevalManager gamevalManager;

	@Inject
	private SceneManager sceneManager;

	@Inject
	private FishingSpotReplacer fishingSpotReplacer;

	private final HashMap<Integer, ModelOverride> modelOverrides = new HashMap<>();

	private FileWatcher.UnregisterCallback fileWatcher;

	public void startUp() {
		fileWatcher = MODEL_OVERRIDES_PATH.watch((path, first) -> clientThread.invoke(() -> {
			try {
				sceneManager.getLoadingLock().lock();
				sceneManager.completeAllStreaming();

				ModelOverride[] parsedOverrides = path.loadJson(plugin.getGson(), ModelOverride[].class);
				if (parsedOverrides == null)
					throw new IOException("Empty or invalid: " + path);

				modelOverrides.clear();
				for (ModelOverride override : parsedOverrides) {
					try {
						override.normalize(plugin);
					} catch (IllegalStateException ex) {
						log.error("Invalid model override '{}': {}", override.description, ex.getMessage());
						continue;
					}

					addOverride(override);

					if (override.hideInAreas.length > 0) {
						var hider = override.copy();
						hider.hide = true;
						hider.areas = override.hideInAreas;
						addOverride(hider);
					}
				}

				addOverride(fishingSpotReplacer.getModelOverride());

				log.debug("Loaded {} model overrides", modelOverrides.size());

				if (first)
					return;

				plugin.renderer.clearCaches();
				plugin.renderer.reloadScene();
			} catch (Exception ex) {
				log.error("Failed to load model overrides:", ex);
			} finally {
				sceneManager.getLoadingLock().unlock();
				log.trace("loadingLock unlocked - holdCount: {}", sceneManager.getLoadingLock().getHoldCount());
			}
		}));
	}

	public void shutDown() {
		if (fileWatcher != null)
			fileWatcher.unregister();
		fileWatcher = null;

		modelOverrides.clear();
	}

	public void reload() {
		shutDown();
		startUp();
	}

	private void addOverride(@Nullable ModelOverride override) {
		if (override == null || override.seasonalTheme != null && override.seasonalTheme != plugin.configSeasonalTheme)
			return;

		for (int id : override.npcIds)
			addEntry(ModelHash.TYPE_NPC, id, override);
		for (int id : override.objectIds)
			addEntry(ModelHash.TYPE_OBJECT, id, override);
		for (int id : override.projectileIds)
			addEntry(ModelHash.TYPE_PROJECTILE, id, override);
		for (int id : override.graphicsObjectIds)
			addEntry(ModelHash.TYPE_GRAPHICS_OBJECT, id, override);
	}

	private void addEntry(int type, int id, ModelOverride entry) {
		int uuid = ModelHash.packUuid(type, id);
		ModelOverride current = modelOverrides.get(uuid);

		if (current != null && !Objects.equals(current.seasonalTheme, entry.seasonalTheme)) {
			// Seasonal theme overrides should take precedence
			if (current.seasonalTheme != null)
				return;
			current = null;
		}

		boolean isDuplicate = false;

		if (entry.areas.length == 0) {
			// Non-area-restricted override, of which there can only be one per UUID

			// A dummy override is used as the base if only area-specific overrides exist
			isDuplicate = current != null && !current.isDummy;

			if (isDuplicate && Props.DEVELOPMENT) {
				String name = null;
				switch (type) {
					case ModelHash.TYPE_NPC:
						name = gamevalManager.getNpcName(id);
						break;
					case ModelHash.TYPE_OBJECT:
						name = gamevalManager.getObjectName(id);
						break;
					case ModelHash.TYPE_PROJECTILE:
					case ModelHash.TYPE_GRAPHICS_OBJECT:
						name = gamevalManager.getSpotanimName(id);
						break;
				}

				// This should ideally not be reached, so print helpful warnings in development mode
				if (entry.hideInAreas.length > 0) {
					log.error(
						"Replacing {} ({}) from '{}' with hideInAreas-override '{}'. This is likely a mistake...",
						name, id, current.description, entry.description
					);
				} else {
					log.error(
						"Replacing {} ({}) from '{}' with '{}'. The first-mentioned override should be removed.",
						name, id, current.description, entry.description
					);
				}
			}

			if (current != null && current.areaOverrides != null && !current.areaOverrides.isEmpty()) {
				var areaOverrides = current.areaOverrides;
				current = entry.copy();
				current.areaOverrides = areaOverrides;
			} else {
				current = entry;
			}

			modelOverrides.put(uuid, current);
		} else {
			if (current == null)
				current = ModelOverride.NONE;

			if (current.areaOverrides == null) {
				// We need to replace the override with a copy that has a separate list of area overrides to avoid conflicts
				current = current.copy();
				current.areaOverrides = new HashMap<>();
				modelOverrides.put(uuid, current);
			}

			for (var area : entry.areas)
				current.areaOverrides.put(area, entry);
		}
	}

	@Nonnull
	public ModelOverride getOverride(int uuid, int[] worldPos) {
		var override = modelOverrides.get(ModelHash.getUuidWithoutSubType(uuid));
		if (override == null)
			return ModelOverride.NONE;

		if (override.areaOverrides != null)
			for (var entry : override.areaOverrides.entrySet())
				if (entry.getKey().contains(worldPos))
					return entry.getValue();

		return override;
	}

	@Nonnull
	public ModelOverride getOverride(TileObject tileObject, int[] worldPos) {
		return getOverride(ModelHash.packUuid(ModelHash.TYPE_OBJECT, tileObject.getId()), worldPos);
	}
}

package rs117.hd.scene.model_overrides;

public enum InheritTileColorType
{
	NONE, OVERLAY, UNDERLAY
}

package rs117.hd.scene.model_overrides;

import com.google.gson.JsonArray;
import com.google.gson.JsonElement;
import com.google.gson.annotations.JsonAdapter;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;
import lombok.AllArgsConstructor;
import lombok.NoArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.*;
import rs117.hd.HdPlugin;
import rs117.hd.config.SeasonalTheme;
import rs117.hd.config.VanillaShadowMode;
import rs117.hd.scene.GamevalManager;
import rs117.hd.scene.areas.AABB;
import rs117.hd.scene.materials.Material;
import rs117.hd.utils.Props;

import static net.runelite.api.Perspective.*;
import static rs117.hd.utils.ExpressionParser.asExpression;
import static rs117.hd.utils.ExpressionParser.parseExpression;
import static rs117.hd.utils.MathUtils.*;

@Slf4j
@NoArgsConstructor
@AllArgsConstructor
public class ModelOverride
{
	public static final ModelOverride NONE = new ModelOverride(true);

	private static final Set<Integer> EMPTY = new HashSet<>();

	public String description = "UNKNOWN";

	// When, where or what the override should apply to
	public SeasonalTheme seasonalTheme;
	@JsonAdapter(AABB.ArrayAdapter.class)
	public AABB[] areas = {};
	@JsonAdapter(GamevalManager.NpcAdapter.class)
	public Set<Integer> npcIds = EMPTY;
	@JsonAdapter(GamevalManager.ObjectAdapter.class)
	public Set<Integer> objectIds = EMPTY;
	@JsonAdapter(GamevalManager.SpotanimAdapter.class)
	public Set<Integer> projectileIds = EMPTY;
	@JsonAdapter(GamevalManager.SpotanimAdapter.class)
	public Set<Integer> graphicsObjectIds = EMPTY;

	public Material baseMaterial = Material.NONE;
	public Material textureMaterial = Material.NONE;
	public UvType uvType = UvType.VANILLA;
	public float uvScale = 1;
	public int uvOrientation = 0;
	public int uvOrientationX = 0;
	public int uvOrientationY = 0;
	public int uvOrientationZ = 0;
	public int rotate = 0;
	public boolean hide = false;
	public boolean retainVanillaUvs = true;
	public boolean forceMaterialChanges = false;
	public boolean flatNormals = false;
	public boolean upwardsNormals = false;
	public boolean hideVanillaShadows = false;
	public boolean retainVanillaShadowsInPvm = false;
	public boolean hideHdShadowsInPvm = false;
	public boolean castShadows = true;
	public boolean receiveShadows = true;
	public boolean terrainVertexSnap = false;
	public boolean undoVanillaShading = true;
	public float terrainVertexSnapThreshold = 0.125f;
	public float shadowOpacityThreshold = 0;
	public TzHaarRecolorType tzHaarRecolorType = TzHaarRecolorType.NONE;
	public InheritTileColorType inheritTileColorType = InheritTileColorType.NONE;
	public WindDisplacement windDisplacementMode = WindDisplacement.DISABLED;
	public int windDisplacementModifier = 0;
	public boolean invertDisplacementStrength = false;
	public int depthBias = -1;
	public boolean disablePrioritySorting = false;

	@JsonAdapter(AABB.ArrayAdapter.class)
	public AABB[] hideInAreas = {};

	public Map<Material, ModelOverride> materialOverrides;
	public ModelOverride[] colorOverrides;

	private JsonElement colors;

	public transient boolean isDummy;
	public transient Map<AABB, ModelOverride> areaOverrides;
	public transient AhslPredicate ahslCondition;
	public transient boolean hasTransparency;
	public transient boolean mightHaveTransparency;
	public transient boolean modifiesVanillaTexture;

	@FunctionalInterface
	public interface AhslPredicate {
		boolean test(int ahsl);
	}

	public void normalize(HdPlugin plugin) {
		// Ensure there are no nulls in case of invalid configuration during development
		if (baseMaterial == null) {
			if (Props.DEVELOPMENT)
				throw new IllegalStateException("Invalid baseMaterial");
			baseMaterial = ModelOverride.NONE.baseMaterial;
		}
		if (textureMaterial == null) {
			if (Props.DEVELOPMENT)
				throw new IllegalStateException("Invalid textureMaterial");
			textureMaterial = ModelOverride.NONE.textureMaterial;
		}
		if (uvType == null) {
			if (Props.DEVELOPMENT)
				throw new IllegalStateException("Invalid uvType");
			uvType = ModelOverride.NONE.uvType;
		}
		if (tzHaarRecolorType == null) {
			if (Props.DEVELOPMENT)
				throw new IllegalStateException("Invalid tzHaarRecolorType");
			tzHaarRecolorType = ModelOverride.NONE.tzHaarRecolorType;
		}
		if (inheritTileColorType == null) {
			if (Props.DEVELOPMENT)
				throw new IllegalStateException("Invalid inheritTileColorType");
			inheritTileColorType = ModelOverride.NONE.inheritTileColorType;
		}
		if (windDisplacementMode == null) {
			if (Props.DEVELOPMENT)
				throw new IllegalStateException("Invalid windDisplacementMode");
			windDisplacementMode = ModelOverride.NONE.windDisplacementMode;
		}

		if (windDisplacementModifier < -3 || windDisplacementModifier > 3) {
			if (Props.DEVELOPMENT)
				throw new IllegalStateException("Invalid windDisplacementModifier (range is -3 to 3)");
			windDisplacementModifier = clamp(windDisplacementModifier, -3, 3);
		}

		modifiesVanillaTexture = textureMaterial.modifiesVanillaTexture;

		boolean disableTextures = !plugin.configModelTextures && !forceMaterialChanges;
		if (disableTextures) {
			if (baseMaterial.modifiesVanillaTexture)
				baseMaterial = Material.NONE;
			if (textureMaterial.modifiesVanillaTexture)
				textureMaterial = Material.NONE;
		}

		if (areas == null)
			areas = new AABB[0];
		if (hideInAreas == null)
			hideInAreas = new AABB[0];

		hasTransparency = mightHaveTransparency =
			baseMaterial.hasTransparency ||
			textureMaterial.hasTransparency ||
			tzHaarRecolorType != TzHaarRecolorType.NONE;

		if (materialOverrides != null) {
			var normalized = new HashMap<Material, ModelOverride>();
			for (var entry : materialOverrides.entrySet()) {
				var override = entry.getValue();
				override.normalize(plugin);
				if (disableTextures && override.modifiesVanillaTexture)
					continue;
				mightHaveTransparency |= override.mightHaveTransparency;
				normalized.put(entry.getKey(), override);
			}
			if (normalized.isEmpty())
				normalized = null;
			materialOverrides = normalized;
		}

		if (colorOverrides != null) {
			for (var override : colorOverrides) {
				override.normalize(plugin);
				mightHaveTransparency |= override.mightHaveTransparency;
				override.ahslCondition = parseAhslConditions(override.colors);
			}
		}

		if (uvOrientationX == 0)
			uvOrientationX = uvOrientation;
		if (uvOrientationY == 0)
			uvOrientationY = uvOrientation;
		if (uvOrientationZ == 0)
			uvOrientationZ = uvOrientation;

		if (retainVanillaShadowsInPvm) {
			if (plugin.configVanillaShadowMode.retainInPvm)
				hideVanillaShadows = false;
			if (plugin.configVanillaShadowMode == VanillaShadowMode.PREFER_IN_PVM && hideHdShadowsInPvm)
				castShadows = false;
		}

		if (!castShadows && shadowOpacityThreshold == 0)
			shadowOpacityThreshold = 1;
	}

	public ModelOverride copy() {
		return new ModelOverride(
			description,
			seasonalTheme,
			areas,
			npcIds,
			objectIds,
			projectileIds,
			graphicsObjectIds,
			baseMaterial,
			textureMaterial,
			uvType,
			uvScale,
			uvOrientation,
			uvOrientationX,
			uvOrientationY,
			uvOrientationZ,
			rotate,
			hide,
			retainVanillaUvs,
			forceMaterialChanges,
			flatNormals,
			upwardsNormals,
			hideVanillaShadows,
			retainVanillaShadowsInPvm,
			hideHdShadowsInPvm,
			castShadows,
			receiveShadows,
			terrainVertexSnap,
			undoVanillaShading,
			terrainVertexSnapThreshold,
			shadowOpacityThreshold,
			tzHaarRecolorType,
			inheritTileColorType,
			windDisplacementMode,
			windDisplacementModifier,
			invertDisplacementStrength,
			depthBias,
			disablePrioritySorting,
			hideInAreas,
			materialOverrides,
			colorOverrides,
			colors,
			isDummy,
			areaOverrides,
			ahslCondition,
			hasTransparency,
			mightHaveTransparency,
			modifiesVanillaTexture
		);
	}

	private ModelOverride(boolean isDummy) {
		this();
		this.isDummy = isDummy;
	}

	private AhslPredicate parseAhslConditions(JsonElement element) {
		if (element == null)
			return ahsl -> false;

		JsonArray arr;
		if (element.isJsonArray()) {
			arr = element.getAsJsonArray();
		} else {
			arr = new JsonArray();
			arr.add(element);
		}

		AhslPredicate combinedPredicate = null;

		for (var el : arr) {
			if (el.isJsonNull())
				continue;
			if (!el.isJsonPrimitive()) {
				log.warn("Skipping unexpected HSL condition '{}' in override '{}'", el, description);
				continue;
			}

			AhslPredicate condition;
			var prim = el.getAsJsonPrimitive();
			if (prim.isBoolean()) {
				boolean bool = prim.getAsBoolean();
				condition = ahsl -> bool;
			} else if (prim.isNumber()) {
				try {
					int targetHsl = prim.getAsInt();
					condition = ahsl -> (ahsl & 0xFFFF) == targetHsl;
				} catch (Exception ex) {
					log.warn("Expected integer, but got {} in override '{}'", el, description);
					continue;
				}
			} else if (prim.isString()) {
				var expr = asExpression(parseExpression(prim.getAsString()));

				if (Props.DEVELOPMENT) {
					// Ensure all variables are defined
					final Set<String> knownVariables = Set.of("a", "h", "s", "l", "hsl", "ahsl");
					for (var variable : expr.variables)
						if (!knownVariables.contains(variable))
							throw new IllegalStateException(
								"Expression '" + prim.getAsString() + "' contains unknown variable '" + variable + "'");
				}

				var predicate = expr.toPredicate();
				condition = ahsl -> predicate.test(key -> {
					switch (key) {
						case "a":
							return ahsl >>> 16 & 0xFF;
						case "h":
							return ahsl >>> 10 & 0x3F;
						case "s":
							return ahsl >>> 7 & 0x7;
						case "l":
							return ahsl & 0x7F;
						case "ahsl":
							return ahsl;
						case "hsl":
							return ahsl & 0xFFFF;
						default:
							assert false : "Unexpected variable: " + key;
							return 0;
					}
				});
			} else {
				log.warn("Skipping unexpected HSL condition primitive '{}' in override '{}'", el, description);
				continue;
			}

			if (combinedPredicate == null) {
				combinedPredicate = condition;
			} else {
				var prev = combinedPredicate;
				combinedPredicate = ahsl -> prev.test(ahsl) || condition.test(ahsl);
			}
		}

		if (combinedPredicate == null)
			return ahsl -> false;

		return combinedPredicate;
	}

	public void computeModelUvw(float[] out, int i, float x, float y, float z, int orientation) {
		float rad, cos, sin;
		float temp;
		if (orientation % 2048 != 0) {
			// Reverse baked vertex rotation
			rad = orientation * JAU_TO_RAD;
			cos = cos(rad);
			sin = sin(rad);
			temp = x * sin + z * cos;
			x = x * cos - z * sin;
			z = temp;
		}

		x = (x / LOCAL_TILE_SIZE + .5f) / uvScale;
		y = (y / LOCAL_TILE_SIZE + .5f) / uvScale;
		z = (z / LOCAL_TILE_SIZE + .5f) / uvScale;

		uvType.computeModelUvw(out, i, x, y, z);

		if (uvOrientation % 2048 != 0) {
			rad = uvOrientation * JAU_TO_RAD;
			cos = cos(rad);
			sin = sin(rad);
			x = out[i] - .5f;
			z = out[i + 1] - .5f;
			temp = x * sin + z * cos;
			x = x * cos - z * sin;
			z = temp;
			out[i] = x + .5f;
			out[i + 1] = z + .5f;
		}
	}

	public void fillUvsForFace(float[] out, Model model, int orientation, UvType uvType, int face, float[] workingSpace) {
		switch (uvType) {
			case WORLD_XY:
			case WORLD_XZ:
			case WORLD_YZ:
				uvType.computeWorldUvw(out, 0, uvScale);
				uvType.computeWorldUvw(out, 4, uvScale);
				uvType.computeWorldUvw(out, 8, uvScale);
				break;
			case MODEL_XY:
			case MODEL_XY_MIRROR_A:
			case MODEL_XY_MIRROR_B:
			case MODEL_XZ:
			case MODEL_XZ_MIRROR_A:
			case MODEL_XZ_MIRROR_B:
			case MODEL_YZ:
			case MODEL_YZ_MIRROR_A:
			case MODEL_YZ_MIRROR_B: {
				final float[] vertexX = model.getVerticesX();
				final float[] vertexY = model.getVerticesY();
				final float[] vertexZ = model.getVerticesZ();
				final int triA = model.getFaceIndices1()[face];
				final int triB = model.getFaceIndices2()[face];
				final int triC = model.getFaceIndices3()[face];

				computeModelUvw(out, 0, vertexX[triA], vertexY[triA], vertexZ[triA], orientation);
				computeModelUvw(out, 4, vertexX[triB], vertexY[triB], vertexZ[triB], orientation);
				computeModelUvw(out, 8, vertexX[triC], vertexY[triC], vertexZ[triC], orientation);
				break;
			}
			case BOX:
				computeBoxUvw(out, model, orientation, face, workingSpace);
				break;
			case VANILLA: {
				final byte[] textureFaces = model.getTextureFaces();
				int texFace = textureFaces == null ? -1 : textureFaces[face];
				if (texFace != -1) {
					texFace &= 0xff;

					final float[] vertexX = model.getVerticesX();
					final float[] vertexY = model.getVerticesY();
					final float[] vertexZ = model.getVerticesZ();
					final int texA = model.getTexIndices1()[texFace];
					final int texB = model.getTexIndices2()[texFace];
					final int texC = model.getTexIndices3()[texFace];

					out[0] = vertexX[texA];
					out[1] = vertexY[texA];
					out[2] = vertexZ[texA];
					out[4] = vertexX[texB];
					out[5] = vertexY[texB];
					out[6] = vertexZ[texB];
					out[8] = vertexX[texC];
					out[9] = vertexY[texC];
					out[10] = vertexZ[texC];
				}
				break;
			}
			case GEOMETRY:
			default:
				out[0] = 0;
				out[1] = 0;
				out[2] = 0;
				out[4] = 1;
				out[5] = 0;
				out[6] = 0;
				out[8] = 0;
				out[9] = 1;
				out[10] = 0;
				break;
		}
	}

	@SuppressWarnings({ "PointlessArithmeticExpression", "UnnecessaryLocalVariable" })
	private void computeBoxUvw(float[] out, Model model, int modelOrientation, int face, float[] workingSpace) {
		final float[] verticesX = model.getVerticesX();
		final float[] verticesY = model.getVerticesY();
		final float[] verticesZ = model.getVerticesZ();

		final float[] v = workingSpace;
		int vidx;
		vidx = model.getFaceIndices1()[face];
		v[0 * 3 + 0] = verticesX[vidx];
		v[0 * 3 + 1] = verticesY[vidx];
		v[0 * 3 + 2] = verticesZ[vidx];
		vidx = model.getFaceIndices2()[face];
		v[1 * 3 + 0] = verticesX[vidx];
		v[1 * 3 + 1] = verticesY[vidx];
		v[1 * 3 + 2] = verticesZ[vidx];
		vidx = model.getFaceIndices3()[face];
		v[2 * 3 + 0] = verticesX[vidx];
		v[2 * 3 + 1] = verticesY[vidx];
		v[2 * 3 + 2] = verticesZ[vidx];

		float rad, cos, sin;
		float temp;
		if (modelOrientation % 2048 != 0) {
			// Reverse baked vertex rotation
			rad = modelOrientation * JAU_TO_RAD;
			cos = cos(rad);
			sin = sin(rad);

			for (int i = 0; i < 3; i++) {
				temp = v[i * 3] * sin + v[i * 3 + 2] * cos;
				v[i * 3] = v[i * 3] * cos - v[i * 3 + 2] * sin;
				v[i * 3 + 2] = temp;
			}
		}

		for (int i = 0; i < 3; i++) {
			v[i * 3] = (v[i * 3] / LOCAL_TILE_SIZE + .5f) / uvScale;
			v[i * 3 + 1] = (v[i * 3 + 1] / LOCAL_TILE_SIZE + .5f) / uvScale;
			v[i * 3 + 2] = (v[i * 3 + 2] / LOCAL_TILE_SIZE + .5f) / uvScale;
		}

		// Compute face normal as cross(v[1] - v[0], v[2] - v[0])
		float nx = (v[3 + 1] - v[1]) * (v[6 + 2] - v[2]) - (v[3 + 2] - v[2]) * (v[6 + 1] - v[1]);
		float ny = (v[3 + 2] - v[2]) * (v[6 + 0] - v[0]) - (v[3 + 0] - v[0]) * (v[6 + 2] - v[2]);
		float nz = (v[3 + 0] - v[0]) * (v[6 + 1] - v[1]) - (v[3 + 1] - v[1]) * (v[6 + 0] - v[0]);
		float absNx = abs(nx);
		float absNy = abs(ny);
		float absNz = abs(nz);

		out[2] = out[6] = out[10] = 0;
		if (absNx > absNy && absNx > absNz) {
			// YZ plane
			float flip = sign(nx);
			for (int tri = 0; tri < 3; tri++) {
				out[tri * 4] = flip * -v[tri * 3 + 2];
				out[tri * 4 + 1] = v[tri * 3 + 1];
			}

			if (uvOrientationX % 2048 != 0) {
				rad = uvOrientationX * JAU_TO_RAD;
				cos = cos(rad);
				sin = sin(rad);

				for (int i = 0; i < 3; i++) {
					int j = i * 4;
					v[i * 3] = out[j] - .5f;
					v[i * 3 + 2] = out[j + 1] - .5f;
					temp = v[i * 3] * sin + v[i * 3 + 2] * cos;
					v[i * 3] = v[i * 3] * cos - v[i * 3 + 2] * sin;
					v[i * 3 + 2] = temp;
					out[j] = v[i * 3] + .5f;
					out[j + 1] = v[i * 3 + 2] + .5f;
				}
			}
		} else if (absNy > absNx && absNy > absNz) {
			// XZ
			float flip = sign(ny);
			for (int tri = 0; tri < 3; tri++) {
				out[tri * 4] = flip * -v[tri * 3];
				out[tri * 4 + 1] = v[tri * 3 + 2];
			}

			if (uvOrientationY % 2048 != 0) {
				rad = uvOrientationY * JAU_TO_RAD;
				cos = cos(rad);
				sin = sin(rad);

				for (int i = 0; i < 3; i++) {
					int j = i * 4;
					v[i * 3] = out[j] - .5f;
					v[i * 3 + 2] = out[j + 1] - .5f;
					temp = v[i * 3] * sin + v[i * 3 + 2] * cos;
					v[i * 3] = v[i * 3] * cos - v[i * 3 + 2] * sin;
					v[i * 3 + 2] = temp;
					out[j] = v[i * 3] + .5f;
					out[j + 1] = v[i * 3 + 2] + .5f;
				}
			}
		} else {
			// XY
			float flip = sign(nz);
			for (int tri = 0; tri < 3; tri++) {
				out[tri * 4] = flip * v[tri * 3];
				out[tri * 4 + 1] = v[tri * 3 + 1];
			}

			if (uvOrientationZ % 2048 != 0) {
				rad = uvOrientationZ * JAU_TO_RAD;
				cos = cos(rad);
				sin = sin(rad);

				for (int i = 0; i < 3; i++) {
					int j = i * 4;
					v[i * 3] = out[j] - .5f;
					v[i * 3 + 2] = out[j + 1] - .5f;
					temp = v[i * 3] * sin + v[i * 3 + 2] * cos;
					v[i * 3] = v[i * 3] * cos - v[i * 3 + 2] * sin;
					v[i * 3 + 2] = temp;
					out[j] = v[i * 3] + .5f;
					out[j + 1] = v[i * 3 + 2] + .5f;
				}
			}
		}
	}

	public void applyRotation(Model model) {
		switch (rotate) {
			case 0:
				break;
			case 90:
				model.rotateY90Ccw();
				break;
			case 180:
				model.rotateY180Ccw();
				break;
			case 270:
				model.rotateY270Ccw();
				break;
			default:
				log.debug(
					"Unsupported rotation of {} degrees in model override: '{}'",
					rotate,
					description
				);
				break;
		}
	}

	public void revertRotation(Model model) {
		switch (rotate) {
			case 90:
				model.rotateY270Ccw();
				break;
			case 180:
				model.rotateY180Ccw();
				break;
			case 270:
				model.rotateY90Ccw();
				break;
		}
	}
}

/*
 * Copyright (c) 2021, 117 <https://twitter.com/117scape>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package rs117.hd.scene.model_overrides;

public enum TzHaarRecolorType
{
	NONE, GRADIENT, HUE_SHIFT
}

/*
 * Copyright (c) 2021, 117 <https://twitter.com/117scape>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package rs117.hd.scene.model_overrides;

public enum UvType {
	VANILLA,
	GEOMETRY,
	// TODO: move MODEL_* computation to compute shader for efficiency
	MODEL_XY(true, (uvw, i, x, y, z) -> {
		uvw[i] = x;
		uvw[i + 1] = y;
		uvw[i + 2] = z;
	}),
	MODEL_XY_MIRROR_A(MODEL_XY, UvType::mirrorDiagonally),
	MODEL_XY_MIRROR_B(MODEL_XY, (uvw, i) -> {
		uvw[i + 1] = 1 - uvw[i + 1];
		mirrorDiagonally(uvw, i);
	}),
	MODEL_XZ(true, (uvw, i, x, y, z) -> {
		uvw[i] = x;
		uvw[i + 1] = z;
		uvw[i + 2] = y;
	}),
	MODEL_XZ_MIRROR_A(MODEL_XZ, UvType::mirrorDiagonally),
	MODEL_XZ_MIRROR_B(MODEL_XZ, (uvw, i) -> {
		uvw[i + 1] = 1 - uvw[i + 1];
		mirrorDiagonally(uvw, i);
	}),
	MODEL_YZ(true, (uvw, i, x, y, z) -> {
		uvw[i] = y;
		uvw[i + 1] = z;
		uvw[i + 2] = x;
	}),
	MODEL_YZ_MIRROR_A(MODEL_YZ, UvType::mirrorDiagonally),
	MODEL_YZ_MIRROR_B(MODEL_YZ, (uvw, i) -> {
		uvw[i + 1] = 1 - uvw[i + 1];
		mirrorDiagonally(uvw, i);
	}),
	WORLD_XY(new float[] { 0, 0, -1 }),
	WORLD_XZ(new float[] { 0, -1, 0 }),
	WORLD_YZ(new float[] { -1, 0, 0 }),
	BOX,
	;

	public final boolean worldUvs;
	public final boolean orientationDependent;
	private final UvGenerator generator;

	UvType() {
		worldUvs = false;
		orientationDependent = false;
		generator = null;
	}

	UvType(boolean orientationDependent, UvGenerator generator) {
		this.worldUvs = false;
		this.orientationDependent = orientationDependent;
		this.generator = generator;
	}

	UvType(UvType inherit, UvProcessor processor) {
		worldUvs = inherit.worldUvs;
		orientationDependent = inherit.orientationDependent;
		generator = (uvw, i, x, y, z) -> {
			inherit.generator.computeUvw(uvw, i, x, y, z);
			processor.processUvw(uvw, i);
		};
	}

	UvType(float[] normal) {
		worldUvs = true;
		orientationDependent = false;
		generator = (uvw, i, scale, _1, _2) -> {
			uvw[i] = scale * normal[0];
			uvw[i + 1] = scale * normal[1];
			uvw[i + 2] = scale * normal[2];
		};
	}

	@FunctionalInterface
	public interface UvGenerator {
		void computeUvw(float[] out, int offset, float x, float y, float z);
	}

	@FunctionalInterface
	public interface UvProcessor {
		void processUvw(float[] out, int offset);
	}

	public void computeModelUvw(float[] out, int offset, float x, float y, float z) {
		assert generator != null : this + " does not support computing UVs";
		generator.computeUvw(out, offset, x, y, z);
	}

	public void computeWorldUvw(float[] out, int offset, float scale) {
		assert generator != null : this + " does not support computing UVs";
		generator.computeUvw(out, offset, scale, 0, 0);
	}

	private static void mirrorDiagonally(float[] uv, int i) {
		if (uv[i] < uv[i + 1]) {
			float temp = uv[i];
			uv[i] = uv[i + 1];
			uv[i + 1] = temp;
		}
	}
}

package rs117.hd.scene.model_overrides;

public enum WindDisplacement {
	DISABLED,
	OBJECT,
	OBJECT_NO_GROUND_DISPLACEMENT,
	VERTEX,
	VERTEX_WITH_HEMISPHERE_BLEND,
	VERTEX_JIGGLE
}

/*
 * Copyright (c) 2021, 117 <https://twitter.com/117scape>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package rs117.hd.scene;

import java.util.Arrays;
import java.util.HashMap;
import javax.inject.Inject;
import javax.inject.Singleton;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.*;
import rs117.hd.renderer.legacy.LegacySceneContext;
import rs117.hd.scene.materials.Material;
import rs117.hd.scene.model_overrides.ModelOverride;
import rs117.hd.scene.model_overrides.TzHaarRecolorType;
import rs117.hd.scene.tile_overrides.TileOverride;
import rs117.hd.scene.water_types.WaterType;
import rs117.hd.utils.ColorUtils;
import rs117.hd.utils.ModelHash;
import rs117.hd.utils.buffer.GpuIntBuffer;

import static net.runelite.api.Constants.*;
import static net.runelite.api.Perspective.*;
import static rs117.hd.scene.tile_overrides.TileOverride.OVERLAY_FLAG;
import static rs117.hd.utils.HDUtils.HIDDEN_HSL;
import static rs117.hd.utils.HDUtils.calculateSurfaceNormals;
import static rs117.hd.utils.HDUtils.fastVertexHash;
import static rs117.hd.utils.MathUtils.*;

@Slf4j
@Singleton
public class ProceduralGenerator {
	public static final int[] DEPTH_LEVEL_SLOPE = new int[] { 150, 300, 470, 610, 700, 750, 820, 920, 1080, 1300, 1350, 1380 };
	public static final int MAX_DEPTH = DEPTH_LEVEL_SLOPE[DEPTH_LEVEL_SLOPE.length - 1];

	public static final int VERTICES_PER_FACE = 3;
	public static final boolean[][] TILE_OVERLAY_TRIS = new boolean[][]
		{
			/*  0 */ { true, true, true, true }, // Used by tilemodels of varying tri counts?
			/*  1 */ { false, true },
			/*  2 */ { false, false, true },
			/*  3 */ { false, false, true },
			/*  4 */ { false, true, true },
			/*  5 */ { false, true, true },
			/*  6 */ { false, false, true, true },
			/*  7 */ { false, false, false, true },
			/*  8 */ { false, true, true, true },
			/*  9 */ { false, false, false, true, true, true },
			/* 10 */ { true, true, true, false, false, false },
			/* 11 */ { true, true, false, false, false, false },
		};

	@Inject
	private TileOverrideManager tileOverrideManager;

	@Inject
	private WaterTypeManager waterTypeManager;

	public void generateSceneData(SceneContext sceneContext)
	{
		long timerTotal = System.currentTimeMillis();
		long timerCalculateTerrainNormals, timerGenerateTerrainData, timerGenerateUnderwaterTerrain;

		long startTime = System.currentTimeMillis();
		generateUnderwaterTerrain(sceneContext);
		timerGenerateUnderwaterTerrain = (int)(System.currentTimeMillis() - startTime);
		startTime = System.currentTimeMillis();
		calculateTerrainNormals(sceneContext);
		timerCalculateTerrainNormals = (int)(System.currentTimeMillis() - startTime);
		startTime = System.currentTimeMillis();
		generateTerrainData(sceneContext);
		timerGenerateTerrainData = (int)(System.currentTimeMillis() - startTime);

		log.debug("procedural data generation took {}ms to complete", (System.currentTimeMillis() - timerTotal));
		log.debug("-- calculateTerrainNormals: {}ms", timerCalculateTerrainNormals);
		log.debug("-- generateTerrainData: {}ms", timerGenerateTerrainData);
		log.debug("-- generateUnderwaterTerrain: {}ms", timerGenerateUnderwaterTerrain);
	}

	public void clearSceneData(SceneContext sceneContext) {
		sceneContext.tileIsWater = null;
		sceneContext.vertexIsWater = null;
		sceneContext.vertexIsLand = null;
		sceneContext.vertexIsOverlay = null;
		sceneContext.vertexIsUnderlay = null;
		sceneContext.skipTile = null;
		sceneContext.vertexUnderwaterDepth = null;
		if (!(sceneContext instanceof LegacySceneContext))
			sceneContext.underwaterDepthLevels = null;
	}

	/**
	 * Iterates through all Tiles in a given Scene, producing color and
	 * material data for each vertex of each Tile. Then adds the resulting
	 * data to appropriate HashMaps.
	 */
	private void generateTerrainData(SceneContext sceneContext)
	{
		sceneContext.vertexTerrainColor = new HashMap<>();
		// used for overriding potentially undesirable vertex colors
		// for example, colors that aren't supposed to be visible
		sceneContext.highPriorityColor = new HashMap<>();
		sceneContext.vertexTerrainTexture = new HashMap<>();
		// for faces without an overlay is set to true
		sceneContext.vertexIsUnderlay = new HashMap<>();
		// for faces with an overlay is set to true
		// the result of these maps can be used to determine the vertices
		// between underlays and overlays for custom blending
		sceneContext.vertexIsOverlay = new HashMap<>();

		Tile[][][] tiles = sceneContext.scene.getExtendedTiles();
		int sizeX = sceneContext.sizeX;
		int sizeY = sceneContext.sizeZ;
		for (int z = 0; z < MAX_Z; ++z) {
			for (int x = 0; x < sizeX; ++x)
				for (int y = 0; y < sizeY; ++y)
					if (tiles[z][x][y] != null)
						generateDataForTile(sceneContext, tiles[z][x][y], x, y);

			for (int x = 0; x < sizeX; ++x)
				for (int y = 0; y < sizeY; ++y)
					if (tiles[z][x][y] != null && tiles[z][x][y].getBridge() != null)
						generateDataForTile(sceneContext, tiles[z][x][y].getBridge(), x, y);
		}
	}

	/**
	 * Produces color and material data for the vertices of the provided Tile.
	 * Then adds the resulting data to appropriate HashMaps.
	 *
	 * @param sceneContext that the tile is associated with
	 * @param tile         to generate terrain data for
	 */
	private void generateDataForTile(SceneContext sceneContext, Tile tile, int tileExX, int tileExY)
	{
		int faceCount;
		if (tile.getSceneTilePaint() != null) {
			faceCount = 2;
		} else if (tile.getSceneTileModel() != null) {
			faceCount = tile.getSceneTileModel().getFaceX().length;
		} else {
			return;
		}

		int[] vertexHashes = new int[faceCount * VERTICES_PER_FACE];
		int[] vertexColors = new int[faceCount * VERTICES_PER_FACE];
		TileOverride[] vertexOverrides = new TileOverride[faceCount * VERTICES_PER_FACE];
		boolean[] vertexIsOverlay = new boolean[faceCount * VERTICES_PER_FACE];
		boolean[] vertexDefaultColor = new boolean[faceCount * VERTICES_PER_FACE];

		int tileX = tileExX - sceneContext.sceneOffset;
		int tileY = tileExY - sceneContext.sceneOffset;
		int tileZ = tile.getRenderLevel();
		int[] worldPos = sceneContext.sceneToWorld(tileX, tileY, tileZ);

		Scene scene = sceneContext.scene;
		if (tile.getSceneTilePaint() != null) {
			// tile paint

			var override = tileOverrideManager.getOverride(sceneContext, tile, worldPos);
			if (override.waterType != WaterType.NONE) {
				// skip water tiles
				return;
			}

			int swColor = tile.getSceneTilePaint().getSwColor();
			int seColor = tile.getSceneTilePaint().getSeColor();
			int nwColor = tile.getSceneTilePaint().getNwColor();
			int neColor = tile.getSceneTilePaint().getNeColor();

			vertexHashes = tileVertexKeys(sceneContext, tile);

			if (tileExX >= EXTENDED_SCENE_SIZE - 2 && tileExY >= EXTENDED_SCENE_SIZE - 2) {
				// reduce the black scene edges by assigning surrounding colors
				neColor = swColor;
				nwColor = swColor;
				seColor = swColor;
			} else if (tileExY >= EXTENDED_SCENE_SIZE - 2) {
				nwColor = swColor;
				neColor = seColor;
			} else if (tileExX >= EXTENDED_SCENE_SIZE - 2) {
				neColor = nwColor;
				seColor = swColor;
			}

			vertexColors[0] = swColor;
			vertexColors[1] = seColor;
			vertexColors[2] = nwColor;
			vertexColors[3] = neColor;

			for (int i = 0; i < 4; i++) {
				vertexOverrides[i] = override;
				vertexIsOverlay[i] = override.queriedAsOverlay;
			}
			if (useDefaultColor(tile, override))
				for (int i = 0; i < 4; i++)
					vertexDefaultColor[i] = true;
		}
		else if (tile.getSceneTileModel() != null)
		{
			// tile model

			SceneTileModel sceneTileModel = tile.getSceneTileModel();

			final int[] faceColorsA = sceneTileModel.getTriangleColorA();
			final int[] faceColorsB = sceneTileModel.getTriangleColorB();
			final int[] faceColorsC = sceneTileModel.getTriangleColorC();

			int overlayId = OVERLAY_FLAG | scene.getOverlayIds()[tileZ][tileExX][tileExY];
			int underlayId = scene.getUnderlayIds()[tileZ][tileExX][tileExY];
			var overlayOverride = tileOverrideManager.getOverride(sceneContext, tile, worldPos, overlayId);
			var underlayOverride = tileOverrideManager.getOverride(sceneContext, tile, worldPos, underlayId);

			for (int face = 0; face < faceCount; face++) {
				int[] faceColors = new int[]{faceColorsA[face], faceColorsB[face], faceColorsC[face]};
				int[] vertexKeys = faceVertexKeys(tile, face);

				for (int vertex = 0; vertex < VERTICES_PER_FACE; vertex++) {
					boolean isOverlay = isOverlayFace(tile, face);
					var override = isOverlay ? overlayOverride : underlayOverride;
					if (override.waterType != WaterType.NONE)
						continue; // skip water faces

					vertexHashes[face * VERTICES_PER_FACE + vertex] = vertexKeys[vertex];

					int color = faceColors[vertex];
					vertexColors[face * VERTICES_PER_FACE + vertex] = color;

					vertexOverrides[face * VERTICES_PER_FACE + vertex] = override;
					vertexIsOverlay[face * VERTICES_PER_FACE + vertex] = isOverlay;

					if (isOverlay && useDefaultColor(tile, override))
						vertexDefaultColor[face * VERTICES_PER_FACE + vertex] = true;
				}
			}
		}

		for (int vertex = 0; vertex < vertexHashes.length; vertex++)
		{
			if (vertexHashes[vertex] == 0)
				continue;

			int color = vertexColors[vertex];
			var override = vertexOverrides[vertex];
			if (color < 0 || color == HIDDEN_HSL && !override.forced)
				continue;

			// if this vertex already has a 'high priority' color assigned,
			// skip assigning a 'low priority' color unless there is no color assigned.
			// Near-solid-black tiles that are used in some places under wall objects
			boolean lowPriorityColor = vertexColors[vertex] <= 2;

			float lightenMultiplier = 1.5f;
			int lightenBase = 15;
			int lightenAdd = 3;
			float darkenMultiplier = 0.5f;

			int[] vNormals = sceneContext.vertexTerrainNormals.getOrDefault(vertexHashes[vertex], new int[] { 0, 0, 0 });

			float dot = dot(vNormals);
			if (dot < EPSILON) {
				dot = 0;
			} else {
				// Approximately reverse vanilla tile lighting
				dot = (vNormals[0] + vNormals[1]) / sqrt(2 * dot);
			}
			int lightness = color & 0x7F;
			lightness = (int) mix(lightness, (int) (max(lightness - lightenAdd, 0) * lightenMultiplier) + lightenBase, max(dot, 0));
			lightness = (int) (1.25f * mix(lightness, (int) (lightness * darkenMultiplier), -min(dot, 0)));
			final int maxBrightness = 55; // reduces overexposure
			lightness = min(lightness, maxBrightness);
			color = color & ~0x7F | lightness;

			Material material = override.groundMaterial.getRandomMaterial(worldPos);
			boolean isOverlay = vertexIsOverlay[vertex] != override.blendedAsOpposite;
			color = override.modifyColor(color);

			vertexColors[vertex] = color;

			// mark the vertex as either an overlay or underlay.
			// this is used to determine how to blend between vertex colors
			if (isOverlay)
			{
				sceneContext.vertexIsOverlay.put(vertexHashes[vertex], true);
			}
			else
			{
				sceneContext.vertexIsUnderlay.put(vertexHashes[vertex], true);
			}

			// add color and texture to hashmap
			if ((!lowPriorityColor || !sceneContext.highPriorityColor.containsKey(vertexHashes[vertex])) && !vertexDefaultColor[vertex])
			{
				boolean shouldWrite = isOverlay || !sceneContext.vertexTerrainColor.containsKey(vertexHashes[vertex]);
				if (shouldWrite || !sceneContext.vertexTerrainColor.containsKey(vertexHashes[vertex]))
					sceneContext.vertexTerrainColor.put(vertexHashes[vertex], vertexColors[vertex]);

				if (shouldWrite || !sceneContext.vertexTerrainTexture.containsKey(vertexHashes[vertex]))
					sceneContext.vertexTerrainTexture.put(vertexHashes[vertex], material);

				if (!lowPriorityColor)
					sceneContext.highPriorityColor.put(vertexHashes[vertex], true);
			}
		}
	}

	/**
	 * Generates underwater terrain data by iterating through all Tiles in a given
	 * Scene, increasing the depth of each tile based on its distance from the shore.
	 * Then stores the resulting data in a HashMap.
	 */
	private void generateUnderwaterTerrain(SceneContext sceneContext)
	{
		int sizeX = sceneContext.sizeX;
		int sizeY = sceneContext.sizeZ;
		// true if a tile contains at least 1 face which qualifies as water
		sceneContext.tileIsWater = new boolean[MAX_Z][sizeX][sizeY];
		// true if a vertex is part of a face which qualifies as water; non-existent if not
		sceneContext.vertexIsWater = new HashMap<>();
		// true if a vertex is part of a face which qualifies as land; non-existent if not
		// tiles along the shoreline will be true for both vertexIsWater and vertexIsLand
		sceneContext.vertexIsLand = new HashMap<>();
		// if true, the tile will be skipped when the scene is drawn
		// this is due to certain edge cases with water on the same X/Y on different planes
		sceneContext.skipTile = new boolean[MAX_Z][sizeX][sizeY];
		// the height adjustment for each vertex, to be applied to the vertex'
		// real height to create the underwater terrain
		sceneContext.vertexUnderwaterDepth = new HashMap<>();
		// the basic 'levels' of underwater terrain, used to sink terrain based on its distance
		// from the shore, then used to produce the world-space height offset
		// 0 = land
		sceneContext.underwaterDepthLevels = new int[MAX_Z][sizeX + 1][sizeY + 1];
		// the world-space height offsets of each vertex on the tile grid
		// these offsets are interpolated to calculate offsets for vertices not on the grid (tilemodels)
		final int[][][] underwaterDepths = new int[MAX_Z][sizeX + 1][sizeY + 1];

		for (int z = 0; z < MAX_Z; ++z)
		{
			for (int x = 0; x < sizeX; ++x) {
				// set the array to 1 initially
				// this assumes that all vertices are water;
				// we will set non-water vertices to 0 in the next loop
				Arrays.fill(sceneContext.underwaterDepthLevels[z][x], 1);
			}
		}

		Scene scene = sceneContext.scene;
		Tile[][][] tiles = scene.getExtendedTiles();

		// figure out which vertices are water and assign some data
		for (int z = 0; z < MAX_Z; ++z) {
			for (int x = 0; x < sizeX; ++x) {
				for (int y = 0; y < sizeY; ++y) {
					if (tiles[z][x][y] == null) {
						sceneContext.underwaterDepthLevels[z][x][y] = 0;
						sceneContext.underwaterDepthLevels[z][x + 1][y] = 0;
						sceneContext.underwaterDepthLevels[z][x][y + 1] = 0;
						sceneContext.underwaterDepthLevels[z][x + 1][y + 1] = 0;
						continue;
					}

					Tile tile = tiles[z][x][y];
					if (tile.getBridge() != null) {
						tile = tile.getBridge();
					}

					if (tile.getSceneTilePaint() != null) {
						int[] vertexKeys = tileVertexKeys(sceneContext, tile);

						int[] worldPos = sceneContext.extendedSceneToWorld(x, y, tile.getRenderLevel());
						var override = tileOverrideManager.getOverride(sceneContext, tile, worldPos);
						if (seasonalWaterType(override, tile.getSceneTilePaint().getTexture()) == WaterType.NONE) {
							for (int vertexKey : vertexKeys)
								if (tile.getSceneTilePaint().getNeColor() != HIDDEN_HSL || override.forced)
									sceneContext.vertexIsLand.put(vertexKey, true);

							sceneContext.underwaterDepthLevels[z][x][y] = 0;
							sceneContext.underwaterDepthLevels[z][x + 1][y] = 0;
							sceneContext.underwaterDepthLevels[z][x][y + 1] = 0;
							sceneContext.underwaterDepthLevels[z][x + 1][y + 1] = 0;
						} else {
							// Stop tiles on the same X,Y coordinates on different planes from
							// each generating water. Prevents undesirable results in certain places.
							if (z > 0) {
								boolean continueLoop = false;

								for (int checkZ = 0; checkZ < z; ++checkZ) {
									if (sceneContext.tileIsWater[checkZ][x][y]) {
										sceneContext.underwaterDepthLevels[z][x][y] = 0;
										sceneContext.underwaterDepthLevels[z][x + 1][y] = 0;
										sceneContext.underwaterDepthLevels[z][x][y + 1] = 0;
										sceneContext.underwaterDepthLevels[z][x + 1][y + 1] = 0;

										sceneContext.skipTile[z][x][y] = true;

										continueLoop = true;

										break;
									}
								}

								if (continueLoop)
									continue;
							}

							sceneContext.tileIsWater[z][x][y] = true;

							for (int vertexKey : vertexKeys)
							{
								sceneContext.vertexIsWater.put(vertexKey, true);
							}
						}
					}
					else if (tile.getSceneTileModel() != null)
					{
						SceneTileModel model = tile.getSceneTileModel();

						int faceCount = model.getFaceX().length;

						int tileZ = tile.getRenderLevel();
						int[] worldPos = sceneContext.extendedSceneToWorld(x, y, tileZ);
						int overlayId = OVERLAY_FLAG | scene.getOverlayIds()[tileZ][x][y];
						int underlayId = scene.getUnderlayIds()[tileZ][x][y];
						var overlayOverride = tileOverrideManager.getOverride(sceneContext, tile, worldPos, overlayId);
						var underlayOverride = tileOverrideManager.getOverride(sceneContext, tile, worldPos, underlayId);

						// Stop tiles on the same X,Y coordinates on different planes from
						// each generating water. Prevents undesirable results in certain places.
						if (z > 0)
						{
							boolean tileIncludesWater = false;
							for (int face = 0; face < faceCount; face++)
							{
								var override = ProceduralGenerator.isOverlayFace(tile, face) ? overlayOverride : underlayOverride;
								int textureId = model.getTriangleTextureId() == null ? -1 :
									model.getTriangleTextureId()[face];
								if (seasonalWaterType(override, textureId) != WaterType.NONE)
								{
									tileIncludesWater = true;
									break;
								}
							}

							if (tileIncludesWater)
							{
								boolean continueLoop = false;

								for (int checkZ = 0; checkZ < z; ++checkZ)
								{
									if (sceneContext.tileIsWater[checkZ][x][y])
									{
										sceneContext.underwaterDepthLevels[z][x][y] = 0;
										sceneContext.underwaterDepthLevels[z][x + 1][y] = 0;
										sceneContext.underwaterDepthLevels[z][x][y + 1] = 0;
										sceneContext.underwaterDepthLevels[z][x + 1][y + 1] = 0;

										sceneContext.skipTile[z][x][y] = true;

										continueLoop = true;

										break;
									}
								}

								if (continueLoop)
									continue;
							}
						}

						for (int face = 0; face < faceCount; face++)
						{
							int[][] vertices = faceVertices(tile, face);
							int[] vertexKeys = faceVertexKeys(tile, face);

							var override = ProceduralGenerator.isOverlayFace(tile, face) ? overlayOverride : underlayOverride;
							int textureId = model.getTriangleTextureId() == null ? -1 :
								model.getTriangleTextureId()[face];
							if (seasonalWaterType(override, textureId) == WaterType.NONE)
							{
								for (int vertex = 0; vertex < VERTICES_PER_FACE; vertex++)
								{
									if (model.getTriangleColorA()[face] != HIDDEN_HSL || override.forced)
										sceneContext.vertexIsLand.put(vertexKeys[vertex], true);

									if (vertices[vertex][0] % LOCAL_TILE_SIZE == 0 &&
										vertices[vertex][1] % LOCAL_TILE_SIZE == 0
									) {
										int vX = (vertices[vertex][0] >> LOCAL_COORD_BITS) + sceneContext.sceneOffset;
										int vY = (vertices[vertex][1] >> LOCAL_COORD_BITS) + sceneContext.sceneOffset;

										sceneContext.underwaterDepthLevels[z][vX][vY] = 0;
									}
								}
							}
							else
							{
								sceneContext.tileIsWater[z][x][y] = true;

								for (int vertex = 0; vertex < VERTICES_PER_FACE; vertex++)
								{
									sceneContext.vertexIsWater.put(vertexKeys[vertex], true);
								}
							}
						}
					}
					else
					{
						sceneContext.underwaterDepthLevels[z][x][y] = 0;
						sceneContext.underwaterDepthLevels[z][x + 1][y] = 0;
						sceneContext.underwaterDepthLevels[z][x][y + 1] = 0;
						sceneContext.underwaterDepthLevels[z][x + 1][y + 1] = 0;
					}
				}
			}
		}

		// Sink terrain further from shore by desired levels.
		for (int level = 0; level < DEPTH_LEVEL_SLOPE.length - 1; level++)
		{
			for (int z = 0; z < MAX_Z; ++z)
			{
				for (int x = 0; x < sceneContext.underwaterDepthLevels[z].length; x++)
				{
					for (int y = 0; y < sceneContext.underwaterDepthLevels[z][x].length; y++)
					{
						if (sceneContext.underwaterDepthLevels[z][x][y] == 0)
						{
							// Skip the tile if it isn't water.
							continue;
						}
						// If it's on the edge of the scene, reset the depth so
						// it creates a 'wall' to prevent fog from passing through.
						// Not incredibly effective, but better than nothing.
						if (x == 0 || y == 0 || x == EXTENDED_SCENE_SIZE || y == EXTENDED_SCENE_SIZE) {
							sceneContext.underwaterDepthLevels[z][x][y] = 0;
							continue;
						}

						int tileHeight = sceneContext.underwaterDepthLevels[z][x][y];
						if (sceneContext.underwaterDepthLevels[z][x - 1][y] < tileHeight)
						{
							// West
							continue;
						}
						if (x < sceneContext.underwaterDepthLevels[z].length - 1 && sceneContext.underwaterDepthLevels[z][x + 1][y] < tileHeight)
						{
							// East
							continue;
						}
						if (sceneContext.underwaterDepthLevels[z][x][y - 1] < tileHeight)
						{
							// South
							continue;
						}
						if (y < sceneContext.underwaterDepthLevels[z].length - 1 && sceneContext.underwaterDepthLevels[z][x][y + 1] < tileHeight)
						{
							// North
							continue;
						}
						// At this point, it's surrounded only by other depth-adjusted vertices.
						sceneContext.underwaterDepthLevels[z][x][y]++;
					}
				}
			}
		}

		// Adjust the height levels to world coordinate offsets and add to an array.
		for (int z = 0; z < MAX_Z; ++z)
		{
			for (int x = 0; x < sceneContext.underwaterDepthLevels[z].length; x++)
			{
				for (int y = 0; y < sceneContext.underwaterDepthLevels[z][x].length; y++)
				{
					if (sceneContext.underwaterDepthLevels[z][x][y] == 0)
					{
						continue;
					}
					int depth = DEPTH_LEVEL_SLOPE[sceneContext.underwaterDepthLevels[z][x][y] - 1];
					int heightOffset = (int) (depth * .55f); // legacy weirdness
					underwaterDepths[z][x][y] = heightOffset;
				}
			}
		}

		// Store the height offsets in a hashmap and calculate interpolated
		// height offsets for non-corner vertices.
		for (int z = 0; z < MAX_Z; ++z) {
			for (int x = 0; x < sizeX; ++x) {
				for (int y = 0; y < sizeY; ++y) {
					if (!sceneContext.tileIsWater[z][x][y]) {
						continue;
					}

					Tile tile = tiles[z][x][y];
					if (tile == null) {
						continue;
					}

					if (tile.getBridge() != null) {
						tile = tile.getBridge();
					}
					if (tile.getSceneTilePaint() != null) {
						int[] vertexKeys = tileVertexKeys(sceneContext, tile);

						int swVertexKey = vertexKeys[0];
						int seVertexKey = vertexKeys[1];
						int nwVertexKey = vertexKeys[2];
						int neVertexKey = vertexKeys[3];

						sceneContext.vertexUnderwaterDepth.put(swVertexKey, underwaterDepths[z][x][y]);
						sceneContext.vertexUnderwaterDepth.put(seVertexKey, underwaterDepths[z][x + 1][y]);
						sceneContext.vertexUnderwaterDepth.put(nwVertexKey, underwaterDepths[z][x][y + 1]);
						sceneContext.vertexUnderwaterDepth.put(neVertexKey, underwaterDepths[z][x + 1][y + 1]);
					}
					else if (tile.getSceneTileModel() != null)
					{
						SceneTileModel sceneTileModel = tile.getSceneTileModel();

						int faceCount = sceneTileModel.getFaceX().length;

						for (int face = 0; face < faceCount; face++)
						{
							int[][] vertices = faceVertices(tile, face);
							int[] vertexKeys = faceVertexKeys(tile, face);

							for (int vertex = 0; vertex < VERTICES_PER_FACE; vertex++)
							{
								if (vertices[vertex][0] % LOCAL_TILE_SIZE == 0 &&
									vertices[vertex][1] % LOCAL_TILE_SIZE == 0
								) {
									// The vertex is at the corner of the tile;
									// simply use the offset in the tile grid array.

									int vX = (vertices[vertex][0] >> LOCAL_COORD_BITS) + sceneContext.sceneOffset;
									int vY = (vertices[vertex][1] >> LOCAL_COORD_BITS) + sceneContext.sceneOffset;

									sceneContext.vertexUnderwaterDepth.put(vertexKeys[vertex], underwaterDepths[z][vX][vY]);
								}
								else
								{
									// If the tile is a tile model and this vertex is shared only by faces that are water,
									// interpolate between the height offsets at each corner to get the height offset
									// of the vertex.

									float lerpX = fract(vertices[vertex][0] / (float) LOCAL_TILE_SIZE);
									float lerpY = fract(vertices[vertex][1] / (float) LOCAL_TILE_SIZE);
									float northHeightOffset = mix(underwaterDepths[z][x][y + 1], underwaterDepths[z][x + 1][y + 1], lerpX);
									float southHeightOffset = mix(underwaterDepths[z][x][y], underwaterDepths[z][x + 1][y], lerpX);
									int heightOffset = (int) mix(southHeightOffset, northHeightOffset, lerpY);

									if (!sceneContext.vertexIsLand.containsKey(vertexKeys[vertex]))
										sceneContext.vertexUnderwaterDepth.put(vertexKeys[vertex], heightOffset);
								}
							}
						}
					}
				}
			}
		}
	}

	/**
	 * Iterates through all Tiles in a given Scene, calculating vertex normals
	 * for each one, then stores resulting normal data in a HashMap.
	 */
	private void calculateTerrainNormals(SceneContext sceneContext)
	{
		sceneContext.vertexTerrainNormals = new HashMap<>();

		for (Tile[][] plane : sceneContext.scene.getExtendedTiles()) {
			for (Tile[] column : plane) {
				for (Tile tile : column) {
					if (tile != null) {
						boolean isBridge = false;

						if (tile.getBridge() != null) {
							calculateNormalsForTile(sceneContext, tile.getBridge(), false);
							isBridge = true;
						}
						calculateNormalsForTile(sceneContext, tile, isBridge);
					}
				}
			}
		}

		sceneContext.vertexTerrainNormals.forEach((key, normal) -> {
			var n = normalize(vec(normal));
			for (int i = 0; i < 3; i++)
				normal[i] = GpuIntBuffer.normShort(n[i]);
		});
	}

	/**
	 * Calculates vertex normals for a given Tile,
	 * then stores resulting normal data in a HashMap.
	 *
	 * @param sceneContext that the tile is associated with
	 * @param tile         to calculate normals for
	 * @param isBridge     whether the tile is a bridge tile, i.e. tile above
	 */
	private void calculateNormalsForTile(SceneContext sceneContext, Tile tile, boolean isBridge)
	{
		// Make array of tile's tris with vertices
		int[][][] faceVertices; // Array of tile's tri vertices
		int[][] faceVertexKeys;

		if (tile.getSceneTileModel() != null)
		{
			// Tile model
			SceneTileModel tileModel = tile.getSceneTileModel();
			faceVertices = new int[tileModel.getFaceX().length][VERTICES_PER_FACE][3];
			faceVertexKeys = new int[tileModel.getFaceX().length][VERTICES_PER_FACE];

			for (int face = 0; face < tileModel.getFaceX().length; face++)
			{
				int[][] vertices = faceVertices(tile, face);

				faceVertices[face][0] = new int[]{vertices[0][0], vertices[0][1], vertices[0][2]};
				faceVertices[face][2] = new int[]{vertices[1][0], vertices[1][1], vertices[1][2]};
				faceVertices[face][1] = new int[]{vertices[2][0], vertices[2][1], vertices[2][2]};

				int[] vertexKeys = faceVertexKeys(tile, face);
				faceVertexKeys[face][0] = vertexKeys[0];
				faceVertexKeys[face][2] = vertexKeys[1];
				faceVertexKeys[face][1] = vertexKeys[2];
			}
		}
		else
		{
			faceVertices = new int[2][VERTICES_PER_FACE][3];
			faceVertexKeys = new int[VERTICES_PER_FACE][3];
			int[][] vertices = tileVertices(sceneContext, tile);
			faceVertices[0] = new int[][]{vertices[3], vertices[1], vertices[2]};
			faceVertices[1] = new int[][]{vertices[0], vertices[2], vertices[1]};

			int[] vertexKeys = tileVertexKeys(sceneContext, tile);
			faceVertexKeys[0] = new int[]{vertexKeys[3], vertexKeys[1], vertexKeys[2]};
			faceVertexKeys[1] = new int[]{vertexKeys[0], vertexKeys[2], vertexKeys[1]};
		}

		// Loop through tris to calculate and accumulate normals
		for (int face = 0; face < faceVertices.length; face++)
		{
			// XYZ
			int[] vertexHeights = new int[]{faceVertices[face][0][2], faceVertices[face][1][2], faceVertices[face][2][2]};
			if (!isBridge)
			{
				vertexHeights[0] += sceneContext.vertexUnderwaterDepth.getOrDefault(faceVertexKeys[face][0], 0);
				vertexHeights[1] += sceneContext.vertexUnderwaterDepth.getOrDefault(faceVertexKeys[face][1], 0);
				vertexHeights[2] += sceneContext.vertexUnderwaterDepth.getOrDefault(faceVertexKeys[face][2], 0);
			}

			int[] vertexNormals = calculateSurfaceNormals(
				ivec(
					faceVertices[face][0][0],
					faceVertices[face][0][1],
					vertexHeights[0]
				),
				ivec(
					faceVertices[face][1][0],
					faceVertices[face][1][1],
					vertexHeights[1]
				),
				ivec(
					faceVertices[face][2][0],
					faceVertices[face][2][1],
					vertexHeights[2]
				)
			);

			for (int vertex = 0; vertex < VERTICES_PER_FACE; vertex++)
			{
				int vertexKey = faceVertexKeys[face][vertex];
				// accumulate normals to hashmap
				sceneContext.vertexTerrainNormals.merge(vertexKey, vertexNormals, (a, b) -> add(a, a, b));
			}
		}
	}

	public boolean useDefaultColor(Tile tile, TileOverride override)
	{
		if ((tile.getSceneTilePaint() != null && tile.getSceneTilePaint().getTexture() >= 0) ||
			(tile.getSceneTileModel() != null && tile.getSceneTileModel().getTriangleTextureId() != null))
		{
			// skip tiles with textures provided by default
			return true;
		}

		if (override == TileOverride.NONE)
			return false;

		return !override.blended;
	}

	public WaterType seasonalWaterType(TileOverride override, int textureId)
	{
		var waterType = override.waterType;

		// As a fallback, always consider vanilla textured water tiles as water
		// We purposefully ignore material replacements here such as ice from the winter theme
		if (waterType == WaterType.NONE) {
			if (130 <= textureId && textureId <= 189 || textureId == 208) {
				// New sailing water textures
				waterType = waterTypeManager.getFallback(textureId);
			} else {
				switch (textureId) {
					case 1:
					case 24:
						waterType = WaterType.WATER; // This used to be WATER_FLAT, but for sailing we want translucent water
						break;
					case 25:
						waterType = WaterType.SWAMP_WATER_FLAT;
						break;
				}
			}
		}

		// Disable the winter theme ice
//		if (waterType == WaterType.WATER && plugin.configSeasonalTheme == SeasonalTheme.WINTER)
//			return WaterType.ICE;

		return waterType;
	}

	private static boolean[] getTileOverlayTris(int tileShapeIndex)
	{
		if (tileShapeIndex >= TILE_OVERLAY_TRIS.length)
		{
			log.debug("getTileOverlayTris(): unknown tileShapeIndex ({})", tileShapeIndex);
			return new boolean[10]; // false
		}
		else
		{
			return TILE_OVERLAY_TRIS[tileShapeIndex];
		}
	}

	public static boolean isOverlayFace(Tile tile, int face) {
		int tileShapeIndex = tile.getSceneTileModel().getShape() - 1;
		if (face >= getTileOverlayTris(tileShapeIndex).length) {
			return false;
		}
		return getTileOverlayTris(tileShapeIndex)[face];
	}

	private static void tileVertices(SceneContext ctx, Tile tile, int[][] vertices) {
		int tileX = tile.getSceneLocation().getX();
		int tileY = tile.getSceneLocation().getY();
		int tileExX = tileX + ctx.sceneOffset;
		int tileExY = tileY + ctx.sceneOffset;
		int tileZ = tile.getRenderLevel();
		int[][][] tileHeights = ctx.scene.getTileHeights();

		// swVertex
		vertices[0][0] = tileX * LOCAL_TILE_SIZE;
		vertices[0][1] = tileY * LOCAL_TILE_SIZE;
		vertices[0][2] = tileHeights[tileZ][tileExX][tileExY];

		// seVertex
		vertices[1][0] = (tileX + 1) * LOCAL_TILE_SIZE;
		vertices[1][1] = tileY * LOCAL_TILE_SIZE;
		vertices[1][2] = tileHeights[tileZ][tileExX + 1][tileExY];

		// nwVertex
		vertices[2][0] = tileX * LOCAL_TILE_SIZE;
		vertices[2][1] = (tileY + 1) * LOCAL_TILE_SIZE;
		vertices[2][2] = tileHeights[tileZ][tileExX][tileExY + 1];

		//neVertex
		vertices[3][0] = (tileX + 1) * LOCAL_TILE_SIZE;
		vertices[3][1] = (tileY + 1) * LOCAL_TILE_SIZE;
		vertices[3][2] = tileHeights[tileZ][tileExX + 1][tileExY + 1];
	}

	private static int[][] tileVertices(SceneContext ctx, Tile tile) {
		int[][] vertices = new int[4][3];
		tileVertices(ctx, tile, vertices);
		return vertices;
	}

	private static void faceVertices(Tile tile, int face, int[][] vertices)
	{
		SceneTileModel sceneTileModel = tile.getSceneTileModel();

		final int[] faceA = sceneTileModel.getFaceX();
		final int[] faceB = sceneTileModel.getFaceY();
		final int[] faceC = sceneTileModel.getFaceZ();

		final int[] vertexX = sceneTileModel.getVertexX();
		final int[] vertexY = sceneTileModel.getVertexY();
		final int[] vertexZ = sceneTileModel.getVertexZ();

		int vertexFacesA = faceA[face];
		int vertexFacesB = faceB[face];
		int vertexFacesC = faceC[face];

		// scene X
		vertices[0][0] = vertexX[vertexFacesA];
		vertices[1][0] = vertexX[vertexFacesB];
		vertices[2][0] = vertexX[vertexFacesC];
		// scene Y
		vertices[0][1] = vertexZ[vertexFacesA];
		vertices[1][1] = vertexZ[vertexFacesB];
		vertices[2][1] = vertexZ[vertexFacesC];
		// scene Z - heights
		vertices[0][2] = vertexY[vertexFacesA];
		vertices[1][2] = vertexY[vertexFacesB];
		vertices[2][2] = vertexY[vertexFacesC];
	}

	private static int[][] faceVertices(Tile tile, int face)
	{
		int[][] vertices = new int[3][3];
		faceVertices(tile, face, vertices);
		return vertices;
	}

	/**
	 * Returns vertex positions in local coordinates, between 0 and 128.
	 */
	public static void faceLocalVertices(Tile tile, int face, int[][] vertices) {
		if (tile.getSceneTileModel() == null) {
			for (int[] vertex : vertices)
				Arrays.fill(vertex, 0);
			return;
		}

		int x = tile.getSceneLocation().getX();
		int y = tile.getSceneLocation().getY();
		int baseX = x * LOCAL_TILE_SIZE;
		int baseY = y * LOCAL_TILE_SIZE;

		faceVertices(tile, face, vertices);
		for (int[] vertex : vertices) {
			vertex[0] -= baseX;
			vertex[1] -= baseY;
		}
	}

	public static int[][] faceLocalVertices(Tile tile, int face) {
		int[][] vertices = new int[3][3];
		faceLocalVertices(tile, face, vertices);
		return vertices;
	}

	/**
	 * Gets the vertex keys of a Tile Paint tile for use in retrieving data from hashmaps.
	 * Writes the vertex keys in following order: SW, SE, NW, NE
	 *
	 * @param ctx that the tile is from
	 * @param tile to get the vertex keys of
	 */
	public static void tileVertexKeys(SceneContext ctx, Tile tile, int[][] tileVertices, int[] vertexHashes)
	{
		tileVertices(ctx, tile, tileVertices);
		for (int vertex = 0; vertex < tileVertices.length; ++vertex)
			vertexHashes[vertex] = fastVertexHash(tileVertices[vertex]);
	}

	public static void tileVertexKeys(SceneContext ctx, Tile tile, int[] vertexHashes)
	{
		int[][] vertices = new int[4][3];
		tileVertexKeys(ctx, tile, vertices, vertexHashes);
	}

	public static int[] tileVertexKeys(SceneContext ctx, Tile tile)
	{
		int[] vertexHashes = new int[4];
		tileVertexKeys(ctx, tile, vertexHashes);
		return vertexHashes;
	}

	public static void faceVertexKeys(Tile tile, int face, int[][] vertices, int[] vertexHashes)
	{
		faceVertices(tile, face, vertices);
		for (int vertex = 0; vertex < vertices.length; ++vertex)
			vertexHashes[vertex] = fastVertexHash(vertices[vertex]);
	}

	public static int[] faceVertexKeys(Tile tile, int face)
	{
		int[][] vertices = new int[3][3];
		int[] vertexHashes = new int[4];
		faceVertexKeys(tile, face, vertices, vertexHashes);
		return vertexHashes;
	}

	private static final int[] tzHaarRecolored = new int[4];
	// used when calculating the gradient to apply to the walls of TzHaar
	// to emulate the style from 2008 HD rework
	private static final float[] gradientBaseColor = vec(3, 4, 26);
	private static final float[] gradientDarkColor = vec(3, 4, 10);
	private static final int gradientBottom = 200;
	private static final int gradientTop = -200;

	public static int[] recolorTzHaar(
		int uuid,
		ModelOverride modelOverride,
		Model model,
		int face,
		int color1,
		int color2,
		int color3
	) {
		int[] hsl1 = ColorUtils.unpackRawHsl(color1);
		int[] hsl2 = ColorUtils.unpackRawHsl(color2);
		int[] hsl3 = ColorUtils.unpackRawHsl(color3);

		// shift model hues from red->yellow
		int hue = 7;
		hsl1[0] = hsl2[0] = hsl3[0] = hue;

		int transparency = 0;

		// recolor tzhaar to look like the 2008+ HD version
		if (ModelHash.getUuidSubType(uuid) == ModelHash.TYPE_GROUND_OBJECT) {
			// remove the black parts of floor objects to allow the ground to show,
			// so we can apply textures, ground blending, etc. to it
			if (hsl1[1] <= 1)
				transparency = 0xFF;
		}

		if (modelOverride.tzHaarRecolorType == TzHaarRecolorType.GRADIENT) {
			final int triA = model.getFaceIndices1()[face];
			final int triB = model.getFaceIndices2()[face];
			final int triC = model.getFaceIndices3()[face];
			final float[] yVertices = model.getVerticesY();
			float heightA = yVertices[triA];
			float heightB = yVertices[triB];
			float heightC = yVertices[triC];

			// apply coloring to the rocky walls
			if (hsl1[2] < 20) {
				float pos = clamp((heightA - gradientTop) / (float) gradientBottom, 0.0f, 1.0f);
				round(hsl1, mix(gradientDarkColor, gradientBaseColor, pos));
			}

			if (hsl2[2] < 20)
			{
				float pos = clamp((heightB - gradientTop) / (float) gradientBottom, 0.0f, 1.0f);
				round(hsl2, mix(gradientDarkColor, gradientBaseColor, pos));
			}

			if (hsl3[2] < 20)
			{
				float pos = clamp((heightC - gradientTop) / (float) gradientBottom, 0.0f, 1.0f);
				round(hsl3, mix(gradientDarkColor, gradientBaseColor, pos));
			}
		}
		else if (modelOverride.tzHaarRecolorType == TzHaarRecolorType.HUE_SHIFT)
		{
			// objects around the entrance to The Inferno only need a hue-shift
			// and very slight lightening to match the lightened terrain
			hsl1[2] += 1;
			hsl2[2] += 1;
			hsl3[2] += 1;
		}

		tzHaarRecolored[0] = ColorUtils.packRawHsl(hsl1);
		tzHaarRecolored[1] = ColorUtils.packRawHsl(hsl2);
		tzHaarRecolored[2] = ColorUtils.packRawHsl(hsl3);
		tzHaarRecolored[3] = transparency;

		return tzHaarRecolored;
	}
}

package rs117.hd.scene;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Objects;
import java.util.stream.Stream;
import javax.annotation.Nullable;
import net.runelite.api.*;
import net.runelite.api.coords.*;
import rs117.hd.scene.areas.AABB;
import rs117.hd.scene.areas.Area;
import rs117.hd.scene.environments.Environment;
import rs117.hd.scene.lights.Light;
import rs117.hd.scene.materials.Material;
import rs117.hd.scene.tile_overrides.TileOverrideVariables;
import rs117.hd.utils.HDUtils;

import static net.runelite.api.Constants.*;
import static net.runelite.api.Constants.SCENE_SIZE;
import static net.runelite.api.Perspective.*;
import static rs117.hd.utils.MathUtils.*;

public class SceneContext {
	public final Client client;
	public final Scene scene;
	public final int expandedMapLoadingChunks;
	public int sizeX, sizeZ;

	@Nullable
	public final int[] sceneBase;
	public final AABB sceneBounds;
	public int sceneOffset;

	public boolean enableAreaHiding;
	public boolean fillGaps;
	public boolean isPrepared;
	public boolean isInChambersOfXeric;
	public boolean isInHouse;

	@Nullable
	public Area currentArea;
	public Area[] possibleAreas = new Area[0];
	public final ArrayList<Environment> environments = new ArrayList<>();
	public byte[][] filledTiles = new byte[EXTENDED_SCENE_SIZE][EXTENDED_SCENE_SIZE];

	public int staticVertexCount = 0;

	public int staticGapFillerTilesOffset;
	public int staticGapFillerTilesVertexCount;
	public int staticCustomTilesOffset;
	public int staticCustomTilesVertexCount;

	// Statistics
	public int uniqueModels;

	// Terrain data
	public HashMap<Integer, Integer> vertexTerrainColor;
	public HashMap<Integer, Material> vertexTerrainTexture;
	public HashMap<Integer, int[]> vertexTerrainNormals;
	// Used for overriding potentially low quality vertex colors
	public HashMap<Integer, Boolean> highPriorityColor;

	// Water-related data
	public boolean[][][] tileIsWater;
	public HashMap<Integer, Boolean> vertexIsWater;
	public HashMap<Integer, Boolean> vertexIsLand;
	public HashMap<Integer, Boolean> vertexIsOverlay;
	public HashMap<Integer, Boolean> vertexIsUnderlay;
	public boolean[][][] skipTile;
	public HashMap<Integer, Integer> vertexUnderwaterDepth;
	public int[][][] underwaterDepthLevels;

	// Thread safe tile override variables
	public final ThreadLocal<TileOverrideVariables> tileOverrideVars = ThreadLocal.withInitial(TileOverrideVariables::new);

	public int numVisibleLights = 0;
	public final ArrayList<Light> lights = new ArrayList<>();
	public final HashSet<Projectile> knownProjectiles = new HashSet<>();
	public final ArrayList<TileObject> lightSpawnsToHandleOnClientThread = new ArrayList<>();

	// Model pusher arrays, to avoid simultaneous usage from different threads
	public final int[] modelFaceVertices = new int[12];
	public final float[] modelFaceUvs = new float[12];
	public final float[] modelFaceNormals = new float[12];
	public final int[] modelPusherResults = new int[2];

	public SceneContext(Client client, Scene scene, int expandedMapLoadingChunks) {
		this.client = client;
		this.scene = scene;
		this.expandedMapLoadingChunks = expandedMapLoadingChunks;
//		this.sizeX = SCENE_SIZE + expandedMapLoadingChunks * CHUNK_SIZE;
//		this.sizeZ = SCENE_SIZE + expandedMapLoadingChunks * CHUNK_SIZE;
		sizeX = sizeZ = EXTENDED_SCENE_SIZE;
		sceneOffset = (EXTENDED_SCENE_SIZE - SCENE_SIZE) / 2;
		sceneBase = findSceneBase();
		sceneBounds = findSceneBounds(sceneBase);
	}

	public synchronized void destroy() {}

	/**
	 * Transform local coordinates into world coordinates.
	 * If the {@link LocalPoint} is not in the scene, this returns untranslated coordinates when in instances.
	 *
	 * @param localPoint to transform
	 * @param plane      which the local coordinate is on
	 * @return world coordinate
	 */
	public int[] localToWorld(LocalPoint localPoint, int plane) {
		return localToWorld(localPoint.getX(), localPoint.getY(), plane);
	}

	public int[] localToWorld(LocalPoint localPoint, int plane, int[] result) {
		return localToWorld(localPoint.getX(), localPoint.getY(), plane, result);
	}

	public int[] localToWorld(LocalPoint localPoint) {
		return localToWorld(localPoint, client.getPlane());
	}

	public int[] localToWorld(int localX, int localY) {
		return localToWorld(localX, localY, client.getPlane());
	}

	public int[] localToWorld(int localX, int localY, int plane) {
		return sceneToWorld(localX >> LOCAL_COORD_BITS, localY >> LOCAL_COORD_BITS, plane);
	}

	public int[] localToWorld(int localX, int localY, int plane, int[] result) {
		sceneToWorld(localX >> LOCAL_COORD_BITS, localY >> LOCAL_COORD_BITS, plane, result);
		return result;
	}

	public void sceneToWorld(int sceneX, int sceneY, int plane, int[] result) {
		if (sceneBase == null) {
			HDUtils.sceneToWorld(scene, sceneX, sceneY, plane, result);
			return;
		}

		result[0] = sceneBase[0] + sceneX;
		result[1] = sceneBase[1] + sceneY;
		result[2] = sceneBase[2] + plane;
	}

	public int[] sceneToWorld(int sceneX, int sceneY, int plane) {
		int[] result = new int[3];
		sceneToWorld(sceneX, sceneY, plane, result);
		return result;
	}

	public void extendedSceneToWorld(int sceneExX, int sceneExY, int plane, int[] result) {
		sceneToWorld(sceneExX - sceneOffset, sceneExY - sceneOffset, plane, result);
	}

	public int[] extendedSceneToWorld(int sceneExX, int sceneExY, int plane) {
		return sceneToWorld(sceneExX - sceneOffset, sceneExY - sceneOffset, plane);
	}

	public Stream<int[]> worldToLocals(WorldPoint worldPoint) {
		if (sceneBase != null)
			return Stream.of(worldToLocal(worldPoint));
		// If the scene is not contiguous, convert the world point to world points within the instance, then to local coords
		return WorldPoint.toLocalInstance(scene, worldPoint)
			.stream()
			.filter(Objects::nonNull)
			.map(instancePoint -> ivec(
				(instancePoint.getX() - scene.getBaseX()) * LOCAL_TILE_SIZE,
				(instancePoint.getY() - scene.getBaseY()) * LOCAL_TILE_SIZE,
				instancePoint.getPlane()
			));
	}

	/**
	 * Gets the local coordinate at the south-western corner of the tile, if the scene is contiguous, otherwise null
	 */
	@Nullable
	public int[] worldToLocal(WorldPoint worldPoint) {
		if (sceneBase == null)
			return null;
		return ivec(
			(worldPoint.getX() - sceneBase[0]) * LOCAL_TILE_SIZE,
			(worldPoint.getY() - sceneBase[1]) * LOCAL_TILE_SIZE,
			worldPoint.getPlane()
		);
	}

	public boolean intersects(Area area) {
		return intersects(area.aabbs);
	}

	public boolean intersects(AABB... aabbs) {
		return HDUtils.sceneIntersects(scene, expandedMapLoadingChunks, aabbs);
	}

	public AABB getNonInstancedSceneBounds() {
		return HDUtils.getNonInstancedSceneBounds(scene, expandedMapLoadingChunks);
	}

	/**
	 * Returns the south-west coordinate of the scene in world coordinates, after resolving instance template chunks
	 * to their original world coordinates. If the scene is instanced, this returns null when the chunks aren't contiguous.
	 */
	@Nullable
	private int[] findSceneBase() {
		int baseX = scene.getBaseX();
		int baseY = scene.getBaseY();
		int basePlane = 0;

		if (scene.isInstance()) {
			boolean foundChunk = false;

			int[][][] chunks = scene.getInstanceTemplateChunks();
			for (int plane = 0; plane < chunks.length; plane++) {
				for (int x = 0; x < chunks[plane].length; x++) {
					for (int y = 0; y < chunks[plane][x].length; y++) {
						int chunk = chunks[plane][x][y];
						if (chunk == -1)
							continue; // Ignore unfilled chunks

						// Ensure the chunk isn't rotated (although we technically could handle consistent rotation)
						int rotation = chunk >> 1 & 0x3;
						if (rotation != 0)
							return null;

						int chunkX = chunk >> 14 & 0x3FF;
						int chunkY = chunk >> 3 & 0x7FF;
						int chunkPlane = chunk >> 24 & 0x3;

						if (foundChunk) {
							int expectedX = baseX + x;
							int expectedY = baseY + y;
							int expectedPlane = basePlane + plane;
							if (chunkX != expectedX || chunkY != expectedY || chunkPlane != expectedPlane)
								return null; // Not contiguous
						} else {
							// Calculate the expected unextended scene base chunk
							baseX = chunkX - x;
							baseY = chunkY - y;
							basePlane = chunkPlane - plane;
							foundChunk = true;
						}
					}
				}
			}

			if (!foundChunk)
				return null;

			// Transform chunk to world coordinates
			baseX <<= 3;
			baseY <<= 3;
		}

		return ivec(baseX, baseY, basePlane);
	}

	/**
	 * Works for non-instanced scenes & contiguous instanced scenes.
	 * Returns a best attempt for non-contiguous instanced scenes, which may be
	 * significantly larger than necessary, but will always include all tiles.
	 */
	private AABB findSceneBounds(@Nullable int[] sceneBase) {
		if (sceneBase != null) {
			int x = sceneBase[0] - sceneOffset;
			int y = sceneBase[1] - sceneOffset;
			return new AABB(x, y, x + EXTENDED_SCENE_SIZE - 1, y + EXTENDED_SCENE_SIZE - 1);
		}

		// Assume instances are assembled from approximately adjacent chunks on the map
		int minX = Integer.MAX_VALUE;
		int minY = Integer.MAX_VALUE;
		int minZ = MAX_Z;
		int maxX = Integer.MIN_VALUE;
		int maxY = Integer.MIN_VALUE;
		int maxZ = 0;

		int[][][] chunks = scene.getInstanceTemplateChunks();
		for (int[][] plane : chunks) {
			for (int[] column : plane) {
				for (int chunk : column) {
					if (chunk == -1)
						continue;

					// Extract chunk coordinates
					int x = chunk >> 14 & 0x3FF;
					int y = chunk >> 3 & 0x7FF;
					int z = chunk >> 24 & 0x3;
					minX = min(minX, x);
					minY = min(minY, y);
					minZ = min(minZ, z);
					maxX = max(maxX, x);
					maxY = max(maxY, y);
					maxZ = max(maxZ, z);
				}
			}
		}

		// Return an AABB representing no match, if there are no chunks
		if (maxX < minX)
			return new AABB(-1, -1);

		// Transform from chunk to world coordinates
		return new AABB(minX << 3, minY << 3, minZ, (maxX << 3) + CHUNK_SIZE - 1, (maxY << 3) + CHUNK_SIZE - 1, maxZ);
	}
}

/*
 * Copyright (c) 2018, Adam <Adam@sigterm.info>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package rs117.hd.scene;

import java.awt.geom.AffineTransform;
import java.awt.image.AffineTransformOp;
import java.awt.image.BufferedImage;
import java.awt.image.DataBufferInt;
import java.nio.IntBuffer;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.ScheduledFuture;
import java.util.concurrent.TimeUnit;
import javax.annotation.Nullable;
import javax.inject.Inject;
import javax.inject.Singleton;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.*;
import net.runelite.client.callback.ClientThread;
import org.lwjgl.BufferUtils;
import org.lwjgl.opengl.*;
import rs117.hd.HdPluginConfig;
import rs117.hd.utils.Props;
import rs117.hd.utils.ResourcePath;

import static org.lwjgl.opengl.GL33C.*;
import static rs117.hd.utils.MathUtils.*;
import static rs117.hd.utils.ResourcePath.path;

@Slf4j
@Singleton
public class TextureManager {
	private static final String[] SUPPORTED_IMAGE_EXTENSIONS = { "png", "jpg" };
	private static final ResourcePath TEXTURE_PATH = Props
		.getFolder("rlhd.texture-path", () -> path(TextureManager.class, "textures"));

	@Inject
	private Client client;

	@Inject
	private ClientThread clientThread;

	@Inject
	private ScheduledExecutorService executor;

	@Inject
	private HdPluginConfig config;

	@Inject
	private MaterialManager materialManager;

	// Temporary variables for texture loading and generating material uniforms
	private IntBuffer pixelBuffer;
	private BufferedImage scaledImage;
	private BufferedImage vanillaImage;

	private ScheduledFuture<?> debounce;

	public void startUp() {
		assert vanillaTexturesAvailable();
		vanillaImage = new BufferedImage(128, 128, BufferedImage.TYPE_INT_ARGB);

		TEXTURE_PATH.watch((path, first) -> {
			if (first) return;
			log.debug("Texture changed: {}", path);

			// Mark texture layers that need to be reloaded
			String filename = path.getFilename();
			if (!filename.isEmpty())
				for (var layer : materialManager.textureLayers)
					if (filename.equals(layer.material.getTextureName()))
						layer.needsUpload = true;

			// Debounce texture loading in case the same file change is triggered multiple times
			if (debounce == null || debounce.cancel(false) || debounce.isDone())
				debounce = executor.schedule(() -> clientThread.invoke(materialManager::uploadTextures), 100, TimeUnit.MILLISECONDS);
		});
	}

	public void shutDown() {
		pixelBuffer = null;
		scaledImage = null;
		vanillaImage = null;
	}

	public boolean vanillaTexturesAvailable() {
		var textureProvider = client.getTextureProvider();
		if (textureProvider == null)
			return false;

		Texture[] vanillaTextures = textureProvider.getTextures();
		if (vanillaTextures == null || vanillaTextures.length == 0)
			return false;

		// Ensure all textures are available
		for (int i = 0; i < vanillaTextures.length; i++) {
			var texture = vanillaTextures[i];
			if (texture != null) {
				int[] pixels = textureProvider.load(i);
				if (pixels == null)
					return false;
			}
		}

		return true;
	}

	@Nullable
	public BufferedImage loadTexture(@Nullable String filename, int fallbackVanillaIndex) {
		if (filename != null) {
			var image = loadTexture(filename);
			if (image != null)
				return image;
			if (fallbackVanillaIndex == -1) {
				log.warn("Missing texture: '{}'", filename);
				return null;
			}
		}

		if (fallbackVanillaIndex == -1)
			return null;

		var textureProvider = client.getTextureProvider();
		Texture[] vanillaTextures = textureProvider.getTextures();
		var texture = vanillaTextures[fallbackVanillaIndex];
		if (texture == null) {
			log.warn("Missing vanilla texture index {}", fallbackVanillaIndex);
			return null;
		}

		int[] pixels = textureProvider.load(fallbackVanillaIndex);
		if (pixels == null) {
			log.warn("No pixels for vanilla texture index {}", fallbackVanillaIndex);
			return null;
		}

		if (pixels.length != 128 * 128) {
			log.warn("Unknown dimensions for vanilla texture at index {} ({} pixels)", fallbackVanillaIndex, pixels.length);
			return null;
		}

		for (int j = 0; j < pixels.length; j++) {
			int rgb = pixels[j];
			// Black is considered transparent in vanilla, with anything else being fully opaque
			int alpha = rgb == 0 ? 0 : 0xFF;
			vanillaImage.setRGB(j % 128, j / 128, alpha << 24 | rgb & 0xFFFFFF);
		}

		return vanillaImage;
	}

	@Nullable
	public BufferedImage loadTexture(String filename) {
		for (String ext : SUPPORTED_IMAGE_EXTENSIONS) {
			ResourcePath path = TEXTURE_PATH.resolve(filename + "." + ext);
			try {
				return path.loadImage();
			} catch (Exception ex) {
				log.trace("Unable to load texture: {}", path, ex);
			}
		}

		return null;
	}

	public void uploadTexture(int target, int textureLayer, int[] textureSize, BufferedImage image) {
		assert client.isClientThread() : "Not thread safe";

		// Allocate resources for storing temporary image data
		int numPixels = product(textureSize);
		if (pixelBuffer == null || pixelBuffer.capacity() < numPixels)
			pixelBuffer = BufferUtils.createIntBuffer(numPixels);
		if (scaledImage == null || scaledImage.getWidth() != textureSize[0] || scaledImage.getHeight() != textureSize[1])
			scaledImage = new BufferedImage(textureSize[0], textureSize[1], BufferedImage.TYPE_INT_ARGB);

		// TODO: scale and transform on the GPU for better performance (would save 400+ ms)
		AffineTransform t = new AffineTransform();
		if (image != vanillaImage) {
			// Flip non-vanilla textures horizontally to match vanilla UV orientation
			t.translate(textureSize[1], 0);
			t.scale(-1, 1);
		}
		t.scale((double) textureSize[0] / image.getWidth(), (double) textureSize[1] / image.getHeight());
		AffineTransformOp scaleOp = new AffineTransformOp(t, AffineTransformOp.TYPE_BICUBIC);
		scaleOp.filter(image, scaledImage);

		int[] pixels = ((DataBufferInt) scaledImage.getRaster().getDataBuffer()).getData();
		pixelBuffer.put(pixels).flip();

		// Go from TYPE_4BYTE_ABGR in the BufferedImage to RGBA
		glTexSubImage3D(
			target, 0, 0, 0,
			textureLayer, textureSize[0], textureSize[1], 1,
			GL_BGRA, GL_UNSIGNED_INT_8_8_8_8_REV, pixelBuffer
		);
	}

	public void setAnisotropicFilteringLevel() {
		int level = config.anisotropicFilteringLevel();
		if (level == 0) {
			//level = 0 means no mipmaps and no anisotropic filtering
			glTexParameteri(GL_TEXTURE_2D_ARRAY, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
			glTexParameteri(GL_TEXTURE_2D_ARRAY, GL_TEXTURE_MAG_FILTER, GL_NEAREST);
		} else {
			// level = 1 means with mipmaps but without anisotropic filtering GL_MAX_TEXTURE_MAX_ANISOTROPY_EXT defaults to 1.0 which is off
			// level > 1 enables anisotropic filtering. It's up to the vendor what the values mean
			// Even if anisotropic filtering isn't supported, mipmaps will be enabled with any level >= 1
			// Trilinear filtering is used for HD textures as linear filtering produces noisy textures
			// that are very noticeable on terrain
			glTexParameteri(GL_TEXTURE_2D_ARRAY, GL_TEXTURE_MIN_FILTER, GL_LINEAR_MIPMAP_LINEAR);
			glTexParameteri(GL_TEXTURE_2D_ARRAY, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
		}

		if (GL.getCapabilities().GL_EXT_texture_filter_anisotropic) {
			final float maxSamples = glGetFloat(EXTTextureFilterAnisotropic.GL_MAX_TEXTURE_MAX_ANISOTROPY_EXT);
			glTexParameterf(GL_TEXTURE_2D_ARRAY, EXTTextureFilterAnisotropic.GL_TEXTURE_MAX_ANISOTROPY_EXT, clamp(level, 1, maxSamples));
		}
	}
}

package rs117.hd.scene;

import com.google.common.collect.ArrayListMultimap;
import com.google.common.collect.ListMultimap;
import java.io.IOException;
import java.util.ArrayDeque;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;
import javax.annotation.Nonnull;
import javax.inject.Inject;
import javax.inject.Singleton;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.*;
import net.runelite.api.coords.*;
import net.runelite.client.callback.ClientThread;
import rs117.hd.HdPlugin;
import rs117.hd.renderer.zone.SceneManager;
import rs117.hd.scene.areas.Area;
import rs117.hd.scene.ground_materials.GroundMaterial;
import rs117.hd.scene.tile_overrides.TileOverride;
import rs117.hd.utils.FileWatcher;
import rs117.hd.utils.Props;
import rs117.hd.utils.ResourcePath;

import static rs117.hd.scene.tile_overrides.TileOverride.OVERLAY_FLAG;
import static rs117.hd.utils.HDUtils.localToWorld;
import static rs117.hd.utils.ResourcePath.path;

@Slf4j
@Singleton
public class TileOverrideManager {
	private static final ResourcePath TILE_OVERRIDES_PATH = Props
		.getFile("rlhd.tile-overrides-path", () -> path(TileOverrideManager.class, "tile_overrides.json"));

	private static final ThreadLocal<int[]> OVERLAY_UNDERLAY_IDS = ThreadLocal.withInitial(() -> new int[2]);

	@Inject
	private Client client;

	@Inject
	private ClientThread clientThread;

	@Inject
	private HdPlugin plugin;

	@Inject
	private SceneManager sceneManager;

	private FileWatcher.UnregisterCallback fileWatcher;
	private boolean trackReplacements;
	private List<TileOverride> anyMatchOverrides;
	private ListMultimap<Integer, TileOverride> idMatchOverrides;

	public void startUp() {
		fileWatcher = TILE_OVERRIDES_PATH.watch((path, first) -> clientThread.invoke(() -> reload(first)));
	}

	public void shutDown() {
		if (fileWatcher != null)
			fileWatcher.unregister();
		fileWatcher = null;
		anyMatchOverrides = null;
		idMatchOverrides = null;
	}

	public void reload(boolean skipSceneReload) {
		assert client.isClientThread();

		try {
			sceneManager.getLoadingLock().lock();
			sceneManager.completeAllStreaming();

			TileOverride[] allOverrides = TILE_OVERRIDES_PATH.loadJson(plugin.getGson(), TileOverride[].class);
			if (allOverrides == null)
				throw new IOException("Empty or invalid: " + TILE_OVERRIDES_PATH);

			HashSet<String> names = new HashSet<>();
			for (var override : allOverrides) {
				if (override.name != null) {
					if (!names.add(override.name)) {
						log.warn("Removing duplicate tile override name: {}", override.name);
						override.name = null;
					}
				}
			}

			checkForReplacementLoops(allOverrides);

			List<TileOverride> anyMatch = new ArrayList<>();
			ListMultimap<Integer, TileOverride> idMatch = ArrayListMultimap.create();

			var tileOverrideVars = plugin.vars.aliases(Map.of(
				"textures", "groundTextures"
			));

			for (int i = 0; i < allOverrides.length; i++) {
				var override = allOverrides[i];
				try {
					override.index = i;
					override.normalize(allOverrides, tileOverrideVars);
				} catch (Exception ex) {
					log.warn("Skipping invalid tile override '{}':", override.name, ex);
					continue;
				}

				if (override.area == Area.NONE)
					continue;

				override.replacement = trackReplacements ? override : override.resolveConstantReplacements();
				if (override.ids != null) {
					for (int id : override.ids)
						idMatch.put(id, override);
				} else {
					anyMatch.add(override);
				}
			}

			anyMatchOverrides = anyMatch;
			idMatchOverrides = idMatch;

			log.debug("Loaded {} tile overrides", allOverrides.length);
		} catch (IOException ex) {
			log.error("Failed to load tile overrides:", ex);
		} finally {
			sceneManager.getLoadingLock().unlock();
			log.trace("loadingLock unlocked - holdCount: {}", sceneManager.getLoadingLock().getHoldCount());
		}

		// Update the reference, since the underlying dirt materials may have changed
		TileOverride.NONE.groundMaterial = GroundMaterial.DIRT;

		if (!skipSceneReload) {
			plugin.renderer.clearCaches();
			plugin.renderer.reloadScene();
		}
	}

	private void checkForReplacementLoops(TileOverride[] allOverrides) {
		Map<String, TileOverride> relevantOverrides = new HashMap<>();
		for (var override : allOverrides)
			if (override.name != null && override.rawReplacements != null)
				relevantOverrides.put(override.name, override);

		Set<String> alreadyChecked = new HashSet<>();
		for (var override : relevantOverrides.values())
			checkForReplacementLoops(relevantOverrides, alreadyChecked, override);
	}

	private static void checkForReplacementLoops(
		Map<String, TileOverride> map,
		Set<String> alreadyChecked,
		TileOverride topLevelOverride
	) {
		String name = topLevelOverride.name;
		// Only check each top-level override once
		if (alreadyChecked.add(name))
			checkForReplacementLoops(map, alreadyChecked, new ArrayDeque<>(), name, topLevelOverride);
	}

	private static void checkForReplacementLoops(
		Map<String, TileOverride> map,
		Set<String> alreadyChecked,
		ArrayDeque<String> loop,
		String topLevelOverrideName,
		TileOverride overrideToCheck
	) {
		assert overrideToCheck.name != null : "There's no point in checking overrides without names, since they can't be referenced";
		loop.addLast(overrideToCheck.name);

		for (String replacementName : overrideToCheck.rawReplacements.keySet()) {
			// Check if the replacement introduces a loop
			if (topLevelOverrideName.equals(replacementName)) {
				log.warn(
					"Tile override contains replacement loop: {} -> {}",
					String.join(" -> ", loop),
					replacementName
				);
				// Remove the loop
				overrideToCheck.rawReplacements.put(replacementName, null);
				continue;
			}

			var replacement = map.get(replacementName);
			if (replacement == null)
				continue;

			// Before continuing to check for loops back to the top-level override,
			// we need to rule out any loops within the replacement override itself,
			// so we don't get stuck in a loop there
			checkForReplacementLoops(map, alreadyChecked, replacement);

			// The replacement might've already been removed to prevent a loop in the step above
			if (overrideToCheck.rawReplacements.get(replacementName) == null)
				continue;

			// Check if any further replacements result in a loop
			checkForReplacementLoops(map, alreadyChecked, loop, topLevelOverrideName, replacement);
		}

		loop.removeLast();
	}

	public void setTrackReplacements(boolean shouldTrackReplacements) {
		clientThread.invoke(() -> {
			trackReplacements = shouldTrackReplacements;
			if (plugin.isActive())
				reload(false);
		});
	}

	@Nonnull
	public TileOverride getOverride(SceneContext sceneContext, Tile tile) {
		LocalPoint lp = tile.getLocalLocation();
		var worldPos = localToWorld(sceneContext.scene, lp.getX(), lp.getY(), tile.getRenderLevel());
		return getOverride(sceneContext, tile, worldPos);
	}

	@Nonnull
	public TileOverride getOverride(SceneContext sceneContext, @Nonnull Tile tile, @Nonnull int[] worldPos, int... ids) {
		if (ids.length == 0) {
			var pos = tile.getSceneLocation();
			int x = pos.getX() + sceneContext.sceneOffset;
			int y = pos.getY() + sceneContext.sceneOffset;
			int z = tile.getRenderLevel();
			int overlayId = OVERLAY_FLAG | sceneContext.scene.getOverlayIds()[z][x][y];
			int underlayId = sceneContext.scene.getUnderlayIds()[z][x][y];
			ids = OVERLAY_UNDERLAY_IDS.get();
			ids[0] = overlayId;
			ids[1] = underlayId;
		}
		var override = getOverrideBeforeReplacements(worldPos, ids);
		if (override.isConstant())
			return override;

		var vars = sceneContext.tileOverrideVars.get();
		vars.setTile(tile);
		var replacement = override.resolveReplacements(vars);
		vars.setTile(null); // Avoid accidentally keeping the old scene in memory
		return replacement;
	}

	@Nonnull
	public TileOverride getOverrideBeforeReplacements(@Nonnull int[] worldPos, int... ids) {
		var match = TileOverride.NONE;
		int index = match.index;

		outer:
		for (int id : ids) {
			final var entries = idMatchOverrides.get(id);
			// Enhanced for allocates an iterator...
			// noinspection ForLoopReplaceableByForEach
			for (int i = 0; i < entries.size(); i++) {
				final var entry = entries.get(i);
				if (entry.area.containsPoint(worldPos)) {
					index = entry.index;
					match = entry.replacement;
					match.queriedAsOverlay = (id & OVERLAY_FLAG) != 0;
					break outer;
				}
			}
		}

		for (var entry : anyMatchOverrides) {
			if (entry.index > index)
				break;
			if (entry.area.containsPoint(worldPos)) {
				match = entry.replacement;
				break;
			}
		}

		return match;
	}
}

package rs117.hd.scene.tile_overrides;

import com.google.gson.JsonElement;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import java.util.ArrayList;
import java.util.Collections;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;
import javax.annotation.Nonnull;
import javax.annotation.Nullable;
import lombok.AllArgsConstructor;
import lombok.NoArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import rs117.hd.scene.AreaManager;
import rs117.hd.scene.areas.Area;
import rs117.hd.scene.ground_materials.GroundMaterial;
import rs117.hd.scene.water_types.WaterType;
import rs117.hd.utils.ExpressionParser;
import rs117.hd.utils.ExpressionPredicate;
import rs117.hd.utils.Props;
import rs117.hd.utils.VariableSupplier;

import static rs117.hd.utils.ExpressionParser.asExpression;
import static rs117.hd.utils.ExpressionParser.parseExpression;
import static rs117.hd.utils.MathUtils.clamp;

@Slf4j
@NoArgsConstructor
@AllArgsConstructor
public class TileOverride {
	public static final int OVERLAY_FLAG = 1 << 31;
	public static final TileOverride NONE = new TileOverride("NONE", GroundMaterial.DIRT);

	@Nullable
	public String name;
	public String description;
	@JsonAdapter(AreaManager.Adapter.class)
	public Area area = Area.NONE;
	public int[] overlayIds;
	public int[] underlayIds;
	@JsonAdapter(GroundMaterial.Adapter.class)
	public GroundMaterial groundMaterial = GroundMaterial.NONE;
	@JsonAdapter(WaterType.Adapter.class)
	public WaterType waterType = WaterType.NONE;
	public boolean blended = true;
	public boolean blendedAsOpposite;
	public boolean forced;
	public boolean depthTested;
	private int setHue = -1;
	private int shiftHue;
	private int minHue;
	private int maxHue = 63;
	private int setSaturation = -1;
	private int shiftSaturation;
	private int minSaturation;
	private int maxSaturation = 7;
	private int setLightness = -1;
	private int shiftLightness;
	private int minLightness;
	private int maxLightness = 127;
	public int uvOrientation;
	public float uvScale = 1;
	public int heightOffset;
	@SerializedName("replacements")
	public LinkedHashMap<String, JsonElement> rawReplacements;

	public transient int index;
	public transient int[] ids;
	public transient boolean queriedAsOverlay;
	public transient TileOverride replacement;
	@Nonnull
	private transient List<Map.Entry<ExpressionPredicate, TileOverride>> replacements = Collections.emptyList();

	private TileOverride(@Nullable String name, GroundMaterial groundMaterial) {
		this.name = name;
		this.groundMaterial = groundMaterial;
		this.index = Integer.MAX_VALUE; // Prioritize any-match overrides over this
	}

	@Override
	public String toString() {
		if (name != null)
			return name;
		if (description != null)
			return description;
		if (area != null)
			return area.name;
		return "Unnamed";
	}

	public boolean isConstant() {
		return replacements.isEmpty();
	}

	public void normalize(TileOverride[] allOverrides, VariableSupplier constants) {
		int numOverlays = overlayIds == null ? 0 : overlayIds.length;
		int numUnderlays = underlayIds == null ? 0 : underlayIds.length;
		int numIds = numOverlays + numUnderlays;
		if (numIds > 0) {
			ids = new int[numOverlays + numUnderlays];
			int i = 0;
			for (int j = 0; j < numOverlays; j++) {
				int id = overlayIds[j];
				ids[i++] = OVERLAY_FLAG | id;
			}
			for (int j = 0; j < numUnderlays; j++) {
				int id = underlayIds[j];
				ids[i++] = id;
			}
		}

		if (area == null) {
			log.warn("Undefined area in tile override: {}", this);
			area = Area.NONE;
		}
		if (groundMaterial == null) {
			log.warn("Undefined ground material in tile override: {}", this);
			groundMaterial = GroundMaterial.NONE;
		}
		if (waterType == null) {
			log.warn("Undefined water type in tile override: {}", this);
			waterType = WaterType.NONE;
		}

		if (forced) {
			// Replace hidden tiles with white by default
			minHue = maxHue = minSaturation = maxSaturation = 0;
			minLightness = maxLightness = 127;
		}

		if (setHue != -1)
			minHue = maxHue = setHue;
		if (setSaturation != -1)
			minSaturation = maxSaturation = setSaturation;
		if (setLightness != -1)
			minLightness = maxLightness = setLightness;

		// Convert UV scale to reciprocal, so we can multiply instead of dividing later
		uvScale = 1 / uvScale;

		if (rawReplacements != null) {
			replacements = new ArrayList<>();
			for (var entry : rawReplacements.entrySet()) {
				var name = entry.getKey();
				TileOverride replacement = null;
				if (name == null) {
					assert false : "Null is reserved for future use";
					replacement = NONE;
				} else if (name.equals(NONE.name)) {
					replacement = NONE;
				} else {
					for (var other : allOverrides) {
						if (name.equals(other.name)) {
							replacement = other;
							break;
						}
					}
					if (replacement == null) {
						replacement = NONE;
						// Technically, we could allow nulls, but it's indistinguishable from a parsing error atm
						if (Props.DEVELOPMENT)
							throw new IllegalStateException("Unknown tile override: '" + name + "'");
					}
				}

				var result = parseExpression(ExpressionParser.mergeJsonExpressions("||", entry.getValue()), constants);
				if (Props.DEVELOPMENT && result instanceof ExpressionParser.Expression) {
					var expr = (ExpressionParser.Expression) result;
					// Ensure all variables are defined
					var acceptedVariables = Set.of("h", "s", "l");
					for (var variable : expr.variables)
						if (!acceptedVariables.contains(variable))
							throw new IllegalStateException(String.format(
								"Expression '%s' contains unknown variable '%s'. Accepted variables: %s",
								expr, variable, String.join(", ", acceptedVariables)
							));
				}

				ExpressionPredicate predicate;
				boolean isConstant = result instanceof Boolean;
				if (isConstant) {
					if (!(boolean) result)
						continue; // Skip replacement conditions that are always false
					predicate = ExpressionPredicate.TRUE;
				} else {
					predicate = asExpression(result).toPredicate();
				}

				replacements.add(Map.entry(predicate, replacement));

				// Skip parsing the remaining unnecessary replacements, unless in development mode, where we want to parse all anyway
				if (isConstant && !Props.DEVELOPMENT)
					break;
			}
		}
	}

	public TileOverride resolveConstantReplacements() {
		// Check if the override always resolves to the same replacement override
		var override = this;
		// Enhanced for loop here causes the original iterator to be used without replacements
		for (int i = 0; i < override.replacements.size(); i++) {
			var entry = override.replacements.get(i);
			var predicate = entry.getKey();
			// Stop on the first non-constant predicate
			if (predicate != ExpressionPredicate.TRUE)
				break;

			override = entry.getValue();
		}

		return override;
	}

	public TileOverride resolveReplacements(VariableSupplier vars) {
		var replacement = resolveNextReplacement(vars);
		if (replacement == this)
			return replacement;
		return replacement.resolveReplacements(vars);
	}

	public TileOverride resolveNextReplacement(VariableSupplier vars) {
		for (var entry : replacements) {
			if (!entry.getKey().test(vars))
				continue;

			var replacement = entry.getValue();
			if (replacement == null)
				replacement = NONE;

			replacement.queriedAsOverlay = queriedAsOverlay;
			return replacement;
		}

		return this;
	}

	public int modifyColor(int jagexHsl) {
		int h = jagexHsl >> 10 & 0x3F;
		h += shiftHue;
		h = clamp(h, minHue, maxHue);

		int s = jagexHsl >> 7 & 7;
		s += shiftSaturation;
		s = clamp(s, minSaturation, maxSaturation);

		int l = jagexHsl & 0x7F;
		l += shiftLightness;
		l = clamp(l, minLightness, maxLightness);

		return h << 10 | s << 7 | l;
	}
}

package rs117.hd.scene.tile_overrides;

import net.runelite.api.*;
import rs117.hd.utils.HDUtils;
import rs117.hd.utils.VariableSupplier;

public class TileOverrideVariables implements VariableSupplier {
	private final String[] HSL_VARS = { "h", "s", "l" };
	private final int[] hsl = new int[3];

	private Tile tile;
	private boolean requiresHslUpdate;

	public void setTile(Tile tile) {
		if (tile == this.tile)
			return;
		this.tile = tile;
		requiresHslUpdate = true;
	}

	@Override
	public Object get(String name) {
		for (int i = 0; i < HSL_VARS.length; i++) {
			if (HSL_VARS[i].equals(name)) {
				if (requiresHslUpdate) {
					HDUtils.getSouthWesternMostTileColor(hsl, tile);
					requiresHslUpdate = false;
				}
				return hsl[i];
			}
		}

		throw new IllegalArgumentException("Undefined variable '" + name + "'");
	}
}

/*
 * Copyright (c) 2025, Hooder <ahooder@protonmail.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package rs117.hd.scene;

import java.io.IOException;
import java.util.Arrays;
import javax.inject.Inject;
import javax.inject.Singleton;
import lombok.extern.slf4j.Slf4j;
import net.runelite.client.callback.ClientThread;
import rs117.hd.HdPlugin;
import rs117.hd.opengl.uniforms.UBOWaterTypes;
import rs117.hd.renderer.zone.SceneManager;
import rs117.hd.scene.materials.Material;
import rs117.hd.scene.water_types.WaterType;
import rs117.hd.utils.FileWatcher;
import rs117.hd.utils.Props;
import rs117.hd.utils.ResourcePath;

import static rs117.hd.utils.MathUtils.*;
import static rs117.hd.utils.ResourcePath.path;

@Slf4j
@Singleton
public class WaterTypeManager {
	private static final ResourcePath WATER_TYPES_PATH = Props
		.getFile("rlhd.water-types-path", () -> path(WaterTypeManager.class, "water_types.json"));

	@Inject
	private ClientThread clientThread;

	@Inject
	private HdPlugin plugin;

	@Inject
	private MaterialManager materialManager;

	@Inject
	private TileOverrideManager tileOverrideManager;

	@Inject
	private FishingSpotReplacer fishingSpotReplacer;

	@Inject
	private SceneManager sceneManager;

	public static WaterType[] WATER_TYPES = {};

	public UBOWaterTypes uboWaterTypes;

	private WaterType[] fallbackWaterTypes = {};
	private FileWatcher.UnregisterCallback fileWatcher;

	public void startUp() {
		fileWatcher = WATER_TYPES_PATH.watch((path, first) -> clientThread.invoke(() -> {
			try {
				sceneManager.getLoadingLock().lock();
				sceneManager.completeAllStreaming();

				var rawWaterTypes = path.loadJson(plugin.getGson(), WaterType[].class);
				if (rawWaterTypes == null)
					throw new IOException("Empty or invalid: " + path);
				log.debug("Loaded {} water types", rawWaterTypes.length);

				var waterTypes = new WaterType[rawWaterTypes.length + 1];
				waterTypes[0] = WaterType.NONE;
				System.arraycopy(rawWaterTypes, 0, waterTypes, 1, rawWaterTypes.length);

				Material fallbackNormalMap = materialManager.getMaterial("WATER_NORMAL_MAP_1");
				int maxFallback = -1;
				for (int i = 0; i < waterTypes.length; i++) {
					waterTypes[i].normalize(i, fallbackNormalMap);
					if (waterTypes[i].vanillaTextureIndex > -1)
						maxFallback = max(maxFallback, waterTypes[i].vanillaTextureIndex);
				}
				if (maxFallback > -1) {
					maxFallback = min(maxFallback, Short.MAX_VALUE);
					fallbackWaterTypes = new WaterType[maxFallback + 1];
					Arrays.fill(fallbackWaterTypes, WaterType.NONE);
					for (var waterType : waterTypes) {
						int i = waterType.vanillaTextureIndex;
						if (0 <= i && i < fallbackWaterTypes.length)
							fallbackWaterTypes[i] = waterType;
					}
				} else {
					fallbackWaterTypes = new WaterType[0];
				}

				var oldWaterTypes = WATER_TYPES;
				WATER_TYPES = waterTypes;
				// Update statically accessible water types
				WaterType.WATER = get("WATER");
				WaterType.WATER_FLAT = get("WATER_FLAT");
				WaterType.SWAMP_WATER_FLAT = get("SWAMP_WATER_FLAT");
				WaterType.ICE = get("ICE");

				if (uboWaterTypes != null)
					uboWaterTypes.destroy();
				uboWaterTypes = new UBOWaterTypes(waterTypes);

				if (first)
					return;

				fishingSpotReplacer.despawnRuneLiteObjects();
				fishingSpotReplacer.update();

				boolean indicesChanged = oldWaterTypes == null || oldWaterTypes.length != waterTypes.length;
				if (!indicesChanged) {
					for (int i = 0; i < waterTypes.length; i++) {
						if (!waterTypes[i].name.equals(oldWaterTypes[i].name)) {
							indicesChanged = true;
							break;
						}
					}
				}

				if (indicesChanged) {
					// Reload everything which depends on water type indices
					tileOverrideManager.shutDown();
					tileOverrideManager.startUp();
					plugin.renderer.clearCaches();
					plugin.renderer.reloadScene();
				}
			} catch (IOException ex) {
				log.error("Failed to load water types:", ex);
			} finally {
				sceneManager.getLoadingLock().unlock();
				log.trace("loadingLock unlocked - holdCount: {}", sceneManager.getLoadingLock().getHoldCount());
			}
		}));
	}

	public void shutDown() {
		if (fileWatcher != null)
			fileWatcher.unregister();
		fileWatcher = null;

		if (uboWaterTypes != null)
			uboWaterTypes.destroy();
		uboWaterTypes = null;

		WATER_TYPES = new WaterType[0];
	}

	public void restart() {
		shutDown();
		startUp();
	}

	private WaterType get(String name) {
		for (var type : WATER_TYPES)
			if (name.equals(type.name))
				return type;
		return WaterType.NONE;
	}

	public WaterType getFallback(int vanillaTextureId) {
		if (vanillaTextureId < 0 || vanillaTextureId >= fallbackWaterTypes.length)
			return WaterType.NONE;
		return fallbackWaterTypes[vanillaTextureId];
	}
}

package rs117.hd.scene.water_types;

import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonToken;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import javax.annotation.Nullable;
import lombok.AccessLevel;
import lombok.NoArgsConstructor;
import lombok.Setter;
import lombok.extern.slf4j.Slf4j;
import rs117.hd.opengl.uniforms.UBOWaterTypes;
import rs117.hd.scene.WaterTypeManager;
import rs117.hd.scene.materials.Material;
import rs117.hd.utils.ColorUtils;
import rs117.hd.utils.GsonUtils;

import static rs117.hd.utils.ColorUtils.linearToSrgb;
import static rs117.hd.utils.ColorUtils.rgb;

@NoArgsConstructor
@GsonUtils.ExcludeDefaults
@Setter(AccessLevel.PROTECTED)
public class WaterType {
	public String name;
	public int vanillaTextureIndex = -1;
	private boolean flat = false;
	private float specularStrength = .5f;
	private float specularGloss = 500;
	private float normalStrength = .09f;
	private float baseOpacity = .5f;
	private float fresnelAmount = 1;
	@Nullable
	private Material normalMap;
	@JsonAdapter(ColorUtils.SrgbToLinearAdapter.class)
	private float[] surfaceColor = { 1, 1, 1 };
	@JsonAdapter(ColorUtils.SrgbToLinearAdapter.class)
	private float[] foamColor = rgb(176, 164, 146);
	@JsonAdapter(ColorUtils.SrgbToLinearAdapter.class)
	private float[] depthColor = rgb(0, 117, 142);
	private boolean hasFoam = true;
	private float duration = 1;
	public int fishingSpotRecolor = -1;

	public transient int index;

	public static final WaterType NONE = new WaterType("NONE");
	public static WaterType WATER;
	public static WaterType WATER_FLAT;
	public static WaterType SWAMP_WATER_FLAT;
	public static WaterType ICE;

	private WaterType(String name) {
		this.name = name;
	}

	public void normalize(int index, Material fallbackNormalMap) {
		this.index = index;
		if (name == null)
			name = "UNNAMED_" + index;
		if (normalMap == null)
			normalMap = fallbackNormalMap;
		if (surfaceColor == null)
			surfaceColor = NONE.surfaceColor;
		if (foamColor == null)
			foamColor = NONE.foamColor;
		if (depthColor == null)
			depthColor = NONE.depthColor;
	}

	@Override
	public String toString() {
		return name;
	}

	public void fillStruct(UBOWaterTypes.WaterTypeStruct struct) {
		struct.isFlat.set(flat ? 1 : 0);
		struct.specularStrength.set(specularStrength);
		struct.specularGloss.set(specularGloss);
		struct.normalStrength.set(normalStrength);
		struct.baseOpacity.set(baseOpacity);
		struct.hasFoam.set(hasFoam ? 1 : 0);
		struct.duration.set(duration);
		struct.fresnelAmount.set(fresnelAmount);
		struct.surfaceColor.set(linearToSrgb(surfaceColor));
		struct.foamColor.set(linearToSrgb(foamColor));
		struct.depthColor.set(linearToSrgb(depthColor));
		struct.normalMap.set(Material.getTextureLayer(normalMap));
	}

	@Slf4j
	public static class Adapter extends TypeAdapter<WaterType> {
		@Override
		public WaterType read(JsonReader in) throws IOException {
			if (in.peek() == JsonToken.NULL)
				return null;

			if (in.peek() == JsonToken.STRING) {
				String name = in.nextString();
				for (var match : WaterTypeManager.WATER_TYPES)
					if (name.equals(match.name))
						return match;

				log.warn("No water type exists with the name '{}' at {}", name, GsonUtils.location(in), new Throwable());
			} else {
				log.warn("Unexpected type {} at {}", in.peek(), GsonUtils.location(in), new Throwable());
			}

			return null;
		}

		@Override
		public void write(JsonWriter out, WaterType waterType) throws IOException {
			if (waterType == null) {
				out.nullValue();
			} else {
				out.value(waterType.name);
			}
		}
	}
}

/*
 * Copyright (c) 2021, Adam <Adam@sigterm.info>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package rs117.hd.utils.buffer;

import java.nio.ByteBuffer;
import java.nio.FloatBuffer;
import java.nio.IntBuffer;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.lwjgl.opengl.*;
import rs117.hd.HdPlugin;
import rs117.hd.utils.HDUtils;

import static org.lwjgl.opengl.GL33C.*;
import static rs117.hd.HdPlugin.checkGLErrors;
import static rs117.hd.utils.MathUtils.*;

@Slf4j
@RequiredArgsConstructor
public class GLBuffer
{
	public final String name;
	public final int target;
	public final int usage;

	public int id;
	public long size;

	public void initialize() {
		initialize(0);
	}

	public void initialize(long initialCapacity) {
		id = glGenBuffers();
		// Initialize both GL and CL buffers to buffers of a single byte or more,
		// to ensure that valid buffers are given to compute dispatches.
		// This is particularly important on Apple M2 Max, where an uninitialized buffer leads to a crash
		ensureCapacity(max(1, initialCapacity));
	}

	public void destroy() {
		size = 0;

		if (id != 0) {
			glDeleteBuffers(id);
			id = 0;
		}
	}

	public void ensureCapacity(long numBytes) {
		ensureCapacity(0, numBytes);
	}

	public void ensureCapacity(long byteOffset, long numBytes) {
		numBytes += byteOffset;
		if (numBytes <= size) {
			glBindBuffer(target, id);
			return;
		}

		numBytes = HDUtils.ceilPow2(numBytes);
		if (log.isDebugEnabled() && numBytes > 1e6)
			log.debug("Resizing buffer '{}'\t{}", name, String.format("%.2f MB -> %.2f MB", size / 1e6, numBytes / 1e6));

		if (byteOffset > 0) {
			// Create a new buffer and copy the old data to it
			int oldBuffer = id;
			id = glGenBuffers();
			glBindBuffer(target, id);
			glBufferData(target, numBytes, usage);

			glBindBuffer(GL_COPY_READ_BUFFER, oldBuffer);
			glCopyBufferSubData(GL_COPY_READ_BUFFER, target, 0, 0, byteOffset);
			glDeleteBuffers(oldBuffer);
		} else {
			glBindBuffer(target, id);
			glBufferData(target, numBytes, usage);
		}

		size = numBytes;

		if (log.isDebugEnabled() && HdPlugin.GL_CAPS.OpenGL43) {
			GL43C.glObjectLabel(GL43C.GL_BUFFER, id, name);
			checkGLErrors();
		}
	}

	public void upload(ByteBuffer data) {
		upload(data, 0);
	}

	public void upload(ByteBuffer data, long byteOffset) {
		long numBytes = data.remaining();
		ensureCapacity(byteOffset, numBytes);
		glBufferSubData(target, byteOffset, data);
	}

	public void upload(IntBuffer data) {
		upload(data, 0);
	}

	public void upload(IntBuffer data, long byteOffset) {
		long numBytes = 4L * data.remaining();
		ensureCapacity(byteOffset, numBytes);
		glBufferSubData(target, byteOffset, data);
	}

	public void upload(FloatBuffer data) {
		upload(data, 0);
	}

	public void upload(FloatBuffer data, long byteOffset) {
		long numBytes = 4L * data.remaining();
		ensureCapacity(byteOffset, numBytes);
		glBufferSubData(target, byteOffset, data);
	}

	public void upload(GpuIntBuffer data) {
		upload(data.getBuffer());
	}

	public void upload(GpuIntBuffer data, long byteOffset) {
		upload(data.getBuffer(), byteOffset);
	}

	public void upload(GpuFloatBuffer data) {
		upload(data.getBuffer());
	}

	public void upload(GpuFloatBuffer data, long byteOffset) {
		upload(data.getBuffer(), byteOffset);
	}
}

/*
 * Copyright (c) 2018, Adam <Adam@sigterm.info>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package rs117.hd.utils.buffer;

import java.nio.FloatBuffer;
import org.lwjgl.system.MemoryUtil;
import rs117.hd.HdPlugin;

public class GpuFloatBuffer
{
	private FloatBuffer buffer;

	public GpuFloatBuffer()
	{
		this(65536);
	}

	public GpuFloatBuffer(int initialCapacity) {
		try {
			buffer = MemoryUtil.memAllocFloat(initialCapacity);
		} catch (OutOfMemoryError oom) {
			// Force garbage collection and try again
			System.gc();
			buffer = MemoryUtil.memAllocFloat(initialCapacity);
		}
	}

	public void destroy() {
		if (buffer != null)
			MemoryUtil.memFree(buffer);
		buffer = null;
	}

	@Override
	@SuppressWarnings("deprecation")
	protected void finalize() {
		destroy();
	}

	public void put(float x, float y, float z, float w) {
		buffer.put(x).put(y).put(z).put(w);
	}

	public void put(float x, float y, float z, int w) {
		buffer.put(x).put(y).put(z).put(Float.intBitsToFloat(w));
	}

	public void put(float[] floats) {
		buffer.put(floats);
	}

	public void put(FloatBuffer buffer) {
		this.buffer.put(buffer);
	}

	public int position()
	{
		return buffer.position();
	}

	public void flip() {
		buffer.flip();
	}

	public GpuFloatBuffer clear() {
		buffer.clear();
		return this;
	}

	public int capacity() {
		return buffer.capacity();
	}

	public void ensureCapacity(int size) {
		int capacity = buffer.capacity();
		final int position = buffer.position();
		if ((capacity - position) < size) {
			do {
				capacity = (int) (capacity * HdPlugin.BUFFER_GROWTH_MULTIPLIER);
			}
			while ((capacity - position) < size);

			FloatBuffer newB = MemoryUtil.memAllocFloat(capacity);
			buffer.flip();
			newB.put(buffer);
			MemoryUtil.memFree(buffer);
			buffer = newB;
		}
	}

	public FloatBuffer getBuffer()
	{
		return buffer;
	}
}

/*
 * Copyright (c) 2018, Adam <Adam@sigterm.info>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package rs117.hd.utils.buffer;

import java.nio.IntBuffer;
import lombok.Getter;
import org.lwjgl.system.MemoryUtil;
import rs117.hd.HdPlugin;

import static rs117.hd.utils.MathUtils.*;

public class GpuIntBuffer
{
	@Getter
	private IntBuffer buffer;
	private final boolean ownsBuffer;

	public GpuIntBuffer()
	{
		this(65536);
	}

	public GpuIntBuffer(int initialCapacity) {
		try {
			buffer = MemoryUtil.memAllocInt(initialCapacity);
		} catch (OutOfMemoryError oom) {
			// Force garbage collection and try again
			System.gc();
			buffer = MemoryUtil.memAllocInt(initialCapacity);
		}
		ownsBuffer = true;
	}

	public GpuIntBuffer(IntBuffer buffer) {
		this.buffer = buffer;
		ownsBuffer = false;
	}

	public void destroy() {
		if (buffer != null && ownsBuffer)
			MemoryUtil.memFree(buffer);
		buffer = null;
	}

	@Override
	@SuppressWarnings("deprecation")
	protected void finalize() {
		destroy();
	}

	@Override
	public String toString() {
		return String.format(
			"%s@%x(pos=%d, size=%d)",
			getClass().getSimpleName(),
			hashCode(),
			buffer.position(),
			buffer.capacity()
		);
	}

	public void put(int x, int y, int z) {
		buffer.put(x).put(y).put(z);
	}

	public void put(float x, float y, float z, int w) {
		buffer
			.put(Float.floatToIntBits(x))
			.put(Float.floatToIntBits(y))
			.put(Float.floatToIntBits(z))
			.put(w);
	}

	public void put(int[] ints) {
		buffer.put(ints);
	}

	public void put(IntBuffer buffer) {
		this.buffer.put(buffer);
	}

	public void putVertex(
		int x, int y, int z, int alphaBiasHsl,
		int u, int v, int w, int materialData,
		int nx, int ny, int nz, int terrainData
	) {
		buffer.put((y & 0xFFFF) << 16 | x & 0xFFFF);
		buffer.put((u & 0xFFFF) << 16 | z & 0xFFFF);
		buffer.put((w & 0xFFFF) << 16 | v & 0xFFFF);
		buffer.put((ny & 0xFFFF) << 16 | nx & 0xFFFF);
		buffer.put(nz & 0xFFFF);
		buffer.put(alphaBiasHsl);
		buffer.put(materialData);
		buffer.put(terrainData);
	}

	public static int normShort(float f) {
		return round(clamp(f, -1, 1) * Short.MAX_VALUE);
	}

	public void putVertex(
		int x, int y, int z, int alphaBiasHsl,
		float u, float v, float w, int materialData,
		float nx, float ny, float nz, int terrainData
	) {
		buffer.put((y & 0xFFFF) << 16 | x & 0xFFFF);
		buffer.put(float16(u) << 16 | z & 0xFFFF);
		buffer.put(float16(w) << 16 | float16(v));
		// This only works with normalized normals
		buffer.put((normShort(ny) & 0xFFFF) << 16 | (normShort(nx) & 0xFFFF));
		buffer.put((normShort(nz) & 0xFFFF));
		buffer.put(alphaBiasHsl);
		buffer.put(materialData);
		buffer.put(terrainData);
	}

	public void putVertex(
		int x, int y, int z, int alphaBiasHsl,
		float u, float v, float w, int materialData,
		int nx, int ny, int nz, int terrainData
	) {
		buffer.put((y & 0xFFFF) << 16 | x & 0xFFFF);
		buffer.put(float16(u) << 16 | z & 0xFFFF);
		buffer.put(float16(w) << 16 | float16(v));
		// Unnormalized normals, assumed to be within short max
		buffer.put((ny & 0xFFFF) << 16 | nx & 0xFFFF);
		buffer.put(nz & 0xFFFF);
		buffer.put(alphaBiasHsl);
		buffer.put(materialData);
		buffer.put(terrainData);
	}

	public static void putFloatVertex(
		IntBuffer buffer,
		float x, float y, float z, int alphaBiasHsl,
		float u, float v, float w, int materialData,
		int nx, int ny, int nz, int terrainData
	) {
		buffer.put(Float.floatToRawIntBits(x));
		buffer.put(Float.floatToRawIntBits(y));
		buffer.put(Float.floatToRawIntBits(z));
		buffer.put(float16(v) << 16 | float16(u));
		buffer.put((nx & 0xFFFF) << 16 | float16(w));
		buffer.put((nz & 0xFFFF) << 16 | ny & 0xFFFF);
		buffer.put(alphaBiasHsl);
		buffer.put(materialData);
		buffer.put(terrainData);
	}

	public int position()
	{
		return buffer.position();
	}

	public void flip() {
		buffer.flip();
	}

	public GpuIntBuffer clear() {
		buffer.clear();
		return this;
	}

	public int capacity() {
		return buffer.capacity();
	}

	public GpuIntBuffer ensureCapacity(int size) {
		int capacity = buffer.capacity();
		final int position = buffer.position();
		if ((capacity - position) < size) {
			do {
				capacity = (int) (capacity * HdPlugin.BUFFER_GROWTH_MULTIPLIER);
			}
			while ((capacity - position) < size);

			IntBuffer newB = MemoryUtil.memAllocInt(capacity);
			buffer.flip();
			newB.put(buffer);
			MemoryUtil.memFree(buffer);
			buffer = newB;
		}

		return this;
	}
}

package rs117.hd.utils.buffer;

import java.nio.IntBuffer;
import rs117.hd.opengl.compute.OpenCLManager;

import static org.lwjgl.opencl.CL10.*;
import static org.lwjgl.opencl.CL10GL.clCreateFromGLBuffer;

public class SharedGLBuffer extends GLBuffer {
	public final int clUsage;

	public long clId;

	public SharedGLBuffer(String name, int target, int glUsage, int clUsage) {
		super(name, target, glUsage);
		this.clUsage = clUsage;
	}

	private void releaseCLBuffer() {
		if (clId != 0 && OpenCLManager.context != 0)
			clReleaseMemObject(clId);
		clId = 0;
	}

	@Override
	public void destroy() {
		releaseCLBuffer();
		super.destroy();
	}

	@Override
	public void ensureCapacity(long byteOffset, long numBytes) {
		super.ensureCapacity(byteOffset, numBytes);
		if (OpenCLManager.context == 0)
			return;

		releaseCLBuffer();

		// OpenCL does not allow 0-size GL buffers, it will segfault on macOS
		if (size != 0)
			clId = clCreateFromGLBuffer(OpenCLManager.context, clUsage, id, (IntBuffer) null);
	}
}

package rs117.hd.utils;

import java.util.Arrays;
import lombok.Getter;
import lombok.extern.slf4j.Slf4j;

import static rs117.hd.utils.MathUtils.*;

@Slf4j
public class Camera {
	private static final int PROJECTION_MATRIX_DIRTY = 1;
	private static final int VIEW_MATRIX_DIRTY = 1 << 1;
	private static final int VIEW_PROJ_MATRIX_DIRTY = 1 << 2;
	private static final int INV_VIEW_PROJ_MATRIX_DIRTY = 1 << 3;
	private static final int FRUSTUM_PLANES_DIRTY = 1 << 4;
	private static final int FRUSTUM_CORNERS_DIRTY = 1 << 5;

	private static final int VIEW_PROJ_CHANGED =
		VIEW_PROJ_MATRIX_DIRTY | INV_VIEW_PROJ_MATRIX_DIRTY | FRUSTUM_PLANES_DIRTY | FRUSTUM_CORNERS_DIRTY;
	private static final int PROJ_CHANGED = PROJECTION_MATRIX_DIRTY | VIEW_PROJ_CHANGED;
	private static final int VIEW_CHANGED = VIEW_MATRIX_DIRTY | VIEW_PROJ_CHANGED;

	private float[] viewMatrix;
	private float[] projectionMatrix;
	private float[] viewProjMatrix;
	private float[] invViewProjMatrix;

	private final float[][] frustumCorners = new float[8][3];
	private final float[][] frustumPlanes = new float[6][4];
	private final float[] position = new float[3];
	private final float[] orientation = new float[2];
	private final int[] fixedOrientation = new int[2]; // TODO: Is there a reliable way to go from orientation -> Fixed?

	private int dirtyFlags = PROJ_CHANGED | VIEW_CHANGED;

	@Getter
	private int viewportWidth = 10;
	@Getter
	private int viewportHeight = 10;

	@Getter
	private float zoom = 1.0f;
	@Getter
	private float nearPlane = 0.5f;
	@Getter
	private float farPlane = 0.0f;
	private boolean isOrthographic = false;

	public boolean isDirty() {
		return dirtyFlags != 0;
	}

	public boolean isProjDirty() { return (dirtyFlags & PROJECTION_MATRIX_DIRTY) != 0; }

	public boolean isViewDirty() { return (dirtyFlags & VIEW_MATRIX_DIRTY) != 0; }

	public boolean getIsOrthographic() {return isOrthographic; }

	public Camera setOrthographic(boolean newOrthographic) {
		if (isOrthographic != newOrthographic) {
			isOrthographic = newOrthographic;
			dirtyFlags |= PROJ_CHANGED;
		}
		return this;
	}

	public Camera setViewportWidth(int newViewportWidth) {
		if (viewportWidth != newViewportWidth) {
			viewportWidth = newViewportWidth;
			dirtyFlags |= PROJ_CHANGED;
		}
		return this;
	}

	public Camera setViewportHeight(int newViewportHeight) {
		if (viewportHeight != newViewportHeight) {
			viewportHeight = newViewportHeight;
			dirtyFlags |= PROJ_CHANGED;
		}
		return this;
	}

	public float getAspectRatio() {
		return viewportHeight == 0 ? 1 : (float) viewportWidth / viewportHeight;
	}

	public Camera setNearPlane(float newNearPlane) {
		if (nearPlane != newNearPlane) {
			nearPlane = newNearPlane;
			dirtyFlags |= PROJ_CHANGED;
		}
		return this;
	}

	public Camera setFarPlane(float newFarPlane) {
		if (farPlane != newFarPlane) {
			farPlane = newFarPlane;
			dirtyFlags |= PROJ_CHANGED;
		}
		return this;
	}

	public Camera setZoom(float newZoom) {
		if (zoom != newZoom) {
			zoom = newZoom;
			dirtyFlags |= PROJ_CHANGED;
		}
		return this;
	}

	public float getPositionX() {
		return position[0];
	}

	public void translateX(float xOffset) {
		setPositionX(getPositionX() + xOffset);
	}

	public Camera setPositionX(float x) {
		if (position[0] != x) {
			position[0] = x;
			dirtyFlags |= VIEW_CHANGED;
		}
		return this;
	}

	public float getPositionY() {
		return position[1];
	}

	public void translateY(float yOffset) {
		setPositionY(getPositionY() + yOffset);
	}

	public Camera setPositionY(float y) {
		if (position[1] != y) {
			position[1] = y;
			dirtyFlags |= VIEW_CHANGED;
		}
		return this;
	}

	public float getPositionZ() {
		return position[2];
	}

	public void translateZ(float zOffset) {
		setPositionZ(getPositionZ() + zOffset);
	}

	public Camera setPositionZ(float z) {
		if (position[2] != z) {
			position[2] = z;
			dirtyFlags |= VIEW_CHANGED;
		}
		return this;
	}

	public Camera setPosition(float[] newPosition) {
		if (position[0] != newPosition[0] || position[1] != newPosition[1] || position[2] != newPosition[2]) {
			position[0] = newPosition[0];
			position[1] = newPosition[1];
			position[2] = newPosition[2];
			dirtyFlags |= VIEW_CHANGED;
		}
		return this;
	}

	public float[] getPosition() {
		return copy(position);
	}

	public float distanceTo(float[] point) {
		return distanceTo(point[0], point[1], point[2]);
	}

	public float distanceTo(float x, float y, float z) {
		return sqrt(squaredDistanceTo(x, y, z));
	}

	public float squaredDistanceTo(float x, float y, float z) {
		float dx = position[0] - x;
		float dy = position[1] - y;
		float dz = position[2] - z;
		return dx * dx + dy * dy + dz * dz;
	}

	public Camera translate(float[] translation) {
		if (translation[0] != 0.0f || translation[1] != 0.0f || translation[2] != 0.0f) {
			position[0] += translation[0];
			position[1] += translation[1];
			position[2] += translation[2];
			dirtyFlags |= VIEW_CHANGED;
		}
		return this;
	}

	public Camera setYaw(float yaw) {
		if (orientation[0] != yaw) {
			orientation[0] = yaw;
			dirtyFlags |= VIEW_CHANGED;
		}
		return this;
	}

	public Camera setFixedYaw(int yaw) {
		fixedOrientation[0] = yaw;
		return this;
	}

	public float getYaw() {
		return orientation[0];
	}

	public int getFixedYaw() { return fixedOrientation[0]; }

	public Camera setPitch(float pitch) {
		if (orientation[1] != pitch) {
			orientation[1] = pitch;
			dirtyFlags |= VIEW_CHANGED;
		}
		return this;
	}

	public Camera setFixedPitch(int pitch) {
		fixedOrientation[1] = pitch;
		return this;
	}

	public float getPitch() {
		return orientation[1];
	}

	public int getFixedPitch() { return fixedOrientation[1]; }

	public float[] getOrientation() {
		return Arrays.copyOf(orientation, 2);
	}

	public int[] getFixedOrientation() {
		return Arrays.copyOf(fixedOrientation, 2);
	}

	public Camera setOrientation(float[] newOrientation) {
		if (orientation[0] != newOrientation[0] || orientation[1] != newOrientation[1]) {
			orientation[0] = newOrientation[0];
			orientation[1] = newOrientation[1];
			dirtyFlags |= VIEW_CHANGED;
		}
		return this;
	}

	public float[] getForwardDirection(float[] out) {
		calculateViewMatrix();
		out[0] = -viewMatrix[2];
		out[1] = -viewMatrix[6];
		out[2] = -viewMatrix[10];
		return out;
	}

	public float[] getForwardDirection() { return getForwardDirection(new float[3]); }

	private void calculateViewMatrix() {
		if ((dirtyFlags & VIEW_MATRIX_DIRTY) != 0) {
			viewMatrix = Mat4.identity();
			Mat4.mul(viewMatrix, Mat4.rotateX(orientation[1]));
			Mat4.mul(viewMatrix, Mat4.rotateY(orientation[0]));
			if (position[0] != 0 || position[1] != 0 || position[2] != 0) {
				Mat4.mul(
					viewMatrix,
					Mat4.translate(
						-position[0],
						-position[1],
						-position[2]
					)
				);
			}
			dirtyFlags &= ~VIEW_MATRIX_DIRTY;
		}
	}

	public float[] getViewMatrix(float[] out) {
		calculateViewMatrix();
		copyTo(out, viewMatrix);
		return out;
	}

	public float[] getViewMatrix() {
		return getViewMatrix(new float[16]);
	}

	public float[] transformPoint(float[] out, float[] point) {
		calculateViewMatrix();
		Mat4.transformVecAffine(out, viewMatrix, point);
		return out;
	}

	public float[] transformPoint(float[] point) {
		return transformPoint(new float[3], point);
	}

	private void calculateProjectionMatrix() {
		if ((dirtyFlags & PROJECTION_MATRIX_DIRTY) != 0) {
			final float zoomedViewportWidth = (viewportWidth / zoom);
			final float zoomedViewportHeight = (viewportHeight / zoom);
			if (isOrthographic) {
				projectionMatrix = Mat4.orthographic(zoomedViewportWidth, zoomedViewportHeight, nearPlane);
			} else {
				if (farPlane > 0.0f) {
					projectionMatrix = Mat4.perspective(zoomedViewportWidth, zoomedViewportHeight, nearPlane, farPlane);
				} else {
					projectionMatrix = Mat4.perspective(zoomedViewportWidth, zoomedViewportHeight, nearPlane);
				}
			}
			dirtyFlags &= ~PROJECTION_MATRIX_DIRTY;
		}
	}

	public float[] getProjectionMatrix(float[] out) {
		calculateProjectionMatrix();
		copyTo(out, projectionMatrix);
		return out;
	}

	public float[] getProjectionMatrix() {
		return getProjectionMatrix(new float[16]);
	}

	private void calculateViewProjMatrix() {
		if ((dirtyFlags & VIEW_PROJ_MATRIX_DIRTY) != 0) {
			calculateViewMatrix();
			calculateProjectionMatrix();

			viewProjMatrix = Mat4.identity();
			Mat4.mul(viewProjMatrix, projectionMatrix);
			Mat4.mul(viewProjMatrix, viewMatrix);

			dirtyFlags &= ~VIEW_PROJ_MATRIX_DIRTY;
		}
	}

	public float[] getViewProjMatrix(float[] out) {
		calculateViewProjMatrix();
		copyTo(out, viewProjMatrix);
		return out;
	}

	public float[] getViewProjMatrix() {
		return getViewProjMatrix(new float[16]);
	}

	private void calculateInvViewProjMatrix() {
		if ((dirtyFlags & INV_VIEW_PROJ_MATRIX_DIRTY) != 0) {
			calculateViewProjMatrix();
			try {
				invViewProjMatrix = Mat4.inverse(viewProjMatrix);
			} catch (Exception ex) {
				log.warn("Encountered an exception whilst solving inverse of camera ViewProj: ", ex);
			}
			dirtyFlags &= ~INV_VIEW_PROJ_MATRIX_DIRTY;
		}
	}

	public float[] getInvViewProjMatrix(float[] out) {
		calculateInvViewProjMatrix();
		copyTo(out, invViewProjMatrix);
		return out;
	}

	public float[] getInvViewProjMatrix() {
		calculateInvViewProjMatrix();
		return Arrays.copyOf(invViewProjMatrix, invViewProjMatrix.length);
	}

	private void calculateFrustumPlanes() {
		if ((dirtyFlags & FRUSTUM_PLANES_DIRTY) == 0)
			return;
		calculateViewProjMatrix();
		Mat4.extractPlanes(viewProjMatrix, frustumPlanes);
		dirtyFlags &= ~FRUSTUM_PLANES_DIRTY;
	}

	public float[][] getFrustumPlanes(float[][] out) {
		calculateFrustumPlanes();
		for (int i = 0; i < out.length; i++)
			copyTo(out[i], frustumPlanes[i]);
		return out;
	}

	public float[][] getFrustumPlanes() {
		return getFrustumPlanes(new float[6][4]);
	}

	private void calculateFrustumCorners() {
		if ((dirtyFlags & FRUSTUM_CORNERS_DIRTY) == 0)
			return;
		calculateInvViewProjMatrix();
		Mat4.extractFrustumCorners(invViewProjMatrix, frustumCorners);
		dirtyFlags &= ~FRUSTUM_CORNERS_DIRTY;
	}

	public float[][] getFrustumCorners(float[][] out) {
		calculateFrustumCorners();
		for (int i = 0; i < out.length; i++)
			copyTo(out[i], frustumCorners[i]);
		return frustumCorners;
	}

	public float[][] getFrustumCorners() {
		return getFrustumCorners(new float[8][3]);
	}

	public boolean intersectsAABB(int minX, int minY, int minZ, int maxX, int maxY, int maxZ) {
		calculateFrustumPlanes();
		return HDUtils.isAABBIntersectingFrustum(minX, minY, minZ, maxX, maxY, maxZ, frustumPlanes);
	}

	public boolean intersectsSphere(float x, float y, float z, float radius) {
		calculateFrustumPlanes();
		return HDUtils.isSphereIntersectingFrustum(x, y, z, radius, frustumPlanes, frustumPlanes.length);
	}
}

/*
 * Color utility functions
 * Written in 2023 by Hooder <ahooder@protonmail.com>
 * To the extent possible under law, the author(s) have dedicated all copyright and related and neighboring rights
 * to this software to the public domain worldwide. This software is distributed without any warranty.
 * You should have received a copy of the CC0 Public Domain Dedication along with this software.
 * If not, see <http://creativecommons.org/publicdomain/zero/1.0/>.
 */
package rs117.hd.utils;

import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonToken;
import com.google.gson.stream.JsonWriter;
import java.awt.Color;
import java.io.IOException;
import java.util.Arrays;
import lombok.extern.slf4j.Slf4j;
import rs117.hd.utils.GsonUtils.DelegateFloatAdapter;

import static rs117.hd.utils.MathUtils.*;

public class ColorUtils {
	private static final float EPS = 1e-4f;

	/**
	 * Row-major transformation matrices for conversion between RGB and XYZ color spaces.
	 * Fairman, H. S., Brill, M. H., & Hemmendinger, H. (1997).
	 * How the CIE 1931 color-matching functions were derived from Wright-Guild data.
	 * Color Research & Application, 22(1), 1123.
	 * doi:10.1002/(sici)1520-6378(199702)22:1<11::aid-col4>3.0.co;2-7
	 */
	private static final float[] RGB_TO_XYZ_MATRIX = {
		.49f, .31f, .2f,
		.1769f, .8124f, .0107f,
		.0f,    .0099f, .9901f
	};
	private static final float[] XYZ_TO_RGB_MATRIX = {
		2.36449f,    -.896553f,  -.467937f,
		-.514935f,   1.42633f,    .0886025f,
		 .00514883f, -.0142619f, 1.00911f
	};

	/**
	 * Approximate UV coordinates in the CIE 1960 UCS color space from a color temperature specified in degrees Kelvin.
	 * @param kelvin temperature in degrees Kelvin. Valid from 1000 to 15000.
	 * @see <a href="https://doi.org/10.1002/col.5080100109">
	 *     Krystek, M. (1985). An algorithm to calculate correlated colour temperature.
	 *     Color Research & Application, 10(1), 3840. doi:10.1002/col.5080100109
	 * </a>
	 * @return UV coordinates in the UCS color space
	 */
	public static float[] colorTemperatureToLinearRgb(double kelvin) {
		// UV coordinates in CIE 1960 UCS color space
		double[] uv = new double[] {
			(0.860117757 + 1.54118254e-4 * kelvin + 1.28641212e-7 * kelvin * kelvin)
				/ (1 + 8.42420235e-4 * kelvin + 7.08145163e-7 * kelvin * kelvin),
			(0.317398726 + 4.22806245e-5 * kelvin + 4.20481691e-8 * kelvin * kelvin)
				/ (1 - 2.89741816e-5 * kelvin + 1.61456053e-7 * kelvin * kelvin)
		};

		// xy coordinates in CIES 1931 xyY space
		double divisor = 2 * uv[0] - 8 * uv[1] + 4;
		double[] xy = new double[] { 3 * uv[0] / divisor,  2 * uv[1] / divisor };

		// CIE XYZ space
		float Y = 1;
		float[] XYZ = { (float) (xy[0] * Y / xy[1]), Y, (float) ((1 - xy[0] - xy[1]) * Y / xy[1]) };

		return XYZtoRGB(XYZ);
	}

	/**
	 * Transform from CIE 1931 XYZ color space to linear RGB.
	 * @param XYZ coordinates
	 * @return linear RGB coordinates
	 */
	public static float[] XYZtoRGB(float[] XYZ) {
		float[] RGB = new float[3];
		mat3MulVec3(RGB, XYZ_TO_RGB_MATRIX, XYZ);
		return RGB;
	}

	/**
	 * Transform from linear RGB to CIE 1931 XYZ color space.
	 * @param RGB linear RGB color coordinates
	 * @return XYZ color coordinates
	 */
	public static float[] RGBtoXYZ(float[] RGB) {
		float[] XYZ = new float[3];
		mat3MulVec3(XYZ, RGB_TO_XYZ_MATRIX, RGB);
		return XYZ;
	}

	private static void mat3MulVec3(float[] out, float[] m, float[] v) {
		out[0] = m[0] * v[0] + m[1] * v[1] + m[2] * v[2];
		out[1] = m[3] * v[0] + m[4] * v[1] + m[5] * v[2];
		out[2] = m[6] * v[0] + m[7] * v[1] + m[8] * v[2];
	}

	// Conversion functions to and from sRGB and linear color space.
	// The implementation is based on the sRGB EOTF given in the Khronos Data Format Specification.
	// Source: https://web.archive.org/web/20220808015852/https://registry.khronos.org/DataFormat/specs/1.3/dataformat.1.3.pdf
	// Page number 130 (146 in the PDF)
	public static float linearToSrgb(float c) {
		return c <= 0.0031308f ?
			c * 12.92f :
			1.055f * pow(c, 1 / 2.4f) - 0.055f;
	}

	public static float srgbToLinear(float c) {
		return c <= 0.04045f ?
			c / 12.92f :
			pow((c + 0.055f) / 1.055f, 2.4f);
	}

	public static float[] linearToSrgb(float... c) {
		float[] result = new float[c.length];
		for (int i = 0; i < c.length; i++)
			result[i] = linearToSrgb(c[i]);
		return result;
	}

	public static float[] srgbToLinear(float... c) {
		float[] result = new float[c.length];
		for (int i = 0; i < c.length; i++)
			result[i] = srgbToLinear(c[i]);
		return result;
	}

	/**
	 * Convert sRGB in the range 0-1 to HSL in the range 0-1.
	 *
	 * @param srgb float[3]
	 * @return hsl float[3]
	 * @link <a href="https://web.archive.org/web/20230619214343/https://en.wikipedia.org/wiki/HSL_and_HSV#Color_conversion_formulae">Wikipedia: HSL and HSV</a>
	 */
	public static float[] srgbToHsl(float[] srgb) {
		float V = max(srgb);
		float X_min = min(srgb);
		float C = V - X_min;

		float H = 0;
		if (C > 0) {
			if (V == srgb[0]) {
				H = mod((srgb[1] - srgb[2]) / C, 6);
			} else if (V == srgb[1]) {
				H = (srgb[2] - srgb[0]) / C + 2;
			} else {
				H = (srgb[0] - srgb[1]) / C + 4;
			}
			assert H >= 0 && H <= 6;
		}

		float L = (V + X_min) / 2;
		float divisor = 1 - abs(2 * L - 1);
		float S_L = abs(divisor) < EPS ? 0 : C / divisor;
		return new float[] { H / 6, S_L, L };
	}

	/**
	 * Convert HSL in the range 0-1 to sRGB in the range 0-1.
	 *
	 * @param hsl float[3]
	 * @return srgb float[3]
	 * @link <a href="https://web.archive.org/web/20230619214343/https://en.wikipedia.org/wiki/HSL_and_HSV#Color_conversion_formulae">Wikipedia: HSL and HSV</a>
	 */
	public static float[] hslToSrgb(float[] hsl) {
		float C = hsl[1] * (1 - abs(2 * hsl[2] - 1));
		float H_prime = fract(hsl[0]) * 6;
		float m = hsl[2] - C / 2;

		float r = clamp(abs(H_prime - 3) - 1, 0, 1) * C + m;
		float g = clamp(2 - abs(H_prime - 2), 0, 1) * C + m;
		float b = clamp(2 - abs(H_prime - 4), 0, 1) * C + m;
		return new float[] { r, g, b };
	}

	/**
	 * Convert HSL in the range 0-1 to HSV in the range 0-1.
	 *
	 * @param hsl float[3]
	 * @return hsv float[3]
	 */
	public static float[] hslToHsv(float[] hsl) {
		float v = hsl[2] + hsl[1] * min(hsl[2], 1 - hsl[2]);
		return vec(hsl[0], abs(v) < EPS ? 0 : 2 * (1 - hsl[2] / v), v);
	}

	/**
	 * Convert HSV in the range 0-1 to HSL in the range 0-1.
	 *
	 * @param hsv float[3]
	 * @return hsl float[3]
	 */
	public static float[] hsvToHsl(float[] hsv) {
		float l = hsv[2] * (1 - hsv[1] / 2);
		float divisor = min(l, 1 - l);
		return vec(hsv[0], abs(divisor) < EPS ? 0 : (hsv[2] - l) / divisor, l);
	}

	/**
	 * Convert sRGB in the range 0-1 from sRGB to HSV (also known as HSB) in the range 0-1.
	 *
	 * @param srgb float[3]
	 * @return hsv float[3]
	 * @link <a href="https://web.archive.org/web/20230619214343/https://en.wikipedia.org/wiki/HSL_and_HSV#Color_conversion_formulae">Wikipedia: HSL and HSV</a>
	 */
	public static float[] srgbToHsv(float[] srgb) {
		return hslToHsv(srgbToHsl(srgb));
	}

	/**
	 * Convert HSV (also known as HSB) in the range 0-1 to sRGB in the range 0-1.
	 *
	 * @param hsv float[3]
	 * @return srgb float[3]
	 * @link <a href="https://web.archive.org/web/20230619214343/https://en.wikipedia.org/wiki/HSL_and_HSV#Color_conversion_formulae">Wikipedia: HSL and HSV</a>
	 */
	public static float[] hsvToSrgb(float[] hsv) {
		return hslToSrgb(hsvToHsl(hsv));
	}

	// Convenience functions for converting different formats into linear RGB, sRGB or packed HSL

	/**
	 * Convert red, green and blue in the range 0-255 from sRGB to linear RGB in the range 0-1.
	 *
	 * @param r red color
	 * @param g green color
	 * @param b blue color
	 * @return float[3] linear rgb values from 0-1
	 */
	public static float[] rgb(float r, float g, float b) {
		return srgbToLinear(srgb(r, g, b));
	}

	/**
	 * Convert hex color from sRGB to linear RGB in the range 0-1.
	 *
	 * @param hex RGB hex color
	 * @return float[3] linear rgb values from 0-1
	 */
	public static float[] rgb(String hex) {
		return srgbToLinear(srgb(hex));
	}

	/**
	 * Convert sRGB color packed as an int to linear RGB in the range 0-1.
	 *
	 * @param srgb packed sRGB
	 * @return float[3] linear rgb values from 0-1
	 */
	public static float[] rgb(int srgb) {
		return srgbToLinear(srgb(srgb));
	}

	/**
	 * Convert red, green and blue in the range 0-255 from sRGB to sRGB in the range 0-1.
	 *
	 * @param r red color
	 * @param g green color
	 * @param b blue color
	 * @return float[3] non-linear sRGB values from 0-1
	 */
	public static float[] srgb(float r, float g, float b) {
		return new float[] { r / 255f, g / 255f, b / 255f };
	}

	/**
	 * Convert hex color from sRGB to sRGB in the range 0-1.
	 *
	 * @param hex RGB hex color
	 * @return float[3] non-linear sRGB values from 0-1
	 */
	public static float[] srgb(String hex) {
		Color color = Color.decode(hex);
		return srgb(color.getRed(), color.getGreen(), color.getBlue());
	}

	/**
	 * Convert sRGB color packed as an int to sRGB in the range 0-1.
	 *
	 * @param srgb packed sRGB
	 * @return float[3] non-linear sRGB values from 0-1
	 */
	public static float[] srgb(int srgb) {
		return new float[] {
			(srgb >> 16 & 0xFF) / (float) 0xFF,
			(srgb >> 8 & 0xFF) / (float) 0xFF,
			(srgb & 0xFF) / (float) 0xFF,
		};
	}

	public static float[] srgb(Color c) {
		return srgb(c.getRed(), c.getGreen(), c.getBlue());
	}

	/**
	 * Convert alpha and sRGB color packed in an int as ARGB to sRGB in the range 0-1.
	 *
	 * @param alphaSrgb packed sRGB with a preceding alpha channel
	 * @return float[4] non-linear sRGB and alpha in the range 0-1
	 */
	public static float[] srgba(int alphaSrgb) {
		return new float[] {
			(alphaSrgb >> 16 & 0xFF) / (float) 0xFF,
			(alphaSrgb >> 8 & 0xFF) / (float) 0xFF,
			(alphaSrgb & 0xFF) / (float) 0xFF,
			(alphaSrgb >> 24 & 0xFF) / (float) 0xFF
		};
	}

	/**
	 * Convert red, green and blue in the range 0-255 from sRGB to packed HSL.
	 *
	 * @param r red color
	 * @param g green color
	 * @param b blue color
	 * @return int packed HSL
	 */
	public static int hsl(float r, float g, float b) {
		return srgbToPackedHsl(srgb(r, g, b));
	}

	/**
	 * Convert hex color from sRGB to packed HSL.
	 *
	 * @param rgbHex RGB hex color
	 * @return int packed HSL
	 */
	public static int hsl(String rgbHex) {
		return srgbToPackedHsl(srgb(rgbHex));
	}

	/**
	 * Convert sRGB color packed as an int to packed HSL.
	 *
	 * @param packedSrgb RGB hex color
	 * @return int packed HSL
	 */
	public static int hsl(int packedSrgb) {
		return srgbToPackedHsl(srgb(packedSrgb));
	}

	// Integer packing and unpacking functions

	public static int packRawRgb(int... rgb) {
		return rgb[0] << 16 | rgb[1] << 8 | rgb[2];
	}

	public static int packSrgb(float[] srgb) {
		return packRawRgb(ivec(multiply(saturate(srgb), 0xFF)));
	}

	public static int packRawHsl(int... hsl) {
		return hsl[0] << 10 | hsl[1] << 7 | hsl[2];
	}

	public static void unpackRawHsl(int[] out, int hsl) {
		// 6-bit hue | 3-bit saturation | 7-bit lightness
		out[0] = hsl >>> 10 & 0x3F;
		out[1] = hsl >>> 7 & 0x7;
		out[2] = hsl & 0x7F;
	}

	public static int[] unpackRawHsl(int hsl) {
		int[] out = new int[3];
		unpackRawHsl(out, hsl);
		return out;
	}

	public static int packHsl(float... hsl) {
		int H = clamp(round((hsl[0] - .0078125f) * (0x3F + 1)), 0, 0x3F);
		int S = clamp(round((hsl[1] - .0625f) * (0x7 + 1)), 0, 0x7);
		int L = clamp(round(hsl[2] * (0x7F + 1)), 0, 0x7F);
		return packRawHsl(H, S, L);
	}

	public static float[] unpackHsl(int hsl) {
		// 6-bit hue | 3-bit saturation | 7-bit lightness
		float H = (hsl >>> 10 & 0x3F) / (0x3F + 1f) + .0078125f;
		float S = (hsl >>> 7 & 0x7) / (0x7 + 1f) + .0625f;
		float L = (hsl & 0x7F) / (0x7F + 1f);
		return new float[] { H, S, L };
	}

	public static int srgbToPackedHsl(float[] srgb) {
		return packHsl(srgbToHsl(srgb));
	}

	public static float[] packedHslToSrgb(int packedHsl) {
		return hslToSrgb(unpackHsl(packedHsl));
	}

	public static int linearRgbToPackedHsl(float[] linearRgb) {
		return srgbToPackedHsl(linearToSrgb(linearRgb));
	}

	public static float[] packedHslToLinearRgb(int hsl) {
		return srgbToLinear(packedHslToSrgb(hsl));
	}

	public static String srgbToHex(float... srgb) {
		return String.format("#%06x", packSrgb(srgb));
	}

	public static String rgbToHex(float... linearRgb) {
		return srgbToHex(linearToSrgb(linearRgb));
	}

	@Slf4j
	public static class SrgbAdapter extends DelegateFloatAdapter<float[]> {
		@Override
		public float[] read(JsonReader in) throws IOException {
			var token = in.peek();
			if (token == JsonToken.STRING)
				return ColorUtils.srgb(in.nextString());

			if (token != JsonToken.BEGIN_ARRAY)
				throw new IOException("Expected hex color code or array of color channels at " + GsonUtils.location(in));

			in.beginArray();
			float[] rgba = { 0, 0, 0, 1 };
			int i = 0;
			while (in.hasNext() && in.peek() != JsonToken.END_ARRAY) {
				if (in.peek() == JsonToken.NULL) {
					log.warn("Skipping null value in color array at {}", GsonUtils.location(in));
					in.skipValue();
					continue;
				}

				if (in.peek() == JsonToken.NUMBER) {
					if (i > 3) {
						log.warn("Skipping extra elements in color array at {}", GsonUtils.location(in));
						break;
					}

					rgba[i++] = FLOAT_ADAPTER.read(in);
					continue;
				}

				throw new IOException("Unexpected type in color array: " + in.peek() + " at " + GsonUtils.location(in));
			}
			in.endArray();

			if (i < 3)
				throw new IOException("Too few elements in color array: " + i + " at " + GsonUtils.location(in));

			for (int j = 0; j < i; j++)
				rgba[j] /= 255;

			if (i == 4)
				return rgba;

			return slice(rgba, 0, 3);
		}

		@Override
		public void write(JsonWriter out, float[] src) throws IOException {
			if (src == null || src.length == 0) {
				out.nullValue();
				return;
			}

			if (src.length != 3 && src.length != 4)
				throw new IOException("The number of components must be 3 or 4 in a color array. Got " + Arrays.toString(src));

			float[] rgba = { 0, 0, 0, 1 };
			int[] rgbaInt = { 0, 0, 0, 255 };
			for (int i = 0; i < src.length; i++)
				rgba[i] = src[i] * 255;

			// See if it can fit in a hex color code
			boolean canfit = true;
			for (int i = 0; i < src.length; i++) {
				float f = rgba[i];
				rgbaInt[i] = round(f);
				if (abs(f - rgbaInt[i]) > EPS) {
					canfit = false;
					break;
				}
			}

			if (canfit) {
				// Serialize it as a hex color code
				if (src.length == 3) {
					out.value(String.format("#%02x%02x%02x", rgbaInt[0], rgbaInt[1], rgbaInt[2]));
				} else {
					out.value(String.format("#%02x%02x%02x%02x", rgbaInt[0], rgbaInt[1], rgbaInt[2], rgbaInt[3]));
				}
			} else {
				out.beginArray();
				for (int i = 0; i < src.length; i++)
					FLOAT_ADAPTER.write(out, rgba[i]);
				out.endArray();
			}
		}
	}

	@Slf4j
	public static class SrgbToLinearAdapter extends SrgbAdapter {
		@Override
		public float[] read(JsonReader in) throws IOException {
			return srgbToLinear(super.read(in));
		}

		@Override
		public void write(JsonWriter out, float[] src) throws IOException {
			super.write(out, linearToSrgb(src));
		}
	}

	public static class LinearAdapter extends DelegateFloatAdapter<Float> {
		@Override
		public Float read(JsonReader in) throws IOException {
			var value = FLOAT_ADAPTER.read(in);
			return value == null ? null : srgbToLinear(value);
		}

		@Override
		public void write(JsonWriter out, Float value) throws IOException {
			FLOAT_ADAPTER.write(out, value == null ? null : linearToSrgb(value));
		}
	}
}

package rs117.hd.utils;

import java.nio.IntBuffer;
import java.util.Arrays;
import lombok.extern.slf4j.Slf4j;
import org.lwjgl.system.MemoryStack;
import rs117.hd.opengl.shader.ShaderProgram;
import rs117.hd.utils.buffer.GpuIntBuffer;

import static org.lwjgl.opengl.GL33C.*;
import static org.lwjgl.opengl.GL40.glDrawArraysIndirect;
import static org.lwjgl.opengl.GL40.glDrawElementsIndirect;
import static org.lwjgl.opengl.GL43.glMultiDrawArraysIndirect;

@Slf4j
public class CommandBuffer {
	public static boolean SKIP_DEPTH_MASKING;

	private static final int GL_MULTI_DRAW_ARRAYS_TYPE = 0;
	private static final int GL_MULTI_DRAW_ARRAYS_INDIRECT_TYPE = 1;
	private static final int GL_DRAW_ARRAYS_TYPE = 2;
	private static final int GL_DRAW_ARRAYS_INDIRECT_TYPE = 3;
	private static final int GL_DRAW_ELEMENTS_TYPE = 4;
	private static final int GL_DRAW_ELEMENTS_INDIRECT_TYPE = 5;
	private static final int GL_DRAW_CALL_TYPE_COUNT = 6;

	private static final int GL_BIND_VERTEX_ARRAY_TYPE = 6;
	private static final int GL_BIND_ELEMENTS_ARRAY_TYPE = 7;
	private static final int GL_BIND_INDIRECT_ARRAY_TYPE = 8;
	private static final int GL_DEPTH_MASK_TYPE = 9;
	private static final int GL_COLOR_MASK_TYPE = 10;
	private static final int GL_USE_PROGRAM = 11;

	private static final int GL_TOGGLE_TYPE = 12; // Combined glEnable & glDisable

	private static final long INT_MASK = 0xFFFF_FFFFL;
	private static final int DRAW_MODE_MASK = 0xF;

	private final Object[] objects = new Object[10];
	private int objectCount = 0;

	private final RenderState renderState;

	private long[] cmd = new long[1 << 20]; // ~1 million calls
	private int writeHead = 0;

	public CommandBuffer(RenderState renderState) {
		this.renderState = renderState;
	}

	private void ensureCapacity(int numLongs) {
		if (writeHead + numLongs >= cmd.length)
			cmd = Arrays.copyOf(cmd, cmd.length * 2);
	}

	public void BindVertexArray(int vao) {
		ensureCapacity(1);
		cmd[writeHead++] = GL_BIND_VERTEX_ARRAY_TYPE & 0xFF | (long) vao << 8;
	}

	public void BindElementsArray(int ebo) {
		ensureCapacity(1);
		cmd[writeHead++] = GL_BIND_ELEMENTS_ARRAY_TYPE & 0xFF | (long) ebo << 8;
	}

	public void BindIndirectArray(int ido) {
		ensureCapacity(1);
		cmd[writeHead++] = GL_BIND_INDIRECT_ARRAY_TYPE & 0xFF | (long) ido << 8;
	}

	public void SetShader(ShaderProgram program) {
		ensureCapacity(1);
		int objectIdx = writeObject(program);
		cmd[writeHead++] = GL_USE_PROGRAM & 0xFF | (long) objectIdx << 8;
	}

	public void DepthMask(boolean writeDepth) {
		ensureCapacity(1);
		cmd[writeHead++] = GL_DEPTH_MASK_TYPE & 0xFF | (writeDepth ? 1 : 0) << 8;
	}

	public void ColorMask(boolean writeRed, boolean writeGreen, boolean writeBlue, boolean writeAlpha) {
		ensureCapacity(1);
		cmd[writeHead++] =
			GL_COLOR_MASK_TYPE & 0xFF |
			(writeRed ? 1 : 0) << 8 |
			(writeGreen ? 1 : 0) << 9 |
			(writeBlue ? 1 : 0) << 10 |
			(writeAlpha ? 1 : 0) << 11;
	}

	public void MultiDrawArrays(int mode, int[] offsets, int[] counts) {
		assert offsets.length == counts.length;
		assert (mode & DRAW_MODE_MASK) == mode;
		if (offsets.length == 0)
			return;

		ensureCapacity(1 + offsets.length);
		cmd[writeHead++] = GL_MULTI_DRAW_ARRAYS_TYPE & 0xFF | mode << 8 | (long) offsets.length << 32;
		for (int i = 0; i < offsets.length; i++)
			cmd[writeHead++] = (long) offsets[i] << 32 | counts[i] & INT_MASK;
	}

	public void DrawElements(int mode, int vertexCount, long offset) {
		ensureCapacity(2);
		cmd[writeHead++] = GL_DRAW_ELEMENTS_TYPE & 0xFF | (mode & DRAW_MODE_MASK) << 8 | (long) vertexCount << 32;
		cmd[writeHead++] = offset;
	}

	public void DrawArrays(int mode, int offset, int vertexCount) {
		ensureCapacity(2);
		cmd[writeHead++] = GL_DRAW_ARRAYS_TYPE & 0xFF | (mode & DRAW_MODE_MASK) << 8;
		cmd[writeHead++] = (long) offset << 32 | vertexCount & INT_MASK;
	}

	public void DrawArraysIndirect(int mode, int vertexOffset, int vertexCount, GpuIntBuffer indirectBuffer) {
		ensureCapacity(2);

		// https://registry.khronos.org/OpenGL-Refpages/gl4/html/glDrawArraysIndirect.xhtml
		int indirectOffset = indirectBuffer.position();
		indirectBuffer.ensureCapacity(4).getBuffer()
			.put(vertexCount)  // count
			.put(1)         // primCount
			.put(vertexOffset) // first
			.put(0);        // baseInstance (reserved 4.1 prior)

		cmd[writeHead++] = GL_DRAW_ARRAYS_INDIRECT_TYPE & 0xFF | (long) mode << 8;
		cmd[writeHead++] = (long) indirectOffset * Integer.BYTES;
	}

	public void DrawElementsIndirect(int mode, int indexCount, int indexOffset, GpuIntBuffer indirectBuffer) {
		ensureCapacity(2);

		// https://registry.khronos.org/OpenGL-Refpages/gl4/html/glDrawElementsIndirect.xhtml
		int indirectOffset = indirectBuffer.position();
		indirectBuffer.ensureCapacity(5).getBuffer()
			.put(indexCount)    // count
			.put(1)          // instanceCount
			.put(indexOffset)   // firstIndex
			.put(0)          // baseVertex
			.put(0);         // baseInstance

		cmd[writeHead++] = GL_DRAW_ELEMENTS_INDIRECT_TYPE & 0xFF | (long) mode << 8;
		cmd[writeHead++] = (long) indirectOffset * Integer.BYTES;
	}

	public void MultiDrawArraysIndirect(int mode, int[] vertexOffsets, int[] vertexCounts, GpuIntBuffer indirectBuffer) {
		assert vertexOffsets.length == vertexCounts.length;
		assert (mode & DRAW_MODE_MASK) == mode;
		int drawCount = vertexOffsets.length;
		if (drawCount == 0)
			return;

		ensureCapacity(2);
		int indirectOffset = indirectBuffer.position();

		// https://registry.khronos.org/OpenGL-Refpages/gl4/html/glMultiDrawArraysIndirect.xhtml
		indirectBuffer.ensureCapacity(drawCount * 4);
		IntBuffer buf = indirectBuffer.getBuffer();
		for (int i = 0; i < drawCount; i++) {
			buf.put(vertexCounts[i]);  // count
			buf.put(1);              // instanceCount
			buf.put(vertexOffsets[i]); // first
			buf.put(0);             // baseInstance
		}

		cmd[writeHead++] = GL_MULTI_DRAW_ARRAYS_INDIRECT_TYPE & 0xFF | (long) mode << 8 | (long) drawCount << 32;
		cmd[writeHead++] = (long) indirectOffset * Integer.BYTES;
	}


	public void Enable(int capability) {
		Toggle(capability, true);
	}

	public void Disable(int capability) {
		Toggle(capability, false);
	}

	public void Toggle(int capability, boolean enabled) {
		ensureCapacity(2);
		cmd[writeHead++] = GL_TOGGLE_TYPE;
		cmd[writeHead++] = (enabled ? 1L : 0) << 32 | capability & INT_MASK;
	}

	public void execute() {
		try (MemoryStack stack = MemoryStack.stackPush()) {
			IntBuffer offsets = null, counts = null;
			int readHead = 0;
			while (readHead < writeHead) {
				// Casting from long to int keeps the lower 32 bits
				long data = cmd[readHead++];
				int type = (int) data & 0xFF;
				if (type < GL_DRAW_CALL_TYPE_COUNT)
					renderState.apply();

				switch (type) {
					case GL_DEPTH_MASK_TYPE: {
						int state = (int) (data >> 8) & 1;
						if (SKIP_DEPTH_MASKING)
							continue;
						renderState.depthMask.set(state == 1);
						break;
					}
					case GL_COLOR_MASK_TYPE: {
						boolean red = ((data >> 8) & 1) == 1;
						boolean green = ((data >> 9) & 1) == 1;
						boolean blue = ((data >> 10) & 1) == 1;
						boolean alpha = ((data >> 11) & 1) == 1;
						renderState.colorMask.set(red, green, blue, alpha);
						break;
					}
					case GL_BIND_VERTEX_ARRAY_TYPE: {
						renderState.vao.set((int) (data >> 8));
						break;
					}
					case GL_BIND_ELEMENTS_ARRAY_TYPE: {
						renderState.ebo.set((int) (data >> 8));
						break;
					}
					case GL_BIND_INDIRECT_ARRAY_TYPE: {
						renderState.ido.set((int) (data >> 8));
						break;
					}
					case GL_USE_PROGRAM: {
						int objectIdx = (int) (data >> 8);
						renderState.program.set((ShaderProgram) objects[objectIdx]);
						break;
					}
					case GL_TOGGLE_TYPE: {
						long packed = cmd[readHead++];
						int capability = (int) (packed & INT_MASK);
						if ((packed >> 32) != 0) {
							renderState.enable.set(capability);
						} else {
							renderState.disable.set(capability);
						}
						break;
					}
					case GL_DRAW_ARRAYS_TYPE: {
						long packed = cmd[readHead++];
						int mode = (int) data >> 8;
						int offset = (int) (packed >> 32);
						int count = (int) packed;

						glDrawArrays(mode, offset, count);
						break;
					}
					case GL_DRAW_ELEMENTS_TYPE: {
						int mode = (int) data >> 8;
						int vertexCount = (int) (data >> 32);
						long byteOffset = cmd[readHead++];

						glDrawElements(mode, vertexCount, GL_UNSIGNED_INT, byteOffset);
						break;
					}
					case GL_MULTI_DRAW_ARRAYS_TYPE: {
						int mode = (int) data >> 8;
						int drawCount = (int) (data >> 32);

						if (offsets == null || offsets.capacity() < drawCount) {
							offsets = stack.callocInt(drawCount);
							counts = stack.callocInt(drawCount);
						}

						for (int i = 0; i < drawCount; i++) {
							long packed = cmd[readHead++];
							offsets.put((int) (packed >> 32));
							counts.put((int) packed);
						}

						offsets.flip();
						counts.flip();

						glMultiDrawArrays(mode, offsets, counts);

						offsets.clear();
						counts.clear();
						break;
					}
					case GL_DRAW_ARRAYS_INDIRECT_TYPE: {
						int mode = (int) data >> 8;
						glDrawArraysIndirect(mode, cmd[readHead++]);
						break;
					}
					case GL_DRAW_ELEMENTS_INDIRECT_TYPE: {
						int mode = (int) data >> 8;
						glDrawElementsIndirect(mode, GL_UNSIGNED_INT, cmd[readHead++]);
						break;
					}
					case GL_MULTI_DRAW_ARRAYS_INDIRECT_TYPE: {
						int mode = (int) data >> 8;
						int drawCount = (int) (data >> 32);
						long offset = cmd[readHead++];
						glMultiDrawArraysIndirect(mode, offset, drawCount, 0);
						break;
					}
					default:
						throw new IllegalArgumentException("Encountered an unknown DrawCall type: " + type);
				}
			}
			renderState.apply();
		}
	}

	private int writeObject(Object obj) {
		for (int i = 0; i < objectCount; i++) {
			if (objects[i] == obj) {
				return i;
			}
		}
		objects[objectCount] = obj;
		return objectCount++;
	}

	public void reset() {
		writeHead = 0;
		renderState.reset();
	}
}

package rs117.hd.utils;

import java.awt.event.KeyEvent;
import javax.inject.Inject;
import lombok.Getter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.events.*;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.config.Keybind;
import net.runelite.client.eventbus.EventBus;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.input.KeyListener;
import net.runelite.client.input.KeyManager;
import rs117.hd.HdPlugin;
import rs117.hd.overlays.FrameTimerOverlay;
import rs117.hd.overlays.LightGizmoOverlay;
import rs117.hd.overlays.ShadowMapOverlay;
import rs117.hd.overlays.TileInfoOverlay;
import rs117.hd.overlays.TiledLightingOverlay;
import rs117.hd.scene.AreaManager;
import rs117.hd.scene.areas.AABB;
import rs117.hd.scene.areas.Area;

import static java.awt.event.InputEvent.CTRL_DOWN_MASK;
import static java.awt.event.InputEvent.SHIFT_DOWN_MASK;

@Slf4j
public class DeveloperTools implements KeyListener {
	// This could be part of the config if we had developer mode config sections
	private static final Keybind KEY_TOGGLE_TILE_INFO = new Keybind(KeyEvent.VK_F3, CTRL_DOWN_MASK);
	private static final Keybind KEY_TOGGLE_FRAME_TIMINGS = new Keybind(KeyEvent.VK_F4, CTRL_DOWN_MASK);
	private static final Keybind KEY_RECORD_TIMINGS_SNAPSHOT = new Keybind(KeyEvent.VK_F4, CTRL_DOWN_MASK | SHIFT_DOWN_MASK);
	private static final Keybind KEY_TOGGLE_SHADOW_MAP_OVERLAY = new Keybind(KeyEvent.VK_F5, CTRL_DOWN_MASK);
	private static final Keybind KEY_TOGGLE_LIGHT_GIZMO_OVERLAY = new Keybind(KeyEvent.VK_F6, CTRL_DOWN_MASK);
	private static final Keybind KEY_TOGGLE_TILED_LIGHTING_OVERLAY = new Keybind(KeyEvent.VK_F7, CTRL_DOWN_MASK);
	private static final Keybind KEY_TOGGLE_FREEZE_FRAME = new Keybind(KeyEvent.VK_ESCAPE, SHIFT_DOWN_MASK);
	private static final Keybind KEY_TOGGLE_ORTHOGRAPHIC = new Keybind(KeyEvent.VK_TAB, SHIFT_DOWN_MASK);
	private static final Keybind KEY_TOGGLE_HIDE_UI = new Keybind(KeyEvent.VK_H, CTRL_DOWN_MASK);
	private static final Keybind KEY_RELOAD_SCENE = new Keybind(KeyEvent.VK_R, CTRL_DOWN_MASK);

	@Inject
	private ClientThread clientThread;

	@Inject
	private EventBus eventBus;

	@Inject
	private KeyManager keyManager;

	@Inject
	private HdPlugin plugin;

	@Inject
	private TileInfoOverlay tileInfoOverlay;

	@Inject
	private FrameTimerOverlay frameTimerOverlay;

	@Inject
	private FrameTimingsRecorder frameTimingsRecorder;

	@Inject
	private ShadowMapOverlay shadowMapOverlay;

	@Inject
	private LightGizmoOverlay lightGizmoOverlay;

	@Inject
	private TiledLightingOverlay tiledLightingOverlay;

	private boolean keyBindingsEnabled;
	private boolean tileInfoOverlayEnabled;
	@Getter
	private boolean frameTimingsOverlayEnabled;
	private boolean shadowMapOverlayEnabled;
	private boolean lightGizmoOverlayEnabled;
	@Getter
	private boolean hideUiEnabled;
	private boolean tiledLightingOverlayEnabled;

	public void activate() {
		// Listen for commands
		eventBus.register(this);

		// Don't do anything else unless we're in the development environment
		if (!Props.DEVELOPMENT)
			return;

		// Enable 117 HD's keybindings by default during development
		keyBindingsEnabled = true;
		keyManager.registerKeyListener(this);

		clientThread.invokeLater(() -> {
			tileInfoOverlay.setActive(tileInfoOverlayEnabled);
			frameTimerOverlay.setActive(frameTimingsOverlayEnabled);
			shadowMapOverlay.setActive(shadowMapOverlayEnabled);
			lightGizmoOverlay.setActive(lightGizmoOverlayEnabled);
			tiledLightingOverlay.setActive(tiledLightingOverlayEnabled);
		});

		// Check for any out of bounds areas
		for (Area area : AreaManager.AREAS) {
			if (area == Area.ALL || area == Area.NONE)
				continue;

			for (AABB aabb : area.aabbs) {
				if (aabb.minX < -128 || aabb.minY < 1000 || aabb.maxX > 5000 || aabb.maxY > 13000) {
					throw new IllegalArgumentException(
						"Your definition for the area " + area + " has an incorrect AABB: " + aabb);
				}
			}
		}
	}

	public void deactivate() {
		eventBus.unregister(this);
		keyManager.unregisterKeyListener(this);
		tileInfoOverlay.setActive(false);
		frameTimerOverlay.setActive(false);
		shadowMapOverlay.setActive(false);
		lightGizmoOverlay.setActive(false);
		tiledLightingOverlay.setActive(false);
		hideUiEnabled = false;
	}

	@Subscribe
	public void onCommandExecuted(CommandExecuted commandExecuted) {
		if (!commandExecuted.getCommand().equalsIgnoreCase("117hd"))
			return;

		String[] args = commandExecuted.getArguments();
		if (args.length < 1)
			return;

		String action = args[0].toLowerCase();
		switch (action) {
			case "tileinfo":
				tileInfoOverlay.setActive(tileInfoOverlayEnabled = !tileInfoOverlayEnabled);
				break;
			case "timers":
			case "timings":
				frameTimerOverlay.setActive(frameTimingsOverlayEnabled = !frameTimingsOverlayEnabled);
				break;
			case "snapshot":
				frameTimingsRecorder.recordSnapshot();
				break;
			case "shadowmap":
				shadowMapOverlay.setActive(shadowMapOverlayEnabled = !shadowMapOverlayEnabled);
				break;
			case "lights":
				lightGizmoOverlay.setActive(lightGizmoOverlayEnabled = !lightGizmoOverlayEnabled);
				break;
			case "tiledlights":
			case "tiledlighting":
				tiledLightingOverlay.setActive(tiledLightingOverlayEnabled = !tiledLightingOverlayEnabled);
				break;
			case "keybinds":
			case "keybindings":
				keyBindingsEnabled = !keyBindingsEnabled;
				if (keyBindingsEnabled) {
					keyManager.registerKeyListener(this);
				} else {
					keyManager.unregisterKeyListener(this);
				}
				break;
			case "reload":
				plugin.renderer.reloadScene();
				break;
		}
	}

	@Override
	public void keyPressed(KeyEvent e) {
		if (KEY_TOGGLE_TILE_INFO.matches(e)) {
			tileInfoOverlay.setActive(tileInfoOverlayEnabled = !tileInfoOverlayEnabled);
		} else if (KEY_TOGGLE_FRAME_TIMINGS.matches(e)) {
			frameTimerOverlay.setActive(frameTimingsOverlayEnabled = !frameTimingsOverlayEnabled);
		} else if (KEY_RECORD_TIMINGS_SNAPSHOT.matches(e)) {
			frameTimingsRecorder.recordSnapshot();
		} else if (KEY_TOGGLE_SHADOW_MAP_OVERLAY.matches(e)) {
			shadowMapOverlay.setActive(shadowMapOverlayEnabled = !shadowMapOverlayEnabled);
		} else if (KEY_TOGGLE_LIGHT_GIZMO_OVERLAY.matches(e)) {
			lightGizmoOverlay.setActive(lightGizmoOverlayEnabled = !lightGizmoOverlayEnabled);
		} else if (KEY_TOGGLE_TILED_LIGHTING_OVERLAY.matches(e)) {
			tiledLightingOverlay.setActive(tiledLightingOverlayEnabled = !tiledLightingOverlayEnabled);
		} else if (KEY_TOGGLE_FREEZE_FRAME.matches(e)) {
			plugin.toggleFreezeFrame();
		} else if (KEY_TOGGLE_ORTHOGRAPHIC.matches(e)) {
			plugin.orthographicProjection = !plugin.orthographicProjection;
		} else if (KEY_TOGGLE_HIDE_UI.matches(e)) {
			hideUiEnabled = !hideUiEnabled;
		} else if (KEY_RELOAD_SCENE.matches(e)) {
			plugin.renderer.reloadScene();
		} else {
			return;
		}
		e.consume();
	}

	@Override
	public void keyReleased(KeyEvent e) {}

	@Override
	public void keyTyped(KeyEvent e) {}
}

package rs117.hd.utils;

import com.google.gson.JsonElement;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonToken;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.HashSet;
import java.util.function.Function;
import javax.annotation.Nullable;
import lombok.AllArgsConstructor;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;

import static rs117.hd.utils.MathUtils.*;

public class ExpressionParser {
	public static ExpressionPredicate parsePredicate(String expression) {
		return parsePredicate(expression, null);
	}

	public static ExpressionPredicate parsePredicate(String expression, @Nullable VariableSupplier constants) {
		return asExpression(parseExpression(expression, constants)).toPredicate();
	}

	public static Function<VariableSupplier, Object> parseFunction(String expression) {
		return parseFunction(expression, null);
	}

	public static Function<VariableSupplier, Object> parseFunction(String expression, @Nullable VariableSupplier constants) {
		return asFunction(parseExpression(expression, constants));
	}

	public static Object parseExpression(String expression) {
		return parseExpression(expression, null);
	}

	public static Object parseExpression(String expression, @Nullable VariableSupplier constants) {
		return asExpression(parseExpression(expression, 0, expression.length())).simplify(constants);
	}

	public static String mergeJsonExpressions(String delimiter, JsonElement jsonExpressions) {
		if (jsonExpressions == null || jsonExpressions.isJsonNull())
			throw new IllegalArgumentException("Missing expression, got null");

		if (jsonExpressions.isJsonPrimitive())
			return jsonExpressions.getAsJsonPrimitive().getAsString();

		if (jsonExpressions.isJsonArray()) {
			var array = jsonExpressions.getAsJsonArray();
			var sb = new StringBuilder();
			String prefix = "";
			for (var primitive : array) {
				sb.append(prefix).append('(').append(primitive.getAsString()).append(')');
				prefix = delimiter;
			}
			return sb.toString();
		}

		throw new IllegalArgumentException("Unsupported expression format: '" + jsonExpressions + "'");
	}

	public static String mergeExpressions(String delimiter, Iterable<String> expressions) {
		var sb = new StringBuilder();
		String prefix = "";
		for (var expression : expressions) {
			sb.append(prefix).append('(').append(expression).append(')');
			prefix = delimiter;
		}
		return sb.toString();
	}

	public static Expression asExpression(Object object) {
		if (object instanceof Expression)
			return (Expression) object;
		return new Expression(object);
	}

	public static Function<VariableSupplier, Object> asFunction(Object object) {
		if (object instanceof Expression)
			return ((Expression) object).toFunction();
		if (object instanceof String)
			return vars -> vars.get((String) object);
		return vars -> object;
	}

	public static class SerializableExpressionPredicate implements ExpressionPredicate {
		public final Expression expression;
		public final ExpressionPredicate predicate;

		public SerializableExpressionPredicate(Expression expression) {
			this.expression = expression;
			predicate = expression.toPredicate();
		}

		@Override
		public String toString() {
			return expression.toString();
		}

		@Override
		public boolean test(VariableSupplier variableSupplier) {
			return predicate.test(variableSupplier);
		}
	}

	public static class PredicateAdapter extends TypeAdapter<SerializableExpressionPredicate> {
		private static final Adapter ADAPTER = new Adapter();

		@Override
		public SerializableExpressionPredicate read(JsonReader in) throws IOException {
			return new SerializableExpressionPredicate(ADAPTER.read(in));
		}

		@Override
		public void write(JsonWriter out, SerializableExpressionPredicate predicate) throws IOException {
			ADAPTER.write(out, predicate.expression);
		}
	}

	@Slf4j
	public static class Adapter extends TypeAdapter<Expression> {
		@Override
		public Expression read(JsonReader in) throws IOException {
			if (in.peek() == JsonToken.NULL)
				return null;

			if (in.peek() == JsonToken.BOOLEAN)
				return asExpression(in.nextBoolean());

			if (in.peek() == JsonToken.STRING)
				return asExpression(parseExpression(in.nextString()));

			if (in.peek() == JsonToken.BEGIN_ARRAY) {
				in.beginArray();
				var cases = new ArrayList<String>();
				while (in.peek() == JsonToken.STRING)
					cases.add(in.nextString());
				in.endArray();
				return asExpression(parseExpression(mergeExpressions("||", cases)));
			}

			log.warn("Unexpected type {} at {}", in.peek(), GsonUtils.location(in), new Throwable());
			return null;
		}

		@Override
		public void write(JsonWriter out, Expression expression) throws IOException {
			if (expression == null) {
				out.nullValue();
			} else {
				// Disable HTML escaping to keep operators intact
				out.setHtmlSafe(false);
				out.value(expression.toString());
			}
		}
	}

	public static class SyntaxError extends IllegalArgumentException {
		SyntaxError(ParserContext ctx, String message) {
			super(
				"Error at index " + ctx.index + " while parsing " +
				(ctx.op == null ? "expression" : "operator '" + ctx.op + "' in") +
				" '" + ctx.expr + "': " + message
			);
		}
	}

	@RequiredArgsConstructor
	private enum Operator {
		MOD("%", 6, 2),
		MUL("*", 6, 2),
		DIV("/", 6, 2),
		ADD("+", 5, 2),
		SUB("-", 5, 2),
		LEQUAL("<=", 4, 2),
		LESS("<", 4, 2),
		GEQUAL(">=", 4, 2),
		GREATER(">", 4, 2),
		NOTEQUAL("!=", 3, 2),
		NOT("!", 7, 1),
		EQUAL("==", 3, 2),
		AND("&&", 2, 2),
		OR("||", 1, 2),
		TERNARY("?", 0, 3);

		static final Operator[] OPERATORS = values();

		final String symbol;
		final int precedence;
		final int numOperands;

		@Override
		public String toString() {
			return symbol;
		}
	}

	@AllArgsConstructor
	public static class ParserContext {
		final String expr;
		int index, endIndex;
		char c;
		Operator op;
		Object[] operands = new Object[2];
		boolean isInParentheses;
		boolean isTopLevelParser;
		int minPrecedence;

		ParserContext(String expression, int startIndex, int endIndex, boolean isTopLevelParser, int minPrecedence) {
			this.expr = expression;
			this.index = startIndex;
			this.endIndex = endIndex;
			this.isTopLevelParser = isTopLevelParser;
			this.minPrecedence = minPrecedence;
		}

		boolean done() {
			return index >= endIndex;
		}

		void read() {
			if (done())
				throw new SyntaxError(this, "Unexpected end of expression");
			c = expr.charAt(index);
		}

		void readSafe() {
			c = done() ? 0 : expr.charAt(index);
		}

		char readEnd() {
			return expr.charAt(endIndex - 1);
		}

		void readIgnoringWhitespace() {
			skipWhitespace();
			read();
		}

		void advance() {
			index++;
			readSafe();
		}

		void advanceIgnoringWhitespace() {
			advance();
			skipWhitespace();
		}

		void trim() {
			int remaining;
			do {
				remaining = remaining();
				trimWhitespace();
				trimParentheses();
			} while (remaining != remaining());
		}

		void trimParentheses() {
			isInParentheses = false;
			while (!done() && c == '(' && readEnd() == ')') {
				int i = index + 1;
				int levels = 1;
				while (i < endIndex - 2) {
					char c = expr.charAt(i++);
					if (c == '(') {
						levels++;
					} else if (c == ')') {
						levels--;
						if (levels == 0)
							return;
					}
				}

				advance();
				endIndex--;
				isInParentheses = true;
			}
		}

		void skipWhitespace() {
			while (!done()) {
				readSafe();
				if (c != ' ')
					break;
				index++;
			}
		}

		void trimWhitespaceEnd() {
			while (!done()) {
				var end = expr.charAt(endIndex - 1);
				if (end != ' ')
					break;
				endIndex--;
			}
		}

		void trimWhitespace() {
			skipWhitespace();
			trimWhitespaceEnd();
		}

		int remaining() {
			return endIndex - index;
		}

		int indexOfClosingParenthesis(int openingParenthesis) {
			int i = openingParenthesis;
			int levels = 1;
			while (++i < endIndex) {
				char c = expr.charAt(i);
				if (c == '(') {
					levels++;
				} else if (c == ')' && --levels == 0) {
					return i;
				}
			}
			throw new SyntaxError(this, "Missing closing parenthesis");
		}

		Object parseOperand() {
			if (!done()) {
				skipWhitespace();

				// Always parse parentheses in a new parsing context
				if (c == '(') {
					int end = indexOfClosingParenthesis(index);
					var exprInParentheses = parseExpression(expr, index, end + 1);
					index = end + 1;
					readSafe();
					return exprInParentheses;
				}

				// Parse all following operations with higher precedence than the current, and return that as the operand
				if (op != null) {
					var higherPrecedenceParser = new ParserContext(expr, index, endIndex, false, op.precedence + 1);
					var expr = parseExpression(higherPrecedenceParser);
					if (expr != null) {
						index = higherPrecedenceParser.index;
						endIndex = higherPrecedenceParser.endIndex;
						return expr;
					}
				}

				if (c == '+' || c == '-' || c == '.' || ('0' <= c && c <= '9'))
					return readNumber();
				if ('A' <= c && c <= 'Z' || 'a' <= c && c <= 'z' || c == '_')
					return readIdentifier();
			}
			return null;
		}

		float readNumber() {
			// Parse sign
			int sign = 1;
			while (!done()) {
				if (c == '-') {
					sign *= -1;
				} else if (c != '+') {
					break;
				}
				advanceIgnoringWhitespace();
			}

			// Parse whole part
			int wholePart = 0;
			int numDigits = 0;
			while (!done()) {
				if ('0' <= c && c <= '9') {
					wholePart *= 10;
					wholePart += c - '0';
					numDigits++;
					advance();
				} else {
					break;
				}
			}

			// Parse fractional part
			if (!done() && c == '.') {
				advance();
				int fractionalPart = 0;
				int divisor = 1;
				while (!done()) {
					if ('0' <= c && c <= '9') {
						fractionalPart += c - '0';
						divisor *= 10;
						advance();
					} else {
						break;
					}
				}

				if (divisor > 1)
					return sign * ((float) fractionalPart / divisor + wholePart);
			}

			if (numDigits == 0)
				throw new SyntaxError(this, "Expected a number");

			return sign * wholePart;
		}

		Object readIdentifier() {
			StringBuilder sb = new StringBuilder();
			while (!done()) {
				if ('A' <= c && c <= 'Z' ||
					'a' <= c && c <= 'z' ||
					'0' <= c && c <= '9' ||
					c == '_' ||
					c == '.' && sb.length() > 0
				) {
					sb.append(c);
					advance();
				} else {
					break;
				}
			}

			assert sb.length() > 0;
			var str = sb.toString();

			// Convert string constants
			if (str.equalsIgnoreCase("true"))
				return true;
			if (str.equalsIgnoreCase("false"))
				return false;

			return str;
		}

		Expression createExpression(Object leftOperand, Operator op, Object rightOperand) {
			if (!(leftOperand instanceof Expression)) {
				// Simple combination of left & right operands
				return new Expression(op, leftOperand, rightOperand, null, false);
			}

			Expression left = (Expression) leftOperand;
			// If the left expression is in parentheses, or has the same or higher operator precedence,
			// it should be evaluated first, so use it as the left operand in a new expression
			if (left.isInParentheses || left.op.precedence >= op.precedence)
				return new Expression(op, left, rightOperand, null, false);

			// The new operator should act on the left expression's right-most operand,
			// and should replace the right-most operand with the resulting expression
			left.right = createExpression(left.right, op, rightOperand);
			return left;
		}
	}

	public static class Expression {
		Operator op;
		Object left, right;
		Object ternary;
		boolean isInParentheses;
		public final HashSet<String> variables = new HashSet<>();

		Expression(Object value) {
			this(null, value, null, null, false);
		}

		Expression(Operator op, Object left, Object right, Object ternary, boolean isInParentheses) {
			this.op = op;
			this.left = left;
			this.right = right;
			this.ternary = ternary;
			this.isInParentheses = isInParentheses;
			registerVariables(left);
			registerVariables(right);
			registerVariables(ternary);
		}

		public Object simplify(@Nullable VariableSupplier constants) {
			Object l = left instanceof Expression ? ((Expression) left).simplify(constants) : left;
			Object r = right instanceof Expression ? ((Expression) right).simplify(constants) : right;

			if (constants != null) {
				if (l instanceof String) {
					var value = constants.get((String) l);
					if (value != null)
						l = sanitizeValue(value);
				}
				if (r instanceof String) {
					var value = constants.get((String) r);
					if (value != null)
						r = sanitizeValue(value);
				}
			}

			if (op == Operator.TERNARY) {
				Object t = asExpression(ternary).simplify(constants);
				if (t instanceof Boolean)
					return (boolean) t ? l : r;
				return new Expression(op, l, r, asExpression(t), isInParentheses);
			}

			var expr = this;
			if (l != left || r != right)
				expr = new Expression(op, l, r, null, isInParentheses);

			if (isPrimitive(l) && isPrimitive(r))
				return expr.toFunctionInternal().apply(null);

			return expr;
		}

		private String formatOperand(Object operand) {
			if (operand instanceof Number) {
				int nearest = round((float) operand);
				if (abs((float) operand - nearest) < 1e-10)
					operand = nearest;
			}
			return operand.toString();
		}

		@Override
		public String toString() {
			if (op == null)
				return formatOperand(left);
			if (op.numOperands == 1)
				return op.symbol + formatOperand(left);
			if (op.numOperands == 2)
				return String.format("%s %s %s", formatOperand(left), op, formatOperand(right));
			if (op.numOperands == 3)
				return String.format("%s %s %s : %s", formatOperand(ternary), op, formatOperand(left), formatOperand(right));
			throw new IllegalStateException(String.format("Cannot stringify operator '%s'", op));
		}

		public Function<VariableSupplier, Object> toFunction() {
			var func = toFunctionInternal();
			return vars -> func.apply(key -> sanitizeValue(vars.get(key)));
		}

		static Object sanitizeValue(Object value) {
			// This is kind of stupid, but it's necessary to convert
			// ints to floats here to avoid messy code later
			if (value instanceof Integer)
				return ((Integer) value).floatValue();
			return value;
		}

		private Function<VariableSupplier, Object> toFunctionInternal() {
			if (op == null)
				return asFunction(left);

			if (op == Operator.TERNARY) {
				var condition = asExpression(ternary).toPredicate();
				if (left instanceof Expression) {
					var ifTrue = ((Expression) left).toFunction();
					if (right instanceof Expression) {
						var ifFalse = ((Expression) right).toFunction();
						return vars -> condition.test(vars) ? ifTrue.apply(vars) : ifFalse.apply(vars);
					}
					return vars -> condition.test(vars) ? ifTrue.apply(vars) : right;
				} else if (right instanceof Expression) {
					var ifFalse = ((Expression) right).toFunction();
					return vars -> condition.test(vars) ? left : ifFalse.apply(vars);
				} else {
					return vars -> condition.test(vars) ? left : right;
				}
			}

			// Convert variables and constants into functions
			var l = asFunction(left);
			var r = asFunction(right);

			switch (op) {
				case AND:
					return vars -> (boolean) l.apply(vars) && (boolean) r.apply(vars);
				case OR:
					return vars -> (boolean) l.apply(vars) || (boolean) r.apply(vars);
				case NOTEQUAL:
				case EQUAL:
					boolean isBoolean =
						left instanceof Boolean || left instanceof Expression && ((Expression) left).isBoolean() ||
						right instanceof Boolean || right instanceof Expression && ((Expression) right).isBoolean();
					if (isBoolean) {
						return op == Operator.EQUAL ?
							vars -> (boolean) l.apply(vars) == (boolean) r.apply(vars) :
							vars -> (boolean) l.apply(vars) != (boolean) r.apply(vars);
					} else {
						return op == Operator.EQUAL ?
							vars -> (float) l.apply(vars) == (float) r.apply(vars) :
							vars -> (float) l.apply(vars) != (float) r.apply(vars);
					}
				case GEQUAL:
					return vars -> (float) l.apply(vars) >= (float) r.apply(vars);
				case GREATER:
					return vars -> (float) l.apply(vars) > (float) r.apply(vars);
				case LEQUAL:
					return vars -> (float) l.apply(vars) <= (float) r.apply(vars);
				case LESS:
					return vars -> (float) l.apply(vars) < (float) r.apply(vars);
				case ADD:
					return vars -> (float) l.apply(vars) + (float) r.apply(vars);
				case SUB:
					return vars -> (float) l.apply(vars) - (float) r.apply(vars);
				case MUL:
					return vars -> (float) l.apply(vars) * (float) r.apply(vars);
				case DIV:
					return vars -> (float) l.apply(vars) / (float) r.apply(vars);
				case MOD:
					return vars -> (float) l.apply(vars) % (float) r.apply(vars);
				case NOT:
					return vars -> !(boolean) r.apply(vars);
			}

			throw new UnsupportedOperationException("Unsupported operands: " + l + " " + op + " " + r);
		}

		public ExpressionPredicate toPredicate() {
			if (!isBoolean())
				throw new IllegalArgumentException("Expression does not result in a boolean");

			var func = toFunction();
			return vars -> (boolean) func.apply(vars);
		}

		boolean isBoolean() {
			if (op == null)
				return isPossiblyBoolean(left);
			switch (op) {
				case TERNARY:
					return isPossiblyBoolean(left) || isPossiblyBoolean(right);
				case EQUAL:
				case NOTEQUAL:
				case LESS:
				case LEQUAL:
				case GREATER:
				case GEQUAL:
				case AND:
				case OR:
				case NOT:
					return true;
			}
			return false;
		}

		static boolean isPossiblyBoolean(Object obj) {
			return
				obj instanceof Boolean ||
				obj instanceof String ||
				obj instanceof Expression && ((Expression) obj).isBoolean();
		}

		private boolean isPrimitive(Object obj) {
			return obj == null || obj instanceof Float || obj instanceof Boolean;
		}

		private void registerVariables(@Nullable Object dependency) {
			if (dependency instanceof String) {
				variables.add((String) dependency);
			} else if (dependency instanceof Expression) {
				variables.addAll(((Expression) dependency).variables);
			}
		}
	}

	private static Object parseExpression(String expression, int startIndex, int endIndex) {
		return parseExpression(new ParserContext(expression, startIndex, endIndex, true, 0));
	}

	private static Object parseExpression(ParserContext ctx) {
		ctx.trimWhitespace();
		if (ctx.done())
			throw new SyntaxError(ctx, "Empty expression");

		ctx.trimParentheses();
		boolean wasInParentheses = ctx.isInParentheses;
		boolean wasTopLevelParser = ctx.isTopLevelParser;
		// Since we'll be reusing the same parser context for parsing sub-expressions, mark it as not top-level
		ctx.isTopLevelParser = false;

		// The general gist:
		// 1. Begin parsing from left to right until any operator is reached
		// 2. Parse all following higher precedence operations
		// 3. Continue parsing operators regardless of precedence
		// 4. If a lower precedence operator is reached, make that the new parent node, and return to step 2
		// 5. At the end, return the left operand and parenthesis information

		ctx.operands[0] = ctx.parseOperand();

		parsing:
		while (!ctx.done()) {
			ctx.skipWhitespace();
			ctx.op = null;
			for (var op : Operator.OPERATORS) {
				// Skip lower precedence operators
				if (op.precedence >= ctx.minPrecedence && ctx.expr.startsWith(op.symbol, ctx.index)) {
					if (op == Operator.TERNARY) {
						// Parse the ternary into an expression to be the new left operand, and keep parsing
						var condition = ctx.operands[0];
						if (condition == null)
							throw new SyntaxError(ctx, "Unexpected operator '" + op.symbol + "' without preceding condition");
						ctx.index += op.symbol.length();
						var ifTrue = parseExpression(ctx);
						ctx.trim();
						if (ctx.c != ':')
							throw new SyntaxError(ctx, "Expected ':' in ternary expression");
						ctx.advance();
						var ifFalse = parseExpression(ctx);
						ctx.operands[0] = new Expression(op, ifTrue, ifFalse, condition, wasInParentheses);
						continue parsing;
					}

					if (ctx.operands[0] == null) {
						if (op.numOperands > 1)
							throw new SyntaxError(ctx, "Missing left operand for operator '" + op.symbol + "'");
					} else if (op.numOperands == 1) {
						throw new SyntaxError(ctx, "Unexpected left operand before '" + op.symbol + "'");
					}

					ctx.op = op;
					ctx.index += op.symbol.length();
					break;
				}
			}

			if (ctx.op == null)
				break;

			if (ctx.op != Operator.NOT && ctx.operands[0] == null)
				throw new SyntaxError(ctx, "Missing left operand for operator '" + ctx.op.symbol + "'");

			// Will parse all following higher precedence operations, or a single value or identifier
			ctx.operands[1] = ctx.parseOperand();
			if (ctx.operands[1] == null)
				throw new SyntaxError(ctx, "Missing right operand for operator '" + ctx.op.symbol + "'");

			ctx.operands[0] = ctx.createExpression(ctx.operands[0], ctx.op, ctx.operands[1]);
		}

		if (wasTopLevelParser && !ctx.done())
			throw new SyntaxError(ctx, "Unexpected character '" + ctx.c + "'");

		if (ctx.operands[0] instanceof Expression)
			((Expression) ctx.operands[0]).isInParentheses = wasInParentheses;

		return ctx.operands[0];
	}
}

package rs117.hd.utils;

import java.util.function.Predicate;

@FunctionalInterface
public interface ExpressionPredicate extends Predicate<VariableSupplier> {
	ExpressionPredicate TRUE = vars -> true;
	ExpressionPredicate FALSE = vars -> false;

	default boolean test() {
		return test(vars -> null);
	}
}

/*
 * Copyright (c) 2022, Hooder <ahooder@protonmail.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package rs117.hd.utils;

import com.google.common.collect.ArrayListMultimap;
import com.google.common.collect.ListMultimap;
import java.io.File;
import java.io.IOException;
import java.nio.file.ClosedWatchServiceException;
import java.nio.file.FileSystems;
import java.nio.file.FileVisitResult;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.SimpleFileVisitor;
import java.nio.file.WatchEvent;
import java.nio.file.WatchKey;
import java.nio.file.WatchService;
import java.nio.file.attribute.BasicFileAttributes;
import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.DelayQueue;
import java.util.concurrent.Delayed;
import java.util.concurrent.TimeUnit;
import java.util.function.Consumer;
import javax.annotation.Nonnull;
import lombok.AllArgsConstructor;
import lombok.extern.slf4j.Slf4j;

import static java.nio.file.StandardWatchEventKinds.ENTRY_CREATE;
import static java.nio.file.StandardWatchEventKinds.ENTRY_DELETE;
import static java.nio.file.StandardWatchEventKinds.ENTRY_MODIFY;
import static java.nio.file.StandardWatchEventKinds.OVERFLOW;
import static rs117.hd.utils.ResourcePath.path;

@Slf4j
public class FileWatcher {
	private static final WatchEvent.Kind<?>[] eventKinds = { ENTRY_CREATE, ENTRY_DELETE, ENTRY_MODIFY };

	private static Thread watcherThread;
	private static Thread runnerThread;
	private static WatchService watchService;
	private static final HashMap<WatchKey, Path> watchKeys = new HashMap<>();
	private static final ListMultimap<String, Consumer<ResourcePath>> changeHandlers = ArrayListMultimap.create();
	private static final DelayQueue<PendingChange> pendingChanges = new DelayQueue<>();

	@AllArgsConstructor
	private static class PendingChange implements Delayed {
		final ResourcePath path;
		final Consumer<ResourcePath> handler;
		long delayUntilMillis;

		@Override
		public boolean equals(Object obj) {
			return
				obj instanceof PendingChange &&
				path.equals(((PendingChange) obj).path) &&
				handler.equals(((PendingChange) obj).handler);
		}

		@Override
		public long getDelay(TimeUnit timeUnit) {
			return timeUnit.convert(delayUntilMillis - System.currentTimeMillis(), TimeUnit.MILLISECONDS);
		}

		@Override
		public int compareTo(Delayed delayed) {
			return (int) (getDelay(TimeUnit.MILLISECONDS) - delayed.getDelay(TimeUnit.MILLISECONDS));
		}
	}

	private static void initialize() throws IOException {
		watchService = FileSystems.getDefault().newWatchService();
		watcherThread = new Thread(() -> {
			try {
				WatchKey watchKey;
				while ((watchKey = watchService.take()) != null) {
					Path dir = watchKeys.get(watchKey);
					if (dir == null) {
						log.error("Unknown WatchKey: {}", watchKey);
						continue;
					}
					for (WatchEvent<?> event : watchKey.pollEvents()) {
						if (event.kind() == OVERFLOW)
							continue;

						Path path = dir.resolve((Path) event.context());
						if (path.toString().endsWith("~")) // Ignore temp files
							continue;

						log.trace("WatchEvent of kind {} for path {}", event.kind(), path);

						try {
							// Manually register new sub folders if not watching a file tree
							if (event.kind() == ENTRY_CREATE && path.toFile().isDirectory())
								watchRecursively(path);

							String key = path.toString();
							ResourcePath resourcePath = path(key);
							if (path.toFile().isDirectory())
								key += File.separator;

							for (Map.Entry<String, Consumer<ResourcePath>> entry : changeHandlers.entries())
								if (key.startsWith(entry.getKey()))
									queuePendingChange(resourcePath, entry.getValue());
						} catch (Exception ex) {
							log.error("Error while handling file change event:", ex);
						}
					}
					watchKey.reset();
				}
			} catch (ClosedWatchServiceException ignored) {
			} catch (InterruptedException ex) {
				log.error("Watcher thread interrupted", ex);
			}
		}, FileWatcher.class.getSimpleName() + " Watcher");
		watcherThread.setDaemon(true);
		watcherThread.start();

		runnerThread = new Thread(() -> {
			try {
				PendingChange pending;
				while ((pending = pendingChanges.poll(100, TimeUnit.DAYS)) != null) {
					try {
						pending.handler.accept(pending.path);
					} catch (Throwable throwable) {
						log.error("Error in change handler for path: {}", pending.path, throwable);
					}
				}
			} catch (InterruptedException ignored) {
			}
		}, FileWatcher.class.getSimpleName() + " Runner");
		runnerThread.setDaemon(true);
		runnerThread.start();
	}

	private static void queuePendingChange(ResourcePath path, Consumer<ResourcePath> handler) {
		var pendingChange = new PendingChange(path, handler, System.currentTimeMillis() + 200);
		var ignored = pendingChanges.remove(pendingChange);
		pendingChanges.add(pendingChange);
	}

	public static void destroy() {
		if (watchService == null)
			return;

		try {
			log.debug("Shutting down {}", FileWatcher.class.getSimpleName());
			changeHandlers.clear();
			watchKeys.clear();
			watchService.close();
			watchService = null;
			if (watcherThread.isAlive())
				watcherThread.join();
			runnerThread.interrupt();
			if (runnerThread.isAlive())
				runnerThread.join();
		} catch (IOException | InterruptedException ex) {
			throw new RuntimeException("Error while closing " + FileWatcher.class.getSimpleName(), ex);
		}
	}

	@FunctionalInterface
	public interface UnregisterCallback {
		void unregister();
	}

	public static UnregisterCallback watchPath(@Nonnull ResourcePath resourcePath, @Nonnull Consumer<ResourcePath> changeHandler)
	{
		if (!resourcePath.isFileSystemResource())
			throw new IllegalStateException("Only resources on the file system can be watched: " + resourcePath);

		try {
			if (watchService == null)
				initialize();

			Path path = resourcePath.toPath();

			final String key;
			final Consumer<ResourcePath> handler;
			if (path.toFile().isDirectory()) {
				watchRecursively(path);
				key = path + File.separator;
				handler = changeHandler;
			} else {
				watchFile(path);
				key = path.toString();
				handler = changed -> {
					try {
						if (Files.isSameFile(changed.toPath(), resourcePath.toPath()))
							changeHandler.accept(changed);
					} catch (IOException ex) {
						throw new RuntimeException(ex);
					}
				};
			}

			changeHandlers.put(key, handler);
			return () -> changeHandlers.remove(key, handler);
		} catch (IOException ex) {
			throw new RuntimeException("Failed to initialize " + FileWatcher.class.getSimpleName(), ex);
		}
	}

	private static void watchFile(Path path) {
		Path dir = path.getParent();
		try {
			watchKeys.put(dir.register(watchService, eventKinds), dir);
			log.debug("Watching {}", path);
		} catch (Exception ex) {
			throw new RuntimeException("Failed to register file watcher for path: " + path, ex);
		}
	}

	private static void watchRecursively(Path path) {
		try {
			log.debug("Watching {}", path);
			Files.walkFileTree(path, new SimpleFileVisitor<>() {
				@Override
				public FileVisitResult preVisitDirectory(Path dir, BasicFileAttributes attrs) throws IOException {
					WatchKey key = dir.register(watchService, eventKinds);
					watchKeys.put(key, dir);
					return FileVisitResult.CONTINUE;
				}
			});
		} catch (Exception ex) {
			throw new RuntimeException("Failed to register recursive file watcher for path: " + path, ex);
		}
	}
}

package rs117.hd.utils;

import com.google.gson.Gson;
import com.google.gson.JsonObject;
import com.google.inject.Inject;
import com.google.inject.Singleton;
import java.io.IOException;
import java.io.PrintWriter;
import java.text.SimpleDateFormat;
import java.util.ArrayDeque;
import java.util.HashMap;
import java.util.LinkedHashMap;
import java.util.Map;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.*;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.config.ConfigManager;
import rs117.hd.HdPlugin;
import rs117.hd.HdPluginConfig;
import rs117.hd.overlays.FrameTimer;
import rs117.hd.overlays.FrameTimings;
import rs117.hd.overlays.Timer;

import static org.lwjgl.opengl.GL33C.*;
import static rs117.hd.utils.MathUtils.*;

@Slf4j
@Singleton
public class FrameTimingsRecorder implements FrameTimer.Listener {
	private static final ResourcePath SNAPSHOTS_PATH = HdPlugin.PLUGIN_DIR.resolve("snapshots");
	private static final int SNAPSHOT_DURATION_MS = 20_000;

	@Inject
	private Gson gson;

	@Inject
	private Client client;

	@Inject
	private ClientThread clientThread;

	@Inject
	private ConfigManager configManager;

	@Inject
	private HdPlugin plugin;

	@Inject
	private FrameTimer frameTimer;

	@Inject
	private NpcDisplacementCache npcDisplacementCache;

	private static class Snapshot {
		public long timestamp = System.currentTimeMillis();
		public String osName;
		public String osArch;
		public String osVersion;
		public String javaVersion;
		public int cpuCores;
		public long memoryMaxMiB;
		public String gpuName;
		public Map<String, String> settings = new HashMap<>();
		public ArrayDeque<Frame> frames = new ArrayDeque<>(SNAPSHOT_DURATION_MS * 200 / 1000); // Allocate for 200 FPS

		public static class Frame {
			public long timestamp;
			public long drawnTiles;
			public long drawnStatic;
			public long drawnDynamic;
			public long npcDisplacementCacheSize;
			public long memoryUsed;
			public long memoryTotal;
			public long memoryFree;
			public long memoryMax;
			public LinkedHashMap<String, Long> cpu;
			public LinkedHashMap<String, Long> gpu;

			public transient long[] rawTimings;

			public Frame(FrameTimings frameTimings) {
				timestamp = frameTimings.frameTimestamp;
				rawTimings = frameTimings.timers;
				Runtime rt = Runtime.getRuntime();
				memoryTotal = rt.totalMemory() / MiB;
				memoryFree = rt.freeMemory() / MiB;
				memoryMax = rt.maxMemory() / MiB;
				memoryUsed = memoryTotal - memoryFree;
			}
		}
	}

	private Snapshot snapshot;

	public boolean isCapturingSnapshot() {
		return snapshot != null;
	}

	public void recordSnapshot() {
		clientThread.invoke(() -> {
			if (isCapturingSnapshot()) {
				sendGameMessage(String.format("Already capturing a snapshot (%d%% complete)", getProgressPercentage()));
				return;
			}

			snapshot = new Snapshot();
			snapshot.osName = System.getProperty("os.name");
			snapshot.osArch = System.getProperty("os.arch");
			snapshot.osVersion = System.getProperty("os.version");
			snapshot.javaVersion = System.getProperty("java.version");
			snapshot.cpuCores = HdPlugin.PROCESSOR_COUNT;
			snapshot.memoryMaxMiB = Runtime.getRuntime().maxMemory() / MiB;
			snapshot.gpuName = String.format(
				"%s (%s, OpenGL %s)",
				glGetString(GL_RENDERER),
				glGetString(GL_VENDOR),
				glGetString(GL_VERSION)
			);

			String prefix = HdPluginConfig.CONFIG_GROUP + ".";
			for (String config : configManager.getConfigurationKeys(prefix)) {
				String key = config.substring(prefix.length());
				snapshot.settings.put(key, configManager.getConfiguration("hd", key));
			}

			frameTimer.addTimingsListener(this);
			sendGameMessage(String.format("Capturing frame timings for %.0f seconds...", SNAPSHOT_DURATION_MS / 1e3f));
		});
	}

	public int getProgressPercentage() {
		if (isCapturingSnapshot())
			return round((float) (System.currentTimeMillis() - snapshot.timestamp) / SNAPSHOT_DURATION_MS * 100);
		return 100;
	}

	@Override
	public void onFrameCompletion(FrameTimings timings) {
		if (!isCapturingSnapshot()) {
			frameTimer.removeTimingsListener(this);
			return;
		}

		if (timings.frameTimestamp - snapshot.timestamp > SNAPSHOT_DURATION_MS) {
			saveSnapshot();
			return;
		}

		var frame = new Snapshot.Frame(timings);
		frame.drawnTiles = plugin.getDrawnTileCount();
		frame.drawnStatic = plugin.getDrawnStaticRenderableCount();
		frame.drawnDynamic = plugin.getDrawnDynamicRenderableCount();
		frame.npcDisplacementCacheSize = npcDisplacementCache.size();
		snapshot.frames.add(frame);
	}

	private void saveSnapshot() {
		frameTimer.removeTimingsListener(this);

		for (var frame : snapshot.frames) {
			frame.cpu = new LinkedHashMap<>();
			frame.gpu = new LinkedHashMap<>();
			for (Timer t : Timer.TIMERS)
				(t.isGpuTimer ? frame.gpu : frame.cpu).put(t.name, frame.rawTimings[t.ordinal()]);
		}

		try {
			SNAPSHOTS_PATH.mkdirs();
			String timestamp = new SimpleDateFormat("yyyy-MM-dd_HH-mm-ss").format(snapshot.timestamp);
			var path = SNAPSHOTS_PATH.resolve("snapshot-" + timestamp);
			path.setExtension("json").writeString(gson.toJson(snapshot));
			saveCsvSnapshot(path);
			sendGameMessage("Snapshot complete! Saved to: " + path + ".csv & json");
		} catch (IOException ex) {
			log.error("Error while saving snapshot:", ex);
		}

		snapshot = null;
	}

	private String escapeCsv(String string) {
		string = string.replaceAll("\"", "\"\"");
		if (string.contains(",") || string.contains("\n"))
			string = '"' + string + '"';
		return string;
	}

	private void writeCsvObject(PrintWriter out, boolean header, String prefix, JsonObject obj) {
		String comma = "";
		for (var entry : obj.entrySet()) {
			out.write(comma);
			var value = entry.getValue();
			if (value.isJsonObject()) {
				writeCsvObject(out, header, prefix + entry.getKey() + ".", value.getAsJsonObject());
			} else {
				out.write(escapeCsv(header ? prefix + entry.getKey() : value.toString()));
			}
			comma = ",";
		}
	}

	private void saveCsvSnapshot(ResourcePath path) throws IOException {
		if (snapshot.frames.isEmpty())
			return;

		var frames = gson.toJsonTree(snapshot.frames).getAsJsonArray();
		try (var out = new PrintWriter(path.setExtension("csv").toWriter())) {
			writeCsvObject(out, true, "", frames.get(0).getAsJsonObject());
			out.println();
			for (var frame : frames) {
				writeCsvObject(out, false, "", frame.getAsJsonObject());
				out.println();
			}
		}
	}

	private void sendGameMessage(String message) {
		clientThread.invoke(() -> client.addChatMessage(
			ChatMessageType.GAMEMESSAGE, "117 HD", "<col=ffff00>[117 HD] " + message + "</col>", "117 HD"));
	}
}

/*
 * Gson hacks.
 * Written in 2025 by Hooder <ahooder@protonmail.com>
 * To the extent possible under law, the author(s) have dedicated all copyright and related and neighboring rights
 * to this software to the public domain worldwide. This software is distributed without any warranty.
 * You should have received a copy of the CC0 Public Domain Dedication along with this software.
 * If not, see <http://creativecommons.org/publicdomain/zero/1.0/>.
 */
package rs117.hd.utils;

import com.google.gson.Gson;
import com.google.gson.JsonObject;
import com.google.gson.TypeAdapter;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonToken;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;
import java.util.Objects;
import javax.annotation.Nullable;
import lombok.NoArgsConstructor;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;

import static rs117.hd.utils.MathUtils.*;

@Slf4j
public class GsonUtils {
	public static String location(JsonReader in) {
		var str = in.toString();
		int i = str.indexOf(" at ");
		if (i != -1)
			str = str.substring(i + 4);
		return str;
	}

	public static Gson wrap(Gson gson) {
		return gson.newBuilder()
			.setLenient()
			.setPrettyPrinting()
			.disableHtmlEscaping() // Disable HTML escaping for JSON exports (Gson never escapes when parsing regardless)
			.registerTypeAdapterFactory(new ExcludeDefaultsFactory())
			.registerTypeAdapter(Float.class, new RoundingAdapter(3))
			.create();
	}

	public static class RoundingAdapter extends TypeAdapter<Float> {
		private final float rounding;

		public RoundingAdapter(int decimals) {
			rounding = pow(10, decimals);
		}

		@Override
		public Float read(JsonReader in) throws IOException {
			if (in.peek() == JsonToken.NULL)
				return null;
			return (float) in.nextDouble();
		}

		@Override
		public void write(JsonWriter out, Float src) throws IOException {
			if (src == null) {
				out.nullValue();
			} else {
				var result = round(src * rounding) / rounding;
				if (round(result) == result) {
					out.value((int) result); // Remove decimals when possible
				} else {
					out.value((Number) result); // Cast to Number so Gson removes unnecessary precision
				}
			}
		}
	}

	/**
	 * Make it less cumbersome to implement a TypeAdapter which respects the default Float adapter.
	 */
	@NoArgsConstructor
	@SuppressWarnings("unchecked")
	public static abstract class DelegateFloatAdapter<T> implements TypeAdapterFactory {
		protected TypeAdapter<Float> FLOAT_ADAPTER;
		protected boolean unwrapContainers; // Only apply directly to numbers, letting Gson handle any composite types

		@Override
		public <U> TypeAdapter<U> create(Gson gson, TypeToken<U> typeToken) {
			FLOAT_ADAPTER = gson.getAdapter(TypeToken.get(Float.class));
			var impl = this;
			var adapter = new TypeAdapter<U>() {
				@Override
				public U read(JsonReader in) throws IOException {
					return (U) impl.read(in);
				}

				@Override
				public void write(JsonWriter out, U value) throws IOException {
					impl.write(out, (T) value);
				}
			};

			if (!unwrapContainers)
				return adapter;

			// Register this as a TypeAdapterFactory for numbers downstream
			return gson.newBuilder()
				.registerTypeAdapterFactory(new TypeAdapterFactory() {
					@Override
					public <S> TypeAdapter<S> create(Gson gson, TypeToken<S> typeToken) {
						var type = typeToken.getRawType();
						if (type.isPrimitive()) {
							if (type != float.class)
								return null;
						} else if (!Float.class.isAssignableFrom(type)) {
							return null;
						}
						return (TypeAdapter<S>) adapter;
					}
				})
				.create()
				.getAdapter(typeToken);
		}

		public abstract T read(JsonReader in) throws IOException;
		public abstract void write(JsonWriter out, T value) throws IOException;
	}

	/**
	 * Because of the way this works internally, custom formatting by calling `JsonWriter#jsonValue` is not supported.
	 */
	@Retention(RetentionPolicy.RUNTIME)
	@Target(ElementType.TYPE)
	public @interface ExcludeDefaults {}

	public interface ExcludeDefaultsProvider<T> {
		@Nullable
		T provideDefaults();
	}

	@RequiredArgsConstructor
	private static class ExcludeDefaultsAdapter<T> extends TypeAdapter<T> {
		private final Gson gson;
		private final TypeAdapter<T> type;
		private final JsonObject defaults;

		@Override
		public void write(JsonWriter out, T t) throws IOException {
			var json = type.toJsonTree(t);
			if (!json.isJsonObject()) {
				gson.toJson(json, out);
				return;
			}

			var defaults = this.defaults;
			if (t instanceof ExcludeDefaultsProvider) {
				var provided = ((ExcludeDefaultsProvider<?>) t).provideDefaults();
				if (provided != null) {
					try {
						// noinspection unchecked
						defaults = type.toJsonTree((T) provided).getAsJsonObject();
					} catch (ClassCastException ex) {
						log.error("Incorrect type provided by DefaultsProvider: {}, expected {}", provided.getClass(), t.getClass());
					}
				}
			}

			var obj = json.getAsJsonObject();
			for (var e : defaults.entrySet())
				if (Objects.equals(obj.get(e.getKey()), e.getValue()))
					obj.remove(e.getKey());

			// Make it possible to replace inherited non-null default values with explicit nulls
			out.setSerializeNulls(true);
			out.beginObject();
			for (var e : obj.entrySet()) {
				out.name(e.getKey());
				if (e.getValue().isJsonNull()) {
					out.nullValue();
				} else {
					gson.toJson(e.getValue(), out);
				}
			}
			out.endObject();
		}

		@Override
		public T read(JsonReader in) throws IOException {
			return type.read(in);
		}
	}

	private static class ExcludeDefaultsFactory implements TypeAdapterFactory {
		@Override
		public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
			for (var annotation : type.getRawType().getAnnotations()) {
				if (annotation.annotationType() == ExcludeDefaults.class) {
					try {
						var defaultDelegate = gson.getDelegateAdapter(this, type);
						T defaultObj;
						try {
							defaultObj = defaultDelegate.fromJson("{}");
						} catch (IOException ex) {
							return null; // Can't skip defaults for non-object types
						}

						if (defaultObj == null)
							return null; // No defaults available

						var defaults = defaultDelegate.toJsonTree(defaultObj).getAsJsonObject();
						return new ExcludeDefaultsAdapter<>(gson, gson.getDelegateAdapter(this, type), defaults);
					} catch (Exception ex) {
						log.error("Unable to exclude defaults for {}", type, ex);
						break;
					}
				}
			}
			return null;
		}
	}

	public static class DegreesToRadians extends DelegateFloatAdapter<Float> {
		{
			unwrapContainers = true;
		}

		@Override
		public Float read(JsonReader in) throws IOException {
			var value = FLOAT_ADAPTER.read(in);
			return value == null ? null : value * DEG_TO_RAD;
		}

		@Override
		public void write(JsonWriter out, Float value) throws IOException {
			FLOAT_ADAPTER.write(out, value == null ? null : value * RAD_TO_DEG);
		}
	}
}

/*
 * Copyright (c) 2021, 117 <https://twitter.com/117scape>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package rs117.hd.utils;

import javax.inject.Singleton;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.*;
import rs117.hd.data.ObjectType;
import rs117.hd.scene.areas.AABB;
import rs117.hd.scene.areas.Area;
import rs117.hd.scene.water_types.WaterType;

import static net.runelite.api.Constants.*;
import static net.runelite.api.Constants.SCENE_SIZE;
import static net.runelite.api.Perspective.*;
import static rs117.hd.scene.ProceduralGenerator.VERTICES_PER_FACE;
import static rs117.hd.scene.ProceduralGenerator.faceLocalVertices;
import static rs117.hd.scene.ProceduralGenerator.isOverlayFace;
import static rs117.hd.utils.MathUtils.*;

@Slf4j
@Singleton
public final class HDUtils {
	public static final int HIDDEN_HSL = 12345678;
	public static final int UNDERWATER_HSL = 6676;

	public static int fastVertexHash(int[] vPos) {
		int hash = 0;
		for (int part : vPos) {
			hash = 31 * hash + part;
			hash = 31 * hash + ','; // preserve the comma separator effect
		}
		return hash;
	}

	public static int[] calculateSurfaceNormals(int[] a, int[] b, int[] c) {
		subtract(b, a, b);
		subtract(c, a, c);
		return cross(b, c);
	}

	public static long ceilPow2(long l) {
		assert l >= 0;
		l--; // Reduce by 1 in case it's already a power of 2
		// Fill in all bits below the highest active bit
		for (int i = 1; i <= 32; i *= 2)
			l |= l >> i;
		return l + 1; // Bump it up to the next power of 2
	}

	public static float[] sunAngles(float altitude, float azimuth) {
		return multiply(vec(altitude, azimuth), DEG_TO_RAD);
	}

	public static float[] ensureArrayLength(float[] array, int targetLength) {
		return array.length == targetLength ? array : slice(array, 0, targetLength);
	}

	public static int convertWallObjectOrientation(int orientation) {
		// Note: this is still imperfect, since the model rotation of a wall object depends on more than just the config orientation,
		// 		 i.e. extra rotation depending on wall type whatever. I'm not sure.
		// Derived from config orientation {@link HDUtils#getBakedOrientation}
		switch (orientation) {
			case 1:
				return 512; // west
			case 2:
				return 1024; // north
			case 4:
				return 1536; // east
			case 8:
			default:
				return 0; // south
			case 16:
				return 768; // north-west
			case 32:
				return 1280; // north-east
			case 64:
				return 1792; // south-east
			case 128:
				return 256; // south-west
		}
	}

	// (gameObject.getConfig() >> 6) & 3, // 2-bit orientation
	// (gameObject.getConfig() >> 8) & 1, // 1-bit interactType != 0 (supports items)
	// (gameObject.getConfig() >> 9) // should always be zero
	public static int getObjectConfig(Tile tile, long hash) {
		if (tile.getWallObject() != null && tile.getWallObject().getHash() == hash)
			return tile.getWallObject().getConfig();
		if (tile.getDecorativeObject() != null && tile.getDecorativeObject().getHash() == hash)
			return tile.getDecorativeObject().getConfig();
		if (tile.getGroundObject() != null && tile.getGroundObject().getHash() == hash)
			return tile.getGroundObject().getConfig();
		for (GameObject gameObject : tile.getGameObjects())
			if (gameObject != null && gameObject.getHash() == hash)
				return gameObject.getConfig();
		return -1;
	}

	public static int getObjectConfig(TileObject tileObject) {
		if (tileObject instanceof WallObject)
			return ((WallObject) tileObject).getConfig();
		if (tileObject instanceof DecorativeObject)
			return ((DecorativeObject) tileObject).getConfig();
		if (tileObject instanceof GroundObject)
			return ((GroundObject) tileObject).getConfig();
		if (tileObject instanceof GameObject)
			return ((GameObject) tileObject).getConfig();
		return -1;
	}

	/**
	 * Computes the orientation used when uploading the model.
	 * This does not include the extra 45-degree rotation of diagonal models.
	 */
	public static int getModelPreOrientation(int config) {
		var objectType = ObjectType.fromConfig(config);
		int orientation = 1024 + 512 * (config >>> 6 & 3);
		switch (objectType) {
			case WallDiagonalCorner:
			case WallSquareCorner:
			case WallDecorDiagonalOffset:
			case WallDecorDiagonalBoth:
				orientation += 1024;
		}
		return orientation % 2048;
	}

	/**
	 * Computes the complete model orientation, including the pre-orientation when uploading,
	 * and the extra 45-degree rotation of diagonal models.
	 */
	public static int getModelOrientation(int config) {
		int orientation = getModelPreOrientation(config);
		var objectType = ObjectType.fromConfig(config);
		switch (objectType) {
			case WallDecorDiagonalNoOffset:
			case CentrepieceDiagonal:
				orientation += 256;
		}
		return orientation % 2048;
	}

	/**
	 * Returns the south-west coordinate of the scene in world coordinates, after resolving instance template
	 * chunks to their original world coordinates. If the scene is instanced, the base coordinates are computed from
	 * the center chunk instead, or any valid chunk if the center chunk is invalid.
	 *
	 * @param scene to get the south-west coordinate for
	 * @param plane to use when resolving instance template chunks
	 * @return the south-western coordinate of the scene in world space
	 */
	public static int[] getSceneBaseBestGuess(Scene scene, int plane) {
		int baseX = scene.getBaseX();
		int baseY = scene.getBaseY();

		if (scene.isInstance()) {
			// Assume the player is loaded into the center chunk, and calculate the world space position of the lower
			// left corner of the scene, assuming well-behaved template chunks are used to create the instance.
			int chunkX = 6, chunkY = 6;
			int[][] chunks = scene.getInstanceTemplateChunks()[plane];
			int chunk = chunks[chunkX][chunkY];
			if (chunk == -1) {
				// If the center chunk is invalid, pick any valid chunk and hope for the best
				outer:
				for (chunkX = 0; chunkX < chunks.length; chunkX++) {
					for (chunkY = 0; chunkY < chunks[chunkX].length; chunkY++) {
						chunk = chunks[chunkX][chunkY];
						if (chunk != -1)
							break outer;
					}
				}
			}

			if (chunk != -1) {
				// Extract chunk coordinates
				baseX = chunk >> 14 & 0x3FF;
				baseY = chunk >> 3 & 0x7FF;
				// Shift to what would be the lower left corner chunk if the template chunks were contiguous on the map
				baseX -= chunkX;
				baseY -= chunkY;
				// Transform to world coordinates
				baseX <<= 3;
				baseY <<= 3;
			}
		}

		return ivec(baseX, baseY, 0);
	}

	/**
	 * The returned plane may be different
	 */
	public static int[] localToWorld(Scene scene, int localX, int localY, int plane) {
		return sceneToWorld(scene, localX >> LOCAL_COORD_BITS, localY >> LOCAL_COORD_BITS, plane);
	}

	/**
	 * The returned plane may be different
	 */
	public static void sceneToWorld(Scene scene, int sceneX, int sceneY, int plane, int[] result) {
		if (scene.isInstance()) {
			if (sceneX >= 0 && sceneY >= 0 && sceneX < SCENE_SIZE && sceneY < SCENE_SIZE) {
				int chunkX = sceneX / CHUNK_SIZE;
				int chunkY = sceneY / CHUNK_SIZE;
				int templateChunk = scene.getInstanceTemplateChunks()[plane][chunkX][chunkY];
				if (templateChunk != -1) {
					int rotation = 4 - (templateChunk >> 1 & 3);
					int templateChunkY = (templateChunk >> 3 & 2047) * 8;
					int templateChunkX = (templateChunk >> 14 & 1023) * 8;
					int templateChunkPlane = templateChunk >> 24 & 3;
					int worldX = templateChunkX + (sceneX & 7);
					int worldY = templateChunkY + (sceneY & 7);

					result[0] = worldX;
					result[1] = worldY;
					result[2] = templateChunkPlane;

					chunkX = result[0] & -8;
					chunkY = result[1] & -8;
					int x = result[0] & 7;
					int y = result[1] & 7;
					switch (rotation) {
						case 1:
							result[0] = chunkX + y;
							result[1] = chunkY + (7 - x);
							break;
						case 2:
							result[0] = chunkX + (7 - x);
							result[1] = chunkY + (7 - y);
							break;
						case 3:
							result[0] = chunkX + (7 - y);
							result[1] = chunkY + x;
							break;
					}
					return;
				}
			}
			result[0] = -1;
			result[1] = -1;
			result[2] = 0;
			return;
		}

		result[0] = scene.getBaseX() + sceneX;
		result[1] = scene.getBaseY() + sceneY;
		result[2] = plane;
	}

	public static int[] sceneToWorld(Scene scene, int sceneX, int sceneY, int plane) {
		int[] result = new int[3];
		sceneToWorld(scene, sceneX, sceneY, plane, result);
		return result;
	}

	public static int worldToRegionID(int[] worldPoint) {
		return worldToRegionID(worldPoint[0], worldPoint[1]);
	}

	public static int worldToRegionID(int worldX, int worldY) {
		return worldX >> 6 << 8 | worldY >> 6;
	}

	public static boolean is32Bit() {
		return System.getProperty("sun.arch.data.model", "Unknown").equals("32");
	}

	public static boolean sceneIntersects(Scene scene, int numChunksExtended, Area area) {
		return sceneIntersects(scene, numChunksExtended, area.aabbs);
	}

	public static boolean sceneIntersects(Scene scene, int numChunksExtended, AABB... aabbs) {
		if (scene.isInstance()) {
			var templateChunks = scene.getInstanceTemplateChunks();
			for (var plane : templateChunks) {
				for (var column : plane) {
					for (int chunk : column) {
						if (chunk == -1)
							continue;

						int chunkX = chunk >> 14 & 1023;
						int chunkY = chunk >> 3 & 2047;
						int minX = chunkX * CHUNK_SIZE;
						int minY = chunkY * CHUNK_SIZE;
						int maxX = (chunkX + 1) * CHUNK_SIZE - 1;
						int maxY = (chunkY + 1) * CHUNK_SIZE - 1;

						for (var aabb : aabbs)
							if (aabb.intersects(minX, minY, maxX, maxY))
								return true;
					}
				}
			}

			return false;
		}

		return getNonInstancedSceneBounds(scene, numChunksExtended).intersects(aabbs);
	}

	public static AABB getNonInstancedSceneBounds(Scene scene, int numChunksExtended) {
		assert !scene.isInstance();
		int baseX = scene.getBaseX();
		int baseY = scene.getBaseY();
		int extended = numChunksExtended * CHUNK_SIZE;
		return new AABB(
			baseX - extended,
			baseY - extended,
			baseX + SCENE_SIZE + extended - 1,
			baseY + SCENE_SIZE + extended - 1
		);
	}

	public static int getSouthWesternMostTileColor(int[] out, Tile tile) {
		var paint = tile.getSceneTilePaint();
		var model = tile.getSceneTileModel();
		int hsl = 0;
		if (paint != null) {
			hsl = paint.getSwColor();
			ColorUtils.unpackRawHsl(out, hsl);
		} else if (model != null) {
			int faceCount = tile.getSceneTileModel().getFaceX().length;
			final int[] faceColorsA = model.getTriangleColorA();
			final int[] faceColorsB = model.getTriangleColorB();
			final int[] faceColorsC = model.getTriangleColorC();

			outer:
			for (int face = 0; face < faceCount; face++) {
				if (isOverlayFace(tile, face))
					continue;

				int[][] vertices = faceLocalVertices(tile, face);
				int[] faceColors = new int[] { faceColorsA[face], faceColorsB[face], faceColorsC[face] };

				for (int vertex = 0; vertex < VERTICES_PER_FACE; vertex++) {
					hsl = faceColors[vertex];
					if (vertices[vertex][0] != LOCAL_TILE_SIZE && vertices[vertex][1] != LOCAL_TILE_SIZE)
						break outer;
				}
			}

			ColorUtils.unpackRawHsl(out, hsl);
		}
		return hsl;
	}

	public static boolean isSphereIntersectingFrustum(float x, float y, float z, float radius, float[][] cullingPlanes, int numPlanes) {
		for (int i = 0; i < numPlanes; i++) {
			var p = cullingPlanes[i];
			if (p[0] * x + p[1] * y + p[2] * z + p[3] < -radius)
				return false;
		}
		return true;
	}

	public static boolean isAABBIntersectingFrustum(
		int minX,
		int minY,
		int minZ,
		int maxX,
		int maxY,
		int maxZ,
		float[][] cullingPlanes
	) {
		for (float[] plane : cullingPlanes) {
			if (
				plane[0] * minX + plane[1] * minY + plane[2] * minZ + plane[3] < 0 &&
				plane[0] * maxX + plane[1] * minY + plane[2] * minZ + plane[3] < 0 &&
				plane[0] * minX + plane[1] * maxY + plane[2] * minZ + plane[3] < 0 &&
				plane[0] * maxX + plane[1] * maxY + plane[2] * minZ + plane[3] < 0 &&
				plane[0] * minX + plane[1] * minY + plane[2] * maxZ + plane[3] < 0 &&
				plane[0] * maxX + plane[1] * minY + plane[2] * maxZ + plane[3] < 0 &&
				plane[0] * minX + plane[1] * maxY + plane[2] * maxZ + plane[3] < 0 &&
				plane[0] * maxX + plane[1] * maxY + plane[2] * maxZ + plane[3] < 0
			) {
				return false;
			}
		}

		// Potentially visible
		return true;
	}

	public static int packTerrainData(boolean isTerrain, int waterDepth, WaterType waterType, int plane) {
		// Up to 12-bit water depth | 8-bit water type | 2-bit plane | terrain flag
		assert waterType.index < 1 << 7 : "Too many water types";
		int terrainData = (waterDepth & 0xFFF) << 11 | waterType.index << 3 | plane << 1 | (isTerrain ? 1 : 0);
		assert (terrainData & ~0xFFFFFF) == 0 : "Only the lower 24 bits are usable, since we pass this into shaders as a float";
		return terrainData;
	}

	private static final ThreadLocal<StringBuilder> threadLocalStringBuilder = ThreadLocal.withInitial(StringBuilder::new);

	public static String getThreadStackTrace(Thread thread) {
		var stackTrace = thread.getStackTrace();
		if (stackTrace.length == 0)
			return "<STACK TRACE UNAVAILABLE>";

		StringBuilder sb = threadLocalStringBuilder.get();
		for (int i = 1; i < stackTrace.length; i++)
			sb.append('\t').append(stackTrace[i]).append('\n');

		String s = sb.toString();
		sb.setLength(0);
		return s;
	}

	public static boolean isBakedGroundShading(Model model, int face) {
		final byte[] faceTransparencies = model.getFaceTransparencies();
		if (faceTransparencies == null || (faceTransparencies[face] & 0xFF) <= 100)
			return false;

		final short[] faceTextures = model.getFaceTextures();
		if (faceTextures != null && faceTextures[face] != -1)
			return false;

		final float[] yVertices = model.getVerticesY();
		float heightA = yVertices[model.getFaceIndices1()[face]];
		if (heightA < -8)
			return false;

		float heightB = yVertices[model.getFaceIndices2()[face]];
		float heightC = yVertices[model.getFaceIndices3()[face]];
		return heightA == heightB && heightA == heightC;
	}
}

package rs117.hd.utils;

import java.util.List;
import javax.inject.Inject;
import javax.inject.Singleton;
import rs117.hd.HdPlugin;
import rs117.hd.HdPluginConfig;
import rs117.hd.config.SeasonalTheme;

@Singleton
public class HDVariables implements VariableSupplier {
	public static final String VAR_SEASONAL_THEME = "season";
	public static final String VAR_MODEL_TEXTURES = "modelTextures";
	public static final String VAR_GROUND_TEXTURES = "groundTextures";
	public static final String VAR_GROUND_BLENDING = "blending";
	public static final String VAR_HD_INFERNAL_TEXTURE = "hdInfernalCape";

	@Inject
	private HdPlugin plugin;

	@Inject
	private HdPluginConfig config;

	private static final List<Class<? extends Enum<? extends Enum<?>>>> VAR_ENUMS = List.of(
		SeasonalTheme.class
	);

	@Override
	public Object get(String name) {
		switch (name) {
			case VAR_SEASONAL_THEME:
				return plugin.configSeasonalTheme.ordinal();
			case VAR_MODEL_TEXTURES:
				return plugin.configModelTextures;
			case VAR_GROUND_TEXTURES:
				return plugin.configGroundTextures;
			case VAR_GROUND_BLENDING:
				return plugin.configGroundBlending;
			case VAR_HD_INFERNAL_TEXTURE:
				return config.hdInfernalTexture();
		}

		int i = name.indexOf('.');
		if (i > 0 && i < name.length() - 1) {
			var enumName = name.substring(0, i);
			for (var varEnum : VAR_ENUMS) {
				if (!enumName.equals(varEnum.getSimpleName()))
					continue;

				var enumKey = name.substring(i + 1);
				var enumConstants = varEnum.getEnumConstants();
				for (var enumConstant : enumConstants)
					if (enumKey.equals(enumConstant.name()))
						return enumConstant.ordinal();

				break;
			}
		}

		return null;
	}
}

package rs117.hd.utils.jobs;

import java.util.concurrent.Semaphore;

public final class ClientCallbackJob {
	private static final ThreadLocal<ClientCallbackJob> POOL = ThreadLocal.withInitial(ClientCallbackJob::new);

	public static ClientCallbackJob current() {
		ClientCallbackJob callback = POOL.get();
		callback.semaphore.drainPermits();
		return callback;
	}

	final Semaphore semaphore = new Semaphore(0);
	public Runnable callback;
	public boolean immediate;
}

package rs117.hd.utils.jobs;

import java.util.concurrent.ConcurrentLinkedDeque;

public final class GenericJob extends Job {
	private static final ConcurrentLinkedDeque<GenericJob> POOL = new ConcurrentLinkedDeque<>();

	@FunctionalInterface
	public interface TaskRunnable {
		void run(GenericJob Task) throws InterruptedException;
	}

	public static GenericJob build(String context, TaskRunnable runnable) {
		GenericJob newTask = POOL.poll();
		if (newTask == null)
			newTask = new GenericJob();
		newTask.context = context;
		newTask.runnable = runnable;
		newTask.isReleased = false;

		return newTask;
	}

	public String context;
	public TaskRunnable runnable;

	@Override
	public void onRun() throws InterruptedException {
		runnable.run(this);
	}

	@Override
	protected void onCancel() {}

	@Override
	public void onReleased() {
		runnable = null;
		POOL.add(this);
	}

	@Override
	public String toString() {
		return super.toString() + " " + context;
	}
}

package rs117.hd.utils.jobs;

import com.google.inject.Injector;
import java.util.concurrent.atomic.AtomicBoolean;
import lombok.Getter;
import lombok.extern.slf4j.Slf4j;

@Slf4j
public abstract class Job {
	static JobSystem JOB_SYSTEM;

	protected final AtomicBoolean done = new AtomicBoolean();
	protected final AtomicBoolean wasCancelled = new AtomicBoolean();
	protected final AtomicBoolean encounteredError = new AtomicBoolean();
	protected final AtomicBoolean ranToCompletion = new AtomicBoolean();
	protected final AtomicBoolean queued = new AtomicBoolean();
	protected JobGroup<Job> group;

	@Getter
	protected boolean isReleased;

	boolean executeAsync = true;
	JobHandle handle;

	public final void waitForCompletion() {
		if (handle != null) {
			try {
				handle.await();
			} catch (InterruptedException e) {
				log.warn("Job {} was interrupted while waiting for completion", this);
				throw new RuntimeException(e);
			} finally {
				handle.release();
			}
		}

		if (group != null) {
			group.pending.remove(this);
			group = null;
		}
	}

	public final boolean isQueued() {
		return queued.get();
	}

	public final boolean encounteredError() {
		return encounteredError.get();
	}

	public final boolean wasCancelled() {
		return wasCancelled.get();
	}

	public final boolean ranToCompletion() {
		return ranToCompletion.get();
	}

	public final void cancel() {
		if (handle != null) {
			try {
				handle.cancel(true);
			} catch (InterruptedException e) {
				log.warn("Job {} was interrupted while waiting for it to be cancelled", this);
				throw new RuntimeException(e);
			} finally {
				handle.release();
			}
		}
	}

	public final void release() {
		if (isReleased)
			return;
		isReleased = true;
		queued.set(false);
		waitForCompletion();
		onReleased();
	}

	public final boolean isDone() {
		return done.get();
	}

	public final boolean isHighPriority() {
		return (group != null && group.highPriority) || (handle != null && handle.highPriority);
	}

	protected static Injector getInjector() { return JOB_SYSTEM.injector; }

	protected void invokeClientCallback(boolean immediate, Runnable callback) throws InterruptedException {
		JOB_SYSTEM.invokeClientCallback(immediate || !executeAsync, callback);
	}

	public final void workerHandleCancel() throws InterruptedException {
		if (handle == null)
			return;

		final Worker worker = handle.worker;
		if (handle.worker == null)
			return;

		worker.workerHandleCancel();
	}

	public final <T extends Job> T setExecuteAsync(boolean executeAsync) {
		this.executeAsync = executeAsync;
		return (T) this;
	}

	public final <T extends Job> T queue(JobGroup<T> group, Job... dependencies) {
		assert group != null;
		JOB_SYSTEM.queue(this, group.highPriority, dependencies);
		if (executeAsync) {
			this.group = (JobGroup<Job>) group;
			this.group.pending.add(this);
		}
		return (T) this;
	}

	public final <T extends Job> T queue(boolean highPriority, Job... dependencies) {
		JOB_SYSTEM.queue(this, highPriority, dependencies);
		return (T) this;
	}

	public final <T extends Job> T queue(Job... dependencies) {
		JOB_SYSTEM.queue(this, true, dependencies);
		return (T) this;
	}

	protected abstract void onRun() throws InterruptedException;
	protected abstract void onCancel();
	protected abstract void onReleased();

	public String toString() {
		return "[" + hashCode() + "|" + getClass().getSimpleName() + "]";
	}
}

package rs117.hd.utils.jobs;

import java.util.concurrent.LinkedBlockingDeque;
import lombok.Getter;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;

@Slf4j
@RequiredArgsConstructor
public final class JobGroup<T extends Job> {
	@Getter
	final LinkedBlockingDeque<T> pending = new LinkedBlockingDeque<>();

	@Getter
	final boolean highPriority;

	@Getter
	final boolean autoRelease;

	public int getPendingCount() { return pending.size(); }

	public void complete() {
		T work;
		while ((work = pending.poll()) != null) {
			work.waitForCompletion();
			if (autoRelease) work.release();
		}
	}

	public void cancel() {
		T work;
		while ((work = pending.poll()) != null) {
			work.cancel();
			if (autoRelease) work.release();
		}
		pending.clear();
	}
}

package rs117.hd.utils.jobs;

import java.util.ArrayDeque;
import java.util.HashSet;
import java.util.concurrent.ConcurrentLinkedDeque;
import java.util.concurrent.LinkedBlockingDeque;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.concurrent.locks.AbstractQueuedSynchronizer;
import javax.annotation.Nullable;
import lombok.Getter;
import lombok.extern.slf4j.Slf4j;

import static rs117.hd.utils.HDUtils.getThreadStackTrace;
import static rs117.hd.utils.jobs.JobSystem.VALIDATE;

@Slf4j
final class JobHandle extends AbstractQueuedSynchronizer {
	static JobSystem JOB_SYSTEM;

	public static final int STATE_NONE = 0;
	public static final int STATE_QUEUED = 1;
	public static final int STATE_RUNNING = 2;
	public static final int STATE_CANCELLED = 3;
	public static final int STATE_COMPLETED = 4;

	private static final String[] STATE_NAMES = { "NONE", "QUEUED", "RUNNING", "CANCELLED", "COMPLETED" };
	private static final long DEADLOCK_TIMEOUT_SECONDS = 10;
	private static final ConcurrentLinkedDeque<JobHandle> POOL = new ConcurrentLinkedDeque<>();

	private static final ThreadLocal<ArrayDeque<JobHandle>> CYCLE_STACK = ThreadLocal.withInitial(ArrayDeque::new);
	private static final ThreadLocal<HashSet<JobHandle>> VISITED = ThreadLocal.withInitial(HashSet::new);

	private final LinkedBlockingDeque<JobHandle> dependants = new LinkedBlockingDeque<>();
	private final AtomicInteger jobState = new AtomicInteger(STATE_NONE);
	private final AtomicInteger refCounter = new AtomicInteger();
	private final AtomicInteger depCount = new AtomicInteger();

	@Getter
	Job item;
	@Getter
	Worker worker;
	@Getter
	boolean highPriority;

	static JobHandle obtain() {
		JobHandle handle = POOL.poll();
		if (handle == null || handle.refCounter.get() > 0) {
			if (handle != null) {
				POOL.add(handle); // Re-add to the end of the pool
			}
			handle = new JobHandle();
		}

		handle.setJobState(STATE_NONE);
		handle.refCounter.lazySet(1);
		handle.dependants.clear();

		// reset AQS state for completion
		handle.setStateAQS(0);

		handle.depCount.lazySet(0);
		handle.highPriority = false;
		handle.item = null;
		handle.worker = null;

		return handle;
	}

	synchronized boolean addDependency(@Nullable JobHandle handle) {
		return handle != null && handle.addDependant(this);
	}

	synchronized boolean addDependant(@Nullable JobHandle handle) {
		if (handle == null)
			return false;

		if (isCompleted() || isReleased()) {
			if (VALIDATE)
				log.debug(
					"Handle [{}] Skipping dependant [{}] due to being in state: [{}]",
					this,
					handle,
					STATE_NAMES[jobState.getAcquire()]
				);
			return false;
		}

		if (wouldCreateCycle(handle, this))
			throw new IllegalStateException("Circular dependency detected: " + this + " depends on " + handle);

		if (VALIDATE)
			log.debug("Handle [{}] added dependant [{}]", this, handle);

		dependants.add(handle);
		handle.depCount.getAndIncrement();

		return true;
	}

	static boolean wouldCreateCycle(JobHandle start, JobHandle target) {
		if (start == target)
			return true;

		if (start.dependants.isEmpty())
			return false;

		ArrayDeque<JobHandle> stack = CYCLE_STACK.get();
		HashSet<JobHandle> visited = VISITED.get();
		try {
			stack.push(start);
			while (!stack.isEmpty()) {
				JobHandle h = stack.pop();
				if (!visited.add(h)) continue;
				if (h == target) return true;
				for (JobHandle dep : h.dependants) stack.push(dep);
			}
		} finally {
			stack.clear();
			visited.clear();
		}

		return false;
	}

	synchronized boolean setRunning(Worker worker) {
		if (isInQueue()) {
			setJobState(STATE_RUNNING);
			this.worker = worker;
			return true;
		}
		return false;
	}

	synchronized void setInQueue() {
		assert isIdle() : "State should be NONE but is " + STATE_NAMES[jobState.getAcquire()];
		setJobState(STATE_QUEUED);
	}

	synchronized void setCompleted() throws InterruptedException {
		if (isCompleted()) return;

		final boolean wasCancelled = isCancelled();
		setJobState(STATE_COMPLETED);

		if (item != null)
			item.done.set(true);

		// Signal completion via AQS
		releaseShared(0); // TODO: This should increment the generation

		if (VALIDATE)
			log.debug("Handle [{}] Completed", this);

		int queuedWork = 0;
		JobHandle dep;
		while ((dep = dependants.pollFirst()) != null) {
			if (wasCancelled) {
				dep.cancel(false);
				continue;
			}

			if (dep.isIdle() && dep.depCount.decrementAndGet() == 0) {
				dep.setInQueue();
				if (VALIDATE)
					log.debug("Handle [{}] Adding: [{}] to queue", this, dep);

				if (dep.isHighPriority()) {
					worker.localWorkQueue.addFirst(dep);
				} else {
					worker.localWorkQueue.addLast(dep);
				}

				queuedWork++;
			}
		}

		if (queuedWork > 1)
			JOB_SYSTEM.signalWorkAvailable(queuedWork - 1);
	}

	private void setJobState(int newState) {
		final int currentState = jobState.getAcquire();
		if (currentState == newState) return;
		if (VALIDATE) log.trace("[{}] {} -> {}", hashCode(), STATE_NAMES[currentState], STATE_NAMES[newState]);
		jobState.lazySet(newState);
	}

	private void setStateAQS(int value) {
		setState(value); // AQS state for completion: 0 = not done, 1 = done
	}

	synchronized void release() {
		if (isReleased()) return;

		if (refCounter.decrementAndGet() > 0)
			return;

		assert item != null : "Double Release, item is already null";
		assert isCompleted() : "Release before setCompleted() has been called?!";
		assert !VALIDATE || !POOL.contains(this) : "POOL already contains this Handle?!";

		if (VALIDATE) log.debug("Releasing [{}] state: [{}]", this, STATE_NAMES[jobState.getAcquire()]);
		setJobState(STATE_NONE);
		item.handle = null;
		item = null;
		worker = null;

		POOL.add(this);
	}

	void cancel(boolean block) throws InterruptedException {
		if (item == null || isCancelled() || isCompleted())
			return;

		int prevState = jobState.getAcquire();
		setJobState(STATE_CANCELLED);

		if (item != null)
			item.wasCancelled.set(true);

		if (VALIDATE) log.debug("Cancelling [{}] state: [{}]", this, STATE_NAMES[prevState]);

		if (prevState == STATE_NONE || (prevState == STATE_QUEUED && JOB_SYSTEM.workQueue.remove(this))) {
			setCompleted();
			return;
		}

		if (prevState == STATE_RUNNING && worker != null && worker.thread != Thread.currentThread())
			worker.thread.interrupt();

		if (block)
			await();
	}

	boolean isReleased() { return isIdle() && refCounter.get() == 0; }
	boolean isIdle() { return jobState.getAcquire() == STATE_NONE; }
	boolean isInQueue() { return jobState.getAcquire() == STATE_QUEUED; }
	boolean isCancelled() { return jobState.getAcquire() == STATE_CANCELLED; }
	boolean isCompleted() { return jobState.getAcquire() == STATE_COMPLETED; }

	void await() throws InterruptedException {
		refCounter.incrementAndGet();

		final boolean isClientThread = JOB_SYSTEM.client != null && JOB_SYSTEM.client.isClientThread();
		try {
			if (!isDone()) {
				if (isClientThread) {
					long start = System.currentTimeMillis();
					int seconds = 0;
					while (!tryAcquireSharedNanos(0, TimeUnit.MILLISECONDS.toNanos(1))) {
						JOB_SYSTEM.processPendingClientCallbacks(false);
						long elapsed = System.currentTimeMillis() - start;
						int newSeconds = (int) (elapsed / 1000);
						if (newSeconds > seconds) {
							if (VALIDATE) {
								log.debug(
									"Waiting on Handle: [{}] state [{}] elapsed: {} secs",
									this,
									STATE_NAMES[jobState.getAcquire()],
									newSeconds
								);
								JOB_SYSTEM.printWorkersState();
							}
							seconds = newSeconds;
						}
						if (elapsed > DEADLOCK_TIMEOUT_SECONDS * 1000) {
							handleDeadlock();
							return;
						}
					}
				} else {
					if (!tryAcquireSharedNanos(0, TimeUnit.SECONDS.toNanos(DEADLOCK_TIMEOUT_SECONDS)))
						handleDeadlock();
				}
			}
		} finally {
			refCounter.decrementAndGet();
		}
	}

	private boolean isDone() {
		return getState() != 0;
	}

	@Override
	protected int tryAcquireShared(int ignored) {
		return isDone() ? 1 : -1;
	}

	@Override
	protected boolean tryReleaseShared(int ignored) {
		setStateAQS(1);
		return true;
	}

	private void handleDeadlock() throws InterruptedException {
		if (!JOB_SYSTEM.active) return;

		log.warn(
			"Deadlock detected on thread: {} whilst waiting {} seconds on handle {} {}, worker {}, shutting down...",
			Thread.currentThread().getName(),
			DEADLOCK_TIMEOUT_SECONDS,
			hashCode(),
			item,
			worker
		);
		log.warn("Thread {} stacktrace:\n{}", Thread.currentThread().getName(), getThreadStackTrace(Thread.currentThread()));
		if (worker != null)
			log.warn("Worker {} stacktrace:\n{}", worker.thread.getName(), getThreadStackTrace(worker.thread));

		JOB_SYSTEM.plugin.stopPlugin();
		if (JOB_SYSTEM.isWorker())
			throw new InterruptedException();
	}

	@Override
	public String toString() {
		return "[" + hashCode() + "] " + (item != null ? item.toString() : "null");
	}
}

package rs117.hd.utils.jobs;

import com.google.inject.Injector;
import java.util.HashMap;
import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.BlockingDeque;
import java.util.concurrent.LinkedBlockingDeque;
import java.util.concurrent.Semaphore;
import javax.inject.Inject;
import javax.inject.Singleton;
import lombok.Getter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.*;
import net.runelite.client.callback.ClientThread;
import rs117.hd.HdPlugin;
import rs117.hd.overlays.FrameTimer;

import static rs117.hd.HdPlugin.PROCESSOR_COUNT;
import static rs117.hd.utils.MathUtils.*;

@Slf4j
@Singleton
public final class JobSystem {
	public static final boolean VALIDATE = false;

	@Inject
	public Injector injector;

	@Inject
	public Client client;

	@Inject
	public ClientThread clientThread;

	@Inject
	public HdPlugin plugin;

	@Inject
	public FrameTimer frametimer;

	@Getter
	boolean active;

	private final int workerCount = max(2, PROCESSOR_COUNT - 1);

	final BlockingDeque<JobHandle> workQueue = new LinkedBlockingDeque<>();
	private final ArrayBlockingQueue<ClientCallbackJob> clientCallbacks = new ArrayBlockingQueue<>(workerCount);

	private final HashMap<Thread, Worker> threadToWorker = new HashMap<>();
	Worker[] workers;
	Semaphore workerSemaphore = new Semaphore(workerCount);

	private boolean clientInvokeScheduled;

	public void initialize() {
		workers = new Worker[workerCount];
		active = true;

		for (int i = 0; i < workerCount; i++) {
			Worker worker = workers[i] = new Worker(this, i);
			worker.thread = new Thread(worker::run);
			worker.thread.setPriority(Thread.NORM_PRIORITY + 1);
			worker.thread.setName("117HD - Worker " + i);
			threadToWorker.put(worker.thread, worker);
		}

		Job.JOB_SYSTEM = this;
		JobHandle.JOB_SYSTEM = this;

		for (int i = 0; i < workerCount; i++)
			workers[i].thread.start();
	}

	public int getInflightWorkerCount() {
		int inflightCount = 0;
		for (int i = 0; i < workerCount; i++) {
			if (workers[i].inflight.get())
				inflightCount++;
		}
		return inflightCount;
	}

	void signalWorkAvailable(int workCount) {
		int availPermits = workerSemaphore.availablePermits();
		if (availPermits >= workCount)
			return;
		workerSemaphore.release(min(workCount, workCount - availPermits));
	}

	public int getWorkQueueSize() {
		return workQueue.size();
	}

	private void cancelAllWork(BlockingDeque<JobHandle> queue) {
		JobHandle handle;
		while ((handle = queue.poll()) != null) {
			try {
				handle.cancel(false);
				handle.setCompleted();
			} catch (InterruptedException e) {
				log.warn("Interrupted while shutting down worker", e);
				throw new RuntimeException(e);
			}
		}
	}

	public void destroy() {
		active = false;
		cancelAllWork(workQueue);

		for (Worker worker : workers) {
			cancelAllWork(worker.localWorkQueue);
			if (worker.handle != null) {
				try {
					worker.handle.cancel(true);
				} catch (InterruptedException e) {
					log.warn("Interrupted while shutting down worker", e);
					throw new RuntimeException(e);
				}
			}
			worker.thread.interrupt();
		}

		int workerShutdownCount = 0;
		for (Worker worker : workers) {
			if (!worker.thread.isAlive()) {
				workerShutdownCount++;
				continue;
			}

			try {
				worker.thread.join(1000);
			} catch (InterruptedException e) {
				log.warn("Interrupted while waiting for worker shutdown", e);
			}

			if (worker.thread.isAlive()) {
				log.warn("Worker {} didn't shutdown within a timely manner", worker.thread.getName());
				worker.printState();
			} else {
				workerShutdownCount++;
			}
		}

		if (workerShutdownCount == workerCount)
			log.debug("All workers shutdown successfully");

		threadToWorker.clear();
		workers = null;
	}

	public boolean isWorker() {
		return threadToWorker.containsKey(Thread.currentThread());
	}

	public boolean hasIdleWorkers() {
		for (Worker worker : workers) {
			if (!worker.inflight.get())
				return true;
		}
		return false;
	}

	public void printWorkersState() {
		log.debug("WorkQueue Size: {}", workQueue.size());
		for (Worker worker : workers)
			worker.printState();
	}

	void queue(Job item, boolean highPriority, Job... dependencies) {
		if (!item.executeAsync) {
			try {
				item.queued.set(true);
				item.onRun();
				item.ranToCompletion.set(true);
			} catch (Throwable ex) {
				if (item.wasCancelled()) {
					log.debug("Encountered an error whilst processing: {}", item.hashCode(), ex);
				} else {
					log.warn("Encountered an error whilst processing: {}", item.hashCode(), ex);
				}
			} finally {
				item.done.set(true);
			}
			return;
		}

		JobHandle newHandle = item.handle = JobHandle.obtain();
		newHandle.highPriority = highPriority;
		newHandle.item = item;

		boolean shouldQueue = true;
		for (Job dep : dependencies) {
			if (dep == null || dep.handle == null) continue;
			if (dep.handle.addDependant(newHandle)) {
				shouldQueue = false;
			}
		}

		item.queued.set(true);
		item.done.set(false);
		item.wasCancelled.set(false);
		item.encounteredError.set(false);
		item.ranToCompletion.set(false);

		if (shouldQueue) {
			newHandle.setInQueue();
			if (VALIDATE) log.debug("Handle [{}] Added to queue (Dep Count: {{}})", newHandle, dependencies);
			if (highPriority) {
				workQueue.addFirst(newHandle);
			} else {
				workQueue.addLast(newHandle);
			}
		}

		signalWorkAvailable(1);
	}

	void invokeClientCallback(boolean immediate, Runnable callback) throws InterruptedException {
		if (client.isClientThread()) {
			callback.run();
			processPendingClientCallbacks(false);
			return;
		}

		final ClientCallbackJob clientCallback = ClientCallbackJob.current();
		clientCallback.callback = callback;
		clientCallback.immediate = immediate;

		clientCallbacks.add(clientCallback);

		if (!clientInvokeScheduled) {
			clientInvokeScheduled = true;
			clientThread.invoke(() -> {
				clientInvokeScheduled = false;
				processPendingClientCallbacks(false);
			});
		}

		try {
			clientCallback.semaphore.acquire();
		} catch (InterruptedException e) {
			clientCallbacks.remove(clientCallback);
			throw new InterruptedException();
		}
	}

	public void processPendingClientCallbacks() {
		processPendingClientCallbacks(true);
	}

	public void processPendingClientCallbacks(boolean immediateOnly) {
		int size = clientCallbacks.size();
		if (size == 0)
			return;

		ClientCallbackJob pair;
		while (size-- > 0 && (pair = clientCallbacks.poll()) != null) {
			if (!pair.immediate && immediateOnly) {
				clientCallbacks.add(pair); // Add it back onto the end
				continue;
			}

			try {
				pair.callback.run();
			} catch (Throwable ex) {
				log.warn("Encountered exception whilst processing client callback", ex);
			} finally {
				pair.semaphore.release();
			}
		}
	}
}

package rs117.hd.utils.jobs;

import java.util.concurrent.BlockingDeque;
import java.util.concurrent.LinkedBlockingDeque;
import java.util.concurrent.atomic.AtomicBoolean;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;

import static rs117.hd.utils.HDUtils.getThreadStackTrace;
import static rs117.hd.utils.MathUtils.*;
import static rs117.hd.utils.jobs.JobSystem.VALIDATE;

@Slf4j
@RequiredArgsConstructor
public final class Worker {
	String name, pausedName;
	Thread thread;
	JobHandle handle;
	int stealTargetIdx = -1;

	final JobSystem jobSystem;
	final int workerIdx;
	final BlockingDeque<JobHandle> localWorkQueue = new LinkedBlockingDeque<>();
	final AtomicBoolean inflight = new AtomicBoolean();

	boolean findNextStealTarget() {
		// Find the best target to steal work from
		int nextVictimIdx = -1;
		int nextVictimWorkCount = -1;
		for (int i = 0; i < jobSystem.workers.length; i++) {
			if (i == workerIdx || !jobSystem.workers[i].inflight.get())
				continue; // Don't query ourselves or a worker that is idle
			int workCount = jobSystem.workers[i].localWorkQueue.size();
			if (workCount > nextVictimWorkCount) {
				nextVictimIdx = i;
				nextVictimWorkCount = workCount;
			}
		}
		stealTargetIdx = nextVictimIdx;
		return nextVictimWorkCount > 0;
	}

	void run() {
		name = thread.getName();
		pausedName = name + " [Paused]";
		while (jobSystem.active) {
			// Check local work queue
			handle = localWorkQueue.poll();

			while (handle == null) {
				if (stealTargetIdx >= 0) {
					final Worker victim = jobSystem.workers[stealTargetIdx];
					int stealCount = max(1, victim.localWorkQueue.size() / jobSystem.workers.length);

					JobHandle stolenHandle;
					while (stealCount-- > 0 && (stolenHandle = victim.localWorkQueue.poll()) != null) {
						if (handle == null) {
							handle = stolenHandle;
						} else {
							if (handle.highPriority)
								localWorkQueue.addFirst(stolenHandle);
							else
								localWorkQueue.addLast(stolenHandle);
						}
					}
				}

				if (handle == null) {
					// Check if any work is in the main queue before attempting to steal again
					handle = jobSystem.workQueue.poll();
				}

				if (handle == null && !findNextStealTarget()) {
					// Wait for a signal that there is work to be had
					try {
						jobSystem.workerSemaphore.acquire();
					} catch (InterruptedException ignored) {
						// Interrupts are used to signal that the worker should shutdown, we'll pick this up and shutdown
						thread.isInterrupted(); // Consume the interrupt to prevent it from cancelling the next job
					}

					if (handle == null) {
						// We've been signaled that there is work to be had, try the main queue again
						handle = jobSystem.workQueue.poll();
					}

					if (handle == null) {
						// No work in the main queue, this must mean it was pushed to a local queue and as such should find it
						findNextStealTarget();
					}
				}

				if (!jobSystem.active) {
					log.debug("Shutdown");
					return;
				}
			}

			try {
				processHandle();
			} catch (InterruptedException ignored) {
				thread.isInterrupted(); // Consume the interrupt to prevent it from cancelling the next job
			}
		}
		log.debug("Shutdown - {}", jobSystem.active);
	}

	void processHandle() throws InterruptedException {
		try {
			workerHandleCancel();

			if (handle.item != null && handle.setRunning(this)) {
				inflight.lazySet(true);
				handle.item.onRun();
				handle.item.ranToCompletion.set(true);
			}
		} catch (InterruptedException e) {
			log.debug("Interrupt Received whilst processing: {}", handle.hashCode());
		} catch (Throwable ex) {
			if (handle.item.wasCancelled()) {
				log.debug("Encountered an error whilst processing: {}", handle.hashCode(), ex);
			} else {
				log.warn("Encountered an error whilst processing: {}", handle.hashCode(), ex);
			}
			handle.item.encounteredError.set(true);
			handle.cancel(false);
		} finally {
			if (handle.item != null && handle.item.wasCancelled.get())
				handle.item.onCancel();
			handle.setCompleted();
			handle.worker = null;
			handle = null;
		}
	}

	void workerHandleCancel() throws InterruptedException {
		if (handle.isCancelled()) {
			if (VALIDATE) log.debug("Handle {} has been cancelled, interrupting to exit execution", handle);
			throw new InterruptedException();
		}
	}

	void printState() {
		log.debug("Worker {} is {}", thread.getName(), handle == null ? "idle" : "running:\n" + getThreadStackTrace(thread));
	}
}

/*
 * Copyright (c) 2022 Abex
 * Copyright 2010 JogAmp Community.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package rs117.hd.utils;

import static rs117.hd.utils.MathUtils.*;

public class Mat4
{
	/**
	 * Utility class for working with column-major 4 x 4 matrices.
	 */

	public static float[] identity()
	{
		return new float[] {
			1, 0, 0, 0,
			0, 1, 0, 0,
			0, 0, 1, 0,
			0, 0, 0, 1,
		};
	}

	public static float[] scale(float sx, float sy, float sz)
	{
		return new float[] {
			sx, 0, 0, 0,
			0, sy, 0, 0,
			0, 0, sz, 0,
			0, 0, 0, 1,
		};
	}

	public static float[] translate(float tx, float ty, float tz)
	{
		return new float[] {
			1, 0, 0, 0,
			0, 1, 0, 0,
			0, 0, 1, 0,
			tx, ty, tz, 1,
		};
	}

	public static float[] rotateX(float rx)
	{
		float s = sin(rx);
		float c = cos(rx);

		return new float[] {
			1, 0, 0, 0,
			0, c, s, 0,
			0, -s, c, 0,
			0, 0, 0, 1,
		};
	}

	public static float[] rotateY(float ry)
	{
		float s = sin(ry);
		float c = cos(ry);

		return new float[] {
			c, 0, -s, 0,
			0, 1, 0, 0,
			s, 0, c, 0,
			0, 0, 0, 1,
		};
	}

	public static float[] perspective(float w, float h, float n) {
		// Flip Y so positive is up, and reverse depth from 1 at the near plane to 0 infinitely far away
		return new float[] {
			2 / w, 0, 0, 0,
			0, -2 / h, 0, 0,
			0, 0, 0, 1,
			0, 0, 2 * n, 0
		};
	}

	/**
	 * Create a perspective projection matrix matching vanilla OSRS projection, with a finite far plane.
	 *
	 * @param w viewport width
	 * @param h viewport height
	 * @param n near plane
	 * @param f far plane
	 * @return 4x4 column-major matrix
	 */
	public static float[] perspective(float w, float h, float n, float f) {
		// Same projection as vanilla, except with slightly more depth precision, and a usable far plane for clipping calculations
		w = 2 / w;
		h = 2 / h;
		float a = (1 + n / f) / (n / f - 1);
		float b = a * n - n;
		float c = -1; // perspective divide by -z
		return new float[]
			{
				w, 0, 0, 0,
				0, h, 0, 0,
				0, 0, a, c,
				0, 0, b, 0
			};
	}

	public static float[] orthographic(float w, float h, float n)
	{
		return new float[] {
			2 / w, 0, 0, 0,
			0, -2 / h, 0, 0,
			0, 0, 2 / n, 0,
			0, 0, 0, 1
		};
	}

	/**
	 * Multiplies matrices a and b, storing the result in matrix a.
	 *
	 * @param a column-major 4x4 matrix
	 * @param b column-major 4x4 matrix
	 */
	@SuppressWarnings("PointlessArithmeticExpression")
	public static void mul(float[] a, float[] b)
	{
		final float b00 = b[0 + 0 * 4];
		final float b10 = b[1 + 0 * 4];
		final float b20 = b[2 + 0 * 4];
		final float b30 = b[3 + 0 * 4];
		final float b01 = b[0 + 1 * 4];
		final float b11 = b[1 + 1 * 4];
		final float b21 = b[2 + 1 * 4];
		final float b31 = b[3 + 1 * 4];
		final float b02 = b[0 + 2 * 4];
		final float b12 = b[1 + 2 * 4];
		final float b22 = b[2 + 2 * 4];
		final float b32 = b[3 + 2 * 4];
		final float b03 = b[0 + 3 * 4];
		final float b13 = b[1 + 3 * 4];
		final float b23 = b[2 + 3 * 4];
		final float b33 = b[3 + 3 * 4];

		float ai0 = a[0 * 4]; // row-0 of a
		float ai1 = a[1 * 4];
		float ai2 = a[2 * 4];
		float ai3 = a[3 * 4];
		a[0 * 4] = ai0 * b00 + ai1 * b10 + ai2 * b20 + ai3 * b30;
		a[1 * 4] = ai0 * b01 + ai1 * b11 + ai2 * b21 + ai3 * b31;
		a[2 * 4] = ai0 * b02 + ai1 * b12 + ai2 * b22 + ai3 * b32;
		a[3 * 4] = ai0 * b03 + ai1 * b13 + ai2 * b23 + ai3 * b33;

		ai0 = a[1 + 0 * 4]; // row-1 of a
		ai1 = a[1 + 1 * 4];
		ai2 = a[1 + 2 * 4];
		ai3 = a[1 + 3 * 4];
		a[1 + 0 * 4] = ai0 * b00 + ai1 * b10 + ai2 * b20 + ai3 * b30;
		a[1 + 1 * 4] = ai0 * b01 + ai1 * b11 + ai2 * b21 + ai3 * b31;
		a[1 + 2 * 4] = ai0 * b02 + ai1 * b12 + ai2 * b22 + ai3 * b32;
		a[1 + 3 * 4] = ai0 * b03 + ai1 * b13 + ai2 * b23 + ai3 * b33;

		ai0 = a[2 + 0 * 4]; // row-2 of a
		ai1 = a[2 + 1 * 4];
		ai2 = a[2 + 2 * 4];
		ai3 = a[2 + 3 * 4];
		a[2 + 0 * 4] = ai0 * b00 + ai1 * b10 + ai2 * b20 + ai3 * b30;
		a[2 + 1 * 4] = ai0 * b01 + ai1 * b11 + ai2 * b21 + ai3 * b31;
		a[2 + 2 * 4] = ai0 * b02 + ai1 * b12 + ai2 * b22 + ai3 * b32;
		a[2 + 3 * 4] = ai0 * b03 + ai1 * b13 + ai2 * b23 + ai3 * b33;

		ai0 = a[3 + 0 * 4]; // row-3 of a
		ai1 = a[3 + 1 * 4];
		ai2 = a[3 + 2 * 4];
		ai3 = a[3 + 3 * 4];
		a[3 + 0 * 4] = ai0 * b00 + ai1 * b10 + ai2 * b20 + ai3 * b30;
		a[3 + 1 * 4] = ai0 * b01 + ai1 * b11 + ai2 * b21 + ai3 * b31;
		a[3 + 2 * 4] = ai0 * b02 + ai1 * b12 + ai2 * b22 + ai3 * b32;
		a[3 + 3 * 4] = ai0 * b03 + ai1 * b13 + ai2 * b23 + ai3 * b33;
	}

	/**
	 * Multiplies a 4x4 matrix with a 4x1 vector, storing the result in the output vector, which may be the same as the input vector.
	 *
	 * @param out  where the result should be stored
	 * @param mat4 4x4 column-major matrix
	 * @param vec4 4x1 vector
	 */
	@SuppressWarnings("PointlessArithmeticExpression")
	public static void mulVec(float[] out, float[] mat4, float[] vec4) {
		float a =
			mat4[0 * 4 + 0] * vec4[0] +
			mat4[1 * 4 + 0] * vec4[1] +
			mat4[2 * 4 + 0] * vec4[2] +
			mat4[3 * 4 + 0] * vec4[3];
		float b =
			mat4[0 * 4 + 1] * vec4[0] +
			mat4[1 * 4 + 1] * vec4[1] +
			mat4[2 * 4 + 1] * vec4[2] +
			mat4[3 * 4 + 1] * vec4[3];
		float c =
			mat4[0 * 4 + 2] * vec4[0] +
			mat4[1 * 4 + 2] * vec4[1] +
			mat4[2 * 4 + 2] * vec4[2] +
			mat4[3 * 4 + 2] * vec4[3];
		float d =
			mat4[0 * 4 + 3] * vec4[0] +
			mat4[1 * 4 + 3] * vec4[1] +
			mat4[2 * 4 + 3] * vec4[2] +
			mat4[3 * 4 + 3] * vec4[3];
		out[0] = a;
		out[1] = b;
		out[2] = c;
		out[3] = d;
	}

	public static float[][] extractFrustumCorners(float[] invViewProj, float[][] corners) {
		int index = 0;

		for (int z = 0; z <= 1; z++) {
			for (int y = 0; y <= 1; y++) {
				for (int x = 0; x <= 1; x++) {
					// Convert from 0/1 to -1/+1 for NDC
					float ndcX = x * 2.0f - 1.0f;
					float ndcY = y * 2.0f - 1.0f;
					float ndcZ = z * 2.0f - 1.0f;

					float[] ndc = new float[] { ndcX, ndcY, ndcZ, 1.0f };
					float[] world = new float[4];

					projectVec(world, invViewProj, ndc);

					// Store world-space XYZ
					corners[index][0] = world[0];
					corners[index][1] = world[1];
					corners[index][2] = world[2];
					index++;
				}
			}
		}

		return corners;
	}

	public static void extractPlanes(float[] mat, float[][] planes) {
		// Each plane is defined as: ax + by + cz + d = 0
		// Extract rows from the matrix (column-major order)
		float m00 = mat[0], m01 = mat[4], m02 = mat[8], m03 = mat[12];
		float m10 = mat[1], m11 = mat[5], m12 = mat[9], m13 = mat[13];
		float m20 = mat[2], m21 = mat[6], m22 = mat[10], m23 = mat[14];
		float m30 = mat[3], m31 = mat[7], m32 = mat[11], m33 = mat[15];

		// Left = row3 + row0
		float[] left = planes[0];
		left[0] = m30 + m00;
		left[1] = m31 + m01;
		left[2] = m32 + m02;
		left[3] = m33 + m03;
		normalizePlane(left, left);

		// Right = row3 - row0
		float[] right = planes[1];
		right[0] = m30 - m00;
		right[1] = m31 - m01;
		right[2] = m32 - m02;
		right[3] = m33 - m03;
		normalizePlane(right, right);

		// Bottom = row3 + row1
		float[] bottom = planes[2];
		bottom[0] = m30 + m10;
		bottom[1] = m31 + m11;
		bottom[2] = m32 + m12;
		bottom[3] = m33 + m13;
		normalizePlane(bottom, bottom);

		// Top = row3 - row1
		float[] top = planes[3];
		top[0] = m30 - m10;
		top[1] = m31 - m11;
		top[2] = m32 - m12;
		top[3] = m33 - m13;
		normalizePlane(top, top);

		// Near = row3 + row2
		float[] near = planes[4];
		near[0] = m30 + m20;
		near[1] = m31 + m21;
		near[2] = m32 + m22;
		near[3] = m33 + m23;
		normalizePlane(near, near);

		// Far = row3 - row2
		float[] far = planes[5];
		far[0] = m30 - m20;
		far[1] = m31 - m21;
		far[2] = m32 - m22;
		far[3] = m33 - m23;
		normalizePlane(far, far);
	}

	/**
	 * Multiplies a 4x4 matrix with a 3x1 vector, storing the result in the output vector, which may be the same as the input vector.
	 * Transforms a 3D position by a 4x4 affine matrix (w = 1.0), ignoring the resulting W component.
	 *
	 * @param out  where the result should be stored
	 * @param mat4 4x4 column-major matrix
	 * @param vec3 3x1 vector
	 */
	@SuppressWarnings("PointlessArithmeticExpression")
	public static void transformVecAffine(float[] out, float[] mat4, float[] vec3) {
		float a =
			mat4[0 * 4 + 0] * vec3[0] +
			mat4[1 * 4 + 0] * vec3[1] +
			mat4[2 * 4 + 0] * vec3[2] +
			mat4[3 * 4 + 0] * 1.0f;
		float b =
			mat4[0 * 4 + 1] * vec3[0] +
			mat4[1 * 4 + 1] * vec3[1] +
			mat4[2 * 4 + 1] * vec3[2] +
			mat4[3 * 4 + 1] * 1.0f;
		float c =
			mat4[0 * 4 + 2] * vec3[0] +
			mat4[1 * 4 + 2] * vec3[1] +
			mat4[2 * 4 + 2] * vec3[2] +
			mat4[3 * 4 + 2] * 1.0f;
		out[0] = a;
		out[1] = b;
		out[2] = c;
	}

	/**
	 * Transforms the vector by the matrix, and does a perspective divide.
	 *
	 * @param out  where the result should be stored
	 * @param mat4 4x4 column-major matrix
	 * @param vec4 4x1 vector
	 */
	public static void projectVec(float[] out, float[] mat4, float[] vec4) {
		mulVec(out, mat4, vec4);
		if (out[3] != 0) {
			// The 4th component should retain information about whether the
			// point lies behind the camera
			float reciprocal = 1 / Math.abs(out[3]);
			for (int i = 0; i < 4; i++)
				out[i] *= reciprocal;
		}
	}

	public static void transpose(float[] m) {
		for (int i = 0; i < 4; i++) {
			for (int j = i + 1; j < 4; j++) {
				int a = i * 4 + j;
				int b = j * 4 + i;
				float temp = m[a];
				m[a] = m[b];
				m[b] = temp;
			}
		}
	}

	public static float[] inverse(float[] m) {
		float[] augmented = slice(m, 0, 32);
		augmented[16] = augmented[21] = augmented[26] = augmented[31] = 1;
		Matrix.solve(augmented, 4, 8);
		return slice(augmented, 16);
	}

	public static void clipFrustumToDistance(float[][] frustumCorners, float maxDistance) {
		if (frustumCorners.length != 8) {
			return;
		}

		// Clip Far Plane Corners
		for (int i = 4; i < frustumCorners.length; i++) {
			float[] nearCorner = frustumCorners[i - 4];
			float[] farCorner = frustumCorners[i];
			float[] nearToFarVec = subtract(nearCorner, farCorner);
			float len = length(nearToFarVec);

			if (len > 1e-5f && len > maxDistance) {
				normalize(nearToFarVec, nearToFarVec);
				float[] clipped = multiply(nearToFarVec, maxDistance);
				frustumCorners[i] = add(clipped, nearCorner);
			}
		}
	}

	public static void extractRow(float[] out, float[] mat4, int rowIndex) {
		System.arraycopy(mat4, 4 * rowIndex, out, 0, out.length);
	}

	public static void extractColumn(float[] out, float[] mat4, int columnIndex) {
		for (int i = 0; i < out.length; i++)
			out[i] = mat4[4 * i + columnIndex];
	}

	public static String format(float[] m) {
		assert m.length == 16;
		return Matrix.format(m, 4, 4);
	}
}

/*
 * Math utility functions.
 * Written in 2025 by Hooder <ahooder@protonmail.com>
 * To the extent possible under law, the author(s) have dedicated all copyright and related and neighboring rights
 * to this software to the public domain worldwide. This software is distributed without any warranty.
 * You should have received a copy of the CC0 Public Domain Dedication along with this software.
 * If not, see <http://creativecommons.org/publicdomain/zero/1.0/>.
 */
package rs117.hd.utils;

import java.util.Arrays;
import java.util.Random;
import javax.annotation.Nullable;

/**
 * Math utility functions similar to GLSL, including vector operations on raw float arrays.
 * Usability and conciseness is prioritized, however most methods at least allow avoiding unnecessary allocations.
 * Wherever it makes sense, inputs of different sizes are allowed, where shorter inputs will be repeated to fill the output vector.
 * When automatically determining the length of the output vector, it will equal the maximum length of the input vectors.
 * Some regular Java math function aliases are included to minimize the need for manual type casting.
 */
public final class MathUtils {
	public static final Random RAND = new Random();

	public static final long KiB = 1024;
	public static final long MiB = KiB * KiB;
	public static final long GiB = MiB * KiB;

	public static final float EPSILON = 1.1920929e-7f; // Float epsilon from JOGL
	public static final float MAX_FLOAT_WITH_128TH_PRECISION = 1 << 16;

	public static final float E = (float) Math.E;

	public static final float PI = (float) Math.PI;
	public static final float TWO_PI = PI * 2;
	public static final float HALF_PI = PI / 2;
	public static final float QUARTER_PI = PI / 4;

	public static final float DEG_TO_RAD = TWO_PI / 360;
	public static final float RAD_TO_DEG = 1 / DEG_TO_RAD;
	public static final float JAU_TO_RAD = TWO_PI / 2048;
	public static final float RAD_TO_JAU = 1 / JAU_TO_RAD;

	public static float[] vec(float... vec) {
		return vec;
	}

	public static float[] vec(int... vec) {
		float[] floats = new float[vec.length];
		for (int i = 0; i < vec.length; i++)
			floats[i] = vec[i];
		return floats;
	}

	public static int[] ivec(int... vec) {
		return vec;
	}

	public static int[] ivec(float... vec) {
		int[] ivec = new int[vec.length];
		for (int i = 0; i < vec.length; i++)
			ivec[i] = (int) vec[i];
		return ivec;
	}

	public static float[] copy(float[] v) {
		return Arrays.copyOf(v, v.length);
	}

	public static int[] copy(int[] v) {
		return Arrays.copyOf(v, v.length);
	}

	public static float[] copyTo(float[] out, @Nullable float[] in, int offset, int len) {
		if (in != null) {
			assert offset + len <= min(out.length, in.length);
			System.arraycopy(in, offset, out, offset, len);
		}
		return out;
	}

	public static float[] copyTo(float[] out, @Nullable float[] in) {
		return copyTo(out, in, 0, in == null ? out.length : min(out.length, in.length));
	}

	public static int[] copyTo(int[] out, @Nullable int[] in, int offset, int len) {
		if (in != null) {
			assert offset + len <= min(out.length, in.length);
			System.arraycopy(in, offset, out, offset, len);
		}
		return out;
	}

	public static int[] copyTo(int[] out, @Nullable int[] in) {
		return copyTo(out, in, 0, in == null ? out.length : min(out.length, in.length));
	}

	public static float[] ensureDefaults(@Nullable float[] in, float[] defaults) {
		return in != null && in.length == defaults.length ? in : copyTo(copy(defaults), in);
	}

	public static int[] ensureDefaults(@Nullable int[] in, int[] defaults) {
		return in != null && in.length == defaults.length ? in : copyTo(copy(defaults), in);
	}

	public static int[] slice(int[] v, int offset) {
		return Arrays.copyOfRange(v, offset, v.length);
	}

	/**
	 * If offset + length surpasses the end of the array, the output will be zero padded.
	 */
	public static int[] slice(int[] v, int offset, int length) {
		assert offset <= v.length;
		return Arrays.copyOfRange(v, offset, offset + length);
	}

	public static float[] slice(float[] v, int offset) {
		return Arrays.copyOfRange(v, offset, v.length);
	}

	/**
	 * If offset + length surpasses the end of the array, the output will be zero padded.
	 */
	public static float[] slice(float[] v, int offset, int length) {
		assert offset <= v.length;
		return Arrays.copyOfRange(v, offset, offset + length);
	}

	public static int[] add(int[] out, int[] a, int... b) {
		for (int i = 0; i < out.length; i++)
			out[i] = a[i % out.length] + b[i % b.length];
		return out;
	}

	public static int[] add(int[] a, int[] b) {
		return add(new int[max(a.length, b.length)], a, b);
	}

	public static float[] add(float[] out, float[] a, float... b) {
		for (int i = 0; i < out.length; i++)
			out[i] = a[i % out.length] + b[i % b.length];
		return out;
	}

	public static float[] add(float[] a, float[] b) {
		return add(new float[max(a.length, b.length)], a, b);
	}

	public static int[] subtract(int[] out, int[] a, int... b) {
		for (int i = 0; i < out.length; i++)
			out[i] = a[i % a.length] - b[i % b.length];
		return out;
	}

	public static int[] subtract(int[] a, int[] b) {
		return subtract(new int[max(a.length, b.length)], a, b);
	}

	public static float[] subtract(float[] out, float[] a, float... b) {
		for (int i = 0; i < out.length; i++)
			out[i] = a[i % a.length] - b[i % b.length];
		return out;
	}

	public static float[] subtract(float[] a, float[] b) {
		return subtract(new float[max(a.length, b.length)], a, b);
	}

	public static float[] multiply(float[] out, float[] a, float... b) {
		for (int i = 0; i < out.length; i++)
			out[i] = a[i % a.length] * b[i % b.length];
		return out;
	}

	public static float[] multiply(float[] a, float... b) {
		return multiply(new float[max(a.length, b.length)], a, b);
	}

	public static float divide(float a, float b) {
		return b == 0 ? 0 : a / b;
	}

	public static float[] divide(float[] out, float[] a, float... b) {
		for (int i = 0; i < out.length; i++) {
			float divisor = b[i % b.length];
			out[i] = a[i % a.length] * (divisor == 0 ? 0 : 1 / divisor);
		}
		return out;
	}

	public static float[] divide(float[] a, float... b) {
		return divide(new float[max(a.length, b.length)], a, b);
	}

	/**
	 * Modulo which returns the answer with the same sign as the modulus.
	 */
	public static float mod(float v, float mod) {
		return v - floor(v / mod) * mod;
	}

	/**
	 * Modulo which returns the answer with the same sign as the modulus.
	 */
	public static int mod(int v, int mod) {
		return Math.floorMod(v, mod);
	}

	/**
	 * Modulo which returns the answer with the same sign as the modulus.
	 */
	public static int mod(long v, int mod) {
		return (int) (v - (v / mod) * mod);
	}

	public static float mod(double v, float mod) {
		return (float) (v - Math.floor(v / mod) * mod);
	}

	public static float[] mod(float[] out, float[] v, float... mod) {
		for (int i = 0; i < out.length; i++)
			out[i] = mod(v[i % v.length], mod[i % mod.length]);
		return out;
	}

	public static float[] mod(float[] v, float... mod) {
		return mod(new float[max(v.length, mod.length)], v, mod);
	}

	public static float pow(float base, float exp) {
		return (float) Math.pow(base, exp);
	}

	public static float[] pow(float[] out, float[] base, float... exp) {
		for (int i = 0; i < out.length; i++)
			out[i] = pow(base[i % base.length], exp[i % exp.length]);
		return out;
	}

	public static float[] pow(float[] in, float... exp) {
		return pow(new float[max(in.length, exp.length)], in, exp);
	}

	public static float pow2(float v) {
		return v * v;
	}

	public static float[] pow2(float[] out, float... v) {
		for (int i = 0; i < out.length; i++) {
			float f = v[i % out.length];
			out[i] = f * f;
		}
		return out;
	}

	public static float[] pow2(float... v) {
		return pow2(new float[v.length], v);
	}

	public static float exp(float v) {
		return (float) Math.exp(v);
	}

	public static float[] exp(float[] out, float... v) {
		for (int i = 0; i < out.length; i++)
			out[i] = exp(v[i % v.length]);
		return out;
	}

	public static float[] exp(float... v) {
		return exp(new float[v.length], v);
	}

	public static float log(float v) {
		return (float) Math.log(v);
	}

	public static float[] log(float[] out, float... v) {
		for (int i = 0; i < out.length; i++)
			out[i] = log(v[i % v.length]);
		return out;
	}

	public static float[] log(float... v) {
		return log(new float[v.length], v);
	}

	public static float log2(float v) {
		return log(v) / log(2);
	}

	public static float[] log2(float[] out, float... v) {
		for (int i = 0; i < out.length; i++)
			out[i] = log2(v[i % v.length]);
		return out;
	}

	public static float[] log2(float... v) {
		return log2(new float[v.length], v);
	}

	public static float sqrt(float v) {
		return (float) Math.sqrt(v);
	}

	public static float[] sqrt(float[] out, float... v) {
		for (int i = 0; i < out.length; i++)
			out[i] = sqrt(v[i % v.length]);
		return out;
	}

	public static float[] sqrt(float... v) {
		return sqrt(new float[v.length], v);
	}

	public static float dot(float[] a, float[] b, int n) {
		assert a.length >= n && b.length >= n;
		float f = 0;
		for (int i = 0; i < n; i++)
			f += a[i] * b[i];
		return f;
	}

	public static float dot(float[] a, float... b) {
		return dot(a, b, min(a.length, b.length));
	}

	public static float dot(float... v) {
		return dot(v, v);
	}

	public static float dot(int[] a, int[] b, int n) {
		assert a.length >= n && b.length >= n;
		float f = 0;
		for (int i = 0; i < n; i++)
			f += a[i] * b[i];
		return f;
	}

	public static float dot(int[] a, int... b) {
		return dot(a, b, min(a.length, b.length));
	}

	public static float dot(int... v) {
		return dot(v, v);
	}

	public static int product(int... v) {
		int product = 1;
		for (int factor : v)
			product *= factor;
		return product;
	}

	public static float product(float... v) {
		float product = 1;
		for (float factor : v)
			product *= factor;
		return product;
	}

	/**
	 * Yields incorrect results if either of the input vectors is used as the output vector.
	 */
	public static int[] cross(int[] out, int[] a, int[] b) {
		out[0] = a[1] * b[2] - a[2] * b[1];
		out[1] = a[2] * b[0] - a[0] * b[2];
		out[2] = a[0] * b[1] - a[1] * b[0];
		return out;
	}

	public static int[] cross(int[] a, int[] b) {
		return cross(new int[3], a, b);
	}

	/**
	 * Yields incorrect results if either of the input vectors is used as the output vector.
	 */
	public static float[] cross(float[] out, float[] a, float[] b) {
		out[0] = a[1] * b[2] - a[2] * b[1];
		out[1] = a[2] * b[0] - a[0] * b[2];
		out[2] = a[0] * b[1] - a[1] * b[0];
		return out;
	}

	public static float[] cross(float[] a, float[] b) {
		return cross(new float[3], a, b);
	}

	public static float length(float... v) {
		return (float) Math.sqrt(dot(v, v));
	}

	public static float distance(float[] a, float[] b, int n) {
		return (float) Math.sqrt(dot(a, a, n) - 2 * dot(a, b, n) + dot(b, b, n));
	}

	public static float distance(float[] a, float[] b) {
		return distance(a, b, min(a.length, b.length));
	}

	public static float[] normalize(float[] out, float... v) {
		return divide(out, v, length(v));
	}

	public static float[] normalize(float... v) {
		return normalize(new float[v.length], v);
	}

	public static float[] normalizePlane(float[] out, float... plane) {
		return divide(out, plane, length(slice(plane, 0, 3)));
	}

	public static float[] normalizePlane(float... plane) {
		return normalizePlane(new float[4], plane);
	}

	public static float distanceToPlane(float[] plane, float[] v) {
		return dot(plane, v, 3) + plane[3];
	}

	public static float abs(float v) {
		return Math.abs(v);
	}

	public static int abs(int v) {
		return Math.abs(v);
	}

	public static long abs(long v) {
		return Math.abs(v);
	}

	public static float[] abs(float[] out, float... v) {
		for (int i = 0; i < out.length; i++)
			out[i] = abs(v[i % v.length]);
		return out;
	}

	public static float[] abs(float[] v) {
		return abs(new float[v.length], v);
	}

	public static int floor(float v) {
		return (int) Math.floor(v);
	}

	public static int[] floor(int[] out, float... v) {
		for (int i = 0; i < out.length; i++)
			out[i] = floor(v[i % v.length]);
		return out;
	}

	public static int[] floor(float[] v) {
		return floor(new int[v.length], v);
	}

	public static int ceil(float v) {
		return (int) Math.ceil(v);
	}

	public static int[] ceil(int[] out, float... v) {
		for (int i = 0; i < out.length; i++)
			out[i] = ceil(v[i % v.length]);
		return out;
	}

	public static int[] ceil(float[] v) {
		return ceil(new int[v.length], v);
	}

	public static int round(float v) {
		return Math.round(v);
	}

	public static long round(double v) {
		return Math.round(v);
	}

	public static int[] round(int[] out, float... v) {
		for (int i = 0; i < out.length; i++)
			out[i] = round(v[i % v.length]);
		return out;
	}

	public static int[] round(float[] v) {
		return round(new int[v.length], v);
	}

	public static float[] roundf(float[] out, float... v) {
		for (int i = 0; i < out.length; i++)
			out[i] = round(v[i % v.length]);
		return out;
	}

	public static float[] roundf(float[] v) {
		return roundf(new float[v.length], v);
	}

	public static float min(float a, float b) {
		return Math.min(a, b);
	}

	public static int min(int a, int b) {
		return Math.min(a, b);
	}

	public static long min(long a, long b) {
		return Math.min(a, b);
	}

	public static float min(float... v) {
		assert v.length > 0;
		var min = v[0];
		for (var x : v)
			min = min(min, x);
		return min;
	}

	public static float[] min(float[] out, float[] a, float... b) {
		for (int i = 0; i < out.length; i++)
			out[i] = min(a[i % a.length], b[i % b.length]);
		return out;
	}

	public static float[] min(float[] a, float... b) {
		return min(new float[max(a.length, b.length)], a, b);
	}

	public static int min(int... v) {
		assert v.length > 0;
		var min = v[0];
		for (var x : v)
			min = min(min, x);
		return min;
	}

	public static int[] min(int[] out, int[] a, int... b) {
		for (int i = 0; i < out.length; i++)
			out[i] = min(a[i % a.length], b[i % b.length]);
		return out;
	}

	public static int[] min(int[] a, int... b) {
		return min(new int[max(a.length, b.length)], a, b);
	}

	public static float max(float a, float b) {
		return Math.max(a, b);
	}

	public static int max(int a, int b) {
		return Math.max(a, b);
	}

	public static long max(long a, long b) {
		return Math.max(a, b);
	}

	public static float max(float... v) {
		assert v.length > 0;
		var max = v[0];
		for (var x : v)
			max = max(max, x);
		return max;
	}

	public static float[] max(float[] out, float[] a, float... b) {
		for (int i = 0; i < out.length; i++)
			out[i] = max(a[i % a.length], b[i % b.length]);
		return out;
	}

	public static float[] max(float[] a, float... b) {
		return max(new float[max(a.length, b.length)], a, b);
	}

	public static int max(int... v) {
		assert v.length > 0;
		var max = v[0];
		for (var x : v)
			max = max(max, x);
		return max;
	}

	public static int[] max(int[] out, int[] a, int... b) {
		for (int i = 0; i < out.length; i++)
			out[i] = max(a[i % a.length], b[i % b.length]);
		return out;
	}

	public static int[] max(int[] a, int... b) {
		return max(new int[max(a.length, b.length)], a, b);
	}

	public static float clamp(float v, float min, float max) {
		return min(max(v, min), max);
	}

	public static float clamp(double v, float min, float max) {
		return clamp((float) v, min, max);
	}

	public static int clamp(int v, int min, int max) {
		return min(max(v, min), max);
	}

	public static float[] clamp(float[] out, float[] v, float[] min, float[] max) {
		for (int i = 0; i < out.length; i++)
			out[i] = clamp(v[i % v.length], min[i % min.length], max[i % max.length]);
		return out;
	}

	public static float[] clamp(float[] out, float[] v, float min, float max) {
		return clamp(out, v, vec(min), vec(max));
	}

	public static float[] clamp(float[] v, float[] min, float[] max) {
		return clamp(new float[max(v.length, min.length, max.length)], v, min, max);
	}

	public static float[] clamp(float[] v, float min, float max) {
		return clamp(new float[v.length], v, vec(min), vec(max));
	}

	public static float saturate(float v) {
		return clamp(v, 0, 1);
	}

	public static float saturate(double v) {
		return saturate((float) v);
	}

	public static float[] saturate(float[] out, float... v) {
		for (int i = 0; i < out.length; i++)
			out[i] = saturate(v[i % v.length]);
		return out;
	}

	public static float[] saturate(float... v) {
		return saturate(new float[v.length], v);
	}

	public static float fract(float v) {
		return mod(v, 1);
	}

	public static float[] fract(float[] out, float... v) {
		for (int i = 0; i < out.length; i++)
			out[i] = fract(v[i % out.length]);
		return out;
	}

	public static float[] fract(float... v) {
		return fract(new float[v.length], v);
	}

	public static float sign(float v) {
		return v < 0 ? -1 : 1;
	}

	public static float[] sign(float[] out, float... v) {
		for (int i = 0; i < out.length; i++)
			out[i] = sign(v[i % out.length]);
		return out;
	}

	public static float[] sign(float... v) {
		return sign(new float[v.length], v);
	}

	public static float mix(float v0, float v1, float factor) {
		return v0 * (1 - factor) + v1 * factor;
	}

	public static float[] mix(float[] out, float[] v0, float[] v1, float... factor) {
		for (int i = 0; i < out.length; i++)
			out[i] = mix(v0[i % v0.length], v1[i % v1.length], factor[i % factor.length]);
		return out;
	}

	public static float[] mix(float[] v0, float[] v1, float... factor) {
		return mix(new float[max(v0.length, v1.length, factor.length)], v0, v1, factor);
	}

	public static float smoothstep(float v0, float v1, float factor) {
		float t = saturate((factor - v0) / (v1 - v0));
		return t * t * (3 - 2 * t);
	}

	public static float[] smoothstep(float[] out, float[] v0, float[] v1, float... factor) {
		for (int i = 0; i < out.length; i++)
			out[i] = smoothstep(v0[i % v0.length], v1[i % v1.length], factor[i % factor.length]);
		return out;
	}

	public static float[] smoothstep(float[] v0, float[] v1, float... factor) {
		return smoothstep(new float[max(v0.length, v1.length, factor.length)], v0, v1, factor);
	}

	public static float sum(float... v) {
		float sum = 0;
		for (float value : v)
			sum += value;
		return sum;
	}

	public static float avg(float... v) {
		return sum(v) / v.length;
	}

	public static float sin(float rad) {
		return (float) Math.sin(rad);
	}

	public static float cos(float rad) {
		return (float) Math.cos(rad);
	}

	public static float tan(float rad) {
		return (float) Math.tan(rad);
	}

	public static int float16(float value) {
		if (value == 0)
			return 0;
		// float32: (-1)^sign * 2^(exponent - 127) * (1.mantissa)
		// float16: (-1)^sign * 2^(exponent -  15) * (1.mantissa)
		int f = Float.floatToRawIntBits(value);
		int sign = (f >>> 16) & 0x8000;
		int exponent = ((f >>> 23) & 0xFF) - 127 + 15;
		int mantissa = f & 0x7FFFFF;

		if (exponent <= 0) { // Too small, subnormal
			if (exponent < -10) // To small to represent, return signed zero
				return sign;
			mantissa |= 0x800000; // Add the leading 1 back in
			mantissa >>= 1 - exponent; // Shift to represent the smaller exponent
			// Round based on the last bit, before shifting it away
			if ((mantissa & 0x1000) != 0)
				mantissa += 0x2000;
			return sign | mantissa >> 13;
		}

		if (exponent >= 0x1F) { // Too large to represent
			if (mantissa == 0)
				return sign | 0x7C00; // Infinity
			return 0x7E00; // NaN
		}

		// Round based on the last bit, before shifting it away
		if ((mantissa & 0x1000) != 0) {
			// Round to nearest even
			mantissa += 0x2000;
			// If rounding up caused the mantissa to overflow, increment the exponent
			if ((mantissa & 0x800000) != 0) {
				mantissa = 0;
				exponent += 1;
				if (exponent >= 0x1F) // Return infinity if it's too large to represent again
					return sign | 0x7C00; // Infinity
				return sign | exponent << 10;
			}
		}

		return sign | exponent << 10 | mantissa >> 13;
	}
}

/*
 * Matrix utility functions.
 * Written in 2024 by Hooder <ahooder@protonmail.com>
 * To the extent possible under law, the author(s) have dedicated all copyright and related and neighboring rights
 * to this software to the public domain worldwide. This software is distributed without any warranty.
 * You should have received a copy of the CC0 Public Domain Dedication along with this software.
 * If not, see <http://creativecommons.org/publicdomain/zero/1.0/>.
 */
package rs117.hd.utils;

import java.text.DecimalFormat;
import java.util.Arrays;

import static rs117.hd.utils.MathUtils.*;

public class Matrix {
	private static final float EPS = 1e-6f;

	/**
	 * Utility class for working with column-major m x n matrices.
	 */

	public static float[] copy(float[] m) {
		return Arrays.copyOf(m, m.length);
	}

	public static void solve(float[] m, int rows, int columns) {
		int square = min(columns, rows);
		columns:
		for (int j = 0; j < square; j++) {
			for (int i = j; i < rows; i++) {
				var f = m[j * rows + i];
				if (abs(f) < EPS)
					continue;

				// Swap the row into the right position
				if (i != j) {
					for (int k = 0; k < rows * columns; k += rows) {
						var tmp = m[k + j];
						m[k + j] = m[k + i];
						m[k + i] = tmp;
					}
				}

				// Divide by the first entry of the row
				if (abs(f - 1) > EPS) {
					f = 1 / f;
					for (int k = 0; k < rows * columns; k += rows)
						m[k + j] *= f;
				}

				// Reduce other rows
				for (int r = 0; r < rows; r++) {
					if (r == j)
						continue;
					var g = m[j * rows + r];
					if (abs(g) > EPS)
						for (int k = 0; k < rows * columns; k += rows)
							m[k + r] -= g * m[k + j];
				}

				continue columns;
			}

			throw new IllegalArgumentException("Linear system does not have a solution");
		}
	}

	public static String format(float[] m, int rows, int columns) {
		String[] f = new String[m.length];
		var format = new DecimalFormat("0.##");
		int maxdigits = 0;
		int maxfractions = 0;
		for (int i = 0; i < rows * columns; i++) {
			float v = m[i];
			if (abs(v) < .01)
				v = 0;
			f[i] = format.format(v);
			var j = f[i].indexOf('.');
			if (j == -1) {
				maxdigits = max(maxdigits, f[i].length());
			} else {
				maxdigits = max(maxdigits, j);
				maxfractions = max(maxfractions, f[i].length() - j);
			}
		}

		StringBuilder str = new StringBuilder();

		for (int row = 0; row < rows; row++) {
			for (int col = 0; col < columns; col++) {
				int idx = col * rows + row;
				int dot = f[idx].indexOf('.');
				if (dot == -1) {
					int padLeft = maxdigits - f[idx].length();
					if (padLeft > 0)
						f[idx] = " ".repeat(padLeft) + f[idx];
					f[idx] += " ".repeat(maxfractions);
				} else {
					int padLeft = maxdigits - dot;
					if (padLeft > 0)
						f[idx] = " ".repeat(padLeft) + f[idx];
					int padRight = maxfractions - (f[idx].length() - dot);
					if (padRight > 0)
						f[idx] += " ".repeat(padRight);
				}

				if (col == 0)
					str.append("[ ");
				str.append(f[idx]).append(" ");
				if (col == columns - 1) {
					str.append("]");
					if (idx != m.length - 1)
						str.append("\n");
				}
			}
		}

		return str.toString();
	}
}

package rs117.hd.utils;

import javax.annotation.Nullable;
import net.runelite.api.*;

import static rs117.hd.utils.MathUtils.*;

public class ModelHash {
	// Model hashes are composed as follows:
	// | 12-bit worldView | 32-bit id or index | 1-bit wall | 3-bit type | 2-bit plane | 7-bit sceneY | 7-bit sceneX |
	//
	// type:
	// - 0 = player
	// - 1 = NPC
	// - 2 = object
	// - 3 = ground item
	//
	// id_or_index for different types:
	// - player = index
	// - NPC = index
	// - object = id
	// - ground item = always zero

	public static final int TYPE_PLAYER = 0;
	public static final int TYPE_NPC = 1;
	public static final int TYPE_OBJECT = 2;
	public static final int TYPE_GROUND_ITEM = 3;

	// 117 HD UUID types
	public static final int TYPE_PROJECTILE = 4;
	public static final int TYPE_GRAPHICS_OBJECT = 5;
	public static final int TYPE_UNKNOWN = 0xF;

	// 117 HD UUID sub object types
	public static final int TYPE_WALL_OBJECT = 1 << 4 | TYPE_OBJECT;
	public static final int TYPE_GROUND_OBJECT = 2 << 4 | TYPE_OBJECT;
	public static final int TYPE_DECORATIVE_OBJECT = 3 << 4 | TYPE_OBJECT;
	public static final int TYPE_GAME_OBJECT = 4 << 4 | TYPE_OBJECT;

	public static final int UNKNOWN_ID = 0xFFFFFF;

	private static final String[] TYPE_NAMES = {
		"Player",
		"NPC",
		"Game Object",
		"Ground item",
		"Projectile",
		"Graphics object",
		"Unknown"
	};
	private static final String[] TYPE_NAMES_SHORT = {
		"PLR",
		"NPC",
		"OBJ",
		"ITM",
		"PRJ",
		"GFX",
		"N/A"
	};

	public static String getTypeName(int type) {
		return TYPE_NAMES[clamp(type, 0, TYPE_NAMES.length - 1)];
	}

	public static String getTypeNameShort(int type) {
		return TYPE_NAMES_SHORT[clamp(type, 0, TYPE_NAMES_SHORT.length - 1)];
	}

	public static int getSceneX(long hash) {
		return (int) (hash & 0x7f);
	}

	public static int getSceneY(long hash) {
		return (int) (hash >> 7 & 0x7f);
	}

	public static int getPlane(long hash) {
		return (int) (hash >> TileObject.HASH_PLANE_SHIFT & 3);
	}

	public static int getType(long hash) {
		return (int) (hash >> 16 & 7);
	}

	public static int getIdOrIndex(long hash) {
		return (int) (hash >> 20);
	}

	public static boolean isTemporaryObject(long hash) {
		return getIdOrIndex(hash) == 0xFFFFFFFF;
	}

	/**
	 * Generate an identifier of a Renderable, consisting of the type and ID.
	 *
	 * @param client     RuneLite client instance
	 * @param hash       RuneLite draw call hash
	 * @param renderable the Renderable passed into the draw callback
	 * @return a combined identifier
	 */
	public static int generateUuid(Client client, long hash, @Nullable Renderable renderable) {
		int type = TYPE_UNKNOWN;
		int id = UNKNOWN_ID;

		if (hash == -1) {
			if (renderable instanceof Projectile) {
				type = TYPE_PROJECTILE;
				id = ((Projectile) renderable).getId();
			} else if (renderable instanceof GraphicsObject) {
				type = TYPE_GRAPHICS_OBJECT;
				id = ((GraphicsObject) renderable).getId();
			}
		} else {
			type = ModelHash.getType(hash);
			id = ModelHash.getIdOrIndex(hash);

			if (renderable instanceof DynamicObject) {
				var def = client.getObjectDefinition(id);
				if (def.getImpostorIds() != null) {
					var impostor = def.getImpostor();
					if (impostor != null)
						id = impostor.getId();
				}
			} else if (type == TYPE_NPC) {
				int index = id;
				id = UNKNOWN_ID;
				var npcs = client.getTopLevelWorldView().npcs();
				if (index >= 0 && index < 65536) {
					NPC npc = npcs.byIndex(index);
					if (npc != null)
						id = npc.getId();
				}
			}
		}

		return packUuid(type, id);
	}

	/**
	 * Pack a type ID and object/NPC/projectile/other ID into an int for use with 117 HD functions.
	 *
	 * @param type ModelHash type ID
	 * @param id   object/NPC/projectile/other ID
	 * @return a combined identifier
	 */
	public static int packUuid(int type, int id) {
		return type << 24 | id;
	}

	public static int getUuidType(int uuid) {
		return uuid >> 24 & 0xF;
	}

	public static int getUuidSubType(int uuid) {
		return uuid >> 24;
	}

	public static int getUuidWithoutSubType(int uuid) {
		return uuid & ~0xF0000000;
	}

	public static int getUuidId(int uuid) {
		return uuid & 0xFFFFFF;
	}
}

package rs117.hd.utils;

import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Set;
import javax.inject.Inject;
import javax.inject.Singleton;
import net.runelite.api.*;
import rs117.hd.scene.GamevalManager;

@Singleton
public class NpcDisplacementCache {
	private static final int MAX_SIZE = 100;
	private static final Set<String> ANIM_IGNORE_LIST = Set.of("HOVER", "FLY", "IMPLING", "SWAN", "DUCK", "SWIM");

	@Inject
	private GamevalManager gamevalManager;

	public static class Entry {
		public boolean canDisplace;
		public int idleRadius;
		public long lastAccessMs;

		{
			reset();
		}

		public Entry reset() {
			canDisplace = true;
			idleRadius = -1;
			lastAccessMs = 0;
			return this;
		}
	}

	private final HashMap<Integer, Entry> cache = new HashMap<>(MAX_SIZE);
	private Set<Integer> ANIM_ID_IGNORE_LIST = Collections.emptySet();

	public void initialize() {
		HashSet<Integer> idsToIgnore = new HashSet<>();
		for (var substringToIgnore : ANIM_IGNORE_LIST)
			for (var entry : gamevalManager.getAnims().entrySet())
				if (entry.getKey().contains(substringToIgnore))
					idsToIgnore.add(entry.getValue());
		ANIM_ID_IGNORE_LIST = Set.copyOf(idsToIgnore);
	}

	public void destroy() {
		ANIM_ID_IGNORE_LIST = Collections.emptySet();
		cache.clear();
	}

	public int size() {
		return cache.size();
	}

	public void clear() {
		cache.clear();
	}

	public Entry get(NPC npc) {
		int npcId = npc.getId();
		var entry = cache.get(npcId);

		if (entry == null) {
			if (cache.size() >= NpcDisplacementCache.MAX_SIZE) {
				long oldestMs = Long.MAX_VALUE;
				int oldestNpcId = -1;
				for (var e : cache.entrySet())
					if (e.getValue().lastAccessMs < oldestMs)
						oldestNpcId = e.getKey();
				entry = cache.remove(oldestNpcId).reset();
			} else {
				entry = new NpcDisplacementCache.Entry();
			}
			cache.put(npcId, entry);

			// Check if NPC is allowed to displace
			int animId = npc.getWalkAnimation();
			entry.canDisplace = animId == -1 || !ANIM_ID_IGNORE_LIST.contains(animId);
		}

		entry.lastAccessMs = System.currentTimeMillis();
		return entry;
	}
}

package rs117.hd.utils;

import java.awt.BorderLayout;
import java.awt.Desktop;
import java.awt.FlowLayout;
import java.awt.Image;
import java.awt.Point;
import java.awt.image.BufferedImage;
import java.io.IOException;
import java.net.URISyntaxException;
import java.util.function.Function;
import javax.swing.BorderFactory;
import javax.swing.ImageIcon;
import javax.swing.JButton;
import javax.swing.JEditorPane;
import javax.swing.JFrame;
import javax.swing.JLabel;
import javax.swing.JPanel;
import javax.swing.JScrollPane;
import javax.swing.ScrollPaneConstants;
import javax.swing.SwingUtilities;
import javax.swing.event.HyperlinkEvent;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.*;
import rs117.hd.HdPlugin;

import static rs117.hd.utils.ResourcePath.path;

@Slf4j
public class PopupUtils {
	public static void displayPopupMessage(
		Client client,
		String title,
		String message,
		String[] buttonLabels,
		Function<Integer, Boolean> buttonIndexConsumer
	) {
		SwingUtilities.invokeLater(() -> {
			JFrame frame = new JFrame(title);

			JPanel mainPanel = new JPanel(new BorderLayout());
			mainPanel.setBorder(BorderFactory.createEmptyBorder(16, 0, 8, 8));

			try {
				BufferedImage logoImage = path(HdPlugin.class, "logo.png").loadImage();
				frame.setIconImage(logoImage);
				Image logoScaled = logoImage.getScaledInstance(96, -1, Image.SCALE_SMOOTH);
				JLabel logoLabel = new JLabel(new ImageIcon(logoScaled));
				logoLabel.setBorder(BorderFactory.createEmptyBorder(0, 8, 0, 8));
				mainPanel.add(logoLabel, BorderLayout.LINE_START);
			} catch (IOException ex) {
				log.error("Unable to load HD logo: ", ex);
			}

			String html = String.format("<html><style>a { color: #dc8a00; }</style><body>%s</body></html>", message);
			JEditorPane messagePane = new JEditorPane("text/html", html);
			messagePane.setBorder(BorderFactory.createEmptyBorder());
			messagePane.setHighlighter(null);
			messagePane.setEditable(false);
			messagePane.setOpaque(false);
			messagePane.addHyperlinkListener(e -> {
				if (Desktop.isDesktopSupported() && e.getEventType().equals(HyperlinkEvent.EventType.ACTIVATED)) {
					try {
						Desktop.getDesktop().browse(e.getURL().toURI());
					} catch (IOException | URISyntaxException ex) {
						log.error("Unable to open link: {}", e.getURL().toString(), ex);
					}
                }
            });

			JScrollPane scrollPane = new JScrollPane(messagePane);
            scrollPane.setViewportBorder(BorderFactory.createEmptyBorder());
            scrollPane.setBorder(BorderFactory.createEmptyBorder());
			scrollPane.setOpaque(false);
			scrollPane.getViewport().setOpaque(false);
			scrollPane.setVerticalScrollBarPolicy(ScrollPaneConstants.VERTICAL_SCROLLBAR_AS_NEEDED);
			scrollPane.setHorizontalScrollBarPolicy(ScrollPaneConstants.HORIZONTAL_SCROLLBAR_NEVER);
			mainPanel.add(scrollPane, BorderLayout.CENTER);

            JPanel buttonPanel = new JPanel(new FlowLayout(FlowLayout.RIGHT, 8, 8));
            for (int i = 0; i < buttonLabels.length; i++) {
                JButton button = new JButton(buttonLabels[i]);
                int index = i;
				button.addActionListener(actionEvent -> {
					if (buttonIndexConsumer.apply(index))
						frame.setVisible(false);
				});
				buttonPanel.add(button);
            }

            JPanel framePanel = new JPanel(new BorderLayout());
            framePanel.add(mainPanel, BorderLayout.CENTER);
            framePanel.add(buttonPanel, BorderLayout.PAGE_END);

            frame.setContentPane(framePanel);
            frame.pack();
            frame.setResizable(false);

            frame.setLocationRelativeTo(client.getCanvas());
            Point point = frame.getLocation();
            frame.setLocation(point.x + 5, point.y + (Constants.GAME_FIXED_HEIGHT - client.getCanvasHeight()) / 2 - 3);
            frame.setAutoRequestFocus(true);

            JFrame runeLiteWindow = (JFrame) SwingUtilities.getWindowAncestor(client.getCanvas());
            if (runeLiteWindow.isAlwaysOnTop())
                frame.setAlwaysOnTop(true);

            frame.setVisible(true);
        });
    }
}

package rs117.hd.utils;

import java.util.Properties;
import java.util.function.Supplier;
import javax.annotation.Nonnull;
import javax.annotation.meta.When;

import static rs117.hd.utils.ResourcePath.path;

public class Props
{
	public static boolean DEVELOPMENT;

	private static final Properties env = new Properties();

	static {
		env.putAll(System.getProperties());
	}

	public static boolean has(String key)
	{
		return env.containsKey(key);
	}

	public static String get(String key)
	{
		return env.getProperty(key);
	}

	public static String getOrDefault(String key, String defaultValue)
	{
		String value = get(key);
		return value == null ? defaultValue : value;
	}

	public static String getOrDefault(String key, @Nonnull Supplier<String> defaultValueSupplier)
	{
		String value = get(key);
		return value == null ? defaultValueSupplier.get() : value;
	}

	public static boolean getBoolean(String key)
	{
		String value = get(key);
		if (value == null)
			return false;
		if (value.isEmpty())
			return true;
		value = value.toLowerCase();
		return value.equals("true") || value.equals("1") || value.equals("on") || value.equals("yes");
	}

	public static ResourcePath getFile(String key, @Nonnull Supplier<ResourcePath> fallback) {
		var path = get(key);
		return path != null ? path(path) : fallback.get();
	}

	@Nonnull(when = When.UNKNOWN) // Disable downstream null warnings, since they're not smart enough
	public static ResourcePath getFolder(String key, @Nonnull Supplier<ResourcePath> fallback) {
		var path = getFile(key, fallback);
		return path != null ? path.chroot() : null;
	}

	public static void set(String key, boolean value)
	{
		set(key, value ? "true" : "false");
	}

	public static void set(String key, String value)
	{
		if (value == null)
		{
			unset(key);
		}
		else
		{
			env.put(key, value);
		}
	}

	public static void unset(String key)
	{
		env.remove(key);
	}
}

package rs117.hd.utils;

import java.util.ArrayList;
import java.util.List;
import java.util.function.Supplier;
import rs117.hd.opengl.GLState;
import rs117.hd.opengl.shader.ShaderProgram;

import static org.lwjgl.opengl.GL33C.*;
import static org.lwjgl.opengl.GL40.GL_DRAW_INDIRECT_BUFFER;

public final class RenderState {
	private final List<GLState<RenderState>> states = new ArrayList<>();

	public final GLBindFramebuffer framebuffer = addState(GLBindFramebuffer::new);
	public final GLFramebufferTextureLayer framebufferTextureLayer = addState(GLFramebufferTextureLayer::new);
	public final GLDrawBuffer drawBuffer = addState(GLDrawBuffer::new);
	public final GLShaderProgram program = addState(GLShaderProgram::new);
	public final GLViewport viewport = addState(GLViewport::new);
	public final GLBindVAO vao = addState(GLBindVAO::new);
	public final GLBindEBO ebo = addState(GLBindEBO::new);
	public final GLBindIDO ido = addState(GLBindIDO::new);
	public final GLBindUBO ubo = addState(GLBindUBO::new);
	public final GLDepthMask depthMask = addState(GLDepthMask::new);
	public final GLDepthFunc depthFunc = addState(GLDepthFunc::new);
	public final GLColorMask colorMask = addState(GLColorMask::new);
	public final GLBlendFunc blendFunc = addState(GLBlendFunc::new);
	public final GLEnable enable = addState(GLEnable::new);
	public final GLDisable disable = addState(GLDisable::new);

	public void apply() {
		for (GLState<RenderState> state : states)
			state.apply();
	}

	public void reset() {
		for (GLState<RenderState> state : states)
			state.reset();
	}

	private <T extends GLState<RenderState>> T addState(Supplier<T> supplier) {
		T state = supplier.get();
		state.owner = this;
		states.add(state);
		return state;
	}

	public static final class GLBindFramebuffer extends GLState.PrimitiveArrayState<RenderState, Integer> {
		private GLBindFramebuffer() {
			super(() -> new Integer[2]);
		}

		@Override
		protected void applyValues(Integer[] values) { glBindFramebuffer(values[0], values[1]); }
	}

	public static final class GLFramebufferTextureLayer extends GLState.PrimitiveArrayState<RenderState, Integer> {
		private GLFramebufferTextureLayer() {
			super(() -> new Integer[5]);
		}

		@Override
		protected void applyValues(Integer[] values) {
			glFramebufferTextureLayer(values[0], values[1], values[2], values[3], values[4]);
		}
	}

	public static final class GLViewport extends GLState.PrimitiveArrayState<RenderState, Integer> {
		private GLViewport() {
			super(() -> new Integer[4]);
		}

		@Override
		protected void applyValues(Integer[] values) { glViewport(values[0], values[1], values[2], values[3]); }
	}

	public static final class GLShaderProgram extends GLState.SingleState<RenderState, ShaderProgram> {
		@Override
		protected void applyValue(ShaderProgram program) { program.use(); }
	}

	public static final class GLDrawBuffer extends GLState.SingleState<RenderState, Integer> {
		@Override
		protected void applyValue(Integer buf) { glDrawBuffer(buf); }
	}

	public static final class GLBindVAO extends GLState.SingleState<RenderState, Integer> {
		@Override
		protected void applyValue(Integer vao) { glBindVertexArray(vao); }
	}

	public static final class GLBindEBO extends GLState.SingleState<RenderState, Integer> {
		@Override
		protected void applyValue(Integer ebo) { glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, ebo); }
	}

	public static final class GLBindIDO extends GLState.SingleState<RenderState, Integer> {
		@Override
		protected void applyValue(Integer ebo) { glBindBuffer(GL_DRAW_INDIRECT_BUFFER, ebo); }
	}

	public static final class GLBindUBO extends GLState.SingleState<RenderState, Integer> {
		@Override
		protected void applyValue(Integer ubo) { glBindBuffer(GL_UNIFORM_BUFFER, ubo); }
	}

	public static final class GLDepthMask extends GLState.SingleState<RenderState, Boolean> {
		@Override
		protected void applyValue(Boolean enabled) { glDepthMask(enabled); }
	}

	public static final class GLDepthFunc extends GLState.SingleState<RenderState, Integer> {
		@Override
		protected void applyValue(Integer func) { glDepthFunc(func); }
	}

	public static final class GLBlendFunc extends GLState.PrimitiveArrayState<RenderState, Integer> {
		private GLBlendFunc() {
			super(() -> new Integer[4]);
		}

		@Override
		protected void applyValues(Integer[] values) { glBlendFuncSeparate(values[0], values[1], values[2], values[3]); }
	}

	public static final class GLColorMask extends GLState.PrimitiveArrayState<RenderState, Boolean> {
		private GLColorMask() {
			super(() -> new Boolean[4]);
		}

		@Override
		protected void applyValues(Boolean[] values) { glColorMask(values[0], values[1], values[2], values[3]); }
	}

	public static final class GLEnable extends GLState.GLFlagSetState<RenderState> {
		@Override
		protected void applyTarget(int target) { glEnable(target); }

		public void set(int target) {
			add(target);
			owner.disable.remove(target);
		}
	}

	public static final class GLDisable extends GLState.GLFlagSetState<RenderState> {
		@Override
		protected void applyTarget(int target) { glDisable(target); }

		public void set(int target) {
			add(target);
			owner.enable.remove(target);
		}
	}
}

/*
 * Copyright (c) 2025, Hooder <ahooder@protonmail.com>
 * Copyright (c) 2022, Mark <https://github.com/Mark7625>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package rs117.hd.utils;

import com.google.gson.Gson;
import java.awt.Toolkit;
import java.awt.image.BufferedImage;
import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.OutputStream;
import java.io.OutputStreamWriter;
import java.net.URL;
import java.nio.ByteBuffer;
import java.nio.channels.Channels;
import java.nio.channels.ReadableByteChannel;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.Arrays;
import java.util.Objects;
import java.util.Stack;
import java.util.function.BiConsumer;
import java.util.function.BiFunction;
import java.util.function.Consumer;
import java.util.function.Function;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.stream.Collectors;
import javax.annotation.Nonnull;
import javax.annotation.Nullable;
import javax.annotation.RegEx;
import javax.swing.ImageIcon;
import lombok.extern.slf4j.Slf4j;
import org.lwjgl.BufferUtils;
import org.lwjgl.system.MemoryUtil;
import org.lwjgl.system.Platform;

@Slf4j
public class ResourcePath {
	private static final FileWatcher.UnregisterCallback NOOP = () -> {};
	private static final ResourcePath RESOURCE_PATH = Props.getFolder("rlhd.resource-path", () -> null);

	@Nullable
	public final ResourcePath root;
	@Nullable
	public final String path;

	public static ResourcePath path(String... parts) {
		return new ResourcePath(parts);
	}

	public static ResourcePath path(Path path, String... parts) {
		return path(normalize(path.toString(), parts));
	}

	public static ResourcePath path(File file, String... parts) {
		return path(normalize(file.getPath(), parts));
	}

	public static ResourcePath path(Class<?> clazz, String... parts) {
		String path = normalize(clazz.getPackage().getName().replace(".", "/"), parts);
		return path(clazz.getClassLoader(), path);
	}

	public static ResourcePath path(ClassLoader root, String... parts) {
		// Redirect class resources to the specified resource path during development
		if (RESOURCE_PATH != null)
			return RESOURCE_PATH.resolve(parts);

		return new ClassResourcePath(root).resolve(parts);
	}

	private ResourcePath(String... parts) {
		this(null, parts);
	}

	private ResourcePath(@Nonnull ResourcePath root) {
		// Encapsulate the current root and path into a new root ResourcePath.
		// Subsequent path resolutions will not include the encapsulated path.
		this.root = root;
		this.path = null;
	}

	private ResourcePath(@Nullable ResourcePath root, String... parts) {
		this.root = root;
		this.path = normalize(parts);
	}

	public ResourcePath chroot() {
		return new ResourcePath(this);
	}

	public ResourcePath resolve(String... parts) {
		return new ResourcePath(root, normalize(path, parts));
	}

	@SuppressWarnings("ResultOfMethodCallIgnored")
	public ResourcePath mkdirs() {
		var path = this;
		// Assume paths with an extension are file paths, not directories
		if (!getExtension().isEmpty())
			path = path.resolve("..");
		path.toFile().mkdirs();
		return this;
	}

	public boolean exists() {
		if (root != null)
			return root.resolve(path).exists();
		return toFile().exists();
	}

	public String getFilename() {
		if (path == null)
			return "";
		int i = path.lastIndexOf("/");
		if (i != -1)
			return path.substring(i + 1);
		return path;
	}

	public String getExtension() {
		return getExtension(0);
	}

	public String getExtension(int nthLast) {
		String filename = getFilename();
		String extension = "";
		while (nthLast-- >= 0) {
			int i = filename.lastIndexOf('.');
			if (i == -1)
				break;
			extension = filename.substring(i + 1);
			filename = filename.substring(0, i);
		}
		return extension;
	}

	public ResourcePath setExtension(String extension) {
		if (path == null)
			throw new IllegalStateException("Cannot set extension for root path: " + this);

		String path = this.path;
		int i = path.lastIndexOf('.');
		if (i != -1)
			path = path.substring(0, i);

		if (extension != null && !extension.isEmpty())
			path += '.' + extension;

		return new ResourcePath(root, path);
	}

	public boolean matches(@RegEx String posixPathRegex) {
		Pattern p = Pattern.compile(posixPathRegex);
		Matcher m = p.matcher(toPosixPath());
		return m.find();
	}

	@Override
	public String toString() {
		String path = toPosixPath();
		return path.isEmpty() ? "." : path;
	}

	@Override
	public boolean equals(Object obj) {
		// Used for file watcher event deduplication
		return obj instanceof ResourcePath &&
			   Objects.equals(root, ((ResourcePath) obj).root) &&
			   Objects.equals(path, ((ResourcePath) obj).path);
	}

	public String toPosixPath() {
		if (root != null)
			return normalize(root.toPosixPath(), new String[] { path });
		return path;
	}

	public Path toPath() {
		if (root == null) {
			assert path != null;
			return Paths.get(path);
		}

		Path basePath = root.toPath();
		if (path == null)
			return basePath;

		return basePath.resolve(stripLeadingSlash(path));
	}

	public File toFile() {
		if (isFileSystemResource())
			return toPath().toFile();
		throw new IllegalStateException("Not a file: " + this);
	}

	public BufferedReader toReader() throws IOException {
		return new BufferedReader(new InputStreamReader(toInputStream(), StandardCharsets.UTF_8));
	}

	public InputStream toInputStream() throws IOException {
		if (root != null)
			return root.resolve(path).toInputStream();

		try {
			return Files.newInputStream(toPath());
		} catch (IOException ex) {
			throw new IOException("Unable to load resource: " + this, ex);
		}
	}

	public BufferedWriter toWriter() throws IOException {
		return new BufferedWriter(new OutputStreamWriter(toOutputStream(), StandardCharsets.UTF_8));
	}

	public FileOutputStream toOutputStream() throws FileNotFoundException {
		return new FileOutputStream(toFile());
	}

	public boolean isFileSystemResource() {
		if (root != null)
			return root.isFileSystemResource();
		return true;
	}

	/**
	 * Run the callback once at the start & every time the resource (or sub resource) changes.
	 *
	 * @param changeHandler Callback to call once at the start (bool = true) and every time the resource changes (bool = false)
	 * @return A runnable that can be called to unregister the watch callback
	 */
	public FileWatcher.UnregisterCallback watch(BiConsumer<ResourcePath, Boolean> changeHandler) {
		var path = this;

		// Load once up front
		changeHandler.accept(path, true);

		// Watch for changes if the resource is on the file system, which will exclude paths pointing into the JAR.
		// By default, unless paths are overridden by VM arguments, all of 117 HD's paths point into the JAR.
		if (path.isFileSystemResource())
			return FileWatcher.watchPath(path, p -> changeHandler.accept(p, false));

		return NOOP;
	}

	public FileWatcher.UnregisterCallback watch(Consumer<ResourcePath> changeHandler) {
		return watch((path, first) -> changeHandler.accept(path));
	}

	/**
	 * Run the callback once at the start & every time the resource (or sub resource) changes.
	 *
	 * @param changeHandler Callback to call once at the start and every time the resource changes
	 * @return A runnable that can be called to unregister the watch callback
	 */
	public FileWatcher.UnregisterCallback watch(@RegEx String filter, BiConsumer<ResourcePath, Boolean> changeHandler) {
		return watch((path, first) -> {
			if (path.matches(filter))
				changeHandler.accept(path, first);
		});
	}

	public FileWatcher.UnregisterCallback watch(@RegEx String filter, Consumer<ResourcePath> changeHandler) {
		return watch(filter, (path, first) -> changeHandler.accept(path));
	}

	public String loadString() throws IOException {
		try (BufferedReader reader = toReader()) {
			return reader.lines().collect(Collectors.joining(System.lineSeparator()));
		}
	}

	public <T> T loadJson(Gson gson, Class<T> type) throws IOException {
		try (BufferedReader reader = toReader()) {
			return gson.fromJson(reader, type);
		}
	}

	public BufferedImage loadImage() throws IOException {
		try (InputStream is = toInputStream()) {
			byte[] bytes = is.readAllBytes();
			var icon = new ImageIcon(Toolkit.getDefaultToolkit().createImage(bytes));
			var bufferedImage = new BufferedImage(
				icon.getIconWidth(),
				icon.getIconHeight(),
				BufferedImage.TYPE_INT_ARGB
			);
			var g = bufferedImage.createGraphics();
			icon.paintIcon(null, g, 0, 0);
			g.dispose();
			return bufferedImage;
		}
	}

	/**
	 * Reads the full InputStream into a garbage-collected ByteBuffer allocated with BufferUtils.
	 *
	 * @return a ByteBuffer
	 * @throws IOException if the InputStream cannot be read
	 */
	public ByteBuffer loadByteBuffer() throws IOException {
		return readInputStream(toInputStream(), BufferUtils::createByteBuffer, null);
	}

	/**
	 * Reads the full InputStream into a ByteBuffer allocated with malloc, which must be explicitly freed.
	 *
	 * @return a ByteBuffer
	 * @throws IOException if the InputStream cannot be read
	 */
	public ByteBuffer loadByteBufferMalloc() throws IOException {
		return readInputStream(toInputStream(), MemoryUtil::memAlloc, MemoryUtil::memRealloc);
	}

	public ResourcePath writeByteBuffer(ByteBuffer buffer) throws IOException {
		try (var os = toOutputStream(); var channel = os.getChannel()) {
			int bytesToWrite = buffer.remaining();
			int bytesWritten = channel.write(buffer);
			if (bytesWritten < bytesToWrite) {
				throw new IOException(String.format(
					"Only %d out of %d bytes were successfully written to %s",
					bytesWritten, bytesToWrite, this
				));
			}
		}
		return this;
	}

	public ResourcePath writeString(String string) throws IOException {
		try (OutputStream os = toOutputStream()) {
			os.write(string.getBytes(StandardCharsets.UTF_8));
			// Ensure there's always a blank line at the end
			if (!string.endsWith("\n"))
				os.write('\n');
		}
		return this;
	}

	/**
	 * Reads the full InputStream into a garbage-collected ByteBuffer allocated with BufferUtils.
	 *
	 * @param is the InputStream
	 * @return a ByteBuffer
	 * @throws IOException if the InputStream cannot be read
	 */
	private static ByteBuffer readInputStream(
		InputStream is,
		Function<Integer, ByteBuffer> alloc,
		@Nullable BiFunction<ByteBuffer, Integer, ByteBuffer> realloc
	) throws IOException {
		if (realloc == null) {
			realloc = (ByteBuffer oldBuffer, Integer newSize) -> {
				ByteBuffer newBuffer = alloc.apply(newSize);
				newBuffer.put(oldBuffer);
				return newBuffer;
			};
		}

		try (ReadableByteChannel channel = Channels.newChannel(is)) {
			// Read all currently buffered data into a ByteBuffer
			ByteBuffer buffer = alloc.apply(is.available());
			channel.read(buffer);

			// If there's more data available, double the buffer size and round up to the nearest power of 2
			if (is.available() > buffer.remaining()) {
				int newSize = (buffer.position() + is.available()) * 2;
				int nearestPow2 = 2 << (31 - Integer.numberOfLeadingZeros(newSize - 1));
				buffer = realloc.apply(buffer, nearestPow2);
			}

			// Continue reading all bytes, doubling the buffer each time it runs out of space
			while (is.available() > 0)
				if (buffer.remaining() == channel.read(buffer))
					buffer = realloc.apply(buffer, buffer.capacity() * 2);

			channel.close();
			buffer.flip();
			return buffer;
		}
	}

	public static String normalize(String... parts) {
        return normalize(null, parts);
    }

	public static String normalize(@Nullable String workingDirectory, String[] parts) {
        Stack<String> resolvedParts = new Stack<>();
		if (workingDirectory != null && !workingDirectory.isEmpty() && !workingDirectory.equals("."))
			resolvedParts.addAll(Arrays.asList(normalizeSlashes(workingDirectory).split("/")));

		if (parts.length > 0)
			parts[0] = resolveTilde(parts[0]);

		for (String part : parts) {
			if (part == null || part.isEmpty() || part.equals("."))
				continue;

			part = normalizeSlashes(part);

			if (isAbsolute(part))
				resolvedParts.clear();

			for (String normalizedPart : part.split("/")) {
				if (normalizedPart.equals("..") &&
					!resolvedParts.isEmpty() &&
					!resolvedParts.peek().equals("..")
				) {
					resolvedParts.pop();
				} else {
					resolvedParts.push(normalizedPart);
				}
			}
		}

		return String.join("/", resolvedParts);
	}

	private static String normalizeSlashes(String path) {
		if (Platform.get() == Platform.WINDOWS)
			return path.replace("\\", "/");
		return path;
	}

	private static String resolveTilde(String path) {
		// Note: We only support ~ and ~user tilde expansion
		if (path == null || !path.startsWith("~"))
			return path;

		int slashIndex = path.indexOf('/');
		String specifiedUser = path.substring(1, slashIndex == -1 ? path.length() : slashIndex);
		String userHome = System.getProperty("user.home");
		if (userHome == null)
			throw new RuntimeException("Unable to resolve tilde path: " + path);

		Path home = Paths.get(userHome);

		// Check if the home path of a different user was specified
		if (!specifiedUser.isEmpty()) {
			// Assume the username matches the home folder name,
			// and that it's located next to the current user's home directory
			home = home.resolve("../" + specifiedUser);
		}

		if (slashIndex == -1)
			return home.toString();
		return home.resolve(path.substring(slashIndex + 1)).toString();
	}

	private static String stripLeadingSlash(String path) {
		return path.startsWith("/") ? path.substring(1) : path;
	}

	/**
	 * Expects forward slashes as path delimiter, but accepts Windows-style drive letter prefixes.
	 */
	private static boolean isAbsolute(String path) {
		if (Platform.get() == Platform.WINDOWS)
			path = path.replaceFirst("^\\w:", "");
		return path.startsWith("/");
	}

	private static class ClassResourcePath extends ResourcePath {
		public final ClassLoader classLoader;

		private ClassResourcePath(@Nonnull ClassLoader classLoader, String... parts) {
			super(parts);
			this.classLoader = classLoader;
		}

		@Override
		public ResourcePath resolve(String... parts) {
			return new ClassResourcePath(classLoader, normalize(path, parts));
		}

		private URL toResource() {
			assert path != null;
			return classLoader.getResource(stripLeadingSlash(path));
		}

		@Override
		public boolean exists() {
			return toResource() != null;
		}

		@Override
		public InputStream toInputStream() throws IOException {
			var url = toResource();
			if (url == null)
				throw new IOException("Unable to load resource: " + this);
			return url.openStream();
		}

		@Override
		public boolean isFileSystemResource() {
			return false;
		}
	}
}

package rs117.hd.utils;

import lombok.RequiredArgsConstructor;
import rs117.hd.opengl.shader.ShaderIncludes;

@RequiredArgsConstructor
public class ShaderRecompile {
	public final ShaderIncludes includes;
}

package rs117.hd.utils;

import static rs117.hd.utils.MathUtils.*;

public class ShadowCasterVolume {
	private static final float EPS = 1e-5f;
	private static final int VOLUME_TRIANGLE_COUNT = 12;
	private static final int[] VOLUME_TRIANGLE_INDICES = {
		// Left Side
		0, 1, 5,
		0, 5, 4,

		// Right Side
		2, 3, 7,
		2, 7, 6,

		// Top Side
		1, 2, 6,
		1, 6, 5,

		// Bottom Side
		0, 3, 7,
		0, 7, 4,

		// Near Plane
		0, 1, 2,
		2, 3, 0,

		// Far Plane
		4, 5, 6,
		6, 7, 4
	};

	private final Camera shadowCamera;
	private final float[] lightDir = new float[3];
	private final VolumeTriangle[] volumeTriangles = new VolumeTriangle[VOLUME_TRIANGLE_COUNT];

	public ShadowCasterVolume(Camera shadowCamera) {
		this.shadowCamera = shadowCamera;
		for (int t = 0; t < VOLUME_TRIANGLE_COUNT; t++)
			volumeTriangles[t] = new VolumeTriangle();
	}

	public void build(float[][] volumeCorners) {
		shadowCamera.getForwardDirection(lightDir);

		// Invert Light Direction
		normalize(lightDir, lightDir);
		lightDir[0] = -lightDir[0];
		lightDir[1] = -lightDir[1];
		lightDir[2] = -lightDir[2];

		for (int t = 0; t < VOLUME_TRIANGLE_COUNT; t++) {
			final float[] v0 = volumeCorners[VOLUME_TRIANGLE_INDICES[t * 3]];
			final float[] v1 = volumeCorners[VOLUME_TRIANGLE_INDICES[t * 3 + 1]];
			final float[] v2 = volumeCorners[VOLUME_TRIANGLE_INDICES[t * 3 + 2]];

			volumeTriangles[t].build(v0, v1, v2);
		}
	}

	public boolean intersectsPoint(int x, int y, int z) {
		for (int t = 0; t < VOLUME_TRIANGLE_COUNT; t++) {
			if (volumeTriangles[t].side(lightDir, x, y, z))
				return true;
		}

		return false;
	}

	public boolean intersectsAABB(int minX, int minY, int minZ, int maxX, int maxY, int maxZ) {
		for (int t = 0; t < VOLUME_TRIANGLE_COUNT; t++) {
			if (volumeTriangles[t].side(lightDir, minX, minY, minZ)) return true;
			if (volumeTriangles[t].side(lightDir, maxX, minY, minZ)) return true;
			if (volumeTriangles[t].side(lightDir, maxX, minY, maxZ)) return true;
			if (volumeTriangles[t].side(lightDir, minX, minY, maxZ)) return true;

			if (volumeTriangles[t].side(lightDir, minX, maxY, minZ)) return true;
			if (volumeTriangles[t].side(lightDir, maxX, maxY, minZ)) return true;
			if (volumeTriangles[t].side(lightDir, maxX, maxY, maxZ)) return true;
			if (volumeTriangles[t].side(lightDir, minX, maxY, maxZ)) return true;
		}

		return false;
	}

	static class VolumeTriangle {
		float x;
		float y;
		float z;

		float e1x;
		float e1y;
		float e1z;

		float e2x;
		float e2y;
		float e2z;

		void build(float[] v0, float[] v1, float[] v2) {
			x = v0[0];
			y = v0[1];
			z = v0[2];

			e1x = v1[0] - v0[0];
			e1y = v1[1] - v0[1];
			e1z = v1[2] - v0[2];

			e2x = v2[0] - v0[0];
			e2y = v2[1] - v0[1];
			e2z = v2[2] - v0[2];
		}

		boolean side(float[] lightDir, float x, float y, float z) {
			float px = lightDir[1] * e2z - lightDir[2] * e2y;
			float py = lightDir[2] * e2x - lightDir[0] * e2z;
			float pz = lightDir[0] * e2y - lightDir[1] * e2x;

			float det = e1x * px + e1y * py + e1z * pz;
			if (det > -EPS && det < EPS) return false;

			float invDet = 1.0f / det;

			float tx = x - this.x;
			float ty = y - this.y;
			float tz = z - this.z;

			float u = (tx * px + ty * py + tz * pz) * invDet;
			if (u < 0.0f || u > 1.0f) return false;

			float qx = ty * e1z - tz * e1y;
			float qy = tz * e1x - tx * e1z;
			float qz = tx * e1y - ty * e1x;

			float v = (lightDir[0] * qx + lightDir[1] * qy + lightDir[2] * qz) * invDet;
			if (v < 0.0f || u + v > 1.0f) return false;

			float t = (e2x * qx + e2y * qy + e2z * qz) * invDet;
			return t > EPS;
		}
	}
}

package rs117.hd.utils;

import java.util.Map;

@FunctionalInterface
public interface VariableSupplier {
	Object get(String name);

	default VariableSupplier proxy(VariableSupplier proxy) {
		return name -> {
			var value = proxy.get(name);
			if (value == null)
				return get(name);
			if (value instanceof String)
				return get((String) value);
			return value;
		};
	}

	default VariableSupplier aliases(Map<String, Object> aliases) {
		return proxy(aliases::get);
	}
}

package rs117.hd;

import java.io.InputStream;
import java.util.Properties;
import lombok.extern.slf4j.Slf4j;
import net.runelite.client.RuneLite;
import net.runelite.client.RuneLiteProperties;
import net.runelite.client.externalplugins.ExternalPluginManager;
import rs117.hd.utils.Props;

@SuppressWarnings("unchecked")
@Slf4j
public class HdPluginTest
{
	public static void main(String[] args) throws Exception
	{
		Props.DEVELOPMENT = true;
		Props.set("rlhd.resource-path", "src/main/resources");
		ClassLoader.getSystemClassLoader().setDefaultAssertionStatus(true);
		useLatestPluginHub();
		ExternalPluginManager.loadBuiltin(HdPlugin.class);
		RuneLite.main(args);
	}

	private static void useLatestPluginHub()
	{
		if (System.getProperty("runelite.pluginhub.version") == null)
		{
			try
			{
				Properties props = new Properties();
				try (InputStream in = RuneLiteProperties.class.getResourceAsStream("runelite.properties"))
				{
					props.load(in);
				}

				String version = props.getProperty("runelite.pluginhub.version");
				String[] parts = version.split("[.-]");
				if (parts.length > 3 && parts[3].equals("SNAPSHOT"))
				{
					int patch = Integer.parseInt(parts[2]) - 1;
					version = parts[0] + "." + parts[1] + "." + patch;
					log.info("Detected SNAPSHOT version with no manually specified plugin-hub version. " +
							"Setting runelite.pluginhub.version to {}", version);
					System.setProperty("runelite.pluginhub.version", version);
				}
			}
			catch (Exception ex)
			{
				log.error("Failed to automatically use latest plugin-hub version", ex);
			}
		}
	}
}

package rs117.hd.tests;

import org.junit.Assert;
import org.junit.Test;
import rs117.hd.scene.areas.AABB;
import rs117.hd.scene.areas.RegionBox;

import static net.runelite.api.Constants.*;

public class AABBTest {
	@Test
	public void testAABB() {
		Assert.assertTrue(new AABB(2815, 10097, 0, 2844, 10046, 0)
			.intersects(2832, 10056, 0, 2839, 10063, 0));
		Assert.assertTrue(new AABB(3221, 9602, 3307, 9660)
			.contains(3223, 9617, 0));
	}

	@Test
	public void testRegionBox() {
		Assert.assertEquals(
			new AABB(3264, 5120, 0, 3327, 5759, MAX_Z - 1),
			new RegionBox(13136, 13145).toAabb()
		);
		Assert.assertEquals(
			new AABB(3264, 5120, 0, 3327, 5759, MAX_Z - 1),
			new RegionBox(13145, 13136).toAabb()
		);
		Assert.assertEquals(
			new AABB(3392, 5760, 0, 3519, 5951, MAX_Z - 1),
			new RegionBox(13658, 13916).toAabb()
		);
	}

	@Test
	public void testRegion() {
		Assert.assertEquals(new AABB(3264, 5696, 3327, 5759), AABB.fromRegionId(13145));
	}
}

package rs117.hd.tests;

import java.util.Arrays;
import org.junit.Test;
import rs117.hd.utils.ColorUtils;

import static junit.framework.TestCase.assertEquals;
import static rs117.hd.utils.ColorUtils.linearToSrgb;
import static rs117.hd.utils.ColorUtils.packHsl;
import static rs117.hd.utils.ColorUtils.srgbToLinear;
import static rs117.hd.utils.ColorUtils.srgbToPackedHsl;
import static rs117.hd.utils.ColorUtils.unpackHsl;

public class ColorUtilsTest {
	@Test
	public void testJagexHslPacking() {
		float[] hsl;
		for (int counter = 0; (counter & ~0xFFFF) == 0; counter++) {
			int packedHslBefore = counter;
			hsl = unpackHsl(packedHslBefore);
			// Zero saturation or min/max lightness yield the same color
			if (hsl[1] <= .0625f || hsl[2] == 0 || hsl[2] >= 127f / 128) {
				hsl[0] = .0078125f;
				hsl[1] = .0625f;
				packedHslBefore = packHsl(hsl);
			}

			float[] srgbBefore = ColorUtils.packedHslToSrgb(packedHslBefore);
			float[] srgbAfter = linearToSrgb(srgbToLinear(srgbBefore));

			int packedHslAfter = srgbToPackedHsl(srgbAfter);
			if (packedHslBefore != packedHslAfter) {
				assertEquals(String.format(
					"Inaccurate color, packedHsl: %d\t->\t%d,\tHSL: %s\t->\t%s,\tRGB: %s\t->\t%s\n",
					packedHslBefore,
					packedHslAfter,
					Arrays.toString(hsl),
					Arrays.toString(unpackHsl(packedHslAfter)),
					Arrays.toString(srgbBefore),
					Arrays.toString(srgbAfter)
				), packedHslBefore, packedHslAfter);
			}
		}
	}
}

package rs117.hd.tests;

import java.util.LinkedHashMap;
import org.junit.Assert;
import org.junit.Test;
import rs117.hd.config.SeasonalTheme;
import rs117.hd.utils.VariableSupplier;

import static rs117.hd.utils.ExpressionParser.parseExpression;
import static rs117.hd.utils.ExpressionParser.parseFunction;
import static rs117.hd.utils.ExpressionParser.parsePredicate;

public class ExpressionParserTest {
	@Test
	public void testExpressionParser() {
		VariableSupplier vars = name -> {
			switch (name) {
				case "h":
					return 5;
				case "s":
					return 10;
				case "l":
					return 5;
				case "blending":
					return true;
				case "textures":
					return false;
			}
			return null;
		};

		Assert.assertEquals(5.f, parseExpression("5"));
		Assert.assertEquals(-5.f, parseExpression("-5"));
		Assert.assertEquals(-2.5f, parseExpression("-2.5"));
		Assert.assertEquals(-.5f, parseExpression("-0.5"));
		Assert.assertEquals(-.5f, parseExpression("-.5"));
		Assert.assertEquals(.5f, parseExpression(".5"));
		Assert.assertEquals(.5f, parseExpression("+.5"));
		Assert.assertEquals(.5f, parseExpression("++ +.5"));
		Assert.assertEquals(1f, parseExpression("--1"));
		Assert.assertEquals(.5f, parseExpression("+-++-.5"));
		Assert.assertEquals(17.f, parseFunction("5 + 12").apply(null));
		Assert.assertEquals(16.f, parseExpression("8 / 2 * (2 + 2)"));
		Assert.assertEquals(32.f, parseExpression("2 * 8 / 2 * (2 + 2)"));
		Assert.assertEquals(3.f, parseExpression("2 * 3 / 2"));
		Assert.assertEquals(0.f, parseExpression("2 * 8 - 4 * 4"));
		Assert.assertEquals(29.f, parseExpression("2 + 3 * (8 + 5 / 5)"));
		Assert.assertEquals(40.f, parseExpression("(8 - 1 + 3) * 6 - ((3 + 7) * 2)"));
		Assert.assertEquals(21.f, parseExpression("(1 + 2) * (3 + 4)"));
		Assert.assertFalse(parsePredicate("!( blending )").test(vars));
		Assert.assertEquals(false, parseExpression("!true"));
		Assert.assertEquals(true, parseExpression("SUMMER == 1", name -> SeasonalTheme.valueOf(name).ordinal()));

		assertThrows(() -> parseExpression("unexpected ( indeed"));
		assertThrows(() -> parseExpression("(5 + ( missing paren)"));

		LinkedHashMap<String, Boolean> testCases = new LinkedHashMap<>();
		testCases.put("h != 0", true);
		testCases.put("s == 0 || h <= 10 && s < 2", false);
		testCases.put("h == 8 && (s == 3 || s == 4) && l >= 20", false);
		testCases.put("h > 3 && s < 15 && l < 21", true);
		testCases.put("h < 3 && s < 15 && l < 21", false);
		testCases.put("h > 3 && (s < 9 || l < 19)", true);
		testCases.put("h == 5 ? s > 3 : s > 15", true);
		testCases.put("h == s || h == l", true);
		testCases.put("blending || textures", true);

		for (var entry : testCases.entrySet()) {
			var predicate = parsePredicate(entry.getKey());
			var result = predicate.test(vars);
			var passed = entry.getValue() == result;
			System.out.println(
				(passed ? "\u001B[32m" : "\u001B[31m") +
				"Case: " + entry.getKey() + " " + (passed ? "passed" : "failed") + ". Expected: " + entry.getValue() + ", got: " + result);
		}
	}

	private static void assertThrows(Runnable runnable) {
		try {
			runnable.run();
		} catch (Throwable ex) {
			System.out.println("\u001B[32m" + "Case: Threw as expected: " + ex);
			return;
		}
		Assert.fail("Didn't throw an exception");
	}
}

package rs117.hd.tests;

import java.util.List;
import java.util.concurrent.CopyOnWriteArrayList;
import lombok.extern.slf4j.Slf4j;
import org.junit.AfterClass;
import org.junit.Assert;
import org.junit.BeforeClass;
import org.junit.Test;
import rs117.hd.utils.jobs.GenericJob;
import rs117.hd.utils.jobs.JobSystem;

@Slf4j
public class JobSystemTests {
	private static JobSystem JOB_SYSTEM;

	@BeforeClass
	public static void beforeAll() {
		JOB_SYSTEM = new JobSystem();
		JOB_SYSTEM.initialize();
	}

	@AfterClass
	public static void afterAll() {
		JOB_SYSTEM.destroy();
	}

	@Test
	public void testQueueAndCompletion() {
		GenericJob task = GenericJob
			.build(
				"testQueueAndCompletion",
				(t) -> busyWork(t, 5000)
			)
			.queue(false);

		task.waitForCompletion();
		Assert.assertTrue(task.ranToCompletion());
	}

	@Test
	public void testQueueWithMultipleDependencies() {
		List<String> order = new CopyOnWriteArrayList<>();

		GenericJob tA = GenericJob
			.build(
				"A", t -> {
					busyWork(t, 200);
					order.add("A");
				}
			)
			.queue();

		GenericJob tB = GenericJob
			.build(
				"B", t -> {
					busyWork(t, 300);
					order.add("B");
				}
			)
			.queue(tA);

		GenericJob tC = GenericJob
			.build(
				"C", t -> {
					busyWork(t, 300);
					order.add("C");
				}
			)
			.queue(tA, tB);

		// Wait for dependent
		tC.waitForCompletion();

		Assert.assertTrue(tA.isDone());
		Assert.assertTrue(tB.isDone());
		Assert.assertTrue(tC.isDone());

		int idxA = order.indexOf("A");
		int idxB = order.indexOf("B");
		int idxC = order.indexOf("C");

		Assert.assertTrue(idxA >= 0 && idxB >= 0 && idxC >= 0);
		Assert.assertTrue(idxC > idxA && idxC > idxB);
		Assert.assertTrue(tA.ranToCompletion() && tB.ranToCompletion() && tC.ranToCompletion());
	}

	@Test
	public void testCancelTask() throws Exception {
		GenericJob longTask = GenericJob
			.build("long", (t) -> busyWork(t, 10000))
			.queue();

		Thread.sleep(50); // let it start
		longTask.cancel();

		Assert.assertFalse(longTask.ranToCompletion());
	}

	@Test
	public void testTasksWideParallel() {
		int taskCount = 1000;

		List<GenericJob> tasks = new CopyOnWriteArrayList<>();

		// Queue all tasks with no dependencies
		for (int i = 0; i < taskCount; i++) {
			tasks.add(GenericJob
				.build(
					"Task" + i,
					t -> {
						busyWork(t, 100); // short work for speed
					}
				)
				.queue());
		}

		// Wait for all tasks to complete
		for (GenericJob task : tasks)
			task.waitForCompletion();

		// Verify all tasks ran
		for (int i = 0; i < taskCount; i++)
			Assert.assertTrue("Task" + i + " should have executed", tasks.get(i).ranToCompletion());
	}

	@Test
	public void testManyDependenciesStress() {
		int count = 500;
		List<GenericJob> tasks = new CopyOnWriteArrayList<>();

		GenericJob prev = null;

		for (int i = 0; i < count; i++) {
			int idx = i;
			GenericJob task = GenericJob
				.build(
					"T" + idx, t -> {
						log.debug("[TASK {}] Start", idx);
						busyWork(t, 10);
					}
				)
				.queue(prev);

			tasks.add(task);
			prev = task;
		}

		prev.waitForCompletion();

		for (int i = 0; i < count; i++)
			Assert.assertTrue("Task T" + i + " should complete", tasks.get(i).ranToCompletion());
	}

	@Test
	public void testDependencyChain() {
		List<String> order = new CopyOnWriteArrayList<>();

		GenericJob tA = GenericJob
			.build(
				"A", t -> {
					log.debug("[TASK A] Start");
					busyWork(t, 1000);
					order.add("A");
				}
			)
			.queue();

		GenericJob tB = GenericJob
			.build(
				"B", t -> {
					log.debug("[TASK B] Start");
					busyWork(t, 200);
					order.add("B");
				}
			)
			.queue(tA);

		GenericJob tC = GenericJob
			.build(
				"C", t -> {
					log.debug("[TASK C] Start");
					busyWork(t, 2000);
					order.add("C");
				}
			)
			.queue(tB);

		tC.waitForCompletion();

		Assert.assertEquals(List.of("A", "B", "C"), order);
		Assert.assertTrue(tA.ranToCompletion() && tB.ranToCompletion() && tC.ranToCompletion());
	}

	@Test
	public void testBranchingDependencies() {
		List<String> order = new CopyOnWriteArrayList<>();

		GenericJob tA = GenericJob.build(
			"A", t -> {
				log.debug("[TASK A] Start");
				busyWork(t, 100);
				order.add("A");
			}
		).queue();

		GenericJob tB = GenericJob.build(
			"B", t -> {
				log.debug("[TASK B] Start");
				busyWork(t, 200);
				order.add("B");
			}
		).queue(tA);

		GenericJob tC = GenericJob.build(
			"C", t -> {
				log.debug("[TASK C] Start");
				busyWork(t, 150);
				order.add("C");
			}
		).queue(tA);

		GenericJob tD = GenericJob.build(
			"D", t -> {
				log.debug("[TASK D] Start");
				busyWork(t, 100);
				order.add("D");
			}
		).queue(tB, tC);

		tD.waitForCompletion();

		Assert.assertTrue(order.indexOf("A") < order.indexOf("B"));
		Assert.assertTrue(order.indexOf("A") < order.indexOf("C"));
		Assert.assertTrue(order.indexOf("B") < order.indexOf("D"));
		Assert.assertTrue(order.indexOf("C") < order.indexOf("D"));
	}

	@Test
	public void testDiamondDependencyGraph() throws Exception {
		List<String> order = new CopyOnWriteArrayList<>();

		GenericJob tA = GenericJob.build(
			"A", t -> {
				log.debug("[TASK A] Start");
				busyWork(t, 120);
				order.add("A");
			}
		).queue();

		GenericJob tB = GenericJob.build(
			"B", t -> {
				log.debug("[TASK B] Start");
				busyWork(t, 140);
				order.add("B");
			}
		).queue();

		GenericJob tC = GenericJob.build(
			"C", t -> {
				log.debug("[TASK C] Start");
				busyWork(t, 200);
				order.add("C");
			}
		).queue(tA, tB);

		GenericJob tD = GenericJob.build(
			"D", t -> {
				log.debug("[TASK D] Start");
				busyWork(t, 180);
				order.add("D");
			}
		).queue(tA, tB);

		GenericJob tE = GenericJob.build(
			"E", t -> {
				log.debug("[TASK E] Start");
				busyWork(t, 80);
				order.add("E");
			}
		).queue(tC, tD);

		tE.waitForCompletion();

		Assert.assertTrue(order.indexOf("A") < order.indexOf("C"));
		Assert.assertTrue(order.indexOf("B") < order.indexOf("C"));
		Assert.assertTrue(order.indexOf("A") < order.indexOf("D"));
		Assert.assertTrue(order.indexOf("B") < order.indexOf("D"));

		Assert.assertTrue(order.indexOf("C") < order.indexOf("E"));
		Assert.assertTrue(order.indexOf("D") < order.indexOf("E"));
	}

	@Test
	public void testCancelUpstreamDependencyPreventsDownstreamExecution() throws Exception {
		GenericJob hA = GenericJob.build(
			"A", t -> {
				log.debug("[TASK A] Start");
				busyWork(t, 5000);
			}
		).queue();

		GenericJob hB = GenericJob.build(
			"B", t -> {
				log.debug("[TASK B] Start (This shouldn't happen)");
				busyWork(t, 100);
			}
		).queue(hA);

		Thread.sleep(50);
		hA.cancel();

		Assert.assertTrue(hA.isDone());
		Assert.assertTrue(hB.isDone());

		Assert.assertFalse(hA.ranToCompletion());
		Assert.assertFalse(hB.ranToCompletion());
	}

	@Test
	public void testCircularDependencyDetection() {
		// Create 4 fresh handles
		GenericJob A = GenericJob.build("A", t -> busyWork(t, 1000));
		GenericJob B = GenericJob.build("B", t -> busyWork(t, 1000));
		GenericJob C = GenericJob.build("C", t -> busyWork(t, 1000));
		GenericJob D = GenericJob.build("D", t -> busyWork(t, 1000));

		// ----------------------------
		// Case 1: Valid chain A -> B -> C -> D
		// Should NOT throw
		// ----------------------------
		try {
			A.queue(); // A -> B
			B.queue(A); // B -> C
			C.queue(B); // C -> D
		} catch (Exception ex) {
			Assert.fail("Valid dependency chain threw unexpectedly: " + ex);
		}

		A.waitForCompletion();
		B.waitForCompletion();
		C.waitForCompletion();

		// ----------------------------
		// Case 2: Create a cycle by adding D -> A
		// A -> B -> C -> D -> A  (cycle)
		// Should throw IllegalStateException
		// ----------------------------
		boolean cycleThrown = false;
		try {
			A.queue(); // A -> D
			B.queue(A); // B -> C
			C.queue(B); // C -> B
			D.queue(D); // D -> A - should throw
		} catch (IllegalStateException expected) {
			cycleThrown = true;
		}
		Assert.assertTrue("Cycle A -> B -> C -> D -> A should throw IllegalStateException", cycleThrown);

		A.waitForCompletion();
		B.waitForCompletion();
		C.waitForCompletion();

		// ----------------------------
		// Case 3: Self-cycle A -> A
		// Should throw IllegalStateException
		// ----------------------------
		boolean selfCycleThrown = false;
		try {
			A.queue(A);
		} catch (IllegalStateException expected) {
			selfCycleThrown = true;
		}
		Assert.assertTrue("Self-cycle A -> A should throw IllegalStateException", selfCycleThrown);
	}

	@Test
	public void testGroupedDependencyGraph() throws Exception {
		List<String> order = new CopyOnWriteArrayList<>();

		// ----- A -----
		GenericJob tA = GenericJob.build(
			"A", t -> {
				log.debug("[TASK A] Start");
				busyWork(t, 100);
				order.add("A");
			}
		).queue();

		// ----- B -----
		GenericJob tB = GenericJob.build(
			"B", t -> {
				log.debug("[TASK B] Start");
				busyWork(t, 120);
				order.add("B");
			}
		).queue();

		// ----- C depends on A & B -----
		GenericJob hC = GenericJob.build(
			"C", t -> {
				log.debug("[TASK C] Start");
				busyWork(t, 150);
				order.add("C");
			}
		).queue(tA, tB);

		// ----- D depends on C -----
		GenericJob tD = GenericJob.build(
			"D", t -> {
				log.debug("[TASK D] Start");
				busyWork(t, 80);
				order.add("D");
			}
		).queue(hC);

		// ----- E depends on C -----
		GenericJob tE = GenericJob.build(
			"E", t -> {
				log.debug("[TASK E] Start");
				busyWork(t, 90);
				order.add("E");
			}
		).queue(hC);

		// Wait for the final downstream tasks
		tD.waitForCompletion();
		tE.waitForCompletion();

		// ----- Assertions -----
		Assert.assertTrue(order.contains("A"));
		Assert.assertTrue(order.contains("B"));
		Assert.assertTrue(order.contains("C"));
		Assert.assertTrue(order.contains("D"));
		Assert.assertTrue(order.contains("E"));

		// C must run after both A and B
		Assert.assertTrue(order.indexOf("C") > order.indexOf("A"));
		Assert.assertTrue(order.indexOf("C") > order.indexOf("B"));

		// D & E must run after C
		Assert.assertTrue(order.indexOf("D") > order.indexOf("C"));
		Assert.assertTrue(order.indexOf("E") > order.indexOf("C"));

		// Flags must be set
		Assert.assertTrue(tA.ranToCompletion());
		Assert.assertTrue(tB.ranToCompletion());
		Assert.assertTrue(hC.ranToCompletion());
		Assert.assertTrue(tD.ranToCompletion());
		Assert.assertTrue(tE.ranToCompletion());
	}

	@Test
	public void testCancelUpstreamCascadesDownstream() throws Exception {
		List<String> order = new CopyOnWriteArrayList<>();

		// ----- A: Will be cancelled -----
		GenericJob tA = GenericJob.build(
			"A", t -> {
				log.debug("[TASK A] Start");
				busyWork(t, 3000);  // long-running, gives us time to cancel
				order.add("A");
			}
		).queue();

		// ----- B: Allowed to run -----
		GenericJob tB = GenericJob.build(
			"B", t -> {
				log.debug("[TASK B] Start");
				busyWork(t, 100);
				order.add("B");
			}
		).queue();

		// ----- C depends on A & B -----
		GenericJob tC = GenericJob.build(
			"C", t -> {
				log.debug("[TASK C] Should NOT execute");
				busyWork(t, 50);
				order.add("C");
			}
		).queue(tA, tB);

		// ----- D depends on C -----
		GenericJob tD = GenericJob.build(
			"D", t -> {
				log.debug("[TASK D] Should NOT execute");
				busyWork(t, 50);
				order.add("D");
			}
		).queue(tC);

		// ----- E depends on C -----
		GenericJob tE = GenericJob.build(
			"E", t -> {
				log.debug("[TASK E] Should NOT execute");
				busyWork(t, 50);
				order.add("E");
			}
		).queue(tC);

		// Let A start
		Thread.sleep(50);
		tA.cancel(); // cancel upstream root

		// Wait for final tasks
		tE.waitForCompletion();

		// ----- Assertions -----

		// B is not cancelled, should run
		tB.waitForCompletion();
		Assert.assertTrue(tB.ranToCompletion());

		// A is cancelled
		Assert.assertFalse(tA.ranToCompletion());

		// C, D, E must never execute because they depend on A
		Assert.assertFalse(tC.ranToCompletion());
		Assert.assertFalse(tD.ranToCompletion());
		Assert.assertFalse(tE.ranToCompletion());

		// Order should contain only B (A is cancelled before completing)
		Assert.assertTrue(order.contains("B"));
		Assert.assertEquals(1, order.size());
	}

	private static void busyWork(GenericJob task, long millis) throws InterruptedException {
		final long start = System.nanoTime();
		final long durationNanos = millis * 1_000_000L;
		long nextLogTime = System.nanoTime() + 1000 * 1_000_000L; // 1 Second

		long number = 2;
		long primesFound = 0;

		while (System.nanoTime() - start < durationNanos) {
			if (isPrime(number))
				primesFound++;

			number++;

			task.workerHandleCancel();

			long now = System.nanoTime();
			if (now >= nextLogTime) {
				log.debug("busyWork: checked={} primes={}", number, primesFound);
				nextLogTime = now + 1000 * 1_000_000L;
			}
		}
	}

	private static boolean isPrime(long n) {
		if (n < 2) return false;
		if (n % 2 == 0) return n == 2;

		long limit = (long) Math.sqrt(n);
		for (long i = 3; i <= limit; i += 2) {
			if (n % i == 0)
				return false;
		}
		return true;
	}
}

package rs117.hd.tests;

import org.junit.Assert;
import org.junit.Test;
import rs117.hd.utils.Mat4;

public class Mat4Test {
	@Test
	public void testTranspose() {
		float[] m = {
			1, 2, 3, 4,
			5, 6, 7, 8,
			9, 10, 11, 12,
			13, 14, 15, 16
		};
		System.out.println(Mat4.format(m));
		Mat4.transpose(m);
		System.out.println("\n" + Mat4.format(m));
	}

	@Test
	public void testInverse() {
		float[] nonInvertible = {
			1, -2, 0, 2,
			-1, 3, 1, -2,
			-1, 5, 3, -2,
			0, 7, 7, 0
		};
		Mat4.transpose(nonInvertible);
		Assert.assertThrows(IllegalArgumentException.class, () -> Mat4.inverse(nonInvertible));

		String identity = Mat4.format(Mat4.identity());

		float[] invertible = {
			0, 0, -1, 2,
			0, 1, 0, 0,
			9, 0, 0, 0,
			0, 0, 0, 1
		};
		Mat4.transpose(invertible);
		float[] inverse = Mat4.inverse(invertible);
		Mat4.mul(inverse, invertible);
		Assert.assertEquals(identity, Mat4.format(inverse));

		invertible = new float[] {
			4, 0, 0, 0,
			0, 0, 2, 0,
			0, 1, 2, 0,
			1, 0, 0, 1
		};
		Mat4.transpose(invertible);
		inverse = Mat4.inverse(invertible);
		Mat4.mul(inverse, invertible);
		Assert.assertEquals(identity, Mat4.format(inverse));

		float[] invertible2 = {
			0.20491976f, -0.1548707f, 0.0f, 1.8616436E-8f,
			0.0f, -1.589505E-8f, 0.0f, -1.0f,
			0.096459776f, 0.32900834f, 0.0f, -3.954888E-8f,
			-1846.3291f, -1871.3298f, 100.0f, 3498.0002f
		};
		float[] inverse2 = Mat4.inverse(invertible2);
		Mat4.mul(inverse2, invertible2);
		Assert.assertEquals(identity, Mat4.format(inverse2));
	}
}

package rs117.hd.tests;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Random;
import org.junit.Test;
import rs117.hd.model.ModelHasher;

public class ModelHasherPerformanceTest {
    private final ArrayList<int[]> intArrays;
    private final Random random;
    private final int testDataCount;
    private final int testIterations;

    private long accumulatedHash = 0;

	public ModelHasherPerformanceTest() {
        this.intArrays = new ArrayList<>();
        this.random = new Random(1337);
        this.testDataCount = 1000;
        this.testIterations = 10000000;
    }

    private int[] generateRandomIntArray(int size) {
        int[] a = new int[size];

        for (int i = 0; i < size; i++) {
            a[i] = this.random.nextInt();
        }

        return a;
    }

	private long runStandardHasher() {
		long start = System.nanoTime();
		for (int i = 0; i < this.testIterations; i++) {
			accumulatedHash *= 31;
			accumulatedHash += Arrays.hashCode(intArrays.get(this.random.nextInt(this.testDataCount)));
		}
		return System.nanoTime() - start;
	}

	private long runFastHasher() {
		long start = System.nanoTime();
		for (int i = 0; i < this.testIterations; i++) {
			accumulatedHash *= 31;
			accumulatedHash += ModelHasher.fastHash(intArrays.get(this.random.nextInt(this.testDataCount)), -1);
		}
		return System.nanoTime() - start;
	}

	private double percentageDifference(long original, long changed) {
		long diff = original - changed;
		double delta = (double) diff / original;
		return delta * 100;
	}

	@Test
	public void testHashPerformance() {
		System.out.printf("Java version: %s\n\n", System.getProperty("java.version"));
		System.out.printf("Comparing hash performance of with %,d test items and %,d iterations\n\n", testDataCount, testIterations);

		// small arrays (size=512)
		for (int i = 0; i < testDataCount; i++) {
			// generate random test data
			intArrays.add(generateRandomIntArray(512));
		}

		long standardBatchResult = runStandardHasher();
		System.out.printf("Standard hasher small data set:  \t%,.3f seconds\n", (double) standardBatchResult / 1e9);
		long fastIntBatchResult = runFastHasher();
		System.out.printf("Fast int hasher small data set:  \t%,.3f seconds\n", (double) fastIntBatchResult / 1e9);
		System.out.printf("Improvement =\t%.2f%%\n\n", percentageDifference(standardBatchResult, fastIntBatchResult));
		long fastBatchResult = runFastHasher();
		System.out.printf("Fast hasher small data set:      \t%,.3f seconds\n", (double) fastBatchResult / 1e9);
		System.out.printf("Improvement =\t%.2f%%\n\n", percentageDifference(standardBatchResult, fastBatchResult));

		// medium arrays (size=2048)
		intArrays.clear();
		for (int i = 0; i < testDataCount; i++) {
			intArrays.add(generateRandomIntArray(2048));
		}

		standardBatchResult = runStandardHasher();
		System.out.printf("Standard hasher medium data set:  \t%,.3f seconds\n", (double) standardBatchResult / 1e9);
		fastIntBatchResult = runFastHasher();
		System.out.printf("Fast int hasher medium data set:  \t%,.3f seconds\n", (double) fastIntBatchResult / 1e9);
		System.out.printf("Improvement =\t%.2f%%\n\n", percentageDifference(standardBatchResult, fastIntBatchResult));
		fastBatchResult = runFastHasher();
		System.out.printf("Fast hasher medium data set:      \t%,.3f seconds\n", (double) fastBatchResult / 1e9);
		System.out.printf("Improvement =\t%.2f%%\n\n", percentageDifference(standardBatchResult, fastBatchResult));

		// large arrays (size=6144)
		intArrays.clear();
		for (int i = 0; i < testDataCount; i++) {
			intArrays.add(generateRandomIntArray(6144));
		}

		standardBatchResult = runStandardHasher();
		System.out.printf("Standard hasher large data set:  \t%,.3f seconds\n", (double) standardBatchResult / 1e9);
		fastIntBatchResult = runFastHasher();
		System.out.printf("Fast int hasher large data set:  \t%,.3f seconds\n", (double) fastIntBatchResult / 1e9);
		System.out.printf("Improvement =\t%.2f%%\n\n", percentageDifference(standardBatchResult, fastIntBatchResult));
		fastBatchResult = runFastHasher();
		System.out.printf("Fast hasher large data set:      \t%,.3f seconds\n", (double) fastBatchResult / 1e9);
		System.out.printf("Improvement =\t%.2f%%\n\n", percentageDifference(standardBatchResult, fastBatchResult));

		System.out.println("Hash: " + accumulatedHash);
	}
}

package rs117.hd.tools;

import com.google.gson.Gson;
import java.io.IOException;
import java.util.Arrays;
import java.util.Collection;
import java.util.HashSet;
import lombok.extern.slf4j.Slf4j;
import rs117.hd.scene.AreaManager;
import rs117.hd.scene.areas.AABB;
import rs117.hd.scene.areas.Area;
import rs117.hd.utils.Props;

import static rs117.hd.utils.MathUtils.*;
import static rs117.hd.utils.ResourcePath.path;

@Slf4j
public class ExportAreas {
	public static void main(String... args) throws IOException {
		Props.set("rlhd.resource-path", "src/main/resources");
		Area[] areas = path(AreaManager.class, "areas.json")
			.loadJson(new Gson(), Area[].class);

		HashSet<AABB> aabbs = new HashSet<>();
		HashSet<AABB> suspiciousAabbs = new HashSet<>();

		for (var area : areas) {
			if (area == Area.ALL || area == Area.NONE)
				continue;
			area.normalize();
			for (AABB aabb : area.aabbs) {
				int width = aabb.maxX + 1 - aabb.minX;
				int height = aabb.maxY + 1 - aabb.minY;
				float ratio = (float) width / height;
				if (max(ratio, 1 / ratio) > 64) {
					log.warn("Suspiciously shaped AABB (width={}, height={}) in {}: {}", width, height, area, aabb);
					suspiciousAabbs.add(aabb);
				}
			}
			aabbs.addAll(Arrays.asList(area.aabbs));
		}

		System.out.println("Suspicious AABBs:");
		printAabbs(suspiciousAabbs);
		System.out.println("\nAll AABBs:");
		printAabbs(aabbs);
	}

	public static void printAabbs(Collection<AABB> aabbs) {
		StringBuilder sb = new StringBuilder();
		sb.append("Area[] area = {");
		for (var aabb : aabbs)
			sb.append(String.format("new Area(%d, %d, %d, %d),", aabb.minX, aabb.minY, aabb.maxX, aabb.maxY));
		sb.deleteCharAt(sb.length() - 1);
		sb.append("};\n");
		sb.append("\"aabbs\": [");
		for (var aabb : aabbs)
			sb.append(String.format("[%d, %d, %d, %d],", aabb.minX, aabb.minY, aabb.maxX, aabb.maxY));
		sb.deleteCharAt(sb.length() - 1);
		sb.append("]");
		System.out.println(sb);
	}
}

