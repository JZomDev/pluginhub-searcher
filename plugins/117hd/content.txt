/*
 * Gson hacks.
 * Written in 2025 by Hooder <ahooder@protonmail.com>
 * To the extent possible under law, the author(s) have dedicated all copyright and related and neighboring rights
 * to this software to the public domain worldwide. This software is distributed without any warranty.
 * You should have received a copy of the CC0 Public Domain Dedication along with this software.
 * If not, see <http://creativecommons.org/publicdomain/zero/1.0/>.
 */
package rs117.hd.utils;

import com.google.gson.Gson;
import com.google.gson.JsonObject;
import com.google.gson.TypeAdapter;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonToken;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;
import java.util.Objects;
import javax.annotation.Nullable;
import lombok.NoArgsConstructor;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;

import static rs117.hd.utils.MathUtils.*;

@Slf4j
public class GsonUtils {
	public static String location(JsonReader in) {
		var str = in.toString();
		int i = str.indexOf(" at ");
		if (i != -1)
			str = str.substring(i + 4);
		return str;
	}

	public static Gson wrap(Gson gson) {
		return gson.newBuilder()
			.setLenient()
			.setPrettyPrinting()
			.disableHtmlEscaping() // Disable HTML escaping for JSON exports (Gson never escapes when parsing regardless)
			.registerTypeAdapterFactory(new ExcludeDefaultsFactory())
			.registerTypeAdapter(Float.class, new RoundingAdapter(3))
			.create();
	}

	public static class RoundingAdapter extends TypeAdapter<Float> {
		private final float rounding;

		public RoundingAdapter(int decimals) {
			rounding = pow(10, decimals);
		}

		@Override
		public Float read(JsonReader in) throws IOException {
			if (in.peek() == JsonToken.NULL)
				return null;
			return (float) in.nextDouble();
		}

		@Override
		public void write(JsonWriter out, Float src) throws IOException {
			if (src == null) {
				out.nullValue();
			} else {
				var result = round(src * rounding) / rounding;
				if (round(result) == result) {
					out.value((int) result); // Remove decimals when possible
				} else {
					out.value((Number) result); // Cast to Number so Gson removes unnecessary precision
				}
			}
		}
	}

	/**
	 * Make it less cumbersome to implement a TypeAdapter which respects the default Float adapter.
	 */
	@NoArgsConstructor
	@SuppressWarnings("unchecked")
	public static abstract class DelegateFloatAdapter<T> implements TypeAdapterFactory {
		protected TypeAdapter<Float> FLOAT_ADAPTER;
		protected boolean unwrapContainers; // Only apply directly to numbers, letting Gson handle any composite types

		@Override
		public <U> TypeAdapter<U> create(Gson gson, TypeToken<U> typeToken) {
			FLOAT_ADAPTER = gson.getAdapter(TypeToken.get(Float.class));
			var impl = this;
			var adapter = new TypeAdapter<U>() {
				@Override
				public U read(JsonReader in) throws IOException {
					return (U) impl.read(in);
				}

				@Override
				public void write(JsonWriter out, U value) throws IOException {
					impl.write(out, (T) value);
				}
			};

			if (!unwrapContainers)
				return adapter;

			// Register this as a TypeAdapterFactory for numbers downstream
			return gson.newBuilder()
				.registerTypeAdapterFactory(new TypeAdapterFactory() {
					@Override
					public <S> TypeAdapter<S> create(Gson gson, TypeToken<S> typeToken) {
						var type = typeToken.getRawType();
						if (type.isPrimitive()) {
							if (type != float.class)
								return null;
						} else if (!Float.class.isAssignableFrom(type)) {
							return null;
						}
						return (TypeAdapter<S>) adapter;
					}
				})
				.create()
				.getAdapter(typeToken);
		}

		public abstract T read(JsonReader in) throws IOException;
		public abstract void write(JsonWriter out, T value) throws IOException;
	}

	/**
	 * Because of the way this works internally, custom formatting by calling `JsonWriter#jsonValue` is not supported.
	 */
	@Retention(RetentionPolicy.RUNTIME)
	@Target(ElementType.TYPE)
	public @interface ExcludeDefaults {}

	public interface ExcludeDefaultsProvider<T> {
		@Nullable
		T provideDefaults();
	}

	@RequiredArgsConstructor
	private static class ExcludeDefaultsAdapter<T> extends TypeAdapter<T> {
		private final Gson gson;
		private final TypeAdapter<T> type;
		private final JsonObject defaults;

		@Override
		public void write(JsonWriter out, T t) throws IOException {
			var json = type.toJsonTree(t);
			if (!json.isJsonObject()) {
				gson.toJson(json, out);
				return;
			}

			var defaults = this.defaults;
			if (t instanceof ExcludeDefaultsProvider) {
				var provided = ((ExcludeDefaultsProvider<?>) t).provideDefaults();
				if (provided != null) {
					try {
						// noinspection unchecked
						defaults = type.toJsonTree((T) provided).getAsJsonObject();
					} catch (ClassCastException ex) {
						log.error("Incorrect type provided by DefaultsProvider: {}, expected {}", provided.getClass(), t.getClass());
					}
				}
			}

			var obj = json.getAsJsonObject();
			for (var e : defaults.entrySet())
				if (Objects.equals(obj.get(e.getKey()), e.getValue()))
					obj.remove(e.getKey());

			// Make it possible to replace inherited non-null default values with explicit nulls
			out.setSerializeNulls(true);
			out.beginObject();
			for (var e : obj.entrySet()) {
				out.name(e.getKey());
				if (e.getValue().isJsonNull()) {
					out.nullValue();
				} else {
					gson.toJson(e.getValue(), out);
				}
			}
			out.endObject();
		}

		@Override
		public T read(JsonReader in) throws IOException {
			return type.read(in);
		}
	}

	private static class ExcludeDefaultsFactory implements TypeAdapterFactory {
		@Override
		public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
			for (var annotation : type.getRawType().getAnnotations()) {
				if (annotation.annotationType() == ExcludeDefaults.class) {
					try {
						var defaultDelegate = gson.getDelegateAdapter(this, type);
						T defaultObj;
						try {
							defaultObj = defaultDelegate.fromJson("{}");
						} catch (IOException ex) {
							return null; // Can't skip defaults for non-object types
						}

						if (defaultObj == null)
							return null; // No defaults available

						var defaults = defaultDelegate.toJsonTree(defaultObj).getAsJsonObject();
						return new ExcludeDefaultsAdapter<>(gson, gson.getDelegateAdapter(this, type), defaults);
					} catch (Exception ex) {
						log.error("Unable to exclude defaults for {}", type, ex);
						break;
					}
				}
			}
			return null;
		}
	}

	public static class DegreesToRadians extends DelegateFloatAdapter<Float> {
		{
			unwrapContainers = true;
		}

		@Override
		public Float read(JsonReader in) throws IOException {
			var value = FLOAT_ADAPTER.read(in);
			return value == null ? null : value * DEG_TO_RAD;
		}

		@Override
		public void write(JsonWriter out, Float value) throws IOException {
			FLOAT_ADAPTER.write(out, value == null ? null : value * RAD_TO_DEG);
		}
	}
}

/*
 * Matrix utility functions.
 * Written in 2024 by Hooder <ahooder@protonmail.com>
 * To the extent possible under law, the author(s) have dedicated all copyright and related and neighboring rights
 * to this software to the public domain worldwide. This software is distributed without any warranty.
 * You should have received a copy of the CC0 Public Domain Dedication along with this software.
 * If not, see <http://creativecommons.org/publicdomain/zero/1.0/>.
 */
package rs117.hd.utils;

import java.text.DecimalFormat;
import java.util.Arrays;

import static rs117.hd.utils.MathUtils.*;

public class Matrix {
	private static final float EPS = 1e-6f;

	/**
	 * Utility class for working with column-major m x n matrices.
	 */

	public static float[] copy(float[] m) {
		return Arrays.copyOf(m, m.length);
	}

	public static void solve(float[] m, int rows, int columns) {
		int square = min(columns, rows);
		columns:
		for (int j = 0; j < square; j++) {
			for (int i = j; i < rows; i++) {
				var f = m[j * rows + i];
				if (abs(f) < EPS)
					continue;

				// Swap the row into the right position
				if (i != j) {
					for (int k = 0; k < rows * columns; k += rows) {
						var tmp = m[k + j];
						m[k + j] = m[k + i];
						m[k + i] = tmp;
					}
				}

				// Divide by the first entry of the row
				if (abs(f - 1) > EPS) {
					f = 1 / f;
					for (int k = 0; k < rows * columns; k += rows)
						m[k + j] *= f;
				}

				// Reduce other rows
				for (int r = 0; r < rows; r++) {
					if (r == j)
						continue;
					var g = m[j * rows + r];
					if (abs(g) > EPS)
						for (int k = 0; k < rows * columns; k += rows)
							m[k + r] -= g * m[k + j];
				}

				continue columns;
			}

			throw new IllegalArgumentException("Linear system does not have a solution");
		}
	}

	public static String format(float[] m, int rows, int columns) {
		String[] f = new String[m.length];
		var format = new DecimalFormat("0.##");
		int maxdigits = 0;
		int maxfractions = 0;
		for (int i = 0; i < rows * columns; i++) {
			float v = m[i];
			if (abs(v) < .01)
				v = 0;
			f[i] = format.format(v);
			var j = f[i].indexOf('.');
			if (j == -1) {
				maxdigits = max(maxdigits, f[i].length());
			} else {
				maxdigits = max(maxdigits, j);
				maxfractions = max(maxfractions, f[i].length() - j);
			}
		}

		StringBuilder str = new StringBuilder();

		for (int row = 0; row < rows; row++) {
			for (int col = 0; col < columns; col++) {
				int idx = col * rows + row;
				int dot = f[idx].indexOf('.');
				if (dot == -1) {
					int padLeft = maxdigits - f[idx].length();
					if (padLeft > 0)
						f[idx] = " ".repeat(padLeft) + f[idx];
					f[idx] += " ".repeat(maxfractions);
				} else {
					int padLeft = maxdigits - dot;
					if (padLeft > 0)
						f[idx] = " ".repeat(padLeft) + f[idx];
					int padRight = maxfractions - (f[idx].length() - dot);
					if (padRight > 0)
						f[idx] += " ".repeat(padRight);
				}

				if (col == 0)
					str.append("[ ");
				str.append(f[idx]).append(" ");
				if (col == columns - 1) {
					str.append("]");
					if (idx != m.length - 1)
						str.append("\n");
				}
			}
		}

		return str.toString();
	}
}

/*
 * Math utility functions.
 * Written in 2025 by Hooder <ahooder@protonmail.com>
 * To the extent possible under law, the author(s) have dedicated all copyright and related and neighboring rights
 * to this software to the public domain worldwide. This software is distributed without any warranty.
 * You should have received a copy of the CC0 Public Domain Dedication along with this software.
 * If not, see <http://creativecommons.org/publicdomain/zero/1.0/>.
 */
package rs117.hd.utils;

import java.util.Arrays;
import java.util.Random;
import javax.annotation.Nullable;

/**
 * Math utility functions similar to GLSL, including vector operations on raw float arrays.
 * Usability and conciseness is prioritized, however most methods at least allow avoiding unnecessary allocations.
 * Wherever it makes sense, inputs of different sizes are allowed, where shorter inputs will be repeated to fill the output vector.
 * When automatically determining the length of the output vector, it will equal the maximum length of the input vectors.
 * Some regular Java math function aliases are included to minimize the need for manual type casting.
 */
public class MathUtils {
	public static final Random RAND = new Random();

	public static final long KiB = 1024;
	public static final long MiB = KiB * KiB;
	public static final long GiB = MiB * KiB;

	public static final float EPSILON = 1.1920929e-7f; // Float epsilon from JOGL
	public static final float MAX_FLOAT_WITH_128TH_PRECISION = 1 << 16;

	public static final float E = (float) Math.E;

	public static final float PI = (float) Math.PI;
	public static final float TWO_PI = PI * 2;
	public static final float HALF_PI = PI / 2;
	public static final float QUARTER_PI = PI / 4;

	public static final float DEG_TO_RAD = TWO_PI / 360;
	public static final float RAD_TO_DEG = 1 / DEG_TO_RAD;
	public static final float JAU_TO_RAD = TWO_PI / 2048;
	public static final float RAD_TO_JAU = 1 / JAU_TO_RAD;

	public static float[] vec(float... vec) {
		return vec;
	}

	public static float[] vec(int... vec) {
		float[] floats = new float[vec.length];
		for (int i = 0; i < vec.length; i++)
			floats[i] = vec[i];
		return floats;
	}

	public static int[] ivec(int... vec) {
		return vec;
	}

	public static int[] ivec(float... vec) {
		int[] ivec = new int[vec.length];
		for (int i = 0; i < vec.length; i++)
			ivec[i] = (int) vec[i];
		return ivec;
	}

	public static float[] copy(float[] v) {
		return Arrays.copyOf(v, v.length);
	}

	public static int[] copy(int[] v) {
		return Arrays.copyOf(v, v.length);
	}

	public static float[] copyTo(float[] out, @Nullable float[] in, int offset, int len) {
		if (in != null) {
			assert offset + len <= min(out.length, in.length);
			System.arraycopy(in, offset, out, offset, len);
		}
		return out;
	}

	public static float[] copyTo(float[] out, @Nullable float[] in) {
		return copyTo(out, in, 0, in == null ? out.length : min(out.length, in.length));
	}

	public static int[] copyTo(int[] out, @Nullable int[] in, int offset, int len) {
		if (in != null) {
			assert offset + len <= min(out.length, in.length);
			System.arraycopy(in, offset, out, offset, len);
		}
		return out;
	}

	public static int[] copyTo(int[] out, @Nullable int[] in) {
		return copyTo(out, in, 0, in == null ? out.length : min(out.length, in.length));
	}

	public static float[] ensureDefaults(@Nullable float[] in, float[] defaults) {
		return in != null && in.length == defaults.length ? in : copyTo(copy(defaults), in);
	}

	public static int[] ensureDefaults(@Nullable int[] in, int[] defaults) {
		return in != null && in.length == defaults.length ? in : copyTo(copy(defaults), in);
	}

	public static int[] slice(int[] v, int offset) {
		return Arrays.copyOfRange(v, offset, v.length);
	}

	/**
	 * If offset + length surpasses the end of the array, the output will be zero padded.
	 */
	public static int[] slice(int[] v, int offset, int length) {
		assert offset <= v.length;
		return Arrays.copyOfRange(v, offset, offset + length);
	}

	public static float[] slice(float[] v, int offset) {
		return Arrays.copyOfRange(v, offset, v.length);
	}

	/**
	 * If offset + length surpasses the end of the array, the output will be zero padded.
	 */
	public static float[] slice(float[] v, int offset, int length) {
		assert offset <= v.length;
		return Arrays.copyOfRange(v, offset, offset + length);
	}

	public static float[] add(float[] out, float[] a, float... b) {
		for (int i = 0; i < out.length; i++)
			out[i] = a[i % out.length] + b[i % b.length];
		return out;
	}

	public static float[] add(float[] a, float[] b) {
		return add(new float[max(a.length, b.length)], a, b);
	}

	public static float[] subtract(float[] out, float[] a, float... b) {
		for (int i = 0; i < out.length; i++)
			out[i] = a[i % a.length] - b[i % b.length];
		return out;
	}

	public static float[] subtract(float[] a, float[] b) {
		return subtract(new float[max(a.length, b.length)], a, b);
	}

	public static float[] multiply(float[] out, float[] a, float... b) {
		for (int i = 0; i < out.length; i++)
			out[i] = a[i % a.length] * b[i % b.length];
		return out;
	}

	public static float[] multiply(float[] a, float... b) {
		return multiply(new float[max(a.length, b.length)], a, b);
	}

	public static float[] divide(float[] out, float[] a, float... b) {
		for (int i = 0; i < out.length; i++) {
			float divisor = b[i % b.length];
			out[i] = a[i % a.length] * (divisor == 0 ? 0 : 1 / divisor);
		}
		return out;
	}

	public static float[] divide(float[] a, float... b) {
		return divide(new float[max(a.length, b.length)], a, b);
	}

	/**
	 * Modulo which returns the answer with the same sign as the modulus.
	 */
	public static float mod(float v, float mod) {
		return v - floor(v / mod) * mod;
	}

	public static int mod(long v, int mod) {
		return (int) (v - (v / mod) * mod);
	}

	public static float mod(double v, float mod) {
		return (float) (v - Math.floor(v / mod) * mod);
	}

	public static float[] mod(float[] out, float[] v, float... mod) {
		for (int i = 0; i < out.length; i++)
			out[i] = mod(v[i % v.length], mod[i % mod.length]);
		return out;
	}

	public static float[] mod(float[] v, float... mod) {
		return mod(new float[max(v.length, mod.length)], v, mod);
	}

	public static float pow(float base, float exp) {
		return (float) Math.pow(base, exp);
	}

	public static float[] pow(float[] out, float[] base, float... exp) {
		for (int i = 0; i < out.length; i++)
			out[i] = pow(base[i % base.length], exp[i % exp.length]);
		return out;
	}

	public static float[] pow(float[] in, float... exp) {
		return pow(new float[max(in.length, exp.length)], in, exp);
	}

	public static float pow2(float v) {
		return v * v;
	}

	public static float[] pow2(float[] out, float... v) {
		for (int i = 0; i < out.length; i++) {
			float f = v[i % out.length];
			out[i] = f * f;
		}
		return out;
	}

	public static float[] pow2(float... v) {
		return pow2(new float[v.length], v);
	}

	public static float exp(float v) {
		return (float) Math.exp(v);
	}

	public static float[] exp(float[] out, float... v) {
		for (int i = 0; i < out.length; i++)
			out[i] = exp(v[i % v.length]);
		return out;
	}

	public static float[] exp(float... v) {
		return exp(new float[v.length], v);
	}

	public static float log(float v) {
		return (float) Math.log(v);
	}

	public static float[] log(float[] out, float... v) {
		for (int i = 0; i < out.length; i++)
			out[i] = log(v[i % v.length]);
		return out;
	}

	public static float[] log(float... v) {
		return log(new float[v.length], v);
	}

	public static float log2(float v) {
		return log(v) / log(2);
	}

	public static float[] log2(float[] out, float... v) {
		for (int i = 0; i < out.length; i++)
			out[i] = log2(v[i % v.length]);
		return out;
	}

	public static float[] log2(float... v) {
		return log2(new float[v.length], v);
	}

	public static float sqrt(float v) {
		return (float) Math.sqrt(v);
	}

	public static float[] sqrt(float[] out, float... v) {
		for (int i = 0; i < out.length; i++)
			out[i] = sqrt(v[i % v.length]);
		return out;
	}

	public static float[] sqrt(float... v) {
		return sqrt(new float[v.length], v);
	}

	public static float dot(float[] a, float[] b, int n) {
		assert a.length >= n && b.length >= n;
		float f = 0;
		for (int i = 0; i < n; i++)
			f += a[i] * b[i];
		return f;
	}

	public static float dot(float[] a, float... b) {
		return dot(a, b, min(a.length, b.length));
	}

	public static float dot(float... v) {
		return dot(v, v);
	}

	public static int product(int... v) {
		int product = 1;
		for (int factor : v)
			product *= factor;
		return product;
	}

	public static float product(float... v) {
		float product = 1;
		for (float factor : v)
			product *= factor;
		return product;
	}

	/**
	 * Yields incorrect results if either of the input vectors is used as the output vector.
	 */
	public static float[] cross(float[] out, float[] a, float[] b) {
		out[0] = a[1] * b[2] - a[2] * b[1];
		out[1] = a[2] * b[0] - a[0] * b[2];
		out[2] = a[0] * b[1] - a[1] * b[0];
		return out;
	}

	public static float[] cross(float[] a, float[] b) {
		return cross(new float[3], a, b);
	}

	public static float length(float... v) {
		return (float) Math.sqrt(dot(v, v));
	}

	public static float distance(float[] a, float[] b, int n) {
		return (float) Math.sqrt(dot(a, a, n) - 2 * dot(a, b, n) + dot(b, b, n));
	}

	public static float distance(float[] a, float[] b) {
		return distance(a, b, min(a.length, b.length));
	}

	public static float[] normalize(float[] out, float... v) {
		return divide(out, v, length(v));
	}

	public static float[] normalize(float... v) {
		return normalize(new float[v.length], v);
	}

	public static float abs(float v) {
		return Math.abs(v);
	}

	public static int abs(int v) {
		return Math.abs(v);
	}

	public static long abs(long v) {
		return Math.abs(v);
	}

	public static float[] abs(float[] out, float... v) {
		for (int i = 0; i < out.length; i++)
			out[i] = abs(v[i % v.length]);
		return out;
	}

	public static float[] abs(float[] v) {
		return abs(new float[v.length], v);
	}

	public static int floor(float v) {
		return (int) Math.floor(v);
	}

	public static int[] floor(int[] out, float... v) {
		for (int i = 0; i < out.length; i++)
			out[i] = floor(v[i % v.length]);
		return out;
	}

	public static int[] floor(float[] v) {
		return floor(new int[v.length], v);
	}

	public static int ceil(float v) {
		return (int) Math.ceil(v);
	}

	public static int[] ceil(int[] out, float... v) {
		for (int i = 0; i < out.length; i++)
			out[i] = ceil(v[i % v.length]);
		return out;
	}

	public static int[] ceil(float[] v) {
		return ceil(new int[v.length], v);
	}

	public static int round(float v) {
		return Math.round(v);
	}

	public static long round(double v) {
		return Math.round(v);
	}

	public static int[] round(int[] out, float... v) {
		for (int i = 0; i < out.length; i++)
			out[i] = round(v[i % v.length]);
		return out;
	}

	public static int[] round(float[] v) {
		return round(new int[v.length], v);
	}

	public static float[] roundf(float[] out, float... v) {
		for (int i = 0; i < out.length; i++)
			out[i] = round(v[i % v.length]);
		return out;
	}

	public static float[] roundf(float[] v) {
		return roundf(new float[v.length], v);
	}

	public static float min(float a, float b) {
		return Math.min(a, b);
	}

	public static int min(int a, int b) {
		return Math.min(a, b);
	}

	public static long min(long a, long b) {
		return Math.min(a, b);
	}

	public static float min(float... v) {
		assert v.length > 0;
		var min = v[0];
		for (var x : v)
			min = min(min, x);
		return min;
	}

	public static float[] min(float[] out, float[] a, float... b) {
		for (int i = 0; i < out.length; i++)
			out[i] = min(a[i % a.length], b[i % b.length]);
		return out;
	}

	public static float[] min(float[] a, float... b) {
		return min(new float[max(a.length, b.length)], a, b);
	}

	public static int min(int... v) {
		assert v.length > 0;
		var min = v[0];
		for (var x : v)
			min = min(min, x);
		return min;
	}

	public static int[] min(int[] out, int[] a, int... b) {
		for (int i = 0; i < out.length; i++)
			out[i] = min(a[i % a.length], b[i % b.length]);
		return out;
	}

	public static int[] min(int[] a, int... b) {
		return min(new int[max(a.length, b.length)], a, b);
	}

	public static float max(float a, float b) {
		return Math.max(a, b);
	}

	public static int max(int a, int b) {
		return Math.max(a, b);
	}

	public static long max(long a, long b) {
		return Math.max(a, b);
	}

	public static float max(float... v) {
		assert v.length > 0;
		var max = v[0];
		for (var x : v)
			max = max(max, x);
		return max;
	}

	public static float[] max(float[] out, float[] a, float... b) {
		for (int i = 0; i < out.length; i++)
			out[i] = max(a[i % a.length], b[i % b.length]);
		return out;
	}

	public static float[] max(float[] a, float... b) {
		return max(new float[max(a.length, b.length)], a, b);
	}

	public static int max(int... v) {
		assert v.length > 0;
		var max = v[0];
		for (var x : v)
			max = max(max, x);
		return max;
	}

	public static int[] max(int[] out, int[] a, int... b) {
		for (int i = 0; i < out.length; i++)
			out[i] = max(a[i % a.length], b[i % b.length]);
		return out;
	}

	public static int[] max(int[] a, int... b) {
		return max(new int[max(a.length, b.length)], a, b);
	}

	public static float clamp(float v, float min, float max) {
		return min(max(v, min), max);
	}

	public static float clamp(double v, float min, float max) {
		return clamp((float) v, min, max);
	}

	public static int clamp(int v, int min, int max) {
		return min(max(v, min), max);
	}

	public static float[] clamp(float[] out, float[] v, float[] min, float... max) {
		for (int i = 0; i < out.length; i++)
			out[i] = clamp(v[i % v.length], min[i % min.length], max[i % max.length]);
		return out;
	}

	public static float[] clamp(float[] out, float[] v, float min, float... max) {
		return clamp(out, v, vec(min), max);
	}

	public static float[] clamp(float[] v, float[] min, float... max) {
		return clamp(new float[max(v.length, min.length, max.length)], v, min, max);
	}

	public static float[] clamp(float[] v, float min, float... max) {
		return clamp(new float[max(v.length, max.length)], v, vec(min), max);
	}

	public static float saturate(float v) {
		return clamp(v, 0, 1);
	}

	public static float saturate(double v) {
		return saturate((float) v);
	}

	public static float[] saturate(float[] out, float... v) {
		for (int i = 0; i < out.length; i++)
			out[i] = saturate(v[i % v.length]);
		return out;
	}

	public static float[] saturate(float... v) {
		return saturate(new float[v.length], v);
	}

	public static float fract(float v) {
		return mod(v, 1);
	}

	public static float[] fract(float[] out, float... v) {
		for (int i = 0; i < out.length; i++)
			out[i] = fract(v[i % out.length]);
		return out;
	}

	public static float[] fract(float... v) {
		return fract(new float[v.length], v);
	}

	public static float sign(float v) {
		return v < 0 ? -1 : 1;
	}

	public static float[] sign(float[] out, float... v) {
		for (int i = 0; i < out.length; i++)
			out[i] = sign(v[i % out.length]);
		return out;
	}

	public static float[] sign(float... v) {
		return sign(new float[v.length], v);
	}

	public static float mix(float v0, float v1, float factor) {
		return v0 * (1 - factor) + v1 * factor;
	}

	public static float[] mix(float[] out, float[] v0, float[] v1, float... factor) {
		for (int i = 0; i < out.length; i++)
			out[i] = mix(v0[i % v0.length], v1[i % v1.length], factor[i % factor.length]);
		return out;
	}

	public static float[] mix(float[] v0, float[] v1, float... factor) {
		return mix(new float[max(v0.length, v1.length, factor.length)], v0, v1, factor);
	}

	public static float smoothstep(float v0, float v1, float factor) {
		float t = saturate((factor - v0) / (v1 - v0));
		return t * t * (3 - 2 * t);
	}

	public static float[] smoothstep(float[] out, float[] v0, float[] v1, float... factor) {
		for (int i = 0; i < out.length; i++)
			out[i] = smoothstep(v0[i % v0.length], v1[i % v1.length], factor[i % factor.length]);
		return out;
	}

	public static float[] smoothstep(float[] v0, float[] v1, float... factor) {
		return smoothstep(new float[max(v0.length, v1.length, factor.length)], v0, v1, factor);
	}

	public static float sum(float... v) {
		float sum = 0;
		for (float value : v)
			sum += value;
		return sum;
	}

	public static float avg(float... v) {
		return sum(v) / v.length;
	}

	public static float sin(float rad) {
		return (float) Math.sin(rad);
	}

	public static float cos(float rad) {
		return (float) Math.cos(rad);
	}

	public static float tan(float rad) {
		return (float) Math.tan(rad);
	}
}

package rs117.hd.utils;

import java.util.function.Predicate;

@FunctionalInterface
public interface ExpressionPredicate extends Predicate<VariableSupplier> {
	ExpressionPredicate TRUE = vars -> true;
	ExpressionPredicate FALSE = vars -> false;

	default boolean test() {
		return test(vars -> null);
	}
}

package rs117.hd.utils;

import java.util.Map;

@FunctionalInterface
public interface VariableSupplier {
	Object get(String name);

	default VariableSupplier proxy(VariableSupplier proxy) {
		return name -> {
			var value = proxy.get(name);
			if (value == null)
				return get(name);
			if (value instanceof String)
				return get((String) value);
			return value;
		};
	}

	default VariableSupplier aliases(Map<String, Object> aliases) {
		return proxy(aliases::get);
	}
}

package rs117.hd.utils;

import lombok.RequiredArgsConstructor;
import rs117.hd.opengl.shader.ShaderIncludes;

@RequiredArgsConstructor
public class ShaderRecompile {
	public final ShaderIncludes includes;
}

package rs117.hd.utils;

import java.util.List;
import javax.inject.Inject;
import javax.inject.Singleton;
import rs117.hd.HdPlugin;
import rs117.hd.HdPluginConfig;
import rs117.hd.config.SeasonalTheme;

@Singleton
public class HDVariables implements VariableSupplier {
	public static final String VAR_SEASONAL_THEME = "season";
	public static final String VAR_MODEL_TEXTURES = "modelTextures";
	public static final String VAR_GROUND_TEXTURES = "groundTextures";
	public static final String VAR_GROUND_BLENDING = "blending";
	public static final String VAR_HD_INFERNAL_TEXTURE = "hdInfernalCape";

	@Inject
	private HdPlugin plugin;

	@Inject
	private HdPluginConfig config;

	private static final List<Class<? extends Enum<? extends Enum<?>>>> VAR_ENUMS = List.of(
		SeasonalTheme.class
	);

	@Override
	public Object get(String name) {
		switch (name) {
			case VAR_SEASONAL_THEME:
				return plugin.configSeasonalTheme.ordinal();
			case VAR_MODEL_TEXTURES:
				return plugin.configModelTextures;
			case VAR_GROUND_TEXTURES:
				return plugin.configGroundTextures;
			case VAR_GROUND_BLENDING:
				return plugin.configGroundBlending;
			case VAR_HD_INFERNAL_TEXTURE:
				return config.hdInfernalTexture();
		}

		int i = name.indexOf('.');
		if (i > 0 && i < name.length() - 1) {
			var enumName = name.substring(0, i);
			for (var varEnum : VAR_ENUMS) {
				if (!enumName.equals(varEnum.getSimpleName()))
					continue;

				var enumKey = name.substring(i + 1);
				var enumConstants = varEnum.getEnumConstants();
				for (var enumConstant : enumConstants)
					if (enumKey.equals(enumConstant.name()))
						return enumConstant.ordinal();

				break;
			}
		}

		return null;
	}
}

package rs117.hd.utils;

import java.util.Properties;
import java.util.function.Supplier;
import javax.annotation.Nonnull;
import javax.annotation.meta.When;

import static rs117.hd.utils.ResourcePath.path;

public class Props
{
	public static boolean DEVELOPMENT;

	private static final Properties env = new Properties();

	static {
		env.putAll(System.getProperties());
	}

	public static boolean has(String key)
	{
		return env.containsKey(key);
	}

	public static String get(String key)
	{
		return env.getProperty(key);
	}

	public static String getOrDefault(String key, String defaultValue)
	{
		String value = get(key);
		return value == null ? defaultValue : value;
	}

	public static String getOrDefault(String key, @Nonnull Supplier<String> defaultValueSupplier)
	{
		String value = get(key);
		return value == null ? defaultValueSupplier.get() : value;
	}

	public static boolean getBoolean(String key)
	{
		String value = get(key);
		if (value == null)
			return false;
		if (value.isEmpty())
			return true;
		value = value.toLowerCase();
		return value.equals("true") || value.equals("1") || value.equals("on") || value.equals("yes");
	}

	public static ResourcePath getFile(String key, @Nonnull Supplier<ResourcePath> fallback) {
		var path = get(key);
		return path != null ? path(path) : fallback.get();
	}

	@Nonnull(when = When.UNKNOWN) // Disable downstream null warnings, since they're not smart enough
	public static ResourcePath getFolder(String key, @Nonnull Supplier<ResourcePath> fallback) {
		var path = getFile(key, fallback);
		return path != null ? path.chroot() : null;
	}

	public static void set(String key, boolean value)
	{
		set(key, value ? "true" : "false");
	}

	public static void set(String key, String value)
	{
		if (value == null)
		{
			unset(key);
		}
		else
		{
			env.put(key, value);
		}
	}

	public static void unset(String key)
	{
		env.remove(key);
	}
}

/*
 * Copyright (c) 2025, Hooder <ahooder@protonmail.com>
 * Copyright (c) 2022, Mark <https://github.com/Mark7625>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package rs117.hd.utils;

import com.google.gson.Gson;
import java.awt.Toolkit;
import java.awt.image.BufferedImage;
import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.OutputStream;
import java.io.OutputStreamWriter;
import java.net.URL;
import java.nio.ByteBuffer;
import java.nio.channels.Channels;
import java.nio.channels.ReadableByteChannel;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.Arrays;
import java.util.Objects;
import java.util.Stack;
import java.util.function.BiConsumer;
import java.util.function.BiFunction;
import java.util.function.Consumer;
import java.util.function.Function;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.stream.Collectors;
import javax.annotation.Nonnull;
import javax.annotation.Nullable;
import javax.annotation.RegEx;
import javax.swing.ImageIcon;
import lombok.extern.slf4j.Slf4j;
import org.lwjgl.BufferUtils;
import org.lwjgl.system.MemoryUtil;
import org.lwjgl.system.Platform;

@Slf4j
public class ResourcePath {
	private static final FileWatcher.UnregisterCallback NOOP = () -> {};
	private static final ResourcePath RESOURCE_PATH = Props.getFolder("rlhd.resource-path", () -> null);

	@Nullable
	public final ResourcePath root;
	@Nullable
	public final String path;

	public static ResourcePath path(String... parts) {
		return new ResourcePath(parts);
	}

	public static ResourcePath path(Path path, String... parts) {
		return path(normalize(path.toString(), parts));
	}

	public static ResourcePath path(File file, String... parts) {
		return path(normalize(file.getPath(), parts));
	}

	public static ResourcePath path(Class<?> clazz, String... parts) {
		String path = normalize(clazz.getPackage().getName().replace(".", "/"), parts);
		return path(clazz.getClassLoader(), path);
	}

	public static ResourcePath path(ClassLoader root, String... parts) {
		// Redirect class resources to the specified resource path during development
		if (RESOURCE_PATH != null)
			return RESOURCE_PATH.resolve(parts);

		return new ClassResourcePath(root).resolve(parts);
	}

	private ResourcePath(String... parts) {
		this(null, parts);
	}

	private ResourcePath(@Nonnull ResourcePath root) {
		// Encapsulate the current root and path into a new root ResourcePath.
		// Subsequent path resolutions will not include the encapsulated path.
		this.root = root;
		this.path = null;
	}

	private ResourcePath(@Nullable ResourcePath root, String... parts) {
		this.root = root;
		this.path = normalize(parts);
	}

	public ResourcePath chroot() {
		return new ResourcePath(this);
	}

	public ResourcePath resolve(String... parts) {
		return new ResourcePath(root, normalize(path, parts));
	}

	@SuppressWarnings("ResultOfMethodCallIgnored")
	public ResourcePath mkdirs() {
		var path = this;
		// Assume paths with an extension are file paths, not directories
		if (!getExtension().isEmpty())
			path = path.resolve("..");
		path.toFile().mkdirs();
		return this;
	}

	public boolean exists() {
		if (root != null)
			return root.resolve(path).exists();
		return toFile().exists();
	}

	public String getFilename() {
		if (path == null)
			return "";
		int i = path.lastIndexOf("/");
		if (i != -1)
			return path.substring(i + 1);
		return path;
	}

	public String getExtension() {
		return getExtension(0);
	}

	public String getExtension(int nthLast) {
		String filename = getFilename();
		String extension = "";
		while (nthLast-- >= 0) {
			int i = filename.lastIndexOf('.');
			if (i == -1)
				break;
			extension = filename.substring(i + 1);
			filename = filename.substring(0, i);
		}
		return extension;
	}

	public ResourcePath setExtension(String extension) {
		if (path == null)
			throw new IllegalStateException("Cannot set extension for root path: " + this);

		String path = this.path;
		int i = path.lastIndexOf('.');
		if (i != -1)
			path = path.substring(0, i);

		if (extension != null && !extension.isEmpty())
			path += '.' + extension;

		return new ResourcePath(root, path);
	}

	public boolean matches(@RegEx String posixPathRegex) {
		Pattern p = Pattern.compile(posixPathRegex);
		Matcher m = p.matcher(toPosixPath());
		return m.find();
	}

	@Override
	public String toString() {
		String path = toPosixPath();
		return path.isEmpty() ? "." : path;
	}

	@Override
	public boolean equals(Object obj) {
		// Used for file watcher event deduplication
		return obj instanceof ResourcePath &&
			   Objects.equals(root, ((ResourcePath) obj).root) &&
			   Objects.equals(path, ((ResourcePath) obj).path);
	}

	public String toPosixPath() {
		if (root != null)
			return normalize(root.toPosixPath(), new String[] { path });
		return path;
	}

	public Path toPath() {
		if (root == null) {
			assert path != null;
			return Paths.get(path);
		}

		Path basePath = root.toPath();
		if (path == null)
			return basePath;

		return basePath.resolve(stripLeadingSlash(path));
	}

	public File toFile() {
		if (isFileSystemResource())
			return toPath().toFile();
		throw new IllegalStateException("Not a file: " + this);
	}

	public BufferedReader toReader() throws IOException {
		return new BufferedReader(new InputStreamReader(toInputStream(), StandardCharsets.UTF_8));
	}

	public InputStream toInputStream() throws IOException {
		if (root != null)
			return root.resolve(path).toInputStream();

		try {
			return Files.newInputStream(toPath());
		} catch (IOException ex) {
			throw new IOException("Unable to load resource: " + this, ex);
		}
	}

	public BufferedWriter toWriter() throws IOException {
		return new BufferedWriter(new OutputStreamWriter(toOutputStream(), StandardCharsets.UTF_8));
	}

	public FileOutputStream toOutputStream() throws FileNotFoundException {
		return new FileOutputStream(toFile());
	}

	public boolean isFileSystemResource() {
		if (root != null)
			return root.isFileSystemResource();
		return true;
	}

	/**
	 * Run the callback once at the start & every time the resource (or sub resource) changes.
	 *
	 * @param changeHandler Callback to call once at the start (bool = true) and every time the resource changes (bool = false)
	 * @return A runnable that can be called to unregister the watch callback
	 */
	public FileWatcher.UnregisterCallback watch(BiConsumer<ResourcePath, Boolean> changeHandler) {
		var path = this;

		// Load once up front
		changeHandler.accept(path, true);

		// Watch for changes if the resource is on the file system, which will exclude paths pointing into the JAR.
		// By default, unless paths are overridden by VM arguments, all of 117 HD's paths point into the JAR.
		if (path.isFileSystemResource())
			return FileWatcher.watchPath(path, p -> changeHandler.accept(p, false));

		return NOOP;
	}

	public FileWatcher.UnregisterCallback watch(Consumer<ResourcePath> changeHandler) {
		return watch((path, first) -> changeHandler.accept(path));
	}

	/**
	 * Run the callback once at the start & every time the resource (or sub resource) changes.
	 *
	 * @param changeHandler Callback to call once at the start and every time the resource changes
	 * @return A runnable that can be called to unregister the watch callback
	 */
	public FileWatcher.UnregisterCallback watch(@RegEx String filter, BiConsumer<ResourcePath, Boolean> changeHandler) {
		return watch((path, first) -> {
			if (path.matches(filter))
				changeHandler.accept(path, first);
		});
	}

	public FileWatcher.UnregisterCallback watch(@RegEx String filter, Consumer<ResourcePath> changeHandler) {
		return watch(filter, (path, first) -> changeHandler.accept(path));
	}

	public String loadString() throws IOException {
		try (BufferedReader reader = toReader()) {
			return reader.lines().collect(Collectors.joining(System.lineSeparator()));
		}
	}

	public <T> T loadJson(Gson gson, Class<T> type) throws IOException {
		try (BufferedReader reader = toReader()) {
			return gson.fromJson(reader, type);
		}
	}

	public BufferedImage loadImage() throws IOException {
		try (InputStream is = toInputStream()) {
			byte[] bytes = is.readAllBytes();
			var icon = new ImageIcon(Toolkit.getDefaultToolkit().createImage(bytes));
			var bufferedImage = new BufferedImage(
				icon.getIconWidth(),
				icon.getIconHeight(),
				BufferedImage.TYPE_INT_ARGB
			);
			var g = bufferedImage.createGraphics();
			icon.paintIcon(null, g, 0, 0);
			g.dispose();
			return bufferedImage;
		}
	}

	/**
	 * Reads the full InputStream into a garbage-collected ByteBuffer allocated with BufferUtils.
	 *
	 * @return a ByteBuffer
	 * @throws IOException if the InputStream cannot be read
	 */
	public ByteBuffer loadByteBuffer() throws IOException {
		return readInputStream(toInputStream(), BufferUtils::createByteBuffer, null);
	}

	/**
	 * Reads the full InputStream into a ByteBuffer allocated with malloc, which must be explicitly freed.
	 *
	 * @return a ByteBuffer
	 * @throws IOException if the InputStream cannot be read
	 */
	public ByteBuffer loadByteBufferMalloc() throws IOException {
		return readInputStream(toInputStream(), MemoryUtil::memAlloc, MemoryUtil::memRealloc);
	}

	public ResourcePath writeByteBuffer(ByteBuffer buffer) throws IOException {
		try (var os = toOutputStream(); var channel = os.getChannel()) {
			int bytesToWrite = buffer.remaining();
			int bytesWritten = channel.write(buffer);
			if (bytesWritten < bytesToWrite) {
				throw new IOException(String.format(
					"Only %d out of %d bytes were successfully written to %s",
					bytesWritten, bytesToWrite, this
				));
			}
		}
		return this;
	}

	public ResourcePath writeString(String string) throws IOException {
		try (OutputStream os = toOutputStream()) {
			os.write(string.getBytes(StandardCharsets.UTF_8));
			// Ensure there's always a blank line at the end
			if (!string.endsWith("\n"))
				os.write('\n');
		}
		return this;
	}

	/**
	 * Reads the full InputStream into a garbage-collected ByteBuffer allocated with BufferUtils.
	 *
	 * @param is the InputStream
	 * @return a ByteBuffer
	 * @throws IOException if the InputStream cannot be read
	 */
	private static ByteBuffer readInputStream(
		InputStream is,
		Function<Integer, ByteBuffer> alloc,
		@Nullable BiFunction<ByteBuffer, Integer, ByteBuffer> realloc
	) throws IOException {
		if (realloc == null) {
			realloc = (ByteBuffer oldBuffer, Integer newSize) -> {
				ByteBuffer newBuffer = alloc.apply(newSize);
				newBuffer.put(oldBuffer);
				return newBuffer;
			};
		}

		try (ReadableByteChannel channel = Channels.newChannel(is)) {
			// Read all currently buffered data into a ByteBuffer
			ByteBuffer buffer = alloc.apply(is.available());
			channel.read(buffer);

			// If there's more data available, double the buffer size and round up to the nearest power of 2
			if (is.available() > buffer.remaining()) {
				int newSize = (buffer.position() + is.available()) * 2;
				int nearestPow2 = 2 << (31 - Integer.numberOfLeadingZeros(newSize - 1));
				buffer = realloc.apply(buffer, nearestPow2);
			}

			// Continue reading all bytes, doubling the buffer each time it runs out of space
			while (is.available() > 0)
				if (buffer.remaining() == channel.read(buffer))
					buffer = realloc.apply(buffer, buffer.capacity() * 2);

			channel.close();
			buffer.flip();
			return buffer;
		}
	}

	public static String normalize(String... parts) {
        return normalize(null, parts);
    }

	public static String normalize(@Nullable String workingDirectory, String[] parts) {
        Stack<String> resolvedParts = new Stack<>();
		if (workingDirectory != null && !workingDirectory.isEmpty() && !workingDirectory.equals("."))
			resolvedParts.addAll(Arrays.asList(normalizeSlashes(workingDirectory).split("/")));

		if (parts.length > 0)
			parts[0] = resolveTilde(parts[0]);

		for (String part : parts) {
			if (part == null || part.isEmpty() || part.equals("."))
				continue;

			part = normalizeSlashes(part);

			if (isAbsolute(part))
				resolvedParts.clear();

			for (String normalizedPart : part.split("/")) {
				if (normalizedPart.equals("..") &&
					!resolvedParts.isEmpty() &&
					!resolvedParts.peek().equals("..")
				) {
					resolvedParts.pop();
				} else {
					resolvedParts.push(normalizedPart);
				}
			}
		}

		return String.join("/", resolvedParts);
	}

	private static String normalizeSlashes(String path) {
		if (Platform.get() == Platform.WINDOWS)
			return path.replace("\\", "/");
		return path;
	}

	private static String resolveTilde(String path) {
		// Note: We only support ~ and ~user tilde expansion
		if (path == null || !path.startsWith("~"))
			return path;

		int slashIndex = path.indexOf('/');
		String specifiedUser = path.substring(1, slashIndex == -1 ? path.length() : slashIndex);
		String userHome = System.getProperty("user.home");
		if (userHome == null)
			throw new RuntimeException("Unable to resolve tilde path: " + path);

		Path home = Paths.get(userHome);

		// Check if the home path of a different user was specified
		if (!specifiedUser.isEmpty()) {
			// Assume the username matches the home folder name,
			// and that it's located next to the current user's home directory
			home = home.resolve("../" + specifiedUser);
		}

		if (slashIndex == -1)
			return home.toString();
		return home.resolve(path.substring(slashIndex + 1)).toString();
	}

	private static String stripLeadingSlash(String path) {
		return path.startsWith("/") ? path.substring(1) : path;
	}

	/**
	 * Expects forward slashes as path delimiter, but accepts Windows-style drive letter prefixes.
	 */
	private static boolean isAbsolute(String path) {
		if (Platform.get() == Platform.WINDOWS)
			path = path.replaceFirst("^\\w:", "");
		return path.startsWith("/");
	}

	private static class ClassResourcePath extends ResourcePath {
		public final ClassLoader classLoader;

		private ClassResourcePath(@Nonnull ClassLoader classLoader, String... parts) {
			super(parts);
			this.classLoader = classLoader;
		}

		@Override
		public ResourcePath resolve(String... parts) {
			return new ClassResourcePath(classLoader, normalize(path, parts));
		}

		private URL toResource() {
			assert path != null;
			return classLoader.getResource(stripLeadingSlash(path));
		}

		@Override
		public boolean exists() {
			return toResource() != null;
		}

		@Override
		public InputStream toInputStream() throws IOException {
			var url = toResource();
			if (url == null)
				throw new IOException("Unable to load resource: " + this);
			return url.openStream();
		}

		@Override
		public boolean isFileSystemResource() {
			return false;
		}
	}
}

/*
 * Copyright (c) 2018, Adam <Adam@sigterm.info>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package rs117.hd.utils.buffer;

import java.nio.IntBuffer;
import org.lwjgl.system.MemoryUtil;
import rs117.hd.HdPlugin;

public class GpuIntBuffer
{
	private IntBuffer buffer;

	public GpuIntBuffer()
	{
		this(65536);
	}

	public GpuIntBuffer(int initialCapacity) {
		try {
			buffer = MemoryUtil.memAllocInt(initialCapacity);
		} catch (OutOfMemoryError oom) {
			// Force garbage collection and try again
			System.gc();
			buffer = MemoryUtil.memAllocInt(initialCapacity);
		}
	}

	public void destroy() {
		if (buffer != null)
			MemoryUtil.memFree(buffer);
		buffer = null;
	}

	@Override
	@SuppressWarnings("deprecation")
	protected void finalize() {
		destroy();
	}

	public void put(int x, int y, int z) {
		buffer.put(x).put(y).put(z);
	}

	public void put(float x, float y, float z, int w) {
		buffer
			.put(Float.floatToIntBits(x))
			.put(Float.floatToIntBits(y))
			.put(Float.floatToIntBits(z))
			.put(w);
	}

	public void put(int[] ints) {
		buffer.put(ints);
	}

	public void put(IntBuffer buffer) {
		this.buffer.put(buffer);
	}

	public int position()
	{
		return buffer.position();
	}

	public void flip() {
		buffer.flip();
	}

	public GpuIntBuffer clear() {
		buffer.clear();
		return this;
	}

	public int capacity() {
		return buffer.capacity();
	}

	public GpuIntBuffer ensureCapacity(int size) {
		int capacity = buffer.capacity();
		final int position = buffer.position();
		if ((capacity - position) < size) {
			do {
				capacity = (int) (capacity * HdPlugin.BUFFER_GROWTH_MULTIPLIER);
			}
			while ((capacity - position) < size);

			IntBuffer newB = MemoryUtil.memAllocInt(capacity);
			buffer.flip();
			newB.put(buffer);
			MemoryUtil.memFree(buffer);
			buffer = newB;
		}

		return this;
	}

	public IntBuffer getBuffer()
	{
		return buffer;
	}
}

/*
 * Copyright (c) 2018, Adam <Adam@sigterm.info>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package rs117.hd.utils.buffer;

import java.nio.FloatBuffer;
import org.lwjgl.system.MemoryUtil;
import rs117.hd.HdPlugin;

public class GpuFloatBuffer
{
	private FloatBuffer buffer;

	public GpuFloatBuffer()
	{
		this(65536);
	}

	public GpuFloatBuffer(int initialCapacity) {
		try {
			buffer = MemoryUtil.memAllocFloat(initialCapacity);
		} catch (OutOfMemoryError oom) {
			// Force garbage collection and try again
			System.gc();
			buffer = MemoryUtil.memAllocFloat(initialCapacity);
		}
	}

	public void destroy() {
		if (buffer != null)
			MemoryUtil.memFree(buffer);
		buffer = null;
	}

	@Override
	@SuppressWarnings("deprecation")
	protected void finalize() {
		destroy();
	}

	public void put(float x, float y, float z, float w) {
		buffer.put(x).put(y).put(z).put(w);
	}

	public void put(float x, float y, float z, int w) {
		buffer.put(x).put(y).put(z).put(Float.intBitsToFloat(w));
	}

	public void put(float[] floats) {
		buffer.put(floats);
	}

	public void put(FloatBuffer buffer) {
		this.buffer.put(buffer);
	}

	public int position()
	{
		return buffer.position();
	}

	public void flip() {
		buffer.flip();
	}

	public GpuFloatBuffer clear() {
		buffer.clear();
		return this;
	}

	public int capacity() {
		return buffer.capacity();
	}

	public void ensureCapacity(int size) {
		int capacity = buffer.capacity();
		final int position = buffer.position();
		if ((capacity - position) < size) {
			do {
				capacity = (int) (capacity * HdPlugin.BUFFER_GROWTH_MULTIPLIER);
			}
			while ((capacity - position) < size);

			FloatBuffer newB = MemoryUtil.memAllocFloat(capacity);
			buffer.flip();
			newB.put(buffer);
			MemoryUtil.memFree(buffer);
			buffer = newB;
		}
	}

	public FloatBuffer getBuffer()
	{
		return buffer;
	}
}

package rs117.hd.utils.buffer;

import java.nio.IntBuffer;
import rs117.hd.opengl.compute.OpenCLManager;

import static org.lwjgl.opencl.CL10.*;
import static org.lwjgl.opencl.CL10GL.clCreateFromGLBuffer;

public class SharedGLBuffer extends GLBuffer {
	public final int clUsage;

	public long clId;

	public SharedGLBuffer(String name, int target, int glUsage, int clUsage) {
		super(name, target, glUsage);
		this.clUsage = clUsage;
	}

	private void releaseCLBuffer() {
		if (clId != 0)
			clReleaseMemObject(clId);
		clId = 0;
	}

	@Override
	public void destroy() {
		releaseCLBuffer();
		super.destroy();
	}

	@Override
	public void ensureCapacity(long byteOffset, long numBytes) {
		super.ensureCapacity(byteOffset, numBytes);
		if (OpenCLManager.context == 0)
			return;

		releaseCLBuffer();

		// OpenCL does not allow 0-size GL buffers, it will segfault on macOS
		if (size != 0)
			clId = clCreateFromGLBuffer(OpenCLManager.context, clUsage, id, (IntBuffer) null);
	}
}

/*
 * Copyright (c) 2021, Adam <Adam@sigterm.info>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package rs117.hd.utils.buffer;

import java.nio.ByteBuffer;
import java.nio.FloatBuffer;
import java.nio.IntBuffer;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.lwjgl.opengl.*;
import rs117.hd.HdPlugin;
import rs117.hd.utils.HDUtils;

import static org.lwjgl.opengl.GL33C.*;
import static rs117.hd.HdPlugin.checkGLErrors;
import static rs117.hd.utils.MathUtils.*;

@Slf4j
@RequiredArgsConstructor
public class GLBuffer
{
	public final String name;
	public final int target;
	public final int usage;

	public int id;
	public long size;

	public void initialize() {
		initialize(0);
	}

	public void initialize(long initialCapacity) {
		id = glGenBuffers();
		// Initialize both GL and CL buffers to buffers of a single byte or more,
		// to ensure that valid buffers are given to compute dispatches.
		// This is particularly important on Apple M2 Max, where an uninitialized buffer leads to a crash
		ensureCapacity(max(1, initialCapacity));
	}

	public void destroy() {
		size = 0;

		if (id != 0) {
			glDeleteBuffers(id);
			id = 0;
		}
	}

	public void ensureCapacity(long numBytes) {
		ensureCapacity(0, numBytes);
	}

	public void ensureCapacity(long byteOffset, long numBytes) {
		numBytes += byteOffset;
		if (numBytes <= size) {
			glBindBuffer(target, id);
			return;
		}

		numBytes = HDUtils.ceilPow2(numBytes);
		if (log.isDebugEnabled() && numBytes > 1e6)
			log.debug("Resizing buffer '{}'\t{}", name, String.format("%.2f MB -> %.2f MB", size / 1e6, numBytes / 1e6));

		if (byteOffset > 0) {
			// Create a new buffer and copy the old data to it
			int oldBuffer = id;
			id = glGenBuffers();
			glBindBuffer(target, id);
			glBufferData(target, numBytes, usage);

			glBindBuffer(GL_COPY_READ_BUFFER, oldBuffer);
			glCopyBufferSubData(GL_COPY_READ_BUFFER, target, 0, 0, byteOffset);
			glDeleteBuffers(oldBuffer);
		} else {
			glBindBuffer(target, id);
			glBufferData(target, numBytes, usage);
		}

		size = numBytes;

		if (log.isDebugEnabled() && HdPlugin.GL_CAPS.OpenGL43) {
			GL43C.glObjectLabel(GL43C.GL_BUFFER, id, name);
			checkGLErrors();
		}
	}

	public void upload(ByteBuffer data) {
		upload(data, 0);
	}

	public void upload(ByteBuffer data, long byteOffset) {
		long numBytes = data.remaining();
		ensureCapacity(byteOffset, numBytes);
		glBufferSubData(target, byteOffset, data);
	}

	public void upload(IntBuffer data) {
		upload(data, 0);
	}

	public void upload(IntBuffer data, long byteOffset) {
		long numBytes = 4L * data.remaining();
		ensureCapacity(byteOffset, numBytes);
		glBufferSubData(target, byteOffset, data);
	}

	public void upload(FloatBuffer data) {
		upload(data, 0);
	}

	public void upload(FloatBuffer data, long byteOffset) {
		long numBytes = 4L * data.remaining();
		ensureCapacity(byteOffset, numBytes);
		glBufferSubData(target, byteOffset, data);
	}

	public void upload(GpuIntBuffer data) {
		upload(data.getBuffer());
	}

	public void upload(GpuIntBuffer data, long byteOffset) {
		upload(data.getBuffer(), byteOffset);
	}

	public void upload(GpuFloatBuffer data) {
		upload(data.getBuffer());
	}

	public void upload(GpuFloatBuffer data, long byteOffset) {
		upload(data.getBuffer(), byteOffset);
	}
}

/*
 * Copyright (c) 2021, 117 <https://twitter.com/117scape>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package rs117.hd.utils;

import javax.inject.Singleton;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.*;
import rs117.hd.data.ObjectType;
import rs117.hd.scene.areas.AABB;
import rs117.hd.scene.areas.Area;

import static net.runelite.api.Constants.*;
import static net.runelite.api.Constants.SCENE_SIZE;
import static net.runelite.api.Perspective.*;
import static rs117.hd.scene.ProceduralGenerator.VERTICES_PER_FACE;
import static rs117.hd.scene.ProceduralGenerator.faceLocalVertices;
import static rs117.hd.scene.ProceduralGenerator.isOverlayFace;
import static rs117.hd.utils.MathUtils.*;

@Slf4j
@Singleton
public class HDUtils {
	public static final int HIDDEN_HSL = 12345678;

	public static int vertexHash(int[] vPos) {
		// simple custom hashing function for vertex position data
		StringBuilder s = new StringBuilder();
		for (int part : vPos)
			s.append(part).append(",");
		return s.toString().hashCode();
	}

	public static float[] calculateSurfaceNormals(float[] a, float[] b, float[] c) {
		subtract(b, a, b);
		subtract(c, a, c);
		return cross(b, c);
	}

	public static long ceilPow2(long l) {
		assert l >= 0;
		l--; // Reduce by 1 in case it's already a power of 2
		// Fill in all bits below the highest active bit
		for (int i = 1; i <= 32; i *= 2)
			l |= l >> i;
		return l + 1; // Bump it up to the next power of 2
	}

	public static float[] sunAngles(float altitude, float azimuth) {
		return multiply(vec(altitude, azimuth), DEG_TO_RAD);
	}

	public static float[] ensureArrayLength(float[] array, int targetLength) {
		return array.length == targetLength ? array : slice(array, 0, targetLength);
	}

	public static int convertWallObjectOrientation(int orientation) {
		// Note: this is still imperfect, since the model rotation of a wall object depends on more than just the config orientation,
		// 		 i.e. extra rotation depending on wall type whatever. I'm not sure.
		// Derived from config orientation {@link HDUtils#getBakedOrientation}
		switch (orientation) {
			case 1:
				return 512; // west
			case 2:
				return 1024; // north
			case 4:
				return 1536; // east
			case 8:
			default:
				return 0; // south
			case 16:
				return 768; // north-west
			case 32:
				return 1280; // north-east
			case 64:
				return 1792; // south-east
			case 128:
				return 256; // south-west
		}
	}

	// (gameObject.getConfig() >> 6) & 3, // 2-bit orientation
	// (gameObject.getConfig() >> 8) & 1, // 1-bit interactType != 0 (supports items)
	// (gameObject.getConfig() >> 9) // should always be zero

	/**
	 * Computes the orientation used when uploading the model.
	 * This does not include the extra 45-degree rotation of diagonal models.
	 */
	public static int getModelPreOrientation(int config) {
		var objectType = ObjectType.fromConfig(config);
		int orientation = 1024 + 512 * (config >>> 6 & 3);
		switch (objectType) {
			case WallDiagonalCorner:
			case WallSquareCorner:
			case WallDecorDiagonalOffset:
			case WallDecorDiagonalBoth:
				orientation += 1024;
		}
		return orientation % 2048;
	}

	/**
	 * Computes the complete model orientation, including the pre-orientation when uploading,
	 * and the extra 45-degree rotation of diagonal models.
	 */
	public static int getModelOrientation(int config) {
		int orientation = getModelPreOrientation(config);
		var objectType = ObjectType.fromConfig(config);
		switch (objectType) {
			case WallDecorDiagonalNoOffset:
			case CentrepieceDiagonal:
				orientation += 256;
		}
		return orientation % 2048;
	}

	/**
	 * Returns the south-west coordinate of the scene in world coordinates, after resolving instance template
	 * chunks to their original world coordinates. If the scene is instanced, the base coordinates are computed from
	 * the center chunk instead, or any valid chunk if the center chunk is invalid.
	 *
	 * @param scene to get the south-west coordinate for
	 * @param plane to use when resolving instance template chunks
	 * @return the south-western coordinate of the scene in world space
	 */
	public static int[] getSceneBaseBestGuess(Scene scene, int plane) {
		int baseX = scene.getBaseX();
		int baseY = scene.getBaseY();

		if (scene.isInstance()) {
			// Assume the player is loaded into the center chunk, and calculate the world space position of the lower
			// left corner of the scene, assuming well-behaved template chunks are used to create the instance.
			int chunkX = 6, chunkY = 6;
			int[][] chunks = scene.getInstanceTemplateChunks()[plane];
			int chunk = chunks[chunkX][chunkY];
			if (chunk == -1) {
				// If the center chunk is invalid, pick any valid chunk and hope for the best
				outer:
				for (chunkX = 0; chunkX < chunks.length; chunkX++) {
					for (chunkY = 0; chunkY < chunks[chunkX].length; chunkY++) {
						chunk = chunks[chunkX][chunkY];
						if (chunk != -1)
							break outer;
					}
				}
			}

			if (chunk != -1) {
				// Extract chunk coordinates
				baseX = chunk >> 14 & 0x3FF;
				baseY = chunk >> 3 & 0x7FF;
				// Shift to what would be the lower left corner chunk if the template chunks were contiguous on the map
				baseX -= chunkX;
				baseY -= chunkY;
				// Transform to world coordinates
				baseX <<= 3;
				baseY <<= 3;
			}
		}

		return ivec(baseX, baseY, 0);
	}

	/**
	 * The returned plane may be different
	 */
	public static int[] localToWorld(Scene scene, int localX, int localY, int plane) {
		return sceneToWorld(scene, localX >> LOCAL_COORD_BITS, localY >> LOCAL_COORD_BITS, plane);
	}

	/**
	 * The returned plane may be different
	 */
	public static int[] sceneToWorld(Scene scene, int sceneX, int sceneY, int plane) {
		if (scene.isInstance()) {
			if (sceneX >= 0 && sceneY >= 0 && sceneX < SCENE_SIZE && sceneY < SCENE_SIZE) {
				int chunkX = sceneX / CHUNK_SIZE;
				int chunkY = sceneY / CHUNK_SIZE;
				int templateChunk = scene.getInstanceTemplateChunks()[plane][chunkX][chunkY];
				if (templateChunk != -1) {
					int rotation = 4 - (templateChunk >> 1 & 3);
					int templateChunkY = (templateChunk >> 3 & 2047) * 8;
					int templateChunkX = (templateChunk >> 14 & 1023) * 8;
					int templateChunkPlane = templateChunk >> 24 & 3;
					int worldX = templateChunkX + (sceneX & 7);
					int worldY = templateChunkY + (sceneY & 7);

					int[] pos = { worldX, worldY, templateChunkPlane };

					chunkX = pos[0] & -8;
					chunkY = pos[1] & -8;
					int x = pos[0] & 7;
					int y = pos[1] & 7;
					switch (rotation) {
						case 1:
							pos[0] = chunkX + y;
							pos[1] = chunkY + (7 - x);
							break;
						case 2:
							pos[0] = chunkX + (7 - x);
							pos[1] = chunkY + (7 - y);
							break;
						case 3:
							pos[0] = chunkX + (7 - y);
							pos[1] = chunkY + x;
							break;
					}

					return pos;
				}
			}
			return ivec(-1, -1, 0);
		}

		return ivec(scene.getBaseX() + sceneX, scene.getBaseY() + sceneY, plane);
	}

	public static int worldToRegionID(int[] worldPoint) {
		return worldToRegionID(worldPoint[0], worldPoint[1]);
	}

	public static int worldToRegionID(int worldX, int worldY) {
		return worldX >> 6 << 8 | worldY >> 6;
	}

	public static boolean is32Bit() {
		return System.getProperty("sun.arch.data.model", "Unknown").equals("32");
	}

	public static boolean sceneIntersects(Scene scene, int numChunksExtended, Area area) {
		return sceneIntersects(scene, numChunksExtended, area.aabbs);
	}

	public static boolean sceneIntersects(Scene scene, int numChunksExtended, AABB... aabbs) {
		if (scene.isInstance()) {
			var templateChunks = scene.getInstanceTemplateChunks();
			for (var plane : templateChunks) {
				for (var column : plane) {
					for (int chunk : column) {
						if (chunk == -1)
							continue;

						int chunkX = chunk >> 14 & 1023;
						int chunkY = chunk >> 3 & 2047;
						int minX = chunkX * CHUNK_SIZE;
						int minY = chunkY * CHUNK_SIZE;
						int maxX = (chunkX + 1) * CHUNK_SIZE - 1;
						int maxY = (chunkY + 1) * CHUNK_SIZE - 1;

						for (var aabb : aabbs)
							if (aabb.intersects(minX, minY, maxX, maxY))
								return true;
					}
				}
			}

			return false;
		}

		return getNonInstancedSceneBounds(scene, numChunksExtended).intersects(aabbs);
	}

	public static AABB getNonInstancedSceneBounds(Scene scene, int numChunksExtended) {
		assert !scene.isInstance();
		int baseX = scene.getBaseX();
		int baseY = scene.getBaseY();
		int extended = numChunksExtended * CHUNK_SIZE;
		return new AABB(
			baseX - extended,
			baseY - extended,
			baseX + SCENE_SIZE + extended - 1,
			baseY + SCENE_SIZE + extended - 1
		);
	}

	public static int getSouthWesternMostTileColor(int[] out, Tile tile) {
		var paint = tile.getSceneTilePaint();
		var model = tile.getSceneTileModel();
		int hsl = 0;
		if (paint != null) {
			hsl = paint.getSwColor();
			ColorUtils.unpackRawHsl(out, hsl);
		} else if (model != null) {
			int faceCount = tile.getSceneTileModel().getFaceX().length;
			final int[] faceColorsA = model.getTriangleColorA();
			final int[] faceColorsB = model.getTriangleColorB();
			final int[] faceColorsC = model.getTriangleColorC();

			outer:
			for (int face = 0; face < faceCount; face++) {
				if (isOverlayFace(tile, face))
					continue;

				int[][] vertices = faceLocalVertices(tile, face);
				int[] faceColors = new int[] { faceColorsA[face], faceColorsB[face], faceColorsC[face] };

				for (int vertex = 0; vertex < VERTICES_PER_FACE; vertex++) {
					hsl = faceColors[vertex];
					if (vertices[vertex][0] != LOCAL_TILE_SIZE && vertices[vertex][1] != LOCAL_TILE_SIZE)
						break outer;
				}
			}

			ColorUtils.unpackRawHsl(out, hsl);
		}
		return hsl;
	}
}

package rs117.hd.utils;

import java.awt.BorderLayout;
import java.awt.Desktop;
import java.awt.FlowLayout;
import java.awt.Image;
import java.awt.Point;
import java.awt.image.BufferedImage;
import java.io.IOException;
import java.net.URISyntaxException;
import java.util.function.Function;
import javax.swing.BorderFactory;
import javax.swing.ImageIcon;
import javax.swing.JButton;
import javax.swing.JEditorPane;
import javax.swing.JFrame;
import javax.swing.JLabel;
import javax.swing.JPanel;
import javax.swing.JScrollPane;
import javax.swing.ScrollPaneConstants;
import javax.swing.SwingUtilities;
import javax.swing.event.HyperlinkEvent;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.*;
import rs117.hd.HdPlugin;

import static rs117.hd.utils.ResourcePath.path;

@Slf4j
public class PopupUtils {
	public static void displayPopupMessage(
		Client client,
		String title,
		String message,
		String[] buttonLabels,
		Function<Integer, Boolean> buttonIndexConsumer
	) {
		SwingUtilities.invokeLater(() -> {
			JFrame frame = new JFrame(title);

			JPanel mainPanel = new JPanel(new BorderLayout());
			mainPanel.setBorder(BorderFactory.createEmptyBorder(16, 0, 8, 8));

			try {
				BufferedImage logoImage = path(HdPlugin.class, "logo.png").loadImage();
				frame.setIconImage(logoImage);
				Image logoScaled = logoImage.getScaledInstance(96, -1, Image.SCALE_SMOOTH);
				JLabel logoLabel = new JLabel(new ImageIcon(logoScaled));
				logoLabel.setBorder(BorderFactory.createEmptyBorder(0, 8, 0, 8));
				mainPanel.add(logoLabel, BorderLayout.LINE_START);
			} catch (IOException ex) {
				log.error("Unable to load HD logo: ", ex);
			}

			String html = String.format("<html><style>a { color: #dc8a00; }</style><body>%s</body></html>", message);
			JEditorPane messagePane = new JEditorPane("text/html", html);
			messagePane.setBorder(BorderFactory.createEmptyBorder());
			messagePane.setHighlighter(null);
			messagePane.setEditable(false);
			messagePane.setOpaque(false);
			messagePane.addHyperlinkListener(e -> {
				if (Desktop.isDesktopSupported() && e.getEventType().equals(HyperlinkEvent.EventType.ACTIVATED)) {
					try {
						Desktop.getDesktop().browse(e.getURL().toURI());
					} catch (IOException | URISyntaxException ex) {
						log.error("Unable to open link: {}", e.getURL().toString(), ex);
					}
                }
            });

			JScrollPane scrollPane = new JScrollPane(messagePane);
            scrollPane.setViewportBorder(BorderFactory.createEmptyBorder());
            scrollPane.setBorder(BorderFactory.createEmptyBorder());
			scrollPane.setOpaque(false);
			scrollPane.getViewport().setOpaque(false);
			scrollPane.setVerticalScrollBarPolicy(ScrollPaneConstants.VERTICAL_SCROLLBAR_AS_NEEDED);
			scrollPane.setHorizontalScrollBarPolicy(ScrollPaneConstants.HORIZONTAL_SCROLLBAR_NEVER);
			mainPanel.add(scrollPane, BorderLayout.CENTER);

            JPanel buttonPanel = new JPanel(new FlowLayout(FlowLayout.RIGHT, 8, 8));
            for (int i = 0; i < buttonLabels.length; i++) {
                JButton button = new JButton(buttonLabels[i]);
                int index = i;
				button.addActionListener(actionEvent -> {
					if (buttonIndexConsumer.apply(index))
						frame.setVisible(false);
				});
				buttonPanel.add(button);
            }

            JPanel framePanel = new JPanel(new BorderLayout());
            framePanel.add(mainPanel, BorderLayout.CENTER);
            framePanel.add(buttonPanel, BorderLayout.PAGE_END);

            frame.setContentPane(framePanel);
            frame.pack();
            frame.setResizable(false);

            frame.setLocationRelativeTo(client.getCanvas());
            Point point = frame.getLocation();
            frame.setLocation(point.x + 5, point.y + (Constants.GAME_FIXED_HEIGHT - client.getCanvasHeight()) / 2 - 3);
            frame.setAutoRequestFocus(true);

            JFrame runeLiteWindow = (JFrame) SwingUtilities.getWindowAncestor(client.getCanvas());
            if (runeLiteWindow.isAlwaysOnTop())
                frame.setAlwaysOnTop(true);

            frame.setVisible(true);
        });
    }
}

/*
 * Copyright (c) 2022, Hooder <ahooder@protonmail.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package rs117.hd.utils;

import com.google.common.collect.ArrayListMultimap;
import com.google.common.collect.ListMultimap;
import java.io.File;
import java.io.IOException;
import java.nio.file.ClosedWatchServiceException;
import java.nio.file.FileSystems;
import java.nio.file.FileVisitResult;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.SimpleFileVisitor;
import java.nio.file.WatchEvent;
import java.nio.file.WatchKey;
import java.nio.file.WatchService;
import java.nio.file.attribute.BasicFileAttributes;
import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.DelayQueue;
import java.util.concurrent.Delayed;
import java.util.concurrent.TimeUnit;
import java.util.function.Consumer;
import javax.annotation.Nonnull;
import lombok.AllArgsConstructor;
import lombok.extern.slf4j.Slf4j;

import static java.nio.file.StandardWatchEventKinds.ENTRY_CREATE;
import static java.nio.file.StandardWatchEventKinds.ENTRY_DELETE;
import static java.nio.file.StandardWatchEventKinds.ENTRY_MODIFY;
import static java.nio.file.StandardWatchEventKinds.OVERFLOW;
import static rs117.hd.utils.ResourcePath.path;

@Slf4j
public class FileWatcher {
	private static final WatchEvent.Kind<?>[] eventKinds = { ENTRY_CREATE, ENTRY_DELETE, ENTRY_MODIFY };

	private static Thread watcherThread;
	private static Thread runnerThread;
	private static WatchService watchService;
	private static final HashMap<WatchKey, Path> watchKeys = new HashMap<>();
	private static final ListMultimap<String, Consumer<ResourcePath>> changeHandlers = ArrayListMultimap.create();
	private static final DelayQueue<PendingChange> pendingChanges = new DelayQueue<>();

	@AllArgsConstructor
	private static class PendingChange implements Delayed {
		final ResourcePath path;
		final Consumer<ResourcePath> handler;
		long delayUntilMillis;

		@Override
		public boolean equals(Object obj) {
			return
				obj instanceof PendingChange &&
				path.equals(((PendingChange) obj).path) &&
				handler.equals(((PendingChange) obj).handler);
		}

		@Override
		public long getDelay(TimeUnit timeUnit) {
			return timeUnit.convert(delayUntilMillis - System.currentTimeMillis(), TimeUnit.MILLISECONDS);
		}

		@Override
		public int compareTo(Delayed delayed) {
			return (int) (getDelay(TimeUnit.MILLISECONDS) - delayed.getDelay(TimeUnit.MILLISECONDS));
		}
	}

	private static void initialize() throws IOException {
		watchService = FileSystems.getDefault().newWatchService();
		watcherThread = new Thread(() -> {
			try {
				WatchKey watchKey;
				while ((watchKey = watchService.take()) != null) {
					Path dir = watchKeys.get(watchKey);
					if (dir == null) {
						log.error("Unknown WatchKey: {}", watchKey);
						continue;
					}
					for (WatchEvent<?> event : watchKey.pollEvents()) {
						if (event.kind() == OVERFLOW)
							continue;

						Path path = dir.resolve((Path) event.context());
						if (path.toString().endsWith("~")) // Ignore temp files
							continue;

						log.trace("WatchEvent of kind {} for path {}", event.kind(), path);

						try {
							// Manually register new sub folders if not watching a file tree
							if (event.kind() == ENTRY_CREATE && path.toFile().isDirectory())
								watchRecursively(path);

							String key = path.toString();
							ResourcePath resourcePath = path(key);
							if (path.toFile().isDirectory())
								key += File.separator;

							for (Map.Entry<String, Consumer<ResourcePath>> entry : changeHandlers.entries())
								if (key.startsWith(entry.getKey()))
									queuePendingChange(resourcePath, entry.getValue());
						} catch (Exception ex) {
							log.error("Error while handling file change event:", ex);
						}
					}
					watchKey.reset();
				}
			} catch (ClosedWatchServiceException ignored) {
			} catch (InterruptedException ex) {
				log.error("Watcher thread interrupted", ex);
			}
		}, FileWatcher.class.getSimpleName() + " Watcher");
		watcherThread.setDaemon(true);
		watcherThread.start();

		runnerThread = new Thread(() -> {
			try {
				PendingChange pending;
				while ((pending = pendingChanges.poll(100, TimeUnit.DAYS)) != null) {
					try {
						pending.handler.accept(pending.path);
					} catch (Throwable throwable) {
						log.error("Error in change handler for path: {}", pending.path, throwable);
					}
				}
			} catch (InterruptedException ignored) {
			}
		}, FileWatcher.class.getSimpleName() + " Runner");
		runnerThread.setDaemon(true);
		runnerThread.start();
	}

	private static void queuePendingChange(ResourcePath path, Consumer<ResourcePath> handler) {
		var pendingChange = new PendingChange(path, handler, System.currentTimeMillis() + 200);
		var ignored = pendingChanges.remove(pendingChange);
		pendingChanges.add(pendingChange);
	}

	public static void destroy() {
		if (watchService == null)
			return;

		try {
			log.debug("Shutting down {}", FileWatcher.class.getSimpleName());
			changeHandlers.clear();
			watchKeys.clear();
			watchService.close();
			watchService = null;
			if (watcherThread.isAlive())
				watcherThread.join();
			runnerThread.interrupt();
			if (runnerThread.isAlive())
				runnerThread.join();
		} catch (IOException | InterruptedException ex) {
			throw new RuntimeException("Error while closing " + FileWatcher.class.getSimpleName(), ex);
		}
	}

	@FunctionalInterface
	public interface UnregisterCallback {
		void unregister();
	}

	public static UnregisterCallback watchPath(@Nonnull ResourcePath resourcePath, @Nonnull Consumer<ResourcePath> changeHandler)
	{
		if (!resourcePath.isFileSystemResource())
			throw new IllegalStateException("Only resources on the file system can be watched: " + resourcePath);

		try {
			if (watchService == null)
				initialize();

			Path path = resourcePath.toPath();

			final String key;
			final Consumer<ResourcePath> handler;
			if (path.toFile().isDirectory()) {
				watchRecursively(path);
				key = path + File.separator;
				handler = changeHandler;
			} else {
				watchFile(path);
				key = path.toString();
				handler = changed -> {
					try {
						if (Files.isSameFile(changed.toPath(), resourcePath.toPath()))
							changeHandler.accept(changed);
					} catch (IOException ex) {
						throw new RuntimeException(ex);
					}
				};
			}

			changeHandlers.put(key, handler);
			return () -> changeHandlers.remove(key, handler);
		} catch (IOException ex) {
			throw new RuntimeException("Failed to initialize " + FileWatcher.class.getSimpleName(), ex);
		}
	}

	private static void watchFile(Path path) {
		Path dir = path.getParent();
		try {
			watchKeys.put(dir.register(watchService, eventKinds), dir);
			log.debug("Watching {}", path);
		} catch (Exception ex) {
			throw new RuntimeException("Failed to register file watcher for path: " + path, ex);
		}
	}

	private static void watchRecursively(Path path) {
		try {
			log.debug("Watching {}", path);
			Files.walkFileTree(path, new SimpleFileVisitor<>() {
				@Override
				public FileVisitResult preVisitDirectory(Path dir, BasicFileAttributes attrs) throws IOException {
					WatchKey key = dir.register(watchService, eventKinds);
					watchKeys.put(key, dir);
					return FileVisitResult.CONTINUE;
				}
			});
		} catch (Exception ex) {
			throw new RuntimeException("Failed to register recursive file watcher for path: " + path, ex);
		}
	}
}

package rs117.hd.utils;

import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Set;
import javax.inject.Inject;
import javax.inject.Singleton;
import net.runelite.api.*;
import rs117.hd.scene.GamevalManager;

@Singleton
public class NpcDisplacementCache {
	private static final int MAX_SIZE = 100;
	private static final Set<String> ANIM_IGNORE_LIST = Set.of("HOVER", "FLY", "IMPLING", "SWAN", "DUCK", "SWIM");

	@Inject
	private GamevalManager gamevalManager;

	public static class Entry {
		public boolean canDisplace;
		public int idleRadius;
		public long lastAccessMs;

		{
			reset();
		}

		public Entry reset() {
			canDisplace = true;
			idleRadius = -1;
			lastAccessMs = 0;
			return this;
		}
	}

	private final HashMap<Integer, Entry> cache = new HashMap<>(MAX_SIZE);
	private Set<Integer> ANIM_ID_IGNORE_LIST = Collections.emptySet();

	public void initialize() {
		HashSet<Integer> idsToIgnore = new HashSet<>();
		for (var substringToIgnore : ANIM_IGNORE_LIST)
			for (var entry : gamevalManager.getAnims().entrySet())
				if (entry.getKey().contains(substringToIgnore))
					idsToIgnore.add(entry.getValue());
		ANIM_ID_IGNORE_LIST = Set.copyOf(idsToIgnore);
	}

	public void destroy() {
		ANIM_ID_IGNORE_LIST = Collections.emptySet();
		cache.clear();
	}

	public int size() {
		return cache.size();
	}

	public void clear() {
		cache.clear();
	}

	public Entry get(NPC npc) {
		int npcId = npc.getId();
		var entry = cache.get(npcId);

		if (entry == null) {
			if (cache.size() >= NpcDisplacementCache.MAX_SIZE) {
				long oldestMs = Long.MAX_VALUE;
				int oldestNpcId = -1;
				for (var e : cache.entrySet())
					if (e.getValue().lastAccessMs < oldestMs)
						oldestNpcId = e.getKey();
				entry = cache.remove(oldestNpcId).reset();
			} else {
				entry = new NpcDisplacementCache.Entry();
			}
			cache.put(npcId, entry);

			// Check if NPC is allowed to displace
			int animId = npc.getWalkAnimation();
			entry.canDisplace = animId == -1 || !ANIM_ID_IGNORE_LIST.contains(animId);
		}

		entry.lastAccessMs = System.currentTimeMillis();
		return entry;
	}
}

package rs117.hd.utils;

import javax.annotation.Nullable;
import net.runelite.api.*;

import static rs117.hd.utils.MathUtils.*;

public class ModelHash {
	// Model hashes are composed as follows:
	// | 12-bit worldView | 32-bit id or index | 1-bit wall | 3-bit type | 2-bit plane | 7-bit sceneY | 7-bit sceneX |
	//
	// type:
	// - 0 = player
	// - 1 = NPC
	// - 2 = object
	// - 3 = ground item
	//
	// id_or_index for different types:
	// - player = index
	// - NPC = index
	// - object = id
	// - ground item = always zero

	public static final int TYPE_PLAYER = 0;
	public static final int TYPE_NPC = 1;
	public static final int TYPE_OBJECT = 2;
	public static final int TYPE_GROUND_ITEM = 3;

	// 117 HD UUID types
	public static final int TYPE_PROJECTILE = 4;
	public static final int TYPE_GRAPHICS_OBJECT = 5;
	public static final int TYPE_UNKNOWN = 0xF;

	// 117 HD UUID sub object types
	public static final int TYPE_WALL_OBJECT = 1 << 4 | TYPE_OBJECT;
	public static final int TYPE_GROUND_OBJECT = 2 << 4 | TYPE_OBJECT;
	public static final int TYPE_DECORATIVE_OBJECT = 3 << 4 | TYPE_OBJECT;
	public static final int TYPE_GAME_OBJECT = 4 << 4 | TYPE_OBJECT;

	public static final int UNKNOWN_ID = 0xFFFFFF;

	private static final String[] TYPE_NAMES = {
		"Player",
		"NPC",
		"Game Object",
		"Ground item",
		"Projectile",
		"Graphics object",
		"Unknown"
	};
	private static final String[] TYPE_NAMES_SHORT = {
		"PLR",
		"NPC",
		"OBJ",
		"ITM",
		"PRJ",
		"GFX",
		"N/A"
	};

	public static String getTypeName(int type) {
		return TYPE_NAMES[clamp(type, 0, TYPE_NAMES.length - 1)];
	}

	public static String getTypeNameShort(int type) {
		return TYPE_NAMES_SHORT[clamp(type, 0, TYPE_NAMES_SHORT.length - 1)];
	}

	public static int getSceneX(long hash) {
		return (int) (hash & 0x7f);
	}

	public static int getSceneY(long hash) {
		return (int) (hash >> 7 & 0x7f);
	}

	public static int getPlane(long hash) {
		return (int) (hash >> TileObject.HASH_PLANE_SHIFT & 3);
	}

	public static int getType(long hash) {
		return (int) (hash >> 16 & 7);
	}

	public static int getIdOrIndex(long hash) {
		return (int) (hash >> 20);
	}

	/**
	 * Generate an identifier of a Renderable, consisting of the type and ID.
	 *
	 * @param client     RuneLite client instance
	 * @param hash       RuneLite draw call hash
	 * @param renderable the Renderable passed into the draw callback
	 * @return a combined identifier
	 */
	public static int generateUuid(Client client, long hash, @Nullable Renderable renderable) {
		int type = TYPE_UNKNOWN;
		int id = UNKNOWN_ID;

		if (hash == -1) {
			if (renderable instanceof Projectile) {
				type = TYPE_PROJECTILE;
				id = ((Projectile) renderable).getId();
			} else if (renderable instanceof GraphicsObject) {
				type = TYPE_GRAPHICS_OBJECT;
				id = ((GraphicsObject) renderable).getId();
			}
		} else {
			type = ModelHash.getType(hash);
			id = ModelHash.getIdOrIndex(hash);

			if (renderable instanceof DynamicObject) {
				var def = client.getObjectDefinition(id);
				if (def.getImpostorIds() != null) {
					var impostor = def.getImpostor();
					if (impostor != null)
						id = impostor.getId();
				}
			} else if (type == TYPE_NPC) {
				int index = id;
				id = UNKNOWN_ID;
				var npcs = client.getTopLevelWorldView().npcs();
				if (index >= 0 && index < 65536) {
					NPC npc = npcs.byIndex(index);
					if (npc != null)
						id = npc.getId();
				}
			}
		}

		return packUuid(type, id);
	}

	/**
	 * Pack a type ID and object/NPC/projectile/other ID into an int for use with 117 HD functions.
	 *
	 * @param type ModelHash type ID
	 * @param id   object/NPC/projectile/other ID
	 * @return a combined identifier
	 */
	public static int packUuid(int type, int id) {
		return type << 24 | id;
	}

	public static int getUuidType(int uuid) {
		return uuid >> 24 & 0xF;
	}

	public static int getUuidSubType(int uuid) {
		return uuid >> 24;
	}

	public static int getUuidWithoutSubType(int uuid) {
		return uuid & ~0xF0000000;
	}

	public static int getUuidId(int uuid) {
		return uuid & 0xFFFFFF;
	}
}

package rs117.hd.utils;

import java.awt.event.KeyEvent;
import javax.inject.Inject;
import lombok.Getter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.events.*;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.config.Keybind;
import net.runelite.client.eventbus.EventBus;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.input.KeyListener;
import net.runelite.client.input.KeyManager;
import rs117.hd.HdPlugin;
import rs117.hd.overlays.FrameTimerOverlay;
import rs117.hd.overlays.LightGizmoOverlay;
import rs117.hd.overlays.ShadowMapOverlay;
import rs117.hd.overlays.TileInfoOverlay;
import rs117.hd.overlays.TiledLightingOverlay;
import rs117.hd.scene.AreaManager;
import rs117.hd.scene.areas.AABB;
import rs117.hd.scene.areas.Area;

import static java.awt.event.InputEvent.CTRL_DOWN_MASK;
import static java.awt.event.InputEvent.SHIFT_DOWN_MASK;

@Slf4j
public class DeveloperTools implements KeyListener {
	// This could be part of the config if we had developer mode config sections
	private static final Keybind KEY_TOGGLE_TILE_INFO = new Keybind(KeyEvent.VK_F3, CTRL_DOWN_MASK);
	private static final Keybind KEY_TOGGLE_FRAME_TIMINGS = new Keybind(KeyEvent.VK_F4, CTRL_DOWN_MASK);
	private static final Keybind KEY_RECORD_TIMINGS_SNAPSHOT = new Keybind(KeyEvent.VK_F4, CTRL_DOWN_MASK | SHIFT_DOWN_MASK);
	private static final Keybind KEY_TOGGLE_SHADOW_MAP_OVERLAY = new Keybind(KeyEvent.VK_F5, CTRL_DOWN_MASK);
	private static final Keybind KEY_TOGGLE_LIGHT_GIZMO_OVERLAY = new Keybind(KeyEvent.VK_F6, CTRL_DOWN_MASK);
	private static final Keybind KEY_TOGGLE_TILED_LIGHTING_OVERLAY = new Keybind(KeyEvent.VK_F7, CTRL_DOWN_MASK);
	private static final Keybind KEY_TOGGLE_FREEZE_FRAME = new Keybind(KeyEvent.VK_ESCAPE, SHIFT_DOWN_MASK);
	private static final Keybind KEY_TOGGLE_ORTHOGRAPHIC = new Keybind(KeyEvent.VK_TAB, SHIFT_DOWN_MASK);
	private static final Keybind KEY_TOGGLE_HIDE_UI = new Keybind(KeyEvent.VK_H, CTRL_DOWN_MASK);

	@Inject
	private ClientThread clientThread;

	@Inject
	private EventBus eventBus;

	@Inject
	private KeyManager keyManager;

	@Inject
	private HdPlugin plugin;

	@Inject
	private TileInfoOverlay tileInfoOverlay;

	@Inject
	private FrameTimerOverlay frameTimerOverlay;

	@Inject
	private FrameTimingsRecorder frameTimingsRecorder;

	@Inject
	private ShadowMapOverlay shadowMapOverlay;

	@Inject
	private LightGizmoOverlay lightGizmoOverlay;

	@Inject
	private TiledLightingOverlay tiledLightingOverlay;

	private boolean keyBindingsEnabled;
	private boolean tileInfoOverlayEnabled;
	@Getter
	private boolean frameTimingsOverlayEnabled;
	private boolean shadowMapOverlayEnabled;
	private boolean lightGizmoOverlayEnabled;
	@Getter
	private boolean hideUiEnabled;
	private boolean tiledLightingOverlayEnabled;

	public void activate() {
		// Listen for commands
		eventBus.register(this);

		// Don't do anything else unless we're in the development environment
		if (!Props.DEVELOPMENT)
			return;

		// Enable 117 HD's keybindings by default during development
		keyBindingsEnabled = true;
		keyManager.registerKeyListener(this);

		clientThread.invokeLater(() -> {
			tileInfoOverlay.setActive(tileInfoOverlayEnabled);
			frameTimerOverlay.setActive(frameTimingsOverlayEnabled);
			shadowMapOverlay.setActive(shadowMapOverlayEnabled);
			lightGizmoOverlay.setActive(lightGizmoOverlayEnabled);
			tiledLightingOverlay.setActive(tiledLightingOverlayEnabled);
		});

		// Check for any out of bounds areas
		for (Area area : AreaManager.AREAS) {
			if (area == Area.ALL || area == Area.NONE)
				continue;

			for (AABB aabb : area.aabbs) {
				if (aabb.minX < -128 || aabb.minY < 1000 || aabb.maxX > 5000 || aabb.maxY > 13000) {
					throw new IllegalArgumentException(
						"Your definition for the area " + area + " has an incorrect AABB: " + aabb);
				}
			}
		}
	}

	public void deactivate() {
		eventBus.unregister(this);
		keyManager.unregisterKeyListener(this);
		tileInfoOverlay.setActive(false);
		frameTimerOverlay.setActive(false);
		shadowMapOverlay.setActive(false);
		lightGizmoOverlay.setActive(false);
		tiledLightingOverlay.setActive(false);
		hideUiEnabled = false;
	}

	@Subscribe
	public void onCommandExecuted(CommandExecuted commandExecuted) {
		if (!commandExecuted.getCommand().equalsIgnoreCase("117hd"))
			return;

		String[] args = commandExecuted.getArguments();
		if (args.length < 1)
			return;

		String action = args[0].toLowerCase();
		switch (action) {
			case "tileinfo":
				tileInfoOverlay.setActive(tileInfoOverlayEnabled = !tileInfoOverlayEnabled);
				break;
			case "timers":
			case "timings":
				frameTimerOverlay.setActive(frameTimingsOverlayEnabled = !frameTimingsOverlayEnabled);
				break;
			case "snapshot":
				frameTimingsRecorder.recordSnapshot();
				break;
			case "shadowmap":
				shadowMapOverlay.setActive(shadowMapOverlayEnabled = !shadowMapOverlayEnabled);
				break;
			case "lights":
				lightGizmoOverlay.setActive(lightGizmoOverlayEnabled = !lightGizmoOverlayEnabled);
				break;
			case "tiledlights":
			case "tiledlighting":
				tiledLightingOverlay.setActive(tiledLightingOverlayEnabled = !tiledLightingOverlayEnabled);
				break;
			case "keybinds":
			case "keybindings":
				keyBindingsEnabled = !keyBindingsEnabled;
				if (keyBindingsEnabled) {
					keyManager.registerKeyListener(this);
				} else {
					keyManager.unregisterKeyListener(this);
				}
				break;
		}
	}

	@Override
	public void keyPressed(KeyEvent e) {
		if (KEY_TOGGLE_TILE_INFO.matches(e)) {
			tileInfoOverlay.setActive(tileInfoOverlayEnabled = !tileInfoOverlayEnabled);
		} else if (KEY_TOGGLE_FRAME_TIMINGS.matches(e)) {
			frameTimerOverlay.setActive(frameTimingsOverlayEnabled = !frameTimingsOverlayEnabled);
		} else if (KEY_RECORD_TIMINGS_SNAPSHOT.matches(e)) {
			frameTimingsRecorder.recordSnapshot();
		} else if (KEY_TOGGLE_SHADOW_MAP_OVERLAY.matches(e)) {
			shadowMapOverlay.setActive(shadowMapOverlayEnabled = !shadowMapOverlayEnabled);
		} else if (KEY_TOGGLE_LIGHT_GIZMO_OVERLAY.matches(e)) {
			lightGizmoOverlay.setActive(lightGizmoOverlayEnabled = !lightGizmoOverlayEnabled);
		} else if (KEY_TOGGLE_TILED_LIGHTING_OVERLAY.matches(e)) {
			tiledLightingOverlay.setActive(tiledLightingOverlayEnabled = !tiledLightingOverlayEnabled);
		} else if (KEY_TOGGLE_FREEZE_FRAME.matches(e)) {
			plugin.toggleFreezeFrame();
		} else if (KEY_TOGGLE_ORTHOGRAPHIC.matches(e)) {
			plugin.orthographicProjection = !plugin.orthographicProjection;
		} else if (KEY_TOGGLE_HIDE_UI.matches(e)) {
			hideUiEnabled = !hideUiEnabled;
		} else {
			return;
		}
		e.consume();
	}

	@Override
	public void keyReleased(KeyEvent e) {}

	@Override
	public void keyTyped(KeyEvent e) {}
}

/*
 * Copyright (c) 2022 Abex
 * Copyright 2010 JogAmp Community.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package rs117.hd.utils;

import static rs117.hd.utils.MathUtils.*;

public class Mat4
{
	/**
	 * Utility class for working with column-major 4 x 4 matrices.
	 */

	public static float[] identity()
	{
		return new float[] {
			1, 0, 0, 0,
			0, 1, 0, 0,
			0, 0, 1, 0,
			0, 0, 0, 1,
		};
	}

	public static float[] scale(float sx, float sy, float sz)
	{
		return new float[] {
			sx, 0, 0, 0,
			0, sy, 0, 0,
			0, 0, sz, 0,
			0, 0, 0, 1,
		};
	}

	public static float[] translate(float tx, float ty, float tz)
	{
		return new float[] {
			1, 0, 0, 0,
			0, 1, 0, 0,
			0, 0, 1, 0,
			tx, ty, tz, 1,
		};
	}

	public static float[] rotateX(float rx)
	{
		float s = sin(rx);
		float c = cos(rx);

		return new float[] {
			1, 0, 0, 0,
			0, c, s, 0,
			0, -s, c, 0,
			0, 0, 0, 1,
		};
	}

	public static float[] rotateY(float ry)
	{
		float s = sin(ry);
		float c = cos(ry);

		return new float[] {
			c, 0, -s, 0,
			0, 1, 0, 0,
			s, 0, c, 0,
			0, 0, 0, 1,
		};
	}

	public static float[] perspective(float w, float h, float n) {
		// Flip Y so positive is up, and reverse depth from 1 at the near plane to 0 infinitely far away
		return new float[] {
			2 / w, 0, 0, 0,
			0, -2 / h, 0, 0,
			0, 0, 0, 1,
			0, 0, 2 * n, 0
		};
	}

	public static float[] orthographic(float w, float h, float n)
	{
		return new float[] {
			2 / w, 0, 0, 0,
			0, -2 / h, 0, 0,
			0, 0, 2 / n, 0,
			0, 0, 0, 1
		};
	}

	/**
	 * Multiplies matrices a and b, storing the result in matrix a.
	 *
	 * @param a column-major 4x4 matrix
	 * @param b column-major 4x4 matrix
	 */
	@SuppressWarnings("PointlessArithmeticExpression")
	public static void mul(float[] a, float[] b)
	{
		final float b00 = b[0 + 0 * 4];
		final float b10 = b[1 + 0 * 4];
		final float b20 = b[2 + 0 * 4];
		final float b30 = b[3 + 0 * 4];
		final float b01 = b[0 + 1 * 4];
		final float b11 = b[1 + 1 * 4];
		final float b21 = b[2 + 1 * 4];
		final float b31 = b[3 + 1 * 4];
		final float b02 = b[0 + 2 * 4];
		final float b12 = b[1 + 2 * 4];
		final float b22 = b[2 + 2 * 4];
		final float b32 = b[3 + 2 * 4];
		final float b03 = b[0 + 3 * 4];
		final float b13 = b[1 + 3 * 4];
		final float b23 = b[2 + 3 * 4];
		final float b33 = b[3 + 3 * 4];

		float ai0 = a[0 * 4]; // row-0 of a
		float ai1 = a[1 * 4];
		float ai2 = a[2 * 4];
		float ai3 = a[3 * 4];
		a[0 * 4] = ai0 * b00 + ai1 * b10 + ai2 * b20 + ai3 * b30;
		a[1 * 4] = ai0 * b01 + ai1 * b11 + ai2 * b21 + ai3 * b31;
		a[2 * 4] = ai0 * b02 + ai1 * b12 + ai2 * b22 + ai3 * b32;
		a[3 * 4] = ai0 * b03 + ai1 * b13 + ai2 * b23 + ai3 * b33;

		ai0 = a[1 + 0 * 4]; // row-1 of a
		ai1 = a[1 + 1 * 4];
		ai2 = a[1 + 2 * 4];
		ai3 = a[1 + 3 * 4];
		a[1 + 0 * 4] = ai0 * b00 + ai1 * b10 + ai2 * b20 + ai3 * b30;
		a[1 + 1 * 4] = ai0 * b01 + ai1 * b11 + ai2 * b21 + ai3 * b31;
		a[1 + 2 * 4] = ai0 * b02 + ai1 * b12 + ai2 * b22 + ai3 * b32;
		a[1 + 3 * 4] = ai0 * b03 + ai1 * b13 + ai2 * b23 + ai3 * b33;

		ai0 = a[2 + 0 * 4]; // row-2 of a
		ai1 = a[2 + 1 * 4];
		ai2 = a[2 + 2 * 4];
		ai3 = a[2 + 3 * 4];
		a[2 + 0 * 4] = ai0 * b00 + ai1 * b10 + ai2 * b20 + ai3 * b30;
		a[2 + 1 * 4] = ai0 * b01 + ai1 * b11 + ai2 * b21 + ai3 * b31;
		a[2 + 2 * 4] = ai0 * b02 + ai1 * b12 + ai2 * b22 + ai3 * b32;
		a[2 + 3 * 4] = ai0 * b03 + ai1 * b13 + ai2 * b23 + ai3 * b33;

		ai0 = a[3 + 0 * 4]; // row-3 of a
		ai1 = a[3 + 1 * 4];
		ai2 = a[3 + 2 * 4];
		ai3 = a[3 + 3 * 4];
		a[3 + 0 * 4] = ai0 * b00 + ai1 * b10 + ai2 * b20 + ai3 * b30;
		a[3 + 1 * 4] = ai0 * b01 + ai1 * b11 + ai2 * b21 + ai3 * b31;
		a[3 + 2 * 4] = ai0 * b02 + ai1 * b12 + ai2 * b22 + ai3 * b32;
		a[3 + 3 * 4] = ai0 * b03 + ai1 * b13 + ai2 * b23 + ai3 * b33;
	}

	/**
	 * Multiplies a 4x4 matrix with a 4x1 vector, storing the result in the output vector, which may be the same as the input vector.
	 *
	 * @param out  where the result should be stored
	 * @param mat4 4x4 column-major matrix
	 * @param vec4 4x1 vector
	 */
	@SuppressWarnings("PointlessArithmeticExpression")
	public static void mulVec(float[] out, float[] mat4, float[] vec4) {
		float a =
			mat4[0 * 4 + 0] * vec4[0] +
			mat4[1 * 4 + 0] * vec4[1] +
			mat4[2 * 4 + 0] * vec4[2] +
			mat4[3 * 4 + 0] * vec4[3];
		float b =
			mat4[0 * 4 + 1] * vec4[0] +
			mat4[1 * 4 + 1] * vec4[1] +
			mat4[2 * 4 + 1] * vec4[2] +
			mat4[3 * 4 + 1] * vec4[3];
		float c =
			mat4[0 * 4 + 2] * vec4[0] +
			mat4[1 * 4 + 2] * vec4[1] +
			mat4[2 * 4 + 2] * vec4[2] +
			mat4[3 * 4 + 2] * vec4[3];
		float d =
			mat4[0 * 4 + 3] * vec4[0] +
			mat4[1 * 4 + 3] * vec4[1] +
			mat4[2 * 4 + 3] * vec4[2] +
			mat4[3 * 4 + 3] * vec4[3];
		out[0] = a;
		out[1] = b;
		out[2] = c;
		out[3] = d;
	}

	/**
	 * Transforms the vector by the matrix, and does a perspective divide.
	 *
	 * @param out  where the result should be stored
	 * @param mat4 4x4 column-major matrix
	 * @param vec4 4x1 vector
	 */
	public static void projectVec(float[] out, float[] mat4, float[] vec4) {
		mulVec(out, mat4, vec4);
		// Perspective divide
		divide(out, out, out[3]);
	}

	public static void transpose(float[] m) {
		for (int i = 0; i < 4; i++) {
			for (int j = i + 1; j < 4; j++) {
				int a = i * 4 + j;
				int b = j * 4 + i;
				float temp = m[a];
				m[a] = m[b];
				m[b] = temp;
			}
		}
	}

	public static float[] inverse(float[] m) {
		float[] augmented = slice(m, 0, 32);
		augmented[16] = augmented[21] = augmented[26] = augmented[31] = 1;
		Matrix.solve(augmented, 4, 8);
		return slice(augmented, 16);
	}

	public static void extractRow(float[] out, float[] mat4, int rowIndex) {
		System.arraycopy(mat4, 4 * rowIndex, out, 0, out.length);
	}

	public static void extractColumn(float[] out, float[] mat4, int columnIndex) {
		for (int i = 0; i < out.length; i++)
			out[i] = mat4[4 * i + columnIndex];
	}

	public static String format(float[] m) {
		assert m.length == 16;
		return Matrix.format(m, 4, 4);
	}
}

package rs117.hd.utils;

import com.google.gson.JsonElement;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonToken;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.HashSet;
import java.util.function.Function;
import javax.annotation.Nullable;
import lombok.AllArgsConstructor;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;

import static rs117.hd.utils.MathUtils.*;

public class ExpressionParser {
	public static ExpressionPredicate parsePredicate(String expression) {
		return parsePredicate(expression, null);
	}

	public static ExpressionPredicate parsePredicate(String expression, @Nullable VariableSupplier constants) {
		return asExpression(parseExpression(expression, constants)).toPredicate();
	}

	public static Function<VariableSupplier, Object> parseFunction(String expression) {
		return parseFunction(expression, null);
	}

	public static Function<VariableSupplier, Object> parseFunction(String expression, @Nullable VariableSupplier constants) {
		return asFunction(parseExpression(expression, constants));
	}

	public static Object parseExpression(String expression) {
		return parseExpression(expression, null);
	}

	public static Object parseExpression(String expression, @Nullable VariableSupplier constants) {
		return asExpression(parseExpression(expression, 0, expression.length())).simplify(constants);
	}

	public static String mergeJsonExpressions(String delimiter, JsonElement jsonExpressions) {
		if (jsonExpressions == null || jsonExpressions.isJsonNull())
			throw new IllegalArgumentException("Missing expression, got null");

		if (jsonExpressions.isJsonPrimitive())
			return jsonExpressions.getAsJsonPrimitive().getAsString();

		if (jsonExpressions.isJsonArray()) {
			var array = jsonExpressions.getAsJsonArray();
			var sb = new StringBuilder();
			String prefix = "";
			for (var primitive : array) {
				sb.append(prefix).append('(').append(primitive.getAsString()).append(')');
				prefix = delimiter;
			}
			return sb.toString();
		}

		throw new IllegalArgumentException("Unsupported expression format: '" + jsonExpressions + "'");
	}

	public static String mergeExpressions(String delimiter, Iterable<String> expressions) {
		var sb = new StringBuilder();
		String prefix = "";
		for (var expression : expressions) {
			sb.append(prefix).append('(').append(expression).append(')');
			prefix = delimiter;
		}
		return sb.toString();
	}

	public static Expression asExpression(Object object) {
		if (object instanceof Expression)
			return (Expression) object;
		return new Expression(object);
	}

	public static Function<VariableSupplier, Object> asFunction(Object object) {
		if (object instanceof Expression)
			return ((Expression) object).toFunction();
		if (object instanceof String)
			return vars -> vars.get((String) object);
		return vars -> object;
	}

	public static class SerializableExpressionPredicate implements ExpressionPredicate {
		public final Expression expression;
		public final ExpressionPredicate predicate;

		public SerializableExpressionPredicate(Expression expression) {
			this.expression = expression;
			predicate = expression.toPredicate();
		}

		@Override
		public String toString() {
			return expression.toString();
		}

		@Override
		public boolean test(VariableSupplier variableSupplier) {
			return predicate.test(variableSupplier);
		}
	}

	public static class PredicateAdapter extends TypeAdapter<SerializableExpressionPredicate> {
		private static final Adapter ADAPTER = new Adapter();

		@Override
		public SerializableExpressionPredicate read(JsonReader in) throws IOException {
			return new SerializableExpressionPredicate(ADAPTER.read(in));
		}

		@Override
		public void write(JsonWriter out, SerializableExpressionPredicate predicate) throws IOException {
			ADAPTER.write(out, predicate.expression);
		}
	}

	@Slf4j
	public static class Adapter extends TypeAdapter<Expression> {
		@Override
		public Expression read(JsonReader in) throws IOException {
			if (in.peek() == JsonToken.NULL)
				return null;

			if (in.peek() == JsonToken.BOOLEAN)
				return asExpression(in.nextBoolean());

			if (in.peek() == JsonToken.STRING)
				return asExpression(parseExpression(in.nextString()));

			if (in.peek() == JsonToken.BEGIN_ARRAY) {
				in.beginArray();
				var cases = new ArrayList<String>();
				while (in.peek() == JsonToken.STRING)
					cases.add(in.nextString());
				in.endArray();
				return asExpression(parseExpression(mergeExpressions("||", cases)));
			}

			log.warn("Unexpected type {} at {}", in.peek(), GsonUtils.location(in), new Throwable());
			return null;
		}

		@Override
		public void write(JsonWriter out, Expression expression) throws IOException {
			if (expression == null) {
				out.nullValue();
			} else {
				// Disable HTML escaping to keep operators intact
				out.setHtmlSafe(false);
				out.value(expression.toString());
			}
		}
	}

	public static class SyntaxError extends IllegalArgumentException {
		SyntaxError(ParserContext ctx, String message) {
			super(
				"Error at index " + ctx.index + " while parsing " +
				(ctx.op == null ? "expression" : "operator '" + ctx.op + "' in") +
				" '" + ctx.expr + "': " + message
			);
		}
	}

	@RequiredArgsConstructor
	private enum Operator {
		MOD("%", 6, 2),
		MUL("*", 6, 2),
		DIV("/", 6, 2),
		ADD("+", 5, 2),
		SUB("-", 5, 2),
		LEQUAL("<=", 4, 2),
		LESS("<", 4, 2),
		GEQUAL(">=", 4, 2),
		GREATER(">", 4, 2),
		NOTEQUAL("!=", 3, 2),
		NOT("!", 7, 1),
		EQUAL("==", 3, 2),
		AND("&&", 2, 2),
		OR("||", 1, 2),
		TERNARY("?", 0, 3);

		final String symbol;
		final int precedence;
		final int numOperands;

		@Override
		public String toString() {
			return symbol;
		}
	}

	@AllArgsConstructor
	public static class ParserContext {
		final String expr;
		int index, endIndex;
		char c;
		Operator op;
		Object[] operands = new Object[2];
		boolean isInParentheses;
		boolean isTopLevelParser;
		int minPrecedence;

		ParserContext(String expression, int startIndex, int endIndex, boolean isTopLevelParser, int minPrecedence) {
			this.expr = expression;
			this.index = startIndex;
			this.endIndex = endIndex;
			this.isTopLevelParser = isTopLevelParser;
			this.minPrecedence = minPrecedence;
		}

		boolean done() {
			return index >= endIndex;
		}

		void read() {
			if (done())
				throw new SyntaxError(this, "Unexpected end of expression");
			c = expr.charAt(index);
		}

		void readSafe() {
			c = done() ? 0 : expr.charAt(index);
		}

		char readEnd() {
			return expr.charAt(endIndex - 1);
		}

		void readIgnoringWhitespace() {
			skipWhitespace();
			read();
		}

		void advance() {
			index++;
			readSafe();
		}

		void advanceIgnoringWhitespace() {
			advance();
			skipWhitespace();
		}

		void trim() {
			int remaining;
			do {
				remaining = remaining();
				trimWhitespace();
				trimParentheses();
			} while (remaining != remaining());
		}

		void trimParentheses() {
			isInParentheses = false;
			while (!done() && c == '(' && readEnd() == ')') {
				int i = index + 1;
				int levels = 1;
				while (i < endIndex - 2) {
					char c = expr.charAt(i++);
					if (c == '(') {
						levels++;
					} else if (c == ')') {
						levels--;
						if (levels == 0)
							return;
					}
				}

				advance();
				endIndex--;
				isInParentheses = true;
			}
		}

		void skipWhitespace() {
			while (!done()) {
				readSafe();
				if (c != ' ')
					break;
				index++;
			}
		}

		void trimWhitespaceEnd() {
			while (!done()) {
				var end = expr.charAt(endIndex - 1);
				if (end != ' ')
					break;
				endIndex--;
			}
		}

		void trimWhitespace() {
			skipWhitespace();
			trimWhitespaceEnd();
		}

		int remaining() {
			return endIndex - index;
		}

		int indexOfClosingParenthesis(int openingParenthesis) {
			int i = openingParenthesis;
			int levels = 1;
			while (++i < endIndex) {
				char c = expr.charAt(i);
				if (c == '(') {
					levels++;
				} else if (c == ')' && --levels == 0) {
					return i;
				}
			}
			throw new SyntaxError(this, "Missing closing parenthesis");
		}

		Object parseOperand() {
			if (!done()) {
				skipWhitespace();

				// Always parse parentheses in a new parsing context
				if (c == '(') {
					int end = indexOfClosingParenthesis(index);
					var exprInParentheses = parseExpression(expr, index, end + 1);
					index = end + 1;
					readSafe();
					return exprInParentheses;
				}

				// Parse all following operations with higher precedence than the current, and return that as the operand
				if (op != null) {
					var higherPrecedenceParser = new ParserContext(expr, index, endIndex, false, op.precedence + 1);
					var expr = parseExpression(higherPrecedenceParser);
					if (expr != null) {
						index = higherPrecedenceParser.index;
						endIndex = higherPrecedenceParser.endIndex;
						return expr;
					}
				}

				if (c == '+' || c == '-' || c == '.' || ('0' <= c && c <= '9'))
					return readNumber();
				if ('A' <= c && c <= 'Z' || 'a' <= c && c <= 'z' || c == '_')
					return readIdentifier();
			}
			return null;
		}

		float readNumber() {
			// Parse sign
			int sign = 1;
			while (!done()) {
				if (c == '-') {
					sign *= -1;
				} else if (c != '+') {
					break;
				}
				advanceIgnoringWhitespace();
			}

			// Parse whole part
			int wholePart = 0;
			int numDigits = 0;
			while (!done()) {
				if ('0' <= c && c <= '9') {
					wholePart *= 10;
					wholePart += c - '0';
					numDigits++;
					advance();
				} else {
					break;
				}
			}

			// Parse fractional part
			if (!done() && c == '.') {
				advance();
				int fractionalPart = 0;
				int divisor = 1;
				while (!done()) {
					if ('0' <= c && c <= '9') {
						fractionalPart += c - '0';
						divisor *= 10;
						advance();
					} else {
						break;
					}
				}

				if (divisor > 1)
					return sign * ((float) fractionalPart / divisor + wholePart);
			}

			if (numDigits == 0)
				throw new SyntaxError(this, "Expected a number");

			return sign * wholePart;
		}

		Object readIdentifier() {
			StringBuilder sb = new StringBuilder();
			while (!done()) {
				if ('A' <= c && c <= 'Z' ||
					'a' <= c && c <= 'z' ||
					'0' <= c && c <= '9' ||
					c == '_' ||
					c == '.' && sb.length() > 0
				) {
					sb.append(c);
					advance();
				} else {
					break;
				}
			}

			assert sb.length() > 0;
			var str = sb.toString();

			// Convert string constants
			if (str.equalsIgnoreCase("true"))
				return true;
			if (str.equalsIgnoreCase("false"))
				return false;

			return str;
		}

		Expression createExpression(Object leftOperand, Operator op, Object rightOperand) {
			if (!(leftOperand instanceof Expression)) {
				// Simple combination of left & right operands
				return new Expression(op, leftOperand, rightOperand, null, false);
			}

			Expression left = (Expression) leftOperand;
			// If the left expression is in parentheses, or has the same or higher operator precedence,
			// it should be evaluated first, so use it as the left operand in a new expression
			if (left.isInParentheses || left.op.precedence >= op.precedence)
				return new Expression(op, left, rightOperand, null, false);

			// The new operator should act on the left expression's right-most operand,
			// and should replace the right-most operand with the resulting expression
			left.right = createExpression(left.right, op, rightOperand);
			return left;
		}
	}

	public static class Expression {
		Operator op;
		Object left, right;
		Object ternary;
		boolean isInParentheses;
		public final HashSet<String> variables = new HashSet<>();

		Expression(Object value) {
			this(null, value, null, null, false);
		}

		Expression(Operator op, Object left, Object right, Object ternary, boolean isInParentheses) {
			this.op = op;
			this.left = left;
			this.right = right;
			this.ternary = ternary;
			this.isInParentheses = isInParentheses;
			registerVariables(left);
			registerVariables(right);
			registerVariables(ternary);
		}

		public Object simplify(@Nullable VariableSupplier constants) {
			Object l = left instanceof Expression ? ((Expression) left).simplify(constants) : left;
			Object r = right instanceof Expression ? ((Expression) right).simplify(constants) : right;

			if (constants != null) {
				if (l instanceof String) {
					var value = constants.get((String) l);
					if (value != null)
						l = sanitizeValue(value);
				}
				if (r instanceof String) {
					var value = constants.get((String) r);
					if (value != null)
						r = sanitizeValue(value);
				}
			}

			if (op == Operator.TERNARY) {
				Object t = asExpression(ternary).simplify(constants);
				if (t instanceof Boolean)
					return (boolean) t ? l : r;
				return new Expression(op, l, r, asExpression(t), isInParentheses);
			}

			var expr = this;
			if (l != left || r != right)
				expr = new Expression(op, l, r, null, isInParentheses);

			if (isPrimitive(l) && isPrimitive(r))
				return expr.toFunctionInternal().apply(null);

			return expr;
		}

		private String formatOperand(Object operand) {
			if (operand instanceof Number) {
				int nearest = round((float) operand);
				if (abs((float) operand - nearest) < 1e-10)
					operand = nearest;
			}
			return operand.toString();
		}

		@Override
		public String toString() {
			if (op == null)
				return formatOperand(left);
			if (op.numOperands == 1)
				return op.symbol + formatOperand(left);
			if (op.numOperands == 2)
				return String.format("%s %s %s", formatOperand(left), op, formatOperand(right));
			if (op.numOperands == 3)
				return String.format("%s %s %s : %s", formatOperand(ternary), op, formatOperand(left), formatOperand(right));
			throw new IllegalStateException(String.format("Cannot stringify operator '%s'", op));
		}

		public Function<VariableSupplier, Object> toFunction() {
			var func = toFunctionInternal();
			return vars -> func.apply(key -> sanitizeValue(vars.get(key)));
		}

		static Object sanitizeValue(Object value) {
			// This is kind of stupid, but it's necessary to convert
			// ints to floats here to avoid messy code later
			if (value instanceof Integer)
				return ((Integer) value).floatValue();
			return value;
		}

		private Function<VariableSupplier, Object> toFunctionInternal() {
			if (op == null)
				return asFunction(left);

			if (op == Operator.TERNARY) {
				var condition = asExpression(ternary).toPredicate();
				if (left instanceof Expression) {
					var ifTrue = ((Expression) left).toFunction();
					if (right instanceof Expression) {
						var ifFalse = ((Expression) right).toFunction();
						return vars -> condition.test(vars) ? ifTrue.apply(vars) : ifFalse.apply(vars);
					}
					return vars -> condition.test(vars) ? ifTrue.apply(vars) : right;
				} else if (right instanceof Expression) {
					var ifFalse = ((Expression) right).toFunction();
					return vars -> condition.test(vars) ? left : ifFalse.apply(vars);
				} else {
					return vars -> condition.test(vars) ? left : right;
				}
			}

			// Convert variables and constants into functions
			var l = asFunction(left);
			var r = asFunction(right);

			switch (op) {
				case AND:
					return vars -> (boolean) l.apply(vars) && (boolean) r.apply(vars);
				case OR:
					return vars -> (boolean) l.apply(vars) || (boolean) r.apply(vars);
				case NOTEQUAL:
				case EQUAL:
					boolean isBoolean =
						left instanceof Boolean || left instanceof Expression && ((Expression) left).isBoolean() ||
						right instanceof Boolean || right instanceof Expression && ((Expression) right).isBoolean();
					if (isBoolean) {
						return op == Operator.EQUAL ?
							vars -> (boolean) l.apply(vars) == (boolean) r.apply(vars) :
							vars -> (boolean) l.apply(vars) != (boolean) r.apply(vars);
					} else {
						return op == Operator.EQUAL ?
							vars -> (float) l.apply(vars) == (float) r.apply(vars) :
							vars -> (float) l.apply(vars) != (float) r.apply(vars);
					}
				case GEQUAL:
					return vars -> (float) l.apply(vars) >= (float) r.apply(vars);
				case GREATER:
					return vars -> (float) l.apply(vars) > (float) r.apply(vars);
				case LEQUAL:
					return vars -> (float) l.apply(vars) <= (float) r.apply(vars);
				case LESS:
					return vars -> (float) l.apply(vars) < (float) r.apply(vars);
				case ADD:
					return vars -> (float) l.apply(vars) + (float) r.apply(vars);
				case SUB:
					return vars -> (float) l.apply(vars) - (float) r.apply(vars);
				case MUL:
					return vars -> (float) l.apply(vars) * (float) r.apply(vars);
				case DIV:
					return vars -> (float) l.apply(vars) / (float) r.apply(vars);
				case MOD:
					return vars -> (float) l.apply(vars) % (float) r.apply(vars);
				case NOT:
					return vars -> !(boolean) r.apply(vars);
			}

			throw new UnsupportedOperationException("Unsupported operands: " + l + " " + op + " " + r);
		}

		public ExpressionPredicate toPredicate() {
			if (!isBoolean())
				throw new IllegalArgumentException("Expression does not result in a boolean");

			var func = toFunction();
			return vars -> (boolean) func.apply(vars);
		}

		boolean isBoolean() {
			if (op == null)
				return isPossiblyBoolean(left);
			switch (op) {
				case TERNARY:
					return isPossiblyBoolean(left) || isPossiblyBoolean(right);
				case EQUAL:
				case NOTEQUAL:
				case LESS:
				case LEQUAL:
				case GREATER:
				case GEQUAL:
				case AND:
				case OR:
				case NOT:
					return true;
			}
			return false;
		}

		static boolean isPossiblyBoolean(Object obj) {
			return
				obj instanceof Boolean ||
				obj instanceof String ||
				obj instanceof Expression && ((Expression) obj).isBoolean();
		}

		private boolean isPrimitive(Object obj) {
			return obj == null || obj instanceof Float || obj instanceof Boolean;
		}

		private void registerVariables(@Nullable Object dependency) {
			if (dependency instanceof String) {
				variables.add((String) dependency);
			} else if (dependency instanceof Expression) {
				variables.addAll(((Expression) dependency).variables);
			}
		}
	}

	private static Object parseExpression(String expression, int startIndex, int endIndex) {
		return parseExpression(new ParserContext(expression, startIndex, endIndex, true, 0));
	}

	private static Object parseExpression(ParserContext ctx) {
		ctx.trimWhitespace();
		if (ctx.done())
			throw new SyntaxError(ctx, "Empty expression");

		ctx.trimParentheses();
		boolean wasInParentheses = ctx.isInParentheses;
		boolean wasTopLevelParser = ctx.isTopLevelParser;
		// Since we'll be reusing the same parser context for parsing sub-expressions, mark it as not top-level
		ctx.isTopLevelParser = false;

		// The general gist:
		// 1. Begin parsing from left to right until any operator is reached
		// 2. Parse all following higher precedence operations
		// 3. Continue parsing operators regardless of precedence
		// 4. If a lower precedence operator is reached, make that the new parent node, and return to step 2
		// 5. At the end, return the left operand and parenthesis information

		ctx.operands[0] = ctx.parseOperand();

		parsing:
		while (!ctx.done()) {
			ctx.skipWhitespace();
			ctx.op = null;
			for (var op : Operator.values()) {
				// Skip lower precedence operators
				if (op.precedence >= ctx.minPrecedence && ctx.expr.startsWith(op.symbol, ctx.index)) {
					if (op == Operator.TERNARY) {
						// Parse the ternary into an expression to be the new left operand, and keep parsing
						var condition = ctx.operands[0];
						if (condition == null)
							throw new SyntaxError(ctx, "Unexpected operator '" + op.symbol + "' without preceding condition");
						ctx.index += op.symbol.length();
						var ifTrue = parseExpression(ctx);
						ctx.trim();
						if (ctx.c != ':')
							throw new SyntaxError(ctx, "Expected ':' in ternary expression");
						ctx.advance();
						var ifFalse = parseExpression(ctx);
						ctx.operands[0] = new Expression(op, ifTrue, ifFalse, condition, wasInParentheses);
						continue parsing;
					}

					if (ctx.operands[0] == null) {
						if (op.numOperands > 1)
							throw new SyntaxError(ctx, "Missing left operand for operator '" + op.symbol + "'");
					} else if (op.numOperands == 1) {
						throw new SyntaxError(ctx, "Unexpected left operand before '" + op.symbol + "'");
					}

					ctx.op = op;
					ctx.index += op.symbol.length();
					break;
				}
			}

			if (ctx.op == null)
				break;

			if (ctx.op != Operator.NOT && ctx.operands[0] == null)
				throw new SyntaxError(ctx, "Missing left operand for operator '" + ctx.op.symbol + "'");

			// Will parse all following higher precedence operations, or a single value or identifier
			ctx.operands[1] = ctx.parseOperand();
			if (ctx.operands[1] == null)
				throw new SyntaxError(ctx, "Missing right operand for operator '" + ctx.op.symbol + "'");

			ctx.operands[0] = ctx.createExpression(ctx.operands[0], ctx.op, ctx.operands[1]);
		}

		if (wasTopLevelParser && !ctx.done())
			throw new SyntaxError(ctx, "Unexpected character '" + ctx.c + "'");

		if (ctx.operands[0] instanceof Expression)
			((Expression) ctx.operands[0]).isInParentheses = wasInParentheses;

		return ctx.operands[0];
	}
}

package rs117.hd.utils;

import com.google.gson.Gson;
import com.google.gson.JsonObject;
import com.google.inject.Inject;
import com.google.inject.Singleton;
import java.io.IOException;
import java.io.PrintWriter;
import java.text.SimpleDateFormat;
import java.util.ArrayDeque;
import java.util.HashMap;
import java.util.LinkedHashMap;
import java.util.Map;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.*;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.config.ConfigManager;
import rs117.hd.HdPlugin;
import rs117.hd.HdPluginConfig;
import rs117.hd.overlays.FrameTimer;
import rs117.hd.overlays.FrameTimings;
import rs117.hd.overlays.Timer;

import static org.lwjgl.opengl.GL33C.*;
import static rs117.hd.utils.MathUtils.*;

@Slf4j
@Singleton
public class FrameTimingsRecorder implements FrameTimer.Listener {
	private static final ResourcePath SNAPSHOTS_PATH = HdPlugin.PLUGIN_DIR.resolve("snapshots");
	private static final int SNAPSHOT_DURATION_MS = 20_000;

	@Inject
	private Gson gson;

	@Inject
	private Client client;

	@Inject
	private ClientThread clientThread;

	@Inject
	private ConfigManager configManager;

	@Inject
	private HdPlugin plugin;

	@Inject
	private FrameTimer frameTimer;

	@Inject
	private NpcDisplacementCache npcDisplacementCache;

	private static class Snapshot {
		public long timestamp = System.currentTimeMillis();
		public String osName;
		public String osArch;
		public String osVersion;
		public String javaVersion;
		public int cpuCores;
		public long memoryMaxMiB;
		public String gpuName;
		public Map<String, String> settings = new HashMap<>();
		public ArrayDeque<Frame> frames = new ArrayDeque<>(SNAPSHOT_DURATION_MS * 200 / 1000); // Allocate for 200 FPS

		public static class Frame {
			public long timestamp;
			public long drawnTiles;
			public long drawnStatic;
			public long drawnDynamic;
			public long npcDisplacementCacheSize;
			public long memoryUsed;
			public long memoryTotal;
			public long memoryFree;
			public long memoryMax;
			public LinkedHashMap<String, Long> cpu;
			public LinkedHashMap<String, Long> gpu;

			public transient long[] rawTimings;

			public Frame(FrameTimings frameTimings) {
				timestamp = frameTimings.frameTimestamp;
				rawTimings = frameTimings.timers;
				Runtime rt = Runtime.getRuntime();
				memoryTotal = rt.totalMemory() / MiB;
				memoryFree = rt.freeMemory() / MiB;
				memoryMax = rt.maxMemory() / MiB;
				memoryUsed = memoryTotal - memoryFree;
			}
		}
	}

	private Snapshot snapshot;

	public boolean isCapturingSnapshot() {
		return snapshot != null;
	}

	public void recordSnapshot() {
		clientThread.invoke(() -> {
			if (isCapturingSnapshot()) {
				sendGameMessage(String.format("Already capturing a snapshot (%d%% complete)", getProgressPercentage()));
				return;
			}

			snapshot = new Snapshot();
			snapshot.osName = System.getProperty("os.name");
			snapshot.osArch = System.getProperty("os.arch");
			snapshot.osVersion = System.getProperty("os.version");
			snapshot.javaVersion = System.getProperty("java.version");
			snapshot.cpuCores = Runtime.getRuntime().availableProcessors();
			snapshot.memoryMaxMiB = Runtime.getRuntime().maxMemory() / MiB;
			snapshot.gpuName = String.format(
				"%s (%s, OpenGL %s)",
				glGetString(GL_RENDERER),
				glGetString(GL_VENDOR),
				glGetString(GL_VERSION)
			);

			String prefix = HdPluginConfig.CONFIG_GROUP + ".";
			for (String config : configManager.getConfigurationKeys(prefix)) {
				String key = config.substring(prefix.length());
				snapshot.settings.put(key, configManager.getConfiguration("hd", key));
			}

			frameTimer.addTimingsListener(this);
			sendGameMessage(String.format("Capturing frame timings for %.0f seconds...", SNAPSHOT_DURATION_MS / 1e3f));
		});
	}

	public int getProgressPercentage() {
		if (isCapturingSnapshot())
			return round((float) (System.currentTimeMillis() - snapshot.timestamp) / SNAPSHOT_DURATION_MS * 100);
		return 100;
	}

	@Override
	public void onFrameCompletion(FrameTimings timings) {
		if (!isCapturingSnapshot()) {
			frameTimer.removeTimingsListener(this);
			return;
		}

		if (timings.frameTimestamp - snapshot.timestamp > SNAPSHOT_DURATION_MS) {
			saveSnapshot();
			return;
		}

		var frame = new Snapshot.Frame(timings);
		frame.drawnTiles = plugin.getDrawnTileCount();
		frame.drawnStatic = plugin.getDrawnStaticRenderableCount();
		frame.drawnDynamic = plugin.getDrawnDynamicRenderableCount();
		frame.npcDisplacementCacheSize = npcDisplacementCache.size();
		snapshot.frames.add(frame);
	}

	private void saveSnapshot() {
		frameTimer.removeTimingsListener(this);

		for (var frame : snapshot.frames) {
			frame.cpu = new LinkedHashMap<>();
			frame.gpu = new LinkedHashMap<>();
			for (Timer t : Timer.values())
				(t.isGpuTimer ? frame.gpu : frame.cpu).put(t.name, frame.rawTimings[t.ordinal()]);
		}

		try {
			SNAPSHOTS_PATH.mkdirs();
			String timestamp = new SimpleDateFormat("yyyy-MM-dd_HH-mm-ss").format(snapshot.timestamp);
			var path = SNAPSHOTS_PATH.resolve("snapshot-" + timestamp);
			path.setExtension("json").writeString(gson.toJson(snapshot));
			saveCsvSnapshot(path);
			sendGameMessage("Snapshot complete! Saved to: " + path + ".csv & json");
		} catch (IOException ex) {
			log.error("Error while saving snapshot:", ex);
		}

		snapshot = null;
	}

	private String escapeCsv(String string) {
		string = string.replaceAll("\"", "\"\"");
		if (string.contains(",") || string.contains("\n"))
			string = '"' + string + '"';
		return string;
	}

	private void writeCsvObject(PrintWriter out, boolean header, String prefix, JsonObject obj) {
		String comma = "";
		for (var entry : obj.entrySet()) {
			out.write(comma);
			var value = entry.getValue();
			if (value.isJsonObject()) {
				writeCsvObject(out, header, prefix + entry.getKey() + ".", value.getAsJsonObject());
			} else {
				out.write(escapeCsv(header ? prefix + entry.getKey() : value.toString()));
			}
			comma = ",";
		}
	}

	private void saveCsvSnapshot(ResourcePath path) throws IOException {
		if (snapshot.frames.isEmpty())
			return;

		var frames = gson.toJsonTree(snapshot.frames).getAsJsonArray();
		try (var out = new PrintWriter(path.setExtension("csv").toWriter())) {
			writeCsvObject(out, true, "", frames.get(0).getAsJsonObject());
			out.println();
			for (var frame : frames) {
				writeCsvObject(out, false, "", frame.getAsJsonObject());
				out.println();
			}
		}
	}

	private void sendGameMessage(String message) {
		clientThread.invoke(() -> client.addChatMessage(
			ChatMessageType.GAMEMESSAGE, "117 HD", "<col=ffff00>[117 HD] " + message + "</col>", "117 HD"));
	}
}

/*
 * Color utility functions
 * Written in 2023 by Hooder <ahooder@protonmail.com>
 * To the extent possible under law, the author(s) have dedicated all copyright and related and neighboring rights
 * to this software to the public domain worldwide. This software is distributed without any warranty.
 * You should have received a copy of the CC0 Public Domain Dedication along with this software.
 * If not, see <http://creativecommons.org/publicdomain/zero/1.0/>.
 */
package rs117.hd.utils;

import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonToken;
import com.google.gson.stream.JsonWriter;
import java.awt.Color;
import java.io.IOException;
import java.util.Arrays;
import lombok.extern.slf4j.Slf4j;
import rs117.hd.utils.GsonUtils.DelegateFloatAdapter;

import static rs117.hd.utils.MathUtils.*;

public class ColorUtils {
	private static final float EPS = 1e-4f;

	/**
	 * Row-major transformation matrices for conversion between RGB and XYZ color spaces.
	 * Fairman, H. S., Brill, M. H., & Hemmendinger, H. (1997).
	 * How the CIE 1931 color-matching functions were derived from Wright-Guild data.
	 * Color Research & Application, 22(1), 11–23.
	 * doi:10.1002/(sici)1520-6378(199702)22:1<11::aid-col4>3.0.co;2-7
	 */
	private static final float[] RGB_TO_XYZ_MATRIX = {
		.49f, .31f, .2f,
		.1769f, .8124f, .0107f,
		.0f,    .0099f, .9901f
	};
	private static final float[] XYZ_TO_RGB_MATRIX = {
		2.36449f,    -.896553f,  -.467937f,
		-.514935f,   1.42633f,    .0886025f,
		 .00514883f, -.0142619f, 1.00911f
	};

	/**
	 * Approximate UV coordinates in the CIE 1960 UCS color space from a color temperature specified in degrees Kelvin.
	 * @param kelvin temperature in degrees Kelvin. Valid from 1000 to 15000.
	 * @see <a href="https://doi.org/10.1002/col.5080100109">
	 *     Krystek, M. (1985). An algorithm to calculate correlated colour temperature.
	 *     Color Research & Application, 10(1), 38–40. doi:10.1002/col.5080100109
	 * </a>
	 * @return UV coordinates in the UCS color space
	 */
	public static float[] colorTemperatureToLinearRgb(double kelvin) {
		// UV coordinates in CIE 1960 UCS color space
		double[] uv = new double[] {
			(0.860117757 + 1.54118254e-4 * kelvin + 1.28641212e-7 * kelvin * kelvin)
				/ (1 + 8.42420235e-4 * kelvin + 7.08145163e-7 * kelvin * kelvin),
			(0.317398726 + 4.22806245e-5 * kelvin + 4.20481691e-8 * kelvin * kelvin)
				/ (1 - 2.89741816e-5 * kelvin + 1.61456053e-7 * kelvin * kelvin)
		};

		// xy coordinates in CIES 1931 xyY space
		double divisor = 2 * uv[0] - 8 * uv[1] + 4;
		double[] xy = new double[] { 3 * uv[0] / divisor,  2 * uv[1] / divisor };

		// CIE XYZ space
		float Y = 1;
		float[] XYZ = { (float) (xy[0] * Y / xy[1]), Y, (float) ((1 - xy[0] - xy[1]) * Y / xy[1]) };

		return XYZtoRGB(XYZ);
	}

	/**
	 * Transform from CIE 1931 XYZ color space to linear RGB.
	 * @param XYZ coordinates
	 * @return linear RGB coordinates
	 */
	public static float[] XYZtoRGB(float[] XYZ) {
		float[] RGB = new float[3];
		mat3MulVec3(RGB, XYZ_TO_RGB_MATRIX, XYZ);
		return RGB;
	}

	/**
	 * Transform from linear RGB to CIE 1931 XYZ color space.
	 * @param RGB linear RGB color coordinates
	 * @return XYZ color coordinates
	 */
	public static float[] RGBtoXYZ(float[] RGB) {
		float[] XYZ = new float[3];
		mat3MulVec3(XYZ, RGB_TO_XYZ_MATRIX, RGB);
		return XYZ;
	}

	private static void mat3MulVec3(float[] out, float[] m, float[] v) {
		out[0] = m[0] * v[0] + m[1] * v[1] + m[2] * v[2];
		out[1] = m[3] * v[0] + m[4] * v[1] + m[5] * v[2];
		out[2] = m[6] * v[0] + m[7] * v[1] + m[8] * v[2];
	}

	// Conversion functions to and from sRGB and linear color space.
	// The implementation is based on the sRGB EOTF given in the Khronos Data Format Specification.
	// Source: https://web.archive.org/web/20220808015852/https://registry.khronos.org/DataFormat/specs/1.3/dataformat.1.3.pdf
	// Page number 130 (146 in the PDF)
	public static float linearToSrgb(float c) {
		return c <= 0.0031308f ?
			c * 12.92f :
			1.055f * pow(c, 1 / 2.4f) - 0.055f;
	}

	public static float srgbToLinear(float c) {
		return c <= 0.04045f ?
			c / 12.92f :
			pow((c + 0.055f) / 1.055f, 2.4f);
	}

	public static float[] linearToSrgb(float... c) {
		float[] result = new float[c.length];
		for (int i = 0; i < c.length; i++)
			result[i] = linearToSrgb(c[i]);
		return result;
	}

	public static float[] srgbToLinear(float... c) {
		float[] result = new float[c.length];
		for (int i = 0; i < c.length; i++)
			result[i] = srgbToLinear(c[i]);
		return result;
	}

	/**
	 * Convert sRGB in the range 0-1 to HSL in the range 0-1.
	 *
	 * @param srgb float[3]
	 * @return hsl float[3]
	 * @link <a href="https://web.archive.org/web/20230619214343/https://en.wikipedia.org/wiki/HSL_and_HSV#Color_conversion_formulae">Wikipedia: HSL and HSV</a>
	 */
	public static float[] srgbToHsl(float[] srgb) {
		float V = max(srgb);
		float X_min = min(srgb);
		float C = V - X_min;

		float H = 0;
		if (C > 0) {
			if (V == srgb[0]) {
				H = mod((srgb[1] - srgb[2]) / C, 6);
			} else if (V == srgb[1]) {
				H = (srgb[2] - srgb[0]) / C + 2;
			} else {
				H = (srgb[0] - srgb[1]) / C + 4;
			}
			assert H >= 0 && H <= 6;
		}

		float L = (V + X_min) / 2;
		float divisor = 1 - abs(2 * L - 1);
		float S_L = abs(divisor) < EPS ? 0 : C / divisor;
		return new float[] { H / 6, S_L, L };
	}

	/**
	 * Convert HSL in the range 0-1 to sRGB in the range 0-1.
	 *
	 * @param hsl float[3]
	 * @return srgb float[3]
	 * @link <a href="https://web.archive.org/web/20230619214343/https://en.wikipedia.org/wiki/HSL_and_HSV#Color_conversion_formulae">Wikipedia: HSL and HSV</a>
	 */
	public static float[] hslToSrgb(float[] hsl) {
		float C = hsl[1] * (1 - abs(2 * hsl[2] - 1));
		float H_prime = fract(hsl[0]) * 6;
		float m = hsl[2] - C / 2;

		float r = clamp(abs(H_prime - 3) - 1, 0, 1) * C + m;
		float g = clamp(2 - abs(H_prime - 2), 0, 1) * C + m;
		float b = clamp(2 - abs(H_prime - 4), 0, 1) * C + m;
		return new float[] { r, g, b };
	}

	/**
	 * Convert HSL in the range 0-1 to HSV in the range 0-1.
	 *
	 * @param hsl float[3]
	 * @return hsv float[3]
	 */
	public static float[] hslToHsv(float[] hsl) {
		float v = hsl[2] + hsl[1] * min(hsl[2], 1 - hsl[2]);
		return vec(hsl[0], abs(v) < EPS ? 0 : 2 * (1 - hsl[2] / v), v);
	}

	/**
	 * Convert HSV in the range 0-1 to HSL in the range 0-1.
	 *
	 * @param hsv float[3]
	 * @return hsl float[3]
	 */
	public static float[] hsvToHsl(float[] hsv) {
		float l = hsv[2] * (1 - hsv[1] / 2);
		float divisor = min(l, 1 - l);
		return vec(hsv[0], abs(divisor) < EPS ? 0 : (hsv[2] - l) / divisor, l);
	}

	/**
	 * Convert sRGB in the range 0-1 from sRGB to HSV (also known as HSB) in the range 0-1.
	 *
	 * @param srgb float[3]
	 * @return hsv float[3]
	 * @link <a href="https://web.archive.org/web/20230619214343/https://en.wikipedia.org/wiki/HSL_and_HSV#Color_conversion_formulae">Wikipedia: HSL and HSV</a>
	 */
	public static float[] srgbToHsv(float[] srgb) {
		return hslToHsv(srgbToHsl(srgb));
	}

	/**
	 * Convert HSV (also known as HSB) in the range 0-1 to sRGB in the range 0-1.
	 *
	 * @param hsv float[3]
	 * @return srgb float[3]
	 * @link <a href="https://web.archive.org/web/20230619214343/https://en.wikipedia.org/wiki/HSL_and_HSV#Color_conversion_formulae">Wikipedia: HSL and HSV</a>
	 */
	public static float[] hsvToSrgb(float[] hsv) {
		return hslToSrgb(hsvToHsl(hsv));
	}

	// Convenience functions for converting different formats into linear RGB, sRGB or packed HSL

	/**
	 * Convert red, green and blue in the range 0-255 from sRGB to linear RGB in the range 0-1.
	 *
	 * @param r red color
	 * @param g green color
	 * @param b blue color
	 * @return float[3] linear rgb values from 0-1
	 */
	public static float[] rgb(float r, float g, float b) {
		return srgbToLinear(srgb(r, g, b));
	}

	/**
	 * Convert hex color from sRGB to linear RGB in the range 0-1.
	 *
	 * @param hex RGB hex color
	 * @return float[3] linear rgb values from 0-1
	 */
	public static float[] rgb(String hex) {
		return srgbToLinear(srgb(hex));
	}

	/**
	 * Convert sRGB color packed as an int to linear RGB in the range 0-1.
	 *
	 * @param srgb packed sRGB
	 * @return float[3] linear rgb values from 0-1
	 */
	public static float[] rgb(int srgb) {
		return srgbToLinear(srgb(srgb));
	}

	/**
	 * Convert red, green and blue in the range 0-255 from sRGB to sRGB in the range 0-1.
	 *
	 * @param r red color
	 * @param g green color
	 * @param b blue color
	 * @return float[3] non-linear sRGB values from 0-1
	 */
	public static float[] srgb(float r, float g, float b) {
		return new float[] { r / 255f, g / 255f, b / 255f };
	}

	/**
	 * Convert hex color from sRGB to sRGB in the range 0-1.
	 *
	 * @param hex RGB hex color
	 * @return float[3] non-linear sRGB values from 0-1
	 */
	public static float[] srgb(String hex) {
		Color color = Color.decode(hex);
		return srgb(color.getRed(), color.getGreen(), color.getBlue());
	}

	/**
	 * Convert sRGB color packed as an int to sRGB in the range 0-1.
	 *
	 * @param srgb packed sRGB
	 * @return float[3] non-linear sRGB values from 0-1
	 */
	public static float[] srgb(int srgb) {
		return new float[] {
			(srgb >> 16 & 0xFF) / (float) 0xFF,
			(srgb >> 8 & 0xFF) / (float) 0xFF,
			(srgb & 0xFF) / (float) 0xFF,
		};
	}

	public static float[] srgb(Color c) {
		return srgb(c.getRed(), c.getGreen(), c.getBlue());
	}

	/**
	 * Convert alpha and sRGB color packed in an int as ARGB to sRGB in the range 0-1.
	 *
	 * @param alphaSrgb packed sRGB with a preceding alpha channel
	 * @return float[4] non-linear sRGB and alpha in the range 0-1
	 */
	public static float[] srgba(int alphaSrgb) {
		return new float[] {
			(alphaSrgb >> 16 & 0xFF) / (float) 0xFF,
			(alphaSrgb >> 8 & 0xFF) / (float) 0xFF,
			(alphaSrgb & 0xFF) / (float) 0xFF,
			(alphaSrgb >> 24 & 0xFF) / (float) 0xFF
		};
	}

	/**
	 * Convert red, green and blue in the range 0-255 from sRGB to packed HSL.
	 *
	 * @param r red color
	 * @param g green color
	 * @param b blue color
	 * @return int packed HSL
	 */
	public static int hsl(float r, float g, float b) {
		return srgbToPackedHsl(srgb(r, g, b));
	}

	/**
	 * Convert hex color from sRGB to packed HSL.
	 *
	 * @param rgbHex RGB hex color
	 * @return int packed HSL
	 */
	public static int hsl(String rgbHex) {
		return srgbToPackedHsl(srgb(rgbHex));
	}

	/**
	 * Convert sRGB color packed as an int to packed HSL.
	 *
	 * @param packedSrgb RGB hex color
	 * @return int packed HSL
	 */
	public static int hsl(int packedSrgb) {
		return srgbToPackedHsl(srgb(packedSrgb));
	}

	// Integer packing and unpacking functions

	public static int packRawRgb(int... rgb) {
		return rgb[0] << 16 | rgb[1] << 8 | rgb[2];
	}

	public static int packSrgb(float[] srgb) {
		return packRawRgb(ivec(multiply(saturate(srgb), 0xFF)));
	}

	public static int packRawHsl(int... hsl) {
		return hsl[0] << 10 | hsl[1] << 7 | hsl[2];
	}

	public static void unpackRawHsl(int[] out, int hsl) {
		// 6-bit hue | 3-bit saturation | 7-bit lightness
		out[0] = hsl >>> 10 & 0x3F;
		out[1] = hsl >>> 7 & 0x7;
		out[2] = hsl & 0x7F;
	}

	public static int[] unpackRawHsl(int hsl) {
		int[] out = new int[3];
		unpackRawHsl(out, hsl);
		return out;
	}

	public static int packHsl(float... hsl) {
		int H = clamp(round((hsl[0] - .0078125f) * (0x3F + 1)), 0, 0x3F);
		int S = clamp(round((hsl[1] - .0625f) * (0x7 + 1)), 0, 0x7);
		int L = clamp(round(hsl[2] * (0x7F + 1)), 0, 0x7F);
		return packRawHsl(H, S, L);
	}

	public static float[] unpackHsl(int hsl) {
		// 6-bit hue | 3-bit saturation | 7-bit lightness
		float H = (hsl >>> 10 & 0x3F) / (0x3F + 1f) + .0078125f;
		float S = (hsl >>> 7 & 0x7) / (0x7 + 1f) + .0625f;
		float L = (hsl & 0x7F) / (0x7F + 1f);
		return new float[] { H, S, L };
	}

	public static int srgbToPackedHsl(float[] srgb) {
		return packHsl(srgbToHsl(srgb));
	}

	public static float[] packedHslToSrgb(int packedHsl) {
		return hslToSrgb(unpackHsl(packedHsl));
	}

	public static int linearRgbToPackedHsl(float[] linearRgb) {
		return srgbToPackedHsl(linearToSrgb(linearRgb));
	}

	public static float[] packedHslToLinearRgb(int hsl) {
		return srgbToLinear(packedHslToSrgb(hsl));
	}

	public static String srgbToHex(float... srgb) {
		return String.format("#%06x", packSrgb(srgb));
	}

	public static String rgbToHex(float... linearRgb) {
		return srgbToHex(linearToSrgb(linearRgb));
	}

	@Slf4j
	public static class SrgbAdapter extends DelegateFloatAdapter<float[]> {
		@Override
		public float[] read(JsonReader in) throws IOException {
			var token = in.peek();
			if (token == JsonToken.STRING)
				return ColorUtils.srgb(in.nextString());

			if (token != JsonToken.BEGIN_ARRAY)
				throw new IOException("Expected hex color code or array of color channels at " + GsonUtils.location(in));

			in.beginArray();
			float[] rgba = { 0, 0, 0, 1 };
			int i = 0;
			while (in.hasNext() && in.peek() != JsonToken.END_ARRAY) {
				if (in.peek() == JsonToken.NULL) {
					log.warn("Skipping null value in color array at {}", GsonUtils.location(in));
					in.skipValue();
					continue;
				}

				if (in.peek() == JsonToken.NUMBER) {
					if (i > 3) {
						log.warn("Skipping extra elements in color array at {}", GsonUtils.location(in));
						break;
					}

					rgba[i++] = FLOAT_ADAPTER.read(in);
					continue;
				}

				throw new IOException("Unexpected type in color array: " + in.peek() + " at " + GsonUtils.location(in));
			}
			in.endArray();

			if (i < 3)
				throw new IOException("Too few elements in color array: " + i + " at " + GsonUtils.location(in));

			for (int j = 0; j < i; j++)
				rgba[j] /= 255;

			if (i == 4)
				return rgba;

			return slice(rgba, 0, 3);
		}

		@Override
		public void write(JsonWriter out, float[] src) throws IOException {
			if (src == null || src.length == 0) {
				out.nullValue();
				return;
			}

			if (src.length != 3 && src.length != 4)
				throw new IOException("The number of components must be 3 or 4 in a color array. Got " + Arrays.toString(src));

			float[] rgba = { 0, 0, 0, 1 };
			int[] rgbaInt = { 0, 0, 0, 255 };
			for (int i = 0; i < src.length; i++)
				rgba[i] = src[i] * 255;

			// See if it can fit in a hex color code
			boolean canfit = true;
			for (int i = 0; i < src.length; i++) {
				float f = rgba[i];
				rgbaInt[i] = round(f);
				if (abs(f - rgbaInt[i]) > EPS) {
					canfit = false;
					break;
				}
			}

			if (canfit) {
				// Serialize it as a hex color code
				if (src.length == 3) {
					out.value(String.format("#%02x%02x%02x", rgbaInt[0], rgbaInt[1], rgbaInt[2]));
				} else {
					out.value(String.format("#%02x%02x%02x%02x", rgbaInt[0], rgbaInt[1], rgbaInt[2], rgbaInt[3]));
				}
			} else {
				out.beginArray();
				for (int i = 0; i < src.length; i++)
					FLOAT_ADAPTER.write(out, rgba[i]);
				out.endArray();
			}
		}
	}

	@Slf4j
	public static class SrgbToLinearAdapter extends SrgbAdapter {
		@Override
		public float[] read(JsonReader in) throws IOException {
			return srgbToLinear(super.read(in));
		}

		@Override
		public void write(JsonWriter out, float[] src) throws IOException {
			super.write(out, linearToSrgb(src));
		}
	}

	public static class LinearAdapter extends DelegateFloatAdapter<Float> {
		@Override
		public Float read(JsonReader in) throws IOException {
			var value = FLOAT_ADAPTER.read(in);
			return value == null ? null : srgbToLinear(value);
		}

		@Override
		public void write(JsonWriter out, Float value) throws IOException {
			FLOAT_ADAPTER.write(out, value == null ? null : linearToSrgb(value));
		}
	}
}

/*
 * Copyright (c) 2025, Hooder <ahooder@protonmail.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package rs117.hd.overlays;

import com.google.inject.Singleton;
import java.awt.Color;
import java.awt.Cursor;
import java.awt.Dimension;
import java.awt.Graphics2D;
import java.awt.Point;
import java.awt.Rectangle;
import java.io.IOException;
import java.util.function.Consumer;
import javax.inject.Inject;
import lombok.Getter;
import lombok.Setter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.*;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.eventbus.EventBus;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.ui.ClientUI;
import net.runelite.client.ui.overlay.Overlay;
import net.runelite.client.ui.overlay.OverlayLayer;
import net.runelite.client.ui.overlay.OverlayManager;
import net.runelite.client.ui.overlay.OverlayPosition;
import rs117.hd.HdPlugin;
import rs117.hd.opengl.shader.ShaderException;
import rs117.hd.opengl.shader.ShaderProgram;
import rs117.hd.opengl.shader.ShaderTemplate;
import rs117.hd.utils.ShaderRecompile;

import static org.lwjgl.opengl.GL33C.*;
import static rs117.hd.utils.MathUtils.*;

@Slf4j
@Singleton
public class ShaderOverlay<T extends ShaderOverlay.Shader> extends Overlay {
	@Inject
	private Client client;

	@Inject
	private ClientUI clientUI;

	@Inject
	private ClientThread clientThread;

	@Inject
	private EventBus eventBus;

	@Inject
	private OverlayManager overlayManager;

	@Inject
	private HdPlugin plugin;

	@Inject
	public T shader;

	@Getter
	@Setter
	private boolean borderless;

	@Getter
	private boolean centered;

	@Setter
	private boolean maintainAspectRatio;

	@Getter
	private boolean fullscreen;

	private boolean movable = true;
	private boolean snappable = true;

	private boolean initialized;
	private final Dimension initialSize = new Dimension(256, 256);
	private long becameHiddenAt;
	private boolean isHidden = true;
	private boolean skipNextGetPreferredLocation;
	private boolean isProbablyStartingResize;
	private Rectangle resizeStartingBounds = new Rectangle();
	private final float[] aspectRatioRoundingError = { 0, 0 };

	public static class Shader extends ShaderProgram {
		protected final Uniform4f uniTransform = addUniform4f("transform");

		public Shader(Consumer<ShaderTemplate> templateConsumer) {
			super(template -> {
				template
					.add(GL_VERTEX_SHADER, "overlays/overlay_vert.glsl")
					.add(GL_FRAGMENT_SHADER, "overlays/overlay_frag.glsl");
				templateConsumer.accept(template);
			});
		}
	}

	public ShaderOverlay() {
		setLayer(OverlayLayer.ABOVE_WIDGETS);
		setResizable(true);
	}

	public void initialize() {
		try {
			shader.compile(plugin.getShaderIncludes());
		} catch (Exception ex) {
			log.error("Failed to compile shader:", ex);
			return;
		}
		overlayManager.add(this);
		eventBus.register(this);
		initialized = true;
	}

	public void destroy() {
		initialized = false;
		isHidden = true;
		becameHiddenAt = 0;
		overlayManager.remove(this);
		eventBus.unregister(this);
		shader.destroy();
	}

	public void setActive(boolean activate) {
		if (activate == initialized)
			return;

		clientThread.invoke(() -> {
			if (activate) {
				initialize();
			} else {
				destroy();
			}
		});
	}

	@Override
	protected void setMovable(boolean movable) {
		super.setMovable(movable);
		this.movable = movable;
	}

	@Override
	protected void setSnappable(boolean snappable) {
		super.setSnappable(snappable);
		this.snappable = snappable;
	}

	protected void setFullscreen(boolean fullscreen) {
		this.fullscreen = fullscreen;
		if (fullscreen) {
			setPosition(OverlayPosition.DYNAMIC);
		} else {
			setPosition(OverlayPosition.TOP_LEFT);
		}
	}

	protected void setCentered(boolean centered) {
		this.centered = centered;
		setPosition(centered ? OverlayPosition.DYNAMIC : OverlayPosition.TOP_LEFT);
		super.setMovable(movable);
		super.setSnappable(snappable);
	}

	public boolean shouldMaintainAspectRatio() {
		return maintainAspectRatio;
	}

	protected void setInitialSize(int width, int height) {
		initialSize.setSize(width, height);
	}

	@Override
	public Dimension getPreferredSize() {
		if (isFullscreen())
			return null;
		var size = super.getPreferredSize();
		return size != null ? size : new Dimension(initialSize);
	}

	private boolean isLoggedIn() {
		return client != null && client.getGameState().getState() >= GameState.LOGGED_IN.getState();
	}

	private boolean shouldKeepCentered() {
		// If centered & not at a custom position & not in a snap corner & currently logged in to interact with overlays
		return centered && getPreferredLocation() == null && getPreferredPosition() == null && isLoggedIn();
	}

	@Override
	public Rectangle getBounds() {
		var bounds = super.getBounds();
		if (shouldKeepCentered()) {
			bounds.setSize(getPreferredSize());
			bounds.x = (client.getCanvasWidth() - bounds.width) / 2;
			bounds.y = (client.getCanvasHeight() - bounds.height) / 2;
		}
		if (isProbablyStartingResize) {
			isProbablyStartingResize = false;
			resizeStartingBounds = new Rectangle(bounds);
		}
		return bounds;
	}

	@Override
	public Point getPreferredLocation() {
		// Hacky way to prevent RuneLite from updating the location during resizing
		if (skipNextGetPreferredLocation) {
			skipNextGetPreferredLocation = false;
			return null;
		}
		return super.getPreferredLocation();
	}

	@Override
	public void setPreferredLocation(Point preferredLocation) {
		// Reset the hide timer while resizing
		if (!resizeStartingBounds.isEmpty())
			resetHideTimer();
		super.setPreferredLocation(preferredLocation);
	}

	@Override
	public boolean isResizable() {
		isProbablyStartingResize = true;
		return super.isResizable();
	}

	@Override
	public void setPreferredSize(Dimension size) {
		if (size != null) {
			// Reset the hide timer while resizing
			if (!resizeStartingBounds.isEmpty())
				resetHideTimer();

			int minWidth, minHeight;
			minWidth = minHeight = getMinimumSize();
			int maxWidth = client.getCanvasWidth() - 1;
			int maxHeight = client.getCanvasHeight() - 1;
			var cursor = clientUI.getCurrentCursor().getType();

			// Take over resizing when centered
			if (shouldKeepCentered()) {
				var prev = getPreferredSize();
				var mouse = client.getMouseCanvasPosition();
				if (size.width != prev.width)
					size.width = 2 * mouse.getX() - maxWidth;
				if (size.height != prev.height)
					size.height = 2 * mouse.getY() - maxHeight;

				switch (cursor) {
					case Cursor.NW_RESIZE_CURSOR:
						size.height *= -1;
					case Cursor.W_RESIZE_CURSOR:
					case Cursor.SW_RESIZE_CURSOR:
						size.width *= -1;
						break;
					case Cursor.N_RESIZE_CURSOR:
					case Cursor.NE_RESIZE_CURSOR:
						size.height *= -1;
						break;
				}

				size.width = clamp(size.width, minWidth, maxWidth);
				size.height = clamp(size.height, minHeight, maxHeight);
			}

			if (shouldMaintainAspectRatio()) {
				float aspectRatio = (float) initialSize.width / initialSize.height;
				if (aspectRatio > 1) {
					minWidth = round(minHeight * aspectRatio);
					maxHeight = round(maxWidth / aspectRatio);
				} else {
					minHeight = round(minWidth / aspectRatio);
					maxWidth = round(maxHeight * aspectRatio);
				}

				boolean resizingHeight = cursor == Cursor.N_RESIZE_CURSOR || cursor == Cursor.S_RESIZE_CURSOR;
				if (resizingHeight) {
					size.width = round(size.height * aspectRatio);
				} else {
					size.height = round(size.width / aspectRatio);
				}

				size.width = clamp(size.width, minWidth, maxWidth);
				size.height = clamp(size.height, minHeight, maxHeight);

				var loc = getPreferredLocation();
				if (loc != null) {
					var prevSize = getPreferredSize();
					int widthChange = size.width - prevSize.width;
					int heightChange = size.height - prevSize.height;

					// Since we'll be skipping RuneLite's location adjustment, we must add it in ourselves
					switch (cursor) {
						case Cursor.N_RESIZE_CURSOR:
						case Cursor.NE_RESIZE_CURSOR:
							loc.y -= heightChange;
							break;
						case Cursor.W_RESIZE_CURSOR:
						case Cursor.SW_RESIZE_CURSOR:
							loc.x -= widthChange;
							break;
						case Cursor.NW_RESIZE_CURSOR:
							loc.x -= widthChange;
							loc.y -= heightChange;
							break;
					}

					// If adjusting along one dimension, automatically adjust the other dimension to maintain the aspect ratio
					switch (cursor) {
						case Cursor.N_RESIZE_CURSOR:
						case Cursor.S_RESIZE_CURSOR:
						case Cursor.E_RESIZE_CURSOR:
						case Cursor.W_RESIZE_CURSOR:
							if (resizingHeight) {
								float shouldSubtract = widthChange / 2f + aspectRatioRoundingError[0];
								int willSubtract = (int) shouldSubtract;
								aspectRatioRoundingError[0] = shouldSubtract - willSubtract;
								loc.x -= willSubtract;
							} else {
								float shouldSubtract = heightChange / 2f + aspectRatioRoundingError[1];
								int willSubtract = (int) shouldSubtract;
								aspectRatioRoundingError[1] = shouldSubtract - willSubtract;
								loc.y -= willSubtract;
							}
							break;
					}

					// Update the location and skip the next location update to ignore RuneLite's resize location change
					setPreferredLocation(loc);
					skipNextGetPreferredLocation = true;
				}
			}
		}

		super.setPreferredSize(size);
	}

	@Subscribe
	public void onShaderRecompile(ShaderRecompile event) throws ShaderException, IOException {
		shader.compile(event.includes);
	}

	public boolean isHidden() {
		return !initialized || !shader.isValid() || !isLoggedIn();
	}

	public boolean isManageable() {
		return isMovable() || isResizable();
	}

	private void updateTransform() {
		assert shader.isActive();
		if (isFullscreen()) {
			shader.uniTransform.set(0, 0, 1, 1);
		} else {
			int[] resolution = plugin.getUiResolution();
			if (resolution == null)
				return;
			var bounds = getBounds();
			// Calculate translation and scale in NDC
			float[] rect = { bounds.x + 1, bounds.y + 1, bounds.width - 1, bounds.height - 1 };
			rect[0] += rect[0] + rect[2];
			rect[1] += rect[1] + rect[3];
			for (int i = 0; i < 2; i++) {
				rect[i * 2] /= resolution[0];
				rect[i * 2 + 1] /= resolution[1];
				rect[i] -= 1;
			}
			rect[1] *= -1;
			shader.uniTransform.set(rect);
		}
	}

	public void render() {
		if (isHidden())
			return;

		shader.use();
		updateTransform();
		updateUniforms();
		renderShader();
	}

	protected void updateUniforms() {}

	protected void renderShader() {
		glEnable(GL_BLEND);
		glBlendFuncSeparate(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA, GL_ZERO, GL_ONE);
		if (fullscreen) {
			glBindVertexArray(plugin.vaoTri);
			glDrawArrays(GL_TRIANGLES, 0, 3);
		} else {
			glBindVertexArray(plugin.vaoQuad);
			glDrawArrays(GL_TRIANGLE_FAN, 0, 4);
		}
	}

	private void resetHideTimer() {
		becameHiddenAt = System.currentTimeMillis();
	}

	private long getTimeSinceHiding() {
		return System.currentTimeMillis() - becameHiddenAt;
	}

	private boolean getUpdatedHiddenState() {
		boolean isHidden = isHidden();
		if (isHidden && !this.isHidden)
			resetHideTimer();
		return this.isHidden = isHidden;
	}

	@Override
	public Dimension render(Graphics2D g) {
		var bounds = getBounds();
		if (getUpdatedHiddenState()) {
			// When the overlay is hidden, keep it manageable for a minute by not returning null
			if (!isManageable() || getTimeSinceHiding() >= 60000) {
				resizeStartingBounds.setSize(0, 0);
				return null;
			}
		} else if (!borderless) {
			g.setColor(Color.BLACK);
			g.drawRect(0, 0, bounds.width, bounds.height);
		}
		return bounds.getSize();
	}

	protected void drawStringShadowed(Graphics2D g, String s, float x, float y) {
		var c = g.getColor();
		g.setColor(Color.BLACK);
		g.drawString(s, x + 1, y + 1);
		g.setColor(c);
		g.drawString(s, x, y);
	}

	protected void drawStringCentered(Graphics2D g, String s, float x, float y) {
		var m = g.getFontMetrics();
		drawStringShadowed(g, s, x - m.stringWidth(s) / 2.f, y + m.getHeight() / 2.f);
	}

	protected void drawStringCentered(Graphics2D g, String s) {
		var b = g.getClipBounds();
		drawStringCentered(g, s, b.width / 2.f, b.height / 2.f);
	}
}

package rs117.hd.overlays;

import java.awt.Color;
import java.awt.Dimension;
import java.awt.Graphics2D;
import javax.inject.Inject;
import javax.inject.Singleton;
import lombok.extern.slf4j.Slf4j;
import net.runelite.client.ui.overlay.OverlayLayer;
import rs117.hd.HdPlugin;
import rs117.hd.config.DynamicLights;

import static org.lwjgl.opengl.GL33C.*;
import static rs117.hd.HdPlugin.TEXTURE_UNIT_TILED_LIGHTING_MAP;

@Slf4j
@Singleton
public class TiledLightingOverlay extends ShaderOverlay<TiledLightingOverlay.Shader> {
	static class Shader extends ShaderOverlay.Shader {
		private final UniformTexture uniTiledLightingTextureArray = addUniformTexture("tiledLightingArray");

		public Shader() {
			super(t -> t.add(GL_FRAGMENT_SHADER, "overlays/tiled_lighting_overlay_frag.glsl"));
		}

		@Override
		protected void initialize() {
			uniTiledLightingTextureArray.set(TEXTURE_UNIT_TILED_LIGHTING_MAP);
		}
	}

	@Inject
	private HdPlugin plugin;

	public TiledLightingOverlay() {
		setLayer(OverlayLayer.ABOVE_SCENE);
		setFullscreen(true);
	}

	@Override
	public boolean isHidden() {
		return super.isHidden() || plugin.configDynamicLights == DynamicLights.NONE || !plugin.configTiledLighting;
	}

	@Override
	public Dimension render(Graphics2D g) {
		if (!super.isHidden()) {
			g.setColor(Color.YELLOW);
			boolean usingImageLoadStore = plugin.getTiledLightingImageStoreProgram().isValid();
			drawStringShadowed(g, String.format("Using GL_ARB_shader_image_load_store: %B", usingImageLoadStore), 4, 32);
			if (plugin.configDynamicLights == DynamicLights.NONE) {
				drawStringCentered(g, "Dynamic lights are disabled");
			} else if (!plugin.configTiledLighting) {
				drawStringCentered(g, "Tiled lighting is disabled");
			}
		}
		return super.render(g);
	}
}

package rs117.hd.overlays;

import com.google.inject.Singleton;
import lombok.extern.slf4j.Slf4j;

import static org.lwjgl.opengl.GL33C.*;
import static rs117.hd.HdPlugin.TEXTURE_UNIT_SHADOW_MAP;

@Slf4j
@Singleton
public class ShadowMapOverlay extends ShaderOverlay<ShadowMapOverlay.Shader> {
	static class Shader extends ShaderOverlay.Shader {
		private final UniformTexture uniShadowMap = addUniformTexture("shadowMap");

		public Shader() {
			super(t -> t.add(GL_FRAGMENT_SHADER, "overlays/shadow_map_frag.glsl"));
		}

		@Override
		protected void initialize() {
			uniShadowMap.set(TEXTURE_UNIT_SHADOW_MAP);
		}
	}
}

package rs117.hd.overlays;

import com.google.inject.Singleton;
import java.awt.BasicStroke;
import java.awt.Color;
import java.awt.Dimension;
import java.awt.Font;
import java.awt.FontMetrics;
import java.awt.Graphics2D;
import java.awt.Polygon;
import java.awt.Rectangle;
import java.awt.RenderingHints;
import java.awt.Toolkit;
import java.awt.datatransfer.Clipboard;
import java.awt.datatransfer.StringSelection;
import java.awt.event.MouseEvent;
import java.awt.event.MouseWheelEvent;
import java.awt.geom.Rectangle2D;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Objects;
import java.util.function.Function;
import java.util.regex.Pattern;
import javax.annotation.Nonnull;
import javax.annotation.Nullable;
import javax.inject.Inject;
import javax.swing.SwingUtilities;
import lombok.Getter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.*;
import net.runelite.api.coords.*;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.input.MouseListener;
import net.runelite.client.input.MouseManager;
import net.runelite.client.input.MouseWheelListener;
import net.runelite.client.ui.FontManager;
import net.runelite.client.ui.overlay.Overlay;
import net.runelite.client.ui.overlay.OverlayLayer;
import net.runelite.client.ui.overlay.OverlayManager;
import net.runelite.client.ui.overlay.OverlayPosition;
import net.runelite.client.util.Text;
import org.apache.commons.lang3.tuple.Pair;
import rs117.hd.HdPlugin;
import rs117.hd.data.ObjectType;
import rs117.hd.scene.AreaManager;
import rs117.hd.scene.GamevalManager;
import rs117.hd.scene.MaterialManager;
import rs117.hd.scene.ProceduralGenerator;
import rs117.hd.scene.SceneContext;
import rs117.hd.scene.SceneUploader;
import rs117.hd.scene.TileOverrideManager;
import rs117.hd.scene.areas.AABB;
import rs117.hd.scene.areas.Area;
import rs117.hd.scene.materials.Material;
import rs117.hd.utils.ColorUtils;
import rs117.hd.utils.HDUtils;
import rs117.hd.utils.ModelHash;

import static net.runelite.api.Constants.*;
import static net.runelite.api.Constants.SCENE_SIZE;
import static net.runelite.api.Perspective.*;
import static rs117.hd.HdPlugin.ORTHOGRAPHIC_ZOOM;
import static rs117.hd.scene.SceneContext.SCENE_OFFSET;
import static rs117.hd.scene.tile_overrides.TileOverride.OVERLAY_FLAG;
import static rs117.hd.utils.HDUtils.HIDDEN_HSL;
import static rs117.hd.utils.MathUtils.*;

@Slf4j
@Singleton
public class TileInfoOverlay extends Overlay implements MouseListener, MouseWheelListener {
	private static final Font MONOSPACE_FONT = new Font("Courier New", Font.PLAIN, 12);
	private static final Color BACKDROP_COLOR = new Color(0, 0, 0, 100);
	private static final Color TRANSPARENT_YELLOW_50 = new Color(255, 255, 0, 50);
	private static final Color TRANSPARENT_YELLOW_100 = new Color(255, 255, 0, 100);
	private static final Color TRANSPARENT_WHITE_100 = new Color(255, 255, 255, 100);

	@Inject
	private Client client;

	@Inject
	private ClientThread clientThread;

	@Inject
	private OverlayManager overlayManager;

	@Inject
	private MouseManager mouseManager;

	@Inject
	private HdPlugin plugin;

	@Inject
	private MaterialManager materialManager;

	@Inject
	private TileOverrideManager tileOverrideManager;

	@Inject
	private GamevalManager gamevalManager;

	@Inject
	private ProceduralGenerator proceduralGenerator;

	@Getter
	private boolean active;

	private float[] mousePos;
	private boolean ctrlHeld;
	private boolean ctrlToggled;
	private boolean shiftHeld;
	private boolean altHeld;
	private float zoom = 1;

	private static final int MODE_TILE_INFO = 0;
	private static final int MODE_MODEL_INFO = 1;
	private static final int MODE_SCENE_AABBS = 2;
	private static final int MODE_OBJECT_IDS = 3;

	private int mode;
	private int aabbMarkingStage;
	private AABB pendingSelection;
	private final ArrayList<AABB> selections = new ArrayList<>();
	private final int[] selectedAreaAabb = { -1, 0 };
	private final int[] hoveredAreaAabb = { -1, 0 };
	private final int[][] markedWorldPoints = new int[2][3];
	private int[] hoveredWorldPoint = new int[3];
	private int targetPlane = MAX_Z - 1;
	private boolean selectionIncludeZ;

	private SceneContext currentSceneContext;
	private Area[] visibleAreas = new Area[0];
	private final AABB dummyAabb = new AABB(0, 0);
	private int[] sceneBase;
	private final ArrayList<String> hoveredGamevals = new ArrayList<>();
	private int hoveredGamevalsIndex;
	private int hoveredGamevalsHash;
	private int copiedGamevalsHash;

	public TileInfoOverlay() {
		setLayer(OverlayLayer.ABOVE_SCENE);
		setPosition(OverlayPosition.DYNAMIC);
	}

	public void setActive(boolean activate) {
		this.active = activate;
		if (activate) {
			overlayManager.add(this);
			// Listen to events before they're possibly consumed in DeveloperTools
			mouseManager.registerMouseListener(0, this);
			mouseManager.registerMouseWheelListener(this);
		} else {
			overlayManager.remove(this);
			mouseManager.unregisterMouseListener(this);
			mouseManager.unregisterMouseWheelListener(this);
		}
		tileOverrideManager.setTrackReplacements(activate);
	}

	@Override
	public synchronized Dimension render(Graphics2D g) {
		// Disable the overlay while loading a scene, since tile overrides aren't thread safe
		if (plugin.isLoadingScene())
			return null;

		var sceneContext = plugin.getSceneContext();
		if (sceneContext == null)
			return null;

		if (sceneContext != currentSceneContext) {
			currentSceneContext = sceneContext;

			hoveredAreaAabb[0] = -1;
			hoveredAreaAabb[1] = 0;
			copyTo(selectedAreaAabb, hoveredAreaAabb);

			sceneBase = Objects.requireNonNullElseGet(
				sceneContext.sceneBase,
				() -> HDUtils.getSceneBaseBestGuess(sceneContext.scene, client.getPlane())
			);

			if (sceneContext.sceneBase == null) {
				visibleAreas = new Area[0];
			} else {
				visibleAreas = Arrays
					.stream(AreaManager.AREAS)
					.map(area -> {
						var copy = new Area(area.name);
						copy.regions = area.regions;
						copy.regionBoxes = area.regionBoxes;
						copy.rawAabbs = area.rawAabbs;
						copy.normalize();
						copy.unhideAreas = area.unhideAreas;
						copy.aabbs = Arrays
							.stream(copy.aabbs)
							.map(aabb -> sceneContext.sceneBounds.intersects(aabb) ? aabb : dummyAabb)
							.toArray(AABB[]::new);
						return copy;
					})
					.filter(area -> Arrays.stream(area.aabbs)
						.anyMatch(aabb -> aabb != dummyAabb))
					.toArray(Area[]::new);
			}
		}

		boolean ctrlPressed = client.isKeyPressed(KeyCode.KC_CONTROL);
		if (ctrlHeld != ctrlPressed) {
			ctrlHeld = ctrlPressed;
			if (ctrlPressed)
				ctrlToggled = !ctrlToggled;
		}
		boolean shiftPressed = client.isKeyPressed(KeyCode.KC_SHIFT);
		if (shiftHeld != shiftPressed) {
			shiftHeld = shiftPressed;
			if (shiftPressed)
				mode = (mode + 1) % 4;
		}
		altHeld = client.isKeyPressed(KeyCode.KC_ALT);

		Tile[][][] tiles = sceneContext.scene.getExtendedTiles();
		int[][][] templateChunks = sceneContext.scene.isInstance() ? sceneContext.scene.getInstanceTemplateChunks() : null;
		Point canvasMousePos = client.getMouseCanvasPosition();
		mousePos = null;
		if (canvasMousePos != null && canvasMousePos.getX() != -1 && canvasMousePos.getY() != -1)
			mousePos = new float[] { canvasMousePos.getX(), canvasMousePos.getY() };
		hoveredGamevals.clear();

		int maxPlane = client.getPlane();
		int minPlane = 0;
		if (ctrlHeld)
			minPlane = maxPlane = targetPlane;

		if (mousePos != null) {
			g.setFont(FontManager.getRunescapeFont());
			g.setStroke(new BasicStroke(1, BasicStroke.CAP_BUTT, BasicStroke.JOIN_ROUND));

			tileLoop:
			for (int secondTry = 0; secondTry <= 1; secondTry++) {
				for (int z = maxPlane; z >= minPlane; z--) {
					for (int isBridge = 1; isBridge >= 0; isBridge--) {
						for (int x = 0; x < EXTENDED_SCENE_SIZE; x++) {
							for (int y = 0; y < EXTENDED_SCENE_SIZE; y++) {
								Tile tile = tiles[z][x][y];
								boolean shouldDraw = tile != null && (isBridge == 0 || tile.getBridge() != null);
								if (shouldDraw) {
									if (templateChunks != null) {
										int sx = x - SCENE_OFFSET;
										int sy = y - SCENE_OFFSET;
										if (sx < 0 || sy < 0 || sx >= SCENE_SIZE || sy >= SCENE_SIZE)
											continue;
										int chunk = templateChunks[z][sx / CHUNK_SIZE][sy / CHUNK_SIZE];
										if (chunk == -1 && !ctrlHeld)
											continue;
									}

									if (secondTry == 0) {
										var paint = tile.getSceneTilePaint();
										if ((paint == null || paint.getNeColor() == HIDDEN_HSL) && tile.getSceneTileModel() == null)
											continue;
									}

									if (mode == MODE_TILE_INFO || mode == MODE_MODEL_INFO) {
										if (!drawTileInfo(g, sceneContext, tile))
											continue;
									} else {
										if (altHeld) {
											g.setColor(Color.YELLOW);
										} else {
											g.setColor(Color.CYAN);
											if (isBridge == 1 && tile.getBridge() != null) {
												g.setColor(Color.MAGENTA);
												tile = tile.getBridge();
											}
										}
										var poly = getCanvasTilePoly(client, sceneContext.scene, tile);
										if (poly == null || !poly.contains(mousePos[0], mousePos[1]))
											continue;
										g.drawPolygon(poly);
									}

									int tileZ = tile.getRenderLevel();
									hoveredWorldPoint = sceneContext.extendedSceneToWorld(x, y, tileZ);

									break tileLoop;
								}
							}
						}
					}
				}
			}
		}

		hoveredGamevalsHash = hoveredGamevals.hashCode();

		switch (mode) {
			case MODE_OBJECT_IDS:
				drawAllIds(g, sceneContext);
				break;
			case MODE_SCENE_AABBS:
				g.setFont(FontManager.getRunescapeSmallFont());

				drawLoadingLines(g);
				drawRegionBoxes(g, sceneContext);

				if (mousePos != null) {
					hoveredAreaAabb[0] = -1;
					hoveredAreaAabb[1] = 0;
					float[] v = new float[2];
					outer:
					for (int i = 0; i < visibleAreas.length; i++) {
						var area = visibleAreas[i];
						for (int j = 0; j < area.aabbs.length; j++) {
							if (i == selectedAreaAabb[0] && j == selectedAreaAabb[1])
								continue;

							var aabb = toLocalAabb(sceneContext, cropAabb(sceneContext, area.aabbs[j]));
							var p = getAabbCanvasCenter(aabb);
							if (p != null) {
								subtract(v, mousePos, p);
								if (dot(v) < 26 * 26) {
									hoveredAreaAabb[0] = i;
									hoveredAreaAabb[1] = j;
									break outer;
								}
							}
						}
					}
				}

				for (int i = 0; i < visibleAreas.length; i++) {
					var area = visibleAreas[i];
					if (area.name.equals("ALL"))
						continue;

					boolean areaHovered = i == hoveredAreaAabb[0];
					boolean areaSelected = i == selectedAreaAabb[0];
					for (int j = 0; j < area.aabbs.length; j++) {
						AABB aabb = area.aabbs[j];
						if (aabb == dummyAabb)
							continue;

						boolean hovered = areaHovered && j == hoveredAreaAabb[1];
						boolean selected = areaSelected && j == selectedAreaAabb[1];
						if (hovered || selected)
							continue;

						String label = aabb.toArgs();
						if (aabb.isVolume())
							label = area.name + "[" + j + "]\n" + label;
						if (sceneContext.currentArea != null && sceneContext.currentArea.name.equals(area.name))
							label = "CURRENT\n" + label;

						// Since we have a bunch of AABBs spanning all planes,
						// it would be a bit obnoxious to always render the full AABB
						AABB croppedAabb = cropAabb(sceneContext, aabb);
						var localAabb = toLocalAabb(sceneContext, croppedAabb);

						g.setColor(TRANSPARENT_WHITE_100);
						drawLocalAabb(g, localAabb);

						g.setColor(Color.LIGHT_GRAY);
						drawLocalAabbLabel(g, localAabb, label, false);
					}

					for (int j = 0; j < area.unhideAreas.length; j++) {
						AABB aabb = area.unhideAreas[j];
						String label = aabb.toArgs();
						if (aabb.isVolume())
							label = area.name + ".unhide[" + j + "]\n" + label;
						if (sceneContext.currentArea != null && sceneContext.currentArea.name.equals(area.name))
							label = "CURRENT\n" + label;

						var localAabb = toLocalAabb(sceneContext, cropAabb(sceneContext, aabb));
						g.setColor(Color.PINK);
						drawLocalAabb(g, localAabb);
						drawLocalAabbLabel(g, localAabb, label, false);
					}
				}

				if (hoveredAreaAabb[0] != -1) {
					var area = visibleAreas[hoveredAreaAabb[0]];
					var aabb = area.aabbs[hoveredAreaAabb[1]];
					g.setColor(Color.WHITE);

					var localAabb = toLocalAabb(sceneContext, aabb);
					drawLocalAabb(g, localAabb);
					drawLocalAabbLabel(g, localAabb, area.name + "[" + hoveredAreaAabb[1] + "]\n" + aabb.toArgs(), false);
				}

				if (selectedAreaAabb[0] != -1) {
					var area = visibleAreas[selectedAreaAabb[0]];
					var aabb = area.aabbs[selectedAreaAabb[1]];
					g.setColor(Color.CYAN);

					var localAabb = toLocalAabb(sceneContext, aabb);
					drawLocalAabb(g, localAabb);
					drawLocalAabbLabel(g, localAabb, area.name + "[" + selectedAreaAabb[1] + "]\n" + aabb.toArgs(), true);
				}

				break;
		}

		// Update second selection point each frame
		if (aabbMarkingStage == 1) {
			System.arraycopy(hoveredWorldPoint, 0, markedWorldPoints[1], 0, 3);
			if (selectionIncludeZ || markedWorldPoints[0][2] != markedWorldPoints[1][2]) {
				pendingSelection = new AABB(markedWorldPoints[0], markedWorldPoints[1]);
			} else {
				pendingSelection = new AABB(
					markedWorldPoints[0][0],
					markedWorldPoints[0][1],
					markedWorldPoints[1][0],
					markedWorldPoints[1][1]
				);
			}
		}

		for (int i = 0; i < selections.size(); i++) {
			var aabb = selections.get(i);
			var localAabb = toLocalAabb(sceneContext, aabb);
			// Draw selection boxes
			g.setColor(Color.YELLOW);
			drawLocalAabb(g, localAabb);
			g.setFont(FontManager.getRunescapeFont());
			drawLocalAabbLabel(g, localAabb, "Selection[" + i + "]\n" + aabb.toArgs(), true);
		}

		if (pendingSelection != null) {
			var localAabb = toLocalAabb(sceneContext, pendingSelection);
			// Draw current selection box
			g.setColor(Color.YELLOW);
			drawLocalAabb(g, localAabb);
			g.setFont(FontManager.getRunescapeFont());
			drawLocalAabbLabel(g, localAabb, "Selection[" + selections.size() + "]\n" + pendingSelection.toArgs(), true);
		}

		if (sceneContext.sceneBase == null) {
			g.setColor(Color.RED);
			g.setFont(FontManager.getRunescapeFont());
			var b = g.getClipBounds();
			var str = "This is a non-contiguous instance. AABBs may not work.";
			int w = g.getFontMetrics().stringWidth(str);
			g.drawString(str, (int) (b.x + b.getWidth() / 2 - w / 2.f), 16);
		}

		return null;
	}

	private boolean drawTileInfo(Graphics2D g, SceneContext sceneContext, Tile tile) {
		boolean infoDrawn = false;

		if (tile != null) {
			Rectangle rect = null;
			Polygon poly;

			Tile bridge = tile.getBridge();
			if (bridge != null) {
				poly = getCanvasTilePoly(client, sceneContext.scene, bridge);
				if (poly != null && poly.contains(mousePos[0], mousePos[1])) {
					rect = drawTileInfo(g, sceneContext, bridge, poly, null);
					infoDrawn = true;
				}
			}

			poly = getCanvasTilePoly(client, sceneContext.scene, tile);
			if (poly != null && poly.contains(mousePos[0], mousePos[1])) {
				drawTileInfo(g, sceneContext, tile, poly, rect);
				infoDrawn = true;
			}
		}

		return infoDrawn;
	}

	private Rectangle drawTileInfo(Graphics2D g, SceneContext sceneContext, Tile tile, Polygon poly, Rectangle dodgeRect)
	{
		SceneTilePaint tilePaint = tile.getSceneTilePaint();
		SceneTileModel tileModel = tile.getSceneTileModel();

		Scene scene = sceneContext.scene;
		int tileX = tile.getSceneLocation().getX();
		int tileY = tile.getSceneLocation().getY();
		int tileZ = tile.getRenderLevel();
		int tileExX = tileX + SCENE_OFFSET;
		int tileExY = tileY + SCENE_OFFSET;
		int[] worldPos = sceneContext.sceneToWorld(tileX, tileY, tileZ);

		ArrayList<String> lines = new ArrayList<>();

		Color polyColor = Color.LIGHT_GRAY;
		if (mode == MODE_TILE_INFO) {
			sceneContext.tileOverrideVars.setTile(tile);
			if (tile.getBridge() != null)
				lines.add("Bridge");

			lines.add("Scene point: " + tileX + ", " + tileY + ", " + tileZ);
			lines.add("World point: " + Arrays.toString(worldPos));
			lines.add(String.format(
				"Region ID: %d (%d, %d)",
				HDUtils.worldToRegionID(worldPos),
				worldPos[0] >> 6,
				worldPos[1] >> 6
			));

			for (var environment : sceneContext.environments) {
				if (environment.area.containsPoint(worldPos)) {
					lines.add("Environment: " + environment);
					break;
				}
			}

			int overlayId = scene.getOverlayIds()[tileZ][tileExX][tileExY];
			var overlay = tileOverrideManager.getOverrideBeforeReplacements(worldPos, OVERLAY_FLAG | overlayId);
			var replacementPath = new StringBuilder(overlay.toString());
			while (true) {
				var replacement = overlay.resolveNextReplacement(sceneContext.tileOverrideVars);
				if (replacement == overlay)
					break;
				replacementPath.append("\n\t⤷ ").append(replacement);
				overlay = replacement;
			}
			lines.add(String.format("Overlay: ID %d -> %s", overlayId, replacementPath));
			lines.add(String.format(
				"GroundMaterial: %s -> %s",
				overlay.groundMaterial,
				overlay.groundMaterial.getRandomMaterial(worldPos)
			));

			int underlayId = scene.getUnderlayIds()[tileZ][tileExX][tileExY];
			var underlay = tileOverrideManager.getOverrideBeforeReplacements(worldPos, underlayId);
			replacementPath = new StringBuilder(underlay.toString());
			while (true) {
				var replacement = underlay.resolveNextReplacement(sceneContext.tileOverrideVars);
				if (replacement == underlay)
					break;
				replacementPath.append("\n\t⤷ ").append(replacement);
				underlay = replacement;
			}
			lines.add(String.format("Underlay: ID %d -> %s", underlayId, replacementPath));
			lines.add(String.format(
				"GroundMaterial: %s -> %s",
				underlay.groundMaterial,
				underlay.groundMaterial.getRandomMaterial(worldPos)
			));

			if (tilePaint != null) {
				polyColor = client.isKeyPressed(KeyCode.KC_ALT) ? Color.YELLOW : Color.CYAN;
				lines.add("Tile type: Paint");
				Material material = materialManager.fromVanillaTexture(tilePaint.getTexture());
				lines.add(String.format("Material: %s (%d)", material.name, tilePaint.getTexture()));
				lines.add(String.format("HSL: %s", hslString(tile)));

				var override = tileOverrideManager.getOverride(sceneContext, tile, worldPos, OVERLAY_FLAG | overlayId, underlayId);
				lines.add("WaterType: " + proceduralGenerator.seasonalWaterType(override, tilePaint.getTexture()));
			} else if (tileModel != null) {
				polyColor = Color.ORANGE;
				lines.add("Tile type: Model");
				lines.add(String.format("Face count: %d", tileModel.getFaceX().length));

				HashSet<String> uniqueMaterials = new HashSet<>();
				int numChars = 0;
				if (tileModel.getTriangleTextureId() != null) {
					for (int texture : tileModel.getTriangleTextureId()) {
						String material = String.format("%s (%d)", materialManager.fromVanillaTexture(texture).name, texture);
						boolean unique = uniqueMaterials.add(material);
						if (unique) {
							numChars += material.length();
						}
					}
				}

				ArrayList<String> materials = new ArrayList<>(uniqueMaterials);
				Collections.sort(materials);

				if (materials.size() <= 1 || numChars < 26) {
					StringBuilder sb = new StringBuilder("Materials: { ");
					if (materials.isEmpty()) {
						sb.append("null");
					} else {
						String prefix = "";
						for (String m : materials) {
							sb.append(prefix).append(m);
							prefix = ", ";
						}
					}
					sb.append(" }");
					lines.add(sb.toString());
				} else {
					Iterator<String> iter = materials.iterator();
					lines.add("Materials: { " + iter.next() + ",");
					while (iter.hasNext()) {
						lines.add("\t  " + iter.next() + (iter.hasNext() ? "," : " }"));
					}
				}

				lines.add(String.format("HSL: %s", hslString(tile)));
			}

			sceneContext.tileOverrideVars.setTile(null); // Avoid accidentally keeping the old scene in memory
		}

		var decorObject = tile.getDecorativeObject();
		if (decorObject != null) {
			lines.add(String.format(
				"Decor Object: %s preori=%d ori=%d offset=[%d, %d] type=%s %s",
				getIdAndImpostorId(decorObject, decorObject.getRenderable()),
				HDUtils.getModelPreOrientation(decorObject.getConfig()),
				HDUtils.getModelOrientation(decorObject.getConfig()),
				decorObject.getXOffset(),
				decorObject.getYOffset(),
				ObjectType.fromConfig(decorObject.getConfig()),
				getModelInfo(decorObject.getRenderable())
			));
			lines.add("Decor Type: " + ObjectType.fromConfig(decorObject.getConfig()));
		}

		GroundObject groundObject = tile.getGroundObject();
		if (groundObject != null) {
			lines.add(String.format(
				"Ground Object: %s preori=%d ori=%d%s",
				getIdAndImpostorId(groundObject, groundObject.getRenderable()),
				HDUtils.getModelPreOrientation(groundObject.getConfig()),
				HDUtils.getModelOrientation(groundObject.getConfig()),
				getModelInfo(groundObject.getRenderable())
			));
			lines.add("Ground Type: " + ObjectType.fromConfig(groundObject.getConfig()));
		}

		WallObject wallObject = tile.getWallObject();
		if (wallObject != null) {
			if (wallObject.getRenderable1() != null) {
				lines.add(String.format(
					"Wall Object 1: %s bakedOri=%d ori=%d wallori=%d%s",
					getIdAndImpostorId(wallObject, wallObject.getRenderable1()),
					HDUtils.getModelPreOrientation(wallObject.getConfig()),
					HDUtils.getModelOrientation(wallObject.getConfig()),
					wallObject.getOrientationA(),
					getModelInfo(wallObject.getRenderable1())
				));
			}
			if (wallObject.getRenderable2() != null) {
				lines.add(String.format(
					"Wall Object 2: %s bakedOri=%d ori=%d wallori=%d%s",
					getIdAndImpostorId(wallObject, wallObject.getRenderable2()),
					HDUtils.getModelPreOrientation(wallObject.getConfig()),
					HDUtils.getModelOrientation(wallObject.getConfig()),
					wallObject.getOrientationB(),
					getModelInfo(wallObject.getRenderable2())
				));
			}
			lines.add("Wall Type: " + ObjectType.fromConfig(wallObject.getConfig()));
		}

		GameObject[] gameObjects = tile.getGameObjects();
		for (GameObject gameObject : gameObjects) {
			if (gameObject == null)
				continue;
			int height = -1;
			int animationId = -1;
			int faceCount = 0;
			String id = "";
			var renderable = gameObject.getRenderable();
			if (renderable != null) {
				Model model = renderable instanceof Model ? (Model) renderable : renderable.getModel();
				if (model != null)
					faceCount = model.getFaceCount();

				if (renderable instanceof NPC)
					continue;

				height = renderable.getModelHeight();

				if (renderable instanceof Player) {
					id = "name=" + ((Player) renderable).getName();
				} else {
					id = getIdAndImpostorId(gameObject, renderable);
					if (renderable instanceof DynamicObject) {
						var anim = ((DynamicObject) renderable).getAnimation();
						if (anim != null)
							animationId = anim.getId();
					}
				}
				id += " ";
			}

			lines.add(String.format(
				"%s: %spreori=%d ori=%d objori=%d height=%d anim=%d faces=%d%s",
				ModelHash.getTypeName(ModelHash.getType(gameObject.getHash())),
				id,
				HDUtils.getModelPreOrientation(gameObject.getConfig()),
				HDUtils.getModelOrientation(gameObject.getConfig()),
				gameObject.getModelOrientation(),
				height,
				animationId,
				faceCount,
				getModelInfo(renderable)
			));
			lines.add("Object Type: " + ObjectType.fromConfig(gameObject.getConfig()));
		}

		for (var npc : client.getTopLevelWorldView().npcs()) {
			var lp = npc.getLocalLocation();
			int size = npc.getComposition().getSize() / 2;
			int x = lp.getSceneX();
			int y = lp.getSceneY();
			if (x - size <= tileX && tileX <= x + size && y - size <= tileY && tileY <= y + size) {
				var name = gamevalManager.getNpcName(npc.getId());
				hoveredGamevals.add(name);
				lines.add(String.format(
					"NPC: %s (%d) name=%s ori=[%d,%d] anim=%d impostor=?%s",
					name,
					npc.getId(),
					npc.getName(),
					npc.getOrientation(),
					npc.getCurrentOrientation(),
					npc.getAnimation(),
					getModelInfo(npc)
				));
			}
		}

		for (GraphicsObject graphicsObject : client.getGraphicsObjects()) {
			var lp = graphicsObject.getLocation();
			if (lp.getSceneX() == tileX && lp.getSceneY() == tileY) {
				var name = gamevalManager.getSpotanimName(graphicsObject.getId());
				hoveredGamevals.add(name);
				lines.add(String.format(
					"Graphics Object: %s (%d)%s",
					name,
					graphicsObject.getId(),
					getModelInfo(graphicsObject)
				));
			}
		}

		if (tile.getBridge() != null)
			polyColor = Color.MAGENTA;
		g.setColor(polyColor);
		g.drawPolygon(poly);

		if (lines.isEmpty())
			return null;

		for (int i = 0; i < lines.size(); i++) {
			var moreLines = lines.get(i).split("\\n");
			if (moreLines.length > 1) {
				//noinspection SuspiciousListRemoveInLoop
				lines.remove(i);
				lines.addAll(i, List.of(moreLines));
			}
		}

		int padding = 4;
		int xPadding = padding * 2;
		FontMetrics fm = g.getFontMetrics();
		int lineHeight = fm.getHeight();
		int totalHeight = lineHeight * lines.size() + padding * 3;
		int space = fm.stringWidth(": ");
		int indent = fm.stringWidth("{ ");

		int leftWidth = 0;
		int rightWidth = 0;

		Function<String, Pair<String, String>> splitter = line ->
		{
			int i = line.indexOf(":");
			String left = line;
			String right = "";
			if (left.startsWith("\t"))
			{
				right = left;
				left = "";
			} else if (i != -1)
			{
				left = line.substring(0, i);
				right = line.substring(i + 1);
			}

			return Pair.of(left, right);
		};

		Font f = g.getFont();
		for (String line : lines)
		{
			Pair<String, String> pair = splitter.apply(line);
			if (pair.getRight().isEmpty())
			{
				int halfWidth = fm.stringWidth(Text.removeTags(pair.getLeft())) / 2;
				leftWidth = max(leftWidth, halfWidth);
				rightWidth = max(rightWidth, halfWidth);
			}
			else
			{
				leftWidth = max(leftWidth, fm.stringWidth(Text.removeTags(pair.getLeft())));
				var rfm = fm;
				if (pair.getRight().contains("<tt>"))
					rfm = g.getFontMetrics(MONOSPACE_FONT);
				rightWidth = max(rightWidth, rfm.stringWidth(Text.removeTags(pair.getRight())));
			}
		}

		Rectangle2D polyBounds = poly.getBounds2D();
		float centerX = (float) polyBounds.getCenterX();
		float centerY = (float) (polyBounds.getCenterY() - polyBounds.getHeight() / 2.f);

		var bounds = g.getClipBounds();

		int totalWidth = leftWidth + rightWidth + space + xPadding * 2;
		Rectangle rect = new Rectangle(
			(int) clamp(centerX - totalWidth / 2.f, bounds.x, bounds.x + bounds.width - totalWidth),
			(int) clamp(centerY - totalHeight - padding, bounds.y + 16, bounds.y + bounds.height - totalHeight),
			totalWidth,
			totalHeight
		);
		if (dodgeRect != null && dodgeRect.intersects(rect))
		{
			// Avoid overlapping with other tile info
			rect.y = dodgeRect.y - rect.height - padding;
		}

		g.setColor(BACKDROP_COLOR);
		g.fillRect(rect.x, rect.y, rect.width, rect.height);

		g.setColor(Color.WHITE);

		int offsetY = 0;
		for (String line : lines)
		{
			boolean dropShadow = true;

			Pair<String, String> pair = splitter.apply(line);
			offsetY += lineHeight;
			float x, y;
			if (pair.getRight().isEmpty())
			{
				// centered
				x = rect.x + rect.width / 2.f - fm.stringWidth(pair.getLeft()) / 2.f;
				y = rect.y + padding + offsetY;
			}
			else
			{
				boolean indented = pair.getRight().startsWith("\t");
				if (pair.getRight().contains("<tt>")) {
					g.setFont(MONOSPACE_FONT);
					dropShadow = false;
				}

				// left & right
				x = rect.x + xPadding + leftWidth - fm.stringWidth(pair.getLeft()) + (indented ? indent : 0);
				y = rect.y + padding + offsetY;
			}

			drawString(g, line, (int) x, (int) y, dropShadow);

			g.setFont(f);
		}

		return rect;
	}

	private String getIdAndImpostorId(TileObject object, @Nullable Renderable renderable) {
		int id = object.getId();
		int impostorId = getIdOrImpostorId(object, renderable);
		String name = gamevalManager.getObjectName(id);
		if (id == impostorId) {
			hoveredGamevals.add(name);
			return String.format("%s (%d)", name, id);
		}

		String impostorName = gamevalManager.getObjectName(impostorId);
		hoveredGamevals.add(impostorName);
		return String.format("%s (%d) -> %s (%d)", name, id, impostorName, impostorId);
	}

	private int getIdOrImpostorId(TileObject object, @Nullable Renderable renderable) {
		return ModelHash.getUuidId(ModelHash.generateUuid(client, object.getHash(), renderable));
	}

	private String getModelInfo(Renderable renderable) {
		if (renderable == null)
			return " null renderable";

		Model model = renderable instanceof Model ? (Model) renderable : renderable.getModel();
		if (model == null)
			return " null model";

		switch (mode) {
			case MODE_TILE_INFO:
				return
					"  " + (
						renderable instanceof Model ? "<col=#00ff00>static</col>" :
						(renderable instanceof DynamicObject || renderable instanceof Actor) ?
							"<col=#ff0000>dynamic</col>" : "<col=#ffff00>maybe dynamic</col>"
					) +
					"  scenebuf=" + (
						model.getSceneId() == SceneUploader.EXCLUDED_FROM_SCENE_BUFFER ? "excluded" :
							(model.getSceneId() & SceneUploader.SCENE_ID_MASK) == currentSceneContext.id ?
								model.getBufferOffset() : "dynamic"
					);
			case MODE_MODEL_INFO:
				int[] faceColors = model.getFaceColors1();
				byte[] faceTransparencies = model.getFaceTransparencies();
				int[] faceAhsl = new int[model.getFaceCount()];
				for (int i = 0; i < faceAhsl.length; i++)
					faceAhsl[i] = (faceTransparencies == null ? 0xFF : 0xFF - (faceTransparencies[i] & 0xFF)) << 16 | faceColors[i];
				var colors = Arrays.stream(faceAhsl)
					.distinct()
					.sorted()
					.mapToObj(ahsl -> {
						var hsl = ColorUtils.unpackRawHsl(ahsl);
						var alpha = ahsl >> 16;
						return String.format(
							"<col=%s>%5d [%3d %2d %1d %3d]</col>",
							String.format("#%08x", ColorUtils.packSrgb(ColorUtils.packedHslToSrgb(ahsl)) << 8 | alpha),
							ahsl & 0xFFFF, alpha, hsl[0], hsl[1], hsl[2]
						);
					})
					.toArray(String[]::new);

				int columns = clamp(round(sqrt(colors.length / 5f)), 3, 8);
				int rows = ceil(colors.length / (float) columns);

				StringBuilder str = new StringBuilder("\nFace colors: ").append(colors.length);
				for (int i = 0; i < rows; i++) {
					str.append("\n\t<tt>");
					for (int j = 0; j < columns; j++) {
						int idx = i * columns + j;
						if (idx < colors.length)
							str.append(colors[idx]);
					}
				}

				if (model.getFaceTextures() != null) {
					var textureIds = new HashSet<Integer>();
					for (int textureId : model.getFaceTextures())
						textureIds.add(textureId);
					textureIds.remove(-1);
					if (!textureIds.isEmpty()) {
						str.append("\nTexture IDs: [ ");
						String prefix = "";
						for (int id : textureIds) {
							str.append(prefix).append(id);
							prefix = ", ";
						}
						str.append("]");
					}
				}

				return str.toString();
		}

		return "";
	}

	public Polygon getCanvasTilePoly(@Nonnull Client client, Scene scene, Tile tile) {
		if (tile == null)
			return null;
		var l = tile.getSceneLocation();
		return getCanvasTilePoly(client, scene, l.getX(), l.getY(), tile.getPlane());
	}

	public Polygon getCanvasTilePoly(@Nonnull Client client, Scene scene, int... sceneXYplane) {
		final int wx = sceneXYplane[0] * LOCAL_TILE_SIZE;
		final int sy = sceneXYplane[1] * LOCAL_TILE_SIZE;
		final int ex = (sceneXYplane[0] + 1) * LOCAL_TILE_SIZE;
		final int ny = (sceneXYplane[1] + 1) * LOCAL_TILE_SIZE;

		final int sw = getHeight(scene, wx, sy, sceneXYplane[2]);
		final int se = getHeight(scene, ex, sy, sceneXYplane[2]);
		final int ne = getHeight(scene, ex, ny, sceneXYplane[2]);
		final int nw = getHeight(scene, wx, ny, sceneXYplane[2]);

		float[] p1 = localToCanvas(client, wx, sy, sw);
		float[] p2 = localToCanvas(client, ex, sy, se);
		float[] p3 = localToCanvas(client, ex, ny, ne);
		float[] p4 = localToCanvas(client, wx, ny, nw);
		if (p1 == null || p2 == null || p3 == null || p4 == null)
			return null;

		Polygon poly = new Polygon();
		poly.addPoint((int) p1[0], (int) p1[1]);
		poly.addPoint((int) p2[0], (int) p2[1]);
		poly.addPoint((int) p3[0], (int) p3[1]);
		poly.addPoint((int) p4[0], (int) p4[1]);

		return poly;
	}

	private static int getHeight(Scene scene, int localX, int localY, int plane) {
		int sceneExX = clamp((localX >> LOCAL_COORD_BITS) + SCENE_OFFSET, 0, EXTENDED_SCENE_SIZE - 1);
		int sceneExY = clamp((localY >> LOCAL_COORD_BITS) + SCENE_OFFSET, 0, EXTENDED_SCENE_SIZE - 1);

		int[][][] tileHeights = scene.getTileHeights();
		int x = localX & (LOCAL_TILE_SIZE - 1);
		int y = localY & (LOCAL_TILE_SIZE - 1);
		int var8 = x * tileHeights[plane][sceneExX + 1][sceneExY] +
				   (LOCAL_TILE_SIZE - x) * tileHeights[plane][sceneExX][sceneExY] >> LOCAL_COORD_BITS;
		int var9 = x * tileHeights[plane][sceneExX + 1][sceneExY + 1] +
				   (LOCAL_TILE_SIZE - x) * tileHeights[plane][sceneExX][sceneExY + 1] >> LOCAL_COORD_BITS;
		return y * var9 + (LOCAL_TILE_SIZE - y) * var8 >> 7;
	}

	private float[] localToCanvas(@Nonnull Client client, int x, int y, int z) {
		// Using floats to support coordinates much larger than normal local coordinates
		x -= client.getCameraX();
		y -= client.getCameraY();
		z -= client.getCameraZ();
		int cameraPitch = client.getCameraPitch();
		int cameraYaw = client.getCameraYaw();
		float pitchSin = sin(cameraPitch * JAU_TO_RAD);
		float pitchCos = cos(cameraPitch * JAU_TO_RAD);
		float yawSin = sin(cameraYaw * JAU_TO_RAD);
		float yawCos = cos(cameraYaw * JAU_TO_RAD);
		float x1 = x * yawCos + y * yawSin;
		float y1 = y * yawCos - x * yawSin;
		float y2 = z * pitchCos - y1 * pitchSin;
		float z1 = y1 * pitchCos + z * pitchSin;
		if (z1 >= 1) {
			float scale = client.getScale();
			float screenX = x1 * scale;
			float screenY = y2 * scale;
			if (plugin.orthographicProjection) {
				screenX *= ORTHOGRAPHIC_ZOOM;
				screenY *= ORTHOGRAPHIC_ZOOM;
			} else {
				screenX /= z1;
				screenY /= z1;
			}

			screenX += client.getViewportWidth() / 2.f;
			screenY += client.getViewportHeight() / 2.f;

			return new float[] {
				(screenX + client.getViewportXOffset()),
				(screenY + client.getViewportYOffset()),
				min(Integer.MAX_VALUE, z1)
			};
		}

		return null;
	}

	private static String hslString(Tile tile) {
		int[] hsl = new int[3];
		int rawHsl = HDUtils.getSouthWesternMostTileColor(hsl, tile);
		if (rawHsl == HIDDEN_HSL)
			return "HIDDEN";
		return rawHsl + " " + Arrays.toString(hsl);
	}

	private void drawAllIds(Graphics2D g, SceneContext ctx) {
		g.setFont(FontManager.getRunescapeSmallFont());
		g.setColor(new Color(255, 255, 255, 127));

		Tile[][][] tiles = ctx.scene.getExtendedTiles();
		int plane = ctrlHeld ? MAX_Z - 1 : client.getPlane();
		for (int z = plane; z >= 0; z--) {
			for (int x = 0; x < EXTENDED_SCENE_SIZE; x++) {
				for (int y = 0; y < EXTENDED_SCENE_SIZE; y++) {
					Tile tile = tiles[z][x][y];
					if (tile == null)
						continue;

					var lp = tile.getLocalLocation();
					int lines = 0;
					for (int isBridge = 1; isBridge >= 0; isBridge--) {
						var t = tile;
						if (isBridge == 1) {
							t = tile.getBridge();
							if (t == null)
								continue;
						}

						GroundObject groundObject = t.getGroundObject();
						if (groundObject != null)
							drawTileObjectInfo(g, lp, groundObject, groundObject.getRenderable(), lines++);

						WallObject wallObject = t.getWallObject();
						if (wallObject != null)
							drawTileObjectInfo(g, lp, wallObject, wallObject.getRenderable1(), lines++);

						for (GameObject gameObject : t.getGameObjects())
							if (gameObject != null)
								drawTileObjectInfo(g, lp, gameObject, gameObject.getRenderable(), lines++);
					}
				}
			}
		}
	}

	private void drawTileObjectInfo(Graphics2D g, LocalPoint lp, TileObject object, Renderable renderable, int line) {
		int type = ModelHash.getType(object.getHash());
		String str;
		if (zoom > 1.2f) {
			str = ModelHash.getTypeName(type) + ": " + getIdAndImpostorId(object, renderable);
		} else {
			str = ModelHash.getTypeNameShort(type) + ": " + getIdOrImpostorId(object, renderable);
		}
		var p = localToCanvas(client, lp.getX(), lp.getY(),
			Perspective.getTileHeight(client, lp, object.getPlane())
		);
		if (p == null)
			return;

		var fm = g.getFontMetrics();
		int w = fm.stringWidth(str);

		drawString(g, str, (int) (p[0] - w / 2.f), (int) (p[1] + line * fm.getHeight()), true);
	}

	private void drawString(Graphics2D g2d, String str, int x, int y, boolean dropShadow) {
		Color origColor = g2d.getColor();

		setAntiAliasing(g2d, false);

		String stripped = Text.removeTags(str);
		if (dropShadow) {
			g2d.setColor(Color.BLACK);
			g2d.drawString(stripped, x + 1, y + 1);
			g2d.setColor(origColor);
		}

		if (!str.contains("<col=")) {
			g2d.drawString(stripped, x, y);
			return;
		}

		var fm = g2d.getFontMetrics();
		final Pattern pattern = Pattern.compile("<col=#?([a-fA-F0-9]{3,8})>(.*?)</col>");
		var m = pattern.matcher(str);
		int end = 0;
		while (m.find()) {
			if (end < m.start()) {
				var s = Text.removeTags(str.substring(end, m.start()));
				g2d.setColor(origColor);
				g2d.drawString(s, x, y);
				x += fm.stringWidth(s);
			}
			end = m.end();

			var hex = m.group(1);
			int i = (int) Long.parseLong(hex, 16);
			int r, g, b, a = 0xFF;
			if (hex.length() == 3) {
				r = (i >>> 8) * 2;
				g = (i >>> 4 & 0xF) * 2;
				b = (i & 0xF) * 2;
			} else if (hex.length() == 6) {
				r = i >>> 16;
				g = i >>> 8 & 0xFF;
				b = i & 0xFF;
			} else if (hex.length() == 8) {
				r = i >>> 24;
				g = i >>> 16 & 0xFF;
				b = i >>> 8 & 0xFF;
				a = i & 0xFF;
			} else {
				g2d.drawString(m.group(0), x, y);
				x += fm.stringWidth(m.group(0));
				continue;
			}

			var withBrackets = m.group(2);
			var withoutBrackets = withBrackets.replaceAll("[\\[\\]]", " ");
			var onlyBrackets = withBrackets.replaceAll("[^\\[\\]]", " ");

			var c = new Color(r, g, b, a);
			g2d.setColor(c);
			int w = fm.stringWidth(withoutBrackets);
			int h = fm.getHeight();
			g2d.fillRect(x - 2, y - fm.getAscent() + fm.getLeading() - 2, w + 4, h + 2);
			g2d.setColor(getContrastColor(c));
			g2d.drawString(withoutBrackets, x, y);
			g2d.drawString(onlyBrackets, x, y - 1);

			x += fm.stringWidth(withoutBrackets);
		}

		g2d.setColor(origColor);
		if (end < str.length())
			g2d.drawString(str.substring(end), x, y);
	}

	private Color getContrastColor(Color color) {
		double y = (299. * color.getRed() + 587 * color.getGreen() + 114 * color.getBlue()) / 1000;
		return y >= 128 ? Color.black : Color.white;
	}

	/**
	 * Draw line given local scene coordinates
	 */
	private void drawLine(Graphics2D g, int x1, int y1, int z1, int x2, int y2, int z2) {
		// Using floats to support coordinates much larger than normal local coordinates
		float yawSin = sin(plugin.cameraOrientation[0]);
		float yawCos = cos(plugin.cameraOrientation[0]);
		float pitchSin = sin(plugin.cameraOrientation[1]);
		float pitchCos = cos(plugin.cameraOrientation[1]);

		x1 -= client.getCameraX();
		y1 -= client.getCameraY();
		z1 -= client.getCameraZ();
		x2 -= client.getCameraX();
		y2 -= client.getCameraY();
		z2 -= client.getCameraZ();

		float ax = x1 * yawCos + y1 * yawSin;
		float aUnpitchedZ = y1 * yawCos - x1 * yawSin;
		float ay = z1 * pitchCos - aUnpitchedZ * pitchSin;
		float az = aUnpitchedZ * pitchCos + z1 * pitchSin;

		float bx = x2 * yawCos + y2 * yawSin;
		float bUnpitchedZ = y2 * yawCos - x2 * yawSin;
		float by = z2 * pitchCos - bUnpitchedZ * pitchSin;
		float bz = bUnpitchedZ * pitchCos + z2 * pitchSin;

		if (!plugin.orthographicProjection) {
			// Project points which lie behind the camera onto the
			// near plane, so lines can still be drawn accurately

			// Both behind the near plane
			if (az < 1 && bz < 1)
				return;

			float vx = bx - ax;
			float vy = by - ay;
			float vz = bz - az;

			if (az < 1) {
				// A is behind the near plane
				// az + (bz - az) * t = 1
				// t = (1 - az) / (bz - az)
				double t = (1.f - az) / vz;
				ax += (float) (vx * t);
				ay += (float) (vy * t);
				az = 1;
			} else if (bz < 1) {
				// B is behind the near plane
				double t = (1.f - bz) / vz;
				bx += (float) (vx * t);
				by += (float) (vy * t);
				bz = 1;
			}
		}

		if (plugin.orthographicProjection) {
			ax *= ORTHOGRAPHIC_ZOOM;
			ay *= ORTHOGRAPHIC_ZOOM;
			bx *= ORTHOGRAPHIC_ZOOM;
			by *= ORTHOGRAPHIC_ZOOM;
		} else {
			ax /= az;
			ay /= az;
			bx /= bz;
			by /= bz;
		}

		int scale = client.getScale();
		ax *= scale;
		ay *= scale;
		bx *= scale;
		by *= scale;

		int w = client.getViewportWidth();
		int h = client.getViewportHeight();

		float offsetX = client.getViewportXOffset() + w / 2.f;
		float offsetY = client.getViewportYOffset() + h / 2.f;
		ax += offsetX;
		ay += offsetY;
		bx += offsetX;
		by += offsetY;

		float vx = bx - ax;
		float vy = by - ay;

		// a + v * t = edge
		// t = (edge - a) / v
		if (ax < 0) {
			ay += -ax / vx * vy;
			ax = 0;
		} else if (ax > w) {
			ay += (w - ax) / vx * vy;
			ax = w;
		}
		if (ay < 0) {
			ax += -ay / vy * vx;
			ay = 0;
		} else if (ay > h) {
			ax += (h - ay) / vy * vx;
			ay = h;
		}

		if (bx < 0) {
			by += -bx / vx * vy;
			bx = 0;
		} else if (bx > w) {
			by += (w - bx) / vx * vy;
			bx = w;
		}
		if (by < 0) {
			bx += -by / vy * vx;
			by = 0;
		} else if (by > h) {
			bx += (h - by) / vy * vx;
			by = h;
		}

		int fromX = round(ax);
		int fromY = round(ay);
		int toX = round(bx);
		int toY = round(by);

		if (fromX == toX && fromY == toY)
			return;

		g.drawLine(fromX, fromY, toX, toY);
	}

	private void setAntiAliasing(Graphics2D g, boolean state) {
		g.setRenderingHint(
			RenderingHints.KEY_TEXT_ANTIALIASING,
			state ? RenderingHints.VALUE_TEXT_ANTIALIAS_ON : RenderingHints.VALUE_TEXT_ANTIALIAS_OFF
		);
	}

	private AABB toLocalAabb(SceneContext ctx, AABB aabb) {
		return toLocalAabb(ctx, aabb, 1);
	}

	private AABB toLocalAabb(SceneContext ctx, AABB aabb, float scale) {
		int x1 = (aabb.minX - sceneBase[0]) * LOCAL_TILE_SIZE;
		int y1 = (aabb.minY - sceneBase[1]) * LOCAL_TILE_SIZE;
		int x2 = (aabb.maxX + 1 - sceneBase[0]) * LOCAL_TILE_SIZE;
		int y2 = (aabb.maxY + 1 - sceneBase[1]) * LOCAL_TILE_SIZE;

		int minZ = 0, maxZ = MAX_Z;
		if (aabb.hasZ()) {
			minZ = clamp(aabb.minZ, 0, MAX_Z);
			maxZ = clamp(aabb.maxZ, 0, MAX_Z) + 1;
		}
		int z1 = Integer.MAX_VALUE;
		int z2 = Integer.MIN_VALUE;

		for (int i = minZ; i < maxZ; i++) {
			int sw = getHeight(ctx.scene, x1, y1, i);
			int nw = getHeight(ctx.scene, x1, y2, i);
			int ne = getHeight(ctx.scene, x2, y2, i);
			int se = getHeight(ctx.scene, x2, y1, i);
			if (sw != -1) {
				z1 = min(z1, sw);
				z2 = max(z2, sw);
			}
			if (nw != -1) {
				z1 = min(z1, nw);
				z2 = max(z2, nw);
			}
			if (ne != -1) {
				z1 = min(z1, ne);
				z2 = max(z2, ne);
			}
			if (se != -1) {
				z1 = min(z1, se);
				z2 = max(z2, se);
			}
		}

		if (scale == 1)
			return new AABB(x1, y1, z1, x2, y2, z2);

		float cx = (x1 + x2) / 2.f;
		float cy = (y1 + y2) / 2.f;
		float cz = (z1 + z2) / 2.f;
		int sx = (int) ((x2 - x1) / 2.f);
		int sy = (int) ((y2 - y1) / 2.f);
		int sz = (int) ((z2 - z1) / 2.f);

		return new AABB(
			round(cx - sx * scale),
			round(cy - sy * scale),
			round(cz - sz * scale),
			round(cx + sx * scale),
			round(cy + sy * scale),
			round(cz + sz * scale)
		);
	}

	private AABB cropAabb(SceneContext ctx, AABB aabb) {
		if (aabb.isPoint()) {
			int sceneExX = aabb.minX - (sceneBase[0] - SCENE_OFFSET);
			int sceneExY = aabb.minY - (sceneBase[1] - SCENE_OFFSET);
			if (sceneExX >= 0 && sceneExY >= 0 && sceneExX < EXTENDED_SCENE_SIZE && sceneExY < EXTENDED_SCENE_SIZE) {
				int minZ = MAX_Z - 1;
				int maxZ = 0;
				int filled = ctx.filledTiles[sceneExX][sceneExY];
				for (int plane = 0; plane < MAX_Z; plane++) {
					if ((filled & (1 << plane)) != 0) {
						minZ = min(minZ, plane);
						maxZ = max(maxZ, plane);
					}
				}
				return new AABB(aabb.minX, aabb.minY, minZ, aabb.minX, aabb.minY, maxZ);
			}
		}

		return aabb;
	}

	private void drawLocalAabb(Graphics2D g, AABB aabb) {
		setAntiAliasing(g, true);

		// Draw bottom rect
		drawLine(g, aabb.minX, aabb.minY, aabb.minZ, aabb.minX, aabb.maxY, aabb.minZ);
		drawLine(g, aabb.minX, aabb.maxY, aabb.minZ, aabb.maxX, aabb.maxY, aabb.minZ);
		drawLine(g, aabb.maxX, aabb.maxY, aabb.minZ, aabb.maxX, aabb.minY, aabb.minZ);
		drawLine(g, aabb.maxX, aabb.minY, aabb.minZ, aabb.minX, aabb.minY, aabb.minZ);

		if (aabb.minZ != aabb.maxZ) {
			// Draw top rect
			drawLine(g, aabb.minX, aabb.minY, aabb.maxZ, aabb.minX, aabb.maxY, aabb.maxZ);
			drawLine(g, aabb.minX, aabb.maxY, aabb.maxZ, aabb.maxX, aabb.maxY, aabb.maxZ);
			drawLine(g, aabb.maxX, aabb.maxY, aabb.maxZ, aabb.maxX, aabb.minY, aabb.maxZ);
			drawLine(g, aabb.maxX, aabb.minY, aabb.maxZ, aabb.minX, aabb.minY, aabb.maxZ);

			// Connect corners
			drawLine(g, aabb.minX, aabb.minY, aabb.minZ, aabb.minX, aabb.minY, aabb.maxZ);
			drawLine(g, aabb.minX, aabb.maxY, aabb.minZ, aabb.minX, aabb.maxY, aabb.maxZ);
			drawLine(g, aabb.maxX, aabb.maxY, aabb.minZ, aabb.maxX, aabb.maxY, aabb.maxZ);
			drawLine(g, aabb.maxX, aabb.minY, aabb.minZ, aabb.maxX, aabb.minY, aabb.maxZ);
		}
	}

	private float[] getAabbCanvasCenter(AABB aabb) {
		float[] c = aabb.getCenter();
		return localToCanvas(client, (int) c[0], (int) c[1], (int) c[2]);
	}

	private void drawLocalAabbLabel(Graphics2D g, AABB aabb, String text, boolean backdrop) {
		var p = getAabbCanvasCenter(aabb);
		if (p == null)
			return;

		String[] lines = text.split("\\n");

		Color c = g.getColor();

		FontMetrics fm = g.getFontMetrics();
		int lineHeight = fm.getHeight();
		int totalHeight = lineHeight * lines.length;

		if (backdrop) {
			int totalWidth = 0;
			for (String line : lines)
				totalWidth = max(totalWidth, fm.stringWidth(line));

			g.setColor(BACKDROP_COLOR);
			int pad = 4;
			g.fillRect(
				(int) (p[0] - totalWidth / 2.f - pad),
				(int) (p[1] - totalHeight / 2.f - lineHeight / 2.f - pad),
				totalWidth + pad * 2,
				totalHeight + pad * 2
			);
		}

		for (int i = 0; i < lines.length; i++) {
			String line = lines[i];
			int width = fm.stringWidth(line);
			int px = (int) (p[0] - width / 2.f);
			int py = (int) (p[1] - totalHeight / 2.f + lineHeight * i + lineHeight / 2.f);
			g.setColor(Color.BLACK);
			g.drawString(line, px + 1, py + 1);
			g.setColor(c);
			g.drawString(line, px, py);
		}
	}

	private void drawLoadingLines(Graphics2D g) {
		g.setColor(Color.BLUE);
		int min = 16 * LOCAL_TILE_SIZE;
		int max = (SCENE_SIZE - 16) * LOCAL_TILE_SIZE;
		var localAabb = new AABB(min, min, max, max, 0);
		drawLocalAabb(g, localAabb);
	}

	private void drawRegionBoxes(Graphics2D g, SceneContext ctx) {
		if (ctx.sceneBase == null)
			return;
		int regionSize = CHUNK_SIZE * 8;

		for (int x = 0; x < EXTENDED_SCENE_SIZE; x += regionSize) {
			for (int y = 0; y < EXTENDED_SCENE_SIZE; y += regionSize) {
				int regionX = (ctx.sceneBase[0] + x) / regionSize;
				int regionY = (ctx.sceneBase[1] + y) / regionSize;
				int regionId = regionX << 8 | regionY;
				int worldX = regionX * regionSize;
				int worldY = regionY * regionSize;
				var aabb = new AABB(
					worldX,
					worldY,
					worldX + regionSize - 1,
					worldY + regionSize - 1,
					ctx.sceneBase[2] + client.getPlane()
				);
				var localAabb = toLocalAabb(ctx, aabb, .996f);
				g.setColor(TRANSPARENT_YELLOW_50);
				drawLocalAabb(g, localAabb);
				g.setColor(TRANSPARENT_YELLOW_100);
				drawLocalAabbLabel(g, localAabb, "Region ID\n" + regionId, false);
			}
		}
	}

	private void copyToClipboard(String toCopy) {
		copyToClipboard(toCopy, null);
	}

	private void copyToClipboard(String toCopy, @Nullable String description) {
		Clipboard clipboard = Toolkit.getDefaultToolkit().getSystemClipboard();
		StringSelection string = new StringSelection(toCopy);
		clipboard.setContents(string, null);
		clientThread.invoke(() -> client.addChatMessage(
			ChatMessageType.GAMEMESSAGE,
			"117 HD",
			"<col=006600>[117 HD] " + (
				description == null ?
					"Copied to clipboard: " + toCopy :
					description
			),
			"117 HD"
		));
	}

	@Override
	public MouseEvent mouseClicked(MouseEvent e) {
		return e;
	}

	@Override
	public synchronized MouseEvent mousePressed(MouseEvent e) {
		var sceneContext = plugin.getSceneContext();
		if (sceneContext == null)
			return e;

		if (e.isAltDown()) {
			e.consume();

			if (SwingUtilities.isLeftMouseButton(e)) {
				if (!Arrays.equals(selectedAreaAabb, hoveredAreaAabb)) {
					if (TileInfoOverlay.this.hoveredAreaAabb[0] != -1)
						copyToClipboard(visibleAreas[TileInfoOverlay.this.hoveredAreaAabb[0]]
							.aabbs[TileInfoOverlay.this.hoveredAreaAabb[1]]
							.toArgs());

					copyTo(selectedAreaAabb, hoveredAreaAabb);
					return e;
				}

				if (aabbMarkingStage == 0) {
					// Marking first
					System.arraycopy(hoveredWorldPoint, 0, markedWorldPoints[0], 0, 3);
				} else {
					// Done marking
					selections.add(pendingSelection);

					if (selections.size() == 1) {
						copyToClipboard(pendingSelection.toArgs());
					} else {
						StringBuilder sb = new StringBuilder();
						for (int i = 0; i < selections.size(); i++) {
							if (i > 0)
								sb.append(",\n");
							sb.append(selections.get(i).toArgs());
						}
						copyToClipboard(sb.toString(), "Copied " + selections.size() + " AABBs to clipboard");
					}

					pendingSelection = null;
				}
				aabbMarkingStage = (aabbMarkingStage + 1) % 2;
			} else if (SwingUtilities.isRightMouseButton(e)) {
				// Reset selection
				aabbMarkingStage = 0;
				selections.clear();
				pendingSelection = null;
			}
		} else if (SwingUtilities.isRightMouseButton(e)) {
			if (!hoveredGamevals.isEmpty()) {
				if (copiedGamevalsHash != hoveredGamevalsHash) {
					copiedGamevalsHash = hoveredGamevalsHash;
					hoveredGamevalsIndex = 0;
				}
				copyToClipboard('"' + hoveredGamevals.get(hoveredGamevalsIndex) + '"');
				hoveredGamevalsIndex = (hoveredGamevalsIndex + 1) % hoveredGamevals.size();
			}
		}

		return e;
	}

	@Override
	public MouseEvent mouseReleased(MouseEvent e) {
		return e;
	}

	@Override
	public MouseEvent mouseEntered(MouseEvent e) {
		return e;
	}

	@Override
	public MouseEvent mouseExited(MouseEvent e) {
		return e;
	}

	@Override
	public MouseEvent mouseDragged(MouseEvent e) {
		return e;
	}

	@Override
	public MouseEvent mouseMoved(MouseEvent e) {
		return e;
	}

	@Override
	public MouseWheelEvent mouseWheelMoved(MouseWheelEvent e) {
		if (ctrlHeld) {
			e.consume();
			targetPlane = clamp(targetPlane + e.getWheelRotation(), 0, MAX_Z - 1);
		} else if (altHeld) {
			e.consume();
			selectionIncludeZ = !selectionIncludeZ;
		}

		return e;
	}
}

package rs117.hd.overlays;

import java.util.Arrays;

public class FrameTimings {
	public final long frameTimestamp;
	public final long[] timers;

	public FrameTimings(long frameTimestamp, long[] timers) {
		this.frameTimestamp = frameTimestamp;
		this.timers = Arrays.copyOf(timers, timers.length);
	}
}

package rs117.hd.overlays;

import java.awt.BasicStroke;
import java.awt.Color;
import java.awt.Dimension;
import java.awt.FontMetrics;
import java.awt.Graphics;
import java.awt.Graphics2D;
import java.awt.MouseInfo;
import java.awt.Stroke;
import java.awt.Toolkit;
import java.awt.datatransfer.Clipboard;
import java.awt.datatransfer.StringSelection;
import java.awt.event.KeyEvent;
import java.awt.event.MouseEvent;
import java.util.ArrayList;
import java.util.Arrays;
import javax.inject.Inject;
import javax.inject.Singleton;
import javax.swing.SwingUtilities;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.*;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.input.KeyListener;
import net.runelite.client.input.KeyManager;
import net.runelite.client.input.MouseListener;
import net.runelite.client.input.MouseManager;
import net.runelite.client.ui.FontManager;
import net.runelite.client.ui.overlay.Overlay;
import net.runelite.client.ui.overlay.OverlayLayer;
import net.runelite.client.ui.overlay.OverlayManager;
import net.runelite.client.ui.overlay.OverlayPosition;
import net.runelite.client.util.ColorUtil;
import org.apache.commons.lang3.NotImplementedException;
import rs117.hd.HdPlugin;
import rs117.hd.scene.lights.Alignment;
import rs117.hd.scene.lights.Light;
import rs117.hd.scene.lights.LightType;
import rs117.hd.utils.ColorUtils;
import rs117.hd.utils.Mat4;

import static rs117.hd.HdPlugin.NEAR_PLANE;
import static rs117.hd.utils.MathUtils.*;

@Slf4j
@Singleton
public class LightGizmoOverlay extends Overlay implements MouseListener, KeyListener {
	private static final Color ORANGE = Color.decode("#ff9f2c");

	@Inject
	private Client client;

	@Inject
	private ClientThread clientThread;

	@Inject
	private OverlayManager overlayManager;

	@Inject
	private MouseManager mouseManager;

	@Inject
	private KeyManager keyManager;

	@Inject
	private HdPlugin plugin;

	private boolean hideInvisibleLights;
	private boolean hideRadiusRings = true;
	private boolean hideAnimLights;
	private boolean hideLabels;
	private boolean hideInfo = true;
	private boolean toggleBlackColor;
	private boolean liveInfo;
	private boolean showDuplicationInfo;
	private boolean toggleOpacity = true;
	private boolean followMouse;

	private Action action = Action.SELECT;
	private final float[] rawMousePos = new float[2];
	private final float[] rawMousePosPrev = new float[2];
	private final float[] mouseDelta = new float[2];
	private final float[] cameraOrientation = new float[2];
	private Alignment originalLightAlignment = Alignment.CUSTOM;
	private final float[] originalLightPosition = new float[3];
	private final float[] originalLightOffset = new float[3];
	private final float[] currentLightOffset = new float[3];
	private int freezeMode = 0;
	private final boolean[] frozenAxes = { false, true, false }; // by default, restrict movement to the same height
	private final ArrayList<Light> selections = new ArrayList<>();
	private final ArrayList<Light> hovers = new ArrayList<>();
	private boolean isProbablyRotatingCamera;

	private static final int RELATIVE_TO_CAMERA = 0;
	private static final int RELATIVE_TO_ORIGIN = 1;
	private static final int RELATIVE_TO_POSITION = 2;

	enum Action {
		SELECT, GRAB, SCALE
	}

	public LightGizmoOverlay() {
		setLayer(OverlayLayer.ABOVE_SCENE);
		setPosition(OverlayPosition.DYNAMIC);
	}

	public void setActive(boolean activate) {
		if (activate) {
			overlayManager.add(this);
			mouseManager.registerMouseListener(this);
			keyManager.registerKeyListener(this);
		} else {
			overlayManager.remove(this);
			mouseManager.unregisterMouseListener(this);
			keyManager.unregisterKeyListener(this);
			action = Action.SELECT;
			selections.clear();
		}
	}

	@Override
	public Dimension render(Graphics2D g) {
		var sceneContext = plugin.getSceneContext();
		if (sceneContext == null)
			return null;

		// If the orientation changed, don't consider mouse movement
		boolean wasCameraReoriented = isProbablyRotatingCamera;
		for (int j = 0; j < 2; j++) {
			if (cameraOrientation[j] != plugin.cameraOrientation[j]) {
				wasCameraReoriented = true;
				break;
			}
		}
		copyTo(cameraOrientation, plugin.cameraOrientation);

		boolean isCtrlHeld = client.isKeyPressed(KeyCode.KC_CONTROL);
		boolean isShiftHeld = client.isKeyPressed(KeyCode.KC_SHIFT);
		boolean isAltHeld = client.isKeyPressed(KeyCode.KC_ALT);

		var rawMouse = MouseInfo.getPointerInfo().getLocation();
		rawMousePos[0] = (float) rawMouse.getX();
		rawMousePos[1] = (float) rawMouse.getY();
		if (wasCameraReoriented) {
			if (action == Action.GRAB) {
				assert !selections.isEmpty();
				// Rotation & moving the light with the mouse don't mix very well, so apply the offset and reset mouseDelta when rotating
				if (mouseDelta[0] != 0 || mouseDelta[1] != 0) {
					Arrays.fill(mouseDelta, 0);
					var selection = selections.get(0);
					System.arraycopy(selection.offset, 0, currentLightOffset, 0, 3);
				}
			}
		} else if (!isAltHeld) {
			float scalingFactor = isShiftHeld ? .1f : 1f;
			for (int j = 0; j < 2; j++)
				mouseDelta[j] += (rawMousePos[j] - rawMousePosPrev[j]) * scalingFactor;
		}
		copyTo(rawMousePosPrev, rawMousePos);

		var mousePoint = new java.awt.Point(round(rawMousePos[0]), round(rawMousePos[1]));
		SwingUtilities.convertPointFromScreen(mousePoint, client.getCanvas());
		int[] mousePos = { mousePoint.x, mousePoint.y };

		Point mousePosCanvas = client.getMouseCanvasPosition();
		if (mousePosCanvas != null && (mousePosCanvas.getX() == -1 || mousePosCanvas.getY() == -1))
			mousePosCanvas = null;

		g.setFont(FontManager.getRunescapeSmallFont());

		final int innerDotDiameter = 6;
		final int innerHandleRingDiameter = 19;
		final int outerHandleRingDiameter = 25;
		final int hoverDistanceMargin = 5;

		Stroke thickLine = new BasicStroke(2);
		Stroke thinLine = new BasicStroke(1);
		Stroke thinnerLine = new BasicStroke(.75f);
		Stroke thinDashedLine = new BasicStroke(
			1, BasicStroke.CAP_BUTT, BasicStroke.JOIN_BEVEL,
			0, new float[] { 3 }, 0
		);
		Stroke thinLongDashedLine = new BasicStroke(
			1, BasicStroke.CAP_BUTT, BasicStroke.JOIN_BEVEL,
			0, new float[] { 10 }, 0
		);
		Stroke thickDashedLine = new BasicStroke(
			1.5f, BasicStroke.CAP_BUTT, BasicStroke.JOIN_BEVEL,
			0, new float[] { 3 }, 0
		);

		float[] projectionMatrix = Mat4.identity();
		int viewportWidth = client.getViewportWidth();
		int viewportHeight = client.getViewportHeight();
		Mat4.mul(projectionMatrix, Mat4.translate(client.getViewportXOffset(), client.getViewportYOffset(), 0));
		Mat4.mul(projectionMatrix, Mat4.scale(viewportWidth, viewportHeight, 1));
		Mat4.mul(projectionMatrix, Mat4.translate(.5f, .5f, .5f));
		Mat4.mul(projectionMatrix, Mat4.scale(.5f, -.5f, .5f));
		// NDC clip space
		Mat4.mul(projectionMatrix, Mat4.scale(client.getScale(), client.getScale(), 1));
		Mat4.mul(projectionMatrix, Mat4.perspective(viewportWidth, viewportHeight, NEAR_PLANE));
		Mat4.mul(projectionMatrix, Mat4.rotateX(plugin.cameraOrientation[1]));
		Mat4.mul(projectionMatrix, Mat4.rotateY(plugin.cameraOrientation[0]));
		Mat4.mul(projectionMatrix, Mat4.translate(
			-plugin.cameraPosition[0],
			-plugin.cameraPosition[1],
			-plugin.cameraPosition[2]
		));

		float[] inverseProjection = null;
		try {
			inverseProjection = Mat4.inverse(projectionMatrix);
		} catch (IllegalArgumentException ex) {
			log.warn("Not invertible:\n{}", Mat4.format(projectionMatrix));
		}

		int numFrozenAxes = 0;
		if (freezeMode > 0)
			for (int i = 0; i < 3; i++)
				if (frozenAxes[i])
					numFrozenAxes++;

		hovers.clear();
		int counter = 0;
		final float[] lightToCamera = new float[3];
		var lights = sceneContext.lights;

		float[] point = new float[4];
		int selectedIndex = -1;
		for (int i = lights.size() - 1; i >= -1; i--) {
			// Draw the selected light last
			int lightIndex = i;
			if (i == -1) {
				lightIndex = selectedIndex;
				if (lightIndex == -1)
					continue;
			}

			Light l = lights.get(lightIndex);

			if (hideInvisibleLights && !l.def.visibleFromOtherPlanes &&
				(l.plane < client.getPlane() && l.belowFloor || l.plane > client.getPlane() && l.aboveFloor))
				continue;

			if (hideAnimLights && !l.def.animationIds.isEmpty() && !l.parentExists)
				continue;

			boolean isHovered = !hovers.isEmpty() && hovers.get(0) == l;
			boolean isSelected = selections.contains(l);

			// Skip the selected light until the end
			if (i != -1 && isSelected) {
				selectedIndex = i;
				continue;
			}

			if (isSelected && !wasCameraReoriented && inverseProjection != null) {
				if (action == Action.GRAB) {
					float[] oldLightPos = new float[4];
					float[] newLightPos = new float[4];

					float radians = l.orientation * JAU_TO_RAD;
					float sin = sin(radians);
					float cos = cos(radians);

					// Project the light's current position into screen space
					System.arraycopy(l.origin, 0, oldLightPos, 0, 3);
					float x = currentLightOffset[0];
					float z = currentLightOffset[2];
					oldLightPos[0] += -cos * x - sin * z;
					oldLightPos[1] += currentLightOffset[1];
					oldLightPos[2] += -cos * z + sin * x;
					oldLightPos[3] = 1;
					Mat4.projectVec(point, projectionMatrix, oldLightPos);

					if (followMouse) {
						// Move the light to the mouse position
						for (int j = 0; j < 2; j++)
							point[j] = mousePos[j];
					} else {
						// Shift the position with mouse movement
						for (int j = 0; j < 2; j++)
							point[j] += mouseDelta[j];
					}

					if (numFrozenAxes == 0) { // restrict to same depth plane
						// Project the screen position back into the new light position
						Mat4.projectVec(newLightPos, inverseProjection, point);
						if (point[3] <= 0)
							continue;
					} else {
						// p1 & v1 = ray from the camera in the hovered direction
						var p1 = plugin.cameraPosition;
						var v1 = new float[3];

						// Compute a vector from the camera to the target mouse position
						Mat4.projectVec(point, inverseProjection, point);
						for (int j = 0; j < 3; j++)
							v1[j] = point[j] - p1[j];

						if (numFrozenAxes == 1) {
							// restrict to basis plane
							// ax + by + cz = d
							// n = (a, b, c)
							float[] n = new float[3];
							for (int j = 0; j < 3; j++) {
								if (frozenAxes[j]) {
									n[j] = 1;
									break;
								}
							}

							if (freezeMode == RELATIVE_TO_ORIGIN) {
								copyTo(oldLightPos, l.origin);
								oldLightPos[3] = 1;
								Mat4.projectVec(point, projectionMatrix, oldLightPos);
							}

							float d = dot(n, oldLightPos);

							// dot(p1 + v1 * t, n) = d
							// dot(p1, n) + dot(v1 * t, n) = d
							// dot(p1, n) + dot(v1, n) * t = d
							// t = (d - dot(p1, n)) / dot(v1, n)
							float t = (d - dot(p1, n)) / dot(v1, n);

							for (int j = 0; j < 3; j++)
								newLightPos[j] = p1[j] + v1[j] * t;
						} else if (numFrozenAxes == 2) {
							// restrict to axis
							int axis = 0;
							for (int j = 0; j < 3; j++) {
								if (!frozenAxes[j]) {
									axis = j;
									break;
								}
							}

							// p2 & v2 = ray from the light's origin in the direction of the target axis
							var p2 = freezeMode == RELATIVE_TO_ORIGIN ? l.origin : originalLightPosition;
							var v2 = new float[3];
							v2[axis] = 1;

							// v3 is the direction perpendicular to both v1 and v2, which is the direction
							// for the shortest path between two points on the two rays
							var v3 = cross(v1, v2);

							try {
								// Solve the following set of linear equations to find t2; the distance
								// from p2 along v2 until the closest point between the two rays:
								// p1 + v1 * t1 + v3 * t3 = p2 + v2 * t2

								// Solve for t2:
								float t2 = -p1[0] * v1[1] * v3[2] + p1[0] * v1[2] * v3[1] + p1[1] * v1[0] * v3[2] - p1[1] * v1[2] * v3[0]
										   - p1[2] * v1[0] * v3[1] + p1[2] * v1[1] * v3[0] + p2[0] * v1[1] * v3[2] - p2[0] * v1[2] * v3[1]
										   - p2[1] * v1[0] * v3[2] + p2[1] * v1[2] * v3[0] + p2[2] * v1[0] * v3[1] - p2[2] * v1[1] * v3[0];
								t2 /= v1[0] * v2[1] * v3[2] - v1[0] * v2[2] * v3[1] - v1[1] * v2[0] * v3[2] + v1[1] * v2[2] * v3[0]
									  + v1[2] * v2[0] * v3[1] - v1[2] * v2[1] * v3[0];

								for (int j = 0; j < 3; j++)
									newLightPos[j] = p2[j] + v2[j] * t2;
							} catch (IllegalArgumentException ex) {
								log.debug("No solution:", ex);
							}
						}
					}

					int gridSize = isCtrlHeld ? 128 / (isShiftHeld ? 8 : 1) : 1;

					float[] relativePos = new float[3];
					for (int j = 0; j < 3; j++)
						relativePos[j] = newLightPos[j] - l.origin[j];

					x = relativePos[0];
					z = relativePos[2];
					relativePos[0] = -cos * x + sin * z;
					relativePos[2] = -cos * z - sin * x;

					for (int j = 0; j < 3; j++)
						l.offset[j] = round(relativePos[j] / gridSize) * gridSize;

					x = l.offset[0];
					z = l.offset[2];
					l.pos[0] = l.origin[0] + (int) (-cos * x - sin * z);
					l.pos[1] = l.origin[1] + l.offset[1];
					l.pos[2] = l.origin[2] + (int) (-cos * z + sin * x);
				}
			}

			copyTo(point, l.pos);
			point[3] = 1;

			subtract(lightToCamera, plugin.cameraPosition, point);
			float distanceFromCamera = length(lightToCamera);

			Mat4.projectVec(point, projectionMatrix, point);
			if (point[3] <= 0)
				continue;
			int x = round(point[0]);
			int y = round(point[1]);

			// Take perspective depth into account
			int currentDiameter = round(l.radius * 2 / distanceFromCamera * client.getScale());
			float definedDiameter = l.def.radius * 2 / distanceFromCamera * client.getScale();
			float fRange = l.def.range / 100f;
			int minDiameter = round(definedDiameter * (1 - fRange));
			int maxDiameter = round(definedDiameter * (1 + fRange));

			if (mousePosCanvas != null) {
				float d = length(mousePosCanvas.getX() - x, mousePosCanvas.getY() - y);
				if (d <= outerHandleRingDiameter / 2f + hoverDistanceMargin ||
					!hideRadiusRings && abs(d - currentDiameter / 2f) < hoverDistanceMargin * 2)
					hovers.add(l);
			}

			int mainOpacity = toggleOpacity ?
				(l.visible ? 255 : 100) :
				(l.visible ? 100 : 30);
			int rangeOpacity = 70;
			Color baseColor = toggleBlackColor ? Color.BLACK : Color.WHITE;
			Color radiusRingColor = alpha(baseColor, mainOpacity);
			Color rangeRingsColor = alpha(baseColor, rangeOpacity);
			Color handleRingsColor = radiusRingColor;
			Color textColor = Color.WHITE;
			Stroke handleRingsStroke = thinDashedLine;

			if (isSelected) {
				handleRingsColor = radiusRingColor = rangeRingsColor = ORANGE;
				handleRingsStroke = thickDashedLine;
			} else if (isHovered) {
				radiusRingColor = Color.YELLOW;
				handleRingsColor = Color.WHITE;
			} else {
				textColor = alpha(textColor, mainOpacity);
			}

			// Draw handle rings
			drawRing(g, x, y, innerHandleRingDiameter, handleRingsColor, handleRingsStroke);
			drawRing(g, x, y, outerHandleRingDiameter, handleRingsColor, handleRingsStroke);

			// Draw radius rings
			if (!hideRadiusRings) {
				drawRing(g, x, y, currentDiameter, radiusRingColor, thinnerLine);
				if (l.def.type == LightType.PULSE && abs(currentDiameter) > .001f) {
					drawRing(g, x, y, minDiameter, rangeRingsColor, thinLongDashedLine);
					drawRing(g, x, y, maxDiameter, rangeRingsColor, thinLongDashedLine);
				}
			}

			// Only the selected dot has a filled dot in the center
			if (isSelected) {
				fillOutlinedCircle(g, x, y, innerDotDiameter, ORANGE, handleRingsColor, thinLine);
			} else {
				drawCircleOutline(g, x, y, innerDotDiameter, handleRingsColor, thinLine);
			}

			g.setColor(textColor);
			if (!hideLabels) {
				String info = l.def.description;
				if (showDuplicationInfo) {
					int newlines = (counter++ % 5) + 1;
					info += "\n".repeat(newlines);
					info += counter + ": " + l.hash;
					info += "\n".repeat(5 - newlines);
				}
				if (!hideInfo) {
					info += String.format("\nradius: %.0f", liveInfo ? l.radius : l.def.radius);
					info += String.format("\nstrength: %.1f", liveInfo ? l.strength : l.def.strength);
					var color = ColorUtils.linearToSrgb(l.def.color);
					info += String.format("\ncolor: [%.0f, %.0f, %.0f]", color[0] * 255, color[1] * 255, color[2] * 255);
					// Technically negative Y is up, but invert this in the info shown
					info += String.format(
						"\norigin: [%.0f, %.0f%s, %.0f]",
						l.origin[0],
						-(l.origin[1] + l.def.height),
						l.def.height == 0 ? "" : " + " + l.def.height,
						l.origin[2]
					);
					info += String.format("\noffset: [%.0f, %.0f, %.0f]", l.offset[0], -l.offset[1], l.offset[2]);
					info += String.format("\norientation: %d", l.orientation);
				}
				drawAlignedString(g, info, x, y + 25, TextAlignment.CENTER_ON_COLONS);
			}
		}

		if (!selections.isEmpty()) {
			switch (action) {
				case GRAB:
					Light l = selections.get(0);
					var lightOrigin = freezeMode == RELATIVE_TO_ORIGIN ? l.origin : originalLightPosition;
					System.arraycopy(lightOrigin, 0, point, 0, 3);
					point[3] = 1;
					float[] origin = new float[4];
					Mat4.projectVec(origin, projectionMatrix, point);
					if (point[3] <= 0)
						break;

					if (numFrozenAxes > 0) {
						Color[] axisColors = {
							new Color(0xef738c),
							new Color(0x9fd853),
							new Color(0x75ace1),
						};
						g.setStroke(thickLine);

						float[] stepAlongAxis = new float[4];
						for (int i = 0; i < 3; i++) {
							if (!frozenAxes[i]) {
								int stepSize = 1000;
								point[i] += stepSize;
								Mat4.projectVec(stepAlongAxis, projectionMatrix, point);
								point[i] -= stepSize;

								g.setColor(axisColors[i]);
								drawLineSpan(g, origin, stepAlongAxis);
							}
						}
					}

					copyTo(point, l.pos);
					point[3] = 1;
					float[] pos = new float[4];
					Mat4.projectVec(pos, projectionMatrix, point);
					if (point[3] <= 0)
						break;

					g.setColor(Color.YELLOW);
					drawLineSegment(g, origin, pos);
					break;
				case SCALE:
					break;
			}
		}

		return null;
	}

	private void drawLineSegment(Graphics2D g, float[] a, float[] b) {
		g.drawLine(round(a[0]), round(a[1]), round(b[0]), round(b[1]));
	}

	private void drawLineSpan(Graphics2D g, float[] a, float[] b) {
		float[] v = subtract(b, a);
		if (v[0] == 0 && v[1] == 0)
			return;

		float[] p = new float[2];
		System.arraycopy(a, 0, p, 0, 2);

		var clipBounds = g.getClipBounds();
		float[][] axisBounds = {
			{ 0, clipBounds.width },
			{ 0, clipBounds.height }
		};

		final float INF = Float.POSITIVE_INFINITY;
		final float EPS = 1f;

		// First intersection with an edge within the screen bounds
		float t = INF;
		int intersectedEdge = -1;
		outer:
		for (int axis = 0; axis < 2; axis++) {
			if (v[axis] == 0)
				continue;
			for (int edge = 0; edge < 2; edge++) {
				float d = (axisBounds[axis][edge] - p[axis]) / v[axis];
				int oppositeAxis = (axis + 1) % 2;
				float[] bounds = axisBounds[oppositeAxis];
				float coord = p[oppositeAxis] + v[oppositeAxis] * d;
				if (bounds[0] - EPS < coord && coord < bounds[1] + EPS) {
					t = d;
					intersectedEdge = axis * 2 + edge;
					break outer;
				}
			}
		}
		if (t == INF)
			return;

		// Move the point to the selected edge
		for (int i = 0; i < 2; i++)
			p[i] += v[i] * t;

		t = INF;
		outer:
		for (int axis = 0; axis < 2; axis++) {
			if (v[axis] == 0)
				continue;
			for (int edge = 0; edge < 2; edge++) {
				// Skip the edge we've already intersected with
				if (axis * 2 + edge == intersectedEdge)
					continue;

				float d = (axisBounds[axis][edge] - p[axis]) / v[axis];
				int oppositeAxis = (axis + 1) % 2;
				float[] bounds = axisBounds[oppositeAxis];
				float coord = p[oppositeAxis] + v[oppositeAxis] * d;
				if (bounds[0] - EPS < coord && coord < bounds[1] + EPS) {
					t = d;
					break outer;
				}
			}
		}
		if (t == INF)
			return;

		int x1 = round(p[0]);
		int y1 = round(p[1]);
		int x2 = round(p[0] + v[0] * t);
		int y2 = round(p[1] + v[1] * t);
		g.drawLine(x1, y1, x2, y2);
	}

	private void fillCircle(Graphics2D g, int centerX, int centerY, int diameter, Color color) {
		int r = diameter / 2;
		g.setColor(color);
		g.fillOval(centerX - r, centerY - r, diameter, diameter);
	}

	private void drawRing(Graphics2D g, int centerX, int centerY, int diameter, Color strokeColor, Stroke stroke) {
		// Round down to an odd number
		diameter = ceil(diameter / 2.f) * 2 - 1;
		int r = ceil(diameter / 2.f);
		g.setColor(strokeColor);
		g.setStroke(stroke);
		g.drawOval(centerX - r, centerY - r, diameter, diameter);
	}

	private void fillOutlinedCircle(
		Graphics2D g, int centerX, int centerY, int diameter, Color fillColor, Color strokeColor, Stroke stroke
	) {
		fillCircle(g, centerX, centerY, diameter - 2, fillColor);
		drawCircleOutline(g, centerX, centerY, diameter, strokeColor, stroke);
	}

	private void drawCircleOutline(
		Graphics2D g, int centerX, int centerY, int diameter, Color strokeColor, Stroke stroke
	) {
		int r = ceil(diameter / 2.f);
		int s = diameter - 1;
		g.setColor(strokeColor);
		g.setStroke(stroke);
		g.drawRoundRect(centerX - r, centerY - r, s, s, s - 1, s - 1);
	}

	private enum TextAlignment {
		LEFT, RIGHT, CENTER, CENTER_ON_COLONS
	}

	private void drawCenteredString(Graphics g, String text, int centerX, int centerY, TextAlignment alignment) {
		drawCenteredString(g, text.split("\\n"), centerX, centerY, alignment);
	}

	private void drawCenteredString(Graphics g, String[] lines, int centerX, int centerY, TextAlignment alignment) {
		FontMetrics metrics = g.getFontMetrics();
		int yOffset = metrics.getAscent() - (lines.length * metrics.getHeight()) / 2;
		drawAlignedString(g, lines, centerX, centerY + yOffset, alignment);
	}

	private void drawAlignedString(Graphics g, String text, int centerX, int topY, TextAlignment alignment) {
		drawAlignedString(g, text.split("\\n"), centerX, topY, alignment);
	}

	private void drawAlignedString(Graphics g, String[] lines, int centerX, int topY, TextAlignment alignment) {
		var color = g.getColor();
		var shadow = alpha(Color.BLACK, color.getAlpha());
		FontMetrics metrics = g.getFontMetrics();
		int fontHeight = metrics.getHeight();
		int yOffset = 0;

		if (alignment == TextAlignment.CENTER_ON_COLONS) {
			int longestLeft = 0, longestRight = 0;
			for (String line : lines) {
				int dotIndex = line.indexOf(":");
				String left, right;
				if (dotIndex == -1) {
					left = line;
					right = "";
				} else {
					left = line.substring(0, dotIndex);
					right = line.substring(dotIndex + 1);
				}
				int leftLen = metrics.stringWidth(left);
				if (leftLen > longestLeft) {
					longestLeft = leftLen;
				}
				int rightLen = metrics.stringWidth(right);
				if (rightLen > longestRight) {
					longestRight = rightLen;
				}
			}

			int dotOffset = -metrics.stringWidth(":") / 2;

			for (String line : lines) {
				int dotIndex = line.indexOf(":");
				int xOffset = dotOffset;
				if (dotIndex == -1) {
					xOffset -= metrics.stringWidth(line) / 2;
				} else {
					xOffset -= metrics.stringWidth(line.substring(0, dotIndex));
				}
				g.setColor(shadow);
				g.drawString(line, centerX + xOffset + 1, topY + yOffset + 1);
				g.setColor(color);
				g.drawString(line, centerX + xOffset, topY + yOffset);
				yOffset += fontHeight;
			}
		} else {
			int longestLine = 0;
			if (alignment != TextAlignment.CENTER) {
				for (String line : lines) {
					int length = metrics.stringWidth(line);
					if (longestLine < length) {
						longestLine = length;
					}
				}
			}
			for (String line : lines) {
				int xOffset;
				switch (alignment) {
					case LEFT:
						xOffset = -longestLine / 2;
						break;
					case RIGHT:
						int length = metrics.stringWidth(line);
						xOffset = longestLine / 2 - length;
						break;
					case CENTER:
						xOffset = -metrics.stringWidth(line) / 2;
						break;
					default:
						throw new NotImplementedException("Alignment " + alignment + " has not been implemented");
				}
				g.setColor(shadow);
				g.drawString(line, centerX + xOffset + 1, topY + yOffset + 1);
				g.setColor(color);
				g.drawString(line, centerX + xOffset, topY + yOffset);
				yOffset += fontHeight;
			}
		}
	}

	private Color alpha(Color rgb, int alpha) {
		if (alpha == 255)
			return rgb;
		return new Color(rgb.getRed(), rgb.getGreen(), rgb.getBlue(), alpha);
	}

	private boolean applyPendingChange() {
		if (action == Action.SELECT || selections.isEmpty())
			return false;

		action = Action.SELECT;
		return true;
	}

	private boolean discardPendingChange() {
		if (action == Action.SELECT) {
			if (!selections.isEmpty())
				selections.clear();
			return false;
		}

		if (selections.isEmpty())
			return false;

		if (action == Action.GRAB) {
			// Reset the light back to its original offset
			var l = selections.get(0);
			l.alignment = originalLightAlignment;
			copyTo(l.offset, originalLightOffset);
		}

		action = Action.SELECT;
		return true;
	}

	@Override
	public MouseEvent mouseClicked(MouseEvent e) {
		return e;
	}

	@Override
	public MouseEvent mousePressed(MouseEvent e) {
		if (SwingUtilities.isMiddleMouseButton(e))
			isProbablyRotatingCamera = true;

		switch (action) {
			case SELECT:
				if (SwingUtilities.isLeftMouseButton(e) && e.isControlDown()) {
					e.consume();

					selections.clear();
					if (!hovers.isEmpty()) {
						selections.add(hovers.get(0));
					} else {
						action = Action.SELECT;
					}
				}
				break;
			case GRAB:
				if (SwingUtilities.isLeftMouseButton(e)) {
					if (applyPendingChange())
						e.consume();
				} else if (SwingUtilities.isRightMouseButton(e)) {
					if (discardPendingChange())
						e.consume();
				}
				break;
			case SCALE:
				break;
		}
		return e;
	}

	@Override
	public MouseEvent mouseReleased(MouseEvent e) {
		if (SwingUtilities.isMiddleMouseButton(e))
			isProbablyRotatingCamera = false;
		return e;
	}

	@Override
	public MouseEvent mouseEntered(MouseEvent e) {
		return e;
	}

	@Override
	public MouseEvent mouseExited(MouseEvent e) {
		return e;
	}

	@Override
	public MouseEvent mouseDragged(MouseEvent e) {
		return e;
	}

	@Override
	public MouseEvent mouseMoved(MouseEvent e) {
		return e;
	}

	@Override
	public void keyTyped(KeyEvent e) {}

	@Override
	public void keyPressed(KeyEvent e) {
//		if (e.isControlDown() && e.isShiftDown() && e.getKeyCode() == KeyCode.KC_S) {
//			// TODO: Save changes to JSON
//			// Every time the JSON is updated, either through the file system or exporting changes,
//			// create a checkpoint. Store all checkpoints in memory throughout the client session.
//			// Implement ctrl Z and ctrl shift Z to redo. Forget reverted checkpoints upon file change.
//		}

		// Interaction with selected object
		if (!selections.isEmpty()) {
			var l = selections.get(0);

			if (e.isControlDown() && e.getKeyCode() == KeyEvent.VK_C) {
				String str = "\n    \"offset\": [ " + l.offset[0] + ", " + -l.offset[1] + ", " + l.offset[2] + " ],";

				Clipboard clipboard = Toolkit.getDefaultToolkit().getSystemClipboard();
				StringSelection string = new StringSelection(str);
				clipboard.setContents(string, null);
				clientThread.invoke(() -> client.addChatMessage(
					ChatMessageType.GAMEMESSAGE,
					"117 HD",
					ColorUtil.wrapWithColorTag("[117 HD] Copied offset (must remove alignment): " + str.trim(), Color.GREEN),
					"117 HD"
				));
			}

			if (action == Action.SELECT) {
				switch (e.getKeyCode()) {
					case KeyEvent.VK_G:
						action = Action.GRAB;
						Arrays.fill(mouseDelta, 0);

						originalLightAlignment = l.alignment;
						copyTo(originalLightOffset, l.offset);
						copyTo(originalLightPosition, l.pos);

						l.alignment = Alignment.CUSTOM;
						for (int i = 0; i < 3; i++)
							l.offset[i] = l.pos[i] - l.origin[i];
						System.arraycopy(l.offset, 0, currentLightOffset, 0, 3);
						break;
					case KeyEvent.VK_S:
						action = Action.SCALE;
						break;
				}
			} else if (action == Action.GRAB) {
				int axis = -1;
				boolean cycleFreezeMode = false;
				switch (e.getKeyCode()) {
					case KeyEvent.VK_X:
						axis = 0;
						break;
					case KeyEvent.VK_Y:
						axis = 1;
						break;
					case KeyEvent.VK_Z:
						axis = 2;
						break;
					case KeyEvent.VK_G:
						cycleFreezeMode = true;
						break;
				}
				if (axis != -1) {
					boolean invert = e.isShiftDown();
					boolean modified = false;
					for (int i = 0; i < 3; i++) {
						boolean shouldFreeze = i == axis == invert;
						if (shouldFreeze != frozenAxes[i])
							modified = true;
						frozenAxes[i] = shouldFreeze;
					}
					if (modified) {
						// Reset current offset
						if (freezeMode == 0)
							freezeMode = 1;
						copyTo(l.offset, originalLightOffset);
					} else {
						cycleFreezeMode = true;
					}
				}
				if (cycleFreezeMode) {
					// If the same combination is repeated, cycle through different modes
					freezeMode++;
					freezeMode %= 3;
				}
			}

			switch (e.getKeyCode()) {
				case KeyEvent.VK_ESCAPE:
					if (discardPendingChange())
						e.consume();
					break;
				case KeyEvent.VK_ENTER:
					if (applyPendingChange())
						e.consume();
					break;
				case KeyEvent.VK_BACK_SPACE:
					// Reset light back to its defined offset
					l.alignment = l.def.alignment;
					System.arraycopy(l.def.offset, 0, l.offset, 0, 3);
					copyTo(currentLightOffset, l.offset);
					copyTo(originalLightOffset, l.offset);
					Arrays.fill(mouseDelta, 0);
					break;
			}
		}

		// Toggles
		if (e.isControlDown()) {
			switch (e.getKeyCode()) {
				case KeyEvent.VK_A:
					hideAnimLights = !hideAnimLights;
					break;
				case KeyEvent.VK_B:
					toggleBlackColor = !toggleBlackColor;
					break;
				case KeyEvent.VK_D:
					showDuplicationInfo = !showDuplicationInfo;
					break;
				case KeyEvent.VK_I:
					hideInfo = !hideInfo;
					break;
				case KeyEvent.VK_L:
					hideLabels = !hideLabels;
					break;
				case KeyEvent.VK_M:
					followMouse = !followMouse;
					break;
				case KeyEvent.VK_O:
					toggleOpacity = !toggleOpacity;
					break;
				case KeyEvent.VK_R:
					hideRadiusRings = !hideRadiusRings;
					break;
				case KeyEvent.VK_U:
					liveInfo = !liveInfo;
					break;
			}
		} else {
			switch (e.getKeyCode()) {
				case KeyEvent.VK_H:
					hideInvisibleLights = !hideInvisibleLights;
					break;
			}
		}
	}

	@Override
	public void keyReleased(KeyEvent e) {}
}

package rs117.hd.overlays;

import com.google.inject.Singleton;
import lombok.extern.slf4j.Slf4j;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.events.ConfigChanged;

import static org.lwjgl.opengl.GL33C.*;
import static rs117.hd.HdPluginConfig.*;
import static rs117.hd.utils.MathUtils.*;

@Slf4j
@Singleton
public class GammaCalibrationOverlay extends ShaderOverlay<GammaCalibrationOverlay.Shader> {
	static class Shader extends ShaderOverlay.Shader {
		public Uniform1f uniCalibrationTimer = addUniform1f("calibrationTimer");

		public Shader() {
			super(t -> t.add(GL_FRAGMENT_SHADER, "overlays/gamma_calibration_frag.glsl"));
		}
	}

	private long brightnessChangedAt;

	public GammaCalibrationOverlay() {
		setBorderless(true);
		setCentered(true);
		setMaintainAspectRatio(true);
		setInitialSize(300, 100);
	}

	private float getTimeout() {
		final int gammaCalibrationTimeout = 3000;
		long t = System.currentTimeMillis() - brightnessChangedAt;
		return saturate(1 - (float) t / gammaCalibrationTimeout);
	}

	@Override
	public boolean isHidden() {
		return super.isHidden() || getTimeout() <= 0;
	}

	@Override
	protected void updateUniforms() {
		shader.uniCalibrationTimer.set(getTimeout());
	}

	@Subscribe
	public void onConfigChanged(ConfigChanged event) {
		if (event.getGroup().equals(CONFIG_GROUP) && event.getKey().equals(KEY_BRIGHTNESS))
			brightnessChangedAt = System.currentTimeMillis();
	}
}

package rs117.hd.overlays;

import java.util.ArrayDeque;
import java.util.Arrays;
import javax.inject.Inject;
import javax.inject.Singleton;
import lombok.Getter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.client.callback.ClientThread;
import org.lwjgl.opengl.*;
import rs117.hd.HdPlugin;

import static org.lwjgl.opengl.GL33C.*;

@Slf4j
@Singleton
public class FrameTimer {
	@Inject
	private ClientThread clientThread;

	@Inject
	private HdPlugin plugin;

	private static final Timer[] TIMERS = Timer.values();
	private static final int NUM_TIMERS = TIMERS.length;
	private static final int NUM_GPU_TIMERS = (int) Arrays.stream(TIMERS).filter(t -> t.isGpuTimer).count();
	private static final int NUM_GPU_DEBUG_GROUPS = (int) Arrays.stream(TIMERS).filter(t -> t.gpuDebugGroup).count();

	private final boolean[] activeTimers = new boolean[NUM_TIMERS];
	private final long[] timings = new long[NUM_TIMERS];
	private final int[] gpuQueries = new int[NUM_TIMERS * 2];
	private final ArrayDeque<Timer> glDebugGroupStack = new ArrayDeque<>(NUM_GPU_DEBUG_GROUPS);
	private final ArrayDeque<Listener> listeners = new ArrayDeque<>();

	@Getter
	private boolean isActive = false;

	public long cumulativeError;
	public long errorCompensation;

	private void initialize() {
		clientThread.invokeLater(() -> {
			int[] queryNames = new int[NUM_GPU_TIMERS * 2];
			glGenQueries(queryNames);
			int queryIndex = 0;
			for (var timer : TIMERS)
				if (timer.isGpuTimer)
					for (int j = 0; j < 2; ++j)
						gpuQueries[timer.ordinal() * 2 + j] = queryNames[queryIndex++];

			isActive = true;
			plugin.setupSyncMode();
			plugin.enableDetailedTimers = true;

			// Estimate the timer's own runtime, with a warm-up run first
			final int iterations = 100000;
			final int compensation = 1950000; // additional manual correction
			for (int i = 0; i < 2; i++) {
				errorCompensation = 0;
				for (int j = 0; j < iterations; j++) {
					begin(Timer.DRAW_FRAME);
					end(Timer.DRAW_FRAME);
				}
				errorCompensation = (timings[Timer.DRAW_FRAME.ordinal()] + compensation) / iterations;
				timings[Timer.DRAW_FRAME.ordinal()] = 0;
			}
			log.debug("Estimated the overhead of timers to be around {} ns", errorCompensation);
		});
	}

	private void destroy() {
		clientThread.invokeLater(() -> {
			if (!isActive)
				return;

			isActive = false;
			plugin.setupSyncMode();
			plugin.enableDetailedTimers = false;

			glDeleteQueries(gpuQueries);
			Arrays.fill(gpuQueries, 0);
			reset();
		});
	}

	@FunctionalInterface
	public interface Listener {
		void onFrameCompletion(FrameTimings timings);
	}

	public void addTimingsListener(Listener listener) {
		if (listeners.isEmpty())
			initialize();
		listeners.add(listener);
	}

	public void removeTimingsListener(Listener listener) {
		listeners.remove(listener);
		if (listeners.isEmpty())
			destroy();
	}

	public void removeAllListeners() {
		listeners.clear();
		destroy();
	}

	public void reset() {
		Arrays.fill(timings, 0);
		Arrays.fill(activeTimers, false);
		cumulativeError = 0;
	}

	public void begin(Timer timer) {
		if (log.isDebugEnabled() && timer.gpuDebugGroup && HdPlugin.GL_CAPS.OpenGL43) {
			if (glDebugGroupStack.contains(timer)) {
				log.warn("The debug group {} is already on the stack", timer.name());
			} else {
				glDebugGroupStack.push(timer);
				GL43C.glPushDebugGroup(GL43C.GL_DEBUG_SOURCE_APPLICATION, timer.ordinal(), timer.name);
			}
		}

		if (!isActive)
			return;

		if (timer.isGpuTimer) {
			if (activeTimers[timer.ordinal()])
				throw new UnsupportedOperationException("Cumulative GPU timing isn't supported");
			glQueryCounter(gpuQueries[timer.ordinal() * 2], GL_TIMESTAMP);
		} else if (!activeTimers[timer.ordinal()]) {
			cumulativeError += errorCompensation + 1 >> 1;
			timings[timer.ordinal()] -= System.nanoTime() - cumulativeError;
		}
		activeTimers[timer.ordinal()] = true;
	}

	public void end(Timer timer) {
		if (log.isDebugEnabled() && timer.gpuDebugGroup && HdPlugin.GL_CAPS.OpenGL43) {
			if (glDebugGroupStack.peek() != timer) {
				log.warn("The debug group {} was popped out of order", timer.name());
			} else {
				glDebugGroupStack.pop();
				GL43C.glPopDebugGroup();
			}
		}

		if (!isActive || !activeTimers[timer.ordinal()])
			return;

		if (timer.isGpuTimer) {
			glQueryCounter(gpuQueries[timer.ordinal() * 2 + 1], GL_TIMESTAMP);
			// leave the GPU timer active, since it needs to be gathered at a later point
		} else {
			cumulativeError += errorCompensation >> 1;
			timings[timer.ordinal()] += System.nanoTime() - cumulativeError;
			activeTimers[timer.ordinal()] = false;
		}
	}

	public void add(Timer timer, long time) {
		if (isActive)
			timings[timer.ordinal()] += time;
	}

	public void endFrameAndReset() {
		if (HdPlugin.GL_CAPS.OpenGL43) {
			while (!glDebugGroupStack.isEmpty()) {
				log.warn("The debug group {} was never popped", glDebugGroupStack.pop().name());
				GL43C.glPopDebugGroup();
			}
		}

		if (!isActive)
			return;

		long frameEndNanos = System.nanoTime();
		long frameEndTimestamp = System.currentTimeMillis();

		int[] available = { 0 };
		for (var timer : TIMERS) {
			int i = timer.ordinal();
			if (timer.isGpuTimer) {
				if (!activeTimers[i])
					continue;

				for (int j = 0; j < 2; j++) {
					while (available[0] == 0)
						glGetQueryObjectiv(gpuQueries[i * 2 + j], GL_QUERY_RESULT_AVAILABLE, available);
					timings[i] += (j * 2L - 1) * glGetQueryObjectui64(gpuQueries[i * 2 + j], GL_QUERY_RESULT);
				}
			} else {
				if (activeTimers[i]) {
					// End the CPU timer automatically, but warn about it
					log.warn("Timer {} was never ended", timer);
					timings[i] += frameEndNanos;
				}
			}
		}

		var frameTimings = new FrameTimings(frameEndTimestamp, timings);
		for (var listener : listeners)
			listener.onFrameCompletion(frameTimings);

		reset();
	}
}

package rs117.hd.overlays;

import javax.annotation.Nonnull;
import lombok.RequiredArgsConstructor;

@RequiredArgsConstructor
public enum Timer {
	DRAW_FRAME,
	DRAW_SCENE,
	DRAW_RENDERABLE,
	DRAW_TILED_LIGHTING,
	GET_MODEL,
	VISIBILITY_CHECK,
	CLICKBOX_CHECK,
	MODEL_BATCHING,
	MODEL_PUSHING,
	MODEL_PUSHING_VERTEX,
	MODEL_PUSHING_NORMAL,
	MODEL_PUSHING_UV(false, "Model pushing UV"),
	UPDATE_ENVIRONMENT,
	UPDATE_LIGHTS,
	IMPOSTOR_TRACKING,
	REPLACE_FISHING_SPOTS,
	CHARACTER_DISPLACEMENT,
	MAP_UI_BUFFER(false, "Map UI Buffer"),
	COPY_UI(false, "Copy UI"),
	RENDER_FRAME(true, false),
	RENDER_TILED_LIGHTING(true),
	UPLOAD_GEOMETRY(true),
	UPLOAD_UI(true, "Upload UI"),
	COMPUTE(true),
	CLEAR_SCENE(true),
	RENDER_SHADOWS(true),
	RENDER_SCENE(true),
	RENDER_UI(true, "Render UI"),
	SWAP_BUFFERS,
	;

	public final String name;
	public final boolean isGpuTimer;
	public final boolean gpuDebugGroup;

	Timer() {
		name = enumToName(name());
		isGpuTimer = false;
		gpuDebugGroup = false;
	}

	Timer(boolean isGpuTimer) {
		name = enumToName(name());
		this.isGpuTimer = isGpuTimer;
		gpuDebugGroup = isGpuTimer;
	}

	Timer(boolean isGpuTimer, @Nonnull String name) {
		this.name = name;
		this.isGpuTimer = isGpuTimer;
		gpuDebugGroup = isGpuTimer;
	}

	Timer(boolean isGpuTimer, boolean gpuDebugGroup) {
		name = enumToName(name());
		this.isGpuTimer = isGpuTimer;
		this.gpuDebugGroup = gpuDebugGroup;
	}

	Timer(@Nonnull String name) {
		this.name = name;
		isGpuTimer = false;
		gpuDebugGroup = false;
	}

	private static String enumToName(String name) {
		name = name.replace('_', ' ');
		return name.substring(0, 1).toUpperCase() + name.substring(1).toLowerCase();
	}

	@Override
	public String toString() {
		return name;
	}
}

package rs117.hd.overlays;

import com.google.inject.Inject;
import com.google.inject.Singleton;
import java.awt.Dimension;
import java.awt.Graphics2D;
import java.util.ArrayDeque;
import java.util.Arrays;
import net.runelite.client.ui.FontManager;
import net.runelite.client.ui.overlay.OverlayLayer;
import net.runelite.client.ui.overlay.OverlayManager;
import net.runelite.client.ui.overlay.OverlayPanel;
import net.runelite.client.ui.overlay.OverlayPosition;
import net.runelite.client.ui.overlay.components.LineComponent;
import net.runelite.client.ui.overlay.components.TitleComponent;
import rs117.hd.HdPlugin;
import rs117.hd.utils.FrameTimingsRecorder;
import rs117.hd.utils.NpcDisplacementCache;

import static rs117.hd.utils.MathUtils.*;

@Singleton
public class FrameTimerOverlay extends OverlayPanel implements FrameTimer.Listener {
	@Inject
	private OverlayManager overlayManager;

	@Inject
	private HdPlugin plugin;

	@Inject
	private FrameTimer frameTimer;

	@Inject
	private FrameTimingsRecorder frameTimingsRecorder;

	@Inject
	private NpcDisplacementCache npcDisplacementCache;

	private final ArrayDeque<FrameTimings> frames = new ArrayDeque<>();
	private final long[] timings = new long[Timer.values().length];
	private final StringBuilder sb = new StringBuilder();

	@Inject
	public FrameTimerOverlay(HdPlugin plugin) {
		super(plugin);
		setLayer(OverlayLayer.ABOVE_SCENE);
		setPosition(OverlayPosition.TOP_RIGHT);
		panelComponent.setPreferredSize(new Dimension(215, 200));
	}

	public void setActive(boolean activate) {
		if (activate) {
			frameTimer.addTimingsListener(this);
			overlayManager.add(this);
		} else {
			frameTimer.removeTimingsListener(this);
			overlayManager.remove(this);
			frames.clear();
		}
	}

	@Override
	public void onFrameCompletion(FrameTimings timings) {
		long now = System.currentTimeMillis();
		while (!frames.isEmpty()) {
			if (now - frames.peekFirst().frameTimestamp < 10e3) // remove older entries
				break;
			frames.removeFirst();
		}
		frames.addLast(timings);
	}

	@Override
	public Dimension render(Graphics2D g) {
		long time = System.nanoTime();
		var boldFont = FontManager.getRunescapeBoldFont();

		var children = panelComponent.getChildren();
		if (!getAverageTimings()) {
			children.add(TitleComponent.builder()
				.text("Waiting for data...")
				.build());
		} else {
			long cpuTime = timings[Timer.DRAW_FRAME.ordinal()];
			addTiming("CPU", cpuTime, true);
			for (var t : Timer.values())
				if (!t.isGpuTimer && t != Timer.DRAW_FRAME)
					addTiming(t, timings);

			long gpuTime = timings[Timer.RENDER_FRAME.ordinal()];
			addTiming("GPU", gpuTime, true);
			for (var t : Timer.values())
				if (t.isGpuTimer && t != Timer.RENDER_FRAME)
					addTiming(t, timings);

			children.add(LineComponent.builder()
				.leftFont(boldFont)
				.left("Estimated bottleneck:")
				.rightFont(boldFont)
				.right(cpuTime > gpuTime ? "CPU" : "GPU")
				.build());

			children.add(LineComponent.builder()
				.leftFont(boldFont)
				.left("Estimated FPS:")
				.rightFont(boldFont)
				.right(String.format("%.1f FPS", 1e9 / max(cpuTime, gpuTime)))
				.build());

			children.add(LineComponent.builder()
				.left("Error compensation:")
				.right(String.format("%d ns", frameTimer.errorCompensation))
				.build());

			children.add(LineComponent.builder()
				.leftFont(boldFont)
				.left("Scene Stats:")
				.build());

			if (plugin.getSceneContext() != null) {
				var sceneContext = plugin.getSceneContext();
				children.add(LineComponent.builder()
					.left("Lights:")
					.right(String.format("%d/%d", sceneContext.numVisibleLights, sceneContext.lights.size()))
					.build());
			}

			children.add(LineComponent.builder()
				.left("Tiles:")
				.right(String.valueOf(plugin.getDrawnTileCount()))
				.build());

			children.add(LineComponent.builder()
				.left("Static Renderables:")
				.right(String.valueOf(plugin.getDrawnStaticRenderableCount()))
				.build());

			children.add(LineComponent.builder()
				.left("Dynamic Renderables:")
				.right(String.valueOf(plugin.getDrawnDynamicRenderableCount()))
				.build());

			children.add(LineComponent.builder()
				.left("NPC Displacement Cache Size:")
				.right(String.valueOf(npcDisplacementCache.size()))
				.build());

			if (frameTimingsRecorder.isCapturingSnapshot())
				children.add(LineComponent.builder()
					.leftFont(boldFont)
					.left("Capturing Snapshot...")
					.rightFont(boldFont)
					.right(String.format("%d%%", frameTimingsRecorder.getProgressPercentage()))
					.build());
		}

		var result = super.render(g);
		frameTimer.cumulativeError += System.nanoTime() - time;
		return result;
	}

	private boolean getAverageTimings() {
		if (frames.isEmpty())
			return false;

		Arrays.fill(timings, 0);
		for (var frame : frames)
			for (int i = 0; i < frame.timers.length; i++)
				timings[i] += frame.timers[i];

		for (int i = 0; i < timings.length; i++)
			timings[i] = max(0, timings[i] / frames.size());

		return true;
	}

	private void addTiming(Timer timer, long[] timings) {
		addTiming(timer.name, timings[timer.ordinal()], false);
	}

	private void addTiming(String name, long nanos, boolean bold) {
		if (nanos == 0)
			return;

		// Round timers to zero if they are less than a microsecond off
		String result = "~0 ms";
		if (abs(nanos) > 1e3) {
			result = sb.append(round(nanos / 1e3) / 1e3).append(" ms").toString();
			sb.setLength(0);
		}
		var font = bold ? FontManager.getRunescapeBoldFont() : FontManager.getRunescapeFont();
		panelComponent.getChildren().add(LineComponent.builder()
			.left(name + ":")
			.leftFont(font)
			.right(result)
			.rightFont(font)
			.build());
	}
}

package rs117.hd.data;

import lombok.RequiredArgsConstructor;

@RequiredArgsConstructor
public enum ObjectType {
	// Sourced from https://github.com/abextm/cache2/blob/2562ab769e4042667d6a10c3ab795b9622be6049/cache2-ts/src/types.ts#L119-L145
	WallStraight(0),
	WallDiagonalCorner(1),
	WallCorner(2),
	WallSquareCorner(3),
	WallDecorStraightNoOffset(4),
	WallDecorStraightOffset(5),
	WallDecorDiagonalOffset(6),
	WallDecorDiagonalNoOffset(7),
	WallDecorDiagonalBoth(8),
	WallDiagonal(9),
	CentrepieceStraight(10),
	CentrepieceDiagonal(11),
	RoofStraight(12),
	RoofDiagonalWithRoofEdge(13),
	RoofDiagonal(14),
	RoofCornerConcave(15),
	RoofCornerConvex(16),
	RoofFlat(17),
	RoofEdgeStraight(18),
	RoofEdgeDiagonalCorner(19),
	RoofEdgeCorner(20),
	RoofEdgeSquarecorner(21),
	GroundDecor(22),
	Unknown(-1);

	public final int id;

	public static ObjectType fromConfig(int config) {
		int type = config & 0x3F;
		if (type >= values().length - 1)
			return Unknown;
		return values()[type];
	}
}

package rs117.hd.scene.lights;

import com.google.gson.annotations.JsonAdapter;
import java.util.HashSet;
import javax.annotation.Nullable;
import rs117.hd.scene.GamevalManager;
import rs117.hd.scene.areas.AABB;
import rs117.hd.utils.ColorUtils;

public class LightDefinition {
	public String description;
	@Nullable
	public Integer worldX, worldY;
	public int plane;
	public Alignment alignment = Alignment.CUSTOM;
	public float[] offset = new float[3];
	public int height;
	public int radius = 300;
	public float strength = 5;
	@JsonAdapter(ColorUtils.SrgbToLinearAdapter.class)
	public float[] color;
	public LightType type = LightType.STATIC;
	public float duration;
	public float range;
	public int fadeInDuration = 50;
	public int fadeOutDuration = 50;
	public int spawnDelay;
	public int despawnDelay;
	public boolean fixedDespawnTime;
	public boolean visibleFromOtherPlanes;
	public boolean ignoreActorHiding;
	public int renderableIndex = -1;

	@JsonAdapter(AABB.ArrayAdapter.class)
	public AABB[] areas = {};
	@JsonAdapter(AABB.ArrayAdapter.class)
	public AABB[] excludeAreas = {};
	@JsonAdapter(GamevalManager.NpcAdapter.class)
	public HashSet<Integer> npcIds = new HashSet<>();
	@JsonAdapter(GamevalManager.ObjectAdapter.class)
	public HashSet<Integer> objectIds = new HashSet<>();
	@JsonAdapter(GamevalManager.SpotanimAdapter.class)
	public HashSet<Integer> projectileIds = new HashSet<>();
	@JsonAdapter(GamevalManager.SpotanimAdapter.class)
	public HashSet<Integer> graphicsObjectIds = new HashSet<>();
	@JsonAdapter(GamevalManager.AnimationAdapter.class)
	public HashSet<Integer> animationIds = new HashSet<>();

	public void normalize() {
		if (description == null)
			description = "N/A";
		if (alignment == null || alignment == Alignment.CENTER)
			alignment = Alignment.CUSTOM;
		if (offset == null || offset.length != 3) {
			offset = new float[3];
		} else {
			offset[1] *= -1;
		}
		if (color == null || color.length != 3)
			color = new float[3];
		if (type == null)
			type = LightType.STATIC;
	}
}

package rs117.hd.scene.lights;

public enum LightType
{
	STATIC, FLICKER, PULSE
}

package rs117.hd.scene.lights;

import net.runelite.api.*;
import net.runelite.api.coords.*;

import static rs117.hd.utils.MathUtils.*;

public class Light
{
	public static final float VISIBILITY_FADE = 0.1f;

	public final float randomOffset = RAND.nextFloat();
	public final LightDefinition def;

	public float radius;
	public float strength;
	/**
	 * Linear color space RGBA in the range [0, 1]
	 */
	public float[] color;
	public float animation = 0.5f;
	public float duration;
	public float fadeInDuration;
	public float fadeOutDuration;
	public float spawnDelay;
	public float despawnDelay;

	public boolean visible;
	public boolean parentExists;
	public boolean withinViewingDistance = true;
	public boolean hiddenTemporarily;
	public boolean markedForRemoval;
	public boolean persistent;
	public boolean replayable;

	public final boolean animationSpecific;
	public final boolean dynamicLifetime;

	public float elapsedTime;
	public float changedVisibilityAt = -1;
	public float lifetime = -1;

	public WorldPoint worldPoint;
	public boolean belowFloor;
	public boolean aboveFloor;
	public int plane;
	public int prevPlane = -1;
	public Alignment alignment;
	public float[] origin = new float[3];
	public float[] offset = new float[3];
	public float[] pos = new float[3];
	public int orientation;
	public float distanceSquared;

	public Actor actor;
	public Projectile projectile;
	public TileObject tileObject;
	public GraphicsObject graphicsObject;
	public int spotanimId = -1;
	public int[] projectileRefCounter;
	public long hash;

	public int sizeX = 1;
	public int sizeY = 1;

	public Light(LightDefinition def) {
		this.def = def;
		copyTo(offset, def.offset);
		duration = max(0, def.duration) / 1000f;
		fadeInDuration = max(0, def.fadeInDuration) / 1000f;
		fadeOutDuration = max(0, def.fadeOutDuration) / 1000f;
		spawnDelay = max(0, def.spawnDelay) / 1000f;
		despawnDelay = max(0, def.despawnDelay) / 1000f;
		color = def.color;
		radius = def.radius;
		strength = def.strength;
		alignment = def.alignment;
		plane = def.plane;
		if (def.type == LightType.PULSE)
			animation = (float) Math.random();

		// Old way of setting a fixed lifetime
		if (def.fixedDespawnTime)
			lifetime = spawnDelay + despawnDelay;

		if (lifetime == -1) {
			dynamicLifetime = true;
			// If the despawn is dynamic, ensure there's enough time for the light to fade out
			despawnDelay = max(despawnDelay, fadeOutDuration);
		} else {
			dynamicLifetime = false;
		}

		animationSpecific = !def.animationIds.isEmpty();
		if (animationSpecific) {
			persistent = replayable = true;
			// Initially hide the light
			if (dynamicLifetime) {
				lifetime = 0;
			} else {
				elapsedTime = lifetime;
			}
		}
	}

	public void toggleTemporaryVisibility(boolean changedPlanes) {
		hiddenTemporarily = !hiddenTemporarily;
		// If visibility changes due to something other than changing planes, fade in or out
		if (!changedPlanes) {
			// Begin fading in or out, while accounting for time already spent fading out or in respectively
			float beginFadeAt = elapsedTime;
			if (changedVisibilityAt != -1)
				beginFadeAt -= max(0, VISIBILITY_FADE - (elapsedTime - changedVisibilityAt));
			changedVisibilityAt = beginFadeAt;
		}
	}

	public float getTemporaryVisibilityFade() {
		float fade = 1;
		if (changedVisibilityAt != -1)
			fade = saturate((elapsedTime - changedVisibilityAt) / Light.VISIBILITY_FADE);
		if (hiddenTemporarily)
			fade = 1 - fade; // Fade out instead
		return fade;
	}

	public void applyTemporaryVisibilityFade() {
		strength *= getTemporaryVisibilityFade();
	}
}

package rs117.hd.scene.lights;

import javax.annotation.Nullable;
import net.runelite.api.*;
import net.runelite.api.coords.*;

public class TileObjectImpostorTracker {
	public TileObject tileObject;
	public final long tileObjectHash;
	public boolean justSpawned = true;
	public boolean spawnedAnyLights;
	public int[] impostorIds;
	public int impostorVarbit = -1;
	public int impostorVarp = -1;
	public int impostorId = -1;

	public TileObjectImpostorTracker(TileObject tileObject) {
		this.tileObject = tileObject;
		this.tileObjectHash = tileObjectHash(tileObject);
	}

	public long lightHash(int impostorId) {
		long hash = this.tileObjectHash;
		hash = hash * 31 + impostorId;
		return hash;
	}

	private static long tileObjectHash(@Nullable TileObject tileObject) {
		if (tileObject == null)
			return 0;

		LocalPoint lp = tileObject.getLocalLocation();
		long hash = lp.getX();
		hash = hash * 31 + lp.getY();
		hash = hash * 31 + tileObject.getPlane();
		hash = hash * 31 + tileObject.getId();
		return hash;
	}
}

package rs117.hd.scene.lights;

public enum Alignment
{
	CUSTOM(0, false, true),
	@Deprecated
	CENTER(0, false, false),

	NORTH(0, true, false),
	NORTHEAST(256, true, false),
	NORTHEAST_CORNER(256, false, false),
	EAST(512, true, false),
	SOUTHEAST(768, true, false),
	SOUTHEAST_CORNER(768, false, false),
	SOUTH(1024, true, false),
	SOUTHWEST(1280, true, false),
	SOUTHWEST_CORNER(1280, false, false),
	WEST(1536, true, false),
	NORTHWEST(1792, true, false),
	NORTHWEST_CORNER(1792, false, false),

	BACK(0, true, true),
	BACKLEFT(256, true, true),
	BACKLEFT_CORNER(256, false, true),
	LEFT(512, true, true),
	FRONTLEFT(768, true, true),
	FRONTLEFT_CORNER(768, false, true),
	FRONT(1024, true, true),
	FRONTRIGHT(1280, true, true),
	FRONTRIGHT_CORNER(1280, false, true),
	RIGHT(1536, true, true),
	BACKRIGHT(1792, true, true),
	BACKRIGHT_CORNER(1792, false, true);

	public final int orientation;
	public final boolean radial;
	public final boolean relative;

	Alignment(int orientation, boolean radial, boolean relative)
	{
		this.orientation = orientation;
		this.radial = radial;
		this.relative = relative;
	}
}

/*
 * Copyright (c) 2018, Adam <Adam@sigterm.info>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package rs117.hd.scene;

import java.awt.geom.AffineTransform;
import java.awt.image.AffineTransformOp;
import java.awt.image.BufferedImage;
import java.awt.image.DataBufferInt;
import java.nio.IntBuffer;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.ScheduledFuture;
import java.util.concurrent.TimeUnit;
import javax.annotation.Nullable;
import javax.inject.Inject;
import javax.inject.Singleton;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.*;
import net.runelite.client.callback.ClientThread;
import org.lwjgl.BufferUtils;
import org.lwjgl.opengl.*;
import rs117.hd.HdPluginConfig;
import rs117.hd.utils.Props;
import rs117.hd.utils.ResourcePath;

import static org.lwjgl.opengl.GL33C.*;
import static rs117.hd.utils.MathUtils.*;
import static rs117.hd.utils.ResourcePath.path;

@Slf4j
@Singleton
public class TextureManager {
	private static final String[] SUPPORTED_IMAGE_EXTENSIONS = { "png", "jpg" };
	private static final ResourcePath TEXTURE_PATH = Props
		.getFolder("rlhd.texture-path", () -> path(TextureManager.class, "textures"));

	@Inject
	private Client client;

	@Inject
	private ClientThread clientThread;

	@Inject
	private ScheduledExecutorService executor;

	@Inject
	private HdPluginConfig config;

	@Inject
	private MaterialManager materialManager;

	// Temporary variables for texture loading and generating material uniforms
	private IntBuffer pixelBuffer;
	private BufferedImage scaledImage;
	private BufferedImage vanillaImage;

	private ScheduledFuture<?> debounce;

	public void startUp() {
		assert vanillaTexturesAvailable();
		vanillaImage = new BufferedImage(128, 128, BufferedImage.TYPE_INT_ARGB);

		TEXTURE_PATH.watch((path, first) -> {
			if (first) return;
			log.debug("Texture changed: {}", path);

			// Mark texture layers that need to be reloaded
			String filename = path.getFilename();
			if (!filename.isEmpty())
				for (var layer : materialManager.textureLayers)
					if (filename.equals(layer.material.getTextureName()))
						layer.needsUpload = true;

			// Debounce texture loading in case the same file change is triggered multiple times
			if (debounce == null || debounce.cancel(false) || debounce.isDone())
				debounce = executor.schedule(() -> clientThread.invoke(materialManager::uploadTextures), 100, TimeUnit.MILLISECONDS);
		});
	}

	public void shutDown() {
		pixelBuffer = null;
		scaledImage = null;
		vanillaImage = null;
	}

	public boolean vanillaTexturesAvailable() {
		var textureProvider = client.getTextureProvider();
		if (textureProvider == null)
			return false;

		Texture[] vanillaTextures = textureProvider.getTextures();
		if (vanillaTextures == null || vanillaTextures.length == 0)
			return false;

		// Ensure all textures are available
		for (int i = 0; i < vanillaTextures.length; i++) {
			var texture = vanillaTextures[i];
			if (texture != null) {
				int[] pixels = textureProvider.load(i);
				if (pixels == null)
					return false;
			}
		}

		return true;
	}

	@Nullable
	public BufferedImage loadTexture(@Nullable String filename, int fallbackVanillaIndex) {
		if (filename != null) {
			var image = loadTexture(filename);
			if (image != null)
				return image;
			if (fallbackVanillaIndex == -1) {
				log.warn("Missing texture: '{}'", filename);
				return null;
			}
		}

		if (fallbackVanillaIndex == -1)
			return null;

		var textureProvider = client.getTextureProvider();
		Texture[] vanillaTextures = textureProvider.getTextures();
		var texture = vanillaTextures[fallbackVanillaIndex];
		if (texture == null) {
			log.warn("Missing vanilla texture index {}", fallbackVanillaIndex);
			return null;
		}

		int[] pixels = textureProvider.load(fallbackVanillaIndex);
		if (pixels == null) {
			log.warn("No pixels for vanilla texture index {}", fallbackVanillaIndex);
			return null;
		}

		if (pixels.length != 128 * 128) {
			log.warn("Unknown dimensions for vanilla texture at index {} ({} pixels)", fallbackVanillaIndex, pixels.length);
			return null;
		}

		for (int j = 0; j < pixels.length; j++) {
			int rgb = pixels[j];
			// Black is considered transparent in vanilla, with anything else being fully opaque
			int alpha = rgb == 0 ? 0 : 0xFF;
			vanillaImage.setRGB(j % 128, j / 128, alpha << 24 | rgb & 0xFFFFFF);
		}

		return vanillaImage;
	}

	@Nullable
	public BufferedImage loadTexture(String filename) {
		for (String ext : SUPPORTED_IMAGE_EXTENSIONS) {
			ResourcePath path = TEXTURE_PATH.resolve(filename + "." + ext);
			try {
				return path.loadImage();
			} catch (Exception ex) {
				log.trace("Unable to load texture: {}", path, ex);
			}
		}

		return null;
	}

	public void uploadTexture(int target, int textureLayer, int[] textureSize, BufferedImage image) {
		assert client.isClientThread() : "Not thread safe";

		// Allocate resources for storing temporary image data
		int numPixels = product(textureSize);
		if (pixelBuffer == null || pixelBuffer.capacity() < numPixels)
			pixelBuffer = BufferUtils.createIntBuffer(numPixels);
		if (scaledImage == null || scaledImage.getWidth() != textureSize[0] || scaledImage.getHeight() != textureSize[1])
			scaledImage = new BufferedImage(textureSize[0], textureSize[1], BufferedImage.TYPE_INT_ARGB);

		// TODO: scale and transform on the GPU for better performance (would save 400+ ms)
		AffineTransform t = new AffineTransform();
		if (image != vanillaImage) {
			// Flip non-vanilla textures horizontally to match vanilla UV orientation
			t.translate(textureSize[1], 0);
			t.scale(-1, 1);
		}
		t.scale((double) textureSize[0] / image.getWidth(), (double) textureSize[1] / image.getHeight());
		AffineTransformOp scaleOp = new AffineTransformOp(t, AffineTransformOp.TYPE_BICUBIC);
		scaleOp.filter(image, scaledImage);

		int[] pixels = ((DataBufferInt) scaledImage.getRaster().getDataBuffer()).getData();
		pixelBuffer.put(pixels).flip();

		// Go from TYPE_4BYTE_ABGR in the BufferedImage to RGBA
		glTexSubImage3D(
			target, 0, 0, 0,
			textureLayer, textureSize[0], textureSize[1], 1,
			GL_BGRA, GL_UNSIGNED_INT_8_8_8_8_REV, pixelBuffer
		);
	}

	public void setAnisotropicFilteringLevel() {
		int level = config.anisotropicFilteringLevel();
		if (level == 0) {
			//level = 0 means no mipmaps and no anisotropic filtering
			glTexParameteri(GL_TEXTURE_2D_ARRAY, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
			glTexParameteri(GL_TEXTURE_2D_ARRAY, GL_TEXTURE_MAG_FILTER, GL_NEAREST);
		} else {
			// level = 1 means with mipmaps but without anisotropic filtering GL_MAX_TEXTURE_MAX_ANISOTROPY_EXT defaults to 1.0 which is off
			// level > 1 enables anisotropic filtering. It's up to the vendor what the values mean
			// Even if anisotropic filtering isn't supported, mipmaps will be enabled with any level >= 1
			// Trilinear filtering is used for HD textures as linear filtering produces noisy textures
			// that are very noticeable on terrain
			glTexParameteri(GL_TEXTURE_2D_ARRAY, GL_TEXTURE_MIN_FILTER, GL_LINEAR_MIPMAP_LINEAR);
			glTexParameteri(GL_TEXTURE_2D_ARRAY, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
		}

		if (GL.getCapabilities().GL_EXT_texture_filter_anisotropic) {
			final float maxSamples = glGetFloat(EXTTextureFilterAnisotropic.GL_MAX_TEXTURE_MAX_ANISOTROPY_EXT);
			glTexParameterf(GL_TEXTURE_2D_ARRAY, EXTTextureFilterAnisotropic.GL_TEXTURE_MAX_ANISOTROPY_EXT, clamp(level, 1, maxSamples));
		}
	}
}

package rs117.hd.scene;

import java.io.IOException;
import java.util.HashMap;
import java.util.Objects;
import javax.annotation.Nonnull;
import javax.annotation.Nullable;
import javax.inject.Inject;
import javax.inject.Singleton;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.*;
import net.runelite.client.callback.ClientThread;
import rs117.hd.HdPlugin;
import rs117.hd.model.ModelPusher;
import rs117.hd.scene.model_overrides.ModelOverride;
import rs117.hd.utils.FileWatcher;
import rs117.hd.utils.ModelHash;
import rs117.hd.utils.Props;
import rs117.hd.utils.ResourcePath;

import static rs117.hd.utils.ResourcePath.path;

@Slf4j
@Singleton
public class ModelOverrideManager {
	private static final ResourcePath MODEL_OVERRIDES_PATH = Props
		.getFile("rlhd.model-overrides-path", () -> path(ModelOverrideManager.class, "model_overrides.json"));

	@Inject
	private Client client;

	@Inject
	private ClientThread clientThread;

	@Inject
	private HdPlugin plugin;

	@Inject
	private GamevalManager gamevalManager;

	@Inject
	private ModelPusher modelPusher;

	@Inject
	private FishingSpotReplacer fishingSpotReplacer;

	private final HashMap<Integer, ModelOverride> modelOverrides = new HashMap<>();

	private FileWatcher.UnregisterCallback fileWatcher;

	public void startUp() {
		fileWatcher = MODEL_OVERRIDES_PATH.watch((path, first) -> clientThread.invoke(() -> {
			try {
				ModelOverride[] parsedOverrides = path.loadJson(plugin.getGson(), ModelOverride[].class);
				if (parsedOverrides == null)
					throw new IOException("Empty or invalid: " + path);

				modelOverrides.clear();
				for (ModelOverride override : parsedOverrides) {
					try {
						override.normalize(plugin.configVanillaShadowMode);
					} catch (IllegalStateException ex) {
						log.error("Invalid model override '{}': {}", override.description, ex.getMessage());
						continue;
					}

					addOverride(override);

					if (override.hideInAreas.length > 0) {
						var hider = override.copy();
						hider.hide = true;
						hider.areas = override.hideInAreas;
						addOverride(hider);
					}
				}

				addOverride(fishingSpotReplacer.getModelOverride());

				log.debug("Loaded {} model overrides", modelOverrides.size());

				if (first)
					return;

				modelPusher.clearModelCache();
				plugin.reuploadScene();
			} catch (Exception ex) {
				log.error("Failed to load model overrides:", ex);
			}
		}));
	}

	public void shutDown() {
		if (fileWatcher != null)
			fileWatcher.unregister();
		fileWatcher = null;

		modelOverrides.clear();
	}

	public void reload() {
		shutDown();
		startUp();
	}

	private void addOverride(@Nullable ModelOverride override) {
		if (override == null || override.seasonalTheme != null && override.seasonalTheme != plugin.configSeasonalTheme)
			return;

		for (int id : override.npcIds)
			addEntry(ModelHash.TYPE_NPC, id, override);
		for (int id : override.objectIds)
			addEntry(ModelHash.TYPE_OBJECT, id, override);
		for (int id : override.projectileIds)
			addEntry(ModelHash.TYPE_PROJECTILE, id, override);
		for (int id : override.graphicsObjectIds)
			addEntry(ModelHash.TYPE_GRAPHICS_OBJECT, id, override);
	}

	private void addEntry(int type, int id, ModelOverride entry) {
		int uuid = ModelHash.packUuid(type, id);
		ModelOverride current = modelOverrides.get(uuid);

		if (current != null && !Objects.equals(current.seasonalTheme, entry.seasonalTheme)) {
			// Seasonal theme overrides should take precedence
			if (current.seasonalTheme != null)
				return;
			current = null;
		}

		boolean isDuplicate = false;

		if (entry.areas.length == 0) {
			// Non-area-restricted override, of which there can only be one per UUID

			// A dummy override is used as the base if only area-specific overrides exist
			isDuplicate = current != null && !current.isDummy;

			if (isDuplicate && Props.DEVELOPMENT) {
				String name = null;
				switch (type) {
					case ModelHash.TYPE_NPC:
						name = gamevalManager.getNpcName(id);
						break;
					case ModelHash.TYPE_OBJECT:
						name = gamevalManager.getObjectName(id);
						break;
					case ModelHash.TYPE_PROJECTILE:
					case ModelHash.TYPE_GRAPHICS_OBJECT:
						name = gamevalManager.getSpotanimName(id);
						break;
				}

				// This should ideally not be reached, so print helpful warnings in development mode
				if (entry.hideInAreas.length > 0) {
					log.error(
						"Replacing {} ({}) from '{}' with hideInAreas-override '{}'. This is likely a mistake...",
						name, id, current.description, entry.description
					);
				} else {
					log.error(
						"Replacing {} ({}) from '{}' with '{}'. The first-mentioned override should be removed.",
						name, id, current.description, entry.description
					);
				}
			}

			if (current != null && current.areaOverrides != null && !current.areaOverrides.isEmpty()) {
				var areaOverrides = current.areaOverrides;
				current = entry.copy();
				current.areaOverrides = areaOverrides;
			} else {
				current = entry;
			}

			modelOverrides.put(uuid, current);
		} else {
			if (current == null)
				current = ModelOverride.NONE;

			if (current.areaOverrides == null) {
				// We need to replace the override with a copy that has a separate list of area overrides to avoid conflicts
				current = current.copy();
				current.areaOverrides = new HashMap<>();
				modelOverrides.put(uuid, current);
			}

			for (var area : entry.areas)
				current.areaOverrides.put(area, entry);
		}
	}

	@Nonnull
	public ModelOverride getOverride(int uuid, int[] worldPos) {
		var override = modelOverrides.get(ModelHash.getUuidWithoutSubType(uuid));
		if (override == null)
			return ModelOverride.NONE;

		if (override.areaOverrides != null)
			for (var entry : override.areaOverrides.entrySet())
				if (entry.getKey().contains(worldPos))
					return entry.getValue();

		return override;
	}
}

/*
 * Copyright (c) 2019 Abex
 * Copyright (c) 2021, 117 <https://twitter.com/117scape>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package rs117.hd.scene;

import com.google.common.collect.ArrayListMultimap;
import com.google.common.collect.ListMultimap;
import com.google.gson.Gson;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashSet;
import java.util.List;
import java.util.function.Predicate;
import javax.annotation.Nonnull;
import javax.annotation.Nullable;
import javax.inject.Inject;
import javax.inject.Singleton;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.*;
import net.runelite.api.coords.*;
import net.runelite.api.events.*;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.eventbus.EventBus;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.plugins.PluginManager;
import net.runelite.client.plugins.entityhider.EntityHiderConfig;
import net.runelite.client.plugins.entityhider.EntityHiderPlugin;
import rs117.hd.HdPlugin;
import rs117.hd.config.DynamicLights;
import rs117.hd.data.ObjectType;
import rs117.hd.opengl.uniforms.UBOLights;
import rs117.hd.overlays.FrameTimer;
import rs117.hd.overlays.Timer;
import rs117.hd.scene.lights.Alignment;
import rs117.hd.scene.lights.Light;
import rs117.hd.scene.lights.LightDefinition;
import rs117.hd.scene.lights.LightType;
import rs117.hd.scene.lights.TileObjectImpostorTracker;
import rs117.hd.utils.HDUtils;
import rs117.hd.utils.ModelHash;
import rs117.hd.utils.Props;
import rs117.hd.utils.ResourcePath;

import static net.runelite.api.Constants.*;
import static net.runelite.api.Perspective.*;
import static rs117.hd.scene.SceneContext.SCENE_OFFSET;
import static rs117.hd.utils.MathUtils.*;
import static rs117.hd.utils.ResourcePath.path;

@Singleton
@Slf4j
public class LightManager {
	private static final ResourcePath LIGHTS_PATH = Props
		.getFile("rlhd.lights-path", () -> path(LightManager.class, "lights.json"));

	@Inject
	private Client client;

	@Inject
	private EventBus eventBus;

	@Inject
	private PluginManager pluginManager;

	@Inject
	private ConfigManager configManager;

	@Inject
	private HdPlugin plugin;

	@Inject
	private ModelOverrideManager modelOverrideManager;

	@Inject
	private EntityHiderPlugin entityHiderPlugin;

	@Inject
	private FrameTimer frameTimer;

	private final ArrayList<Light> WORLD_LIGHTS = new ArrayList<>();
	private final ListMultimap<Integer, LightDefinition> NPC_LIGHTS = ArrayListMultimap.create();
	private final ListMultimap<Integer, LightDefinition> OBJECT_LIGHTS = ArrayListMultimap.create();
	private final ListMultimap<Integer, LightDefinition> PROJECTILE_LIGHTS = ArrayListMultimap.create();
	private final ListMultimap<Integer, LightDefinition> GRAPHICS_OBJECT_LIGHTS = ArrayListMultimap.create();

	private boolean reloadLights;
	private EntityHiderConfig entityHiderConfig;
	private int currentPlane;

	public void loadConfig(Gson gson, ResourcePath path) {
		try {
			LightDefinition[] lights;
			try {
				lights = path.loadJson(gson, LightDefinition[].class);
				if (lights == null) {
					log.warn("Skipping empty lights.json");
					return;
				}
			} catch (IOException ex) {
				log.error("Failed to load lights", ex);
				return;
			}

			WORLD_LIGHTS.clear();
			NPC_LIGHTS.clear();
			OBJECT_LIGHTS.clear();
			PROJECTILE_LIGHTS.clear();
			GRAPHICS_OBJECT_LIGHTS.clear();

			for (LightDefinition lightDef : lights) {
				lightDef.normalize();
				if (lightDef.worldX != null && lightDef.worldY != null) {
					Light light = new Light(lightDef);
					light.worldPoint = new WorldPoint(lightDef.worldX, lightDef.worldY, lightDef.plane);
					light.persistent = true;
					WORLD_LIGHTS.add(light);
				}
				lightDef.npcIds.forEach(id -> NPC_LIGHTS.put(id, lightDef));
				lightDef.objectIds.forEach(id -> OBJECT_LIGHTS.put(id, lightDef));
				lightDef.projectileIds.forEach(id -> PROJECTILE_LIGHTS.put(id, lightDef));
				lightDef.graphicsObjectIds.forEach(id -> GRAPHICS_OBJECT_LIGHTS.put(id, lightDef));
			}

			log.debug("Loaded {} lights", lights.length);

			// Reload lights once on plugin startup, and whenever lights.json should be hot-swapped.
			// If we don't reload on startup, NPCs won't have lights added until RuneLite fires events
			reloadLights = true;
		} catch (Exception ex) {
			log.error("Failed to parse light configuration", ex);
		}
	}

	public void startUp() {
		entityHiderConfig = configManager.getConfig(EntityHiderConfig.class);
		LIGHTS_PATH.watch(path -> loadConfig(plugin.getGson(), path));
		eventBus.register(this);
	}

	public void shutDown() {
		eventBus.unregister(this);
	}

	public void update(@Nonnull SceneContext sceneContext) {
		assert client.isClientThread();

		if (plugin.configDynamicLights == DynamicLights.NONE || client.getGameState() != GameState.LOGGED_IN) {
			sceneContext.numVisibleLights = 0;
			return;
		}

		if (reloadLights) {
			reloadLights = false;
			loadSceneLights(sceneContext, null);

			client.getNpcs().forEach(npc -> {
				addNpcLights(npc);
				addSpotanimLights(npc);
			});
		}

		// These should never occur, but just in case...
		if (sceneContext.knownProjectiles.size() > 10000) {
			log.warn("Too many projectiles tracked: {}. Clearing...", sceneContext.knownProjectiles.size());
			sceneContext.knownProjectiles.clear();
		}
		if (sceneContext.lights.size() > 10000) {
			log.warn("Too many lights: {}. Clearing...", sceneContext.lights.size());
			sceneContext.lights.clear();
		}

		int drawDistance = plugin.getDrawDistance() * LOCAL_TILE_SIZE;
		Tile[][][] tiles = sceneContext.scene.getExtendedTiles();
		int[][][] tileHeights = sceneContext.scene.getTileHeights();
		var cachedNpcs = client.getTopLevelWorldView().npcs();
		var cachedPlayers = client.getTopLevelWorldView().players();
		int plane = client.getPlane();
		boolean changedPlanes = false;

		if (plane != currentPlane) {
			currentPlane = plane;
			changedPlanes = true;
		}

		float cosYaw = cos(plugin.cameraOrientation[0]);
		float sinYaw = sin(plugin.cameraOrientation[0]);
		float cosPitch = cos(plugin.cameraOrientation[1]);
		float sinPitch = sin(plugin.cameraOrientation[1]);
		float[] viewDir = {
			cosPitch * -sinYaw,
			sinPitch,
			cosPitch * cosYaw
		};
		float[] cameraToLight = new float[3];

		for (Light light : sceneContext.lights) {
			// Ways lights may get deleted:
			// - animation-specific:
			//   effectively spawn when the animation they're attached to starts playing, and despawns when it stops,
			//   but they are typically replayable, so they don't fully despawn until marked for removal by something else
			// - spotanim & projectile lights:
			//   automatically marked for removal upon completion
			// - actor lights:
			//   may be automatically marked for removal if the actor becomes invalid
			// - other lights:
			//   despawn when marked for removal by a RuneLite despawn event
			// - fixed lifetime && !replayable:
			//   All non-replayable lights with a fixed lifetime will be automatically marked for removal when done playing

			// Light fade-in and fade-out are based on whether the parent currently exists
			// Additionally, lights have an overruling fade-out when being deprioritized

			// Whatever the light is attached to is presumed to exist if it's not marked for removal yet
			boolean parentExists = !light.markedForRemoval;
			boolean hiddenTemporarily = false;

			if (light.tileObject != null) {
				if (!light.markedForRemoval && light.animationSpecific && light.tileObject instanceof GameObject) {
					int animationId = -1;
					var renderable = ((GameObject) light.tileObject).getRenderable();
					if (renderable instanceof DynamicObject) {
						var anim = ((DynamicObject) renderable).getAnimation();
						if (anim != null)
							animationId = anim.getId();
					}
					parentExists = light.def.animationIds.contains(animationId);
				}
			} else if (light.projectile != null) {
				light.origin[0] = (int) light.projectile.getX();
				light.origin[1] = (int) light.projectile.getZ() - light.def.height;
				light.origin[2] = (int) light.projectile.getY();
				if (light.projectile.getRemainingCycles() <= 0) {
					light.markedForRemoval = true;
				} else {
					hiddenTemporarily = !shouldShowProjectileLights();
					if (light.animationSpecific) {
						var animation = light.projectile.getAnimation();
						parentExists = animation != null && light.def.animationIds.contains(animation.getId());
					}
					light.orientation = light.projectile.getOrientation();
				}
			} else if (light.graphicsObject != null) {
				light.origin[0] = light.graphicsObject.getLocation().getX();
				light.origin[1] = light.graphicsObject.getZ() - light.def.height;
				light.origin[2] = light.graphicsObject.getLocation().getY();
				if (light.graphicsObject.finished()) {
					light.markedForRemoval = true;
				} else if (light.animationSpecific) {
					var animation = light.graphicsObject.getAnimation();
					parentExists = animation != null && light.def.animationIds.contains(animation.getId());
				}
			} else if (light.actor != null && !light.markedForRemoval) {
				if (light.actor instanceof NPC && light.actor != cachedNpcs.byIndex(((NPC) light.actor).getIndex()) ||
					light.actor instanceof Player && light.actor != cachedPlayers.byIndex(((Player) light.actor).getId()) ||
					light.spotanimId != -1 && !light.actor.hasSpotAnim(light.spotanimId)
				) {
					parentExists = false;
					light.markedForRemoval = true;
				} else {
					var lp = light.actor.getLocalLocation();
					light.origin[0] = lp.getX();
					light.origin[2] = lp.getY();
					light.plane = plane;
					light.orientation = light.actor.getCurrentOrientation();

					if (light.animationSpecific)
						parentExists = light.def.animationIds.contains(light.actor.getAnimation());

					int tileExX = ((int) light.origin[0] >> LOCAL_COORD_BITS) + SCENE_OFFSET;
					int tileExY = ((int) light.origin[2] >> LOCAL_COORD_BITS) + SCENE_OFFSET;

					// Some NPCs, such as Crystalline Hunllef in The Gauntlet, sometimes return scene X/Y values far outside the possible range.
					Tile tile;
					if (tileExX >= 0 && tileExY >= 0 &&
						tileExX < EXTENDED_SCENE_SIZE && tileExY < EXTENDED_SCENE_SIZE &&
						(tile = tiles[plane][tileExX][tileExY]) != null
					) {
						if (!light.def.ignoreActorHiding &&
							!(light.actor instanceof NPC && ((NPC) light.actor).getComposition().getSize() > 1)
						) {
							// Check if the actor is hidden by another actor on the same tile
							for (var gameObject : tile.getGameObjects()) {
								if (gameObject == null || !(gameObject.getRenderable() instanceof Actor))
									continue;

								// Assume only the first actor at the same exact location will be rendered
								if (gameObject.getX() == light.origin[0] && gameObject.getY() == light.origin[2]) {
									hiddenTemporarily = gameObject.getRenderable() != light.actor;
									break;
								}
							}
						}

						if (!hiddenTemporarily)
							hiddenTemporarily = !isActorLightVisible(light.actor);

						// Tile null check is to prevent oddities caused by - once again - Crystalline Hunllef.
						// May also apply to other NPCs in instances.
						if (tile.getBridge() != null)
							plane++;

						// Interpolate between tile heights based on specific scene coordinates
						float lerpX = fract(light.origin[0] / (float) LOCAL_TILE_SIZE);
						float lerpY = fract(light.origin[2] / (float) LOCAL_TILE_SIZE);
						float heightNorth = mix(
							tileHeights[plane][tileExX][tileExY + 1],
							tileHeights[plane][tileExX + 1][tileExY + 1],
							lerpX
						);
						float heightSouth = mix(
							tileHeights[plane][tileExX][tileExY],
							tileHeights[plane][tileExX + 1][tileExY],
							lerpX
						);
						float tileHeight = mix(heightSouth, heightNorth, lerpY);
						light.origin[1] = (int) tileHeight - 1 - light.def.height;
					}
				}
			}

			light.pos[0] = light.origin[0];
			light.pos[1] = light.origin[1];
			light.pos[2] = light.origin[2];

			int orientation = 0;
			if (light.alignment.relative)
				orientation = mod(light.orientation + light.alignment.orientation, 2048);

			if (light.alignment == Alignment.CUSTOM) {
				// orientation 0 = south
				float sin = sin(orientation * JAU_TO_RAD);
				float cos = cos(orientation * JAU_TO_RAD);
				float x = light.offset[0];
				float z = light.offset[2];
				light.pos[0] += -cos * x - sin * z;
				light.pos[1] += light.offset[1];
				light.pos[2] += -cos * z + sin * x;
			} else {
				int localSizeX = light.sizeX * LOCAL_TILE_SIZE;
				int localSizeY = light.sizeY * LOCAL_TILE_SIZE;

				float radius = localSizeX / 2f;
				if (!light.alignment.radial)
					radius = sqrt(localSizeX * localSizeX + localSizeX * localSizeX) / 2;

				float sine = SINE[orientation] / 65536f;
				float cosine = COSINE[orientation] / 65536f;
				cosine /= (float) localSizeX / (float) localSizeY;

				int offsetX = (int) (radius * sine);
				int offsetY = (int) (radius * cosine);

				light.pos[0] += offsetX;
				light.pos[2] += offsetY;
			}

			// This is a little bit slow, so only update it when necessary
			if (light.prevPlane != light.plane) {
				light.prevPlane = light.plane;
				light.belowFloor = false;
				light.aboveFloor = false;
				int tileExX = ((int) light.pos[0] >> LOCAL_COORD_BITS) + SCENE_OFFSET;
				int tileExY = ((int) light.pos[2] >> LOCAL_COORD_BITS) + SCENE_OFFSET;
				if (light.plane >= 0 && tileExX >= 0 && tileExY >= 0 && tileExX < EXTENDED_SCENE_SIZE && tileExY < EXTENDED_SCENE_SIZE) {
					byte hasTile = sceneContext.filledTiles[tileExX][tileExY];
					if ((hasTile & (1 << light.plane + 1)) != 0)
						light.belowFloor = true;
					if ((hasTile & (1 << light.plane)) != 0)
						light.aboveFloor = true;
				}
			}

			if (!hiddenTemporarily && !light.def.visibleFromOtherPlanes) {
				// Hide certain lights on planes lower than the player to prevent light 'leaking' through the floor
				if (light.plane < plane && light.belowFloor)
					hiddenTemporarily = true;
				// Hide any light that is above the current plane and is above a solid floor
				if (light.plane > plane && light.aboveFloor)
					hiddenTemporarily = true;
			}

			if (parentExists != light.parentExists) {
				light.parentExists = parentExists;
				if (parentExists) {
					// Reset the light if it's replayable and the parent just spawned
					if (light.replayable) {
						light.elapsedTime = 0;
						light.changedVisibilityAt = -1;
						if (light.dynamicLifetime)
							light.lifetime = -1;
					}
				} else if (light.lifetime == -1) {
					// Schedule despawning of the light if the parent just despawned, and the light isn't already scheduled to despawn
					float minLifetime = light.spawnDelay + light.fadeInDuration;
					light.lifetime = max(minLifetime, light.elapsedTime) + light.despawnDelay;
				}
			}

			if (hiddenTemporarily != light.hiddenTemporarily)
				light.toggleTemporaryVisibility(changedPlanes);

			light.elapsedTime += plugin.deltaClientTime;

			light.visible = light.spawnDelay < light.elapsedTime && (light.lifetime == -1 || light.elapsedTime < light.lifetime);

			// If the light is temporarily hidden, keep it visible only while fading out
			if (light.visible && light.hiddenTemporarily)
				light.visible = light.changedVisibilityAt != -1 && light.elapsedTime - light.changedVisibilityAt < Light.VISIBILITY_FADE;

			if (light.visible) {
				// Prioritize lights closer to the focal point
				float distX = plugin.cameraFocalPoint[0] - light.pos[0];
				float distZ = plugin.cameraFocalPoint[1] - light.pos[2];
				light.distanceSquared = distX * distX + distZ * distZ;

				float maxRadius = light.def.radius;
				switch (light.def.type) {
					case FLICKER:
						maxRadius *= 1.5f;
						break;
					case PULSE:
						maxRadius *= 1 + light.def.range / 100f;
						break;
				}

				// Hide lights which cannot possibly affect the visible scene,
				// by either being behind the camera, or too far beyond the edge of the scene
				float near = -maxRadius * maxRadius;
				float far = drawDistance + LOCAL_HALF_TILE_SIZE + maxRadius;
				far *= far;
				light.visible = near < light.distanceSquared && light.distanceSquared < far;
			}
		}

		// Order visible lights first, then by distance. Leave hidden lights unordered at the end.
		sceneContext.lights.sort((a, b) -> a.visible && b.visible ?
			Float.compare(a.distanceSquared, b.distanceSquared) :
			Boolean.compare(b.visible, a.visible));

		// Count number of visible lights
		sceneContext.numVisibleLights = 0;
		int maxLights = plugin.configTiledLighting ? UBOLights.MAX_LIGHTS : plugin.configDynamicLights.getMaxSceneLights();
		for (Light light : sceneContext.lights) {
			// Exit early once encountering the first invisible light, or the light limit is reached
			if (!light.visible || sceneContext.numVisibleLights >= maxLights)
				break;

			sceneContext.numVisibleLights++;

			// If the light was temporarily hidden, begin fading in
			if (!light.withinViewingDistance && light.hiddenTemporarily)
				light.toggleTemporaryVisibility(changedPlanes);
			light.withinViewingDistance = true;

			if (light.def.type == LightType.FLICKER) {
				float t = TWO_PI * (mod(plugin.elapsedTime, 60) / 60 + light.randomOffset);
				float flicker = (
					pow(cos(11 * t), 3) +
					pow(cos(17 * t), 6) +
					pow(cos(23 * t), 2) +
					pow(cos(31 * t), 6) +
					pow(cos(71 * t), 4) +
					pow(cos(151 * t), 6) / 2
				) / 4.335f;

				float maxFlicker = 1f + (light.def.range / 100f);
				float minFlicker = 1f - (light.def.range / 100f);

				flicker = minFlicker + (maxFlicker - minFlicker) * flicker;

				light.strength = light.def.strength * flicker;
				light.radius = (int) (light.def.radius * 1.5f);
			} else if (light.def.type == LightType.PULSE) {
				light.animation = fract(light.animation + plugin.deltaClientTime / light.duration);
				float output = 1 - 2 * abs(light.animation - .5f);
				float multiplier = 1 + (2 * output - 1) * light.def.range / 100;
				light.radius = light.def.radius * multiplier;
				light.strength = light.def.strength * multiplier;
			} else {
				light.strength = light.def.strength;
				light.radius = light.def.radius;
				light.color = light.def.color;
			}

			// Spawn & despawn fade-in and fade-out
			if (light.fadeInDuration > 0)
				light.strength *= saturate((light.elapsedTime - light.spawnDelay) / light.fadeInDuration);
			if (light.fadeOutDuration > 0 && light.lifetime != -1)
				light.strength *= saturate((light.lifetime - light.elapsedTime) / light.fadeOutDuration);

			light.applyTemporaryVisibilityFade();
		}

		for (int i = sceneContext.lights.size() - 1; i >= sceneContext.numVisibleLights; i--) {
			Light light = sceneContext.lights.get(i);
			light.withinViewingDistance = false;

			// Automatically despawn non-replayable fixed lifetime lights when they expire
			if (!light.replayable && light.lifetime != -1 && light.lifetime < light.elapsedTime)
				light.markedForRemoval = true;

			if (light.markedForRemoval) {
				sceneContext.lights.remove(i);
				if (light.projectile != null && --light.projectileRefCounter[0] == 0)
					sceneContext.knownProjectiles.remove(light.projectile);
			}
		}
	}

	private boolean isActorLightVisible(@Nonnull Actor actor) {
		try {
			// getModel may throw an exception from vanilla client code
			if (actor.getModel() == null)
				return false;
		} catch (Exception ex) {
			// Vanilla handles exceptions thrown in `DrawCallbacks#draw` gracefully, but here we have to handle them
			return false;
		}

		boolean entityHiderEnabled = pluginManager.isPluginEnabled(entityHiderPlugin);

		if (actor instanceof NPC) {
			if (!plugin.configNpcLights)
				return false;

			if (entityHiderEnabled) {
				var npc = (NPC) actor;
				boolean isPet = npc.getComposition().isFollower();

				if (client.getFollower() != null && client.getFollower().getIndex() == npc.getIndex())
					return true;

				if (entityHiderConfig.hideNPCs() && !isPet)
					return false;

				return !entityHiderConfig.hidePets() || !isPet;
			}
		} else if (actor instanceof Player) {
			if (entityHiderEnabled) {
				var player = (Player) actor;
				Player local = client.getLocalPlayer();
				if (local == null || player.getName() == null)
					return true;

				if (player == local)
					return !entityHiderConfig.hideLocalPlayer();

				if (entityHiderConfig.hideAttackers() && player.getInteracting() == local)
					return false;

				if (player.isFriend())
					return !entityHiderConfig.hideFriends();
				if (player.isFriendsChatMember())
					return !entityHiderConfig.hideFriendsChatMembers();
				if (player.isClanMember())
					return !entityHiderConfig.hideClanChatMembers();
				if (client.getIgnoreContainer().findByName(player.getName()) != null)
					return !entityHiderConfig.hideIgnores();

				return !entityHiderConfig.hideOthers();
			}
		}

		return true;
	}

	private boolean shouldShowProjectileLights() {
		return plugin.configProjectileLights && !(pluginManager.isPluginEnabled(entityHiderPlugin) && entityHiderConfig.hideProjectiles());
	}

	public void loadSceneLights(SceneContext sceneContext, @Nullable SceneContext oldSceneContext)
	{
		assert client.isClientThread();

		if (oldSceneContext == null) {
			sceneContext.lights.clear();
			sceneContext.trackedTileObjects.clear();
			sceneContext.trackedVarps.clear();
			sceneContext.trackedVarbits.clear();
			sceneContext.knownProjectiles.clear();
		} else {
			// Copy over NPC and projectile lights from the old scene
			ArrayList<Light> lightsToKeep = new ArrayList<>();
			for (Light light : oldSceneContext.lights)
				if (light.actor != null || light.projectile != null)
					lightsToKeep.add(light);

			sceneContext.lights.addAll(lightsToKeep);
			for (var light : lightsToKeep)
				if (light.projectile != null && oldSceneContext.knownProjectiles.contains(light.projectile))
					sceneContext.knownProjectiles.add(light.projectile);
		}

		for (Light light : WORLD_LIGHTS) {
			assert light.worldPoint != null;
			if (sceneContext.sceneBounds.contains(light.worldPoint))
				addWorldLight(sceneContext, light);
		}

		for (Tile[][] plane : sceneContext.scene.getExtendedTiles()) {
			for (Tile[] column : plane) {
				for (Tile tile : column) {
					if (tile == null)
						continue;

					DecorativeObject decorativeObject = tile.getDecorativeObject();
					if (decorativeObject != null)
						handleObjectSpawn(sceneContext, decorativeObject);

					WallObject wallObject = tile.getWallObject();
					if (wallObject != null)
						handleObjectSpawn(sceneContext, wallObject);

					GroundObject groundObject = tile.getGroundObject();
					if (groundObject != null && groundObject.getRenderable() != null)
						handleObjectSpawn(sceneContext, groundObject);

					for (GameObject gameObject : tile.getGameObjects()) {
						// Skip nulls, players & NPCs
						if (gameObject == null || gameObject.getRenderable() instanceof Actor)
							continue;

						handleObjectSpawn(sceneContext, gameObject);
					}
				}
			}
		}
	}

	private void removeLightIf(Predicate<Light> predicate) {
		var sceneContext = plugin.getSceneContext();
		if (sceneContext == null)
			return;
		removeLightIf(sceneContext, predicate);
	}

	private void removeLightIf(@Nonnull SceneContext sceneContext, Predicate<Light> predicate) {
		for (var light : sceneContext.lights)
			if (predicate.test(light))
				light.markedForRemoval = true;
	}

	private void addSpotanimLights(Actor actor) {
		var sceneContext = plugin.getSceneContext();
		if (sceneContext == null)
			return;

		int[] worldPos = sceneContext.localToWorld(actor.getLocalLocation());

		for (var spotAnim : actor.getSpotAnims()) {
			int spotAnimId = spotAnim.getId();
			for (var def : GRAPHICS_OBJECT_LIGHTS.get(spotAnim.getId())) {
				if (def.areas.length > 0) {
					boolean isInArea = Arrays.stream(def.areas).anyMatch(aabb -> aabb.contains(worldPos));
					if (!isInArea)
						continue;
				}
				if (def.excludeAreas.length > 0) {
					boolean isInArea = Arrays.stream(def.excludeAreas).anyMatch(aabb -> aabb.contains(worldPos));
					if (isInArea)
						continue;
				}

				boolean isDuplicate = sceneContext.lights.stream()
					.anyMatch(light ->
						light.spotanimId == spotAnimId &&
						light.actor == actor &&
						light.def == def);
				if (isDuplicate)
					continue;

				Light light = new Light(def);
				light.plane = -1;
				light.spotanimId = spotAnimId;
				light.actor = actor;
				sceneContext.lights.add(light);
			}
		}
	}

	private void addNpcLights(NPC npc)
	{
		var sceneContext = plugin.getSceneContext();
		if (sceneContext == null)
			return;

		int uuid = ModelHash.packUuid(ModelHash.TYPE_NPC, npc.getId());
		int[] worldPos = sceneContext.localToWorld(npc.getLocalLocation());

		var modelOverride = modelOverrideManager.getOverride(uuid, worldPos);
		if (modelOverride.hide)
			return;

		for (LightDefinition def : NPC_LIGHTS.get(npc.getId())) {
			if (def.areas.length > 0) {
				boolean isInArea = Arrays.stream(def.areas).anyMatch(aabb -> aabb.contains(worldPos));
				if (!isInArea)
					continue;
			}
			if (def.excludeAreas.length > 0) {
				boolean isInArea = Arrays.stream(def.excludeAreas).anyMatch(aabb -> aabb.contains(worldPos));
				if (isInArea)
					continue;
			}

			// Prevent duplicate lights from being spawned for the same NPC
			boolean isDuplicate = sceneContext.lights.stream()
				.anyMatch(light ->
					light.actor == npc &&
					light.def == def &&
					!light.markedForRemoval);
			if (isDuplicate)
				continue;

			Light light = new Light(def);
			light.plane = -1;
			light.actor = npc;
			sceneContext.lights.add(light);
		}
	}

	private void handleObjectSpawn(TileObject object) {
		var sceneContext = plugin.getSceneContext();
		if (sceneContext != null)
			handleObjectSpawn(sceneContext, object);
	}

	private void handleObjectSpawn(
		@Nonnull SceneContext sceneContext,
		@Nonnull TileObject tileObject
	) {
		if (sceneContext.trackedTileObjects.containsKey(tileObject))
			return;

		var tracker = new TileObjectImpostorTracker(tileObject);
		sceneContext.trackedTileObjects.put(tileObject, tracker);

		// prevent objects at plane -1 and below from having lights
		if (tileObject.getPlane() < 0)
			return;

		ObjectComposition def = client.getObjectDefinition(tileObject.getId());
		tracker.impostorIds = def.getImpostorIds();
		if (tracker.impostorIds != null) {
			tracker.impostorVarbit = def.getVarbitId();
			tracker.impostorVarp = def.getVarPlayerId();
			if (tracker.impostorVarbit != -1)
				sceneContext.trackedVarbits.put(tracker.impostorVarbit, tracker);
			if (tracker.impostorVarp != -1)
				sceneContext.trackedVarps.put(tracker.impostorVarp, tracker);
		}

		trackImpostorChanges(sceneContext, tracker);
	}

	private void handleObjectDespawn(TileObject tileObject) {
		var sceneContext = plugin.getSceneContext();
		if (sceneContext == null)
			return;

		var tracker = sceneContext.trackedTileObjects.remove(tileObject);
		if (tracker == null)
			return;

		if (tracker.spawnedAnyLights) {
			long hash = tracker.lightHash(tracker.impostorId);
			removeLightIf(sceneContext, l -> l.hash == hash);
		}

		if (tracker.impostorVarbit != -1)
			sceneContext.trackedVarbits.remove(tracker.impostorVarbit, tracker);
		if (tracker.impostorVarp != -1)
			sceneContext.trackedVarps.remove(tracker.impostorVarp, tracker);
	}

	private void trackImpostorChanges(@Nonnull SceneContext sceneContext, TileObjectImpostorTracker tracker) {
		int impostorId = -1;
		if (tracker.impostorIds != null) {
			try {
				int impostorIndex = -1;
				if (tracker.impostorVarbit != -1) {
					impostorIndex = client.getVarbitValue(tracker.impostorVarbit);
				} else if (tracker.impostorVarp != -1) {
					impostorIndex = client.getVarpValue(tracker.impostorVarp);
				}
				if (impostorIndex >= 0)
					impostorId = tracker.impostorIds[min(impostorIndex, tracker.impostorIds.length - 1)];
			} catch (Exception ex) {
				log.debug("Error getting impostor:", ex);
			}
		}

		// Don't do anything if the impostor is the same, unless the object just spawned
		if (impostorId == tracker.impostorId && !tracker.justSpawned)
			return;

		int sizeX = 1;
		int sizeY = 1;
		Renderable[] renderables = new Renderable[2];
		int[] orientations = { 0, 0 };
		int[] offset = { 0, 0 };

		var tileObject = tracker.tileObject;
		if (tileObject instanceof GroundObject) {
			var object = (GroundObject) tileObject;
			renderables[0] = object.getRenderable();
			orientations[0] = HDUtils.getModelOrientation(object.getConfig());
		} else if (tileObject instanceof DecorativeObject) {
			var object = (DecorativeObject) tileObject;
			renderables[0] = object.getRenderable();
			renderables[1] = object.getRenderable2();
			int ori = orientations[0] = orientations[1] = HDUtils.getModelOrientation(object.getConfig());
			switch (ObjectType.fromConfig(object.getConfig())) {
				case WallDecorDiagonalNoOffset:
				case WallDecorDiagonalOffset:
				case WallDecorDiagonalBoth:
					ori = (ori + 512) % 2048;
					offset[0] = SINE[ori] * 64 >> 16;
					offset[1] = COSINE[ori] * 64 >> 16;
					break;
			}
			offset[0] += object.getXOffset();
			offset[1] += object.getYOffset();
		} else if (tileObject instanceof WallObject) {
			var object = (WallObject) tileObject;
			renderables[0] = object.getRenderable1();
			renderables[1] = object.getRenderable2();
			orientations[0] = HDUtils.convertWallObjectOrientation(object.getOrientationA());
			orientations[1] = HDUtils.convertWallObjectOrientation(object.getOrientationB());
		} else if (tileObject instanceof GameObject) {
			var object = (GameObject) tileObject;
			sizeX = object.sizeX();
			sizeY = object.sizeY();
			renderables[0] = object.getRenderable();
			int ori = orientations[0] = HDUtils.getModelOrientation(object.getConfig());
			int offsetDist = 64;
			switch (ObjectType.fromConfig(object.getConfig())) {
				case RoofEdgeDiagonalCorner:
				case RoofDiagonalWithRoofEdge:
					ori += 1024;
					offsetDist = round(offsetDist / sqrt(2));
				case WallDiagonal:
					ori = (ori + 2048 - 256) % 2048;
					offset[0] = SINE[ori] * offsetDist >> 16;
					offset[1] = COSINE[ori] * offsetDist >> 16;
					break;
			}
		} else {
			log.warn("Unhandled TileObject type: id: {}, hash: {}", tileObject.getId(), tileObject.getHash());
			return;
		}

		// Despawn old lights, if we spawned any for the previous impostor
		if (tracker.spawnedAnyLights) {
			long oldHash = tracker.lightHash(tracker.impostorId);
			removeLightIf(sceneContext, l -> l.hash == oldHash);
			tracker.spawnedAnyLights = false;
		}

		long newHash = tracker.lightHash(impostorId);
		List<LightDefinition> lights = OBJECT_LIGHTS.get(impostorId == -1 ? tileObject.getId() : impostorId);
		HashSet<LightDefinition> onlySpawnOnce = new HashSet<>();

		LocalPoint lp = tileObject.getLocalLocation();
		int lightX = lp.getX() + offset[0];
		int lightZ = lp.getY() + offset[1];
		int plane = tileObject.getPlane();

		// Spawn animation-specific lights for each DynamicObject renderable, and non-animation-based lights
		for (int i = 0; i < 2; i++) {
			var renderable = renderables[i];
			if (renderable == null)
				continue;

			for (LightDefinition def : lights) {
				if (def.areas.length > 0) {
					int[] worldPos = sceneContext.localToWorld(lightX, lightZ, plane);
					boolean isInArea = Arrays.stream(def.areas).anyMatch(aabb -> aabb.contains(worldPos));
					if (!isInArea)
						continue;
				}
				if (def.excludeAreas.length > 0) {
					int[] worldPos = sceneContext.localToWorld(lightX, lightZ, plane);
					boolean isInArea = Arrays.stream(def.excludeAreas).anyMatch(aabb -> aabb.contains(worldPos));
					if (isInArea)
						continue;
				}

				// Rarely, it may be necessary to specify which of the two possible renderables the light should be attached to
				if (def.renderableIndex == -1) {
					// If unspecified, spawn it for the first non-null renderable
					if (onlySpawnOnce.contains(def))
						continue;
					onlySpawnOnce.add(def);
				} else if (def.renderableIndex != i) {
					continue;
				}

				int tileExX = clamp(lp.getSceneX() + SCENE_OFFSET, 0, EXTENDED_SCENE_SIZE - 2);
				int tileExY = clamp(lp.getSceneY() + SCENE_OFFSET, 0, EXTENDED_SCENE_SIZE - 2);
				float lerpX = fract(lightX / (float) LOCAL_TILE_SIZE);
				float lerpZ = fract(lightZ / (float) LOCAL_TILE_SIZE);
				int tileZ = clamp(plane, 0, MAX_Z - 1);

				Tile[][][] tiles = sceneContext.scene.getExtendedTiles();
				Tile tile = tiles[tileZ][tileExX][tileExY];
				if (tile != null && tile.getBridge() != null && tileZ < MAX_Z - 1)
					tileZ++;

				int[][][] tileHeights = sceneContext.scene.getTileHeights();
				float heightNorth = mix(
					tileHeights[tileZ][tileExX][tileExY + 1],
					tileHeights[tileZ][tileExX + 1][tileExY + 1],
					lerpX
				);
				float heightSouth = mix(
					tileHeights[tileZ][tileExX][tileExY],
					tileHeights[tileZ][tileExX + 1][tileExY],
					lerpX
				);
				float tileHeight = mix(heightSouth, heightNorth, lerpZ);

				Light light = new Light(def);
				light.hash = newHash;
				light.tileObject = tileObject;
				light.plane = plane;
				light.orientation = orientations[i];
				light.origin[0] = lightX;
				light.origin[1] = (int) tileHeight - light.def.height - 1;
				light.origin[2] = lightZ;
				light.sizeX = sizeX;
				light.sizeY = sizeY;
				sceneContext.lights.add(light);
				tracker.spawnedAnyLights = true;
			}
		}

		tracker.impostorId = impostorId;
		tracker.justSpawned = false;
	}

	private void addWorldLight(SceneContext sceneContext, Light light) {
		assert light.worldPoint != null;
		sceneContext.worldToLocals(light.worldPoint).forEach(local -> {
			int tileExX = local[0] / LOCAL_TILE_SIZE + SCENE_OFFSET;
			int tileExY = local[1] / LOCAL_TILE_SIZE + SCENE_OFFSET;
			if (tileExX < 0 || tileExY < 0 || tileExX >= EXTENDED_SCENE_SIZE || tileExY >= EXTENDED_SCENE_SIZE)
				return;

			var copy = new Light(light.def);
			copy.plane = local[2];
			copy.persistent = light.persistent;
			copy.origin[0] = local[0] + LOCAL_HALF_TILE_SIZE;
			copy.origin[1] = sceneContext.scene.getTileHeights()[local[2]][tileExX][tileExY] - copy.def.height - 1;
			copy.origin[2] = local[1] + LOCAL_HALF_TILE_SIZE;
			sceneContext.lights.add(copy);
		});
	}

	@Subscribe
	public void onProjectileMoved(ProjectileMoved projectileMoved) {
		SceneContext sceneContext = plugin.getSceneContext();
		if (sceneContext == null)
			return;

		// Since there's no spawn & despawn events for projectiles, add when they move for the first time
		Projectile projectile = projectileMoved.getProjectile();
		if (!sceneContext.knownProjectiles.add(projectile))
			return;

		int[] worldPos = sceneContext.localToWorld((int) projectile.getX(), (int) projectile.getY(), projectile.getFloor());

		int[] refCounter = { 0 };
		for (LightDefinition def : PROJECTILE_LIGHTS.get(projectile.getId())) {
			if (def.areas.length > 0) {
				boolean isInArea = Arrays.stream(def.areas).anyMatch(aabb -> aabb.contains(worldPos));
				if (!isInArea)
					continue;
			}
			if (def.excludeAreas.length > 0) {
				boolean isInArea = Arrays.stream(def.excludeAreas).anyMatch(aabb -> aabb.contains(worldPos));
				if (isInArea)
					continue;
			}

			Light light = new Light(def);
			light.projectile = projectile;
			light.projectileRefCounter = refCounter;
			refCounter[0]++;
			light.origin[0] = (int) projectile.getX();
			light.origin[1] = (int) projectile.getZ();
			light.origin[2] = (int) projectile.getY();
			light.plane = projectile.getFloor();

			sceneContext.lights.add(light);
		}
	}

	@Subscribe
	public void onNpcSpawned(NpcSpawned spawn) {
		NPC npc = spawn.getNpc();
		addNpcLights(npc);
		addSpotanimLights(npc);
	}

	@Subscribe
	public void onNpcChanged(NpcChanged change) {
		// Respawn non-spotanim lights
		NPC npc = change.getNpc();
		removeLightIf(light -> light.actor == npc && light.spotanimId == -1);
		addNpcLights(change.getNpc());
	}

	@Subscribe
	public void onNpcDespawned(NpcDespawned despawn) {
		NPC npc = despawn.getNpc();
		removeLightIf(light -> light.actor == npc);
	}

	@Subscribe
	public void onPlayerSpawned(PlayerSpawned spawn) {
		addSpotanimLights(spawn.getPlayer());
	}

	@Subscribe
	public void onPlayerChanged(PlayerChanged change) {
		// Don't add spotanim lights on player change events, since it breaks death & respawn lights
	}

	@Subscribe
	public void onGraphicChanged(GraphicChanged change) {
		addSpotanimLights(change.getActor());
	}

	@Subscribe
	public void onPlayerDespawned(PlayerDespawned despawn) {
		Player player = despawn.getPlayer();
		removeLightIf(light -> light.actor == player);
	}

	@Subscribe
	public void onGraphicsObjectCreated(GraphicsObjectCreated graphicsObjectCreated) {
		SceneContext sceneContext = plugin.getSceneContext();
		if (sceneContext == null)
			return;

		GraphicsObject graphicsObject = graphicsObjectCreated.getGraphicsObject();
		var lp = graphicsObject.getLocation();
		int[] worldPos = sceneContext.localToWorld(lp, graphicsObject.getLevel());

		for (LightDefinition def : GRAPHICS_OBJECT_LIGHTS.get(graphicsObject.getId())) {
			if (def.areas.length > 0) {
				boolean isInArea = Arrays.stream(def.areas).anyMatch(aabb -> aabb.contains(worldPos));
				if (!isInArea)
					continue;
			}
			if (def.excludeAreas.length > 0) {
				boolean isInArea = Arrays.stream(def.excludeAreas).anyMatch(aabb -> aabb.contains(worldPos));
				if (isInArea)
					continue;
			}

			Light light = new Light(def);
			light.graphicsObject = graphicsObject;
			light.origin[0] = lp.getX();
			light.origin[1] = graphicsObject.getZ();
			light.origin[2] = lp.getY();
			light.plane = worldPos[2];
			sceneContext.lights.add(light);
		}
	}

	@Subscribe
	public void onGameObjectSpawned(GameObjectSpawned spawn) {
		handleObjectSpawn(spawn.getGameObject());
	}

	@Subscribe
	public void onGameObjectDespawned(GameObjectDespawned despawn) {
		handleObjectDespawn(despawn.getGameObject());
	}

	@Subscribe
	public void onWallObjectSpawned(WallObjectSpawned spawn) {
		handleObjectSpawn(spawn.getWallObject());
	}

	@Subscribe
	public void onWallObjectDespawned(WallObjectDespawned despawn) {
		handleObjectDespawn(despawn.getWallObject());
	}

	@Subscribe
	public void onDecorativeObjectSpawned(DecorativeObjectSpawned spawn) {
		handleObjectSpawn(spawn.getDecorativeObject());
	}

	@Subscribe
	public void onDecorativeObjectDespawned(DecorativeObjectDespawned despawn) {
		handleObjectDespawn(despawn.getDecorativeObject());
	}

	@Subscribe
	public void onGroundObjectSpawned(GroundObjectSpawned spawn) {
		handleObjectSpawn(spawn.getGroundObject());
	}

	@Subscribe
	public void onGroundObjectDespawned(GroundObjectDespawned despawn) {
		handleObjectDespawn(despawn.getGroundObject());
	}

	@Subscribe
	public void onVarbitChanged(VarbitChanged event) {
		var sceneContext = plugin.getSceneContext();
		if (sceneContext == null)
			return;

		if (plugin.enableDetailedTimers)
			frameTimer.begin(Timer.IMPOSTOR_TRACKING);
		// Check if the event is specifically a varbit change first,
		// since all varbit changes are necessarily also varp changes
		if (event.getVarbitId() != -1) {
			for (var tracker : sceneContext.trackedVarbits.get(event.getVarbitId()))
				trackImpostorChanges(sceneContext, tracker);
		} else if (event.getVarpId() != -1) {
			for (var tracker : sceneContext.trackedVarps.get(event.getVarpId()))
				trackImpostorChanges(sceneContext, tracker);
		}
		if (plugin.enableDetailedTimers)
			frameTimer.end(Timer.IMPOSTOR_TRACKING);
	}
}

/*
 * Copyright (c) 2021, 117 <https://twitter.com/117scape>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package rs117.hd.scene;

import java.io.IOException;
import java.util.HashMap;
import java.util.Objects;
import javax.annotation.Nonnull;
import javax.inject.Inject;
import javax.inject.Singleton;
import lombok.Getter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.*;
import net.runelite.client.callback.ClientThread;
import rs117.hd.HdPlugin;
import rs117.hd.HdPluginConfig;
import rs117.hd.config.DefaultSkyColor;
import rs117.hd.scene.environments.Environment;
import rs117.hd.utils.FileWatcher;
import rs117.hd.utils.Props;
import rs117.hd.utils.ResourcePath;

import static rs117.hd.utils.MathUtils.*;
import static rs117.hd.utils.ResourcePath.path;

@Slf4j
@Singleton
public class EnvironmentManager {
	private static final ResourcePath ENVIRONMENTS_PATH = Props
		.getFile("rlhd.environments-path", () -> path(EnvironmentManager.class, "environments.json"));

	@Inject
	private Client client;

	@Inject
	private ClientThread clientThread;

	@Inject
	private HdPlugin plugin;

	@Inject
	private HdPluginConfig config;

	private static final float TRANSITION_DURATION = 3; // seconds
	// distance in tiles to skip transition (e.g. entering cave, teleporting)
	// walking across a loading line causes a movement of 40-41 tiles
	private static final int SKIP_TRANSITION_DISTANCE = 41;

	// when the current transition began, relative to plugin startup
	private boolean transitionComplete = true;
	private double transitionStartTime = 0;
	private int[] previousPosition = new int[3];

	private float[] startFogColor = new float[] { 0, 0, 0 };
	public float[] currentFogColor = new float[] { 0, 0, 0 };
	private float[] targetFogColor = new float[] { 0, 0, 0 };

	private float[] startWaterColor = new float[] { 0, 0, 0 };
	public float[] currentWaterColor = new float[] { 0, 0, 0 };
	private float[] targetWaterColor = new float[] { 0, 0, 0 };

	private float startFogDepth = 0;
	public float currentFogDepth = 0;
	private float targetFogDepth = 0;

	private float startAmbientStrength = 0f;
	public float currentAmbientStrength = 0f;
	private float targetAmbientStrength = 0f;

	private float[] startAmbientColor = new float[] { 0, 0, 0 };
	public float[] currentAmbientColor = new float[] { 0, 0, 0 };
	private float[] targetAmbientColor = new float[] { 0, 0, 0 };

	private float startDirectionalStrength = 0f;
	public float currentDirectionalStrength = 0f;
	private float targetDirectionalStrength = 0f;

	private float[] startUnderwaterCausticsColor = new float[] { 0, 0, 0 };
	public float[] currentUnderwaterCausticsColor = new float[] { 0, 0, 0 };
	private float[] targetUnderwaterCausticsColor = new float[] { 0, 0, 0 };

	private float startUnderwaterCausticsStrength = 1f;
	public float currentUnderwaterCausticsStrength = 1f;
	private float targetUnderwaterCausticsStrength = 1f;

	private float[] startDirectionalColor = new float[] { 0, 0, 0 };
	public float[] currentDirectionalColor = new float[] { 0, 0, 0 };
	private float[] targetDirectionalColor = new float[] { 0, 0, 0 };

	private float startUnderglowStrength = 0f;
	public float currentUnderglowStrength = 0f;
	private float targetUnderglowStrength = 0f;

	private float[] startUnderglowColor = new float[] { 0, 0, 0 };
	public float[] currentUnderglowColor = new float[] { 0, 0, 0 };
	private float[] targetUnderglowColor = new float[] { 0, 0, 0 };

	private float startGroundFogStart = 0f;
	public float currentGroundFogStart = 0f;
	private float targetGroundFogStart = 0f;

	private float startGroundFogEnd = 0f;
	public float currentGroundFogEnd = 0f;
	private float targetGroundFogEnd = 0f;

	private float startGroundFogOpacity = 0f;
	public float currentGroundFogOpacity = 0f;
	private float targetGroundFogOpacity = 0f;

	private final float[] startSunAngles = { 0, 0 };
	public final float[] currentSunAngles = { 0, 0 };
	private final float[] targetSunAngles = { 0, 0 };

	private float startWindAngle = 0f;
	public float currentWindAngle = 0f;
	private float targetWindAngle = 0f;

	private float startWindSpeed = 0f;
	public float currentWindSpeed = 0f;
	private float targetWindSpeed = 0f;

	private float startWindStrength = 0f;
	public float currentWindStrength = 0f;
	private float targetWindStrength = 0f;

	private float startWindCeiling = 0f;
	public float currentWindCeiling = 0f;
	private float targetWindCeiling = 0f;

	private boolean lightningEnabled = false;
	private boolean forceNextTransition = false;

	private Environment[] environments;
	private FileWatcher.UnregisterCallback fileWatcher;

	@Nonnull
	private Environment currentEnvironment = Environment.NONE;

	public void startUp() {
		fileWatcher = ENVIRONMENTS_PATH.watch((path, first) -> {
			try {
				environments = path.loadJson(plugin.getGson(), Environment[].class);
				if (environments == null)
					throw new IOException("Empty or invalid: " + path);
				log.debug("Loaded {} environments", environments.length);

				HashMap<String, Environment> map = new HashMap<>();
				for (var env : environments)
					if (env.key != null)
						map.put(env.key, env);

				Environment.OVERWORLD = map.getOrDefault("OVERWORLD", Environment.DEFAULT);
				Environment.AUTUMN = map.getOrDefault("AUTUMN", Environment.DEFAULT);
				Environment.WINTER = map.getOrDefault("WINTER", Environment.DEFAULT);

				for (var env : environments)
					env.normalize();

				clientThread.invoke(() -> {
					// Force instant transition during development
					if (!first)
						reset();

					if (client.getGameState().getState() >= GameState.LOGGED_IN.getState() && plugin.getSceneContext() != null)
						loadSceneEnvironments(plugin.getSceneContext());
				});
			} catch (IOException ex) {
				log.error("Failed to load environments:", ex);
			}
		});
	}

	public void shutDown() {
		if (fileWatcher != null)
			fileWatcher.unregister();
		fileWatcher = null;
		environments = null;
		reset();
	}

	public void reset() {
		currentEnvironment = Environment.NONE;
		forceNextTransition = false;
	}

	public void triggerTransition() {
		forceNextTransition = true;
	}

	/**
	 * Updates variables used in transition effects
	 *
	 * @param sceneContext to possible environments from
	 */
	public void update(SceneContext sceneContext) {
		assert client.isClientThread();

		int[] focalPoint = sceneContext.localToWorld(
			plugin.cameraFocalPoint[0],
			plugin.cameraFocalPoint[1],
			client.getPlane()
		);

		// skip the transitional fade if the player has moved too far
		// since the previous frame. results in an instant transition when
		// teleporting, entering dungeons, etc.
		int tileChange = (int) max(abs(subtract(vec(focalPoint), vec(previousPosition))));
		previousPosition = focalPoint;

		boolean skipTransition = tileChange >= SKIP_TRANSITION_DISTANCE;
		for (var environment : sceneContext.environments) {
			if (environment.area.containsPoint(focalPoint)) {
				changeEnvironment(environment, skipTransition);
				break;
			}
		}

		updateTargetSkyColor(); // Update every frame, since other plugins may control it

		if (transitionComplete) {
			// Always write fog and water color, since they're affected by lightning
			currentFogColor = targetFogColor;
			currentWaterColor = targetWaterColor;
		} else {
			// interpolate between start and target values
			float t = smoothstep(0, 1, (float) (plugin.elapsedTime - transitionStartTime) / TRANSITION_DURATION);
			if (t >= 1)
				transitionComplete = true;
			currentFogColor = mix(startFogColor, targetFogColor, t);
			currentWaterColor = mix(startWaterColor, targetWaterColor, t);
			currentFogDepth = mix(startFogDepth, targetFogDepth, t);
			currentAmbientStrength = mix(startAmbientStrength, targetAmbientStrength, t);
			currentAmbientColor = mix(startAmbientColor, targetAmbientColor, t);
			currentDirectionalStrength = mix(startDirectionalStrength, targetDirectionalStrength, t);
			currentDirectionalColor = mix(startDirectionalColor, targetDirectionalColor, t);
			currentUnderglowStrength = mix(startUnderglowStrength, targetUnderglowStrength, t);
			currentUnderglowColor = mix(startUnderglowColor, targetUnderglowColor, t);
			currentGroundFogStart = mix(startGroundFogStart, targetGroundFogStart, t);
			currentGroundFogEnd = mix(startGroundFogEnd, targetGroundFogEnd, t);
			currentGroundFogOpacity = mix(startGroundFogOpacity, targetGroundFogOpacity, t);
			for (int i = 0; i < 2; i++)
				currentSunAngles[i] = mix(startSunAngles[i], targetSunAngles[i], t);
			currentUnderwaterCausticsColor = mix(startUnderwaterCausticsColor, targetUnderwaterCausticsColor, t);
			currentUnderwaterCausticsStrength = mix(startUnderwaterCausticsStrength, targetUnderwaterCausticsStrength, t);
			currentWindAngle = mix(startWindAngle, targetWindAngle, t);
			currentWindSpeed = mix(startWindSpeed, targetWindSpeed, t);
			currentWindStrength = mix(startWindStrength, targetWindStrength, t);
			currentWindCeiling = mix(startWindCeiling, targetWindCeiling, t);
		}

		updateLightning();
	}

	/**
	 * Updates variables used in transition effects
	 *
	 * @param newEnvironment the new environment to transition to
	 * @param skipTransition whether the transition should be done instantly
	 */
	private void changeEnvironment(Environment newEnvironment, boolean skipTransition) {
		// Skip changing the environment unless the transition is forced, since reapplying
		// the overworld environment is required when switching between seasonal themes
		if (currentEnvironment == newEnvironment && !forceNextTransition)
			return;

		if (currentEnvironment == Environment.NONE) {
			skipTransition = true;
		} else if (forceNextTransition) {
			forceNextTransition = false;
			skipTransition = false;
		}

		if (currentEnvironment.instantTransition || newEnvironment.instantTransition)
			skipTransition = true;

		log.debug("changing environment from {} to {} (instant: {})", currentEnvironment, newEnvironment, skipTransition);
		currentEnvironment = newEnvironment;
		transitionComplete = false;
		transitionStartTime = plugin.elapsedTime - (skipTransition ? TRANSITION_DURATION : 0);

		// Start transitioning from the current values
		startFogColor = currentFogColor;
		startWaterColor = currentWaterColor;
		startFogDepth = currentFogDepth;
		startAmbientStrength = currentAmbientStrength;
		startAmbientColor = currentAmbientColor;
		startDirectionalStrength = currentDirectionalStrength;
		startDirectionalColor = currentDirectionalColor;
		startUnderglowStrength = currentUnderglowStrength;
		startUnderglowColor = currentUnderglowColor;
		startGroundFogStart = currentGroundFogStart;
		startGroundFogEnd = currentGroundFogEnd;
		startGroundFogOpacity = currentGroundFogOpacity;
		startUnderwaterCausticsColor = currentUnderwaterCausticsColor;
		startUnderwaterCausticsStrength = currentUnderwaterCausticsStrength;
		startWindAngle = currentWindAngle;
		startWindSpeed = currentWindSpeed;
		startWindStrength = currentWindStrength;
		startWindCeiling = currentWindCeiling;
		for (int i = 0; i < 2; i++)
			startSunAngles[i] = mod(currentSunAngles[i], TWO_PI);

		updateTargetSkyColor();

		var env = getCurrentEnvironment();
		targetFogDepth = env.fogDepth;
		targetGroundFogStart = env.groundFogStart;
		targetGroundFogEnd = env.groundFogEnd;
		targetGroundFogOpacity = env.groundFogOpacity;
		lightningEnabled = env.lightningEffects;

		var overworldEnv = getOverworldEnvironment();
		float[] sunAngles = env.sunAngles;
		if (sunAngles == null)
			sunAngles = Objects.requireNonNullElse(overworldEnv.sunAngles, Environment.DEFAULT_SUN_ANGLES);
		copyTo(targetSunAngles, sunAngles);

		if (!config.atmosphericLighting() && !env.force)
			env = overworldEnv;
		targetAmbientStrength = env.ambientStrength;
		targetAmbientColor = env.ambientColor;
		targetDirectionalStrength = env.directionalStrength;
		targetDirectionalColor = env.directionalColor;
		targetUnderglowStrength = env.underglowStrength;
		targetUnderglowColor = env.underglowColor;
		targetUnderwaterCausticsColor = env.waterCausticsColor;
		targetUnderwaterCausticsStrength = env.waterCausticsStrength;
		targetWindAngle = env.windAngle;
		targetWindSpeed = env.windSpeed;
		targetWindStrength = env.windStrength;
		targetWindCeiling = env.windCeiling;

		// Prevent transitions from taking the long way around
		for (int i = 0; i < 2; i++) {
			float diff = startSunAngles[i] - targetSunAngles[i];
			if (abs(diff) > PI)
				targetSunAngles[i] += TWO_PI * sign(diff);
		}
	}

	public void updateTargetSkyColor() {
		Environment env = getCurrentEnvironment();

		if (env.fogColor == null || env.allowSkyOverride && config.overrideSky()) {
			DefaultSkyColor sky = config.defaultSkyColor();
			targetFogColor = sky.getRgb(client);
			if (sky == DefaultSkyColor.OSRS)
				sky = DefaultSkyColor.DEFAULT;
			targetWaterColor = sky.getRgb(client);
		} else {
			targetFogColor = targetWaterColor = env.fogColor;
		}

		// Override with decoupled water/sky color if present
		if (env.waterColor != null) {
			targetWaterColor = env.waterColor;
		} else if (config.decoupleSkyAndWaterColor()) {
			targetWaterColor = DefaultSkyColor.DEFAULT.getRgb(client);
		}
	}

	/**
	 * Figures out which Areas exist in the current scene and
	 * adds them to lists for easy access.
	 */
	public void loadSceneEnvironments(SceneContext sceneContext) {
		log.debug("Loading environments for scene: {}", sceneContext.sceneBounds);

		sceneContext.environments.clear();
		for (var environment : environments) {
			if (sceneContext.sceneBounds.intersects(environment.area.aabbs)) {
				log.debug("Added environment: {}", environment);
				sceneContext.environments.add(environment);
			}
		}

		// Fall back to the default environment
		sceneContext.environments.add(Environment.DEFAULT);
	}

	/* lightning */
	private static final float[] LIGHTNING_COLOR = new float[]{.25f, .25f, .25f};
	private static final float NEW_LIGHTNING_BRIGHTNESS = 7f;
	private static final float LIGHTNING_FADE_SPEED = 80f; // brightness units per second
	private static final float MIN_LIGHTNING_INTERVAL = 5.5f;
	private static final float MAX_LIGHTNING_INTERVAL = 17f;
	private static final float QUICK_LIGHTNING_CHANCE = .5f;
	private static final float MIN_QUICK_LIGHTNING_INTERVAL = .04f;
	private static final float MAX_QUICK_LIGHTNING_INTERVAL = .15f;

	@Getter
	private float lightningBrightness = 0f;
	private double nextLightningTime = -1;

	/**
	 * Updates lightning variables and sets water reflection and sky
	 * colors during lightning flashes.
	 */
	void updateLightning() {
		if (lightningBrightness > 0) {
			float brightnessChange = plugin.deltaTime * LIGHTNING_FADE_SPEED;
			lightningBrightness = max(lightningBrightness - brightnessChange, 0);
		}

		if (nextLightningTime == -1) {
			generateNextLightningTime();
			return;
		}
		if (plugin.elapsedTime > nextLightningTime) {
			lightningBrightness = NEW_LIGHTNING_BRIGHTNESS;
			generateNextLightningTime();
		}

		if (lightningEnabled && config.flashingEffects()) {
			float t = clamp(lightningBrightness, 0, 1);
			currentFogColor = mix(currentFogColor, LIGHTNING_COLOR, t);
			currentWaterColor = mix(currentWaterColor, LIGHTNING_COLOR, t);
		} else {
			lightningBrightness = 0f;
		}
	}

	/**
	 * Determines when the next lighting strike will occur.
	 * Produces a short interval for a quick successive strike
	 * or a longer interval at the end of a cluster.
	 */
	void generateNextLightningTime() {
		nextLightningTime = plugin.elapsedTime;
		if (Math.random() <= QUICK_LIGHTNING_CHANCE) {
			// chain together lighting strikes in quick succession
			nextLightningTime += mix(MIN_QUICK_LIGHTNING_INTERVAL, MAX_QUICK_LIGHTNING_INTERVAL, RAND.nextFloat());
		} else {
			// cool-down period before a new lightning cluster
			nextLightningTime += mix(MIN_LIGHTNING_INTERVAL, MAX_LIGHTNING_INTERVAL, RAND.nextFloat());
		}
	}

	private Environment getCurrentEnvironment() {
		if (currentEnvironment == Environment.OVERWORLD)
			return getOverworldEnvironment();
		return currentEnvironment;
	}

	private Environment getOverworldEnvironment() {
		switch (plugin.configSeasonalTheme) {
			case AUTUMN:
				return Environment.AUTUMN;
			case WINTER:
				return Environment.WINTER;
			default:
				return Environment.OVERWORLD;
		}
	}

	public boolean isUnderwater() {
		return currentEnvironment.isUnderwater;
	}
}

/*
 * Copyright (c) 2018, Adam <Adam@sigterm.info>
 * Copyright (c) 2021, 117 <https://twitter.com/117scape>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package rs117.hd.scene;

import com.google.common.base.Stopwatch;
import java.util.Arrays;
import java.util.stream.Collectors;
import javax.annotation.Nonnull;
import javax.annotation.Nullable;
import javax.inject.Inject;
import javax.inject.Singleton;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.*;
import rs117.hd.HdPlugin;
import rs117.hd.HdPluginConfig;
import rs117.hd.model.ModelPusher;
import rs117.hd.scene.areas.Area;
import rs117.hd.scene.ground_materials.GroundMaterial;
import rs117.hd.scene.materials.Material;
import rs117.hd.scene.model_overrides.ModelOverride;
import rs117.hd.scene.model_overrides.UvType;
import rs117.hd.scene.tile_overrides.TileOverride;
import rs117.hd.scene.water_types.WaterType;
import rs117.hd.utils.HDUtils;
import rs117.hd.utils.ModelHash;

import static net.runelite.api.Constants.*;
import static net.runelite.api.Constants.SCENE_SIZE;
import static net.runelite.api.Perspective.*;
import static rs117.hd.HdPlugin.NORMAL_SIZE;
import static rs117.hd.HdPlugin.UV_SIZE;
import static rs117.hd.HdPlugin.VERTEX_SIZE;
import static rs117.hd.scene.SceneContext.SCENE_OFFSET;
import static rs117.hd.scene.tile_overrides.TileOverride.NONE;
import static rs117.hd.scene.tile_overrides.TileOverride.OVERLAY_FLAG;
import static rs117.hd.utils.HDUtils.HIDDEN_HSL;
import static rs117.hd.utils.MathUtils.*;

@Slf4j
@Singleton
@SuppressWarnings("UnnecessaryLocalVariable")
public class SceneUploader {
	public static final int SCENE_ID_MASK = 0xFFFF;
	public static final int EXCLUDED_FROM_SCENE_BUFFER = 0xFFFFFFFF;

	private static final float[] UP_NORMAL = { 0, -1, 0 };

	@Inject
	private Client client;

	@Inject
	private HdPlugin plugin;

	@Inject
	private HdPluginConfig config;

	@Inject
	private AreaManager areaManager;

	@Inject
	private MaterialManager materialManager;

	@Inject
	private TileOverrideManager tileOverrideManager;

	@Inject
	private ModelOverrideManager modelOverrideManager;

	@Inject
	public ProceduralGenerator proceduralGenerator;

	@Inject
	private ModelPusher modelPusher;

	public void upload(SceneContext sceneContext) {
		Stopwatch stopwatch = Stopwatch.createStarted();

		var scene = sceneContext.scene;
		sceneContext.enableAreaHiding =
			config.hideUnrelatedAreas() &&
			sceneContext.sceneBase != null &&
			!sceneContext.forceDisableAreaHiding;
		sceneContext.fillGaps = config.fillGapsInTerrain();

		if (sceneContext.enableAreaHiding) {
			sceneContext.possibleAreas = Arrays
				.stream(areaManager.areasWithAreaHiding)
				.filter(area -> sceneContext.sceneBounds.intersects(area.aabbs))
				.toArray(Area[]::new);

			if (log.isDebugEnabled() && sceneContext.possibleAreas.length > 0) {
				log.debug(
					"Hiding areas outside of {}",
					Arrays.stream(sceneContext.possibleAreas)
						.distinct()
						.map(Area::toString)
						.collect(Collectors.joining(", "))
				);
			}
		}

		// The scene can be prepared early when loaded synchronously
		if (client.isClientThread())
			prepareBeforeSwap(sceneContext);

		sceneContext.staticCustomTilesOffset = sceneContext.staticVertexCount;
		var tiles = scene.getExtendedTiles();
		for (int z = 0; z < MAX_Z; ++z) {
			for (int x = 0; x < EXTENDED_SCENE_SIZE; ++x) {
				for (int y = 0; y < EXTENDED_SCENE_SIZE; ++y) {
					Tile tile = tiles[z][x][y];
					if (tile != null)
						upload(sceneContext, tile, x, y);
				}
			}
		}
		sceneContext.staticCustomTilesVertexCount = sceneContext.staticVertexCount - sceneContext.staticCustomTilesOffset;

		stopwatch.stop();
		log.debug(
			"Scene upload time: {}, unique models: {}, size: {} MB",
			stopwatch,
			sceneContext.uniqueModels,
			String.format(
				"%.2f",
				(
					sceneContext.getVertexOffset() * 4L * (VERTEX_SIZE + NORMAL_SIZE) +
					sceneContext.getUvOffset() * 4L * UV_SIZE
				) / 1e6
			)
		);
	}

	public void prepareBeforeSwap(SceneContext sceneContext) {
		assert client.isClientThread();
		if (sceneContext.isPrepared)
			return;
		sceneContext.isPrepared = true;

		// At this point, the player's position & plane has been updated, so area hiding can be set up
		if (sceneContext.enableAreaHiding)
			removeTilesOutsideCurrentArea(sceneContext);

		// Gaps need to be filled right before scene swap, since map regions aren't updated earlier
		if (sceneContext.fillGaps) {
			sceneContext.staticGapFillerTilesOffset = sceneContext.staticVertexCount;
			fillGaps(sceneContext);
			sceneContext.staticGapFillerTilesVertexCount = sceneContext.staticVertexCount - sceneContext.staticGapFillerTilesOffset;
		}
	}

	public void updatePlayerArea(SceneContext sceneContext) {
		if (!sceneContext.enableAreaHiding) {
			sceneContext.currentArea = null;
			return;
		}

		assert sceneContext.sceneBase != null;
		var lp = client.getLocalPlayer().getLocalLocation();
		int[] worldPos = {
			sceneContext.sceneBase[0] + lp.getSceneX(),
			sceneContext.sceneBase[1] + lp.getSceneY(),
			sceneContext.sceneBase[2] + client.getPlane()
		};

		if (sceneContext.currentArea == null || !sceneContext.currentArea.containsPoint(false, worldPos)) {
			sceneContext.currentArea = null;
			for (var area : sceneContext.possibleAreas) {
				if (area.containsPoint(false, worldPos)) {
					sceneContext.currentArea = area;
					break;
				}
			}
		}
	}

	private void removeTilesOutsideCurrentArea(SceneContext sceneContext) {
		assert sceneContext.sceneBase != null;
		updatePlayerArea(sceneContext);
		if (sceneContext.currentArea == null)
			return;

		var tiles = sceneContext.scene.getExtendedTiles();
		int baseExX = sceneContext.sceneBase[0] - SCENE_OFFSET;
		int baseExY = sceneContext.sceneBase[1] - SCENE_OFFSET;
		int basePlane = sceneContext.sceneBase[2];
		for (int z = 0; z < MAX_Z; ++z) {
			for (int x = 0; x < EXTENDED_SCENE_SIZE; ++x) {
				for (int y = 0; y < EXTENDED_SCENE_SIZE; ++y) {
					Tile tile = tiles[z][x][y];
					if (tile == null)
						continue;

					if (!sceneContext.currentArea.containsPoint(baseExX + x, baseExY + y, basePlane + z))
						sceneContext.scene.removeTile(tile);
				}
			}
		}
	}

	private void fillGaps(SceneContext sceneContext) {
		if (sceneContext.sceneBase == null)
			return;

		var area = sceneContext.currentArea;
		if (area != null && !area.fillGaps)
			return;

		int sceneMin = -sceneContext.expandedMapLoadingChunks * CHUNK_SIZE;
		int sceneMax = SCENE_SIZE + sceneContext.expandedMapLoadingChunks * CHUNK_SIZE;
		int baseExX = sceneContext.sceneBase[0];
		int baseExY = sceneContext.sceneBase[1];
		int basePlane = sceneContext.sceneBase[2];
		Material blackMaterial = materialManager.getMaterial("BLACK");

		Tile[][][] extendedTiles = sceneContext.scene.getExtendedTiles();
		for (int tileZ = 0; tileZ < MAX_Z; ++tileZ) {
			for (int tileExX = 0; tileExX < EXTENDED_SCENE_SIZE; ++tileExX) {
				for (int tileExY = 0; tileExY < EXTENDED_SCENE_SIZE; ++tileExY) {
					if (area != null && !area.containsPoint(baseExX + tileExX, baseExY + tileExY, basePlane + tileZ))
						continue;

					int tileX = tileExX - SCENE_OFFSET;
					int tileY = tileExY - SCENE_OFFSET;
					Tile tile = extendedTiles[tileZ][tileExX][tileExY];

					SceneTilePaint paint;
					SceneTileModel model = null;
					int renderLevel = tileZ;
					if (tile != null) {
						renderLevel = tile.getRenderLevel();
						paint = tile.getSceneTilePaint();
						model = tile.getSceneTileModel();

						if (model == null) {
							boolean hasTilePaint = paint != null && paint.getNeColor() != HIDDEN_HSL;
							if (!hasTilePaint) {
								tile = tile.getBridge();
								if (tile != null) {
									renderLevel = tile.getRenderLevel();
									paint = tile.getSceneTilePaint();
									model = tile.getSceneTileModel();
									hasTilePaint = paint != null && paint.getNeColor() != HIDDEN_HSL;
								}
							}

							if (hasTilePaint)
								continue;
						}
					}

					int[] worldPoint = sceneContext.sceneToWorld(tileX, tileY, tileZ);
					boolean fillGaps =
						tileZ == 0 &&
						tileX > sceneMin &&
						tileY > sceneMin &&
						tileX < sceneMax - 1 &&
						tileY < sceneMax - 1 &&
						Area.OVERWORLD.containsPoint(worldPoint);

					if (fillGaps) {
						int tileRegionID = HDUtils.worldToRegionID(worldPoint);
						int[] regions = client.getMapRegions();

						fillGaps = false;
						for (int region : regions) {
							if (region == tileRegionID) {
								fillGaps = true;
								break;
							}
						}
					}

					if (fillGaps) {
						int vertexOffset = sceneContext.getVertexOffset();
						int uvOffset = sceneContext.getUvOffset();
						int vertexCount;

						if (model == null) {
							uploadCustomTile(sceneContext, tileExX, tileExY, renderLevel, blackMaterial);
							vertexCount = 6;
						} else {
							int[] worldPos = sceneContext.sceneToWorld(tileX, tileY, tileZ);
							int[] uploadedTileModelData = uploadHDTileModelSurface(sceneContext, tile, worldPos, model, true);
							vertexCount = uploadedTileModelData[0];
						}

						if (vertexCount > 0) {
							sceneContext.staticUnorderedModelBuffer
								.ensureCapacity(8)
								.getBuffer()
								.put(vertexOffset)
								.put(uvOffset)
								.put(vertexCount / 3)
								.put(sceneContext.staticVertexCount)
								.put(0)
								.put(tileX * LOCAL_TILE_SIZE)
								.put(0)
								.put(tileY * LOCAL_TILE_SIZE);
							sceneContext.staticVertexCount += vertexCount;
						}
					}
				}
			}
		}
	}

	private void uploadModel(SceneContext sceneContext, Tile tile, int uuid, Model model, int orientation) {
		// deduplicate hillskewed models
		if (model.getUnskewedModel() != null)
			model = model.getUnskewedModel();

		if (model.getSceneId() == EXCLUDED_FROM_SCENE_BUFFER)
			return;

		int[] worldPos = sceneContext.localToWorld(tile.getLocalLocation(), tile.getPlane());
		ModelOverride modelOverride = modelOverrideManager.getOverride(uuid, worldPos);
		int sceneId = modelOverride.hashCode() << 16 | sceneContext.id;

		// check if the model has already been uploaded
		if ((model.getSceneId() & SCENE_ID_MASK) == sceneContext.id) {
			// if the same model is being uploaded, but with a different model override,
			// exclude it from the scene buffer to avoid conflicts
			if (model.getSceneId() != sceneId)
				model.setSceneId(EXCLUDED_FROM_SCENE_BUFFER);
			return;
		}

		int vertexOffset = sceneContext.getVertexOffset();
		int uvOffset = sceneContext.getUvOffset();

		if (modelOverride.hide) {
			vertexOffset = -1;
		} else {
			modelPusher.pushModel(sceneContext, tile, uuid, model, modelOverride, orientation, false);
			if (sceneContext.modelPusherResults[1] == 0)
				uvOffset = -1;
		}

		model.setBufferOffset(vertexOffset);
		model.setUvBufferOffset(uvOffset);
		model.setSceneId(sceneId);
		++sceneContext.uniqueModels;
	}

	private void upload(SceneContext sceneContext, @Nonnull Tile tile, int tileExX, int tileExY) {
		Tile bridge = tile.getBridge();
		if (bridge != null)
			upload(sceneContext, bridge, tileExX, tileExY);

		int[] worldPos = sceneContext.localToWorld(tile.getLocalLocation(), tile.getPlane());
		var override = tileOverrideManager.getOverride(sceneContext, tile, worldPos);

		SceneTilePaint sceneTilePaint = tile.getSceneTilePaint();
		if (sceneTilePaint != null || override.forced) {
			sceneContext.filledTiles[tileExX][tileExY] |= (byte) (1 << tile.getPlane());

			boolean depthTested = override.depthTested ||
								  override.forced && (sceneTilePaint == null || sceneTilePaint.getNeColor() == HIDDEN_HSL);

			// Set offsets before pushing new data
			int vertexOffset = sceneContext.getVertexOffset();
			int uvOffset = sceneContext.getUvOffset();
			int[] uploadedTilePaintData = upload(sceneContext, tile, worldPos, override, sceneTilePaint);

			int vertexCount = uploadedTilePaintData[0];
			int uvCount = uploadedTilePaintData[1];

			// Opening the right-click menu causes the game to stop drawing hidden tiles, which prevents us from drawing underwater tiles
			// below the boats at Pest Control, or any other custom tile. To work around this, we can instead draw all hidden tiles at once
			// at the start of the frame. This currently means they will only draw correctly if they're always behind everything else.
			if (vertexCount > 0 && depthTested) {
				int tileX = tileExX - SCENE_OFFSET;
				int tileY = tileExY - SCENE_OFFSET;

				// Draw the tile at the start of each frame
				sceneContext.staticUnorderedModelBuffer
					.ensureCapacity(8)
					.getBuffer()
					.put(vertexOffset)
					.put(uvOffset)
					.put(vertexCount / 3)
					.put(sceneContext.staticVertexCount)
					.put(0)
					.put(tileX * LOCAL_TILE_SIZE)
					.put(0)
					.put(tileY * LOCAL_TILE_SIZE);
				sceneContext.staticVertexCount += vertexCount;

				// Since we're now drawing this tile at the beginning of the frame, remove its vertices from the draw callback
				vertexCount = 0;
				uvCount = 0;
			}

			if (uvCount <= 0)
				uvOffset = -1;

			if (sceneTilePaint != null) {
				sceneTilePaint.setBufferLen(vertexCount);
				sceneTilePaint.setBufferOffset(vertexOffset);
				sceneTilePaint.setUvBufferOffset(uvOffset);
			}
		}

		var sceneTileModel = tile.getSceneTileModel();
		if (sceneTileModel != null) {
			sceneContext.filledTiles[tileExX][tileExY] |= (byte) (1 << tile.getPlane());

			// Set offsets before pushing new data
			sceneTileModel.setBufferOffset(sceneContext.getVertexOffset());
			sceneTileModel.setUvBufferOffset(sceneContext.getUvOffset());
			int[] uploadedTileModelData = upload(sceneContext, tile, worldPos, sceneTileModel);

			final int bufferLength = uploadedTileModelData[0];
			final int uvBufferLength = uploadedTileModelData[1];
			final int underwaterTerrain = uploadedTileModelData[2];
			if (uvBufferLength <= 0)
				sceneTileModel.setUvBufferOffset(-1);
			// pack a boolean into the buffer length of tiles so we can tell
			// which tiles have procedurally-generated underwater terrain
			int packedBufferLength = bufferLength << 1 | underwaterTerrain;

			sceneTileModel.setBufferLen(packedBufferLength);
		}

		WallObject wallObject = tile.getWallObject();
		if (wallObject != null) {
			Renderable renderable1 = wallObject.getRenderable1();
			if (renderable1 instanceof Model) {
				uploadModel(
					sceneContext,
					tile,
					ModelHash.packUuid(ModelHash.TYPE_WALL_OBJECT, wallObject.getId()),
					(Model) renderable1,
					HDUtils.convertWallObjectOrientation(wallObject.getOrientationA())
				);
			}

			Renderable renderable2 = wallObject.getRenderable2();
			if (renderable2 instanceof Model) {
				uploadModel(
					sceneContext,
					tile,
					ModelHash.packUuid(ModelHash.TYPE_WALL_OBJECT, wallObject.getId()),
					(Model) renderable2,
					HDUtils.convertWallObjectOrientation(wallObject.getOrientationB())
				);
			}
		}

		GroundObject groundObject = tile.getGroundObject();
		if (groundObject != null) {
			Renderable renderable = groundObject.getRenderable();
			if (renderable instanceof Model) {
				uploadModel(
					sceneContext,
					tile,
					ModelHash.packUuid(ModelHash.TYPE_GROUND_OBJECT, groundObject.getId()),
					(Model) renderable,
					HDUtils.getModelPreOrientation(groundObject.getConfig())
				);
			}
		}

		DecorativeObject decorativeObject = tile.getDecorativeObject();
		if (decorativeObject != null) {
			Renderable renderable = decorativeObject.getRenderable();
			int orientation = HDUtils.getModelPreOrientation(decorativeObject.getConfig());
			if (renderable instanceof Model) {
				uploadModel(
					sceneContext,
					tile,
					ModelHash.packUuid(ModelHash.TYPE_DECORATIVE_OBJECT, decorativeObject.getId()),
					(Model) renderable,
					orientation
				);
			}

			Renderable renderable2 = decorativeObject.getRenderable2();
			if (renderable2 instanceof Model) {
				uploadModel(
					sceneContext,
					tile,
					ModelHash.packUuid(ModelHash.TYPE_DECORATIVE_OBJECT, decorativeObject.getId()),
					(Model) renderable2,
					orientation
				);
			}
		}

		GameObject[] gameObjects = tile.getGameObjects();
		for (GameObject gameObject : gameObjects) {
			if (gameObject == null)
				continue;

			Renderable renderable = gameObject.getRenderable();
			if (renderable instanceof Model) {
				uploadModel(sceneContext,
					tile,
					ModelHash.packUuid(ModelHash.TYPE_GAME_OBJECT, gameObject.getId()),
					(Model) gameObject.getRenderable(),
					HDUtils.getModelPreOrientation(gameObject.getConfig())
				);
			}
		}
	}

	private int[] upload(SceneContext sceneContext, Tile tile, int[] worldPos, TileOverride override, @Nullable SceneTilePaint paint) {
		int bufferLength = 0;
		int uvBufferLength = 0;
		int underwaterTerrain = 0;

		int[] bufferLengths;
		WaterType waterType = WaterType.NONE;
		if (paint != null)
			waterType = proceduralGenerator.seasonalWaterType(override, paint.getTexture());

		bufferLengths = uploadHDTilePaintUnderwater(sceneContext, tile, worldPos, waterType);
		bufferLength += bufferLengths[0];
		uvBufferLength += bufferLengths[1];
		underwaterTerrain += bufferLengths[2];

		bufferLengths = uploadHDTilePaintSurface(sceneContext, tile, worldPos, waterType, paint, override);
		bufferLength += bufferLengths[0];
		uvBufferLength += bufferLengths[1];
		underwaterTerrain += bufferLengths[2];

		return new int[] { bufferLength, uvBufferLength, underwaterTerrain };
	}

	private int[] uploadHDTilePaintSurface(
		SceneContext sceneContext,
		Tile tile,
		int[] worldPos,
		WaterType waterType,
		@Nullable SceneTilePaint paint,
		TileOverride override
	) {
		final Scene scene = sceneContext.scene;
		final Point tilePoint = tile.getSceneLocation();
		final int tileX = tilePoint.getX();
		final int tileY = tilePoint.getY();
		final int tileExX = tileX + SCENE_OFFSET;
		final int tileExY = tileY + SCENE_OFFSET;
		final int tileZ = tile.getRenderLevel();

		final int localX = 0;
		final int localY = 0;

		final int[][][] tileHeights = scene.getTileHeights();
		int swHeight = tileHeights[tileZ][tileExX][tileExY];
		int seHeight = tileHeights[tileZ][tileExX + 1][tileExY];
		int neHeight = tileHeights[tileZ][tileExX + 1][tileExY + 1];
		int nwHeight = tileHeights[tileZ][tileExX][tileExY + 1];

		int bufferLength = 0;
		int uvBufferLength = 0;
		int underwaterTerrain = 0;

		int localSwVertexX = localX;
		int localSwVertexY = localY;
		int localSeVertexX = localX + LOCAL_TILE_SIZE;
		int localSeVertexY = localY;
		int localNwVertexX = localX;
		int localNwVertexY = localY + LOCAL_TILE_SIZE;
		int localNeVertexX = localX + LOCAL_TILE_SIZE;
		int localNeVertexY = localY + LOCAL_TILE_SIZE;

		int[] vertexKeys = ProceduralGenerator.tileVertexKeys(scene, tile);
		int swVertexKey = vertexKeys[0];
		int seVertexKey = vertexKeys[1];
		int nwVertexKey = vertexKeys[2];
		int neVertexKey = vertexKeys[3];

		int uvOrientation = 0;
		float uvScale = 1;

		// Ignore certain tiles that aren't supposed to be visible,
		// but which we can still make a height-adjusted version of for underwater
		if ((paint != null && paint.getNeColor() != HIDDEN_HSL) || override.forced)
		{
			int swColor = 0;
			int seColor = 0;
			int neColor = 0;
			int nwColor = 0;
			int textureId = -1;

			if (paint != null) {
				swColor = paint.getSwColor();
				seColor = paint.getSeColor();
				neColor = paint.getNeColor();
				nwColor = paint.getNwColor();
				textureId = paint.getTexture();
			}

			boolean neVertexIsOverlay = false;
			boolean nwVertexIsOverlay = false;
			boolean seVertexIsOverlay = false;
			boolean swVertexIsOverlay = false;

			Material swMaterial = Material.NONE;
			Material seMaterial = Material.NONE;
			Material neMaterial = Material.NONE;
			Material nwMaterial = Material.NONE;

			float[] swNormals = UP_NORMAL;
			float[] seNormals = UP_NORMAL;
			float[] neNormals = UP_NORMAL;
			float[] nwNormals = UP_NORMAL;

			if (waterType == WaterType.NONE) {
				if (textureId != -1) {
					var material = materialManager.fromVanillaTexture(textureId);
					// Disable tile overrides for newly introduced vanilla textures
					if (material.isFallbackVanillaMaterial)
						override = NONE;
					swMaterial = seMaterial = neMaterial = nwMaterial = material;
				}

				swNormals = sceneContext.vertexTerrainNormals.getOrDefault(swVertexKey, swNormals);
				seNormals = sceneContext.vertexTerrainNormals.getOrDefault(seVertexKey, seNormals);
				neNormals = sceneContext.vertexTerrainNormals.getOrDefault(neVertexKey, neNormals);
				nwNormals = sceneContext.vertexTerrainNormals.getOrDefault(nwVertexKey, nwNormals);

				boolean useBlendedMaterialAndColor =
					plugin.configGroundBlending &&
					textureId == -1 &&
					!proceduralGenerator.useDefaultColor(tile, override);
				GroundMaterial groundMaterial = null;
				if (override != TileOverride.NONE) {
					groundMaterial = override.groundMaterial;
					uvOrientation = override.uvOrientation;
					uvScale = override.uvScale;
					if (!useBlendedMaterialAndColor) {
						swColor = override.modifyColor(swColor);
						seColor = override.modifyColor(seColor);
						nwColor = override.modifyColor(nwColor);
						neColor = override.modifyColor(neColor);
					}
					swHeight -= override.heightOffset;
					seHeight -= override.heightOffset;
					neHeight -= override.heightOffset;
					nwHeight -= override.heightOffset;
				} else if (textureId == -1) {
					// Fall back to the default ground material if the tile is untextured
					groundMaterial = override.groundMaterial;
				}

				if (useBlendedMaterialAndColor) {
					// get the vertices' colors and textures from hashmaps
					swColor = sceneContext.vertexTerrainColor.getOrDefault(swVertexKey, swColor);
					seColor = sceneContext.vertexTerrainColor.getOrDefault(seVertexKey, seColor);
					neColor = sceneContext.vertexTerrainColor.getOrDefault(neVertexKey, neColor);
					nwColor = sceneContext.vertexTerrainColor.getOrDefault(nwVertexKey, nwColor);

					if (plugin.configGroundTextures) {
						swMaterial = sceneContext.vertexTerrainTexture.getOrDefault(swVertexKey, swMaterial);
						seMaterial = sceneContext.vertexTerrainTexture.getOrDefault(seVertexKey, seMaterial);
						neMaterial = sceneContext.vertexTerrainTexture.getOrDefault(neVertexKey, neMaterial);
						nwMaterial = sceneContext.vertexTerrainTexture.getOrDefault(nwVertexKey, nwMaterial);
					}
				} else if (plugin.configGroundTextures && groundMaterial != null) {
					swMaterial = groundMaterial.getRandomMaterial(worldPos[0], worldPos[1], worldPos[2]);
					seMaterial = groundMaterial.getRandomMaterial(worldPos[0] + 1, worldPos[1], worldPos[2]);
					nwMaterial = groundMaterial.getRandomMaterial(worldPos[0], worldPos[1] + 1, worldPos[2]);
					neMaterial = groundMaterial.getRandomMaterial(worldPos[0] + 1, worldPos[1] + 1, worldPos[2]);
				}
			}
			else
			{
				// set colors for the shoreline to create a foam effect in the water shader

				swColor = seColor = nwColor = neColor = 127;

				if (sceneContext.vertexIsWater.containsKey(swVertexKey) && sceneContext.vertexIsLand.containsKey(swVertexKey))
					swColor = 0;
				if (sceneContext.vertexIsWater.containsKey(seVertexKey) && sceneContext.vertexIsLand.containsKey(seVertexKey))
					seColor = 0;
				if (sceneContext.vertexIsWater.containsKey(nwVertexKey) && sceneContext.vertexIsLand.containsKey(nwVertexKey))
					nwColor = 0;
				if (sceneContext.vertexIsWater.containsKey(neVertexKey) && sceneContext.vertexIsLand.containsKey(neVertexKey))
					neColor = 0;
			}

			if (sceneContext.vertexIsOverlay.containsKey(neVertexKey) && sceneContext.vertexIsUnderlay.containsKey(neVertexKey))
				neVertexIsOverlay = true;
			if (sceneContext.vertexIsOverlay.containsKey(nwVertexKey) && sceneContext.vertexIsUnderlay.containsKey(nwVertexKey))
				nwVertexIsOverlay = true;
			if (sceneContext.vertexIsOverlay.containsKey(seVertexKey) && sceneContext.vertexIsUnderlay.containsKey(seVertexKey))
				seVertexIsOverlay = true;
			if (sceneContext.vertexIsOverlay.containsKey(swVertexKey) && sceneContext.vertexIsUnderlay.containsKey(swVertexKey))
				swVertexIsOverlay = true;


			float terrainData = (float) packTerrainData(true, 0, waterType, tileZ);

			sceneContext.stagingBufferNormals.ensureCapacity(24);
			sceneContext.stagingBufferNormals.put(neNormals[0], neNormals[2], neNormals[1], terrainData);
			sceneContext.stagingBufferNormals.put(nwNormals[0], nwNormals[2], nwNormals[1], terrainData);
			sceneContext.stagingBufferNormals.put(seNormals[0], seNormals[2], seNormals[1], terrainData);

			sceneContext.stagingBufferNormals.put(swNormals[0], swNormals[2], swNormals[1], terrainData);
			sceneContext.stagingBufferNormals.put(seNormals[0], seNormals[2], seNormals[1], terrainData);
			sceneContext.stagingBufferNormals.put(nwNormals[0], nwNormals[2], nwNormals[1], terrainData);


			sceneContext.stagingBufferVertices.ensureCapacity(24);
			sceneContext.stagingBufferVertices.put((float) localNeVertexX, neHeight, localNeVertexY, neColor);
			sceneContext.stagingBufferVertices.put((float) localNwVertexX, nwHeight, localNwVertexY, nwColor);
			sceneContext.stagingBufferVertices.put((float) localSeVertexX, seHeight, localSeVertexY, seColor);

			sceneContext.stagingBufferVertices.put((float) localSwVertexX, swHeight, localSwVertexY, swColor);
			sceneContext.stagingBufferVertices.put((float) localSeVertexX, seHeight, localSeVertexY, seColor);
			sceneContext.stagingBufferVertices.put((float) localNwVertexX, nwHeight, localNwVertexY, nwColor);

			bufferLength += 6;


			int packedMaterialDataSW = swMaterial.packMaterialData(ModelOverride.NONE, UvType.GEOMETRY, swVertexIsOverlay);
			int packedMaterialDataSE = seMaterial.packMaterialData(ModelOverride.NONE, UvType.GEOMETRY, seVertexIsOverlay);
			int packedMaterialDataNW = nwMaterial.packMaterialData(ModelOverride.NONE, UvType.GEOMETRY, nwVertexIsOverlay);
			int packedMaterialDataNE = neMaterial.packMaterialData(ModelOverride.NONE, UvType.GEOMETRY, neVertexIsOverlay);

			float uvcos = -uvScale, uvsin = 0;
			if (uvOrientation % 2048 != 0) {
				float rad = -uvOrientation * JAU_TO_RAD;
				uvcos = cos(rad) * -uvScale;
				uvsin = sin(rad) * -uvScale;
			}
			float uvx = worldPos[0];
			float uvy = worldPos[1];
			float tmp = uvx;
			uvx = uvx * uvcos - uvy * uvsin;
			uvy = tmp * uvsin + uvy * uvcos;

			sceneContext.stagingBufferUvs.ensureCapacity(24);
			sceneContext.stagingBufferUvs.put(uvx, uvy, 0, packedMaterialDataNE);
			sceneContext.stagingBufferUvs.put(uvx - uvcos, uvy - uvsin, 0, packedMaterialDataNW);
			sceneContext.stagingBufferUvs.put(uvx + uvsin, uvy - uvcos, 0, packedMaterialDataSE);

			sceneContext.stagingBufferUvs.put(uvx - uvcos + uvsin, uvy - uvsin - uvcos, 0, packedMaterialDataSW);
			sceneContext.stagingBufferUvs.put(uvx + uvsin, uvy - uvcos, 0, packedMaterialDataSE);
			sceneContext.stagingBufferUvs.put(uvx - uvcos, uvy - uvsin, 0, packedMaterialDataNW);

			uvBufferLength += 6;
		}

		return new int[]{bufferLength, uvBufferLength, underwaterTerrain};
	}

	private int[] uploadHDTilePaintUnderwater(SceneContext sceneContext, Tile tile, int[] worldPos, WaterType waterType) {
		final Scene scene = sceneContext.scene;
		final Point tilePoint = tile.getSceneLocation();
		final int tileX = tilePoint.getX();
		final int tileY = tilePoint.getY();
		final int tileExX = tileX + SCENE_OFFSET;
		final int tileExY = tileY + SCENE_OFFSET;
		final int tileZ = tile.getRenderLevel();

		int baseX = scene.getBaseX();
		int baseY = scene.getBaseY();

		if (baseX >= 2816 && baseX <= 2970 && baseY <= 5375 && baseY >= 5220) {
			// fix for God Wars Dungeon's water rendering over zamorak bridge
			return new int[] { 0, 0, 0 };
		}

		final int[][][] tileHeights = scene.getTileHeights();
		int swHeight = tileHeights[tileZ][tileExX][tileExY];
		int seHeight = tileHeights[tileZ][tileExX + 1][tileExY];
		int neHeight = tileHeights[tileZ][tileExX + 1][tileExY + 1];
		int nwHeight = tileHeights[tileZ][tileExX][tileExY + 1];

		int bufferLength = 0;
		int uvBufferLength = 0;
		int underwaterTerrain = 0;

		int localSwVertexX = 0;
		int localSwVertexY = 0;
		int localSeVertexX = LOCAL_TILE_SIZE;
		int localSeVertexY = 0;
		int localNwVertexX = 0;
		int localNwVertexY = LOCAL_TILE_SIZE;
		int localNeVertexX = LOCAL_TILE_SIZE;
		int localNeVertexY = LOCAL_TILE_SIZE;

		int[] vertexKeys = ProceduralGenerator.tileVertexKeys(scene, tile);
		int swVertexKey = vertexKeys[0];
		int seVertexKey = vertexKeys[1];
		int nwVertexKey = vertexKeys[2];
		int neVertexKey = vertexKeys[3];

		if (sceneContext.tileIsWater[tileZ][tileExX][tileExY]) {
			// underwater terrain

			underwaterTerrain = 1;

			int swColor = 6676;
			int seColor = 6676;
			int neColor = 6676;
			int nwColor = 6676;

			int swDepth = sceneContext.vertexUnderwaterDepth.getOrDefault(swVertexKey, 0);
			int seDepth = sceneContext.vertexUnderwaterDepth.getOrDefault(seVertexKey, 0);
			int nwDepth = sceneContext.vertexUnderwaterDepth.getOrDefault(nwVertexKey, 0);
			int neDepth = sceneContext.vertexUnderwaterDepth.getOrDefault(neVertexKey, 0);

			float[] swNormals = sceneContext.vertexTerrainNormals.getOrDefault(swVertexKey, UP_NORMAL);
			float[] seNormals = sceneContext.vertexTerrainNormals.getOrDefault(seVertexKey, UP_NORMAL);
			float[] nwNormals = sceneContext.vertexTerrainNormals.getOrDefault(nwVertexKey, UP_NORMAL);
			float[] neNormals = sceneContext.vertexTerrainNormals.getOrDefault(neVertexKey, UP_NORMAL);

			Material swMaterial = Material.NONE;
			Material seMaterial = Material.NONE;
			Material nwMaterial = Material.NONE;
			Material neMaterial = Material.NONE;

			if (plugin.configGroundTextures)
			{
				GroundMaterial groundMaterial = GroundMaterial.UNDERWATER_GENERIC;
				swMaterial = groundMaterial.getRandomMaterial(worldPos[0], worldPos[1], worldPos[2]);
				seMaterial = groundMaterial.getRandomMaterial(worldPos[0] + 1, worldPos[1], worldPos[2]);
				nwMaterial = groundMaterial.getRandomMaterial(worldPos[0], worldPos[1] + 1, worldPos[2]);
				neMaterial = groundMaterial.getRandomMaterial(worldPos[0] + 1, worldPos[1] + 1, worldPos[2]);
			}

			float swTerrainData = (float) packTerrainData(true, max(1, swDepth), waterType, tileZ);
			float seTerrainData = (float) packTerrainData(true, max(1, seDepth), waterType, tileZ);
			float nwTerrainData = (float) packTerrainData(true, max(1, nwDepth), waterType, tileZ);
			float neTerrainData = (float) packTerrainData(true, max(1, neDepth), waterType, tileZ);

			sceneContext.stagingBufferNormals.ensureCapacity(24);
			sceneContext.stagingBufferNormals.put(neNormals[0], neNormals[2], neNormals[1], neTerrainData);
			sceneContext.stagingBufferNormals.put(nwNormals[0], nwNormals[2], nwNormals[1], nwTerrainData);
			sceneContext.stagingBufferNormals.put(seNormals[0], seNormals[2], seNormals[1], seTerrainData);

			sceneContext.stagingBufferNormals.put(swNormals[0], swNormals[2], swNormals[1], swTerrainData);
			sceneContext.stagingBufferNormals.put(seNormals[0], seNormals[2], seNormals[1], seTerrainData);
			sceneContext.stagingBufferNormals.put(nwNormals[0], nwNormals[2], nwNormals[1], nwTerrainData);

			sceneContext.stagingBufferVertices.ensureCapacity(24);
			sceneContext.stagingBufferVertices.put((float) localNeVertexX, neHeight + neDepth, localNeVertexY, neColor);
			sceneContext.stagingBufferVertices.put((float) localNwVertexX, nwHeight + nwDepth, localNwVertexY, nwColor);
			sceneContext.stagingBufferVertices.put((float) localSeVertexX, seHeight + seDepth, localSeVertexY, seColor);

			sceneContext.stagingBufferVertices.put((float) localSwVertexX, swHeight + swDepth, localSwVertexY, swColor);
			sceneContext.stagingBufferVertices.put((float) localSeVertexX, seHeight + seDepth, localSeVertexY, seColor);
			sceneContext.stagingBufferVertices.put((float) localNwVertexX, nwHeight + nwDepth, localNwVertexY, nwColor);

			bufferLength += 6;

			int packedMaterialDataSW = swMaterial.packMaterialData(ModelOverride.NONE, UvType.GEOMETRY, false);
			int packedMaterialDataSE = seMaterial.packMaterialData(ModelOverride.NONE, UvType.GEOMETRY, false);
			int packedMaterialDataNW = nwMaterial.packMaterialData(ModelOverride.NONE, UvType.GEOMETRY, false);
			int packedMaterialDataNE = neMaterial.packMaterialData(ModelOverride.NONE, UvType.GEOMETRY, false);

			sceneContext.stagingBufferUvs.ensureCapacity(24);
			sceneContext.stagingBufferUvs.put(0, 0, 0, packedMaterialDataNE);
			sceneContext.stagingBufferUvs.put(1, 0, 0, packedMaterialDataNW);
			sceneContext.stagingBufferUvs.put(0, 1, 0, packedMaterialDataSE);

			sceneContext.stagingBufferUvs.put(1, 1, 0, packedMaterialDataSW);
			sceneContext.stagingBufferUvs.put(0, 1, 0, packedMaterialDataSE);
			sceneContext.stagingBufferUvs.put(1, 0, 0, packedMaterialDataNW);

			uvBufferLength += 6;
		}

		return new int[]{bufferLength, uvBufferLength, underwaterTerrain};
	}

	private int[] upload(SceneContext sceneContext, Tile tile, int[] worldPos, SceneTileModel sceneTileModel)
	{
		int bufferLength = 0;
		int uvBufferLength = 0;
		int underwaterTerrain = 0;

		int[] bufferLengths;

		bufferLengths = uploadHDTileModelSurface(sceneContext, tile, worldPos, sceneTileModel, false);
		bufferLength += bufferLengths[0];
		uvBufferLength += bufferLengths[1];
		underwaterTerrain += bufferLengths[2];

		bufferLengths = uploadHDTileModelUnderwater(sceneContext, tile, worldPos, sceneTileModel);
		assert bufferLengths[0] == bufferLength || bufferLengths[0] == 0;
		bufferLength += bufferLengths[0];
		uvBufferLength += bufferLengths[1];
		underwaterTerrain += bufferLengths[2];

		return new int[]{bufferLength, uvBufferLength, underwaterTerrain};
	}

	private int[] uploadHDTileModelSurface(SceneContext sceneContext, Tile tile, int[] worldPos, SceneTileModel model, boolean fillGaps) {
		final Scene scene = sceneContext.scene;
		final Point tilePoint = tile.getSceneLocation();
		final int tileX = tilePoint.getX();
		final int tileY = tilePoint.getY();
		final int tileExX = tileX + SCENE_OFFSET;
		final int tileExY = tileY + SCENE_OFFSET;
		final int tileZ = tile.getRenderLevel();

		if (sceneContext.skipTile[tileZ][tileExX][tileExY])
			return new int[3];

		int bufferLength = 0;
		int uvBufferLength = 0;
		int underwaterTerrain = 0;

		final int[] faceColorA = model.getTriangleColorA();
		final int[] faceColorB = model.getTriangleColorB();
		final int[] faceColorC = model.getTriangleColorC();
		final int[] faceTextures = model.getTriangleTextureId();
		final int faceCount = model.getFaceX().length;

		int overlayId = OVERLAY_FLAG | scene.getOverlayIds()[tileZ][tileExX][tileExY];
		int underlayId = scene.getUnderlayIds()[tileZ][tileExX][tileExY];
		var overlayOverride = tileOverrideManager.getOverride(sceneContext, tile, worldPos, overlayId);
		var underlayOverride = tileOverrideManager.getOverride(sceneContext, tile, worldPos, underlayId);

		for (int face = 0; face < faceCount; ++face) {
			int colorA = faceColorA[face];
			int colorB = faceColorB[face];
			int colorC = faceColorC[face];

			int[][] localVertices = ProceduralGenerator.faceLocalVertices(tile, face);

			int[] vertexKeys = ProceduralGenerator.faceVertexKeys(tile, face);
			int vertexKeyA = vertexKeys[0];
			int vertexKeyB = vertexKeys[1];
			int vertexKeyC = vertexKeys[2];

			boolean vertexAIsOverlay = false;
			boolean vertexBIsOverlay = false;
			boolean vertexCIsOverlay = false;

			int textureId;
			Material materialA = Material.NONE;
			Material materialB = Material.NONE;
			Material materialC = Material.NONE;

			int uvOrientation = 0;
			float uvScale = 1;

			float[] normalsA = UP_NORMAL;
			float[] normalsB = UP_NORMAL;
			float[] normalsC = UP_NORMAL;

			WaterType waterType = WaterType.NONE;

			boolean isHidden = colorA == HIDDEN_HSL;
			if (fillGaps) {
				if (!isHidden)
					continue;
				colorA = colorB = colorC = 0;
			} else {
				boolean isOverlay = ProceduralGenerator.isOverlayFace(tile, face);
				var override = isOverlay ? overlayOverride : underlayOverride;
				if (isHidden && !override.forced)
					continue;

				textureId = faceTextures == null ? -1 : faceTextures[face];
				waterType = proceduralGenerator.seasonalWaterType(override, textureId);
				if (waterType == WaterType.NONE) {
					if (textureId != -1) {
						var material = materialManager.fromVanillaTexture(textureId);
						// Disable tile overrides for newly introduced vanilla textures
						if (material.isFallbackVanillaMaterial)
							override = NONE;
						materialA = materialB = materialC = material;
					}

					normalsA = sceneContext.vertexTerrainNormals.getOrDefault(vertexKeyA, normalsA);
					normalsB = sceneContext.vertexTerrainNormals.getOrDefault(vertexKeyB, normalsB);
					normalsC = sceneContext.vertexTerrainNormals.getOrDefault(vertexKeyC, normalsC);

					GroundMaterial groundMaterial = null;

					boolean useBlendedMaterialAndColor =
						plugin.configGroundBlending &&
						textureId == -1 &&
						!(isOverlay && proceduralGenerator.useDefaultColor(tile, override));
					if (override != TileOverride.NONE) {
						groundMaterial = override.groundMaterial;
						uvOrientation = override.uvOrientation;
						uvScale = override.uvScale;
						if (!useBlendedMaterialAndColor) {
							colorA = override.modifyColor(colorA);
							colorB = override.modifyColor(colorB);
							colorC = override.modifyColor(colorC);
						}
					} else if (textureId == -1) {
						// Fall back to the default ground material if the tile is untextured
						groundMaterial = override.groundMaterial;
					}

					if (useBlendedMaterialAndColor) {
						// get the vertices' colors and textures from hashmaps
						colorA = sceneContext.vertexTerrainColor.getOrDefault(vertexKeyA, colorA);
						colorB = sceneContext.vertexTerrainColor.getOrDefault(vertexKeyB, colorB);
						colorC = sceneContext.vertexTerrainColor.getOrDefault(vertexKeyC, colorC);

						if (plugin.configGroundTextures) {
							materialA = sceneContext.vertexTerrainTexture.getOrDefault(vertexKeyA, materialA);
							materialB = sceneContext.vertexTerrainTexture.getOrDefault(vertexKeyB, materialB);
							materialC = sceneContext.vertexTerrainTexture.getOrDefault(vertexKeyC, materialC);
						}
					} else if (plugin.configGroundTextures && groundMaterial != null) {
						materialA = groundMaterial.getRandomMaterial(
							worldPos[0] + (localVertices[0][0] >> LOCAL_COORD_BITS),
							worldPos[1] + (localVertices[0][1] >> LOCAL_COORD_BITS),
							worldPos[2]
						);
						materialB = groundMaterial.getRandomMaterial(
							worldPos[0] + (localVertices[1][0] >> LOCAL_COORD_BITS),
							worldPos[1] + (localVertices[1][1] >> LOCAL_COORD_BITS),
							worldPos[2]
						);
						materialC = groundMaterial.getRandomMaterial(
							worldPos[0] + (localVertices[2][0] >> LOCAL_COORD_BITS),
							worldPos[1] + (localVertices[2][1] >> LOCAL_COORD_BITS),
							worldPos[2]
						);
					}
				} else {
					// set colors for the shoreline to create a foam effect in the water shader
					textureId = -1;
					colorA = colorB = colorC = 127;
					if (sceneContext.vertexIsWater.containsKey(vertexKeyA) && sceneContext.vertexIsLand.containsKey(vertexKeyA))
						colorA = 0;
					if (sceneContext.vertexIsWater.containsKey(vertexKeyB) && sceneContext.vertexIsLand.containsKey(vertexKeyB))
						colorB = 0;
					if (sceneContext.vertexIsWater.containsKey(vertexKeyC) && sceneContext.vertexIsLand.containsKey(vertexKeyC))
						colorC = 0;
				}

				if (sceneContext.vertexIsOverlay.containsKey(vertexKeyA) && sceneContext.vertexIsUnderlay.containsKey(vertexKeyA))
					vertexAIsOverlay = true;
				if (sceneContext.vertexIsOverlay.containsKey(vertexKeyB) && sceneContext.vertexIsUnderlay.containsKey(vertexKeyB))
					vertexBIsOverlay = true;
				if (sceneContext.vertexIsOverlay.containsKey(vertexKeyC) && sceneContext.vertexIsUnderlay.containsKey(vertexKeyC))
					vertexCIsOverlay = true;

				for (int i = 0; i < 3; i++)
					localVertices[i][2] -= override.heightOffset;
			}

			float terrainData = (float) packTerrainData(true, 0, waterType, tileZ);

			sceneContext.stagingBufferNormals.ensureCapacity(12);
			sceneContext.stagingBufferNormals.put(normalsA[0], normalsA[2], normalsA[1], terrainData);
			sceneContext.stagingBufferNormals.put(normalsB[0], normalsB[2], normalsB[1], terrainData);
			sceneContext.stagingBufferNormals.put(normalsC[0], normalsC[2], normalsC[1], terrainData);

			sceneContext.stagingBufferVertices.ensureCapacity(12);
			sceneContext.stagingBufferVertices.put((float) localVertices[0][0], localVertices[0][2], localVertices[0][1], colorA);
			sceneContext.stagingBufferVertices.put((float) localVertices[1][0], localVertices[1][2], localVertices[1][1], colorB);
			sceneContext.stagingBufferVertices.put((float) localVertices[2][0], localVertices[2][2], localVertices[2][1], colorC);

			bufferLength += 3;

			int[] packedMaterialData = {
				materialA.packMaterialData(ModelOverride.NONE, UvType.GEOMETRY, vertexAIsOverlay),
				materialB.packMaterialData(ModelOverride.NONE, UvType.GEOMETRY, vertexBIsOverlay),
				materialC.packMaterialData(ModelOverride.NONE, UvType.GEOMETRY, vertexCIsOverlay)
			};

			float uvcos = -uvScale, uvsin = 0;
			if (uvOrientation % 2048 != 0) {
				float rad = -uvOrientation * JAU_TO_RAD;
				uvcos = cos(rad) * -uvScale;
				uvsin = sin(rad) * -uvScale;
			}

			sceneContext.stagingBufferUvs.ensureCapacity(12);
			for (int i = 0; i < 3; i++) {
				float uvx = worldPos[0] + localVertices[i][0] / 128f - 1;
				float uvy = worldPos[1] + localVertices[i][1] / 128f - 1;
				float tmp = uvx;
				uvx = uvx * uvcos - uvy * uvsin;
				uvy = tmp * uvsin + uvy * uvcos;

				sceneContext.stagingBufferUvs.put(uvx, uvy, 0, packedMaterialData[i]);
			}

			uvBufferLength += 3;
		}

		return new int[]{bufferLength, uvBufferLength, underwaterTerrain};
	}

	private int[] uploadHDTileModelUnderwater(SceneContext sceneContext, Tile tile, int[] worldPos, SceneTileModel model) {
		final Scene scene = sceneContext.scene;
		final Point tilePoint = tile.getSceneLocation();
		final int tileX = tilePoint.getX();
		final int tileY = tilePoint.getY();
		final int tileExX = tileX + SCENE_OFFSET;
		final int tileExY = tileY + SCENE_OFFSET;
		final int tileZ = tile.getRenderLevel();

		int bufferLength = 0;
		int uvBufferLength = 0;
		int underwaterTerrain = 0;

		if (sceneContext.skipTile[tileZ][tileExX][tileExY]) {
			return new int[] { bufferLength, uvBufferLength, underwaterTerrain };
		}

		final int[] faceColorA = model.getTriangleColorA();
		final int faceCount = model.getFaceX().length;
		final int[] faceTextures = model.getTriangleTextureId();

		int baseX = scene.getBaseX();
		int baseY = scene.getBaseY();

		if (baseX >= 2816 && baseX <= 2970 && baseY <= 5375 && baseY >= 5220) {
			// fix for God Wars Dungeon's water rendering over zamorak bridge
			return new int[] { bufferLength, uvBufferLength, underwaterTerrain };
		}

		if (sceneContext.tileIsWater[tileZ][tileExX][tileExY]) {
			underwaterTerrain = 1;

			int overlayId = OVERLAY_FLAG | scene.getOverlayIds()[tileZ][tileExX][tileExY];
			int underlayId = scene.getUnderlayIds()[tileZ][tileExX][tileExY];
			var overlayOverride = tileOverrideManager.getOverride(sceneContext, tile, worldPos, overlayId);
			var underlayOverride = tileOverrideManager.getOverride(sceneContext, tile, worldPos, underlayId);

			// underwater terrain
			for (int face = 0; face < faceCount; ++face) {
				int colorA = 6676;
				int colorB = 6676;
				int colorC = 6676;

				boolean isOverlay = ProceduralGenerator.isOverlayFace(tile, face);
				var override = isOverlay ? overlayOverride : underlayOverride;
				if (faceColorA[face] == HIDDEN_HSL && !override.forced)
					continue;

				int[][] localVertices = ProceduralGenerator.faceLocalVertices(tile, face);

				Material materialA = Material.NONE;
				Material materialB = Material.NONE;
				Material materialC = Material.NONE;

				int[] vertexKeys = ProceduralGenerator.faceVertexKeys(tile, face);
				int vertexKeyA = vertexKeys[0];
				int vertexKeyB = vertexKeys[1];
				int vertexKeyC = vertexKeys[2];

				int depthA = sceneContext.vertexUnderwaterDepth.getOrDefault(vertexKeyA, 0);
				int depthB = sceneContext.vertexUnderwaterDepth.getOrDefault(vertexKeyB, 0);
				int depthC = sceneContext.vertexUnderwaterDepth.getOrDefault(vertexKeyC, 0);

				if (plugin.configGroundTextures) {
					GroundMaterial groundMaterial = GroundMaterial.UNDERWATER_GENERIC;
					materialA = groundMaterial.getRandomMaterial(
						worldPos[0] + (localVertices[0][0] >> LOCAL_COORD_BITS),
						worldPos[1] + (localVertices[0][1] >> LOCAL_COORD_BITS),
						worldPos[2]
					);
					materialB = groundMaterial.getRandomMaterial(
						worldPos[0] + (localVertices[1][0] >> LOCAL_COORD_BITS),
						worldPos[1] + (localVertices[1][1] >> LOCAL_COORD_BITS),
						worldPos[2]
					);
					materialC = groundMaterial.getRandomMaterial(
						worldPos[0] + (localVertices[2][0] >> LOCAL_COORD_BITS),
						worldPos[1] + (localVertices[2][1] >> LOCAL_COORD_BITS),
						worldPos[2]
					);
				}

				float[] normalsA = sceneContext.vertexTerrainNormals.getOrDefault(vertexKeyA, UP_NORMAL);
				float[] normalsB = sceneContext.vertexTerrainNormals.getOrDefault(vertexKeyB, UP_NORMAL);
				float[] normalsC = sceneContext.vertexTerrainNormals.getOrDefault(vertexKeyC, UP_NORMAL);

				int textureId = faceTextures == null ? -1 : faceTextures[face];
				WaterType waterType = proceduralGenerator.seasonalWaterType(override, textureId);

				float aTerrainData = (float) packTerrainData(true, max(1, depthA), waterType, tileZ);
				float bTerrainData = (float) packTerrainData(true, max(1, depthB), waterType, tileZ);
				float cTerrainData = (float) packTerrainData(true, max(1, depthC), waterType, tileZ);

				sceneContext.stagingBufferNormals.ensureCapacity(12);
				sceneContext.stagingBufferNormals.put(normalsA[0], normalsA[2], normalsA[1], aTerrainData);
				sceneContext.stagingBufferNormals.put(normalsB[0], normalsB[2], normalsB[1], bTerrainData);
				sceneContext.stagingBufferNormals.put(normalsC[0], normalsC[2], normalsC[1], cTerrainData);

				sceneContext.stagingBufferVertices.ensureCapacity(12);
				sceneContext.stagingBufferVertices.put(
					(float) localVertices[0][0],
					localVertices[0][2] + depthA,
					localVertices[0][1],
					colorA
				);
				sceneContext.stagingBufferVertices.put(
					(float) localVertices[1][0],
					localVertices[1][2] + depthB,
					localVertices[1][1],
					colorB
				);
				sceneContext.stagingBufferVertices.put(
					(float) localVertices[2][0],
					localVertices[2][2] + depthC,
					localVertices[2][1],
					colorC
				);

				bufferLength += 3;

				int packedMaterialDataA = materialA.packMaterialData(ModelOverride.NONE, UvType.GEOMETRY, false);
				int packedMaterialDataB = materialB.packMaterialData(ModelOverride.NONE, UvType.GEOMETRY, false);
				int packedMaterialDataC = materialC.packMaterialData(ModelOverride.NONE, UvType.GEOMETRY, false);

				sceneContext.stagingBufferUvs.ensureCapacity(12);
				sceneContext.stagingBufferUvs.put(1 - localVertices[0][0] / 128f, 1 - localVertices[0][1] / 128f, 0, packedMaterialDataA);
				sceneContext.stagingBufferUvs.put(1 - localVertices[1][0] / 128f, 1 - localVertices[1][1] / 128f, 0, packedMaterialDataB);
				sceneContext.stagingBufferUvs.put(1 - localVertices[2][0] / 128f, 1 - localVertices[2][1] / 128f, 0, packedMaterialDataC);

				uvBufferLength += 3;
			}
		}

		return new int[] { bufferLength, uvBufferLength, underwaterTerrain };
	}

	private void uploadCustomTile(SceneContext sceneContext, int tileExX, int tileExY, int tileZ, Material material) {
		final Scene scene = sceneContext.scene;

		int color = 0;
		float fromX = 0;
		float fromY = 0;
		float toX = LOCAL_TILE_SIZE;
		float toY = LOCAL_TILE_SIZE;

		final int[][][] tileHeights = scene.getTileHeights();
		int swHeight = tileHeights[tileZ][tileExX][tileExY];
		int seHeight = tileHeights[tileZ][tileExX + 1][tileExY];
		int neHeight = tileHeights[tileZ][tileExX + 1][tileExY + 1];
		int nwHeight = tileHeights[tileZ][tileExX][tileExY + 1];

		float terrainData = (float) packTerrainData(true, 0, WaterType.NONE, tileZ);

		sceneContext.stagingBufferNormals.ensureCapacity(24);
		sceneContext.stagingBufferNormals.put(0, -1, 0, terrainData);
		sceneContext.stagingBufferNormals.put(0, -1, 0, terrainData);
		sceneContext.stagingBufferNormals.put(0, -1, 0, terrainData);

		sceneContext.stagingBufferNormals.put(0, -1, 0, terrainData);
		sceneContext.stagingBufferNormals.put(0, -1, 0, terrainData);
		sceneContext.stagingBufferNormals.put(0, -1, 0, terrainData);

		sceneContext.stagingBufferVertices.ensureCapacity(24);
		sceneContext.stagingBufferVertices.put(toX, neHeight, toY, color);
		sceneContext.stagingBufferVertices.put(fromX, nwHeight, toY, color);
		sceneContext.stagingBufferVertices.put(toX, seHeight, fromY, color);

		sceneContext.stagingBufferVertices.put(fromX, swHeight, fromY, color);
		sceneContext.stagingBufferVertices.put(toX, seHeight, fromY, color);
		sceneContext.stagingBufferVertices.put(fromX, nwHeight, toY, color);

		int packedMaterialData = material.packMaterialData(ModelOverride.NONE, UvType.GEOMETRY, false);

		sceneContext.stagingBufferUvs.ensureCapacity(24);
		sceneContext.stagingBufferUvs.put(0, 0, 0, packedMaterialData);
		sceneContext.stagingBufferUvs.put(1, 0, 0, packedMaterialData);
		sceneContext.stagingBufferUvs.put(0, 1, 0, packedMaterialData);

		sceneContext.stagingBufferUvs.put(1, 1, 0, packedMaterialData);
		sceneContext.stagingBufferUvs.put(0, 1, 0, packedMaterialData);
		sceneContext.stagingBufferUvs.put(1, 0, 0, packedMaterialData);
	}

	public static int packTerrainData(boolean isTerrain, int waterDepth, WaterType waterType, int plane) {
		// Up to 16-bit water depth | 5-bit water type | 2-bit plane | terrain flag
		assert waterType.index < 1 << 5 : "Too many water types";
		int terrainData = (waterDepth & 0xFFFF) << 8 | waterType.index << 3 | plane << 1 | (isTerrain ? 1 : 0);
		assert (terrainData & ~0xFFFFFF) == 0 : "Only the lower 24 bits are usable, since we pass this into shaders as a float";
		return terrainData;
	}
}

/*
 * Copyright (c) 2021, 117 <https://twitter.com/117scape>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package rs117.hd.scene;

import java.util.Arrays;
import java.util.HashMap;
import javax.inject.Inject;
import javax.inject.Singleton;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.*;
import rs117.hd.HdPlugin;
import rs117.hd.config.SeasonalTheme;
import rs117.hd.scene.materials.Material;
import rs117.hd.scene.model_overrides.ModelOverride;
import rs117.hd.scene.model_overrides.TzHaarRecolorType;
import rs117.hd.scene.tile_overrides.TileOverride;
import rs117.hd.scene.water_types.WaterType;
import rs117.hd.utils.ColorUtils;
import rs117.hd.utils.ModelHash;

import static net.runelite.api.Constants.*;
import static net.runelite.api.Perspective.*;
import static rs117.hd.scene.SceneContext.SCENE_OFFSET;
import static rs117.hd.scene.tile_overrides.TileOverride.OVERLAY_FLAG;
import static rs117.hd.utils.HDUtils.HIDDEN_HSL;
import static rs117.hd.utils.HDUtils.calculateSurfaceNormals;
import static rs117.hd.utils.HDUtils.vertexHash;
import static rs117.hd.utils.MathUtils.*;

@Slf4j
@Singleton
public class ProceduralGenerator {
	public static final int[] DEPTH_LEVEL_SLOPE = new int[] { 150, 300, 470, 610, 700, 750, 820, 920, 1080, 1300, 1350, 1380 };

	// directional vectors approximately opposite of the directional light used by the client
	public static final float[] LIGHT_DIR_TILE = new float[] { 0.70710678f, 0.70710678f, 0f };

	public static final int VERTICES_PER_FACE = 3;
	public static final boolean[][] TILE_OVERLAY_TRIS = new boolean[][]
		{
			/*  0 */ { true, true, true, true }, // Used by tilemodels of varying tri counts?
			/*  1 */ { false, true },
			/*  2 */ { false, false, true },
			/*  3 */ { false, false, true },
			/*  4 */ { false, true, true },
			/*  5 */ { false, true, true },
			/*  6 */ { false, false, true, true },
			/*  7 */ { false, false, false, true },
			/*  8 */ { false, true, true, true },
			/*  9 */ { false, false, false, true, true, true },
			/* 10 */ { true, true, true, false, false, false },
			/* 11 */ { true, true, false, false, false, false },
		};

	@Inject
	private HdPlugin plugin;

	@Inject
	private TileOverrideManager tileOverrideManager;

	public void generateSceneData(SceneContext sceneContext)
	{
		long timerTotal = System.currentTimeMillis();
		long timerCalculateTerrainNormals, timerGenerateTerrainData, timerGenerateUnderwaterTerrain;

		long startTime = System.currentTimeMillis();
		generateUnderwaterTerrain(sceneContext);
		timerGenerateUnderwaterTerrain = (int)(System.currentTimeMillis() - startTime);
		startTime = System.currentTimeMillis();
		calculateTerrainNormals(sceneContext);
		timerCalculateTerrainNormals = (int)(System.currentTimeMillis() - startTime);
		startTime = System.currentTimeMillis();
		generateTerrainData(sceneContext);
		timerGenerateTerrainData = (int)(System.currentTimeMillis() - startTime);

		log.debug("procedural data generation took {}ms to complete", (System.currentTimeMillis() - timerTotal));
		log.debug("-- calculateTerrainNormals: {}ms", timerCalculateTerrainNormals);
		log.debug("-- generateTerrainData: {}ms", timerGenerateTerrainData);
		log.debug("-- generateUnderwaterTerrain: {}ms", timerGenerateUnderwaterTerrain);
	}

	/**
	 * Iterates through all Tiles in a given Scene, producing color and
	 * material data for each vertex of each Tile. Then adds the resulting
	 * data to appropriate HashMaps.
	 */
	private void generateTerrainData(SceneContext sceneContext)
	{
		sceneContext.vertexTerrainColor = new HashMap<>();
		// used for overriding potentially undesirable vertex colors
		// for example, colors that aren't supposed to be visible
		sceneContext.highPriorityColor = new HashMap<>();
		sceneContext.vertexTerrainTexture = new HashMap<>();
		// for faces without an overlay is set to true
		sceneContext.vertexIsUnderlay = new HashMap<>();
		// for faces with an overlay is set to true
		// the result of these maps can be used to determine the vertices
		// between underlays and overlays for custom blending
		sceneContext.vertexIsOverlay = new HashMap<>();

		Tile[][][] tiles = sceneContext.scene.getExtendedTiles();
		for (int z = 0; z < MAX_Z; ++z) {
			for (int x = 0; x < EXTENDED_SCENE_SIZE; ++x)
				for (int y = 0; y < EXTENDED_SCENE_SIZE; ++y)
					if (tiles[z][x][y] != null)
						generateDataForTile(sceneContext, tiles[z][x][y], x, y);

			for (int x = 0; x < EXTENDED_SCENE_SIZE; ++x)
				for (int y = 0; y < EXTENDED_SCENE_SIZE; ++y)
					if (tiles[z][x][y] != null && tiles[z][x][y].getBridge() != null)
						generateDataForTile(sceneContext, tiles[z][x][y].getBridge(), x, y);
		}
	}

	/**
	 * Produces color and material data for the vertices of the provided Tile.
	 * Then adds the resulting data to appropriate HashMaps.
	 *
	 * @param sceneContext that the tile is associated with
	 * @param tile         to generate terrain data for
	 */
	private void generateDataForTile(SceneContext sceneContext, Tile tile, int tileExX, int tileExY)
	{
		int faceCount;
		if (tile.getSceneTilePaint() != null) {
			faceCount = 2;
		} else if (tile.getSceneTileModel() != null) {
			faceCount = tile.getSceneTileModel().getFaceX().length;
		} else {
			return;
		}

		int[] vertexHashes = new int[faceCount * VERTICES_PER_FACE];
		int[] vertexColors = new int[faceCount * VERTICES_PER_FACE];
		TileOverride[] vertexOverrides = new TileOverride[faceCount * VERTICES_PER_FACE];
		boolean[] vertexIsOverlay = new boolean[faceCount * VERTICES_PER_FACE];
		boolean[] vertexDefaultColor = new boolean[faceCount * VERTICES_PER_FACE];

		int tileX = tileExX - SCENE_OFFSET;
		int tileY = tileExY - SCENE_OFFSET;
		int tileZ = tile.getRenderLevel();
		int[] worldPos = sceneContext.sceneToWorld(tileX, tileY, tileZ);

		Scene scene = sceneContext.scene;
		if (tile.getSceneTilePaint() != null) {
			// tile paint

			var override = tileOverrideManager.getOverride(sceneContext, tile, worldPos);
			if (override.waterType != WaterType.NONE) {
				// skip water tiles
				return;
			}

			int swColor = tile.getSceneTilePaint().getSwColor();
			int seColor = tile.getSceneTilePaint().getSeColor();
			int nwColor = tile.getSceneTilePaint().getNwColor();
			int neColor = tile.getSceneTilePaint().getNeColor();

			vertexHashes = tileVertexKeys(scene, tile);

			if (tileExX >= EXTENDED_SCENE_SIZE - 2 && tileExY >= EXTENDED_SCENE_SIZE - 2) {
				// reduce the black scene edges by assigning surrounding colors
				neColor = swColor;
				nwColor = swColor;
				seColor = swColor;
			} else if (tileExY >= EXTENDED_SCENE_SIZE - 2) {
				nwColor = swColor;
				neColor = seColor;
			} else if (tileExX >= EXTENDED_SCENE_SIZE - 2) {
				neColor = nwColor;
				seColor = swColor;
			}

			vertexColors[0] = swColor;
			vertexColors[1] = seColor;
			vertexColors[2] = nwColor;
			vertexColors[3] = neColor;

			for (int i = 0; i < 4; i++) {
				vertexOverrides[i] = override;
				vertexIsOverlay[i] = override.queriedAsOverlay;
			}
			if (useDefaultColor(tile, override))
				for (int i = 0; i < 4; i++)
					vertexDefaultColor[i] = true;
		}
		else if (tile.getSceneTileModel() != null)
		{
			// tile model

			SceneTileModel sceneTileModel = tile.getSceneTileModel();

			final int[] faceColorsA = sceneTileModel.getTriangleColorA();
			final int[] faceColorsB = sceneTileModel.getTriangleColorB();
			final int[] faceColorsC = sceneTileModel.getTriangleColorC();

			int overlayId = OVERLAY_FLAG | scene.getOverlayIds()[tileZ][tileExX][tileExY];
			int underlayId = scene.getUnderlayIds()[tileZ][tileExX][tileExY];
			var overlayOverride = tileOverrideManager.getOverride(sceneContext, tile, worldPos, overlayId);
			var underlayOverride = tileOverrideManager.getOverride(sceneContext, tile, worldPos, underlayId);

			for (int face = 0; face < faceCount; face++) {
				int[] faceColors = new int[]{faceColorsA[face], faceColorsB[face], faceColorsC[face]};
				int[] vertexKeys = faceVertexKeys(tile, face);

				for (int vertex = 0; vertex < VERTICES_PER_FACE; vertex++) {
					boolean isOverlay = isOverlayFace(tile, face);
					var override = isOverlay ? overlayOverride : underlayOverride;
					if (override.waterType != WaterType.NONE)
						continue; // skip water faces

					vertexHashes[face * VERTICES_PER_FACE + vertex] = vertexKeys[vertex];

					int color = faceColors[vertex];
					vertexColors[face * VERTICES_PER_FACE + vertex] = color;

					vertexOverrides[face * VERTICES_PER_FACE + vertex] = override;
					vertexIsOverlay[face * VERTICES_PER_FACE + vertex] = isOverlay;

					if (isOverlay && useDefaultColor(tile, override))
						vertexDefaultColor[face * VERTICES_PER_FACE + vertex] = true;
				}
			}
		}

		for (int vertex = 0; vertex < vertexHashes.length; vertex++)
		{
			if (vertexHashes[vertex] == 0)
				continue;

			int color = vertexColors[vertex];
			var override = vertexOverrides[vertex];
			if (color < 0 || color == HIDDEN_HSL && !override.forced)
				continue;

			// if this vertex already has a 'high priority' color assigned,
			// skip assigning a 'low priority' color unless there is no color assigned.
			// Near-solid-black tiles that are used in some places under wall objects
			boolean lowPriorityColor = vertexColors[vertex] <= 2;

			float lightenMultiplier = 1.5f;
			int lightenBase = 15;
			int lightenAdd = 3;
			float darkenMultiplier = 0.5f;

			float[] vNormals = sceneContext.vertexTerrainNormals.getOrDefault(vertexHashes[vertex], new float[] { 0, 0, 0 });

			float dot = dot(vNormals);
			if (dot < EPSILON) {
				dot = 0;
			} else {
				// Tile normal vectors need to be normalized
				dot = dot(LIGHT_DIR_TILE, vNormals, 2) / sqrt(dot);
			}
			int lightness = color & 0x7F;
			lightness = (int) mix(lightness, (int) (max(lightness - lightenAdd, 0) * lightenMultiplier) + lightenBase, max(dot, 0));
			lightness = (int) (1.25f * mix(lightness, (int) (lightness * darkenMultiplier), -min(dot, 0)));
			final int maxBrightness = 55; // reduces overexposure
			lightness = min(lightness, maxBrightness);
			color = color & ~0x7F | lightness;

			Material material = override.groundMaterial.getRandomMaterial(worldPos);
			boolean isOverlay = vertexIsOverlay[vertex] != override.blendedAsOpposite;
			color = override.modifyColor(color);

			vertexColors[vertex] = color;

			// mark the vertex as either an overlay or underlay.
			// this is used to determine how to blend between vertex colors
			if (isOverlay)
			{
				sceneContext.vertexIsOverlay.put(vertexHashes[vertex], true);
			}
			else
			{
				sceneContext.vertexIsUnderlay.put(vertexHashes[vertex], true);
			}

			// add color and texture to hashmap
			if ((!lowPriorityColor || !sceneContext.highPriorityColor.containsKey(vertexHashes[vertex])) && !vertexDefaultColor[vertex])
			{
				boolean shouldWrite = isOverlay || !sceneContext.vertexTerrainColor.containsKey(vertexHashes[vertex]);
				if (shouldWrite || !sceneContext.vertexTerrainColor.containsKey(vertexHashes[vertex]))
					sceneContext.vertexTerrainColor.put(vertexHashes[vertex], vertexColors[vertex]);

				if (shouldWrite || !sceneContext.vertexTerrainTexture.containsKey(vertexHashes[vertex]))
					sceneContext.vertexTerrainTexture.put(vertexHashes[vertex], material);

				if (!lowPriorityColor)
					sceneContext.highPriorityColor.put(vertexHashes[vertex], true);
			}
		}
	}

	/**
	 * Generates underwater terrain data by iterating through all Tiles in a given
	 * Scene, increasing the depth of each tile based on its distance from the shore.
	 * Then stores the resulting data in a HashMap.
	 */
	private void generateUnderwaterTerrain(SceneContext sceneContext)
	{
		// true if a tile contains at least 1 face which qualifies as water
		sceneContext.tileIsWater = new boolean[MAX_Z][EXTENDED_SCENE_SIZE][EXTENDED_SCENE_SIZE];
		// true if a vertex is part of a face which qualifies as water; non-existent if not
		sceneContext.vertexIsWater = new HashMap<>();
		// true if a vertex is part of a face which qualifies as land; non-existent if not
		// tiles along the shoreline will be true for both vertexIsWater and vertexIsLand
		sceneContext.vertexIsLand = new HashMap<>();
		// if true, the tile will be skipped when the scene is drawn
		// this is due to certain edge cases with water on the same X/Y on different planes
		sceneContext.skipTile = new boolean[MAX_Z][EXTENDED_SCENE_SIZE][EXTENDED_SCENE_SIZE];
		// the height adjustment for each vertex, to be applied to the vertex'
		// real height to create the underwater terrain
		sceneContext.vertexUnderwaterDepth = new HashMap<>();
		// the basic 'levels' of underwater terrain, used to sink terrain based on its distance
		// from the shore, then used to produce the world-space height offset
		// 0 = land
		sceneContext.underwaterDepthLevels = new int[MAX_Z][EXTENDED_SCENE_SIZE + 1][EXTENDED_SCENE_SIZE + 1];
		// the world-space height offsets of each vertex on the tile grid
		// these offsets are interpolated to calculate offsets for vertices not on the grid (tilemodels)
		final int[][][] underwaterDepths = new int[MAX_Z][EXTENDED_SCENE_SIZE + 1][EXTENDED_SCENE_SIZE + 1];

		for (int z = 0; z < MAX_Z; ++z)
		{
			for (int x = 0; x < EXTENDED_SCENE_SIZE; ++x) {
				// set the array to 1 initially
				// this assumes that all vertices are water;
				// we will set non-water vertices to 0 in the next loop
				Arrays.fill(sceneContext.underwaterDepthLevels[z][x], 1);
			}
		}

		Scene scene = sceneContext.scene;
		Tile[][][] tiles = scene.getExtendedTiles();

		// figure out which vertices are water and assign some data
		for (int z = 0; z < MAX_Z; ++z) {
			for (int x = 0; x < EXTENDED_SCENE_SIZE; ++x) {
				for (int y = 0; y < EXTENDED_SCENE_SIZE; ++y) {
					if (tiles[z][x][y] == null) {
						sceneContext.underwaterDepthLevels[z][x][y] = 0;
						sceneContext.underwaterDepthLevels[z][x + 1][y] = 0;
						sceneContext.underwaterDepthLevels[z][x][y + 1] = 0;
						sceneContext.underwaterDepthLevels[z][x + 1][y + 1] = 0;
						continue;
					}

					Tile tile = tiles[z][x][y];
					if (tile.getBridge() != null) {
						tile = tile.getBridge();
					}

					if (tile.getSceneTilePaint() != null) {
						int[] vertexKeys = tileVertexKeys(scene, tile);

						int[] worldPos = sceneContext.extendedSceneToWorld(x, y, tile.getRenderLevel());
						var override = tileOverrideManager.getOverride(sceneContext, tile, worldPos);
						if (seasonalWaterType(override, tile.getSceneTilePaint().getTexture()) == WaterType.NONE) {
							for (int vertexKey : vertexKeys)
								if (tile.getSceneTilePaint().getNeColor() != HIDDEN_HSL || override.forced)
									sceneContext.vertexIsLand.put(vertexKey, true);

							sceneContext.underwaterDepthLevels[z][x][y] = 0;
							sceneContext.underwaterDepthLevels[z][x + 1][y] = 0;
							sceneContext.underwaterDepthLevels[z][x][y + 1] = 0;
							sceneContext.underwaterDepthLevels[z][x + 1][y + 1] = 0;
						} else {
							// Stop tiles on the same X,Y coordinates on different planes from
							// each generating water. Prevents undesirable results in certain places.
							if (z > 0) {
								boolean continueLoop = false;

								for (int checkZ = 0; checkZ < z; ++checkZ) {
									if (sceneContext.tileIsWater[checkZ][x][y]) {
										sceneContext.underwaterDepthLevels[z][x][y] = 0;
										sceneContext.underwaterDepthLevels[z][x + 1][y] = 0;
										sceneContext.underwaterDepthLevels[z][x][y + 1] = 0;
										sceneContext.underwaterDepthLevels[z][x + 1][y + 1] = 0;

										sceneContext.skipTile[z][x][y] = true;

										continueLoop = true;

										break;
									}
								}

								if (continueLoop)
									continue;
							}

							sceneContext.tileIsWater[z][x][y] = true;

							for (int vertexKey : vertexKeys)
							{
								sceneContext.vertexIsWater.put(vertexKey, true);
							}
						}
					}
					else if (tile.getSceneTileModel() != null)
					{
						SceneTileModel model = tile.getSceneTileModel();

						int faceCount = model.getFaceX().length;

						int tileZ = tile.getRenderLevel();
						int[] worldPos = sceneContext.extendedSceneToWorld(x, y, tileZ);
						int overlayId = OVERLAY_FLAG | scene.getOverlayIds()[tileZ][x][y];
						int underlayId = scene.getUnderlayIds()[tileZ][x][y];
						var overlayOverride = tileOverrideManager.getOverride(sceneContext, tile, worldPos, overlayId);
						var underlayOverride = tileOverrideManager.getOverride(sceneContext, tile, worldPos, underlayId);

						// Stop tiles on the same X,Y coordinates on different planes from
						// each generating water. Prevents undesirable results in certain places.
						if (z > 0)
						{
							boolean tileIncludesWater = false;
							for (int face = 0; face < faceCount; face++)
							{
								var override = ProceduralGenerator.isOverlayFace(tile, face) ? overlayOverride : underlayOverride;
								int textureId = model.getTriangleTextureId() == null ? -1 :
									model.getTriangleTextureId()[face];
								if (seasonalWaterType(override, textureId) != WaterType.NONE)
								{
									tileIncludesWater = true;
									break;
								}
							}

							if (tileIncludesWater)
							{
								boolean continueLoop = false;

								for (int checkZ = 0; checkZ < z; ++checkZ)
								{
									if (sceneContext.tileIsWater[checkZ][x][y])
									{
										sceneContext.underwaterDepthLevels[z][x][y] = 0;
										sceneContext.underwaterDepthLevels[z][x+1][y] = 0;
										sceneContext.underwaterDepthLevels[z][x][y+1] = 0;
										sceneContext.underwaterDepthLevels[z][x+1][y+1] = 0;

										sceneContext.skipTile[z][x][y] = true;

										continueLoop = true;

										break;
									}
								}

								if (continueLoop)
									continue;
							}
						}

						for (int face = 0; face < faceCount; face++)
						{
							int[][] vertices = faceVertices(tile, face);
							int[] vertexKeys = faceVertexKeys(tile, face);

							var override = ProceduralGenerator.isOverlayFace(tile, face) ? overlayOverride : underlayOverride;
							int textureId = model.getTriangleTextureId() == null ? -1 :
								model.getTriangleTextureId()[face];
							if (seasonalWaterType(override, textureId) == WaterType.NONE)
							{
								for (int vertex = 0; vertex < VERTICES_PER_FACE; vertex++)
								{
									if (model.getTriangleColorA()[face] != HIDDEN_HSL || override.forced)
										sceneContext.vertexIsLand.put(vertexKeys[vertex], true);

									if (vertices[vertex][0] % LOCAL_TILE_SIZE == 0 &&
										vertices[vertex][1] % LOCAL_TILE_SIZE == 0
									) {
										int vX = (vertices[vertex][0] >> LOCAL_COORD_BITS) + SCENE_OFFSET;
										int vY = (vertices[vertex][1] >> LOCAL_COORD_BITS) + SCENE_OFFSET;

										sceneContext.underwaterDepthLevels[z][vX][vY] = 0;
									}
								}
							}
							else
							{
								sceneContext.tileIsWater[z][x][y] = true;

								for (int vertex = 0; vertex < VERTICES_PER_FACE; vertex++)
								{
									sceneContext.vertexIsWater.put(vertexKeys[vertex], true);
								}
							}
						}
					}
					else
					{
						sceneContext.underwaterDepthLevels[z][x][y] = 0;
						sceneContext.underwaterDepthLevels[z][x+1][y] = 0;
						sceneContext.underwaterDepthLevels[z][x][y+1] = 0;
						sceneContext.underwaterDepthLevels[z][x+1][y+1] = 0;
					}
				}
			}
		}

		// Sink terrain further from shore by desired levels.
		for (int level = 0; level < DEPTH_LEVEL_SLOPE.length - 1; level++)
		{
			for (int z = 0; z < MAX_Z; ++z)
			{
				for (int x = 0; x < sceneContext.underwaterDepthLevels[z].length; x++)
				{
					for (int y = 0; y < sceneContext.underwaterDepthLevels[z][x].length; y++)
					{
						if (sceneContext.underwaterDepthLevels[z][x][y] == 0)
						{
							// Skip the tile if it isn't water.
							continue;
						}
						// If it's on the edge of the scene, reset the depth so
						// it creates a 'wall' to prevent fog from passing through.
						// Not incredibly effective, but better than nothing.
						if (x == 0 || y == 0 || x == EXTENDED_SCENE_SIZE || y == EXTENDED_SCENE_SIZE) {
							sceneContext.underwaterDepthLevels[z][x][y] = 0;
							continue;
						}

						int tileHeight = sceneContext.underwaterDepthLevels[z][x][y];
						if (sceneContext.underwaterDepthLevels[z][x - 1][y] < tileHeight)
						{
							// West
							continue;
						}
						if (x < sceneContext.underwaterDepthLevels[z].length - 1 && sceneContext.underwaterDepthLevels[z][x + 1][y] < tileHeight)
						{
							// East
							continue;
						}
						if (sceneContext.underwaterDepthLevels[z][x][y - 1] < tileHeight)
						{
							// South
							continue;
						}
						if (y < sceneContext.underwaterDepthLevels[z].length - 1 && sceneContext.underwaterDepthLevels[z][x][y + 1] < tileHeight)
						{
							// North
							continue;
						}
						// At this point, it's surrounded only by other depth-adjusted vertices.
						sceneContext.underwaterDepthLevels[z][x][y]++;
					}
				}
			}
		}

		// Adjust the height levels to world coordinate offsets and add to an array.
		for (int z = 0; z < MAX_Z; ++z)
		{
			for (int x = 0; x < sceneContext.underwaterDepthLevels[z].length; x++)
			{
				for (int y = 0; y < sceneContext.underwaterDepthLevels[z][x].length; y++)
				{
					if (sceneContext.underwaterDepthLevels[z][x][y] == 0)
					{
						continue;
					}
					int depth = DEPTH_LEVEL_SLOPE[sceneContext.underwaterDepthLevels[z][x][y] - 1];
					int heightOffset = (int) (depth * .55f); // legacy weirdness
					underwaterDepths[z][x][y] = heightOffset;
				}
			}
		}

		// Store the height offsets in a hashmap and calculate interpolated
		// height offsets for non-corner vertices.
		for (int z = 0; z < MAX_Z; ++z) {
			for (int x = 0; x < EXTENDED_SCENE_SIZE; ++x) {
				for (int y = 0; y < EXTENDED_SCENE_SIZE; ++y) {
					if (!sceneContext.tileIsWater[z][x][y]) {
						continue;
					}

					Tile tile = tiles[z][x][y];
					if (tile == null) {
						continue;
					}

					if (tile.getBridge() != null) {
						tile = tile.getBridge();
					}
					if (tile.getSceneTilePaint() != null) {
						int[] vertexKeys = tileVertexKeys(scene, tile);

						int swVertexKey = vertexKeys[0];
						int seVertexKey = vertexKeys[1];
						int nwVertexKey = vertexKeys[2];
						int neVertexKey = vertexKeys[3];

						sceneContext.vertexUnderwaterDepth.put(swVertexKey, underwaterDepths[z][x][y]);
						sceneContext.vertexUnderwaterDepth.put(seVertexKey, underwaterDepths[z][x + 1][y]);
						sceneContext.vertexUnderwaterDepth.put(nwVertexKey, underwaterDepths[z][x][y + 1]);
						sceneContext.vertexUnderwaterDepth.put(neVertexKey, underwaterDepths[z][x + 1][y + 1]);
					}
					else if (tile.getSceneTileModel() != null)
					{
						SceneTileModel sceneTileModel = tile.getSceneTileModel();

						int faceCount = sceneTileModel.getFaceX().length;

						for (int face = 0; face < faceCount; face++)
						{
							int[][] vertices = faceVertices(tile, face);
							int[] vertexKeys = faceVertexKeys(tile, face);

							for (int vertex = 0; vertex < VERTICES_PER_FACE; vertex++)
							{
								if (vertices[vertex][0] % LOCAL_TILE_SIZE == 0 &&
									vertices[vertex][1] % LOCAL_TILE_SIZE == 0
								) {
									// The vertex is at the corner of the tile;
									// simply use the offset in the tile grid array.

									int vX = (vertices[vertex][0] >> LOCAL_COORD_BITS) + SCENE_OFFSET;
									int vY = (vertices[vertex][1] >> LOCAL_COORD_BITS) + SCENE_OFFSET;

									sceneContext.vertexUnderwaterDepth.put(vertexKeys[vertex], underwaterDepths[z][vX][vY]);
								}
								else
								{
									// If the tile is a tile model and this vertex is shared only by faces that are water,
									// interpolate between the height offsets at each corner to get the height offset
									// of the vertex.

									float lerpX = fract(vertices[vertex][0] / (float) LOCAL_TILE_SIZE);
									float lerpY = fract(vertices[vertex][1] / (float) LOCAL_TILE_SIZE);
									float northHeightOffset = mix(underwaterDepths[z][x][y + 1], underwaterDepths[z][x + 1][y + 1], lerpX);
									float southHeightOffset = mix(underwaterDepths[z][x][y], underwaterDepths[z][x + 1][y], lerpX);
									int heightOffset = (int) mix(southHeightOffset, northHeightOffset, lerpY);

									if (!sceneContext.vertexIsLand.containsKey(vertexKeys[vertex]))
										sceneContext.vertexUnderwaterDepth.put(vertexKeys[vertex], heightOffset);
								}
							}
						}
					}
				}
			}
		}
	}

	/**
	 * Iterates through all Tiles in a given Scene, calculating vertex normals
	 * for each one, then stores resulting normal data in a HashMap.
	 */
	private void calculateTerrainNormals(SceneContext sceneContext)
	{
		sceneContext.vertexTerrainNormals = new HashMap<>();

		for (Tile[][] plane : sceneContext.scene.getExtendedTiles()) {
			for (Tile[] column : plane) {
				for (Tile tile : column) {
					if (tile != null) {
						boolean isBridge = false;

						if (tile.getBridge() != null) {
							calculateNormalsForTile(sceneContext, tile.getBridge(), false);
							isBridge = true;
						}
						calculateNormalsForTile(sceneContext, tile, isBridge);
					}
				}
			}
		}
	}

	/**
	 * Calculates vertex normals for a given Tile,
	 * then stores resulting normal data in a HashMap.
	 *
	 * @param sceneContext that the tile is associated with
	 * @param tile         to calculate normals for
	 * @param isBridge     whether the tile is a bridge tile, i.e. tile above
	 */
	private void calculateNormalsForTile(SceneContext sceneContext, Tile tile, boolean isBridge)
	{
		// Make array of tile's tris with vertices
		int[][][] faceVertices; // Array of tile's tri vertices
		int[][] faceVertexKeys;

		if (tile.getSceneTileModel() != null)
		{
			// Tile model
			SceneTileModel tileModel = tile.getSceneTileModel();
			faceVertices = new int[tileModel.getFaceX().length][VERTICES_PER_FACE][3];
			faceVertexKeys = new int[tileModel.getFaceX().length][VERTICES_PER_FACE];

			for (int face = 0; face < tileModel.getFaceX().length; face++)
			{
				int[][] vertices = faceVertices(tile, face);

				faceVertices[face][0] = new int[]{vertices[0][0], vertices[0][1], vertices[0][2]};
				faceVertices[face][2] = new int[]{vertices[1][0], vertices[1][1], vertices[1][2]};
				faceVertices[face][1] = new int[]{vertices[2][0], vertices[2][1], vertices[2][2]};

				int[] vertexKeys = faceVertexKeys(tile, face);
				faceVertexKeys[face][0] = vertexKeys[0];
				faceVertexKeys[face][2] = vertexKeys[1];
				faceVertexKeys[face][1] = vertexKeys[2];
			}
		}
		else
		{
			faceVertices = new int[2][VERTICES_PER_FACE][3];
			faceVertexKeys = new int[VERTICES_PER_FACE][3];
			int[][] vertices = tileVertices(sceneContext.scene, tile);
			faceVertices[0] = new int[][]{vertices[3], vertices[1], vertices[2]};
			faceVertices[1] = new int[][]{vertices[0], vertices[2], vertices[1]};

			int[] vertexKeys = tileVertexKeys(sceneContext.scene, tile);
			faceVertexKeys[0] = new int[]{vertexKeys[3], vertexKeys[1], vertexKeys[2]};
			faceVertexKeys[1] = new int[]{vertexKeys[0], vertexKeys[2], vertexKeys[1]};
		}

		// Loop through tris to calculate and accumulate normals
		for (int face = 0; face < faceVertices.length; face++)
		{
			// XYZ
			int[] vertexHeights = new int[]{faceVertices[face][0][2], faceVertices[face][1][2], faceVertices[face][2][2]};
			if (!isBridge)
			{
				vertexHeights[0] += sceneContext.vertexUnderwaterDepth.getOrDefault(faceVertexKeys[face][0], 0);
				vertexHeights[1] += sceneContext.vertexUnderwaterDepth.getOrDefault(faceVertexKeys[face][1], 0);
				vertexHeights[2] += sceneContext.vertexUnderwaterDepth.getOrDefault(faceVertexKeys[face][2], 0);
			}

			float[] vertexNormals = calculateSurfaceNormals(
				new float[] {
					faceVertices[face][0][0],
					faceVertices[face][0][1],
					vertexHeights[0]
				},
				new float[] {
					faceVertices[face][1][0],
					faceVertices[face][1][1],
					vertexHeights[1]
				},
				new float[] {
					faceVertices[face][2][0],
					faceVertices[face][2][1],
					vertexHeights[2]
				}
			);

			for (int vertex = 0; vertex < VERTICES_PER_FACE; vertex++)
			{
				int vertexKey = faceVertexKeys[face][vertex];
				// accumulate normals to hashmap
				sceneContext.vertexTerrainNormals.merge(vertexKey, vertexNormals, (a, b) -> add(a, a, b));
			}
		}
	}

	public boolean useDefaultColor(Tile tile, TileOverride override)
	{
		if ((tile.getSceneTilePaint() != null && tile.getSceneTilePaint().getTexture() >= 0) ||
			(tile.getSceneTileModel() != null && tile.getSceneTileModel().getTriangleTextureId() != null))
		{
			// skip tiles with textures provided by default
			return true;
		}

		if (override == TileOverride.NONE)
			return false;

		return !override.blended;
	}

	public WaterType seasonalWaterType(TileOverride override, int textureId)
	{
		var waterType = override.waterType;

		// As a fallback, always consider vanilla textured water tiles as water
		// We purposefully ignore material replacements here such as ice from the winter theme
		if (waterType == WaterType.NONE) {
			switch (textureId) {
				case 1:
				case 24:
					waterType = WaterType.WATER_FLAT;
					break;
				case 25:
					waterType = WaterType.SWAMP_WATER_FLAT;
					break;
			}
		}

		if (waterType == WaterType.WATER && plugin.configSeasonalTheme == SeasonalTheme.WINTER)
			return WaterType.ICE;

		return waterType;
	}

	private static boolean[] getTileOverlayTris(int tileShapeIndex)
	{
		if (tileShapeIndex >= TILE_OVERLAY_TRIS.length)
		{
			log.debug("getTileOverlayTris(): unknown tileShapeIndex ({})", tileShapeIndex);
			return new boolean[10]; // false
		}
		else
		{
			return TILE_OVERLAY_TRIS[tileShapeIndex];
		}
	}

	public static boolean isOverlayFace(Tile tile, int face) {
		int tileShapeIndex = tile.getSceneTileModel().getShape() - 1;
		if (face >= getTileOverlayTris(tileShapeIndex).length) {
			return false;
		}
		return getTileOverlayTris(tileShapeIndex)[face];
	}

	private static int[][] tileVertices(Scene scene, Tile tile) {
		int tileX = tile.getSceneLocation().getX();
		int tileY = tile.getSceneLocation().getY();
		int tileExX = tileX + SCENE_OFFSET;
		int tileExY = tileY + SCENE_OFFSET;
		int tileZ = tile.getRenderLevel();
		int[][][] tileHeights = scene.getTileHeights();

		int[] swVertex = new int[] {
			tileX * LOCAL_TILE_SIZE,
			tileY * LOCAL_TILE_SIZE,
			tileHeights[tileZ][tileExX][tileExY]
		};
		int[] seVertex = new int[] {
			(tileX + 1) * LOCAL_TILE_SIZE,
			tileY * LOCAL_TILE_SIZE,
			tileHeights[tileZ][tileExX + 1][tileExY]
		};
		int[] nwVertex = new int[] {
			tileX * LOCAL_TILE_SIZE,
			(tileY + 1) * LOCAL_TILE_SIZE,
			tileHeights[tileZ][tileExX][tileExY + 1]
		};
		int[] neVertex = new int[] {
			(tileX + 1) * LOCAL_TILE_SIZE,
			(tileY + 1) * LOCAL_TILE_SIZE,
			tileHeights[tileZ][tileExX + 1][tileExY + 1]
		};

		return new int[][] { swVertex, seVertex, nwVertex, neVertex };
	}

	private static int[][] faceVertices(Tile tile, int face)
	{
		SceneTileModel sceneTileModel = tile.getSceneTileModel();

		final int[] faceA = sceneTileModel.getFaceX();
		final int[] faceB = sceneTileModel.getFaceY();
		final int[] faceC = sceneTileModel.getFaceZ();

		final int[] vertexX = sceneTileModel.getVertexX();
		final int[] vertexY = sceneTileModel.getVertexY();
		final int[] vertexZ = sceneTileModel.getVertexZ();

		int vertexFacesA = faceA[face];
		int vertexFacesB = faceB[face];
		int vertexFacesC = faceC[face];

		// scene X
		int sceneVertexXA = vertexX[vertexFacesA];
		int sceneVertexXB = vertexX[vertexFacesB];
		int sceneVertexXC = vertexX[vertexFacesC];
		// scene Y
		int sceneVertexZA = vertexZ[vertexFacesA];
		int sceneVertexZB = vertexZ[vertexFacesB];
		int sceneVertexZC = vertexZ[vertexFacesC];
		// scene Z - heights
		int sceneVertexYA = vertexY[vertexFacesA];
		int sceneVertexYB = vertexY[vertexFacesB];
		int sceneVertexYC = vertexY[vertexFacesC];

		int[] vertexA = new int[] { sceneVertexXA, sceneVertexZA, sceneVertexYA };
		int[] vertexB = new int[] { sceneVertexXB, sceneVertexZB, sceneVertexYB };
		int[] vertexC = new int[] { sceneVertexXC, sceneVertexZC, sceneVertexYC };

		return new int[][] { vertexA, vertexB, vertexC };
	}

	/**
	 * Returns vertex positions in local coordinates, between 0 and 128.
	 */
	public static int[][] faceLocalVertices(Tile tile, int face) {
		if (tile.getSceneTileModel() == null)
			return new int[0][0];

		int x = tile.getSceneLocation().getX();
		int y = tile.getSceneLocation().getY();
		int baseX = x * LOCAL_TILE_SIZE;
		int baseY = y * LOCAL_TILE_SIZE;

		int[][] vertices = faceVertices(tile, face);
		for (int[] vertex : vertices) {
			vertex[0] -= baseX;
			vertex[1] -= baseY;
		}
		return vertices;
	}

	/**
	 * Gets the vertex keys of a Tile Paint tile for use in retrieving data from hashmaps.
	 *
	 * @param scene that the tile is from
	 * @param tile  to get the vertex keys of
	 * @return Vertex keys in following order: SW, SE, NW, NE
	 */
	public static int[] tileVertexKeys(Scene scene, Tile tile)
	{
		int[][] tileVertices = tileVertices(scene, tile);
		int[] vertexHashes = new int[tileVertices.length];

		for (int vertex = 0; vertex < tileVertices.length; ++vertex)
			vertexHashes[vertex] = vertexHash(tileVertices[vertex]);

		return vertexHashes;
	}

	public static int[] faceVertexKeys(Tile tile, int face)
	{
		int[][] faceVertices = faceVertices(tile, face);
		int[] vertexHashes = new int[faceVertices.length];

		for (int vertex = 0; vertex < faceVertices.length; ++vertex)
			vertexHashes[vertex] = vertexHash(faceVertices[vertex]);

		return vertexHashes;
	}

	private static final int[] tzHaarRecolored = new int[4];
	// used when calculating the gradient to apply to the walls of TzHaar
	// to emulate the style from 2008 HD rework
	private static final float[] gradientBaseColor = vec(3, 4, 26);
	private static final float[] gradientDarkColor = vec(3, 4, 10);
	private static final int gradientBottom = 200;
	private static final int gradientTop = -200;

	public static int[] recolorTzHaar(
		int uuid,
		ModelOverride modelOverride,
		Model model,
		int face,
		int packedAlphaPriority,
		int color1,
		int color2,
		int color3
	) {
		int[] hsl1 = ColorUtils.unpackRawHsl(color1);
		int[] hsl2 = ColorUtils.unpackRawHsl(color2);
		int[] hsl3 = ColorUtils.unpackRawHsl(color3);

		// shift model hues from red->yellow
		int hue = 7;
		hsl1[0] = hsl2[0] = hsl3[0] = hue;

		// recolor tzhaar to look like the 2008+ HD version
		if (ModelHash.getUuidSubType(uuid) == ModelHash.TYPE_GROUND_OBJECT) {
			// remove the black parts of floor objects to allow the ground to show,
			// so we can apply textures, ground blending, etc. to it
			if (hsl1[1] <= 1)
				packedAlphaPriority = 0xFF << 24;
		}

		if (modelOverride.tzHaarRecolorType == TzHaarRecolorType.GRADIENT) {
			final int triA = model.getFaceIndices1()[face];
			final int triB = model.getFaceIndices2()[face];
			final int triC = model.getFaceIndices3()[face];
			final float[] yVertices = model.getVerticesY();
			float heightA = yVertices[triA];
			float heightB = yVertices[triB];
			float heightC = yVertices[triC];

			// apply coloring to the rocky walls
			if (hsl1[2] < 20) {
				float pos = clamp((heightA - gradientTop) / (float) gradientBottom, 0.0f, 1.0f);
				round(hsl1, mix(gradientDarkColor, gradientBaseColor, pos));
			}

			if (hsl2[2] < 20)
			{
				float pos = clamp((heightB - gradientTop) / (float) gradientBottom, 0.0f, 1.0f);
				round(hsl2, mix(gradientDarkColor, gradientBaseColor, pos));
			}

			if (hsl3[2] < 20)
			{
				float pos = clamp((heightC - gradientTop) / (float) gradientBottom, 0.0f, 1.0f);
				round(hsl3, mix(gradientDarkColor, gradientBaseColor, pos));
			}
		}
		else if (modelOverride.tzHaarRecolorType == TzHaarRecolorType.HUE_SHIFT)
		{
			// objects around the entrance to The Inferno only need a hue-shift
			// and very slight lightening to match the lightened terrain
			hsl1[2] += 1;
			hsl2[2] += 1;
			hsl3[2] += 1;
		}

		tzHaarRecolored[0] = ColorUtils.packRawHsl(hsl1);
		tzHaarRecolored[1] = ColorUtils.packRawHsl(hsl2);
		tzHaarRecolored[2] = ColorUtils.packRawHsl(hsl3);
		tzHaarRecolored[3] = packedAlphaPriority;

		return tzHaarRecolored;
	}
}

package rs117.hd.scene.water_types;

import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonToken;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import javax.annotation.Nullable;
import lombok.AccessLevel;
import lombok.NoArgsConstructor;
import lombok.Setter;
import lombok.extern.slf4j.Slf4j;
import rs117.hd.opengl.uniforms.UBOWaterTypes;
import rs117.hd.scene.WaterTypeManager;
import rs117.hd.scene.materials.Material;
import rs117.hd.utils.ColorUtils;
import rs117.hd.utils.GsonUtils;

import static rs117.hd.utils.ColorUtils.linearToSrgb;
import static rs117.hd.utils.ColorUtils.rgb;

@NoArgsConstructor
@GsonUtils.ExcludeDefaults
@Setter(AccessLevel.PROTECTED)
public class WaterType {
	public String name;
	private boolean flat = false;
	private float specularStrength = .5f;
	private float specularGloss = 500;
	private float normalStrength = .09f;
	private float baseOpacity = .5f;
	private float fresnelAmount = 1;
	@Nullable
	private Material normalMap;
	@JsonAdapter(ColorUtils.SrgbToLinearAdapter.class)
	private float[] surfaceColor = { 1, 1, 1 };
	@JsonAdapter(ColorUtils.SrgbToLinearAdapter.class)
	private float[] foamColor = rgb(176, 164, 146);
	@JsonAdapter(ColorUtils.SrgbToLinearAdapter.class)
	private float[] depthColor = rgb(0, 117, 142);
	private boolean hasFoam = true;
	private float duration = 1;
	public int fishingSpotRecolor = -1;

	public transient int index;

	public static final WaterType NONE = new WaterType("NONE");
	public static WaterType WATER;
	public static WaterType WATER_FLAT;
	public static WaterType SWAMP_WATER_FLAT;
	public static WaterType ICE;

	private WaterType(String name) {
		this.name = name;
	}

	public void normalize(int index, Material fallbackNormalMap) {
		this.index = index;
		if (name == null)
			name = "UNNAMED_" + index;
		if (normalMap == null)
			normalMap = fallbackNormalMap;
		if (surfaceColor == null)
			surfaceColor = NONE.surfaceColor;
		if (foamColor == null)
			foamColor = NONE.foamColor;
		if (depthColor == null)
			depthColor = NONE.depthColor;
	}

	@Override
	public String toString() {
		return name;
	}

	public void fillStruct(UBOWaterTypes.WaterTypeStruct struct) {
		struct.isFlat.set(flat ? 1 : 0);
		struct.specularStrength.set(specularStrength);
		struct.specularGloss.set(specularGloss);
		struct.normalStrength.set(normalStrength);
		struct.baseOpacity.set(baseOpacity);
		struct.hasFoam.set(hasFoam ? 1 : 0);
		struct.duration.set(duration);
		struct.fresnelAmount.set(fresnelAmount);
		struct.surfaceColor.set(linearToSrgb(surfaceColor));
		struct.foamColor.set(linearToSrgb(foamColor));
		struct.depthColor.set(linearToSrgb(depthColor));
		struct.normalMap.set(Material.getTextureLayer(normalMap));
	}

	@Slf4j
	public static class Adapter extends TypeAdapter<WaterType> {
		@Override
		public WaterType read(JsonReader in) throws IOException {
			if (in.peek() == JsonToken.NULL)
				return null;

			if (in.peek() == JsonToken.STRING) {
				String name = in.nextString();
				for (var match : WaterTypeManager.WATER_TYPES)
					if (name.equals(match.name))
						return match;

				log.warn("No water type exists with the name '{}' at {}", name, GsonUtils.location(in), new Throwable());
			} else {
				log.warn("Unexpected type {} at {}", in.peek(), GsonUtils.location(in), new Throwable());
			}

			return null;
		}

		@Override
		public void write(JsonWriter out, WaterType waterType) throws IOException {
			if (waterType == null) {
				out.nullValue();
			} else {
				out.value(waterType.name);
			}
		}
	}
}

package rs117.hd.scene.tile_overrides;

import net.runelite.api.*;
import rs117.hd.utils.HDUtils;
import rs117.hd.utils.VariableSupplier;

public class TileOverrideVariables implements VariableSupplier {
	private final String[] HSL_VARS = { "h", "s", "l" };
	private final int[] hsl = new int[3];

	private Tile tile;
	private boolean requiresHslUpdate;

	public void setTile(Tile tile) {
		if (tile == this.tile)
			return;
		this.tile = tile;
		requiresHslUpdate = true;
	}

	@Override
	public Object get(String name) {
		for (int i = 0; i < HSL_VARS.length; i++) {
			if (HSL_VARS[i].equals(name)) {
				if (requiresHslUpdate) {
					HDUtils.getSouthWesternMostTileColor(hsl, tile);
					requiresHslUpdate = false;
				}
				return hsl[i];
			}
		}

		throw new IllegalArgumentException("Undefined variable '" + name + "'");
	}
}

package rs117.hd.scene.tile_overrides;

import com.google.gson.JsonElement;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import java.util.ArrayList;
import java.util.Collections;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;
import javax.annotation.Nonnull;
import javax.annotation.Nullable;
import lombok.AllArgsConstructor;
import lombok.NoArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import rs117.hd.scene.AreaManager;
import rs117.hd.scene.areas.Area;
import rs117.hd.scene.ground_materials.GroundMaterial;
import rs117.hd.scene.water_types.WaterType;
import rs117.hd.utils.ExpressionParser;
import rs117.hd.utils.ExpressionPredicate;
import rs117.hd.utils.Props;
import rs117.hd.utils.VariableSupplier;

import static rs117.hd.utils.ExpressionParser.asExpression;
import static rs117.hd.utils.ExpressionParser.parseExpression;
import static rs117.hd.utils.MathUtils.*;

@Slf4j
@NoArgsConstructor
@AllArgsConstructor
public class TileOverride {
	public static final int OVERLAY_FLAG = 1 << 31;
	public static final TileOverride NONE = new TileOverride("NONE", GroundMaterial.DIRT);

	@Nullable
	public String name;
	public String description;
	@JsonAdapter(AreaManager.Adapter.class)
	public Area area = Area.NONE;
	public int[] overlayIds;
	public int[] underlayIds;
	@JsonAdapter(GroundMaterial.Adapter.class)
	public GroundMaterial groundMaterial = GroundMaterial.NONE;
	@JsonAdapter(WaterType.Adapter.class)
	public WaterType waterType = WaterType.NONE;
	public boolean blended = true;
	public boolean blendedAsOpposite;
	public boolean forced;
	public boolean depthTested;
	private int setHue = -1;
	private int shiftHue;
	private int minHue;
	private int maxHue = 63;
	private int setSaturation = -1;
	private int shiftSaturation;
	private int minSaturation;
	private int maxSaturation = 7;
	private int setLightness = -1;
	private int shiftLightness;
	private int minLightness;
	private int maxLightness = 127;
	public int uvOrientation;
	public float uvScale = 1;
	public int heightOffset;
	@SerializedName("replacements")
	public LinkedHashMap<String, JsonElement> rawReplacements;

	public transient int index;
	public transient int[] ids;
	public transient boolean queriedAsOverlay;
	@Nonnull
	private transient List<Map.Entry<ExpressionPredicate, TileOverride>> replacements = Collections.emptyList();

	private TileOverride(@Nullable String name, GroundMaterial groundMaterial) {
		this.name = name;
		this.groundMaterial = groundMaterial;
		this.index = Integer.MAX_VALUE; // Prioritize any-match overrides over this
	}

	@Override
	public String toString() {
		if (name != null)
			return name;
		if (description != null)
			return description;
		if (area != null)
			return area.name;
		return "Unnamed";
	}

	public boolean isConstant() {
		return replacements.isEmpty();
	}

	public void normalize(TileOverride[] allOverrides, VariableSupplier constants) {
		int numOverlays = overlayIds == null ? 0 : overlayIds.length;
		int numUnderlays = underlayIds == null ? 0 : underlayIds.length;
		int numIds = numOverlays + numUnderlays;
		if (numIds > 0) {
			ids = new int[numOverlays + numUnderlays];
			int i = 0;
			for (int j = 0; j < numOverlays; j++) {
				int id = overlayIds[j];
				ids[i++] = OVERLAY_FLAG | id;
			}
			for (int j = 0; j < numUnderlays; j++) {
				int id = underlayIds[j];
				ids[i++] = id;
			}
		}

		if (area == null) {
			log.warn("Undefined area in tile override: {}", this);
			area = Area.NONE;
		}
		if (groundMaterial == null) {
			log.warn("Undefined ground material in tile override: {}", this);
			groundMaterial = GroundMaterial.NONE;
		}
		if (waterType == null) {
			log.warn("Undefined water type in tile override: {}", this);
			waterType = WaterType.NONE;
		}

		if (forced) {
			// Replace hidden tiles with white by default
			minHue = maxHue = minSaturation = maxSaturation = 0;
			minLightness = maxLightness = 127;
		}

		if (setHue != -1)
			minHue = maxHue = setHue;
		if (setSaturation != -1)
			minSaturation = maxSaturation = setSaturation;
		if (setLightness != -1)
			minLightness = maxLightness = setLightness;

		// Convert UV scale to reciprocal, so we can multiply instead of dividing later
		uvScale = 1 / uvScale;

		if (rawReplacements != null) {
			replacements = new ArrayList<>();
			for (var entry : rawReplacements.entrySet()) {
				var name = entry.getKey();
				TileOverride replacement = null;
				if (name == null) {
					assert false : "Null is reserved for future use";
					replacement = NONE;
				} else if (name.equals(NONE.name)) {
					replacement = NONE;
				} else {
					for (var other : allOverrides) {
						if (name.equals(other.name)) {
							replacement = other;
							break;
						}
					}
					if (replacement == null) {
						replacement = NONE;
						// Technically, we could allow nulls, but it's indistinguishable from a parsing error atm
						if (Props.DEVELOPMENT)
							throw new IllegalStateException("Unknown tile override: '" + name + "'");
					}
				}

				var result = parseExpression(ExpressionParser.mergeJsonExpressions("||", entry.getValue()), constants);
				if (Props.DEVELOPMENT && result instanceof ExpressionParser.Expression) {
					var expr = (ExpressionParser.Expression) result;
					// Ensure all variables are defined
					var acceptedVariables = Set.of("h", "s", "l");
					for (var variable : expr.variables)
						if (!acceptedVariables.contains(variable))
							throw new IllegalStateException(String.format(
								"Expression '%s' contains unknown variable '%s'. Accepted variables: %s",
								expr, variable, String.join(", ", acceptedVariables)
							));
				}

				ExpressionPredicate predicate;
				boolean isConstant = result instanceof Boolean;
				if (isConstant) {
					if (!(boolean) result)
						continue; // Skip replacement conditions that are always false
					predicate = ExpressionPredicate.TRUE;
				} else {
					predicate = asExpression(result).toPredicate();
				}

				replacements.add(Map.entry(predicate, replacement));

				// Skip parsing the remaining unnecessary replacements, unless in development mode, where we want to parse all anyway
				if (isConstant && !Props.DEVELOPMENT)
					break;
			}
		}
	}

	public TileOverride resolveConstantReplacements() {
		// Check if the override always resolves to the same replacement override
		for (var entry : replacements) {
			var predicate = entry.getKey();
			// Stop on the first non-constant predicate
			if (predicate != ExpressionPredicate.TRUE)
				break;

			if (predicate.test()) {
				return entry.getValue();
			} else {
				assert false : "Constant false expressions should be filtered out by this point";
			}
		}

		return this;
	}

	public TileOverride resolveReplacements(VariableSupplier vars) {
		var replacement = resolveNextReplacement(vars);
		if (replacement == this)
			return replacement;
		return replacement.resolveReplacements(vars);
	}

	public TileOverride resolveNextReplacement(VariableSupplier vars) {
		for (var entry : replacements) {
			if (!entry.getKey().test(vars))
				continue;

			var replacement = entry.getValue();
			if (replacement == null)
				replacement = NONE;

			replacement.queriedAsOverlay = queriedAsOverlay;
			return replacement;
		}

		return this;
	}

	public int modifyColor(int jagexHsl) {
		int h = jagexHsl >> 10 & 0x3F;
		h += shiftHue;
		h = clamp(h, minHue, maxHue);

		int s = jagexHsl >> 7 & 7;
		s += shiftSaturation;
		s = clamp(s, minSaturation, maxSaturation);

		int l = jagexHsl & 0x7F;
		l += shiftLightness;
		l = clamp(l, minLightness, maxLightness);

		return h << 10 | s << 7 | l;
	}
}

/*
 * Copyright (c) 2025, Hooder <ahooder@protonmail.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package rs117.hd.scene;

import com.google.gson.JsonArray;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import java.io.IOException;
import java.util.ArrayDeque;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.Set;
import java.util.stream.Stream;
import javax.inject.Inject;
import javax.inject.Singleton;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.*;
import net.runelite.client.callback.ClientThread;
import org.lwjgl.opengl.*;
import rs117.hd.HdPlugin;
import rs117.hd.HdPluginConfig;
import rs117.hd.model.ModelPusher;
import rs117.hd.opengl.uniforms.UBOMaterials;
import rs117.hd.scene.materials.Material;
import rs117.hd.utils.ExpressionParser;
import rs117.hd.utils.FileWatcher;
import rs117.hd.utils.HDVariables;
import rs117.hd.utils.Props;
import rs117.hd.utils.ResourcePath;

import static org.lwjgl.opengl.GL33C.*;
import static rs117.hd.HdPlugin.TEXTURE_UNIT_GAME;
import static rs117.hd.utils.MathUtils.*;
import static rs117.hd.utils.ResourcePath.path;

@Slf4j
@Singleton
public class MaterialManager {
	private static final ResourcePath MATERIALS_PATH = Props
		.getFile("rlhd.materials-path", () -> path(MaterialManager.class, "materials.json"));

	@Inject
	private Client client;

	@Inject
	private ClientThread clientThread;

	@Inject
	private HdPlugin plugin;

	@Inject
	private HdPluginConfig config;

	@Inject
	private HDVariables vars;

	@Inject
	private TextureManager textureManager;

	@Inject
	private WaterTypeManager waterTypeManager;

	@Inject
	private GroundMaterialManager groundMaterialManager;

	@Inject
	private TileOverrideManager tileOverrideManager;

	@Inject
	private ModelOverrideManager modelOverrideManager;

	@Inject
	private ModelPusher modelPusher;

	public UBOMaterials uboMaterials;

	public static class TextureLayer {
		Material material;
		boolean needsUpload = true;
	}

	public static final Map<String, Material> MATERIAL_MAP = new HashMap<>();
	public static Material[] MATERIALS;
	public static Material[] VANILLA_TEXTURE_MAPPING;

	private int texMaterialTextureArray;
	private int[] textureResolution;
	public final List<TextureLayer> textureLayers = new ArrayList<>();

	private FileWatcher.UnregisterCallback fileWatcher;

	public void startUp() {
		fileWatcher = MATERIALS_PATH.watch((path, first) -> reload(first));
	}

	public void shutDown() {
		if (fileWatcher != null)
			fileWatcher.unregister();
		fileWatcher = null;

		if (texMaterialTextureArray != 0)
			glDeleteTextures(texMaterialTextureArray);
		texMaterialTextureArray = 0;
		textureLayers.clear();

		if (uboMaterials != null)
			uboMaterials.destroy();
		uboMaterials = null;

		MATERIAL_MAP.clear();
		invalidateMaterials(MATERIALS);
		MATERIALS = VANILLA_TEXTURE_MAPPING = null;
	}

	public Material getMaterial(String name) {
		var mat = MATERIAL_MAP.get(name);
		if (mat != null)
			return mat;
		log.warn("Couldn't find material '{}', falling back to NONE", name);
		return Material.NONE;
	}

	public Material fromVanillaTexture(int vanillaTextureId) {
		if (vanillaTextureId < 0 || vanillaTextureId >= VANILLA_TEXTURE_MAPPING.length)
			return Material.NONE;
		return VANILLA_TEXTURE_MAPPING[vanillaTextureId];
	}

	public void reload(boolean throwOnFailure) {
		clientThread.invoke(() -> {
			try {
				Material[] materials = loadMaterials(MATERIALS_PATH);
				log.debug("Loaded {} materials", materials.length);
				clientThread.invoke(() -> swapMaterials(materials));
			} catch (IOException ex) {
				log.error("Failed to load materials:", ex);
				if (throwOnFailure)
					throw new IllegalStateException(ex);
			}
		});
	}

	private Material[] loadMaterials(ResourcePath path) throws IOException {
		// Gson provides no simple way to let one object inherit defaults from another object,
		// so we parse the JSON manually into a JsonArray, which we can process to copy default
		// values from parent materials in the correct order.
		var gson = plugin.getGson();
		var rawMaterials = path.loadJson(gson, JsonArray.class);
		if (rawMaterials == null)
			throw new IOException("Empty or invalid: " + path);

		var rawMaterialMap = new HashMap<String, JsonObject>();
		var materialToParentMap = new HashMap<String, String>();

		var validMaterials = new ArrayList<JsonObject>();
		for (var element : rawMaterials) {
			if (!element.isJsonObject()) {
				log.error("Invalid material. Expected an object. Got: '{}'", element);
				continue;
			}

			var mat = element.getAsJsonObject();
			var name = mat.get("name");
			if (name == null) {
				log.error("Material missing name: '{}'", mat);
				continue;
			}
			if (!name.isJsonPrimitive() || !name.getAsJsonPrimitive().isString()) {
				log.error("Material name is not a string: '{}'", mat);
				continue;
			}

			var parent = mat.get("parent");
			if (parent != null && (!parent.isJsonPrimitive() || !parent.getAsJsonPrimitive().isString())) {
				log.error("Error in material '{}': Invalid parent name: '{}'", name.getAsString(), parent);
				continue;
			}

			if (rawMaterialMap.putIfAbsent(name.getAsString(), mat) != null) {
				log.error("Duplicate material name: '{}'", name);
				continue;
			}

			validMaterials.add(mat);
			if (parent != null)
				materialToParentMap.put(name.getAsString(), parent.getAsString());
		}

		// Check for parent loops
		var iter = materialToParentMap.entrySet().iterator();
		while (iter.hasNext()) {
			var entry = iter.next();
			var original = entry.getKey();
			var current = entry.getValue();
			while ((current = materialToParentMap.get(current)) != null) {
				if (current.equals(original)) {
					log.error("Material '{}' contains a parent loop. Removing its parent...", original);
					rawMaterialMap.get(original).remove("parent"); // Remove parent in-place
					iter.remove(); // No longer has a parent
				}
			}
		}

		// Recursively resolve parents and apply default values from them
		for (var mat : rawMaterialMap.values()) {
			var parent = mat;
			JsonElement parentField;
			while ((parentField = parent.get("parent")) != null) {
				if (!parentField.isJsonPrimitive() || !parentField.getAsJsonPrimitive().isString()) {
					log.error("Error in material '{}': Invalid parent name '{}'", parent.get("name").getAsString(), parentField);
					break;
				}
				String parentName = parentField.getAsString();
				// Don't allow inheriting from NONE. Those defaults will be inherited anyway
				if (parentName.equals(Material.NONE.name))
					break;

				var nextParent = rawMaterialMap.get(parentName);
				if (nextParent == null) {
					log.error(
						"Error in material '{}': Unknown parent name '{}'",
						parent.get("name").getAsString(),
						parentField.getAsString()
					);
					break;
				}

				for (var entry : nextParent.entrySet())
					if (!mat.has(entry.getKey()))
						mat.add(entry.getKey(), entry.getValue());

				parent = nextParent;
			}
		}

		var materialsToParse = new JsonArray();
		for (var mat : validMaterials)
			materialsToParse.add(mat);

		var materials = Stream.concat(
			Arrays.stream(Material.REQUIRED_MATERIALS),
			Arrays.stream(gson.fromJson(materialsToParse, Material.Definition[].class))
		).toArray(Material[]::new);

		var materialMap = new HashMap<String, Material>();
		int unnamedCounter = 1;
		for (var mat : materials) {
			if (mat.name == null)
				mat.name = "UNNAMED_" + unnamedCounter++;
			materialMap.put(mat.name, mat);

			if (Props.DEVELOPMENT && mat.replacementCondition instanceof ExpressionParser.SerializableExpressionPredicate) {
				// Ensure the variables are defined
				var expr = ((ExpressionParser.SerializableExpressionPredicate) mat.replacementCondition).expression;
				for (var variable : expr.variables)
					if (vars.get(variable) == null)
						throw new IllegalStateException(String.format("Unknown variable '%s' in expression: '%s'", variable, expr));
			}
		}

		for (var mat : materials)
			mat.normalize(materialMap);

		checkForReplacementLoops(materials);
		return materials;
	}

	private void swapMaterials(Material[] parsedMaterials) {
		assert client.isClientThread();
		assert textureManager.vanillaTexturesAvailable();

		boolean isFirstLoad = MATERIALS == null;
		var textureProvider = client.getTextureProvider();
		var vanillaTextures = textureProvider.getTextures();
		VANILLA_TEXTURE_MAPPING = new Material[vanillaTextures.length];

		// Assemble the material map, accounting for replacements
		MATERIAL_MAP.clear();
		for (var original : parsedMaterials) {
			// If the material is a conditional replacement material, and the condition is not met,
			// the material shouldn't be loaded and can be mapped to NONE
			Material replacement = original;
			if (original.isInactiveReplacement(plugin.vars)) {
				replacement = Material.NONE;
			} else {
				// Apply material replacements from top to bottom
				for (var other : parsedMaterials)
					if (other.replaces(replacement.name, plugin.vars))
						replacement = other;
			}

			MATERIAL_MAP.put(original.name, replacement);

			// Add to vanilla texture mappings if the original was a vanilla replacement
			if (original.isVanillaReplacement()) {
				int i = original.vanillaTextureIndex;
				assert VANILLA_TEXTURE_MAPPING[i] == null || VANILLA_TEXTURE_MAPPING[i] == replacement : String.format(
					"Material %s conflicts with vanilla ID %s of material %s", replacement, i, VANILLA_TEXTURE_MAPPING[i]);
				VANILLA_TEXTURE_MAPPING[i] = replacement;
			}
		}

		// Add dummy materials for any vanilla textures lacking one
		for (int i = 0; i < VANILLA_TEXTURE_MAPPING.length; i++) {
			if (vanillaTextures[i] == null || VANILLA_TEXTURE_MAPPING[i] != null)
				continue;

			var m = new Material()
				.name("VANILLA_" + i)
				.vanillaTextureIndex(i)
				.isFallbackVanillaMaterial(true)
				.hasTransparency(true);
			MATERIAL_MAP.put(m.name, m);
			VANILLA_TEXTURE_MAPPING[i] = m;
		}

		// Gather all unique materials after displacements into an array
		invalidateMaterials(MATERIALS);
		MATERIALS = MATERIAL_MAP.values().stream().distinct().toArray(Material[]::new);
		// Ensure that NONE is the first material
		for (int i = 0; i < MATERIALS.length; i++) {
			if (MATERIALS[i] == Material.NONE) {
				MATERIALS[i] = MATERIALS[0];
				MATERIALS[0] = Material.NONE;
				break;
			}
		}

		// Resolve all texture-owning materials, and update the list of texture layers
		var textureMaterials = Arrays.stream(MATERIALS)
			.map(Material::resolveTextureOwner)
			.distinct()
			.filter(m -> m != Material.NONE)
			.toArray(Material[]::new);
		int previousLayerCount = textureLayers.size();
		int textureLayerIndex = 0;
		for (var mat : textureMaterials) {
			TextureLayer layer;
			if (textureLayerIndex == textureLayers.size()) {
				layer = new TextureLayer();
				textureLayers.add(layer);
			} else {
				layer = textureLayers.get(textureLayerIndex);
				layer.needsUpload = !Objects.equals(mat.getTextureName(), layer.material.getTextureName());
			}
			layer.material = mat;
			mat.textureLayer = textureLayerIndex++;
		}
		// Delete unused layers
		textureLayers.subList(textureLayerIndex, textureLayers.size()).clear();
		// Update texture layers for materials which inherit their texture
		for (var mat : MATERIALS)
			mat.textureLayer = mat.resolveTextureOwner().textureLayer;

		int textureSize = config.textureResolution().getSize();
		textureResolution = ivec(textureSize, textureSize);
		glActiveTexture(TEXTURE_UNIT_GAME);
		if (texMaterialTextureArray == 0 || previousLayerCount != textureLayers.size()) {
			if (texMaterialTextureArray != 0)
				glDeleteTextures(texMaterialTextureArray);
			texMaterialTextureArray = glGenTextures();
			glBindTexture(GL_TEXTURE_2D_ARRAY, texMaterialTextureArray);

			// Since we're reallocating the texture array, all layers need to be reuploaded
			for (var layer : textureLayers)
				layer.needsUpload = true;

			log.debug("Allocating {}x{} texture array with {} layers", textureSize, textureSize, textureLayers.size());
			int mipLevels = 1 + floor(log2(textureSize));
			int format = GL_SRGB8_ALPHA8;
			if (HdPlugin.GL_CAPS.glTexStorage3D != 0) {
				ARBTextureStorage.glTexStorage3D(GL_TEXTURE_2D_ARRAY, mipLevels, format, textureSize, textureSize, textureLayers.size());
			} else {
				// Allocate each mip level separately
				for (int i = 0; i < mipLevels; i++) {
					int size = textureSize >> i;
					glTexImage3D(GL_TEXTURE_2D_ARRAY, i, format, size, size, textureLayers.size(), 0, GL_RGBA, GL_UNSIGNED_BYTE, 0);
				}
			}

			glTexParameteri(GL_TEXTURE_2D_ARRAY, GL_TEXTURE_WRAP_S, GL_REPEAT);
			glTexParameteri(GL_TEXTURE_2D_ARRAY, GL_TEXTURE_WRAP_T, GL_REPEAT);
		}
		textureManager.setAnisotropicFilteringLevel();

		uploadTextures();

		boolean materialOrderChanged = true;
		if (uboMaterials != null && uboMaterials.materials.length == MATERIALS.length) {
			materialOrderChanged = false;
			for (int i = 0; i < MATERIALS.length; i++) {
				var a = MATERIALS[i];
				var b = uboMaterials.materials[i];
				if (a.vanillaTextureIndex != b.vanillaTextureIndex ||
					a.modifiesVanillaTexture != b.modifiesVanillaTexture ||
					!a.name.equals(b.name)
				) {
					materialOrderChanged = true;
					break;
				}
			}
		} else {
			if (uboMaterials != null)
				uboMaterials.destroy();
			uboMaterials = new UBOMaterials(MATERIALS.length);
		}
		uboMaterials.update(MATERIALS, vanillaTextures);

		if (isFirstLoad)
			return;

		// Reload anything which depends on Material instances
		waterTypeManager.restart();
		groundMaterialManager.restart();
		tileOverrideManager.reload(false);
		modelOverrideManager.reload();

		if (materialOrderChanged) {
			modelPusher.clearModelCache();
			plugin.reuploadScene();
			plugin.recompilePrograms();
		}
	}

	private void invalidateMaterials(Material[] materials) {
		// Invalidate old materials to highlight issues with keeping them around accidentally
		if (materials != null)
			for (var mat : materials)
				if (mat != Material.NONE)
					mat.isValid = false;
	}

	public void uploadTextures() {
		assert client.isClientThread();
		if (texMaterialTextureArray == 0)
			return;

		// Set brightness to 1 to upload unmodified vanilla textures
		var textureProvider = client.getTextureProvider();
		double vanillaBrightness = textureProvider.getBrightness();
		textureProvider.setBrightness(1);

		boolean uploadedAnything = false;
		for (var layer : textureLayers) {
			if (!layer.needsUpload)
				continue;

			var material = layer.material;
			var image = textureManager.loadTexture(material.getTextureName(), material.vanillaTextureIndex);
			if (image == null)
				continue;

			try {
				if (!uploadedAnything) {
					glActiveTexture(TEXTURE_UNIT_GAME);
					glBindTexture(GL_TEXTURE_2D_ARRAY, texMaterialTextureArray);
					uploadedAnything = true;
				}
				textureManager.uploadTexture(GL_TEXTURE_2D_ARRAY, material.textureLayer, textureResolution, image);
			} catch (Exception ex) {
				log.error("Failed to upload texture {}:", material, ex);
			}
		}

		// Reset the texture brightness
		textureProvider.setBrightness(vanillaBrightness);

		if (uploadedAnything)
			glGenerateMipmap(GL_TEXTURE_2D_ARRAY);
	}

	private static void checkForReplacementLoops(Material[] materials) {
		Map<String, Material> map = new HashMap<>();
		for (var mat : materials)
			if (!mat.materialsToReplace.isEmpty())
				map.put(mat.name, mat);

		Set<String> alreadyChecked = new HashSet<>();
		for (var mat : map.values())
			checkForReplacementLoops(alreadyChecked, map, mat);
	}

	private static void checkForReplacementLoops(Set<String> alreadyChecked, Map<String, Material> map, Material entryMaterial) {
		if (alreadyChecked.add(entryMaterial.name))
			checkForReplacementLoops(alreadyChecked, map, new ArrayDeque<>(), entryMaterial.name, entryMaterial);
	}

	private static void checkForReplacementLoops(
		Set<String> alreadyChecked,
		Map<String, Material> map,
		ArrayDeque<String> loop,
		String entryPointName,
		Material toCheck
	) {
		loop.addLast(toCheck.findParent(m -> m.materialsToReplace).name);

		for (int i = toCheck.materialsToReplace.size() - 1; i >= 0; i--) {
			String nameToReplace = toCheck.materialsToReplace.get(i);
			// Check if the replacement introduces a loop
			if (entryPointName.equals(nameToReplace)) {
				var original = map.get(nameToReplace).findParent(m -> m.materialsToReplace).name;
				if (!nameToReplace.equals(original))
					nameToReplace += " (parent=" + original + ")";
				log.warn("Materials contain replacement loop: {} -> {}", String.join(" -> ", loop), nameToReplace);
				// Remove the loop
				toCheck.materialsToReplace.remove(i);
				continue;
			}

			var toReplace = map.get(nameToReplace);
			if (toReplace == null)
				continue;

			// Before continuing to check for loops back to the entrypoint name,
			// we need to rule out any loops within the next material to check,
			// so we don't get stuck in a loop there
			checkForReplacementLoops(alreadyChecked, map, toReplace);

			// The replacement might've already been removed to prevent a loop in the step above
			if (!toCheck.materialsToReplace.contains(nameToReplace))
				continue;

			// Check if any further replacements result in a loop
			checkForReplacementLoops(alreadyChecked, map, loop, entryPointName, toReplace);
		}

		loop.removeLast();
	}
}

package rs117.hd.scene;

import com.google.gson.TypeAdapter;
import com.google.gson.reflect.TypeToken;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Map;
import java.util.stream.Collectors;
import javax.inject.Inject;
import javax.inject.Singleton;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import rs117.hd.HdPlugin;
import rs117.hd.utils.FileWatcher;
import rs117.hd.utils.GsonUtils;
import rs117.hd.utils.Props;
import rs117.hd.utils.ResourcePath;

import static rs117.hd.utils.ResourcePath.path;

@Slf4j
@Singleton
public class GamevalManager {
	private static final ResourcePath GAMEVAL_PATH = Props
		.getFile("rlhd.gameval-path", () -> path(GamevalManager.class, "gamevals.json"));

	private static final String NPC_KEY = "npcs";
	private static final String OBJECT_KEY = "objects";
	private static final String ANIM_KEY = "anims";
	private static final String SPOTANIM_KEY = "spotanims";

	@Inject
	private HdPlugin plugin;

	private FileWatcher.UnregisterCallback fileWatcher;

	private static final Map<String, Map<String, Integer>> GAMEVALS = new HashMap<>();

	static {
		clearGamevals();
	}

	private static void clearGamevals() {
		GAMEVALS.put(NPC_KEY, Collections.emptyMap());
		GAMEVALS.put(OBJECT_KEY, Collections.emptyMap());
		GAMEVALS.put(ANIM_KEY, Collections.emptyMap());
		GAMEVALS.put(SPOTANIM_KEY, Collections.emptyMap());
	}

	public void startUp() throws IOException {
		fileWatcher = GAMEVAL_PATH.watch((path, first) -> {
			try {
				Map<String, Map<String, Integer>> gamevals = plugin.getGson()
					.fromJson(path.toReader(), new TypeToken<Map<String, Map<String, Integer>>>() {}.getType());
				GAMEVALS.replaceAll((k, v) -> gamevals.getOrDefault(k, Collections.emptyMap()));
				log.debug("Loaded gameval mappings");
			} catch (IOException ex) {
				log.error("Failed to load gamevals:", ex);
			}
		});
	}

	public void shutDown() {
		if (fileWatcher != null)
			fileWatcher.unregister();
		fileWatcher = null;
		clearGamevals();
	}

	private String getName(String key, int id) {
		return GAMEVALS
			.get(key)
			.entrySet()
			.stream()
			.filter(e -> e.getValue() == id)
			.map(Map.Entry::getKey)
			.findFirst()
			.orElse(null);
	}

	public Map<String, Integer> getNpcs() {
		return GAMEVALS.get(NPC_KEY);
	}

	public Map<String, Integer> getObjects() {
		return GAMEVALS.get(OBJECT_KEY);
	}

	public Map<String, Integer> getAnims() {
		return GAMEVALS.get(ANIM_KEY);
	}

	public Map<String, Integer> getSpotanims() {
		return GAMEVALS.get(SPOTANIM_KEY);
	}

	public int getNpcId(String name) {
		return getNpcs().get(name);
	}

	public int getObjectId(String name) {
		return getObjects().get(name);
	}

	public int getAnimId(String name) {
		return getAnims().get(name);
	}

	public int getSpotanimId(String name) {
		return getSpotanims().get(name);
	}

	public String getNpcName(int id) {
		return getName(NPC_KEY, id);
	}

	public String getObjectName(int id) {
		return getName(OBJECT_KEY, id);
	}

	public String getAnimName(int id) {
		return getName(ANIM_KEY, id);
	}

	public String getSpotanimName(int id) {
		return getName(SPOTANIM_KEY, id);
	}

	@Slf4j
	@RequiredArgsConstructor
	private abstract static class GamevalAdapter extends TypeAdapter<HashSet<Integer>> {
		private final String key;

		@Override
		public HashSet<Integer> read(JsonReader in) throws IOException {
			var map = GAMEVALS.get(key);
			HashSet<Integer> result = new HashSet<>();

			in.beginArray();
			while (in.hasNext()) {
				var type = in.peek();
				switch (type) {
					case NUMBER: {
						int id = in.nextInt();
						if (id != -1)
							log.debug("Adding raw {} ID: {} at {}. Should be replaced with a gameval.", key, id, GsonUtils.location(in));
						result.add(id);
						break;
					}
					case STRING:
						String name = in.nextString();
						Integer id = map.get(name);
						if (id == null) {
							String suggestion = "";
							for (var gamevalMapEntry : GAMEVALS.entrySet()) {
								if (gamevalMapEntry.getValue().get(name) != null) {
									suggestion = String.format(", did you mean to match %s?", gamevalMapEntry.getKey());
									break;
								}
							}
							log.error("Missing {} gameval: {}{} at {}", key, name, suggestion, GsonUtils.location(in), new Throwable());
						} else {
							result.add(id);
						}
						break;
					default:
						log.error("Unexpected {} gameval type: {} at {}", key, type, GsonUtils.location(in), new Throwable());
						break;
				}
			}
			in.endArray();

			return result;
		}

		@Override
		public void write(JsonWriter out, HashSet<Integer> ids) throws IOException {
			var remainingIds = new ArrayList<>(ids);
			var map = GAMEVALS.get(key);
			var names = map.entrySet().stream()
				.filter(e -> remainingIds.remove(e.getValue()))
				.map(Map.Entry::getKey)
				.sorted()
				.toArray(String[]::new);

			if (!remainingIds.isEmpty()) {
				remainingIds.sort(Integer::compareTo);
				log.warn(
					"Exporting IDs with no corresponding gamevals: {}", remainingIds.stream()
						.filter(i -> i != -1)
						.map(Object::toString)
						.collect(Collectors.joining(", "))
				);
			}

			out.beginArray();
			for (var id : remainingIds)
				out.value(id);
			for (var name : names)
				out.value(name);
			out.endArray();
		}
	}

	public static class NpcAdapter extends GamevalAdapter {
		public NpcAdapter() {
			super(NPC_KEY);
		}
	}

	public static class ObjectAdapter extends GamevalAdapter {
		public ObjectAdapter() {
			super(OBJECT_KEY);
		}
	}

	public static class AnimationAdapter extends GamevalAdapter {
		public AnimationAdapter() {
			super(ANIM_KEY);
		}
	}

	public static class SpotanimAdapter extends GamevalAdapter {
		public SpotanimAdapter() {
			super(SPOTANIM_KEY);
		}
	}
}

package rs117.hd.scene;

import com.google.common.collect.Sets;
import java.util.Arrays;
import java.util.HashMap;
import java.util.Map;
import java.util.Set;
import javax.inject.Inject;
import net.runelite.api.*;
import net.runelite.api.events.*;
import net.runelite.client.eventbus.EventBus;
import net.runelite.client.eventbus.Subscribe;
import rs117.hd.HdPlugin;
import rs117.hd.HdPluginConfig;
import rs117.hd.config.FishingSpotStyle;
import rs117.hd.overlays.FrameTimer;
import rs117.hd.overlays.Timer;
import rs117.hd.scene.model_overrides.ModelOverride;

import static rs117.hd.utils.ColorUtils.hsl;
import static rs117.hd.utils.MathUtils.*;

public class FishingSpotReplacer {
	private static final int FISHING_SPOT_MODEL_ID = 41238;
	private static final int FISHING_SPOT_ANIMATION_ID = 10793;
	private static final int LAVA_SPOT_MODEL_ID = 2331;
	private static final int LAVA_SPOT_ANIMATION_ID = 525;
	private static final int LAVA_SPOT_COLOR = hsl("#837574");

	// @formatter:off
	private static final Set<Integer> FISHING_SPOT_IDS = Set.of(394, 635, 1506, 1507, 1508, 1509, 1510, 1511, 1512, 1513, 1514, 1515, 1516, 1517, 1518, 1519, 1520, 1521, 1522, 1523, 1524, 1525, 1526, 1527, 1528, 1529, 1530, 1531, 1532, 1533, 1534, 1535, 1536, 1542, 1544, 2146, 2653, 2654, 2655, 3317, 3417, 3418, 3419, 3657, 3913, 3914, 3915, 4079, 4080, 4081, 4082, 4316, 4476, 4477, 4710, 4711, 4712, 4713, 4714, 5233, 5234, 5820, 5821, 6731, 6825, 7155, 7199, 7200, 7323, 7459, 7460, 7461, 7462, 7463, 7464, 7465, 7466, 7467, 7468, 7469, 7470, 7946, 7947, 8524, 8525, 8526, 8527, 9171, 9172, 9173, 9174, 9478, 12267);
	private static final Set<Integer> LAVA_FISHING_SPOT_IDS = Set.of(4928);
	// @formatter:on
	private static final Set<Integer> NPC_IDS = Sets.union(FISHING_SPOT_IDS, LAVA_FISHING_SPOT_IDS).immutableCopy();

	@Inject
	private Client client;

	@Inject
	private EventBus eventBus;

	@Inject
	private HdPlugin plugin;

	@Inject
	private HdPluginConfig config;

	@Inject
	private TileOverrideManager tileOverrideManager;

	@Inject
	private FrameTimer frameTimer;

	private final Map<Integer, RuneLiteObject> npcIndexToModel = new HashMap<>();

	public void startUp() {
		eventBus.register(this);
	}

	public void shutDown() {
		eventBus.unregister(this);
		despawnRuneLiteObjects();
	}

	public void despawnRuneLiteObjects() {
		for (var obj : npcIndexToModel.values())
			obj.setActive(false);
		npcIndexToModel.clear();
	}

	public ModelOverride getModelOverride() {
		if (config.fishingSpotStyle() != FishingSpotStyle.HD)
			return null;

		ModelOverride override = new ModelOverride();
		override.hide = true;
		override.npcIds = NPC_IDS;
		return override;
	}

	public void update() {
		if (config.fishingSpotStyle() == FishingSpotStyle.VANILLA)
			return;

		var sceneContext = plugin.getSceneContext();
		if (sceneContext == null)
			return;

		frameTimer.begin(Timer.REPLACE_FISHING_SPOTS);

		var worldView = client.getTopLevelWorldView();
		var npcs = worldView.npcs();
		var modelsToDespawn = new HashMap<>(npcIndexToModel);
		for (NPC npc : npcs) {
			if (!NPC_IDS.contains(npc.getId()))
				continue;

			var model = modelsToDespawn.remove(npc.getIndex());
			if (model == null) {
				// No fishing spot replacement associated with the NPC yet, so spawn one
				spawnFishingSpot(sceneContext, npc);
			} else {
				// Already associated with a fishing spot replacement, so let's update its position
				model.setLocation(npc.getLocalLocation(), worldView.getPlane());
			}
		}

		for (var entry : modelsToDespawn.entrySet()) {
			// Despawn the RuneLiteObject and stop tracking the index
			entry.getValue().setActive(false);
			npcIndexToModel.remove(entry.getKey());
		}

		frameTimer.end(Timer.REPLACE_FISHING_SPOTS);
	}

	@Subscribe
	public void onNpcSpawned(NpcSpawned npcSpawned) {
		var sceneContext = plugin.getSceneContext();
		var npc = npcSpawned.getNpc();
		if (sceneContext != null && NPC_IDS.contains(npc.getId()))
			spawnFishingSpot(sceneContext, npc);
	}

	public void spawnFishingSpot(SceneContext sceneContext, NPC npc) {
		if (npcIndexToModel.containsKey(npc.getIndex()))
			return;

		AnimationController animController;
		int modelId;
		int recolor = -1;
		if (LAVA_FISHING_SPOT_IDS.contains(npc.getId())) {
			animController = new AnimationController(client, LAVA_SPOT_ANIMATION_ID);
			modelId = LAVA_SPOT_MODEL_ID;
			recolor = LAVA_SPOT_COLOR;
		} else {
			animController = new AnimationController(client, FISHING_SPOT_ANIMATION_ID);
			modelId = FISHING_SPOT_MODEL_ID;
			var lp = npc.getLocalLocation();
			if (lp.isInScene()) {
				var worldView = client.getTopLevelWorldView();
				int plane = worldView.getPlane();
				Tile tile = worldView.getScene().getTiles()[plane][lp.getSceneX()][lp.getSceneY()];
				recolor = tileOverrideManager.getOverride(sceneContext, tile).waterType.fishingSpotRecolor;
			}
		}

		ModelData modelData = client.loadModelData(modelId);
		if (modelData == null)
			return;

		if (recolor != -1) {
			modelData = modelData.cloneColors();
			Arrays.fill(modelData.getFaceColors(), (short) recolor);
		}

		var anim = animController.getAnimation();
		if (anim != null)
			animController.setFrame(RAND.nextInt(anim.getDuration()));

		RuneLiteObject fishingSpot = client.createRuneLiteObject();
		fishingSpot.setAnimationController(animController);
		fishingSpot.setOrientation(RAND.nextInt(5) * 512);
		fishingSpot.setDrawFrontTilesFirst(false);
		fishingSpot.setActive(true);
		fishingSpot.setModel(modelData.light());
		npcIndexToModel.put(npc.getIndex(), fishingSpot);
	}
}

package rs117.hd.scene;

import com.google.common.collect.ArrayListMultimap;
import com.google.common.collect.ListMultimap;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Map;
import java.util.Objects;
import java.util.stream.Stream;
import javax.annotation.Nullable;
import net.runelite.api.*;
import net.runelite.api.coords.*;
import rs117.hd.scene.areas.AABB;
import rs117.hd.scene.areas.Area;
import rs117.hd.scene.environments.Environment;
import rs117.hd.scene.lights.Light;
import rs117.hd.scene.lights.TileObjectImpostorTracker;
import rs117.hd.scene.materials.Material;
import rs117.hd.scene.tile_overrides.TileOverrideVariables;
import rs117.hd.utils.HDUtils;
import rs117.hd.utils.buffer.GpuFloatBuffer;
import rs117.hd.utils.buffer.GpuIntBuffer;

import static net.runelite.api.Constants.*;
import static net.runelite.api.Constants.SCENE_SIZE;
import static net.runelite.api.Perspective.*;
import static rs117.hd.HdPlugin.UV_SIZE;
import static rs117.hd.HdPlugin.VERTEX_SIZE;
import static rs117.hd.utils.MathUtils.*;

public class SceneContext {
	public static final int SCENE_OFFSET = (EXTENDED_SCENE_SIZE - SCENE_SIZE) / 2;

	public final int id = RAND.nextInt() & SceneUploader.SCENE_ID_MASK;
	public final Client client;
	public final Scene scene;
	public final int expandedMapLoadingChunks;

	@Nullable
	public final int[] sceneBase;
	public final AABB sceneBounds;

	public boolean enableAreaHiding;
	public boolean forceDisableAreaHiding;
	public boolean fillGaps;
	public boolean isPrepared;

	@Nullable
	public Area currentArea;
	public Area[] possibleAreas = new Area[0];
	public final ArrayList<Environment> environments = new ArrayList<>();
	public byte[][] filledTiles = new byte[EXTENDED_SCENE_SIZE][EXTENDED_SCENE_SIZE];

	public int staticVertexCount = 0;
	public GpuIntBuffer staticUnorderedModelBuffer;
	public GpuIntBuffer stagingBufferVertices;
	public GpuFloatBuffer stagingBufferUvs;
	public GpuFloatBuffer stagingBufferNormals;

	public int staticGapFillerTilesOffset;
	public int staticGapFillerTilesVertexCount;
	public int staticCustomTilesOffset;
	public int staticCustomTilesVertexCount;

	// Statistics
	public int uniqueModels;

	// Terrain data
	public Map<Integer, Integer> vertexTerrainColor;
	public Map<Integer, Material> vertexTerrainTexture;
	public Map<Integer, float[]> vertexTerrainNormals;
	// Used for overriding potentially low quality vertex colors
	public HashMap<Integer, Boolean> highPriorityColor;

	// Water-related data
	public boolean[][][] tileIsWater;
	public Map<Integer, Boolean> vertexIsWater;
	public Map<Integer, Boolean> vertexIsLand;
	public Map<Integer, Boolean> vertexIsOverlay;
	public Map<Integer, Boolean> vertexIsUnderlay;
	public boolean[][][] skipTile;
	public Map<Integer, Integer> vertexUnderwaterDepth;
	public int[][][] underwaterDepthLevels;

	// Thread safe tile override variables
	public final TileOverrideVariables tileOverrideVars = new TileOverrideVariables();

	public int numVisibleLights = 0;
	public final ArrayList<Light> lights = new ArrayList<>();
	public final HashSet<Projectile> knownProjectiles = new HashSet<>();
	public final HashMap<TileObject, TileObjectImpostorTracker> trackedTileObjects = new HashMap<>();
	public final ListMultimap<Integer, TileObjectImpostorTracker> trackedVarps = ArrayListMultimap.create();
	public final ListMultimap<Integer, TileObjectImpostorTracker> trackedVarbits = ArrayListMultimap.create();

	// Model pusher arrays, to avoid simultaneous usage from different threads
	public final int[] modelFaceVertices = new int[12];
	public final float[] modelFaceNormals = new float[12];
	public final int[] modelPusherResults = new int[2];

	public SceneContext(Client client, Scene scene, int expandedMapLoadingChunks, boolean reuseBuffers, @Nullable SceneContext previous) {
		this.client = client;
		this.scene = scene;
		this.expandedMapLoadingChunks = expandedMapLoadingChunks;
		sceneBase = findSceneBase();
		sceneBounds = findSceneBounds(sceneBase);

		if (previous == null) {
			staticUnorderedModelBuffer = new GpuIntBuffer();
			stagingBufferVertices = new GpuIntBuffer();
			stagingBufferUvs = new GpuFloatBuffer();
			stagingBufferNormals = new GpuFloatBuffer();
		} else {
			// If area hiding was determined to be incorrect previously, keep it disabled
			forceDisableAreaHiding = previous.forceDisableAreaHiding;

			if (reuseBuffers) {
				// Avoid reallocating buffers whenever possible
				staticUnorderedModelBuffer = previous.staticUnorderedModelBuffer.clear();
				stagingBufferVertices = previous.stagingBufferVertices.clear();
				stagingBufferUvs = previous.stagingBufferUvs.clear();
				stagingBufferNormals = previous.stagingBufferNormals.clear();
				previous.staticUnorderedModelBuffer = null;
				previous.stagingBufferVertices = null;
				previous.stagingBufferUvs = null;
				previous.stagingBufferNormals = null;
			} else {
				staticUnorderedModelBuffer = new GpuIntBuffer(previous.staticUnorderedModelBuffer.capacity());
				stagingBufferVertices = new GpuIntBuffer(previous.stagingBufferVertices.capacity());
				stagingBufferUvs = new GpuFloatBuffer(previous.stagingBufferUvs.capacity());
				stagingBufferNormals = new GpuFloatBuffer(previous.stagingBufferNormals.capacity());
			}
		}
	}

	public synchronized void destroy() {
		if (staticUnorderedModelBuffer != null)
			staticUnorderedModelBuffer.destroy();
		staticUnorderedModelBuffer = null;

		if (stagingBufferVertices != null)
			stagingBufferVertices.destroy();
		stagingBufferVertices = null;

		if (stagingBufferUvs != null)
			stagingBufferUvs.destroy();
		stagingBufferUvs = null;

		if (stagingBufferNormals != null)
			stagingBufferNormals.destroy();
		stagingBufferNormals = null;
	}

	public int getVertexOffset() {
		return stagingBufferVertices.position() / VERTEX_SIZE;
	}

	public int getUvOffset() {
		return stagingBufferUvs.position() / UV_SIZE;
	}

	/**
	 * Transform local coordinates into world coordinates.
	 * If the {@link LocalPoint} is not in the scene, this returns untranslated coordinates when in instances.
	 *
	 * @param localPoint to transform
	 * @param plane      which the local coordinate is on
	 * @return world coordinate
	 */
	public int[] localToWorld(LocalPoint localPoint, int plane) {
		return localToWorld(localPoint.getX(), localPoint.getY(), plane);
	}

	public int[] localToWorld(LocalPoint localPoint) {
		return localToWorld(localPoint, client.getPlane());
	}

	public int[] localToWorld(int localX, int localY) {
		return localToWorld(localX, localY, client.getPlane());
	}

	public int[] localToWorld(int localX, int localY, int plane) {
		return sceneToWorld(localX >> LOCAL_COORD_BITS, localY >> LOCAL_COORD_BITS, plane);
	}

	public int[] sceneToWorld(int sceneX, int sceneY, int plane) {
		if (sceneBase == null)
			return HDUtils.sceneToWorld(scene, sceneX, sceneY, plane);
		return ivec(
			sceneBase[0] + sceneX,
			sceneBase[1] + sceneY,
			sceneBase[2] + plane
		);
	}

	public int[] extendedSceneToWorld(int sceneExX, int sceneExY, int plane) {
		return sceneToWorld(sceneExX - SCENE_OFFSET, sceneExY - SCENE_OFFSET, plane);
	}

	public Stream<int[]> worldToLocals(WorldPoint worldPoint) {
		if (sceneBase != null)
			return Stream.of(worldToLocal(worldPoint));
		// If the scene is not contiguous, convert the world point to world points within the instance, then to local coords
		return WorldPoint.toLocalInstance(scene, worldPoint)
			.stream()
			.filter(Objects::nonNull)
			.map(instancePoint -> ivec(
				(instancePoint.getX() - scene.getBaseX()) * LOCAL_TILE_SIZE,
				(instancePoint.getY() - scene.getBaseY()) * LOCAL_TILE_SIZE,
				instancePoint.getPlane()
			));
	}

	/**
	 * Gets the local coordinate at the south-western corner of the tile, if the scene is contiguous, otherwise null
	 */
	@Nullable
	public int[] worldToLocal(WorldPoint worldPoint) {
		if (sceneBase == null)
			return null;
		return ivec(
			(worldPoint.getX() - sceneBase[0]) * LOCAL_TILE_SIZE,
			(worldPoint.getY() - sceneBase[1]) * LOCAL_TILE_SIZE,
			worldPoint.getPlane()
		);
	}

	public boolean intersects(Area area) {
		return intersects(area.aabbs);
	}

	public boolean intersects(AABB... aabbs) {
		return HDUtils.sceneIntersects(scene, expandedMapLoadingChunks, aabbs);
	}

	public AABB getNonInstancedSceneBounds() {
		return HDUtils.getNonInstancedSceneBounds(scene, expandedMapLoadingChunks);
	}

	public int getObjectConfig(Tile tile, long hash) {
		if (tile.getWallObject() != null && tile.getWallObject().getHash() == hash)
			return tile.getWallObject().getConfig();
		if (tile.getDecorativeObject() != null && tile.getDecorativeObject().getHash() == hash)
			return tile.getDecorativeObject().getConfig();
		if (tile.getGroundObject() != null && tile.getGroundObject().getHash() == hash)
			return tile.getGroundObject().getConfig();
		for (GameObject gameObject : tile.getGameObjects())
			if (gameObject != null && gameObject.getHash() == hash)
				return gameObject.getConfig();
		return -1;
	}

	/**
	 * Returns the south-west coordinate of the scene in world coordinates, after resolving instance template chunks
	 * to their original world coordinates. If the scene is instanced, this returns null when the chunks aren't contiguous.
	 */
	@Nullable
	private int[] findSceneBase() {
		int baseX = scene.getBaseX();
		int baseY = scene.getBaseY();
		int basePlane = 0;

		if (scene.isInstance()) {
			boolean foundChunk = false;

			int[][][] chunks = scene.getInstanceTemplateChunks();
			for (int plane = 0; plane < chunks.length; plane++) {
				for (int x = 0; x < chunks[plane].length; x++) {
					for (int y = 0; y < chunks[plane][x].length; y++) {
						int chunk = chunks[plane][x][y];
						if (chunk == -1)
							continue; // Ignore unfilled chunks

						// Ensure the chunk isn't rotated (although we technically could handle consistent rotation)
						int rotation = chunk >> 1 & 0x3;
						if (rotation != 0)
							return null;

						int chunkX = chunk >> 14 & 0x3FF;
						int chunkY = chunk >> 3 & 0x7FF;
						int chunkPlane = chunk >> 24 & 0x3;

						if (foundChunk) {
							int expectedX = baseX + x;
							int expectedY = baseY + y;
							int expectedPlane = basePlane + plane;
							if (chunkX != expectedX || chunkY != expectedY || chunkPlane != expectedPlane)
								return null; // Not contiguous
						} else {
							// Calculate the expected unextended scene base chunk
							baseX = chunkX - x;
							baseY = chunkY - y;
							basePlane = chunkPlane - plane;
							foundChunk = true;
						}
					}
				}
			}

			if (!foundChunk)
				return null;

			// Transform chunk to world coordinates
			baseX <<= 3;
			baseY <<= 3;
		}

		return ivec(baseX, baseY, basePlane);
	}

	/**
	 * Works for non-instanced scenes & contiguous instanced scenes.
	 * Returns a best attempt for non-contiguous instanced scenes, which may be
	 * significantly larger than necessary, but will always include all tiles.
	 */
	private AABB findSceneBounds(@Nullable int[] sceneBase) {
		if (sceneBase != null) {
			int x = sceneBase[0] - SCENE_OFFSET;
			int y = sceneBase[1] - SCENE_OFFSET;
			return new AABB(x, y, x + EXTENDED_SCENE_SIZE - 1, y + EXTENDED_SCENE_SIZE - 1);
		}

		// Assume instances are assembled from approximately adjacent chunks on the map
		int minX = Integer.MAX_VALUE;
		int minY = Integer.MAX_VALUE;
		int minZ = MAX_Z;
		int maxX = Integer.MIN_VALUE;
		int maxY = Integer.MIN_VALUE;
		int maxZ = 0;

		int[][][] chunks = scene.getInstanceTemplateChunks();
		for (int[][] plane : chunks) {
			for (int[] column : plane) {
				for (int chunk : column) {
					if (chunk == -1)
						continue;

					// Extract chunk coordinates
					int x = chunk >> 14 & 0x3FF;
					int y = chunk >> 3 & 0x7FF;
					int z = chunk >> 24 & 0x3;
					minX = min(minX, x);
					minY = min(minY, y);
					minZ = min(minZ, z);
					maxX = max(maxX, x);
					maxY = max(maxY, y);
					maxZ = max(maxZ, z);
				}
			}
		}

		// Return an AABB representing no match, if there are no chunks
		if (maxX < minX)
			return new AABB(-1, -1);

		// Transform from chunk to world coordinates
		return new AABB(minX << 3, minY << 3, minZ, (maxX << 3) + CHUNK_SIZE - 1, (maxY << 3) + CHUNK_SIZE - 1, maxZ);
	}
}

package rs117.hd.scene;

import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonToken;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import javax.annotation.Nonnull;
import javax.inject.Inject;
import javax.inject.Singleton;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.*;
import net.runelite.client.callback.ClientThread;
import rs117.hd.HdPlugin;
import rs117.hd.model.ModelPusher;
import rs117.hd.scene.areas.Area;
import rs117.hd.utils.FileWatcher;
import rs117.hd.utils.GsonUtils;
import rs117.hd.utils.Props;
import rs117.hd.utils.ResourcePath;

import static rs117.hd.utils.ResourcePath.path;

@Slf4j
@Singleton
public class AreaManager {
	private static final ResourcePath AREA_PATH = Props
		.getFile("rlhd.area-path", () -> path(AreaManager.class, "areas.json"));

	@Inject
	private Client client;

	@Inject
	private ClientThread clientThread;

	@Inject
	private HdPlugin plugin;

	@Inject
	private EnvironmentManager environmentManager;

	@Inject
	private TileOverrideManager tileOverrideManager;

	@Inject
	private ModelOverrideManager modelOverrideManager;

	@Inject
	private LightManager lightManager;

	@Inject
	private ModelPusher modelPusher;

	private FileWatcher.UnregisterCallback fileWatcher;

	public static Area[] AREAS = new Area[0];

	public Area[] areasWithAreaHiding = new Area[0];

	public void startUp() {
		fileWatcher = AREA_PATH.watch((path, first) -> {
			try {
				Area[] areas = path.loadJson(plugin.getGson(), Area[].class);
				if (areas == null)
					throw new IOException("Empty or invalid: " + path);

				clientThread.invoke(() -> {
					AREAS = Arrays.copyOf(areas, areas.length + 2);
					AREAS[AREAS.length - 2] = Area.ALL;
					AREAS[AREAS.length - 1] = Area.NONE;

					ArrayList<Area> areasWithAreaHiding = new ArrayList<>();
					for (Area area : areas) {
						area.normalize();
						if (area.hideOtherAreas)
							areasWithAreaHiding.add(area);
					}
					this.areasWithAreaHiding = areasWithAreaHiding.toArray(Area[]::new);

					Area.OVERWORLD = getArea("OVERWORLD");

					log.debug("Loaded {} areas", areas.length);

					if (!first) {
						// Reload everything which depends on area definitions
						modelPusher.clearModelCache();
						tileOverrideManager.shutDown();
						modelOverrideManager.shutDown();
						lightManager.shutDown();
						environmentManager.shutDown();

						tileOverrideManager.startUp();
						modelOverrideManager.startUp();
						lightManager.startUp();
						environmentManager.startUp();

						// Force reload the scene to reapply area hiding
						if (client.getGameState() == GameState.LOGGED_IN)
							client.setGameState(GameState.LOADING);
					}
				});
			} catch (IOException ex) {
				log.error("Failed to load areas:", ex);
			}
		});
	}

	public void shutDown() {
		if (fileWatcher != null)
			fileWatcher.unregister();
		fileWatcher = null;
		AREAS = new Area[0];
	}

	@Nonnull
	public Area getArea(String name) {
		for (Area area : AREAS)
			if (name.equals(area.name))
				return area;
		return Area.NONE;
	}

	@Slf4j
	public static class Adapter extends TypeAdapter<Area> {
		@Override
		public Area read(JsonReader in) throws IOException {
			var token = in.peek();
			if (token == JsonToken.NULL)
				return null;

			if (token == JsonToken.BEGIN_OBJECT)
				throw new IllegalStateException(
					"This is only meant for mapping area names to existing areas, not parse new ones. Unexpected token " + token + " at "
					+ GsonUtils.location(in));

			if (token != JsonToken.STRING) {
				log.warn("Expected an area name instead of {} at {}", token, GsonUtils.location(in), new Throwable());
				return Area.NONE;
			}

			var str = in.nextString();
			for (Area area : AREAS)
				if (str.equals(area.name))
					return area;

			log.warn("No area exists with the name '{}' at {}", str, GsonUtils.location(in), new Throwable());
			return Area.NONE;
		}

		@Override
		public void write(JsonWriter out, Area area) throws IOException {
			if (area == null) {
				out.nullValue();
			} else {
				out.value(area.name);
			}
		}
	}
}

package rs117.hd.scene.model_overrides;

public enum InheritTileColorType
{
	NONE, OVERLAY, UNDERLAY
}

package rs117.hd.scene.model_overrides;

import com.google.gson.JsonArray;
import com.google.gson.JsonElement;
import com.google.gson.annotations.JsonAdapter;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;
import lombok.AllArgsConstructor;
import lombok.NoArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.*;
import rs117.hd.config.SeasonalTheme;
import rs117.hd.config.VanillaShadowMode;
import rs117.hd.scene.GamevalManager;
import rs117.hd.scene.areas.AABB;
import rs117.hd.scene.materials.Material;
import rs117.hd.utils.Props;

import static net.runelite.api.Perspective.*;
import static rs117.hd.utils.ExpressionParser.asExpression;
import static rs117.hd.utils.ExpressionParser.parseExpression;
import static rs117.hd.utils.MathUtils.*;

@Slf4j
@NoArgsConstructor
@AllArgsConstructor
public class ModelOverride
{
	public static final ModelOverride NONE = new ModelOverride(true);

	private static final Set<Integer> EMPTY = new HashSet<>();

	public String description = "UNKNOWN";

	// When, where or what the override should apply to
	public SeasonalTheme seasonalTheme;
	@JsonAdapter(AABB.ArrayAdapter.class)
	public AABB[] areas = {};
	@JsonAdapter(GamevalManager.NpcAdapter.class)
	public Set<Integer> npcIds = EMPTY;
	@JsonAdapter(GamevalManager.ObjectAdapter.class)
	public Set<Integer> objectIds = EMPTY;
	@JsonAdapter(GamevalManager.SpotanimAdapter.class)
	public Set<Integer> projectileIds = EMPTY;
	@JsonAdapter(GamevalManager.SpotanimAdapter.class)
	public Set<Integer> graphicsObjectIds = EMPTY;

	public Material baseMaterial = Material.NONE;
	public Material textureMaterial = Material.NONE;
	public UvType uvType = UvType.VANILLA;
	public float uvScale = 1;
	public int uvOrientation = 0;
	public int uvOrientationX = 0;
	public int uvOrientationY = 0;
	public int uvOrientationZ = 0;
	public int rotate = 0;
	public boolean hide = false;
	public boolean retainVanillaUvs = true;
	public boolean forceMaterialChanges = false;
	public boolean flatNormals = false;
	public boolean upwardsNormals = false;
	public boolean hideVanillaShadows = false;
	public boolean retainVanillaShadowsInPvm = false;
	public boolean hideHdShadowsInPvm = false;
	public boolean castShadows = true;
	public boolean receiveShadows = true;
	public boolean terrainVertexSnap = false;
	public float shadowOpacityThreshold = 0;
	public TzHaarRecolorType tzHaarRecolorType = TzHaarRecolorType.NONE;
	public InheritTileColorType inheritTileColorType = InheritTileColorType.NONE;
	public WindDisplacement windDisplacementMode = WindDisplacement.DISABLED;
	public int windDisplacementModifier = 0;
	public boolean invertDisplacementStrength = false;

	@JsonAdapter(AABB.ArrayAdapter.class)
	public AABB[] hideInAreas = {};

	public Map<Material, ModelOverride> materialOverrides;
	public ModelOverride[] colorOverrides;

	private JsonElement colors;

	public transient boolean isDummy;
	public transient Map<AABB, ModelOverride> areaOverrides;
	public transient AhslPredicate ahslCondition;

	@FunctionalInterface
	public interface AhslPredicate {
		boolean test(int ahsl);
	}

	public void normalize(VanillaShadowMode vanillaShadowMode) {
		// Ensure there are no nulls in case of invalid configuration during development
		if (baseMaterial == null) {
			if (Props.DEVELOPMENT)
				throw new IllegalStateException("Invalid baseMaterial");
			baseMaterial = ModelOverride.NONE.baseMaterial;
		}
		if (textureMaterial == null) {
			if (Props.DEVELOPMENT)
				throw new IllegalStateException("Invalid textureMaterial");
			textureMaterial = ModelOverride.NONE.textureMaterial;
		}
		if (uvType == null) {
			if (Props.DEVELOPMENT)
				throw new IllegalStateException("Invalid uvType");
			uvType = ModelOverride.NONE.uvType;
		}
		if (tzHaarRecolorType == null) {
			if (Props.DEVELOPMENT)
				throw new IllegalStateException("Invalid tzHaarRecolorType");
			tzHaarRecolorType = ModelOverride.NONE.tzHaarRecolorType;
		}
		if (inheritTileColorType == null) {
			if (Props.DEVELOPMENT)
				throw new IllegalStateException("Invalid inheritTileColorType");
			inheritTileColorType = ModelOverride.NONE.inheritTileColorType;
		}
		if (windDisplacementMode == null) {
			if (Props.DEVELOPMENT)
				throw new IllegalStateException("Invalid windDisplacementMode");
			windDisplacementMode = ModelOverride.NONE.windDisplacementMode;
		}

		if (windDisplacementModifier < -3 || windDisplacementModifier > 3) {
			if (Props.DEVELOPMENT)
				throw new IllegalStateException("Invalid windDisplacementModifier (range is -3 to 3)");
			windDisplacementModifier = clamp(windDisplacementModifier, -3, 3);
		}

		if (areas == null)
			areas = new AABB[0];
		if (hideInAreas == null)
			hideInAreas = new AABB[0];

		if (materialOverrides != null) {
			var normalized = new HashMap<Material, ModelOverride>();
			for (var entry : materialOverrides.entrySet()) {
				var override = entry.getValue();
				override.normalize(vanillaShadowMode);
				normalized.put(entry.getKey(), override);
			}
			materialOverrides = normalized;
		}

		if (colorOverrides != null) {
			for (var override : colorOverrides) {
				override.normalize(vanillaShadowMode);
				override.ahslCondition = parseAhslConditions(override.colors);
			}
		}

		if (uvOrientationX == 0)
			uvOrientationX = uvOrientation;
		if (uvOrientationY == 0)
			uvOrientationY = uvOrientation;
		if (uvOrientationZ == 0)
			uvOrientationZ = uvOrientation;

		if (retainVanillaShadowsInPvm) {
			if (vanillaShadowMode.retainInPvm)
				hideVanillaShadows = false;
			if (vanillaShadowMode == VanillaShadowMode.PREFER_IN_PVM && hideHdShadowsInPvm)
				castShadows = false;
		}

		if (!castShadows && shadowOpacityThreshold == 0)
			shadowOpacityThreshold = 1;
	}

	public ModelOverride copy() {
		return new ModelOverride(
			description,
			seasonalTheme,
			areas,
			npcIds,
			objectIds,
			projectileIds,
			graphicsObjectIds,
			baseMaterial,
			textureMaterial,
			uvType,
			uvScale,
			uvOrientation,
			uvOrientationX,
			uvOrientationY,
			uvOrientationZ,
			rotate,
			hide,
			retainVanillaUvs,
			forceMaterialChanges,
			flatNormals,
			upwardsNormals,
			hideVanillaShadows,
			retainVanillaShadowsInPvm,
			hideHdShadowsInPvm,
			castShadows,
			receiveShadows,
			terrainVertexSnap,
			shadowOpacityThreshold,
			tzHaarRecolorType,
			inheritTileColorType,
			windDisplacementMode,
			windDisplacementModifier,
			invertDisplacementStrength,
			hideInAreas,
			materialOverrides,
			colorOverrides,
			colors,
			isDummy,
			areaOverrides,
			ahslCondition
		);
	}

	private ModelOverride(boolean isDummy) {
		this();
		this.isDummy = isDummy;
	}

	private AhslPredicate parseAhslConditions(JsonElement element) {
		if (element == null)
			return ahsl -> false;

		JsonArray arr;
		if (element.isJsonArray()) {
			arr = element.getAsJsonArray();
		} else {
			arr = new JsonArray();
			arr.add(element);
		}

		AhslPredicate combinedPredicate = null;

		for (var el : arr) {
			if (el.isJsonNull())
				continue;
			if (!el.isJsonPrimitive()) {
				log.warn("Skipping unexpected HSL condition '{}' in override '{}'", el, description);
				continue;
			}

			AhslPredicate condition;
			var prim = el.getAsJsonPrimitive();
			if (prim.isBoolean()) {
				boolean bool = prim.getAsBoolean();
				condition = ahsl -> bool;
			} else if (prim.isNumber()) {
				try {
					int targetHsl = prim.getAsInt();
					condition = ahsl -> (ahsl & 0xFFFF) == targetHsl;
				} catch (Exception ex) {
					log.warn("Expected integer, but got {} in override '{}'", el, description);
					continue;
				}
			} else if (prim.isString()) {
				var expr = asExpression(parseExpression(prim.getAsString()));

				if (Props.DEVELOPMENT) {
					// Ensure all variables are defined
					final Set<String> knownVariables = Set.of("a", "h", "s", "l", "hsl", "ahsl");
					for (var variable : expr.variables)
						if (!knownVariables.contains(variable))
							throw new IllegalStateException(
								"Expression '" + prim.getAsString() + "' contains unknown variable '" + variable + "'");
				}

				var predicate = expr.toPredicate();
				condition = ahsl -> predicate.test(key -> {
					switch (key) {
						case "a":
							return ahsl >>> 16 & 0xFF;
						case "h":
							return ahsl >>> 10 & 0x3F;
						case "s":
							return ahsl >>> 7 & 0x7;
						case "l":
							return ahsl & 0x7F;
						case "ahsl":
							return ahsl;
						case "hsl":
							return ahsl & 0xFFFF;
						default:
							assert false : "Unexpected variable: " + key;
							return 0;
					}
				});
			} else {
				log.warn("Skipping unexpected HSL condition primitive '{}' in override '{}'", el, description);
				continue;
			}

			if (combinedPredicate == null) {
				combinedPredicate = condition;
			} else {
				var prev = combinedPredicate;
				combinedPredicate = ahsl -> prev.test(ahsl) || condition.test(ahsl);
			}
		}

		if (combinedPredicate == null)
			return ahsl -> false;

		return combinedPredicate;
	}

	public void computeModelUvw(float[] out, int i, float x, float y, float z, int orientation) {
		float rad, cos, sin;
		float temp;
		if (orientation % 2048 != 0) {
			// Reverse baked vertex rotation
			rad = orientation * JAU_TO_RAD;
			cos = cos(rad);
			sin = sin(rad);
			temp = x * sin + z * cos;
			x = x * cos - z * sin;
			z = temp;
		}

		x = (x / LOCAL_TILE_SIZE + .5f) / uvScale;
		y = (y / LOCAL_TILE_SIZE + .5f) / uvScale;
		z = (z / LOCAL_TILE_SIZE + .5f) / uvScale;

		uvType.computeModelUvw(out, i, x, y, z);

		if (uvOrientation % 2048 != 0) {
			rad = uvOrientation * JAU_TO_RAD;
			cos = cos(rad);
			sin = sin(rad);
			x = out[i] - .5f;
			z = out[i + 1] - .5f;
			temp = x * sin + z * cos;
			x = x * cos - z * sin;
			z = temp;
			out[i] = x + .5f;
			out[i + 1] = z + .5f;
		}
	}

	public void fillUvsForFace(float[] out, Model model, int orientation, UvType uvType, int face) {
		switch (uvType) {
			case WORLD_XY:
			case WORLD_XZ:
			case WORLD_YZ:
				uvType.computeWorldUvw(out, 0, uvScale);
				uvType.computeWorldUvw(out, 4, uvScale);
				uvType.computeWorldUvw(out, 8, uvScale);
				break;
			case MODEL_XY:
			case MODEL_XY_MIRROR_A:
			case MODEL_XY_MIRROR_B:
			case MODEL_XZ:
			case MODEL_XZ_MIRROR_A:
			case MODEL_XZ_MIRROR_B:
			case MODEL_YZ:
			case MODEL_YZ_MIRROR_A:
			case MODEL_YZ_MIRROR_B: {
				final float[] vertexX = model.getVerticesX();
				final float[] vertexY = model.getVerticesY();
				final float[] vertexZ = model.getVerticesZ();
				final int triA = model.getFaceIndices1()[face];
				final int triB = model.getFaceIndices2()[face];
				final int triC = model.getFaceIndices3()[face];

				computeModelUvw(out, 0, vertexX[triA], vertexY[triA], vertexZ[triA], orientation);
				computeModelUvw(out, 4, vertexX[triB], vertexY[triB], vertexZ[triB], orientation);
				computeModelUvw(out, 8, vertexX[triC], vertexY[triC], vertexZ[triC], orientation);
				break;
			}
			case BOX:
				computeBoxUvw(out, model, orientation, face);
				break;
			case VANILLA: {
				final byte[] textureFaces = model.getTextureFaces();
				int texFace = textureFaces == null ? -1 : textureFaces[face];
				if (texFace != -1) {
					texFace &= 0xff;

					final float[] vertexX = model.getVerticesX();
					final float[] vertexY = model.getVerticesY();
					final float[] vertexZ = model.getVerticesZ();
					final int texA = model.getTexIndices1()[texFace];
					final int texB = model.getTexIndices2()[texFace];
					final int texC = model.getTexIndices3()[texFace];

					out[0] = vertexX[texA];
					out[1] = vertexY[texA];
					out[2] = vertexZ[texA];
					out[4] = vertexX[texB];
					out[5] = vertexY[texB];
					out[6] = vertexZ[texB];
					out[8] = vertexX[texC];
					out[9] = vertexY[texC];
					out[10] = vertexZ[texC];
				}
				break;
			}
			case GEOMETRY:
			default:
				out[0] = 0;
				out[1] = 0;
				out[2] = 0;
				out[4] = 1;
				out[5] = 0;
				out[6] = 0;
				out[8] = 0;
				out[9] = 1;
				out[10] = 0;
				break;
		}
	}

	private void computeBoxUvw(float[] out, Model model, int modelOrientation, int face) {
		final float[][] vertexXYZ = {
			model.getVerticesX(),
			model.getVerticesY(),
			model.getVerticesZ()
		};
		final int[] triABC = {
			model.getFaceIndices1()[face],
			model.getFaceIndices2()[face],
			model.getFaceIndices3()[face]
		};

		float[][] v = new float[3][3];
		for (int tri = 0; tri < 3; tri++)
			for (int i = 0; i < 3; i++)
				v[tri][i] = vertexXYZ[i][triABC[tri]];

		float rad, cos, sin;
		float temp;
		if (modelOrientation % 2048 != 0) {
			// Reverse baked vertex rotation
			rad = modelOrientation * JAU_TO_RAD;
			cos = cos(rad);
			sin = sin(rad);

			for (int i = 0; i < 3; i++) {
				temp = v[i][0] * sin + v[i][2] * cos;
				v[i][0] = v[i][0] * cos - v[i][2] * sin;
				v[i][2] = temp;
			}
		}

		for (int i = 0; i < 3; i++) {
			v[i][0] = (v[i][0] / LOCAL_TILE_SIZE + .5f) / uvScale;
			v[i][1] = (v[i][1] / LOCAL_TILE_SIZE + .5f) / uvScale;
			v[i][2] = (v[i][2] / LOCAL_TILE_SIZE + .5f) / uvScale;
		}

		// Compute face normal
		float[] a = subtract(v[1], v[0]);
		float[] b = subtract(v[2], v[0]);
		float[] n = cross(a, b);
		float[] absN = abs(n);

		out[2] = out[6] = out[10] = 0;
		if (absN[0] > absN[1] && absN[0] > absN[2]) {
			// YZ plane
			float flip = sign(n[0]);
			for (int tri = 0; tri < 3; tri++) {
				out[tri * 4] = flip * -v[tri][2];
				out[tri * 4 + 1] = v[tri][1];
			}

			if (uvOrientationX % 2048 != 0) {
				rad = uvOrientationX * JAU_TO_RAD;
				cos = cos(rad);
				sin = sin(rad);

				for (int i = 0; i < 3; i++) {
					int j = i * 4;
					v[i][0] = out[j] - .5f;
					v[i][2] = out[j + 1] - .5f;
					temp = v[i][0] * sin + v[i][2] * cos;
					v[i][0] = v[i][0] * cos - v[i][2] * sin;
					v[i][2] = temp;
					out[j] = v[i][0] + .5f;
					out[j + 1] = v[i][2] + .5f;
				}
			}
		} else if (absN[1] > absN[0] && absN[1] > absN[2]) {
			// XZ
			float flip = sign(n[1]);
			for (int tri = 0; tri < 3; tri++) {
				out[tri * 4] = flip * -v[tri][0];
				out[tri * 4 + 1] = v[tri][2];
			}

			if (uvOrientationY % 2048 != 0) {
				rad = uvOrientationY * JAU_TO_RAD;
				cos = cos(rad);
				sin = sin(rad);

				for (int i = 0; i < 3; i++) {
					int j = i * 4;
					v[i][0] = out[j] - .5f;
					v[i][2] = out[j + 1] - .5f;
					temp = v[i][0] * sin + v[i][2] * cos;
					v[i][0] = v[i][0] * cos - v[i][2] * sin;
					v[i][2] = temp;
					out[j] = v[i][0] + .5f;
					out[j + 1] = v[i][2] + .5f;
				}
			}
		} else {
			// XY
			float flip = sign(n[2]);
			for (int tri = 0; tri < 3; tri++) {
				out[tri * 4] = flip * v[tri][0];
				out[tri * 4 + 1] = v[tri][1];
			}

			if (uvOrientationZ % 2048 != 0) {
				rad = uvOrientationZ * JAU_TO_RAD;
				cos = cos(rad);
				sin = sin(rad);

				for (int i = 0; i < 3; i++) {
					int j = i * 4;
					v[i][0] = out[j] - .5f;
					v[i][2] = out[j + 1] - .5f;
					temp = v[i][0] * sin + v[i][2] * cos;
					v[i][0] = v[i][0] * cos - v[i][2] * sin;
					v[i][2] = temp;
					out[j] = v[i][0] + .5f;
					out[j + 1] = v[i][2] + .5f;
				}
			}
		}
	}

	public void applyRotation(Model model) {
		switch (rotate) {
			case 0:
				break;
			case 90:
				model.rotateY90Ccw();
				break;
			case 180:
				model.rotateY180Ccw();
				break;
			case 270:
				model.rotateY270Ccw();
				break;
			default:
				log.debug(
					"Unsupported rotation of {} degrees in model override: '{}'",
					rotate,
					description
				);
				break;
		}
	}

	public void revertRotation(Model model) {
		switch (rotate) {
			case 90:
				model.rotateY270Ccw();
				break;
			case 180:
				model.rotateY180Ccw();
				break;
			case 270:
				model.rotateY90Ccw();
				break;
		}
	}
}

/*
 * Copyright (c) 2021, 117 <https://twitter.com/117scape>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package rs117.hd.scene.model_overrides;

public enum UvType {
	VANILLA,
	GEOMETRY,
	// TODO: move MODEL_* computation to compute shader for efficiency
	MODEL_XY(true, (uvw, i, x, y, z) -> {
		uvw[i] = x;
		uvw[i + 1] = y;
		uvw[i + 2] = z;
	}),
	MODEL_XY_MIRROR_A(MODEL_XY, UvType::mirrorDiagonally),
	MODEL_XY_MIRROR_B(MODEL_XY, (uvw, i) -> {
		uvw[i + 1] = 1 - uvw[i + 1];
		mirrorDiagonally(uvw, i);
	}),
	MODEL_XZ(true, (uvw, i, x, y, z) -> {
		uvw[i] = x;
		uvw[i + 1] = z;
		uvw[i + 2] = y;
	}),
	MODEL_XZ_MIRROR_A(MODEL_XZ, UvType::mirrorDiagonally),
	MODEL_XZ_MIRROR_B(MODEL_XZ, (uvw, i) -> {
		uvw[i + 1] = 1 - uvw[i + 1];
		mirrorDiagonally(uvw, i);
	}),
	MODEL_YZ(true, (uvw, i, x, y, z) -> {
		uvw[i] = y;
		uvw[i + 1] = z;
		uvw[i + 2] = x;
	}),
	MODEL_YZ_MIRROR_A(MODEL_YZ, UvType::mirrorDiagonally),
	MODEL_YZ_MIRROR_B(MODEL_YZ, (uvw, i) -> {
		uvw[i + 1] = 1 - uvw[i + 1];
		mirrorDiagonally(uvw, i);
	}),
	WORLD_XY(new float[] { 0, 0, -1 }),
	WORLD_XZ(new float[] { 0, -1, 0 }),
	WORLD_YZ(new float[] { -1, 0, 0 }),
	BOX,
	;

	public final boolean worldUvs;
	public final boolean orientationDependent;
	private final UvGenerator generator;

	UvType() {
		worldUvs = false;
		orientationDependent = false;
		generator = null;
	}

	UvType(boolean orientationDependent, UvGenerator generator) {
		this.worldUvs = false;
		this.orientationDependent = orientationDependent;
		this.generator = generator;
	}

	UvType(UvType inherit, UvProcessor processor) {
		worldUvs = inherit.worldUvs;
		orientationDependent = inherit.orientationDependent;
		generator = (uvw, i, x, y, z) -> {
			inherit.generator.computeUvw(uvw, i, x, y, z);
			processor.processUvw(uvw, i);
		};
	}

	UvType(float[] normal) {
		worldUvs = true;
		orientationDependent = false;
		generator = (uvw, i, scale, _1, _2) -> {
			uvw[i] = scale * normal[0];
			uvw[i + 1] = scale * normal[1];
			uvw[i + 2] = scale * normal[2];
		};
	}

	@FunctionalInterface
	public interface UvGenerator {
		void computeUvw(float[] out, int offset, float x, float y, float z);
	}

	@FunctionalInterface
	public interface UvProcessor {
		void processUvw(float[] out, int offset);
	}

	public void computeModelUvw(float[] out, int offset, float x, float y, float z) {
		assert generator != null : this + " does not support computing UVs";
		generator.computeUvw(out, offset, x, y, z);
	}

	public void computeWorldUvw(float[] out, int offset, float scale) {
		assert generator != null : this + " does not support computing UVs";
		generator.computeUvw(out, offset, scale, 0, 0);
	}

	private static void mirrorDiagonally(float[] uv, int i) {
		if (uv[i] < uv[i + 1]) {
			float temp = uv[i];
			uv[i] = uv[i + 1];
			uv[i + 1] = temp;
		}
	}
}

package rs117.hd.scene.model_overrides;

public enum WindDisplacement {
	DISABLED,
	OBJECT,
	OBJECT_NO_GROUND_DISPLACEMENT,
	VERTEX,
	VERTEX_WITH_HEMISPHERE_BLEND,
	VERTEX_JIGGLE
}

/*
 * Copyright (c) 2021, 117 <https://twitter.com/117scape>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package rs117.hd.scene.model_overrides;

public enum TzHaarRecolorType
{
	NONE, GRADIENT, HUE_SHIFT
}

package rs117.hd.scene.environments;

import com.google.gson.annotations.JsonAdapter;
import java.util.Objects;
import javax.annotation.Nullable;
import lombok.AccessLevel;
import lombok.Setter;
import rs117.hd.scene.AreaManager;
import rs117.hd.scene.areas.Area;
import rs117.hd.utils.GsonUtils.DegreesToRadians;
import rs117.hd.utils.HDUtils;

import static rs117.hd.utils.ColorUtils.SrgbToLinearAdapter;
import static rs117.hd.utils.ColorUtils.rgb;

@Setter(value = AccessLevel.PRIVATE)
public class Environment {
	public static final float[] DEFAULT_SUN_ANGLES = HDUtils.sunAngles(52, 235);
	public static final Environment DEFAULT = new Environment()
		.setKey("DEFAULT")
		.setArea(Area.ALL)
		.setFogColor(rgb("#000000"))
		.setWaterColor(rgb("#66eaff"))
		.setSunAngles(DEFAULT_SUN_ANGLES)
		.normalize();
	public static final Environment NONE = new Environment()
		.setKey("NONE")
		.setFogColor(rgb("#ff00ff"))
		.normalize();

	public static Environment OVERWORLD, AUTUMN, WINTER;

	public String key;
	@JsonAdapter(AreaManager.Adapter.class)
	public Area area = Area.NONE;
	public boolean isOverworld = false;
	public boolean isUnderwater = false;
	public boolean force = false;
	public boolean allowSkyOverride = true;
	public boolean lightningEffects = false;
	public boolean instantTransition = false;
	@JsonAdapter(SrgbToLinearAdapter.class)
	public float[] ambientColor = rgb("#ffffff");
	public float ambientStrength = 1;
	@JsonAdapter(SrgbToLinearAdapter.class)
	public float[] directionalColor = rgb("#ffffff");
	public float directionalStrength = .25f;
	@Nullable
	@JsonAdapter(SrgbToLinearAdapter.class)
	public float[] waterColor;
	@JsonAdapter(SrgbToLinearAdapter.class)
	public float[] waterCausticsColor;
	public float waterCausticsStrength = -1;
	@JsonAdapter(SrgbToLinearAdapter.class)
	public float[] underglowColor = rgb("#000000");
	public float underglowStrength = 0;
	@Nullable
	@JsonAdapter(DegreesToRadians.class)
	public float[] sunAngles; // horizontal coordinate system, in radians
	@Nullable
	@JsonAdapter(SrgbToLinearAdapter.class)
	public float[] fogColor;
	public float fogDepth = 25;
	public int groundFogStart = -200;
	public int groundFogEnd = -500;
	public float groundFogOpacity = 0;
	@JsonAdapter(DegreesToRadians.class)
	public float windAngle = 0.0f;
	public float windSpeed = 15.0f;
	public float windStrength = 0.0f;
	public float windCeiling = 1280.0f;

	public Environment normalize() {
		if (area != Area.ALL && area != Area.NONE) {
			isOverworld = Area.OVERWORLD.intersects(area);
			// Certain nullable fields will fall back to using the current overworld theme's values later,
			// but for environments that aren't part of the overworld, we want to fall back to the default
			// (underground) environment's values for any unspecified fields
			if (!isOverworld && DEFAULT != null) {
				sunAngles = Objects.requireNonNullElse(sunAngles, DEFAULT.sunAngles);
				fogColor = Objects.requireNonNullElse(fogColor, DEFAULT.fogColor);
				waterColor = Objects.requireNonNullElse(waterColor, DEFAULT.waterColor);
			}
		}

		if (sunAngles != null)
			sunAngles = HDUtils.ensureArrayLength(sunAngles, 2);

		// Base water caustics on directional lighting by default
		if (waterCausticsColor == null)
			waterCausticsColor = directionalColor;
		if (waterCausticsStrength == -1)
			waterCausticsStrength = directionalStrength;
		return this;
	}

	@Override
	public String toString() {
		if (key != null)
			return key;
		return area.name;
	}
}

package rs117.hd.scene;

import com.google.common.collect.ArrayListMultimap;
import com.google.common.collect.ListMultimap;
import java.io.IOException;
import java.util.ArrayDeque;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;
import javax.annotation.Nonnull;
import javax.inject.Inject;
import javax.inject.Singleton;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.*;
import net.runelite.api.coords.*;
import net.runelite.client.callback.ClientThread;
import rs117.hd.HdPlugin;
import rs117.hd.model.ModelPusher;
import rs117.hd.scene.areas.Area;
import rs117.hd.scene.ground_materials.GroundMaterial;
import rs117.hd.scene.tile_overrides.TileOverride;
import rs117.hd.utils.FileWatcher;
import rs117.hd.utils.Props;
import rs117.hd.utils.ResourcePath;

import static rs117.hd.scene.SceneContext.SCENE_OFFSET;
import static rs117.hd.scene.tile_overrides.TileOverride.OVERLAY_FLAG;
import static rs117.hd.utils.HDUtils.localToWorld;
import static rs117.hd.utils.ResourcePath.path;

@Slf4j
@Singleton
public class TileOverrideManager {
	private static final ResourcePath TILE_OVERRIDES_PATH = Props
		.getFile("rlhd.tile-overrides-path", () -> path(TileOverrideManager.class, "tile_overrides.json"));

	@Inject
	private Client client;

	@Inject
	private ClientThread clientThread;

	@Inject
	private HdPlugin plugin;

	@Inject
	private ModelPusher modelPusher;

	private FileWatcher.UnregisterCallback fileWatcher;
	private boolean trackReplacements;
	private List<Map.Entry<Area, TileOverride>> anyMatchOverrides;
	private ListMultimap<Integer, Map.Entry<Area, TileOverride>> idMatchOverrides;

	public void startUp() {
		fileWatcher = TILE_OVERRIDES_PATH.watch((path, first) -> clientThread.invoke(() -> reload(!first)));
	}

	public void shutDown() {
		if (fileWatcher != null)
			fileWatcher.unregister();
		fileWatcher = null;
		anyMatchOverrides = null;
		idMatchOverrides = null;
	}

	public void reload(boolean reloadScene) {
		assert client.isClientThread();

		try {
			TileOverride[] allOverrides = TILE_OVERRIDES_PATH.loadJson(plugin.getGson(), TileOverride[].class);
			if (allOverrides == null)
				throw new IOException("Empty or invalid: " + TILE_OVERRIDES_PATH);

			HashSet<String> names = new HashSet<>();
			for (var override : allOverrides) {
				if (override.name != null) {
					if (!names.add(override.name)) {
						log.warn("Removing duplicate tile override name: {}", override.name);
						override.name = null;
					}
				}
			}

			checkForReplacementLoops(allOverrides);

			List<Map.Entry<Area, TileOverride>> anyMatch = new ArrayList<>();
			ListMultimap<Integer, Map.Entry<Area, TileOverride>> idMatch = ArrayListMultimap.create();

			var tileOverrideVars = plugin.vars.aliases(Map.of(
				"textures", "groundTextures"
			));

			for (int i = 0; i < allOverrides.length; i++) {
				var override = allOverrides[i];
				try {
					override.index = i;
					override.normalize(allOverrides, tileOverrideVars);
				} catch (Exception ex) {
					log.warn("Skipping invalid tile override '{}':", override.name, ex);
					continue;
				}

				if (override.area == Area.NONE)
					continue;

				var replacement = trackReplacements ? override : override.resolveConstantReplacements();
				var entry = Map.entry(override.area, replacement);
				if (override.ids != null) {
					for (int id : override.ids)
						idMatch.put(id, entry);
				} else {
					anyMatch.add(entry);
				}
			}

			anyMatchOverrides = anyMatch;
			idMatchOverrides = idMatch;

			log.debug("Loaded {} tile overrides", allOverrides.length);
		} catch (IOException ex) {
			log.error("Failed to load tile overrides:", ex);
		}

		// Update the reference, since the underlying dirt materials may have changed
		TileOverride.NONE.groundMaterial = GroundMaterial.DIRT;

		if (reloadScene) {
			modelPusher.clearModelCache();
			plugin.reuploadScene();
		}
	}

	private void checkForReplacementLoops(TileOverride[] allOverrides) {
		Map<String, TileOverride> relevantOverrides = new HashMap<>();
		for (var override : allOverrides)
			if (override.name != null && override.rawReplacements != null)
				relevantOverrides.put(override.name, override);

		Set<String> alreadyChecked = new HashSet<>();
		for (var override : relevantOverrides.values())
			checkForReplacementLoops(relevantOverrides, alreadyChecked, override);
	}

	private static void checkForReplacementLoops(
		Map<String, TileOverride> map,
		Set<String> alreadyChecked,
		TileOverride topLevelOverride
	) {
		String name = topLevelOverride.name;
		// Only check each top-level override once
		if (alreadyChecked.add(name))
			checkForReplacementLoops(map, alreadyChecked, new ArrayDeque<>(), name, topLevelOverride);
	}

	private static void checkForReplacementLoops(
		Map<String, TileOverride> map,
		Set<String> alreadyChecked,
		ArrayDeque<String> loop,
		String topLevelOverrideName,
		TileOverride overrideToCheck
	) {
		assert overrideToCheck.name != null : "There's no point in checking overrides without names, since they can't be referenced";
		loop.addLast(overrideToCheck.name);

		for (String replacementName : overrideToCheck.rawReplacements.keySet()) {
			// Check if the replacement introduces a loop
			if (topLevelOverrideName.equals(replacementName)) {
				log.warn(
					"Tile override contains replacement loop: {} -> {}",
					String.join(" -> ", loop),
					replacementName
				);
				// Remove the loop
				overrideToCheck.rawReplacements.put(replacementName, null);
				continue;
			}

			var replacement = map.get(replacementName);
			if (replacement == null)
				continue;

			// Before continuing to check for loops back to the top-level override,
			// we need to rule out any loops within the replacement override itself,
			// so we don't get stuck in a loop there
			checkForReplacementLoops(map, alreadyChecked, replacement);

			// The replacement might've already been removed to prevent a loop in the step above
			if (overrideToCheck.rawReplacements.get(replacementName) == null)
				continue;

			// Check if any further replacements result in a loop
			checkForReplacementLoops(map, alreadyChecked, loop, topLevelOverrideName, replacement);
		}

		loop.removeLast();
	}

	public void setTrackReplacements(boolean shouldTrackReplacements) {
		clientThread.invoke(() -> {
			trackReplacements = shouldTrackReplacements;
			if (plugin.isActive())
				reload(true);
		});
	}

	@Nonnull
	public TileOverride getOverride(SceneContext sceneContext, Tile tile) {
		LocalPoint lp = tile.getLocalLocation();
		var worldPos = localToWorld(sceneContext.scene, lp.getX(), lp.getY(), tile.getRenderLevel());
		return getOverride(sceneContext, tile, worldPos);
	}

	@Nonnull
	public TileOverride getOverride(SceneContext sceneContext, @Nonnull Tile tile, @Nonnull int[] worldPos, int... ids) {
		if (ids.length == 0) {
			var pos = tile.getSceneLocation();
			int x = pos.getX() + SCENE_OFFSET;
			int y = pos.getY() + SCENE_OFFSET;
			int z = tile.getRenderLevel();
			int overlayId = OVERLAY_FLAG | sceneContext.scene.getOverlayIds()[z][x][y];
			int underlayId = sceneContext.scene.getUnderlayIds()[z][x][y];
			ids = new int[] { overlayId, underlayId };
		}
		var override = getOverrideBeforeReplacements(worldPos, ids);
		if (override.isConstant())
			return override;

		sceneContext.tileOverrideVars.setTile(tile);
		var replacement = override.resolveReplacements(sceneContext.tileOverrideVars);
		sceneContext.tileOverrideVars.setTile(null); // Avoid accidentally keeping the old scene in memory
		return replacement;
	}

	@Nonnull
	public TileOverride getOverrideBeforeReplacements(@Nonnull int[] worldPos, int... ids) {
		var match = TileOverride.NONE;

		outer:
		for (int id : ids) {
			var entries = idMatchOverrides.get(id);
			for (var entry : entries) {
				var area = entry.getKey();
				if (area.containsPoint(worldPos)) {
					match = entry.getValue();
					match.queriedAsOverlay = (id & OVERLAY_FLAG) != 0;
					break outer;
				}
			}
		}

		for (var entry : anyMatchOverrides) {
			var anyMatch = entry.getValue();
			if (anyMatch.index > match.index)
				break;
			var area = entry.getKey();
			if (area.containsPoint(worldPos)) {
				match = anyMatch;
				break;
			}
		}

		return match;
	}

}

package rs117.hd.scene;

import java.io.IOException;
import java.util.Arrays;
import java.util.List;
import java.util.stream.Stream;
import javax.inject.Inject;
import lombok.extern.slf4j.Slf4j;
import net.runelite.client.callback.ClientThread;
import rs117.hd.HdPlugin;
import rs117.hd.scene.ground_materials.GroundMaterial;
import rs117.hd.utils.FileWatcher;
import rs117.hd.utils.Props;
import rs117.hd.utils.ResourcePath;

import static rs117.hd.utils.ResourcePath.path;

@Slf4j
public class GroundMaterialManager {
	private static final ResourcePath GROUND_MATERIALS_PATH = Props
		.getFile("rlhd.ground-materials-path", () -> path(AreaManager.class, "ground_materials.json"));

	@Inject
	private HdPlugin plugin;

	@Inject
	private ClientThread clientThread;

	@Inject
	private MaterialManager materialManager;

	@Inject
	private TileOverrideManager tileOverrideManager;

	private FileWatcher.UnregisterCallback fileWatcher;

	public static GroundMaterial[] GROUND_MATERIALS = {};

	public void startUp() {
		fileWatcher = GROUND_MATERIALS_PATH.watch((path, first) -> clientThread.invoke(() -> {
			try {
				GroundMaterial[] groundMaterials = path.loadJson(plugin.getGson(), GroundMaterial[].class);
				if (groundMaterials == null)
					throw new IOException("Empty or invalid: " + path);

				for (var g : groundMaterials)
					g.normalize();


				var dirt1 = materialManager.getMaterial("DIRT_1");
				var dirt2 = materialManager.getMaterial("DIRT_2");
				GroundMaterial.DIRT = new GroundMaterial("DIRT", dirt1, dirt2);
				GroundMaterial.UNDERWATER_GENERIC = new GroundMaterial("UNDERWATER_GENERIC", dirt1, dirt2);

				var staticGroundMaterials = List.of(
					GroundMaterial.NONE,
					GroundMaterial.DIRT,
					GroundMaterial.UNDERWATER_GENERIC
				);
				GROUND_MATERIALS = Stream.concat(
					staticGroundMaterials.stream(),
					Arrays.stream(groundMaterials)
				).toArray(GroundMaterial[]::new);

				// Reload everything which depends on ground materials
				if (!first)
					tileOverrideManager.reload(true);
			} catch (IOException ex) {
				log.error("Failed to load ground materials:", ex);
			}
		}));
	}

	public void shutDown() {
		if (fileWatcher != null)
			fileWatcher.unregister();
		fileWatcher = null;
		GROUND_MATERIALS = new GroundMaterial[0];
	}

	public void restart() {
		shutDown();
		startUp();
	}
}

package rs117.hd.scene.materials;

import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonToken;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.function.Function;
import javax.annotation.Nonnull;
import javax.annotation.Nullable;
import lombok.NoArgsConstructor;
import lombok.Setter;
import lombok.experimental.Accessors;
import lombok.extern.slf4j.Slf4j;
import rs117.hd.model.ModelPusher;
import rs117.hd.opengl.uniforms.UBOMaterials;
import rs117.hd.scene.MaterialManager;
import rs117.hd.scene.model_overrides.ModelOverride;
import rs117.hd.scene.model_overrides.UvType;
import rs117.hd.utils.ColorUtils;
import rs117.hd.utils.ExpressionParser;
import rs117.hd.utils.ExpressionPredicate;
import rs117.hd.utils.GsonUtils;
import rs117.hd.utils.HDVariables;
import rs117.hd.utils.Props;

import static rs117.hd.utils.MathUtils.*;

@Slf4j
@Setter
@Accessors(fluent = true)
@JsonAdapter(Material.Adapter.class)
@NoArgsConstructor
public class Material {
	public String name;
	@JsonAdapter(Reference.Adapter.class)
	protected Material parent;
	public int vanillaTextureIndex = -1;

	@JsonAdapter(Reference.Adapter.class)
	private Material normalMap;
	@JsonAdapter(Reference.Adapter.class)
	private Material displacementMap;
	@JsonAdapter(Reference.Adapter.class)
	private Material roughnessMap;
	@JsonAdapter(Reference.Adapter.class)
	private Material ambientOcclusionMap;
	@JsonAdapter(Reference.Adapter.class)
	private Material flowMap;
	private boolean hasTransparency;
	private boolean overrideBaseColor;
	private boolean unlit;
	@JsonAdapter(ColorUtils.LinearAdapter.class)
	private float brightness = 1;
	private float displacementScale = .1f;
	private float flowMapStrength;
	private float[] flowMapDuration = { 0, 0 };
	private float specularStrength;
	private float specularGloss;
	private float[] scrollSpeed = { 0, 0 };
	private float[] textureScale = { 1, 1, 1 };
	public List<String> materialsToReplace = Collections.emptyList();
	@JsonAdapter(ExpressionParser.PredicateAdapter.class)
	public ExpressionPredicate replacementCondition;

	public transient int uboIndex;
	public transient int textureLayer = -1;
	public transient boolean modifiesVanillaTexture;
	public transient boolean isFallbackVanillaMaterial;
	public transient boolean isValid = true;

	public static final Material NONE = new Material().name("NONE");
	public static final Material[] REQUIRED_MATERIALS = { NONE };

	public static int getTextureLayer(@Nullable Material material) {
		return material == null ? -1 : material.textureLayer;
	}

	public void normalize(Map<String, Material> materials) {
		parent = resolveReference(parent, materials);
		if (parent == this) {
			parent = null;
		} else if (parent != null) {
			parent.normalize(materials);
		}

		normalMap = resolveReference(normalMap, materials);
		displacementMap = resolveReference(displacementMap, materials);
		roughnessMap = resolveReference(roughnessMap, materials);
		ambientOcclusionMap = resolveReference(ambientOcclusionMap, materials);
		flowMap = resolveReference(flowMap, materials);

		if (displacementScale == 0)
			displacementMap = NONE.displacementMap;
		flowMapDuration = ensureDefaults(flowMapDuration, NONE.flowMapDuration);
		scrollSpeed = ensureDefaults(scrollSpeed, NONE.scrollSpeed);
		textureScale = ensureDefaults(textureScale, NONE.textureScale);

		if (!materialsToReplace.isEmpty() && materialsToReplace.removeIf(Objects::isNull))
			log.error("Error in material '{}': Null is not allowed as a replacement material", this);

		// Unwrap the predicate in release mode, since it never needs to be serialized
		if (!Props.DEVELOPMENT && replacementCondition instanceof ExpressionParser.SerializableExpressionPredicate)
			replacementCondition = ((ExpressionParser.SerializableExpressionPredicate) replacementCondition).predicate;

		// Determine whether the material contains some form of non-vanilla texture change
		var base = this;
		while (base.parent != null)
			base = base.parent;
		modifiesVanillaTexture =
			base != NONE ||
			normalMap != null ||
			displacementMap != null ||
			roughnessMap != null ||
			ambientOcclusionMap != null ||
			flowMap != null;
	}

	@Override
	public String toString() {
		return name;
	}

	public boolean isVanillaReplacement() {
		return vanillaTextureIndex != -1 && (parent == null || parent.vanillaTextureIndex != vanillaTextureIndex);
	}

	public String getTextureName() {
		if (this == NONE || isFallbackVanillaMaterial)
			return null;
		return name.toLowerCase();
	}

	public Material resolveTextureOwner() {
		var base = this;
		while (base.parent != null)
			base = base.parent;
		return base;
	}

	public Material findParent(Function<Material, Object> propertyGetter) {
		var property = propertyGetter.apply(this);
		var source = this;
		while (source.parent != null && Objects.deepEquals(property, propertyGetter.apply(source.parent)))
			source = source.parent;
		return source;
	}

	public boolean isInactiveReplacement(HDVariables vars) {
		if (replacementCondition == null)
			return false;
		return !replacementCondition.test(vars);
	}

	public boolean replaces(String name, HDVariables vars) {
		if (replacementCondition == null || !materialsToReplace.contains(name))
			return false;
		return replacementCondition.test(vars);
	}

	public int packMaterialData(@Nonnull ModelOverride modelOverride, UvType uvType, boolean isOverlay) {
		// This needs to return zero by default, since we often fall back to writing all zeroes to UVs
		assert isValid : String.format("Material %s used after invalidation", this);
		int materialIndex = uboIndex;
		assert materialIndex <= ModelPusher.MAX_MATERIAL_INDEX;
		// The sign bit can't be used without shader changes to correctly unpack the material index
		return (materialIndex & ModelPusher.MAX_MATERIAL_INDEX) << 20
			   | ((int) (modelOverride.shadowOpacityThreshold * 0x3F) & 0x3F) << 14
			   | ((modelOverride.windDisplacementModifier + 3) & 0x7) << 11
			   | (modelOverride.windDisplacementMode.ordinal() & 0x7) << 8
			   | (modelOverride.invertDisplacementStrength ? 1 : 0) << 7
			   | (modelOverride.terrainVertexSnap ? 1 : 0) << 6
			   | (!modelOverride.receiveShadows ? 1 : 0) << 5
			   | (modelOverride.upwardsNormals ? 1 : 0) << 4
			   | (modelOverride.flatNormals ? 1 : 0) << 3
			   | (uvType.worldUvs ? 1 : 0) << 2
			   | (uvType == UvType.VANILLA ? 1 : 0) << 1
			   | (isOverlay ? 1 : 0);
	}

	public void fillMaterialStruct(
		UBOMaterials.MaterialStruct struct,
		float vanillaScrollX,
		float vanillaScrollY
	) {
		float scrollSpeedX = scrollSpeed[0] + vanillaScrollX;
		float scrollSpeedY = scrollSpeed[1] + vanillaScrollY;

		struct.colorMap.set(textureLayer);
		struct.normalMap.set(getTextureLayer(normalMap));
		struct.displacementMap.set(getTextureLayer(displacementMap));
		struct.roughnessMap.set(getTextureLayer(roughnessMap));
		struct.ambientOcclusionMap.set(getTextureLayer(ambientOcclusionMap));
		struct.flowMap.set(getTextureLayer(flowMap));
		struct.flags.set(
			(overrideBaseColor ? 1 : 0) << 2 |
			(unlit ? 1 : 0) << 1 |
			(hasTransparency ? 1 : 0)
		);
		struct.brightness.set(brightness);
		struct.displacementScale.set(displacementScale);
		struct.specularStrength.set(specularStrength);
		struct.specularGloss.set(specularGloss);
		struct.flowMapStrength.set(flowMapStrength);
		struct.flowMapDuration.set(flowMapDuration);
		struct.scrollDuration.set(scrollSpeedX, scrollSpeedY);
		struct.textureScale.set(divide(vec(1), textureScale));
	}

	private Material resolveReference(@Nullable Material material, Map<String, Material> materials) {
		if (material instanceof Reference) {
			String name = material.name;
			var m = materials.get(name);
			if (m != null)
				return m;
			log.error("Error in material '{}': Unknown material referenced: '{}'", this, name);
		}
		return material;
	}

	@GsonUtils.ExcludeDefaults
	public static class Definition extends Material implements GsonUtils.ExcludeDefaultsProvider<Material> {
		@Override
		public Material provideDefaults() {
			return parent;
		}
	}

	public static class Reference extends Material {
		public Reference(@Nonnull String name) {
			name(name);
		}

		@Slf4j
		private static class Adapter extends TypeAdapter<Material> {
			@Override
			public Material read(JsonReader in) throws IOException {
				return in.peek() == JsonToken.NULL ? null : new Reference(in.nextString());
			}

			@Override
			public void write(JsonWriter out, Material material) throws IOException {
				out.value(material == null ? null : material.name);
			}
		}
	}

	@Slf4j
	public static class Adapter extends TypeAdapter<Material> {
		@Override
		public Material read(JsonReader in) throws IOException {
			if (in.peek() == JsonToken.NULL)
				return null;

			if (in.peek() == JsonToken.STRING) {
				String name = in.nextString();
				var match = MaterialManager.MATERIAL_MAP.get(name);
				if (match != null)
					return match;
				log.error("Missing material '{}' at {}", name, GsonUtils.location(in), new Throwable());
				return null;
			}

			log.error("Unexpected type {} at {}", in.peek(), GsonUtils.location(in), new Throwable());
			return null;
		}

		@Override
		public void write(JsonWriter out, Material material) throws IOException {
			if (material == null) {
				out.nullValue();
			} else {
				out.value(material.name);
			}
		}
	}

	@Slf4j
	public static class ListAdapter extends TypeAdapter<List<Material>> {
		private static final Adapter ADAPTER = new Adapter();

		@Override
		public List<Material> read(JsonReader in) throws IOException {
			if (in.peek() == JsonToken.NULL)
				return Collections.emptyList();

			if (in.peek() == JsonToken.STRING)
				return List.of(ADAPTER.read(in));

			if (in.peek() == JsonToken.BEGIN_ARRAY) {
				in.beginArray();
				List<Material> materials = new ArrayList<>();
				while (in.peek() != JsonToken.END_ARRAY)
					materials.add(ADAPTER.read(in));
				in.endArray();
				return materials;
			}

			log.error("Unexpected type {} at {}", in.peek(), GsonUtils.location(in), new Throwable());
			return Collections.emptyList();
		}

		@Override
		public void write(JsonWriter out, List<Material> materials) throws IOException {
			if (materials == null || materials.isEmpty()) {
				out.nullValue();
			} else {
				out.beginArray();
				for (var material : materials)
					out.value(material.name);
				out.endArray();
			}
		}
	}

	@Slf4j
	public static class ArrayAdapter extends TypeAdapter<Material[]> {
		private static final ListAdapter ADAPTER = new ListAdapter();

		@Override
		public Material[] read(JsonReader in) throws IOException {
			return ADAPTER.read(in).toArray(Material[]::new);
		}

		@Override
		public void write(JsonWriter out, Material[] materials) throws IOException {
			ADAPTER.write(out, List.of(materials));
		}
	}
}

/*
 * Copyright (c) 2025, Hooder <ahooder@protonmail.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package rs117.hd.scene;

import java.io.IOException;
import javax.inject.Inject;
import javax.inject.Singleton;
import lombok.extern.slf4j.Slf4j;
import net.runelite.client.callback.ClientThread;
import rs117.hd.HdPlugin;
import rs117.hd.opengl.uniforms.UBOWaterTypes;
import rs117.hd.scene.materials.Material;
import rs117.hd.scene.water_types.WaterType;
import rs117.hd.utils.FileWatcher;
import rs117.hd.utils.Props;
import rs117.hd.utils.ResourcePath;

import static rs117.hd.utils.ResourcePath.path;

@Slf4j
@Singleton
public class WaterTypeManager {
	private static final ResourcePath WATER_TYPES_PATH = Props
		.getFile("rlhd.water-types-path", () -> path(WaterTypeManager.class, "water_types.json"));

	@Inject
	private ClientThread clientThread;

	@Inject
	private HdPlugin plugin;

	@Inject
	private MaterialManager materialManager;

	@Inject
	private TileOverrideManager tileOverrideManager;

	@Inject
	private FishingSpotReplacer fishingSpotReplacer;

	public static WaterType[] WATER_TYPES = {};

	public UBOWaterTypes uboWaterTypes;

	private FileWatcher.UnregisterCallback fileWatcher;

	public void startUp() {
		fileWatcher = WATER_TYPES_PATH.watch((path, first) -> clientThread.invoke(() -> {
			try {
				var rawWaterTypes = path.loadJson(plugin.getGson(), WaterType[].class);
				if (rawWaterTypes == null)
					throw new IOException("Empty or invalid: " + path);
				log.debug("Loaded {} water types", rawWaterTypes.length);

				var waterTypes = new WaterType[rawWaterTypes.length + 1];
				waterTypes[0] = WaterType.NONE;
				System.arraycopy(rawWaterTypes, 0, waterTypes, 1, rawWaterTypes.length);

				Material fallbackNormalMap = materialManager.getMaterial("WATER_NORMAL_MAP_1");
				for (int i = 0; i < waterTypes.length; i++)
					waterTypes[i].normalize(i, fallbackNormalMap);

				var oldWaterTypes = WATER_TYPES;
				WATER_TYPES = waterTypes;
				// Update statically accessible water types
				WaterType.WATER = get("WATER");
				WaterType.WATER_FLAT = get("WATER_FLAT");
				WaterType.SWAMP_WATER_FLAT = get("SWAMP_WATER_FLAT");
				WaterType.ICE = get("ICE");

				if (uboWaterTypes != null)
					uboWaterTypes.destroy();
				uboWaterTypes = new UBOWaterTypes(waterTypes);

				if (first)
					return;

				fishingSpotReplacer.despawnRuneLiteObjects();
				fishingSpotReplacer.update();

				boolean indicesChanged = oldWaterTypes == null || oldWaterTypes.length != waterTypes.length;
				if (!indicesChanged) {
					for (int i = 0; i < waterTypes.length; i++) {
						if (!waterTypes[i].name.equals(oldWaterTypes[i].name)) {
							indicesChanged = true;
							break;
						}
					}
				}

				if (indicesChanged) {
					// Reload everything which depends on water type indices
					tileOverrideManager.shutDown();
					tileOverrideManager.startUp();
					plugin.reuploadScene();
				}
			} catch (IOException ex) {
				log.error("Failed to load water types:", ex);
			}
		}));
	}

	public void shutDown() {
		if (fileWatcher != null)
			fileWatcher.unregister();
		fileWatcher = null;

		if (uboWaterTypes != null)
			uboWaterTypes.destroy();
		uboWaterTypes = null;

		WATER_TYPES = new WaterType[0];
	}

	public void restart() {
		shutDown();
		startUp();
	}

	public WaterType get(String name) {
		for (var type : WATER_TYPES)
			if (name.equals(type.name))
				return type;
		return WaterType.NONE;
	}
}

package rs117.hd.scene.areas;

import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import java.util.ArrayList;
import java.util.Collections;
import rs117.hd.scene.AreaManager;

public class Area {
	public static final Area NONE = new Area("NONE", 0, 0, 0, 0);
	public static final Area ALL = new Area("ALL", Integer.MIN_VALUE, Integer.MIN_VALUE, Integer.MAX_VALUE, Integer.MAX_VALUE);
	public static Area OVERWORLD = NONE;

	public String name;
	public boolean hideOtherAreas;
	public boolean fillGaps = true;

	public String[] areas;
	public int[] regions;
	@JsonAdapter(RegionBox.Adapter.class)
	public RegionBox[] regionBoxes;
	@JsonAdapter(AABB.ArrayAdapter.class)
	@SerializedName("aabbs")
	public AABB[] rawAabbs;
	@JsonAdapter(AABB.ArrayAdapter.class)
	public AABB[] unhideAreas = {};

	public transient AABB[] aabbs;
	private transient boolean normalized;

	public Area(String name) {
		this.name = name;
	}

	public Area(String name, int x1, int y1, int x2, int y2) {
		this(name);
		aabbs = new AABB[] { new AABB(x1, y1, x2, y2) };
	}

	public void normalize() {
		if (normalized)
			return;
		normalized = true;

		ArrayList<AABB> aabbs = new ArrayList<>();
		if (rawAabbs != null)
			Collections.addAll(aabbs, rawAabbs);
		if (regions != null)
			for (int regionId : regions)
				aabbs.add(AABB.fromRegionId(regionId));
		if (regionBoxes != null)
			for (var box : regionBoxes)
				aabbs.add(box.toAabb());
		if (areas != null) {
			for (String area : areas) {
				for (Area other : AreaManager.AREAS) {
					if (area.equals(other.name)) {
						other.normalize();
						Collections.addAll(aabbs, other.aabbs);
						break;
					}
				}
			}
		}

		this.aabbs = aabbs.toArray(AABB[]::new);

		if (unhideAreas == null)
			unhideAreas = new AABB[0];
	}

	public boolean containsPoint(boolean includeUnhiding, int... worldPoint) {
		for (var aabb : aabbs)
			if (aabb.contains(worldPoint))
				return true;
		if (includeUnhiding)
			for (var aabb : unhideAreas)
				if (aabb.contains(worldPoint))
					return true;
		return false;
	}

	public boolean containsPoint(int... worldPoint) {
		return containsPoint(true, worldPoint);
	}

	public boolean intersects(Area otherArea) {
		if (otherArea == null)
			return false;
		return intersects(otherArea.aabbs);
	}

	public boolean intersects(AABB... otherAabbs) {
		for (AABB aabb : aabbs)
			if (aabb.intersects(otherAabbs))
				return true;
		return false;
	}

	@Override
	public String toString() {
		return name;
	}
}

package rs117.hd.scene.areas;

import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonToken;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.ArrayList;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import rs117.hd.utils.GsonUtils;

import static net.runelite.api.Constants.*;

@RequiredArgsConstructor
public class RegionBox {
	public final int from, to;
	public final int fromPlane, toPlane;

	public RegionBox(int regionId) {
		this(regionId, regionId);
	}

	public RegionBox(int from, int to) {
		this(from, to, 0, MAX_Z - 1);
	}

	public RegionBox(int from, int to, int plane) {
		this(from, to, plane, plane);
	}

	public AABB toAabb() {
		int x1 = from >>> 8;
		int y1 = from & 0xFF;
		int x2 = to >>> 8;
		int y2 = to & 0xFF;
		if (x1 > x2) {
			int temp = x1;
			x1 = x2;
			x2 = temp;
		}
		if (y1 > y2) {
			int temp = y1;
			y1 = y2;
			y2 = temp;
		}
		return new AABB(
			(x1) << 6,
			(y1) << 6,
			fromPlane,
			((x2) + 1 << 6) - 1,
			((y2) + 1 << 6) - 1,
			toPlane
		);
	}

	@Slf4j
	public static class Adapter extends TypeAdapter<RegionBox[]> {
		@Override
		public RegionBox[] read(JsonReader in) throws IOException {
			in.beginArray();
			ArrayList<RegionBox> list = new ArrayList<>();
			while (in.hasNext() && in.peek() != JsonToken.END_ARRAY) {
				if (in.peek() == JsonToken.NULL) {
					in.skipValue();
					continue;
				}

				in.beginArray();
				int[] ints = new int[4];
				int i = 0;
				while (in.hasNext()) {
					switch (in.peek()) {
						case NUMBER:
							if (i >= ints.length)
								throw new IOException(
									"Too many numbers in RegionBox entry (> " + ints.length + ") at " + GsonUtils.location(in));
							ints[i++] = in.nextInt();
						case END_ARRAY:
							break;
						case NULL:
							in.skipValue();
							continue;
						default:
							throw new IOException(
								"Malformed RegionBox entry. Unexpected token: " + in.peek() + " at " + GsonUtils.location(in));
					}
				}
				in.endArray();

				switch (i) {
					case 1:
						list.add(new RegionBox(ints[0]));
						break;
					case 2:
						list.add(new RegionBox(ints[0], ints[1]));
						break;
					case 3:
						list.add(new RegionBox(ints[0], ints[1], ints[2]));
						break;
					case 4:
						list.add(new RegionBox(ints[0], ints[1], ints[2], ints[3]));
						break;
				}
			}
			in.endArray();
			return list.toArray(new RegionBox[0]);
		}

		@Override
		public void write(JsonWriter out, RegionBox[] aabbs) throws IOException {
			if (aabbs == null || aabbs.length == 0) {
				out.nullValue();
				return;
			}

			out.beginArray();
			for (RegionBox box : aabbs) {
				// Compact JSON array
				if (box.fromPlane == 0 && box.toPlane == MAX_Z - 1) {
					if (box.from == box.to) {
						out.jsonValue(String.format("[ %d ]", box.from));
					} else {
						out.jsonValue(String.format("[ %d, %d ]", box.from, box.to));
					}
				} else if (box.fromPlane == box.toPlane) {
					out.jsonValue(String.format("[ %d, %d, %d ]", box.from, box.to, box.fromPlane));
				} else {
					out.jsonValue(String.format("[ %d, %d, %d, %d ]", box.from, box.to, box.fromPlane, box.toPlane));
				}
			}
			out.endArray();
		}
	}
}

/*
 * Copyright (c) 2021, 117 <https://twitter.com/117scape>
 * Copyright (c) 2022, Hooder <ahooder@protonmail.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package rs117.hd.scene.areas;

import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonToken;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.coords.*;
import rs117.hd.scene.AreaManager;
import rs117.hd.utils.GsonUtils;

import static net.runelite.api.Constants.*;
import static rs117.hd.utils.MathUtils.*;

public class AABB {
	public final int minX;
	public final int minY;
	public final int minZ;
	public final int maxX;
	public final int maxY;
	public final int maxZ;

	public AABB(int x, int y) {
		minX = maxX = x;
		minY = maxY = y;
		minZ = Integer.MIN_VALUE;
		maxZ = Integer.MAX_VALUE;
	}

	public AABB(int x, int y, int z) {
		minX = maxX = x;
		minY = maxY = y;
		minZ = maxZ = z;
	}

	public AABB(int x1, int y1, int x2, int y2) {
		minX = min(x1, x2);
		minY = min(y1, y2);
		minZ = Integer.MIN_VALUE;
		maxX = max(x1, x2);
		maxY = max(y1, y2);
		maxZ = Integer.MAX_VALUE;
	}

	public AABB(int x1, int y1, int x2, int y2, int z1) {
		minX = min(x1, x2);
		minY = min(y1, y2);
		maxX = max(x1, x2);
		maxY = max(y1, y2);
		minZ = maxZ = z1;
	}

	public AABB(int x1, int y1, int z1, int x2, int y2, int z2) {
		minX = min(x1, x2);
		minY = min(y1, y2);
		minZ = min(z1, z2);
		maxX = max(x1, x2);
		maxY = max(y1, y2);
		maxZ = max(z1, z2);
	}

	public AABB(int[] point) {
		this(point[0], point[1], point[2]);
	}

	public AABB(int[] from, int[] to) {
		this(from[0], from[1], from[2], to[0], to[1], to[2]);
	}

	public static AABB fromRegionId(int regionId) {
		int minX = (regionId >>> 8) << 6;
		int minY = (regionId & 0xFF) << 6;
		int maxX = minX + REGION_SIZE - 1;
		int maxY = minY + REGION_SIZE - 1;
		return new AABB(minX, minY, maxX, maxY);
	}

	public AABB onPlane(int plane) {
		return new AABB(minX, minY, plane, maxX, maxY, plane);
	}

	public AABB expandTo(int[] point) {
		return new AABB(
			min(minX, point[0]),
			min(minY, point[1]),
			min(minZ, point[2]),
			max(maxX, point[0]),
			max(maxY, point[1]),
			max(maxZ, point[2])
		);
	}

	public boolean hasZ() {
		return minZ != Integer.MIN_VALUE || maxZ != Integer.MAX_VALUE;
	}

	public boolean isPoint() {
		return
			minX == maxX &&
			minY == maxY &&
			(!hasZ() || minZ == maxZ);
	}

	public boolean isVolume() {
		return !isPoint();
	}

	public boolean contains(int... worldPos) {
		assert worldPos.length >= 2 : "Expected X, Y & possibly a plane, got: " + Arrays.toString(worldPos);
		return
			minX <= worldPos[0] && worldPos[0] <= maxX &&
			minY <= worldPos[1] && worldPos[1] <= maxY &&
			(worldPos.length < 3 || minZ <= worldPos[2] && worldPos[2] <= maxZ);
	}

	public boolean contains(WorldPoint location) {
		return contains(location.getX(), location.getY(), location.getPlane());
	}

	public boolean contains(AABB other) {
		return
			contains(other.minX, other.minY, other.minZ) &&
			contains(other.maxX, other.maxY, other.maxZ);
	}

	public boolean intersects(int minX, int minY, int maxX, int maxY) {
		return
			minX <= this.maxX && maxX >= this.minX &&
			minY <= this.maxY && maxY >= this.minY;
	}

	public boolean intersects(int minX, int minY, int minZ, int maxX, int maxY, int maxZ) {
		return
			minX <= this.maxX && maxX >= this.minX &&
			minY <= this.maxY && maxY >= this.minY &&
			minZ <= this.maxZ && maxZ >= this.minZ;
	}

	public boolean intersects(AABB other) {
		return intersects(
			other.minX,
			other.minY,
			other.minZ,
			other.maxX,
			other.maxY,
			other.maxZ
		);
	}

	public boolean intersects(AABB... aabbs) {
		for (var aabb : aabbs)
			if (intersects(aabb))
				return true;
		return false;
	}

	public float[] getCenter() {
		return new float[] {
			(minX + maxX) / 2.f,
			(minY + maxY) / 2.f,
			(minZ + maxZ) / 2.f
		};
	}

	@Override
	public String toString() {
		if (hasZ())
			return String.format("AABB{min=(%d,%d,%d), max=(%d,%d,%d)}", minX, minY, minZ, maxX, maxY, maxZ);
		return String.format("AABB{min=(%d,%d), max=(%d,%d)}", minX, minY, maxX, maxY);
	}

	public String toArgs() {
		if (hasZ()) {
			if (isPoint())
				return String.format("[ %d, %d, %d ]", minX, minY, minZ);
			if (minZ == maxZ)
				return String.format("[ %d, %d, %d, %d, %d ]", minX, minY, maxX, maxY, minZ);
			return String.format("[ %d, %d, %d, %d, %d, %d ]", minX, minY, minZ, maxX, maxY, maxZ);
		}
		if (isPoint())
			return String.format("[ %d, %d ]", minX, minY);
		return String.format("[ %d, %d, %d, %d ]", minX, minY, maxX, maxY);
	}

	@Override
	public boolean equals(Object obj) {
		if (!(obj instanceof AABB))
			return false;

		AABB other = (AABB) obj;
		return
			other.minX == minX && other.maxX == maxX &&
			other.minY == minY && other.maxY == maxY &&
			other.minZ == minZ && other.maxZ == maxZ;
	}

	@Slf4j
	public static class ArrayAdapter extends TypeAdapter<AABB[]> {
		@Override
		public AABB[] read(JsonReader in) throws IOException {
			in.beginArray();
			ArrayList<AABB> list = new ArrayList<>();
			outer:
			while (in.hasNext() && in.peek() != JsonToken.END_ARRAY) {
				if (in.peek() == JsonToken.NULL) {
					in.skipValue();
					continue;
				}

				if (in.peek() == JsonToken.NUMBER) {
					log.warn("AABBs are specified by two or more numbers. Did you forget to add an array at {}?", GsonUtils.location(in));
					continue;
				}

				if (in.peek() == JsonToken.STRING) {
					String name = in.nextString();
					for (var area : AreaManager.AREAS) {
						if (name.equals(area.name)) {
							Collections.addAll(list, area.aabbs);
							continue outer;
						}
					}

					log.warn("No area exists with the name '{}' at {}", name, GsonUtils.location(in), new Throwable());
				}

				in.beginArray();
				int[] ints = new int[6];
				int i = 0;
				while (in.hasNext()) {
					switch (in.peek()) {
						case NUMBER:
							if (i >= ints.length)
								throw new IOException(
									"Too many numbers in AABB entry (> " + ints.length + ") at " + GsonUtils.location(in));
							ints[i++] = in.nextInt();
						case END_ARRAY:
							break;
						case NULL:
							in.skipValue();
							continue;
						default:
							throw new IOException("Malformed AABB entry. Unexpected token: " + in.peek() + " at " + GsonUtils.location(in));
					}
				}
				in.endArray();

				switch (i) {
					case 1:
						log.warn("AABBs are specified by two or more numbers, only one was provided at {}", GsonUtils.location(in));
						break;
					case 2:
						list.add(new AABB(ints[0], ints[1]));
						break;
					case 3:
						list.add(new AABB(ints[0], ints[1], ints[2]));
						break;
					case 4:
						list.add(new AABB(ints[0], ints[1], ints[2], ints[3]));
						break;
					case 5:
						list.add(new AABB(ints[0], ints[1], ints[2], ints[3], ints[4]));
						break;
					case 6:
						list.add(new AABB(ints[0], ints[1], ints[2], ints[3], ints[4], ints[5]));
						break;
				}
			}
			in.endArray();
			return list.toArray(AABB[]::new);
		}

		@Override
		public void write(JsonWriter out, AABB[] aabbs) throws IOException {
			if (aabbs == null || aabbs.length == 0) {
				out.nullValue();
				return;
			}

			out.beginArray();
			for (AABB aabb : aabbs) {
				// Compact JSON array
				StringBuilder sb = new StringBuilder();
				sb.append("[ ").append(aabb.minX);
				sb.append(", ").append(aabb.minY);
				if (aabb.hasZ())
					sb.append(", ").append(aabb.minZ);
				if (aabb.isVolume()) {
					sb.append(", ").append(aabb.maxX);
					sb.append(", ").append(aabb.maxY);
					if (aabb.hasZ())
						sb.append(", ").append(aabb.maxZ);
				}
				sb.append(" ]");
				out.jsonValue(sb.toString());
			}
			out.endArray();
		}
	}
}

package rs117.hd.scene.ground_materials;

import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonToken;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import lombok.Getter;
import lombok.extern.slf4j.Slf4j;
import rs117.hd.scene.GroundMaterialManager;
import rs117.hd.scene.materials.Material;
import rs117.hd.utils.GsonUtils;

@Getter
@Slf4j
public class GroundMaterial {
	public static final GroundMaterial NONE = new GroundMaterial("NONE", Material.NONE);

	public static GroundMaterial DIRT;
	public static GroundMaterial UNDERWATER_GENERIC;

	public final String name;
	private final Material[] materials;

	public GroundMaterial(String name, Material... materials) {
		this.name = name;
		this.materials = materials;
	}

	public void normalize() {
		for (int j = 0; j < materials.length; j++)
			if (materials[j] == null)
				materials[j] = Material.NONE;
	}

	/**
	 * Get a random material based on the given coordinates.
	 */
	public Material getRandomMaterial(int... worldPos) {
		long hash = 0;
		for (int coord : worldPos)
			hash = hash * 31 + coord;
		long seed = (hash ^ 0x5DEECE66DL) & ((1L << 48) - 1);
		seed = (seed * 0x5DEECE66DL + 0xBL) & ((1L << 48) - 1);
		int r = (int) (seed >>> (48 - 31));
		return materials[r % materials.length];
	}

	@Override
	public String toString() {
		return name;
	}

	@Slf4j
	public static class Adapter extends TypeAdapter<GroundMaterial> {
		@Override
		public GroundMaterial read(JsonReader in) throws IOException {
			if (in.peek() == JsonToken.NULL)
				return null;

			if (in.peek() == JsonToken.STRING) {
				String name = in.nextString();
				for (var groundMaterial : GroundMaterialManager.GROUND_MATERIALS)
					if (name.equals(groundMaterial.name))
						return groundMaterial;

				log.warn("No ground material exists with the name '{}' at {}", name, GsonUtils.location(in), new Throwable());
			} else {
				log.warn("Unexpected type {} at {}", in.peek(), GsonUtils.location(in), new Throwable());
			}

			return null;
		}

		@Override
		public void write(JsonWriter out, GroundMaterial groundMaterial) throws IOException {
			if (groundMaterial == null) {
				out.nullValue();
			} else {
				out.value(groundMaterial.name);
			}
		}
	}
}

/*
 * Copyright (c) 2018, Adam <Adam@sigterm.info>
 * Copyright (c) 2021, 117 <https://twitter.com/117scape>
 * Copyright (c) 2025, Hooder <ahooder@protonmail.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package rs117.hd;

import com.google.gson.Gson;
import com.google.inject.Provides;
import java.awt.Canvas;
import java.awt.Dimension;
import java.awt.GraphicsConfiguration;
import java.awt.Image;
import java.awt.geom.AffineTransform;
import java.awt.image.BufferedImage;
import java.awt.image.DataBufferInt;
import java.io.IOException;
import java.nio.ByteBuffer;
import java.nio.ByteOrder;
import java.nio.FloatBuffer;
import java.nio.IntBuffer;
import java.nio.ShortBuffer;
import java.time.ZoneOffset;
import java.time.ZonedDateTime;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import javax.annotation.Nullable;
import javax.inject.Inject;
import javax.swing.SwingUtilities;
import lombok.Getter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.*;
import net.runelite.api.events.*;
import net.runelite.api.hooks.*;
import net.runelite.client.RuneLite;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.eventbus.EventBus;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.events.ConfigChanged;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.plugins.PluginDependency;
import net.runelite.client.plugins.PluginDescriptor;
import net.runelite.client.plugins.PluginInstantiationException;
import net.runelite.client.plugins.PluginManager;
import net.runelite.client.plugins.entityhider.EntityHiderPlugin;
import net.runelite.client.ui.ClientUI;
import net.runelite.client.ui.DrawManager;
import net.runelite.client.util.LinkBrowser;
import net.runelite.client.util.OSType;
import net.runelite.rlawt.AWTContext;
import org.lwjgl.BufferUtils;
import org.lwjgl.opengl.*;
import org.lwjgl.system.Callback;
import org.lwjgl.system.Configuration;
import rs117.hd.config.ColorFilter;
import rs117.hd.config.DynamicLights;
import rs117.hd.config.SeasonalHemisphere;
import rs117.hd.config.SeasonalTheme;
import rs117.hd.config.ShadingMode;
import rs117.hd.config.ShadowMode;
import rs117.hd.config.UIScalingMode;
import rs117.hd.config.VanillaShadowMode;
import rs117.hd.model.ModelHasher;
import rs117.hd.model.ModelOffsets;
import rs117.hd.model.ModelPusher;
import rs117.hd.opengl.AsyncUICopy;
import rs117.hd.opengl.compute.ComputeMode;
import rs117.hd.opengl.compute.OpenCLManager;
import rs117.hd.opengl.shader.ModelPassthroughComputeProgram;
import rs117.hd.opengl.shader.ModelSortingComputeProgram;
import rs117.hd.opengl.shader.SceneShaderProgram;
import rs117.hd.opengl.shader.ShaderException;
import rs117.hd.opengl.shader.ShaderIncludes;
import rs117.hd.opengl.shader.ShadowShaderProgram;
import rs117.hd.opengl.shader.TiledLightingShaderProgram;
import rs117.hd.opengl.shader.UIShaderProgram;
import rs117.hd.opengl.uniforms.UBOCompute;
import rs117.hd.opengl.uniforms.UBOGlobal;
import rs117.hd.opengl.uniforms.UBOLights;
import rs117.hd.opengl.uniforms.UBOUI;
import rs117.hd.overlays.FrameTimer;
import rs117.hd.overlays.GammaCalibrationOverlay;
import rs117.hd.overlays.ShadowMapOverlay;
import rs117.hd.overlays.TiledLightingOverlay;
import rs117.hd.overlays.Timer;
import rs117.hd.scene.AreaManager;
import rs117.hd.scene.EnvironmentManager;
import rs117.hd.scene.FishingSpotReplacer;
import rs117.hd.scene.GamevalManager;
import rs117.hd.scene.GroundMaterialManager;
import rs117.hd.scene.LightManager;
import rs117.hd.scene.MaterialManager;
import rs117.hd.scene.ModelOverrideManager;
import rs117.hd.scene.ProceduralGenerator;
import rs117.hd.scene.SceneContext;
import rs117.hd.scene.SceneUploader;
import rs117.hd.scene.TextureManager;
import rs117.hd.scene.TileOverrideManager;
import rs117.hd.scene.WaterTypeManager;
import rs117.hd.scene.areas.Area;
import rs117.hd.scene.lights.Light;
import rs117.hd.scene.model_overrides.ModelOverride;
import rs117.hd.utils.ColorUtils;
import rs117.hd.utils.DeveloperTools;
import rs117.hd.utils.FileWatcher;
import rs117.hd.utils.GsonUtils;
import rs117.hd.utils.HDUtils;
import rs117.hd.utils.HDVariables;
import rs117.hd.utils.Mat4;
import rs117.hd.utils.ModelHash;
import rs117.hd.utils.NpcDisplacementCache;
import rs117.hd.utils.PopupUtils;
import rs117.hd.utils.Props;
import rs117.hd.utils.ResourcePath;
import rs117.hd.utils.ShaderRecompile;
import rs117.hd.utils.buffer.GLBuffer;
import rs117.hd.utils.buffer.GpuIntBuffer;
import rs117.hd.utils.buffer.SharedGLBuffer;

import static net.runelite.api.Constants.*;
import static net.runelite.api.Constants.SCENE_SIZE;
import static net.runelite.api.Perspective.*;
import static org.lwjgl.opencl.CL10.*;
import static org.lwjgl.opengl.GL33C.*;
import static rs117.hd.HdPluginConfig.*;
import static rs117.hd.scene.SceneContext.SCENE_OFFSET;
import static rs117.hd.utils.MathUtils.*;
import static rs117.hd.utils.ResourcePath.path;

@PluginDescriptor(
	name = "117 HD",
	description = "GPU renderer with a suite of graphical enhancements",
	tags = { "hd", "high", "detail", "graphics", "shaders", "textures", "gpu", "shadows", "lights" },
	conflicts = "GPU"
)
@PluginDependency(EntityHiderPlugin.class)
@Slf4j
public class HdPlugin extends Plugin implements DrawCallbacks {
	public static final ResourcePath PLUGIN_DIR = Props
		.getFolder("rlhd.plugin-dir", () -> path(RuneLite.RUNELITE_DIR, "117hd"));

	public static final String DISCORD_URL = "https://discord.gg/U4p6ChjgSE";
	public static final String RUNELITE_URL = "https://runelite.net";
	public static final String AMD_DRIVER_URL = "https://www.amd.com/en/support";
	public static final String INTEL_DRIVER_URL = "https://www.intel.com/content/www/us/en/support/detect.html";
	public static final String NVIDIA_DRIVER_URL = "https://www.nvidia.com/en-us/geforce/drivers/";

	public static int MAX_TEXTURE_UNITS;
	public static int TEXTURE_UNIT_COUNT = 0;
	public static final int TEXTURE_UNIT_UI = GL_TEXTURE0 + TEXTURE_UNIT_COUNT++;
	public static final int TEXTURE_UNIT_GAME = GL_TEXTURE0 + TEXTURE_UNIT_COUNT++;
	public static final int TEXTURE_UNIT_SHADOW_MAP = GL_TEXTURE0 + TEXTURE_UNIT_COUNT++;
	public static final int TEXTURE_UNIT_TILE_HEIGHT_MAP = GL_TEXTURE0 + TEXTURE_UNIT_COUNT++;
	public static final int TEXTURE_UNIT_TILED_LIGHTING_MAP = GL_TEXTURE0 + TEXTURE_UNIT_COUNT++;

	public static int MAX_IMAGE_UNITS;
	public static int IMAGE_UNIT_COUNT = 0;
	public static final int IMAGE_UNIT_TILED_LIGHTING = IMAGE_UNIT_COUNT++;

	public static final int UNIFORM_BLOCK_GLOBAL = 0;
	public static final int UNIFORM_BLOCK_MATERIALS = 1;
	public static final int UNIFORM_BLOCK_WATER_TYPES = 2;
	public static final int UNIFORM_BLOCK_LIGHTS = 3;
	public static final int UNIFORM_BLOCK_LIGHTS_CULLING = 4;
	public static final int UNIFORM_BLOCK_COMPUTE = 5;
	public static final int UNIFORM_BLOCK_UI = 6;

	public static final float NEAR_PLANE = 50;
	public static final int MAX_FACE_COUNT = 6144;
	public static final int MAX_DISTANCE = EXTENDED_SCENE_SIZE;
	public static final int GROUND_MIN_Y = 350; // how far below the ground models extend
	public static final int MAX_FOG_DEPTH = 100;
	public static final int VERTEX_SIZE = 4; // 4 ints per vertex
	public static final int UV_SIZE = 4; // 4 floats per vertex
	public static final int NORMAL_SIZE = 4; // 4 floats per vertex
	public static final int TILED_LIGHTING_TILE_SIZE = 16;

	public static final float ORTHOGRAPHIC_ZOOM = .0002f;
	public static final float WIND_DISPLACEMENT_NOISE_RESOLUTION = 0.04f;

	public static float BUFFER_GROWTH_MULTIPLIER = 2; // can be less than 2 if trying to conserve memory

	private static final float COLOR_FILTER_FADE_DURATION = 500;

	private static final int[] eightIntWrite = new int[8];

	private static final int[] RENDERBUFFER_FORMATS_SRGB = {
		GL_SRGB8,
		GL_SRGB8_ALPHA8 // should be guaranteed
	};
	private static final int[] RENDERBUFFER_FORMATS_SRGB_WITH_ALPHA = {
		GL_SRGB8_ALPHA8 // should be guaranteed
	};
	private static final int[] RENDERBUFFER_FORMATS_LINEAR = {
		GL_RGB8,
		GL_RGBA8,
		GL_RGB, // should be guaranteed
		GL_RGBA // should be guaranteed
	};
	private static final int[] RENDERBUFFER_FORMATS_LINEAR_WITH_ALPHA = {
		GL_RGBA8,
		GL_RGBA // should be guaranteed
	};

	@Getter
	private Gson gson;

	@Inject
	private Client client;

	@Inject
	private ClientUI clientUI;

	@Inject
	private ClientThread clientThread;

	@Inject
	private EventBus eventBus;

	@Inject
	private DrawManager drawManager;

	@Inject
	private PluginManager pluginManager;

	@Inject
	private HdPluginConfig config;

	@Inject
	private OpenCLManager clManager;

	@Inject
	private GamevalManager gamevalManager;

	@Inject
	private AreaManager areaManager;

	@Inject
	private LightManager lightManager;

	@Inject
	private EnvironmentManager environmentManager;

	@Inject
	private TextureManager textureManager;

	@Inject
	private MaterialManager materialManager;

	@Inject
	private WaterTypeManager waterTypeManager;

	@Inject
	private GroundMaterialManager groundMaterialManager;

	@Inject
	private TileOverrideManager tileOverrideManager;

	@Inject
	private ModelOverrideManager modelOverrideManager;

	@Inject
	private ProceduralGenerator proceduralGenerator;

	@Inject
	private SceneUploader sceneUploader;

	@Inject
	private AsyncUICopy asyncUICopy;

	@Inject
	private ModelPusher modelPusher;

	@Inject
	private ModelHasher modelHasher;

	@Inject
	private FishingSpotReplacer fishingSpotReplacer;

	@Inject
	private NpcDisplacementCache npcDisplacementCache;

	@Inject
	private DeveloperTools developerTools;

	@Inject
	private FrameTimer frameTimer;

	@Inject
	private SceneShaderProgram sceneProgram;

	@Inject
	private ShadowShaderProgram shadowProgram;

	@Inject
	private UIShaderProgram uiProgram;

	@Inject
	private ModelPassthroughComputeProgram modelPassthroughComputeProgram;

	@Getter
	@Inject
	private TiledLightingShaderProgram tiledLightingImageStoreProgram;

	private final List<ModelSortingComputeProgram> modelSortingComputePrograms = new ArrayList<>();

	private final List<TiledLightingShaderProgram> tiledLightingShaderPrograms = new ArrayList<>();

	@Inject
	private GammaCalibrationOverlay gammaCalibrationOverlay;

	@Inject
	private ShadowMapOverlay shadowMapOverlay;

	@Inject
	private TiledLightingOverlay tiledLightingOverlay;

	@Inject
	public HDVariables vars;

	public static boolean SKIP_GL_ERROR_CHECKS;
	public static GLCapabilities GL_CAPS;

	private Canvas canvas;
	private AWTContext awtContext;
	private Callback debugCallback;
	private ComputeMode computeMode = ComputeMode.OPENGL;

	private static final String LINUX_VERSION_HEADER =
		"#version 420\n" +
		"#extension GL_ARB_compute_shader : require\n" +
		"#extension GL_ARB_shader_storage_buffer_object : require\n" +
		"#extension GL_ARB_explicit_attrib_location : require\n";
	private static final String WINDOWS_VERSION_HEADER = "#version 430\n";

	private static final ResourcePath SHADER_PATH = Props
		.getFolder("rlhd.shader-path", () -> path(HdPlugin.class));

	public int vaoQuad;
	private int vboQuad;

	public int vaoTri;
	private int vboTri;

	private int vaoScene;

	@Getter
	@Nullable
	private int[] uiResolution;
	private final int[] actualUiResolution = { 0, 0 }; // Includes stretched mode and DPI scaling
	private int texUi;
	private int pboUi;

	@Nullable
	private int[] sceneViewport;
	private final float[] sceneViewportScale = { 1, 1 };
	private int msaaSamples;

	private int[] sceneResolution;
	private int fboScene;
	private int rboSceneColor;
	private int rboSceneDepth;
	private int fboSceneResolve;
	private int rboSceneResolveColor;

	private int shadowMapResolution;
	private int fboShadowMap;
	private int texShadowMap;

	private int[] tiledLightingResolution;
	private int fboTiledLighting;
	private int texTiledLighting;

	private int texTileHeightMap;

	private final SharedGLBuffer hStagingBufferVertices = new SharedGLBuffer(
		"Staging Vertices", GL_ARRAY_BUFFER, GL_DYNAMIC_DRAW, CL_MEM_READ_ONLY);
	private final SharedGLBuffer hStagingBufferUvs = new SharedGLBuffer(
		"Staging UVs", GL_ARRAY_BUFFER, GL_DYNAMIC_DRAW, CL_MEM_READ_ONLY);
	private final SharedGLBuffer hStagingBufferNormals = new SharedGLBuffer(
		"Staging Normals", GL_ARRAY_BUFFER, GL_DYNAMIC_DRAW, CL_MEM_READ_ONLY);
	private final SharedGLBuffer hRenderBufferVertices = new SharedGLBuffer(
		"Render Vertices", GL_ARRAY_BUFFER, GL_STREAM_COPY, CL_MEM_WRITE_ONLY);
	private final SharedGLBuffer hRenderBufferUvs = new SharedGLBuffer(
		"Render UVs", GL_ARRAY_BUFFER, GL_STREAM_COPY, CL_MEM_WRITE_ONLY);
	private final SharedGLBuffer hRenderBufferNormals = new SharedGLBuffer(
		"Render Normals", GL_ARRAY_BUFFER, GL_STREAM_COPY, CL_MEM_WRITE_ONLY);

	private int numPassthroughModels;
	private GpuIntBuffer modelPassthroughBuffer;
	private final SharedGLBuffer hModelPassthroughBuffer = new SharedGLBuffer(
		"Model Passthrough", GL_ARRAY_BUFFER, GL_STREAM_DRAW, CL_MEM_READ_ONLY);

	// ordered by face count from small to large
	public int numSortingBins;
	public int maxComputeThreadCount;
	public int[] modelSortingBinFaceCounts; // facesPerThread * threadCount
	public int[] modelSortingBinThreadCounts;
	private int[] numModelsToSort;
	private GpuIntBuffer[] modelSortingBuffers;
	private SharedGLBuffer[] hModelSortingBuffers;

	private final UBOGlobal uboGlobal = new UBOGlobal();
	private final UBOLights uboLights = new UBOLights(false);
	private final UBOLights uboLightsCulling = new UBOLights(true);
	private final UBOCompute uboCompute = new UBOCompute();
	private final UBOUI uboUI = new UBOUI();

	@Getter
	@Nullable
	private SceneContext sceneContext;
	private SceneContext nextSceneContext;

	private int dynamicOffsetVertices;
	private int dynamicOffsetUvs;
	private int renderBufferOffset;

	// Configs used frequently enough to be worth caching
	public boolean configGroundTextures;
	public boolean configGroundBlending;
	public boolean configModelTextures;
	public boolean configTzhaarHD;
	public boolean configProjectileLights;
	public boolean configNpcLights;
	public boolean configHideFakeShadows;
	public boolean configLegacyGreyColors;
	public boolean configModelBatching;
	public boolean configModelCaching;
	public boolean configShadowsEnabled;
	public boolean configExpandShadowDraw;
	public boolean configUseFasterModelHashing;
	public boolean configUndoVanillaShading;
	public boolean configPreserveVanillaNormals;
	public boolean configAsyncUICopy;
	public boolean configWindDisplacement;
	public boolean configCharacterDisplacement;
	public boolean configTiledLighting;
	public DynamicLights configDynamicLights;
	public ShadowMode configShadowMode;
	public SeasonalTheme configSeasonalTheme;
	public SeasonalHemisphere configSeasonalHemisphere;
	public VanillaShadowMode configVanillaShadowMode;
	public ColorFilter configColorFilter = ColorFilter.NONE;
	public ColorFilter configColorFilterPrevious;

	public boolean useLowMemoryMode;
	public boolean enableDetailedTimers;
	public boolean enableFreezeFrame;
	public boolean orthographicProjection;

	@Getter
	private boolean isActive;
	private boolean lwjglInitialized;
	private boolean hasLoggedIn;
	private boolean redrawPreviousFrame;
	private boolean isInChambersOfXeric;
	private boolean isInHouse;
	private boolean justChangedArea;
	private Scene skipScene;

	private final ConcurrentHashMap.KeySetView<String, ?> pendingConfigChanges = ConcurrentHashMap.newKeySet();
	private final Map<Long, ModelOffsets> frameModelInfoMap = new HashMap<>();

	// Camera position and orientation may be reused from the old scene while hopping, prior to drawScene being called
	public float[] viewMatrix;
	public final float[] cameraPosition = new float[3];
	public final float[] cameraOrientation = new float[2];
	public final int[] cameraFocalPoint = new int[2];
	private final int[] cameraShift = new int[2];
	private int visibilityCheckZoom;
	private boolean tileVisibilityCached;
	private final boolean[][][] tileIsVisible = new boolean[MAX_Z][EXTENDED_SCENE_SIZE][EXTENDED_SCENE_SIZE];

	@Getter
	private int drawnTileCount;
	@Getter
	private int drawnStaticRenderableCount;
	@Getter
	private int drawnDynamicRenderableCount;

	public double elapsedTime;
	public double elapsedClientTime;
	public float deltaTime;
	public float deltaClientTime;
	private long lastFrameTimeMillis;
	private double lastFrameClientTime;
	private float windOffset;
	private int gameTicksUntilSceneReload = 0;
	private long colorFilterChangedAt;

	@Provides
	HdPluginConfig provideConfig(ConfigManager configManager) {
		return configManager.getConfig(HdPluginConfig.class);
	}

	@Override
	protected void startUp() {
		gson = GsonUtils.wrap(injector.getInstance(Gson.class));

		clientThread.invoke(() -> {
			try {
				if (!textureManager.vanillaTexturesAvailable())
					return false;

				renderBufferOffset = 0;
				fboScene = 0;
				rboSceneColor = 0;
				rboSceneDepth = 0;
				fboSceneResolve = 0;
				rboSceneResolveColor = 0;
				fboShadowMap = 0;
				numPassthroughModels = 0;
				numModelsToSort = null;
				elapsedTime = 0;
				elapsedClientTime = 0;
				deltaTime = 0;
				deltaClientTime = 0;
				lastFrameTimeMillis = 0;
				lastFrameClientTime = 0;

				AWTContext.loadNatives();
				canvas = client.getCanvas();

				synchronized (canvas.getTreeLock()) {
					// Delay plugin startup until the client's canvas is valid
					if (!canvas.isValid())
						return false;

					awtContext = new AWTContext(canvas);
					awtContext.configurePixelFormat(0, 0, 0);
				}

				awtContext.createGLContext();

				canvas.setIgnoreRepaint(true);

				// lwjgl defaults to lwjgl- + user.name, but this breaks if the username would cause an invalid path
				// to be created.
				Configuration.SHARED_LIBRARY_EXTRACT_DIRECTORY.set("lwjgl-rl");

				SKIP_GL_ERROR_CHECKS = false;
				GL_CAPS = GL.createCapabilities();
				useLowMemoryMode = config.lowMemoryMode();
				BUFFER_GROWTH_MULTIPLIER = useLowMemoryMode ? 1.333f : 2;

				String glRenderer = glGetString(GL_RENDERER);
				String arch = System.getProperty("sun.arch.data.model", "Unknown");
				if (glRenderer == null)
					glRenderer = "Unknown";
				log.info("Using device: {}", glRenderer);
				log.info("Using driver: {}", glGetString(GL_VERSION));
				log.info("Client is {}-bit", arch);
				log.info("Low memory mode: {}", useLowMemoryMode);

				computeMode = OSType.getOSType() == OSType.MacOS ? ComputeMode.OPENCL : ComputeMode.OPENGL;

				List<String> fallbackDevices = List.of(
					"GDI Generic",
					"D3D12 (Microsoft Basic Render Driver)",
					"softpipe"
				);
				boolean isFallbackGpu = fallbackDevices.contains(glRenderer) && !Props.has("rlhd.allowFallbackGpu");
				boolean isUnsupportedGpu = isFallbackGpu || (computeMode == ComputeMode.OPENGL ? !GL_CAPS.OpenGL43 : !GL_CAPS.OpenGL31);
				if (isUnsupportedGpu) {
					log.error(
						"The GPU is lacking OpenGL {} support. Stopping the plugin...",
						computeMode == ComputeMode.OPENGL ? "4.3" : "3.1"
					);
					displayUnsupportedGpuMessage(isFallbackGpu, glRenderer);
					stopPlugin();
					return true;
				}

				lwjglInitialized = true;
				checkGLErrors();

				MAX_TEXTURE_UNITS = glGetInteger(GL_MAX_TEXTURE_IMAGE_UNITS); // Not the fixed pipeline MAX_TEXTURE_UNITS
				if (MAX_TEXTURE_UNITS < TEXTURE_UNIT_COUNT)
					log.warn("The GPU only supports {} texture units", MAX_TEXTURE_UNITS);
				MAX_IMAGE_UNITS = GL_CAPS.GL_ARB_shader_image_load_store ?
					glGetInteger(ARBShaderImageLoadStore.GL_MAX_IMAGE_UNITS) : 0;
				if (MAX_IMAGE_UNITS < IMAGE_UNIT_COUNT)
					log.warn("The GPU only supports {} image units", MAX_IMAGE_UNITS);

				if (log.isDebugEnabled() && GL_CAPS.glDebugMessageControl != 0) {
					debugCallback = GLUtil.setupDebugMessageCallback();
					if (debugCallback != null) {
						// Hide our own debug group messages
						GL43C.glDebugMessageControl(
							GL43C.GL_DEBUG_SOURCE_APPLICATION,
							GL43C.GL_DEBUG_TYPE_PUSH_GROUP,
							GL43C.GL_DEBUG_SEVERITY_NOTIFICATION,
							(int[]) null,
							false
						);
						GL43C.glDebugMessageControl(
							GL43C.GL_DEBUG_SOURCE_APPLICATION,
							GL43C.GL_DEBUG_TYPE_POP_GROUP,
							GL43C.GL_DEBUG_SEVERITY_NOTIFICATION,
							(int[]) null,
							false
						);

						//	GLDebugEvent[ id 0x20071
						//		type Warning: generic
						//		severity Unknown (0x826b)
						//		source GL API
						//		msg Buffer detailed info: Buffer object 11 (bound to GL_ARRAY_BUFFER_ARB, and GL_SHADER_STORAGE_BUFFER (4), usage hint is GL_STREAM_DRAW) will use VIDEO memory as the source for buffer object operations.
						GL43C.glDebugMessageControl(
							GL43C.GL_DEBUG_SOURCE_API, GL43C.GL_DEBUG_TYPE_OTHER,
							GL_DONT_CARE, 0x20071, false
						);

						//	GLDebugMessageHandler: GLDebugEvent[ id 0x20052
						//		type Warning: implementation dependent performance
						//		severity Medium: Severe performance/deprecation/other warnings
						//		source GL API
						//		msg Pixel-path performance warning: Pixel transfer is synchronized with 3D rendering.
						GL43C.glDebugMessageControl(
							GL43C.GL_DEBUG_SOURCE_API, GL43C.GL_DEBUG_TYPE_PERFORMANCE,
							GL_DONT_CARE, 0x20052, false
						);

						// [LWJGL] OpenGL debug message
						//	ID: 0x20092
						//	Source: API
						//	Type: PERFORMANCE
						//	Severity: MEDIUM
						//	Message: Program/shader state performance warning: Vertex shader in program 20 is being recompiled based on GL state.
						GL43C.glDebugMessageControl(
							GL43C.GL_DEBUG_SOURCE_API, GL43C.GL_DEBUG_TYPE_PERFORMANCE,
							GL_DONT_CARE, 0x20092, false
						);
					}
				}

				updateCachedConfigs();
				developerTools.activate();

				modelPassthroughBuffer = new GpuIntBuffer();

				int maxComputeThreadCount;
				if (computeMode == ComputeMode.OPENCL) {
					clManager.startUp(awtContext);
					maxComputeThreadCount = clManager.getMaxWorkGroupSize();
				} else {
					maxComputeThreadCount = glGetInteger(GL43C.GL_MAX_COMPUTE_WORK_GROUP_INVOCATIONS);
				}
				initModelSortingBins(maxComputeThreadCount);

				setupSyncMode();
				initVaos();
				initBuffers();

				// Materials need to be initialized before compiling shader programs
				textureManager.startUp();
				materialManager.startUp();
				waterTypeManager.startUp();

				initPrograms();
				initShaderHotswapping();
				initUiTexture();
				initShadowMapFbo();

				checkGLErrors();

				client.setDrawCallbacks(this);
				client.setGpuFlags(
					DrawCallbacks.GPU |
					DrawCallbacks.HILLSKEW |
					DrawCallbacks.NORMALS |
					(config.removeVertexSnapping() ? DrawCallbacks.NO_VERTEX_SNAPPING : 0)
				);
				client.setExpandedMapLoading(getExpandedMapLoadingChunks());
				// force rebuild of main buffer provider to enable alpha channel
				client.resizeCanvas();

				gamevalManager.startUp();
				areaManager.startUp();
				groundMaterialManager.startUp();
				tileOverrideManager.startUp();
				modelOverrideManager.startUp();
				modelPusher.startUp();
				lightManager.startUp();
				environmentManager.startUp();
				fishingSpotReplacer.startUp();
				gammaCalibrationOverlay.initialize();
				npcDisplacementCache.initialize();

				isActive = true;
				hasLoggedIn = client.getGameState().getState() > GameState.LOGGING_IN.getState();
				redrawPreviousFrame = false;
				skipScene = null;
				isInHouse = false;
				isInChambersOfXeric = false;

				// We need to force the client to reload the scene since we're changing GPU flags
				if (client.getGameState() == GameState.LOGGED_IN)
					client.setGameState(GameState.LOADING);

				checkGLErrors();

				clientThread.invokeLater(this::displayUpdateMessage);
			} catch (Throwable err) {
				log.error("Error while starting 117 HD", err);
				stopPlugin();
			}
			return true;
		});
	}

	@Override
	protected void shutDown() {
		isActive = false;
		FileWatcher.destroy();

		clientThread.invoke(() -> {
			var scene = client.getScene();
			if (scene != null)
				scene.setMinLevel(0);

			client.setGpuFlags(0);
			client.setDrawCallbacks(null);
			client.setUnlockedFps(false);
			client.setExpandedMapLoading(0);

			asyncUICopy.complete();
			developerTools.deactivate();
			modelPusher.shutDown();
			tileOverrideManager.shutDown();
			groundMaterialManager.shutDown();
			modelOverrideManager.shutDown();
			lightManager.shutDown();
			environmentManager.shutDown();
			fishingSpotReplacer.shutDown();
			areaManager.shutDown();
			gamevalManager.shutDown();
			gammaCalibrationOverlay.destroy();
			npcDisplacementCache.destroy();

			if (lwjglInitialized) {
				lwjglInitialized = false;
				waitUntilIdle();

				waterTypeManager.shutDown();
				materialManager.shutDown();
				textureManager.shutDown();

				destroyBuffers();
				destroyUiTexture();
				destroyPrograms();
				destroyVaos();
				destroySceneFbo();
				destroyShadowMapFbo();
				destroyTiledLightingFbo();
				destroyTileHeightMap();
				destroyModelSortingBins();

				clManager.shutDown();
			}

			if (awtContext != null)
				awtContext.destroy();
			awtContext = null;

			if (debugCallback != null)
				debugCallback.free();
			debugCallback = null;

			if (sceneContext != null)
				sceneContext.destroy();
			sceneContext = null;

			synchronized (this) {
				if (nextSceneContext != null)
					nextSceneContext.destroy();
				nextSceneContext = null;
			}

			if (modelPassthroughBuffer != null)
				modelPassthroughBuffer.destroy();
			modelPassthroughBuffer = null;

			// force main buffer provider rebuild to turn off alpha channel
			client.resizeCanvas();

			// Force the client to reload the scene to reset any scene modifications & update GPU flags
			if (client.getGameState() == GameState.LOGGED_IN)
				client.setGameState(GameState.LOADING);
		});
	}

	public void stopPlugin() {
		SwingUtilities.invokeLater(() -> {
			try {
				pluginManager.setPluginEnabled(this, false);
				pluginManager.stopPlugin(this);
			} catch (PluginInstantiationException ex) {
				log.error("Error while stopping 117HD:", ex);
			}
		});

		shutDown();
	}

	public void restartPlugin() {
		clientThread.invoke(() -> {
			shutDown();
			// Validate the canvas so it becomes valid without having to manually resize the client
			canvas.validate();
			startUp();
		});
	}

	public void toggleFreezeFrame() {
		clientThread.invoke(() -> {
			enableFreezeFrame = !enableFreezeFrame;
			if (enableFreezeFrame)
				redrawPreviousFrame = true;
		});
	}

	private String generateFetchCases(String array, int from, int to) {
		int length = to - from;
		if (length <= 1)
			return array + "[" + from + "]";
		int middle = from + length / 2;
		return "i < " + middle +
			" ? " + generateFetchCases(array, from, middle) +
			" : " + generateFetchCases(array, middle, to);
	}

	private String generateGetter(String type, int arrayLength) {
		StringBuilder include = new StringBuilder();

		boolean isAppleM1 = OSType.getOSType() == OSType.MacOS && System.getProperty("os.arch").equals("aarch64");
		if (config.macosIntelWorkaround() && !isAppleM1) {
			// Workaround wrapper for drivers that do not support dynamic indexing,
			// particularly Intel drivers on macOS
			include
				.append(type)
				.append(" ")
				.append("get")
				.append(type)
				.append("(int i) { return ")
				.append(generateFetchCases(type + "Array", 0, arrayLength))
				.append("; }\n");
		} else {
			include
				.append("#define get")
				.append(type)
				.append("(i) ")
				.append(type)
				.append("Array[i]\n");
		}

		return include.toString();
	}

	public ShaderIncludes getShaderIncludes() {
		String versionHeader = OSType.getOSType() == OSType.Linux ? LINUX_VERSION_HEADER : WINDOWS_VERSION_HEADER;
		return new ShaderIncludes()
			.addIncludePath(SHADER_PATH)
			.addInclude("VERSION_HEADER", versionHeader)
			.define("UI_SCALING_MODE", config.uiScalingMode().getMode())
			.define("COLOR_BLINDNESS", config.colorBlindness())
			.define("APPLY_COLOR_FILTER", configColorFilter != ColorFilter.NONE)
			.define("MATERIAL_COUNT", MaterialManager.MATERIALS.length)
			.define("WATER_TYPE_COUNT", waterTypeManager.uboWaterTypes.getCount())
			.define("DYNAMIC_LIGHTS", configDynamicLights != DynamicLights.NONE)
			.define("TILED_LIGHTING", configTiledLighting)
			.define("TILED_LIGHTING_LAYER_COUNT", configDynamicLights.getLightsPerTile() / 4)
			.define("TILED_LIGHTING_TILE_SIZE", TILED_LIGHTING_TILE_SIZE)
			.define("MAX_LIGHT_COUNT", configTiledLighting ? UBOLights.MAX_LIGHTS : configDynamicLights.getMaxSceneLights())
			.define("NORMAL_MAPPING", config.normalMapping())
			.define("PARALLAX_OCCLUSION_MAPPING", config.parallaxOcclusionMapping())
			.define("SHADOW_MODE", configShadowMode)
			.define("SHADOW_TRANSPARENCY", config.enableShadowTransparency())
			.define("PIXELATED_SHADOWS", config.pixelatedShadows())
			.define("VANILLA_COLOR_BANDING", config.vanillaColorBanding())
			.define("UNDO_VANILLA_SHADING", configUndoVanillaShading)
			.define("LEGACY_GREY_COLORS", configLegacyGreyColors)
			.define("DISABLE_DIRECTIONAL_SHADING", config.shadingMode() != ShadingMode.DEFAULT)
			.define("FLAT_SHADING", config.flatShading())
			.define("WIND_DISPLACEMENT", configWindDisplacement)
			.define("WIND_DISPLACEMENT_NOISE_RESOLUTION", WIND_DISPLACEMENT_NOISE_RESOLUTION)
			.define("CHARACTER_DISPLACEMENT", configCharacterDisplacement)
			.define("MAX_CHARACTER_POSITION_COUNT", max(1, UBOCompute.MAX_CHARACTER_POSITION_COUNT))
			.define("WIREFRAME", config.wireframe())
			.addInclude(
				"MATERIAL_CONSTANTS", () -> {
					StringBuilder include = new StringBuilder();
					for (var entry : MaterialManager.MATERIAL_MAP.entrySet()) {
						include
							.append("#define MAT_")
							.append(entry.getKey().toUpperCase())
							.append(" getMaterial(")
							.append(entry.getValue().uboIndex)
							.append(")\n");
					}
					return include.toString();
				}
			)
			.addInclude("MATERIAL_GETTER", () -> generateGetter("Material", MaterialManager.MATERIALS.length))
			.addInclude("WATER_TYPE_GETTER", () -> generateGetter("WaterType", waterTypeManager.uboWaterTypes.getCount()))
			.addUniformBuffer(uboGlobal)
			.addUniformBuffer(uboLights)
			.addUniformBuffer(uboLightsCulling)
			.addUniformBuffer(uboCompute)
			.addUniformBuffer(uboUI)
			.addUniformBuffer(materialManager.uboMaterials)
			.addUniformBuffer(waterTypeManager.uboWaterTypes);
	}

	private void initPrograms() throws ShaderException, IOException {
		var includes = getShaderIncludes();

		// Bind a valid VAO, otherwise validation may fail on older Intel-based Macs
		glBindVertexArray(vaoTri);

		sceneProgram.compile(includes);
		shadowProgram.setMode(configShadowMode);
		shadowProgram.compile(includes);
		uiProgram.compile(includes);

		if (configDynamicLights != DynamicLights.NONE && configTiledLighting) {
			if (GL_CAPS.GL_ARB_shader_image_load_store && tiledLightingImageStoreProgram.isViable()) {
				try {
					tiledLightingImageStoreProgram.compile(includes
						.define("TILED_IMAGE_STORE", true)
						.define("TILED_LIGHTING_LAYER", false));
				} catch (ShaderException ex) {
					log.warn("Disabling TILED_IMAGE_STORE due to:", ex);
				}
			}

			int tiledLayerCount = DynamicLights.MAX_LIGHTS_PER_TILE / 4;
			for (int layer = 0; layer < tiledLayerCount; layer++) {
				var shader = new TiledLightingShaderProgram();
				shader.compile(includes
					.define("TILED_IMAGE_STORE", false)
					.define("TILED_LIGHTING_LAYER", layer));
				tiledLightingShaderPrograms.add(shader);
			}
		}

		if (computeMode == ComputeMode.OPENCL) {
			clManager.initPrograms();
		} else {
			modelPassthroughComputeProgram.compile(includes);

			for (int i = 0; i < numSortingBins; i++) {
				int faceCount = modelSortingBinFaceCounts[i];
				int threadCount = modelSortingBinThreadCounts[i];
				int facesPerThread = ceil((float) faceCount / threadCount);
				var program = new ModelSortingComputeProgram(threadCount, facesPerThread);
				modelSortingComputePrograms.add(program);
				program.compile(includes);
			}
		}

		checkGLErrors();

		eventBus.post(new ShaderRecompile(includes));
	}

	private void destroyPrograms() {
		sceneProgram.destroy();
		shadowProgram.destroy();
		uiProgram.destroy();

		tiledLightingImageStoreProgram.destroy();
		for (var program : tiledLightingShaderPrograms)
			program.destroy();
		tiledLightingShaderPrograms.clear();

		if (computeMode == ComputeMode.OPENGL) {
			modelPassthroughComputeProgram.destroy();
			for (var program : modelSortingComputePrograms)
				program.destroy();
			modelSortingComputePrograms.clear();
		} else {
			clManager.destroyPrograms();
		}
	}

	public void recompilePrograms() {
		// Only recompile if the programs have been compiled successfully before
		if (!sceneProgram.isValid())
			return;

		clientThread.invoke(() -> {
			try {
				waitUntilIdle();
				destroyPrograms();
				initPrograms();
			} catch (ShaderException | IOException ex) {
				// TODO: If each shader compilation leaves the previous working shader intact, we wouldn't need to shut down on failure
				log.error("Error while recompiling shaders:", ex);
				stopPlugin();
			}
		});
	}

	private void initModelSortingBins(int maxThreadCount) {
		maxComputeThreadCount = maxThreadCount;

		int[] targetFaceCounts = {
			128,
			512,
			2048,
			4096,
			MAX_FACE_COUNT
		};

		int numBins = 0;
		int[] binFaceCounts = new int[targetFaceCounts.length];
		int[] binThreadCounts = new int[targetFaceCounts.length];

		int faceCount = 0;
		for (int targetFaceCount : targetFaceCounts) {
			if (faceCount >= targetFaceCount)
				continue;

			int facesPerThread = 1;
			int threadCount;
			while (true) {
				threadCount = ceil((float) targetFaceCount / facesPerThread);
				if (threadCount <= maxThreadCount)
					break;
				++facesPerThread;
			}

			faceCount = threadCount * facesPerThread;
			binFaceCounts[numBins] = faceCount;
			binThreadCounts[numBins] = threadCount;
			++numBins;
		}

		numSortingBins = numBins;
		modelSortingBinFaceCounts = Arrays.copyOf(binFaceCounts, numBins);
		modelSortingBinThreadCounts = Arrays.copyOf(binThreadCounts, numBins);
		numModelsToSort = new int[numBins];

		modelSortingBuffers = new GpuIntBuffer[numSortingBins];
		for (int i = 0; i < numSortingBins; i++)
			modelSortingBuffers[i] = new GpuIntBuffer();

		hModelSortingBuffers = new SharedGLBuffer[numSortingBins];
		for (int i = 0; i < numSortingBins; i++) {
			hModelSortingBuffers[i] = new SharedGLBuffer(
				"Model Sorting " + modelSortingBinFaceCounts[i], GL_ARRAY_BUFFER, GL_STREAM_DRAW, CL_MEM_READ_ONLY);
			// Initialize each model sorting buffer with capacity for 64 models
			hModelSortingBuffers[i].initialize();
		}

		log.debug("Spreading model sorting across {} bins: {}", numBins, modelSortingBinFaceCounts);
	}

	private void destroyModelSortingBins() {
		// Don't allow redrawing the previous frame if the model sorting buffers are no longer valid
		redrawPreviousFrame = false;

		numSortingBins = 0;
		modelSortingBinFaceCounts = null;
		modelSortingBinThreadCounts = null;
		numModelsToSort = null;

		if (modelSortingBuffers != null)
			for (var buffer : modelSortingBuffers)
				buffer.destroy();
		modelSortingBuffers = null;

		if (hModelSortingBuffers != null)
			for (var buffer : hModelSortingBuffers)
				buffer.destroy();
		hModelSortingBuffers = null;
	}

	private void initVaos() {
		// Create scene VAO
		vaoScene = glGenVertexArrays();

		{
			// Create quad VAO
			vaoQuad = glGenVertexArrays();
			vboQuad = glGenBuffers();
			glBindVertexArray(vaoQuad);

			FloatBuffer vboQuadData = BufferUtils.createFloatBuffer(16)
				.put(new float[] {
					// x, y, u, v
					1, 1, 1, 1, // top right
					-1, 1, 0, 1, // top left
					-1, -1, 0, 0, // bottom left
					1, -1, 1, 0 // bottom right
				})
				.flip();
			glBindBuffer(GL_ARRAY_BUFFER, vboQuad);
			glBufferData(GL_ARRAY_BUFFER, vboQuadData, GL_STATIC_DRAW);

			// position attribute
			glVertexAttribPointer(0, 2, GL_FLOAT, false, 4 * Float.BYTES, 0);
			glEnableVertexAttribArray(0);

			// texture coord attribute
			glVertexAttribPointer(1, 2, GL_FLOAT, false, 4 * Float.BYTES, 2 * Float.BYTES);
			glEnableVertexAttribArray(1);
		}

		{
			// Create tri VAO
			vaoTri = glGenVertexArrays();
			vboTri = glGenBuffers();
			glBindVertexArray(vaoTri);

			FloatBuffer vboTriData = BufferUtils.createFloatBuffer(12)
				.put(new float[] {
					// x, y, u, v
					-1, -1, 0, 0, // bottom left
					3, -1, 2, 0, // bottom right (off-screen)
					-1, 3, 0, 2 // top left (off-screen)
				})
				.flip();
			glBindBuffer(GL_ARRAY_BUFFER, vboTri);
			glBufferData(GL_ARRAY_BUFFER, vboTriData, GL_STATIC_DRAW);

			// position attribute
			glVertexAttribPointer(0, 2, GL_FLOAT, false, 4 * Float.BYTES, 0);
			glEnableVertexAttribArray(0);

			// texture coord attribute
			glVertexAttribPointer(1, 2, GL_FLOAT, false, 4 * Float.BYTES, 2 * Float.BYTES);
			glEnableVertexAttribArray(1);
		}
	}

	private void updateSceneVao(GLBuffer vertexBuffer, GLBuffer uvBuffer, GLBuffer normalBuffer) {
		glBindVertexArray(vaoScene);

		glEnableVertexAttribArray(0);
		glBindBuffer(GL_ARRAY_BUFFER, vertexBuffer.id);
		glVertexAttribPointer(0, 3, GL_FLOAT, false, 16, 0);

		glEnableVertexAttribArray(1);
		glBindBuffer(GL_ARRAY_BUFFER, vertexBuffer.id);
		glVertexAttribIPointer(1, 1, GL_INT, 16, 12);

		glEnableVertexAttribArray(2);
		glBindBuffer(GL_ARRAY_BUFFER, uvBuffer.id);
		glVertexAttribPointer(2, 3, GL_FLOAT, false, 16, 0);

		glEnableVertexAttribArray(3);
		glBindBuffer(GL_ARRAY_BUFFER, uvBuffer.id);
		glVertexAttribIPointer(3, 1, GL_INT, 16, 12);

		glEnableVertexAttribArray(4);
		glBindBuffer(GL_ARRAY_BUFFER, normalBuffer.id);
		glVertexAttribPointer(4, 4, GL_FLOAT, false, 0, 0);
	}

	private void destroyVaos() {
		if (vaoScene != 0)
			glDeleteVertexArrays(vaoScene);
		vaoScene = 0;

		if (vboQuad != 0)
			glDeleteBuffers(vboQuad);
		vboQuad = 0;

		if (vaoQuad != 0)
			glDeleteVertexArrays(vaoQuad);
		vaoQuad = 0;

		if (vboTri != 0)
			glDeleteBuffers(vboTri);
		vboTri = 0;

		if (vaoTri != 0)
			glDeleteVertexArrays(vaoTri);
		vaoTri = 0;
	}

	private void initBuffers() {
		hStagingBufferVertices.initialize();
		hStagingBufferUvs.initialize();
		hStagingBufferNormals.initialize();

		hRenderBufferVertices.initialize();
		hRenderBufferUvs.initialize();
		hRenderBufferNormals.initialize();

		hModelPassthroughBuffer.initialize();

		uboGlobal.initialize(UNIFORM_BLOCK_GLOBAL);
		uboLights.initialize(UNIFORM_BLOCK_LIGHTS);
		uboLightsCulling.initialize(UNIFORM_BLOCK_LIGHTS_CULLING);
		uboCompute.initialize(UNIFORM_BLOCK_COMPUTE);
		uboUI.initialize(UNIFORM_BLOCK_UI);
	}

	private void destroyBuffers() {
		hStagingBufferVertices.destroy();
		hStagingBufferUvs.destroy();
		hStagingBufferNormals.destroy();

		hRenderBufferVertices.destroy();
		hRenderBufferUvs.destroy();
		hRenderBufferNormals.destroy();

		hModelPassthroughBuffer.destroy();

		uboGlobal.destroy();
		uboLights.destroy();
		uboLightsCulling.destroy();
		uboCompute.destroy();
		uboUI.destroy();
	}

	private void initUiTexture() {
		pboUi = glGenBuffers();

		texUi = glGenTextures();
		glActiveTexture(TEXTURE_UNIT_UI);
		glBindTexture(GL_TEXTURE_2D, texUi);
		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);
		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
	}

	private void destroyUiTexture() {
		uiResolution = null;

		if (pboUi != 0)
			glDeleteBuffers(pboUi);
		pboUi = 0;

		if (texUi != 0)
			glDeleteTextures(texUi);
		texUi = 0;
	}

	private void updateTiledLightingFbo() {
		assert configTiledLighting;

		int[] resolution = max(ivec(1), round(divide(vec(sceneResolution), TILED_LIGHTING_TILE_SIZE)));
		if (Arrays.equals(resolution, tiledLightingResolution))
			return;

		destroyTiledLightingFbo();

		tiledLightingResolution = resolution;
		fboTiledLighting = glGenFramebuffers();
		texTiledLighting = glGenTextures();
		glActiveTexture(TEXTURE_UNIT_TILED_LIGHTING_MAP);
		glBindTexture(GL_TEXTURE_2D_ARRAY, texTiledLighting);
		glTexParameteri(GL_TEXTURE_2D_ARRAY, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
		glTexParameteri(GL_TEXTURE_2D_ARRAY, GL_TEXTURE_MAG_FILTER, GL_NEAREST);
		glTexParameteri(GL_TEXTURE_2D_ARRAY, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
		glTexParameteri(GL_TEXTURE_2D_ARRAY, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);
		glTexImage3D(
			GL_TEXTURE_2D_ARRAY,
			0,
			GL_RGBA16I,
			tiledLightingResolution[0],
			tiledLightingResolution[1],
			DynamicLights.MAX_LIGHTS_PER_TILE / 4,
			0,
			GL_RGBA_INTEGER,
			GL_SHORT,
			0
		);
		checkGLErrors();

		if (tiledLightingImageStoreProgram.isValid())
			ARBShaderImageLoadStore.glBindImageTexture(
				IMAGE_UNIT_TILED_LIGHTING, texTiledLighting, 0, false, 0, GL_WRITE_ONLY, GL_RGBA16I);

		checkGLErrors();

		uboGlobal.tiledLightingResolution.set(tiledLightingResolution);
	}

	private void destroyTiledLightingFbo() {
		tiledLightingResolution = null;

		if (fboTiledLighting != 0)
			glDeleteFramebuffers(fboTiledLighting);
		fboTiledLighting = 0;

		if (texTiledLighting != 0)
			glDeleteTextures(texTiledLighting);
		texTiledLighting = 0;
	}

	private void updateSceneFbo() {
		if (uiResolution == null)
			return;

		int[] viewport = {
			client.getViewportXOffset(),
			uiResolution[1] - (client.getViewportYOffset() + client.getViewportHeight()),
			client.getViewportWidth(),
			client.getViewportHeight()
		};

		// Skip rendering when there's no viewport to render to, which happens while world hopping
		if (viewport[2] == 0 || viewport[3] == 0)
			return;

		// DPI scaling and stretched mode also affects the game's viewport
		divide(sceneViewportScale, vec(actualUiResolution), vec(uiResolution));
		if (sceneViewportScale[0] != 1 || sceneViewportScale[1] != 1) {
			// Pad the viewport before scaling, so it always covers the game's viewport in the UI
			for (int i = 0; i < 2; i++) {
				viewport[i] -= 1;
				viewport[i + 2] += 2;
			}
			viewport = round(multiply(vec(viewport), sceneViewportScale));
		}

		// Check if scene FBO needs to be recreated
		if (Arrays.equals(sceneViewport, viewport))
			return;

		destroySceneFbo();
		sceneViewport = viewport;

		// Bind default FBO to check whether anti-aliasing is forced
		int defaultFramebuffer = awtContext.getFramebuffer(false);
		glBindFramebuffer(GL_FRAMEBUFFER, defaultFramebuffer);
		final int forcedAASamples = glGetInteger(GL_SAMPLES);
		msaaSamples = forcedAASamples != 0 ? forcedAASamples : min(config.antiAliasingMode().getSamples(), glGetInteger(GL_MAX_SAMPLES));

		// Since there's seemingly no reliable way to check if the default framebuffer will do sRGB conversions with GL_FRAMEBUFFER_SRGB
		// enabled, we always replace the default framebuffer with an sRGB one. We could technically support rendering to the default
		// framebuffer when sRGB conversions aren't needed, but the goal is to transition to linear blending in the future anyway.
		boolean sRGB = false; // This is currently unused

		// Some implementations (*cough* Apple) complain when blitting from an FBO without an alpha channel to a (default) FBO with alpha.
		// To work around this, we select a format which includes an alpha channel, even though we don't need it.
		int defaultColorAttachment = defaultFramebuffer == 0 ? GL_BACK_LEFT : GL_COLOR_ATTACHMENT0;
		int alphaBits = glGetFramebufferAttachmentParameteri(GL_FRAMEBUFFER, defaultColorAttachment, GL_FRAMEBUFFER_ATTACHMENT_ALPHA_SIZE);
		checkGLErrors();
		boolean alpha = alphaBits > 0;

		int[] desiredFormats = sRGB ?
			alpha ? RENDERBUFFER_FORMATS_SRGB_WITH_ALPHA : RENDERBUFFER_FORMATS_SRGB :
			alpha ? RENDERBUFFER_FORMATS_LINEAR_WITH_ALPHA : RENDERBUFFER_FORMATS_LINEAR;

		float resolutionScale = config.sceneResolutionScale() / 100f;
		sceneResolution = round(max(vec(1), multiply(slice(vec(sceneViewport), 2), resolutionScale)));
		uboGlobal.sceneResolution.set(sceneResolution);

		// Create and bind the FBO
		fboScene = glGenFramebuffers();
		glBindFramebuffer(GL_FRAMEBUFFER, fboScene);

		// Create color render buffer
		rboSceneColor = glGenRenderbuffers();
		glBindRenderbuffer(GL_RENDERBUFFER, rboSceneColor);

		// Flush out all pending errors, so we can check whether the next step succeeds
		clearGLErrors();

		int format = 0;
		for (int desiredFormat : desiredFormats) {
			glRenderbufferStorageMultisample(GL_RENDERBUFFER, msaaSamples, desiredFormat, sceneResolution[0], sceneResolution[1]);

			if (glGetError() == GL_NO_ERROR) {
				format = desiredFormat;
				break;
			}
		}

		if (format == 0)
			throw new RuntimeException("No supported " + (sRGB ? "sRGB" : "linear") + " formats");

		// Found a usable format. Bind the RBO to the scene FBO
		glFramebufferRenderbuffer(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_RENDERBUFFER, rboSceneColor);
		checkGLErrors();

		// Create depth render buffer
		rboSceneDepth = glGenRenderbuffers();
		glBindRenderbuffer(GL_RENDERBUFFER, rboSceneDepth);
		glRenderbufferStorageMultisample(GL_RENDERBUFFER, msaaSamples, GL_DEPTH24_STENCIL8, sceneResolution[0], sceneResolution[1]);
		glFramebufferRenderbuffer(GL_FRAMEBUFFER, GL_DEPTH_ATTACHMENT, GL_RENDERBUFFER, rboSceneDepth);
		checkGLErrors();

		// If necessary, create an FBO for resolving multisampling
		if (msaaSamples > 1 && resolutionScale != 1) {
			fboSceneResolve = glGenFramebuffers();
			glBindFramebuffer(GL_FRAMEBUFFER, fboSceneResolve);
			rboSceneResolveColor = glGenRenderbuffers();
			glBindRenderbuffer(GL_RENDERBUFFER, rboSceneResolveColor);
			glRenderbufferStorageMultisample(GL_RENDERBUFFER, 0, format, sceneResolution[0], sceneResolution[1]);
			glFramebufferRenderbuffer(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_RENDERBUFFER, rboSceneResolveColor);
			checkGLErrors();
		}

		// Reset
		glBindFramebuffer(GL_FRAMEBUFFER, awtContext.getFramebuffer(false));
		glBindRenderbuffer(GL_RENDERBUFFER, 0);
	}

	private void destroySceneFbo() {
		sceneViewport = null;

		if (fboScene != 0)
			glDeleteFramebuffers(fboScene);
		fboScene = 0;

		if (rboSceneColor != 0)
			glDeleteRenderbuffers(rboSceneColor);
		rboSceneColor = 0;

		if (rboSceneDepth != 0)
			glDeleteRenderbuffers(rboSceneDepth);
		rboSceneDepth = 0;

		if (fboSceneResolve != 0)
			glDeleteFramebuffers(fboSceneResolve);
		fboSceneResolve = 0;

		if (rboSceneResolveColor != 0)
			glDeleteRenderbuffers(rboSceneResolveColor);
		rboSceneResolveColor = 0;
	}

	private void initShadowMapFbo() {
		if (!configShadowsEnabled) {
			initDummyShadowMap();
			return;
		}

		// Create and bind the FBO
		fboShadowMap = glGenFramebuffers();
		glBindFramebuffer(GL_FRAMEBUFFER, fboShadowMap);

		// Create texture
		texShadowMap = glGenTextures();
		glActiveTexture(TEXTURE_UNIT_SHADOW_MAP);
		glBindTexture(GL_TEXTURE_2D, texShadowMap);

		shadowMapResolution = config.shadowResolution().getValue();
		int maxResolution = glGetInteger(GL_MAX_TEXTURE_SIZE);
		if (maxResolution < shadowMapResolution) {
			log.info("Capping shadow resolution from {} to {}", shadowMapResolution, maxResolution);
			shadowMapResolution = maxResolution;
		}

		glTexImage2D(
			GL_TEXTURE_2D,
			0,
			GL_DEPTH_COMPONENT24,
			shadowMapResolution,
			shadowMapResolution,
			0,
			GL_DEPTH_COMPONENT,
			GL_FLOAT,
			0
		);
		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);
		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_BORDER);
		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_BORDER);

		float[] color = { 1, 1, 1, 1 };
		glTexParameterfv(GL_TEXTURE_2D, GL_TEXTURE_BORDER_COLOR, color);

		// Bind texture
		glFramebufferTexture2D(GL_FRAMEBUFFER, GL_DEPTH_ATTACHMENT, GL_TEXTURE_2D, texShadowMap, 0);
		glDrawBuffer(GL_NONE);
		glReadBuffer(GL_NONE);

		// Reset FBO
		glBindFramebuffer(GL_FRAMEBUFFER, awtContext.getFramebuffer(false));
	}

	private void initDummyShadowMap() {
		// Create dummy texture
		texShadowMap = glGenTextures();
		glActiveTexture(TEXTURE_UNIT_SHADOW_MAP);
		glBindTexture(GL_TEXTURE_2D, texShadowMap);
		glTexImage2D(GL_TEXTURE_2D, 0, GL_DEPTH_COMPONENT, 1, 1, 0, GL_DEPTH_COMPONENT, GL_FLOAT, 0);
		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);
		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_BORDER);
		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_BORDER);
	}

	private void destroyShadowMapFbo() {
		if (texShadowMap != 0)
			glDeleteTextures(texShadowMap);
		texShadowMap = 0;

		if (fboShadowMap != 0)
			glDeleteFramebuffers(fboShadowMap);
		fboShadowMap = 0;
	}

	private void initTileHeightMap(Scene scene) {
		final int TILE_HEIGHT_BUFFER_SIZE = Constants.MAX_Z * EXTENDED_SCENE_SIZE * EXTENDED_SCENE_SIZE * Short.BYTES;
		ShortBuffer tileBuffer = ByteBuffer
			.allocateDirect(TILE_HEIGHT_BUFFER_SIZE)
			.order(ByteOrder.nativeOrder())
			.asShortBuffer();

		int[][][] tileHeights = scene.getTileHeights();
		for (int z = 0; z < Constants.MAX_Z; ++z) {
			for (int y = 0; y < EXTENDED_SCENE_SIZE; ++y) {
				for (int x = 0; x < EXTENDED_SCENE_SIZE; ++x) {
					int h = tileHeights[z][x][y];
					assert (h & 0b111) == 0;
					h >>= 3;
					tileBuffer.put((short) h);
				}
			}
		}
		tileBuffer.flip();

		texTileHeightMap = glGenTextures();
		glActiveTexture(TEXTURE_UNIT_TILE_HEIGHT_MAP);
		glBindTexture(GL_TEXTURE_3D, texTileHeightMap);
		glTexParameteri(GL_TEXTURE_3D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
		glTexParameteri(GL_TEXTURE_3D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);
		glTexParameteri(GL_TEXTURE_3D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
		glTexParameteri(GL_TEXTURE_3D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);
		glTexImage3D(GL_TEXTURE_3D, 0, GL_R16I,
			EXTENDED_SCENE_SIZE, EXTENDED_SCENE_SIZE, Constants.MAX_Z,
			0, GL_RED_INTEGER, GL_SHORT, tileBuffer
		);
	}

	private void destroyTileHeightMap() {
		if (texTileHeightMap != 0)
			glDeleteTextures(texTileHeightMap);
		texTileHeightMap = 0;
	}

	@Override
	public void drawScene(double cameraX, double cameraY, double cameraZ, double cameraPitch, double cameraYaw, int plane) {
		updateSceneFbo();

		if (sceneContext == null || sceneViewport == null)
			return;

		frameTimer.begin(Timer.DRAW_FRAME);
		frameTimer.begin(Timer.DRAW_SCENE);

		final Scene scene = client.getScene();
		int drawDistance = getDrawDistance();
		boolean drawDistanceChanged = false;
		if (scene.getDrawDistance() != drawDistance) {
			scene.setDrawDistance(drawDistance);
			drawDistanceChanged = true;
		}

		boolean updateUniforms = true;

		Player localPlayer = client.getLocalPlayer();
		var lp = localPlayer.getLocalLocation();
		if (sceneContext.enableAreaHiding) {
			assert sceneContext.sceneBase != null;
			int[] worldPos = {
				sceneContext.sceneBase[0] + lp.getSceneX(),
				sceneContext.sceneBase[1] + lp.getSceneY(),
				sceneContext.sceneBase[2] + client.getPlane()
			};

			// We need to check all areas contained in the scene in the order they appear in the list,
			// in order to ensure lower floors can take precedence over higher floors which include tiny
			// portions of the floor beneath around stairs and ladders
			Area newArea = null;
			for (var area : sceneContext.possibleAreas) {
				if (area.containsPoint(false, worldPos)) {
					newArea = area;
					break;
				}
			}

			// Force a scene reload if the player is no longer in the same area
			if (newArea != sceneContext.currentArea) {
				if (justChangedArea) {
					// Prevent getting stuck in a scene reloading loop if this breaks for any reason
					sceneContext.forceDisableAreaHiding = true;
					log.error("Force disabling area hiding after moving from {} to {} at {}", sceneContext.currentArea, newArea, worldPos);
				} else {
					justChangedArea = true;
				}
				// Reload the scene to reapply area hiding
				client.setGameState(GameState.LOADING);
				updateUniforms = false;
				redrawPreviousFrame = true;
			} else {
				justChangedArea = false;
			}
		} else {
			justChangedArea = false;
		}

		if (!enableFreezeFrame) {
			if (!redrawPreviousFrame) {
				// Only reset the target buffer offset right before drawing the scene. That way if there are frames
				// after this that don't involve a scene draw, like during LOADING/HOPPING/CONNECTION_LOST, we can
				// still redraw the previous frame's scene to emulate the client behavior of not painting over the
				// viewport buffer.
				renderBufferOffset = sceneContext.staticVertexCount;

				drawnTileCount = 0;
				drawnStaticRenderableCount = 0;
				drawnDynamicRenderableCount = 0;

				// TODO: this could be done only once during scene swap, but is a bit of a pain to do
				// Push unordered models that should always be drawn at the start of each frame.
				// Used to fix issues like the right-click menu causing underwater tiles to disappear.
				var staticUnordered = sceneContext.staticUnorderedModelBuffer.getBuffer();
				modelPassthroughBuffer
					.ensureCapacity(staticUnordered.limit())
					.put(staticUnordered);
				staticUnordered.rewind();
				numPassthroughModels += staticUnordered.limit() / 8;
			}

			if (updateUniforms) {
				float[] newCameraPosition = { (float) cameraX, (float) cameraY, (float) cameraZ };
				float[] newCameraOrientation = { (float) cameraYaw, (float) cameraPitch };
				int newZoom = configShadowsEnabled && configExpandShadowDraw ? client.get3dZoom() / 2 : client.get3dZoom();
				if (!Arrays.equals(cameraPosition, newCameraPosition) ||
					!Arrays.equals(cameraOrientation, newCameraOrientation) ||
					visibilityCheckZoom != newZoom ||
					drawDistanceChanged
				) {
					copyTo(cameraPosition, newCameraPosition);
					copyTo(cameraOrientation, newCameraOrientation);
					visibilityCheckZoom = newZoom;
					tileVisibilityCached = false;
				}

				if (sceneContext.scene == scene) {
					cameraFocalPoint[0] = client.getOculusOrbFocalPointX();
					cameraFocalPoint[1] = client.getOculusOrbFocalPointY();
					Arrays.fill(cameraShift, 0);

					try {
						frameTimer.begin(Timer.UPDATE_ENVIRONMENT);
						environmentManager.update(sceneContext);
						frameTimer.end(Timer.UPDATE_ENVIRONMENT);

						frameTimer.begin(Timer.UPDATE_LIGHTS);
						lightManager.update(sceneContext);
						frameTimer.end(Timer.UPDATE_LIGHTS);
					} catch (Exception ex) {
						log.error("Error while updating environment or lights:", ex);
						stopPlugin();
						return;
					}
				} else {
					cameraShift[0] = cameraFocalPoint[0] - client.getOculusOrbFocalPointX();
					cameraShift[1] = cameraFocalPoint[1] - client.getOculusOrbFocalPointY();
					cameraPosition[0] += cameraShift[0];
					cameraPosition[2] += cameraShift[1];
				}

				uboCompute.yaw.set(cameraOrientation[0]);
				uboCompute.pitch.set(cameraOrientation[1]);
				uboCompute.centerX.set(client.getCenterX());
				uboCompute.centerY.set(client.getCenterY());
				uboCompute.zoom.set(client.getScale());
				uboCompute.cameraX.set(cameraPosition[0]);
				uboCompute.cameraY.set(cameraPosition[1]);
				uboCompute.cameraZ.set(cameraPosition[2]);

				uboCompute.windDirectionX.set(cos(environmentManager.currentWindAngle));
				uboCompute.windDirectionZ.set(sin(environmentManager.currentWindAngle));
				uboCompute.windStrength.set(environmentManager.currentWindStrength);
				uboCompute.windCeiling.set(environmentManager.currentWindCeiling);
				uboCompute.windOffset.set(windOffset);

				if (configCharacterDisplacement) {
					// The local player needs to be added first for distance culling
					uboCompute.addCharacterPosition(lp.getX(), lp.getY(), (int) (LOCAL_TILE_SIZE * 1.33f));
				}

				// Calculate the viewport dimensions before scaling in order to include the extra padding
				int viewportWidth = (int) (sceneViewport[2] / sceneViewportScale[0]);
				int viewportHeight = (int) (sceneViewport[3] / sceneViewportScale[1]);

				// Calculate projection matrix
				float[] projectionMatrix = Mat4.scale(client.getScale(), client.getScale(), 1);
				if (orthographicProjection) {
					Mat4.mul(projectionMatrix, Mat4.scale(ORTHOGRAPHIC_ZOOM, ORTHOGRAPHIC_ZOOM, -1));
					Mat4.mul(projectionMatrix, Mat4.orthographic(viewportWidth, viewportHeight, 40000));
				} else {
					Mat4.mul(projectionMatrix, Mat4.perspective(viewportWidth, viewportHeight, NEAR_PLANE));
				}

				// Calculate view matrix
				viewMatrix = Mat4.rotateX(cameraOrientation[1]);
				Mat4.mul(viewMatrix, Mat4.rotateY(cameraOrientation[0]));
				Mat4.mul(viewMatrix, Mat4.translate(-cameraPosition[0], -cameraPosition[1], -cameraPosition[2]));

				// Calculate view proj & inv matrix
				float[] viewProj = Mat4.identity();
				Mat4.mul(viewProj, projectionMatrix);
				Mat4.mul(viewProj, viewMatrix);
				float[] invProjectionMatrix = Mat4.inverse(viewProj);

				uboGlobal.cameraPos.set(cameraPosition);
				uboGlobal.viewMatrix.set(viewMatrix);
				uboGlobal.projectionMatrix.set(viewProj);
				uboGlobal.invProjectionMatrix.set(invProjectionMatrix);
				uboGlobal.upload();
			}
		}

		if (configDynamicLights != DynamicLights.NONE && sceneContext.scene == scene && updateUniforms) {
			// Update lights UBO
			assert sceneContext.numVisibleLights <= UBOLights.MAX_LIGHTS;

			final float[] lightPosition = new float[4];
			final float[] lightColor = new float[4];
			for (int i = 0; i < sceneContext.numVisibleLights; i++) {
				final Light light = sceneContext.lights.get(i);
				final float lightRadiusSq = light.radius * light.radius;
				lightPosition[0] = light.pos[0] + cameraShift[0];
				lightPosition[1] = light.pos[1];
				lightPosition[2] = light.pos[2] + cameraShift[1];
				lightPosition[3] = lightRadiusSq;

				lightColor[0] = light.color[0] * light.strength;
				lightColor[1] = light.color[1] * light.strength;
				lightColor[2] = light.color[2] * light.strength;
				lightColor[3] = 0.0f;

				uboLights.setLight(i, lightPosition, lightColor);

				// Pre-calculate the ViewSpace Position of the light, to save having to do the multiplication in the culling shader
				lightPosition[3] = 1.0f;
				Mat4.mulVec(lightPosition, viewMatrix, lightPosition);
				lightPosition[3] = lightRadiusSq; // Restore LightRadiusSq

				uboLightsCulling.setLight(i, lightPosition, lightColor);
			}

			uboLights.upload();
			uboLightsCulling.upload();

			// Perform tiled lighting culling before the compute memory barrier, so it's performed asynchronously
			if (configTiledLighting) {
				updateTiledLightingFbo();
				assert fboTiledLighting != 0;

				frameTimer.begin(Timer.DRAW_TILED_LIGHTING);
				frameTimer.begin(Timer.RENDER_TILED_LIGHTING);

				glViewport(0, 0, tiledLightingResolution[0], tiledLightingResolution[1]);
				glBindFramebuffer(GL_FRAMEBUFFER, fboTiledLighting);

				glFramebufferTexture(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, texTiledLighting, 0);

				glClearColor(0, 0, 0, 0);
				glClear(GL_COLOR_BUFFER_BIT);

				glBindVertexArray(vaoTri);
				glDisable(GL_BLEND);

				if (tiledLightingImageStoreProgram.isValid()) {
					tiledLightingImageStoreProgram.use();
					glDrawArrays(GL_TRIANGLES, 0, 3);
				} else {
					int layerCount = configDynamicLights.getLightsPerTile() / 4;
					for (int layer = 0; layer < layerCount; layer++) {
						tiledLightingShaderPrograms.get(layer).use();
						glFramebufferTextureLayer(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, texTiledLighting, 0, layer);
						glDrawArrays(GL_TRIANGLES, 0, 3);
					}
				}

				frameTimer.end(Timer.RENDER_TILED_LIGHTING);
				frameTimer.end(Timer.DRAW_TILED_LIGHTING);
			}
		}
	}

	@Override
	public void postDrawScene() {
		if (sceneContext == null)
			return;

		tileVisibilityCached = true;

		frameTimer.end(Timer.DRAW_SCENE);
		frameTimer.begin(Timer.RENDER_FRAME);
		frameTimer.begin(Timer.UPLOAD_GEOMETRY);

		// The client only updates animations once per client tick, so we can skip updating geometry buffers,
		// but the compute shaders should still be executed in case the camera angle has changed.
		// Technically we could skip compute shaders as well when the camera is unchanged,
		// but it would only lead to micro stuttering when rotating the camera, compared to no rotation.
		if (!redrawPreviousFrame) {
			// Geometry buffers
			sceneContext.stagingBufferVertices.flip();
			sceneContext.stagingBufferUvs.flip();
			sceneContext.stagingBufferNormals.flip();
			hStagingBufferVertices.upload(sceneContext.stagingBufferVertices, dynamicOffsetVertices * 4L * VERTEX_SIZE);
			hStagingBufferUvs.upload(sceneContext.stagingBufferUvs, dynamicOffsetUvs * 4L * UV_SIZE);
			hStagingBufferNormals.upload(sceneContext.stagingBufferNormals, dynamicOffsetVertices * 4L * NORMAL_SIZE);
			sceneContext.stagingBufferVertices.clear();
			sceneContext.stagingBufferUvs.clear();
			sceneContext.stagingBufferNormals.clear();

			// Model buffers
			modelPassthroughBuffer.flip();
			hModelPassthroughBuffer.upload(modelPassthroughBuffer);
			modelPassthroughBuffer.clear();

			for (int i = 0; i < modelSortingBuffers.length; i++) {
				var buffer = modelSortingBuffers[i];
				buffer.flip();
				hModelSortingBuffers[i].upload(buffer);
				buffer.clear();
			}

			// Output buffers
			// each vertex is an ivec4, which is 16 bytes
			hRenderBufferVertices.ensureCapacity(renderBufferOffset * 16L);
			// each vertex is an ivec4, which is 16 bytes
			hRenderBufferUvs.ensureCapacity(renderBufferOffset * 16L);
			// each vertex is an ivec4, which is 16 bytes
			hRenderBufferNormals.ensureCapacity(renderBufferOffset * 16L);
			updateSceneVao(hRenderBufferVertices, hRenderBufferUvs, hRenderBufferNormals);
		}

		frameTimer.end(Timer.UPLOAD_GEOMETRY);
		frameTimer.begin(Timer.COMPUTE);

		uboCompute.upload();

		if (computeMode == ComputeMode.OPENCL) {
			// The docs for clEnqueueAcquireGLObjects say all pending GL operations must be completed before calling
			// clEnqueueAcquireGLObjects, and recommends calling glFinish() as the only portable way to do that.
			// However, no issues have been observed from not calling it, and so will leave disabled for now.
			// glFinish();

			clManager.compute(
				uboCompute.glBuffer,
				numPassthroughModels, numModelsToSort,
				hModelPassthroughBuffer, hModelSortingBuffers,
				hStagingBufferVertices, hStagingBufferUvs, hStagingBufferNormals,
				hRenderBufferVertices, hRenderBufferUvs, hRenderBufferNormals
			);
		} else {
			// Compute is split into a passthrough shader for unsorted models,
			// and multiple sizes of sorting shaders to better utilize the GPU

			// Bind shared buffers
			glBindBufferBase(GL43C.GL_SHADER_STORAGE_BUFFER, 1, hStagingBufferVertices.id);
			glBindBufferBase(GL43C.GL_SHADER_STORAGE_BUFFER, 2, hStagingBufferUvs.id);
			glBindBufferBase(GL43C.GL_SHADER_STORAGE_BUFFER, 3, hStagingBufferNormals.id);
			glBindBufferBase(GL43C.GL_SHADER_STORAGE_BUFFER, 4, hRenderBufferVertices.id);
			glBindBufferBase(GL43C.GL_SHADER_STORAGE_BUFFER, 5, hRenderBufferUvs.id);
			glBindBufferBase(GL43C.GL_SHADER_STORAGE_BUFFER, 6, hRenderBufferNormals.id);

			// unordered
			modelPassthroughComputeProgram.use();
			glBindBufferBase(GL43C.GL_SHADER_STORAGE_BUFFER, 0, hModelPassthroughBuffer.id);
			GL43C.glDispatchCompute(numPassthroughModels, 1, 1);

			for (int i = 0; i < numModelsToSort.length; i++) {
				if (numModelsToSort[i] == 0)
					continue;

				modelSortingComputePrograms.get(i).use();
				glBindBufferBase(GL43C.GL_SHADER_STORAGE_BUFFER, 0, hModelSortingBuffers[i].id);
				GL43C.glDispatchCompute(numModelsToSort[i], 1, 1);
			}
		}

		frameTimer.end(Timer.COMPUTE);

		checkGLErrors();

		if (!redrawPreviousFrame) {
			numPassthroughModels = 0;
			Arrays.fill(numModelsToSort, 0);
		}
	}

	@Override
	public void drawScenePaint(Scene scene, SceneTilePaint paint, int plane, int tileX, int tileY) {
		if (redrawPreviousFrame || paint.getBufferLen() <= 0)
			return;

		int vertexCount = paint.getBufferLen();

		++numPassthroughModels;
		modelPassthroughBuffer
			.ensureCapacity(16)
			.getBuffer()
			.put(paint.getBufferOffset())
			.put(paint.getUvBufferOffset())
			.put(vertexCount / 3)
			.put(renderBufferOffset)
			.put(0)
			.put(tileX * LOCAL_TILE_SIZE)
			.put(0)
			.put(tileY * LOCAL_TILE_SIZE);

		renderBufferOffset += vertexCount;
		drawnTileCount++;
	}

	public void initShaderHotswapping() {
		SHADER_PATH.watch("\\.(glsl|cl)$", path -> {
			log.info("Recompiling shaders: {}", path);
			recompilePrograms();
		});
	}

	@Override
	public void drawSceneTileModel(Scene scene, SceneTileModel model, int tileX, int tileY) {
		if (redrawPreviousFrame || model.getBufferLen() <= 0)
			return;

		final int localX = tileX * LOCAL_TILE_SIZE;
		final int localY = 0;
		final int localZ = tileY * LOCAL_TILE_SIZE;

		GpuIntBuffer b = modelPassthroughBuffer;
		b.ensureCapacity(16);
		IntBuffer buffer = b.getBuffer();

		int bufferLength = model.getBufferLen();

		// we packed a boolean into the buffer length of tiles so we can tell
		// which tiles have procedurally-generated underwater terrain.
		// unpack the boolean:
		boolean underwaterTerrain = (bufferLength & 1) == 1;
		// restore the bufferLength variable:
		bufferLength = bufferLength >> 1;

		if (underwaterTerrain) {
			// draw underwater terrain tile before surface tile

			// buffer length includes the generated underwater terrain, so it must be halved
			bufferLength /= 2;

			++numPassthroughModels;

			buffer.put(model.getBufferOffset() + bufferLength);
			buffer.put(model.getUvBufferOffset() + bufferLength);
			buffer.put(bufferLength / 3);
			buffer.put(renderBufferOffset);
			buffer.put(0);
			buffer.put(localX).put(localY).put(localZ);

			renderBufferOffset += bufferLength;
			drawnTileCount++;
		}

		++numPassthroughModels;

		buffer.put(model.getBufferOffset());
		buffer.put(model.getUvBufferOffset());
		buffer.put(bufferLength / 3);
		buffer.put(renderBufferOffset);
		buffer.put(0);
		buffer.put(localX).put(localY).put(localZ);

		renderBufferOffset += bufferLength;
		drawnTileCount++;
	}

	private void prepareInterfaceTexture() {
		int[] resolution = {
			max(1, client.getCanvasWidth()),
			max(1, client.getCanvasHeight())
		};
		boolean resize = !Arrays.equals(uiResolution, resolution);
		if (resize) {
			uiResolution = resolution;

			glBindBuffer(GL_PIXEL_UNPACK_BUFFER, pboUi);
			glBufferData(GL_PIXEL_UNPACK_BUFFER, uiResolution[0] * uiResolution[1] * 4L, GL_STREAM_DRAW);
			glBindBuffer(GL_PIXEL_UNPACK_BUFFER, 0);

			glActiveTexture(TEXTURE_UNIT_UI);
			glBindTexture(GL_TEXTURE_2D, texUi);
			glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, uiResolution[0], uiResolution[1], 0, GL_BGRA, GL_UNSIGNED_BYTE, 0);
		}

		if (client.isStretchedEnabled()) {
			Dimension dim = client.getStretchedDimensions();
			actualUiResolution[0] = dim.width;
			actualUiResolution[1] = dim.height;
		} else {
			copyTo(actualUiResolution, uiResolution);
		}
		round(actualUiResolution, multiply(vec(actualUiResolution), getDpiScaling()));

		if (configAsyncUICopy) {
			// Start copying the UI on a different thread, to be uploaded during the next frame
			asyncUICopy.prepare(pboUi, texUi);
			// If the window was just resized, upload once synchronously so there is something to show
			if (resize)
				asyncUICopy.complete();
			return;
		}

		final BufferProvider bufferProvider = client.getBufferProvider();
		final int[] pixels = bufferProvider.getPixels();
		final int width = bufferProvider.getWidth();
		final int height = bufferProvider.getHeight();

		frameTimer.begin(Timer.MAP_UI_BUFFER);
		glBindBuffer(GL_PIXEL_UNPACK_BUFFER, pboUi);
		ByteBuffer mappedBuffer = glMapBuffer(GL_PIXEL_UNPACK_BUFFER, GL_WRITE_ONLY);
		frameTimer.end(Timer.MAP_UI_BUFFER);
		if (mappedBuffer == null) {
			log.error("Unable to map interface PBO. Skipping UI...");
		} else if (width > uiResolution[0] || height > uiResolution[1]) {
			log.error("UI texture resolution mismatch ({}x{} > {}). Skipping UI...", width, height, uiResolution);
		} else {
			frameTimer.begin(Timer.COPY_UI);
			mappedBuffer.asIntBuffer().put(pixels, 0, width * height);
			frameTimer.end(Timer.COPY_UI);

			frameTimer.begin(Timer.UPLOAD_UI);
			glUnmapBuffer(GL_PIXEL_UNPACK_BUFFER);
			glActiveTexture(TEXTURE_UNIT_UI);
			glBindTexture(GL_TEXTURE_2D, texUi);
			glTexSubImage2D(GL_TEXTURE_2D, 0, 0, 0, width, height, GL_BGRA, GL_UNSIGNED_INT_8_8_8_8_REV, 0);
			frameTimer.end(Timer.UPLOAD_UI);
		}
		glBindBuffer(GL_PIXEL_UNPACK_BUFFER, 0);
	}

	@Override
	public void draw(int overlayColor) {
		final GameState gameState = client.getGameState();
		if (gameState == GameState.STARTING) {
			frameTimer.end(Timer.DRAW_FRAME);
			return;
		}

		if (lastFrameTimeMillis > 0) {
			deltaTime = (float) ((System.currentTimeMillis() - lastFrameTimeMillis) / 1000.);

			// Restart the plugin to avoid potential buffer corruption if the computer has likely resumed from suspension
			if (deltaTime > 300) {
				log.debug("Restarting the plugin after probable OS suspend ({} second delta)", deltaTime);
				restartPlugin();
				return;
			}

			// If system time changes between frames, clamp the delta to a more sensible value
			if (abs(deltaTime) > 10)
				deltaTime = 1 / 60.f;
			elapsedTime += deltaTime;
			windOffset += deltaTime * environmentManager.currentWindSpeed;

			// The client delta doesn't need clamping
			deltaClientTime = (float) (elapsedClientTime - lastFrameClientTime);
		}
		lastFrameTimeMillis = System.currentTimeMillis();
		lastFrameClientTime = elapsedClientTime;

		try {
			prepareInterfaceTexture();
		} catch (Exception ex) {
			// Fixes: https://github.com/runelite/runelite/issues/12930
			// Gracefully Handle loss of opengl buffers and context
			log.warn("prepareInterfaceTexture exception", ex);
			restartPlugin();
			return;
		}

		// Upon logging in, the client will draw some frames with zero geometry before it hides the login screen
		if (renderBufferOffset > 0)
			hasLoggedIn = true;

		updateSceneFbo();

		// Draw 3d scene
		if (hasLoggedIn && sceneContext != null && sceneViewport != null) {
			// Before reading the SSBOs written to from postDrawScene() we must insert a barrier
			if (computeMode == ComputeMode.OPENCL) {
				clManager.finish();
			} else {
				GL43C.glMemoryBarrier(GL43C.GL_SHADER_STORAGE_BARRIER_BIT);
			}

			float[] fogColor = ColorUtils.linearToSrgb(environmentManager.currentFogColor);
			float fogDepth = 0;
			switch (config.fogDepthMode()) {
				case USER_DEFINED:
					fogDepth = config.fogDepth();
					break;
				case DYNAMIC:
					fogDepth = environmentManager.currentFogDepth;
					break;
			}
			fogDepth *= min(getDrawDistance(), 90) / 10.f;
			uboGlobal.useFog.set(fogDepth > 0 ? 1 : 0);
			uboGlobal.fogDepth.set(fogDepth);
			uboGlobal.fogColor.set(fogColor);

			uboGlobal.drawDistance.set((float) getDrawDistance());
			uboGlobal.expandedMapLoadingChunks.set(sceneContext.expandedMapLoadingChunks);
			uboGlobal.colorBlindnessIntensity.set(config.colorBlindnessIntensity() / 100.f);

			float[] waterColorHsv = ColorUtils.srgbToHsv(environmentManager.currentWaterColor);
			float lightBrightnessMultiplier = 0.8f;
			float midBrightnessMultiplier = 0.45f;
			float darkBrightnessMultiplier = 0.05f;
			float[] waterColorLight = ColorUtils.linearToSrgb(ColorUtils.hsvToSrgb(new float[] {
				waterColorHsv[0],
				waterColorHsv[1],
				waterColorHsv[2] * lightBrightnessMultiplier
			}));
			float[] waterColorMid = ColorUtils.linearToSrgb(ColorUtils.hsvToSrgb(new float[] {
				waterColorHsv[0],
				waterColorHsv[1],
				waterColorHsv[2] * midBrightnessMultiplier
			}));
			float[] waterColorDark = ColorUtils.linearToSrgb(ColorUtils.hsvToSrgb(new float[] {
				waterColorHsv[0],
				waterColorHsv[1],
				waterColorHsv[2] * darkBrightnessMultiplier
			}));
			uboGlobal.waterColorLight.set(waterColorLight);
			uboGlobal.waterColorMid.set(waterColorMid);
			uboGlobal.waterColorDark.set(waterColorDark);

			uboGlobal.gammaCorrection.set(getGammaCorrection());
			float ambientStrength = environmentManager.currentAmbientStrength;
			float directionalStrength = environmentManager.currentDirectionalStrength;
			if (config.useLegacyBrightness()) {
				float factor = config.legacyBrightness() / 20f;
				ambientStrength *= factor;
				directionalStrength *= factor;
			}
			uboGlobal.ambientStrength.set(ambientStrength);
			uboGlobal.ambientColor.set(environmentManager.currentAmbientColor);
			uboGlobal.lightStrength.set(directionalStrength);
			uboGlobal.lightColor.set(environmentManager.currentDirectionalColor);

			uboGlobal.underglowStrength.set(environmentManager.currentUnderglowStrength);
			uboGlobal.underglowColor.set(environmentManager.currentUnderglowColor);

			uboGlobal.groundFogStart.set(environmentManager.currentGroundFogStart);
			uboGlobal.groundFogEnd.set(environmentManager.currentGroundFogEnd);
			uboGlobal.groundFogOpacity.set(config.groundFog() ? environmentManager.currentGroundFogOpacity : 0);

			// Lights & lightning
			uboGlobal.pointLightsCount.set(sceneContext.numVisibleLights);
			uboGlobal.lightningBrightness.set(environmentManager.getLightningBrightness());

			uboGlobal.saturation.set(config.saturation() / 100f);
			uboGlobal.contrast.set(config.contrast() / 100f);
			uboGlobal.underwaterEnvironment.set(environmentManager.isUnderwater() ? 1 : 0);
			uboGlobal.underwaterCaustics.set(config.underwaterCaustics() ? 1 : 0);
			uboGlobal.underwaterCausticsColor.set(environmentManager.currentUnderwaterCausticsColor);
			uboGlobal.underwaterCausticsStrength.set(environmentManager.currentUnderwaterCausticsStrength);
			uboGlobal.elapsedTime.set((float) (elapsedTime % MAX_FLOAT_WITH_128TH_PRECISION));

			float[] lightViewMatrix = Mat4.rotateX(environmentManager.currentSunAngles[0]);
			Mat4.mul(lightViewMatrix, Mat4.rotateY(PI - environmentManager.currentSunAngles[1]));
			// Extract the 3rd column from the light view matrix (the float array is column-major).
			// This produces the light's direction vector in world space, which we negate in order to
			// get the light's direction vector pointing away from each fragment
			uboGlobal.lightDir.set(-lightViewMatrix[2], -lightViewMatrix[6], -lightViewMatrix[10]);

			if (configColorFilter != ColorFilter.NONE) {
				uboGlobal.colorFilter.set(configColorFilter.ordinal());
				uboGlobal.colorFilterPrevious.set(configColorFilterPrevious.ordinal());
				long timeSinceChange = System.currentTimeMillis() - colorFilterChangedAt;
				uboGlobal.colorFilterFade.set(clamp(timeSinceChange / COLOR_FILTER_FADE_DURATION, 0, 1));
			}

			if (configShadowsEnabled && fboShadowMap != 0 && environmentManager.currentDirectionalStrength > 0) {
				frameTimer.begin(Timer.RENDER_SHADOWS);

				// Render to the shadow depth map
				glViewport(0, 0, shadowMapResolution, shadowMapResolution);
				glBindFramebuffer(GL_FRAMEBUFFER, fboShadowMap);
				glClearDepth(1);
				glClear(GL_DEPTH_BUFFER_BIT);
				glDepthFunc(GL_LEQUAL);

				shadowProgram.use();

				final int camX = cameraFocalPoint[0];
				final int camY = cameraFocalPoint[1];

				final int drawDistanceSceneUnits = min(config.shadowDistance().getValue(), getDrawDistance()) * LOCAL_TILE_SIZE / 2;
				final int east = min(camX + drawDistanceSceneUnits, LOCAL_TILE_SIZE * SCENE_SIZE);
				final int west = max(camX - drawDistanceSceneUnits, 0);
				final int north = min(camY + drawDistanceSceneUnits, LOCAL_TILE_SIZE * SCENE_SIZE);
				final int south = max(camY - drawDistanceSceneUnits, 0);
				final int width = east - west;
				final int height = north - south;
				final int depthScale = 10000;

				final int maxDrawDistance = 90;
				final float maxScale = 0.7f;
				final float minScale = 0.4f;
				final float scaleMultiplier = 1.0f - (getDrawDistance() / (maxDrawDistance * maxScale));
				float scale = mix(maxScale, minScale, scaleMultiplier);
				float[] lightProjectionMatrix = Mat4.identity();
				Mat4.mul(lightProjectionMatrix, Mat4.scale(scale, scale, scale));
				Mat4.mul(lightProjectionMatrix, Mat4.orthographic(width, height, depthScale));
				Mat4.mul(lightProjectionMatrix, lightViewMatrix);
				Mat4.mul(lightProjectionMatrix, Mat4.translate(-(width / 2f + west), 0, -(height / 2f + south)));

				uboGlobal.lightProjectionMatrix.set(lightProjectionMatrix);
				uboGlobal.upload();

				glEnable(GL_CULL_FACE);
				glEnable(GL_DEPTH_TEST);

				glBindVertexArray(vaoScene);
				glDrawArrays(GL_TRIANGLES, 0, renderBufferOffset);

				glDisable(GL_CULL_FACE);
				glDisable(GL_DEPTH_TEST);

				frameTimer.end(Timer.RENDER_SHADOWS);
			}

			uboGlobal.upload();
			sceneProgram.use();

			glBindFramebuffer(GL_DRAW_FRAMEBUFFER, fboScene);
			glToggle(GL_MULTISAMPLE, msaaSamples > 1);
			glViewport(0, 0, sceneResolution[0], sceneResolution[1]);

			// Clear scene
			frameTimer.begin(Timer.CLEAR_SCENE);

			float[] gammaCorrectedFogColor = pow(fogColor, getGammaCorrection());
			glClearColor(
				gammaCorrectedFogColor[0],
				gammaCorrectedFogColor[1],
				gammaCorrectedFogColor[2],
				1f
			);
			glClearDepth(0);
			glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
			frameTimer.end(Timer.CLEAR_SCENE);

			frameTimer.begin(Timer.RENDER_SCENE);

			// We just allow the GL to do face culling. Note this requires the priority renderer
			// to have logic to disregard culled faces in the priority depth testing.
			glEnable(GL_CULL_FACE);
			glCullFace(GL_BACK);

			// Enable blending for alpha
			glEnable(GL_BLEND);
			glBlendFuncSeparate(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA, GL_ZERO, GL_ONE);

			// Draw with buffers bound to scene VAO
			glBindVertexArray(vaoScene);

			// When there are custom tiles, we need depth testing to draw them in the correct order, but the rest of the
			// scene doesn't support depth testing, so we only write depths for custom tiles.
			if (sceneContext.staticCustomTilesVertexCount > 0) {
				// Draw gap filler tiles first, without depth testing
				if (sceneContext.staticGapFillerTilesVertexCount > 0) {
					glDisable(GL_DEPTH_TEST);
					glDrawArrays(
						GL_TRIANGLES,
						sceneContext.staticGapFillerTilesOffset,
						sceneContext.staticGapFillerTilesVertexCount
					);
				}

				glEnable(GL_DEPTH_TEST);
				glDepthFunc(GL_GREATER);

				// Draw custom tiles, writing depth
				glDepthMask(true);
				glDrawArrays(
					GL_TRIANGLES,
					sceneContext.staticCustomTilesOffset,
					sceneContext.staticCustomTilesVertexCount
				);

				// Draw the rest of the scene with depth testing, but not against itself
				glDepthMask(false);
				glDrawArrays(
					GL_TRIANGLES,
					sceneContext.staticVertexCount,
					renderBufferOffset - sceneContext.staticVertexCount
				);
			} else {
				// Draw everything without depth testing
				glDisable(GL_DEPTH_TEST);
				glDrawArrays(GL_TRIANGLES, 0, renderBufferOffset);
			}

			frameTimer.end(Timer.RENDER_SCENE);

			glDisable(GL_BLEND);
			glDisable(GL_CULL_FACE);
			glDisable(GL_MULTISAMPLE);
			glDisable(GL_DEPTH_TEST);
			glDepthMask(true);
			glUseProgram(0);

			glBindFramebuffer(GL_READ_FRAMEBUFFER, fboScene);
			if (fboSceneResolve != 0) {
				// Blit from the scene FBO to the multisample resolve FBO
				glBindFramebuffer(GL_DRAW_FRAMEBUFFER, fboSceneResolve);
				glBlitFramebuffer(
					0, 0, sceneResolution[0], sceneResolution[1],
					0, 0, sceneResolution[0], sceneResolution[1],
					GL_COLOR_BUFFER_BIT, GL_NEAREST
				);
				glBindFramebuffer(GL_READ_FRAMEBUFFER, fboSceneResolve);
			}

			// Blit from the resolved FBO to the default FBO
			glBindFramebuffer(GL_DRAW_FRAMEBUFFER, awtContext.getFramebuffer(false));
			glBlitFramebuffer(
				0, 0, sceneResolution[0], sceneResolution[1],
				sceneViewport[0], sceneViewport[1], sceneViewport[0] + sceneViewport[2], sceneViewport[1] + sceneViewport[3],
				GL_COLOR_BUFFER_BIT, config.sceneScalingMode().glFilter
			);
		} else {
			glClearColor(0, 0, 0, 1f);
			glClear(GL_COLOR_BUFFER_BIT);
		}

		drawUi(overlayColor);

		try {
			frameTimer.begin(Timer.SWAP_BUFFERS);
			awtContext.swapBuffers();
			frameTimer.end(Timer.SWAP_BUFFERS);
			drawManager.processDrawComplete(this::screenshot);
		} catch (RuntimeException ex) {
			// this is always fatal
			if (!canvas.isValid()) {
				// this might be AWT shutting down on VM shutdown, ignore it
				return;
			}

			log.error("Unable to swap buffers:", ex);
		}

		glBindFramebuffer(GL_FRAMEBUFFER, awtContext.getFramebuffer(false));

		frameTimer.end(Timer.DRAW_FRAME);
		frameTimer.end(Timer.RENDER_FRAME);
		frameTimer.endFrameAndReset();
		frameModelInfoMap.clear();
		checkGLErrors();

		// Process pending config changes after the EDT is done with any pending work, which could include further config changes
		if (!pendingConfigChanges.isEmpty())
			SwingUtilities.invokeLater(this::processPendingConfigChanges);
	}

	private void drawUi(int overlayColor) {
		if (uiResolution == null || developerTools.isHideUiEnabled() && hasLoggedIn)
			return;

		// Fix vanilla bug causing the overlay to remain on the login screen in areas like Fossil Island underwater
		if (client.getGameState().getState() < GameState.LOADING.getState())
			overlayColor = 0;

		frameTimer.begin(Timer.RENDER_UI);

		glBindFramebuffer(GL_FRAMEBUFFER, awtContext.getFramebuffer(false));
		// Disable alpha writes, just in case the default FBO has an alpha channel
		glColorMask(true, true, true, false);

		glViewport(0, 0, actualUiResolution[0], actualUiResolution[1]);

		tiledLightingOverlay.render();

		uiProgram.use();
		uboUI.sourceDimensions.set(uiResolution);
		uboUI.targetDimensions.set(actualUiResolution);
		uboUI.alphaOverlay.set(ColorUtils.srgba(overlayColor));
		uboUI.upload();

		// Set the sampling function used when stretching the UI.
		// This is probably better done with sampler objects instead of texture parameters, but this is easier and likely more portable.
		// See https://www.khronos.org/opengl/wiki/Sampler_Object for details.
		// GL_NEAREST makes sampling for bicubic/xBR simpler, so it should be used whenever linear isn't
		final int function = config.uiScalingMode() == UIScalingMode.LINEAR ? GL_LINEAR : GL_NEAREST;
		glActiveTexture(TEXTURE_UNIT_UI);
		glBindTexture(GL_TEXTURE_2D, texUi);
		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, function);
		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, function);

		glEnable(GL_BLEND);
		glBlendFuncSeparate(GL_ONE, GL_ONE_MINUS_SRC_ALPHA, GL_ZERO, GL_ONE);
		glBindVertexArray(vaoTri);
		glDrawArrays(GL_TRIANGLES, 0, 3);

		shadowMapOverlay.render();
		gammaCalibrationOverlay.render();

		// Reset
		glBlendFuncSeparate(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA, GL_ZERO, GL_ONE);
		glDisable(GL_BLEND);
		glColorMask(true, true, true, true);

		frameTimer.end(Timer.RENDER_UI);
	}

	/**
	 * Convert the front framebuffer to an Image
	 */
	private Image screenshot() {
		if (uiResolution == null)
			return null;

		int width = actualUiResolution[0];
		int height = actualUiResolution[1];

		ByteBuffer buffer = BufferUtils.createByteBuffer(width * height * 4);

		glReadBuffer(awtContext.getBufferMode());
		glReadPixels(0, 0, width, height, GL_RGBA, GL_UNSIGNED_BYTE, buffer);

		BufferedImage image = new BufferedImage(width, height, BufferedImage.TYPE_INT_RGB);
		int[] pixels = ((DataBufferInt) image.getRaster().getDataBuffer()).getData();

		for (int y = 0; y < height; ++y)
		{
			for (int x = 0; x < width; ++x)
			{
				int r = buffer.get() & 0xff;
				int g = buffer.get() & 0xff;
				int b = buffer.get() & 0xff;
				buffer.get(); // alpha

				pixels[(height - y - 1) * width + x] = (r << 16) | (g << 8) | b;
			}
		}

		return image;
	}

	@Override
	public void animate(Texture texture, int diff) {}

	@Subscribe
	public void onGameStateChanged(GameStateChanged gameStateChanged) {
		if (gameStateChanged.getGameState() == GameState.LOGIN_SCREEN) {
			renderBufferOffset = 0;
			hasLoggedIn = false;
			environmentManager.reset();
		}
	}

	public void reuploadScene() {
		assert client.isClientThread() : "Loading a scene is unsafe while the client can modify it";
		if (client.getGameState().getState() < GameState.LOGGED_IN.getState())
			return;
		Scene scene = client.getScene();
		loadScene(scene);
		if (skipScene == scene)
			skipScene = null;
		swapScene(scene);
	}

	@Override
	public void loadScene(Scene scene) {
		if (!isActive)
			return;

		int expandedChunks = getExpandedMapLoadingChunks();
		if (HDUtils.sceneIntersects(scene, expandedChunks, areaManager.getArea("PLAYER_OWNED_HOUSE"))) {
			// Reload once the POH is done loading
			if (!isInHouse)
				reloadSceneIn(2);
		} else if (skipScene != scene && HDUtils.sceneIntersects(scene, expandedChunks, areaManager.getArea("THE_GAUNTLET"))) {
			// Some game objects in The Gauntlet are spawned in too late for the initial scene load,
			// so we skip the first scene load and trigger another scene load the next game tick
			reloadSceneNextGameTick();
			skipScene = scene;
			return;
		}

		if (useLowMemoryMode)
			return; // Force scene loading to happen on the client thread

		loadSceneInternal(scene);
	}

	public boolean isLoadingScene() {
		return nextSceneContext != null;
	}

	private synchronized void loadSceneInternal(Scene scene) {
		if (nextSceneContext != null)
			nextSceneContext.destroy();
		nextSceneContext = null;

		try {
			// Because scene contexts are always swapped on the client thread, it is guaranteed to only be
			// in use by the client thread, meaning we can reuse all of its buffers if we are loading the
			// next scene also on the client thread
			boolean reuseBuffers = client.isClientThread();
			nextSceneContext = new SceneContext(client, scene, getExpandedMapLoadingChunks(), reuseBuffers, sceneContext);
			proceduralGenerator.generateSceneData(nextSceneContext);
			environmentManager.loadSceneEnvironments(nextSceneContext);
			sceneUploader.upload(nextSceneContext);
		} catch (OutOfMemoryError oom) {
			log.error("Ran out of memory while loading scene (32-bit: {}, low memory mode: {}, cache size: {})",
				HDUtils.is32Bit(), useLowMemoryMode, config.modelCacheSizeMiB(), oom
			);
			displayOutOfMemoryMessage();
			stopPlugin();
		} catch (Throwable ex) {
			log.error("Error while loading scene:", ex);
			stopPlugin();
		}
	}

	@Override
	public synchronized void swapScene(Scene scene) {
		if (!isActive || skipScene == scene) {
			redrawPreviousFrame = true;
			return;
		}

		// If the scene wasn't loaded by a call to loadScene, load it synchronously instead
		if (nextSceneContext == null) {
			loadSceneInternal(scene);
			if (nextSceneContext == null)
				return; // Return early if scene loading failed
		}

		if (computeMode == ComputeMode.OPENCL) {
			clManager.uploadTileHeights(scene);
		} else {
			initTileHeightMap(scene);
		}

		tileVisibilityCached = false;
		lightManager.loadSceneLights(nextSceneContext, sceneContext);
		fishingSpotReplacer.despawnRuneLiteObjects();
		npcDisplacementCache.clear();

		if (sceneContext != null)
			sceneContext.destroy();
		sceneContext = nextSceneContext;
		nextSceneContext = null;
		assert sceneContext != null;

		sceneUploader.prepareBeforeSwap(sceneContext);

		sceneContext.staticUnorderedModelBuffer.flip();

		dynamicOffsetVertices = sceneContext.getVertexOffset();
		dynamicOffsetUvs = sceneContext.getUvOffset();

		sceneContext.stagingBufferVertices.flip();
		sceneContext.stagingBufferUvs.flip();
		sceneContext.stagingBufferNormals.flip();
		hStagingBufferVertices.upload(sceneContext.stagingBufferVertices);
		hStagingBufferUvs.upload(sceneContext.stagingBufferUvs);
		hStagingBufferNormals.upload(sceneContext.stagingBufferNormals);
		sceneContext.stagingBufferVertices.clear();
		sceneContext.stagingBufferUvs.clear();
		sceneContext.stagingBufferNormals.clear();

		if (sceneContext.intersects(areaManager.getArea("PLAYER_OWNED_HOUSE"))) {
			isInHouse = true;
			isInChambersOfXeric = false;
		} else {
			isInHouse = false;
			isInChambersOfXeric = sceneContext.intersects(areaManager.getArea("CHAMBERS_OF_XERIC"));
		}
	}

	public void reloadSceneNextGameTick() {
		reloadSceneIn(1);
	}

	public void reloadSceneIn(int gameTicks) {
		assert gameTicks > 0 : "A value <= 0 will not reload the scene";
		if (gameTicks > gameTicksUntilSceneReload)
			gameTicksUntilSceneReload = gameTicks;
	}

	private void updateCachedConfigs() {
		configShadowMode = config.shadowMode();
		configShadowsEnabled = configShadowMode != ShadowMode.OFF;
		configGroundTextures = config.groundTextures();
		configGroundBlending = config.groundBlending();
		configModelTextures = config.modelTextures();
		configTzhaarHD = config.hdTzHaarReskin();
		configProjectileLights = config.projectileLights();
		configNpcLights = config.npcLights();
		configVanillaShadowMode = config.vanillaShadowMode();
		configHideFakeShadows = configVanillaShadowMode != VanillaShadowMode.SHOW;
		configLegacyGreyColors = config.legacyGreyColors();
		configModelBatching = config.modelBatching();
		configModelCaching = config.modelCaching();
		configDynamicLights = config.dynamicLights();
		configTiledLighting = config.tiledLighting();
		configExpandShadowDraw = config.expandShadowDraw();
		configUseFasterModelHashing = config.fasterModelHashing();
		configUndoVanillaShading = config.shadingMode() != ShadingMode.VANILLA;
		configPreserveVanillaNormals = config.preserveVanillaNormals();
		configAsyncUICopy = config.asyncUICopy();
		configWindDisplacement = config.windDisplacement();
		configCharacterDisplacement = config.characterDisplacement();
		configSeasonalTheme = config.seasonalTheme();
		configSeasonalHemisphere = config.seasonalHemisphere();

		var newColorFilter = config.colorFilter();
		if (newColorFilter != configColorFilter) {
			configColorFilterPrevious = configColorFilter;
			configColorFilter = newColorFilter;
			colorFilterChangedAt = System.currentTimeMillis();
		}
		if (configColorFilter == ColorFilter.CEL_SHADING) {
			configGroundTextures = false;
			configModelTextures = false;
		}

		if (configSeasonalTheme == SeasonalTheme.AUTOMATIC) {
			var time = ZonedDateTime.now(ZoneOffset.UTC);

			if (configSeasonalHemisphere == SeasonalHemisphere.NORTHERN) {
				switch (time.getMonth()) {
					case SEPTEMBER:
					case OCTOBER:
					case NOVEMBER:
						configSeasonalTheme = SeasonalTheme.AUTUMN;
						break;
					case DECEMBER:
					case JANUARY:
					case FEBRUARY:
						configSeasonalTheme = SeasonalTheme.WINTER;
						break;
					default:
						configSeasonalTheme = SeasonalTheme.SUMMER;
						break;
				}
			} else {
				switch (time.getMonth()) {
					case MARCH:
					case APRIL:
					case MAY:
						configSeasonalTheme = SeasonalTheme.AUTUMN;
						break;
					case JUNE:
					case JULY:
					case AUGUST:
						configSeasonalTheme = SeasonalTheme.WINTER;
						break;
					default:
						configSeasonalTheme = SeasonalTheme.SUMMER;
						break;
				}
			}
		}
	}

	@Subscribe
	public void onConfigChanged(ConfigChanged event) {
		// Exit if the plugin is off, the config is unrelated to the plugin, or if switching to a profile with the plugin turned off
		if (!isActive || !event.getGroup().equals(CONFIG_GROUP) || !pluginManager.isPluginEnabled(this))
			return;

		synchronized (this) {
			pendingConfigChanges.add(event.getKey());
		}
	}

	private void processPendingConfigChanges() {
		clientThread.invoke(() -> {
			if (pendingConfigChanges.isEmpty())
				return;

			try {
				// Synchronize with scene loading
				synchronized (this) {
					updateCachedConfigs();

					log.debug("Processing {} pending config changes: {}", pendingConfigChanges.size(), pendingConfigChanges);

					boolean recompilePrograms = false;
					boolean recreateSceneFbo = false;
					boolean recreateShadowMapFbo = false;
					boolean reloadTexturesAndMaterials = false;
					boolean reloadEnvironments = false;
					boolean reloadModelOverrides = false;
					boolean reloadTileOverrides = false;
					boolean reloadScene = false;
					boolean clearModelCache = false;
					boolean resizeModelCache = false;

					for (var key : pendingConfigChanges) {
						switch (key) {
							case KEY_SEASONAL_THEME:
							case KEY_SEASONAL_HEMISPHERE:
							case KEY_GROUND_BLENDING:
							case KEY_GROUND_TEXTURES:
								reloadTileOverrides = true;
								break;
							case KEY_COLOR_FILTER:
								if (configColorFilter == ColorFilter.NONE || configColorFilterPrevious == ColorFilter.NONE)
									recompilePrograms = true;
								if (configColorFilter == ColorFilter.CEL_SHADING || configColorFilterPrevious == ColorFilter.CEL_SHADING)
									clearModelCache = reloadScene = true;
								break;
							case KEY_ASYNC_UI_COPY:
								asyncUICopy.complete();
								break;
						}

						switch (key) {
							case KEY_EXPANDED_MAP_LOADING_CHUNKS:
								client.setExpandedMapLoading(getExpandedMapLoadingChunks());
								// fall-through
							case KEY_HIDE_UNRELATED_AREAS:
								if (client.getGameState() == GameState.LOGGED_IN)
									client.setGameState(GameState.LOADING);
								break;
							case KEY_COLOR_BLINDNESS:
							case KEY_MACOS_INTEL_WORKAROUND:
							case KEY_DYNAMIC_LIGHTS:
							case KEY_TILED_LIGHTING:
							case KEY_NORMAL_MAPPING:
							case KEY_PARALLAX_OCCLUSION_MAPPING:
							case KEY_UI_SCALING_MODE:
							case KEY_VANILLA_COLOR_BANDING:
							case KEY_WIND_DISPLACEMENT:
							case KEY_CHARACTER_DISPLACEMENT:
							case KEY_WIREFRAME:
							case KEY_PIXELATED_SHADOWS:
								recompilePrograms = true;
								break;
							case KEY_ANTI_ALIASING_MODE:
							case KEY_SCENE_RESOLUTION_SCALE:
								recreateSceneFbo = true;
								break;
							case KEY_SHADOW_MODE:
							case KEY_SHADOW_TRANSPARENCY:
								recompilePrograms = true;
								// fall-through
							case KEY_SHADOW_RESOLUTION:
								recreateShadowMapFbo = true;
								break;
							case KEY_ATMOSPHERIC_LIGHTING:
								reloadEnvironments = true;
								break;
							case KEY_SEASONAL_THEME:
							case KEY_SEASONAL_HEMISPHERE:
								reloadEnvironments = true;
								reloadModelOverrides = true;
								// fall-through
							case KEY_ANISOTROPIC_FILTERING_LEVEL:
							case KEY_GROUND_TEXTURES:
							case KEY_MODEL_TEXTURES:
							case KEY_TEXTURE_RESOLUTION:
							case KEY_HD_INFERNAL_CAPE:
								reloadTexturesAndMaterials = true;
								// fall-through
							case KEY_GROUND_BLENDING:
							case KEY_FILL_GAPS_IN_TERRAIN:
							case KEY_HD_TZHAAR_RESKIN:
								clearModelCache = true;
								reloadScene = true;
								break;
							case KEY_VANILLA_SHADOW_MODE:
								reloadModelOverrides = true;
								reloadScene = true;
								break;
							case KEY_LEGACY_GREY_COLORS:
							case KEY_PRESERVE_VANILLA_NORMALS:
							case KEY_SHADING_MODE:
							case KEY_FLAT_SHADING:
								recompilePrograms = true;
								clearModelCache = true;
								reloadScene = true;
								break;
							case KEY_FPS_TARGET:
							case KEY_UNLOCK_FPS:
							case KEY_VSYNC_MODE:
								setupSyncMode();
								break;
							case KEY_MODEL_CACHE_SIZE:
							case KEY_MODEL_CACHING:
								resizeModelCache = true;
								break;
							case KEY_LOW_MEMORY_MODE:
							case KEY_REMOVE_VERTEX_SNAPPING:
								restartPlugin();
								// since we'll be restarting the plugin anyway, skip pending changes
								return;
							case KEY_FISHING_SPOT_STYLE:
								reloadModelOverrides = true;
								fishingSpotReplacer.despawnRuneLiteObjects();
								clientThread.invokeLater(fishingSpotReplacer::update);
								break;
						}
					}

					if (reloadTexturesAndMaterials || recompilePrograms)
						waitUntilIdle();

					if (reloadTexturesAndMaterials) {
						materialManager.reload(false);
						modelOverrideManager.reload();
						recompilePrograms = true;
						clearModelCache = true;
					} else if (reloadModelOverrides) {
						modelOverrideManager.reload();
						clearModelCache = true;
					}

					if (reloadTileOverrides) {
						tileOverrideManager.reload(false);
						reloadScene = true;
					}

					if (recompilePrograms)
						recompilePrograms();

					if (recreateSceneFbo) {
						destroySceneFbo();
						updateSceneFbo();
					}

					if (resizeModelCache) {
						modelPusher.shutDown();
						modelPusher.startUp();
					} else if (clearModelCache) {
						modelPusher.clearModelCache();
					}

					if (reloadScene)
						reuploadScene();

					if (recreateShadowMapFbo) {
						destroyShadowMapFbo();
						initShadowMapFbo();
					}

					if (reloadEnvironments)
						environmentManager.triggerTransition();
				}
			} catch (Throwable ex) {
				log.error("Error while changing settings:", ex);
				stopPlugin();
			} finally {
				pendingConfigChanges.clear();
				frameTimer.reset();
			}
		});
	}

	public void setupSyncMode() {
		// Without unlocked fps, the client manages sync on its 20ms timer
		boolean unlockFps = config.unlockFps();
		HdPluginConfig.SyncMode syncMode = unlockFps ? config.syncMode() : HdPluginConfig.SyncMode.OFF;

		if (frameTimer.isActive()) {
			unlockFps = true;
			syncMode = SyncMode.OFF;
		}

		client.setUnlockedFps(unlockFps);
		int swapInterval;
		switch (syncMode)
		{
			case ON:
				swapInterval = 1;
				break;
			case ADAPTIVE:
				swapInterval = -1;
				break;
			default:
			case OFF:
				swapInterval = 0;
				break;
		}

		int actualSwapInterval = awtContext.setSwapInterval(swapInterval);
		if (actualSwapInterval != swapInterval) {
			log.info("unsupported swap interval {}, got {}", swapInterval, actualSwapInterval);
		}

		client.setUnlockedFpsTarget(actualSwapInterval == 0 ? config.fpsTarget() : 0);
		checkGLErrors();
	}

	@Override
	public boolean tileInFrustum(
		Scene scene,
		float pitchSin,
		float pitchCos,
		float yawSin,
		float yawCos,
		int cameraX,
		int cameraY,
		int cameraZ,
		int plane,
		int tileExX,
		int tileExY
	) {
		if (sceneContext == null)
			return false;

		if (orthographicProjection)
			return true;

		if (tileVisibilityCached)
			return tileIsVisible[plane][tileExX][tileExY];

		int[][][] tileHeights = scene.getTileHeights();
		int x = ((tileExX - SCENE_OFFSET) << Perspective.LOCAL_COORD_BITS) + 64;
		int z = ((tileExY - SCENE_OFFSET) << Perspective.LOCAL_COORD_BITS) + 64;
		int y = GROUND_MIN_Y + max(
			tileHeights[plane][tileExX][tileExY],
			tileHeights[plane][tileExX][tileExY + 1],
			tileHeights[plane][tileExX + 1][tileExY],
			tileHeights[plane][tileExX + 1][tileExY + 1]
		);

		if (sceneContext.scene == scene) {
			int depthLevel = sceneContext.underwaterDepthLevels[plane][tileExX][tileExY];
			if (depthLevel > 0)
				y += ProceduralGenerator.DEPTH_LEVEL_SLOPE[depthLevel - 1] - GROUND_MIN_Y;
		}

		x -= (int) cameraPosition[0];
		y -= (int) cameraPosition[1];
		z -= (int) cameraPosition[2];

		final int tileRadius = 96; // ~ 64 * sqrt(2)
		final int leftClip = client.getRasterizer3D_clipNegativeMidX();
		final int rightClip = client.getRasterizer3D_clipMidX2();
		final int topClip = client.getRasterizer3D_clipNegativeMidY();

		// Transform the local coordinates using the yaw (horizontal rotation)
		final float transformedZ = yawCos * z - yawSin * x;
		final float depth = pitchCos * tileRadius + pitchSin * y + pitchCos * transformedZ;

		boolean visible = false;

		// Check if the tile is within the near plane of the frustum
		if (depth > NEAR_PLANE) {
			final float transformedX = z * yawSin + yawCos * x;
			final float leftPoint = transformedX - tileRadius;
			// Check left and right bounds
			if (leftPoint * visibilityCheckZoom < rightClip * depth) {
				final float rightPoint = transformedX + tileRadius;
				if (rightPoint * visibilityCheckZoom > leftClip * depth) {
					// Transform the local Y using pitch (vertical rotation)
					final float transformedY = pitchCos * y - transformedZ * pitchSin;
					final float bottomPoint = transformedY + pitchSin * tileRadius;
					// Check top bound (we skip bottom bound to avoid computing model heights)
					visible = bottomPoint * visibilityCheckZoom > topClip * depth;
				}
			}
		}

		return tileIsVisible[plane][tileExX][tileExY] = visible;
	}

	/**
	 * Check is a model is visible and should be drawn.
	 */
	private boolean isOutsideViewport(Model model, int modelRadius, float pitchSin, float pitchCos, float yawSin, float yawCos, int x, int y, int z) {
		if (sceneContext == null)
			return true;

		if (orthographicProjection)
			return false;

		final int leftClip = client.getRasterizer3D_clipNegativeMidX();
		final int rightClip = client.getRasterizer3D_clipMidX2();
		final int topClip = client.getRasterizer3D_clipNegativeMidY();
		final int bottomClip = client.getRasterizer3D_clipMidY2();

		final float transformedZ = yawCos * z - yawSin * x;
		final float depth = pitchCos * modelRadius + pitchSin * y + pitchCos * transformedZ;

		if (depth > NEAR_PLANE) {
			final float transformedX = z * yawSin + yawCos * x;
			final float leftPoint = transformedX - modelRadius;
			if (leftPoint * visibilityCheckZoom < rightClip * depth) {
				final float rightPoint = transformedX + modelRadius;
				if (rightPoint * visibilityCheckZoom > leftClip * depth) {
					final float transformedY = pitchCos * y - transformedZ * pitchSin;
					final float transformedRadius = pitchSin * modelRadius;
					final float bottomExtent = pitchCos * model.getBottomY() + transformedRadius;
					final float bottomPoint = transformedY + bottomExtent;
					if (bottomPoint * visibilityCheckZoom > topClip * depth) {
						final float topExtent = pitchCos * model.getModelHeight() + transformedRadius;
						final float topPoint = transformedY - topExtent;
						return topPoint * visibilityCheckZoom >= bottomClip * depth; // inverted check
					}
				}
			}
		}
		return true;
	}

	/**
	 * Draw a Renderable in the scene
	 *
	 * @param projection
	 * @param scene
	 * @param renderable  Can be an Actor (Player or NPC), DynamicObject, GraphicsObject, TileItem, Projectile or a raw Model.
	 * @param orientation Rotation around the up-axis, from 0 to 2048 exclusive, 2048 indicating a complete rotation.
	 * @param x           The Renderable's X offset relative to {@link Client#getCameraX()}.
	 * @param y           The Renderable's Y offset relative to {@link Client#getCameraZ()}.
	 * @param z           The Renderable's Z offset relative to {@link Client#getCameraY()}.
	 * @param hash        A unique hash of the renderable consisting of some useful information. See {@link rs117.hd.utils.ModelHash} for more details.
	 */
	@Override
	public void draw(Projection projection, @Nullable Scene scene, Renderable renderable, int orientation, int x, int y, int z, long hash) {
		if (sceneContext == null)
			return;

		// Hide everything outside the current area if area hiding is enabled
		if (sceneContext.currentArea != null) {
			assert sceneContext.sceneBase != null;
			boolean inArea = sceneContext.currentArea.containsPoint(
				sceneContext.sceneBase[0] + (x >> LOCAL_COORD_BITS),
				sceneContext.sceneBase[1] + (z >> LOCAL_COORD_BITS),
				sceneContext.sceneBase[2] + client.getPlane()
			);
			if (!inArea)
				return;
		}

		if (enableDetailedTimers)
			frameTimer.begin(Timer.GET_MODEL);

		Model model, offsetModel;
		try {
			// getModel may throw an exception from vanilla client code
			if (renderable instanceof Model) {
				model = (Model) renderable;
				offsetModel = model.getUnskewedModel();
				if (offsetModel == null)
					offsetModel = model;
			} else {
				offsetModel = model = renderable.getModel();
			}
			if (model == null || model.getFaceCount() == 0) {
				// skip models with zero faces
				// this does seem to happen sometimes (mostly during loading)
				// should save some CPU cycles here and there
				return;
			}
		} catch (Exception ex) {
			// Vanilla happens to handle exceptions thrown here gracefully, but we handle them explicitly anyway
			return;
		} finally {
			if (enableDetailedTimers)
				frameTimer.end(Timer.GET_MODEL);
		}

		// Apply height to renderable from the model
		int height = model.getModelHeight();
		if (model != renderable)
			renderable.setModelHeight(height);

		model.calculateBoundsCylinder();
		int modelRadius = model.getXYZMag(); // Model radius excluding height (model.getRadius() includes height)

		if (projection instanceof IntProjection) {
			var p = (IntProjection) projection;
			if (isOutsideViewport(
				model,
				modelRadius,
				p.getPitchSin(),
				p.getPitchCos(),
				p.getYawSin(),
				p.getYawCos(),
				x - p.getCameraX(),
				y - p.getCameraY(),
				z - p.getCameraZ()
			)) {
				return;
			}
		}

		client.checkClickbox(projection, model, orientation, x, y, z, hash);

		if (redrawPreviousFrame)
			return;

		if (enableDetailedTimers)
			frameTimer.begin(Timer.DRAW_RENDERABLE);

		eightIntWrite[3] = renderBufferOffset;
		eightIntWrite[4] = orientation;
		eightIntWrite[5] = x;
		eightIntWrite[6] = y << 16 | height & 0xFFFF; // Pack Y into the upper bits to easily preserve the sign
		eightIntWrite[7] = z;

		int plane = ModelHash.getPlane(hash);
		int faceCount;
		if (sceneContext.id == (offsetModel.getSceneId() & SceneUploader.SCENE_ID_MASK)) {
			// The model is part of the static scene buffer. The Renderable will then almost always be the Model instance, but if the scene
			// is reuploaded without triggering the LOADING game state, it's possible for static objects which may only temporarily become
			// animated to also be uploaded. This results in the Renderable being converted to a DynamicObject, whose `getModel` returns the
			// original static Model after the animation is done playing. One such example is in the POH, after it has been reuploaded in
			// order to cache newly loaded static models, and you subsequently attempt to interact with a wardrobe triggering its animation.
			faceCount = min(MAX_FACE_COUNT, offsetModel.getFaceCount());
			int vertexOffset = offsetModel.getBufferOffset();
			int uvOffset = offsetModel.getUvBufferOffset();
			boolean hillskew = offsetModel != model;

			eightIntWrite[0] = vertexOffset;
			eightIntWrite[1] = uvOffset;
			eightIntWrite[2] = faceCount;
			eightIntWrite[4] |= (hillskew ? 1 : 0) << 26 | plane << 24;

			drawnStaticRenderableCount++;
		} else {
			int uuid = ModelHash.generateUuid(client, hash, renderable);
			int[] worldPos = sceneContext.localToWorld(x, z, plane);
			ModelOverride modelOverride = modelOverrideManager.getOverride(uuid, worldPos);
			if (modelOverride.hide)
				return;

			// Disable color overrides when caching is disabled, since they are expensive on dynamic models
			if (!configModelCaching && modelOverride.colorOverrides != null)
				modelOverride = ModelOverride.NONE;

			int preOrientation = 0;
			if (ModelHash.getType(hash) == ModelHash.TYPE_OBJECT) {
				int tileExX = (x >> LOCAL_COORD_BITS) + SCENE_OFFSET;
				int tileExY = (z >> LOCAL_COORD_BITS) + SCENE_OFFSET;
				if (0 <= tileExX && tileExX < EXTENDED_SCENE_SIZE && 0 <= tileExY && tileExY < EXTENDED_SCENE_SIZE) {
					Tile tile = sceneContext.scene.getExtendedTiles()[plane][tileExX][tileExY];
					int config;
					if (tile != null && (config = sceneContext.getObjectConfig(tile, hash)) != -1) {
						preOrientation = HDUtils.getModelPreOrientation(config);
					} else if (plane > 0) {
						// Might be on a bridge tile
						tile = sceneContext.scene.getExtendedTiles()[plane - 1][tileExX][tileExY];
						if (tile != null && tile.getBridge() != null && (config = sceneContext.getObjectConfig(tile, hash)) != -1)
							preOrientation = HDUtils.getModelPreOrientation(config);
					}
				}
			}

			// Temporary model (animated or otherwise not a static Model already in the scene buffer)
			if (enableDetailedTimers)
				frameTimer.begin(Timer.MODEL_BATCHING);
			ModelOffsets modelOffsets = null;
			if (configModelBatching || configModelCaching) {
				modelHasher.setModel(model, modelOverride, preOrientation);
				// Disable model batching for models which have been excluded from the scene buffer,
				// because we want to avoid having to fetch the model override
				if (configModelBatching && offsetModel.getSceneId() != SceneUploader.EXCLUDED_FROM_SCENE_BUFFER) {
					modelOffsets = frameModelInfoMap.get(modelHasher.batchHash);
					if (modelOffsets != null && modelOffsets.faceCount != model.getFaceCount())
						modelOffsets = null; // Assume there's been a hash collision
				}
			}
			if (enableDetailedTimers)
				frameTimer.end(Timer.MODEL_BATCHING);

			if (modelOffsets != null && modelOffsets.faceCount == model.getFaceCount()) {
				faceCount = modelOffsets.faceCount;
				eightIntWrite[0] = modelOffsets.vertexOffset;
				eightIntWrite[1] = modelOffsets.uvOffset;
				eightIntWrite[2] = modelOffsets.faceCount;
			} else {
				if (enableDetailedTimers)
					frameTimer.begin(Timer.MODEL_PUSHING);

				int vertexOffset = dynamicOffsetVertices + sceneContext.getVertexOffset();
				int uvOffset = dynamicOffsetUvs + sceneContext.getUvOffset();

				modelPusher.pushModel(sceneContext, null, uuid, model, modelOverride, preOrientation, true);

				faceCount = sceneContext.modelPusherResults[0];
				if (sceneContext.modelPusherResults[1] == 0)
					uvOffset = -1;

				if (enableDetailedTimers)
					frameTimer.end(Timer.MODEL_PUSHING);

				eightIntWrite[0] = vertexOffset;
				eightIntWrite[1] = uvOffset;
				eightIntWrite[2] = faceCount;

				// add this temporary model to the map for batching purposes
				if (configModelBatching && modelOffsets == null)
					frameModelInfoMap.put(modelHasher.batchHash, new ModelOffsets(faceCount, vertexOffset, uvOffset));
			}

			if (eightIntWrite[0] != -1)
				drawnDynamicRenderableCount++;

			if (configCharacterDisplacement && renderable instanceof Actor) {
				if (enableDetailedTimers)
					frameTimer.begin(Timer.CHARACTER_DISPLACEMENT);
				if (renderable instanceof NPC) {
					var npc = (NPC) renderable;
					var entry = npcDisplacementCache.get(npc);
					if (entry.canDisplace) {
						int displacementRadius = entry.idleRadius;
						if (displacementRadius == -1) {
							displacementRadius = modelRadius; // Fallback to model radius since we don't know the idle radius yet
							if (npc.getIdlePoseAnimation() == npc.getPoseAnimation() && npc.getAnimation() == -1) {
								displacementRadius *= 2; // Double the idle radius, so that it fits most other animations
								entry.idleRadius = displacementRadius;
							}
						}
						uboCompute.addCharacterPosition(x, z, displacementRadius);
					}
				} else if (renderable instanceof Player && renderable != client.getLocalPlayer()) {
					uboCompute.addCharacterPosition(x, z, (int) (LOCAL_TILE_SIZE * 1.33f));
				}
				if (enableDetailedTimers)
					frameTimer.end(Timer.CHARACTER_DISPLACEMENT);
			}
		}

		if (enableDetailedTimers)
			frameTimer.end(Timer.DRAW_RENDERABLE);

		if (eightIntWrite[0] == -1)
			return; // Hidden model

		bufferForTriangles(faceCount)
			.ensureCapacity(8)
			.put(eightIntWrite);
		renderBufferOffset += faceCount * 3;
	}

	/**
	 * returns the correct buffer based on triangle count and updates model count
	 */
	private GpuIntBuffer bufferForTriangles(int triangles) {
		for (int i = 0; i < numSortingBins; i++) {
			if (modelSortingBinFaceCounts[i] >= triangles) {
				++numModelsToSort[i];
				return modelSortingBuffers[i];
			}
		}

		throw new IllegalStateException(
			"Ran into a model with more triangles than the plugin supports (" +
			triangles + " > " + MAX_FACE_COUNT + ")");
	}

	private float[] getDpiScaling() {
		final GraphicsConfiguration graphicsConfiguration = clientUI.getGraphicsConfiguration();
		if (graphicsConfiguration == null)
			return new float[] { 1, 1 };

		final AffineTransform t = graphicsConfiguration.getDefaultTransform();
		return new float[] { (float) t.getScaleX(), (float) t.getScaleY() };
	}

	public int getDrawDistance() {
		return clamp(config.drawDistance(), 0, MAX_DISTANCE);
	}

	public float getGammaCorrection() {
		return 100f / config.brightness();
	}

	private int getExpandedMapLoadingChunks() {
		if (useLowMemoryMode)
			return 0;
		return config.expandedMapLoadingChunks();
	}

	@Subscribe(priority = -1) // Run after the low detail plugin
	public void onBeforeRender(BeforeRender beforeRender) {
		SKIP_GL_ERROR_CHECKS = !log.isDebugEnabled() || developerTools.isFrameTimingsOverlayEnabled();

		// Upload the UI which we began copying during the previous frame
		if (configAsyncUICopy)
			asyncUICopy.complete();

		if (client.getScene() == null)
			return;
		// The game runs significantly slower with lower planes in Chambers of Xeric
		client.getScene().setMinLevel(isInChambersOfXeric ? client.getPlane() : client.getScene().getMinLevel());
	}

	@Subscribe
	public void onClientTick(ClientTick clientTick) {
		elapsedClientTime += 1 / 50f;

		if (!enableFreezeFrame && skipScene != client.getScene())
			redrawPreviousFrame = false;
	}

	@Subscribe
	public void onGameTick(GameTick gameTick) {
		if (!isActive)
			return;

		if (gameTicksUntilSceneReload > 0) {
			if (gameTicksUntilSceneReload == 1)
				reuploadScene();
			--gameTicksUntilSceneReload;
		}

		fishingSpotReplacer.update();
	}

	public void waitUntilIdle() {
		if (computeMode == ComputeMode.OPENCL)
			clManager.finish();
		glFinish();
	}

	private void glToggle(int target, boolean enable) {
		if (enable) {
			glEnable(target);
		} else {
			glDisable(target);
		}
	}

	@SuppressWarnings("StatementWithEmptyBody")
	public static void clearGLErrors() {
		// @formatter:off
		while (glGetError() != GL_NO_ERROR);
		// @formatter:on
	}

	public static void checkGLErrors() {
		if (SKIP_GL_ERROR_CHECKS)
			return;

		while (true) {
			int err = glGetError();
			if (err == GL_NO_ERROR)
				return;

			String errStr;
			switch (err) {
				case GL_INVALID_ENUM:
					errStr = "INVALID_ENUM";
					break;
				case GL_INVALID_VALUE:
					errStr = "INVALID_VALUE";
					break;
				case GL_STACK_OVERFLOW:
					errStr = "STACK_OVERFLOW";
					break;
				case GL_STACK_UNDERFLOW:
					errStr = "STACK_UNDERFLOW";
					break;
				case GL_INVALID_OPERATION:
					errStr = "INVALID_OPERATION";
					break;
				case GL_INVALID_FRAMEBUFFER_OPERATION:
					errStr = "INVALID_FRAMEBUFFER_OPERATION";
					break;
				default:
					errStr = String.format("Error code: %d", err);
					break;
			}

			log.debug("glGetError:", new Exception(errStr));
		}
	}

	private void displayUpdateMessage() {
		int messageId = 1;
		if (config.getPluginUpdateMessage() >= messageId)
			return; // Don't show the same message multiple times

//		PopupUtils.displayPopupMessage(client, "117HD Update",
//			"<br><br>" +
//			"If you experience any issues, please report them in the <a href=\"" + DISCORD_URL +"\">117HD Discord</a>.",
//			new String[] { "Remind me later", "Got it!" },
//			i -> {
//				if (i == 1) {
//					config.setPluginUpdateMessage(messageId);
//				}
//			}
//		);
	}

	private void displayUnsupportedGpuMessage(boolean isGenericGpu, String glRenderer) {
		String hint32Bit = "";
		if (HDUtils.is32Bit()) {
			hint32Bit =
				"&nbsp;• Install the 64-bit version of RuneLite from " +
				"<a href=\"" + HdPlugin.RUNELITE_URL + "\">the official website</a>. You are currently using 32-bit.<br>";
		}

		String driverLinks =
			"<br>" +
			"Links to drivers for each graphics card vendor:<br>" +
			"&nbsp;• <a href=\"" + HdPlugin.AMD_DRIVER_URL + "\">AMD drivers</a><br>" +
			"&nbsp;• <a href=\"" + HdPlugin.INTEL_DRIVER_URL + "\">Intel drivers</a><br>" +
			"&nbsp;• <a href=\"" + HdPlugin.NVIDIA_DRIVER_URL + "\">Nvidia drivers</a><br>";

		String errorMessage =
			(
				isGenericGpu ? (
					"Your graphics driver appears to be broken.<br>"
					+ "<br>"
					+ "Some things to try:<br>"
					+ "&nbsp;• Reinstall the drivers for <b>both</b> your processor's integrated graphics <b>and</b> your graphics card.<br>"
				) :
					(
						"Your GPU is currently not supported by 117 HD.<br><br>GPU name: " + glRenderer + "<br>"
						+ "<br>"
						+ "Your computer might not be letting RuneLite access your most powerful GPU.<br>"
						+ "To find out if your system is supported, try the following steps:<br>"
						+ "&nbsp;• Reinstall the drivers for your graphics card. You can find a link below.<br>"
					)
			)
			+ hint32Bit
			+ "&nbsp;• Tell your machine to use your high performance GPU for RuneLite.<br>"
			+ "&nbsp;• If you are on a desktop PC, make sure your monitor is plugged into your graphics card instead of<br>"
			+ "&nbsp;&nbsp;&nbsp;&nbsp;your motherboard. The graphics card's display outputs are usually lower down behind the computer.<br>"
			+ driverLinks
			+ "<br>"
			+ "If the issue persists even after <b>all of the above</b>, please join our "
			+ "<a href=\"" + HdPlugin.DISCORD_URL + "\">Discord server</a>, and click the <br>"
			+ "\"Open logs folder\" button below, find the file named \"client\" or \"client.log\", then drag and drop<br>"
			+ "that file into one of our support channels.";

		PopupUtils.displayPopupMessage(client, "117 HD Error", errorMessage,
			new String[] { "Open logs folder", "Ok, let me try that..." },
			i -> {
				if (i == 0) {
					LinkBrowser.open(RuneLite.LOGS_DIR.toString());
					return false;
				}
				return true;
			}
		);
	}

	private void displayOutOfMemoryMessage() {
		String errorMessage;
		if (HDUtils.is32Bit()) {
			String lowMemoryModeHint = useLowMemoryMode ? "" : (
				"If you are unable to install 64-bit RuneLite, you can instead turn on <b>Low Memory Mode</b> in the<br>" +
				"Miscellaneous section of 117 HD settings.<br>"
			);
			errorMessage =
				"The plugin ran out of memory because you are using the 32-bit version of RuneLite.<br>"
				+ "We would recommend installing the 64-bit version from "
				+ "<a href=\"" + HdPlugin.RUNELITE_URL + "\">RuneLite's website</a> if possible.<br>"
				+ "<br>"
				+ lowMemoryModeHint
				+ "<br>"
				+ "If you need further assistance, please join our "
				+ "<a href=\"" + HdPlugin.DISCORD_URL + "\">Discord</a> server, and click the \"Open logs folder\"<br>"
				+ "button below, find the file named \"client\" or \"client.log\", then drag and drop that file into one of<br>"
				+ "our support channels.";
		} else {
			errorMessage =
				"The plugin ran out of memory. "
				+ "Try " + (useLowMemoryMode ? "" : "reducing your model cache size from " + config.modelCacheSizeMiB() + " or ") + "closing other programs.<br>"
				+ "<br>"
				+ "If the issue persists, please join our "
				+ "<a href=\"" + HdPlugin.DISCORD_URL + "\">Discord</a> server, and click the \"Open logs folder\" button<br>"
				+ "below, find the file named \"client\" or \"client.log\", then drag and drop that file into one of our<br>"
				+ "support channels.";
		}

		PopupUtils.displayPopupMessage(client, "117 HD Error", errorMessage,
			new String[] { "Open logs folder", "Ok, let me try that..." },
			i -> {
				if (i == 0) {
					LinkBrowser.open(RuneLite.LOGS_DIR.toString());
					return false;
				}
				return true;
			}
		);
	}
}

package rs117.hd.model;

import javax.inject.Inject;
import javax.inject.Singleton;
import net.runelite.api.*;
import rs117.hd.HdPlugin;
import rs117.hd.scene.model_overrides.ModelOverride;
import rs117.hd.scene.model_overrides.UvType;

@Singleton
public class ModelHasher {
	@Inject
	private HdPlugin plugin;

	public long batchHash;
	public long vertexHash;
	public long normalHash;
	public long uvHash;

	private Model model;
	private int faceCount;
	private long faceColorsOneHash;
	private long faceColorsTwoHash;
	private long faceColorsThreeHash;
	private long faceTransparenciesHash;
	private long faceTexturesHash;
	private long xVerticesHash;
	private long yVerticesHash;
	private long zVerticesHash;
	private long faceIndicesOneHash;
	private long faceIndicesTwoHash;
	private long faceIndicesThreeHash;
	private long textureTrianglesHash;

	public void setModel(Model model, ModelOverride modelOverride, int preOrientation) {
		this.model = model;
		faceCount = model.getFaceCount();
		if (plugin.configUseFasterModelHashing) {
			faceColorsOneHash = fastHash(model.getFaceColors1());
			faceColorsTwoHash = 0;
			faceColorsThreeHash = 0;
			faceTransparenciesHash = fastByteHash(model.getFaceTransparencies());
			faceTexturesHash = fastShortHash(model.getFaceTextures());
			xVerticesHash = fastFloatHash(model.getVerticesX(), model.getVerticesCount());
			yVerticesHash = fastFloatHash(model.getVerticesY(), model.getVerticesCount());
			zVerticesHash = fastFloatHash(model.getVerticesZ(), model.getVerticesCount());
			faceIndicesOneHash = fastHash(model.getFaceIndices1());
			faceIndicesTwoHash = 0;
			faceIndicesThreeHash = 0;
			textureTrianglesHash = 0;
			final byte[] textureFaces = model.getTextureFaces();
			if (textureFaces != null) {
				boolean hasVanillaTexturedFaces = false;
				for (int textureId : textureFaces) {
					if (textureId != -1) {
						hasVanillaTexturedFaces = true;
						break;
					}
				}
				if (hasVanillaTexturedFaces) {
					final int[] texIndices1 = model.getTexIndices1();
					final int[] texIndices2 = model.getTexIndices2();
					final int[] texIndices3 = model.getTexIndices3();
					final float[] vertexX = model.getVerticesX();
					final float[] vertexY = model.getVerticesY();
					final float[] vertexZ = model.getVerticesZ();
					long h = 0;
					for (int i = 0; i < model.getFaceCount(); i++) {
						int texFace = textureFaces[i];
						if (texFace == -1)
							continue;
						texFace &= 0xff;
						final int texA = texIndices1[texFace];
						final int texB = texIndices2[texFace];
						final int texC = texIndices3[texFace];
						h = h * 31L + Float.floatToIntBits(vertexX[texA]);
						h = h * 31L + Float.floatToIntBits(vertexY[texA]);
						h = h * 31L + Float.floatToIntBits(vertexZ[texA]);
						h = h * 31L + Float.floatToIntBits(vertexX[texB]);
						h = h * 31L + Float.floatToIntBits(vertexY[texB]);
						h = h * 31L + Float.floatToIntBits(vertexZ[texB]);
						h = h * 31L + Float.floatToIntBits(vertexX[texC]);
						h = h * 31L + Float.floatToIntBits(vertexY[texC]);
						h = h * 31L + Float.floatToIntBits(vertexZ[texC]);
					}
					textureTrianglesHash = h;
				}
			}
		} else {
			faceColorsOneHash = fastHash(model.getFaceColors1());
			faceColorsTwoHash = fastHash(model.getFaceColors2());
			faceColorsThreeHash = fastHash(model.getFaceColors3());
			faceTransparenciesHash = fastByteHash(model.getFaceTransparencies());
			faceTexturesHash = fastShortHash(model.getFaceTextures());
			xVerticesHash = fastFloatHash(model.getVerticesX(), model.getVerticesCount());
			yVerticesHash = fastFloatHash(model.getVerticesY(), model.getVerticesCount());
			zVerticesHash = fastFloatHash(model.getVerticesZ(), model.getVerticesCount());
			faceIndicesOneHash = fastHash(model.getFaceIndices1());
			faceIndicesTwoHash = fastHash(model.getFaceIndices2());
			faceIndicesThreeHash = fastHash(model.getFaceIndices3());
			textureTrianglesHash = 0;
			final byte[] textureFaces = model.getTextureFaces();
			if (textureFaces != null) {
				boolean hasVanillaTexturedFaces = false;
				for (int textureId : textureFaces) {
					if (textureId != -1) {
						hasVanillaTexturedFaces = true;
						break;
					}
				}
				if (hasVanillaTexturedFaces) {
					final int[] texIndices1 = model.getTexIndices1();
					final int[] texIndices2 = model.getTexIndices2();
					final int[] texIndices3 = model.getTexIndices3();
					final float[] vertexX = model.getVerticesX();
					final float[] vertexY = model.getVerticesY();
					final float[] vertexZ = model.getVerticesZ();
					long h = 0;
					for (int i = 0; i < model.getFaceCount(); i++) {
						int texFace = textureFaces[i];
						if (texFace == -1)
							continue;
						texFace &= 0xff;
						final int texA = texIndices1[texFace];
						final int texB = texIndices2[texFace];
						final int texC = texIndices3[texFace];
						h = h * 31L + Float.floatToIntBits(vertexX[texA]);
						h = h * 31L + Float.floatToIntBits(vertexY[texA]);
						h = h * 31L + Float.floatToIntBits(vertexZ[texA]);
						h = h * 31L + Float.floatToIntBits(vertexX[texB]);
						h = h * 31L + Float.floatToIntBits(vertexY[texB]);
						h = h * 31L + Float.floatToIntBits(vertexZ[texB]);
						h = h * 31L + Float.floatToIntBits(vertexX[texC]);
						h = h * 31L + Float.floatToIntBits(vertexY[texC]);
						h = h * 31L + Float.floatToIntBits(vertexZ[texC]);
					}
					textureTrianglesHash = h;
				}
			}
		}

		vertexHash = calculateVertexCacheHash(modelOverride);
		normalHash = calculateNormalCacheHash();
		uvHash = calculateUvCacheHash(preOrientation, modelOverride);
		batchHash = vertexHash;
		batchHash = batchHash * 31 + normalHash;
		batchHash = batchHash * 31 + uvHash;
	}

	private long calculateVertexCacheHash(ModelOverride modelOverride) {
		long h = faceCount;
		h = h * 31L + faceColorsOneHash;
		h = h * 31L + faceColorsTwoHash;
		h = h * 31L + faceColorsThreeHash;
		h = h * 31L + faceTransparenciesHash;
		h = h * 31L + faceTexturesHash;
		h = h * 31L + xVerticesHash;
		h = h * 31L + yVerticesHash;
		h = h * 31L + zVerticesHash;
		h = h * 31L + faceIndicesOneHash;
		h = h * 31L + faceIndicesTwoHash;
		h = h * 31L + faceIndicesThreeHash;
		h = h * 31L + textureTrianglesHash;
		h = h * 31L + model.getOverrideAmount();
		h = h * 31L + model.getOverrideHue();
		h = h * 31L + model.getOverrideSaturation();
		h = h * 31L + model.getOverrideLuminance();
		h = h * 31L + modelOverride.hashCode();
		return h;
	}

	private long calculateNormalCacheHash() {
		long h = faceCount;
		h = h * 31L + faceIndicesOneHash;
		h = h * 31L + faceIndicesTwoHash;
		h = h * 31L + faceIndicesThreeHash;
		h = h * 31L + fastHash(model.getVertexNormalsX());
		h = h * 31L + fastHash(model.getVertexNormalsY());
		h = h * 31L + fastHash(model.getVertexNormalsZ());
		return h;
	}

	private long calculateUvCacheHash(int orientation, ModelOverride modelOverride) {
		long h = faceCount;
		h = h * 31L + (modelOverride.uvType == UvType.VANILLA || modelOverride.retainVanillaUvs ? textureTrianglesHash : 0);
		h = h * 31L + (modelOverride.uvType.orientationDependent ? orientation : 0);
		h = h * 31L + (modelOverride.uvType == UvType.BOX ? vertexHash : 0);
		h = h * 31L + modelOverride.hashCode();
		h = h * 31L + faceTexturesHash;
		return h;
	}

	public static long fastHash(int[] a) {
		if (a == null)
			return 0;

		int i = 0;
		long r = 1;
		int length = a.length;

		for (; i + 5 < length; i += 6)
			r = 31L * 31L * 31L * 31L * 31L * 31L * r +
				31L * 31L * 31L * 31L * 31L * a[i] +
				31L * 31L * 31L * 31L * a[i + 1] +
				31L * 31L * 31L * a[i + 2] +
				31L * 31L * a[i + 3] +
				31L * a[i + 4] +
				a[i + 5];

		for (; i < length; i++)
			r = 31L * r + a[i];

		return r;
	}

	public static long fastHash(int[] a, int length) {
		if (a == null)
			return 0;

		int i = 0;
		long r = 1;

		for (; i + 5 < length; i += 6)
			r = 31L * 31L * 31L * 31L * 31L * 31L * r +
				31L * 31L * 31L * 31L * 31L * a[i] +
				31L * 31L * 31L * 31L * a[i + 1] +
				31L * 31L * 31L * a[i + 2] +
				31L * 31L * a[i + 3] +
				31L * a[i + 4] +
				a[i + 5];

		for (; i < length; i++)
			r = 31L * r + a[i];

		return r;
	}

	public static int fastByteHash(byte[] a) {
		if (a == null)
			return 0;

		int i = 0;
		int r = 1;

		for (; i + 5 < a.length; i += 6)
			r = 31 * 31 * 31 * 31 * 31 * 31 * r
				+ 31 * 31 * 31 * 31 * 31 * a[i]
				+ 31 * 31 * 31 * 31 * a[i + 1]
				+ 31 * 31 * 31 * a[i + 2]
				+ 31 * 31 * a[i + 3]
				+ 31 * a[i + 4]
				+ a[i + 5];

		for (; i < a.length; i++) {
			r = 31 * r + a[i];
		}

		return r;
	}

    public static int fastShortHash(short[] a) {
		if (a == null)
			return 0;

		int i = 0;
		int r = 1;

		for (; i + 5 < a.length; i += 6)
			r = 31 * 31 * 31 * 31 * 31 * 31 * r +
				31 * 31 * 31 * 31 * 31 * a[i] +
				31 * 31 * 31 * 31 * a[i + 1] +
				31 * 31 * 31 * a[i + 2] +
				31 * 31 * a[i + 3] +
				31 * a[i + 4] +
				a[i + 5];

		for (; i < a.length; i++)
			r = 31 * r + a[i];

		return r;
	}

	public static int fastFloatHash(float[] a, int length) {
		if (a == null)
			return 0;

		int i = 0;
		int r = 1;

		for (; i + 5 < length; i += 6)
			r = 31 * 31 * 31 * 31 * 31 * 31 * r +
				31 * 31 * 31 * 31 * 31 * (int) (a[i] * 100) +
				31 * 31 * 31 * 31 * (int) (a[i + 1] * 100) +
				31 * 31 * 31 * (int) (a[i + 2] * 100) +
				31 * 31 * (int) (a[i + 3] * 100) +
				31 * (int) (a[i + 4] * 100) +
				(int) (a[i + 5] * 100);

		for (; i < length; i++)
			r = 31 * r + (int) (a[i] * 100);

		return r;
	}
}

package rs117.hd.model;

import java.nio.FloatBuffer;
import java.nio.IntBuffer;
import java.util.Arrays;
import javax.annotation.Nonnull;
import javax.annotation.Nullable;
import javax.inject.Inject;
import javax.inject.Singleton;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.*;
import net.runelite.api.gameval.ItemID;
import net.runelite.api.kit.*;
import net.runelite.client.RuneLite;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.util.LinkBrowser;
import rs117.hd.HdPlugin;
import rs117.hd.HdPluginConfig;
import rs117.hd.overlays.FrameTimer;
import rs117.hd.overlays.Timer;
import rs117.hd.scene.MaterialManager;
import rs117.hd.scene.ProceduralGenerator;
import rs117.hd.scene.SceneContext;
import rs117.hd.scene.SceneUploader;
import rs117.hd.scene.TileOverrideManager;
import rs117.hd.scene.materials.Material;
import rs117.hd.scene.model_overrides.InheritTileColorType;
import rs117.hd.scene.model_overrides.ModelOverride;
import rs117.hd.scene.model_overrides.TzHaarRecolorType;
import rs117.hd.scene.model_overrides.UvType;
import rs117.hd.scene.model_overrides.WindDisplacement;
import rs117.hd.scene.water_types.WaterType;
import rs117.hd.utils.HDUtils;
import rs117.hd.utils.ModelHash;
import rs117.hd.utils.PopupUtils;

import static rs117.hd.HdPlugin.MAX_FACE_COUNT;
import static rs117.hd.scene.SceneContext.SCENE_OFFSET;
import static rs117.hd.scene.tile_overrides.TileOverride.OVERLAY_FLAG;
import static rs117.hd.utils.HDUtils.HIDDEN_HSL;
import static rs117.hd.utils.MathUtils.*;

@Singleton
@Slf4j
public class ModelPusher {
	@Inject
	private Client client;

	@Inject
	private ClientThread clientThread;

	@Inject
	private HdPlugin plugin;

	@Inject
	private HdPluginConfig config;

	@Inject
	private MaterialManager materialManager;

	@Inject
	private TileOverrideManager tileOverrideManager;

	@Inject
	private ModelHasher modelHasher;

	@Inject
	private FrameTimer frameTimer;

	public static final int DATUM_PER_FACE = 12;
	public static final int MAX_MATERIAL_INDEX = (1 << 12) - 1;

	private static final int[] ZEROED_INTS = new int[12];

	private ModelCache modelCache;

	public void startUp() {
		assert WindDisplacement.values().length - 1 <= 0x7;

		if (plugin.configModelCaching && !plugin.useLowMemoryMode) {
			final int size = config.modelCacheSizeMiB();
			try {
				modelCache = new ModelCache(size, () -> {
					shutDown();
					plugin.stopPlugin();
				});
			} catch (Throwable err) {
				log.error("Error while initializing model cache. Stopping the plugin...", err);

				if (err instanceof OutOfMemoryError) {
					PopupUtils.displayPopupMessage(client, "117 HD Error",
						"117 HD ran out of memory while trying to allocate the model cache.<br><br>" +
						(
							HDUtils.is32Bit() ?
								(
									"You are currently using 32-bit RuneLite, which heavily restricts<br>" +
									"the amount of memory RuneLite is allowed to use.<br>" +
									"Please install the 64-bit launcher from " +
									"<a href=\"" + HdPlugin.RUNELITE_URL + "\">RuneLite's website</a> and try again.<br>"
								) : (
								(
									size <= 512 ? "" :
										"Your cache size of " + size + " MiB is " + (
											size >= 4000 ?
												"very large. We would recommend reducing it.<br>" :
												"bigger than the default size. Try reducing it.<br>"
										)
								) +
								"Normally, a cache size above 512 MiB is unnecessary, and the game should<br>" +
								"run acceptably even at 128 MiB. If you have to reduce the size by a lot,<br>" +
								"you may be better off disabling model caching entirely.<br>"
							)
						)
						+ "<br>"
						+ "You can also try closing some other programs on your PC to free up memory.<br>"
						+ "<br>"
						+ "If you need further assistance, please join our "
						+ "<a href=\"" + HdPlugin.DISCORD_URL + "\">Discord</a> server, and click the <br>"
						+ "\"Open logs folder\" button below, find the file named \"client\" or \"client.log\",<br>"
						+ "then drag and drop that file into one of our support channels.",
						new String[] { "Open logs folder", "Ok, let me try that..." },
						i -> {
							if (i == 0) {
								LinkBrowser.open(RuneLite.LOGS_DIR.toString());
								return false;
							}
							return true;
						}
					);
				}

				// Allow the model pusher to be used until the plugin has cleanly shut down
				clientThread.invoke(plugin::stopPlugin);
			}
		}
	}

	public void shutDown() {
		if (modelCache != null) {
			modelCache.destroy();
			modelCache = null;
		}
	}

	public void clearModelCache() {
		if (modelCache != null) {
			modelCache.clear();
		}
	}

	/**
	 * Pushes model data to staging buffers in the provided {@link SceneContext}, and writes the pushed number of
	 * vertices and UVs to {@link SceneContext#modelPusherResults}.
	 *
	 * @param sceneContext   object for the scene to push model data for
	 * @param tile           that the model is associated with, if any
	 * @param uuid           of the model
	 * @param model          to push data from
	 * @param modelOverride  the active model override
	 * @param preOrientation which the vertices have already been rotated by
	 * @param needsCaching   whether the model should be cached for future reuse, if enabled
	 */
	public void pushModel(
		SceneContext sceneContext,
		@Nullable Tile tile,
		int uuid,
		Model model,
		ModelOverride modelOverride,
		int preOrientation,
		boolean needsCaching
	) {
		boolean useCache = needsCaching;
		if (modelCache == null)
			useCache = false;

		final int faceCount = min(model.getFaceCount(), MAX_FACE_COUNT);
		final int bufferSize = faceCount * DATUM_PER_FACE;
		int texturedFaceCount = 0;

		final short[] faceTextures = model.getFaceTextures();
		final byte[] textureFaces = model.getTextureFaces();
		boolean isVanillaTextured = faceTextures != null;
		boolean isVanillaUVMapped =
			isVanillaTextured && // Vanilla UV mapped models don't always have sensible UVs for untextured faces
			model.getTexIndices1() != null &&
			model.getTexIndices2() != null &&
			model.getTexIndices3() != null &&
			model.getTextureFaces() != null;

		Material baseMaterial = modelOverride.baseMaterial;
		Material textureMaterial = modelOverride.textureMaterial;
		boolean disableTextures = !plugin.configModelTextures && !modelOverride.forceMaterialChanges;
		if (disableTextures) {
			if (baseMaterial.modifiesVanillaTexture)
				baseMaterial = Material.NONE;
			if (textureMaterial.modifiesVanillaTexture)
				textureMaterial = Material.NONE;
		}

		boolean skipUVs =
			!isVanillaTextured &&
			baseMaterial.packMaterialData(modelOverride, UvType.GEOMETRY, false) == 0 &&
			modelOverride.colorOverrides == null;

		// ensure capacity upfront
		sceneContext.stagingBufferVertices.ensureCapacity(bufferSize);
		sceneContext.stagingBufferNormals.ensureCapacity(bufferSize);
		if (!skipUVs)
			sceneContext.stagingBufferUvs.ensureCapacity(bufferSize);

		boolean foundCachedVertexData = false;
		boolean foundCachedNormalData = false;
		boolean foundCachedUvData = skipUVs;

		if (useCache) {
			assert client.isClientThread() : "Model caching isn't thread-safe";

			IntBuffer vertexData = this.modelCache.getIntBuffer(modelHasher.vertexHash);
			foundCachedVertexData = vertexData != null && vertexData.remaining() == bufferSize;
			if (foundCachedVertexData) {
				sceneContext.stagingBufferVertices.put(vertexData);
				vertexData.rewind();
			}

			FloatBuffer normalData = this.modelCache.getFloatBuffer(modelHasher.normalHash);
			foundCachedNormalData = normalData != null && normalData.remaining() == bufferSize;
			if (foundCachedNormalData) {
				sceneContext.stagingBufferNormals.put(normalData);
				normalData.rewind();
			}

			if (!foundCachedUvData) {
				FloatBuffer uvData = this.modelCache.getFloatBuffer(modelHasher.uvHash);
				foundCachedUvData = uvData != null && uvData.remaining() == bufferSize;
				if (foundCachedUvData) {
					texturedFaceCount = faceCount;
					sceneContext.stagingBufferUvs.put(uvData);
					uvData.rewind();
				}
			}

			if (foundCachedVertexData && foundCachedNormalData && foundCachedUvData) {
				sceneContext.modelPusherResults[0] = faceCount;
				sceneContext.modelPusherResults[1] = texturedFaceCount;
				return;
			}
		}

		IntBuffer fullVertexData = null;
		FloatBuffer fullNormalData = null;
		FloatBuffer fullUvData = null;

		boolean cacheVertexData = false;
		boolean cacheNormalData = false;
		boolean cacheUvData = false;
		if (useCache) {
			cacheVertexData = !foundCachedVertexData;
			cacheNormalData = !foundCachedNormalData;
			cacheUvData = !foundCachedUvData;

			if (cacheVertexData) {
				fullVertexData = this.modelCache.reserveIntBuffer(modelHasher.vertexHash, bufferSize);
				if (fullVertexData == null) {
					log.error("failed to reserve vertex buffer");
					cacheVertexData = false;
				}
			}

			if (cacheNormalData) {
				fullNormalData = this.modelCache.reserveFloatBuffer(modelHasher.normalHash, bufferSize);
				if (fullNormalData == null) {
					log.error("failed to reserve normal buffer");
					cacheNormalData = false;
				}
			}

			if (cacheUvData) {
				fullUvData = this.modelCache.reserveFloatBuffer(modelHasher.uvHash, bufferSize);
				if (fullUvData == null) {
					log.error("failed to reserve uv buffer");
					cacheUvData = false;
				}
			}
		}

		if (!foundCachedVertexData) {
			if (plugin.enableDetailedTimers)
				frameTimer.begin(Timer.MODEL_PUSHING_VERTEX);

			modelOverride.applyRotation(model);
			for (int face = 0; face < faceCount; face++) {
				int[] data = getFaceVertices(sceneContext, tile, uuid, model, modelOverride, face);
				sceneContext.stagingBufferVertices.put(data);
				if (cacheVertexData)
					fullVertexData.put(data);
			}
			modelOverride.revertRotation(model);

			if (plugin.enableDetailedTimers)
				frameTimer.end(Timer.MODEL_PUSHING_VERTEX);
		}

		if (!foundCachedNormalData) {
			if (plugin.enableDetailedTimers)
				frameTimer.begin(Timer.MODEL_PUSHING_NORMAL);

			for (int face = 0; face < faceCount; face++) {
				getNormalDataForFace(sceneContext, model, modelOverride, face);
				sceneContext.stagingBufferNormals.put(sceneContext.modelFaceNormals);
				if (cacheNormalData)
					fullNormalData.put(sceneContext.modelFaceNormals);
			}

			if (plugin.enableDetailedTimers)
				frameTimer.end(Timer.MODEL_PUSHING_NORMAL);
		}

		if (!foundCachedUvData) {
			if (plugin.enableDetailedTimers)
				frameTimer.begin(Timer.MODEL_PUSHING_UV);

			int[] faceColors = model.getFaceColors1();
			byte[] faceTransparencies = model.getFaceTransparencies();
			for (int face = 0; face < faceCount; face++) {
				UvType uvType = UvType.GEOMETRY;
				Material material = baseMaterial;

				short textureId = isVanillaTextured ? faceTextures[face] : -1;
				if (textureId != -1) {
					uvType = UvType.VANILLA;
					material = textureMaterial;
					if (material == Material.NONE)
						material = materialManager.fromVanillaTexture(textureId);
				}

				ModelOverride faceOverride = modelOverride;
				if (!disableTextures) {
					if (modelOverride.materialOverrides != null) {
						var override = modelOverride.materialOverrides.get(material);
						if (override != null) {
							faceOverride = override;
							material = faceOverride.textureMaterial;
						}
					}

					// Color overrides are heavy. Only apply them if the UVs will be cached or don't need caching
					if (modelOverride.colorOverrides != null && (cacheUvData || !needsCaching)) {
						int ahsl = (faceTransparencies == null ? 0xFF : 0xFF - (faceTransparencies[face] & 0xFF)) << 16 | faceColors[face];
						for (var override : modelOverride.colorOverrides) {
							if (override.ahslCondition.test(ahsl)) {
								faceOverride = override;
								material = faceOverride.baseMaterial;
								break;
							}
						}
					}
				}

				if (material != Material.NONE) {
					uvType = faceOverride.uvType;
					if (uvType == UvType.VANILLA || (textureId != -1 && faceOverride.retainVanillaUvs))
						uvType = isVanillaUVMapped && textureFaces[face] != -1 ? UvType.VANILLA : UvType.GEOMETRY;
				}

				int materialData = material.packMaterialData(faceOverride, uvType, false);

				final float[] uvData = sceneContext.modelFaceNormals;
				if (materialData == 0) {
					Arrays.fill(uvData, 0);
				} else {
					faceOverride.fillUvsForFace(uvData, model, preOrientation, uvType, face);
					uvData[3] = uvData[7] = uvData[11] = Float.intBitsToFloat(materialData);
				}

				sceneContext.stagingBufferUvs.put(uvData);
				if (cacheUvData)
					fullUvData.put(uvData);

				++texturedFaceCount;
			}

			if (plugin.enableDetailedTimers)
				frameTimer.end(Timer.MODEL_PUSHING_UV);
		}

		if (cacheVertexData)
			fullVertexData.flip();
		if (cacheNormalData)
			fullNormalData.flip();
		if (cacheUvData)
			fullUvData.flip();

		sceneContext.modelPusherResults[0] = faceCount;
		sceneContext.modelPusherResults[1] = texturedFaceCount;
	}

	private void getNormalDataForFace(SceneContext sceneContext, Model model, @Nonnull ModelOverride modelOverride, int face) {
		assert SceneUploader.packTerrainData(false, 0, WaterType.NONE, 0) == 0;
		if (modelOverride.flatNormals || !plugin.configPreserveVanillaNormals && model.getFaceColors3()[face] == -1) {
			Arrays.fill(sceneContext.modelFaceNormals, 0);
			return;
		}

		final int[] xVertexNormals = model.getVertexNormalsX();
		final int[] yVertexNormals = model.getVertexNormalsY();
		final int[] zVertexNormals = model.getVertexNormalsZ();

		if (xVertexNormals == null || yVertexNormals == null || zVertexNormals == null) {
			Arrays.fill(sceneContext.modelFaceNormals, 0);
			return;
		}

		final int triA = model.getFaceIndices1()[face];
		final int triB = model.getFaceIndices2()[face];
		final int triC = model.getFaceIndices3()[face];

		float terrainData = 0;
		sceneContext.modelFaceNormals[0] = xVertexNormals[triA];
		sceneContext.modelFaceNormals[1] = yVertexNormals[triA];
		sceneContext.modelFaceNormals[2] = zVertexNormals[triA];
		sceneContext.modelFaceNormals[3] = terrainData;
		sceneContext.modelFaceNormals[4] = xVertexNormals[triB];
		sceneContext.modelFaceNormals[5] = yVertexNormals[triB];
		sceneContext.modelFaceNormals[6] = zVertexNormals[triB];
		sceneContext.modelFaceNormals[7] = terrainData;
		sceneContext.modelFaceNormals[8] = xVertexNormals[triC];
		sceneContext.modelFaceNormals[9] = yVertexNormals[triC];
		sceneContext.modelFaceNormals[10] = zVertexNormals[triC];
		sceneContext.modelFaceNormals[11] = terrainData;
	}

	private boolean isBakedGroundShading(Model model, int face) {
		final byte[] faceTransparencies = model.getFaceTransparencies();
		if (faceTransparencies == null || (faceTransparencies[face] & 0xFF) <= 100)
			return false;

		final short[] faceTextures = model.getFaceTextures();
		if (faceTextures != null && faceTextures[face] != -1)
			return false;

		final float[] yVertices = model.getVerticesY();
		float heightA = yVertices[model.getFaceIndices1()[face]];
		if (heightA < -8)
			return false;

		float heightB = yVertices[model.getFaceIndices2()[face]];
		float heightC = yVertices[model.getFaceIndices3()[face]];
		return heightA == heightB && heightA == heightC;
	}

	@SuppressWarnings({ "ReassignedVariable" })
	private int[] getFaceVertices(
		SceneContext sceneContext,
		Tile tile,
		int uuid,
		Model model,
		@Nonnull ModelOverride modelOverride,
		int face
	) {
		if (model.getFaceColors3()[face] == -2)
			return ZEROED_INTS; // Hide the face

		// Hide fake shadows or lighting that is often baked into models by making the fake shadow transparent
		if (plugin.configHideFakeShadows && isBakedGroundShading(model, face)) {
			if (modelOverride.hideVanillaShadows)
				return ZEROED_INTS; // Hide the face

			if (ModelHash.getUuidType(uuid) == ModelHash.TYPE_PLAYER) {
				int index = ModelHash.getUuidId(uuid);
				var players = client.getTopLevelWorldView().players();
				if (index >= 0 && index < 2048) {
					Player player = players.byIndex(index);
					if (player != null && player.getPlayerComposition().getEquipmentId(KitType.WEAPON) == ItemID.MAGIC_CARPET)
						return ZEROED_INTS; // Hide the face
				}
			}
		}

		int color1 = model.getFaceColors1()[face];
		int color2 = model.getFaceColors2()[face];
		int color3 = model.getFaceColors3()[face];
		final int triA = model.getFaceIndices1()[face];
		final int triB = model.getFaceIndices2()[face];
		final int triC = model.getFaceIndices3()[face];
		final float[] xVertices = model.getVerticesX();
		final float[] yVertices = model.getVerticesY();
		final float[] zVertices = model.getVerticesZ();
		final short[] faceTextures = model.getFaceTextures();
		final byte[] faceTransparencies = model.getFaceTransparencies();
		final byte[] facePriorities = model.getFaceRenderPriorities();
		boolean isTextured = faceTextures != null && faceTextures[face] != -1;

		if (color3 == -1)
			color2 = color3 = color1;

		int packedAlphaPriorityFlags = 0;
		if (faceTransparencies != null && !isTextured)
			packedAlphaPriorityFlags |= (faceTransparencies[face] & 0xFF) << 24;
		if (facePriorities != null)
			packedAlphaPriorityFlags |= (facePriorities[face] & 0xF) << 16;

		if (isTextured) {
			// Without overriding the color for textured faces, vanilla shading remains pretty noticeable even after
			// the approximate reversal above. Ardougne rooftops is a good example, where vanilla shading results in a
			// weird-looking tint. The brightness clamp afterward is required to reduce the over-exposure introduced.
			color1 = color2 = color3 = 90;

			// Let the shader know vanilla shading reversal should be skipped for this face
			packedAlphaPriorityFlags |= 1 << 20;
		} else {
			final int overrideAmount = model.getOverrideAmount() & 0xFF;
			if (overrideAmount > 0) {
				// HSL override is not applied to flat shade faces or to textured faces
				final byte overrideHue = model.getOverrideHue();
				final byte overrideSat = model.getOverrideSaturation();
				final byte overrideLum = model.getOverrideLuminance();

				if (overrideHue != -1) {
					color1 += overrideAmount * (overrideHue - (color1 >> 10 & 0x3F)) >> 7 << 10;
					color2 += overrideAmount * (overrideHue - (color2 >> 10 & 0x3F)) >> 7 << 10;
					color3 += overrideAmount * (overrideHue - (color3 >> 10 & 0x3F)) >> 7 << 10;
				}

				if (overrideSat != -1) {
					color1 += overrideAmount * (overrideSat - (color1 >> 7 & 7)) >> 7 << 7;
					color2 += overrideAmount * (overrideSat - (color2 >> 7 & 7)) >> 7 << 7;
					color3 += overrideAmount * (overrideSat - (color3 >> 7 & 7)) >> 7 << 7;
				}

				if (overrideLum != -1) {
					color1 += overrideAmount * (overrideLum - (color1 & 0x7F)) >> 7;
					color2 += overrideAmount * (overrideLum - (color2 & 0x7F)) >> 7;
					color3 += overrideAmount * (overrideLum - (color3 & 0x7F)) >> 7;
				}
			}

			if (tile != null) {
				if (modelOverride.inheritTileColorType != InheritTileColorType.NONE) {
					final Scene scene = sceneContext.scene;
					SceneTileModel tileModel = tile.getSceneTileModel();
					SceneTilePaint tilePaint = tile.getSceneTilePaint();

					if (tilePaint != null || tileModel != null) {
						// No point in inheriting tilepaint color if the ground tile does not have a color, for example above a cave wall
						if (
							tilePaint != null &&
							tilePaint.getTexture() == -1 &&
							tilePaint.getRBG() != 0 &&
							tilePaint.getNeColor() != HIDDEN_HSL
						) {

							// Since tile colors are guaranteed to have the same hue and saturation per face,
							// we can blend without converting from HSL to RGB
							int averageColor =
								(
									tilePaint.getSwColor() +
									tilePaint.getNwColor() +
									tilePaint.getNeColor() +
									tilePaint.getSeColor()
								) / 4;

							var override = tileOverrideManager.getOverride(sceneContext, tile);
							averageColor = override.modifyColor(averageColor);
							color1 = color2 = color3 = averageColor;

							// Let the shader know vanilla shading reversal should be skipped for this face
							packedAlphaPriorityFlags |= 1 << 20;
						} else if (tileModel != null && tileModel.getTriangleTextureId() == null) {
							int faceColorIndex = -1;
							for (int i = 0; i < tileModel.getTriangleColorA().length; i++) {
								boolean isOverlay = ProceduralGenerator.isOverlayFace(tile, i);
								// Use underlay if the tile does not have an overlay, useful for rocks in cave corners.
								if (modelOverride.inheritTileColorType == InheritTileColorType.UNDERLAY
									|| tileModel.getModelOverlay() == 0) {
									// pulling the color from UNDERLAY is more desirable for green grass tiles
									// OVERLAY pulls in path color which is not desirable for grass next to paths
									if (!isOverlay) {
										faceColorIndex = i;
										break;
									}
								} else if (modelOverride.inheritTileColorType == InheritTileColorType.OVERLAY) {
									if (isOverlay) {
										// OVERLAY used in dirt/path/house tile color blend better with rubbles/rocks
										faceColorIndex = i;
										break;
									}
								}
							}

							if (faceColorIndex != -1) {
								int color = tileModel.getTriangleColorA()[faceColorIndex];
								if (color != HIDDEN_HSL) {
									var scenePos = tile.getSceneLocation();
									int tileX = scenePos.getX();
									int tileY = scenePos.getY();
									int tileZ = tile.getRenderLevel();
									int tileExX = tileX + SCENE_OFFSET;
									int tileExY = tileY + SCENE_OFFSET;
									int[] worldPos = sceneContext.sceneToWorld(tileX, tileY, tileZ);
									int tileId = modelOverride.inheritTileColorType == InheritTileColorType.OVERLAY ?
										OVERLAY_FLAG | scene.getOverlayIds()[tileZ][tileExX][tileExY] :
										scene.getUnderlayIds()[tileZ][tileExX][tileExY];
									var override = tileOverrideManager.getOverride(sceneContext, tile, worldPos, tileId);
									color = override.modifyColor(color);
									color1 = color2 = color3 = color;

									// Let the shader know vanilla shading reversal should be skipped for this face
									packedAlphaPriorityFlags |= 1 << 20;
								}
							}
						}
					}
				}

				if (plugin.configTzhaarHD && modelOverride.tzHaarRecolorType != TzHaarRecolorType.NONE) {
					int[] tzHaarRecolored = ProceduralGenerator.recolorTzHaar(
						uuid,
						modelOverride,
						model,
						face,
						packedAlphaPriorityFlags,
						color1,
						color2,
						color3
					);
					color1 = tzHaarRecolored[0];
					color2 = tzHaarRecolored[1];
					color3 = tzHaarRecolored[2];
					packedAlphaPriorityFlags = tzHaarRecolored[3];
				}
			}
		}

		color1 |= packedAlphaPriorityFlags;
		color2 |= packedAlphaPriorityFlags;
		color3 |= packedAlphaPriorityFlags;

		int[] data = sceneContext.modelFaceVertices;
		data[0] = Float.floatToIntBits(xVertices[triA]);
		data[1] = Float.floatToIntBits(yVertices[triA]);
		data[2] = Float.floatToIntBits(zVertices[triA]);
		data[3] = color1;
		data[4] = Float.floatToIntBits(xVertices[triB]);
		data[5] = Float.floatToIntBits(yVertices[triB]);
		data[6] = Float.floatToIntBits(zVertices[triB]);
		data[7] = color2;
		data[8] = Float.floatToIntBits(xVertices[triC]);
		data[9] = Float.floatToIntBits(yVertices[triC]);
		data[10] = Float.floatToIntBits(zVertices[triC]);
		data[11] = color3;
		return data;
	}
}

package rs117.hd.model;

import lombok.RequiredArgsConstructor;

@RequiredArgsConstructor
public class ModelOffsets {
	public final int faceCount;
	public final int vertexOffset;
	public final int uvOffset;
}

package rs117.hd.model;

import java.nio.FloatBuffer;
import java.nio.IntBuffer;
import java.util.ArrayDeque;
import java.util.HashMap;
import lombok.extern.slf4j.Slf4j;
import org.lwjgl.system.MemoryUtil;

import static rs117.hd.utils.MathUtils.*;

@Slf4j
public class ModelCache {
	private static class Allocation {
		long address;
		long byteCapacity;

		long cursor;
		long freeBytesAhead;

		Allocation(long byteCapacity) {
			assert byteCapacity > 0;
			address = MemoryUtil.nmemAllocChecked(byteCapacity);
			this.byteCapacity = byteCapacity;
			cursor = 0;
			freeBytesAhead = byteCapacity;
		}

		void destroy() {
			if (address == 0L)
				return;

			MemoryUtil.nmemFree(address);
			address = 0;
			byteCapacity = 0;
			cursor = 0;
			freeBytesAhead = 0;
		}

		@Override
		@SuppressWarnings("deprecation")
		protected void finalize() {
			destroy();
		}

		long reserve(long numBytes) {
			assert numBytes > 0;
			assert numBytes <= freeBytesAhead;
			assert numBytes <= byteCapacity - cursor;
			long address = this.address + cursor;
			cursor += numBytes;
			freeBytesAhead -= numBytes;
			return address;
		}

		long bytesFromEnd() {
			return byteCapacity - cursor;
		}
	}

	private static class Buffer {
		final boolean endMarker;
		final long hash;
		final long byteCapacity;
		final IntBuffer intBuffer;
		final FloatBuffer floatBuffer;

		public Buffer(long byteCapacity) {
			endMarker = true;
			this.hash = 0;
			this.byteCapacity = byteCapacity;
			intBuffer = null;
			floatBuffer = null;
		}

		public Buffer(long hash, IntBuffer buffer) {
			endMarker = false;
			this.hash = hash;
			byteCapacity = buffer.capacity() * 4L;
			intBuffer = buffer;
			floatBuffer = null;
		}

		public Buffer(long hash, FloatBuffer buffer) {
			endMarker = false;
			this.hash = hash;
			byteCapacity = buffer.capacity() * 4L;
			intBuffer = null;
			floatBuffer = buffer;
		}
	}

	private final Runnable terminationHook;
	private final HashMap<Long, Buffer> cache = new HashMap<>();
	private final ArrayDeque<Buffer> buffers = new ArrayDeque<>();
	private final Allocation[] allocations;
	private Allocation currentAllocation;
	private int currentAllocationIndex;

	public ModelCache(int modelCacheSizeMiB, Runnable terminationHook) {
		this.terminationHook = terminationHook;

		// Limit cache size to 128 MiB for 32-bit
		if (modelCacheSizeMiB > 128 && !"64".equals(System.getProperty("sun.arch.data.model"))) {
			log.warn("Defaulting model cache to 128 MiB due to non 64-bit client");
			modelCacheSizeMiB = 128;
		}

		try {
			int totalPhysicalMemoryMiB = (int) (((com.sun.management.OperatingSystemMXBean)
				java.lang.management.ManagementFactory.getOperatingSystemMXBean()).getTotalPhysicalMemorySize() / MiB);

			// Try to limit the cache size to half of the total physical memory
			if (modelCacheSizeMiB > totalPhysicalMemoryMiB / 2) {
				log.warn(
					"Limiting cache size to {} since the selected amount ({}) exceeds half of the total system memory ({} / 2)",
					totalPhysicalMemoryMiB / 2, modelCacheSizeMiB, totalPhysicalMemoryMiB);
				modelCacheSizeMiB = totalPhysicalMemoryMiB / 2;
			}
		} catch (Throwable e) {
			log.warn("Unable to check physical memory size: " + e);
		}

		long byteCapacity = modelCacheSizeMiB * MiB;

		log.debug("Allocating {} MiB model cache", modelCacheSizeMiB);

		Allocation[] allocations = new Allocation[1];
		try {
			// Try allocating the whole size as a single chunk
			allocations[0] = new Allocation(byteCapacity);
		} catch (Throwable err) {
			log.warn("Unable to allocate {} MiB as a single chunk", modelCacheSizeMiB, err);

			try {
				// Try allocating in chunks of up to 1 GiB each
				int numChunks = (int) ((byteCapacity + GiB - 1) / GiB);
				allocations = new Allocation[numChunks];
				for (int i = 0; i < numChunks; i++) {
					allocations[i] = new Allocation(min(byteCapacity - i * GiB, GiB));
				}
			} catch (Throwable err2) {
				destroy();
				log.error("Unable to allocate {} MiB in chunks of up to 1 GiB each", modelCacheSizeMiB, err2);
				throw err2;
			}
		}

		this.allocations = allocations;
		currentAllocation = allocations[0];
	}

	public void destroy() {
		cache.clear();
		buffers.clear();
		currentAllocation = null;

		if (allocations != null) {
			for (int i = 0; i < allocations.length; i++) {
				if (allocations[i] != null) {
					allocations[i].destroy();
					allocations[i] = null;
				}
			}
		}
	}

	@Override
	@SuppressWarnings("deprecation")
	protected void finalize() throws Throwable {
		try {
			// Clean up allocations in case the plugin somehow fails to call destroy
			destroy();
		} finally {
			super.finalize();
		}
	}

	public void clear() {
		cache.clear();
		buffers.clear();
		for (Allocation allocation : allocations) {
			if (allocation != null) {
				allocation.cursor = 0;
				allocation.freeBytesAhead = allocation.byteCapacity;
			}
		}
	}

	private Buffer get(long hash) {
		return cache.get(hash);
	}

	private void nextAllocation() {
		currentAllocation.cursor = 0;
		currentAllocation.freeBytesAhead = 0;

		currentAllocationIndex++;
		currentAllocationIndex %= allocations.length;
		currentAllocation = allocations[currentAllocationIndex];
	}

	private long reserve(long numBytes) {
		assert currentAllocation != null : "model cache used after destruction";

		if (currentAllocation.bytesFromEnd() < numBytes) {
			// ### = taken, ... = free, MMM = end marker
			//                    _________ -> not enough space
			// [##################....###MM]
			// inserting a new end marker as follows will cause issues
			// [##################MMMM###MM]
			// since ### and MM will be freed next, an option is to move these to the end of the buffer list
			// another minor optimization we can make is to pretend that the buffers are shifted to the left like so
			// [##################|MMMM###MM]
			// [##################|###MMMMMM]
			// this leaves us with only a single dummy buffer at the end, and a guarantee that buffers will still be
			// freed in an appropriate order with no collisions

			// Move the existing regions to the end of the buffer list
			while (currentAllocation.bytesFromEnd() != currentAllocation.freeBytesAhead) {
				assert currentAllocation.bytesFromEnd() > currentAllocation.freeBytesAhead;
				Buffer buffer = buffers.pollFirst();
				if (buffer == null) {
					log.error("No more cache entries left to free, yet the allocation is still in use ({} != {})",
						currentAllocation.bytesFromEnd(), currentAllocation.freeBytesAhead);
					terminationHook.run();
					return 0;
				}

				if (buffer.endMarker) {
					// Shift unused space to the end of the buffer, as detailed above
					currentAllocation.freeBytesAhead += buffer.byteCapacity;
					assert currentAllocation.cursor + currentAllocation.freeBytesAhead <= currentAllocation.byteCapacity;
				} else {
					// Move the buffer to the end of the list, and pretend we've shifted it to the left as detailed above
					buffers.addLast(buffer);
					currentAllocation.cursor += buffer.byteCapacity;
				}
			}

			// Consume the remaining free bytes of the allocation
			buffers.addLast(new Buffer(currentAllocation.freeBytesAhead));
			// Advance to the next allocation, or the beginning of the same allocation if there is only one
			nextAllocation();

			if (currentAllocation.bytesFromEnd() < numBytes) {
				log.error("Failed to reserve space for {} bytes. Too large to fit in allocation {} of size {}",
					numBytes, currentAllocationIndex, currentAllocation.byteCapacity);
				terminationHook.run();
				return 0;
			}
		}

		while (currentAllocation.freeBytesAhead < numBytes) {
			if (removeOldestCacheEntry() == null) {
				log.error("No more cache entries left to free, yet there aren't enough free bytes ({} < {})",
					currentAllocation.freeBytesAhead, numBytes);
				terminationHook.run();
				return 0;
			}
		}

		return currentAllocation.reserve(numBytes);
	}

	private Buffer removeOldestCacheEntry() {
		Buffer buffer = buffers.pollFirst();

		if (buffer != null) {
			if (!buffer.endMarker) {
				cache.remove(buffer.hash, buffer);
				// Normally, these addresses will be equal, but in case they've been "shifted" as detailed in the
				// reserve function, the buffer's actual address will be larger than the cursor position
				assert currentAllocation.address + currentAllocation.cursor + currentAllocation.freeBytesAhead <=
					MemoryUtil.memAddress0(buffer.intBuffer == null ? buffer.floatBuffer : buffer.intBuffer);
			}

			currentAllocation.freeBytesAhead += buffer.byteCapacity;
			assert currentAllocation.cursor + currentAllocation.freeBytesAhead <= currentAllocation.byteCapacity;
		}

		return buffer;
	}

	public IntBuffer getIntBuffer(long hash) {
		Buffer buffer = get(hash);
		if (buffer == null)
			return null;
		return buffer.intBuffer;
	}

	public FloatBuffer getFloatBuffer(long hash) {
		Buffer buffer = get(hash);
		if (buffer == null)
			return null;
		return buffer.floatBuffer;
	}

	public IntBuffer reserveIntBuffer(long hash, int capacity) {
		long address = reserve(capacity * 4L);
		if (address == 0L)
			return null;
		Buffer buffer = new Buffer(hash, MemoryUtil.memIntBuffer(address, capacity));
		cache.put(hash, buffer);
		buffers.addLast(buffer);
		return buffer.intBuffer;
	}

	public FloatBuffer reserveFloatBuffer(long hash, int capacity) {
		long address = reserve(capacity * 4L);
		if (address == 0L)
			return null;
		Buffer buffer = new Buffer(hash, MemoryUtil.memFloatBuffer(address, capacity));
		cache.put(hash, buffer);
		buffers.addLast(buffer);
		return buffer.floatBuffer;
	}
}

package rs117.hd.config;

public enum ColorFilter {
	NONE,
	GREYSCALE,
	SEPIA,
	HIGH_CONTRAST,
	CARTOON,
	INVERT_COLORS,
	BLACK_AND_WHITE,
	CEL_SHADING
}

/*
 * Copyright (c) 2023, Hooder <ahooder@protonmail.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package rs117.hd.config;

public enum ShadowMode
{
	OFF,
	FAST,
	DETAILED
}

/*
 * Copyright (c) 2019 logarrhytmic <https://github.com/logarrhythmic>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package rs117.hd.config;

import lombok.Getter;
import lombok.RequiredArgsConstructor;

import static org.lwjgl.opengl.GL33C.*;

@Getter
@RequiredArgsConstructor
public enum SceneScalingMode {
	NEAREST("Nearest", GL_NEAREST),
	LINEAR("Bilinear", GL_LINEAR);

	private final String name;

	public final int glFilter;

	@Override
	public String toString() {
		return name;
	}
}

/*
 * Copyright (c) 2021, 117 <https://twitter.com/117scape>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package rs117.hd.config;

import lombok.Getter;
import lombok.RequiredArgsConstructor;

@Getter
@RequiredArgsConstructor
public enum ShadowDistance
{
	DISTANCE_20("20", 20),
	DISTANCE_30("30", 30),
	DISTANCE_40("40", 40),
	DISTANCE_50("50", 50),
	DISTANCE_60("60", 60),
	DISTANCE_70("70", 70),
	DISTANCE_80("80", 80),
	DISTANCE_90("90", 90);

	private final String name;
	private final int value;

	@Override
	public String toString()
	{
		return name;
	}
}

/*
 * Copyright (c) 2018, Lotto <https://github.com/devLotto>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package rs117.hd.config;

import lombok.Getter;
import lombok.RequiredArgsConstructor;

@Getter
@RequiredArgsConstructor
public enum AntiAliasingMode
{
	DISABLED("Disabled", 0),
	MSAA_2("MSAA x2", 2),
	MSAA_4("MSAA x4", 4),
	MSAA_8("MSAA x8", 8),
	MSAA_16("MSAA x16", 16);

	private final String name;
	private final int samples;

	@Override
	public String toString()
	{
		return name;
	}
}

/*
 * Copyright (c) 2020 Ben Poulson <https://github.com/benpoulson>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package rs117.hd.config;

public enum ColorBlindMode {
	NONE,
	PROTANOPE,
	DEUTERANOPE,
	TRITANOPE
}

/*
 * Copyright (c) 2023, Hooder <ahooder@protonmail.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package rs117.hd.config;

import lombok.Getter;
import lombok.RequiredArgsConstructor;

@Getter
@RequiredArgsConstructor
public enum ShadingMode {
	DEFAULT("117 HD"),
	VANILLA("Vanilla"),
	NONE("None"),
	;

	private final String name;

	@Override
	public String toString() {
		return name;
	}
}

package rs117.hd.config;

import lombok.RequiredArgsConstructor;

@RequiredArgsConstructor
public enum FishingSpotStyle {
	HD("Bubbles"),
	VANILLA("Droplets"),
	BOTH("Both");

	private final String name;

	@Override
	public String toString() {
		return name;
	}
}

/*
 * Copyright (c) 2021, 117 <https://twitter.com/117scape>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package rs117.hd.config;

import lombok.Getter;
import lombok.RequiredArgsConstructor;

import static rs117.hd.utils.MathUtils.*;

@Getter
@RequiredArgsConstructor
public enum DynamicLights
{
	NONE("Disabled", 0, 0),
	FEW("Few", 12, 25),
	SOME("Some", 24, 50),
	MANY("Many", 32, 100);

	public static final int MAX_LIGHTS_PER_TILE;

	static {
		int max = 0;
		for (var e : values()) {
			assert e.lightsPerTile % 4 == 0; // Needs to be divisible by 4
			max = max(max, e.lightsPerTile);
		}
		MAX_LIGHTS_PER_TILE = max;
	}

	private final String name;
	private final int lightsPerTile;
	private final int maxSceneLights;

	@Override
	public String toString()
	{
		return name;
	}
}

/*
 * Copyright (c) 2021, 117 <https://twitter.com/117scape>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package rs117.hd.config;

import lombok.Getter;
import lombok.RequiredArgsConstructor;

@Getter
@RequiredArgsConstructor
public enum Contrast
{
	HIGHER("Highest", 1.1f),
	HIGHEST("Higher", 1.05f),
	DEFAULT("Default", 1.0f),
	LOWER("Lower", 0.95f),
	LOWEST("Lowest", 0.9f);

	private final String name;
	private final float amount;

	@Override
	public String toString()
	{
		return name;
	}
}

package rs117.hd.config;

import lombok.Getter;
import lombok.RequiredArgsConstructor;

@Getter
@RequiredArgsConstructor
public enum SeasonalTheme {
	AUTOMATIC,
	SUMMER,
	AUTUMN,
	WINTER,
	;
}

/*
 * Copyright (c) 2024, Hooder <ahooder@protonmail.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package rs117.hd.config;

import lombok.Getter;
import lombok.RequiredArgsConstructor;

@Getter
@RequiredArgsConstructor
public enum VanillaShadowMode {
	SHOW("Show", true),
	SHOW_IN_PVM("Show in PvM", true),
	PREFER_IN_PVM("Prefer in PvM", true),
	HIDE("Hide", false),
	;

	private final String name;

	public final boolean retainInPvm;

	@Override
	public String toString() {
		return name;
	}
}

package rs117.hd.config;

import lombok.Getter;
import lombok.RequiredArgsConstructor;

@Getter
@RequiredArgsConstructor
public enum SeasonalHemisphere {
	NORTHERN,
	SOUTHERN
	;
}

/*
 * Copyright (c) 2022, Hooder <ahooder@protonmail.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package rs117.hd.config;

import lombok.Getter;
import lombok.RequiredArgsConstructor;

@Getter
@RequiredArgsConstructor
public enum TextureResolution
{
	RES_128("128", 128),
	RES_256("256", 256);

	private final String name;
	private final int size;

	@Override
	public String toString()
	{
		return name;
	}
}

/*
 * Copyright (c) 2021, 117 <https://twitter.com/117scape>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package rs117.hd.config;

import lombok.Getter;
import lombok.RequiredArgsConstructor;

@Getter
@RequiredArgsConstructor
public enum FogDepthMode
{
	NONE("None", 0),
	DYNAMIC("Dynamic", 1),
	USER_DEFINED("Static", 2);

	private final String name;
	private final int mode;

	@Override
	public String toString()
	{
		return name;
	}
}

/*
 * Copyright (c) 2021, 117 <https://twitter.com/117scape>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package rs117.hd.config;

import lombok.Getter;
import lombok.RequiredArgsConstructor;
import net.runelite.api.*;
import rs117.hd.utils.ColorUtils;

@Getter
@RequiredArgsConstructor
public enum DefaultSkyColor
{
	DEFAULT("117 HD Blue", 185, 214, 255),
	RUNELITE("RuneLite Skybox", -1, -1, -1),
	OSRS("Old School Black", 0, 0, 0),
	HD2008("2008 HD Tan", 200, 192, 169);

	private final String name;
	private final int r;
	private final int g;
	private final int b;

	@Override
	public String toString()
	{
		return name;
	}

	public float[] getRgb(Client client) {
		int r = this.r;
		int g = this.g;
		int b = this.b;
		if (this == RUNELITE)
		{
			int sky = client.getSkyboxColor();
			r = sky >> 16 & 0xFF;
			g = sky >> 8 & 0xFF;
			b = sky & 0xFF;
		}
		return new float[] {
			ColorUtils.srgbToLinear(r / 255f),
			ColorUtils.srgbToLinear(g / 255f),
			ColorUtils.srgbToLinear(b / 255f)
		};
	}
}

/*
 * Copyright (c) 2019 logarrhytmic <https://github.com/logarrhythmic>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package rs117.hd.config;

import lombok.Getter;
import lombok.RequiredArgsConstructor;

@Getter
@RequiredArgsConstructor
public enum UIScalingMode {
	NEAREST("Nearest", 0),
	LINEAR("Bilinear", 0),
	MITCHELL("Mitchell", 1),
	CATMULL_ROM("Catmull-Rom", 2),
	XBR("xBR", 3);

	private final String name;
	private final int mode;

	@Override
	public String toString()
	{
		return name;
	}
}

/*
 * Copyright (c) 2021, 117 <https://twitter.com/117scape>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package rs117.hd.config;

import lombok.Getter;
import lombok.RequiredArgsConstructor;

@Getter
@RequiredArgsConstructor
public enum ShadowResolution
{
	RES_1024("Low (1K)", 1024),
	RES_2048("Medium (2K)", 2048),
	RES_4096("High (4K)", 4096),
	RES_8192("Ultra (8K)", 8192),
	RES_16384("Extreme (16K)", 16384);

	private final String name;
	private final int value;

	@Override
	public String toString()
	{
		return name;
	}
}

/*
 * Copyright (c) 2021, 117 <https://twitter.com/117scape>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package rs117.hd.config;

import lombok.Getter;
import lombok.RequiredArgsConstructor;

@Getter
@RequiredArgsConstructor
public enum Saturation
{
	HIGHEST("Highest", 1.2f),
	HIGHER("Higher", 1.1f),
	DEFAULT("Default", 1.0f),
	LOWER("Lower", 0.9f),
	LOWEST("Lowest", 0.8f),
	NONE("None", 0.0f);

	private final String name;
	private final float amount;

	@Override
	public String toString()
	{
		return name;
	}
}

/*
 * Copyright (c) 2018, Adam <Adam@sigterm.info>
 * Copyright (c) 2021, 117 <https://twitter.com/117scape>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package rs117.hd;

import net.runelite.client.config.Config;
import net.runelite.client.config.ConfigGroup;
import net.runelite.client.config.ConfigItem;
import net.runelite.client.config.ConfigSection;
import net.runelite.client.config.Range;
import net.runelite.client.config.Units;
import rs117.hd.config.AntiAliasingMode;
import rs117.hd.config.ColorBlindMode;
import rs117.hd.config.ColorFilter;
import rs117.hd.config.Contrast;
import rs117.hd.config.DefaultSkyColor;
import rs117.hd.config.DynamicLights;
import rs117.hd.config.FishingSpotStyle;
import rs117.hd.config.FogDepthMode;
import rs117.hd.config.Saturation;
import rs117.hd.config.SceneScalingMode;
import rs117.hd.config.SeasonalHemisphere;
import rs117.hd.config.SeasonalTheme;
import rs117.hd.config.ShadingMode;
import rs117.hd.config.ShadowDistance;
import rs117.hd.config.ShadowMode;
import rs117.hd.config.ShadowResolution;
import rs117.hd.config.TextureResolution;
import rs117.hd.config.UIScalingMode;
import rs117.hd.config.VanillaShadowMode;

import static rs117.hd.HdPlugin.MAX_DISTANCE;
import static rs117.hd.HdPlugin.MAX_FOG_DEPTH;
import static rs117.hd.HdPluginConfig.*;
import static rs117.hd.utils.MathUtils.*;

@ConfigGroup(CONFIG_GROUP)
public interface HdPluginConfig extends Config
{
	String CONFIG_GROUP = "hd";

	/*====== General settings ======*/

	@ConfigSection(
		name = "General",
		description = "General settings",
		position = 0
	)
	String generalSettings = "generalSettings";

	@Range(
		max = MAX_DISTANCE
	)
	@ConfigItem(
		keyName = "drawDistance",
		name = "Draw Distance",
		description =
			"The number of tiles to draw in either direction from the camera, up to a maximum of 184.<br>" +
			"Depending on where the scene is centered, you might only see 16 tiles in one direction, unless you extend map loading.",
		position = 1,
		section = generalSettings
	)
	default int drawDistance() {
		return 50;
	}

	String KEY_EXPANDED_MAP_LOADING_CHUNKS = "expandedMapLoadingChunks";
	@Range(
		max = 5
	)
	@ConfigItem(
		keyName = KEY_EXPANDED_MAP_LOADING_CHUNKS,
		name = "Extended map loading",
		description =
			"How much further the map should be loaded. The maximum is 5 extra chunks.<br>" +
			"Note, extending the map can have a very high impact on performance.",
		position = 2,
		section = generalSettings
	)
	default int expandedMapLoadingChunks() {
		return 3;
	}

	String KEY_ANTI_ALIASING_MODE = "antiAliasingMode";
	@ConfigItem(
		keyName = KEY_ANTI_ALIASING_MODE,
		name = "Anti-Aliasing",
		description =
			"Improves pixelated edges at the cost of significantly higher GPU usage.<br>" +
			"MSAA x16 is very expensive, so x8 is recommended if anti-aliasing is desired.",
		position = 3,
		section = generalSettings
	)
	default AntiAliasingMode antiAliasingMode()
	{
		return AntiAliasingMode.DISABLED;
	}

	String KEY_SCENE_RESOLUTION_SCALE = "sceneResolutionScale";
	@ConfigItem(
		keyName = KEY_SCENE_RESOLUTION_SCALE,
		name = "Game Resolution",
		description =
			"Render the game at a different resolution and stretch it to fit the screen.<br>" +
			"Reducing this can improve performance, particularly on very high resolution displays.",
		position = 4,
		section = generalSettings
	)
	@Units(Units.PERCENT)
	@Range(min = 1, max = 200)
	default int sceneResolutionScale() {
		return 100;
	}

	@ConfigItem(
		keyName = "sceneScalingMode",
		name = "Game Scaling Mode",
		description = "The sampling function to use when upscaling the above reduced game resolution.",
		position = 5,
		section = generalSettings
	)
	default SceneScalingMode sceneScalingMode()
	{
		return SceneScalingMode.LINEAR;
	}

	String KEY_UI_SCALING_MODE = "uiScalingMode";
	@ConfigItem(
		keyName = KEY_UI_SCALING_MODE,
		name = "UI Scaling Mode",
		description =
			"The sampling function to use when the Stretched Mode plugin is enabled.<br>" +
			"Affects how the UI looks with non-integer scaling.",
		position = 6,
		section = generalSettings
	)
	default UIScalingMode uiScalingMode() {
		return UIScalingMode.LINEAR;
	}

	String KEY_ANISOTROPIC_FILTERING_LEVEL = "anisotropicFilteringLevel";
	@Range(
		min = 0,
		max = 16
	)
	@ConfigItem(
		keyName = KEY_ANISOTROPIC_FILTERING_LEVEL,
		name = "Anisotropic Filtering",
		description =
			"Configures whether mipmapping and anisotropic filtering should be used.<br>" +
			"At zero, mipmapping is disabled and textures look the most pixelated.<br>" +
			"At 1 through 16, mipmapping is enabled, and textures look more blurry and smoothed out.<br>" +
			"The higher you go beyond 1, the less blurry textures will look, up to a certain extent.",
		position = 7,
		section = generalSettings
	)
	default int anisotropicFilteringLevel()
	{
		return 16;
	}

	String KEY_UNLOCK_FPS = "unlockFps";
	@ConfigItem(
		keyName = KEY_UNLOCK_FPS,
		name = "Unlock FPS",
		description = "Removes the 50 FPS cap for some game content, such as camera movement and dynamic lighting.",
		position = 8,
		section = generalSettings
	)
	default boolean unlockFps()
	{
		return false;
	}

	enum SyncMode
	{
		OFF,
		ON,
		ADAPTIVE
	}

	String KEY_VSYNC_MODE = "vsyncMode";
	@ConfigItem(
		keyName = KEY_VSYNC_MODE,
		name = "VSync Mode",
		description =
			"Controls whether the frame rate should be synchronized with your monitor's refresh rate.<br>" +
			"If set to 'off', the FPS Target option will be used instead.<br>" +
			"If set to 'adaptive', FPS will be limited to your monitor's refresh rate, which saves power.<br>" +
			"If set to 'on', the game will attempt to match your monitor's refresh rate <b>exactly</b>,<br>" +
			"but if it can't keep up, FPS will be <u>halved until it catches up</u>. This option is rarely desired.<br>" +
			"Note, GPUs that don't support Adaptive VSync will silently fall back to 'on'.",
		position = 9,
		section = generalSettings
	)
	default SyncMode syncMode()
	{
		return SyncMode.ADAPTIVE;
	}

	String KEY_FPS_TARGET = "fpsTarget";
	@ConfigItem(
		keyName = KEY_FPS_TARGET,
		name = "FPS Target",
		description =
			"Controls the maximum number of frames per second.<br>" +
			"This setting only applies if Unlock FPS is enabled, and VSync Mode is set to 'off'.",
		position = 10,
		section = generalSettings
	)
	@Range(
		min = 0,
		max = 999
	)
	default int fpsTarget()
	{
		return 60;
	}

	String KEY_COLOR_BLINDNESS = "colorBlindMode";
	@ConfigItem(
		keyName = KEY_COLOR_BLINDNESS,
		name = "Color Blindness",
		description = "Adjust colors to make them more distinguishable for people with a certain type of color blindness.",
		position = 11,
		section = generalSettings
	)
	default ColorBlindMode colorBlindness()
	{
		return ColorBlindMode.NONE;
	}

	@ConfigItem(
		keyName = "colorBlindnessIntensity",
		name = "Blindness Intensity",
		description = "Specifies how intense the color blindness adjustment should be.",
		position = 12,
		section = generalSettings
	)
	@Units(Units.PERCENT)
	@Range(max = 100)
	default int colorBlindnessIntensity()
	{
		return 100;
	}

	@ConfigItem(
		keyName = "flashingEffects",
		name = "Flashing Effects",
		description = "Whether to show rapid flashing effects, such as lightning, in certain areas.",
		position = 13,
		section = generalSettings
	)
	default boolean flashingEffects()
	{
		return false;
	}

	@ConfigItem(
		keyName = "fSaturation",
		name = "Saturation",
		description = "Controls the saturation of the final rendered image.<br>" +
			"Intended to be kept between 0% and 120%.",
		position = 14,
		section = generalSettings
	)
	@Units(Units.PERCENT)
	@Range(min = -500, max = 500)
	default int saturation()
	{
		return round(oldSaturationDropdown().getAmount() * 100);
	}
	@ConfigItem(keyName = "saturation", hidden = true, name = "", description = "")
	default Saturation oldSaturationDropdown()
	{
		return Saturation.DEFAULT;
	}

	@ConfigItem(
		keyName = "fContrast",
		name = "Contrast",
		description = "Controls the contrast of the final rendered image.<br>" +
			"Intended to be kept between 90% and 110%.",
		position = 15,
		section = generalSettings
	)
	@Units(Units.PERCENT)
	@Range(min = -500, max = 500)
	default int contrast()
	{
		return round(oldContrastDropdown().getAmount() * 100);
	}
	@ConfigItem(keyName = "contrast", hidden = true, name = "", description = "")
	default Contrast oldContrastDropdown()
	{
		return Contrast.DEFAULT;
	}

	String KEY_BRIGHTNESS = "screenBrightness";
	@Range(
		min = 25,
		max = 400
	)
	@Units(Units.PERCENT)
	@ConfigItem(
		keyName = KEY_BRIGHTNESS,
		name = "Brightness",
		description =
			"Controls the brightness of the game, excluding UI.<br>" +
			"Adjust until the disk on the left is barely visible.",
		position = 16,
		section = generalSettings
	)
	default int brightness() {
		return 100;
	}

	@ConfigItem(
		keyName = "useLegacyBrightness",
		name = "Enable Legacy Brightness",
		description =
			"Whether the legacy brightness option below should be applied.<br>" +
			"We recommend leaving this disabled.",
		position = 17,
		section = generalSettings
	)
	default boolean useLegacyBrightness() {
		return false;
	}

	@Range(
		min = 1,
		max = 50
	)
	@ConfigItem(
		keyName = "brightness2",
		name = "Legacy Brightness",
		description =
			"Controls the strength of the sun and ambient lighting.<br>" +
			"A brightness value of 20 is recommended.",
		position = 18,
		section = generalSettings
	)
	default int legacyBrightness() {
		return 20;
	}


	/*====== Lighting settings ======*/

	@ConfigSection(
		name = "Lighting",
		description = "Lighting settings",
		position = 1
	)
	String lightingSettings = "lightingSettings";

	String KEY_DYNAMIC_LIGHTS = "dynamicLights";
	@ConfigItem(
		keyName = KEY_DYNAMIC_LIGHTS,
		name = "Dynamic Lights",
		description =
			"The maximum number of dynamic lights visible at once.<br>" +
			"Reducing this may improve performance.",
		position = 0,
		section = lightingSettings
	)
	default DynamicLights dynamicLights()
	{
		return DynamicLights.SOME;
	}

	String KEY_TILED_LIGHTING = "tiledLighting";
	@ConfigItem(
		keyName = KEY_TILED_LIGHTING,
		name = "Tiled Lighting",
		description = "Allows rendering <b>a lot</b> more lights simultaneously.",
		section = lightingSettings,
		position = 1
	)
	default boolean tiledLighting() {
		return true;
	}

	String KEY_PROJECTILE_LIGHTS = "projectileLights";
	@ConfigItem(
		keyName = KEY_PROJECTILE_LIGHTS,
		name = "Projectile Lights",
		description = "Adds dynamic lights to some projectiles.",
		position = 2,
		section = lightingSettings
	)
	default boolean projectileLights() {
		return true;
	}

	String KEY_NPC_LIGHTS = "npcLights";
	@ConfigItem(
		keyName = KEY_NPC_LIGHTS,
		name = "NPC Lights",
		description = "Adds dynamic lights to some NPCs.",
		position = 3,
		section = lightingSettings
	)
	default boolean npcLights() {
		return true;
	}

	String KEY_ATMOSPHERIC_LIGHTING = "environmentalLighting";
	@ConfigItem(
		keyName = KEY_ATMOSPHERIC_LIGHTING,
		name = "Atmospheric Lighting",
		description = "Change environmental lighting based on the current area.",
		position = 4,
		section = lightingSettings
	)
	default boolean atmosphericLighting() {
		return true;
	}

	String KEY_SHADOW_MODE = "shadowMode";
	@ConfigItem(
		keyName = KEY_SHADOW_MODE,
		name = "Shadows",
		description =
			"Render fully dynamic shadows.<br>" +
			"'Off' completely disables shadows.<br>" +
			"'Fast' enables fast shadows without any texture detail.<br>" +
			"'Detailed' enables slower shadows with support for texture detail.",
		position = 5,
		section = lightingSettings
	)
	default ShadowMode shadowMode()
	{
		return ShadowMode.DETAILED;
	}

	String KEY_SHADOW_TRANSPARENCY = "enableShadowTransparency";
	@ConfigItem(
		keyName = KEY_SHADOW_TRANSPARENCY,
		name = "Shadow Transparency",
		description = "Enables partial support for shadows that take transparency into account.",
		position = 6,
		section = lightingSettings
	)
	default boolean enableShadowTransparency()
	{
		return true;
	}

	String KEY_PIXELATED_SHADOWS = "pixelatedShadows";
	@ConfigItem(
		keyName = KEY_PIXELATED_SHADOWS,
		name = "Pixelated Shadows",
		description = "Give shadows a slightly pixelated look.",
		position = 7,
		section = lightingSettings
	)
	default boolean pixelatedShadows() {
		return false;
	}

	String KEY_SHADOW_RESOLUTION = "shadowResolution";
	@ConfigItem(
		keyName = KEY_SHADOW_RESOLUTION,
		name = "Shadow Quality",
		description =
			"The resolution of the shadow map.<br>" +
			"Higher resolutions result in higher quality shadows, at the cost of higher GPU usage.",
		position = 8,
		section = lightingSettings
	)
	default ShadowResolution shadowResolution()
	{
		return ShadowResolution.RES_4096;
	}

	@ConfigItem(
		keyName = "shadowDistance",
		name = "Shadow Distance",
		description =
			"The maximum draw distance for shadows.<br>" +
			"Shorter distances result in higher quality shadows.",
		position = 9,
		section = lightingSettings
	)
	default ShadowDistance shadowDistance()
	{
		return ShadowDistance.DISTANCE_50;
	}

	String KEY_EXPAND_SHADOW_DRAW = "expandShadowDraw";
	@ConfigItem(
		keyName = KEY_EXPAND_SHADOW_DRAW,
		name = "Expand Shadow Draw",
		description =
			"Reduces shadows popping in and out at the edge of the screen by rendering<br>" +
			"shadows for a larger portion of the scene, at the cost of higher GPU usage.",
		position = 10,
		section = lightingSettings
	)
	default boolean expandShadowDraw()
	{
		return false;
	}

	String KEY_VANILLA_SHADOW_MODE = "vanillaShadowMode";
	@ConfigItem(
		keyName = KEY_VANILLA_SHADOW_MODE,
		name = "Vanilla Shadows",
		description =
			"Choose whether shadows built into models by Jagex should be hidden. This does not affect clickboxes.<br>" +
			"'Show in PvM' will retain shadows for falling crystals during the Olm fight and other useful cases.<br>" +
			"'Prefer in PvM' will do the above and also disable 117 HD's dynamic shadows in such cases.",
		position = 11,
		section = lightingSettings
	)
	default VanillaShadowMode vanillaShadowMode() {
		return VanillaShadowMode.SHOW_IN_PVM;
	}

	String KEY_NORMAL_MAPPING = "normalMapping";
	@ConfigItem(
		keyName = KEY_NORMAL_MAPPING,
		name = "Normal Mapping",
		description = "Affects how light interacts with certain materials. Barely impacts performance.",
		position = 12,
		section = lightingSettings
	)
	default boolean normalMapping() {
		return true;
	}

	String KEY_PARALLAX_OCCLUSION_MAPPING = "parallaxOcclusionMappingToggle";
	@ConfigItem(
		keyName = KEY_PARALLAX_OCCLUSION_MAPPING,
		name = "Parallax Occlusion Mapping",
		description = "Adds more depth to some materials, at the cost of higher GPU usage.",
		position = 13,
		section = lightingSettings
	)
	default boolean parallaxOcclusionMapping() {
		return true;
	}


	/*====== Environment settings ======*/

	@ConfigSection(
		name = "Environment",
		description = "Environment settings",
		position = 2
	)
	String environmentSettings = "environmentSettings";

	String KEY_SEASONAL_THEME = "seasonalTheme";
	@ConfigItem(
		keyName = KEY_SEASONAL_THEME,
		name = "Seasonal Theme",
		description = "Festive themes for Gielinor.",
		position = 0,
		section = environmentSettings
	)
	default SeasonalTheme seasonalTheme() {
		return SeasonalTheme.AUTOMATIC;
	}

	String KEY_SEASONAL_HEMISPHERE = "seasonalHemisphere";
	@ConfigItem(
		keyName = KEY_SEASONAL_HEMISPHERE,
		name = "Seasonal Hemisphere",
		description = "Determines which hemisphere the 'Automatic' Seasonal Theme should consider.",
		position = 1,
		section = environmentSettings
	)
	default SeasonalHemisphere seasonalHemisphere() {
		return SeasonalHemisphere.NORTHERN;
	}

	@ConfigItem(
		keyName = "fogDepthMode",
		name = "Fog Depth Mode",
		description =
			"Determines how the fog amount is controlled.<br>" +
			"'Dynamic' changes fog depth based on the area, while<br>" +
			"'Static' respects the manually defined fog depth.",
		position = 2,
		section = environmentSettings
	)
	default FogDepthMode fogDepthMode()
	{
		return FogDepthMode.DYNAMIC;
	}

	@Range(
		max = MAX_FOG_DEPTH
	)
	@ConfigItem(
		keyName = "fogDepth",
		name = "Static Fog Depth",
		description =
			"Specify how far from the edge fog should reach.<br>" +
			"This applies only when 'Fog Depth Mode' is set to 'Static'.",
		position = 3,
		section = environmentSettings
	)
	default int fogDepth()
	{
		return 5;
	}

	@ConfigItem(
		keyName = "groundFog",
		name = "Ground Fog",
		description = "Enables a height-based fog effect that covers the ground in certain areas.",
		position = 4,
		section = environmentSettings
	)
	default boolean groundFog() {
		return true;
	}

	@ConfigItem(
		keyName = "defaultSkyColor",
		name = "Default Sky",
		description =
			"Specify a sky color to use when the current area doesn't have a sky color defined.<br>" +
			"This only applies when the default summer seasonal theme is active.<br>" +
			"If set to 'RuneLite Skybox', the sky color from RuneLite's Skybox plugin will be used.<br>" +
			"If set to 'Old School Black', the sky will be black and water will remain blue, but for any<br>" +
			"other option, the water color will be influenced by the sky color.",
		position = 5,
		section = environmentSettings
	)
	default DefaultSkyColor defaultSkyColor()
	{
		return DefaultSkyColor.DEFAULT;
	}

	@ConfigItem(
		keyName = "overrideSky",
		name = "Override Sky Color",
		description = "Forces the default sky color to be used in all environments.",
		position = 6,
		section = environmentSettings
	)
	default boolean overrideSky() {
		return false;
	}

	String KEY_MODEL_TEXTURES = "objectTextures";
	@ConfigItem(
		keyName = KEY_MODEL_TEXTURES,
		name = "Model Textures",
		description =
			"Adds new textures to most models. If disabled, the standard game textures will be used instead.<br>" +
			"Note, this requires model caching in order to apply to animated models.",
		position = 7,
		section = environmentSettings
	)
	default boolean modelTextures() {
		return true;
	}

	String KEY_GROUND_TEXTURES = "groundTextures";
	@ConfigItem(
		keyName = KEY_GROUND_TEXTURES,
		name = "Ground Textures",
		description = "Adds new textures to most ground tiles.",
		position = 8,
		section = environmentSettings
	)
	default boolean groundTextures()
	{
		return true;
	}

	String KEY_TEXTURE_RESOLUTION = "textureResolution";
	@ConfigItem(
		keyName = KEY_TEXTURE_RESOLUTION,
		name = "Texture Resolution",
		description = "Controls the resolution used for all in-game textures.",
		position = 9,
		section = environmentSettings
	)
	default TextureResolution textureResolution()
	{
		return TextureResolution.RES_256;
	}

	String KEY_GROUND_BLENDING = "groundBlending";
	@ConfigItem(
		keyName = KEY_GROUND_BLENDING,
		name = "Ground Blending",
		description = "Controls whether ground tiles should blend into each other, or have distinct edges.",
		position = 10,
		section = environmentSettings
	)
	default boolean groundBlending()
	{
		return true;
	}

	@ConfigItem(
		keyName = "underwaterCaustics",
		name = "Underwater Caustics",
		description = "Apply underwater lighting effects to imitate sunlight passing through waves on the surface.",
		position = 11,
		section = environmentSettings
	)
	default boolean underwaterCaustics()
	{
		return true;
	}

	String KEY_HD_TZHAAR_RESKIN = "tzhaarHD";
	@ConfigItem(
		keyName = KEY_HD_TZHAAR_RESKIN,
		name = "HD TzHaar Reskin",
		description = "Recolors the TzHaar city of Mor Ul Rek to give it an appearance similar to that of its 2008 HD variant.",
		position = 12,
		section = environmentSettings
	)
	default boolean hdTzHaarReskin() {
		return true;
	}

	String KEY_WIND_DISPLACEMENT = "windDisplacement";
	@ConfigItem(
		keyName = KEY_WIND_DISPLACEMENT,
		name = "Wind Displacement",
		description = "Controls whether things like grass and leaves should be affected by wind.",
		position = 13,
		section = environmentSettings
	)
	default boolean windDisplacement() {
		return true;
	}

	String KEY_CHARACTER_DISPLACEMENT = "characterDisplacement";
	@ConfigItem(
		keyName = KEY_CHARACTER_DISPLACEMENT,
		name = "Character Displacement",
		description = "Let players & NPCs affect things like grass whilst walking around.",
		position = 14,
		section = environmentSettings
	)
	default boolean characterDisplacement() {
		return true;
	}

	/*====== Model caching settings ======*/

	@ConfigSection(
		name = "Model caching",
		description = "Improve performance by reusing model data",
		position = 3,
		closedByDefault = true
	)
	String modelCachingSettings = "modelCachingSettings";

	String KEY_MODEL_BATCHING = "useModelBatching";
	@ConfigItem(
		keyName = KEY_MODEL_BATCHING,
		name = "Model Batching",
		description =
			"Model batching improves performance by reusing identical models within the same frame.<br>" +
			"May cause instability and graphical bugs, particularly if Jagex makes engine changes.",
		position = 1,
		section = modelCachingSettings
	)
	default boolean modelBatching() {return true;}

	String KEY_MODEL_CACHING = "useModelCaching";
	@ConfigItem(
		keyName = KEY_MODEL_CACHING,
		name = "Model Caching",
		description =
			"Model caching improves performance by saving and reusing model data from previous frames.<br>" +
			"May cause instability or graphical bugs, particularly if Jagex makes engine changes.",
		position = 2,
		section = modelCachingSettings
	)
	default boolean modelCaching() {return true;}

	String KEY_MODEL_CACHE_SIZE = "modelCacheSizeMiBv2";
	@Range(
		min = 64,
		max = 16384
	)
	@ConfigItem(
		keyName = KEY_MODEL_CACHE_SIZE,
		name = "Cache Size (MiB)",
		description =
			"Size of the model cache in mebibytes (slightly more than megabytes).<br>" +
			"Generally, 512 MiB is plenty, with diminishing returns the higher you go.<br>" +
			"Minimum=64 MiB, maximum=16384 MiB",
		position = 3,
		section = modelCachingSettings
	)
	default int modelCacheSizeMiB() {
		return modelCacheSizeMiBv1() / 4;
	}
	@ConfigItem(keyName = "modelCacheSizeMiB", hidden = true, name = "", description = "")
	default int modelCacheSizeMiBv1()
	{
		return 2048;
	}


	/*====== Miscellaneous settings ======*/

	@ConfigSection(
		name = "Miscellaneous",
		description = "Miscellaneous settings",
		position = 4,
		closedByDefault = true
	)
	String miscellaneousSettings = "miscellaneousSettings";

	String KEY_MACOS_INTEL_WORKAROUND = "macosIntelWorkaround";
	@ConfigItem(
		keyName = KEY_MACOS_INTEL_WORKAROUND,
		name = "Fix white color issue on Macs",
		description = "Workaround for visual artifacts found on some Intel GPU drivers on macOS.",
		warning =
			"This setting can cause RuneLite to crash, and it can be difficult to undo.\n" +
			"Only enable it if you are seeing broken colors. Are you sure you want to enable this setting?",
		section = miscellaneousSettings
	)
	default boolean macosIntelWorkaround()
	{
		return false;
	}

	String KEY_HD_INFERNAL_CAPE = "hdInfernalTexture";
	@ConfigItem(
		keyName = KEY_HD_INFERNAL_CAPE,
		name = "HD Infernal Cape",
		description =
			"Replace the infernal cape texture with a more detailed version.<br>" +
			"Note, with Anisotropic Filtering above zero, the cape may look blurry when zoomed out.",
		section = miscellaneousSettings
	)
	default boolean hdInfernalTexture() {
		return true;
	}

	String KEY_LEGACY_GREY_COLORS = "reduceOverExposure";
	@ConfigItem(
		keyName = KEY_LEGACY_GREY_COLORS,
		name = "Legacy Grey Colors",
		description =
			"Previously, HD attempted to reduce over-exposure by capping the maximum color brightness,<br>" +
			"which changed white colors into dull shades of grey. This option brings back that old behaviour.",
		section = miscellaneousSettings
	)
	default boolean legacyGreyColors() {
		return false;
	}

	String KEY_VANILLA_COLOR_BANDING = "vanillaColorBanding";
	@ConfigItem(
		keyName = KEY_VANILLA_COLOR_BANDING,
		name = "Vanilla Color Banding",
		description =
			"Blend between colors similarly to how it works in vanilla, with clearly defined bands of color.<br>" +
			"This isn't really noticeable on textured surfaces, and is intended to be used without ground textures.",
		section = miscellaneousSettings
	)
	default boolean vanillaColorBanding() {
		return false;
	}

	String KEY_LOW_MEMORY_MODE = "lowMemoryMode";
	@ConfigItem(
		keyName = KEY_LOW_MEMORY_MODE,
		name = "Low Memory Mode",
		description = "Turns off features which require extra memory, such as model caching, faster scene loading & extended scene loading.",
		warning =
			"<html>This <b>will not</b> result in better performance. It is recommended only if you are unable to install<br>" +
			"the 64-bit version of RuneLite, or if your computer has a very low amount of memory available.</html>",
		section = miscellaneousSettings
	)
	default boolean lowMemoryMode() {
		return false;
	}

	String KEY_FISHING_SPOT_STYLE = "fishingSpotStyle";
	@ConfigItem(
		keyName = KEY_FISHING_SPOT_STYLE,
		name = "Fishing spot style",
		description = "Choose the appearance of most fishing spots. Bubbles are the easiest to see on top of 117 HD's water style.",
		section = miscellaneousSettings
	)
	default FishingSpotStyle fishingSpotStyle() {
		return FishingSpotStyle.HD;
	}

	String KEY_COLOR_FILTER = "colorFilter";
	@ConfigItem(
		keyName = KEY_COLOR_FILTER,
		name = "Color Filter",
		description = "Apply a color filter to the game as a post-processing effect.",
		section = miscellaneousSettings
	)
	default ColorFilter colorFilter() {
		return ColorFilter.NONE;
	}

	String KEY_REMOVE_VERTEX_SNAPPING = "removeVertexSnapping";
	@ConfigItem(
		keyName = KEY_REMOVE_VERTEX_SNAPPING,
		name = "Remove vertex snapping",
		description =
			"Removes vertex snapping from most animations.<br>" +
			"Most animations are barely affected by this, and it only has an effect if the animation smoothing plugin is turned off.<br>" +
			"To see quite clearly what impact this option has, a good example is the godsword idle animation.",
		section = miscellaneousSettings
	)
	default boolean removeVertexSnapping() {
		return true;
	}

	String KEY_FILL_GAPS_IN_TERRAIN = "fillGapsInTerrain";
	@ConfigItem(
		keyName = KEY_FILL_GAPS_IN_TERRAIN,
		name = "Fill gaps in terrain",
		description = "Attempt to patch all holes in the ground, such as around trapdoors and ladders.",
		section = miscellaneousSettings
	)
	default boolean fillGapsInTerrain() {
		return true;
	}

	String KEY_FLAT_SHADING = "flatShading";
	@ConfigItem(
		keyName = KEY_FLAT_SHADING,
		name = "Flat shading",
		description = "Gives a more low-poly look to the game.",
		section = miscellaneousSettings
	)
	default boolean flatShading() {
		return false;
	}


	/*====== Experimental settings ======*/

	@ConfigSection(
		name = "Experimental",
		description = "Experimental features - if you're experiencing issues you should consider disabling these",
		position = 5,
		closedByDefault = true
	)
	String experimentalSettings = "experimentalSettings";

	String KEY_FASTER_MODEL_HASHING = "experimentalFasterModelHashing";
	@ConfigItem(
		keyName = KEY_FASTER_MODEL_HASHING,
		name = "Use faster model hashing",
		description = "Should increase performance at the expense of potential graphical issues.",
		section = experimentalSettings
	)
	default boolean fasterModelHashing() {
		return true;
	}

	String KEY_PRESERVE_VANILLA_NORMALS = "experimentalPreserveVanillaNormals";
	@ConfigItem(
		keyName = KEY_PRESERVE_VANILLA_NORMALS,
		name = "Preserve vanilla normals",
		description = "Originally, 117 HD would respect vanilla normals, but these are often less accurate.",
		section = experimentalSettings
	)
	default boolean preserveVanillaNormals() {
		return false;
	}

	String KEY_SHADING_MODE = "experimentalShadingMode";
	@ConfigItem(
		keyName = KEY_SHADING_MODE,
		name = "Shading mode",
		description =
			"If you prefer playing without shadows, maybe you'll prefer vanilla shading or no shading as well.<br>" +
			"Keep in mind, with vanilla shading used alongside shadows, you can end up with double shading.",
		section = experimentalSettings
	)
	default ShadingMode shadingMode() {
		return ShadingMode.DEFAULT;
	}

	String KEY_DECOUPLE_WATER_FROM_SKY_COLOR = "experimentalDecoupleWaterFromSkyColor";
	@ConfigItem(
		keyName = KEY_DECOUPLE_WATER_FROM_SKY_COLOR,
		name = "Decouple water from sky color",
		description = "Some people prefer the water staying blue even with a different sky color active.",
		section = experimentalSettings
	)
	default boolean decoupleSkyAndWaterColor() {
		return false;
	}

	String KEY_HIDE_UNRELATED_AREAS = "hideUnrelatedAreas";
	@ConfigItem(
		keyName = KEY_HIDE_UNRELATED_AREAS,
		name = "Hide unrelated areas",
		description = "Hide unrelated areas which you shouldn't see from your current position.",
		section = experimentalSettings
	)
	default boolean hideUnrelatedAreas() {
		return true;
	}

	String KEY_WIREFRAME = "wireframe";
	@ConfigItem(
		keyName = KEY_WIREFRAME,
		name = "Wireframe",
		description = "Show the edges of individual triangles in the scene.",
		section = experimentalSettings
	)
	default boolean wireframe() {
		return false;
	}

	String KEY_ASYNC_UI_COPY = "experimentalAsyncUICopy";
	@ConfigItem(
		keyName = KEY_ASYNC_UI_COPY,
		name = "Perform UI copy asynchronously",
		description = "Slightly improves performance by delaying the UI by one frame.",
		section = experimentalSettings
	)
	default boolean asyncUICopy() {
		return false;
	}

	/*====== Internal settings ======*/

	@ConfigItem(keyName = "pluginUpdateMessage", hidden = true, name = "", description = "")
	void setPluginUpdateMessage(int version);
	@ConfigItem(keyName = "pluginUpdateMessage", hidden = true, name = "", description = "")
	default int getPluginUpdateMessage() {
		return 0;
	}
}

package rs117.hd.opengl.uniforms;

import rs117.hd.HdPlugin;
import rs117.hd.scene.water_types.WaterType;
import rs117.hd.utils.buffer.GLBuffer;

import static org.lwjgl.opengl.GL33C.*;

public class UBOWaterTypes extends UniformBuffer<GLBuffer> {
	public static class WaterTypeStruct extends StructProperty {
		public final Property isFlat = addProperty(PropertyType.Int, "isFlat");
		public final Property specularStrength = addProperty(PropertyType.Float, "specularStrength");
		public final Property specularGloss = addProperty(PropertyType.Float, "specularGloss");
		public final Property normalStrength = addProperty(PropertyType.Float, "normalStrength");
		public final Property baseOpacity = addProperty(PropertyType.Float, "baseOpacity");
		public final Property hasFoam = addProperty(PropertyType.Int, "hasFoam");
		public final Property duration = addProperty(PropertyType.Float, "duration");
		public final Property fresnelAmount = addProperty(PropertyType.Float, "fresnelAmount");
		public final Property surfaceColor = addProperty(PropertyType.FVec3, "surfaceColor");
		public final Property foamColor = addProperty(PropertyType.FVec3, "foamColor");
		public final Property depthColor = addProperty(PropertyType.FVec3, "depthColor");
		public final Property normalMap = addProperty(PropertyType.Int, "normalMap");
	}

	private final WaterTypeStruct[] uboStructs;
	private final WaterType[] waterTypes;

	public UBOWaterTypes(WaterType[] waterTypes) {
		super(GL_STATIC_DRAW);
		this.waterTypes = waterTypes;
		uboStructs = addStructs(new WaterTypeStruct[waterTypes.length], WaterTypeStruct::new);
		initialize(HdPlugin.UNIFORM_BLOCK_WATER_TYPES);
		update();
	}

	public int getCount() {
		return uboStructs.length;
	}

	public void update() {
		for (int i = 0; i < waterTypes.length; i++)
			waterTypes[i].fillStruct(uboStructs[i]);
		upload();
	}
}

package rs117.hd.opengl.uniforms;

import rs117.hd.utils.buffer.GLBuffer;

import static org.lwjgl.opengl.GL33C.*;

public class UBOGlobal extends UniformBuffer<GLBuffer> {
	public UBOGlobal() {
		super(GL_DYNAMIC_DRAW);
	}

	public Property expandedMapLoadingChunks = addProperty(PropertyType.Int, "expandedMapLoadingChunks");
	public Property drawDistance = addProperty(PropertyType.Float, "drawDistance");

	public Property colorBlindnessIntensity = addProperty(PropertyType.Float, "colorBlindnessIntensity");
	public Property gammaCorrection = addProperty(PropertyType.Float, "gammaCorrection");
	public Property saturation = addProperty(PropertyType.Float, "saturation");
	public Property contrast = addProperty(PropertyType.Float, "contrast");
	public Property colorFilterPrevious = addProperty(PropertyType.Int, "colorFilterPrevious");
	public Property colorFilter = addProperty(PropertyType.Int, "colorFilter");
	public Property colorFilterFade = addProperty(PropertyType.Float, "colorFilterFade");

	public Property sceneResolution = addProperty(PropertyType.IVec2, "sceneResolution");
	public Property tiledLightingResolution = addProperty(PropertyType.IVec2, "tiledLightingResolution");

	public Property ambientColor = addProperty(PropertyType.FVec3, "ambientColor");
	public Property ambientStrength = addProperty(PropertyType.Float, "ambientStrength");
	public Property lightColor = addProperty(PropertyType.FVec3, "lightColor");
	public Property lightStrength = addProperty(PropertyType.Float, "lightStrength");
	public Property underglowColor = addProperty(PropertyType.FVec3, "underglowColor");
	public Property underglowStrength = addProperty(PropertyType.Float, "underglowStrength");

	public Property useFog = addProperty(PropertyType.Int, "useFog");
	public Property fogDepth = addProperty(PropertyType.Float, "fogDepth");
	public Property fogColor = addProperty(PropertyType.FVec3, "fogColor");
	public Property groundFogStart = addProperty(PropertyType.Float, "groundFogStart");
	public Property groundFogEnd = addProperty(PropertyType.Float, "groundFogEnd");
	public Property groundFogOpacity = addProperty(PropertyType.Float, "groundFogOpacity");

	public Property waterColorLight = addProperty(PropertyType.FVec3, "waterColorLight");
	public Property waterColorMid = addProperty(PropertyType.FVec3, "waterColorMid");
	public Property waterColorDark = addProperty(PropertyType.FVec3, "waterColorDark");

	public Property underwaterEnvironment = addProperty(PropertyType.Int, "underwaterEnvironment");
	public Property underwaterCaustics = addProperty(PropertyType.Int, "underwaterCaustics");
	public Property underwaterCausticsColor = addProperty(PropertyType.FVec3, "underwaterCausticsColor");
	public Property underwaterCausticsStrength = addProperty(PropertyType.Float, "underwaterCausticsStrength");

	public Property lightDir = addProperty(PropertyType.FVec3, "lightDir");

	public Property pointLightsCount = addProperty(PropertyType.Int, "pointLightsCount");

	public Property cameraPos = addProperty(PropertyType.FVec3, "cameraPos");
	public Property viewMatrix = addProperty(PropertyType.Mat4, "viewMatrix");
	public Property projectionMatrix = addProperty(PropertyType.Mat4, "projectionMatrix");
	public Property invProjectionMatrix = addProperty(PropertyType.Mat4, "invProjectionMatrix");
	public Property lightProjectionMatrix = addProperty(PropertyType.Mat4, "lightProjectionMatrix");

	public Property lightningBrightness = addProperty(PropertyType.Float, "lightningBrightness");
	public Property elapsedTime = addProperty(PropertyType.Float, "elapsedTime");
}

package rs117.hd.opengl.uniforms;

import rs117.hd.utils.buffer.GLBuffer;

import static org.lwjgl.opengl.GL33C.*;

public class UBOLights extends UniformBuffer<GLBuffer> {

	public static final int MAX_LIGHTS = 1000; // Struct is 64 Bytes, UBO Max size is 64 KB
	private final LightStruct[] lights;
	private final Property[] lightPositions;

	public UBOLights(boolean isCullingUBO) {
		super(GL_DYNAMIC_DRAW);
		lightPositions = isCullingUBO ? addPropertyArray(PropertyType.FVec4, "lightPositions", MAX_LIGHTS) : null;
		lights = !isCullingUBO ? addStructs(new LightStruct[MAX_LIGHTS], LightStruct::new) : null;
	}

	@Override
	public String getUniformBlockName() {
		return lights != null ? "UBOLights" : "UBOLightsCulling";
	}

	public void setLight(int lightIdx, float[] position, float[] color) {
		if (lightIdx >= 0 && lightIdx < MAX_LIGHTS) {
			if(lights != null) {
				var struct = lights[lightIdx];
				struct.position.set(position);
				struct.color.set(color);
			} else {
				lightPositions[lightIdx].set(position);
			}
		}
	}

	public static class LightStruct extends UniformBuffer.StructProperty {
		public Property position = addProperty(PropertyType.FVec4, "position");
		public Property color = addProperty(PropertyType.FVec4, "color");
	}
}

package rs117.hd.opengl.uniforms;

import java.nio.ByteBuffer;
import java.nio.FloatBuffer;
import java.nio.IntBuffer;
import java.util.ArrayList;
import java.util.List;
import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.lwjgl.BufferUtils;
import rs117.hd.utils.buffer.GLBuffer;
import rs117.hd.utils.buffer.SharedGLBuffer;

import static org.lwjgl.opengl.GL33C.*;
import static rs117.hd.utils.MathUtils.*;

@Slf4j
public abstract class UniformBuffer<GLBUFFER extends GLBuffer> {
	@RequiredArgsConstructor
	protected enum PropertyType {
		Int(4, 4, 1),
		IVec2(8, 8, 2),
		IVec3(12, 16, 3),
		IVec4(16, 16, 4),

		Float(4, 4, 1),
		FVec2(8, 8, 2),
		FVec3(12, 16, 3),
		FVec4(16, 16, 4),

		Mat3(48, 16, 9),
		Mat4(64, 16, 16);

		private final int size;
		private final int alignment;
		private final int elementCount;
		private final boolean isInt = name().startsWith("I");
	}

	@AllArgsConstructor
	@RequiredArgsConstructor
	public static class Property {
		private UniformBuffer<?> owner;
		private int position;
		private int offset = -1;
		private final PropertyType type;
		private final String name;

		private void log(String message) {
			log.warn("{}.{} - {}", owner.glBuffer.name, name, message);
		}

		private boolean isUninitialized() {
			if (offset >= 0)
				return false;
			log("Hasn't been initialized yet!");
			return true;
		}

		public final void set(int... values) {
			if (isUninitialized())
				return;

			if (!type.isInt) {
				log("Int setter was used with a non-int property type");
				return;
			}

			if (values == null) {
				log("Int setter was provided with null value");
				return;
			}

			if (values.length != type.elementCount) {
				log(String.format("Int setter was provided with incorrect number of elements: %d != %d", values.length, type.elementCount));
				return;
			}

			owner.dataInt.position(offset).put(values);
			owner.markWaterLine(position, type.size);
		}

		public final void set(float... values) {
			if (isUninitialized())
				return;

			if (type.isInt) {
				log("Float setter was used with an int property type");
				return;
			}

			if (values == null) {
				log("Float setter was provided with null value");
				return;
			}

			if (values.length != type.elementCount) {
				log(String.format(
					"Float setter was provided with incorrect number of elements: %d != %d",
					values.length,
					type.elementCount
				));
				return;
			}

			owner.dataFloat.position(offset);
			if (type == PropertyType.Mat3) {
				// Pad each column to a vec4
				for (int i = 0; i < 3; i++)
					owner.dataFloat.put(values, i * 3, 3).put(0);
			} else {
				owner.dataFloat.put(values);
			}
			owner.markWaterLine(position, type.size);
		}
	}

	public interface CreateStructProperty<T extends StructProperty> {
		T create();
	}

	public abstract static class StructProperty {
		protected List<Property> properties = new ArrayList<>();

		protected final Property addProperty(PropertyType type, String name) {
			Property property = new Property(type, name);
			properties.add(property);
			return property;
		}
	}

	public final GLBUFFER glBuffer;

	private int size;
	private int dirtyLowTide = Integer.MAX_VALUE;
	private int dirtyHighTide = 0;
	private ByteBuffer data;
	private IntBuffer dataInt;
	private FloatBuffer dataFloat;
	private final List<Property> properties = new ArrayList<>();

	@Getter
	private int bindingIndex;

	@SuppressWarnings("unchecked")
	public UniformBuffer(int glUsage) {
		glBuffer = (GLBUFFER) new GLBuffer(getClass().getSimpleName(), GL_UNIFORM_BUFFER, glUsage);
	}

	@SuppressWarnings("unchecked")
	public UniformBuffer(int glUsage, int clUsage) {
		glBuffer = (GLBUFFER) new SharedGLBuffer(getClass().getSimpleName(), GL_UNIFORM_BUFFER, glUsage, clUsage);
	}

	protected final <T extends StructProperty> T addStruct(T newStructProp) {
		for (Property property : newStructProp.properties)
			appendToBuffer(property);

		// Structs need to align to 16 bytes
		size += (16 - (size % 16)) % 16;

		newStructProp.properties.clear();
		return newStructProp;
	}

	protected final <T extends StructProperty> T[] addStructs(T[] newStructPropArray, CreateStructProperty<T> createFunction) {
		for (int i = 0; i < newStructPropArray.length; i++) {
			newStructPropArray[i] = createFunction.create();
			addStruct(newStructPropArray[i]);
		}

		return newStructPropArray;
	}

	protected Property addProperty(PropertyType type, String name) {
		return appendToBuffer(new Property(type, name));
	}

	protected Property[] addPropertyArray(PropertyType type, String name, int size) {
		Property[] result = new Property[size];
		for (int i = 0; i < size; i++)
			result[i] = addProperty(type, name);
		return result;
	}

	private Property appendToBuffer(Property property) {
		property.owner = this;

		int padding = (property.type.alignment - (size % property.type.alignment)) % property.type.alignment;
		property.position = size + padding;

		size += property.type.size + padding;
		properties.add(property);

		return property;
	}

	private void markWaterLine(int position, int size) {
		dirtyLowTide = min(dirtyLowTide, position);
		dirtyHighTide = max(dirtyHighTide, position + size);
	}

	public void initialize() {
		if (data != null)
			destroy();

		glBuffer.initialize(size);
		data = BufferUtils.createByteBuffer(size);
		dataInt = data.asIntBuffer();
		dataFloat = data.asFloatBuffer();

		// Since everything is aligned to a multiple of 4 bytes, we can easily define offsets into dataInt and dataFloat
		for (Property prop : properties)
			prop.offset = prop.position / 4;
	}

	public void initialize(int bindingIndex) {
		initialize();
		bind(bindingIndex);
	}

	public String getUniformBlockName() {
		return glBuffer.name;
	}

	public void bind(int bindingIndex) {
		this.bindingIndex = bindingIndex;
		glBindBufferBase(GL_UNIFORM_BUFFER, bindingIndex, glBuffer.id);
	}

	protected void preUpload() {}

	public final void upload() {
		if (data == null)
			return;

		preUpload();

		if (dirtyHighTide <= 0 || dirtyLowTide >= glBuffer.size)
			return;

		data.position(dirtyLowTide);
		data.limit(dirtyHighTide);

		glBindBuffer(GL_UNIFORM_BUFFER, glBuffer.id);
		glBufferSubData(GL_UNIFORM_BUFFER, dirtyLowTide, data);
		glBindBuffer(GL_UNIFORM_BUFFER, 0);

		data.clear();

		dirtyLowTide = Integer.MAX_VALUE;
		dirtyHighTide = 0;
	}

	public final void destroy() {
		if (data == null)
			return;

		for (Property prop : properties)
			prop.offset = -1;

		glBuffer.destroy();
		data = null;
		dataInt = null;
		dataFloat = null;
	}
}

package rs117.hd.opengl.uniforms;

import lombok.extern.slf4j.Slf4j;
import net.runelite.api.*;
import rs117.hd.HdPlugin;
import rs117.hd.model.ModelPusher;
import rs117.hd.scene.materials.Material;
import rs117.hd.utils.buffer.GLBuffer;

import static org.lwjgl.opengl.GL33C.*;
import static rs117.hd.utils.MathUtils.*;

@Slf4j
public class UBOMaterials extends UniformBuffer<GLBuffer> {
	public static class MaterialStruct extends StructProperty {
		public Property colorMap = addProperty(PropertyType.Int, "colorMap");
		public Property normalMap = addProperty(PropertyType.Int, "normalMap");
		public Property displacementMap = addProperty(PropertyType.Int, "displacementMap");
		public Property roughnessMap = addProperty(PropertyType.Int, "roughnessMap");
		public Property ambientOcclusionMap = addProperty(PropertyType.Int, "ambientOcclusionMap");
		public Property flowMap = addProperty(PropertyType.Int, "flowMap");
		public Property flags = addProperty(PropertyType.Int, "flags");
		public Property brightness = addProperty(PropertyType.Float, "brightness");
		public Property displacementScale = addProperty(PropertyType.Float, "displacementScale");
		public Property specularStrength = addProperty(PropertyType.Float, "specularStrength");
		public Property specularGloss = addProperty(PropertyType.Float, "specularGloss");
		public Property flowMapStrength = addProperty(PropertyType.Float, "flowMapStrength");
		public Property flowMapDuration = addProperty(PropertyType.FVec2, "flowMapDuration");
		public Property scrollDuration = addProperty(PropertyType.FVec2, "scrollDuration");
		public Property textureScale = addProperty(PropertyType.FVec3, "textureScale");
	}

	public MaterialStruct[] uboStructs;
	public Material[] materials;

	public UBOMaterials(int materialCount) {
		super(GL_STATIC_DRAW);
		assert materialCount - 1 <= ModelPusher.MAX_MATERIAL_INDEX :
			"Too many materials (" + materialCount + ") to fit into packed material data.";
		uboStructs = addStructs(new MaterialStruct[materialCount], MaterialStruct::new);
		initialize(HdPlugin.UNIFORM_BLOCK_MATERIALS);
	}

	public void update(Material[] materials, Texture[] vanillaTextures) {
		this.materials = materials;

		for (int i = 0; i < materials.length; i++) {
			var mat = materials[i];
			mat.uboIndex = i;
			float vanillaScrollX = 0;
			float vanillaScrollY = 0;
			// Replacement materials will only apply vanilla scrolling if they also specify a vanillaTextureIndex
			if (mat.vanillaTextureIndex != -1) {
				var texture = vanillaTextures[mat.vanillaTextureIndex];
				if (texture != null) {
					int direction = texture.getAnimationDirection();
					if (direction != 0) {
						// Convert vanilla texture animations to the same format as Material scroll parameters
						float speed = texture.getAnimationSpeed() * 50 / 128.f;
						float radians = direction * -HALF_PI;
						vanillaScrollX = cos(radians) * speed;
						vanillaScrollY = sin(radians) * speed;
					}
				}
			}
			mat.fillMaterialStruct(uboStructs[i], vanillaScrollX, vanillaScrollY);
		}

		upload();
	}
}

package rs117.hd.opengl.uniforms;

import rs117.hd.utils.buffer.GLBuffer;

import static org.lwjgl.opengl.GL33C.*;

public class UBOUI extends UniformBuffer<GLBuffer> {
	public UBOUI() {
		super(GL_DYNAMIC_DRAW);
	}

	public Property sourceDimensions = addProperty(PropertyType.IVec2, "sourceDimensions");
	public Property targetDimensions = addProperty(PropertyType.IVec2, "targetDimensions");
	public Property alphaOverlay = addProperty(PropertyType.FVec4, "alphaOverlay");
}

package rs117.hd.opengl.uniforms;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import rs117.hd.utils.buffer.SharedGLBuffer;

import static org.lwjgl.opencl.CL10.*;
import static org.lwjgl.opengl.GL33C.*;
import static rs117.hd.utils.MathUtils.*;

public class UBOCompute extends UniformBuffer<SharedGLBuffer> {
	public static final int MAX_CHARACTER_POSITION_COUNT = 50;

	private static final Comparator<CharacterPositionPair> CHARACTER_POSITION_PAIR_COMPARATOR =
		Comparator.comparingDouble(p -> p.dist);

	// Camera uniforms
	public Property yaw = addProperty(PropertyType.Float, "yaw");
	public Property pitch = addProperty(PropertyType.Float, "pitch");
	public Property centerX = addProperty(PropertyType.Int, "centerX");
	public Property centerY = addProperty(PropertyType.Int, "centerY");
	public Property zoom = addProperty(PropertyType.Int, "zoom");
	public Property cameraX = addProperty(PropertyType.Float, "cameraX");
	public Property cameraY = addProperty(PropertyType.Float, "cameraY");
	public Property cameraZ = addProperty(PropertyType.Float, "cameraZ");

	// Wind uniforms
	public Property windDirectionX = addProperty(PropertyType.Float, "windDirectionX");
	public Property windDirectionZ = addProperty(PropertyType.Float, "windDirectionZ");
	public Property windStrength = addProperty(PropertyType.Float, "windStrength");
	public Property windCeiling = addProperty(PropertyType.Float, "windCeiling");
	public Property windOffset = addProperty(PropertyType.Float, "windOffset");

	private final Property characterPositionCount = addProperty(PropertyType.Int, "characterPositionCount");
	private final Property[] characterPositions = addPropertyArray(PropertyType.FVec3, "characterPositions", MAX_CHARACTER_POSITION_COUNT);

	private final ArrayList<CharacterPositionPair> characterPositionsPairs = new ArrayList<>(characterPositions.length);
	private int writtenCharacterPositions;
	private float playerPosX, playerPosZ;

	private static class CharacterPositionPair {
		public float x;
		public float z;
		public float radius;
		public float dist = Float.MAX_VALUE;
	}

	public UBOCompute() {
		super(GL_DYNAMIC_DRAW, CL_MEM_READ_ONLY);
	}

	private CharacterPositionPair getCharacterPositionPair() {
		if (writtenCharacterPositions >= characterPositionsPairs.size()) {
			CharacterPositionPair newPair = new CharacterPositionPair();
			characterPositionsPairs.add(newPair);
			return newPair;
		}

		return characterPositionsPairs.get(writtenCharacterPositions);
	}

	public void addCharacterPosition(int localX, int localZ, int modelRadius) {
		int writeIndex = writtenCharacterPositions;
		CharacterPositionPair pair = getCharacterPositionPair();
		characterPositionsPairs.remove(writeIndex);

		pair.x = localX;
		pair.z = localZ;
		pair.radius = modelRadius * 1.25f;

		if (writeIndex == 0) {
			playerPosX = pair.x;
			playerPosZ = pair.z;
			pair.dist = 0.0f;
		} else {
			pair.dist = abs(playerPosX - pair.x) + abs(playerPosZ - pair.z);

			if (writeIndex > 1) {
				int index = Collections.binarySearch(
					characterPositionsPairs.subList(1, writeIndex),
					pair,
					CHARACTER_POSITION_PAIR_COMPARATOR
				);

				writeIndex = index >= 0 ? index : -index - 1;
			}
		}

		characterPositionsPairs.add(writeIndex, pair);
		writtenCharacterPositions++;
	}

	@Override
	protected void preUpload() {
		for (int i = 0; i < writtenCharacterPositions; i++) {
			CharacterPositionPair pair = characterPositionsPairs.get(i);
			pair.dist = Float.MAX_VALUE;

			if (i < characterPositions.length)
				characterPositions[i].set(pair.x, pair.z, pair.radius);
		}
		characterPositionCount.set(min(writtenCharacterPositions, characterPositions.length));
		writtenCharacterPositions = 0;
	}
}

package rs117.hd.opengl;

import java.nio.ByteBuffer;
import java.nio.IntBuffer;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.Semaphore;
import java.util.concurrent.TimeUnit;
import javax.inject.Inject;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.*;
import rs117.hd.HdPlugin;
import rs117.hd.overlays.FrameTimer;
import rs117.hd.overlays.Timer;

import static org.lwjgl.opengl.GL33C.*;

@Slf4j
public class AsyncUICopy implements Runnable {
	@Inject
	private Client client;

	@Inject
	private HdPlugin plugin;

	@Inject
	private FrameTimer timer;

	private final ExecutorService executor = Executors.newSingleThreadExecutor();
	private final Semaphore completionSemaphore = new Semaphore(0);

	private IntBuffer mappedBuffer;
	private int[] pixels;
	private int interfacePbo;
	private int interfaceTexture;
	private int width;
	private int height;

	@Override
	public void run() {
		long time = System.nanoTime();
		mappedBuffer.put(pixels, 0, width * height);
		time = System.nanoTime() - time;
		completionSemaphore.release();
		timer.add(Timer.COPY_UI, time);
	}

	public void prepare(int interfacePbo, int interfaceTex) {
		// Ensure there isn't already another UI copy in progress
		if (mappedBuffer != null)
			return;

		timer.begin(Timer.MAP_UI_BUFFER);
		glBindBuffer(GL_PIXEL_UNPACK_BUFFER, interfacePbo);
		ByteBuffer buffer = glMapBuffer(GL_PIXEL_UNPACK_BUFFER, GL_WRITE_ONLY);
		glBindBuffer(GL_PIXEL_UNPACK_BUFFER, 0);
		timer.end(Timer.MAP_UI_BUFFER);
		if (buffer == null) {
			log.error("Unable to map interface PBO. Skipping UI...");
			return;
		}

		this.interfacePbo = interfacePbo;
		this.interfaceTexture = interfaceTex;
		this.mappedBuffer = buffer.asIntBuffer();

		var provider = client.getBufferProvider();
		this.pixels = provider.getPixels();
		this.width = provider.getWidth();
		this.height = provider.getHeight();

		executor.execute(this);
	}

	public boolean complete() {
		if (mappedBuffer == null)
			return false;

		try {
			// It shouldn't take this long even in the worst case
			boolean acquired = completionSemaphore.tryAcquire(1, 100, TimeUnit.MILLISECONDS);
			if (!acquired)
				return false;
		} catch (InterruptedException e) {
			throw new RuntimeException(e);
		}

		var uiResolution = plugin.getUiResolution();
		if (uiResolution == null || width > uiResolution[0] || height > uiResolution[1]) {
			log.error("UI texture resolution mismatch ({}x{} > {}). Skipping UI...", width, height, uiResolution);
			return false;
		}

		timer.begin(Timer.UPLOAD_UI);
		glBindBuffer(GL_PIXEL_UNPACK_BUFFER, interfacePbo);
		glUnmapBuffer(GL_PIXEL_UNPACK_BUFFER);
		glActiveTexture(HdPlugin.TEXTURE_UNIT_UI);
		glBindTexture(GL_TEXTURE_2D, interfaceTexture);
		glTexSubImage2D(GL_TEXTURE_2D, 0, 0, 0, width, height, GL_BGRA, GL_UNSIGNED_INT_8_8_8_8_REV, 0);
		timer.end(Timer.UPLOAD_UI);

		glBindBuffer(GL_PIXEL_UNPACK_BUFFER, 0);

		mappedBuffer = null;
		pixels = null;
		return true;
	}
}

/*
 * Copyright (c) 2021, Adam <Adam@sigterm.info>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package rs117.hd.opengl.compute;

import java.io.IOException;
import java.nio.ByteBuffer;
import java.nio.IntBuffer;
import java.nio.LongBuffer;
import java.nio.ShortBuffer;
import javax.inject.Inject;
import javax.inject.Singleton;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.*;
import net.runelite.client.util.OSType;
import net.runelite.rlawt.AWTContext;
import org.lwjgl.BufferUtils;
import org.lwjgl.PointerBuffer;
import org.lwjgl.opencl.APPLEGLSharing;
import org.lwjgl.opencl.CL;
import org.lwjgl.opencl.CL10GL;
import org.lwjgl.opencl.CL12;
import org.lwjgl.opencl.CLCapabilities;
import org.lwjgl.opencl.CLContextCallback;
import org.lwjgl.opencl.CLImageFormat;
import org.lwjgl.system.Configuration;
import org.lwjgl.system.MemoryStack;
import rs117.hd.HdPlugin;
import rs117.hd.opengl.shader.ShaderException;
import rs117.hd.opengl.shader.ShaderIncludes;
import rs117.hd.opengl.uniforms.UBOCompute;
import rs117.hd.utils.buffer.SharedGLBuffer;

import static org.lwjgl.opencl.APPLEGLSharing.CL_CGL_DEVICE_FOR_CURRENT_VIRTUAL_SCREEN_APPLE;
import static org.lwjgl.opencl.APPLEGLSharing.clGetGLContextInfoAPPLE;
import static org.lwjgl.opencl.CL10.*;
import static org.lwjgl.opencl.KHRGLSharing.CL_GLX_DISPLAY_KHR;
import static org.lwjgl.opencl.KHRGLSharing.CL_GL_CONTEXT_KHR;
import static org.lwjgl.opencl.KHRGLSharing.CL_WGL_HDC_KHR;
import static org.lwjgl.system.MemoryUtil.NULL;
import static org.lwjgl.system.MemoryUtil.memASCII;
import static org.lwjgl.system.MemoryUtil.memUTF8;
import static rs117.hd.utils.MathUtils.*;

@Singleton
@Slf4j
public class OpenCLManager {
	private static final String KERNEL_NAME_PASSTHROUGH = "passthroughModel";
	private static final String KERNEL_NAME_SORT = "sortModel";

	//  struct shared_data {
	//      int totalNum[12];
	//      int totalDistance[12];
	//      int totalMappedNum[18];
	//      int min10;
	//      int renderPris[0];
	//  };
	private static final int SHARED_SIZE = 12 + 12 + 18 + 1; // in ints

	@Inject
	private HdPlugin plugin;

	public static long context;

	private boolean initialized;

	private CLCapabilities deviceCaps;
	private long device;
	private long commandQueue;

	private long passthroughProgram;
	private long[] sortingPrograms;

	private long passthroughKernel;
	private long[] sortingKernels;

	private long tileHeightMap;

	static {
		Configuration.OPENCL_EXPLICIT_INIT.set(true);
	}

	public void startUp(AWTContext awtContext) {
		CL.create();
		initialized = true;
		initContext(awtContext);
		log.debug("Device CL_DEVICE_MAX_WORK_GROUP_SIZE: {}", getMaxWorkGroupSize());
		initQueue();
	}

	public void shutDown() {
		if (!initialized)
			return;

		try {
			if (tileHeightMap != 0)
				clReleaseMemObject(tileHeightMap);
			tileHeightMap = 0;

			destroyPrograms();

			if (commandQueue != 0)
				clReleaseCommandQueue(commandQueue);
			commandQueue = 0;
			if (context != 0)
				clReleaseContext(context);
			context = 0;
			if (device != 0 && deviceCaps.OpenCL12)
				CL12.clReleaseDevice(device);
			device = 0;
		} finally {
			CL.destroy();
			initialized = false;
		}
	}

	private void initContext(AWTContext awtContext) {
		try (var stack = MemoryStack.stackPush()) {
			IntBuffer pi = stack.mallocInt(1);
			checkCLError(clGetPlatformIDs(null, pi));
			if (pi.get(0) == 0)
				throw new RuntimeException("No OpenCL platforms found.");

			PointerBuffer platforms = stack.mallocPointer(pi.get(0));
			checkCLError(clGetPlatformIDs(platforms, (IntBuffer) null));
			if (platforms.limit() == 0)
				throw new RuntimeException("Unable to find compute platform");

			PointerBuffer ctxProps = stack.mallocPointer(7)
				.put(CL_CONTEXT_PLATFORM)
				.put(0);
			switch (OSType.getOSType()) {
				case Windows:
					ctxProps
						.put(CL_GL_CONTEXT_KHR)
						.put(awtContext.getGLContext())
						.put(CL_WGL_HDC_KHR)
						.put(awtContext.getWGLHDC());
					break;
				case Linux:
					ctxProps
						.put(CL_GL_CONTEXT_KHR)
						.put(awtContext.getGLContext())
						.put(CL_GLX_DISPLAY_KHR)
						.put(awtContext.getGLXDisplay());
					break;
				case MacOS:
					ctxProps
						.put(APPLEGLSharing.CL_CONTEXT_PROPERTY_USE_CGL_SHAREGROUP_APPLE)
						.put(awtContext.getCGLShareGroup());
					break;
				default:
					throw new RuntimeException("unsupported platform");
			}
			ctxProps.put(0).flip();

			IntBuffer errcode_ret = stack.callocInt(1);
			for (int p = 0; p < platforms.limit(); p++) {
				try {
					long platform = platforms.get(p);
					ctxProps.put(1, platform);

					log.debug("Platform index {}:", p);
					log.debug("\tprofile: {}", getPlatformInfoStringUTF8(platform, CL_PLATFORM_PROFILE));
					log.debug("\tversion: {}", getPlatformInfoStringUTF8(platform, CL_PLATFORM_VERSION));
					log.debug("\tname: {}", getPlatformInfoStringUTF8(platform, CL_PLATFORM_NAME));
					log.debug("\tvendor: {}", getPlatformInfoStringUTF8(platform, CL_PLATFORM_VENDOR));
					log.debug("\textensions: {}", getPlatformInfoStringUTF8(platform, CL_PLATFORM_EXTENSIONS));

					int returnCode = clGetDeviceIDs(platform, CL_DEVICE_TYPE_ALL, null, pi);
					if (returnCode == CL_INVALID_DEVICE_TYPE) {
						log.debug("\tno devices");
						continue;
					}
					checkCLError(returnCode);

					PointerBuffer devices = stack.mallocPointer(pi.get(0));
					checkCLError(clGetDeviceIDs(platform, CL_DEVICE_TYPE_ALL, devices, (IntBuffer) null));

					for (int d = 0; d < devices.capacity(); d++) {
						long device = devices.get(d);
						long deviceType = getDeviceInfoLong(device, CL_DEVICE_TYPE);

						log.debug("\tdevice index {}:", d);
						log.debug("\t\tCL_DEVICE_NAME: {}", getDeviceInfoStringUTF8(device, CL_DEVICE_NAME));
						log.debug("\t\tCL_DEVICE_VENDOR: {}", getDeviceInfoStringUTF8(device, CL_DEVICE_VENDOR));
						log.debug("\t\tCL_DRIVER_VERSION: {}", getDeviceInfoStringUTF8(device, CL_DRIVER_VERSION));
						log.debug("\t\tCL_DEVICE_PROFILE: {}", getDeviceInfoStringUTF8(device, CL_DEVICE_PROFILE));
						log.debug("\t\tCL_DEVICE_VERSION: {}", getDeviceInfoStringUTF8(device, CL_DEVICE_VERSION));
						log.debug("\t\tCL_DEVICE_EXTENSIONS: {}", getDeviceInfoStringUTF8(device, CL_DEVICE_EXTENSIONS));
						log.debug("\t\tCL_DEVICE_TYPE: {}", deviceType);
						log.debug("\t\tCL_DEVICE_VENDOR_ID: {}", getDeviceInfoInt(device, CL_DEVICE_VENDOR_ID));
						log.debug("\t\tCL_DEVICE_MAX_COMPUTE_UNITS: {}", getDeviceInfoInt(device, CL_DEVICE_MAX_COMPUTE_UNITS));
						log.debug("\t\tCL_DEVICE_MAX_WORK_ITEM_DIMENSIONS: {}", getDeviceInfoInt(device, CL_DEVICE_MAX_WORK_ITEM_DIMENSIONS));
						log.debug("\t\tCL_DEVICE_MAX_WORK_GROUP_SIZE: {}", getDeviceInfoPointer(device, CL_DEVICE_MAX_WORK_GROUP_SIZE));
						log.debug("\t\tCL_DEVICE_MAX_CLOCK_FREQUENCY: {}", getDeviceInfoInt(device, CL_DEVICE_MAX_CLOCK_FREQUENCY));
						log.debug("\t\tCL_DEVICE_ADDRESS_BITS: {}", getDeviceInfoInt(device, CL_DEVICE_ADDRESS_BITS));
						log.debug("\t\tCL_DEVICE_AVAILABLE: {}", getDeviceInfoInt(device, CL_DEVICE_AVAILABLE) != 0);
						log.debug("\t\tCL_DEVICE_COMPILER_AVAILABLE: {}", (getDeviceInfoInt(device, CL_DEVICE_COMPILER_AVAILABLE) != 0));

						if (deviceType != CL_DEVICE_TYPE_GPU)
							continue;
						CLCapabilities platformCaps = CL.createPlatformCapabilities(platform);
						deviceCaps = CL.createDeviceCapabilities(device, platformCaps);
						if (!deviceCaps.cl_khr_gl_sharing && !deviceCaps.cl_APPLE_gl_sharing)
							continue;

						// Initialize a context from the device if one hasn't already been created
						if (context == 0) {
							try {
								var callback = CLContextCallback.create((errinfo, private_info, cb, user_data) ->
									log.error("[LWJGL] cl_context_callback: {}", memUTF8(errinfo)));
								long context = clCreateContext(ctxProps, device, callback, NULL, errcode_ret);
								checkCLError(errcode_ret);

								if (OSType.getOSType() == OSType.MacOS) {
									var buf = stack.mallocPointer(1);
									checkCLError(clGetGLContextInfoAPPLE(
										context,
										awtContext.getGLContext(),
										CL_CGL_DEVICE_FOR_CURRENT_VIRTUAL_SCREEN_APPLE,
										buf,
										null
									));
									if (buf.get(0) != device) {
										log.debug("Skipping capable but not current virtual screen device...");
										clReleaseContext(context);
										continue;
									}
								}

								log.debug("Choosing the above device for OpenCL");
								this.device = device;
								OpenCLManager.context = context;
							} catch (Exception ex) {
								log.error("Error while creating context:", ex);
							}
						}
					}
				} catch (Exception ex) {
					log.error("Error while checking platform:", ex);
				}
			}

			if (context == 0)
				throw new RuntimeException("Unable to create suitable compute context");
		}
	}

	public int getMaxWorkGroupSize() {
		long[] maxWorkGroupSize = new long[1];
		clGetDeviceInfo(device, CL_DEVICE_MAX_WORK_GROUP_SIZE, maxWorkGroupSize, null);
		return (int) (maxWorkGroupSize[0] * 0.6f); // Workaround for https://github.com/117HD/RLHD/issues/598
	}

	private void initQueue() {
		long[] l = new long[1];
		clGetDeviceInfo(device, CL_DEVICE_QUEUE_PROPERTIES, l, null);

		commandQueue = clCreateCommandQueue(context, device, l[0] & CL_QUEUE_OUT_OF_ORDER_EXEC_MODE_ENABLE, (int[]) null);
		log.debug("Created command_queue {}, properties {}", commandQueue, l[0] & CL_QUEUE_OUT_OF_ORDER_EXEC_MODE_ENABLE);
	}

	private long compileProgram(MemoryStack stack, String path, ShaderIncludes includes) throws ShaderException, IOException {
		String source = includes.loadFile(path);
		log.trace("Compiling program:\n {}", source);
		IntBuffer errcode_ret = stack.callocInt(1);
		long program = clCreateProgramWithSource(context, source, errcode_ret);
		checkCLError(errcode_ret);

		int err = clBuildProgram(program, device, "", null, 0);
		if (err != CL_SUCCESS)
			throw ShaderException.compileError(
				includes,
				source,
				getProgramBuildInfoStringASCII(program, device, CL_PROGRAM_BUILD_LOG),
				path
			);

		log.debug("Build status: {}", getProgramBuildInfoInt(program, device, CL_PROGRAM_BUILD_STATUS));
		if (deviceCaps.OpenCL12)
			log.debug("Binary type: {}", getProgramBuildInfoInt(program, device, CL12.CL_PROGRAM_BINARY_TYPE));
		log.debug("Build options: {}", getProgramBuildInfoStringASCII(program, device, CL_PROGRAM_BUILD_OPTIONS));
		log.debug("Build log: {}", getProgramBuildInfoStringASCII(program, device, CL_PROGRAM_BUILD_LOG));
		return program;
	}

	private long getKernel(MemoryStack stack, long program, String kernelName) {
		IntBuffer errcode_ret = stack.callocInt(1);
		long kernel = clCreateKernel(program, kernelName, errcode_ret);
		checkCLError(errcode_ret);
		log.debug("Loaded kernel {} for program {}", kernelName, program);
		return kernel;
	}

	public void initPrograms() throws ShaderException, IOException {
		try (var stack = MemoryStack.stackPush()) {
			var includes = new ShaderIncludes()
				.define("UNDO_VANILLA_SHADING", plugin.configUndoVanillaShading)
				.define("LEGACY_GREY_COLORS", plugin.configLegacyGreyColors)
				.define("WIND_DISPLACEMENT", plugin.configWindDisplacement)
				.define("WIND_DISPLACEMENT_NOISE_RESOLUTION", HdPlugin.WIND_DISPLACEMENT_NOISE_RESOLUTION)
				.define("CHARACTER_DISPLACEMENT", plugin.configCharacterDisplacement)
				.define("MAX_CHARACTER_POSITION_COUNT", UBOCompute.MAX_CHARACTER_POSITION_COUNT)
				.addIncludePath(OpenCLManager.class);
			passthroughProgram = compileProgram(stack, "comp_unordered.cl", includes);
			passthroughKernel = getKernel(stack, passthroughProgram, KERNEL_NAME_PASSTHROUGH);

			sortingPrograms = new long[plugin.numSortingBins];
			sortingKernels = new long[plugin.numSortingBins];
			for (int i = 0; i < plugin.numSortingBins; i++) {
				int faceCount = plugin.modelSortingBinFaceCounts[i];
				int threadCount = plugin.modelSortingBinThreadCounts[i];
				int facesPerThread = ceil((float) faceCount / threadCount);
				includes = includes
					.define("THREAD_COUNT", threadCount)
					.define("FACES_PER_THREAD", facesPerThread);
				sortingPrograms[i] = compileProgram(stack, "comp.cl", includes);
				sortingKernels[i] = getKernel(stack, sortingPrograms[i], KERNEL_NAME_SORT);
			}
		}
	}

	public void destroyPrograms() {
		if (passthroughKernel != 0)
			clReleaseKernel(passthroughKernel);
		passthroughKernel = 0;

		if (passthroughProgram != 0)
			clReleaseProgram(passthroughProgram);
		passthroughProgram = 0;

		if (sortingKernels != null)
			for (var kernel : sortingKernels)
				if (kernel != 0)
					clReleaseKernel(kernel);
		sortingKernels = null;

		if (sortingPrograms != null)
			for (var program : sortingPrograms)
				if (program != 0)
					clReleaseProgram(program);
		sortingPrograms = null;
	}

	public void uploadTileHeights(Scene scene) {
		if (tileHeightMap != 0)
			clReleaseMemObject(tileHeightMap);
		tileHeightMap = 0;

		final int TILEHEIGHT_BUFFER_SIZE = Constants.MAX_Z * Constants.EXTENDED_SCENE_SIZE * Constants.EXTENDED_SCENE_SIZE * Short.BYTES;
		ShortBuffer tileBuffer = BufferUtils.createShortBuffer(TILEHEIGHT_BUFFER_SIZE);
		int[][][] tileHeights = scene.getTileHeights();
		for (int z = 0; z < Constants.MAX_Z; ++z) {
			for (int y = 0; y < Constants.EXTENDED_SCENE_SIZE; ++y) {
				for (int x = 0; x < Constants.EXTENDED_SCENE_SIZE; ++x) {
					int h = tileHeights[z][x][y];
					assert (h & 0b111) == 0;
					h >>= 3;
					tileBuffer.put((short) h);
				}
			}
		}
		tileBuffer.flip();

		try (MemoryStack stack = MemoryStack.stackPush()) {
			CLImageFormat imageFormat = CLImageFormat.calloc(stack);
			imageFormat.image_channel_order(CL_R);
			imageFormat.image_channel_data_type(CL_SIGNED_INT16);

			IntBuffer errcode_ret = stack.callocInt(1);
			tileHeightMap = clCreateImage3D(context, CL_MEM_READ_ONLY | CL_MEM_COPY_HOST_PTR, imageFormat,
				Constants.EXTENDED_SCENE_SIZE, Constants.EXTENDED_SCENE_SIZE, Constants.MAX_Z,
				0L, 0L,
				tileBuffer,
				errcode_ret
			);
			checkCLError(errcode_ret);
		}
	}

	public void compute(
		SharedGLBuffer uboCompute,
		int numPassthroughModels, int[] numSortingBinModels,
		SharedGLBuffer modelPassthroughBuffer, SharedGLBuffer[] modelSortingBuffers,
		SharedGLBuffer stagingBufferVertices, SharedGLBuffer stagingBufferUvs, SharedGLBuffer stagingBufferNormals,
		SharedGLBuffer renderBufferVertices, SharedGLBuffer renderBufferUvs, SharedGLBuffer renderBufferNormals
	) {
		try (var stack = MemoryStack.stackPush()) {
			PointerBuffer glBuffers = stack.mallocPointer(8 + modelSortingBuffers.length)
				.put(uboCompute.clId)
				.put(modelPassthroughBuffer.clId)
				.put(stagingBufferVertices.clId)
				.put(stagingBufferUvs.clId)
				.put(stagingBufferNormals.clId)
				.put(renderBufferVertices.clId)
				.put(renderBufferUvs.clId)
				.put(renderBufferNormals.clId);
			for (var buffer : modelSortingBuffers)
				glBuffers.put(buffer.clId);
			glBuffers.flip();

			PointerBuffer acquireEvent = stack.mallocPointer(1);
			CL10GL.clEnqueueAcquireGLObjects(commandQueue, glBuffers, null, acquireEvent);

			PointerBuffer computeEvents = stack.mallocPointer(1 + modelSortingBuffers.length);
			if (numPassthroughModels > 0) {
				clSetKernelArg1p(passthroughKernel, 0, modelPassthroughBuffer.clId);
				clSetKernelArg1p(passthroughKernel, 1, stagingBufferVertices.clId);
				clSetKernelArg1p(passthroughKernel, 2, stagingBufferUvs.clId);
				clSetKernelArg1p(passthroughKernel, 3, stagingBufferNormals.clId);
				clSetKernelArg1p(passthroughKernel, 4, renderBufferVertices.clId);
				clSetKernelArg1p(passthroughKernel, 5, renderBufferUvs.clId);
				clSetKernelArg1p(passthroughKernel, 6, renderBufferNormals.clId);

				// queue compute call after acquireGLBuffers
				clEnqueueNDRangeKernel(commandQueue, passthroughKernel, 1, null,
					stack.pointers(numPassthroughModels * 6L), stack.pointers(6),
					acquireEvent, computeEvents
				);
				computeEvents.position(computeEvents.position() + 1);
			}

			for (int i = 0; i < numSortingBinModels.length; i++) {
				int numModels = numSortingBinModels[i];
				if (numModels == 0)
					continue;

				int faceCount = plugin.modelSortingBinFaceCounts[i];
				int threadCount = plugin.modelSortingBinThreadCounts[i];
				long kernel = sortingKernels[i];

				clSetKernelArg(kernel, 0, (long) (SHARED_SIZE + faceCount) * Integer.BYTES);
				clSetKernelArg1p(kernel, 1, modelSortingBuffers[i].clId);
				clSetKernelArg1p(kernel, 2, stagingBufferVertices.clId);
				clSetKernelArg1p(kernel, 3, stagingBufferUvs.clId);
				clSetKernelArg1p(kernel, 4, stagingBufferNormals.clId);
				clSetKernelArg1p(kernel, 5, renderBufferVertices.clId);
				clSetKernelArg1p(kernel, 6, renderBufferUvs.clId);
				clSetKernelArg1p(kernel, 7, renderBufferNormals.clId);
				clSetKernelArg1p(kernel, 8, uboCompute.clId);
				clSetKernelArg1p(kernel, 9, tileHeightMap);

				clEnqueueNDRangeKernel(commandQueue, kernel, 1, null,
					stack.pointers((long) numModels * threadCount),
					stack.pointers(threadCount),
					acquireEvent, computeEvents
				);
				computeEvents.position(computeEvents.position() + 1);
			}

			if (computeEvents.position() == 0) {
				CL10GL.clEnqueueReleaseGLObjects(commandQueue, glBuffers, null, null);
			} else {
				computeEvents.flip();
				CL10GL.clEnqueueReleaseGLObjects(commandQueue, glBuffers, computeEvents, null);
			}
		}
	}

	public void finish() {
		if (commandQueue != 0)
			clFinish(commandQueue);
	}

	private static String getPlatformInfoStringUTF8(long cl_platform_id, int param_name) {
		try (var stack = MemoryStack.stackPush()) {
			PointerBuffer pp = stack.mallocPointer(1);
			checkCLError(clGetPlatformInfo(cl_platform_id, param_name, (ByteBuffer) null, pp));
			int bytes = (int) pp.get(0);

			ByteBuffer buffer = stack.malloc(bytes);
			checkCLError(clGetPlatformInfo(cl_platform_id, param_name, buffer, null));

			return memUTF8(buffer, bytes - 1);
		}
	}

	private static long getDeviceInfoLong(long cl_device_id, int param_name) {
		try (var stack = MemoryStack.stackPush()) {
			LongBuffer pl = stack.mallocLong(1);
			checkCLError(clGetDeviceInfo(cl_device_id, param_name, pl, null));
			return pl.get(0);
		}
	}

	private static int getDeviceInfoInt(long cl_device_id, int param_name) {
		try (var stack = MemoryStack.stackPush()) {
			IntBuffer pl = stack.mallocInt(1);
			checkCLError(clGetDeviceInfo(cl_device_id, param_name, pl, null));
			return pl.get(0);
		}
	}

	private static long getDeviceInfoPointer(long cl_device_id, int param_name) {
		try (var stack = MemoryStack.stackPush()) {
			PointerBuffer pp = stack.mallocPointer(1);
			checkCLError(clGetDeviceInfo(cl_device_id, param_name, pp, null));
			return pp.get(0);
		}
	}

	private static String getDeviceInfoStringUTF8(long cl_device_id, int param_name) {
		try (var stack = MemoryStack.stackPush()) {
			PointerBuffer pp = stack.mallocPointer(1);
			checkCLError(clGetDeviceInfo(cl_device_id, param_name, (ByteBuffer) null, pp));
			int bytes = (int) pp.get(0);

			ByteBuffer buffer = stack.malloc(bytes);
			checkCLError(clGetDeviceInfo(cl_device_id, param_name, buffer, null));

			return memUTF8(buffer, bytes - 1);
		}
	}

	private static int getProgramBuildInfoInt(long cl_program_id, long cl_device_id, int param_name) {
		try (var stack = MemoryStack.stackPush()) {
			IntBuffer pl = stack.mallocInt(1);
			checkCLError(clGetProgramBuildInfo(cl_program_id, cl_device_id, param_name, pl, null));
			return pl.get(0);
		}
	}

	private static String getProgramBuildInfoStringASCII(long cl_program_id, long cl_device_id, int param_name) {
		try (var stack = MemoryStack.stackPush()) {
			PointerBuffer pp = stack.mallocPointer(1);
			checkCLError(clGetProgramBuildInfo(cl_program_id, cl_device_id, param_name, (ByteBuffer) null, pp));
			int bytes = (int) pp.get(0);

			ByteBuffer buffer = stack.malloc(bytes);
			checkCLError(clGetProgramBuildInfo(cl_program_id, cl_device_id, param_name, buffer, null));

			return memASCII(buffer, bytes - 1);
		}
	}

	private static void checkCLError(IntBuffer errcode) {
		checkCLError(errcode.get(errcode.position()));
	}

	private static void checkCLError(int errcode) {
		if (errcode != CL_SUCCESS)
			throw new RuntimeException(String.format("OpenCL error [%d]", errcode));
	}
}

package rs117.hd.opengl.compute;

public enum ComputeMode
{
    OPENGL,
    OPENCL,
}
package rs117.hd.opengl.shader;

import static org.lwjgl.opengl.GL33C.*;
import static rs117.hd.HdPlugin.TEXTURE_UNIT_UI;

public class UIShaderProgram extends ShaderProgram {
	private final UniformTexture uniUiTexture = addUniformTexture("uiTexture");

	public UIShaderProgram() {
		super(t -> t
			.add(GL_VERTEX_SHADER, "ui_vert.glsl")
			.add(GL_FRAGMENT_SHADER, "ui_frag.glsl"));
	}

	@Override
	protected void initialize() {
		uniUiTexture.set(TEXTURE_UNIT_UI);
	}
}

/*
 * Copyright (c) 2018, Adam <Adam@sigterm.info>
 * Copyright (c) 2025, Hooder <ahooder@protonmail.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package rs117.hd.opengl.shader;

import java.util.regex.Matcher;
import java.util.regex.Pattern;
import lombok.extern.slf4j.Slf4j;

@Slf4j
public class ShaderException extends Exception
{
	private static final Pattern NVIDIA_GL_ERROR_REGEX = Pattern.compile("^(\\d+)\\((\\d+)\\) : (.*)$", Pattern.MULTILINE);
	private static final Pattern NVIDIA_CL_ERROR_REGEX = Pattern.compile("^<kernel>:(\\d+):(\\d+): (.*)$", Pattern.MULTILINE);
	private static final Pattern CL_LINE_REGEX = Pattern.compile("^#line (\\d+) \"(.*)\"", Pattern.MULTILINE);

	public ShaderException(String message) {
		super(message);
	}

	public static ShaderException compileError(ShaderIncludes includes, String source, String error, String... paths)
	{
		boolean linkerError = paths.length > 1;

		StringBuilder sb = new StringBuilder();
		sb.append("Error when ");
		if (linkerError) {
			sb.append("linking shaders");
		} else {
			sb.append("compiling shader");
		}
		sb.append(": ");
		for (int i = 0; i < paths.length; i++) {
			if (i > 0)
				sb.append(" & ");
			sb.append(paths[i]);
		}
		sb.append('\n');

		// We can't parse linker errors without making line directives unique across different shader units
		if (linkerError)
			return new ShaderException(sb.append(error).toString());

		switch (includes.includeType) {
			case GLSL: {
				Matcher m = NVIDIA_GL_ERROR_REGEX.matcher(error);
				if (m.find()) {
					try {
						int prevEnd = 0;
						do {
							if (m.start() > prevEnd)
								sb.append(error, prevEnd, m.start());
							prevEnd = m.end();

							int index = Integer.parseInt(m.group(1));
							int lineNumber = Integer.parseInt(m.group(2));
							String errorString = m.group(3);
							String include = includes.includeList.get(index);
							sb.append(String.format("%s line %d - %s", include, lineNumber, errorString));
						} while (m.find());
						return new ShaderException(sb.toString());
					} catch (Exception ex) {
						log.error("Error while parsing shader compilation error:", ex);
						break;
					}
				}
				break;
			}
			case C:
				Matcher m = NVIDIA_CL_ERROR_REGEX.matcher(error);
				if (m.find()) {
					try {
						int prevEnd = 0;
						do {
							if (m.start() > prevEnd)
								sb.append(error, prevEnd, m.start());
							prevEnd = m.end();

							int lineNumber = Integer.parseInt(m.group(1));
							String errorString = m.group(3);
							String include = "Unknown source";

							var lm = CL_LINE_REGEX.matcher("");
							String[] lines = source.split("\n", lineNumber);
							for (int i = lineNumber - 2; i >= 0; i--) {
								lm.reset(lines[i]);
								if (lm.find()) {
									lineNumber += Integer.parseInt(lm.group(1)) - i - 2;
									include = lm.group(2).replaceAll("\\\\\"", "\"");
									break;
								}
							}

							sb.append(String.format("%s line %d - %s", include, lineNumber, errorString));
						} while (m.find());
						return new ShaderException(sb.toString());
					} catch (Exception ex) {
						log.error("Error while parsing shader compilation error:", ex);
						break;
					}
				}
				break;
		}

		// Unknown error format, so include a mapping from source file indices to paths
		sb.append(error).append("Included sources: [\n");
		int maxIndexWidth = String.valueOf(includes.includeList.size() - 1).length();
		String indexFormat = String.format("%%%dd", maxIndexWidth + 2);
		for (int i = 0; i < includes.includeList.size(); i++)
			sb
				.append(String.format(indexFormat, i))
				.append(": ")
				.append(includes.includeList.get(i))
				.append('\n');
		sb.append("]");

		return new ShaderException(error);
	}
}

package rs117.hd.opengl.shader;

import static org.lwjgl.opengl.GL33C.*;
import static rs117.hd.HdPlugin.TEXTURE_UNIT_GAME;
import static rs117.hd.HdPlugin.TEXTURE_UNIT_SHADOW_MAP;
import static rs117.hd.HdPlugin.TEXTURE_UNIT_TILED_LIGHTING_MAP;

public class SceneShaderProgram extends ShaderProgram {
	private final UniformTexture uniTextureArray = addUniformTexture("textureArray");
	private final UniformTexture uniShadowMap = addUniformTexture("shadowMap");
	private final UniformTexture uniTiledLightingTextureArray = addUniformTexture("tiledLightingArray");

	public SceneShaderProgram() {
		super(t -> t
			.add(GL_VERTEX_SHADER, "scene_vert.glsl")
			.add(GL_GEOMETRY_SHADER, "scene_geom.glsl")
			.add(GL_FRAGMENT_SHADER, "scene_frag.glsl"));
	}

	@Override
	protected void initialize() {
		uniTextureArray.set(TEXTURE_UNIT_GAME);
		uniShadowMap.set(TEXTURE_UNIT_SHADOW_MAP);
		uniTiledLightingTextureArray.set(TEXTURE_UNIT_TILED_LIGHTING_MAP);
	}
}

package rs117.hd.opengl.shader;

import java.io.IOException;
import java.util.ArrayList;
import java.util.List;
import java.util.function.Consumer;
import lombok.Getter;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import rs117.hd.opengl.uniforms.UniformBuffer;

import static org.lwjgl.opengl.GL33C.*;

@Slf4j
public class ShaderProgram {
	@RequiredArgsConstructor
	private static class UniformBufferBlockPair {
		public final UniformBuffer<?> buffer;
		public final int uboProgramIndex;
	}

	private final List<UniformProperty> uniformProperties = new ArrayList<>();
	private final List<UniformBufferBlockPair> uniformBlockMappings = new ArrayList<>();

	protected final ShaderTemplate shaderTemplate;

	private int program;
	@Getter
	private boolean viable = true;

	public ShaderProgram(Consumer<ShaderTemplate> templateConsumer) {
		shaderTemplate = new ShaderTemplate();
		templateConsumer.accept(shaderTemplate);
	}

	public void compile(ShaderIncludes includes) throws ShaderException, IOException {
		int newProgram;
		try {
			newProgram = shaderTemplate.compile(includes);
		} catch (ShaderException ex) {
			viable = false;
			throw ex;
		}

		if (isValid())
			destroy();

		program = newProgram;
		assert isValid();

		for (var prop : uniformProperties) {
			prop.uniformIndex = glGetUniformLocation(program, prop.uniformName);
			if (prop.uniformIndex == -1 && !prop.ignoreMissing)
				log.warn("{} has missing or unused {}: {}", getClass().getSimpleName(), prop.getClass().getSimpleName(), prop.uniformName);
		}

		for (var ubo : includes.uniformBuffers) {
			int bindingIndex = glGetUniformBlockIndex(program, ubo.getUniformBlockName());
			if (bindingIndex != -1)
				uniformBlockMappings.add(new UniformBufferBlockPair(ubo, bindingIndex));
		}

		use();
		initialize();

		glValidateProgram(program);
		if (glGetProgrami(program, GL_VALIDATE_STATUS) == GL_FALSE) {
			String err = glGetProgramInfoLog(program);
			log.error("Failed to validate shader program: {}", getClass().getSimpleName(), new ShaderException(err));
		}
	}

	protected void initialize() {}

	public boolean isValid() {
		return program != 0;
	}

	public boolean isActive() {
		// Meant for debugging only
		return program == glGetInteger(GL_CURRENT_PROGRAM);
	}

	@SuppressWarnings("unchecked")
	public <T extends UniformBuffer<?>> T getUniformBufferBlock(int UniformBlockIndex) {
		for (UniformBufferBlockPair pair : uniformBlockMappings)
			if (pair.buffer.getBindingIndex() == UniformBlockIndex)
				return (T) pair.buffer;
		return null;
	}

	public void use() {
		assert program != 0;
		glUseProgram(program);

		for (UniformBufferBlockPair pair : uniformBlockMappings)
			glUniformBlockBinding(program, pair.uboProgramIndex, pair.buffer.getBindingIndex());
	}

	public void destroy() {
		viable = true;
		if (program == 0)
			return;

		glDeleteProgram(program);
		program = 0;

		for (var prop : uniformProperties)
			prop.destroy();

		uniformBlockMappings.clear();
	}

	private static class UniformProperty {
		ShaderProgram program;
		String uniformName;
		int uniformIndex;
		boolean ignoreMissing;

		void destroy() {
			uniformIndex = -1;
		}
	}

	private <T extends UniformProperty> T addUniform(T property, String uniformName) {
		property.program = this;
		property.uniformName = uniformName;
		uniformProperties.add(property);
		return property;
	}

	public static class UniformBool extends UniformProperty {
		public void set(boolean bool) {
			assert program.isActive();
			glUniform1i(uniformIndex, bool ? 1 : 0);
		}
	}

	public UniformBool addUniformBool(String uniformName) {
		return addUniform(new UniformBool(), uniformName);
	}

	public static class UniformTexture extends UniformProperty {
		public void set(int textureUnit) {
			assert textureUnit >= GL_TEXTURE0 : "Did you accidentally pass in an image unit?";
			assert program.isActive();
			glUniform1i(uniformIndex, textureUnit - GL_TEXTURE0);
		}
	}

	public UniformTexture addUniformTexture(String uniformName) {
		return addUniform(new UniformTexture(), uniformName);
	}

	public static class UniformImage extends UniformProperty {
		public void set(int imageUnit) {
			assert imageUnit < GL_TEXTURE0 : "Did you accidentally pass in a texture unit?";
			assert program.isActive();
			glUniform1i(uniformIndex, imageUnit);
		}
	}

	public UniformImage addUniformImage(String uniformName) {
		return addUniform(new UniformImage(), uniformName);
	}

	public static class Uniform1i extends UniformProperty {
		public void set(int value) {
			assert program.isActive();
			glUniform1i(uniformIndex, value);
		}
	}

	public Uniform1i addUniform1i(String uniformName) {
		return addUniform(new Uniform1i(), uniformName);
	}

	public static class Uniform2i extends UniformProperty {
		public void set(int x, int y) {
			assert program.isActive();
			glUniform2i(uniformIndex, x, y);
		}

		public void set(int... ivec2) {
			assert program.isActive();
			glUniform2iv(uniformIndex, ivec2);
		}
	}

	public Uniform2i addUniform2i(String uniformName) {
		return addUniform(new Uniform2i(), uniformName);
	}

	public static class Uniform3i extends UniformProperty {
		public void set(int x, int y, int z) {
			assert program.isActive();
			glUniform3i(uniformIndex, x, y, z);
		}

		public void set(int... ivec3) {
			assert program.isActive();
			glUniform3iv(uniformIndex, ivec3);
		}
	}

	public Uniform3i addUniform3i(String uniformName) {
		return addUniform(new Uniform3i(), uniformName);
	}

	public static class Uniform4i extends UniformProperty {
		public void set(int x, int y, int z, int w) {
			assert program.isActive();
			glUniform4i(uniformIndex, x, y, z, w);
		}

		public void set(int... ivec4) {
			assert program.isActive();
			glUniform4iv(uniformIndex, ivec4);
		}
	}

	public Uniform4i addUniform4i(String uniformName) {
		return addUniform(new Uniform4i(), uniformName);
	}

	public static class Uniform1f extends UniformProperty {
		public void set(float value) {
			assert program.isActive();
			glUniform1f(uniformIndex, value);
		}
	}

	public Uniform1f addUniform1f(String uniformName) {
		return addUniform(new Uniform1f(), uniformName);
	}

	public static class Uniform2f extends UniformProperty {
		public void set(float x, float y) {
			assert program.isActive();
			glUniform2f(uniformIndex, x, y);
		}

		public void set(float... vec2) {
			assert program.isActive();
			glUniform2fv(uniformIndex, vec2);
		}
	}

	public Uniform2f addUniform2f(String uniformName) {
		return addUniform(new Uniform2f(), uniformName);
	}

	public static class Uniform3f extends UniformProperty {
		public void set(float x, float y, float z) {
			assert program.isActive();
			glUniform3f(uniformIndex, x, y, z);
		}

		public void set(float... vec3) {
			assert program.isActive();
			glUniform3fv(uniformIndex, vec3);
		}
	}

	public Uniform3f addUniform3f(String uniformName) {
		return addUniform(new Uniform3f(), uniformName);
	}

	public static class Uniform4f extends UniformProperty {
		public void set(float x, float y, float z, float w) {
			assert program.isActive();
			glUniform4f(uniformIndex, x, y, z, w);
		}

		public void set(float... vec4) {
			assert program.isActive();
			glUniform4fv(uniformIndex, vec4);
		}
	}

	public Uniform4f addUniform4f(String uniformName) {
		return addUniform(new Uniform4f(), uniformName);
	}

	public static class UniformMat4 extends UniformProperty {
		public void set(float[] mat4) {
			assert program.isActive();
			glUniformMatrix4fv(uniformIndex, false, mat4);
		}
	}

	public UniformMat4 addUniformMat4(String uniformName) {
		return addUniform(new UniformMat4(), uniformName);
	}
}

package rs117.hd.opengl.shader;

import rs117.hd.config.ShadowMode;

import static org.lwjgl.opengl.GL33C.*;
import static rs117.hd.HdPlugin.TEXTURE_UNIT_GAME;

public class ShadowShaderProgram extends ShaderProgram {
	private final UniformTexture uniShadowMap = addUniformTexture("textureArray");

	public ShadowShaderProgram() {
		super(t -> t
			.add(GL_VERTEX_SHADER, "shadow_vert.glsl")
			.add(GL_FRAGMENT_SHADER, "shadow_frag.glsl"));
	}

	@Override
	protected void initialize() {
		uniShadowMap.set(TEXTURE_UNIT_GAME);
	}

	public void setMode(ShadowMode mode) {
		if (mode == ShadowMode.DETAILED) {
			shaderTemplate.add(GL_GEOMETRY_SHADER, "shadow_geom.glsl");
		} else {
			shaderTemplate.remove(GL_GEOMETRY_SHADER);
		}
	}
}

package rs117.hd.opengl.shader;

import static org.lwjgl.opengl.GL33C.*;
import static rs117.hd.HdPlugin.IMAGE_UNIT_TILED_LIGHTING;
import static rs117.hd.HdPlugin.TEXTURE_UNIT_TILED_LIGHTING_MAP;

public class TiledLightingShaderProgram extends ShaderProgram {
	private final UniformTexture uniTiledLightingTextureArray = addUniformTexture("tiledLightingArray");
	private final UniformImage uniTiledLightingTextureStore = addUniformImage("tiledLightingImage");

	public TiledLightingShaderProgram() {
		super(t -> t
			.add(GL_VERTEX_SHADER, "tiled_lighting_vert.glsl")
			.add(GL_FRAGMENT_SHADER, "tiled_lighting_frag.glsl"));
		uniTiledLightingTextureArray.ignoreMissing = true;
		uniTiledLightingTextureStore.ignoreMissing = true;
	}

	@Override
	protected void initialize() {
		uniTiledLightingTextureArray.set(TEXTURE_UNIT_TILED_LIGHTING_MAP);
		uniTiledLightingTextureStore.set(IMAGE_UNIT_TILED_LIGHTING);
	}
}

package rs117.hd.opengl.shader;

import java.io.IOException;
import org.lwjgl.opengl.*;

import static rs117.hd.HdPlugin.TEXTURE_UNIT_TILE_HEIGHT_MAP;

public class ModelSortingComputeProgram extends ShaderProgram {
	public final int threadCount, facesPerThread;

	private final UniformTexture uniTileHeightMap = addUniformTexture("tileHeightMap");

	public ModelSortingComputeProgram(int threadCount, int facesPerThread) {
		super(t -> t.add(GL43C.GL_COMPUTE_SHADER, "comp.glsl"));
		this.threadCount = threadCount;
		this.facesPerThread = facesPerThread;
	}

	@Override
	protected void initialize() {
		uniTileHeightMap.set(TEXTURE_UNIT_TILE_HEIGHT_MAP);
	}

	@Override
	public void compile(ShaderIncludes includes) throws ShaderException, IOException {
		super.compile(includes
			.define("THREAD_COUNT", threadCount)
			.define("FACES_PER_THREAD", facesPerThread));
	}
}

/*
 * Copyright (c) 2018, Adam <Adam@sigterm.info>
 * Copyright (c) 2025, Hooder <ahooder@protonmail.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package rs117.hd.opengl.shader;

import java.io.IOException;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.Stack;
import java.util.function.Supplier;
import java.util.regex.Pattern;
import lombok.extern.slf4j.Slf4j;
import rs117.hd.opengl.uniforms.UniformBuffer;
import rs117.hd.utils.Props;
import rs117.hd.utils.ResourcePath;

import static rs117.hd.utils.ResourcePath.path;

@Slf4j
public class ShaderIncludes {
	public static final ResourcePath SHADER_DUMP_PATH = Props.getFolder("rlhd.dump-shaders", () -> null);

	enum Type { GLSL, C, UNKNOWN }

	private static final Pattern IDENTIFIER_PATTERN = Pattern.compile("^[a-zA-Z_]\\w*");

	@FunctionalInterface
	public interface IncludeProcessor {
		String process(String expression) throws IOException;
	}

	private final List<IncludeProcessor> includeProcessors = new ArrayList<>();
	private final List<ResourcePath> includePaths = new ArrayList<>();
	private final Map<String, Supplier<String>> includeMap = new HashMap<>();

	public final Set<UniformBuffer<?>> uniformBuffers = new HashSet<>();

	Type includeType = Type.UNKNOWN;
	final Stack<Integer> includeStack = new Stack<>();
	final List<String> includeList = new ArrayList<>();

	public ShaderIncludes copy() {
		var clone = new ShaderIncludes();
		clone.includeProcessors.addAll(includeProcessors);
		clone.includePaths.addAll(includePaths);
		clone.uniformBuffers.addAll(uniformBuffers);
		return clone;
	}

	private static int nextUnescapedMatch(String s, int offset, char targetChar) {
		int i;
		while ((i = s.indexOf(targetChar, offset)) != -1) {
			// Check if the char was escaped
			int j = i - 1;
			while (j >= 0 && s.charAt(j) == '\\')
				j--;
			if ((i - j) % 2 != 0)
				break; // Not escaped
			offset = i + 1;
		}
		return i;
	}

	private static boolean isCommentOrEmpty(String expression) {
		expression = expression.stripLeading();
		if (expression.isEmpty())
			return true;

		if (expression.length() < 2 || expression.charAt(0) != '/')
			return false;

		switch (expression.charAt(1)) {
			case '/':
				return true;
			case '*':
				int i = expression.indexOf("*/");
				return i == -1 || isCommentOrEmpty(expression.substring(i + 2));
		}

		return false;
	}

	private ShaderException syntaxError(int lineNumber, String error) {
		String currentFile = includeList.get(includeStack.peek());
		return new ShaderException(String.format(
			"Syntax error in shader include in '%s' on line %d: %s", currentFile, lineNumber, error));
	}

	private ShaderException includeError(int lineNumber, String include) {
		String currentFile = includeList.get(includeStack.peek());
		return new ShaderException(String.format(
			"Failed to load shader include in '%s' on line %d: #include %s", currentFile, lineNumber, include));
	}

	private String parse(String source) throws ShaderException, IOException {
		StringBuilder sb = new StringBuilder();
		int lineNumber = 0;
		for (String line : source.split("\r?\n")) {
			lineNumber++;
			String trimmed = line.stripLeading();
			if (trimmed.startsWith("#include ")) {
				int currentIncludeIndex = includeList.size();
				int parentIncludeIndex = includeStack.peek();
				String currentFile = includeList.get(parentIncludeIndex);

				String expression = trimmed.substring(9).stripLeading();
				if (expression.isEmpty())
					throw syntaxError(lineNumber, "Empty include");

				String includeContents = null;
				char endChar = '"';
				int commentIndex = -1;
				switch (expression.charAt(0)) {
					case '<':
						endChar = '>';
					case '"':
						// Process path includes
						int endIndex = nextUnescapedMatch(expression, 1, endChar);
						if (endIndex == -1)
							throw syntaxError(lineNumber, "Expected closing '" + endChar + "' in include");

						commentIndex = endIndex + 1;
						if (!isCommentOrEmpty(expression.substring(commentIndex)))
							throw syntaxError(
								lineNumber,
								"Unexpected characters after closing '" + endChar + "' in include. Only comments are allowed."
							);

						// Valid include
						String include = expression.substring(1, endIndex);
						if (endChar == '"')
							include = ResourcePath.normalize(currentFile, "..", include);

						includeContents = loadFileInternal(include);
						if (includeContents == null)
							throw includeError(lineNumber, expression.substring(0, endIndex + 1));
						break;
					default:
						// Process constant identifier includes
						var m = IDENTIFIER_PATTERN.matcher(expression);
						if (m.find() && isCommentOrEmpty(expression.substring(m.end()))) {
							commentIndex = m.end();
							var supplier = includeMap.get(m.group());
							if (supplier == null)
								throw includeError(lineNumber, m.group());
							includeContents = supplier.get();
							break;
						}

						// Fall back to custom include processors
						for (var processor : includeProcessors)
							if ((includeContents = processor.process(expression)) != null)
								break;
				}

				if (includeContents == null) {
					log.error("Include not found. Did you forget quotes?", includeError(lineNumber, expression));
					includeContents = String.format("// Not found: %s", expression);
				}

				if (SHADER_DUMP_PATH != null) {
					sb.append("// Include: ").append(expression).append('\n');
					includeContents += String.format("\n// End include: %s", expression);
				}

				switch (includeType) {
					case GLSL:
						if (includeContents.stripLeading().startsWith("#version ")) {
							// In GLSL, no preprocessor directive can precede #version, so handle included files
							// starting with a #version directive differently.
							sb.append(includeContents);
						} else {
							// In GLSL, the #line directive takes a line number and a source file index, which we map to
							// an include-filename through tracking the list of includes.
							// Source: https://www.khronos.org/opengl/wiki/Core_Language_(GLSL)#.23line_directive
							sb
								.append("#line 1 ") // Mark the first line of the included file
								.append(currentIncludeIndex)
								.append('\n')
								.append(includeContents)
								.append('\n')
								.append("#line ") // Return to the next line of the current file
								.append(lineNumber + 1)
								.append(" ")
								.append(parentIncludeIndex)
								.append('\n');
						}
						break;
					case C:
						// In C, #line followed by a line number sets the line number for the current file, while
						// #line followed by a line number and a string constant filename changes the line number and
						// current filename being processed, so in our case we will only be using the latter.
						// Source: https://gcc.gnu.org/onlinedocs/cpp/Line-Control.html
						sb
							.append("#line 1 \"") // Change to line 1 in the included file
							.append(expression.replaceAll("\"", "\\\\\""))
							.append("\"\n")
							.append(includeContents)
							.append('\n')
							.append("#line ") // Return to the next line in the parent include
							.append(lineNumber + 1)
							.append(" \"")
							.append(currentFile)
							.append("\"\n");
						break;
					default:
						sb.append(includeContents).append('\n');
						break;
				}

				String comment = commentIndex == -1 ? "" : expression.substring(commentIndex).stripLeading();
				if (!comment.isEmpty())
					sb.append(comment).append('\n');
			} else if (trimmed.startsWith("#pragma once")) {
				int currentIndex = includeList.size() - 1;
				String currentInclude = includeList.get(currentIndex);
				sb.append("// #pragma once: ");
				if (includeList.indexOf(currentInclude) != currentIndex) {
					sb.append("already included\n");
					break;
				} else {
					sb.append("first include\n");
				}
			} else {
				sb.append(line).append('\n');
			}
		}
		return sb.toString();
	}

	private String loadFileInternal(String path) throws ShaderException, IOException {
		includeStack.push(includeList.size());
		includeList.add(path);

		String source = null;
		for (var includePath : includePaths) {
			var resourcePath = includePath.resolve(path);
			if (resourcePath.exists()) {
				source = parse(resourcePath.loadString());
				if (SHADER_DUMP_PATH != null)
					SHADER_DUMP_PATH.resolve(resourcePath.path).mkdirs().writeString(source);
				break;
			}
		}

		includeStack.pop();
		return source;
	}

	public String loadFile(String path) throws ShaderException, IOException {
		includeList.clear();

		switch (path(path).getExtension().toLowerCase()) {
			case "glsl":
				includeType = Type.GLSL;
				break;
			case "c":
			case "h":
			case "cl":
				includeType = Type.C;
				break;
			default:
				includeType = Type.UNKNOWN;
				break;
		}

		String source = loadFileInternal(path);
		if (source != null)
			return source;

		throw new IOException("Failed to load file: " + path);
	}

	public ShaderIncludes addIncludePath(Class<?> clazz) {
		return addIncludePath(path(clazz));
	}

	public ShaderIncludes addIncludePath(ResourcePath includePath) {
		includePaths.add(includePath.chroot());
		return this;
	}

	public ShaderIncludes addInclude(String identifier, Supplier<String> supplier) {
		includeMap.put(identifier, supplier);
		return this;
	}

	public ShaderIncludes addInclude(String identifier, String value) {
		return addInclude(identifier, () -> value);
	}

	public ShaderIncludes addUniformBuffer(UniformBuffer<?> ubo) {
		uniformBuffers.add(ubo);
		return this;
	}

	public ShaderIncludes define(String identifier, String value) {
		return addInclude(identifier, String.format("#define %s %s", identifier, value));
	}

	public ShaderIncludes define(String identifier, boolean value) {
		return define(identifier, String.format("%d", value ? 1 : 0));
	}

	public ShaderIncludes define(String identifier, int value) {
		return define(identifier, String.format("%d", value));
	}

	/**
	 * Define a single-precision float shader constant. OpenCL warns when using doubles in float contexts.
	 */
	public ShaderIncludes define(String identifier, float value) {
		return define(identifier, String.format("%ff", value));
	}

	/**
	 * Define a double-precision float shader constant.
	 */
	public ShaderIncludes define(String identifier, double value) {
		return define(identifier, String.format("%f", value));
	}

	public ShaderIncludes define(String identifier, Enum<?> enumValue) {
		return define(identifier, String.format("%d", enumValue.ordinal()));
	}
}

package rs117.hd.opengl.shader;

import org.lwjgl.opengl.*;

public class ModelPassthroughComputeProgram extends ShaderProgram {
	public ModelPassthroughComputeProgram() {
		super(t -> t.add(GL43C.GL_COMPUTE_SHADER, "comp_unordered.glsl"));
	}
}

/*
 * Copyright (c) 2018, Adam <Adam@sigterm.info>
 * Copyright (c) 2020 Abex
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package rs117.hd.opengl.shader;

import java.io.IOException;
import java.nio.ByteBuffer;
import java.util.HashMap;
import java.util.Map;
import lombok.extern.slf4j.Slf4j;
import org.lwjgl.BufferUtils;
import org.lwjgl.opengl.*;

import static org.lwjgl.opengl.GL33C.*;
import static rs117.hd.opengl.shader.ShaderIncludes.SHADER_DUMP_PATH;

@Slf4j
public class ShaderTemplate
{
	private final Map<Integer, String> shaderTypePaths = new HashMap<>();

	public ShaderTemplate add(int type, String name) {
		shaderTypePaths.put(type, name);
		return this;
	}

	public ShaderTemplate remove(int type) {
		shaderTypePaths.remove(type);
		return this;
	}

	public int compile(ShaderIncludes includes) throws ShaderException, IOException {
		int program = glCreateProgram();
		int[] shaders = new int[shaderTypePaths.size()];
		int i = 0;
		boolean ok = false;

		try
		{
			for (var entry : shaderTypePaths.entrySet()) {
				int shader = glCreateShader(entry.getKey());
				if (shader == 0)
					throw new ShaderException("Unable to create shader of type " + entry.getKey());

				String source = includes.loadFile(entry.getValue());
				glShaderSource(shader, source);
				glCompileShader(shader);

				if (glGetShaderi(shader, GL_COMPILE_STATUS) != GL_TRUE) {
					String error = glGetShaderInfoLog(shader);
					glDeleteShader(shader);
					throw ShaderException.compileError(includes, source, error, entry.getValue());
				}

				glAttachShader(program, shader);
				shaders[i++] = shader;
			}

			glLinkProgram(program);

			String[] paths = shaderTypePaths.values().toArray(String[]::new);
			String combinedName = String.join(" + ", paths);
			if (glGetProgrami(program, GL_LINK_STATUS) == GL_FALSE) {
				throw ShaderException.compileError(
					includes,
					"// Linking " + combinedName,
					glGetProgramInfoLog(program),
					paths
				);
			}

			ok = true;

			if (SHADER_DUMP_PATH != null) {
				int[] numFormats = { 0 };
				glGetIntegerv(GL41C.GL_NUM_PROGRAM_BINARY_FORMATS, numFormats);
				if (numFormats[0] < 1) {
					log.error("OpenGL driver does not support any binary formats");
				} else {
					int[] size = { 0 };
					glGetProgramiv(program, GL41C.GL_PROGRAM_BINARY_LENGTH, size);

					int[] format = { 0 };
					ByteBuffer binary = BufferUtils.createByteBuffer(size[0]);
					GL41C.glGetProgramBinary(program, size, format, binary);

					SHADER_DUMP_PATH.resolve("binaries", combinedName + ".bin").mkdirs().writeByteBuffer(binary);
				}
			}
		} finally {
			while (i > 0) {
				int shader = shaders[--i];
				glDetachShader(program, shader);
				glDeleteShader(shader);
			}

			if (!ok)
				glDeleteProgram(program);
		}

		return program;
	}
}

package rs117.hd.tests;

import org.junit.Assert;
import org.junit.Test;
import rs117.hd.utils.Mat4;

public class Mat4Test {
	@Test
	public void testTranspose() {
		float[] m = {
			1, 2, 3, 4,
			5, 6, 7, 8,
			9, 10, 11, 12,
			13, 14, 15, 16
		};
		System.out.println(Mat4.format(m));
		Mat4.transpose(m);
		System.out.println("\n" + Mat4.format(m));
	}

	@Test
	public void testInverse() {
		float[] nonInvertible = {
			1, -2, 0, 2,
			-1, 3, 1, -2,
			-1, 5, 3, -2,
			0, 7, 7, 0
		};
		Mat4.transpose(nonInvertible);
		Assert.assertThrows(IllegalArgumentException.class, () -> Mat4.inverse(nonInvertible));

		String identity = Mat4.format(Mat4.identity());

		float[] invertible = {
			0, 0, -1, 2,
			0, 1, 0, 0,
			9, 0, 0, 0,
			0, 0, 0, 1
		};
		Mat4.transpose(invertible);
		float[] inverse = Mat4.inverse(invertible);
		Mat4.mul(inverse, invertible);
		Assert.assertEquals(identity, Mat4.format(inverse));

		invertible = new float[] {
			4, 0, 0, 0,
			0, 0, 2, 0,
			0, 1, 2, 0,
			1, 0, 0, 1
		};
		Mat4.transpose(invertible);
		inverse = Mat4.inverse(invertible);
		Mat4.mul(inverse, invertible);
		Assert.assertEquals(identity, Mat4.format(inverse));

		float[] invertible2 = {
			0.20491976f, -0.1548707f, 0.0f, 1.8616436E-8f,
			0.0f, -1.589505E-8f, 0.0f, -1.0f,
			0.096459776f, 0.32900834f, 0.0f, -3.954888E-8f,
			-1846.3291f, -1871.3298f, 100.0f, 3498.0002f
		};
		float[] inverse2 = Mat4.inverse(invertible2);
		Mat4.mul(inverse2, invertible2);
		Assert.assertEquals(identity, Mat4.format(inverse2));
	}
}

package rs117.hd.tests;

import java.util.LinkedHashMap;
import org.junit.Assert;
import org.junit.Test;
import rs117.hd.config.SeasonalTheme;
import rs117.hd.utils.VariableSupplier;

import static rs117.hd.utils.ExpressionParser.parseExpression;
import static rs117.hd.utils.ExpressionParser.parseFunction;
import static rs117.hd.utils.ExpressionParser.parsePredicate;

public class ExpressionParserTest {
	@Test
	public void testExpressionParser() {
		VariableSupplier vars = name -> {
			switch (name) {
				case "h":
					return 5;
				case "s":
					return 10;
				case "l":
					return 5;
				case "blending":
					return true;
				case "textures":
					return false;
			}
			return null;
		};

		Assert.assertEquals(5.f, parseExpression("5"));
		Assert.assertEquals(-5.f, parseExpression("-5"));
		Assert.assertEquals(-2.5f, parseExpression("-2.5"));
		Assert.assertEquals(-.5f, parseExpression("-0.5"));
		Assert.assertEquals(-.5f, parseExpression("-.5"));
		Assert.assertEquals(.5f, parseExpression(".5"));
		Assert.assertEquals(.5f, parseExpression("+.5"));
		Assert.assertEquals(.5f, parseExpression("++ +.5"));
		Assert.assertEquals(1f, parseExpression("--1"));
		Assert.assertEquals(.5f, parseExpression("+-++-.5"));
		Assert.assertEquals(17.f, parseFunction("5 + 12").apply(null));
		Assert.assertEquals(16.f, parseExpression("8 / 2 * (2 + 2)"));
		Assert.assertEquals(32.f, parseExpression("2 * 8 / 2 * (2 + 2)"));
		Assert.assertEquals(3.f, parseExpression("2 * 3 / 2"));
		Assert.assertEquals(0.f, parseExpression("2 * 8 - 4 * 4"));
		Assert.assertEquals(29.f, parseExpression("2 + 3 * (8 + 5 / 5)"));
		Assert.assertEquals(40.f, parseExpression("(8 - 1 + 3) * 6 - ((3 + 7) * 2)"));
		Assert.assertEquals(21.f, parseExpression("(1 + 2) * (3 + 4)"));
		Assert.assertFalse(parsePredicate("!( blending )").test(vars));
		Assert.assertEquals(false, parseExpression("!true"));
		Assert.assertEquals(true, parseExpression("SUMMER == 1", name -> SeasonalTheme.valueOf(name).ordinal()));

		assertThrows(() -> parseExpression("unexpected ( indeed"));
		assertThrows(() -> parseExpression("(5 + ( missing paren)"));

		LinkedHashMap<String, Boolean> testCases = new LinkedHashMap<>();
		testCases.put("h != 0", true);
		testCases.put("s == 0 || h <= 10 && s < 2", false);
		testCases.put("h == 8 && (s == 3 || s == 4) && l >= 20", false);
		testCases.put("h > 3 && s < 15 && l < 21", true);
		testCases.put("h < 3 && s < 15 && l < 21", false);
		testCases.put("h > 3 && (s < 9 || l < 19)", true);
		testCases.put("h == 5 ? s > 3 : s > 15", true);
		testCases.put("h == s || h == l", true);
		testCases.put("blending || textures", true);

		for (var entry : testCases.entrySet()) {
			var predicate = parsePredicate(entry.getKey());
			var result = predicate.test(vars);
			var passed = entry.getValue() == result;
			System.out.println(
				(passed ? "\u001B[32m" : "\u001B[31m") +
				"Case: " + entry.getKey() + " " + (passed ? "passed" : "failed") + ". Expected: " + entry.getValue() + ", got: " + result);
		}
	}

	private static void assertThrows(Runnable runnable) {
		try {
			runnable.run();
		} catch (Throwable ex) {
			System.out.println("\u001B[32m" + "Case: Threw as expected: " + ex);
			return;
		}
		Assert.fail("Didn't throw an exception");
	}
}

package rs117.hd.tests;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Random;
import org.junit.Test;
import rs117.hd.model.ModelHasher;

public class ModelHasherPerformanceTest {
    private final ArrayList<int[]> intArrays;
    private final Random random;
    private final int testDataCount;
    private final int testIterations;

    private long accumulatedHash = 0;

	public ModelHasherPerformanceTest() {
        this.intArrays = new ArrayList<>();
        this.random = new Random(1337);
        this.testDataCount = 1000;
        this.testIterations = 10000000;
    }

    private int[] generateRandomIntArray(int size) {
        int[] a = new int[size];

        for (int i = 0; i < size; i++) {
            a[i] = this.random.nextInt();
        }

        return a;
    }

	private long runStandardHasher() {
		long start = System.nanoTime();
		for (int i = 0; i < this.testIterations; i++) {
			accumulatedHash *= 31;
			accumulatedHash += Arrays.hashCode(intArrays.get(this.random.nextInt(this.testDataCount)));
		}
		return System.nanoTime() - start;
	}

	private long runFastHasher() {
		long start = System.nanoTime();
		for (int i = 0; i < this.testIterations; i++) {
			accumulatedHash *= 31;
			accumulatedHash += ModelHasher.fastHash(intArrays.get(this.random.nextInt(this.testDataCount)), -1);
		}
		return System.nanoTime() - start;
	}

	private double percentageDifference(long original, long changed) {
		long diff = original - changed;
		double delta = (double) diff / original;
		return delta * 100;
	}

	@Test
	public void testHashPerformance() {
		System.out.printf("Java version: %s\n\n", System.getProperty("java.version"));
		System.out.printf("Comparing hash performance of with %,d test items and %,d iterations\n\n", testDataCount, testIterations);

		// small arrays (size=512)
		for (int i = 0; i < testDataCount; i++) {
			// generate random test data
			intArrays.add(generateRandomIntArray(512));
		}

		long standardBatchResult = runStandardHasher();
		System.out.printf("Standard hasher small data set:  \t%,.3f seconds\n", (double) standardBatchResult / 1e9);
		long fastIntBatchResult = runFastHasher();
		System.out.printf("Fast int hasher small data set:  \t%,.3f seconds\n", (double) fastIntBatchResult / 1e9);
		System.out.printf("Improvement =\t%.2f%%\n\n", percentageDifference(standardBatchResult, fastIntBatchResult));
		long fastBatchResult = runFastHasher();
		System.out.printf("Fast hasher small data set:      \t%,.3f seconds\n", (double) fastBatchResult / 1e9);
		System.out.printf("Improvement =\t%.2f%%\n\n", percentageDifference(standardBatchResult, fastBatchResult));

		// medium arrays (size=2048)
		intArrays.clear();
		for (int i = 0; i < testDataCount; i++) {
			intArrays.add(generateRandomIntArray(2048));
		}

		standardBatchResult = runStandardHasher();
		System.out.printf("Standard hasher medium data set:  \t%,.3f seconds\n", (double) standardBatchResult / 1e9);
		fastIntBatchResult = runFastHasher();
		System.out.printf("Fast int hasher medium data set:  \t%,.3f seconds\n", (double) fastIntBatchResult / 1e9);
		System.out.printf("Improvement =\t%.2f%%\n\n", percentageDifference(standardBatchResult, fastIntBatchResult));
		fastBatchResult = runFastHasher();
		System.out.printf("Fast hasher medium data set:      \t%,.3f seconds\n", (double) fastBatchResult / 1e9);
		System.out.printf("Improvement =\t%.2f%%\n\n", percentageDifference(standardBatchResult, fastBatchResult));

		// large arrays (size=6144)
		intArrays.clear();
		for (int i = 0; i < testDataCount; i++) {
			intArrays.add(generateRandomIntArray(6144));
		}

		standardBatchResult = runStandardHasher();
		System.out.printf("Standard hasher large data set:  \t%,.3f seconds\n", (double) standardBatchResult / 1e9);
		fastIntBatchResult = runFastHasher();
		System.out.printf("Fast int hasher large data set:  \t%,.3f seconds\n", (double) fastIntBatchResult / 1e9);
		System.out.printf("Improvement =\t%.2f%%\n\n", percentageDifference(standardBatchResult, fastIntBatchResult));
		fastBatchResult = runFastHasher();
		System.out.printf("Fast hasher large data set:      \t%,.3f seconds\n", (double) fastBatchResult / 1e9);
		System.out.printf("Improvement =\t%.2f%%\n\n", percentageDifference(standardBatchResult, fastBatchResult));

		System.out.println("Hash: " + accumulatedHash);
	}
}

package rs117.hd.tests;

import java.util.Arrays;
import org.junit.Test;
import rs117.hd.utils.ColorUtils;

import static junit.framework.TestCase.assertEquals;
import static rs117.hd.utils.ColorUtils.linearToSrgb;
import static rs117.hd.utils.ColorUtils.packHsl;
import static rs117.hd.utils.ColorUtils.srgbToLinear;
import static rs117.hd.utils.ColorUtils.srgbToPackedHsl;
import static rs117.hd.utils.ColorUtils.unpackHsl;

public class ColorUtilsTest {
	@Test
	public void testJagexHslPacking() {
		float[] hsl;
		for (int counter = 0; (counter & ~0xFFFF) == 0; counter++) {
			int packedHslBefore = counter;
			hsl = unpackHsl(packedHslBefore);
			// Zero saturation or min/max lightness yield the same color
			if (hsl[1] <= .0625f || hsl[2] == 0 || hsl[2] >= 127f / 128) {
				hsl[0] = .0078125f;
				hsl[1] = .0625f;
				packedHslBefore = packHsl(hsl);
			}

			float[] srgbBefore = ColorUtils.packedHslToSrgb(packedHslBefore);
			float[] srgbAfter = linearToSrgb(srgbToLinear(srgbBefore));

			int packedHslAfter = srgbToPackedHsl(srgbAfter);
			if (packedHslBefore != packedHslAfter) {
				assertEquals(String.format(
					"Inaccurate color, packedHsl: %d\t->\t%d,\tHSL: %s\t->\t%s,\tRGB: %s\t->\t%s\n",
					packedHslBefore,
					packedHslAfter,
					Arrays.toString(hsl),
					Arrays.toString(unpackHsl(packedHslAfter)),
					Arrays.toString(srgbBefore),
					Arrays.toString(srgbAfter)
				), packedHslBefore, packedHslAfter);
			}
		}
	}
}

package rs117.hd.tests;

import org.junit.Assert;
import org.junit.Test;
import rs117.hd.scene.areas.AABB;
import rs117.hd.scene.areas.RegionBox;

import static net.runelite.api.Constants.*;

public class AABBTest {
	@Test
	public void testAABB() {
		Assert.assertTrue(new AABB(2815, 10097, 0, 2844, 10046, 0)
			.intersects(2832, 10056, 0, 2839, 10063, 0));
		Assert.assertTrue(new AABB(3221, 9602, 3307, 9660)
			.contains(3223, 9617, 0));
	}

	@Test
	public void testRegionBox() {
		Assert.assertEquals(
			new AABB(3264, 5120, 0, 3327, 5759, MAX_Z - 1),
			new RegionBox(13136, 13145).toAabb()
		);
		Assert.assertEquals(
			new AABB(3264, 5120, 0, 3327, 5759, MAX_Z - 1),
			new RegionBox(13145, 13136).toAabb()
		);
		Assert.assertEquals(
			new AABB(3392, 5760, 0, 3519, 5951, MAX_Z - 1),
			new RegionBox(13658, 13916).toAabb()
		);
	}

	@Test
	public void testRegion() {
		Assert.assertEquals(new AABB(3264, 5696, 3327, 5759), AABB.fromRegionId(13145));
	}
}

package rs117.hd;

import java.io.InputStream;
import java.util.Properties;
import lombok.extern.slf4j.Slf4j;
import net.runelite.client.RuneLite;
import net.runelite.client.RuneLiteProperties;
import net.runelite.client.externalplugins.ExternalPluginManager;
import rs117.hd.utils.Props;

@SuppressWarnings("unchecked")
@Slf4j
public class HdPluginTest
{
	public static void main(String[] args) throws Exception
	{
		Props.DEVELOPMENT = true;
		Props.set("rlhd.resource-path", "src/main/resources");
		ClassLoader.getSystemClassLoader().setDefaultAssertionStatus(true);
		useLatestPluginHub();
		ExternalPluginManager.loadBuiltin(HdPlugin.class);
		RuneLite.main(args);
	}

	private static void useLatestPluginHub()
	{
		if (System.getProperty("runelite.pluginhub.version") == null)
		{
			try
			{
				Properties props = new Properties();
				try (InputStream in = RuneLiteProperties.class.getResourceAsStream("runelite.properties"))
				{
					props.load(in);
				}

				String version = props.getProperty("runelite.pluginhub.version");
				String[] parts = version.split("[.-]");
				if (parts.length > 3 && parts[3].equals("SNAPSHOT"))
				{
					int patch = Integer.parseInt(parts[2]) - 1;
					version = parts[0] + "." + parts[1] + "." + patch;
					log.info("Detected SNAPSHOT version with no manually specified plugin-hub version. " +
							"Setting runelite.pluginhub.version to {}", version);
					System.setProperty("runelite.pluginhub.version", version);
				}
			}
			catch (Exception ex)
			{
				log.error("Failed to automatically use latest plugin-hub version", ex);
			}
		}
	}
}

package rs117.hd.tools;

import com.google.gson.Gson;
import java.io.IOException;
import java.util.Arrays;
import java.util.Collection;
import java.util.HashSet;
import lombok.extern.slf4j.Slf4j;
import rs117.hd.scene.AreaManager;
import rs117.hd.scene.areas.AABB;
import rs117.hd.scene.areas.Area;
import rs117.hd.utils.Props;

import static rs117.hd.utils.MathUtils.*;
import static rs117.hd.utils.ResourcePath.path;

@Slf4j
public class ExportAreas {
	public static void main(String... args) throws IOException {
		Props.set("rlhd.resource-path", "src/main/resources");
		Area[] areas = path(AreaManager.class, "areas.json")
			.loadJson(new Gson(), Area[].class);

		HashSet<AABB> aabbs = new HashSet<>();
		HashSet<AABB> suspiciousAabbs = new HashSet<>();

		for (var area : areas) {
			if (area == Area.ALL || area == Area.NONE)
				continue;
			area.normalize();
			for (AABB aabb : area.aabbs) {
				int width = aabb.maxX + 1 - aabb.minX;
				int height = aabb.maxY + 1 - aabb.minY;
				float ratio = (float) width / height;
				if (max(ratio, 1 / ratio) > 64) {
					log.warn("Suspiciously shaped AABB (width={}, height={}) in {}: {}", width, height, area, aabb);
					suspiciousAabbs.add(aabb);
				}
			}
			aabbs.addAll(Arrays.asList(area.aabbs));
		}

		System.out.println("Suspicious AABBs:");
		printAabbs(suspiciousAabbs);
		System.out.println("\nAll AABBs:");
		printAabbs(aabbs);
	}

	public static void printAabbs(Collection<AABB> aabbs) {
		StringBuilder sb = new StringBuilder();
		sb.append("Area[] area = {");
		for (var aabb : aabbs)
			sb.append(String.format("new Area(%d, %d, %d, %d),", aabb.minX, aabb.minY, aabb.maxX, aabb.maxY));
		sb.deleteCharAt(sb.length() - 1);
		sb.append("};\n");
		sb.append("\"aabbs\": [");
		for (var aabb : aabbs)
			sb.append(String.format("[%d, %d, %d, %d],", aabb.minX, aabb.minY, aabb.maxX, aabb.maxY));
		sb.deleteCharAt(sb.length() - 1);
		sb.append("]");
		System.out.println(sb);
	}
}

