/*
 * Copyright (c) 2018, John Pettenger
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

//thanks & credits to hiscores plugin!
package com.BHPages;

import com.google.common.collect.EvictingQueue;
import com.google.inject.Inject;
import java.awt.event.KeyEvent;
import java.awt.event.KeyListener;
import java.util.Arrays;
import java.util.Objects;
import java.util.Optional;
import java.util.regex.Pattern;
import javax.inject.Singleton;
import javax.swing.SwingUtilities;
import javax.swing.text.BadLocationException;
import javax.swing.text.Document;
import javax.swing.text.JTextComponent;
import lombok.NonNull;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.Friend;
import net.runelite.api.FriendsChatManager;
import net.runelite.api.Nameable;
import net.runelite.api.NameableContainer;
import net.runelite.api.Player;
import net.runelite.api.WorldView;
import net.runelite.api.clan.ClanID;
import net.runelite.api.clan.ClanMember;
import net.runelite.api.clan.ClanSettings;

@Slf4j
@Singleton
class NameAutocompleter implements KeyListener
{
    /**
     * Non-breaking space character.
     */
    private static final String NBSP = Character.toString((char)160);

    /**
     * Character class for characters that cannot be in an RSN.
     */
    private static final Pattern INVALID_CHARS = Pattern.compile("[^a-zA-Z0-9_ -]");

    private static final int MAX_SEARCH_HISTORY = 25;

    private final Client client;
    private final BHP_Config BHPconfig;

    private final EvictingQueue<String> searchHistory = EvictingQueue.create(MAX_SEARCH_HISTORY);

    /**
     * The name currently being autocompleted.
     */
    private String autocompleteName;

    /**
     * Pattern for the name currently being autocompleted.
     */
    private Pattern autocompleteNamePattern;

    @Inject
    private NameAutocompleter(Client client, BHP_Config config)
    {
        this.client = client;
        this.BHPconfig = config;
    }

    @Override
    public void keyPressed(KeyEvent e)
    {

    }

    @Override
    public void keyReleased(KeyEvent e)
    {

    }

    @Override
    public void keyTyped(KeyEvent e)
    {
        if (!BHPconfig.autocomplete())
        {
            return;
        }

        final JTextComponent input = (JTextComponent)e.getSource();
        final String inputText = input.getText();

        // Only autocomplete if the selection end is at the end of the text.
        if (input.getSelectionEnd() != inputText.length())
        {
            return;
        }

        // Character to be inserted at the selection start.
        final String charToInsert = Character.toString(e.getKeyChar());

        // Don't attempt to autocomplete if the name is invalid.
        // This condition is also true when the user presses a key like backspace.
        if (INVALID_CHARS.matcher(charToInsert).find()
                || INVALID_CHARS.matcher(inputText).find())
        {
            return;
        }

        // Check if we are already autocompleting.
        if (autocompleteName != null && autocompleteNamePattern.matcher(inputText).matches())
        {
            if (isExpectedNext(input, charToInsert))
            {
                try
                {
                    // Insert the character and move the selection.
                    final int insertIndex = input.getSelectionStart();
                    Document doc = input.getDocument();
                    doc.remove(insertIndex, 1);
                    doc.insertString(insertIndex, charToInsert, null);
                    input.select(insertIndex + 1, input.getSelectionEnd());
                }
                catch (BadLocationException ex)
                {
                    log.warn("Could not insert character.", ex);
                }

                // Prevent default behavior.
                e.consume();
            }
            else // Character to insert does not match current autocompletion. Look for another name.
            {
                newAutocomplete(e);
            }
        }
        else // Search for a name to autocomplete
        {
            newAutocomplete(e);
        }
    }

    private void newAutocomplete(KeyEvent e)
    {
        final JTextComponent input = (JTextComponent)e.getSource();
        final String inputText = input.getText();
        final String nameStart = inputText.substring(0, input.getSelectionStart()) + e.getKeyChar();

        if (findAutocompleteName(nameStart))
        {
            // Assert this.autocompleteName != null
            final String name = this.autocompleteName;
            SwingUtilities.invokeLater(() ->
            {
                try
                {
                    input.getDocument().insertString(
                            nameStart.length(),
                            name.substring(nameStart.length()),
                            null);
                    input.select(nameStart.length(), name.length());
                }
                catch (BadLocationException ex)
                {
                    log.warn("Could not autocomplete name.", ex);
                }
            });
        }
    }

    private boolean findAutocompleteName(String nameStart)
    {
        final Pattern pattern;
        Optional<String> autocompleteName;

        // Pattern to match names that start with nameStart.
        // Allows spaces to be represented as common whitespaces, underscores,
        // hyphens, or non-breaking spaces.
        // Matching non-breaking spaces is necessary because the API
        // returns non-breaking spaces when a name has whitespace.
        pattern = Pattern.compile(
                "(?i)^" + nameStart.replaceAll("[ _-]", "[ _" + NBSP + "-]") + ".+?");

        // Search all previous successful queries
        autocompleteName = searchHistory.stream()
                .filter(n -> pattern.matcher(n).matches())
                .findFirst();

        // Search friends if previous searches weren't matched
        if (!autocompleteName.isPresent())
        {
            NameableContainer<Friend> friendContainer = client.getFriendContainer();
            if (friendContainer != null)
            {
                autocompleteName = Arrays.stream(friendContainer.getMembers())
                        .map(Nameable::getName)
                        .filter(n -> pattern.matcher(n).matches())
                        .findFirst();
            }
        }

        // Search friends chat if a friend wasn't found
        if (!autocompleteName.isPresent())
        {
            final FriendsChatManager friendsChatManager = client.getFriendsChatManager();
            if (friendsChatManager != null)
            {
                autocompleteName = Arrays.stream(friendsChatManager.getMembers())
                        .map(Nameable::getName)
                        .filter(n -> pattern.matcher(n).matches())
                        .findFirst();
            }
        }

        // Search clans
        if (!autocompleteName.isPresent())
        {
            final ClanSettings[] clanSettings = {
                    client.getClanSettings(ClanID.CLAN),
                    client.getClanSettings(ClanID.GROUP_IRONMAN),
                    client.getGuestClanSettings()
            };
            autocompleteName = Arrays.stream(clanSettings)
                    .filter(Objects::nonNull)
                    .flatMap(cs -> cs.getMembers().stream())
                    .map(ClanMember::getName)
                    .filter(n -> pattern.matcher(n).matches())
                    .findFirst();
        }

        // Search cached players if a friend wasn't found
        if (!autocompleteName.isPresent())
        {
            WorldView wv = client.getTopLevelWorldView();
            autocompleteName = wv.players().stream()
                    .filter(Objects::nonNull)
                    .map(Player::getName)
                    .filter(Objects::nonNull)
                    .filter(n -> pattern.matcher(n).matches())
                    .findFirst();
        }

        if (autocompleteName.isPresent())
        {
            this.autocompleteName = autocompleteName.get().replace(NBSP, " ");
            this.autocompleteNamePattern = Pattern.compile(
                    "(?i)^" + this.autocompleteName.replaceAll("[ _-]", "[ _-]") + "$");
        }
        else
        {
            this.autocompleteName = null;
            this.autocompleteNamePattern = null;
        }

        return autocompleteName.isPresent();
    }

    void addToSearchHistory(@NonNull String name)
    {
        if (!searchHistory.contains(name))
        {
            searchHistory.offer(name);
        }
    }

    private boolean isExpectedNext(JTextComponent input, String nextChar)
    {
        String expected;
        if (input.getSelectionStart() < input.getSelectionEnd())
        {
            try
            {
                expected = input.getText(input.getSelectionStart(), 1);
            }
            catch (BadLocationException ex)
            {
                log.warn("Could not get first character from input selection.", ex);
                return false;
            }
        }
        else
        {
            expected = "";
        }
        return nextChar.equalsIgnoreCase(expected);
    }
}
package com.BHPages;

import net.runelite.client.ui.ColorScheme;

import javax.swing.*;
import java.awt.*;

public class BHP_changelogPanel extends JPanel
{
    public final JPanel changelogPanel = new JPanel();
    public final JLabel changelogTextArea = new JLabel();

    public BHP_changelogPanel()
    {
        setLayout(new BorderLayout());
        setBackground(ColorScheme.DARK_GRAY_COLOR);

        changelogPanel.setLayout(new BorderLayout());
        changelogPanel.setBackground(ColorScheme.DARK_GRAY_COLOR);

        String changelogHtml =
                "<html>" +
                        "<body style='width:180px;'>" +
                        "<b>Change Log</b><br><br>" +

                        "<b>Version 1.0</b>" +
                        "<ul style='margin-left:0; padding-left:10px;'>" +
                        "<li><font color='green'>Added:</font> Automatic Activation when target is assigned.</li>" +
                        "<li><font color='green'>Added:</font> Notepad for keeping track of opponent behaviours / traits.</li>" +
                        "<li><font color='green'>Added:</font> Combat level & Total level listed.</li>" +
                        "<li><font color='green'>Added:</font> Skill levels listed.</li>" +
                        "<li><font color='green'>Added:</font> Ability to make surge potion (81 herb - Yes/No).</li>" +
                        "<li><font color='green'>Added:</font> BH & LMS kill counts listed.</li>" +
                        "</ul>" +

                        "<b>Version 1.1</b>" +
                        "<ul style='margin-left:0; padding-left:10px;'>" +
                        "<li><font color='green'>Added:</font> Name Autocomplete to search function.</li>" +
                        "<li><font color='red'>Removed:</font> Save button in favour of FocusChanged Autosave.</li>" +
                        "<li><font color='green'>Added:</font> A note to inform users how autosave works if no player note is present.</li>" +
                        "<li><font color='orange'>Fixed:</font> Save space data corruption that comes from player names.</li>" +
                        "<li><font color='green'>Added:</font> Merged any duplicate notes using \"---\" as a splitter.</li>" +
                        "</ul>" +

                        "<b>Version 1.2</b>" +
                        "<ul style='margin-left:0; padding-left:10px;'>" +
                        "<li><font color='green'>Added:</font> Tabs for a notes panel & target history panel.</li>" +
                        "<li><font color='green'>Added:</font> Buttons for Changelog (here), Discord, Github & Donations.</li>" +
                        "<li><font color='green'>Added:</font> History Log - tiles with player name, last seen & view in notes (eye icon).</li>" +
                        "<li><font color='green'>Added:</font> Right click support \"BH Lookup\" to show note & skills of players.</li>" +
                        "<li><font color='orange'>Fixed:</font> Issue where new lines or tabs were being removed from note data.</li>" +
                        "<li><font color='orange'>Fixed:</font> Issue where names had \"-\" or \"_\" characters removed.</li>" +
                        "</ul>" +
                        "</body>" +
                        "</html>";


        changelogTextArea.setText(changelogHtml);

        changelogPanel.add(changelogTextArea);
        add(changelogPanel);

    }

    public void rebuild()
    {
        changelogPanel.removeAll();

        changelogPanel.add(changelogTextArea);
        add(changelogPanel);
    }
}

package com.BHPages;

import net.runelite.client.config.Config;
import net.runelite.client.config.ConfigGroup;
import net.runelite.client.config.ConfigItem;

@ConfigGroup("BH Pages")
public interface BHP_Config extends Config
{
	@ConfigItem(
			position = 1,
			keyName = "virtualLevels",
			name = "Display virtual levels",
			description = "Display levels over 99 in the hiscore panel."
	)
	default boolean virtualLevels()
	{
		return true;
	}

	@ConfigItem(
			position = 2,
			keyName = "autocomplete",
			name = "Autocomplete",
			description = "Predict names when typing a name to lookup."
	)
	default boolean autocomplete()
	{
		return true;
	}

	@ConfigItem(
			position = 3,
			keyName = "playerOption",
			name = "Player lookup option",
			description = "Add BH Lookup option to players."
	)
	default boolean playerOption()
	{
		return true;
	}

	@ConfigItem(
			position = 4,
			keyName = "bossPanel",
			name = "Show boss kc on lookups",
			description = "Add the boss kc panel below LMS/BH kc"
	)
	default boolean bossPanel()
	{
		return false;
	}

}

package com.BHPages;

import net.runelite.client.ui.ColorScheme;

import javax.swing.*;
import javax.swing.border.EmptyBorder;
import java.awt.*;
import java.awt.datatransfer.Clipboard;
import java.awt.datatransfer.StringSelection;

public class BHP_donatorinfoPanel extends JPanel
{
    private final JPanel donatorinfoPanel = new JPanel();

    public BHP_donatorinfoPanel()
    {
        setLayout(new BorderLayout());
        setBackground(ColorScheme.DARK_GRAY_COLOR);

        // Main content panel
        donatorinfoPanel.setLayout(new BoxLayout(donatorinfoPanel, BoxLayout.Y_AXIS));
        donatorinfoPanel.setBackground(ColorScheme.DARK_GRAY_COLOR);
        donatorinfoPanel.setBorder(new EmptyBorder(10, 10, 10, 10));

        addLabel("Thank you for any donations!");

        addSpacer();

        addLabel("Crypto Wallet:");
        addLabel("0x18bcfffD1656B1dA70B<br>E5f055B005c5848AEBBCC");  //added <br> to ensure its all displayed
        addCopyButton("Copy Address", "0x18bcfffD1656B1dA70BE5f055B005c5848AEBBCC");

        addSpacer();

        addLabel("Network:");
        addLabel("ERC20 (Ethereum)");
        addCopyButton("Copy Network", "ERC20");

        addSpacer();

        addLabel("Buy me a coffee?");
        addLabel("https://coff.ee/un4gott3n");
        addCopyButton("Copy Coffee Link", "https://coff.ee/un4gott3n");

        addSpacer();

        addLabel("Patreon:");
        addLabel("https://patreon.com/Un4gott3n");
        addCopyButton("Copy Patreon Link", "https://patreon.com/Un4gott3n");

        add(donatorinfoPanel, BorderLayout.CENTER);
    }

    private void addLabel(String htmlText)
    {
        JLabel label = new JLabel("<html>" + htmlText + "</html>");
        label.setForeground(Color.LIGHT_GRAY);
        label.setAlignmentX(Component.LEFT_ALIGNMENT);
        label.setBorder(new EmptyBorder(0, 0, 4, 0));
        donatorinfoPanel.add(label);
    }

    private void addCopyButton(String text, String content)
    {
        JButton copyButton = new JButton(text);
        copyButton.setToolTipText("Copy to clipboard");
        copyButton.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        copyButton.setAlignmentX(Component.LEFT_ALIGNMENT);
        copyButton.addActionListener(e -> copyToClipboard(content));
        donatorinfoPanel.add(copyButton);
    }

    private void addSpacer()
    {
        donatorinfoPanel.add(Box.createVerticalStrut(10));
    }

    private void copyToClipboard(String text)
    {
        StringSelection str = new StringSelection(text);
        Clipboard clipboard = Toolkit.getDefaultToolkit().getSystemClipboard();
        clipboard.setContents(str, null);
    }
}

package com.BHPages;
import com.BHPages.session.IconHandler;

import net.runelite.client.ui.ColorScheme;
import net.runelite.client.util.ImageUtil;
import net.runelite.client.util.LinkBrowser;
import net.runelite.client.util.SwingUtil;

import javax.inject.Inject;
import javax.swing.*;
import javax.swing.plaf.basic.BasicButtonUI;
import java.awt.*;
import java.util.List;
import java.util.LinkedList;


class BHP_HistoryPanel extends JPanel
{
    private final BHP_Plugin plugin;
    private final BHP_changelogPanel BHPchangelog = new BHP_changelogPanel();
    private final BHP_donatorinfoPanel BHPdonator = new BHP_donatorinfoPanel();

    //buttons
    private final JPanel buttonPanel;
    private final JButton changelogBtn;
    private final JButton githubpageBtn;
    private final JButton discordnameBtn;
    private final JButton donatorBtn;

    //history panel
    private final JPanel historyPanel;
    class historyEntry //for usage with our history tiles.
    {
        final String playerName;
        final String timeStamp;

        historyEntry(String name, String time)
        {
            this.playerName = name;
            this.timeStamp = time;
        }
    }
    private final List<historyEntry> historyEntryList = new LinkedList<>();

    private final JScrollPane scrollableContainer;

    private static final ImageIcon CHANGELOG_ICON;
    private static final ImageIcon GITHUB_ICON;
    private static final ImageIcon DISCORD_ICON;
    private static final ImageIcon DONATORADDR_ICON;


    static
    {
        CHANGELOG_ICON = IconHandler.CHANGELOG.getIcon(img -> ImageUtil.resizeImage(img, 16, 16));
        GITHUB_ICON = IconHandler.GITHUB.getIcon(img -> ImageUtil.resizeImage(img, 16, 16));
        DISCORD_ICON = IconHandler.DISCORD.getIcon(img -> ImageUtil.resizeImage(img, 16, 16));
        DONATORADDR_ICON = IconHandler.DONATORADDR.getIcon(img -> ImageUtil.resizeImage(img, 16, 16));
    }

    @Inject
    BHP_HistoryPanel(BHP_Plugin plugin, BHP_changelogPanel BHPchangelog, BHP_donatorinfoPanel BHPdonator, BHP_Config BHPconfig)
    {
        this.plugin = plugin;

        setBorder(BorderFactory.createEmptyBorder(10, 0, 0, 0));
        setBackground(ColorScheme.DARK_GRAY_COLOR);
        setLayout(new BorderLayout(0, 5));

        /* BUTTONS */
        buttonPanel = new JPanel();
        buttonPanel.setLayout(new GridLayout(1, 3, 10, 0));
        buttonPanel.setBackground(ColorScheme.DARK_GRAY_COLOR);

        changelogBtn = new JButton();
        SwingUtil.removeButtonDecorations(changelogBtn);
        changelogBtn.setIcon(CHANGELOG_ICON);
        changelogBtn.setToolTipText("Change Log");
        changelogBtn.setBackground(ColorScheme.DARK_GRAY_COLOR);
        changelogBtn.setUI(new BasicButtonUI());
        changelogBtn.addActionListener((ev) -> {
            BHPchangelog.rebuild();

            if(changelogActive())
            {
                changelogBtn.setBackground(ColorScheme.LIGHT_GRAY_COLOR);
                changelogClose();
            }
            else
            {
                changelogBtn.setBackground(ColorScheme.DARK_GRAY_COLOR);
                changelogOpen();
            }
        });
        changelogBtn.addMouseListener(new java.awt.event.MouseAdapter()
        {
            public void mouseEntered(java.awt.event.MouseEvent evt)
            {
                changelogBtn.setBackground(ColorScheme.DARK_GRAY_HOVER_COLOR);
            }

            public void mouseExited(java.awt.event.MouseEvent evt)
            {
                if(changelogActive())
                {
                    changelogBtn.setBackground(ColorScheme.LIGHT_GRAY_COLOR);
                }
                else
                {
                    changelogBtn.setBackground(ColorScheme.DARK_GRAY_HOVER_COLOR);
                }
            }
        });

        buttonPanel.add(changelogBtn);

        githubpageBtn = new JButton();
        SwingUtil.removeButtonDecorations(githubpageBtn);
        githubpageBtn.setIcon(GITHUB_ICON);
        githubpageBtn.setToolTipText("Report issues or contribute on Github");
        githubpageBtn.setBackground(ColorScheme.DARK_GRAY_COLOR);
        githubpageBtn.setUI(new BasicButtonUI());
        githubpageBtn.addActionListener((ev) -> LinkBrowser.browse("https://github.com/Un4gott3n/BH-Pages"));
        githubpageBtn.addMouseListener(new java.awt.event.MouseAdapter()
        {
            public void mouseEntered(java.awt.event.MouseEvent evt)
            {
                githubpageBtn.setBackground(ColorScheme.DARK_GRAY_HOVER_COLOR);
            }

            public void mouseExited(java.awt.event.MouseEvent evt)
            {
                githubpageBtn.setBackground(ColorScheme.DARK_GRAY_COLOR);
            }
        });

        buttonPanel.add(githubpageBtn);

        discordnameBtn = new JButton();
        SwingUtil.removeButtonDecorations(discordnameBtn);
        discordnameBtn.setIcon(DISCORD_ICON);
        discordnameBtn.setToolTipText("Join BH Pages Discord!");
        discordnameBtn.setBackground(ColorScheme.DARK_GRAY_COLOR);
        discordnameBtn.setUI(new BasicButtonUI());
        discordnameBtn.addActionListener((ev) -> LinkBrowser.browse("https://discord.gg/E8Xu3QAps7"));  //Offical BH Pages Discord
        discordnameBtn.addMouseListener(new java.awt.event.MouseAdapter()
        {
            public void mouseEntered(java.awt.event.MouseEvent evt)
            {
                discordnameBtn.setBackground(ColorScheme.DARK_GRAY_HOVER_COLOR);
            }

            public void mouseExited(java.awt.event.MouseEvent evt)
            {
                discordnameBtn.setBackground(ColorScheme.DARK_GRAY_COLOR);
            }
        });
        buttonPanel.add(discordnameBtn);

        donatorBtn = new JButton();
        SwingUtil.removeButtonDecorations(donatorBtn);
        donatorBtn.setIcon(DONATORADDR_ICON);
        donatorBtn.setToolTipText("Any tips/donations appreciated");
        donatorBtn.setBackground(ColorScheme.DARK_GRAY_COLOR);
        donatorBtn.setUI(new BasicButtonUI());
        donatorBtn.addActionListener((ev) -> {
            if(donatorActive())
            {
                donatorBtn.setBackground(ColorScheme.LIGHT_GRAY_COLOR);
                donatorClose();
            }
            else
            {
                donatorBtn.setBackground(ColorScheme.DARK_GRAY_COLOR);
                donatorOpen();
            }
        });

        donatorBtn.addMouseListener(new java.awt.event.MouseAdapter()
        {
            public void mouseEntered(java.awt.event.MouseEvent evt)
            {
                donatorBtn.setBackground(ColorScheme.DARK_GRAY_COLOR);
            }

            public void mouseExited(java.awt.event.MouseEvent evt)
            {
                if(donatorActive())
                {
                    donatorBtn.setBackground(ColorScheme.LIGHT_GRAY_COLOR);
                }
                else
                {
                    donatorBtn.setBackground(ColorScheme.DARK_GRAY_COLOR);
                }
            }
        });

        buttonPanel.add(donatorBtn);
        /* BUTTONS END */

        /* HISTORY PANEL */
        historyPanel = new JPanel();
        historyPanel.setLayout(new BoxLayout(historyPanel, BoxLayout.Y_AXIS));
        historyPanel.setBackground(ColorScheme.DARK_GRAY_COLOR);

        scrollableContainer = new JScrollPane();
        scrollableContainer.setHorizontalScrollBarPolicy(ScrollPaneConstants.HORIZONTAL_SCROLLBAR_NEVER);
        scrollableContainer.getVerticalScrollBar().setUnitIncrement(12);
        scrollableContainer.setBorder(null);
        scrollableContainer.setViewportView(historyPanel); //default view
        /* HISTORY PANEL END */

        add(buttonPanel, BorderLayout.NORTH);
        add(scrollableContainer, BorderLayout.CENTER);
    }

    private boolean changelogActive()
    {
        return scrollableContainer.getViewport().getView() == BHPchangelog;
    }
    private boolean donatorActive()
    {
        return scrollableContainer.getViewport().getView() == BHPdonator;
    }

    private void changelogClose()
    {
        scrollableContainer.setViewportView(historyPanel);
        historyPanel.setVisible(true);

        repaint();
        revalidate();
    }

    private void donatorClose()
    {
        scrollableContainer.setViewportView(historyPanel);
        historyPanel.setVisible(true);

        repaint();
        revalidate();
    }

    private void changelogOpen()
    {
        scrollableContainer.setViewportView(BHPchangelog);
        historyPanel.setVisible(false);

        repaint();
        revalidate();
    }

    private void donatorOpen()
    {
        scrollableContainer.setViewportView(BHPdonator);
        historyPanel.setVisible(false);

        repaint();
        revalidate();
    }

    public void addHistoryTile(String name, String datestamp)
    {
        if(datestamp.isEmpty())
        {
            return;
        }

        historyPanel.removeAll(); //delete all entries

        historyEntryList.add(0, new historyEntry(name, datestamp)); //Add new entry to the top of the list

        for(historyEntry entry : historyEntryList)
        {
            JPanel tile = new historyTilePanel(entry.playerName, entry.timeStamp, this::triggerLookup);
            historyPanel.add(tile);
        }
        repaint();
        revalidate();

    }

    private void triggerLookup(String name)
    {
        plugin.lookupPlayerName(name, ""); //ensure new entry isn't added to history by passing blank datetime
    }

    public JPanel getHistoryPanel()
    {
        return historyPanel;
    }


}

package com.BHPages;

import javax.inject.Inject;
import javax.inject.Singleton;
import javax.swing.*;
import javax.swing.border.EmptyBorder;

import com.BHPages.session.SessionHandler;
import com.google.common.annotations.VisibleForTesting;
import com.google.common.collect.ImmutableList;
import com.google.common.base.Strings;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.Experience;
import net.runelite.client.game.SpriteManager;
import net.runelite.client.hiscore.*;

import static net.runelite.api.SpriteID.TAB_COMBAT;
import static net.runelite.client.hiscore.HiscoreSkill.*;


import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.FontManager;
import net.runelite.client.ui.components.IconTextField;
import net.runelite.client.util.ImageUtil;

import java.awt.*;
import java.awt.event.FocusAdapter;
import java.awt.event.FocusEvent;
import java.awt.event.KeyListener;
import java.awt.image.BufferedImage;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import net.runelite.client.util.QuantityFormatter;
import org.apache.commons.lang3.StringUtils;

@Slf4j
@Singleton
public class BHP_NotesPanel extends JPanel
{

    private final BHP_Plugin BHPplugin;
    private final BHP_Config BHPconfig;
    private final NameAutocompleter nameAutocompleter;
    private final HiscoreClient hiscoreClient;
    private final SessionHandler sessionHandler;
    //group to hold all the skill levels & cmb level
    private final SpriteManager spriteManager;

    //panel assets
    private final JPanel BHP_NotesPanel = new JPanel(new GridBagLayout());
    private final IconTextField opp_nameText;
    private final JButton opp_search_button;
    private final JTextArea notesEditor;
    private final JPanel totalPanel;
    private final JPanel statsPanel;
    private final JLabel surgePot;
    private final JLabel surgeDash;
    private final JLabel surgeNo;
    private final JLabel surgeYes;
    private final JPanel minigamePanel;
    private final JPanel bosskcPanel;

    //Runescape character usernames are limited to 12 chars
    int MAX_USERNAME_LENGTH = 12;

    //Making string scope bigger for cleaner code
    String autosaveMessage = "Click outside of the textbox to trigger AutoSave for your target notes!";

    // Not an enummap because we need null keys for combat
    private final Map<HiscoreSkill, JLabel> skillLabels = new HashMap<>();

    //the skills to show
    private static final List<HiscoreSkill> SKILLS = ImmutableList.of(
            ATTACK, HITPOINTS, MINING,
            STRENGTH, AGILITY, SMITHING,
            DEFENCE, HERBLORE, FISHING,
            RANGED, THIEVING, COOKING,
            PRAYER, CRAFTING, FIREMAKING,
            MAGIC, FLETCHING, WOODCUTTING,
            RUNECRAFT, SLAYER, FARMING,
            CONSTRUCTION, HUNTER
    );

    //For the boss display panel, same order as hiscore
    private static final List<HiscoreSkill> BOSSES = ImmutableList.of(
            ABYSSAL_SIRE, ALCHEMICAL_HYDRA, AMOXLIATL,
            ARAXXOR, ARTIO, BARROWS_CHESTS,
            BRYOPHYTA, CALLISTO, CALVARION,
            CERBERUS, CHAMBERS_OF_XERIC, CHAMBERS_OF_XERIC_CHALLENGE_MODE,
            CHAOS_ELEMENTAL, CHAOS_FANATIC, COMMANDER_ZILYANA,
            CORPOREAL_BEAST, CRAZY_ARCHAEOLOGIST, DAGANNOTH_PRIME,
            DAGANNOTH_REX, DAGANNOTH_SUPREME, DERANGED_ARCHAEOLOGIST,
            DOOM_OF_MOKHAIOTL, DUKE_SUCELLUS, GENERAL_GRAARDOR,
            GIANT_MOLE, GROTESQUE_GUARDIANS, HESPORI,
            KALPHITE_QUEEN, KING_BLACK_DRAGON, KRAKEN,
            KREEARRA, KRIL_TSUTSAROTH, LUNAR_CHESTS,
            MIMIC, NEX, NIGHTMARE,
            PHOSANIS_NIGHTMARE, OBOR, PHANTOM_MUSPAH,
            SARACHNIS, SCORPIA, SCURRIUS,
            SKOTIZO, SOL_HEREDIT, SPINDEL,
            TEMPOROSS, THE_GAUNTLET, THE_CORRUPTED_GAUNTLET,
            THE_HUEYCOATL, THE_LEVIATHAN, THE_ROYAL_TITANS,
            THE_WHISPERER, THEATRE_OF_BLOOD, THEATRE_OF_BLOOD_HARD_MODE,
            THERMONUCLEAR_SMOKE_DEVIL, TOMBS_OF_AMASCUT, TOMBS_OF_AMASCUT_EXPERT,
            TZKAL_ZUK, TZTOK_JAD, VARDORVIS,
            VENENATIS, VETION, VORKATH,
            WINTERTODT, YAMA, ZALCANO,
            ZULRAH
    );

    /* The currently selected endpoint */
    private HiscoreEndpoint selectedEndPoint;

    /* Used to prevent users from switching endpoint tabs while the results are loading */
    private boolean loading = false;

    @Inject
    BHP_NotesPanel(Client client,
                   BHP_Plugin plugin,
                   BHP_Config config,
                   NameAutocompleter nameAutocompleter,
                   HiscoreClient hiscoreClient,
                   SessionHandler sessionHandler,
                   SpriteManager spriteManager )
    {
        this.BHPplugin = plugin;
        this.BHPconfig = config;
        this.nameAutocompleter = nameAutocompleter;
        this.hiscoreClient = hiscoreClient;
        this.sessionHandler = sessionHandler;
        this.spriteManager = spriteManager;

        setBorder(BorderFactory.createEmptyBorder(10, 0, 0, 0));
        setBackground(ColorScheme.DARK_GRAY_COLOR);
        setLayout(new GridBagLayout());

        GridBagConstraints c = new GridBagConstraints();

        c.insets = new Insets(0, 0, 10, 0);

        //player name / search bar
        opp_nameText = new IconTextField();
        opp_nameText.setIcon(IconTextField.Icon.SEARCH);
        opp_nameText.setPreferredSize(new Dimension(205,30));
        opp_nameText.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        opp_nameText.setHoverBackgroundColor(ColorScheme.DARK_GRAY_HOVER_COLOR);
        opp_nameText.setMinimumSize(new Dimension(0, 30));
        opp_nameText.addActionListener(evt ->
        {
            String searchName = opp_nameText.getText();
            lookup(searchName);
        });
        opp_nameText.addClearListener(() ->
        {
            opp_nameText.setIcon(IconTextField.Icon.SEARCH);
            opp_nameText.setEditable(true);

        });
        c.fill = GridBagConstraints.HORIZONTAL;
        c.weightx = 1;
        c.gridwidth = 2;
        c.gridx = 0;
        c.gridy = 0;
        add(opp_nameText, c);

        //search button to display players
        opp_search_button = new JButton("Search");
        opp_search_button.addActionListener(evt ->
        {
            String searchName = opp_nameText.getText();
            lookup(searchName);
        });
        c.weightx = 1;
        c.gridwidth = 2;
        c.fill = GridBagConstraints.HORIZONTAL;
        c.gridx = 0;
        c.gridy = 1;
        add(opp_search_button, c);

        notesEditor = new JTextArea();
        notesEditor.setForeground(Color.WHITE);
        notesEditor.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        notesEditor.setLineWrap(true);
        notesEditor.setWrapStyleWord(true);
        notesEditor.setTabSize(2);
        notesEditor.setRows(7);
        notesEditor.addFocusListener(new FocusAdapter()
        {
            @Override
            public void focusGained(FocusEvent e)
            {
                String note = notesEditor.getText();
                if(note.equals(autosaveMessage))
                {
                    notesEditor.setForeground(Color.WHITE);
                    notesEditor.setText("");
                }
            }

            @Override
            public void focusLost(FocusEvent e)
            {
                String note = notesEditor.getText();
                String playerName = opp_nameText.getText();

                //ensure we aren't saving this message as the note
                if(note.equals(autosaveMessage)) return;

                if(!note.isEmpty() && !playerName.isEmpty())
                {
                    sessionHandler.updateNote(playerName, note);
                    postSaveMsg("[+]BH Pages: Note for " + playerName + " has been updated.");
                }
            }
        });
        c.weightx = 1;
        c.gridwidth = 2;
        c.fill = GridBagConstraints.HORIZONTAL;
        c.gridx = 0;
        c.gridy = 2;
        add(notesEditor, c);

        //Display total combat level and combined levels on acc.
        totalPanel = new JPanel();
        totalPanel.setLayout(new GridLayout(1, 2));
        totalPanel.setBackground(ColorScheme.DARKER_GRAY_COLOR);

        totalPanel.add(makeHiscorePanel(null)); //combat has no hiscore skill, referred to as null
        totalPanel.add(makeHiscorePanel(OVERALL)); //total level holder

        c.weightx = 1;
        c.gridwidth = 2;
        c.fill = GridBagConstraints.HORIZONTAL;
        c.gridx = 0;
        c.gridy = 3;
        add(totalPanel, c);

        // Panel that holds skill icons
        statsPanel = new JPanel();
        statsPanel.setLayout(new GridLayout(8, 3));
        statsPanel.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        statsPanel.setBorder(new EmptyBorder(5, 0, 5, 0));

        // For each skill on the ingame skill panel, create a Label and add it to the UI
        for (HiscoreSkill skill : SKILLS)
        {
            JPanel panel = makeHiscorePanel(skill);
            statsPanel.add(panel);
        }

        c.weightx = 1;
        c.gridwidth = 2;
        c.fill = GridBagConstraints.HORIZONTAL;
        c.gridx = 0;
        c.gridy = 4;
        add(statsPanel, c);

        //Can use a Surge pot?
        surgePot = new JLabel("Can use Surge Potion?");
        c.weightx = 1;
        c.gridwidth = 1;
        c.fill = GridBagConstraints.HORIZONTAL;
        c.gridx = 0;
        c.gridy = 5;
        add(surgePot, c);

        //I draw all assets on screen with only dash visible on default state
        //easier to turn on and off with setVisible() true/false later on when lookup() runs.
        surgeDash = new JLabel("-", JLabel.CENTER);
        surgeDash.setForeground(Color.white);
        c.weightx = 1;
        c.gridwidth = 1;
        c.fill = GridBagConstraints.HORIZONTAL;
        c.gridx = 1;
        c.gridy = 5;
        add(surgeDash, c);

        surgeNo = new JLabel("No", JLabel.CENTER);
        surgeNo.setForeground(Color.red);
        surgeNo.setVisible(false);
        c.weightx = 1;
        c.gridwidth = 1;
        c.fill = GridBagConstraints.HORIZONTAL;
        c.gridx = 1;
        c.gridy = 5;
        add(surgeNo, c);

        surgeYes = new JLabel("Yes", JLabel.CENTER);
        surgeYes.setForeground(Color.green);
        surgeYes.setVisible(false);
        c.weightx = 1;
        c.gridwidth = 1;
        c.fill = GridBagConstraints.HORIZONTAL;
        c.gridx = 1;
        c.gridy = 5;
        add(surgeYes, c);

        //panel to display LMS, BH Rouge (nontarget) & BH Hunter (target)
        minigamePanel = new JPanel();
        minigamePanel.setLayout(new GridLayout(0, 3));
        minigamePanel.setBackground(ColorScheme.DARKER_GRAY_COLOR);

        minigamePanel.add(makeHiscorePanel(LAST_MAN_STANDING));
        minigamePanel.add(makeHiscorePanel(BOUNTY_HUNTER_ROGUE));
        minigamePanel.add(makeHiscorePanel(BOUNTY_HUNTER_HUNTER));

        c.weightx = 1;
        c.gridwidth = 2;
        c.fill = GridBagConstraints.HORIZONTAL;
        c.gridx = 0;
        c.gridy = 6;
        add(minigamePanel, c);

        bosskcPanel = new JPanel();
        bosskcPanel.setLayout(new GridLayout(0, 3));
        bosskcPanel.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        bosskcPanel.setVisible(false); // set to invisible unless config changed.

        // For each boss on the ingame boss panel, create a Label and add it to the UI
        for (HiscoreSkill skill : BOSSES)
        {
            JPanel panel = makeHiscorePanel(skill);
            bosskcPanel.add(panel);
        }

        c.weightx = 1;
        c.gridwidth = 2;
        c.fill = GridBagConstraints.HORIZONTAL;
        c.gridx = 0;
        c.gridy = 7;
        add(bosskcPanel, c);


        addInputKeyListener(nameAutocompleter);
    }

    void shutdown()
    {
        removeInputKeyListener(nameAutocompleter);
    }
//asset functions

    public void lookup(String username)
    {
        opp_nameText.setText(username); //set the username in cases where playername is from BH chat message

        String cleanUsername = sanitize(username); //sanitize bad characters from the name before note search
        String note = sessionHandler.getNoteForPlayer(cleanUsername);
        if(note.isEmpty())
        {
            notesEditor.setForeground(Color.GRAY);
            notesEditor.setText(autosaveMessage);
        }
        else
        {
            notesEditor.setForeground(Color.WHITE);
            notesEditor.setText(note);
        }
        lookup();
    }

    private void lookup()
    {
        final String lookup = sanitize(opp_nameText.getText());

        if(Strings.isNullOrEmpty(lookup))
        {
            return;
        }

        if(lookup.length() > MAX_USERNAME_LENGTH)
        {
            opp_nameText.setIcon(IconTextField.Icon.ERROR);
            loading = false;
            return;
        }

        repaint();

        opp_nameText.setEditable(false);
        opp_nameText.setIcon(IconTextField.Icon.LOADING_DARKER);
        loading = true;

        for (Map.Entry<HiscoreSkill, JLabel> entry : skillLabels.entrySet())
        {
            HiscoreSkill skill = entry.getKey();
            JLabel label = entry.getValue();
            HiscoreSkillType skillType = skill == null ? HiscoreSkillType.SKILL : skill.getType();

            label.setText(pad("--", skillType));
            label.setToolTipText(skill == null ? "Combat" : skill.getName());
        }

        //set endpoint to normal (change later?)
        selectedEndPoint = HiscoreEndpoint.NORMAL;

        hiscoreClient.lookupAsync(lookup, selectedEndPoint).whenCompleteAsync((result, ex) ->
                SwingUtilities.invokeLater(() ->
                {
                    if (!sanitize(opp_nameText.getText()).equals(lookup))
                    {
                        // search has changed in the meantime
                        return;
                    }

                    if (result == null || ex != null)
                    {
                        if (ex != null)
                        {
                            postSaveMsg("Error fetching Hiscore data " + ex.getMessage());
                        }

                        opp_nameText.setIcon(IconTextField.Icon.ERROR);
                        opp_nameText.setEditable(true);
                        loading = false;
                        return;
                    }

                    //successful player search
                    opp_nameText.setIcon(IconTextField.Icon.SEARCH);
                    opp_nameText.setEditable(true);
                    loading = false;

                    applyHiscoreResult(result);
                }));

    }

    private void applyHiscoreResult(HiscoreResult result)
    {
        assert SwingUtilities.isEventDispatchThread();
        repaint();

        nameAutocompleter.addToSearchHistory(result.getPlayer().toLowerCase());

        for (Map.Entry<HiscoreSkill, JLabel> entry : skillLabels.entrySet())
        {
            HiscoreSkill skill = entry.getKey();
            JLabel label = entry.getValue();
            Skill s;

            if (skill == null)
            {
                if (result.getPlayer() != null)
                {
                    int combatLevel = Experience.getCombatLevel(
                            result.getSkill(ATTACK).getLevel(),
                            result.getSkill(STRENGTH).getLevel(),
                            result.getSkill(DEFENCE).getLevel(),
                            result.getSkill(HITPOINTS).getLevel(),
                            result.getSkill(MAGIC).getLevel(),
                            result.getSkill(RANGED).getLevel(),
                            result.getSkill(PRAYER).getLevel()
                    );
                    label.setText(Integer.toString(combatLevel));
                }
            }
            else if ((s = result.getSkill(skill)) != null)
            {
                final long exp = s.getExperience();
                final boolean isSkill = skill.getType() == HiscoreSkillType.SKILL;
                int level = -1;

                if(result.getSkill(HERBLORE).getLevel() >= 81)
                {
                    surgeDash.setVisible(false);
                    surgeNo.setVisible(false);
                    surgeYes.setVisible(true);
                }
                else
                {
                    surgeDash.setVisible(false);
                    surgeYes.setVisible(false);
                    surgeNo.setVisible(true);
                }

                if (BHPconfig.virtualLevels() && isSkill && exp > -1L)
                {
                    level = Experience.getLevelForXp((int) exp);
                }
                else if (!isSkill || exp != -1L)
                {
                    // for skills, level is only valid if exp is not -1
                    // otherwise level is always valid
                    level = s.getLevel();
                }

                if (level != -1)
                {
                    label.setText(pad(formatLevel(level), skill.getType()));
                }
            }

            label.setToolTipText(detailsHtml(result, skill));
        }
    }

    private JPanel makeHiscorePanel(HiscoreSkill skill)
    {
        HiscoreSkillType skillType = skill == null ? HiscoreSkillType.SKILL : skill.getType();

        JLabel label = new JLabel();
        label.setToolTipText(skill == null ? "Combat" : skill.getName());
        label.setFont(FontManager.getRunescapeSmallFont());
        label.setText(pad("--", skillType));

        spriteManager.getSpriteAsync(skill == null ? TAB_COMBAT : skill.getSpriteId(), 0, (sprite) ->
                SwingUtilities.invokeLater(() ->
                {
                    // Icons are all 25x25 or smaller, so they're fit into a 25x25 canvas to give them a consistent size for
                    // better alignment. Further, they are then scaled down to 20x20 to not be overly large in the panel.
                    final BufferedImage scaledSprite = ImageUtil.resizeImage(ImageUtil.resizeCanvas(sprite, 25, 25), 20, 20);
                    label.setIcon(new ImageIcon(scaledSprite));
                }));

        boolean totalLabel = skill == OVERALL || skill == null; //overall or combat
        label.setIconTextGap(totalLabel ? 10 : 4);

        JPanel skillPanel = new JPanel();
        skillPanel.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        skillPanel.setBorder(new EmptyBorder(2, 0, 2, 0));
        skillLabels.put(skill, label);
        skillPanel.add(label);

        return skillPanel;
    }

    void addInputKeyListener(KeyListener l)
    {
        this.opp_nameText.addKeyListener(l);
    }

    void removeInputKeyListener(KeyListener l)
    {
        this.opp_nameText.removeKeyListener(l);
    }

    private String detailsHtml(HiscoreResult result, HiscoreSkill skill)
    {
        String openingTags = "<html><body style = 'padding: 5px;color:#989898'>";
        String closingTags = "</html><body>";

        String content = "";

        if (skill == null)
        {
            double combatLevel = Experience.getCombatLevelPrecise(
                    result.getSkill(ATTACK).getLevel(),
                    result.getSkill(STRENGTH).getLevel(),
                    result.getSkill(DEFENCE).getLevel(),
                    result.getSkill(HITPOINTS).getLevel(),
                    result.getSkill(MAGIC).getLevel(),
                    result.getSkill(RANGED).getLevel(),
                    result.getSkill(PRAYER).getLevel()
            );

            double combatExperience = result.getSkill(ATTACK).getExperience()
                    + result.getSkill(STRENGTH).getExperience() + result.getSkill(DEFENCE).getExperience()
                    + result.getSkill(HITPOINTS).getExperience() + result.getSkill(MAGIC).getExperience()
                    + result.getSkill(RANGED).getExperience() + result.getSkill(PRAYER).getExperience();

            content += "<p><span style = 'color:white'>Combat</span></p>";
            content += "<p><span style = 'color:white'>Exact Combat Level:</span> " + QuantityFormatter.formatNumber(combatLevel) + "</p>";
            content += "<p><span style = 'color:white'>Experience:</span> " + QuantityFormatter.formatNumber(combatExperience) + "</p>";
        }
        else
        {
            switch (skill)
            {
                case CLUE_SCROLL_ALL:
                {
                    content += "<p><span style = 'color:white'>Clues</span></p>";
                    content += buildClueLine(result, "All", CLUE_SCROLL_ALL);
                    content += buildClueLine(result, "Beginner", CLUE_SCROLL_BEGINNER);
                    content += buildClueLine(result, "Easy", CLUE_SCROLL_EASY);
                    content += buildClueLine(result, "Medium", CLUE_SCROLL_MEDIUM);
                    content += buildClueLine(result, "Hard", CLUE_SCROLL_HARD);
                    content += buildClueLine(result, "Elite", CLUE_SCROLL_ELITE);
                    content += buildClueLine(result, "Master", CLUE_SCROLL_MASTER);
                    break;
                }
                case BOUNTY_HUNTER_ROGUE:
                case BOUNTY_HUNTER_HUNTER:
                case PVP_ARENA_RANK:
                case LAST_MAN_STANDING:
                case SOUL_WARS_ZEAL:
                case RIFTS_CLOSED:
                case COLOSSEUM_GLORY:
                case COLLECTIONS_LOGGED:
                {
                    content += buildMinigameTooltip(result.getSkill(skill), skill);
                    break;
                }
                case LEAGUE_POINTS:
                {
                    Skill leaguePoints = result.getSkill(LEAGUE_POINTS);
                    String rank = (leaguePoints.getRank() == -1) ? "Unranked" : QuantityFormatter.formatNumber(leaguePoints.getRank());
                    content += "<p><span style = 'color:white'>League Points</span></p>";
                    content += "<p><span style = 'color:white'>Rank:</span> " + rank + "</p>";
                    if (leaguePoints.getLevel() > -1)
                    {
                        content += "<p><span style = 'color:white'>Points:</span> " + QuantityFormatter.formatNumber(leaguePoints.getLevel()) + "</p>";
                    }
                    break;
                }
                case OVERALL:
                {
                    Skill requestedSkill = result.getSkill(skill);
                    String rank = (requestedSkill.getRank() == -1) ? "Unranked" : QuantityFormatter.formatNumber(requestedSkill.getRank());
                    String exp = (requestedSkill.getExperience() == -1L) ? "Unranked" : QuantityFormatter.formatNumber(requestedSkill.getExperience());
                    content += "<p><span style = 'color:white'>" + skill.getName() + "</span></p>";
                    content += "<p><span style = 'color:white'>Rank:</span> " + rank + "</p>";
                    content += "<p><span style = 'color:white'>Experience:</span> " + exp + "</p>";
                    break;
                }
                default:
                {
                    if (skill.getType() == HiscoreSkillType.BOSS)
                    {
                        String rank = "Unranked";
                        String lvl = null;
                        Skill requestedSkill = result.getSkill(skill);
                        if (requestedSkill != null)
                        {
                            if (requestedSkill.getRank() > -1)
                            {
                                rank = QuantityFormatter.formatNumber(requestedSkill.getRank());
                            }
                            if (requestedSkill.getLevel() > -1)
                            {
                                lvl = QuantityFormatter.formatNumber(requestedSkill.getLevel());
                            }
                        }

                        content += "<p><span style = 'color:white'>Boss:</span> " + skill.getName() + "</p>";
                        content += "<p><span style = 'color:white'>Rank:</span> " + rank + "</p>";
                        if (lvl != null)
                        {
                            content += "<p><span style = 'color:white'>KC:</span> " + lvl + "</p>";
                        }
                    }
                    else
                    {
                        Skill requestedSkill = result.getSkill(skill);
                        final long experience = requestedSkill.getExperience();

                        String rank = (requestedSkill.getRank() == -1) ? "Unranked" : QuantityFormatter.formatNumber(requestedSkill.getRank());
                        String exp = (experience == -1L) ? "Unranked" : QuantityFormatter.formatNumber(experience);
                        String remainingXp;
                        if (experience == -1L)
                        {
                            remainingXp = "Unranked";
                        }
                        else
                        {
                            int currentLevel = Experience.getLevelForXp((int) experience);
                            remainingXp = (currentLevel + 1 <= Experience.MAX_VIRT_LEVEL) ? QuantityFormatter.formatNumber(Experience.getXpForLevel(currentLevel + 1) - experience) : "0";
                        }

                        content += "<p><span style = 'color:white'>Skill:</span> " + skill.getName() + "</p>";
                        content += "<p><span style = 'color:white'>Rank:</span> " + rank + "</p>";
                        content += "<p><span style = 'color:white'>Experience:</span> " + exp + "</p>";
                        content += "<p><span style = 'color:white'>Remaining XP:</span> " + remainingXp + "</p>";
                    }
                    break;
                }
            }
        }

        // Add a html progress bar to the hover information
        if (skill != null && skill.getType() == HiscoreSkillType.SKILL)
        {
            long experience = result.getSkill(skill).getExperience();
            if (experience >= 0)
            {
                int currentXp = (int) experience;
                int currentLevel = Experience.getLevelForXp(currentXp);
                int xpForCurrentLevel = Experience.getXpForLevel(currentLevel);
                int xpForNextLevel = currentLevel + 1 <= Experience.MAX_VIRT_LEVEL ? Experience.getXpForLevel(currentLevel + 1) : -1;

                double xpGained = currentXp - xpForCurrentLevel;
                double xpGoal = xpForNextLevel != -1 ? xpForNextLevel - xpForCurrentLevel : 100;
                int progress = (int) ((xpGained / xpGoal) * 100f);

                // had to wrap the bar with an empty div, if i added the margin directly to the bar, it would mess up
                content += "<div style = 'margin-top:3px'>"
                        + "<div style = 'background: #070707; border: 1px solid #070707; height: 6px; width: 100%;'>"
                        + "<div style = 'height: 6px; width: " + progress + "%; background: #dc8a00;'>"
                        + "</div>"
                        + "</div>"
                        + "</div>";
            }
        }

        return openingTags + content + closingTags;
    }

    private static String buildMinigameTooltip(Skill s, HiscoreSkill hiscoreSkill)
    {
        String rank = (s.getRank() == -1) ? "Unranked" : QuantityFormatter.formatNumber(s.getRank());
        String content = "";
        content += "<p><span style = 'color:white'>" + hiscoreSkill.getName() + "</span></p>";
        content += "<p><span style = 'color:white'>Rank:</span> " + rank + "</p>";
        if (s.getLevel() > -1)
        {
            content += "<p><span style = 'color:white'>Score:</span> " + QuantityFormatter.formatNumber(s.getLevel()) + "</p>";
        }
        return content;
    }

    private static String buildClueLine(HiscoreResult result, String name, HiscoreSkill skill)
    {
        Skill sk = result.getSkill(skill);
        String count = sk.getLevel() == -1
                ? "0"
                : QuantityFormatter.formatNumber(sk.getLevel());
        String rank = sk.getRank() == -1
                ? "Unranked"
                : QuantityFormatter.formatNumber(sk.getRank());
        return "<p><span style = 'color:white'>" + name + ":</span> " + count + " <span style = 'color:white'>Rank:</span> " + rank + "</p>";
    }

    private static String sanitize(String lookup)
    {
        return lookup
                .replace('\u00A0', ' ');
    }

    @VisibleForTesting
    static String formatLevel(int level)
    {
        if (level < 10000)
        {
            return Integer.toString(level);
        }
        else
        {
            return (level / 1000) + "k";
        }
    }

    private static String pad(String str, HiscoreSkillType type)
    {
        // Left pad label text to keep labels aligned
        int pad = type == HiscoreSkillType.BOSS ? 4 : 2;
        return StringUtils.leftPad(str, pad);
    }


    private void postSaveMsg(String msg)
    {
        BHPplugin.chatGameMessage(msg);
    }

    public void showBossPanel(Boolean option)
    {
        if(option)
        {
            bosskcPanel.setVisible(true);
        }
        else
        {
            bosskcPanel.setVisible(false);
        }
    }

}

package com.BHPages;

import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.PluginPanel;
import net.runelite.client.ui.components.materialtabs.MaterialTab;
import net.runelite.client.ui.components.materialtabs.MaterialTabGroup;

import javax.swing.*;
import javax.swing.border.EmptyBorder;
import java.awt.*;
import javax.inject.Inject;

class BHP_PanelContainer extends PluginPanel
{
    private final JPanel BHP_Panel = new JPanel();

    private final MaterialTabGroup tabGroup = new MaterialTabGroup(BHP_Panel);
    private final MaterialTab historyTab;
    private final MaterialTab notesTab;


    private final BHP_NotesPanel notesPanel;
    //@Getter
    private final BHP_HistoryPanel historyPanel;

    @Inject
    private  BHP_PanelContainer(BHP_NotesPanel notesPanel, BHP_HistoryPanel historyPanel)
    {
        this.notesPanel = notesPanel;
        this.historyPanel = historyPanel;

        setLayout(new BorderLayout(0,0));

        setBackground(ColorScheme.DARK_GRAY_COLOR);

        notesTab = new MaterialTab("Notes", tabGroup, notesPanel);
        historyTab = new MaterialTab("History", tabGroup, historyPanel);

        tabGroup.setBorder(new EmptyBorder(10, 0, 0, 0));
        tabGroup.addTab(notesTab);
        tabGroup.addTab(historyTab);
        tabGroup.select(notesTab);

        add(tabGroup, BorderLayout.NORTH);
        add(BHP_Panel, BorderLayout.CENTER);
    }

    void showHistory()
    {
        if(historyPanel.isShowing())
        {
            return;
        }

        tabGroup.select(historyTab);
        revalidate();
    }

    void showNotes()
    {
        if(notesPanel.isShowing())
        {
            return;
        }

        tabGroup.select(notesTab);
        revalidate();
    }

    public BHP_NotesPanel getNotesPanel()
    {
        return notesPanel;
    }

    public BHP_HistoryPanel getHistoryPanel(){ return historyPanel; }

}

package com.BHPages;

import javax.inject.Inject;
import javax.inject.Provider;
import javax.swing.*;

import com.BHPages.session.SessionHandler;

import com.google.inject.Provides;
import lombok.extern.slf4j.Slf4j;

import net.runelite.api.Client;
import net.runelite.api.MenuAction;
import net.runelite.api.Player;
import net.runelite.api.events.ChatMessage;
import net.runelite.api.events.MenuEntryAdded;
import net.runelite.api.events.MenuOptionClicked;
import net.runelite.api.gameval.InterfaceID;
import net.runelite.api.widgets.WidgetUtil;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.eventbus.Subscribe;

import net.runelite.client.events.ConfigChanged;
import net.runelite.client.hiscore.HiscoreEndpoint;
import net.runelite.client.menus.MenuManager;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.plugins.PluginDescriptor;
import net.runelite.client.ui.ClientToolbar;
import net.runelite.client.ui.NavigationButton;
import net.runelite.client.util.ImageUtil;
import net.runelite.client.util.Text;

import java.text.SimpleDateFormat;
import java.util.Date;

import java.util.regex.Matcher;
import java.util.regex.Pattern;

import static net.runelite.api.ChatMessageType.GAMEMESSAGE;


@Slf4j
@PluginDescriptor(
		name = "BH Pages",
		description = "Keep track of your opponents in Bounty Hunter.",
		tags = {"Bounty", "Hunter", "bounty", "hunter", "BH", "bh", "pvp"}
)

public class BHP_Plugin extends Plugin {

	private static final String LOOKUP = "BH Lookup";

	@Inject
	private Client client;

	@Inject
	private Provider<MenuManager> menuManager;

	@Inject
	private ClientToolbar clientToolbar;

	@Inject
	private ClientThread clientThread;

	@Inject
	private BHP_Config config;

	@Inject
	private SessionHandler sessionHandler;

	private NavigationButton navButton;
	private BHP_NotesPanel BHPNotesPanel;
	private BHP_PanelContainer BHPPanelContainer;
	private BHP_HistoryPanel BHPHistoryPanel;

	//regex for opponent player name extraction (onChatMessage)
	private static final Pattern BOUNTY_PATTERN = Pattern.compile("You have been assigned a new target: <col=[0-9a-f]+>(.*)</col>");

	//to be used in a debug message to trigger plugin.
	//Openmessage + name + Closemessage
	//Regex matcher for command in chat
	private final String gamemessagePlayerOpenString = "You have been assigned a new target: <col=e00a19>";
	private final String getGamemessagePlayerCloseString = "</col>";
	private static final Pattern BHPAGES_DEBUG_CMD = Pattern.compile("^!Bhpages\\s+([A-Za-z0-9 ]{1,12})$");

	@Provides
	BHP_Config provideConfig(ConfigManager configManager)
	{
		return configManager.getConfig(BHP_Config.class);
	}

	@Override
	protected void startUp() throws Exception
	{
		BHPPanelContainer = injector.getInstance(BHP_PanelContainer.class);
		BHPNotesPanel = BHPPanelContainer.getNotesPanel();
		BHPHistoryPanel = BHPPanelContainer.getHistoryPanel();

		navButton = NavigationButton.builder()
				.tooltip("BH Pages")
				.icon(ImageUtil.loadImageResource(getClass(), "/BHP_Panel_Icon.png"))
				.priority(99)
				.panel(BHPPanelContainer)
				.build();

		clientToolbar.addNavigation(navButton);

		if (config.playerOption())
		{
			menuManager.get().addPlayerMenuItem(LOOKUP);
		}

		sessionHandler.loadNotes();
	}

	@Override
	protected void shutDown() throws Exception {

		sessionHandler.saveNotes();
		BHPNotesPanel.shutdown();
		clientToolbar.removeNavigation(navButton);
		menuManager.get().removePlayerMenuItem(LOOKUP);

	}

	@Subscribe
	public void onConfigChanged(ConfigChanged event)
	{
		if (event.getGroup().equals("BH Pages"))
		{
			//remove these options to avoid duplicates
			menuManager.get().removePlayerMenuItem(LOOKUP);

			if (config.playerOption())
			{
				menuManager.get().addPlayerMenuItem(LOOKUP);
			}

			if(config.bossPanel())
			{
				BHPNotesPanel.showBossPanel(true);
			}
			else
			{
				BHPNotesPanel.showBossPanel(false);
			}
		}
	}

	@Subscribe
	public void onMenuEntryAdded(MenuEntryAdded event)
	{
		if ((event.getType() != MenuAction.CC_OP.getId() && event.getType() != MenuAction.CC_OP_LOW_PRIORITY.getId()) || !config.playerOption())
		{
			return;
		}

		final String option = event.getOption();
		final int componentId = event.getActionParam1();
		final int groupId = WidgetUtil.componentToInterface(componentId);

		if (groupId == InterfaceID.FRIENDS && option.equals("Delete")
				|| groupId == InterfaceID.CHATCHANNEL_CURRENT && (option.equals("Add ignore") || option.equals("Remove friend"))
				|| groupId == InterfaceID.CHATBOX && (option.equals("Add ignore") || option.equals("Message"))
				|| groupId == InterfaceID.IGNORE && option.equals("Delete")
				|| (componentId == InterfaceID.ClansSidepanel.PLAYERLIST || componentId == InterfaceID.ClansGuestSidepanel.PLAYERLIST) && (option.equals("Add ignore") || option.equals("Remove friend"))
				|| groupId == InterfaceID.PM_CHAT && (option.equals("Add ignore") || option.equals("Message"))
				|| groupId == InterfaceID.GIM_SIDEPANEL && (option.equals("Add friend") || option.equals("Remove friend") || option.equals("Remove ignore"))
		)
		{
			client.createMenuEntry(-2)
					.setOption(LOOKUP)
					.setTarget(event.getTarget())
					.setType(MenuAction.RUNELITE)
					.setIdentifier(event.getIdentifier())
					.onClick(e ->
					{
						String target = Text.removeTags(e.getTarget());
						if(target.isEmpty())
						{
							return;
						}

						lookupPlayerName(target, "");

					});
		}
	}

	@Subscribe
	public void onMenuOptionClicked(MenuOptionClicked event)
	{
		if (event.getMenuAction() == MenuAction.RUNELITE_PLAYER && event.getMenuOption().equals(LOOKUP))
		{
			Player player = event.getMenuEntry().getPlayer();
			if (player == null)
			{
				return;
			}

			String target = player.getName();
			
			lookupPlayerName(target, ""); //blank datetime to ensure history is NOT added.
		}
	}

	@Subscribe(priority = -2) // run after ChatMessageManager
	public void onChatMessage(ChatMessage chatMessage)
	{
		if (chatMessage.getType() == GAMEMESSAGE)
		{
			String date_t = getCurrentTimestamp();
			String message = chatMessage.getMessage();
			Matcher match = BOUNTY_PATTERN.matcher(message);
			if (match.matches())
			{
				lookupPlayerName(match.group(1), date_t);
			}
		}

	}

	void lookupPlayerName(String playerName, String datetime)
	{
		SwingUtilities.invokeLater(() ->
		{
			clientToolbar.openPanel(navButton);
			BHPPanelContainer.showNotes();
			BHPNotesPanel.lookup(playerName);
			BHPHistoryPanel.addHistoryTile(playerName, datetime);
		});
	}

	HiscoreEndpoint getWorldEndpoint()
	{
		return HiscoreEndpoint.fromWorldTypes(client.getWorldType());
	}

	void chatGameMessage(String message) //function without
	{
		clientThread.invokeLater(() ->
		{
			client.addChatMessage(GAMEMESSAGE, "", message, null);
		});

	}



	private String getCurrentTimestamp()
	{
		String format = "MMM/dd HH:mm";
		SimpleDateFormat dateFormat = new SimpleDateFormat(format);
		return dateFormat.format(new Date());
	}
}
package com.BHPages;

import com.BHPages.session.IconHandler;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.util.ImageUtil;

import javax.swing.*;
import javax.swing.border.EmptyBorder;
import javax.swing.border.MatteBorder;
import java.awt.*;
import java.util.function.Consumer;

public class historyTilePanel extends JPanel
{

    private final JPanel topLine;
    private final JPanel controlLine;
    private final JLabel playerName;
    private final JLabel dateTime;
    private final JButton lookupButton;

    private static final ImageIcon EYE_ICON;

    static
    {
        EYE_ICON = IconHandler.EYEICON.getIcon(img -> ImageUtil.resizeImage(img, 16, 16));
    }


    historyTilePanel(String name, String date, Consumer<String> onLookup)
    {
        setLayout(new BorderLayout());
        setBorder(new EmptyBorder(3, 2, 3, 2));

        topLine = new JPanel(new BorderLayout());
        topLine.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        topLine.setBorder(new EmptyBorder(2, 4, 1, 4));
        add(topLine, BorderLayout.NORTH);

        playerName = new JLabel(name);
        playerName.setForeground(Color.WHITE);
        playerName.setFont(playerName.getFont().deriveFont(Font.BOLD));
        topLine.add(playerName, BorderLayout.WEST);

        controlLine = new JPanel(new BorderLayout());
        controlLine.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        controlLine.setBorder(new MatteBorder(1, 0, 0, 0, ColorScheme.DARK_GRAY_COLOR));
        add(controlLine, BorderLayout.SOUTH);

        lookupButton = new JButton();
        lookupButton.setIcon(EYE_ICON);
        lookupButton.setPreferredSize(new Dimension(22, 22));
        lookupButton.setToolTipText("Lookup player in Notes tab");
        lookupButton.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        lookupButton.setFocusable(false);
        lookupButton.setBorderPainted(false);
        lookupButton.setContentAreaFilled(false);
        lookupButton.setOpaque(false);
        lookupButton.addActionListener(e ->
                SwingUtilities.invokeLater(() -> onLookup.accept(name))
        );

        controlLine.add(lookupButton, BorderLayout.WEST);

        dateTime = new JLabel("Last Seen: " + date);
        dateTime.setForeground(Color.LIGHT_GRAY);
        controlLine.add(dateTime, BorderLayout.EAST);
    }

}

package com.BHPages.session;

import com.BHPages.BHP_Plugin;
import net.runelite.client.util.ImageUtil;

import javax.annotation.Nonnull;
import javax.swing.*;
import java.awt.image.BufferedImage;
import java.util.function.UnaryOperator;

public enum IconHandler
{
    CHANGELOG("/changelog.png"),
    GITHUB("/github.png"),
    DISCORD("/discord.png"),
    DONATORADDR("/bitcoin_clear.png"),
    EYEICON("/eye_icon.png");

    private final String file;

    IconHandler(String file)
    {
        this.file = file;
    }

    public BufferedImage getImage()
    {
        return ImageUtil.loadImageResource(BHP_Plugin.class, file);
    }

    public ImageIcon getIcon()
    {
        return getIcon(UnaryOperator.identity());
    }

    public ImageIcon getIcon(@Nonnull UnaryOperator<BufferedImage> func)
    {
        BufferedImage img = func.apply(getImage());
        return new ImageIcon(img);
    }
}

package com.BHPages.session;

import com.google.gson.Gson;
import com.google.gson.reflect.TypeToken;
import net.runelite.client.RuneLite;

import javax.inject.Inject;
import java.io.*;
import java.lang.reflect.Type;
import java.nio.charset.StandardCharsets;
import java.util.HashMap;
import java.util.Map;

public class SessionHandler
{
    private static final String FILE_NAME = "player_notes.json";
    private final File notesFile;
    private final Gson gson;
    private Map<String, String> playerNotes = new HashMap<>();

    @Inject
    public SessionHandler(Gson gson)
    {
        this.gson = gson;

        File pluginDir = new File(RuneLite.RUNELITE_DIR, "bhpages");
        if (!pluginDir.exists())
        {
            pluginDir.mkdirs();
        }

        this.notesFile = new File(pluginDir, FILE_NAME);
        loadNotes(); // Load on init
    }

    public void loadNotes()
    {
        if (!notesFile.exists()) return;

        try (Reader reader = new InputStreamReader(new FileInputStream(notesFile), StandardCharsets.UTF_8))
        {
            Type type = new TypeToken<Map<String, String>>() {}.getType();
            Map<String, String> rawNotes = gson.fromJson(reader, type);

            boolean changed = false;
            Map<String, String> cleaned = new HashMap<>();

            for (Map.Entry<String, String> entry : rawNotes.entrySet())
            {
                String rawName = entry.getKey();
                String rawNote = entry.getValue();

                String cleanName = sanitize(rawName);
                String cleanNote = sanitizeNote(rawNote);

                if (cleaned.containsKey(cleanName))
                {
                    String existingNote = cleaned.get(cleanName);

                    // Merge if note is different and not already part of the current one
                    if (!existingNote.equals(cleanNote) && !cleanNote.isEmpty())
                    {
                        if (!existingNote.toLowerCase().contains(cleanNote.toLowerCase()))
                        {
                            String mergedNote = existingNote + " --- " + cleanNote;
                            cleaned.put(cleanName, mergedNote);
                            changed = true;
                        }
                    }
                }
                else
                {
                    cleaned.put(cleanName, cleanNote);
                    if (!cleanName.equals(rawName) || !cleanNote.equals(rawNote))
                    {
                        changed = true;
                    }
                }
            }

            this.playerNotes = cleaned;

            if (changed)
            {
                saveNotes(); // Re-save fixed file
            }
        }
        catch (IOException e)
        {
            e.printStackTrace();
        }
    }


    public void saveNotes()
    {
        try (Writer writer = new OutputStreamWriter(new FileOutputStream(notesFile), StandardCharsets.UTF_8))
        {
            gson.toJson(playerNotes, writer);
        }
        catch (IOException e)
        {
            e.printStackTrace();
        }
    }

    public Map<String, String> getAllNotes()
    {
        return new HashMap<>(playerNotes);
    }

    public String getNoteForPlayer(String playerName)
    {
        return playerNotes.getOrDefault(playerName, "");
    }

    private String sanitize(String input)
    {
        if (input == null)
        {
            return "";
        }

        return input
                .replace('\uFFFD', ' ')             // Replace the replacement character with a space
                .replace('\u00A0', ' ')             // Replace non-breaking spaces with regular space
                .replaceAll("[^-A-Za-z0-9_ ]", "")     // Keep "-" char, A-Z, a-z, 0-9, underscore and spaces only
                .replaceAll("\\s{2,}", " ")          // Collapse multiple spaces into a single space
                .trim();
    }

    private String sanitizeNote(String note)
    {
        if (note == null)
        {
            return "";
        }

        return note
                .replace('\u00A0', ' ')   // Replace non-breaking space
                .replaceAll("[\\p{C}&&[^\\n\\t]]", "") // Remove control characters
                //.replaceAll("\\p{C}", "") // Remove control characters
                .trim();
    }


    public void updateNote(String playerName, String note)
    {
        playerName = sanitize(playerName);
        note = sanitizeNote(note);

        if (note.isEmpty())
        {
            playerNotes.remove(playerName);
        }
        else
        {
            playerNotes.put(playerName, note);
        }

        saveNotes();
    }

}

package com.BHPages;

import net.runelite.client.RuneLite;
import net.runelite.client.externalplugins.ExternalPluginManager;

public class BHP_PluginTest
{
	public static void main(String[] args) throws Exception
	{
		ExternalPluginManager.loadBuiltin(BHP_Plugin.class);
		RuneLite.main(args);
	}
}
