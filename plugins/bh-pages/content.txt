package com.BHPages.session;

import com.google.gson.Gson;
import com.google.gson.reflect.TypeToken;
import net.runelite.client.RuneLite;

import javax.inject.Inject;
import java.io.*;
import java.lang.reflect.Type;
import java.nio.charset.StandardCharsets;
import java.util.HashMap;
import java.util.Map;

public class SessionHandler
{
    private static final String FILE_NAME = "player_notes.json";
    private final File notesFile;
    private final Gson gson;
    private Map<String, String> playerNotes = new HashMap<>();

    @Inject
    public SessionHandler(Gson gson)
    {
        this.gson = gson;

        File pluginDir = new File(RuneLite.RUNELITE_DIR, "bhpages");
        if (!pluginDir.exists())
        {
            pluginDir.mkdirs();
        }

        this.notesFile = new File(pluginDir, FILE_NAME);
        loadNotes(); // Load on init
    }

    public void loadNotes()
    {
        if (!notesFile.exists()) return;

        try (Reader reader = new InputStreamReader(new FileInputStream(notesFile), StandardCharsets.UTF_8))
        {
            Type type = new TypeToken<Map<String, String>>() {}.getType();
            Map<String, String> rawNotes = gson.fromJson(reader, type);

            boolean changed = false;
            Map<String, String> cleaned = new HashMap<>();

            for (Map.Entry<String, String> entry : rawNotes.entrySet())
            {
                String rawName = entry.getKey();
                String rawNote = entry.getValue();

                String cleanName = sanitize(rawName);
                String cleanNote = sanitizeNote(rawNote);

                if (cleaned.containsKey(cleanName))
                {
                    String existingNote = cleaned.get(cleanName);

                    // Merge if note is different and not already part of the current one
                    if (!existingNote.equals(cleanNote) && !cleanNote.isEmpty())
                    {
                        if (!existingNote.toLowerCase().contains(cleanNote.toLowerCase()))
                        {
                            String mergedNote = existingNote + " --- " + cleanNote;
                            cleaned.put(cleanName, mergedNote);
                            changed = true;
                        }
                    }
                }
                else
                {
                    cleaned.put(cleanName, cleanNote);
                    if (!cleanName.equals(rawName) || !cleanNote.equals(rawNote))
                    {
                        changed = true;
                    }
                }
            }

            this.playerNotes = cleaned;

            if (changed)
            {
                saveNotes(); // Re-save fixed file
            }
        }
        catch (IOException e)
        {
            e.printStackTrace();
        }
    }


    public void saveNotes()
    {
        try (Writer writer = new OutputStreamWriter(new FileOutputStream(notesFile), StandardCharsets.UTF_8))
        {
            gson.toJson(playerNotes, writer);
        }
        catch (IOException e)
        {
            e.printStackTrace();
        }
    }

    public Map<String, String> getAllNotes()
    {
        return new HashMap<>(playerNotes);
    }

    public String getNoteForPlayer(String playerName)
    {
        return playerNotes.getOrDefault(playerName, "");
    }

    private String sanitize(String input)
    {
        if (input == null)
        {
            return "";
        }

        return input
                .replace('\uFFFD', ' ')             // Replace the replacement character with a space
                .replace('\u00A0', ' ')             // Replace non-breaking spaces with regular space
                .replaceAll("[^A-Za-z0-9 ]", "")     // Keep A-Z, a-z, 0-9, and spaces only
                .replaceAll("\\s{2,}", " ")          // Collapse multiple spaces into a single space
                .trim();
    }

    private String sanitizeNote(String note)
    {
        if (note == null)
        {
            return "";
        }

        return note
                .replace('\u00A0', ' ')   // Replace non-breaking space
                .replaceAll("\\p{C}", "") // Remove control characters
                .trim();
    }


    public void updateNote(String playerName, String note)
    {
        playerName = sanitize(playerName);
        note = sanitizeNote(note);

        if (note.isEmpty())
        {
            playerNotes.remove(playerName);
        }
        else
        {
            playerNotes.put(playerName, note);
        }

        saveNotes();
    }

}

/*
 * Copyright (c) 2018, John Pettenger
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

//thanks & credits to hiscores plugin!
package com.BHPages;

import com.google.common.collect.EvictingQueue;
import com.google.inject.Inject;
import java.awt.event.KeyEvent;
import java.awt.event.KeyListener;
import java.util.Arrays;
import java.util.Objects;
import java.util.Optional;
import java.util.regex.Pattern;
import javax.inject.Singleton;
import javax.swing.SwingUtilities;
import javax.swing.text.BadLocationException;
import javax.swing.text.Document;
import javax.swing.text.JTextComponent;
import lombok.NonNull;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.Friend;
import net.runelite.api.FriendsChatManager;
import net.runelite.api.Nameable;
import net.runelite.api.NameableContainer;
import net.runelite.api.Player;
import net.runelite.api.WorldView;
import net.runelite.api.clan.ClanID;
import net.runelite.api.clan.ClanMember;
import net.runelite.api.clan.ClanSettings;

@Slf4j
@Singleton
class NameAutocompleter implements KeyListener
{
    /**
     * Non-breaking space character.
     */
    private static final String NBSP = Character.toString((char)160);

    /**
     * Character class for characters that cannot be in an RSN.
     */
    private static final Pattern INVALID_CHARS = Pattern.compile("[^a-zA-Z0-9_ -]");

    private static final int MAX_SEARCH_HISTORY = 25;

    private final Client client;
    //private final HiscoreConfig hiscoreConfig;
    private final BHP_Config BHPconfig;

    private final EvictingQueue<String> searchHistory = EvictingQueue.create(MAX_SEARCH_HISTORY);

    /**
     * The name currently being autocompleted.
     */
    private String autocompleteName;

    /**
     * Pattern for the name currently being autocompleted.
     */
    private Pattern autocompleteNamePattern;

    @Inject
    private NameAutocompleter(Client client, BHP_Config config)
    {
        this.client = client;
        this.BHPconfig = config;
    }

    @Override
    public void keyPressed(KeyEvent e)
    {

    }

    @Override
    public void keyReleased(KeyEvent e)
    {

    }

    @Override
    public void keyTyped(KeyEvent e)
    {
        if (!BHPconfig.autocomplete())
        {
            return;
        }

        final JTextComponent input = (JTextComponent)e.getSource();
        final String inputText = input.getText();

        // Only autocomplete if the selection end is at the end of the text.
        if (input.getSelectionEnd() != inputText.length())
        {
            return;
        }

        // Character to be inserted at the selection start.
        final String charToInsert = Character.toString(e.getKeyChar());

        // Don't attempt to autocomplete if the name is invalid.
        // This condition is also true when the user presses a key like backspace.
        if (INVALID_CHARS.matcher(charToInsert).find()
                || INVALID_CHARS.matcher(inputText).find())
        {
            return;
        }

        // Check if we are already autocompleting.
        if (autocompleteName != null && autocompleteNamePattern.matcher(inputText).matches())
        {
            if (isExpectedNext(input, charToInsert))
            {
                try
                {
                    // Insert the character and move the selection.
                    final int insertIndex = input.getSelectionStart();
                    Document doc = input.getDocument();
                    doc.remove(insertIndex, 1);
                    doc.insertString(insertIndex, charToInsert, null);
                    input.select(insertIndex + 1, input.getSelectionEnd());
                }
                catch (BadLocationException ex)
                {
                    log.warn("Could not insert character.", ex);
                }

                // Prevent default behavior.
                e.consume();
            }
            else // Character to insert does not match current autocompletion. Look for another name.
            {
                newAutocomplete(e);
            }
        }
        else // Search for a name to autocomplete
        {
            newAutocomplete(e);
        }
    }

    private void newAutocomplete(KeyEvent e)
    {
        final JTextComponent input = (JTextComponent)e.getSource();
        final String inputText = input.getText();
        final String nameStart = inputText.substring(0, input.getSelectionStart()) + e.getKeyChar();

        if (findAutocompleteName(nameStart))
        {
            // Assert this.autocompleteName != null
            final String name = this.autocompleteName;
            SwingUtilities.invokeLater(() ->
            {
                try
                {
                    input.getDocument().insertString(
                            nameStart.length(),
                            name.substring(nameStart.length()),
                            null);
                    input.select(nameStart.length(), name.length());
                }
                catch (BadLocationException ex)
                {
                    log.warn("Could not autocomplete name.", ex);
                }
            });
        }
    }

    private boolean findAutocompleteName(String nameStart)
    {
        final Pattern pattern;
        Optional<String> autocompleteName;

        // Pattern to match names that start with nameStart.
        // Allows spaces to be represented as common whitespaces, underscores,
        // hyphens, or non-breaking spaces.
        // Matching non-breaking spaces is necessary because the API
        // returns non-breaking spaces when a name has whitespace.
        pattern = Pattern.compile(
                "(?i)^" + nameStart.replaceAll("[ _-]", "[ _" + NBSP + "-]") + ".+?");

        // Search all previous successful queries
        autocompleteName = searchHistory.stream()
                .filter(n -> pattern.matcher(n).matches())
                .findFirst();

        // Search friends if previous searches weren't matched
        if (!autocompleteName.isPresent())
        {
            NameableContainer<Friend> friendContainer = client.getFriendContainer();
            if (friendContainer != null)
            {
                autocompleteName = Arrays.stream(friendContainer.getMembers())
                        .map(Nameable::getName)
                        .filter(n -> pattern.matcher(n).matches())
                        .findFirst();
            }
        }

        // Search friends chat if a friend wasn't found
        if (!autocompleteName.isPresent())
        {
            final FriendsChatManager friendsChatManager = client.getFriendsChatManager();
            if (friendsChatManager != null)
            {
                autocompleteName = Arrays.stream(friendsChatManager.getMembers())
                        .map(Nameable::getName)
                        .filter(n -> pattern.matcher(n).matches())
                        .findFirst();
            }
        }

        // Search clans
        if (!autocompleteName.isPresent())
        {
            final ClanSettings[] clanSettings = {
                    client.getClanSettings(ClanID.CLAN),
                    client.getClanSettings(ClanID.GROUP_IRONMAN),
                    client.getGuestClanSettings()
            };
            autocompleteName = Arrays.stream(clanSettings)
                    .filter(Objects::nonNull)
                    .flatMap(cs -> cs.getMembers().stream())
                    .map(ClanMember::getName)
                    .filter(n -> pattern.matcher(n).matches())
                    .findFirst();
        }

        // Search cached players if a friend wasn't found
        if (!autocompleteName.isPresent())
        {
            WorldView wv = client.getTopLevelWorldView();
            autocompleteName = wv.players().stream()
                    .filter(Objects::nonNull)
                    .map(Player::getName)
                    .filter(Objects::nonNull)
                    .filter(n -> pattern.matcher(n).matches())
                    .findFirst();
        }

        if (autocompleteName.isPresent())
        {
            this.autocompleteName = autocompleteName.get().replace(NBSP, " ");
            this.autocompleteNamePattern = Pattern.compile(
                    "(?i)^" + this.autocompleteName.replaceAll("[ _-]", "[ _-]") + "$");
        }
        else
        {
            this.autocompleteName = null;
            this.autocompleteNamePattern = null;
        }

        return autocompleteName.isPresent();
    }

    void addToSearchHistory(@NonNull String name)
    {
        if (!searchHistory.contains(name))
        {
            searchHistory.offer(name);
        }
    }

    private boolean isExpectedNext(JTextComponent input, String nextChar)
    {
        String expected;
        if (input.getSelectionStart() < input.getSelectionEnd())
        {
            try
            {
                expected = input.getText(input.getSelectionStart(), 1);
            }
            catch (BadLocationException ex)
            {
                log.warn("Could not get first character from input selection.", ex);
                return false;
            }
        }
        else
        {
            expected = "";
        }
        return nextChar.equalsIgnoreCase(expected);
    }
}
package com.BHPages;

import javax.inject.Inject;
import javax.inject.Singleton;
import javax.swing.*;
import javax.swing.border.EmptyBorder;

import com.BHPages.session.SessionHandler;
import com.google.common.annotations.VisibleForTesting;
import com.google.common.collect.ImmutableList;
import com.google.common.base.Strings;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.Experience;
import net.runelite.client.game.SpriteManager;
import net.runelite.client.hiscore.*;

import static net.runelite.api.SpriteID.TAB_COMBAT;
import static net.runelite.client.hiscore.HiscoreSkill.*;


import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.FontManager;
import net.runelite.client.ui.PluginPanel;
import net.runelite.client.ui.components.IconTextField;
import net.runelite.client.util.ImageUtil;

import java.awt.*;
import java.awt.event.FocusAdapter;
import java.awt.event.FocusEvent;
import java.awt.event.KeyListener;
import java.awt.image.BufferedImage;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import net.runelite.client.util.QuantityFormatter;
import org.apache.commons.lang3.StringUtils;

@Slf4j
@Singleton
public class BHP_Panel extends PluginPanel
{

    private final BHP_Plugin BHPplugin;
    private final BHP_Config BHPconfig;
    private final NameAutocompleter nameAutocompleter;
    private final HiscoreClient hiscoreClient;
    private final SessionHandler sessionHandler;
    //group to hold all the skill levels & cmb level
    private final SpriteManager spriteManager;

    //panel assets
    private final JPanel BHP_Panel = new JPanel(new GridBagLayout());
    private final IconTextField opp_nameText;
    private final JButton opp_search_button;
    //private final JButton opp_save_button;
    private final JTextArea notesEditor;
    private final JPanel totalPanel;
    private final JPanel statsPanel;
    private final JLabel surgePot;
    private final JLabel surgeDash;
    private final JLabel surgeNo;
    private final JLabel surgeYes;
    private final JPanel minigamePanel;

    //Runescape character usernames are limited to 12 chars
    int MAX_USERNAME_LENGTH = 12;

    //Making string scope bigger for cleaner code
    String autosaveMessage = "Click outside of the textbox to trigger AutoSave for your target notes!";

    // Not an enummap because we need null keys for combat
    private final Map<HiscoreSkill, JLabel> skillLabels = new HashMap<>();

    //the skills to show
    private static final List<HiscoreSkill> SKILLS = ImmutableList.of(
            ATTACK, HITPOINTS, MINING,
            STRENGTH, AGILITY, SMITHING,
            DEFENCE, HERBLORE, FISHING,
            RANGED, THIEVING, COOKING,
            PRAYER, CRAFTING, FIREMAKING,
            MAGIC, FLETCHING, WOODCUTTING,
            RUNECRAFT, SLAYER, FARMING,
            CONSTRUCTION, HUNTER
    );

    /* The currently selected endpoint */
    private HiscoreEndpoint selectedEndPoint;

    /* Used to prevent users from switching endpoint tabs while the results are loading */
    private boolean loading = false;

    @Inject
    BHP_Panel(Client client, BHP_Plugin plugin, BHP_Config config, NameAutocompleter nameAutocompleter, HiscoreClient hiscoreClient, SessionHandler sessionHandler, SpriteManager spriteManager )  //BHP_Panel(Client client, BHP_Plugin plugin, BHP_Config config, SpriteManager spriteManager, HiscoreClient hiscoreClient)
    {
        this.BHPplugin = plugin;
        this.BHPconfig = config;
        this.nameAutocompleter = nameAutocompleter;
        this.hiscoreClient = hiscoreClient;
        this.sessionHandler = sessionHandler;
        this.spriteManager = spriteManager;

        setBorder(BorderFactory.createEmptyBorder(10, 10, 0, 10));
        setBackground(ColorScheme.DARK_GRAY_COLOR);
        setLayout(new GridBagLayout());

        GridBagConstraints c = new GridBagConstraints();

        c.insets = new Insets(0, 0, 10, 0);

        //player name / search bar
        opp_nameText = new IconTextField();
        opp_nameText.setIcon(IconTextField.Icon.SEARCH);
        opp_nameText.setPreferredSize(new Dimension(PluginPanel.PANEL_WIDTH - 20,30));
        opp_nameText.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        opp_nameText.setHoverBackgroundColor(ColorScheme.DARK_GRAY_HOVER_COLOR);
        opp_nameText.setMinimumSize(new Dimension(0, 30));
        opp_nameText.addActionListener(evt ->
        {
            String searchName = opp_nameText.getText();
            lookup(searchName);
        });
        opp_nameText.addClearListener(() ->
        {
            opp_nameText.setIcon(IconTextField.Icon.SEARCH);
            opp_nameText.setEditable(true);

        });
        c.fill = GridBagConstraints.HORIZONTAL;
        c.weightx = 1;
        c.gridwidth = 2;
        c.gridx = 0;
        c.gridy = 0;
        add(opp_nameText, c);

        //search button to display players
        opp_search_button = new JButton("Search");
        opp_search_button.addActionListener(evt ->
        {
            String searchName = opp_nameText.getText();
            lookup(searchName);
        });
        c.weightx = 1;
        c.gridwidth = 2;
        c.fill = GridBagConstraints.HORIZONTAL;
        c.gridx = 0;
        c.gridy = 1;
        add(opp_search_button, c);

        notesEditor = new JTextArea();
        notesEditor.setForeground(Color.WHITE);
        notesEditor.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        notesEditor.setLineWrap(true);
        notesEditor.setWrapStyleWord(true);
        notesEditor.setTabSize(2);
        notesEditor.setRows(7);
        notesEditor.addFocusListener(new FocusAdapter()
        {
            @Override
            public void focusGained(FocusEvent e)
            {
                String note = notesEditor.getText();
                if(note.equals(autosaveMessage))
                {
                    notesEditor.setForeground(Color.WHITE);
                    notesEditor.setText("");
                }
            }

            @Override
            public void focusLost(FocusEvent e)
            {
                String note = notesEditor.getText();
                String playerName = opp_nameText.getText();

                //ensure we aren't saving this message as the note
                if(note.equals(autosaveMessage)) return;

                if(!note.isEmpty() && !playerName.isEmpty())
                {
                    sessionHandler.updateNote(playerName, note);
                    postSaveMsg("[+]BH Pages: Note for " + playerName + " has been updated.");
                }
            }
        });
        c.weightx = 1;
        c.gridwidth = 2;
        c.fill = GridBagConstraints.HORIZONTAL;
        c.gridx = 0;
        c.gridy = 2;
        add(notesEditor, c);

        //Display total combat level and combined levels on acc.
        totalPanel = new JPanel();
        totalPanel.setLayout(new GridLayout(1, 2));
        totalPanel.setBackground(ColorScheme.DARKER_GRAY_COLOR);

        totalPanel.add(makeHiscorePanel(null)); //combat has no hiscore skill, referred to as null
        totalPanel.add(makeHiscorePanel(OVERALL)); //total level holder

        c.weightx = 1;
        c.gridwidth = 2;
        c.fill = GridBagConstraints.HORIZONTAL;
        c.gridx = 0;
        c.gridy = 3;
        add(totalPanel, c);

        // Panel that holds skill icons
        statsPanel = new JPanel();
        statsPanel.setLayout(new GridLayout(8, 3));
        statsPanel.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        statsPanel.setBorder(new EmptyBorder(5, 0, 5, 0));

        // For each skill on the ingame skill panel, create a Label and add it to the UI
        for (HiscoreSkill skill : SKILLS)
        {
            JPanel panel = makeHiscorePanel(skill);
            statsPanel.add(panel);
        }

        c.weightx = 1;
        c.gridwidth = 2;
        c.fill = GridBagConstraints.HORIZONTAL;
        c.gridx = 0;
        c.gridy = 4;
        add(statsPanel, c);

        //Can use a Surge pot?
        surgePot = new JLabel("Can use Surge Potion?");
        c.weightx = 1;
        c.gridwidth = 1;
        c.fill = GridBagConstraints.HORIZONTAL;
        c.gridx = 0;
        c.gridy = 5;
        add(surgePot, c);

        //I draw all assets on screen with only dash visible on default state
        //easier to turn on and off with setVisible() true/false later on when lookup() runs.
        surgeDash = new JLabel("-", JLabel.CENTER);
        surgeDash.setForeground(Color.white);
        c.weightx = 1;
        c.gridwidth = 1;
        c.fill = GridBagConstraints.HORIZONTAL;
        c.gridx = 1;
        c.gridy = 5;
        add(surgeDash, c);

        surgeNo = new JLabel("No", JLabel.CENTER);
        surgeNo.setForeground(Color.red);
        surgeNo.setVisible(false);
        c.weightx = 1;
        c.gridwidth = 1;
        c.fill = GridBagConstraints.HORIZONTAL;
        c.gridx = 1;
        c.gridy = 5;
        add(surgeNo, c);

        surgeYes = new JLabel("Yes", JLabel.CENTER);
        surgeYes.setForeground(Color.green);
        surgeYes.setVisible(false);
        c.weightx = 1;
        c.gridwidth = 1;
        c.fill = GridBagConstraints.HORIZONTAL;
        c.gridx = 1;
        c.gridy = 5;
        add(surgeYes, c);


        //panel to display LMS, BH Rouge (nontarget) & BH Hunter (target)
        minigamePanel = new JPanel();
        minigamePanel.setLayout(new GridLayout(0, 3));
        minigamePanel.setBackground(ColorScheme.DARKER_GRAY_COLOR);

        minigamePanel.add(makeHiscorePanel(LAST_MAN_STANDING));
        minigamePanel.add(makeHiscorePanel(BOUNTY_HUNTER_ROGUE));
        minigamePanel.add(makeHiscorePanel(BOUNTY_HUNTER_HUNTER));

        c.weightx = 1;
        c.gridwidth = 2;
        c.fill = GridBagConstraints.HORIZONTAL;
        c.gridx = 0;
        c.gridy = 6;
        add(minigamePanel, c);

        addInputKeyListener(nameAutocompleter);

    }

    void shutdown()
    {
        removeInputKeyListener(nameAutocompleter);
    }
//asset functions

    public void lookup(String username)
    {
        opp_nameText.setText(username);
        String note = sessionHandler.getNoteForPlayer(username);
        if(note.isEmpty())
        {
            notesEditor.setForeground(Color.GRAY);
            notesEditor.setText(autosaveMessage);
        }
        else
        {
            notesEditor.setForeground(Color.WHITE);
            notesEditor.setText(note);
        }
        lookup();
    }

    private void lookup()
    {


        final String lookup = sanitize(opp_nameText.getText());

        if(Strings.isNullOrEmpty(lookup))
        {
            return;
        }

        if(lookup.length() > MAX_USERNAME_LENGTH)
        {
            opp_nameText.setIcon(IconTextField.Icon.ERROR);
            loading = false;
            return;
        }

        repaint();

        opp_nameText.setEditable(false);
        opp_nameText.setIcon(IconTextField.Icon.LOADING_DARKER);
        loading = true;

        for (Map.Entry<HiscoreSkill, JLabel> entry : skillLabels.entrySet())
        {
            HiscoreSkill skill = entry.getKey();
            JLabel label = entry.getValue();
            HiscoreSkillType skillType = skill == null ? HiscoreSkillType.SKILL : skill.getType();

            label.setText(pad("--", skillType));
            label.setToolTipText(skill == null ? "Combat" : skill.getName());
        }

        //set endpoint to normal (change later?)
        selectedEndPoint = HiscoreEndpoint.NORMAL;

        hiscoreClient.lookupAsync(lookup, selectedEndPoint).whenCompleteAsync((result, ex) ->
                SwingUtilities.invokeLater(() ->
                {
                    if (!sanitize(opp_nameText.getText()).equals(lookup))
                    {
                        // search has changed in the meantime
                        return;
                    }

                    if (result == null || ex != null)
                    {
                        if (ex != null)
                        {
                            postSaveMsg("Error fetching Hiscore data " + ex.getMessage());
                        }

                        opp_nameText.setIcon(IconTextField.Icon.ERROR);
                        opp_nameText.setEditable(true);
                        loading = false;
                        return;
                    }

                    //successful player search
                    opp_nameText.setIcon(IconTextField.Icon.SEARCH);
                    opp_nameText.setEditable(true);
                    loading = false;

                    applyHiscoreResult(result);
                }));

    }

    private void applyHiscoreResult(HiscoreResult result)
    {
        assert SwingUtilities.isEventDispatchThread();
        repaint();

        nameAutocompleter.addToSearchHistory(result.getPlayer().toLowerCase());

        for (Map.Entry<HiscoreSkill, JLabel> entry : skillLabels.entrySet())
        {
            HiscoreSkill skill = entry.getKey();
            JLabel label = entry.getValue();
            Skill s;

            if (skill == null)
            {
                if (result.getPlayer() != null)
                {
                    int combatLevel = Experience.getCombatLevel(
                            result.getSkill(ATTACK).getLevel(),
                            result.getSkill(STRENGTH).getLevel(),
                            result.getSkill(DEFENCE).getLevel(),
                            result.getSkill(HITPOINTS).getLevel(),
                            result.getSkill(MAGIC).getLevel(),
                            result.getSkill(RANGED).getLevel(),
                            result.getSkill(PRAYER).getLevel()
                    );
                    label.setText(Integer.toString(combatLevel));
                }
            }
            else if ((s = result.getSkill(skill)) != null)
            {
                final long exp = s.getExperience();
                final boolean isSkill = skill.getType() == HiscoreSkillType.SKILL;
                int level = -1;

                if(result.getSkill(HERBLORE).getLevel() >= 81)
                {
                    surgeDash.setVisible(false);
                    surgeNo.setVisible(false);
                    surgeYes.setVisible(true);
                }
                else
                {
                    surgeDash.setVisible(false);
                    surgeYes.setVisible(false);
                    surgeNo.setVisible(true);
                }

                if (BHPconfig.virtualLevels() && isSkill && exp > -1L)
                {
                    level = Experience.getLevelForXp((int) exp);
                }
                else if (!isSkill || exp != -1L)
                {
                    // for skills, level is only valid if exp is not -1
                    // otherwise level is always valid
                    level = s.getLevel();
                }

                if (level != -1)
                {
                    label.setText(pad(formatLevel(level), skill.getType()));
                }
            }

            label.setToolTipText(detailsHtml(result, skill));
        }
    }

    private JPanel makeHiscorePanel(HiscoreSkill skill)
    {
        HiscoreSkillType skillType = skill == null ? HiscoreSkillType.SKILL : skill.getType();

        JLabel label = new JLabel();
        label.setToolTipText(skill == null ? "Combat" : skill.getName());
        label.setFont(FontManager.getRunescapeSmallFont());
        label.setText(pad("--", skillType));

        spriteManager.getSpriteAsync(skill == null ? TAB_COMBAT : skill.getSpriteId(), 0, (sprite) ->
                SwingUtilities.invokeLater(() ->
                {
                    // Icons are all 25x25 or smaller, so they're fit into a 25x25 canvas to give them a consistent size for
                    // better alignment. Further, they are then scaled down to 20x20 to not be overly large in the panel.
                    final BufferedImage scaledSprite = ImageUtil.resizeImage(ImageUtil.resizeCanvas(sprite, 25, 25), 20, 20);
                    label.setIcon(new ImageIcon(scaledSprite));
                }));

        boolean totalLabel = skill == OVERALL || skill == null; //overall or combat
        label.setIconTextGap(totalLabel ? 10 : 4);

        JPanel skillPanel = new JPanel();
        skillPanel.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        skillPanel.setBorder(new EmptyBorder(2, 0, 2, 0));
        skillLabels.put(skill, label);
        skillPanel.add(label);

        return skillPanel;
    }

    void addInputKeyListener(KeyListener l)
    {
        this.opp_nameText.addKeyListener(l);
    }

    void removeInputKeyListener(KeyListener l)
    {
        this.opp_nameText.removeKeyListener(l);
    }

    private String detailsHtml(HiscoreResult result, HiscoreSkill skill)
    {
        String openingTags = "<html><body style = 'padding: 5px;color:#989898'>";
        String closingTags = "</html><body>";

        String content = "";

        if (skill == null)
        {
            double combatLevel = Experience.getCombatLevelPrecise(
                    result.getSkill(ATTACK).getLevel(),
                    result.getSkill(STRENGTH).getLevel(),
                    result.getSkill(DEFENCE).getLevel(),
                    result.getSkill(HITPOINTS).getLevel(),
                    result.getSkill(MAGIC).getLevel(),
                    result.getSkill(RANGED).getLevel(),
                    result.getSkill(PRAYER).getLevel()
            );

            double combatExperience = result.getSkill(ATTACK).getExperience()
                    + result.getSkill(STRENGTH).getExperience() + result.getSkill(DEFENCE).getExperience()
                    + result.getSkill(HITPOINTS).getExperience() + result.getSkill(MAGIC).getExperience()
                    + result.getSkill(RANGED).getExperience() + result.getSkill(PRAYER).getExperience();

            content += "<p><span style = 'color:white'>Combat</span></p>";
            content += "<p><span style = 'color:white'>Exact Combat Level:</span> " + QuantityFormatter.formatNumber(combatLevel) + "</p>";
            content += "<p><span style = 'color:white'>Experience:</span> " + QuantityFormatter.formatNumber(combatExperience) + "</p>";
        }
        else
        {
            switch (skill)
            {
                case CLUE_SCROLL_ALL:
                {
                    content += "<p><span style = 'color:white'>Clues</span></p>";
                    content += buildClueLine(result, "All", CLUE_SCROLL_ALL);
                    content += buildClueLine(result, "Beginner", CLUE_SCROLL_BEGINNER);
                    content += buildClueLine(result, "Easy", CLUE_SCROLL_EASY);
                    content += buildClueLine(result, "Medium", CLUE_SCROLL_MEDIUM);
                    content += buildClueLine(result, "Hard", CLUE_SCROLL_HARD);
                    content += buildClueLine(result, "Elite", CLUE_SCROLL_ELITE);
                    content += buildClueLine(result, "Master", CLUE_SCROLL_MASTER);
                    break;
                }
                case BOUNTY_HUNTER_ROGUE:
                case BOUNTY_HUNTER_HUNTER:
                case PVP_ARENA_RANK:
                case LAST_MAN_STANDING:
                case SOUL_WARS_ZEAL:
                case RIFTS_CLOSED:
                case COLOSSEUM_GLORY:
                case COLLECTIONS_LOGGED:
                {
                    content += buildMinigameTooltip(result.getSkill(skill), skill);
                    break;
                }
                case LEAGUE_POINTS:
                {
                    Skill leaguePoints = result.getSkill(LEAGUE_POINTS);
                    String rank = (leaguePoints.getRank() == -1) ? "Unranked" : QuantityFormatter.formatNumber(leaguePoints.getRank());
                    content += "<p><span style = 'color:white'>League Points</span></p>";
                    content += "<p><span style = 'color:white'>Rank:</span> " + rank + "</p>";
                    if (leaguePoints.getLevel() > -1)
                    {
                        content += "<p><span style = 'color:white'>Points:</span> " + QuantityFormatter.formatNumber(leaguePoints.getLevel()) + "</p>";
                    }
                    break;
                }
                case OVERALL:
                {
                    Skill requestedSkill = result.getSkill(skill);
                    String rank = (requestedSkill.getRank() == -1) ? "Unranked" : QuantityFormatter.formatNumber(requestedSkill.getRank());
                    String exp = (requestedSkill.getExperience() == -1L) ? "Unranked" : QuantityFormatter.formatNumber(requestedSkill.getExperience());
                    content += "<p><span style = 'color:white'>" + skill.getName() + "</span></p>";
                    content += "<p><span style = 'color:white'>Rank:</span> " + rank + "</p>";
                    content += "<p><span style = 'color:white'>Experience:</span> " + exp + "</p>";
                    break;
                }
                default:
                {
                    if (skill.getType() == HiscoreSkillType.BOSS)
                    {
                        String rank = "Unranked";
                        String lvl = null;
                        Skill requestedSkill = result.getSkill(skill);
                        if (requestedSkill != null)
                        {
                            if (requestedSkill.getRank() > -1)
                            {
                                rank = QuantityFormatter.formatNumber(requestedSkill.getRank());
                            }
                            if (requestedSkill.getLevel() > -1)
                            {
                                lvl = QuantityFormatter.formatNumber(requestedSkill.getLevel());
                            }
                        }

                        content += "<p><span style = 'color:white'>Boss:</span> " + skill.getName() + "</p>";
                        content += "<p><span style = 'color:white'>Rank:</span> " + rank + "</p>";
                        if (lvl != null)
                        {
                            content += "<p><span style = 'color:white'>KC:</span> " + lvl + "</p>";
                        }
                    }
                    else
                    {
                        Skill requestedSkill = result.getSkill(skill);
                        final long experience = requestedSkill.getExperience();

                        String rank = (requestedSkill.getRank() == -1) ? "Unranked" : QuantityFormatter.formatNumber(requestedSkill.getRank());
                        String exp = (experience == -1L) ? "Unranked" : QuantityFormatter.formatNumber(experience);
                        String remainingXp;
                        if (experience == -1L)
                        {
                            remainingXp = "Unranked";
                        }
                        else
                        {
                            int currentLevel = Experience.getLevelForXp((int) experience);
                            remainingXp = (currentLevel + 1 <= Experience.MAX_VIRT_LEVEL) ? QuantityFormatter.formatNumber(Experience.getXpForLevel(currentLevel + 1) - experience) : "0";
                        }

                        content += "<p><span style = 'color:white'>Skill:</span> " + skill.getName() + "</p>";
                        content += "<p><span style = 'color:white'>Rank:</span> " + rank + "</p>";
                        content += "<p><span style = 'color:white'>Experience:</span> " + exp + "</p>";
                        content += "<p><span style = 'color:white'>Remaining XP:</span> " + remainingXp + "</p>";
                    }
                    break;
                }
            }
        }

        // Add a html progress bar to the hover information
        if (skill != null && skill.getType() == HiscoreSkillType.SKILL)
        {
            long experience = result.getSkill(skill).getExperience();
            if (experience >= 0)
            {
                int currentXp = (int) experience;
                int currentLevel = Experience.getLevelForXp(currentXp);
                int xpForCurrentLevel = Experience.getXpForLevel(currentLevel);
                int xpForNextLevel = currentLevel + 1 <= Experience.MAX_VIRT_LEVEL ? Experience.getXpForLevel(currentLevel + 1) : -1;

                double xpGained = currentXp - xpForCurrentLevel;
                double xpGoal = xpForNextLevel != -1 ? xpForNextLevel - xpForCurrentLevel : 100;
                int progress = (int) ((xpGained / xpGoal) * 100f);

                // had to wrap the bar with an empty div, if i added the margin directly to the bar, it would mess up
                content += "<div style = 'margin-top:3px'>"
                        + "<div style = 'background: #070707; border: 1px solid #070707; height: 6px; width: 100%;'>"
                        + "<div style = 'height: 6px; width: " + progress + "%; background: #dc8a00;'>"
                        + "</div>"
                        + "</div>"
                        + "</div>";
            }
        }

        return openingTags + content + closingTags;
    }

    private static String buildMinigameTooltip(Skill s, HiscoreSkill hiscoreSkill)
    {
        String rank = (s.getRank() == -1) ? "Unranked" : QuantityFormatter.formatNumber(s.getRank());
        String content = "";
        content += "<p><span style = 'color:white'>" + hiscoreSkill.getName() + "</span></p>";
        content += "<p><span style = 'color:white'>Rank:</span> " + rank + "</p>";
        if (s.getLevel() > -1)
        {
            content += "<p><span style = 'color:white'>Score:</span> " + QuantityFormatter.formatNumber(s.getLevel()) + "</p>";
        }
        return content;
    }

    private static String buildClueLine(HiscoreResult result, String name, HiscoreSkill skill)
    {
        Skill sk = result.getSkill(skill);
        String count = sk.getLevel() == -1
                ? "0"
                : QuantityFormatter.formatNumber(sk.getLevel());
        String rank = sk.getRank() == -1
                ? "Unranked"
                : QuantityFormatter.formatNumber(sk.getRank());
        return "<p><span style = 'color:white'>" + name + ":</span> " + count + " <span style = 'color:white'>Rank:</span> " + rank + "</p>";
    }

    private static String sanitize(String lookup)
    {
        return lookup.replace('\u00A0', ' ');
    }

    @VisibleForTesting
    static String formatLevel(int level)
    {
        if (level < 10000)
        {
            return Integer.toString(level);
        }
        else
        {
            return (level / 1000) + "k";
        }
    }

    private static String pad(String str, HiscoreSkillType type)
    {
        // Left pad label text to keep labels aligned
        int pad = type == HiscoreSkillType.BOSS ? 4 : 2;
        return StringUtils.leftPad(str, pad);
    }


    private void postSaveMsg(String msg)
    {
        BHPplugin.chatGameMessage(msg);
    }

}

package com.BHPages;

import javax.inject.Inject;
import javax.swing.*;

import com.BHPages.session.SessionHandler;
import com.google.inject.Provides;
import lombok.extern.slf4j.Slf4j;

import net.runelite.api.Client;
import net.runelite.api.events.ChatMessage;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.eventbus.Subscribe;

import net.runelite.client.hiscore.HiscoreEndpoint;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.plugins.PluginDescriptor;
import net.runelite.client.ui.ClientToolbar;
import net.runelite.client.ui.NavigationButton;
import net.runelite.client.util.ImageUtil;

import java.util.regex.Matcher;
import java.util.regex.Pattern;

import static net.runelite.api.ChatMessageType.GAMEMESSAGE;


@Slf4j
@PluginDescriptor(
	name = "BH Pages"
)
public class BHP_Plugin extends Plugin {

	@Inject
	private Client client;

	@Inject
	private ClientToolbar clientToolbar;

	@Inject
	private ClientThread clientThread;

	@Inject
	private BHP_Config config;

	@Inject
	private SessionHandler sessionHandler;

	private NavigationButton navButton;
	private BHP_Panel BHPpanel;


	//regex for opponent player name extraction (onChatMessage)
	private static final Pattern BOUNTY_PATTERN = Pattern.compile("You have been assigned a new target: <col=[0-9a-f]+>(.*)</col>");

	@Provides
	BHP_Config provideConfig(ConfigManager configManager)
	{
		return configManager.getConfig(BHP_Config.class);
	}

	@Override
	protected void startUp() throws Exception
	{
		BHPpanel = injector.getInstance(BHP_Panel.class);
		navButton = NavigationButton.builder()
				.tooltip("BH Pages")
				.icon(ImageUtil.loadImageResource(getClass(), "/BHP_Panel_Icon.png"))
				.priority(99)
				.panel(BHPpanel)
				.build();
		clientToolbar.addNavigation(navButton);

		sessionHandler.loadNotes();
	}

	@Override
	protected void shutDown() throws Exception {

		sessionHandler.saveNotes();
		BHPpanel.shutdown();
		clientToolbar.removeNavigation(navButton);

	}


	@Subscribe(priority = -2) // run after ChatMessageManager
	public void onChatMessage(ChatMessage chatMessage)
	{
		if (chatMessage.getType() == GAMEMESSAGE)
		{
			String message = chatMessage.getMessage();
			Matcher match = BOUNTY_PATTERN.matcher(message);
			if (match.matches())
			{
				lookupPlayerName(match.group(1));
			}
		}
	}

	void lookupPlayerName(String playerName)
	{
		SwingUtilities.invokeLater(() ->
		{
			clientToolbar.openPanel(navButton);
			BHPpanel.lookup(playerName);
		});
	}

	HiscoreEndpoint getWorldEndpoint()
	{
		return HiscoreEndpoint.fromWorldTypes(client.getWorldType());
	}

	void chatGameMessage(String message)
	{
		clientThread.invokeLater(() ->
		{
			client.addChatMessage(GAMEMESSAGE, "", message, null);
		});

	}

}
package com.BHPages;

import net.runelite.client.config.Config;
import net.runelite.client.config.ConfigGroup;
import net.runelite.client.config.ConfigItem;

@ConfigGroup("BH Pages")
public interface BHP_Config extends Config
{
	@ConfigItem(
			position = 1,
			keyName = "virtualLevels",
			name = "Display virtual levels",
			description = "Display levels over 99 in the hiscore panel."
	)
	default boolean virtualLevels()
	{
		return true;
	}

	@ConfigItem(
			position = 2,
			keyName = "autocomplete",
			name = "Autocomplete",
			description = "Predict names when typing a name to lookup."
	)
	default boolean autocomplete()
	{
		return true;
	}

}

package com.BHPages;

import net.runelite.client.RuneLite;
import net.runelite.client.externalplugins.ExternalPluginManager;

public class BHP_PluginTest
{
	public static void main(String[] args) throws Exception
	{
		ExternalPluginManager.loadBuiltin(BHP_Plugin.class);
		RuneLite.main(args);
	}
}
