package com.combatlogger;

import com.combatlogger.messages.BaseCombatStatsMessage;
import com.combatlogger.messages.BoostedCombatStatsMessage;
import com.combatlogger.messages.DamageMessage;
import com.combatlogger.messages.EquipmentMessage;
import com.combatlogger.messages.PrayerMessage;
import com.combatlogger.model.Fight;
import com.combatlogger.model.TrackedGraphicObject;
import com.combatlogger.model.TrackedNpc;
import com.combatlogger.model.TrackedPartyMember;
import com.combatlogger.model.logs.*;
import com.combatlogger.overlay.CombatLoggerOverlay;
import com.combatlogger.panel.CombatLoggerPanel;
import com.combatlogger.util.AnimationIds;
import com.combatlogger.util.BoundedQueue;
import com.combatlogger.util.CombatStats;
import com.google.inject.Provides;
import lombok.Getter;
import net.runelite.api.Deque;
import net.runelite.api.Menu;
import net.runelite.api.Point;
import net.runelite.api.*;
import net.runelite.api.coords.LocalPoint;
import net.runelite.api.coords.WorldPoint;
import net.runelite.api.events.*;
import net.runelite.api.gameval.InventoryID;
import net.runelite.api.gameval.SpotanimID;
import net.runelite.api.gameval.VarPlayerID;
import net.runelite.api.gameval.VarbitID;
import net.runelite.api.kit.KitType;
import net.runelite.client.RuneLite;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.chat.QueuedMessage;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.eventbus.EventBus;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.events.ConfigChanged;
import net.runelite.client.events.PartyChanged;
import net.runelite.client.party.PartyMember;
import net.runelite.client.party.PartyService;
import net.runelite.client.party.WSClient;
import net.runelite.client.party.messages.UserSync;
import net.runelite.client.party.events.UserJoin;
import net.runelite.client.party.events.UserPart;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.plugins.PluginDependency;
import net.runelite.client.plugins.PluginDescriptor;
import net.runelite.client.plugins.party.PartyPlugin;
import net.runelite.client.ui.ClientToolbar;
import net.runelite.client.ui.NavigationButton;
import net.runelite.client.ui.overlay.OverlayManager;
import net.runelite.client.util.ImageUtil;
import net.runelite.client.util.Text;
import org.apache.commons.lang3.ArrayUtils;

import javax.inject.Inject;
import java.awt.*;
import java.io.File;
import java.io.IOException;
import java.text.SimpleDateFormat;
import java.util.List;
import java.util.*;
import java.util.regex.Pattern;
import java.util.stream.Collectors;

import static com.combatlogger.util.GameObjectIdsToTrack.GAME_OBJECT_IDS_TO_TRACK;
import static com.combatlogger.util.GraphicsObjectIdsToTrack.GRAPHICS_OBJECT_IDS_TO_TRACK;
import static com.combatlogger.util.GroundObjectIdsToTrack.GROUND_OBJECT_IDS_TO_TRACK;
import static com.combatlogger.util.HitSplatUtil.getHitsplatName;
import static com.combatlogger.util.NpcIdsToTrack.NPC_IDS_TO_TRACK;
import static com.combatlogger.util.OverheadToPrayer.HEADICON_TO_PRAYER_VARBIT;

@PluginDependency(PartyPlugin.class)

@PluginDescriptor(
		name = "Combat Logger",
		description = "Damage meter and logs combat events to a text file - Upload and analyze your logs at runelogs.com.",
		tags = {"damage", "dps", "pvm", "tob", "theatre of blood", "toa", "tombs of amascut", "meter", "counter", "tick"}
)

public class CombatLoggerPlugin extends Plugin
{
	public static final String DIRECTORY_NAME = "combat_log";
	public static final File DIRECTORY;
	private static final String LOG_FILE_NAME = "combat_log";
	public static File LOG_FILE;

	private static final SimpleDateFormat DATE_FORMAT = new SimpleDateFormat("MM-dd-yyyy HH:mm:ss 'Z'Z", Locale.ENGLISH);
	private static final Pattern ENCOUNTER_PATTERN = Pattern.compile("(Wave|Duration|Challenge)", Pattern.CASE_INSENSITIVE);

	private static final List<Integer> TOB_ORBS_VARBITS = Arrays.asList(
			VarbitID.TOB_CLIENT_P0,
			VarbitID.TOB_CLIENT_P1,
			VarbitID.TOB_CLIENT_P2,
			VarbitID.TOB_CLIENT_P3,
			VarbitID.TOB_CLIENT_P4
	);

	private static final List<Integer> TOA_ORBS_VARBITS = Arrays.asList(
			VarbitID.TOA_CLIENT_P0,
			VarbitID.TOA_CLIENT_P1,
			VarbitID.TOA_CLIENT_P2,
			VarbitID.TOA_CLIENT_P3,
			VarbitID.TOA_CLIENT_P4,
			VarbitID.TOA_CLIENT_P5,
			VarbitID.TOA_CLIENT_P6,
			VarbitID.TOA_CLIENT_P7
	);

	static
	{
		DIRECTORY = new File(RuneLite.RUNELITE_DIR, DIRECTORY_NAME);
	}

	private boolean checkPlayerName = false;

	private Map<String, TrackedPartyMember> trackedPartyMembers = new HashMap<>();
	private Map<String, TrackedNpc> trackedNpcs = new HashMap<>();
	private Map<String, TrackedGraphicObject> trackedGraphicObjects = new HashMap<>();
	private List<Integer> previousBaseStats;
	private boolean baseStatChangeLogScheduled;
	private List<Integer> previousBoostedStats;
	private boolean boostedStatChangeLogScheduled;
	private int hitpointsXpLastUpdated = -1;
	private List<Integer> previousPrayers;
	private List<Integer> previousItemIds;
	private Set<Integer> playerAnimationChanges = new HashSet<>();
	private int regionId = -1;

	private boolean inFight = false;
	private javax.swing.Timer overlayTimeout = null;
	@Getter
	private Boolean overlayVisible = false;

	@Inject
	private Client client;

	@Getter
	@Inject
	private ClientThread clientThread;

	@Inject
	private EventBus eventBus;

	@Inject
	private ChatMessageManager chatMessageManager;

	@Inject
	private LogQueueManager logQueueManager;

	@Inject
	private FightManager fightManager;

	@Inject
	private ClientToolbar clientToolbar;

	@Inject
	private CombatLoggerConfig config;

	@Inject
	private WSClient wsClient;

	@Inject
	private PartyService party;

	@Inject
	private OverlayManager overlayManager;

	@Inject
	private CombatLoggerOverlay damageOverlay;

	private CombatLoggerPanel panel;

	private NavigationButton navButton;

	@Provides
	CombatLoggerConfig provideConfig(ConfigManager configManager)
	{
		return configManager.getConfig(CombatLoggerConfig.class);
	}

	@Override
	protected void startUp()
	{
		panel = injector.getInstance(CombatLoggerPanel.class);
		logQueueManager.startUp(eventBus);

		navButton = NavigationButton.builder()
				.tooltip("Combat Logger")
				.icon(ImageUtil.loadImageResource(getClass(), "/panel_icon.png"))
				.priority(10)
				.panel(panel)
				.build();
		clientToolbar.addNavigation(navButton);

		DIRECTORY.mkdirs();
		sendReminderMessage();
		createLogFile();
		wsClient.registerMessage(DamageMessage.class);
		wsClient.registerMessage(BaseCombatStatsMessage.class);
		wsClient.registerMessage(BoostedCombatStatsMessage.class);
		wsClient.registerMessage(EquipmentMessage.class);
		wsClient.registerMessage(PrayerMessage.class);

		if (config.enableOverlay())
		{
			setOverlayVisible(true);
			resetOverlayTimeout();
		}
	}

	@Override
	protected void shutDown()
	{
		previousBaseStats = null;
		previousBoostedStats = null;
		previousPrayers = null;
		previousItemIds = null;
		playerAnimationChanges.clear();
		trackedPartyMembers.clear();
		trackedNpcs.clear();
		trackedGraphicObjects.clear();
		regionId = -1;
		wsClient.unregisterMessage(DamageMessage.class);
		wsClient.unregisterMessage(BaseCombatStatsMessage.class);
		wsClient.unregisterMessage(BoostedCombatStatsMessage.class);
		wsClient.unregisterMessage(EquipmentMessage.class);
		wsClient.unregisterMessage(PrayerMessage.class);
		clientToolbar.removeNavigation(navButton);
		panel = null;
		logQueueManager.shutDown(eventBus);
		fightManager.shutDown();
		setOverlayVisible(false);
	}


	@Subscribe
	public void onCommandExecuted(CommandExecuted commandExecuted)
	{
		if (!commandExecuted.getCommand().equals("newlog"))
		{
			return;
		}

		createLogFile();
		chatMessageManager
				.queue(QueuedMessage.builder()
						.type(ChatMessageType.GAMEMESSAGE)
						.runeLiteFormattedMessage(String.format("<col=cc0000>New combat log created: %s</col>", LOG_FILE.getName()))
						.build());
		logEquipment(true); // Normally ItemContainerChanged is fired on startup, so it's not necessary in createLogFile()
		logPrayers(true);
	}

	@Subscribe
	public void onGameStateChanged(GameStateChanged gameStateChanged)
	{
		if (gameStateChanged.getGameState() == GameState.LOGGING_IN)
		{
			checkPlayerName = true;
		}
	}

	@Subscribe
	public void onNpcDespawned(NpcDespawned event)
	{
		int npcId = event.getNpc().getId();
		if (!NPC_IDS_TO_TRACK.contains(npcId))
		{
			return;
		}
		String key = npcId + "-" + event.getNpc().getIndex();
		trackedNpcs.remove(key);
		logQueueManager.queue(String.format("%s\tDESPAWNED", key));
	}

	@Subscribe
	public void onNpcChanged(NpcChanged event)
	{
		String oldNpc = event.getOld().getId() + "-" + event.getNpc().getIndex();
		String newNpc = event.getNpc().getId() + "-" + event.getNpc().getIndex();

		trackedNpcs.remove(oldNpc);
		logQueueManager.queue(
				new NpcChangedLog(
						client.getTickCount(),
						getCurrentTimestamp(),
						String.format("%s\tNPC_CHANGED\t%s", oldNpc, newNpc),
						oldNpc,
						newNpc
				)
		);
	}

	@Subscribe
	public void onGameTick(GameTick event)
	{
		Fight currentFight = fightManager.getLastFight();
		boolean fightOngoing = currentFight != null && !currentFight.isOver();

		if (fightOngoing && !inFight)
		{
			// Fight has just started
			inFight = true;
			setOverlayVisible(true);
			stopOverlayTimeout();
		}
		else if (!fightOngoing && inFight)
		{
			// Fight has just ended
			inFight = false;
			resetOverlayTimeout();
		}

		if (fightOngoing)
		{
			currentFight.setFightLengthTicks(currentFight.getFightLengthTicks() + 1);

			if ((currentFight.getLastActivityTick() + 100 < client.getTickCount() && !currentFight.getFightName().startsWith("Path of"))
					|| (currentFight.getLastActivityTick() + 500 < client.getTickCount() && currentFight.getFightName().startsWith("Path of")))
			{
				// It's been 1 minute (or 5 minutes in a ToA path) without any activity. End the fight
				currentFight.setOver(true);
			}
		}

		panel.updatePanel();

		if (checkPlayerName && client.getLocalPlayer() != null && client.getLocalPlayer().getName() != null)
		{
			logPlayerName();
			clientThread.invokeLater(this::sendReminderMessage); // Delay so it's at bottom of chat
			checkPlayerName = false;
		}

		Player local = client.getLocalPlayer();
		if (local == null)
		{
			return;
		}

		logPrayers(false);

		List<Player> players = client.getPlayers();
		players.forEach(player -> {
			this.checkBlowpipe(player);
			this.logPosition(player);
			this.logMemberEquipment(player);
			this.logMemberOverhead(player);
		});

		for (int playerId : playerAnimationChanges)
		{
			Player player = players.stream()
					.filter(p -> p.getId() == playerId)
					.findFirst()
					.orElse(null);
			if (player != null)
			{
				int animationId = player.getAnimation();
				checkAttackAnimation(player, animationId);
			}
		}
		playerAnimationChanges.clear();

		checkPlayerRegion();
		validatePartyMembers();

		List<NPC> npcs = client.getNpcs();
		npcs.forEach(npc -> {
			this.logPosition(npc);
		});

		checkGraphicsObjectDespawns();
	}

	private void logPrayers(boolean forceLogging)
	{
		Player player = client.getLocalPlayer();
		List<Integer> currentPrayers = new ArrayList<>();
		for (Prayer prayer : Prayer.values())
		{
			if (client.isPrayerActive(prayer))
			{
				currentPrayers.add(prayer.getVarbit());
			}
		}
		if (forceLogging || !Objects.equals(currentPrayers, previousPrayers))
		{
			if (party.isInParty())
			{
				PrayerMessage prayerMessage = new PrayerMessage(currentPrayers);
				clientThread.invokeLater(() -> party.send(prayerMessage));
			}
			logQueueManager.queue(String.format("%s\tPRAYERS\t%s", player.getName(), currentPrayers));
			previousPrayers = currentPrayers;
		}
	}

	private void checkBlowpipe(Player player)
	{
		int animationId = player.getAnimation();

		if ((animationId == 5061 || animationId == 10656) && player.getAnimationFrame() == 0 && player.getInteracting() != null)
		{
			// Blowpipes will restart their attack animation (at frame 0) without sending an AnimationChanged event
			// So we just check every player if they have the blowpipe animation at frame 0
			logAttackAnimation(animationId, player);
		}
	}

	private void logPosition(Player player)
	{
		if (party.getMemberByDisplayName(player.getName()) == null && !client.getLocalPlayer().getName().equals(player.getName()))
		{
			return;
		}

		TrackedPartyMember trackedPartyMember = trackedPartyMembers.getOrDefault(player.getName(), new TrackedPartyMember());
		WorldPoint currentWorldPoint = WorldPoint.fromLocalInstance(client, LocalPoint.fromWorld(client, player.getWorldLocation()));

		if (currentWorldPoint.equals(trackedPartyMember.getWorldPoint()))
		{
			// Only log if their position has changed
			return;
		}

		trackedPartyMember.setWorldPoint(currentWorldPoint);
		if (player.getName().equals(client.getLocalPlayer().getName()))
		{
			trackedPartyMember.setUsingCombatLoggerPlugin(true);
		}
		trackedPartyMembers.put(player.getName(), trackedPartyMember);
		logQueueManager.queue(String.format("%s\tPOSITION\t(%d, %d, %d)", player.getName(), currentWorldPoint.getX(), currentWorldPoint.getY(), currentWorldPoint.getPlane()));
	}

	private void logMemberEquipment(Player player)
	{
		TrackedPartyMember trackedPartyMember = trackedPartyMembers.get(player.getName());

		if (trackedPartyMember == null || trackedPartyMember.isUsingCombatLoggerPlugin())
		{
			return;
		}

		PlayerComposition composition = player.getPlayerComposition();
		if (composition != null)
		{
			int[] compositionEquipmentIds = composition.getEquipmentIds();
			List<Integer> currentEquipment = new ArrayList<>();
			for (int i = 0; i < compositionEquipmentIds.length; i++)
			{
				currentEquipment.add(compositionEquipmentIds[i] > PlayerComposition.ITEM_OFFSET ? compositionEquipmentIds[i] - PlayerComposition.ITEM_OFFSET : -1); // Convert to item ID
			}
			for (int i = 0; i < 3; i++)
			{
				// Add slots we can't see as -2 to indicate unknown
				currentEquipment.add(-2);
			}
			if (compositionEquipmentIds != null)
			{
				// Compare with previous equipment
				if (!Objects.equals(currentEquipment, trackedPartyMember.getPreviousEquipment()))
				{
					logQueueManager.queue(String.format("%s\tEQUIPMENT\t%s", player.getName(), currentEquipment));
					trackedPartyMember.setPreviousEquipment(currentEquipment);
					trackedPartyMembers.put(player.getName(), trackedPartyMember);
				}
			}
		}
	}

	private void logMemberOverhead(Player player)
	{
		TrackedPartyMember trackedPartyMember = trackedPartyMembers.get(player.getName());

		if (trackedPartyMember == null || trackedPartyMember.isUsingCombatLoggerPlugin())
		{
			return;
		}

		int currentOverheadPrayerId = -1; // -1 represents none
		if (player.getOverheadIcon() != null)
		{
			currentOverheadPrayerId = HEADICON_TO_PRAYER_VARBIT.get(player.getOverheadIcon());
		}
		if (currentOverheadPrayerId != trackedPartyMember.getPreviousOverheadPrayerId())
		{
			logQueueManager.queue(String.format("%s\tOVERHEAD\t%s", player.getName(), currentOverheadPrayerId));
			trackedPartyMember.setPreviousOverheadPrayerId(currentOverheadPrayerId);
			trackedPartyMembers.put(player.getName(), trackedPartyMember);
		}
	}

	private void logPosition(NPC npc)
	{
		if (!NPC_IDS_TO_TRACK.contains(npc.getId()))
		{
			return;
		}

		TrackedNpc trackedNpc = trackedNpcs.getOrDefault(npc.getId() + "-" + npc.getIndex(), new TrackedNpc());
		WorldPoint currentWorldPoint = WorldPoint.fromLocalInstance(client, LocalPoint.fromWorld(client, npc.getWorldLocation()));

		if (currentWorldPoint.equals(trackedNpc.getWorldPoint()))
		{
			// Only log if their position has changed
			return;
		}

		trackedNpc.setWorldPoint(currentWorldPoint);
		trackedNpcs.put(npc.getId() + "-" + npc.getIndex(), trackedNpc);
		logQueueManager.queue(String.format("%d-%d\tPOSITION\t(%d, %d, %d)", npc.getId(), npc.getIndex(), currentWorldPoint.getX(), currentWorldPoint.getY(), currentWorldPoint.getPlane()));
	}

	@Subscribe
	protected void onGraphicsObjectCreated(GraphicsObjectCreated event)
	{
		GraphicsObject graphicsObject = event.getGraphicsObject();
		if (!GRAPHICS_OBJECT_IDS_TO_TRACK.contains(graphicsObject.getId()))
		{
			return;
		}

		WorldPoint currentWorldPoint = WorldPoint.fromLocalInstance(client, graphicsObject.getLocation());

		String key = graphicsObject.getId() + "-" + currentWorldPoint.getX() + "-" + currentWorldPoint.getY() + "-" + currentWorldPoint.getPlane();

		if (trackedGraphicObjects.get(key) != null)
		{
			// Sometimes the same graphics object is recreated before it's gone (I think to loop the animation?)
			// We don't need to log it again
			return;
		}

		TrackedGraphicObject trackedGraphicObject = new TrackedGraphicObject();
		trackedGraphicObject.setId(graphicsObject.getId());
		trackedGraphicObject.setWorldPoint(currentWorldPoint);
		trackedGraphicObjects.put(key, trackedGraphicObject);
		logQueueManager.queue(String.format("%d\tGRAPHICS_OBJECT_SPAWNED\t(%d, %d, %d)", graphicsObject.getId(), currentWorldPoint.getX(), currentWorldPoint.getY(), currentWorldPoint.getPlane()));
	}

	private void checkGraphicsObjectDespawns()
	{
		Deque<GraphicsObject> graphicsObjects = client.getGraphicsObjects();
		Set<String> activeKeys = new HashSet<>();
		for (GraphicsObject graphicsObject : graphicsObjects)
		{
			if (GRAPHICS_OBJECT_IDS_TO_TRACK.contains(graphicsObject.getId()))
			{
				WorldPoint currentWorldPoint = WorldPoint.fromLocalInstance(client, graphicsObject.getLocation());
				activeKeys.add(graphicsObject.getId() + "-" + currentWorldPoint.getX() + "-" + currentWorldPoint.getY() + "-" + currentWorldPoint.getPlane());
			}
		}

		trackedGraphicObjects.entrySet().removeIf(trackedGraphicObjectEntry -> {
					if (!activeKeys.contains(trackedGraphicObjectEntry.getKey()))
					{
						logQueueManager.queue(String.format(
								"%d\tGRAPHICS_OBJECT_DESPAWNED\t(%d, %d, %d)",
								trackedGraphicObjectEntry.getValue().getId(),
								trackedGraphicObjectEntry.getValue().getWorldPoint().getX(),
								trackedGraphicObjectEntry.getValue().getWorldPoint().getY(),
								trackedGraphicObjectEntry.getValue().getWorldPoint().getPlane()
						));
						return true;
					}
					return false;
				}
		);
	}

	@Subscribe
	protected void onGameObjectSpawned(GameObjectSpawned event)
	{
		GameObject gameObject = event.getGameObject();
		if (!GAME_OBJECT_IDS_TO_TRACK.contains(gameObject.getId()))
		{
			return;
		}
		LocalPoint localPoint = LocalPoint.fromWorld(client, gameObject.getWorldLocation());
		if (localPoint == null)
		{
			return;
		}

		WorldPoint currentWorldPoint = WorldPoint.fromLocalInstance(client, localPoint);

		logQueueManager.queue(String.format("%d\tGAME_OBJECT_SPAWNED\t(%d, %d, %d)", gameObject.getId(), currentWorldPoint.getX(), currentWorldPoint.getY(), currentWorldPoint.getPlane()));
	}

	@Subscribe
	protected void onGameObjectDespawned(GameObjectDespawned event)
	{
		GameObject gameObject = event.getGameObject();
		if (!GAME_OBJECT_IDS_TO_TRACK.contains(gameObject.getId()))
		{
			return;
		}

		LocalPoint localPoint = LocalPoint.fromWorld(client, gameObject.getWorldLocation());
		if (localPoint == null)
		{
			return;
		}

		WorldPoint currentWorldPoint = WorldPoint.fromLocalInstance(client, localPoint);
		logQueueManager.queue(String.format("%d\tGAME_OBJECT_DESPAWNED\t(%d, %d, %d)", gameObject.getId(), currentWorldPoint.getX(), currentWorldPoint.getY(), currentWorldPoint.getPlane()));
	}

	@Subscribe
	protected void onGroundObjectSpawned(GroundObjectSpawned event)
	{
		GroundObject groundObject = event.getGroundObject();

		if (!GROUND_OBJECT_IDS_TO_TRACK.contains(groundObject.getId()))
		{
			return;
		}

		LocalPoint localPoint = LocalPoint.fromWorld(client, groundObject.getWorldLocation());
		if (localPoint == null)
		{
			return;
		}
		WorldPoint currentWorldPoint = WorldPoint.fromLocalInstance(client, localPoint);

		logQueueManager.queue(String.format("%d\tGROUND_OBJECT_SPAWNED\t(%d, %d, %d)", groundObject.getId(), currentWorldPoint.getX(), currentWorldPoint.getY(), currentWorldPoint.getPlane()));
	}

	@Subscribe
	protected void onGroundObjectDespawned(GroundObjectDespawned event)
	{
		GroundObject groundObject = event.getGroundObject();
		if (!GROUND_OBJECT_IDS_TO_TRACK.contains(groundObject.getId()))
		{
			return;
		}
		LocalPoint localPoint = LocalPoint.fromWorld(client, groundObject.getWorldLocation());
		if (localPoint == null)
		{
			return;
		}

		WorldPoint currentWorldPoint = WorldPoint.fromLocalInstance(client, localPoint);
		logQueueManager.queue(String.format("%d\tGROUND_OBJECT_DESPAWNED\t(%d, %d, %d)", groundObject.getId(), currentWorldPoint.getX(), currentWorldPoint.getY(), currentWorldPoint.getPlane()));
	}

	/**
	 * Remove any trackedPartyMembers that are no longer in the party
	 */
	private void validatePartyMembers()
	{
		List<String> partyMemberNames = party.getMembers().stream().map(PartyMember::getDisplayName).collect(Collectors.toList());
		trackedPartyMembers.keySet().removeIf(name -> !partyMemberNames.contains(name) && !client.getLocalPlayer().getName().equals(name));
	}

	private void logAttackAnimation(int animationId, Player player)
	{
		int weaponId = -1;
		if (player.getPlayerComposition() != null)
		{
			weaponId = player.getPlayerComposition().getEquipmentId(KitType.WEAPON);
		}

		logQueueManager.queue(
				new AttackAnimationLog(
						client.getTickCount(),
						getCurrentTimestamp(),
						String.format("%s attack animation %d\t%s", player.getName(), animationId, getIdOrName(player.getInteracting())),
						player.getName(),
						getIdOrName(player.getInteracting()),
						Text.removeTags(player.getInteracting().getName()),
						animationId,
						weaponId
				)
		);
	}

	private void checkAttackAnimation(Player player, int animationId)
	{
		if (player.getInteracting() == null)
		{
			// It's possible we see a player interacting, but their interacting target is outside our visibility range
			// Just not going to count those for now
			return;
		}

		if (animationId == 5061 || animationId == 10656)
		{
			// Blowpipe animations are handled in checkBlowpipe
			return;
		}

		if (AnimationIds.MELEE_IDS.contains(animationId) ||
				AnimationIds.RANGED_IDS.contains(animationId) ||
				AnimationIds.MAGE_IDS.contains(animationId))
		{
			logAttackAnimation(animationId, player);
		}

		Player local = client.getLocalPlayer();
		if (local != null && local.getId() == player.getId() && AnimationIds.MAGE_IDS.contains(animationId))
		{
			checkSplash(local);
		}
	}

	private void checkPlayerRegion()
	{
		if (client.getLocalPlayer() != null)
		{
			LocalPoint localPoint = client.getLocalPlayer().getLocalLocation();
			int currentRegionId = localPoint == null ? -1 : WorldPoint.fromLocalInstance(client, localPoint).getRegionID();
			if (currentRegionId != regionId)
			{
				regionId = currentRegionId;
				logQueueManager.queue(String.format("Player region %d", regionId));
			}

		}
	}

	@Subscribe
	public void onStatChanged(StatChanged statChanged)
	{
		List<Integer> currentBaseStats = CombatStats.getBaseStats(client);
		if (!Objects.equals(currentBaseStats, previousBaseStats))
		{
			previousBaseStats = currentBaseStats;
			// Many StatChanged events are fired on login
			// So we group them together to just get a single log message
			if (!baseStatChangeLogScheduled)
			{
				baseStatChangeLogScheduled = true;
				clientThread.invokeLater(() ->
				{
					if (party.isInParty())
					{
						BaseCombatStatsMessage baseCombatStatsMessage = new BaseCombatStatsMessage(previousBaseStats);
						clientThread.invokeLater(() -> party.send(baseCombatStatsMessage));
					}
					logQueueManager.queue(String.format("%s\tBASE_STATS\t%s", client.getLocalPlayer().getName(), previousBaseStats));
					baseStatChangeLogScheduled = false;
				});
			}
		}

		List<Integer> currentBoostedStats = CombatStats.getBoostedStats(client);
		if (!Objects.equals(currentBoostedStats, previousBoostedStats))
		{
			previousBoostedStats = currentBoostedStats;
			// Many StatChanged events are fired on login and some boosts effect multiple stats (like brews)
			// So we group them together to just get a single log message
			if (!boostedStatChangeLogScheduled)
			{
				boostedStatChangeLogScheduled = true;
				clientThread.invokeLater(() ->
				{
					if (party.isInParty())
					{
						BoostedCombatStatsMessage boostedCombatStatsMessage = new BoostedCombatStatsMessage(previousBoostedStats);
						clientThread.invokeLater(() -> party.send(boostedCombatStatsMessage));
					}
					logQueueManager.queue(String.format("%s\tBOOSTED_STATS\t%s", client.getLocalPlayer().getName(), previousBoostedStats));
					boostedStatChangeLogScheduled = false;
				});
			}
		}

		if (statChanged.getSkill() == Skill.HITPOINTS)
		{
			hitpointsXpLastUpdated = client.getTickCount();
		}
	}

	@Subscribe
	public void onAnimationChanged(AnimationChanged event)
	{
		if (!(event.getActor() instanceof Player))
		{
			return;
		}

		// If we are standing right next to our target, the AnimationChanged event can fire before we are interacting
		// So flag that it happened, but let onGameTick handle it, because it always fires last
		playerAnimationChanges.add(((Player) event.getActor()).getId());
	}

	private void checkSplash(Player local)
	{
		int currentTick = client.getTickCount();
		Actor target = local.getInteracting();
		if (currentTick - hitpointsXpLastUpdated > 1 && !target.getName().toLowerCase().contains("dummy"))
		{
			// We used a spell attack animation, but it's been more than 1 tick since we gained hitpoints xp
			// Assuming that is a splash
			logQueueManager.queue(String.format("%s\t%s\t%s\t%d", local.getName(), "SPLASH_ME", getIdOrName(target), 0));
		}
	}

	@Subscribe
	public void onGraphicChanged(GraphicChanged event)
	{
		Player local = client.getLocalPlayer();

		if (event.getActor() != local)
		{
			return;
		}

		if (local.hasSpotAnim(SpotanimID.FAILEDSPELL_IMPACT))
		{
			logQueueManager.queue(String.format("%s\t%s\t%s\t%d", "Unknown", "SPLASH_ME", local.getName(), 0));
		}
	}

	@Subscribe
	public void onItemContainerChanged(ItemContainerChanged itemContainerChanged)
	{
		if (itemContainerChanged.getContainerId() == InventoryID.WORN)
		{
			logEquipment(false);
		}
	}

	private void logEquipment(boolean forceLogging)
	{
		ItemContainer equipContainer = client.getItemContainer(InventoryID.WORN);
		if (equipContainer == null)
		{
			return;
		}
		List<Integer> currentItemIds = Arrays.stream(equipContainer.getItems())
				.map(Item::getId)
				.collect(Collectors.toList());

		final int quiverAmmoId = client.getVarpValue(VarPlayerID.DIZANAS_QUIVER_TEMP_AMMO);
		currentItemIds.add(quiverAmmoId);

		if (forceLogging || !Objects.equals(currentItemIds, previousItemIds))
		{
			if (party.isInParty())
			{
				EquipmentMessage equipmentMessage = new EquipmentMessage(currentItemIds);
				clientThread.invokeLater(() -> party.send(equipmentMessage));
			}

			previousItemIds = currentItemIds;
			logQueueManager.queue(String.format("%s\tEQUIPMENT\t%s", client.getLocalPlayer().getName(), currentItemIds));
		}
	}

	@Subscribe
	public void onUserSync(final UserSync event)
	{
		clientThread.invokeAtTickEnd(() -> {
			EquipmentMessage equipmentMessage = new EquipmentMessage(previousItemIds);
			party.send(equipmentMessage);

			PrayerMessage prayerMessage = new PrayerMessage(previousPrayers);
			party.send(prayerMessage);

			BaseCombatStatsMessage baseCombatStatsMessage = new BaseCombatStatsMessage(previousBaseStats);
			party.send(baseCombatStatsMessage);

			BoostedCombatStatsMessage boostedCombatStatsMessage = new BoostedCombatStatsMessage(previousBoostedStats);
			party.send(boostedCombatStatsMessage);
		});
	}

	@Subscribe
	public void onEquipmentMessage(EquipmentMessage event)
	{
		PartyMember localMember = party.getLocalMember();
		if (localMember == null || localMember.getMemberId() == event.getMemberId())
		{
			// Don't need to update logs from ourselves
			return;
		}

		markMemberHasPlugin(event.getMemberId());
		PartyMember eventMember = party.getMemberById(event.getMemberId());

		logQueueManager.queue(String.format("%s\tEQUIPMENT\t%s", eventMember.getDisplayName(), event.getItemIds()));
	}

	@Subscribe
	public void onPrayerMessage(PrayerMessage event)
	{
		PartyMember localMember = party.getLocalMember();
		if (localMember == null || localMember.getMemberId() == event.getMemberId())
		{
			// Don't need to update logs from ourselves
			return;
		}

		markMemberHasPlugin(event.getMemberId());
		PartyMember eventMember = party.getMemberById(event.getMemberId());

		logQueueManager.queue(String.format("%s\tPRAYERS\t%s", eventMember.getDisplayName(), event.getPrayerIds()));
	}

	@Subscribe
	public void onBaseCombatStatsMessage(BaseCombatStatsMessage event)
	{
		PartyMember localMember = party.getLocalMember();
		if (localMember == null || localMember.getMemberId() == event.getMemberId())
		{
			// Don't need to update logs from ourselves
			return;
		}

		markMemberHasPlugin(event.getMemberId());
		PartyMember eventMember = party.getMemberById(event.getMemberId());

		logQueueManager.queue(String.format("%s\tBASE_STATS\t%s", eventMember.getDisplayName(), event.getStats()));
	}

	@Subscribe
	public void onBoostedCombatStatsMessage(BoostedCombatStatsMessage event)
	{
		PartyMember localMember = party.getLocalMember();
		if (localMember == null || localMember.getMemberId() == event.getMemberId())
		{
			// Don't need to update logs from ourselves
			return;
		}

		markMemberHasPlugin(event.getMemberId());
		PartyMember eventMember = party.getMemberById(event.getMemberId());

		logQueueManager.queue(String.format("%s\tBOOSTED_STATS\t%s", eventMember.getDisplayName(), event.getStats()));
	}

	private void markMemberHasPlugin(long memberId)
	{
		PartyMember eventMember = party.getMemberById(memberId);
		if (eventMember == null)
		{
			return;
		}

		TrackedPartyMember trackedMember = trackedPartyMembers.getOrDefault(eventMember.getDisplayName(), new TrackedPartyMember());
		trackedMember.setUsingCombatLoggerPlugin(true);
		// I guess if they turn the plugin off without leaving and rejoining the party we just won't have logs for them anymore
		trackedPartyMembers.put(eventMember.getDisplayName(), trackedMember);
	}


	@Subscribe
	public void onHitsplatApplied(HitsplatApplied hitsplatApplied)
	{
		Actor actor = hitsplatApplied.getActor();
		Hitsplat hitsplat = hitsplatApplied.getHitsplat();

		int damageAmount = hitsplat.getAmount();
		String target = getIdOrName(actor);
		String hitsplatName = getHitsplatName(hitsplat.getHitsplatType());
		String source = "Unknown";
		String myName = client.getLocalPlayer().getName();

		if (hitsplat.isMine() && !target.equals(myName))
		{
			source = myName;
		}

		logQueueManager.queue(
				new DamageLog(
						client.getTickCount(),
						getCurrentTimestamp(),
						(String.format("%s\t%s\t%s\t%d", source, hitsplatName, target, damageAmount)),
						source,
						getIdOrName(actor),
						Text.removeTags(actor.getName()),
						damageAmount,
						hitsplatName
				)
		);

		if (party.isInParty() && hitsplat.isMine() && !target.equals(myName))
		{
			DamageMessage damageMessage = new DamageMessage(target, Text.removeTags(actor.getName()), hitsplatName, damageAmount);
			clientThread.invokeLater(() -> party.send(damageMessage));
		}
	}

	@Subscribe
	public void onInteractingChanged(InteractingChanged event)
	{
		Actor source = event.getSource();
		if (event.getTarget() != null &&
				!event.getSource().isDead() &&
				(event.getTarget() instanceof Player || event.getTarget() instanceof NPC))
		{
			Actor target = event.getTarget();
			logQueueManager.queue(
					new TargetChangeLog(
							client.getTickCount(),
							getCurrentTimestamp(),
							String.format("%s changes target to %s", getIdOrName(source), getIdOrName(target)),
							getIdOrName(source),
							Text.removeTags(source.getName()),
							getIdOrName(target)
					)
			);
		}
	}

	@Subscribe
	public void onActorDeath(ActorDeath actorDeath)
	{
		logQueueManager.queue(
				new DeathLog(
						client.getTickCount(),
						getCurrentTimestamp(),
						String.format("%s dies", getIdOrName(actorDeath.getActor())),
						getIdOrName(actorDeath.getActor())
				)
		);
	}

	@Subscribe
	public void onVarbitChanged(VarbitChanged varbitChanged)
	{
		if (varbitChanged.getVarpId() == VarPlayerID.DIZANAS_QUIVER_TEMP_AMMO)
		{
			logEquipment(false);
		}

		if (varbitChanged.getValue() != 30)
		{
			return;
		}

		if (TOB_ORBS_VARBITS.contains(varbitChanged.getVarbitId()) && isWipe(TOB_ORBS_VARBITS))
		{
			logQueueManager.queue("Theatre of Blood Wipe");
		}
		else if (TOA_ORBS_VARBITS.contains(varbitChanged.getVarbitId()) && isWipe(TOA_ORBS_VARBITS))
		{
			logQueueManager.queue("Tombs of Amascut Wipe");
		}
	}

	private boolean isWipe(List<Integer> orbVarbits)
	{
		return orbVarbits.stream()
				.allMatch(varbit -> {
					int value = client.getVarbitValue(varbit);
					// 0 = hidden
					// 30 = dead
					return value == 0 || value == 30;
				});
	}

	@Subscribe
	public void onChatMessage(ChatMessage event)
	{

		if (event.getType() != ChatMessageType.GAMEMESSAGE || "combat-logger".equals(event.getSender()))
		{
			return;
		}

		String message = event.getMessage();
		if (ENCOUNTER_PATTERN.matcher(message).find())
		{
			logQueueManager.queue(
					new GameMessageLog(
							client.getTickCount(),
							getCurrentTimestamp(),
							message

					)
			);
		}
	}

	@Subscribe
	public void onPartyChanged(PartyChanged ev)
	{
		damageOverlay.clearAvatarCache();
	}

	@Subscribe
	public void onUserJoin(UserJoin ev)
	{
		damageOverlay.clearAvatarCache();
	}

	@Subscribe
	public void onUserPart(UserPart ev)
	{
		damageOverlay.clearAvatarCache();
	}

	public void setOverlayVisible(boolean visible)
	{
		if (visible && config.enableOverlay())
		{
			if (!overlayVisible)
			{
				overlayVisible = true;
				overlayManager.add(damageOverlay);
			}
			resetOverlayTimeout();
		}
		else
		{
			if (overlayVisible)
			{
				overlayVisible = false;
				overlayManager.remove(damageOverlay);
			}
			stopOverlayTimeout();
		}
	}

	/**
	 * Shows the overlay by setting its visibility to true.
	 */
	public void showOverlay()
	{
		setOverlayVisible(true);
	}

	/**
	 * Hides the overlay by setting its visibility to false.
	 */
	public void hideOverlay()
	{
		setOverlayVisible(false);
	}


	/**
	 * Stops and nullifies the existing overlay timer.
	 */
	public void stopOverlayTimeout()
	{
		if (overlayTimeout != null)
		{
			overlayTimeout.stop();
			overlayTimeout = null;
		}
	}

	/**
	 * Resets the overlay timer to hide the overlay after the configured timeout.
	 */
	public void resetOverlayTimeout()
	{
		stopOverlayTimeout(); // Ensure no existing timer is running
		if (config.enableOverlay())
		{
			var timeoutMS = config.overlayTimeout() * 60 * 1000; // Convert minutes to milliseconds
			overlayTimeout = new javax.swing.Timer(timeoutMS, _ev -> setOverlayVisible(false));
			overlayTimeout.setRepeats(false); // Ensure the timer only runs once
			overlayTimeout.start();
		}
	}


	@Subscribe
	public void onMenuOpened(MenuOpened event)
	{
		Point mousePosition = client.getMouseCanvasPosition();
		Rectangle overlayBounds = damageOverlay.getBounds();

		if (overlayVisible && overlayBounds.contains(mousePosition.getX(), mousePosition.getY()))
		{
			// Get existing menu entries
			MenuEntry[] existingEntries = event.getMenuEntries();

			// Use a dynamic list to hold new entries
			List<MenuEntry> newEntries = new ArrayList<>();

			// Retrieve the current fights
			BoundedQueue<Fight> fights = fightManager.getFights();

			// Only add the "Select Fight" entry if there are active fights
			if (fights != null && !fights.isEmpty())
			{
				// Create the main "Select Fight" menu entry
				MenuEntry selectFightEntry = client.createMenuEntry(-3)
						.setOption("Select Fight")
						.setTarget("")
						.setType(MenuAction.RUNELITE)
						.setType(MenuAction.RUNELITE_OVERLAY)
						.setDeprioritized(true);

				// Create a submenu for selecting a fight
				Menu submenu = selectFightEntry.createSubMenu();
				Iterator<Fight> iterator = fights.descendingIterator();

				int i = -1;
				while (iterator.hasNext())
				{
					Fight fight = iterator.next();
					submenu.createMenuEntry(i)
							.setOption(fight.getFightName() + " (" + Fight.formatTime(fight.getFightLengthTicks()) + ")")
							.setTarget("")
							.setType(MenuAction.RUNELITE_OVERLAY)
							.onClick((e) -> fightManager.setSelectedFight(fight));
					i--;
				}

				// Add the "Select Fight" entry to the new entries list first
				newEntries.add(selectFightEntry);
			}

			// Add "Clear All Fights" entry next
			newEntries.add(client.createMenuEntry(-4)
					.setOption("Clear All Fights")
					.setTarget("")
					.setType(MenuAction.RUNELITE_OVERLAY)
					.onClick((me) -> fightManager.clearFights()));

			// Add "End Current Fight" entry last
			newEntries.add(client.createMenuEntry(-5)
					.setOption("End Current Fight")
					.setTarget("")
					.setType(MenuAction.RUNELITE_OVERLAY)
					.onClick((me) -> fightManager.endCurrentFight()));

			// Convert the new entries list to an array
			MenuEntry[] newEntriesArray = newEntries.toArray(new MenuEntry[0]);

			// Combine existing entries with new entries and set the menu
			client.setMenuEntries(ArrayUtils.addAll(existingEntries, newEntriesArray));
		}
	}


	@Subscribe
	public void onConfigChanged(ConfigChanged event)
	{
		if (!event.getGroup().equals("combatlogger"))
		{
			return;
		}

		switch (event.getKey())
		{
			case "secondaryMetric":
				panel.updatePanel();
				break;

			case "selfDamageMeterColor":
				fightManager.clearPlayerColors();
				panel.updatePanel();
				break;

			case "enableOverlay":
				if (config.enableOverlay())
				{
					showOverlay();
				}
				else
				{
					hideOverlay();
				}
				break;

			case "showOverlayAvatar":
				damageOverlay.clearAvatarCache();
				break;

			case "overlayTimeout":
				resetOverlayTimeout();
				break;

			case "overlayOpacity":
				damageOverlay.setOpacity(config.overlayOpacity());
				break;
		}
	}

	protected static String getCurrentTimestamp()
	{
		return DATE_FORMAT.format(new Date());
	}

	private static String getIdOrName(Actor actor)
	{
		if (actor instanceof NPC)
		{
			return ((NPC) actor).getId() + "-" + ((NPC) actor).getIndex();
		}
		else
		{
			return actor.getName();
		}
	}

	private void createLogFile()
	{
		try
		{
			LOG_FILE = new File(DIRECTORY, LOG_FILE_NAME + "-" + System.currentTimeMillis() + ".txt");
			LOG_FILE.createNewFile();
			logQueueManager.queue("Log Version 1.4.5");
			if (client.getLocalPlayer() != null && client.getLocalPlayer().getName() != null)
			{
				logPlayerName();
				logQueueManager.queue(String.format("%s\tBASE_STATS\t%s", client.getLocalPlayer().getName(), previousBaseStats));
				logQueueManager.queue(String.format("%s\tBOOSTED_STATS\t%s", client.getLocalPlayer().getName(), previousBoostedStats));
			}
		}
		catch (IOException e)
		{
			e.printStackTrace();
		}
	}

	private void logPlayerName()
	{
		logQueueManager.queue(String.format("Logged in player is %s", client.getLocalPlayer().getName()));
	}

	private void sendReminderMessage()
	{
		chatMessageManager
				.queue(QueuedMessage.builder()
						.type(ChatMessageType.GAMEMESSAGE)
						.runeLiteFormattedMessage("<col=cc0000>Combat Logger plugin is logging to .runelite\\combat_log</col>")
						.build());
	}
}

package com.combatlogger.util;

import java.util.Arrays;
import java.util.HashSet;
import java.util.Set;

public class GameObjectIdsToTrack
{
	public static final Set<Integer> GAME_OBJECT_IDS_TO_TRACK = new HashSet<>(Arrays.asList(
			32734, // Verzik web
			32984, // Maiden of Sugadinti blood trail
			45570, // Zebak poison
			45571, // Zebak poison
			45572, // Zebak poison
			45573, // Zebak poison
			45574, // Zebak poison
			45575, // Zebak poison
			45576, // Zebak poison
			57283, // Doom of Mokhaiotl acid blood
			57286 // Doom of Mokhaiotl rock
	));
}

package com.combatlogger.util;

import java.util.Arrays;
import java.util.HashSet;
import java.util.Set;

public class GroundObjectIdsToTrack
{
	public static final Set<Integer> GROUND_OBJECT_IDS_TO_TRACK = new HashSet<>(Arrays.asList(
			32743, // Xarpus exhume
			32744 // Xarpus acidic miasma
	));
}

package com.combatlogger.util;

import net.runelite.api.HeadIcon;
import net.runelite.api.gameval.VarbitID;

import java.util.HashMap;
import java.util.Map;

public class OverheadToPrayer
{
	public static final Map<HeadIcon, Integer> HEADICON_TO_PRAYER_VARBIT = new HashMap<>();

	static
	{
		HEADICON_TO_PRAYER_VARBIT.put(HeadIcon.MELEE, VarbitID.PRAYER_PROTECTFROMMELEE);
		HEADICON_TO_PRAYER_VARBIT.put(HeadIcon.RANGED, VarbitID.PRAYER_PROTECTFROMMISSILES);
		HEADICON_TO_PRAYER_VARBIT.put(HeadIcon.MAGIC, VarbitID.PRAYER_PROTECTFROMMAGIC);
		HEADICON_TO_PRAYER_VARBIT.put(HeadIcon.RETRIBUTION, VarbitID.PRAYER_RETRIBUTION);
		HEADICON_TO_PRAYER_VARBIT.put(HeadIcon.SMITE, VarbitID.PRAYER_SMITE);
		HEADICON_TO_PRAYER_VARBIT.put(HeadIcon.REDEMPTION, VarbitID.PRAYER_REDEMPTION);
	}

}

package com.combatlogger.util;

import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

public class HitSplatUtil
{
	private static final Map<Integer, String> hitsplatNames = initializeHitsplatNames();

	private static Map<Integer, String> initializeHitsplatNames()
	{
		Map<Integer, String> names = new HashMap<>();

		names.put(0, "CORRUPTION");
		names.put(4, "DISEASE");
		names.put(5, "VENOM");
		names.put(6, "HEAL");
		names.put(11, "CYAN_UP");
		names.put(12, "BLOCK_ME");
		names.put(13, "BLOCK_OTHER");
		names.put(15, "CYAN_DOWN");
		names.put(16, "DAMAGE_ME");
		names.put(17, "DAMAGE_OTHER");
		names.put(18, "DAMAGE_ME_CYAN");
		names.put(19, "DAMAGE_OTHER_CYAN");
		names.put(20, "DAMAGE_ME_ORANGE");
		names.put(21, "DAMAGE_OTHER_ORANGE");
		names.put(22, "DAMAGE_ME_YELLOW");
		names.put(23, "DAMAGE_OTHER_YELLOW");
		names.put(24, "DAMAGE_ME_WHITE");
		names.put(25, "DAMAGE_OTHER_WHITE");
		names.put(43, "DAMAGE_MAX_ME");
		names.put(44, "DAMAGE_MAX_ME_CYAN");
		names.put(45, "DAMAGE_MAX_ME_ORANGE");
		names.put(46, "DAMAGE_MAX_ME_YELLOW");
		names.put(47, "DAMAGE_MAX_ME_WHITE");
		names.put(53, "DAMAGE_ME_POISE");
		names.put(54, "DAMAGE_OTHER_POISE");
		names.put(55, "DAMAGE_MAX_ME_POISE");
		names.put(60, "PRAYER_DRAIN");
		names.put(65, "POISON");
		names.put(67, "BLEED");
		names.put(71, "SANITY_DRAIN");
		names.put(72, "SANITY_RESTORE");
		names.put(73, "DOOM");
		names.put(74, "BURN");
		names.put(79, "DAMAGE_BOAT");

		return names;
	}

	public static final List<String> NON_DAMAGE_HITSPLATS = Arrays.asList(
			"CORRUPTION",
			"DISEASE",
			"HEAL",
			"CYAN_UP",
			"PRAYER_DRAIN",
			"SANITY_DRAIN",
			"SANITY_RESTORE"
	);

	public static String getHitsplatName(int hitsplatType)
	{
		return hitsplatNames.getOrDefault(hitsplatType, "Unknown_" + hitsplatType);
	}

	/**
	 * Convert a "ME" hitsplat from another player into an "OTHER" hitsplat
	 * Only results in hitsplat names that already exist for lookup purposes
	 * e.g. DAMAGE_MAX_ME -> DAMAGE_OTHER
	 */
	public static String replaceMeWithExistingOther(String hitsplatName)
	{
		return hitsplatName.replace("MAX_ME", "OTHER").replace("ME", "OTHER");
	}

	/**
	 * Convert a "ME" hitsplat from another player into an "OTHER" hitsplat
	 * Can result in hitsplat names that don't normally exist
	 * e.g. DAMAGE_MAX_ME -> DAMAGE_MAX_OTHER
	 */
	public static String replaceMeWithNewOther(String hitsplatName)
	{
		return hitsplatName.replace("ME", "OTHER");
	}
}

package com.combatlogger.util;

import net.runelite.api.gameval.AnimationID;
import net.runelite.api.gameval.ItemID;

import java.util.Arrays;
import java.util.List;

public class AnimationIds
{
	public static final List<Integer> MELEE_IDS = Arrays.asList(
			AnimationID.HUMAN_SWORD_SLASH, // Slash, Swift blade, Osmumten's fang
			AnimationID.HUMAN_OSMUMTENS_FANG, // Osmumten's fang stab
			AnimationID.WEAPON_SWORD_OSMUMTEN03_SPECIAL, // Osmumten's fang spec
			AnimationID.HUMAN_DHUNTER_LANCE_ATTACK, // Dragon hunter lance stab, Swift blade
			AnimationID.HUMAN_DHUNTER_LANCE_SLASH, // Dragon hunter lance slash
			AnimationID.HUMAN_DHUNTER_LANCE_CRUSH, // Dragon hunter lance crush
			AnimationID.HUMAN_AXE_CHOP, // Staff bash
			AnimationID.HUMAN_AXE_HACK, // Axe
			AnimationID.HUMAN_BLUNT_SPIKE, // Pickaxe smash, Inquisitor's mace stab
			AnimationID.HUMAN_INQUISITORS_MACE_CRUSH, // Inquisitor's mace crush
			AnimationID.HUMAN_BLUNT_POUND, // Crush, DWH, Ham joint
			AnimationID.HUMAN_DHSWORD_CHOP, // 2h crush
			AnimationID.HUMAN_DHSWORD_SLASH, // 2h slash
			AnimationID.HUMAN_SPEAR_SPIKE, // Spear stab, Chally, Zamorakian hasta
			AnimationID.HUMAN_SPEAR_LUNGE, // Spear crush
			AnimationID.HUMAN_SCYTHE_SWEEP, // Spear slash, Chally
			AnimationID.DRAGON_HALBERD_SPECIAL_ATTACK, // Halberd spec
			AnimationID.DRAGON_WARHAMMER_SA_PLAYER, // Dragon warhammer spec
			AnimationID.HUMAN_SPECIAL02_VOIDWAKER, // Voidwaker spec
			AnimationID.HUMAN_TOADCANNON_ATTACK, // Goblin paint cannon
			AnimationID.HUMAN_DDAGGER_LUNGE, // Dragon dagger stab
			AnimationID.HUMAN_DDAGGER_HACK, // Dragon dagger slash
			AnimationID.PUNCTURE, // Dragon dagger spec
			AnimationID.WILD_CAVE_CHAINMACE_CRUSH, // Ursine/Viggora mace
			AnimationID.HUMAN_SPECIAL02_URSINE, // Ursine mace spec
			AnimationID.HUMAN_UNARMEDPUNCH, // Punch
			AnimationID.HUMAN_UNARMEDKICK, // Kick
			AnimationID.HUMAN_DSPEAR_STAB, // Zamorakian hasta, Keris partisan
			AnimationID.HUMAN_SWORD_STAB, // Stab
			AnimationID.HUMAN_STAFF_PUMMEL, // Crozier crush
			AnimationID.HUMAN_STAFFORB_PUMMEL, // Keris partisan crush, Zamorakian hasta crush
			AnimationID.TOA_KERIS_PARTISAN_SPECIAL01, // Keris partisan of corruption spec
			AnimationID.D_CLAWS_PUNCH, // Claw stab
			AnimationID.HUMAN_DRAGON_CLAWS_SPEC, // Claw spec
			AnimationID.HUMAN_WEAPON_BURNING_CLAWS_02_SPEC, // Burning claws spec
			AnimationID.SLAYER_ABYSSAL_WHIP_ATTACK, // Whip
			AnimationID.DARK_SPEC_PLAYER, // Arclight spec
			AnimationID.ABYSSAL_DAGGER_HACK, // Abyssal dagger slash
			AnimationID.ABYSSAL_DAGGER_LUNGE, // Abyssal dagger stab
			AnimationID.ABYSSAL_DAGGER_SPECIAL, // Abyssal dagger spec
			AnimationID.ABYSSAL_BLUDGEON_CRUSH, // Abyssal bludgeon
			AnimationID.ABYSSAL_BLUDGEON_SPECIAL_ATTACK, // Abyssal bludgeon spec
			AnimationID.HUMAN_DRAGON_SWORD_SPEC, // Dragon sword spec
			AnimationID.GHRAZI_RAPIER_ATTACK, // Rapier
			AnimationID.HUMAN_ZAMORAKSPEAR_STAB, // Zamorakian spear
			AnimationID.HUMAN_ZAMORAKSPEAR_SLASH, // Blue moon spear slash
			AnimationID.HUMAN_ZAMORAKSPEAR_LUNGE, // Blue moon spear crush
			AnimationID.BARROW_GUTHAN_CRUSH, // Verac's flail, Bone mace
			AnimationID.BARROW_DHAROK_SLASH, // Dharok's greataxe slash
			AnimationID.BARROW_DHAROK_CRUSH, // Dharok's greataxe crush
			AnimationID.BARROW_TORAG_CRUSH, // Torag's hammer
			AnimationID.BARROWS_WAR_SPEAR_STAB, // Guthan's warspear stab
			AnimationID.BARROWS_WAR_SPEAR_SLASH, // Guthan's warspear slash
			AnimationID.BARROWS_WAR_SPEAR_CRUSH, // Guthan's warspear crush
			AnimationID.DTTD_PLAYER_STAB_BONE_DAGGER, // Bone dagger spec
			AnimationID.SCYTHE_OF_VITUR_ATTACK, // Scythe
			AnimationID.IVANDIS_FLAIL_ATTACK, // Blisterwood flail
			AnimationID.BATTLEAXE_CRUSH, // Leaf-bladed battleaxe crush, Zombie axe crush
			AnimationID.GODWARS_GODSWORD_ZAMORAK_PLAYER, // Leaf-bladed battleaxe slash, Zombie axe slash
			AnimationID.ANCIENT_AXE_SLASH, // Soulreaper Axe crush
			AnimationID.ANCIENT_AXE_CRUSH, // Soulreaper Axe slash
			AnimationID.ANCIENT_AXE_SPECIAL, // Soulreaper Axe spec
			AnimationID.DH_SWORD_UPDATE_TURNONSPOT, // Godsword
			AnimationID.DH_SWORD_UPDATE_SLASH, // Saradomin sword, Godswords
			AnimationID.DH_SWORD_UPDATE_SMASH, // Saradomin sword, Godswords
			AnimationID.DH_SWORD_UPDATE_BLOCK, // Saradomin sword, Godswords
			AnimationID.SARADOMIN_SWORD_SPECIAL_PLAYER, // Saradomin sword spec
			AnimationID.BLESSED_SARADOMIN_SWORD_SPECIAL_PLAYER, // Saradomin's blessed sword spec
			AnimationID.ZGS_SPECIAL_PLAYER, // Zamorak godsword spec
			AnimationID.ZGS_SPECIAL_ORNATE_PLAYER, // Zamorak godsword spec
			AnimationID.SGS_SPECIAL_PLAYER, // Saradomin godsword spec
			AnimationID.SGS_SPECIAL_ORNATE_PLAYER, // Saradomin godsword spec
			AnimationID.BGS_SPECIAL_PLAYER, // Bandos godsword spec
			AnimationID.BGS_SPECIAL_ORNATE_PLAYER, // Bandos godsword spec
			AnimationID.AGS_SPECIAL_PLAYER, // Armadyl godsword spec
			AnimationID.AGS_SPECIAL_ORNATE_PLAYER, // Armadyl godsword spec
			AnimationID.NGS_SPECIAL_PLAYER, // Ancient godsword spec
			AnimationID.BARROWS_QUARTERSTAFF_ATTACK, // Ahrim's staff bash
			AnimationID.BRAIN_PLAYER_ANCHOR_ATTACK, // Barrelchest anchor
			AnimationID.BRAIN_PLAYER_ANCHOR_SPECIAL_ATTACK, // Barrelchest anchor spec
			AnimationID.HUMAN_DINHS_BULWARK_BASH, // Dinh's bulwark
			AnimationID.QIP_DRAGON_SLAYER_PLAYER_UNLEASHING_FIRE, // Dragonfire shield spec
			AnimationID.HUMAN_ELDER_MAUL_ATTACK, // Maul
			AnimationID.HUMAN_ELDER_MAUL_SPEC, // Elder maul spec
			AnimationID.SLAYER_GRANITE_MAUL_ATTACK, // Gadderhammer, Granite maul
			AnimationID.SLAYER_GRANITE_MAUL_DEFEND, // Granite maul block
			AnimationID.SLAYER_GRANITE_MAUL_SPECIAL_ATTACK, // Granite maul spec
			AnimationID.STAB_WOLBANEDAGGER, // Wolfbane stab
			AnimationID.SHATTER, // Dragon mace spec
			AnimationID.DRAGON_TWO_HANDED_SWORD, // Dragon 2h spec
			AnimationID.CHAIR_SIT_READY_THRONE_5B, // Dragon longsword spec
			AnimationID.CHAIR_SIT_READY_THRONE_3B, // Dragon scimitar spec
			AnimationID.HUMAN_DHSWORD_STAB, // Dragon spear spec
			AnimationID.PMOON_MACUAHUITL_CRUSH // Dual macuahuitl
	);

	public static final List<Integer> RANGED_IDS = Arrays.asList(
			AnimationID.HUMAN_BOW, // Bow
			AnimationID.SNAPSHOT, // Magic shortbow spec
			AnimationID.HUMAN_STAKE2_PVN, // Rune knife, thrownaxe
			AnimationID.HUMAN_DRAGON_KNIFE, // Dragon knife
			AnimationID.HUMAN_DRAGON_KNIFE_P, // Dragon knife poisoned
			AnimationID.HUMAN_DRAGON_TKNIVES_SPEC, // Dragon knife spec
			AnimationID.SNAKEBOSS_BLOWPIPE_ATTACK, // Blowpipe
			AnimationID.SNAKEBOSS_BLOWPIPE_ATTACK_ORNAMENT, // Blazing Blowpipe
			AnimationID.II_HUMAN_DART_THROW_PVN, // Dart throw
			AnimationID.HUMAN_CHINCHOMPA_ATTACK_PVN, // Chinchompa
			AnimationID.BARROWS_REPEATING_CROSSBOW_FIRE, // Karil's crossbow
			AnimationID.HUMAN_SPECIAL01_WEBWEAVER, // Webweaver bow spec
			AnimationID.XBOWS_HUMAN_FIRE_AND_RELOAD_PVN, // Crossbow
			AnimationID.ZCB_ATTACK_PVN, // Zaryte crossbow
			AnimationID.HUMAN_XBOWS_LEAGUE03_ATTACK_PVN, // Rune crossbow (or)
			AnimationID.DTTD_PLAYER_FIRE_BONE_CROSSBOW_PVN, // Dorgeshuun crossbow spec
			AnimationID.BALLISTA_ATTACK_PVN, // Ballista
			AnimationID.HUMAN_WEAPON_BOW_VENATOR01_SHOOT, // Venator bow
			AnimationID.HUMAN_ATLATL_ATTACK_RANGED_01, // Eclipse atlatl
			AnimationID.HUMAN_SPECIAL_ATLATL_01, // Eclipse atlatl spec
			AnimationID.HUMAN_GLAIVE_RALOS01_UNCHARGED_SPECIAL, // Tonalztics of ralos (Uncharged)
			AnimationID.HUMAN_GLAIVE_RALOS01_UNCHARGED_THROW, // Tonalztics of ralos
			AnimationID.HUMAN_GLAIVE_RALOS01_CHARGED_THROW, // Tonalztics of ralos
			AnimationID.HUMAN_GLAIVE_RALOS01_CHARGED_SPECIAL // Tonalztics of ralos spec
	);

	public static final List<Integer> MAGE_IDS = Arrays.asList(
			AnimationID.HUMAN_CASTENTANGLE, // Bind, snare, entangle without staff
			AnimationID.HUMAN_CASTENTANGLE_STAFF, // Bind, snare, entangle with staff
			AnimationID.HUMAN_CASTSTRIKE, // Strike, Bolt, and Blast without staff
			AnimationID.HUMAN_CASTSTRIKE_STAFF, // Strike, Bolt, and Blast with staff
			AnimationID.HUMAN_CASTWAVE, // Wave without staff
			AnimationID.HUMAN_CASTWAVE_STAFF, // Wave with staff, Sanguinesti staff, Tridents
			AnimationID.HUMAN_CASTCRUMBLEUNDEAD, // Crumble undead without staff
			AnimationID.HUMAN_CASTCRUMBLEUNDEAD_STAFF, // Crumble undead with staff
			AnimationID.SLAYER_MAGICDART_CAST, // Magic dart
			AnimationID.HUMAN_CAST_SURGE, // Surge, Harmonised nightmare staff
			AnimationID.HUMAN_CASTING, // Flames of Zamorak, Saradomin Strike, Claws of Guthix
			AnimationID.HUMAN_AXE_CHOP, // Bone staff
			AnimationID.HUMAN_CASTIBANBLAST, // Iban blast
			AnimationID.NIGHTMARE_STAFF_SPECIAL, // Eldritch/Volatile nightmare staff spec
			AnimationID.ZAROS_CASTING, // Rush and Blitz
			AnimationID.ZAROS_VERTICAL_CASTING, // Burst and Barrage
			AnimationID.TOA_SOT_CAST_B, // Tumeken's shadow
			AnimationID.POG_WARPED_SCEPTRE_ATTACK, // Warped sceptre
			AnimationID.HUMAN_SPELLCAST_GRASP, // Arceuus grasp
			AnimationID.HUMAN_SPELLCAST_DEMONBANE // Arceuus demonbane
	);

	public static int getTicks(int attackAnimationId, int weaponId)
	{
		int ticks = 0;
		switch (attackAnimationId)
		{
			// 2 Tick Animations (and alternatives)
			case AnimationID.HUMAN_STAKE2_PVN: // Rune knife
				if (weaponId == ItemID.BRONZE_THROWNAXE || weaponId == ItemID.IRON_THROWNAXE || weaponId == ItemID.STEEL_THROWNAXE || weaponId == ItemID.MITHRIL_THROWNAXE
						|| weaponId == ItemID.ADAMNT_THROWNAXE || weaponId == ItemID.RUNE_THROWNAXE || weaponId == ItemID.DRAGON_THROWNAXE)
				{
					ticks = 4;
					break;
				}
			case AnimationID.HUMAN_DRAGON_KNIFE: // Dragon knife
			case AnimationID.HUMAN_DRAGON_KNIFE_P: // Dragon knife poisoned
			case AnimationID.HUMAN_DRAGON_TKNIVES_SPEC: // Dragon knife spec
			case AnimationID.SNAKEBOSS_BLOWPIPE_ATTACK: // Blowpipe
			case AnimationID.SNAKEBOSS_BLOWPIPE_ATTACK_ORNAMENT: // Blazing Blowpipe
			case AnimationID.II_HUMAN_DART_THROW_PVN: // Dart throw
				ticks = 2;
				break;

			// 3 Tick Animations (and alternatives)
			case AnimationID.HUMAN_BOW: // Bow
				if (weaponId == ItemID.TWISTED_BOW)
				{
					ticks = 5;
					break;
				}
				else if (weaponId == ItemID.BOW_OF_FAERDHINEN || weaponId == ItemID.BOW_OF_FAERDHINEN_INFINITE || weaponId == ItemID.BOW_OF_FAERDHINEN_INFINITE_DUMMY || weaponId == ItemID.BOW_OF_FAERDHINEN_INFINITE_ITHELL
						|| weaponId == ItemID.BOW_OF_FAERDHINEN_INFINITE_IORWERTH || weaponId == ItemID.BOW_OF_FAERDHINEN_INFINITE_TRAHAEARN || weaponId == ItemID.BOW_OF_FAERDHINEN_INFINITE_CADARN
						|| weaponId == ItemID.BOW_OF_FAERDHINEN_INFINITE_CRWYS || weaponId == ItemID.BOW_OF_FAERDHINEN_INFINITE_MEILYR || weaponId == ItemID.BOW_OF_FAERDHINEN_INFINITE_AMLODD)
				{
					ticks = 4;
					break;
				}
			case AnimationID.HUMAN_TOADCANNON_ATTACK: // Goblin paint cannon
			case AnimationID.HUMAN_CHINCHOMPA_ATTACK_PVN: // Chinchompa
			case AnimationID.BARROWS_REPEATING_CROSSBOW_FIRE: // Karil's crossbow
			case AnimationID.HUMAN_SPECIAL01_WEBWEAVER: // Webweaver bow spec
			case AnimationID.HUMAN_ATLATL_ATTACK_RANGED_01: // Eclipse atlatl
			case AnimationID.HUMAN_SPECIAL_ATLATL_01: // Eclipse atlatl spec
				ticks = 3;
				break;

			// 4 Tick Animations (and alternatives)
			case AnimationID.HUMAN_SPEAR_SPIKE: // Spear stab, Chally,  Zamorakian Hasta
			case AnimationID.HUMAN_SCYTHE_SWEEP: // Spear slash, Chally
				if (weaponId == ItemID.CRYSTAL_HALBERD || weaponId == ItemID.CRYSTAL_HALBERD_2500)
				{
					ticks = 7;
					break;
				}
				else if (weaponId == ItemID.SLAYER_LEAFBLADED_SPEAR || weaponId == ItemID.NOXIOUS_HALBERD)
				{
					ticks = 5;
					break;
				}
			case AnimationID.HUMAN_SPEAR_LUNGE: // Spear crush
			case AnimationID.HUMAN_DDAGGER_LUNGE: // Dragon dagger stab
			case AnimationID.HUMAN_DDAGGER_HACK: // Dragon dagger slash
			case AnimationID.PUNCTURE: // Dragon dagger spec
			case AnimationID.WILD_CAVE_CHAINMACE_CRUSH: // Ursine/Viggora mace
			case AnimationID.HUMAN_SPECIAL02_URSINE: // Ursine mace spec
			case AnimationID.HUMAN_UNARMEDPUNCH: // Punch
			case AnimationID.HUMAN_UNARMEDKICK: // Kick
			case AnimationID.HUMAN_DSPEAR_STAB: // Zamorakian Hasta
			case AnimationID.HUMAN_SWORD_STAB: // Stab
			case AnimationID.HUMAN_STAFFORB_PUMMEL: // Keris partisan crush, Zamorakian hasta crush
			case AnimationID.HUMAN_SWORD_SLASH: // Slash, Swift blade, Osmumten's fang
				if (weaponId == ItemID.SWIFT_BLADE)
				{
					ticks = 3;
					break;
				}
				if (weaponId == ItemID.OSMUMTENS_FANG || weaponId == ItemID.OSMUMTENS_FANG_ORNAMENT)
				{
					ticks = 5;
					break;
				}
			case AnimationID.D_CLAWS_PUNCH: // Claw stab
			case AnimationID.HUMAN_DRAGON_CLAWS_SPEC: // Claw spec
			case AnimationID.HUMAN_WEAPON_BURNING_CLAWS_02_SPEC: // Burning claws spec
			case AnimationID.SLAYER_ABYSSAL_WHIP_ATTACK: // Whip
			case AnimationID.DARK_SPEC_PLAYER: // Arclight spec
			case AnimationID.ABYSSAL_DAGGER_HACK: // Abyssal dagger slash
			case AnimationID.ABYSSAL_DAGGER_LUNGE: // Abyssal dagger stab
			case AnimationID.ABYSSAL_DAGGER_SPECIAL: // Abyssal dagger spec
			case AnimationID.ABYSSAL_BLUDGEON_CRUSH: // Abyssal bludgeon
			case AnimationID.ABYSSAL_BLUDGEON_SPECIAL_ATTACK: // Abyssal bludgeon spec
			case AnimationID.HUMAN_DRAGON_SWORD_SPEC: // Dragon sword spec
			case AnimationID.GHRAZI_RAPIER_ATTACK: // Rapier
			case AnimationID.BARROW_GUTHAN_CRUSH: // Verac's flail, Bone mace
				if (weaponId == ItemID.BARROWS_VERAC_WEAPON || weaponId == ItemID.BARROWS_VERAC_WEAPON_100 || weaponId == ItemID.BARROWS_VERAC_WEAPON_75 || weaponId == ItemID.BARROWS_VERAC_WEAPON_50 || weaponId == ItemID.BARROWS_VERAC_WEAPON_25)
				{
					ticks = 5;
					break;
				}
			case AnimationID.HUMAN_DHUNTER_LANCE_ATTACK: // Dragon hunter lance stab, Swift blade
				if (weaponId == ItemID.SWIFT_BLADE)
				{
					ticks = 3;
					break;
				}
			case AnimationID.DTTD_PLAYER_STAB_BONE_DAGGER: // Bone dagger spec
			case AnimationID.HUMAN_DHUNTER_LANCE_SLASH: // Dragon hunter lance slash
			case AnimationID.HUMAN_DHUNTER_LANCE_CRUSH: // Dragon hunter lance crush
			case AnimationID.HUMAN_INQUISITORS_MACE_CRUSH: // Inquisitor's mace crush
			case AnimationID.SARADOMIN_SWORD_SPECIAL_PLAYER: // Saradomin sword spec
			case AnimationID.BLESSED_SARADOMIN_SWORD_SPECIAL_PLAYER: // Saradomin's blessed sword spec
			case AnimationID.HUMAN_ZAMORAKSPEAR_STAB: // Zamorakian spear
			case AnimationID.STAB_WOLBANEDAGGER: // Wolfbane stab
			case AnimationID.SHATTER: // Dragon mace spec
			case AnimationID.CHAIR_SIT_READY_THRONE_3B: // Dragon scimitar spec
			case AnimationID.HUMAN_DHSWORD_STAB: // Dragon spear spec
			case AnimationID.PMOON_MACUAHUITL_CRUSH: // Dual macuahuitl - this is a weird one because with the Bloodrager set effect it's sometimes 3 tick
			case AnimationID.HUMAN_WEAPON_BOW_VENATOR01_SHOOT: // Venator bow
			case AnimationID.SNAPSHOT: // Magic shortbow spec
			case AnimationID.DTTD_PLAYER_FIRE_BONE_CROSSBOW_PVN: // Dorgeshuun crossbow spec
			case AnimationID.HUMAN_CASTWAVE_STAFF: // Wave with staff, Sanguinesti staff, Tridents
			case AnimationID.POG_WARPED_SCEPTRE_ATTACK: // Warped sceptre
			case AnimationID.HUMAN_SPECIAL02_VOIDWAKER: // Voidwaker spec
				ticks = 4;
				break;

			// 5 Tick Animations (and alternatives)
			case AnimationID.HUMAN_AXE_CHOP: // Staff bash
				if (weaponId == ItemID.DRAGON_CLAWS || weaponId == ItemID.BH_DRAGON_CLAWS_CORRUPTED || weaponId == ItemID.BONE_CLAWS || weaponId == ItemID.RAT_BONE_STAFF)
				{
					ticks = 4;
					break;
				}
			case AnimationID.HUMAN_AXE_HACK: // Axe
			case AnimationID.HUMAN_BLUNT_SPIKE: // Pickaxe smash, Inquisitor's mace stab
				if (weaponId == ItemID.INQUISITORS_MACE)
				{
					ticks = 4;
					break;
				}
			case AnimationID.HUMAN_STAFF_PUMMEL: // Crozier crush
			case AnimationID.HUMAN_ZAMORAKSPEAR_SLASH: // Blue moon spear slash
			case AnimationID.HUMAN_ZAMORAKSPEAR_LUNGE: // Blue moon spear crush
			case AnimationID.BARROW_TORAG_CRUSH: // Torag's hammer
			case AnimationID.BARROWS_WAR_SPEAR_STAB: // Guthan's warspear stab
			case AnimationID.BARROWS_WAR_SPEAR_SLASH: // Guthan's warspear slash
			case AnimationID.BARROWS_WAR_SPEAR_CRUSH: // Guthan's warspear crush
			case AnimationID.SCYTHE_OF_VITUR_ATTACK: // Scythe
			case AnimationID.IVANDIS_FLAIL_ATTACK: // Blisterwood flail
			case AnimationID.BATTLEAXE_CRUSH: // Leaf-bladed battleaxe crush, Zombie axe crush
			case AnimationID.GODWARS_GODSWORD_ZAMORAK_PLAYER: // Leaf-bladed battleaxe slash, Zombie axe slash
			case AnimationID.ANCIENT_AXE_CRUSH: // Soulreaper Axe slash
			case AnimationID.ANCIENT_AXE_SPECIAL: // Soulreaper Axe spec
			case AnimationID.HUMAN_OSMUMTENS_FANG: // Osmumten's Fang Stab
			case AnimationID.WEAPON_SWORD_OSMUMTEN03_SPECIAL: // Osmumten's fang spec
			case AnimationID.SLAYER_GRANITE_MAUL_ATTACK: // Gadderhammer, Granite maul
				if (weaponId == ItemID.GRANITE_MAUL || weaponId == ItemID.GRANITE_MAUL_PLUS || weaponId == ItemID.GRANITE_MAUL_PRETTY || weaponId == ItemID.GRANITE_MAUL_PRETTY_PLUS)
				{
					ticks = 7;
					break;
				}
			case AnimationID.CLEAVE: // Dragon longsword spec
			case AnimationID.XBOWS_HUMAN_FIRE_AND_RELOAD_PVN: // Crossbow
				if (weaponId == ItemID.DTTD_BONE_CROSSBOW)
				{
					ticks = 4;
					break;
				}
			case AnimationID.HUMAN_XBOWS_LEAGUE03_ATTACK_PVN: // Rune crossbow (or)
			case AnimationID.ZCB_ATTACK_PVN: // Zaryte Crossbow
			case AnimationID.HUMAN_CASTENTANGLE: // Bind, snare, entangle without staff
			case AnimationID.HUMAN_CASTENTANGLE_STAFF: // Bind, snare, entangle with staff
			case AnimationID.HUMAN_CASTSTRIKE: // Strike, Bolt, and Blast without staff
			case AnimationID.HUMAN_CASTSTRIKE_STAFF: // Strike, Bolt, and Blast with staff
			case AnimationID.HUMAN_CASTWAVE: // Wave without staff
			case AnimationID.HUMAN_CASTCRUMBLEUNDEAD: // Crumble undead without staff
			case AnimationID.HUMAN_CASTCRUMBLEUNDEAD_STAFF: // Crumble undead with staff
			case AnimationID.SLAYER_MAGICDART_CAST: // Magic dart
			case AnimationID.HUMAN_CAST_SURGE: // Surge, Harmonised nightmare staff
				if (weaponId == ItemID.NIGHTMARE_STAFF_HARMONISED)
				{
					ticks = 4;
					break;
				}
				if (weaponId == ItemID.TWINFLAME_STAFF)
				{
					ticks = 6;
					break;
				}
			case AnimationID.HUMAN_CASTING: // Flames of Zamorak, Saradomin Strike, Claws of Guthix
			case AnimationID.HUMAN_CASTIBANBLAST: // Iban blast
			case AnimationID.NIGHTMARE_STAFF_SPECIAL: // Eldritch/Volatile nightmare staff spec
			case AnimationID.ZAROS_CASTING: // Rush and Blitz
			case AnimationID.ZAROS_VERTICAL_CASTING: // Burst and Barrage
			case AnimationID.TOA_SOT_CAST_B: // Tumeken's shadow
			case AnimationID.HUMAN_SPELLCAST_GRASP: // Arceuus grasp
			case AnimationID.HUMAN_SPELLCAST_DEMONBANE: // Arceuus demonbane
				ticks = 5;
				break;

			// 6 Tick Animations (and alternatives)
			case AnimationID.HUMAN_BLUNT_POUND:
				if (weaponId == ItemID.DRAGON_WARHAMMER || weaponId == ItemID.BH_DRAGON_WARHAMMER_CORRUPTED)
				{
					ticks = 6;
				}
				else if (weaponId == ItemID.JOINT_OF_HAM)
				{
					ticks = 3;
				}
				else // Pickaxe and axe
				{
					ticks = 5;
				}
				break;
			case AnimationID.DRAGON_WARHAMMER_SA_PLAYER: // Dragon warhammer spec
			case AnimationID.DH_SWORD_UPDATE_TURNONSPOT: // Godsword
			case AnimationID.DH_SWORD_UPDATE_SLASH: // Saradomin sword, Godswords
			case AnimationID.DH_SWORD_UPDATE_SMASH: // Saradomin sword, Godswords
			case AnimationID.DH_SWORD_UPDATE_BLOCK: // Saradomin sword, Godswords
				if (weaponId == ItemID.SARADOMIN_SWORD || weaponId == ItemID.BLESSED_SARADOMIN_SWORD || weaponId == ItemID.BLESSED_SARADOMIN_SWORD_DEGRADED)
				{
					ticks = 4;
					break;
				}
			case AnimationID.BARROWS_QUARTERSTAFF_ATTACK: // Ahrim's staff bash
			case AnimationID.BRAIN_PLAYER_ANCHOR_ATTACK: // Barrelchest anchor
			case AnimationID.BRAIN_PLAYER_ANCHOR_SPECIAL_ATTACK: // Barrelchest anchor spec
			case AnimationID.HUMAN_DINHS_BULWARK_BASH: // Dinh's bulwark
			case AnimationID.HUMAN_ELDER_MAUL_ATTACK: // Maul
			case AnimationID.HUMAN_ELDER_MAUL_SPEC: // Elder maul spec
			case AnimationID.BALLISTA_ATTACK_PVN: // Ballista
			case AnimationID.ZGS_SPECIAL_PLAYER: // Zamorak godsword spec
			case AnimationID.ZGS_SPECIAL_ORNATE_PLAYER: // Zamorak godsword spec
			case AnimationID.SGS_SPECIAL_PLAYER: // Saradomin godsword spec
			case AnimationID.SGS_SPECIAL_ORNATE_PLAYER: // Saradomin godsword spec
			case AnimationID.BGS_SPECIAL_PLAYER: // Bandos godsword spec
			case AnimationID.BGS_SPECIAL_ORNATE_PLAYER: // Bandos godsword spec
			case AnimationID.AGS_SPECIAL_PLAYER: // Armadyl godsword spec
			case AnimationID.AGS_SPECIAL_ORNATE_PLAYER: // Armadyl godsword spec
			case AnimationID.NGS_SPECIAL_PLAYER: // Ancient godsword spec
			case AnimationID.HUMAN_GLAIVE_RALOS01_UNCHARGED_SPECIAL: // Tonalztics of ralos (Uncharged)
			case AnimationID.HUMAN_GLAIVE_RALOS01_UNCHARGED_THROW: // Tonalztics of ralos
			case AnimationID.HUMAN_GLAIVE_RALOS01_CHARGED_THROW: // Tonalztics of ralos
			case AnimationID.HUMAN_GLAIVE_RALOS01_CHARGED_SPECIAL:// Tonalztics of ralos spec
				ticks = 6;
				break;

			// 7 Tick Animations
			case AnimationID.HUMAN_DHSWORD_CHOP: // 2h crush
			case AnimationID.HUMAN_DHSWORD_SLASH: // 2h slash
			case AnimationID.DRAGON_HALBERD_SPECIAL_ATTACK: // Halberd spec
				if (weaponId == ItemID.NOXIOUS_HALBERD)
				{
					ticks = 5;
					break;
				}
			case AnimationID.BARROW_DHAROK_SLASH: // Dharok's greataxe slash
			case AnimationID.BARROW_DHAROK_CRUSH: // Dharok's greataxe crush
			case AnimationID.SLAYER_GRANITE_MAUL_DEFEND: // Granite maul block
			case AnimationID.DRAGON_TWO_HANDED_SWORD: // Dragon 2h spec
				ticks = 7;
				break;

			// 8 Tick Animations
			case AnimationID.TOA_KERIS_PARTISAN_SPECIAL01: // Keris partisan of corruption spec
				ticks = 8;
				break;
		}
		return ticks;
	}
}

package com.combatlogger.util;

import net.runelite.api.gameval.NpcID;

import java.util.Arrays;
import java.util.HashSet;
import java.util.Set;

public class NpcIdsToTrack
{
	public static final Set<Integer> NPC_IDS_TO_TRACK = new HashSet<>(Arrays.asList(
			// Chambers of Xeric
			NpcID.RAIDS_TEKTON_WAITING,
			NpcID.RAIDS_TEKTON_WALKING_STANDARD,
			NpcID.RAIDS_TEKTON_FIGHTING_STANDARD,
			NpcID.RAIDS_TEKTON_WALKING_ENRAGED,
			NpcID.RAIDS_TEKTON_FIGHTING_ENRAGED,
			NpcID.RAIDS_TEKTON_HAMMERING,
			NpcID.RAIDS_VESPULA_FLYING,
			NpcID.RAIDS_VESPULA_ENRAGED,
			NpcID.RAIDS_VESPULA_WALKING,
			NpcID.RAIDS_VESPULA_PORTAL,
			NpcID.RAIDS_VESPULA_CATERPILLAR_HEALTHY,
			NpcID.RAIDS_VESPULA_CATERPILLAR_SICKLY,
			NpcID.RAIDS_VESPULA_CATERPILLAR_INFECTED,
			NpcID.RAIDS_VESPULA_CATERPILLAR_DEAD,
			NpcID.RAIDS_VESPULA_VESPINE_FLYING,
			NpcID.RAIDS_VESPULA_VESPINE_WALKING,
			NpcID.RAIDS_VASANISTIRIO_WALKING,
			NpcID.RAIDS_VASANISTIRIO_HEALING,
			NpcID.RAIDS_VASANISTIRIO_CRYSTAL,
			NpcID.RAIDS_VANGUARD_DORMANT,
			NpcID.RAIDS_VANGUARD_WALKING,
			NpcID.RAIDS_VANGUARD_MELEE,
			NpcID.RAIDS_VANGUARD_RANGED,
			NpcID.RAIDS_VANGUARD_MAGIC,
			NpcID.RAIDS_STONEGUARDIANS_LEFT,
			NpcID.RAIDS_STONEGUARDIANS_RIGHT,
			NpcID.RAIDS_STONEGUARDIANS_LEFT_DEAD,
			NpcID.RAIDS_STONEGUARDIANS_RIGHT_DEAD,
			NpcID.RAIDS_LIZARDSHAMAN_A,
			NpcID.RAIDS_LIZARDSHAMAN_B,
			NpcID.RAIDS_LIZARDSHAMAN_BLOCKER,
			NpcID.RAIDS_LASERCRABS_CRAB_GREY,
			NpcID.RAIDS_LASERCRABS_CRAB_RED,
			NpcID.RAIDS_LASERCRABS_CRAB_GREEN,
			NpcID.RAIDS_LASERCRABS_CRAB_BLUE,
			NpcID.RAIDS_LASERCRABS_ENERGY_WHITE,
			NpcID.RAIDS_LASERCRABS_ENERGY_RED,
			NpcID.RAIDS_LASERCRABS_ENERGY_GREEN,
			NpcID.RAIDS_LASERCRABS_ENERGY_BLUE,
			NpcID.RAIDS_ICEDEMON_NONCOMBAT,
			NpcID.RAIDS_ICEDEMON_COMBAT,
			NpcID.RAIDS_ICEFIEND,
			NpcID.RAIDS_SKELETONMYSTIC_A,
			NpcID.RAIDS_SKELETONMYSTIC_B,
			NpcID.RAIDS_SKELETONMYSTIC_C,
			NpcID.RAIDS_THIEVINGCHEST_BEAST_ACTIVE,
			NpcID.RAIDS_THIEVINGCHEST_BEAST_SLEEPING,
			NpcID.RAIDS_SCAVENGER_BEAST_A,
			NpcID.RAIDS_SCAVENGER_BEAST_B,
			NpcID.RAIDS_TIGHTROPE_RANGER,
			NpcID.RAIDS_TIGHTROPE_MAGE,
			NpcID.RAIDS_DOGODILE_SUBMERGED,
			NpcID.RAIDS_DOGODILE_JUNIOR,
			NpcID.RAIDS_DOGODILE,
			NpcID.RAIDS_DOGODILE_MEAT_TREE,
			NpcID.OLM_HEAD_SPAWNING,
			NpcID.OLM_HEAD,
			NpcID.OLM_HAND_RIGHT_SPAWNING,
			NpcID.OLM_HAND_RIGHT,
			NpcID.OLM_HAND_LEFT_SPAWNING,
			NpcID.OLM_HAND_LEFT,
			NpcID.OLM_FIREWALL_NPC,

			// Theatre of Blood
			NpcID.TOB_MAIDEN_100,
			NpcID.TOB_MAIDEN_70,
			NpcID.TOB_MAIDEN_50,
			NpcID.TOB_MAIDEN_30,
			NpcID.TOB_MAIDEN_DYING_A,
			NpcID.TOB_MAIDEN_DYING_B,
			NpcID.TOB_MAIDEN_100_STORY,
			NpcID.TOB_MAIDEN_70_STORY,
			NpcID.TOB_MAIDEN_50_STORY,
			NpcID.TOB_MAIDEN_30_STORY,
			NpcID.TOB_MAIDEN_DYING_A_STORY,
			NpcID.TOB_MAIDEN_DYING_B_STORY,
			NpcID.TOB_MAIDEN_100_HARD,
			NpcID.TOB_MAIDEN_70_HARD,
			NpcID.TOB_MAIDEN_50_HARD,
			NpcID.TOB_MAIDEN_30_HARD,
			NpcID.TOB_MAIDEN_DYING_A_HARD,
			NpcID.TOB_MAIDEN_DYING_B_HARD,
			NpcID.TOBQUEST_MAIDEN,
			NpcID.MAIDEN_TRANSMOG,
			NpcID.MAIDEN_ELEMENTAL,
			NpcID.TOB_VERZIK_PHASE2_BLOODNYLOCAS,
			NpcID.MAIDEN_ELEMENTAL_STORY,
			NpcID.MAIDEN_ELEMENTAL_HARD,
			NpcID.TOB_VERZIK_PHASE2_BLOODNYLOCAS_STORY,
			NpcID.TOB_VERZIK_PHASE2_BLOODNYLOCAS_HARD,
			NpcID.MAIDEN_BLOOD_SLUG,
			NpcID.MAIDEN_BLOOD_SLUG_STORY,
			NpcID.MAIDEN_BLOOD_SLUG_HARD,
			NpcID.TOB_BLOAT,
			NpcID.TOB_BLOAT_STORY,
			NpcID.TOB_BLOAT_HARD,
			NpcID.TOBQUEST_BLOAT,
			NpcID.MYQ4_NYLOCAS_2,
			NpcID.TOB_NYLOCAS_INCOMING_RANGED,
			NpcID.TOB_NYLOCAS_BIG_INCOMING_RANGED,
			NpcID.TOB_NYLOCAS_FIGHTING_RANGED,
			NpcID.TOB_NYLOCAS_BIG_FIGHTING_RANGED,
			NpcID.VERZIK_NYLOCAS_RANGED,
			NpcID.TOB_NYLOCAS_INCOMING_RANGED_STORY,
			NpcID.TOB_NYLOCAS_BIG_INCOMING_RANGED_STORY,
			NpcID.TOB_NYLOCAS_FIGHTING_RANGED_STORY,
			NpcID.TOB_NYLOCAS_BIG_FIGHTING_RANGED_STORY,
			NpcID.TOB_NYLOCAS_INCOMING_RANGED_HARD,
			NpcID.TOB_NYLOCAS_BIG_INCOMING_RANGED_HARD,
			NpcID.TOB_NYLOCAS_FIGHTING_RANGED_HARD,
			NpcID.TOB_NYLOCAS_BIG_FIGHTING_RANGED_HARD,
			NpcID.VERZIK_NYLOCAS_RANGED_STORY,
			NpcID.VERZIK_NYLOCAS_RANGED_HARD,
			NpcID.TOBQUEST_NYLOCAS_2,
			NpcID.TOB_NYLOCAS_INCOMING_MAGIC,
			NpcID.TOB_NYLOCAS_BIG_INCOMING_MAGIC,
			NpcID.TOB_NYLOCAS_FIGHTING_MAGIC,
			NpcID.TOB_NYLOCAS_BIG_FIGHTING_MAGIC,
			NpcID.VERZIK_NYLOCAS_MAGIC,
			NpcID.TOB_NYLOCAS_INCOMING_MAGIC_STORY,
			NpcID.TOB_NYLOCAS_BIG_INCOMING_MAGIC_STORY,
			NpcID.TOB_NYLOCAS_FIGHTING_MAGIC_STORY,
			NpcID.TOB_NYLOCAS_BIG_FIGHTING_MAGIC_STORY,
			NpcID.TOB_NYLOCAS_INCOMING_MAGIC_HARD,
			NpcID.TOB_NYLOCAS_BIG_INCOMING_MAGIC_HARD,
			NpcID.TOB_NYLOCAS_FIGHTING_MAGIC_HARD,
			NpcID.TOB_NYLOCAS_BIG_FIGHTING_MAGIC_HARD,
			NpcID.VERZIK_NYLOCAS_MAGIC_STORY,
			NpcID.VERZIK_NYLOCAS_MAGIC_HARD,
			NpcID.TOBQUEST_NYLOCAS_3,
			NpcID.MYQ4_NYLOCAS_1,
			NpcID.TOB_NYLOCAS_INCOMING_MELEE,
			NpcID.TOB_NYLOCAS_BIG_INCOMING_MELEE,
			NpcID.TOB_NYLOCAS_FIGHTING_MELEE,
			NpcID.TOB_NYLOCAS_BIG_FIGHTING_MELEE,
			NpcID.VERZIK_NYLOCAS_MELEE,
			NpcID.TOB_NYLOCAS_INCOMING_MELEE_STORY,
			NpcID.TOB_NYLOCAS_BIG_INCOMING_MELEE_STORY,
			NpcID.TOB_NYLOCAS_FIGHTING_MELEE_STORY,
			NpcID.TOB_NYLOCAS_BIG_FIGHTING_MELEE_STORY,
			NpcID.TOB_NYLOCAS_INCOMING_MELEE_HARD,
			NpcID.TOB_NYLOCAS_BIG_INCOMING_MELEE_HARD,
			NpcID.TOB_NYLOCAS_FIGHTING_MELEE_HARD,
			NpcID.TOB_NYLOCAS_BIG_FIGHTING_MELEE_HARD,
			NpcID.VERZIK_NYLOCAS_MELEE_STORY,
			NpcID.VERZIK_NYLOCAS_MELEE_HARD,
			NpcID.TOBQUEST_NYLOCAS_1,
			NpcID.NYLOCAS_BOSS_SPAWNING,
			NpcID.NYLOCAS_BOSS_MELEE,
			NpcID.NYLOCAS_BOSS_MAGIC,
			NpcID.NYLOCAS_BOSS_RANGED,
			NpcID.NYLOCAS_BOSS_SPAWNING_STORY,
			NpcID.NYLOCAS_BOSS_MELEE_STORY,
			NpcID.NYLOCAS_BOSS_MAGIC_STORY,
			NpcID.NYLOCAS_BOSS_RANGED_STORY,
			NpcID.NYLOCAS_BOSS_SPAWNING_HARD,
			NpcID.NYLOCAS_BOSS_MELEE_HARD,
			NpcID.NYLOCAS_BOSS_MAGIC_HARD,
			NpcID.NYLOCAS_BOSS_RANGED_HARD,
			NpcID.TOBQUEST_NYLOBOSS,
			NpcID.NYLOCAS_MINIBOSS_SPAWNING_HARD,
			NpcID.NYLOCAS_MINIBOSS_MELEE_HARD,
			NpcID.NYLOCAS_MINIBOSS_MAGIC_HARD,
			NpcID.NYLOCAS_MINIBOSS_RANGED_HARD,
			NpcID.TOB_SOTETSEG_NONCOMBAT,
			NpcID.TOB_SOTETSEG_COMBAT,
			NpcID.TOB_SOTETSEG_NONCOMBAT_STORY,
			NpcID.TOB_SOTETSEG_COMBAT_STORY,
			NpcID.TOB_SOTETSEG_NONCOMBAT_HARD,
			NpcID.TOB_SOTETSEG_COMBAT_HARD,
			NpcID.TOBQUEST_SOTETSEG,
			NpcID.TOB_XARPUS_STATIC,
			NpcID.TOB_XARPUS_FEEDING,
			NpcID.TOB_XARPUS_COMBAT,
			NpcID.XARPUS_DEATH,
			NpcID.TOB_XARPUS_STATIC_STORY,
			NpcID.TOB_XARPUS_FEEDING_STORY,
			NpcID.TOB_XARPUS_COMBAT_STORY,
			NpcID.XARPUS_DEATH_STORY,
			NpcID.TOB_XARPUS_STATIC_HARD,
			NpcID.TOB_XARPUS_FEEDING_HARD,
			NpcID.TOB_XARPUS_COMBAT_HARD,
			NpcID.XARPUS_DEATH_HARD,
			NpcID.TOBQUEST_XARPUS,
			NpcID.MYQ4_VERZIK_HUMAN,
			NpcID.VERZIK_INITIAL,
			NpcID.VERZIK_PHASE1,
			NpcID.VERZIK_PHASE1_TO2_TRANSITION,
			NpcID.VERZIK_PHASE2,
			NpcID.VERZIK_PHASE2_TO3_TRANSITION,
			NpcID.VERZIK_PHASE3,
			NpcID.VERZIK_DEATH_BAT,
			NpcID.VERZIK_INITIAL_STORY,
			NpcID.VERZIK_PHASE1_STORY,
			NpcID.VERZIK_PHASE1_TO2_TRANSITION_STORY,
			NpcID.VERZIK_PHASE2_STORY,
			NpcID.VERZIK_PHASE2_TO3_TRANSITION_STORY,
			NpcID.VERZIK_PHASE3_STORY,
			NpcID.VERZIK_DEATH_BAT_STORY,
			NpcID.VERZIK_INITIAL_HARD,
			NpcID.VERZIK_PHASE1_HARD,
			NpcID.VERZIK_PHASE1_TO2_TRANSITION_HARD,
			NpcID.VERZIK_PHASE2_HARD,
			NpcID.VERZIK_PHASE2_TO3_TRANSITION_HARD,
			NpcID.VERZIK_PHASE3_HARD,
			NpcID.VERZIK_DEATH_BAT_HARD,
			NpcID.TOBQUEST_VERZIK,
			NpcID.TOBQUEST_VERZIK_NYLO,
			NpcID.VERZIK_PILLAR_NPC,
			NpcID.VERZIK_STORY_PILLAR_NPC,
			NpcID.VERZIK_HARD_PILLAR_NPC,
			NpcID.VERZIK_COLLAPSING_PILLAR_NPC,
			NpcID.VERZIK_FADING_RUBBLE_NPC,
			NpcID.VERZIK_STORY_COLLAPSING_PILLAR_NPC,
			NpcID.VERZIK_STORY_FADING_RUBBLE_NPC,
			NpcID.VERZIK_HARD_COLLAPSING_PILLAR_NPC,
			NpcID.VERZIK_HARD_FADING_RUBBLE_NPC,
			NpcID.VERZIK_WEB_NPC,
			NpcID.VERZIK_WEB_NPC_STORY,
			NpcID.VERZIK_WEB_NPC_HARD,
			NpcID.TOB_VERZIK_PHASE2_ARMOUREDNYLOCAS,
			NpcID.TOB_VERZIK_PHASE2_ARMOUREDNYLOCAS_STORY,
			NpcID.TOB_VERZIK_PHASE2_ARMOUREDNYLOCAS_HARD,
			NpcID.TOB_VERZIK_CREEPER,
			NpcID.TOB_VERZIK_CREEPER_HARD,
			NpcID.TOB_VERZIK_CREEPER_STORY,
			NpcID.TOBQUEST_ATHANATOS,

			// Tombs of Amascut
			NpcID.TOA_CRONDIS_TREE_1,
			NpcID.TOA_CRONDIS_TREE_2,
			NpcID.TOA_CRONDIS_TREE_3,
			NpcID.TOA_CRONDIS_TREE_4,
			NpcID.TOA_CRONDIS_TREE_5,
			NpcID.TOA_CRONDIS_CROCODILE,
			NpcID.TOA_ZEBAK,
			NpcID.TOA_ZEBAK_ENRAGED,
			NpcID.TOA_ZEBAK_DEAD,
			NpcID.OSB10_TOA_ZEBAK_CUTSCENE,
			NpcID.TOA_ZEBAK_TAIL,
			NpcID.TOA_ZEBAK_TAIL_DEAD,
			NpcID.OSB10_TOA_ZEBAK_TAIL_CUTSCENE,
			NpcID.TOA_ZEBAK_JUG,
			NpcID.TOA_ZEBAK_JUG_ROLLING,
			NpcID.TOA_ZEBAK_SAFESPOT,
			NpcID.TOA_ZEBAK_WAVE,
			NpcID.TOA_ZEBAK_WAVE_BLOODY,
			NpcID.TOA_ZEBAK_LANDCROC,
			NpcID.TOA_ZEBAK_WATERCROC,
			NpcID.TOA_ZEBAK_BLOOD_CLOUD,
			NpcID.TOA_ZEBAK_BLOOD_CLOUD_SMALL,
			NpcID.TOA_SCABARAS_SCARAB,
			NpcID.TOA_KEPHRI_BOSS_SHIELDED,
			NpcID.TOA_KEPHRI_BOSS_WEAK,
			NpcID.TOA_KEPHRI_BOSS_ENRAGE,
			NpcID.TOA_KEPHRI_BOSS_DEAD,
			NpcID.TOA_KEPHRI_SHIELD_SCARAB,
			NpcID.TOA_KEPHRI_GUARDIAN_MELEE,
			NpcID.TOA_KEPHRI_GUARDIAN_RANGED,
			NpcID.TOA_KEPHRI_GUARDIAN_MAGE,
			NpcID.TOA_KEPHRI_SCARAB_RANGEKITE,
			NpcID.KEPHRI_EGG_EXPLODE,
			NpcID.KEPHRI_EGG_HATCH,
			NpcID.TOA_HET_GOAL,
			NpcID.TOA_HET_GOAL_VULNERABLE,
			NpcID.TOA_HET_ORB,
			NpcID.AKKHA_TRAIL_ORB_DARKNESS,
			NpcID.AKKHA_SPAWN,
			NpcID.AKKHA_MELEE,
			NpcID.AKKHA_RANGE,
			NpcID.AKKHA_MAGE,
			NpcID.AKKHA_ENRAGE_SPAWN,
			NpcID.AKKHA_ENRAGE_INITIAL,
			NpcID.AKKHA_ENRAGE,
			NpcID.AKKHA_ENRAGE_DUMMY,
			NpcID.AKKHA_SHADOW,
			NpcID.AKKHA_SHADOW_ENRAGE,
			NpcID.AKKHA_SHADOW_ENRAGE_DUMMY,
			NpcID.AKKHA_TRAIL_ORB_LIGHTNING,
			NpcID.AKKHA_TRAIL_ORB_BURN,
			NpcID.AKKHA_TRAIL_ORB_FREEZE,
			NpcID.AKKHA_ENRAGE_ORB,
			NpcID.TOA_PATH_APMEKEN_BABOON_MELEE_1,
			NpcID.TOA_PATH_APMEKEN_BABOON_MELEE_2,
			NpcID.TOA_PATH_APMEKEN_BABOON_RANGED_1,
			NpcID.TOA_PATH_APMEKEN_BABOON_RANGED_2,
			NpcID.TOA_PATH_APMEKEN_BABOON_MAGIC_1,
			NpcID.TOA_PATH_APMEKEN_BABOON_MAGIC_2,
			NpcID.TOA_PATH_APMEKEN_BABOON_SHAMAN,
			NpcID.TOA_PATH_APMEKEN_BABOON_ZOMBIE,
			NpcID.TOA_PATH_APMEKEN_BABOON_CURSED,
			NpcID.TOA_PATH_APMEKEN_BABOON_THRALL,
			NpcID.TOA_BABA,
			NpcID.TOA_BABA_COFFIN,
			NpcID.TOA_BABA_DIGGING,
			NpcID.TOA_BABA_BABOON,
			NpcID.TOA_BABA_BOULDER,
			NpcID.TOA_BABA_BOULDER_WEAK,
			NpcID.TOA_BABA_RUBBLE,
			NpcID.TOA_BABA_RUBBLE_2,
			NpcID.TOA_BABA_RUBBLE_3,
			NpcID.TOA_BABA_RUBBLE_4,
			NpcID.TOA_WARDENS_P1_OBELISK_NPC_INACTIVE,
			NpcID.TOA_WARDENS_P1_OBELISK_NPC,
			NpcID.TOA_WARDENS_P2_OBELISK_NPC,
			NpcID.TOA_WARDEN_ELIDINIS_PHASE1_INACTIVE,
			NpcID.TOA_WARDEN_ELIDINIS_PHASE1,
			NpcID.TOA_WARDEN_ELIDINIS_PHASE2_MAGE,
			NpcID.TOA_WARDEN_ELIDINIS_PHASE2_RANGE,
			NpcID.TOA_WARDEN_ELIDINIS_PHASE2_EXPOSED,
			NpcID.TOA_WARDEN_ELIDINIS_PHASE3_INACTIVE,
			NpcID.TOA_WARDEN_ELIDINIS_PHASE3,
			NpcID.TOA_WARDEN_ELIDINIS_PHASE3_CHARGING,
			NpcID.OSB10_TOA_WARDEN_ELIDINIS_CUTSCENE,
			NpcID.TOA_WARDEN_TUMEKEN_PHASE1_INACTIVE,
			NpcID.TOA_WARDEN_TUMEKEN_PHASE1,
			NpcID.TOA_WARDEN_TUMEKEN_PHASE2_MAGE,
			NpcID.TOA_WARDEN_TUMEKEN_PHASE2_EXPOSED,
			NpcID.TOA_WARDEN_TUMEKEN_PHASE3_INACTIVE,
			NpcID.TOA_WARDEN_TUMEKEN_PHASE3,
			NpcID.TOA_WARDEN_TUMEKEN_PHASE3_CHARGING,
			NpcID.TOA_WARDEN_TUMEKEN_CORE,
			NpcID.TOA_WARDEN_ELIDINIS_CORE,
			NpcID.WARDENS_P3_ORB_BLUE,
			NpcID.TOA_WARDENS_ZEBAK,
			NpcID.TOA_WARDENS_BABA,
			NpcID.TOA_WARDENS_KEPHRI,
			NpcID.TOA_WARDENS_AKKHA,

			// God Wars Dungeon
			NpcID.GODWARS_ARMADYL_AVATAR,
			NpcID.CLANCUP_GODWARS_ARMADYL_AVATAR,
			NpcID.GODWARS_ARMADYL_BODYGUARD_SKREE,
			NpcID.GODWARS_ARMADYL_BODYGUARD_GEERIN,
			NpcID.GODWARS_ARMADYL_BODYGUARD_KILISA,

			NpcID.GODWARS_SARADOMIN_AVATAR,
			NpcID.CLANCUP_GODWARS_SARADOMIN_AVATAR,
			NpcID.GODWARS_SARADOMIN_UNICORN,
			NpcID.GODWARS_SARADOMIN_LION,
			NpcID.GODWARS_SARADOMIN_CENTAUR,

			NpcID.GODWARS_BANDOS_AVATAR,
			NpcID.CLANCUP_GODWARS_BANDOS_AVATAR,
			NpcID.GODWARS_SERGEANT_GOBLIN1,
			NpcID.GODWARS_SERGEANT_GOBLIN2,
			NpcID.GODWARS_SERGEANT_GOBLIN3,

			NpcID.GODWARS_ZAMORAK_AVATAR,
			NpcID.CLANCUP_GODWARS_ZAMORAK_AVATAR,
			NpcID.GODWARS_ANCIENT_GREATER_DEMON,
			NpcID.GODWARS_ANCIENT_LESSER_DEMON,
			NpcID.GODWARS_ANCIENT_BLACK_DEMON,

			NpcID.NEX,
			NpcID.NEX_SPAWNING,
			NpcID.NEX_SOULSPLIT,
			NpcID.NEX_DEFLECT,
			NpcID.NEX_DYING,
			NpcID.NEX_SMOKEMAGE,
			NpcID.NEX_SHADOWMAGE,
			NpcID.NEX_BLOODMAGE,
			NpcID.NEX_ICEMAGE,

			// Other
			NpcID.BARBASSAULT_PEN_FIGHTER_TUTOR,
			NpcID.BARBASSAULT_PEN_FIGHTER_LV1,
			NpcID.BARBASSAULT_PEN_FIGHTER_LV2,
			NpcID.BARBASSAULT_PEN_FIGHTER_LV3,
			NpcID.BARBASSAULT_PEN_FIGHTER_LV4,
			NpcID.BARBASSAULT_PEN_FIGHTER_LV5,
			NpcID.BARBASSAULT_PEN_FIGHTER_LV6,
			NpcID.BARBASSAULT_PEN_FIGHTER_LV7,
			NpcID.BARBASSAULT_PEN_FIGHTER_LV8,
			NpcID.BARBASSAULT_PEN_FIGHTER_LV9,
			NpcID.BARBASSAULT_PEN_RUNNER_TUTOR,
			NpcID.BARBASSAULT_PEN_RUNNER_LV1,
			NpcID.BARBASSAULT_PEN_RUNNER_LV2,
			NpcID.BARBASSAULT_PEN_RUNNER_LV3,
			NpcID.BARBASSAULT_PEN_RUNNER_LV4,
			NpcID.BARBASSAULT_PEN_RUNNER_LV5,
			NpcID.BARBASSAULT_PEN_RUNNER_LV6,
			NpcID.BARBASSAULT_PEN_RUNNER_LV7,
			NpcID.BARBASSAULT_PEN_RUNNER_LV8,
			NpcID.BARBASSAULT_PEN_RUNNER_LV9,
			NpcID.BARBASSAULT_PEN_RANGER_TUTOR,
			NpcID.BARBASSAULT_PEN_RANGER_LV1,
			NpcID.BARBASSAULT_PEN_RANGER_LV2,
			NpcID.BARBASSAULT_PEN_RANGER_LV3,
			NpcID.BARBASSAULT_PEN_RANGER_LV4,
			NpcID.BARBASSAULT_PEN_RANGER_LV5,
			NpcID.BARBASSAULT_PEN_RANGER_LV6,
			NpcID.BARBASSAULT_PEN_RANGER_LV7,
			NpcID.BARBASSAULT_PEN_RANGER_LV8,
			NpcID.BARBASSAULT_PEN_RANGER_LV9,
			NpcID.BARBASSAULT_PEN_HEALER_TUTOR,
			NpcID.BARBASSAULT_PEN_HEALER_LV1,
			NpcID.BARBASSAULT_PEN_HEALER_LV2,
			NpcID.BARBASSAULT_PEN_HEALER_LV3,
			NpcID.BARBASSAULT_PEN_HEALER_LV4,
			NpcID.BARBASSAULT_PEN_HEALER_LV5,
			NpcID.BARBASSAULT_PEN_HEALER_LV6,
			NpcID.BARBASSAULT_PEN_HEALER_LV7,
			NpcID.BARBASSAULT_PEN_HEALER_LV8,
			NpcID.BARBASSAULT_PEN_HEALER_LV9,
			NpcID.BARBASSAULT_PEN_QUEEN_NEW,
			NpcID.BARBASSAULT_PEN_QUEEN_SPAWN,

			NpcID.RAT_BOSS_NORMAL,
			NpcID.RAT_BOSS_INSTANCE,
			NpcID.RAT_BOSS_GIANT_RAT,

			NpcID.POH_MOUNTED_KQ,
			NpcID.KALPHITE_QUEEN,
			NpcID.KALPHITE_FLYINGQUEEN,
			NpcID.SWAN_KALPHITE_1,
			NpcID.SWAN_KALPHITE_2,
			NpcID.CLANCUP_KALPHITE_QUEEN,
			NpcID.CLANCUP_KALPHITE_FLYINGQUEEN,

			NpcID.SARACHNIS,
			NpcID.SARACHNIS_MELEE_SPAWN,
			NpcID.SARACHNIS_MAGE_SPAWN,

			NpcID.SCORPIA,
			NpcID.SCORPIA_MINION,
			NpcID.SCORPIA_GUARDIAN,

			NpcID.ABYSSALSIRE_SIRE_STASIS_SLEEPING,
			NpcID.ABYSSALSIRE_SIRE_STASIS_AWAKE,
			NpcID.ABYSSALSIRE_SIRE_STASIS_STUNNED,
			NpcID.ABYSSALSIRE_SIRE_PUPPET,
			NpcID.ABYSSALSIRE_SIRE_WANDERING,
			NpcID.ABYSSALSIRE_SIRE_PANICKING,
			NpcID.ABYSSALSIRE_SIRE_APOCALYPSE,
			NpcID.ABYSSALSIRE_TENTACLE_SLEEPING_NORTH,
			NpcID.ABYSSALSIRE_TENTACLE_SLEEPING_SOUTH,
			NpcID.ABYSSALSIRE_TENTACLE_SLEEPING_UPRIGHT,
			NpcID.ABYSSALSIRE_TENTACLE_ACTIVE,
			NpcID.ABYSSALSIRE_TENTACLE_STUNNED,
			NpcID.ABYSSALSIRE_LUNG,
			NpcID.ABYSSALSIRE_LUNG_DYING,
			NpcID.ABYSSALSIRE_SPAWN,
			NpcID.ABYSSALSIRE_SPAWN_DYING,
			NpcID.ABYSSALSIRE_SCION,

			NpcID.LEVIATHAN,
			NpcID.LEVIATHAN_QUEST,
			NpcID.LEVIATHAN_CUTSCENE_FAKE,
			NpcID.LEVIATHAN_BUFF_NPC,

			NpcID.WHISPERER,
			NpcID.WHISPERER_MELEE,
			NpcID.WHISPERER_QUEST,
			NpcID.WHISPERER_MELEE_QUEST,
			NpcID.WHISPERER_TENTACLE,
			NpcID.WHISPERER_SCREECH_SAFESPOT_SHADOW,
			NpcID.WHISPERER_SCREECH_SAFESPOT,
			NpcID.WHISPERER_SOUL,
			NpcID.WHISPERER_SOUL_VULNERABLE,

			NpcID.VARDORVIS,
			NpcID.VARDORVIS_QUEST,
			NpcID.VARDORVIS_CUTSCENE,
			NpcID.VARDORVIS_BASE_QUEST,
			NpcID.VARDORVIS_BASE_POSTQUEST,
			NpcID.DEADMAN_BREACH_VARDORVIS,
			NpcID.VARDORVIS_HEAD_TENTACLE,

			NpcID.DUKE_SUCELLUS_INACTIVE,
			NpcID.DUKE_SUCELLUS_ASLEEP,
			NpcID.DUKE_SUCELLUS_AWAKE,
			NpcID.DUKE_SUCELLUS_DEAD,
			NpcID.DUKE_SUCELLUS_INACTIVE_QUEST,
			NpcID.DUKE_SUCELLUS_ASLEEP_QUEST,
			NpcID.DUKE_SUCELLUS_AWAKE_QUEST,
			NpcID.DUKE_SUCELLUS_DEAD_QUEST,

			NpcID.CORP_BEAST,
			NpcID.DARK_CORE,

			NpcID.KING_DRAGON,
			NpcID.CLANCUP_KING_DRAGON,
			NpcID.DEADMAN_BREACH_KING_BLACK_DRAGON,

			NpcID.POH_MOUNTED_VORKATH,
			NpcID.VORKATH_SLEEPING_NOOP,
			NpcID.VORKATH_SLEEPING,
			NpcID.VORKATH_QUEST,
			NpcID.VORKATH,
			NpcID.VORKATH_SPAWN_QUEST,
			NpcID.VORKATH_SPAWN,

			NpcID.SNAKEBOSS_BOSS_RANGED,
			NpcID.SNAKEBOSS_BOSS_MELEE,
			NpcID.SNAKEBOSS_BOSS_MAGIC,
			NpcID.SNAKEBOSS_MINION_MELEE,
			NpcID.SNAKEBOSS_MINION_MAGIC,
			NpcID.SNAKEBOSS_MINION_DYING,

			NpcID.DARK_SEREN,
			NpcID.DARK_SEREN_PHANTOM,
			NpcID.DARK_SEREN_CUTSCENE,
			NpcID.DARK_SEREN_CUTSCENE_TRAPPED,

			NpcID.HYDRABOSS,
			NpcID.HYDRABOSS_P1_TRANSITION,
			NpcID.HYDRABOSS_P2_TRANSITION,
			NpcID.HYDRABOSS_P3_TRANSITION,
			NpcID.HYDRABOSS_4,
			NpcID.HYDRABOSS_3,
			NpcID.HYDRABOSS_2,
			NpcID.HYDRABOSS_FINALDEATH,
			NpcID.POH_MOUNTED_HYDRA,
			NpcID.HYDRABOSS_TRANSMOG,

			NpcID.GB_MOSSGIANT,
			NpcID.HILLGIANT_BOSS,
			NpcID.CLANCUP_CALLISTO,
			NpcID.CLANCUP_VENENATIS,
			NpcID.VENENATIS,
			NpcID.POH_VENENATIS_PET,
			NpcID.VENENATISPET,
			NpcID.VETION,
			NpcID.VETION_2,
			NpcID.VETION_HELLHOUND_JNR,
			NpcID.VETION_HELLHOUND_SNR,

			NpcID.CERBERUS_ATTACKING,
			NpcID.CHAOSELEMENTAL,

			NpcID.CRYSTAL_HUNLLEF_MELEE,
			NpcID.CRYSTAL_HUNLLEF_RANGED,
			NpcID.CRYSTAL_HUNLLEF_MAGIC,
			NpcID.CRYSTAL_HUNLLEF_DEATH,

			NpcID.CRYSTAL_HUNLLEF_MELEE_HM,
			NpcID.CRYSTAL_HUNLLEF_RANGED_HM,
			NpcID.CRYSTAL_HUNLLEF_MAGIC_HM,
			NpcID.CRYSTAL_HUNLLEF_DEATH_HM,

			NpcID.MOLE_GIANT,
			NpcID.CLANCUP_MOLE_GIANT,

			NpcID.HESPORI,
			NpcID.TOBQUEST_HESPORI,
			NpcID.HESPORI_HEALER_ACTIVE,
			NpcID.HESPORI_HEALER_INACTIVE,
			NpcID.TOBQUEST_HESPORI_HEALER_ACTIVE,
			NpcID.TOBQUEST_HESPORI_HEALER_INACTIVE,

			NpcID.TRAIL_MIMIC_NONCOMBAT,
			NpcID.TRAIL_MIMIC_COMBAT,

			NpcID.NIGHTMARE_DEAD,
			NpcID.NIGHTMARE_PHASE_01,
			NpcID.NIGHTMARE_PHASE_02,
			NpcID.NIGHTMARE_PHASE_03,
			NpcID.NIGHTMARE_WEAK_PHASE_01,
			NpcID.NIGHTMARE_WEAK_PHASE_02,
			NpcID.NIGHTMARE_WEAK_PHASE_03,
			NpcID.NIGHTMARE_BLAST,
			NpcID.NIGHTMARE_INITIAL,
			NpcID.NIGHTMARE_DYING,
			NpcID.NIGHTMARE_ENTRY_READY,
			NpcID.NIGHTMARE_ENTRY_OPEN,
			NpcID.NIGHTMARE_ENTRY_CLOSED_01,
			NpcID.NIGHTMARE_ENTRY_CLOSED_02,
			NpcID.NIGHTMARE_ENTRY_CLOSED_03,
			NpcID.NIGHTMARE_TOTEM_1_DORMANT,
			NpcID.NIGHTMARE_TOTEM_1_READY,
			NpcID.NIGHTMARE_TOTEM_1_CHARGED,
			NpcID.NIGHTMARE_TOTEM_2_DORMANT,
			NpcID.NIGHTMARE_TOTEM_2_READY,
			NpcID.NIGHTMARE_TOTEM_2_CHARGED,
			NpcID.NIGHTMARE_TOTEM_3_DORMANT,
			NpcID.NIGHTMARE_TOTEM_3_READY,
			NpcID.NIGHTMARE_TOTEM_3_CHARGED,
			NpcID.NIGHTMARE_TOTEM_4_DORMANT,
			NpcID.NIGHTMARE_TOTEM_4_READY,
			NpcID.NIGHTMARE_TOTEM_4_CHARGED,
			NpcID.NIGHTMARE_SLEEPWALKER_1,
			NpcID.NIGHTMARE_SLEEPWALKER_2,
			NpcID.NIGHTMARE_SLEEPWALKER_3,
			NpcID.NIGHTMARE_SLEEPWALKER_4,
			NpcID.NIGHTMARE_SLEEPWALKER_5,
			NpcID.NIGHTMARE_SLEEPWALKER_6,
			NpcID.NIGHTMARE_PARASITE,
			NpcID.NIGHTMARE_PARASITE_WEAK,
			NpcID.NIGHTMARE_HUSK_MAGIC,
			NpcID.NIGHTMARE_HUSK_RANGED,
			NpcID.NIGHTMARE_CHALLENGE_PHASE_01,
			NpcID.NIGHTMARE_CHALLENGE_PHASE_02,
			NpcID.NIGHTMARE_CHALLENGE_PHASE_03,
			NpcID.NIGHTMARE_CHALLENGE_WEAK_PHASE_01,
			NpcID.NIGHTMARE_CHALLENGE_WEAK_PHASE_02,
			NpcID.NIGHTMARE_CHALLENGE_WEAK_PHASE_03,
			NpcID.NIGHTMARE_CHALLENGE_BLAST,
			NpcID.NIGHTMARE_CHALLENGE_INITIAL,
			NpcID.NIGHTMARE_CHALLENGE_DYING,

			NpcID.MUSPAH,
			NpcID.MUSPAH_MELEE,
			NpcID.MUSPAH_SOULSPLIT,
			NpcID.MUSPAH_FINAL,
			NpcID.MUSPAH_TELEPORT,

			NpcID.CATA_BOSS,

			NpcID.TZHAAR_FIGHTPIT_SWARM_1A,
			NpcID.TZHAAR_FIGHTPIT_SWARM_1B,
			NpcID.TZHAAR_FIGHTPIT_SWARM_2A,
			NpcID.TZHAAR_FIGHTPIT_SWARM_2B,
			NpcID.TZHAAR_FIGHTPIT_SWARM_3A,
			NpcID.TZHAAR_FIGHTPIT_SWARM_3B,
			NpcID.TZHAAR_FIGHTCAVE_SWARM_4A,
			NpcID.TZHAAR_FIGHTCAVE_SWARM_4B,
			NpcID.TZHAAR_FIGHTCAVE_SWARM_5A,
			NpcID.TZHAAR_FIGHTCAVE_SWARM_5B,
			NpcID.TZHAAR_FIGHTCAVE_SWARM_BOSS,
			NpcID.TZHAAR_FIGHTCAVE_SWARM_BOSS_CLERIC,

			NpcID.INFERNO_NIBBLER,
			NpcID.INFERNO_CREATURE_HARPIE,
			NpcID.INFERNO_CREATURE_SPLITTER,
			NpcID.INFERNO_CREATURE_SPLITTER_MAGE,
			NpcID.INFERNO_CREATURE_SPLITTER_RANGE,
			NpcID.INFERNO_CREATURE_SPLITTER_MELEE,
			NpcID.INFERNO_CREATURE_MELEE,
			NpcID.INFERNO_CREATURE_RANGER,
			NpcID.INFERNO_RANGER_FINALWAVE,
			NpcID.INFERNO_CREATURE_MAGER,
			NpcID.INFERNO_MAGER_FINALWAVE,
			NpcID.INFERNO_JAD,
			NpcID.INFERNO_JAD_FINALWAVE,
			NpcID.INFERNO_JAD_HEALER,
			NpcID.INFERNO_JAD_HEALER_FINALWAVE,
			NpcID.INFERNO_TZKALZUK_PLACEHOLDER,
			NpcID.INFERNO_ZUK_HEALER,
			NpcID.INFERNO_INVISIBLE_3X3,
			NpcID.INFERNO_SAFESPOT_DYING,

			NpcID.DAGCAVE_RANGED_BOSS,
			NpcID.CLANCUP_DAGCAVE_RANGED_BOSS,
			NpcID.DAGCAVE_MAGIC_BOSS,
			NpcID.CLANCUP_DAGCAVE_MAGIC_BOSS,
			NpcID.DAGCAVE_MELEE_BOSS,
			NpcID.CLANCUP_DAGCAVE_MELEE_BOSS,

			NpcID.COLOSSEUM_WARBANDER_RANGED_FEMALE,
			NpcID.COLOSSEUM_WARBANDER_MAGE_MALE,
			NpcID.COLOSSEUM_WARBANDER_MELEE_MALE,
			NpcID.COLOSSEUM_JAGUAR_WARRIOR,
			NpcID.COLOSSEUM_STANDARD_MAGER,
			NpcID.COLOSSEUM_MINOTAUR,
			NpcID.COLOSSEUM_MINOTAUR_ROUTEFIND,
			NpcID.COLOSSEUM_JAVELIN_COLOSSUS,
			NpcID.COLOSSEUM_MANTICORE,
			NpcID.COLOSSEUM_SHOCKWAVE_COLOSSUS,
			NpcID.COLOSSEUM_SOL_P1,
			NpcID.COLOSSEUM_DOOM_SCORPION,
			NpcID.COLOSSEUM_MODIFIER_BEES,
			NpcID.COLOSSEUM_HEALING_TOTEM,

			// Royal Titans
			NpcID.RT_FIRE_QUEEN,
			NpcID.RT_ICE_KING,
			NpcID.RT_SUMMON_ELEMENTAL_FIRE,
			NpcID.RT_SUMMON_ELEMENTAL_ICE,
			NpcID.RS_LOC_ATTACK_FIRE_HITBOX,
			NpcID.RS_LOC_ATTACK_ICE_HITBOX,

			// Yama
			NpcID.YAMA,
			NpcID.YAMA_VOIDFLARE,
			NpcID.YAMA_JUDGE_OF_YAMA,
			NpcID.YAMA_METEOR_NPC,

			// Doom of Mokhaiotl
			NpcID.DOM_BOSS,
			NpcID.DOM_BOSS_SHIELDED ,
			NpcID.DOM_DEMONIC_ENERGY,
			NpcID.DOM_DEMONIC_ENERGY_RANGE,
			NpcID.DOM_DEMONIC_ENERGY_MAGE,
			NpcID.DOM_DEMONIC_ENERGY_MELEE,
			NpcID.DOM_SHOCKWAVE_PATH_NODE,
			NpcID.DOM_SHOCKWAVE_SHIELD

	));
}

package com.combatlogger.util;

import java.util.Arrays;
import java.util.HashSet;
import java.util.Set;

public class GraphicsObjectIdsToTrack
{
	public static final Set<Integer> GRAPHICS_OBJECT_IDS_TO_TRACK = new HashSet<>(Arrays.asList(
			1570, // Bloat hand
			1571, // Bloat foot
			1572, // Bloat hand
			1573, // Bloat foot
			1579, // Maiden of Sugadinti blood
			1595 // Verzik yellows
	));
}

package com.combatlogger.util;

import net.runelite.api.Client;
import net.runelite.api.Skill;

import java.util.List;

public class CombatStats
{
	public static List<Integer> getBaseStats(Client client)
	{
		return List.of(
				client.getRealSkillLevel(Skill.ATTACK),
				client.getRealSkillLevel(Skill.STRENGTH),
				client.getRealSkillLevel(Skill.DEFENCE),
				client.getRealSkillLevel(Skill.RANGED),
				client.getRealSkillLevel(Skill.MAGIC),
				client.getRealSkillLevel(Skill.HITPOINTS),
				client.getRealSkillLevel(Skill.PRAYER),
				client.getRealSkillLevel(Skill.SAILING)
		);
	}

	public static List<Integer> getBoostedStats(Client client)
	{
		return List.of(
				client.getBoostedSkillLevel(Skill.ATTACK),
				client.getBoostedSkillLevel(Skill.STRENGTH),
				client.getBoostedSkillLevel(Skill.DEFENCE),
				client.getBoostedSkillLevel(Skill.RANGED),
				client.getBoostedSkillLevel(Skill.MAGIC),
				client.getBoostedSkillLevel(Skill.HITPOINTS),
				client.getBoostedSkillLevel(Skill.PRAYER),
				client.getBoostedSkillLevel(Skill.SAILING)
		);
	}
}

package com.combatlogger.util;

import java.util.concurrent.LinkedBlockingDeque;

/**
 * Double-ended queue (deque) with a fixed maximum capacity.
 * When new elements are added to the queue that exceed its capacity, the oldest elements in the queue are automatically removed.
 *
 * @param <E>
 */
public class BoundedQueue<E> extends LinkedBlockingDeque<E>
{
	public BoundedQueue(int capacity)
	{
		super(capacity);
	}

	@Override
	public boolean add(E e)
	{
		// Remove the oldest element if the queue is full
		if (remainingCapacity() == 0)
		{
			poll();
		}
		return super.add(e);
	}

	@Override
	public boolean offer(E e)
	{
		// Remove the oldest element if the queue is full
		if (remainingCapacity() == 0)
		{
			poll();
		}
		return super.offer(e);
	}
}

package com.combatlogger.util;

import java.util.Arrays;
import java.util.HashSet;
import java.util.Set;

public class BoatIds
{
	public static final Set<Integer> BOAT_IDS = new HashSet<>(Arrays.asList(
			15187, // Small boat
			15188, // Medium boat
			15189, // Large boat
			15190 // Colossal boat
	));
}

package com.combatlogger.util;

import com.google.common.collect.ImmutableSet;

import java.util.*;
import java.util.stream.Collectors;

import static net.runelite.api.gameval.NpcID.*;

public class BossIds
{
	public static final ImmutableSet<Integer> VERZIK_P1_END = ImmutableSet.of(
			VERZIK_PHASE1_TO2_TRANSITION_STORY, // entry mode
			VERZIK_PHASE1_TO2_TRANSITION, // normal mode
			VERZIK_PHASE1_TO2_TRANSITION_HARD // hard mode
	);

	/**
	 * List of Boss IDs
	 * This differs from NpcIdsToTrack in that boss ids are used to "upgrade" a fight to a boss, or start a new fight if a boss targets a player
	 **/
	public static final Set<Integer> BOSS_IDS = new HashSet<>(Arrays.asList(
			RAT_BOSS_INSTANCE, // Scurrius solo
			RAT_BOSS_NORMAL, // Scurrius group
			GODWARS_ARMADYL_AVATAR, // Kree'arra
			GODWARS_SARADOMIN_AVATAR, // Commander Zilyana
			GODWARS_BANDOS_AVATAR, // General Graardor
			GODWARS_ZAMORAK_AVATAR, // K'ril Tsutsaroth
			NEX,
			NEX_SPAWNING,
			NEX_SOULSPLIT,
			NEX_DEFLECT,
			NEX_DYING,
			KALPHITE_QUEEN,
			KALPHITE_FLYINGQUEEN,
			SWAN_KALPHITE_1, // Kalphite Queen
			SWAN_KALPHITE_2, // Kalphite Queen
			SARACHNIS,
			SCORPIA,
			ABYSSALSIRE_SIRE_STASIS_SLEEPING,
			ABYSSALSIRE_SIRE_STASIS_AWAKE,
			ABYSSALSIRE_SIRE_STASIS_STUNNED,
			ABYSSALSIRE_SIRE_PUPPET,
			ABYSSALSIRE_SIRE_WANDERING,
			ABYSSALSIRE_SIRE_PANICKING,
			ABYSSALSIRE_SIRE_APOCALYPSE,
			LEVIATHAN,
			LEVIATHAN_QUEST,
			LEVIATHAN_CUTSCENE,
			LEVIATHAN_CUTSCENE_FAKE,
			WHISPERER,
			WHISPERER_MELEE,
			WHISPERER_QUEST,
			WHISPERER_MELEE_QUEST,
			WHISPERER_CUTSCENE,
			VARDORVIS,
			VARDORVIS_QUEST,
			VARDORVIS_CUTSCENE,
			VARDORVIS_BASE_QUEST,
			VARDORVIS_BASE_POSTQUEST,
			VARDORVIS_BASE,
			DUKE_SUCELLUS_INACTIVE,
			DUKE_SUCELLUS_ASLEEP,
			DUKE_SUCELLUS_AWAKE,
			DUKE_SUCELLUS_DEAD,
			DUKE_SUCELLUS_INACTIVE_QUEST,
			DUKE_SUCELLUS_ASLEEP_QUEST,
			DUKE_SUCELLUS_AWAKE_QUEST,
			DUKE_SUCELLUS_DEAD_QUEST,
			RAIDS_TEKTON_WAITING,
			RAIDS_TEKTON_WALKING_STANDARD,
			RAIDS_TEKTON_FIGHTING_STANDARD,
			RAIDS_TEKTON_WALKING_ENRAGED,
			RAIDS_TEKTON_FIGHTING_ENRAGED,
			RAIDS_TEKTON_HAMMERING,
			RAIDS_ICEDEMON_NONCOMBAT,
			RAIDS_ICEDEMON_COMBAT,
			RAIDS_VANGUARD_DORMANT,
			RAIDS_VANGUARD_WALKING,
			RAIDS_VANGUARD_MELEE,
			RAIDS_VANGUARD_RANGED,
			RAIDS_VANGUARD_MAGIC,
			RAIDS_VESPULA_FLYING,
			RAIDS_VESPULA_ENRAGED,
			RAIDS_VESPULA_WALKING,
			RAIDS_VESPULA_PORTAL,
			RAIDS_VASANISTIRIO_WALKING,
			RAIDS_VASANISTIRIO_HEALING,
			RAIDS_DOGODILE_SUBMERGED,
			RAIDS_DOGODILE_JUNIOR,
			RAIDS_DOGODILE,
			OLM_HEAD,
			TOB_MAIDEN_100,
			TOB_MAIDEN_70,
			TOB_MAIDEN_50,
			TOB_MAIDEN_30,
			TOB_MAIDEN_DYING_A,
			TOB_MAIDEN_DYING_B,
			TOB_BLOAT,
			TOB_BLOAT_STORY,
			TOB_BLOAT_HARD,
			TOBQUEST_BLOAT,
			NYLOCAS_BOSS_SPAWNING,
			NYLOCAS_BOSS_MELEE,
			NYLOCAS_BOSS_MAGIC,
			NYLOCAS_BOSS_RANGED,
			NYLOCAS_BOSS_SPAWNING_STORY,
			NYLOCAS_BOSS_MELEE_STORY,
			NYLOCAS_BOSS_MAGIC_STORY,
			NYLOCAS_BOSS_RANGED_STORY,
			NYLOCAS_BOSS_SPAWNING_HARD,
			NYLOCAS_BOSS_MELEE_HARD,
			NYLOCAS_BOSS_MAGIC_HARD,
			NYLOCAS_BOSS_RANGED_HARD,
			TOBQUEST_NYLOBOSS,
			TOB_SOTETSEG_NONCOMBAT,
			TOB_SOTETSEG_COMBAT,
			TOB_SOTETSEG_NONCOMBAT_STORY,
			TOB_SOTETSEG_COMBAT_STORY,
			TOB_SOTETSEG_NONCOMBAT_HARD,
			TOB_SOTETSEG_COMBAT_HARD,
			TOB_XARPUS_STATIC,
			TOB_XARPUS_FEEDING,
			TOB_XARPUS_COMBAT,
			XARPUS_DEATH,
			TOB_XARPUS_STATIC_STORY,
			TOB_XARPUS_FEEDING_STORY,
			TOB_XARPUS_COMBAT_STORY,
			XARPUS_DEATH_STORY,
			TOB_XARPUS_STATIC_HARD,
			TOB_XARPUS_FEEDING_HARD,
			TOB_XARPUS_COMBAT_HARD,
			XARPUS_DEATH_HARD,
			TOBQUEST_XARPUS,
			VERZIK_INITIAL,
			VERZIK_PHASE1,
			VERZIK_PHASE1_TO2_TRANSITION,
			VERZIK_PHASE2,
			VERZIK_PHASE2_TO3_TRANSITION,
			VERZIK_PHASE3,
			VERZIK_DEATH_BAT,
			VERZIK_INITIAL_STORY,
			VERZIK_PHASE1_STORY,
			VERZIK_PHASE1_TO2_TRANSITION_STORY,
			VERZIK_PHASE2_STORY,
			VERZIK_PHASE2_TO3_TRANSITION_STORY,
			VERZIK_PHASE3_STORY,
			VERZIK_DEATH_BAT_STORY,
			VERZIK_INITIAL_HARD,
			VERZIK_PHASE1_HARD,
			VERZIK_PHASE1_TO2_TRANSITION_HARD,
			VERZIK_PHASE2_HARD,
			VERZIK_PHASE2_TO3_TRANSITION_HARD,
			VERZIK_PHASE3_HARD,
			VERZIK_DEATH_BAT_HARD,
			TOBQUEST_VERZIK,
			TOA_BABA,
			TOA_BABA_COFFIN,
			TOA_BABA_DIGGING,
			AKKHA_SPAWN,
			AKKHA_MELEE,
			AKKHA_RANGE,
			AKKHA_MAGE,
			AKKHA_ENRAGE_SPAWN,
			AKKHA_ENRAGE_INITIAL,
			AKKHA_ENRAGE,
			AKKHA_ENRAGE_DUMMY,
			TOA_KEPHRI_BOSS_SHIELDED,
			TOA_KEPHRI_BOSS_WEAK,
			TOA_KEPHRI_BOSS_ENRAGE,
			TOA_KEPHRI_BOSS_DEAD,
			TOA_ZEBAK,
			TOA_ZEBAK_TAIL,
			TOA_ZEBAK_ENRAGED,
			TOA_ZEBAK_DEAD,
			TOA_ZEBAK_TAIL_DEAD,
			TOA_WARDENS_P1_OBELISK_NPC_INACTIVE,
			TOA_WARDENS_P1_OBELISK_NPC,
			TOA_WARDEN_ELIDINIS_PHASE2_MAGE,
			TOA_WARDEN_ELIDINIS_PHASE2_RANGE,
			TOA_WARDEN_ELIDINIS_PHASE2_EXPOSED,
			TOA_WARDEN_TUMEKEN_PHASE2_MAGE,
			TOA_WARDEN_TUMEKEN_PHASE2_RANGE,
			TOA_WARDEN_TUMEKEN_PHASE2_EXPOSED,
			TOA_WARDEN_TUMEKEN_CORE,
			TOA_WARDEN_ELIDINIS_CORE,
			TOA_WARDEN_ELIDINIS_PHASE3,
			TOA_WARDEN_TUMEKEN_PHASE3,
			TOA_WARDEN_ELIDINIS_PHASE3_CHARGING,
			TOA_WARDEN_TUMEKEN_PHASE3_CHARGING,
			CORP_BEAST,
			KING_DRAGON, // King Black Dragon
			VORKATH_SLEEPING_NOOP,
			VORKATH_SLEEPING,
			VORKATH_QUEST,
			VORKATH,
			VORKATH_TRANSMOG,
			SNAKEBOSS_BOSS_RANGED, // Zulrah
			SNAKEBOSS_BOSS_MELEE, // Zulrah
			SNAKEBOSS_BOSS_MAGIC, // Zulrah
			DARK_SEREN,
			DARK_SEREN_PHANTOM,
			DARK_SEREN_CUTSCENE,
			DARK_SEREN_CUTSCENE_TRAPPED,
			HYDRABOSS,
			HYDRABOSS_P1_TRANSITION,
			HYDRABOSS_P2_TRANSITION,
			HYDRABOSS_P3_TRANSITION,
			HYDRABOSS_4,
			HYDRABOSS_3,
			HYDRABOSS_2,
			HYDRABOSS_FINALDEATH,
			HYDRABOSS_TRANSMOG,
			GB_MOSSGIANT, // Bryophyta
			CALLISTO,
			CALLISTO_SINGLES, // Artio
			CERBERUS_ATTACKING,
			CERBERUS_SITTING,
			CERBERUS_RESETTING,
			CRYSTAL_HUNLLEF_MELEE,
			CRYSTAL_HUNLLEF_RANGED,
			CRYSTAL_HUNLLEF_MAGIC,
			CRYSTAL_HUNLLEF_DEATH,
			CRYSTAL_HUNLLEF_MELEE_HM, // Corrupted Hunllef
			CRYSTAL_HUNLLEF_RANGED_HM, // Corrupted Hunllef
			CRYSTAL_HUNLLEF_MAGIC_HM, // Corrupted Hunllef
			CRYSTAL_HUNLLEF_DEATH_HM, // Corrupted Hunllef
			MOLE_GIANT, // Giant Mole
			CLANCUP_MOLE_GIANT, // Giant Mole
			HESPORI,
			TOBQUEST_HESPORI,
			TRAIL_MIMIC_NONCOMBAT, // The Mimic
			TRAIL_MIMIC_COMBAT, // The Mimic
			NIGHTMARE_PHASE_01,
			NIGHTMARE_PHASE_02,
			NIGHTMARE_PHASE_03,
			NIGHTMARE_WEAK_PHASE_01,
			NIGHTMARE_WEAK_PHASE_02,
			NIGHTMARE_WEAK_PHASE_03,
			NIGHTMARE_BLAST,
			NIGHTMARE_INITIAL,
			NIGHTMARE_DYING,
			NIGHTMARE_ENTRY_READY,
			NIGHTMARE_ENTRY_OPEN,
			NIGHTMARE_ENTRY_CLOSED_01,
			NIGHTMARE_ENTRY_CLOSED_02,
			NIGHTMARE_ENTRY_CLOSED_03,
			NIGHTMARE_CHALLENGE_PHASE_01,
			NIGHTMARE_CHALLENGE_PHASE_02,
			NIGHTMARE_CHALLENGE_PHASE_03,
			NIGHTMARE_CHALLENGE_WEAK_PHASE_01,
			NIGHTMARE_CHALLENGE_WEAK_PHASE_02,
			NIGHTMARE_CHALLENGE_WEAK_PHASE_03,
			NIGHTMARE_CHALLENGE_BLAST,
			NIGHTMARE_CHALLENGE_INITIAL,
			NIGHTMARE_CHALLENGE_DYING,
			HILLGIANT_BOSS, // Obor
			MUSPAH,
			MUSPAH_MELEE,
			MUSPAH_SOULSPLIT,
			MUSPAH_FINAL,
			CATA_BOSS, // Skotizo
			TZHAAR_FIGHTCAVE_SWARM_BOSS, // TzTok-Jad
			INFERNO_JAD,
			INFERNO_TZKALZUK_PLACEHOLDER, // TzKal-Zuk
			JAD_CHALLENGE_JAD,
			CLANCUP_TZHAAR_FIGHTCAVE_SWARM_BOSS,
			VENENATIS,
			VENENATIS_SINGLES, // Spindel
			CLANCUP_VENENATIS,
			VETION,
			VETION_2,
			VETION_TRANS,
			VETION_SINGLE, // Calvar'ion
			VETION_2_SINGLE, // Calvar'ion
			VETION_TRANS_SINGLE,
			VETION_TRANS_2_SINGLE,
			COLOSSEUM_SOL_P1,
			COLOSSEUM_BOSS_SEATED,
			SLAYER_KRAKEN_BOSS,
			SLAYER_KRAKEN_BOSS_WHIRLPOOL,
			DOM_BOSS // Doom of Mokhaiotl
	));
	public static final Map<String, List<String>> BOSS_TO_MINIONS;
	public static final Map<String, String> MINION_TO_BOSS;

	static
	{
		BOSS_TO_MINIONS = Map.of(
				"Nylocas Vasilias", List.of("Nylocas Hagios", "Nylocas Ischyros", "Nylocas Toxobolos")
		);

		MINION_TO_BOSS = BOSS_TO_MINIONS.entrySet().stream()
				.flatMap(entry -> entry.getValue().stream().map(minion -> Map.entry(minion, entry.getKey())))
				.collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue));
	}
}

package com.combatlogger.util;

/**
 * TODO: This shouldn't even be necessary. Would prefer to store id, index, name separately rather than relying on a combined string.
 * 	However, it's already used in many places (including party DamageMessage).
 */
public final class IdParser
{
	/**
	 * Parses the integer portion (id) from an actor string in the format "<id>-<index>".
	 * If the actorString is null, empty, or does not match the "<id>-<index>" format,
	 * or if <id> is not a valid integer, returns -1.
	 */
	public static int parseId(String actorString)
	{
		if (actorString == null || actorString.isEmpty() || !actorString.contains("-"))
		{
			return -1;
		}
		try
		{
			return Integer.parseInt(actorString.substring(0, actorString.indexOf('-')));
		}
		catch (NumberFormatException e)
		{
			return -1;
		}
	}
}

package com.combatlogger;

import net.runelite.client.config.*;

import java.awt.*;

@ConfigGroup("combatlogger")
public interface CombatLoggerConfig extends Config
{
	// SECTIONS
	@ConfigSection(
			position = 0,
			name = "Damage Meter",
			description = "Damage Meter (Overlay + Panel)"
	)
	String damageMeterSection = "damageMeterSection";

	@ConfigSection(
			position = 25,
			name = "Overlay",
			description = "Overlay Settings"
	)
	String overlaySection = "overlaySettings";

	@ConfigSection(
			position = 50,
			name = "Debug",
			description = "Debug",
			closedByDefault = true
	)
	String debugSection = "debugSection";


	/* Damage Meter Settings (currently affects both overlay and panel)
	 * POSITIONS: 1-24
	 * */
	@ConfigItem(
			keyName = "secondaryMetric",
			name = "Secondary Metric",
			description = "Which Secondary Metric to display alongside Damage - e.g. Damage (DPS, %)",
			section = damageMeterSection,
			position = 1

	)
	default SecondaryMetric secondaryMetric()
	{
		return SecondaryMetric.DPS;
	}

	enum SecondaryMetric
	{DPS, TICKS,}

	@ConfigItem(
			keyName = "selfDamageMeterColor",
			name = "Self Color",
			description = "Color that will represent you in both the panel and overlay when not in a party.",
			section = damageMeterSection,
			position = 2
	)
	default Color selfDamageMeterColor()
	{
		return new Color(139, 15, 16);
	}

	/* Overlay Settings
	 * POSITIONS: 26-49
	 * */
	@ConfigItem(
			keyName = "enableOverlay",
			name = "Enable Overlay",
			description = "Toggles the display of the overlay",
			section = overlaySection,
			position = 26
	)
	default boolean enableOverlay()
	{
		return true;
	}

	@ConfigItem(
			keyName = "showOverlayAvatar",
			name = "Show Overlay Avatar",
			description = "Toggles the display of the party avatar (or default) within the overlay",
			section = overlaySection,
			position = 27
	)
	default boolean showOverlayAvatar()
	{
		return false;
	}

	@ConfigItem(
			keyName = "overlayTimeout",
			name = "Overlay Timeout",
			description = "Hides the overlay after a period of time outside of combat",
			section = overlaySection,
			position = 28
	)
	@Units(Units.MINUTES)
	default int overlayTimeout()
	{
		return 5;
	}

	@Range(max = 100)
	@Units(Units.PERCENT)
	@ConfigItem(
			keyName = "overlayOpacity",
			name = "Overlay Opacity",
			description = "Adjusts the opacity of the overlay (0-100%)",
			section = overlaySection,
			position = 29
	)
	default int overlayOpacity()
	{
		return 100;
	}

	@Range(max = 100)
	@Units(Units.PERCENT)
	@ConfigItem(
			keyName = "backgroundOpacity",
			name = "Background Opacity",
			description = "Transparency of the overlay's background",
			section = overlaySection,
			position = 31
	)
	default int backgroundOpacity() { return 60; }


	/* Debug Settings
	 * POSITIONS: 51-74
	 * */
	@ConfigItem(
			keyName = "logInChat",
			name = "Log In Chat (Debug)",
			description = "Display logs in chat" +
					"<br><strong>This is very excessive, mostly for testing/verification.<strong>",
			warning = "Enabling this will spam your chat with combat messages. This option is mostly for debugging and is not necessary for the text file logging or damage meter.",
			section = debugSection,
			position = 51
	)
	default boolean logInChat()
	{
		return false;
	}


}

package com.combatlogger;

import com.combatlogger.model.Fight;
import com.combatlogger.model.PlayerStats;
import com.combatlogger.model.logs.*;
import com.combatlogger.util.AnimationIds;
import com.combatlogger.util.BoundedQueue;
import lombok.Getter;
import lombok.Setter;
import net.runelite.api.ChatMessageType;
import net.runelite.api.Client;
import net.runelite.api.NPC;
import net.runelite.api.Player;
import net.runelite.api.events.ChatMessage;
import net.runelite.client.eventbus.EventBus;
import net.runelite.api.events.NpcSpawned;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.party.PartyMember;
import net.runelite.client.party.PartyService;
import net.runelite.client.plugins.party.PartyPluginService;
import net.runelite.client.plugins.party.data.PartyData;
import net.runelite.client.events.ConfigChanged;

import javax.inject.Inject;
import javax.inject.Singleton;
import java.awt.*;
import java.util.*;
import java.util.List;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.regex.Pattern;
import java.util.stream.Collectors;

import static com.combatlogger.CombatLoggerPlugin.getCurrentTimestamp;
import static com.combatlogger.util.BoatIds.BOAT_IDS;
import static com.combatlogger.util.BossIds.*;
import static com.combatlogger.util.HitSplatUtil.NON_DAMAGE_HITSPLATS;
import static com.combatlogger.util.IdParser.parseId;

@Singleton
public class FightManager
{
	private final Client client;
	private final Map<String, Color> playerColors = new ConcurrentHashMap<>();
	private final EventBus eventBus;

	@Getter
	private final BoundedQueue<Fight> fights = new BoundedQueue<>(20);

	private final CombatLoggerConfig config;

	@Inject
	private PartyPluginService partyPluginService;

	@Inject
	private PartyService partyService;

	@Inject
	private LogQueueManager logQueueManager;

	@Inject
	private ChatMessageManager chatMessageManager;

	@Setter
	private Fight selectedFight;

	// Define the default color list
	private final Color[] defaultColors = {
			Color.decode("#8B0F10"), // Red
			Color.decode("#A330C9"), // Dark Magenta
			Color.decode("#FF7C0A"), // Orange
			Color.decode("#33937F"), // Dark Emerald
			Color.decode("#AAD372"), // Pistachio
			Color.decode("#3FC7EB"), // Light Blue
			Color.decode("#00FF98"), // Spring Green
			Color.decode("#F48CBA"), // Pink
			Color.decode("#FFFFFF"), // White
			Color.decode("#FFF468"), // Yellow
			Color.decode("#0070DD"), // Blue
			Color.decode("#8788EE"), // Purple
			Color.decode("#C69B6D")  // Tan
	};

	private final AtomicInteger colorIndex = new AtomicInteger(0);

	@Inject
	public FightManager(
			Client client,
			CombatLoggerConfig config,
			EventBus eventBus
	)
	{
		this.client = client;
		this.config = config;
		this.eventBus = eventBus;
		eventBus.register(this);
	}

	public void shutDown()
	{
		eventBus.unregister(this);
	}


	public List<PlayerStats> getPlayerDamageForFight(Fight fight)
	{
		if (fight == null)
		{
			return Collections.emptyList();
		}

		// Aggregate stats (e.g., damage) by player
		Map<String, PlayerStats> playerStatsMap = fight.getPlayerDataMap().entrySet().stream()
				.collect(Collectors.toMap(
						Map.Entry::getKey, // Player name
						entry -> {
							int totalDamage = entry.getValue().getTargetDataMap().values().stream()
									.mapToInt(Fight.PlayerData.PlayerTargetData::getDamage)
									.sum();
							int totalActivityTicks = entry.getValue().getTargetDataMap().values().stream()
									.mapToInt(Fight.PlayerData.PlayerTargetData::getActivityTicks)
									.sum();
							return new PlayerStats(entry.getKey(), totalDamage, totalActivityTicks);
						},
						(existing, replacement) -> replacement // If a key collision occurs while mapping, include the replacement and discard existing
				));

		return calculatePlayerStats(fight, playerStatsMap);
	}

	public List<PlayerStats> getBreakdownDamage(Fight fight, String player)
	{
		if (fight == null || !fight.getPlayerDataMap().containsKey(player))
		{
			return Collections.emptyList();
		}

		Map<String, PlayerStats> playerStatsMap = fight.getPlayerDataMap().get(player).getTargetDataMap().entrySet().stream()
				.collect(Collectors.toMap(
						Map.Entry::getKey,
						entry -> new PlayerStats(entry.getKey(), entry.getValue().getDamage(), entry.getValue().getActivityTicks())
				));

		return calculatePlayerStats(fight, playerStatsMap);
	}

	public List<PlayerStats> calculatePlayerStats(Fight fight, Map<String, PlayerStats> playerStatsMap)
	{
		List<PlayerStats> playerStatsList = new ArrayList<>();
		double fightLengthSeconds = fight.getFightLengthTicks() * 0.6;
		int totalDamage = playerStatsMap.values().stream().mapToInt(PlayerStats::getDamage).sum();

		playerStatsMap.forEach((name, playerStats) -> {
			double dps = fightLengthSeconds > 0 ? (double) playerStats.getDamage() / fightLengthSeconds : 0;
			double percentOfTotalDamage = totalDamage > 0 ? ((double) playerStats.getDamage() / totalDamage * 100) : 0;

			// Ensure that percentage damage is not NaN
			if (Double.isNaN(percentOfTotalDamage))
			{
				percentOfTotalDamage = 0;
			}

			playerStats.setDps(dps);
			playerStats.setPercentDamage(percentOfTotalDamage);
			playerStatsList.add(playerStats);
		});

		playerStatsList.sort(Comparator.comparingInt(PlayerStats::getDamage).reversed());

		return playerStatsList;
	}

	public synchronized Fight getLastFight()
	{
		if (!fights.isEmpty())
		{
			return fights.peekLast();
		}
		return null;
	}

	public void endCurrentFight()
	{
		if (!fights.isEmpty() && !fights.peekLast().isOver())
		{
			fights.peekLast().setOver(true);
		}
	}

	public synchronized void setCurrentFight(Fight fight)
	{
		if (fight == null)
		{
			return;
		}
		// End the current fight if it's still active
		endCurrentFight();
		// Add the new fight as the current fight
		fights.add(fight);
	}

	public void clearFights()
	{
		fights.clear();
		selectedFight = null;
		clearPlayerColors();  // Optionally clear player colors when clearing fights
	}

	/**
	 * Retrieves the color associated with a player. If the player is in a party, their party color is used.
	 * Otherwise, a default color from the predefined list is assigned. Once all colors are used, the colors will repeat.
	 *
	 * @param playerName The name of the player.
	 * @return The Color assigned to the player.
	 */
	public Color getPlayerColor(String playerName)
	{
		// First, check if the player is part of a party
		PartyMember partyMember = partyService.getMemberByDisplayName(playerName);
		if (partyMember != null)
		{
			PartyData partyData = partyPluginService.getPartyData(partyMember.getMemberId());
			if (partyData != null && partyData.getColor() != null)
			{
				return partyData.getColor();
			}
		}

		// else proceed with existing logic
		PartyMember localMember = partyService.getLocalMember();
		Player player = client.getLocalPlayer();
		String localPlayerName = localMember == null ? player.getName() : localMember.getDisplayName();

		if (Objects.equals(playerName, localPlayerName))
		{
			return config.selfDamageMeterColor();
		}

		// Assign a default color from the list, caching the result
		return playerColors.computeIfAbsent(playerName, name -> {
			int index = colorIndex.getAndIncrement() % defaultColors.length;
			return defaultColors[index];
		});
	}

	/**
	 * Clears cached player colors for non-party players and resets the color index.
	 */
	public void clearPlayerColors()
	{
		playerColors.clear();
		colorIndex.set(0);
	}

	public void addDamage(DamageLog damageLog)
	{
		if (NON_DAMAGE_HITSPLATS.contains(damageLog.getHitsplatName()))
		{
			return;
		}

		if (BOAT_IDS.contains(parseId(damageLog.getTarget())))
		{
			// Exclude boats from damage meter - there's not even a clear way to tell whose boat is being damaged
			return;
		}

		Fight currentFight;

		if (fights.isEmpty() || fights.peekLast().isOver())
		{
			if (damageLog.getSource().equals("Unknown")
					&& !BOSS_IDS.contains(parseId(damageLog.getTarget()))
					&& !MINION_TO_BOSS.containsKey(damageLog.getTargetName()))
			{
				// Don't start a fight if the source is Unknown unless the target is a boss or minion
				return;
			}
			currentFight = new Fight();
			currentFight.setFightLengthTicks(1);
			currentFight.setFightName(damageLog.getTargetName());
			currentFight.setMainTarget(damageLog.getTarget());
			fights.add(currentFight);
			selectedFight = currentFight; // Set the new fight as the selected fight
		}
		else
		{
			currentFight = fights.peekLast();

			if (
					BOSS_IDS.contains(parseId(damageLog.getTarget()))
							&& (
							!currentFight.getMainTarget().equals(damageLog.getTarget())
									|| !currentFight.getFightName().equals(damageLog.getTargetName())
					)
			)
			{
				// If we are in the middle of a fight and encounter a boss, change the fight name and main target
				currentFight.setFightName(damageLog.getTargetName());
				currentFight.setMainTarget(damageLog.getTarget());
			}

			String bossName = MINION_TO_BOSS.get(damageLog.getTargetName());
			if (bossName != null)
			{
				// If we encounter a minion of a boss, change the fight name and main target to the boss
				currentFight.setFightName(bossName);
				currentFight.setMainTarget(bossName);
			}
		}

		currentFight.setLastActivityTick(client.getTickCount());

		Fight.PlayerData playerData = currentFight.getPlayerDataMap().get(damageLog.getSource());
		if (playerData == null)
		{
			playerData = new Fight.PlayerData(damageLog.getSource());
		}
		playerData.addDamage(damageLog.getTargetName(), damageLog.getDamageAmount());
		currentFight.getPlayerDataMap().put(damageLog.getSource(), playerData);
	}

	public void addTicks(AttackAnimationLog attackAnimationLog)
	{
		Fight currentFight;

		if (fights.isEmpty() || fights.peekLast().isOver())
		{
			if (!attackAnimationLog.getSource().equals(client.getLocalPlayer().getName())
					&& !BOSS_IDS.contains(parseId(attackAnimationLog.getTarget()))
					&& !MINION_TO_BOSS.containsKey(attackAnimationLog.getTargetName()))
			{
				// Don't start a fight if the source is not us unless it's a boss or minion
				return;
			}
			currentFight = new Fight();
			currentFight.setFightLengthTicks(1); // Ensure at least 1 tick to prevent zero duration
			currentFight.setFightName(attackAnimationLog.getTargetName());
			currentFight.setMainTarget(attackAnimationLog.getTarget());
			fights.add(currentFight);
			selectedFight = currentFight; // Set the new fight as the selected fight
		}
		else
		{
			currentFight = fights.peekLast();
		}

		currentFight.setLastActivityTick(client.getTickCount());

		Fight.PlayerData playerData = currentFight.getPlayerDataMap().get(attackAnimationLog.getSource());
		if (playerData == null)
		{
			playerData = new Fight.PlayerData(attackAnimationLog.getSource());
		}
		playerData.addActivityTicks(attackAnimationLog.getTargetName(),
				AnimationIds.getTicks(attackAnimationLog.getAnimationId(), attackAnimationLog.getWeaponId()));
		currentFight.getPlayerDataMap().put(attackAnimationLog.getSource(), playerData);
	}

	public void recordDeath(DeathLog deathLog)
	{
		if (!fights.isEmpty() && !fights.peekLast().isOver() && fights.peekLast().getMainTarget().equals(deathLog.getTarget()))
		{
			// The main fight target has died; end the fight
			fights.peekLast().setOver(true);
		}
	}

	public void handleGameMessage(GameMessageLog gameMessageLog)
	{
		String message = gameMessageLog.getMessage();
		if (message.startsWith("Challenge started: Path of"))
		{
			String fightName = message.substring("Challenge started: ".length()).replace(".", "");
			Fight newFight = new Fight();
			newFight.setFightLengthTicks(1); // Ensure at least 1 tick
			newFight.setLastActivityTick(client.getTickCount());
			newFight.setFightName(fightName);
			newFight.setMainTarget(fightName);
			fights.add(newFight);
			selectedFight = newFight; // Set the new fight as the selected fight
		}
		else if (message.startsWith("Challenge complete: Path of") || message.startsWith("Challenge complete: The Wardens"))
		{
			if (!fights.isEmpty() && !fights.peekLast().isOver())
			{
				fights.peekLast().setOver(true);
			}
		}
	}

	public void recordNPCTargetingPlayer(TargetChangeLog targetChangeLog)
	{
		if ((fights.isEmpty() || fights.peekLast().isOver())
				&& BOSS_IDS.contains(parseId(targetChangeLog.getSource())))
		{
			// A boss has targeted a player; start a new fight
			Fight newFight = new Fight();
			newFight.setFightLengthTicks(1); // Ensure at least 1 tick
			newFight.setLastActivityTick(client.getTickCount());
			newFight.setFightName(targetChangeLog.getSourceName());
			newFight.setMainTarget(targetChangeLog.getSource());
			fights.add(newFight);
			selectedFight = newFight; // Set the new fight as the selected fight
		}
	}

	public void handleNpcChanged(NpcChangedLog npcChangedLog)
	{
		if (fights.isEmpty() || fights.peekLast().isOver())
		{
			return;
		}

		Fight currentFight = fights.peekLast();
		if (currentFight.getMainTarget().equals(npcChangedLog.getOldNpc()))
		{
			currentFight.setMainTarget(npcChangedLog.getNewNpc());
		}
	}

	@Subscribe
	public void onChatMessage(ChatMessage event)
	{
		if (event.getType() != ChatMessageType.GAMEMESSAGE || "combat-logger".equals(event.getSender()))
		{
			return;
		}

		String message = event.getMessage();
		if (ENCOUNTER_PATTERN.matcher(message).find())
		{
			GameMessageLog gameMessageLog = new GameMessageLog(
					client.getTickCount(),
					getCurrentTimestamp(),
					message
			);

			handleGameMessage(gameMessageLog);

			// Optionally, queue the game message log
			if (logQueueManager != null)
			{
				logQueueManager.queue(gameMessageLog);
			}
		}
	}

	// Regular expression pattern for specific chat messages
	private static final Pattern ENCOUNTER_PATTERN = Pattern.compile("(Wave|Duration|Challenge)", Pattern.CASE_INSENSITIVE);

	@Subscribe
	public void onNpcSpawned(NpcSpawned npcSpawned)
	{
		NPC npc = npcSpawned.getNpc();

		if (VERZIK_P1_END.contains(npc.getId()) && !fights.isEmpty() && !fights.peekLast().isOver())
		{
			// P1 Verzik doesn't die, so send a fake death event when it changes forms
			DeathLog deathLog = new DeathLog(
					client.getTickCount(),
					getCurrentTimestamp(),
					String.format("%s dies", fights.peekLast().getMainTarget()),
					fights.peekLast().getMainTarget()
			);

			recordDeath(deathLog);

			// Optionally, queue the death log for writing
			if (logQueueManager != null)
			{
				logQueueManager.queue(deathLog);
			}
		}
	}

	public Fight getSelectedFight()
	{
		if (selectedFight == null && !fights.isEmpty())
		{
			return fights.peekLast();
		}
		return selectedFight;
	}

	/**
	 * Returns either black or white based on the luminance of the provided color (ITU-R BT.601-7 FORMULA)
	 */
	public Color getContrastingColor(Color bg) {
		double luminance = 0.299 * bg.getRed() + 0.587 * bg.getGreen() + 0.114 * bg.getBlue();
		return luminance > 128 ? Color.BLACK : Color.WHITE;
	}

	/**
	 * Subscribe to configuration changes to update player colors when relevant config options change.
	 *
	 * @param event The ConfigChanged event.
	 */
	@Subscribe
	public void onConfigChanged(ConfigChanged event)
	{
		if (!"combatLogger".equals(event.getGroup()))
		{
			return;
		}

		// Check if the change affects player colors
		if ("damageMeterColor".equals(event.getKey()) || "someOtherColorRelatedKey".equals(event.getKey()))
		{
			// Clear cached player colors to ensure updated colors are used
			clearPlayerColors();
		}
	}
}

package com.combatlogger.model.logs;

import lombok.Getter;

@Getter
public class NpcChangedLog extends Log
{
	private final String oldNpc; // <id>-<index>
	private final String newNpc; // <id>-<index>

	public NpcChangedLog(int tickCount, String timestamp, String message, String oldNpc, String newNpc)
	{
		super(tickCount, timestamp, message);
		this.oldNpc = oldNpc;
		this.newNpc = newNpc;
	}
}

package com.combatlogger.model.logs;

import lombok.Getter;
import lombok.Setter;

@Getter
public class Log
{
	private final int tickCount;

	private final String timestamp;

	@Setter
	private String message;

	public Log(int tickCount, String timestamp, String message)
	{
		this.tickCount = tickCount;
		this.timestamp = timestamp;
		this.message = message;
	}
}

package com.combatlogger.model.logs;

import lombok.Getter;
import lombok.Setter;

@Getter
public class DamageLog extends Log
{
	@Setter
	private String source;

	private final String target; // <id>-<index> or <playerName>

	private final String targetName;

	@Setter
	private String hitsplatName;

	private final int damageAmount;

	public DamageLog(int tickCount, String timestamp, String message, String source, String target, String targetName, int damageAmount, String hitsplatName)
	{
		super(tickCount, timestamp, message);
		this.damageAmount = damageAmount;
		this.source = source;
		this.target = target;
		this.targetName = targetName;
		this.hitsplatName = hitsplatName;
	}
}

package com.combatlogger.model.logs;

import lombok.Getter;

@Getter
public class TargetChangeLog extends Log
{
	private final String source; // <id>-<index> or <playerName>
	private final String sourceName;

	private final String target; // <id>-<index> or <playerName>


	public TargetChangeLog(int tickCount, String timestamp, String message, String source, String sourceName, String target)
	{
		super(tickCount, timestamp, message);
		this.source = source;
		this.sourceName = sourceName;
		this.target = target;
	}
}

package com.combatlogger.model.logs;

import lombok.Getter;

@Getter
public class DeathLog extends Log
{
	private final String target; // <id>-<index> or <playerName>

	public DeathLog(int tickCount, String timestamp, String message, String target)
	{
		super(tickCount, timestamp, message);
		this.target = target;
	}
}

package com.combatlogger.model.logs;

import lombok.Getter;

@Getter
public class AttackAnimationLog extends Log
{
	private final String source;
	private final String target; // <id>-<index> or <playerName>
	private final String targetName;
	private final int animationId;
	private final int weaponId;

	public AttackAnimationLog(int tickCount, String timestamp, String message, String source, String target, String targetName, int animationId, int weaponId)
	{
		super(tickCount, timestamp, message);
		this.source = source;
		this.target = target;
		this.targetName = targetName;
		this.animationId = animationId;
		this.weaponId = weaponId;
	}
}

package com.combatlogger.model.logs;

import lombok.Getter;

@Getter
public class GameMessageLog extends Log
{
	public GameMessageLog(int tickCount, String timestamp, String message)
	{
		super(tickCount, timestamp, message);
	}
}

package com.combatlogger.model;

import lombok.Getter;
import lombok.Setter;
import net.runelite.api.coords.WorldPoint;

@Getter
@Setter
public class TrackedGraphicObject
{
	private int id;
	private WorldPoint worldPoint;
}

package com.combatlogger.model;

import lombok.Getter;
import lombok.Setter;
import net.runelite.api.coords.WorldPoint;

import java.util.List;

@Getter
@Setter
public class TrackedPartyMember
{
	private WorldPoint worldPoint;
	private boolean usingCombatLoggerPlugin = false;
	private List<Integer> previousEquipment;
	private int previousOverheadPrayerId = -2; // -2 represents unknown
}

package com.combatlogger.model;

import lombok.Getter;
import lombok.Setter;

import java.awt.Color;

@Getter
@Setter
public class PlayerStats
{
	private String name;
	private int damage;
	private double dps;
	private int ticks;
	private double percentDamage;
	private Color color;

	public PlayerStats(String name, int damage, int ticks)
	{
		this.name = name;
		this.damage = damage;
		this.ticks = ticks;
		this.color = null;
	}
}

package com.combatlogger.model;

import lombok.Getter;
import lombok.Setter;

import java.time.Duration;
import java.util.HashMap;
import java.util.concurrent.ConcurrentHashMap;

@Getter
@Setter
public class Fight
{
	private String fightName;

	private String mainTarget; // <id>-<index>

	private ConcurrentHashMap<String, PlayerData> playerDataMap = new ConcurrentHashMap<>();

	private int fightLengthTicks = 0;

	private int lastActivityTick = 0;

	private boolean isOver = false;

	@Override
	public String toString()
	{
		if (this.isOver)
		{
			return fightName + " - " + formatTime(fightLengthTicks);
		}
		else
		{
			return fightName;
		}
	}

	public static String formatTime(int ticks)
	{
		long totalMilliseconds = ticks * 600L;
		Duration duration = Duration.ofMillis(totalMilliseconds);
		long minutes = duration.toMinutes();
		long seconds = (duration.getSeconds() % 60);
		long tenths = (totalMilliseconds / 100) % 10;

		// Format as MM:SS.s
		return String.format("%02d:%02d.%d", minutes, seconds, tenths);
	}

	public static class PlayerData
	{
		private final String name;

		@Getter
		private ConcurrentHashMap<String, PlayerTargetData> targetDataMap = new ConcurrentHashMap<>(); // key=target

		public PlayerData(String name)
		{
			this.name = name;
		}

		public void addDamage(String target, int damage)
		{
			targetDataMap.computeIfAbsent(target, k -> new PlayerTargetData(0, 0))
					.setDamage(targetDataMap.get(target).getDamage() + damage);
		}

		public void addActivityTicks(String target, int ticks)
		{
			targetDataMap.computeIfAbsent(target, k -> new PlayerTargetData(0, 0))
					.setActivityTicks(targetDataMap.get(target).getActivityTicks() + ticks);
		}

		@Getter
		@Setter
		public static class PlayerTargetData
		{
			private int damage;
			private int activityTicks;

			public PlayerTargetData(int damage, int activityTicks)
			{
				this.damage = damage;
				this.activityTicks = activityTicks;
			}
		}
	}
}

package com.combatlogger.model;

import lombok.Getter;
import lombok.Setter;
import net.runelite.api.coords.WorldPoint;

@Getter
@Setter
public class TrackedNpc
{
	private int id;
	private int index;
	private WorldPoint worldPoint;
}

package com.combatlogger.messages;

import lombok.EqualsAndHashCode;
import lombok.Value;
import net.runelite.client.party.messages.PartyMemberMessage;

import java.util.List;

@Value
@EqualsAndHashCode(callSuper = true)
public class BoostedCombatStatsMessage extends PartyMemberMessage
{
	List<Integer> stats;
}

package com.combatlogger.messages;

import lombok.EqualsAndHashCode;
import lombok.Value;
import net.runelite.client.party.messages.PartyMemberMessage;

import java.util.List;

@Value
@EqualsAndHashCode(callSuper = true)
public class PrayerMessage extends PartyMemberMessage
{
	List<Integer> prayerIds;
}

package com.combatlogger.messages;

import lombok.EqualsAndHashCode;
import lombok.Value;
import net.runelite.client.party.messages.PartyMemberMessage;

@Value
@EqualsAndHashCode(callSuper = true)
public class DamageMessage extends PartyMemberMessage
{
	String target; // <id>-<index> or <playerName>
	String targetName;
	String hitsplatName;
	int damage;
}

package com.combatlogger.messages;

import lombok.EqualsAndHashCode;
import lombok.Value;
import net.runelite.client.party.messages.PartyMemberMessage;

import java.util.List;

@Value
@EqualsAndHashCode(callSuper = true)
public class EquipmentMessage extends PartyMemberMessage
{
	List<Integer> itemIds;
}

package com.combatlogger.messages;

import lombok.EqualsAndHashCode;
import lombok.Value;
import net.runelite.client.party.messages.PartyMemberMessage;

import java.util.List;

@Value
@EqualsAndHashCode(callSuper = true)
public class BaseCombatStatsMessage extends PartyMemberMessage
{
	List<Integer> stats;
}

package com.combatlogger;

import com.combatlogger.messages.DamageMessage;
import com.combatlogger.model.logs.*;
import com.combatlogger.util.HitSplatUtil;
import net.runelite.api.ChatMessageType;
import net.runelite.api.Client;
import net.runelite.api.events.GameTick;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.chat.QueuedMessage;
import net.runelite.client.eventbus.EventBus;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.party.PartyMember;
import net.runelite.client.party.PartyService;

import javax.inject.Inject;
import javax.inject.Singleton;
import java.io.BufferedWriter;
import java.io.FileWriter;
import java.io.IOException;
import java.util.Queue;
import java.util.concurrent.ConcurrentLinkedQueue;

import static com.combatlogger.CombatLoggerPlugin.LOG_FILE;
import static com.combatlogger.CombatLoggerPlugin.getCurrentTimestamp;

@Singleton
public class LogQueueManager
{
	private final Client client;
	private final Queue<Log> logQueue = new ConcurrentLinkedQueue<>();

	@Inject
	private ChatMessageManager chatMessageManager;

	@Inject
	private CombatLoggerConfig config;

	@Inject
	private PartyService party;

	@Inject
	private FightManager fightManager;

	@Inject
	private LogQueueManager(Client client)
	{
		this.client = client;
	}

	public void startUp(EventBus eventBus)
	{
		eventBus.register(this);
	}

	public void shutDown(EventBus eventBus)
	{
		eventBus.unregister(this);
	}

	@Subscribe
	public void onGameTick(GameTick event)
	{
		int currentTick = client.getTickCount();

		// Wait until 2 ticks have passed before writing to the log file
		// So that we can enrich the data from other players in the Party with DamageMessage
		while (!logQueue.isEmpty() && currentTick >= logQueue.peek().getTickCount() + 2)
		{
			Log log = logQueue.poll();
			log(log.getTickCount(), log.getTimestamp(), log.getMessage());

			if (log instanceof DamageLog && isNPC(((DamageLog) log).getTarget()))
			{
				fightManager.addDamage((DamageLog) log);
			}
			else if (log instanceof DeathLog && isNPC(((DeathLog) log).getTarget()))
			{
				fightManager.recordDeath((DeathLog) log);
			}
			else if (log instanceof TargetChangeLog && isNPC(((TargetChangeLog) log).getSource()) && !isNPC(((TargetChangeLog) log).getTarget()))
			{
				fightManager.recordNPCTargetingPlayer((TargetChangeLog) log);
			}
			else if (log instanceof GameMessageLog)
			{
				fightManager.handleGameMessage((GameMessageLog) log);
			}
			else if (log instanceof AttackAnimationLog)
			{
				fightManager.addTicks((AttackAnimationLog) log);
			}
			else if (log instanceof NpcChangedLog)
			{
				fightManager.handleNpcChanged((NpcChangedLog) log);
			}
		}

		// No need to call panel.onGameTick(event); as FightManager handles game ticks.
	}

	private void log(int tickCount, String timestamp, String message)
	{
		try (BufferedWriter writer = new BufferedWriter(new FileWriter(LOG_FILE, true)))
		{
			writer.write(String.format("%s %s\t%s\n", tickCount, timestamp, message));
			if (config.logInChat())
			{
				chatMessageManager
						.queue(QueuedMessage.builder()
								.type(ChatMessageType.GAMEMESSAGE)
								.sender("combat-logger")
								.runeLiteFormattedMessage(message.replace("\t", " "))
								.build());
			}
		}
		catch (IOException e)
		{
			e.printStackTrace();
		}
	}

	@Subscribe
	protected void onDamageMessage(DamageMessage event)
	{
		PartyMember localMember = party.getLocalMember();

		if (localMember == null || localMember.getMemberId() == event.getMemberId())
		{
			// Don't need to update logs from ourselves
			return;
		}

		PartyMember eventMember = party.getMemberById(event.getMemberId());
		String newHitsplatName = HitSplatUtil.replaceMeWithNewOther(event.getHitsplatName());

		// Find a matching damage log in the queue and then add the source of the damage and rename the hitsplat appropriately
		boolean matchFound = false;
		for (Log log : logQueue)
		{
			if (log instanceof DamageLog)
			{
				DamageLog damageLog = (DamageLog) log;
				if (damageLog.getSource().equals("Unknown")
						&& event.getDamage() == damageLog.getDamageAmount()
						&& event.getTarget().equals(damageLog.getTarget())
						&& HitSplatUtil.replaceMeWithExistingOther(event.getHitsplatName()).equals(damageLog.getHitsplatName()))
				{
					// Match found, update the existing damage log
					damageLog.setHitsplatName(newHitsplatName);
					damageLog.setSource(eventMember.getDisplayName());
					damageLog.setMessage(String.format("%s\t%s\t%s\t%d", eventMember.getDisplayName(), newHitsplatName, event.getTarget(), event.getDamage()));
					matchFound = true;
					break;
				}
			}
		}

		// If no match is found, add a new damage log to the queue
		if (!matchFound)
		{
			queue(
					new DamageLog(
							client.getTickCount(),
							getCurrentTimestamp(),
							String.format("%s\t%s\t%s\t%d", eventMember.getDisplayName(), newHitsplatName, event.getTarget(), event.getDamage()),
							eventMember.getDisplayName(),
							event.getTarget(),
							event.getTargetName(),
							event.getDamage(),
							newHitsplatName)
			);
		}
	}

	public void queue(Log log)
	{
		logQueue.add(log);
	}

	public void queue(String message)
	{
		logQueue.add(
				new Log(
						client.getTickCount(),
						getCurrentTimestamp(),
						message
				));
	}

	public static boolean isNPC(String name)
	{
		return name.matches("\\d+-\\d+");
	}
}

package com.combatlogger.overlay;

import java.awt.*;
import java.awt.image.BufferedImage;
import java.util.List;
import java.util.concurrent.ConcurrentHashMap;
import java.util.Map;
import javax.inject.Inject;

import com.combatlogger.FightManager;
import com.combatlogger.CombatLoggerConfig;
import com.combatlogger.CombatLoggerPlugin;
import com.combatlogger.model.Fight;
import com.combatlogger.model.PlayerStats;
import lombok.Setter;
import net.runelite.client.plugins.party.PartyPluginService;
import net.runelite.client.ui.overlay.*;
import net.runelite.client.ui.overlay.components.ComponentConstants;
import net.runelite.api.*;
import net.runelite.api.Point;
import net.runelite.client.party.PartyService;
import net.runelite.client.ui.FontManager;
import net.runelite.client.party.PartyMember;
import net.runelite.client.ui.overlay.tooltip.Tooltip;
import net.runelite.client.ui.overlay.tooltip.TooltipManager;
import net.runelite.client.util.ImageUtil;

public class CombatLoggerOverlay extends OverlayPanel
{
	private final CombatLoggerPlugin combatLoggerPlugin;
	private final PartyService partyService;
	private final CombatLoggerConfig config;
	private final Client client;
	private final TooltipManager tooltipManager;
	private final FightManager fightManager;

	private final BufferedImage defaultAvatar;
	private final BufferedImage settingsIcon;
	private final Map<String, BufferedImage> avatarCache = new ConcurrentHashMap<>();
	private Fight cachedFight = null;
	private int cachedFightLength = -1;
	private List<PlayerStats> playerStatCache;

	@Setter
	private int opacity;

	static final String IMAGE_DEFAULT_AVATAR_PATH = "/default_avatar.png";
	static final String IMAGE_SETTINGS_PATH = "/settings.png";
	static final int LINE_HEIGHT = 16;
	static final Dimension MIN_SIZE = new Dimension((int) Math.floor((double) ComponentConstants.STANDARD_WIDTH / 2), LINE_HEIGHT * 2); //header + 1 row
	static final Dimension DEFAULT_SIZE = new Dimension((int) Math.floor(ComponentConstants.STANDARD_WIDTH * 1.5), LINE_HEIGHT * 4); //header + 3 rows
	static final int DEFAULT_BACKGROUND_ALPHA = 120;
	static final int DEFAULT_HEADER_ALPHA = 200;
	static final int DEFAULT_BAR_ALPHA = 255;

	@Inject
	public CombatLoggerOverlay(
			CombatLoggerPlugin plugin,
			Client client,
			CombatLoggerConfig config,
			PartyService partyService,
			TooltipManager tooltipManager,
			PartyPluginService partyPluginService,
			FightManager fightManager
	)
	{
		super(plugin);

		setPosition(OverlayPosition.ABOVE_CHATBOX_RIGHT);
		setPriority(PRIORITY_HIGHEST);
		setPreferredSize(DEFAULT_SIZE);

		this.combatLoggerPlugin = plugin;
		this.config = config;
		this.partyService = partyService;
		this.tooltipManager = tooltipManager;
		this.client = client;
		this.fightManager = fightManager;
		this.opacity = config.overlayOpacity();

		defaultAvatar = loadImage(IMAGE_DEFAULT_AVATAR_PATH);
		settingsIcon = loadImage(IMAGE_SETTINGS_PATH);
	}

	@Override
	public Dimension render(Graphics2D graphics)
	{
		if (!config.enableOverlay() || !combatLoggerPlugin.getOverlayVisible())
		{
			return null;
		}

		Fight selectedFight = fightManager.getSelectedFight();
		if (selectedFight == null)
		{
			// No fight is selected; reset cache and prevent rendering
			cachedFight = null;
			cachedFightLength = -1;
			return null;
		}

		List<PlayerStats> playerStats;
		if (selectedFight.equals(cachedFight) && selectedFight.getFightLengthTicks() == cachedFightLength)
		{
			playerStats = playerStatCache;
		}
		else
		{
			playerStats = playerStatCache = fightManager.getPlayerDamageForFight(selectedFight);
			cachedFight = selectedFight;
			cachedFightLength = selectedFight.getFightLengthTicks();
		}

		if (playerStats.isEmpty())
		{
			return null;
		}


		Dimension currentSize = this.getBounds().getSize();

		if (currentSize.height == 0 && currentSize.width == 0)
		{
			currentSize = DEFAULT_SIZE;
		}

		//ensure min height/width are enforced
		currentSize.width = Math.max(currentSize.width, MIN_SIZE.width);
		currentSize.height = Math.max(currentSize.height, MIN_SIZE.height);

		graphics.setFont(FontManager.getRunescapeSmallFont());
		FontMetrics metrics = graphics.getFontMetrics();

		// Draw the background for the entire overlay with adjusted transparency
		int bgOpacity = (int) Math.round( (opacity / 100.0) * (config.backgroundOpacity() / 100.0)  * 255); // take the lowest between opacity and bg opacity
		graphics.setColor(new Color(50, 50, 50, (int) Math.round((opacity / 100.0) * bgOpacity))); // Semi-transparent gray background
		graphics.fillRect(0, 0, currentSize.width, currentSize.height);

		// Draw the header background with adjusted transparency
		graphics.setColor(new Color(30, 30, 30, (int) Math.round((opacity / 100.0) * DEFAULT_HEADER_ALPHA))); // Slightly darker semi-transparent background
		graphics.fillRect(0, 0, currentSize.width, LINE_HEIGHT);

		final boolean showAvatars = config.showOverlayAvatar();
		final Rectangle overlayBounds = this.getBounds();
		final int avatarSize = showAvatars ? LINE_HEIGHT : 0;

		// Position the settings icon in the header
		if (settingsIcon != null)
		{
			int settingsIconX = currentSize.width - settingsIcon.getWidth() - 2; // 2px padding from the right
			int settingsIconY = (LINE_HEIGHT - settingsIcon.getHeight()) / 2; // Vertically center the icon
			graphics.drawImage(settingsIcon, settingsIconX, settingsIconY, null);

			// Calculate global coordinates by adding overlay's top-left corner
			int globalSettingsIconX = overlayBounds.x + settingsIconX;
			int globalSettingsIconY = overlayBounds.y + settingsIconY;

			Rectangle settingsIconBounds = new Rectangle(globalSettingsIconX, globalSettingsIconY, settingsIcon.getWidth(), settingsIcon.getHeight());

			final Point mousePosition = client.getMouseCanvasPosition();

			if (settingsIconBounds.contains(mousePosition.getX(), mousePosition.getY()))
			{
				tooltipManager.add(new Tooltip("Right click for Combat Logger overlay settings"));
			}
		}
		String baseLabel = "Damage: ";
		String fightName = selectedFight.getFightName();
		String fightLength = " (" + Fight.formatTime(selectedFight.getFightLengthTicks()) + ")";

		int availableHeaderWidth = currentSize.width - (settingsIcon != null ? settingsIcon.getWidth() + 6 : 6);
		int labelWidth = metrics.stringWidth(baseLabel);
		int nameWidth = metrics.stringWidth(fightName);
		int lengthWidth = metrics.stringWidth(fightLength);
		int totalWidth = labelWidth + nameWidth + lengthWidth;

		String displayLabel = baseLabel;
		String displayName = fightName;
		String displayLength = fightLength;

		// header text overflows the bounding box
		if (totalWidth > availableHeaderWidth)
		{
			// first truncate encounter name
			int maxNameWidth = availableHeaderWidth - labelWidth - lengthWidth;
			if (maxNameWidth < 0) maxNameWidth = 0;
			if (nameWidth > maxNameWidth)
			{
				displayName = truncateText(fightName, metrics, maxNameWidth);
				if(displayName.equals("...")) displayName = "";
				nameWidth = metrics.stringWidth(displayName);
				totalWidth = labelWidth + nameWidth + lengthWidth;
			}

			// still overflows, truncate base label
			if (totalWidth > availableHeaderWidth)
			{
				int maxLabelWidth = availableHeaderWidth - nameWidth - lengthWidth;
				if (maxLabelWidth < 0) maxLabelWidth = 0;
				if (labelWidth > maxLabelWidth)
				{
					displayLabel = truncateText(baseLabel, metrics, maxLabelWidth);
					if(displayLabel.equals("...")) displayLabel = "";
					labelWidth = metrics.stringWidth(displayLabel);
					totalWidth = labelWidth + nameWidth + lengthWidth;
				}
			}

			// STILL overflows, truncate fight length
			if (totalWidth > availableHeaderWidth)
			{
				int maxLengthWidth = availableHeaderWidth - labelWidth - nameWidth;
				if (maxLengthWidth < 0) maxLengthWidth = 0;
				if (lengthWidth > maxLengthWidth)
				{
					displayLength = truncateText(fightLength, metrics, maxLengthWidth);
				}
			}
		}

		String header = displayLabel + displayName + displayLength;

		// Position the header text vertically centered
		int headerTextY = (LINE_HEIGHT - metrics.getHeight()) / 2 + metrics.getAscent();

		// Draw the header text
		graphics.setColor(new Color(255, 255, 255, (int) Math.round((opacity / 100.0) * 255)));
		graphics.drawString(header, 3, headerTextY + 1);

		int yPosition = LINE_HEIGHT;
		int maxRows = Math.min(((int) Math.floor((double) currentSize.height - LINE_HEIGHT) / LINE_HEIGHT), playerStats.size());
		int maxDamage = playerStats.stream().mapToInt(PlayerStats::getDamage).max().orElse(1);

		// Render each damage bar
		for (var i = 0; i < maxRows; i++)
		{
			var stats = playerStats.get(i);
			String playerName = stats.getName();
			int damage = stats.getDamage();

			if (damage == 0)
			{
				//skip players with 0 damage
				continue;
			}

			double percentDamage = stats.getPercentDamage(); // Already handled to avoid NaN
			CombatLoggerConfig.SecondaryMetric secondaryMetric = this.config.secondaryMetric();

			// Calculate bar length proportionally
			int availableBarWidth = showAvatars ? (currentSize.width - avatarSize) : currentSize.width;
			int barLength = (int) ((double) damage / maxDamage * availableBarWidth);


			BufferedImage avatarImage = null;
			if (showAvatars)
			{
				avatarImage = avatarCache.get(playerName);

				if (avatarImage == null)
				{
					PartyMember partyMember = partyService.getMemberByDisplayName(playerName);
					BufferedImage cachedAvatar = partyMember != null ? partyMember.getAvatar() : null;

					if (cachedAvatar != null)
					{
						avatarImage = ImageUtil.resizeImage(cachedAvatar, avatarSize, avatarSize);
						avatarCache.put(playerName, avatarImage);
					}
					else
					{
						avatarImage = ImageUtil.resizeImage(defaultAvatar, avatarSize, avatarSize);
					}
				}
			}

			// Draw avatar or skip if avatars are hidden
			int avatarX = 0;
			int avatarY = yPosition; // Align avatar with the top of the bar

			if (showAvatars && avatarImage != null)
			{
				graphics.drawImage(avatarImage, avatarX, avatarY, null);
			}

			// Adjust positions based on avatar visibility
			int barX = showAvatars ? avatarSize : 0; // Bar starts after avatar if shown
			int textX = showAvatars ? (barX + 5) : 5; // Text starts after avatar or with padding

			// Draw bar line
			graphics.setColor(new Color(70, 70, 70, (int) Math.round((opacity / 100.0) * DEFAULT_BACKGROUND_ALPHA)));
			graphics.fillRect(barX, yPosition, availableBarWidth, LINE_HEIGHT);

			// Get the player's color from FightManager
			Color playerColor = fightManager.getPlayerColor(playerName);

			// Draw Damage bar
			Color semiTransparentPlayerColor = new Color(
					playerColor.getRed(),
					playerColor.getGreen(),
					playerColor.getBlue(),
					(int) Math.round((opacity / 100.0) * DEFAULT_BAR_ALPHA)
			);
			graphics.setColor(semiTransparentPlayerColor);
			graphics.fillRect(barX, yPosition, barLength, LINE_HEIGHT);

			// Metric
			String secondaryText = "";
			if (secondaryMetric == CombatLoggerConfig.SecondaryMetric.DPS)
			{
				secondaryText = String.format("(%.2f, %.1f%%)", stats.getDps(), percentDamage);
			}
			else if (secondaryMetric == CombatLoggerConfig.SecondaryMetric.TICKS)
			{
				secondaryText = String.format("(%d, %.1f%%)", stats.getTicks(), percentDamage);
			}
			int rowY = yPosition + ((LINE_HEIGHT - metrics.getHeight()) / 2) + metrics.getAscent();

			Color fontColor = fightManager.getContrastingColor(playerColor);
			graphics.setColor(new Color(
					fontColor.getRed(),
					fontColor.getGreen(),
					fontColor.getBlue(),
					(int) Math.round((opacity / 100.0) * 255)
			));
			String damageText = String.format("%d %s", damage, secondaryText);
			int damageTextXPosition = currentSize.width - metrics.stringWidth(damageText) - 2; // 2 pixels padding from the right edge
			graphics.drawString(damageText, damageTextXPosition, rowY + 1);

			int availableNameWidth = damageTextXPosition - textX - 5; // 5 pixels padding between name and damage
			if (availableNameWidth > 0)
			{
				String truncatedNameText = truncateText(playerName, metrics, availableNameWidth);
				graphics.drawString(truncatedNameText, textX, rowY + 1);
			}

			yPosition += LINE_HEIGHT;
		}
		return new Dimension(currentSize.width, currentSize.height);
	}

	private BufferedImage loadImage(String path)
	{

		return ImageUtil.loadImageResource(CombatLoggerPlugin.class, path);
	}

	/**
	 * Truncates the given text and appends an ellipsis if it exceeds the maxWidth.
	 *
	 * @param text     The original text to potentially truncate.
	 * @param fm       The FontMetrics object for measuring text width.
	 * @param maxWidth The maximum allowed width for the text.
	 * @return The original or truncated text with an ellipsis.
	 */
	private String truncateText(String text, FontMetrics fm, int maxWidth)
	{
		if (fm.stringWidth(text) <= maxWidth)
		{
			return text;
		}

		String ellipsis = "...";
		int ellipsisWidth = fm.stringWidth(ellipsis);
		int availableWidth = maxWidth - ellipsisWidth;

		if (availableWidth <= 0)
		{
			return ellipsis;
		}

		int len = text.length();
		while (len > 0 && fm.stringWidth(text.substring(0, len)) > availableWidth)
		{
			len--;
		}

		return text.substring(0, len) + ellipsis;
	}

	public void clearAvatarCache()
	{
		avatarCache.clear();
	}

}
package com.combatlogger.panel;

import com.combatlogger.CombatLoggerConfig;
import com.combatlogger.FightManager;
import com.combatlogger.model.PlayerStats;

import javax.swing.*;
import java.awt.*;
import java.util.ArrayList;
import java.util.List;

public abstract class DamageBarsPanel extends JPanel
{
	private final FightManager fightManager;
	private final CombatLoggerConfig config;
	protected List<DamageBar> damageBars = new ArrayList<>();
	protected CombatLoggerPanel parentPanel;

	protected JPanel topPanel;


	public DamageBarsPanel(CombatLoggerPanel parentPanel, CombatLoggerConfig config, FightManager fightManager)
	{
		this.parentPanel = parentPanel;
		this.config = config;
		this.fightManager = fightManager;

		setLayout(new BoxLayout(this, BoxLayout.Y_AXIS));

		topPanel = new JPanel(new FlowLayout(FlowLayout.LEFT, 2, 0));
		topPanel.setPreferredSize(new Dimension(1000, 25));
		topPanel.setMaximumSize(new Dimension(1000, 25));
		add(topPanel);
	}

	protected DamageBar createDamageBar(PlayerStats stats, int maximumValue)
	{
		// Assign color to the DamageBar
		if (stats.getColor() == null)
		{
			stats.setColor(fightManager.getPlayerColor(stats.getName()));
		}
		DamageBar damageBar = new DamageBar(stats.getColor(), fightManager.getContrastingColor(stats.getColor()));
		damageBar.setMaximumValue(maximumValue);
		damageBar.setValue(stats.getDamage());
		damageBar.setLeftLabel(stats.getName());

		if (this.config.secondaryMetric() == CombatLoggerConfig.SecondaryMetric.DPS)
		{
			damageBar.setRightLabel(String.format("%d (%.2f, %.2f%%)", stats.getDamage(), stats.getDps(), stats.getPercentDamage()));
		}
		else
		{
			damageBar.setRightLabel(String.format("%d (%s, %.2f%%)", stats.getDamage(), stats.getTicks(), stats.getPercentDamage()));
		}
		return damageBar;
	}

	protected void addDamageBars(List<PlayerStats> damageBreakdown, int maximumValue)
	{
		damageBars.forEach(this::remove);
		damageBars.clear();

		for (PlayerStats stats : damageBreakdown)
		{
			if (stats.getDamage() > 0)
			{
				// Assign a color if not already set
				if (stats.getColor() == null)
				{
					stats.setColor(fightManager.getPlayerColor(stats.getName()));
				}

				DamageBar newBar = createDamageBar(stats, maximumValue);
				damageBars.add(newBar);
				add(newBar);
			}
		}

		revalidate();
		repaint();
	}
}

package com.combatlogger.panel;

import com.combatlogger.CombatLoggerConfig;
import com.combatlogger.CombatLoggerPlugin;
import com.combatlogger.FightManager;
import com.combatlogger.model.PlayerStats;
import net.runelite.client.util.ImageUtil;

import javax.swing.*;
import java.awt.*;
import java.awt.image.BufferedImage;
import java.util.List;

public class DamageDrillDownPanel extends DamageBarsPanel
{
	private final FightManager fightManager;
	private final JLabel breakdownLabel = new JLabel();
	private static final ImageIcon BACK_ICON;

	static
	{
		final BufferedImage backIcon = ImageUtil.resizeImage(ImageUtil.loadImageResource(CombatLoggerPlugin.class, "/arrow_back.png"), 16, 16);
		BACK_ICON = new ImageIcon(backIcon);
	}


	public DamageDrillDownPanel(CombatLoggerPanel parentPanel, CombatLoggerConfig config, FightManager fightManager)
	{
		super(parentPanel, config, fightManager);
		this.fightManager = fightManager;

		JButton backButton = parentPanel.createButton(BACK_ICON, "Back to Overview", parentPanel::showOverviewPanel);
		backButton.setPreferredSize(new Dimension(22, 25));
		breakdownLabel.setHorizontalTextPosition(JLabel.LEFT);

		topPanel.add(backButton);
		topPanel.add(breakdownLabel);
	}

	public void setPlayerStats(String playerName, List<PlayerStats> damageBreakdown)
	{
		breakdownLabel.setText("Breakdown: " + playerName);
		int totalDamage = damageBreakdown.stream().mapToInt(PlayerStats::getDamage).sum();

		addDamageBars(damageBreakdown, totalDamage);
	}
}

package com.combatlogger.panel;

import java.awt.Color;
import java.awt.Dimension;
import java.awt.Graphics;
import java.awt.GridBagConstraints;
import java.awt.GridBagLayout;
import java.awt.event.MouseListener;
import javax.swing.*;
import javax.swing.border.EmptyBorder;
import javax.swing.border.LineBorder;

import lombok.Getter;
import net.runelite.client.ui.FontManager;
import net.runelite.client.ui.components.shadowlabel.JShadowedLabel;

/**
 * Based on ProgressBar from net.runelite.client.ui.components.ProgressBar
 * Except taller, bigger font, no center label, no dimming, no positions
 */

public class DamageBar extends JPanel
{
	private int maximumValue;
	private int value;

	@Getter
	private final JLabel leftLabel = new JShadowedLabel();
	private final JLabel rightLabel = new JShadowedLabel();

	public DamageBar(Color barForeground, Color labelForeground)
	{
		setLayout(new GridBagLayout());
		GridBagConstraints gbc = new GridBagConstraints();

		setBackground(new Color(61, 56, 49));
		setForeground(barForeground);

		setPreferredSize(new Dimension(100, 25));

		// The box layout will try to fit the parent container
		// So we need to set the maximum height to prevent it from growing
		setMaximumSize(new Dimension(1000, 25));

		leftLabel.setFont(FontManager.getRunescapeFont());
		leftLabel.setForeground(labelForeground);
		leftLabel.setBorder(new EmptyBorder(2, 5, 0, 0));
		gbc.gridx = 0;
		gbc.gridy = 0;
		gbc.weightx = 0.4;
		gbc.fill = GridBagConstraints.HORIZONTAL;
		add(leftLabel, gbc);

		rightLabel.setFont(FontManager.getRunescapeFont());
		rightLabel.setForeground(labelForeground);
		rightLabel.setHorizontalAlignment(SwingConstants.RIGHT);
		rightLabel.setBorder(new EmptyBorder(2, 0, 0, 5));
		gbc.gridx = 2;
		gbc.gridy = 0;
		gbc.weightx = 0.4;
		gbc.fill = GridBagConstraints.HORIZONTAL;
		add(rightLabel, gbc);

		setBorder(new LineBorder(new Color(20, 20, 20), 1));
	}

	@Override
	public void paint(Graphics g)
	{
		int percentage = getPercentage();
		int topWidth = (int) (getSize().width * (percentage / 100f));

		super.paint(g);
		g.setColor(getForeground());
		g.fillRect(0, 1, topWidth, 23); // 1px padding on top and bottom for border

		super.paintComponents(g);
	}

	public void setLeftLabel(String txt)
	{
		leftLabel.setText(txt);
	}

	public void setRightLabel(String txt)
	{
		rightLabel.setText(txt);
	}

	public int getPercentage()
	{
		if (maximumValue == 0)
		{
			return 0;
		}

		return (value * 100) / maximumValue;
	}

	public void setMaximumValue(int maximumValue)
	{
		this.maximumValue = maximumValue;
		repaint();
	}

	public void setValue(int value)
	{
		this.value = value;
		repaint();
	}

	public void addDrillDownMouseListener(MouseListener mouseListener)
	{
		this.addMouseListener(mouseListener);
	}
}

package com.combatlogger.panel;

import com.combatlogger.CombatLoggerConfig;
import com.combatlogger.model.PlayerStats;
import com.combatlogger.FightManager;

import javax.swing.*;
import javax.swing.border.LineBorder;
import java.awt.*;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.util.List;

public class DamageOverviewPanel extends DamageBarsPanel
{
	private final FightManager fightManager;

	public DamageOverviewPanel(CombatLoggerPanel parentPanel, CombatLoggerConfig config, FightManager fightManager)
	{
		super(parentPanel, config, fightManager);
		this.fightManager = fightManager;
		topPanel.setLayout(new BorderLayout());
		JLabel textLabel = new JLabel("Overview");
		textLabel.setBorder(BorderFactory.createEmptyBorder(0, 5, 0, 0));
		topPanel.add(textLabel);
		topPanel.setVisible(false);
	}

	public void setPlayerStats(List<PlayerStats> playerStats)
	{
		// We use the highest player's damage instead of the sum, because the top player should have a full bar
		int highestDamage = playerStats.isEmpty() ? 0 : playerStats.get(0).getDamage();

		addDamageBars(playerStats, highestDamage);
		for (DamageBar damageBar : damageBars)
		{
			attachDrillDownAction(damageBar, damageBar.getLeftLabel().getText());
		}

		topPanel.setVisible(!damageBars.isEmpty());
	}

	private void attachDrillDownAction(DamageBar damageBar, String playerName)
	{
		damageBar.addDrillDownMouseListener(new MouseAdapter()
		{
			@Override
			public void mousePressed(MouseEvent e)
			{
				if (SwingUtilities.isLeftMouseButton(e))
				{
					parentPanel.showDrillDownPanel(parentPanel.getSelectedFight(), playerName);
				}
			}
		});

		damageBar.addMouseListener(new MouseAdapter()
		{
			@Override
			public void mouseEntered(MouseEvent e)
			{
				damageBar.setBorder(new LineBorder(Color.WHITE, 1));
			}

			@Override
			public void mouseExited(MouseEvent e)
			{
				damageBar.setBorder(new LineBorder(new Color(20, 20, 20), 1)); // Reset to default border
			}
		});
	}
}

package com.combatlogger.panel;

import com.combatlogger.CombatLoggerConfig;
import com.combatlogger.CombatLoggerPlugin;
import com.combatlogger.FightManager;
import com.combatlogger.model.Fight;
import com.combatlogger.model.PlayerStats;
import com.combatlogger.util.BoundedQueue;
import net.runelite.client.util.ImageUtil;
import net.runelite.client.util.LinkBrowser;
import net.runelite.client.util.SwingUtil;
import lombok.Getter;
import net.runelite.client.ui.PluginPanel;

import javax.inject.Inject;
import javax.swing.*;
import javax.swing.border.EmptyBorder;
import java.awt.*;
import java.util.ArrayList;
import java.util.List;

import static com.combatlogger.CombatLoggerPlugin.DIRECTORY;

public class CombatLoggerPanel extends PluginPanel
{
	private final FightManager fightManager;
	private final CardLayout cardLayout;
	private final JLabel currentFightLengthLabel = new JLabel("00:00");
	private final JPanel damageMeterPanel;
	private final DamageOverviewPanel damageOverviewPanel;
	private final DamageDrillDownPanel drillDownPanel;

	private final JComboBox<Fight> fightsComboBox = new JComboBox<>();

	@Getter
	private Fight selectedFight = null;

	private static final ImageIcon DISCORD_ICON;
	private static final ImageIcon RUNELOGS_ICON;
	private static final ImageIcon FOLDER_ICON;
	private static final ImageIcon STOP_ICON;
	private static final ImageIcon CLOSE_ICON;

	static
	{
		DISCORD_ICON = new ImageIcon(ImageUtil.loadImageResource(CombatLoggerPlugin.class, "/discord.png"));
		RUNELOGS_ICON = new ImageIcon(ImageUtil.loadImageResource(CombatLoggerPlugin.class, "/runelogs.png"));
		FOLDER_ICON = new ImageIcon(ImageUtil.loadImageResource(CombatLoggerPlugin.class, "/folder.png"));
		STOP_ICON = new ImageIcon(ImageUtil.loadImageResource(CombatLoggerPlugin.class, "/stop.png"));
		CLOSE_ICON = new ImageIcon(ImageUtil.loadImageResource(CombatLoggerPlugin.class, "/close.png"));
	}

	@Inject
	public CombatLoggerPanel(CombatLoggerConfig config, FightManager fightManager)
	{
		this.fightManager = fightManager;

		final JPanel topPanel = new JPanel();
		topPanel.setLayout(new BorderLayout());
		topPanel.setBorder(new EmptyBorder(0, 0, 20, 0));
		topPanel.add(new JLabel("Combat Logger"), BorderLayout.WEST);

		final JPanel iconPanel = new JPanel(new FlowLayout(FlowLayout.LEFT, 0, 0));

		iconPanel.add(createButton(
				RUNELOGS_ICON,
				"Open Runelogs - upload and analyze your combat logs",
				() -> LinkBrowser.browse("https://runelogs.com")
		));
		iconPanel.add(Box.createHorizontalStrut(10));
		iconPanel.add(createButton(
				DISCORD_ICON,
				"Get Combat Logger / Runelogs help or make suggestions on Discord",
				() -> LinkBrowser.browse("https://discord.gg/ZydwX7AJEd")
		));
		iconPanel.add(Box.createHorizontalStrut(10));
		iconPanel.add(createButton(
				FOLDER_ICON,
				"Open combat log folder",
				() -> LinkBrowser.open(DIRECTORY.toString())
		));

		topPanel.add(iconPanel, BorderLayout.EAST);
		add(topPanel, BorderLayout.NORTH);

		final JPanel damageMeterTextPanel = new JPanel(new BorderLayout());
		damageMeterTextPanel.setBorder(new EmptyBorder(0, 0, 10, 0));
		damageMeterTextPanel.add(new JLabel("Damage Meter"), BorderLayout.WEST);
		damageMeterTextPanel.add(currentFightLengthLabel, BorderLayout.EAST);
		add(damageMeterTextPanel, BorderLayout.NORTH);

		cardLayout = new CardLayout();
		damageMeterPanel = new JPanel(cardLayout);

		updateFightsComboBox(fightManager.getFights());

		JButton clearFightsButton = createButton(CLOSE_ICON, "Clear all fights", () ->
		{
			if (isConfirmed("Are you sure you want to clear all fights?", "Clear all fights"))
			{
				fightManager.clearFights();
				updateFightsComboBox(fightManager.getFights());
				updateOverviewPanel(new ArrayList<>());
				showOverviewPanel();
			}
		});
		JButton stopFightButton = createButton(STOP_ICON, "End the current fight", () ->
		{
			if (isConfirmed("Are you sure you want to end the current fight?", "End fight"))
			{
				fightManager.endCurrentFight();
			}
		});
		JPanel fightsPanel = new JPanel(new BorderLayout());
		fightsPanel.add(fightsComboBox, BorderLayout.CENTER);

		JPanel buttonPanel = new JPanel(new BorderLayout());
		buttonPanel.add(stopFightButton, BorderLayout.WEST);
		buttonPanel.add(clearFightsButton, BorderLayout.EAST);
		fightsPanel.add(buttonPanel, BorderLayout.EAST);

		add(fightsPanel, BorderLayout.NORTH);

		fightsComboBox.setRenderer(new PlaceholderComboBoxRenderer("Start a fight..."));
		fightsComboBox.addActionListener(e -> {
			selectedFight = (Fight) fightsComboBox.getSelectedItem();
			fightManager.setSelectedFight(selectedFight);
			if (selectedFight != null)
			{
				List<PlayerStats> playerStats = fightManager.getPlayerDamageForFight(selectedFight);
				updateOverviewPanel(playerStats);
			}
		});

		damageOverviewPanel = new DamageOverviewPanel(this, config, fightManager);
		drillDownPanel = new DamageDrillDownPanel(this, config, fightManager);

		damageMeterPanel.add(damageOverviewPanel, "overview");
		damageMeterPanel.add(drillDownPanel, "drilldown");

		showOverviewPanel();
		add(damageMeterPanel);
	}

	public void showOverviewPanel()
	{
		cardLayout.show(damageMeterPanel, "overview");
	}

	public void showDrillDownPanel(Fight fight, String playerName)
	{
		List<PlayerStats> playerTotalDamage = fightManager.getBreakdownDamage(fight, playerName);

		drillDownPanel.setPlayerStats(playerName, playerTotalDamage);
		cardLayout.show(damageMeterPanel, "drilldown");
	}

	public void updateOverviewPanel(List<PlayerStats> playerStats)
	{
		damageOverviewPanel.setPlayerStats(playerStats);
	}

	public void updateCurrentFightLength(String fightLength)
	{
		currentFightLengthLabel.setText(fightLength);
	}

	public void updateFightsComboBox(BoundedQueue<Fight> fights)
	{
		List<Fight> updatedFights = new ArrayList<>();
		// Reverse order so the newest fights are first
		fights.descendingIterator().forEachRemaining(updatedFights::add);

		List<Fight> existingFights = new ArrayList<>();
		for (int i = 0; i < fightsComboBox.getItemCount(); i++)
		{
			existingFights.add(fightsComboBox.getItemAt(i));
		}

		if (!existingFights.equals(updatedFights))
		{
			fightsComboBox.removeAllItems();
			updatedFights.forEach(fightsComboBox::addItem);
		}

		// Set the selected item in the combo box
		Fight selectedFight = fightManager.getSelectedFight();
		if (selectedFight != null)
		{
			fightsComboBox.setSelectedItem(selectedFight);
		}
	}

	public JButton createButton(ImageIcon icon, String toolTipText, Runnable onClick)
	{
		JButton button = new JButton(icon);
		button.setPreferredSize(new Dimension(24, 24));
		SwingUtil.removeButtonDecorations(button);
		button.setToolTipText(toolTipText);
		button.addActionListener(e -> onClick.run());

		return button;
	}

	private boolean isConfirmed(final String message, final String title)
	{
		int confirm = JOptionPane.showConfirmDialog(this,
				message, title, JOptionPane.OK_CANCEL_OPTION);

		return confirm == JOptionPane.YES_OPTION;
	}

	/**
	 * Update the panel with the latest data
	 */
	public void updatePanel()
	{
		selectedFight = fightManager.getSelectedFight();
		if (selectedFight != null)
		{
			List<PlayerStats> playerStats = fightManager.getPlayerDamageForFight(selectedFight);
			updateOverviewPanel(playerStats);
			updateCurrentFightLength(Fight.formatTime(selectedFight.getFightLengthTicks()));
		}
		else
		{
			updateCurrentFightLength("00:00");
		}

		updateFightsComboBox(fightManager.getFights());
	}
}

class PlaceholderComboBoxRenderer extends DefaultListCellRenderer
{
	private final String placeholder;

	public PlaceholderComboBoxRenderer(String placeholder)
	{
		this.placeholder = placeholder;
	}

	@Override
	public Component getListCellRendererComponent(JList<?> list, Object value, int index, boolean isSelected, boolean cellHasFocus)
	{
		if (list.getModel().getSize() == 0)
		{
			value = placeholder;
		}
		return super.getListCellRendererComponent(list, value, index, isSelected, cellHasFocus);
	}
}

package com.combatlogger;

import net.runelite.client.RuneLite;
import net.runelite.client.externalplugins.ExternalPluginManager;

public class CombatLoggerPluginTest
{
	public static void main(String[] args) throws Exception
	{
		ExternalPluginManager.loadBuiltin(CombatLoggerPlugin.class);
		RuneLite.main(args);
	}
}
