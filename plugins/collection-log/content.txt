package com.evansloan.collectionlog;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@AllArgsConstructor
@NoArgsConstructor
public class UserSettings
{
	private AccountType displayRank = AccountType.ALL;
	private boolean showQuantity = true;
}

package com.evansloan.collectionlog;

import java.awt.Color;
import net.runelite.client.config.Alpha;
import net.runelite.client.config.Config;
import net.runelite.client.config.ConfigGroup;
import net.runelite.client.config.ConfigItem;
import net.runelite.client.config.ConfigSection;

@ConfigGroup("collectionlog")
public interface CollectionLogConfig extends Config
{
	String PLUGIN_VERSION = "3.1.4";

	Color DEFAULT_GREEN = new Color(13, 193, 13);
	Color DEFAULT_ORANGE = new Color(255, 152, 31);
	Color DEFAULT_RED = new Color(204, 44, 44);

	@ConfigItem(
		keyName = "show_collection_log_panel",
		name = "Show the collection log side panel",
		description = "Show the collection log side panel",
		position = 1
	)
	default boolean showCollectionLogSidePanel()
	{
		return true;
	}

	@ConfigSection(
		name = "Appearance",
		description = "Modify the appearance of the collection log",
		position = 2
	)
	String appearanceSection = "appearance";

	@ConfigItem(
		keyName = "display_unique_items",
		name = "Display unique items",
		description = "Display unique obtained collection log items",
		position = 1,
		section = appearanceSection
	)
	default boolean displayUniqueItems()
	{
		return true;
	}

	@ConfigItem(
		keyName = "display_total_items",
		name = "Display total items",
		description = "Display total obtained collection log items",
		position = 2,
		section = appearanceSection
	)
	default boolean displayTotalItems()
	{
		return false;
	}

	@ConfigItem(
		keyName = "display_as_percentage",
		name = "Display item counts as percentage",
		description = "Display collection log progress as a percentage",
		position = 3,
		section = appearanceSection
	)
	default boolean displayAsPercentage()
	{
		return false;
	}

	@ConfigItem(
		keyName = "highlight_incomplete_pages",
		name = "Highlight incomplete pages",
		description = "Highlight incomplete page titles",
		position = 4,
		section = appearanceSection
	)
	default boolean highlightIncompletePages()
	{
		return false;
	}

	@Alpha
	@ConfigItem(
		keyName = "highlight_color",
		name = "Completed page highlight color",
		description = "Sets the highlight color of completed pages",
		position = 5,
		section = appearanceSection
	)
	default Color highlightColor()
	{
		return DEFAULT_GREEN;
	}

	@Alpha
	@ConfigItem(
		keyName = "in_progress_highlight_color",
		name = "In progress page highlight color",
		description = "Sets the highlight color of page titles with at least one item obtained",
		position = 6,
		section = appearanceSection
	)
	default Color inProgressHighlightColor()
	{
		return DEFAULT_ORANGE;
	}

	@Alpha
	@ConfigItem(
		keyName = "empty_highlight_color",
		name = "Empty page highlight color",
		description = "Sets the highlight color of page titles with no items obtained",
		position = 7,
		section = appearanceSection
	)
	default Color emptyHighlightColor()
	{
		return DEFAULT_RED;
	}

	@ConfigItem(
		keyName = "show_quantity_for_all_obtained_items",
		name = "Show quantity for all obtained items",
		description = "Show the quantity of items where only one has been obtained",
		position = 8,
		section = appearanceSection
	)
	default boolean showQuantityForAllObtainedItems()
	{
		return false;
	}

	@ConfigSection(
		name = "Exporting",
		description = "Config options for exporting collection log data",
		position = 4
	)
	String exportingSection = "exporting";

	@ConfigItem(
		keyName = "upload_collection_log",
		name = "Allow collectionlog.net connections",
		description = "Allows collection log data to upload on log out and the chat command to pull data",
		position = 1,
		section = exportingSection,
		warning = "Enabling this option submits your IP address and account hash to a 3rd party website not controlled or verified by the RuneLite Developers."
	)
	default boolean allowApiConnections()
	{
		return false;
	}

	@ConfigItem(
		keyName = "export_chat_message",
		name = "Chat message on export",
		description = "Show exported file location in chat box on collection log export",
		position = 2,
		section = exportingSection
	)
	default boolean sendExportChatMessage()
	{
		return true;
	}
}

package com.evansloan.collectionlog;

import com.google.gson.JsonObject;
import com.google.gson.JsonParser;
import java.io.IOException;
import javax.inject.Inject;
import javax.inject.Singleton;
import lombok.extern.slf4j.Slf4j;
import okhttp3.Callback;
import okhttp3.HttpUrl;
import okhttp3.MediaType;
import okhttp3.OkHttpClient;
import okhttp3.Request;
import okhttp3.RequestBody;
import okhttp3.Response;
import okhttp3.ResponseBody;

@Slf4j
@Singleton
public class CollectionLogApiClient
{
	private static final String COLLECTION_LOG_API_BASE = "api.collectionlog.net";
	private static final String COLLECTION_LOG_API_SCHEME = "https";
	private static final String COLLECTION_LOG_USER_PATH = "user";
	private static final String COLLECTION_LOG_LOG_PATH = "collectionlog";
	private static final String COLLECTION_LOG_JSON_KEY = "collectionLog";
	private static final String COLLECTION_LOG_USER_AGENT = "Runelite collection-log/" + CollectionLogConfig.PLUGIN_VERSION;
	private static final MediaType COLLECTION_LOG_MEDIA_TYPE = MediaType.parse("application/json; charset=utf-8");;

	@Inject
	private CollectionLogConfig config;

	@Inject
	private OkHttpClient okHttpClient;

	public void updateUser(String username, String accountType, String accountHash, boolean isFemale, JsonObject userSettings, Callback callback)
	{
		HttpUrl url = new HttpUrl.Builder()
			.scheme(COLLECTION_LOG_API_SCHEME)
			.host(COLLECTION_LOG_API_BASE)
			.addPathSegment(COLLECTION_LOG_USER_PATH)
			.build();

		JsonObject jsonObject = new JsonObject();
		jsonObject.addProperty("username", username);
		jsonObject.addProperty("accountType", accountType);
		jsonObject.addProperty("accountHash", accountHash);
		jsonObject.addProperty("isFemale", isFemale);
		jsonObject.add("userSettings", userSettings);

		postRequest(url, jsonObject, callback);
	}

	public void updateCollectionLog(JsonObject collectionLogData, String accountHash, Callback callback)
	{
		HttpUrl url = new HttpUrl.Builder()
			.scheme(COLLECTION_LOG_API_SCHEME)
			.host(COLLECTION_LOG_API_BASE)
			.addPathSegment(COLLECTION_LOG_LOG_PATH)
			.addPathSegment(accountHash)
			.build();

		JsonObject logData = new JsonObject();
		logData.add(COLLECTION_LOG_JSON_KEY, collectionLogData);

		putRequest(url, logData, callback);
	}

	public void getCollectionLog(String username, Callback callback) throws IOException
	{
		HttpUrl url = new HttpUrl.Builder()
			.scheme(COLLECTION_LOG_API_SCHEME)
			.host(COLLECTION_LOG_API_BASE)
			.addPathSegment(COLLECTION_LOG_LOG_PATH)
			.addPathSegment(COLLECTION_LOG_USER_PATH)
			.addEncodedPathSegment(username)
			.build();

		getRequest(url, callback);
	}

	public void deleteCollectionLog(String username, String accountHash, Callback callback)
	{
		HttpUrl url = new HttpUrl.Builder()
			.scheme(COLLECTION_LOG_API_SCHEME)
			.host(COLLECTION_LOG_API_BASE)
			.addPathSegment(COLLECTION_LOG_LOG_PATH)
			.addPathSegment("delete")
			.build();

		JsonObject deleteBody = new JsonObject();
		deleteBody.addProperty("username", username);
		deleteBody.addProperty("accountHash", accountHash);

		deleteRequest(url, deleteBody, callback);
	}

	private Request.Builder createRequestBuilder(HttpUrl url)
	{
		return new Request.Builder()
			.header("User-Agent", COLLECTION_LOG_USER_AGENT)
			.url(url);
	}

	private void getRequest(HttpUrl url, Callback callback)
	{
		Request request = createRequestBuilder(url)
			.get()
			.build();
		apiRequest(request, callback);
	}

	private void postRequest(HttpUrl url, JsonObject postData, Callback callback)
	{
		RequestBody body = RequestBody.create(COLLECTION_LOG_MEDIA_TYPE, postData.toString());
		Request request = createRequestBuilder(url)
			.post(body)
			.build();
		apiRequest(request, callback);
	}

	private void putRequest(HttpUrl url, JsonObject putData, Callback callback)
	{
		RequestBody body = RequestBody.create(COLLECTION_LOG_MEDIA_TYPE, putData.toString());
		Request request = createRequestBuilder(url)
			.put(body)
			.build();
		apiRequest(request, callback);
	}

	private void deleteRequest(HttpUrl url, JsonObject deleteData, Callback callback)
	{
		RequestBody body = RequestBody.create(COLLECTION_LOG_MEDIA_TYPE, deleteData.toString());
		Request request = createRequestBuilder(url)
			.delete(body)
			.build();
		apiRequest(request, callback);
	}

	private void apiRequest(Request request, Callback callback)
	{
		if (!config.allowApiConnections())
		{
			return;
		}

		okHttpClient.newCall(request).enqueue(callback);
	}

	public JsonObject processResponse(Response response) throws IOException
	{
		if (!response.isSuccessful())
		{
			return null;
		}

		ResponseBody resBody = response.body();
		if (resBody == null)
		{
			return null;
		}
		return new JsonParser().parse(resBody.string()).getAsJsonObject();
	}
}

package com.evansloan.collectionlog.util;

import com.evansloan.collectionlog.CollectionLog;
import com.evansloan.collectionlog.CollectionLogPage;
import com.evansloan.collectionlog.CollectionLogTab;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonSerializer;
import com.google.gson.JsonSerializationContext;
import java.lang.reflect.Type;
import java.util.Map;

public class CollectionLogSerializer implements JsonSerializer<CollectionLog>
{
	private static final String COLLECTION_LOG_ITEMS_KEY = "items";
	private static final String COLLECTION_LOG_KILL_COUNTS_KEY = "killCounts";
	private static final String COLLECTION_LOG_TABS_KEY = "tabs";
	private static final String COLLECTION_LOG_TOTAL_OBTAINED_KEY = "totalObtained";
	private static final String COLLECTION_LOG_TOTAL_ITEMS_KEY = "totalItems";
	private static final String COLLECTION_LOG_UNIQUE_OBTAINED_KEY = "uniqueObtained";
	private static final String COLLECTION_LOG_UNIQUE_ITEMS_KEY = "uniqueItems";
	private static final String COLLECTION_LOG_IS_UPDATED_KEY = "isUpdated";

	@Override
	public JsonElement serialize(CollectionLog collectionLog, Type type, JsonSerializationContext context)
	{
		JsonObject collectionLogJson = new JsonObject();
		collectionLogJson.addProperty(COLLECTION_LOG_TOTAL_OBTAINED_KEY, collectionLog.getTotalObtained());
		collectionLogJson.addProperty(COLLECTION_LOG_TOTAL_ITEMS_KEY, collectionLog.getTotalItems());
		collectionLogJson.addProperty(COLLECTION_LOG_UNIQUE_OBTAINED_KEY, collectionLog.getUniqueObtained());
		collectionLogJson.addProperty(COLLECTION_LOG_UNIQUE_ITEMS_KEY, collectionLog.getUniqueItems());

		JsonObject jsonTabs = new JsonObject();

		for (Map.Entry<String, CollectionLogTab> tab : collectionLog.getTabs().entrySet())
		{
			JsonObject jsonTab = new JsonObject();

			for (Map.Entry<String, CollectionLogPage> page : tab.getValue().getPages().entrySet())
			{
				JsonObject jsonPage = new JsonObject();
				JsonElement jsonItems = context.serialize(page.getValue().getItems());
				JsonElement jsonKillCounts = context.serialize(page.getValue().getKillCounts());

				jsonPage.addProperty(COLLECTION_LOG_IS_UPDATED_KEY, page.getValue().isUpdated());
				jsonPage.add(COLLECTION_LOG_ITEMS_KEY, jsonItems);
				jsonPage.add(COLLECTION_LOG_KILL_COUNTS_KEY, jsonKillCounts);

				jsonTab.add(page.getKey(), jsonPage);
			}

			jsonTabs.add(tab.getKey(), jsonTab);
		}

		collectionLogJson.add(COLLECTION_LOG_TABS_KEY, jsonTabs);

		return collectionLogJson;
	}
}

package com.evansloan.collectionlog.util;

import com.google.gson.Gson;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.JsonParser;
import com.google.gson.JsonSerializer;
import com.google.inject.Inject;
import java.io.BufferedWriter;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import javax.inject.Singleton;
import lombok.extern.slf4j.Slf4j;

@Slf4j
@Singleton
public class JsonUtils
{
	@Inject
	Gson gson;

	private JsonObject parseFile(String filePath) throws IOException, JsonParseException
	{
		FileReader reader = new FileReader(filePath);
		JsonObject fileContents = new JsonParser().parse(reader).getAsJsonObject();
		reader.close();

		return fileContents;
	}

	public <T, D extends JsonDeserializer<T>> T readJsonFile(String filePath, Class<T> type, D deserializer)
	{
		try
		{
			JsonObject fileContents = parseFile(filePath);
			return gson.newBuilder()
				.registerTypeAdapter(type, deserializer)
				.create()
				.fromJson(fileContents, type);
		}
		catch (IOException | JsonParseException e)
		{
			log.error("Unable to read JSON file at path: " + filePath + "\n" + e.getMessage());
		}

		return null;
	}

	private boolean writeFile(String filePath, String contents)
	{
		try
		{
			BufferedWriter writer = new BufferedWriter(new FileWriter(filePath));
			writer.write(contents);
			writer.close();
			return true;
		}
		catch (IOException e)
		{
			log.error("Unable to write JSON file at path: " + filePath + "\n" + e.getMessage());
		}

		return false;
	}

	public <T> boolean writeJsonFile(String filePath, T data)
	{
		String contents = gson.newBuilder()
			.setPrettyPrinting()
			.create()
			.toJson(data, data.getClass());

		return writeFile(filePath, contents);
	}

	public <T, S extends JsonSerializer<T>> boolean writeJsonFile(String filePath, T data, S serializer)
	{
		String contents = gson.newBuilder()
			.registerTypeAdapter(data.getClass(), serializer)
			.setPrettyPrinting()
			.create()
			.toJson(data);

		return writeFile(filePath, contents);
	}

	public <T> JsonObject toJsonObject(T data)
	{
		return gson.toJsonTree(data).getAsJsonObject();
	}

	public <T, S extends JsonSerializer<T>> JsonObject toJsonObject(T data, S serializer)
	{
		return gson.newBuilder()
			.registerTypeAdapter(data.getClass(), serializer)
			.create()
			.toJsonTree(data)
			.getAsJsonObject();
	}

	public <T, D extends JsonDeserializer<T>> T fromJsonObject(JsonObject data, Class<T> type, D deserializer)
	{
		return gson.newBuilder()
			.registerTypeAdapter(type, deserializer)
			.create()
			.fromJson(data, type);
	}
}

package com.evansloan.collectionlog.util;

import com.evansloan.collectionlog.CollectionLog;
import com.evansloan.collectionlog.CollectionLogItem;
import com.evansloan.collectionlog.CollectionLogKillCount;
import com.evansloan.collectionlog.CollectionLogPage;
import com.evansloan.collectionlog.CollectionLogTab;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import java.lang.reflect.Type;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

public class CollectionLogDeserializer implements JsonDeserializer<CollectionLog>
{
    private static final String COLLECTION_LOG_ITEMS_KEY = "items";
    private static final String COLLECTION_LOG_KILL_COUNTS_KEY = "killCounts";
    private static final String COLLECTION_LOG_TABS_KEY = "tabs";
    private static final String COLLECTION_LOG_TOTAL_OBTAINED_KEY = "totalObtained";
    private static final String COLLECTION_LOG_TOTAL_ITEMS_KEY = "totalItems";
    private static final String COLLECTION_LOG_UNIQUE_OBTAINED_KEY = "uniqueObtained";
    private static final String COLLECTION_LOG_UNIQUE_ITEMS_KEY = "uniqueItems";
	private static final String COLLECTION_LOG_IS_UPDATED_KEY = "isUpdated";

    private final Map<String, String> keyMap = new HashMap<String, String>()
	{
		{
			put(COLLECTION_LOG_KILL_COUNTS_KEY, COLLECTION_LOG_KILL_COUNTS_KEY);
			put(COLLECTION_LOG_TOTAL_OBTAINED_KEY, COLLECTION_LOG_TOTAL_OBTAINED_KEY);
			put(COLLECTION_LOG_TOTAL_ITEMS_KEY, COLLECTION_LOG_TOTAL_ITEMS_KEY);
			put(COLLECTION_LOG_UNIQUE_OBTAINED_KEY, COLLECTION_LOG_UNIQUE_OBTAINED_KEY);
			put(COLLECTION_LOG_UNIQUE_ITEMS_KEY, COLLECTION_LOG_UNIQUE_ITEMS_KEY);
		}
	};

	public CollectionLogDeserializer()
	{
		super();
	}

    @Override
    public CollectionLog deserialize(JsonElement jsonElement, Type type, JsonDeserializationContext context) throws JsonParseException
    {
        JsonObject jsonObjectLog = jsonElement.getAsJsonObject();

        JsonObject jsonObjectTabs = jsonObjectLog.get(COLLECTION_LOG_TABS_KEY).getAsJsonObject();

        Map<String, CollectionLogTab> newTabs = new HashMap<>();
        for (String tabKey : jsonObjectTabs.keySet())
        {
            JsonObject tab = jsonObjectTabs.get(tabKey).getAsJsonObject();
            Map<String, CollectionLogPage> newPages = new HashMap<>();

            for (String pageKey : tab.keySet())
            {
                JsonObject page = tab.get(pageKey).getAsJsonObject();
                List<CollectionLogItem> newItems = new ArrayList<>();

                for (JsonElement item : page.get(COLLECTION_LOG_ITEMS_KEY).getAsJsonArray())
                {
                    CollectionLogItem newItem = context.deserialize(item, CollectionLogItem.class);
                    newItems.add(newItem);
                }

                List<CollectionLogKillCount> newKillCounts = new ArrayList<>();
                JsonElement pageKillCounts = page.get(keyMap.get(COLLECTION_LOG_KILL_COUNTS_KEY));

                if (pageKillCounts != null)
                {
                    for (JsonElement killCount : pageKillCounts.getAsJsonArray())
                    {
                        CollectionLogKillCount newKillCount;
                        newKillCount = context.deserialize(killCount, CollectionLogKillCount.class);
                        newKillCounts.add(newKillCount);
                    }
                }

                boolean isUpdated = page.get(COLLECTION_LOG_IS_UPDATED_KEY) != null
					&& page.get(COLLECTION_LOG_IS_UPDATED_KEY).getAsBoolean();

                CollectionLogPage newPage = new CollectionLogPage(pageKey, newItems, newKillCounts, isUpdated);
                newPages.put(pageKey, newPage);
            }
            CollectionLogTab newTab = new CollectionLogTab(tabKey, newPages);
            newTabs.put(tabKey, newTab);
        }
        return new CollectionLog(
            "",
            jsonObjectLog.get(keyMap.get(COLLECTION_LOG_TOTAL_OBTAINED_KEY)).getAsInt(),
            jsonObjectLog.get(keyMap.get(COLLECTION_LOG_TOTAL_ITEMS_KEY)).getAsInt(),
            jsonObjectLog.get(keyMap.get(COLLECTION_LOG_UNIQUE_OBTAINED_KEY)).getAsInt(),
            jsonObjectLog.get(keyMap.get(COLLECTION_LOG_UNIQUE_ITEMS_KEY)).getAsInt(),
            newTabs
        );
    }
}

package com.evansloan.collectionlog.util;

import com.evansloan.collectionlog.UserSettings;
import com.evansloan.collectionlog.AccountType;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import java.lang.reflect.Type;

public class UserSettingsDeserializer implements JsonDeserializer<UserSettings>
{
	private static final String USER_SETTINGS_DISPLAY_RANK = "displayRank";
	private static final String USER_SETTINGS_SHOW_QUANTITY = "showQuantity";

	@Override
	public UserSettings deserialize(JsonElement jsonElement, Type type, JsonDeserializationContext context) throws JsonParseException
	{
		JsonObject userSettingsJson = jsonElement.getAsJsonObject();
		AccountType displayRank = AccountType.valueOf(userSettingsJson.get(USER_SETTINGS_DISPLAY_RANK).getAsString());
		boolean showQuantity = userSettingsJson.get(USER_SETTINGS_SHOW_QUANTITY).getAsBoolean();

		return new UserSettings(displayRank, showQuantity);
	}
}

package com.evansloan.collectionlog;

import com.evansloan.collectionlog.ui.GameStatePanel;
import com.evansloan.collectionlog.ui.Icon;
import java.awt.BorderLayout;
import java.awt.Color;
import java.awt.Dimension;
import java.awt.GridLayout;
import java.awt.event.ActionListener;
import java.awt.event.ItemEvent;
import java.awt.event.ItemListener;
import java.util.EnumSet;
import javax.swing.BoxLayout;
import javax.swing.ImageIcon;
import javax.swing.JButton;
import javax.swing.JCheckBox;
import javax.swing.JComboBox;
import javax.swing.JComponent;
import javax.swing.JLabel;
import javax.swing.JOptionPane;
import javax.swing.JPanel;
import javax.swing.JTextArea;
import javax.swing.SwingConstants;
import javax.swing.border.EmptyBorder;
import javax.swing.border.LineBorder;
import javax.swing.plaf.basic.BasicButtonUI;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.GameState;
import net.runelite.api.Varbits;
import net.runelite.api.events.GameStateChanged;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.events.ConfigChanged;
import net.runelite.client.game.ItemManager;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.FontManager;
import net.runelite.client.ui.PluginPanel;
import net.runelite.client.ui.components.TitleCaseListCellRenderer;
import net.runelite.client.ui.components.materialtabs.MaterialTab;
import net.runelite.client.ui.components.materialtabs.MaterialTabGroup;
import net.runelite.client.util.AsyncBufferedImage;
import net.runelite.client.util.ImageUtil;
import net.runelite.client.util.LinkBrowser;
import net.runelite.client.util.SwingUtil;

@Slf4j
public class CollectionLogPanel extends PluginPanel
{
	private static final ImageIcon ACCOUNT_ICON;
	private static final ImageIcon DISCORD_ICON;
	private static final ImageIcon GITHUB_ICON;
	private static final ImageIcon RANDOM_ICON;
	private static final ImageIcon INFO_ICON;
	private static final ImageIcon WEBSITE_ICON;
	private static final EmptyBorder DEFAULT_BORDER = new EmptyBorder(10, 10, 10, 10);

	static
	{
		ACCOUNT_ICON = Icon.ACCOUNT.getIcon(img -> ImageUtil.resizeImage(img, 16, 16));
		DISCORD_ICON = Icon.DISCORD.getIcon(img -> ImageUtil.resizeImage(img, 16, 16));
		GITHUB_ICON = Icon.GITHUB.getIcon(img -> ImageUtil.resizeImage(img, 16, 16));
		RANDOM_ICON = Icon.RANDOM.getIcon(img -> ImageUtil.resizeImage(img, 20, 20));
		INFO_ICON = Icon.INFO.getIcon(img -> ImageUtil.resizeImage(img, 20, 20));
		WEBSITE_ICON = Icon.COLLECTION_LOG.getIcon(img -> ImageUtil.resizeImage(img, 16, 16));
	}

	private static GameState currentGameState;

	private final CollectionLogPlugin collectionLogPlugin;
	private final CollectionLogManager collectionLogManager;
	private final ClientThread clientThread;
	private final CollectionLogConfig config;
	private final ItemManager itemManager;

	private GameStatePanel accountPanel;
	private JLabel clnEnabledLabel;
	private JButton uploadCollectionLogBtn;
	private JButton deleteCollectionLogBtn;
	private JTextArea statusTextArea;
	private JPanel accountSettingsPanel;
	private JComboBox<AccountType> displayRankComboBox;
	private JCheckBox showQuantityCheck;

	private JButton randomCollectionLogBtn;
	private JLabel randomItemSprite;
	private JLabel randomItemLabel;

	public CollectionLogPanel(
		CollectionLogPlugin collectionLogPlugin,
		CollectionLogManager collectionLogManager,
		ClientThread clientThread,
		CollectionLogConfig config,
		ItemManager itemManager
	)
	{
		super(false);

		this.collectionLogPlugin = collectionLogPlugin;
		this.collectionLogManager = collectionLogManager;
		this.clientThread = clientThread;
		this.config = config;
		this.itemManager = itemManager;
	}

	public void create(GameState gameState)
	{
		setBackground(ColorScheme.DARK_GRAY_COLOR);
		setLayout(new BorderLayout());
		setBorder(DEFAULT_BORDER);

		JPanel layoutPanel = new JPanel();
		layoutPanel.setLayout(new BoxLayout(layoutPanel, BoxLayout.Y_AXIS));

		JPanel titlePanel = createTitlePanel();
		JPanel tabPanel = createTabPanel(gameState);

		layoutPanel.add(titlePanel);
		layoutPanel.add(tabPanel);

		add(layoutPanel, BorderLayout.NORTH);
	}

	private JPanel createTitlePanel()
	{
		JPanel titlePanel = new JPanel();
		titlePanel.setBorder(new EmptyBorder(0, 0, 10, 0));
		titlePanel.setLayout(new BorderLayout());

		JLabel title = new JLabel();
		title.setText("Collection Log");
		title.setForeground(Color.WHITE);
		titlePanel.add(title, BorderLayout.WEST);

		final JPanel infoButtons = new JPanel(new GridLayout(1, 3, 10, 0));
		infoButtons.setBackground(ColorScheme.DARK_GRAY_COLOR);

		JButton websiteBtn = createTitleButton(
			WEBSITE_ICON,
			"Open collectionlog.net",
			"https://collectionlog.net"
		);
		infoButtons.add(websiteBtn);

		JButton discordBtn = createTitleButton(
			DISCORD_ICON,
			"Join the Log Hunters Discord Server",
			"https://discord.gg/loghunters"
		);
		infoButtons.add(discordBtn);

		JButton githubBtn = createTitleButton(
			GITHUB_ICON,
			"View the Collection Log plugin source code on GitHub",
			"https://github.com/evansloan/collection-log"
		);
		infoButtons.add(githubBtn);

		titlePanel.add(infoButtons, BorderLayout.EAST);

		JPanel titleContainer = new JPanel();
		titleContainer.setLayout(new BorderLayout());
		titleContainer.add(titlePanel, BorderLayout.NORTH);

		return titleContainer;
	}

	private JPanel createTabPanel(GameState gameState)
	{
		boolean isLoggedIn = gameState == GameState.LOGGED_IN;

		JPanel tabPanel = new JPanel();
		tabPanel.setLayout(new BoxLayout(tabPanel, BoxLayout.Y_AXIS));

		JPanel activeTabPanel = new JPanel();
		activeTabPanel.setLayout(new BoxLayout(activeTabPanel, BoxLayout.Y_AXIS));
		MaterialTabGroup tabGroup = new MaterialTabGroup(activeTabPanel);
		tabGroup.setLayout(new GridLayout(1, 3, 10, 10));
		tabGroup.setBorder(new EmptyBorder(0, 0, 10, 0));
		tabPanel.add(tabGroup);
		tabPanel.add(activeTabPanel);

		JPanel infoPanel = createInfoPanel();
		activeTabPanel.add(infoPanel);
		createTab(INFO_ICON, "Info", tabGroup, infoPanel).select();

		accountPanel = createAccountPanel(isLoggedIn);
		createTab(ACCOUNT_ICON, "Account", tabGroup, accountPanel);

		JPanel randomPanel = createRandomPanel();
		createTab(RANDOM_ICON, "Random", tabGroup, randomPanel);

		return tabPanel;
	}

	private JPanel createInfoPanel()
	{
		JPanel infoPanel = new JPanel();
		infoPanel.setLayout(new BoxLayout(infoPanel, BoxLayout.Y_AXIS));

		JPanel pluginInfoPanel = new JPanel(new GridLayout(0, 1));
		pluginInfoPanel.setBackground(ColorScheme.DARKER_GRAY_COLOR);
		pluginInfoPanel.setBorder(DEFAULT_BORDER);
		infoPanel.add(pluginInfoPanel);

		JLabel versionLabel = createKeyValueLabel("Version: ", CollectionLogConfig.PLUGIN_VERSION);
		clnEnabledLabel = createKeyValueLabel(
			"collectionlog.net uploads: ",
			config.allowApiConnections() ? "Enabled" : "Disabled"
		);
		pluginInfoPanel.add(versionLabel);
		pluginInfoPanel.add(clnEnabledLabel);


		JPanel buttonPanel = new JPanel(new GridLayout(4, 1, 0, 5));
		buttonPanel.setBorder(new EmptyBorder(10, 0, 0, 0));
		infoPanel.add(buttonPanel);

		JButton changeLogButton = createButton(
			"Change log",
			(event) -> LinkBrowser.browse("https://collectionlog.net/change-log")
		);
		buttonPanel.add(changeLogButton);

		JButton quickStartButton = createButton(
			"Quick start",
			(event) -> LinkBrowser.browse("https://collectionlog.net/quick-start")
		);
		buttonPanel.add(quickStartButton);

		JButton faqButton = createButton(
			"FAQ",
			(event) -> LinkBrowser.browse("https://collectionlog.net/faq")
		);
		buttonPanel.add(faqButton);

		return infoPanel;
	}

	private GameStatePanel createAccountPanel(boolean isLoggedIn)
	{
		GameStatePanel gameStatePanel = new GameStatePanel();
		gameStatePanel.setLayout(new BoxLayout(gameStatePanel, BoxLayout.Y_AXIS));

		// Account tab logged out state
		JLabel accountLoggedOutLabel = new JLabel("Log in to manage your account");
		accountLoggedOutLabel.setForeground(ColorScheme.LIGHT_GRAY_COLOR);
		gameStatePanel.setLoggedOutContent(accountLoggedOutLabel);

		// Account tab logged in state
		JPanel accountLoggedInPanel = new JPanel();
		accountLoggedInPanel.setLayout(new BorderLayout());
		gameStatePanel.setLoggedInContent(accountLoggedInPanel);

		statusTextArea = createTextArea("");
		accountLoggedInPanel.add(statusTextArea, BorderLayout.NORTH);

		JPanel accountButtonPanel = createAccountButtonPanel();
		accountLoggedInPanel.add(accountButtonPanel, BorderLayout.CENTER);

		accountSettingsPanel = createAccountSettingsPanel();
		accountSettingsPanel.setVisible(config.allowApiConnections());
		accountLoggedInPanel.add(accountSettingsPanel, BorderLayout.SOUTH);

		gameStatePanel.updateContent(isLoggedIn);

		return gameStatePanel;
	}

	private JPanel createAccountSettingsPanel()
	{
		JPanel settingsPanel = new JPanel(new BorderLayout());
		settingsPanel.setBorder(new EmptyBorder(0, 0, 10, 0));

		JLabel settingsLabel = createTitleLabel("Account settings");
		settingsPanel.add(settingsLabel, BorderLayout.NORTH);

		JPanel controlPanel = new JPanel();
		controlPanel.setLayout(new BoxLayout(controlPanel, BoxLayout.Y_AXIS));

		JPanel showQuantityPanel = new JPanel(new BorderLayout());
		showQuantityPanel.setMinimumSize(new Dimension(PANEL_WIDTH, 0));

		JLabel showQuantityLabel = new JLabel("Show item quantities");
		showQuantityLabel.setForeground(Color.WHITE);
		showQuantityLabel.setToolTipText("Toggle the display of item quantities on collectionlog.net");
		showQuantityPanel.add(showQuantityLabel, BorderLayout.CENTER);

		showQuantityCheck = createCheckBox((event) -> {
			collectionLogManager.getUserSettings()
				.setShowQuantity(event.getStateChange() == ItemEvent.SELECTED);
		});
		showQuantityPanel.add(showQuantityCheck, BorderLayout.EAST);

		controlPanel.add(showQuantityPanel);

		JPanel displayRankPanel = new JPanel(new BorderLayout());
		displayRankPanel.setMinimumSize(new Dimension(PANEL_WIDTH, 0));

		JLabel displayRankLabel = new JLabel("Display rank");
		displayRankLabel.setForeground(Color.WHITE);
		displayRankLabel.setToolTipText("Rank type to display on collectionlog.net profile");
		displayRankPanel.add(displayRankLabel, BorderLayout.CENTER);

		displayRankComboBox = createComboBox(AccountType.values(), event -> {
			collectionLogManager.getUserSettings().setDisplayRank((AccountType) event.getItem());
		});
		displayRankPanel.add(displayRankComboBox, BorderLayout.EAST);

		controlPanel.add(displayRankPanel);
		settingsPanel.add(controlPanel, BorderLayout.CENTER);

		return settingsPanel;
	}

	private JPanel createAccountButtonPanel()
	{
		JPanel buttonPanel = new JPanel(new GridLayout(4, 1));
		buttonPanel.setBorder(new EmptyBorder(0, 0, 10, 0));

		JLabel titleLabel = createTitleLabel("Account management");
		buttonPanel.add(titleLabel);

		uploadCollectionLogBtn = createButton(
			"Upload collection log",
			(event) -> {
				collectionLogPlugin.setCollectionLogDeleted(false);
				setStatus("Uploading collection log to collectionlog.net...", false, false);
				clientThread.invokeLater(collectionLogPlugin::saveCollectionLogData);
			}
		);
		uploadCollectionLogBtn.setVisible(config.allowApiConnections());
		buttonPanel.add(uploadCollectionLogBtn);

		JButton clearCollectionLogBtn = createButton(
			"Reset collection log data",
			(event) -> collectionLogManager.deleteSaveFile()
		);
		buttonPanel.add(clearCollectionLogBtn);

		deleteCollectionLogBtn = createButton(
			"Delete collection log",
			(event) -> {
				int confirm = JOptionPane.showOptionDialog(
					deleteCollectionLogBtn,
					"Are you sure you want to delete your collection log from collectionlog.net?\n" +
					"Make sure to disable \"Allow collectionlog.net connections\" config to prevent future uploads.",
					"Delete collection log?",
					JOptionPane.YES_NO_OPTION,
					JOptionPane.WARNING_MESSAGE,
					null,
					new String[]{"Yes", "No"},
					"No"
				);

				if (confirm == JOptionPane.YES_OPTION)
				{
					setStatus("Deleting collection log from collectionlog.net...", false, false);
					clientThread.invokeLater(collectionLogPlugin::deleteCollectionLog);
				}
			}
		);
		deleteCollectionLogBtn.setBackground(ColorScheme.PROGRESS_ERROR_COLOR);
		deleteCollectionLogBtn.setVisible(config.allowApiConnections());
		buttonPanel.add(deleteCollectionLogBtn);

		return buttonPanel;
	}

	private JPanel createRandomPanel()
	{
		JPanel randomPanel = new JPanel();
		randomPanel.setLayout(new BoxLayout(randomPanel, BoxLayout.Y_AXIS));

		JPanel childPanel = createChildRandomPanel();
		randomPanel.add(childPanel);
		
		return randomPanel;
	}

	private JPanel createChildRandomPanel()
	{
		JPanel buttonPanel = new JPanel(new GridLayout(4, 1));
		buttonPanel.setBorder(new EmptyBorder(0, 0, 10, 0));

		JLabel titleLabel = createTitleLabel("Random Collection Log Item Picker");
		titleLabel.setVerticalAlignment(SwingConstants.CENTER);
		titleLabel.setHorizontalAlignment(SwingConstants.CENTER);
		buttonPanel.add(titleLabel);

		randomCollectionLogBtn = createButton(
			"Roll New Item",
			(event) -> clientThread.invokeLater(() -> {
				CollectionLogItem item = collectionLogManager.getRandomItem();
				if (item == null)
				{
					randomItemLabel.setText("Open Collection Log first");
					return;
				}
				AsyncBufferedImage itemImage = itemManager.getImage(item.getId(), 1, false);
				itemImage.addTo(randomItemSprite);
				randomItemLabel.setText(item.getName());
			})
		);
		buttonPanel.add(randomCollectionLogBtn);

		randomItemSprite = new JLabel();
		randomItemSprite.setVerticalAlignment(SwingConstants.CENTER);
		randomItemSprite.setHorizontalAlignment(SwingConstants.CENTER);
		randomItemSprite.setMinimumSize(new Dimension(36, 36));
		randomItemSprite.setPreferredSize(new Dimension(36, 36));
		randomItemSprite.setBorder(new LineBorder(Color.BLACK, 1));
		buttonPanel.add(randomItemSprite);

		randomItemLabel = createTitleLabel("");
		randomItemLabel.setVerticalAlignment(SwingConstants.CENTER);
		randomItemLabel.setHorizontalAlignment(SwingConstants.CENTER);
		buttonPanel.add(randomItemLabel);

		return buttonPanel;
	}

	private JTextArea createTextArea(String text)
	{
		JTextArea textArea = new JTextArea(0, 22);
		textArea.setText(text);
		textArea.setWrapStyleWord(true);
		textArea.setLineWrap(true);
		textArea.setEditable(false);
		textArea.setFocusable(false);
		textArea.setOpaque(false);

		return textArea;
	}

	private JButton createTitleButton(ImageIcon icon, String toolTip, String url)
	{
		JButton btn = new JButton();
		SwingUtil.removeButtonDecorations(btn);
		btn.setIcon(icon);
		btn.setToolTipText(toolTip);
		btn.setBackground(ColorScheme.DARK_GRAY_COLOR);
		btn.setUI(new BasicButtonUI());
		btn.addActionListener((event) -> LinkBrowser.browse(url));
		btn.addMouseListener(new java.awt.event.MouseAdapter()
		{
			public void mouseEntered(java.awt.event.MouseEvent mouseEvent)
			{
				btn.setBackground(ColorScheme.DARK_GRAY_HOVER_COLOR);
			}

			public void mouseExited(java.awt.event.MouseEvent mouseEvent)
			{
				btn.setBackground(ColorScheme.DARK_GRAY_COLOR);
			}
		});

		return btn;
	}

	private JButton createButton(String text, ActionListener actionListener)
	{
		JButton btn = new JButton();
		btn.setBorder(new EmptyBorder(15, 0, 15, 0));
		btn.setText(text);
		btn.setForeground(Color.WHITE);
		btn.setPreferredSize(new Dimension(PluginPanel.PANEL_WIDTH - 5, 30));
		btn.addActionListener(actionListener);
		btn.setFocusable(false);

		return btn;
	}

	private MaterialTab createTab(ImageIcon icon, String toolTipText, MaterialTabGroup tabGroup, JComponent content)
	{
		MaterialTab tab = new MaterialTab(icon, tabGroup, content);
		tab.setToolTipText(toolTipText);
		tabGroup.addTab(tab);

		return tab;
	}

	private JPanel createTabContentPanel()
	{
		JPanel tabContentPanel = new JPanel(new GridLayout(0, 1));
		tabContentPanel.setBorder(DEFAULT_BORDER);
		tabContentPanel.setBackground(ColorScheme.DARKER_GRAY_COLOR);

		return tabContentPanel;
	}

	private String htmlText(String text)
	{
		return "<html><body style='color:#A5A5A5'>" + text + "</body></html>";
	}

	private String getKeyValueText(String key, String value)
	{
		return htmlText(key + "<span style='color:white'>" + value + "</span>");
	}

	private JLabel createKeyValueLabel(String key, String value)
	{
		return new JLabel(getKeyValueText(key, value));
	}

	private JLabel createTitleLabel(String text)
	{
		JLabel titleLabel = new JLabel(text);
		titleLabel.setBorder(new EmptyBorder(10, 0, 10, 0));
		titleLabel.setFont(FontManager.getRunescapeBoldFont());
		titleLabel.setForeground(Color.WHITE);

		return titleLabel;
	}

	private JCheckBox createCheckBox(ItemListener itemListener)
	{
		JCheckBox checkBox = new JCheckBox();
		checkBox.setBackground(ColorScheme.LIGHT_GRAY_COLOR);
		checkBox.addItemListener(itemListener);
		checkBox.setSelected(true);

		return checkBox;
	}

	private <T extends Enum<T>> JComboBox<T> createComboBox(T[] items, ItemListener itemListener)
	{
		JComboBox<T> comboBox = new JComboBox<>(items);
		comboBox.setRenderer(new TitleCaseListCellRenderer());
		comboBox.setForeground(Color.WHITE);
		comboBox.setFocusable(false);
		comboBox.addItemListener(itemListener);

		return comboBox;
	}

	public void setUserSettings(UserSettings userSettings)
	{
		displayRankComboBox.setSelectedItem(userSettings.getDisplayRank());
		showQuantityCheck.setSelected(userSettings.isShowQuantity());
	}

	/**
	 * Set the status message that appears at the top of the account panel and
	 * enables/disables upload and delete buttons
	 *
	 * @param message Message to display. Pass null to keep previous message
	 * @param isError Set to true to color message text red
	 * @param enableBtn Should upload/delete buttons be enabled
	 */
	public void setStatus(String message, boolean isError, boolean enableBtn)
	{
		Color textColor = Color.WHITE;
		if (isError)
		{
			textColor = ColorScheme.PROGRESS_ERROR_COLOR;
		}

		if (message != null)
		{
			statusTextArea.setText(message);
			statusTextArea.setForeground(textColor);
		}

		uploadCollectionLogBtn.setEnabled(enableBtn);
		deleteCollectionLogBtn.setEnabled(enableBtn);
	}

	public void onConfigChanged(ConfigChanged configChanged)
	{
		if (configChanged.getKey().equals("upload_collection_log"))
		{
			clnEnabledLabel.setText(getKeyValueText(
				"collectionlog.net uploads: ",
				config.allowApiConnections() ? "Enabled" : "Disabled"
			));

			uploadCollectionLogBtn.setVisible(config.allowApiConnections());
			deleteCollectionLogBtn.setVisible(config.allowApiConnections());
			accountSettingsPanel.setVisible(config.allowApiConnections());

			accountPanel.revalidate();
			accountPanel.repaint();
		}
	}

	public void onGameStateChanged(GameStateChanged gameStateChanged)
	{
		GameState gameState = gameStateChanged.getGameState();
		if (gameState != GameState.LOGGED_IN && gameState != GameState.LOGIN_SCREEN)
		{
			return;
		}

		// Check if game state has changed to prevent updating panels
		// when going from LOGGED_IN -> LOADING -> LOGGED_IN
		boolean isNewGameState = gameState != currentGameState;
		if (!isNewGameState)
		{
			return;
		}

		currentGameState = gameState;
		GameStatePanel.updatePanels(gameState);

		if (gameState == GameState.LOGGED_IN)
		{
			clientThread.invokeLater(() -> {
				Client client = collectionLogPlugin.getClient();
				EnumSet<AccountType> accountTypes = AccountType.getAllAccountTypes(client.getVarbitValue(Varbits.ACCOUNT_TYPE));

				displayRankComboBox.removeAllItems();

				for (AccountType accountType : accountTypes)
				{
					displayRankComboBox.addItem(accountType);
				}
			});
		}
	}
}

package com.evansloan.collectionlog;

import lombok.AllArgsConstructor;
import lombok.Getter;

@Getter
@AllArgsConstructor
enum CollectionLogList
{
	BOSSES(12),
	RAIDS(16),
	CLUES(32),
	MINIGAMES(35),
	OTHER(34);

	private final int listIndex;
}

package com.evansloan.collectionlog;

import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.Setter;
import net.runelite.client.util.Text;

@Getter
@AllArgsConstructor
public class CollectionLogKillCount
{
    private final String name;
	@Setter
    private int amount;
    private final int sequence;

	public static CollectionLogKillCount fromString(String killCountString, int sequence)
	{
		String[] killCountSplit = killCountString.split(": ");
		String name = killCountSplit[0];
		String amount = Text.removeTags(killCountSplit[1])
			.replace(",", "");

		return new CollectionLogKillCount(name, Integer.parseInt(amount), sequence);
	}
}
package com.evansloan.collectionlog;

import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.Setter;
import org.apache.commons.lang3.StringUtils;
import java.util.Map;

@Getter
@AllArgsConstructor
public class CollectionLog
{
    private final String username;

    @Setter
    private int totalObtained;

    @Setter
    private int totalItems;

    @Setter
    private int uniqueObtained;

    @Setter
    private int uniqueItems;

    private final Map<String, CollectionLogTab> tabs;

    public CollectionLogPage searchForPage(String pageName)
    {
        if (StringUtils.isEmpty(pageName))
        {
            return null;
        }

        for (CollectionLogTab tab : tabs.values())
        {
            for (CollectionLogPage page : tab.getPages().values())
            {
                if (pageName.equalsIgnoreCase(page.getName()))
                {
                    return page;
                }
            }
        }
        return null;
    }

    public CollectionLogPage randomPage()
    {
        int pageCount = 0;
        for (CollectionLogTab tab : tabs.values())
        {
            pageCount += tab.getPages().size();
        }

        int randomIndex = (int) (Math.random() * pageCount);
        int index = 0;
        for (CollectionLogTab tab : tabs.values())
        {
            for (CollectionLogPage page : tab.getPages().values())
            {
                if (index == randomIndex)
                {
                    return page;
                }
                index++;
            }
        }
        return null;
    }
}
/*
 *
 *  * Copyright (c) 2021, Senmori
 *  * All rights reserved.
 *  *
 *  * Redistribution and use in source and binary forms, with or without
 *  * modification, are permitted provided that the following conditions are met:
 *  *
 *  * 1. Redistributions of source code must retain the above copyright notice, this
 *  *    list of conditions and the following disclaimer.
 *  * 2. Redistributions in binary form must reproduce the above copyright notice,
 *  *    this list of conditions and the following disclaimer in the documentation
 *  *    and/or other materials provided with the distribution.
 *  *
 *  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 *  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 *  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 *  * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 *  * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 *  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 *  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 *  * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 *  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 *  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 */

package com.evansloan.collectionlog.ui;

import com.evansloan.collectionlog.CollectionLogPlugin;
import java.awt.image.BufferedImage;
import java.util.function.UnaryOperator;
import javax.annotation.Nonnull;
import javax.swing.ImageIcon;
import net.runelite.client.util.ImageUtil;

public enum Icon
{
	ACCOUNT("/account.png"),
	COLLECTION_LOG("/collection_log.png"),
	COLLECTION_LOG_TOOLBAR("/collection_log_toolbar.png"),
	DISCORD("/discord.png"),
	GITHUB("/github.png"),
	RANDOM("/random.png"),
	INFO("/info.png"),
	;

	private final String file;
	Icon(String file)
	{
		this.file = file;
	}

	/**
	 * Get the raw {@link BufferedImage} of this icon.
	 * @return {@link BufferedImage} of the icon
	 */
	public BufferedImage getImage()
	{
		return ImageUtil.loadImageResource(CollectionLogPlugin.class, file);
	}

	/**
	 * @return the {@link ImageIcon} with no modifications. Equivalent to {@code getIcon(UnaryOperator.identity())}
	 */
	public ImageIcon getIcon()
	{
		return getIcon(UnaryOperator.identity());
	}

	/**
	 * Return this icon.
	 * <br>
	 * The {@link UnaryOperator} is applied to the {@link BufferedImage}. The {@link ImageIcon}
	 * is then created using that modified image.
	 *
	 * @param func the {@link UnaryOperator} to apply to the image
	 * @return the modified {@link ImageIcon}
	 */
	public ImageIcon getIcon(@Nonnull UnaryOperator<BufferedImage> func)
	{
		BufferedImage img = func.apply(getImage());
		return new ImageIcon(img);
	}
}
package com.evansloan.collectionlog.ui;

import lombok.Getter;
import lombok.Setter;
import net.runelite.api.GameState;

import javax.swing.BoxLayout;
import javax.swing.JComponent;
import javax.swing.JPanel;
import java.util.ArrayList;
import java.util.List;

@Getter
@Setter
public class GameStatePanel extends JPanel
{
	private static List<GameStatePanel> gameStatePanelList = new ArrayList<>();

	private JComponent loggedInContent;
	private JComponent loggedOutContent;

	public GameStatePanel()
	{
		gameStatePanelList.add(this);
	}

	public static void updatePanels(GameState gameState)
	{
		boolean isLoggedIn = gameState == GameState.LOGGED_IN;

		for (GameStatePanel gameStatePanel : gameStatePanelList)
		{
			gameStatePanel.updateContent(isLoggedIn);
		}
	}

	public void updateContent(boolean isLoggedIn)
	{
		removeAll();

		if (isLoggedIn)
		{
			add(loggedInContent);
		}
		else
		{
			add(loggedOutContent);
		}

		revalidate();
		repaint();
	}
}

package com.evansloan.collectionlog;

import com.google.common.collect.ImmutableMap;
import java.util.function.Predicate;
import java.util.stream.Collectors;
import java.util.List;
import java.util.Map;
import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.Setter;

@Getter
@AllArgsConstructor
public class CollectionLogPage
{
	public static final String ITEM_FILTER_DUPES = "dupes";
	public static final String ITEM_FILTER_MISSING = "missing";
	public static final String ITEM_FILTER_OBTAINED = "obtained";

	private static final Map<String, Predicate<CollectionLogItem>> ITEM_FILTERS = new ImmutableMap.Builder<String, Predicate<CollectionLogItem>>()
		.put(ITEM_FILTER_OBTAINED, CollectionLogItem::isObtained)
		.put(ITEM_FILTER_MISSING, (item) -> !item.isObtained())
		.put(ITEM_FILTER_DUPES, (item) -> item.getQuantity() > 1)
		.build();

	private final String name;
	private List<CollectionLogItem> items;
	private final List<CollectionLogKillCount> killCounts;

	@Setter
	private boolean isUpdated;

	public static String aliasPageName(String pageName)
	{
		switch (pageName.toLowerCase())
		{
			// Bosses Tab
			case "sire":
				return "Abyssal Sire";
			case "hydra":
				return "Alchemical Hydra";
			case "byro":
				return "Bryophyta";
			case "barrows":
				return "Barrows Chests";
			case "artio":
			case "art":
			case "cal":
			case "callisto":
				return "Callisto and Artio";
			case "cerb":
				return "Cerberus";
			case "chaos ele":
				return "Chaos Elemental";
			case "sara":
			case "saradomin":
			case "zilyana":
			case "zily":
				return "Commander Zilyana";
			case "corp":
				return "Corporeal Beast";
			case "crazy arch":
				return "Crazy Archaeologist";
			case "dks":
				return "Dagannoth Kings";
			case "duke":
			case "succ":
			case "succelus":
			case "ugly":
			case "succellus":
			case "duke succellus":
				return "Duke Succelus";
			case "jad":
			case "fight caves":
			case "fc":
				return "The Fight Caves";
			case "gaunt":
			case "gauntlet":
			case "cgaunt":
			case "cgauntlet":
			case "the corrupted gauntlet":
			case "cg":
				return "The Gauntlet";
			case "mole":
				return "Giant Mole";
			case "bando":
			case "bandos":
			case "graardor":
				return "General Graardor";
			case "dusk":
			case "dawn":
			case "gargs":
			case "ggs":
			case "gg":
				return "Grotesque Guardians";
			case "farming guild":
			case "uim":
				return "Hespori";
			case "zuk":
			case "inferno":
				return "The Inferno";
			case "kq":
				return "Kalphite Queen";
			case "kbd":
				return "King Black Dragon";
			case "cave kraken":
				return "Kraken";
			case "arma":
			case "kree":
			case "kreearra":
			case "armadyl":
				return "Kree'arra";
			case "zammy":
			case "zamorak":
			case "kril":
			case "kril trutsaroth":
				return "K'ril Tsutsaroth";
			case "leviathan":
			case "levi":
			case "lev":
				return "The Leviathan";
			case "nightmare":
			case "nm":
			case "tnm":
			case "nmare":
			case "pnm":
			case "phosani":
			case "phosanis":
			case "phosani nm":
			case "phosani nightmare":
			case "phosanis nightmare":
				return "The Nightmare";
			case "hill giant":
				return "Obor";
			case "mus":
			case "muspah":
			case "pm":
			case "the grumbler":
				return "Phantom Muspah";
			case "saracha":
			case "sarac":
			case "saracnis":
				return "Sarachnis";
			case "scorpa":
				return "Scorpia";
			case "scur":
			case "scurius":
			case "rat":
				return "Scurrius";
			case "skotizos":
			case "totems":
			case "totem":
				return "Skotizo";
			case "tempoross":
			case "temp":
				return "Tempoross";
			case "smoke devil":
			case "smoke devils":
			case "thermy":
			case "thermey":
				return "Thermonuclear Smoke Devil";
			case "vard":
			case "vardo":
				return "Vardorvis";
			case "spin":
			case "spindel":
			case "vene":
			case "venenatis":
				return "Venenatis and Spindel";
			case "calv":
			case "calvarion":
			case "calvar ion":
			case "calvar'ion":
			case "vetion":
			case "vet ion":
			case "vet'ion":
			case "veti":
				return "Vet'ion and Calvar'ion";
			case "vork":
			case "vorki":
				return "Vorkath";
			case "wt":
			case "todt":
				return "Wintertodt";
			case "whisperer":
			case "whisp":
			case "wisp":
				return "The Whisperer";
			case "zalc":
				return "Zalcano";
			case "zul":
			case "profit snake":
			case "bjs":
				return "Zulrah";

			// Raids Tab
			case "cox":
			case "xeric":
			case "chambers":
			case "olm":
			case "raids":
			case "cox cm":
			case "xeric cm":
			case "chambers cm":
			case "olm cm":
			case "raids cm":
			case "chambers of xeric - challenge mode":
				return "Chambers of Xeric";
			case "tob":
			case "theatre":
			case "verzik":
			case "verzik vitur":
			case "raids 2":
			case "theatre of blood: story mode":
			case "tob sm":
			case "tob story mode":
			case "tob story":
			case "theatre of blood: entry mode":
			case "tob em":
			case "tob entry mode":
			case "tob entry":
			case "theatre of blood: hard mode":
			case "tob cm":
			case "tob hm":
			case "tob hard mode":
			case "tob hard":
			case "hmt":
				return "Theatre of Blood";
			case "toa":
			case "tomb":
			case "tombs":
			case "raids 3":
			case "tomb of amascut":
				return "Tombs of Amascut";

			// Clues Tab
			case "begs":
			case "beg clues":
			case "beginners":
			case "beginner clues":
			case "beginner clue":
			case "clues beg":
			case "clues beginner":
			case "clue beg":
			case "clue beginner":
				return "Beginner Treasure Trails";
			case "easy clues":
			case "easy clue":
			case "easies":
			case "clues easy":
			case "clue easy":
				return "Easy Treasure Trails";
			case "meds":
			case "med":
			case "mediums":
			case "medium clues":
			case "medium clue":
			case "clues med":
			case "clues medium":
			case "clue med":
			case "clue medium":
				return "Medium Treasure Trails";
			case "hards":
			case "hard clues":
			case "hard clue":
			case "clue hard":
			case "clues hard":
				return "Hard Treasure Trails";
			case "masters":
			case "master clues":
			case "master clue":
			case "clue master":
			case "clues master":
				return "Master Treasure Trails";
			case "elites":
			case "elite clues":
			case "elite clue":
			case "clue elite":
			case "clues elite":
				return "Elite Treasure Trails";
			case "hards rare":
			case "hard clues rare":
			case "hard clue rare":
			case "hards rares":
			case "hard clues rares":
			case "hard clue rares":
			case "rare hards":
			case "rare hard":
				return "Hard Treasure Trails (Rare)";
			case "elites rare":
			case "elite clues rare":
			case "elite clue rare":
			case "elites rares":
			case "elite clues rares":
			case "elite clue rares":
			case "rare elite":
			case "rare elites":
				return "Elite Treasure Trails (Rare)";
			case "master treasure trails rare":
			case "masters rare":
			case "master clues rare":
			case "master clue rare":
			case "master treasure trails rares":
			case "masters rares":
			case "master clues rares":
			case "master clue rares":
			case "rare master":
			case "rare masters":
				return "Master Treasure Trails (Rare)";
			case "shared rewards":
			case "shared clue":
			case "shared clues":
			case "shared":
				return "Shared Treasure Trail Rewards";

			// Minigames Tab
			case "ba":
			case "barb":
				return "Barbarian Assault";
			case "brimhaven agility":
			case "brimhaven":
			case "brim agility":
			case "brim":
				return "Brimhaven Agility Arena";
			case "cw":
			case "cwars":
				return "Castle Wars";
			case "trawler":
				return "Fishing Trawler";
			case "giants foundry":
			case "foundry":
			case "gf":
				return "Giants' Foundry";
			case "gnome":
			case "restaurant":
				return "Gnome Restaurant";
			case "guardian of the rift":
			case "gotr":
			case "grift":
			case "grifting":
			case "guardians":
			case "runetodt":
				return "Guardians of the Rift";
			case "hs":
			case "sepc":
			case "sepulchre":
				return "Hallowed Sepulchre";
			case "lms":
				return "Last Man Standing";
			case "mta":
			case "magic arena":
				return "Magic Training Arena";
			case "mah homes":
			case "mahogany home":
			case "mh":
				return "Mahogany Homes";
			case "pc":
				return "Pest Control";
			case "rogues den":
			case "rogue den":
			case "rogues":
			case "rogue":
				return "Rogues' Den";
			case "shades of mortton":
			case "shade of mortton":
			case "shades":
			case "shade":
			case "mort ton":
			case "mortton":
				return "Shades of Mort'ton";
			case "soul war":
			case "sw":
				return "Soul Wars";
			case "trekking":
			case "temple trek":
				return "Temple Trekking";
			case "tithe":
				return "Tithe Farm";
			case "brewing":
				return "Trouble Brewing";
			case "vm":
			case "volc mine":
				return "Volcanic Mine";

			// Other Tab
			case "aerial fish":
			case "aerial":
				return "Aerial Fishing";
			case "all pets":
			case "pets":
			case "pet":
				return "All Pets";
			case "champions challenge":
			case "champion challenge":
			case "champion scrolls":
			case "champ scrolls":
				return "Champion's Challenge";
			case "chaos druid":
			case "elder druids":
			case "elder druid":
			case "elder":
				return "Chaos Druids";
			case "chompy":
			case "chompies":
			case "bird hunting":
				return "Chompy Bird Hunting";
			case "tower of life":
				return "Creature Creation";
			case "defenders":
			case "defender":
				return "Cyclopes";
			case "fossil island note":
			case "fossil island":
				return "Fossil Island Notes";
			case "gloughs experiments":
			case "gloughs experiment":
			case "glough experiments":
			case "glough experiment":
			case "demonics":
			case "demonic gorilla":
			case "demonic gorillas":
				return "Glough's Experiments";
			case "monkey backpacks":
			case "monkey backpack":
			case "ape atoll":
			case "backpack":
			case "backpacks":
				return "Monkey Backpacks";
			case "motherlode mine":
			case "motherlode":
			case "mlm":
			case "mm":
				return "Motherlode Mine";
			case "my notes":
			case "notes":
			case "note":
				return "My Notes";
			case "random event":
			case "random":
			case "randoms":
				return "Random Events";
			case "revs":
				return "Revenants";
			case "rooftop":
			case "rooftops":
			case "agility":
			case "graceful":
				return "Rooftop Agility";
			case "shayzien":
				return "Shayzien Armour";
			case "shooting star":
			case "star mining":
			case "ss":
			case "stars":
				return "Shooting Stars";
			case "skilling pet":
			case "skill pets":
			case "skill pet":
			case "pets skill":
			case "pet skill":
			case "pets skilling":
			case "pet skilling":
				return "Skilling Pets";
			case "slay":
				return "Slayer";
			case "tz haar":
			case "tz":
			case "tzh":
				return "TzHaar";
			case "misc":
				return "Miscellaneous";

			default:
				return pageName;
		}
	}

	public int getObtainedItemCount()
	{
		return (int) items.stream()
			.filter(CollectionLogItem::isObtained)
			.count();
	}

	public CollectionLogItem getItemById(int itemId)
	{
		for (CollectionLogItem item : getItems())
		{
			if (item.getId() == itemId)
			{
				return item;
			}
		}
		return null;
	}

	public List<CollectionLogItem> applyItemFilter(String filterString)
	{
		Predicate<CollectionLogItem> filter = ITEM_FILTERS.get(filterString);
		if (filter == null)
		{
			return items;
		}

		return items.stream().filter(filter).collect(Collectors.toList());
	}

	public CollectionLogKillCount getKillCountByName(String name)
	{
		for (CollectionLogKillCount killCount : getKillCounts())
		{
			if (killCount.getName().equals(name))
			{
				return killCount;
			}
		}
		return null;
	}
}

package com.evansloan.collectionlog;

import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.Setter;
import net.runelite.api.ItemComposition;

@Getter
@AllArgsConstructor
public class CollectionLogItem
{

	@Setter
    private int id;

    private final String name;

    @Setter
    private int quantity;

    @Setter
    private boolean obtained;

    private final int sequence;

    public static CollectionLogItem fromItemComposition(ItemComposition itemComposition, Integer sequence)
    {
        return new CollectionLogItem(
            itemComposition.getId(),
            itemComposition.getMembersName(),
            0,
            false,
            sequence
        );
    }
}

package com.evansloan.collectionlog;

import com.evansloan.collectionlog.util.CollectionLogDeserializer;
import com.evansloan.collectionlog.util.CollectionLogSerializer;
import com.evansloan.collectionlog.util.JsonUtils;
import com.evansloan.collectionlog.util.UserSettingsDeserializer;
import com.google.common.collect.ImmutableList;
import com.google.common.collect.ImmutableMap;
import com.google.gson.JsonObject;
import java.io.File;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.Collections;
import java.util.Date;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import javax.inject.Inject;
import javax.inject.Singleton;
import lombok.Getter;
import lombok.Setter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.EnumComposition;
import net.runelite.api.ItemComposition;
import net.runelite.api.StructComposition;
import static net.runelite.client.RuneLite.RUNELITE_DIR;
import net.runelite.client.game.ItemManager;
import net.runelite.client.game.ItemStack;
import org.apache.commons.lang3.RandomUtils;

@Slf4j
@Singleton
public class CollectionLogManager
{
	private static final List<Integer> COLLECTION_LOG_TAB_STRUCT_IDS = ImmutableList.of(
		471, // Bosses
		472, // Raids
		473, // Clues
		474, // Minigames
		475  // Other
	);
	private static final List<Integer> COLLECTION_LOG_TAB_ENUM_IDS = ImmutableList.of(2103, 2104, 2105, 2106, 2107);
	private static final int COLLECTION_LOG_TAB_NAME_PARAM_ID = 682;
	private static final int COLLECTION_LOG_TAB_ENUM_PARAM_ID = 683;
	private static final int COLLECTION_LOG_PAGE_NAME_PARAM_ID = 689;
	private static final int COLLECTION_LOG_PAGE_ITEMS_ENUM_PARAM_ID = 690;
	private static final int COLLECTION_LOG_KILL_COUNT_SCRIPT_ID = 2735;

	private static final int COLLECTION_LOG_UNIQUE_OBTAINED_VARP_ID = 2943;
	private static final int COLLECTION_LOG_UNIQUE_ITEMS_VARP_ID = 2944;

	private static final File COLLECTION_LOG_DIR = new File(RUNELITE_DIR, "collectionlog");
	private static final File COLLECTION_LOG_SAVE_DATA_DIR = new File(COLLECTION_LOG_DIR, "data");
	private static final File COLLECTION_LOG_EXPORT_DIR = new File(COLLECTION_LOG_DIR, "exports");
	private static final Pattern COLLECTION_LOG_FILE_PATTERN = Pattern.compile("collectionlog-([\\w\\s-]+).json");

	/*
	 * Map of item IDs that differ in page items struct vs ID on item widget in the collection log
	 * Both IDs are valid, but causes duplicates on site
	 *
	 * Key: Page struct item ID
	 * Value: Item widget item ID
	 */
	private static final Map<Integer, Integer> ITEM_ID_MAP = new ImmutableMap.Builder<Integer, Integer>()
		.put(10859, 25617) // Tea flask
		.put(10877, 25618) // Red satchel
		.put(10878, 25619) // Green satchel
		.put(10879, 25620) // Red satchel
		.put(10880, 25621) // Black satchel
		.put(10881, 25622) // Gold satchel
		.put(10882, 25623) // Rune satchel
		.put(13273, 25624) // Unsired
		.put(12019, 25627) // Coal bag
		.put(12020, 25628) // Gem bag
		.put(24882, 25629) // Plank sack
		.put(12854, 25630) // Flamtaer bag
		.build();

	private final Map<String, CollectionLog> loadedCollectionLogs = new HashMap<>();

	@Setter
	private String username;

	@Getter
	private boolean isInitialized;

	@Getter
	private CollectionLog collectionLog;

	@Getter
	@Setter
	private UserSettings userSettings = new UserSettings();

	@Inject
	private Client client;

	@Inject
	private ItemManager itemManager;

	@Inject
	private JsonUtils jsonUtils;


	/**
	 * Init CollectionLog object with all items in the collection log. Does not include quantity or obtained status.
	 * Based off cs2 scripts
	 * <a href="https://github.com/Joshua-F/cs2-scripts/blob/master/scripts/%5Bproc,collection_draw_list%5D.cs2">2731 proc_collection_draw_list</a>
	 * and
	 * <a href="https://github.com/Joshua-F/cs2-scripts/blob/master/scripts/%5Bproc,collection_draw_log%5D.cs2">2732 proc_collection_draw_log</a>
	 * If a user has previously clicked through the collection log with the plugin installed,
	 * obtained and quantity will be set for each item if item exists in local save file.
	 */
	public void initCollectionLog()
	{
		CollectionLog saveFileCollectionLog = loadedCollectionLogs.get(username);
		boolean saveDataExists = saveFileCollectionLog != null;

		int totalObtained = 0;
		int totalItems = 0;
		Map<String, CollectionLogTab> collectionLogTabs = new HashMap<>();

		for (Integer structId : COLLECTION_LOG_TAB_STRUCT_IDS)
		{
			StructComposition tabStruct = client.getStructComposition(structId);
			String tabName = tabStruct.getStringValue(COLLECTION_LOG_TAB_NAME_PARAM_ID);
			int tabEnumId = tabStruct.getIntValue(COLLECTION_LOG_TAB_ENUM_PARAM_ID);
			EnumComposition tabEnum = client.getEnum(tabEnumId);

			Map<String, CollectionLogPage> collectionLogPages = new HashMap<>();
			for (Integer pageStructId : tabEnum.getIntVals())
			{
				StructComposition pageStruct = client.getStructComposition(pageStructId);
				String pageName = pageStruct.getStringValue(COLLECTION_LOG_PAGE_NAME_PARAM_ID);
				int pageItemsEnumId = pageStruct.getIntValue(COLLECTION_LOG_PAGE_ITEMS_ENUM_PARAM_ID);
				EnumComposition pageItemsEnum = client.getEnum(pageItemsEnumId);

				List<CollectionLogItem> pageItems = new ArrayList<>();
				List<CollectionLogKillCount> pageKillCounts = new ArrayList<>();

				CollectionLogPage saveFilePage = null;
				if (saveDataExists)
				{
					saveFilePage = saveFileCollectionLog.searchForPage(pageName);
				}

				for (Integer pageItemId : pageItemsEnum.getIntVals())
				{
					ItemComposition itemComposition = itemManager.getItemComposition(pageItemId);
					CollectionLogItem item = CollectionLogItem.fromItemComposition(itemComposition, pageItems.size());

					if (ITEM_ID_MAP.containsKey(item.getId()))
					{
						item.setId(ITEM_ID_MAP.get(item.getId()));
					}

					if (saveDataExists && saveFilePage != null)
					{
						CollectionLogItem saveFileItem = saveFilePage.getItemById(item.getId());
						if (saveFileItem != null)
						{
							item.setQuantity(saveFileItem.getQuantity());
							item.setObtained(saveFileItem.isObtained());
						}
					}

					pageItems.add(item);
					totalItems += 1;
					if (item.isObtained())
					{
						totalObtained += 1;
					}
				}

				/*
				 * Run script to get available kill count names. Amounts are set in var2048 which isn't set unless
				 * pages are manually opened in-game. Override amounts with 0 or previously saved amounts.
				 *
				 * https://github.com/Joshua-F/cs2-scripts/blob/master/scripts/%5Bproc,collection_category_count%5D.cs2
				 */
				client.runScript(COLLECTION_LOG_KILL_COUNT_SCRIPT_ID, pageStruct.getId());
				List<String> killCountStrings = new ArrayList<>(
					Arrays.asList(Arrays.copyOfRange(client.getStringStack(), 0, 3))
				);
				Collections.reverse(killCountStrings);

				for (String killCountString : killCountStrings)
				{
					if (killCountString.isEmpty())
					{
						continue;
					}
					CollectionLogKillCount killCount = CollectionLogKillCount.fromString(killCountString, pageKillCounts.size());

					int killCountAmount = 0;
					if (saveFilePage != null)
					{
						CollectionLogKillCount saveFileKc = saveFilePage.getKillCountByName(killCount.getName());
						if (saveFileKc != null)
						{
							killCountAmount = saveFileKc.getAmount();
						}
					}

					killCount.setAmount(killCountAmount);
					pageKillCounts.add(killCount);
				}

				boolean isUpdated = saveFilePage != null && saveFilePage.isUpdated();
				CollectionLogPage collectionLogPage = new CollectionLogPage(pageName, pageItems, pageKillCounts, isUpdated);

				collectionLogPages.put(pageName, collectionLogPage);
			}

			collectionLogTabs.put(tabName, new CollectionLogTab(tabName, collectionLogPages));
		}

		collectionLog = new CollectionLog(
			username,
			totalObtained,
			totalItems,
			client.getVarpValue(COLLECTION_LOG_UNIQUE_OBTAINED_VARP_ID),
			client.getVarpValue(COLLECTION_LOG_UNIQUE_ITEMS_VARP_ID),
			collectionLogTabs
		);

		isInitialized = true;
	}

	private String getDataFilePath(String fileName)
	{
		File directory = new File(COLLECTION_LOG_SAVE_DATA_DIR + File.separator + username);
		directory.mkdirs();
		return directory + File.separator + fileName;
	}

	public String getCollectionLogFilePath()
	{
		String fileName = "collectionlog-" + username + ".json";
		return getDataFilePath(fileName);
	}

	public String getUserSettingsFilePath()
	{
		String fileName = "settings-" + username + ".json"; // TODO: Username is null here
		return getDataFilePath(fileName);
	}

	public String getExportFilePath()
	{
		File directory = COLLECTION_LOG_EXPORT_DIR;
		String exportDate = new SimpleDateFormat("yyyyMMdd'T'HHmmss").format(new Date());
		String fileName = exportDate + "-collectionlog-" + username + ".json";

		directory.mkdir();
		return directory + File.separator + fileName;
	}

	public void loadCollectionLogFiles(File directory)
	{
		if (!directory.exists())
		{
			return;
		}

		File[] files = directory.listFiles();
		if (files == null)
		{
			return;
		}

		for (File file : files)
		{
			Matcher matcher = COLLECTION_LOG_FILE_PATTERN.matcher(file.getName());
			if (!matcher.matches())
			{
				continue;
			}

			String fileUsername = matcher.group(1);
			CollectionLog loadedCollectionLog = jsonUtils.readJsonFile(file.getPath(), CollectionLog.class, new CollectionLogDeserializer());
			loadedCollectionLogs.put(fileUsername, loadedCollectionLog);
		}
	}

	public void loadCollectionLogFiles() {
		if (!COLLECTION_LOG_SAVE_DATA_DIR.exists() || !COLLECTION_LOG_SAVE_DATA_DIR.isDirectory()) {
			log.error("Directory: \"" + COLLECTION_LOG_DIR.getPath() + "\" does not exist");
			return;
		}

		File[] userDirectories = COLLECTION_LOG_SAVE_DATA_DIR.listFiles();
		if (userDirectories == null) {
			log.warn("No collection logs have been found");
			return;
		}

		for (File userDirectory : userDirectories) {
			loadCollectionLogFiles(userDirectory);
		}
	}

	public UserSettings loadUserSettingsFile()
	{
		return jsonUtils.readJsonFile(getUserSettingsFilePath(), UserSettings.class, new UserSettingsDeserializer());
	}

	public boolean saveCollectionLogFile(boolean isExport)
	{
		String filePath = getCollectionLogFilePath();
		if (isExport)
		{
			filePath = getExportFilePath();
		}

		boolean isSaved = jsonUtils.writeJsonFile(filePath, collectionLog, new CollectionLogSerializer());
		if (isSaved)
		{
			loadedCollectionLogs.put(username, collectionLog);
		}

		return isSaved;
	}

	public boolean saveUserSettingsFile()
	{
		return jsonUtils.writeJsonFile(getUserSettingsFilePath(), userSettings);
	}

	/**
	 * Deletes saved collection log data for the current user
	 */
	public void deleteSaveFile()
	{
		String filePath = getCollectionLogFilePath();
		File savedData = new File(filePath);
		if (!savedData.delete())
		{
			log.error("Unable to delete collection log save file: " + filePath);
			return;
		}

		loadedCollectionLogs.remove(username);
		isInitialized = false;
		collectionLog = null;
	}

	public void reset()
	{
		collectionLog = null;
		isInitialized = false;
		username = null;
		userSettings = new UserSettings();
	}

	public void updateUniqueCounts()
	{
		collectionLog.setUniqueObtained(client.getVarpValue(COLLECTION_LOG_UNIQUE_OBTAINED_VARP_ID));
		collectionLog.setUniqueItems(client.getVarpValue(COLLECTION_LOG_UNIQUE_ITEMS_VARP_ID));
	}

	/**
	 * Updates the total amount of items in the collection log
	 */
	public void updateTotalItems()
	{
		int newTotal = 0;
		for (CollectionLogTab tab : collectionLog.getTabs().values())
		{
			Collection<CollectionLogPage> pages = tab.getPages().values();
			newTotal += pages.stream().mapToInt(page -> page.getItems().size()).sum();
		}

		if (newTotal > collectionLog.getTotalItems())
		{
			collectionLog.setTotalItems(newTotal);
		}
	}

	public CollectionLogTab getTabByName(String tabName)
	{
		return collectionLog.getTabs().get(tabName);
	}

	public CollectionLogPage getPageByName(String pageName)
	{
		return collectionLog.searchForPage(pageName);
	}

	public boolean updateObtainedItem(ItemStack itemStack)
	{
		if (!isInitialized)
		{
			return false;
		}

		boolean itemUpdated = false;
		for (CollectionLogTab tab : collectionLog.getTabs().values())
		{
			for (CollectionLogPage page : tab.getPages().values())
			{
				CollectionLogItem existingItem = page.getItemById(itemStack.getId());
				if (existingItem == null)
				{
					continue;
				}

				itemUpdated = true;
				existingItem.setQuantity(existingItem.getQuantity() + itemStack.getQuantity());
				existingItem.setObtained(true);

				collectionLog.setTotalObtained(collectionLog.getTotalObtained() + 1);
			}
		}

		if (itemUpdated)
		{
			collectionLog.setUniqueObtained(collectionLog.getUniqueObtained() + 1);
		}

		return false;
	}

	public JsonObject getCollectionLogJsonObject()
	{
		return jsonUtils.toJsonObject(collectionLog, new CollectionLogSerializer());
	}

	public JsonObject getUserSettingsJsonObject()
	{
		return jsonUtils.toJsonObject(userSettings);
	}

	public CollectionLogItem getRandomItem()
	{
		if (!isInitialized())
		{
			return null;
		}

		int totalMissing = Math.min(collectionLog.getUniqueItems() - collectionLog.getTotalObtained(), 16);
		List<CollectionLogItem> items = new ArrayList<>(totalMissing);

		for (Map.Entry<String, CollectionLogTab> entry : collectionLog.getTabs().entrySet())
		{
			CollectionLogTab collectionLogTab = entry.getValue();
			for (CollectionLogPage page : collectionLogTab.getPages().values())
			{
				List<CollectionLogItem> pageItems = page.applyItemFilter(CollectionLogPage.ITEM_FILTER_MISSING);
				items.addAll(pageItems);
			}
		}

		int index = RandomUtils.nextInt(0, items.size() - 1);
		return items.get(index);
	}
}

package com.evansloan.collectionlog;

import java.util.Arrays;
import java.util.EnumSet;
import lombok.AllArgsConstructor;
import lombok.Getter;

@Getter
@AllArgsConstructor
public enum AccountType
{
	NORMAL(0),
	IRONMAN(1),
	ULTIMATE_IRONMAN(2),
	HARDCORE_IRONMAN(3),
	GROUP_IRONMAN(4),
	HARDCORE_GROUP_IRONMAN(5),
	UNRANKED_GROUP_IRONMAN(6),
	ALL(100);

	private final int accountTypeVar;

	public static AccountType valueOf(int accountTypeVar)
	{
		return Arrays.stream(values())
			.filter(accountType -> accountTypeVar == accountType.accountTypeVar)
			.findFirst()
			.orElse(null);
	}

	/**
	 * Returns an EnumSet of AccountType values based on the specified accountType varbit value.
	 *
	 * @param accountType The account type to match
	 * @return An EnumSet of AccountType values that match the specified accountType varbit value
	 */
	public static EnumSet<AccountType> getAllAccountTypes(int accountType)
	{
		EnumSet<AccountType> accountTypes = EnumSet.of(
			ALL,
			valueOf(accountType)
		);

		if (isInRange(accountType, IRONMAN, HARDCORE_IRONMAN))
		{
			accountTypes.add(IRONMAN);
		}

		if (isInRange(accountType, GROUP_IRONMAN, HARDCORE_GROUP_IRONMAN))
		{
			accountTypes.add(GROUP_IRONMAN);
		}

		return accountTypes;
	}

	private static boolean isInRange(int accountType, AccountType min, AccountType max)
	{
		return accountType >= min.accountTypeVar && accountType <= max.accountTypeVar;
	}
}

package com.evansloan.collectionlog;

import lombok.AllArgsConstructor;
import lombok.Getter;
import java.util.Map;

@AllArgsConstructor
public class CollectionLogTab
{
    @Getter
    private final String name;

    @Getter
    private final Map<String, CollectionLogPage> pages;

    public boolean containsPage(String pageName)
    {
        return pages.containsKey(pageName);
    }
}

package com.evansloan.collectionlog;

import com.evansloan.collectionlog.ui.Icon;
import com.evansloan.collectionlog.util.CollectionLogDeserializer;
import com.evansloan.collectionlog.util.JsonUtils;
import com.google.common.collect.HashMultiset;
import com.google.common.collect.ImmutableList;
import com.google.common.collect.Multiset;
import com.google.common.collect.Multisets;
import com.google.gson.JsonObject;
import com.google.inject.Provides;
import java.awt.Color;
import java.awt.image.BufferedImage;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.concurrent.ScheduledExecutorService;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.stream.Collectors;
import javax.inject.Inject;
import lombok.Getter;
import lombok.NonNull;
import lombok.Setter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.ChatMessageType;
import net.runelite.api.Client;
import net.runelite.api.GameState;
import net.runelite.api.IndexedSprite;
import net.runelite.api.InventoryID;
import net.runelite.api.ItemComposition;
import net.runelite.api.ItemContainer;
import net.runelite.api.MenuAction;
import net.runelite.api.MenuEntry;
import net.runelite.api.Player;
import net.runelite.api.ScriptID;
import net.runelite.api.Varbits;
import net.runelite.api.WorldType;
import net.runelite.api.events.ChatMessage;
import net.runelite.api.events.GameStateChanged;
import net.runelite.api.events.GameTick;
import net.runelite.api.events.ItemContainerChanged;
import net.runelite.api.events.MenuOpened;
import net.runelite.api.events.ScriptPostFired;
import net.runelite.api.events.WidgetLoaded;
import net.runelite.api.widgets.ComponentID;
import net.runelite.api.widgets.InterfaceID;
import net.runelite.api.widgets.ItemQuantityMode;
import net.runelite.api.widgets.Widget;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.chat.ChatColorType;
import net.runelite.client.chat.ChatCommandManager;
import net.runelite.client.chat.ChatMessageBuilder;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.chat.QueuedMessage;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.events.ConfigChanged;
import net.runelite.client.game.ItemManager;
import net.runelite.client.game.ItemStack;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.plugins.PluginDescriptor;
import net.runelite.client.plugins.loottracker.LootReceived;
import net.runelite.client.ui.ClientToolbar;
import net.runelite.client.ui.NavigationButton;
import net.runelite.client.util.ImageUtil;
import net.runelite.client.util.Text;
import static net.runelite.client.util.Text.removeTags;
import okhttp3.Call;
import okhttp3.Callback;
import okhttp3.Response;

@Slf4j
@PluginDescriptor(
	name = "Collection Log",
	description = "Share your collection log progress on collectionlog.net",
	tags = {"collection", "log"}
)
public class CollectionLogPlugin extends Plugin
{
	private static final String CONFIG_GROUP = "collectionlog";
	private static final String CONFIG_SHOW_PANEL = "show_collection_log_panel";

	private static final int COLLECTION_LOG_CONTAINER = 1;
	private static final int COLLECTION_LOG_ACTIVE_TAB_VARBIT_ID = 6905;
	private static final int COLLECTION_LOG_ACTIVE_PAGE_VARBIT_ID = 6906;
	private static final int COLLECTION_LOG_COMPLETED_PAGE_COLOR = 901389;

	private static final String COLLECTION_LOG_TITLE = "Collection Log";
	private static final Pattern COLLECTION_LOG_ITEM_REGEX = Pattern.compile("New item added to your collection log: (.*)");
	private static final String COLLECTION_LOG_TARGET = "collection log";
	private static final int COLLECTION_LOG_TARGET_INDEX = 2;
	private static final String COLLECTION_LOG_EXPORT = "Export";
	private static final String COLLECTION_LOG_COMMAND_STRING = "!log";
	private static final List<String> COLLECTION_LOG_COMMAND_FILTERS = ImmutableList.of("missing", "obtained", "dupes");
	private static final Pattern COLLECTION_LOG_COMMAND_PATTERN = Pattern.compile("!log\\s*(" + String.join("|", COLLECTION_LOG_COMMAND_FILTERS) + ")?\\s*([\\w\\s]+)?", Pattern.CASE_INSENSITIVE);

	private static final int ADVENTURE_LOG_COLLECTION_LOG_SELECTED_VARBIT_ID = 12061;
	private static final Pattern ADVENTURE_LOG_TITLE_PATTERN = Pattern.compile("The Exploits of (.+)");

	private CollectionLogPanel collectionLogPanel;
	private NavigationButton navigationButton;

	@Setter
	private boolean isCollectionLogDeleted = false;
	private boolean isUserLoggedIn = false;
	private boolean userSettingsLoaded = false;
	private boolean isPohOwner = false;

	private String obtainedItemName;
	private Multiset<Integer> inventoryItems;
	private Map<Integer, Integer> loadedCollectionLogIcons;

	@Getter
	@Inject
	private Client client;

	@Inject
	private ClientThread clientThread;

	@Inject
	private ChatMessageManager chatMessageManager;

	@Inject
	private ChatCommandManager chatCommandManager;

	@Inject
	private ClientToolbar clientToolbar;

	@Inject
	private ConfigManager configManager;

	@Inject
	private CollectionLogConfig config;

	@Inject
	private ScheduledExecutorService executor;

	@Inject
	private ItemManager itemManager;

	@Inject
	private CollectionLogApiClient apiClient;

	@Inject
	private CollectionLogManager collectionLogManager;

	@Inject
	private JsonUtils jsonUtils;

	@Provides
	CollectionLogConfig provideConfig(ConfigManager configManager)
	{
		return configManager.getConfig(CollectionLogConfig.class);
	}

	@Override
	protected void startUp()
	{
		if (client.getGameState() == GameState.LOGGED_IN)
		{
			isUserLoggedIn = true;
			unsetOldConfigs();
		}

		initPanel();
		if (config.showCollectionLogSidePanel())
		{
			clientToolbar.addNavigation(navigationButton);
		}

		// Load all save files up front on executor thread to mitigate lag on log open
		executor.submit(() -> collectionLogManager.loadCollectionLogFiles());

		loadedCollectionLogIcons = new HashMap<>();
		chatCommandManager.registerCommandAsync(COLLECTION_LOG_COMMAND_STRING, this::collectionLogLookup);
	}

	@Override
	protected void shutDown()
	{
		destroyPanel();
		chatCommandManager.unregisterCommand(COLLECTION_LOG_COMMAND_STRING);
		loadedCollectionLogIcons.clear();
	}

	private void initPanel()
	{
		collectionLogPanel = new CollectionLogPanel(this, collectionLogManager, clientThread, config, itemManager);
		collectionLogPanel.create(client.getGameState());

		if (navigationButton == null)
		{
			final BufferedImage navigationButtonIcon = Icon.COLLECTION_LOG_TOOLBAR.getImage();
			navigationButton = NavigationButton.builder()
				.tooltip(COLLECTION_LOG_TITLE)
				.icon(navigationButtonIcon)
				.panel(collectionLogPanel)
				.priority(10)
				.build();
		}
	}

	private void destroyPanel()
	{
		collectionLogPanel = null;
		clientToolbar.removeNavigation(navigationButton);
	}

	@Subscribe
	public void onConfigChanged(ConfigChanged configChanged)
	{
		if (!configChanged.getGroup().equals(CONFIG_GROUP))
		{
			return;
		}

		if (configChanged.getKey().equals(CONFIG_SHOW_PANEL))
		{
			clientToolbar.removeNavigation(navigationButton);
			if (config.showCollectionLogSidePanel())
			{
				clientToolbar.addNavigation(navigationButton);
			}
		}

		collectionLogPanel.onConfigChanged(configChanged);
	}

	@Subscribe
	public void onGameStateChanged(GameStateChanged gameStateChanged)
	{
		if (!isValidWorldType())
		{
			return;
		}

		GameState gameState = gameStateChanged.getGameState();

		if (gameState == GameState.LOGGED_IN)
		{
			isUserLoggedIn = true;
			collectionLogPanel.setStatus("", false, true);

			unsetOldConfigs();
		}

		if (gameState == GameState.LOGIN_SCREEN ||
			gameState == GameState.HOPPING)
		{
			saveCollectionLogData();
			collectionLogManager.reset();
			resetFlags();
		}
		collectionLogPanel.onGameStateChanged(gameStateChanged);
	}

	@Subscribe
	public void onGameTick(GameTick gameTick)
	{
		if (userSettingsLoaded)
		{
			return;
		}

		if (!isUserLoggedIn)
		{
			return;
		}

		collectionLogManager.setUsername(client.getLocalPlayer().getName());

		executor.execute(() -> {
			UserSettings userSettings = collectionLogManager.loadUserSettingsFile();
			if (userSettings == null)
			{
				userSettings = new UserSettings();
			}
			collectionLogManager.setUserSettings(userSettings);
			collectionLogPanel.setUserSettings(userSettings);
		});

		userSettingsLoaded = true;
	}

	@Subscribe
	public void onScriptPostFired(ScriptPostFired scriptPostFired)
	{
		if (scriptPostFired.getScriptId() == ScriptID.COLLECTION_DRAW_LIST)
		{
			clientThread.invokeLater(this::getPage);
		}
	}

	@Subscribe
	public void onMenuOpened(MenuOpened event)
	{
		if (event.getMenuEntries().length < 2)
		{
			return;
		}

		MenuEntry entry = event.getMenuEntries()[COLLECTION_LOG_TARGET_INDEX];

		String entryTarget = entry.getTarget();
		if (entryTarget.isEmpty())
		{
			entryTarget = entry.getOption();
		}

		if (!removeTags(entryTarget).toLowerCase().endsWith(COLLECTION_LOG_TARGET))
		{
			return;
		}

		client.getMenu().createMenuEntry(1)
			.setOption(COLLECTION_LOG_EXPORT)
			.setTarget(entryTarget)
			.setType(MenuAction.RUNELITE)
			.onClick(e -> {
				boolean collectionLogSaved = collectionLogManager.saveCollectionLogFile(true);
				if (collectionLogSaved)
				{
					String filePath = collectionLogManager.getExportFilePath();
					String message = "Collection log exported to " + filePath;

					if (config.sendExportChatMessage())
					{
						String chatMessage = new ChatMessageBuilder()
							.append(ChatColorType.HIGHLIGHT)
							.append(message)
							.build();

						chatMessageManager.queue(
							QueuedMessage.builder()
								.type(ChatMessageType.CONSOLE)
								.runeLiteFormattedMessage(chatMessage)
								.build()
						);
					}
				}
			});
	}

	@Subscribe
	public void onWidgetLoaded(WidgetLoaded widgetLoaded)
	{
		if (!isValidWorldType())
		{
			return;
		}

		if (widgetLoaded.getGroupId() == InterfaceID.ADVENTURE_LOG)
		{
			Widget adventureLog = client.getWidget(ComponentID.ADVENTURE_LOG_CONTAINER);
			if (adventureLog == null)
			{
				return;
			}

			// Children are rendered on tick after widget load. Invoke later to prevent null children on adventure log widget
			clientThread.invokeLater(() -> {
				Matcher adventureLogUser = ADVENTURE_LOG_TITLE_PATTERN.matcher(adventureLog.getChild(1).getText());
				if (adventureLogUser.find())
				{
					isPohOwner = adventureLogUser.group(1).equals(client.getLocalPlayer().getName());
				}
			});
		}

		if (widgetLoaded.getGroupId() == InterfaceID.COLLECTION_LOG)
		{
			if (!collectionLogManager.isInitialized())
			{
				collectionLogManager.initCollectionLog();
			}
			collectionLogManager.updateUniqueCounts();
		}
	}

	@Subscribe
	public void onLootReceived(LootReceived lootReceived)
	{
		if (obtainedItemName == null)
		{
			inventoryItems = null;
			return;
		}

		ItemStack obtainedItem = null;
		Collection<ItemStack> items = lootReceived.getItems();
		for (ItemStack item : items)
		{
			ItemComposition itemComp = itemManager.getItemComposition(item.getId());
			if (itemComp.getName().equals(obtainedItemName))
			{
				obtainedItem = item;
			}
		}

		if (obtainedItem == null)
		{
			obtainedItemName = null;
			inventoryItems = null;
			return;
		}

		updateObtainedItem(obtainedItem);
	}

	@Subscribe
	public void onChatMessage(ChatMessage chatMessage)
	{
		if (chatMessage.getType() != ChatMessageType.GAMEMESSAGE)
		{
			return;
		}

		Matcher m = COLLECTION_LOG_ITEM_REGEX.matcher(chatMessage.getMessage());
		if (!m.matches())
		{
			return;
		}

		obtainedItemName = removeTags(m.group(1));

		ItemContainer inventory = client.getItemContainer(InventoryID.INVENTORY);
		if (inventory == null)
		{
			obtainedItemName = null;
			inventoryItems = null;
			return;
		}

		// Get inventory prior to onItemContainerChanged event
		Arrays.stream(inventory.getItems())
			.forEach(item -> inventoryItems.add(item.getId(), item.getQuantity()));

		// Defer to onItemContainerChanged or onLootReceived
	}

	@Subscribe
	private void onItemContainerChanged(ItemContainerChanged itemContainerChanged)
	{
		if (itemContainerChanged.getContainerId() != InventoryID.INVENTORY.getId())
		{
			return;
		}

		if (obtainedItemName == null)
		{
			inventoryItems = HashMultiset.create();
			return;
		}

		if (inventoryItems == null)
		{
			inventoryItems = HashMultiset.create();
		}

		// Need to build a diff of inventory items prior to item appearing in inventory and current inventory items
		// Necessary to find item that may have non-unique name (Ancient page, decorative armor) that
		// may already be in inventory
		ItemContainer inventory = itemContainerChanged.getItemContainer();
		Multiset<Integer> currentInventoryItems = HashMultiset.create();
		Arrays.stream(inventory.getItems())
			.forEach(item -> currentInventoryItems.add(item.getId(), item.getQuantity()));
		Multiset<Integer> invDiff = Multisets.difference(currentInventoryItems, inventoryItems);

		ItemStack obtainedItemStack = null;
		for (Multiset.Entry<Integer> item : invDiff.entrySet())
		{
			ItemComposition itemComp = itemManager.getItemComposition(item.getElement());
			if (itemComp.getName().equals(obtainedItemName))
			{
				obtainedItemStack = new ItemStack(
					item.getElement(),
					item.getCount()
				);

				break;
			}
		}

		if (obtainedItemStack == null)
		{
			// Opening clue casket triggers onItemContainerChanged event before clue items
			// appear in inventory. Fall through to onLootReceived to find obtained item(s)
			if (client.getWidget(ComponentID.CLUESCROLL_REWARD_ITEM_CONTAINER) != null)
			{
				return;
			}

			obtainedItemName = null;
			inventoryItems = HashMultiset.create();
			return;
		}

		updateObtainedItem(obtainedItemStack);
	}

	/**
	 * Save collection log data to a file or upload to
	 * collectionlog.net
	 */
	public void saveCollectionLogData()
	{
		if (!collectionLogManager.isInitialized())
		{
			collectionLogPanel.setStatus(
				"Unable to save collection log, please open the collection log in game and try again.",
				true,
				true
			);
			return;
		}

		if (!isValidWorldType())
		{
			collectionLogPanel.setStatus(
				"Unable to save collection log, please log in to a normal free to play or members world and try again",
				true,
				true
			);
			return;
		}

		if (isCollectionLogDeleted)
		{
			return;
		}

		boolean isSaved = collectionLogManager.saveCollectionLogFile(false);
		isSaved = isSaved && collectionLogManager.saveUserSettingsFile();
		String statusMessage = isSaved ? null : "Unable to save collection log data. Check Runelite logs for full error.";
		collectionLogPanel.setStatus(statusMessage, isSaved, !config.allowApiConnections());

		if (!config.allowApiConnections() || !isSaved)
		{
			return;
		}

		if (client.getAccountHash() == -1)
		{
			return;
		}

		Player localPlayer = client.getLocalPlayer();
		String username = localPlayer.getName();
		String accountHash = String.valueOf(client.getAccountHash());
		String accountType = AccountType.valueOf(client.getVarbitValue(Varbits.ACCOUNT_TYPE)).toString();

		// Used to display proper farming outfit on site
		boolean isFemale = localPlayer.getPlayerComposition().getGender() == 1;

		JsonObject collectionLogJson = collectionLogManager.getCollectionLogJsonObject();
		JsonObject userSettingsJson = collectionLogManager.getUserSettingsJsonObject();

		uploadCollectionLog(username, accountType, accountHash, isFemale, userSettingsJson, collectionLogJson);
	}

	/**
	 * Retrieves and updates all items in the given entry
	 *
	 * @param pageHead Collection log entry to update
	 */
	private void updatePage(Widget pageHead, CollectionLogPage pageToUpdate)
	{
		Widget itemsContainer = client.getWidget(ComponentID.COLLECTION_LOG_ENTRY_ITEMS);
		if (itemsContainer == null)
		{
			return;
		}

		List<CollectionLogItem> items = pageToUpdate.getItems();
		items.clear();

		Widget[] widgetItems = itemsContainer.getDynamicChildren();
		for (Widget widgetItem : widgetItems)
		{
			String itemName = itemManager.getItemComposition(widgetItem.getItemId()).getMembersName();
			boolean isObtained = widgetItem.getOpacity() == 0;
			int quantity = isObtained ? widgetItem.getItemQuantity() : 0;

			items.add(new CollectionLogItem(
				widgetItem.getItemId(),
				itemName,
				quantity,
				isObtained,
				items.size()
			));

			if (config.showQuantityForAllObtainedItems() && quantity > 0)
			{
				widgetItem.setItemQuantityMode(ItemQuantityMode.ALWAYS);
			}
		}

		Widget[] children = pageHead.getDynamicChildren();
		if (children.length < 3)
		{
			// Page does not have kill count widgets, mark as updated and early return
			pageToUpdate.setUpdated(true);
			return;
		}

		List<CollectionLogKillCount> killCounts = pageToUpdate.getKillCounts();
		killCounts.clear();

		Widget[] killCountWidgets = Arrays.copyOfRange(children, 2, children.length);
		for (Widget killCountWidget : killCountWidgets)
		{
			String killCountString = killCountWidget.getText();
			CollectionLogKillCount killCount = CollectionLogKillCount.fromString(killCountString, killCounts.size());
			killCounts.add(killCount);
		}

		pageToUpdate.setUpdated(true);
	}

	/**
	 * Load the current page being viewed in the collection log
	 * and get/update relevant information contained in the page
	 */
	private void getPage()
	{
		if (!isValidWorldType())
		{
			return;
		}

		boolean openedFromAdventureLog = client.getVarbitValue(ADVENTURE_LOG_COLLECTION_LOG_SELECTED_VARBIT_ID) != 0;
		if (openedFromAdventureLog && !isPohOwner)
		{
			return;
		}

		Widget activeTab = getActiveTab();
		if (activeTab == null)
		{
			return;
		}

		String activeTabName = removeTags(activeTab.getName());
		CollectionLogTab collectionLogTab = collectionLogManager.getTabByName(activeTabName);
		if (collectionLogTab == null)
		{
			return;
		}

		Widget pageHead = client.getWidget(ComponentID.COLLECTION_LOG_ENTRY_HEADER);
		if (pageHead == null)
		{
			return;
		}

		String pageTitle = pageHead.getDynamicChildren()[0].getText();
		if (!collectionLogTab.containsPage(pageTitle))
		{
			return;
		}

		CollectionLogPage pageToUpdate = collectionLogManager.getPageByName(pageTitle);
		if (pageToUpdate == null)
		{
			return;
		}

		int prevObtainedItemCount = pageToUpdate.getObtainedItemCount();

		updatePage(pageHead, pageToUpdate);

		int newObtainedItemCount = pageToUpdate.getObtainedItemCount();

		if (collectionLogManager.getTabByName(activeTabName) != null)
		{
			// Can happen when entries are opened in quick succession
			// Item data in the widget doesn't load properly and obtained count shows as 0
			if (prevObtainedItemCount > newObtainedItemCount)
			{
				return;
			}
		}

		if (prevObtainedItemCount == newObtainedItemCount)
		{
			update();
			return;
		}

		CollectionLog collectionLog = collectionLogManager.getCollectionLog();

		int prevTotalObtained = collectionLog.getTotalObtained();
		int newTotalObtained = prevTotalObtained + (newObtainedItemCount - prevObtainedItemCount);
		collectionLog.setTotalObtained(newTotalObtained);

		update();
	}

	/**
	 * Update completed collection log entries with user specified color
	 */
	private void highlightPages()
	{
		Widget pageList = getActivePageList();
		if (pageList == null)
		{
			return;
		}

		Widget[] pageNameWidgets = pageList.getDynamicChildren();
		for (Widget pageNameWidget : pageNameWidgets)
		{
			String pageName = pageNameWidget.getText()
				.replace(" *", "");
			CollectionLogPage collectionLogPage = collectionLogManager.getPageByName(pageName);

			if (!collectionLogPage.isUpdated())
			{
				pageNameWidget.setText(pageName + " *");
			}

			Color pageNameColor = getPageNameColor(collectionLogPage, pageNameWidget);
			pageNameWidget.setTextColor(pageNameColor.getRGB());
		}
	}

	/**
	 * Get the current tab opened in the collection log
	 *
	 * @return Open collection log tab
	 */
	private Widget getActiveTab()
	{
		Widget tabsWidget = client.getWidget(ComponentID.COLLECTION_LOG_TABS);
		if (tabsWidget == null)
		{
			return null;
		}

		int tabIndex = client.getVarbitValue(COLLECTION_LOG_ACTIVE_TAB_VARBIT_ID);
		return tabsWidget.getStaticChildren()[tabIndex];
	}

	/**
	 * Get the current page list opened in the collection log
	 *
	 * @return Open collection log page list
	 */
	private Widget getActivePageList()
	{
		Widget tab = getActiveTab();
		if (tab == null)
		{
			return null;
		}

		String tabName = removeTags(tab.getName());
		int listIndex = CollectionLogList.valueOf(tabName.toUpperCase()).getListIndex();
		return client.getWidget(InterfaceID.COLLECTION_LOG, listIndex);
	}

	/**
	 * Get the appropriate page name highlight color based on configs/items obtained
	 *
	 * @param collectionLogPage Page to highlight
	 * @return Page name highlight color
	 */
	private Color getPageNameColor(CollectionLogPage collectionLogPage, Widget pageNameWidget)
	{
		Color pageNameColor = CollectionLogConfig.DEFAULT_ORANGE;
		int obtainedItemCount = collectionLogPage.getObtainedItemCount();

		if (obtainedItemCount == 0 && config.highlightIncompletePages())
		{
			pageNameColor = config.emptyHighlightColor();
		}
		if (obtainedItemCount > 0 && obtainedItemCount < collectionLogPage.getItems().size() && config.highlightIncompletePages())
		{
			pageNameColor = config.inProgressHighlightColor();
		}
		if (pageNameWidget.getTextColor() == COLLECTION_LOG_COMPLETED_PAGE_COLOR)
		{
			pageNameColor = config.highlightColor();
		}

		return pageNameColor;
	}

	/**
	 * Build the new title for the collection log containing unique/total counts
	 * or display counts as a percentage
	 *
	 * @return Collection log title
	 */
	private String buildTitle()
	{
		StringBuilder titleBuilder = new StringBuilder(COLLECTION_LOG_TITLE);
		List<String> titleSections = new ArrayList<>();

		boolean displayUnique = config.displayUniqueItems();
		boolean displayTotal = config.displayTotalItems();

		if (!collectionLogManager.isInitialized())
		{
			return "";
		}

		CollectionLog collectionLog = collectionLogManager.getCollectionLog();

		if (displayUnique)
		{
			int uniqueObtained = collectionLog.getUniqueObtained();
			int uniqueTotal = collectionLog.getUniqueItems();

			String prefix = displayTotal ? "U: " : "";
			String uniqueTitle = String.format("%s%d/%d", prefix, uniqueObtained, uniqueTotal);

			if (config.displayAsPercentage())
			{
				uniqueTitle = String.format("%s%.2f%%", prefix, ((double) uniqueObtained / uniqueTotal) * 100);
			}
			titleSections.add(uniqueTitle);
		}

		if (config.displayTotalItems())
		{
			int totalItemsObtained = collectionLog.getTotalObtained();
			int totalItems = collectionLog.getTotalItems();

			String prefix = displayUnique ? "T: " : "";
			String totalTitle = String.format("%s%d/%d", prefix, totalItemsObtained, totalItems);

			if (config.displayAsPercentage())
			{
				totalTitle = String.format("%s%.2f%%", prefix, ((double) totalItemsObtained / totalItems) * 100);
			}

			titleSections.add(totalTitle);
		}

		if (!titleSections.isEmpty())
		{
			titleBuilder.append(" - ");
		}
		titleBuilder.append(String.join(" ", titleSections));

		return titleBuilder.toString();
	}

	/**
	 * Update collection log title and highlight completed entries
	 */
	private void update()
	{
		collectionLogManager.updateTotalItems();
		setCollectionLogTitle();

		highlightPages();
	}

	private void setCollectionLogTitle()
	{
		String title = buildTitle();
		setCollectionLogTitle(title);
	}

	/**
	 * Updates the collection log title with updated counts
	 *
	 * @param title New collection log title value
	 */
	private void setCollectionLogTitle(String title)
	{
		Widget collectionLogTitleWidget = getCollectionLogTitle();
		if (collectionLogTitleWidget == null)
		{
			return;
		}
		collectionLogTitleWidget.setText(title);
	}

	private boolean isValidWorldType()
	{
		List<WorldType> invalidTypes = ImmutableList.of(
			WorldType.DEADMAN,
			WorldType.NOSAVE_MODE,
			WorldType.SEASONAL,
			WorldType.TOURNAMENT_WORLD
		);

		for (WorldType worldType : invalidTypes)
		{
			if (client.getWorldType().contains(worldType))
			{
				return false;
			}
		}

		return true;
	}

	/**
	 * Looks up and then replaces !log chat messages
	 *
	 * @param chatMessage The ChatMessage event
	 * @param message Text of the message
	 */
	private void collectionLogLookup(ChatMessage chatMessage, String message)
	{
		String localPlayerName = client.getLocalPlayer().getName();
		String username = Text.sanitize(chatMessage.getName());

		if (!config.allowApiConnections())
		{
			// When logged-in user triggers the command and doesn't allow API connections then give them an error
			if (username.equals(localPlayerName))
			{
				clientThread.invoke(() -> updateChatMessage(chatMessage, "Please allow collectionlog.net connections to use the command."));
			}
			return;
		}
		clientThread.invoke(() -> updateChatMessage(chatMessage, "Loading..."));

		// Because outgoing private messages display the recipient's name use the logged-in user instead
		if (chatMessage.getType().equals(ChatMessageType.PRIVATECHATOUT))
		{
			username = localPlayerName;
		}

		try
		{
			apiClient.getCollectionLog(username, new Callback()
			{
				@Override
				public void onFailure(@NonNull Call call, @NonNull IOException e)
				{
					log.error("Unable to resolve !log command: " + e.getMessage());
					clientThread.invoke(() -> updateChatMessage(chatMessage, "Failed to retrieve collection log data."));
				}

				@Override
				public void onResponse(@NonNull Call call, @NonNull Response response) throws IOException
				{
					JsonObject collectionLogJson = apiClient.processResponse(response);
					response.close();

					if (collectionLogJson == null)
					{
						clientThread.invoke(() -> updateChatMessage(chatMessage, "No Collection Log data found for user."));
						return;
					}

					CollectionLog collectionLog = jsonUtils.fromJsonObject(
						collectionLogJson.getAsJsonObject("collectionLog"),
						CollectionLog.class,
						new CollectionLogDeserializer()
					);
					clientThread.invoke(() -> replaceCommandMessage(chatMessage, message, collectionLog));
				}
			});
		}
		catch (IOException e)
		{
			log.error("Unable to resolve !log command: " + e.getMessage());
		}
	}

	/**
	 * Tries to parse the arguments from the message that triggered the command. Then uses the data from
	 * the passed collection log and the parsed arguments to build command's output message.
	 * Finally, updates the chat message with the output.
	 *
	 * @param chatMessage The ChatMessage event
	 * @param message Text of the message that triggered the command
	 * @param collectionLog Collection log data of the user triggering the command
	 */
	private void replaceCommandMessage(ChatMessage chatMessage, String message, CollectionLog collectionLog)
	{
		Matcher commandMatcher = COLLECTION_LOG_COMMAND_PATTERN.matcher(message);
		if (!commandMatcher.matches())
		{
			return;
		}
		String commandFilter = commandMatcher.group(1);
		String commandPage = commandMatcher.group(2);

		// Display the total unique items obtained when no page is specified
		if (commandPage == null)
		{
			String output = "Collection Log: " + collectionLog.getUniqueObtained() + "/" + collectionLog.getUniqueItems();
			updateChatMessage(chatMessage, output);
			return;
		}

		// Display a random collection log page for the keyword 'any'
		if (commandPage.equals("any"))
		{
			String output = buildCommandOutput(collectionLog.randomPage(), commandFilter);
			updateChatMessage(chatMessage, output);
			return;
		}

		String pageArgument = CollectionLogPage.aliasPageName(commandPage);
		CollectionLogPage collectionLogPage = collectionLog.searchForPage(pageArgument);

		// Display an error when no matching page could be found
		if (collectionLogPage == null)
		{
			updateChatMessage(chatMessage, "No Collection Log page found.");
			return;
		}

		// Display the found collection log page
		String output = buildCommandOutput(collectionLogPage, commandFilter);
		updateChatMessage(chatMessage, output);
	}

	/**
	 * Updates the passed chat message with the new text then rebuilds the chatbox.
	 *
	 * @param chatMessage Chat message to update
	 * @param text New text of the chat message
	 */
	private void updateChatMessage(ChatMessage chatMessage, String text)
	{
		chatMessage.getMessageNode().setValue(text);
		client.runScript(ScriptID.BUILD_CHATBOX);
	}

	/**
	 * Loads a list of Collection Log items into the client's mod icons.
	 *
	 * @param collectionLogItems List of items to load
	 */
	private void loadPageIcons(List<CollectionLogItem> collectionLogItems)
	{
		List<CollectionLogItem> itemsToLoad = collectionLogItems
			.stream()
			.filter(item -> !loadedCollectionLogIcons.containsKey(item.getId()))
			.collect(Collectors.toList());

		final IndexedSprite[] modIcons = client.getModIcons();

		final IndexedSprite[] newModIcons = Arrays.copyOf(modIcons, modIcons.length + itemsToLoad.size());
		int modIconIdx = modIcons.length;

		for (int i = 0; i < itemsToLoad.size(); i++)
		{
			final CollectionLogItem item = itemsToLoad.get(i);
			final ItemComposition itemComposition = itemManager.getItemComposition(item.getId());
			final BufferedImage image = ImageUtil.resizeImage(itemManager.getImage(itemComposition.getId()), 18, 16);
			final IndexedSprite sprite = ImageUtil.getImageIndexedSprite(image, client);
			final int spriteIndex = modIconIdx + i;

			newModIcons[spriteIndex] = sprite;
			loadedCollectionLogIcons.put(item.getId(), spriteIndex);
		}

		client.setModIcons(newModIcons);
	}

	/**
	 * Builds the output message for the !log command when a page is specified
	 *
	 * @param collectionLogPage Page to format into a chat message
	 * @return Command's output message
	 */
	private String buildCommandOutput(CollectionLogPage collectionLogPage, String commandFilter)
	{
		// Ensure all the page's item icons are loaded into the client
		loadPageIcons(collectionLogPage.getItems());

		if (commandFilter == null)
		{
			commandFilter = "obtained";
		}

		List<CollectionLogItem> items = collectionLogPage.applyItemFilter(commandFilter.toLowerCase());
		StringBuilder itemBuilder = new StringBuilder();
		for (CollectionLogItem item : items)
		{
			String itemString = "<img=" + loadedCollectionLogIcons.get(item.getId()) + ">";
			if (item.getQuantity() > 1)
			{
				itemString += "x" + item.getQuantity();
			}
			itemString += "  ";
			itemBuilder.append(itemString);
		}

		String replacementMessage = collectionLogPage.getName() + " (" + commandFilter + "): " + items.size() + "/" + collectionLogPage.getItems().size() + " ";
		replacementMessage += itemBuilder.toString();

		return replacementMessage;
	}

	/**
	 * Get the collection log title widget
	 *
	 * @return Collection log title widget
	 */
	private Widget getCollectionLogTitle()
	{
		Widget collLogContainer = client.getWidget(ComponentID.COLLECTION_LOG_CONTAINER);

		if (collLogContainer == null)
		{
			return null;
		}

		Widget containerChild = collLogContainer.getStaticChildren()[0];
		return containerChild.getDynamicChildren()[1];
	}

	/**
	 * Update newly obtained item
	 *
	 * @param itemStack Obtained item
	 */
	private void updateObtainedItem(ItemStack itemStack)
	{
		boolean itemUpdated = collectionLogManager.updateObtainedItem(itemStack);

		if (!itemUpdated)
		{
			collectionLogPanel.setStatus(
				"Unable to update data for item \"" + obtainedItemName + "\". Open the collection log page(s)" +
				"it exists in to update.",
				true,
				true
			);
		}

		obtainedItemName = null;
		inventoryItems = HashMultiset.create();
	}

	/**
	 * Delete profile from collectionlog.net
	 */
	public void deleteCollectionLog()
	{
		String username = client.getLocalPlayer().getName();
		String accountHash = String.valueOf(client.getAccountHash());
		apiClient.deleteCollectionLog(username, accountHash, new Callback()
		{
			@Override
			public void onFailure(@NonNull Call call, @NonNull IOException e)
			{
				log.error("Unable to delete collectionlog.net profile: " + e.getMessage());
				collectionLogPanel.setStatus(
					"Error deleting collectionlog.net profile. Check Runelite logs for full error.",
					true,
					true
				);
				isCollectionLogDeleted = false;
			}

			@Override
			public void onResponse(@NonNull Call call, @NonNull Response response)
			{
				response.close();
				collectionLogPanel.setStatus(
					"collectionlog.net profile successfully deleted.",
					false,
					true
				);
				isCollectionLogDeleted = true;
			}
		});
	}

	private void unsetOldConfigs()
	{
		// Remove old configs
		configManager.unsetRSProfileConfiguration(CONFIG_GROUP, "completed_categories");
		configManager.unsetConfiguration(CONFIG_GROUP, "highlight_completed");
		configManager.unsetConfiguration(CONFIG_GROUP, "new_item_chat_message");
		configManager.unsetRSProfileConfiguration(CONFIG_GROUP, "obtained_counts");
		configManager.unsetRSProfileConfiguration(CONFIG_GROUP, "obtained_items");
		configManager.unsetRSProfileConfiguration(CONFIG_GROUP, "kill_counts");
		configManager.unsetConfiguration(CONFIG_GROUP, "total_items");
	}

	private void resetFlags()
	{
		isUserLoggedIn = false;
		isCollectionLogDeleted = false;
		userSettingsLoaded = false;
	}

	private void uploadCollectionLog(String username, String accountType, String accountHash, boolean isFemale, JsonObject userSettings, JsonObject collectionLog)
	{
		apiClient.updateUser(username, accountType, accountHash, isFemale, userSettings, uploadCollectionLogCallback(() -> {
			apiClient.updateCollectionLog(collectionLog, accountHash, uploadCollectionLogCallback(null));
		}));
	}

	private Callback uploadCollectionLogCallback(Runnable onSuccess)
	{
		String errorDisplay = "Error uploading data to collectionlog.net. Check Runelite logs for full error.";
		String errorLog = "Unable to upload data to collectionlog.net: ";
		return new Callback()
		{
			@Override
			public void onFailure(@NonNull Call call, @NonNull IOException e)
			{
				log.error(errorLog + e.getMessage());
				collectionLogPanel.setStatus(
					errorDisplay,
					true,
					true
				);
			}

			@Override
			public void onResponse(@NonNull Call call, @NonNull Response response)
			{
				response.close();

				collectionLogPanel.setStatus(
					"Collection log successfully uploaded to collectionlog.net",
					false,
					true
				);

				if (onSuccess != null)
				{
					onSuccess.run();
				}
			}
		};
	}
}

package com.evansloan.collectionlog;

import net.runelite.client.RuneLite;
import net.runelite.client.externalplugins.ExternalPluginManager;

public class CollectionLogPluginTest
{
	public static void main(String[] args) throws Exception
	{
		ExternalPluginManager.loadBuiltin(CollectionLogPlugin.class);
		RuneLite.main(args);
	}
}
