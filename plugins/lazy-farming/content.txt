package com.easyfarming.utils;

import net.runelite.api.gameval.ItemID;
import net.runelite.api.gameval.VarbitID;
import java.util.Arrays;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

public class Constants {
    
    // Scene size for iterating over tiles
    public static final int SCENE_SIZE = 104;
    
    // Region IDs
    public static final int REGION_ARDOUGNE = 10547;
    public static final int REGION_CATHERBY = 11061;
    public static final int REGION_FALADOR = 11828;
    public static final int REGION_FARMING_GUILD = 4922;
    public static final int REGION_HARMONY = 15148;
    public static final int REGION_KOUREND = 6967;
    public static final int REGION_MORYTANIA = 14647;
    public static final int REGION_TROLL_STRONGHOLD = 11321;
    public static final int REGION_WEISS = 11325;
    public static final int REGION_CIVITAS = 6192;
    public static final int REGION_GNOME_STRONGHOLD = 9782;
    public static final int REGION_GNOME_STRONGHOLD_ALT = 9781;
    
    // Varbit IDs for patch checking
    public static final int VARBIT_HERB_PATCH_STANDARD = 4774;
    public static final int VARBIT_HERB_PATCH_FARMING_GUILD = 4775;
    public static final int VARBIT_HERB_PATCH_HARMONY = 4772;
    public static final int VARBIT_HERB_PATCH_TROLL_WEISS = 4771;
    public static final int VARBIT_FLOWER_PATCH_STANDARD = 4773;
    public static final int VARBIT_FLOWER_PATCH_FARMING_GUILD = 7906;
    public static final int VARBIT_TREE_PATCH_STANDARD = 4771;
    public static final int VARBIT_TREE_PATCH_FARMING_GUILD = 7905;
    public static final int VARBIT_FRUIT_TREE_PATCH_STANDARD = 4771;
    public static final int VARBIT_FRUIT_TREE_PATCH_FARMING_GUILD = 7909;
    public static final int VARBIT_FRUIT_TREE_PATCH_GNOME_STRONGHOLD = 4772;
    
    // Tool Leprechaun varbits
    public static final int VARBIT_COMPOST_STORED = 1442;
    public static final int VARBIT_SUPERCOMPOST_STORED = 1443;
    public static final int VARBIT_ULTRACOMPOST_STORED = 5732;
    public static final int VARBIT_BOTTOMLESS_COMPOST = 7915;
    
    // Interface IDs
    public static final int INTERFACE_SPELLBOOK_RESIZABLE = 161;
    public static final int INTERFACE_SPELLBOOK_FIXED = 164;
    public static final int INTERFACE_SPELLBOOK_TAB_RESIZABLE = 65;
    public static final int INTERFACE_SPELLBOOK_TAB_FIXED = 58;
    public static final int INTERFACE_PORTAL_NEXUS = 17;
    public static final int INTERFACE_PORTAL_NEXUS_CHILD = 13;
    public static final int INTERFACE_SPIRIT_TREE = 187;
    public static final int INTERFACE_SPIRIT_TREE_CHILD = 3;
    public static final int INTERFACE_JEWELLERY_BOX = 29155;
    public static final int INTERFACE_JEWELLERY_BOX_OPEN = 590;
    public static final int INTERFACE_TOOL_LEPRECHAUN = 125;
    public static final int INTERFACE_FARMER = 219;
    public static final int INTERFACE_INVENTORY = 149;
    public static final int INTERFACE_MAGIC_SPELLBOOK = 218;
    
    // Widget IDs
    public static final int WIDGET_PORTAL_NEXUS_PARENT = 17;
    public static final int WIDGET_PORTAL_NEXUS_CHILD = 12;
    public static final int WIDGET_JEWELLERY_BOX_WIDGET = 590;
    public static final int WIDGET_JEWELLERY_BOX_CHILD = 5;
    
    // Item ID Groups
    public static final List<Integer> TELEPORT_CRYSTAL_IDS = Collections.unmodifiableList(Arrays.asList(
        ItemID.MOURNING_TELEPORT_CRYSTAL_1,
        ItemID.MOURNING_TELEPORT_CRYSTAL_2,
        ItemID.MOURNING_TELEPORT_CRYSTAL_3,
        ItemID.MOURNING_TELEPORT_CRYSTAL_4,
        ItemID.MOURNING_TELEPORT_CRYSTAL_5
    ));
    
    public static final List<Integer> SKILLS_NECKLACE_IDS = Collections.unmodifiableList(Arrays.asList(
        ItemID.JEWL_NECKLACE_OF_SKILLS_1,
        ItemID.JEWL_NECKLACE_OF_SKILLS_2,
        ItemID.JEWL_NECKLACE_OF_SKILLS_3,
        ItemID.JEWL_NECKLACE_OF_SKILLS_4,
        ItemID.JEWL_NECKLACE_OF_SKILLS_5,
        ItemID.JEWL_NECKLACE_OF_SKILLS_6
    ));
    
    public static final List<Integer> HERB_PATCH_IDS = Collections.unmodifiableList(Arrays.asList(
        33176, 27115, 8152, 8150, 8153, 18816, 8151, 9372, 33979, 50697
    ));
    
    public static final List<Integer> FLOWER_PATCH_IDS = Collections.unmodifiableList(Arrays.asList(
        27111, 7849, 7847, 7850, 7848, 33649
    ));
    
    public static final List<Integer> TREE_PATCH_IDS = Collections.unmodifiableList(Arrays.asList(
        8389, 33732, 19147, 8391, 8388, 8390
    ));
    
    public static final List<Integer> FRUIT_TREE_PATCH_IDS = Collections.unmodifiableList(Arrays.asList(
        7964, 7965, 34007, 7962, 26579, 7963
    ));
    
    public static final List<Integer> HERB_SEED_IDS = Collections.unmodifiableList(Arrays.asList(
        ItemID.GUAM_SEED, ItemID.MARRENTILL_SEED, ItemID.TARROMIN_SEED, ItemID.HARRALANDER_SEED,
        ItemID.RANARR_SEED, ItemID.TOADFLAX_SEED, ItemID.IRIT_SEED, ItemID.AVANTOE_SEED,
        ItemID.KWUARM_SEED, ItemID.SNAPDRAGON_SEED, ItemID.CADANTINE_SEED, ItemID.LANTADYME_SEED,
        ItemID.DWARF_WEED_SEED, ItemID.TORSTOL_SEED, ItemID.HUASCA_SEED
    ));
    
    public static final List<Integer> TREE_SAPLING_IDS = Collections.unmodifiableList(Arrays.asList(
        ItemID.PLANTPOT_OAK_SAPLING, ItemID.PLANTPOT_WILLOW_SAPLING, ItemID.PLANTPOT_MAPLE_SAPLING,
        ItemID.PLANTPOT_YEW_SAPLING, ItemID.PLANTPOT_MAGIC_TREE_SAPLING
    ));
    
    public static final List<Integer> FRUIT_TREE_SAPLING_IDS = Collections.unmodifiableList(Arrays.asList(
        ItemID.PLANTPOT_APPLE_SAPLING, ItemID.PLANTPOT_BANANA_SAPLING, ItemID.PLANTPOT_ORANGE_SAPLING,
        ItemID.PLANTPOT_CURRY_SAPLING, ItemID.PLANTPOT_PINEAPPLE_SAPLING, ItemID.PLANTPOT_PAPAYA_SAPLING,
        ItemID.PLANTPOT_PALM_SAPLING, ItemID.PLANTPOT_DRAGONFRUIT_SAPLING
    ));
    
    public static final List<Integer> RUNE_POUCH_IDS = Collections.unmodifiableList(Arrays.asList(
        ItemID.BH_RUNE_POUCH, ItemID.DIVINE_RUNE_POUCH
    ));
    
    public static final List<Integer> RUNE_POUCH_AMOUNT_VARBITS = Collections.unmodifiableList(Arrays.asList(
        VarbitID.RUNE_POUCH_QUANTITY_1, VarbitID.RUNE_POUCH_QUANTITY_2,
        VarbitID.RUNE_POUCH_QUANTITY_3, VarbitID.RUNE_POUCH_QUANTITY_4
    ));
    
    public static final List<Integer> RUNE_POUCH_RUNE_VARBITS = Collections.unmodifiableList(Arrays.asList(
        VarbitID.RUNE_POUCH_TYPE_1, VarbitID.RUNE_POUCH_TYPE_2,
        VarbitID.RUNE_POUCH_TYPE_3, VarbitID.RUNE_POUCH_TYPE_4
    ));
    
    public static final List<Integer> SPIRIT_TREE_IDS = Collections.unmodifiableList(Arrays.asList(
        1293, 1294, 1295, 8355, 29227, 29229, 37329, 40778
    ));
    
    public static final List<Integer> JEWELLERY_BOX_IDS = Collections.unmodifiableList(Arrays.asList(
        29154, 29155, 29156
    ));
    
    public static final List<Integer> XERICS_TALISMAN_IDS = Collections.unmodifiableList(Arrays.asList(
        33411, 33412, 33413, 33414, 33415
    ));
    
    // Base item IDs (for variant handling)
    public static final int BASE_TELEPORT_CRYSTAL_ID = ItemID.MOURNING_TELEPORT_CRYSTAL_1;
    public static final int BASE_SKILLS_NECKLACE_ID = ItemID.JEWL_NECKLACE_OF_SKILLS_1;
    public static final int BASE_HERB_SEED_ID = ItemID.GUAM_SEED;
    public static final int BASE_TREE_SAPLING_ID = ItemID.PLANTPOT_OAK_SAPLING;
    public static final int BASE_FRUIT_TREE_SAPLING_ID = ItemID.PLANTPOT_APPLE_SAPLING;
    
    // Combination rune mapping
    public static final Map<Integer, List<Integer>> COMBINATION_RUNE_SUBRUNES_MAP;
    
    static {
        Map<Integer, List<Integer>> tempMap = new HashMap<>();
        tempMap.put(ItemID.DUSTRUNE, Arrays.asList(ItemID.AIRRUNE, ItemID.EARTHRUNE));
        tempMap.put(ItemID.MISTRUNE, Arrays.asList(ItemID.AIRRUNE, ItemID.WATERRUNE));
        tempMap.put(ItemID.MUDRUNE, Arrays.asList(ItemID.WATERRUNE, ItemID.EARTHRUNE));
        tempMap.put(ItemID.LAVARUNE, Arrays.asList(ItemID.FIRERUNE, ItemID.EARTHRUNE));
        tempMap.put(ItemID.STEAMRUNE, Arrays.asList(ItemID.FIRERUNE, ItemID.WATERRUNE));
        tempMap.put(ItemID.SMOKERUNE, Arrays.asList(ItemID.FIRERUNE, ItemID.AIRRUNE));
        COMBINATION_RUNE_SUBRUNES_MAP = Collections.unmodifiableMap(tempMap);
    }
    
    // Helper methods
    public static boolean isTeleportCrystal(int itemId) {
        return TELEPORT_CRYSTAL_IDS.contains(itemId);
    }
    
    public static boolean isSkillsNecklace(int itemId) {
        return SKILLS_NECKLACE_IDS.contains(itemId);
    }
    
    public static boolean isHerbSeed(int itemId) {
        return HERB_SEED_IDS.contains(itemId);
    }
    
    public static boolean isTreeSapling(int itemId) {
        return TREE_SAPLING_IDS.contains(itemId);
    }
    
    public static boolean isFruitTreeSapling(int itemId) {
        return FRUIT_TREE_SAPLING_IDS.contains(itemId);
    }
    
    public static boolean isQuetzalWhistle(int itemId) {
        return itemId == ItemID.HG_QUETZALWHISTLE_BASIC ||
               itemId == ItemID.HG_QUETZALWHISTLE_ENHANCED ||
               itemId == ItemID.HG_QUETZALWHISTLE_PERFECTED;
    }
}


package com.easyfarming;

import net.runelite.api.Client;

import java.util.Arrays;
import java.util.List;
import java.util.stream.Collectors;
import java.util.stream.Stream;

public class FruitTreePatchChecker {
    public enum FruitTree {
        //Order of lists is "growing, diseased, dead, healthy, remove"
        APPLE(Arrays.asList(8,9,10,11,12,13), Arrays.asList(21,22,23,24,25,26), Arrays.asList(27,28,29,30,31,32), Arrays.asList(34), Arrays.asList(14,15,16,17,18,19,20, 33)),
        BANANA(Arrays.asList(35,36,37,38,39,40), Arrays.asList(48,49,50,51,52,53), Arrays.asList(54,55,56,57,58,59), Arrays.asList(61), Arrays.asList(41,42,43,44,45,46,47, 60)),
        ORANGE(Arrays.asList(72,73,74,75,76,77), Arrays.asList(85,86,87,88,89, 90), Arrays.asList(91,92,93,94,95,96), Arrays.asList(98), Arrays.asList(78,79,80,81,82,83,84, 97)),
        CURRY(Arrays.asList(99,100,101,102,103,104), Arrays.asList(112,113,114,115,116,117), Arrays.asList(118,119,120,121,122,123), Arrays.asList(125), Arrays.asList(105,106,107,108,109,110,111, 124)),
        PINEAPPLE(Arrays.asList(136,137,138,139,140,141), Arrays.asList(149,150,151,152,153,154), Arrays.asList(155,156,157,158,159,160), Arrays.asList(162), Arrays.asList(142,143,144,145,146,147,148, 161)),
        PAPAYA(Arrays.asList(163,164,165,166,167,168), Arrays.asList(176,177,178,179,180,181), Arrays.asList(182,183,184,185,186,187), Arrays.asList(189), Arrays.asList(169,170,171,172,173,174,175, 188)),
        PALM(Arrays.asList(200,201,202,203,204,205), Arrays.asList(213,214,215,216,217,218), Arrays.asList(219,220,221,222,223,224), Arrays.asList(226), Arrays.asList(206,207,208,209,210,211,212, 225)),
        DRAGONFRUIT(Arrays.asList(227,228,229,230,231,232), Arrays.asList(240,241,242,243,244,245), Arrays.asList(246,247,248,249,250,251), Arrays.asList(253), Arrays.asList(233,234,235,236,237,238,239, 252));

        private final List<Integer> growing;
        private final List<Integer> diseased;
        private final List<Integer> dead;
        private final List<Integer> healthy;
        private final List<Integer> remove;

        FruitTree(List<Integer> growing, List<Integer> diseased, List<Integer> dead, List<Integer> healthy, List<Integer> remove) {
            this.growing = growing;
            this.diseased = diseased;
            this.dead = dead;
            this.healthy = healthy;
            this.remove = remove;
        }

        public List<Integer> getGrowing() {
            return growing;
        }

        public List<Integer> getDiseased() {
            return diseased;
        }

        public List<Integer> getDead() {
            return dead;
        }

        public List<Integer> getHealthy() {
            return healthy;
        }
        public List<Integer> getRemove() {
            return remove;
        }
    }

    // Combine all growing and dead varbit values into single lists
    private static final List<Integer> growing = Stream.of(FruitTree.values())
            .flatMap(fruitTree -> fruitTree.getGrowing().stream())
            .collect(Collectors.toList());

    private static final List<Integer> diseased = Stream.of(FruitTree.values())
            .flatMap(fruitTree -> fruitTree.getDiseased().stream())
            .collect(Collectors.toList());

    private static final List<Integer> dead = Stream.of(FruitTree.values())
            .flatMap(fruitTree -> fruitTree.getDead().stream())
            .collect(Collectors.toList());

    private static final List<Integer> healthy = Stream.of(FruitTree.values())
            .flatMap(fruitTree -> fruitTree.getHealthy().stream())
            .collect(Collectors.toList());
    private static final List<Integer> remove = Stream.of(FruitTree.values())
            .flatMap(fruitTree -> fruitTree.getRemove().stream())
            .collect(Collectors.toList());

    private static final List<Integer> weeds = Arrays.asList(0, 1, 2);

    public enum PlantState {
        GROWING,
        DISEASED,
        DEAD,
        WEEDS,
        HEALTHY,
        REMOVE,
        PLANT,
        UNKNOWN
    }

    public static PlantState checkFruitTreePatch(Client client, int varbitIndex) {
        int varbitValue = client.getVarbitValue(varbitIndex);
        if (growing.contains(varbitValue)) {
            return PlantState.GROWING;
        } else if (diseased.contains(varbitValue)) {
            return PlantState.DISEASED;
        } else if (dead.contains(varbitValue)) {
            return PlantState.DEAD;
        } else if (weeds.contains(varbitValue)) {
            return PlantState.WEEDS;
        }  else if (healthy.contains(varbitValue)) {
            return PlantState.HEALTHY;
        }else if (remove.contains(varbitValue)) {
            return PlantState.REMOVE;
        } else if (varbitValue == 3) {
            return PlantState.PLANT;
        } else {
            return PlantState.UNKNOWN;
        }
    }
}
package com.easyfarming;

import java.awt.*;
import net.runelite.client.config.Config;
import net.runelite.client.config.ConfigGroup;
import net.runelite.client.config.ConfigItem;
import net.runelite.client.config.ConfigSection;

@ConfigGroup("farminghelper")
public interface EasyFarmingConfig extends Config
{
	@ConfigSection(
			name = "General",
			description = "The highlighted and hidden item lists",
			position = 0
	)
	String generalList = "generalList";

	enum OptionEnumHouseTele
	{
		Law_air_earth_runes,
		Teleport_To_House,
		Construction_cape,
		Construction_cape_t,
		Max_cape
	}
	public interface OptionEnumTeleport {
		String name();
	}
	@ConfigItem(
			position = 10,
			keyName = "enumConfigHouseTele",
			name = "House teleport",
			description = "Desired way to teleport to house",
			section = generalList
	)
	default OptionEnumHouseTele enumConfigHouseTele() { return OptionEnumHouseTele.Law_air_earth_runes; }
	@ConfigItem(
			position = 1,
			keyName = "highlightLeftClickColor",
			name = "Left Click Color",
			description = "The color to use for highlighting objects",
			section = generalList
	)
	default Color highlightLeftClickColor() {return new Color(0, 191, 255, 128);}
	@ConfigItem(
			position = 2,
			keyName = "highlightRightClickColor",
			name = "Right Click Color",
			description = "The color to use for highlighting objects",
			section = generalList
	)
	default Color highlightRightClickColor() {return new Color(0, 191, 30, 128);}
	@ConfigItem(
			position = 3,
			keyName = "highlightUseItemColor",
			name = "'Use' item Color",
			description = "The color to use for highlighting objects",
			section = generalList
	)
	default Color highlightUseItemColor() {return new Color(255, 192, 203, 128);}
	@ConfigItem(
			position = 4,
			keyName = "highlightAlpha",
			name = "Transparency",
			description = "The transparency value for the highlight color (0-255)",
			section = generalList
	)
	default int highlightAlpha() {return 128;}

	enum OptionEnumCompost
	{
		Compost,
		Supercompost,
		Ultracompost,
		Bottomless
	}
	@ConfigItem(
			position = 5,
			keyName = "enumConfigCompost",
			name = "Compost",
			description = "Desired Compost",
			section = generalList
	)
	default OptionEnumCompost enumConfigCompost() { return OptionEnumCompost.Bottomless; }


	@ConfigItem(
			keyName = "booleanConfigRake",
			name = "Rake",
			description = "Include rake?",
			position = 6,
			section = generalList
	)
	default boolean generalRake() { return false; }
	@ConfigItem(
		keyName = "booleanConfigSeedDibber",
		name = "Seed dibber",
		description = "Include seed dibber?",
		position = 7,
		section = generalList
	)
	default boolean generalSeedDibber() { return true; }
	@ConfigItem(
			keyName = "booleanConfigLimpwurt",
			name = "Limpwurt",
			description = "Want to include limpwurts in your farm run?",
			position = 8,
			section = generalList
	)
	default boolean generalLimpwurt() { return false; }
	@ConfigItem(
			keyName = "booleanConfigAllotment",
			name = "Allotment (No code written yet)",
			description = "Want to include Allotment in your farm run?",
			position = 9,
			section = generalList
	)
	default boolean generalAllotment() { return false; }

	@ConfigItem(
		keyName = "booleanConfigPayForProtection",
		name = "Pay for protection",
		description = "Want a reminder to pay for protection? (This currently doesn't check for the required items, only prompts you to pay the farmer.)",
		position = 10,
		section = generalList
	)
	default boolean generalPayForProtection() { return false; }


	@ConfigSection(
		name = "Herbs",
		description = "The highlighted and hidden item lists",
		position = 1
	)
	String herbList = "herbList";

	@ConfigItem(
		keyName = "booleanConfigArdougneHerb",
		name = "Ardougne",
		description = "Include Ardougne?",
		position = 1,
		section = herbList
	)
	default boolean ardougneHerb() { return true; }
	
	@ConfigItem(
		position = 2,
		keyName = "booleanConfigCatherbyHerb",
		name = "Catherby",
		description = "Include Catherby?",
		section = herbList
	)
	default boolean catherbyHerb() { return true; }
	
	@ConfigItem(
		position = 3,
		keyName = "booleanConfigFaladorHerb",
		name = "Falador",
		description = "Include Falador?",
		section = herbList
	)
	default boolean faladorHerb() { return true; }
	
	@ConfigItem(
		position = 4,
		keyName = "booleanConfigFarmingGuildHerb",
		name = "Farming Guild",
		description = "Include Farming guild? (Requires level 65 farming and 60% Hosidious favour)",
		section = herbList
	)
	default boolean farmingGuildHerb() { return false; }
	
	@ConfigItem(
		position = 5,
		keyName = "booleanConfigHarmonyHerb",
		name = "Harmony",
		description = "Include Harmony? (Requires elite Morytania diary)",
		section = herbList
	)
	default boolean harmonyHerb() { return false; }
	
	@ConfigItem(
		position = 6,
		keyName = "booleanConfigKourendHerb",
		name = "Kourend",
		description = "Include Kourend?",
		section = herbList
	)
	default boolean kourendHerb() { return true; }
	
	@ConfigItem(
		position = 7,
		keyName = "booleanConfigMorytaniaHerb",
		name = "Morytania",
		description = "Include Morytania?",
		section = herbList
	)
	default boolean morytaniaHerb() { return true; }
	
	@ConfigItem(
		position = 8,
		keyName = "booleanConfigTrollStrongholdHerb",
		name = "Troll Stronghold",
		description = "Include Troll Stronghold(Requires completion of My Arm's Big Adventure)?",
		section = herbList
	)
	default boolean trollStrongholdHerb() { return false; }
	
	@ConfigItem(
		position = 9,
		keyName = "booleanConfigWeissHerb",
		name = "Weiss",
		description = "Include Weiss? (Requires completion of Making Friends with My Arm, and The Fire of Nourishment must be built)",
		section = herbList
	)
	default boolean weissHerb() { return false; }

	@ConfigItem(
		position = 10,
		keyName = "booleanConfigCivitasHerb",
		name = "Civitas illa Fortis",
		description = "Include Civitas illa Fortis?",
		section = herbList
	)
	default boolean civitasHerb() { return false; }

	@ConfigSection(
		name = "Tree",
		description = "The highlighted and hidden item lists",
		position = 2
	)
	String treeList = "treeList";
	
	@ConfigItem(
		position = 10,
		keyName = "booleanConfigFaladorTree",
		name = "Falador",
		description = "Include Falador?",
		section = treeList
	)
	default boolean faladorTree() { return true; }
	
	@ConfigItem(
		position = 11,
		keyName = "booleanConfigFarmingGuildTree",
		name = "Farming guild",
		description = "Include Farming Guild? (Requires 65 farming)",
		section = treeList
	)
	default boolean farmingGuildTree() { return false; }
	
	@ConfigItem(
		position = 12,
		keyName = "booleanConfigGnomeStrongholdTree",
		name = "Gnome Stronghold",
		description = "Include Gnome Stronghold?",
		section = treeList
	)
	default boolean gnomeStrongholdTree() { return true; }
	
	@ConfigItem(
		position = 13,
		keyName = "booleanConfigLumbridgeTree",
		name = "Lumbridge",
		description = "Include Lumbridge?",
		section = treeList
	)
	default boolean lumbridgeTree() { return true; }
	
	@ConfigItem(
		position = 14,
		keyName = "booleanConfigTaverleyTree",
		name = "Taverley",
		description = "Include Taverley?",
		section = treeList
	)
	default boolean taverleyTree() { return true; }
	
	@ConfigItem(
		position = 15,
		keyName = "booleanConfigVarrockTree",
		name = "Varrock",
		description = "Include Varrock?",
		section = treeList
	)
	default boolean varrockTree() { return true; }
	
	@ConfigSection(
		name = "Fruit Tree",
		description = "The highlighted and hidden item lists",
		position = 3
	)
	String fruitTreeList = "fruitTreeList";
	
	@ConfigItem(
		position = 16,
		keyName = "booleanConfigBrimhavenFruitTree",
		name = "Brimhaven",
		description = "Include Brimhaven?",
		section = fruitTreeList
	)
	default boolean brimhavenFruitTree() { return true; }
	
	@ConfigItem(
		position = 17,
		keyName = "booleanConfigCatherbyFruitTree",
		name = "Catherby",
		description = "Include Catherby?",
		section = fruitTreeList
	)
	default boolean catherbyFruitTree() { return true; }
	
	@ConfigItem(
		position = 18,
		keyName = "booleanConfigFarmingGuildFruitTree",
		name = "Farming Guild",
		description = "Include Farming Guild? (Requires 85 farming)",
		section = fruitTreeList
	)
	default boolean farmingGuildFruitTree() { return false; }
	
	@ConfigItem(
		position = 19,
		keyName = "booleanConfigGnomeStrongholdFruitTree",
		name = "Gnome Stronghold",
		description = "Include Gnome Stronghold?",
		section = fruitTreeList
	)
	default boolean gnomeStrongholdFruitTree() { return true; }
	
	@ConfigItem(
		position = 20,
		keyName = "booleanConfigLletyaFruitTree",
		name = "Lletya",
		description = "Include Lletya? (Requires starting Mourning's End Part I)",
		section = fruitTreeList
	)
	default boolean lletyaFruitTree() { return false; }
	
	@ConfigItem(
		position = 21,
		keyName = "booleanConfigTreeGnomeVillageFruitTree",
		name = "Tree Gnome Village",
		description = "Include Tree Gnome Village?",
		section = fruitTreeList
	)
	default boolean treeGnomeVillageFruitTree() { return true; }


	@ConfigSection(
			name = "Herb teleport options",
			description = "Choose what teleport to use for each Herb patch",
			position = 4
	)
	String teleportOptionList = "teleportOptionList";

	enum OptionEnumArdougneTeleport implements OptionEnumTeleport
	{
		Portal_Nexus,
		Ardougne_teleport,
		Ardougne_tele_tab,
		Ardy_cloak,
		Skills_Necklace
	}
	@ConfigItem(
			position = 2,
			keyName = "enumOptionEnumArdougneTeleport",
			name = "Ardougne",
			description = "Desired way to teleport to Ardougne",
			section = teleportOptionList
	)
	default OptionEnumArdougneTeleport enumOptionEnumArdougneTeleport() { return OptionEnumArdougneTeleport.Ardy_cloak; }
	enum OptionEnumCatherbyTeleport implements OptionEnumTeleport
	{
		Portal_Nexus_Catherby,
		Portal_Nexus_Camelot,
		Camelot_Teleport,
		Camelot_Tele_Tab,
		Catherby_Tele_Tab
	}
	@ConfigItem(
			position = 3,
			keyName = "enumOptionEnumCatherbyTeleport",
			name = "Catherby",
			description = "Desired way to teleport to Catherby",
			section = teleportOptionList
	)
	default OptionEnumCatherbyTeleport enumOptionEnumCatherbyTeleport() { return OptionEnumCatherbyTeleport.Portal_Nexus_Catherby; }

	enum OptionEnumFaladorTeleport implements OptionEnumTeleport
	{
		Portal_Nexus,
		Explorers_ring,
		Falador_Teleport,
		Falador_Tele_Tab,
		Draynor_Tele_Tab
	}
	@ConfigItem(
			position = 4,
			keyName = "enumOptionEnumFaladorTeleport",
			name = "Falador",
			description = "Desired way to teleport to Falador",
			section = teleportOptionList
	)
	default OptionEnumFaladorTeleport enumOptionEnumFaladorTeleport() { return OptionEnumFaladorTeleport.Explorers_ring; }

	enum OptionEnumFarmingGuildTeleport implements OptionEnumTeleport
	{
		Jewellery_box,
		Skills_Necklace
	}
	@ConfigItem(
			position = 5,
			keyName = "enumOptionEnumFarmingGuildTeleport",
			name = "Farming Guild",
			description = "Desired way to teleport to Farming Guild",
			section = teleportOptionList
	)
	default OptionEnumFarmingGuildTeleport enumOptionEnumFarmingGuildTeleport() { return OptionEnumFarmingGuildTeleport.Jewellery_box; }

	enum OptionEnumHarmonyTeleport implements OptionEnumTeleport
	{
		Portal_Nexus,
		Harmony_Tele_tab
	}
	@ConfigItem(
			position = 6,
			keyName = "enumOptionEnumHarmonyTeleport",
			name = "Harmony",
			description = "Desired way to teleport to Harmony",
			section = teleportOptionList
	)
	default OptionEnumHarmonyTeleport enumOptionEnumHarmonyTeleport() { return OptionEnumHarmonyTeleport.Portal_Nexus; }

	enum OptionEnumKourendTeleport implements OptionEnumTeleport
	{
		Xerics_Talisman,
		Mounted_Xerics
	}
	@ConfigItem(
			position = 7,
			keyName = "enumOptionEnumKourendTeleport",
			name = "Kourend",
			description = "Desired way to teleport to Kourend",
			section = teleportOptionList
	)
	default OptionEnumKourendTeleport enumOptionEnumKourendTeleport() { return OptionEnumKourendTeleport.Xerics_Talisman; }

	enum OptionEnumMorytaniaTeleport implements OptionEnumTeleport
	{
		Ectophial
	}
	@ConfigItem(
			position = 8,
			keyName = "enumOptionEnumMorytaniaTeleport",
			name = "Morytania",
			description = "Desired way to teleport to Morytania",
			section = teleportOptionList
	)
	default OptionEnumMorytaniaTeleport enumOptionEnumMorytaniaTeleport() { return OptionEnumMorytaniaTeleport.Ectophial; }

	enum OptionEnumTrollStrongholdTeleport implements OptionEnumTeleport
	{
		Portal_Nexus,
		Stony_Basalt
	}
	@ConfigItem(
			position = 9,
			keyName = "enumOptionEnumTrollStrongholdTeleport",
			name = "Troll Stronghold",
			description = "Desired way to teleport to Troll Stronghold",
			section = teleportOptionList
	)
	default OptionEnumTrollStrongholdTeleport enumOptionEnumTrollStrongholdTeleport() { return OptionEnumTrollStrongholdTeleport.Portal_Nexus; }

	enum OptionEnumWeissTeleport implements OptionEnumTeleport
	{
		Portal_Nexus,
		Icy_basalt
	}
	@ConfigItem(
			position = 10,
			keyName = "enumOptionEnumWeissTeleport",
			name = "Weiss",
			description = "Desired way to teleport to Weiss",
			section = teleportOptionList
	)
	default OptionEnumWeissTeleport enumOptionEnumWeissTeleport() { return OptionEnumWeissTeleport.Portal_Nexus; }

	enum OptionEnumCivitasTeleport implements OptionEnumTeleport
	{
		Portal_Nexus,
		Civitas_Teleport,
		Civitas_Tele_Tab,
		Quetzal_whistle,
		Hunter_Skillcape
	}
	@ConfigItem(
		position = 11,
		keyName = "enumOptionEnumCivitasTeleport",
		name = "Civitas illa Fortis",
		description = "Desired way to teleport to Civitas illa Fortis",
		section = teleportOptionList
	)
	default OptionEnumCivitasTeleport enumOptionEnumCivitasTeleport() { return OptionEnumCivitasTeleport.Portal_Nexus; }

	@ConfigSection(
			name = "Tree teleport options",
			description = "Choose what teleport to use for each Herb patch",
			position = 5
	)
	String treeTeleportOptionList = "treeTeleportOptionList";
	enum TreeOptionEnumFaladorTeleport implements OptionEnumTeleport
	{
		Portal_Nexus,
		Teleport,
		Falador_Tele_Tab
	}
	@ConfigItem(
			position = 1,
			keyName = "enumTreeFaladorTeleport",
			name = "Falador",
			description = "Desired way to teleport to Falador",
			section = treeTeleportOptionList
	)
	default TreeOptionEnumFaladorTeleport enumTreeFaladorTeleport() { return TreeOptionEnumFaladorTeleport.Teleport; }

	enum TreeOptionEnumFarmingGuildTeleport implements OptionEnumTeleport
	{
		Jewellery_box,
		Skills_Necklace
	}
	@ConfigItem(
			position = 1,
			keyName = "enumTreeFarmingGuildTeleport",
			name = "Farming Guild",
			description = "Desired way to teleport to Farming Guild",
			section = treeTeleportOptionList
	)
	default TreeOptionEnumFarmingGuildTeleport enumTreeFarmingGuildTeleport() { return TreeOptionEnumFarmingGuildTeleport.Jewellery_box; }

	enum TreeOptionEnumGnomeStrongholdTeleport implements OptionEnumTeleport
	{
		Royal_seed_pod,
		Spirit_Tree
	}
	@ConfigItem(
			position = 2,
			keyName = "enumTreeGnomeStrongoldTeleport",
			name = "Gnome Stronghold",
			description = "Desired way to teleport to Gnome Stronghold",
			section = treeTeleportOptionList
	)
	default TreeOptionEnumGnomeStrongholdTeleport enumTreeGnomeStrongoldTeleport() { return TreeOptionEnumGnomeStrongholdTeleport.Royal_seed_pod; }

	enum TreeOptionEnumLumbridgeTeleport implements OptionEnumTeleport
	{
		Portal_Nexus,
		Teleport,
		Lumbridge_Tele_Tab
	}
	@ConfigItem(
			position = 3,
			keyName = "enumTreeLumbridgeTeleport",
			name = "Lumbridge",
			description = "Desired way to teleport to Lumbridge",
			section = treeTeleportOptionList
	)
	default TreeOptionEnumLumbridgeTeleport enumTreeLumbridgeTeleport() { return TreeOptionEnumLumbridgeTeleport.Teleport; }

	enum TreeOptionEnumTaverleyTeleport implements OptionEnumTeleport
	{
		Portal_Nexus,
		Teleport,
		Falador_Tele_Tab
	}
	@ConfigItem(
			position = 4,
			keyName = "enumTreeTaverleyTeleport",
			name = "Taverley",
			description = "Desired way to teleport to Taverley",
			section = treeTeleportOptionList
	)
	default TreeOptionEnumTaverleyTeleport enumTreeTaverleyTeleport() { return TreeOptionEnumTaverleyTeleport.Teleport; }

	enum TreeOptionEnumVarrockTeleport implements OptionEnumTeleport
	{
		Portal_Nexus,
		Teleport,
		Varrock_Tele_Tab
	}
	@ConfigItem(
			position = 5,
			keyName = "enumTreeVarrockTeleport",
			name = "Varrock",
			description = "Desired way to teleport to Varrock",
			section = treeTeleportOptionList
	)
	default TreeOptionEnumVarrockTeleport enumTreeVarrockTeleport() { return TreeOptionEnumVarrockTeleport.Teleport; }

	@ConfigSection(
			name = "Fruit tree teleport options",
			description = "Choose what teleport to use for each fruit tree",
			position = 6
	)
	String fruitTreeTeleportOptionList = "fruitTreeTeleportOptionList";

	enum FruitTreeOptionEnumBrimhavenTeleport implements OptionEnumTeleport
	{
		Portal_Nexus,
		Ardougne_teleport,
		Ardougne_Tele_Tab,
		POH_Tele_Tab
	}
	@ConfigItem(
			position = 1,
			keyName = "enumFruitTreeBrimhavenTeleport",
			name = "Brimhaven",
			description = "Desired way to teleport to Brimhaven",
			section = fruitTreeTeleportOptionList
	)
	default FruitTreeOptionEnumBrimhavenTeleport enumFruitTreeBrimhavenTeleport() { return FruitTreeOptionEnumBrimhavenTeleport.Ardougne_teleport; }

	enum FruitTreeOptionEnumCatherbyTeleport implements OptionEnumTeleport
	{
		Portal_Nexus_Catherby,
		Portal_Nexus_Camelot,
		Camelot_Teleport,
		Camelot_Tele_Tab,
		Catherby_Tele_Tab
	}
	@ConfigItem(
			position = 1,
			keyName = "enumFruitTreeCatherbyTeleport",
			name = "Catherby",
			description = "Desired way to teleport to Catherby",
			section = fruitTreeTeleportOptionList
	)
	default FruitTreeOptionEnumCatherbyTeleport enumFruitTreeCatherbyTeleport() { return FruitTreeOptionEnumCatherbyTeleport.Portal_Nexus_Catherby; }

	enum FruitTreeOptionEnumFarmingGuildTeleport implements OptionEnumTeleport
	{
		Jewellery_box,
		Skills_Necklace
	}
	@ConfigItem(
			position = 1,
			keyName = "enumFruitTreeFarmingGuildTeleport",
			name = "Farming Guild",
			description = "Desired way to teleport to Farming Guild",
			section = fruitTreeTeleportOptionList
	)
	default FruitTreeOptionEnumFarmingGuildTeleport enumFruitTreeFarmingGuildTeleport() { return FruitTreeOptionEnumFarmingGuildTeleport.Jewellery_box; }

	enum FruitTreeOptionEnumGnomeStrongholdTeleport implements OptionEnumTeleport
	{
		Royal_seed_pod,
		Spirit_Tree
	}
	@ConfigItem(
			position = 1,
			keyName = "enumFruitTreeGnomeStrongholdTeleport",
			name = "Gnome Stronghold",
			description = "Desired way to teleport to Gnome Stronghold",
			section = fruitTreeTeleportOptionList
	)
	default FruitTreeOptionEnumGnomeStrongholdTeleport enumFruitTreeGnomeStrongholdTeleport() { return FruitTreeOptionEnumGnomeStrongholdTeleport.Royal_seed_pod; }

	enum FruitTreeOptionEnumLletyaTeleport implements OptionEnumTeleport
	{
		Teleport_crystal
	}
	@ConfigItem(
			position = 1,
			keyName = "enumFruitTreeLletyaTeleport",
			name = "Lletya",
			description = "Desired way to teleport to Lletya",
			section = fruitTreeTeleportOptionList
	)
	default FruitTreeOptionEnumLletyaTeleport enumFruitTreeLletyaTeleport() { return FruitTreeOptionEnumLletyaTeleport.Teleport_crystal; }

	enum FruitTreeOptionEnumTreeGnomeVillageTeleport implements OptionEnumTeleport
	{
		Royal_seed_pod,
		Spirit_Tree
	}
	@ConfigItem(
			position = 1,
			keyName = "enumFruitTreeTreeGnomeVillageTeleport",
			name = "Tree Gnome Village",
			description = "Desired way to teleport to Tree Gnome Village",
			section = fruitTreeTeleportOptionList
	)
	default FruitTreeOptionEnumTreeGnomeVillageTeleport enumFruitTreeTreeGnomeVillageTeleport() { return FruitTreeOptionEnumTreeGnomeVillageTeleport.Royal_seed_pod; }
}
package com.easyfarming.overlays.handlers;

import com.easyfarming.*;
import com.easyfarming.core.Location;
import com.easyfarming.core.Teleport;
import com.easyfarming.overlays.highlighting.*;
import com.easyfarming.overlays.utils.ColorProvider;
import com.easyfarming.overlays.utils.GameObjectHelper;
import com.easyfarming.overlays.utils.WidgetHelper;
import com.easyfarming.utils.Constants;
import net.runelite.api.Client;
import net.runelite.api.coords.WorldPoint;
import net.runelite.api.gameval.InterfaceID;
import net.runelite.api.gameval.ItemID;
import net.runelite.api.gameval.VarClientID;
import net.runelite.api.widgets.Widget;

import javax.inject.Inject;
import java.awt.*;
import java.util.List;
import java.util.Objects;

/**
 * Handles teleport navigation logic for getting to locations and houses.
 */
public class NavigationHandler {
    private final Client client;
    private final EasyFarmingPlugin plugin;
    private final EasyFarmingConfig config;
    private final AreaCheck areaCheck;
    private final TeleportHighlighter teleportHighlighter;
    private final PatchHighlighter patchHighlighter;
    private final ItemHighlighter itemHighlighter;
    private final WidgetHighlighter widgetHighlighter;
    private final GameObjectHighlighter gameObjectHighlighter;
    private final DecorativeObjectHighlighter decorativeObjectHighlighter;
    private final MenuHighlighter menuHighlighter;
    private final WidgetHelper widgetHelper;
    private final GameObjectHelper gameObjectHelper;
    private final ColorProvider colorProvider;
    
    // State tracking
    public int currentTeleportCase = 1;
    public boolean isAtDestination = false;
    
    @Inject
    public NavigationHandler(Client client, EasyFarmingPlugin plugin, EasyFarmingConfig config,
                            AreaCheck areaCheck, TeleportHighlighter teleportHighlighter,
                            PatchHighlighter patchHighlighter, ItemHighlighter itemHighlighter,
                            WidgetHighlighter widgetHighlighter, GameObjectHighlighter gameObjectHighlighter,
                            DecorativeObjectHighlighter decorativeObjectHighlighter, MenuHighlighter menuHighlighter,
                            WidgetHelper widgetHelper, GameObjectHelper gameObjectHelper,
                            ColorProvider colorProvider) {
        this.client = client;
        this.plugin = plugin;
        this.config = config;
        this.areaCheck = areaCheck;
        this.teleportHighlighter = teleportHighlighter;
        this.patchHighlighter = patchHighlighter;
        this.itemHighlighter = itemHighlighter;
        this.widgetHighlighter = widgetHighlighter;
        this.gameObjectHighlighter = gameObjectHighlighter;
        this.decorativeObjectHighlighter = decorativeObjectHighlighter;
        this.menuHighlighter = menuHighlighter;
        this.widgetHelper = widgetHelper;
        this.gameObjectHelper = gameObjectHelper;
        this.colorProvider = colorProvider;
    }
    
    /**
     * Checks if player is in their house (has Portal object).
     */
    public void inHouseCheck() {
        if (gameObjectHelper.getGameObjectIdsByName("Portal").contains(4525)) {
            this.currentTeleportCase = 2;
        }
    }
    
    /**
     * Handles navigation to player's house.
     */
    public void gettingToHouse(Graphics2D graphics) {
        EasyFarmingConfig.OptionEnumHouseTele teleportOption = config.enumConfigHouseTele();
        Color leftColor = colorProvider.getLeftClickColorWithAlpha();
        Color rightColor = colorProvider.getRightClickColorWithAlpha();
        
        switch (teleportOption) {
            case Law_air_earth_runes:
                InventoryTabChecker.TabState tabState;
                tabState = InventoryTabChecker.checkTab(client, VarClientID.TOPLEVEL_PANEL);
                switch (tabState) {
                    case INVENTORY:
                    case REST:
                        widgetHighlighter.interfaceOverlay(widgetHelper.getSpellbookTabGroupId(), widgetHelper.getSpellbookTabChildId()).render(graphics);
                        break;
                    case SPELLBOOK:
                        // Highlight the "Teleport to House" spell using correct child ID from widget inspector
                        widgetHighlighter.interfaceOverlay(InterfaceID.MAGIC_SPELLBOOK, 31).render(graphics);
                        inHouseCheck();
                        break;
                }
                break;
            case Teleport_To_House:
                inHouseCheck();
                itemHighlighter.itemHighlight(graphics, ItemID.POH_TABLET_TELEPORTTOHOUSE, leftColor);
                break;
            case Construction_cape:
                inHouseCheck();
                itemHighlighter.itemHighlight(graphics, ItemID.SKILLCAPE_CONSTRUCTION, rightColor);
                break;
            case Construction_cape_t:
                inHouseCheck();
                itemHighlighter.itemHighlight(graphics, ItemID.SKILLCAPE_CONSTRUCTION_TRIMMED, rightColor);
                break;
            case Max_cape:
                inHouseCheck();
                itemHighlighter.itemHighlight(graphics, ItemID.SKILLCAPE_MAX, rightColor);
                break;
        }
    }
    
    /**
     * Determines if player should proceed to farming phase based on location and teleport.
     */
    public boolean shouldProceedToFarming(Location location, Teleport teleport) {
        int currentRegionId = client.getLocalPlayer().getWorldLocation().getRegionID();
        WorldPoint targetLocation = teleport.getPoint();
        
        // Check if player is in the correct region
        boolean inCorrectRegion = (currentRegionId == teleport.getRegionId());
        
        // Check if player is near the target location (within 20 tiles)
        boolean nearTarget = areaCheck.isPlayerWithinArea(targetLocation, 20);
        
        // Check if player is very close to the farming patch (within 5 tiles)
        boolean nearPatch = areaCheck.isPlayerWithinArea(targetLocation, 5);
        
        // Scenario 1: Player is very close to the patch - proceed to farming regardless of teleport method
        if (nearPatch) {
            return true;
        }
        
        // Scenario 2: Player is in correct region and reasonably close - proceed to farming
        if (inCorrectRegion && nearTarget) {
            return true;
        }
        
        // Scenario 3: Player is in correct region but far from target - might have skipped teleport step
        if (inCorrectRegion && !nearTarget) {
            if (isNearAnyFarmingPatch(location.getName())) {
                return true;
            }
        }
        
        // Scenario 4: Player is in wrong region but very close to target - might have used different teleport
        if (!inCorrectRegion && nearTarget) {
            return true;
        }
        
        // Default: Continue with normal navigation
        return false;
    }
    
    /**
     * Checks if player is near any farming patches of the specified type.
     */
    private boolean isNearAnyFarmingPatch(String locationName) {
        // Define farming patch locations for each area
        switch (locationName) {
            case "Ardougne":
                return areaCheck.isPlayerWithinArea(new WorldPoint(2670, 3374, 0), 10);
            case "Catherby":
                return areaCheck.isPlayerWithinArea(new WorldPoint(2813, 3463, 0), 10);
            case "Falador":
                return areaCheck.isPlayerWithinArea(new WorldPoint(3058, 3307, 0), 10);
            case "Civitas illa Fortis":
                return areaCheck.isPlayerWithinArea(new WorldPoint(1586, 3099, 0), 10);
            case "Farming Guild":
                return areaCheck.isPlayerWithinArea(new WorldPoint(1238, 3726, 0), 15) ||
                       areaCheck.isPlayerWithinArea(new WorldPoint(1232, 3736, 0), 15) ||
                       areaCheck.isPlayerWithinArea(new WorldPoint(1243, 3759, 0), 15);
            case "Brimhaven":
                return areaCheck.isPlayerWithinArea(new WorldPoint(2764, 3212, 0), 10);
            case "Gnome Stronghold":
                return areaCheck.isPlayerWithinArea(new WorldPoint(2436, 3415, 0), 10) ||
                       areaCheck.isPlayerWithinArea(new WorldPoint(2475, 3446, 0), 10);
            case "Lumbridge":
                return areaCheck.isPlayerWithinArea(new WorldPoint(3193, 3231, 0), 10);
            case "Taverley":
                return areaCheck.isPlayerWithinArea(new WorldPoint(2936, 3438, 0), 10);
            case "Varrock":
                return areaCheck.isPlayerWithinArea(new WorldPoint(3229, 3459, 0), 10);
            default:
                return false;
        }
    }
    
    /**
     * Gets the appropriate highlighting based on current situation.
     */
    public void adaptiveHighlighting(Location location, Teleport teleport, Graphics2D graphics,
                                     boolean herbRun, boolean treeRun, boolean fruitTreeRun) {
        int currentRegionId = client.getLocalPlayer().getWorldLocation().getRegionID();
        WorldPoint targetLocation = teleport.getPoint();
        Color leftColor = colorProvider.getLeftClickColorWithAlpha();
        
        boolean inCorrectRegion = (currentRegionId == teleport.getRegionId());
        boolean nearTarget = areaCheck.isPlayerWithinArea(targetLocation, 20);
        boolean nearPatch = areaCheck.isPlayerWithinArea(targetLocation, 5);
        
        // If player is very close to patch, highlight the patch directly
        if (nearPatch) {
            patchHighlighter.highlightFarmingPatchesForLocation(location.getName(), graphics,
                    herbRun, treeRun, fruitTreeRun, leftColor, leftColor);
            return;
        }
        
        // If player is in correct region but not near target, they might be near a different patch
        if (inCorrectRegion && !nearTarget) {
            if (isNearAnyFarmingPatch(location.getName())) {
                patchHighlighter.highlightFarmingPatchesForLocation(location.getName(), graphics,
                        herbRun, treeRun, fruitTreeRun, leftColor, leftColor);
                return;
            }
        }
        
        // Default to normal teleport highlighting
        teleportHighlighter.highlightTeleportMethod(teleport, graphics);
    }
    
    /**
     * Handles navigation to a specific location.
     */
    public void gettingToLocation(Graphics2D graphics, Location location, boolean herbRun,
                                  boolean treeRun, boolean fruitTreeRun) {
        Teleport teleport = location.getSelectedTeleport();
        boolean locationEnabledBool = false;
        
        if (herbRun) {
            locationEnabledBool = plugin.getHerbLocationEnabled(location.getName());
        } else if (treeRun) {
            locationEnabledBool = plugin.getTreeLocationEnabled(location.getName());
        } else if (fruitTreeRun) {
            locationEnabledBool = plugin.getFruitTreeLocationEnabled(location.getName());
        }
        
        if (locationEnabledBool) {
            if (!isAtDestination) {
                int currentRegionId = client.getLocalPlayer().getWorldLocation().getRegionID();
                
                // Use adaptive detection to determine if we should proceed to farming
                if (shouldProceedToFarming(location, teleport)) {
                    this.currentTeleportCase = 1;
                    isAtDestination = true;
                    if (location.getFarmLimps()) {
                        // This will be handled by the calling code
                    }
                    plugin.addTextToInfoBox(teleport.getDescription());
                } else {
                    // Use adaptive highlighting based on current situation
                    adaptiveHighlighting(location, teleport, graphics, herbRun, treeRun, fruitTreeRun);
                    plugin.addTextToInfoBox(teleport.getDescription());
                    return;
                }
                
                // Handle different teleport categories
                switch (teleport.getCategory()) {
                    case ITEM:
                        handleItemTeleport(graphics, teleport, location, currentRegionId);
                        break;
                    case PORTAL_NEXUS:
                        handlePortalNexusTeleport(graphics, teleport, location, currentRegionId);
                        break;
                    case SPIRIT_TREE:
                        handleSpiritTreeTeleport(graphics, teleport, location, currentRegionId);
                        break;
                    case JEWELLERY_BOX:
                        handleJewelleryBoxTeleport(graphics, teleport, location, currentRegionId);
                        break;
                    case MOUNTED_XERICS:
                        handleMountedXericsTeleport(graphics, teleport, location, currentRegionId);
                        break;
                    case SPELLBOOK:
                        handleSpellbookTeleport(graphics, teleport, currentRegionId);
                        break;
                }
            }
        } else {
            // Location not enabled, skip to next
        }
    }
    
    private void handleItemTeleport(Graphics2D graphics, Teleport teleport, Location location, int currentRegionId) {
        Color leftColor = colorProvider.getLeftClickColorWithAlpha();
        Color rightColor = colorProvider.getRightClickColorWithAlpha();
        
        if (teleport.getInterfaceGroupId() != 0) {
            if (!widgetHelper.isInterfaceOpen(teleport.getInterfaceGroupId(), teleport.getInterfaceChildId())) {
                itemHighlighter.itemHighlight(graphics, teleport.getId(), rightColor);
                if (!teleport.getRightClickOption().equals("null")) {
                    menuHighlighter.highlightRightClickOption(graphics, teleport.getRightClickOption());
                }
            } else {
                Widget widget = client.getWidget(teleport.getInterfaceGroupId(), teleport.getInterfaceChildId());
                widgetHighlighter.highlightDynamicComponent(graphics, widget, 1);
            }
            if (currentRegionId == teleport.getRegionId()) {
                this.currentTeleportCase = 1;
                isAtDestination = true;
                if (location.getFarmLimps()) {
                    // This will be handled by the calling code
                }
            }
        } else {
            if (!teleport.getRightClickOption().equals("null")) {
                itemHighlighter.itemHighlight(graphics, teleport.getId(), rightColor);
                menuHighlighter.highlightRightClickOption(graphics, teleport.getRightClickOption());
            } else {
                if (plugin.getEasyFarmingOverlay().isTeleportCrystal(teleport.getId())) {
                    itemHighlighter.highlightTeleportCrystal(graphics);
                }
                if (plugin.getEasyFarmingOverlay().isSkillsNecklace(teleport.getId())) {
                    String index = location.getName();
                    if (Objects.equals(index, "Ardougne")) {
                        itemHighlighter.highlightSkillsNecklace(graphics);
                        menuHighlighter.highlightRightClickOption(graphics, "Rub");
                        Widget widget = client.getWidget(Constants.INTERFACE_SPIRIT_TREE, Constants.INTERFACE_SPIRIT_TREE_CHILD);
                        widgetHighlighter.highlightDynamicComponent(graphics, widget, 0);
                    }
                    if (Objects.equals(index, "Farming Guild")) {
                        itemHighlighter.highlightSkillsNecklace(graphics);
                        menuHighlighter.highlightRightClickOption(graphics, "Rub");
                        Widget widget = client.getWidget(Constants.INTERFACE_SPIRIT_TREE, Constants.INTERFACE_SPIRIT_TREE_CHILD);
                        widgetHighlighter.highlightDynamicComponent(graphics, widget, 5);
                    }
                } else if (plugin.getEasyFarmingOverlay().isQuetzalWhistle(teleport.getId())) {
                    itemHighlighter.itemHighlight(graphics, teleport.getId(), leftColor);
                } else {
                    itemHighlighter.itemHighlight(graphics, teleport.getId(), leftColor);
                }
            }
            if (currentRegionId == teleport.getRegionId()) {
                this.currentTeleportCase = 1;
                isAtDestination = true;
                if (location.getFarmLimps()) {
                    // This will be handled by the calling code
                }
            }
        }
    }
    
    private void handlePortalNexusTeleport(Graphics2D graphics, Teleport teleport, Location location, int currentRegionId) {
        Color leftColor = colorProvider.getLeftClickColorWithAlpha();
        
        switch (this.currentTeleportCase) {
            case 1:
                gettingToHouse(graphics);
                break;
            case 2:
                if (!widgetHelper.isInterfaceOpen(17, 0)) {
                    List<Integer> portalNexusIds = gameObjectHelper.getGameObjectIdsByName("Portal Nexus");
                    for (Integer objectId : portalNexusIds) {
                        gameObjectHighlighter.highlightGameObject(objectId, leftColor).render(graphics);
                    }
                } else {
                    Widget widget = client.getWidget(Constants.INTERFACE_PORTAL_NEXUS, Constants.INTERFACE_PORTAL_NEXUS_CHILD);
                    int index = widgetHelper.getChildIndexPortalNexus(location.getName());
                    widgetHighlighter.highlightDynamicComponent(graphics, widget, index);
                }
                if (currentRegionId == teleport.getRegionId()) {
                    this.currentTeleportCase = 1;
                    isAtDestination = true;
                    if (location.getFarmLimps()) {
                        // This will be handled by the calling code
                    }
                }
                break;
        }
    }
    
    private void handleSpiritTreeTeleport(Graphics2D graphics, Teleport teleport, Location location, int currentRegionId) {
        Color leftColor = colorProvider.getLeftClickColorWithAlpha();
        
        if (!widgetHelper.isInterfaceOpen(187, 3)) {
            List<Integer> spiritTreeIds = Constants.SPIRIT_TREE_IDS;
            for (Integer objectId : spiritTreeIds) {
                gameObjectHighlighter.highlightGameObject(objectId, leftColor).render(graphics);
            }
        } else {
            Widget widget = client.getWidget(Constants.INTERFACE_SPIRIT_TREE, Constants.INTERFACE_SPIRIT_TREE_CHILD);
            switch (location.getName()) {
                case "Gnome Stronghold":
                    widgetHighlighter.highlightDynamicComponent(graphics, widget, widgetHelper.getChildIndexSpiritTree("Gnome Stronghold"));
                    break;
                case "Tree Gnome Village":
                    widgetHighlighter.highlightDynamicComponent(graphics, widget, widgetHelper.getChildIndexSpiritTree("Tree Gnome Village"));
                    break;
                case "Falador":
                    widgetHighlighter.highlightDynamicComponent(graphics, widget, widgetHelper.getChildIndexSpiritTree("Port Sarim"));
                    break;
                case "Kourend":
                    widgetHighlighter.highlightDynamicComponent(graphics, widget, widgetHelper.getChildIndexSpiritTree("Hosidius"));
                    break;
            }
        }
        if (currentRegionId == teleport.getRegionId()) {
            this.currentTeleportCase = 1;
            isAtDestination = true;
            if (location.getFarmLimps()) {
                // This will be handled by the calling code
            }
        }
    }
    
    private void handleJewelleryBoxTeleport(Graphics2D graphics, Teleport teleport, Location location, int currentRegionId) {
        Color leftColor = colorProvider.getLeftClickColorWithAlpha();
        
        switch (this.currentTeleportCase) {
            case 1:
                gettingToHouse(graphics);
                break;
            case 2:
                List<Integer> jewelleryBoxIds = Constants.JEWELLERY_BOX_IDS;
                if (!widgetHelper.isInterfaceOpen(Constants.INTERFACE_JEWELLERY_BOX_OPEN, 0)) {
                    for (int id : jewelleryBoxIds) {
                        gameObjectHighlighter.highlightGameObject(id, leftColor).render(graphics);
                    }
                    gameObjectHighlighter.highlightGameObject(teleport.getId(), leftColor).render(graphics);
                } else {
                    Widget widget = client.getWidget(Constants.INTERFACE_JEWELLERY_BOX_OPEN, Constants.WIDGET_JEWELLERY_BOX_CHILD);
                    widgetHighlighter.highlightDynamicComponent(graphics, widget, 10);
                }
                if (currentRegionId == teleport.getRegionId()) {
                    this.currentTeleportCase = 1;
                    isAtDestination = true;
                    if (location.getFarmLimps()) {
                        // This will be handled by the calling code
                    }
                }
                break;
        }
    }
    
    private void handleMountedXericsTeleport(Graphics2D graphics, Teleport teleport, Location location, int currentRegionId) {
        switch (this.currentTeleportCase) {
            case 1:
                gettingToHouse(graphics);
                break;
            case 2:
                List<Integer> xericsTalismanIds = Constants.XERICS_TALISMAN_IDS;
                if (!widgetHelper.isInterfaceOpen(teleport.getInterfaceGroupId(), teleport.getInterfaceChildId())) {
                    for (int id : xericsTalismanIds) {
                        decorativeObjectHighlighter.highlightDecorativeObject(id).render(graphics);
                    }
                } else {
                    Widget widget = client.getWidget(teleport.getInterfaceGroupId(), teleport.getInterfaceChildId());
                    widgetHighlighter.highlightDynamicComponent(graphics, widget, 1);
                    if (currentRegionId == teleport.getRegionId()) {
                        this.currentTeleportCase = 1;
                        isAtDestination = true;
                        if (location.getFarmLimps()) {
                            // This will be handled by the calling code
                        }
                    }
                }
                break;
        }
    }
    
    private void handleSpellbookTeleport(Graphics2D graphics, Teleport teleport, int currentRegionId) {
        InventoryTabChecker.TabState tabState;
        tabState = InventoryTabChecker.checkTab(client, VarClientID.TOPLEVEL_PANEL);
        switch (tabState) {
            case REST:
            case INVENTORY:
                widgetHighlighter.interfaceOverlay(widgetHelper.getSpellbookTabGroupId(), widgetHelper.getSpellbookTabChildId()).render(graphics);
                if (currentRegionId == teleport.getRegionId()) {
                    this.currentTeleportCase = 1;
                    isAtDestination = true;
                }
                break;
            case SPELLBOOK:
                widgetHighlighter.interfaceOverlay(teleport.getInterfaceGroupId(), teleport.getInterfaceChildId()).render(graphics);
                if (currentRegionId == teleport.getRegionId()) {
                    this.currentTeleportCase = 1;
                    isAtDestination = true;
                }
                break;
        }
    }
}


package com.easyfarming.overlays.handlers;

import com.easyfarming.*;
import com.easyfarming.core.Teleport;
import com.easyfarming.overlays.highlighting.*;
import com.easyfarming.overlays.utils.ColorProvider;
import com.easyfarming.overlays.utils.PatchStateChecker;
import com.easyfarming.utils.Constants;
import net.runelite.api.Client;
import net.runelite.api.gameval.ItemID;

import javax.inject.Inject;
import java.awt.*;

/**
 * Handles farming step logic for herb, flower, tree, and fruit tree patches.
 */
public class FarmingStepHandler {
    private final Client client;
    private final EasyFarmingPlugin plugin;
    private final EasyFarmingConfig config;
    private final AreaCheck areaCheck;
    private final PatchHighlighter patchHighlighter;
    private final ItemHighlighter itemHighlighter;
    private final CompostHighlighter compostHighlighter;
    private final FarmerHighlighter farmerHighlighter;
    private final PatchStateChecker patchStateChecker;
    private final ColorProvider colorProvider;
    
    // State tracking
    public boolean herbPatchDone = false;
    public boolean flowerPatchDone = false;
    public boolean treePatchDone = false;
    public boolean fruitTreePatchDone = false;
    
    @Inject
    public FarmingStepHandler(Client client, EasyFarmingPlugin plugin, EasyFarmingConfig config,
                              AreaCheck areaCheck, PatchHighlighter patchHighlighter,
                              ItemHighlighter itemHighlighter, CompostHighlighter compostHighlighter,
                              FarmerHighlighter farmerHighlighter, PatchStateChecker patchStateChecker,
                              ColorProvider colorProvider) {
        this.client = client;
        this.plugin = plugin;
        this.config = config;
        this.areaCheck = areaCheck;
        this.patchHighlighter = patchHighlighter;
        this.itemHighlighter = itemHighlighter;
        this.compostHighlighter = compostHighlighter;
        this.farmerHighlighter = farmerHighlighter;
        this.patchStateChecker = patchStateChecker;
        this.colorProvider = colorProvider;
    }
    
    /**
     * Handles herb patch farming steps.
     */
    public void herbSteps(Graphics2D graphics, Teleport teleport) {
        int currentRegionId = client.getLocalPlayer().getWorldLocation().getRegionID();
        HerbPatchChecker.PlantState plantState;
        Color leftColor = colorProvider.getLeftClickColorWithAlpha();
        Color useItemColor = colorProvider.getHighlightUseItemWithAlpha();
        
        // Farming guild herb patch uses 4775
        if (currentRegionId == Constants.REGION_FARMING_GUILD) {
            plantState = HerbPatchChecker.checkHerbPatch(client, Constants.VARBIT_HERB_PATCH_FARMING_GUILD);
        }
        // Harmony herb patch uses 4772
        else if (currentRegionId == Constants.REGION_HARMONY) {
            plantState = HerbPatchChecker.checkHerbPatch(client, Constants.VARBIT_HERB_PATCH_HARMONY);
        }
        // Troll Stronghold and Weiss herb patch uses 4771
        else if (currentRegionId == Constants.REGION_TROLL_STRONGHOLD || currentRegionId == Constants.REGION_WEISS) {
            plantState = HerbPatchChecker.checkHerbPatch(client, Constants.VARBIT_HERB_PATCH_TROLL_WEISS);
        }
        // Rest uses 4774
        else {
            plantState = HerbPatchChecker.checkHerbPatch(client, Constants.VARBIT_HERB_PATCH_STANDARD);
        }
        
        if (!areaCheck.isPlayerWithinArea(teleport.getPoint(), 15)) {
            // Should be replaced with a pathing system, pointing arrow or something else eventually
            patchHighlighter.highlightHerbPatches(graphics, leftColor);
        } else {
            switch (plantState) {
                case HARVESTABLE:
                    plugin.addTextToInfoBox("Harvest Herbs.");
                    patchHighlighter.highlightHerbPatches(graphics, leftColor);
                    break;
                case PLANT:
                    plugin.addTextToInfoBox("Use Herb seed on patch.");
                    patchHighlighter.highlightHerbPatches(graphics, useItemColor);
                    itemHighlighter.highlightHerbSeeds(graphics);
                    break;
                case DEAD:
                    plugin.addTextToInfoBox("Clear the dead herb patch.");
                    patchHighlighter.highlightHerbPatches(graphics, leftColor);
                    break;
                case DISEASED:
                    plugin.addTextToInfoBox("Use Plant cure on herb patch. Buy at GE or in farming guild/catherby, and store at Tool Leprechaun for easy access.");
                    patchHighlighter.highlightHerbPatches(graphics, leftColor);
                    itemHighlighter.itemHighlight(graphics, ItemID.PLANT_CURE, useItemColor);
                    break;
                case WEEDS:
                    plugin.addTextToInfoBox("Rake the herb patch.");
                    patchHighlighter.highlightHerbPatches(graphics, leftColor);
                    break;
                case GROWING:
                    plugin.addTextToInfoBox("Use Compost on patch.");
                    compostHighlighter.highlightCompost(graphics, true, false, false, 1);
                    if (patchStateChecker.patchIsComposted()) {
                        herbPatchDone = true;
                    }
                    break;
                case UNKNOWN:
                    plugin.addTextToInfoBox("UNKNOWN state: Try to do something with the herb patch to change its state.");
                    break;
            }
        }
    }
    
    /**
     * Handles flower patch farming steps.
     */
    public void flowerSteps(Graphics2D graphics, boolean farmLimps) {
        if (farmLimps) {
            int currentRegionId = client.getLocalPlayer().getWorldLocation().getRegionID();
            FlowerPatchChecker.PlantState plantState;
            Color leftColor = colorProvider.getLeftClickColorWithAlpha();
            Color useItemColor = colorProvider.getHighlightUseItemWithAlpha();
            
            if (currentRegionId == Constants.REGION_FARMING_GUILD) {
                plantState = FlowerPatchChecker.checkFlowerPatch(client, Constants.VARBIT_FLOWER_PATCH_FARMING_GUILD);
            } else {
                plantState = FlowerPatchChecker.checkFlowerPatch(client, Constants.VARBIT_FLOWER_PATCH_STANDARD);
            }
            switch (plantState) {
                case HARVESTABLE:
                    plugin.addTextToInfoBox("Harvest Limwurt root.");
                    patchHighlighter.highlightFlowerPatches(graphics, leftColor);
                    break;
                case WEEDS:
                    plugin.addTextToInfoBox("Rake the flower patch.");
                    patchHighlighter.highlightFlowerPatches(graphics, leftColor);
                    break;
                case DEAD:
                    plugin.addTextToInfoBox("Clear the dead flower patch.");
                    patchHighlighter.highlightFlowerPatches(graphics, leftColor);
                    break;
                case PLANT:
                    plugin.addTextToInfoBox("Use Limwurt seed on the patch.");
                    patchHighlighter.highlightFlowerPatches(graphics, useItemColor);
                    itemHighlighter.itemHighlight(graphics, ItemID.LIMPWURT_SEED, useItemColor);
                    break;
                case GROWING:
                    plugin.addTextToInfoBox("Use Compost on patch.");
                    compostHighlighter.highlightCompost(graphics, false, false, false, 2);
                    if (patchStateChecker.patchIsComposted()) {
                        flowerPatchDone = true;
                    }
                    break;
                case UNKNOWN:
                    // Handle unknown state if needed
                    break;
            }
        } else {
            flowerPatchDone = true;
        }
    }
    
    /**
     * Handles tree patch farming steps.
     */
    public void treeSteps(Graphics2D graphics, Teleport teleport) {
        int currentRegionId = client.getLocalPlayer().getWorldLocation().getRegionID();
        TreePatchChecker.PlantState plantState;
        Color leftColor = colorProvider.getLeftClickColorWithAlpha();
        Color useItemColor = colorProvider.getHighlightUseItemWithAlpha();
        
        // 4771 falador, gnome stronghold, lumbridge, Taverly, Varrock
        // 7905 farming guild
        if (currentRegionId == Constants.REGION_FARMING_GUILD) {
            plantState = TreePatchChecker.checkTreePatch(client, Constants.VARBIT_TREE_PATCH_FARMING_GUILD);
        } else {
            plantState = TreePatchChecker.checkTreePatch(client, Constants.VARBIT_TREE_PATCH_STANDARD);
        }
        
        if (!areaCheck.isPlayerWithinArea(teleport.getPoint(), 15)) {
            // Should be replaced with a pathing system, pointing arrow or something else eventually
            patchHighlighter.highlightTreePatches(graphics, leftColor);
        } else {
            switch (plantState) {
                case HEALTHY:
                    plugin.addTextToInfoBox("Check tree health.");
                    patchHighlighter.highlightTreePatches(graphics, leftColor);
                    break;
                case WEEDS:
                    plugin.addTextToInfoBox("Rake the tree patch.");
                    patchHighlighter.highlightTreePatches(graphics, leftColor);
                    break;
                case DEAD:
                    plugin.addTextToInfoBox("Clear the dead tree patch.");
                    patchHighlighter.highlightTreePatches(graphics, leftColor);
                    break;
                case PLANT:
                    plugin.addTextToInfoBox("Use Sapling on the patch.");
                    patchHighlighter.highlightTreePatches(graphics, useItemColor);
                    itemHighlighter.highlightTreeSapling(graphics);
                    break;
                case DISEASED:
                    plugin.addTextToInfoBox("Prune the tree patch.");                    
                    patchHighlighter.highlightTreePatches(graphics, useItemColor);
                    break;
                case REMOVE:
                    plugin.addTextToInfoBox("Pay to remove tree, or cut it down and clear the patch.");
                    farmerHighlighter.highlightTreeFarmers(graphics);
                    break;
                case UNKNOWN:
                    plugin.addTextToInfoBox("UNKNOWN state: Try to do something with the tree patch to change its state.");
                    break;
                case GROWING:
                    if (config.generalPayForProtection()) {
                        plugin.addTextToInfoBox("Pay to protect the patch.");
                        farmerHighlighter.highlightTreeFarmers(graphics);
                        if (patchStateChecker.patchIsProtected()) {
                            treePatchDone = true;
                        }
                    } else {
                        plugin.addTextToInfoBox("Use Compost on patch.");
                        compostHighlighter.highlightCompost(graphics, false, true, false, 1);
                        if (patchStateChecker.patchIsComposted()) {
                            treePatchDone = true;
                        }
                    }
                    break;
            }
        }
    }
    
    /**
     * Handles fruit tree patch farming steps.
     */
    public void fruitTreeSteps(Graphics2D graphics, Teleport teleport) {
        int currentRegionId = client.getLocalPlayer().getWorldLocation().getRegionID();
        FruitTreePatchChecker.PlantState plantState;
        Color leftColor = colorProvider.getLeftClickColorWithAlpha();
        Color useItemColor = colorProvider.getHighlightUseItemWithAlpha();
        
        // 4771 brimhaven, catherby, Lletya, tree gnome village
        // 7909 farming guild
        // 4772 gnome stronghold
        if (currentRegionId == Constants.REGION_FARMING_GUILD) {
            plantState = FruitTreePatchChecker.checkFruitTreePatch(client, Constants.VARBIT_FRUIT_TREE_PATCH_FARMING_GUILD);
        } else if (currentRegionId == Constants.REGION_GNOME_STRONGHOLD || currentRegionId == Constants.REGION_GNOME_STRONGHOLD_ALT) {
            plantState = FruitTreePatchChecker.checkFruitTreePatch(client, Constants.VARBIT_FRUIT_TREE_PATCH_GNOME_STRONGHOLD);
        } else {
            plantState = FruitTreePatchChecker.checkFruitTreePatch(client, Constants.VARBIT_FRUIT_TREE_PATCH_STANDARD);
        }
        
        if (!areaCheck.isPlayerWithinArea(teleport.getPoint(), 15)) {
            // Should be replaced with a pathing system, point arrow or something else eventually
            patchHighlighter.highlightFruitTreePatches(graphics, leftColor);
        } else {
            switch (plantState) {
                case HEALTHY:
                    plugin.addTextToInfoBox("Check Fruit tree health.");
                    patchHighlighter.highlightFruitTreePatches(graphics, leftColor);
                    break;
                case WEEDS:
                    plugin.addTextToInfoBox("Rake the fruit tree patch.");
                    patchHighlighter.highlightFruitTreePatches(graphics, leftColor);
                    break;
                case DEAD:
                    plugin.addTextToInfoBox("Clear the dead fruit tree patch.");
                    patchHighlighter.highlightFruitTreePatches(graphics, leftColor);
                    break;
                case PLANT:
                    plugin.addTextToInfoBox("Use Sapling on the patch.");
                    patchHighlighter.highlightFruitTreePatches(graphics, useItemColor);
                    itemHighlighter.highlightFruitTreeSapling(graphics);
                    break;
                case DISEASED:
                    plugin.addTextToInfoBox("Prune the fruit tree patch.");
                    patchHighlighter.highlightFruitTreePatches(graphics, leftColor);
                    break;
                case REMOVE:
                    plugin.addTextToInfoBox("Pay to remove fruit tree, or cut it down and clear the patch.");
                    farmerHighlighter.highlightFruitTreeFarmers(graphics);
                    break;
                case UNKNOWN:
                    plugin.addTextToInfoBox("UNKNOWN state: Try to do something with the tree patch to change its state.");
                    break;
                case GROWING:
                    if (config.generalPayForProtection()) {
                        plugin.addTextToInfoBox("Pay to protect the patch.");
                        farmerHighlighter.highlightFruitTreeFarmers(graphics);
                        if (patchStateChecker.patchIsProtected()) {
                            fruitTreePatchDone = true;
                        }
                    } else {
                        plugin.addTextToInfoBox("Use Compost on patch.");
                        compostHighlighter.highlightCompost(graphics, false, false, true, 1);
                        if (patchStateChecker.patchIsComposted()) {
                            fruitTreePatchDone = true;
                        }
                    }
                    break;
            }
        }
    }
}


package com.easyfarming.overlays.utils;

import com.easyfarming.EasyFarmingPlugin;

import java.util.regex.Pattern;

/**
 * Utility class for checking patch states (composted, protected, etc.).
 */
public class PatchStateChecker {
    private static final String REGEX_COMPOST1 = "You treat the (herb patch|flower patch|tree patch|fruit tree patch) with (compost|supercompost|ultracompost)\\.";
    private static final String REGEX_COMPOST2 = "This (herb patch|flower patch|tree patch|fruit tree patch) has already been treated with (compost|supercompost|ultracompost)\\.";
    private static final String REGEX_COMPOST3 = "You treat the patch with (compost|supercompost|ultracompost)\\.";
    private static final String REGEX_COMPOST4 = "This patch has already been treated with (compost|supercompost|ultracompost)\\.";
    private static final Pattern COMPOST_PATTERN = Pattern.compile(REGEX_COMPOST1 + "|" + REGEX_COMPOST2 + "|" + REGEX_COMPOST3 + "|" + REGEX_COMPOST4);
    
    private static final String STANDARD_RESPONSE = "You pay the gardener ([0-9A-Za-z\\ ]+) to protect the patch\\.";
    private static final String FALADOR_ELITE_RESPONSE = "The gardener protects your tree for you, free of charge, as a token of gratitude for completing the ([A-Za-z\\ ]+)\\.";
    private static final Pattern PROTECTED_PATTERN = Pattern.compile(STANDARD_RESPONSE + "|" + FALADOR_ELITE_RESPONSE);
    
    private final EasyFarmingPlugin plugin;
    
    public PatchStateChecker(EasyFarmingPlugin plugin) {
        this.plugin = plugin;
    }
    
    /**
     * Checks if a patch has been composted based on chat messages.
     */
    public boolean patchIsComposted() {
        String lastMessage = plugin.getLastMessage();
        if (lastMessage == null || lastMessage.isEmpty()) {
            return false;
        }
        
        return COMPOST_PATTERN.matcher(lastMessage).matches();
    }
    
    /**
     * Checks if a patch has been protected based on chat messages.
     */
    public boolean patchIsProtected() {
        String lastMessage = plugin.getLastMessage();
        if (lastMessage == null || lastMessage.isEmpty()) {
            return false;
        }
        
        return PROTECTED_PATTERN.matcher(lastMessage).matches();
    }
}


package com.easyfarming.overlays.utils;

import net.runelite.api.Client;
import net.runelite.api.GameObject;
import net.runelite.api.ObjectComposition;
import net.runelite.api.Tile;
import net.runelite.api.WorldView;
import com.easyfarming.utils.Constants;

import java.util.ArrayList;
import java.util.List;

/**
 * Utility class for finding game objects by name or ID.
 */
public class GameObjectHelper {
    private final Client client;
    
    public GameObjectHelper(Client client) {
        this.client = client;
    }
    
    /**
     * Gets game object IDs by name in the current scene.
     */
    public List<Integer> getGameObjectIdsByName(String name) {
        List<Integer> foundObjectIds = new ArrayList<>();
        WorldView top_wv = client.getTopLevelWorldView();
        Tile[][][] tiles = top_wv.getScene().getTiles();
        
        for (int x = 0; x < Constants.SCENE_SIZE; x++) {
            for (int y = 0; y < Constants.SCENE_SIZE; y++) {
                Tile tile = tiles[top_wv.getPlane()][x][y];
                if (tile == null) {
                    continue;
                }
                
                for (GameObject gameObject : tile.getGameObjects()) {
                    if (gameObject != null) {
                        ObjectComposition objectComposition = client.getObjectDefinition(gameObject.getId());
                        if (objectComposition != null && objectComposition.getName().equals(name)) {
                            foundObjectIds.add(gameObject.getId());
                        }
                    }
                }
            }
        }
        
        return foundObjectIds;
    }
}


package com.easyfarming.overlays.utils;

import com.easyfarming.utils.Constants;
import net.runelite.api.Client;
import net.runelite.api.widgets.Widget;

/**
 * Utility class for widget-related operations.
 */
public class WidgetHelper {
    private final Client client;
    
    public WidgetHelper(Client client) {
        this.client = client;
    }
    
    /**
     * Gets the child index of a widget by searching for text after a colon.
     */
    public int getChildIndex(String searchText, Widget parentWidget) {
        if (parentWidget == null) {
            return -1;
        }
        
        Widget[] children = parentWidget.getChildren();
        
        if (children == null) {
            return -1;
        }
        
        for (int index = 0; index < children.length; index++) {
            Widget child = children[index];
            String text = child.getText();
            
            if (text != null) {
                int colonIndex = text.indexOf(':');
                
                if (colonIndex != -1 && colonIndex + 1 < text.length()) {
                    String textAfterColon = text.substring(colonIndex + 1).trim();
                    
                    if (textAfterColon.equals(searchText)) {
                        return index;
                    }
                }
            }
        }
        
        return -1;
    }
    
    /**
     * Gets the child index for Portal Nexus widget.
     */
    public int getChildIndexPortalNexus(String searchText) {
        return getChildIndex(
            searchText,
            client.getWidget(Constants.WIDGET_PORTAL_NEXUS_PARENT, Constants.WIDGET_PORTAL_NEXUS_CHILD)
        );
    }
    
    /**
     * Gets the child index for Spirit Tree widget.
     */
    public int getChildIndexSpiritTree(String searchText) {
        return getChildIndex(
            searchText,
            client.getWidget(Constants.INTERFACE_SPIRIT_TREE, Constants.INTERFACE_SPIRIT_TREE_CHILD)
        );
    }
    
    /**
     * Checks if an interface is open.
     */
    public boolean isInterfaceOpen(int groupId, int childId) {
        Widget widget = client.getWidget(groupId, childId);
        return widget != null && !widget.isHidden();
    }
    
    /**
     * Dynamically detects the correct spellbook tab interface ID based on the current client mode.
     * @return The child ID for the magic spellbook tab, or -1 if not found
     */
    public int getSpellbookTabChildId() {
        if (isInterfaceOpen(161, 65)) {
            return 65;
        }
        if (isInterfaceOpen(164, 58)) {
            return 58;
        }
        if (isInterfaceOpen(161, 58)) {
            return 58;
        }
        if (isInterfaceOpen(164, 65)) {
            return 65;
        }
        return 65;
    }
    
    /**
     * Gets the correct group ID for the spellbook tab based on the current client mode.
     * @return The group ID for the spellbook tab
     */
    public int getSpellbookTabGroupId() {
        if (isInterfaceOpen(161, 65)) {
            return 161;
        }
        if (isInterfaceOpen(164, 58)) {
            return 164;
        }
        if (isInterfaceOpen(161, 58)) {
            return 161;
        }
        if (isInterfaceOpen(164, 65)) {
            return 164;
        }
        return 161;
    }
}


package com.easyfarming.overlays.utils;

import com.easyfarming.EasyFarmingConfig;
import java.awt.Color;

/**
 * Provides color computation from config values.
 * Colors are computed dynamically to reflect config changes.
 */
public class ColorProvider {
    private final EasyFarmingConfig config;
    
    public ColorProvider(EasyFarmingConfig config) {
        this.config = config;
    }
    
    /**
     * Gets the left-click color with alpha applied.
     */
    public Color getLeftClickColorWithAlpha() {
        return new Color(
            config.highlightLeftClickColor().getRed(),
            config.highlightLeftClickColor().getGreen(),
            config.highlightLeftClickColor().getBlue(),
            config.highlightAlpha()
        );
    }
    
    /**
     * Gets the right-click color with alpha applied.
     */
    public Color getRightClickColorWithAlpha() {
        return new Color(
            config.highlightRightClickColor().getRed(),
            config.highlightRightClickColor().getGreen(),
            config.highlightRightClickColor().getBlue(),
            config.highlightAlpha()
        );
    }
    
    /**
     * Gets the use-item color with alpha applied.
     */
    public Color getHighlightUseItemWithAlpha() {
        return new Color(
            config.highlightUseItemColor().getRed(),
            config.highlightUseItemColor().getGreen(),
            config.highlightUseItemColor().getBlue(),
            config.highlightAlpha()
        );
    }
}


package com.easyfarming.overlays.highlighting;

import com.easyfarming.overlays.utils.ColorProvider;
import net.runelite.api.Client;
import net.runelite.api.Menu;
import net.runelite.api.MenuEntry;
import net.runelite.client.util.ColorUtil;

import javax.inject.Inject;
import java.awt.*;

/**
 * Handles highlighting of menu entries (right-click options).
 */
public class MenuHighlighter {
    private final Client client;
    private final ColorProvider colorProvider;
    
    @Inject
    public MenuHighlighter(Client client, ColorProvider colorProvider) {
        this.client = client;
        this.colorProvider = colorProvider;
    }
    
    /**
     * Highlights a right-click menu option.
     */
    public void highlightRightClickOption(Graphics2D graphics, String option) {
        Menu menu = client.getMenu();
        MenuEntry[] menuEntries = menu.getMenuEntries();
        Color color = colorProvider.getRightClickColorWithAlpha();
        
        for (int i = 0; i < menuEntries.length; i++) {
            MenuEntry entry = menuEntries[i];
            String optionText = entry.getOption();
            
            if (optionText.equalsIgnoreCase(option)) {
                String highlightedText = ColorUtil.prependColorTag(">>> " + optionText, color);
                entry.setOption(highlightedText);
                menu.setMenuEntries(menuEntries);
                break;
            }
        }
    }
}


package com.easyfarming.overlays.highlighting;

import com.easyfarming.EasyFarmingConfig;
import com.easyfarming.overlays.utils.ColorProvider;
import com.easyfarming.overlays.utils.PatchStateChecker;
import com.easyfarming.utils.Constants;
import net.runelite.api.Client;
import net.runelite.api.gameval.ItemID;
import net.runelite.api.widgets.Widget;

import javax.inject.Inject;
import java.awt.*;

/**
 * Handles highlighting of compost and compost withdrawal from Tool Leprechaun.
 */
public class CompostHighlighter {
    private final Client client;
    private final EasyFarmingConfig config;
    private final ItemHighlighter itemHighlighter;
    private final PatchHighlighter patchHighlighter;
    private final NPCHighlighter npcHighlighter;
    private final WidgetHighlighter widgetHighlighter;
    private final PatchStateChecker patchStateChecker;
    private final ColorProvider colorProvider;
    
    @Inject
    public CompostHighlighter(Client client, EasyFarmingConfig config, 
                             ItemHighlighter itemHighlighter, PatchHighlighter patchHighlighter,
                             NPCHighlighter npcHighlighter, WidgetHighlighter widgetHighlighter,
                             PatchStateChecker patchStateChecker, ColorProvider colorProvider) {
        this.client = client;
        this.config = config;
        this.itemHighlighter = itemHighlighter;
        this.patchHighlighter = patchHighlighter;
        this.npcHighlighter = npcHighlighter;
        this.widgetHighlighter = widgetHighlighter;
        this.patchStateChecker = patchStateChecker;
        this.colorProvider = colorProvider;
    }
    
    /**
     * Highlights compost in inventory and patches, or withdraws from Tool Leprechaun if not in inventory.
     */
    public void highlightCompost(Graphics2D graphics, boolean herbRun, boolean treeRun, 
                                boolean fruitTreeRun, int subCase) {
        Integer compostId = itemHighlighter.selectedCompostID();
        Color color = colorProvider.getHighlightUseItemWithAlpha();
        
        if (itemHighlighter.isItemInInventory(compostId)) {
            if (herbRun) {
                if (subCase == 1) {
                    patchHighlighter.highlightHerbPatches(graphics, color);
                } else if (subCase == 2) {
                    patchHighlighter.highlightFlowerPatches(graphics, color);
                }
            }
            
            if (treeRun) {
                patchHighlighter.highlightTreePatches(graphics, color);
            }
            
            if (fruitTreeRun) {
                patchHighlighter.highlightFruitTreePatches(graphics, color);
            }
            
            itemHighlighter.itemHighlight(graphics, compostId, color);
        } else {
            withdrawCompost(graphics);
        }
    }
    
    /**
     * Highlights compost without subCase parameter (for backward compatibility).
     */
    public void highlightCompost(Graphics2D graphics, boolean herbRun, boolean treeRun, boolean fruitTreeRun) {
        highlightCompost(graphics, herbRun, treeRun, fruitTreeRun, 1);
    }
    
    /**
     * Highlights the Tool Leprechaun and interface for withdrawing compost.
     */
    public void withdrawCompost(Graphics2D graphics) {
        if (!isInterfaceOpen(Constants.INTERFACE_TOOL_LEPRECHAUN, 0)) {
            npcHighlighter.highlightNpc(graphics, "Tool Leprechaun");
        } else {
            Integer compostId = itemHighlighter.selectedCompostID();
            if (compostId == ItemID.BUCKET_COMPOST) {
                widgetHighlighter.interfaceOverlay(Constants.INTERFACE_TOOL_LEPRECHAUN, 17).render(graphics);
            } else if (compostId == ItemID.BUCKET_SUPERCOMPOST) {
                widgetHighlighter.interfaceOverlay(Constants.INTERFACE_TOOL_LEPRECHAUN, 18).render(graphics);
            } else if (compostId == ItemID.BUCKET_ULTRACOMPOST) {
                widgetHighlighter.interfaceOverlay(Constants.INTERFACE_TOOL_LEPRECHAUN, 19).render(graphics);
            } else if (compostId == ItemID.BOTTOMLESS_COMPOST_BUCKET) {
                widgetHighlighter.interfaceOverlay(Constants.INTERFACE_TOOL_LEPRECHAUN, 15).render(graphics);
            }
        }
    }
    
    private boolean isInterfaceOpen(int groupId, int childId) {
        Widget widget = client.getWidget(groupId, childId);
        return widget != null && !widget.isHidden();
    }
}


package com.easyfarming.overlays.highlighting;

import com.easyfarming.EasyFarmingOverlay;
import com.easyfarming.EasyFarmingPlugin;
import com.easyfarming.InventoryTabChecker;
import com.easyfarming.core.Teleport;
import com.easyfarming.overlays.utils.ColorProvider;
import com.easyfarming.overlays.utils.GameObjectHelper;
import com.easyfarming.overlays.utils.WidgetHelper;
import com.easyfarming.utils.Constants;
import net.runelite.api.Client;
import net.runelite.api.gameval.VarClientID;
import net.runelite.api.widgets.Widget;

import javax.inject.Inject;
import java.awt.*;
import java.util.List;

/**
 * Handles highlighting of teleport methods (items, spellbook, portal nexus, spirit tree, etc.).
 */
public class TeleportHighlighter {
    private final Client client;
    private final EasyFarmingPlugin plugin;
    private final EasyFarmingOverlay easyFarmingOverlay;
    private final ItemHighlighter itemHighlighter;
    private final WidgetHighlighter widgetHighlighter;
    private final GameObjectHighlighter gameObjectHighlighter;
    private final WidgetHelper widgetHelper;
    private final GameObjectHelper gameObjectHelper;
    private final ColorProvider colorProvider;
    
    @Inject
    public TeleportHighlighter(Client client, EasyFarmingPlugin plugin, EasyFarmingOverlay easyFarmingOverlay,
                               ItemHighlighter itemHighlighter, WidgetHighlighter widgetHighlighter,
                               GameObjectHighlighter gameObjectHighlighter, WidgetHelper widgetHelper,
                               GameObjectHelper gameObjectHelper, ColorProvider colorProvider) {
        this.client = client;
        this.plugin = plugin;
        this.easyFarmingOverlay = easyFarmingOverlay;
        this.itemHighlighter = itemHighlighter;
        this.widgetHighlighter = widgetHighlighter;
        this.gameObjectHighlighter = gameObjectHighlighter;
        this.widgetHelper = widgetHelper;
        this.gameObjectHelper = gameObjectHelper;
        this.colorProvider = colorProvider;
    }
    
    /**
     * Highlights the appropriate teleport method based on category.
     */
    public void highlightTeleportMethod(Teleport teleport, Graphics2D graphics) {
        Color leftColor = colorProvider.getLeftClickColorWithAlpha();
        Color rightColor = colorProvider.getRightClickColorWithAlpha();
        
        switch (teleport.getCategory()) {
            case ITEM:
                // Check if it's a Quetzal whistle (left-click teleport)
                if (easyFarmingOverlay.isQuetzalWhistle(teleport.getId())) {
                    itemHighlighter.itemHighlight(graphics, teleport.getId(), leftColor);
                } else {
                    itemHighlighter.itemHighlight(graphics, teleport.getId(), rightColor);
                    if (!teleport.getRightClickOption().equals("null")) {
                        // MenuHighlighter would be needed here, but we'll handle it in the calling code
                    }
                }
                break;
            case SPELLBOOK:
                InventoryTabChecker.TabState tabState = InventoryTabChecker.checkTab(client, VarClientID.TOPLEVEL_PANEL);
                if (tabState == InventoryTabChecker.TabState.SPELLBOOK) {
                    widgetHighlighter.interfaceOverlay(teleport.getInterfaceGroupId(), teleport.getInterfaceChildId()).render(graphics);
                } else {
                    widgetHighlighter.interfaceOverlay(widgetHelper.getSpellbookTabGroupId(), widgetHelper.getSpellbookTabChildId()).render(graphics);
                }
                break;
            case PORTAL_NEXUS:
                if (!widgetHelper.isInterfaceOpen(17, 0)) {
                    List<Integer> portalNexusIds = gameObjectHelper.getGameObjectIdsByName("Portal Nexus");
                    for (Integer objectId : portalNexusIds) {
                        gameObjectHighlighter.highlightGameObject(objectId, leftColor).render(graphics);
                    }
                } else {
                    Widget widget = client.getWidget(Constants.INTERFACE_PORTAL_NEXUS, Constants.INTERFACE_PORTAL_NEXUS_CHILD);
                    int index = widgetHelper.getChildIndexPortalNexus(teleport.getPoint().toString());
                    widgetHighlighter.highlightDynamicComponent(graphics, widget, index);
                }
                break;
            case SPIRIT_TREE:
                if (!widgetHelper.isInterfaceOpen(187, 3)) {
                    List<Integer> spiritTreeIds = Constants.SPIRIT_TREE_IDS;
                    for (Integer objectId : spiritTreeIds) {
                        gameObjectHighlighter.highlightGameObject(objectId, leftColor).render(graphics);
                    }
                } else {
                    Widget widget = client.getWidget(Constants.INTERFACE_SPIRIT_TREE, Constants.INTERFACE_SPIRIT_TREE_CHILD);
                    int index = widgetHelper.getChildIndexSpiritTree(teleport.getPoint().toString());
                    widgetHighlighter.highlightDynamicComponent(graphics, widget, index);
                }
                break;
            case JEWELLERY_BOX:
                if (!widgetHelper.isInterfaceOpen(Constants.INTERFACE_JEWELLERY_BOX, 0)) {
                    List<Integer> jewelleryBoxIds = gameObjectHelper.getGameObjectIdsByName("Jewellery Box");
                    for (Integer objectId : jewelleryBoxIds) {
                        gameObjectHighlighter.highlightGameObject(objectId, leftColor).render(graphics);
                    }
                } else {
                    Widget widget = client.getWidget(Constants.INTERFACE_JEWELLERY_BOX, 0);
                    widgetHighlighter.highlightDynamicComponent(graphics, widget, 0);
                }
                break;
            case MOUNTED_XERICS:
                // Mounted Xeric's talisman handling is done in NavigationHandler
                break;
        }
    }
}


package com.easyfarming.overlays.highlighting;

import com.easyfarming.utils.Constants;
import net.runelite.api.Client;
import net.runelite.api.widgets.Widget;

import java.awt.*;
import java.util.Arrays;
import java.util.List;

/**
 * Handles highlighting of farmers for protection payments.
 */
public class FarmerHighlighter {
    private final Client client;
    private final NPCHighlighter npcHighlighter;
    private final WidgetHighlighter widgetHighlighter;
    
    public FarmerHighlighter(Client client, NPCHighlighter npcHighlighter, WidgetHighlighter widgetHighlighter) {
        this.client = client;
        this.npcHighlighter = npcHighlighter;
        this.widgetHighlighter = widgetHighlighter;
    }
    
    /**
     * Highlights farmers by name and their interface if open.
     */
    public void highlightFarmers(Graphics2D graphics, List<String> farmers) {
        if (!isInterfaceOpen(Constants.INTERFACE_FARMER, 1)) {
            for (String farmer : farmers) {
                npcHighlighter.highlightNpc(graphics, farmer);
            }
        } else {
            Widget widget = client.getWidget(Constants.INTERFACE_FARMER, 1);
            widgetHighlighter.highlightDynamicComponent(graphics, widget, 1);
        }
    }
    
    /**
     * Highlights tree farmers.
     */
    public void highlightTreeFarmers(Graphics2D graphics) {
        highlightFarmers(graphics, Arrays.asList(
            "Alain",         // Taverly
            "Fayeth",        // Lumbridge
            "Heskel",        // Falador
            "Prissy Scilla", // Gnome Stronghold
            "Rosie",         // Farming Guild
            "Treznor"        // Varrock
        ));
    }
    
    /**
     * Highlights fruit tree farmers.
     */
    public void highlightFruitTreeFarmers(Graphics2D graphics) {
        highlightFarmers(graphics, Arrays.asList(
            "Bolongo", // Gnome Stronghold
            "Ellena",  // Catherby
            "Garth",   // Brimhaven
            "Gileth",  // Tree Gnome Village
            "Liliwen", // Lletya
            "Nikkie"   // Farming Guild
        ));
    }
    
    private boolean isInterfaceOpen(int groupId, int childId) {
        Widget widget = client.getWidget(groupId, childId);
        return widget != null && !widget.isHidden();
    }
}


package com.easyfarming.overlays.highlighting;

import com.easyfarming.EasyFarmingPlugin;
import net.runelite.api.Client;
import net.runelite.api.GameObject;
import net.runelite.api.Tile;
import net.runelite.api.WorldView;
import net.runelite.client.ui.overlay.Overlay;
import com.easyfarming.utils.Constants;

import java.awt.*;
import java.util.ArrayList;
import java.util.List;

/**
 * Handles highlighting of game objects in the world.
 */
public class GameObjectHighlighter {
    private final Client client;
    private final EasyFarmingPlugin plugin;
    
    public GameObjectHighlighter(Client client, EasyFarmingPlugin plugin) {
        this.client = client;
        this.plugin = plugin;
    }
    
    /**
     * Finds all game objects with the specified ID in the current scene.
     */
    public List<GameObject> findGameObjectsByID(int objectID) {
        List<GameObject> gameObjects = new ArrayList<>();
        for (int x = 0; x < Constants.SCENE_SIZE; x++) {
            for (int y = 0; y < Constants.SCENE_SIZE; y++) {
                WorldView top_wv = client.getTopLevelWorldView();
                Tile tile = top_wv.getScene().getTiles()[top_wv.getPlane()][x][y];
                if (tile == null) {
                    continue;
                }
                
                for (GameObject gameObject : tile.getGameObjects()) {
                    if (gameObject != null && gameObject.getId() == objectID) {
                        gameObjects.add(gameObject);
                    }
                }
            }
        }
        return gameObjects;
    }
    
    /**
     * Draws the clickbox for a game object.
     */
    public void drawGameObjectClickbox(Graphics2D graphics, GameObject gameObject, Color color) {
        Shape objectClickbox = gameObject.getClickbox();
        if (objectClickbox != null) {
            graphics.setColor(color);
            graphics.draw(objectClickbox);
            graphics.setColor(new Color(color.getRed(), color.getGreen(), color.getBlue(), color.getAlpha() / 5));
            graphics.fill(objectClickbox);
        }
    }
    
    /**
     * Creates an overlay that highlights a game object by ID.
     */
    public Overlay highlightGameObject(int objectId, Color color) {
        return new Overlay() {
            @Override
            public Dimension render(Graphics2D graphics) {
                Client client = plugin.getClient();
                if (client != null) {
                    List<GameObject> gameObjects = findGameObjectsByID(objectId);
                    for (GameObject gameObject : gameObjects) {
                        drawGameObjectClickbox(graphics, gameObject, color);
                    }
                }
                return null;
            }
        };
    }
}


package com.easyfarming.overlays.highlighting;

import com.easyfarming.EasyFarmingPlugin;
import com.easyfarming.overlays.utils.ColorProvider;
import net.runelite.api.Client;
import net.runelite.api.DecorativeObject;
import net.runelite.api.Tile;
import net.runelite.api.WorldView;
import net.runelite.client.ui.overlay.Overlay;

import javax.inject.Inject;
import java.awt.*;
import java.util.ArrayList;
import java.util.List;

/**
 * Handles highlighting of decorative objects in the world.
 */
public class DecorativeObjectHighlighter {
    private final Client client;
    private final EasyFarmingPlugin plugin;
    private final ColorProvider colorProvider;
    
    @Inject
    public DecorativeObjectHighlighter(Client client, EasyFarmingPlugin plugin, ColorProvider colorProvider) {
        this.client = client;
        this.plugin = plugin;
        this.colorProvider = colorProvider;
    }
    
    /**
     * Finds all decorative objects with the specified ID in the current scene.
     */
    public List<DecorativeObject> findDecorativeObjectsByID(int objectId) {
        Client client = this.client;
        List<DecorativeObject> foundDecorativeObjects = new ArrayList<>();
        
        if (client != null) {
            WorldView top_wv = client.getTopLevelWorldView();
            Tile[][][] tiles = top_wv.getScene().getTiles();
            for (int plane = 0; plane < tiles.length; plane++) {
                for (int x = 0; x < tiles[plane].length; x++) {
                    for (int y = 0; y < tiles[plane][x].length; y++) {
                        Tile tile = tiles[plane][x][y];
                        if (tile != null) {
                            DecorativeObject decorativeObject = tile.getDecorativeObject();
                            if (decorativeObject != null && decorativeObject.getId() == objectId) {
                                foundDecorativeObjects.add(decorativeObject);
                            }
                        }
                    }
                }
            }
        }
        
        return foundDecorativeObjects;
    }
    
    /**
     * Draws the clickbox for a decorative object.
     */
    public void drawDecorativeObjectClickbox(Graphics2D graphics, DecorativeObject decorativeObject, Color color) {
        Shape clickbox = decorativeObject.getClickbox();
        if (clickbox != null) {
            graphics.setColor(color);
            graphics.draw(clickbox);
            graphics.setColor(new Color(color.getRed(), color.getGreen(), color.getBlue(), 50));
            graphics.fill(clickbox);
        }
    }
    
    /**
     * Creates an overlay that highlights a decorative object by ID.
     */
    public Overlay highlightDecorativeObject(int objectId) {
        return new Overlay() {
            @Override
            public Dimension render(Graphics2D graphics) {
                Client client = plugin.getClient();
                if (client != null) {
                    Color color = colorProvider.getLeftClickColorWithAlpha();
                    List<DecorativeObject> decorativeObjects = findDecorativeObjectsByID(objectId);
                    for (DecorativeObject decorativeObject : decorativeObjects) {
                        drawDecorativeObjectClickbox(graphics, decorativeObject, color);
                    }
                }
                return null;
            }
        };
    }
}


package com.easyfarming.overlays.highlighting;

import com.easyfarming.overlays.utils.ColorProvider;
import net.runelite.api.Client;
import net.runelite.api.IndexedObjectSet;
import net.runelite.api.NPC;

import javax.inject.Inject;
import java.awt.*;
import java.util.List;

/**
 * Handles highlighting of NPCs in the world.
 */
public class NPCHighlighter {
    private final Client client;
    private final ColorProvider colorProvider;
    
    @Inject
    public NPCHighlighter(Client client, ColorProvider colorProvider) {
        this.client = client;
        this.colorProvider = colorProvider;
    }
    
    /**
     * Highlights an NPC by name.
     */
    public void highlightNpc(Graphics2D graphics, String npcName) {
        IndexedObjectSet<? extends NPC> npcs = client.getTopLevelWorldView().npcs();
        
        if (npcs != null) {
            Color color = colorProvider.getLeftClickColorWithAlpha();
            for (NPC npc : npcs) {
                if (npc != null && npc.getName() != null && npc.getName().equals(npcName)) {
                    Polygon tilePolygon = npc.getCanvasTilePoly();
                    
                    if (tilePolygon != null) {
                        graphics.setColor(color);
                        graphics.draw(tilePolygon);
                        graphics.setColor(new Color(color.getRed(), 
                                                   color.getGreen(), 
                                                   color.getBlue(), 
                                                   color.getAlpha() / 5));
                        graphics.fill(tilePolygon);
                    }
                }
            }
        }
    }
    
    /**
     * Highlights multiple NPCs by name.
     */
    public void highlightNpcs(Graphics2D graphics, List<String> npcNames) {
        for (String npcName : npcNames) {
            highlightNpc(graphics, npcName);
        }
    }
}


package com.easyfarming.overlays.highlighting;

import com.easyfarming.EasyFarmingOverlay;
import com.easyfarming.EasyFarmingConfig;
import com.easyfarming.overlays.utils.ColorProvider;
import net.runelite.api.Client;
import net.runelite.api.Item;
import net.runelite.api.gameval.InventoryID;
import net.runelite.api.gameval.InterfaceID;
import net.runelite.api.gameval.ItemID;
import net.runelite.api.widgets.Widget;

import javax.inject.Inject;
import java.awt.*;
import java.util.List;

/**
 * Handles highlighting of items in inventory and various item-related highlights.
 */
public class ItemHighlighter {
    private final Client client;
    private final EasyFarmingOverlay farmingHelperOverlay;
    private final EasyFarmingConfig config;
    private final ColorProvider colorProvider;
    
    @Inject
    public ItemHighlighter(Client client, EasyFarmingOverlay farmingHelperOverlay, 
                          EasyFarmingConfig config, ColorProvider colorProvider) {
        this.client = client;
        this.farmingHelperOverlay = farmingHelperOverlay;
        this.config = config;
        this.colorProvider = colorProvider;
    }
    
    /**
     * Highlights an item in the inventory by its ID.
     */
    public void itemHighlight(Graphics2D graphics, int itemID, Color color) {
        net.runelite.api.ItemContainer inventory = client.getItemContainer(InventoryID.INV);
        
        if (inventory != null) {
            Item[] items = inventory.getItems();
            
            Widget inventoryWidget = client.getWidget(InterfaceID.INVENTORY);
            if (inventoryWidget == null) {
                inventoryWidget = client.getWidget(149, 0);
            }
            
            if (inventoryWidget != null) {
                Widget[] children = inventoryWidget.getChildren();
                Widget[] dynamicChildren = inventoryWidget.getDynamicChildren();
                
                Widget[] childrenToUse = (dynamicChildren != null && dynamicChildren.length > 0) ? dynamicChildren : children;
                
                if (childrenToUse != null) {
                    for (int i = 0; i < items.length && i < childrenToUse.length; i++) {
                        Item item = items[i];
                        
                        if (item != null && (item.getId() == itemID || 
                            isQuetzalWhistleHighlight(item.getId(), itemID) ||
                            isExplorersRingHighlight(item.getId(), itemID) ||
                            isArdyCloakHighlight(item.getId(), itemID))) {
                            Widget itemWidget = childrenToUse[i];
                            if (itemWidget != null) {
                                Rectangle bounds = itemWidget.getBounds();
                                if (bounds != null && bounds.width > 0 && bounds.height > 0) {
                                    graphics.setColor(new Color(color.getRed(), color.getGreen(), color.getBlue(), 100));
                                    graphics.fill(bounds);
                                    graphics.setColor(color);
                                    graphics.draw(bounds);
                                }
                            }
                        }
                    }
                }
            }
        }
    }
    
    /**
     * Checks if an item ID matches a quetzal whistle highlight pattern.
     */
    private boolean isQuetzalWhistleHighlight(int itemId, int targetId) {
        return farmingHelperOverlay.isQuetzalWhistle(itemId) && farmingHelperOverlay.isQuetzalWhistle(targetId);
    }
    
    /**
     * Checks if an item ID matches an Explorer's Ring highlight pattern.
     */
    private boolean isExplorersRingHighlight(int itemId, int targetId) {
        return farmingHelperOverlay.isExplorersRing(itemId) && farmingHelperOverlay.isExplorersRing(targetId);
    }
    
    /**
     * Checks if an item ID matches an Ardougne Cloak highlight pattern.
     */
    private boolean isArdyCloakHighlight(int itemId, int targetId) {
        return farmingHelperOverlay.isArdyCloak(itemId) && farmingHelperOverlay.isArdyCloak(targetId);
    }
    
    /**
     * Highlights herb seeds in inventory.
     */
    public void highlightHerbSeeds(Graphics2D graphics) {
        Color color = colorProvider.getHighlightUseItemWithAlpha();
        for (Integer seedId : farmingHelperOverlay.getHerbSeedIds()) {
            itemHighlight(graphics, seedId, color);
        }
    }
    
    /**
     * Highlights tree saplings in inventory.
     */
    public void highlightTreeSapling(Graphics2D graphics) {
        Color color = colorProvider.getHighlightUseItemWithAlpha();
        for (Integer seedId : farmingHelperOverlay.getTreeSaplingIds()) {
            itemHighlight(graphics, seedId, color);
        }
    }
    
    /**
     * Highlights fruit tree saplings in inventory.
     */
    public void highlightFruitTreeSapling(Graphics2D graphics) {
        Color color = colorProvider.getHighlightUseItemWithAlpha();
        for (Integer seedId : farmingHelperOverlay.getFruitTreeSaplingIds()) {
            itemHighlight(graphics, seedId, color);
        }
    }
    
    /**
     * Highlights teleport crystals in inventory.
     */
    public void highlightTeleportCrystal(Graphics2D graphics) {
        Color color = colorProvider.getLeftClickColorWithAlpha();
        for (Integer crystalId : farmingHelperOverlay.getTeleportCrystalIds()) {
            itemHighlight(graphics, crystalId, color);
        }
    }
    
    /**
     * Highlights skills necklaces in inventory.
     */
    public void highlightSkillsNecklace(Graphics2D graphics) {
        Color color = colorProvider.getLeftClickColorWithAlpha();
        for (Integer necklaceId : farmingHelperOverlay.getSkillsNecklaceIds()) {
            itemHighlight(graphics, necklaceId, color);
        }
    }
    
    /**
     * Gets the selected compost item ID.
     */
    public Integer selectedCompostID() {
        EasyFarmingConfig.OptionEnumCompost selectedCompost = config.enumConfigCompost();
        switch (selectedCompost) {
            case Compost:
                return ItemID.BUCKET_COMPOST;
            case Supercompost:
                return ItemID.BUCKET_SUPERCOMPOST;
            case Ultracompost:
                return ItemID.BUCKET_ULTRACOMPOST;
            case Bottomless:
                return ItemID.BOTTOMLESS_COMPOST_BUCKET;
        }
        return -1;
    }
    
    /**
     * Checks if an item is in the inventory.
     */
    public boolean isItemInInventory(int itemId) {
        net.runelite.api.ItemContainer inventory = client.getItemContainer(InventoryID.INV);
        
        Item[] items;
        if (inventory == null || inventory.getItems() == null) {
            items = new Item[0];
        } else {
            items = inventory.getItems();
        }
        
        for (Item item : items) {
            if (item.getId() == itemId) {
                return true;
            }
        }
        
        return false;
    }
}


package com.easyfarming.overlays.highlighting;

import com.easyfarming.overlays.utils.ColorProvider;
import net.runelite.api.Client;
import net.runelite.api.widgets.Widget;
import net.runelite.client.ui.overlay.Overlay;

import javax.inject.Inject;
import java.awt.*;

/**
 * Handles highlighting of widgets and interface components.
 */
public class WidgetHighlighter {
    private final Client client;
    private final ColorProvider colorProvider;
    
    @Inject
    public WidgetHighlighter(Client client, ColorProvider colorProvider) {
        this.client = client;
        this.colorProvider = colorProvider;
    }
    
    /**
     * Creates an overlay that highlights a widget interface.
     */
    public Overlay interfaceOverlay(int groupId, int childId) {
        return new Overlay() {
            @Override
            public Dimension render(Graphics2D graphics) {
                Client client = WidgetHighlighter.this.client;
                if (client != null) {
                    Widget widget = client.getWidget(groupId, childId);
                    if (widget != null) {
                        Rectangle bounds = widget.getBounds();
                        Color color = colorProvider.getLeftClickColorWithAlpha();
                        graphics.setColor(color);
                        
                        AlphaComposite alphaComposite = AlphaComposite.getInstance(AlphaComposite.SRC_OVER, 0.65f);
                        graphics.setComposite(alphaComposite);
                        
                        graphics.fillRect(bounds.x, bounds.y, bounds.width, bounds.height);
                        
                        graphics.setComposite(AlphaComposite.SrcOver);
                    }
                }
                return null;
            }
        };
    }
    
    /**
     * Highlights a dynamic component within a widget.
     */
    public void highlightDynamicComponent(Graphics2D graphics, Widget widget, int dynamicChildIndex) {
        if (widget != null) {
            Widget[] dynamicChildren = widget.getDynamicChildren();
            if (dynamicChildren != null && dynamicChildIndex >= 0 && dynamicChildIndex < dynamicChildren.length) {
                Widget child = dynamicChildren[dynamicChildIndex];
                if (child != null) {
                    Rectangle bounds = child.getBounds();
                    if (bounds != null && bounds.width > 0 && bounds.height > 0) {
                        Color color = colorProvider.getLeftClickColorWithAlpha();
                        graphics.setColor(color);
                        
                        AlphaComposite alphaComposite = AlphaComposite.getInstance(AlphaComposite.SRC_OVER, 0.65f);
                        graphics.setComposite(alphaComposite);
                        
                        graphics.fillRect(bounds.x, bounds.y, bounds.width, bounds.height);
                        
                        graphics.setComposite(AlphaComposite.SrcOver);
                    }
                }
            }
        }
    }
}


package com.easyfarming.overlays.highlighting;

import com.easyfarming.EasyFarmingOverlay;
import com.easyfarming.utils.Constants;
import net.runelite.api.Client;
import net.runelite.api.GameObject;
import net.runelite.client.ui.overlay.Overlay;

import javax.inject.Inject;
import java.awt.*;
import java.util.List;

/**
 * Handles highlighting of farming patches (herb, flower, tree, fruit tree).
 */
public class PatchHighlighter {
    private final Client client;
    private final EasyFarmingOverlay farmingHelperOverlay;
    private final GameObjectHighlighter gameObjectHighlighter;
    
    @Inject
    public PatchHighlighter(Client client, EasyFarmingOverlay farmingHelperOverlay, GameObjectHighlighter gameObjectHighlighter) {
        this.client = client;
        this.farmingHelperOverlay = farmingHelperOverlay;
        this.gameObjectHighlighter = gameObjectHighlighter;
    }
    
    public void highlightHerbPatches(Graphics2D graphics, Color color) {
        for (Integer patchId : farmingHelperOverlay.getHerbPatchIds()) {
            gameObjectHighlighter.highlightGameObject(patchId, color).render(graphics);
        }
    }
    
    public void highlightFlowerPatches(Graphics2D graphics, Color color) {
        for (Integer patchId : farmingHelperOverlay.getFlowerPatchIds()) {
            gameObjectHighlighter.highlightGameObject(patchId, color).render(graphics);
        }
    }
    
    public void highlightTreePatches(Graphics2D graphics, Color color) {
        for (Integer patchId : farmingHelperOverlay.getTreePatchIds()) {
            gameObjectHighlighter.highlightGameObject(patchId, color).render(graphics);
        }
    }
    
    public void highlightFruitTreePatches(Graphics2D graphics, Color color) {
        for (Integer patchId : farmingHelperOverlay.getFruitTreePatchIds()) {
            gameObjectHighlighter.highlightGameObject(patchId, color).render(graphics);
        }
    }
    
    /**
     * Highlights farming patches for a specific location.
     * @param locationName The name of the location
     * @param graphics Graphics context for highlighting
     * @param herbRun Whether this is a herb run
     * @param treeRun Whether this is a tree run
     * @param fruitTreeRun Whether this is a fruit tree run
     * @param leftClickColor Color for left-click highlights
     * @param useItemColor Color for use-item highlights
     */
    public void highlightFarmingPatchesForLocation(String locationName, Graphics2D graphics, 
                                                   boolean herbRun, boolean treeRun, boolean fruitTreeRun,
                                                   Color leftClickColor, Color useItemColor) {
        // Herb locations
        if (herbRun && (locationName.equals("Ardougne") || locationName.equals("Catherby") || 
                       locationName.equals("Falador") || locationName.equals("Farming Guild") ||
                       locationName.equals("Harmony Island") || locationName.equals("Kourend") ||
                       locationName.equals("Morytania") || locationName.equals("Troll Stronghold") ||
                       locationName.equals("Weiss") || locationName.equals("Civitas illa Fortis"))) {
            highlightHerbPatches(graphics, leftClickColor);
        }
        
        // Tree locations
        if (treeRun && (locationName.equals("Falador") || locationName.equals("Farming Guild") ||
                       locationName.equals("Gnome Stronghold") || locationName.equals("Lumbridge") ||
                       locationName.equals("Taverley") || locationName.equals("Varrock"))) {
            highlightTreePatches(graphics, leftClickColor);
        }
        
        // Fruit tree locations
        if (fruitTreeRun && (locationName.equals("Brimhaven") || locationName.equals("Catherby") ||
                            locationName.equals("Farming Guild") || locationName.equals("Gnome Stronghold") ||
                            locationName.equals("Lletya") || locationName.equals("Tree Gnome Village"))) {
            highlightFruitTreePatches(graphics, leftClickColor);
        }
    }
}


package com.easyfarming;

import java.awt.*;
import javax.inject.Inject;

import net.runelite.api.*;
import net.runelite.api.Menu;
import net.runelite.api.coords.WorldPoint;
import net.runelite.api.gameval.InterfaceID;
import net.runelite.api.gameval.InventoryID;
import net.runelite.api.gameval.VarClientID;
import net.runelite.api.widgets.Widget;
import net.runelite.client.ui.overlay.Overlay;
import net.runelite.client.ui.overlay.OverlayLayer;
import net.runelite.client.ui.overlay.OverlayPosition;
import net.runelite.api.Client;
import net.runelite.api.GameObject;
import net.runelite.client.ui.overlay.components.PanelComponent;
import net.runelite.api.gameval.ItemID;
import net.runelite.client.util.ColorUtil;
import net.runelite.api.Tile;

import java.awt.Color;
import java.awt.Shape;
import java.awt.Dimension;
import java.awt.Graphics2D;
import java.util.*;
import java.util.List;
import java.util.regex.Pattern;


public class FarmingTeleportOverlay extends Overlay {
    private final Client client;
    private final EasyFarmingPlugin plugin;
    private boolean clicked = false;
    @Inject
    private EasyFarmingConfig config;
    @Inject
    private EasyFarmingOverlay farmingHelperOverlay;
    @Inject
    private EasyFarmingOverlayInfoBox farmingHelperOverlayInfoBox;
    @Inject
    private AreaCheck areaCheck;

    private final PanelComponent panelComponent = new PanelComponent();
    public boolean patchCleared = false;

    private Color leftClickColorWithAlpha;
    private Color rightClickColorWithAlpha;
    private Color highlightUseItemWithAlpha;

    public void updateColors() {
        leftClickColorWithAlpha = new Color(
                config.highlightLeftClickColor().getRed(),
                config.highlightLeftClickColor().getGreen(),
                config.highlightLeftClickColor().getBlue(),
                config.highlightAlpha()
        );
        rightClickColorWithAlpha = new Color(
                config.highlightRightClickColor().getRed(),
                config.highlightRightClickColor().getGreen(),
                config.highlightRightClickColor().getBlue(),
                config.highlightAlpha()
        );
        highlightUseItemWithAlpha = new Color(
                config.highlightUseItemColor().getRed(),
                config.highlightUseItemColor().getGreen(),
                config.highlightUseItemColor().getBlue(),
                config.highlightAlpha()
        );
    }


    public Map<String, Boolean> herbConfigMap = new HashMap<>();


    private int previousRegionId;
    public int inventoryTabValue = 0;



    public boolean patchIsComposted() {
        String regexCompost1 = "You treat the (herb patch|flower patch|tree patch|fruit tree patch) with (compost|supercompost|ultracompost)\\.";
        String regexCompost2 = "This (herb patch|flower patch|tree patch|fruit tree patch) has already been treated with (compost|supercompost|ultracompost)\\.";
        String regexCompost3 = "You treat the patch with (compost|supercompost|ultracompost)\\.";
        String regexCompost4 = "This patch has already been treated with (compost|supercompost|ultracompost)\\.";

        String lastMessage = plugin.getLastMessage();
        if (lastMessage == null || lastMessage.isEmpty()) {
            return false;
        }

        return Pattern
            .compile(regexCompost1 + "|" + regexCompost2 + "|" + regexCompost3 + "|" + regexCompost4)
            .matcher(lastMessage)
            .matches();
    }

    public boolean patchIsProtected() {
        String standardResponse = "You pay the gardener ([0-9A-Za-z\\ ]+) to protect the patch\\.";
        String faladorEliteResponse = "The gardener protects your tree for you, free of charge, as a token of gratitude for completing the ([A-Za-z\\ ]+)\\.";

        return Pattern
            .compile(standardResponse + "|" + faladorEliteResponse)
            .matcher(plugin.getLastMessage())
            .matches();
    }

    @Inject
    public FarmingTeleportOverlay(EasyFarmingPlugin plugin, Client client, AreaCheck areaCheck) {
        this.areaCheck = areaCheck;
        setPosition(OverlayPosition.DYNAMIC);
        setLayer(OverlayLayer.ABOVE_WIDGETS);
        this.plugin = plugin;
        this.client = client;
    }

    public Overlay interfaceOverlay(int groupId, int childId) {
        return new Overlay() {
            @Override
            public Dimension render(Graphics2D graphics) {
                Client client = plugin.getClient();
                if (client != null) {
                    Widget widget = client.getWidget(groupId, childId);
                    if (widget != null) {
                        Rectangle bounds = widget.getBounds();
                        graphics.setColor(leftClickColorWithAlpha);

                        // Set the composite for transparency
                        AlphaComposite alphaComposite = AlphaComposite.getInstance(AlphaComposite.SRC_OVER, 0.65f);
                        graphics.setComposite(alphaComposite);

                        // Draw a rectangle over the widget
                        graphics.fillRect(bounds.x, bounds.y, bounds.width, bounds.height);

                        // Reset the composite back to the original
                        graphics.setComposite(AlphaComposite.SrcOver);

                    }
                }
                return null;
            }
        };
    }

    public int getChildIndex(String searchText, Widget parentWidget)
    {
        if (parentWidget == null) {
            return -1;
        }

        Widget[] children = parentWidget.getChildren();

        if (children == null) {
            return -1;
        }

        for (int index = 0; index < children.length; index++) {
            Widget child = children[index];
            String text = child.getText();

            if (text != null) {
                int colonIndex = text.indexOf(':');

                if (colonIndex != -1 && colonIndex + 1 < text.length()) {
                    String textAfterColon = text.substring(colonIndex + 1).trim();

                    if (textAfterColon.equals(searchText)) {
                        return index;
                    }
                }
            }
        }

        return -1; // Return -1 if the specified text is not found
    }

    public int getChildIndexPortalNexus(String searchText)
    {
        return getChildIndex(
            searchText,
            client.getWidget(17, 12)
        );
    }

    public int getChildIndexSpiritTree(String searchText)
    {
        return getChildIndex(
            searchText,
            client.getWidget(187, 3)
        );
    }

    public void highlightDynamicComponent(Graphics2D graphics, Widget widget, int dynamicChildIndex) {
        if (widget != null) {
            Widget[] dynamicChildren = widget.getDynamicChildren();
            if (dynamicChildren != null && dynamicChildIndex >= 0 && dynamicChildIndex < dynamicChildren.length) {
                Widget dynamicChild = dynamicChildren[dynamicChildIndex];
                if (dynamicChild != null) {
                    Rectangle bounds = dynamicChild.getBounds();
                    graphics.setColor(leftClickColorWithAlpha);
                    //graphics.draw(bounds);
                    graphics.fill(bounds);
                }
            }
        }
    }

    private boolean isQuetzalWhistleHighlight(int itemId, int targetItemId) {
        // If we're looking for a Quetzal whistle and this item is any Quetzal whistle variant
        if (targetItemId == ItemID.HG_QUETZALWHISTLE_BASIC) {
            return itemId == ItemID.HG_QUETZALWHISTLE_BASIC || 
                   itemId == ItemID.HG_QUETZALWHISTLE_ENHANCED || 
                   itemId == ItemID.HG_QUETZALWHISTLE_PERFECTED;
        }
        return false;
    }
    
    private boolean isExplorersRingHighlight(int itemId, int targetItemId) {
        // If we're looking for an Explorer's Ring and this item is any Explorer's Ring variant
        if (farmingHelperOverlay.isExplorersRing(targetItemId)) {
            return farmingHelperOverlay.isExplorersRing(itemId);
        }
        return false;
    }
    
    private boolean isArdyCloakHighlight(int itemId, int targetItemId) {
        // If we're looking for an Ardougne Cloak and this item is any Ardougne Cloak variant
        if (farmingHelperOverlay.isArdyCloak(targetItemId)) {
            return farmingHelperOverlay.isArdyCloak(itemId);
        }
        return false;
    }

    public void itemHighlight(Graphics2D graphics, int itemID, Color color) {
        ItemContainer inventory = client.getItemContainer(InventoryID.INV);

        if (inventory != null) {
            Item[] items = inventory.getItems();
            
            // Try multiple widget access methods
            Widget inventoryWidget = client.getWidget(InterfaceID.INVENTORY);
            if (inventoryWidget == null) {
                // Fallback to direct widget access
                inventoryWidget = client.getWidget(149, 0);
            }
            
            if (inventoryWidget == null) {
                // Another fallback - try the inventory interface directly
                inventoryWidget = client.getWidget(149, 0);
            }

            if (inventoryWidget != null) {
                // Try both children and dynamic children
                Widget[] children = inventoryWidget.getChildren();
                Widget[] dynamicChildren = inventoryWidget.getDynamicChildren();
                
                // Use dynamic children if available, otherwise use regular children
                Widget[] childrenToUse = (dynamicChildren != null && dynamicChildren.length > 0) ? dynamicChildren : children;
                
                if (childrenToUse != null) {
                    for (int i = 0; i < items.length && i < childrenToUse.length; i++) {
                        Item item = items[i];

                        if (item != null && (item.getId() == itemID || 
                            isQuetzalWhistleHighlight(item.getId(), itemID) ||
                            isExplorersRingHighlight(item.getId(), itemID) ||
                            isArdyCloakHighlight(item.getId(), itemID))) {
                            Widget itemWidget = childrenToUse[i];
                            if (itemWidget != null) {
                                Rectangle bounds = itemWidget.getBounds();
                                if (bounds != null && bounds.width > 0 && bounds.height > 0) {
                                    // Use a more visible highlighting approach
                                    graphics.setColor(new Color(color.getRed(), color.getGreen(), color.getBlue(), 100));
                                    graphics.fill(bounds);
                                    graphics.setColor(color);
                                    graphics.draw(bounds);
                                }
                            }
                        }
                    }
                }
            }
        }
    }

    private List<GameObject> findGameObjectsByID(int objectID) {
        List<GameObject> gameObjects = new ArrayList<>();
        for (int x = 0; x < Constants.SCENE_SIZE; x++) {
            for (int y = 0; y < Constants.SCENE_SIZE; y++) {
                WorldView top_wv = client.getTopLevelWorldView();
                Tile tile = top_wv.getScene().getTiles()[top_wv.getPlane()][x][y];
                if (tile == null) {
                    continue;
                }

                for (GameObject gameObject : tile.getGameObjects()) {
                    if (gameObject != null && gameObject.getId() == objectID) {
                        gameObjects.add(gameObject);
                    }
                }
            }
        }
        return gameObjects;
    }

    private void drawGameObjectClickbox(Graphics2D graphics, GameObject gameObject, Color color) {
        Shape objectClickbox = gameObject.getClickbox();
        if (objectClickbox != null) {
            graphics.setColor(color);
            graphics.draw(objectClickbox);
            graphics.setColor(new Color(color.getRed(), color.getGreen(), color.getBlue(), color.getAlpha() / 5));
            graphics.fill(objectClickbox);
        }
    }

    public Overlay gameObjectOverlay(int objectId, Color color) {
        return new Overlay() {
            @Override
            public Dimension render(Graphics2D graphics) {
                Client client = plugin.getClient();
                if (client != null) {
                    List<GameObject> gameObjects = findGameObjectsByID(objectId);
                    for (GameObject gameObject : gameObjects) {
                        drawGameObjectClickbox(graphics, gameObject, color);
                    }
                }
                return null;
            }
        };
    }

    public List<DecorativeObject> findDecorativeObjectsByID(int objectId) {
        Client client = plugin.getClient();
        List<DecorativeObject> foundDecorativeObjects = new ArrayList<>();

        if (client != null) {
            WorldView top_wv = client.getTopLevelWorldView();
            Tile[][][] tiles = top_wv.getScene().getTiles();
            for (int plane = 0; plane < tiles.length; plane++) {
                for (int x = 0; x < tiles[plane].length; x++) {
                    for (int y = 0; y < tiles[plane][x].length; y++) {
                        Tile tile = tiles[plane][x][y];
                        if (tile != null) {
                            DecorativeObject decorativeObject = tile.getDecorativeObject();
                            if (decorativeObject != null && decorativeObject.getId() == objectId) {
                                foundDecorativeObjects.add(decorativeObject);
                            }
                        }
                    }
                }
            }
        }

        return foundDecorativeObjects;
    }

    public Overlay decorativeObjectOverlay(int objectId) {
        return new Overlay() {
            @Override
            public Dimension render(Graphics2D graphics) {
                Client client = plugin.getClient();
                if (client != null) {
                    List<DecorativeObject> decorativeObjects = findDecorativeObjectsByID(objectId);
                    for (DecorativeObject decorativeObject : decorativeObjects) {
                        drawDecorativeObjectClickbox(graphics, decorativeObject, leftClickColorWithAlpha);
                    }
                }
                return null;
            }
        };
    }


    public void drawDecorativeObjectClickbox(Graphics2D graphics, DecorativeObject decorativeObject, Color color) {
        Shape clickbox = decorativeObject.getClickbox();
        if (clickbox != null) {
            graphics.setColor(color);
            graphics.draw(clickbox);
            graphics.setColor(new Color(color.getRed(), color.getGreen(), color.getBlue(), 50));
            graphics.fill(clickbox);
        }
    }

    public void highlightRightClickOption(Graphics2D graphics, String option) {
        // Get the menu entries
        Menu menu = client.getMenu();
        MenuEntry[] menuEntries = menu.getMenuEntries();

        for (int i = 0; i < menuEntries.length; i++) {
            MenuEntry entry = menuEntries[i];
            String optionText = entry.getOption();

            // Check if the option text matches the desired option
            if (optionText.equalsIgnoreCase(option)) {
                // Modify the menu entry to include a highlight
                String highlightedText = ColorUtil.prependColorTag(">>> " + optionText, rightClickColorWithAlpha);
                entry.setOption(highlightedText);
                menu.setMenuEntries(menuEntries);
                break;
            }
        }
    }

    public void highlightNpc(Graphics2D graphics, String npcName) {
        IndexedObjectSet<? extends NPC> npcs = client.getTopLevelWorldView().npcs();

        if (npcs != null) {
            for (NPC npc : npcs) {
                if (npc != null && npc.getName() != null && npc.getName().equals(npcName)) {
                    Polygon tilePolygon = npc.getCanvasTilePoly();

                    if (tilePolygon != null) {
                        graphics.setColor(leftClickColorWithAlpha);
                        graphics.draw(tilePolygon);
                        //graphics.setColor(new Color(color.getRed(), color.getGreen(), color.getBlue()));
                        graphics.fill(tilePolygon);
                    }
                }
            }
        }
    }


    private boolean isInterfaceOpen(int groupId, int childId) {
        Widget widget = client.getWidget(groupId, childId);
        return widget != null && !widget.isHidden();
    }

    /**
     * Dynamically detects the correct spellbook tab interface ID based on the current client mode
     * @return The child ID for the magic spellbook tab, or -1 if not found
     */
    private int getSpellbookTabChildId() {
        // Try resizable classic mode first (161.65)
        if (isInterfaceOpen(161, 65)) {
            return 65;
        }
        // Try pre-EOC mode (164.58)
        if (isInterfaceOpen(164, 58)) {
            return 58;
        }
        // Try other possible variations
        if (isInterfaceOpen(161, 58)) {
            return 58;
        }
        if (isInterfaceOpen(164, 65)) {
            return 65;
        }
        // Default fallback to resizable classic mode
        return 65;
    }

    /**
     * Gets the correct group ID for the spellbook tab based on the current client mode
     * @return The group ID for the spellbook tab
     */
    private int getSpellbookTabGroupId() {
        // Try resizable classic mode first (161.65)
        if (isInterfaceOpen(161, 65)) {
            return 161;
        }
        // Try pre-EOC mode (164.58)
        if (isInterfaceOpen(164, 58)) {
            return 164;
        }
        // Try other possible variations
        if (isInterfaceOpen(161, 58)) {
            return 161;
        }
        if (isInterfaceOpen(164, 65)) {
            return 164;
        }
        // Default fallback to resizable classic mode
        return 161;
    }

    /**
     * Enhanced location detection that handles edge cases and adapts to player's current situation
     * @param location The target location
     * @param teleport The selected teleport method
     * @return true if player should proceed to farming phase, false if still navigating
     */
    private boolean shouldProceedToFarming(Location location, Location.Teleport teleport) {
        int currentRegionId = client.getLocalPlayer().getWorldLocation().getRegionID();
        WorldPoint playerLocation = client.getLocalPlayer().getWorldLocation();
        WorldPoint targetLocation = teleport.getPoint();
        
        // Check if player is in the correct region
        boolean inCorrectRegion = (currentRegionId == teleport.getRegionId());
        
        // Check if player is near the target location (within 20 tiles)
        boolean nearTarget = areaCheck.isPlayerWithinArea(targetLocation, 20);
        
        // Check if player is very close to the farming patch (within 5 tiles)
        boolean nearPatch = areaCheck.isPlayerWithinArea(targetLocation, 5);
        
        // Adaptive logic for different scenarios:
        
        // Scenario 1: Player is very close to the patch - proceed to farming regardless of teleport method
        if (nearPatch) {
            return true;
        }
        
        // Scenario 2: Player is in correct region and reasonably close - proceed to farming
        if (inCorrectRegion && nearTarget) {
            return true;
        }
        
        // Scenario 3: Player is in correct region but far from target - might have skipped teleport step
        // Check if there are any farming patches nearby that match this location type
        if (inCorrectRegion && !nearTarget) {
            // Check if player is near any farming patches of the same type
            if (isNearAnyFarmingPatch(location.getName())) {
                return true;
            }
        }
        
        // Scenario 4: Player is in wrong region but very close to target - might have used different teleport
        if (!inCorrectRegion && nearTarget) {
            return true;
        }
        
        // Default: Continue with normal navigation
        return false;
    }
    
    /**
     * Checks if player is near any farming patches of the specified type
     * @param locationName The name of the location to check for
     * @return true if player is near any farming patch of this type
     */
    private boolean isNearAnyFarmingPatch(String locationName) {
        WorldPoint playerLocation = client.getLocalPlayer().getWorldLocation();
        
        // Define farming patch locations for each area
        switch (locationName) {
            case "Ardougne":
                // Check if near Ardougne herb patch
                return areaCheck.isPlayerWithinArea(new WorldPoint(2670, 3374, 0), 10);
            case "Catherby":
                // Check if near Catherby herb patch
                return areaCheck.isPlayerWithinArea(new WorldPoint(2813, 3463, 0), 10);
            case "Falador":
                // Check if near Falador herb patch
                return areaCheck.isPlayerWithinArea(new WorldPoint(3058, 3307, 0), 10);
            case "Civitas illa Fortis":
                // Check if near Civitas herb patch
                return areaCheck.isPlayerWithinArea(new WorldPoint(1586, 3099, 0), 10);
            case "Farming Guild":
                // Check if near Farming Guild patches
                return areaCheck.isPlayerWithinArea(new WorldPoint(1238, 3726, 0), 15) ||
                       areaCheck.isPlayerWithinArea(new WorldPoint(1232, 3736, 0), 15) ||
                       areaCheck.isPlayerWithinArea(new WorldPoint(1243, 3759, 0), 15);
            case "Brimhaven":
                // Check if near Brimhaven fruit tree patch
                return areaCheck.isPlayerWithinArea(new WorldPoint(2764, 3212, 0), 10);
            case "Gnome Stronghold":
                // Check if near Gnome Stronghold patches
                return areaCheck.isPlayerWithinArea(new WorldPoint(2436, 3415, 0), 10) ||
                       areaCheck.isPlayerWithinArea(new WorldPoint(2475, 3446, 0), 10);
            case "Lumbridge":
                // Check if near Lumbridge tree patch
                return areaCheck.isPlayerWithinArea(new WorldPoint(3193, 3231, 0), 10);
            case "Taverley":
                // Check if near Taverley tree patch
                return areaCheck.isPlayerWithinArea(new WorldPoint(2936, 3438, 0), 10);
            case "Varrock":
                // Check if near Varrock tree patch
                return areaCheck.isPlayerWithinArea(new WorldPoint(3229, 3459, 0), 10);
            default:
                return false;
        }
    }
    
    /**
     * Gets the appropriate highlighting based on current situation
     * @param location The target location
     * @param teleport The selected teleport method
     * @param graphics Graphics context for highlighting
     */
    private void adaptiveHighlighting(Location location, Location.Teleport teleport, Graphics2D graphics) {
        int currentRegionId = client.getLocalPlayer().getWorldLocation().getRegionID();
        WorldPoint playerLocation = client.getLocalPlayer().getWorldLocation();
        WorldPoint targetLocation = teleport.getPoint();
        
        boolean inCorrectRegion = (currentRegionId == teleport.getRegionId());
        boolean nearTarget = areaCheck.isPlayerWithinArea(targetLocation, 20);
        boolean nearPatch = areaCheck.isPlayerWithinArea(targetLocation, 5);
        
        // If player is very close to patch, highlight the patch directly
        if (nearPatch) {
            highlightFarmingPatchesForLocation(location.getName(), graphics);
            return;
        }
        
        // If player is in correct region but not near target, they might be near a different patch
        if (inCorrectRegion && !nearTarget) {
            if (isNearAnyFarmingPatch(location.getName())) {
                highlightFarmingPatchesForLocation(location.getName(), graphics);
                return;
            }
        }
        
        // Default to normal teleport highlighting
        highlightTeleportMethod(teleport, graphics);
    }
    
    /**
     * Highlights farming patches for a specific location
     * @param locationName The name of the location
     * @param graphics Graphics context for highlighting
     */
    private void highlightFarmingPatchesForLocation(String locationName, Graphics2D graphics) {
        switch (locationName) {
            case "Ardougne":
            case "Weiss":
            case "Civitas illa Fortis":
                highlightHerbPatches(graphics, leftClickColorWithAlpha);
                break;
            case "Catherby":
                // Catherby has both herb and fruit tree patches
                highlightHerbPatches(graphics, leftClickColorWithAlpha);
                highlightFruitTreePatches(graphics, leftClickColorWithAlpha);
                break;
            case "Falador":
                // Falador has both herb and tree patches
                highlightHerbPatches(graphics, leftClickColorWithAlpha);
                highlightTreePatches(graphics, leftClickColorWithAlpha);
                break;
            case "Farming Guild":
                // Farming Guild has all patch types
                highlightHerbPatches(graphics, leftClickColorWithAlpha);
                highlightTreePatches(graphics, leftClickColorWithAlpha);
                highlightFruitTreePatches(graphics, leftClickColorWithAlpha);
                break;
            case "Lumbridge":
            case "Taverley":
            case "Varrock":
                highlightTreePatches(graphics, leftClickColorWithAlpha);
                break;
            case "Brimhaven":
            case "Gnome Stronghold":
            case "Lletya":
            case "Tree Gnome Village":
                highlightFruitTreePatches(graphics, leftClickColorWithAlpha);
                break;
        }
    }
    
    /**
     * Highlights the appropriate teleport method based on category
     * @param teleport The teleport method to highlight
     * @param graphics Graphics context for highlighting
     */
    private void highlightTeleportMethod(Location.Teleport teleport, Graphics2D graphics) {
        switch (teleport.getCategory()) {
            case ITEM:
                // Check if it's a Quetzal whistle (left-click teleport)
                if(plugin.getEasyFarmingOverlay().isQuetzalWhistle(teleport.getId())) {
                    itemHighlight(graphics, teleport.getId(), leftClickColorWithAlpha);
                } else {
                    itemHighlight(graphics, teleport.getId(), rightClickColorWithAlpha);
                    if (!teleport.getRightClickOption().equals("null")) {
                        highlightRightClickOption(graphics, teleport.getRightClickOption());
                    }
                }
                break;
            case SPELLBOOK:
                InventoryTabChecker.TabState tabState = InventoryTabChecker.checkTab(client, VarClientID.TOPLEVEL_PANEL);
                if (tabState == InventoryTabChecker.TabState.SPELLBOOK) {
                    interfaceOverlay(teleport.getInterfaceGroupId(), teleport.getInterfaceChildId()).render(graphics);
                } else {
                    interfaceOverlay(getSpellbookTabGroupId(), getSpellbookTabChildId()).render(graphics);
                }
                break;
            case PORTAL_NEXUS:
                if (!isInterfaceOpen(17, 0)) {
                    List<Integer> portalNexusIds = getGameObjectIdsByName("Portal Nexus");
                    for (Integer objectId : portalNexusIds) {
                        gameObjectOverlay(objectId, leftClickColorWithAlpha).render(graphics);
                    }
                } else {
                    Widget widget = client.getWidget(17, 13);
                    int index = getChildIndexPortalNexus(teleport.getPoint().toString());
                    highlightDynamicComponent(graphics, widget, index);
                }
                break;
            case SPIRIT_TREE:
                if (!isInterfaceOpen(187, 3)) {
                    List<Integer> spiritTreeIds = Arrays.asList(1293, 1294, 1295, 8355, 29227, 29229, 37329, 40778);
                    for (Integer objectId : spiritTreeIds) {
                        gameObjectOverlay(objectId, leftClickColorWithAlpha).render(graphics);
                    }
                } else {
                    Widget widget = client.getWidget(187, 3);
                    int index = getChildIndexSpiritTree(teleport.getPoint().toString());
                    highlightDynamicComponent(graphics, widget, index);
                }
                break;
            case JEWELLERY_BOX:
                if (!isInterfaceOpen(29155, 0)) {
                    List<Integer> jewelleryBoxIds = getGameObjectIdsByName("Jewellery Box");
                    for (Integer objectId : jewelleryBoxIds) {
                        gameObjectOverlay(objectId, leftClickColorWithAlpha).render(graphics);
                    }
                } else {
                    Widget widget = client.getWidget(29155, 0);
                    highlightDynamicComponent(graphics, widget, 0);
                }
                break;
        }
    }

    public void highlightHerbPatches(Graphics2D graphics, Color color)
    {
        for (Integer patchId : farmingHelperOverlay.getHerbPatchIds()) {
            gameObjectOverlay(patchId, color).render(graphics);
        }
    }

    public void highlightFlowerPatches(Graphics2D graphics, Color color)
    {
        for (Integer patchId : farmingHelperOverlay.getFlowerPatchIds()) {
            gameObjectOverlay(patchId, color).render(graphics);
        }
    }

    public void highlightTreePatches(Graphics2D graphics, Color color)
    {
        for (Integer patchId : farmingHelperOverlay.getTreePatchIds()) {
            gameObjectOverlay(patchId, color).render(graphics);
        }
    }

    public void highlightFruitTreePatches(Graphics2D graphics, Color color)
    {
        for (Integer patchId : farmingHelperOverlay.getFruitTreePatchIds()) {
            gameObjectOverlay(patchId, color).render(graphics);
        }
    }

    public void highlightCompost(Graphics2D graphics)
    {
        if (isItemInInventory(selectedCompostID())) {
            if (herbRun) {
                if (this.subCase == 1) {
                    highlightHerbPatches(graphics, highlightUseItemWithAlpha);

                }
                else if(this.subCase == 2) {
                    highlightFlowerPatches(graphics, highlightUseItemWithAlpha);
                }

            }

            if (treeRun) {
                highlightTreePatches(graphics, highlightUseItemWithAlpha);
            }

            if (fruitTreeRun) {
                highlightFruitTreePatches(graphics, highlightUseItemWithAlpha);
            }

            itemHighlight(graphics, selectedCompostID(), highlightUseItemWithAlpha);
        } else {
            withdrawCompost(graphics);
        }
    }

    public void highlightFarmers(Graphics2D graphics, List<String> farmers)
    {
        if (! isInterfaceOpen(219, 1)) {
            for (String farmer : farmers) {
                highlightNpc(graphics, farmer);
            }
        } else {
            Widget widget = client.getWidget(219, 1);
            highlightDynamicComponent(graphics, widget, 1);
        }
    }

    public void highlightTreeFarmers(Graphics2D graphics)
    {
        highlightFarmers(graphics, Arrays.asList(
            "Alain",         // Taverly
            "Fayeth",        // Lumbridge
            "Heskel",        // Falador
            "Prissy Scilla", // Gnome Stronghold
            "Rosie",         // Farming Guild
            "Treznor"        // Varrock
        ));
    }

    public void highlightFruitTreeFarmers(Graphics2D graphics)
    {
        highlightFarmers(graphics, Arrays.asList(
            "Bolongo", // Gnome Stronghold
            "Ellena",  // Catherby
            "Garth",   // Brimhaven
            "Gileth",  // Tree Gnome Village
            "Liliwen", // Lletya
            "Nikkie"   // Farming Guild
        ));
    }

    public void highlightHerbSeeds(Graphics2D graphics) {
        for (Integer seedId : farmingHelperOverlay.getHerbSeedIds()) {
            itemHighlight(graphics, seedId, highlightUseItemWithAlpha);
        }
    }

    public void highlightTreeSapling(Graphics2D graphics) {
        for (Integer seedId : farmingHelperOverlay.getTreeSaplingIds()) {
            itemHighlight(graphics, seedId, highlightUseItemWithAlpha);
        }
    }

    public void highlightFruitTreeSapling(Graphics2D graphics) {
        for (Integer seedId : farmingHelperOverlay.getFruitTreeSaplingIds()) {
            itemHighlight(graphics, seedId, highlightUseItemWithAlpha);
        }
    }

    public void highlightTeleportCrystal(Graphics2D graphics) {
        for (Integer seedId : farmingHelperOverlay.getTeleportCrystalIds()) {
            itemHighlight(graphics, seedId, leftClickColorWithAlpha);
        }
    }

    public void highlightSkillsNecklace(Graphics2D graphics) {
        for (Integer seedId : farmingHelperOverlay.getSkillsNecklaceIds()) {
            itemHighlight(graphics, seedId, leftClickColorWithAlpha);
        }
    }

    public Integer selectedCompostID() {
        EasyFarmingConfig.OptionEnumCompost selectedCompost = config.enumConfigCompost();
        switch (selectedCompost) {
            case Compost:
                return ItemID.BUCKET_COMPOST;
            case Supercompost:
                return ItemID.BUCKET_SUPERCOMPOST;
            case Ultracompost:
                return ItemID.BUCKET_ULTRACOMPOST;
            case Bottomless:
                return ItemID.BOTTOMLESS_COMPOST_BUCKET;
        }
        return -1;
    }

    private boolean isItemInInventory(int itemId) {
        ItemContainer inventory = client.getItemContainer(InventoryID.INV);

        Item[] items;
        if (inventory == null || inventory.getItems() == null) {
            items = new Item[0];
        } else {
            items = inventory.getItems();
        }

        for (Item item : items) {
            if (item.getId() == itemId) {
                return true;
            }
        }

        return false;
    }

    public void withdrawCompost (Graphics2D graphics) {
        plugin.addTextToInfoBox("Withdraw compost from Tool Leprechaun");
        if(!isInterfaceOpen(125,0)) {
            highlightNpc(graphics, "Tool Leprechaun");
        }
        else {
            if (selectedCompostID() == ItemID.BUCKET_COMPOST) {
                interfaceOverlay(125, 17).render(graphics);
            }
            else if(selectedCompostID() == ItemID.BUCKET_SUPERCOMPOST)
            {
                interfaceOverlay(125, 18).render(graphics);
            }
            else if(selectedCompostID() == ItemID.BUCKET_ULTRACOMPOST) {
                interfaceOverlay(125, 19).render(graphics);
            }
            else if(selectedCompostID() == ItemID.BOTTOMLESS_COMPOST_BUCKET) {
                interfaceOverlay(125, 15).render(graphics);
            }
        }
    }

    public Boolean herbPatchDone = false;

    public void herbSteps(Graphics2D graphics, Location.Teleport teleport) {
        int currentRegionId = client.getLocalPlayer().getWorldLocation().getRegionID();
        HerbPatchChecker.PlantState plantState;

        //Farming guild herb patch uses 4775
        if (currentRegionId == 4922) {
            plantState = HerbPatchChecker.checkHerbPatch(client, 4775);
        }
        //Harmony herb patch uses 4772
        else if (currentRegionId == 15148) {
            plantState = HerbPatchChecker.checkHerbPatch(client, 4772);
        }
        //Troll Stronghold and Weiss herb patch uses 4771
        else if (currentRegionId == 11321 || currentRegionId == 11325) {
            plantState = HerbPatchChecker.checkHerbPatch(client, 4771);
        }
        //Rest uses 4774
        else {
            plantState = HerbPatchChecker.checkHerbPatch(client, 4774);
        }
        if (!areaCheck.isPlayerWithinArea(teleport.getPoint(), 15))
        {
            //should be replaced with a pathing system, pointing arrow or something else eventually
            highlightHerbPatches(graphics, leftClickColorWithAlpha);
        }
        else {
            switch (plantState) {
                case HARVESTABLE:
                    plugin.addTextToInfoBox("Harvest Herbs.");
                    highlightHerbPatches(graphics, leftClickColorWithAlpha);
                    break;
                case PLANT:
                    plugin.addTextToInfoBox("Use Herb seed on patch.");
                    highlightHerbPatches(graphics, highlightUseItemWithAlpha);
                    highlightHerbSeeds(graphics);
                    break;
                case DEAD:
                    plugin.addTextToInfoBox("Clear the dead herb patch.");
                    highlightHerbPatches(graphics, leftClickColorWithAlpha);
                    break;
                case DISEASED:
                    plugin.addTextToInfoBox("Use Plant cure on herb patch. Buy at GE or in farming guild/catherby, and store at Tool Leprechaun for easy access.");
                    highlightHerbPatches(graphics, leftClickColorWithAlpha);
                    itemHighlight(graphics, ItemID.PLANT_CURE, highlightUseItemWithAlpha);
                    break;
                case WEEDS:
                    plugin.addTextToInfoBox("Rake the herb patch.");
                    highlightHerbPatches(graphics, leftClickColorWithAlpha);
                    break;
                case GROWING:
                    plugin.addTextToInfoBox("Use Compost on patch.");

                    highlightCompost(graphics);

                    if (patchIsComposted()) {
                        herbPatchDone = true;
                    }
                    break;
                case UNKNOWN:
                    plugin.addTextToInfoBox("UNKNOWN state: Try to do something with the herb patch to change its state.");
                    break;
            }
        }
    }

    private boolean flowerPatchDone = false;

    public void flowerSteps(Graphics2D graphics) {
        if (this.farmLimps) {
            int currentRegionId = client.getLocalPlayer().getWorldLocation().getRegionID();
            FlowerPatchChecker.PlantState plantState;
            if (currentRegionId == 4922) {
                plantState = FlowerPatchChecker.checkFlowerPatch(client, 7906);
            } else {
                plantState = FlowerPatchChecker.checkFlowerPatch(client, 4773);
            }
            switch (plantState) {
                case HARVESTABLE:
                    plugin.addTextToInfoBox("Harvest Limwurt root.");
                    highlightFlowerPatches(graphics, leftClickColorWithAlpha);
                    break;
                case WEEDS:
                    plugin.addTextToInfoBox("Rake the flower patch.");
                    highlightFlowerPatches(graphics, leftClickColorWithAlpha);
                    break;
                case DEAD:
                    plugin.addTextToInfoBox("Clear the dead flower patch.");
                    highlightFlowerPatches(graphics, leftClickColorWithAlpha);
                    break;
                case PLANT:
                    plugin.addTextToInfoBox("Use Limwurt seed on the patch.");
                    highlightFlowerPatches(graphics, highlightUseItemWithAlpha);
                    itemHighlight(graphics, ItemID.LIMPWURT_SEED, highlightUseItemWithAlpha);
                    break;
                case GROWING:
                    plugin.addTextToInfoBox("Use Compost on patch.");

                    highlightCompost(graphics);

                    if (patchIsComposted()) {
                        this.flowerPatchDone = true;
                    }
                    break;
            }
        } else {
            this.flowerPatchDone = true;
        }
    }

    public Boolean treePatchDone = false;

    public void treeSteps(Graphics2D graphics, Location.Teleport teleport) {
        int currentRegionId = client.getLocalPlayer().getWorldLocation().getRegionID();
        TreePatchChecker.PlantState plantState;
        //4771 falador, gnome stronghold, lumbridge, Taverly, Varrock
        //7905 farming guild
        if (currentRegionId == 4922) {
            plantState = TreePatchChecker.checkTreePatch(client, 7905);
        } else {
            plantState = TreePatchChecker.checkTreePatch(client, 4771);
        }
        if (!areaCheck.isPlayerWithinArea(teleport.getPoint(), 15))
        {
            //should be replaced with a pathing system, pointing arrow or something else eventually
            highlightTreePatches(graphics, leftClickColorWithAlpha);
        }
        else {
            switch (plantState) {
                case HEALTHY:
                    plugin.addTextToInfoBox("Check tree health.");
                    highlightTreePatches(graphics, leftClickColorWithAlpha);
                    break;
                case WEEDS:
                    plugin.addTextToInfoBox("Rake the tree patch.");
                    highlightTreePatches(graphics, leftClickColorWithAlpha);
                    break;
                case DEAD:
                    plugin.addTextToInfoBox("Clear the dead tree patch.");
                    highlightTreePatches(graphics, leftClickColorWithAlpha);
                    break;
                case PLANT:
                    plugin.addTextToInfoBox("Use Sapling on the patch.");
                    highlightTreePatches(graphics, highlightUseItemWithAlpha);
                    highlightTreeSapling(graphics);
                    break;
                case DISEASED:
                    plugin.addTextToInfoBox("Prune the tree patch patch.");
                    highlightTreePatches(graphics, highlightUseItemWithAlpha);
                    break;
                case REMOVE:
                    plugin.addTextToInfoBox("Pay to remove tree, or cut it down and clear the patch.");

                    highlightTreeFarmers(graphics);

                    break;
                case UNKNOWN:
                    plugin.addTextToInfoBox("UNKNOWN state: Try to do something with the tree patch to change its state.");
                    break;
                case GROWING:
                    if (config.generalPayForProtection()) {
                        plugin.addTextToInfoBox("Pay to protect the patch.");

                        highlightTreeFarmers(graphics);

                        if (patchIsProtected()) {
                            treePatchDone = true;
                        }
                    } else {
                        plugin.addTextToInfoBox("Use Compost on patch.");

                        highlightCompost(graphics);

                        if (patchIsComposted()) {
                            treePatchDone = true;
                        }
                    }

                    break;
            }
        }
    }

    public Boolean fruitTreePatchDone = false;

    public void fruitTreeSteps(Graphics2D graphics, Location.Teleport teleport) {
        int currentRegionId = client.getLocalPlayer().getWorldLocation().getRegionID();
        FruitTreePatchChecker.PlantState plantState;
        //4771 brimhaven, catherby, Lletya, tree gnome village
        //7909 farming guild
        //4772 gnome stronghold
        if (currentRegionId == 4922) {
            plantState = FruitTreePatchChecker.checkFruitTreePatch(client, 7909);
        } else if (currentRegionId == 9782 || currentRegionId == 9781) {
            plantState = FruitTreePatchChecker.checkFruitTreePatch(client, 4772);
        } else {
            plantState = FruitTreePatchChecker.checkFruitTreePatch(client, 4771);
        }
        if (!areaCheck.isPlayerWithinArea(teleport.getPoint(), 15)) {
            //should be replaced with a pathing system, point arrow or something else eventually
            highlightFruitTreePatches(graphics, leftClickColorWithAlpha);
        } else {
            switch (plantState) {
                case HEALTHY:
                    plugin.addTextToInfoBox("Check Fruit tree health.");
                    highlightFruitTreePatches(graphics, leftClickColorWithAlpha);
                    break;
                case WEEDS:
                    plugin.addTextToInfoBox("Rake the fruit tree patch.");
                    highlightFruitTreePatches(graphics, leftClickColorWithAlpha);
                    break;
                case DEAD:
                    plugin.addTextToInfoBox("Clear the dead fruit tree patch.");
                    highlightFruitTreePatches(graphics, leftClickColorWithAlpha);
                    break;
                case PLANT:
                    plugin.addTextToInfoBox("Use Sapling on the patch.");
                    highlightFruitTreePatches(graphics, highlightUseItemWithAlpha);
                    highlightFruitTreeSapling(graphics);
                    break;
                case DISEASED:
                    plugin.addTextToInfoBox("Prune the fruit tree patch.");
                    highlightFruitTreePatches(graphics, leftClickColorWithAlpha);
                    break;
                case REMOVE:
                    plugin.addTextToInfoBox("Pay to remove fruit tree, or cut it down and clear the patch.");

                    highlightFruitTreeFarmers(graphics);

                    break;
                case UNKNOWN:
                    plugin.addTextToInfoBox("UNKNOWN state: Try to do something with the tree patch to change its state.");
                    break;
                case GROWING:
                    if (config.generalPayForProtection()) {
                        plugin.addTextToInfoBox("Pay to protect the patch.");

                        highlightFruitTreeFarmers(graphics);

                        if (patchIsProtected()) {
                            fruitTreePatchDone = true;
                        }
                    } else {
                        plugin.addTextToInfoBox("Use Compost on patch.");

                        highlightCompost(graphics);

                        if (patchIsComposted()) {
                            fruitTreePatchDone = true;
                        }
                    }

                    break;
            }
        }
    }

    private List<Integer> getGameObjectIdsByName(String name) {
        List<Integer> foundObjectIds = new ArrayList<>();
        WorldView top_wv = client.getTopLevelWorldView();
        Scene scene = top_wv.getScene();
        Tile[][][] tiles = scene.getTiles();

        for (int x = 0; x < Constants.SCENE_SIZE; x++) {
            for (int y = 0; y < Constants.SCENE_SIZE; y++) {
                Tile tile = tiles[top_wv.getPlane()][x][y];
                if (tile == null) {
                    continue;
                }

                for (GameObject gameObject : tile.getGameObjects()) {
                    if (gameObject != null) {
                        ObjectComposition objectComposition = client.getObjectDefinition(gameObject.getId());
                        if (objectComposition != null && objectComposition.getName().equals(name)) {
                            foundObjectIds.add(gameObject.getId());
                        }
                    }
                }
            }
        }

        return foundObjectIds;
    }

    public void inHouseCheck() {
        if(getGameObjectIdsByName("Portal").contains(4525))
        {
            this.currentTeleportCase = 2;
        }
    }

    public void gettingToHouse(Graphics2D graphics) {
        EasyFarmingConfig.OptionEnumHouseTele teleportOption = config.enumConfigHouseTele();
        switch (teleportOption) {
            case Law_air_earth_runes:
                InventoryTabChecker.TabState tabState;
                tabState = InventoryTabChecker.checkTab(client, VarClientID.TOPLEVEL_PANEL);
                switch (tabState) {
                            case INVENTORY:
                            case REST:
                                interfaceOverlay(getSpellbookTabGroupId(), getSpellbookTabChildId()).render(graphics);
                                break;
                    case SPELLBOOK:
                        // Highlight the "Teleport to House" spell using correct child ID from widget inspector
                        interfaceOverlay(InterfaceID.MAGIC_SPELLBOOK, 31).render(graphics);
                        inHouseCheck();
                        break;
                }
                break;
            case Teleport_To_House:
                inHouseCheck();
                itemHighlight(graphics, ItemID.POH_TABLET_TELEPORTTOHOUSE, leftClickColorWithAlpha);
                break;
            case Construction_cape:
                inHouseCheck();
                itemHighlight(graphics, ItemID.SKILLCAPE_CONSTRUCTION, rightClickColorWithAlpha);
                break;
            case Construction_cape_t:
                inHouseCheck();
                itemHighlight(graphics, ItemID.SKILLCAPE_CONSTRUCTION_TRIMMED, rightClickColorWithAlpha);
                break;
            case Max_cape:
                inHouseCheck();
                itemHighlight(graphics, ItemID.SKILLCAPE_MAX, rightClickColorWithAlpha);
                break;
        }
    }

    private int currentTeleportCase = 1;

    public boolean isAtDestination = false;


    public void gettingToLocation(Graphics2D graphics, Location location) {
        updateColors();
        Location.Teleport teleport = location.getSelectedTeleport();
        Boolean locationEnabledBool = false;
        if (plugin.getFarmingTeleportOverlay().herbRun) {
            locationEnabledBool = plugin.getHerbLocationEnabled(location.getName());
        }
        if (plugin.getFarmingTeleportOverlay().treeRun) {
            locationEnabledBool = plugin.getTreeLocationEnabled(location.getName());
        }
        if (plugin.getFarmingTeleportOverlay().fruitTreeRun) {
            locationEnabledBool = plugin.getFruitTreeLocationEnabled(location.getName());
        }
        if (locationEnabledBool) {
            if (!isAtDestination) {
                int currentRegionId = client.getLocalPlayer().getWorldLocation().getRegionID();
                
                // Use adaptive detection to determine if we should proceed to farming
                if (shouldProceedToFarming(location, teleport)) {
                    this.currentTeleportCase = 1;
                    isAtDestination = true;
                    this.startSubCases = true;
                    if (location.getFarmLimps()) {
                        this.farmLimps = true;
                    }
                    plugin.addTextToInfoBox(teleport.getDescription());
                } else {
                    // Use adaptive highlighting based on current situation
                    adaptiveHighlighting(location, teleport, graphics);
                    plugin.addTextToInfoBox(teleport.getDescription());
                    return;
                }
                
                switch (teleport.getCategory()) {
                    case ITEM:
                        if (teleport.getInterfaceGroupId() != 0) {
                            if (!isInterfaceOpen(teleport.getInterfaceGroupId(), teleport.getInterfaceChildId())) {
                                itemHighlight(graphics, teleport.getId(), rightClickColorWithAlpha);
                                if (!teleport.getRightClickOption().equals("null")) {
                                    highlightRightClickOption(graphics, teleport.getRightClickOption());
                                }
                            } else {
                                Widget widget = client.getWidget(teleport.getInterfaceGroupId(), teleport.getInterfaceChildId());
                                highlightDynamicComponent(graphics, widget, 1);
                            }
                            if (currentRegionId == teleport.getRegionId()) {
                                this.currentTeleportCase = 1;
                                isAtDestination = true;
                                this.startSubCases = true;
                                if (location.getFarmLimps()) {
                                    this.farmLimps = true;
                                }
                            }
                        } else {
                            if (!teleport.getRightClickOption().equals("null")) {
                                itemHighlight(graphics, teleport.getId(), rightClickColorWithAlpha);
                                highlightRightClickOption(graphics, teleport.getRightClickOption());
                            } else {
                                if(plugin.getEasyFarmingOverlay().isTeleportCrystal(teleport.getId())) {
                                    highlightTeleportCrystal(graphics);
                                }
                                if(plugin.getEasyFarmingOverlay().isSkillsNecklace(teleport.getId())) {
                                    String index = location.getName();
                                    if(Objects.equals(index, "Ardougne")) {
                                        highlightSkillsNecklace(graphics);
                                        highlightRightClickOption(graphics, "Rub");
                                        Widget widget = client.getWidget(187, 3);
                                        highlightDynamicComponent(graphics, widget, 0);
                                    }
                                    if(Objects.equals(index, "Farming Guild")) {
                                        highlightSkillsNecklace(graphics);
                                        highlightRightClickOption(graphics, "Rub");
                                        Widget widget = client.getWidget(187, 3);
                                        highlightDynamicComponent(graphics, widget, 5);
                                    }
                                }
                                else if(plugin.getEasyFarmingOverlay().isQuetzalWhistle(teleport.getId())) {
                                    itemHighlight(graphics, teleport.getId(), leftClickColorWithAlpha);
                                }
                                else {
                                    itemHighlight(graphics, teleport.getId(), leftClickColorWithAlpha);
                                }
                            }
                            if (currentRegionId == teleport.getRegionId()) {
                                this.currentTeleportCase = 1;
                                isAtDestination = true;
                                this.startSubCases = true;
                                if (location.getFarmLimps()) {
                                    this.farmLimps = true;
                                }
                            }
                        }
                        break;
                    case PORTAL_NEXUS:
                        switch (this.currentTeleportCase) {
                            case 1:
                                gettingToHouse(graphics);
                                break;
                            case 2:
                                if (!isInterfaceOpen(17, 0)) {
                                    List<Integer> portalNexusIds = getGameObjectIdsByName("Portal Nexus");
                                    for (Integer objectId : portalNexusIds) {
                                        gameObjectOverlay(objectId, leftClickColorWithAlpha).render(graphics);
                                    }
                                } else {
                                    Widget widget = client.getWidget(17, 13);
                                    int index = getChildIndexPortalNexus(location.getName());
                                    highlightDynamicComponent(graphics, widget, index);
                                }
                                if (currentRegionId == teleport.getRegionId()) {
                                    this.currentTeleportCase = 1;
                                    isAtDestination = true;
                                    this.startSubCases = true;
                                    if (location.getFarmLimps()) {
                                        this.farmLimps = true;
                                    }
                                }
                                break;
                        }
                        break;
                    case SPIRIT_TREE:
                        if (!isInterfaceOpen(187, 3)) {
                            List<Integer> spiritTreeIds = Arrays.asList(1293, 1294, 1295, 8355, 29227, 29229, 37329, 40778);

                            for (Integer objectId : spiritTreeIds) {
                                gameObjectOverlay(objectId, leftClickColorWithAlpha).render(graphics);
                            }
                        } else {
                            Widget widget = client.getWidget(187, 3);

                            switch (location.getName()) {
                                case "Gnome Stronghold":
                                    highlightDynamicComponent(graphics, widget, getChildIndexSpiritTree("Gnome Stronghold"));
                                    break;

                                case "Tree Gnome Village":
                                    highlightDynamicComponent(graphics, widget, getChildIndexSpiritTree("Tree Gnome Village"));
                                    break;

                                case "Falador":
                                    highlightDynamicComponent(graphics, widget, getChildIndexSpiritTree("Port Sarim"));
                                    break;

                                case "Kourend":
                                    highlightDynamicComponent(graphics, widget, getChildIndexSpiritTree("Hosidius"));
                                    break;
                            }
                        }
                        if (currentRegionId == teleport.getRegionId()) {
                            this.currentTeleportCase = 1;
                            isAtDestination = true;
                            this.startSubCases = true;

                            if (location.getFarmLimps()) {
                                this.farmLimps = true;
                            }
                        }
                        break;                    
                    case JEWELLERY_BOX:
                        switch (this.currentTeleportCase) {
                            case 1:
                                gettingToHouse(graphics);
                                break;
                            case 2:
                                List<Integer> jewelleryBoxIds = Arrays.asList(29154, 29155, 29156);

                                if (!isInterfaceOpen(590, 0)) {
                                    for (int id : jewelleryBoxIds) {
                                        gameObjectOverlay(id, leftClickColorWithAlpha).render(graphics);
                                    }
                                    gameObjectOverlay(teleport.getId(), leftClickColorWithAlpha).render(graphics);
                                } else {
                                    Widget widget = client.getWidget(590, 5);
                                    highlightDynamicComponent(graphics, widget, 10);
                                }
                                if (currentRegionId == teleport.getRegionId()) {
                                    this.currentTeleportCase = 1;
                                    isAtDestination = true;
                                    this.startSubCases = true;
                                    if (location.getFarmLimps()) {
                                        this.farmLimps = true;
                                    }
                                }
                                break;
                        }
                        break;
                    case MOUNTED_XERICS:
                        switch (this.currentTeleportCase) {
                            case 1:
                                gettingToHouse(graphics);
                                break;
                            case 2:
                                List<Integer> xericsTalismanIds = Arrays.asList(33411, 33412, 33413, 33414, 33415);

                                if (!isInterfaceOpen(teleport.getInterfaceGroupId(), teleport.getInterfaceChildId())) {
                                    for (int id : xericsTalismanIds) {
                                        Overlay decorativeObjectHighlight = decorativeObjectOverlay(id);
                                        decorativeObjectHighlight.render(graphics);
                                    }
                                } else {
                                    Widget widget = client.getWidget(teleport.getInterfaceGroupId(), teleport.getInterfaceChildId());
                                    highlightDynamicComponent(graphics, widget, 1);
                                    if (currentRegionId == teleport.getRegionId()) {
                                        this.currentTeleportCase = 1;
                                        isAtDestination = true;
                                        this.startSubCases = true;
                                        if (location.getFarmLimps()) {
                                            this.farmLimps = true;
                                        }
                                    }
                                }
                                break;
                        }
                        break;
                    case SPELLBOOK:
                        InventoryTabChecker.TabState tabState;
                        tabState = InventoryTabChecker.checkTab(client, VarClientID.TOPLEVEL_PANEL);
                        switch (tabState) {
                            case REST:
                            case INVENTORY:
                                interfaceOverlay(getSpellbookTabGroupId(), getSpellbookTabChildId()).render(graphics);
                                if (currentRegionId == teleport.getRegionId()) {
                                    this.currentTeleportCase = 1;
                                    isAtDestination = true;
                                    this.startSubCases = true;
                                }
                                break;
                            case SPELLBOOK:
                                interfaceOverlay(teleport.getInterfaceGroupId(), teleport.getInterfaceChildId()).render(graphics);
                                if (currentRegionId == teleport.getRegionId()) {
                                    this.currentTeleportCase = 1;
                                    isAtDestination = true;
                                    this.startSubCases = true;
                                }
                                break;
                        }
                        break;
                    default:
                        // Optional: Code for handling unexpected values
                        break;
                }

            } else {
                farming(graphics, teleport);
            }
        } else {
            this.currentLocationIndex++;
        }
    }
    //}


    private boolean farmLimps = false;

    public void farming(Graphics2D graphics, Location.Teleport teleport) {
        if (this.startSubCases) {
            if (herbRun) {
                if (this.subCase == 1) {
                    herbSteps(graphics, teleport);
                    if (herbPatchDone) {
                        this.subCase = 2;
                        herbPatchDone = false;
                    }
                } else if (this.subCase == 2) {
                    if (config.generalLimpwurt()) {
                        flowerSteps(graphics);
                        if (this.flowerPatchDone) {
                            this.subCase = 1;
                            this.startSubCases = false;
                            isAtDestination = false;
                            this.currentLocationIndex++;
                            this.farmLimps = false;
                            this.flowerPatchDone = false;

                        }
                    } else {
                        this.subCase = 1;
                        this.startSubCases = false;
                        isAtDestination = false;
                        this.currentLocationIndex++;
                        this.farmLimps = false;
                        this.flowerPatchDone = false;
                    }
                }
            }
            if (treeRun) {
                treeSteps(graphics, teleport);
                if (treePatchDone) {
                    this.startSubCases = false;
                    isAtDestination = false;
                    this.currentLocationIndex++;
                    treePatchDone = false;
                }
            }
            if (fruitTreeRun) {
                fruitTreeSteps(graphics, teleport);
                if (fruitTreePatchDone) {
                    this.startSubCases = false;
                    isAtDestination = false;
                    this.currentLocationIndex++;
                    fruitTreePatchDone = false;
                }
            }
        }
    }

    private int subCase = 1;
    private boolean startSubCases = false;
    private int currentLocationIndex = 0;

    public void removeOverlay() {
        plugin.overlayManager.remove(farmingHelperOverlay);
        plugin.overlayManager.remove(this);
        plugin.overlayManager.remove(farmingHelperOverlayInfoBox);

        plugin.setOverlayActive(false);
        plugin.setTeleportOverlayActive(false);

        this.currentLocationIndex = 0;
        this.currentTeleportCase = 1;
        this.subCase = 1;
        this.startSubCases = false;
        isAtDestination = false;
        this.farmLimps = false;
        this.flowerPatchDone = false;

        plugin.setItemsCollected(false);

        plugin.getFarmingTeleportOverlay().herbRun = false;
        plugin.getFarmingTeleportOverlay().treeRun = false;
        plugin.getFarmingTeleportOverlay().fruitTreeRun = false;

        fruitTreeRun = false;
        herbRun = false;
        treeRun = false;

        plugin.panel.herbButton.setStartStopState(false);
        plugin.panel.treeButton.setStartStopState(false);
        plugin.panel.fruitTreeButton.setStartStopState(false);
    }

    public Boolean herbRun = false;

    public Boolean treeRun = false;

    public Boolean fruitTreeRun = false;

    @Override
    public Dimension render(Graphics2D graphics) {
        if (plugin.isTeleportOverlayActive()) {
            if (herbRun) {
                switch (this.currentLocationIndex) {
                    case 0:
                        gettingToLocation(graphics, plugin.getArdougneLocation());
                        break;
                    case 1:
                        gettingToLocation(graphics, plugin.getCatherbyLocation());
                        break;
                    case 2:
                        gettingToLocation(graphics, plugin.getFaladorLocation());
                        break;
                    case 3:
                        gettingToLocation(graphics, plugin.getFarmingGuildLocation());
                        break;
                    case 4:
                        gettingToLocation(graphics, plugin.getHarmonyLocation());
                        break;
                    case 5:
                        gettingToLocation(graphics, plugin.getKourendLocation());
                        break;
                    case 6:
                        gettingToLocation(graphics, plugin.getMorytaniaLocation());
                        break;
                    case 7:
                        gettingToLocation(graphics, plugin.getTrollStrongholdLocation());
                        break;
                    case 8:
                        gettingToLocation(graphics, plugin.getWeissLocation());
                        break;
                    case 9:
                        gettingToLocation(graphics, plugin.getCivitasLocation());
                        break;
                    case 10:
                        removeOverlay();
                        // add more cases for each location in the array
                    default:
                        removeOverlay();
                        // Add any other actions you want to perform when the herb run is complete
                        break;
                }
            } else if (treeRun) {
                switch (this.currentLocationIndex) {
                    case 0:
                        gettingToLocation(graphics, plugin.getFaladorTreeLocation());
                        break;
                    case 1:
                        gettingToLocation(graphics, plugin.getFarmingGuildTreeLocation());
                        break;
                    case 2:
                        gettingToLocation(graphics, plugin.getGnomeStrongholdTreeLocation());
                        break;
                    case 3:
                        gettingToLocation(graphics, plugin.getLumbridgeTreeLocation());
                        break;
                    case 4:
                        gettingToLocation(graphics, plugin.getTaverleyTreeLocation());
                        break;
                    case 5:
                        gettingToLocation(graphics, plugin.getVarrockTreeLocation());
                        break;
                    case 6:
                        removeOverlay();
                        // add more cases for each location in the array
                    default:
                        removeOverlay();
                        // Add any other actions you want to perform when the herb run is complete
                        break;
                }
            } else if (fruitTreeRun) {
                switch (this.currentLocationIndex) {
                    case 0:
                        gettingToLocation(graphics, plugin.getBrimhavenFruitTreeLocation());
                        break;
                    case 1:
                        gettingToLocation(graphics, plugin.getCatherbyFruitTreeLocation());
                        break;
                    case 2:
                        gettingToLocation(graphics, plugin.getFarmingGuildFruitTreeLocation());
                        break;
                    case 3:
                        gettingToLocation(graphics, plugin.getGnomeStrongholdFruitTreeLocation());
                        break;
                    case 4:
                        gettingToLocation(graphics, plugin.getLletyaFruitTreeLocation());
                        break;
                    case 5:
                        gettingToLocation(graphics, plugin.getTreeGnomeVillageTreeLocation());
                        break;
                    case 6:
                        removeOverlay();
                        // add more cases for each location in the array
                    default:
                        removeOverlay();
                        // Add any other actions you want to perform when the herb run is complete
                        break;
                }
            }
        }
        return null;
    }
}

package com.easyfarming;

import java.awt.Dimension;
import java.awt.Graphics2D;
import java.util.*;
import javax.inject.Inject;

import net.runelite.api.*;
import net.runelite.api.gameval.InventoryID;
import net.runelite.api.gameval.ItemID;
import net.runelite.api.gameval.VarbitID;
import net.runelite.api.kit.KitType;
import net.runelite.client.ui.overlay.Overlay;
import net.runelite.client.ui.overlay.OverlayLayer;
import net.runelite.client.ui.overlay.OverlayPosition;
import net.runelite.client.ui.overlay.components.ImageComponent;
import net.runelite.client.ui.overlay.components.PanelComponent;
import java.awt.image.BufferedImage;
import net.runelite.client.game.ItemManager;

import java.awt.Color;
import com.easyfarming.ItemsAndLocations.HerbRunItemAndLocation;
import com.easyfarming.ItemsAndLocations.TreeRunItemAndLocation;
import com.easyfarming.ItemsAndLocations.FruitTreeRunItemAndLocation;

public class EasyFarmingOverlay extends Overlay {

    private HerbRunItemAndLocation herbRunItemAndLocation;
    private TreeRunItemAndLocation treeRunItemAndLocation;
    private FruitTreeRunItemAndLocation fruitTreeRunItemAndLocation;
    private final Client client;
    private final EasyFarmingPlugin plugin;
    private final PanelComponent panelComponent = new PanelComponent();
    @Inject
    private ItemManager itemManager;

    public static final List<Integer> TELEPORT_CRYSTAL_IDS = Arrays.asList(ItemID.MOURNING_TELEPORT_CRYSTAL_1, ItemID.MOURNING_TELEPORT_CRYSTAL_2, ItemID.MOURNING_TELEPORT_CRYSTAL_3, ItemID.MOURNING_TELEPORT_CRYSTAL_4, ItemID.MOURNING_TELEPORT_CRYSTAL_5);
    private static final int BASE_TELEPORT_CRYSTAL_ID = ItemID.MOURNING_TELEPORT_CRYSTAL_1;
    public List<Integer> getTeleportCrystalIds() {
        return TELEPORT_CRYSTAL_IDS;
    }    public boolean isTeleportCrystal(int itemId) {
        return TELEPORT_CRYSTAL_IDS.contains(itemId);
    }

    public static final List<Integer> SKILLS_NECKLACE_IDS = Arrays.asList(ItemID.JEWL_NECKLACE_OF_SKILLS_1, ItemID.JEWL_NECKLACE_OF_SKILLS_2, ItemID.JEWL_NECKLACE_OF_SKILLS_3, ItemID.JEWL_NECKLACE_OF_SKILLS_4, ItemID.JEWL_NECKLACE_OF_SKILLS_5, ItemID.JEWL_NECKLACE_OF_SKILLS_6);
    private static final int BASE_SKILLS_NECKLACE_ID = ItemID.JEWL_NECKLACE_OF_SKILLS_1;
    public List<Integer> getSkillsNecklaceIds() {
        return SKILLS_NECKLACE_IDS;
    }    public boolean isSkillsNecklace(int itemId) {
        return SKILLS_NECKLACE_IDS.contains(itemId);
    }

    public static final List<Integer> EXPLORERS_RING_IDS = Arrays.asList(ItemID.LUMBRIDGE_RING_MEDIUM, ItemID.LUMBRIDGE_RING_HARD, ItemID.LUMBRIDGE_RING_ELITE);
    private static final int BASE_EXPLORERS_RING_ID = ItemID.LUMBRIDGE_RING_MEDIUM;
    public List<Integer> getExplorersRingIds() {
        return EXPLORERS_RING_IDS;
    }
    public boolean isExplorersRing(int itemId) {
        return EXPLORERS_RING_IDS.contains(itemId);
    }

    public static final List<Integer> ARDY_CLOAK_IDS = Arrays.asList(ItemID.ARDY_CAPE_MEDIUM, ItemID.ARDY_CAPE_HARD, ItemID.ARDY_CAPE_ELITE);
    private static final int BASE_ARDY_CLOAK_ID = ItemID.ARDY_CAPE_MEDIUM;
    public List<Integer> getArdyCloakIds() {
        return ARDY_CLOAK_IDS;
    }
    public boolean isArdyCloak(int itemId) {
        return ARDY_CLOAK_IDS.contains(itemId);
    }


    public static final List<Integer> HERB_PATCH_IDS = Arrays.asList(33176, 27115, 8152, 8150, 8153, 18816, 8151, 9372, 33979, 50697);
    public List<Integer> getHerbPatchIds() {
        return HERB_PATCH_IDS;
    }
    private static final List<Integer> HERB_SEED_IDS = Arrays.asList(
        ItemID.GUAM_SEED, ItemID.MARRENTILL_SEED, ItemID.TARROMIN_SEED, ItemID.HARRALANDER_SEED,
        ItemID.RANARR_SEED, ItemID.TOADFLAX_SEED, ItemID.IRIT_SEED, ItemID.AVANTOE_SEED,
        ItemID.KWUARM_SEED, ItemID.SNAPDRAGON_SEED, ItemID.CADANTINE_SEED, ItemID.LANTADYME_SEED,
        ItemID.DWARF_WEED_SEED, ItemID.TORSTOL_SEED, ItemID.HUASCA_SEED
    );
    private static final int BASE_SEED_ID = ItemID.GUAM_SEED;
    public List<Integer> getHerbSeedIds() {
        return HERB_SEED_IDS;
    }
    private boolean isHerbSeed(int itemId) {
        return HERB_SEED_IDS.contains(itemId);
    }



    private static final List<Integer> FLOWER_PATCH_IDS = Arrays.asList(27111, 7849, 7847, 7850, 7848, 33649);
    public List<Integer> getFlowerPatchIds() {
        return FLOWER_PATCH_IDS;
    }


    public static final List<Integer> TREE_PATCH_IDS = Arrays.asList(8389, 33732, 19147, 8391, 8388, 8390);
    public List<Integer> getTreePatchIds() {
        return TREE_PATCH_IDS;
    }
    private static final List<Integer> TREE_SAPLING_IDS = Arrays.asList(ItemID.PLANTPOT_OAK_SAPLING, ItemID.PLANTPOT_WILLOW_SAPLING,ItemID.PLANTPOT_MAPLE_SAPLING,ItemID.PLANTPOT_YEW_SAPLING,ItemID.PLANTPOT_MAGIC_TREE_SAPLING);
    private static final int BASE_SAPLING_ID = ItemID.PLANTPOT_OAK_SAPLING;
    public List<Integer> getTreeSaplingIds() {
        return TREE_SAPLING_IDS;
    }
    private boolean isTreeSapling(int itemId) {return TREE_SAPLING_IDS.contains(itemId);}


    public static final List<Integer> FRUIT_TREE_PATCH_IDS = Arrays.asList(7964, 7965, 34007, 7962, 26579, 7963);
    public List<Integer> getFruitTreePatchIds() {
        return FRUIT_TREE_PATCH_IDS;
    }
    private static final List<Integer> FRUIT_TREE_SAPLING_IDS = Arrays.asList(ItemID.PLANTPOT_APPLE_SAPLING, ItemID.PLANTPOT_BANANA_SAPLING,ItemID.PLANTPOT_ORANGE_SAPLING,ItemID.PLANTPOT_CURRY_SAPLING,ItemID.PLANTPOT_PINEAPPLE_SAPLING,ItemID.PLANTPOT_PAPAYA_SAPLING,ItemID.PLANTPOT_PALM_SAPLING, ItemID.PLANTPOT_DRAGONFRUIT_SAPLING);
    private static final int BASE_FRUIT_SAPLING_ID = ItemID.PLANTPOT_APPLE_SAPLING;
    public List<Integer> getFruitTreeSaplingIds() {return FRUIT_TREE_SAPLING_IDS;}
    private boolean isFruitTreeSapling(int itemId) {return FRUIT_TREE_SAPLING_IDS.contains(itemId);}


    public static final List<Integer> RUNE_POUCH_ID = Arrays.asList(ItemID.BH_RUNE_POUCH, ItemID.DIVINE_RUNE_POUCH);

    public static final List<Integer> RUNE_POUCH_AMOUNT_VARBITS = Arrays.asList(VarbitID.RUNE_POUCH_QUANTITY_1, VarbitID.RUNE_POUCH_QUANTITY_2, VarbitID.RUNE_POUCH_QUANTITY_3, VarbitID.RUNE_POUCH_QUANTITY_4);

    public static final List<Integer> RUNE_POUCH_RUNE_VARBITS = Arrays.asList(VarbitID.RUNE_POUCH_TYPE_1, VarbitID.RUNE_POUCH_TYPE_2, VarbitID.RUNE_POUCH_TYPE_3, VarbitID.RUNE_POUCH_TYPE_4);

    private static final Map<Integer, List<Integer>> COMBINATION_RUNE_SUBRUNES_MAP;

    static {
        Map<Integer, List<Integer>> tempMap = new HashMap<>();
        tempMap.put(ItemID.DUSTRUNE, Arrays.asList(ItemID.AIRRUNE, ItemID.EARTHRUNE));
        tempMap.put(ItemID.MISTRUNE, Arrays.asList(ItemID.AIRRUNE, ItemID.WATERRUNE));
        tempMap.put(ItemID.MUDRUNE, Arrays.asList(ItemID.WATERRUNE, ItemID.EARTHRUNE));
        tempMap.put(ItemID.LAVARUNE, Arrays.asList(ItemID.FIRERUNE, ItemID.EARTHRUNE));
        tempMap.put(ItemID.STEAMRUNE, Arrays.asList(ItemID.FIRERUNE, ItemID.WATERRUNE));
        tempMap.put(ItemID.SMOKERUNE, Arrays.asList(ItemID.FIRERUNE, ItemID.AIRRUNE));
        COMBINATION_RUNE_SUBRUNES_MAP = Collections.unmodifiableMap(tempMap);
    }

    private int getRuneItemIdFromVarbitValue(int varbitValue) {
        switch (varbitValue) {
            case 1:
                return ItemID.AIRRUNE;
            case 2:
                return ItemID.WATERRUNE;
            case 3:
                return ItemID.EARTHRUNE;
            case 4:
                return ItemID.FIRERUNE;
            case 5:
                return ItemID.MINDRUNE;
            case 6:
                return ItemID.CHAOSRUNE;
            case 7:
                return ItemID.DEATHRUNE;
            case 8:
                return ItemID.BLOODRUNE;
            case 9:
                return ItemID.COSMICRUNE;
            case 10:
                return ItemID.NATURERUNE;
            case 11:
                return ItemID.LAWRUNE;
            case 12:
                return ItemID.BODYRUNE;
            case 13:
                return ItemID.SOULRUNE;
            case 14:
                return ItemID.ASTRALRUNE;
            case 15:
                return ItemID.MISTRUNE;
            case 16:
                return ItemID.MUDRUNE;
            case 17:
                return ItemID.DUSTRUNE;
            case 18:
                return ItemID.LAVARUNE;
            case 19:
                return ItemID.STEAMRUNE;
            case 20:
                return ItemID.SMOKERUNE;
            case 21:
                return ItemID.WRATHRUNE;
            // Add more cases for other runes
            default:
                return -1;
        }
    }

    private Map<Integer, Integer> getRunePouchContentsVarbits() {
        Map<Integer, Integer> runePouchContents = new HashMap<>();

        for (int i = 0; i < RUNE_POUCH_RUNE_VARBITS.size(); i++) {
            int runeVarbitValue = client.getVarbitValue(RUNE_POUCH_RUNE_VARBITS.get(i));
            int runeAmount = client.getVarbitValue(RUNE_POUCH_AMOUNT_VARBITS.get(i));

            int runeId = getRuneItemIdFromVarbitValue(runeVarbitValue);

            if (runeId != -1 && runeAmount > 0) {
                handleCombinationRunes(runeId, runeAmount, runePouchContents);
            }
        }
        return runePouchContents;
    }

    private Map<Integer, Integer> buildExpandedRuneMap(Item[] items) {
        // Start with rune pouch contents
        Map<Integer, Integer> expandedRuneMap = new HashMap<>(getRunePouchContentsVarbits());
        
        // Add combination runes from inventory
        for (Item item : items) {
            if (item != null) {
                int itemIdRune = item.getId();
                int itemQuantity = item.getQuantity();

                if (COMBINATION_RUNE_SUBRUNES_MAP.containsKey(itemIdRune)) {
                    List<Integer> subRunes = COMBINATION_RUNE_SUBRUNES_MAP.get(itemIdRune);
                    for (int subRune : subRunes) {
                        expandedRuneMap.put(subRune, expandedRuneMap.getOrDefault(subRune, 0) + itemQuantity);
                    }
                } else {
                    // Add regular runes from inventory
                    expandedRuneMap.put(itemIdRune, expandedRuneMap.getOrDefault(itemIdRune, 0) + itemQuantity);
                }
            }
        }
        
        return expandedRuneMap;
    }

    @Inject
    public EasyFarmingOverlay(Client client, EasyFarmingPlugin plugin, ItemManager itemManager, HerbRunItemAndLocation herbRunItemAndLocation, TreeRunItemAndLocation treeRunItemAndLocation, FruitTreeRunItemAndLocation fruitTreeRunItemAndLocation) {
        this.client = client;
        this.plugin = plugin;
        this.itemManager = itemManager;
        this.herbRunItemAndLocation = herbRunItemAndLocation;
        this.treeRunItemAndLocation = treeRunItemAndLocation;
        this.fruitTreeRunItemAndLocation = fruitTreeRunItemAndLocation;
        setPosition(OverlayPosition.BOTTOM_RIGHT);
        setLayer(OverlayLayer.ABOVE_SCENE);
    }

    private void handleCombinationRunes(int runeId, int runeAmount, Map<Integer, Integer> runePouchContents) {
        if (COMBINATION_RUNE_SUBRUNES_MAP.containsKey(runeId)) {
            List<Integer> subRunes = COMBINATION_RUNE_SUBRUNES_MAP.get(runeId);
            for (int subRune : subRunes) {
                runePouchContents.put(subRune, runePouchContents.getOrDefault(subRune, 0) + runeAmount);
            }
        } else {
            runePouchContents.put(runeId, runeAmount);
        }
    }
    public Integer checkToolLep(Integer item) {
        if(item == ItemID.BUCKET_COMPOST) {
            return client.getVarbitValue(1442);
        }
        if(item == ItemID.BUCKET_SUPERCOMPOST) {
            return client.getVarbitValue(1443);
        }
        if (item == ItemID.BUCKET_ULTRACOMPOST) {
            return client.getVarbitValue(5732);
        }
        if (item == ItemID.BOTTOMLESS_COMPOST_BUCKET) {
            if (client.getVarbitValue(7915) != 0) {
                return 1;
            }
        }
        return 0;
    }

    // Helper method to get charges from necklace ID
    private int getSkillsNecklaceCharges(int itemId) {
        switch (itemId) {
            case ItemID.JEWL_NECKLACE_OF_SKILLS_1: return 1;
            case ItemID.JEWL_NECKLACE_OF_SKILLS_2: return 2;
            case ItemID.JEWL_NECKLACE_OF_SKILLS_3: return 3;
            case ItemID.JEWL_NECKLACE_OF_SKILLS_4: return 4;
            case ItemID.JEWL_NECKLACE_OF_SKILLS_5: return 5;
            case ItemID.JEWL_NECKLACE_OF_SKILLS_6: return 6;
            default: return 0;
        }
    }

    public boolean isQuetzalWhistle(int itemId) {
        return itemId == ItemID.HG_QUETZALWHISTLE_BASIC || 
               itemId == ItemID.HG_QUETZALWHISTLE_ENHANCED || 
               itemId == ItemID.HG_QUETZALWHISTLE_PERFECTED;
    }

    /**
     * Scans equipped items and returns a map of item IDs to their counts.
     * Equipped items are counted as 1 each (equipment slots can only hold 1 item).
     * Uses PlayerComposition.getEquipmentId(KitType) with KitType enum constants.
     */
    private Map<Integer, Integer> getEquippedItems() {
        Map<Integer, Integer> equippedItems = new HashMap<>();
        
        Player localPlayer = client.getLocalPlayer();
        if (localPlayer == null) {
            return equippedItems;
        }
        
        PlayerComposition playerComposition = localPlayer.getPlayerComposition();
        if (playerComposition == null) {
            return equippedItems;
        }
        
        // Scan through all KitType enum values to get equipped items
        for (KitType kitType : KitType.values()) {
            int itemId = playerComposition.getEquipmentId(kitType);
            if (itemId > 0) {
                // Count each equipped item as 1
                equippedItems.put(itemId, equippedItems.getOrDefault(itemId, 0) + 1);
            }
        }
        
        return equippedItems;
    }

    public Map<Integer, Integer> itemsToCheck;
    @Override
    public Dimension render(Graphics2D graphics) {
        if (plugin.isOverlayActive() && !plugin.areItemsCollected()) {
            if (!plugin.isOverlayActive()) {
                return null;
            }
            plugin.addTextToInfoBox("Grab all the items needed");
            // List of items to check
            Map<Integer, Integer> itemsToCheck = null;
            if(plugin.getFarmingTeleportOverlay().herbRun) {
                itemsToCheck = herbRunItemAndLocation.getHerbItems();
            }
            if(plugin.getFarmingTeleportOverlay().treeRun) {
                itemsToCheck = treeRunItemAndLocation.getTreeItems();
            }
            if(plugin.getFarmingTeleportOverlay().fruitTreeRun) {
                itemsToCheck = fruitTreeRunItemAndLocation.getFruitTreeItems();
            }

            if (itemsToCheck == null || itemsToCheck.isEmpty()) {
                return null;
            }

            ItemContainer inventory = client.getItemContainer(InventoryID.INV);

            Item[] items;
            if (inventory == null || inventory.getItems() == null) {
                items = new Item[0];
            } else {
                items = inventory.getItems();
            }

            // Build expanded rune map once before any requirement checks
            Map<Integer, Integer> expandedRuneMap = buildExpandedRuneMap(items);

            int teleportCrystalCount = 0;
            for (Item item : items) {
                if (isTeleportCrystal(item.getId())) {
                    teleportCrystalCount += item.getQuantity();
                    break;
                }
            }
            int skillsNecklaceCharges = 0;
            // Count charges from inventory
            for (Item item : items) {
                if (isSkillsNecklace(item.getId())) {
                    int charges = getSkillsNecklaceCharges(item.getId());
                    skillsNecklaceCharges += charges * item.getQuantity();
                }
            }
            // Count charges from equipped items
            Map<Integer, Integer> equippedItems = getEquippedItems();
            for (Map.Entry<Integer, Integer> equippedEntry : equippedItems.entrySet()) {
                int equippedItemId = equippedEntry.getKey();
                if (isSkillsNecklace(equippedItemId)) {
                    int charges = getSkillsNecklaceCharges(equippedItemId);
                    skillsNecklaceCharges += charges;
                }
            }
            int quetzalWhistleCount = 0;
            for (Item item : items) {
                if (isQuetzalWhistle(item.getId())) {
                    quetzalWhistleCount += item.getQuantity();
                }
            }

            int totalSeeds = 0;
            if(plugin.getFarmingTeleportOverlay().herbRun) {
                for (Item item : items) {
                    if (isHerbSeed(item.getId())) {
                        totalSeeds += item.getQuantity();
                    }
                }
            }
            if(plugin.getFarmingTeleportOverlay().treeRun) {
                for (Item item : items) {
                    if (isTreeSapling(item.getId())) {
                        totalSeeds += item.getQuantity();
                    }
                }
            }
            if(plugin.getFarmingTeleportOverlay().fruitTreeRun) {
                for (Item item : items) {
                    if (isFruitTreeSapling(item.getId())) {
                        totalSeeds += item.getQuantity();
                    }
                }
            }

            panelComponent.getChildren().clear();
            int yOffset = 0;

            // Single inventory scan to build comprehensive item count map (including rune pouch expansions)
            Map<Integer, Integer> inventoryItemCounts = new HashMap<>();
            boolean hasRunePouch = false;
            
            // First pass: scan inventory for regular items and check for rune pouch
            for (Item item : items) {
                if (item != null) {
                    int itemId = item.getId();
                    int itemQuantity = item.getQuantity();
                    
                    // Check if this is a rune pouch
                    if (RUNE_POUCH_ID.contains(itemId)) {
                        hasRunePouch = true;
                    }
                    
                    if (COMBINATION_RUNE_SUBRUNES_MAP.containsKey(itemId)) {
                        // Handle combination runes
                        List<Integer> subRunes = COMBINATION_RUNE_SUBRUNES_MAP.get(itemId);
                        for (int subRune : subRunes) {
                            inventoryItemCounts.put(subRune, inventoryItemCounts.getOrDefault(subRune, 0) + itemQuantity);
                        }
                    } else {
                        // Handle regular items
                        inventoryItemCounts.put(itemId, itemQuantity);
                    }
                }
            }
            
            // Second pass: if rune pouch exists, add expanded rune map contents to inventory counts
            if (hasRunePouch) {
                for (Map.Entry<Integer, Integer> runeEntry : expandedRuneMap.entrySet()) {
                    int runeId = runeEntry.getKey();
                    int runeCount = runeEntry.getValue();
                    inventoryItemCounts.put(runeId, inventoryItemCounts.getOrDefault(runeId, 0) + runeCount);
                }
            }
            
            // Third pass: add equipped items to inventory counts
            // Note: equippedItems was already retrieved above for skills necklace charges
            for (Map.Entry<Integer, Integer> equippedEntry : equippedItems.entrySet()) {
                int equippedItemId = equippedEntry.getKey();
                int equippedCount = equippedEntry.getValue();
                inventoryItemCounts.put(equippedItemId, inventoryItemCounts.getOrDefault(equippedItemId, 0) + equippedCount);
            }

            List<AbstractMap.SimpleEntry<Integer, Integer>> missingItemsWithCounts = new ArrayList<>();
            boolean allItemsCollected = true;
            for (Map.Entry<Integer, Integer> entry : itemsToCheck.entrySet()) {
                int itemId = entry.getKey();
                int count = entry.getValue();

                // Start with inventory count from single scan
                int inventoryCount = inventoryItemCounts.getOrDefault(itemId, 0);
                
                // Add tool lep count
                int toolLepCount = checkToolLep(itemId);
                if (toolLepCount > 0) {
                    inventoryCount += toolLepCount;
                }
                
                // Apply run-specific and item-specific overrides in order
                if (plugin.getFarmingTeleportOverlay().herbRun && itemId == BASE_SEED_ID) {
                    inventoryCount = totalSeeds;
                } else if (plugin.getFarmingTeleportOverlay().treeRun && itemId == BASE_SAPLING_ID) {
                    inventoryCount = totalSeeds;
                } else if (plugin.getFarmingTeleportOverlay().fruitTreeRun && itemId == BASE_FRUIT_SAPLING_ID) {
                    inventoryCount = totalSeeds;
                } else if (itemId == BASE_TELEPORT_CRYSTAL_ID) {
                    inventoryCount = teleportCrystalCount;
                } else if (itemId == BASE_SKILLS_NECKLACE_ID) {
                    // Skills necklace requirement is in charges, not number of items
                    inventoryCount = skillsNecklaceCharges;
                } else if (itemId == ItemID.HG_QUETZALWHISTLE_BASIC) {
                    inventoryCount = quetzalWhistleCount;
                } else if (itemId == BASE_EXPLORERS_RING_ID) {
                    // Check if any Explorer's Ring variant is equipped or in inventory
                    // inventoryItemCounts already includes equipped items from the third pass
                    boolean hasExplorersRing = false;
                    for (int ringId : EXPLORERS_RING_IDS) {
                        if (inventoryItemCounts.containsKey(ringId) && inventoryItemCounts.get(ringId) > 0) {
                            hasExplorersRing = true;
                            break;
                        }
                    }
                    inventoryCount = hasExplorersRing ? 1 : 0;
                } else if (itemId == BASE_ARDY_CLOAK_ID) {
                    // Check if any Ardougne Cloak variant is equipped or in inventory
                    // inventoryItemCounts already includes equipped items from the third pass
                    boolean hasArdyCloak = false;
                    for (int cloakId : ARDY_CLOAK_IDS) {
                        if (inventoryItemCounts.containsKey(cloakId) && inventoryItemCounts.get(cloakId) > 0) {
                            hasArdyCloak = true;
                            break;
                        }
                    }
                    inventoryCount = hasArdyCloak ? 1 : 0;
                }

                // Rune pouch contents are already included in inventoryItemCounts

                if (inventoryCount < count) {
                    allItemsCollected = false;
                    int missingCount = count - inventoryCount;
                    BufferedImage itemImage = itemManager.getImage(itemId);
                    if (itemImage != null) {
                        ImageComponent imageComponent = new ImageComponent(itemImage);
                        panelComponent.getChildren().add(imageComponent);

                        // Add the missing item and count to the list
                        missingItemsWithCounts.add(new AbstractMap.SimpleEntry<>(itemId, missingCount));

                        yOffset += itemImage.getHeight() + 2; // Update yOffset for the next item
                    }
                }
            }
            plugin.setTeleportOverlayActive(allItemsCollected);
            Dimension panelSize = panelComponent.render(graphics);

            // Draw item count on top of the overlay
            yOffset = 0;
            for (AbstractMap.SimpleEntry<Integer, Integer> pair : missingItemsWithCounts) {
                int itemId = pair.getKey();
                int missingCount = pair.getValue();

                BufferedImage itemImage = itemManager.getImage(itemId);
                if (itemImage != null) {
                    // Draw item count
                    if (missingCount > 1) {
                        String countText = Integer.toString(missingCount);
                        int textX = 2; // Calculate X position for the count text
                        int textY = yOffset + 15; // Calculate Y position for the count text
                        graphics.setColor(Color.WHITE);
                        graphics.drawString(countText, textX, textY);
                    }

                    yOffset += itemImage.getHeight() + 2; // Update yOffset for the next item
                }
            }
            // Check if all items have been collected
            if (missingItemsWithCounts.isEmpty()) {
                plugin.setItemsCollected(true);
            } else {
                plugin.setItemsCollected(false);
            }

            return panelSize;
        }
        return null;
    }
}
package com.easyfarming;

import net.runelite.api.Client;

import java.util.Arrays;
import java.util.List;
import java.util.stream.Collectors;
import java.util.stream.Stream;

public class HerbPatchChecker {
    public enum Herb {
        //Order of lists is "growing, diseased, harvest"
        GUAM(Arrays.asList(4,5,6,7), Arrays.asList(128,129,130), Arrays.asList(8,9,10)),
        MARRENTILL(Arrays.asList(11,12,13,14), Arrays.asList(131,132,133), Arrays.asList(15,16,17)),
        TARROMIN(Arrays.asList(18,19,20,21), Arrays.asList(134,135,136), Arrays.asList(22,23,24)),
        HARRALANDER(Arrays.asList(25,26,27,28), Arrays.asList(137,138,139), Arrays.asList(29,30,31)),
        RANARR(Arrays.asList(32,33,34,35), Arrays.asList(140,141,142), Arrays.asList(36,37,38)),
        TOADFLAX(Arrays.asList(39,40,41,42), Arrays.asList(143,144,145), Arrays.asList(43,44,45)),
        IRIT(Arrays.asList(46,47,48,49), Arrays.asList(146,147,148), Arrays.asList(50,51,52)),
        AVANTOE(Arrays.asList(53,54,55,56), Arrays.asList(149,159,151), Arrays.asList(57,58,59)),
        KWUARM(Arrays.asList(68,69,70,71), Arrays.asList(152,153,154), Arrays.asList(72,73,74)),
        SNAPDRAGON(Arrays.asList(75,76,77,78), Arrays.asList(155,156,157), Arrays.asList(79,80,81)),
        CADANTINE(Arrays.asList(82,83,84,85), Arrays.asList(158,159,160), Arrays.asList(86,87,88)),
        LANTADYME(Arrays.asList(89,90,91,92), Arrays.asList(161,162,163), Arrays.asList(93,94,95)),
        DWARF_WEED(Arrays.asList(96,97,98,99), Arrays.asList(164,165,166), Arrays.asList(100,101,102)),
        TORSTOL(Arrays.asList(103,104,105,106), Arrays.asList(167,168,169), Arrays.asList(107,108,109));

        private final List<Integer> growing;
        private final List<Integer> diseased;
        private final List<Integer> harvest;

        Herb(List<Integer> growing, List<Integer> diseased, List<Integer> harvest) {
            this.growing = growing;
            this.diseased = diseased;
            this.harvest = harvest;
        }
        public List<Integer> getGrowing() {
            return growing;
        }

        public List<Integer> getDead() {
            return diseased;
        }

        public List<Integer> getHarvest() {
            return harvest;
        }
    }

    // Combine all growing and dead varbit values into single lists
    private static final List<Integer> growing = Stream.of(Herb.values())
            .flatMap(herb -> herb.getGrowing().stream())
            .collect(Collectors.toList());

    private static final List<Integer> diseased = Stream.of(Herb.values())
            .flatMap(herb -> herb.getDead().stream())
            .collect(Collectors.toList());

    private static final List<Integer> harvest = Stream.of(Herb.values())
            .flatMap(herb -> herb.getHarvest().stream())
            .collect(Collectors.toList());

    private static final List<Integer> WEEDS = Arrays.asList(0, 1, 2);
    private static final List<Integer> DEAD = Arrays.asList(170, 171, 172);

    public static PlantState checkHerbPatch(Client client, int varbitIndex) {
        int varbitValue = client.getVarbitValue(varbitIndex);

        if (growing.contains(varbitValue)) {
            return PlantState.GROWING;
        } else if (diseased.contains(varbitValue)) {
            return PlantState.DISEASED;
        } else if (harvest.contains(varbitValue)) {
            return PlantState.HARVESTABLE;
        } else if (WEEDS.contains(varbitValue)) {
            return PlantState.WEEDS;
        } else if (DEAD.contains(varbitValue)) {
            return PlantState.DEAD;
        } else if (varbitValue == 3) {
            return PlantState.PLANT;
        } else {
            return PlantState.UNKNOWN;
        }
    }
    public enum PlantState {
        GROWING,
        DISEASED,
        HARVESTABLE,
        WEEDS,
        DEAD,
        PLANT,
        UNKNOWN
    }

}

package com.easyfarming.locations;

import com.easyfarming.EasyFarmingConfig;
import net.runelite.api.coords.WorldPoint;
import java.util.ArrayList;
import java.util.List;
import java.util.function.Function;

/**
 * NOTE: This class is part of an incomplete refactoring effort.
 * 
 * This class and related classes in the locations.* package were designed to replace
 * the current ItemsAndLocations.* package structure, but the migration was never completed.
 * 
 * Currently only used by LocationFactory (which is also unused).
 * 
 * SPARED FROM PURGING: This appears to be part of an unimplemented feature/refactoring
 * and may be completed in the future.
 */
public class LocationData {
    private final String name;
    private final boolean farmLimps;
    private final WorldPoint patchPoint;
    private final Function<EasyFarmingConfig, EasyFarmingConfig.OptionEnumTeleport> configFunction;
    private final List<TeleportData> teleportOptions;
    
    public LocationData(String name, boolean farmLimps, WorldPoint patchPoint,
                       Function<EasyFarmingConfig, EasyFarmingConfig.OptionEnumTeleport> configFunction) {
        this.name = name;
        this.farmLimps = farmLimps;
        this.patchPoint = patchPoint;
        this.configFunction = configFunction;
        this.teleportOptions = new ArrayList<>();
    }
    
    public LocationData addTeleport(TeleportData teleportData) {
        teleportOptions.add(teleportData);
        return this;
    }
    
    // Getters
    public String getName() { return name; }
    public boolean getFarmLimps() { return farmLimps; }
    public WorldPoint getPatchPoint() { return patchPoint; }
    public Function<EasyFarmingConfig, EasyFarmingConfig.OptionEnumTeleport> getConfigFunction() { return configFunction; }
    public List<TeleportData> getTeleportOptions() { return teleportOptions; }
}


package com.easyfarming.locations;

import com.easyfarming.core.Location;
import com.easyfarming.items.RunType;
import java.util.HashMap;
import java.util.Map;

/**
 * NOTE: This class is part of an incomplete refactoring effort.
 * 
 * This class and related classes in the locations.* package were designed to replace
 * the current ItemsAndLocations.* package structure, but the migration was never completed.
 * 
 * Currently unused - no instantiation found in the codebase.
 * 
 * SPARED FROM PURGING: This appears to be part of an unimplemented feature/refactoring
 * and may be completed in the future.
 */
public class LocationRegistry {
    private final Map<RunType, Map<String, Location>> locationsByType;
    
    public LocationRegistry() {
        this.locationsByType = new HashMap<>();
        for (RunType runType : RunType.values()) {
            locationsByType.put(runType, new HashMap<>());
        }
    }
    
    public void registerLocation(RunType runType, String locationName, Location location) {
        locationsByType.get(runType).put(locationName, location);
    }
    
    public Location getLocation(RunType runType, String locationName) {
        Map<String, Location> locations = locationsByType.get(runType);
        return locations != null ? locations.get(locationName) : null;
    }
    
    public Map<String, Location> getLocationsForType(RunType runType) {
        return locationsByType.get(runType);
    }
}


package com.easyfarming.locations;

import com.easyfarming.core.ItemRequirement;
import com.easyfarming.core.Teleport;
import net.runelite.api.coords.WorldPoint;
import java.util.List;
import java.util.function.Supplier;

/**
 * NOTE: This class is part of an incomplete refactoring effort.
 * 
 * This class and related classes in the locations.* package were designed to replace
 * the current ItemsAndLocations.* package structure, but the migration was never completed.
 * 
 * Currently only used by LocationData/LocationFactory (which are also unused).
 * 
 * SPARED FROM PURGING: This appears to be part of an unimplemented feature/refactoring
 * and may be completed in the future.
 */
public class TeleportData {
    private final String enumOption;
    private final Teleport.Category category;
    private final String description;
    private final int id;
    private final String rightClickOption;
    private final int interfaceGroupId;
    private final int interfaceChildId;
    private final int regionId;
    private final WorldPoint point;
    private final Supplier<List<ItemRequirement>> itemRequirementsSupplier;
    
    public TeleportData(String enumOption, Teleport.Category category, String description, int id,
                       String rightClickOption, int interfaceGroupId, int interfaceChildId,
                       int regionId, WorldPoint point, Supplier<List<ItemRequirement>> itemRequirementsSupplier) {
        this.enumOption = enumOption;
        this.category = category;
        this.description = description;
        this.id = id;
        this.rightClickOption = rightClickOption;
        this.interfaceGroupId = interfaceGroupId;
        this.interfaceChildId = interfaceChildId;
        this.regionId = regionId;
        this.point = point;
        this.itemRequirementsSupplier = itemRequirementsSupplier;
    }
    
    public Teleport toTeleport() {
        return new Teleport(
            enumOption, category, description, id, rightClickOption,
            interfaceGroupId, interfaceChildId, regionId, point,
            itemRequirementsSupplier.get()
        );
    }
    
    // Getters
    public String getEnumOption() { return enumOption; }
    public Teleport.Category getCategory() { return category; }
    public String getDescription() { return description; }
    public int getId() { return id; }
    public String getRightClickOption() { return rightClickOption; }
    public int getInterfaceGroupId() { return interfaceGroupId; }
    public int getInterfaceChildId() { return interfaceChildId; }
    public int getRegionId() { return regionId; }
    public WorldPoint getPoint() { return point; }
}


package com.easyfarming.locations;

import com.easyfarming.EasyFarmingConfig;
import com.easyfarming.core.Location;
import java.util.List;
import java.util.stream.Collectors;

/**
 * NOTE: This class is part of an incomplete refactoring effort.
 * 
 * This class and related classes in the locations.* package were designed to replace
 * the current ItemsAndLocations.* package structure, but the migration was never completed.
 * 
 * Currently unused - no instantiation found in the codebase.
 * 
 * SPARED FROM PURGING: This appears to be part of an unimplemented feature/refactoring
 * and may be completed in the future.
 */
public class LocationFactory {
    
    public static Location createLocation(LocationData locationData, EasyFarmingConfig config) {
        Location location = new Location(
            locationData.getConfigFunction(),
            config,
            locationData.getName(),
            locationData.getFarmLimps()
        );
        
        for (TeleportData teleportData : locationData.getTeleportOptions()) {
            location.addTeleportOption(teleportData.toTeleport());
        }
        
        return location;
    }
    
    public static List<Location> createLocations(List<LocationData> locationDataList, EasyFarmingConfig config) {
        return locationDataList.stream()
            .map(data -> createLocation(data, config))
            .collect(Collectors.toList());
    }
}


package com.easyfarming;

import net.runelite.api.Client;
import net.runelite.api.coords.WorldPoint;

import javax.inject.Inject;

public class AreaCheck {
    private Client client;

    @Inject
    public AreaCheck(Client client) {
        this.client = client;
    }

    public boolean isPlayerWithinArea(WorldPoint centerTile, int range) {
        WorldPoint playerLocation = client.getLocalPlayer().getWorldLocation();

        int minX = centerTile.getX() - range;
        int maxX = centerTile.getX() + range;
        int minY = centerTile.getY() - range;
        int maxY = centerTile.getY() + range;

        return playerLocation.getX() >= minX &&
                playerLocation.getX() <= maxX &&
                playerLocation.getY() >= minY &&
                playerLocation.getY() <= maxY;
    }
}
package com.easyfarming;

import net.runelite.api.Client;

import java.util.Arrays;
import java.util.List;
import java.util.stream.Collectors;
import java.util.stream.Stream;

public class TreePatchChecker {

    public enum Tree {
        //Order of lists is "growing, diseased, dead, healthy, remove"
        OAK(Arrays.asList(8,9,10,11), Arrays.asList(73,74,75), Arrays.asList(137, 138, 139, 141), Arrays.asList(12), Arrays.asList(13,14)),
        WILLOW(Arrays.asList(15,16,17,18,19,20), Arrays.asList(80,81,82,83,84,86), Arrays.asList(144,145,146,147,148, 150), Arrays.asList(21), Arrays.asList(22,23)),
        MAPLE(Arrays.asList(24,25,26,27,28,29,30,31), Arrays.asList(89,90,91,92,93,94,95,97), Arrays.asList(153,154,155,156,157,158,159, 161), Arrays.asList(32), Arrays.asList(33,34)),
        YEW(Arrays.asList(35,36,37,38,39,40,41,42,43,44), Arrays.asList(100,101,102,103,104,105,106,107,108, 110), Arrays.asList(164,165,166,167,168,169,170,171,172, 174), Arrays.asList(45), Arrays.asList(46,47)),
        MAGIC(Arrays.asList(48,49,50,51,52,53,54,55,56,57,58,59), Arrays.asList(113,114,115,116,117,118,119,120,121,122,123, 125), Arrays.asList(177,178,179,180,181,182,183,184,185,186,187, 189), Arrays.asList(60), Arrays.asList(61,62));

        private final List<Integer> growing;
        private final List<Integer> diseased;
        private final List<Integer> dead;
        private final List<Integer> healthy;
        private final List<Integer> remove;

        Tree(List<Integer> growing, List<Integer> diseased, List<Integer> dead, List<Integer> healthy, List<Integer> remove) {
            this.growing = growing;
            this.diseased = diseased;
            this.dead = dead;
            this.healthy = healthy;
            this.remove = remove;
        }

        public List<Integer> getGrowing() {
            return growing;
        }

        public List<Integer> getDiseased() {
            return diseased;
        }

        public List<Integer> getDead() {
            return dead;
        }

        public List<Integer> getHealthy() {
            return healthy;
        }
        public List<Integer> getRemove() {
            return remove;
        }
    }

    // Combine all growing and dead varbit values into single lists
    private static final List<Integer> growing = Stream.of(Tree.values())
            .flatMap(tree -> tree.getGrowing().stream())
            .collect(Collectors.toList());

    private static final List<Integer> diseased = Stream.of(Tree.values())
            .flatMap(tree -> tree.getDiseased().stream())
            .collect(Collectors.toList());

    private static final List<Integer> dead = Stream.of(Tree.values())
            .flatMap(tree -> tree.getDead().stream())
            .collect(Collectors.toList());

    private static final List<Integer> healthy = Stream.of(Tree.values())
            .flatMap(tree -> tree.getHealthy().stream())
            .collect(Collectors.toList());
    private static final List<Integer> remove = Stream.of(Tree.values())
            .flatMap(tree -> tree.getRemove().stream())
            .collect(Collectors.toList());

    private static final List<Integer> weeds = Arrays.asList(0, 1, 2);

    public enum PlantState {
        GROWING,
        DISEASED,
        DEAD,
        WEEDS,
        HEALTHY,
        REMOVE,
        PLANT,
        UNKNOWN
    }

    public static PlantState checkTreePatch(Client client, int varbitIndex) {
        int varbitValue = client.getVarbitValue(varbitIndex);
        if (growing.contains(varbitValue)) {
            return PlantState.GROWING;
        } else if (diseased.contains(varbitValue)) {
            return PlantState.DISEASED;
        } else if (dead.contains(varbitValue)) {
            return PlantState.DEAD;
        } else if (weeds.contains(varbitValue)) {
            return PlantState.WEEDS;
        }  else if (healthy.contains(varbitValue)) {
            return PlantState.HEALTHY;
        }else if (remove.contains(varbitValue)) {
            return PlantState.REMOVE;
        } else if (varbitValue == 3) {
            return PlantState.PLANT;
        } else {
            return PlantState.UNKNOWN;
        }
    }
}
package com.easyfarming;

import net.runelite.client.ui.PluginPanel;
import net.runelite.client.ui.overlay.OverlayManager;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import javax.swing.*;
import javax.swing.border.EmptyBorder;
import java.awt.*;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;

import com.easyfarming.ItemsAndLocations.HerbRunItemAndLocation;
import com.easyfarming.ItemsAndLocations.TreeRunItemAndLocation;
import com.easyfarming.ItemsAndLocations.FruitTreeRunItemAndLocation;

public class EasyFarmingPanel extends PluginPanel
{
    private static final Logger logger = LoggerFactory.getLogger(EasyFarmingPanel.class);
    private final HerbRunItemAndLocation herbRunItemAndLocation;
    private final TreeRunItemAndLocation treeRunItemAndLocation;
    private  final FruitTreeRunItemAndLocation fruitTreeRunItemAndLocation;
	private final EasyFarmingPlugin plugin;
    private final OverlayManager overlayManager;
    private final FarmingTeleportOverlay farmingTeleportOverlay;

    public StartStopJButton herbButton;
    public StartStopJButton treeButton;
    public StartStopJButton fruitTreeButton;

    public EasyFarmingPanel(EasyFarmingPlugin plugin, OverlayManager overlayManager, FarmingTeleportOverlay farmingTeleportOverlay, HerbRunItemAndLocation herbRunItemAndLocation, TreeRunItemAndLocation treeRunItemAndLocation, FruitTreeRunItemAndLocation fruitTreeRunItemAndLocation)
    {
        this.herbRunItemAndLocation = herbRunItemAndLocation;
        this.treeRunItemAndLocation = treeRunItemAndLocation;
        this.farmingTeleportOverlay = farmingTeleportOverlay;
        this.fruitTreeRunItemAndLocation = fruitTreeRunItemAndLocation;

        this.plugin = plugin;
        this.overlayManager = overlayManager;

        setLayout(new BorderLayout());
        setBorder(new EmptyBorder(10, 10, 10, 10));

        JPanel layoutPanel = new JPanel();
        layoutPanel.setLayout(new BoxLayout(layoutPanel, BoxLayout.Y_AXIS));

        JPanel titlePanel = createTitlePanel();
        JPanel farmRunButtons = createFarmRunButtons();
        JPanel infoPanel = createInfoPanel();

        layoutPanel.add(titlePanel);
        layoutPanel.add(farmRunButtons);
        layoutPanel.add(infoPanel);

        add(layoutPanel, BorderLayout.NORTH);
    }

    private JPanel createTitlePanel()
    {
        JPanel titlePanel = new JPanel();
        titlePanel.setBorder(new EmptyBorder(0, 0, 15, 0));
        titlePanel.setLayout(new BorderLayout());

        JLabel title = new JLabel("Pick a new farm run:");
        titlePanel.add(title, BorderLayout.WEST);

        return titlePanel;
    }

    private JPanel createFarmRunButtons()
    {
        JPanel farmRunButtonsContainingPanel = new JPanel();
        farmRunButtonsContainingPanel.setLayout(new BoxLayout(farmRunButtonsContainingPanel, BoxLayout.Y_AXIS));

        // With GridLayout, you can't set the button height.
        // With GridBagLayout, you can't make the buttons the full width of the container.
        // The height seemed like the better thing to let go of.
        JPanel farmRunButtonsPanel = new JPanel(new GridLayout(0, 1, 0, 15));
        farmRunButtonsPanel.setBorder(new EmptyBorder(0, 0, 0, 0));

        herbButton = new StartStopJButton("Herb Run");
		herbButton.setFocusable(false);
        herbButton.addActionListener(new ActionListener() {
            @Override
            public void actionPerformed(ActionEvent e) {
                plugin.runOnClientThread(() -> {
                    plugin.setOverlayActive(!plugin.isOverlayActive());

                    herbButton.setStartStopState(plugin.isOverlayActive());

                    onHerbButtonClicked();
                });
            }
        });
        farmRunButtonsPanel.add(herbButton);

        treeButton = new StartStopJButton("Tree Run");
        treeButton.setFocusable(false);
        treeButton.addActionListener(new ActionListener()
        {
            @Override
            public void actionPerformed(ActionEvent e) {
                plugin.runOnClientThread(() -> {
                    plugin.setOverlayActive(!plugin.isOverlayActive());

                    treeButton.setStartStopState(plugin.isOverlayActive());

                    onTreeButtonClicked();
                });
            }
        });
        farmRunButtonsPanel.add(treeButton);

        fruitTreeButton = new StartStopJButton("Fruit Tree Run");
        fruitTreeButton.setFocusable(false);
        fruitTreeButton.addActionListener(new ActionListener()
        {
            @Override
            public void actionPerformed(ActionEvent e) {
                plugin.runOnClientThread(() -> {
                    plugin.setOverlayActive(!plugin.isOverlayActive());

                    fruitTreeButton.setStartStopState(plugin.isOverlayActive());

                    onFruitTreeButtonClicked();
                });
            }
        });
        farmRunButtonsPanel.add(fruitTreeButton);

        farmRunButtonsContainingPanel.add(farmRunButtonsPanel);

        return farmRunButtonsContainingPanel;
    }

    private JPanel createInfoPanel()
    {
        JPanel infoContainingPanel = new JPanel();
        infoContainingPanel.setLayout(new BoxLayout(infoContainingPanel, BoxLayout.Y_AXIS));
        
        JPanel infoPanel = new JPanel(new GridLayout(0, 1, 0, 0));
        infoPanel.setBorder(new EmptyBorder(25, 0, 0, 0));

        JTextArea textAreaTip = new JTextArea("Tips: \n - Rune pouch and combination runes work. \n - If you don't have Bottomless compost bucket you should store compost @ Tool Leprechaun, the plugin checks if you have compost stored there.");
        textAreaTip.setWrapStyleWord(true);
        textAreaTip.setLineWrap(true);
        textAreaTip.setEditable(false);
        infoPanel.add(textAreaTip);

        infoContainingPanel.add(infoPanel);

        return infoContainingPanel;
    }

    private void onHerbButtonClicked() {
        SwingUtilities.invokeLater(new Runnable() {
            @Override
            public void run() {
                EasyFarmingOverlay overlay = plugin.getEasyFarmingOverlay();

                if (!plugin.isOverlayActive()) {
                    farmingTeleportOverlay.removeOverlay();
                    logger.debug("Remove overlay from button");
                } else {
                    logger.debug("Add overlay from button");
                    plugin.getFarmingTeleportOverlay().herbRun = true;
                    overlayManager.add(overlay);
                    overlayManager.add(farmingTeleportOverlay);
                }
            }
        });
    }

    private void onTreeButtonClicked()
    {
        // Handle button click event here
        SwingUtilities.invokeLater(new Runnable()
        {
            @Override
            public void run() {
                EasyFarmingOverlay overlay = plugin.getEasyFarmingOverlay();

                if (!plugin.isOverlayActive()) {
                    farmingTeleportOverlay.removeOverlay();
                    logger.debug("Remove overlay from button");
                } else {
                    logger.debug("Add overlay from button");
                    plugin.getFarmingTeleportOverlay().treeRun = true;
                    overlayManager.add(overlay);
                    overlayManager.add(farmingTeleportOverlay);
                }
            }
        });
    }
	private void onFruitTreeButtonClicked()
    {
        // Handle button click event here
        SwingUtilities.invokeLater(new Runnable()
        {
            @Override
            public void run() {
                EasyFarmingOverlay overlay = plugin.getEasyFarmingOverlay();

                if (!plugin.isOverlayActive()) {
                    farmingTeleportOverlay.removeOverlay();
                    logger.debug("Remove overlay from button");
                } else {
                    logger.debug("Add overlay from button");
                    plugin.getFarmingTeleportOverlay().fruitTreeRun = true;
                    overlayManager.add(overlay);
                    overlayManager.add(farmingTeleportOverlay);
                }
            }
        });
    }
}
package com.easyfarming;

import net.runelite.api.Client;
import net.runelite.client.ui.overlay.Overlay;
import net.runelite.client.ui.overlay.OverlayLayer;
import net.runelite.client.ui.overlay.OverlayPosition;
import net.runelite.client.ui.overlay.components.LineComponent;
import net.runelite.client.ui.overlay.components.PanelComponent;

import javax.inject.Inject;
import java.awt.Dimension;
import java.awt.Graphics2D;

public class EasyFarmingOverlayInfoBox extends Overlay {
    private final Client client;
    private final PanelComponent panelComponent = new PanelComponent();
    private final EasyFarmingPlugin plugin;

    private String text;

    @Inject
    public EasyFarmingOverlayInfoBox(Client client, EasyFarmingPlugin plugin) {
        this.client = client;
        this.plugin = plugin;
        setPosition(OverlayPosition.TOP_LEFT);
        setLayer(OverlayLayer.ALWAYS_ON_TOP);
    }

    public void setText(String text) {
        this.text = text;
    }

    @Override
    public Dimension render(Graphics2D graphics) {
        if (!plugin.isOverlayActive()) {
            return null;
        }

        panelComponent.getChildren().clear();

        if (text != null) {
            panelComponent.getChildren().add(LineComponent.builder().left(text).build());
        }

        return panelComponent.render(graphics);
    }
}
package com.easyfarming;

import java.awt.*;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.function.Function;

import net.runelite.api.coords.WorldPoint;

public class Location {
    public enum TeleportCategory {
        ITEM,
        PORTAL_NEXUS,
        SPIRIT_TREE,
        JEWELLERY_BOX,
        MOUNTED_XERICS,
        SPELLBOOK
    }
    private String name;

    public String getName() {
        return name;
    }
    private Boolean farmLimps;

    public Boolean getFarmLimps() {
        return farmLimps;
    }

    private List<Teleport> teleportOptions;
    private EasyFarmingConfig config;
    private final Function<EasyFarmingConfig, EasyFarmingConfig.OptionEnumTeleport> selectedTeleportFunction;

    public Location(Function<EasyFarmingConfig, EasyFarmingConfig.OptionEnumTeleport> selectedTeleportFunction, EasyFarmingConfig config, String name, Boolean farmLimps) {
        this.config = config;
        this.selectedTeleportFunction = selectedTeleportFunction;
        this.name = name;
        this.farmLimps = farmLimps;
        this.teleportOptions = new ArrayList<>();
    }

    public void addTeleportOption(Teleport teleport) {
        teleportOptions.add(teleport);
    }

    public Teleport getSelectedTeleport() {
        String selectedEnumOption = selectedTeleportFunction.apply(config).name();
        for (Teleport teleport : teleportOptions) {
            if (teleport.getEnumOption().equalsIgnoreCase(selectedEnumOption)) {
                return teleport;
            }
        }
        return teleportOptions.isEmpty() ? null : teleportOptions.get(0);
    }





    public class Teleport {
        private TeleportCategory category;
        private String description;
        private Color color;
        private int id;
        private int interfaceGroupId;
        private int interfaceChildId;

        private int regionId;
        private String enumOption;
        private String rightClickOption;
        private List<ItemRequirement> itemRequirements;
        private WorldPoint point;

        public Teleport(String enumOption, TeleportCategory category, String description, int id, String rightClickOption, int interfaceGroupId, int interfaceChildId, int regionId, WorldPoint point, List<ItemRequirement> itemRequirements) {
            this.enumOption = enumOption;
            this.category = category;
            this.description = description;
            this.id = id;
            this.rightClickOption = rightClickOption;
            this.interfaceGroupId = interfaceGroupId;
            this.interfaceChildId = interfaceChildId;
            this.regionId = regionId;
            this.point = point;
            this.itemRequirements = itemRequirements;
        }

        public Map<Integer, Integer> getItemRequirements() {
            Map<Integer, Integer> requirements = new HashMap<>();
            for (ItemRequirement itemRequirement : itemRequirements) {
                requirements.put(itemRequirement.getItemId(), itemRequirement.getQuantity());
            }
            return requirements;
        }

        public WorldPoint getPoint(){return point;}

        public void addItemRequirement(int itemId, int quantity) {
            ItemRequirement itemRequirement = new ItemRequirement(itemId, quantity);
            this.itemRequirements.add(itemRequirement);
        }
        public void addAllItemRequirements(List<ItemRequirement> itemRequirements) {
            this.itemRequirements.addAll(itemRequirements);
        }

        public void updateTeleportItemId(int newItemId) {
            this.id = newItemId;
        }

        public TeleportCategory getCategory() {
            return category;
        }
        public int getRegionId() {
            return regionId;
        }
        public String getEnumOption() {
            return enumOption;
        }

        public String getDescription() {
            return description;
        }
        public String getRightClickOption() {
            return rightClickOption;
        }

        public void setDescription(String description) {
            this.description = description;
        }

        public int getId() {
            return id;
        }

        public void setId(int id) {
            this.id = id;
        }

        public int getInterfaceGroupId() {
            return interfaceGroupId;
        }

        public void setInterfaceGroupId(int interfaceGroupId) {
            this.interfaceGroupId = interfaceGroupId;
        }

        public int getInterfaceChildId() {
            return interfaceChildId;
        }

        public void setInterfaceChildId(int interfaceChildId) {
            this.interfaceChildId = interfaceChildId;
        }

        public Color getColor() {
            return  color;
        }
    }
}
package com.easyfarming;
public class ItemRequirement {
    private int itemId;
    private int quantity;

    public ItemRequirement(int itemId, int quantity) {
        this.itemId = itemId;
        this.quantity = quantity;
    }

    public int getItemId() {
        return itemId;
    }

    public int getQuantity() {
        return quantity;
    }
}

package com.easyfarming;

import net.runelite.api.Client;
import net.runelite.api.gameval.VarbitID;
import net.runelite.api.gameval.InterfaceID;
import net.runelite.api.widgets.Widget;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import java.util.Arrays;
import java.util.List;

public class InventoryTabChecker {
    private static final Logger log = LoggerFactory.getLogger(InventoryTabChecker.class);
    
    // Lists for each tab state
    private static final List<Integer> INVENTORY = Arrays.asList(3);
    private static final List<Integer> SPELLBOOK = Arrays.asList(6);

    public enum TabState {
        INVENTORY,
        SPELLBOOK,
        REST
    }

    public static TabState checkTab(Client client, int varbitIndex) {
        int varbitValue = client.getVarcIntValue(varbitIndex);
        
        // Original working logic - keep this for now
        List<Integer> INVENTORY = Arrays.asList(3);
        List<Integer> SPELLBOOK = Arrays.asList(6);
        
        if (INVENTORY.contains(varbitValue)) {
            return TabState.INVENTORY;
        } else if (SPELLBOOK.contains(varbitValue)) {
            return TabState.SPELLBOOK;
        } else {
            return TabState.REST;
        }
    }}
package com.easyfarming.ItemsAndLocations;

import com.easyfarming.EasyFarmingConfig;
import com.easyfarming.EasyFarmingPlugin;
import com.easyfarming.ItemRequirement;
import com.easyfarming.Location;
import net.runelite.api.Client;
import net.runelite.api.gameval.ItemID;
import net.runelite.api.coords.WorldPoint;

import java.util.*;

public class FruitTreeRunItemAndLocation extends ItemAndLocation
{
    public Location brimhavenFruitTreeLocation;
    public Location catherbyFruitTreeLocation;
    public Location farmingGuildFruitTreeLocation;
    public Location gnomeStrongholdFruitTreeLocation;
    public Location lletyaFruitTreeLocation;
    public Location treeGnomeVillageFruitTreeLocation;

    public FruitTreeRunItemAndLocation()
    {
    }

    public FruitTreeRunItemAndLocation(EasyFarmingConfig config, Client client, EasyFarmingPlugin plugin)
    {
        super(
            config,
            client,
            plugin
        );
    }

    public Map<Integer, Integer> getFruitTreeItems()
    {
        return getAllItemRequirements(locations);
    }

    public Map<Integer, Integer> getAllItemRequirements(List<Location> locations)
    {
        Map<Integer, Integer> allRequirements = new HashMap<>();

        setupLocations();

        // Add other items and merge them with allRequirements
        for (Location location : locations) {
            if (plugin.getFruitTreeLocationEnabled(location.getName())) {
                //ItemID.GUAM_SEED is default for herb seeds, code later will allow for any seed to be used, just needed a placeholder ID
                //allRequirements.merge(ItemID.GUAM_SEED, 1, Integer::sum);
                allRequirements.merge(
                    ItemID.PLANTPOT_APPLE_SAPLING,
                    1,
                    Integer::sum
                );

                allRequirements.merge(
                    ItemID.COINS,
                    200,
                    Integer::sum
                );

                if (selectedCompostID() != -1 && selectedCompostID() != ItemID.BOTTOMLESS_COMPOST_BUCKET) {
                    allRequirements.merge(
                        selectedCompostID(),
                        1,
                        Integer::sum
                    );
                }

                Location.Teleport teleport = location.getSelectedTeleport();

                Map<Integer, Integer> locationRequirements = teleport.getItemRequirements();

                for (Map.Entry<Integer, Integer> entry : locationRequirements.entrySet()) {
                    int itemId = entry.getKey();
                    int quantity = entry.getValue();

                    if (itemId == ItemID.SKILLCAPE_CONSTRUCTION || itemId == ItemID.SKILLCAPE_CONSTRUCTION_TRIMMED || itemId == ItemID.SKILLCAPE_MAX || itemId == ItemID.MM2_ROYAL_SEED_POD) {
                        allRequirements.merge(
                            itemId,
                            quantity,
                            (oldValue, newValue) -> Math.min(
                                1,
                                oldValue + newValue
                            )
                        );
                    } else {
                        allRequirements.merge(
                            itemId,
                            quantity,
                            Integer::sum
                        );
                    }
                }
            }
        }

        //allRequirements.merge(ItemID.SEED_DIBBER, 1, Integer::sum);
        allRequirements.merge(
            ItemID.SPADE,
            1,
            Integer::sum
        );

        // Only add bottomless compost bucket if it's selected in config
        if (selectedCompostID() == ItemID.BOTTOMLESS_COMPOST_BUCKET) {
            allRequirements.merge(
                ItemID.BOTTOMLESS_COMPOST_BUCKET,
                1,
                Integer::sum
            );
        }

        allRequirements.merge(
            ItemID.FAIRY_ENCHANTED_SECATEURS,
            1,
            Integer::sum
        );

        if (config.generalRake()) {
            allRequirements.merge(
                ItemID.RAKE,
                1,
                Integer::sum
            );
        }

        return allRequirements;
    }

    public void setupLocations()
    {
        super.setupLocations();

        setupBrimhavenLocations();
        setupCatherbyLocations();
        setupFarmingGuildLocation();
        setupGnomeStrongholdLocation();
        setupLletyaLocation();
        setupTreeGnomeVillage();
    }

    private void setupBrimhavenLocations()
    {
        WorldPoint brimhavenFruitTreePatchPoint = new WorldPoint(
            2764,
            3212,
            0
        );

        brimhavenFruitTreeLocation = new Location(
            EasyFarmingConfig::enumFruitTreeBrimhavenTeleport,
            config,
            "Brimhaven",
            false
        );

        brimhavenFruitTreeLocation.addTeleportOption(brimhavenFruitTreeLocation.new Teleport(
            "Portal_Nexus",
            Location.TeleportCategory.PORTAL_NEXUS,
            "Teleport to Ardougne with Portal Nexus and take the boat to Brimhaven.",
            0,
            "null",
            17,
            13,
            10547,
            brimhavenFruitTreePatchPoint,
            getHouseTeleportItemRequirements()
        ));

        brimhavenFruitTreeLocation.addTeleportOption(brimhavenFruitTreeLocation.new Teleport(
            "Ardougne_teleport",
            Location.TeleportCategory.SPELLBOOK,
            "Teleport to Ardougne with Spellbook and take the boat to Brimhaven.",
            0,
            "null",
            218,
            41,
            10547,
            brimhavenFruitTreePatchPoint,
            Arrays.asList(
                new ItemRequirement(
                    ItemID.COINS,
                    30
                ),
                new ItemRequirement(
                    ItemID.LAWRUNE,
                    2
                ),
                new ItemRequirement(
                    ItemID.WATERRUNE,
                    2
                )
            )
        ));

        brimhavenFruitTreeLocation.addTeleportOption(brimhavenFruitTreeLocation.new Teleport(
            "Ardougne_Tele_Tab",
            Location.TeleportCategory.ITEM,
            "Teleport to Ardougne with Ardougne tele tab and take the boat to Brimhaven.",
            ItemID.POH_TABLET_ARDOUGNETELEPORT,
            "null",
            0,
            0,
            10547,
            brimhavenFruitTreePatchPoint,
            Arrays.asList(
                new ItemRequirement(
                    ItemID.POH_TABLET_ARDOUGNETELEPORT,
                    1
                ),
                new ItemRequirement(
                    ItemID.COINS,
                    30
                )
            )
        ));

        brimhavenFruitTreeLocation.addTeleportOption(brimhavenFruitTreeLocation.new Teleport(
            "POH_Tele_Tab",
            Location.TeleportCategory.ITEM,
            "Teleport to house with POH tele tab, use Portal Nexus to Ardougne and take the boat to Brimhaven.",
            ItemID.POH_TABLET_TELEPORTTOHOUSE,
            "null",
            0,
            0,
            10547,
            brimhavenFruitTreePatchPoint,
            Arrays.asList(
                new ItemRequirement(
                    ItemID.POH_TABLET_TELEPORTTOHOUSE,
                    1
                ),
                new ItemRequirement(
                    ItemID.COINS,
                    30
                )
            )
        ));

        locations.add(brimhavenFruitTreeLocation);
    }

    private void setupCatherbyLocations()
    {
        WorldPoint cathebyFruitTreePatchPoint = new WorldPoint(
            2860,
            3433,
            0
        );

        catherbyFruitTreeLocation = new Location(
            EasyFarmingConfig::enumFruitTreeCatherbyTeleport,
            config,
            "Catherby",
            false
        );

        catherbyFruitTreeLocation.addTeleportOption(catherbyFruitTreeLocation.new Teleport(
            "Portal_Nexus_Catherby",
            Location.TeleportCategory.PORTAL_NEXUS,
            "Teleport to Catherby with Portal Nexus.",
            0,
            "null",
            17,
            13,
            11061,
            cathebyFruitTreePatchPoint,
            getHouseTeleportItemRequirements()
        ));

        catherbyFruitTreeLocation.addTeleportOption(catherbyFruitTreeLocation.new Teleport(
            "Portal_Nexus_Camelot",
            Location.TeleportCategory.PORTAL_NEXUS,
            "Teleport to Camelot with Portal Nexus.",
            0,
            "null",
            17,
            13,
            11062,
            cathebyFruitTreePatchPoint,
            getHouseTeleportItemRequirements()
        ));

        catherbyFruitTreeLocation.addTeleportOption(catherbyFruitTreeLocation.new Teleport(
            "Camelot_Teleport",
            Location.TeleportCategory.SPELLBOOK,
            "Teleport to Camelot using the standard spellbook, and run east. (If you have configured the teleport to seers you need to right click and teleport to Camelot)",
            0,
            "null",
            218,
            34,
            11062,
            cathebyFruitTreePatchPoint,
            Arrays.asList(
                new ItemRequirement(
                    ItemID.AIRRUNE,
                    5
                ),
                new ItemRequirement(
                    ItemID.LAWRUNE,
                    1
                )
            )
        ));

        catherbyFruitTreeLocation.addTeleportOption(catherbyFruitTreeLocation.new Teleport(
            "Camelot_Tele_Tab",
            Location.TeleportCategory.ITEM,
            "Teleport to Camelot using a Camelot tele tab, and run east.(If you have configured the teleport to seers you need to right click and teleport to Camelot)",
            ItemID.POH_TABLET_CAMELOTTELEPORT,
            "null",
            0,
            0,
            11062,
            cathebyFruitTreePatchPoint,
            Collections.singletonList(new ItemRequirement(
                ItemID.POH_TABLET_CAMELOTTELEPORT,
                1
            ))
        ));

        catherbyFruitTreeLocation.addTeleportOption(catherbyFruitTreeLocation.new Teleport(
            "Catherby_Tele_Tab",
            Location.TeleportCategory.ITEM,
            "Teleport to Catherby using Catherby teleport tab.",
            ItemID.LUNAR_TABLET_CATHERBY_TELEPORT,
            "null",
            0,
            0,
            11061,
            cathebyFruitTreePatchPoint,
            Collections.singletonList(new ItemRequirement(
                ItemID.LUNAR_TABLET_CATHERBY_TELEPORT,
                1
            ))
        ));

        locations.add(catherbyFruitTreeLocation);
    }

    private void setupFarmingGuildLocation()
    {
        WorldPoint farmingGuildFruitTreePatchPoint = new WorldPoint(
            1243,
            3759,
            0
        );

        farmingGuildFruitTreeLocation = new Location(
            EasyFarmingConfig::enumFruitTreeFarmingGuildTeleport,
            config,
            "Farming Guild",
            false
        );

        farmingGuildFruitTreeLocation.addTeleportOption(farmingGuildFruitTreeLocation.new Teleport(
            "Jewellery_box",
            Location.TeleportCategory.JEWELLERY_BOX,
            "Teleport to Farming Guild with Jewellery box.",
            0,
            "null",
            17,
            13,
            4922,
            farmingGuildFruitTreePatchPoint,
            getHouseTeleportItemRequirements()
        ));

        farmingGuildFruitTreeLocation.addTeleportOption(farmingGuildFruitTreeLocation.new Teleport(
            "Skills_Necklace",
            Location.TeleportCategory.ITEM,
            "Teleport to Farming guild using Skills necklace.",
            ItemID.JEWL_NECKLACE_OF_SKILLS_1,
            "null",
            0,
            0,
            4922,
            farmingGuildFruitTreePatchPoint,
            Collections.singletonList(new ItemRequirement(
                ItemID.JEWL_NECKLACE_OF_SKILLS_1,
                1
            ))
        ));

        locations.add(farmingGuildFruitTreeLocation);
    }

    private void setupGnomeStrongholdLocation()
    {
        WorldPoint gnomeStrongholdFruitTreePatchPoint = new WorldPoint(
            2475,
            3446,
            0
        );

        gnomeStrongholdFruitTreeLocation = new Location(
            EasyFarmingConfig::enumFruitTreeGnomeStrongholdTeleport,
            config,
            "Gnome Stronghold",
            false
        );

        gnomeStrongholdFruitTreeLocation.addTeleportOption(gnomeStrongholdFruitTreeLocation.new Teleport(
            "Royal_seed_pod",
            Location.TeleportCategory.ITEM,
            "Teleport to Gnome Stronghold with Royal seed pod.",
            ItemID.MM2_ROYAL_SEED_POD,
            "null",
            0,
            0,
            9782,
            gnomeStrongholdFruitTreePatchPoint,
            Collections.singletonList(new ItemRequirement(
                ItemID.MM2_ROYAL_SEED_POD,
                1
            ))
        ));

        gnomeStrongholdFruitTreeLocation.addTeleportOption(gnomeStrongholdFruitTreeLocation.new Teleport(
            "Spirit_Tree",
            Location.TeleportCategory.SPIRIT_TREE,
            "Teleport to Gnome Stronghold via a Spirit Tree.",
            0,
            "null",
            187,
            3,
            9781,
            gnomeStrongholdFruitTreePatchPoint,
            Collections.<ItemRequirement> emptyList()
        ));

        locations.add(gnomeStrongholdFruitTreeLocation);
    }

    private void setupLletyaLocation()
    {
        WorldPoint lletyaFruitTreePatchPoint = new WorldPoint(
            2346,
            3162,
            0
        );

        lletyaFruitTreeLocation = new Location(
            EasyFarmingConfig::enumFruitTreeLletyaTeleport,
            config,
            "Lletya",
            false
        );

        lletyaFruitTreeLocation.addTeleportOption(lletyaFruitTreeLocation.new Teleport(
            "Teleport_crystal",
            Location.TeleportCategory.ITEM,
            "Teleport to Lletya with Teleport crystal.",
            ItemID.MOURNING_TELEPORT_CRYSTAL_1,
            "null",
            0,
            0,
            9265,
            lletyaFruitTreePatchPoint,
            Collections.singletonList(new ItemRequirement(
                ItemID.MOURNING_TELEPORT_CRYSTAL_1,
                1
            ))
        ));

        locations.add(lletyaFruitTreeLocation);
    }

    private void setupTreeGnomeVillage()
    {
        WorldPoint treeGnomeVillageFruitTreePatchPoint = new WorldPoint(
            2490,
            3180,
            0
        );

        treeGnomeVillageFruitTreeLocation = new Location(
            EasyFarmingConfig::enumFruitTreeTreeGnomeVillageTeleport,
            config,
            "Tree Gnome Village",
            false
        );

        treeGnomeVillageFruitTreeLocation.addTeleportOption(treeGnomeVillageFruitTreeLocation.new Teleport(
            "Royal_seed_pod",
            Location.TeleportCategory.ITEM,
            "Teleport to Tree Gnome Village with Royal seed pod and use Spirit tree to Tree Gnome Village.",
            ItemID.MM2_ROYAL_SEED_POD,
            "null",
            0,
            0,
            9782,
            treeGnomeVillageFruitTreePatchPoint,
            Collections.singletonList(new ItemRequirement(
                ItemID.MM2_ROYAL_SEED_POD,
                1
            ))
        ));

        treeGnomeVillageFruitTreeLocation.addTeleportOption(treeGnomeVillageFruitTreeLocation.new Teleport(
            "Spirit_Tree",
            Location.TeleportCategory.SPIRIT_TREE,
            "Teleport to Tree Gnome Village via a Spirit Tree.",
            0,
            "null",
            187,
            3,
            10033,
            treeGnomeVillageFruitTreePatchPoint,
            Collections.<ItemRequirement> emptyList()
        ));

        locations.add(treeGnomeVillageFruitTreeLocation);
    }
}
package com.easyfarming.ItemsAndLocations;

import com.easyfarming.EasyFarmingConfig;
import com.easyfarming.EasyFarmingPlugin;
import com.easyfarming.ItemRequirement;
import com.easyfarming.Location;
import net.runelite.api.Client;
import net.runelite.api.gameval.ItemID;
import net.runelite.api.coords.WorldPoint;

import java.util.*;

public class HerbRunItemAndLocation extends ItemAndLocation
{
    public Location ardougneLocation;
    public Location catherbyLocation;
    public Location faladorLocation;
    public Location farmingGuildLocation;
    public Location harmonyLocation;
    public Location kourendLocation;
    public Location morytaniaLocation;
    public Location trollStrongholdLocation;
    public Location weissLocation;
    public Location civitasLocation;

    public HerbRunItemAndLocation()
    {
    }

    public HerbRunItemAndLocation(EasyFarmingConfig config, Client client, EasyFarmingPlugin plugin)
    {
        super(
            config,
            client,
            plugin
        );
    }

    public Map<Integer, Integer> getHerbItems()
    {
        return getAllItemRequirements(locations);
    }

    public Map<Integer, Integer> getAllItemRequirements(List<Location> locations)
    {
        Map<Integer, Integer> allRequirements = new HashMap<>();

        setupLocations();

        // Add other items and merge them with allRequirements
        for (Location location : locations) {
            if (plugin.getHerbLocationEnabled(location.getName())) {
                //ItemID.GUAM_SEED is default for herb seeds, code later will allow for any seed to be used, just needed a placeholder ID
                allRequirements.merge(
                    ItemID.GUAM_SEED,
                    1,
                    Integer::sum
                );

                if (selectedCompostID() != - 1 && selectedCompostID() != ItemID.BOTTOMLESS_COMPOST_BUCKET) {
                    allRequirements.merge(
                        selectedCompostID(),
                        1,
                        Integer::sum
                    );
                }

                Location.Teleport teleport = location.getSelectedTeleport();

                Map<Integer, Integer> locationRequirements = teleport.getItemRequirements();

                for (Map.Entry<Integer, Integer> entry : locationRequirements.entrySet()) {
                    int itemId = entry.getKey();
                    int quantity = entry.getValue();

                    if (itemId == ItemID.SKILLCAPE_CONSTRUCTION || itemId == ItemID.SKILLCAPE_CONSTRUCTION_TRIMMED || itemId == ItemID.SKILLCAPE_MAX) {
                        allRequirements.merge(
                            itemId,
                            quantity,
                            (oldValue, newValue) -> Math.min(
                                1,
                                oldValue + newValue
                            )
                        );
                    } else if (itemId == ItemID.HG_QUETZALWHISTLE_BASIC || itemId == ItemID.HG_QUETZALWHISTLE_ENHANCED || itemId == ItemID.HG_QUETZALWHISTLE_PERFECTED) {
                        // Handle Quetzal whistle variants - only show the basic one in requirements
                        allRequirements.merge(
                            ItemID.HG_QUETZALWHISTLE_BASIC,  // Always show the basic variant
                            quantity,
                            (oldValue, newValue) -> Math.min(
                                1,
                                oldValue + newValue
                            )
                        );
                    } else if (itemId == ItemID.SKILLCAPE_HUNTING || itemId == ItemID.SKILLCAPE_HUNTING_TRIMMED) {
                        // Handle Hunter skillcape variants - only show the regular one in requirements
                        allRequirements.merge(
                            ItemID.SKILLCAPE_HUNTING,  // Always show the regular variant
                            quantity,
                            (oldValue, newValue) -> Math.min(
                                1,
                                oldValue + newValue
                            )
                        );
                    } else if (itemId == ItemID.LUMBRIDGE_RING_MEDIUM || itemId == ItemID.LUMBRIDGE_RING_HARD || itemId == ItemID.LUMBRIDGE_RING_ELITE) {
                        // Handle Explorer's Ring variants - normalize to base ID
                        allRequirements.merge(
                            ItemID.LUMBRIDGE_RING_MEDIUM,  // Always show the base variant
                            quantity,
                            (oldValue, newValue) -> Math.min(
                                1,
                                oldValue + newValue
                            )
                        );
                    } else if (itemId == ItemID.ARDY_CAPE_MEDIUM || itemId == ItemID.ARDY_CAPE_HARD || itemId == ItemID.ARDY_CAPE_ELITE) {
                        // Handle Ardougne Cloak variants - normalize to base ID
                        allRequirements.merge(
                            ItemID.ARDY_CAPE_MEDIUM,  // Always show the base variant
                            quantity,
                            (oldValue, newValue) -> Math.min(
                                1,
                                oldValue + newValue
                            )
                        );
                    } else {
                        allRequirements.merge(
                            itemId,
                            quantity,
                            Integer::sum
                        );
                    }
                }

                if (location.getFarmLimps() && config.generalLimpwurt()) {
                    allRequirements.merge(
                        ItemID.LIMPWURT_SEED,
                        1,
                        Integer::sum
                    );

                    if (selectedCompostID() != - 1 && selectedCompostID() != ItemID.BOTTOMLESS_COMPOST_BUCKET) {
                        allRequirements.merge(
                            selectedCompostID(),
                            1,
                            Integer::sum
                        );
                    }
                }
            }
        }
        if(config.generalSeedDibber()) {
            allRequirements.merge(
                ItemID.DIBBER,
                1,
                Integer::sum
            );
        }

        allRequirements.merge(
            ItemID.SPADE,
            1,
            Integer::sum
        );

        if (selectedCompostID() == ItemID.BOTTOMLESS_COMPOST_BUCKET) {
            allRequirements.merge(
                ItemID.BOTTOMLESS_COMPOST_BUCKET,
                1,
                Integer::sum
            );
        }

        allRequirements.merge(
            ItemID.FAIRY_ENCHANTED_SECATEURS,
            1,
            Integer::sum
        );

        if (config.generalRake()) {
            allRequirements.merge(
                ItemID.RAKE,
                1,
                Integer::sum
            );
        }

        return allRequirements;
    }

    public void setupLocations()
    {
        super.setupLocations();

        setupArdougneLocation();
        setupCatherbyLocation();
        setupFaladorLocation();
        setupFarmingGuildLocation();
        setupHarmonyLocation();
        setupKourendLocation();
        setupMorytaniaLocation();
        setupTrollStrongholdLocation();
        setupWeissLocation();
        setupCivitasLocation();
    }

    private void setupCivitasLocation()
    {
        WorldPoint civitasHerbPatchPoint = new WorldPoint(
            1586,
            3099,
            0
        );

        civitasLocation = new Location(
            EasyFarmingConfig::enumOptionEnumCivitasTeleport,
            config,
            "Civitas illa Fortis",
            true
        );

        civitasLocation.addTeleportOption(civitasLocation.new Teleport(
            "Portal_Nexus",
            Location.TeleportCategory.PORTAL_NEXUS,
            "Teleport to Civitas illa Fortis with Portal Nexus.",
            0,
            "null",
            17,
            13,
            6192,
            civitasHerbPatchPoint, 
            getHouseTeleportItemRequirements()
        ));

        civitasLocation.addTeleportOption(civitasLocation.new Teleport(
            "Civitas_Teleport",
            Location.TeleportCategory.SPELLBOOK,
            "Teleport to Civitas illa Fortis with standard spellbook, and run west.",
            0,
            "null",
            218,
            43,
            6192,
            civitasHerbPatchPoint,
            Arrays.asList(
                new ItemRequirement(
                    ItemID.LAWRUNE,
                    2
                ),
                new ItemRequirement(
                    ItemID.AIRRUNE,
                    1
                ),
                new ItemRequirement(
                    ItemID.EARTHRUNE,
                    1
                )
            )
        ));

        civitasLocation.addTeleportOption(civitasLocation.new Teleport(
            "Civitas_Tele_Tab",
            Location.TeleportCategory.ITEM,
            "Teleport to Civitas illa Fortis with Civitas teleport tab, and run west.",
            ItemID.POH_TABLET_FORTISTELEPORT,
            "null",
            0,
            0,
            6192,
            civitasHerbPatchPoint,
            Collections.singletonList(new ItemRequirement(
                ItemID.POH_TABLET_FORTISTELEPORT,
                1
            ))
        ));

        civitasLocation.addTeleportOption(civitasLocation.new Teleport(
            "Quetzal_whistle",
            Location.TeleportCategory.ITEM,
            "Teleport to the Hunter's Guild with the quetzal whistle, and run north.",
            ItemID.HG_QUETZALWHISTLE_BASIC,
            "null",
            0,
            0,
            6192,
            civitasHerbPatchPoint,
            Collections.singletonList(new ItemRequirement(
                ItemID.HG_QUETZALWHISTLE_BASIC,
                1
            ))
        ));

        civitasLocation.addTeleportOption(civitasLocation.new Teleport(
            "Hunter_Skillcape",
            Location.TeleportCategory.ITEM,
            "Teleport to Civitas illa Fortis with Hunter skillcape.",
            ItemID.SKILLCAPE_HUNTING,
            "null",
            0,
            0,
            6192,
            civitasHerbPatchPoint,
            Collections.singletonList(new ItemRequirement(
                ItemID.SKILLCAPE_HUNTING,
                1
            ))
        ));

        locations.add(civitasLocation);
    }

    private void setupArdougneLocation()
    {
        WorldPoint ardougneHerbPatchPoint = new WorldPoint(
            2670,
            3374,
            0
        );

        ardougneLocation = new Location(
            EasyFarmingConfig::enumOptionEnumArdougneTeleport,
            config,
            "Ardougne",
            true
        );

        ardougneLocation.addTeleportOption(ardougneLocation.new Teleport(
            "Portal_Nexus",
            Location.TeleportCategory.PORTAL_NEXUS,
            "Teleport to Ardougne with Portal Nexus, and run north.",
            0,
            "null",
            17,
            13,
            10547,
            ardougneHerbPatchPoint,
            getHouseTeleportItemRequirements()
        ));

        ardougneLocation.addTeleportOption(ardougneLocation.new Teleport(
            "Ardougne_teleport",
            Location.TeleportCategory.SPELLBOOK,
            "Teleport to Ardougne with standard spellbook, and run north.",
            0,
            "null",
            218,
            41,
            10547,
            ardougneHerbPatchPoint,
            Arrays.asList(
                new ItemRequirement(
                    ItemID.LAWRUNE,
                    2
                ),
                new ItemRequirement(
                    ItemID.WATERRUNE,
                    2
                )
            )
        ));

        ardougneLocation.addTeleportOption(ardougneLocation.new Teleport(
            "Ardougne_Tele_Tab",
            Location.TeleportCategory.ITEM,
            "Teleport to Ardougne with Ardougne tele tab, and run north.",
            ItemID.POH_TABLET_ARDOUGNETELEPORT,
            "null",
            0,
            0,
            10547,
            ardougneHerbPatchPoint,
            Collections.singletonList(new ItemRequirement(
                ItemID.POH_TABLET_ARDOUGNETELEPORT,
                1
            ))
        ));

        ardougneLocation.addTeleportOption(ardougneLocation.new Teleport(
            "Ardy_cloak",
            Location.TeleportCategory.ITEM,
            "Teleport to Ardougne Farm with Ardougne cloak.",
            ItemID.ARDY_CAPE_MEDIUM,
            "Farm Teleport",
            0,
            0,
            10548,
            ardougneHerbPatchPoint,
            Collections.singletonList(new ItemRequirement(
                ItemID.ARDY_CAPE_MEDIUM,
                1
            ))
        ));

        ardougneLocation.addTeleportOption(ardougneLocation.new Teleport(
            "Skills_Necklace",
            Location.TeleportCategory.ITEM,
            "Teleport to Fishing guild with Skills necklace, and run east.",
            ItemID.JEWL_NECKLACE_OF_SKILLS_1,
            "null",
            0,
            0,
            10292,
            ardougneHerbPatchPoint,
            Collections.singletonList(new ItemRequirement(
                ItemID.JEWL_NECKLACE_OF_SKILLS_1,
                1
            ))
        ));

        locations.add(ardougneLocation);
    }

    private void setupCatherbyLocation()
    {
        WorldPoint catherbyHerbPatchPoint = new WorldPoint(
            2813,
            3463,
            0
        );

        catherbyLocation = new Location(
            EasyFarmingConfig::enumOptionEnumCatherbyTeleport,
            config,
            "Catherby",
            true
        );

        catherbyLocation.addTeleportOption(catherbyLocation.new Teleport(
            "Portal_Nexus_Catherby",
            Location.TeleportCategory.PORTAL_NEXUS,
            "Teleport to Catherby with Portal Nexus.",
            0,
            "null",
            17,
            13,
            11061,
            catherbyHerbPatchPoint,
            getHouseTeleportItemRequirements()
        ));

        catherbyLocation.addTeleportOption(catherbyLocation.new Teleport(
            "Portal_Nexus_Camelot",
            Location.TeleportCategory.PORTAL_NEXUS,
            "Teleport to Camelot with Portal Nexus.",
            0,
            "null",
            17,
            13,
            11062,
            catherbyHerbPatchPoint,
            getHouseTeleportItemRequirements()
        ));

        catherbyLocation.addTeleportOption(catherbyLocation.new Teleport(
            "Camelot_Teleport",
            Location.TeleportCategory.SPELLBOOK,
            "Teleport to Camelot using the standard spellbook, and run east to Catherby herb patch.",
            0,
            "null",
            218,
            34,
            11062,
            catherbyHerbPatchPoint,
            Arrays.asList(
                new ItemRequirement(
                    ItemID.AIRRUNE,
                    5
                ),
                new ItemRequirement(
                    ItemID.LAWRUNE,
                    1
                )
            )
        ));

        catherbyLocation.addTeleportOption(catherbyLocation.new Teleport(
            "Camelot_Tele_Tab",
            Location.TeleportCategory.ITEM,
            "Teleport to Camelot using a Camelot tele tab, and run east to Catherby herb patch.",
            ItemID.POH_TABLET_CAMELOTTELEPORT,
            "null",
            0,
            0,
            11062,
            catherbyHerbPatchPoint,
            Collections.singletonList(new ItemRequirement(
                ItemID.POH_TABLET_CAMELOTTELEPORT,
                1
            ))
        ));

        catherbyLocation.addTeleportOption(catherbyLocation.new Teleport(
            "Catherby_Tele_Tab",
            Location.TeleportCategory.ITEM,
            "Teleport to Catherby using Catherby teleport tab.",
            ItemID.LUNAR_TABLET_CATHERBY_TELEPORT,
            "null",
            0,
            0,
            11061,
            catherbyHerbPatchPoint,
            Collections.singletonList(new ItemRequirement(
                ItemID.LUNAR_TABLET_CATHERBY_TELEPORT,
                1
            ))
        ));

        locations.add(catherbyLocation);
    }

    private void setupFaladorLocation()
    {
        WorldPoint faladorHerbPatchPoint = new WorldPoint(
            3058,
            3307,
            0
        );

        faladorLocation = new Location(
            EasyFarmingConfig::enumOptionEnumFaladorTeleport,
            config,
            "Falador",
            true
        );

        faladorLocation.addTeleportOption(faladorLocation.new Teleport(
            "Portal_Nexus",
            Location.TeleportCategory.PORTAL_NEXUS,
            "Teleport to Falador with Portal Nexus, and run south-east.",
            0,
            "null",
            17,
            13,
            11828,
            faladorHerbPatchPoint,
            getHouseTeleportItemRequirements()
        ));

        faladorLocation.addTeleportOption(faladorLocation.new Teleport(
            "Explorers_ring",
            Location.TeleportCategory.ITEM,
            "Teleport to Falador with Explorers ring, and run slightly north.",
            ItemID.LUMBRIDGE_RING_MEDIUM,
            "Teleport",
            0,
            0,
            12083,
            faladorHerbPatchPoint,
            Collections.singletonList(new ItemRequirement(
                ItemID.LUMBRIDGE_RING_MEDIUM,
                1
            ))
        ));

        faladorLocation.addTeleportOption(faladorLocation.new Teleport(
            "Falador_Teleport",
            Location.TeleportCategory.SPELLBOOK,
            "Teleport to Falador with standard spellbook, and run south-east.",
            0,
            "null",
            218,
            29,
            11828,
            faladorHerbPatchPoint,
            Arrays.asList(
                new ItemRequirement(
                    ItemID.AIRRUNE,
                    3
                ),
                new ItemRequirement(
                    ItemID.LAWRUNE,
                    1
                ),
                new ItemRequirement(
                    ItemID.WATERRUNE,
                    1
                )
            )
        ));

        faladorLocation.addTeleportOption(faladorLocation.new Teleport(
            "Falador_Tele_Tab",
            Location.TeleportCategory.ITEM,
            "Teleport to Falador with Falador Tele Tab, and run south-east.",
            ItemID.POH_TABLET_FALADORTELEPORT,
            "null",
            0,
            0,
            11828,
            faladorHerbPatchPoint,
            Collections.singletonList(new ItemRequirement(
                ItemID.POH_TABLET_FALADORTELEPORT,
                1
            ))
        ));

        faladorLocation.addTeleportOption(faladorLocation.new Teleport(
            "Draynor_Tele_Tab",
            Location.TeleportCategory.ITEM,
            "Teleport to Draynor Manor with Draynor Manor Tele Tab, and run south-west.",
            ItemID.TELETAB_DRAYNOR,
            "null",
            0,
            0,
            12340,
            faladorHerbPatchPoint,
            Collections.singletonList(new ItemRequirement(
                ItemID.TELETAB_DRAYNOR,
                1
            ))
        ));

        locations.add(faladorLocation);
    }

    private void setupFarmingGuildLocation()
    {
        WorldPoint farmingGuildHerbPatchPoint = new WorldPoint(
            1238,
            3726,
            0
        );

        farmingGuildLocation = new Location(
            EasyFarmingConfig::enumOptionEnumFarmingGuildTeleport,
            config,
            "Farming Guild",
            true
        );

        farmingGuildLocation.addTeleportOption(farmingGuildLocation.new Teleport(
            "Jewellery_box",
            Location.TeleportCategory.JEWELLERY_BOX,
            "Teleport to Farming guild with Jewellery box.",
            29155,
            "null",
            0,
            0,
            4922,
            farmingGuildHerbPatchPoint,
            getHouseTeleportItemRequirements()
        ));

        farmingGuildLocation.addTeleportOption(farmingGuildLocation.new Teleport(
            "Skills_Necklace",
            Location.TeleportCategory.ITEM,
            "Teleport to Farming guild using Skills necklace.",
            ItemID.JEWL_NECKLACE_OF_SKILLS_1,
            "null",
            0,
            0,
            4922,
            farmingGuildHerbPatchPoint,
            Collections.singletonList(new ItemRequirement(
                ItemID.JEWL_NECKLACE_OF_SKILLS_1,
                1
            ))
        ));

        locations.add(farmingGuildLocation);
    }

    private void setupHarmonyLocation()
    {
        WorldPoint harmonyHerbPatchPoint = new WorldPoint(
            3789,
            2837,
            0
        );

        harmonyLocation = new Location(
            EasyFarmingConfig::enumOptionEnumHarmonyTeleport,
            config,
            "Harmony Island",
            false
        );

        harmonyLocation.addTeleportOption(harmonyLocation.new Teleport(
            "Portal_Nexus",
            Location.TeleportCategory.PORTAL_NEXUS,
            "Teleport to Harmony with Portal Nexus.",
            0,
            "null",
            17,
            13,
            15148,
            harmonyHerbPatchPoint,
            getHouseTeleportItemRequirements()
        ));

        harmonyLocation.addTeleportOption(harmonyLocation.new Teleport(
            "Harmony_Tele_Tab",
            Location.TeleportCategory.ITEM,
            "Teleport to Harmony with Harmony Tele Tab.",
            ItemID.TELETAB_HARMONY,
            "null",
            0,
            0,
            15148,
            harmonyHerbPatchPoint,
            Collections.singletonList(new ItemRequirement(
                ItemID.TELETAB_HARMONY,
                1
            ))
        ));

        locations.add(harmonyLocation);
    }

    private void setupKourendLocation()
    {
        WorldPoint kourendHerbPatchPoint = new WorldPoint(
            1738,
            3550,
            0
        );

        kourendLocation = new Location(
            EasyFarmingConfig::enumOptionEnumKourendTeleport,
            config,
            "Kourend",
            true
        );

        kourendLocation.addTeleportOption(kourendLocation.new Teleport(
            "Xerics_Talisman",
            Location.TeleportCategory.ITEM,
            "Teleport to Kourend with Xeric's Talisman.",
            ItemID.XERIC_TALISMAN,
            "Rub",
            187,
            3,
            6967,
            kourendHerbPatchPoint,
            Collections.singletonList(new ItemRequirement(
                ItemID.XERIC_TALISMAN,
                1
            ))
        ));

        kourendLocation.addTeleportOption(kourendLocation.new Teleport(
            "Mounted_Xerics",
            Location.TeleportCategory.MOUNTED_XERICS,
            "Teleport to Kourend with Xeric's Talisman in PoH.",
            0,
            "null",
            187,
            3,
            6967,
            kourendHerbPatchPoint,
            getHouseTeleportItemRequirements()
        ));

        locations.add(kourendLocation);
    }

    private void setupMorytaniaLocation()
    {
        WorldPoint morytaniaHerbPatchPoint = new WorldPoint(
            3601,
            3525,
            0
        );

        morytaniaLocation = new Location(
            EasyFarmingConfig::enumOptionEnumMorytaniaTeleport,
            config,
            "Morytania",
            true
        );

        morytaniaLocation.addTeleportOption(morytaniaLocation.new Teleport(
            "Ectophial",
            Location.TeleportCategory.ITEM,
            "Teleport to Morytania with Ectophial and run West to the patch.",
            ItemID.ECTOPHIAL,
            "null",
            0,
            0,
            14647,
            morytaniaHerbPatchPoint,
            Collections.singletonList(new ItemRequirement(
                ItemID.ECTOPHIAL,
                1
            ))
        ));

        locations.add(morytaniaLocation);
    }

    private void setupTrollStrongholdLocation()
    {
        WorldPoint trollStrongholdHerbPatchPoint = new WorldPoint(
            2824,
            3696,
            0
        );

        trollStrongholdLocation = new Location(
            EasyFarmingConfig::enumOptionEnumTrollStrongholdTeleport,
            config,
            "Troll Stronghold",
            false
        );

        trollStrongholdLocation.addTeleportOption(trollStrongholdLocation.new Teleport(
            "Stony_Basalt",
            Location.TeleportCategory.ITEM,
            "Teleport to Troll Stronghold with Stony Basalt.",
            ItemID.STRONGHOLD_TELEPORT_BASALT,
            "null",
            0,
            0,
            11321,
            trollStrongholdHerbPatchPoint,
            Collections.singletonList(new ItemRequirement(
                ItemID.STRONGHOLD_TELEPORT_BASALT,
                1
            ))
        ));

        trollStrongholdLocation.addTeleportOption(trollStrongholdLocation.new Teleport(
            "Portal_Nexus",
            Location.TeleportCategory.PORTAL_NEXUS,
            "Teleport to Troll Stronghold with Portal Nexus.",
            0,
            "null",
            17,
            13,
            11321,
            trollStrongholdHerbPatchPoint,
            getHouseTeleportItemRequirements()
        ));

        locations.add(trollStrongholdLocation);
    }

    private void setupWeissLocation()
    {
        WorldPoint weissHerbPatchPoint = new WorldPoint(
            2847,
            3931,
            0
        );

        weissLocation = new Location(
            EasyFarmingConfig::enumOptionEnumWeissTeleport,
            config,
            "Weiss",
            false
        );

        weissLocation.addTeleportOption(weissLocation.new Teleport(
            "Icy_Basalt",
            Location.TeleportCategory.ITEM,
            "Teleport to Weiss with Icy Basalt.",
            ItemID.WEISS_TELEPORT_BASALT,
            "null",
            0,
            0,
            11325,
            weissHerbPatchPoint,
            Collections.singletonList(new ItemRequirement(
                ItemID.WEISS_TELEPORT_BASALT,
                1
            ))
        ));

        weissLocation.addTeleportOption(weissLocation.new Teleport(
            "Portal_Nexus",
            Location.TeleportCategory.PORTAL_NEXUS,
            "Teleport to Weiss with Portal Nexus.",
            0,
            "null",
            17,
            13,
            11325,
            weissHerbPatchPoint,
            getHouseTeleportItemRequirements()
        ));

        locations.add(weissLocation);
    }


}
package com.easyfarming.ItemsAndLocations;

import com.easyfarming.EasyFarmingConfig;
import com.easyfarming.EasyFarmingPlugin;
import com.easyfarming.ItemRequirement;
import com.easyfarming.Location;
import net.runelite.api.Client;
import net.runelite.api.gameval.ItemID;

import java.util.ArrayList;
import java.util.List;

public class ItemAndLocation
{
    protected EasyFarmingConfig config;

    protected Client client;

    protected EasyFarmingPlugin plugin;

    public List<Location> locations = new ArrayList<>();

    public ItemAndLocation()
    {
    }

    public ItemAndLocation(EasyFarmingConfig config, Client client, EasyFarmingPlugin plugin)
    {
        this.config = config;
        this.client = client;
        this.plugin = plugin;
    }

    public List<ItemRequirement> getHouseTeleportItemRequirements()
    {
        EasyFarmingConfig.OptionEnumHouseTele selectedOption = config.enumConfigHouseTele();

        List<ItemRequirement> itemRequirements = new ArrayList<>();

        switch (selectedOption) {
            case Law_air_earth_runes:
                itemRequirements.add(new ItemRequirement(
                    ItemID.AIRRUNE,
                    1
                ));

                itemRequirements.add(new ItemRequirement(
                    ItemID.EARTHRUNE,
                    1
                ));

                itemRequirements.add(new ItemRequirement(
                    ItemID.LAWRUNE,
                    1
                ));

                break;

            case Teleport_To_House:
                itemRequirements.add(new ItemRequirement(
                    ItemID.POH_TABLET_TELEPORTTOHOUSE,
                    1
                ));

                break;

            case Construction_cape:
                itemRequirements.add(new ItemRequirement(
                    ItemID.SKILLCAPE_CONSTRUCTION,
                    1
                ));

                break;

            case Construction_cape_t:
                itemRequirements.add(new ItemRequirement(
                    ItemID.SKILLCAPE_CONSTRUCTION_TRIMMED,
                    1
                ));

                break;
            case Max_cape:
                itemRequirements.add(new ItemRequirement(
                    ItemID.SKILLCAPE_MAX,
                    1
                ));

                break;

            default:
                throw new IllegalStateException("Unexpected value: " + selectedOption);
        }

        return itemRequirements;
    }

    public Integer selectedCompostID()
    {
        EasyFarmingConfig.OptionEnumCompost selectedCompost = config.enumConfigCompost();

        switch (selectedCompost) {
            case Compost:
                return ItemID.BUCKET_COMPOST;

            case Supercompost:
                return ItemID.BUCKET_SUPERCOMPOST;

            case Ultracompost:
                return ItemID.BUCKET_ULTRACOMPOST;

            case Bottomless:
                return ItemID.BOTTOMLESS_COMPOST_BUCKET;
            default:
                return 0;
        }
    }    public void setupLocations()
    {
        locations.clear();
    }
}

package com.easyfarming.ItemsAndLocations;

import com.easyfarming.EasyFarmingConfig;
import com.easyfarming.EasyFarmingPlugin;
import com.easyfarming.ItemRequirement;
import com.easyfarming.Location;
import net.runelite.api.Client;
import net.runelite.api.gameval.ItemID;
import net.runelite.api.coords.WorldPoint;

import java.util.*;

public class TreeRunItemAndLocation extends ItemAndLocation
{
    public Location faladorTreeLocation;
    public Location farmingGuildTreeLocation;
    public Location gnomeStrongholdTreeLocation;
    public Location lumbridgeTreeLocation;
    public Location taverleyTreeLocation;
    public Location varrockTreeLocation;

    public TreeRunItemAndLocation()
    {
    }

    public TreeRunItemAndLocation(EasyFarmingConfig config, Client client, EasyFarmingPlugin plugin)
    {
        super(
            config,
            client,
            plugin
        );
    }

    public Map<Integer, Integer> getTreeItems()
    {
        return getAllItemRequirements(locations);
    }

    public Map<Integer, Integer> getAllItemRequirements(List<Location> locations)
    {
        Map<Integer, Integer> allRequirements = new HashMap<>();

        setupLocations();

        // Add other items and merge them with allRequirements
        for (Location location : locations) {
            if (plugin.getTreeLocationEnabled(location.getName())) {
                //ItemID.GUAM_SEED is default for herb seeds, code later will allow for any seed to be used, just needed a placeholder ID
                //allRequirements.merge(ItemID.GUAM_SEED, 1, Integer::sum);
                allRequirements.merge(
                    ItemID.PLANTPOT_OAK_SAPLING,
                    1,
                    Integer::sum
                );

                allRequirements.merge(
                    ItemID.COINS,
                    200,
                    Integer::sum
                );

                if (selectedCompostID() != -1 && selectedCompostID() != ItemID.BOTTOMLESS_COMPOST_BUCKET) {
                    allRequirements.merge(
                        selectedCompostID(),
                        1,
                        Integer::sum
                    );
                }

                Location.Teleport teleport = location.getSelectedTeleport();

                Map<Integer, Integer> locationRequirements = teleport.getItemRequirements();

                for (Map.Entry<Integer, Integer> entry : locationRequirements.entrySet()) {
                    int itemId = entry.getKey();
                    int quantity = entry.getValue();

                    if (itemId == ItemID.SKILLCAPE_CONSTRUCTION || itemId == ItemID.SKILLCAPE_CONSTRUCTION_TRIMMED || itemId == ItemID.SKILLCAPE_MAX) {
                        allRequirements.merge(
                            itemId,
                            quantity,
                            (oldValue, newValue) -> Math.min(
                                1,
                                oldValue + newValue
                            )
                        );
                    } else {
                        allRequirements.merge(
                            itemId,
                            quantity,
                            Integer::sum
                        );
                    }
                }
            }
        }

        //allRequirements.merge(ItemID.SEED_DIBBER, 1, Integer::sum);
        allRequirements.merge(
            ItemID.SPADE,
            1,
            Integer::sum
        );

        // Only add bottomless compost bucket if it's selected in config
        if (selectedCompostID() == ItemID.BOTTOMLESS_COMPOST_BUCKET) {
            allRequirements.merge(
                ItemID.BOTTOMLESS_COMPOST_BUCKET,
                1,
                Integer::sum
            );
        }

        allRequirements.merge(
            ItemID.FAIRY_ENCHANTED_SECATEURS,
            1,
            Integer::sum
        );

        if (config.generalRake()) {
            allRequirements.merge(
                ItemID.RAKE,
                1,
                Integer::sum
            );
        }

        return allRequirements;
    }

    public void setupLocations()
    {
        super.setupLocations();

        setupFaladorLocation();
        setupFarmingGuildLocation();
        setupGnomeStrongholdLocation();
        setupLumbridgeLocation();
        setupTaverleyLocation();
        setupVarrockLocation();
    }

    private void setupFaladorLocation()
    {
        WorldPoint faladorTreePatchPoint = new WorldPoint(
            3000,
            3373,
            0
        );

        faladorTreeLocation = new Location(
            EasyFarmingConfig::enumTreeFaladorTeleport,
            config,
            "Falador",
            false
        );

        faladorTreeLocation.addTeleportOption(faladorTreeLocation.new Teleport(
            "Portal_Nexus",
            Location.TeleportCategory.PORTAL_NEXUS,
            "Teleport to Falador with Portal Nexus.",
            0,
            "null",
            17,
            13,
            11828,
            faladorTreePatchPoint,
            getHouseTeleportItemRequirements()
        ));

        faladorTreeLocation.addTeleportOption(faladorTreeLocation.new Teleport(
            "Teleport",
            Location.TeleportCategory.SPELLBOOK,
            "Teleport to Falador with Spellbook and run to Falador park.",
            0,
            "null",
            218,
            29,
            11828,
            faladorTreePatchPoint,
            Arrays.asList(
                new ItemRequirement(
                    ItemID.AIRRUNE,
                    3
                ),
                new ItemRequirement(
                    ItemID.LAWRUNE,
                    1
                ),
                new ItemRequirement(
                    ItemID.WATERRUNE,
                    1
                )
            )
        ));

        faladorTreeLocation.addTeleportOption(faladorTreeLocation.new Teleport(
            "Falador_Tele_Tab",
            Location.TeleportCategory.ITEM,
            "Teleport to Falador with Falador Tele Tab and run to Falador park.",
            ItemID.POH_TABLET_FALADORTELEPORT,
            "null",
            0,
            0,
            11828,
            faladorTreePatchPoint,
            Collections.singletonList(new ItemRequirement(
                ItemID.POH_TABLET_FALADORTELEPORT,
                1
            ))
        ));

        locations.add(faladorTreeLocation);
    }

    private void setupFarmingGuildLocation()
    {
        WorldPoint farmingGuildTreePatchPoint = new WorldPoint(
            1232,
            3736,
            0
        );

        farmingGuildTreeLocation = new Location(
            EasyFarmingConfig::enumTreeFarmingGuildTeleport,
            config,
            "Farming Guild",
            false
        );

        farmingGuildTreeLocation.addTeleportOption(farmingGuildTreeLocation.new Teleport(
            "Jewellery_box",
            Location.TeleportCategory.JEWELLERY_BOX,
            "Teleport to Farming Guild with Jewellery box.",
            0,
            "null",
            0,
            0,
            4922,
            farmingGuildTreePatchPoint,
            getHouseTeleportItemRequirements()
        ));

        farmingGuildTreeLocation.addTeleportOption(farmingGuildTreeLocation.new Teleport(
            "Skills_Necklace",
            Location.TeleportCategory.ITEM,
            "Teleport to Farming guild using Skills necklace.",
            ItemID.JEWL_NECKLACE_OF_SKILLS_1,
            "null",
            0,
            0,
            4922,
            farmingGuildTreePatchPoint,
            Collections.singletonList(new ItemRequirement(
                ItemID.JEWL_NECKLACE_OF_SKILLS_1,
                1
            ))
        ));

        locations.add(farmingGuildTreeLocation);
    }

    private void setupGnomeStrongholdLocation()
    {
        WorldPoint gnomeStrongholdTreePatchPoint = new WorldPoint(
            2436,
            3415,
            0
        );

        gnomeStrongholdTreeLocation = new Location(
            EasyFarmingConfig::enumTreeGnomeStrongoldTeleport,
            config,
            "Gnome Stronghold",
            false
        );

        gnomeStrongholdTreeLocation.addTeleportOption(gnomeStrongholdTreeLocation.new Teleport(
            "Royal_seed_pod",
            Location.TeleportCategory.ITEM,
            "Teleport to Gnome Stronghold with Royal seed pod.",
            ItemID.MM2_ROYAL_SEED_POD,
            "null",
            0,
            0,
            9782,
            gnomeStrongholdTreePatchPoint,
            Collections.singletonList(new ItemRequirement(
                ItemID.MM2_ROYAL_SEED_POD,
                1
            ))
        ));

        gnomeStrongholdTreeLocation.addTeleportOption(gnomeStrongholdTreeLocation.new Teleport(
            "Spirit_Tree",
            Location.TeleportCategory.SPIRIT_TREE,
            "Teleport to Gnome Stronghold via a Spirit Tree.",
            0,
            "null",
            187,
            3,
            9781,
            gnomeStrongholdTreePatchPoint,
            Collections.<ItemRequirement> emptyList()
        ));

        locations.add(gnomeStrongholdTreeLocation);
    }

    private void setupLumbridgeLocation()
    {
        WorldPoint lumbridgeTreePatchPoint = new WorldPoint(
            3193,
            3231,
            0
        );

        lumbridgeTreeLocation = new Location(
            EasyFarmingConfig::enumTreeLumbridgeTeleport,
            config,
            "Lumbridge",
            false
        );

        lumbridgeTreeLocation.addTeleportOption(lumbridgeTreeLocation.new Teleport(
            "Portal_Nexus",
            Location.TeleportCategory.PORTAL_NEXUS,
            "Teleport to Lumbridge with Portal Nexus.",
            0,
            "null",
            17,
            13,
            12850,
            lumbridgeTreePatchPoint,
            getHouseTeleportItemRequirements()
        ));

        lumbridgeTreeLocation.addTeleportOption(lumbridgeTreeLocation.new Teleport(
            "Teleport",
            Location.TeleportCategory.SPELLBOOK,
            "Teleport to Lumbridge with spellbook.",
            0,
            "null",
            218,
            26,
            12850,
            lumbridgeTreePatchPoint,
            Arrays.asList(
                new ItemRequirement(
                    ItemID.AIRRUNE,
                    3
                ),
                new ItemRequirement(
                    ItemID.LAWRUNE,
                    1
                ),
                new ItemRequirement(
                    ItemID.EARTHRUNE,
                    1
                )
            )
        ));

        lumbridgeTreeLocation.addTeleportOption(lumbridgeTreeLocation.new Teleport(
            "Lumbridge_Tele_Tab",
            Location.TeleportCategory.ITEM,
            "Teleport to Lumbridge with Lumbridge Tele Tab.",
            ItemID.POH_TABLET_LUMBRIDGETELEPORT,
            "null",
            0,
            0,
            12850,
            lumbridgeTreePatchPoint,
            Collections.singletonList(new ItemRequirement(
                ItemID.POH_TABLET_LUMBRIDGETELEPORT,
                1
            ))
        ));

        locations.add(lumbridgeTreeLocation);
    }

    private void setupTaverleyLocation()
    {
        WorldPoint taverlyPatchPoint = new WorldPoint(
            2936,
            3438,
            0
        );

        taverleyTreeLocation = new Location(
            EasyFarmingConfig::enumTreeTaverleyTeleport,
            config,
            "Taverley",
            false
        );

        taverleyTreeLocation.addTeleportOption(taverleyTreeLocation.new Teleport(
            "Portal_Nexus",
            Location.TeleportCategory.PORTAL_NEXUS,
            "Teleport to Falador with Portal Nexus and run to Taverly.",
            0,
            "null",
            17,
            13,
            11828,
            taverlyPatchPoint,
            getHouseTeleportItemRequirements()
        ));

        taverleyTreeLocation.addTeleportOption(taverleyTreeLocation.new Teleport(
            "Teleport",
            Location.TeleportCategory.SPELLBOOK,
            "Teleport to Falador with spellbook and run to Taverly.",
            0,
            "null",
            218,
            29,
            11828,
            taverlyPatchPoint,
            Arrays.asList(
                new ItemRequirement(
                    ItemID.AIRRUNE,
                    3
                ),
                new ItemRequirement(
                    ItemID.LAWRUNE,
                    1
                ),
                new ItemRequirement(
                    ItemID.WATERRUNE,
                    1
                )
            )
        ));

        taverleyTreeLocation.addTeleportOption(taverleyTreeLocation.new Teleport(
            "Falador_Tele_Tab",
            Location.TeleportCategory.ITEM,
            "Teleport to Falador with Falador Tele Tab and run to Taverly.",
            ItemID.POH_TABLET_FALADORTELEPORT,
            "null",
            0,
            0,
            11828,
            taverlyPatchPoint,
            Collections.singletonList(new ItemRequirement(
                ItemID.POH_TABLET_FALADORTELEPORT,
                1
            ))
        ));

        locations.add(taverleyTreeLocation);
    }

    private void setupVarrockLocation()
    {
        WorldPoint varrockTreePatchPoint = new WorldPoint(
            3229,
            3459,
            0
        );

        varrockTreeLocation = new Location(
            EasyFarmingConfig::enumTreeVarrockTeleport,
            config,
            "Varrock",
            false
        );

        varrockTreeLocation.addTeleportOption(varrockTreeLocation.new Teleport(
            "Portal_Nexus",
            Location.TeleportCategory.PORTAL_NEXUS,
            "Teleport to Varrock with Portal Nexus.",
            0,
            "null",
            17,
            13,
            12853,
            varrockTreePatchPoint,
            getHouseTeleportItemRequirements()
        ));

        varrockTreeLocation.addTeleportOption(varrockTreeLocation.new Teleport(
            "Teleport",
            Location.TeleportCategory.SPELLBOOK,
            "Teleport to Varrock with spellbook.",
            0,
            "null",
            218,
            23,
            12853,
            varrockTreePatchPoint,
            Arrays.asList(
                new ItemRequirement(
                    ItemID.AIRRUNE,
                    3
                ),
                new ItemRequirement(
                    ItemID.LAWRUNE,
                    1
                ),
                new ItemRequirement(
                    ItemID.FIRERUNE,
                    1
                )
            )
        ));

        varrockTreeLocation.addTeleportOption(varrockTreeLocation.new Teleport(
            "Varrock_Tele_Tab",
            Location.TeleportCategory.ITEM,
            "Teleport to Varrock with Varrock Tele Tab.",
            ItemID.POH_TABLET_VARROCKTELEPORT,
            "null",
            0,
            0,
            12853,
            varrockTreePatchPoint,
            Collections.singletonList(new ItemRequirement(
                ItemID.POH_TABLET_VARROCKTELEPORT,
                1
            ))
        ));

        locations.add(varrockTreeLocation);
    }
}
package com.easyfarming;

import com.easyfarming.ItemsAndLocations.HerbRunItemAndLocation;
import com.easyfarming.ItemsAndLocations.TreeRunItemAndLocation;
import com.easyfarming.ItemsAndLocations.FruitTreeRunItemAndLocation;

import com.google.inject.Provides;
import java.awt.image.BufferedImage;
import javax.inject.Inject;

import lombok.Getter;
import lombok.Setter;
import net.runelite.api.*;
import net.runelite.api.events.ChatMessage;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.game.ItemManager;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.plugins.PluginDescriptor;
import net.runelite.client.ui.NavigationButton;
import net.runelite.client.util.ImageUtil;
import net.runelite.client.ui.ClientToolbar;
import net.runelite.client.ui.overlay.OverlayManager;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.eventbus.EventBus;

@PluginDescriptor(
		name = "Easy Farming",
		description = "Show item requirements and highlights for farming runs."
)

public class EasyFarmingPlugin extends Plugin
{
	private HerbRunItemAndLocation herbRunItemAndLocation;
	private TreeRunItemAndLocation treeRunItemAndLocation;
	private FruitTreeRunItemAndLocation fruitTreeRunItemAndLocation;


	@Inject
	private ItemManager itemManager;
	@Getter
    @Inject
	private Client client;

	public void runOnClientThread(Runnable task) {
		clientThread.invokeLater(task);
	}

	public Location getArdougneLocation() {
		return herbRunItemAndLocation.ardougneLocation;
	}
	public Location getCatherbyLocation() {
		return herbRunItemAndLocation.catherbyLocation;
	}
	public Location getFaladorLocation() {
		return herbRunItemAndLocation.faladorLocation;
	}
	public Location getFarmingGuildLocation() {return herbRunItemAndLocation.farmingGuildLocation;}
	public Location getHarmonyLocation() {
		return herbRunItemAndLocation.harmonyLocation;
	}
	public Location getKourendLocation() {
		return herbRunItemAndLocation.kourendLocation;
	}
	public Location getMorytaniaLocation() {
		return herbRunItemAndLocation.morytaniaLocation;
	}
	public Location getTrollStrongholdLocation() {
		return herbRunItemAndLocation.trollStrongholdLocation;
	}

	public Location getWeissLocation() {
		return herbRunItemAndLocation.weissLocation;
	}

	public Location getCivitasLocation() {
		return herbRunItemAndLocation.civitasLocation;
	}

	//get Tree locations
	public Location getFaladorTreeLocation() {return treeRunItemAndLocation.faladorTreeLocation;}
	public Location getFarmingGuildTreeLocation() {
		return treeRunItemAndLocation.farmingGuildTreeLocation;
	}
	public Location getGnomeStrongholdTreeLocation() {return treeRunItemAndLocation.gnomeStrongholdTreeLocation;}
	public Location getLumbridgeTreeLocation() {return treeRunItemAndLocation.lumbridgeTreeLocation;}
	public Location getTaverleyTreeLocation() {
		return treeRunItemAndLocation.taverleyTreeLocation;
	}
	public Location getVarrockTreeLocation() {
		return treeRunItemAndLocation.varrockTreeLocation;
	}

	//get fruit tree locations
	public Location getBrimhavenFruitTreeLocation() {return fruitTreeRunItemAndLocation.brimhavenFruitTreeLocation;}
	public Location getCatherbyFruitTreeLocation() {return fruitTreeRunItemAndLocation.catherbyFruitTreeLocation;}
	public Location getFarmingGuildFruitTreeLocation() {return fruitTreeRunItemAndLocation.farmingGuildFruitTreeLocation;}
	public Location getGnomeStrongholdFruitTreeLocation() {return fruitTreeRunItemAndLocation.gnomeStrongholdFruitTreeLocation;}
	public Location getLletyaFruitTreeLocation() {return fruitTreeRunItemAndLocation.lletyaFruitTreeLocation;}
	public Location getTreeGnomeVillageTreeLocation() {return fruitTreeRunItemAndLocation.treeGnomeVillageFruitTreeLocation;}

	@Getter
    @Setter
    private boolean isTeleportOverlayActive = false;

    @Inject
	private EasyFarmingOverlayInfoBox farmingHelperOverlayInfoBox;
	public EasyFarmingOverlayInfoBox getEasyFarmingOverlayInfoBox()
	{
		return farmingHelperOverlayInfoBox;
	}

	@Getter
    private String lastMessage = "";
    @Subscribe
    public void onChatMessage(ChatMessage event) {
        if (event.getType() == ChatMessageType.GAMEMESSAGE) {
            lastMessage = event.getMessage();
        }
        else if (event.getType() == ChatMessageType.SPAM) {
            lastMessage = event.getMessage();
        }
    }

    public boolean checkMessage(String targetMessage, String lastMessage) {
		return lastMessage.trim().equalsIgnoreCase(targetMessage.trim());
	}

	@Inject
	private EventBus eventBus;

	@Inject
	private ClientThread clientThread;


	@Getter
    @Inject
	private FarmingTeleportOverlay farmingTeleportOverlay;

	private EasyFarmingPanel farmingHelperPanel;
	public EasyFarmingPanel panel;
	private NavigationButton navButton;

	@Inject
	private ClientToolbar clientToolbar;

	@Inject
	private EasyFarmingConfig config;
	@Inject
	public OverlayManager overlayManager;

	@Getter
    @Setter
    private boolean isOverlayActive = true;

	@Inject
	private EasyFarmingOverlay farmingHelperOverlay;

	public EasyFarmingOverlay getEasyFarmingOverlay()
	{
		return farmingHelperOverlay;
	}

	@Setter
    private boolean itemsCollected = false;
	public boolean areItemsCollected() {
		return itemsCollected;
	}

	@Provides
	EasyFarmingConfig getConfig(ConfigManager configManager)
	{
		return configManager.getConfig(EasyFarmingConfig.class);
	}
	
	@Provides
	com.easyfarming.overlays.utils.ColorProvider provideColorProvider(EasyFarmingConfig config)
	{
		return new com.easyfarming.overlays.utils.ColorProvider(config);
	}
	
	@Provides
	HerbRunItemAndLocation provideHerbRunItemAndLocation(EasyFarmingConfig config, Client client, EasyFarmingPlugin plugin)
	{
		return new HerbRunItemAndLocation(config, client, plugin);
	}
	
	@Provides
	TreeRunItemAndLocation provideTreeRunItemAndLocation(EasyFarmingConfig config, Client client, EasyFarmingPlugin plugin)
	{
		return new TreeRunItemAndLocation(config, client, plugin);
	}
	
	@Provides
	FruitTreeRunItemAndLocation provideFruitTreeRunItemAndLocation(EasyFarmingConfig config, Client client, EasyFarmingPlugin plugin)
	{
		return new FruitTreeRunItemAndLocation(config, client, plugin);
	}
	
	@Provides
	EasyFarmingOverlay provideEasyFarmingOverlay(Client client, EasyFarmingPlugin plugin, ItemManager itemManager,
	                                             HerbRunItemAndLocation herbRunItemAndLocation,
	                                             TreeRunItemAndLocation treeRunItemAndLocation,
	                                             FruitTreeRunItemAndLocation fruitTreeRunItemAndLocation)
	{
		return new EasyFarmingOverlay(client, plugin, itemManager, herbRunItemAndLocation, treeRunItemAndLocation, fruitTreeRunItemAndLocation);
	}

    public void addTextToInfoBox(String text) {
		farmingHelperOverlayInfoBox.setText(text);
	}
	public boolean getHerbLocationEnabled(String locationName) {
		switch (locationName) {
			case "Ardougne":
				return config.ardougneHerb();
			case "Catherby":
				return config.catherbyHerb();
			case "Falador":
				return config.faladorHerb();
			case "Farming Guild":
				return config.farmingGuildHerb();
			case "Harmony Island":
				return config.harmonyHerb();
			case "Kourend":
				return config.kourendHerb();
			case "Morytania":
				return config.morytaniaHerb();
			case "Troll Stronghold":
				return config.trollStrongholdHerb();
			case "Weiss":
				return config.weissHerb();
			case "Civitas illa Fortis":
				return config.civitasHerb();
			// Add cases for other locations as needed
			default:
				return false;
		}
	}

	public boolean getTreeLocationEnabled(String locationName) {
		switch (locationName) {
			case "Falador":
				return config.faladorTree();
			case "Farming Guild":
				return config.farmingGuildTree();
			case "Gnome Stronghold":
				return config.gnomeStrongholdTree();
			case "Lumbridge":
				return config.lumbridgeTree();
			case "Taverley":
				return config.taverleyTree();
			case "Varrock":
				return config.varrockTree();
			// Add cases for other locations as needed
			default:
				return false;
		}
	}

	public boolean getFruitTreeLocationEnabled(String locationName) {
		switch (locationName) {
			case "Brimhaven":
				return config.brimhavenFruitTree();
			case "Catherby":
				return config.catherbyFruitTree();
			case "Farming Guild":
				return config.farmingGuildFruitTree();
			case "Gnome Stronghold":
				return config.gnomeStrongholdFruitTree();
			case "Lletya":
				return config.lletyaFruitTree();
			case "Tree Gnome Village":
				return config.treeGnomeVillageFruitTree();
			// Add cases for other locations as needed
			default:
				return false;
		}
	}

	@Override
	protected void startUp()
	{
		herbRunItemAndLocation = new HerbRunItemAndLocation(config, client, this);
		treeRunItemAndLocation = new TreeRunItemAndLocation(config, client, this);
		fruitTreeRunItemAndLocation = new FruitTreeRunItemAndLocation(config, client, this);
		farmingHelperOverlay = new EasyFarmingOverlay(client, this, itemManager, herbRunItemAndLocation, treeRunItemAndLocation, fruitTreeRunItemAndLocation);

		panel = new EasyFarmingPanel(this, overlayManager, farmingTeleportOverlay, herbRunItemAndLocation, treeRunItemAndLocation, fruitTreeRunItemAndLocation);
		final BufferedImage icon = ImageUtil.loadImageResource(getClass(), "/icon.png");

		navButton = NavigationButton.builder()
				.tooltip("Easy Farming")
				.icon(icon)
				.priority(6)
				.panel(panel)
				.build();
		clientToolbar.addNavigation(navButton);

		overlayManager.add(farmingHelperOverlay);
		overlayManager.add(farmingTeleportOverlay);
		overlayManager.add(farmingHelperOverlayInfoBox);

		// set overlay to inactive
		isOverlayActive = false;
		eventBus.register(this);

		herbRunItemAndLocation.setupLocations();
	}

	@Override
	protected void shutDown()
	{
		if (navButton != null) {
			clientToolbar.removeNavigation(navButton);
		}

		overlayManager.remove(farmingHelperOverlay);
		overlayManager.remove(farmingTeleportOverlay);
		overlayManager.remove(farmingHelperOverlayInfoBox);

		eventBus.unregister(this);
	}
}
package com.easyfarming;

import net.runelite.api.Client;

import java.util.Arrays;
import java.util.List;

public class FlowerPatchChecker {
    // Add lists for each plant state
    private static final List<Integer> HARVESTABLE = Arrays.asList(32);
    private static final List<Integer> GROWING = Arrays.asList(28, 29, 30, 31);
    private static final List<Integer> DEAD = Arrays.asList(221,222,223,224);
    private static final List<Integer> WEEDS = Arrays.asList(0, 1, 2);


    public enum PlantState {
        HARVESTABLE,
        GROWING,
        DEAD,
        WEEDS,
        PLANT,
        UNKNOWN
    }

    public static PlantState checkFlowerPatch(Client client, int varbitIndex) {
        int varbitValue = client.getVarbitValue(varbitIndex);

        if (HARVESTABLE.contains(varbitValue)) {
            return PlantState.HARVESTABLE;
        } else if (GROWING.contains(varbitValue)) {
            return PlantState.GROWING;
        } else if (DEAD.contains(varbitValue)) {
            return PlantState.DEAD;
        } else if (WEEDS.contains(varbitValue)) {
            return PlantState.WEEDS;
        } else if (varbitValue == 3) {
            return PlantState.PLANT;
        } else {
            return PlantState.UNKNOWN;
        }
    }}
package com.easyfarming;

import javax.swing.*;
import java.awt.*;

public class StartStopJButton extends JButton {
    private String originalText;

    public StartStopJButton(String text) {
        super(text, null);

        this.originalText = text;
        this.setStartStopState(false);
    }

    public void setStartStopState(boolean started)
    {
        String startOrStop = started ? "Stop " : "Start ";

        this.setText(startOrStop.concat(this.originalText));
        this.setBackground(started ? Color.RED : Color.BLACK);
    }
}
package com.easyfarming.items;

import com.easyfarming.EasyFarmingConfig;
import com.easyfarming.EasyFarmingPlugin;
import com.easyfarming.core.ItemRequirement;
import com.easyfarming.core.Location;
import com.easyfarming.core.Teleport;
import net.runelite.api.gameval.ItemID;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

/**
 * NOTE: This class is part of an incomplete refactoring effort.
 * 
 * This class was designed to replace the current ItemsAndLocations.* package structure
 * and work with the new locations.* package classes, but the migration was never completed.
 * 
 * Currently unused - no instantiation found in the codebase.
 * 
 * SPARED FROM PURGING: This appears to be part of an unimplemented feature/refactoring
 * and may be completed in the future.
 */
public class ItemRequirementCalculator {
    
    private final EasyFarmingConfig config;
    private final EasyFarmingPlugin plugin;
    private final ItemAndLocationHelper itemHelper;
    
    public ItemRequirementCalculator(EasyFarmingConfig config, EasyFarmingPlugin plugin, ItemAndLocationHelper itemHelper) {
        this.config = config;
        this.plugin = plugin;
        this.itemHelper = itemHelper;
    }
    
    public Map<Integer, Integer> calculateItemRequirements(RunType runType, List<Location> locations) {
        Map<Integer, Integer> allRequirements = new HashMap<>();
        
        // Get run-specific configuration
        RunTypeConfig runConfig = getRunTypeConfig(runType);
        
        // Process each location
        for (Location location : locations) {
            if (!isLocationEnabled(runType, location.getName())) {
                continue;
            }
            
            // Add seed/sapling for this location
            allRequirements.merge(runConfig.getSeedId(), 1, Integer::sum);
            
            // Add coins for tree types
            if (runConfig.requiresCoins()) {
                allRequirements.merge(ItemID.COINS, 200, Integer::sum);
            }
            
            // Add compost if needed (not bottomless)
            Integer compostId = itemHelper.selectedCompostID();
            if (compostId != null && compostId != -1 && compostId != ItemID.BOTTOMLESS_COMPOST_BUCKET) {
                allRequirements.merge(compostId, 1, Integer::sum);
            }
            
            // Add teleport requirements
            Teleport teleport = location.getSelectedTeleport();
            if (teleport == null) {
                continue;
            }
            Map<Integer, Integer> locationRequirements = teleport.getItemRequirements();
            
            for (Map.Entry<Integer, Integer> entry : locationRequirements.entrySet()) {
                int itemId = entry.getKey();
                int quantity = entry.getValue();
                
                // Handle special items that should be counted as 1 max
                if (isSpecialItem(itemId, runType)) {
                    allRequirements.putIfAbsent(itemId, 1);
                } else {
                    allRequirements.merge(itemId, quantity, Integer::sum);
                }
            }            
            // Handle limpwurt seeds for herb runs
            if (runType == RunType.HERB && location.getFarmLimps() && config.generalLimpwurt()) {
                allRequirements.merge(ItemID.LIMPWURT_SEED, 1, Integer::sum);
                
                // Add compost for limpwurt patch if needed
                if (compostId != null && compostId != -1 && compostId != ItemID.BOTTOMLESS_COMPOST_BUCKET) {
                    allRequirements.merge(compostId, 1, Integer::sum);
                }
            }
        }
        
        // Add common tools
        if (runType == RunType.HERB && config.generalSeedDibber()) {
            allRequirements.merge(ItemID.DIBBER, 1, Integer::sum);
        }
        
        allRequirements.merge(ItemID.SPADE, 1, Integer::sum);
        
        // Add bottomless compost bucket if selected
        Integer compostId = itemHelper.selectedCompostID();
        if (compostId != null && compostId == ItemID.BOTTOMLESS_COMPOST_BUCKET) {
            allRequirements.merge(ItemID.BOTTOMLESS_COMPOST_BUCKET, 1, Integer::sum);
        }
        
        allRequirements.merge(ItemID.FAIRY_ENCHANTED_SECATEURS, 1, Integer::sum);
        
        if (config.generalRake()) {
            allRequirements.merge(ItemID.RAKE, 1, Integer::sum);
        }
        
        return allRequirements;
    }
    
    private boolean isLocationEnabled(RunType runType, String locationName) {
        switch (runType) {
            case HERB:
                return plugin.getHerbLocationEnabled(locationName);
            case TREE:
                return plugin.getTreeLocationEnabled(locationName);
            case FRUIT_TREE:
                return plugin.getFruitTreeLocationEnabled(locationName);
            default:
                return false;
        }
    }
    
    private boolean isSpecialItem(int itemId, RunType runType) {
        // Items that should be counted as max 1 regardless of how many locations need them
        if (itemId == ItemID.SKILLCAPE_CONSTRUCTION || 
            itemId == ItemID.SKILLCAPE_CONSTRUCTION_TRIMMED || 
            itemId == ItemID.SKILLCAPE_MAX) {
            return true;
        }
        
        if (itemId == ItemID.HG_QUETZALWHISTLE_BASIC || 
            itemId == ItemID.HG_QUETZALWHISTLE_ENHANCED || 
            itemId == ItemID.HG_QUETZALWHISTLE_PERFECTED) {
            return true;
        }
        
        if (itemId == ItemID.SKILLCAPE_HUNTING || 
            itemId == ItemID.SKILLCAPE_HUNTING_TRIMMED) {
            return true;
        }
        
        if (runType == RunType.FRUIT_TREE && itemId == ItemID.MM2_ROYAL_SEED_POD) {
            return true;
        }
        
        return false;
    }
    
    private RunTypeConfig getRunTypeConfig(RunType runType) {
        switch (runType) {
            case HERB:
                return new RunTypeConfig(ItemID.GUAM_SEED, false);
            case TREE:
                return new RunTypeConfig(ItemID.PLANTPOT_OAK_SAPLING, true);
            case FRUIT_TREE:
                return new RunTypeConfig(ItemID.PLANTPOT_APPLE_SAPLING, true);
            default:
                throw new IllegalArgumentException("Unknown run type: " + runType);
        }
    }
    
    private static class RunTypeConfig {
        private final int seedId;
        private final boolean requiresCoins;
        
        public RunTypeConfig(int seedId, boolean requiresCoins) {
            this.seedId = seedId;
            this.requiresCoins = requiresCoins;
        }
        
        public int getSeedId() { return seedId; }
        public boolean requiresCoins() { return requiresCoins; }
    }
    
    // Helper interface to abstract ItemAndLocation methods
    public interface ItemAndLocationHelper {
        Integer selectedCompostID();
        List<ItemRequirement> getHouseTeleportItemRequirements();
    }
}


package com.easyfarming.items;

public enum RunType {
    HERB,
    TREE,
    FRUIT_TREE
}


package com.easyfarming.core;

import com.easyfarming.EasyFarmingConfig;
import java.util.ArrayList;
import java.util.List;
import java.util.function.Function;

public class Location {
    private String name;
    private Boolean farmLimps;
    private List<Teleport> teleportOptions;
    private EasyFarmingConfig config;
    private final Function<EasyFarmingConfig, EasyFarmingConfig.OptionEnumTeleport> selectedTeleportFunction;

    public Location(Function<EasyFarmingConfig, EasyFarmingConfig.OptionEnumTeleport> selectedTeleportFunction,
                   EasyFarmingConfig config, String name, Boolean farmLimps) {
        this.config = config;
        this.selectedTeleportFunction = selectedTeleportFunction;
        this.name = name;
        this.farmLimps = farmLimps;
        this.teleportOptions = new ArrayList<>();
    }

    public void addTeleportOption(Teleport teleport) {
        teleportOptions.add(teleport);
    }

    public Teleport getSelectedTeleport() {
        String selectedEnumOption = selectedTeleportFunction.apply(config).name();
        for (Teleport teleport : teleportOptions) {
            if (teleport.getEnumOption().equalsIgnoreCase(selectedEnumOption)) {
                return teleport;
            }
        }
        return teleportOptions.isEmpty() ? null : teleportOptions.get(0);
    }

    // Getters
    public String getName() { return name; }
    public Boolean getFarmLimps() { return farmLimps; }
    public List<Teleport> getTeleportOptions() { return teleportOptions; }
}


package com.easyfarming.core;

public class ItemRequirement {
    private int itemId;
    private int quantity;

    public ItemRequirement(int itemId, int quantity) {
        this.itemId = itemId;
        this.quantity = quantity;
    }

    public int getItemId() {
        return itemId;
    }

    public int getQuantity() {
        return quantity;
    }
}


package com.easyfarming.core;

import net.runelite.api.coords.WorldPoint;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

public class Teleport {
    public enum Category {
        ITEM,
        PORTAL_NEXUS,
        SPIRIT_TREE,
        JEWELLERY_BOX,
        MOUNTED_XERICS,
        SPELLBOOK
    }
    
    private final String enumOption;
    private final Category category;
    private final String description;
    private final int id;
    private final String rightClickOption;
    private final int interfaceGroupId;
    private final int interfaceChildId;
    private final int regionId;
    private final WorldPoint point;
    private final List<ItemRequirement> itemRequirements;
    
    public Teleport(String enumOption, Category category, String description, int id,
                   String rightClickOption, int interfaceGroupId, int interfaceChildId,
                   int regionId, WorldPoint point, List<ItemRequirement> itemRequirements) {
        this.enumOption = enumOption;
        this.category = category;
        this.description = description;
        this.id = id;
        this.rightClickOption = rightClickOption;
        this.interfaceGroupId = interfaceGroupId;
        this.interfaceChildId = interfaceChildId;
        this.regionId = regionId;
        this.point = point;
        this.itemRequirements = itemRequirements;
    }
    
    public Map<Integer, Integer> getItemRequirements() {
        Map<Integer, Integer> requirements = new HashMap<>();
        for (ItemRequirement itemRequirement : itemRequirements) {
            requirements.put(itemRequirement.getItemId(), itemRequirement.getQuantity());
        }
        return requirements;
    }
    
    // Getters
    public String getEnumOption() { return enumOption; }
    public Category getCategory() { return category; }
    public String getDescription() { return description; }
    public int getId() { return id; }
    public String getRightClickOption() { return rightClickOption; }
    public int getInterfaceGroupId() { return interfaceGroupId; }
    public int getInterfaceChildId() { return interfaceChildId; }
    public int getRegionId() { return regionId; }
    public WorldPoint getPoint() { return point; }
    public List<ItemRequirement> getItemRequirementsList() { return itemRequirements; }
}


package com.easyfarming;

import net.runelite.client.RuneLite;
import net.runelite.client.externalplugins.ExternalPluginManager;

public class EasyFarmingPluginTest
{
	public static void main(String[] args) throws Exception
	{
		// Check if assertions are enabled
		boolean assertionsEnabled = false;
		try {
			assert assertionsEnabled = true;
		} catch (AssertionError e) {
			// Assertions are not enabled
		}
		
		if (!assertionsEnabled) {
			System.err.println("Assertions are not enabled. Please run with -ea flag:");
			System.err.println("java -ea -cp <classpath> com.easyfarming.EasyFarmingPluginTest");
			System.exit(1);
		}
		
		ExternalPluginManager.loadBuiltin(EasyFarmingPlugin.class);
		RuneLite.main(args);
	}
}
