package com.easyfarming.utils;

import net.runelite.api.gameval.ItemID;
import net.runelite.api.gameval.VarbitID;
import java.util.Arrays;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

public class Constants {
    
    // Scene size for iterating over tiles
    public static final int SCENE_SIZE = 104;
    
    // Region IDs
    public static final int REGION_ARDOUGNE = 10547;
    public static final int REGION_ARDOUGNE_ALT = 10548; // Alternative region ID for Ardougne farming area
    public static final int REGION_CATHERBY = 11062;
    public static final int REGION_FALADOR = 12083;
    public static final int REGION_FARMING_GUILD = 4922;
    public static final int REGION_HARMONY = 15148;
    public static final int REGION_KOUREND = 6967;
    public static final int REGION_MORYTANIA = 14391;
    public static final int REGION_TROLL_STRONGHOLD = 11321;
    public static final int REGION_WEISS = 11325;
    public static final int REGION_CIVITAS = 6192;
    public static final int REGION_GNOME_STRONGHOLD = 9782;
    public static final int REGION_GNOME_STRONGHOLD_ALT = 9781;
    
    // Varbit IDs for patch checking
    public static final int VARBIT_HERB_PATCH_STANDARD = 4774;
    public static final int VARBIT_HERB_PATCH_FARMING_GUILD = 4775;
    public static final int VARBIT_HERB_PATCH_HARMONY = 4772;
    public static final int VARBIT_HERB_PATCH_TROLL_WEISS = 4771;
    public static final int VARBIT_FLOWER_PATCH_STANDARD = 4773;
    public static final int VARBIT_FLOWER_PATCH_FARMING_GUILD = 7906;
    public static final int VARBIT_TREE_PATCH_STANDARD = 4771;
    public static final int VARBIT_TREE_PATCH_FARMING_GUILD = 7905;
    public static final int VARBIT_FRUIT_TREE_PATCH_STANDARD = 4771;
    public static final int VARBIT_FRUIT_TREE_PATCH_FARMING_GUILD = 7909;
    public static final int VARBIT_FRUIT_TREE_PATCH_GNOME_STRONGHOLD = 4772;
    // Allotment patch varbits - fallback only (object composition is preferred)
    // These are only used if object composition doesn't provide a varbit ID
    // Different locations use different transmit varbits:
    // Catherby uses A1/B1, Ardougne uses A2/B2
    public static final int VARBIT_ALLOTMENT_PATCH_NORTH_A1 = VarbitID.FARMING_TRANSMIT_A1;  // North patch fallback (Catherby)
    public static final int VARBIT_ALLOTMENT_PATCH_SOUTH_B1 = VarbitID.FARMING_TRANSMIT_B1;  // South patch fallback (Catherby)
    public static final int VARBIT_ALLOTMENT_PATCH_NORTH_A2 = VarbitID.FARMING_TRANSMIT_A2;  // North patch fallback (Ardougne)
    public static final int VARBIT_ALLOTMENT_PATCH_SOUTH_B2 = VarbitID.FARMING_TRANSMIT_B2;  // South patch fallback (Ardougne)
    
    // Tool Leprechaun varbits
    public static final int VARBIT_COMPOST_STORED = 1442;
    public static final int VARBIT_SUPERCOMPOST_STORED = 1443;
    public static final int VARBIT_ULTRACOMPOST_STORED = 5732;
    public static final int VARBIT_BOTTOMLESS_COMPOST = 7915;
    
    // Interface IDs
    public static final int INTERFACE_SPELLBOOK_RESIZABLE = 161;
    public static final int INTERFACE_SPELLBOOK_FIXED = 164;
    public static final int INTERFACE_SPELLBOOK_TAB_RESIZABLE = 65;
    public static final int INTERFACE_SPELLBOOK_TAB_FIXED = 58;
    public static final int INTERFACE_PORTAL_NEXUS = 17;
    public static final int INTERFACE_PORTAL_NEXUS_CHILD = 13;
    public static final int INTERFACE_SPIRIT_TREE = 187;
    public static final int INTERFACE_SPIRIT_TREE_CHILD = 3;
    public static final int INTERFACE_JEWELLERY_BOX = 29155;
    public static final int INTERFACE_JEWELLERY_BOX_OPEN = 590;
    public static final int INTERFACE_TOOL_LEPRECHAUN = 125;
    public static final int INTERFACE_FARMER = 219;
    public static final int INTERFACE_INVENTORY = 149;
    public static final int INTERFACE_MAGIC_SPELLBOOK = 218;
    
    // Widget IDs
    public static final int WIDGET_PORTAL_NEXUS_PARENT = 17;
    public static final int WIDGET_PORTAL_NEXUS_CHILD = 12;
    public static final int WIDGET_JEWELLERY_BOX_WIDGET = 590;
    public static final int WIDGET_JEWELLERY_BOX_CHILD = 5;
    
    // Item ID Groups
    public static final List<Integer> TELEPORT_CRYSTAL_IDS = Collections.unmodifiableList(Arrays.asList(
        ItemID.MOURNING_TELEPORT_CRYSTAL_1,
        ItemID.MOURNING_TELEPORT_CRYSTAL_2,
        ItemID.MOURNING_TELEPORT_CRYSTAL_3,
        ItemID.MOURNING_TELEPORT_CRYSTAL_4,
        ItemID.MOURNING_TELEPORT_CRYSTAL_5
    ));
    
    public static final List<Integer> SKILLS_NECKLACE_IDS = Collections.unmodifiableList(Arrays.asList(
        ItemID.JEWL_NECKLACE_OF_SKILLS_1,
        ItemID.JEWL_NECKLACE_OF_SKILLS_2,
        ItemID.JEWL_NECKLACE_OF_SKILLS_3,
        ItemID.JEWL_NECKLACE_OF_SKILLS_4,
        ItemID.JEWL_NECKLACE_OF_SKILLS_5,
        ItemID.JEWL_NECKLACE_OF_SKILLS_6
    ));
    
    public static final List<Integer> HERB_PATCH_IDS = Collections.unmodifiableList(Arrays.asList(
        33176, 27115, 8152, 8150, 8153, 18816, 8151, 9372, 33979, 50697
    ));
    
    public static final List<Integer> FLOWER_PATCH_IDS = Collections.unmodifiableList(Arrays.asList(
        27111, 7849, 7847, 7850, 7848, 33649, 50693
    ));
    
    public static final List<Integer> TREE_PATCH_IDS = Collections.unmodifiableList(Arrays.asList(
        8389, 33732, 19147, 8391, 8388, 8390
    ));
    
    public static final List<Integer> FRUIT_TREE_PATCH_IDS = Collections.unmodifiableList(Arrays.asList(
        7964, 7965, 34007, 7962, 26579, 7963
    ));
    
    // Allotment patch IDs per location
    // Format: [north patch, south patch] for each location
    // Note: Troll Stronghold and Weiss have no allotment patches
    // Harmony is excluded for now
    public static final Map<String, List<Integer>> ALLOTMENT_PATCH_IDS_BY_LOCATION;
    
    static {
        Map<String, List<Integer>> patchMap = new HashMap<>();
        patchMap.put("Ardougne", Arrays.asList(8554, 8555));  // north, south
        patchMap.put("Catherby", Arrays.asList(8552, 8553));  // north, south
        patchMap.put("Falador", Arrays.asList(8550, 8551));  // north, south
        patchMap.put("Farming Guild", Arrays.asList(33694, 33693));  // north, south
        patchMap.put("Kourend", Arrays.asList(27113, 27114));  // north, south
        patchMap.put("Morytania", Arrays.asList(8556, 8557));  // north, south
        patchMap.put("Civitas illa Fortis", Arrays.asList(50696, 50695));  // north, south
        ALLOTMENT_PATCH_IDS_BY_LOCATION = Collections.unmodifiableMap(patchMap);
    }
    
    // Herb patch IDs per location
    // Format: single patch ID for each location
    public static final Map<String, Integer> HERB_PATCH_IDS_BY_LOCATION;
    
    static {
        Map<String, Integer> patchMap = new HashMap<>();
        patchMap.put("Ardougne", 8150);
        patchMap.put("Catherby", 8152);
        patchMap.put("Falador", 8151);
        patchMap.put("Farming Guild", 33979);
        patchMap.put("Harmony Island", 9372);
        patchMap.put("Kourend", 27115);
        patchMap.put("Morytania", 18816);
        patchMap.put("Troll Stronghold", 33176);
        patchMap.put("Weiss", 8153);
        patchMap.put("Civitas illa Fortis", 50697);
        HERB_PATCH_IDS_BY_LOCATION = Collections.unmodifiableMap(patchMap);
    }
    
    // Flower patch IDs per location
    // Format: single patch ID for each location
    public static final Map<String, Integer> FLOWER_PATCH_IDS_BY_LOCATION;
    
    static {
        Map<String, Integer> patchMap = new HashMap<>();
        patchMap.put("Ardougne", 7847);
        patchMap.put("Catherby", 7849);
        patchMap.put("Falador", 7848);
        patchMap.put("Farming Guild", 33649);
        patchMap.put("Kourend", 27111);
        patchMap.put("Morytania", 7850);
        patchMap.put("Civitas illa Fortis", 50693);
        FLOWER_PATCH_IDS_BY_LOCATION = Collections.unmodifiableMap(patchMap);
    }
    
    // Legacy support - returns Ardougne patches by default
    @Deprecated
    public static final List<Integer> ALLOTMENT_PATCH_IDS = Collections.unmodifiableList(Arrays.asList(
        8554, 8555  // Ardougne: north patch, south patch
    ));
    
    public static final List<Integer> HERB_SEED_IDS = Collections.unmodifiableList(Arrays.asList(
        ItemID.GUAM_SEED, ItemID.MARRENTILL_SEED, ItemID.TARROMIN_SEED, ItemID.HARRALANDER_SEED,
        ItemID.RANARR_SEED, ItemID.TOADFLAX_SEED, ItemID.IRIT_SEED, ItemID.AVANTOE_SEED,
        ItemID.KWUARM_SEED, ItemID.SNAPDRAGON_SEED, ItemID.CADANTINE_SEED, ItemID.LANTADYME_SEED,
        ItemID.DWARF_WEED_SEED, ItemID.TORSTOL_SEED, ItemID.HUASCA_SEED
    ));
    
    public static final List<Integer> TREE_SAPLING_IDS = Collections.unmodifiableList(Arrays.asList(
        ItemID.PLANTPOT_OAK_SAPLING, ItemID.PLANTPOT_WILLOW_SAPLING, ItemID.PLANTPOT_MAPLE_SAPLING,
        ItemID.PLANTPOT_YEW_SAPLING, ItemID.PLANTPOT_MAGIC_TREE_SAPLING
    ));
    
    public static final List<Integer> FRUIT_TREE_SAPLING_IDS = Collections.unmodifiableList(Arrays.asList(
        ItemID.PLANTPOT_APPLE_SAPLING, ItemID.PLANTPOT_BANANA_SAPLING, ItemID.PLANTPOT_ORANGE_SAPLING,
        ItemID.PLANTPOT_CURRY_SAPLING, ItemID.PLANTPOT_PINEAPPLE_SAPLING, ItemID.PLANTPOT_PAPAYA_SAPLING,
        ItemID.PLANTPOT_PALM_SAPLING, ItemID.PLANTPOT_DRAGONFRUIT_SAPLING
    ));
    
    public static final List<Integer> ALLOTMENT_SEED_IDS = Collections.unmodifiableList(Arrays.asList(
        ItemID.POTATO_SEED, ItemID.ONION_SEED, ItemID.CABBAGE_SEED, ItemID.TOMATO_SEED,
        ItemID.SWEETCORN_SEED, ItemID.STRAWBERRY_SEED, ItemID.WATERMELON_SEED, ItemID.SNAPE_GRASS_SEED
    ));
    
    public static final List<Integer> WATERING_CAN_IDS = Collections.unmodifiableList(Arrays.asList(
        5331, 5333, 5334, 5335, 5336, 5337, 5338, 5339, 5340
    ));
    
    public static final List<Integer> RUNE_POUCH_IDS = Collections.unmodifiableList(Arrays.asList(
        ItemID.BH_RUNE_POUCH, ItemID.DIVINE_RUNE_POUCH
    ));
    
    public static final List<Integer> RUNE_POUCH_AMOUNT_VARBITS = Collections.unmodifiableList(Arrays.asList(
        VarbitID.RUNE_POUCH_QUANTITY_1, VarbitID.RUNE_POUCH_QUANTITY_2,
        VarbitID.RUNE_POUCH_QUANTITY_3, VarbitID.RUNE_POUCH_QUANTITY_4
    ));
    
    public static final List<Integer> RUNE_POUCH_RUNE_VARBITS = Collections.unmodifiableList(Arrays.asList(
        VarbitID.RUNE_POUCH_TYPE_1, VarbitID.RUNE_POUCH_TYPE_2,
        VarbitID.RUNE_POUCH_TYPE_3, VarbitID.RUNE_POUCH_TYPE_4
    ));
    
    public static final List<Integer> SPIRIT_TREE_IDS = Collections.unmodifiableList(Arrays.asList(
        1293, 1294, 1295, 8355, 29227, 29229, 37329, 40778
    ));
    
    public static final List<Integer> JEWELLERY_BOX_IDS = Collections.unmodifiableList(Arrays.asList(
        29154, 29155, 29156
    ));
    
    public static final List<Integer> XERICS_TALISMAN_IDS = Collections.unmodifiableList(Arrays.asList(
        33411, 33412, 33413, 33414, 33415
    ));
    
    // Base item IDs (for variant handling)
    public static final int BASE_TELEPORT_CRYSTAL_ID = ItemID.MOURNING_TELEPORT_CRYSTAL_1;
    public static final int BASE_SKILLS_NECKLACE_ID = ItemID.JEWL_NECKLACE_OF_SKILLS_1;
    public static final int BASE_HERB_SEED_ID = ItemID.GUAM_SEED;
    public static final int BASE_TREE_SAPLING_ID = ItemID.PLANTPOT_OAK_SAPLING;
    public static final int BASE_FRUIT_TREE_SAPLING_ID = ItemID.PLANTPOT_APPLE_SAPLING;
    public static final int BASE_ALLOTMENT_SEED_ID = ItemID.SNAPE_GRASS_SEED;
    
    // Combination rune mapping
    public static final Map<Integer, List<Integer>> COMBINATION_RUNE_SUBRUNES_MAP;
    
    static {
        Map<Integer, List<Integer>> tempMap = new HashMap<>();
        tempMap.put(ItemID.DUSTRUNE, Arrays.asList(ItemID.AIRRUNE, ItemID.EARTHRUNE));
        tempMap.put(ItemID.MISTRUNE, Arrays.asList(ItemID.AIRRUNE, ItemID.WATERRUNE));
        tempMap.put(ItemID.MUDRUNE, Arrays.asList(ItemID.WATERRUNE, ItemID.EARTHRUNE));
        tempMap.put(ItemID.LAVARUNE, Arrays.asList(ItemID.FIRERUNE, ItemID.EARTHRUNE));
        tempMap.put(ItemID.STEAMRUNE, Arrays.asList(ItemID.FIRERUNE, ItemID.WATERRUNE));
        tempMap.put(ItemID.SMOKERUNE, Arrays.asList(ItemID.FIRERUNE, ItemID.AIRRUNE));
        COMBINATION_RUNE_SUBRUNES_MAP = Collections.unmodifiableMap(tempMap);
    }
    
    // Helper methods
    public static boolean isTeleportCrystal(int itemId) {
        return TELEPORT_CRYSTAL_IDS.contains(itemId);
    }
    
    public static boolean isSkillsNecklace(int itemId) {
        return SKILLS_NECKLACE_IDS.contains(itemId);
    }
    
    public static boolean isHerbSeed(int itemId) {
        return HERB_SEED_IDS.contains(itemId);
    }
    
    public static boolean isTreeSapling(int itemId) {
        return TREE_SAPLING_IDS.contains(itemId);
    }
    
    public static boolean isFruitTreeSapling(int itemId) {
        return FRUIT_TREE_SAPLING_IDS.contains(itemId);
    }
    
    public static boolean isAllotmentSeed(int itemId) {
        return ALLOTMENT_SEED_IDS.contains(itemId);
    }
    
    public static boolean isQuetzalWhistle(int itemId) {
        return itemId == ItemID.HG_QUETZALWHISTLE_BASIC ||
               itemId == ItemID.HG_QUETZALWHISTLE_ENHANCED ||
               itemId == ItemID.HG_QUETZALWHISTLE_PERFECTED;
    }
}


package com.easyfarming;

import net.runelite.api.Client;

import java.util.Arrays;
import java.util.List;
import java.util.stream.Collectors;
import java.util.stream.Stream;

public class FruitTreePatchChecker {
    public enum FruitTree {
        //Order of lists is "growing, diseased, dead, healthy, remove"
        APPLE(Arrays.asList(8,9,10,11,12,13), Arrays.asList(21,22,23,24,25,26), Arrays.asList(27,28,29,30,31,32), Arrays.asList(34), Arrays.asList(14,15,16,17,18,19,20, 33)),
        BANANA(Arrays.asList(35,36,37,38,39,40), Arrays.asList(48,49,50,51,52,53), Arrays.asList(54,55,56,57,58,59), Arrays.asList(61), Arrays.asList(41,42,43,44,45,46,47, 60)),
        ORANGE(Arrays.asList(72,73,74,75,76,77), Arrays.asList(85,86,87,88,89, 90), Arrays.asList(91,92,93,94,95,96), Arrays.asList(98), Arrays.asList(78,79,80,81,82,83,84, 97)),
        CURRY(Arrays.asList(99,100,101,102,103,104), Arrays.asList(112,113,114,115,116,117), Arrays.asList(118,119,120,121,122,123), Arrays.asList(125), Arrays.asList(105,106,107,108,109,110,111, 124)),
        PINEAPPLE(Arrays.asList(136,137,138,139,140,141), Arrays.asList(149,150,151,152,153,154), Arrays.asList(155,156,157,158,159,160), Arrays.asList(162), Arrays.asList(142,143,144,145,146,147,148, 161)),
        PAPAYA(Arrays.asList(163,164,165,166,167,168), Arrays.asList(176,177,178,179,180,181), Arrays.asList(182,183,184,185,186,187), Arrays.asList(189), Arrays.asList(169,170,171,172,173,174,175, 188)),
        PALM(Arrays.asList(200,201,202,203,204,205), Arrays.asList(213,214,215,216,217,218), Arrays.asList(219,220,221,222,223,224), Arrays.asList(226), Arrays.asList(206,207,208,209,210,211,212, 225)),
        DRAGONFRUIT(Arrays.asList(227,228,229,230,231,232), Arrays.asList(240,241,242,243,244,245), Arrays.asList(246,247,248,249,250,251), Arrays.asList(253), Arrays.asList(233,234,235,236,237,238,239, 252));

        private final List<Integer> growing;
        private final List<Integer> diseased;
        private final List<Integer> dead;
        private final List<Integer> healthy;
        private final List<Integer> remove;

        FruitTree(List<Integer> growing, List<Integer> diseased, List<Integer> dead, List<Integer> healthy, List<Integer> remove) {
            this.growing = growing;
            this.diseased = diseased;
            this.dead = dead;
            this.healthy = healthy;
            this.remove = remove;
        }

        public List<Integer> getGrowing() {
            return growing;
        }

        public List<Integer> getDiseased() {
            return diseased;
        }

        public List<Integer> getDead() {
            return dead;
        }

        public List<Integer> getHealthy() {
            return healthy;
        }
        public List<Integer> getRemove() {
            return remove;
        }
    }

    // Combine all growing and dead varbit values into single lists
    private static final List<Integer> growing = Stream.of(FruitTree.values())
            .flatMap(fruitTree -> fruitTree.getGrowing().stream())
            .collect(Collectors.toList());

    private static final List<Integer> diseased = Stream.of(FruitTree.values())
            .flatMap(fruitTree -> fruitTree.getDiseased().stream())
            .collect(Collectors.toList());

    private static final List<Integer> dead = Stream.of(FruitTree.values())
            .flatMap(fruitTree -> fruitTree.getDead().stream())
            .collect(Collectors.toList());

    private static final List<Integer> healthy = Stream.of(FruitTree.values())
            .flatMap(fruitTree -> fruitTree.getHealthy().stream())
            .collect(Collectors.toList());
    private static final List<Integer> remove = Stream.of(FruitTree.values())
            .flatMap(fruitTree -> fruitTree.getRemove().stream())
            .collect(Collectors.toList());

    private static final List<Integer> weeds = Arrays.asList(0, 1, 2);

    public enum PlantState {
        GROWING,
        DISEASED,
        DEAD,
        WEEDS,
        HEALTHY,
        REMOVE,
        PLANT,
        UNKNOWN
    }

    public static PlantState checkFruitTreePatch(Client client, int varbitIndex) {
        int varbitValue = client.getVarbitValue(varbitIndex);
        if (growing.contains(varbitValue)) {
            return PlantState.GROWING;
        } else if (diseased.contains(varbitValue)) {
            return PlantState.DISEASED;
        } else if (dead.contains(varbitValue)) {
            return PlantState.DEAD;
        } else if (weeds.contains(varbitValue)) {
            return PlantState.WEEDS;
        }  else if (healthy.contains(varbitValue)) {
            return PlantState.HEALTHY;
        }else if (remove.contains(varbitValue)) {
            return PlantState.REMOVE;
        } else if (varbitValue == 3) {
            return PlantState.PLANT;
        } else {
            return PlantState.UNKNOWN;
        }
    }
}
package com.easyfarming;

import java.awt.*;
import net.runelite.client.config.Config;
import net.runelite.client.config.ConfigGroup;
import net.runelite.client.config.ConfigItem;
import net.runelite.client.config.ConfigSection;

@ConfigGroup("farminghelper")
public interface EasyFarmingConfig extends Config
{
	@ConfigSection(
			name = "General",
			description = "The highlighted and hidden item lists",
			position = 0,
			closedByDefault = false
	)
	String generalList = "generalList";

	enum OptionEnumHouseTele
	{
		Law_air_earth_runes,
		Teleport_To_House,
		Construction_cape,
		Construction_cape_t,
		Max_cape
	}
	public interface OptionEnumTeleport {
		String name();
	}
	@ConfigItem(
			position = 10,
			keyName = "enumConfigHouseTele",
			name = "House teleport",
			description = "Desired way to teleport to house",
			section = generalList
	)
	default OptionEnumHouseTele enumConfigHouseTele() { return OptionEnumHouseTele.Law_air_earth_runes; }
	@ConfigItem(
			position = 1,
			keyName = "highlightLeftClickColor",
			name = "Left Click Color",
			description = "The color to use for highlighting objects",
			section = generalList
	)
	default Color highlightLeftClickColor() {return new Color(0, 191, 255, 128);}
	@ConfigItem(
			position = 2,
			keyName = "highlightRightClickColor",
			name = "Right Click Color",
			description = "The color to use for highlighting objects",
			section = generalList
	)
	default Color highlightRightClickColor() {return new Color(0, 191, 30, 128);}
	@ConfigItem(
			position = 3,
			keyName = "highlightUseItemColor",
			name = "'Use' item Color",
			description = "The color to use for highlighting objects",
			section = generalList
	)
	default Color highlightUseItemColor() {return new Color(255, 192, 203, 128);}
	@ConfigItem(
			position = 4,
			keyName = "highlightAlpha",
			name = "Transparency",
			description = "The transparency value for the highlight color (0-255)",
			section = generalList
	)
	default int highlightAlpha() {return 128;}

	enum OptionEnumCompost
	{
		Compost,
		Supercompost,
		Ultracompost,
		Bottomless
	}
	@ConfigItem(
			position = 5,
			keyName = "enumConfigCompost",
			name = "Compost",
			description = "Desired Compost",
			section = generalList
	)
	default OptionEnumCompost enumConfigCompost() { return OptionEnumCompost.Bottomless; }


	@ConfigItem(
			keyName = "booleanConfigRake",
			name = "Rake",
			description = "Include rake?",
			position = 6,
			section = generalList
	)
	default boolean generalRake() { return false; }
	@ConfigItem(
		keyName = "booleanConfigSeedDibber",
		name = "Seed dibber",
		description = "Include seed dibber?",
		position = 7,
		section = generalList
	)
	default boolean generalSeedDibber() { return true; }
	@ConfigItem(
			keyName = "booleanConfigLimpwurt",
			name = "Limpwurt",
			description = "Want to include limpwurts in your farm run?",
			position = 8,
			section = generalList
	)
	default boolean generalLimpwurt() { return false; }
	@ConfigItem(
			keyName = "booleanConfigAllotment",
			name = "Allotments",
			description = "Want to include Allotments in your farm run?",
			position = 9,
			section = generalList
	)
	default boolean generalAllotment() { return false; }

	@ConfigItem(
		keyName = "booleanConfigPayForProtection",
		name = "Pay for protection",
		description = "Want a reminder to pay for protection? (This currently doesn't check for the required items, only prompts you to pay the farmer.)",
		position = 10,
		section = generalList
	)
	default boolean generalPayForProtection() { return false; }


	@ConfigSection(
		name = "Herbs",
		description = "The highlighted and hidden item lists",
		position = 1,
		closedByDefault = true
	)
	String herbList = "herbList";

	@ConfigItem(
		keyName = "booleanConfigArdougneHerb",
		name = "Ardougne",
		description = "Include Ardougne?",
		position = 1,
		section = herbList
	)
	default boolean ardougneHerb() { return true; }
	
	@ConfigItem(
		position = 2,
		keyName = "booleanConfigCatherbyHerb",
		name = "Catherby",
		description = "Include Catherby?",
		section = herbList
	)
	default boolean catherbyHerb() { return true; }
	
	@ConfigItem(
		position = 3,
		keyName = "booleanConfigFaladorHerb",
		name = "Falador",
		description = "Include Falador?",
		section = herbList
	)
	default boolean faladorHerb() { return true; }
	
	@ConfigItem(
		position = 4,
		keyName = "booleanConfigFarmingGuildHerb",
		name = "Farming Guild",
		description = "Include Farming guild? (Requires level 65 farming and 60% Hosidious favour)",
		section = herbList
	)
	default boolean farmingGuildHerb() { return false; }
	
	@ConfigItem(
		position = 5,
		keyName = "booleanConfigHarmonyHerb",
		name = "Harmony",
		description = "Include Harmony? (Requires elite Morytania diary)",
		section = herbList
	)
	default boolean harmonyHerb() { return false; }
	
	@ConfigItem(
		position = 6,
		keyName = "booleanConfigKourendHerb",
		name = "Kourend",
		description = "Include Kourend?",
		section = herbList
	)
	default boolean kourendHerb() { return true; }
	
	@ConfigItem(
		position = 7,
		keyName = "booleanConfigMorytaniaHerb",
		name = "Morytania",
		description = "Include Morytania?",
		section = herbList
	)
	default boolean morytaniaHerb() { return true; }
	
	@ConfigItem(
		position = 8,
		keyName = "booleanConfigTrollStrongholdHerb",
		name = "Troll Stronghold",
		description = "Include Troll Stronghold(Requires completion of My Arm's Big Adventure)?",
		section = herbList
	)
	default boolean trollStrongholdHerb() { return false; }
	
	@ConfigItem(
		position = 9,
		keyName = "booleanConfigWeissHerb",
		name = "Weiss",
		description = "Include Weiss? (Requires completion of Making Friends with My Arm, and The Fire of Nourishment must be built)",
		section = herbList
	)
	default boolean weissHerb() { return false; }

	@ConfigItem(
		position = 10,
		keyName = "booleanConfigCivitasHerb",
		name = "Civitas illa Fortis",
		description = "Include Civitas illa Fortis?",
		section = herbList
	)
	default boolean civitasHerb() { return false; }

	@ConfigSection(
		name = "Tree",
		description = "The highlighted and hidden item lists",
		position = 2,
		closedByDefault = true
	)
	String treeList = "treeList";
	
	@ConfigItem(
		position = 10,
		keyName = "booleanConfigFaladorTree",
		name = "Falador",
		description = "Include Falador?",
		section = treeList
	)
	default boolean faladorTree() { return true; }
	
	@ConfigItem(
		position = 11,
		keyName = "booleanConfigFarmingGuildTree",
		name = "Farming guild",
		description = "Include Farming Guild? (Requires 65 farming)",
		section = treeList
	)
	default boolean farmingGuildTree() { return false; }
	
	@ConfigItem(
		position = 12,
		keyName = "booleanConfigGnomeStrongholdTree",
		name = "Gnome Stronghold",
		description = "Include Gnome Stronghold?",
		section = treeList
	)
	default boolean gnomeStrongholdTree() { return true; }
	
	@ConfigItem(
		position = 13,
		keyName = "booleanConfigLumbridgeTree",
		name = "Lumbridge",
		description = "Include Lumbridge?",
		section = treeList
	)
	default boolean lumbridgeTree() { return true; }
	
	@ConfigItem(
		position = 14,
		keyName = "booleanConfigTaverleyTree",
		name = "Taverley",
		description = "Include Taverley?",
		section = treeList
	)
	default boolean taverleyTree() { return true; }
	
	@ConfigItem(
		position = 15,
		keyName = "booleanConfigVarrockTree",
		name = "Varrock",
		description = "Include Varrock?",
		section = treeList
	)
	default boolean varrockTree() { return true; }
	
	@ConfigSection(
		name = "Fruit Tree",
		description = "The highlighted and hidden item lists",
		position = 3,
		closedByDefault = true
	)
	String fruitTreeList = "fruitTreeList";
	
	@ConfigItem(
		position = 16,
		keyName = "booleanConfigBrimhavenFruitTree",
		name = "Brimhaven",
		description = "Include Brimhaven?",
		section = fruitTreeList
	)
	default boolean brimhavenFruitTree() { return true; }
	
	@ConfigItem(
		position = 17,
		keyName = "booleanConfigCatherbyFruitTree",
		name = "Catherby",
		description = "Include Catherby?",
		section = fruitTreeList
	)
	default boolean catherbyFruitTree() { return true; }
	
	@ConfigItem(
		position = 18,
		keyName = "booleanConfigFarmingGuildFruitTree",
		name = "Farming Guild",
		description = "Include Farming Guild? (Requires 85 farming)",
		section = fruitTreeList
	)
	default boolean farmingGuildFruitTree() { return false; }
	
	@ConfigItem(
		position = 19,
		keyName = "booleanConfigGnomeStrongholdFruitTree",
		name = "Gnome Stronghold",
		description = "Include Gnome Stronghold?",
		section = fruitTreeList
	)
	default boolean gnomeStrongholdFruitTree() { return true; }
	
	@ConfigItem(
		position = 20,
		keyName = "booleanConfigLletyaFruitTree",
		name = "Lletya",
		description = "Include Lletya? (Requires starting Mourning's End Part I)",
		section = fruitTreeList
	)
	default boolean lletyaFruitTree() { return false; }
	
	@ConfigItem(
		position = 21,
		keyName = "booleanConfigTreeGnomeVillageFruitTree",
		name = "Tree Gnome Village",
		description = "Include Tree Gnome Village?",
		section = fruitTreeList
	)
	default boolean treeGnomeVillageFruitTree() { return true; }


	@ConfigSection(
			name = "Herb teleport options",
			description = "Choose what teleport to use for each Herb patch",
			position = 4,
			closedByDefault = true
	)
	String teleportOptionList = "teleportOptionList";

	enum OptionEnumArdougneTeleport implements OptionEnumTeleport
	{
		Portal_Nexus,
		Ardougne_teleport,
		Ardougne_tele_tab,
		Ardy_cloak,
		Skills_Necklace
	}
	@ConfigItem(
			position = 2,
			keyName = "enumOptionEnumArdougneTeleport",
			name = "Ardougne",
			description = "Desired way to teleport to Ardougne",
			section = teleportOptionList
	)
	default OptionEnumArdougneTeleport enumOptionEnumArdougneTeleport() { return OptionEnumArdougneTeleport.Ardy_cloak; }
	enum OptionEnumCatherbyTeleport implements OptionEnumTeleport
	{
		Portal_Nexus_Catherby,
		Portal_Nexus_Camelot,
		Camelot_Teleport,
		Camelot_Tele_Tab,
		Catherby_Tele_Tab
	}
	@ConfigItem(
			position = 3,
			keyName = "enumOptionEnumCatherbyTeleport",
			name = "Catherby",
			description = "Desired way to teleport to Catherby",
			section = teleportOptionList
	)
	default OptionEnumCatherbyTeleport enumOptionEnumCatherbyTeleport() { return OptionEnumCatherbyTeleport.Portal_Nexus_Catherby; }

	enum OptionEnumFaladorTeleport implements OptionEnumTeleport
	{
		Portal_Nexus,
		Explorers_ring,
		Falador_Teleport,
		Falador_Tele_Tab,
		Draynor_Tele_Tab
	}
	@ConfigItem(
			position = 4,
			keyName = "enumOptionEnumFaladorTeleport",
			name = "Falador",
			description = "Desired way to teleport to Falador",
			section = teleportOptionList
	)
	default OptionEnumFaladorTeleport enumOptionEnumFaladorTeleport() { return OptionEnumFaladorTeleport.Explorers_ring; }

	enum OptionEnumFarmingGuildTeleport implements OptionEnumTeleport
	{
		Jewellery_box,
		Skills_Necklace
	}
	@ConfigItem(
			position = 5,
			keyName = "enumOptionEnumFarmingGuildTeleport",
			name = "Farming Guild",
			description = "Desired way to teleport to Farming Guild",
			section = teleportOptionList
	)
	default OptionEnumFarmingGuildTeleport enumOptionEnumFarmingGuildTeleport() { return OptionEnumFarmingGuildTeleport.Jewellery_box; }

	enum OptionEnumHarmonyTeleport implements OptionEnumTeleport
	{
		Portal_Nexus,
		Harmony_Tele_tab
	}
	@ConfigItem(
			position = 6,
			keyName = "enumOptionEnumHarmonyTeleport",
			name = "Harmony",
			description = "Desired way to teleport to Harmony",
			section = teleportOptionList
	)
	default OptionEnumHarmonyTeleport enumOptionEnumHarmonyTeleport() { return OptionEnumHarmonyTeleport.Portal_Nexus; }

	enum OptionEnumKourendTeleport implements OptionEnumTeleport
	{
		Xerics_Talisman,
		Mounted_Xerics
	}
	@ConfigItem(
			position = 7,
			keyName = "enumOptionEnumKourendTeleport",
			name = "Kourend",
			description = "Desired way to teleport to Kourend",
			section = teleportOptionList
	)
	default OptionEnumKourendTeleport enumOptionEnumKourendTeleport() { return OptionEnumKourendTeleport.Xerics_Talisman; }

	enum OptionEnumMorytaniaTeleport implements OptionEnumTeleport
	{
		Ectophial
	}
	@ConfigItem(
			position = 8,
			keyName = "enumOptionEnumMorytaniaTeleport",
			name = "Morytania",
			description = "Desired way to teleport to Morytania",
			section = teleportOptionList
	)
	default OptionEnumMorytaniaTeleport enumOptionEnumMorytaniaTeleport() { return OptionEnumMorytaniaTeleport.Ectophial; }

	enum OptionEnumTrollStrongholdTeleport implements OptionEnumTeleport
	{
		Portal_Nexus,
		Stony_Basalt
	}
	@ConfigItem(
			position = 9,
			keyName = "enumOptionEnumTrollStrongholdTeleport",
			name = "Troll Stronghold",
			description = "Desired way to teleport to Troll Stronghold",
			section = teleportOptionList
	)
	default OptionEnumTrollStrongholdTeleport enumOptionEnumTrollStrongholdTeleport() { return OptionEnumTrollStrongholdTeleport.Portal_Nexus; }

	enum OptionEnumWeissTeleport implements OptionEnumTeleport
	{
		Portal_Nexus,
		Icy_basalt
	}
	@ConfigItem(
			position = 10,
			keyName = "enumOptionEnumWeissTeleport",
			name = "Weiss",
			description = "Desired way to teleport to Weiss",
			section = teleportOptionList
	)
	default OptionEnumWeissTeleport enumOptionEnumWeissTeleport() { return OptionEnumWeissTeleport.Portal_Nexus; }

	enum OptionEnumCivitasTeleport implements OptionEnumTeleport
	{
		Portal_Nexus,
		Civitas_Teleport,
		Civitas_Tele_Tab,
		Quetzal_whistle,
		Hunter_Skillcape
	}
	@ConfigItem(
		position = 11,
		keyName = "enumOptionEnumCivitasTeleport",
		name = "Civitas illa Fortis",
		description = "Desired way to teleport to Civitas illa Fortis",
		section = teleportOptionList
	)
	default OptionEnumCivitasTeleport enumOptionEnumCivitasTeleport() { return OptionEnumCivitasTeleport.Portal_Nexus; }

	@ConfigSection(
			name = "Tree teleport options",
			description = "Choose what teleport to use for each Herb patch",
			position = 5,
			closedByDefault = true
	)
	String treeTeleportOptionList = "treeTeleportOptionList";
	enum TreeOptionEnumFaladorTeleport implements OptionEnumTeleport
	{
		Portal_Nexus,
		Teleport,
		Falador_Tele_Tab
	}
	@ConfigItem(
			position = 1,
			keyName = "enumTreeFaladorTeleport",
			name = "Falador",
			description = "Desired way to teleport to Falador",
			section = treeTeleportOptionList
	)
	default TreeOptionEnumFaladorTeleport enumTreeFaladorTeleport() { return TreeOptionEnumFaladorTeleport.Teleport; }

	enum TreeOptionEnumFarmingGuildTeleport implements OptionEnumTeleport
	{
		Jewellery_box,
		Skills_Necklace
	}
	@ConfigItem(
			position = 1,
			keyName = "enumTreeFarmingGuildTeleport",
			name = "Farming Guild",
			description = "Desired way to teleport to Farming Guild",
			section = treeTeleportOptionList
	)
	default TreeOptionEnumFarmingGuildTeleport enumTreeFarmingGuildTeleport() { return TreeOptionEnumFarmingGuildTeleport.Jewellery_box; }

	enum TreeOptionEnumGnomeStrongholdTeleport implements OptionEnumTeleport
	{
		Royal_seed_pod,
		Spirit_Tree
	}
	@ConfigItem(
			position = 2,
			keyName = "enumTreeGnomeStrongoldTeleport",
			name = "Gnome Stronghold",
			description = "Desired way to teleport to Gnome Stronghold",
			section = treeTeleportOptionList
	)
	default TreeOptionEnumGnomeStrongholdTeleport enumTreeGnomeStrongoldTeleport() { return TreeOptionEnumGnomeStrongholdTeleport.Royal_seed_pod; }

	enum TreeOptionEnumLumbridgeTeleport implements OptionEnumTeleport
	{
		Portal_Nexus,
		Teleport,
		Lumbridge_Tele_Tab
	}
	@ConfigItem(
			position = 3,
			keyName = "enumTreeLumbridgeTeleport",
			name = "Lumbridge",
			description = "Desired way to teleport to Lumbridge",
			section = treeTeleportOptionList
	)
	default TreeOptionEnumLumbridgeTeleport enumTreeLumbridgeTeleport() { return TreeOptionEnumLumbridgeTeleport.Teleport; }

	enum TreeOptionEnumTaverleyTeleport implements OptionEnumTeleport
	{
		Portal_Nexus,
		Teleport,
		Falador_Tele_Tab
	}
	@ConfigItem(
			position = 4,
			keyName = "enumTreeTaverleyTeleport",
			name = "Taverley",
			description = "Desired way to teleport to Taverley",
			section = treeTeleportOptionList
	)
	default TreeOptionEnumTaverleyTeleport enumTreeTaverleyTeleport() { return TreeOptionEnumTaverleyTeleport.Teleport; }

	enum TreeOptionEnumVarrockTeleport implements OptionEnumTeleport
	{
		Portal_Nexus,
		Teleport,
		Varrock_Tele_Tab
	}
	@ConfigItem(
			position = 5,
			keyName = "enumTreeVarrockTeleport",
			name = "Varrock",
			description = "Desired way to teleport to Varrock",
			section = treeTeleportOptionList
	)
	default TreeOptionEnumVarrockTeleport enumTreeVarrockTeleport() { return TreeOptionEnumVarrockTeleport.Teleport; }

	@ConfigSection(
			name = "Fruit tree teleport options",
			description = "Choose what teleport to use for each fruit tree",
			position = 6,
			closedByDefault = true
	)
	String fruitTreeTeleportOptionList = "fruitTreeTeleportOptionList";

	enum FruitTreeOptionEnumBrimhavenTeleport implements OptionEnumTeleport
	{
		Portal_Nexus,
		Ardougne_teleport,
		Ardougne_Tele_Tab,
		POH_Tele_Tab
	}
	@ConfigItem(
			position = 1,
			keyName = "enumFruitTreeBrimhavenTeleport",
			name = "Brimhaven",
			description = "Desired way to teleport to Brimhaven",
			section = fruitTreeTeleportOptionList
	)
	default FruitTreeOptionEnumBrimhavenTeleport enumFruitTreeBrimhavenTeleport() { return FruitTreeOptionEnumBrimhavenTeleport.Ardougne_teleport; }

	enum FruitTreeOptionEnumCatherbyTeleport implements OptionEnumTeleport
	{
		Portal_Nexus_Catherby,
		Portal_Nexus_Camelot,
		Camelot_Teleport,
		Camelot_Tele_Tab,
		Catherby_Tele_Tab
	}
	@ConfigItem(
			position = 1,
			keyName = "enumFruitTreeCatherbyTeleport",
			name = "Catherby",
			description = "Desired way to teleport to Catherby",
			section = fruitTreeTeleportOptionList
	)
	default FruitTreeOptionEnumCatherbyTeleport enumFruitTreeCatherbyTeleport() { return FruitTreeOptionEnumCatherbyTeleport.Portal_Nexus_Catherby; }

	enum FruitTreeOptionEnumFarmingGuildTeleport implements OptionEnumTeleport
	{
		Jewellery_box,
		Skills_Necklace
	}
	@ConfigItem(
			position = 1,
			keyName = "enumFruitTreeFarmingGuildTeleport",
			name = "Farming Guild",
			description = "Desired way to teleport to Farming Guild",
			section = fruitTreeTeleportOptionList
	)
	default FruitTreeOptionEnumFarmingGuildTeleport enumFruitTreeFarmingGuildTeleport() { return FruitTreeOptionEnumFarmingGuildTeleport.Jewellery_box; }

	enum FruitTreeOptionEnumGnomeStrongholdTeleport implements OptionEnumTeleport
	{
		Royal_seed_pod,
		Spirit_Tree
	}
	@ConfigItem(
			position = 1,
			keyName = "enumFruitTreeGnomeStrongholdTeleport",
			name = "Gnome Stronghold",
			description = "Desired way to teleport to Gnome Stronghold",
			section = fruitTreeTeleportOptionList
	)
	default FruitTreeOptionEnumGnomeStrongholdTeleport enumFruitTreeGnomeStrongholdTeleport() { return FruitTreeOptionEnumGnomeStrongholdTeleport.Royal_seed_pod; }

	enum FruitTreeOptionEnumLletyaTeleport implements OptionEnumTeleport
	{
		Teleport_crystal
	}
	@ConfigItem(
			position = 1,
			keyName = "enumFruitTreeLletyaTeleport",
			name = "Lletya",
			description = "Desired way to teleport to Lletya",
			section = fruitTreeTeleportOptionList
	)
	default FruitTreeOptionEnumLletyaTeleport enumFruitTreeLletyaTeleport() { return FruitTreeOptionEnumLletyaTeleport.Teleport_crystal; }

	enum FruitTreeOptionEnumTreeGnomeVillageTeleport implements OptionEnumTeleport
	{
		Royal_seed_pod,
		Spirit_Tree
	}
	@ConfigItem(
			position = 1,
			keyName = "enumFruitTreeTreeGnomeVillageTeleport",
			name = "Tree Gnome Village",
			description = "Desired way to teleport to Tree Gnome Village",
			section = fruitTreeTeleportOptionList
	)
	default FruitTreeOptionEnumTreeGnomeVillageTeleport enumFruitTreeTreeGnomeVillageTeleport() { return FruitTreeOptionEnumTreeGnomeVillageTeleport.Royal_seed_pod; }
}
package com.easyfarming.overlays.handlers;

import com.easyfarming.*;
import com.easyfarming.core.Location;
import com.easyfarming.core.Teleport;
import com.easyfarming.overlays.highlighting.*;
import com.easyfarming.overlays.utils.ColorProvider;
import com.easyfarming.overlays.utils.GameObjectHelper;
import com.easyfarming.overlays.utils.WidgetHelper;
import com.easyfarming.utils.Constants;
import net.runelite.api.Client;
import net.runelite.api.coords.WorldPoint;
import net.runelite.api.gameval.InterfaceID;
import net.runelite.api.gameval.ItemID;
import net.runelite.api.gameval.VarClientID;
import net.runelite.api.widgets.Widget;

import javax.inject.Inject;
import java.awt.*;
import java.util.List;
import java.util.Objects;

/**
 * Handles teleport navigation logic for getting to locations and houses.
 */
public class NavigationHandler {
    private final Client client;
    private final EasyFarmingPlugin plugin;
    private final EasyFarmingConfig config;
    private final AreaCheck areaCheck;
    private final TeleportHighlighter teleportHighlighter;
    private final PatchHighlighter patchHighlighter;
    private final ItemHighlighter itemHighlighter;
    private final WidgetHighlighter widgetHighlighter;
    private final GameObjectHighlighter gameObjectHighlighter;
    private final DecorativeObjectHighlighter decorativeObjectHighlighter;
    private final MenuHighlighter menuHighlighter;
    private final WidgetHelper widgetHelper;
    private final GameObjectHelper gameObjectHelper;
    private final ColorProvider colorProvider;
    
    // State tracking
    public int currentTeleportCase = 1;
    public boolean isAtDestination = false;
    
    @Inject
    public NavigationHandler(Client client, EasyFarmingPlugin plugin, EasyFarmingConfig config,
                            AreaCheck areaCheck, TeleportHighlighter teleportHighlighter,
                            PatchHighlighter patchHighlighter, ItemHighlighter itemHighlighter,
                            WidgetHighlighter widgetHighlighter, GameObjectHighlighter gameObjectHighlighter,
                            DecorativeObjectHighlighter decorativeObjectHighlighter, MenuHighlighter menuHighlighter,
                            WidgetHelper widgetHelper, GameObjectHelper gameObjectHelper,
                            ColorProvider colorProvider) {
        this.client = client;
        this.plugin = plugin;
        this.config = config;
        this.areaCheck = areaCheck;
        this.teleportHighlighter = teleportHighlighter;
        this.patchHighlighter = patchHighlighter;
        this.itemHighlighter = itemHighlighter;
        this.widgetHighlighter = widgetHighlighter;
        this.gameObjectHighlighter = gameObjectHighlighter;
        this.decorativeObjectHighlighter = decorativeObjectHighlighter;
        this.menuHighlighter = menuHighlighter;
        this.widgetHelper = widgetHelper;
        this.gameObjectHelper = gameObjectHelper;
        this.colorProvider = colorProvider;
    }
    
    /**
     * Checks if player is in their house (has Portal object).
     */
    public void inHouseCheck() {
        if (gameObjectHelper.getGameObjectIdsByName("Portal").contains(4525)) {
            this.currentTeleportCase = 2;
        }
    }
    
    /**
     * Handles navigation to player's house.
     */
    public void gettingToHouse(Graphics2D graphics) {
        EasyFarmingConfig.OptionEnumHouseTele teleportOption = config.enumConfigHouseTele();
        Color leftColor = colorProvider.getLeftClickColorWithAlpha();
        Color rightColor = colorProvider.getRightClickColorWithAlpha();
        
        switch (teleportOption) {
            case Law_air_earth_runes:
                InventoryTabChecker.TabState tabState;
                tabState = InventoryTabChecker.checkTab(client, VarClientID.TOPLEVEL_PANEL);
                switch (tabState) {
                    case INVENTORY:
                    case REST:
                        widgetHighlighter.interfaceOverlay(widgetHelper.getSpellbookTabGroupId(), widgetHelper.getSpellbookTabChildId()).render(graphics);
                        break;
                    case SPELLBOOK:
                        // Highlight the "Teleport to House" spell using correct child ID from widget inspector
                        widgetHighlighter.interfaceOverlay(InterfaceID.MAGIC_SPELLBOOK, 31).render(graphics);
                        inHouseCheck();
                        break;
                }
                break;
            case Teleport_To_House:
                inHouseCheck();
                itemHighlighter.itemHighlight(graphics, ItemID.POH_TABLET_TELEPORTTOHOUSE, leftColor);
                break;
            case Construction_cape:
                inHouseCheck();
                itemHighlighter.itemHighlight(graphics, ItemID.SKILLCAPE_CONSTRUCTION, rightColor);
                break;
            case Construction_cape_t:
                inHouseCheck();
                itemHighlighter.itemHighlight(graphics, ItemID.SKILLCAPE_CONSTRUCTION_TRIMMED, rightColor);
                break;
            case Max_cape:
                inHouseCheck();
                itemHighlighter.itemHighlight(graphics, ItemID.SKILLCAPE_MAX, rightColor);
                break;
        }
    }
    
    /**
     * Determines if player should proceed to farming phase based on location and teleport.
     */
    public boolean shouldProceedToFarming(Location location, Teleport teleport) {
        int currentRegionId = client.getLocalPlayer().getWorldLocation().getRegionID();
        WorldPoint targetLocation = teleport.getPoint();
        
        // Check if player is in the correct region
        boolean inCorrectRegion = (currentRegionId == teleport.getRegionId());
        
        // Check if player is near the target location (within 20 tiles)
        boolean nearTarget = areaCheck.isPlayerWithinArea(targetLocation, 20);
        
        // Check if player is very close to the farming patch (within 5 tiles)
        boolean nearPatch = areaCheck.isPlayerWithinArea(targetLocation, 5);
        
        // Scenario 1: Player is very close to the patch - proceed to farming regardless of teleport method
        if (nearPatch) {
            return true;
        }
        
        // Scenario 2: Player is in correct region and reasonably close - proceed to farming
        if (inCorrectRegion && nearTarget) {
            return true;
        }
        
        // Scenario 3: Player is in correct region but far from target - might have skipped teleport step
        if (inCorrectRegion && !nearTarget) {
            if (isNearAnyFarmingPatch(location.getName())) {
                return true;
            }
        }
        
        // Scenario 4: Player is in wrong region but very close to target - might have used different teleport
        if (!inCorrectRegion && nearTarget) {
            return true;
        }
        
        // Default: Continue with normal navigation
        return false;
    }
    
    /**
     * Checks if player is near any farming patches of the specified type.
     */
    private boolean isNearAnyFarmingPatch(String locationName) {
        // Define farming patch locations for each area
        switch (locationName) {
            case "Ardougne":
                return areaCheck.isPlayerWithinArea(new WorldPoint(2670, 3374, 0), 10);
            case "Catherby":
                return areaCheck.isPlayerWithinArea(new WorldPoint(2813, 3463, 0), 10);
            case "Falador":
                return areaCheck.isPlayerWithinArea(new WorldPoint(3058, 3307, 0), 10);
            case "Civitas illa Fortis":
                return areaCheck.isPlayerWithinArea(new WorldPoint(1586, 3099, 0), 10);
            case "Farming Guild":
                return areaCheck.isPlayerWithinArea(new WorldPoint(1238, 3726, 0), 15) ||
                       areaCheck.isPlayerWithinArea(new WorldPoint(1232, 3736, 0), 15) ||
                       areaCheck.isPlayerWithinArea(new WorldPoint(1243, 3759, 0), 15);
            case "Brimhaven":
                return areaCheck.isPlayerWithinArea(new WorldPoint(2764, 3212, 0), 10);
            case "Gnome Stronghold":
                return areaCheck.isPlayerWithinArea(new WorldPoint(2436, 3415, 0), 10) ||
                       areaCheck.isPlayerWithinArea(new WorldPoint(2475, 3446, 0), 10);
            case "Lumbridge":
                return areaCheck.isPlayerWithinArea(new WorldPoint(3193, 3231, 0), 10);
            case "Taverley":
                return areaCheck.isPlayerWithinArea(new WorldPoint(2936, 3438, 0), 10);
            case "Varrock":
                return areaCheck.isPlayerWithinArea(new WorldPoint(3229, 3459, 0), 10);
            default:
                return false;
        }
    }
    
    /**
     * Gets the appropriate highlighting based on current situation.
     */
    public void adaptiveHighlighting(Location location, Teleport teleport, Graphics2D graphics,
                                     boolean herbRun, boolean treeRun, boolean fruitTreeRun) {
        int currentRegionId = client.getLocalPlayer().getWorldLocation().getRegionID();
        WorldPoint targetLocation = teleport.getPoint();
        Color leftColor = colorProvider.getLeftClickColorWithAlpha();
        
        boolean inCorrectRegion = (currentRegionId == teleport.getRegionId());
        boolean nearTarget = areaCheck.isPlayerWithinArea(targetLocation, 20);
        boolean nearPatch = areaCheck.isPlayerWithinArea(targetLocation, 5);
        
        // If player is very close to patch, highlight the patch directly
        if (nearPatch) {
            patchHighlighter.highlightFarmingPatchesForLocation(location.getName(), graphics,
                    herbRun, treeRun, fruitTreeRun, leftColor, leftColor);
            return;
        }
        
        // If player is in correct region but not near target, they might be near a different patch
        if (inCorrectRegion && !nearTarget) {
            if (isNearAnyFarmingPatch(location.getName())) {
                patchHighlighter.highlightFarmingPatchesForLocation(location.getName(), graphics,
                        herbRun, treeRun, fruitTreeRun, leftColor, leftColor);
                return;
            }
        }
        
        // Default to normal teleport highlighting
        teleportHighlighter.highlightTeleportMethod(teleport, graphics);
    }
    
    /**
     * Handles navigation to a specific location.
     */
    public void gettingToLocation(Graphics2D graphics, Location location, boolean herbRun,
                                  boolean treeRun, boolean fruitTreeRun) {
        Teleport teleport = location.getSelectedTeleport();
        boolean locationEnabledBool = false;
        
        if (herbRun) {
            locationEnabledBool = plugin.getHerbLocationEnabled(location.getName());
        } else if (treeRun) {
            locationEnabledBool = plugin.getTreeLocationEnabled(location.getName());
        } else if (fruitTreeRun) {
            locationEnabledBool = plugin.getFruitTreeLocationEnabled(location.getName());
        }
        
        if (locationEnabledBool) {
            if (!isAtDestination) {
                int currentRegionId = client.getLocalPlayer().getWorldLocation().getRegionID();
                
                // Use adaptive detection to determine if we should proceed to farming
                if (shouldProceedToFarming(location, teleport)) {
                    this.currentTeleportCase = 1;
                    isAtDestination = true;
                    if (location.getFarmLimps()) {
                        // This will be handled by the calling code
                    }
                    plugin.addTextToInfoBox(teleport.getDescription());
                } else {
                    // Use adaptive highlighting based on current situation
                    adaptiveHighlighting(location, teleport, graphics, herbRun, treeRun, fruitTreeRun);
                    plugin.addTextToInfoBox(teleport.getDescription());
                    return;
                }
                
                // Handle different teleport categories
                switch (teleport.getCategory()) {
                    case ITEM:
                        handleItemTeleport(graphics, teleport, location, currentRegionId);
                        break;
                    case PORTAL_NEXUS:
                        handlePortalNexusTeleport(graphics, teleport, location, currentRegionId);
                        break;
                    case SPIRIT_TREE:
                        handleSpiritTreeTeleport(graphics, teleport, location, currentRegionId);
                        break;
                    case JEWELLERY_BOX:
                        handleJewelleryBoxTeleport(graphics, teleport, location, currentRegionId);
                        break;
                    case MOUNTED_XERICS:
                        handleMountedXericsTeleport(graphics, teleport, location, currentRegionId);
                        break;
                    case SPELLBOOK:
                        handleSpellbookTeleport(graphics, teleport, currentRegionId);
                        break;
                }
            }
        } else {
            // Location not enabled, skip to next
        }
    }
    
    private void handleItemTeleport(Graphics2D graphics, Teleport teleport, Location location, int currentRegionId) {
        Color leftColor = colorProvider.getLeftClickColorWithAlpha();
        Color rightColor = colorProvider.getRightClickColorWithAlpha();
        
        if (teleport.getInterfaceGroupId() != 0) {
            if (!widgetHelper.isInterfaceOpen(teleport.getInterfaceGroupId(), teleport.getInterfaceChildId())) {
                itemHighlighter.itemHighlight(graphics, teleport.getId(), rightColor);
                if (!teleport.getRightClickOption().equals("")) {
                    menuHighlighter.highlightRightClickOption(graphics, teleport.getRightClickOption());
                }
            } else {
                Widget widget = client.getWidget(teleport.getInterfaceGroupId(), teleport.getInterfaceChildId());
                widgetHighlighter.highlightDynamicComponent(graphics, widget, 1);
            }
            if (currentRegionId == teleport.getRegionId()) {
                this.currentTeleportCase = 1;
                isAtDestination = true;
                if (location.getFarmLimps()) {
                    // This will be handled by the calling code
                }
            }
        } else {
            if (!teleport.getRightClickOption().equals("")) {
                itemHighlighter.itemHighlight(graphics, teleport.getId(), rightColor);
                menuHighlighter.highlightRightClickOption(graphics, teleport.getRightClickOption());
            } else {
                if (plugin.getEasyFarmingOverlay().isTeleportCrystal(teleport.getId())) {
                    itemHighlighter.highlightTeleportCrystal(graphics);
                }
                if (plugin.getEasyFarmingOverlay().isSkillsNecklace(teleport.getId())) {
                    String index = location.getName();
                    List<Integer> skillsNecklaceIds = Constants.SKILLS_NECKLACE_IDS;
                    if (Objects.equals(index, "Ardougne")) {
                        for (int id : skillsNecklaceIds) {
                            itemHighlighter.itemHighlight(graphics, id, rightColor);
                        }
                        Widget widget = client.getWidget(Constants.INTERFACE_SPIRIT_TREE, Constants.INTERFACE_SPIRIT_TREE_CHILD);
                        if (widget != null && !widget.isHidden()) {
                            widgetHighlighter.highlightDynamicComponent(graphics, widget, 0);
                        }
                    }
                    if (Objects.equals(index, "Farming Guild")) {
                        for (int id : skillsNecklaceIds) {
                            itemHighlighter.itemHighlight(graphics, id, rightColor);
                        }
                        Widget widget = client.getWidget(Constants.INTERFACE_SPIRIT_TREE, Constants.INTERFACE_SPIRIT_TREE_CHILD);
                        if (widget != null && !widget.isHidden()) {
                            widgetHighlighter.highlightDynamicComponent(graphics, widget, 5);
                        }
                    }
                } else if (plugin.getEasyFarmingOverlay().isQuetzalWhistle(teleport.getId()) || 
                           plugin.getEasyFarmingOverlay().isRoyalSeedPod(teleport.getId()) ||
                           plugin.getEasyFarmingOverlay().isEctophial(teleport.getId())) {
                    itemHighlighter.itemHighlight(graphics, teleport.getId(), leftColor);
                } else {
                    itemHighlighter.itemHighlight(graphics, teleport.getId(), leftColor);
                }
            }
            if (currentRegionId == teleport.getRegionId()) {
                this.currentTeleportCase = 1;
                isAtDestination = true;
                if (location.getFarmLimps()) {
                    // This will be handled by the calling code
                }
            }
        }
    }
    
    private void handlePortalNexusTeleport(Graphics2D graphics, Teleport teleport, Location location, int currentRegionId) {
        Color leftColor = colorProvider.getLeftClickColorWithAlpha();
        
        switch (this.currentTeleportCase) {
            case 1:
                gettingToHouse(graphics);
                break;
            case 2:
                if (!widgetHelper.isInterfaceOpen(17, 0)) {
                    List<Integer> portalNexusIds = gameObjectHelper.getGameObjectIdsByName("Portal Nexus");
                    for (Integer objectId : portalNexusIds) {
                        gameObjectHighlighter.highlightGameObject(objectId, leftColor).render(graphics);
                    }
                } else {
                    Widget widget = client.getWidget(Constants.INTERFACE_PORTAL_NEXUS, Constants.INTERFACE_PORTAL_NEXUS_CHILD);
                    int index = widgetHelper.getChildIndexPortalNexus(location.getName());
                    widgetHighlighter.highlightDynamicComponent(graphics, widget, index);
                }
                if (currentRegionId == teleport.getRegionId()) {
                    this.currentTeleportCase = 1;
                    isAtDestination = true;
                    if (location.getFarmLimps()) {
                        // This will be handled by the calling code
                    }
                }
                break;
        }
    }
    
    private void handleSpiritTreeTeleport(Graphics2D graphics, Teleport teleport, Location location, int currentRegionId) {
        Color leftColor = colorProvider.getLeftClickColorWithAlpha();
        
        if (!widgetHelper.isInterfaceOpen(187, 3)) {
            List<Integer> spiritTreeIds = Constants.SPIRIT_TREE_IDS;
            for (Integer objectId : spiritTreeIds) {
                gameObjectHighlighter.highlightGameObject(objectId, leftColor).render(graphics);
            }
        } else {
            Widget widget = client.getWidget(Constants.INTERFACE_SPIRIT_TREE, Constants.INTERFACE_SPIRIT_TREE_CHILD);
            switch (location.getName()) {
                case "Gnome Stronghold":
                    widgetHighlighter.highlightDynamicComponent(graphics, widget, widgetHelper.getChildIndexSpiritTree("Gnome Stronghold"));
                    break;
                case "Tree Gnome Village":
                    widgetHighlighter.highlightDynamicComponent(graphics, widget, widgetHelper.getChildIndexSpiritTree("Tree Gnome Village"));
                    break;
                case "Falador":
                    widgetHighlighter.highlightDynamicComponent(graphics, widget, widgetHelper.getChildIndexSpiritTree("Port Sarim"));
                    break;
                case "Kourend":
                    widgetHighlighter.highlightDynamicComponent(graphics, widget, widgetHelper.getChildIndexSpiritTree("Hosidius"));
                    break;
            }
        }
        if (currentRegionId == teleport.getRegionId()) {
            this.currentTeleportCase = 1;
            isAtDestination = true;
            if (location.getFarmLimps()) {
                // This will be handled by the calling code
            }
        }
    }
    
    private void handleJewelleryBoxTeleport(Graphics2D graphics, Teleport teleport, Location location, int currentRegionId) {
        Color leftColor = colorProvider.getLeftClickColorWithAlpha();
        
        switch (this.currentTeleportCase) {
            case 1:
                gettingToHouse(graphics);
                break;
            case 2:
                List<Integer> jewelleryBoxIds = Constants.JEWELLERY_BOX_IDS;
                if (!widgetHelper.isInterfaceOpen(Constants.INTERFACE_JEWELLERY_BOX_OPEN, 0)) {
                    for (int id : jewelleryBoxIds) {
                        gameObjectHighlighter.highlightGameObject(id, leftColor).render(graphics);
                    }
                    gameObjectHighlighter.highlightGameObject(teleport.getId(), leftColor).render(graphics);
                } else {
                    Widget widget = client.getWidget(Constants.INTERFACE_JEWELLERY_BOX_OPEN, Constants.WIDGET_JEWELLERY_BOX_CHILD);
                    widgetHighlighter.highlightDynamicComponent(graphics, widget, 10);
                }
                if (currentRegionId == teleport.getRegionId()) {
                    this.currentTeleportCase = 1;
                    isAtDestination = true;
                    if (location.getFarmLimps()) {
                        // This will be handled by the calling code
                    }
                }
                break;
        }
    }
    
    private void handleMountedXericsTeleport(Graphics2D graphics, Teleport teleport, Location location, int currentRegionId) {
        switch (this.currentTeleportCase) {
            case 1:
                gettingToHouse(graphics);
                break;
            case 2:
                List<Integer> xericsTalismanIds = Constants.XERICS_TALISMAN_IDS;
                Color leftColor = colorProvider.getLeftClickColorWithAlpha();
                if (!widgetHelper.isInterfaceOpen(teleport.getInterfaceGroupId(), teleport.getInterfaceChildId())) {
                    for (int id : xericsTalismanIds) {
                        decorativeObjectHighlighter.highlightDecorativeObject(id, leftColor).render(graphics);
                    }
                } else {
                    Widget widget = client.getWidget(teleport.getInterfaceGroupId(), teleport.getInterfaceChildId());
                    widgetHighlighter.highlightDynamicComponent(graphics, widget, 1);
                    if (currentRegionId == teleport.getRegionId()) {
                        this.currentTeleportCase = 1;
                        isAtDestination = true;
                        if (location.getFarmLimps()) {
                            // This will be handled by the calling code
                        }
                    }
                }
                break;
        }
    }
    
    private void handleSpellbookTeleport(Graphics2D graphics, Teleport teleport, int currentRegionId) {
        InventoryTabChecker.TabState tabState;
        tabState = InventoryTabChecker.checkTab(client, VarClientID.TOPLEVEL_PANEL);
        switch (tabState) {
            case REST:
            case INVENTORY:
                widgetHighlighter.interfaceOverlay(widgetHelper.getSpellbookTabGroupId(), widgetHelper.getSpellbookTabChildId()).render(graphics);
                if (currentRegionId == teleport.getRegionId()) {
                    this.currentTeleportCase = 1;
                    isAtDestination = true;
                }
                break;
            case SPELLBOOK:
                widgetHighlighter.interfaceOverlay(teleport.getInterfaceGroupId(), teleport.getInterfaceChildId()).render(graphics);
                if (currentRegionId == teleport.getRegionId()) {
                    this.currentTeleportCase = 1;
                    isAtDestination = true;
                }
                break;
        }
    }
}


package com.easyfarming.overlays.handlers;

import com.easyfarming.*;
import com.easyfarming.overlays.highlighting.*;
import com.easyfarming.overlays.utils.ColorProvider;
import com.easyfarming.overlays.utils.PatchStateChecker;
import com.easyfarming.utils.Constants;
import net.runelite.api.Client;
import net.runelite.api.GameObject;
import net.runelite.api.ObjectComposition;
import net.runelite.api.gameval.ItemID;

import javax.inject.Inject;
import java.awt.*;
import java.util.List;

/**
 * Handles farming step logic for herb, flower, tree, and fruit tree patches.
 */
public class FarmingStepHandler {
    private final Client client;
    private final EasyFarmingPlugin plugin;
    private final EasyFarmingConfig config;
    private final AreaCheck areaCheck;
    private final PatchHighlighter patchHighlighter;
    private final ItemHighlighter itemHighlighter;
    private final CompostHighlighter compostHighlighter;
    private final FarmerHighlighter farmerHighlighter;
    private final PatchStateChecker patchStateChecker;
    private final ColorProvider colorProvider;
    private final GameObjectHighlighter gameObjectHighlighter;
    
    // State tracking
    public boolean herbPatchDone = false;
    public boolean flowerPatchDone = false;
    public boolean allotmentPatchDone = false;
    public boolean treePatchDone = false;
    public boolean fruitTreePatchDone = false;
    
    // Allotment patch tracking - which patch we're currently working on (0 = first patch, 1 = second patch)
    private final AllotmentPatchState allotmentPatchState = new AllotmentPatchState();
    private final EasyFarmingOverlay farmingHelperOverlay;
    
    @Inject
    public FarmingStepHandler(Client client, EasyFarmingPlugin plugin, EasyFarmingConfig config,
                              AreaCheck areaCheck, PatchHighlighter patchHighlighter,
                              ItemHighlighter itemHighlighter, CompostHighlighter compostHighlighter,
                              FarmerHighlighter farmerHighlighter, PatchStateChecker patchStateChecker,
                              ColorProvider colorProvider, EasyFarmingOverlay farmingHelperOverlay,
                              GameObjectHighlighter gameObjectHighlighter) {
        this.client = client;
        this.plugin = plugin;
        this.config = config;
        this.areaCheck = areaCheck;
        this.patchHighlighter = patchHighlighter;
        this.itemHighlighter = itemHighlighter;
        this.compostHighlighter = compostHighlighter;
        this.farmerHighlighter = farmerHighlighter;
        this.patchStateChecker = patchStateChecker;
        this.colorProvider = colorProvider;
        this.farmingHelperOverlay = farmingHelperOverlay;
        this.gameObjectHighlighter = gameObjectHighlighter;
    }
    
    /**
     * Handles herb patch farming steps.
     */
    public void herbSteps(Graphics2D graphics, Location.Teleport teleport) {
        int currentRegionId = client.getLocalPlayer().getWorldLocation().getRegionID();
        HerbPatchChecker.PlantState plantState = HerbPatchChecker.PlantState.UNKNOWN;
        Color leftColor = colorProvider.getLeftClickColorWithAlpha();
        Color useItemColor = colorProvider.getHighlightUseItemWithAlpha();
        
        // Get location name from region ID
        String locationName = getLocationNameFromRegionId(currentRegionId);
        
        // Get patch object ID for this location
        Integer patchObjectId = farmingHelperOverlay.getHerbPatchIdForLocation(locationName);
        
        int varbitId = -1;
        
        // Try to get varbit from object composition
        if (patchObjectId != null) {
            varbitId = getHerbPatchVarbitId(patchObjectId);
        }
        
        // Fallback: If object composition fails, use location-specific varbits
        if (varbitId == -1) {
            if (currentRegionId == Constants.REGION_FARMING_GUILD) {
                varbitId = Constants.VARBIT_HERB_PATCH_FARMING_GUILD;
            } else if (currentRegionId == Constants.REGION_HARMONY) {
                varbitId = Constants.VARBIT_HERB_PATCH_HARMONY;
            } else if (currentRegionId == Constants.REGION_TROLL_STRONGHOLD || currentRegionId == Constants.REGION_WEISS) {
                varbitId = Constants.VARBIT_HERB_PATCH_TROLL_WEISS;
            } else {
                varbitId = Constants.VARBIT_HERB_PATCH_STANDARD;
            }
        }
        
        // Check state for herb patch
        if (varbitId != -1) {
            plantState = HerbPatchChecker.checkHerbPatch(client, varbitId);
        }
        
        if (!areaCheck.isPlayerWithinArea(teleport.getPoint(), 15)) {
            // Should be replaced with a pathing system, pointing arrow or something else eventually
            patchHighlighter.highlightHerbPatches(graphics, leftColor);
        } else {
            switch (plantState) {
                case HARVESTABLE:
                    plugin.addTextToInfoBox("Harvest Herbs.");
                    patchHighlighter.highlightHerbPatches(graphics, leftColor);
                    break;
                case PLANT:
                    plugin.addTextToInfoBox("Use Herb seed on patch.");
                    patchHighlighter.highlightHerbPatches(graphics, useItemColor);
                    itemHighlighter.highlightHerbSeeds(graphics);
                    break;
                case DEAD:
                    plugin.addTextToInfoBox("Clear the dead herb patch.");
                    patchHighlighter.highlightHerbPatches(graphics, leftColor);
                    break;
                case DISEASED:
                    plugin.addTextToInfoBox("Use Plant cure on herb patch. Buy at GE or in farming guild/catherby, and store at Tool Leprechaun for easy access.");
                    patchHighlighter.highlightHerbPatches(graphics, leftColor);
                    itemHighlighter.itemHighlight(graphics, ItemID.PLANT_CURE, useItemColor);
                    break;
                case WEEDS:
                    plugin.addTextToInfoBox("Rake the herb patch.");
                    patchHighlighter.highlightHerbPatches(graphics, leftColor);
                    break;
                case GROWING:
                    boolean isComposted = patchStateChecker.patchIsComposted();
                    if (isComposted) {
                        herbPatchDone = true;
                        // Don't show anything - transition will happen on next frame
                        return;
                    }
                    if (!herbPatchDone) {
                        plugin.addTextToInfoBox("Use Compost on patch.");
                        compostHighlighter.highlightCompost(graphics, true, false, false, 1);
                    }
                    break;
                case UNKNOWN:
                    plugin.addTextToInfoBox("UNKNOWN state: Try to do something with the herb patch to change its state.");
                    break;
            }
        }
    }
    
    /**
     * Handles flower patch farming steps.
     */
    public void flowerSteps(Graphics2D graphics, boolean farmLimps) {
        if (farmLimps) {
            int currentRegionId = client.getLocalPlayer().getWorldLocation().getRegionID();
            FlowerPatchChecker.PlantState plantState = FlowerPatchChecker.PlantState.UNKNOWN;
            Color leftColor = colorProvider.getLeftClickColorWithAlpha();
            Color useItemColor = colorProvider.getHighlightUseItemWithAlpha();
            
            // Get location name from region ID
            String locationName = getLocationNameFromRegionId(currentRegionId);
            
            // Get patch object ID for this location
            Integer patchObjectId = farmingHelperOverlay.getFlowerPatchIdForLocation(locationName);
            
            int varbitId = -1;
            
            // Try to get varbit from object composition
            if (patchObjectId != null) {
                varbitId = getFlowerPatchVarbitId(patchObjectId);
            }
            
            // Fallback: If object composition fails, use location-specific varbits
            if (varbitId == -1) {
                if (currentRegionId == Constants.REGION_FARMING_GUILD) {
                    varbitId = Constants.VARBIT_FLOWER_PATCH_FARMING_GUILD;
                } else {
                    varbitId = Constants.VARBIT_FLOWER_PATCH_STANDARD;
                }
            }
            
            // Check state for flower patch
            if (varbitId != -1) {
                plantState = FlowerPatchChecker.checkFlowerPatch(client, varbitId);
            }
            switch (plantState) {
                case HARVESTABLE:
                    plugin.addTextToInfoBox("Harvest Limwurt root.");
                    patchHighlighter.highlightFlowerPatches(graphics, leftColor);
                    break;
                case DISEASED:
                    plugin.addTextToInfoBox("Cure the diseased Limwurt.");
                    patchHighlighter.highlightFlowerPatches(graphics, leftColor);
                    break;
                case WEEDS:
                    plugin.addTextToInfoBox("Rake the flower patch.");
                    patchHighlighter.highlightFlowerPatches(graphics, leftColor);
                    break;
                case DEAD:
                    plugin.addTextToInfoBox("Clear the dead flower patch.");
                    patchHighlighter.highlightFlowerPatches(graphics, leftColor);
                    break;
                case PLANT:
                    plugin.addTextToInfoBox("Use Limwurt seed on the patch.");
                    patchHighlighter.highlightFlowerPatches(graphics, useItemColor);
                    itemHighlighter.itemHighlight(graphics, ItemID.LIMPWURT_SEED, useItemColor);
                    break;
                case GROWING:
                    plugin.addTextToInfoBox("Use Compost on patch.");
                    compostHighlighter.highlightCompost(graphics, false, false, false, 2);
                    if (patchStateChecker.patchIsComposted()) {
                        flowerPatchDone = true;
                    }
                    break;
                case UNKNOWN:
                    // Handle unknown state if needed
                    break;
            }
        } else {
            flowerPatchDone = true;
        }
    }
    
    /**
     * Gets the location name from a region ID.
     * @param regionId The region ID
     * @return The location name, or "Unknown" if not found
     */
    private String getLocationNameFromRegionId(int regionId) {
        switch (regionId) {
            case Constants.REGION_ARDOUGNE:
            case Constants.REGION_ARDOUGNE_ALT:
                return "Ardougne";
            case Constants.REGION_CATHERBY:
                return "Catherby";
            case Constants.REGION_FALADOR:
                return "Falador";
            case Constants.REGION_FARMING_GUILD:
                return "Farming Guild";
            case Constants.REGION_KOUREND:
                return "Kourend";
            case Constants.REGION_MORYTANIA:
                return "Morytania";
            case Constants.REGION_CIVITAS:
                return "Civitas illa Fortis";
            case Constants.REGION_HARMONY:
                return "Harmony Island";
            case Constants.REGION_TROLL_STRONGHOLD:
                return "Troll Stronghold";
            case Constants.REGION_WEISS:
                return "Weiss";
            default:
                return "Unknown";
        }
    }
    
    /**
     * Gets the varbit ID for an allotment patch by checking the object composition.
     * @param objectId The object ID of the allotment patch
     * @return The varbit ID, or -1 if not found
     */
    private int getAllotmentPatchVarbitId(int objectId) {
        if (objectId == -1) {
            return -1;
        }
        ObjectComposition objectComposition = client.getObjectDefinition(objectId);
        if (objectComposition != null) {
            return objectComposition.getVarbitId();
        }
        return -1;
    }
    
    /**
     * Gets the varbit ID for a herb patch by checking the object composition.
     * @param objectId The object ID of the herb patch
     * @return The varbit ID, or -1 if not found
     */
    private int getHerbPatchVarbitId(Integer objectId) {
        if (objectId == null || objectId == -1) {
            return -1;
        }
        ObjectComposition objectComposition = client.getObjectDefinition(objectId);
        if (objectComposition != null) {
            return objectComposition.getVarbitId();
        }
        return -1;
    }
    
    /**
     * Gets the varbit ID for a flower patch by checking the object composition.
     * @param objectId The object ID of the flower patch
     * @return The varbit ID, or -1 if not found
     */
    private int getFlowerPatchVarbitId(Integer objectId) {
        if (objectId == null || objectId == -1) {
            return -1;
        }
        ObjectComposition objectComposition = client.getObjectDefinition(objectId);
        if (objectComposition != null) {
            return objectComposition.getVarbitId();
        }
        return -1;
    }
    
    /**
     * Gets the priority of a plant state for determining which patch to handle first.
     * Higher priority = handle first.
     */
    private int getStatePriority(AllotmentPatchChecker.PlantState state) {
        switch (state) {
            case HARVESTABLE: return 7;
            case DEAD: return 6;
            case DISEASED: return 5;
            case NEEDS_WATER: return 4;
            case WEEDS: return 3;
            case PLANT: return 2;
            case GROWING: return 1;
            case UNKNOWN: return 0;
            default: return 0;
        }
    }
    
    /**
     * Handles allotment patch farming steps.
     * Calls north patch handler first, then south patch handler when north is done.
     */
    public void allotmentSteps(Graphics2D graphics, Location.Teleport teleport) {
        // Handle north patch first
        if (allotmentPatchState.getCurrentIndex() == 0) {
            allotmentNorthSteps(graphics, teleport);
            // If north patch is done (GROWING + composted), move to south patch
            // Once we move to south patch, north patch is completely ignored for this run
            // Only transition if north patch is actually completed (GROWING + composted)
            if (allotmentPatchState.isPatchCompleted(0) && allotmentPatchState.isPatchComposted(0)) {
                allotmentPatchState.moveToNextPatch();
                // Don't process south patch in the same frame - let it happen on next frame
                return;
            }
        }
        
        // Handle south patch if north is done (and we're on index 1)
        // This block only executes when currentAllotmentPatchIndex == 1
        // Once we're here, we never go back to north patch
        if (allotmentPatchState.getCurrentIndex() == 1) {
            allotmentSouthSteps(graphics, teleport);
            // If south patch is done, mark all allotment patches as done
            if (allotmentPatchState.isPatchCompleted(1)) {
                this.allotmentPatchDone = true;
                // Reset for next location
                allotmentPatchState.reset();
            }
        }
    }
    
    /**
     * Handles north allotment patch farming steps.
     * Completely separate from south patch handling.
     * Once we move to south patch (index 1), this method should never be called.
     */
    private void allotmentNorthSteps(Graphics2D graphics, Location.Teleport teleport) {
        // Safety check: If we're not on north patch (index 0), return immediately
        // This ensures we never process north patch once we've moved forward
        if (allotmentPatchState.getCurrentIndex() != 0) {
            return;
        }
        
        int currentRegionId = client.getLocalPlayer().getWorldLocation().getRegionID();
        Color leftColor = colorProvider.getLeftClickColorWithAlpha();
        Color useItemColor = colorProvider.getHighlightUseItemWithAlpha();
        
        // Get location name from region ID
        String locationName = getLocationNameFromRegionId(currentRegionId);
        
        // Get patch object IDs for this location
        List<Integer> allotmentPatchIds = farmingHelperOverlay.getAllotmentPatchIdsForLocation(locationName);
        
        // If no patches found for this location, return
        if (allotmentPatchIds.isEmpty() || allotmentPatchIds.get(0) == null) {
            return;
        }
        
        int patchObjectId = allotmentPatchIds.get(0); // North patch (index 0)
        
        // Get varbit ID from object composition
        int varbitIdFromObject = getAllotmentPatchVarbitId(patchObjectId);
        int varbitId = varbitIdFromObject;
        
        // Fallback: If object composition fails, use location-specific varbits
        if (varbitId == -1) {
            if (locationName.equals("Catherby")) {
                varbitId = Constants.VARBIT_ALLOTMENT_PATCH_NORTH_A1;
            } else {
                varbitId = Constants.VARBIT_ALLOTMENT_PATCH_NORTH_A2;
            }
        }
        
        // Check state for north patch
        AllotmentPatchChecker.PlantState plantState = AllotmentPatchChecker.PlantState.UNKNOWN;
        
        if (varbitId != -1) {
            plantState = AllotmentPatchChecker.checkAllotmentPatch(client, varbitId);
        }

        // Check completion status for north patch
        // HARVESTABLE is NOT completed - user still needs to harvest
        // Only GROWING + composted is considered completed (nothing more to do)
        boolean completed = plantState == AllotmentPatchChecker.PlantState.GROWING && allotmentPatchState.isPatchComposted(0);
        allotmentPatchState.setPatchCompleted(0, completed);
        
        // Handle early returns in a single place
        if (plantState == AllotmentPatchChecker.PlantState.UNKNOWN) {
            int varbitValue = varbitId != -1 ? client.getVarbitValue(varbitId) : -1;
            plugin.addTextToInfoBox("Allotment patch state unknown - north patch");
            plugin.addDebugTextToInfoBox("[ALLOTMENT NORTH] Varbit=" + varbitId + " Value=" + varbitValue);
            return;
        }
        
        // If completed and not HARVESTABLE, return early (no need to show further instructions)
        // This prevents re-highlighting after other game actions
        if (completed && plantState != AllotmentPatchChecker.PlantState.HARVESTABLE) {
            return;
        }
        
        // Check if patch is visible in scene (more accurate than distance to teleport point)
        List<GameObject> patchObjects = gameObjectHighlighter.findGameObjectsByID(patchObjectId);
        boolean patchVisible = !patchObjects.isEmpty();
        
        // Handle north patch states
        if (!patchVisible) {
            plugin.addTextToInfoBox("Navigate to north patch.");
            patchHighlighter.highlightSpecificAllotmentPatch(graphics, patchObjectId, leftColor);
        } else {
            switch (plantState) {
                case HARVESTABLE:
                    plugin.addTextToInfoBox("Harvest Allotment (north patch).");
                    patchHighlighter.highlightSpecificAllotmentPatch(graphics, patchObjectId, leftColor);
                    break;
                case PLANT:
                    plugin.addTextToInfoBox("Use Allotment seed on north patch.");
                    patchHighlighter.highlightSpecificAllotmentPatch(graphics, patchObjectId, useItemColor);
                    itemHighlighter.highlightAllotmentSeeds(graphics);
                    break;
                case DEAD:
                    plugin.addTextToInfoBox("Clear the dead north patch.");
                    patchHighlighter.highlightSpecificAllotmentPatch(graphics, patchObjectId, leftColor);
                    break;
                case DISEASED:
                    plugin.addTextToInfoBox("Use Plant cure on north patch. Buy at GE or in farming guild/catherby, and store at Tool Leprechaun for easy access.");
                    patchHighlighter.highlightSpecificAllotmentPatch(graphics, patchObjectId, leftColor);
                    itemHighlighter.itemHighlight(graphics, ItemID.PLANT_CURE, useItemColor);
                    break;
                case NEEDS_WATER:
                    plugin.addTextToInfoBox("Water the north patch.");
                    patchHighlighter.highlightSpecificAllotmentPatch(graphics, patchObjectId, useItemColor);
                    for (int canId : Constants.WATERING_CAN_IDS) {
                        itemHighlighter.itemHighlight(graphics, canId, useItemColor);
                    }
                    break;
                case WEEDS:
                    plugin.addTextToInfoBox("Rake the north patch.");
                    patchHighlighter.highlightSpecificAllotmentPatch(graphics, patchObjectId, leftColor);
                    break;
                case GROWING:
                    // Check if compost was just applied (from chat message)
                    if (patchStateChecker.patchIsComposted()) {
                        // Mark as composted (persistent)
                        allotmentPatchState.markComposted(0);
                        return;
                    }
                    // Patch is GROWING but not composted yet - show compost instruction
                    plugin.addTextToInfoBox("Use Compost on north patch.");
                    patchHighlighter.highlightSpecificAllotmentPatch(graphics, patchObjectId, useItemColor);
                    Integer compostId = itemHighlighter.selectedCompostID();
                    if (compostId != null && itemHighlighter.isItemInInventory(compostId)) {
                        itemHighlighter.itemHighlight(graphics, compostId, useItemColor);
                    } else {
                        compostHighlighter.withdrawCompost(graphics);
                    }
                    break;
                case UNKNOWN:
                    int varbitValueNorth = varbitId != -1 ? client.getVarbitValue(varbitId) : -1;
                    plugin.addTextToInfoBox("UNKNOWN state: Try to do something with the north allotment patch to change its state.");
                    plugin.addDebugTextToInfoBox("[ALLOTMENT NORTH] Varbit=" + varbitId + " Value=" + varbitValueNorth);
                    break;
            }
        }
    }
    
    /**
     * Handles south allotment patch farming steps.
     * Completely separate from north patch handling - only deals with south patch (index 1).
     * North patch is completely ignored once we reach this point.
     */
    private void allotmentSouthSteps(Graphics2D graphics, Location.Teleport teleport) {
        // Safety check: If we're not on south patch (index 1), return immediately
        // This ensures we only process south patch when we're supposed to
        if (allotmentPatchState.getCurrentIndex() != 1) {
            return;
        }
        
        int currentRegionId = client.getLocalPlayer().getWorldLocation().getRegionID();
        Color leftColor = colorProvider.getLeftClickColorWithAlpha();
        Color useItemColor = colorProvider.getHighlightUseItemWithAlpha();
        
        // Get location name from region ID
        String locationName = getLocationNameFromRegionId(currentRegionId);
        
        // Get patch object IDs for this location
        List<Integer> allotmentPatchIds = farmingHelperOverlay.getAllotmentPatchIdsForLocation(locationName);
        
        // If no patches found or south patch doesn't exist, return
        if (allotmentPatchIds.size() < 2 || allotmentPatchIds.get(1) == null) {
            return;
        }
        
        int patchObjectId = allotmentPatchIds.get(1); // South patch (index 1)
        
        // Get varbit ID from object composition
        int varbitIdFromObject = getAllotmentPatchVarbitId(patchObjectId);
        int varbitId = varbitIdFromObject;
        
        // Fallback: If object composition fails, use location-specific varbits
        if (varbitId == -1) {
            if (locationName.equals("Catherby")) {
                varbitId = Constants.VARBIT_ALLOTMENT_PATCH_SOUTH_B1;
            } else {
                varbitId = Constants.VARBIT_ALLOTMENT_PATCH_SOUTH_B2;
            }
        }
        
        // Check state for south patch
        AllotmentPatchChecker.PlantState plantState = AllotmentPatchChecker.PlantState.UNKNOWN;
        
        if (varbitId != -1) {
            plantState = AllotmentPatchChecker.checkAllotmentPatch(client, varbitId);
        }

        // Check completion status for south patch
        // HARVESTABLE is NOT completed - user still needs to harvest
        // Only GROWING + composted is considered completed (nothing more to do)
        // Don't mark as completed if it's GROWING but not composted yet
        if (!allotmentPatchState.isPatchCompleted(1)) {
            if (plantState == AllotmentPatchChecker.PlantState.GROWING && allotmentPatchState.isPatchComposted(1)) {
                allotmentPatchState.setPatchCompleted(1, true);
            }
        }
        
        // If patch is GROWING and already composted, return early (no need to show compost instruction)
        // This prevents re-highlighting after other game actions
        if (plantState == AllotmentPatchChecker.PlantState.GROWING && allotmentPatchState.isPatchComposted(1)) {
            if (!allotmentPatchState.isPatchCompleted(1)) {
                allotmentPatchState.setPatchCompleted(1, true);
            }
            return; // Don't show compost instruction if already composted
        }
        
        // If patch is done (GROWING + composted) and not HARVESTABLE, return (transition handled by allotmentSteps)
        // Don't return early for HARVESTABLE - user still needs to harvest
        // Don't return early for GROWING if not composted - user still needs to compost
        if (allotmentPatchState.isPatchCompleted(1) && 
            allotmentPatchState.isPatchComposted(1) && 
            plantState != AllotmentPatchChecker.PlantState.HARVESTABLE &&
            plantState != AllotmentPatchChecker.PlantState.GROWING) {
            return;
        }
        
        // If state is unknown, show message and return
        if (plantState == AllotmentPatchChecker.PlantState.UNKNOWN) {
            int varbitValue = varbitId != -1 ? client.getVarbitValue(varbitId) : -1;
            plugin.addTextToInfoBox("Allotment patch state unknown - south patch");
            plugin.addDebugTextToInfoBox("[ALLOTMENT SOUTH] Varbit=" + varbitId + " Value=" + varbitValue);
            return;
        }
        
        // Check if patch is visible in scene (more accurate than distance to teleport point)
        List<GameObject> patchObjects = gameObjectHighlighter.findGameObjectsByID(patchObjectId);
        boolean patchVisible = !patchObjects.isEmpty();
        
        // Handle south patch states
        if (!patchVisible) {
            plugin.addTextToInfoBox("Navigate to south patch.");
            patchHighlighter.highlightSpecificAllotmentPatch(graphics, patchObjectId, leftColor);
        } else {
            switch (plantState) {
                case HARVESTABLE:
                    plugin.addTextToInfoBox("Harvest Allotment (south patch).");
                    patchHighlighter.highlightSpecificAllotmentPatch(graphics, patchObjectId, leftColor);
                    break;
                case PLANT:
                    plugin.addTextToInfoBox("Use Allotment seed on south patch.");
                    patchHighlighter.highlightSpecificAllotmentPatch(graphics, patchObjectId, useItemColor);
                    itemHighlighter.highlightAllotmentSeeds(graphics);
                    break;
                case DEAD:
                    plugin.addTextToInfoBox("Clear the dead south patch.");
                    patchHighlighter.highlightSpecificAllotmentPatch(graphics, patchObjectId, leftColor);
                    break;
                case DISEASED:
                    plugin.addTextToInfoBox("Use Plant cure on south patch. Buy at GE or in farming guild/catherby, and store at Tool Leprechaun for easy access.");
                    patchHighlighter.highlightSpecificAllotmentPatch(graphics, patchObjectId, leftColor);
                    itemHighlighter.itemHighlight(graphics, ItemID.PLANT_CURE, useItemColor);
                    break;
                case NEEDS_WATER:
                    plugin.addTextToInfoBox("Water the south patch.");
                    patchHighlighter.highlightSpecificAllotmentPatch(graphics, patchObjectId, useItemColor);
                    for (int canId : Constants.WATERING_CAN_IDS) {
                        itemHighlighter.itemHighlight(graphics, canId, useItemColor);
                    }
                    break;
                case WEEDS:
                    plugin.addTextToInfoBox("Rake the south patch.");
                    patchHighlighter.highlightSpecificAllotmentPatch(graphics, patchObjectId, leftColor);
                    break;
                case GROWING:
                    // This case should only be reached if the patch is GROWING and NOT already composted
                    // (the early return above should catch GROWING + composted cases)
                    // Check if compost was just applied (from chat message)
                    boolean isComposted = patchStateChecker.patchIsComposted();
                    if (isComposted) {
                        // Mark as composted (persistent)
                        allotmentPatchState.markComposted(1);
                        return;
                    }
                    // Safety check: If already composted (shouldn't reach here due to early return, but just in case)
                    if (allotmentPatchState.isPatchComposted(1)) {
                        // Patch is already composted, mark as completed and return
                        if (!allotmentPatchState.isPatchCompleted(1)) {
                            allotmentPatchState.setPatchCompleted(1, true);
                        }
                        return; // Don't show compost instruction if already composted
                    }
                    // Patch is GROWING but not composted yet - show compost instruction
                    plugin.addTextToInfoBox("Use Compost on south patch.");
                    patchHighlighter.highlightSpecificAllotmentPatch(graphics, patchObjectId, useItemColor);
                    Integer compostId = itemHighlighter.selectedCompostID();
                    if (compostId != null && itemHighlighter.isItemInInventory(compostId)) {
                        itemHighlighter.itemHighlight(graphics, compostId, useItemColor);
                    } else {
                        compostHighlighter.withdrawCompost(graphics);
                    }
                    break;
                case UNKNOWN:
                    int varbitValueSouth = varbitId != -1 ? client.getVarbitValue(varbitId) : -1;
                    plugin.addTextToInfoBox("UNKNOWN state: Try to do something with the south allotment patch to change its state.");
                    plugin.addDebugTextToInfoBox("[ALLOTMENT SOUTH] Varbit=" + varbitId + " Value=" + varbitValueSouth);
                    break;
            }
        }
    }
    
    /**
     * Handles tree patch farming steps.
     */
    public void treeSteps(Graphics2D graphics, Location.Teleport teleport) {
        int currentRegionId = client.getLocalPlayer().getWorldLocation().getRegionID();
        TreePatchChecker.PlantState plantState;
        Color leftColor = colorProvider.getLeftClickColorWithAlpha();
        Color useItemColor = colorProvider.getHighlightUseItemWithAlpha();
        
        // 4771 falador, gnome stronghold, lumbridge, Taverly, Varrock
        // 7905 farming guild
        if (currentRegionId == Constants.REGION_FARMING_GUILD) {
            plantState = TreePatchChecker.checkTreePatch(client, Constants.VARBIT_TREE_PATCH_FARMING_GUILD);
        } else {
            plantState = TreePatchChecker.checkTreePatch(client, Constants.VARBIT_TREE_PATCH_STANDARD);
        }
        
        if (!areaCheck.isPlayerWithinArea(teleport.getPoint(), 15)) {
            // Should be replaced with a pathing system, pointing arrow or something else eventually
            patchHighlighter.highlightTreePatches(graphics, leftColor);
        } else {
            switch (plantState) {
                case HEALTHY:
                    plugin.addTextToInfoBox("Check tree health.");
                    patchHighlighter.highlightTreePatches(graphics, leftColor);
                    break;
                case WEEDS:
                    plugin.addTextToInfoBox("Rake the tree patch.");
                    patchHighlighter.highlightTreePatches(graphics, leftColor);
                    break;
                case DEAD:
                    plugin.addTextToInfoBox("Clear the dead tree patch.");
                    patchHighlighter.highlightTreePatches(graphics, leftColor);
                    break;
                case PLANT:
                    plugin.addTextToInfoBox("Use Sapling on the patch.");
                    patchHighlighter.highlightTreePatches(graphics, useItemColor);
                    itemHighlighter.highlightTreeSapling(graphics);
                    break;
                case DISEASED:
                    plugin.addTextToInfoBox("Prune the tree patch.");                    
                    patchHighlighter.highlightTreePatches(graphics, useItemColor);
                    break;
                case REMOVE:
                    plugin.addTextToInfoBox("Pay to remove tree, or cut it down and clear the patch.");
                    farmerHighlighter.highlightTreeFarmers(graphics);
                    break;
                case UNKNOWN:
                    plugin.addTextToInfoBox("UNKNOWN state: Try to do something with the tree patch to change its state.");
                    break;
                case GROWING:
                    if (config.generalPayForProtection()) {
                        plugin.addTextToInfoBox("Pay to protect the patch.");
                        farmerHighlighter.highlightTreeFarmers(graphics);
                        if (patchStateChecker.patchIsProtected()) {
                            treePatchDone = true;
                        }
                    } else {
                        plugin.addTextToInfoBox("Use Compost on patch.");
                        compostHighlighter.highlightCompost(graphics, false, true, false, 1);
                        if (patchStateChecker.patchIsComposted()) {
                            treePatchDone = true;
                        }
                    }
                    break;
            }
        }
    }
    
    /**
     * Handles fruit tree patch farming steps.
     */
    public void fruitTreeSteps(Graphics2D graphics, Location.Teleport teleport) {
        int currentRegionId = client.getLocalPlayer().getWorldLocation().getRegionID();
        FruitTreePatchChecker.PlantState plantState;
        Color leftColor = colorProvider.getLeftClickColorWithAlpha();
        Color useItemColor = colorProvider.getHighlightUseItemWithAlpha();
        
        // 4771 brimhaven, catherby, Lletya, tree gnome village
        // 7909 farming guild
        // 4772 gnome stronghold
        if (currentRegionId == Constants.REGION_FARMING_GUILD) {
            plantState = FruitTreePatchChecker.checkFruitTreePatch(client, Constants.VARBIT_FRUIT_TREE_PATCH_FARMING_GUILD);
        } else if (currentRegionId == Constants.REGION_GNOME_STRONGHOLD || currentRegionId == Constants.REGION_GNOME_STRONGHOLD_ALT) {
            plantState = FruitTreePatchChecker.checkFruitTreePatch(client, Constants.VARBIT_FRUIT_TREE_PATCH_GNOME_STRONGHOLD);
        } else {
            plantState = FruitTreePatchChecker.checkFruitTreePatch(client, Constants.VARBIT_FRUIT_TREE_PATCH_STANDARD);
        }
        
        if (!areaCheck.isPlayerWithinArea(teleport.getPoint(), 15)) {
            // Should be replaced with a pathing system, point arrow or something else eventually
            patchHighlighter.highlightFruitTreePatches(graphics, leftColor);
        } else {
            switch (plantState) {
                case HEALTHY:
                    plugin.addTextToInfoBox("Check Fruit tree health.");
                    patchHighlighter.highlightFruitTreePatches(graphics, leftColor);
                    break;
                case WEEDS:
                    plugin.addTextToInfoBox("Rake the fruit tree patch.");
                    patchHighlighter.highlightFruitTreePatches(graphics, leftColor);
                    break;
                case DEAD:
                    plugin.addTextToInfoBox("Clear the dead fruit tree patch.");
                    patchHighlighter.highlightFruitTreePatches(graphics, leftColor);
                    break;
                case PLANT:
                    plugin.addTextToInfoBox("Use Sapling on the patch.");
                    patchHighlighter.highlightFruitTreePatches(graphics, useItemColor);
                    itemHighlighter.highlightFruitTreeSapling(graphics);
                    break;
                case DISEASED:
                    plugin.addTextToInfoBox("Prune the fruit tree patch.");
                    patchHighlighter.highlightFruitTreePatches(graphics, leftColor);
                    break;
                case REMOVE:
                    plugin.addTextToInfoBox("Pay to remove fruit tree, or cut it down and clear the patch.");
                    farmerHighlighter.highlightFruitTreeFarmers(graphics);
                    break;
                case UNKNOWN:
                    plugin.addTextToInfoBox("UNKNOWN state: Try to do something with the tree patch to change its state.");
                    break;
                case GROWING:
                    if (config.generalPayForProtection()) {
                        plugin.addTextToInfoBox("Pay to protect the patch.");
                        farmerHighlighter.highlightFruitTreeFarmers(graphics);
                        if (patchStateChecker.patchIsProtected()) {
                            fruitTreePatchDone = true;
                        }
                    } else {
                        plugin.addTextToInfoBox("Use Compost on patch.");
                        compostHighlighter.highlightCompost(graphics, false, false, true, 1);
                        if (patchStateChecker.patchIsComposted()) {
                            fruitTreePatchDone = true;
                        }
                    }
                    break;
            }
        }
    }
    
    /**
     * Encapsulates allotment patch state tracking.
     * Manages current patch index, completion status, and compost state for both patches.
     */
    private static class AllotmentPatchState {
        private int currentIndex = 0;
        private final boolean[] completed = new boolean[2]; // Track completion of each patch
        private final boolean[] composted = new boolean[2]; // Track compost state per patch independently
        
        /**
         * Gets the current patch index (0 = north patch, 1 = south patch).
         * @return The current patch index
         */
        public int getCurrentIndex() {
            return currentIndex;
        }
        
        /**
         * Checks if a patch at the given index is completed.
         * @param index The patch index (0 = north, 1 = south)
         * @return true if the patch is completed, false otherwise
         */
        public boolean isPatchCompleted(int index) {
            if (index < 0 || index >= completed.length) {
                throw new IllegalArgumentException("Invalid patch index: " + index);
            }
            return completed[index];
        }
        
        /**
         * Checks if a patch at the given index is composted.
         * @param index The patch index (0 = north, 1 = south)
         * @return true if the patch is composted, false otherwise
         */
        public boolean isPatchComposted(int index) {
            if (index < 0 || index >= composted.length) {
                throw new IllegalArgumentException("Invalid patch index: " + index);
            }
            return composted[index];
        }
        
        /**
         * Marks a patch as composted and completed.
         * @param index The patch index (0 = north, 1 = south)
         */
        public void markComposted(int index) {
            if (index < 0 || index >= composted.length) {
                throw new IllegalArgumentException("Invalid patch index: " + index);
            }
            composted[index] = true;
            completed[index] = true;
        }
        
        /**
         * Sets the completion status of a patch.
         * @param index The patch index (0 = north, 1 = south)
         * @param value The completion status to set
         */
        public void setPatchCompleted(int index, boolean value) {
            if (index < 0 || index >= completed.length) {
                throw new IllegalArgumentException("Invalid patch index: " + index);
            }
            completed[index] = value;
        }
        
        /**
         * Moves to the next patch (from north to south).
         * Resets the south patch completion status.
         */
        public void moveToNextPatch() {
            currentIndex = 1;
            completed[1] = false; // Reset for south patch check
        }
        
        /**
         * Resets all state to initial values.
         * Sets current index to 0 and clears all completion and compost flags.
         */
        public void reset() {
            currentIndex = 0;
            completed[0] = false;
            completed[1] = false;
            composted[0] = false;
            composted[1] = false;
        }
    }
}


package com.easyfarming.overlays.utils;

import com.easyfarming.EasyFarmingPlugin;

import javax.inject.Inject;
import java.util.regex.Pattern;

/**
 * Utility class for checking patch states (composted, protected, etc.).
 */
public class PatchStateChecker {
    private static final String REGEX_COMPOST1 = "You treat the (herb patch|flower patch|allotment|tree patch|fruit tree patch) with (compost|supercompost|ultracompost)\\.";
    private static final String REGEX_COMPOST2 = "This (herb patch|flower patch|allotment|tree patch|fruit tree patch) has already been treated with (compost|supercompost|ultracompost)\\.";
    private static final String REGEX_COMPOST3 = "You treat the patch with (compost|supercompost|ultracompost)\\.";
    private static final String REGEX_COMPOST4 = "This patch has already been treated with (compost|supercompost|ultracompost)\\.";
    private static final Pattern COMPOST_PATTERN = Pattern.compile(REGEX_COMPOST1 + "|" + REGEX_COMPOST2 + "|" + REGEX_COMPOST3 + "|" + REGEX_COMPOST4);
    
    private static final String STANDARD_RESPONSE = "You pay the gardener ([0-9A-Za-z\\ ]+) to protect the patch\\.";
    private static final String FALADOR_ELITE_RESPONSE = "The gardener protects your tree for you, free of charge, as a token of gratitude for completing the ([A-Za-z\\ ]+)\\.";
    private static final Pattern PROTECTED_PATTERN = Pattern.compile(STANDARD_RESPONSE + "|" + FALADOR_ELITE_RESPONSE);
    
    private final EasyFarmingPlugin plugin;
    
    @Inject
    public PatchStateChecker(EasyFarmingPlugin plugin) {
        this.plugin = plugin;
    }
    
    /**
     * Checks if a patch has been composted based on chat messages.
     */
    public boolean patchIsComposted() {
        String lastMessage = plugin.getLastMessage();
        if (lastMessage == null || lastMessage.isEmpty()) {
            return false;
        }
        
        return COMPOST_PATTERN.matcher(lastMessage).matches();
    }
    
    /**
     * Checks if a patch has been protected based on chat messages.
     */
    public boolean patchIsProtected() {
        String lastMessage = plugin.getLastMessage();
        if (lastMessage == null || lastMessage.isEmpty()) {
            return false;
        }
        
        return PROTECTED_PATTERN.matcher(lastMessage).matches();
    }
}


package com.easyfarming.overlays.utils;

import net.runelite.api.Client;
import net.runelite.api.GameObject;
import net.runelite.api.ObjectComposition;
import net.runelite.api.Tile;
import net.runelite.api.WorldView;
import com.easyfarming.utils.Constants;

import javax.inject.Inject;
import java.util.ArrayList;
import java.util.List;

/**
 * Utility class for finding game objects by name or ID.
 */
public class GameObjectHelper {
    private final Client client;
    
    @Inject
    public GameObjectHelper(Client client) {
        this.client = client;
    }
    
    /**
     * Gets game object IDs by name in the current scene.
     */
    public List<Integer> getGameObjectIdsByName(String name) {
        List<Integer> foundObjectIds = new ArrayList<>();
        WorldView top_wv = client.getTopLevelWorldView();
        Tile[][][] tiles = top_wv.getScene().getTiles();
        
        for (int x = 0; x < Constants.SCENE_SIZE; x++) {
            for (int y = 0; y < Constants.SCENE_SIZE; y++) {
                Tile tile = tiles[top_wv.getPlane()][x][y];
                if (tile == null) {
                    continue;
                }
                
                for (GameObject gameObject : tile.getGameObjects()) {
                    if (gameObject != null) {
                        ObjectComposition objectComposition = client.getObjectDefinition(gameObject.getId());
                        if (objectComposition != null && objectComposition.getName().equals(name)) {
                            foundObjectIds.add(gameObject.getId());
                        }
                    }
                }
            }
        }
        
        return foundObjectIds;
    }
}


package com.easyfarming.overlays.utils;

import com.easyfarming.utils.Constants;
import net.runelite.api.Client;
import net.runelite.api.widgets.Widget;

import javax.inject.Inject;

/**
 * Utility class for widget-related operations.
 */
public class WidgetHelper {
    private final Client client;
    
    @Inject
    public WidgetHelper(Client client) {
        this.client = client;
    }
    
    /**
     * Gets the child index of a widget by searching for text after a colon.
     */
    public int getChildIndex(String searchText, Widget parentWidget) {
        if (parentWidget == null) {
            return -1;
        }
        
        Widget[] children = parentWidget.getChildren();
        
        if (children == null) {
            return -1;
        }
        
        for (int index = 0; index < children.length; index++) {
            Widget child = children[index];
            String text = child.getText();
            
            if (text != null) {
                int colonIndex = text.indexOf(':');
                
                if (colonIndex != -1 && colonIndex + 1 < text.length()) {
                    String textAfterColon = text.substring(colonIndex + 1).trim();
                    
                    if (textAfterColon.equals(searchText)) {
                        return index;
                    }
                }
            }
        }
        
        return -1;
    }
    
    /**
     * Gets the child index for Portal Nexus widget.
     */
    public int getChildIndexPortalNexus(String searchText) {
        return getChildIndex(
            searchText,
            client.getWidget(Constants.WIDGET_PORTAL_NEXUS_PARENT, Constants.WIDGET_PORTAL_NEXUS_CHILD)
        );
    }
    
    /**
     * Gets the child index for Spirit Tree widget.
     */
    public int getChildIndexSpiritTree(String searchText) {
        return getChildIndex(
            searchText,
            client.getWidget(Constants.INTERFACE_SPIRIT_TREE, Constants.INTERFACE_SPIRIT_TREE_CHILD)
        );
    }
    
    /**
     * Checks if an interface is open.
     */
    public boolean isInterfaceOpen(int groupId, int childId) {
        Widget widget = client.getWidget(groupId, childId);
        return widget != null && !widget.isHidden();
    }
    
    /**
     * Dynamically detects the correct spellbook tab interface ID based on the current client mode.
     * @return The child ID for the magic spellbook tab, or -1 if not found
     */
    public int getSpellbookTabChildId() {
        if (isInterfaceOpen(161, 65)) {
            return 65;
        }
        if (isInterfaceOpen(164, 58)) {
            return 58;
        }
        if (isInterfaceOpen(161, 58)) {
            return 58;
        }
        if (isInterfaceOpen(164, 65)) {
            return 65;
        }
        return 65;
    }
    
    /**
     * Gets the correct group ID for the spellbook tab based on the current client mode.
     * @return The group ID for the spellbook tab
     */
    public int getSpellbookTabGroupId() {
        if (isInterfaceOpen(161, 65)) {
            return 161;
        }
        if (isInterfaceOpen(164, 58)) {
            return 164;
        }
        if (isInterfaceOpen(161, 58)) {
            return 161;
        }
        if (isInterfaceOpen(164, 65)) {
            return 164;
        }
        return 161;
    }
}


package com.easyfarming.overlays.utils;

import com.easyfarming.EasyFarmingConfig;
import java.awt.Color;

/**
 * Provides color computation from config values.
 * Colors are computed dynamically to reflect config changes.
 */
public class ColorProvider {
    private final EasyFarmingConfig config;
    
    public ColorProvider(EasyFarmingConfig config) {
        this.config = config;
    }
    
    /**
     * Gets the left-click color with alpha applied.
     */
    public Color getLeftClickColorWithAlpha() {
        return new Color(
            config.highlightLeftClickColor().getRed(),
            config.highlightLeftClickColor().getGreen(),
            config.highlightLeftClickColor().getBlue(),
            config.highlightAlpha()
        );
    }
    
    /**
     * Gets the right-click color with alpha applied.
     */
    public Color getRightClickColorWithAlpha() {
        return new Color(
            config.highlightRightClickColor().getRed(),
            config.highlightRightClickColor().getGreen(),
            config.highlightRightClickColor().getBlue(),
            config.highlightAlpha()
        );
    }
    
    /**
     * Gets the use-item color with alpha applied.
     */
    public Color getHighlightUseItemWithAlpha() {
        return new Color(
            config.highlightUseItemColor().getRed(),
            config.highlightUseItemColor().getGreen(),
            config.highlightUseItemColor().getBlue(),
            config.highlightAlpha()
        );
    }
}


package com.easyfarming.overlays.highlighting;

import com.easyfarming.overlays.utils.ColorProvider;
import net.runelite.api.Client;
import net.runelite.api.Menu;
import net.runelite.api.MenuEntry;
import net.runelite.client.util.ColorUtil;

import javax.inject.Inject;
import java.awt.*;

/**
 * Handles highlighting of menu entries (right-click options).
 */
public class MenuHighlighter {
    private final Client client;
    private final ColorProvider colorProvider;
    
    @Inject
    public MenuHighlighter(Client client, ColorProvider colorProvider) {
        this.client = client;
        this.colorProvider = colorProvider;
    }
    
    /**
     * Highlights a right-click menu option.
     */
    public void highlightRightClickOption(Graphics2D graphics, String option) {
        // Skip if option is null or empty to avoid matching all menu entries
        if (option == null || option.trim().isEmpty()) {
            return;
        }
        
        Menu menu = client.getMenu();
        if (menu == null) {
            return;
        }
        
        MenuEntry[] menuEntries = menu.getMenuEntries();
        if (menuEntries == null) {
            return;
        }
        
        Color color = colorProvider.getRightClickColorWithAlpha();
        
        for (int i = 0; i < menuEntries.length; i++) {
            MenuEntry entry = menuEntries[i];
            if (entry == null) {
                continue;
            }
            
            String optionText = entry.getOption();
            String target = entry.getTarget();
            
            // Check if option matches exactly or contains the search text
            // Also check target in case the option is formatted differently
            boolean matches = false;
            if (optionText != null) {
                // Exact match
                if (optionText.equalsIgnoreCase(option)) {
                    matches = true;
                }
                // Check if option starts with the search text (e.g., "Rub > Skills necklace")
                else if (optionText.toLowerCase().startsWith(option.toLowerCase() + " >") ||
                         optionText.toLowerCase().startsWith(option.toLowerCase() + " ")) {
                    matches = true;
                }
            }
            
            // Also check target text
            if (!matches && target != null) {
                if (target.equalsIgnoreCase(option) || 
                    target.toLowerCase().contains(option.toLowerCase())) {
                    matches = true;
                }
            }
            
            if (matches && optionText != null) {
                // Only highlight if not already highlighted
                if (!optionText.startsWith(">>>")) {
                    String highlightedText = ColorUtil.prependColorTag(">>> " + optionText, color);
                    entry.setOption(highlightedText);
                    menu.setMenuEntries(menuEntries);
                }
                break;
            }
        }
    }
}


package com.easyfarming.overlays.highlighting;

import com.easyfarming.EasyFarmingConfig;
import com.easyfarming.overlays.utils.ColorProvider;
import com.easyfarming.overlays.utils.PatchStateChecker;
import com.easyfarming.utils.Constants;
import net.runelite.api.Client;
import net.runelite.api.gameval.ItemID;
import net.runelite.api.widgets.Widget;

import javax.inject.Inject;
import java.awt.*;

/**
 * Handles highlighting of compost and compost withdrawal from Tool Leprechaun.
 */
public class CompostHighlighter {
    private final Client client;
    private final EasyFarmingConfig config;
    private final ItemHighlighter itemHighlighter;
    private final PatchHighlighter patchHighlighter;
    private final NPCHighlighter npcHighlighter;
    private final WidgetHighlighter widgetHighlighter;
    private final PatchStateChecker patchStateChecker;
    private final ColorProvider colorProvider;
    
    @Inject
    public CompostHighlighter(Client client, EasyFarmingConfig config, 
                             ItemHighlighter itemHighlighter, PatchHighlighter patchHighlighter,
                             NPCHighlighter npcHighlighter, WidgetHighlighter widgetHighlighter,
                             PatchStateChecker patchStateChecker, ColorProvider colorProvider) {
        this.client = client;
        this.config = config;
        this.itemHighlighter = itemHighlighter;
        this.patchHighlighter = patchHighlighter;
        this.npcHighlighter = npcHighlighter;
        this.widgetHighlighter = widgetHighlighter;
        this.patchStateChecker = patchStateChecker;
        this.colorProvider = colorProvider;
    }
    
    /**
     * Highlights compost in inventory and patches, or withdraws from Tool Leprechaun if not in inventory.
     */
    public void highlightCompost(Graphics2D graphics, boolean herbRun, boolean treeRun, 
                                boolean fruitTreeRun, int subCase) {
        Integer compostId = itemHighlighter.selectedCompostID();
        Color color = colorProvider.getHighlightUseItemWithAlpha();
        
        if (itemHighlighter.isItemInInventory(compostId)) {
            if (herbRun) {
                if (subCase == 1) {
                    patchHighlighter.highlightHerbPatches(graphics, color);
                } else if (subCase == 2) {
                    patchHighlighter.highlightFlowerPatches(graphics, color);
                }
            }
            
            if (treeRun) {
                patchHighlighter.highlightTreePatches(graphics, color);
            }
            
            if (fruitTreeRun) {
                patchHighlighter.highlightFruitTreePatches(graphics, color);
            }
            
            itemHighlighter.itemHighlight(graphics, compostId, color);
        } else {
            withdrawCompost(graphics);
        }
    }
    
    /**
     * Highlights compost without subCase parameter (for backward compatibility).
     */
    public void highlightCompost(Graphics2D graphics, boolean herbRun, boolean treeRun, boolean fruitTreeRun) {
        highlightCompost(graphics, herbRun, treeRun, fruitTreeRun, 1);
    }
    
    /**
     * Highlights the Tool Leprechaun and interface for withdrawing compost.
     */
    public void withdrawCompost(Graphics2D graphics) {
        if (!isInterfaceOpen(Constants.INTERFACE_TOOL_LEPRECHAUN, 0)) {
            npcHighlighter.highlightNpc(graphics, "Tool Leprechaun");
        } else {
            Integer compostId = itemHighlighter.selectedCompostID();
            if (compostId == ItemID.BUCKET_COMPOST) {
                widgetHighlighter.interfaceOverlay(Constants.INTERFACE_TOOL_LEPRECHAUN, 17).render(graphics);
            } else if (compostId == ItemID.BUCKET_SUPERCOMPOST) {
                widgetHighlighter.interfaceOverlay(Constants.INTERFACE_TOOL_LEPRECHAUN, 18).render(graphics);
            } else if (compostId == ItemID.BUCKET_ULTRACOMPOST) {
                widgetHighlighter.interfaceOverlay(Constants.INTERFACE_TOOL_LEPRECHAUN, 19).render(graphics);
            } else if (compostId == ItemID.BOTTOMLESS_COMPOST_BUCKET) {
                widgetHighlighter.interfaceOverlay(Constants.INTERFACE_TOOL_LEPRECHAUN, 15).render(graphics);
            }
        }
    }
    
    private boolean isInterfaceOpen(int groupId, int childId) {
        Widget widget = client.getWidget(groupId, childId);
        return widget != null && !widget.isHidden();
    }
}


package com.easyfarming.overlays.highlighting;

import com.easyfarming.EasyFarmingOverlay;
import com.easyfarming.EasyFarmingPlugin;
import com.easyfarming.InventoryTabChecker;
import com.easyfarming.core.Teleport;
import com.easyfarming.overlays.utils.ColorProvider;
import com.easyfarming.overlays.utils.GameObjectHelper;
import com.easyfarming.overlays.utils.WidgetHelper;
import com.easyfarming.utils.Constants;
import net.runelite.api.Client;
import net.runelite.api.gameval.VarClientID;
import net.runelite.api.widgets.Widget;

import javax.inject.Inject;
import java.awt.*;
import java.util.List;

/**
 * Handles highlighting of teleport methods (items, spellbook, portal nexus, spirit tree, etc.).
 */
public class TeleportHighlighter {
    private final Client client;
    private final EasyFarmingPlugin plugin;
    private final EasyFarmingOverlay easyFarmingOverlay;
    private final ItemHighlighter itemHighlighter;
    private final WidgetHighlighter widgetHighlighter;
    private final GameObjectHighlighter gameObjectHighlighter;
    private final WidgetHelper widgetHelper;
    private final GameObjectHelper gameObjectHelper;
    private final ColorProvider colorProvider;
    
    @Inject
    public TeleportHighlighter(Client client, EasyFarmingPlugin plugin, EasyFarmingOverlay easyFarmingOverlay,
                               ItemHighlighter itemHighlighter, WidgetHighlighter widgetHighlighter,
                               GameObjectHighlighter gameObjectHighlighter, WidgetHelper widgetHelper,
                               GameObjectHelper gameObjectHelper, ColorProvider colorProvider) {
        this.client = client;
        this.plugin = plugin;
        this.easyFarmingOverlay = easyFarmingOverlay;
        this.itemHighlighter = itemHighlighter;
        this.widgetHighlighter = widgetHighlighter;
        this.gameObjectHighlighter = gameObjectHighlighter;
        this.widgetHelper = widgetHelper;
        this.gameObjectHelper = gameObjectHelper;
        this.colorProvider = colorProvider;
    }
    
    /**
     * Highlights the appropriate teleport method based on category.
     */
    public void highlightTeleportMethod(Teleport teleport, Graphics2D graphics) {
        Color leftColor = colorProvider.getLeftClickColorWithAlpha();
        Color rightColor = colorProvider.getRightClickColorWithAlpha();
        
        switch (teleport.getCategory()) {
            case ITEM:
                // Check if it's a Quetzal whistle, Royal seed pod, or Ectophial (left-click teleport)
                if (easyFarmingOverlay.isQuetzalWhistle(teleport.getId()) || 
                    easyFarmingOverlay.isRoyalSeedPod(teleport.getId()) ||
                    easyFarmingOverlay.isEctophial(teleport.getId())) {
                    itemHighlighter.itemHighlight(graphics, teleport.getId(), leftColor);
                } else {
                    itemHighlighter.itemHighlight(graphics, teleport.getId(), rightColor);
                    if (!teleport.getRightClickOption().equals("")) {
                        // MenuHighlighter would be needed here, but we'll handle it in the calling code
                    }
                }
                break;
            case SPELLBOOK:
                InventoryTabChecker.TabState tabState = InventoryTabChecker.checkTab(client, VarClientID.TOPLEVEL_PANEL);
                if (tabState == InventoryTabChecker.TabState.SPELLBOOK) {
                    widgetHighlighter.interfaceOverlay(teleport.getInterfaceGroupId(), teleport.getInterfaceChildId()).render(graphics);
                } else {
                    widgetHighlighter.interfaceOverlay(widgetHelper.getSpellbookTabGroupId(), widgetHelper.getSpellbookTabChildId()).render(graphics);
                }
                break;
            case PORTAL_NEXUS:
                if (!widgetHelper.isInterfaceOpen(17, 0)) {
                    List<Integer> portalNexusIds = gameObjectHelper.getGameObjectIdsByName("Portal Nexus");
                    for (Integer objectId : portalNexusIds) {
                        gameObjectHighlighter.highlightGameObject(objectId, leftColor).render(graphics);
                    }
                } else {
                    Widget widget = client.getWidget(Constants.INTERFACE_PORTAL_NEXUS, Constants.INTERFACE_PORTAL_NEXUS_CHILD);
                    int index = widgetHelper.getChildIndexPortalNexus(teleport.getPoint().toString());
                    widgetHighlighter.highlightDynamicComponent(graphics, widget, index);
                }
                break;
            case SPIRIT_TREE:
                if (!widgetHelper.isInterfaceOpen(187, 3)) {
                    List<Integer> spiritTreeIds = Constants.SPIRIT_TREE_IDS;
                    for (Integer objectId : spiritTreeIds) {
                        gameObjectHighlighter.highlightGameObject(objectId, leftColor).render(graphics);
                    }
                } else {
                    Widget widget = client.getWidget(Constants.INTERFACE_SPIRIT_TREE, Constants.INTERFACE_SPIRIT_TREE_CHILD);
                    int index = widgetHelper.getChildIndexSpiritTree(teleport.getPoint().toString());
                    widgetHighlighter.highlightDynamicComponent(graphics, widget, index);
                }
                break;
            case JEWELLERY_BOX:
                if (!widgetHelper.isInterfaceOpen(Constants.INTERFACE_JEWELLERY_BOX, 0)) {
                    List<Integer> jewelleryBoxIds = gameObjectHelper.getGameObjectIdsByName("Jewellery Box");
                    for (Integer objectId : jewelleryBoxIds) {
                        gameObjectHighlighter.highlightGameObject(objectId, leftColor).render(graphics);
                    }
                } else {
                    Widget widget = client.getWidget(Constants.INTERFACE_JEWELLERY_BOX, 0);
                    widgetHighlighter.highlightDynamicComponent(graphics, widget, 0);
                }
                break;
            case MOUNTED_XERICS:
                // Mounted Xeric's talisman handling is done in NavigationHandler
                break;
        }
    }
}


package com.easyfarming.overlays.highlighting;

import com.easyfarming.utils.Constants;
import net.runelite.api.Client;
import net.runelite.api.widgets.Widget;

import javax.inject.Inject;
import java.awt.*;
import java.util.Arrays;
import java.util.List;

/**
 * Handles highlighting of farmers for protection payments.
 */
public class FarmerHighlighter {
    private final Client client;
    private final NPCHighlighter npcHighlighter;
    private final WidgetHighlighter widgetHighlighter;
    
    @Inject
    public FarmerHighlighter(Client client, NPCHighlighter npcHighlighter, WidgetHighlighter widgetHighlighter) {
        this.client = client;
        this.npcHighlighter = npcHighlighter;
        this.widgetHighlighter = widgetHighlighter;
    }
    
    /**
     * Highlights farmers by name and their interface if open.
     */
    public void highlightFarmers(Graphics2D graphics, List<String> farmers) {
        if (!isInterfaceOpen(Constants.INTERFACE_FARMER, 1)) {
            for (String farmer : farmers) {
                npcHighlighter.highlightNpc(graphics, farmer);
            }
        } else {
            Widget widget = client.getWidget(Constants.INTERFACE_FARMER, 1);
            widgetHighlighter.highlightDynamicComponent(graphics, widget, 1);
        }
    }
    
    /**
     * Highlights tree farmers.
     */
    public void highlightTreeFarmers(Graphics2D graphics) {
        highlightFarmers(graphics, Arrays.asList(
            "Alain",         // Taverly
            "Fayeth",        // Lumbridge
            "Heskel",        // Falador
            "Prissy Scilla", // Gnome Stronghold
            "Rosie",         // Farming Guild
            "Treznor"        // Varrock
        ));
    }
    
    /**
     * Highlights fruit tree farmers.
     */
    public void highlightFruitTreeFarmers(Graphics2D graphics) {
        highlightFarmers(graphics, Arrays.asList(
            "Bolongo", // Gnome Stronghold
            "Ellena",  // Catherby
            "Garth",   // Brimhaven
            "Gileth",  // Tree Gnome Village
            "Liliwen", // Lletya
            "Nikkie"   // Farming Guild
        ));
    }
    
    private boolean isInterfaceOpen(int groupId, int childId) {
        Widget widget = client.getWidget(groupId, childId);
        return widget != null && !widget.isHidden();
    }
}


package com.easyfarming.overlays.highlighting;

import com.easyfarming.EasyFarmingPlugin;
import net.runelite.api.Client;
import net.runelite.api.GameObject;
import net.runelite.api.Tile;
import net.runelite.api.WorldView;
import net.runelite.client.ui.overlay.Overlay;
import com.easyfarming.utils.Constants;

import javax.inject.Inject;
import java.awt.*;
import java.util.ArrayList;
import java.util.List;

/**
 * Handles highlighting of game objects in the world.
 */
public class GameObjectHighlighter {
    private final Client client;
    private final EasyFarmingPlugin plugin;
    
    @Inject
    public GameObjectHighlighter(Client client, EasyFarmingPlugin plugin) {
        this.client = client;
        this.plugin = plugin;
    }
    
    /**
     * Finds all game objects with the specified ID in the current scene.
     */
    public List<GameObject> findGameObjectsByID(int objectID) {
        List<GameObject> gameObjects = new ArrayList<>();
        for (int x = 0; x < Constants.SCENE_SIZE; x++) {
            for (int y = 0; y < Constants.SCENE_SIZE; y++) {
                WorldView top_wv = client.getTopLevelWorldView();
                Tile tile = top_wv.getScene().getTiles()[top_wv.getPlane()][x][y];
                if (tile == null) {
                    continue;
                }
                
                for (GameObject gameObject : tile.getGameObjects()) {
                    if (gameObject != null && gameObject.getId() == objectID) {
                        gameObjects.add(gameObject);
                    }
                }
            }
        }
        return gameObjects;
    }
    
    /**
     * Draws the clickbox for a game object.
     */
    public void drawGameObjectClickbox(Graphics2D graphics, GameObject gameObject, Color color) {
        Shape objectClickbox = gameObject.getClickbox();
        if (objectClickbox != null) {
            graphics.setColor(color);
            graphics.draw(objectClickbox);
            graphics.setColor(new Color(color.getRed(), color.getGreen(), color.getBlue(), color.getAlpha() / 5));
            graphics.fill(objectClickbox);
        }
    }
    
    /**
     * Creates an overlay that highlights a game object by ID.
     */
    public Overlay highlightGameObject(int objectId, Color color) {
        return new Overlay() {
            @Override
            public Dimension render(Graphics2D graphics) {
                Client client = plugin.getClient();
                if (client != null) {
                    List<GameObject> gameObjects = findGameObjectsByID(objectId);
                    for (GameObject gameObject : gameObjects) {
                        drawGameObjectClickbox(graphics, gameObject, color);
                    }
                }
                return null;
            }
        };
    }
}


package com.easyfarming.overlays.highlighting;

import com.easyfarming.EasyFarmingPlugin;
import com.easyfarming.overlays.utils.ColorProvider;
import net.runelite.api.Client;
import net.runelite.api.DecorativeObject;
import net.runelite.api.Tile;
import net.runelite.api.WorldView;
import net.runelite.client.ui.overlay.Overlay;

import javax.inject.Inject;
import java.awt.*;
import java.util.ArrayList;
import java.util.List;

/**
 * Handles highlighting of decorative objects in the world.
 */
public class DecorativeObjectHighlighter {
    private final Client client;
    private final EasyFarmingPlugin plugin;
    private final ColorProvider colorProvider;
    
    @Inject
    public DecorativeObjectHighlighter(Client client, EasyFarmingPlugin plugin, ColorProvider colorProvider) {
        this.client = client;
        this.plugin = plugin;
        this.colorProvider = colorProvider;
    }
    
    /**
     * Finds all decorative objects with the specified ID in the current scene.
     */
    public List<DecorativeObject> findDecorativeObjectsByID(int objectId) {
        Client client = this.client;
        List<DecorativeObject> foundDecorativeObjects = new ArrayList<>();
        
        if (client != null) {
            WorldView top_wv = client.getTopLevelWorldView();
            Tile[][][] tiles = top_wv.getScene().getTiles();
            for (int plane = 0; plane < tiles.length; plane++) {
                for (int x = 0; x < tiles[plane].length; x++) {
                    for (int y = 0; y < tiles[plane][x].length; y++) {
                        Tile tile = tiles[plane][x][y];
                        if (tile != null) {
                            DecorativeObject decorativeObject = tile.getDecorativeObject();
                            if (decorativeObject != null && decorativeObject.getId() == objectId) {
                                foundDecorativeObjects.add(decorativeObject);
                            }
                        }
                    }
                }
            }
        }
        
        return foundDecorativeObjects;
    }
    
    /**
     * Draws the clickbox for a decorative object.
     */
    public void drawDecorativeObjectClickbox(Graphics2D graphics, DecorativeObject decorativeObject, Color color) {
        Shape clickbox = decorativeObject.getClickbox();
        if (clickbox != null) {
            graphics.setColor(color);
            graphics.draw(clickbox);
            graphics.setColor(new Color(color.getRed(), color.getGreen(), color.getBlue(), 50));
            graphics.fill(clickbox);
        }
    }
    
    /**
     * Highlights decorative objects by ID directly (for use in render methods).
     */
    public void highlightDecorativeObject(Graphics2D graphics, int objectId, Color color) {
        List<DecorativeObject> decorativeObjects = findDecorativeObjectsByID(objectId);
        for (DecorativeObject decorativeObject : decorativeObjects) {
            drawDecorativeObjectClickbox(graphics, decorativeObject, color);
        }
    }
    
    /**
     * Creates an overlay that highlights a decorative object by ID.
     */
    public Overlay highlightDecorativeObject(int objectId) {
        return highlightDecorativeObject(objectId, colorProvider.getLeftClickColorWithAlpha());
    }
    
    /**
     * Creates an overlay that highlights a decorative object by ID with a specific color.
     */
    public Overlay highlightDecorativeObject(int objectId, Color color) {
        return new Overlay() {
            @Override
            public Dimension render(Graphics2D graphics) {
                Client client = plugin.getClient();
                if (client != null) {
                    List<DecorativeObject> decorativeObjects = findDecorativeObjectsByID(objectId);
                    for (DecorativeObject decorativeObject : decorativeObjects) {
                        drawDecorativeObjectClickbox(graphics, decorativeObject, color);
                    }
                }
                return null;
            }
        };
    }
}


package com.easyfarming.overlays.highlighting;

import com.easyfarming.overlays.utils.ColorProvider;
import net.runelite.api.Client;
import net.runelite.api.IndexedObjectSet;
import net.runelite.api.NPC;

import javax.inject.Inject;
import java.awt.*;
import java.util.List;

/**
 * Handles highlighting of NPCs in the world.
 */
public class NPCHighlighter {
    private final Client client;
    private final ColorProvider colorProvider;
    
    @Inject
    public NPCHighlighter(Client client, ColorProvider colorProvider) {
        this.client = client;
        this.colorProvider = colorProvider;
    }
    
    /**
     * Highlights an NPC by name using their convex hull.
     */
    public void highlightNpc(Graphics2D graphics, String npcName) {
        IndexedObjectSet<? extends NPC> npcs = client.getTopLevelWorldView().npcs();
        
        if (npcs != null) {
            Color color = colorProvider.getLeftClickColorWithAlpha();
            for (NPC npc : npcs) {
                if (npc != null && npc.getName() != null && npc.getName().equals(npcName)) {
                    Shape convexHull = npc.getConvexHull();
                    
                    if (convexHull != null) {
                        graphics.setColor(color);
                        graphics.draw(convexHull);
                        graphics.setColor(new Color(color.getRed(), 
                                                   color.getGreen(), 
                                                   color.getBlue(), 
                                                   color.getAlpha() / 5));
                        graphics.fill(convexHull);
                    }
                }
            }
        }
    }
    
    /**
     * Highlights multiple NPCs by name.
     */
    public void highlightNpcs(Graphics2D graphics, List<String> npcNames) {
        for (String npcName : npcNames) {
            highlightNpc(graphics, npcName);
        }
    }
}


package com.easyfarming.overlays.highlighting;

import com.easyfarming.EasyFarmingOverlay;
import com.easyfarming.EasyFarmingConfig;
import com.easyfarming.overlays.utils.ColorProvider;
import net.runelite.api.Client;
import net.runelite.api.Item;
import net.runelite.api.gameval.InventoryID;
import net.runelite.api.gameval.InterfaceID;
import net.runelite.api.gameval.ItemID;
import net.runelite.api.widgets.Widget;

import javax.inject.Inject;
import java.awt.*;
import java.util.List;

/**
 * Handles highlighting of items in inventory and various item-related highlights.
 */
public class ItemHighlighter {
    private final Client client;
    private final EasyFarmingOverlay farmingHelperOverlay;
    private final EasyFarmingConfig config;
    private final ColorProvider colorProvider;
    
    @Inject
    public ItemHighlighter(Client client, EasyFarmingOverlay farmingHelperOverlay, 
                          EasyFarmingConfig config, ColorProvider colorProvider) {
        this.client = client;
        this.farmingHelperOverlay = farmingHelperOverlay;
        this.config = config;
        this.colorProvider = colorProvider;
    }
    
    /**
     * Highlights an item in the inventory by its ID.
     */
    public void itemHighlight(Graphics2D graphics, int itemID, Color color) {
        net.runelite.api.ItemContainer inventory = client.getItemContainer(InventoryID.INV);
        
        if (inventory != null) {
            Item[] items = inventory.getItems();
            
            Widget inventoryWidget = client.getWidget(InterfaceID.INVENTORY);
            if (inventoryWidget == null) {
                inventoryWidget = client.getWidget(149, 0);
            }
            
            if (inventoryWidget != null) {
                Widget[] children = inventoryWidget.getChildren();
                Widget[] dynamicChildren = inventoryWidget.getDynamicChildren();
                
                Widget[] childrenToUse = (dynamicChildren != null && dynamicChildren.length > 0) ? dynamicChildren : children;
                
                if (childrenToUse != null) {
                    for (int i = 0; i < items.length && i < childrenToUse.length; i++) {
                        Item item = items[i];
                        
                        if (item != null && (item.getId() == itemID || 
                            isQuetzalWhistleHighlight(item.getId(), itemID) ||
                            isExplorersRingHighlight(item.getId(), itemID) ||
                            isArdyCloakHighlight(item.getId(), itemID) ||
                            isSkillsNecklaceHighlight(item.getId(), itemID) ||
                            isBottomlessBucketHighlight(item.getId(), itemID))) {
                            Widget itemWidget = childrenToUse[i];
                            if (itemWidget != null) {
                                Rectangle bounds = itemWidget.getBounds();
                                if (bounds != null && bounds.width > 0 && bounds.height > 0) {
                                    graphics.setColor(new Color(color.getRed(), color.getGreen(), color.getBlue(), 100));
                                    graphics.fill(bounds);
                                    graphics.setColor(color);
                                    graphics.draw(bounds);
                                }
                            }
                        }
                    }
                }
            }
        }
    }
    
    /**
     * Checks if an item ID matches a quetzal whistle highlight pattern.
     */
    private boolean isQuetzalWhistleHighlight(int itemId, int targetId) {
        return farmingHelperOverlay.isQuetzalWhistle(itemId) && farmingHelperOverlay.isQuetzalWhistle(targetId);
    }
    
    /**
     * Checks if an item ID matches an Explorer's Ring highlight pattern.
     */
    private boolean isExplorersRingHighlight(int itemId, int targetId) {
        return farmingHelperOverlay.isExplorersRing(itemId) && farmingHelperOverlay.isExplorersRing(targetId);
    }
    
    /**
     * Checks if an item ID matches an Ardougne Cloak highlight pattern.
     */
    private boolean isArdyCloakHighlight(int itemId, int targetId) {
        return farmingHelperOverlay.isArdyCloak(itemId) && farmingHelperOverlay.isArdyCloak(targetId);
    }
    
    /**
     * Checks if an item ID matches a Skills Necklace highlight pattern.
     */
    private boolean isSkillsNecklaceHighlight(int itemId, int targetId) {
        return farmingHelperOverlay.isSkillsNecklace(itemId) && farmingHelperOverlay.isSkillsNecklace(targetId);
    }
    
    /**
     * Checks if an item ID matches a bottomless compost bucket highlight pattern.
     * Handles both empty bucket and all filled variants (22994-22998).
     */
    private boolean isBottomlessBucketHighlight(int itemId, int targetId) {
        if (targetId == ItemID.BOTTOMLESS_COMPOST_BUCKET) {
            // Check if itemId is the base bucket or any filled variant
            return itemId == ItemID.BOTTOMLESS_COMPOST_BUCKET ||
                   (itemId >= 22994 && itemId <= 22998);
        }
        return false;
    }
    
    /**
     * Highlights allotment seeds in inventory.
     */
    public void highlightAllotmentSeeds(Graphics2D graphics) {
        Color useItemColor = colorProvider.getHighlightUseItemWithAlpha();
        List<Integer> allotmentSeedIds = farmingHelperOverlay.getAllotmentSeedIds();
        
        for (Integer seedId : allotmentSeedIds) {
            itemHighlight(graphics, seedId, useItemColor);
        }
    }
    
    public void highlightHerbSeeds(Graphics2D graphics) {
        Color color = colorProvider.getHighlightUseItemWithAlpha();
        for (Integer seedId : farmingHelperOverlay.getHerbSeedIds()) {
            itemHighlight(graphics, seedId, color);
        }
    }
    
    /**
     * Highlights tree saplings in inventory.
     */
    public void highlightTreeSapling(Graphics2D graphics) {
        Color color = colorProvider.getHighlightUseItemWithAlpha();
        for (Integer seedId : farmingHelperOverlay.getTreeSaplingIds()) {
            itemHighlight(graphics, seedId, color);
        }
    }
    
    /**
     * Highlights fruit tree saplings in inventory.
     */
    public void highlightFruitTreeSapling(Graphics2D graphics) {
        Color color = colorProvider.getHighlightUseItemWithAlpha();
        for (Integer seedId : farmingHelperOverlay.getFruitTreeSaplingIds()) {
            itemHighlight(graphics, seedId, color);
        }
    }
    
    /**
     * Highlights teleport crystals in inventory.
     */
    public void highlightTeleportCrystal(Graphics2D graphics) {
        Color color = colorProvider.getLeftClickColorWithAlpha();
        for (Integer crystalId : farmingHelperOverlay.getTeleportCrystalIds()) {
            itemHighlight(graphics, crystalId, color);
        }
    }
    
    /**
     * Highlights skills necklaces in inventory.
     */
    public void highlightSkillsNecklace(Graphics2D graphics) {
        Color color = colorProvider.getRightClickColorWithAlpha();
        for (Integer necklaceId : farmingHelperOverlay.getSkillsNecklaceIds()) {
            itemHighlight(graphics, necklaceId, color);
        }
    }
    
    /**
     * Gets the selected compost item ID.
     */
    public Integer selectedCompostID() {
        EasyFarmingConfig.OptionEnumCompost selectedCompost = config.enumConfigCompost();
        switch (selectedCompost) {
            case Compost:
                return ItemID.BUCKET_COMPOST;
            case Supercompost:
                return ItemID.BUCKET_SUPERCOMPOST;
            case Ultracompost:
                return ItemID.BUCKET_ULTRACOMPOST;
            case Bottomless:
                return ItemID.BOTTOMLESS_COMPOST_BUCKET;
        }
        return -1;
    }
    
    /**
     * Checks if an item is in the inventory.
     * For bottomless compost bucket, also checks for filled variants.
     */
    public boolean isItemInInventory(int itemId) {
        net.runelite.api.ItemContainer inventory = client.getItemContainer(InventoryID.INV);
        
        Item[] items;
        if (inventory == null || inventory.getItems() == null) {
            items = new Item[0];
        } else {
            items = inventory.getItems();
        }
        
        for (Item item : items) {
            int checkItemId = item.getId();
            if (checkItemId == itemId) {
                return true;
            }
            // Special handling for bottomless compost bucket - check filled variants
            if (itemId == ItemID.BOTTOMLESS_COMPOST_BUCKET) {
                // Check for all bottomless bucket variants (empty: BOTTOMLESS_COMPOST_BUCKET, 
                // filled: 22994-22998 for various compost types)
                if (checkItemId == ItemID.BOTTOMLESS_COMPOST_BUCKET ||
                    (checkItemId >= 22994 && checkItemId <= 22998)) {
                    return true;
                }
            }
        }
        
        return false;
    }
}


package com.easyfarming.overlays.highlighting;

import com.easyfarming.overlays.utils.ColorProvider;
import net.runelite.api.Client;
import net.runelite.api.widgets.Widget;
import net.runelite.client.ui.overlay.Overlay;

import javax.inject.Inject;
import java.awt.*;

/**
 * Handles highlighting of widgets and interface components.
 */
public class WidgetHighlighter {
    private final Client client;
    private final ColorProvider colorProvider;
    
    @Inject
    public WidgetHighlighter(Client client, ColorProvider colorProvider) {
        this.client = client;
        this.colorProvider = colorProvider;
    }
    
    /**
     * Creates an overlay that highlights a widget interface.
     */
    public Overlay interfaceOverlay(int groupId, int childId) {
        return new Overlay() {
            @Override
            public Dimension render(Graphics2D graphics) {
                Client client = WidgetHighlighter.this.client;
                if (client != null) {
                    Widget widget = client.getWidget(groupId, childId);
                    if (widget != null) {
                        Rectangle bounds = widget.getBounds();
                        Color color = colorProvider.getLeftClickColorWithAlpha();
                        graphics.setColor(color);
                        
                        AlphaComposite alphaComposite = AlphaComposite.getInstance(AlphaComposite.SRC_OVER, 0.65f);
                        graphics.setComposite(alphaComposite);
                        
                        graphics.fillRect(bounds.x, bounds.y, bounds.width, bounds.height);
                        
                        graphics.setComposite(AlphaComposite.SrcOver);
                    }
                }
                return null;
            }
        };
    }
    
    /**
     * Highlights a dynamic component within a widget.
     */
    public void highlightDynamicComponent(Graphics2D graphics, Widget widget, int dynamicChildIndex) {
        if (widget != null) {
            Widget[] dynamicChildren = widget.getDynamicChildren();
            if (dynamicChildren != null && dynamicChildIndex >= 0 && dynamicChildIndex < dynamicChildren.length) {
                Widget child = dynamicChildren[dynamicChildIndex];
                if (child != null) {
                    Rectangle bounds = child.getBounds();
                    if (bounds != null && bounds.width > 0 && bounds.height > 0) {
                        Color color = colorProvider.getLeftClickColorWithAlpha();
                        graphics.setColor(color);
                        
                        AlphaComposite alphaComposite = AlphaComposite.getInstance(AlphaComposite.SRC_OVER, 0.65f);
                        graphics.setComposite(alphaComposite);
                        
                        graphics.fillRect(bounds.x, bounds.y, bounds.width, bounds.height);
                        
                        graphics.setComposite(AlphaComposite.SrcOver);
                    }
                }
            }
        }
    }
}


package com.easyfarming.overlays.highlighting;

import com.easyfarming.EasyFarmingOverlay;
import com.easyfarming.utils.Constants;
import net.runelite.api.Client;
import net.runelite.api.GameObject;
import net.runelite.client.ui.overlay.Overlay;

import javax.inject.Inject;
import java.awt.*;
import java.util.List;

/**
 * Handles highlighting of farming patches (herb, flower, tree, fruit tree).
 */
public class PatchHighlighter {
    private final Client client;
    private final EasyFarmingOverlay farmingHelperOverlay;
    private final GameObjectHighlighter gameObjectHighlighter;
    
    @Inject
    public PatchHighlighter(Client client, EasyFarmingOverlay farmingHelperOverlay, GameObjectHighlighter gameObjectHighlighter) {
        this.client = client;
        this.farmingHelperOverlay = farmingHelperOverlay;
        this.gameObjectHighlighter = gameObjectHighlighter;
    }
    
    public void highlightHerbPatches(Graphics2D graphics, Color color) {
        for (Integer patchId : farmingHelperOverlay.getHerbPatchIds()) {
            gameObjectHighlighter.highlightGameObject(patchId, color).render(graphics);
        }
    }
    
    public void highlightFlowerPatches(Graphics2D graphics, Color color) {
        for (Integer patchId : farmingHelperOverlay.getFlowerPatchIds()) {
            gameObjectHighlighter.highlightGameObject(patchId, color).render(graphics);
        }
    }
    
    public void highlightAllotmentPatches(Graphics2D graphics, Color color) {
        for (Integer patchId : farmingHelperOverlay.getAllotmentPatchIds()) {
            gameObjectHighlighter.highlightGameObject(patchId, color).render(graphics);
        }
    }
    
    /**
     * Highlights a specific allotment patch by object ID.
     * @param graphics Graphics context
     * @param objectId The object ID of the specific patch to highlight
     * @param color The color to use for highlighting
     */
    public void highlightSpecificAllotmentPatch(Graphics2D graphics, int objectId, Color color) {
        gameObjectHighlighter.highlightGameObject(objectId, color).render(graphics);
    }
    
    public void highlightTreePatches(Graphics2D graphics, Color color) {
        for (Integer patchId : farmingHelperOverlay.getTreePatchIds()) {
            gameObjectHighlighter.highlightGameObject(patchId, color).render(graphics);
        }
    }
    
    public void highlightFruitTreePatches(Graphics2D graphics, Color color) {
        for (Integer patchId : farmingHelperOverlay.getFruitTreePatchIds()) {
            gameObjectHighlighter.highlightGameObject(patchId, color).render(graphics);
        }
    }
    
    /**
     * Highlights farming patches for a specific location.
     * @param locationName The name of the location
     * @param graphics Graphics context for highlighting
     * @param herbRun Whether this is a herb run
     * @param treeRun Whether this is a tree run
     * @param fruitTreeRun Whether this is a fruit tree run
     * @param leftClickColor Color for left-click highlights
     * @param useItemColor Color for use-item highlights
     */
    public void highlightFarmingPatchesForLocation(String locationName, Graphics2D graphics, 
                                                   boolean herbRun, boolean treeRun, boolean fruitTreeRun,
                                                   Color leftClickColor, Color useItemColor) {
        // Herb locations
        if (herbRun && (locationName.equals("Ardougne") || locationName.equals("Catherby") || 
                       locationName.equals("Falador") || locationName.equals("Farming Guild") ||
                       locationName.equals("Harmony Island") || locationName.equals("Kourend") ||
                       locationName.equals("Morytania") || locationName.equals("Troll Stronghold") ||
                       locationName.equals("Weiss") || locationName.equals("Civitas illa Fortis"))) {
            highlightHerbPatches(graphics, leftClickColor);
        }
        
        // Tree locations
        if (treeRun && (locationName.equals("Falador") || locationName.equals("Farming Guild") ||
                       locationName.equals("Gnome Stronghold") || locationName.equals("Lumbridge") ||
                       locationName.equals("Taverley") || locationName.equals("Varrock"))) {
            highlightTreePatches(graphics, leftClickColor);
        }
        
        // Fruit tree locations
        if (fruitTreeRun && (locationName.equals("Brimhaven") || locationName.equals("Catherby") ||
                            locationName.equals("Farming Guild") || locationName.equals("Gnome Stronghold") ||
                            locationName.equals("Lletya") || locationName.equals("Tree Gnome Village"))) {
            highlightFruitTreePatches(graphics, leftClickColor);
        }
    }
}


package com.easyfarming;

import java.awt.*;
import javax.inject.Inject;

import net.runelite.api.*;
import net.runelite.api.coords.WorldPoint;
import net.runelite.api.gameval.InterfaceID;
import net.runelite.api.gameval.VarClientID;
import net.runelite.api.widgets.Widget;
import net.runelite.client.ui.overlay.Overlay;
import net.runelite.client.ui.overlay.OverlayLayer;
import net.runelite.client.ui.overlay.OverlayPosition;
import net.runelite.api.Client;
import net.runelite.api.GameObject;
import net.runelite.client.ui.overlay.components.PanelComponent;
import net.runelite.api.gameval.ItemID;
import net.runelite.api.Tile;

import java.awt.Color;
import java.awt.Shape;
import java.awt.Dimension;
import java.awt.Graphics2D;
import java.util.*;
import java.util.List;
import com.easyfarming.utils.Constants;


public class FarmingTeleportOverlay extends Overlay {
    private final Client client;
    private final EasyFarmingPlugin plugin;
    private boolean clicked = false;
    @Inject
    private EasyFarmingConfig config;
    @Inject
    private EasyFarmingOverlay farmingHelperOverlay;
    @Inject
    private EasyFarmingOverlayInfoBox farmingHelperOverlayInfoBox;
    @Inject
    private AreaCheck areaCheck;
    @Inject
    private com.easyfarming.overlays.handlers.FarmingStepHandler farmingStepHandler;
    @Inject
    private com.easyfarming.overlays.highlighting.PatchHighlighter patchHighlighter;
    @Inject
    private com.easyfarming.overlays.highlighting.ItemHighlighter itemHighlighter;
    @Inject
    private com.easyfarming.overlays.highlighting.WidgetHighlighter widgetHighlighter;
    @Inject
    private com.easyfarming.overlays.highlighting.MenuHighlighter menuHighlighter;
    @Inject
    private com.easyfarming.overlays.highlighting.GameObjectHighlighter gameObjectHighlighter;
    @Inject
    private com.easyfarming.overlays.highlighting.DecorativeObjectHighlighter decorativeObjectHighlighter;
    @Inject
    private com.easyfarming.overlays.utils.ColorProvider colorProvider;

    private final PanelComponent panelComponent = new PanelComponent();
    public boolean patchCleared = false;

    private Color leftClickColorWithAlpha;
    private Color rightClickColorWithAlpha;
    private Color highlightUseItemWithAlpha;

    public void updateColors() {
        leftClickColorWithAlpha = new Color(
                config.highlightLeftClickColor().getRed(),
                config.highlightLeftClickColor().getGreen(),
                config.highlightLeftClickColor().getBlue(),
                config.highlightAlpha()
        );
        rightClickColorWithAlpha = new Color(
                config.highlightRightClickColor().getRed(),
                config.highlightRightClickColor().getGreen(),
                config.highlightRightClickColor().getBlue(),
                config.highlightAlpha()
        );
        highlightUseItemWithAlpha = new Color(
                config.highlightUseItemColor().getRed(),
                config.highlightUseItemColor().getGreen(),
                config.highlightUseItemColor().getBlue(),
                config.highlightAlpha()
        );
    }


    public Map<String, Boolean> herbConfigMap = new HashMap<>();


    private int previousRegionId;
    public int inventoryTabValue = 0;




    @Inject
    public FarmingTeleportOverlay(EasyFarmingPlugin plugin, Client client, AreaCheck areaCheck) {
        this.areaCheck = areaCheck;
        setPosition(OverlayPosition.DYNAMIC);
        setLayer(OverlayLayer.ABOVE_WIDGETS);
        this.plugin = plugin;
        this.client = client;
    }


    public int getChildIndex(String searchText, Widget parentWidget)
    {
        if (parentWidget == null) {
            return -1;
        }

        Widget[] children = parentWidget.getChildren();

        if (children == null) {
            return -1;
        }

        for (int index = 0; index < children.length; index++) {
            Widget child = children[index];
            String text = child.getText();

            if (text != null) {
                int colonIndex = text.indexOf(':');

                if (colonIndex != -1 && colonIndex + 1 < text.length()) {
                    String textAfterColon = text.substring(colonIndex + 1).trim();

                    if (textAfterColon.equals(searchText)) {
                        return index;
                    }
                }
            }
        }

        return -1; // Return -1 if the specified text is not found
    }

    public int getChildIndexPortalNexus(String searchText)
    {
        return getChildIndex(
            searchText,
            client.getWidget(17, 12)
        );
    }

    public int getChildIndexSpiritTree(String searchText)
    {
        return getChildIndex(
            searchText,
            client.getWidget(187, 3)
        );
    }





    private boolean isInterfaceOpen(int groupId, int childId) {
        Widget widget = client.getWidget(groupId, childId);
        return widget != null && !widget.isHidden();
    }

    /**
     * Dynamically detects the correct spellbook tab interface ID based on the current client mode
     * @return The child ID for the magic spellbook tab, or -1 if not found
     */
    private int getSpellbookTabChildId() {
        // Try resizable classic mode first (161.65)
        if (isInterfaceOpen(161, 65)) {
            return 65;
        }
        // Try pre-EOC mode (164.58)
        if (isInterfaceOpen(164, 58)) {
            return 58;
        }
        // Try other possible variations
        if (isInterfaceOpen(161, 58)) {
            return 58;
        }
        if (isInterfaceOpen(164, 65)) {
            return 65;
        }
        // Default fallback to resizable classic mode
        return 65;
    }

    /**
     * Gets the correct group ID for the spellbook tab based on the current client mode
     * @return The group ID for the spellbook tab
     */
    private int getSpellbookTabGroupId() {
        // Try resizable classic mode first (161.65)
        if (isInterfaceOpen(161, 65)) {
            return 161;
        }
        // Try pre-EOC mode (164.58)
        if (isInterfaceOpen(164, 58)) {
            return 164;
        }
        // Try other possible variations
        if (isInterfaceOpen(161, 58)) {
            return 161;
        }
        if (isInterfaceOpen(164, 65)) {
            return 164;
        }
        // Default fallback to resizable classic mode
        return 161;
    }

    /**
     * Enhanced location detection that handles edge cases and adapts to player's current situation
     * @param location The target location
     * @param teleport The selected teleport method
     * @return true if player should proceed to farming phase, false if still navigating
     */
    private boolean shouldProceedToFarming(Location location, Location.Teleport teleport) {
        int currentRegionId = client.getLocalPlayer().getWorldLocation().getRegionID();
        WorldPoint playerLocation = client.getLocalPlayer().getWorldLocation();
        WorldPoint targetLocation = teleport.getPoint();
        
        // Check if player is in the correct region
        boolean inCorrectRegion = (currentRegionId == teleport.getRegionId());
        
        // Check if player is near the target location (within 20 tiles)
        boolean nearTarget = areaCheck.isPlayerWithinArea(targetLocation, 20);
        
        // Check if player is very close to the farming patch (within 5 tiles)
        boolean nearPatch = areaCheck.isPlayerWithinArea(targetLocation, 5);
        
        // Adaptive logic for different scenarios:
        
        // Scenario 1: Player is very close to the patch - proceed to farming regardless of teleport method
        if (nearPatch) {
            return true;
        }
        
        // Scenario 2: Player is in correct region and reasonably close - proceed to farming
        if (inCorrectRegion && nearTarget) {
            return true;
        }
        
        // Scenario 3: Player is in correct region but far from target - might have skipped teleport step
        // Check if there are any farming patches nearby that match this location type
        if (inCorrectRegion && !nearTarget) {
            // Check if player is near any farming patches of the same type
            if (isNearAnyFarmingPatch(location.getName())) {
                return true;
            }
        }
        
        // Scenario 4: Player is in wrong region but very close to target - might have used different teleport
        if (!inCorrectRegion && nearTarget) {
            return true;
        }
        
        // Default: Continue with normal navigation
        return false;
    }
    
    /**
     * Checks if player is near any farming patches of the specified type
     * @param locationName The name of the location to check for
     * @return true if player is near any farming patch of this type
     */
    private boolean isNearAnyFarmingPatch(String locationName) {
        WorldPoint playerLocation = client.getLocalPlayer().getWorldLocation();
        
        // Define farming patch locations for each area
        switch (locationName) {
            case "Ardougne":
                // Check if near Ardougne herb patch
                return areaCheck.isPlayerWithinArea(new WorldPoint(2670, 3374, 0), 10);
            case "Catherby":
                // Check if near Catherby herb patch
                return areaCheck.isPlayerWithinArea(new WorldPoint(2813, 3463, 0), 10);
            case "Falador":
                // Check if near Falador herb patch
                return areaCheck.isPlayerWithinArea(new WorldPoint(3058, 3307, 0), 10);
            case "Civitas illa Fortis":
                // Check if near Civitas herb patch
                return areaCheck.isPlayerWithinArea(new WorldPoint(1586, 3099, 0), 10);
            case "Farming Guild":
                // Check if near Farming Guild patches
                return areaCheck.isPlayerWithinArea(new WorldPoint(1238, 3726, 0), 15) ||
                       areaCheck.isPlayerWithinArea(new WorldPoint(1232, 3736, 0), 15) ||
                       areaCheck.isPlayerWithinArea(new WorldPoint(1243, 3759, 0), 15);
            case "Brimhaven":
                // Check if near Brimhaven fruit tree patch
                return areaCheck.isPlayerWithinArea(new WorldPoint(2764, 3212, 0), 10);
            case "Gnome Stronghold":
                // Check if near Gnome Stronghold patches
                return areaCheck.isPlayerWithinArea(new WorldPoint(2436, 3415, 0), 10) ||
                       areaCheck.isPlayerWithinArea(new WorldPoint(2475, 3446, 0), 10);
            case "Lumbridge":
                // Check if near Lumbridge tree patch
                return areaCheck.isPlayerWithinArea(new WorldPoint(3193, 3231, 0), 10);
            case "Taverley":
                // Check if near Taverley tree patch
                return areaCheck.isPlayerWithinArea(new WorldPoint(2936, 3438, 0), 10);
            case "Varrock":
                // Check if near Varrock tree patch
                return areaCheck.isPlayerWithinArea(new WorldPoint(3229, 3459, 0), 10);
            default:
                return false;
        }
    }
    
    /**
     * Gets the appropriate highlighting based on current situation
     * @param location The target location
     * @param teleport The selected teleport method
     * @param graphics Graphics context for highlighting
     */
    private void adaptiveHighlighting(Location location, Location.Teleport teleport, Graphics2D graphics) {
        int currentRegionId = client.getLocalPlayer().getWorldLocation().getRegionID();
        WorldPoint playerLocation = client.getLocalPlayer().getWorldLocation();
        WorldPoint targetLocation = teleport.getPoint();
        
        boolean inCorrectRegion = (currentRegionId == teleport.getRegionId());
        boolean nearTarget = areaCheck.isPlayerWithinArea(targetLocation, 20);
        boolean nearPatch = areaCheck.isPlayerWithinArea(targetLocation, 5);
        
        // If player is very close to patch, highlight the patch directly
        if (nearPatch) {
            highlightFarmingPatchesForLocation(location, graphics);
            return;
        }
        
        // If player is in correct region but not near target, they might be near a different patch
        if (inCorrectRegion && !nearTarget) {
            if (isNearAnyFarmingPatch(location.getName())) {
                highlightFarmingPatchesForLocation(location, graphics);
                return;
            }
        }
        
        // Default to normal teleport highlighting
        highlightTeleportMethod(teleport, graphics);
    }
    
    /**
     * Highlights farming patches for a specific location
     * @param location The location object (to check farmLimps and run type)
     * @param graphics Graphics context for highlighting
     */
    private void highlightFarmingPatchesForLocation(Location location, Graphics2D graphics) {
        Color leftColor = colorProvider.getLeftClickColorWithAlpha();
        String locationName = location.getName();
        
        switch (locationName) {
            case "Ardougne":
            case "Weiss":
            case "Civitas illa Fortis":
                patchHighlighter.highlightHerbPatches(graphics, leftColor);
                // Also highlight flower patches if this location supports limpwurt and it's a herb run
                if (herbRun && location.getFarmLimps() && config.generalLimpwurt()) {
                    patchHighlighter.highlightFlowerPatches(graphics, leftColor);
                }
                // Allotment patches are highlighted in allotmentSteps() based on state detection
                // No unconditional highlighting here - only when state is detected
                // highlightHerbPatches(graphics, leftClickColorWithAlpha);
                break;
            case "Catherby":
                // Catherby has both herb and fruit tree patches
                patchHighlighter.highlightHerbPatches(graphics, leftColor);
                patchHighlighter.highlightFruitTreePatches(graphics, leftColor);
                // highlightHerbPatches(graphics, leftClickColorWithAlpha);
                // highlightFruitTreePatches(graphics, leftClickColorWithAlpha);
                break;
            case "Falador":
                // Falador has both herb and tree patches
                patchHighlighter.highlightHerbPatches(graphics, leftColor);
                patchHighlighter.highlightTreePatches(graphics, leftColor);
                // highlightHerbPatches(graphics, leftClickColorWithAlpha);
                // highlightTreePatches(graphics, leftClickColorWithAlpha);
                break;
            case "Farming Guild":
                // Farming Guild has all patch types
                patchHighlighter.highlightHerbPatches(graphics, leftColor);
                patchHighlighter.highlightTreePatches(graphics, leftColor);
                patchHighlighter.highlightFruitTreePatches(graphics, leftColor);
                // highlightHerbPatches(graphics, leftClickColorWithAlpha);
                // highlightTreePatches(graphics, leftClickColorWithAlpha);
                // highlightFruitTreePatches(graphics, leftClickColorWithAlpha);
                break;
            case "Lumbridge":
            case "Taverley":
            case "Varrock":
                patchHighlighter.highlightTreePatches(graphics, leftColor);
                // highlightTreePatches(graphics, leftClickColorWithAlpha);
                break;
            case "Brimhaven":
            case "Gnome Stronghold":
            case "Lletya":
            case "Tree Gnome Village":
                patchHighlighter.highlightFruitTreePatches(graphics, leftColor);
                // highlightFruitTreePatches(graphics, leftClickColorWithAlpha);
                break;
        }
    }
    
    /**
     * Highlights the appropriate teleport method based on category
     * @param teleport The teleport method to highlight
     * @param graphics Graphics context for highlighting
     */
    private void highlightTeleportMethod(Location.Teleport teleport, Graphics2D graphics) {
        Color leftColor = colorProvider.getLeftClickColorWithAlpha();
        Color rightColor = colorProvider.getRightClickColorWithAlpha();
        switch (teleport.getCategory()) {
            case ITEM:
                // Check if it's a Quetzal whistle, Royal seed pod, or Ectophial (left-click teleport)
                if(plugin.getEasyFarmingOverlay().isQuetzalWhistle(teleport.getId()) || 
                   plugin.getEasyFarmingOverlay().isRoyalSeedPod(teleport.getId()) ||
                   plugin.getEasyFarmingOverlay().isEctophial(teleport.getId())) {
                    itemHighlighter.itemHighlight(graphics, teleport.getId(), leftColor);
                    // itemHighlight(graphics, teleport.getId(), leftClickColorWithAlpha);
                } else {
                    itemHighlighter.itemHighlight(graphics, teleport.getId(), rightColor);
                    // itemHighlight(graphics, teleport.getId(), rightClickColorWithAlpha);
                    if (!teleport.getRightClickOption().equals("")) {
                        menuHighlighter.highlightRightClickOption(graphics, teleport.getRightClickOption());
                        // highlightRightClickOption(graphics, teleport.getRightClickOption());
                    }
                }
                break;
            case SPELLBOOK:
                InventoryTabChecker.TabState tabState = InventoryTabChecker.checkTab(client, VarClientID.TOPLEVEL_PANEL);
                if (tabState == InventoryTabChecker.TabState.SPELLBOOK) {
                    widgetHighlighter.interfaceOverlay(teleport.getInterfaceGroupId(), teleport.getInterfaceChildId()).render(graphics);
                    // interfaceOverlay(teleport.getInterfaceGroupId(), teleport.getInterfaceChildId()).render(graphics);
                } else {
                    widgetHighlighter.interfaceOverlay(getSpellbookTabGroupId(), getSpellbookTabChildId()).render(graphics);
                    // interfaceOverlay(getSpellbookTabGroupId(), getSpellbookTabChildId()).render(graphics);
                }
                break;
            case PORTAL_NEXUS:
                if (!isInterfaceOpen(17, 0)) {
                    List<Integer> portalNexusIds = getGameObjectIdsByName("Portal Nexus");
                    for (Integer objectId : portalNexusIds) {
                        gameObjectHighlighter.highlightGameObject(objectId, leftColor).render(graphics);
                        // gameObjectOverlay(objectId, leftClickColorWithAlpha).render(graphics);
                    }
                } else {
                    Widget widget = client.getWidget(17, 13);
                    int index = getChildIndexPortalNexus(teleport.getPoint().toString());
                    widgetHighlighter.highlightDynamicComponent(graphics, widget, index);
                    // highlightDynamicComponent(graphics, widget, index);
                }
                break;
            case SPIRIT_TREE:
                if (!isInterfaceOpen(187, 3)) {
                    List<Integer> spiritTreeIds = Arrays.asList(1293, 1294, 1295, 8355, 29227, 29229, 37329, 40778);
                    for (Integer objectId : spiritTreeIds) {
                        gameObjectHighlighter.highlightGameObject(objectId, leftColor).render(graphics);
                        // gameObjectOverlay(objectId, leftClickColorWithAlpha).render(graphics);
                    }
                } else {
                    Widget widget = client.getWidget(187, 3);
                    int index = getChildIndexSpiritTree(teleport.getPoint().toString());
                    widgetHighlighter.highlightDynamicComponent(graphics, widget, index);
                    // highlightDynamicComponent(graphics, widget, index);
                }
                break;
            case JEWELLERY_BOX:
                if (!isInterfaceOpen(29155, 0)) {
                    List<Integer> jewelleryBoxIds = getGameObjectIdsByName("Jewellery Box");
                    for (Integer objectId : jewelleryBoxIds) {
                        gameObjectHighlighter.highlightGameObject(objectId, leftColor).render(graphics);
                        // gameObjectOverlay(objectId, leftClickColorWithAlpha).render(graphics);
                    }
                } else {
                    Widget widget = client.getWidget(29155, 0);
                    widgetHighlighter.highlightDynamicComponent(graphics, widget, 0);
                    // highlightDynamicComponent(graphics, widget, 0);
                }
                break;
        }
    }



    private List<Integer> getGameObjectIdsByName(String name) {
        List<Integer> foundObjectIds = new ArrayList<>();
        WorldView top_wv = client.getTopLevelWorldView();
        Scene scene = top_wv.getScene();
        Tile[][][] tiles = scene.getTiles();

        for (int x = 0; x < Constants.SCENE_SIZE; x++) {
            for (int y = 0; y < Constants.SCENE_SIZE; y++) {
                Tile tile = tiles[top_wv.getPlane()][x][y];
                if (tile == null) {
                    continue;
                }

                for (GameObject gameObject : tile.getGameObjects()) {
                    if (gameObject != null) {
                        ObjectComposition objectComposition = client.getObjectDefinition(gameObject.getId());
                        if (objectComposition != null && objectComposition.getName().equals(name)) {
                            foundObjectIds.add(gameObject.getId());
                        }
                    }
                }
            }
        }

        return foundObjectIds;
    }

    public void inHouseCheck() {
        if(getGameObjectIdsByName("Portal").contains(4525))
        {
            this.currentTeleportCase = 2;
        }
    }

    public void gettingToHouse(Graphics2D graphics) {
        EasyFarmingConfig.OptionEnumHouseTele teleportOption = config.enumConfigHouseTele();
        switch (teleportOption) {
            case Law_air_earth_runes:
                InventoryTabChecker.TabState tabState;
                tabState = InventoryTabChecker.checkTab(client, VarClientID.TOPLEVEL_PANEL);
                switch (tabState) {
                            case INVENTORY:
                            case REST:
                                widgetHighlighter.interfaceOverlay(getSpellbookTabGroupId(), getSpellbookTabChildId()).render(graphics);
                                // interfaceOverlay(getSpellbookTabGroupId(), getSpellbookTabChildId()).render(graphics);
                                break;
                    case SPELLBOOK:
                        // Highlight the "Teleport to House" spell using correct child ID from widget inspector
                        widgetHighlighter.interfaceOverlay(InterfaceID.MAGIC_SPELLBOOK, 31).render(graphics);
                        // interfaceOverlay(InterfaceID.MAGIC_SPELLBOOK, 31).render(graphics);
                        inHouseCheck();
                        break;
                }
                break;
            case Teleport_To_House:
                inHouseCheck();
                Color leftColor = colorProvider.getLeftClickColorWithAlpha();
                itemHighlighter.itemHighlight(graphics, ItemID.POH_TABLET_TELEPORTTOHOUSE, leftColor);
                // itemHighlight(graphics, ItemID.POH_TABLET_TELEPORTTOHOUSE, leftClickColorWithAlpha);
                break;
            case Construction_cape:
                inHouseCheck();
                Color rightColor = colorProvider.getRightClickColorWithAlpha();
                itemHighlighter.itemHighlight(graphics, ItemID.SKILLCAPE_CONSTRUCTION, rightColor);
                // itemHighlight(graphics, ItemID.SKILLCAPE_CONSTRUCTION, rightClickColorWithAlpha);
                break;
            case Construction_cape_t:
                inHouseCheck();
                Color rightColor2 = colorProvider.getRightClickColorWithAlpha();
                itemHighlighter.itemHighlight(graphics, ItemID.SKILLCAPE_CONSTRUCTION_TRIMMED, rightColor2);
                // itemHighlight(graphics, ItemID.SKILLCAPE_CONSTRUCTION_TRIMMED, rightClickColorWithAlpha);
                break;
            case Max_cape:
                inHouseCheck();
                Color rightColor3 = colorProvider.getRightClickColorWithAlpha();
                itemHighlighter.itemHighlight(graphics, ItemID.SKILLCAPE_MAX, rightColor3);
                // itemHighlight(graphics, ItemID.SKILLCAPE_MAX, rightClickColorWithAlpha);
                break;
        }
    }

    private int currentTeleportCase = 1;

    public boolean isAtDestination = false;


    public void gettingToLocation(Graphics2D graphics, Location location) {
        updateColors();
        Location.Teleport teleport = location.getSelectedTeleport();
        Boolean locationEnabledBool = false;
        if (plugin.getFarmingTeleportOverlay().herbRun) {
            locationEnabledBool = plugin.getHerbLocationEnabled(location.getName());
        }
        if (plugin.getFarmingTeleportOverlay().treeRun) {
            locationEnabledBool = plugin.getTreeLocationEnabled(location.getName());
        }
        if (plugin.getFarmingTeleportOverlay().fruitTreeRun) {
            locationEnabledBool = plugin.getFruitTreeLocationEnabled(location.getName());
        }
        if (locationEnabledBool) {
            if (!isAtDestination) {
                int currentRegionId = client.getLocalPlayer().getWorldLocation().getRegionID();
                
                // Use adaptive detection to determine if we should proceed to farming
                if (shouldProceedToFarming(location, teleport)) {
                    this.currentTeleportCase = 1;
                    isAtDestination = true;
                    this.startSubCases = true;
                    if (location.getFarmLimps()) {
                        this.farmLimps = true;
                    }
                    plugin.addTextToInfoBox(teleport.getDescription());
                } else {
                    // Use adaptive highlighting based on current situation
                    adaptiveHighlighting(location, teleport, graphics);
                    plugin.addTextToInfoBox(teleport.getDescription());
                    return;
                }
                
                switch (teleport.getCategory()) {
                    case ITEM:
                        if (teleport.getInterfaceGroupId() != 0) {
                            Color rightColor = colorProvider.getRightClickColorWithAlpha();
                            if (!isInterfaceOpen(teleport.getInterfaceGroupId(), teleport.getInterfaceChildId())) {
                                itemHighlighter.itemHighlight(graphics, teleport.getId(), rightColor);
                                // itemHighlight(graphics, teleport.getId(), rightClickColorWithAlpha);
                                if (!teleport.getRightClickOption().equals("")) {
                                    menuHighlighter.highlightRightClickOption(graphics, teleport.getRightClickOption());
                                    // highlightRightClickOption(graphics, teleport.getRightClickOption());
                                }
                            } else {
                                Widget widget = client.getWidget(teleport.getInterfaceGroupId(), teleport.getInterfaceChildId());
                                widgetHighlighter.highlightDynamicComponent(graphics, widget, 1);
                                // highlightDynamicComponent(graphics, widget, 1);
                            }
                            if (currentRegionId == teleport.getRegionId()) {
                                this.currentTeleportCase = 1;
                                isAtDestination = true;
                                this.startSubCases = true;
                                if (location.getFarmLimps()) {
                                    this.farmLimps = true;
                                }
                            }
                        } else {
                            Color rightColor = colorProvider.getRightClickColorWithAlpha();
                            if (!teleport.getRightClickOption().equals("")) {
                                itemHighlighter.itemHighlight(graphics, teleport.getId(), rightColor);
                                menuHighlighter.highlightRightClickOption(graphics, teleport.getRightClickOption());
                                // itemHighlight(graphics, teleport.getId(), rightClickColorWithAlpha);
                                // highlightRightClickOption(graphics, teleport.getRightClickOption());
                            } else {
                                Color leftColor = colorProvider.getLeftClickColorWithAlpha();
                                if(plugin.getEasyFarmingOverlay().isTeleportCrystal(teleport.getId())) {
                                    itemHighlighter.highlightTeleportCrystal(graphics);
                                    // highlightTeleportCrystal(graphics);
                                }
                                if(plugin.getEasyFarmingOverlay().isSkillsNecklace(teleport.getId())) {
                                    String index = location.getName();
                                    List<Integer> skillsNecklaceIds = Constants.SKILLS_NECKLACE_IDS;
                                    if(Objects.equals(index, "Ardougne")) {
                                        for (int id : skillsNecklaceIds) {
                                            itemHighlighter.itemHighlight(graphics, id, rightColor);
                                        }
                                        Widget widget = client.getWidget(187, 3);
                                        if (widget != null && !widget.isHidden()) {
                                            widgetHighlighter.highlightDynamicComponent(graphics, widget, 0);
                                        }
                                        // highlightSkillsNecklace(graphics);
                                        // highlightRightClickOption(graphics, "Rub");
                                        // highlightDynamicComponent(graphics, widget, 0);
                                    }
                                    if(Objects.equals(index, "Farming Guild")) {
                                        for (int id : skillsNecklaceIds) {
                                            itemHighlighter.itemHighlight(graphics, id, rightColor);
                                        }
                                        Widget widget = client.getWidget(187, 3);
                                        if (widget != null && !widget.isHidden()) {
                                            widgetHighlighter.highlightDynamicComponent(graphics, widget, 5);
                                        }
                                        // highlightSkillsNecklace(graphics);
                                        // highlightRightClickOption(graphics, "Rub");
                                        // highlightDynamicComponent(graphics, widget, 5);
                                    }
                                }
                                else if(plugin.getEasyFarmingOverlay().isQuetzalWhistle(teleport.getId()) || 
                                        plugin.getEasyFarmingOverlay().isRoyalSeedPod(teleport.getId()) ||
                                        plugin.getEasyFarmingOverlay().isEctophial(teleport.getId())) {
                                    itemHighlighter.itemHighlight(graphics, teleport.getId(), leftColor);
                                    // itemHighlight(graphics, teleport.getId(), leftClickColorWithAlpha);
                                }
                                else {
                                    itemHighlighter.itemHighlight(graphics, teleport.getId(), leftColor);
                                    // itemHighlight(graphics, teleport.getId(), leftClickColorWithAlpha);
                                }
                            }
                            if (currentRegionId == teleport.getRegionId()) {
                                this.currentTeleportCase = 1;
                                isAtDestination = true;
                                this.startSubCases = true;
                                if (location.getFarmLimps()) {
                                    this.farmLimps = true;
                                }
                            }
                        }
                        break;
                    case PORTAL_NEXUS:
                        switch (this.currentTeleportCase) {
                            case 1:
                                gettingToHouse(graphics);
                                break;
                            case 2:
                                Color leftColor = colorProvider.getLeftClickColorWithAlpha();
                                if (!isInterfaceOpen(17, 0)) {
                                    List<Integer> portalNexusIds = getGameObjectIdsByName("Portal Nexus");
                                    for (Integer objectId : portalNexusIds) {
                                        gameObjectHighlighter.highlightGameObject(objectId, leftColor).render(graphics);
                                        // gameObjectOverlay(objectId, leftClickColorWithAlpha).render(graphics);
                                    }
                                } else {
                                    Widget widget = client.getWidget(17, 13);
                                    int index = getChildIndexPortalNexus(location.getName());
                                    widgetHighlighter.highlightDynamicComponent(graphics, widget, index);
                                    // highlightDynamicComponent(graphics, widget, index);
                                }
                                if (currentRegionId == teleport.getRegionId()) {
                                    this.currentTeleportCase = 1;
                                    isAtDestination = true;
                                    this.startSubCases = true;
                                    if (location.getFarmLimps()) {
                                        this.farmLimps = true;
                                    }
                                }
                                break;
                        }
                        break;
                    case SPIRIT_TREE:
                        Color leftColor = colorProvider.getLeftClickColorWithAlpha();
                        if (!isInterfaceOpen(187, 3)) {
                            List<Integer> spiritTreeIds = Arrays.asList(1293, 1294, 1295, 8355, 29227, 29229, 37329, 40778);

                            for (Integer objectId : spiritTreeIds) {
                                gameObjectHighlighter.highlightGameObject(objectId, leftColor).render(graphics);
                                // gameObjectOverlay(objectId, leftClickColorWithAlpha).render(graphics);
                            }
                        } else {
                            Widget widget = client.getWidget(187, 3);

                            switch (location.getName()) {
                                case "Gnome Stronghold":
                                    widgetHighlighter.highlightDynamicComponent(graphics, widget, getChildIndexSpiritTree("Gnome Stronghold"));
                                    // highlightDynamicComponent(graphics, widget, getChildIndexSpiritTree("Gnome Stronghold"));
                                    break;

                                case "Tree Gnome Village":
                                    widgetHighlighter.highlightDynamicComponent(graphics, widget, getChildIndexSpiritTree("Tree Gnome Village"));
                                    // highlightDynamicComponent(graphics, widget, getChildIndexSpiritTree("Tree Gnome Village"));
                                    break;

                                case "Falador":
                                    widgetHighlighter.highlightDynamicComponent(graphics, widget, getChildIndexSpiritTree("Port Sarim"));
                                    // highlightDynamicComponent(graphics, widget, getChildIndexSpiritTree("Port Sarim"));
                                    break;

                                case "Kourend":
                                    widgetHighlighter.highlightDynamicComponent(graphics, widget, getChildIndexSpiritTree("Hosidius"));
                                    // highlightDynamicComponent(graphics, widget, getChildIndexSpiritTree("Hosidius"));
                                    break;
                            }
                        }
                        if (currentRegionId == teleport.getRegionId()) {
                            this.currentTeleportCase = 1;
                            isAtDestination = true;
                            this.startSubCases = true;

                            if (location.getFarmLimps()) {
                                this.farmLimps = true;
                            }
                        }
                        break;                    
                    case JEWELLERY_BOX:
                        switch (this.currentTeleportCase) {
                            case 1:
                                gettingToHouse(graphics);
                                break;
                            case 2:
                                Color leftColorJewelry = colorProvider.getLeftClickColorWithAlpha();
                                List<Integer> jewelleryBoxIds = Arrays.asList(29154, 29155, 29156);

                                if (!isInterfaceOpen(590, 0)) {
                                    for (int id : jewelleryBoxIds) {
                                        gameObjectHighlighter.highlightGameObject(id, leftColorJewelry).render(graphics);
                                        // gameObjectOverlay(id, leftClickColorWithAlpha).render(graphics);
                                    }
                                    gameObjectHighlighter.highlightGameObject(teleport.getId(), leftColorJewelry).render(graphics);
                                    // gameObjectOverlay(teleport.getId(), leftClickColorWithAlpha).render(graphics);
                                } else {
                                    Widget widget = client.getWidget(590, 5);
                                    widgetHighlighter.highlightDynamicComponent(graphics, widget, 10);
                                    // highlightDynamicComponent(graphics, widget, 10);
                                }
                                if (currentRegionId == teleport.getRegionId()) {
                                    this.currentTeleportCase = 1;
                                    isAtDestination = true;
                                    this.startSubCases = true;
                                    if (location.getFarmLimps()) {
                                        this.farmLimps = true;
                                    }
                                }
                                break;
                        }
                        break;
                    case MOUNTED_XERICS:
                        switch (this.currentTeleportCase) {
                            case 1:
                                gettingToHouse(graphics);
                                break;
                            case 2:
                                List<Integer> xericsTalismanIds = Arrays.asList(33411, 33412, 33413, 33414, 33415);

                                if (!isInterfaceOpen(teleport.getInterfaceGroupId(), teleport.getInterfaceChildId())) {
                                    for (int id : xericsTalismanIds) {
                                        decorativeObjectHighlighter.highlightDecorativeObject(id).render(graphics);
                                        // Overlay decorativeObjectHighlight = decorativeObjectOverlay(id);
                                        // decorativeObjectHighlight.render(graphics);
                                    }
                                } else {
                                    Widget widget = client.getWidget(teleport.getInterfaceGroupId(), teleport.getInterfaceChildId());
                                    widgetHighlighter.highlightDynamicComponent(graphics, widget, 1);
                                    // highlightDynamicComponent(graphics, widget, 1);
                                    if (currentRegionId == teleport.getRegionId()) {
                                        this.currentTeleportCase = 1;
                                        isAtDestination = true;
                                        this.startSubCases = true;
                                        if (location.getFarmLimps()) {
                                            this.farmLimps = true;
                                        }
                                    }
                                }
                                break;
                        }
                        break;
                    case SPELLBOOK:
                        InventoryTabChecker.TabState tabState;
                        tabState = InventoryTabChecker.checkTab(client, VarClientID.TOPLEVEL_PANEL);
                        switch (tabState) {
                            case REST:
                            case INVENTORY:
                                widgetHighlighter.interfaceOverlay(getSpellbookTabGroupId(), getSpellbookTabChildId()).render(graphics);
                                // interfaceOverlay(getSpellbookTabGroupId(), getSpellbookTabChildId()).render(graphics);
                                if (currentRegionId == teleport.getRegionId()) {
                                    this.currentTeleportCase = 1;
                                    isAtDestination = true;
                                    this.startSubCases = true;
                                }
                                break;
                            case SPELLBOOK:
                                widgetHighlighter.interfaceOverlay(teleport.getInterfaceGroupId(), teleport.getInterfaceChildId()).render(graphics);
                                // interfaceOverlay(teleport.getInterfaceGroupId(), teleport.getInterfaceChildId()).render(graphics);
                                if (currentRegionId == teleport.getRegionId()) {
                                    this.currentTeleportCase = 1;
                                    isAtDestination = true;
                                    this.startSubCases = true;
                                }
                                break;
                        }
                        break;
                    default:
                        // Optional: Code for handling unexpected values
                        break;
                }

            } else {
                farming(graphics, teleport);
            }
        } else {
            this.currentLocationIndex++;
        }
    }
    //}


    private boolean farmLimps = false;

    public void farming(Graphics2D graphics, Location.Teleport teleport) {
        if (this.startSubCases) {
            if (herbRun) {
                if (this.subCase == 1) {
                    farmingStepHandler.herbSteps(graphics, teleport);
                    if (farmingStepHandler.herbPatchDone) {
                        this.subCase = 2;
                        farmingStepHandler.herbPatchDone = false;
                    }
                } else if (this.subCase == 2) {
                    if (config.generalLimpwurt()) {
                        farmingStepHandler.flowerSteps(graphics, this.farmLimps);
                        if (farmingStepHandler.flowerPatchDone) {
                            if (config.generalAllotment()) {
                                this.subCase = 3;
                                farmingStepHandler.flowerPatchDone = false;
                            } else {
                                this.subCase = 1;
                                this.startSubCases = false;
                                isAtDestination = false;
                                this.currentLocationIndex++;
                                this.farmLimps = false;
                                farmingStepHandler.flowerPatchDone = false;
                            }
                        }
                    } else if (config.generalAllotment()) {
                        // Transition directly to allotment steps
                        this.subCase = 3;
                        // Reset allotment patch tracking for new location
                        farmingStepHandler.allotmentPatchDone = false;
                    } else {
                        this.subCase = 1;
                        this.startSubCases = false;
                        isAtDestination = false;
                        this.currentLocationIndex++;
                        this.farmLimps = false;
                        farmingStepHandler.flowerPatchDone = false;
                    }
                } else if (this.subCase == 3) {
                    if (config.generalAllotment()) {
                        farmingStepHandler.allotmentSteps(graphics, teleport);
                        if (farmingStepHandler.allotmentPatchDone) {
                            this.subCase = 1;
                            this.startSubCases = false;
                            isAtDestination = false;
                            this.currentLocationIndex++;
                            this.farmLimps = false;
                            farmingStepHandler.allotmentPatchDone = false;
                        }
                        // If allotmentPatchDone is false, continue to next frame - allotmentSteps() will handle instructions/highlights
                    } else {
                        this.subCase = 1;
                        this.startSubCases = false;
                        isAtDestination = false;
                        this.currentLocationIndex++;
                        this.farmLimps = false;
                    }
                }
            }
            if (treeRun) {
                farmingStepHandler.treeSteps(graphics, teleport);
                if (farmingStepHandler.treePatchDone) {
                    this.startSubCases = false;
                    isAtDestination = false;
                    this.currentLocationIndex++;
                    farmingStepHandler.treePatchDone = false;
                }
            }
            if (fruitTreeRun) {
                farmingStepHandler.fruitTreeSteps(graphics, teleport);
                if (farmingStepHandler.fruitTreePatchDone) {
                    this.startSubCases = false;
                    isAtDestination = false;
                    this.currentLocationIndex++;
                    farmingStepHandler.fruitTreePatchDone = false;
                }
            }
        }
    }

    private int subCase = 1;
    private boolean startSubCases = false;
    private int currentLocationIndex = 0;

    public void removeOverlay() {
        plugin.overlayManager.remove(farmingHelperOverlay);
        plugin.overlayManager.remove(this);
        plugin.overlayManager.remove(farmingHelperOverlayInfoBox);

        plugin.setOverlayActive(false);
        plugin.setTeleportOverlayActive(false);

        this.currentLocationIndex = 0;
        this.currentTeleportCase = 1;
        this.subCase = 1;
        this.startSubCases = false;
        isAtDestination = false;
        this.farmLimps = false;
        farmingStepHandler.flowerPatchDone = false;
        farmingStepHandler.treePatchDone = false;
        farmingStepHandler.fruitTreePatchDone = false;

        plugin.setItemsCollected(false);

        plugin.getFarmingTeleportOverlay().herbRun = false;
        plugin.getFarmingTeleportOverlay().treeRun = false;
        plugin.getFarmingTeleportOverlay().fruitTreeRun = false;

        fruitTreeRun = false;
        herbRun = false;
        treeRun = false;

        plugin.panel.herbButton.setStartStopState(false);
        plugin.panel.treeButton.setStartStopState(false);
        plugin.panel.fruitTreeButton.setStartStopState(false);
    }

    public Boolean herbRun = false;

    public Boolean treeRun = false;

    public Boolean fruitTreeRun = false;

    @Override
    public Dimension render(Graphics2D graphics) {
        if (plugin.isTeleportOverlayActive()) {
            if (herbRun) {
                switch (this.currentLocationIndex) {
                    case 0:
                        gettingToLocation(graphics, plugin.getArdougneLocation());
                        break;
                    case 1:
                        gettingToLocation(graphics, plugin.getCatherbyLocation());
                        break;
                    case 2:
                        gettingToLocation(graphics, plugin.getFaladorLocation());
                        break;
                    case 3:
                        gettingToLocation(graphics, plugin.getFarmingGuildLocation());
                        break;
                    case 4:
                        gettingToLocation(graphics, plugin.getHarmonyLocation());
                        break;
                    case 5:
                        gettingToLocation(graphics, plugin.getKourendLocation());
                        break;
                    case 6:
                        gettingToLocation(graphics, plugin.getMorytaniaLocation());
                        break;
                    case 7:
                        gettingToLocation(graphics, plugin.getTrollStrongholdLocation());
                        break;
                    case 8:
                        gettingToLocation(graphics, plugin.getWeissLocation());
                        break;
                    case 9:
                        gettingToLocation(graphics, plugin.getCivitasLocation());
                        break;
                    case 10:
                        removeOverlay();
                        // add more cases for each location in the array
                    default:
                        removeOverlay();
                        // Add any other actions you want to perform when the herb run is complete
                        break;
                }
            } else if (treeRun) {
                switch (this.currentLocationIndex) {
                    case 0:
                        gettingToLocation(graphics, plugin.getFaladorTreeLocation());
                        break;
                    case 1:
                        gettingToLocation(graphics, plugin.getFarmingGuildTreeLocation());
                        break;
                    case 2:
                        gettingToLocation(graphics, plugin.getGnomeStrongholdTreeLocation());
                        break;
                    case 3:
                        gettingToLocation(graphics, plugin.getLumbridgeTreeLocation());
                        break;
                    case 4:
                        gettingToLocation(graphics, plugin.getTaverleyTreeLocation());
                        break;
                    case 5:
                        gettingToLocation(graphics, plugin.getVarrockTreeLocation());
                        break;
                    case 6:
                        removeOverlay();
                        // add more cases for each location in the array
                    default:
                        removeOverlay();
                        // Add any other actions you want to perform when the herb run is complete
                        break;
                }
            } else if (fruitTreeRun) {
                switch (this.currentLocationIndex) {
                    case 0:
                        gettingToLocation(graphics, plugin.getBrimhavenFruitTreeLocation());
                        break;
                    case 1:
                        gettingToLocation(graphics, plugin.getCatherbyFruitTreeLocation());
                        break;
                    case 2:
                        gettingToLocation(graphics, plugin.getFarmingGuildFruitTreeLocation());
                        break;
                    case 3:
                        gettingToLocation(graphics, plugin.getGnomeStrongholdFruitTreeLocation());
                        break;
                    case 4:
                        gettingToLocation(graphics, plugin.getLletyaFruitTreeLocation());
                        break;
                    case 5:
                        gettingToLocation(graphics, plugin.getTreeGnomeVillageTreeLocation());
                        break;
                    case 6:
                        removeOverlay();
                        // add more cases for each location in the array
                    default:
                        removeOverlay();
                        // Add any other actions you want to perform when the herb run is complete
                        break;
                }
            }
        }
        return null;
    }
}

package com.easyfarming;

import java.awt.Dimension;
import java.awt.Graphics2D;
import java.util.*;
import javax.inject.Inject;

import net.runelite.api.*;
import net.runelite.api.gameval.InventoryID;
import net.runelite.api.gameval.ItemID;
import net.runelite.api.gameval.VarbitID;
import net.runelite.api.kit.KitType;
import net.runelite.client.ui.overlay.Overlay;
import net.runelite.client.ui.overlay.OverlayLayer;
import net.runelite.client.ui.overlay.OverlayPosition;
import net.runelite.client.ui.overlay.components.ImageComponent;
import net.runelite.client.ui.overlay.components.PanelComponent;
import java.awt.image.BufferedImage;
import net.runelite.client.game.ItemManager;

import java.awt.Color;
import com.easyfarming.ItemsAndLocations.HerbRunItemAndLocation;
import com.easyfarming.ItemsAndLocations.TreeRunItemAndLocation;
import com.easyfarming.ItemsAndLocations.FruitTreeRunItemAndLocation;
import com.easyfarming.utils.Constants;

public class EasyFarmingOverlay extends Overlay {

    private HerbRunItemAndLocation herbRunItemAndLocation;
    private TreeRunItemAndLocation treeRunItemAndLocation;
    private FruitTreeRunItemAndLocation fruitTreeRunItemAndLocation;
    private final Client client;
    private final EasyFarmingPlugin plugin;
    private final PanelComponent panelComponent = new PanelComponent();
    @Inject
    private ItemManager itemManager;

    public static final List<Integer> TELEPORT_CRYSTAL_IDS = Arrays.asList(ItemID.MOURNING_TELEPORT_CRYSTAL_1, ItemID.MOURNING_TELEPORT_CRYSTAL_2, ItemID.MOURNING_TELEPORT_CRYSTAL_3, ItemID.MOURNING_TELEPORT_CRYSTAL_4, ItemID.MOURNING_TELEPORT_CRYSTAL_5);
    private static final int BASE_TELEPORT_CRYSTAL_ID = ItemID.MOURNING_TELEPORT_CRYSTAL_1;
    public List<Integer> getTeleportCrystalIds() {
        return TELEPORT_CRYSTAL_IDS;
    }    public boolean isTeleportCrystal(int itemId) {
        return TELEPORT_CRYSTAL_IDS.contains(itemId);
    }

    public static final List<Integer> SKILLS_NECKLACE_IDS = Arrays.asList(ItemID.JEWL_NECKLACE_OF_SKILLS_1, ItemID.JEWL_NECKLACE_OF_SKILLS_2, ItemID.JEWL_NECKLACE_OF_SKILLS_3, ItemID.JEWL_NECKLACE_OF_SKILLS_4, ItemID.JEWL_NECKLACE_OF_SKILLS_5, ItemID.JEWL_NECKLACE_OF_SKILLS_6);
    
    // Bottomless compost bucket variants (empty and all filled states)
    // These IDs should match ItemID.java constants:
    // BOTTOMLESS_COMPOST_BUCKET (empty), and filled variants 22994-22998
    private static final List<Integer> BOTTOMLESS_COMPOST_BUCKET_IDS = Arrays.asList(
        ItemID.BOTTOMLESS_COMPOST_BUCKET, // Empty
        22994, // Filled variant 1
        22995, // Filled variant 2
        22996, // Filled variant 3
        22997, // Filled variant 4
        22998  // Filled variant 5
    );
    private static final int BASE_SKILLS_NECKLACE_ID = ItemID.JEWL_NECKLACE_OF_SKILLS_1;
    public List<Integer> getSkillsNecklaceIds() {
        return SKILLS_NECKLACE_IDS;
    }    public boolean isSkillsNecklace(int itemId) {
        return SKILLS_NECKLACE_IDS.contains(itemId);
    }

    public static final List<Integer> EXPLORERS_RING_IDS = Arrays.asList(ItemID.LUMBRIDGE_RING_MEDIUM, ItemID.LUMBRIDGE_RING_HARD, ItemID.LUMBRIDGE_RING_ELITE);
    private static final int BASE_EXPLORERS_RING_ID = ItemID.LUMBRIDGE_RING_MEDIUM;
    public List<Integer> getExplorersRingIds() {
        return EXPLORERS_RING_IDS;
    }
    public boolean isExplorersRing(int itemId) {
        return EXPLORERS_RING_IDS.contains(itemId);
    }

    public static final List<Integer> ARDY_CLOAK_IDS = Arrays.asList(ItemID.ARDY_CAPE_MEDIUM, ItemID.ARDY_CAPE_HARD, ItemID.ARDY_CAPE_ELITE);
    private static final int BASE_ARDY_CLOAK_ID = ItemID.ARDY_CAPE_MEDIUM;
    public List<Integer> getArdyCloakIds() {
        return ARDY_CLOAK_IDS;
    }
    public boolean isArdyCloak(int itemId) {
        return ARDY_CLOAK_IDS.contains(itemId);
    }

    public static final List<Integer> WATERING_CAN_IDS = Constants.WATERING_CAN_IDS;
    private static final int BASE_WATERING_CAN_ID = Constants.WATERING_CAN_IDS.get(0);
    public List<Integer> getWateringCanIds() {
        return WATERING_CAN_IDS;
    }
    public boolean isWateringCan(int itemId) {
        return WATERING_CAN_IDS.contains(itemId);
    }


    public List<Integer> getHerbPatchIds() {
        return Constants.HERB_PATCH_IDS;
    }
    private static final List<Integer> HERB_SEED_IDS = Arrays.asList(
        ItemID.GUAM_SEED, ItemID.MARRENTILL_SEED, ItemID.TARROMIN_SEED, ItemID.HARRALANDER_SEED,
        ItemID.RANARR_SEED, ItemID.TOADFLAX_SEED, ItemID.IRIT_SEED, ItemID.AVANTOE_SEED,
        ItemID.KWUARM_SEED, ItemID.SNAPDRAGON_SEED, ItemID.CADANTINE_SEED, ItemID.LANTADYME_SEED,
        ItemID.DWARF_WEED_SEED, ItemID.TORSTOL_SEED, ItemID.HUASCA_SEED
    );
    private static final int BASE_SEED_ID = ItemID.GUAM_SEED;
    public List<Integer> getHerbSeedIds() {
        return HERB_SEED_IDS;
    }
    private boolean isHerbSeed(int itemId) {
        return HERB_SEED_IDS.contains(itemId);
    }


    public List<Integer> getFlowerPatchIds() {
        return Constants.FLOWER_PATCH_IDS;
    }

    @Deprecated
    public List<Integer> getAllotmentPatchIds() {
        // Deprecated: Use getAllotmentPatchIdsForLocation() instead
        // Returns Ardougne patches for backward compatibility
        return Constants.ALLOTMENT_PATCH_IDS_BY_LOCATION.getOrDefault("Ardougne", Collections.emptyList());
    }
    
    /**
     * Gets allotment patch IDs for a specific location.
     * @param locationName The name of the location
     * @return List of patch object IDs [north patch, south patch], or empty list if location has no allotment patches
     */
    public List<Integer> getAllotmentPatchIdsForLocation(String locationName) {
        return Constants.ALLOTMENT_PATCH_IDS_BY_LOCATION.getOrDefault(locationName, Collections.emptyList());
    }
    
    /**
     * Gets herb patch ID for a specific location.
     * @param locationName The name of the location
     * @return The patch object ID, or null if location has no herb patch
     */
    public Integer getHerbPatchIdForLocation(String locationName) {
        return Constants.HERB_PATCH_IDS_BY_LOCATION.get(locationName);
    }
    
    /**
     * Gets flower patch ID for a specific location.
     * @param locationName The name of the location
     * @return The patch object ID, or null if location has no flower patch
     */
    public Integer getFlowerPatchIdForLocation(String locationName) {
        return Constants.FLOWER_PATCH_IDS_BY_LOCATION.get(locationName);
    }
    private static final List<Integer> ALLOTMENT_SEED_IDS = Arrays.asList(
        ItemID.POTATO_SEED, ItemID.ONION_SEED, ItemID.CABBAGE_SEED, ItemID.TOMATO_SEED,
        ItemID.SWEETCORN_SEED, ItemID.STRAWBERRY_SEED, ItemID.WATERMELON_SEED, ItemID.SNAPE_GRASS_SEED
    );
    private static final int BASE_ALLOTMENT_SEED_ID = ItemID.SNAPE_GRASS_SEED;
    public List<Integer> getAllotmentSeedIds() {
        return Constants.ALLOTMENT_SEED_IDS;
    }
    private boolean isAllotmentSeed(int itemId) {
        return Constants.isAllotmentSeed(itemId);
    }

    public List<Integer> getTreePatchIds() {
        return Constants.TREE_PATCH_IDS;
    }
    private static final List<Integer> TREE_SAPLING_IDS = Arrays.asList(ItemID.PLANTPOT_OAK_SAPLING, ItemID.PLANTPOT_WILLOW_SAPLING,ItemID.PLANTPOT_MAPLE_SAPLING,ItemID.PLANTPOT_YEW_SAPLING,ItemID.PLANTPOT_MAGIC_TREE_SAPLING);
    private static final int BASE_SAPLING_ID = ItemID.PLANTPOT_OAK_SAPLING;
    public List<Integer> getTreeSaplingIds() {
        return TREE_SAPLING_IDS;
    }
    private boolean isTreeSapling(int itemId) {return TREE_SAPLING_IDS.contains(itemId);}


    public List<Integer> getFruitTreePatchIds() {
        return Constants.FRUIT_TREE_PATCH_IDS;
    }
    private static final List<Integer> FRUIT_TREE_SAPLING_IDS = Arrays.asList(ItemID.PLANTPOT_APPLE_SAPLING, ItemID.PLANTPOT_BANANA_SAPLING,ItemID.PLANTPOT_ORANGE_SAPLING,ItemID.PLANTPOT_CURRY_SAPLING,ItemID.PLANTPOT_PINEAPPLE_SAPLING,ItemID.PLANTPOT_PAPAYA_SAPLING,ItemID.PLANTPOT_PALM_SAPLING, ItemID.PLANTPOT_DRAGONFRUIT_SAPLING);
    private static final int BASE_FRUIT_SAPLING_ID = ItemID.PLANTPOT_APPLE_SAPLING;
    public List<Integer> getFruitTreeSaplingIds() {return FRUIT_TREE_SAPLING_IDS;}
    private boolean isFruitTreeSapling(int itemId) {return FRUIT_TREE_SAPLING_IDS.contains(itemId);}


    public static final List<Integer> RUNE_POUCH_ID = Arrays.asList(ItemID.BH_RUNE_POUCH, ItemID.DIVINE_RUNE_POUCH);

    public static final List<Integer> RUNE_POUCH_AMOUNT_VARBITS = Arrays.asList(VarbitID.RUNE_POUCH_QUANTITY_1, VarbitID.RUNE_POUCH_QUANTITY_2, VarbitID.RUNE_POUCH_QUANTITY_3, VarbitID.RUNE_POUCH_QUANTITY_4);

    public static final List<Integer> RUNE_POUCH_RUNE_VARBITS = Arrays.asList(VarbitID.RUNE_POUCH_TYPE_1, VarbitID.RUNE_POUCH_TYPE_2, VarbitID.RUNE_POUCH_TYPE_3, VarbitID.RUNE_POUCH_TYPE_4);

    private static final Map<Integer, List<Integer>> COMBINATION_RUNE_SUBRUNES_MAP;

    private static final Map<Integer, List<Integer>> STAFF_RUNES_MAP;
    
    private static final int STAFF_RUNE_AMOUNT = 999; // Large amount to satisfy requirements without overflow

    static {
        Map<Integer, List<Integer>> tempMap = new HashMap<>();
        tempMap.put(ItemID.DUSTRUNE, Arrays.asList(ItemID.AIRRUNE, ItemID.EARTHRUNE));
        tempMap.put(ItemID.MISTRUNE, Arrays.asList(ItemID.AIRRUNE, ItemID.WATERRUNE));
        tempMap.put(ItemID.MUDRUNE, Arrays.asList(ItemID.WATERRUNE, ItemID.EARTHRUNE));
        tempMap.put(ItemID.LAVARUNE, Arrays.asList(ItemID.FIRERUNE, ItemID.EARTHRUNE));
        tempMap.put(ItemID.STEAMRUNE, Arrays.asList(ItemID.FIRERUNE, ItemID.WATERRUNE));
        tempMap.put(ItemID.SMOKERUNE, Arrays.asList(ItemID.FIRERUNE, ItemID.AIRRUNE));
        COMBINATION_RUNE_SUBRUNES_MAP = Collections.unmodifiableMap(tempMap);
        
        // Staff to rune mapping - Elemental staffs
        Map<Integer, List<Integer>> staffMap = new HashMap<>();
        
        // Air staffs
        staffMap.put(ItemID.STAFF_OF_AIR, Arrays.asList(ItemID.AIRRUNE));
        staffMap.put(ItemID.AIR_BATTLESTAFF, Arrays.asList(ItemID.AIRRUNE));
        staffMap.put(ItemID.MYSTIC_AIR_STAFF, Arrays.asList(ItemID.AIRRUNE));
        
        // Water staffs
        staffMap.put(ItemID.STAFF_OF_WATER, Arrays.asList(ItemID.WATERRUNE));
        staffMap.put(ItemID.WATER_BATTLESTAFF, Arrays.asList(ItemID.WATERRUNE));
        staffMap.put(ItemID.MYSTIC_WATER_STAFF, Arrays.asList(ItemID.WATERRUNE));
        
        // Earth staffs
        staffMap.put(ItemID.STAFF_OF_EARTH, Arrays.asList(ItemID.EARTHRUNE));
        staffMap.put(ItemID.EARTH_BATTLESTAFF, Arrays.asList(ItemID.EARTHRUNE));
        staffMap.put(ItemID.MYSTIC_EARTH_STAFF, Arrays.asList(ItemID.EARTHRUNE));
        
        // Fire staffs
        staffMap.put(ItemID.STAFF_OF_FIRE, Arrays.asList(ItemID.FIRERUNE));
        staffMap.put(ItemID.FIRE_BATTLESTAFF, Arrays.asList(ItemID.FIRERUNE));
        staffMap.put(ItemID.MYSTIC_FIRE_STAFF, Arrays.asList(ItemID.FIRERUNE));
        
        // Combination staffs - Lava (Fire + Earth)
        staffMap.put(ItemID.LAVA_BATTLESTAFF, Arrays.asList(ItemID.FIRERUNE, ItemID.EARTHRUNE));
        staffMap.put(ItemID.MYSTIC_LAVA_STAFF, Arrays.asList(ItemID.FIRERUNE, ItemID.EARTHRUNE));
        
        // Combination staffs - Steam (Fire + Water)
        staffMap.put(ItemID.STEAM_BATTLESTAFF, Arrays.asList(ItemID.FIRERUNE, ItemID.WATERRUNE));
        staffMap.put(ItemID.MYSTIC_STEAM_BATTLESTAFF, Arrays.asList(ItemID.FIRERUNE, ItemID.WATERRUNE));
        
        // Combination staffs - Mist (Air + Water)
        staffMap.put(ItemID.MIST_BATTLESTAFF, Arrays.asList(ItemID.AIRRUNE, ItemID.WATERRUNE));
        staffMap.put(ItemID.MYSTIC_MIST_BATTLESTAFF, Arrays.asList(ItemID.AIRRUNE, ItemID.WATERRUNE));
        
        // Combination staffs - Dust (Air + Earth)
        staffMap.put(ItemID.DUST_BATTLESTAFF, Arrays.asList(ItemID.AIRRUNE, ItemID.EARTHRUNE));
        staffMap.put(ItemID.MYSTIC_DUST_BATTLESTAFF, Arrays.asList(ItemID.AIRRUNE, ItemID.EARTHRUNE));
        
        // Combination staffs - Smoke (Fire + Air)
        staffMap.put(ItemID.SMOKE_BATTLESTAFF, Arrays.asList(ItemID.FIRERUNE, ItemID.AIRRUNE));
        staffMap.put(ItemID.MYSTIC_SMOKE_BATTLESTAFF, Arrays.asList(ItemID.FIRERUNE, ItemID.AIRRUNE));
        
        // Combination staffs - Mud (Water + Earth)
        staffMap.put(ItemID.MUD_BATTLESTAFF, Arrays.asList(ItemID.WATERRUNE, ItemID.EARTHRUNE));
        staffMap.put(ItemID.MYSTIC_MUD_STAFF, Arrays.asList(ItemID.WATERRUNE, ItemID.EARTHRUNE));
        
        STAFF_RUNES_MAP = Collections.unmodifiableMap(staffMap);
    }

    private int getRuneItemIdFromVarbitValue(int varbitValue) {
        switch (varbitValue) {
            case 1:
                return ItemID.AIRRUNE;
            case 2:
                return ItemID.WATERRUNE;
            case 3:
                return ItemID.EARTHRUNE;
            case 4:
                return ItemID.FIRERUNE;
            case 5:
                return ItemID.MINDRUNE;
            case 6:
                return ItemID.CHAOSRUNE;
            case 7:
                return ItemID.DEATHRUNE;
            case 8:
                return ItemID.BLOODRUNE;
            case 9:
                return ItemID.COSMICRUNE;
            case 10:
                return ItemID.NATURERUNE;
            case 11:
                return ItemID.LAWRUNE;
            case 12:
                return ItemID.BODYRUNE;
            case 13:
                return ItemID.SOULRUNE;
            case 14:
                return ItemID.ASTRALRUNE;
            case 15:
                return ItemID.MISTRUNE;
            case 16:
                return ItemID.MUDRUNE;
            case 17:
                return ItemID.DUSTRUNE;
            case 18:
                return ItemID.LAVARUNE;
            case 19:
                return ItemID.STEAMRUNE;
            case 20:
                return ItemID.SMOKERUNE;
            case 21:
                return ItemID.WRATHRUNE;
            // Add more cases for other runes
            default:
                return -1;
        }
    }

    private Map<Integer, Integer> getRunePouchContentsVarbits() {
        Map<Integer, Integer> runePouchContents = new HashMap<>();

        for (int i = 0; i < RUNE_POUCH_RUNE_VARBITS.size(); i++) {
            int runeVarbitValue = client.getVarbitValue(RUNE_POUCH_RUNE_VARBITS.get(i));
            int runeAmount = client.getVarbitValue(RUNE_POUCH_AMOUNT_VARBITS.get(i));

            int runeId = getRuneItemIdFromVarbitValue(runeVarbitValue);

            if (runeId != -1 && runeAmount > 0) {
                handleCombinationRunes(runeId, runeAmount, runePouchContents);
            }
        }
        return runePouchContents;
    }

    private Map<Integer, Integer> buildExpandedRuneMap(Item[] items) {
        // Start with rune pouch contents
        Map<Integer, Integer> expandedRuneMap = new HashMap<>(getRunePouchContentsVarbits());
        
        // Add combination runes from inventory
        for (Item item : items) {
            if (item != null) {
                int itemIdRune = item.getId();
                int itemQuantity = item.getQuantity();

                if (COMBINATION_RUNE_SUBRUNES_MAP.containsKey(itemIdRune)) {
                    List<Integer> subRunes = COMBINATION_RUNE_SUBRUNES_MAP.get(itemIdRune);
                    for (int subRune : subRunes) {
                        expandedRuneMap.put(subRune, expandedRuneMap.getOrDefault(subRune, 0) + itemQuantity);
                    }
                } else if (STAFF_RUNES_MAP.containsKey(itemIdRune)) {
                    // Handle staffs - add their runes with large amount
                    List<Integer> staffRunes = STAFF_RUNES_MAP.get(itemIdRune);
                    for (int rune : staffRunes) {
                        // Use max to ensure we always have enough, but cap at STAFF_RUNE_AMOUNT to avoid overflow
                        expandedRuneMap.put(rune, Math.max(expandedRuneMap.getOrDefault(rune, 0), STAFF_RUNE_AMOUNT));
                    }
                } else {
                    // Add regular runes from inventory
                    expandedRuneMap.put(itemIdRune, expandedRuneMap.getOrDefault(itemIdRune, 0) + itemQuantity);
                }
            }
        }
        
        // Add staffs from equipped items
        Map<Integer, Integer> equippedItems = getEquippedItems();
        for (Map.Entry<Integer, Integer> equippedEntry : equippedItems.entrySet()) {
            int equippedItemId = equippedEntry.getKey();
            if (STAFF_RUNES_MAP.containsKey(equippedItemId)) {
                List<Integer> staffRunes = STAFF_RUNES_MAP.get(equippedItemId);
                for (int rune : staffRunes) {
                    // Use max to ensure we always have enough, but cap at STAFF_RUNE_AMOUNT to avoid overflow
                    expandedRuneMap.put(rune, Math.max(expandedRuneMap.getOrDefault(rune, 0), STAFF_RUNE_AMOUNT));
                }
            }
        }
        
        return expandedRuneMap;
    }

    @Inject
    public EasyFarmingOverlay(Client client, EasyFarmingPlugin plugin, ItemManager itemManager, HerbRunItemAndLocation herbRunItemAndLocation, TreeRunItemAndLocation treeRunItemAndLocation, FruitTreeRunItemAndLocation fruitTreeRunItemAndLocation) {
        this.client = client;
        this.plugin = plugin;
        this.itemManager = itemManager;
        this.herbRunItemAndLocation = herbRunItemAndLocation;
        this.treeRunItemAndLocation = treeRunItemAndLocation;
        this.fruitTreeRunItemAndLocation = fruitTreeRunItemAndLocation;
        setPosition(OverlayPosition.BOTTOM_RIGHT);
        setLayer(OverlayLayer.ABOVE_SCENE);
    }

    private void handleCombinationRunes(int runeId, int runeAmount, Map<Integer, Integer> runePouchContents) {
        if (COMBINATION_RUNE_SUBRUNES_MAP.containsKey(runeId)) {
            List<Integer> subRunes = COMBINATION_RUNE_SUBRUNES_MAP.get(runeId);
            for (int subRune : subRunes) {
                runePouchContents.put(subRune, runePouchContents.getOrDefault(subRune, 0) + runeAmount);
            }
        } else {
            runePouchContents.put(runeId, runeAmount);
        }
    }
    public Integer checkToolLep(Integer item) {
        if(item == ItemID.BUCKET_COMPOST) {
            return client.getVarbitValue(1442);
        }
        if(item == ItemID.BUCKET_SUPERCOMPOST) {
            return client.getVarbitValue(1443);
        }
        if (item == ItemID.BUCKET_ULTRACOMPOST) {
            return client.getVarbitValue(5732);
        }
        if (item == ItemID.BOTTOMLESS_COMPOST_BUCKET) {
            if (client.getVarbitValue(7915) != 0) {
                return 1;
            }
        }
        return 0;
    }

    // Helper method to get charges from necklace ID
    private int getSkillsNecklaceCharges(int itemId) {
        switch (itemId) {
            case ItemID.JEWL_NECKLACE_OF_SKILLS_1: return 1;
            case ItemID.JEWL_NECKLACE_OF_SKILLS_2: return 2;
            case ItemID.JEWL_NECKLACE_OF_SKILLS_3: return 3;
            case ItemID.JEWL_NECKLACE_OF_SKILLS_4: return 4;
            case ItemID.JEWL_NECKLACE_OF_SKILLS_5: return 5;
            case ItemID.JEWL_NECKLACE_OF_SKILLS_6: return 6;
            default: return 0;
        }
    }

    public boolean isQuetzalWhistle(int itemId) {
        return itemId == ItemID.HG_QUETZALWHISTLE_BASIC || 
               itemId == ItemID.HG_QUETZALWHISTLE_ENHANCED || 
               itemId == ItemID.HG_QUETZALWHISTLE_PERFECTED;
    }

    public boolean isRoyalSeedPod(int itemId) {
        return itemId == ItemID.MM2_ROYAL_SEED_POD;
    }

    public boolean isEctophial(int itemId) {
        return itemId == ItemID.ECTOPHIAL;
    }

    /**
     * Scans equipped items and returns a map of item IDs to their counts.
     * Equipped items are counted as 1 each (equipment slots can only hold 1 item).
     * Uses PlayerComposition.getEquipmentId(KitType) with KitType enum constants.
     */
    private Map<Integer, Integer> getEquippedItems() {
        Map<Integer, Integer> equippedItems = new HashMap<>();
        
        Player localPlayer = client.getLocalPlayer();
        if (localPlayer == null) {
            return equippedItems;
        }
        
        PlayerComposition playerComposition = localPlayer.getPlayerComposition();
        if (playerComposition == null) {
            return equippedItems;
        }
        
        // Scan through all KitType enum values to get equipped items
        for (KitType kitType : KitType.values()) {
            int itemId = playerComposition.getEquipmentId(kitType);
            if (itemId > 0) {
                // Count each equipped item as 1
                equippedItems.put(itemId, equippedItems.getOrDefault(itemId, 0) + 1);
            }
        }
        
        return equippedItems;
    }

    public Map<Integer, Integer> itemsToCheck;
    @Override
    public Dimension render(Graphics2D graphics) {
        if (plugin.isOverlayActive() && !plugin.areItemsCollected()) {
            if (!plugin.isOverlayActive()) {
                return null;
            }
            plugin.addTextToInfoBox("Grab all the items needed");
            // List of items to check
            Map<Integer, Integer> itemsToCheck = null;
            if(plugin.getFarmingTeleportOverlay().herbRun) {
                itemsToCheck = herbRunItemAndLocation.getHerbItems();
            }
            if(plugin.getFarmingTeleportOverlay().treeRun) {
                itemsToCheck = treeRunItemAndLocation.getTreeItems();
            }
            if(plugin.getFarmingTeleportOverlay().fruitTreeRun) {
                itemsToCheck = fruitTreeRunItemAndLocation.getFruitTreeItems();
            }

            if (itemsToCheck == null || itemsToCheck.isEmpty()) {
                return null;
            }

            ItemContainer inventory = client.getItemContainer(InventoryID.INV);

            Item[] items;
            if (inventory == null || inventory.getItems() == null) {
                items = new Item[0];
            } else {
                items = inventory.getItems();
            }

            // Build expanded rune map once before any requirement checks
            Map<Integer, Integer> expandedRuneMap = buildExpandedRuneMap(items);

            int teleportCrystalCount = 0;
            for (Item item : items) {
                if (isTeleportCrystal(item.getId())) {
                    teleportCrystalCount += item.getQuantity();
                    break;
                }
            }
            int skillsNecklaceCharges = 0;
            // Count charges from inventory
            for (Item item : items) {
                if (isSkillsNecklace(item.getId())) {
                    int charges = getSkillsNecklaceCharges(item.getId());
                    skillsNecklaceCharges += charges * item.getQuantity();
                }
            }
            // Count charges from equipped items
            Map<Integer, Integer> equippedItems = getEquippedItems();
            for (Map.Entry<Integer, Integer> equippedEntry : equippedItems.entrySet()) {
                int equippedItemId = equippedEntry.getKey();
                if (isSkillsNecklace(equippedItemId)) {
                    int charges = getSkillsNecklaceCharges(equippedItemId);
                    skillsNecklaceCharges += charges;
                }
            }
            int quetzalWhistleCount = 0;
            for (Item item : items) {
                if (isQuetzalWhistle(item.getId())) {
                    quetzalWhistleCount += item.getQuantity();
                }
            }

            int totalSeeds = 0;
            int totalAllotmentSeeds = 0;
            if(plugin.getFarmingTeleportOverlay().herbRun) {
                for (Item item : items) {
                    if (isHerbSeed(item.getId())) {
                        totalSeeds += item.getQuantity();
                    }
                    if (isAllotmentSeed(item.getId())) {
                        totalAllotmentSeeds += item.getQuantity();
                    }
                }
            }
            if(plugin.getFarmingTeleportOverlay().treeRun) {
                for (Item item : items) {
                    if (isTreeSapling(item.getId())) {
                        totalSeeds += item.getQuantity();
                    }
                }
            }
            if(plugin.getFarmingTeleportOverlay().fruitTreeRun) {
                for (Item item : items) {
                    if (isFruitTreeSapling(item.getId())) {
                        totalSeeds += item.getQuantity();
                    }
                }
            }

            panelComponent.getChildren().clear();
            int yOffset = 0;

            // Single inventory scan to build comprehensive item count map (including rune pouch expansions)
            Map<Integer, Integer> inventoryItemCounts = new HashMap<>();
            boolean hasRunePouch = false;
            
            // First pass: scan inventory for regular items and check for rune pouch
            for (Item item : items) {
                if (item != null) {
                    int itemId = item.getId();
                    int itemQuantity = item.getQuantity();
                    
                    // Check if this is a rune pouch
                    if (RUNE_POUCH_ID.contains(itemId)) {
                        hasRunePouch = true;
                    }
                    
                    if (COMBINATION_RUNE_SUBRUNES_MAP.containsKey(itemId)) {
                        // Handle combination runes
                        List<Integer> subRunes = COMBINATION_RUNE_SUBRUNES_MAP.get(itemId);
                        for (int subRune : subRunes) {
                            inventoryItemCounts.put(subRune, inventoryItemCounts.getOrDefault(subRune, 0) + itemQuantity);
                        }
                    } else if (STAFF_RUNES_MAP.containsKey(itemId)) {
                        // Handle staffs - add their runes with large amount
                        List<Integer> staffRunes = STAFF_RUNES_MAP.get(itemId);
                        for (int rune : staffRunes) {
                            // Use max to ensure we always have enough, but cap at STAFF_RUNE_AMOUNT to avoid overflow
                            inventoryItemCounts.put(rune, Math.max(inventoryItemCounts.getOrDefault(rune, 0), STAFF_RUNE_AMOUNT));
                        }
                    } else {
                        // Handle regular items
                        inventoryItemCounts.put(itemId, itemQuantity);
                    }
                }
            }
            
            // Second pass: if rune pouch exists, add expanded rune map contents to inventory counts
            if (hasRunePouch) {
                for (Map.Entry<Integer, Integer> runeEntry : expandedRuneMap.entrySet()) {
                    int runeId = runeEntry.getKey();
                    int runeCount = runeEntry.getValue();
                    inventoryItemCounts.put(runeId, inventoryItemCounts.getOrDefault(runeId, 0) + runeCount);
                }
            }
            
            // Third pass: add equipped items to inventory counts
            // Note: equippedItems was already retrieved above for skills necklace charges
            for (Map.Entry<Integer, Integer> equippedEntry : equippedItems.entrySet()) {
                int equippedItemId = equippedEntry.getKey();
                int equippedCount = equippedEntry.getValue();
                
                // Check if equipped item is a staff
                if (STAFF_RUNES_MAP.containsKey(equippedItemId)) {
                    // Handle staffs - add their runes with large amount
                    List<Integer> staffRunes = STAFF_RUNES_MAP.get(equippedItemId);
                    for (int rune : staffRunes) {
                        // Use max to ensure we always have enough, but cap at STAFF_RUNE_AMOUNT to avoid overflow
                        inventoryItemCounts.put(rune, Math.max(inventoryItemCounts.getOrDefault(rune, 0), STAFF_RUNE_AMOUNT));
                    }
                } else {
                    // Handle regular equipped items
                    inventoryItemCounts.put(equippedItemId, inventoryItemCounts.getOrDefault(equippedItemId, 0) + equippedCount);
                }
            }

            List<AbstractMap.SimpleEntry<Integer, Integer>> missingItemsWithCounts = new ArrayList<>();
            boolean allItemsCollected = true;
            for (Map.Entry<Integer, Integer> entry : itemsToCheck.entrySet()) {
                int itemId = entry.getKey();
                int count = entry.getValue();

                // Start with inventory count from single scan
                int inventoryCount = inventoryItemCounts.getOrDefault(itemId, 0);
                
                // Special handling for bottomless compost bucket - check for filled variants in inventory
                if (itemId == ItemID.BOTTOMLESS_COMPOST_BUCKET) {
                    // Check inventory for any bottomless bucket variant (empty or filled)
                    for (Item item : items) {
                        if (item != null && BOTTOMLESS_COMPOST_BUCKET_IDS.contains(item.getId())) {
                            inventoryCount = 1;
                            break;
                        }
                    }
                }
                
                // Add tool lep count
                int toolLepCount = checkToolLep(itemId);
                if (toolLepCount > 0) {
                    inventoryCount += toolLepCount;
                }
                
                // Apply run-specific and item-specific overrides in order
                if (plugin.getFarmingTeleportOverlay().herbRun && itemId == BASE_SEED_ID) {
                    inventoryCount = totalSeeds;
                } else if (plugin.getFarmingTeleportOverlay().herbRun && itemId == BASE_ALLOTMENT_SEED_ID) {
                    inventoryCount = totalAllotmentSeeds;
                } else if (plugin.getFarmingTeleportOverlay().treeRun && itemId == BASE_SAPLING_ID) {
                    inventoryCount = totalSeeds;
                } else if (plugin.getFarmingTeleportOverlay().fruitTreeRun && itemId == BASE_FRUIT_SAPLING_ID) {
                    inventoryCount = totalSeeds;
                } else if (itemId == BASE_TELEPORT_CRYSTAL_ID) {
                    inventoryCount = teleportCrystalCount;
                } else if (itemId == BASE_SKILLS_NECKLACE_ID) {
                    // Skills necklace requirement is in charges, not number of items
                    inventoryCount = skillsNecklaceCharges;
                } else if (itemId == ItemID.HG_QUETZALWHISTLE_BASIC) {
                    inventoryCount = quetzalWhistleCount;
                } else if (itemId == BASE_EXPLORERS_RING_ID) {
                    // Check if any Explorer's Ring variant is equipped or in inventory
                    // inventoryItemCounts already includes equipped items from the third pass
                    boolean hasExplorersRing = false;
                    for (int ringId : EXPLORERS_RING_IDS) {
                        if (inventoryItemCounts.containsKey(ringId) && inventoryItemCounts.get(ringId) > 0) {
                            hasExplorersRing = true;
                            break;
                        }
                    }
                    inventoryCount = hasExplorersRing ? 1 : 0;
                } else if (itemId == BASE_ARDY_CLOAK_ID) {
                    // Check if any Ardougne Cloak variant is equipped or in inventory
                    // inventoryItemCounts already includes equipped items from the third pass
                    boolean hasArdyCloak = false;
                    for (int cloakId : ARDY_CLOAK_IDS) {
                        if (inventoryItemCounts.containsKey(cloakId) && inventoryItemCounts.get(cloakId) > 0) {
                            hasArdyCloak = true;
                            break;
                        }
                    }
                    inventoryCount = hasArdyCloak ? 1 : 0;
                } else if (itemId == BASE_WATERING_CAN_ID) {
                    // Check if any watering can variant is equipped or in inventory
                    // inventoryItemCounts already includes equipped items from the third pass
                    boolean hasWateringCan = false;
                    for (int canId : WATERING_CAN_IDS) {
                        if (inventoryItemCounts.containsKey(canId) && inventoryItemCounts.get(canId) > 0) {
                            hasWateringCan = true;
                            break;
                        }
                    }
                    inventoryCount = hasWateringCan ? 1 : 0;
                }

                // Rune pouch contents are already included in inventoryItemCounts

                if (inventoryCount < count) {
                    allItemsCollected = false;
                    int missingCount = count - inventoryCount;
                    BufferedImage itemImage = itemManager.getImage(itemId);
                    if (itemImage != null) {
                        ImageComponent imageComponent = new ImageComponent(itemImage);
                        panelComponent.getChildren().add(imageComponent);

                        // Add the missing item and count to the list
                        missingItemsWithCounts.add(new AbstractMap.SimpleEntry<>(itemId, missingCount));

                        yOffset += itemImage.getHeight() + 2; // Update yOffset for the next item
                    }
                }
            }
            plugin.setTeleportOverlayActive(allItemsCollected);
            Dimension panelSize = panelComponent.render(graphics);

            // Draw item count on top of the overlay
            yOffset = 0;
            for (AbstractMap.SimpleEntry<Integer, Integer> pair : missingItemsWithCounts) {
                int itemId = pair.getKey();
                int missingCount = pair.getValue();

                BufferedImage itemImage = itemManager.getImage(itemId);
                if (itemImage != null) {
                    // Draw item count
                    if (missingCount > 1) {
                        String countText = Integer.toString(missingCount);
                        int textX = 2; // Calculate X position for the count text
                        int textY = yOffset + 15; // Calculate Y position for the count text
                        graphics.setColor(Color.WHITE);
                        graphics.drawString(countText, textX, textY);
                    }

                    yOffset += itemImage.getHeight() + 2; // Update yOffset for the next item
                }
            }
            // Check if all items have been collected
            if (missingItemsWithCounts.isEmpty()) {
                plugin.setItemsCollected(true);
            } else {
                plugin.setItemsCollected(false);
            }

            return panelSize;
        }
        return null;
    }
}
package com.easyfarming;

import net.runelite.api.Client;

import java.util.Arrays;
import java.util.List;
import java.util.stream.Collectors;
import java.util.stream.Stream;

public class HerbPatchChecker {
    public enum Herb {
        //Order of lists is "growing, diseased, harvest"
        GUAM(Arrays.asList(4,5,6,7), Arrays.asList(128,129,130), Arrays.asList(8,9,10)),
        MARRENTILL(Arrays.asList(11,12,13,14), Arrays.asList(131,132,133), Arrays.asList(15,16,17)),
        TARROMIN(Arrays.asList(18,19,20,21), Arrays.asList(134,135,136), Arrays.asList(22,23,24)),
        HARRALANDER(Arrays.asList(25,26,27,28), Arrays.asList(137,138,139), Arrays.asList(29,30,31)),
        RANARR(Arrays.asList(32,33,34,35), Arrays.asList(140,141,142), Arrays.asList(36,37,38)),
        TOADFLAX(Arrays.asList(39,40,41,42), Arrays.asList(143,144,145), Arrays.asList(43,44,45)),
        IRIT(Arrays.asList(46,47,48,49), Arrays.asList(146,147,148), Arrays.asList(50,51,52)),
        AVANTOE(Arrays.asList(53,54,55,56), Arrays.asList(149,159,151), Arrays.asList(57,58,59)),
        KWUARM(Arrays.asList(68,69,70,71), Arrays.asList(152,153,154), Arrays.asList(72,73,74)),
        SNAPDRAGON(Arrays.asList(75,76,77,78), Arrays.asList(155,156,157), Arrays.asList(79,80,81)),
        CADANTINE(Arrays.asList(82,83,84,85), Arrays.asList(158,159,160), Arrays.asList(86,87,88)),
        LANTADYME(Arrays.asList(89,90,91,92), Arrays.asList(161,162,163), Arrays.asList(93,94,95)),
        DWARF_WEED(Arrays.asList(96,97,98,99), Arrays.asList(164,165,166), Arrays.asList(100,101,102)),
        TORSTOL(Arrays.asList(103,104,105,106), Arrays.asList(167,168,169), Arrays.asList(107,108,109));

        private final List<Integer> growing;
        private final List<Integer> diseased;
        private final List<Integer> harvest;

        Herb(List<Integer> growing, List<Integer> diseased, List<Integer> harvest) {
            this.growing = growing;
            this.diseased = diseased;
            this.harvest = harvest;
        }
        public List<Integer> getGrowing() {
            return growing;
        }

        public List<Integer> getDead() {
            return diseased;
        }

        public List<Integer> getHarvest() {
            return harvest;
        }
    }

    // Combine all growing and dead varbit values into single lists
    private static final List<Integer> growing = Stream.of(Herb.values())
            .flatMap(herb -> herb.getGrowing().stream())
            .collect(Collectors.toList());

    private static final List<Integer> diseased = Stream.of(Herb.values())
            .flatMap(herb -> herb.getDead().stream())
            .collect(Collectors.toList());

    private static final List<Integer> harvest = Stream.of(Herb.values())
            .flatMap(herb -> herb.getHarvest().stream())
            .collect(Collectors.toList());

    private static final List<Integer> WEEDS = Arrays.asList(0, 1, 2);
    private static final List<Integer> DEAD = Arrays.asList(170, 171, 172);

    public static PlantState checkHerbPatch(Client client, int varbitIndex) {
        int varbitValue = client.getVarbitValue(varbitIndex);

        if (growing.contains(varbitValue)) {
            return PlantState.GROWING;
        } else if (diseased.contains(varbitValue)) {
            return PlantState.DISEASED;
        } else if (harvest.contains(varbitValue)) {
            return PlantState.HARVESTABLE;
        } else if (WEEDS.contains(varbitValue)) {
            return PlantState.WEEDS;
        } else if (DEAD.contains(varbitValue)) {
            return PlantState.DEAD;
        } else if (varbitValue == 3) {
            return PlantState.PLANT;
        } else {
            return PlantState.UNKNOWN;
        }
    }
    public enum PlantState {
        GROWING,
        DISEASED,
        HARVESTABLE,
        WEEDS,
        DEAD,
        PLANT,
        UNKNOWN
    }

}

package com.easyfarming.locations;

import com.easyfarming.EasyFarmingConfig;
import com.easyfarming.ItemRequirement;
import com.easyfarming.core.Teleport;
import net.runelite.api.coords.WorldPoint;
import net.runelite.api.gameval.ItemID;

import java.util.Collections;
import java.util.List;
import java.util.function.Supplier;

/**
 * LocationData definition for Farming Guild.
 */
public class FarmingGuildLocationData {
    
    private static final WorldPoint FARMING_GUILD_HERB_PATCH_POINT = new WorldPoint(1238, 3726, 0);
    
    /**
     * Creates LocationData for Farming Guild.
     * @param houseTeleportSupplier Supplier that provides house teleport item requirements
     *                              (typically from ItemAndLocation.getHouseTeleportItemRequirements())
     */
    public static LocationData create(Supplier<List<ItemRequirement>> houseTeleportSupplier) {
        LocationData locationData = new LocationData(
            "Farming Guild",
            true, // farmLimps
            FARMING_GUILD_HERB_PATCH_POINT,
            EasyFarmingConfig::enumOptionEnumFarmingGuildTeleport
        );
        
        // Jewellery box
        locationData.addTeleport(new TeleportData(
            "Jewellery_box",
            Teleport.Category.JEWELLERY_BOX,
            "Teleport to Farming guild with Jewellery box.",
            29155,
            "",
            0,
            0,
            4922,
            FARMING_GUILD_HERB_PATCH_POINT,
            houseTeleportSupplier
        ));
        
        // Skills Necklace
        locationData.addTeleport(new TeleportData(
            "Skills_Necklace",
            Teleport.Category.ITEM,
            "Teleport to Farming guild using Skills necklace.",
            ItemID.JEWL_NECKLACE_OF_SKILLS_1,
            "",
            0,
            0,
            4922,
            FARMING_GUILD_HERB_PATCH_POINT,
            () -> Collections.singletonList(
                new ItemRequirement(ItemID.JEWL_NECKLACE_OF_SKILLS_1, 1)
            )
        ));
        
        return locationData;
    }
}


package com.easyfarming.locations;

import com.easyfarming.EasyFarmingConfig;
import com.easyfarming.ItemRequirement;
import com.easyfarming.core.Teleport;
import net.runelite.api.coords.WorldPoint;
import net.runelite.api.gameval.ItemID;

import java.util.Collections;
import java.util.List;

/**
 * LocationData definition for Morytania.
 */
public class MorytaniaLocationData {
    
    private static final WorldPoint MORYTANIA_HERB_PATCH_POINT = new WorldPoint(3601, 3525, 0);
    
    /**
     * Creates LocationData for Morytania.
     */
    public static LocationData create() {
        LocationData locationData = new LocationData(
            "Morytania",
            true, // farmLimps
            MORYTANIA_HERB_PATCH_POINT,
            EasyFarmingConfig::enumOptionEnumMorytaniaTeleport
        );
        
        // Ectophial
        locationData.addTeleport(new TeleportData(
            "Ectophial",
            Teleport.Category.ITEM,
            "Teleport to Morytania with Ectophial and run West to the patch.",
            ItemID.ECTOPHIAL,
            "",
            0,
            0,
            14647,
            MORYTANIA_HERB_PATCH_POINT,
            () -> Collections.singletonList(
                new ItemRequirement(ItemID.ECTOPHIAL, 1)
            )
        ));
        
        return locationData;
    }
}


package com.easyfarming.locations;

import com.easyfarming.EasyFarmingConfig;
import com.easyfarming.ItemRequirement;
import com.easyfarming.core.Teleport;
import net.runelite.api.coords.WorldPoint;
import net.runelite.api.gameval.ItemID;

import java.util.Collections;
import java.util.List;
import java.util.function.Supplier;

/**
 * LocationData definition for Troll Stronghold.
 */
public class TrollStrongholdLocationData {
    
    private static final WorldPoint TROLL_STRONGHOLD_HERB_PATCH_POINT = new WorldPoint(2824, 3696, 0);
    
    /**
     * Creates LocationData for Troll Stronghold.
     * @param houseTeleportSupplier Supplier that provides house teleport item requirements
     *                              (typically from ItemAndLocation.getHouseTeleportItemRequirements())
     */
    public static LocationData create(Supplier<List<ItemRequirement>> houseTeleportSupplier) {
        LocationData locationData = new LocationData(
            "Troll Stronghold",
            false, // farmLimps
            TROLL_STRONGHOLD_HERB_PATCH_POINT,
            EasyFarmingConfig::enumOptionEnumTrollStrongholdTeleport
        );
        
        // Stony Basalt
        locationData.addTeleport(new TeleportData(
            "Stony_Basalt",
            Teleport.Category.ITEM,
            "Teleport to Troll Stronghold with Stony Basalt.",
            ItemID.STRONGHOLD_TELEPORT_BASALT,
            "",
            0,
            0,
            11321,
            TROLL_STRONGHOLD_HERB_PATCH_POINT,
            () -> Collections.singletonList(
                new ItemRequirement(ItemID.STRONGHOLD_TELEPORT_BASALT, 1)
            )
        ));
        
        // Portal Nexus
        locationData.addTeleport(new TeleportData(
            "Portal_Nexus",
            Teleport.Category.PORTAL_NEXUS,
            "Teleport to Troll Stronghold with Portal Nexus.",
            0,
            "",
            17,
            13,
            11321,
            TROLL_STRONGHOLD_HERB_PATCH_POINT,
            houseTeleportSupplier
        ));
        
        return locationData;
    }
}


package com.easyfarming.locations;

import com.easyfarming.EasyFarmingConfig;
import net.runelite.api.coords.WorldPoint;
import java.util.ArrayList;
import java.util.List;
import java.util.function.Function;

/**
 * NOTE: This class is part of an incomplete refactoring effort.
 * 
 * This class and related classes in the locations.* package were designed to replace
 * the current ItemsAndLocations.* package structure, but the migration was never completed.
 * 
 * Currently only used by LocationFactory (which is also unused).
 * 
 * SPARED FROM PURGING: This appears to be part of an unimplemented feature/refactoring
 * and may be completed in the future.
 */
public class LocationData {
    private final String name;
    private final boolean farmLimps;
    private final WorldPoint patchPoint;
    private final Function<EasyFarmingConfig, EasyFarmingConfig.OptionEnumTeleport> configFunction;
    private final List<TeleportData> teleportOptions;
    
    public LocationData(String name, boolean farmLimps, WorldPoint patchPoint,
                       Function<EasyFarmingConfig, EasyFarmingConfig.OptionEnumTeleport> configFunction) {
        this.name = name;
        this.farmLimps = farmLimps;
        this.patchPoint = patchPoint;
        this.configFunction = configFunction;
        this.teleportOptions = new ArrayList<>();
    }
    
    public LocationData addTeleport(TeleportData teleportData) {
        teleportOptions.add(teleportData);
        return this;
    }
    
    // Getters
    public String getName() { return name; }
    public boolean getFarmLimps() { return farmLimps; }
    public WorldPoint getPatchPoint() { return patchPoint; }
    public Function<EasyFarmingConfig, EasyFarmingConfig.OptionEnumTeleport> getConfigFunction() { return configFunction; }
    public List<TeleportData> getTeleportOptions() { return teleportOptions; }
}


package com.easyfarming.locations;

import com.easyfarming.ItemRequirement;
import com.easyfarming.core.Teleport;
import net.runelite.api.coords.WorldPoint;
import java.util.List;
import java.util.function.Supplier;

/**
 * NOTE: This class is part of an incomplete refactoring effort.
 * 
 * This class and related classes in the locations.* package were designed to replace
 * the current ItemsAndLocations.* package structure, but the migration was never completed.
 * 
 * Currently only used by LocationData/LocationFactory (which are also unused).
 * 
 * SPARED FROM PURGING: This appears to be part of an unimplemented feature/refactoring
 * and may be completed in the future.
 */
public class TeleportData {
    private final String enumOption;
    private final Teleport.Category category;
    private final String description;
    private final int id;
    private final String rightClickOption;
    private final int interfaceGroupId;
    private final int interfaceChildId;
    private final int regionId;
    private final WorldPoint point;
    private final Supplier<List<ItemRequirement>> itemRequirementsSupplier;
    
    public TeleportData(String enumOption, Teleport.Category category, String description, int id,
                       String rightClickOption, int interfaceGroupId, int interfaceChildId,
                       int regionId, WorldPoint point, Supplier<List<ItemRequirement>> itemRequirementsSupplier) {
        this.enumOption = enumOption;
        this.category = category;
        this.description = description;
        this.id = id;
        this.rightClickOption = rightClickOption;
        this.interfaceGroupId = interfaceGroupId;
        this.interfaceChildId = interfaceChildId;
        this.regionId = regionId;
        this.point = point;
        this.itemRequirementsSupplier = itemRequirementsSupplier;
    }
    
    public Teleport toTeleport() {
        return new Teleport(
            enumOption, category, description, id, rightClickOption,
            interfaceGroupId, interfaceChildId, regionId, point,
            itemRequirementsSupplier.get()
        );
    }
    
    // Getters
    public String getEnumOption() { return enumOption; }
    public Teleport.Category getCategory() { return category; }
    public String getDescription() { return description; }
    public int getId() { return id; }
    public String getRightClickOption() { return rightClickOption; }
    public int getInterfaceGroupId() { return interfaceGroupId; }
    public int getInterfaceChildId() { return interfaceChildId; }
    public int getRegionId() { return regionId; }
    public WorldPoint getPoint() { return point; }
    public Supplier<List<ItemRequirement>> getItemRequirementsSupplier() { return itemRequirementsSupplier; }
}


package com.easyfarming.locations;

import com.easyfarming.EasyFarmingConfig;
import com.easyfarming.ItemRequirement;
import com.easyfarming.core.Teleport;
import net.runelite.api.coords.WorldPoint;
import net.runelite.api.gameval.ItemID;

import java.util.Collections;
import java.util.List;
import java.util.function.Supplier;

/**
 * LocationData definition for Weiss.
 */
public class WeissLocationData {
    
    private static final WorldPoint WEISS_HERB_PATCH_POINT = new WorldPoint(2847, 3931, 0);
    
    /**
     * Creates LocationData for Weiss.
     * @param houseTeleportSupplier Supplier that provides house teleport item requirements
     *                              (typically from ItemAndLocation.getHouseTeleportItemRequirements())
     */
    public static LocationData create(Supplier<List<ItemRequirement>> houseTeleportSupplier) {
        LocationData locationData = new LocationData(
            "Weiss",
            false, // farmLimps
            WEISS_HERB_PATCH_POINT,
            EasyFarmingConfig::enumOptionEnumWeissTeleport
        );
        
        // Icy Basalt
        locationData.addTeleport(new TeleportData(
            "Icy_Basalt",
            Teleport.Category.ITEM,
            "Teleport to Weiss with Icy Basalt.",
            ItemID.WEISS_TELEPORT_BASALT,
            "",
            0,
            0,
            11325,
            WEISS_HERB_PATCH_POINT,
            () -> Collections.singletonList(
                new ItemRequirement(ItemID.WEISS_TELEPORT_BASALT, 1)
            )
        ));
        
        // Portal Nexus
        locationData.addTeleport(new TeleportData(
            "Portal_Nexus",
            Teleport.Category.PORTAL_NEXUS,
            "Teleport to Weiss with Portal Nexus.",
            0,
            "",
            17,
            13,
            11325,
            WEISS_HERB_PATCH_POINT,
            houseTeleportSupplier
        ));
        
        return locationData;
    }
}


package com.easyfarming.locations;

import com.easyfarming.EasyFarmingConfig;
import com.easyfarming.ItemRequirement;
import com.easyfarming.Location;
import java.util.EnumMap;
import java.util.List;
import java.util.stream.Collectors;

/**
 * Factory for creating Location instances from LocationData.
 * This allows locations to be defined as data rather than code.
 */
public class LocationFactory {
    
    /**
     * Enum-safe mapping from core.Teleport.Category to Location.TeleportCategory.
     * This ensures all enum values are explicitly mapped and prevents runtime errors
     * when new enum constants are added.
     * Package-private for testing.
     */
    static final EnumMap<com.easyfarming.core.Teleport.Category, Location.TeleportCategory> CATEGORY_MAP = new EnumMap<>(com.easyfarming.core.Teleport.Category.class);
    
    static {
        CATEGORY_MAP.put(com.easyfarming.core.Teleport.Category.ITEM, Location.TeleportCategory.ITEM);
        CATEGORY_MAP.put(com.easyfarming.core.Teleport.Category.PORTAL_NEXUS, Location.TeleportCategory.PORTAL_NEXUS);
        CATEGORY_MAP.put(com.easyfarming.core.Teleport.Category.SPIRIT_TREE, Location.TeleportCategory.SPIRIT_TREE);
        CATEGORY_MAP.put(com.easyfarming.core.Teleport.Category.JEWELLERY_BOX, Location.TeleportCategory.JEWELLERY_BOX);
        CATEGORY_MAP.put(com.easyfarming.core.Teleport.Category.MOUNTED_XERICS, Location.TeleportCategory.MOUNTED_XERICS);
        CATEGORY_MAP.put(com.easyfarming.core.Teleport.Category.SPELLBOOK, Location.TeleportCategory.SPELLBOOK);
    }
    
    /**
     * Creates a com.easyfarming.Location from LocationData.
     * This is the adapter method that bridges the new data-driven approach
     * with the current Location class structure.
     */
    public static Location createLocation(LocationData locationData, EasyFarmingConfig config) {
        Location location = new Location(
            locationData.getConfigFunction(),
            config,
            locationData.getName(),
            locationData.getFarmLimps()
        );
        
        for (TeleportData teleportData : locationData.getTeleportOptions()) {
            location.addTeleportOption(convertTeleportData(teleportData, location));
        }
        
        return location;
    }
    
    /**
     * Converts TeleportData to com.easyfarming.Location.Teleport.
     */
    private static Location.Teleport convertTeleportData(TeleportData teleportData, Location location) {
        // Convert core.Teleport.Category to Location.TeleportCategory
        Location.TeleportCategory category = convertCategory(teleportData.getCategory());
        
        // Get item requirements directly (no conversion needed)
        List<ItemRequirement> itemRequirements = teleportData.getItemRequirementsSupplier().get();
        
        return location.new Teleport(
            teleportData.getEnumOption(),
            category,
            teleportData.getDescription(),
            teleportData.getId(),
            teleportData.getRightClickOption(),
            teleportData.getInterfaceGroupId(),
            teleportData.getInterfaceChildId(),
            teleportData.getRegionId(),
            teleportData.getPoint(),
            itemRequirements
        );
    }
    
    /**
     * Converts core.Teleport.Category to Location.TeleportCategory.
     * Uses an EnumMap for enum-safe mapping that will fail fast if a new enum constant
     * is added without a corresponding mapping.
     * 
     * @param category the category to convert
     * @return the corresponding Location.TeleportCategory
     * @throws IllegalArgumentException if the category has no mapping
     */
    private static Location.TeleportCategory convertCategory(com.easyfarming.core.Teleport.Category category) {
        Location.TeleportCategory result = CATEGORY_MAP.get(category);
        if (result == null) {
            throw new IllegalArgumentException("No mapping found for category: " + category + ". Please add a mapping to CATEGORY_MAP.");
        }
        return result;
    }
    
    /**
     * Creates multiple locations from a list of LocationData.
     */
    public static List<Location> createLocations(List<LocationData> locationDataList, EasyFarmingConfig config) {
        return locationDataList.stream()
            .map(data -> createLocation(data, config))
            .collect(Collectors.toList());
    }
}


package com.easyfarming.locations.fruittree;

import com.easyfarming.EasyFarmingConfig;
import com.easyfarming.ItemRequirement;
import com.easyfarming.core.Teleport;
import com.easyfarming.locations.LocationData;
import com.easyfarming.locations.TeleportData;
import net.runelite.api.coords.WorldPoint;
import net.runelite.api.gameval.ItemID;

import java.util.Collections;

/**
 * LocationData definition for Tree Gnome Village Fruit Tree patch.
 */
public class TreeGnomeVillageFruitTreeLocationData {
    
    private static final WorldPoint TREE_GNOME_VILLAGE_FRUIT_TREE_PATCH_POINT = new WorldPoint(2490, 3180, 0);
    
    /**
     * Creates LocationData for Tree Gnome Village Fruit Tree patch.
     */
    public static LocationData create() {
        LocationData locationData = new LocationData(
            "Tree Gnome Village",
            false, // farmLimps
            TREE_GNOME_VILLAGE_FRUIT_TREE_PATCH_POINT,
            EasyFarmingConfig::enumFruitTreeTreeGnomeVillageTeleport
        );
        
        // Royal seed pod
        locationData.addTeleport(new TeleportData(
            "Royal_seed_pod",
            Teleport.Category.ITEM,
            "Teleport to Tree Gnome Village with Royal seed pod and use Spirit tree to Tree Gnome Village.",
            ItemID.MM2_ROYAL_SEED_POD,
            "",
            0,
            0,
            9782,
            TREE_GNOME_VILLAGE_FRUIT_TREE_PATCH_POINT,
            () -> Collections.singletonList(
                new ItemRequirement(ItemID.MM2_ROYAL_SEED_POD, 1)
            )
        ));
        
        // Spirit Tree
        locationData.addTeleport(new TeleportData(
            "Spirit_Tree",
            Teleport.Category.SPIRIT_TREE,
            "Teleport to Tree Gnome Village via a Spirit Tree.",
            0,
            "",
            187,
            3,
            10033,
            TREE_GNOME_VILLAGE_FRUIT_TREE_PATCH_POINT,
            () -> Collections.emptyList()
        ));
        
        return locationData;
    }
}


package com.easyfarming.locations.fruittree;

import com.easyfarming.EasyFarmingConfig;
import com.easyfarming.ItemRequirement;
import com.easyfarming.core.Teleport;
import com.easyfarming.locations.LocationData;
import com.easyfarming.locations.TeleportData;
import net.runelite.api.coords.WorldPoint;
import net.runelite.api.gameval.ItemID;

import java.util.Collections;

/**
 * LocationData definition for Lletya Fruit Tree patch.
 */
public class LletyaFruitTreeLocationData {
    
    private static final WorldPoint LLETYA_FRUIT_TREE_PATCH_POINT = new WorldPoint(2346, 3162, 0);
    
    /**
     * Creates LocationData for Lletya Fruit Tree patch.
     */
    public static LocationData create() {
        LocationData locationData = new LocationData(
            "Lletya",
            false, // farmLimps
            LLETYA_FRUIT_TREE_PATCH_POINT,
            EasyFarmingConfig::enumFruitTreeLletyaTeleport
        );
        
        // Teleport crystal
        locationData.addTeleport(new TeleportData(
            "Teleport_crystal",
            Teleport.Category.ITEM,
            "Teleport to Lletya with Teleport crystal.",
            ItemID.MOURNING_TELEPORT_CRYSTAL_1,
            "",
            0,
            0,
            9265,
            LLETYA_FRUIT_TREE_PATCH_POINT,
            () -> Collections.singletonList(
                new ItemRequirement(ItemID.MOURNING_TELEPORT_CRYSTAL_1, 1)
            )
        ));
        
        return locationData;
    }
}


package com.easyfarming.locations.fruittree;

import com.easyfarming.EasyFarmingConfig;
import com.easyfarming.ItemRequirement;
import com.easyfarming.core.Teleport;
import com.easyfarming.locations.LocationData;
import com.easyfarming.locations.TeleportData;
import net.runelite.api.coords.WorldPoint;
import net.runelite.api.gameval.ItemID;

import java.util.Collections;

/**
 * LocationData definition for Gnome Stronghold Fruit Tree patch.
 */
public class GnomeStrongholdFruitTreeLocationData {
    
    private static final WorldPoint GNOME_STRONGHOLD_FRUIT_TREE_PATCH_POINT = new WorldPoint(2475, 3446, 0);
    
    /**
     * Creates LocationData for Gnome Stronghold Fruit Tree patch.
     */
    public static LocationData create() {
        LocationData locationData = new LocationData(
            "Gnome Stronghold",
            false, // farmLimps
            GNOME_STRONGHOLD_FRUIT_TREE_PATCH_POINT,
            EasyFarmingConfig::enumFruitTreeGnomeStrongholdTeleport
        );
        
        // Royal seed pod
        locationData.addTeleport(new TeleportData(
            "Royal_seed_pod",
            Teleport.Category.ITEM,
            "Teleport to Gnome Stronghold with Royal seed pod and run south to the fruit tree patch.",
            ItemID.MM2_ROYAL_SEED_POD,
            "",
            0,
            0,
            9782,
            GNOME_STRONGHOLD_FRUIT_TREE_PATCH_POINT,
            () -> Collections.singletonList(
                new ItemRequirement(ItemID.MM2_ROYAL_SEED_POD, 1)
            )
        ));
        
        // Spirit Tree
        locationData.addTeleport(new TeleportData(
            "Spirit_Tree",
            Teleport.Category.SPIRIT_TREE,
            "Teleport to Gnome Stronghold via a Spirit Tree.",
            0,
            "",
            187,
            3,
            9781,
            GNOME_STRONGHOLD_FRUIT_TREE_PATCH_POINT,
            () -> Collections.emptyList()
        ));
        
        return locationData;
    }
}


package com.easyfarming.locations.fruittree;

import com.easyfarming.EasyFarmingConfig;
import com.easyfarming.ItemRequirement;
import com.easyfarming.core.Teleport;
import com.easyfarming.locations.LocationData;
import com.easyfarming.locations.TeleportData;
import net.runelite.api.coords.WorldPoint;
import net.runelite.api.gameval.ItemID;

import java.util.Arrays;
import java.util.Collections;
import java.util.List;
import java.util.function.Supplier;

/**
 * LocationData definition for Catherby Fruit Tree patch.
 */
public class CatherbyFruitTreeLocationData {
    
    private static final WorldPoint CATHERBY_FRUIT_TREE_PATCH_POINT = new WorldPoint(2860, 3433, 0);
    
    /**
     * Creates LocationData for Catherby Fruit Tree patch.
     * @param houseTeleportSupplier Supplier that provides house teleport item requirements
     */
    public static LocationData create(Supplier<List<ItemRequirement>> houseTeleportSupplier) {
        LocationData locationData = new LocationData(
            "Catherby",
            false, // farmLimps
            CATHERBY_FRUIT_TREE_PATCH_POINT,
            EasyFarmingConfig::enumFruitTreeCatherbyTeleport
        );
        
        // Portal Nexus Catherby
        locationData.addTeleport(new TeleportData(
            "Portal_Nexus_Catherby",
            Teleport.Category.PORTAL_NEXUS,
            "Teleport to Catherby with Portal Nexus.",
            0,
            "",
            17,
            13,
            11061,
            CATHERBY_FRUIT_TREE_PATCH_POINT,
            houseTeleportSupplier
        ));
        
        // Portal Nexus Camelot
        locationData.addTeleport(new TeleportData(
            "Portal_Nexus_Camelot",
            Teleport.Category.PORTAL_NEXUS,
            "Teleport to Camelot with Portal Nexus.",
            0,
            "",
            17,
            13,
            11062,
            CATHERBY_FRUIT_TREE_PATCH_POINT,
            houseTeleportSupplier
        ));
        
        // Camelot Teleport (spellbook)
        locationData.addTeleport(new TeleportData(
            "Camelot_Teleport",
            Teleport.Category.SPELLBOOK,
            "Teleport to Camelot using the standard spellbook, and run east. (If you have configured the teleport to seers you need to right click and teleport to Camelot)",
            0,
            "",
            218,
            34,
            11062,
            CATHERBY_FRUIT_TREE_PATCH_POINT,
            () -> Arrays.asList(
                new ItemRequirement(ItemID.AIRRUNE, 5),
                new ItemRequirement(ItemID.LAWRUNE, 1)
            )
        ));
        
        // Camelot Tele Tab
        locationData.addTeleport(new TeleportData(
            "Camelot_Tele_Tab",
            Teleport.Category.ITEM,
            "Teleport to Camelot using a Camelot tele tab, and run east.(If you have configured the teleport to seers you need to right click and teleport to Camelot)",
            ItemID.POH_TABLET_CAMELOTTELEPORT,
            "",
            0,
            0,
            11062,
            CATHERBY_FRUIT_TREE_PATCH_POINT,
            () -> Collections.singletonList(
                new ItemRequirement(ItemID.POH_TABLET_CAMELOTTELEPORT, 1)
            )
        ));
        
        // Catherby Tele Tab
        locationData.addTeleport(new TeleportData(
            "Catherby_Tele_Tab",
            Teleport.Category.ITEM,
            "Teleport to Catherby using Catherby teleport tab.",
            ItemID.LUNAR_TABLET_CATHERBY_TELEPORT,
            "",
            0,
            0,
            11061,
            CATHERBY_FRUIT_TREE_PATCH_POINT,
            () -> Collections.singletonList(
                new ItemRequirement(ItemID.LUNAR_TABLET_CATHERBY_TELEPORT, 1)
            )
        ));
        
        return locationData;
    }
}


package com.easyfarming.locations.fruittree;

import com.easyfarming.EasyFarmingConfig;
import com.easyfarming.ItemRequirement;
import com.easyfarming.core.Teleport;
import com.easyfarming.locations.LocationData;
import com.easyfarming.locations.TeleportData;
import net.runelite.api.coords.WorldPoint;
import net.runelite.api.gameval.ItemID;

import java.util.Collections;
import java.util.List;
import java.util.function.Supplier;

/**
 * LocationData definition for Farming Guild Fruit Tree patch.
 */
public class FarmingGuildFruitTreeLocationData {
    
    private static final WorldPoint FARMING_GUILD_FRUIT_TREE_PATCH_POINT = new WorldPoint(1243, 3759, 0);
    
    /**
     * Creates LocationData for Farming Guild Fruit Tree patch.
     * @param houseTeleportSupplier Supplier that provides house teleport item requirements
     */
    public static LocationData create(Supplier<List<ItemRequirement>> houseTeleportSupplier) {
        LocationData locationData = new LocationData(
            "Farming Guild",
            false, // farmLimps
            FARMING_GUILD_FRUIT_TREE_PATCH_POINT,
            EasyFarmingConfig::enumFruitTreeFarmingGuildTeleport
        );
        
        // Jewellery box
        locationData.addTeleport(new TeleportData(
            "Jewellery_box",
            Teleport.Category.JEWELLERY_BOX,
            "Teleport to Farming Guild with Jewellery box.",
            0,
            "",
            17,
            13,
            4922,
            FARMING_GUILD_FRUIT_TREE_PATCH_POINT,
            houseTeleportSupplier
        ));
        
        // Skills Necklace
        locationData.addTeleport(new TeleportData(
            "Skills_Necklace",
            Teleport.Category.ITEM,
            "Teleport to Farming guild using Skills necklace.",
            ItemID.JEWL_NECKLACE_OF_SKILLS_1,
            "",
            0,
            0,
            4922,
            FARMING_GUILD_FRUIT_TREE_PATCH_POINT,
            () -> Collections.singletonList(
                new ItemRequirement(ItemID.JEWL_NECKLACE_OF_SKILLS_1, 1)
            )
        ));
        
        return locationData;
    }
}


package com.easyfarming.locations.fruittree;

import com.easyfarming.EasyFarmingConfig;
import com.easyfarming.ItemRequirement;
import com.easyfarming.core.Teleport;
import com.easyfarming.locations.LocationData;
import com.easyfarming.locations.TeleportData;
import net.runelite.api.coords.WorldPoint;
import net.runelite.api.gameval.ItemID;

import java.util.Arrays;
import java.util.List;
import java.util.function.Supplier;

/**
 * LocationData definition for Brimhaven Fruit Tree patch.
 */
public class BrimhavenFruitTreeLocationData {
    
    private static final WorldPoint BRIMHAVEN_FRUIT_TREE_PATCH_POINT = new WorldPoint(2764, 3212, 0);
    
    /**
     * Creates LocationData for Brimhaven Fruit Tree patch.
     * @param houseTeleportSupplier Supplier that provides house teleport item requirements
     */
    public static LocationData create(Supplier<List<ItemRequirement>> houseTeleportSupplier) {
        LocationData locationData = new LocationData(
            "Brimhaven",
            false, // farmLimps
            BRIMHAVEN_FRUIT_TREE_PATCH_POINT,
            EasyFarmingConfig::enumFruitTreeBrimhavenTeleport
        );
        
        // Portal Nexus
        locationData.addTeleport(new TeleportData(
            "Portal_Nexus",
            Teleport.Category.PORTAL_NEXUS,
            "Teleport to Ardougne with Portal Nexus and take the boat to Brimhaven.",
            0,
            "",
            17,
            13,
            10547,
            BRIMHAVEN_FRUIT_TREE_PATCH_POINT,
            houseTeleportSupplier
        ));
        
        // Ardougne teleport (spellbook)
        locationData.addTeleport(new TeleportData(
            "Ardougne_teleport",
            Teleport.Category.SPELLBOOK,
            "Teleport to Ardougne with Spellbook and take the boat to Brimhaven.",
            0,
            "",
            218,
            41,
            10547,
            BRIMHAVEN_FRUIT_TREE_PATCH_POINT,
            () -> Arrays.asList(
                new ItemRequirement(ItemID.COINS, 30),
                new ItemRequirement(ItemID.LAWRUNE, 2),
                new ItemRequirement(ItemID.WATERRUNE, 2)
            )
        ));
        
        // Ardougne Tele Tab
        locationData.addTeleport(new TeleportData(
            "Ardougne_Tele_Tab",
            Teleport.Category.ITEM,
            "Teleport to Ardougne with Ardougne tele tab and take the boat to Brimhaven.",
            ItemID.POH_TABLET_ARDOUGNETELEPORT,
            "",
            0,
            0,
            10547,
            BRIMHAVEN_FRUIT_TREE_PATCH_POINT,
            () -> Arrays.asList(
                new ItemRequirement(ItemID.POH_TABLET_ARDOUGNETELEPORT, 1),
                new ItemRequirement(ItemID.COINS, 30)
            )
        ));
        
        // POH Tele Tab
        locationData.addTeleport(new TeleportData(
            "POH_Tele_Tab",
            Teleport.Category.ITEM,
            "Teleport to house with POH tele tab, use Portal Nexus to Ardougne and take the boat to Brimhaven.",
            ItemID.POH_TABLET_TELEPORTTOHOUSE,
            "",
            0,
            0,
            10547,
            BRIMHAVEN_FRUIT_TREE_PATCH_POINT,
            () -> Arrays.asList(
                new ItemRequirement(ItemID.POH_TABLET_TELEPORTTOHOUSE, 1),
                new ItemRequirement(ItemID.COINS, 30)
            )
        ));
        
        return locationData;
    }
}


package com.easyfarming.locations;

import com.easyfarming.EasyFarmingConfig;
import com.easyfarming.ItemRequirement;
import com.easyfarming.core.Teleport;
import net.runelite.api.coords.WorldPoint;
import net.runelite.api.gameval.ItemID;

import java.util.Collections;
import java.util.List;
import java.util.function.Supplier;

/**
 * LocationData definition for Kourend.
 */
public class KourendLocationData {
    
    private static final WorldPoint KOUREND_HERB_PATCH_POINT = new WorldPoint(1738, 3550, 0);
    
    /**
     * Creates LocationData for Kourend.
     * @param houseTeleportSupplier Supplier that provides house teleport item requirements
     *                              (typically from ItemAndLocation.getHouseTeleportItemRequirements())
     */
    public static LocationData create(Supplier<List<ItemRequirement>> houseTeleportSupplier) {
        LocationData locationData = new LocationData(
            "Kourend",
            true, // farmLimps
            KOUREND_HERB_PATCH_POINT,
            EasyFarmingConfig::enumOptionEnumKourendTeleport
        );
        
        // Xeric's Talisman
        locationData.addTeleport(new TeleportData(
            "Xerics_Talisman",
            Teleport.Category.ITEM,
            "Teleport to Kourend with Xeric's Talisman.",
            ItemID.XERIC_TALISMAN,
            "Rub",
            187,
            3,
            6967,
            KOUREND_HERB_PATCH_POINT,
            () -> Collections.singletonList(
                new ItemRequirement(ItemID.XERIC_TALISMAN, 1)
            )
        ));
        
        // Mounted Xerics
        locationData.addTeleport(new TeleportData(
            "Mounted_Xerics",
            Teleport.Category.MOUNTED_XERICS,
            "Teleport to Kourend with Xeric's Talisman in PoH.",
            0,
            "",
            187,
            3,
            6967,
            KOUREND_HERB_PATCH_POINT,
            houseTeleportSupplier
        ));
        
        return locationData;
    }
}


package com.easyfarming.locations;

import com.easyfarming.EasyFarmingConfig;
import com.easyfarming.ItemRequirement;
import com.easyfarming.core.Teleport;
import net.runelite.api.coords.WorldPoint;
import net.runelite.api.gameval.ItemID;

import java.util.Arrays;
import java.util.Collections;
import java.util.List;
import java.util.function.Supplier;

/**
 * LocationData definition for Ardougne.
 */
public class ArdougneLocationData {
    
    private static final WorldPoint ARDOUGNE_HERB_PATCH_POINT = new WorldPoint(2670, 3374, 0);
    
    /**
     * Creates LocationData for Ardougne.
     * @param houseTeleportSupplier Supplier that provides house teleport item requirements
     *                              (typically from ItemAndLocation.getHouseTeleportItemRequirements())
     */
    public static LocationData create(Supplier<List<ItemRequirement>> houseTeleportSupplier) {
        LocationData locationData = new LocationData(
            "Ardougne",
            true, // farmLimps
            ARDOUGNE_HERB_PATCH_POINT,
            EasyFarmingConfig::enumOptionEnumArdougneTeleport
        );
        
        // Portal Nexus teleport
        locationData.addTeleport(new TeleportData(
            "Portal_Nexus",
            Teleport.Category.PORTAL_NEXUS,
            "Teleport to Ardougne with Portal Nexus, and run north.",
            0,
            "",
            17,
            13,
            10547,
            ARDOUGNE_HERB_PATCH_POINT,
            houseTeleportSupplier
        ));
        
        // Ardougne teleport (spellbook)
        locationData.addTeleport(new TeleportData(
            "Ardougne_teleport",
            Teleport.Category.SPELLBOOK,
            "Teleport to Ardougne with standard spellbook, and run north.",
            0,
            "",
            218,
            41,
            10547,
            ARDOUGNE_HERB_PATCH_POINT,
            () -> Arrays.asList(
                new ItemRequirement(ItemID.LAWRUNE, 2),
                new ItemRequirement(ItemID.WATERRUNE, 2)
            )
        ));
        
        // Ardougne Tele Tab
        locationData.addTeleport(new TeleportData(
            "Ardougne_Tele_Tab",
            Teleport.Category.ITEM,
            "Teleport to Ardougne with Ardougne tele tab, and run north.",
            ItemID.POH_TABLET_ARDOUGNETELEPORT,
            "",
            0,
            0,
            10547,
            ARDOUGNE_HERB_PATCH_POINT,
            () -> Collections.singletonList(
                new ItemRequirement(ItemID.POH_TABLET_ARDOUGNETELEPORT, 1)
            )
        ));
        
        // Ardy cloak
        locationData.addTeleport(new TeleportData(
            "Ardy_cloak",
            Teleport.Category.ITEM,
            "Teleport to Ardougne Farm with Ardougne cloak.",
            ItemID.ARDY_CAPE_MEDIUM,
            "Farm Teleport",
            0,
            0,
            10548,
            ARDOUGNE_HERB_PATCH_POINT,
            () -> Collections.singletonList(
                new ItemRequirement(ItemID.ARDY_CAPE_MEDIUM, 1)
            )
        ));
        
        // Skills Necklace
        locationData.addTeleport(new TeleportData(
            "Skills_Necklace",
            Teleport.Category.ITEM,
            "Teleport to Fishing guild with Skills necklace, and run east.",
            ItemID.JEWL_NECKLACE_OF_SKILLS_1,
            "",
            0,
            0,
            10292,
            ARDOUGNE_HERB_PATCH_POINT,
            () -> Collections.singletonList(
                new ItemRequirement(ItemID.JEWL_NECKLACE_OF_SKILLS_1, 1)
            )
        ));
        
        return locationData;
    }
}


package com.easyfarming.locations;

import com.easyfarming.EasyFarmingConfig;
import com.easyfarming.ItemRequirement;
import com.easyfarming.core.Teleport;
import net.runelite.api.coords.WorldPoint;
import net.runelite.api.gameval.ItemID;

import java.util.Arrays;
import java.util.Collections;
import java.util.List;
import java.util.function.Supplier;

/**
 * LocationData definition for Falador.
 */
public class FaladorLocationData {
    
    private static final WorldPoint FALADOR_HERB_PATCH_POINT = new WorldPoint(3058, 3307, 0);
    
    /**
     * Creates LocationData for Falador.
     * @param houseTeleportSupplier Supplier that provides house teleport item requirements
     *                              (typically from ItemAndLocation.getHouseTeleportItemRequirements())
     */
    public static LocationData create(Supplier<List<ItemRequirement>> houseTeleportSupplier) {
        LocationData locationData = new LocationData(
            "Falador",
            true, // farmLimps
            FALADOR_HERB_PATCH_POINT,
            EasyFarmingConfig::enumOptionEnumFaladorTeleport
        );
        
        // Portal Nexus
        locationData.addTeleport(new TeleportData(
            "Portal_Nexus",
            Teleport.Category.PORTAL_NEXUS,
            "Teleport to Falador with Portal Nexus, and run south-east.",
            0,
            "",
            17,
            13,
            11828,
            FALADOR_HERB_PATCH_POINT,
            houseTeleportSupplier
        ));
        
        // Explorers ring
        locationData.addTeleport(new TeleportData(
            "Explorers_ring",
            Teleport.Category.ITEM,
            "Teleport to Falador with Explorers ring, and run slightly north.",
            ItemID.LUMBRIDGE_RING_MEDIUM,
            "Teleport",
            0,
            0,
            12083,
            FALADOR_HERB_PATCH_POINT,
            () -> Collections.singletonList(
                new ItemRequirement(ItemID.LUMBRIDGE_RING_MEDIUM, 1)
            )
        ));
        
        // Falador Teleport (spellbook)
        locationData.addTeleport(new TeleportData(
            "Falador_Teleport",
            Teleport.Category.SPELLBOOK,
            "Teleport to Falador with standard spellbook, and run south-east.",
            0,
            "",
            218,
            29,
            11828,
            FALADOR_HERB_PATCH_POINT,
            () -> Arrays.asList(
                new ItemRequirement(ItemID.AIRRUNE, 3),
                new ItemRequirement(ItemID.LAWRUNE, 1),
                new ItemRequirement(ItemID.WATERRUNE, 1)
            )
        ));
        
        // Falador Tele Tab
        locationData.addTeleport(new TeleportData(
            "Falador_Tele_Tab",
            Teleport.Category.ITEM,
            "Teleport to Falador with Falador Tele Tab, and run south-east.",
            ItemID.POH_TABLET_FALADORTELEPORT,
            "",
            0,
            0,
            11828,
            FALADOR_HERB_PATCH_POINT,
            () -> Collections.singletonList(
                new ItemRequirement(ItemID.POH_TABLET_FALADORTELEPORT, 1)
            )
        ));
        
        // Draynor Tele Tab
        locationData.addTeleport(new TeleportData(
            "Draynor_Tele_Tab",
            Teleport.Category.ITEM,
            "Teleport to Draynor Manor with Draynor Manor Tele Tab, and run south-west.",
            ItemID.TELETAB_DRAYNOR,
            "",
            0,
            0,
            12340,
            FALADOR_HERB_PATCH_POINT,
            () -> Collections.singletonList(
                new ItemRequirement(ItemID.TELETAB_DRAYNOR, 1)
            )
        ));
        
        return locationData;
    }
}


package com.easyfarming.locations;

import com.easyfarming.EasyFarmingConfig;
import com.easyfarming.ItemRequirement;
import com.easyfarming.core.Teleport;
import net.runelite.api.coords.WorldPoint;
import net.runelite.api.gameval.ItemID;

import java.util.Arrays;
import java.util.Collections;
import java.util.List;
import java.util.function.Supplier;

/**
 * LocationData definition for Civitas illa Fortis.
 * This is a test case for migrating from code-based location setup to data-driven setup.
 * 
 * Usage:
 *   Supplier<List<ItemRequirement>> houseTeleSupplier = () -> itemAndLocation.getHouseTeleportItemRequirements();
 *   LocationData civitasData = CivitasLocationData.create(houseTeleSupplier);
 *   Location civitasLocation = LocationFactory.createLocation(civitasData, config);
 */
public class CivitasLocationData {
    
    private static final WorldPoint CIVITAS_HERB_PATCH_POINT = new WorldPoint(1586, 3099, 0);
    
    /**
     * Creates LocationData for Civitas illa Fortis.
     * @param houseTeleportSupplier Supplier that provides house teleport item requirements
     *                              (typically from ItemAndLocation.getHouseTeleportItemRequirements())
     */
    public static LocationData create(Supplier<List<ItemRequirement>> houseTeleportSupplier) {
        LocationData locationData = new LocationData(
            "Civitas illa Fortis",
            true, // farmLimps
            CIVITAS_HERB_PATCH_POINT,
            EasyFarmingConfig::enumOptionEnumCivitasTeleport
        );
        
        // Portal Nexus teleport
        locationData.addTeleport(new TeleportData(
            "Portal_Nexus",
            Teleport.Category.PORTAL_NEXUS,
            "Teleport to Civitas illa Fortis with Portal Nexus.",
            0,
            "",
            17,
            13,
            6192,
            CIVITAS_HERB_PATCH_POINT,
            houseTeleportSupplier
        ));
        
        // Civitas Teleport (spellbook)
        locationData.addTeleport(new TeleportData(
            "Civitas_Teleport",
            Teleport.Category.SPELLBOOK,
            "Teleport to Civitas illa Fortis with standard spellbook, and run west.",
            0,
            "",
            218,
            43,
            6192,
            CIVITAS_HERB_PATCH_POINT,
            () -> Arrays.asList(
                new ItemRequirement(ItemID.LAWRUNE, 2),
                new ItemRequirement(ItemID.EARTHRUNE, 1),
                new ItemRequirement(ItemID.FIRERUNE, 1)
            )
        ));
        
        // Civitas Tele Tab
        locationData.addTeleport(new TeleportData(
            "Civitas_Tele_Tab",
            Teleport.Category.ITEM,
            "Teleport to Civitas illa Fortis with Civitas teleport tab, and run west.",
            ItemID.POH_TABLET_FORTISTELEPORT,
            "",
            0,
            0,
            6192,
            CIVITAS_HERB_PATCH_POINT,
            () -> Collections.singletonList(
                new ItemRequirement(ItemID.POH_TABLET_FORTISTELEPORT, 1)
            )
        ));
        
        // Quetzal whistle
        locationData.addTeleport(new TeleportData(
            "Quetzal_whistle",
            Teleport.Category.ITEM,
            "Teleport to the Hunter's Guild with the quetzal whistle, and run north.",
            ItemID.HG_QUETZALWHISTLE_BASIC,
            "",
            0,
            0,
            6192,
            CIVITAS_HERB_PATCH_POINT,
            () -> Collections.singletonList(
                new ItemRequirement(ItemID.HG_QUETZALWHISTLE_BASIC, 1)
            )
        ));
        
        // Hunter Skillcape
        locationData.addTeleport(new TeleportData(
            "Hunter_Skillcape",
            Teleport.Category.ITEM,
            "Teleport to Civitas illa Fortis with Hunter skillcape.",
            ItemID.SKILLCAPE_HUNTING,
            "",
            0,
            0,
            6192,
            CIVITAS_HERB_PATCH_POINT,
            () -> Collections.singletonList(
                new ItemRequirement(ItemID.SKILLCAPE_HUNTING, 1)
            )
        ));
        
        return locationData;
    }
}


package com.easyfarming.locations.tree;

import com.easyfarming.EasyFarmingConfig;
import com.easyfarming.ItemRequirement;
import com.easyfarming.core.Teleport;
import com.easyfarming.locations.LocationData;
import com.easyfarming.locations.TeleportData;
import net.runelite.api.coords.WorldPoint;
import net.runelite.api.gameval.ItemID;

import java.util.Arrays;
import java.util.Collections;
import java.util.List;
import java.util.function.Supplier;

/**
 * LocationData definition for Lumbridge Tree patch.
 */
public class LumbridgeTreeLocationData {
    
    private static final WorldPoint LUMBRIDGE_TREE_PATCH_POINT = new WorldPoint(3193, 3231, 0);
    
    /**
     * Creates LocationData for Lumbridge Tree patch.
     * @param houseTeleportSupplier Supplier that provides house teleport item requirements
     */
    public static LocationData create(Supplier<List<ItemRequirement>> houseTeleportSupplier) {
        LocationData locationData = new LocationData(
            "Lumbridge",
            false, // farmLimps
            LUMBRIDGE_TREE_PATCH_POINT,
            EasyFarmingConfig::enumTreeLumbridgeTeleport
        );
        
        // Portal Nexus
        locationData.addTeleport(new TeleportData(
            "Portal_Nexus",
            Teleport.Category.PORTAL_NEXUS,
            "Teleport to Lumbridge with Portal Nexus.",
            0,
            "",
            17,
            13,
            12850,
            LUMBRIDGE_TREE_PATCH_POINT,
            houseTeleportSupplier
        ));
        
        // Teleport (spellbook)
        locationData.addTeleport(new TeleportData(
            "Teleport",
            Teleport.Category.SPELLBOOK,
            "Teleport to Lumbridge with spellbook.",
            0,
            "",
            218,
            26,
            12850,
            LUMBRIDGE_TREE_PATCH_POINT,
            () -> Arrays.asList(
                new ItemRequirement(ItemID.AIRRUNE, 3),
                new ItemRequirement(ItemID.LAWRUNE, 1),
                new ItemRequirement(ItemID.EARTHRUNE, 1)
            )
        ));
        
        // Lumbridge Tele Tab
        locationData.addTeleport(new TeleportData(
            "Lumbridge_Tele_Tab",
            Teleport.Category.ITEM,
            "Teleport to Lumbridge with Lumbridge Tele Tab.",
            ItemID.POH_TABLET_LUMBRIDGETELEPORT,
            "",
            0,
            0,
            12850,
            LUMBRIDGE_TREE_PATCH_POINT,
            () -> Collections.singletonList(
                new ItemRequirement(ItemID.POH_TABLET_LUMBRIDGETELEPORT, 1)
            )
        ));
        
        return locationData;
    }
}


package com.easyfarming.locations.tree;

import com.easyfarming.EasyFarmingConfig;
import com.easyfarming.ItemRequirement;
import com.easyfarming.core.Teleport;
import com.easyfarming.locations.LocationData;
import com.easyfarming.locations.TeleportData;
import net.runelite.api.coords.WorldPoint;
import net.runelite.api.gameval.ItemID;

import java.util.Arrays;
import java.util.Collections;
import java.util.List;
import java.util.function.Supplier;

/**
 * LocationData definition for Varrock Tree patch.
 */
public class VarrockTreeLocationData {
    
    private static final WorldPoint VARROCK_TREE_PATCH_POINT = new WorldPoint(3229, 3459, 0);
    
    /**
     * Creates LocationData for Varrock Tree patch.
     * @param houseTeleportSupplier Supplier that provides house teleport item requirements
     */
    public static LocationData create(Supplier<List<ItemRequirement>> houseTeleportSupplier) {
        LocationData locationData = new LocationData(
            "Varrock",
            false, // farmLimps
            VARROCK_TREE_PATCH_POINT,
            EasyFarmingConfig::enumTreeVarrockTeleport
        );
        
        // Portal Nexus
        locationData.addTeleport(new TeleportData(
            "Portal_Nexus",
            Teleport.Category.PORTAL_NEXUS,
            "Teleport to Varrock with Portal Nexus.",
            0,
            "",
            17,
            13,
            12853,
            VARROCK_TREE_PATCH_POINT,
            houseTeleportSupplier
        ));
        
        // Teleport (spellbook)
        locationData.addTeleport(new TeleportData(
            "Teleport",
            Teleport.Category.SPELLBOOK,
            "Teleport to Varrock with spellbook.",
            0,
            "",
            218,
            23,
            12853,
            VARROCK_TREE_PATCH_POINT,
            () -> Arrays.asList(
                new ItemRequirement(ItemID.AIRRUNE, 3),
                new ItemRequirement(ItemID.LAWRUNE, 1),
                new ItemRequirement(ItemID.FIRERUNE, 1)
            )
        ));
        
        // Varrock Tele Tab
        locationData.addTeleport(new TeleportData(
            "Varrock_Tele_Tab",
            Teleport.Category.ITEM,
            "Teleport to Varrock with Varrock Tele Tab.",
            ItemID.POH_TABLET_VARROCKTELEPORT,
            "",
            0,
            0,
            12853,
            VARROCK_TREE_PATCH_POINT,
            () -> Collections.singletonList(
                new ItemRequirement(ItemID.POH_TABLET_VARROCKTELEPORT, 1)
            )
        ));
        
        return locationData;
    }
}


package com.easyfarming.locations.tree;

import com.easyfarming.EasyFarmingConfig;
import com.easyfarming.ItemRequirement;
import com.easyfarming.core.Teleport;
import com.easyfarming.locations.LocationData;
import com.easyfarming.locations.TeleportData;
import net.runelite.api.coords.WorldPoint;
import net.runelite.api.gameval.ItemID;

import java.util.Arrays;
import java.util.Collections;
import java.util.List;
import java.util.function.Supplier;

/**
 * LocationData definition for Taverley Tree patch.
 */
public class TaverleyTreeLocationData {
    
    private static final WorldPoint TAVERLEY_TREE_PATCH_POINT = new WorldPoint(2936, 3438, 0);
    
    /**
     * Creates LocationData for Taverley Tree patch.
     * @param houseTeleportSupplier Supplier that provides house teleport item requirements
     */
    public static LocationData create(Supplier<List<ItemRequirement>> houseTeleportSupplier) {
        LocationData locationData = new LocationData(
            "Taverley",
            false, // farmLimps
            TAVERLEY_TREE_PATCH_POINT,
            EasyFarmingConfig::enumTreeTaverleyTeleport
        );
        
        // Portal Nexus
        locationData.addTeleport(new TeleportData(
            "Portal_Nexus",
            Teleport.Category.PORTAL_NEXUS,
            "Teleport to Falador with Portal Nexus and run to Taverly.",
            0,
            "",
            17,
            13,
            11828,
            TAVERLEY_TREE_PATCH_POINT,
            houseTeleportSupplier
        ));
        
        // Teleport (spellbook)
        locationData.addTeleport(new TeleportData(
            "Teleport",
            Teleport.Category.SPELLBOOK,
            "Teleport to Falador with spellbook and run to Taverly.",
            0,
            "",
            218,
            29,
            11828,
            TAVERLEY_TREE_PATCH_POINT,
            () -> Arrays.asList(
                new ItemRequirement(ItemID.AIRRUNE, 3),
                new ItemRequirement(ItemID.LAWRUNE, 1),
                new ItemRequirement(ItemID.WATERRUNE, 1)
            )
        ));
        
        // Falador Tele Tab
        locationData.addTeleport(new TeleportData(
            "Falador_Tele_Tab",
            Teleport.Category.ITEM,
            "Teleport to Falador with Falador Tele Tab and run to Taverly.",
            ItemID.POH_TABLET_FALADORTELEPORT,
            "",
            0,
            0,
            11828,
            TAVERLEY_TREE_PATCH_POINT,
            () -> Collections.singletonList(
                new ItemRequirement(ItemID.POH_TABLET_FALADORTELEPORT, 1)
            )
        ));
        
        return locationData;
    }
}


package com.easyfarming.locations.tree;

import com.easyfarming.EasyFarmingConfig;
import com.easyfarming.ItemRequirement;
import com.easyfarming.core.Teleport;
import com.easyfarming.locations.LocationData;
import com.easyfarming.locations.TeleportData;
import net.runelite.api.coords.WorldPoint;
import net.runelite.api.gameval.ItemID;

import java.util.Collections;
import java.util.List;
import java.util.function.Supplier;

/**
 * LocationData definition for Farming Guild Tree patch.
 */
public class FarmingGuildTreeLocationData {
    
    private static final WorldPoint FARMING_GUILD_TREE_PATCH_POINT = new WorldPoint(1232, 3736, 0);
    
    /**
     * Creates LocationData for Farming Guild Tree patch.
     * @param houseTeleportSupplier Supplier that provides house teleport item requirements
     */
    public static LocationData create(Supplier<List<ItemRequirement>> houseTeleportSupplier) {
        LocationData locationData = new LocationData(
            "Farming Guild",
            false, // farmLimps
            FARMING_GUILD_TREE_PATCH_POINT,
            EasyFarmingConfig::enumTreeFarmingGuildTeleport
        );
        
        // Jewellery box
        locationData.addTeleport(new TeleportData(
            "Jewellery_box",
            Teleport.Category.JEWELLERY_BOX,
            "Teleport to Farming Guild with Jewellery box.",
            0,
            "",
            0,
            0,
            4922,
            FARMING_GUILD_TREE_PATCH_POINT,
            houseTeleportSupplier
        ));
        
        // Skills Necklace
        locationData.addTeleport(new TeleportData(
            "Skills_Necklace",
            Teleport.Category.ITEM,
            "Teleport to Farming guild using Skills necklace.",
            ItemID.JEWL_NECKLACE_OF_SKILLS_1,
            "",
            0,
            0,
            4922,
            FARMING_GUILD_TREE_PATCH_POINT,
            () -> Collections.singletonList(
                new ItemRequirement(ItemID.JEWL_NECKLACE_OF_SKILLS_1, 1)
            )
        ));
        
        return locationData;
    }
}


package com.easyfarming.locations.tree;

import com.easyfarming.EasyFarmingConfig;
import com.easyfarming.ItemRequirement;
import com.easyfarming.core.Teleport;
import com.easyfarming.locations.LocationData;
import com.easyfarming.locations.TeleportData;
import net.runelite.api.coords.WorldPoint;
import net.runelite.api.gameval.ItemID;

import java.util.Collections;
import java.util.List;

/**
 * LocationData definition for Gnome Stronghold Tree patch.
 */
public class GnomeStrongholdTreeLocationData {
    
    private static final WorldPoint GNOME_STRONGHOLD_TREE_PATCH_POINT = new WorldPoint(2436, 3415, 0);
    
    /**
     * Creates LocationData for Gnome Stronghold Tree patch.
     */
    public static LocationData create() {
        LocationData locationData = new LocationData(
            "Gnome Stronghold",
            false, // farmLimps
            GNOME_STRONGHOLD_TREE_PATCH_POINT,
            EasyFarmingConfig::enumTreeGnomeStrongoldTeleport
        );
        
        // Royal seed pod
        locationData.addTeleport(new TeleportData(
            "Royal_seed_pod",
            Teleport.Category.ITEM,
            "Teleport to Gnome Stronghold with Royal seed pod.",
            ItemID.MM2_ROYAL_SEED_POD,
            "",
            0,
            0,
            9782,
            GNOME_STRONGHOLD_TREE_PATCH_POINT,
            () -> Collections.singletonList(
                new ItemRequirement(ItemID.MM2_ROYAL_SEED_POD, 1)
            )
        ));
        
        // Spirit Tree
        locationData.addTeleport(new TeleportData(
            "Spirit_Tree",
            Teleport.Category.SPIRIT_TREE,
            "Teleport to Gnome Stronghold via a Spirit Tree.",
            0,
            "",
            187,
            3,
            9781,
            GNOME_STRONGHOLD_TREE_PATCH_POINT,
            () -> Collections.emptyList()
        ));
        
        return locationData;
    }
}


package com.easyfarming.locations.tree;

import com.easyfarming.EasyFarmingConfig;
import com.easyfarming.ItemRequirement;
import com.easyfarming.core.Teleport;
import com.easyfarming.locations.LocationData;
import com.easyfarming.locations.TeleportData;
import net.runelite.api.coords.WorldPoint;
import net.runelite.api.gameval.ItemID;

import java.util.Arrays;
import java.util.Collections;
import java.util.List;
import java.util.function.Supplier;

/**
 * LocationData definition for Falador Tree patch.
 */
public class FaladorTreeLocationData {
    
    private static final WorldPoint FALADOR_TREE_PATCH_POINT = new WorldPoint(3000, 3373, 0);
    
    /**
     * Creates LocationData for Falador Tree patch.
     * @param houseTeleportSupplier Supplier that provides house teleport item requirements
     */
    public static LocationData create(Supplier<List<ItemRequirement>> houseTeleportSupplier) {
        LocationData locationData = new LocationData(
            "Falador",
            false, // farmLimps
            FALADOR_TREE_PATCH_POINT,
            EasyFarmingConfig::enumTreeFaladorTeleport
        );
        
        // Portal Nexus
        locationData.addTeleport(new TeleportData(
            "Portal_Nexus",
            Teleport.Category.PORTAL_NEXUS,
            "Teleport to Falador with Portal Nexus.",
            0,
            "",
            17,
            13,
            11828,
            FALADOR_TREE_PATCH_POINT,
            houseTeleportSupplier
        ));
        
        // Teleport (spellbook)
        locationData.addTeleport(new TeleportData(
            "Teleport",
            Teleport.Category.SPELLBOOK,
            "Teleport to Falador with Spellbook and run to Falador park.",
            0,
            "",
            218,
            29,
            11828,
            FALADOR_TREE_PATCH_POINT,
            () -> Arrays.asList(
                new ItemRequirement(ItemID.AIRRUNE, 3),
                new ItemRequirement(ItemID.LAWRUNE, 1),
                new ItemRequirement(ItemID.WATERRUNE, 1)
            )
        ));
        
        // Falador Tele Tab
        locationData.addTeleport(new TeleportData(
            "Falador_Tele_Tab",
            Teleport.Category.ITEM,
            "Teleport to Falador with Falador Tele Tab and run to Falador park.",
            ItemID.POH_TABLET_FALADORTELEPORT,
            "",
            0,
            0,
            11828,
            FALADOR_TREE_PATCH_POINT,
            () -> Collections.singletonList(
                new ItemRequirement(ItemID.POH_TABLET_FALADORTELEPORT, 1)
            )
        ));
        
        return locationData;
    }
}


package com.easyfarming.locations;

import com.easyfarming.EasyFarmingConfig;
import com.easyfarming.ItemRequirement;
import com.easyfarming.core.Teleport;
import net.runelite.api.coords.WorldPoint;
import net.runelite.api.gameval.ItemID;

import java.util.Collections;
import java.util.List;
import java.util.function.Supplier;

/**
 * LocationData definition for Harmony Island.
 */
public class HarmonyLocationData {
    
    private static final WorldPoint HARMONY_HERB_PATCH_POINT = new WorldPoint(3789, 2837, 0);
    
    /**
     * Creates LocationData for Harmony Island.
     * @param houseTeleportSupplier Supplier that provides house teleport item requirements
     *                              (typically from ItemAndLocation.getHouseTeleportItemRequirements())
     */
    public static LocationData create(Supplier<List<ItemRequirement>> houseTeleportSupplier) {
        LocationData locationData = new LocationData(
            "Harmony Island",
            false, // farmLimps
            HARMONY_HERB_PATCH_POINT,
            EasyFarmingConfig::enumOptionEnumHarmonyTeleport
        );
        
        // Portal Nexus
        locationData.addTeleport(new TeleportData(
            "Portal_Nexus",
            Teleport.Category.PORTAL_NEXUS,
            "Teleport to Harmony with Portal Nexus.",
            0,
            "",
            17,
            13,
            15148,
            HARMONY_HERB_PATCH_POINT,
            houseTeleportSupplier
        ));
        
        // Harmony Tele Tab
        locationData.addTeleport(new TeleportData(
            "Harmony_Tele_tab",
            Teleport.Category.ITEM,
            "Teleport to Harmony with Harmony Tele Tab.",
            ItemID.TELETAB_HARMONY,
            "",
            0,
            0,
            15148,
            HARMONY_HERB_PATCH_POINT,
            () -> Collections.singletonList(
                new ItemRequirement(ItemID.TELETAB_HARMONY, 1)
            )
        ));
        
        return locationData;
    }
}


package com.easyfarming.locations;

import com.easyfarming.EasyFarmingConfig;
import com.easyfarming.ItemRequirement;
import com.easyfarming.core.Teleport;
import net.runelite.api.coords.WorldPoint;
import net.runelite.api.gameval.ItemID;

import java.util.Arrays;
import java.util.Collections;
import java.util.List;
import java.util.function.Supplier;

/**
 * LocationData definition for Catherby.
 */
public class CatherbyLocationData {
    
    private static final WorldPoint CATHERBY_HERB_PATCH_POINT = new WorldPoint(2813, 3463, 0);
    
    /**
     * Creates LocationData for Catherby.
     * @param houseTeleportSupplier Supplier that provides house teleport item requirements
     *                              (typically from ItemAndLocation.getHouseTeleportItemRequirements())
     */
    public static LocationData create(Supplier<List<ItemRequirement>> houseTeleportSupplier) {
        LocationData locationData = new LocationData(
            "Catherby",
            true, // farmLimps
            CATHERBY_HERB_PATCH_POINT,
            EasyFarmingConfig::enumOptionEnumCatherbyTeleport
        );
        
        // Portal Nexus Catherby
        locationData.addTeleport(new TeleportData(
            "Portal_Nexus_Catherby",
            Teleport.Category.PORTAL_NEXUS,
            "Teleport to Catherby with Portal Nexus.",
            0,
            "",
            17,
            13,
            11061,
            CATHERBY_HERB_PATCH_POINT,
            houseTeleportSupplier
        ));
        
        // Portal Nexus Camelot
        locationData.addTeleport(new TeleportData(
            "Portal_Nexus_Camelot",
            Teleport.Category.PORTAL_NEXUS,
            "Teleport to Camelot with Portal Nexus.",
            0,
            "",
            17,
            13,
            11062,
            CATHERBY_HERB_PATCH_POINT,
            houseTeleportSupplier
        ));
        
        // Camelot Teleport (spellbook)
        locationData.addTeleport(new TeleportData(
            "Camelot_Teleport",
            Teleport.Category.SPELLBOOK,
            "Teleport to Camelot using the standard spellbook, and run east to Catherby herb patch.",
            0,
            "",
            218,
            34,
            11062,
            CATHERBY_HERB_PATCH_POINT,
            () -> Arrays.asList(
                new ItemRequirement(ItemID.AIRRUNE, 5),
                new ItemRequirement(ItemID.LAWRUNE, 1)
            )
        ));
        
        // Camelot Tele Tab
        locationData.addTeleport(new TeleportData(
            "Camelot_Tele_Tab",
            Teleport.Category.ITEM,
            "Teleport to Camelot using a Camelot tele tab, and run east to Catherby herb patch.",
            ItemID.POH_TABLET_CAMELOTTELEPORT,
            "",
            0,
            0,
            11062,
            CATHERBY_HERB_PATCH_POINT,
            () -> Collections.singletonList(
                new ItemRequirement(ItemID.POH_TABLET_CAMELOTTELEPORT, 1)
            )
        ));
        
        // Catherby Tele Tab
        locationData.addTeleport(new TeleportData(
            "Catherby_Tele_Tab",
            Teleport.Category.ITEM,
            "Teleport to Catherby using Catherby teleport tab.",
            ItemID.LUNAR_TABLET_CATHERBY_TELEPORT,
            "",
            0,
            0,
            11061,
            CATHERBY_HERB_PATCH_POINT,
            () -> Collections.singletonList(
                new ItemRequirement(ItemID.LUNAR_TABLET_CATHERBY_TELEPORT, 1)
            )
        ));
        
        return locationData;
    }
}


package com.easyfarming;

import net.runelite.api.Client;
import net.runelite.api.coords.WorldPoint;

import javax.inject.Inject;

public class AreaCheck {
    private Client client;

    @Inject
    public AreaCheck(Client client) {
        this.client = client;
    }

    public boolean isPlayerWithinArea(WorldPoint centerTile, int range) {
        WorldPoint playerLocation = client.getLocalPlayer().getWorldLocation();

        int minX = centerTile.getX() - range;
        int maxX = centerTile.getX() + range;
        int minY = centerTile.getY() - range;
        int maxY = centerTile.getY() + range;

        return playerLocation.getX() >= minX &&
                playerLocation.getX() <= maxX &&
                playerLocation.getY() >= minY &&
                playerLocation.getY() <= maxY;
    }
}
package com.easyfarming;

import net.runelite.api.Client;

import java.util.Arrays;
import java.util.List;
import java.util.stream.Collectors;
import java.util.stream.Stream;

public class TreePatchChecker {

    public enum Tree {
        //Order of lists is "growing, diseased, dead, healthy, remove"
        OAK(Arrays.asList(8,9,10,11), Arrays.asList(73,74,75), Arrays.asList(137, 138, 139, 141), Arrays.asList(12), Arrays.asList(13,14)),
        WILLOW(Arrays.asList(15,16,17,18,19,20), Arrays.asList(80,81,82,83,84,86), Arrays.asList(144,145,146,147,148, 150), Arrays.asList(21), Arrays.asList(22,23)),
        MAPLE(Arrays.asList(24,25,26,27,28,29,30,31), Arrays.asList(89,90,91,92,93,94,95,97), Arrays.asList(153,154,155,156,157,158,159, 161), Arrays.asList(32), Arrays.asList(33,34)),
        YEW(Arrays.asList(35,36,37,38,39,40,41,42,43,44), Arrays.asList(100,101,102,103,104,105,106,107,108, 110), Arrays.asList(164,165,166,167,168,169,170,171,172, 174), Arrays.asList(45), Arrays.asList(46,47)),
        MAGIC(Arrays.asList(48,49,50,51,52,53,54,55,56,57,58,59), Arrays.asList(113,114,115,116,117,118,119,120,121,122,123, 125), Arrays.asList(177,178,179,180,181,182,183,184,185,186,187, 189), Arrays.asList(60), Arrays.asList(61,62));

        private final List<Integer> growing;
        private final List<Integer> diseased;
        private final List<Integer> dead;
        private final List<Integer> healthy;
        private final List<Integer> remove;

        Tree(List<Integer> growing, List<Integer> diseased, List<Integer> dead, List<Integer> healthy, List<Integer> remove) {
            this.growing = growing;
            this.diseased = diseased;
            this.dead = dead;
            this.healthy = healthy;
            this.remove = remove;
        }

        public List<Integer> getGrowing() {
            return growing;
        }

        public List<Integer> getDiseased() {
            return diseased;
        }

        public List<Integer> getDead() {
            return dead;
        }

        public List<Integer> getHealthy() {
            return healthy;
        }
        public List<Integer> getRemove() {
            return remove;
        }
    }

    // Combine all growing and dead varbit values into single lists
    private static final List<Integer> growing = Stream.of(Tree.values())
            .flatMap(tree -> tree.getGrowing().stream())
            .collect(Collectors.toList());

    private static final List<Integer> diseased = Stream.of(Tree.values())
            .flatMap(tree -> tree.getDiseased().stream())
            .collect(Collectors.toList());

    private static final List<Integer> dead = Stream.of(Tree.values())
            .flatMap(tree -> tree.getDead().stream())
            .collect(Collectors.toList());

    private static final List<Integer> healthy = Stream.of(Tree.values())
            .flatMap(tree -> tree.getHealthy().stream())
            .collect(Collectors.toList());
    private static final List<Integer> remove = Stream.of(Tree.values())
            .flatMap(tree -> tree.getRemove().stream())
            .collect(Collectors.toList());

    private static final List<Integer> weeds = Arrays.asList(0, 1, 2);

    public enum PlantState {
        GROWING,
        DISEASED,
        DEAD,
        WEEDS,
        HEALTHY,
        REMOVE,
        PLANT,
        UNKNOWN
    }

    public static PlantState checkTreePatch(Client client, int varbitIndex) {
        int varbitValue = client.getVarbitValue(varbitIndex);
        if (growing.contains(varbitValue)) {
            return PlantState.GROWING;
        } else if (diseased.contains(varbitValue)) {
            return PlantState.DISEASED;
        } else if (dead.contains(varbitValue)) {
            return PlantState.DEAD;
        } else if (weeds.contains(varbitValue)) {
            return PlantState.WEEDS;
        }  else if (healthy.contains(varbitValue)) {
            return PlantState.HEALTHY;
        }else if (remove.contains(varbitValue)) {
            return PlantState.REMOVE;
        } else if (varbitValue == 3) {
            return PlantState.PLANT;
        } else {
            return PlantState.UNKNOWN;
        }
    }
}
package com.easyfarming;

import net.runelite.client.ui.PluginPanel;
import net.runelite.client.ui.overlay.OverlayManager;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import javax.swing.*;
import javax.swing.border.EmptyBorder;
import java.awt.*;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;

import com.easyfarming.ItemsAndLocations.HerbRunItemAndLocation;
import com.easyfarming.ItemsAndLocations.TreeRunItemAndLocation;
import com.easyfarming.ItemsAndLocations.FruitTreeRunItemAndLocation;

public class EasyFarmingPanel extends PluginPanel
{
    private static final Logger logger = LoggerFactory.getLogger(EasyFarmingPanel.class);
    private final HerbRunItemAndLocation herbRunItemAndLocation;
    private final TreeRunItemAndLocation treeRunItemAndLocation;
    private  final FruitTreeRunItemAndLocation fruitTreeRunItemAndLocation;
	private final EasyFarmingPlugin plugin;
    private final OverlayManager overlayManager;
    private final FarmingTeleportOverlay farmingTeleportOverlay;

    public StartStopJButton herbButton;
    public StartStopJButton treeButton;
    public StartStopJButton fruitTreeButton;

    public EasyFarmingPanel(EasyFarmingPlugin plugin, OverlayManager overlayManager, FarmingTeleportOverlay farmingTeleportOverlay, HerbRunItemAndLocation herbRunItemAndLocation, TreeRunItemAndLocation treeRunItemAndLocation, FruitTreeRunItemAndLocation fruitTreeRunItemAndLocation)
    {
        this.herbRunItemAndLocation = herbRunItemAndLocation;
        this.treeRunItemAndLocation = treeRunItemAndLocation;
        this.farmingTeleportOverlay = farmingTeleportOverlay;
        this.fruitTreeRunItemAndLocation = fruitTreeRunItemAndLocation;

        this.plugin = plugin;
        this.overlayManager = overlayManager;

        setLayout(new BorderLayout());
        setBorder(new EmptyBorder(10, 10, 10, 10));

        JPanel layoutPanel = new JPanel();
        layoutPanel.setLayout(new BoxLayout(layoutPanel, BoxLayout.Y_AXIS));

        JPanel titlePanel = createTitlePanel();
        JPanel farmRunButtons = createFarmRunButtons();
        JPanel infoPanel = createInfoPanel();

        layoutPanel.add(titlePanel);
        layoutPanel.add(farmRunButtons);
        layoutPanel.add(infoPanel);

        add(layoutPanel, BorderLayout.NORTH);
    }

    private JPanel createTitlePanel()
    {
        JPanel titlePanel = new JPanel();
        titlePanel.setBorder(new EmptyBorder(0, 0, 15, 0));
        titlePanel.setLayout(new BorderLayout());

        JLabel title = new JLabel("Pick a new farm run:");
        titlePanel.add(title, BorderLayout.WEST);

        return titlePanel;
    }

    private JPanel createFarmRunButtons()
    {
        JPanel farmRunButtonsContainingPanel = new JPanel();
        farmRunButtonsContainingPanel.setLayout(new BoxLayout(farmRunButtonsContainingPanel, BoxLayout.Y_AXIS));

        // With GridLayout, you can't set the button height.
        // With GridBagLayout, you can't make the buttons the full width of the container.
        // The height seemed like the better thing to let go of.
        JPanel farmRunButtonsPanel = new JPanel(new GridLayout(0, 1, 0, 15));
        farmRunButtonsPanel.setBorder(new EmptyBorder(0, 0, 0, 0));

        herbButton = new StartStopJButton("Herb Run");
		herbButton.setFocusable(false);
        herbButton.addActionListener(new ActionListener() {
            @Override
            public void actionPerformed(ActionEvent e) {
                plugin.runOnClientThread(() -> {
                    plugin.setOverlayActive(!plugin.isOverlayActive());

                    herbButton.setStartStopState(plugin.isOverlayActive());

                    onHerbButtonClicked();
                });
            }
        });
        farmRunButtonsPanel.add(herbButton);

        treeButton = new StartStopJButton("Tree Run");
        treeButton.setFocusable(false);
        treeButton.addActionListener(new ActionListener()
        {
            @Override
            public void actionPerformed(ActionEvent e) {
                plugin.runOnClientThread(() -> {
                    plugin.setOverlayActive(!plugin.isOverlayActive());

                    treeButton.setStartStopState(plugin.isOverlayActive());

                    onTreeButtonClicked();
                });
            }
        });
        farmRunButtonsPanel.add(treeButton);

        fruitTreeButton = new StartStopJButton("Fruit Tree Run");
        fruitTreeButton.setFocusable(false);
        fruitTreeButton.addActionListener(new ActionListener()
        {
            @Override
            public void actionPerformed(ActionEvent e) {
                plugin.runOnClientThread(() -> {
                    plugin.setOverlayActive(!plugin.isOverlayActive());

                    fruitTreeButton.setStartStopState(plugin.isOverlayActive());

                    onFruitTreeButtonClicked();
                });
            }
        });
        farmRunButtonsPanel.add(fruitTreeButton);

        farmRunButtonsContainingPanel.add(farmRunButtonsPanel);

        return farmRunButtonsContainingPanel;
    }

    private JPanel createInfoPanel()
    {
        JPanel infoContainingPanel = new JPanel();
        infoContainingPanel.setLayout(new BoxLayout(infoContainingPanel, BoxLayout.Y_AXIS));
        
        JPanel infoPanel = new JPanel(new GridLayout(0, 1, 0, 0));
        infoPanel.setBorder(new EmptyBorder(25, 0, 0, 0));

        JTextArea textAreaTip = new JTextArea("Tips: \n - Rune pouch, combination runes, and elemental staffs work. \n - If you don't have Bottomless compost bucket you should store compost @ Tool Leprechaun, the plugin checks if you have compost stored there.");
        textAreaTip.setWrapStyleWord(true);
        textAreaTip.setLineWrap(true);
        textAreaTip.setEditable(false);
        infoPanel.add(textAreaTip);

        infoContainingPanel.add(infoPanel);

        return infoContainingPanel;
    }

    private void onHerbButtonClicked() {
        SwingUtilities.invokeLater(new Runnable() {
            @Override
            public void run() {
                EasyFarmingOverlay overlay = plugin.getEasyFarmingOverlay();

                if (!plugin.isOverlayActive()) {
                    farmingTeleportOverlay.removeOverlay();
                    logger.debug("Remove overlay from button");
                } else {
                    logger.debug("Add overlay from button");
                    plugin.getFarmingTeleportOverlay().herbRun = true;
                    overlayManager.add(overlay);
                    overlayManager.add(farmingTeleportOverlay);
                }
            }
        });
    }

    private void onTreeButtonClicked()
    {
        // Handle button click event here
        SwingUtilities.invokeLater(new Runnable()
        {
            @Override
            public void run() {
                EasyFarmingOverlay overlay = plugin.getEasyFarmingOverlay();

                if (!plugin.isOverlayActive()) {
                    farmingTeleportOverlay.removeOverlay();
                    logger.debug("Remove overlay from button");
                } else {
                    logger.debug("Add overlay from button");
                    plugin.getFarmingTeleportOverlay().treeRun = true;
                    overlayManager.add(overlay);
                    overlayManager.add(farmingTeleportOverlay);
                }
            }
        });
    }
	private void onFruitTreeButtonClicked()
    {
        // Handle button click event here
        SwingUtilities.invokeLater(new Runnable()
        {
            @Override
            public void run() {
                EasyFarmingOverlay overlay = plugin.getEasyFarmingOverlay();

                if (!plugin.isOverlayActive()) {
                    farmingTeleportOverlay.removeOverlay();
                    logger.debug("Remove overlay from button");
                } else {
                    logger.debug("Add overlay from button");
                    plugin.getFarmingTeleportOverlay().fruitTreeRun = true;
                    overlayManager.add(overlay);
                    overlayManager.add(farmingTeleportOverlay);
                }
            }
        });
    }
}
package com.easyfarming;

import net.runelite.api.Client;
import net.runelite.client.ui.overlay.Overlay;
import net.runelite.client.ui.overlay.OverlayLayer;
import net.runelite.client.ui.overlay.OverlayPosition;
import net.runelite.client.ui.overlay.components.LineComponent;
import net.runelite.client.ui.overlay.components.PanelComponent;

import javax.inject.Inject;
import java.awt.Dimension;
import java.awt.Graphics2D;

public class EasyFarmingOverlayInfoBox extends Overlay {
    private final Client client;
    private final PanelComponent panelComponent = new PanelComponent();
    private final EasyFarmingPlugin plugin;

    private String text;
    private String debugText;

    @Inject
    public EasyFarmingOverlayInfoBox(Client client, EasyFarmingPlugin plugin) {
        this.client = client;
        this.plugin = plugin;
        setPosition(OverlayPosition.TOP_LEFT);
        setLayer(OverlayLayer.ALWAYS_ON_TOP);
    }

    public void setText(String text) {
        this.text = text;
    }

    public void setDebugText(String debugText) {
        this.debugText = debugText;
    }

    @Override
    public Dimension render(Graphics2D graphics) {
        if (!plugin.isOverlayActive()) {
            return null;
        }

        panelComponent.getChildren().clear();

        if (text != null) {
            panelComponent.getChildren().add(LineComponent.builder().left(text).build());
        }

        if (debugText != null) {
            panelComponent.getChildren().add(LineComponent.builder().left(debugText).build());
        }

        return panelComponent.render(graphics);
    }
}
package com.easyfarming;

import java.awt.*;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.function.Function;

import net.runelite.api.coords.WorldPoint;

public class Location {
    public enum TeleportCategory {
        ITEM,
        PORTAL_NEXUS,
        SPIRIT_TREE,
        JEWELLERY_BOX,
        MOUNTED_XERICS,
        SPELLBOOK
    }
    private String name;

    public String getName() {
        return name;
    }
    private Boolean farmLimps;

    public Boolean getFarmLimps() {
        return farmLimps;
    }

    private List<Teleport> teleportOptions;
    private EasyFarmingConfig config;
    private final Function<EasyFarmingConfig, EasyFarmingConfig.OptionEnumTeleport> selectedTeleportFunction;

    public Location(Function<EasyFarmingConfig, EasyFarmingConfig.OptionEnumTeleport> selectedTeleportFunction, EasyFarmingConfig config, String name, Boolean farmLimps) {
        this.config = config;
        this.selectedTeleportFunction = selectedTeleportFunction;
        this.name = name;
        this.farmLimps = farmLimps;
        this.teleportOptions = new ArrayList<>();
    }

    public void addTeleportOption(Teleport teleport) {
        teleportOptions.add(teleport);
    }

    public Teleport getSelectedTeleport() {
        String selectedEnumOption = selectedTeleportFunction.apply(config).name();
        for (Teleport teleport : teleportOptions) {
            if (teleport.getEnumOption().equalsIgnoreCase(selectedEnumOption)) {
                return teleport;
            }
        }
        return teleportOptions.isEmpty() ? null : teleportOptions.get(0);
    }





    public class Teleport {
        private TeleportCategory category;
        private String description;
        private Color color;
        private int id;
        private int interfaceGroupId;
        private int interfaceChildId;

        private int regionId;
        private String enumOption;
        private String rightClickOption;
        private List<ItemRequirement> itemRequirements;
        private WorldPoint point;

        public Teleport(String enumOption, TeleportCategory category, String description, int id, String rightClickOption, int interfaceGroupId, int interfaceChildId, int regionId, WorldPoint point, List<ItemRequirement> itemRequirements) {
            this.enumOption = enumOption;
            this.category = category;
            this.description = description;
            this.id = id;
            this.rightClickOption = rightClickOption;
            this.interfaceGroupId = interfaceGroupId;
            this.interfaceChildId = interfaceChildId;
            this.regionId = regionId;
            this.point = point;
            this.itemRequirements = itemRequirements;
        }

        public Map<Integer, Integer> getItemRequirements() {
            Map<Integer, Integer> requirements = new HashMap<>();
            for (ItemRequirement itemRequirement : itemRequirements) {
                requirements.put(itemRequirement.getItemId(), itemRequirement.getQuantity());
            }
            return requirements;
        }

        public WorldPoint getPoint(){return point;}

        public void addItemRequirement(int itemId, int quantity) {
            ItemRequirement itemRequirement = new ItemRequirement(itemId, quantity);
            this.itemRequirements.add(itemRequirement);
        }
        public void addAllItemRequirements(List<ItemRequirement> itemRequirements) {
            this.itemRequirements.addAll(itemRequirements);
        }

        public void updateTeleportItemId(int newItemId) {
            this.id = newItemId;
        }

        public TeleportCategory getCategory() {
            return category;
        }
        public int getRegionId() {
            return regionId;
        }
        public String getEnumOption() {
            return enumOption;
        }

        public String getDescription() {
            return description;
        }
        public String getRightClickOption() {
            return rightClickOption;
        }

        public void setDescription(String description) {
            this.description = description;
        }

        public int getId() {
            return id;
        }

        public void setId(int id) {
            this.id = id;
        }

        public int getInterfaceGroupId() {
            return interfaceGroupId;
        }

        public void setInterfaceGroupId(int interfaceGroupId) {
            this.interfaceGroupId = interfaceGroupId;
        }

        public int getInterfaceChildId() {
            return interfaceChildId;
        }

        public void setInterfaceChildId(int interfaceChildId) {
            this.interfaceChildId = interfaceChildId;
        }

        public Color getColor() {
            return  color;
        }
    }
}
package com.easyfarming;
public class ItemRequirement {
    private int itemId;
    private int quantity;

    public ItemRequirement(int itemId, int quantity) {
        this.itemId = itemId;
        this.quantity = quantity;
    }

    public int getItemId() {
        return itemId;
    }

    public int getQuantity() {
        return quantity;
    }
}

package com.easyfarming;

import net.runelite.api.Client;

import java.util.Arrays;
import java.util.List;
import java.util.stream.Collectors;
import java.util.stream.Stream;

public class AllotmentPatchChecker {
    /**
     * Allotment patch varbit IDs used in OSRS.
     * 
     * Each location uses specific varbit IDs:
     * - Standard locations (Falador, Ardougne, Catherby, Morytania, Kourend, Civitas): 
     *   Varbit IDs are determined from object composition (typically in 4771-4774 range)
     * - Farming Guild: Varbit IDs in 7904-7914 range
     * - Transmit varbits (fallback): FARMING_TRANSMIT_A1, A2, B1, B2
     * 
     * The varbit ID is determined per-patch from the object composition, not per-crop.
     * All crops planted in the same patch location will use the same varbit ID.
     */
    
    // Valid varbit ID ranges for allotment patches (for validation)
    private static final int MIN_STANDARD_VARBIT = 4771;
    private static final int MAX_STANDARD_VARBIT = 4774;
    private static final int MIN_FARMING_GUILD_VARBIT = 7904;
    private static final int MAX_FARMING_GUILD_VARBIT = 7914;
    
    public enum Allotment {
        //Order of lists is "growing, needsWater, diseased, harvest"
        // Note: Values 128-151 are "needs water" states (confirmed: 129 = needs water)
        // When watered, value changes from 129 to 64, so 64+ are watered growing states
        // Value 63 is also a watered growing state (observed after first watering)
        POTATO(Arrays.asList(4,5,6,7,63,64,65,66,67), Arrays.asList(128,129,130), Arrays.asList(), Arrays.asList(8,9,10)),
        ONION(Arrays.asList(11,12,13,14,68,69,70,71), Arrays.asList(131,132,133), Arrays.asList(), Arrays.asList(15,16,17,18,19)),
        CABBAGE(Arrays.asList(20,21,72,73,74,75), Arrays.asList(134,135,136), Arrays.asList(), Arrays.asList(22,23,24)),
        TOMATO(Arrays.asList(25,26,27,28,76,77,78,79), Arrays.asList(137,138), Arrays.asList(), Arrays.asList(29,30,31)),
        SWEETCORN(Arrays.asList(32,33,34,35,80,81,82,83), Arrays.asList(141,142), Arrays.asList(), Arrays.asList(36,37,38)),
        STRAWBERRY(Arrays.asList(39,40,41,42,84,85,86,87), Arrays.asList(143,144,145), Arrays.asList(), Arrays.asList(43,44,45)),
        WATERMELON(Arrays.asList(46,47,48,49,88,89,90,91), Arrays.asList(146,147,148), Arrays.asList(), Arrays.asList(50,51,52)),
        SNAPE_GRASS(Arrays.asList(53,54,55,56,92,93,94,95), Arrays.asList(128,149,150,151), Arrays.asList(198), Arrays.asList(57,58,59,138,139,140));

        private final List<Integer> growing;
        private final List<Integer> needsWater;
        private final List<Integer> diseased;
        private final List<Integer> harvest;

        Allotment(List<Integer> growing, List<Integer> needsWater, List<Integer> diseased, List<Integer> harvest) {
            this.growing = growing;
            this.needsWater = needsWater;
            this.diseased = diseased;
            this.harvest = harvest;
        }
        
        public List<Integer> getGrowing() {
            return growing;
        }

        public List<Integer> getNeedsWater() {
            return needsWater;
        }

        public List<Integer> getDiseased() {
            return diseased;
        }

        public List<Integer> getHarvest() {
            return harvest;
        }
    }

    // Combine all growing, needsWater, diseased, and harvest varbit values into single lists
    private static final List<Integer> growing = Stream.of(Allotment.values())
            .flatMap(allotment -> allotment.getGrowing().stream())
            .collect(Collectors.toList());

    private static final List<Integer> needsWater = Stream.of(Allotment.values())
            .flatMap(allotment -> allotment.getNeedsWater().stream())
            .collect(Collectors.toList());

    private static final List<Integer> diseased = Stream.of(Allotment.values())
            .flatMap(allotment -> allotment.getDiseased().stream())
            .collect(Collectors.toList());

    private static final List<Integer> harvest = Stream.of(Allotment.values())
            .flatMap(allotment -> allotment.getHarvest().stream())
            .collect(Collectors.toList());

    private static final List<Integer> WEEDS = Arrays.asList(0, 1, 2);
    private static final List<Integer> DEAD = Arrays.asList(170, 171, 172);

    /**
     * Checks if a varbit ID is in the valid range for allotment patches.
     * @param varbitId The varbit ID to validate
     * @return true if the varbit ID is in a valid range for allotment patches
     */
    private static boolean isValidAllotmentVarbitId(int varbitId) {
        return (varbitId >= MIN_STANDARD_VARBIT && varbitId <= MAX_STANDARD_VARBIT) ||
               (varbitId >= MIN_FARMING_GUILD_VARBIT && varbitId <= MAX_FARMING_GUILD_VARBIT);
    }

    /**
     * Checks the state of an allotment patch.
     * 
     * @param client The RuneLite client instance
     * @param varbitIndex The varbit ID for the patch (determined from object composition)
     * @return The current state of the patch
     */
    public static PlantState checkAllotmentPatch(Client client, int varbitIndex) {
        int varbitValue = client.getVarbitValue(varbitIndex);

        // Runtime validation: Log a warning if varbit ID is outside expected ranges
        // (This helps catch incorrect varbit IDs during development/testing)
        if (!isValidAllotmentVarbitId(varbitIndex) && varbitIndex != -1) {
            // Note: We don't throw an error here as transmit varbits (A1, A2, B1, B2) 
            // may also be valid but not in our documented ranges
            // This is just a validation check for common allotment patch varbits
        }

        // Check harvestable first (before weeds, since harvest values might overlap with other states)
        if (harvest.contains(varbitValue)) {
            return PlantState.HARVESTABLE;
        }
        
        // Check dead before diseased, as dead is a more specific state
        if (DEAD.contains(varbitValue)) {
            return PlantState.DEAD;
        }
        
        // Check diseased state using the diseased list
        if (diseased.contains(varbitValue)) {
            return PlantState.DISEASED;
        } else if (needsWater.contains(varbitValue)) {
            // Check needsWater after diseased but before growing, as it's urgent
            // Values 128-151 are "needs water" states (confirmed: 129 = needs water)
            return PlantState.NEEDS_WATER;
        } else if (growing.contains(varbitValue)) {
            // Values 4-7, 64-67, etc. are "growing and watered" states
            return PlantState.GROWING;
        } else if (WEEDS.contains(varbitValue)) {
            // Value 0 = weeds/empty after harvesting
            return PlantState.WEEDS;
        } else if (varbitValue == 3) {
            // Value 3 = empty patch ready to plant (before harvesting, this might be harvestable state)
            // Note: After harvesting, value changes from 3 to 0 (weeds)
            return PlantState.PLANT;
        } else {
            return PlantState.UNKNOWN;
        }
    }
    
    public enum PlantState {
        GROWING,
        NEEDS_WATER,
        DISEASED,
        HARVESTABLE,
        WEEDS,
        DEAD,
        PLANT,
        UNKNOWN
    }
}


package com.easyfarming;

import net.runelite.api.Client;
import net.runelite.api.gameval.VarbitID;
import net.runelite.api.gameval.InterfaceID;
import net.runelite.api.widgets.Widget;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import java.util.Arrays;
import java.util.List;

public class InventoryTabChecker {
    private static final Logger log = LoggerFactory.getLogger(InventoryTabChecker.class);
    
    // Lists for each tab state
    private static final List<Integer> INVENTORY = Arrays.asList(3);
    private static final List<Integer> SPELLBOOK = Arrays.asList(6);

    public enum TabState {
        INVENTORY,
        SPELLBOOK,
        REST
    }

    public static TabState checkTab(Client client, int varbitIndex) {
        int varbitValue = client.getVarcIntValue(varbitIndex);
        
        // Original working logic - keep this for now
        List<Integer> INVENTORY = Arrays.asList(3);
        List<Integer> SPELLBOOK = Arrays.asList(6);
        
        if (INVENTORY.contains(varbitValue)) {
            return TabState.INVENTORY;
        } else if (SPELLBOOK.contains(varbitValue)) {
            return TabState.SPELLBOOK;
        } else {
            return TabState.REST;
        }
    }}
package com.easyfarming.ItemsAndLocations;

import com.easyfarming.EasyFarmingConfig;
import com.easyfarming.EasyFarmingPlugin;
import com.easyfarming.ItemRequirement;
import com.easyfarming.Location;
import net.runelite.api.Client;
import net.runelite.api.gameval.ItemID;
import com.easyfarming.locations.LocationData;
import com.easyfarming.locations.LocationFactory;
import com.easyfarming.locations.fruittree.BrimhavenFruitTreeLocationData;
import com.easyfarming.locations.fruittree.CatherbyFruitTreeLocationData;
import com.easyfarming.locations.fruittree.FarmingGuildFruitTreeLocationData;
import com.easyfarming.locations.fruittree.GnomeStrongholdFruitTreeLocationData;
import com.easyfarming.locations.fruittree.LletyaFruitTreeLocationData;
import com.easyfarming.locations.fruittree.TreeGnomeVillageFruitTreeLocationData;

import java.util.*;

public class FruitTreeRunItemAndLocation extends ItemAndLocation
{
    public Location brimhavenFruitTreeLocation;
    public Location catherbyFruitTreeLocation;
    public Location farmingGuildFruitTreeLocation;
    public Location gnomeStrongholdFruitTreeLocation;
    public Location lletyaFruitTreeLocation;
    public Location treeGnomeVillageFruitTreeLocation;

    private boolean locationsInitialized = false;

    public FruitTreeRunItemAndLocation()
    {
    }

    public FruitTreeRunItemAndLocation(EasyFarmingConfig config, Client client, EasyFarmingPlugin plugin)
    {
        super(
            config,
            client,
            plugin
        );
        setupLocations();
    }

    public Map<Integer, Integer> getFruitTreeItems()
    {
        return getAllItemRequirements(locations);
    }

    public Map<Integer, Integer> getAllItemRequirements(List<Location> locations)
    {
        Map<Integer, Integer> allRequirements = new HashMap<>();

        // Add other items and merge them with allRequirements
        for (Location location : locations) {
            if (plugin.getFruitTreeLocationEnabled(location.getName())) {
                //ItemID.GUAM_SEED is default for herb seeds, code later will allow for any seed to be used, just needed a placeholder ID
                //allRequirements.merge(ItemID.GUAM_SEED, 1, Integer::sum);
                allRequirements.merge(
                    ItemID.PLANTPOT_APPLE_SAPLING,
                    1,
                    Integer::sum
                );

                allRequirements.merge(
                    ItemID.COINS,
                    200,
                    Integer::sum
                );

                if (selectedCompostID() != -1 && selectedCompostID() != ItemID.BOTTOMLESS_COMPOST_BUCKET) {
                    allRequirements.merge(
                        selectedCompostID(),
                        1,
                        Integer::sum
                    );
                }

                Location.Teleport teleport = location.getSelectedTeleport();

                Map<Integer, Integer> locationRequirements = teleport.getItemRequirements();

                for (Map.Entry<Integer, Integer> entry : locationRequirements.entrySet()) {
                    int itemId = entry.getKey();
                    int quantity = entry.getValue();

                    if (itemId == ItemID.SKILLCAPE_CONSTRUCTION || itemId == ItemID.SKILLCAPE_CONSTRUCTION_TRIMMED || itemId == ItemID.SKILLCAPE_MAX || itemId == ItemID.MM2_ROYAL_SEED_POD) {
                        allRequirements.merge(
                            itemId,
                            quantity,
                            (oldValue, newValue) -> Math.max(oldValue, newValue)
                        );
                    } else {
                        allRequirements.merge(
                            itemId,
                            quantity,
                            Integer::sum
                        );
                    }
                }
            }
        }

        //allRequirements.merge(ItemID.SEED_DIBBER, 1, Integer::sum);
        allRequirements.merge(
            ItemID.SPADE,
            1,
            Integer::sum
        );

        // Only add bottomless compost bucket if it's selected in config
        if (selectedCompostID() == ItemID.BOTTOMLESS_COMPOST_BUCKET) {
            allRequirements.merge(
                ItemID.BOTTOMLESS_COMPOST_BUCKET,
                1,
                Integer::sum
            );
        }

        allRequirements.merge(
            ItemID.FAIRY_ENCHANTED_SECATEURS,
            1,
            Integer::sum
        );

        if (config.generalRake()) {
            allRequirements.merge(
                ItemID.RAKE,
                1,
                Integer::sum
            );
        }

        return allRequirements;
    }

    public void setupLocations()
    {
        if (locationsInitialized) {
            return;
        }

        locations.clear();
        super.setupLocations();

        setupBrimhavenLocations();
        setupCatherbyLocations();
        setupFarmingGuildLocation();
        setupGnomeStrongholdLocation();
        setupLletyaLocation();
        setupTreeGnomeVillage();

        locationsInitialized = true;
    }

    private void setupBrimhavenLocations()
    {
        // NEW APPROACH: Using LocationData pattern for data-driven setup
        LocationData brimhavenData = BrimhavenFruitTreeLocationData.create(
            () -> getHouseTeleportItemRequirements()
        );
        
        brimhavenFruitTreeLocation = LocationFactory.createLocation(brimhavenData, config);
        locations.add(brimhavenFruitTreeLocation);
    }

    private void setupCatherbyLocations()
    {
        // NEW APPROACH: Using LocationData pattern for data-driven setup
        LocationData catherbyData = CatherbyFruitTreeLocationData.create(
            () -> getHouseTeleportItemRequirements()
        );
        
        catherbyFruitTreeLocation = LocationFactory.createLocation(catherbyData, config);
        locations.add(catherbyFruitTreeLocation);
    }

    private void setupFarmingGuildLocation()
    {
        // NEW APPROACH: Using LocationData pattern for data-driven setup
        LocationData farmingGuildData = FarmingGuildFruitTreeLocationData.create(
            () -> getHouseTeleportItemRequirements()
        );
        
        farmingGuildFruitTreeLocation = LocationFactory.createLocation(farmingGuildData, config);
        locations.add(farmingGuildFruitTreeLocation);
    }

    private void setupGnomeStrongholdLocation()
    {
        // NEW APPROACH: Using LocationData pattern for data-driven setup
        LocationData gnomeStrongholdData = GnomeStrongholdFruitTreeLocationData.create();
        
        gnomeStrongholdFruitTreeLocation = LocationFactory.createLocation(gnomeStrongholdData, config);
        locations.add(gnomeStrongholdFruitTreeLocation);
    }

    private void setupLletyaLocation()
    {
        // NEW APPROACH: Using LocationData pattern for data-driven setup
        LocationData lletyaData = LletyaFruitTreeLocationData.create();
        
        lletyaFruitTreeLocation = LocationFactory.createLocation(lletyaData, config);
        locations.add(lletyaFruitTreeLocation);
    }

    private void setupTreeGnomeVillage()
    {
        // NEW APPROACH: Using LocationData pattern for data-driven setup
        LocationData treeGnomeVillageData = TreeGnomeVillageFruitTreeLocationData.create();
        
        treeGnomeVillageFruitTreeLocation = LocationFactory.createLocation(treeGnomeVillageData, config);
        locations.add(treeGnomeVillageFruitTreeLocation);
    }
}
package com.easyfarming.ItemsAndLocations;

import com.easyfarming.EasyFarmingConfig;
import com.easyfarming.EasyFarmingPlugin;
import com.easyfarming.ItemRequirement;
import com.easyfarming.Location;
import com.easyfarming.utils.Constants;
import net.runelite.api.Client;
import net.runelite.api.gameval.ItemID;

import java.util.*;
import java.util.function.Supplier;

public class HerbRunItemAndLocation extends ItemAndLocation
{
    public Location ardougneLocation;
    public Location catherbyLocation;
    public Location faladorLocation;
    public Location farmingGuildLocation;
    public Location harmonyLocation;
    public Location kourendLocation;
    public Location morytaniaLocation;
    public Location trollStrongholdLocation;
    public Location weissLocation;
    public Location civitasLocation;

    public HerbRunItemAndLocation()
    {
    }

    public HerbRunItemAndLocation(EasyFarmingConfig config, Client client, EasyFarmingPlugin plugin)
    {
        super(
            config,
            client,
            plugin
        );
    }

    public Map<Integer, Integer> getHerbItems()
    {
        return getAllItemRequirements(locations);
    }

    public Map<Integer, Integer> getAllItemRequirements(List<Location> locations)
    {
        Map<Integer, Integer> allRequirements = new HashMap<>();

        setupLocations();

        // Add other items and merge them with allRequirements
        for (Location location : locations) {
            if (plugin.getHerbLocationEnabled(location.getName())) {
                //ItemID.GUAM_SEED is default for herb seeds, code later will allow for any seed to be used, just needed a placeholder ID
                allRequirements.merge(
                    ItemID.GUAM_SEED,
                    1,
                    Integer::sum
                );

                if (selectedCompostID() != - 1 && selectedCompostID() != ItemID.BOTTOMLESS_COMPOST_BUCKET) {
                    allRequirements.merge(
                        selectedCompostID(),
                        1,
                        Integer::sum
                    );
                }

                Location.Teleport teleport = location.getSelectedTeleport();

                Map<Integer, Integer> locationRequirements = teleport.getItemRequirements();

                for (Map.Entry<Integer, Integer> entry : locationRequirements.entrySet()) {
                    int itemId = entry.getKey();
                    int quantity = entry.getValue();

                    if (itemId == ItemID.SKILLCAPE_CONSTRUCTION || itemId == ItemID.SKILLCAPE_CONSTRUCTION_TRIMMED || itemId == ItemID.SKILLCAPE_MAX) {
                        allRequirements.merge(
                            itemId,
                            quantity,
                            (oldValue, newValue) -> Math.min(
                                1,
                                oldValue + newValue
                            )
                        );
                    } else if (itemId == ItemID.HG_QUETZALWHISTLE_BASIC || itemId == ItemID.HG_QUETZALWHISTLE_ENHANCED || itemId == ItemID.HG_QUETZALWHISTLE_PERFECTED) {
                        // Handle Quetzal whistle variants - only show the basic one in requirements
                        allRequirements.merge(
                            ItemID.HG_QUETZALWHISTLE_BASIC,  // Always show the basic variant
                            quantity,
                            (oldValue, newValue) -> Math.min(
                                1,
                                oldValue + newValue
                            )
                        );
                    } else if (itemId == ItemID.SKILLCAPE_HUNTING || itemId == ItemID.SKILLCAPE_HUNTING_TRIMMED) {
                        // Handle Hunter skillcape variants - only show the regular one in requirements
                        allRequirements.merge(
                            ItemID.SKILLCAPE_HUNTING,  // Always show the regular variant
                            quantity,
                            (oldValue, newValue) -> Math.min(
                                1,
                                oldValue + newValue
                            )
                        );
                    } else if (itemId == ItemID.LUMBRIDGE_RING_MEDIUM || itemId == ItemID.LUMBRIDGE_RING_HARD || itemId == ItemID.LUMBRIDGE_RING_ELITE) {
                        // Handle Explorer's Ring variants - normalize to base ID
                        allRequirements.merge(
                            ItemID.LUMBRIDGE_RING_MEDIUM,  // Always show the base variant
                            quantity,
                            (oldValue, newValue) -> Math.min(
                                1,
                                oldValue + newValue
                            )
                        );
                    } else if (itemId == ItemID.ARDY_CAPE_MEDIUM || itemId == ItemID.ARDY_CAPE_HARD || itemId == ItemID.ARDY_CAPE_ELITE) {
                        // Handle Ardougne Cloak variants - normalize to base ID
                        allRequirements.merge(
                            ItemID.ARDY_CAPE_MEDIUM,  // Always show the base variant
                            quantity,
                            (oldValue, newValue) -> Math.min(
                                1,
                                oldValue + newValue
                            )
                        );
                    } else {
                        allRequirements.merge(
                            itemId,
                            quantity,
                            Integer::sum
                        );
                    }
                }

                if (location.getFarmLimps() && config.generalLimpwurt()) {
                    allRequirements.merge(
                        ItemID.LIMPWURT_SEED,
                        1,
                        Integer::sum
                    );

                    if (selectedCompostID() != - 1 && selectedCompostID() != ItemID.BOTTOMLESS_COMPOST_BUCKET) {
                        allRequirements.merge(
                            selectedCompostID(),
                            1,
                            Integer::sum
                        );
                    }
                }

                // Add allotment seed requirements if enabled
                if (config.generalAllotment()) {
                    int allotmentPatches = 2; // Most locations have 2 allotment patches
                    if (location.getName().equals("Harmony Island")) {
                        allotmentPatches = 1; // Harmony only has 1 allotment patch
                    }
                    
                    // Each allotment patch requires 3 seeds
                    int seedsPerPatch = 3;
                    int totalAllotmentSeeds = allotmentPatches * seedsPerPatch;
                    
                    // Use SNAPE_GRASS_SEED as base ID (similar to GUAM_SEED for herbs)
                    allRequirements.merge(
                        Constants.BASE_ALLOTMENT_SEED_ID,
                        totalAllotmentSeeds,
                        Integer::sum
                    );

                    // Allotment patches also need compost (same as herb patches)
                    if (selectedCompostID() != - 1 && selectedCompostID() != ItemID.BOTTOMLESS_COMPOST_BUCKET) {
                        allRequirements.merge(
                            selectedCompostID(),
                            allotmentPatches,
                            Integer::sum
                        );
                    }
                }
            }
        }
        if(config.generalSeedDibber()) {
            allRequirements.merge(
                ItemID.DIBBER,
                1,
                Integer::sum
            );
        }

        allRequirements.merge(
            ItemID.SPADE,
            1,
            Integer::sum
        );

        if (selectedCompostID() == ItemID.BOTTOMLESS_COMPOST_BUCKET) {
            allRequirements.merge(
                ItemID.BOTTOMLESS_COMPOST_BUCKET,
                1,
                Integer::sum
            );
        }

        allRequirements.merge(
            ItemID.FAIRY_ENCHANTED_SECATEURS,
            1,
            Integer::sum
        );

        if (config.generalRake()) {
            allRequirements.merge(
                ItemID.RAKE,
                1,
                Integer::sum
            );
        }

        // Add watering can if allotments are enabled (only one needed for entire run)
        if (config.generalAllotment()) {
            allRequirements.merge(
                Constants.WATERING_CAN_IDS.get(0), // Base watering can ID
                1,
                Integer::sum
            );
        }

        return allRequirements;
    }

    public void setupLocations()
    {
        super.setupLocations();

        setupArdougneLocation();
        setupCatherbyLocation();
        setupFaladorLocation();
        setupFarmingGuildLocation();
        setupHarmonyLocation();
        setupKourendLocation();
        setupMorytaniaLocation();
        setupTrollStrongholdLocation();
        setupWeissLocation();
        setupCivitasLocation();
    }

    private Supplier<List<ItemRequirement>> createHouseTeleportSupplier() {
        return () -> getHouseTeleportItemRequirements();
    }

    private void setupCivitasLocation()
    {
        // NEW APPROACH: Using LocationData pattern for data-driven setup
        com.easyfarming.locations.LocationData civitasData = 
            com.easyfarming.locations.CivitasLocationData.create(createHouseTeleportSupplier());
        
        civitasLocation = com.easyfarming.locations.LocationFactory.createLocation(civitasData, config);
        locations.add(civitasLocation);
    }

    private void setupArdougneLocation()
    {
        // NEW APPROACH: Using LocationData pattern for data-driven setup
        com.easyfarming.locations.LocationData ardougneData = 
            com.easyfarming.locations.ArdougneLocationData.create(createHouseTeleportSupplier());
        
        ardougneLocation = com.easyfarming.locations.LocationFactory.createLocation(ardougneData, config);
        locations.add(ardougneLocation);
    }

    private void setupCatherbyLocation()
    {
        // NEW APPROACH: Using LocationData pattern for data-driven setup
        com.easyfarming.locations.LocationData catherbyData = 
            com.easyfarming.locations.CatherbyLocationData.create(createHouseTeleportSupplier());
        
        catherbyLocation = com.easyfarming.locations.LocationFactory.createLocation(catherbyData, config);
        locations.add(catherbyLocation);
    }

    private void setupFaladorLocation()
    {
        // NEW APPROACH: Using LocationData pattern for data-driven setup
        com.easyfarming.locations.LocationData faladorData = 
            com.easyfarming.locations.FaladorLocationData.create(createHouseTeleportSupplier());
        
        faladorLocation = com.easyfarming.locations.LocationFactory.createLocation(faladorData, config);
        locations.add(faladorLocation);
    }

    private void setupFarmingGuildLocation()
    {
        // NEW APPROACH: Using LocationData pattern for data-driven setup
        com.easyfarming.locations.LocationData farmingGuildData = 
            com.easyfarming.locations.FarmingGuildLocationData.create(createHouseTeleportSupplier());
        
        farmingGuildLocation = com.easyfarming.locations.LocationFactory.createLocation(farmingGuildData, config);
        locations.add(farmingGuildLocation);
    }

    private void setupHarmonyLocation()
    {
        // NEW APPROACH: Using LocationData pattern for data-driven setup
        com.easyfarming.locations.LocationData harmonyData = 
            com.easyfarming.locations.HarmonyLocationData.create(createHouseTeleportSupplier());
        
        harmonyLocation = com.easyfarming.locations.LocationFactory.createLocation(harmonyData, config);
        locations.add(harmonyLocation);
    }

    private void setupKourendLocation()
    {
        // NEW APPROACH: Using LocationData pattern for data-driven setup
        com.easyfarming.locations.LocationData kourendData = 
            com.easyfarming.locations.KourendLocationData.create(createHouseTeleportSupplier());
        
        kourendLocation = com.easyfarming.locations.LocationFactory.createLocation(kourendData, config);
        locations.add(kourendLocation);
    }

    private void setupMorytaniaLocation()
    {
        // NEW APPROACH: Using LocationData pattern for data-driven setup
        com.easyfarming.locations.LocationData morytaniaData = com.easyfarming.locations.MorytaniaLocationData.create();
        
        morytaniaLocation = com.easyfarming.locations.LocationFactory.createLocation(morytaniaData, config);
        locations.add(morytaniaLocation);
    }

    private void setupTrollStrongholdLocation()
    {
        // NEW APPROACH: Using LocationData pattern for data-driven setup
        com.easyfarming.locations.LocationData trollStrongholdData = 
            com.easyfarming.locations.TrollStrongholdLocationData.create(createHouseTeleportSupplier());
        
        trollStrongholdLocation = com.easyfarming.locations.LocationFactory.createLocation(trollStrongholdData, config);
        locations.add(trollStrongholdLocation);
    }

    private void setupWeissLocation()
    {
        // NEW APPROACH: Using LocationData pattern for data-driven setup
        com.easyfarming.locations.LocationData weissData = 
            com.easyfarming.locations.WeissLocationData.create(createHouseTeleportSupplier());
        
        weissLocation = com.easyfarming.locations.LocationFactory.createLocation(weissData, config);
        locations.add(weissLocation);
    }


}
package com.easyfarming.ItemsAndLocations;

import com.easyfarming.EasyFarmingConfig;
import com.easyfarming.EasyFarmingPlugin;
import com.easyfarming.ItemRequirement;
import com.easyfarming.Location;
import net.runelite.api.Client;
import net.runelite.api.gameval.ItemID;

import java.util.ArrayList;
import java.util.List;

public class ItemAndLocation
{
    protected EasyFarmingConfig config;

    protected Client client;

    protected EasyFarmingPlugin plugin;

    public List<Location> locations = new ArrayList<>();

    public ItemAndLocation()
    {
    }

    public ItemAndLocation(EasyFarmingConfig config, Client client, EasyFarmingPlugin plugin)
    {
        this.config = config;
        this.client = client;
        this.plugin = plugin;
    }

    public List<ItemRequirement> getHouseTeleportItemRequirements()
    {
        EasyFarmingConfig.OptionEnumHouseTele selectedOption = config.enumConfigHouseTele();

        List<ItemRequirement> itemRequirements = new ArrayList<>();

        switch (selectedOption) {
            case Law_air_earth_runes:
                itemRequirements.add(new ItemRequirement(
                    ItemID.AIRRUNE,
                    1
                ));

                itemRequirements.add(new ItemRequirement(
                    ItemID.EARTHRUNE,
                    1
                ));

                itemRequirements.add(new ItemRequirement(
                    ItemID.LAWRUNE,
                    1
                ));

                break;

            case Teleport_To_House:
                itemRequirements.add(new ItemRequirement(
                    ItemID.POH_TABLET_TELEPORTTOHOUSE,
                    1
                ));

                break;

            case Construction_cape:
                itemRequirements.add(new ItemRequirement(
                    ItemID.SKILLCAPE_CONSTRUCTION,
                    1
                ));

                break;

            case Construction_cape_t:
                itemRequirements.add(new ItemRequirement(
                    ItemID.SKILLCAPE_CONSTRUCTION_TRIMMED,
                    1
                ));

                break;
            case Max_cape:
                itemRequirements.add(new ItemRequirement(
                    ItemID.SKILLCAPE_MAX,
                    1
                ));

                break;

            default:
                throw new IllegalStateException("Unexpected value: " + selectedOption);
        }

        return itemRequirements;
    }

    public Integer selectedCompostID()
    {
        EasyFarmingConfig.OptionEnumCompost selectedCompost = config.enumConfigCompost();

        switch (selectedCompost) {
            case Compost:
                return ItemID.BUCKET_COMPOST;

            case Supercompost:
                return ItemID.BUCKET_SUPERCOMPOST;

            case Ultracompost:
                return ItemID.BUCKET_ULTRACOMPOST;

            case Bottomless:
                return ItemID.BOTTOMLESS_COMPOST_BUCKET;
            default:
                return 0;
        }
    }    public void setupLocations()
    {
        locations.clear();
    }
}

package com.easyfarming.ItemsAndLocations;

import com.easyfarming.EasyFarmingConfig;
import com.easyfarming.EasyFarmingPlugin;
import com.easyfarming.ItemRequirement;
import com.easyfarming.Location;
import net.runelite.api.Client;
import net.runelite.api.gameval.ItemID;

import java.util.*;

public class TreeRunItemAndLocation extends ItemAndLocation
{
    public Location faladorTreeLocation;
    public Location farmingGuildTreeLocation;
    public Location gnomeStrongholdTreeLocation;
    public Location lumbridgeTreeLocation;
    public Location taverleyTreeLocation;
    public Location varrockTreeLocation;

    public TreeRunItemAndLocation()
    {
    }

    public TreeRunItemAndLocation(EasyFarmingConfig config, Client client, EasyFarmingPlugin plugin)
    {
        super(
            config,
            client,
            plugin
        );
    }

    public Map<Integer, Integer> getTreeItems()
    {
        return getAllItemRequirements(locations);
    }

    public Map<Integer, Integer> getAllItemRequirements(List<Location> locations)
    {
        Map<Integer, Integer> allRequirements = new HashMap<>();

        setupLocations();

        // Add other items and merge them with allRequirements
        for (Location location : locations) {
            if (plugin.getTreeLocationEnabled(location.getName())) {
                //ItemID.GUAM_SEED is default for herb seeds, code later will allow for any seed to be used, just needed a placeholder ID
                //allRequirements.merge(ItemID.GUAM_SEED, 1, Integer::sum);
                allRequirements.merge(
                    ItemID.PLANTPOT_OAK_SAPLING,
                    1,
                    Integer::sum
                );

                allRequirements.merge(
                    ItemID.COINS,
                    200,
                    Integer::sum
                );

                if (selectedCompostID() != -1 && selectedCompostID() != ItemID.BOTTOMLESS_COMPOST_BUCKET) {
                    allRequirements.merge(
                        selectedCompostID(),
                        1,
                        Integer::sum
                    );
                }

                Location.Teleport teleport = location.getSelectedTeleport();

                Map<Integer, Integer> locationRequirements = teleport.getItemRequirements();

                for (Map.Entry<Integer, Integer> entry : locationRequirements.entrySet()) {
                    int itemId = entry.getKey();
                    int quantity = entry.getValue();

                    if (itemId == ItemID.SKILLCAPE_CONSTRUCTION || itemId == ItemID.SKILLCAPE_CONSTRUCTION_TRIMMED || itemId == ItemID.SKILLCAPE_MAX) {
                        allRequirements.merge(
                            itemId,
                            quantity,
                            (oldValue, newValue) -> Math.min(
                                1,
                                oldValue + newValue
                            )
                        );
                    } else {
                        allRequirements.merge(
                            itemId,
                            quantity,
                            Integer::sum
                        );
                    }
                }
            }
        }

        //allRequirements.merge(ItemID.SEED_DIBBER, 1, Integer::sum);
        allRequirements.merge(
            ItemID.SPADE,
            1,
            Integer::sum
        );

        // Only add bottomless compost bucket if it's selected in config
        if (selectedCompostID() == ItemID.BOTTOMLESS_COMPOST_BUCKET) {
            allRequirements.merge(
                ItemID.BOTTOMLESS_COMPOST_BUCKET,
                1,
                Integer::sum
            );
        }

        allRequirements.merge(
            ItemID.FAIRY_ENCHANTED_SECATEURS,
            1,
            Integer::sum
        );

        if (config.generalRake()) {
            allRequirements.merge(
                ItemID.RAKE,
                1,
                Integer::sum
            );
        }

        return allRequirements;
    }

    public void setupLocations()
    {
        super.setupLocations();

        setupFaladorLocation();
        setupFarmingGuildLocation();
        setupGnomeStrongholdLocation();
        setupLumbridgeLocation();
        setupTaverleyLocation();
        setupVarrockLocation();
    }

    private void setupFaladorLocation()
    {
        // NEW APPROACH: Using LocationData pattern for data-driven setup
        com.easyfarming.locations.LocationData faladorData = com.easyfarming.locations.tree.FaladorTreeLocationData.create(
            () -> getHouseTeleportItemRequirements()
        );
        
        faladorTreeLocation = com.easyfarming.locations.LocationFactory.createLocation(faladorData, config);
        locations.add(faladorTreeLocation);
    }

    private void setupFarmingGuildLocation()
    {
        // NEW APPROACH: Using LocationData pattern for data-driven setup
        com.easyfarming.locations.LocationData farmingGuildData = com.easyfarming.locations.tree.FarmingGuildTreeLocationData.create(
            () -> getHouseTeleportItemRequirements()
        );
        
        farmingGuildTreeLocation = com.easyfarming.locations.LocationFactory.createLocation(farmingGuildData, config);
        locations.add(farmingGuildTreeLocation);
    }

    private void setupGnomeStrongholdLocation()
    {
        // NEW APPROACH: Using LocationData pattern for data-driven setup
        com.easyfarming.locations.LocationData gnomeStrongholdData = com.easyfarming.locations.tree.GnomeStrongholdTreeLocationData.create();
        
        gnomeStrongholdTreeLocation = com.easyfarming.locations.LocationFactory.createLocation(gnomeStrongholdData, config);
        locations.add(gnomeStrongholdTreeLocation);
    }

    private void setupLumbridgeLocation()
    {
        // NEW APPROACH: Using LocationData pattern for data-driven setup
        com.easyfarming.locations.LocationData lumbridgeData = com.easyfarming.locations.tree.LumbridgeTreeLocationData.create(
            () -> getHouseTeleportItemRequirements()
        );
        
        lumbridgeTreeLocation = com.easyfarming.locations.LocationFactory.createLocation(lumbridgeData, config);
        locations.add(lumbridgeTreeLocation);
    }

    private void setupTaverleyLocation()
    {
        // NEW APPROACH: Using LocationData pattern for data-driven setup
        com.easyfarming.locations.LocationData taverleyData = com.easyfarming.locations.tree.TaverleyTreeLocationData.create(
            () -> getHouseTeleportItemRequirements()
        );
        
        taverleyTreeLocation = com.easyfarming.locations.LocationFactory.createLocation(taverleyData, config);
        locations.add(taverleyTreeLocation);
    }

    private void setupVarrockLocation()
    {
        // NEW APPROACH: Using LocationData pattern for data-driven setup
        com.easyfarming.locations.LocationData varrockData = com.easyfarming.locations.tree.VarrockTreeLocationData.create(
            () -> getHouseTeleportItemRequirements()
        );
        
        varrockTreeLocation = com.easyfarming.locations.LocationFactory.createLocation(varrockData, config);
        locations.add(varrockTreeLocation);
    }
}
package com.easyfarming;

import com.easyfarming.ItemsAndLocations.HerbRunItemAndLocation;
import com.easyfarming.ItemsAndLocations.TreeRunItemAndLocation;
import com.easyfarming.ItemsAndLocations.FruitTreeRunItemAndLocation;

import com.google.inject.Provides;
import java.awt.image.BufferedImage;
import javax.inject.Inject;

import lombok.Getter;
import lombok.Setter;
import net.runelite.api.*;
import net.runelite.api.events.ChatMessage;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.game.ItemManager;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.plugins.PluginDescriptor;
import net.runelite.client.ui.NavigationButton;
import net.runelite.client.util.ImageUtil;
import net.runelite.client.ui.ClientToolbar;
import net.runelite.client.ui.overlay.OverlayManager;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.eventbus.EventBus;

@PluginDescriptor(
		name = "Easy Farming",
		description = "Show item requirements and highlights for farming runs."
)

public class EasyFarmingPlugin extends Plugin
{
	private HerbRunItemAndLocation herbRunItemAndLocation;
	private TreeRunItemAndLocation treeRunItemAndLocation;
	private FruitTreeRunItemAndLocation fruitTreeRunItemAndLocation;


	@Inject
	private ItemManager itemManager;
	@Getter
    @Inject
	private Client client;

	public void runOnClientThread(Runnable task) {
		clientThread.invokeLater(task);
	}

	public Location getArdougneLocation() {
		return herbRunItemAndLocation.ardougneLocation;
	}
	public Location getCatherbyLocation() {
		return herbRunItemAndLocation.catherbyLocation;
	}
	public Location getFaladorLocation() {
		return herbRunItemAndLocation.faladorLocation;
	}
	public Location getFarmingGuildLocation() {return herbRunItemAndLocation.farmingGuildLocation;}
	public Location getHarmonyLocation() {
		return herbRunItemAndLocation.harmonyLocation;
	}
	public Location getKourendLocation() {
		return herbRunItemAndLocation.kourendLocation;
	}
	public Location getMorytaniaLocation() {
		return herbRunItemAndLocation.morytaniaLocation;
	}
	public Location getTrollStrongholdLocation() {
		return herbRunItemAndLocation.trollStrongholdLocation;
	}

	public Location getWeissLocation() {
		return herbRunItemAndLocation.weissLocation;
	}

	public Location getCivitasLocation() {
		return herbRunItemAndLocation.civitasLocation;
	}

	//get Tree locations
	public Location getFaladorTreeLocation() {return treeRunItemAndLocation.faladorTreeLocation;}
	public Location getFarmingGuildTreeLocation() {
		return treeRunItemAndLocation.farmingGuildTreeLocation;
	}
	public Location getGnomeStrongholdTreeLocation() {return treeRunItemAndLocation.gnomeStrongholdTreeLocation;}
	public Location getLumbridgeTreeLocation() {return treeRunItemAndLocation.lumbridgeTreeLocation;}
	public Location getTaverleyTreeLocation() {
		return treeRunItemAndLocation.taverleyTreeLocation;
	}
	public Location getVarrockTreeLocation() {
		return treeRunItemAndLocation.varrockTreeLocation;
	}

	//get fruit tree locations
	public Location getBrimhavenFruitTreeLocation() {return fruitTreeRunItemAndLocation.brimhavenFruitTreeLocation;}
	public Location getCatherbyFruitTreeLocation() {return fruitTreeRunItemAndLocation.catherbyFruitTreeLocation;}
	public Location getFarmingGuildFruitTreeLocation() {return fruitTreeRunItemAndLocation.farmingGuildFruitTreeLocation;}
	public Location getGnomeStrongholdFruitTreeLocation() {return fruitTreeRunItemAndLocation.gnomeStrongholdFruitTreeLocation;}
	public Location getLletyaFruitTreeLocation() {return fruitTreeRunItemAndLocation.lletyaFruitTreeLocation;}
	public Location getTreeGnomeVillageTreeLocation() {return fruitTreeRunItemAndLocation.treeGnomeVillageFruitTreeLocation;}

	@Getter
    @Setter
    private boolean isTeleportOverlayActive = false;

    @Inject
	private EasyFarmingOverlayInfoBox farmingHelperOverlayInfoBox;
	public EasyFarmingOverlayInfoBox getEasyFarmingOverlayInfoBox()
	{
		return farmingHelperOverlayInfoBox;
	}

	@Getter
    private String lastMessage = "";
    @Subscribe
    public void onChatMessage(ChatMessage event) {
        String message = event.getMessage();
        
        // Store last message for other purposes (compost detection, etc.)
        if (event.getType() == ChatMessageType.GAMEMESSAGE) {
            lastMessage = message;
        }
        else if (event.getType() == ChatMessageType.SPAM) {
            lastMessage = message;
        }
    }

    public boolean checkMessage(String targetMessage, String lastMessage) {
		return lastMessage.trim().equalsIgnoreCase(targetMessage.trim());
	}

	@Inject
	private EventBus eventBus;

	@Inject
	private ClientThread clientThread;


	@Getter
    @Inject
	private FarmingTeleportOverlay farmingTeleportOverlay;

	private EasyFarmingPanel farmingHelperPanel;
	public EasyFarmingPanel panel;
	private NavigationButton navButton;

	@Inject
	private ClientToolbar clientToolbar;

	@Inject
	private EasyFarmingConfig config;
	@Inject
	public OverlayManager overlayManager;

	@Getter
    @Setter
    private boolean isOverlayActive = true;

	@Inject
	private EasyFarmingOverlay farmingHelperOverlay;

	public EasyFarmingOverlay getEasyFarmingOverlay()
	{
		return farmingHelperOverlay;
	}

	@Setter
    private boolean itemsCollected = false;
	public boolean areItemsCollected() {
		return itemsCollected;
	}

	@Provides
	EasyFarmingConfig getConfig(ConfigManager configManager)
	{
		return configManager.getConfig(EasyFarmingConfig.class);
	}
	
	@Provides
	com.easyfarming.overlays.utils.ColorProvider provideColorProvider(EasyFarmingConfig config)
	{
		return new com.easyfarming.overlays.utils.ColorProvider(config);
	}
	
	@Provides
	HerbRunItemAndLocation provideHerbRunItemAndLocation(EasyFarmingConfig config, Client client, EasyFarmingPlugin plugin)
	{
		return new HerbRunItemAndLocation(config, client, plugin);
	}
	
	@Provides
	TreeRunItemAndLocation provideTreeRunItemAndLocation(EasyFarmingConfig config, Client client, EasyFarmingPlugin plugin)
	{
		return new TreeRunItemAndLocation(config, client, plugin);
	}
	
	@Provides
	FruitTreeRunItemAndLocation provideFruitTreeRunItemAndLocation(EasyFarmingConfig config, Client client, EasyFarmingPlugin plugin)
	{
		return new FruitTreeRunItemAndLocation(config, client, plugin);
	}
	
	@Provides
	EasyFarmingOverlay provideEasyFarmingOverlay(Client client, EasyFarmingPlugin plugin, ItemManager itemManager,
	                                             HerbRunItemAndLocation herbRunItemAndLocation,
	                                             TreeRunItemAndLocation treeRunItemAndLocation,
	                                             FruitTreeRunItemAndLocation fruitTreeRunItemAndLocation)
	{
		return new EasyFarmingOverlay(client, plugin, itemManager, herbRunItemAndLocation, treeRunItemAndLocation, fruitTreeRunItemAndLocation);
	}

    public void addTextToInfoBox(String text) {
		farmingHelperOverlayInfoBox.setText(text);
	}

    public void addDebugTextToInfoBox(String debugText) {
		farmingHelperOverlayInfoBox.setDebugText(debugText);
	}
	public boolean getHerbLocationEnabled(String locationName) {
		switch (locationName) {
			case "Ardougne":
				return config.ardougneHerb();
			case "Catherby":
				return config.catherbyHerb();
			case "Falador":
				return config.faladorHerb();
			case "Farming Guild":
				return config.farmingGuildHerb();
			case "Harmony Island":
				return config.harmonyHerb();
			case "Kourend":
				return config.kourendHerb();
			case "Morytania":
				return config.morytaniaHerb();
			case "Troll Stronghold":
				return config.trollStrongholdHerb();
			case "Weiss":
				return config.weissHerb();
			case "Civitas illa Fortis":
				return config.civitasHerb();
			// Add cases for other locations as needed
			default:
				return false;
		}
	}

	public boolean getTreeLocationEnabled(String locationName) {
		switch (locationName) {
			case "Falador":
				return config.faladorTree();
			case "Farming Guild":
				return config.farmingGuildTree();
			case "Gnome Stronghold":
				return config.gnomeStrongholdTree();
			case "Lumbridge":
				return config.lumbridgeTree();
			case "Taverley":
				return config.taverleyTree();
			case "Varrock":
				return config.varrockTree();
			// Add cases for other locations as needed
			default:
				return false;
		}
	}

	public boolean getFruitTreeLocationEnabled(String locationName) {
		switch (locationName) {
			case "Brimhaven":
				return config.brimhavenFruitTree();
			case "Catherby":
				return config.catherbyFruitTree();
			case "Farming Guild":
				return config.farmingGuildFruitTree();
			case "Gnome Stronghold":
				return config.gnomeStrongholdFruitTree();
			case "Lletya":
				return config.lletyaFruitTree();
			case "Tree Gnome Village":
				return config.treeGnomeVillageFruitTree();
			// Add cases for other locations as needed
			default:
				return false;
		}
	}

	@Override
	protected void startUp()
	{
		herbRunItemAndLocation = new HerbRunItemAndLocation(config, client, this);
		treeRunItemAndLocation = new TreeRunItemAndLocation(config, client, this);
		fruitTreeRunItemAndLocation = new FruitTreeRunItemAndLocation(config, client, this);
		farmingHelperOverlay = new EasyFarmingOverlay(client, this, itemManager, herbRunItemAndLocation, treeRunItemAndLocation, fruitTreeRunItemAndLocation);

		panel = new EasyFarmingPanel(this, overlayManager, farmingTeleportOverlay, herbRunItemAndLocation, treeRunItemAndLocation, fruitTreeRunItemAndLocation);
		final BufferedImage icon = ImageUtil.loadImageResource(getClass(), "/icon.png");

		navButton = NavigationButton.builder()
				.tooltip("Easy Farming")
				.icon(icon)
				.priority(6)
				.panel(panel)
				.build();
		clientToolbar.addNavigation(navButton);

		overlayManager.add(farmingHelperOverlay);
		overlayManager.add(farmingTeleportOverlay);
		overlayManager.add(farmingHelperOverlayInfoBox);

		// set overlay to inactive
		isOverlayActive = false;
		eventBus.register(this);

		herbRunItemAndLocation.setupLocations();
	}

	@Override
	protected void shutDown()
	{
		if (navButton != null) {
			clientToolbar.removeNavigation(navButton);
		}

		overlayManager.remove(farmingHelperOverlay);
		overlayManager.remove(farmingTeleportOverlay);
		overlayManager.remove(farmingHelperOverlayInfoBox);

		eventBus.unregister(this);
	}
}
package com.easyfarming;

import net.runelite.api.Client;

import java.util.Arrays;
import java.util.List;

public class FlowerPatchChecker {
    // Add lists for each plant state
    private static final List<Integer> HARVESTABLE = Arrays.asList(32);
    private static final List<Integer> GROWING = Arrays.asList(28, 29, 30, 31);
    private static final List<Integer> DISEASED = Arrays.asList(159); // Limpwurt diseased
    private static final List<Integer> DEAD = Arrays.asList(221,222,223,224);
    private static final List<Integer> WEEDS = Arrays.asList(0, 1, 2);


    public enum PlantState {
        HARVESTABLE,
        GROWING,
        DISEASED,
        DEAD,
        WEEDS,
        PLANT,
        UNKNOWN
    }

    public static PlantState checkFlowerPatch(Client client, int varbitIndex) {
        int varbitValue = client.getVarbitValue(varbitIndex);

        if (HARVESTABLE.contains(varbitValue)) {
            return PlantState.HARVESTABLE;
        } else if (GROWING.contains(varbitValue)) {
            return PlantState.GROWING;
        } else if (DISEASED.contains(varbitValue)) {
            return PlantState.DISEASED;
        } else if (DEAD.contains(varbitValue)) {
            return PlantState.DEAD;
        } else if (WEEDS.contains(varbitValue)) {
            return PlantState.WEEDS;
        } else if (varbitValue == 3) {
            return PlantState.PLANT;
        } else {
            return PlantState.UNKNOWN;
        }
    }}
package com.easyfarming;

import javax.swing.*;
import java.awt.*;

public class StartStopJButton extends JButton {
    private String originalText;

    public StartStopJButton(String text) {
        super(text, null);

        this.originalText = text;
        this.setStartStopState(false);
    }

    public void setStartStopState(boolean started)
    {
        String startOrStop = started ? "Stop " : "Start ";

        this.setText(startOrStop.concat(this.originalText));
        this.setBackground(started ? Color.RED : Color.BLACK);
    }
}
package com.easyfarming.items;

import com.easyfarming.EasyFarmingConfig;
import com.easyfarming.EasyFarmingPlugin;
import com.easyfarming.ItemRequirement;
import com.easyfarming.core.Location;
import com.easyfarming.core.Teleport;
import net.runelite.api.gameval.ItemID;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

/**
 * NOTE: This class is part of an incomplete refactoring effort.
 * 
 * This class was designed to replace the current ItemsAndLocations.* package structure
 * and work with the new locations.* package classes, but the migration was never completed.
 * 
 * Currently unused - no instantiation found in the codebase.
 * 
 * SPARED FROM PURGING: This appears to be part of an unimplemented feature/refactoring
 * and may be completed in the future.
 */
public class ItemRequirementCalculator {
    
    private final EasyFarmingConfig config;
    private final EasyFarmingPlugin plugin;
    private final ItemAndLocationHelper itemHelper;
    
    public ItemRequirementCalculator(EasyFarmingConfig config, EasyFarmingPlugin plugin, ItemAndLocationHelper itemHelper) {
        this.config = config;
        this.plugin = plugin;
        this.itemHelper = itemHelper;
    }
    
    public Map<Integer, Integer> calculateItemRequirements(RunType runType, List<Location> locations) {
        Map<Integer, Integer> allRequirements = new HashMap<>();
        
        // Get run-specific configuration
        RunTypeConfig runConfig = getRunTypeConfig(runType);
        
        // Process each location
        for (Location location : locations) {
            if (!isLocationEnabled(runType, location.getName())) {
                continue;
            }
            
            // Add seed/sapling for this location
            allRequirements.merge(runConfig.getSeedId(), 1, Integer::sum);
            
            // Add coins for tree types
            if (runConfig.requiresCoins()) {
                allRequirements.merge(ItemID.COINS, 200, Integer::sum);
            }
            
            // Add compost if needed (not bottomless)
            Integer compostId = itemHelper.selectedCompostID();
            if (compostId != null && compostId != -1 && compostId != ItemID.BOTTOMLESS_COMPOST_BUCKET) {
                allRequirements.merge(compostId, 1, Integer::sum);
            }
            
            // Add teleport requirements
            Teleport teleport = location.getSelectedTeleport();
            if (teleport == null) {
                continue;
            }
            Map<Integer, Integer> locationRequirements = teleport.getItemRequirements();
            
            for (Map.Entry<Integer, Integer> entry : locationRequirements.entrySet()) {
                int itemId = entry.getKey();
                int quantity = entry.getValue();
                
                // Handle special items that should be counted as 1 max
                if (isSpecialItem(itemId, runType)) {
                    allRequirements.putIfAbsent(itemId, 1);
                } else {
                    allRequirements.merge(itemId, quantity, Integer::sum);
                }
            }            
            // Handle limpwurt seeds for herb runs
            if (runType == RunType.HERB && location.getFarmLimps() && config.generalLimpwurt()) {
                allRequirements.merge(ItemID.LIMPWURT_SEED, 1, Integer::sum);
                
                // Add compost for limpwurt patch if needed
                if (compostId != null && compostId != -1 && compostId != ItemID.BOTTOMLESS_COMPOST_BUCKET) {
                    allRequirements.merge(compostId, 1, Integer::sum);
                }
            }
        }
        
        // Add common tools
        if (runType == RunType.HERB && config.generalSeedDibber()) {
            allRequirements.merge(ItemID.DIBBER, 1, Integer::sum);
        }
        
        allRequirements.merge(ItemID.SPADE, 1, Integer::sum);
        
        // Add bottomless compost bucket if selected
        Integer compostId = itemHelper.selectedCompostID();
        if (compostId != null && compostId == ItemID.BOTTOMLESS_COMPOST_BUCKET) {
            allRequirements.merge(ItemID.BOTTOMLESS_COMPOST_BUCKET, 1, Integer::sum);
        }
        
        allRequirements.merge(ItemID.FAIRY_ENCHANTED_SECATEURS, 1, Integer::sum);
        
        if (config.generalRake()) {
            allRequirements.merge(ItemID.RAKE, 1, Integer::sum);
        }
        
        return allRequirements;
    }
    
    private boolean isLocationEnabled(RunType runType, String locationName) {
        switch (runType) {
            case HERB:
                return plugin.getHerbLocationEnabled(locationName);
            case TREE:
                return plugin.getTreeLocationEnabled(locationName);
            case FRUIT_TREE:
                return plugin.getFruitTreeLocationEnabled(locationName);
            default:
                return false;
        }
    }
    
    private boolean isSpecialItem(int itemId, RunType runType) {
        // Items that should be counted as max 1 regardless of how many locations need them
        if (itemId == ItemID.SKILLCAPE_CONSTRUCTION || 
            itemId == ItemID.SKILLCAPE_CONSTRUCTION_TRIMMED || 
            itemId == ItemID.SKILLCAPE_MAX) {
            return true;
        }
        
        if (itemId == ItemID.HG_QUETZALWHISTLE_BASIC || 
            itemId == ItemID.HG_QUETZALWHISTLE_ENHANCED || 
            itemId == ItemID.HG_QUETZALWHISTLE_PERFECTED) {
            return true;
        }
        
        if (itemId == ItemID.SKILLCAPE_HUNTING || 
            itemId == ItemID.SKILLCAPE_HUNTING_TRIMMED) {
            return true;
        }
        
        if (runType == RunType.FRUIT_TREE && itemId == ItemID.MM2_ROYAL_SEED_POD) {
            return true;
        }
        
        return false;
    }
    
    private RunTypeConfig getRunTypeConfig(RunType runType) {
        switch (runType) {
            case HERB:
                return new RunTypeConfig(ItemID.GUAM_SEED, false);
            case TREE:
                return new RunTypeConfig(ItemID.PLANTPOT_OAK_SAPLING, true);
            case FRUIT_TREE:
                return new RunTypeConfig(ItemID.PLANTPOT_APPLE_SAPLING, true);
            default:
                throw new IllegalArgumentException("Unknown run type: " + runType);
        }
    }
    
    private static class RunTypeConfig {
        private final int seedId;
        private final boolean requiresCoins;
        
        public RunTypeConfig(int seedId, boolean requiresCoins) {
            this.seedId = seedId;
            this.requiresCoins = requiresCoins;
        }
        
        public int getSeedId() { return seedId; }
        public boolean requiresCoins() { return requiresCoins; }
    }
    
    // Helper interface to abstract ItemAndLocation methods
    public interface ItemAndLocationHelper {
        Integer selectedCompostID();
        List<ItemRequirement> getHouseTeleportItemRequirements();
    }
}


package com.easyfarming.items;

public enum RunType {
    HERB,
    TREE,
    FRUIT_TREE
}


package com.easyfarming.core;

import com.easyfarming.EasyFarmingConfig;
import java.util.ArrayList;
import java.util.List;
import java.util.function.Function;

public class Location {
    private String name;
    private Boolean farmLimps;
    private List<Teleport> teleportOptions;
    private EasyFarmingConfig config;
    private final Function<EasyFarmingConfig, EasyFarmingConfig.OptionEnumTeleport> selectedTeleportFunction;

    public Location(Function<EasyFarmingConfig, EasyFarmingConfig.OptionEnumTeleport> selectedTeleportFunction,
                   EasyFarmingConfig config, String name, Boolean farmLimps) {
        this.config = config;
        this.selectedTeleportFunction = selectedTeleportFunction;
        this.name = name;
        this.farmLimps = farmLimps;
        this.teleportOptions = new ArrayList<>();
    }

    public void addTeleportOption(Teleport teleport) {
        teleportOptions.add(teleport);
    }

    public Teleport getSelectedTeleport() {
        String selectedEnumOption = selectedTeleportFunction.apply(config).name();
        for (Teleport teleport : teleportOptions) {
            if (teleport.getEnumOption().equalsIgnoreCase(selectedEnumOption)) {
                return teleport;
            }
        }
        return teleportOptions.isEmpty() ? null : teleportOptions.get(0);
    }

    // Getters
    public String getName() { return name; }
    public Boolean getFarmLimps() { return farmLimps; }
    public List<Teleport> getTeleportOptions() { return teleportOptions; }
}


package com.easyfarming.core;

import com.easyfarming.ItemRequirement;
import net.runelite.api.coords.WorldPoint;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

public class Teleport {
    public enum Category {
        ITEM,
        PORTAL_NEXUS,
        SPIRIT_TREE,
        JEWELLERY_BOX,
        MOUNTED_XERICS,
        SPELLBOOK
    }
    
    private final String enumOption;
    private final Category category;
    private final String description;
    private final int id;
    private final String rightClickOption;
    private final int interfaceGroupId;
    private final int interfaceChildId;
    private final int regionId;
    private final WorldPoint point;
    private final List<ItemRequirement> itemRequirements;
    
    public Teleport(String enumOption, Category category, String description, int id,
                   String rightClickOption, int interfaceGroupId, int interfaceChildId,
                   int regionId, WorldPoint point, List<ItemRequirement> itemRequirements) {
        this.enumOption = enumOption;
        this.category = category;
        this.description = description;
        this.id = id;
        this.rightClickOption = rightClickOption;
        this.interfaceGroupId = interfaceGroupId;
        this.interfaceChildId = interfaceChildId;
        this.regionId = regionId;
        this.point = point;
        this.itemRequirements = itemRequirements;
    }
    
    public Map<Integer, Integer> getItemRequirements() {
        Map<Integer, Integer> requirements = new HashMap<>();
        for (ItemRequirement itemRequirement : itemRequirements) {
            requirements.put(itemRequirement.getItemId(), itemRequirement.getQuantity());
        }
        return requirements;
    }
    
    // Getters
    public String getEnumOption() { return enumOption; }
    public Category getCategory() { return category; }
    public String getDescription() { return description; }
    public int getId() { return id; }
    public String getRightClickOption() { return rightClickOption; }
    public int getInterfaceGroupId() { return interfaceGroupId; }
    public int getInterfaceChildId() { return interfaceChildId; }
    public int getRegionId() { return regionId; }
    public WorldPoint getPoint() { return point; }
    public List<ItemRequirement> getItemRequirementsList() { return itemRequirements; }
}


package com.easyfarming;

import net.runelite.client.RuneLite;
import net.runelite.client.externalplugins.ExternalPluginManager;

public class EasyFarmingPluginTest
{
	public static void main(String[] args) throws Exception
	{
		// Check if assertions are enabled
		boolean assertionsEnabled = false;
		try {
			assert assertionsEnabled = true;
		} catch (AssertionError e) {
			// Assertions are not enabled
		}
		
		if (!assertionsEnabled) {
			System.err.println("Assertions are not enabled. Please run with -ea flag:");
			System.err.println("java -ea -cp <classpath> com.easyfarming.EasyFarmingPluginTest");
			System.exit(1);
		}
		
		ExternalPluginManager.loadBuiltin(EasyFarmingPlugin.class);
		RuneLite.main(args);
	}
}
package com.easyfarming.locations;

import com.easyfarming.Location;
import com.easyfarming.core.Teleport;
import org.junit.Test;
import static org.junit.Assert.*;

/**
 * Unit tests for LocationFactory.
 */
public class LocationFactoryTest {
    
    /**
     * Tests that every enum value in com.easyfarming.core.Teleport.Category
     * has a corresponding mapping in CATEGORY_MAP.
     * This prevents regressions when new enum constants are added.
     */
    @Test
    public void testAllCategoryEnumValuesHaveMapping() {
        for (Teleport.Category category : Teleport.Category.values()) {
            assertNotNull(
                "Category " + category + " does not have a mapping in CATEGORY_MAP. " +
                "Please add a mapping for this enum value.",
                LocationFactory.CATEGORY_MAP.get(category)
            );
        }
    }
    
    /**
     * Tests that all mappings in CATEGORY_MAP are valid and non-null.
     */
    @Test
    public void testAllMappingsAreValid() {
        for (Teleport.Category category : LocationFactory.CATEGORY_MAP.keySet()) {
            Location.TeleportCategory mappedCategory = LocationFactory.CATEGORY_MAP.get(category);
            assertNotNull(
                "Mapping for " + category + " is null",
                mappedCategory
            );
        }
    }
    
    /**
     * Tests that the number of mappings matches the number of enum values.
     * This ensures no enum values are missing.
     */
    @Test
    public void testMappingCountMatchesEnumCount() {
        int enumCount = Teleport.Category.values().length;
        int mappingCount = LocationFactory.CATEGORY_MAP.size();
        assertEquals(
            "Number of mappings (" + mappingCount + ") does not match number of enum values (" + enumCount + "). " +
            "Some enum values may be missing mappings.",
            enumCount,
            mappingCount
        );
    }
}


