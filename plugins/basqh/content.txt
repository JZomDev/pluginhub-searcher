package com.queuehelper;

import net.runelite.client.RuneLite;
import net.runelite.client.externalplugins.ExternalPluginManager;

public class BASPluginTest
{
	public static void main(String[] args) throws Exception
	{
		ExternalPluginManager.loadBuiltin(BASPlugin.class);
		RuneLite.main(args);
	}
}
	/*
	 * Copyright (c) 2019, TheStonedTurtle <https://github.com/TheStonedTurtle>
	 * All rights reserved.
	 *
	 * Redistribution and use in source and binary forms, with or without
	 * modification, are permitted provided that the following conditions are met:
	 *
	 * 1. Redistributions of source code must retain the above copyright notice, this
	 *    list of conditions and the following disclaimer.
	 * 2. Redistributions in binary form must reproduce the above copyright notice,
	 *    this list of conditions and the following disclaimer in the documentation
	 *    and/or other materials provided with the distribution.
	 *
	 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
	 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
	 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
	 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
	 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
	 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
	 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	 */
package com.queuehelper;

	import java.awt.Color;
	import java.awt.Component;
	import javax.swing.JLabel;
	import javax.swing.JList;
	import javax.swing.ListCellRenderer;
	import javax.swing.border.EmptyBorder;
	import lombok.Setter;
	import net.runelite.client.ui.ColorScheme;
	import net.runelite.client.util.Text;

public class ComboBoxIconListRenderer extends JLabel implements ListCellRenderer
{
	@Setter
	private String defaultText = "Select an option...";

	@Override
	public Component getListCellRendererComponent(JList list, Object o, int index, boolean isSelected, boolean cellHasFocus)
	{
		if (isSelected)
		{
			setBackground(ColorScheme.DARK_GRAY_COLOR);
			setForeground(Color.WHITE);
		}
		else
		{
			setBackground(list.getBackground());
			setForeground(ColorScheme.LIGHT_GRAY_COLOR);
		}

		setBorder(new EmptyBorder(5, 5, 5, 0));

		String text;
		setIcon(null);
		// If using setSelectedItem(null) or setSelectedIndex(-1) show default text until a selection is made
		if (index == -1 && o == null)
		{
			text = defaultText;
		}
		else if (o instanceof Enum)
		{
			text = Text.titleCase((Enum) o);
		}
		else if (o instanceof ComboBoxIconEntry)
		{
			final ComboBoxIconEntry e = (ComboBoxIconEntry) o;
			text = e.getText();
			setIcon(e.getIcon());
		}
		else
		{
			text = o.toString();
		}

		setText(text);

		return this;
	}
}

	/*
	 * Copyright (c) 2019, SkylerPIlot <https://github.com/SkylerPIlot>
	 * All rights reserved.
	 *
	 * Redistribution and use in source and binary forms, with or without
	 * modification, are permitted provided that the following conditions are met:
	 *
	 * 1. Redistributions of source code must retain the above copyright notice, this
	 *    list of conditions and the following disclaimer.
	 * 2. Redistributions in binary form must reproduce the above copyright notice,
	 *    this list of conditions and the following disclaimer in the documentation
	 *    and/or other materials provided with the distribution.
	 *
	 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
	 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
	 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
	 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
	 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
	 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
	 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	 */
package com.queuehelper;


import com.google.common.collect.ImmutableList;
import com.google.inject.Provides;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.awt.image.BufferedImage;
import java.time.Instant;
import java.util.ArrayList;
import javax.swing.SwingUtilities;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.*;
import net.runelite.api.events.*;
import net.runelite.client.chat.ChatColorType;
import net.runelite.client.chat.ChatMessageBuilder;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.chat.QueuedMessage;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.events.ConfigChanged;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.plugins.PluginDescriptor;
import net.runelite.client.ui.ClientToolbar;
import net.runelite.client.ui.NavigationButton;
import net.runelite.client.util.ImageUtil;
import net.runelite.client.util.Text;
import okhttp3.*;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import javax.inject.Inject;
import java.io.IOException;
@Slf4j
@PluginDescriptor(name = "BAS Queue Helper", description = "BAS Customer CC Info", tags = {"minigame"})
public class BASPlugin extends Plugin implements ActionListener
{
    private static final Logger log = LoggerFactory.getLogger(BASPlugin.class);

    private static final String ccName = "BaÂ Services";

    private static final String errorMsg = (new ChatMessageBuilder()).append(ChatColorType.NORMAL).append("BAS QH: ").append(ChatColorType.HIGHLIGHT).append("Please Paste the API key in the plugin settings and restart the plugin").build();

	private BasQueuePanel basQueuePanel;
	private NavigationButton navButton;

	public float fontSize;

	private boolean msgIn = false;

	private static final String KICK_OPTION = "Kick";
	private static final ImmutableList<String> BEFORE_OPTIONS = ImmutableList.of("Add friend", "Remove friend", KICK_OPTION);
	private static final ImmutableList<String> AFTER_OPTIONS = ImmutableList.of("Message");

	private BASHTTPClient httpclient;

    @Inject
    private Client client;

    @Inject
    private ChatMessageManager chatMessageManager;

    @Inject
    private BASConfig config;

	@Inject
	private OkHttpClient BasHttpClient;

	@Inject
	private ClientToolbar clientToolbar;

	public BASPlugin() throws IOException
	{
	}

	@Provides
    BASConfig provideConfig(ConfigManager configManager)
    {
        return configManager.getConfig(BASConfig.class);
    }

	private Queue queue;

    protected void startUp() throws Exception
    {
    	if(!isConfigApiEmpty())
		{
			this.basQueuePanel = new BasQueuePanel(this, this.config);
			this.queue = Queue.getInstance(config.apikey(), basQueuePanel, this, BasHttpClient);
			BufferedImage icon = ImageUtil.loadImageResource(getClass(), "/panellogo.png");
			navButton = NavigationButton.builder()
				.tooltip("BAS queue + options")
				.icon(icon)
				.priority(2)
				.panel(basQueuePanel)
				.build();
			clientToolbar.addNavigation(navButton);
			SwingUtilities.invokeLater(() -> basQueuePanel.populate(queue.getQueue()));
			this.fontSize = config.fontSize();
		}
    }

    protected void shutDown() throws Exception
    {
		clientToolbar.removeNavigation(navButton);
		this.queue = null;
		httpclient = null;

    }


	//checks on startup of plugin and throws an error
    private boolean isConfigApiEmpty(){

        if(config.apikey().equals("Paste your key here") || config.apikey().equals("")){

            BASPlugin.this.chatMessageManager.queue(QueuedMessage.builder()
                    .type(ChatMessageType.CONSOLE)
                    .runeLiteFormattedMessage(errorMsg)
                    .build());
			client.getAccountHash();
            return true;

        }
        return false;

    }


    @Subscribe
    public void onConfigChanged(ConfigChanged event) throws IOException
	{
		this.fontSize = config.fontSize();
    }

	@Subscribe
	public void onFriendsChatMemberJoined(FriendsChatMemberJoined event) throws IOException
	{
		this.queue.ShouldUpdate(true);
	}


    @Subscribe
    public void onFriendsChatMemberLeft(FriendsChatMemberLeft event) throws IOException
	{
		this.queue.ShouldUpdate(true);
    }
	/* fix later
	@Subscribe
	public void onMenuOpened(MenuOpened event)
	{
		if (event.getMenuEntries().length < 2)
		{
			return;
		}

		final MenuEntry entry = event.getMenuEntries()[event.getMenuEntries().length - 2];

		if (entry.getType() != MenuAction.CC_OP_LOW_PRIORITY && entry.getType() != MenuAction.RUNELITE)
		{
			return;
		}

		final int groupId = TO_GROUP(entry.getParam1());
		final int childId = TO_CHILD(entry.getParam1());

		if (groupId != WidgetInfo.CHATBOX.getGroupId())
		{
			return;
		}

		final Widget widget = client.getWidget(groupId, childId);
		final Widget parent = widget.getParent();

		if (WidgetInfo.CHATBOX_MESSAGE_LINES.getId() != parent.getId())
		{
			return;
		}

		final int first = WidgetInfo.CHATBOX_FIRST_MESSAGE.getChildId();

		final int dynamicChildId = (childId - first) * 4;

		final Widget messageContents = parent.getChild(dynamicChildId);
		if (messageContents == null)
		{
			return;
		}

		String playerName = messageContents.getText();
		String player = playerName.replaceAll("\\[.*\\]", "").trim().replace(":", "");

		client.createMenuEntry(1)
			.setOption("Add to Queue Sidepanel")
			.setTarget(entry.getTarget())
			.setType(MenuAction.RUNELITE)
			.onClick(e ->
			{
				this.basQueuePanel.changeCustomerText(Text.removeTags(Text.toJagexName(player)));
			});
	}
	
	@Subscribe
	public void onMenuEntryAdded(MenuEntryAdded event)
	{
		final int componentId = event.getActionParam1();
		int groupId = WidgetInfo.TO_GROUP(componentId);
		String option = event.getOption();

		if (groupId == WidgetInfo.FRIENDS_LIST.getGroupId() || groupId == WidgetInfo.FRIENDS_CHAT.getGroupId()
			|| componentId == WidgetInfo.CLAN_MEMBER_LIST.getId() || componentId == WidgetInfo.CLAN_GUEST_MEMBER_LIST.getId())
		{
			boolean after;

			if (AFTER_OPTIONS.contains(option))
			{
				after = true;
			}
			else if (BEFORE_OPTIONS.contains(option))
			{
				after = false;
			}
			else
			{
				return;
			}

			client.createMenuEntry(after ? -2 : -1)
				.setOption("Add to Queue Sidepanel")
				.setTarget(event.getTarget())
				.setType(MenuAction.RUNELITE)
				.onClick(e ->
				{
					this.basQueuePanel.changeCustomerText(Text.removeTags(Text.toJagexName(event.getTarget())).replaceAll("\\[.*\\]", "").trim().replace(":", ""));
				});
		}
	}
	*/

	//used in sending discord webhook messages
    private boolean isRank()
    {
        FriendsChatManager clanMemberManager = this.client.getFriendsChatManager();
        return this.client.getLocalPlayer().getName() != null && clanMemberManager != null && clanMemberManager.getCount() >= 1 && clanMemberManager.getOwner().equals(ccName);
    }

	//builds a stringbuilder that is then passed to the Implementation of BASHTTPClient to call the backend
    public void updateQueue() throws IOException
	{
		if(!isRank()){
			return;
		}
        FriendsChatManager clanMemberManager = this.client.getFriendsChatManager();
        if (!this.config.autoUpdateQueue() || clanMemberManager == null)
            return;
        StringBuilder csv = new StringBuilder();
        for (FriendsChatMember member : (FriendsChatMember[]) clanMemberManager.getMembers())
        {
            String memberName = member.getName();
            if (csv.toString().equals(""))
            {
                csv = new StringBuilder(memberName + "#" + member.getRank().getValue());
            } else
            {
                csv.append(",").append(memberName).append("#").append(member.getRank().getValue());
            }
        }
        if (csv.toString().equals(""))
            return;
        if (isConfigApiEmpty()){
            return;
        }
        String name = config.queueName();
        if(client.getLocalPlayer().getName() != null){
			name = Text.sanitize(client.getLocalPlayer().getName());
		}

        queue.updateQueuebackend(csv, name);
    }

    @Subscribe
    public void onChatMessage(ChatMessage chatMessage)
    {
		if(!isRank() || chatMessage.getType() != ChatMessageType.FRIENDSCHAT)
		{
			return;
		}

		FriendsChatRank rank = getRank(chatMessage.getName());
		if (isConfigApiEmpty()){
			return;
		}//TODO fix hanging

		try{
			int numMsg = (int) chatMessage.getMessage().charAt(0);
			if((48 <= numMsg && numMsg <= 53) && (chatMessage.getMessage().contains("out") || chatMessage.getMessage().contains("f") || chatMessage.getMessage().contains("a") || chatMessage.getMessage().contains("*") || chatMessage.getMessage().contains("c") || chatMessage.getMessage().contains("d") || chatMessage.getMessage().contains("h") || (chatMessage.getMessage().contains("r") && !chatMessage.getMessage().contains("reg"))))
			{
				if(48 <= ((int) chatMessage.getMessage().charAt(1)) && ((int) chatMessage.getMessage().charAt(1)) <= 57){
					msgIn = false;
				}
				else{
					msgIn = true;
				}
			}
		}
		catch (NumberFormatException ex){
			log.debug("Normal behavior");
		}


		try{
			int numMsg = Integer.parseInt(chatMessage.getMessage());
			if(0 <= numMsg  && numMsg <= 5)
			{
				msgIn = true;
			}
		}
		catch (NumberFormatException ex){
			log.debug("Normal behavior");
		}

		if (chatMessage.getMessage().toLowerCase().contains("t+") || chatMessage.getMessage().toLowerCase().contains("-=-=") || chatMessage.getMessage().toLowerCase().contains("---") || chatMessage.getMessage().toLowerCase().contains("===") || chatMessage.getMessage().toLowerCase().equals("jf") || chatMessage.getMessage().toLowerCase().equals("out")){
			msgIn = true;
		}




		if (((chatMessage.getMessage().contains("+") && chatMessage.getMessage().charAt(0) == '+') || msgIn) && !chatMessage.getMessage().toLowerCase().contains("@"))
		{
			msgIn = false;
			queue.sendChatMsgDiscord(chatMessage);



		}
	//TODO implement webhook + blairm messages + retrieving and using reuls from the AWS server
    }

	private FriendsChatRank getRank(String playerName)
	{
		FriendsChatManager friendsChatManager = this.client.getFriendsChatManager();
		if (friendsChatManager == null)
			return FriendsChatRank.UNRANKED;
		FriendsChatMember friendsChatMember = (FriendsChatMember) friendsChatManager.findByName(playerName);
		return (friendsChatMember != null) ? friendsChatMember.getRank() : FriendsChatRank.UNRANKED;
	}


	@Override
	public void actionPerformed(ActionEvent e)
	{
		//required, didn't feel like using instead used specific functions
	}

	//used in BasQueueRow to run the "Next" button
	public void getNext(){
    	Customer next = queue.getNext();
    	if (next == null) {
    		sendChat("queue empty");
    		return;
		}
		sendChat("Next customer in line: Priority " + next.getPriority() + " " + next.getName() + " " + next.getItem() + " " + next.getNotes());
	}

	public void sendChat(String msg){
		String chatMessage = (new ChatMessageBuilder()).append(ChatColorType.NORMAL).append(msg).build();
    	BASPlugin.this.chatMessageManager.queue(QueuedMessage.builder()
			.type(ChatMessageType.CONSOLE)
			.runeLiteFormattedMessage(chatMessage)
			.build());
	}

	//Adds a customer to the queue and is called by the addcustomer button in the basQueuePanel
	public void addToQueue(String name, String item, String priority){
    	if(name.equals("Customer")){
    		sendChat("Please enter a name");
    		return;
		}
    	if(queue.addToQueue(item, priority, name, config.queueName())){
    		sendChat("Added: " + name + " for " + priority + " " + item);

		}
    	else{
			sendChat("Failed to add: " + name + " for " + priority + " " + item);
		}
		refreshQueue();

	}
	//used in BasQueueRow to run the "Refresh" button
	public void refreshQueue()
	{
		//creates a list of online nonranks to update a autocomplete function
		if(client.getGameState() == GameState.LOGGED_IN)
		{
			FriendsChatManager clanMemberManager = this.client.getFriendsChatManager();
			FriendsChatMember[] memberlist = clanMemberManager.getMembers();
			ArrayList<String> keywords = new ArrayList<>();
			for (FriendsChatMember member : memberlist)
			{
				if (member.getRank() == FriendsChatRank.UNRANKED && !queue.doesCustExist(member.getName()))
				{
					keywords.add(member.getName());
				}
			}
			basQueuePanel.setAutoCompleteKeyWords(keywords);
		}
		try
		{
			queue.refresh();
		}
		catch (IOException ioException)
		{
			ioException.printStackTrace();
		}
		SwingUtilities.invokeLater(() -> basQueuePanel.populate(queue.getQueue()));
	}
	//used in BasQueueRow to run the right click options
	public void markCustomer(int option, Customer cust)
	{
		int UNSUPORRTED = 0;
		if(option != UNSUPORRTED)
		{
			try
			{
				queue.mark(option, cust);
			}
			catch (IOException ioException)
			{
				ioException.printStackTrace();
			}
		}
		this.refreshQueue();
		SwingUtilities.invokeLater(() -> basQueuePanel.populate(queue.getQueue()));
	}
}

	/*
	 * Copyright (c) 2019, SkylerPIlot <https://github.com/SkylerPIlot>
	 * All rights reserved.
	 *
	 * Redistribution and use in source and binary forms, with or without
	 * modification, are permitted provided that the following conditions are met:
	 *
	 * 1. Redistributions of source code must retain the above copyright notice, this
	 *    list of conditions and the following disclaimer.
	 * 2. Redistributions in binary form must reproduce the above copyright notice,
	 *    this list of conditions and the following disclaimer in the documentation
	 *    and/or other materials provided with the distribution.
	 *
	 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
	 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
	 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
	 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
	 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
	 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
	 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	 */
package com.queuehelper;

import java.io.IOException;
import java.util.ArrayList;
import java.util.Date;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Timer;
import java.util.TimerTask;
import javax.swing.SwingUtilities;
import net.runelite.api.FriendsChatRank;
import net.runelite.api.events.ChatMessage;
import net.runelite.client.ui.NavigationButton;
import okhttp3.OkHttpClient;

public class Queue
{
	private static Queue queue;
	private boolean shouldUpdateQueue;
	private BasQueuePanel basPanel;

	private OkHttpClient RLhttpclient;

	Customer tempNext;
	boolean first = true;

	private LinkedHashMap<String, Customer> CurrentQueue;//Queue saved via insertion order

	private List<String[]> OldQueue; //Old csv data used, used in comparison in our implemented HTTPclient interface

	private QueueHelperHTTPClient httpClient;

	Timer timer;

	TimerTask updateQueue;

	BASPlugin plugin;

	private Queue(String apikey, BasQueuePanel BasPanel, BASPlugin Plugin, OkHttpClient rlhttp) throws IOException
	{
		this.plugin = Plugin;
		this.RLhttpclient = rlhttp;
		this.basPanel = BasPanel;
		this.timer = new Timer();
		this.shouldUpdateQueue = false;
		this.CurrentQueue = new LinkedHashMap<String, Customer>();
		this.httpClient = BASHTTPClient.getInstance(apikey, RLhttpclient);
		this.OldQueue = new ArrayList<>();
		createQueue();
		this.updateQueue = new TimerTask()
		{
			@Override
			public void run()
			{
				updateQueueTask(ShouldUpdate());
			}
		};
		timer.scheduleAtFixedRate(this.updateQueue,new Date(),120000);//Schedules a task every 2minutes to both refresh queue object + upload the cc data -> backend
	}

	public static Queue getInstance(String apikey, BasQueuePanel BasPanel, BASPlugin basPlugin,OkHttpClient rlhttp) throws IOException //Singleton queue creation should only need one queue per plugin
	{
		if (Queue.queue == null)
		{
			Queue.queue = new Queue(apikey, BasPanel, basPlugin,rlhttp);
		}
		else
		{
			Queue.queue.setAPikey(apikey);
		}
		return Queue.queue;
	}

	public boolean ShouldUpdate(){
		return this.shouldUpdateQueue;
	}

	public void ShouldUpdate(boolean ShouldUpdateQueue){
		this.shouldUpdateQueue = ShouldUpdateQueue;
	}

	private void setAPikey(String apikey) throws IOException
	{
		this.httpClient = BASHTTPClient.getInstance(apikey,this.RLhttpclient);
	}

	public boolean doesCustExist(String name){
		return CurrentQueue.containsKey(name);
	}

	private void createQueue() throws IOException
	{
		this.OldQueue = httpClient.readCSV(this.OldQueue);
		for (String[] CSVLine : this.OldQueue)
		{
			this.CurrentQueue.put(CSVLine[1], new Customer(CSVLine[1], CSVLine[3], CSVLine[0], CSVLine[2], CSVLine[5], CSVLine[4]));
		}
	}

	public NavigationButton getNav()
	{
		return httpClient.getNavButton(); //return the navigation button from the httpclient implementation allows for alternative nav buttons
	}

	public LinkedHashMap<String, Customer> getQueue()
	{
		return this.CurrentQueue;
	}

	public Customer getNext()
	{

		for (Customer cust : this.CurrentQueue.values())
		{
			if (cust.getStatus().equals("Online") && cust.getPriority().equals("P") && !cust.getNotes().toLowerCase().contains("cooldown"))
			{
				return cust;
			}
				if (cust.getStatus().equals("Online") && cust.getPriority().equals("R") && !cust.getNotes().toLowerCase().contains("cooldown") && first)
			{
				first = false;
				tempNext = cust;//sets the first regular customer to the returned name if no premiums exist
			}


		}
		first = true;
		return tempNext;

	}

	public void refresh() throws IOException
	{
		this.CurrentQueue.clear();
		this.createQueue();
	}

	public void mark(int option, Customer cust) throws IOException
	{
		this.httpClient.markCustomer(option, cust.getName());
	}
	//scheduled task every2minutes Both redraws the panel after retrieving uptodate queue + sends data to the queue given someone has left/joined the cc
	private void updateQueueTask(boolean shouldUpdateQueue)
	{
		if(shouldUpdateQueue){
			try
			{
				this.plugin.updateQueue();
			}
			catch (IOException e)
			{
				e.printStackTrace();
			}
			this.shouldUpdateQueue = false;
		}
		try
		{
			createQueue();
		}
		catch (IOException e)
		{
			e.printStackTrace();
		}

		SwingUtilities.invokeLater(() -> this.basPanel.populate(queue.getQueue()));
	}

	public boolean addToQueue(String itemName, String priority, String custName, String addedBy){
		try
		{
			return httpClient.addCustomer(itemName, priority, custName, addedBy);
		}
		catch (IOException e)
		{
			e.printStackTrace();
		}
		return false;
	}

	public void updateQueuebackend(StringBuilder urlList, String name) throws IOException
	{
		httpClient.updateQueuebackend(urlList,name);
	}

	public void sendChatMsgDiscord(ChatMessage chatMessage){
		try
		{
			httpClient.sendChatMsgDiscord(chatMessage);
		}
		catch (IOException e)
		{
			e.printStackTrace();
		}
	}

}

//Adapted and modified from <https://stackabuse.com/example-adding-autocomplete-to-jtextfield/>

package com.queuehelper;
import java.awt.event.ActionEvent;
import java.util.Collections;
import java.util.List;

import javax.swing.AbstractAction;
import javax.swing.JTextArea;
import javax.swing.SwingUtilities;
import javax.swing.event.DocumentEvent;
import javax.swing.event.DocumentListener;
import javax.swing.text.BadLocationException;

public class AutoComplete implements DocumentListener {

	private static enum Mode {
		INSERT,
		COMPLETION
	};

	private JTextArea textField;
	private List<String> keywords;
	private Mode mode = Mode.INSERT;

	public AutoComplete(JTextArea textField, List<String> keywords) {
		this.textField = textField;
		this.keywords = keywords;
		Collections.sort(keywords);
	}

	public void setKeyWords(List<String> Keywords){
		this.keywords = Keywords;
		Collections.sort(keywords);
	}

	@Override
	public void changedUpdate(DocumentEvent ev) { }

	@Override
	public void removeUpdate(DocumentEvent ev) { }

	@Override
	public void insertUpdate(DocumentEvent ev) {
		if (ev.getLength() != 1)
			return;

		int pos = ev.getOffset();
		String content = null;
		try {
			content = textField.getText(0, pos + 1);
		} catch (BadLocationException e) {
			e.printStackTrace();
		}

		// Find where the word starts
		int w;
		for (w = pos; w >= 0; w--) {
			if (!Character.isLetter(content.charAt(w))) {
				break;
			}
		}

		// Too few chars
		if (pos - w < 2)
			return;

		String prefix = content.substring(w + 1);
		int n = Collections.binarySearch(keywords, prefix);
		if (n < 0 && -n <= keywords.size()) {
			String match = keywords.get(-n - 1);
			if (match.startsWith(prefix)) {
				// A completion is found
				String completion = match.substring(pos - w);
				// We cannot modify Document from within notification,
				// so we submit a task that does the change later
				SwingUtilities.invokeLater(new CompletionTask(completion, pos + 1));
			}
		} else {
			// Nothing found
			mode = Mode.INSERT;
		}
	}

	public class CommitAction extends AbstractAction {
		/**
		 *
		 */
		private static final long serialVersionUID = 5794543109646743416L;

		@Override
		public void actionPerformed(ActionEvent ev) {
			if (mode == Mode.COMPLETION) {
				int pos = textField.getSelectionEnd();
				StringBuffer sb = new StringBuffer(textField.getText());
				sb.insert(pos, "");
				textField.setText(sb.toString());
				try
				{
					textField.setCaretPosition(pos + 1);
				}
				catch(Exception e){
					e.printStackTrace();
				}
				mode = Mode.INSERT;
			} else {
				textField.replaceSelection("\t");
			}
		}
	}

	private class CompletionTask implements Runnable {
		private String completion;
		private int position;

		CompletionTask(String completion, int position) {
			this.completion = completion;
			this.position = position;
		}

		public void run() {
			StringBuffer sb = new StringBuffer(textField.getText());
			sb.insert(position, completion);
			textField.setText(sb.toString());
			textField.setCaretPosition(position + completion.length());
			textField.moveCaretPosition(position);
			mode = Mode.COMPLETION;
		}
	}

}


	/*
	 * Copyright (c) 2019, SkylerPIlot <https://github.com/SkylerPIlot>
	 * All rights reserved.
	 *
	 * Redistribution and use in source and binary forms, with or without
	 * modification, are permitted provided that the following conditions are met:
	 *
	 * 1. Redistributions of source code must retain the above copyright notice, this
	 *    list of conditions and the following disclaimer.
	 * 2. Redistributions in binary form must reproduce the above copyright notice,
	 *    this list of conditions and the following disclaimer in the documentation
	 *    and/or other materials provided with the distribution.
	 *
	 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
	 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
	 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
	 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
	 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
	 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
	 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	 */
package com.queuehelper;

public class Customer
{
	private String CustomerName;

	private String CustomerStatus;

	private String CustomerPriority;

	private String CustomerID;

	private String CustomerNotes;

	private String CustomerItem;

	public Customer(String name, String id, String priority, String CustomerStatus, String CustomerNotes, String CustomerItem){
		this.CustomerName = name;
		this.CustomerID = id;
		this.CustomerPriority = priority;
		this.CustomerStatus = CustomerStatus;
		this.CustomerNotes = CustomerNotes;
		this.CustomerItem = CustomerItem;
	}

	public Customer(String id, String priority, String priority1, String customerNotes, String customerItem)
	{
	}

	public String getName(){
		return this.CustomerName;
	}
	public String getPriority(){
		return this.CustomerPriority;
	}
	public String getID(){
		return this.CustomerID;
	}
	public String getStatus(){
		return this.CustomerStatus;
	}
	public String getItem(){
		return this.CustomerItem;
	}
	public String getNotes() {
		return this.CustomerNotes;
	}

	public void setName(String name){
		this.CustomerName = name;
	}
	public void setPriority(String priority){
		this.CustomerPriority = priority;
	}
	public void setID(String id){
		this.CustomerID = id;
	}
	public void setStatus(String status){
		this.CustomerStatus = status;
	}
	public void setItem(String item){
		this.CustomerItem = item;
	}
	public void setNotes(String notes) {
		this.CustomerNotes = notes;
	}


}

	/*
	 * Copyright (c) 2019, SkylerPIlot <https://github.com/SkylerPIlot>
	 * All rights reserved.
	 *
	 * Redistribution and use in source and binary forms, with or without
	 * modification, are permitted provided that the following conditions are met:
	 *
	 * 1. Redistributions of source code must retain the above copyright notice, this
	 *    list of conditions and the following disclaimer.
	 * 2. Redistributions in binary form must reproduce the above copyright notice,
	 *    this list of conditions and the following disclaimer in the documentation
	 *    and/or other materials provided with the distribution.
	 *
	 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
	 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
	 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
	 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
	 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
	 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
	 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	 */
package com.queuehelper;

import java.io.IOException;
import java.util.List;
import net.runelite.api.FriendsChatRank;
import net.runelite.api.events.ChatMessage;
import net.runelite.client.ui.NavigationButton;

//To create your own implementation, change which implementation is called by the Queue object. To make sure data is
	//"Correct" look how the queue class handles the IO data especially how it creates the list of customers

public interface QueueHelperHTTPClient
{

	static QueueHelperHTTPClient getInstance(String apikey) throws IOException
	{
		return null;
	}


	void setAPikey(String apikey);

	public String getCustomerID(String name) throws IOException;

	public boolean markCustomer(int option, String name) throws IOException;

	public List<String[]> readCSV(List<String[]> csv) throws IOException;//Please pay close attention to how the queue object expects the customer name/id and so forth. A small quirk is it expect cooldown status to be present in the "notes" part of the customer

	public NavigationButton getNavButton();

	public boolean updateQueuebackend(StringBuilder urlList, String name) throws IOException;

	public boolean addCustomer(String itemName,String priority, String custName, String addedBy) throws IOException;

	public boolean sendChatMsgDiscord(ChatMessage chatmessage) throws IOException;

}

/*
 * Copyright (c) 2019, TheStonedTurtle <http://github.com/TheStonedTurtle>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.queuehelper;

import javax.annotation.Nullable;
import javax.swing.Icon;
import lombok.AllArgsConstructor;
import lombok.Getter;
@AllArgsConstructor
@Getter
public class ComboBoxIconEntry
{
	private Icon icon;
	private String text;

}

	/*
	 * Copyright (c) 2019, SkylerPIlot <https://github.com/SkylerPIlot>
	 * All rights reserved.
	 *
	 * Redistribution and use in source and binary forms, with or without
	 * modification, are permitted provided that the following conditions are met:
	 *
	 * 1. Redistributions of source code must retain the above copyright notice, this
	 *    list of conditions and the following disclaimer.
	 * 2. Redistributions in binary form must reproduce the above copyright notice,
	 *    this list of conditions and the following disclaimer in the documentation
	 *    and/or other materials provided with the distribution.
	 *
	 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
	 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
	 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
	 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
	 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
	 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
	 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	 */
package com.queuehelper;

import java.awt.BorderLayout;
import java.awt.Color;
import java.awt.Dimension;
import java.awt.event.ActionListener;
import java.awt.event.FocusEvent;
import java.awt.event.FocusListener;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import javax.swing.ImageIcon;
import javax.swing.JLabel;
import javax.swing.JMenuItem;
import javax.swing.JPanel;
import javax.swing.JPopupMenu;
import javax.swing.JTextArea;
import javax.swing.border.EmptyBorder;
import net.runelite.client.ui.FontManager;
import net.runelite.client.util.ImageUtil;

	class BasQueueRow extends JPanel
{
	private final JMenuItem addMenuOption = new JMenuItem();

	private boolean otherimg;

	private JLabel nameField;
	private JLabel idField;
	private JLabel itemField;
	private JTextArea notesField;

	public Customer customer;

	private Color lastBackground;

	private BASPlugin plugin;

	private JLabel item;


	BasQueueRow(Customer Customer, BASPlugin Plugin)
	{
		this.otherimg = false;
		this.customer = Customer;
		this.plugin = Plugin;

		setLayout(new BorderLayout());
		setBorder(new EmptyBorder(2, 0, 2, 0));
		final JPopupMenu popupMenu = new JPopupMenu();
		popupMenu.setBorder(new EmptyBorder(5, 5, 5, 5));
		String menuText;
		int option;
		String tooltipHover = "";

		if(customer.getStatus().equals("")){
			menuText = "Mark " + customer.getName()+ " online";
			option = 3;
			tooltipHover = "Offline";
		}
		else if(customer.getNotes().toLowerCase().contains("cooldown")){
			menuText = "End Cooldown for: " + customer.getName()+ "(Currently unavailable)";
			option = 0;
			tooltipHover = "Cooldown";
		}
		else if(customer.getStatus().equals("In Progress")){
			if(customer.getItem().equals("Level 5 Roles") && (customer.getNotes().contains("d started") || customer.getNotes().contains("2/3"))){
				menuText = "Mark " + customer.getName()+ " done";
				option = 2;
				tooltipHover = "In Progress last session lvl5s";
			}
			else if(customer.getItem().equals("Level 5 Roles")){
				menuText = "Start Cooldown for: " + customer.getName();
				option = 4;
				tooltipHover = "In Progress lvl5s";
			}
			else{
				menuText = "Mark " + customer.getName()+ " done";
				option = 2;
				tooltipHover = "In Progress";
			}
		}
		else if(customer.getStatus().equals("Done"))
		{
			menuText = "Mark " + customer.getName()+ " in progress";
			option = 1;
			tooltipHover = "Done";
		}
		else{
			menuText = "Mark " + customer.getName()+ " in progress";
			option = 1;
			tooltipHover = "Online";
		}

		addMouseListener(new MouseAdapter()
		{
			@Override
			public void mouseClicked(MouseEvent mouseEvent)
			{
				if (mouseEvent.getClickCount() == 2)
				{
					plugin.markCustomer(option,customer);
				}
			}

			@Override
			public void mousePressed(MouseEvent mouseEvent)
			{
				if (mouseEvent.getClickCount() == 2)
				{
					setBackground(getBackground().brighter());
				}
			}

			@Override
			public void mouseReleased(MouseEvent mouseEvent)
			{
				if (mouseEvent.getClickCount() == 2)
				{
					setBackground(getBackground().darker());
				}
			}

			@Override
			public void mouseEntered(MouseEvent mouseEvent)
			{
				BasQueueRow.this.lastBackground = getBackground();
				setBackground(getBackground().brighter());
			}

			@Override
			public void mouseExited(MouseEvent mouseEvent)
			{
				setBackground(lastBackground);
			}
		});




		addMenuOption.setText(menuText);

		for (ActionListener listener : addMenuOption.getActionListeners())
		{
			addMenuOption.removeActionListener(listener);
		}

		addMenuOption.addActionListener(e ->
		{
			this.plugin.markCustomer(option,customer);
		});
		popupMenu.add(addMenuOption);

		setComponentPopupMenu(popupMenu);

		JPanel leftSide = new JPanel(new BorderLayout());
		JPanel rightSide = new JPanel(new BorderLayout());
		leftSide.setOpaque(false);
		rightSide.setOpaque(false);

		JPanel nameField = buildNameField(Customer);
		nameField.setPreferredSize(new Dimension(70, 10));
		nameField.setOpaque(false);

		JPanel idField = buildidField(Customer);
		idField.setPreferredSize(new Dimension(30, 10));
		idField.setOpaque(false);

		JPanel itemField = builditemField(Customer);
		itemField.setPreferredSize(new Dimension(30, 30));
		itemField.setOpaque(false);

		JPanel notesField = buildNotesField(Customer);
		notesField.setPreferredSize(new Dimension(5, 34));
		notesField.setOpaque(false);

		recolour(Customer);

		leftSide.add(idField, BorderLayout.WEST);
		leftSide.add(nameField, BorderLayout.CENTER);
		rightSide.add(itemField, BorderLayout.WEST);
		rightSide.add(notesField, BorderLayout.CENTER);
		add(leftSide, BorderLayout.WEST);
		add(rightSide, BorderLayout.CENTER);
		this.setToolTipText(tooltipHover);

	}


	public void recolour(Customer customer)
	{
		String status = customer.getStatus();
		Color curColor = Color.black;
		if(this.item == null)
		{
			itemField.setForeground(curColor);
		}
		notesField.setForeground(curColor);
		nameField.setForeground(curColor);
		idField.setForeground(curColor);
		switch(status)
		{
			case "Online":
				if(!customer.getNotes().toLowerCase().contains("cd")&&!customer.getNotes().toLowerCase().contains("cooldown"))
				{
					curColor = Color.green;
					if(this.item == null)
					{
						itemField.setForeground(curColor);
					}
					notesField.setForeground(curColor);
					nameField.setForeground(curColor);
					idField.setForeground(curColor);

					break;
				}
				curColor = new Color(99,151,255);
				this.setBackground(curColor);
				notesField.setBackground(curColor);
				break;

			case "In Progress":
				curColor = new Color(241,235,118);;
				this.setBackground(curColor);
				notesField.setBackground(curColor);
				break;

			case "Done":
				curColor = new Color(129,129,129);;
				this.setBackground(curColor);
				notesField.setBackground(curColor);
				break;

			case "":
				if(!customer.getNotes().toLowerCase().contains("cd")&&!customer.getNotes().toLowerCase().contains("cooldown"))
				{
					curColor = Color.red;
					if(this.item == null)
					{
						itemField.setForeground(curColor);
					}
					notesField.setForeground(curColor);
					nameField.setForeground(curColor);
					idField.setForeground(curColor);
					break;
				}
				curColor = new Color(99,151,255);
				this.setBackground(curColor);
				break;

			default:
				curColor = Color.gray;
				this.setBackground(curColor);

				break;
		}
	}

	/**
	 * Builds the players list field (containing the amount of players logged in that world).
	 */
	private JPanel builditemField(Customer cust)
	{
		String item = cust.getItem();
		JPanel column = new JPanel(new BorderLayout());
		switch(item){

			case "Torso":
				column = new JPanel(new BorderLayout());
				itemField = new JLabel(new ImageIcon(ImageUtil.loadImageResource(getClass(), "/torso.png")));
				column.add(itemField);
				return column;

			case "Queen Kill - Diary":
				column = new JPanel(new BorderLayout());
				itemField = new JLabel(new ImageIcon(ImageUtil.loadImageResource(getClass(), "/queen_kill.png")));
				column.add(itemField);
				return column;

			case "Level 5 Roles":
				column = new JPanel(new BorderLayout());
				itemField = new JLabel(new ImageIcon(ImageUtil.loadImageResource(getClass(), "/Level5s.png")));
				column.add(itemField);
				return column;

			case "Hat":
				column = new JPanel(new BorderLayout());
				itemField = new JLabel(new ImageIcon(ImageUtil.loadImageResource(getClass(), "/hat4.png")));
				column.add(itemField);
				return column;


			default:
				if(item.toLowerCase().contains("gamble")){
					column = new JPanel(new BorderLayout());
					itemField = new JLabel(new ImageIcon(ImageUtil.loadImageResource(getClass(), "/Other.png")));
					column.add(itemField);
					return column;

				}
				if(item.toLowerCase().contains("points") || item.toLowerCase().contains("pts")){
					column = new JPanel(new BorderLayout());
					itemField = new JLabel(new ImageIcon(ImageUtil.loadImageResource(getClass(), "/points.png")));
					otherimg = true;
					column.add(itemField);
					return column;

				}
				else
				{
					column = new JPanel(new BorderLayout());
					itemField = new JLabel(new ImageIcon(ImageUtil.loadImageResource(getClass(), "/Other.png")));
					column.add(itemField);
					otherimg = true;
					return column;
				}

		}
	}



	private JPanel buildidField(Customer cust)
	{
		JPanel column = new JPanel(new BorderLayout());
		column.setBorder(new EmptyBorder(0, 0, 0, 5));

		idField = new JLabel(cust.getID());
		idField.setFont(FontManager.getRunescapeSmallFont().deriveFont(8));

		idField.setToolTipText(cust.getID());
		// Pass up events - https://stackoverflow.com/a/14932443
		idField.addMouseListener(new MouseAdapter()
		{
			@Override
			public void mouseClicked(MouseEvent e)
			{
				dispatchEvent(e);
			}

			@Override
			public void mousePressed(MouseEvent e)
			{
				dispatchEvent(e);
			}

			@Override
			public void mouseReleased(MouseEvent e)
			{
				dispatchEvent(e);
			}

			@Override
			public void mouseEntered(MouseEvent e)
			{
				dispatchEvent(e);
			}

			@Override
			public void mouseExited(MouseEvent e)
			{
				dispatchEvent(e);
			}
		});

		column.add(idField, BorderLayout.EAST);


		return column;
	}

	/**
	 * Builds the activity list field (containing that world's activity/theme).
	 */
	private JPanel buildNotesField(Customer cust)
	{
		JPanel column = new JPanel(new BorderLayout());
		column.setBorder(new EmptyBorder(0, 5, 0, 5));


		String activity = cust.getNotes();
		if(this.otherimg){
			activity = cust.getItem() + " " + cust.getNotes();
		}

		notesField = new JTextArea(2, 10);
		notesField.setText(activity);


		notesField.setLineWrap(true);
		notesField.setWrapStyleWord(true);
		notesField.setEditable(true);
		notesField.setOpaque(false);
		notesField.setFont(FontManager.getRunescapeSmallFont().deriveFont(this.plugin.fontSize));


		column.add(notesField, BorderLayout.WEST);

		return column;
	}


	private JPanel buildNameField(Customer cust)
	{
		JPanel column = new JPanel(new BorderLayout());
		column.setBorder(new EmptyBorder(0, 5, 0, 5));

		nameField = new JLabel(cust.getName());
		nameField.setFont(FontManager.getRunescapeSmallFont());

		column.add(nameField, BorderLayout.CENTER);

		return column;
	}






}

	/*
	 * Copyright (c) 2019, SkylerPIlot <https://github.com/SkylerPIlot>
	 * All rights reserved.
	 *
	 * Redistribution and use in source and binary forms, with or without
	 * modification, are permitted provided that the following conditions are met:
	 *
	 * 1. Redistributions of source code must retain the above copyright notice, this
	 *    list of conditions and the following disclaimer.
	 * 2. Redistributions in binary form must reproduce the above copyright notice,
	 *    this list of conditions and the following disclaimer in the documentation
	 *    and/or other materials provided with the distribution.
	 *
	 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
	 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
	 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
	 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
	 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
	 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
	 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	 */
package com.queuehelper;

import java.awt.image.BufferedImage;
import java.io.IOException;
import java.util.List;
import net.runelite.api.FriendsChatRank;
import net.runelite.api.events.ChatMessage;
import net.runelite.client.ui.NavigationButton;
import net.runelite.client.util.ImageUtil;
import net.runelite.client.util.Text;
import okhttp3.Call;
import okhttp3.Callback;
import okhttp3.HttpUrl;
import okhttp3.OkHttpClient;
import okhttp3.Request;
import okhttp3.Response;
import java.net.URLEncoder;

/**
This Class handles all IO communication to the backend
 */

public class BASHTTPClient implements QueueHelperHTTPClient
{
	private static BASHTTPClient client;

	private String apikey;

	private static final String HOST_PATH = "vrqgs27251.execute-api.eu-west-2.amazonaws.com";

	private HttpUrl apiBase;

	private OkHttpClient Basclient;

	private String CustIDQuery;
	private String RetrieveCSVQuery;
	private String UPDATE_OPTION_GNC;
	private String UPDATE_OPTION_ATQ;
	private String UPDATE_OPTION_PRI;
	private String UPDATE_OPTION_NAM;
	private String UPDATE_OPTION_FORMI;
	private String UPDATE_OPTION_QN;
	private String csvList;
	private String UPDATE_OPTION_QHN;
	private String UPDATE_OPTION_C;
	private String UPDATE_OPTION_M;
	private String UPDATE_OPTION_R;
	private String OptionQuery;
	private String CustomerNameQuery;
	private String basephp;



	private BASHTTPClient(String apikey, OkHttpClient basclient) throws IOException
	{
		this.Basclient = basclient;
		this.apikey = apikey;
		this.apiBase = new HttpUrl.Builder().scheme("https").host(BASHTTPClient.HOST_PATH).addPathSegment("Bas_Queuehelper").build();
		String[] pathsArray = this.getFilePaths();
		this.updateFilePaths(pathsArray);
	}

	public static BASHTTPClient getInstance(String apikey,OkHttpClient basclient) throws IOException
	{
		if(BASHTTPClient.client == null){
			BASHTTPClient.client = new BASHTTPClient(apikey, basclient);
		}
		else{
			BASHTTPClient.client.setAPikey(apikey);
		}
		return BASHTTPClient.client;
	}

	public void setAPikey(String apikey)
	{
		this.apikey = apikey;
	}


	public void clearFilePaths(){
		RetrieveCSVQuery = "";

		UPDATE_OPTION_GNC = "";

		UPDATE_OPTION_ATQ = "";

		UPDATE_OPTION_PRI = "";

		UPDATE_OPTION_NAM = "";

		UPDATE_OPTION_FORMI = "";

		UPDATE_OPTION_QN = "";

		csvList = "";

		UPDATE_OPTION_QHN = "";

		UPDATE_OPTION_C = "";

		UPDATE_OPTION_M = "";

		UPDATE_OPTION_R = "";

		OptionQuery = "";

		CustomerNameQuery = "";

		basephp = "";

		CustIDQuery = "";
	}

	private void updateFilePaths(String[] paths){
		this.RetrieveCSVQuery = paths[0];
		this.UPDATE_OPTION_GNC = paths[1];
		this.UPDATE_OPTION_ATQ = paths[2];
		this.UPDATE_OPTION_PRI = paths[3];
		this.UPDATE_OPTION_NAM = paths[4];
		this.UPDATE_OPTION_FORMI = paths[5];
		this.UPDATE_OPTION_QN = paths[6];
		this.csvList = paths[7];
		this.UPDATE_OPTION_QHN = paths[8];
		this.UPDATE_OPTION_C = paths[9];
		this.UPDATE_OPTION_M = paths[10];
		this.UPDATE_OPTION_R = paths[11];
		this.OptionQuery = paths[12];
		this.CustomerNameQuery = paths[13];
		this.basephp = paths[14];
		this.CustIDQuery = paths[15];
	}

	private String[] getFilePaths() throws IOException {

		OkHttpClient client = Basclient;
		HttpUrl url = apiBase.newBuilder()
			.addPathSegment("grabfilestrings")
			.build();

		Request request = new Request.Builder()
			.header("User-Agent", "RuneLite")
			.url(url)
			.header("Content-Type", "application/json")
			.header("x-api-key", this.apikey)
			.build();

		try (Response response = client.newCall(request).execute())
		{
			return response.body().string().split("\"")[3].split(",");
		}
	}
	@Override
	public String getCustomerID(String name) throws IOException
	{
		OkHttpClient client = Basclient;
		HttpUrl url = apiBase.newBuilder()
			.addPathSegment("bas")
			.addPathSegment(basephp)
			.addQueryParameter(CustIDQuery, URLEncoder.encode(name.replace('Â ', ' '),"UTF-8"))
			.build();

		Request request = new Request.Builder()
			.header("User-Agent", "RuneLite")
			.url(url)
			.header("Content-Type", "application/json")
			.header("x-api-key", this.apikey)
			.build();

		try (Response response = client.newCall(request).execute())
		{
			return response.body().string();
		}

	}
	@Override
	public boolean markCustomer(int option, String name) throws IOException
	{
		OkHttpClient client = Basclient;
		HttpUrl url = apiBase.newBuilder()
			.addPathSegment("bas")
			.addPathSegment(basephp)
			.addQueryParameter(OptionQuery, option + "")
			.addQueryParameter(CustomerNameQuery, URLEncoder.encode(Text.removeTags(Text.sanitize(name)).replace('Â ', ' '),"UTF-8"))
			.build();

		Request request = new Request.Builder()
			.header("User-Agent", "RuneLite")
			.url(url)
			.header("Content-Type", "application/json")
			.header("x-api-key", this.apikey)
			.build();

		try (Response response = client.newCall(request).execute())
		{
			return response.isSuccessful();
		}

	}
	@Override
	public List<String[]> readCSV(List<String[]> csv) throws IOException{

		int PRIORITY = 2;
		int RNAMES = 4;
		int PNAME = 3;
		int STATUS = 0;
		int ID = 1;
		int ITEM = 5;
		int NOTES = 7;
		OkHttpClient client = Basclient;
		HttpUrl url = apiBase.newBuilder()
			.addPathSegment("bas")
			.addPathSegment(basephp)
			.addQueryParameter(RetrieveCSVQuery, "1")
			.build();

		Request request = new Request.Builder()
			.header("User-Agent", "RuneLite")
			.url(url)
			.header("Content-Type", "application/json")
			.header("x-api-key", this.apikey)
			.build();

		try (Response response = client.newCall(request).execute())
		{
			csv.clear();

			String[] CSVLines = response.body().string().split("\n");
			for(String line : CSVLines ){
				String[] LineItems = line.split(",");
				if(LineItems[0].equals("Current time:") || LineItems[0].equals("Last edited:") || LineItems[0].equals("Status")){
					continue;
				}
				else{
					csv.add(new String[] {LineItems[PRIORITY], LineItems[PRIORITY].equals("R") ? LineItems[RNAMES] : LineItems[PNAME], LineItems[STATUS], LineItems[ID], LineItems[ITEM], LineItems[NOTES]});
				}
			}
			response.close();
			return csv;
		}

	}

	@Override
	public NavigationButton getNavButton()
	{
		final BufferedImage icon = ImageUtil.loadImageResource(getClass(), "/panellogo.png");

		NavigationButton navButton = NavigationButton.builder()
			.tooltip("BAS queue + options")
			.icon(icon)
			.priority(2)
			//.panel(BasQueuePanel)
			.build();
		return navButton;
	}


	public boolean updateQueuebackend(StringBuilder urlList, String name) throws IOException
	{
		OkHttpClient client = Basclient;
		HttpUrl url = apiBase.newBuilder()
			.addPathSegment("bas")
			.addPathSegment(basephp)
			.addQueryParameter(csvList, urlList.toString())
			.addQueryParameter(UPDATE_OPTION_QHN, URLEncoder.encode(Text.sanitize(name), "UTF-8"))
			.build();

		Request request = new Request.Builder()
			.header("User-Agent", "RuneLite")
			.url(url)
			.header("Content-Type", "application/json")
			.header("x-api-key", this.apikey)
			.build();

		try (Response response = client.newCall(request).execute())
		{
			return response.isSuccessful();
		}
	}

	@Override
	public boolean addCustomer(String itemName, String priority, String custName, String addedBy) throws IOException
	{
		OkHttpClient client = Basclient;
		HttpUrl url = apiBase.newBuilder()
			.addPathSegment("bas")
			.addPathSegment(basephp)
			.addQueryParameter(UPDATE_OPTION_ATQ, "1")
			.addQueryParameter(UPDATE_OPTION_PRI, priority)
			.addQueryParameter(UPDATE_OPTION_NAM, URLEncoder.encode(custName.replace('Â ', ' '), "UTF-8"))
			.addQueryParameter(UPDATE_OPTION_FORMI, itemName)
			.addQueryParameter(UPDATE_OPTION_QN, addedBy)
			.build();

		Request request = new Request.Builder()
			.header("User-Agent", "RuneLite")
			.url(url)
			.header("Content-Type", "application/json")
			.header("x-api-key", this.apikey)
			.build();

		try (Response response = client.newCall(request).execute())
		{
			return response.isSuccessful();
		}
	}

	@Override
	public boolean sendChatMsgDiscord(ChatMessage chatmessage) throws IOException
	{
		String unhashedMsg = chatmessage.getName() + chatmessage.getMessage() + (((int)(chatmessage.getTimestamp()/10)*10));

		int hasedMsg = unhashedMsg.hashCode();
		OkHttpClient client = Basclient;
		HttpUrl url = apiBase.newBuilder()
			.addPathSegment("disc")
			.build();

		Request request = new Request.Builder()
			.header("User-Agent", "RuneLite")
			.url(url)
			.header("Content-Type", "application/json")
			.header("x-api-key", this.apikey)
			.header("username",chatmessage.getName().replace('Â ', ' '))
			.header("msg",chatmessage.getMessage())
			.header("hash",String.valueOf(hasedMsg))
			.build();

		client.newCall(request).enqueue(new Callback()
		{
			@Override
			public void onFailure(Call call, IOException e)
			{

			}

			@Override
			public void onResponse(Call call, Response response) throws IOException { response.close(); }
		});
		return true;
	}

}

	/*
	 * Copyright (c) 2019, SkylerPIlot <https://github.com/SkylerPIlot>
	 * All rights reserved.
	 *
	 * Redistribution and use in source and binary forms, with or without
	 * modification, are permitted provided that the following conditions are met:
	 *
	 * 1. Redistributions of source code must retain the above copyright notice, this
	 *    list of conditions and the following disclaimer.
	 * 2. Redistributions in binary form must reproduce the above copyright notice,
	 *    this list of conditions and the following disclaimer in the documentation
	 *    and/or other materials provided with the distribution.
	 *
	 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
	 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
	 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
	 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
	 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
	 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
	 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	 */
package com.queuehelper;

import java.awt.BorderLayout;
import java.awt.Color;
import java.awt.GridLayout;
import java.awt.event.FocusEvent;
import java.awt.event.FocusListener;
import java.awt.event.ItemEvent;
import java.awt.image.BufferedImage;
import java.util.ArrayList;
import java.util.LinkedHashMap;
import javax.swing.ImageIcon;
import javax.swing.JButton;
import javax.swing.JComboBox;
import javax.swing.JPanel;
import javax.swing.JTextArea;
import javax.swing.KeyStroke;
import javax.swing.border.EmptyBorder;
import net.runelite.client.util.LinkBrowser;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.DynamicGridLayout;
import net.runelite.client.ui.PluginPanel;
import net.runelite.client.ui.components.materialtabs.MaterialTab;
import net.runelite.client.ui.components.materialtabs.MaterialTabGroup;
import net.runelite.client.util.ImageUtil;


public class BasQueuePanel extends PluginPanel
{
	private BASPlugin plugin;

	private final JPanel onlistContainer;

	private final JPanel offlistContainer;

	private ArrayList<BasQueueRow> rows;

	private BASConfig config;

	private JButton nextButton;

	private JButton custButton;

	private JTextArea namearea;

	private JPanel nextRefreshArea;

	private JPanel custPrioArea;

	private String currItem;

	private String currPriority;

	private JPanel nameAreaPanel;

	private JButton viewOnlineQueue;

	AutoComplete autoComplete;

	private final JPanel display = new JPanel();

	private final MaterialTabGroup tabGroup = new MaterialTabGroup(display);

	ArrayList<String> keywords = new ArrayList<String>();

	BasQueuePanel(BASPlugin plugin, BASConfig Config)
	{
		this.plugin = plugin;
		this.config = Config;

		this.rows = new ArrayList<>();
		this.onlistContainer = new JPanel();
		this.offlistContainer = new JPanel();

		this.setBorder(null);
		this.setLayout(new DynamicGridLayout(0, 1));

		this.onlistContainer.setLayout(new GridLayout(0, 1));
		this.offlistContainer.setLayout(new GridLayout(0, 1));

		setLayout(new BorderLayout());
		setBackground(ColorScheme.DARK_GRAY_COLOR);

		MaterialTab offersTab = new MaterialTab("Online", tabGroup, onlistContainer);
		MaterialTab searchTab = new MaterialTab("Offline", tabGroup, offlistContainer);

		tabGroup.setBorder(new EmptyBorder(5, 0, 0, 0));
		tabGroup.addTab(offersTab);
		tabGroup.addTab(searchTab);
		tabGroup.select(offersTab); // selects the default selected tab

		add(tabGroup, BorderLayout.NORTH);
		add(display, BorderLayout.CENTER);

		nextRefreshArea = refreshNextButton();
		this.nameAreaPanel = customerNamePrioPanel();
		this.custPrioArea = customerAddPanel();

		viewOnlineQueue = new JButton("View Online Queue");
		viewOnlineQueue.setBackground(ColorScheme.DARKER_GRAY_COLOR);
		viewOnlineQueue.setBorder(new EmptyBorder(5, 7, 5, 7));
		viewOnlineQueue.addActionListener(e -> LinkBrowser.browse("https://baservices.site/ranksqueue/"));



	}

	public void setAutoCompleteKeyWords(ArrayList<String> Keywords){
		autoComplete.setKeyWords(Keywords);
		this.keywords = Keywords;
	}

	void populate(LinkedHashMap<String, Customer> queue)
	{
		this.rows.clear();
		this.offlistContainer.removeAll();
		this.onlistContainer.removeAll();
		for (Customer cust : queue.values())
		{
			this.rows.add(new BasQueueRow(cust, plugin));

		}
		for (BasQueueRow row : rows)
		{
			if (row.customer.getStatus().equals("Online") || row.customer.getStatus().equals("In Progress"))
			{
				onlistContainer.add(row);
			}
			else
			{
				offlistContainer.add(row);
			}
		}

		onlistContainer.add(nextRefreshArea);
		onlistContainer.add(nameAreaPanel);
		onlistContainer.add(custPrioArea);
		onlistContainer.add(viewOnlineQueue);
	}


	private JPanel addRefreshButton(String label)
	{
		final JPanel container = new JPanel();
		container.setLayout(new BorderLayout());

		JButton resetButton = new JButton(label);

		resetButton.setBackground(ColorScheme.DARK_GRAY_COLOR);
		resetButton.setBorder(new EmptyBorder(5, 0, 5, 5));
		resetButton.setToolTipText("refreshes the online Queue and redraws it");
		resetButton.setEnabled(true);

		resetButton.addActionListener(e -> {
			this.plugin.refreshQueue();
		});

		container.add(resetButton, BorderLayout.CENTER);

		return container;
	}

	private JPanel addNextButton(String label)
	{

		final JPanel container = new JPanel();
		container.setLayout(new BorderLayout());

		nextButton = new JButton(label);

		nextButton.setBackground(ColorScheme.DARKER_GRAY_COLOR);
		nextButton.setBorder(new EmptyBorder(5, 5, 5, 7));

		nextButton.addActionListener(e -> this.plugin.getNext());

		container.add(nextButton, BorderLayout.CENTER);

		//add(container, BorderLayout.SOUTH);
		return container;
	}

	private JComboBox<ComboBoxIconEntry> createCombobox()
	{
		final JComboBox<ComboBoxIconEntry> dropdown = new JComboBox<>();
		dropdown.setFocusable(false); // To prevent an annoying "focus paint" effect
		dropdown.setForeground(Color.WHITE);
		dropdown.setMaximumRowCount(5);
		final ComboBoxIconListRenderer renderer = new ComboBoxIconListRenderer();
		renderer.setDefaultText("Select an Item...");
		dropdown.setRenderer(renderer);
		final BufferedImage torsoimg = ImageUtil.loadImageResource(getClass(), "/torso.png");
		final ComboBoxIconEntry torsoentry = new ComboBoxIconEntry(new ImageIcon(torsoimg), "Torso");
		final BufferedImage lvl5img = ImageUtil.loadImageResource(getClass(), "/Level5s.png");
		final ComboBoxIconEntry lvl5entry = new ComboBoxIconEntry(new ImageIcon(lvl5img), "Level 5 Roles");
		final BufferedImage pointsimg = ImageUtil.loadImageResource(getClass(), "/points.png");
		final ComboBoxIconEntry pointsentry = new ComboBoxIconEntry(new ImageIcon(pointsimg), "One Round - Points");
		final BufferedImage qkimg = ImageUtil.loadImageResource(getClass(), "/queen_kill.png");
		final ComboBoxIconEntry qkentry = new ComboBoxIconEntry(new ImageIcon(qkimg), "Queen Kill - Diary");
		final BufferedImage hatimg = ImageUtil.loadImageResource(getClass(), "/hat4.png");
		final ComboBoxIconEntry hatentry = new ComboBoxIconEntry(new ImageIcon(hatimg), "Hat");


		dropdown.addItem(torsoentry);
		dropdown.addItem(lvl5entry);
		dropdown.addItem(pointsentry);
		dropdown.addItem(qkentry);
		dropdown.addItem(hatentry);
		dropdown.addItemListener(e ->
		{
			if (e.getStateChange() == ItemEvent.SELECTED)
			{
				final ComboBoxIconEntry source = (ComboBoxIconEntry) e.getItem();
				currItem = source.getText();
			}
		});
		dropdown.setSelectedIndex(-1);
		return dropdown;
	}
	private JTextArea customerNamePanel(){
		namearea = new JTextArea(1, 10);
		namearea.setFocusTraversalKeysEnabled(false);
		namearea.setText("Customer");
		namearea.setLineWrap(true);
		namearea.setWrapStyleWord(true);
		namearea.setEditable(true);
		namearea.setOpaque(true);
		namearea.addFocusListener(custAreaFocus());
		namearea.setBorder(new EmptyBorder(20, 20, 2, 20));

		String COMMIT_ACTION = "commit";
		keywords.add("Skyler Miner");

		autoComplete = new AutoComplete(namearea, keywords);
		namearea.getDocument().addDocumentListener(autoComplete);
		namearea.getInputMap().put(KeyStroke.getKeyStroke("TAB"), COMMIT_ACTION);
		namearea.getActionMap().put(COMMIT_ACTION, autoComplete.new CommitAction());

		return namearea;

	}

	private JPanel addCustomerButoon(String label)
	{
		final JPanel container = new JPanel();
		container.setLayout(new BorderLayout());
		custButton = new JButton(label);
		custButton.setBackground(ColorScheme.DARKER_GRAY_COLOR);
		custButton.setBorder(new EmptyBorder(5, 7, 5, 7));
		custButton.addActionListener(e -> addCustomerAction());


		container.add(custButton, BorderLayout.CENTER);
		return container;
	}
	public void changeCustomerText(String name){
		namearea = (JTextArea) nameAreaPanel.getComponent(0);
		this.namearea.setText(name);
	}

	private void addCustomerAction(){
		namearea = (JTextArea) nameAreaPanel.getComponent(0);
		try
		{
			this.plugin.addToQueue(this.namearea.getText(), currItem, currPriority);
			this.namearea.setText("Customer");
		}
		catch (Exception e){
			e.printStackTrace();
		}

	}
	//Deletes the default text and replaces it if you didn't type anything
	private FocusListener custAreaFocus(){
		FocusListener focus = new FocusListener()
		{
			@Override
			public void focusGained(FocusEvent e)
			{
			if(namearea.getText().equals("Customer"))
				{
				namearea = (JTextArea) nameAreaPanel.getComponent(0);
				namearea.setText("");
				}
			}

			@Override
			public void focusLost(FocusEvent e)
			{
			if(namearea.getText().equals("")){
				namearea = (JTextArea) nameAreaPanel.getComponent(0);
				namearea.setText("Customer");
			}
			}
		};
		return focus;

	}


 	private JPanel customerAddPanel(){
		JComboBox<ComboBoxIconEntry> dropdown = createCombobox();
		JPanel custButton = addCustomerButoon("Add Customer");
		JPanel addPanel = new JPanel();
		addPanel.setLayout(new BorderLayout());
		addPanel.setBorder(new EmptyBorder(3, 0, 2, 5));
		addPanel.add(dropdown, BorderLayout.CENTER);
		addPanel.add(custButton, BorderLayout.EAST);
		return addPanel;
	}

	private JPanel customerNamePrioPanel(){
		JComboBox<ComboBoxIconEntry> dropdown = createRegPremSelect();

		JPanel addPanel = new JPanel();
		addPanel.setLayout(new BorderLayout());
		customerNamePanel(); // instantiates this.namearea
		addPanel.setBorder(new EmptyBorder(3, 0, 2, 5));
		addPanel.add(namearea, BorderLayout.CENTER);
		addPanel.add(dropdown, BorderLayout.EAST);
		return addPanel;

	}

	private JPanel refreshNextButton(){
		JPanel combined = new JPanel();
		JPanel next = addNextButton("Next");
		JPanel refresh = addRefreshButton("Refresh");
		combined.setLayout(new BorderLayout());
		combined.setBorder(new EmptyBorder(3, 0, 2, 5));
		combined.add(next, BorderLayout.CENTER);
		combined.add(refresh, BorderLayout.EAST);
		return combined;
	}
	private JComboBox<ComboBoxIconEntry> createRegPremSelect()
	{
		final JComboBox<ComboBoxIconEntry> dropdown = new JComboBox<>();
		dropdown.setFocusable(false); // To prevent an annoying "focus paint" effect
		dropdown.setForeground(Color.WHITE);
		dropdown.setMaximumRowCount(5);
		final ComboBoxIconListRenderer renderer = new ComboBoxIconListRenderer();
		renderer.setDefaultText("Priority");
		dropdown.setRenderer(renderer);
		final BufferedImage regimg = ImageUtil.loadImageResource(getClass(), "/torso.png");
		final ComboBoxIconEntry regentry = new ComboBoxIconEntry(new ImageIcon(regimg), "Regular");
		final BufferedImage premimg = ImageUtil.loadImageResource(getClass(), "/torso.png");
		final ComboBoxIconEntry prementry = new ComboBoxIconEntry(new ImageIcon(premimg), "Premium");
		dropdown.addItem(regentry);
		dropdown.addItem(prementry);
		dropdown.addItemListener(e ->
		{
			if (e.getStateChange() == ItemEvent.SELECTED)
			{
				final ComboBoxIconEntry source = (ComboBoxIconEntry) e.getItem();
				currPriority = source.getText();
			}
		});
		dropdown.setSelectedIndex(-1);
		return dropdown;
	}

}

	/*
	 * Copyright (c) 2019, SkylerPIlot <https://github.com/SkylerPIlot>
	 * All rights reserved.
	 *
	 * Redistribution and use in source and binary forms, with or without
	 * modification, are permitted provided that the following conditions are met:
	 *
	 * 1. Redistributions of source code must retain the above copyright notice, this
	 *    list of conditions and the following disclaimer.
	 * 2. Redistributions in binary form must reproduce the above copyright notice,
	 *    this list of conditions and the following disclaimer in the documentation
	 *    and/or other materials provided with the distribution.
	 *
	 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
	 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
	 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
	 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
	 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
	 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
	 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	 */
package com.queuehelper;

import net.runelite.client.config.Config;
import net.runelite.client.config.ConfigGroup;
import net.runelite.client.config.ConfigItem;

@ConfigGroup("BAS")
public interface BASConfig extends Config {
  @ConfigItem(keyName = "autoUpdateQueue", name = "Queue Auto Updater", description = "Automatically updates the BAS Queue", position = 1)
  default boolean autoUpdateQueue() {
    return true;
  }
  
  @ConfigItem(keyName = "queueName", name = "Queue Sheet Name", description = "The name that you would like the queue to recognise you as. If not set it will use the currently logged in username.", position = 2)
  default String queueName() {
    return "";
  }

	@ConfigItem(
		keyName = "fontsize",
		name = "Note Font Size",
		description = "changes the font size in the notes",
		position = 3
	)
	default int fontSize()
	{
		return 16;
	}


	@ConfigItem(
		keyName = "APIKEY",
		name = "KEY",
		description = "Please place your api key here",
		position = 4
	)
	default String apikey()
	{
		return "Paste your key here";
	}

}

