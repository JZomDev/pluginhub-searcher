//Adapted and modified from <https://stackabuse.com/example-adding-autocomplete-to-jtextfield/>

package com.queuehelper;
import java.awt.event.ActionEvent;
import java.util.Collections;
import java.util.List;

import javax.swing.AbstractAction;
import javax.swing.JTextArea;
import javax.swing.SwingUtilities;
import javax.swing.event.DocumentEvent;
import javax.swing.event.DocumentListener;
import javax.swing.text.BadLocationException;

public class AutoComplete implements DocumentListener {

	private static enum Mode {
		INSERT,
		COMPLETION
	};

	private JTextArea textField;
	private List<String> keywords;
	private Mode mode = Mode.INSERT;

	public AutoComplete(JTextArea textField, List<String> keywords) {
		this.textField = textField;
		this.keywords = keywords;
		Collections.sort(keywords);
	}

	public void setKeyWords(List<String> Keywords){
		this.keywords = Keywords;
		Collections.sort(keywords);
	}

	@Override
	public void changedUpdate(DocumentEvent ev) { }

	@Override
	public void removeUpdate(DocumentEvent ev) { }

	@Override
	public void insertUpdate(DocumentEvent ev) {
		if (ev.getLength() != 1)
			return;

		int pos = ev.getOffset();
		String content = null;
		try {
			content = textField.getText(0, pos + 1);
		} catch (BadLocationException e) {
			e.printStackTrace();
		}

		// Find where the word starts
		int w;
		for (w = pos; w >= 0; w--) {
			if (!Character.isLetter(content.charAt(w))) {
				break;
			}
		}

		// Too few chars
		if (pos - w < 2)
			return;

		String prefix = content.substring(w + 1);
		int n = Collections.binarySearch(keywords, prefix);
		if (n < 0 && -n <= keywords.size()) {
			String match = keywords.get(-n - 1);
			if (match.startsWith(prefix)) {
				// A completion is found
				String completion = match.substring(pos - w);
				// We cannot modify Document from within notification,
				// so we submit a task that does the change later
				SwingUtilities.invokeLater(new CompletionTask(completion, pos + 1));
			}
		} else {
			// Nothing found
			mode = Mode.INSERT;
		}
	}

	public class CommitAction extends AbstractAction {
		/**
		 *
		 */
		private static final long serialVersionUID = 5794543109646743416L;

		@Override
		public void actionPerformed(ActionEvent ev) {
			if (mode == Mode.COMPLETION) {
				int pos = textField.getSelectionEnd();
				StringBuffer sb = new StringBuffer(textField.getText());
				sb.insert(pos, "");
				textField.setText(sb.toString());
				try
				{
					textField.setCaretPosition(pos + 1);
				}
				catch(Exception e){
					e.printStackTrace();
				}
				mode = Mode.INSERT;
			} else {
				textField.replaceSelection("\t");
			}
		}
	}

	private class CompletionTask implements Runnable {
		private String completion;
		private int position;

		CompletionTask(String completion, int position) {
			this.completion = completion;
			this.position = position;
		}

		public void run() {
			StringBuffer sb = new StringBuffer(textField.getText());
			sb.insert(position, completion);
			textField.setText(sb.toString());
			textField.setCaretPosition(position + completion.length());
			textField.moveCaretPosition(position);
			mode = Mode.COMPLETION;
		}
	}

}


	/*
	 * Copyright (c) 2019, SkylerPIlot <https://github.com/SkylerPIlot>
	 * All rights reserved.
	 *
	 * Redistribution and use in source and binary forms, with or without
	 * modification, are permitted provided that the following conditions are met:
	 *
	 * 1. Redistributions of source code must retain the above copyright notice, this
	 *    list of conditions and the following disclaimer.
	 * 2. Redistributions in binary form must reproduce the above copyright notice,
	 *    this list of conditions and the following disclaimer in the documentation
	 *    and/or other materials provided with the distribution.
	 *
	 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
	 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
	 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
	 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
	 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
	 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
	 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	 */
package com.queuehelper;

import net.runelite.client.config.Config;
import net.runelite.client.config.ConfigGroup;
import net.runelite.client.config.ConfigItem;

@ConfigGroup("BAS")
public interface BASConfig extends Config {
  @ConfigItem(keyName = "autoUpdateQueue", name = "Queue Auto Updater", description = "Automatically updates the BAS Queue", position = 1)
  default boolean autoUpdateQueue() {
    return true;
  }
  
  @ConfigItem(keyName = "queueName", name = "Queue Sheet Name", description = "The name that you would like the queue to recognise you as. If not set it will use the currently logged in username.", position = 2)
  default String queueName() {
    return "";
  }

	@ConfigItem(
		keyName = "fontsize",
		name = "Note Font Size",
		description = "changes the font size in the notes",
		position = 3
	)
	default int fontSize()
	{
		return 16;
	}


	@ConfigItem(
		keyName = "APIKEY",
		name = "KEY",
		description = "Please place your api key here, Specifying any value here will attempt to authenticate and communicate with a external server that Runelite does not control.",
		position = 4
	)
	default String apikey()
	{
		return "Paste your key here";
	}

}

	/*
	 * Copyright (c) 2019, SkylerPIlot <https://github.com/SkylerPIlot>
	 * All rights reserved.
	 *
	 * Redistribution and use in source and binary forms, with or without
	 * modification, are permitted provided that the following conditions are met:
	 *
	 * 1. Redistributions of source code must retain the above copyright notice, this
	 *    list of conditions and the following disclaimer.
	 * 2. Redistributions in binary form must reproduce the above copyright notice,
	 *    this list of conditions and the following disclaimer in the documentation
	 *    and/or other materials provided with the distribution.
	 *
	 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
	 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
	 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
	 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
	 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
	 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
	 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	 */
	package com.queuehelper;
	import okhttp3.FormBody;
	import java.time.ZoneOffset;
	import java.time.ZonedDateTime;
	import java.time.format.DateTimeFormatter;
	import java.util.List;
	import java.util.ArrayList;
	import java.io.IOException;
	import net.runelite.api.events.ChatMessage;
	import okhttp3.Call;
	import okhttp3.Callback;
	import okhttp3.HttpUrl;
	import okhttp3.OkHttpClient;
	import okhttp3.Request;
	import okhttp3.Response;

	/**
	 This Class handles all IO communication to the backend
	 */

	public class BASHTTPClient implements QueueHelperHTTPClient
	{
		private static BASHTTPClient client;

		private String apikey;

		private static final String HOST_PATH = "vrqgs27251.execute-api.eu-west-2.amazonaws.com";

		private HttpUrl apiBase;

		private OkHttpClient Basclient;

		private List<String[]> csvData;
		private String RetrieveCSVQuery;




		private BASHTTPClient(String apikey, OkHttpClient basclient) throws IOException
		{
			this.Basclient = basclient;
			this.apikey = apikey;
			this.apiBase = new HttpUrl.Builder().scheme("https").host(BASHTTPClient.HOST_PATH).addPathSegment("Bas_Queuehelper").build();
			this.getFilePaths();
			//String[] pathsArray = this.getFilePaths();
			//this.updateFilePaths(pathsArray);
		}

		public static BASHTTPClient getInstance(String apikey,OkHttpClient basclient) throws IOException
		{
			if(BASHTTPClient.client == null){
				BASHTTPClient.client = new BASHTTPClient(apikey, basclient);
			}
			else{
				BASHTTPClient.client.setAPikey(apikey);
			}
			return BASHTTPClient.client;
		}

		public void setAPikey(String apikey)
		{
			this.apikey = apikey;
		}


		public void clearFilePaths(){
			RetrieveCSVQuery = "";

			csvData = null;

		}

		public void updateFilePaths(String[] paths){
			this.RetrieveCSVQuery = paths[0];

		}

		private void getFilePaths() throws IOException {

			OkHttpClient client = Basclient;
			HttpUrl url = apiBase.newBuilder()
					.addPathSegment("grabfilestrings")
					.build();

			Request request = new Request.Builder()
					.header("User-Agent", "RuneLite")
					.url(url)
					.header("Content-Type", "application/json")
					.header("x-api-key", this.apikey)
					.build();

			Response test;
			client.newCall(request).enqueue(new Callback() {
				@Override
				public void onFailure(Call call, IOException e) {

				}

				@Override
				public void onResponse(Call call, Response response) throws IOException {
					updateFilePaths(response.body().string().split("\"")[3].split(","));
				}
			});

		}

		@Override
		public boolean markCustomer(int option, String name,String rankName) throws IOException
		{
			OkHttpClient client = Basclient;
			HttpUrl url = apiBase.newBuilder()
					.addPathSegment("queue")
					.build();

			/*
				3 == online
				0 == cooldown
				2 == done
				1 == in progress
			}*/


			Request request = new Request.Builder()
					.header("User-Agent", "RuneLite")
					.url(url)
					.header("Content-Type", "application/json")
					.header("x-api-key", this.apikey)
					.header("username",name)
					.header("action", String.valueOf(option))
					.header("rankname", rankName)
					.build();

			client.newCall(request).enqueue(new Callback()
			{
				@Override
				public void onFailure(Call call, IOException e)
				{

				}

				@Override
				public void onResponse(Call call, Response response) throws IOException { String eat =(response.body().string()); }
			});
			return true;

		}

		public boolean updateQueuebackend(StringBuilder urlList, String name) throws IOException {
			OkHttpClient client = Basclient;
			HttpUrl url = apiBase.newBuilder()
					.addPathSegment("queuespecific")
					.build();

			Request request = new Request.Builder()
					.header("User-Agent", "RuneLite")
					.url(url)
					.header("Content-Type", "application/json")
					.header("x-api-key", this.apikey)
					.header("returncsv", "0")//treat 0/1 as true/false respectively
					.header("rankname", name)
					.header("csv", urlList.toString().replace("\u00A0", " "))
					.build();

			client.newCall(request).enqueue(new Callback()
			{
				@Override
				public void onFailure(Call call, IOException e)
				{

				}

				@Override
				public void onResponse(Call call, Response response) throws IOException { String eat = (response.body().string()+"\n"); }
			});
			return true;
		}

		@Override
		public List<String[]> readCSV(List<String[]> csv) throws IOException {
			OkHttpClient client = Basclient;
			HttpUrl url = apiBase.newBuilder()
					.addPathSegment("queuespecific")
					.build();

			Request request = new Request.Builder()
					.header("User-Agent", "RuneLite")
					.url(url)
					.header("Content-Type", "application/json")
					.header("x-api-key", this.apikey)
					.header("returncsv", "1")//treat 0/1 as true/false respectively
					.header("rankname", "get")
					.build();

			client.newCall(request).enqueue(new Callback()
			{
				@Override
				public void onFailure(Call call, IOException e)
				{

				}

				@Override
				public void onResponse(Call call, Response response) throws IOException {
					String data = response.body().string().split("body\": \"")[1].replace("}","");
					 csvData = new ArrayList<>();
					String[] lines = data.split("\\\\r\\\\n");

					for (String line : lines) {
						String[] values = line.split(",");
						csvData.add(values);
					}
					response.close();

				}
			});
			return csvData;//by way of how the enqueue/callback works this is always 1 refresh behind.... not the end of the world but annoying
		}


		@Override
		public boolean addCustomer(String itemName, String priority, String custName, String addedBy) throws IOException
		{
			OkHttpClient client = Basclient;

			// Build the URL for your Google Form submission.
			HttpUrl url = new HttpUrl.Builder()
					.scheme("https")
					.host("docs.google.com")
					.addPathSegment("forms")
					.addPathSegment("d")
					.addPathSegment("e")
					// Replace with your actual Google Form ID from the URL:
					// https://docs.google.com/forms/d/e/1FAIpQLSc06_IrTbleP0uZBiOt1yMcI5kvOrvkzgaVLLmEDRLqJSSoVg/viewform
					.addPathSegment("1FAIpQLSc06_IrTbleP0uZBiOt1yMcI5kvOrvkzgaVLLmEDRLqJSSoVg")
					.addPathSegment("formResponse")
					.build();

			// Build the form-encoded request body with the proper entry IDs.
			okhttp3.RequestBody formBody = new FormBody.Builder()
					.add("entry.1481518570", priority)
					.add("entry.1794472797", custName)
					.add("entry.1391010025", itemName)
					.add("entry.1284888696", addedBy)
					.add("entry.1260617128", RetrieveCSVQuery)
					.build();

			// Create a POST request to the Google Form.
			Request request = new Request.Builder()
					.url(url)
					.post(formBody)
					.header("User-Agent", "RuneLite")
					.build();

			client.newCall(request).enqueue(new Callback()
			{
				@Override
				public void onFailure(Call call, IOException e)
				{

				}

				@Override
				public void onResponse(Call call, Response response) throws IOException { String eat =(response.body().string()); }
			});
			return true;
		}

		@Override
		public boolean sendChatMsgDiscord(ChatMessage chatmessage) throws IOException
		{
			String unhashedMsg = chatmessage.getName() + chatmessage.getMessage() + (((int)(chatmessage.getTimestamp()/10)*10));

			int hasedMsg = unhashedMsg.hashCode();
			OkHttpClient client = Basclient;
			HttpUrl url = apiBase.newBuilder()
					.addPathSegment("disc")
					.build();

			Request request = new Request.Builder()
					.header("User-Agent", "RuneLite")
					.url(url)
					.header("Content-Type", "application/json")
					.header("x-api-key", this.apikey)
					.header("username",chatmessage.getName().replace(' ', ' '))
					.header("msg",chatmessage.getMessage())
					.header("hash",String.valueOf(hasedMsg))
					.build();

			client.newCall(request).enqueue(new Callback()
			{
				@Override
				public void onFailure(Call call, IOException e)
				{

				}

				@Override
				public void onResponse(Call call, Response response) throws IOException { response.close(); }
			});
			return true;
		}

		@Override
		public boolean sendRoundTimeServer(String main, String collector, String healer, String leech, String defender, int time, int premiumType, String item
				,int attpts, int defpts, int healpts, int collpts, int eggsCollected, int hpHealed, int wrongAtts, String leechrole) {
			ZonedDateTime currentTimeUTC = ZonedDateTime.now(ZoneOffset.UTC);
			int seconds = currentTimeUTC.getSecond();
			int roundedSeconds = (seconds / 30) * 30; // Round to the nearest 10 seconds for use in the hash/prevent multiple same as discord msgs
			ZonedDateTime roundedTime = currentTimeUTC.withSecond(roundedSeconds).withNano(0);
			String roundedTimestampUTC = roundedTime.format(DateTimeFormatter.ISO_DATE_TIME);

			String unhashedMsg = main + collector + healer + leech + defender + roundedTimestampUTC;

			int hasedMsg = unhashedMsg.hashCode();

			OkHttpClient client = Basclient;
			HttpUrl url = apiBase.newBuilder()
					.addPathSegment("recordRound")
					.build();


			Request request = new Request.Builder()
					.header("User-Agent", "RuneLite")
					.url(url)
					.header("Content-Type", "application/json")
					.header("x-api-key", this.apikey)
					.header("main",main)
					.header("collector",collector)
					.header("healer",healer)
					.header("leech",leech)
					.header("defender",defender)
					.header("time", String.valueOf(time))
					.header("premiumtype",String.valueOf(premiumType))
					.header("item", item)
					.header("hash",String.valueOf(hasedMsg))
					.header("attpts", String.valueOf(attpts))
					.header("defpts", String.valueOf(defpts))
					.header("healpts", String.valueOf(healpts))
					.header("collpts", String.valueOf(collpts))
					.header("eggscollected", String.valueOf(eggsCollected))
					.header("hphealed", String.valueOf(hpHealed))
					.header("wrongatts", String.valueOf(wrongAtts))

					.header("leechrole", String.valueOf(leechrole))
					.build();

			client.newCall(request).enqueue(new Callback()
			{
				@Override
				public void onFailure(Call call, IOException e)
				{

				}

				@Override
				public void onResponse(Call call, Response response) throws IOException { response.close(); }
			});
			return true;
		}





	}

	/*
	 * Copyright (c) 2019, SkylerPIlot <https://github.com/SkylerPIlot>
	 * All rights reserved.
	 *
	 * Redistribution and use in source and binary forms, with or without
	 * modification, are permitted provided that the following conditions are met:
	 *
	 * 1. Redistributions of source code must retain the above copyright notice, this
	 *    list of conditions and the following disclaimer.
	 * 2. Redistributions in binary form must reproduce the above copyright notice,
	 *    this list of conditions and the following disclaimer in the documentation
	 *    and/or other materials provided with the distribution.
	 *
	 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
	 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
	 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
	 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
	 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
	 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
	 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	 */
package com.queuehelper;



import com.google.inject.Provides;

import java.awt.*;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.awt.image.BufferedImage;

import java.util.ArrayList;
import javax.swing.SwingUtilities;


import lombok.extern.slf4j.Slf4j;
import net.runelite.api.*;
import net.runelite.api.events.*;
import net.runelite.api.widgets.InterfaceID;
import net.runelite.api.widgets.Widget;

import net.runelite.client.chat.ChatColorType;
import net.runelite.client.chat.ChatMessageBuilder;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.chat.QueuedMessage;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.events.ConfigChanged;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.plugins.PluginDescriptor;
import net.runelite.client.ui.ClientToolbar;
import net.runelite.client.ui.NavigationButton;
import net.runelite.client.util.ImageUtil;
import net.runelite.client.util.Text;
import okhttp3.*;
import javax.inject.Inject;
import java.io.IOException;

@Slf4j
@PluginDescriptor(name = "BAS Queue Helper", description = "BAS Customer CC Info", tags = {"minigame"})
public class BASPlugin extends Plugin implements ActionListener {

	private static final String ccName = "Ba Services";

	private static final String errorMsg = (new ChatMessageBuilder()).append(ChatColorType.NORMAL).append("BAS QH: ").append(ChatColorType.HIGHLIGHT).append("Please Paste the API key in the plugin settings and restart the plugin").build();

	private BasQueuePanel basQueuePanel;
	private NavigationButton navButton;

	public float fontSize;

	private boolean msgIn = false;

	@Inject
	private Client client;

	@Inject
	private ChatMessageManager chatMessageManager;

	@Inject
	private BASConfig config;

	@Inject
	private OkHttpClient BasHttpClient;

	@Inject
	private ClientToolbar clientToolbar;

	public BASPlugin() throws IOException {
	}

	@Provides
	BASConfig provideConfig(ConfigManager configManager) {
		return configManager.getConfig(BASConfig.class);
	}

	private Queue queue;

	protected void startUp() throws IOException {
		if (!isConfigApiEmpty()) {
			this.basQueuePanel = new BasQueuePanel(this, this.config);
			this.queue = Queue.getInstance(config.apikey(), basQueuePanel, this, BasHttpClient);
			BufferedImage icon = ImageUtil.loadImageResource(getClass(), "/panellogo.png");
			navButton = NavigationButton.builder()
					.tooltip("BAS queue + options")
					.icon(icon)
					.priority(2)
					.panel(basQueuePanel)
					.build();
			clientToolbar.addNavigation(navButton);
			SwingUtilities.invokeLater(() -> basQueuePanel.populate(queue.getQueue()));
			this.fontSize = config.fontSize();

		}
	}

	private String currentWave = START_WAVE;

	protected void shutDown() throws Exception {
		clientToolbar.removeNavigation(navButton);
		this.queue = null;
		gameTime = null;
		currentWave = START_WAVE;
	}


	//checks on startup of plugin and throws an error
	private boolean isConfigApiEmpty() {

		if (config.apikey().equals("Paste your key here") || config.apikey().equals("")) {

			BASPlugin.this.chatMessageManager.queue(QueuedMessage.builder()
					.type(ChatMessageType.CONSOLE)
					.runeLiteFormattedMessage(errorMsg)
					.build());
			client.getAccountHash();
			return true;

		}
		return false;

	}


	@Subscribe
	public void onConfigChanged(ConfigChanged event) throws IOException {
		this.fontSize = config.fontSize();
	}

	@Subscribe
	public void onFriendsChatMemberJoined(FriendsChatMemberJoined event) throws IOException {
		this.queue.ShouldUpdate(true);
	}


	@Subscribe
	public void onFriendsChatMemberLeft(FriendsChatMemberLeft event) throws IOException {
		this.queue.ShouldUpdate(true);
	}

	//used in sending discord webhook messages
	private boolean isRank() {
		try {
			FriendsChatManager clanMemberManager = this.client.getFriendsChatManager();
			return this.client.getLocalPlayer().getName() != null && clanMemberManager != null && clanMemberManager.getCount() >= 1 && clanMemberManager.getOwner().equals(ccName);
		} catch (Exception e) {
			return false;
		}

	}

	//builds a stringbuilder that is then passed to the Implementation of BASHTTPClient to call the backend
	public void updateQueue() throws IOException {
		if (!isRank()) {
			return;
		}
		FriendsChatManager clanMemberManager = this.client.getFriendsChatManager();
		if (!this.config.autoUpdateQueue() || clanMemberManager == null)
			return;
		StringBuilder csv = new StringBuilder();
		for (FriendsChatMember member : (FriendsChatMember[]) clanMemberManager.getMembers()) {
			String memberName = member.getName();
			if (csv.toString().equals("")) {
				csv = new StringBuilder(memberName);
			} else {
				csv.append(",").append(memberName);
			}
		}
		if (csv.toString().equals(""))
			return;
		if (isConfigApiEmpty()) {
			return;
		}
		String name = config.queueName();
		if (client.getLocalPlayer().getName() != null) {
			name = Text.sanitize(client.getLocalPlayer().getName());
		}

		queue.updateQueuebackend(csv, name);
	}

	@Subscribe
	public void onChatMessage(ChatMessage chatMessage) {

		if (chatMessage.getType() == ChatMessageType.GAMEMESSAGE
				&& chatMessage.getMessage().startsWith("---- Wave:"))
		{
			String[] message = chatMessage.getMessage().split(" ");
			currentWave = message[BA_WAVE_NUM_INDEX];

			if (currentWave.equals(START_WAVE))
			{
				gameTime = new GameTimer();
				pointsHealer = pointsDefender = pointsCollector = pointsAttacker = totalEggsCollected = totalIncorrectAttacks = totalHealthReplenished = 0;
			}

		}


		if (!isRank() || chatMessage.getType() != ChatMessageType.FRIENDSCHAT) {
			return;
		}

		FriendsChatRank rank = getRank(chatMessage.getName());
		if (isConfigApiEmpty()) {
			return;
		}//TODO fix hanging

		try {
			int numMsg = (int) chatMessage.getMessage().charAt(0);
			if ((48 <= numMsg && numMsg <= 53) && (chatMessage.getMessage().contains("out") || chatMessage.getMessage().contains("f") || chatMessage.getMessage().contains("a") || chatMessage.getMessage().contains("*") || chatMessage.getMessage().contains("c") || chatMessage.getMessage().contains("d") || chatMessage.getMessage().contains("h") || (chatMessage.getMessage().contains("r") && !chatMessage.getMessage().contains("reg")))) {
				if (48 <= ((int) chatMessage.getMessage().charAt(1)) && ((int) chatMessage.getMessage().charAt(1)) <= 57) {
					msgIn = false;
				} else {
					msgIn = true;
				}
			}
		} catch (NumberFormatException ex) {
			log.debug("Normal behavior");
		}


		try {
			int numMsg = Integer.parseInt(chatMessage.getMessage());
			if (0 <= numMsg && numMsg <= 5) {
				msgIn = true;
			}
		} catch (NumberFormatException ex) {
			log.debug("Normal behavior");
		}

		if (chatMessage.getMessage().toLowerCase().contains("t+") || chatMessage.getMessage().toLowerCase().contains("-=-=") || chatMessage.getMessage().toLowerCase().contains("---") || chatMessage.getMessage().toLowerCase().contains("===") || chatMessage.getMessage().toLowerCase().equals("jf") || chatMessage.getMessage().toLowerCase().equals("out")) {
			msgIn = true;
		}


		if (((chatMessage.getMessage().contains("+") && chatMessage.getMessage().charAt(0) == '+') || msgIn) && !chatMessage.getMessage().toLowerCase().contains("@")) {
			msgIn = false;
			queue.sendChatMsgDiscord(chatMessage);


		}
		//TODO implement webhook + blairm messages + retrieving and using reuls from the AWS server
	}

	private FriendsChatRank getRank(String playerName) {
		FriendsChatManager friendsChatManager = this.client.getFriendsChatManager();
		if (friendsChatManager == null)
			return FriendsChatRank.UNRANKED;
		FriendsChatMember friendsChatMember = (FriendsChatMember) friendsChatManager.findByName(playerName);
		return (friendsChatMember != null) ? friendsChatMember.getRank() : FriendsChatRank.UNRANKED;
	}


	@Override
	public void actionPerformed(ActionEvent e) {
		//required, didn't feel like using instead used specific functions
	}

	//used in BasQueueRow to run the "Next" button
	public void getNext() {
		Customer next = queue.getNext();
		if (next == null) {
			sendChat("queue empty");
			return;
		}
		sendChat("Next customer in line: Priority " + next.getPriority() + " " + next.getName() + " " + next.getItem() + " " + next.getNotes());
	}

	public void sendChat(String msg) {
		String chatMessage = (new ChatMessageBuilder()).append(ChatColorType.NORMAL).append(msg).build();
		BASPlugin.this.chatMessageManager.queue(QueuedMessage.builder()
				.type(ChatMessageType.CONSOLE)
				.runeLiteFormattedMessage(chatMessage)
				.build());
	}

	//Adds a customer to the queue and is called by the addcustomer button in the basQueuePanel
	public void addToQueue(String name, String item, String priority) {
		if (name.equals("Customer")) {
			sendChat("Please enter a name");
			return;
		}
		if (queue.addToQueue(item, priority, name, config.queueName())) {
			sendChat("Added: " + name + " for " + priority + " " + item);

		} else {
			sendChat("Failed to add: " + name + " for " + priority + " " + item);
		}
		refreshQueue();

	}

	//used in BasQueueRow to run the "Refresh" button
	public void refreshQueue() {
		//creates a list of online nonranks to update a autocomplete function
		if (client.getGameState() == GameState.LOGGED_IN) {
			FriendsChatManager clanMemberManager = this.client.getFriendsChatManager();
			FriendsChatMember[] memberlist = clanMemberManager.getMembers();
			ArrayList<String> keywords = new ArrayList<>();
			for (FriendsChatMember member : memberlist) {
				if (member.getRank() == FriendsChatRank.UNRANKED && !queue.doesCustExist(member.getName())) {
					keywords.add(member.getName());
				}
			}
			basQueuePanel.setAutoCompleteKeyWords(keywords);
		}
		try {
			queue.refresh();
		} catch (IOException ioException) {
			ioException.printStackTrace();
		}
		SwingUtilities.invokeLater(() -> basQueuePanel.populate(queue.getQueue()));
	}

	//used in BasQueueRow to run the right click options
	public void markCustomer(int option, Customer cust)
	{

		int UNSUPORRTED = 0;
		if(option != UNSUPORRTED)
		{
			try
			{
				queue.mark(option, cust, config.queueName());
			}
			catch (IOException ioException)
			{
				ioException.printStackTrace();
			}
		}
		this.refreshQueue();
		SwingUtilities.invokeLater(() -> basQueuePanel.populate(queue.getQueue()));
	}


	//this is where the fun stuff happens!

	private GameTimer gameTime;
	private static final int BA_WAVE_NUM_INDEX = 2;
	private static final String START_WAVE = "1";
	private static final String ENDGAME_REWARD_NEEDLE_TEXT = "<br>5";
	private String round_role;
	private Boolean scanning = false;
	private int round_roleID;
	private Boolean leech;
	//defines all of my specific widgets and icon names could I do it better yes, but like it works
	private Integer BaRoleWidget = 256;
	private Integer BaScrollWidget = 159;
	private Integer leaderID = 8;
	private Integer player1ID = 9;
	private Integer player2ID = 10;
	private Integer player3ID = 11;
	private Integer player4ID = 12;
	private Integer leadericonID = 18;
	private Integer player1iconID = 19;
	private Integer player2iconID = 20;
	private Integer player3iconID = 21;
	private Integer player4iconID = 22;
	private Integer attackerIcon = 20561;
	private Integer defenderIcon = 20566;
	private Integer collectorIcon = 20563;
	private Integer healerIcon = 20569;

	Widget leader;
	Widget leaderIcon;
	Widget player1;
	Widget player1Icon;
	Widget player2;
	Widget player2Icon;
	Widget player3;
	Widget player3Icon;
	Widget player4;
	Widget player4Icon;



	private int pointsHealer, pointsDefender , pointsCollector, pointsAttacker, totalEggsCollected, totalIncorrectAttacks, totalHealthReplenished;
	final int[] childIDsOfPointsWidgets = new int[]{33, 32, 25, 26, 24, 28, 31, 27, 29, 30, 21, 22, 19};

	@Subscribe
	public void onWidgetLoaded(WidgetLoaded event)
	{
		switch (event.getGroupId())
		{
			case InterfaceID.BA_TEAM: {
				scanning = true;
				leech = false;
				break;
			}
			case 159: {//this is to set scanning true when scroll is used on someone
				scanning = true;
				break;
			}
			case 158: {//this is to set scanning true when scroll is used on someone
				scanning = true;
				break;
			}
			case InterfaceID.BA_REWARD:
			{

				Widget rewardWidget = client.getWidget(InterfaceID.BA_REWARD,57);

				Widget pointsWidget = client.getWidget(InterfaceID.BA_REWARD, 14); //RUNNERS_PASSED

				// Wave 10 ended
				if (rewardWidget != null && rewardWidget.getText().contains(ENDGAME_REWARD_NEEDLE_TEXT) && gameTime != null)
				{
					ChatMessageBuilder message = new ChatMessageBuilder()
							.append("Attacker: ")
							.append(Color.red, pointsAttacker + 80 + "")
							.append(" |  Healer: ")
							.append(Color.GREEN, pointsHealer + 80 + "")
							.append(" | Defender: ")
							.append(Color.blue, pointsDefender + 80 + "")
							.append(" | Collector: ")
							.append(Color.yellow, pointsCollector + 80 + "")
							.append(System.getProperty("line.separator"))
							.append(totalEggsCollected + " eggs collected, " + totalHealthReplenished + "HP vialed and " + totalIncorrectAttacks + " wrong attacks.");

					int finalPointsAttacker = pointsAttacker + 80;
					int finalPointsHealer = pointsHealer + 80;
					int finalPointsDefender = pointsDefender + 80;
					int finalPointsCollector = pointsCollector + 80;
          


					//TODO please don't forget to change this back to actually check instead of just true (leech && isRank())
					if(leech && isRank()) {

						if (queue.doesCustExist(player3.getText())) {
							this.queue.sendRoundMsd(leader.getText(), player1.getText(), player2.getText(), player3.getText(),
									player4.getText(), gameTime.getPBTime(), queue.getCustomer(player3.getText()).getPriority(), queue.getCustomer(player3.getText()).getItem()
							,finalPointsAttacker, finalPointsDefender, finalPointsHealer, finalPointsCollector, totalEggsCollected, totalHealthReplenished, totalIncorrectAttacks,leechRole);

						} else {
							this.queue.sendRoundMsd(leader.getText(), player1.getText(), player2.getText(), player3.getText(),
									player4.getText(), gameTime.getPBTime(), "Unknown", "Unknown"
									,finalPointsAttacker, finalPointsDefender, finalPointsHealer, finalPointsCollector, totalEggsCollected, totalHealthReplenished, totalIncorrectAttacks,leechRole);

						}
						gameTime = null;
						leech = false;
					}




				}

				// Wave 1-9 ended
				else if (pointsWidget != null && client.getVarbitValue(Varbits.IN_GAME_BA) == 0)
				{
					int wavePoints_Attacker, wavePoints_Defender, wavePoints_Healer, wavePoints_Collector, waveEggsCollected, waveHPReplenished, waveFailedAttacks;

					wavePoints_Attacker = wavePoints_Defender = wavePoints_Healer = wavePoints_Collector = Integer.parseInt(client.getWidget(InterfaceID.BA_REWARD, childIDsOfPointsWidgets[0]).getText()); //set base pts to all roles
					waveEggsCollected = waveHPReplenished = waveFailedAttacks = 0;

					// Gather post-wave info from points widget
					for (int i = 0; i < childIDsOfPointsWidgets.length; i++)
					{
						int value = Integer.parseInt(client.getWidget(InterfaceID.BA_REWARD, childIDsOfPointsWidgets[i]).getText());

						switch (i)
						{
							case 1:
							case 2:
							case 3:
								wavePoints_Attacker += value;
								break;
							case 4:
							case 5:
								wavePoints_Defender += value;
								break;
							case 6:
								wavePoints_Collector += value;
								break;
							case 7:
							case 8:
							case 9:
								wavePoints_Healer += value;
								break;
							case 10:
								waveEggsCollected = value;
								totalEggsCollected += value;

								break;
							case 11:
								waveFailedAttacks = value;
								totalIncorrectAttacks += value;
								break;
							case 12:
								waveHPReplenished = value;
								totalHealthReplenished += value;
								break;
						}
					}

					pointsCollector += wavePoints_Collector;
					pointsHealer += wavePoints_Healer;
					pointsDefender += wavePoints_Defender;
					pointsAttacker += wavePoints_Attacker;
				}

				break;

			}

		}
	}

	String leechRole;
	@Subscribe
	public void onGameTick(GameTick event)
	{
		if(		client.getLocalPlayer() == null ||
				client.getWidget(BaRoleWidget, leaderID)==null||
				client.getWidget(BaRoleWidget, player1ID)==null||
				client.getWidget(BaRoleWidget, player2ID)==null||
				client.getWidget(BaRoleWidget, player3ID)==null||
				client.getWidget(BaRoleWidget, player4ID)==null){
			return;
		}

		if(scanning) {
			final String player;
			player = client.getLocalPlayer().getName();
			leader = client.getWidget(BaRoleWidget, leaderID);
			leaderIcon = client.getWidget(BaRoleWidget, leadericonID);
			player1 = client.getWidget(BaRoleWidget, player1ID);
			player1Icon = client.getWidget(BaRoleWidget, player1iconID);
			player2 = client.getWidget(BaRoleWidget, player2ID);
			player2Icon = client.getWidget(BaRoleWidget, player2iconID);
			player3 = client.getWidget(BaRoleWidget, player3ID);
			player3Icon = client.getWidget(BaRoleWidget, player3iconID);
			player4 = client.getWidget(BaRoleWidget, player4ID);
			player4Icon = client.getWidget(BaRoleWidget, player4iconID);
			log.debug("Scanning Team");

			if ((player4Icon.getModelId() != leaderIcon.getModelId()) &&  (player4Icon.getModelId() != 65535) && (leaderIcon.getModelId() != 65535)){//this number is the blank icon
				log.debug("Scanning Complete");
				log.debug("Leader is {}", leader.getText());
				log.debug("Player1 is {}", player1.getText());
				log.debug("Player2 is {}", player2.getText());
				log.debug("Player3 is {}", player3.getText());
				log.debug("Player4 is {}", player4.getText());
				leechRole = IDfinder(client.getWidget(BaRoleWidget,player3iconID).getModelId());
				scanning = false;


                    for (int i = 8; i < 13; i++)
				{
					String player_in_list = (client.getWidget(BaRoleWidget, i).getText());
					if (player.compareTo(player_in_list) == 0)//future developers it grabs the name from the string used in this comparison
					{
						//this checks which location the name is in the scroll
						round_roleID = client.getWidget(BaRoleWidget, (i + 10)).getModelId();
						round_role = IDfinder(round_roleID);
						log.debug("Your role has been identified as {}", round_role);
					}
				}
				if ((leaderIcon.getModelId() == attackerIcon) && (player1Icon.getModelId() == collectorIcon) && (player2Icon.getModelId() == healerIcon) && (player4Icon.getModelId() == defenderIcon))
				{

					log.debug("Leeches {} role identified as {}", player3.getText(), IDfinder(player3Icon.getModelId()));
					round_role = "Leech " + round_role;
					log.debug("This has been identified as a leech run as {}",round_role);
					leech = true;
				}


			}
		}
	}



	private String IDfinder(int roleID){
		if (roleID == attackerIcon) return "Attacker";
		if (roleID == defenderIcon) return "Defender";
		if (roleID == collectorIcon) return "Collector";
		if (roleID == healerIcon) return "Healer";
		return "";
	}


}


	/*
	 * Copyright (c) 2019, SkylerPIlot <https://github.com/SkylerPIlot>
	 * All rights reserved.
	 *
	 * Redistribution and use in source and binary forms, with or without
	 * modification, are permitted provided that the following conditions are met:
	 *
	 * 1. Redistributions of source code must retain the above copyright notice, this
	 *    list of conditions and the following disclaimer.
	 * 2. Redistributions in binary form must reproduce the above copyright notice,
	 *    this list of conditions and the following disclaimer in the documentation
	 *    and/or other materials provided with the distribution.
	 *
	 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
	 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
	 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
	 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
	 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
	 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
	 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	 */
package com.queuehelper;

import java.awt.BorderLayout;
import java.awt.Color;
import java.awt.GridLayout;
import java.awt.event.FocusEvent;
import java.awt.event.FocusListener;
import java.awt.event.ItemEvent;
import java.awt.image.BufferedImage;
import java.util.ArrayList;
import java.util.LinkedHashMap;
import javax.swing.ImageIcon;
import javax.swing.JButton;
import javax.swing.JComboBox;
import javax.swing.JPanel;
import javax.swing.JTextArea;
import javax.swing.KeyStroke;
import javax.swing.border.EmptyBorder;
import net.runelite.client.util.LinkBrowser;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.DynamicGridLayout;
import net.runelite.client.ui.PluginPanel;
import net.runelite.client.ui.components.materialtabs.MaterialTab;
import net.runelite.client.ui.components.materialtabs.MaterialTabGroup;
import net.runelite.client.util.ImageUtil;


public class BasQueuePanel extends PluginPanel
{
	private BASPlugin plugin;

	private final JPanel onlistContainer;

	private final JPanel offlistContainer;

	private ArrayList<BasQueueRow> rows;

	private BASConfig config;

	private JButton nextButton;

	private JButton custButton;

	private JTextArea namearea;

	private JPanel nextRefreshArea;

	private JPanel custPrioArea;

	private String currItem;

	private String currPriority;

	private JPanel nameAreaPanel;

	private JButton viewOnlineQueue;

	AutoComplete autoComplete;

	private final JPanel display = new JPanel();

	private final MaterialTabGroup tabGroup = new MaterialTabGroup(display);

	ArrayList<String> keywords = new ArrayList<String>();

	BasQueuePanel(BASPlugin plugin, BASConfig Config)
	{
		this.plugin = plugin;
		this.config = Config;

		this.rows = new ArrayList<>();
		this.onlistContainer = new JPanel();
		this.offlistContainer = new JPanel();

		this.setBorder(null);
		this.setLayout(new DynamicGridLayout(0, 1));

		this.onlistContainer.setLayout(new GridLayout(0, 1));
		this.offlistContainer.setLayout(new GridLayout(0, 1));

		setLayout(new BorderLayout());
		setBackground(ColorScheme.DARK_GRAY_COLOR);

		MaterialTab offersTab = new MaterialTab("Online", tabGroup, onlistContainer);
		MaterialTab searchTab = new MaterialTab("Offline", tabGroup, offlistContainer);

		tabGroup.setBorder(new EmptyBorder(5, 0, 0, 0));
		tabGroup.addTab(offersTab);
		tabGroup.addTab(searchTab);
		tabGroup.select(offersTab); // selects the default selected tab

		add(tabGroup, BorderLayout.NORTH);
		add(display, BorderLayout.CENTER);

		nextRefreshArea = refreshNextButton();
		this.nameAreaPanel = customerNamePrioPanel();
		this.custPrioArea = customerAddPanel();

		viewOnlineQueue = new JButton("View Online Queue");
		viewOnlineQueue.setBackground(ColorScheme.DARKER_GRAY_COLOR);
		viewOnlineQueue.setBorder(new EmptyBorder(5, 7, 5, 7));
		viewOnlineQueue.addActionListener(e -> LinkBrowser.browse("https://baservices.site/ranksqueue/"));



	}

	public void setAutoCompleteKeyWords(ArrayList<String> Keywords){
		autoComplete.setKeyWords(Keywords);
		this.keywords = Keywords;
	}

	void populate(LinkedHashMap<String, Customer> queue)
	{
		this.rows.clear();
		this.offlistContainer.removeAll();
		this.onlistContainer.removeAll();
		for (Customer cust : queue.values())
		{
			this.rows.add(new BasQueueRow(cust, plugin));

		}
		for (BasQueueRow row : rows)
		{
			if (row.customer.getStatus().equals("Online") || row.customer.getStatus().equals("In Progress"))
			{
				onlistContainer.add(row);
			}
			else
			{
				offlistContainer.add(row);
			}
		}

		onlistContainer.add(nextRefreshArea);
		onlistContainer.add(nameAreaPanel);
		onlistContainer.add(custPrioArea);
		onlistContainer.add(viewOnlineQueue);
	}


	private JPanel addRefreshButton(String label)
	{
		final JPanel container = new JPanel();
		container.setLayout(new BorderLayout());

		JButton resetButton = new JButton(label);

		resetButton.setBackground(ColorScheme.DARK_GRAY_COLOR);
		resetButton.setBorder(new EmptyBorder(5, 0, 5, 5));
		resetButton.setToolTipText("refreshes the online Queue and redraws it");
		resetButton.setEnabled(true);

		resetButton.addActionListener(e -> {
			this.plugin.refreshQueue();
		});

		container.add(resetButton, BorderLayout.CENTER);

		return container;
	}

	private JPanel addNextButton(String label)
	{

		final JPanel container = new JPanel();
		container.setLayout(new BorderLayout());

		nextButton = new JButton(label);

		nextButton.setBackground(ColorScheme.DARKER_GRAY_COLOR);
		nextButton.setBorder(new EmptyBorder(5, 5, 5, 7));

		nextButton.addActionListener(e -> this.plugin.getNext());

		container.add(nextButton, BorderLayout.CENTER);

		//add(container, BorderLayout.SOUTH);
		return container;
	}

	private JComboBox<ComboBoxIconEntry> createCombobox()
	{
		final JComboBox<ComboBoxIconEntry> dropdown = new JComboBox<>();
		dropdown.setFocusable(false); // To prevent an annoying "focus paint" effect
		dropdown.setForeground(Color.WHITE);
		dropdown.setMaximumRowCount(5);
		final ComboBoxIconListRenderer renderer = new ComboBoxIconListRenderer();
		renderer.setDefaultText("Select an Item...");
		dropdown.setRenderer(renderer);
		final BufferedImage torsoimg = ImageUtil.loadImageResource(getClass(), "/torso.png");
		final ComboBoxIconEntry torsoentry = new ComboBoxIconEntry(new ImageIcon(torsoimg), "Torso");
		final BufferedImage lvl5img = ImageUtil.loadImageResource(getClass(), "/Level5s.png");
		final ComboBoxIconEntry lvl5entry = new ComboBoxIconEntry(new ImageIcon(lvl5img), "Level 5 Roles");
		final BufferedImage pointsimg = ImageUtil.loadImageResource(getClass(), "/points.png");
		final ComboBoxIconEntry pointsentry = new ComboBoxIconEntry(new ImageIcon(pointsimg), "One Round - Points");
		final BufferedImage qkimg = ImageUtil.loadImageResource(getClass(), "/queen_kill.png");
		final ComboBoxIconEntry qkentry = new ComboBoxIconEntry(new ImageIcon(qkimg), "Queen Kill - Diary");
		final BufferedImage hatimg = ImageUtil.loadImageResource(getClass(), "/hat4.png");
		final ComboBoxIconEntry hatentry = new ComboBoxIconEntry(new ImageIcon(hatimg), "Hat");


		dropdown.addItem(torsoentry);
		dropdown.addItem(lvl5entry);
		dropdown.addItem(pointsentry);
		dropdown.addItem(qkentry);
		dropdown.addItem(hatentry);
		dropdown.addItemListener(e ->
		{
			if (e.getStateChange() == ItemEvent.SELECTED)
			{
				final ComboBoxIconEntry source = (ComboBoxIconEntry) e.getItem();
				currItem = source.getText();
			}
		});
		dropdown.setSelectedIndex(-1);
		return dropdown;
	}
	private JTextArea customerNamePanel(){
		namearea = new JTextArea(1, 10);
		namearea.setFocusTraversalKeysEnabled(false);
		namearea.setText("Customer");
		namearea.setLineWrap(true);
		namearea.setWrapStyleWord(true);
		namearea.setEditable(true);
		namearea.setOpaque(true);
		namearea.addFocusListener(custAreaFocus());
		namearea.setBorder(new EmptyBorder(20, 20, 2, 20));

		String COMMIT_ACTION = "commit";
		keywords.add("Skyler Miner");

		autoComplete = new AutoComplete(namearea, keywords);
		namearea.getDocument().addDocumentListener(autoComplete);
		namearea.getInputMap().put(KeyStroke.getKeyStroke("TAB"), COMMIT_ACTION);
		namearea.getActionMap().put(COMMIT_ACTION, autoComplete.new CommitAction());

		return namearea;

	}

	private JPanel addCustomerButoon(String label)
	{
		final JPanel container = new JPanel();
		container.setLayout(new BorderLayout());
		custButton = new JButton(label);
		custButton.setBackground(ColorScheme.DARKER_GRAY_COLOR);
		custButton.setBorder(new EmptyBorder(5, 7, 5, 7));
		custButton.addActionListener(e -> addCustomerAction());


		container.add(custButton, BorderLayout.CENTER);
		return container;
	}
	public void changeCustomerText(String name){
		namearea = (JTextArea) nameAreaPanel.getComponent(0);
		this.namearea.setText(name);
	}

	private void addCustomerAction(){
		namearea = (JTextArea) nameAreaPanel.getComponent(0);
		try
		{
			this.plugin.addToQueue(this.namearea.getText(), currItem, currPriority);
			this.namearea.setText("Customer");
		}
		catch (Exception e){
			e.printStackTrace();
		}

	}
	//Deletes the default text and replaces it if you didn't type anything
	private FocusListener custAreaFocus(){
		FocusListener focus = new FocusListener()
		{
			@Override
			public void focusGained(FocusEvent e)
			{
			if(namearea.getText().equals("Customer"))
				{
				namearea = (JTextArea) nameAreaPanel.getComponent(0);
				namearea.setText("");
				}
			}

			@Override
			public void focusLost(FocusEvent e)
			{
			if(namearea.getText().equals("")){
				namearea = (JTextArea) nameAreaPanel.getComponent(0);
				namearea.setText("Customer");
			}
			}
		};
		return focus;

	}


 	private JPanel customerAddPanel(){
		JComboBox<ComboBoxIconEntry> dropdown = createCombobox();
		JPanel custButton = addCustomerButoon("Add Customer");
		JPanel addPanel = new JPanel();
		addPanel.setLayout(new BorderLayout());
		addPanel.setBorder(new EmptyBorder(3, 0, 2, 5));
		addPanel.add(dropdown, BorderLayout.CENTER);
		addPanel.add(custButton, BorderLayout.EAST);
		return addPanel;
	}

	private JPanel customerNamePrioPanel(){
		JComboBox<ComboBoxIconEntry> dropdown = createRegPremSelect();

		JPanel addPanel = new JPanel();
		addPanel.setLayout(new BorderLayout());
		customerNamePanel(); // instantiates this.namearea
		addPanel.setBorder(new EmptyBorder(3, 0, 2, 5));
		addPanel.add(namearea, BorderLayout.CENTER);
		addPanel.add(dropdown, BorderLayout.EAST);
		return addPanel;

	}

	private JPanel refreshNextButton(){
		JPanel combined = new JPanel();
		JPanel next = addNextButton("Next");
		JPanel refresh = addRefreshButton("Refresh");
		combined.setLayout(new BorderLayout());
		combined.setBorder(new EmptyBorder(3, 0, 2, 5));
		combined.add(next, BorderLayout.CENTER);
		combined.add(refresh, BorderLayout.EAST);
		return combined;
	}
	private JComboBox<ComboBoxIconEntry> createRegPremSelect()
	{
		final JComboBox<ComboBoxIconEntry> dropdown = new JComboBox<>();
		dropdown.setFocusable(false); // To prevent an annoying "focus paint" effect
		dropdown.setForeground(Color.WHITE);
		dropdown.setMaximumRowCount(5);
		final ComboBoxIconListRenderer renderer = new ComboBoxIconListRenderer();
		renderer.setDefaultText("Priority");
		dropdown.setRenderer(renderer);
		final BufferedImage regimg = ImageUtil.loadImageResource(getClass(), "/torso.png");
		final ComboBoxIconEntry regentry = new ComboBoxIconEntry(new ImageIcon(regimg), "Regular");
		final BufferedImage premimg = ImageUtil.loadImageResource(getClass(), "/torso.png");
		final ComboBoxIconEntry prementry = new ComboBoxIconEntry(new ImageIcon(premimg), "Premium");
		dropdown.addItem(regentry);
		dropdown.addItem(prementry);
		dropdown.addItemListener(e ->
		{
			if (e.getStateChange() == ItemEvent.SELECTED)
			{
				final ComboBoxIconEntry source = (ComboBoxIconEntry) e.getItem();
				currPriority = source.getText();
			}
		});
		dropdown.setSelectedIndex(-1);
		return dropdown;
	}

}

	/*
	 * Copyright (c) 2019, SkylerPIlot <https://github.com/SkylerPIlot>
	 * All rights reserved.
	 *
	 * Redistribution and use in source and binary forms, with or without
	 * modification, are permitted provided that the following conditions are met:
	 *
	 * 1. Redistributions of source code must retain the above copyright notice, this
	 *    list of conditions and the following disclaimer.
	 * 2. Redistributions in binary form must reproduce the above copyright notice,
	 *    this list of conditions and the following disclaimer in the documentation
	 *    and/or other materials provided with the distribution.
	 *
	 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
	 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
	 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
	 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
	 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
	 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
	 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	 */
package com.queuehelper;

import java.awt.BorderLayout;
import java.awt.Color;
import java.awt.Dimension;
import java.awt.event.ActionListener;
import java.awt.event.FocusEvent;
import java.awt.event.FocusListener;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import javax.swing.ImageIcon;
import javax.swing.JLabel;
import javax.swing.JMenuItem;
import javax.swing.JPanel;
import javax.swing.JPopupMenu;
import javax.swing.JTextArea;
import javax.swing.border.EmptyBorder;
import net.runelite.client.ui.FontManager;
import net.runelite.client.util.ImageUtil;

	class BasQueueRow extends JPanel
{
	private final JMenuItem addMenuOption = new JMenuItem();

	private boolean otherimg;

	private JLabel nameField;
	private JLabel idField;
	private JLabel itemField;
	private JTextArea notesField;

	public Customer customer;

	private Color lastBackground;

	private BASPlugin plugin;

	private JLabel item;


	BasQueueRow(Customer Customer, BASPlugin Plugin)
	{
		this.otherimg = false;
		this.customer = Customer;
		this.plugin = Plugin;

		setLayout(new BorderLayout());
		setBorder(new EmptyBorder(2, 0, 2, 0));
		final JPopupMenu popupMenu = new JPopupMenu();
		popupMenu.setBorder(new EmptyBorder(5, 5, 5, 5));
		String menuText;
		int option;
		String tooltipHover = "";

		if(customer.getStatus().equals("")){
			menuText = "Mark " + customer.getName()+ " online";
			option = 3;
			tooltipHover = "Offline";
		}
		else if(customer.getNotes().toLowerCase().contains("cooldown")){
			menuText = "End Cooldown for: " + customer.getName()+ "(Currently unavailable)";
			option = 0;
			tooltipHover = "Cooldown";
		}
		else if(customer.getStatus().equals("In Progress")){
			if(customer.getItem().equals("Level 5 Roles") && (customer.getNotes().contains("d started") || customer.getNotes().contains("2/3"))){
				menuText = "Mark " + customer.getName()+ " done";
				option = 2;
				tooltipHover = "In Progress last session lvl5s";
			}
			else if(customer.getItem().equals("Level 5 Roles")){
				menuText = "Start Cooldown for: " + customer.getName();
				option = 4;
				tooltipHover = "In Progress lvl5s";
			}
			else{
				menuText = "Mark " + customer.getName()+ " done";
				option = 2;
				tooltipHover = "In Progress";
			}
		}
		else if(customer.getStatus().equals("Done"))
		{
			menuText = "Mark " + customer.getName()+ " in progress";
			option = 1;
			tooltipHover = "Done";
		}
		else{
			menuText = "Mark " + customer.getName()+ " in progress";
			option = 1;
			tooltipHover = "Online";
		}

		addMouseListener(new MouseAdapter()
		{
			@Override
			public void mouseClicked(MouseEvent mouseEvent)
			{
				if (mouseEvent.getClickCount() == 2)
				{
					plugin.markCustomer(option,customer);
				}
			}

			@Override
			public void mousePressed(MouseEvent mouseEvent)
			{
				if (mouseEvent.getClickCount() == 2)
				{
					setBackground(getBackground().brighter());
				}
			}

			@Override
			public void mouseReleased(MouseEvent mouseEvent)
			{
				if (mouseEvent.getClickCount() == 2)
				{
					setBackground(getBackground().darker());
				}
			}

			@Override
			public void mouseEntered(MouseEvent mouseEvent)
			{
				BasQueueRow.this.lastBackground = getBackground();
				setBackground(getBackground().brighter());
			}

			@Override
			public void mouseExited(MouseEvent mouseEvent)
			{
				setBackground(lastBackground);
			}
		});




		addMenuOption.setText(menuText);

		for (ActionListener listener : addMenuOption.getActionListeners())
		{
			addMenuOption.removeActionListener(listener);
		}

		addMenuOption.addActionListener(e ->
		{
			this.plugin.markCustomer(option,customer);
		});
		popupMenu.add(addMenuOption);

		setComponentPopupMenu(popupMenu);

		JPanel leftSide = new JPanel(new BorderLayout());
		JPanel rightSide = new JPanel(new BorderLayout());
		leftSide.setOpaque(false);
		rightSide.setOpaque(false);

		JPanel nameField = buildNameField(Customer);
		nameField.setPreferredSize(new Dimension(70, 10));
		nameField.setOpaque(false);

		JPanel idField = buildidField(Customer);
		idField.setPreferredSize(new Dimension(30, 10));
		idField.setOpaque(false);

		JPanel itemField = builditemField(Customer);
		itemField.setPreferredSize(new Dimension(30, 30));
		itemField.setOpaque(false);

		JPanel notesField = buildNotesField(Customer);
		notesField.setPreferredSize(new Dimension(5, 34));
		notesField.setOpaque(false);

		recolour(Customer);

		leftSide.add(idField, BorderLayout.WEST);
		leftSide.add(nameField, BorderLayout.CENTER);
		rightSide.add(itemField, BorderLayout.WEST);
		rightSide.add(notesField, BorderLayout.CENTER);
		add(leftSide, BorderLayout.WEST);
		add(rightSide, BorderLayout.CENTER);
		this.setToolTipText(tooltipHover);

	}


	public void recolour(Customer customer)
	{
		String status = customer.getStatus();
		Color curColor = Color.black;
		if(this.item == null)
		{
			itemField.setForeground(curColor);
		}
		notesField.setForeground(curColor);
		nameField.setForeground(curColor);
		idField.setForeground(curColor);
		switch(status)
		{
			case "Online":
				if(!customer.getNotes().toLowerCase().contains("cd")&&!customer.getNotes().toLowerCase().contains("cooldown"))
				{
					curColor = Color.green;
					if(this.item == null)
					{
						itemField.setForeground(curColor);
					}
					notesField.setForeground(curColor);
					nameField.setForeground(curColor);
					idField.setForeground(curColor);

					break;
				}
				curColor = new Color(99,151,255);
				this.setBackground(curColor);
				notesField.setBackground(curColor);
				break;

			case "In Progress":
				curColor = new Color(241,235,118);;
				this.setBackground(curColor);
				notesField.setBackground(curColor);
				break;

			case "Done":
				curColor = new Color(129,129,129);;
				this.setBackground(curColor);
				notesField.setBackground(curColor);
				break;

			case "":
				if(!customer.getNotes().toLowerCase().contains("cd")&&!customer.getNotes().toLowerCase().contains("cooldown"))
				{
					curColor = Color.red;
					if(this.item == null)
					{
						itemField.setForeground(curColor);
					}
					notesField.setForeground(curColor);
					nameField.setForeground(curColor);
					idField.setForeground(curColor);
					break;
				}
				curColor = new Color(99,151,255);
				this.setBackground(curColor);
				break;

			default:
				curColor = Color.gray;
				this.setBackground(curColor);

				break;
		}
	}

	/**
	 * Builds the players list field (containing the amount of players logged in that world).
	 */
	private JPanel builditemField(Customer cust)
	{
		String item = cust.getItem();
		JPanel column = new JPanel(new BorderLayout());
		switch(item){

			case "Torso":
				column = new JPanel(new BorderLayout());
				itemField = new JLabel(new ImageIcon(ImageUtil.loadImageResource(getClass(), "/torso.png")));
				column.add(itemField);
				return column;

			case "Queen Kill - Diary":
				column = new JPanel(new BorderLayout());
				itemField = new JLabel(new ImageIcon(ImageUtil.loadImageResource(getClass(), "/queen_kill.png")));
				column.add(itemField);
				return column;

			case "Level 5 Roles":
				column = new JPanel(new BorderLayout());
				itemField = new JLabel(new ImageIcon(ImageUtil.loadImageResource(getClass(), "/Level5s.png")));
				column.add(itemField);
				return column;

			case "Hat":
				column = new JPanel(new BorderLayout());
				itemField = new JLabel(new ImageIcon(ImageUtil.loadImageResource(getClass(), "/hat4.png")));
				column.add(itemField);
				return column;


			default:
				if(item.toLowerCase().contains("gamble")){
					column = new JPanel(new BorderLayout());
					itemField = new JLabel(new ImageIcon(ImageUtil.loadImageResource(getClass(), "/Other.png")));
					column.add(itemField);
					return column;

				}
				if(item.toLowerCase().contains("points") || item.toLowerCase().contains("pts")){
					column = new JPanel(new BorderLayout());
					itemField = new JLabel(new ImageIcon(ImageUtil.loadImageResource(getClass(), "/points.png")));
					otherimg = true;
					column.add(itemField);
					return column;

				}
				else
				{
					column = new JPanel(new BorderLayout());
					itemField = new JLabel(new ImageIcon(ImageUtil.loadImageResource(getClass(), "/Other.png")));
					column.add(itemField);
					otherimg = true;
					return column;
				}

		}
	}



	private JPanel buildidField(Customer cust)
	{
		JPanel column = new JPanel(new BorderLayout());
		column.setBorder(new EmptyBorder(0, 0, 0, 5));

		idField = new JLabel(cust.getID());
		idField.setFont(FontManager.getRunescapeSmallFont().deriveFont(8));

		idField.setToolTipText(cust.getID());
		// Pass up events - https://stackoverflow.com/a/14932443
		idField.addMouseListener(new MouseAdapter()
		{
			@Override
			public void mouseClicked(MouseEvent e)
			{
				dispatchEvent(e);
			}

			@Override
			public void mousePressed(MouseEvent e)
			{
				dispatchEvent(e);
			}

			@Override
			public void mouseReleased(MouseEvent e)
			{
				dispatchEvent(e);
			}

			@Override
			public void mouseEntered(MouseEvent e)
			{
				dispatchEvent(e);
			}

			@Override
			public void mouseExited(MouseEvent e)
			{
				dispatchEvent(e);
			}
		});

		column.add(idField, BorderLayout.EAST);


		return column;
	}

	/**
	 * Builds the activity list field (containing that world's activity/theme).
	 */
	private JPanel buildNotesField(Customer cust)
	{
		JPanel column = new JPanel(new BorderLayout());
		column.setBorder(new EmptyBorder(0, 5, 0, 5));


		String activity = cust.getNotes();
		if(this.otherimg){
			activity = cust.getItem() + " " + cust.getNotes();
		}

		notesField = new JTextArea(2, 10);
		notesField.setText(activity);


		notesField.setLineWrap(true);
		notesField.setWrapStyleWord(true);
		notesField.setEditable(true);
		notesField.setOpaque(false);
		notesField.setFont(FontManager.getRunescapeSmallFont().deriveFont(this.plugin.fontSize));


		column.add(notesField, BorderLayout.WEST);

		return column;
	}


	private JPanel buildNameField(Customer cust)
	{
		JPanel column = new JPanel(new BorderLayout());
		column.setBorder(new EmptyBorder(0, 5, 0, 5));

		nameField = new JLabel(cust.getName());
		nameField.setFont(FontManager.getRunescapeSmallFont());

		column.add(nameField, BorderLayout.CENTER);

		return column;
	}






}

/*
 * Copyright (c) 2019, TheStonedTurtle <http://github.com/TheStonedTurtle>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.queuehelper;

import javax.annotation.Nullable;
import javax.swing.Icon;
import lombok.AllArgsConstructor;
import lombok.Getter;
@AllArgsConstructor
@Getter
public class ComboBoxIconEntry
{
	private Icon icon;
	private String text;

}

	/*
	 * Copyright (c) 2019, TheStonedTurtle <https://github.com/TheStonedTurtle>
	 * All rights reserved.
	 *
	 * Redistribution and use in source and binary forms, with or without
	 * modification, are permitted provided that the following conditions are met:
	 *
	 * 1. Redistributions of source code must retain the above copyright notice, this
	 *    list of conditions and the following disclaimer.
	 * 2. Redistributions in binary form must reproduce the above copyright notice,
	 *    this list of conditions and the following disclaimer in the documentation
	 *    and/or other materials provided with the distribution.
	 *
	 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
	 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
	 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
	 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
	 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
	 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
	 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	 */
package com.queuehelper;

	import java.awt.Color;
	import java.awt.Component;
	import javax.swing.JLabel;
	import javax.swing.JList;
	import javax.swing.ListCellRenderer;
	import javax.swing.border.EmptyBorder;
	import lombok.Setter;
	import net.runelite.client.ui.ColorScheme;
	import net.runelite.client.util.Text;

public class ComboBoxIconListRenderer extends JLabel implements ListCellRenderer
{
	@Setter
	private String defaultText = "Select an option...";

	@Override
	public Component getListCellRendererComponent(JList list, Object o, int index, boolean isSelected, boolean cellHasFocus)
	{
		if (isSelected)
		{
			setBackground(ColorScheme.DARK_GRAY_COLOR);
			setForeground(Color.WHITE);
		}
		else
		{
			setBackground(list.getBackground());
			setForeground(ColorScheme.LIGHT_GRAY_COLOR);
		}

		setBorder(new EmptyBorder(5, 5, 5, 0));

		String text;
		setIcon(null);
		// If using setSelectedItem(null) or setSelectedIndex(-1) show default text until a selection is made
		if (index == -1 && o == null)
		{
			text = defaultText;
		}
		else if (o instanceof Enum)
		{
			text = Text.titleCase((Enum) o);
		}
		else if (o instanceof ComboBoxIconEntry)
		{
			final ComboBoxIconEntry e = (ComboBoxIconEntry) o;
			text = e.getText();
			setIcon(e.getIcon());
		}
		else
		{
			text = o.toString();
		}

		setText(text);

		return this;
	}
}

	/*
	 * Copyright (c) 2019, SkylerPIlot <https://github.com/SkylerPIlot>
	 * All rights reserved.
	 *
	 * Redistribution and use in source and binary forms, with or without
	 * modification, are permitted provided that the following conditions are met:
	 *
	 * 1. Redistributions of source code must retain the above copyright notice, this
	 *    list of conditions and the following disclaimer.
	 * 2. Redistributions in binary form must reproduce the above copyright notice,
	 *    this list of conditions and the following disclaimer in the documentation
	 *    and/or other materials provided with the distribution.
	 *
	 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
	 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
	 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
	 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
	 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
	 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
	 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	 */
package com.queuehelper;

public class Customer
{
	private String CustomerName;

	private String CustomerStatus;

	private String CustomerPriority;

	private String CustomerID;

	private String CustomerNotes;

	private String CustomerItem;

	public Customer(String name, String id, String priority, String CustomerStatus, String CustomerNotes, String CustomerItem){
		this.CustomerName = name;
		this.CustomerID = id;
		this.CustomerPriority = priority;
		this.CustomerStatus = CustomerStatus;
		this.CustomerNotes = CustomerNotes;
		this.CustomerItem = CustomerItem;
	}

	public Customer(String id, String priority, String priority1, String customerNotes, String customerItem)
	{
	}

	public String getName(){
		return this.CustomerName;
	}
	public String getPriority(){
		return this.CustomerPriority;
	}
	public String getID(){
		return this.CustomerID;
	}
	public String getStatus(){
		return this.CustomerStatus;
	}
	public String getItem(){
		return this.CustomerItem;
	}
	public String getNotes() {
		return this.CustomerNotes;
	}

	public void setName(String name){
		this.CustomerName = name;
	}
	public void setPriority(String priority){
		this.CustomerPriority = priority;
	}
	public void setID(String id){
		this.CustomerID = id;
	}
	public void setStatus(String status){
		this.CustomerStatus = status;
	}
	public void setItem(String item){
		this.CustomerItem = item;
	}
	public void setNotes(String notes) {
		this.CustomerNotes = notes;
	}


}

/*
 * Copyright (c) 2018, Jacob M <https://github.com/jacoblairm>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.queuehelper;

import java.time.Duration;
import java.time.Instant;
import java.time.LocalTime;
import java.time.format.DateTimeFormatter;
import static net.runelite.client.util.RSTimeUnit.GAME_TICKS;

class GameTimer
{
    final private Instant startTime = Instant.now();
    int getPBTime()
    {
        return (int)Duration.between(startTime, Instant.now()).minus(Duration.of(1, GAME_TICKS)).getSeconds();
    }

}
	/*
	 * Copyright (c) 2019, SkylerPIlot <https://github.com/SkylerPIlot>
	 * All rights reserved.
	 *
	 * Redistribution and use in source and binary forms, with or without
	 * modification, are permitted provided that the following conditions are met:
	 *
	 * 1. Redistributions of source code must retain the above copyright notice, this
	 *    list of conditions and the following disclaimer.
	 * 2. Redistributions in binary form must reproduce the above copyright notice,
	 *    this list of conditions and the following disclaimer in the documentation
	 *    and/or other materials provided with the distribution.
	 *
	 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
	 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
	 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
	 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
	 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
	 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
	 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	 */
package com.queuehelper;

import java.io.IOException;
import java.util.ArrayList;
import java.util.Date;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Timer;
import java.util.TimerTask;
import javax.swing.SwingUtilities;
import net.runelite.api.events.ChatMessage;
import okhttp3.OkHttpClient;

public class Queue
{
	private static Queue queue;
	private boolean shouldUpdateQueue;
	private BasQueuePanel basPanel;

	private OkHttpClient RLhttpclient;

	Customer tempNext;
	boolean first = true;

	private LinkedHashMap<String, Customer> CurrentQueue;//Queue saved via insertion order

	private List<String[]> OldQueue; //Old csv data used, used in comparison in our implemented HTTPclient interface

	private QueueHelperHTTPClient httpClient;

	Timer timer;

	TimerTask updateQueue;

	BASPlugin plugin;

	private Queue(String apikey, BasQueuePanel BasPanel, BASPlugin Plugin, OkHttpClient rlhttp) throws IOException
	{
		this.plugin = Plugin;
		this.RLhttpclient = rlhttp;
		this.basPanel = BasPanel;
		this.timer = new Timer();
		this.shouldUpdateQueue = false;
		this.CurrentQueue = new LinkedHashMap<String, Customer>();
		this.httpClient = BASHTTPClient.getInstance(apikey, RLhttpclient);
		this.OldQueue = new ArrayList<>();
		createQueue();
		this.updateQueue = new TimerTask()
		{
			@Override
			public void run()
			{
				updateQueueTask(ShouldUpdate());
			}
		};
		timer.scheduleAtFixedRate(this.updateQueue,new Date(),120000);//Schedules a task every 2minutes to both refresh queue object + upload the cc data -> backend
	}

	public static Queue getInstance(String apikey, BasQueuePanel BasPanel, BASPlugin basPlugin,OkHttpClient rlhttp) throws IOException //Singleton queue creation should only need one queue per plugin
	{
		if (Queue.queue == null)
		{
			Queue.queue = new Queue(apikey, BasPanel, basPlugin,rlhttp);
		}
		else
		{
			Queue.queue.setAPikey(apikey);
		}
		return Queue.queue;
	}

	public boolean ShouldUpdate(){
		return this.shouldUpdateQueue;
	}

	public void ShouldUpdate(boolean ShouldUpdateQueue){
		this.shouldUpdateQueue = ShouldUpdateQueue;
	}

	private void setAPikey(String apikey) throws IOException
	{
		this.httpClient = BASHTTPClient.getInstance(apikey,this.RLhttpclient);
	}

	public boolean doesCustExist(String name){
		return CurrentQueue.containsKey(name);
	}

	private void createQueue() throws IOException
	{
		this.OldQueue = httpClient.readCSV(this.OldQueue);
		if(this.OldQueue == null){
			return;
		}
		for (String[] CSVLine : this.OldQueue)
		{
			try {
				this.CurrentQueue.put(CSVLine[1], new Customer(CSVLine[1], CSVLine[3], CSVLine[0], CSVLine[2], CSVLine[5], CSVLine[4]));
			} catch (Exception e) {

				if(CSVLine[0].equals("P")||CSVLine[0].equals("R")) {
					this.CurrentQueue.put(CSVLine[1], new Customer(CSVLine[1], CSVLine[3], CSVLine[0], CSVLine[2], " ", CSVLine[4]));
				}
				//this catches some suboptimal creation actuall yhanldes when ppl use , in the notes column
            }

        }
	}

	public LinkedHashMap<String, Customer> getQueue()
	{
		return this.CurrentQueue;
	}

	public Customer getNext()
	{

		for (Customer cust : this.CurrentQueue.values())
		{
			if (cust.getStatus().equals("Online") && cust.getPriority().equals("P") && !cust.getNotes().toLowerCase().contains("cooldown"))
			{
				return cust;
			}
				if (cust.getStatus().equals("Online") && cust.getPriority().equals("R") && !cust.getNotes().toLowerCase().contains("cooldown") && first)
			{
				first = false;
				tempNext = cust;//sets the first regular customer to the returned name if no premiums exist
			}


		}
		first = true;
		return tempNext;

	}

	public void refresh() throws IOException
	{
		this.plugin.updateQueue();
		this.CurrentQueue.clear();
		this.createQueue();
	}

	public void mark(int option, Customer cust,String rankname) throws IOException
	{
		this.httpClient.markCustomer(option, cust.getName(), rankname);
	}
	//scheduled task every2minutes Both redraws the panel after retrieving uptodate queue + sends data to the queue given someone has left/joined the cc
	private void updateQueueTask(boolean shouldUpdateQueue)
	{
		if(shouldUpdateQueue){
			try
			{
				this.plugin.updateQueue();
			}
			catch (IOException e)
			{
				e.printStackTrace();
			}
			this.shouldUpdateQueue = false;
		}
		try
		{
			createQueue();
		}
		catch (IOException e)
		{
			e.printStackTrace();
		}

		SwingUtilities.invokeLater(() -> this.basPanel.populate(queue.getQueue()));
	}

	public boolean addToQueue(String itemName, String priority, String custName, String addedBy){
		try
		{
			return httpClient.addCustomer(itemName, priority, custName, addedBy);
		}
		catch (IOException e)
		{
			e.printStackTrace();
		}
		return false;
	}

	public void updateQueuebackend(StringBuilder urlList, String name) throws IOException
	{
		httpClient.updateQueuebackend(urlList,name);
	}

	public void sendChatMsgDiscord(ChatMessage chatMessage){
		try
		{
			httpClient.sendChatMsgDiscord(chatMessage);
		}
		catch (IOException e)
		{
			e.printStackTrace();
		}
	}

	public void sendRoundMsd(String main, String collector, String healer, String leech, String defender, int time, String premiumType, String item
			,int attpts, int defpts, int healpts, int collpts, int eggsCollected, int hpHealed, int wrongAtts,String leechrole){
		int premID = 0;
		if(!premiumType.equals("R")){
			premID = 1;
		}
		httpClient.sendRoundTimeServer(main, collector, healer, leech, defender, time, premID, item, attpts,  defpts,  healpts,  collpts,  eggsCollected,  hpHealed,  wrongAtts, leechrole);
	}

	public Customer getCustomer(String name){
		return CurrentQueue.get(name);
	}
}

	/*
	 * Copyright (c) 2019, SkylerPIlot <https://github.com/SkylerPIlot>
	 * All rights reserved.
	 *
	 * Redistribution and use in source and binary forms, with or without
	 * modification, are permitted provided that the following conditions are met:
	 *
	 * 1. Redistributions of source code must retain the above copyright notice, this
	 *    list of conditions and the following disclaimer.
	 * 2. Redistributions in binary form must reproduce the above copyright notice,
	 *    this list of conditions and the following disclaimer in the documentation
	 *    and/or other materials provided with the distribution.
	 *
	 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
	 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
	 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
	 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
	 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
	 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
	 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	 */
package com.queuehelper;

import java.io.IOException;
import java.util.List;
import net.runelite.api.events.ChatMessage;

//To create your own implementation, change which implementation is called by the Queue object. To make sure data is
	//"Correct" look how the queue class handles the IO data especially how it creates the list of customers

public interface QueueHelperHTTPClient
{

	static QueueHelperHTTPClient getInstance(String apikey) throws IOException
	{
		return null;
	}


	void setAPikey(String apikey);

	public boolean markCustomer(int option, String name, String rankname) throws IOException;

	public List<String[]> readCSV(List<String[]> csv) throws IOException;//Please pay close attention to how the queue object expects the customer name/id and so forth. A small quirk is it expect cooldown status to be present in the "notes" part of the customer

	public boolean updateQueuebackend(StringBuilder urlList, String name) throws IOException;

	public boolean addCustomer(String itemName,String priority, String custName, String addedBy) throws IOException;

	public boolean sendChatMsgDiscord(ChatMessage chatmessage) throws IOException;

	public boolean sendRoundTimeServer(String main, String collector, String healer, String leech, String Defender, int time, int premiumType, String item
										,int attpts, int defpts, int healpts, int collpts, int eggsCollected, int hpHealed, int wrongAtts, String leechrole);
}

package com.queuehelper;

import net.runelite.client.RuneLite;
import net.runelite.client.externalplugins.ExternalPluginManager;

public class BASPluginTest
{
	public static void main(String[] args) throws Exception
	{
		ExternalPluginManager.loadBuiltin(BASPlugin.class);
		RuneLite.main(args);
	}
}
