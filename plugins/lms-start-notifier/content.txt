/*
 * Copyright (c) 2021, Matsyir <https://github.com/matsyir>
 * Copyright (c) 2020, Mazhar <https://twitter.com/maz_rs>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.lmsnotifier;

import java.util.HashSet;
import java.util.Set;

public enum AttackAnimation {
    // MELEE
    MELEE_DAGGER_SLASH(376), // tested w/ dds
    MELEE_SPEAR_STAB(381), // tested w/ zammy hasta
    MELEE_SWORD_STAB(386), // tested w/ dragon sword, obby sword, d long
    MELEE_SCIM_SLASH(390), // tested w/ rune & dragon scim, d sword, VLS, obby sword

    MELEE_GENERIC_SLASH(393), // tested w/ zuriel's staff, d long slash, dclaws regular slash
    MELEE_STAFF_CRUSH(0), // 393 previously, save name to support old fights but no longer track

    MELEE_BATTLEAXE_SLASH(395), // tested w/ rune baxe
    MELEE_MACE_STAB(400), // tested w/ d mace
    MELEE_BATTLEAXE_CRUSH(401), // tested w/ rune baxe, dwh & statius warhammer animation, d mace
    MELEE_2H_CRUSH(406), // tested w/ rune & dragon 2h
    MELEE_2H_SLASH(407), // tested w/ rune & dragon 2h
    MELEE_STAFF_CRUSH_2(414), // tested w/ ancient staff, 3rd age wand
    MELEE_STAFF_CRUSH_3(419), // Common staff crush. Air/fire/etc staves, smoke battlestaff, SOTD/SOL crush, zammy hasta crush
    MELEE_PUNCH(422),
    MELEE_KICK(423),
    MELEE_STAFF_STAB(428), // tested w/ SOTD/SOL jab, vesta's spear stab, c hally
    MELEE_SPEAR_CRUSH(429), // tested w/ vesta's spear
    MELEE_STAFF_SLASH(440), // tested w/ SOTD/SOL slash, zammy hasta slash, vesta's spear slash, c hally
    MELEE_DLONG_SPEC(1058), // tested w/ d long spec, also thammaron's sceptre crush (????)...
    MELEE_DRAGON_MACE_SPEC(1060),
    MELEE_DRAGON_DAGGER_SPEC(1062),
    MELEE_DRAGON_WARHAMMER_SPEC(1378), // tested w/ dwh, statius warhammer spec
    MELEE_ABYSSAL_WHIP(1658), // tested w/ whip, tent whip
    MELEE_GRANITE_MAUL(1665), // tested w/ normal gmaul, ornate maul
    MELEE_GRANITE_MAUL_SPEC(1667), // tested w/ normal gmaul, ornate maul
    MELEE_DHAROKS_GREATAXE_CRUSH(2066),
    MELEE_DHAROKS_GREATAXE_SLASH(2067),
    MELEE_AHRIMS_STAFF_CRUSH(2078),
    MELEE_OBBY_MAUL_CRUSH(2661),
    MELEE_ABYSSAL_DAGGER_STAB(3297),
    MELEE_ABYSSAL_BLUDGEON_CRUSH(3298),
    MELEE_LEAF_BLADED_BATTLEAXE_CRUSH(3852),
    MELEE_BARRELCHEST_ANCHOR_CRUSH(5865),
    MELEE_LEAF_BLADED_BATTLEAXE_SLASH(7004),
    MELEE_GODSWORD_SLASH(7045), // tested w/ AGS, BGS, ZGS, SGS, AGS(or) sara sword
    MELEE_GODSWORD_CRUSH(7054), // tested w/ AGS, BGS, ZGS, SGS, sara sword
    MELEE_DRAGON_CLAWS_SPEC(7514),
    MELEE_VLS_SPEC(7515), // both VLS and dragon sword spec
    MELEE_ELDER_MAUL(7516),
    MELEE_ZAMORAK_GODSWORD_SPEC(7638), // tested zgs spec
    MELEE_ZAMORAK_GODSWORD_OR_SPEC(7639), // UNTESTED, assumed due to ags(or)
    MELEE_SARADOMIN_GODSWORD_SPEC(7640), // tested sgs spec
    MELEE_SARADOMIN_GODSWORD_OR_SPEC(7641), // UNTESTED, assumed due to ags(or)
    MELEE_BANDOS_GODSWORD_SPEC(7642), // tested bgs spec
    MELEE_BANDOS_GODSWORD_OR_SPEC(7643), // UNTESTED, assumed due to ags(or)
    MELEE_ARMADYL_GODSWORD_SPEC(7644), // tested ags spec
    MELEE_ARMADYL_GODSWORD_OR_SPEC(7645), // tested ags(or) spec
    MELEE_SCYTHE(8056), // tested w/ all scythe styles (so could be crush, but unlikely)
    MELEE_GHAZI_RAPIER_STAB(8145), // rapier slash is 390, basic slash animation. Also VLS stab.
    MELEE_ANCIENT_GODSWORD_SPEC(9171),

    // RANGED
    RANGED_SHORTBOW(426), // Confirmed same w/ 3 types of arrows, w/ maple, magic, & hunter's shortbow, craw's bow, dbow, dbow spec
    RANGED_RUNE_KNIFE_PVP(929), // 1 tick animation, has 1 tick delay between attacks. likely same for all knives. Same for morrigan's javelins, both spec & normal attack.
    RANGED_MAGIC_SHORTBOW_SPEC(1074),
    RANGED_CROSSBOW_PVP(4230), // Tested RCB & ACB w/ dragonstone bolts (e) & diamond bolts (e)
    RANGED_BLOWPIPE(5061), // tested in PvP with all styles. Has 1 tick delay between animations in pvp.
    RANGED_DARTS(6600), // tested w/ addy darts. Seems to be constant animation but sometimes stalls and doesn't animate
    RANGED_BALLISTA(7218), // Tested w/ dragon javelins.
    RANGED_DRAGON_THROWNAXE_SPEC(7521),
    RANGED_RUNE_CROSSBOW(7552),
    RANGED_BALLISTA_2(7555), // tested w/ light & heavy ballista, dragon & iron javelins.
    RANGED_RUNE_KNIFE(7617), // 1 tick animation, has 1 tick delay between attacks. Also d thrownaxe
    RANGED_DRAGON_KNIFE(8194),
    RANGED_DRAGON_KNIFE_POISONED(8195), // tested w/ d knife p++
    RANGED_DRAGON_KNIFE_SPEC(8292),
    RANGED_ZARYTE_CROSSBOW(9168),
    RANGED_ZARYTE_CROSSBOW_PVP(9166),

    // MAGIC - uses highest base damage available when animations are re-used. No damage = 0 damage.
    // for example, strike/bolt/blast animation will be fire blast base damage, multi target ancient spells will be ice barrage.
    MAGIC_STANDARD_BIND(710), // tested w/ bind, snare, entangle
    MAGIC_STANDARD_STRIKE_BOLT_BLAST(711), // tested w/ bolt
    MAGIC_STANDARD_BIND_STAFF(1161), // tested w/ bind, snare, entangle, various staves
    MAGIC_STANDARD_STRIKE_BOLT_BLAST_STAFF(1162), // strike, bolt and blast (tested all spells, different weapons)
    MAGIC_STANDARD_WAVE_STAFF(1167), // tested many staves
    MAGIC_STANDARD_SURGE_STAFF(7855), // tested many staves
    MAGIC_ANCIENT_SINGLE_TARGET(1978), // Rush & Blitz animations (tested all 8, different weapons)
    MAGIC_ANCIENT_MULTI_TARGET(1979), // Burst & Barrage animations (tested all 8, different weapons)
    MAGIC_VOLATILE_NIGHTMARE_STAFF_SPEC(8532), // assume 99 mage's base damage (does not rise when boosted).
    ;

    public static final Set<Integer> anims = new HashSet<>();
    static {
        for (AttackAnimation data : values()) {
            anims.add(data.animId);
        }
    }

    public final int animId;

    AttackAnimation(int animId) {
        this.animId = animId;
    }

    static boolean contains(int animId) {
        return anims.contains(animId);
    }
}

package com.lmsnotifier;

public enum BotDisplay {
    ALL_INFO,
    BOTS_ONLY,
    NONE,
    ;
}

package com.lmsnotifier;

import lombok.extern.slf4j.Slf4j;
import net.runelite.api.ChatMessageType;
import net.runelite.api.Client;
import net.runelite.api.Player;
import net.runelite.client.util.ColorUtil;

import javax.inject.Inject;
import java.awt.*;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

@Slf4j
public class BotIdentification {

    private final Client client;
    private final LMSConfig config;
    private final LMSPlugin plugin;

    private final Map<String, PlayerTracker> playerToTracker = new HashMap<>();
    private final Map<String, String> attackerToVictim = new HashMap<>();
    private int tick;

    @Inject
    private BotIdentification(Client client, LMSConfig config, LMSPlugin plugin) {
        this.client = client;
        this.config = config;
        this.plugin = plugin;
    }

    public void reset() {
//        dumpInfo();
        if (config.summarizeBots()) {
            displaySummary();
        }
        playerToTracker.clear();
        attackerToVictim.clear();
        tick = 0;
    }

    private void displaySummary() {
        int bots = 0;
        int humans = 0;
        int unknowns = 0;
        for (PlayerTracker tracker : playerToTracker.values()) {
            if (tracker.status == null) {
                unknowns++;
                continue;
            }
            switch (tracker.status) {
                case UNSURE:
                    unknowns++;
                    break;
                case BOT:
                    bots++;
                    break;
                case HUMAN:
                    humans++;
                    break;
            }
        }
        String message = "You saw " + ColorUtil.wrapWithColorTag(Integer.toString(humans), Color.RED) + " humans, "
                + ColorUtil.wrapWithColorTag(Integer.toString(bots), Color.RED) + " bots, and "
                + ColorUtil.wrapWithColorTag(Integer.toString(unknowns), Color.RED) + " unknowns that game.";
        client.addChatMessage(ChatMessageType.GAMEMESSAGE, "", message, "");
    }

//    private void dumpInfo() {
//        playerToTracker.forEach((name, playerTracker) -> {
//            System.out.println(name);
//            for (PlayerSnapshot snapshot : playerTracker.snapshots) {
//                if (snapshot == null)
//                    continue;
//                System.out.println(snapshot);
//            }
//        });
//    }

    public void tick() {
        if (!shouldAnalyze() || !plugin.inGame || client.getLocalPlayer().getWorldLocation().getRegionID() == LMSPlugin.FEROX_REGION_ID) {
            return;
        }
        List<Player> players = new ArrayList<>(client.getPlayers());
        for (Player player : players) {
            if (client.getLocalPlayer().getName().equals(player.getName())) {
                continue;
            }
            Player opponent = getOpponent(player);
            PlayerSnapshot snapshot = new PlayerSnapshot(player, opponent, tick);
            PlayerTracker tracker = playerToTracker.computeIfAbsent(player.getName(), name -> new PlayerTracker(player.getName(), plugin));
            tracker.addSnapshot(snapshot);
            tracker.updateStatus();
        }
        tick++;
    }

    private boolean shouldAnalyze() {
        return config.putNamesInChat() || config.summarizeBots() || config.getBotDisplay() != BotDisplay.NONE;
    }

    private Player getOpponent(Player player) {
        String victim = attackerToVictim.get(player.getName());
        if (victim == null)
            return null;
        String victimsAttacker = attackerToVictim.get(victim);
        if (victimsAttacker == null)
            return null;
        return findPlayerByName(victim);
    }

    public Player findPlayerByName(String name) {
        for (Player player : client.getPlayers()) {
            if (player.getName().equals(name))
                return player;
        }
        return null;
    }

    public Status statusFor(String name) {
        if (!playerToTracker.containsKey(name))
            return Status.UNSURE;
        return playerToTracker.get(name).getStatus();
    }

    public void interaction(Player source, Player target) {
        attackerToVictim.put(source.getName(), target.getName());
    }

    enum Status {
        UNSURE,
        BOT,
        HUMAN,
        ;
    }
}

package com.lmsnotifier;

public enum ChestHightlight
{
	NEVER,
	HAS_KEY,
	ALWAYS,
	;
}

package com.lmsnotifier;

public enum ChestHightlightType
{
	TILE,
	CLICK_BOX,
	HULL,
	;
}

package com.lmsnotifier;

class ColourUtil
{
	static int interpolateBetweenRgbs(int rgb1, int rgb2, double proportion)
	{
		HsvColour first = RgbToHsv(new RgbColour(rgb1));
		HsvColour second = RgbToHsv(new RgbColour(rgb2));

		HsvColour result = new HsvColour(
			first.h + (int) (proportion * (second.h - first.h)),
			first.s + (int) (proportion * (second.s - first.s)),
			first.v + (int) (proportion * (second.v - first.v))
		);

		RgbColour converted = HsvToRgb(result);
		return (converted.r & 0xFF) << 16 | (converted.g & 0xFF) << 8 | converted.b & 0xFF;
	}

	//Hsv and Rgb code modified from https://stackoverflow.com/a/14733008
	private static RgbColour HsvToRgb(HsvColour hsv)
	{
		RgbColour rgb = new RgbColour(1, 1, 1);
		int region, remainder, p, q, t;

		if (hsv.s == 0)
		{
			rgb.r = hsv.v;
			rgb.g = hsv.v;
			rgb.b = hsv.v;
			return rgb;
		}

		region = hsv.h / 43;
		remainder = (hsv.h - (region * 43)) * 6;

		p = (hsv.v * (255 - hsv.s)) >> 8;
		q = (hsv.v * (255 - ((hsv.s * remainder) >> 8))) >> 8;
		t = (hsv.v * (255 - ((hsv.s * (255 - remainder)) >> 8))) >> 8;

		switch (region)
		{
			case 0:
				rgb.r = hsv.v;
				rgb.g = t;
				rgb.b = p;
				break;
			case 1:
				rgb.r = q;
				rgb.g = hsv.v;
				rgb.b = p;
				break;
			case 2:
				rgb.r = p;
				rgb.g = hsv.v;
				rgb.b = t;
				break;
			case 3:
				rgb.r = p;
				rgb.g = q;
				rgb.b = hsv.v;
				break;
			case 4:
				rgb.r = t;
				rgb.g = p;
				rgb.b = hsv.v;
				break;
			default:
				rgb.r = hsv.v;
				rgb.g = p;
				rgb.b = q;
				break;
		}

		return rgb;
	}

	private static HsvColour RgbToHsv(RgbColour rgb)
	{
		HsvColour hsv = new HsvColour(0, 0, 0);
		int rgbMin, rgbMax;

		rgbMin = rgb.r < rgb.g ? (rgb.r < rgb.b ? rgb.r : rgb.b) : (rgb.g < rgb.b ? rgb.g : rgb.b);
		rgbMax = rgb.r > rgb.g ? (rgb.r > rgb.b ? rgb.r : rgb.b) : (rgb.g > rgb.b ? rgb.g : rgb.b);

		hsv.v = rgbMax;
		if (hsv.v == 0)
		{
			hsv.h = 0;
			hsv.s = 0;
			return hsv;
		}

		hsv.s = 255 * (rgbMax - rgbMin) / hsv.v;
		if (hsv.s == 0)
		{
			hsv.h = 0;
			return hsv;
		}

		if (rgbMax == rgb.r)
		{
			hsv.h = 43 * (rgb.g - rgb.b) / (rgbMax - rgbMin);
		}
		else if (rgbMax == rgb.g)
		{
			hsv.h = 85 + 43 * (rgb.b - rgb.r) / (rgbMax - rgbMin);
		}
		else
		{
			hsv.h = 171 + 43 * (rgb.r - rgb.g) / (rgbMax - rgbMin);
		}

		return hsv;
	}

	static class RgbColour
	{
		int r;
		int g;
		int b;

		RgbColour(int r, int g, int b)
		{
			this.r = r;
			this.g = g;
			this.b = b;
		}

		RgbColour(int rgb)
		{
			this.r = (rgb >> 16) & 0xFF;
			this.g = (rgb >> 8) & 0xFF;
			this.b = rgb & 0xFF;
		}
	}

	static class HsvColour
	{
		int h;
		int s;
		int v;

		HsvColour(int h, int s, int v)
		{
			this.h = h;
			this.s = s;
			this.v = v;
		}
	}
}
package com.lmsnotifier;

import com.google.gson.Gson;
import com.google.gson.reflect.TypeToken;
import lombok.AllArgsConstructor;
import lombok.Value;
import net.runelite.api.*;
import net.runelite.client.RuneLite;

import javax.inject.Inject;
import java.io.File;
import java.io.IOException;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.util.HashMap;
import java.util.Map;

public class DeathTracker {

    private static final File SAVE_FILE = new File(RuneLite.RUNELITE_DIR, "lms-kd.json");

    @Inject
    private Client client;

    @Inject
    private LMSConfig config;

    @Inject
    private Gson gson;

    private int lastAttackTick;
    private Player opponent;
    private Player potentialOpponent;

    // maps player names to deaths/kills
    private final Map<String, KD> deathMap = new HashMap<>();

    public void interactChanged(Player source, Player target) {
        if (source.equals(client.getLocalPlayer())) {
            potentialOpponent = target;
        } else if (target.equals(client.getLocalPlayer())) {
            potentialOpponent = source;
        }
    }

    public void animationChanged(Actor actor) {
        if (!(actor instanceof Player)) {
            return;
        }
        checkDeath(actor);
        if (!AttackAnimation.contains(actor.getAnimation())) {
            return;
        }
        Player player = (Player) actor;
        if (player.getName() == null) {
            return;
        }
        if (opponent != null && player.getName().equals(opponent.getName())) {
            lastAttackTick = client.getTickCount();
            return;
        }
        if (potentialOpponent != null && client.getTickCount() - lastAttackTick > 5
                && player.getName().equals(potentialOpponent.getName())) {
            lastAttackTick = client.getTickCount();
            opponent = potentialOpponent;
        }
    }

    private void checkDeath(Actor actor) {
        if (actor.getAnimation() != AnimationID.DEATH || actor.getName() == null || opponent == null) {
            return;
        }
        KD kd;
        if (actor.getName().equals(opponent.getName())) {
            kd = new KD(1, 0);
            if (config.fightResultInChat()) {
                client.addChatMessage(ChatMessageType.CONSOLE, "", "You killed " + opponent.getName(), "");
            }
        } else if (actor.getName().equals(client.getLocalPlayer().getName())) {
            kd = new KD(0, 1);
            if (config.fightResultInChat()) {
                client.addChatMessage(ChatMessageType.CONSOLE, "", "You died to " + opponent.getName(), "");
            }
        } else {
            return;
        }
        deathMap.merge(opponent.getName(), kd, KD::sum);
        opponent = null;
        lastAttackTick = 0;
    }

    public void load() {
        if (!SAVE_FILE.exists()) {
            return;
        }
        try {
            String json = new String(Files.readAllBytes(SAVE_FILE.toPath()));
            deathMap.putAll(gson.fromJson(json, new TypeToken<Map<String, KD>>() {}.getType()));
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    public void save() {
        String json = gson.toJson(deathMap);
        try {
            Files.write(SAVE_FILE.toPath(), json.getBytes(StandardCharsets.UTF_8));
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    public KD getKD(String name) {
        return deathMap.getOrDefault(name, new KD(0, 0));
    }

    @AllArgsConstructor
    @Value
    public static class KD {
        public int kills;
        public int deaths;

        public static KD sum(KD kd, KD kd1) {
            return new KD(kd.kills + kd1.kills, kd.deaths + kd1.deaths);
        }
    }
}

package com.lmsnotifier;

import net.runelite.api.Client;
import net.runelite.api.coords.WorldPoint;
import net.runelite.client.ui.overlay.infobox.InfoBox;
import net.runelite.client.util.AsyncBufferedImage;

import java.awt.*;

public class FloorInfoBox extends InfoBox {

    private final Client client;
    private final LMSPlugin plugin;
    private final LMSPlugin.FloorItem floorItem;

    public FloorInfoBox(AsyncBufferedImage image, LMSPlugin lmsPlugin, Client client, LMSPlugin.FloorItem floorItem) {
        super(image, lmsPlugin);
        this.client = client;
        this.plugin = lmsPlugin;
        this.floorItem = floorItem;
    }

    @Override
    public String getText() {
        WorldPoint playerLoc = client.getLocalPlayer().getWorldLocation();
        int bearing = LMSUtil.bearing(playerLoc, floorItem.getTile().getWorldLocation());
        return bearing + "Â°";
    }

    @Override
    public Color getTextColor() {
        WorldPoint playerLoc = client.getLocalPlayer().getWorldLocation();
        int dist = playerLoc.distanceTo2D(floorItem.getTile().getWorldLocation());
        double proportion = Math.min(40, dist) / 40.0;
        return new Color(ColourUtil.interpolateBetweenRgbs(0x00FF00, 0xFF0000, proportion));
    }
}

package com.lmsnotifier;

import com.google.inject.Inject;
import net.runelite.api.Client;
import net.runelite.api.ItemContainer;
import net.runelite.api.ItemID;
import net.runelite.api.events.ItemDespawned;
import net.runelite.api.events.ItemSpawned;
import net.runelite.client.game.ItemManager;

import java.util.Arrays;
import java.util.HashSet;
import java.util.Iterator;
import java.util.Set;

public class ItemUpgrade {

    private final Client client;
    private final LMSConfig config;
    private final LMSPlugin plugin;
    private ItemManager itemManager;

    @Inject
    private ItemUpgrade(Client client, LMSConfig config, LMSPlugin plugin, ItemManager itemManager) {
        this.client = client;
        this.config = config;
        this.plugin = plugin;
        this.itemManager = itemManager;
    }

    private static final Set<Integer> ignoreIds;
    static {
        ignoreIds = new HashSet<>(Arrays.asList(
                ItemID.OPAL_DRAGON_BOLTS_E_27192,
                ItemID.BONES,
                ItemID.DIAMOND_BOLTS_E_23649,
                ItemID.AHRIMS_STAFF_23653,
                ItemID.ANCIENT_STAFF_20431,
                ItemID.DRAGON_DAGGER_20407,
                ItemID.MYSTIC_ROBE_BOTTOM_20426,
                ItemID.MYSTIC_ROBE_BOTTOM_DARK_27159,
                ItemID.MYSTIC_ROBE_BOTTOM_LIGHT_27161,
                ItemID.MYSTIC_ROBE_TOP_20425,
                ItemID.MYSTIC_ROBE_TOP_DARK_27158,
                ItemID.MYSTIC_ROBE_TOP_LIGHT_27160,
                ItemID.CLIMBING_BOOTS_20578,
                ItemID.SPIRIT_SHIELD_23599,
                ItemID.RUNE_CROSSBOW_23601,
                ItemID.GHOSTLY_HOOD_27166,
                ItemID.GHOSTLY_ROBE_27167,
                ItemID.GHOSTLY_ROBE_27168,
                ItemID.IMBUED_GUTHIX_CAPE_23603,
                ItemID.IMBUED_ZAMORAK_CAPE_23605,
                ItemID.IMBUED_SARADOMIN_CAPE_23607,
                ItemID.RUNE_PLATELEGS_20422,
                ItemID.BLACK_DHIDE_BODY_20423,
                ItemID.SANFEW_SERUM4_23559,
                ItemID.SANFEW_SERUM3_23561,
                ItemID.SANFEW_SERUM2_23563,
                ItemID.SANFEW_SERUM1_23565,
                ItemID.SHARK_20390,
                ItemID.BERSERKER_RING_23595,
                ItemID.HELM_OF_NEITIZNOT_23591,
                ItemID.ABYSSAL_WHIP_20405,
                ItemID.AMULET_OF_GLORY_20586,
                ItemID.DRAGON_ARROW_20389,
                ItemID.TOME_OF_FIRE_27358,
                ItemID.ATLATL_DART_29852,
                ItemID.ROPE_20587
        ));
    }

    // set of item ids that player has had access to during this game.
    final Set<Integer> foundItems = new HashSet<>();

    public boolean notifyItem(ItemSpawned itemSpawned, ItemContainer inv, ItemContainer equip) {
        int id = itemSpawned.getItem().getId();

        if (ignoreIds.contains(id) || foundItems.contains(id) || plugin.floorItems.stream().anyMatch(itemSpawned1 -> itemSpawned1.getTileItem().getId() == id)) {
            return false;
        }

        if (id == ItemID.MORRIGANS_JAVELIN_23619 && itemSpawned.getItem().getQuantity() < 5) {
            return false;
        }

        if (has(id, inv, equip)) {
            return false;
        }
        return true;
    }

    private boolean has(int id, ItemContainer inv, ItemContainer equip) {
        return inv.contains(id) || equip.contains(id);
    }

    public void droppedItem(int itemId) {
        foundItems.add(itemId);
        Iterator<LMSPlugin.FloorItem> it = plugin.floorItems.iterator();
        while (it.hasNext()) {
            LMSPlugin.FloorItem floorItem = it.next();
            if (floorItem.getTileItem().getId() == itemId) {
                plugin.infoBoxManager.removeInfoBox(floorItem.getInfoBox());
                it.remove();
            }
        }
    }

    public void despawn(ItemDespawned event) {
        Iterator<LMSPlugin.FloorItem> it = plugin.floorItems.iterator();
        while (it.hasNext()) {
            LMSPlugin.FloorItem floorItem = it.next();
            if (floorItem.getTileItem() == event.getItem() || floorItem.getTile() == event.getTile()) {
                plugin.infoBoxManager.removeInfoBox(floorItem.getInfoBox());
                it.remove();
            }
        }
    }
}

package com.lmsnotifier;

import net.runelite.client.config.*;

import java.awt.*;

@ConfigGroup(LMSPlugin.CONFIG_GROUP_KEY)
public interface LMSConfig extends Config
{

	@ConfigItem(
			keyName = "overlayKillDeaths",
			name = "Overlay kills/deaths",
			description = "3-0 means 3 kills and 0 deaths",
			position = 1
	)
	default boolean overlayKillDeaths()
	{
		return true;
	}

	@ConfigItem(
			keyName = "fightResultInChat",
			name = "Chatbox fight outcome",
			description = "Display name of opponent you defeated / got killed by",
			position = 2
	)
	default boolean fightResultInChat()
	{
		return true;
	}

	@ConfigItem(
		keyName = "notifyGameStart",
		name = "Game Start Notification",
		description = "Notifies you when LMS starts",
		position = 3
	)
	default boolean notifiesGameStart()
	{
		return true;
	}

	@ConfigSection(
		name = "Chests",
		description = "Chest highlighting options",
		position = 4,
		closedByDefault = false
	)
	String chestList = "chestList";

	@ConfigItem(
		keyName = "highlightChests",
		name = "Highlight",
		description = "When to highlight chests",
		section = chestList,
		position = 0
	)
	default ChestHightlight highlightChests()
	{
		return ChestHightlight.HAS_KEY;
	}

	@ConfigItem(
		keyName = "highlightChestsType",
		name = "Highlight Type",
		description = "Tile, Hull, or Clickbox highlight for chests",
		section = chestList,
		position = 1
	)
	default ChestHightlightType highlightChestType()
	{
		return ChestHightlightType.CLICK_BOX;
	}

	@ConfigItem(
		keyName = "chestColour",
		name = "Colour",
		description = "Chest highlight colour",
		section = chestList,
		position = 2
	)
	default Color chestColour()
	{
		return Color.CYAN;
	}

	@Range(
		min = 1,
		max = 50
	)
	@ConfigItem(
		keyName = "chestRadius",
		name = "Radius",
		description = "Radius of squares to highlight chests within",
		section = chestList,
		position = 3
	)
	default int chestRadius()
	{
		return 25;
	}

	@ConfigSection(
		name = "Loot Crates",
		description = "Loot Crate highlighting options",
		position = 5,
		closedByDefault = false
	)
	String lootCrateList = "lootCrateList";

	@ConfigItem(
		keyName = "lootCrateHighlight",
		name = "Highlight",
		description = "Options for highlighting loot crates",
		section = lootCrateList,
		position = 0
	)
	default LootCrateHightlight lootCrateHighlightType()
	{
		return LootCrateHightlight.CLICK_BOX;
	}

	@ConfigItem(
		keyName = "lootCrateColour",
		name = "Colour",
		description = "Loot Crate highlight colour",
		section = lootCrateList,
		position = 1
	)
	default Color lootCrateColour()
	{
		return Color.GREEN;
	}

	@Range(
		min = 1,
		max = 50
	)
	@ConfigItem(
		keyName = "lootCrateRadius",
		name = "Radius",
		description = "Radius of squares to highlight loot crates within",
		section = lootCrateList,
		position = 2
	)
	default int lootCrateRadius()
	{
		return 25;
	}


	@ConfigSection(
		name = "Player Ranks",
		description = "Show Lms ranks/scores of players",
		position = 6,
		closedByDefault = false
	)
	String playerRanks = "playerRanks";

	@ConfigItem(
		keyName = "showPlayerRank",
		name = "Rank Visual",
		description = "Options for displaying other players lms rank",
		section = playerRanks,
		position = 0
	)
	default RankVisual rankVisual()
	{
		return RankVisual.NONE;
	}

	@ConfigItem(
		keyName = "metricColour",
		name = "Text Colour",
		description = "Colour of the metric text",
		section = playerRanks,
		position = 1
	)
	default Color metricColour()
	{
		return Color.RED;
	}

	@ConfigItem(
		keyName = "metricHeatmap",
		name = "Heatmap",
		description = "Colour metrics differently based on score",
		section = playerRanks,
		position = 2
	)
	default boolean metricHeatmap()
	{
		return true;
	}

	@ConfigItem(
		keyName = "rankMetric",
		name = "Metric",
		description = "Display the LMS Score or Rank of players",
		section = playerRanks,
		position = 3
	)
	default RankMetric rankMetric()
	{
		return RankMetric.SCORE;
	}

	@ConfigSection(
			name = "Bot Detection",
			description = "Options for showing potential bots",
			position = 7,
			closedByDefault = false
	)
	String botDetection = "botDetection";


	@ConfigItem(
			keyName = "showBots",
			name = "Text Overlay",
			description = "Shows players who might be bots",
			section = botDetection,
			position = 1
	)
	default BotDisplay getBotDisplay()
	{
		return BotDisplay.BOTS_ONLY;
	}

	@ConfigItem(
			keyName = "summarizeBots",
			name = "Summarize bots",
			description = "Displays the number of humans/bots encountered at the end of the game",
			section = botDetection,
			position = 2
	)
	default boolean summarizeBots()
	{
		return true;
	}

	@ConfigItem(
			keyName = "botsInChat",
			name = "Add bots to chat",
			description = "Displays names of bots detected in the game chat",
			section = botDetection,
			position = 3
	)
	default boolean putNamesInChat()
	{
		return false;
	}


	@ConfigItem(
			keyName = "showLobbySummary",
			name = "Show Lobby Summary",
			description = "Categorizes players in the lobby based on rank, combat level, and marked sweats",
			position = 8
	)
	default boolean getLobbySummary()
	{
		return false;
	}

	@ConfigItem(
			keyName = "showSweats",
			name = "Show Sweats",
			description = "Shows sweaty players you've previously marked",
			position = 9
	)
	default boolean getSweatDisplay()
	{
		return false;
	}

	@ConfigItem(
			keyName = "autoMarkSweats",
			name = "Auto Mark Sweats",
			description = "Automatically marks terminator bots based on stats as sweats",
			position = 10
	)
	default boolean autoMarkSweats()
	{
		return true;
	}

	@ConfigItem(
			keyName = "showUpgrades",
			name = "Show Upgrades",
			description = "Adds info box and directions to upgrades on the floor in game chat",
			position = 11
	)
	default boolean showUpgrades()
	{
		return true;
	}
}
package com.lmsnotifier;

import com.google.common.cache.Cache;
import com.google.common.cache.CacheBuilder;
import lombok.extern.slf4j.Slf4j;
import net.runelite.client.hiscore.*;
import net.runelite.client.util.Text;

import javax.inject.Inject;
import java.util.concurrent.TimeUnit;

@Slf4j
class LMSHiscores
{
	@Inject
	private HiscoreManager hiscoreManager;

	@Inject
	private LMSConfig config;

	private final Cache<String, LMSRank> cache = CacheBuilder.newBuilder().initialCapacity(30).maximumSize(2000).expireAfterAccess(60, TimeUnit.MINUTES).build();

	LMSRank getRankFor(String username, SweatTracker sweatTracker)
	{
		final String name = Text.sanitize(username);
		LMSRank cachedRank = cache.getIfPresent(name);
		if (cachedRank != null) {
			return cachedRank;
		}
		log.debug("Looking up hiscores for {}", username);
		final HiscoreEndpoint endPoint = HiscoreEndpoint.NORMAL;
		HiscoreResult result = hiscoreManager.lookupAsync(name, endPoint);
		if (result != null) {
			Skill hiscoreSkill = result.getSkill(HiscoreSkill.LAST_MAN_STANDING);
			int score = hiscoreSkill.getLevel();
			int rank = hiscoreSkill.getRank();
			if (config.autoMarkSweats() && !sweatTracker.isSweat(name) && sweatTracker.botCriteriaCount(result) >= 8) {
				sweatTracker.markPlayer(name);
			}
			log.debug("Retrieved hiscores for {} {} {}", username, rank, score);
			LMSRank lmsRank = new LMSRank(rank, score);
			cache.put(name, lmsRank);
			return lmsRank;
		}
		return null;
	}

//	private boolean botCheck(String name, HiscoreResult result) {
//		return botCriteriaCount(result) >= 9;
//
//		System.out.println(name + ": " + criteriaMet);
//		try {
//			BufferedWriter out = new BufferedWriter(new FileWriter("./bots.txt", true));
//			if (criteriaMet >= 10) {
//				out.write(name + ":BOT:" + getSkills(result) + "\n");
//			} else {
//				out.write(name + ":pBOT:" + getSkills(result) + "\n");
//			}
//			out.close();
//		} catch (IOException e) {
//			e.printStackTrace();
//		}
//	}
//
//	private static String getSkills(HiscoreResult r) {
//		StringBuilder sb = new StringBuilder();
//		for (Map.Entry<HiscoreSkill, Skill> entry : r.getSkills().entrySet()) {
//			HiscoreSkill hiscoreSkill = entry.getKey();
//			Skill skill = entry.getValue();
//			if (skill.getLevel() < 0)
//				continue;
//			sb.append(hiscoreSkill.getName()).append(":").append(skill.getLevel()).append("\n");
//		}
//		return sb.toString();
//	}
}

package com.lmsnotifier;

import net.runelite.api.Client;
import net.runelite.api.GameObject;
import net.runelite.api.Point;
import net.runelite.api.TileObject;
import net.runelite.api.coords.LocalPoint;
import net.runelite.client.ui.overlay.*;
import net.runelite.client.util.ColorUtil;

import javax.inject.Inject;
import java.awt.*;

class LMSOverlay extends Overlay
{
	private static final int MIN_SCORE = 500;
	private static final int MAX_SCORE = 3_000;
	private final Client client;
	private final LMSConfig config;
	private final LMSPlugin plugin;

	@Inject
	private LMSOverlay(Client client, LMSConfig config, LMSPlugin plugin)
	{
		this.client = client;
		this.config = config;
		this.plugin = plugin;
		setPosition(OverlayPosition.DYNAMIC);
		setPriority(OverlayPriority.LOW);
		setLayer(OverlayLayer.ABOVE_SCENE);
	}

	@Override
	public Dimension render(Graphics2D graphics)
	{
		if (plugin.preLobby || plugin.inLobby) {
			renderLobby(graphics);
			return null;
		}
		if (!plugin.inGame)
		{
			return null;
		}

		if (plugin.highlightChests())
		{
			renderChests(graphics);
		}

		if (plugin.highlightLootCrates())
		{
			renderLootCrates(graphics);
		}

		if (!config.rankVisual().equals(RankVisual.NONE))
		{
			renderRanks(graphics);
		}

		if (config.getBotDisplay() != BotDisplay.NONE)
		{
			renderBots(graphics);
		}

		if (config.getSweatDisplay())
		{
			renderSweats(graphics);
		}

		if (config.overlayKillDeaths())
		{
			renderKillDeaths(graphics);
		}

		return null;
	}

	private void renderSweats(Graphics2D graphics) {
		for (LMSPlayer lmsPlayer : plugin.localLMSPlayers)
		{
			if (!plugin.sweatTracker.isSweat(lmsPlayer.player)) {
				continue;
			}

			Point textLocation = lmsPlayer.player.getCanvasTextLocation(graphics, "Sweat", 0);
			if (textLocation != null)
			{
				OverlayUtil.renderTextLocation(graphics, new Point(textLocation.getX(), textLocation.getY() + 36), "Sweat", Color.ORANGE);
			}
		}
	}

	private void renderLobby(Graphics2D graphics) {
		if (!config.rankVisual().equals(RankVisual.NONE))
		{
			renderRanks(graphics);
		}

		if (config.overlayKillDeaths())
		{
			renderKillDeaths(graphics);
		}

		for (LMSPlayer lmsPlayer : plugin.localLMSPlayers) {
			DeathTracker.KD kd = plugin.deathTracker.getKD(lmsPlayer.player.getName());
			if (kd.kills <= 0 && kd.deaths <= 0) {
				continue;
			}
			String text = kd.kills + "-" + kd.deaths;
			Point textLocation = lmsPlayer.player.getCanvasTextLocation(graphics, text, 0);
			if (textLocation != null)
			{
				OverlayUtil.renderTextLocation(graphics, new Point(textLocation.getX(), textLocation.getY() + 12), text, Color.WHITE);
			}
		}
	}

	private void renderKillDeaths(Graphics2D graphics) {
        for (LMSPlayer lmsPlayer : plugin.localLMSPlayers) {
            DeathTracker.KD kd = plugin.deathTracker.getKD(lmsPlayer.player.getName());
            if (kd.kills <= 0 && kd.deaths <= 0) {
                continue;
            }
            String text = kd.kills + "-" + kd.deaths;
            Point textLocation = lmsPlayer.player.getCanvasTextLocation(graphics, text, 0);
            if (textLocation != null)
            {
                OverlayUtil.renderTextLocation(graphics, new Point(textLocation.getX(), textLocation.getY() + 12), text, Color.WHITE);
            }
        }
    }

	private void renderBots(Graphics2D graphics) {
		for (LMSPlayer lmsPlayer : plugin.localLMSPlayers)
		{
			BotIdentification.Status status = plugin.botIdentification.statusFor(lmsPlayer.player.getName());
			if (config.getBotDisplay() == BotDisplay.BOTS_ONLY && status != BotIdentification.Status.BOT) {
				continue;
			}
			Color color;
			String text;
			switch (status) {
				case BOT:
					color = Color.RED;
					text = "Bot";
					break;
				case HUMAN:
					color = Color.GREEN;
					text = "Human";
					break;
				case UNSURE:
				default:
					color = Color.WHITE;
					text = "?";
					break;
			}
			Point textLocation = lmsPlayer.player.getCanvasTextLocation(graphics, text, 0);
			if (textLocation != null)
			{
				OverlayUtil.renderTextLocation(graphics, new Point(textLocation.getX(), textLocation.getY() + 24), text, color);
			}
		}
	}

	private void renderRanks(Graphics2D graphics)
	{
		for (LMSPlayer lmsPlayer : plugin.localLMSPlayers)
		{
			Color colour;
			if (config.metricHeatmap())
			{
				int clampedScore = Math.max(MIN_SCORE, Math.min(lmsPlayer.lmsRank.score, MAX_SCORE));
				double proportion = (double) (clampedScore - MIN_SCORE) / (MAX_SCORE - MIN_SCORE);
				colour = new Color(ColourUtil.interpolateBetweenRgbs(0x00FF00, 0xFF0000, proportion));
			}
			else
			{
				colour = config.metricColour();
			}
			String text = "";
			if (config.rankMetric().equals(RankMetric.RANK))
			{
				text = lmsPlayer.lmsRank.rank < 0 ? "n/a" : Integer.toString(lmsPlayer.lmsRank.rank);
			}
			else if (config.rankMetric().equals(RankMetric.SCORE))
			{
				text = lmsPlayer.lmsRank.score < 0 ? "n/a" : Integer.toString(lmsPlayer.lmsRank.score);
			}
			Point textLocation = lmsPlayer.player.getCanvasTextLocation(graphics, text, 0);
			if (textLocation != null)
			{
				OverlayUtil.renderTextLocation(graphics, textLocation, text, colour);
			}
		}
	}

	private void renderLootCrates(Graphics2D graphics)
	{
		int max = config.lootCrateRadius() * config.lootCrateRadius() * 128 * 128;
		LocalPoint playerLocation = client.getLocalPlayer().getLocalLocation();
		for (TileObject object : plugin.lootCrates.values())
		{
			if (LMSUtil.distSquared(object.getLocalLocation(), playerLocation) >= max)
			{
				continue;
			}

			if (config.lootCrateHighlightType().equals(LootCrateHightlight.CLICK_BOX))
			{
				Shape shape = object.getClickbox();
				if (shape != null)
				{
					Color color = config.lootCrateColour();
					Color clickBoxColor = ColorUtil.colorWithAlpha(color, color.getAlpha() / 12);

					graphics.setColor(color);
					graphics.draw(shape);
					graphics.setColor(clickBoxColor);
					graphics.fill(shape);
				}
			}
			else if (config.lootCrateHighlightType().equals(LootCrateHightlight.TILE))
			{
				Shape shape = object.getCanvasTilePoly();
				if (shape != null)
				{
					OverlayUtil.renderPolygon(graphics, shape, config.lootCrateColour());
				}
			}
			else if (config.lootCrateHighlightType().equals(LootCrateHightlight.HULL))
			{
				Shape shape = ((GameObject) object).getConvexHull();
				if (shape != null)
				{
					OverlayUtil.renderPolygon(graphics, shape, config.lootCrateColour());
				}
			}
		}
	}

	private void renderChests(Graphics2D graphics)
	{
		int max = config.chestRadius() * config.chestRadius() * 128 * 128;
		LocalPoint playerLocation = client.getLocalPlayer().getLocalLocation();
		for (TileObject object : plugin.chests.values())
		{
			if (object.getPlane() != client.getPlane())
			{
				continue;
			}
			if (LMSUtil.distSquared(object.getLocalLocation(), playerLocation) >= max)
			{
				continue;
			}

			if (config.highlightChestType().equals(ChestHightlightType.CLICK_BOX))
			{
				Shape shape = object.getClickbox();
				if (shape != null)
				{
					Color color = config.chestColour();
					Color clickBoxColor = ColorUtil.colorWithAlpha(color, color.getAlpha() / 12);

					graphics.setColor(color);
					graphics.draw(shape);
					graphics.setColor(clickBoxColor);
					graphics.fill(shape);
				}
			}
			else if (config.highlightChestType().equals(ChestHightlightType.TILE))
			{
				Shape shape = object.getCanvasTilePoly();
				if (shape != null)
				{
					OverlayUtil.renderPolygon(graphics, shape, config.chestColour());
				}
			}
			else if (config.highlightChestType().equals(ChestHightlightType.HULL))
			{
				Shape shape = ((GameObject) object).getConvexHull();
				if (shape != null)
				{
					OverlayUtil.renderPolygon(graphics, shape, config.chestColour());
				}
			}
		}
	}
}

package com.lmsnotifier;

import net.runelite.api.Client;
import net.runelite.api.Player;
import net.runelite.client.ui.overlay.OverlayPanel;
import net.runelite.client.ui.overlay.OverlayPosition;
import net.runelite.client.ui.overlay.components.LineComponent;
import net.runelite.client.ui.overlay.components.TitleComponent;

import javax.inject.Inject;
import java.awt.*;

public class LMSOverlay2D extends OverlayPanel {
    private final Client client;
    private final LMSConfig config;
    private final LMSPlugin plugin;

    @Inject
    private LMSOverlay2D(Client client, LMSConfig config, LMSPlugin plugin)
    {
        this.client = client;
        this.config = config;
        this.plugin = plugin;
        this.setPosition(OverlayPosition.BOTTOM_LEFT);
    }

    @Override
    public Dimension render(Graphics2D graphics)
    {
        if (!plugin.preLobby && !plugin.inLobby || !config.getLobbySummary()) {
            return null;
        }

        int botCbRangeCnt = 0;
        int historicLosses = 0;
        int highRankCnt = 0;
        int highCbLvl = 0;
        int sweats = 0;

        final int RANK_CAP = 6000;
        final int MIN_BOT_CB = 40;
        final int MAX_BOT_CB = 59;
        final int HIGH_CB = 90;

        for (Player p : client.getPlayers()) {
            if (p.getWorldLocation().distanceTo(LMSPlugin.lmsCompetitiveLobby) != 0) {
                continue;
            }
            String name = p.getName();
            if (client.getLocalPlayer().getName() != null && client.getLocalPlayer().getName().equals(name)) {
                continue;
            }

            if (p.getCombatLevel() >= HIGH_CB) {
                highCbLvl++;
            }

            DeathTracker.KD kd = plugin.deathTracker.getKD(p.getName());
            if (kd.deaths != 0 && kd.deaths >= kd.kills) {
                historicLosses++;
            }

            if (p.getCombatLevel() >= MIN_BOT_CB && p.getCombatLevel() <= MAX_BOT_CB) {
                botCbRangeCnt++;
            }

            if (plugin.sweatTracker.isSweat(p)) {
                sweats++;
            }
        }

        for (LMSPlayer p : plugin.localLMSPlayers) {
            if (p.player.getCombatLevel() >= MIN_BOT_CB && p.player.getCombatLevel() <= MAX_BOT_CB) {
//                botCbRangeCnt++;
            } else if (p.lmsRank.score > RANK_CAP) {
                highRankCnt++;
            }
        }

        panelComponent.getChildren().add(TitleComponent.builder().text("Lobby Summary").build());

        panelComponent.getChildren().add(LineComponent.builder().left("Bot Cb Range ("+MIN_BOT_CB+"-"+MAX_BOT_CB+"):").right(Integer.toString(botCbRangeCnt)).build());
        panelComponent.getChildren().add(LineComponent.builder().left("Prev deaths:").right(Integer.toString(historicLosses)).build());
        panelComponent.getChildren().add(LineComponent.builder().left("High Rank ("+RANK_CAP+"+):").right(Integer.toString(highRankCnt)).build());
        panelComponent.getChildren().add(LineComponent.builder().left("High Cb ("+HIGH_CB+"+):").right(Integer.toString(highCbLvl)).build());
        if (config.getSweatDisplay()) {
            panelComponent.getChildren().add(LineComponent.builder().left("Sweats:").right(Integer.toString(sweats)).build());
        }

        return super.render(graphics);
    }
}

package com.lmsnotifier;

import lombok.AllArgsConstructor;
import net.runelite.api.Player;

@AllArgsConstructor
class LMSPlayer
{
	final Player player;
	final LMSRank lmsRank;
}

package com.lmsnotifier;

import com.google.common.collect.ImmutableSet;
import com.google.inject.Provides;
import lombok.Data;
import lombok.Getter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.*;
import net.runelite.api.coords.LocalPoint;
import net.runelite.api.coords.WorldArea;
import net.runelite.api.coords.WorldPoint;
import net.runelite.api.events.*;
import net.runelite.api.widgets.InterfaceID;
import net.runelite.api.widgets.WidgetUtil;
import net.runelite.client.Notifier;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.events.ClientShutdown;
import net.runelite.client.events.ConfigChanged;
import net.runelite.client.game.ItemManager;
import net.runelite.client.menus.MenuManager;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.plugins.PluginDescriptor;
import net.runelite.client.ui.overlay.OverlayManager;
import net.runelite.client.ui.overlay.infobox.InfoBox;
import net.runelite.client.ui.overlay.infobox.InfoBoxManager;
import net.runelite.client.util.Text;

import javax.inject.Inject;
import javax.inject.Provider;
import java.util.*;
import java.util.concurrent.CompletableFuture;

@Slf4j
@PluginDescriptor(
        name = "Last Man Standing"
)
public class LMSPlugin extends Plugin {
    private static final String MARK = "Mark";
    static final String CONFIG_GROUP_KEY = "lmsconfig";
    private static final int LOOT_CRATE = ObjectID.CRATE_29081;
    private static final WorldArea inFrontCompLobby = new WorldArea(3141, 3638, 2, 1, 0);
    static final WorldArea lmsCompetitiveLobby = new WorldArea(3138, 3639, 8, 7, 0);
    private static final WorldArea lmsCasualLobby = new WorldArea(3139, 3639, 6, 6, 1);
    private static final WorldArea lmsHighStakesLobby = new WorldArea(3138, 3639, 8, 7, 2);
    private static final Set<Integer> chestIds = ImmutableSet.of(ObjectID.CHEST_29069, ObjectID.CHEST_29072);
    static final int FEROX_REGION_ID = 12600;
    boolean inGame = false;
    Map<WorldPoint, TileObject> chests = new HashMap<>();
    Map<WorldPoint, TileObject> lootCrates = new HashMap<>();
    List<LMSPlayer> localLMSPlayers = new LinkedList<>();
    boolean inLobby = false;
    boolean preLobby = false;

    @Inject
    private LMSHiscores lmsHiscores;

    @Inject
    @Getter
    private Client client;

    @Inject
    @Getter
    private LMSConfig config;

    @Inject
    private Notifier notifier;

    @Inject
    private OverlayManager overlayManager;

    @Inject
    private LMSOverlay overlay;

    @Inject
    private LMSOverlay2D overlay2d;

    @Inject
	DeathTracker deathTracker;

    @Inject
    SweatTracker sweatTracker;

    @Inject
    BotIdentification botIdentification;

    @Inject
    ItemUpgrade itemUpgrade;

    @Inject
    private ItemManager itemManager;

    @Inject
    public InfoBoxManager infoBoxManager;

    @Inject
    private Provider<MenuManager> menuManager;

    public final List<FloorItem> floorItems = new ArrayList<>();

    @Data
    public static final class FloorItem {

        TileItem tileItem;
        Tile tile;
        InfoBox infoBox;

        public FloorItem(TileItem tileItem, Tile tile) {
            this.tileItem = tileItem;
            this.tile = tile;
        }
    }

    @Override
    protected void startUp() throws Exception {
        log.info("Lms Notifier started!");
        overlayManager.add(overlay);
        overlayManager.add(overlay2d);
        deathTracker.load();
        sweatTracker.load();
    }

    public void itemReset() {
        itemUpgrade.foundItems.clear();
        for (LMSPlugin.FloorItem floorItem : floorItems) {
            infoBoxManager.removeInfoBox(floorItem.getInfoBox());
        }
        floorItems.clear();
    }

    @Override
    protected void shutDown() throws Exception {
        log.info("Lms Notifier stopped!");
        overlayManager.remove(overlay);
        overlayManager.remove(overlay2d);
        deathTracker.save();
        sweatTracker.save();
        itemReset();
        if (client != null)
        {
            menuManager.get().removePlayerMenuItem(MARK);
        }
    }

    @Subscribe
    public void onClientShutdown(ClientShutdown event) {
        CompletableFuture<Void> future = CompletableFuture.runAsync(deathTracker::save);
        event.waitFor(future);
        CompletableFuture<Void> future2 = CompletableFuture.runAsync(sweatTracker::save);
        event.waitFor(future2);
    }

    @Subscribe
    public void onItemDespawned(ItemDespawned event) {
        itemUpgrade.despawn(event);
    }

    @Subscribe
    public void onItemSpawned(ItemSpawned event) {
        if (!inGame || client.getLocalPlayer().getWorldLocation().getRegionID() == FEROX_REGION_ID) {
            return;
        }

        if (!itemUpgrade.notifyItem(event, client.getItemContainer(InventoryID.INVENTORY), client.getItemContainer(InventoryID.EQUIPMENT))) {
            return;
        }

        WorldPoint itemLoc = event.getTile().getWorldLocation();
        WorldPoint playerLoc = client.getLocalPlayer().getWorldLocation();

        int dist = playerLoc.distanceTo2D(itemLoc);
        if (dist == 0) {
            itemUpgrade.droppedItem(event.getItem().getId());
            // likely spawned from full inv when opening chest
            return;
        }

        LMSPlugin.FloorItem floorItem = new LMSPlugin.FloorItem(event.getItem(), event.getTile());
        floorItems.add(floorItem);
        addInfoBox(floorItem);
    }

    private void addInfoBox(FloorItem floorItem) {
        if (!config.showUpgrades()) {
            return;
        }

        floorItem.infoBox = new FloorInfoBox(itemManager.getImage(floorItem.getTileItem().getId()), this, client, floorItem);
        infoBoxManager.addInfoBox(floorItem.getInfoBox());
    }

    @Subscribe
    public void onGameStateChanged(GameStateChanged event) {
        if (event.getGameState() != GameState.LOADING) {
            return;
        }

        chests.clear();
        lootCrates.clear();
        if (inLobby && config.notifiesGameStart()) {
            notifier.notify("Last Man Standing has started!");
        }
    }

    @Subscribe
    public void onInteractingChanged(InteractingChanged event) {
        if (!inGame || client.getLocalPlayer().getWorldLocation().getRegionID() == FEROX_REGION_ID) {
            return;
        }
        if (event.getSource() instanceof Player && event.getTarget() instanceof Player) {
            Player s = (Player) event.getSource();
            Player t = (Player) event.getTarget();
            botIdentification.interaction(s, t);
			deathTracker.interactChanged(s, t);
        }
    }

	@Subscribe
	public void onAnimationChanged(AnimationChanged event) {
		if (!inGame || client.getLocalPlayer().getWorldLocation().getRegionID() == FEROX_REGION_ID) {
			return;
		}
		deathTracker.animationChanged(event.getActor());
	}

    @Subscribe
    public void onGameTick(GameTick event) {
        boolean inLmsArea = inLobby || preLobby;
        inLobby = client.getLocalPlayer().getWorldLocation().distanceTo(lmsCompetitiveLobby) == 0
                || client.getLocalPlayer().getWorldLocation().distanceTo(lmsCasualLobby) == 0
                || client.getLocalPlayer().getWorldLocation().distanceTo(lmsHighStakesLobby) == 0;
        preLobby = client.getLocalPlayer().getWorldLocation().distanceTo(inFrontCompLobby) == 0;
        refreshNearbyPlayerRanks();
        botIdentification.tick();

        if (config.getSweatDisplay() && inLmsArea && !(inLobby || preLobby)) {
            // Was in lms, now left. Remove mark option
            menuManager.get().removePlayerMenuItem(MARK);
        } else if (config.getSweatDisplay() && !inLmsArea && (inLobby || preLobby)) {
            // Was not in lms, now in lms. Add mark option
            menuManager.get().removePlayerMenuItem(MARK);
            menuManager.get().addPlayerMenuItem(MARK);
        }
    }

    @Subscribe
    public void onConfigChanged(ConfigChanged event) {
        if (!event.getGroup().equals(CONFIG_GROUP_KEY)) {
            return;
        }

        if (client != null)
        {
            menuManager.get().removePlayerMenuItem(MARK);
            if (config.getSweatDisplay())
            {
                menuManager.get().addPlayerMenuItem(MARK);
            }

            if (!config.showUpgrades()) {
                itemReset();
            }
        }
    }

    @Subscribe
    public void onMenuEntryAdded(MenuEntryAdded event)
    {
        if ((event.getType() != MenuAction.CC_OP.getId() && event.getType() != MenuAction.CC_OP_LOW_PRIORITY.getId()) || !config.getSweatDisplay())
        {
            return;
        }

        final String option = event.getOption();
        final int componentId = event.getActionParam1();
        final int groupId = WidgetUtil.componentToInterface(componentId);

        if (groupId == InterfaceID.FRIEND_LIST && option.equals("Delete")
                || groupId == InterfaceID.FRIENDS_CHAT && (option.equals("Add ignore") || option.equals("Remove friend"))
                || groupId == InterfaceID.CHATBOX && (option.equals("Add ignore") || option.equals("Message"))
                || groupId == InterfaceID.IGNORE_LIST && option.equals("Delete")
        )
        {
            client.createMenuEntry(-2)
                    .setOption(MARK)
                    .setTarget(event.getTarget())
                    .setType(MenuAction.RUNELITE)
                    .setIdentifier(event.getIdentifier())
                    .onClick(e ->
                    {
                        String target = Text.removeTags(e.getTarget());
                        sweatTracker.markPlayer(Text.sanitize(target.toLowerCase()));
                    });
        }
    }

    @Subscribe
    public void onMenuOptionClicked(MenuOptionClicked event)
    {
        if (event.getMenuOption().equals("Drop")) {
            itemUpgrade.droppedItem(event.getItemId());
        }

        if (event.getMenuAction() == MenuAction.RUNELITE_PLAYER && event.getMenuOption().equals(MARK))
        {
            Player player = event.getMenuEntry().getPlayer();
            if (player == null)
            {
                return;
            }

            String target = player.getName();
            if (target != null) {
                sweatTracker.markPlayer(Text.sanitize(target.toLowerCase()));
            }
        }
    }

    private void refreshNearbyPlayerRanks() {
        if (!preLobby && !inLobby && !inGame || config.rankVisual().equals(RankVisual.NONE)) {
            localLMSPlayers.clear();
            return;
        }
        List<Player> players = new ArrayList<>(client.getPlayers());
        LocalPoint localPoint = client.getLocalPlayer().getLocalLocation();
        players.sort(Comparator.comparingInt(o -> LMSUtil.distSquared(o.getLocalLocation(), localPoint)));
        localLMSPlayers.clear();
        for (Player player : players) {
            if ((preLobby || inLobby) && player.getWorldLocation().distanceTo(lmsCompetitiveLobby) != 0) {
                continue;
            }
            String name = player.getName();
            if (client.getLocalPlayer().getName().equals(name)) {
                continue;
            }
            LMSRank lmsRank = lmsHiscores.getRankFor(name, sweatTracker);
            if (lmsRank != null) {
                localLMSPlayers.add(new LMSPlayer(player, lmsRank));
            }
        }
    }

    @Subscribe
    public void onWidgetClosed(WidgetClosed ev) {
        if (ev.getGroupId() == InterfaceID.LMS_INGAME) {
            inGame = false;
            chests.clear();
            lootCrates.clear();
            botIdentification.reset();
            itemReset();
            if (config.getSweatDisplay()) {
                menuManager.get().removePlayerMenuItem(MARK);
            }
        }
    }

    @Subscribe
    public void onWidgetLoaded(WidgetLoaded widgetLoaded) {
        if (widgetLoaded.getGroupId() == InterfaceID.LMS_INGAME) {
            inGame = true;
            if (config.getSweatDisplay()) {
                menuManager.get().addPlayerMenuItem(MARK);
            }
        }
    }

    @Provides
    LMSConfig provideConfig(ConfigManager configManager) {
        return configManager.getConfig(LMSConfig.class);
    }

    boolean highlightChests() {
        switch (config.highlightChests()) {
            case NEVER:
                return false;
            case HAS_KEY:
                ItemContainer inv = client.getItemContainer(InventoryID.INVENTORY);
                if (inv == null) {
                    return false;
                }
                return inv.contains(ItemID.BLOODY_KEY) || inv.contains(ItemID.BLOODIER_KEY);
            case ALWAYS:
            default:
                return true;
        }
    }

    @Subscribe
    public void onGameObjectSpawned(GameObjectSpawned event) {
        onTileObject(null, event.getGameObject());
    }

    @Subscribe
    public void onGameObjectDespawned(GameObjectDespawned event) {
        onTileObject(event.getGameObject(), null);
    }

    @Subscribe
    public void onGroundObjectSpawned(GroundObjectSpawned event) {
        onTileObject(null, event.getGroundObject());
    }

    @Subscribe
    public void onGroundObjectDespawned(GroundObjectDespawned event) {
        onTileObject(event.getGroundObject(), null);
    }

    private void onTileObject(TileObject oldObject, TileObject newObject) {
        if (oldObject != null) {
            WorldPoint oldLocation = oldObject.getWorldLocation();
            chests.remove(oldLocation);
            lootCrates.remove(oldLocation);
        }

        if (newObject == null) {
            return;
        }

        if (chestIds.contains(newObject.getId())) {
            chests.put(newObject.getWorldLocation(), newObject);
            return;
        }

        if (newObject.getId() == LOOT_CRATE) {
            lootCrates.put(newObject.getWorldLocation(), newObject);
        }
    }

    boolean highlightLootCrates() {
        return lootCrates.size() > 0 && !config.lootCrateHighlightType().equals(LootCrateHightlight.NONE);
    }
}

package com.lmsnotifier;

import lombok.AllArgsConstructor;

@AllArgsConstructor
class LMSRank
{
	final int rank;
	final int score;
}

package com.lmsnotifier;

import net.runelite.api.coords.LocalPoint;
import net.runelite.api.coords.WorldPoint;

class LMSUtil
{
	static int distSquared(LocalPoint point1, LocalPoint point2)
	{
		int dx = point1.getX() - point2.getX();
		int dy = point1.getY() - point2.getY();
		return dx * dx + dy * dy;
	}

	static int bearing(WorldPoint a, WorldPoint b) {
		int dx = b.getX() - a.getX();
		int dy = b.getY() - a.getY();
		double angle = Math.atan2(dy, dx);
		double bearing = 90 - Math.round(Math.toDegrees(angle));
		if (bearing < 0) {
			bearing += 360;
		}
		return (int) bearing;
	}
}

package com.lmsnotifier;

public enum LootCrateHightlight
{
	NONE,
	HULL,
	CLICK_BOX,
	TILE,
	;
}

package com.lmsnotifier;

import net.runelite.api.HeadIcon;
import net.runelite.api.Player;
import net.runelite.api.kit.KitType;

import java.util.Arrays;

public class PlayerSnapshot {
    final int[] equipment;
    final int animation;
    HeadIcon headIcon;
    HeadIcon opponentIcon;
    int opponentWeapon;
    final int tick;

    public PlayerSnapshot(Player player, Player opponent, int tick) {
        this.equipment = player.getPlayerComposition().getEquipmentIds();
        this.animation = player.getAnimation();
        this.headIcon = player.getOverheadIcon();
        this.tick = tick;
        if (opponent != null) {
            opponentIcon = opponent.getOverheadIcon();
            opponentWeapon = opponent.getPlayerComposition().getEquipmentId(KitType.WEAPON);
        }
    }

    public String toString() {
        return (headIcon == null ? "none" : headIcon.name()) + " a: " + animation + " e: " + Arrays.toString(equipment) + " " + (opponentIcon == null ? "none" : opponentIcon.name()) + " " + opponentWeapon;
    }
}

package com.lmsnotifier;

import lombok.extern.slf4j.Slf4j;
import net.runelite.api.ChatMessageType;
import net.runelite.api.HeadIcon;
import net.runelite.client.util.ColorUtil;

import java.awt.*;

@Slf4j
public class PlayerTracker {

    private static final int TOTAL = 500;

    private final LMSPlugin plugin;
    String name;
    PlayerSnapshot[] snapshots;
    int snapshotIndex;
    BotIdentification.Status status;
    String statusReason;

    PlayerTracker(String name, LMSPlugin plugin) {
        this.name = name;
        this.plugin = plugin;
        snapshots = new PlayerSnapshot[TOTAL];
        snapshotIndex = 0;
        status = null;
    }

    void addSnapshot(PlayerSnapshot snapshot) {
        if (snapshotIndex >= TOTAL)
            return;
        snapshots[snapshotIndex++] = snapshot;
    }

    public BotIdentification.Status getStatus() {
        if (status == null)
            return BotIdentification.Status.UNSURE;
        return status;
    }

    public void setStatus(BotIdentification.Status status, String reason) {
        this.status = status;
        this.statusReason = reason;
        log.debug("{} is a {} reason: {}", name, status, statusReason);
        if (plugin.getConfig().putNamesInChat() && status == BotIdentification.Status.BOT) {
            plugin.getClient().addChatMessage(ChatMessageType.GAMEMESSAGE, "", "Bot: " + ColorUtil.wrapWithColorTag(name, Color.RED), "");
        }
    }

    public void updateStatus() {
        if (status != null)
            return;
        int total = 0;
        int exact2t = 0;
        int exact1T = 0;
//        boolean whipSinceStart = true; // whether they haven't changed their weapon from whip when first seen
        for (int i = 1, n = snapshotIndex - 2; i < n; i++) {
            PlayerSnapshot prev = snapshots[i-1];
            PlayerSnapshot cur = snapshots[i];
            PlayerSnapshot next = snapshots[i+1];
            PlayerSnapshot next2 = snapshots[i+2];
//            if (cur.equipment[3] != 20917) {
//                whipSinceStart = false;
//            }
//            if (!whipSinceStart && cur.animation == 1658 && cur.equipment[3] == 20917) { // make sure they have whip on still cause anim plays for 2t
//                // bots never attack with whip except at start of the game sometimes
//                setStatus(BotIdentification.Status.HUMAN, "Attacked with whip");
//                return;
//            }
            if (prev.headIcon == null)
                continue;
            if (next2.tick - next.tick > 1) { // skip gaps where the player went out of tracking range
                i += 4;
                continue;
            }

            HeadIcon prevStyle = getStyleFor(prev.opponentWeapon);
            HeadIcon curStyle = getStyleFor(cur.opponentWeapon);
            HeadIcon nextStyle = getStyleFor(next.opponentWeapon);
            if (prevStyle != null && curStyle != null && nextStyle != null) {
                /*
                other player changed weapons
                bots see what is worn and then switch, this is guessing what is going to be switched to
                2nd check is to make sure they aren't acting on the switch 2 ticks ago,
                e.g. player does whip, bow, whip and it changes to pray melee on the 3rd tick because it saw whip on 1st
                */
                if (curStyle != nextStyle && next.headIcon == nextStyle && cur.headIcon != nextStyle && prevStyle != next.headIcon) {
                    setStatus(BotIdentification.Status.HUMAN, "Same tick switch");
                    return;
                }

                if (curStyle != prevStyle) { // other player changed weapons
                    if (next.headIcon != curStyle && next2.headIcon == curStyle) {
                        exact2t++;
                    } else if (next.headIcon == curStyle) {
                        exact1T++;
                    }
                    total++;
                }
            }
        }
        double proportion = (double) (exact1T + exact2t) / total;
        if (total > 3) {
            log.debug("{} 1t:{} 2t:{} total:{} {}%", name, exact1T, exact2t, total, String.format("%.2f", 100 * proportion));
        }
        if (total > 6) {
            if (proportion >= 0.85) {
                setStatus(BotIdentification.Status.BOT, "85%+ 2t switches"); // bots always do 1-2t prayer changes
            } else if (proportion < 0.5) {
                setStatus(BotIdentification.Status.HUMAN, "50%- 2t switches"); // bots always do 1-2t prayer changes
            }
        }
    }

    private HeadIcon getStyleFor(int weaponItemId) {
        switch (weaponItemId) {
            case 25517: // Volatile nightmare staff
            case 23626: // Kodai wand
            case 23617: // Zuriel's staff
            case 23653: // Ahrim's staff
            case 23613: // Staff of the dead
                return HeadIcon.MAGIC;
            case 20408: // Dark bow
            case 23630: // Heavy ballista
            case 23619: // Morrigan's javelin
            case 23611: // Armadyl crossbow
            case 23601: // Rune crossbow
                return HeadIcon.RANGED;
            case 23620: // Statius's warhammer
            case 23615: // Vesta's longsword
            case 20407: // Dragon dagger
            case 20405: // Abyssal whip
            case 25516: // Dharok's greataxe
            case 23628: // Ghrazi rapier
            default:
                return HeadIcon.MELEE;
        }
    }
}

package com.lmsnotifier;

public enum RankMetric
{
	SCORE,
	RANK,
	;
}

package com.lmsnotifier;

public enum RankVisual
{
	NONE,
	TEXT
}

package com.lmsnotifier;

import net.runelite.api.ChatMessageType;
import net.runelite.api.Client;
import net.runelite.api.Player;
import net.runelite.client.RuneLite;
import net.runelite.client.hiscore.HiscoreResult;
import net.runelite.client.hiscore.HiscoreSkill;
import net.runelite.client.util.Text;

import javax.inject.Inject;
import java.io.BufferedWriter;
import java.io.File;
import java.io.FileWriter;
import java.io.IOException;
import java.nio.file.Files;
import java.util.LinkedHashSet;
import java.util.Set;

public class SweatTracker {
    @Inject
    private Client client;

    private static final File SWEATS_FILE = new File(RuneLite.RUNELITE_DIR, "lms-sweats.txt");
    public Set<String> usernames = new LinkedHashSet<>();
    boolean requiresSave = false;

    public boolean isSweat(Player p) {
        if (p.getName() == null)
            return false;
        return isSweat(p.getName());
    }

    public boolean isSweat(String name) {
        return usernames.contains(Text.sanitize(name.toLowerCase()));
    }

    public void markPlayer(String name) {
        if (usernames.contains(name)) {
            usernames.remove(name);
            client.addChatMessage(ChatMessageType.GAMEMESSAGE, "", name + " unmarked as sweat for Last Man Standing.", "");
        } else {
            usernames.add(name);
            client.addChatMessage(ChatMessageType.GAMEMESSAGE, "", name + " marked as sweat for Last Man Standing.", "");
        }
        requiresSave = true;
    }


    /*
    Outdated
    Range 1
    Construction 16
    Herblore 52
    Crafting 43
    Fletching 60
    Hunter 1
    Mining 18 or 41
    Smithing 39
    Fishing 24
    Farming 9
    total level 750-760
     */
    public int botCriteriaCount(HiscoreResult r) {
        int criteriaMet = 0;
        /*
        Outdated
        Att/Str 40
        Construction 16-20
        Herblore 23-24
        Crafting 37-38
        Fletching 95+ or low fletching and high range
        Hunter 9/11
        Mining 40-46
        Smithing 40-41
        Fishing 24
        Farming 9
        RC 9
        FM 40
         */
        if (r.getSkill(HiscoreSkill.ATTACK).getLevel() == 40 &&
                r.getSkill(HiscoreSkill.STRENGTH).getLevel() == 40) {
            criteriaMet++;
        }
        if (r.getSkill(HiscoreSkill.CONSTRUCTION).getLevel() >= 14 && r.getSkill(HiscoreSkill.CONSTRUCTION).getLevel() <= 20) {
            criteriaMet++;
        }
        if (r.getSkill(HiscoreSkill.HERBLORE).getLevel() >= 23 && r.getSkill(HiscoreSkill.HERBLORE).getLevel() <= 27) {
            criteriaMet++;
        }
        if (r.getSkill(HiscoreSkill.CRAFTING).getLevel() >= 37 && r.getSkill(HiscoreSkill.CRAFTING).getLevel() <= 39) {
            criteriaMet++;
        }
        if (r.getSkill(HiscoreSkill.FLETCHING).getLevel() >= 95 || (r.getSkill(HiscoreSkill.FLETCHING).getLevel() < 20 && r.getSkill(HiscoreSkill.RANGED).getLevel() >= 80)) {
            criteriaMet++;
        }
        if (r.getSkill(HiscoreSkill.HUNTER).getLevel() == 9 || r.getSkill(HiscoreSkill.HUNTER).getLevel() == 13) {
            criteriaMet++;
        }
        if (r.getSkill(HiscoreSkill.MINING).getLevel() >= 40 && r.getSkill(HiscoreSkill.MINING).getLevel() <= 46) {
            criteriaMet++;
        }
        if (r.getSkill(HiscoreSkill.SMITHING).getLevel() >= 40 && r.getSkill(HiscoreSkill.SMITHING).getLevel() <= 41) {
            criteriaMet++;
        }
        if (r.getSkill(HiscoreSkill.FISHING).getLevel() == 24) {
            criteriaMet++;
        }
        if (r.getSkill(HiscoreSkill.FARMING).getLevel() == 9) {
            criteriaMet++;
        }
        if (r.getSkill(HiscoreSkill.FIREMAKING).getLevel() == 40) {
            criteriaMet++;
        }
        if (r.getSkill(HiscoreSkill.COOKING).getLevel() == 16) {
            criteriaMet++;
        }
        if (r.getSkill(HiscoreSkill.RUNECRAFT).getLevel() == 9) {
            criteriaMet++;
        }
        return criteriaMet;
    }

    public void load() {
        if (!SWEATS_FILE.exists()) {
            return;
        }

        try {
            for (String line : Files.readAllLines(SWEATS_FILE.toPath())) {
                if (line.isEmpty())
                    continue;
                line = line.trim();
                usernames.add(Text.sanitize(line.toLowerCase()));
            }
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    public void save() {
        if (!requiresSave)
            return;
        requiresSave = false;
        try (BufferedWriter writer = new BufferedWriter(new FileWriter(SWEATS_FILE))) {
            for (String name : usernames) {
                writer.write(name);
                writer.newLine();
            }
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}

package com.lmsnotifier;

import net.runelite.client.RuneLite;
import net.runelite.client.externalplugins.ExternalPluginManager;

public class LMSPluginTest
{
	public static void main(String[] args) throws Exception
	{
		ExternalPluginManager.loadBuiltin(LMSPlugin.class);
		RuneLite.main(args);
	}
}
