package dev.koifysh.archipelago;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import dev.koifysh.archipelago.events.RetrievedEvent;
import dev.koifysh.archipelago.flags.ItemsHandling;
import dev.koifysh.archipelago.network.server.ConnectUpdatePacket;
import dev.koifysh.archipelago.network.server.RoomInfoPacket;
import dev.koifysh.archipelago.parts.DataPackage;
import dev.koifysh.archipelago.parts.NetworkSlot;
import dev.koifysh.archipelago.parts.Version;
import dev.koifysh.archipelago.network.client.*;
import net.runelite.client.eventbus.EventBus;

import java.io.*;
import java.net.URI;
import java.net.URISyntaxException;
import java.nio.charset.StandardCharsets;
import java.util.*;
import java.util.logging.Logger;

public abstract class Client {

    private final static Logger LOGGER = Logger.getLogger(Client.class.getName());

    private final String dataPackageLocation;

    protected Map<String,String> versions;

    protected ArrayList<String> games;

    private int hintPoints;

    private WebSocket webSocket;

    private String password;

    private final String UUID;

    private RoomInfoPacket roomInfo;

    private DataPackage dataPackage;

    public static Client client;

    private final LocationManager locationManager;
    private final ItemManager itemManager;
    //private final EventManager eventManager;
    private EventBus eventBus;

    public static final Version protocolVersion = new Version(0, 6, 1);

    private int team;
    private int slot;
    private HashMap<Integer, NetworkSlot> slotInfo;
    private String name = "Name not set";
    private String game = "Game not set";
    private String alias;
    private Set<String> tags = new HashSet<>();
    private int itemsHandlingFlags = 0b000;

    private Gson gson;

    // Parameters modified for OSRS usage. Original data package location and non-gson serialization not allowed.
    // If you're looking at this for reference on how to implement an AP game, don't look at this bit
    public Client(String dataPackageLocation, Gson gson, EventBus bus) {
        this.dataPackageLocation = dataPackageLocation;
        this.gson = gson;

        loadDataPackage();

        UUID = dataPackage.getUUID();

        eventBus = bus;
        locationManager = new LocationManager(this);
        itemManager = new ItemManager(this);
        client = this;
    }

    /**
     * Sets the name of the game to send to Archipelago's servers
     * @param game the name of your game.
     */
    public void setGame(String game) {
        this.game = game;
    }

    /**
     * overwrite, and set all tags sent to the Archipelago server.
     * this will overwrite any previous tags that have been set.
     * @param tags a Set of tags to send.
     */
    public void setTags(Set<String> tags) {
        if (!this.tags.equals(tags)) {
            this.tags = tags;
            if (isConnected()) {
                ConnectUpdatePacket packet = new ConnectUpdatePacket();
                packet.tags = this.tags;
                webSocket.sendPacket(packet);
            }
        }
    }

    /**
     * add a tag to your list, keeping all previous tags intact.
     * @param tag String tag to be added.
     */
    public void addTag(String tag) {
        if (!this.tags.contains(tag)) {
            tags.add(tag);
            if (isConnected()) {
                ConnectUpdatePacket packet = new ConnectUpdatePacket();
                packet.tags = this.tags;
                webSocket.sendPacket(packet);
            }
        }
    }

    /**
     * removes supplied tag, if it exists.
     * @param tag String tag to be removed.
     */
    public void removeTag(String tag) {
        if (this.tags.contains(tag)) {
            tags.remove(tag);
            if (isConnected()) {
                ConnectUpdatePacket packet = new ConnectUpdatePacket();
                packet.tags = this.tags;
                webSocket.sendPacket(packet);
            }
        }
    }


    protected void loadDataPackage() {
        try {
            FileInputStream fileInput = new FileInputStream(dataPackageLocation);
            dataPackage = gson.fromJson(new InputStreamReader(fileInput, StandardCharsets.UTF_8), dev.koifysh.archipelago.parts.DataPackage.class);
            fileInput.close();

        } catch (IOException e) {
            LOGGER.info("no dataPackage found creating a new one.");
            dataPackage = new DataPackage();
            saveDataPackage();
        }
    }

    void saveDataPackage() {
        try {
            File dataPackageFile = new File(dataPackageLocation);

            //noinspection ResultOfMethodCallIgnored
            dataPackageFile.getParentFile().mkdirs();
            //noinspection ResultOfMethodCallIgnored
            dataPackageFile.createNewFile();

            Writer writer = new OutputStreamWriter(new FileOutputStream(dataPackageFile), StandardCharsets.UTF_8);
            String s = gson.toJson(dataPackage);
            gson.toJson(dataPackage, writer);
            writer.flush();
            writer.close();
        } catch (IOException e) {
            LOGGER.warning("unable to save DataPackage.");
        }
    }


    /**
     * Returns true only if connected to an Archipelago server.
     * @return true if connected, otherwise false
     */
    public boolean isConnected() {
        return webSocket != null && webSocket.isOpen();
    }

    /**
     * closes a connection to the Archipelago server if connected.
     */
    public void close() {
        if (webSocket != null)
            webSocket.close();
    }

    /**
     * sets a password to authenticate with to join a password protected room.
     * @param password room password
     */
    public void setPassword(String password) {
        this.password = password;
    }

    void setHintPoints(int hintPoints) {
        this.hintPoints = hintPoints;
    }

    /**
     * sets the slot name to connect to an Archcipelago server with.
     * @param name
     */
    public void setName(String name) {
        this.name = name;
    }

    void setSlot(int slot) {
        this.slot = slot;
    }

    void setTeam(int team) {
        this.team = team;
    }

    void setSlotInfo(HashMap<Integer, NetworkSlot> slotInfo) {
        this.slotInfo = slotInfo;
    }

    void setRoomInfo(RoomInfoPacket roomInfo) {
        this.roomInfo = roomInfo;
    }

    void updateDataPackage(DataPackage newData) {
        dataPackage.update(newData);
    }

    /**
     *
     * @return team ID
     */
    public int getTeam() {
        return team;
    }

    /**
     *
     * @return Slot ID
     */
    public int getSlot() {
        return slot;
    }

    /**
     * fetches the
     * @return Room info.
     */
    public RoomInfoPacket getRoomInfo() {
        return roomInfo;
    }

    public HashMap<Integer, NetworkSlot> getSlotInfo() {return slotInfo;}

    /**
     * Works exactly like {@link #connect(URI, boolean)} with allowDowngrade set to true;
     * @param address
     * @throws URISyntaxException on malformed address
     */
    public void connect(String address) throws URISyntaxException {
        if (webSocket != null && webSocket.isOpen()) {
            LOGGER.fine("previous WebSocket is open, closing.");
            webSocket.close();
        }

        if (!address.contains("//")) address = "//" + address;
        URI uri = new URI(address);
        int port = uri.getPort();
        if (port == -1) port = 38281; //set default port if not included
        String scheme = uri.getScheme();
        if (scheme == null){
            scheme = "wss";
            URI updatedUri = new URI(String.format("%s://%s:%s", scheme, uri.getHost(), port));
            connect(updatedUri, true);
            return;
        }
        URI updatedUri = new URI(String.format("%s://%s:%s", scheme, uri.getHost(), port));
        connect(updatedUri);

    }

    /**
     * Works exactly like {@link #connect(URI, boolean)} but allowDowngrade is False
     * @param address Address to connect to
     */
    public void connect(URI address) {
        connect(address, false);
    }

    /**
     * Connects to an Archipelago server with previously provided info.
     * <br>
     * supply the following info before calling this method
     * <br>
     * game: {@link #setGame(String)}<br>
     * slot name: {@link #setName(String)}<br>
     * <br>
     * if no protocol <code>wss://</code> or <code>ws://</code> is given will attempt a ssl connection
     * to the supplied address, if that fails it will then try a non-ssl connection, unless <code>allowDowngrade</code> is false. <br>
     * <br>
     * Do not prefix <code>address</code> with <code>wss://</code> or <code>ws://</code>. let the user enter a protocol to use.
     * by default ssl will be tried first, if that fails then non-ssl will be used. unless <code>allowDowngrade</code> is set to false.
     * @param address address of the archipelago server.
     * @param allowDowngrade if set to false will prevent auto downgrade of ssl connection.
     */
    public void connect(URI address, boolean allowDowngrade) {
        LOGGER.fine("attempting WebSocket connection to " + address.toString());
        webSocket = new WebSocket(address, this, gson);
        locationManager.setAPWebSocket(webSocket);
        itemManager.setAPWebSocket(webSocket);
        webSocket.connect(allowDowngrade);
    }

    /**
     * Sends a Chat message to all other connected Clients.
     * @param message Message to send.
     */
    public void sendChat(String message) {
        if (webSocket == null)
            return;
        if (webSocket.isAuthenticated()) {
            webSocket.sendChat(message);
        }
    }

    /**
     * inform the Archipelago server that a location ID has been checked.
     * @param locationID id of a location.
     * @return true if packet was successfully sent. False if not connected or otherwise failed to send.
     */
    public boolean checkLocation(long locationID) {
        return locationManager.checkLocation(locationID);
    }

    /**
     * inform the Archipelago server that a collection of location ID has been checked.
     * @param locationIDs a collection of a locations.
     * @return true if packet was successfully sent. False if not connected or otherwise failed to send.
     */
    public boolean checkLocations(Collection<Long> locationIDs) {
        return locationManager.checkLocations(locationIDs);
    }

    /**
     * Ask the server for information about what is in locations. you will get a response in the {@link dev.koifysh.archipelago.events.LocationInfoEvent} event.
     * @param locationIDs List of location ID's to request info on.
     */
    public void scoutLocations(ArrayList<Long> locationIDs) {
        locationIDs.removeIf( location -> !dataPackage.getGame(game).locationNameToId.containsValue(location));
        webSocket.scoutLocation(locationIDs);
    }

    public abstract void onError(Exception ex);

    public abstract void onClose(String Reason, int attemptingReconnect);

    public DataPackage getDataPackage() {
        return dataPackage;
    }

    public String getMyName() {
        return name;
    }

    public String getPassword() {
        return password;
    }

    public int getHintPoints() {
        return hintPoints;
    }

    public String getGame() {
        return game;
    }

    public String getConnectedAddress() {
        if (isConnected())
            return webSocket.getRemoteSocketAddress().getHostName()+":"+ webSocket.getRemoteSocketAddress().getPort();
        else
            return "";
    }

    /**
     * this should not need to be called externally but is left public just in case.
     */
    public void reconnect() {
        webSocket.reconnect();
    }

    /**
     * Gets the UUID of this client.
     * @return UUID of the client, this should theoretically never change.
     */
    public String getUUID() {
        return UUID;
    }

    /**
     * gets the alias of this slot.
     * @return Alias of the slot connected to.
     */
    public String getAlias() {
        return alias;
    }

    /**
     * sets an Alias for this slot on the Archipelago server.
     * @param alias Name to set the alias to.
     */
    void setAlias(String alias) {
        this.alias = alias;
    }

    public LocationManager getLocationManager() {
        return locationManager;
    }

    public ItemManager getItemManager() {
        return itemManager;
    }

    /**
     * Update the current game status.
     * @see ClientStatus
     *
     * @param status a {@link ClientStatus} to send to the server.
     */
    public void setGameState(ClientStatus status) {
        if (webSocket == null)
            return;
        if (webSocket.isAuthenticated())
            webSocket.sendPacket(new StatusUpdatePacket(status));
    }

    /**
     * manually trigger a resync to the Archipelago server. this should be done automatically if the library detects a desync.
     */
    public void sync() {
        webSocket.sendPacket(new SyncPacket());
    }

    public void sendBounce(BouncePacket bouncePacket) {
        if (webSocket == null)
            return;
        if (webSocket.isAuthenticated())
            webSocket.sendPacket(bouncePacket);
    }

    /**
     * disconnects from a connected Archipelago server.
     */
    public void disconnect() {
        webSocket.close();
    }

    /**
     * @return set of tags currently in use.
     */
    public Set<String> getTags() {
        return tags;
    }

    /**
     * fetch the itemflags that have been set, bitwise Or against {@link ItemsHandling} to read.
     * @return items handling int.
     */
    public int getItemsHandlingFlags() {
        return itemsHandlingFlags;
    }

    /**
     * fetch the itemflags that have been set, bitwise Or against {@link ItemsHandling} to read.
     */
    public void setItemsHandlingFlags(int itemsHandlingFlags) {
        this.itemsHandlingFlags = itemsHandlingFlags;
    }

    /**
     * @return the event manager.
     */
    public EventBus getEventBus() {
        return eventBus;
    }

    /**
     * Uses DataStorage to save a value on the AP server.
     *
     */
    public int dataStorageSet(SetPacket setPacket) {
        if (webSocket == null || !webSocket.isAuthenticated())
            return 0;

        webSocket.sendPacket(setPacket);
        return setPacket.getRequestID();
    }

    /**
     * Registers to receive updates of when a key in the Datastorage has been changed on the server.
     *
     * @param keys List of Keys to be notified of.
     */
    public void dataStorageSetNotify(Collection<String> keys) {
        if (webSocket == null || !webSocket.isAuthenticated())
            return;
        webSocket.sendPacket(new SetNotifyPacket(keys));
    }

    /**
     * Uses DataStorage to reterieve a value from the server will get value back though a
     * {@link RetrievedEvent RetrievedEvent}. <br>
     * see following table for list of reserved keys.
     * <table>
     *     <tr>
     *         <th>Name</th>
     *         <th>Type</th>
     *         <th>Notes</th>
     *     </tr>
     *     <tr>
     *         <td> hints_{team}_{slot} </td>
     *         <td> list[Hint] </td>
     *         <td> All Hints belonging to the requested Player. </td>
     *     </tr>
     *     <tr>
     *         <td> slot_data_{slot} </td>
     *         <td> dict[str, any] </td>
     *         <td> slot_data belonging to the requested slot. </td>
     *     </tr>
     *     <tr>
     *         <td> item_name_groups_{game_name} </td>
     *         <td> dict[str, list[str]] </td>
     *         <td> item_name_groups belonging to the requested game. </td>
     *     </tr>
     *     <tr>
     *         <td> location_name_groups_{game_name} </td>
     *         <td> dict[str, list[str]] </td>
     *         <td> location_name_groups belonging to the requested game. </td>
     *     </tr>
     *     <tr>
     *         <td> client_status_{team}_{slot} </td>
     *         <td> ClientStatus </td>
     *         <td> The current game status of the requested player. </td>
     *     </tr>
     *     <tr>
     *         <td> race_mode </td>
     *         <td> int </td>
     *         <td> 0 if race mode is disabled, and 1 if it's enabled. </td>
     *     </tr>
     * </table>
     *
     * @param keys a list of keys to retrieve values for
     */
    public int dataStorageGet(Collection<String> keys) {
        if (webSocket == null || !webSocket.isAuthenticated())
            return 0;

        GetPacket getPacket = new GetPacket(keys);
        webSocket.sendPacket(getPacket);
        return getPacket.getRequestID();
    }

}

package dev.koifysh.archipelago;

import com.google.gson.annotations.SerializedName;

/**
 * A Status to send to the server. <br>
 * {@link #CLIENT_UNKNOWN} - default, no status. <br>
 * {@link #CLIENT_READY} - Ready to start. <br>
 * {@link #CLIENT_PLAYING} - Player has started playing. <br>
 * {@link #CLIENT_GOAL} - Player has finished their game. This will trigger an auto-release depending on server settings.
 */
public enum ClientStatus {

    @SerializedName("0")
    CLIENT_UNKNOWN(0),
    @SerializedName("10")
    CLIENT_READY(10),
    @SerializedName("20")
    CLIENT_PLAYING(20),
    @SerializedName("30")
    CLIENT_GOAL(30);

    private final int value;
    ClientStatus(int value) {
        this.value = value;
    }

    public int getValue() {
        return value;
    }
}

package dev.koifysh.archipelago.events;

import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;

/**
 * tag a method with this who's only parameter is a class that extends {@link Event}
 */
@Retention(RetentionPolicy.RUNTIME)
public @interface ArchipelagoEventListener {
}

package dev.koifysh.archipelago.events;

import com.google.gson.annotations.SerializedName;

import java.util.HashMap;
import java.util.HashSet;

public class BouncedEvent implements Event {

    @SerializedName("games")
    public HashSet<String> games;

    @SerializedName("slots")
    public HashSet<Integer> slots;

    @SerializedName("tags")
    public HashSet<String> tags;

    @SerializedName("data")
    private HashMap<String, Object> data;

    public BouncedEvent(HashSet<String> games, HashSet<String> tags, HashSet<Integer> slots, HashMap<String, Object> data) {
        this.games = games;
        this.tags = tags;
        this.slots = slots;
        this.data = data;
    }

    public int getInt(String key) {
        return ((Double)data.get(key)).intValue();
    }

    public float getFloat(String key) {
        return (Float) data.get(key);
    }

    public double getDouble(String key) {
        return (Double) data.get(key);
    }

    public String getString(String key) {
        return (String)data.get(key);
    }

    public boolean getBoolean(String key) {
        return (boolean)data.get(key);
    }

    public Object getObject(String key) {
        return data.get(key);
    }


    public boolean containsKey(String key) {
        return data.containsKey(key);
    }

}

package dev.koifysh.archipelago.events;

import java.util.ArrayList;

public class CheckedLocationsEvent implements Event {

    public ArrayList<Long> checkedLocations;

    public CheckedLocationsEvent(ArrayList<Long> checkedLocations) {
        this.checkedLocations = checkedLocations;
    }
}

package dev.koifysh.archipelago.events;

import com.google.gson.Gson;
import com.google.gson.JsonElement;
import com.google.gson.internal.Primitives;

public class ConnectionAttemptEvent implements Event {

    private boolean canceled = false;
    private final int team;
    private final int slot;
    private final String seedName;
    private final JsonElement slot_data;

    private final Gson gson;

    public ConnectionAttemptEvent(int team, int slot, String seedName, JsonElement slotData, Gson gson) {
        this.team = team;
        this.slot = slot;
        this.seedName = seedName;
        this.slot_data = slotData;
        this.gson = gson;
    }

    public void setCanceled(boolean canceled) {
        this.canceled = canceled;
    }

    public boolean isCanceled() {
        return canceled;
    }

    public int getTeam() {
        return team;
    }

    public int getSlot() {
        return slot;
    }

    public String getSeedName() {
        return seedName;
    }

    public <T> T getSlotData(Class<T> classOfT) {
        Object data = gson.fromJson(slot_data,classOfT);
        return Primitives.wrap(classOfT).cast(data);
    }

}

package dev.koifysh.archipelago.events;

import com.google.gson.Gson;
import com.google.gson.JsonElement;
import com.google.gson.internal.Primitives;
import dev.koifysh.archipelago.network.ConnectionResult;

public class ConnectionResultEvent implements Event {

    private final int team;
    private final int slot;
    private final String seedName;
    private final ConnectionResult result;
    private final JsonElement slot_data;
    private final Gson gson;

    public ConnectionResultEvent(ConnectionResult result, Gson gson) {
        this(result,0,0,null,null, gson);
    }

    public ConnectionResultEvent(ConnectionResult result, int team, int slot, String seedName, JsonElement slot_data, Gson gson) {
        this.result = result;
        this.team = team;
        this.slot = slot;
        this.seedName = seedName;
        this.slot_data = slot_data;
        this.gson = gson;
    }

    public int getTeam() {
        return team;
    }

    public int getSlot() {
        return slot;
    }

    public String getSeedName() {
        return seedName;
    }

    public ConnectionResult getResult() {
        return result;
    }

    public <T> T getSlotData(Class<T> classOfT) {
        Object data = gson.fromJson(slot_data,classOfT);
        return Primitives.wrap(classOfT).cast(data);
    }
}

package dev.koifysh.archipelago.events;

/**
 * event that is fired whenever you receive a death link from another player. must first enable death links via {@link dev.koifysh.archipelago.helper.DeathLink}
 */
public class DeathLinkEvent implements Event {

    public double time;
    public String cause;
    public String source;

    public DeathLinkEvent(String source, String cause, double time) {
        this.source = source;
        this.cause = cause;
        this.time = time;
    }
}

package dev.koifysh.archipelago.events;

public interface Event {
}

package dev.koifysh.archipelago.events;

public class InvalidPacketEvent implements Event {

    private final String type;
    private final String originalCommand;
    private final String text;

    public InvalidPacketEvent(String type, String originalCommand, String text) {
        this.type = type;
        this.text = text;
        this.originalCommand = originalCommand;
    }


    public String getType() {
        return type;
    }

    public String getOriginalCommand() {
        return originalCommand;
    }

    public boolean hasOriginalCommand() {
        return originalCommand != null;
    }

    public String getText() {
        return text;
    }
}

package dev.koifysh.archipelago.events;

import dev.koifysh.archipelago.parts.NetworkItem;

import java.util.ArrayList;

public class LocationInfoEvent implements Event{
    public ArrayList<NetworkItem> locations;
    public LocationInfoEvent(ArrayList<NetworkItem> locations) {
        this.locations = locations;
    }
}

package dev.koifysh.archipelago.events;

import dev.koifysh.archipelago.Print.APPrint;
import dev.koifysh.archipelago.Print.APPrintJsonType;
import dev.koifysh.archipelago.parts.NetworkItem;

/**
 * event that is fired when the server wishes to send a message to the user.
 */
public class PrintJSONEvent implements Event {

    public APPrint apPrint;
    public APPrintJsonType type;
    public int player;
    public NetworkItem item;

    /**
     * @param apPrint list of message segments.
     * @param type the type of the received message.
     * @param player int id of the sending player.
     * @param item the network item that is involved with the message.
     */
    public PrintJSONEvent(APPrint apPrint, APPrintJsonType type, int player, NetworkItem item) {
        this.apPrint = apPrint;
        this.type = type;
        this.player = player;
        this.item = item;
    }
}

package dev.koifysh.archipelago.events;

import dev.koifysh.archipelago.parts.NetworkItem;

public class ReceiveItemEvent implements Event {

    private final NetworkItem item;
    private final int index;
    public ReceiveItemEvent(NetworkItem item, int index) {
        this.item = item;
        this.index = index;
    }

    public NetworkItem getItem() {
        return item;
    }

    public String getItemName() {
        return item.itemName;
    }

    public String getLocationName() {
        return item.locationName;
    }

    public String getPlayerName() {
        return item.playerName;
    }

    public Long getItemID() {
        return item.itemID;
    }

    public Long getLocationID() {
        return item.locationID;
    }

    public int getPlayerID() {
        return item.playerID;
    }

    public long getIndex() {
        return index;
    }
}

package dev.koifysh.archipelago.events;

import com.google.gson.Gson;
import com.google.gson.JsonObject;
import com.google.gson.internal.Primitives;
import com.google.gson.internal.bind.JsonTreeReader;
import com.google.gson.reflect.TypeToken;

import java.util.HashMap;

public class RetrievedEvent implements Event {

    public HashMap<String, Object> data;
    private final int requestID;
    private final JsonObject jsonValue;

    private final Gson gson;

    public RetrievedEvent(HashMap<String, Object> keys, JsonObject jsonValue, int requestID, Gson gson) {
        data = keys;
        this.jsonValue = jsonValue;
        this.requestID = requestID;
        this.gson = gson;
    }

    public int getInt(String key) {
        return (Integer) data.get(key);
    }

    public float getFloat(String key) {
        return (Float) data.get(key);
    }

    public double getDouble(String key) {
        return (Double) data.get(key);
    }

    public String getString(String key) {
        return (String) data.get(key);
    }

    public boolean getBoolean(String key) {
        return (boolean) data.get(key);
    }

    public Object getObject(String key) {
        return data.get(key);
    }

    public boolean containsKey(String key) {
        return data.containsKey(key);
    }

    public <T> T getValueAsObject(String key, Class<T> classOfT) {
        Object value = gson.fromJson(jsonValue.get(key), classOfT);
        return Primitives.wrap(classOfT).cast(value);
    }

    public <T> T getValueAsObject(String key, TypeToken<T> typeOfT) {
        return jsonValue == null ? null : gson.fromJson(new JsonTreeReader(jsonValue.get(key)), typeOfT.getType());
    }

    public int getRequestID() {
        return requestID;
    }
}
package dev.koifysh.archipelago.events;

import com.google.gson.Gson;
import com.google.gson.JsonElement;
import com.google.gson.annotations.SerializedName;
import com.google.gson.internal.Primitives;
import com.google.gson.internal.bind.JsonTreeReader;
import com.google.gson.reflect.TypeToken;

public class SetReplyEvent implements Event {
    @SerializedName("key")
    public String key;
    @SerializedName("value")
    public Object value;
    @SerializedName("original_value")
    public Object original_value;

    private final int requestID;

    private final JsonElement jsonValue;
    private final Gson gson;

    public SetReplyEvent(String key, Object value, Object original_value, JsonElement jsonValue, int requestID, Gson gson) {
        this.key = key;
        this.value = value;
        this.original_value = original_value;
        this.jsonValue = jsonValue;
        this.requestID = requestID;
        this.gson = gson;
    }

    public <T> T getValueAsObject(Class<T> classOfT) {
        Object value = gson.fromJson(jsonValue, classOfT);
        return Primitives.wrap(classOfT).cast(value);
    }

    public <T> T getValueAsObject(TypeToken<T> typeOfT) {
        return jsonValue == null ? null : gson.fromJson(new JsonTreeReader(jsonValue), typeOfT.getType());
    }

    public int getRequestID() {
        return requestID;
    }
}

package dev.koifysh.archipelago.flags;

import dev.koifysh.archipelago.Client;

/**
 * Item Flag variables to read {@link Client#getItemsHandlingFlags()} and set {@link Client#setItemsHandlingFlags(int)}
 * <br>
 * Current item flags: {@link #SEND_ITEMS} {@link #SEND_OWN_ITEMS} {@link #SEND_STARTING_INVENTORY}
 */
public class ItemsHandling {

    /**
     * Tells the server to send you items from other worlds.
     */
    public static final int SEND_ITEMS = 0b001;

    /**
     * Tells the server to send your own items to you (remote items game)
     */
    public static final int SEND_OWN_ITEMS = 0b010;

    /**
     * Tells the server to send you any items that You should start with.
     * don't set this if you handle starting items by some kind of data file.
     */
    public static final int SEND_STARTING_INVENTORY = 0b100;

}

package dev.koifysh.archipelago.flags;

/**
 * Flags that will tell you more about the item that was sent.<br>
 * {@link #ADVANCEMENT},
 * {@link #USEFUL},
 * {@link #TRAP}
 */
public class NetworkItem {
    /**
     * If set, indicates the item can unlock logical advancement
     */
    public final static int ADVANCEMENT = 0b001;

    /**
     * If set, indicates the item is important but not in a way that unlocks advancement
     */
    public final static int USEFUL = 0b010;

    /**
     * If set, indicates the item is a trap
     */
    public final static int TRAP = 0b100;
}

package dev.koifysh.archipelago.flags;

/**
 * Flags that will tell you more about the slot type.<br>
 * {@link #SPECTATOR},
 * {@link #PLAYER},
 * {@link #GROUP}
 */
public class NetworkPlayer {
    /**
     * If set, indicates the slot is a spectator
     */
    public final static int SPECTATOR = 0b001;

    /**
     * If set, indicates the slot is a player
     */
    public final static int PLAYER = 0b010;

    /**
     * If set, indicates the slot is a group.
     */
    public final static int GROUP = 0b100;
}

package dev.koifysh.archipelago.helper;

import dev.koifysh.archipelago.network.client.BouncePacket;
import dev.koifysh.archipelago.network.server.BouncedPacket;
import dev.koifysh.archipelago.events.DeathLinkEvent;

import java.util.HashMap;

import static dev.koifysh.archipelago.Client.client;

/**
 * a helper-class for sending and receiving death links.
 * <br>
 * enable death links by calling {@link #setDeathLinkEnabled(boolean)}
 */
public class DeathLink {

    static private double lastDeath = 0;

    public static void receiveDeathLink(BouncedPacket bounced) {
        try {
            if ((Double) bounced.data.getOrDefault("time", 0d) == lastDeath)
                return;

            DeathLinkEvent dl = new DeathLinkEvent((String)bounced.data.get("source"), (String)bounced.data.get("cause"), (Double)bounced.data.get("time"));
            client.getEventBus().post(dl);
        } catch (ClassCastException ex) {
            //System.out.println("Error Receiving DeathLink, possible malformed bounce packet");
        }
    }

    /**
     * helper for sending a death link bounce packet. you can send these without enabling death link first, but it is frowned upon.
     * @param source A String that is the name of the player sending the death link (does not have to be slot name)
     * @param cause A String that is the cause of this death. may be empty.
     */
    public static void SendDeathLink(String source, String cause) {
        lastDeath = (double)System.currentTimeMillis() / 1000D;

        BouncePacket deathLinkPacket = new BouncePacket();
        deathLinkPacket.tags = new String[]{"DeathLink"};
        deathLinkPacket.setData(new HashMap<String, Object>(){{
            put("cause",cause);
            put("time", lastDeath);
            put("source",source);
        }});
        client.sendBounce(deathLinkPacket);
    }

    /**
     * Enable or Disable receiving death links.
     * @param enabled set to TRUE to enable death links, FALSE to disable.
     */
    public static void setDeathLinkEnabled(boolean enabled) {
        if(enabled)
            client.addTag("DeathLink");
        else
            client.removeTag("DeathLink");
    }
}

package dev.koifysh.archipelago;

import dev.koifysh.archipelago.events.ReceiveItemEvent;
import dev.koifysh.archipelago.network.client.SyncPacket;
import dev.koifysh.archipelago.parts.DataPackage;
import dev.koifysh.archipelago.parts.NetworkItem;

import java.util.ArrayList;

public class ItemManager {


    Client client;
    WebSocket webSocket;

    ArrayList<NetworkItem> receivedItems = new ArrayList<>();

    int index;

    public ItemManager(Client client) {
        this.client = client;
    }

    public void receiveItems(ArrayList<NetworkItem> ids, int index) {
        if (index == 0) {
            receivedItems = new ArrayList<>();
        }
        if (receivedItems.size() == index) {
            receivedItems.addAll(ids);
            DataPackage dp = client.getDataPackage();
            int myTeam = client.getTeam();
            for (int i = this.index; i < receivedItems.size(); i++) {
                NetworkItem item = receivedItems.get(i);
                item.itemName = dp.getItem(item.itemID, client.getGame());
                item.locationName = dp.getLocation(item.locationID, client.getSlotInfo().get(item.playerID).game);
                item.playerName = client.getRoomInfo().getPlayer(myTeam,item.playerID).alias;
                client.getEventBus().post(new ReceiveItemEvent(item, i+1));
            }

            this.index = receivedItems.size();
        }
        else {
            if(webSocket != null) {
                webSocket.sendPacket(new SyncPacket());
                client.getLocationManager().resendAllCheckedLocations();
            }
        }
    }

    public void writeFromSave(ArrayList<NetworkItem> receivedItems, int index) {
        this.receivedItems = receivedItems;
        this.index = index;
    }

    public void setAPWebSocket(WebSocket webSocket) {
        this.webSocket = webSocket;
    }

    public int getIndex() {
        return index;
    }

    public ArrayList<NetworkItem> getReceivedItems() {
        return receivedItems;
    }

    public ArrayList<Long> getReceivedItemIDs() {
        ArrayList<Long> ids = new ArrayList<>();
        for (NetworkItem receivedItem : receivedItems) {
            ids.add(receivedItem.itemID);
        }
        return ids;
    }
}

package dev.koifysh.archipelago;

import dev.koifysh.archipelago.network.client.LocationChecks;

import java.util.ArrayList;
import java.util.Collection;
import java.util.HashSet;
import java.util.Set;

public class LocationManager {

    Client client;
    WebSocket webSocket;

    Set<Long> checkedLocations = new HashSet<>();

    Set<Long> missingLocations = new HashSet<>();

    public LocationManager(Client client) {
        this.client = client;
    }

    public boolean checkLocation(long id) {
        return checkLocations(new ArrayList<Long>(1) {{add(id);}});
    }

    public boolean checkLocations(Collection<Long> ids) {
        ids.removeIf( location -> !missingLocations.contains(location));
        checkedLocations.addAll(ids);
        missingLocations.removeAll(ids);
        LocationChecks packet = new LocationChecks();
        packet.locations.addAll(ids);
        if(webSocket == null)
            return false;

        if(webSocket.isAuthenticated()) {
            webSocket.sendPacket(packet);
            return true;
        }
        return false;
    }

    public void sendIfChecked(Set<Long> missingChecks) {
        LocationChecks packet = new LocationChecks();
        packet.locations = new HashSet<>();
        for (Long missingCheck : missingChecks) {
            if(checkedLocations.contains(missingCheck)) {
                packet.locations.add(missingCheck);
            }
        }
        if(webSocket != null && !packet.locations.isEmpty())
            webSocket.sendPacket(packet);
    }

    public void resendAllCheckedLocations() {
        if (webSocket == null)
                return;
        LocationChecks packet = new LocationChecks();
        packet.locations = checkedLocations;
        webSocket.sendPacket(packet);
    }

    protected void setAPWebSocket(WebSocket webSocket) {
        this.webSocket = webSocket;
    }

    public Set<Long> getCheckedLocations() {
        return checkedLocations;
    }

    public Set<Long> getMissingLocations() {
        return missingLocations;
    }

    public void addCheckedLocations(Set<Long> newLocations) {
        this.checkedLocations.addAll(newLocations);
        this.missingLocations.removeAll(newLocations);
    }

    public void setMissingLocations(HashSet<Long> missingLocations) {
        this.missingLocations = missingLocations;
    }
}

package dev.koifysh.archipelago.network;

import com.google.gson.annotations.Expose;
import com.google.gson.annotations.SerializedName;

public class APPacket {

    @Expose
    @SerializedName("cmd")
    private APPacketType cmd;

    public APPacket(APPacketType cmd) {
        this.cmd = cmd;
    }

    public APPacketType getCmd() {
        return cmd;
    }
}

package dev.koifysh.archipelago.network;

import com.google.gson.annotations.SerializedName;

public enum APPacketType {
    @SerializedName("RoomInfo")
    RoomInfo,
    @SerializedName("ConnectionRefused")
    ConnectionRefused,
    @SerializedName("Connected")
    Connected,
    @SerializedName("ReceivedItems")
    ReceivedItems,
    @SerializedName("LocationInfo")
    LocationInfo,
    @SerializedName("RoomUpdate")
    RoomUpdate,
    @SerializedName("Print")
    Print,
    @SerializedName("PrintJSON")
    PrintJSON,
    @SerializedName("DataPackage")
    DataPackage,
    @SerializedName("Connect")
    Connect,
    @SerializedName("LocationChecks")
    LocationChecks,
    @SerializedName("LocationScouts")
    LocationScouts,
    @SerializedName("StatusUpdate")
    StatusUpdate,
    @SerializedName("Say")
    Say,
    @SerializedName("GetDataPackage")
    GetDataPackage,
    @SerializedName("Bounce")
    Bounce,
    @SerializedName("Bounced")
    Bounced,
    @SerializedName("Sync")
    Sync,
    @SerializedName("ConnectUpdate")
    ConnectUpdate,
    @SerializedName("Get")
    Get,
    @SerializedName("Set")
    Set,
    @SerializedName("SetNotify")
    SetNotify,
    @SerializedName("Retrieved")
    Retrieved,
    @SerializedName("SetReply")
    SetReply,
    @SerializedName("InvalidPacket")
    InvalidPacket,
    @SerializedName("UpdateHint")
    UpdateHint
}

package dev.koifysh.archipelago.network.client;

import com.google.gson.annotations.Expose;
import com.google.gson.annotations.SerializedName;
import dev.koifysh.archipelago.events.Event;
import dev.koifysh.archipelago.network.APPacket;
import dev.koifysh.archipelago.network.APPacketType;

import java.util.HashMap;

public class BouncePacket extends APPacket implements Event {

    @Expose
    @SerializedName("games")
    public String[] games = new String[]{};

    @Expose
    @SerializedName("slots")
    public int[] slots = new int[]{};

    @Expose
    @SerializedName("tags")
    public String[] tags = new String[]{};

    @Expose
    @SerializedName("data")
    private HashMap<String, Object> data;

    public BouncePacket() {
        super(APPacketType.Bounce);
    }

    public HashMap<String, Object> getData() {
        return data;
    }

    public void setData(HashMap<String, Object> data) {
        this.data = data;
    }
}

package dev.koifysh.archipelago.network.client;

import com.google.gson.annotations.SerializedName;
import dev.koifysh.archipelago.network.APPacket;
import dev.koifysh.archipelago.network.APPacketType;
import dev.koifysh.archipelago.parts.Version;

import java.util.Set;

public class ConnectPacket extends APPacket {

    @SerializedName("password")
    public String password;

    @SerializedName("game")
    public String game;

    @SerializedName("name")
    public String name;

    @SerializedName("uuid")
    public String uuid;

    @SerializedName("version")
    public Version version;

    @SerializedName("items_handling")
    public int itemsHandling;

    @SerializedName("tags")
    public Set<String> tags;

    public ConnectPacket() {
        super(APPacketType.Connect);
    }

}
package dev.koifysh.archipelago.network.client;

import dev.koifysh.archipelago.network.APPacket;
import dev.koifysh.archipelago.network.APPacketType;

import java.util.Set;

public class GetDataPackagePacket extends APPacket {

    Set<String> games;

    public GetDataPackagePacket() {
        this(null);
    }

    public GetDataPackagePacket(Set<String> games) {
        super(APPacketType.GetDataPackage);
        this.games = games;
    }
}

package dev.koifysh.archipelago.network.client;

import com.google.gson.annotations.SerializedName;
import dev.koifysh.archipelago.Client;
import dev.koifysh.archipelago.events.RetrievedEvent;
import dev.koifysh.archipelago.network.APPacket;
import dev.koifysh.archipelago.network.APPacketType;

import java.util.Collection;
import java.util.Random;

/**
 * Used to request a single or multiple values from the server's data storage, see the
 * {@link Client#dataStorageSet(SetPacket) ArchipelagoClient.dataStorageSet()} for how to write values to the data storage.
 * A Get package will be answered with a {@link RetrievedEvent RetreivedEvent}.
 */
public class GetPacket extends APPacket {

    /**
     * a list of keys to retrieve data for.
     */
    @SerializedName("keys")
    public Collection<String> keys;

    @SerializedName("request_id")
    private int requestID;

    public GetPacket(Collection<String> keys) {
        super(APPacketType.Get);
        this.keys = keys;
        requestID = new Random().nextInt(Integer.MAX_VALUE);
    }

    public int getRequestID() {
        return requestID;
    }
}

package dev.koifysh.archipelago.network.client;

import com.google.gson.annotations.SerializedName;

public enum HintStatus {
    @SerializedName("HINT_UNSPECIFIED")
    HINT_UNSPECIFIED(0),
    @SerializedName("HINT_NO_PRIORITY")
    HINT_NO_PRIORITY(10),
    @SerializedName("HINT_AVOID")
    HINT_AVOID(20),
    @SerializedName("HINT_PRIORITY")
    HINT_PRIORITY(30),
    @SerializedName("HINT_FOUND")
    HINT_FOUND(40);

    public final int value;
    HintStatus(int value) {
        this.value=value;
    }
}
package dev.koifysh.archipelago.network.client;

import com.google.gson.annotations.SerializedName;
import dev.koifysh.archipelago.network.APPacket;
import dev.koifysh.archipelago.network.APPacketType;

import java.util.HashSet;
import java.util.Set;

public class LocationChecks extends APPacket {

    @SerializedName("locations")
    public Set<Long> locations = new HashSet<>();

    public LocationChecks() {
        super(APPacketType.LocationChecks);
    }
}

package dev.koifysh.archipelago.network.client;

import dev.koifysh.archipelago.network.APPacket;
import dev.koifysh.archipelago.network.APPacketType;

import java.util.ArrayList;

public class LocationScouts extends APPacket {

    public ArrayList<Long> locations = new ArrayList<>();

    public LocationScouts(ArrayList<Long> locations) {
        super(APPacketType.LocationScouts);
        this.locations = locations;
    }
}

package dev.koifysh.archipelago.network.client;

import com.google.gson.annotations.SerializedName;
import dev.koifysh.archipelago.network.APPacket;
import dev.koifysh.archipelago.network.APPacketType;

public class SayPacket extends APPacket {

    @SerializedName("text")
    String text;

    public SayPacket(String message) {
        super(APPacketType.Say);
        text = message;
    }
}

package dev.koifysh.archipelago.network.client;

import dev.koifysh.archipelago.network.APPacket;
import dev.koifysh.archipelago.network.APPacketType;

import java.util.Collection;

public class SetNotifyPacket extends APPacket {

    /**
     * a list of datastorage keys to be notified upon their change.
     */
    public Collection<String> keys;

    public SetNotifyPacket(Collection<String> keys) {
        super(APPacketType.SetNotify);
        this.keys = keys;
    }
}

package dev.koifysh.archipelago.network.client;

import com.google.gson.annotations.SerializedName;
import dev.koifysh.archipelago.events.SetReplyEvent;
import dev.koifysh.archipelago.network.APPacket;
import dev.koifysh.archipelago.network.APPacketType;

import java.util.ArrayList;
import java.util.Random;

public class SetPacket extends APPacket {

    /**
     * The key to manipulate. Can never start with "_read".
     */
    @SerializedName("key")
    public String key;

    /**
     * The default value to use in case the key has no value on the server.
     */
    @SerializedName("default")
    public Object defaultValue;

    /**
     * If true, the server will send a {@link SetReplyEvent SetReplyEvent} response back to the client.
     */
    @SerializedName("want_reply")
    public boolean want_reply = false;


    /**
     * Operations to apply to the value on the server, multiple operations can be present,
     * and they will be executed in order of appearance.
     */
    @SerializedName("operations")
    public ArrayList<DataStorageOperation> operations = new ArrayList<>();

    @SerializedName("request_id")
    private int requestID;

    public SetPacket(String key, Object defaultValue) {
        super(APPacketType.Set);
        this.key = key;
        this.defaultValue = defaultValue;
        requestID = new Random().nextInt(Integer.MAX_VALUE);
    }

    /**
     * adds a {@link DataStorageOperation} to be performed to the value on the server, these are applied
     * in the order that you add them.
     * @param operation {@link Operation} to apply
     * @param value a `value` for use with the {@link Operation}
     */
    public void addDataStorageOperation(Operation operation, Object value) {
        operations.add(new DataStorageOperation(operation, value));
    }

    public int getRequestID() {
        return requestID;
    }

    /**
     * A DataStorageOperation manipulates or alters the value of a key in the servers data storage.
     * If the operation transforms the value from one state to another then the current value
     * of the key is used as the starting point otherwise the Set's package default is used if
     * the key does not exist on the server already. DataStorageOperations consist of an object
     * containing both the operation to be applied, and the value to be used for that operation.
     */
    private static class DataStorageOperation {
        @SerializedName("operation")
        Operation operation;
        @SerializedName("value")
        Object value;
        DataStorageOperation(Operation operation, Object value) {
            this.operation = operation;
            this.value = value;
        }
    }

    /**
     * A List of operations that can be performed on the value stored on the server.<br>
     * {@link #REPLACE},
     * {@link #DEFAULT},
     * {@link #ADD},
     * {@link #MULTIPLY},
     * {@link #POWER},
     * {@link #MODULO},
     * {@link #MAX},
     * {@link #MIN},
     * {@link #AND},
     * {@link #OR},
     * {@link #XOR},
     * {@link #LEFT_SHIFT},
     * {@link #RIGHT_SHIFT},
     * {@link #REMOVE},
     * {@link #POP},
     * {@link #UPDATE}
     */
    public enum Operation {
        /**
         * Sets the current value of the key on the server to the value given in {@link SetPacket#addDataStorageOperation addDataStorageOperation(Operation, Value)}.
         */
        @SerializedName("replace")
        REPLACE,

        /**
         * If the key has no value yet, Sets the current value of the key on the server to the default of the
         * Set's package (@value is ignored).
         */
        @SerializedName("default")
        DEFAULT,

        /**
         * Adds value to the current value of the key on the server, if both the current value and value
         * are arrays then value will be appended to the current @value.
         */
        @SerializedName("add")
        ADD,

        /**
         * Multiplies the current value of the key on the server by @value.
         */
        @SerializedName("mul")
        MULTIPLY,

        /**
         * Multiplies the current value of the key on the server to the power of @value.
         */
        @SerializedName("pow")
        POWER,

        /**
         * Sets the current value of the key on the server to the remainder after division by @value.
         */
        @SerializedName("mod")
        MODULO,

        /**
         * Sets the current value of the key on the server to @value if @value is bigger.
         */
        @SerializedName("max")
        MAX,

        /**
         * Sets the current value of the key on the server to @value if @value is lower.
         */
        @SerializedName("min")
        MIN,

        /**
         * Applies a bitwise AND to the current value on the server of the key with @value.
         */
        @SerializedName("and")
        AND,

        /**
         * Applies a bitwise OR to the current value of the key on the server with @value.
         */
        @SerializedName("default")
        OR,

        /**
         * Applies a bitwise Exclusive OR to the current value of the key on the server with @value.
         */
        @SerializedName("xor")
        XOR,

        /**
         * Applies a bitwise left-shift to the current value of the key on the server by @value.
         */
        @SerializedName("left_shift")
        LEFT_SHIFT,

        /**
         * Applies a bitwise right-shift to the current value of the key on the server by @value.
         */
        @SerializedName("right_shift")
        RIGHT_SHIFT,

        /**
         * List only: removes the first instance of @value found in the list.
         */
        @SerializedName("remove")
        REMOVE,

        /**
         * List or Dict: for lists it will remove the index of the @value given. for dicts it removes the element with the specified key of value.
         */
        @SerializedName("pop")
        POP,

        /**
         * Dict only: Updates the dictionary with the specified elements given in @value creating new keys, or updating old ones if they previously existed.
         */
        @SerializedName("update")
        UPDATE

    }
}

package dev.koifysh.archipelago.network.client;

import dev.koifysh.archipelago.ClientStatus;
import dev.koifysh.archipelago.network.APPacket;
import dev.koifysh.archipelago.network.APPacketType;

public class StatusUpdatePacket extends APPacket {

    int status;

    public StatusUpdatePacket(ClientStatus status) {
        super(APPacketType.StatusUpdate);
        this.status = status.getValue();

    }
}

package dev.koifysh.archipelago.network.client;

import dev.koifysh.archipelago.network.APPacket;
import dev.koifysh.archipelago.network.APPacketType;

public class SyncPacket extends APPacket {


    public SyncPacket() {
        super(APPacketType.Sync);
    }
}

package dev.koifysh.archipelago.network.client;

import com.google.gson.annotations.SerializedName;

import dev.koifysh.archipelago.network.APPacket;
import dev.koifysh.archipelago.network.APPacketType;

public class UpdateHintPacket extends APPacket{
    /*
    * NEED TO IMPLEMENT STUFF FOR UPDATEHINTPACKET?
    */

    @SerializedName("player")
    int player;    
     
    @SerializedName("location")
    int location;

    @SerializedName("status")
    HintStatus status;

    public UpdateHintPacket(){
        super(APPacketType.UpdateHint);
    }
}

package dev.koifysh.archipelago.network;

public enum ConnectionResult {
    Success,InvalidSlot, SlotAlreadyTaken, IncompatibleVersion, InvalidPassword
}

package dev.koifysh.archipelago.network;



package dev.koifysh.archipelago.network;

public enum Permission {
    disabled(0b000),
    enabled(0b001),
    goal(0b010),
    auto(0b110),
    auto_enabled(0b111);

    public final int value;
    Permission(int value) {
        this.value=value;
    }
}

package dev.koifysh.archipelago.network;

public enum RemainingMode {
    enabled,
    disabled,
    goal;

    public enum ForfeitMode {
        auto("auto"),
        enabled("enabled"),
        disabled("disabled"),
        autoEnabled("auto-enabled");

        public final String label;

        private ForfeitMode(String label) {
            this.label = label;
        }
    }
}

package dev.koifysh.archipelago.network.server;

import com.google.gson.annotations.SerializedName;
import dev.koifysh.archipelago.network.APPacket;
import dev.koifysh.archipelago.network.APPacketType;

import java.util.HashMap;
import java.util.HashSet;

public class BouncedPacket extends APPacket {

    @SerializedName("games")
    public HashSet<String> games = new HashSet<>();

    @SerializedName("slots")
    public HashSet<Integer> slots = new HashSet<>();

    @SerializedName("tags")
    public HashSet<String> tags = new HashSet<>();

    @SerializedName("data")
    public final HashMap<String, Object> data = new HashMap<>();

    public BouncedPacket() {
        super(APPacketType.Bounced);
    }
}

package dev.koifysh.archipelago.network.server;

import com.google.gson.annotations.SerializedName;
import dev.koifysh.archipelago.network.APPacket;
import dev.koifysh.archipelago.network.APPacketType;
import dev.koifysh.archipelago.parts.NetworkPlayer;
import dev.koifysh.archipelago.parts.NetworkSlot;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.HashSet;

public class ConnectedPacket extends APPacket {

    @SerializedName("team")
    public int team = -1;
    @SerializedName("slot")
    public int slot = -1;
    @SerializedName("players")
    public ArrayList<NetworkPlayer> players;
    @SerializedName("missing_locations")
    public HashSet<Long> missingLocations = new HashSet<>();
    @SerializedName("checked_locations")
    public HashSet<Long> checkedLocations = new HashSet<>();
    @SerializedName("slot_info")
    public HashMap<Integer, NetworkSlot> slotInfo;

    public ConnectedPacket() {
        super(APPacketType.Connected);
    }
}

package dev.koifysh.archipelago.network.server;

import com.google.gson.annotations.SerializedName;
import dev.koifysh.archipelago.network.APPacket;
import dev.koifysh.archipelago.network.APPacketType;
import dev.koifysh.archipelago.network.ConnectionResult;

public class ConnectionRefusedPacket extends APPacket {

    @SerializedName("errors")
    public ConnectionResult[] errors;

    public ConnectionRefusedPacket() {
        super(APPacketType.ConnectionRefused);
    }
}

package dev.koifysh.archipelago.network.server;

import com.google.gson.annotations.SerializedName;
import dev.koifysh.archipelago.network.APPacket;
import dev.koifysh.archipelago.network.APPacketType;

import java.util.Set;

public class ConnectUpdatePacket extends APPacket {

    @SerializedName("tags")
    public Set<String> tags;

    public ConnectUpdatePacket() {
        super(APPacketType.ConnectUpdate);
    }

}
package dev.koifysh.archipelago.network.server;

import com.google.gson.annotations.SerializedName;
import dev.koifysh.archipelago.network.APPacket;
import dev.koifysh.archipelago.network.APPacketType;

public class InvalidPacket extends APPacket {

    @SerializedName("type")
    public String type;
    @SerializedName("original_cmd")
    public String Original_cmd;
    @SerializedName("text")
    public String text;

    public InvalidPacket() {
        super(APPacketType.InvalidPacket);
    }
}

package dev.koifysh.archipelago.network.server;

import dev.koifysh.archipelago.Print.APPrintPart;
import dev.koifysh.archipelago.network.APPacket;
import dev.koifysh.archipelago.network.APPacketType;

public class JsonPrintPacket extends APPacket {
    APPrintPart[] parts;

    public JsonPrintPacket() {
        super(APPacketType.PrintJSON);
    }
}

package dev.koifysh.archipelago.network.server;

import com.google.gson.annotations.SerializedName;
import dev.koifysh.archipelago.network.APPacket;
import dev.koifysh.archipelago.network.APPacketType;
import dev.koifysh.archipelago.parts.NetworkItem;

import java.util.ArrayList;

public class LocationInfoPacket extends APPacket {

    @SerializedName("locations")
    public ArrayList<NetworkItem> locations;

    public LocationInfoPacket() {
        super(APPacketType.LocationInfo);
    }
}

package dev.koifysh.archipelago.network.server;

import com.google.gson.annotations.SerializedName;
import dev.koifysh.archipelago.network.APPacket;
import dev.koifysh.archipelago.network.APPacketType;

public class PrintPacket extends APPacket {

    @SerializedName("text")
    String text;

    public PrintPacket() {
        super(APPacketType.Print);
    }

    public String getText() {
        return text;
    }
}

package dev.koifysh.archipelago.network.server;

import com.google.gson.annotations.SerializedName;
import dev.koifysh.archipelago.network.APPacket;
import dev.koifysh.archipelago.network.APPacketType;
import dev.koifysh.archipelago.parts.NetworkItem;

import java.util.ArrayList;

public class ReceivedItemsPacket extends APPacket {

    @SerializedName("index")
    public int index;

    @SerializedName("items")
    public ArrayList<NetworkItem> items;

    public ReceivedItemsPacket() {
        super(APPacketType.ReceivedItems);
    }
}

package dev.koifysh.archipelago.network.server;

import com.google.gson.annotations.SerializedName;
import dev.koifysh.archipelago.network.APPacket;
import dev.koifysh.archipelago.network.APPacketType;

import java.util.HashMap;

public class RetrievedPacket  extends APPacket {

    @SerializedName("keys")
    public HashMap<String, Object> keys;

    @SerializedName("request_id")
    public int requestID;

    public RetrievedPacket() {
        super(APPacketType.Retrieved);
    }
}


package dev.koifysh.archipelago.network.server;

import com.google.gson.annotations.SerializedName;
import dev.koifysh.archipelago.network.APPacket;
import dev.koifysh.archipelago.network.APPacketType;
import dev.koifysh.archipelago.parts.NetworkPlayer;
import dev.koifysh.archipelago.parts.Version;

import java.util.ArrayList;
import java.util.HashMap;

public class RoomInfoPacket extends APPacket {

    public Version version;

    @SerializedName("generator_version")
    public Version generatorVersion;

    public String[] tags;

    public boolean password;

    public HashMap<String, Integer> permissions;

    @SerializedName("hint_cost")
    public int hintCost;

    @SerializedName("location_check_points")
    public int locationCheckPoints;

    @SerializedName("players")
    public ArrayList<NetworkPlayer> networkPlayers = new ArrayList<>();

    @SerializedName("games")
    public ArrayList<String> games = new ArrayList<>();

    @SerializedName("datapackage_checksums")
    public HashMap<String, String> datapackageChecksums = new HashMap<>();

    @SerializedName("seed_name")
    public String seedName;

    @SerializedName("time")
    public double time;

    public RoomInfoPacket() {
        super(APPacketType.RoomInfo);
    }

    public NetworkPlayer getPlayer(int team, int slot) {
        for(NetworkPlayer player : networkPlayers) {
            if (player.slot == slot && player.team == team) {
                return player;
            }
        }
        return null;
    }
}

package dev.koifysh.archipelago.network.server;

import com.google.gson.annotations.SerializedName;
import dev.koifysh.archipelago.network.APPacket;
import dev.koifysh.archipelago.network.APPacketType;
import dev.koifysh.archipelago.network.RemainingMode;
import dev.koifysh.archipelago.parts.NetworkPlayer;
import dev.koifysh.archipelago.parts.Version;

import java.util.ArrayList;
import java.util.HashMap;

public class RoomUpdatePacket extends APPacket {

    @SerializedName("version")
    public Version version;

    @SerializedName("tags")
    public String[] tags;

    @SerializedName("password")
    public boolean password;

    @SerializedName("forfeit_mode")
    public RemainingMode.ForfeitMode forfeitMode;

    @SerializedName("remaining_mode")
    public RemainingMode remainingMode;

    @SerializedName("hint_cost")
    public int hintCost;

    @SerializedName("hint_points")
    public int hintPoints;

    @SerializedName("location_check_points")
    public int locationCheckPoints;

    @SerializedName("checked_locations")
    public ArrayList<Long> checkedLocations = new ArrayList<>();

    @SerializedName("missing_locations")
    public ArrayList<Long> missingLocations = new ArrayList<>();

    @SerializedName("players")
    public ArrayList<NetworkPlayer> networkPlayers = new ArrayList<>();

    @SerializedName("datapackage_version")
    public int datapackageVersion;

    @SerializedName("datapackage_checksums")
    public HashMap<String, String> datapackageChecksums = new HashMap<>();

    public RoomUpdatePacket() {
        super(APPacketType.RoomUpdate);
    }
}

package dev.koifysh.archipelago.network.server;

import com.google.gson.annotations.SerializedName;
import dev.koifysh.archipelago.network.APPacket;
import dev.koifysh.archipelago.network.APPacketType;

public class SetReplyPacket extends APPacket {
    @SerializedName("key")
    public String key;
    @SerializedName("value")
    public Object value;
    @SerializedName("original_value")
    public Object original_Value;
    @SerializedName("slot")
    public int slot;
    @SerializedName("request_id")
    public int requestID;

    public SetReplyPacket() {
        super(APPacketType.SetReply);
    }

}

package dev.koifysh.archipelago.parts;

import com.google.gson.annotations.Expose;
import com.google.gson.annotations.SerializedName;

import java.util.HashMap;
import java.util.Map;
import java.util.UUID;

public class DataPackage {

    @Expose
    @SerializedName("games")
    HashMap<String, Game> games = new HashMap<>();

    public String uuid = UUID.randomUUID().toString();

    public String getItem(long itemID, String game) {
        if (!games.containsKey(game))
            return String.format("Unknown Item [%d] for [%s]", itemID, game);

        if(!games.get(game).itemNameToId.containsValue(itemID))
            return String.format("Unknown Item [%d] for [%s]", itemID, game);

        return games.get(game).getItem(itemID);
    }

    public String getLocation(long locationID, String game) {
        if (!games.containsKey(game))
            return String.format("Unknown Location [%d] for [%s]", locationID, game);

        if (!games.get(game).locationNameToId.containsValue(locationID))
            return String.format("Unknown Location [%d] for [%s]", locationID, game);

        return games.get(game).getLocation(locationID);
    }

    public Map<String, String> getChecksums() {
        HashMap<String, String> checksums = new HashMap<>();
        games.forEach((key, value) -> checksums.put(key, value.checksum));
        return checksums;
    }

    public HashMap<String, Game> getGames() {
        return games;
    }

    public Game getGame(String game) {
        return games.get(game);
    }


    public String getUUID() {
        return uuid;
    }

    public void update(DataPackage newData) {
        games.putAll(newData.getGames());
    }
}

package dev.koifysh.archipelago.parts;

import com.google.gson.annotations.SerializedName;

import java.util.HashMap;
import java.util.Map;

public class Game {



    @SerializedName("checksum")
    public String checksum;

    @SerializedName("item_name_to_id")
    public HashMap<String,Long> itemNameToId = new HashMap<>();

    @SerializedName("location_name_to_id")
    public HashMap<String,Long> locationNameToId = new HashMap<>();

    private final HashMap<Long,String> idToItem = new HashMap<>();
    private final HashMap<Long,String> idToLocation = new HashMap<>();

    public String getItem(long itemID) {
        if(idToItem.isEmpty()) {
            for (Map.Entry<String, Long> entry : itemNameToId.entrySet()) {
                idToItem.put(entry.getValue(), entry.getKey());
            }
        }
        if (!idToItem.containsKey(itemID))
            return String.format("Unknown Item [%d]", itemID);

        return idToItem.get(itemID);
    }

    public String getLocation(long locationID) {
        if(idToLocation.isEmpty()) {
            for (Map.Entry<String, Long> entry : locationNameToId.entrySet()) {
                idToLocation.put(entry.getValue(), entry.getKey());
            }
        }
        if (!idToLocation.containsKey(locationID))
            return String.format("Unknown Location [%d]", locationID);

        return idToLocation.get(locationID);
    }
}

package dev.koifysh.archipelago.parts;

import com.google.gson.annotations.SerializedName;

public class NetworkItem {

    @SerializedName("item")
    public long itemID;

    @SerializedName("location")
    public long locationID;

    @SerializedName("player")
    public int playerID;

    /**
     * Bit flags that tell you information about the item. bitwise AND them with {@link dev.koifysh.archipelago.flags.NetworkItem} to read.
     */
    @SerializedName("flags")
    public int flags;


    public String itemName;
    public String locationName;
    public String playerName;

}

package dev.koifysh.archipelago.parts;

public class NetworkPlayer {
    public int team;

    public int slot;

    public String alias;

    public String name;

    public NetworkPlayer(int team, int slot, String name) {
        this.slot = slot;
        this.name = name;
        this.alias = name;
        this.team = team;
    }
}

package dev.koifysh.archipelago.parts;

import com.google.gson.annotations.SerializedName;

public class NetworkSlot {

    @SerializedName("name")
    public String name;

    @SerializedName("game")
    public String game;

    @SerializedName("type")
    public int type;

    public NetworkSlot(String name, String game, int type) {
        this.name = name;
        this.game = game;
        this.type = type;
    }
}

package dev.koifysh.archipelago.parts;

import com.google.gson.annotations.SerializedName;

public class Version {
    int major;
    int minor;
    int build;
    @SerializedName("class")
    String fakeClass = "Version";

    public Version(int major, int minor, int build) {
        this.major = major;
        this.minor = minor;
        this.build = build;
    }
}

package dev.koifysh.archipelago.Print;

import com.google.gson.annotations.SerializedName;
import dev.koifysh.archipelago.parts.NetworkItem;

public class APPrint {

    @SerializedName("data")
    public APPrintPart[] parts;

    @SerializedName("type")
    public APPrintJsonType type;

    @SerializedName("receiving")
    public int receiving;

    @SerializedName("item")
    public NetworkItem item;

    @SerializedName("found")
    public boolean found;

    @SerializedName("team")
    public String team;

    @SerializedName("slot")
    public int slot;

    @SerializedName("message")
    public String message;

    @SerializedName("tags")
    public String[] tags;

    @SerializedName("countdown")
    public int countdown;

    public String getPlainText() {
        StringBuilder sb = new StringBuilder();
        for (APPrintPart part : parts) {
            sb.append(part.text);
        }
        return sb.toString();
    }

}

package dev.koifysh.archipelago.Print;


import java.awt.*;

public enum APPrintColor {
    none,
    bold,
    underline,
    black(Color.black),
    red(Color.red),
    green(Color.green),
    yellow(Color.yellow),
    blue(Color.blue),
    magenta(Color.magenta),
    cyan(Color.cyan),
    white(Color.white),
    black_bg(Color.black),
    red_bg(Color.red),
    green_bg(Color.green),
    yellow_bg(Color.yellow),
    blue_bg(Color.blue),
    purple_bg(Color.decode("#800080")),
    cyan_bg(Color.cyan),
    white_bg(Color.white),
    gold(Color.decode("#FFD700"));

    public final Color color;

    APPrintColor() {
        this.color = Color.white;
    }

    APPrintColor(Color color) {
        this.color = color;
    }
}

package dev.koifysh.archipelago.Print;

import com.google.gson.annotations.SerializedName;

public enum APPrintJsonType {

    /**
     * A player received an item.
     */
    @SerializedName("ItemSend")
    ItemSend,

    /**
     * A player used the `!getitem` command.
     */
    @SerializedName("ItemCheat")
    ItemCheat,

    /**
     * A player hinted.
     */
    @SerializedName("Hint")
    Hint,

    /**
     * A player connected.
     */
    @SerializedName("Join")
    Join,

    /**
     * A player disconnected.
     */
    @SerializedName("Part")
    Part,

    /**
     * A player sent a chat message.
     */
    @SerializedName("Chat")
    Chat,

    /**
     * The server broadcast a message.
     */
    @SerializedName("ServerChat")
    ServerChat,

    /**
     * The client has triggered a tutorial message, such as when first connecting.
     */
    @SerializedName("entrance_name")
    Tutorial,

    /**
     * A player changed their tags.
     */
    @SerializedName("TagsChanged")
    TagsChanged,

    /**
     *  	Someone (usually the client) entered an ! command.
     */
    @SerializedName("CommandResult")
    CommandResult,

    /**
     * The client entered an !admin command.
     */
    @SerializedName("AdminCommandResult")
    AdminCommandResult,

    /**
     * A player reached their goal.
     */
    @SerializedName("Goal")
    Goal,

    /**
     * A player released the remaining items in their world.
     */
    @SerializedName("Release")
    Release,

    /**
     * A player collected the remaining items for their world.
     */
    @SerializedName("Collect")
    Collect,

    /**
     * The current server countdown has progressed.
     */
    @SerializedName("Countdown")
    Countdown,

    /**
     * The Message type was not set, or is invalid.
     */
    Unknown

}

package dev.koifysh.archipelago.Print;

public class APPrintPart {
    public APPrintType type = APPrintType.text;
    public APPrintColor color = APPrintColor.none;
    public String text = "";
    public int player = 0;
    public int flags = 0;

}

package dev.koifysh.archipelago.Print;

import com.google.gson.annotations.SerializedName;

public enum APPrintType {
    @SerializedName("text")
    text,
    @SerializedName("player_id")
    playerID,
    @SerializedName("player_name")
    playerName,
    @SerializedName("item_id")
    itemID,
    @SerializedName("item_name")
    itemName,
    @SerializedName("location_id")
    locationID,
    @SerializedName("location_name")
    locationName,
    @SerializedName("entrance_name")
    entranceName,
    @SerializedName("color")
    color

}

package dev.koifysh.archipelago;

import com.google.gson.Gson;
import com.google.gson.JsonArray;
import com.google.gson.JsonElement;
import com.google.gson.JsonParser;
import dev.koifysh.archipelago.Print.APPrint;
import dev.koifysh.archipelago.Print.APPrintJsonType;
import dev.koifysh.archipelago.Print.APPrintPart;
import dev.koifysh.archipelago.Print.APPrintType;
import dev.koifysh.archipelago.flags.NetworkPlayer;
import dev.koifysh.archipelago.helper.DeathLink;
import dev.koifysh.archipelago.network.APPacket;
import dev.koifysh.archipelago.network.ConnectionResult;
import dev.koifysh.archipelago.network.client.ConnectPacket;
import dev.koifysh.archipelago.network.client.GetDataPackagePacket;
import dev.koifysh.archipelago.network.client.LocationScouts;
import dev.koifysh.archipelago.network.client.SayPacket;
import dev.koifysh.archipelago.parts.DataPackage;
import dev.koifysh.archipelago.parts.NetworkItem;
import dev.koifysh.archipelago.events.*;
import dev.koifysh.archipelago.network.server.*;

import dev.koifysh.archipelago.parts.NetworkSlot;
import org.java_websocket.client.WebSocketClient;
import org.java_websocket.drafts.Draft;
import org.java_websocket.drafts.Draft_6455;
import org.java_websocket.extensions.permessage_deflate.PerMessageDeflateExtension;
import org.java_websocket.handshake.ServerHandshake;

import javax.net.ssl.SSLException;
import java.net.URI;
import java.net.URISyntaxException;
import java.util.*;
import java.util.logging.Level;

class WebSocket extends WebSocketClient {

    private final static java.util.logging.Logger LOGGER = java.util.logging.Logger.getLogger(WebSocket.class.getName());

    private final Client client;
    private final Gson gson;

    private boolean authenticated = false;

    private int reconnectAttempt = 0;

    private String seedName;
    private static Timer reconnectTimer;
    private boolean downgrade = false;

    private static final Draft perMessageDeflateDraft = new Draft_6455(new PerMessageDeflateExtension());

    private JsonParser parser;

    public WebSocket(URI serverUri, Client client, Gson gson) {
        super(serverUri, perMessageDeflateDraft);
        this.client = client;
        this.gson = gson;

        if (reconnectTimer != null) {
            reconnectTimer.cancel();
        }
        reconnectTimer = new Timer();

        parser = new JsonParser();
    }

    @Override
    public void onOpen(ServerHandshake handshakeData) {
    }

    @Override
    public void onMessage(String message) {
        try {
            LOGGER.fine("Got Packet: " + message);
            JsonElement element = parser.parse(message);
            JsonArray cmdList = element.getAsJsonArray();

            for (int commandNumber = 0; cmdList.size() > commandNumber; ++commandNumber) {
                JsonElement packet = cmdList.get(commandNumber);
                //parse the packet first to see what command has been sent.
                APPacket cmd = gson.fromJson(packet, APPacket.class);


                //check if room info packet
                switch (cmd.getCmd()) {
                    case RoomInfo:
                        RoomInfoPacket roomInfo = gson.fromJson(packet, RoomInfoPacket.class);

                        //save room info
                        client.setRoomInfo(roomInfo);

                        client.versions = roomInfo.datapackageChecksums;
                        client.games = roomInfo.games;

                        client.loadDataPackage();

                        checkDataPackage(roomInfo.datapackageChecksums, roomInfo.games);

                        seedName = roomInfo.seedName;

                        ConnectPacket connectPacket = new ConnectPacket();
                        connectPacket.version = Client.protocolVersion;
                        connectPacket.name = client.getMyName();
                        connectPacket.password = (client.getPassword() == null) ? "" : client.getPassword();
                        connectPacket.uuid = client.getUUID();
                        connectPacket.game = client.getGame();
                        connectPacket.tags = client.getTags();
                        connectPacket.itemsHandling = client.getItemsHandlingFlags();

                        //send reply
                        sendPacket(connectPacket);
                        client.setRoomInfo(roomInfo);
                        break;
                    case Connected:
                        ConnectedPacket connectedPacket = gson.fromJson(packet, ConnectedPacket.class);

                        client.setTeam(connectedPacket.team);
                        client.setSlot(connectedPacket.slot);
                        connectedPacket.slotInfo.put(0, new NetworkSlot("Archipelago", "Archipelago", NetworkPlayer.SPECTATOR));
                        client.setSlotInfo(connectedPacket.slotInfo);

                        client.getRoomInfo().networkPlayers.addAll(connectedPacket.players);
                        int teams = 1;
                        OptionalInt teamsOptional = client.getRoomInfo().networkPlayers.stream().mapToInt(player -> player.team).max();
                        if (teamsOptional.isPresent()) {
                            teams = teamsOptional.getAsInt() + 1;
                        }
                        for (int i = 0; i < teams; i++) {
                            client.getRoomInfo().networkPlayers.add( new dev.koifysh.archipelago.parts.NetworkPlayer(i, 0, "Archipelago"));
                        }

                        client.setAlias(client.getRoomInfo().getPlayer(connectedPacket.team, connectedPacket.slot).alias);

                        JsonElement slotData = packet.getAsJsonObject().get("slot_data");

                        ConnectionAttemptEvent attemptConnectionEvent = new ConnectionAttemptEvent(connectedPacket.team, connectedPacket.slot, seedName, slotData, gson);
                        client.getEventBus().post(attemptConnectionEvent);

                        if (!attemptConnectionEvent.isCanceled()) {
                            authenticated = true;
                            //only send locations if the connection is not canceled.
                            client.getLocationManager().addCheckedLocations(connectedPacket.checkedLocations);
                            client.getLocationManager().setMissingLocations(connectedPacket.missingLocations);
                            client.getLocationManager().sendIfChecked(connectedPacket.missingLocations);

                            ConnectionResultEvent connectionResultEvent = new ConnectionResultEvent(ConnectionResult.Success, connectedPacket.team, connectedPacket.slot, seedName, slotData, gson);
                            client.getEventBus().post(connectionResultEvent);
                        } else {
                            this.close();
                            //close out of this loop because we are no longer interested in further commands from the server.
                            break;
                        }
                        break;
                    case ConnectionRefused:
                        ConnectionRefusedPacket error = gson.fromJson(cmdList.get(commandNumber), ConnectionRefusedPacket.class);
                        client.getEventBus().post(new ConnectionResultEvent(error.errors[0], gson));
                        break;
                    case DataPackage:
                        JsonElement data = packet.getAsJsonObject().get("data");
                        DataPackage dataPackage = gson.fromJson(data, DataPackage.class);
                        dataPackage.uuid = client.getUUID();
                        client.updateDataPackage(dataPackage);
                        client.saveDataPackage();
                        break;
                    case PrintJSON:
                        LOGGER.finest("PrintJSON packet");
                        APPrint print = gson.fromJson(packet, APPrint.class);
                        if (print.type == null) print.type = APPrintJsonType.Unknown;
                        //filter though all player IDs and replace id with alias.
                        for (int partNumber = 0; print.parts.length > partNumber; ++partNumber) {
                            APPrintPart part = print.parts[partNumber];

                            if (part.type == APPrintType.playerID) {
                                int playerID = Integer.parseInt(part.text);
                                dev.koifysh.archipelago.parts.NetworkPlayer player = client.getRoomInfo().getPlayer(client.getTeam(), playerID);
                                part.text = player.alias;
                            }
                            else if (part.type == APPrintType.itemID) {
                                long itemID = Long.parseLong(part.text);
                                part.text = client.getDataPackage().getItem(itemID, client.getSlotInfo().get(part.player).game);
                            }
                            else if (part.type == APPrintType.locationID) {
                                long locationID = Long.parseLong(part.text);
                                part.text = client.getDataPackage().getLocation(locationID, client.getSlotInfo().get(part.player).game);
                            }
                        }

                        if (print.item != null) {
                            print.item.itemName = client.getDataPackage().getItem(print.item.itemID, client.getSlotInfo().get(print.item.playerID).game);
                            print.item.locationName = client.getDataPackage().getLocation(print.item.locationID, client.getSlotInfo().get(print.item.playerID).game);
                            print.item.playerName = client.getRoomInfo().getPlayer(client.getTeam(), print.item.playerID).alias;
                        }

                        client.getEventBus().post(new PrintJSONEvent(print, print.type, print.receiving, print.item));

                        break;
                    case RoomUpdate:
                        RoomUpdatePacket updatePacket = gson.fromJson(packet, RoomUpdatePacket.class);
                        updateRoom(updatePacket);
                        break;
                    case ReceivedItems:
                        ReceivedItemsPacket items = gson.fromJson(packet, ReceivedItemsPacket.class);
                        ItemManager itemManager = client.getItemManager();
                        itemManager.receiveItems(items.items, items.index);
                        break;
                    case Bounced:
                        BouncedPacket bounced = gson.fromJson(packet, BouncedPacket.class);
                        if (bounced.tags.contains("DeathLink"))
                            DeathLink.receiveDeathLink(bounced);
                        else
                            client.getEventBus().post(new BouncedEvent(bounced.games, bounced.tags, bounced.slots, bounced.data));
                        break;
                    case LocationInfo:
                        LocationInfoPacket locations = gson.fromJson(packet, LocationInfoPacket.class);
                        for (NetworkItem item : locations.locations) {
                            item.itemName = client.getDataPackage().getItem(item.itemID, client.getSlotInfo().get(item.playerID).game);
                            item.locationName = client.getDataPackage().getLocation(item.locationID, client.getSlotInfo().get(client.getSlot()).game);
                            item.playerName = client.getRoomInfo().getPlayer(client.getTeam(), item.playerID).alias;
                        }
                        client.getEventBus().post(new LocationInfoEvent(locations.locations));
                        break;
                    case Retrieved:
                        RetrievedPacket retrievedPacket = gson.fromJson(packet, RetrievedPacket.class);
                        client.getEventBus().post(new RetrievedEvent(retrievedPacket.keys, packet.getAsJsonObject().get("keys").getAsJsonObject(), retrievedPacket.requestID, gson));
                        break;
                    case SetReply:
                        SetReplyPacket setReplyPacket = gson.fromJson(packet, SetReplyPacket.class);
                        client.getEventBus().post(new SetReplyEvent(setReplyPacket.key, setReplyPacket.value, setReplyPacket.original_Value, packet.getAsJsonObject().get("value"), setReplyPacket.requestID, gson));
                        break;
                    case InvalidPacket:
                        InvalidPacket invalidPacket = gson.fromJson(packet, InvalidPacket.class);
                        client.getEventBus().post(new InvalidPacketEvent(invalidPacket.type, invalidPacket.Original_cmd, invalidPacket.text));
                    default:

                }
            }
        } catch (Exception e) {
            LOGGER.warning("Error proccessing incoming packet: " + e.getMessage());
        }
    }

    private void updateRoom(RoomUpdatePacket updateRoomPacket) {
        if (!updateRoomPacket.networkPlayers.isEmpty()) {
            client.getRoomInfo().networkPlayers = updateRoomPacket.networkPlayers;
        }

        client.setHintPoints(updateRoomPacket.hintPoints);
        client.setAlias(client.getRoomInfo().getPlayer(client.getTeam(), client.getSlot()).alias);

        client.getEventBus().post(new CheckedLocationsEvent(updateRoomPacket.checkedLocations));
    }


    private void checkDataPackage(HashMap<String, String> versions, List<String> games) {
        Set<String> gamesToUpdate = new HashSet<>();
        Map<String, String> checksums = client.getDataPackage().getChecksums();
        for (Map.Entry<String, String> game : versions.entrySet()) {
            if (!games.contains(game.getKey()))
                continue;

            if (!checksums.containsKey(game.getKey())) {
                gamesToUpdate.add(game.getKey());
                continue;
            }

            if (!checksums.get(game.getKey()).equals(game.getValue()))
                gamesToUpdate.add(game.getKey());
        }


        if (!gamesToUpdate.isEmpty()) {
            fetchDataPackageFromAP(gamesToUpdate);
        }
    }

    private void fetchDataPackageFromAP(Set<String> games) {
        sendPacket(new GetDataPackagePacket(games));
    }

    public void sendPacket(APPacket packet) {
        sendManyPackets(new APPacket[]{packet});
    }

    private void sendManyPackets(APPacket[] packet) {
        if (!isOpen())
            return;
        String json = gson.toJson(packet);
        LOGGER.fine("Sent Packet: " + json);
        send(json);
    }

    @Override
    public void onClose(int code, String wsReason, boolean remote) {
        LOGGER.fine(String.format("Connection closed by %s Code: %s Reason: %s", (remote ? "remote peer" : "us"), code, wsReason));
        String reason = (wsReason.isEmpty()) ? "Connection refused by the Archipelago server." : wsReason;
        if (code == -1) {
            reconnectTimer.cancel();

            // attempt to reconnect using non-secure web socket if we are failing to connect with a secure socket.
            if (uri.getScheme().equalsIgnoreCase("wss") && downgrade) {
                try {
                    URI wsUri = new URI(String.format("ws://%s:%s",uri.getHost(),uri.getPort()));
                    client.connect(wsUri);
                } catch (URISyntaxException ignored) {
                    client.onClose("(AP-275) " + reason, 0);
                }
                return;
            }
            client.onClose("(AP-279) " + reason, 0);
            return;
        }
        if (code == 1000) {
            reconnectTimer.cancel();
            client.onClose("(AP-284) Disconnected.", 0);
        }

        if (code == 1006) {
            reason = "Lost connection to the Archipelago server.";
            if (reconnectAttempt <= 10) {
                int reconnectDelay = (int) (5000 * Math.pow(2, reconnectAttempt));
                reconnectAttempt++;
                TimerTask reconnectTask = new TimerTask() {
                    @Override
                    public void run() {
                        client.reconnect();
                    }
                };

                reconnectTimer.cancel();
                reconnectTimer = new Timer();
                reconnectTimer.schedule(reconnectTask, reconnectDelay);
                client.onClose("(AP-302)  " + reason, reconnectDelay / 1000);
                return;
            }
        }

        reconnectTimer.cancel();
        client.onClose("(AP-308) "+reason, 0);
    }

    @Override
    public void onError(Exception ex) {
        if (ex instanceof SSLException) {
            LOGGER.info(String.format("SSL Error: %s", ex.getMessage()));
            return;
        }
        client.onError(ex);
        LOGGER.log(Level.WARNING, "Error in websocket connection: " + ex.getMessage());
    }

    public void connect(boolean allowDowngrade) {
        super.connect();
        reconnectTimer.cancel();
        reconnectAttempt = 0;
        this.downgrade = allowDowngrade;
    }

    public void sendChat(String message) {
        SayPacket say = new SayPacket(message);
        sendPacket(say);
    }

    public boolean isAuthenticated() {
        return authenticated;
    }

    public void scoutLocation(ArrayList<Long> locationIDs) {
        LocationScouts packet = new LocationScouts(locationIDs);
        sendPacket(packet);
    }
}

package gg.archipelago;

import com.google.gson.Gson;
import dev.koifysh.archipelago.flags.ItemsHandling;
import gg.archipelago.apEvents.ConnectionResult;
import gg.archipelago.apEvents.PrintJson;
import gg.archipelago.apEvents.ReceiveItem;
import dev.koifysh.archipelago.Client;

import lombok.extern.slf4j.Slf4j;
import net.runelite.client.RuneLite;
import net.runelite.client.eventbus.EventBus;

import java.net.URISyntaxException;

@Slf4j
public class APClient extends Client {

    private ArchipelagoPlugin plugin;

    public APClient(ArchipelagoPlugin plugin, Gson gson, EventBus bus){
        super(RuneLite.RUNELITE_DIR + "/APData/DataPackage.ser", gson, bus);
        this.setGame("Old School Runescape");
        this.plugin = plugin;
    }

    // These variables are stored so we can unsubscribe on disconnect
    private Object connectionListener, itemListener, printListener;
    public void newConnection(ArchipelagoPlugin plugin, String address, String slotName, String password) {
        setGame("Old School Runescape");
        setPassword(password);
        setName(slotName);
        setItemsHandlingFlags(ItemsHandling.SEND_ITEMS + ItemsHandling.SEND_OWN_ITEMS + ItemsHandling.SEND_STARTING_INVENTORY);


        connectionListener = new ConnectionResult();
        itemListener = new ReceiveItem();
        printListener = new PrintJson();

        getEventBus().register(connectionListener);
        getEventBus().register(itemListener);
        getEventBus().register(printListener);

        try {
            connect(address);
        } catch (URISyntaxException e) {

        }
    }

    @Override
    public void onError(Exception e) {
        ArchipelagoPlugin.plugin.DisplayNetworkMessage("Server Error: " + e.getMessage());
        disconnect();
    }

    @Override
    public void onClose(String message, int i) {
        //ArchipelagoPanel.apPanel.statusText.setText("Connection Closed NL " + message);
        disconnect();
    }

    @Override
    public void disconnect(){
        super.disconnect();
        plugin.SetConnectionState(false);
        getEventBus().unregister(connectionListener);
        getEventBus().unregister(itemListener);
        getEventBus().unregister(printListener);

    }
}

package gg.archipelago.apEvents;

import gg.archipelago.ArchipelagoPlugin;
import dev.koifysh.archipelago.events.ConnectionResultEvent;
import gg.archipelago.SlotData;
import net.runelite.client.eventbus.Subscribe;

public class ConnectionResult {

    @Subscribe
    public void onConnectionResultEvent(ConnectionResultEvent event) {
        if (event.getResult() == null) return;

        String msg;
        switch (event.getResult()) {
            case SlotAlreadyTaken:
                msg = "Slot already in use.";
                break;
            case Success:
                msg = "Connection Successful.";
                break;
            case InvalidSlot:
                msg = "Invalid Slot Name. Please make sure you typed it correctly.";
                break;
            case InvalidPassword:
                msg = "Invalid Password";
                break;
            case IncompatibleVersion:
                msg = "Server Rejected our connection due to an incompatible communication protocol.";
                break;
            default:
                msg = "Unknown Error";
        }
        ArchipelagoPlugin.plugin.DisplayNetworkMessage(msg);
        if (event.getSlotData(SlotData.class) != null){
            ArchipelagoPlugin.plugin.SetSlotData(event.getSlotData(SlotData.class));
        }
        ArchipelagoPlugin.plugin.SetConnectionState(event.getResult() == dev.koifysh.archipelago.network.ConnectionResult.Success);
    }
}

package gg.archipelago.apEvents;

import dev.koifysh.archipelago.Print.APPrintPart;
import dev.koifysh.archipelago.events.PrintJSONEvent;
import gg.archipelago.ArchipelagoPlugin;
import net.runelite.client.eventbus.Subscribe;

public class PrintJson {

    @Subscribe
    public void onPrintJSONEvent(PrintJSONEvent event) {
        if ("Join".equals(event.apPrint.type) || "Tutorial".equals(event.apPrint.type)) return;
        StringBuilder msgBuilder = new StringBuilder();
        for (APPrintPart part : event.apPrint.parts){
            msgBuilder.append(part.text);
        }
        ArchipelagoPlugin.plugin.DisplayChatMessage(msgBuilder.toString());
    }
}

package gg.archipelago.apEvents;

import gg.archipelago.ArchipelagoPlugin;
import dev.koifysh.archipelago.events.ReceiveItemEvent;
import net.runelite.client.eventbus.Subscribe;

public class ReceiveItem {

    @Subscribe
    public void onReceiveItemEvent(ReceiveItemEvent event) {
        ArchipelagoPlugin.plugin.ReceiveItem(event);
    }
}
package gg.archipelago;

import net.runelite.client.config.Config;
import net.runelite.client.config.ConfigGroup;
import net.runelite.client.config.ConfigItem;

@ConfigGroup("Archipelago")
public interface ArchipelagoConfig extends Config
{
	@ConfigItem(
		keyName = "address",
		name = "Server Address",
		description = "The URL of the server to connect to",
			position = 0
	)
	default String address()
	{
		return "localhost";
	}

	@ConfigItem(
			keyName = "port",
			name = "Server Port",
			description = "The Port of the server to connect to",
			position = 1
	)
	default String port()
	{
		return "38281";
	}

	@ConfigItem(
			keyName = "slotname",
			name = "Slot Name",
			description = "The Player slot to connect to",
			position = 2
	)
	default String slotname()
	{
		return "";
	}

	@ConfigItem(
			keyName = "password",
			name = "Server Password",
			description = "The Password of the server to connect to",
			secret = true,
			position = 3
	)
	default String password()
	{
		return "";
	}

	@ConfigItem(
			keyName = "apMessages",
			name = "Display AP Messages in Chat",
			description = "Whether or not to display messages, such as sending and receiving items, in chat.",
			position = 5
	)
	default boolean apMessages() { return true; }
}

package gg.archipelago;

import lombok.AllArgsConstructor;
import lombok.Data;

@Data
@AllArgsConstructor
public class ArchipelagoLocation {
    private String LocationName;
    private boolean LocationChecked;
}

package gg.archipelago;

import net.runelite.client.eventbus.EventBus;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.PluginPanel;
import javax.swing.*;
import javax.swing.border.EmptyBorder;
import java.awt.*;

public class ArchipelagoPanel extends PluginPanel {

    private final ArchipelagoPlugin plugin;
    private final ArchipelagoConfig config;

    private final TaskPanel taskListPanel;
    private final ItemPanel itemListPanel;

    private final JLabel messageLabel;

    ArchipelagoPanel(final ArchipelagoPlugin plugin, final ArchipelagoConfig config)
    {
        this.plugin = plugin;
        this.config = config;

        setBorder(new EmptyBorder(6, 6, 6, 6));
        setBackground(ColorScheme.DARK_GRAY_COLOR);
        setLayout(new BorderLayout());

        // Create layout panel for wrapping
        final JPanel layoutPanel = new JPanel();
        layoutPanel.setLayout(new BoxLayout(layoutPanel, BoxLayout.Y_AXIS));
        add(layoutPanel, BorderLayout.NORTH);

        final JPanel statusPanel = buildStatusPanel();
        layoutPanel.add(statusPanel);
        //layoutPanel.add(Box.createRigidArea(new Dimension(0, 5)));
        //JLabel versionLabel = new JLabel("plugin version 2.1");
        //versionLabel.setAlignmentX(Component.LEFT_ALIGNMENT);
        //layoutPanel.add(versionLabel);

        messageLabel = new JLabel("");
        messageLabel.setAlignmentX(Component.LEFT_ALIGNMENT);
        messageLabel.setBorder(new EmptyBorder(5, 5, 5, 10));
        layoutPanel.add(messageLabel);

        taskListPanel = new TaskPanel(plugin);
        layoutPanel.add(taskListPanel);
        //layoutPanel.add(Box.createRigidArea(new Dimension(0, 5)));

        itemListPanel = new ItemPanel(plugin);
        layoutPanel.add(itemListPanel);
    }

    private JButton connectButton;

    private JPanel buildStatusPanel(){
        final JPanel statusPanel = new JPanel();
        statusPanel.setLayout(new GridLayout(2, 1));
        statusPanel.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        statusPanel.setPreferredSize(new Dimension(Integer.MAX_VALUE, 80));
        statusPanel.setBorder(new EmptyBorder(5, 5, 5, 10));
        statusPanel.setVisible(true);

        JLabel instructionText = new JLabel("<html>Server address, port, and slot can be found in plugin settings.</html>");
        instructionText.setPreferredSize(new Dimension(Integer.MAX_VALUE, 30));
        instructionText.setBorder(new EmptyBorder(5, 5, 5, 10));

        connectButton = new JButton("Connect");
        connectButton.setPreferredSize(new Dimension(Integer.MAX_VALUE, 30));
        connectButton.setBorder(new EmptyBorder(5, 5, 5, 10));

        statusPanel.add(instructionText);
        statusPanel.add(connectButton);
        connectButton.addActionListener(e -> {
            plugin.ConnectToAPServer();
        });

        statusPanel.setAlignmentX(Component.LEFT_ALIGNMENT);
        return statusPanel;
    }

    public void ConnectionStateChanged(boolean connectionSuccessful) {
        UpdateStatusButton(connectionSuccessful);
    }

    public void UpdateStatusButton(boolean connectionSuccessful){
        connectButton.setEnabled(!connectionSuccessful);
        connectButton.setText(connectionSuccessful ? "Connected!" : "Connect");
    }

    public void DisplayNetworkMessage(String message){
        String formattedMessage = String.format("<html><body style=\"text-align: justify;  text-justify: inter-word;\">%s</body></html>",message);
        messageLabel.setText(formattedMessage);
    }

    public void RegisterListeners(EventBus eventBus){
        eventBus.register(taskListPanel);
        eventBus.register(itemListPanel);
    }

    public void UnregisterListeners(EventBus eventBus){
        eventBus.unregister(taskListPanel);
        eventBus.unregister(itemListPanel);
    }
}

package gg.archipelago;

import com.google.gson.Gson;
import dev.koifysh.archipelago.events.ReceiveItemEvent;
import gg.archipelago.Tasks.APTask;
import gg.archipelago.data.ItemData;
import gg.archipelago.data.ItemNames;
import com.google.inject.Provides;
import javax.inject.Inject;

import dev.koifysh.archipelago.ClientStatus;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.*;
import net.runelite.api.events.*;
import net.runelite.api.widgets.ComponentID;
import net.runelite.api.widgets.Widget;
import net.runelite.api.widgets.WidgetModalMode;
import net.runelite.client.RuneLite;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.eventbus.EventBus;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.events.ChatboxInput;
import net.runelite.client.events.NpcLootReceived;
import net.runelite.client.game.SpriteManager;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.plugins.PluginDescriptor;
import net.runelite.client.ui.ClientToolbar;
import net.runelite.client.ui.NavigationButton;
import net.runelite.client.ui.overlay.OverlayManager;
import net.runelite.client.util.ImageUtil;
import net.runelite.client.util.Text;

import java.awt.image.BufferedImage;
import java.io.*;
import java.nio.charset.StandardCharsets;
import java.util.*;
import java.util.stream.Collectors;

@Slf4j
@PluginDescriptor(
	name = "Archipelago Randomizer"
)
public class ArchipelagoPlugin extends Plugin
{
	public static ArchipelagoPlugin plugin;

	@Inject
	private Client client;
	@Inject
	private EventBus eventBus;
	@Inject
	private ClientThread clientThread;
	@Inject
	private ArchipelagoConfig config;
	@Inject
	private ClientToolbar clientToolbar;
	@Inject
	private SpriteManager spriteManager;
	@Inject
	private ConfigManager configManager;
	@Inject
	private Gson gson;
	@Inject
	private OverlayManager overlayManager;
	@Inject
	private IllegalRegionOverlay overlay;

	public boolean currentlyLoggedIn;
	public boolean connected;
	private boolean pendingConnection;

	protected List<APTask> activeTasks = new ArrayList<>();

	private ArchipelagoPanel panel;
	private APClient apClient;
	private int modIconIndex = -1;
	private final List<ItemData> collectedItems = new ArrayList<>();

	//This boolean will become true when we log in, and will be set back to false in the first game tick.
	//This lets us check if the logged in player should auto-connect to AP
	private boolean justLoggedIn = false;

	private Queue<String[]> queuedMessages = new LinkedList<>();
	private boolean isDisplayingPopup = false;

	private NavigationButton navButton;

	private SlotData slotData;

	private String dataPackageLocation;
	private DataPackage dataPackage;
	private long lastItemReceivedIndex = 0;

	@Provides
	ArchipelagoConfig provideConfig(ConfigManager configManager)
	{
		return configManager.getConfig(ArchipelagoConfig.class);
	}

	@Override
	protected void startUp() throws Exception
	{
		plugin = this;
		panel = new ArchipelagoPanel(this, config);
		apClient = new APClient(this, gson, eventBus);

		final BufferedImage icon = ImageUtil.loadImageResource(getClass(), "panel_icon.png");

		navButton = NavigationButton.builder()
				.tooltip("Archipelago Randomizer")
				.icon(icon)
				.priority(20)
				.panel(panel)
				.build();

		clientToolbar.addNavigation(navButton);

		loadSprites();
		clientThread.invoke(() -> client.runScript(ScriptID.CHAT_PROMPT_INIT));
		overlayManager.add(overlay);

		panel.RegisterListeners(eventBus);
	}

	@Override
	protected void shutDown() throws Exception
	{
		clientToolbar.removeNavigation(navButton);
		plugin = null;
		if (apClient != null && apClient.isConnected())
		{
			apClient.disconnect();
		}
		clientThread.invoke(() -> client.runScript(ScriptID.CHAT_PROMPT_INIT));
		overlayManager.remove(overlay);

		panel.UnregisterListeners(eventBus);
	}

	@Subscribe
	public void onScriptCallbackEvent(ScriptCallbackEvent event)
	{
		if (!event.getEventName().equals("setChatboxInput"))
		{
			return;
		}

		updateChatbox();
	}

	@Subscribe
	public void onBeforeRender(BeforeRender event)
	{
		updateChatbox(); // this stops flickering when typing
	}

	@Subscribe
	public void onGameStateChanged(GameStateChanged gameStateChanged)
	{
		//client.addChatMessage(ChatMessageType.GAMEMESSAGE, "AP", "Changed to State: "+gameStateChanged.getGameState().name(), null);
		log.debug("Changed to State: "+gameStateChanged.getGameState().name());

		if (gameStateChanged.getGameState() == GameState.LOGGED_IN && !currentlyLoggedIn)
		{
			dataPackageLocation = RuneLite.RUNELITE_DIR + "/APData/" + client.getAccountHash() + ".save";
			log.info("Logged in, checking for AP Save file at "+dataPackageLocation);
			loadDataPackage();
			currentlyLoggedIn = true;
			justLoggedIn = true;
			if (!apClient.isConnected() && !dataPackage.address.isEmpty() && !dataPackage.port.isEmpty() && !dataPackage.slotName.isEmpty()) {
				ConnectToAPServer(dataPackage.address, dataPackage.port, dataPackage.slotName, dataPackage.password);
			} else {
				DisplayNetworkMessage("No automatic reconnect defined for this character, please connect manually");
			}
		}
		else if (gameStateChanged.getGameState() == GameState.LOGIN_SCREEN){
			currentlyLoggedIn = false;
			if (connected){
				connected = false;
				apClient.disconnect();

				panel.ConnectionStateChanged(false);
			}
		}
	}
	@Subscribe
	public void onGameTick(GameTick tick){
		for (APTask task : activeTasks){
			task.OnGameTick(client);
		}
	}

	@Subscribe
	public void onClientTick(ClientTick t)
	{
		//client.addChatMessage(ChatMessageType.GAMEMESSAGE, "AP", client.getSelectedWidget().getName(), null);
		
		if (justLoggedIn && client.getLocalPlayer().getName() != null){
			// If we just logged in, and the data package's stored seed doesn't match the one we're connected to,
			// Disconnect immediately before checks get sent
			if (connected && !dataPackage.seed.equals(apClient.getRoomInfo().seedName)){
				apClient.disconnect();
				log.info("Detected log in of a non-auto-reconnect player. Disconnecting from server to avoid mixing checks");
				DisplayNetworkMessage("This Character is associated with a different Archipelago Seed. The slot has been " +
						"disconnected to avoid erroneously completing tasks based on this character's state. "+
						"If you wish to use this character for this Archipelago Seed, click \"Connect\" above to "+
						"reconnect to this slot and associate this character with that seed");
			}
			justLoggedIn = false;
		}
		if (!justLoggedIn && currentlyLoggedIn && connected){
			checkStatus();
			SendChecks();
			UpdateSlotData();

			if (!isDisplayingPopup && queuedMessages.size() > 0 && client.getWidget((161 << 16) | 13) != null){
				String[] msg = queuedMessages.poll();
				isDisplayingPopup = true;
				clientThread.invokeLater(() -> {
					DisplayPopupMessage(msg[0],msg[1]);
				});
			}
		}
		// If we've lost connection since last tick, we want to update the button.
		panel.UpdateStatusButton(apClient.isConnected());
	}

	@Subscribe
	public void onNpcLootReceived(final NpcLootReceived npcLootReceived)
	{
		final NPC npc = npcLootReceived.getNpc();
		for(APTask task : activeTasks){
			task.CheckMobKill(npc);
		}
	}

	@Subscribe
	public void onChatMessage(ChatMessage event)
	{
		for (APTask task : activeTasks){
			task.CheckChatMessage(event);
		}

		if (event.getName() == null || client.getLocalPlayer() == null
				|| client.getLocalPlayer().getName() == null || !apClient.isConnected())
			return;

		boolean isLocalPlayer =
				Text.standardize(event.getName()).equalsIgnoreCase(Text.standardize(client.getLocalPlayer().getName()));

		if (isLocalPlayer)
		{
			String text = "<img=" + modIconIndex + ">"+ Text.removeTags(event.getName());
			event.getMessageNode().setName(text);
		}
	}

	@Subscribe
	public void onChatboxInput(ChatboxInput chatboxInput)
	{
		final String message = chatboxInput.getValue();

		String command = extractCommand(message);
		if ("!ap".equals(command)){
			String cmd = message.substring(3);
			apClient.sendChat(cmd);
			log.info("Sending string to AP: "+cmd);
			chatboxInput.consume();
		}
	}

	@Subscribe
	public void onMenuOptionClicked(MenuOptionClicked event){
		if (connected){
			if (event.getMenuOption().equals("Wear") || event.getMenuOption().equals("Wield")){
				//If we are equipping an item
				if (event.getItemId() != -1){
					if (!IsItemAllowed((event.getItemId()))){
						event.consume();
						client.addChatMessage(ChatMessageType.GAMEMESSAGE, "AP", "<img=" + modIconIndex + ">"+"You have not unlocked the ability to equip this item", null);
					}
				}
			}

			if (event.getWidget() != null){
				String widgetName = Text.removeTags(event.getWidget().getName());

				//Disallow teleports to locked areas
				if (widgetName.equalsIgnoreCase("Varrock Teleport")){
					if (getCollectedItems().stream().noneMatch(it -> it.name.equals("Area: Central Varrock"))){
						event.consume();
						client.addChatMessage(ChatMessageType.GAMEMESSAGE, "AP", "<img=" + modIconIndex + ">"+"You have not unlocked that map region yet.", null);
					}
				}

				if (widgetName.equalsIgnoreCase("Lumbridge Teleport") || widgetName.equalsIgnoreCase("Lumbridge Home Teleport")){
					if (getCollectedItems().stream().noneMatch(it -> it.name.equals("Area: Lumbridge"))){
						event.consume();
						client.addChatMessage(ChatMessageType.GAMEMESSAGE, "AP", "<img=" + modIconIndex + ">"+"You have not unlocked that map region yet.", null);
					}
				}

				if (widgetName.equalsIgnoreCase("Falador Teleport")){
					if (getCollectedItems().stream().noneMatch(it -> it.name.equals("Area: Falador"))){
						event.consume();
						client.addChatMessage(ChatMessageType.GAMEMESSAGE, "AP", "<img=" + modIconIndex + ">"+"You have not unlocked that map region yet.", null);
					}
				}
			}
		}

		for (APTask task : activeTasks){
			task.OnMenuOption(event);
		}
	}

	@Subscribe
	public void onItemContainerChanged(ItemContainerChanged event)
	{
		ItemContainer container = event.getItemContainer();

		if (container == client.getItemContainer(InventoryID.INVENTORY))
		{
			Item[] items = container.getItems();
		}
	}

	private boolean IsItemAllowed(int itemId){
		if (ItemHandler.MetalWeaponItemIds.contains(itemId)){
			int itemTier = (int) getCollectedItems().stream().filter(it -> it.name.equals(ItemNames.Progressive_Weapons)).count();
			for (int i=0; i <= itemTier; i++){
				if (Arrays.asList(ItemHandler.MetalWeaponsPermittedByTier.get(i)).contains(itemId)){
					return true;
				}
			}
			return false;
		} else if (ItemHandler.MetalArmorItemIds.contains(itemId)){
			int itemTier = (int) getCollectedItems().stream().filter(it -> it.name.equals(ItemNames.Progressive_Armor)).count();
			for (int i=0; i <= itemTier; i++){
				if (Arrays.asList(ItemHandler.MetalArmorPermittedByTier.get(i)).contains(itemId)){
					return true;
				}
			}
			return false;
		} else if (ItemHandler.RangeWeaponItemIds.contains(itemId)){
			int itemTier = (int) getCollectedItems().stream().filter(it -> it.name.equals(ItemNames.Progressive_Range_Weapon) || it.name.equals(ItemNames.Progressive_Range_Weapon_Legacy)).count();
			for (int i=0; i <= itemTier; i++){
				if (Arrays.asList(ItemHandler.RangeWeaponsPermittedByTier.get(i)).contains(itemId)){
					return true;
				}
			}
			return false;
		} else if (ItemHandler.RangeArmorItemIds.contains(itemId)){
			int itemTier = (int) getCollectedItems().stream().filter(it -> it.name.equals(ItemNames.Progressive_Range_Armor)).count();
			for (int i=0; i <= itemTier; i++){
				if (Arrays.asList(ItemHandler.RangeArmorPermittedByTier.get(i)).contains(itemId)){
					return true;
				}
			}
			return false;
		}
		//If it's not in any of those lists, it's fine
		return true;
	}

	public void SetConnectionState(boolean newConnectionState){
		// Whether it succeeds or fails, we are no longer waiting for an answer, so we can un-set this right away
		pendingConnection = false;
		// If we've just reconnected, check all our tasks and items
		if (newConnectionState){
			activeTasks = new ArrayList<>();
			for(long id : apClient.getLocationManager().getCheckedLocations()){
				APTask task = TaskLists.GetTaskByID(id);
				if (task != null){
					task.SetCompleted();
					activeTasks.add(task);
				}
			}

			for(long id : apClient.getLocationManager().getMissingLocations()){
				APTask task = TaskLists.GetTaskByID(id);
				if (task != null){
					activeTasks.add(task);
				}
			}

			activeTasks = activeTasks.stream().sorted(Comparator.comparing(APTask::GetID)).collect(Collectors.toList());

			if (dataPackage != null && dataPackage.slotName.isEmpty()){
				log.info("Detected first log in or connection, storing data");
				UpdateSlotData();
			}
		}

		if (connected != newConnectionState)
			panel.ConnectionStateChanged(newConnectionState);
		connected = newConnectionState;
	}

	private void UpdateSlotData(){
		String connectedAddress = apClient.getConnectedAddress();
		String address = connectedAddress.substring(0, connectedAddress.lastIndexOf(':'));
		String port = connectedAddress.substring(connectedAddress.lastIndexOf(':')+1);

		dataPackage.address = address;
		dataPackage.port = port;
		dataPackage.slotName = apClient.getMyName();
		dataPackage.password = apClient.getPassword();
		dataPackage.seed = apClient.getRoomInfo().seedName;


		saveDataPackage();
	}

	public void ReceiveItem(ReceiveItemEvent event){
		//Check against our local copy of the last item received index to add it to the inventory
		if (event.getIndex() >= lastItemReceivedIndex){
			addCollectedItem(ItemHandler.ItemsById.get(event.getItemID()));
			lastItemReceivedIndex = event.getIndex();
			//Check against the datapaackage to determine if we popup a message
			if (event.getIndex() > dataPackage.lastItemReceivedIndex){
				dataPackage.lastItemReceivedIndex = event.getIndex();
				String messageBody = "Received from " +
						event.getPlayerName() +
						" at " +
						event.getLocationName();
				QueuePopupMessage(event.getItemName(), messageBody);
				saveDataPackage();
			}
		}
	}

	public void DisplayChatMessage(String msg)
	{
		if (config.apMessages()){
			clientThread.invoke(() ->
					client.addChatMessage(ChatMessageType.GAMEMESSAGE, "AP", "<img=" + modIconIndex + ">"+msg, null)
			);
		}
	}

	private void checkStatus()
	{
		for (APTask task : activeTasks){
			task.CheckPlayerStatus(client);
		}

		if(Quest.DRAGON_SLAYER_I.getState(client) == QuestState.FINISHED){
			apClient.setGameState(ClientStatus.CLIENT_GOAL);
		}
	}

	public void ConnectToAPServer(){
		if (pendingConnection) return;
		DisplayNetworkMessage("Connecting...");
		pendingConnection = true;
		ConnectToAPServer(config.address(), config.port(), config.slotname(), config.password());
	}

	public void ConnectToAPServer(String address, String port, String slotName, String password)
	{
		String uri = address+":"+port;
		log.info(uri);
		apClient.newConnection(this, uri, slotName, password);
	}

	private String extractCommand(String message)
	{
		int idx = message.indexOf(' ');
		if (idx == -1)
		{
			return message;
		}

		return message.substring(0, idx);
	}

	private void updateChatbox()
	{
		Widget chatboxTypedText = client.getWidget(ComponentID.CHATBOX_INPUT);

		if (chatboxTypedText == null || chatboxTypedText.isHidden() || !apClient.isConnected())
		{
			return;
		}

		String[] chatbox = chatboxTypedText.getText().split(":", 2);
		String rsn = Objects.requireNonNull(client.getLocalPlayer()).getName();

		String text = "<img=" + modIconIndex + ">" + Text.removeTags(rsn) + ":" + chatbox[1];
		chatboxTypedText.setText(text);
	}

	private void SendChecks()
	{
		Collection<Long> checkedLocations = activeTasks.stream()
				.filter(APTask::IsCompleted)
				.map(APTask::GetID)
				.collect(Collectors.toList());

		if (apClient != null && apClient.isConnected()){
			apClient.checkLocations(checkedLocations);
		}
	}

	public void addCollectedItem(ItemData item){
		if (item == null){
			log.warn("Null Item received");
			return;
		}
		log.info("Received item: "+item.name);
		collectedItems.add(item);
		UpdateAvailableChunks();
	}

	private void UpdateAvailableChunks(){
		List<String> unlockedRegions = new ArrayList<>();
		for (ItemData item : collectedItems){
			String regions = ItemHandler.RegionNamesToChunkIdString.getOrDefault(item.name, null);
			if (regions != null) unlockedRegions.add(regions);
		}
		String csv = Text.toCSV(unlockedRegions);
		//TODO replace dependency on regionlocker with custom solution. Good enough for now though
		configManager.setConfiguration("regionlocker", "unlockedRegions", csv);
	}

	private void saveDataPackage() {
		try {
			File dataPackageFile = new File(dataPackageLocation);

			dataPackageFile.getParentFile().mkdirs();
			dataPackageFile.createNewFile();

			Writer writer = new OutputStreamWriter(new FileOutputStream(dataPackageFile), StandardCharsets.UTF_8);
			String s = gson.toJson(dataPackage);
			gson.toJson(dataPackage, writer);
			writer.flush();
			writer.close();
		} catch (IOException e) {
			log.error("unable to save DataPackage.");
		}
	}

	private void loadDataPackage() {
		try {
			FileInputStream fileInput = new FileInputStream(dataPackageLocation);
			dataPackage = gson.fromJson(new InputStreamReader(fileInput, StandardCharsets.UTF_8), DataPackage.class);
			fileInput.close();

		} catch (IOException e) {
			log.info("no dataPackage found creating a new one.");
			dataPackage = new DataPackage();
			saveDataPackage();
		}
	}

	public void ClaimCarePack(long itemId){
		dataPackage.claimedCarePacks.add(itemId);
		saveDataPackage();
	}

	public int CheckClaimedCarePacks(long itemId){
		return Collections.frequency(dataPackage.claimedCarePacks, itemId);
	}

	public List<ItemData> getCollectedItems() {
		return collectedItems;
	}
	public void DisplayNetworkMessage(String message){
		panel.DisplayNetworkMessage(message);
	}
	public void SetSlotData(SlotData data){

		this.slotData = data;
		TaskLists.GetAllTasks(slotData.data_csv_tag);
		ItemHandler.GetAllItems(slotData.data_csv_tag);

		//loadSprites();
		clientThread.invoke(() -> TaskLists.LoadImages(spriteManager));
		clientThread.invoke(() -> ItemHandler.LoadImages(spriteManager));
	}

	public String getCurrentPlayerName(){
		if (client.getLocalPlayer() == null) return "";
		return client.getLocalPlayer().getName();
	}

	/////////// SPRITES ///////////
	private void loadSprites()
	{
		clientThread.invoke(() ->
		{
			//If we already have the mod icon, we don't need to do it again
			if (modIconIndex > -1) return;

			IndexedSprite[] modIcons = client.getModIcons();
			List<IndexedSprite> newList = new ArrayList<>();

			modIconIndex = modIcons.length;

			final IndexedSprite sprite = getIndexedSpriteEmbedded();

			newList.add(sprite);

			IndexedSprite[] newAry = Arrays.copyOf(modIcons, modIcons.length + newList.size());
			System.arraycopy(newList.toArray(new IndexedSprite[0]), 0, newAry, modIcons.length, newList.size());
			client.setModIcons(newAry);
		});
	}
	private IndexedSprite getIndexedSpriteEmbedded()
	{
		try
		{
			BufferedImage image = ImageUtil.loadImageResource(this.getClass(), "chat_icon.png");
			return ImageUtil.getImageIndexedSprite(image, client);
		}
		catch (RuntimeException ex)
		{
			log.debug("Unable to load image: ", ex);
		}
		return null;
	}
	/////////// END SPRITES ///////////

	/////////// POPUP ///////////
	public void QueuePopupMessage(String header, String body){
		log.info("Queueing popup message for "+body);
		queuedMessages.add(new String[]{header, body});
	}
	private void DisplayPopupMessage(String header, String body){
		WidgetNode widgetNode = client.openInterface((161 << 16) | 13, 660, WidgetModalMode.MODAL_CLICKTHROUGH);
		log.info("Opening popup message for "+body);
		client.runScript(3343, header, body, -1);

		clientThread.invokeLater(() -> {
			Widget w = client.getWidget(660, 1);
			if (w.getWidth() > 0) {
				return false;
			}

			client.closeInterface(widgetNode, true);
			log.info("Closing interface message for "+body);
			isDisplayingPopup = false;
			return true;
		});
	}
	/////////// END POPUP ///////////
}

package gg.archipelago.data;

import lombok.AllArgsConstructor;
import lombok.Data;
import net.runelite.api.SpriteID;

import java.util.List;

@Data
@AllArgsConstructor
public class ItemData {
    public long id;
    public String name;
    public int icon_id;
    public int icon_file;
    public String itemType;
}

package gg.archipelago.data;

public class ItemNames {
    public static final String Lumbridge = "Area: Lumbridge";
    public static final String Lumbridge_Swamp = "Area: Lumbridge Swamp";
    public static final String Lumbridge_Farms = "Area: Lumbridge Farms";
    public static final String HAM_Hideout = "Area: HAM Hideout";
    public static final String Draynor_Village = "Area: Draynor Village";
    public static final String Draynor_Manor = "Area: Draynor Manor";
    public static final String Wizards_Tower = "Area: Wizard's Tower";
    public static final String Al_Kharid = "Area: Al Kharid";
    public static final String Citharede_Abbey = "Area: Cathraede Abbey";
    public static final String South_Of_Varrock = "Area: South of Varrock";
    public static final String Central_Varrock = "Area: Central Varrock";
    public static final String Varrock_Palace = "Area: Varrock Palace";
    public static final String Lumberyard = "Area: Lumberyard";
    public static final String West_Varrock = "Area: West Varrock";
    public static final String Edgeville = "Area: Edgeville";
    public static final String Barbarian_Village = "Area: Barbarian Village";
    public static final String Monastery = "Area: Monastery";
    public static final String Ice_Mountain = "Area: Ice Mountain";
    public static final String Dwarven_Mines = "Area: Dwarven Mines";
    public static final String Falador = "Area: Falador";
    public static final String Falador_Farm = "Area: Falador Farm";
    public static final String Crafting_Guild = "Area: Crafting Guild";
    public static final String Rimmington = "Area: Rimmington";
    public static final String Port_Sarim = "Area: Port Sarim";
    public static final String Mudskipper_Point = "Area: Mudskipper Point";
    public static final String Karamja = "Area: Karamja";
    public static final String Crandor = "Area: Crandor";
    public static final String Corsair_Cove = "Area: Corsair Cove";
    public static final String Wilderness = "Area: The Wilderness";
    public static final String Progressive_Armor = "Progressive Armor";
    public static final String Progressive_Weapons = "Progressive Weapons";
    public static final String Progressive_Tools = "Progressive Tools";
    public static final String Progressive_Range_Armor = "Progressive Ranged Armor";
    public static final String Progressive_Range_Weapon = "Progressive Ranged Weapon";
    public static final String Progressive_Range_Weapon_Legacy = "Progressive Ranged Weapons";
    public static final String Progressive_Magic = "Progressive Magic Spell";
    public static final String Progressive_Magic_Legacy = "Progressive Magic";
}

package gg.archipelago.data;

import lombok.AllArgsConstructor;
import lombok.Data;

import java.util.ArrayList;
import java.util.Dictionary;
import java.util.Hashtable;
import java.util.List;

@Data
public class LocationData{
    private String locationName;
    private String category;
    private String[] regionsRequired;
    private String[] skillsRequired;
    private String[] itemsRequired;
    private String qpRequired;
    private String pluginTaskType;
    private List<String> pluginTaskArgs = new ArrayList<String>();

    public LocationData(List<String> csvData){
        locationName = csvData.get(0);
        category = csvData.get(1);
        regionsRequired = csvData.get(2).split(",");
        skillsRequired = csvData.get(3).split(",");
        itemsRequired = csvData.get(4).split(",");
        qpRequired = csvData.get(5);
        pluginTaskType = csvData.get(6);
        if (csvData.size() > 7)
            pluginTaskArgs = csvData.subList(7, csvData.size());
    }
}
package gg.archipelago;

import java.sql.Array;
import java.util.ArrayList;
import java.util.List;

public class DataPackage {
    public long lastItemReceivedIndex = -1;

    public String address = "";
    public String port = "";
    public String slotName = "";
    public String password = "";

    public String seed = "";
    public List<Long> claimedCarePacks = new ArrayList<Long>();
}

package gg.archipelago;

import java.awt.*;
import java.awt.Dimension;
import java.awt.Graphics2D;
import javax.inject.Inject;

import net.runelite.api.*;
import net.runelite.api.coords.WorldPoint;
import net.runelite.client.ui.overlay.OverlayPanel;
import net.runelite.client.ui.overlay.OverlayLayer;
import net.runelite.client.ui.overlay.OverlayPosition;
import net.runelite.client.ui.overlay.OverlayPriority;
import net.runelite.client.ui.overlay.components.LineComponent;
import net.runelite.client.ui.overlay.components.TitleComponent;


public class IllegalRegionOverlay extends OverlayPanel {
    @Inject
    private Client client;

    @Inject
    public IllegalRegionOverlay(Client client){
        setLayer(OverlayLayer.ABOVE_SCENE);
        setPosition(OverlayPosition.DYNAMIC);
        setPriority(OverlayPriority.MED);
        panelComponent.setPreferredSize(new Dimension(300, 0));
    }

    @Override
    public Dimension render(Graphics2D graphics) {
        // Check if the player is in an illegal region
        int regionId = getRegionID();
        // Check if the current region is one we actually check for
        if (ItemHandler.ChunkIDStringToRegionNames.containsKey(Integer.toString(regionId))){
            // Then check if we have that item
            String requiredItemName = ItemHandler.ChunkIDStringToRegionNames.get(Integer.toString(regionId));
            if (ArchipelagoPlugin.plugin.getCollectedItems().stream().filter(it -> it.name.equals(requiredItemName)).count() == 0){
                final String text1 = "You have not unlocked this chunk yet!";
                final String text2 = requiredItemName+" is required to be here";
                final int textWidth1 = graphics.getFontMetrics().stringWidth(text1);
                final int textWidth2 = graphics.getFontMetrics().stringWidth(text2);
                final int textWidth = Math.max(textWidth1,textWidth2);

                final int textHeight = (graphics.getFontMetrics().getAscent() - graphics.getFontMetrics().getDescent()) * 2;
                final int width = (int) client.getRealDimensions().getWidth();
                java.awt.Point jPoint = new java.awt.Point((width / 2) - textWidth, textHeight + 75);
                panelComponent.getChildren().clear();
                panelComponent.getChildren().add(TitleComponent.builder().text(text1).color(Color.RED).build());
                panelComponent.getChildren().add(TitleComponent.builder().text(text2).color(Color.RED).build());
                panelComponent.setPreferredLocation(jPoint);
                return panelComponent.render(graphics);
            }
        }

        return null;
    }

    private int getRegionID(){
        Player player = client.getLocalPlayer();
        if (player == null) return -1;
        return WorldPoint.fromLocalInstance(client, player.getLocalLocation()).getRegionID();
    }

}

package gg.archipelago;

import gg.archipelago.data.ItemData;
import gg.archipelago.data.ItemNames;
import net.runelite.api.ItemID;
import net.runelite.api.SpriteID;
import net.runelite.client.game.SpriteManager;

import javax.swing.plaf.synth.Region;
import java.awt.image.BufferedImage;
import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.net.URL;
import java.util.*;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

public class ItemHandler {
    public static final long base_id = 0x070000;
    public static int itemCount = 0;
    private static final String repository_address = "https://raw.githubusercontent.com/digiholic/osrs-archipelago-logic/";
    private static final boolean DEBUG = false;
    private static final String debugDataSource = "";
    private static List<ItemData> cachedAllItems = new ArrayList<>();
    public static List<ItemData> GetItems() {
        return cachedAllItems;
    }

    public static List<ItemData> GetAllItems(String data_version){
        List<List<String>> items = GetItemCSVs(data_version);
        itemCount = 0;
        // For Legacy purposes, this is the data as it was on V1.2 of the Archipelago World. This was the last time
        // the data was hard-coded instead of being generated by the logic CSV files. If there is no version number
        // associated with the current slot, use that list.
        if (data_version == null || data_version.isEmpty() || items == null){
            cachedAllItems = defaultItems;
            RegionNamesToChunkIdString = defaultChunkRegions;
            for(Map.Entry<String, String> entry : RegionNamesToChunkIdString.entrySet()){
                String name = entry.getKey();
                String chunks = entry.getValue();
                for(String chunk : chunks.split(",")){
                    ChunkIDStringToRegionNames.put(chunk, name);
                }
            }

            for (ItemData item : defaultItems){
                ItemsById.put(item.id, item);
            }
        } else {
            cachedAllItems = new ArrayList<>();
            for (List<String> itemRow : items){
                int icon_id = 0;
                int icon_file = 0;

                switch(itemRow.get(3)){
                    case "Area":
                        icon_id = SpriteID.MINIMAP_ORB_WORLD_MAP_PLANET;
                        //Icon ID is already 0, no need to reassign
                        String name = itemRow.get(0);
                        String chunks = itemRow.get(4);
                        RegionNamesToChunkIdString.put(name, chunks);
                        for(String chunk : chunks.split(",")){
                            ChunkIDStringToRegionNames.put(chunk, name);
                        }
                        break;
                    case "Item":
                    case "Junk":
                    case "CarePack":
                        icon_id = Integer.parseInt(itemRow.get(4));
                        icon_file = Integer.parseInt(itemRow.get(5));
                        break;
                }
                ItemData item = new ItemData(base_id + itemCount++, itemRow.get(0), icon_id, icon_file, itemRow.get(3));
                cachedAllItems.add(item);
                ItemsById.put(item.id, item);
            }
        }
        return cachedAllItems;
    }

    public static List<List<String>> GetItemCSVs(String dataVersion){
        if (dataVersion == null || dataVersion.isEmpty()) return null;

        String taggedRepoAddress = repository_address+dataVersion;
        List<List<String>> items = new ArrayList<>();
        try {
            BufferedReader in = null;
            if (DEBUG){
                FileReader fileIn = new FileReader(debugDataSource);
                in = new BufferedReader(fileIn);
            } else {
                URL repo = new URL(taggedRepoAddress+"/items.csv");
                in = new BufferedReader(new InputStreamReader(repo.openStream()));
            }

            String inputLine;
            while ((inputLine = in.readLine()) != null){
                if (inputLine.startsWith("Name")) continue;

                List<String> row = new ArrayList<>();
                // Gnarly regex to capture CSV pattern without splitting on commas in quotes
                Matcher m = Pattern.compile("(?:,|\\n|^)(\"(?:(?:\"\")*[^\"]*)*\"|[^\",\\n]*|(?:\\n|$))")
                        .matcher(inputLine);
                while (m.find()){
                    String match = m.group();
                    if (match.startsWith(",")) match = match.substring(1);
                    match = match.replace("\"","");
                    row.add(match);
                }
                items.add(row);
            }
            in.close();
        }
        catch (IOException e) {
            throw new RuntimeException(e);
        }
        return items;
    }
    private static List<ItemData> defaultItems = List.of(
            new ItemData(base_id, ItemNames.Lumbridge, SpriteID.MINIMAP_ORB_WORLD_MAP_PLANET, 0, "Area"),
            new ItemData(base_id + 1, ItemNames.Lumbridge_Swamp, SpriteID.MINIMAP_ORB_WORLD_MAP_PLANET, 0, "Area"),
            new ItemData(base_id + 2, ItemNames.HAM_Hideout, SpriteID.MINIMAP_ORB_WORLD_MAP_PLANET, 0, "Area"),
            new ItemData(base_id + 3, ItemNames.Lumbridge_Farms, SpriteID.MINIMAP_ORB_WORLD_MAP_PLANET, 0, "Area"),
            new ItemData(base_id + 4, ItemNames.South_Of_Varrock, SpriteID.MINIMAP_ORB_WORLD_MAP_PLANET, 0, "Area"),
            new ItemData(base_id + 5, ItemNames.Lumberyard, SpriteID.MINIMAP_ORB_WORLD_MAP_PLANET, 0, "Area"),
            new ItemData(base_id + 6, ItemNames.Central_Varrock, SpriteID.MINIMAP_ORB_WORLD_MAP_PLANET, 0, "Area"),
            new ItemData(base_id + 7, ItemNames.Varrock_Palace, SpriteID.MINIMAP_ORB_WORLD_MAP_PLANET, 0, "Area"),
            new ItemData(base_id + 8, ItemNames.West_Varrock, SpriteID.MINIMAP_ORB_WORLD_MAP_PLANET, 0, "Area"),
            new ItemData(base_id + 9, ItemNames.Edgeville, SpriteID.MINIMAP_ORB_WORLD_MAP_PLANET, 0, "Area"),
            new ItemData(base_id + 10, ItemNames.Barbarian_Village, SpriteID.MINIMAP_ORB_WORLD_MAP_PLANET, 0, "Area"),
            new ItemData(base_id + 11, ItemNames.Draynor_Manor, SpriteID.MINIMAP_ORB_WORLD_MAP_PLANET, 0, "Area"),
            new ItemData(base_id + 12, ItemNames.Falador, SpriteID.MINIMAP_ORB_WORLD_MAP_PLANET, 0, "Area"),
            new ItemData(base_id + 13, ItemNames.Dwarven_Mines, SpriteID.MINIMAP_ORB_WORLD_MAP_PLANET, 0, "Area"),
            new ItemData(base_id + 14, ItemNames.Ice_Mountain, SpriteID.MINIMAP_ORB_WORLD_MAP_PLANET, 0, "Area"),
            new ItemData(base_id + 15, ItemNames.Monastery, SpriteID.MINIMAP_ORB_WORLD_MAP_PLANET, 0, "Area"),
            new ItemData(base_id + 16, ItemNames.Falador_Farm, SpriteID.MINIMAP_ORB_WORLD_MAP_PLANET, 0, "Area"),
            new ItemData(base_id + 17, ItemNames.Port_Sarim, SpriteID.MINIMAP_ORB_WORLD_MAP_PLANET, 0, "Area"),
            new ItemData(base_id + 18, ItemNames.Mudskipper_Point, SpriteID.MINIMAP_ORB_WORLD_MAP_PLANET, 0, "Area"),
            new ItemData(base_id + 19, ItemNames.Karamja, SpriteID.MINIMAP_ORB_WORLD_MAP_PLANET, 0, "Area"),
            new ItemData(base_id + 20, ItemNames.Crandor, SpriteID.MINIMAP_ORB_WORLD_MAP_PLANET, 0, "Area"),
            new ItemData(base_id + 21, ItemNames.Rimmington, SpriteID.MINIMAP_ORB_WORLD_MAP_PLANET, 0, "Area"),
            new ItemData(base_id + 22, ItemNames.Crafting_Guild, SpriteID.MINIMAP_ORB_WORLD_MAP_PLANET, 0, "Area"),
            new ItemData(base_id + 23, ItemNames.Draynor_Village, SpriteID.MINIMAP_ORB_WORLD_MAP_PLANET, 0, "Area"),
            new ItemData(base_id + 24, ItemNames.Wizards_Tower, SpriteID.MINIMAP_ORB_WORLD_MAP_PLANET, 0, "Area"),
            new ItemData(base_id + 25, ItemNames.Corsair_Cove, SpriteID.MINIMAP_ORB_WORLD_MAP_PLANET, 0, "Area"),
            new ItemData(base_id + 26, ItemNames.Al_Kharid, SpriteID.MINIMAP_ORB_WORLD_MAP_PLANET, 0, "Area"),
            new ItemData(base_id + 27, ItemNames.Citharede_Abbey, SpriteID.MINIMAP_ORB_WORLD_MAP_PLANET, 0, "Area"),
            new ItemData(base_id + 28, ItemNames.Wilderness, SpriteID.MINIMAP_ORB_WORLD_MAP_PLANET, 0, "Area"),
            new ItemData(base_id + 29, ItemNames.Progressive_Armor, SpriteID.MAP_ICON_HELMET_SHOP, 0, "Item"),
            new ItemData(base_id + 30, ItemNames.Progressive_Weapons, SpriteID.MAP_ICON_SWORD_SHOP, 0, "Item"),
            new ItemData(base_id + 31, ItemNames.Progressive_Tools, SpriteID.MAP_ICON_MINING_SHOP, 0, "Item"),
            new ItemData(base_id + 32, ItemNames.Progressive_Range_Weapon, SpriteID.MAP_ICON_ARCHERY_SHOP, 0, "Item"),
            new ItemData(base_id + 33, ItemNames.Progressive_Range_Armor, SpriteID.MAP_ICON_TANNERY, 0, "Item"),
            new ItemData(base_id + 34, ItemNames.Progressive_Magic, SpriteID.MAP_ICON_MAGIC_SHOP, 0, "Item")
    );

    public static Map<String, String> RegionNamesToChunkIdString = new HashMap<>();
    public static Map<String, String> ChunkIDStringToRegionNames = new HashMap<>();
    private static Map<String, String> defaultChunkRegions = Map.ofEntries(
            Map.entry(ItemNames.Lumbridge, "12850"),
            Map.entry(ItemNames.Lumbridge_Swamp, "12849,12593"),
            Map.entry(ItemNames.Lumbridge_Farms, "12851,12595"),
            Map.entry(ItemNames.HAM_Hideout, "12594"),
            Map.entry(ItemNames.Draynor_Village, "12338,12339"),
            Map.entry(ItemNames.Draynor_Manor, "12340"),
            Map.entry(ItemNames.Wizards_Tower, "12337"),
            Map.entry(ItemNames.Al_Kharid, "13107,13106,13362,13105,13104"),
            Map.entry(ItemNames.Citharede_Abbey, "13361,13617"),
            Map.entry(ItemNames.South_Of_Varrock, "13108,12852,12596"),
            Map.entry(ItemNames.Central_Varrock, "12853"),
            Map.entry(ItemNames.Varrock_Palace, "12854"),
            Map.entry(ItemNames.Lumberyard, "13109,13110"),
            Map.entry(ItemNames.West_Varrock, "12598,12597"),
            Map.entry(ItemNames.Edgeville, "12342"),
            Map.entry(ItemNames.Barbarian_Village, "12341"),
            Map.entry(ItemNames.Monastery, "12086"),
            Map.entry(ItemNames.Ice_Mountain, "11830"),
            Map.entry(ItemNames.Dwarven_Mines, "12085,11829"),
            Map.entry(ItemNames.Falador, "12084,11828"),
            Map.entry(ItemNames.Falador_Farm, "12083,11827"),
            Map.entry(ItemNames.Crafting_Guild, "11571"),
            Map.entry(ItemNames.Rimmington, "11826,11570"),
            Map.entry(ItemNames.Port_Sarim, "12082,12081"),
            Map.entry(ItemNames.Mudskipper_Point, "11825,11824"),
            Map.entry(ItemNames.Karamja, "11569,11313"),
            Map.entry(ItemNames.Crandor, "11315,11314"),
            Map.entry(ItemNames.Corsair_Cove, "10284,10028"),
            Map.entry(ItemNames.Wilderness, "11836,11835,11834,11833,11832,11831,12092,12091,12090,12089,12088,12087,12348,12347,12346,12345,12344,12343,12604,12603,12602,12601,12600,12599,12860,12859,12858,12857,12856,12855,13116,13115,13114,13113,13112,13111,13372,13371,13370,13369,13368,13367")
    );
    public static final Map<ItemData, BufferedImage> loadedSprites = new HashMap<ItemData, BufferedImage>();

    public static ItemData GetItemByName(String name) {
        return GetItems().stream()
                .filter(item -> name.equals(item.name))
                .findFirst()
                .orElse(null);
    }

    public static Map<Long, ItemData> ItemsById = new HashMap<>();

    public static String MetalTierByCount(int count) {
        switch (count) {
            default:
                return "Bronze";
            case 1:
                return "Iron";
            case 2:
                return "Steel";
            case 3:
                return "Black";
            case 4:
                return "Mithril";
            case 5:
                return "Adamant";
            case 6:
                return "Rune";
        }
    }

    public static String RangeArmorTierByCount(int count) {
        switch (count) {
            default:
                return "No Ranged Armor";
            case 1:
                return "Ranged Armor: Leather";
            case 2:
                return "Ranged Armor: Studded Leather";
            case 3:
                return "Ranged Armor: Green Dragonhide";
        }
    }

    public static String RangeWeaponTierByCount(int count) {
        switch (count) {
            default:
                return "Bows: Wooden, Arrows: Iron";
            case 1:
                return "Bows: Oak, Arrows: Steel";
            case 2:
                return "Bows: Willow, Arrows: Mith";
            case 3:
                return "Bows: Maple, Arrows: Adamant";
        }
    }

    public static String MagicTierByCount(int count) {
        switch (count) {
            default:
                return "Strike Spells (Mind Runes)";
            case 1:
                return "Bolt Spells (Chaos Runes)";
            case 2:
                return "Blast Spells (Death Runes)";
        }
    }

    public static void LoadImages(SpriteManager spriteManager) {
        for (ItemData item : GetItems()) {
            loadedSprites.put(item, spriteManager.getSprite(item.icon_id, item.icon_file));
        }
    }


    public static final Map<Integer, Integer[]> MetalWeaponsPermittedByTier = new Hashtable<>() {
        {
            put(0, new Integer[]{
                    ItemID.BRONZE_2H_SWORD, ItemID.BRONZE_AXE, ItemID.BRONZE_BATTLEAXE,
                    ItemID.BRONZE_CLAWS, ItemID.BRONZE_DAGGER, ItemID.BRONZE_DAGGERP, ItemID.BRONZE_DAGGERP_5670,
                    ItemID.BRONZE_DAGGERP_5688, ItemID.BRONZE_HALBERD, ItemID.BRONZE_HASTA, ItemID.BRONZE_HASTAKP,
                    ItemID.BRONZE_HASTAP, ItemID.BRONZE_HASTAP_11382, ItemID.BRONZE_HASTAP_11384,
                    ItemID.BRONZE_LONGSWORD, ItemID.BRONZE_MACE, ItemID.BRONZE_PICKAXE, ItemID.BRONZE_SCIMITAR,
                    ItemID.BRONZE_SPEAR, ItemID.BRONZE_SPEARKP, ItemID.BRONZE_SPEARP, ItemID.BRONZE_SPEARP_5704,
                    ItemID.BRONZE_SPEARP_5718, ItemID.BRONZE_SWORD, ItemID.BRONZE_WARHAMMER
            });
            put(1, new Integer[]{
                    ItemID.IRON_2H_SWORD, ItemID.IRON_AXE, ItemID.IRON_BATTLEAXE,
                    ItemID.IRON_CLAWS, ItemID.IRON_DAGGER, ItemID.IRON_DAGGERP, ItemID.IRON_DAGGERP_5668,
                    ItemID.IRON_DAGGERP_5686, ItemID.IRON_HALBERD, ItemID.IRON_HASTA, ItemID.IRON_HASTAKP,
                    ItemID.IRON_HASTAP, ItemID.IRON_HASTAP_11389, ItemID.IRON_HASTAP_11391,
                    ItemID.IRON_LONGSWORD, ItemID.IRON_MACE, ItemID.IRON_PICKAXE, ItemID.IRON_SCIMITAR,
                    ItemID.IRON_SPEAR, ItemID.IRON_SPEARKP, ItemID.IRON_SPEARP, ItemID.IRON_SPEARP_5706,
                    ItemID.IRON_SPEARP_5720, ItemID.IRON_SWORD, ItemID.IRON_WARHAMMER
            });
            put(2, new Integer[]{
                    ItemID.STEEL_2H_SWORD, ItemID.STEEL_AXE, ItemID.STEEL_BATTLEAXE,
                    ItemID.STEEL_CLAWS, ItemID.STEEL_DAGGER, ItemID.STEEL_DAGGERP, ItemID.STEEL_DAGGERP_5672,
                    ItemID.STEEL_DAGGERP_5690, ItemID.STEEL_HALBERD, ItemID.STEEL_HASTA, ItemID.STEEL_HASTAKP,
                    ItemID.STEEL_HASTAP, ItemID.STEEL_HASTAP_11396, ItemID.STEEL_HASTAP_11398,
                    ItemID.STEEL_LONGSWORD, ItemID.STEEL_MACE, ItemID.STEEL_PICKAXE, ItemID.STEEL_SCIMITAR,
                    ItemID.STEEL_SPEAR, ItemID.STEEL_SPEARKP, ItemID.STEEL_SPEARP, ItemID.STEEL_SPEARP_5708,
                    ItemID.STEEL_SPEARP_5722, ItemID.STEEL_SWORD, ItemID.STEEL_WARHAMMER
            });
            put(3, new Integer[]{
                    ItemID.BLACK_2H_SWORD, ItemID.BLACK_AXE, ItemID.BLACK_BATTLEAXE,
                    ItemID.BLACK_CLAWS, ItemID.BLACK_DAGGER, ItemID.BLACK_DAGGERP, ItemID.BLACK_DAGGERP_5682,
                    ItemID.BLACK_DAGGERP_5700, ItemID.BLACK_HALBERD, ItemID.BLACK_LONGSWORD, ItemID.BLACK_MACE,
                    ItemID.BLACK_PICKAXE, ItemID.BLACK_SCIMITAR, ItemID.BLACK_SPEAR, ItemID.BLACK_SPEARKP,
                    ItemID.BLACK_SPEARP, ItemID.BLACK_SPEARP_5734, ItemID.BLACK_SPEARP_5736, ItemID.BLACK_SWORD,
                    ItemID.BLACK_WARHAMMER
            });
            put(4, new Integer[]{
                    ItemID.MITHRIL_2H_SWORD, ItemID.MITHRIL_AXE, ItemID.MITHRIL_BATTLEAXE,
                    ItemID.MITHRIL_CLAWS, ItemID.MITHRIL_DAGGER, ItemID.MITHRIL_DAGGERP, ItemID.MITHRIL_DAGGERP_5674,
                    ItemID.MITHRIL_DAGGERP_5692, ItemID.MITHRIL_HALBERD, ItemID.MITHRIL_HASTA, ItemID.MITHRIL_HASTAKP,
                    ItemID.MITHRIL_HASTAP, ItemID.MITHRIL_HASTAP_11403, ItemID.MITHRIL_HASTAP_11405,
                    ItemID.MITHRIL_LONGSWORD, ItemID.MITHRIL_MACE, ItemID.MITHRIL_PICKAXE, ItemID.MITHRIL_SCIMITAR,
                    ItemID.MITHRIL_SPEAR, ItemID.MITHRIL_SPEARKP, ItemID.MITHRIL_SPEARP, ItemID.MITHRIL_SPEARP_5710,
                    ItemID.MITHRIL_SPEARP_5724, ItemID.MITHRIL_SWORD, ItemID.MITHRIL_WARHAMMER
            });
            put(5, new Integer[]{
                    ItemID.ADAMANT_2H_SWORD, ItemID.ADAMANT_AXE, ItemID.ADAMANT_BATTLEAXE,
                    ItemID.ADAMANT_CLAWS, ItemID.ADAMANT_DAGGER, ItemID.ADAMANT_DAGGERP, ItemID.ADAMANT_DAGGERP_5676,
                    ItemID.ADAMANT_DAGGERP_5694, ItemID.ADAMANT_HALBERD, ItemID.ADAMANT_HASTA, ItemID.ADAMANT_HASTAKP,
                    ItemID.ADAMANT_HASTAP, ItemID.ADAMANT_HASTAP_11410, ItemID.ADAMANT_HASTAP_11412,
                    ItemID.ADAMANT_LONGSWORD, ItemID.ADAMANT_MACE, ItemID.ADAMANT_PICKAXE, ItemID.ADAMANT_SCIMITAR,
                    ItemID.ADAMANT_SPEAR, ItemID.ADAMANT_SPEARKP, ItemID.ADAMANT_SPEARP, ItemID.ADAMANT_SPEARP_5712,
                    ItemID.ADAMANT_SPEARP_5726, ItemID.ADAMANT_SWORD, ItemID.ADAMANT_WARHAMMER
            });
            put(6, new Integer[]{
                    ItemID.RUNE_2H_SWORD, ItemID.RUNE_AXE, ItemID.RUNE_BATTLEAXE,
                    ItemID.RUNE_CLAWS, ItemID.RUNE_DAGGER, ItemID.RUNE_DAGGERP, ItemID.RUNE_DAGGERP_5678,
                    ItemID.RUNE_DAGGERP_5696, ItemID.RUNE_HALBERD, ItemID.RUNE_HASTA, ItemID.RUNE_HASTAKP,
                    ItemID.RUNE_HASTAP, ItemID.RUNE_HASTAP_11417, ItemID.RUNE_HASTAP_11419,
                    ItemID.RUNE_LONGSWORD, ItemID.RUNE_MACE, ItemID.RUNE_PICKAXE, ItemID.RUNE_SCIMITAR,
                    ItemID.RUNE_SPEAR, ItemID.RUNE_SPEARKP, ItemID.RUNE_SPEARP, ItemID.RUNE_SPEARP_5714,
                    ItemID.RUNE_SPEARP_5728, ItemID.RUNE_SWORD, ItemID.RUNE_WARHAMMER
            });
        }
    };

    public static final List<Integer> MetalWeaponItemIds = new ArrayList<Integer>(){{
        for (int i=0;i<MetalWeaponsPermittedByTier.size();i++){
            Collections.addAll(this,MetalWeaponsPermittedByTier.get(i));
        }
    }};

    public static Map<Integer, Integer[]> MetalArmorPermittedByTier = new Hashtable<>() {
        {
            put(0, new Integer[]{
                    ItemID.BRONZE_BOOTS, ItemID.BRONZE_CHAINBODY, ItemID.BRONZE_GLOVES, ItemID.BRONZE_MED_HELM,
                    ItemID.BRONZE_FULL_HELM, ItemID.BRONZE_FULL_HELM_T, ItemID.BRONZE_FULL_HELM_G,
                    ItemID.BRONZE_KITESHIELD, ItemID.BRONZE_KITESHIELD_T, ItemID.BRONZE_KITESHIELD_G,
                    ItemID.BRONZE_PLATEBODY, ItemID.BRONZE_PLATEBODY_T, ItemID.BRONZE_PLATEBODY_G,
                    ItemID.BRONZE_PLATELEGS, ItemID.BRONZE_PLATELEGS_T, ItemID.BRONZE_PLATELEGS_G,
                    ItemID.BRONZE_PLATESKIRT, ItemID.BRONZE_PLATESKIRT_T, ItemID.BRONZE_PLATESKIRT_G,
                    ItemID.BRONZE_SQ_SHIELD
            });
            put(1, new Integer[]{
                    ItemID.IRON_BOOTS, ItemID.IRON_CHAINBODY, ItemID.IRON_GLOVES, ItemID.IRON_MED_HELM,
                    ItemID.IRON_FULL_HELM, ItemID.IRON_FULL_HELM_T, ItemID.IRON_FULL_HELM_G,
                    ItemID.IRON_KITESHIELD, ItemID.IRON_KITESHIELD_T, ItemID.IRON_KITESHIELD_G,
                    ItemID.IRON_PLATEBODY, ItemID.IRON_PLATEBODY_T, ItemID.IRON_PLATEBODY_G,
                    ItemID.IRON_PLATELEGS, ItemID.IRON_PLATELEGS_T, ItemID.IRON_PLATELEGS_G,
                    ItemID.IRON_PLATESKIRT, ItemID.IRON_PLATESKIRT_T, ItemID.IRON_PLATESKIRT_G,
                    ItemID.IRON_SQ_SHIELD, ItemID.IRONMAN_HELM, ItemID.IRONMAN_PLATEBODY, ItemID.IRONMAN_PLATELEGS,
                    ItemID.HARDCORE_IRONMAN_HELM, ItemID.HARDCORE_IRONMAN_PLATEBODY, ItemID.HARDCORE_IRONMAN_PLATELEGS,
                    ItemID.GROUP_IRONMAN_BRACERS, ItemID.GROUP_IRONMAN_BRACERS_UNRANKED, ItemID.GROUP_IRONMAN_HELM,
                    ItemID.GROUP_IRONMAN_HELM_UNRANKED, ItemID.GROUP_IRONMAN_PLATEBODY, ItemID.GROUP_IRONMAN_PLATEBODY_26160,
                    ItemID.GROUP_IRONMAN_PLATEBODY_26162, ItemID.GROUP_IRONMAN_PLATEBODY_26164,
                    ItemID.GROUP_IRONMAN_PLATEBODY_UNRANKED, ItemID.GROUP_IRONMAN_PLATEBODY_UNRANKED_27050,
                    ItemID.GROUP_IRONMAN_PLATEBODY_UNRANKED_27052, ItemID.GROUP_IRONMAN_PLATEBODY_UNRANKED_27054,
                    ItemID.GROUP_IRONMAN_PLATELEGS, ItemID.GROUP_IRONMAN_PLATELEGS_UNRANKED,
                    ItemID.HARDCORE_GROUP_IRONMAN_BRACERS, ItemID.HARDCORE_GROUP_IRONMAN_HELM,
                    ItemID.HARDCORE_GROUP_IRONMAN_PLATEBODY, ItemID.HARDCORE_GROUP_IRONMAN_PLATEBODY_26174,
                    ItemID.HARDCORE_GROUP_IRONMAN_PLATEBODY_26176, ItemID.HARDCORE_GROUP_IRONMAN_PLATEBODY_26178,
                    ItemID.HARDCORE_GROUP_IRONMAN_PLATELEGS
            });
            put(2, new Integer[]{
                    ItemID.STEEL_BOOTS, ItemID.STEEL_CHAINBODY, ItemID.STEEL_GLOVES, ItemID.STEEL_MED_HELM,
                    ItemID.STEEL_FULL_HELM, ItemID.STEEL_FULL_HELM_T, ItemID.STEEL_FULL_HELM_G,
                    ItemID.STEEL_KITESHIELD, ItemID.STEEL_KITESHIELD_T, ItemID.STEEL_KITESHIELD_G,
                    ItemID.STEEL_PLATEBODY, ItemID.STEEL_PLATEBODY_T, ItemID.STEEL_PLATEBODY_G,
                    ItemID.STEEL_PLATELEGS, ItemID.STEEL_PLATELEGS_T, ItemID.STEEL_PLATELEGS_G,
                    ItemID.STEEL_PLATESKIRT, ItemID.STEEL_PLATESKIRT_T, ItemID.STEEL_PLATESKIRT_G,
                    ItemID.STEEL_SQ_SHIELD,
                    ItemID.STEEL_HERALDIC_HELM, ItemID.STEEL_HERALDIC_HELM_8684, ItemID.STEEL_HERALDIC_HELM_8686,
                    ItemID.STEEL_HERALDIC_HELM_8688, ItemID.STEEL_HERALDIC_HELM_8690, ItemID.STEEL_HERALDIC_HELM_8692,
                    ItemID.STEEL_HERALDIC_HELM_8694, ItemID.STEEL_HERALDIC_HELM_8696, ItemID.STEEL_HERALDIC_HELM_8698,
                    ItemID.STEEL_HERALDIC_HELM_8700, ItemID.STEEL_HERALDIC_HELM_8702, ItemID.STEEL_HERALDIC_HELM_8704,
                    ItemID.STEEL_HERALDIC_HELM_8706, ItemID.STEEL_HERALDIC_HELM_8708, ItemID.STEEL_HERALDIC_HELM_8710,
                    ItemID.STEEL_HERALDIC_HELM_8712,
                    ItemID.STEEL_KITESHIELD_8746, ItemID.STEEL_KITESHIELD_8748, ItemID.STEEL_KITESHIELD_8750,
                    ItemID.STEEL_KITESHIELD_8752, ItemID.STEEL_KITESHIELD_8754, ItemID.STEEL_KITESHIELD_8756,
                    ItemID.STEEL_KITESHIELD_8758, ItemID.STEEL_KITESHIELD_8760, ItemID.STEEL_KITESHIELD_8762,
                    ItemID.STEEL_KITESHIELD_8764, ItemID.STEEL_KITESHIELD_8766, ItemID.STEEL_KITESHIELD_8768,
                    ItemID.STEEL_KITESHIELD_8770, ItemID.STEEL_KITESHIELD_8772, ItemID.STEEL_KITESHIELD_8774,
                    ItemID.STEEL_KITESHIELD_8776

            });
            put(3, new Integer[]{
                    ItemID.BLACK_BOOTS, ItemID.BLACK_CHAINBODY, ItemID.BLACK_GLOVES, ItemID.BLACK_MED_HELM,
                    ItemID.BLACK_FULL_HELM, ItemID.BLACK_FULL_HELM_T, ItemID.BLACK_FULL_HELM_G,
                    ItemID.BLACK_KITESHIELD, ItemID.BLACK_KITESHIELD_T, ItemID.BLACK_KITESHIELD_G,
                    ItemID.BLACK_PLATEBODY, ItemID.BLACK_PLATEBODY_T, ItemID.BLACK_PLATEBODY_G,
                    ItemID.BLACK_PLATELEGS, ItemID.BLACK_PLATELEGS_T, ItemID.BLACK_PLATELEGS_G,
                    ItemID.BLACK_PLATESKIRT, ItemID.BLACK_PLATESKIRT_T, ItemID.BLACK_PLATESKIRT_G,
                    ItemID.BLACK_SQ_SHIELD,
                    ItemID.BLACK_HELM_H1, ItemID.BLACK_HELM_H2, ItemID.BLACK_HELM_H3, ItemID.BLACK_HELM_H4,
                    ItemID.BLACK_PLATEBODY_H1, ItemID.BLACK_PLATEBODY_H2, ItemID.BLACK_PLATEBODY_H3,
                    ItemID.BLACK_PLATEBODY_H4, ItemID.BLACK_PLATEBODY_H5,
                    ItemID.BLACK_SHIELD_H1, ItemID.BLACK_SHIELD_H2, ItemID.BLACK_SHIELD_H3,
                    ItemID.BLACK_SHIELD_H4,ItemID.BLACK_SHIELD_H5
            });
            put(4, new Integer[]{
                    ItemID.MITHRIL_BOOTS, ItemID.MITHRIL_CHAINBODY, ItemID.MITHRIL_GLOVES, ItemID.MITHRIL_MED_HELM,
                    ItemID.MITHRIL_FULL_HELM, ItemID.MITHRIL_FULL_HELM_T, ItemID.MITHRIL_FULL_HELM_G,
                    ItemID.MITHRIL_KITESHIELD, ItemID.MITHRIL_KITESHIELD_T, ItemID.MITHRIL_KITESHIELD_G,
                    ItemID.MITHRIL_PLATEBODY, ItemID.MITHRIL_PLATEBODY_T, ItemID.MITHRIL_PLATEBODY_G,
                    ItemID.MITHRIL_PLATELEGS, ItemID.MITHRIL_PLATELEGS_T, ItemID.MITHRIL_PLATELEGS_G,
                    ItemID.MITHRIL_PLATESKIRT, ItemID.MITHRIL_PLATESKIRT_T, ItemID.MITHRIL_PLATESKIRT_G,
                    ItemID.MITHRIL_SQ_SHIELD
            });
            put(5, new Integer[]{
                    ItemID.ADAMANT_BOOTS, ItemID.ADAMANT_CHAINBODY, ItemID.ADAMANT_GLOVES, ItemID.ADAMANT_MED_HELM,
                    ItemID.ADAMANT_FULL_HELM, ItemID.ADAMANT_FULL_HELM_T, ItemID.ADAMANT_FULL_HELM_G,
                    ItemID.ADAMANT_KITESHIELD, ItemID.ADAMANT_KITESHIELD_T, ItemID.ADAMANT_KITESHIELD_G,
                    ItemID.ADAMANT_PLATEBODY, ItemID.ADAMANT_PLATEBODY_T, ItemID.ADAMANT_PLATEBODY_G,
                    ItemID.ADAMANT_PLATELEGS, ItemID.ADAMANT_PLATELEGS_T, ItemID.ADAMANT_PLATELEGS_G,
                    ItemID.ADAMANT_PLATESKIRT, ItemID.ADAMANT_PLATESKIRT_T, ItemID.ADAMANT_PLATESKIRT_G,
                    ItemID.ADAMANT_SQ_SHIELD,
                    ItemID.ADAMANT_HELM_H1, ItemID.ADAMANT_HELM_H2, ItemID.ADAMANT_HELM_H3, ItemID.ADAMANT_HELM_H4,
                    ItemID.ADAMANT_PLATEBODY_H1, ItemID.ADAMANT_PLATEBODY_H2, ItemID.ADAMANT_PLATEBODY_H3,
                    ItemID.ADAMANT_PLATEBODY_H4, ItemID.ADAMANT_PLATEBODY_H5,
                    ItemID.ADAMANT_SHIELD_H1, ItemID.ADAMANT_SHIELD_H2, ItemID.ADAMANT_SHIELD_H3,
                    ItemID.ADAMANT_SHIELD_H4,ItemID.ADAMANT_SHIELD_H5,
                    ItemID.ADAMANT_KITESHIELD_6894, ItemID.ADAMANT_KITESHIELD_22127, ItemID.ADAMANT_KITESHIELD_22129,
                    ItemID.ADAMANT_KITESHIELD_22131, ItemID.ADAMANT_KITESHIELD_22133, ItemID.ADAMANT_KITESHIELD_22135,
                    ItemID.ADAMANT_KITESHIELD_22137, ItemID.ADAMANT_KITESHIELD_22139, ItemID.ADAMANT_KITESHIELD_22141,
                    ItemID.ADAMANT_KITESHIELD_22143, ItemID.ADAMANT_KITESHIELD_22145, ItemID.ADAMANT_KITESHIELD_22147,
                    ItemID.ADAMANT_KITESHIELD_22149, ItemID.ADAMANT_KITESHIELD_22151, ItemID.ADAMANT_KITESHIELD_22153,
                    ItemID.ADAMANT_KITESHIELD_22155, ItemID.ADAMANT_KITESHIELD_22157, ItemID.ADAMANT_HERALDIC_HELM,
                    ItemID.ADAMANT_HERALDIC_HELM_22161, ItemID.ADAMANT_HERALDIC_HELM_22163,
                    ItemID.ADAMANT_HERALDIC_HELM_22165, ItemID.ADAMANT_HERALDIC_HELM_22167,
                    ItemID.ADAMANT_HERALDIC_HELM_22169, ItemID.ADAMANT_HERALDIC_HELM_22171,
                    ItemID.ADAMANT_HERALDIC_HELM_22173, ItemID.ADAMANT_HERALDIC_HELM_22175,
                    ItemID.ADAMANT_HERALDIC_HELM_22177, ItemID.ADAMANT_HERALDIC_HELM_22179,
                    ItemID.ADAMANT_HERALDIC_HELM_22181, ItemID.ADAMANT_HERALDIC_HELM_22183,
                    ItemID.ADAMANT_HERALDIC_HELM_22185, ItemID.ADAMANT_HERALDIC_HELM_22187,
                    ItemID.ADAMANT_HERALDIC_HELM_22189
            });
            put(6, new Integer[]{
                    ItemID.RUNE_BOOTS, ItemID.RUNE_CHAINBODY, ItemID.RUNE_GLOVES, ItemID.RUNE_MED_HELM,
                    ItemID.RUNE_FULL_HELM, ItemID.RUNE_FULL_HELM_T, ItemID.RUNE_FULL_HELM_G,
                    ItemID.RUNE_KITESHIELD, ItemID.RUNE_KITESHIELD_T, ItemID.RUNE_KITESHIELD_G,
                    ItemID.RUNE_PLATEBODY, ItemID.RUNE_PLATEBODY_T, ItemID.RUNE_PLATEBODY_G,
                    ItemID.RUNE_PLATELEGS, ItemID.RUNE_PLATELEGS_T, ItemID.RUNE_PLATELEGS_G,
                    ItemID.RUNE_PLATESKIRT, ItemID.RUNE_PLATESKIRT_T, ItemID.RUNE_PLATESKIRT_G,
                    ItemID.RUNE_SQ_SHIELD,
                    ItemID.RUNE_HELM_H1, ItemID.RUNE_HELM_H2, ItemID.RUNE_HELM_H3, ItemID.RUNE_HELM_H4,
                    ItemID.RUNE_PLATEBODY_H1, ItemID.RUNE_PLATEBODY_H2, ItemID.RUNE_PLATEBODY_H3,
                    ItemID.RUNE_PLATEBODY_H4, ItemID.RUNE_PLATEBODY_H5,
                    ItemID.RUNE_SHIELD_H1, ItemID.RUNE_SHIELD_H2, ItemID.RUNE_SHIELD_H3,
                    ItemID.RUNE_SHIELD_H4,ItemID.RUNE_SHIELD_H5,
                    ItemID.RUNE_HERALDIC_HELM, ItemID.RUNE_HERALDIC_HELM_8466, ItemID.RUNE_HERALDIC_HELM_8468,
                    ItemID.RUNE_HERALDIC_HELM_8470, ItemID.RUNE_HERALDIC_HELM_8472, ItemID.RUNE_HERALDIC_HELM_8474,
                    ItemID.RUNE_HERALDIC_HELM_8476, ItemID.RUNE_HERALDIC_HELM_8478, ItemID.RUNE_HERALDIC_HELM_8480,
                    ItemID.RUNE_HERALDIC_HELM_8482, ItemID.RUNE_HERALDIC_HELM_8484, ItemID.RUNE_HERALDIC_HELM_8486,
                    ItemID.RUNE_HERALDIC_HELM_8488, ItemID.RUNE_HERALDIC_HELM_8490, ItemID.RUNE_HERALDIC_HELM_8492,
                    ItemID.RUNE_HERALDIC_HELM_8494, ItemID.RUNE_KITESHIELD_8714, ItemID.RUNE_KITESHIELD_8716,
                    ItemID.RUNE_KITESHIELD_8718, ItemID.RUNE_KITESHIELD_8720, ItemID.RUNE_KITESHIELD_8722,
                    ItemID.RUNE_KITESHIELD_8724, ItemID.RUNE_KITESHIELD_8726, ItemID.RUNE_KITESHIELD_8728,
                    ItemID.RUNE_KITESHIELD_8730, ItemID.RUNE_KITESHIELD_8732, ItemID.RUNE_KITESHIELD_8734,
                    ItemID.RUNE_KITESHIELD_8736, ItemID.RUNE_KITESHIELD_8738, ItemID.RUNE_KITESHIELD_8740,
                    ItemID.RUNE_KITESHIELD_8742, ItemID.RUNE_KITESHIELD_8744
            });
        }
    };

    public static final List<Integer> MetalArmorItemIds = new ArrayList<Integer>(){{
        for (int i=0;i<MetalArmorPermittedByTier.size();i++){
            Collections.addAll(this,MetalArmorPermittedByTier.get(i));
        }
    }};

    public static Map<Integer, Integer[]> RangeArmorPermittedByTier = new Hashtable<>() {
        {
            put(0, new Integer[]{ });
            put(1, new Integer[] {
                    ItemID.LEATHER_GLOVES, ItemID.LEATHER_BOOTS, ItemID.LEATHER_COWL,
                    ItemID.LEATHER_BODY, ItemID.LEATHER_BODY_G,
                    ItemID.LEATHER_CHAPS, ItemID.LEATHER_CHAPS_G
            });
            put(2, new Integer[] {
                    ItemID.STUDDED_BODY, ItemID.STUDDED_BODY_T, ItemID.STUDDED_BODY_G,
                    ItemID.STUDDED_CHAPS, ItemID.STUDDED_CHAPS_T, ItemID.STUDDED_CHAPS_G,
                    ItemID.COIF, ItemID.LEATHER_VAMBRACES, ItemID.STUDDED_BODY_26264,
            });
            put(3, new Integer[] {
                    ItemID.GREEN_DHIDE_BODY, ItemID.GREEN_DHIDE_BODY_T, ItemID.GREEN_DHIDE_BODY_G,
                    ItemID.GREEN_DHIDE_CHAPS, ItemID.GREEN_DHIDE_CHAPS_T, ItemID.GREEN_DHIDE_CHAPS_G,
                    ItemID.GREEN_DHIDE_SHIELD, ItemID.GREEN_DHIDE_VAMBRACES
            });
        }
    };

    public static final List<Integer> RangeArmorItemIds = new ArrayList<Integer>(){{
        for (int i=0;i<RangeArmorPermittedByTier.size();i++){
            Collections.addAll(this,RangeArmorPermittedByTier.get(i));
        }
    }};

    public static Map<Integer, Integer[]> RangeWeaponsPermittedByTier = new Hashtable<>() {
        {
            put(0, new Integer[] {
                    ItemID.BOW_AND_ARROW, ItemID.SHORTBOW, ItemID.LONGBOW,
                    ItemID.BRONZE_ARROW, ItemID.BRONZE_ARROW_11700, ItemID.BRONZE_ARROWP, ItemID.BRONZE_ARROWP_5616, ItemID.BRONZE_ARROWP_5622,
                    ItemID.IRON_ARROW, ItemID.IRON_ARROW_11701, ItemID.IRON_ARROWP, ItemID.IRON_ARROWP_5617, ItemID.IRON_ARROWP_5623
            });
            put(1, new Integer[] {
                    ItemID.OAK_SHORTBOW, ItemID.OAK_LONGBOW,
                    ItemID.STEEL_ARROW, ItemID.STEEL_ARROW_11702,
                    ItemID.STEEL_ARROWP, ItemID.STEEL_ARROWP_5618, ItemID.STEEL_ARROWP_5624
            });
            put(2, new Integer[] {
                    ItemID.WILLOW_SHORTBOW, ItemID.WILLOW_LONGBOW,
                    ItemID.MITHRIL_ARROW, ItemID.MITHRIL_ARROW_7552, ItemID.MITHRIL_ARROW_11703,
                    ItemID.MITHRIL_ARROWP, ItemID.MITHRIL_ARROWP_5619, ItemID.MITHRIL_ARROWP_5625
            });
            put(3, new Integer[] {
                    ItemID.MAPLE_SHORTBOW, ItemID.MAPLE_LONGBOW,
                    ItemID.ADAMANT_ARROW, ItemID.ADAMANT_ARROW_20388,
                    ItemID.ADAMANT_ARROWP, ItemID.ADAMANT_ARROWP_5620, ItemID.ADAMANT_ARROWP_5626
            });
        }};

    public static final List<Integer> RangeWeaponItemIds = new ArrayList<Integer>(){{
        for (int i=0;i<RangeWeaponsPermittedByTier.size();i++){
            Collections.addAll(this,RangeWeaponsPermittedByTier.get(i));
        }
    }};
}

package gg.archipelago;

import gg.archipelago.Tasks.APTask;
import gg.archipelago.data.ItemData;
import gg.archipelago.data.ItemNames;
import net.runelite.api.Client;
import net.runelite.api.GameState;
import net.runelite.api.events.ClientTick;
import net.runelite.api.events.GameStateChanged;
import net.runelite.client.RuneLite;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.ui.ColorScheme;

import javax.inject.Inject;
import javax.swing.*;
import javax.swing.border.Border;
import javax.swing.border.EmptyBorder;
import java.awt.*;
import java.awt.image.BufferedImage;
import java.security.DigestException;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.stream.Collectors;

public class ItemPanel extends JPanel {
    private final ArchipelagoPlugin plugin;

    private final HashMap<ItemData, ItemRow> itemPanels = new HashMap<>();

    private final JPanel equipmentPanel;
    private final JPanel carePackPanel;
    private final JPanel areaPanel;
    private final JPanel junkPanel;
    private final JPanel claimedPackPanel;


    private boolean isPanelInitialized;

    public ItemPanel(ArchipelagoPlugin plugin){
        this.plugin = plugin;

        setLayout(new BoxLayout(this, BoxLayout.Y_AXIS));

        setBackground(ColorScheme.DARKER_GRAY_COLOR);
        setBorder(new EmptyBorder(5, 5, 5, 10));
        setVisible(false);

        setAlignmentX(Component.LEFT_ALIGNMENT);

        equipmentPanel = new JPanel();
        equipmentPanel.setLayout(new BoxLayout(equipmentPanel, BoxLayout.Y_AXIS));
        add(equipmentPanel);

        carePackPanel = new JPanel();
        carePackPanel.setLayout(new BoxLayout(carePackPanel, BoxLayout.Y_AXIS));
        add(carePackPanel);

        areaPanel = new JPanel();
        areaPanel.setLayout(new BoxLayout(areaPanel, BoxLayout.Y_AXIS));
        add(areaPanel);

        junkPanel = new JPanel();
        junkPanel.setLayout(new BoxLayout(junkPanel, BoxLayout.Y_AXIS));
        add(junkPanel);

        claimedPackPanel = new JPanel();
        claimedPackPanel.setLayout(new BoxLayout(claimedPackPanel, BoxLayout.Y_AXIS));
        add(claimedPackPanel);
    }

    @Subscribe
    public void onGameStateChanged(GameStateChanged gameStateChanged)
    {
        if (gameStateChanged.getGameState() == GameState.LOGGED_IN && !isPanelInitialized)
        {
            SetConnectionState(true);
        }
        else if (gameStateChanged.getGameState() == GameState.LOGIN_SCREEN && isPanelInitialized)
        {
            SetConnectionState(false);
        }
    }

    @Subscribe
    public void onClientTick(ClientTick t){
        if (plugin.connected && isPanelInitialized){
            UpdateItems();
        }
    }

    public void SetConnectionState(boolean connectionStatus){
        if (connectionStatus){
            setVisible(true);
            isPanelInitialized = true;
            UpdateItems();
        } else {
            setVisible(false);
            isPanelInitialized = false;
            itemPanels.clear();
            equipmentPanel.removeAll();
            carePackPanel.removeAll();
            areaPanel.removeAll();
            junkPanel.removeAll();
            claimedPackPanel.removeAll();
        }
    }

    public void UpdateItems(){
        List<ItemData> items = ItemHandler.GetItems();
        if (items == null) return;
        for (ItemData item : items){
            int countInCollection = (int) plugin.getCollectedItems().stream().filter(it -> it.name.equals(item.name)).count();
            //Progressive items have special name formatting. Everything else uses the item name
            switch(item.name){
                case ItemNames.Progressive_Armor:
                    addOrUpdateItemPanel(item, String.format("Armor up to %s", ItemHandler.MetalTierByCount(countInCollection)));
                    break;
                case ItemNames.Progressive_Weapons:
                    addOrUpdateItemPanel(item, String.format("Weapons up to %s", ItemHandler.MetalTierByCount(countInCollection)));
                    break;
                case ItemNames.Progressive_Tools:
                    addOrUpdateItemPanel(item, String.format("Tools up to %s", ItemHandler.MetalTierByCount(countInCollection)));
                    break;
                case ItemNames.Progressive_Range_Armor:
                    addOrUpdateItemPanel(item, ItemHandler.RangeArmorTierByCount(countInCollection));
                    break;
                //Since there cannot possibly be a case where a datapackage is both a legacy run and not, whichever one these conditions trip will have the proper count
                case ItemNames.Progressive_Range_Weapon:
                case ItemNames.Progressive_Range_Weapon_Legacy:
                    addOrUpdateItemPanel(item, ItemHandler.RangeWeaponTierByCount(countInCollection));
                    break;
                case ItemNames.Progressive_Magic:
                case ItemNames.Progressive_Magic_Legacy:
                    addOrUpdateItemPanel(item, ItemHandler.MagicTierByCount(countInCollection));
                    break;
                default:
                    if (countInCollection > 0){
                        addOrUpdateItemPanel(item, item.name);
                    }
            }
        }
        //After updating item names and counts, go through the care packs to update their remaining claim status
        updateCarePackPanels();

        revalidate();
        repaint();
    }

    private void addOrUpdateItemPanel(ItemData item, String text){
        //The dict can have a null value, but if it does, we don't want to add it again (it's waiting for the ui thread)
        //So we just check the presence of the key here, then check for null inside the if
        if (itemPanels.containsKey(item)){
            if (itemPanels.get(item) != null){
                itemPanels.get(item).SetText(text);
            }
        } else {
            itemPanels.put(item, null);
            SwingUtilities.invokeLater(() -> {
                ItemRow itemPanel = new ItemRow(text, item);
                itemPanels.put(item, itemPanel);
                switch(item.getItemType()) {
                    case "Area":
                        areaPanel.add(itemPanel);
                        break;
                    case "Item":
                        equipmentPanel.add(itemPanel);
                        break;
                    case "CarePack":
                        carePackPanel.add(itemPanel);
                        break;
                    default:
                        junkPanel.add(itemPanel);
                        break;
                }
            });
        }
    }

    private void updateCarePackPanels(){
        for(ItemData item : itemPanels.keySet()){
            if (item.getItemType().equalsIgnoreCase("CarePack")){
                ItemRow panel = itemPanels.get(item);
                int countInInventory = (int) plugin.getCollectedItems().stream().filter(it -> it.name.equals(item.name)).count();
                int countClaimed = plugin.CheckClaimedCarePacks(item.id);
                if (countInInventory > countClaimed){
                    if (panel.getParent() == claimedPackPanel){
                        claimedPackPanel.remove(panel);
                        carePackPanel.add(panel);
                    }

                    panel.SetText(String.format("%s <br/>(%d / %d available)", item.name, countInInventory - countClaimed, countInInventory));
                } else {
                    if (panel.getParent() == carePackPanel){
                        carePackPanel.remove(panel);
                        claimedPackPanel.add(panel);
                        panel.ReplaceButtonWithLabel();
                    }
                    panel.SetText(String.format("%s <br/>(All claimed!)", item.name));
                }
            }
        }
        revalidate();
        repaint();
    }

    private static class ItemRow extends JPanel {
        private JComponent itemName;
        private final JLabel icon;
        private boolean isIconReady;
        private final ItemData itemData;
        private String previousText;

        public ItemRow(String text, ItemData item){
            super();
            itemData = item;
            setLayout(new BorderLayout());
            setBackground(ColorScheme.DARKER_GRAY_COLOR);
            setPreferredSize(new Dimension(0, 40));
            setAlignmentX(Component.LEFT_ALIGNMENT);
            previousText = text;
            icon = new JLabel();
            add(icon, BorderLayout.WEST);

            BufferedImage image = ItemHandler.loadedSprites.get(item);
            if (image != null){
                icon.setIcon(new ImageIcon(image));
                isIconReady = true;
            }

            if (item.getItemType().equalsIgnoreCase("CarePack")){
                JButton taskButton = new JButton("<html><div style='text-align:center'>"+text+"</div></html>");
                taskButton.setHorizontalAlignment(SwingConstants.CENTER);
                taskButton.addActionListener(e -> ClaimCarePack());
                itemName = taskButton;
            } else {
                itemName = new JLabel("<html><div style='text-align:center'>"+text+"</div></html>", SwingConstants.CENTER);
            }

            itemName.setForeground(Color.WHITE);
            add(itemName, BorderLayout.CENTER);
            setVisible(true);
        }

        public void SetText(String text){
            if (!previousText.equals(text)) {
                // Despite the fact that both JButton and JLabel have SetText, they don't actually have that through a shared class.
                // So I have to do this shit.
                if (itemName instanceof JButton) {
                    ((JButton) itemName).setText("<html><div style='text-align:center'>" + text.replace("Care Pack:", "") + "</div></html>");
                }
                if (itemName instanceof JLabel) {
                    ((JLabel) itemName).setText("<html><div style='text-align:center'>" + text.replace("Care Pack:", "") + "</div></html>");
                }
            }

            if (!isIconReady){
                BufferedImage image = ItemHandler.loadedSprites.get(itemData);
                if (image != null){
                    icon.setIcon(new ImageIcon(image));
                    isIconReady = true;
                }
            }
        }

        public void ClaimCarePack(){
            JFrame frame = (JFrame) SwingUtilities.getWindowAncestor(this);
            int result = JOptionPane.showConfirmDialog(
                    frame,
                    "Claim this care pack?", "Claim Care Pack",
                    JOptionPane.OK_CANCEL_OPTION,
                    JOptionPane.QUESTION_MESSAGE);
            if (result == JOptionPane.OK_OPTION){
                ArchipelagoPlugin.plugin.ClaimCarePack(itemData.id);
                ReplaceButtonWithLabel();
            }
        }

        public void ReplaceButtonWithLabel(){
            remove(itemName);
            itemName = new JLabel("<html><div style='text-align:center'>"+ itemData.name+"</div></html>", SwingConstants.CENTER);
            add(itemName, BorderLayout.CENTER);
            revalidate();
            repaint();
        }
    }
}

package gg.archipelago;

public class SlotData {

    public int brutal_grinds;
    public String data_csv_tag;
}

package gg.archipelago;

import gg.archipelago.Tasks.*;
import gg.archipelago.Tasks.EdgevilleMonasteryTask;
import gg.archipelago.Tasks.OpenLockboxTask;
import gg.archipelago.data.LocationData;
import net.runelite.api.*;
import net.runelite.client.game.SpriteManager;

import java.awt.image.BufferedImage;
import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.net.URL;
import java.util.*;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

public class TaskLists {
    public static final long base_id = 0x070000;
    public static int taskCount = 0;
    private static final String repository_address = "https://raw.githubusercontent.com/digiholic/osrs-archipelago-logic/";

    private static final boolean DEBUG = false;
    private static final String debugDataSource = "";

    private static List<APTask> allTasksCached = new ArrayList<>();
    public static List<APTask> GetAllTasks(String data_version){
        List<LocationData> locs = GetTaskCSVs(data_version);
        taskCount = 0;
        // For Legacy purposes, this is the data as it was on V1.2 of the Archipelago World. This was the last time
        // the data was hard-coded instead of being generated by the logic CSV files. If there is no version number
        // associated with the current slot, use that list.
        if (data_version == null || data_version.isEmpty() || locs == null){
            allTasksCached = defaultTasks;
        } else {
            allTasksCached = new ArrayList<>();
            for (LocationData loc : locs){
                APTask task = APTask.CreateFromLocationCSVRow(loc, base_id + taskCount++);
                if (task != null)
                    allTasksCached.add(task);
            }
        }

        return allTasksCached;
    }

    public static APTask GetTaskByID(long id){
        var filter = allTasksCached.stream().filter(apTask -> apTask.GetID() == id).findFirst();
        if (filter.isEmpty()){
            return null;
        } else {
            return filter.get();
        }
    }

    public static final Map<APTask, BufferedImage> loadedSprites = new HashMap<APTask, BufferedImage>();

    public static void LoadImages(SpriteManager spriteManager){
        for(APTask task : allTasksCached){
            //All tasks use an icon file offset of 0 so we can just assume that without needing to populate it
            loadedSprites.put(task, spriteManager.getSprite(task.GetSpriteID(), 0));
        }
    }

    public static List<LocationData> GetTaskCSVs(String dataVersion){
        if (dataVersion == null || dataVersion.isEmpty()) return null;
        String taggedRepoAddress = repository_address+dataVersion;
        List<LocationData> tasks = new ArrayList<>();
        try {
            BufferedReader in = null;
            if (DEBUG){
                FileReader fileIn = new FileReader(debugDataSource);
                in = new BufferedReader(fileIn);
            } else {
                URL repo = new URL(taggedRepoAddress+"/locations.csv");
                in = new BufferedReader(
                        new InputStreamReader(repo.openStream()));

            }
            parse_csv_file(tasks, in);
            in.close();
        }
        catch (IOException e) {
            return null;
        }
        return tasks;
    }

    private static void parse_csv_file(List<LocationData> tasks, BufferedReader in) throws IOException {
        String inputLine;
        while ((inputLine = in.readLine()) != null){
            // If the line is the optional header, skip it
            if (inputLine.startsWith("Location Name")) continue;

            List<String> row = new ArrayList<>();
            // Gnarly regex to capture CSV pattern without splitting on commas in quotes
            Matcher m = Pattern.compile("(?:,|\\n|^)(\"(?:(?:\"\")*[^\"]*)*\"|[^\",\\n]*|(?:\\n|$))")
                    .matcher(inputLine);
            while (m.find()){
                String match = m.group();
                if (match.startsWith(",")) match = match.substring(1);
                match = match.replace("\"","");
                row.add(match);
            }
            tasks.add(new LocationData(row));
        }
    }


    private static final List<APTask> defaultTasks = List.of(
            new QuestTask(base_id + taskCount++, Quest.COOKS_ASSISTANT),
            new QuestTask(base_id + taskCount++, Quest.DEMON_SLAYER),
            new QuestTask(base_id + taskCount++, Quest.THE_RESTLESS_GHOST),
            new QuestTask(base_id + taskCount++, Quest.ROMEO__JULIET),
            new QuestTask(base_id + taskCount++, Quest.SHEEP_SHEARER),
            new QuestTask(base_id + taskCount++, Quest.SHIELD_OF_ARRAV),
            new QuestTask(base_id + taskCount++, Quest.ERNEST_THE_CHICKEN),
            new QuestTask(base_id + taskCount++, Quest.VAMPYRE_SLAYER),
            new QuestTask(base_id + taskCount++, Quest.IMP_CATCHER),
            new QuestTask(base_id + taskCount++, Quest.PRINCE_ALI_RESCUE),
            new QuestTask(base_id + taskCount++, Quest.DORICS_QUEST),
            new QuestTask(base_id + taskCount++, Quest.BLACK_KNIGHTS_FORTRESS),
            new QuestTask(base_id + taskCount++, Quest.WITCHS_POTION),
            new QuestTask(base_id + taskCount++, Quest.THE_KNIGHTS_SWORD),
            new QuestTask(base_id + taskCount++, Quest.GOBLIN_DIPLOMACY),
            new QuestTask(base_id + taskCount++, Quest.PIRATES_TREASURE),
            new QuestTask(base_id + taskCount++, Quest.RUNE_MYSTERIES),
            new QuestTask(base_id + taskCount++, Quest.MISTHALIN_MYSTERY),
            new QuestTask(base_id + taskCount++, Quest.THE_CORSAIR_CURSE),
            new QuestTask(base_id + taskCount++, Quest.X_MARKS_THE_SPOT),
            new QuestTask(base_id + taskCount++, Quest.BELOW_ICE_MOUNTAIN),
            new QuestTask(base_id + taskCount++, Quest.DRAGON_SLAYER_I),
            new VarbitTask(base_id + taskCount++, "Activate the Rock Skin Prayer", SpriteID.SKILL_PRAYER, Prayer.ROCK_SKIN.getVarbit(), 1),
            new VarbitTask(base_id + taskCount++,"Activate the Protect Item Prayer", SpriteID.SKILL_PRAYER, Prayer.PROTECT_ITEM.getVarbit(), 1),
            new EdgevilleMonasteryTask(base_id + taskCount++),
            new CastSpellTask(base_id + taskCount++, "Bones To Bananas"),
            new CastSpellTask(base_id + taskCount++, "Varrock Teleport"),
            new CastSpellTask(base_id + taskCount++, "Lumbridge Teleport"),
            new CastSpellTask(base_id + taskCount++, "Falador Teleport"),
            new CraftRunesTask(base_id + taskCount++, "Craft some Air Runes", ItemID.AIR_RUNE, -1),
            new CraftRunesTask(base_id + taskCount++, "Craft some runes with a Mind Core", ItemID.MIND_RUNE, ItemID.MIND_CORE),
            new CraftRunesTask(base_id + taskCount++, "Craft some runes with a Body Core", ItemID.BODY_RUNE, ItemID.BODY_CORE),
            new ChatMessageTask(base_id + taskCount++,"Craft an Unblessed Holy Symbol",SpriteID.SKILL_CRAFTING, "You put some string on your holy symbol."),
            new ChatMessageTask(base_id + taskCount++,"Cut a Sapphire",SpriteID.SKILL_CRAFTING,"You cut the sapphire."),
            new ChatMessageTask(base_id + taskCount++,"Cut an Emerald",SpriteID.SKILL_CRAFTING, "You cut the emerald."),
            new ChatMessageTask(base_id + taskCount++,"Cut a Ruby",SpriteID.SKILL_CRAFTING, "You cut the ruby."),
            new ChatMessageTask(base_id + taskCount++,"Cut a Diamond",SpriteID.SKILL_CRAFTING, "You cut the diamond."),
            new ChatMessageTask(base_id + taskCount++,"Mine a Blurite Ore",SpriteID.SKILL_MINING, "You manage to mine some blurite."),
            new ChatMessageTask(base_id + taskCount++,"Crush a Barronite Deposit",SpriteID.SKILL_MINING, "You crush a barronite deposit with your hammer."),
            new ChatMessageTask(base_id + taskCount++,"Mine some Silver Ore",SpriteID.SKILL_MINING, "You manage to mine some silver."),
            new ChatMessageTask(base_id + taskCount++,"Mine some Coal",SpriteID.SKILL_MINING, "You manage to mine some coal."),
            new ChatMessageTask(base_id + taskCount++,"Mine some Gold Ore",SpriteID.SKILL_MINING, "You manage to mine some gold."),
            new ChatMessageTask(base_id + taskCount++,"Smelt an Iron Bar",SpriteID.SKILL_SMITHING, "You retrieve a bar of iron."),
            new ChatMessageTask(base_id + taskCount++,"Smelt a Silver Bar",SpriteID.SKILL_SMITHING, "You retrieve a bar of silver from the furnace."),
            new ChatMessageTask(base_id + taskCount++,"Smelt a Steel Bar",SpriteID.SKILL_SMITHING, "You retrieve a bar of steel."),
            new ChatMessageTask(base_id + taskCount++,"Smelt a Gold Bar",SpriteID.SKILL_SMITHING, "You retrieve a bar of gold from the furnace."),
            new ChatMessageTask(base_id + taskCount++,"Catch some Anchovies",SpriteID.SKILL_FISHING, "You catch some anchovies."),
            new ChatMessageTask(base_id + taskCount++,"Catch a Trout",SpriteID.SKILL_FISHING, "You catch a trout."),
            new ChatMessageTask(base_id + taskCount++,"Prepare a Tetra",SpriteID.SKILL_FISHING, "You successfully prepare the Tetra."),
            new ChatMessageTask(base_id + taskCount++,"Catch a Lobster",SpriteID.SKILL_FISHING, "You catch a lobster."),
            new ChatMessageTask(base_id + taskCount++,"Catch a Swordfish",SpriteID.SKILL_FISHING, "You catch a swordfish."),
            new ChatMessageTask(base_id + taskCount++,"Bake a Redberry Pie",SpriteID.SKILL_COOKING, "You successfully bake a delicious redberry pie."),
            new ChatMessageTask(base_id + taskCount++,"Cook a Stew",SpriteID.SKILL_COOKING, "You cook some stew."),
            new ChatMessageTask(base_id + taskCount++,"Bake an Apple Pie",SpriteID.SKILL_COOKING, "You successfully bake a traditional apple pie."),
            new ChatMessageTask(base_id + taskCount++,"Bake a Cake",SpriteID.SKILL_COOKING, "You successfully bake a cake."),
            new ChatMessageTask(base_id + taskCount++,"Bake a Meat Pizza",SpriteID.SKILL_COOKING, "You add the meat to the pizza."),
            new BurnLogsTask(base_id + taskCount++, BurnLogsTask.LogType.OAK),
            new BurnLogsTask(base_id + taskCount++, BurnLogsTask.LogType.WILLOW),
            new ChatMessageTask(base_id + taskCount++, "Sail on a Canoe",SpriteID.SKILL_WOODCUTTING, "Your canoe sinks into the water after the hard journey."),
            new ChatMessageTask(base_id + taskCount++, "Chop some Oak Logs",SpriteID.SKILL_WOODCUTTING, "You get some oak logs."),
            new ChatMessageTask(base_id + taskCount++, "Chop some Willow Logs",SpriteID.SKILL_WOODCUTTING, "You get some willow logs."),
            new KillTask(base_id + taskCount++, "Jeff"),
            new KillTask(base_id + taskCount++, "Goblin"),
            new KillTask(base_id + taskCount++, "Monkey"),
            new KillTask(base_id + taskCount++, "Barbarian"),
            new KillTask(base_id + taskCount++, "Giant Frog"),
            new KillTask(base_id + taskCount++, "Zombie"),
            new KillTask(base_id + taskCount++, "Guard"),
            new KillTask(base_id + taskCount++, "Hill Giant"),
            new KillTask(base_id + taskCount++, "Deadly Red Spider"),
            new KillTask(base_id + taskCount++, "Moss Giant"),
            new KillTask(base_id + taskCount++, "Catablepon"),
            new KillTask(base_id + taskCount++, "Ice Giant"),
            new KillTask(base_id + taskCount++, "Lesser Demon"),
            new KillTask(base_id + taskCount++, "Ogress Shaman"),
            new KillTask(base_id + taskCount++, "Obor"),
            new KillTask(base_id + taskCount++, "Bryophyta"),
            new TotalXPTask(base_id + taskCount++, 5000),
            new CombatLevelTask(base_id + taskCount++, 5),
            new TotalXPTask(base_id + taskCount++, 10000),
            new TotalLevelTask(base_id + taskCount++, 50),
            new TotalXPTask(base_id + taskCount++, 25000),
            new TotalLevelTask(base_id + taskCount++, 100),
            new TotalXPTask(base_id + taskCount++, 50000),
            new CombatLevelTask(base_id + taskCount++, 15),
            new TotalLevelTask(base_id + taskCount++, 150),
            new TotalXPTask(base_id + taskCount++, 75000),
            new CombatLevelTask(base_id + taskCount++, 25),
            new TotalXPTask(base_id + taskCount++, 100000),
            new TotalLevelTask(base_id + taskCount++, 200),
            new TotalXPTask(base_id + taskCount++, 125000),
            new CombatLevelTask(base_id + taskCount++, 30),
            new TotalLevelTask(base_id + taskCount++, 250),
            new TotalXPTask(base_id + taskCount++, 150000),
            new TotalLevelTask(base_id + taskCount++, 300),
            new CombatLevelTask(base_id + taskCount++, 40),
            new OpenLockboxTask(base_id + taskCount++, ItemID.SIMPLE_LOCKBOX),
            new OpenLockboxTask(base_id + taskCount++, ItemID.ELABORATE_LOCKBOX),
            new OpenLockboxTask(base_id + taskCount++, ItemID.ORNATE_LOCKBOX)
    );
}

package gg.archipelago;

import gg.archipelago.Tasks.APTask;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.GameState;
import net.runelite.api.events.ClientTick;
import net.runelite.api.events.GameStateChanged;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.ui.ColorScheme;

import javax.swing.*;
import javax.swing.border.EmptyBorder;
import java.awt.*;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.awt.image.BufferedImage;
import java.util.HashMap;

@Slf4j
public class TaskPanel extends JPanel {
    private final ArchipelagoPlugin plugin;

    private final JCheckBox displayCompleted;
    private final HashMap<Long, TaskRow> locationPanels = new HashMap<Long, TaskRow>();

    private boolean isPanelInitialized = false;

    public TaskPanel(ArchipelagoPlugin plugin){
        this.plugin = plugin;

        setLayout(new BoxLayout(this, BoxLayout.Y_AXIS));
        setBorder(new EmptyBorder(5, 5, 5, 10));
        setVisible(false);

        displayCompleted = new JCheckBox("Display Completed Tasks");
        displayCompleted.setAlignmentX(Component.LEFT_ALIGNMENT);
        displayCompleted.addActionListener(e -> SwingUtilities.invokeLater(this::UpdateTaskStatus));

        add(displayCompleted);
        setAlignmentX(Component.LEFT_ALIGNMENT);
    }

    @Subscribe
    public void onGameStateChanged(GameStateChanged gameStateChanged)
    {
        if (gameStateChanged.getGameState() == GameState.LOGGED_IN && !isPanelInitialized)
        {
            SetConnectionState(true);
        }
        else if (gameStateChanged.getGameState() == GameState.LOGIN_SCREEN && isPanelInitialized)
        {
            SetConnectionState(false);
        }
    }

    @Subscribe
    public void onClientTick(ClientTick t){
        if (plugin.connected && isPanelInitialized){
            UpdateTaskStatus();
        }
    }

    public void SetConnectionState(boolean connectionStatus) {
        if (connectionStatus){
            setVisible(true);
            isPanelInitialized = true;
            UpdateTaskStatus();
        } else {
            setVisible(false);
            isPanelInitialized = false;
            removeAll();
            add(displayCompleted);
        }
    }

    public void UpdateTaskStatus(){
        for (APTask task : plugin.activeTasks){
            if (task.ShouldDisplayPanel()){
                AddOrUpdateTaskRow(task);
            }
        }

        revalidate();
        repaint();
    }

    private void AddOrUpdateTaskRow(APTask task){

        //boolean completed = plugin.LocationCheckStates.getOrDefault(loc,false);
        if (locationPanels.containsKey(task.GetID())){
            TaskRow row = locationPanels.get(task.GetID());
            row.task = task;
            row.UpdateCompleted(task.IsCompleted());
            row.UpdateDisplay();
        } else {
            TaskRow taskPanel = new TaskRow(task);
            locationPanels.put(task.GetID(), taskPanel);
            add(taskPanel);
        }
    }

    private class TaskRow extends JPanel{
        private JComponent taskName;
        private boolean isIconReady = false;
        private final JLabel icon;
        private APTask task;
        public TaskRow(APTask task){
            this.task = task;

            BufferedImage image = TaskLists.loadedSprites.get(task);
            setLayout(new BorderLayout());
            setBackground(task.IsCompleted() ? ColorScheme.PROGRESS_COMPLETE_COLOR : ColorScheme.DARKER_GRAY_COLOR);
            setPreferredSize(new Dimension(0, 36));
            setAlignmentX(Component.LEFT_ALIGNMENT);

            if (image != null){
                icon = new JLabel(new ImageIcon(image));
                isIconReady = true;
            } else {
                icon = new JLabel();
            }
            icon.setPreferredSize(new Dimension(32,0));
            add(icon, BorderLayout.WEST);

            // For the time being, disable the "Can Manually Activate" check and let users click any of the task buttons.
            // The state-based tasks _should_ be working now, but no sense letting a glitch prevent someone's progress
            // if (!task.IsCompleted() && task.CanManuallyActivate()){
            if (!task.IsCompleted()){
                JButton taskButton = new JButton("<html><div style='text-align:center'>"+task.GetName()+"</div></html>");
                taskButton.setHorizontalAlignment(SwingConstants.CENTER);
                taskButton.addActionListener(e -> ManuallyComplete());

                taskName = taskButton;
            } else {
                taskName = new JLabel("<html><div style='text-align:center'>"+task.GetName()+"</div></html>", SwingConstants.CENTER);
            }

            taskName.setForeground(task.IsCompleted() ? Color.BLACK : Color.WHITE);
            add(taskName, BorderLayout.CENTER);
            setVisible(!task.IsCompleted() || displayCompleted.isSelected());
        }

        public void UpdateCompleted(boolean completed){
            if (completed && taskName instanceof JButton) {
                remove(taskName);
                taskName = new JLabel("<html><div style='text-align:center'>"+task.GetName()+"</div></html>", SwingConstants.CENTER);
                add(taskName, BorderLayout.CENTER);
            }
            setBackground(completed ? ColorScheme.PROGRESS_COMPLETE_COLOR : ColorScheme.DARKER_GRAY_COLOR);
            taskName.setForeground(completed ? Color.BLACK : Color.WHITE);
        }

        public void UpdateDisplay()
        {
            if (!isIconReady){
                BufferedImage image = TaskLists.loadedSprites.get(task);
                if (image != null){
                    icon.setIcon(new ImageIcon(image));
                    isIconReady = true;
                }
            }
            setVisible(!task.IsCompleted() || displayCompleted.isSelected());
        }

        public void ManuallyComplete(){
            JFrame frame = (JFrame) SwingUtilities.getWindowAncestor(this);
            int result = JOptionPane.showConfirmDialog(
                    frame,
                    "Mark this task as completed?", "Manually Complete",
                    JOptionPane.OK_CANCEL_OPTION,
                    JOptionPane.QUESTION_MESSAGE);
            if (result == JOptionPane.OK_OPTION){
                log.info("Completed task "+task.GetName());
                task.SetCompleted();
            }
        }
    }
}

package gg.archipelago.Tasks;

import gg.archipelago.data.LocationData;
import net.runelite.api.*;
import net.runelite.api.events.ChatMessage;
import net.runelite.api.events.MenuOptionClicked;
import net.runelite.api.widgets.Widget;

import java.util.List;
import java.util.Map;

public abstract class APTask {
    public abstract String GetName();
    public abstract long GetID();
    public abstract boolean IsCompleted();
    public abstract void SetCompleted();
    public abstract int GetSpriteID();
    public abstract boolean ShouldDisplayPanel();

    public abstract void CheckChatMessage(ChatMessage event);
    public abstract void CheckMobKill(NPC npc);
    public abstract void CheckPlayerStatus(Client client);
    public abstract void OnGameTick(Client client);
    public abstract void OnMenuOption(MenuOptionClicked event);

    public abstract boolean CanManuallyActivate();


    // Task Parser Constructor
    private static final String QUEST = "QuestTask";
    private static final String VARBIT = "VarbitTask";
    private static final String VARBIT_CHANGED = "VarbitChangedTask";
    private static final String SPELL = "SpellTask";
    private static final String CRAFT_RUNES = "CraftRunesTask";
    private static final String CHAT = "ChatMessageTask";
    private static final String MENU = "MenuActionTask";
    private static final String BURN = "BurnLogsTask";
    private static final String KILL = "KillTask";
    private static final String XP = "TotalXPTask";
    private static final String COMBAT = "CombatLevelTask";
    private static final String TOTAL = "TotalLevelTask";
    private static final String MILESTONE = "LevelMilestoneTask";
    private static final String STAND_POSITION = "StandInPositionTask";
    private static final String STAND_AREA = "StandInAreaTask";
    private static final String EMOTE_AREA = "EmoteInAreaTask";
    private static final String ITEM = "ItemOperationTask";
    private static final String WIDGET = "WidgetOpenTask";


    public static APTask CreateFromLocationCSVRow(LocationData row, long locationId){
        List<String> args = row.getPluginTaskArgs();
        switch(row.getPluginTaskType()){
            case QUEST:
                //remove the prefix to get the quest name
                String quest_name = row.getLocationName().replace("Quest: ","");
                return new QuestTask(locationId, QuestsByName.get(quest_name));
            case VARBIT:
                return new VarbitTask(locationId, row.getLocationName(),
                        Integer.parseInt(args.get(0)),
                        Integer.parseInt(args.get(1)),
                        Integer.parseInt(args.get(2)));
            case VARBIT_CHANGED:
                return new VarbitChangedTask(locationId, row.getLocationName(),
                        Integer.parseInt(args.get(0)),
                        Integer.parseInt(args.get(1)));
            case SPELL:
                return new CastSpellTask(locationId, row.getLocationName(),
                        args.get(0));
            case CRAFT_RUNES:
                return new CraftRunesTask(locationId, row.getLocationName(),
                        Integer.parseInt(args.get(0)),
                        Integer.parseInt(args.get(1)));
            case CHAT:
                return new ChatMessageTask(locationId, row.getLocationName(),
                        Integer.parseInt(args.get(0)),
                        args.get(1));
            case MENU:
                return new MenuActionTask(locationId, row.getLocationName(),
                        Integer.parseInt(args.get(0)),
                        args.get(1), args.get(2));
            case BURN:
                return new BurnLogsTask(locationId, row.getLocationName(),
                        Integer.parseInt(args.get(0)),
                        Integer.parseInt(args.get(1)));
            case KILL:
                return new KillTask(locationId, args.get(0));
            case XP:
                return new TotalXPTask(locationId, Integer.parseInt(args.get(0)));
            case COMBAT:
                return new CombatLevelTask(locationId, Integer.parseInt(args.get(0)));
            case TOTAL:
                return new TotalLevelTask(locationId, Integer.parseInt(args.get(0)));
            case MILESTONE:
                return new LevelMilestoneTask(locationId, Integer.parseInt(args.get(0)));
            case STAND_POSITION:
                return new StandInPositionTask(locationId, row.getLocationName(),
                        Integer.parseInt(args.get(0)), Integer.parseInt(args.get(1)),
                        Integer.parseInt(args.get(2)), Integer.parseInt(args.get(3)));
            case STAND_AREA:
                return new StandInAreaTask(locationId, row.getLocationName(), Integer.parseInt(args.get(0)),
                        Integer.parseInt(args.get(1)),Integer.parseInt(args.get(2)),Integer.parseInt(args.get(3)),
                        Integer.parseInt(args.get(4)),Integer.parseInt(args.get(5)),Integer.parseInt(args.get(6)));
            case EMOTE_AREA:
                return new EmoteInAreaTask(locationId, row.getLocationName(), Integer.parseInt(args.get(0)), args.get(1),
                        Integer.parseInt(args.get(2)),Integer.parseInt(args.get(3)),Integer.parseInt(args.get(4)),
                        Integer.parseInt(args.get(5)),Integer.parseInt(args.get(6)),Integer.parseInt(args.get(7)));
            case ITEM:
                return new ItemOperationTask(locationId, row.getLocationName(),
                        Integer.parseInt(args.get(0)), args.get(1),
                        Integer.parseInt(args.get(2)));
            case WIDGET:
                return new WidgetOpenTask(locationId, row.getLocationName(),
                        Integer.parseInt(args.get(0)),
                        Integer.parseInt(args.get(1)));
            default:
                // If it's nothing above, it's a unique task we have to check by name.
                switch(row.getLocationName()){
                    case "Pray at the Edgeville Monastery": return new EdgevilleMonasteryTask(locationId);
                    case "Open a Simple Lockbox": return new OpenLockboxTask(locationId, ItemID.SIMPLE_LOCKBOX);
                    case "Open an Elaborate Lockbox": return new OpenLockboxTask(locationId, ItemID.ELABORATE_LOCKBOX);
                    case "Open an Ornate Lockbox": return new OpenLockboxTask(locationId, ItemID.ORNATE_LOCKBOX);
                    case "Have the Apothecary Make a Strength Potion": return new BuyPotionTask(locationId);
                    case "Telegrab a Gold Bar from the Varrock Bank": return new TelegrabGoldBarTask(locationId);
                    default: return new ManualTask(locationId, row.getLocationName());
                }
        }

    }

    // The Enum just doesn't exist at runtime. We have to make this map
    private static Map<String, Quest> QuestsByName = Map.ofEntries(
        Map.entry(Quest.COOKS_ASSISTANT.getName(), Quest.COOKS_ASSISTANT),
        Map.entry(Quest.DEMON_SLAYER.getName(), Quest.DEMON_SLAYER),
        Map.entry(Quest.THE_RESTLESS_GHOST.getName(), Quest.THE_RESTLESS_GHOST),
        Map.entry(Quest.ROMEO__JULIET.getName(), Quest.ROMEO__JULIET),
        Map.entry(Quest.SHEEP_SHEARER.getName(), Quest.SHEEP_SHEARER),
        Map.entry(Quest.SHIELD_OF_ARRAV.getName(), Quest.SHIELD_OF_ARRAV),
        Map.entry(Quest.ERNEST_THE_CHICKEN.getName(), Quest.ERNEST_THE_CHICKEN),
        Map.entry(Quest.VAMPYRE_SLAYER.getName(), Quest.VAMPYRE_SLAYER),
        Map.entry(Quest.IMP_CATCHER.getName(), Quest.IMP_CATCHER),
        Map.entry(Quest.PRINCE_ALI_RESCUE.getName(), Quest.PRINCE_ALI_RESCUE),
        Map.entry(Quest.DORICS_QUEST.getName(), Quest.DORICS_QUEST),
        Map.entry(Quest.BLACK_KNIGHTS_FORTRESS.getName(), Quest.BLACK_KNIGHTS_FORTRESS),
        Map.entry(Quest.WITCHS_POTION.getName(), Quest.WITCHS_POTION),
        Map.entry(Quest.THE_KNIGHTS_SWORD.getName(), Quest.THE_KNIGHTS_SWORD),
        Map.entry(Quest.GOBLIN_DIPLOMACY.getName(), Quest.GOBLIN_DIPLOMACY),
        Map.entry(Quest.PIRATES_TREASURE.getName(), Quest.PIRATES_TREASURE),
        Map.entry(Quest.RUNE_MYSTERIES.getName(), Quest.RUNE_MYSTERIES),
        Map.entry(Quest.MISTHALIN_MYSTERY.getName(), Quest.MISTHALIN_MYSTERY),
        Map.entry(Quest.THE_CORSAIR_CURSE.getName(), Quest.THE_CORSAIR_CURSE),
        Map.entry(Quest.X_MARKS_THE_SPOT.getName(), Quest.X_MARKS_THE_SPOT),
        Map.entry(Quest.BELOW_ICE_MOUNTAIN.getName(), Quest.BELOW_ICE_MOUNTAIN),
        Map.entry(Quest.DRAGON_SLAYER_I.getName(), Quest.DRAGON_SLAYER_I)
    );
}


package gg.archipelago.Tasks;

import lombok.extern.java.Log;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.NPC;
import net.runelite.api.Skill;
import net.runelite.api.SpriteID;
import net.runelite.api.events.ChatMessage;
import net.runelite.api.events.MenuOptionClicked;
import net.runelite.client.plugins.PluginDescriptor;

public class  BurnLogsTask extends StateTrackingTask{

    private final long _ID;

    private String _name;
    private int _required_level;
    private int _xp_gained;
    private int _previousFiremakingXP;

    private final String logs_burning_message = "The fire catches and the logs begin to burn.";
    public BurnLogsTask(Long ID, LogType logType){
        _ID = ID;

        switch(logType){
            case OAK:
                _name = "Burn an Oak Log";
                _required_level = 15;
                _xp_gained = 60;
                break;
            case WILLOW:
                _name = "Burn a Willow Log";
                _required_level = 30;
                _xp_gained = 90;
        }
    }

    public BurnLogsTask(Long ID, String name, int required_level, int xp_gained){
        _ID = ID;
        _name = name;
        _required_level = required_level;
        _xp_gained = xp_gained;
    }
    @Override
    public void CheckChatMessage(ChatMessage event) {
        // Check for burning log message
        if (event.getMessage().equalsIgnoreCase(logs_burning_message)){
            checkTriggered = true;
        }
    }
    @Override
    public void CheckMobKill(NPC npc) { }
    @Override
    public void CheckPlayerStatus(Client client) { }
    @Override
    public void OnMenuOption(MenuOptionClicked event) { }

    @Override
    public String GetName() {
        return _name;
    }

    @Override
    public long GetID() {
        return _ID;
    }

    @Override
    public int GetSpriteID() {
        return SpriteID.SKILL_FIREMAKING;
    }

    @Override
    public boolean ShouldDisplayPanel() {
        return true;
    }

    @Override
    boolean CheckResetCondition(Client client) {
        return true;
    }

    @Override
    boolean CheckInitialStateOK(Client client) {
        // Check for Firemaking level requirement
        if (!(client.getRealSkillLevel(Skill.FIREMAKING) >= _required_level)) return false;
        _previousFiremakingXP = client.getSkillExperience(Skill.FIREMAKING);
        return true;
    }

    @Override
    boolean CheckPostTriggerStateOK(Client client) {
        // Check for XP increase for specific log
        return client.getSkillExperience(Skill.FIREMAKING) == _previousFiremakingXP + _xp_gained;
    }

    public enum LogType{
        OAK,
        WILLOW
    }
}

package gg.archipelago.Tasks;

import lombok.extern.slf4j.Slf4j;
import net.runelite.api.*;
import net.runelite.api.events.ChatMessage;
import net.runelite.api.events.MenuOptionClicked;
import net.runelite.client.util.Text;

import java.util.Arrays;

@Slf4j
public class BuyPotionTask extends StateTrackingTask{

    private final long _ID;

    private final String _name = "Have the Apothecary Make a Strength Potion";

    private boolean _shouldCancel = false;

    private int _previousPotionCount = 0;

    public BuyPotionTask(Long ID){
        _ID = ID;
    }

    @Override
    public void CheckChatMessage(ChatMessage event) { }
    @Override
    public void CheckMobKill(NPC npc) { }
    @Override
    public void CheckPlayerStatus(Client client) { }
    @Override
    public void OnMenuOption(MenuOptionClicked event) {
        //Check for Runecraft option
        if (event.getMenuOption().startsWith("Buy-") &&
                Text.removeTags(event.getMenuTarget()).equalsIgnoreCase("Strength potion")){
            checkTriggered = true;
            _shouldCancel = false;
            log.info("BuyPotion task is primed.");
        } else {
            _shouldCancel = true;
        }
    }

    @Override
    public String GetName() {
        return _name;
    }

    @Override
    public long GetID() { return _ID; }
    @Override
    public int GetSpriteID() { return SpriteID.MINIMAP_ORB_WORLD_MAP_PLANET; }
    @Override
    public boolean ShouldDisplayPanel() { return true; }

    @Override
    boolean CheckResetCondition(Client client) {
        return _shouldCancel;
    }

    @Override
    boolean CheckInitialStateOK(Client client) {
        _previousPotionCount = CheckInventoryFor(client, ItemID.STRENGTH_POTION4);

        return true;
    }

    @Override
    boolean CheckPostTriggerStateOK(Client client) {
        int currentPotionCount = CheckInventoryFor(client, ItemID.STRENGTH_POTION4);
        return currentPotionCount > _previousPotionCount;
    }

    private int CheckInventoryFor(Client client, int itemID) {
        ItemContainer inventory = client.getItemContainer(InventoryID.INVENTORY);
        if (inventory != null) {
            Item[] currentItems = inventory.getItems();
            final int finalItem_id = itemID;
            final int[] item_count = {0}; //anti lambda capture shenanigans
            Object[] items = Arrays.stream(currentItems).filter(item -> item.getId() == finalItem_id).toArray();

            Arrays.stream(currentItems).filter(item -> item.getId() == finalItem_id)
                    .forEach(item -> item_count[0] += item.getQuantity());
            return item_count[0];
        }
        return 0;
    }
}

package gg.archipelago.Tasks;

import lombok.extern.slf4j.Slf4j;
import net.runelite.api.*;
import net.runelite.api.events.ChatMessage;
import net.runelite.api.events.MenuOptionClicked;
import net.runelite.client.util.Text;

@Slf4j
public class CastSpellTask extends StateTrackingTask{

    private final long _ID;

    private String _name;
    private String _spell_name;

    private int _previousMagicXP;
    private boolean shouldCancel = false;

    public CastSpellTask(Long ID, String spell){
        _ID = ID;
        _name = "Cast "+spell;
        _spell_name = spell;
    }

    public CastSpellTask(Long ID, String name, String spell){
        _ID = ID;
        _name = name;
        _spell_name = spell;
    }

    @Override
    public void CheckChatMessage(ChatMessage event) { }
    @Override
    public void CheckMobKill(NPC npc) { }
    @Override
    public void CheckPlayerStatus(Client client) { }
    @Override
    public void OnMenuOption(MenuOptionClicked event) {
        if (checkTriggered){
            MenuAction action = event.getMenuAction();
            // If we're pending a check and we do any menu options that aren't "Targetting a spell", un-set the trigger next tick
            if (action != MenuAction.WIDGET_TARGET &&
                action != MenuAction.WIDGET_TARGET_ON_GAME_OBJECT &&
                action != MenuAction.WIDGET_TARGET_ON_NPC &&
                action != MenuAction.WIDGET_TARGET_ON_GROUND_ITEM &&
                action != MenuAction.WIDGET_TARGET_ON_PLAYER &&
                action != MenuAction.WIDGET_TARGET_ON_WIDGET) {
                checkTriggered = false;
                shouldCancel = true;
            }
        }
        // Spells always have a widget set
        if (event.getWidget() != null){
            String widgetName = Text.removeTags(event.getWidget().getName());
            if (widgetName.equalsIgnoreCase(_spell_name)){
                checkTriggered = true;
                shouldCancel = false;
            }
        }
    }

    @Override
    public String GetName() {
        return _name;
    }

    @Override
    public long GetID() {
        return _ID;
    }

    @Override
    public int GetSpriteID() {
        return SpriteID.SKILL_MAGIC;
    }

    @Override
    public boolean ShouldDisplayPanel() {
        return true;
    }

    @Override
    boolean CheckResetCondition(Client client) {
        return shouldCancel;
    }

    @Override
    boolean CheckInitialStateOK(Client client) {
        _previousMagicXP = client.getSkillExperience(Skill.MAGIC);
        return true;
    }

    @Override
    boolean CheckPostTriggerStateOK(Client client) {
        //If you've gained magic XP and nothing has broken the condition yet, you've done it.
        return client.getSkillExperience(Skill.MAGIC) > _previousMagicXP;
    }
}

package gg.archipelago.Tasks;

import gg.archipelago.ArchipelagoPlugin;
import net.runelite.api.ChatMessageType;
import net.runelite.api.Client;
import net.runelite.api.NPC;
import net.runelite.api.events.ChatMessage;
import net.runelite.api.events.MenuOptionClicked;

public class ChatMessageTask extends APTask{
    private final long _ID;
    private final String _messageToCheck;
    private boolean _isCompleted = false;
    private String _name;
    private int _spriteID;

    public ChatMessageTask(long ID, String name, int spriteID, String messageToCheck){
        _ID = ID;
        _name = name;
        _spriteID = spriteID;
        _messageToCheck = messageToCheck;
    }

    @Override
    public void CheckChatMessage(ChatMessage event) {
        String[] splitMessages = event.getMessage().split("<br>");
        for (String msg : splitMessages) {
            if (msg.equalsIgnoreCase(_messageToCheck.replace("<player>", ArchipelagoPlugin.plugin.getCurrentPlayerName()))){
                _isCompleted = true;
            }
        }
    }

    @Override
    public void CheckMobKill(NPC npc) { }
    @Override
    public void CheckPlayerStatus(Client client) { }
    @Override
    public void OnGameTick(Client client) { }
    @Override
    public void OnMenuOption(MenuOptionClicked event) {

    }

    @Override
    public boolean IsCompleted() {
        return _isCompleted;
    }
    @Override
    public void SetCompleted() { _isCompleted = true; }

    @Override
    public int GetSpriteID() {
        return _spriteID;
    }

    @Override
    public boolean ShouldDisplayPanel() {
        return true;
    }

    @Override
    public String GetName() {
        return _name;
    }

    @Override
    public long GetID() {
        return _ID;
    }


    @Override
    public boolean CanManuallyActivate() {
        return true;
    }
}

package gg.archipelago.Tasks;

import net.runelite.api.Client;
import net.runelite.api.NPC;
import net.runelite.api.SpriteID;
import net.runelite.api.events.ChatMessage;
import net.runelite.api.events.MenuOptionClicked;

public class CombatLevelTask extends APTask{
    private final long _ID;
    private final int _combatLevelRequired;
    private boolean _isCompleted = false;


    public CombatLevelTask(long ID, int combatLevelRequired){
        _ID = ID;
        _combatLevelRequired = combatLevelRequired;

    }
    @Override
    public void CheckPlayerStatus(Client client) {
        if (client.getLocalPlayer().getCombatLevel() >= _combatLevelRequired)
            _isCompleted = true;
    }

    @Override
    public void OnGameTick(Client client) { }
    @Override
    public void OnMenuOption(MenuOptionClicked event) { }
    @Override
    public void CheckChatMessage(ChatMessage event) { }
    @Override
    public void CheckMobKill(NPC npc) { }
    @Override
    public boolean IsCompleted() {
        return _isCompleted;
    }
    @Override
    public void SetCompleted() { _isCompleted = true; }
    @Override
    public int GetSpriteID() { return SpriteID.SKILL_TOTAL; }
    @Override
    public boolean ShouldDisplayPanel() { return true; }
    @Override
    public String GetName() { return String.format("Combat Level %d", _combatLevelRequired); }
    @Override
    public long GetID() {
        return _ID;
    }

    @Override
    public boolean CanManuallyActivate() {
        return false;
    }
}

package gg.archipelago.Tasks;

import lombok.extern.slf4j.Slf4j;
import net.runelite.api.*;
import net.runelite.api.events.ChatMessage;
import net.runelite.api.events.MenuOptionClicked;

import java.util.Arrays;
import java.util.Optional;

@Slf4j
public class CraftRunesTask extends StateTrackingTask{

    private final long _ID;

    private String _name;

    private int _rune_id;
    //if any essence is acceptable, pass -1 for "Any"
    private int _essence_id;

    private int _previousRunecraftXP;
    private int _previousRuneCount;
    private boolean _shouldCancel = false;

    public CraftRunesTask(Long ID, String name, int rune_id, int essence_id ){
        _ID = ID;
        _name = name;
        _rune_id = rune_id;
        _essence_id = essence_id;
    }

    @Override
    public void CheckChatMessage(ChatMessage event) { }
    @Override
    public void CheckMobKill(NPC npc) { }
    @Override
    public void CheckPlayerStatus(Client client) { }
    @Override
    public void OnMenuOption(MenuOptionClicked event) {
        //Check for Runecraft option
        if (event.getMenuOption().equalsIgnoreCase("Craft-rune")){
            checkTriggered = true;
            _shouldCancel = false;
            log.info("Runecraft task is primed.");
        } else {
            _shouldCancel = true;
            _previousRunecraftXP = 0;
            _previousRuneCount = 0;
        }
    }

    @Override
    public String GetName() {
        return _name;
    }

    @Override
    public long GetID() { return _ID; }
    @Override
    public int GetSpriteID() { return SpriteID.SKILL_RUNECRAFT; }
    @Override
    public boolean ShouldDisplayPanel() { return true; }

    @Override
    boolean CheckResetCondition(Client client) {
        return _shouldCancel;
    }

    @Override
    boolean CheckInitialStateOK(Client client) {
        //If the essence ID is -1, it means "Any essence" and we don't need to check for it
        boolean hasEssence = _essence_id == -1 || CheckInventoryFor(client, _essence_id) > 0;
        _previousRunecraftXP = client.getSkillExperience(Skill.RUNECRAFT);
        _previousRuneCount = CheckInventoryFor(client, _rune_id);

        return hasEssence;
    }

    @Override
    boolean CheckPostTriggerStateOK(Client client) {
        boolean hasGainedXP = client.getSkillExperience(Skill.RUNECRAFT) > _previousRunecraftXP;
        boolean hasGainedRunes = CheckInventoryFor(client, _rune_id) > _previousRuneCount;

        //Check for any increase in RC XP and increase in item count for rune
        return hasGainedXP && hasGainedRunes;
    }

    private int CheckInventoryFor(Client client, int itemID) {
        ItemContainer inventory = client.getItemContainer(InventoryID.INVENTORY);
        if (inventory != null) {
            Item[] currentItems = inventory.getItems();
            final int finalItem_id = itemID;
            final int[] item_count = {0}; //anti lambda capture shenanigans
            Object[] items = Arrays.stream(currentItems).filter(item -> item.getId() == finalItem_id).toArray();

            Arrays.stream(currentItems).filter(item -> item.getId() == finalItem_id)
                    .forEach(item -> item_count[0] += item.getQuantity());
            return item_count[0];
        }
        return 0;
    }
}

package gg.archipelago.Tasks;

import gg.archipelago.Tasks.APTask;
import net.runelite.api.*;
import net.runelite.api.coords.WorldPoint;
import net.runelite.api.events.ChatMessage;
import net.runelite.api.events.MenuOptionClicked;

public class EdgevilleMonasteryTask extends APTask {
    private final long _ID;
    private boolean _isCompleted;

    private int _currentRegionID;
    public EdgevilleMonasteryTask(long ID){
        _ID = ID;
    }
    @Override
    public void CheckPlayerStatus(Client client) {
        Player player = client.getLocalPlayer();
        if (player == null) {
            _currentRegionID = -1;
        } else {
            _currentRegionID = WorldPoint.fromLocalInstance(client, player.getLocalLocation()).getRegionID();
        }
    }

    @Override
    public void OnGameTick(Client client) { }
    @Override
    public void OnMenuOption(MenuOptionClicked event) { }

    @Override
    public boolean CanManuallyActivate() { return true; }

    @Override
    public void CheckChatMessage(ChatMessage event) {
        // If the player is not currently in the monastery chunk, exit without checking.
        if (_currentRegionID != 12086) return;

        String[] splitMessages = event.getMessage().split("<br>");
        for (String msg : splitMessages) {
            String _message_B = "You boost your Prayer points.";
            String _message_A = "You recharge your Prayer points.";
            if (msg.equalsIgnoreCase(_message_A) || msg.equals(_message_B)){
                _isCompleted = true;
            }
        }
    }
    @Override
    public void CheckMobKill(NPC npc) { }
    @Override
    public boolean IsCompleted() {
        return _isCompleted;
    }
    @Override
    public void SetCompleted() { _isCompleted = true; }

    @Override
    public int GetSpriteID() {
        return SpriteID.SKILL_PRAYER;
    }

    @Override
    public boolean ShouldDisplayPanel() {
        return true;
    }

    @Override
    public String GetName() {
        return "Pray at the Edgeville Monastery";
    }

    @Override
    public long GetID() {
        return _ID;
    }
}

package gg.archipelago.Tasks;

import net.runelite.api.Client;
import net.runelite.api.NPC;
import net.runelite.api.coords.WorldPoint;
import net.runelite.api.events.ChatMessage;
import net.runelite.api.events.MenuOptionClicked;
import net.runelite.client.util.Text;

public class EmoteInAreaTask extends APTask {
    private final long _ID;
    private final String _name;
    private boolean _isCompleted;
    private final int _spriteID;
    private final WorldPoint _topleft_point;
    private final WorldPoint _bottomright_point;
    private final String _emote;

    private boolean _in_area;

    public EmoteInAreaTask(long ID, String name, int spriteID, String emote, int tl_x, int tl_y, int tl_plane, int br_x, int br_y, int br_plane){
        _ID = ID;
        _name = name;
        _spriteID = spriteID;
        _emote = emote;
        _topleft_point = new WorldPoint(tl_x, tl_y, tl_plane);
        _bottomright_point = new WorldPoint(br_x, br_y, br_plane);
    }

    @Override
    public void OnMenuOption(MenuOptionClicked event) {
        if (event.getMenuOption().equalsIgnoreCase("Perform") && Text.removeTags(event.getMenuTarget()).equalsIgnoreCase(_emote)){
            if (_in_area)
                SetCompleted();
        }
    }
    @Override
    public void OnGameTick(Client client) {
        WorldPoint point = client.getLocalPlayer().getWorldLocation();
        boolean x_in_range = point.getX() >= _topleft_point.getX() && point.getX() <= _bottomright_point.getX();
        boolean y_in_range = point.getY() <= _topleft_point.getY() && point.getY() >= _bottomright_point.getY();
        boolean plane_in_range = point.getPlane() == _topleft_point.getPlane() && point.getPlane() == _bottomright_point.getPlane();
        _in_area = x_in_range && y_in_range && plane_in_range;
    }
    @Override
    public String GetName() { return _name; }
    @Override
    public long GetID() { return _ID; }
    @Override
    public boolean IsCompleted() { return _isCompleted; }
    @Override
    public void SetCompleted() { _isCompleted = true; }

    @Override
    public int GetSpriteID() { return _spriteID; }

    @Override
    public boolean ShouldDisplayPanel() { return true; }

    @Override
    public boolean CanManuallyActivate() { return true; }

    @Override
    public void CheckChatMessage(ChatMessage event) { }

    @Override
    public void CheckMobKill(NPC npc) { }

    @Override
    public void CheckPlayerStatus(Client client) { }

}

package gg.archipelago.Tasks;

import net.runelite.api.Client;
import net.runelite.api.NPC;
import net.runelite.api.events.ChatMessage;
import net.runelite.api.events.MenuOptionClicked;

public class ItemOperationTask extends APTask {
    private final long _ID;
    private final int _itemID;
    private final String _option;
    private boolean _isCompleted = false;
    private final String _name;
    private final int _spriteID;

    public ItemOperationTask(long ID, String name, int spriteID, String option, int itemID){
        _ID = ID;
        _name = name;
        _spriteID = spriteID;
        _itemID = itemID;
        _option = option;
    }

    @Override
    public void OnMenuOption(MenuOptionClicked event) {
        if (event.getMenuOption().equalsIgnoreCase(_option) && event.getItemId() == _itemID && event.isItemOp()){
            _isCompleted = true;
        }
    }

    @Override
    public void CheckMobKill(NPC npc) { }
    @Override
    public void CheckPlayerStatus(Client client) { }
    @Override
    public void OnGameTick(Client client) { }
    @Override
    public void CheckChatMessage(ChatMessage event) { }

    @Override
    public boolean IsCompleted() {
        return _isCompleted;
    }
    @Override
    public void SetCompleted() { _isCompleted = true; }

    @Override
    public int GetSpriteID() {
        return _spriteID;
    }

    @Override
    public boolean ShouldDisplayPanel() {
        return true;
    }

    @Override
    public String GetName() {
        return _name;
    }

    @Override
    public long GetID() {
        return _ID;
    }


    @Override
    public boolean CanManuallyActivate() {
        return true;
    }
}

package gg.archipelago.Tasks;

import net.runelite.api.Client;
import net.runelite.api.NPC;
import net.runelite.api.SpriteID;
import net.runelite.api.events.ChatMessage;
import net.runelite.api.events.MenuOptionClicked;

public class KillTask extends APTask{
    private final long _ID;
    private final String _mobName;
    private boolean _isCompleted = false;


    public KillTask(long ID, String mobName){
        _ID = ID;
        _mobName = mobName;

    }

    @Override
    public void CheckMobKill(NPC npc) {
        if (_mobName.equalsIgnoreCase(npc.getName())){
            _isCompleted = true;
        }
    }

    @Override
    public void CheckPlayerStatus(Client client) { }
    @Override
    public void OnGameTick(Client client) { }
    @Override
    public void OnMenuOption(MenuOptionClicked event) { }
    @Override
    public void CheckChatMessage(ChatMessage event) { }
    @Override
    public boolean IsCompleted() {
        return _isCompleted;
    }

    @Override
    public int GetSpriteID() {
        return SpriteID.TAB_COMBAT;
    }

    @Override
    public boolean ShouldDisplayPanel() {
        return true;
    }

    @Override
    public String GetName() {
        return String.format("Kill %s",_mobName);
    }
    @Override
    public void SetCompleted() { _isCompleted = true; }

    @Override
    public long GetID() {
        return _ID;
    }


    @Override
    public boolean CanManuallyActivate() {
        return true;
    }
}

package gg.archipelago.Tasks;

import net.runelite.api.Client;
import net.runelite.api.NPC;
import net.runelite.api.Skill;
import net.runelite.api.SpriteID;
import net.runelite.api.events.ChatMessage;
import net.runelite.api.events.MenuOptionClicked;

public class LevelMilestoneTask extends APTask{
    private final long _ID;
    private final int _milestoneLevelRequired;
    private boolean _isCompleted = false;


    public LevelMilestoneTask(long ID, int milestoneLevelRequired){
        _ID = ID;
        _milestoneLevelRequired = milestoneLevelRequired;

    }
    @Override
    public void CheckPlayerStatus(Client client) {
        for (Skill skill : Skill.values()){
            if (skill == Skill.HITPOINTS && _milestoneLevelRequired <= 10) continue; //HP doesn't count for your first level 10

            // We only need one skill to be valid, if we get it, then we can exit early.
            if (client.getRealSkillLevel(skill) >= _milestoneLevelRequired) {
                _isCompleted = true;
                return;
            }
        }
    }
    @Override
    public void OnGameTick(Client client) { }
    @Override
    public void OnMenuOption(MenuOptionClicked event) { }
    @Override
    public void CheckChatMessage(ChatMessage event) { }
    @Override
    public void CheckMobKill(NPC npc) { }
    @Override
    public boolean IsCompleted() {
        return _isCompleted;
    }

    @Override
    public int GetSpriteID() {
        return SpriteID.SKILL_TOTAL;
    }

    @Override
    public boolean ShouldDisplayPanel() {
        return true;
    }
    @Override
    public void SetCompleted() { _isCompleted = true; }

    @Override
    public String GetName() {
        return String.format("Achieve your first Level %d",_milestoneLevelRequired);
    }

    @Override
    public long GetID() {
        return _ID;
    }

    @Override
    public boolean CanManuallyActivate() {
        return false;
    }
}

package gg.archipelago.Tasks;

import net.runelite.api.Client;
import net.runelite.api.NPC;
import net.runelite.api.Skill;
import net.runelite.api.SpriteID;
import net.runelite.api.events.ChatMessage;
import net.runelite.api.events.MenuOptionClicked;

public class ManualTask extends APTask {
    private final long _ID;
    private boolean _isCompleted;
    private final String _name;

    public ManualTask(long ID, String name){
        _ID = ID;
        _name = name;
    }
    @Override
    public void CheckPlayerStatus(Client client) { }

    @Override
    public void OnGameTick(Client client) { }
    @Override
    public void OnMenuOption(MenuOptionClicked event) { }

    @Override
    public boolean CanManuallyActivate() { return true; }

    @Override
    public void CheckChatMessage(ChatMessage event) { }
    @Override
    public void CheckMobKill(NPC npc) { }
    @Override
    public boolean IsCompleted() {
        return _isCompleted;
    }
    @Override
    public void SetCompleted() { _isCompleted = true; }

    @Override
    public int GetSpriteID() { return SpriteID.MINIMAP_ORB_WORLD_MAP_PLANET; }

    @Override
    public boolean ShouldDisplayPanel() {
        return true;
    }

    @Override
    public String GetName() {
        return _name;
    }

    @Override
    public long GetID() {
        return _ID;
    }
}

package gg.archipelago.Tasks;

import gg.archipelago.ArchipelagoPlugin;
import net.runelite.api.Client;
import net.runelite.api.NPC;
import net.runelite.api.events.ChatMessage;
import net.runelite.api.events.MenuOptionClicked;
import net.runelite.client.util.Text;

public class MenuActionTask extends APTask{
    private final long _ID;
    private boolean _isCompleted = false;
    private String _name;
    private int _spriteID;
    private final String _menuAction;
    private final String _menuTarget;


    public MenuActionTask(long ID, String name, int spriteID, String menuAction, String menuTarget){
        _ID = ID;
        _name = name;
        _spriteID = spriteID;
        _menuAction = menuAction;
        _menuTarget = menuTarget;
    }

    @Override
    public void CheckChatMessage(ChatMessage event) { }
    @Override
    public void CheckMobKill(NPC npc) { }
    @Override
    public void CheckPlayerStatus(Client client) { }
    @Override
    public void OnGameTick(Client client) { }
    @Override
    public void OnMenuOption(MenuOptionClicked event) {
        if (event.getMenuOption().equalsIgnoreCase(_menuAction) &&
                Text.removeTags(event.getMenuTarget()).equalsIgnoreCase(_menuTarget)){
            SetCompleted();
        }
    }

    @Override
    public boolean IsCompleted() {
        return _isCompleted;
    }
    @Override
    public void SetCompleted() { _isCompleted = true; }

    @Override
    public int GetSpriteID() {
        return _spriteID;
    }

    @Override
    public boolean ShouldDisplayPanel() {
        return true;
    }

    @Override
    public String GetName() {
        return _name;
    }

    @Override
    public long GetID() {
        return _ID;
    }


    @Override
    public boolean CanManuallyActivate() {
        return true;
    }
}

package gg.archipelago.Tasks;

import gg.archipelago.Tasks.StateTrackingTask;
import net.runelite.api.*;
import net.runelite.api.events.ChatMessage;
import net.runelite.api.events.MenuOptionClicked;

import java.util.Arrays;
import java.util.Optional;

public class OpenLockboxTask extends StateTrackingTask {

    private final long _ID;
    private final int _lockboxItemID;

    private int _previousLockboxCount = 0;

    public OpenLockboxTask(Long ID, int lockboxItemID){
        _ID = ID;
        _lockboxItemID = lockboxItemID;
    }

    @Override
    public void CheckChatMessage(ChatMessage event) { }
    @Override
    public void CheckMobKill(NPC npc) { }
    @Override
    public void CheckPlayerStatus(Client client) { }
    @Override
    public void OnMenuOption(MenuOptionClicked event) {
        //Check for Runecraft option
        if (event.getMenuOption().equalsIgnoreCase("Open")){
            checkTriggered = true;
        }
    }

    @Override
    public String GetName() {
        switch(_lockboxItemID){
            case ItemID.SIMPLE_LOCKBOX:
                return "Open a Simple Lockbox";
            case ItemID.ELABORATE_LOCKBOX:
                return "Open an Elaborate Lockbox";
            case ItemID.ORNATE_LOCKBOX:
                return "Open an Ornate Lockbox";
            default:
                return "Open an Unknown Lockbox";
        }
    }

    @Override
    public long GetID() {
        return _ID;
    }

    @Override
    public int GetSpriteID() {
        return SpriteID.SKILL_THIEVING;
    }

    @Override
    public boolean ShouldDisplayPanel() {
        return true;
    }

    @Override
    boolean CheckResetCondition(Client client) {
        return true;
    }

    @Override
    boolean CheckInitialStateOK(Client client) {
        _previousLockboxCount = 0;
        ItemContainer inventory = client.getItemContainer(InventoryID.INVENTORY);
        if (inventory != null) {
            Item[] currentItems = inventory.getItems();
            final int[] item_count = {0}; //anti lambda capture shenanigans
            Arrays.stream(currentItems).filter(item -> item.getId() == _lockboxItemID)
                    .forEach(item -> item_count[0] += item.getQuantity());
            _previousLockboxCount = item_count[0];
        }

        //Check for level, presence of essence, optional presence of core
        return _previousLockboxCount > 0;
    }

    @Override
    boolean CheckPostTriggerStateOK(Client client) {
        int currentLockboxCount = _previousLockboxCount;
        ItemContainer inventory = client.getItemContainer(InventoryID.INVENTORY);
        if (inventory != null) {
            Item[] currentItems = inventory.getItems();
            final int[] item_count = {0}; //anti lambda capture shenanigans
            Arrays.stream(currentItems).filter(item -> item.getId() == _lockboxItemID)
                    .forEach(item -> item_count[0] += item.getQuantity());
            currentLockboxCount =item_count[0];
        }

        //Check for level, presence of essence, optional presence of core
        return _previousLockboxCount > currentLockboxCount;
    }
}

package gg.archipelago.Tasks;

import net.runelite.api.*;
import net.runelite.api.events.ChatMessage;
import net.runelite.api.events.MenuOptionClicked;

public class QuestTask extends APTask{
    private final long _ID;
    private final Quest _questToCheck;
    private boolean _isCompleted = false;


    public QuestTask(long ID, Quest questToCheck){
        _ID = ID;
        _questToCheck = questToCheck;

    }
    @Override
    public void CheckPlayerStatus(Client client) {
        if (_questToCheck.getState(client) == QuestState.FINISHED)
            _isCompleted = true;
    }

    @Override
    public void OnGameTick(Client client) { }
    @Override
    public void OnMenuOption(MenuOptionClicked event) { }
    @Override
    public void CheckChatMessage(ChatMessage event) { }
    @Override
    public void CheckMobKill(NPC npc) { }
    @Override
    public boolean IsCompleted() {
        return _isCompleted;
    }

    @Override
    public int GetSpriteID() {
        return SpriteID.TAB_QUESTS;
    }

    @Override
    public boolean ShouldDisplayPanel() {
        return true;
    }
    @Override
    public void SetCompleted() { _isCompleted = true; }

    @Override
    public String GetName() {
        return _questToCheck.getName();
    }

    @Override
    public long GetID() {
        return _ID;
    }

    @Override
    public boolean CanManuallyActivate() {
        return false;
    }
}

package gg.archipelago.Tasks;

import net.runelite.api.Client;
import net.runelite.api.NPC;
import net.runelite.api.World;
import net.runelite.api.coords.WorldPoint;
import net.runelite.api.events.ChatMessage;
import net.runelite.api.events.MenuOptionClicked;

public class StandInAreaTask extends APTask {
    private final long _ID;
    private final String _name;
    private boolean _isCompleted;
    private final int _spriteID;
    private final WorldPoint _topleft_point;
    private final WorldPoint _bottomright_point;

    public StandInAreaTask(long ID, String name, int spriteID, int tl_x, int tl_y, int tl_plane, int br_x, int br_y, int br_plane){
        _ID = ID;
        _name = name;
        _spriteID = spriteID;
        _topleft_point = new WorldPoint(tl_x, tl_y, tl_plane);
        _bottomright_point = new WorldPoint(br_x, br_y, br_plane);
    }

    @Override
    public void OnGameTick(Client client) {
        WorldPoint point = client.getLocalPlayer().getWorldLocation();
        boolean x_in_range = point.getX() >= _topleft_point.getX() && point.getX() <= _bottomright_point.getX();
        boolean y_in_range = point.getY() <= _topleft_point.getY() && point.getY() >= _bottomright_point.getY();
        boolean plane_in_range = point.getPlane() == _topleft_point.getPlane() && point.getPlane() == _bottomright_point.getPlane();
        if (x_in_range && y_in_range && plane_in_range)
            SetCompleted();
    }

    @Override
    public String GetName() { return _name; }
    @Override
    public long GetID() { return _ID; }
    @Override
    public boolean IsCompleted() { return _isCompleted; }
    @Override
    public void SetCompleted() { _isCompleted = true; }

    @Override
    public int GetSpriteID() { return _spriteID; }

    @Override
    public boolean ShouldDisplayPanel() { return true; }

    @Override
    public boolean CanManuallyActivate() { return true; }

    @Override
    public void CheckChatMessage(ChatMessage event) { }

    @Override
    public void CheckMobKill(NPC npc) { }

    @Override
    public void CheckPlayerStatus(Client client) { }

    @Override
    public void OnMenuOption(MenuOptionClicked event) { }

}

package gg.archipelago.Tasks;

import gg.archipelago.Tasks.APTask;
import net.runelite.api.Client;
import net.runelite.api.NPC;
import net.runelite.api.World;
import net.runelite.api.coords.WorldPoint;
import net.runelite.api.events.ChatMessage;
import net.runelite.api.events.MenuOptionClicked;

public class StandInPositionTask extends APTask {
    private final long _ID;
    private final String _name;
    private boolean _isCompleted;
    private final int _spriteID;
    private final WorldPoint[] _locationPoints;

    public StandInPositionTask(long ID, String name, int spriteID, int x, int y, int plane){
        _ID = ID;
        _name = name;
        _spriteID = spriteID;
        _locationPoints = new WorldPoint[] { new WorldPoint(x, y, plane) };
    }


    @Override
    public void OnGameTick(Client client) {
        WorldPoint point = client.getLocalPlayer().getWorldLocation();
        for (WorldPoint p : _locationPoints) {
            if (point.equals(p)){
                SetCompleted();
                return;
            }
        }
    }

    @Override
    public String GetName() { return _name; }
    @Override
    public long GetID() { return _ID; }
    @Override
    public boolean IsCompleted() { return _isCompleted; }
    @Override
    public void SetCompleted() { _isCompleted = true; }

    @Override
    public int GetSpriteID() { return _spriteID; }

    @Override
    public boolean ShouldDisplayPanel() { return true; }

    @Override
    public boolean CanManuallyActivate() { return true; }

    @Override
    public void CheckChatMessage(ChatMessage event) { }

    @Override
    public void CheckMobKill(NPC npc) { }

    @Override
    public void CheckPlayerStatus(Client client) { }

    @Override
    public void OnMenuOption(MenuOptionClicked event) { }

}

package gg.archipelago.Tasks;

import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.NPC;
import net.runelite.client.plugins.PluginDescriptor;

@Slf4j
@PluginDescriptor(
        name = "Archipelago Randomizer"
)
public abstract class StateTrackingTask extends APTask {
    private boolean _isCompleted = false;

    //Updated on game tick. If the state is what we want to be before an action triggers
    private boolean prevStateOK = false;
    //One a triggering event (casting a spell, using an item, etc.) is fired, this is set to true, to check the next tick's state

    protected boolean checkTriggered = false;

    @Override
    public void OnGameTick(Client client){
        //If our previous state isn't set, don't bother checking the trigger or the post-state
        if (!prevStateOK){
            checkTriggered = false;
        }
        //If the triggering event happened and our state matches our post-triggered state requirements, we've completed the task
        if (checkTriggered){
            if (CheckPostTriggerStateOK(client)) {
                _isCompleted = true;
            }
            // If the triggering event happened and we did not match the post-triggered state, then back to square one.
            else if (CheckResetCondition(client)) {
                prevStateOK = false;
                checkTriggered = false;
            }
        }
        //If the triggering event has not happened yet, keep track of if our state is good for the first step
        else if (CheckInitialStateOK(client)){
            prevStateOK = true;
        }
    }
    abstract boolean CheckResetCondition(Client client);
    abstract boolean CheckInitialStateOK(Client client);
    abstract boolean CheckPostTriggerStateOK(Client client);

    @Override
    public boolean IsCompleted() { return _isCompleted; }
    @Override
    public void SetCompleted() { _isCompleted = true; }
    @Override
    public boolean CanManuallyActivate() {
        return true;
    }
}

package gg.archipelago.Tasks;

import lombok.extern.slf4j.Slf4j;
import net.runelite.api.*;
import net.runelite.api.coords.WorldPoint;
import net.runelite.api.events.ChatMessage;
import net.runelite.api.events.MenuOptionClicked;
import net.runelite.client.util.Text;

@Slf4j
public class TelegrabGoldBarTask extends StateTrackingTask{

    private final long _ID;

    private final String _name = "Telegrab a Gold Bar from the Varrock Bank";
    private final String _spell_name = "Telekinetic Grab";

    private int _previousMagicXP;
    private boolean shouldCancel = false;
    private final WorldPoint _topleft_point;
    private final WorldPoint _bottomright_point;
    private boolean _in_area;
    public TelegrabGoldBarTask(Long ID){
        _ID = ID;
        _topleft_point = new WorldPoint(3187, 9834, 0);
        _bottomright_point = new WorldPoint(3196, 9818, 0);
    }

    @Override
    public void CheckChatMessage(ChatMessage event) { }
    @Override
    public void CheckMobKill(NPC npc) { }
    @Override
    public void CheckPlayerStatus(Client client) { }
    @Override
    public void OnMenuOption(MenuOptionClicked event) {
        if (checkTriggered){
            MenuAction action = event.getMenuAction();
            // If we're pending a check and we do any menu options that aren't "Targetting a spell", un-set the trigger next tick
            if (action != MenuAction.WIDGET_TARGET_ON_GROUND_ITEM || !event.getMenuTarget().contains("Gold bar")) {
                checkTriggered = false;
                shouldCancel = true;
            }
        }
        // Spells always have a widget set
        if (event.getWidget() != null){
            String widgetName = Text.removeTags(event.getWidget().getName());
            if (widgetName.equalsIgnoreCase(_spell_name)){
                checkTriggered = true;
                shouldCancel = false;
            }
        }
    }
    @Override
    public void OnGameTick(Client client) {
        super.OnGameTick(client);

        WorldPoint point = client.getLocalPlayer().getWorldLocation();
        boolean x_in_range = point.getX() >= _topleft_point.getX() && point.getX() <= _bottomright_point.getX();
        boolean y_in_range = point.getY() <= _topleft_point.getY() && point.getY() >= _bottomright_point.getY();
        boolean plane_in_range = point.getPlane() == _topleft_point.getPlane() && point.getPlane() == _bottomright_point.getPlane();
        _in_area = x_in_range && y_in_range && plane_in_range;
    }

    @Override
    public String GetName() {
        return _name;
    }

    @Override
    public long GetID() {
        return _ID;
    }

    @Override
    public int GetSpriteID() {
        return SpriteID.SKILL_MAGIC;
    }

    @Override
    public boolean ShouldDisplayPanel() {
        return true;
    }

    @Override
    boolean CheckResetCondition(Client client) {
        return shouldCancel;
    }

    @Override
    boolean CheckInitialStateOK(Client client) {
        _previousMagicXP = client.getSkillExperience(Skill.MAGIC);
        return _in_area;
    }

    @Override
    boolean CheckPostTriggerStateOK(Client client) {
        //If you've gained magic XP and nothing has broken the condition yet, you've done it.
        return _in_area && client.getSkillExperience(Skill.MAGIC) > _previousMagicXP;
    }
}

package gg.archipelago.Tasks;

import net.runelite.api.Client;
import net.runelite.api.NPC;
import net.runelite.api.SpriteID;
import net.runelite.api.events.ChatMessage;
import net.runelite.api.events.MenuOptionClicked;

public class TotalLevelTask extends APTask{
    private final long _ID;
    private final int _totalLevelRequired;
    private boolean _isCompleted = false;


    public TotalLevelTask(long ID, int totalLevelRequired){
        _ID = ID;
        _totalLevelRequired = totalLevelRequired;

    }
    @Override
    public void CheckPlayerStatus(Client client) {

        if (client.getTotalLevel() >= _totalLevelRequired)
            _isCompleted = true;
    }
    @Override
    public void OnGameTick(Client client) { }
    @Override
    public void OnMenuOption(MenuOptionClicked event) { }
    @Override
    public void CheckChatMessage(ChatMessage event) { }
    @Override
    public void CheckMobKill(NPC npc) { }
    @Override
    public boolean IsCompleted() {
        return _isCompleted;
    }

    @Override
    public int GetSpriteID() {
        return SpriteID.SKILL_TOTAL;
    }

    @Override
    public boolean ShouldDisplayPanel() {
        return true;
    }
    @Override
    public void SetCompleted() { _isCompleted = true; }

    @Override
    public String GetName() {
        return String.format("Skill Total %d",_totalLevelRequired);
    }

    @Override
    public long GetID() {
        return _ID;
    }

    @Override
    public boolean CanManuallyActivate() {
        return false;
    }
}

package gg.archipelago.Tasks;

import net.runelite.api.Client;
import net.runelite.api.NPC;
import net.runelite.api.SpriteID;
import net.runelite.api.events.ChatMessage;
import net.runelite.api.events.MenuOptionClicked;

public class TotalXPTask extends APTask{
    private final long _ID;
    private final int _totalXPRequired;
    private boolean _isCompleted = false;


    public TotalXPTask(long ID, int totalXPRequired){
        _ID = ID;
        _totalXPRequired = totalXPRequired;

    }
    @Override
    public void CheckPlayerStatus(Client client) {
        if (client.getOverallExperience() >= _totalXPRequired)
            _isCompleted = true;
    }
    @Override
    public void OnGameTick(Client client) { }
    @Override
    public void OnMenuOption(MenuOptionClicked event) { }

    @Override
    public boolean CanManuallyActivate() {
        return false;
    }

    @Override
    public void CheckChatMessage(ChatMessage event) { }
    @Override
    public void CheckMobKill(NPC npc) { }
    @Override
    public boolean IsCompleted() {
        return _isCompleted;
    }
    @Override
    public void SetCompleted() { _isCompleted = true; }
    @Override
    public int GetSpriteID() {
        return SpriteID.SKILL_TOTAL;
    }

    @Override
    public boolean ShouldDisplayPanel() {
        return true;
    }

    @Override
    public String GetName() {
        return String.format("Total XP %,d", _totalXPRequired);
    }

    @Override
    public long GetID() {
        return _ID;
    }
}

package gg.archipelago.Tasks;

import net.runelite.api.Client;
import net.runelite.api.NPC;
import net.runelite.api.events.ChatMessage;
import net.runelite.api.events.MenuOptionClicked;

public class VarbitChangedTask extends APTask{
    private final long _ID;
    private final int _varbitToCheck;
    private boolean _isCompleted = false;
    private String _name;
    private int _spriteID;
    private boolean _isInitialized;
    private int _previousVarbitValue;

    public VarbitChangedTask(long ID, String name, int SpriteID, int varbitToCheck){
        _ID = ID;
        _name = name;
        _spriteID = SpriteID;
        _varbitToCheck = varbitToCheck;
    }

    @Override
    public void CheckPlayerStatus(Client client) {
        if (!_isInitialized){
            _previousVarbitValue = client.getServerVarbitValue(_varbitToCheck);
            _isInitialized = true;
        }


        if (client.getServerVarbitValue(_varbitToCheck) != _previousVarbitValue)
            _isCompleted = true;
    }

    @Override
    public void OnGameTick(Client client) { }
    @Override
    public void OnMenuOption(MenuOptionClicked event) { }
    @Override
    public void CheckChatMessage(ChatMessage event) { }
    @Override
    public void CheckMobKill(NPC npc) { }
    @Override
    public boolean IsCompleted() {
        return _isCompleted;
    }

    @Override
    public int GetSpriteID() {
        return _spriteID;
    }
    @Override
    public void SetCompleted() { _isCompleted = true; }

    @Override
    public boolean ShouldDisplayPanel() {
        return true;
    }

    @Override
    public String GetName() {
        return _name;
    }

    @Override
    public long GetID() {
        return _ID;
    }

    @Override
    public boolean CanManuallyActivate() {
        return true;
    }
}

package gg.archipelago.Tasks;

import net.runelite.api.Client;
import net.runelite.api.NPC;
import net.runelite.api.Varbits;
import net.runelite.api.events.ChatMessage;
import net.runelite.api.events.MenuOptionClicked;

public class VarbitTask extends APTask{
    private final long _ID;
    private final int _varbitToCheck;
    private final int _valueToCheck;
    private boolean _isCompleted = false;
    private String _name;
    private int _spriteID;

    public VarbitTask(long ID, String name, int SpriteID,  int varbitToCheck, int valueToCheck){
        _ID = ID;
        _name = name;
        _spriteID = SpriteID;
        _varbitToCheck = varbitToCheck;
        _valueToCheck = valueToCheck;
    }

    @Override
    public void CheckPlayerStatus(Client client) {
        if (client.getServerVarbitValue(_varbitToCheck) == _valueToCheck)
            _isCompleted = true;
    }

    @Override
    public void OnGameTick(Client client) { }
    @Override
    public void OnMenuOption(MenuOptionClicked event) { }
    @Override
    public void CheckChatMessage(ChatMessage event) { }
    @Override
    public void CheckMobKill(NPC npc) { }
    @Override
    public boolean IsCompleted() {
        return _isCompleted;
    }

    @Override
    public int GetSpriteID() {
        return _spriteID;
    }
    @Override
    public void SetCompleted() { _isCompleted = true; }

    @Override
    public boolean ShouldDisplayPanel() {
        return true;
    }

    @Override
    public String GetName() {
        return _name;
    }

    @Override
    public long GetID() {
        return _ID;
    }

    @Override
    public boolean CanManuallyActivate() {
        return true;
    }
}

package gg.archipelago.Tasks;

import gg.archipelago.ArchipelagoPlugin;
import net.runelite.api.ChatMessageType;
import net.runelite.api.Client;
import net.runelite.api.NPC;
import net.runelite.api.events.ChatMessage;
import net.runelite.api.events.MenuOptionClicked;

public class WidgetOpenTask extends APTask{
    private final long _ID;
    private boolean _isCompleted = false;
    private final String _name;
    private final int _spriteID;
    private final int _widgetID;

    public WidgetOpenTask(long ID, String name, int spriteID, int widgetID){
        _ID = ID;
        _name = name;
        _spriteID = spriteID;
        _widgetID = widgetID;
    }

    @Override
    public void CheckChatMessage(ChatMessage event) { }

    @Override
    public void CheckMobKill(NPC npc) { }
    @Override
    public void CheckPlayerStatus(Client client) { }
    @Override
    public void OnGameTick(Client client) {
        if (client.getWidget(_widgetID) != null && !client.getWidget(_widgetID).isHidden()){
            SetCompleted();
        }
    }
    @Override
    public void OnMenuOption(MenuOptionClicked event) { }

    @Override
    public boolean IsCompleted() {
        return _isCompleted;
    }
    @Override
    public void SetCompleted() { _isCompleted = true; }

    @Override
    public int GetSpriteID() {
        return _spriteID;
    }

    @Override
    public boolean ShouldDisplayPanel() {
        return true;
    }

    @Override
    public String GetName() {
        return _name;
    }

    @Override
    public long GetID() {
        return _ID;
    }


    @Override
    public boolean CanManuallyActivate() {
        return true;
    }
}

package gg.archipelago;

import net.runelite.client.RuneLite;
import net.runelite.client.externalplugins.ExternalPluginManager;

public class ArchipelagoPluginTest
{
	public static void main(String[] args) throws Exception
	{
		ExternalPluginManager.loadBuiltin(ArchipelagoPlugin.class);
		RuneLite.main(args);
	}
}
