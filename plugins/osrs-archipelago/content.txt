package gg.archipelago;

import net.runelite.client.RuneLite;
import net.runelite.client.externalplugins.ExternalPluginManager;

public class ArchipelagoPluginTest
{
	public static void main(String[] args) throws Exception
	{
		ExternalPluginManager.loadBuiltin(ArchipelagoPlugin.class);
		RuneLite.main(args);
	}
}
package gg.archipelago;

import lombok.AllArgsConstructor;
import lombok.Data;

@Data
@AllArgsConstructor
public class ArchipelagoLocation {
    private String LocationName;
    private boolean LocationChecked;
}

package gg.archipelago;

import gg.archipelago.Tasks.APTask;
import gg.archipelago.data.LocationData;
import lombok.extern.slf4j.Slf4j;
import net.runelite.client.ui.ColorScheme;

import javax.swing.*;
import javax.swing.border.EmptyBorder;
import java.awt.*;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.awt.image.BufferedImage;
import java.util.HashMap;

@Slf4j
public class TaskPanel extends JPanel {
    private final ArchipelagoPlugin plugin;

    private final JCheckBox displayCompleted;
    private final HashMap<APTask, TaskRow> locationPanels = new HashMap<APTask, TaskRow>();

    public TaskPanel(ArchipelagoPlugin plugin){
        this.plugin = plugin;

        setLayout(new BoxLayout(this, BoxLayout.Y_AXIS));
        setBorder(new EmptyBorder(5, 5, 5, 10));
        setVisible(false);

        displayCompleted = new JCheckBox("Display Completed Tasks");
        displayCompleted.setAlignmentX(Component.LEFT_ALIGNMENT);
        displayCompleted.addActionListener(e -> SwingUtilities.invokeLater(this::UpdateTaskStatus));

        add(displayCompleted);
        setAlignmentX(Component.LEFT_ALIGNMENT);
    }

    private class TaskRow extends JPanel{
        private JComponent taskName;

        private APTask task;
        public TaskRow(APTask task){
            this.task = task;

            BufferedImage image = TaskLists.loadedSprites.get(task);
            setLayout(new BorderLayout());
            setBackground(task.IsCompleted() ? ColorScheme.PROGRESS_COMPLETE_COLOR : ColorScheme.DARKER_GRAY_COLOR);
            setPreferredSize(new Dimension(0, 36));
            setAlignmentX(Component.LEFT_ALIGNMENT);

            if (image != null){
                JLabel icon = new JLabel(new ImageIcon(image));
                icon.setPreferredSize(new Dimension(32,0));
                add(icon, BorderLayout.WEST);
            }

            // For the time being, disable the "Can Manually Activate" check and let users click any of the task buttons.
            // The state-based tasks _should_ be working now, but no sense letting a glitch prevent someone's progress
            // if (!task.IsCompleted() && task.CanManuallyActivate()){
            if (!task.IsCompleted()){
                JButton taskButton = new JButton("<html><div style='text-align:center'>"+task.GetName()+"</div></html>");
                taskButton.setHorizontalAlignment(SwingConstants.CENTER);
                taskButton.addActionListener(e -> ManuallyComplete());

                taskName = taskButton;
            } else {
                taskName = new JLabel("<html><div style='text-align:center'>"+task.GetName()+"</div></html>", SwingConstants.CENTER);
            }

            taskName.setForeground(task.IsCompleted() ? Color.BLACK : Color.WHITE);
            add(taskName, BorderLayout.CENTER);
            setVisible(!task.IsCompleted() || displayCompleted.isSelected());
        }

        public void UpdateCompleted(boolean completed){
            if (completed && taskName instanceof JButton) {
                remove(taskName);
                taskName = new JLabel("<html><div style='text-align:center'>"+task.GetName()+"</div></html>", SwingConstants.CENTER);
                add(taskName, BorderLayout.CENTER);
            }
            setBackground(completed ? ColorScheme.PROGRESS_COMPLETE_COLOR : ColorScheme.DARKER_GRAY_COLOR);
            taskName.setForeground(completed ? Color.BLACK : Color.WHITE);
        }

        public void UpdateDisplay(){
            setVisible(!task.IsCompleted() || displayCompleted.isSelected());
        }

        public void ManuallyComplete(){
            JFrame frame = (JFrame) SwingUtilities.getWindowAncestor(this);
            int result = JOptionPane.showConfirmDialog(
                    frame,
                    "Mark this task as completed?", "Manually Complete",
                    JOptionPane.OK_CANCEL_OPTION,
                    JOptionPane.QUESTION_MESSAGE);
            if (result == JOptionPane.OK_OPTION){
                log.info("Completed task "+task.GetName());
                task.SetCompleted();
            }
        }
    }

    public void UpdateTaskStatus(){
        for (APTask task : plugin.activeTasks){
            TaskRow taskPanel = locationPanels.getOrDefault(task, null);
            if (taskPanel != null){
                taskPanel.UpdateCompleted(task.IsCompleted());
                taskPanel.UpdateDisplay();
            }
        }
    }

    private void AddOrUpdateTaskRow(APTask task){
        //boolean completed = plugin.LocationCheckStates.getOrDefault(loc,false);
        if (locationPanels.containsKey(task)){
            locationPanels.get(task).UpdateCompleted(task.IsCompleted());
            locationPanels.get(task).UpdateDisplay();
        } else {
            TaskRow taskPanel = new TaskRow(task);
            locationPanels.put(task, taskPanel);
            add(taskPanel);
        }
    }

    public void ConnectionStateChanged(boolean connectionSuccessful) {
        if (connectionSuccessful){
            setVisible(true);

            for (APTask task : plugin.activeTasks){
                if (task.ShouldDisplayPanel()){
                    SwingUtilities.invokeLater(() -> {
                        AddOrUpdateTaskRow(task);
                    });
                }
            }
            revalidate();
            repaint();
        } else {
            setVisible(false);
            //Empty the panel, but put the checkbox back for later
            removeAll();
            add(displayCompleted);
        }
    }
}

package gg.archipelago.data;

import lombok.AllArgsConstructor;
import lombok.Data;

import java.util.ArrayList;
import java.util.Dictionary;
import java.util.Hashtable;
import java.util.List;

@Data
@AllArgsConstructor
public class LocationData {
    public Long id;
    public String name;
    public int icon_id;
    public int icon_file;
    public boolean display_in_panel;
}
package gg.archipelago.data;

import lombok.AllArgsConstructor;
import lombok.Data;

@Data
@AllArgsConstructor
public class ItemData {
    public long id;
    public String name;
    public int icon_id;
    public int icon_file;
}

package gg.archipelago.data;

public class LocationNames {
    public static final String Q_Cooks_Assistant = "Quest: Cook's Assistant";
    public static final String Q_Demon_Slayer = "Quest: Demon Slayer";
    public static final String Q_Restless_Ghost = "Quest: The Restless Ghost";
    public static final String Q_Romeo_Juliet = "Quest: Romeo & Juliet";
    public static final String Q_Sheep_Shearer = "Quest: Sheep Shearer";
    public static final String Q_Shield_of_Arrav = "Quest: Shield of Arrav";
    public static final String Q_Ernest_the_Chicken = "Quest: Ernest the Chicken";
    public static final String Q_Vampyre_Slayer = "Quest: Vampyre Slayer";
    public static final String Q_Imp_Catcher = "Quest: Imp Catcher";
    public static final String Q_Prince_Ali_Rescue = "Quest: Prince Ali Rescue";
    public static final String Q_Dorics_Quest = "Quest: Doric's Quest";
    public static final String Q_Black_Knights_Fortress = "Quest: Black Knights' Fortress";
    public static final String Q_Witchs_Potion = "Quest: Witch's Potion";
    public static final String Q_Knights_Sword = "Quest: The Knight's Sword";
    public static final String Q_Goblin_Diplomacy = "Quest: Goblin Diplomacy";
    public static final String Q_Pirates_Treasure = "Quest: Pirate's Treasure";
    public static final String Q_Rune_Mysteries = "Quest: Rune Mysteries";
    public static final String Q_Misthalin_Mystery = "Quest: Misthalin Mystery";
    public static final String Q_Corsair_Curse = "Quest: The Corsair Curse";
    public static final String Q_X_Marks_the_Spot = "Quest: X Marks the Spot";
    public static final String Q_Below_Ice_Mountain = "Quest: Below Ice Mountain";
    public static final String QP_Cooks_Assistant = "Points: Cook's Assistant";
    public static final String QP_Demon_Slayer = "Points: Demon Slayer";
    public static final String QP_Restless_Ghost = "Points: The Restless Ghost";
    public static final String QP_Romeo_Juliet = "Points: Romeo & Juliet";
    public static final String QP_Sheep_Shearer = "Points: Sheep Shearer";
    public static final String QP_Shield_of_Arrav = "Points: Shield of Arrav";
    public static final String QP_Ernest_the_Chicken = "Points: Ernest the Chicken";
    public static final String QP_Vampyre_Slayer = "Points: Vampyre Slayer";
    public static final String QP_Imp_Catcher = "Points: Imp Catcher";
    public static final String QP_Prince_Ali_Rescue = "Points: Prince Ali Rescue";
    public static final String QP_Dorics_Quest = "Points: Doric's Quest";
    public static final String QP_Black_Knights_Fortress = "Points: Black Knights' Fortress";
    public static final String QP_Witchs_Potion = "Points: Witch's Potion";
    public static final String QP_Knights_Sword = "Points: The Knight's Sword";
    public static final String QP_Goblin_Diplomacy = "Points: Goblin Diplomacy";
    public static final String QP_Pirates_Treasure = "Points: Pirate's Treasure";
    public static final String QP_Rune_Mysteries = "Points: Rune Mysteries";
    public static final String QP_Misthalin_Mystery = "Points: Misthalin Mystery";
    public static final String QP_Corsair_Curse = "Points: The Corsair Curse";
    public static final String QP_X_Marks_the_Spot = "Points: X Marks the Spot";
    public static final String QP_Below_Ice_Mountain = "Points: Below Ice Mountain";
    public static final String Guppy = "Prepare a Guppy";
    public static final String Cavefish = "Prepare a Cavefish";
    public static final String Tetra = "Prepare a Tetra";
    public static final String Barronite_Deposit = "Crush a Barronite Deposit";
    public static final String Oak_Log = "Cut an Oak Log";
    public static final String Willow_Log = "Cut a Willow Log";
    public static final String Catch_Lobster = "Catch a Lobster";
    public static final String Mine_Silver = "Mine Silver";
    public static final String Mine_Coal = "Mine Coal";
    public static final String Mine_Gold = "Mine Gold";
    public static final String Smelt_Silver = "Smelt a Silver Bar";
    public static final String Smelt_Steel = "Smelt a Steel Bar";
    public static final String Smelt_Gold = "Smelt a Gold Bar";
    public static final String Cut_Sapphire = "Cut a Sapphire";
    public static final String Cut_Emerald = "Cut an Emerald";
    public static final String Cut_Ruby = "Cut a Ruby";
    public static final String Cut_Diamond = "Cut a Diamond";
    public static final String K_Lesser_Demon = "Kill a Lesser Demon";
    public static final String K_Ogress_Shaman = "Kill an Ogress Shaman";
    public static final String Bake_Apple_Pie = "Bake an Apple Pie";
    public static final String Bake_Cake = "Bake a Cake";
    public static final String Bake_Meat_Pizza = "Bake a Meat Pizza";
    public static final String Total_XP_5000 = "5,000 Total XP";
    public static final String Total_XP_10000 = "10,000 Total XP";
    public static final String Total_XP_25000 = "25,000 Total XP";
    public static final String Total_XP_50000 = "50,000 Total XP";
    public static final String Total_XP_100000 = "100,000 Total XP";
    public static final String Total_Level_50 = "50 Total Level";
    public static final String Total_Level_100 = "100 Total Level";
    public static final String Total_Level_150 = "150 Total Level";
    public static final String Total_Level_200 = "200 Total Level";
    public static final String Combat_Level_5 = "Combat Level 5";
    public static final String Combat_Level_15 = "Combat Level 15";
    public static final String Combat_Level_25 = "Combat Level 25";
    public static final String Q_Dragon_Slayer = "Quest: Dragon Slayer";
}

package gg.archipelago.data;

public class ItemNames {
    public static final String Lumbridge = "Area: Lumbridge";
    public static final String Lumbridge_Swamp = "Area: Lumbridge Swamp";
    public static final String Lumbridge_Farms = "Area: Lumbridge Farms";
    public static final String HAM_Hideout = "Area: HAM Hideout";
    public static final String Draynor_Village = "Area: Draynor Village";
    public static final String Draynor_Manor = "Area: Draynor Manor";
    public static final String Wizards_Tower = "Area: Wizard's Tower";
    public static final String Al_Kharid = "Area: Al Kharid";
    public static final String Citharede_Abbey = "Area: Cathraede Abbey";
    public static final String South_Of_Varrock = "Area: South of Varrock";
    public static final String Central_Varrock = "Area: Central Varrock";
    public static final String Varrock_Palace = "Area: Varrock Palace";
    public static final String East_Of_Varrock = "Area: East of Varrock";
    public static final String West_Varrock = "Area: West Varrock";
    public static final String Edgeville = "Area: Edgeville";
    public static final String Barbarian_Village = "Area: Barbarian Village";
    public static final String Monastery = "Area: Monastery";
    public static final String Ice_Mountain = "Area: Ice Mountain";
    public static final String Dwarven_Mines = "Area: Dwarven Mines";
    public static final String Falador = "Area: Falador";
    public static final String Falador_Farm = "Area: Falador Farm";
    public static final String Crafting_Guild = "Area: Crafting Guild";
    public static final String Rimmington = "Area: Rimmington";
    public static final String Port_Sarim = "Area: Port Sarim";
    public static final String Mudskipper_Point = "Area: Mudskipper Point";
    public static final String Karamja = "Area: Karamja";
    public static final String Crandor = "Area: Crandor";
    public static final String Corsair_Cove = "Area: Corsair Cove";
    public static final String Wilderness = "Area: The Wilderness";
    public static final String Progressive_Armor = "Progressive Armor";
    public static final String Progressive_Weapons = "Progressive Weapons";
    public static final String Progressive_Tools = "Progressive Tools";
    public static final String Progressive_Range_Armor = "Progressive Range Armor";
    public static final String Progressive_Range_Weapon = "Progressive Range Weapon";
    public static final String Progressive_Magic = "Progressive Magic Spell";
}

package gg.archipelago.Tasks;

import net.runelite.api.Client;
import net.runelite.api.NPC;
import net.runelite.api.SpriteID;
import net.runelite.api.events.MenuOptionClicked;

public class CombatLevelTask extends APTask{
    private final long _ID;
    private final int _combatLevelRequired;
    private boolean _isCompleted = false;


    public CombatLevelTask(long ID, int combatLevelRequired){
        _ID = ID;
        _combatLevelRequired = combatLevelRequired;

    }
    @Override
    public void CheckPlayerStatus(Client client) {
        if (client.getLocalPlayer().getCombatLevel() >= _combatLevelRequired)
            _isCompleted = true;
    }

    @Override
    public void OnGameTick(Client client) { }
    @Override
    public void OnMenuOption(MenuOptionClicked event) { }
    @Override
    public void CheckChatMessage(String message) { }
    @Override
    public void CheckMobKill(NPC npc) { }
    @Override
    public boolean IsCompleted() {
        return _isCompleted;
    }
    @Override
    public void SetCompleted() { _isCompleted = true; }
    @Override
    public int GetSpriteID() { return SpriteID.SKILL_TOTAL; }
    @Override
    public boolean ShouldDisplayPanel() { return true; }
    @Override
    public String GetName() { return String.format("Combat Level %d", _combatLevelRequired); }
    @Override
    public long GetID() {
        return _ID;
    }

    @Override
    public boolean CanManuallyActivate() {
        return false;
    }
}

package gg.archipelago.Tasks;

import net.runelite.api.Client;
import net.runelite.api.NPC;
import net.runelite.api.SpriteID;
import net.runelite.api.events.MenuOptionClicked;

public class TotalLevelTask extends APTask{
    private final long _ID;
    private final int _totalLevelRequired;
    private boolean _isCompleted = false;


    public TotalLevelTask(long ID, int totalLevelRequired){
        _ID = ID;
        _totalLevelRequired = totalLevelRequired;

    }
    @Override
    public void CheckPlayerStatus(Client client) {

        if (client.getTotalLevel() >= _totalLevelRequired)
            _isCompleted = true;
    }
    @Override
    public void OnGameTick(Client client) { }
    @Override
    public void OnMenuOption(MenuOptionClicked event) { }
    @Override
    public void CheckChatMessage(String message) { }
    @Override
    public void CheckMobKill(NPC npc) { }
    @Override
    public boolean IsCompleted() {
        return _isCompleted;
    }

    @Override
    public int GetSpriteID() {
        return SpriteID.SKILL_TOTAL;
    }

    @Override
    public boolean ShouldDisplayPanel() {
        return true;
    }
    @Override
    public void SetCompleted() { _isCompleted = true; }

    @Override
    public String GetName() {
        return String.format("Skill Total %d",_totalLevelRequired);
    }

    @Override
    public long GetID() {
        return _ID;
    }

    @Override
    public boolean CanManuallyActivate() {
        return false;
    }
}

package gg.archipelago.Tasks;

import net.runelite.api.Client;
import net.runelite.api.NPC;
import net.runelite.api.SpriteID;
import net.runelite.api.events.MenuOptionClicked;

public class TotalXPTask extends APTask{
    private final long _ID;
    private final int _totalXPRequired;
    private boolean _isCompleted = false;


    public TotalXPTask(long ID, int totalXPRequired){
        _ID = ID;
        _totalXPRequired = totalXPRequired;

    }
    @Override
    public void CheckPlayerStatus(Client client) {
        if (client.getOverallExperience() >= _totalXPRequired)
            _isCompleted = true;
    }
    @Override
    public void OnGameTick(Client client) { }
    @Override
    public void OnMenuOption(MenuOptionClicked event) { }

    @Override
    public boolean CanManuallyActivate() {
        return false;
    }

    @Override
    public void CheckChatMessage(String message) { }
    @Override
    public void CheckMobKill(NPC npc) { }
    @Override
    public boolean IsCompleted() {
        return _isCompleted;
    }
    @Override
    public void SetCompleted() { _isCompleted = true; }
    @Override
    public int GetSpriteID() {
        return SpriteID.SKILL_TOTAL;
    }

    @Override
    public boolean ShouldDisplayPanel() {
        return true;
    }

    @Override
    public String GetName() {
        return String.format("Total XP %,d", _totalXPRequired);
    }

    @Override
    public long GetID() {
        return _ID;
    }
}

package gg.archipelago.Tasks;

import net.runelite.api.Client;
import net.runelite.api.NPC;
import net.runelite.api.Skill;
import net.runelite.api.SpriteID;
import net.runelite.api.events.MenuOptionClicked;

public class EdgevilleMonasteryTask extends APTask{
    private final long _ID;
    private boolean _isCompleted;

    public EdgevilleMonasteryTask(long ID){
        _ID = ID;
    }
    @Override
    public void CheckPlayerStatus(Client client) {
        int prayerLevel = client.getRealSkillLevel(Skill.PRAYER);
        if (prayerLevel > 31 && client.getBoostedSkillLevel(Skill.PRAYER) == prayerLevel+2){
            _isCompleted = true;
        }
    }

    @Override
    public void OnGameTick(Client client) { }
    @Override
    public void OnMenuOption(MenuOptionClicked event) { }

    @Override
    public boolean CanManuallyActivate() { return true; }

    @Override
    public void CheckChatMessage(String message) { }
    @Override
    public void CheckMobKill(NPC npc) { }
    @Override
    public boolean IsCompleted() {
        return _isCompleted;
    }
    @Override
    public void SetCompleted() { _isCompleted = true; }

    @Override
    public int GetSpriteID() {
        return SpriteID.SKILL_PRAYER;
    }

    @Override
    public boolean ShouldDisplayPanel() {
        return true;
    }

    @Override
    public String GetName() {
        return "Pray at the Edgeville Monastery";
    }

    @Override
    public long GetID() {
        return _ID;
    }
}

package gg.archipelago.Tasks;

import lombok.extern.slf4j.Slf4j;
import net.runelite.api.*;
import net.runelite.api.events.MenuOptionClicked;

import java.util.Arrays;
import java.util.Optional;

@Slf4j
public class CraftRunesTask extends StateTrackingTask{

    private final long _ID;

    private int _required_level;
    private int _essence_id;
    private int _previousEssenceCount;
    private int _previousRunecraftXP;

    private RuneType _runeType;
    public CraftRunesTask(Long ID, RuneType runeType){
        _ID = ID;
        _runeType = runeType;

        switch (runeType){
            case AIR_RUNE:
                _required_level = 1;
                _essence_id = ItemID.RUNE_ESSENCE;
                break;
            case MIND_RUNE:
                _required_level = 2;
                _essence_id = ItemID.MIND_CORE;
                break;
            case BODY_RUNE:
                _required_level = 20;
                _essence_id = ItemID.BODY_CORE;
                break;
        }
    }

    @Override
    public void CheckChatMessage(String message) { }
    @Override
    public void CheckMobKill(NPC npc) { }
    @Override
    public void CheckPlayerStatus(Client client) { }
    @Override
    public void OnMenuOption(MenuOptionClicked event) {
        //Check for Runecraft option
        if (event.getMenuOption().equalsIgnoreCase("Craft-rune")){
            checkTriggered = true;
            //log.info("Runecraft task is primed.");
        }
    }

    @Override
    public String GetName() {
        switch (_runeType){
            case AIR_RUNE:
                return "Craft some Air Runes";
            case MIND_RUNE:
                return "Craft some Mind Runes using a Mind Core";
            case BODY_RUNE:
                return "Craft some Body Runes using a Body Core";
            default:
                return "Unknown Runecraft Task";
        }
    }

    @Override
    public long GetID() { return _ID; }
    @Override
    public int GetSpriteID() { return SpriteID.SKILL_RUNECRAFT; }
    @Override
    public boolean ShouldDisplayPanel() { return true; }
    @Override
    boolean CheckInitialStateOK(Client client) {
        if (!(client.getRealSkillLevel(Skill.RUNECRAFT) >= _required_level)){
            //log.info(GetName()+" - Runecraft level below requirements. Initial State not OK");
            return false;
        }
        _previousRunecraftXP = client.getSkillExperience(Skill.RUNECRAFT);
        ItemContainer inventory = client.getItemContainer(InventoryID.INVENTORY);
        if (inventory != null) {
            Item[] currentItems = inventory.getItems();
            final int finalItem_id = _essence_id;
            final int[] item_count = {0}; //anti lambda capture shenanigans
            Object[] items = Arrays.stream(currentItems).filter(item -> item.getId() == finalItem_id).toArray();

            Arrays.stream(currentItems).filter(item -> item.getId() == finalItem_id)
                    .forEach(item -> item_count[0] += item.getQuantity());
            _previousEssenceCount = item_count[0];
        }
        if (_previousEssenceCount <= 0){
            //log.info(GetName()+" - Not enough essence. Initial State not OK");
        }
        //Check for level, presence of essence, optional presence of core
        return _previousEssenceCount > 0;
    }

    @Override
    boolean CheckPostTriggerStateOK(Client client) {
        boolean hasGainedXP = client.getSkillExperience(Skill.RUNECRAFT) > _previousRunecraftXP;
        int currentEssenceCount = 0;
        ItemContainer inventory = client.getItemContainer(InventoryID.INVENTORY);
        if (inventory != null) {
            Item[] currentItems = inventory.getItems();
            final int finalItem_id = _essence_id;
            Optional<Item> essenceStack =
                    Arrays.stream(currentItems).filter(item -> item.getId() == finalItem_id).findFirst();
            currentEssenceCount = essenceStack.map(Item::getQuantity).orElse(0);
        }

        boolean hasSpentEssence = currentEssenceCount < _previousEssenceCount;

        //if (!hasGainedXP) log.info(GetName()+" - Did not gain RC XP. Second state not OK");
        //if (!hasSpentEssence) log.info(GetName()+" - Did not spend essence. Second state not OK");
        //if (hasGainedXP && hasSpentEssence) log.info(GetName()+" - Successfully completed task");
        //Check for any increase in RC XP and increase in item count for rune
        return hasGainedXP && hasSpentEssence;
    }

    public enum RuneType {
        AIR_RUNE,
        MIND_RUNE,
        BODY_RUNE
    }
}

package gg.archipelago.Tasks;

import net.runelite.api.NPC;
import net.runelite.api.Client;
import net.runelite.api.SpriteID;
import net.runelite.api.events.MenuOptionClicked;

public abstract class APTask {
    public abstract String GetName();
    public abstract long GetID();
    public abstract boolean IsCompleted();
    public abstract void SetCompleted();
    public abstract int GetSpriteID();
    public abstract boolean ShouldDisplayPanel();

    public abstract void CheckChatMessage(String message);
    public abstract void CheckMobKill(NPC npc);
    public abstract void CheckPlayerStatus(Client client);
    public abstract void OnGameTick(Client client);
    public abstract void OnMenuOption(MenuOptionClicked event);

    public abstract boolean CanManuallyActivate();
}


package gg.archipelago.Tasks;

import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.NPC;
import net.runelite.client.plugins.PluginDescriptor;

@Slf4j
@PluginDescriptor(
        name = "Archipelago Randomizer"
)
public abstract class StateTrackingTask extends APTask {
    private boolean _isCompleted = false;

    //Updated on game tick. If the state is what we want to be before an action triggers
    private boolean prevStateOK = false;
    //One a triggering event (casting a spell, using an item, etc.) is fired, this is set to true, to check the next tick's state

    protected boolean checkTriggered = false;

    @Override
    public void OnGameTick(Client client){
        //If our previous state isn't set, don't bother checking the trigger or the post-state
        if (!prevStateOK){
            checkTriggered = false;
        }
        //If the triggering event happened and our state matches our post-triggered state requirements, we've completed the task
        if (checkTriggered){
            if (CheckPostTriggerStateOK(client)){
                _isCompleted = true;
            }
            // If the triggering event happened and we did not match the post-triggered state, then back to square one.
            else {
                prevStateOK = false;
                checkTriggered = false;
            }
        }
        //If the triggering event has not happened yet, keep track of if our state is good for the first step
        else if (CheckInitialStateOK(client)){
            prevStateOK = true;
        }
    }

    abstract boolean CheckInitialStateOK(Client client);
    abstract boolean CheckPostTriggerStateOK(Client client);

    @Override
    public boolean IsCompleted() {
        return _isCompleted;
    }
    @Override
    public void SetCompleted() { _isCompleted = true; }

    @Override
    public boolean CanManuallyActivate() {
        return true;
    }
}

package gg.archipelago.Tasks;

import net.runelite.api.*;
import net.runelite.api.events.MenuOptionClicked;

import java.util.Arrays;
import java.util.Optional;

public class OpenLockboxTask extends StateTrackingTask{

    private final long _ID;
    private final int _lockboxItemID;

    private int _previousLockboxCount = 0;

    public OpenLockboxTask(Long ID, int lockboxItemID){
        _ID = ID;
        _lockboxItemID = lockboxItemID;
    }

    @Override
    public void CheckChatMessage(String message) { }
    @Override
    public void CheckMobKill(NPC npc) { }
    @Override
    public void CheckPlayerStatus(Client client) { }
    @Override
    public void OnMenuOption(MenuOptionClicked event) {
        //Check for Runecraft option
        if (event.getMenuOption().equalsIgnoreCase("Open")){
            checkTriggered = true;
        }
    }

    @Override
    public String GetName() {
        switch(_lockboxItemID){
            case ItemID.SIMPLE_LOCKBOX:
                return "Open a Simple Lockbox";
            case ItemID.ELABORATE_LOCKBOX:
                return "Open an Elaborate Lockbox";
            case ItemID.ORNATE_LOCKBOX:
                return "Open an Ornate Lockbox";
            default:
                return "Open an Unknown Lockbox";
        }
    }

    @Override
    public long GetID() {
        return _ID;
    }

    @Override
    public int GetSpriteID() {
        return SpriteID.SKILL_THIEVING;
    }

    @Override
    public boolean ShouldDisplayPanel() {
        return true;
    }

    @Override
    boolean CheckInitialStateOK(Client client) {
        _previousLockboxCount = 0;
        ItemContainer inventory = client.getItemContainer(InventoryID.INVENTORY);
        if (inventory != null) {
            Item[] currentItems = inventory.getItems();
            final int[] item_count = {0}; //anti lambda capture shenanigans
            Arrays.stream(currentItems).filter(item -> item.getId() == _lockboxItemID)
                    .forEach(item -> item_count[0] += item.getQuantity());
            _previousLockboxCount = item_count[0];
        }

        //Check for level, presence of essence, optional presence of core
        return _previousLockboxCount > 0;
    }

    @Override
    boolean CheckPostTriggerStateOK(Client client) {
        int currentLockboxCount = _previousLockboxCount;
        ItemContainer inventory = client.getItemContainer(InventoryID.INVENTORY);
        if (inventory != null) {
            Item[] currentItems = inventory.getItems();
            final int[] item_count = {0}; //anti lambda capture shenanigans
            Arrays.stream(currentItems).filter(item -> item.getId() == _lockboxItemID)
                    .forEach(item -> item_count[0] += item.getQuantity());
            currentLockboxCount =item_count[0];
        }

        //Check for level, presence of essence, optional presence of core
        return _previousLockboxCount > currentLockboxCount;
    }
}

package gg.archipelago.Tasks;

import net.runelite.api.Client;
import net.runelite.api.NPC;
import net.runelite.api.events.MenuOptionClicked;

public class VarbitTask extends APTask{
    private final long _ID;
    private final int _varbitToCheck;
    private final int _valueToCheck;
    private boolean _isCompleted = false;
    private String _name;
    private int _spriteID;

    public VarbitTask(long ID, String name, int SpriteID,  int varbitToCheck, int valueToCheck){
        _ID = ID;
        _name = name;
        _spriteID = SpriteID;
        _varbitToCheck = varbitToCheck;
        _valueToCheck = valueToCheck;
    }

    @Override
    public void CheckPlayerStatus(Client client) {
        if (client.getServerVarbitValue(_varbitToCheck) == _valueToCheck)
            _isCompleted = true;
    }

    @Override
    public void OnGameTick(Client client) { }
    @Override
    public void OnMenuOption(MenuOptionClicked event) { }
    @Override
    public void CheckChatMessage(String message) { }
    @Override
    public void CheckMobKill(NPC npc) { }
    @Override
    public boolean IsCompleted() {
        return _isCompleted;
    }

    @Override
    public int GetSpriteID() {
        return _spriteID;
    }
    @Override
    public void SetCompleted() { _isCompleted = true; }

    @Override
    public boolean ShouldDisplayPanel() {
        return true;
    }

    @Override
    public String GetName() {
        return _name;
    }

    @Override
    public long GetID() {
        return _ID;
    }

    @Override
    public boolean CanManuallyActivate() {
        return true;
    }
}

package gg.archipelago.Tasks;

import lombok.extern.java.Log;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.NPC;
import net.runelite.api.Skill;
import net.runelite.api.SpriteID;
import net.runelite.api.events.MenuOptionClicked;
import net.runelite.client.plugins.PluginDescriptor;

public class  BurnLogsTask extends StateTrackingTask{

    private final long _ID;
    private final LogType _logType;

    private int _required_level;
    private int _xp_gained;
    private int _previousFiremakingXP;

    private final String logs_burning_message = "The fire catches and the logs begin to burn.";
    public BurnLogsTask(Long ID, LogType logType){
        _ID = ID;
        _logType = logType;

        switch(logType){
            case OAK:
                _required_level = 15;
                _xp_gained = 60;
                break;
            case WILLOW:
                _required_level = 30;
                _xp_gained = 90;
        }
    }

    @Override
    public void CheckChatMessage(String message) {
        // Check for burning log message
        if (message.equalsIgnoreCase(logs_burning_message)){
            checkTriggered = true;
        }
    }
    @Override
    public void CheckMobKill(NPC npc) { }
    @Override
    public void CheckPlayerStatus(Client client) { }
    @Override
    public void OnMenuOption(MenuOptionClicked event) { }

    @Override
    public String GetName() {
        switch (_logType){
            case OAK:
                return "Burn an Oak Log";
            case WILLOW:
                return "Burn a Willow Log";
            default:
                return "Burn an unknown log";
        }
    }

    @Override
    public long GetID() {
        return _ID;
    }

    @Override
    public int GetSpriteID() {
        return SpriteID.SKILL_FIREMAKING;
    }

    @Override
    public boolean ShouldDisplayPanel() {
        return true;
    }

    @Override
    boolean CheckInitialStateOK(Client client) {
        // Check for Firemaking level requirement
        if (!(client.getRealSkillLevel(Skill.FIREMAKING) >= _required_level)) return false;
        _previousFiremakingXP = client.getSkillExperience(Skill.FIREMAKING);
        return true;
    }

    @Override
    boolean CheckPostTriggerStateOK(Client client) {
        // Check for XP increase for specific log
        return client.getSkillExperience(Skill.FIREMAKING) == _previousFiremakingXP + _xp_gained;
    }

    public enum LogType{
        OAK,
        WILLOW
    }
}

package gg.archipelago.Tasks;

import net.runelite.api.Client;
import net.runelite.api.NPC;
import net.runelite.api.events.MenuOptionClicked;

public class ChatMessageTask extends APTask{
    private final long _ID;
    private final String _messageToCheck;
    private boolean _isCompleted = false;
    private String _name;
    private int _spriteID;

    public ChatMessageTask(long ID, String name, int spriteID, String messageToCheck){
        _ID = ID;
        _name = name;
        _spriteID = spriteID;
        _messageToCheck = messageToCheck;

    }

    @Override
    public void CheckChatMessage(String message) {

        String[] splitMessages = message.split("<br>");
        for (String msg : splitMessages) {
            if (msg.equalsIgnoreCase(_messageToCheck)){
                _isCompleted = true;
            }
        }
    }

    @Override
    public void CheckMobKill(NPC npc) { }
    @Override
    public void CheckPlayerStatus(Client client) { }
    @Override
    public void OnGameTick(Client client) { }
    @Override
    public void OnMenuOption(MenuOptionClicked event) {

    }

    @Override
    public boolean IsCompleted() {
        return _isCompleted;
    }
    @Override
    public void SetCompleted() { _isCompleted = true; }

    @Override
    public int GetSpriteID() {
        return _spriteID;
    }

    @Override
    public boolean ShouldDisplayPanel() {
        return true;
    }

    @Override
    public String GetName() {
        return _name;
    }

    @Override
    public long GetID() {
        return _ID;
    }


    @Override
    public boolean CanManuallyActivate() {
        return true;
    }
}

package gg.archipelago.Tasks;

import net.runelite.api.Client;
import net.runelite.api.NPC;
import net.runelite.api.SpriteID;
import net.runelite.api.events.MenuOptionClicked;

public class KillTask extends APTask{
    private final long _ID;
    private final String _mobName;
    private boolean _isCompleted = false;


    public KillTask(long ID, String mobName){
        _ID = ID;
        _mobName = mobName;

    }

    @Override
    public void CheckMobKill(NPC npc) {
        if (_mobName.equalsIgnoreCase(npc.getName())){
            _isCompleted = true;
        }
    }

    @Override
    public void CheckPlayerStatus(Client client) { }
    @Override
    public void OnGameTick(Client client) { }
    @Override
    public void OnMenuOption(MenuOptionClicked event) { }
    @Override
    public void CheckChatMessage(String message) { }
    @Override
    public boolean IsCompleted() {
        return _isCompleted;
    }

    @Override
    public int GetSpriteID() {
        return SpriteID.TAB_COMBAT;
    }

    @Override
    public boolean ShouldDisplayPanel() {
        return true;
    }

    @Override
    public String GetName() {
        return String.format("Kill %s",_mobName);
    }
    @Override
    public void SetCompleted() { _isCompleted = true; }

    @Override
    public long GetID() {
        return _ID;
    }


    @Override
    public boolean CanManuallyActivate() {
        return true;
    }
}

package gg.archipelago.Tasks;

import net.runelite.api.Client;
import net.runelite.api.NPC;
import net.runelite.api.Skill;
import net.runelite.api.SpriteID;
import net.runelite.api.events.MenuOptionClicked;

public class CastSpellTask extends StateTrackingTask{

    private final long _ID;

    private int _required_level;
    private int _xp_gained;
    private int _previousMagicXP;
    private SpellToCast _spell;

    public CastSpellTask(Long ID, SpellToCast spell){
        _ID = ID;
        _spell = spell;

        switch(spell){
            case BONES_TO_BANANAS:
                _required_level = 15;
                _xp_gained = 25;
                break;
            case VARROCK_TELE:
                _required_level = 25;
                _xp_gained = 35;
                break;
            case LUMBRIDGE_TELE:
                _required_level = 31;
                _xp_gained = 41;
                break;
            case FALADOR_TELE:
                _required_level = 37;
                _xp_gained = 48;
                break;
        }
    }

    @Override
    public void CheckChatMessage(String message) { }
    @Override
    public void CheckMobKill(NPC npc) { }
    @Override
    public void CheckPlayerStatus(Client client) { }
    @Override
    public void OnMenuOption(MenuOptionClicked event) {
        // Check for cast action
        if (event.getMenuOption().equalsIgnoreCase("Cast")){
            checkTriggered = true;
        }
    }

    @Override
    public String GetName() {
        switch(_spell){
            case BONES_TO_BANANAS:
                return "Cast Bones to Bananas";
            case VARROCK_TELE:
                return "Teleport to Varrock";
            case LUMBRIDGE_TELE:
                    return "Teleport to Lumbridge";
            case FALADOR_TELE:
                return "Teleport to Falador";
            default:
                return "Cast an unknown spell";
        }
    }

    @Override
    public long GetID() {
        return _ID;
    }

    @Override
    public int GetSpriteID() {
        return SpriteID.SKILL_MAGIC;
    }

    @Override
    public boolean ShouldDisplayPanel() {
        return true;
    }

    @Override
    boolean CheckInitialStateOK(Client client) {
        // Check to make sure you have the level for the spell
        if (!(client.getRealSkillLevel(Skill.MAGIC) >= _required_level)) return false;
        _previousMagicXP = client.getSkillExperience(Skill.MAGIC);
        return true;
    }

    @Override
    boolean CheckPostTriggerStateOK(Client client) {
        // Check if you've gained enough XP for the spell after casting
        return client.getSkillExperience(Skill.MAGIC) == _previousMagicXP + _xp_gained;
    }

    public enum SpellToCast{
        BONES_TO_BANANAS,
        VARROCK_TELE,
        LUMBRIDGE_TELE,
        FALADOR_TELE
    }
}

package gg.archipelago.Tasks;

import net.runelite.api.*;
import net.runelite.api.events.MenuOptionClicked;

public class QuestTask extends APTask{
    private final long _ID;
    private final Quest _questToCheck;
    private boolean _isCompleted = false;


    public QuestTask(long ID, Quest questToCheck){
        _ID = ID;
        _questToCheck = questToCheck;

    }
    @Override
    public void CheckPlayerStatus(Client client) {
        if (_questToCheck.getState(client) == QuestState.FINISHED)
            _isCompleted = true;
    }

    @Override
    public void OnGameTick(Client client) { }
    @Override
    public void OnMenuOption(MenuOptionClicked event) { }
    @Override
    public void CheckChatMessage(String message) { }
    @Override
    public void CheckMobKill(NPC npc) { }
    @Override
    public boolean IsCompleted() {
        return _isCompleted;
    }

    @Override
    public int GetSpriteID() {
        return SpriteID.TAB_QUESTS;
    }

    @Override
    public boolean ShouldDisplayPanel() {
        return true;
    }
    @Override
    public void SetCompleted() { _isCompleted = true; }

    @Override
    public String GetName() {
        return _questToCheck.getName();
    }

    @Override
    public long GetID() {
        return _ID;
    }

    @Override
    public boolean CanManuallyActivate() {
        return false;
    }
}

package gg.archipelago;

import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.PluginPanel;
import javax.swing.*;
import javax.swing.border.EmptyBorder;
import java.awt.*;

public class ArchipelagoPanel extends PluginPanel {

    private final ArchipelagoPlugin plugin;
    private final ArchipelagoConfig config;

    private final TaskPanel taskListPanel;
    private final ItemPanel itemListPanel;

    private final JLabel messageLabel;

    ArchipelagoPanel(final ArchipelagoPlugin plugin, final ArchipelagoConfig config)
    {
        this.plugin = plugin;
        this.config = config;

        setBorder(new EmptyBorder(6, 6, 6, 6));
        setBackground(ColorScheme.DARK_GRAY_COLOR);
        setLayout(new BorderLayout());

        // Create layout panel for wrapping
        final JPanel layoutPanel = new JPanel();
        layoutPanel.setLayout(new BoxLayout(layoutPanel, BoxLayout.Y_AXIS));
        add(layoutPanel, BorderLayout.NORTH);

        final JPanel statusPanel = buildStatusPanel();
        layoutPanel.add(statusPanel);
        //layoutPanel.add(Box.createRigidArea(new Dimension(0, 5)));

        messageLabel = new JLabel("");
        messageLabel.setAlignmentX(Component.LEFT_ALIGNMENT);
        messageLabel.setBorder(new EmptyBorder(5, 5, 5, 10));
        layoutPanel.add(messageLabel);

        taskListPanel = new TaskPanel(plugin);
        layoutPanel.add(taskListPanel);
        //layoutPanel.add(Box.createRigidArea(new Dimension(0, 5)));

        itemListPanel = new ItemPanel(plugin);
        layoutPanel.add(itemListPanel);
    }

    private JButton connectButton;

    private JPanel buildStatusPanel(){
        final JPanel statusPanel = new JPanel();
        statusPanel.setLayout(new GridLayout(2, 1));
        statusPanel.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        statusPanel.setPreferredSize(new Dimension(Integer.MAX_VALUE, 80));
        statusPanel.setBorder(new EmptyBorder(5, 5, 5, 10));
        statusPanel.setVisible(true);

        JLabel instructionText = new JLabel("<html>Server address, port, and slot can be found in plugin settings.</html>");
        instructionText.setPreferredSize(new Dimension(Integer.MAX_VALUE, 30));
        instructionText.setBorder(new EmptyBorder(5, 5, 5, 10));

        connectButton = new JButton("Connect");
        connectButton.setPreferredSize(new Dimension(Integer.MAX_VALUE, 30));
        connectButton.setBorder(new EmptyBorder(5, 5, 5, 10));

        statusPanel.add(instructionText);
        statusPanel.add(connectButton);
        connectButton.addActionListener(e -> {
            plugin.ConnectToAPServer();
        });

        statusPanel.setAlignmentX(Component.LEFT_ALIGNMENT);
        return statusPanel;
    }

    public void ConnectionStateChanged(boolean connectionSuccessful) {
        taskListPanel.ConnectionStateChanged(connectionSuccessful);
        connectButton.setEnabled(!connectionSuccessful);
        connectButton.setText(connectionSuccessful ? "Connected!" : "Connect");
    }

    public void UpdateTaskStatus(){
        taskListPanel.UpdateTaskStatus();
    }

    public void UpdateItems(){
        itemListPanel.UpdateItems();
    }

    public void DisplayNetworkMessage(String message){
        String formattedMessage = String.format("<html><body style=\"text-align: justify;  text-justify: inter-word;\">%s</body></html>",message);
        messageLabel.setText(formattedMessage);
    }
}

package gg.archipelago.apEvents;

import gg.archipelago.ArchipelagoPlugin;
import gg.archipelago.ItemHandler;
import gg.archipelago.client.events.ArchipelagoEventListener;
import gg.archipelago.client.events.ReceiveItemEvent;

public class ReceiveItem {

    @ArchipelagoEventListener
    public void onReceiveItem(ReceiveItemEvent event) {
        if (event.getIndex() >= ArchipelagoPlugin.plugin.lastItemReceivedIndex){
            ArchipelagoPlugin.plugin.addCollectedItem(ItemHandler.ItemsById.get(event.getItemID()));
            ArchipelagoPlugin.plugin.lastItemReceivedIndex = event.getIndex();
            //Don't send messages for items received on startup:
            if (event.getIndex() > 0){
                String messageBody = "Received from " +
                        event.getPlayerName() +
                        " at " +
                        event.getLocationName();
                ArchipelagoPlugin.plugin.QueuePopupMessage(event.getItemName(), messageBody);
            }
        }
    }
}
package gg.archipelago.apEvents;

import gg.archipelago.ArchipelagoPlugin;
import gg.archipelago.client.events.ArchipelagoEventListener;
import gg.archipelago.client.events.ConnectionResultEvent;

public class ConnectionResult {

    @ArchipelagoEventListener
    public void onConnectionResult(ConnectionResultEvent event) {
        if (event.getResult() == null) return;

        String msg;
        switch (event.getResult()) {
            case SlotAlreadyTaken:
                msg = "Slot already in use.";
                break;
            case Success:
                msg = "Connection Successful.";
                break;
            case InvalidSlot:
                msg = "Invalid Slot Name. Please make sure you typed it correctly.";
                break;
            case InvalidPassword:
                msg = "Invalid Password";
                break;
            case IncompatibleVersion:
                msg = "Server Rejected our connection due to an incompatible communication protocol.";
                break;
            default:
                msg = "Unknown Error";
        }

        ArchipelagoPlugin.plugin.DisplayNetworkMessage(msg);
        ArchipelagoPlugin.plugin.SetConnectionState(event.getResult() == gg.archipelago.client.network.ConnectionResult.Success);
    }
}

package gg.archipelago;

import gg.archipelago.Tasks.APTask;
import gg.archipelago.data.ItemData;
import gg.archipelago.data.ItemNames;
import com.google.inject.Provides;
import javax.inject.Inject;
import javax.swing.*;

import gg.archipelago.client.ClientStatus;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.*;
import net.runelite.api.events.*;
import net.runelite.api.widgets.ComponentID;
import net.runelite.api.widgets.Widget;
import net.runelite.api.widgets.WidgetModalMode;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.events.ChatboxInput;
import net.runelite.client.events.NpcLootReceived;
import net.runelite.client.game.SpriteManager;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.plugins.PluginDescriptor;
import net.runelite.client.plugins.mta.graveyard.GraveyardCounter;
import net.runelite.client.ui.ClientToolbar;
import net.runelite.client.ui.NavigationButton;
import net.runelite.client.util.ImageUtil;
import net.runelite.client.util.Text;

import java.awt.image.BufferedImage;
import java.util.*;
import java.util.stream.Collectors;

import static net.runelite.api.ItemID.ANIMALS_BONES;

@Slf4j
@PluginDescriptor(
	name = "Archipelago Randomizer"
)
public class ArchipelagoPlugin extends Plugin
{
	public static ArchipelagoPlugin plugin;

	@Inject
	private Client client;
	@Inject
	private ClientThread clientThread;
	@Inject
	private ArchipelagoConfig config;
	@Inject
	private ClientToolbar clientToolbar;
	@Inject
	private SpriteManager spriteManager;
	@Inject
	private ConfigManager configManager;

	private ArchipelagoPanel panel;
	private OSRSClient apClient;
	private int modIconIndex = -1;
	private final List<ItemData> collectedItems = new ArrayList<>();

	public boolean loggedIn;
	public boolean connected;
	public long lastItemReceivedIndex = -1;
	//This boolean will become true when we log in, and will be set back to false in the first game tick.
	//This lets us check if the logged in player should auto-connect to AP
	private boolean justLoggedIn = false;

	private Queue<String[]> queuedMessages = new LinkedList<>();
	private boolean isDisplayingPopup = false;
	private NavigationButton navButton;

	protected List<APTask> activeTasks = new ArrayList<>();

	@Provides
	ArchipelagoConfig provideConfig(ConfigManager configManager)
	{
		return configManager.getConfig(ArchipelagoConfig.class);
	}

	@Override
	protected void startUp() throws Exception
	{
		plugin = this;
		panel = new ArchipelagoPanel(this, config);
		apClient = new OSRSClient(this);

		final BufferedImage icon = ImageUtil.loadImageResource(getClass(), "panel_icon.png");

		navButton = NavigationButton.builder()
				.tooltip("Archipelago Randomizer")
				.icon(icon)
				.priority(20)
				.panel(panel)
				.build();

		clientToolbar.addNavigation(navButton);

		clientThread.invoke(() -> TaskLists.LoadImages(spriteManager));
		clientThread.invoke(() -> ItemHandler.LoadImages(spriteManager));

		loadSprites();
		clientThread.invoke(() -> client.runScript(ScriptID.CHAT_PROMPT_INIT));
	}

	@Override
	protected void shutDown() throws Exception
	{
		clientToolbar.removeNavigation(navButton);
		plugin = null;
		if (apClient != null && apClient.isConnected())
		{
			apClient.disconnect();
		}
		clientThread.invoke(() -> client.runScript(ScriptID.CHAT_PROMPT_INIT));
	}

	@Subscribe
	public void onScriptCallbackEvent(ScriptCallbackEvent event)
	{
		if (!event.getEventName().equals("setChatboxInput"))
		{
			return;
		}

		updateChatbox();
	}

	@Subscribe
	public void onBeforeRender(BeforeRender event)
	{
		updateChatbox(); // this stops flickering when typing
	}

	@Subscribe
	public void onGameStateChanged(GameStateChanged gameStateChanged)
	{
		if (gameStateChanged.getGameState() == GameState.LOGGED_IN)
		{
			loggedIn = true;
			justLoggedIn = true;
			loadSprites();
		}
		else if (gameStateChanged.getGameState() == GameState.LOGIN_SCREEN){
			loggedIn = false;
			if (connected){
				connected = false;
				apClient.disconnect();
			}
		}
	}
	@Subscribe
	public void onGameTick(GameTick tick){
		for (APTask task : activeTasks){
			task.OnGameTick(client);
		}
	}

	@Subscribe
	public void onClientTick(ClientTick t)
	{
		if (justLoggedIn && client.getLocalPlayer().getName() != null){
			//If we've just logged in with a character that's stored as our autoreconnect, connect immediately.
			if (!connected && config.autoreconnect().equals(client.getLocalPlayer().getName())){
				ConnectToAPServer();
				log.info("Detected log in of autoreconnect, connecting to AP server");
			}
			//If there is no autoreconnect set, and we're already connected to the AP server, set autoreconnect
			else if (config.autoreconnect().isBlank() && connected){
				configManager.setConfiguration("Archipelago", "autoreconnect", client.getLocalPlayer().getName());
				log.info("Detected first log in or connection, setting autoreconnect");
			}
			//If there _is_ an autoreconnect, we are currently connected, and the player we log in isn't the reconnect
			//IMMEDIATELY disconnect, do not pass go, do not collect $200
			else if (connected && !config.autoreconnect().equals(client.getLocalPlayer().getName())){
				apClient.disconnect();
				log.info("Detected log in of a non-auto-reconnect player. Disconnecting from server to avoid mixing checks");
			}
			justLoggedIn = false;
		}
		if (loggedIn && connected){
			checkStatus();
			SendChecks();

			if (!isDisplayingPopup && queuedMessages.size() > 0){
				String[] msg = queuedMessages.poll();
				isDisplayingPopup = true;
				clientThread.invokeLater(() -> {
					DisplayPopupMessage(msg[0],msg[1]);
				});
			}
		}
	}

	@Subscribe
	public void onNpcLootReceived(final NpcLootReceived npcLootReceived)
	{
		final NPC npc = npcLootReceived.getNpc();
		for(APTask task : activeTasks){
			task.CheckMobKill(npc);
		}
	}

	@Subscribe
	public void onChatMessage(ChatMessage event)
	{
		var message = event.getMessage();
		for (APTask task : activeTasks){
			task.CheckChatMessage(message);
		}

		if (event.getName() == null || client.getLocalPlayer() == null
				|| client.getLocalPlayer().getName() == null || !apClient.isConnected())
			return;

		boolean isLocalPlayer =
				Text.standardize(event.getName()).equalsIgnoreCase(Text.standardize(client.getLocalPlayer().getName()));

		if (isLocalPlayer)
		{
			String text = "<img=" + modIconIndex + ">"+ Text.removeTags(event.getName());
			event.getMessageNode().setName(text);
		}
	}

	@Subscribe
	public void onChatboxInput(ChatboxInput chatboxInput)
	{
		final String message = chatboxInput.getValue();

		String command = extractCommand(message);
		if ("!ap".equals(command)){
			String cmd = message.substring(3);
			apClient.sendChat(cmd);
			log.info("Sending string to AP: "+cmd);
			chatboxInput.consume();
		}
	}

	@Subscribe
	public void onMenuOptionClicked(MenuOptionClicked event){
		if (connected){
			if (event.getMenuOption().equals("Wear") || event.getMenuOption().equals("Wield")){
				//If we are equipping an item
				if (event.getItemId() != -1){
					if (!IsItemAllowed((event.getItemId()))){
						event.consume();
						client.addChatMessage(ChatMessageType.GAMEMESSAGE, "AP", "You have not unlocked the ability to equip this item", null);
					}
				}
			}
		}
		for (APTask task : activeTasks){
			task.OnMenuOption(event);
		}
	}

	@Subscribe
	public void onItemContainerChanged(ItemContainerChanged event)
	{
		ItemContainer container = event.getItemContainer();

		if (container == client.getItemContainer(InventoryID.INVENTORY))
		{
			Item[] items = container.getItems();
		}
	}

	private boolean IsItemAllowed(int itemId){
		if (ItemHandler.MetalWeaponItemIds.contains(itemId)){
			int itemTier = (int) getCollectedItems().stream().filter(it -> it.name.equals(ItemNames.Progressive_Weapons)).count();
			for (int i=0; i <= itemTier; i++){
				if (Arrays.asList(ItemHandler.MetalWeaponsPermittedByTier.get(i)).contains(itemId)){
					return true;
				}
			}
			return false;
		} else if (ItemHandler.MetalArmorItemIds.contains(itemId)){
			int itemTier = (int) getCollectedItems().stream().filter(it -> it.name.equals(ItemNames.Progressive_Armor)).count();
			for (int i=0; i <= itemTier; i++){
				if (Arrays.asList(ItemHandler.MetalArmorPermittedByTier.get(i)).contains(itemId)){
					return true;
				}
			}
			return false;
		} else if (ItemHandler.RangeWeaponItemIds.contains(itemId)){
			int itemTier = (int) getCollectedItems().stream().filter(it -> it.name.equals(ItemNames.Progressive_Range_Weapon)).count();
			for (int i=0; i <= itemTier; i++){
				if (Arrays.asList(ItemHandler.RangeWeaponsPermittedByTier.get(i)).contains(itemId)){
					return true;
				}
			}
			return false;
		} else if (ItemHandler.RangeArmorItemIds.contains(itemId)){
			int itemTier = (int) getCollectedItems().stream().filter(it -> it.name.equals(ItemNames.Progressive_Range_Armor)).count();
			for (int i=0; i <= itemTier; i++){
				if (Arrays.asList(ItemHandler.RangeArmorPermittedByTier.get(i)).contains(itemId)){
					return true;
				}
			}
			return false;
		}
		//If it's not in any of those lists, it's fine
		return true;
	}

	public void SetConnectionState(boolean newConnectionState){
		activeTasks = new ArrayList<>();
		for(long id : apClient.getLocationManager().getCheckedLocations()){
			APTask task = TaskLists.GetTaskByID(id);
			if (task != null){
				task.SetCompleted();
				activeTasks.add(task);
			}
		}
		for(long id : apClient.getLocationManager().getMissingLocations()){
			APTask task = TaskLists.GetTaskByID(id);
			if (task != null){
				activeTasks.add(task);
			}
		}
		activeTasks = activeTasks.stream().sorted(Comparator.comparing(APTask::GetID)).collect(Collectors.toList());

		if (connected != newConnectionState)
			panel.ConnectionStateChanged(newConnectionState);
		connected = newConnectionState;

		if (config.autoreconnect().isBlank() && connected && loggedIn){
			configManager.setConfiguration("Archipelago", "autoreconnect", client.getLocalPlayer().getName());
			log.info("Detected first log in or connection, setting autoreconnect");
		}
	}



	public void DisplayChatMessage(String msg)
	{
		clientThread.invoke(() ->
				client.addChatMessage(ChatMessageType.GAMEMESSAGE, "AP", "<img=" + modIconIndex + ">"+msg, null)
		);
	}

	private void checkStatus()
	{
		for (APTask task : activeTasks){
			task.CheckPlayerStatus(client);
		}

		if(Quest.DRAGON_SLAYER_I.getState(client) == QuestState.FINISHED){
			apClient.setGameState(ClientStatus.CLIENT_GOAL);
		}
	}

	public void ConnectToAPServer()
	{
		String uri = config.address()+":"+config.port();
		log.info(uri);
		apClient.newConnection(this, uri, config.slotname(), config.password());
	}

	private String extractCommand(String message)
	{
		int idx = message.indexOf(' ');
		if (idx == -1)
		{
			return message;
		}

		return message.substring(0, idx);
	}

	private void updateChatbox()
	{
		Widget chatboxTypedText = client.getWidget(ComponentID.CHATBOX_INPUT);

		if (chatboxTypedText == null || chatboxTypedText.isHidden() || !apClient.isConnected())
		{
			return;
		}

		String[] chatbox = chatboxTypedText.getText().split(":", 2);
		String rsn = Objects.requireNonNull(client.getLocalPlayer()).getName();

		String text = "<img=" + modIconIndex + ">" + Text.removeTags(rsn) + ":" + chatbox[1];
		chatboxTypedText.setText(text);
	}

	private void SendChecks()
	{
		Collection<Long> checkedLocations = activeTasks.stream()
				.filter(loc -> loc.IsCompleted())
				.map(loc -> loc.GetID())
				.collect(Collectors.toList());

		if (apClient != null && apClient.isConnected()){
			apClient.checkLocations(checkedLocations);
		}

		SwingUtilities.invokeLater(panel::UpdateTaskStatus);
		SwingUtilities.invokeLater(panel::UpdateItems);
	}

	public void addCollectedItem(ItemData item){
		log.info("Received item: "+item.name);
		collectedItems.add(item);
		panel.UpdateItems();
		UpdateAvailableChunks();
	}

	private void UpdateAvailableChunks(){
		List<String> unlockedRegions = new ArrayList<>();
		for (ItemData item : collectedItems){
			String regions = ItemHandler.RegionNamesToChunkIdString.getOrDefault(item.name, null);
			if (regions != null) unlockedRegions.add(regions);
		}
		String csv = Text.toCSV(unlockedRegions);
		//TODO replace dependency on regionlocker with custom solution. Good for testing though
		configManager.setConfiguration("regionlocker", "unlockedRegions", csv);
	}


	public List<ItemData> getCollectedItems() {
		return collectedItems;
	}
	public void DisplayNetworkMessage(String message){
		panel.DisplayNetworkMessage(message);
	}
	
	/////////// SPRITES ///////////
	private void loadSprites()
	{
		clientThread.invoke(() ->
		{
			//If we already have the mod icon, we don't need to do it again
			if (modIconIndex > -1) return;

			IndexedSprite[] modIcons = client.getModIcons();
			List<IndexedSprite> newList = new ArrayList<>();

			modIconIndex = modIcons.length;

			final IndexedSprite sprite = getIndexedSpriteEmbedded();

			newList.add(sprite);

			IndexedSprite[] newAry = Arrays.copyOf(modIcons, modIcons.length + newList.size());
			System.arraycopy(newList.toArray(new IndexedSprite[0]), 0, newAry, modIcons.length, newList.size());
			client.setModIcons(newAry);
		});
	}

	private IndexedSprite getIndexedSpriteEmbedded()
	{
		try
		{
			log.debug("Loading: {}", "chat_icon.png");
			BufferedImage image = ImageUtil.loadImageResource(this.getClass(), "chat_icon.png");
			return ImageUtil.getImageIndexedSprite(image, client);
		}
		catch (RuntimeException ex)
		{
			log.debug("Unable to load image: ", ex);
		}
		return null;
	}
	/////////// END SPRITES ///////////

	/////////// POPUP ///////////
	public void QueuePopupMessage(String header, String body){
		log.info("Queueing popup message for "+body);
		queuedMessages.add(new String[]{header, body});
	}
	private void DisplayPopupMessage(String header, String body){
		WidgetNode widgetNode = client.openInterface((161 << 16) | 13, 660, WidgetModalMode.MODAL_CLICKTHROUGH);
		log.info("Opening popup message for "+body);
		client.runScript(3343, header, body, -1);

		clientThread.invokeLater(() -> {
			Widget w = client.getWidget(660, 1);
			if (w.getWidth() > 0) {
				return false;
			}

			client.closeInterface(widgetNode, true);
			log.info("Closing interface message for "+body);
			isDisplayingPopup = false;
			return true;
		});
	}
	/////////// END POPUP ///////////
}

package gg.archipelago;

import gg.archipelago.data.ItemData;
import gg.archipelago.data.ItemNames;
import net.runelite.client.ui.ColorScheme;

import javax.swing.*;
import javax.swing.border.EmptyBorder;
import java.awt.*;
import java.awt.image.BufferedImage;
import java.util.HashMap;

public class ItemPanel extends JPanel {
    private final ArchipelagoPlugin plugin;

    private final HashMap<ItemData, ItemRow> itemPanels = new HashMap<>();

    public ItemPanel(ArchipelagoPlugin plugin){
        this.plugin = plugin;

        setLayout(new BoxLayout(this, BoxLayout.Y_AXIS));

        setBackground(ColorScheme.DARKER_GRAY_COLOR);
        setBorder(new EmptyBorder(5, 5, 5, 10));
        setVisible(false);

        setAlignmentX(Component.LEFT_ALIGNMENT);
    }

    public void UpdateItems(){
        setVisible(true);

        for (ItemData item : ItemHandler.AllItems){
            int countInCollection = (int) plugin.getCollectedItems().stream().filter(it -> it.name.equals(item.name)).count();
            //Progressive items have special name formatting. Everything else uses the item name
            switch(item.name){
                case ItemNames.Progressive_Armor:
                    addOrUpdateItemPanel(item, String.format("Armor up to %s", ItemHandler.MetalTierByCount(countInCollection)));
                    break;
                case ItemNames.Progressive_Weapons:
                    addOrUpdateItemPanel(item, String.format("Weapons up to %s", ItemHandler.MetalTierByCount(countInCollection)));
                    break;
                case ItemNames.Progressive_Tools:
                    addOrUpdateItemPanel(item, String.format("Tools up to %s", ItemHandler.MetalTierByCount(countInCollection)));
                    break;
                case ItemNames.Progressive_Range_Armor:
                    addOrUpdateItemPanel(item, ItemHandler.RangeArmorTierByCount(countInCollection));
                    break;
                case ItemNames.Progressive_Range_Weapon:
                    addOrUpdateItemPanel(item, ItemHandler.RangeWeaponTierByCount(countInCollection));
                    break;
                case ItemNames.Progressive_Magic:
                    addOrUpdateItemPanel(item, ItemHandler.MagicTierByCount(countInCollection));
                    break;
                default:
                    if (countInCollection > 0){
                        addOrUpdateItemPanel(item, item.name);
                    }
            }
        }
        revalidate();
        repaint();
    }

    private void addOrUpdateItemPanel(ItemData item, String text){
        //The dict can have a null value, but if it does, we don't want to add it again (it's waiting for the ui thread)
        //So we just check the presence of the key here, then check for null inside the if
        if (itemPanels.containsKey(item)){
            if (itemPanels.get(item) != null)
                itemPanels.get(item).SetText(text);
        } else {
            itemPanels.put(item, null);
            SwingUtilities.invokeLater(() -> {
                ItemRow itemPanel = new ItemRow(text, ItemHandler.loadedSprites.get(item));
                itemPanels.put(item, itemPanel);
                add(itemPanel);
            });
        }
    }

    private static class ItemRow extends JPanel {

        private final JLabel labelText;

        public ItemRow(String text, BufferedImage image){
            super();
            setLayout(new BorderLayout());
            setBackground(ColorScheme.DARKER_GRAY_COLOR);
            setPreferredSize(new Dimension(0, 30));
            setAlignmentX(Component.LEFT_ALIGNMENT);

            if (image != null){
                JLabel icon = new JLabel(new ImageIcon(image));
                add(icon, BorderLayout.WEST);
            }

            labelText = new JLabel(text);
            labelText.setForeground(Color.WHITE);
            add(labelText, BorderLayout.CENTER);
            setVisible(true);
        }

        public void SetText(String text){
            labelText.setText(text);
        }
    }
}

package gg.archipelago;

import net.runelite.client.config.Config;
import net.runelite.client.config.ConfigGroup;
import net.runelite.client.config.ConfigItem;

@ConfigGroup("Archipelago")
public interface ArchipelagoConfig extends Config
{
	@ConfigItem(
		keyName = "address",
		name = "Server Address",
		description = "The URL of the server to connect to",
			position = 0
	)
	default String address()
	{
		return "localhost";
	}

	@ConfigItem(
			keyName = "port",
			name = "Server Port",
			description = "The Port of the server to connect to",
			position = 1
	)
	default String port()
	{
		return "38281";
	}

	@ConfigItem(
			keyName = "slotname",
			name = "Slot Name",
			description = "The Player slot to connect to",
			position = 2
	)
	default String slotname()
	{
		return "";
	}

	@ConfigItem(
			keyName = "password",
			name = "Server Password",
			description = "The Password of the server to connect to",
			position = 3
	)
	default String password()
	{
		return "";
	}

	@ConfigItem(
			keyName = "autoreconnect",
			name = "Auto Reconnect On Login For",
			description = "Whenever a character with this name logs in, automatically attempt connecting to the server.",
			position = 4
	)
	default String autoreconnect()
	{
		return "";
	}
}

package gg.archipelago;

import gg.archipelago.Tasks.*;
import gg.archipelago.data.LocationData;
import net.runelite.api.*;
import net.runelite.client.game.SpriteManager;

import java.awt.image.BufferedImage;
import java.util.*;

public class TaskLists {
    public static final long base_id = 0x070000;
    public static int taskCount = 0;
    public static List<APTask> allTasks = List.of(
            new QuestTask(base_id + taskCount++, Quest.COOKS_ASSISTANT),
            new QuestTask(base_id + taskCount++, Quest.DEMON_SLAYER),
            new QuestTask(base_id + taskCount++, Quest.THE_RESTLESS_GHOST),
            new QuestTask(base_id + taskCount++, Quest.ROMEO__JULIET),
            new QuestTask(base_id + taskCount++, Quest.SHEEP_SHEARER),
            new QuestTask(base_id + taskCount++, Quest.SHIELD_OF_ARRAV),
            new QuestTask(base_id + taskCount++, Quest.ERNEST_THE_CHICKEN),
            new QuestTask(base_id + taskCount++, Quest.VAMPYRE_SLAYER),
            new QuestTask(base_id + taskCount++, Quest.IMP_CATCHER),
            new QuestTask(base_id + taskCount++, Quest.PRINCE_ALI_RESCUE),
            new QuestTask(base_id + taskCount++, Quest.DORICS_QUEST),
            new QuestTask(base_id + taskCount++, Quest.BLACK_KNIGHTS_FORTRESS),
            new QuestTask(base_id + taskCount++, Quest.WITCHS_POTION),
            new QuestTask(base_id + taskCount++, Quest.THE_KNIGHTS_SWORD),
            new QuestTask(base_id + taskCount++, Quest.GOBLIN_DIPLOMACY),
            new QuestTask(base_id + taskCount++, Quest.PIRATES_TREASURE),
            new QuestTask(base_id + taskCount++, Quest.RUNE_MYSTERIES),
            new QuestTask(base_id + taskCount++, Quest.MISTHALIN_MYSTERY),
            new QuestTask(base_id + taskCount++, Quest.THE_CORSAIR_CURSE),
            new QuestTask(base_id + taskCount++, Quest.X_MARKS_THE_SPOT),
            new QuestTask(base_id + taskCount++, Quest.BELOW_ICE_MOUNTAIN),
            new QuestTask(base_id + taskCount++, Quest.DRAGON_SLAYER_I),
            new VarbitTask(base_id + taskCount++, "Activate the Rock Skin Prayer", SpriteID.SKILL_PRAYER, Prayer.ROCK_SKIN.getVarbit(), 1),
            new VarbitTask(base_id + taskCount++,"Activate the Protect Item Prayer", SpriteID.SKILL_PRAYER, Prayer.PROTECT_ITEM.getVarbit(), 1),
            new EdgevilleMonasteryTask(base_id + taskCount++),
            new CastSpellTask(base_id + taskCount++, CastSpellTask.SpellToCast.BONES_TO_BANANAS),
            new CastSpellTask(base_id + taskCount++, CastSpellTask.SpellToCast.VARROCK_TELE),
            new CastSpellTask(base_id + taskCount++, CastSpellTask.SpellToCast.LUMBRIDGE_TELE),
            new CastSpellTask(base_id + taskCount++, CastSpellTask.SpellToCast.FALADOR_TELE),
            new CraftRunesTask(base_id + taskCount++, CraftRunesTask.RuneType.AIR_RUNE),
            new CraftRunesTask(base_id + taskCount++, CraftRunesTask.RuneType.MIND_RUNE),
            new CraftRunesTask(base_id + taskCount++, CraftRunesTask.RuneType.BODY_RUNE),
            new ChatMessageTask(base_id + taskCount++,"Craft an Unblessed Holy Symbol",SpriteID.SKILL_CRAFTING, "You put some string on your holy symbol."),
            new ChatMessageTask(base_id + taskCount++,"Cut a Sapphire",SpriteID.SKILL_CRAFTING,"You cut the sapphire."),
            new ChatMessageTask(base_id + taskCount++,"Cut an Emerald",SpriteID.SKILL_CRAFTING, "You cut the emerald."),
            new ChatMessageTask(base_id + taskCount++,"Cut a Ruby",SpriteID.SKILL_CRAFTING, "You cut the ruby."),
            new ChatMessageTask(base_id + taskCount++,"Cut a Diamond",SpriteID.SKILL_CRAFTING, "You cut the diamond."),
            new ChatMessageTask(base_id + taskCount++,"Mine a Blurite Ore",SpriteID.SKILL_MINING, "You manage to mine some blurite."),
            new ChatMessageTask(base_id + taskCount++,"Crush a Barronite Deposit",SpriteID.SKILL_MINING, "You crush a barronite deposit with your hammer."),
            new ChatMessageTask(base_id + taskCount++,"Mine some Silver Ore",SpriteID.SKILL_MINING, "You manage to mine some silver."),
            new ChatMessageTask(base_id + taskCount++,"Mine some Coal",SpriteID.SKILL_MINING, "You manage to mine some coal."),
            new ChatMessageTask(base_id + taskCount++,"Mine some Gold Ore",SpriteID.SKILL_MINING, "You manage to mine some gold."),
            new ChatMessageTask(base_id + taskCount++,"Smelt an Iron Bar",SpriteID.SKILL_SMITHING, "You retrieve a bar of iron."),
            new ChatMessageTask(base_id + taskCount++,"Smelt a Silver Bar",SpriteID.SKILL_SMITHING, "You retrieve a bar of silver from the furnace."),
            new ChatMessageTask(base_id + taskCount++,"Smelt a Steel Bar",SpriteID.SKILL_SMITHING, "You retrieve a bar of steel."),
            new ChatMessageTask(base_id + taskCount++,"Smelt a Gold Bar",SpriteID.SKILL_SMITHING, "You retrieve a bar of gold from the furnace."),
            new ChatMessageTask(base_id + taskCount++,"Catch some Anchovies",SpriteID.SKILL_FISHING, "You catch some anchovies."),
            new ChatMessageTask(base_id + taskCount++,"Catch a Trout",SpriteID.SKILL_FISHING, "You catch a trout."),
            new ChatMessageTask(base_id + taskCount++,"Prepare a Tetra",SpriteID.SKILL_FISHING, "You successfully prepare the Tetra."),
            new ChatMessageTask(base_id + taskCount++,"Catch a Lobster",SpriteID.SKILL_FISHING, "You catch a lobster."),
            new ChatMessageTask(base_id + taskCount++,"Catch a Swordfish",SpriteID.SKILL_FISHING, "You catch a swordfish."),
            new ChatMessageTask(base_id + taskCount++,"Bake a Redberry Pie",SpriteID.SKILL_COOKING, "You successfully bake a delicious redberry pie."),
            new ChatMessageTask(base_id + taskCount++,"Cook a Stew",SpriteID.SKILL_COOKING, "You cook some stew."),
            new ChatMessageTask(base_id + taskCount++,"Bake an Apple Pie",SpriteID.SKILL_COOKING, "You successfully bake a traditional apple pie."),
            new ChatMessageTask(base_id + taskCount++,"Bake a Cake",SpriteID.SKILL_COOKING, "You successfully bake a cake."),
            new ChatMessageTask(base_id + taskCount++,"Bake a Meat Pizza",SpriteID.SKILL_COOKING, "You add the meat to the pizza."),
            new BurnLogsTask(base_id + taskCount++, BurnLogsTask.LogType.OAK),
            new BurnLogsTask(base_id + taskCount++, BurnLogsTask.LogType.WILLOW),
            new ChatMessageTask(base_id + taskCount++, "Sail on a Canoe",SpriteID.SKILL_WOODCUTTING, "Your canoe sinks into the water after the hard journey."),
            new ChatMessageTask(base_id + taskCount++, "Chop some Oak Logs",SpriteID.SKILL_WOODCUTTING, "You get some oak logs."),
            new ChatMessageTask(base_id + taskCount++, "Chop some Willow Logs",SpriteID.SKILL_WOODCUTTING, "You get some willow logs."),
            new KillTask(base_id + taskCount++, "Jeff"),
            new KillTask(base_id + taskCount++, "Goblin"),
            new KillTask(base_id + taskCount++, "Monkey"),
            new KillTask(base_id + taskCount++, "Barbarian"),
            new KillTask(base_id + taskCount++, "Giant Frog"),
            new KillTask(base_id + taskCount++, "Zombie"),
            new KillTask(base_id + taskCount++, "Guard"),
            new KillTask(base_id + taskCount++, "Hill Giant"),
            new KillTask(base_id + taskCount++, "Deadly Red Spider"),
            new KillTask(base_id + taskCount++, "Moss Giant"),
            new KillTask(base_id + taskCount++, "Catablepon"),
            new KillTask(base_id + taskCount++, "Ice Giant"),
            new KillTask(base_id + taskCount++, "Lesser Demon"),
            new KillTask(base_id + taskCount++, "Ogress Shaman"),
            new KillTask(base_id + taskCount++, "Obor"),
            new KillTask(base_id + taskCount++, "Bryophyta"),
            new TotalXPTask(base_id + taskCount++, 5000),
            new CombatLevelTask(base_id + taskCount++, 5),
            new TotalXPTask(base_id + taskCount++, 10000),
            new TotalLevelTask(base_id + taskCount++, 50),
            new TotalXPTask(base_id + taskCount++, 25000),
            new TotalLevelTask(base_id + taskCount++, 100),
            new TotalXPTask(base_id + taskCount++, 50000),
            new CombatLevelTask(base_id + taskCount++, 15),
            new TotalLevelTask(base_id + taskCount++, 150),
            new TotalXPTask(base_id + taskCount++, 75000),
            new CombatLevelTask(base_id + taskCount++, 25),
            new TotalXPTask(base_id + taskCount++, 100000),
            new TotalLevelTask(base_id + taskCount++, 200),
            new TotalXPTask(base_id + taskCount++, 125000),
            new CombatLevelTask(base_id + taskCount++, 30),
            new TotalLevelTask(base_id + taskCount++, 250),
            new TotalXPTask(base_id + taskCount++, 150000),
            new TotalLevelTask(base_id + taskCount++, 300),
            new CombatLevelTask(base_id + taskCount++, 40),
            new OpenLockboxTask(base_id + taskCount++, ItemID.SIMPLE_LOCKBOX),
            new OpenLockboxTask(base_id + taskCount++, ItemID.ELABORATE_LOCKBOX),
            new OpenLockboxTask(base_id + taskCount++, ItemID.ORNATE_LOCKBOX)
    );

    public static APTask GetTaskByID(long id){
        var filter = allTasks.stream().filter(apTask -> apTask.GetID() == id).findFirst();
        if (filter.isEmpty()){
            return null;
        } else {
            return filter.get();
        }
    }

    public static final Map<APTask, BufferedImage> loadedSprites = new HashMap<APTask, BufferedImage>();

    public static void LoadImages(SpriteManager spriteManager){
        for(APTask task : allTasks){
            //All tasks use an icon file offset of 0 so we can just assume that without needing to populate it
            loadedSprites.put(task, spriteManager.getSprite(task.GetSpriteID(), 0));
        }
    }
}

package gg.archipelago;

import gg.archipelago.data.ItemData;
import gg.archipelago.data.ItemNames;
import net.runelite.api.Item;
import net.runelite.api.ItemID;
import net.runelite.api.SpriteID;
import net.runelite.client.game.SpriteManager;

import java.awt.image.BufferedImage;
import java.util.*;

public class ItemHandler {
    public static final long base_id = 0x070000;
    public static List<ItemData> AllItems = List.of(
            new ItemData(base_id, ItemNames.Lumbridge, SpriteID.MINIMAP_ORB_WORLD_MAP_PLANET, 0),
            new ItemData(base_id + 1, ItemNames.Lumbridge_Swamp, SpriteID.MINIMAP_ORB_WORLD_MAP_PLANET, 0),
            new ItemData(base_id + 2, ItemNames.HAM_Hideout, SpriteID.MINIMAP_ORB_WORLD_MAP_PLANET, 0),
            new ItemData(base_id + 3, ItemNames.Lumbridge_Farms, SpriteID.MINIMAP_ORB_WORLD_MAP_PLANET, 0),
            new ItemData(base_id + 4, ItemNames.South_Of_Varrock, SpriteID.MINIMAP_ORB_WORLD_MAP_PLANET, 0),
            new ItemData(base_id + 5, ItemNames.East_Of_Varrock, SpriteID.MINIMAP_ORB_WORLD_MAP_PLANET, 0),
            new ItemData(base_id + 6, ItemNames.Central_Varrock, SpriteID.MINIMAP_ORB_WORLD_MAP_PLANET, 0),
            new ItemData(base_id + 7, ItemNames.Varrock_Palace, SpriteID.MINIMAP_ORB_WORLD_MAP_PLANET, 0),
            new ItemData(base_id + 8, ItemNames.West_Varrock, SpriteID.MINIMAP_ORB_WORLD_MAP_PLANET, 0),
            new ItemData(base_id + 9, ItemNames.Edgeville, SpriteID.MINIMAP_ORB_WORLD_MAP_PLANET, 0),
            new ItemData(base_id + 10, ItemNames.Barbarian_Village, SpriteID.MINIMAP_ORB_WORLD_MAP_PLANET, 0),
            new ItemData(base_id + 11, ItemNames.Draynor_Manor, SpriteID.MINIMAP_ORB_WORLD_MAP_PLANET, 0),
            new ItemData(base_id + 12, ItemNames.Falador, SpriteID.MINIMAP_ORB_WORLD_MAP_PLANET, 0),
            new ItemData(base_id + 13, ItemNames.Dwarven_Mines, SpriteID.MINIMAP_ORB_WORLD_MAP_PLANET, 0),
            new ItemData(base_id + 14, ItemNames.Ice_Mountain, SpriteID.MINIMAP_ORB_WORLD_MAP_PLANET, 0),
            new ItemData(base_id + 15, ItemNames.Monastery, SpriteID.MINIMAP_ORB_WORLD_MAP_PLANET, 0),
            new ItemData(base_id + 16, ItemNames.Falador_Farm, SpriteID.MINIMAP_ORB_WORLD_MAP_PLANET, 0),
            new ItemData(base_id + 17, ItemNames.Port_Sarim, SpriteID.MINIMAP_ORB_WORLD_MAP_PLANET, 0),
            new ItemData(base_id + 18, ItemNames.Mudskipper_Point, SpriteID.MINIMAP_ORB_WORLD_MAP_PLANET, 0),
            new ItemData(base_id + 19, ItemNames.Karamja, SpriteID.MINIMAP_ORB_WORLD_MAP_PLANET, 0),
            new ItemData(base_id + 20, ItemNames.Crandor, SpriteID.MINIMAP_ORB_WORLD_MAP_PLANET, 0),
            new ItemData(base_id + 21, ItemNames.Rimmington, SpriteID.MINIMAP_ORB_WORLD_MAP_PLANET, 0),
            new ItemData(base_id + 22, ItemNames.Crafting_Guild, SpriteID.MINIMAP_ORB_WORLD_MAP_PLANET, 0),
            new ItemData(base_id + 23, ItemNames.Draynor_Village, SpriteID.MINIMAP_ORB_WORLD_MAP_PLANET, 0),
            new ItemData(base_id + 24, ItemNames.Wizards_Tower, SpriteID.MINIMAP_ORB_WORLD_MAP_PLANET, 0),
            new ItemData(base_id + 25, ItemNames.Corsair_Cove, SpriteID.MINIMAP_ORB_WORLD_MAP_PLANET, 0),
            new ItemData(base_id + 26, ItemNames.Al_Kharid, SpriteID.MINIMAP_ORB_WORLD_MAP_PLANET, 0),
            new ItemData(base_id + 27, ItemNames.Citharede_Abbey, SpriteID.MINIMAP_ORB_WORLD_MAP_PLANET, 0),
            new ItemData(base_id + 28, ItemNames.Wilderness, SpriteID.MINIMAP_ORB_WORLD_MAP_PLANET, 0),
            new ItemData(base_id + 29, ItemNames.Progressive_Armor, SpriteID.MAP_ICON_HELMET_SHOP, 0),
            new ItemData(base_id + 30, ItemNames.Progressive_Weapons, SpriteID.MAP_ICON_SWORD_SHOP, 0),
            new ItemData(base_id + 31, ItemNames.Progressive_Tools, SpriteID.MAP_ICON_MINING_SHOP, 0),
            new ItemData(base_id + 32, ItemNames.Progressive_Range_Weapon, SpriteID.MAP_ICON_ARCHERY_SHOP, 0),
            new ItemData(base_id + 33, ItemNames.Progressive_Range_Armor, SpriteID.MAP_ICON_TANNERY, 0),
            new ItemData(base_id + 34, ItemNames.Progressive_Magic, SpriteID.MAP_ICON_MAGIC_SHOP, 0)
    );

    public static Map<String, String> RegionNamesToChunkIdString = Map.ofEntries(
            Map.entry(ItemNames.Lumbridge, "12850"),
            Map.entry(ItemNames.Lumbridge_Swamp, "12849,12593"),
            Map.entry(ItemNames.Lumbridge_Farms, "12851,12595"),
            Map.entry(ItemNames.HAM_Hideout, "12594"),
            Map.entry(ItemNames.Draynor_Village, "12338,12339"),
            Map.entry(ItemNames.Draynor_Manor, "12340"),
            Map.entry(ItemNames.Wizards_Tower, "12337"),
            Map.entry(ItemNames.Al_Kharid, "13107,13106,13362,13105,13104"),
            Map.entry(ItemNames.Citharede_Abbey, "13361,13617"),
            Map.entry(ItemNames.South_Of_Varrock, "13108,12852,12596"),
            Map.entry(ItemNames.Central_Varrock, "12853"),
            Map.entry(ItemNames.Varrock_Palace, "12854"),
            Map.entry(ItemNames.East_Of_Varrock, "13109,13110"),
            Map.entry(ItemNames.West_Varrock, "12598,12597"),
            Map.entry(ItemNames.Edgeville, "12342"),
            Map.entry(ItemNames.Barbarian_Village, "12341"),
            Map.entry(ItemNames.Monastery, "12086"),
            Map.entry(ItemNames.Ice_Mountain, "11830"),
            Map.entry(ItemNames.Dwarven_Mines, "12085,11829"),
            Map.entry(ItemNames.Falador, "12084,11828"),
            Map.entry(ItemNames.Falador_Farm, "12083,11827"),
            Map.entry(ItemNames.Crafting_Guild, "11571"),
            Map.entry(ItemNames.Rimmington, "11826,11570"),
            Map.entry(ItemNames.Port_Sarim, "12082,12081"),
            Map.entry(ItemNames.Mudskipper_Point, "11825,11824"),
            Map.entry(ItemNames.Karamja, "11569,11313"),
            Map.entry(ItemNames.Crandor, "11315,11314"),
            Map.entry(ItemNames.Corsair_Cove, "10284,10028"),
            Map.entry(ItemNames.Wilderness, "11836,11835,11834,11833,11832,11831,12092,12091,12090,12089,12088,12087,12348,12347,12346,12345,12344,12343,12604,12603,12602,12601,12600,12599,12860,12859,12858,12857,12856,12855,13116,13115,13114,13113,13112,13111,13372,13371,13370,13369,13368,13367")
    );

    public static final Map<ItemData, BufferedImage> loadedSprites = new HashMap<ItemData, BufferedImage>();

    public static ItemData GetItemByName(String name) {
        return AllItems.stream()
                .filter(item -> name.equals(item.name))
                .findFirst()
                .orElse(null);
    }

    public static Dictionary<Long, ItemData> ItemsById = new Hashtable<>() {{
        for (ItemData item : AllItems) {
            put(item.id, item);
        }
    }};

    public static String MetalTierByCount(int count) {
        switch (count) {
            default:
                return "Bronze";
            case 1:
                return "Iron";
            case 2:
                return "Steel";
            case 3:
                return "Black";
            case 4:
                return "Mithril";
            case 5:
                return "Adamant";
            case 6:
                return "Rune";
        }
    }

    public static String RangeArmorTierByCount(int count) {
        switch (count) {
            default:
                return "No Ranged Armor";
            case 1:
                return "Ranged Armor: Leather";
            case 2:
                return "Ranged Armor: Studded Leather";
            case 3:
                return "Ranged Armor: Green Dragonhide";
        }
    }

    public static String RangeWeaponTierByCount(int count) {
        switch (count) {
            default:
                return "Bows: Wooden, Arrows: Iron";
            case 1:
                return "Bows: Oak, Arrows: Steel";
            case 2:
                return "Bows: Willow, Arrows: Mith";
            case 3:
                return "Bows: Maple, Arrows: Adamant";
        }
    }

    public static String MagicTierByCount(int count) {
        switch (count) {
            default:
                return "Strike Spells (Mind Runes)";
            case 1:
                return "Bolt Spells (Chaos Runes)";
            case 2:
                return "Blast Spells (Death Runes)";
        }
    }

    public static void LoadImages(SpriteManager spriteManager) {
        for (ItemData item : AllItems) {
            loadedSprites.put(item, spriteManager.getSprite(item.icon_id, item.icon_file));
        }
    }


    public static final Map<Integer, Integer[]> MetalWeaponsPermittedByTier = new Hashtable<>() {
        {
            put(0, new Integer[]{
                    ItemID.BRONZE_2H_SWORD, ItemID.BRONZE_AXE, ItemID.BRONZE_BATTLEAXE,
                    ItemID.BRONZE_CLAWS, ItemID.BRONZE_DAGGER, ItemID.BRONZE_DAGGERP, ItemID.BRONZE_DAGGERP_5670,
                    ItemID.BRONZE_DAGGERP_5688, ItemID.BRONZE_HALBERD, ItemID.BRONZE_HASTA, ItemID.BRONZE_HASTAKP,
                    ItemID.BRONZE_HASTAP, ItemID.BRONZE_HASTAP_11382, ItemID.BRONZE_HASTAP_11384,
                    ItemID.BRONZE_LONGSWORD, ItemID.BRONZE_MACE, ItemID.BRONZE_PICKAXE, ItemID.BRONZE_SCIMITAR,
                    ItemID.BRONZE_SPEAR, ItemID.BRONZE_SPEARKP, ItemID.BRONZE_SPEARP, ItemID.BRONZE_SPEARP_5704,
                    ItemID.BRONZE_SPEARP_5718, ItemID.BRONZE_SWORD, ItemID.BRONZE_WARHAMMER
            });
            put(1, new Integer[]{
                    ItemID.IRON_2H_SWORD, ItemID.IRON_AXE, ItemID.IRON_BATTLEAXE,
                    ItemID.IRON_CLAWS, ItemID.IRON_DAGGER, ItemID.IRON_DAGGERP, ItemID.IRON_DAGGERP_5668,
                    ItemID.IRON_DAGGERP_5686, ItemID.IRON_HALBERD, ItemID.IRON_HASTA, ItemID.IRON_HASTAKP,
                    ItemID.IRON_HASTAP, ItemID.IRON_HASTAP_11389, ItemID.IRON_HASTAP_11391,
                    ItemID.IRON_LONGSWORD, ItemID.IRON_MACE, ItemID.IRON_PICKAXE, ItemID.IRON_SCIMITAR,
                    ItemID.IRON_SPEAR, ItemID.IRON_SPEARKP, ItemID.IRON_SPEARP, ItemID.IRON_SPEARP_5706,
                    ItemID.IRON_SPEARP_5720, ItemID.IRON_SWORD, ItemID.IRON_WARHAMMER
            });
            put(2, new Integer[]{
                    ItemID.STEEL_2H_SWORD, ItemID.STEEL_AXE, ItemID.STEEL_BATTLEAXE,
                    ItemID.STEEL_CLAWS, ItemID.STEEL_DAGGER, ItemID.STEEL_DAGGERP, ItemID.STEEL_DAGGERP_5672,
                    ItemID.STEEL_DAGGERP_5690, ItemID.STEEL_HALBERD, ItemID.STEEL_HASTA, ItemID.STEEL_HASTAKP,
                    ItemID.STEEL_HASTAP, ItemID.STEEL_HASTAP_11396, ItemID.STEEL_HASTAP_11398,
                    ItemID.STEEL_LONGSWORD, ItemID.STEEL_MACE, ItemID.STEEL_PICKAXE, ItemID.STEEL_SCIMITAR,
                    ItemID.STEEL_SPEAR, ItemID.STEEL_SPEARKP, ItemID.STEEL_SPEARP, ItemID.STEEL_SPEARP_5708,
                    ItemID.STEEL_SPEARP_5722, ItemID.STEEL_SWORD, ItemID.STEEL_WARHAMMER
            });
            put(3, new Integer[]{
                    ItemID.BLACK_2H_SWORD, ItemID.BLACK_AXE, ItemID.BLACK_BATTLEAXE,
                    ItemID.BLACK_CLAWS, ItemID.BLACK_DAGGER, ItemID.BLACK_DAGGERP, ItemID.BLACK_DAGGERP_5682,
                    ItemID.BLACK_DAGGERP_5700, ItemID.BLACK_HALBERD, ItemID.BLACK_LONGSWORD, ItemID.BLACK_MACE,
                    ItemID.BLACK_PICKAXE, ItemID.BLACK_SCIMITAR, ItemID.BLACK_SPEAR, ItemID.BLACK_SPEARKP,
                    ItemID.BLACK_SPEARP, ItemID.BLACK_SPEARP_5734, ItemID.BLACK_SPEARP_5736, ItemID.BLACK_SWORD,
                    ItemID.BLACK_WARHAMMER
            });
            put(4, new Integer[]{
                    ItemID.MITHRIL_2H_SWORD, ItemID.MITHRIL_AXE, ItemID.MITHRIL_BATTLEAXE,
                    ItemID.MITHRIL_CLAWS, ItemID.MITHRIL_DAGGER, ItemID.MITHRIL_DAGGERP, ItemID.MITHRIL_DAGGERP_5674,
                    ItemID.MITHRIL_DAGGERP_5692, ItemID.MITHRIL_HALBERD, ItemID.MITHRIL_HASTA, ItemID.MITHRIL_HASTAKP,
                    ItemID.MITHRIL_HASTAP, ItemID.MITHRIL_HASTAP_11403, ItemID.MITHRIL_HASTAP_11405,
                    ItemID.MITHRIL_LONGSWORD, ItemID.MITHRIL_MACE, ItemID.MITHRIL_PICKAXE, ItemID.MITHRIL_SCIMITAR,
                    ItemID.MITHRIL_SPEAR, ItemID.MITHRIL_SPEARKP, ItemID.MITHRIL_SPEARP, ItemID.MITHRIL_SPEARP_5710,
                    ItemID.MITHRIL_SPEARP_5724, ItemID.MITHRIL_SWORD, ItemID.MITHRIL_WARHAMMER
            });
            put(5, new Integer[]{
                    ItemID.ADAMANT_2H_SWORD, ItemID.ADAMANT_AXE, ItemID.ADAMANT_BATTLEAXE,
                    ItemID.ADAMANT_CLAWS, ItemID.ADAMANT_DAGGER, ItemID.ADAMANT_DAGGERP, ItemID.ADAMANT_DAGGERP_5676,
                    ItemID.ADAMANT_DAGGERP_5694, ItemID.ADAMANT_HALBERD, ItemID.ADAMANT_HASTA, ItemID.ADAMANT_HASTAKP,
                    ItemID.ADAMANT_HASTAP, ItemID.ADAMANT_HASTAP_11410, ItemID.ADAMANT_HASTAP_11412,
                    ItemID.ADAMANT_LONGSWORD, ItemID.ADAMANT_MACE, ItemID.ADAMANT_PICKAXE, ItemID.ADAMANT_SCIMITAR,
                    ItemID.ADAMANT_SPEAR, ItemID.ADAMANT_SPEARKP, ItemID.ADAMANT_SPEARP, ItemID.ADAMANT_SPEARP_5712,
                    ItemID.ADAMANT_SPEARP_5726, ItemID.ADAMANT_SWORD, ItemID.ADAMANT_WARHAMMER
            });
            put(6, new Integer[]{
                    ItemID.RUNE_2H_SWORD, ItemID.RUNE_AXE, ItemID.RUNE_BATTLEAXE,
                    ItemID.RUNE_CLAWS, ItemID.RUNE_DAGGER, ItemID.RUNE_DAGGERP, ItemID.RUNE_DAGGERP_5678,
                    ItemID.RUNE_DAGGERP_5696, ItemID.RUNE_HALBERD, ItemID.RUNE_HASTA, ItemID.RUNE_HASTAKP,
                    ItemID.RUNE_HASTAP, ItemID.RUNE_HASTAP_11417, ItemID.RUNE_HASTAP_11419,
                    ItemID.RUNE_LONGSWORD, ItemID.RUNE_MACE, ItemID.RUNE_PICKAXE, ItemID.RUNE_SCIMITAR,
                    ItemID.RUNE_SPEAR, ItemID.RUNE_SPEARKP, ItemID.RUNE_SPEARP, ItemID.RUNE_SPEARP_5714,
                    ItemID.RUNE_SPEARP_5728, ItemID.RUNE_SWORD, ItemID.RUNE_WARHAMMER
            });
        }
    };

    public static final List<Integer> MetalWeaponItemIds = new ArrayList<Integer>(){{
        for (int i=0;i<MetalWeaponsPermittedByTier.size();i++){
            Collections.addAll(this,MetalWeaponsPermittedByTier.get(i));
        }
    }};

    public static Map<Integer, Integer[]> MetalArmorPermittedByTier = new Hashtable<>() {
        {
            put(0, new Integer[]{
                    ItemID.BRONZE_BOOTS, ItemID.BRONZE_CHAINBODY, ItemID.BRONZE_GLOVES, ItemID.BRONZE_MED_HELM,
                    ItemID.BRONZE_FULL_HELM, ItemID.BRONZE_FULL_HELM_T, ItemID.BRONZE_FULL_HELM_G,
                    ItemID.BRONZE_KITESHIELD, ItemID.BRONZE_KITESHIELD_T, ItemID.BRONZE_KITESHIELD_G,
                    ItemID.BRONZE_PLATEBODY, ItemID.BRONZE_PLATEBODY_T, ItemID.BRONZE_PLATEBODY_G,
                    ItemID.BRONZE_PLATELEGS, ItemID.BRONZE_PLATELEGS_T, ItemID.BRONZE_PLATELEGS_G,
                    ItemID.BRONZE_PLATESKIRT, ItemID.BRONZE_PLATESKIRT_T, ItemID.BRONZE_PLATESKIRT_G,
                    ItemID.BRONZE_SQ_SHIELD
            });
            put(1, new Integer[]{
                    ItemID.IRON_BOOTS, ItemID.IRON_CHAINBODY, ItemID.IRON_GLOVES, ItemID.IRON_MED_HELM,
                    ItemID.IRON_FULL_HELM, ItemID.IRON_FULL_HELM_T, ItemID.IRON_FULL_HELM_G,
                    ItemID.IRON_KITESHIELD, ItemID.IRON_KITESHIELD_T, ItemID.IRON_KITESHIELD_G,
                    ItemID.IRON_PLATEBODY, ItemID.IRON_PLATEBODY_T, ItemID.IRON_PLATEBODY_G,
                    ItemID.IRON_PLATELEGS, ItemID.IRON_PLATELEGS_T, ItemID.IRON_PLATELEGS_G,
                    ItemID.IRON_PLATESKIRT, ItemID.IRON_PLATESKIRT_T, ItemID.IRON_PLATESKIRT_G,
                    ItemID.IRON_SQ_SHIELD, ItemID.IRONMAN_HELM, ItemID.IRONMAN_PLATEBODY, ItemID.IRONMAN_PLATELEGS,
                    ItemID.HARDCORE_IRONMAN_HELM, ItemID.HARDCORE_IRONMAN_PLATEBODY, ItemID.HARDCORE_IRONMAN_PLATELEGS,
                    ItemID.GROUP_IRONMAN_BRACERS, ItemID.GROUP_IRONMAN_BRACERS_UNRANKED, ItemID.GROUP_IRONMAN_HELM,
                    ItemID.GROUP_IRONMAN_HELM_UNRANKED, ItemID.GROUP_IRONMAN_PLATEBODY, ItemID.GROUP_IRONMAN_PLATEBODY_26160,
                    ItemID.GROUP_IRONMAN_PLATEBODY_26162, ItemID.GROUP_IRONMAN_PLATEBODY_26164,
                    ItemID.GROUP_IRONMAN_PLATEBODY_UNRANKED, ItemID.GROUP_IRONMAN_PLATEBODY_UNRANKED_27050,
                    ItemID.GROUP_IRONMAN_PLATEBODY_UNRANKED_27052, ItemID.GROUP_IRONMAN_PLATEBODY_UNRANKED_27054,
                    ItemID.GROUP_IRONMAN_PLATELEGS, ItemID.GROUP_IRONMAN_PLATELEGS_UNRANKED,
                    ItemID.HARDCORE_GROUP_IRONMAN_BRACERS, ItemID.HARDCORE_GROUP_IRONMAN_HELM,
                    ItemID.HARDCORE_GROUP_IRONMAN_PLATEBODY, ItemID.HARDCORE_GROUP_IRONMAN_PLATEBODY_26174,
                    ItemID.HARDCORE_GROUP_IRONMAN_PLATEBODY_26176, ItemID.HARDCORE_GROUP_IRONMAN_PLATEBODY_26178,
                    ItemID.HARDCORE_GROUP_IRONMAN_PLATELEGS
            });
            put(2, new Integer[]{
                    ItemID.STEEL_BOOTS, ItemID.STEEL_CHAINBODY, ItemID.STEEL_GLOVES, ItemID.STEEL_MED_HELM,
                    ItemID.STEEL_FULL_HELM, ItemID.STEEL_FULL_HELM_T, ItemID.STEEL_FULL_HELM_G,
                    ItemID.STEEL_KITESHIELD, ItemID.STEEL_KITESHIELD_T, ItemID.STEEL_KITESHIELD_G,
                    ItemID.STEEL_PLATEBODY, ItemID.STEEL_PLATEBODY_T, ItemID.STEEL_PLATEBODY_G,
                    ItemID.STEEL_PLATELEGS, ItemID.STEEL_PLATELEGS_T, ItemID.STEEL_PLATELEGS_G,
                    ItemID.STEEL_PLATESKIRT, ItemID.STEEL_PLATESKIRT_T, ItemID.STEEL_PLATESKIRT_G,
                    ItemID.STEEL_SQ_SHIELD,
                    ItemID.STEEL_HERALDIC_HELM, ItemID.STEEL_HERALDIC_HELM_8684, ItemID.STEEL_HERALDIC_HELM_8686,
                    ItemID.STEEL_HERALDIC_HELM_8688, ItemID.STEEL_HERALDIC_HELM_8690, ItemID.STEEL_HERALDIC_HELM_8692,
                    ItemID.STEEL_HERALDIC_HELM_8694, ItemID.STEEL_HERALDIC_HELM_8696, ItemID.STEEL_HERALDIC_HELM_8698,
                    ItemID.STEEL_HERALDIC_HELM_8700, ItemID.STEEL_HERALDIC_HELM_8702, ItemID.STEEL_HERALDIC_HELM_8704,
                    ItemID.STEEL_HERALDIC_HELM_8706, ItemID.STEEL_HERALDIC_HELM_8708, ItemID.STEEL_HERALDIC_HELM_8710,
                    ItemID.STEEL_HERALDIC_HELM_8712,
                    ItemID.STEEL_KITESHIELD_8746, ItemID.STEEL_KITESHIELD_8748, ItemID.STEEL_KITESHIELD_8750,
                    ItemID.STEEL_KITESHIELD_8752, ItemID.STEEL_KITESHIELD_8754, ItemID.STEEL_KITESHIELD_8756,
                    ItemID.STEEL_KITESHIELD_8758, ItemID.STEEL_KITESHIELD_8760, ItemID.STEEL_KITESHIELD_8762,
                    ItemID.STEEL_KITESHIELD_8764, ItemID.STEEL_KITESHIELD_8766, ItemID.STEEL_KITESHIELD_8768,
                    ItemID.STEEL_KITESHIELD_8770, ItemID.STEEL_KITESHIELD_8772, ItemID.STEEL_KITESHIELD_8774,
                    ItemID.STEEL_KITESHIELD_8776

            });
            put(3, new Integer[]{
                    ItemID.BLACK_BOOTS, ItemID.BLACK_CHAINBODY, ItemID.BLACK_GLOVES, ItemID.BLACK_MED_HELM,
                    ItemID.BLACK_FULL_HELM, ItemID.BLACK_FULL_HELM_T, ItemID.BLACK_FULL_HELM_G,
                    ItemID.BLACK_KITESHIELD, ItemID.BLACK_KITESHIELD_T, ItemID.BLACK_KITESHIELD_G,
                    ItemID.BLACK_PLATEBODY, ItemID.BLACK_PLATEBODY_T, ItemID.BLACK_PLATEBODY_G,
                    ItemID.BLACK_PLATELEGS, ItemID.BLACK_PLATELEGS_T, ItemID.BLACK_PLATELEGS_G,
                    ItemID.BLACK_PLATESKIRT, ItemID.BLACK_PLATESKIRT_T, ItemID.BLACK_PLATESKIRT_G,
                    ItemID.BLACK_SQ_SHIELD,
                    ItemID.BLACK_HELM_H1, ItemID.BLACK_HELM_H2, ItemID.BLACK_HELM_H3, ItemID.BLACK_HELM_H4,
                    ItemID.BLACK_PLATEBODY_H1, ItemID.BLACK_PLATEBODY_H2, ItemID.BLACK_PLATEBODY_H3,
                    ItemID.BLACK_PLATEBODY_H4, ItemID.BLACK_PLATEBODY_H5,
                    ItemID.BLACK_SHIELD_H1, ItemID.BLACK_SHIELD_H2, ItemID.BLACK_SHIELD_H3,
                    ItemID.BLACK_SHIELD_H4,ItemID.BLACK_SHIELD_H5
            });
            put(4, new Integer[]{
                    ItemID.MITHRIL_BOOTS, ItemID.MITHRIL_CHAINBODY, ItemID.MITHRIL_GLOVES, ItemID.MITHRIL_MED_HELM,
                    ItemID.MITHRIL_FULL_HELM, ItemID.MITHRIL_FULL_HELM_T, ItemID.MITHRIL_FULL_HELM_G,
                    ItemID.MITHRIL_KITESHIELD, ItemID.MITHRIL_KITESHIELD_T, ItemID.MITHRIL_KITESHIELD_G,
                    ItemID.MITHRIL_PLATEBODY, ItemID.MITHRIL_PLATEBODY_T, ItemID.MITHRIL_PLATEBODY_G,
                    ItemID.MITHRIL_PLATELEGS, ItemID.MITHRIL_PLATELEGS_T, ItemID.MITHRIL_PLATELEGS_G,
                    ItemID.MITHRIL_PLATESKIRT, ItemID.MITHRIL_PLATESKIRT_T, ItemID.MITHRIL_PLATESKIRT_G,
                    ItemID.MITHRIL_SQ_SHIELD
            });
            put(5, new Integer[]{
                    ItemID.ADAMANT_BOOTS, ItemID.ADAMANT_CHAINBODY, ItemID.ADAMANT_GLOVES, ItemID.ADAMANT_MED_HELM,
                    ItemID.ADAMANT_FULL_HELM, ItemID.ADAMANT_FULL_HELM_T, ItemID.ADAMANT_FULL_HELM_G,
                    ItemID.ADAMANT_KITESHIELD, ItemID.ADAMANT_KITESHIELD_T, ItemID.ADAMANT_KITESHIELD_G,
                    ItemID.ADAMANT_PLATEBODY, ItemID.ADAMANT_PLATEBODY_T, ItemID.ADAMANT_PLATEBODY_G,
                    ItemID.ADAMANT_PLATELEGS, ItemID.ADAMANT_PLATELEGS_T, ItemID.ADAMANT_PLATELEGS_G,
                    ItemID.ADAMANT_PLATESKIRT, ItemID.ADAMANT_PLATESKIRT_T, ItemID.ADAMANT_PLATESKIRT_G,
                    ItemID.ADAMANT_SQ_SHIELD,
                    ItemID.ADAMANT_HELM_H1, ItemID.ADAMANT_HELM_H2, ItemID.ADAMANT_HELM_H3, ItemID.ADAMANT_HELM_H4,
                    ItemID.ADAMANT_PLATEBODY_H1, ItemID.ADAMANT_PLATEBODY_H2, ItemID.ADAMANT_PLATEBODY_H3,
                    ItemID.ADAMANT_PLATEBODY_H4, ItemID.ADAMANT_PLATEBODY_H5,
                    ItemID.ADAMANT_SHIELD_H1, ItemID.ADAMANT_SHIELD_H2, ItemID.ADAMANT_SHIELD_H3,
                    ItemID.ADAMANT_SHIELD_H4,ItemID.ADAMANT_SHIELD_H5,
                    ItemID.ADAMANT_KITESHIELD_6894, ItemID.ADAMANT_KITESHIELD_22127, ItemID.ADAMANT_KITESHIELD_22129,
                    ItemID.ADAMANT_KITESHIELD_22131, ItemID.ADAMANT_KITESHIELD_22133, ItemID.ADAMANT_KITESHIELD_22135,
                    ItemID.ADAMANT_KITESHIELD_22137, ItemID.ADAMANT_KITESHIELD_22139, ItemID.ADAMANT_KITESHIELD_22141,
                    ItemID.ADAMANT_KITESHIELD_22143, ItemID.ADAMANT_KITESHIELD_22145, ItemID.ADAMANT_KITESHIELD_22147,
                    ItemID.ADAMANT_KITESHIELD_22149, ItemID.ADAMANT_KITESHIELD_22151, ItemID.ADAMANT_KITESHIELD_22153,
                    ItemID.ADAMANT_KITESHIELD_22155, ItemID.ADAMANT_KITESHIELD_22157, ItemID.ADAMANT_HERALDIC_HELM,
                    ItemID.ADAMANT_HERALDIC_HELM_22161, ItemID.ADAMANT_HERALDIC_HELM_22163,
                    ItemID.ADAMANT_HERALDIC_HELM_22165, ItemID.ADAMANT_HERALDIC_HELM_22167,
                    ItemID.ADAMANT_HERALDIC_HELM_22169, ItemID.ADAMANT_HERALDIC_HELM_22171,
                    ItemID.ADAMANT_HERALDIC_HELM_22173, ItemID.ADAMANT_HERALDIC_HELM_22175,
                    ItemID.ADAMANT_HERALDIC_HELM_22177, ItemID.ADAMANT_HERALDIC_HELM_22179,
                    ItemID.ADAMANT_HERALDIC_HELM_22181, ItemID.ADAMANT_HERALDIC_HELM_22183,
                    ItemID.ADAMANT_HERALDIC_HELM_22185, ItemID.ADAMANT_HERALDIC_HELM_22187,
                    ItemID.ADAMANT_HERALDIC_HELM_22189
            });
            put(6, new Integer[]{
                    ItemID.RUNE_BOOTS, ItemID.RUNE_CHAINBODY, ItemID.RUNE_GLOVES, ItemID.RUNE_MED_HELM,
                    ItemID.RUNE_FULL_HELM, ItemID.RUNE_FULL_HELM_T, ItemID.RUNE_FULL_HELM_G,
                    ItemID.RUNE_KITESHIELD, ItemID.RUNE_KITESHIELD_T, ItemID.RUNE_KITESHIELD_G,
                    ItemID.RUNE_PLATEBODY, ItemID.RUNE_PLATEBODY_T, ItemID.RUNE_PLATEBODY_G,
                    ItemID.RUNE_PLATELEGS, ItemID.RUNE_PLATELEGS_T, ItemID.RUNE_PLATELEGS_G,
                    ItemID.RUNE_PLATESKIRT, ItemID.RUNE_PLATESKIRT_T, ItemID.RUNE_PLATESKIRT_G,
                    ItemID.RUNE_SQ_SHIELD,
                    ItemID.RUNE_HELM_H1, ItemID.RUNE_HELM_H2, ItemID.RUNE_HELM_H3, ItemID.RUNE_HELM_H4,
                    ItemID.RUNE_PLATEBODY_H1, ItemID.RUNE_PLATEBODY_H2, ItemID.RUNE_PLATEBODY_H3,
                    ItemID.RUNE_PLATEBODY_H4, ItemID.RUNE_PLATEBODY_H5,
                    ItemID.RUNE_SHIELD_H1, ItemID.RUNE_SHIELD_H2, ItemID.RUNE_SHIELD_H3,
                    ItemID.RUNE_SHIELD_H4,ItemID.RUNE_SHIELD_H5,
                    ItemID.RUNE_HERALDIC_HELM, ItemID.RUNE_HERALDIC_HELM_8466, ItemID.RUNE_HERALDIC_HELM_8468,
                    ItemID.RUNE_HERALDIC_HELM_8470, ItemID.RUNE_HERALDIC_HELM_8472, ItemID.RUNE_HERALDIC_HELM_8474,
                    ItemID.RUNE_HERALDIC_HELM_8476, ItemID.RUNE_HERALDIC_HELM_8478, ItemID.RUNE_HERALDIC_HELM_8480,
                    ItemID.RUNE_HERALDIC_HELM_8482, ItemID.RUNE_HERALDIC_HELM_8484, ItemID.RUNE_HERALDIC_HELM_8486,
                    ItemID.RUNE_HERALDIC_HELM_8488, ItemID.RUNE_HERALDIC_HELM_8490, ItemID.RUNE_HERALDIC_HELM_8492,
                    ItemID.RUNE_HERALDIC_HELM_8494, ItemID.RUNE_KITESHIELD_8714, ItemID.RUNE_KITESHIELD_8716,
                    ItemID.RUNE_KITESHIELD_8718, ItemID.RUNE_KITESHIELD_8720, ItemID.RUNE_KITESHIELD_8722,
                    ItemID.RUNE_KITESHIELD_8724, ItemID.RUNE_KITESHIELD_8726, ItemID.RUNE_KITESHIELD_8728,
                    ItemID.RUNE_KITESHIELD_8730, ItemID.RUNE_KITESHIELD_8732, ItemID.RUNE_KITESHIELD_8734,
                    ItemID.RUNE_KITESHIELD_8736, ItemID.RUNE_KITESHIELD_8738, ItemID.RUNE_KITESHIELD_8740,
                    ItemID.RUNE_KITESHIELD_8742, ItemID.RUNE_KITESHIELD_8744
            });
        }
    };

    public static final List<Integer> MetalArmorItemIds = new ArrayList<Integer>(){{
        for (int i=0;i<MetalArmorPermittedByTier.size();i++){
            Collections.addAll(this,MetalArmorPermittedByTier.get(i));
        }
    }};

    public static Map<Integer, Integer[]> RangeArmorPermittedByTier = new Hashtable<>() {
        {
            put(0, new Integer[]{ });
            put(1, new Integer[] {
                    ItemID.LEATHER_GLOVES, ItemID.LEATHER_BOOTS, ItemID.LEATHER_COWL,
                    ItemID.LEATHER_BODY, ItemID.LEATHER_BODY_G,
                    ItemID.LEATHER_CHAPS, ItemID.LEATHER_CHAPS_G
            });
            put(2, new Integer[] {
                    ItemID.STUDDED_BODY, ItemID.STUDDED_BODY_T, ItemID.STUDDED_BODY_G,
                    ItemID.STUDDED_CHAPS, ItemID.STUDDED_CHAPS_T, ItemID.STUDDED_CHAPS_G,
                    ItemID.COIF, ItemID.LEATHER_VAMBRACES, ItemID.STUDDED_BODY_26264,
            });
            put(3, new Integer[] {
                    ItemID.GREEN_DHIDE_BODY, ItemID.GREEN_DHIDE_BODY_T, ItemID.GREEN_DHIDE_BODY_G,
                    ItemID.GREEN_DHIDE_CHAPS, ItemID.GREEN_DHIDE_CHAPS_T, ItemID.GREEN_DHIDE_CHAPS_G,
                    ItemID.GREEN_DHIDE_SHIELD, ItemID.GREEN_DHIDE_VAMBRACES
            });
        }
    };

    public static final List<Integer> RangeArmorItemIds = new ArrayList<Integer>(){{
        for (int i=0;i<RangeArmorPermittedByTier.size();i++){
            Collections.addAll(this,RangeArmorPermittedByTier.get(i));
        }
    }};

    public static Map<Integer, Integer[]> RangeWeaponsPermittedByTier = new Hashtable<>() {
        {
            put(0, new Integer[] {
                    ItemID.BOW_AND_ARROW, ItemID.SHORTBOW, ItemID.LONGBOW,
                    ItemID.BRONZE_ARROW, ItemID.BRONZE_ARROW_11700, ItemID.BRONZE_ARROWP, ItemID.BRONZE_ARROWP_5616, ItemID.BRONZE_ARROWP_5622,
                    ItemID.IRON_ARROW, ItemID.IRON_ARROW_11701, ItemID.IRON_ARROWP, ItemID.IRON_ARROWP_5617, ItemID.IRON_ARROWP_5623
            });
            put(1, new Integer[] {
                    ItemID.OAK_SHORTBOW, ItemID.OAK_LONGBOW,
                    ItemID.STEEL_ARROW, ItemID.STEEL_ARROW_11702,
                    ItemID.STEEL_ARROWP, ItemID.STEEL_ARROWP_5618, ItemID.STEEL_ARROWP_5624
            });
            put(2, new Integer[] {
                    ItemID.WILLOW_SHORTBOW, ItemID.WILLOW_LONGBOW,
                    ItemID.MITHRIL_ARROW, ItemID.MITHRIL_ARROW_7552, ItemID.MITHRIL_ARROW_11703,
                    ItemID.MITHRIL_ARROWP, ItemID.MITHRIL_ARROWP_5619, ItemID.MITHRIL_ARROWP_5625
            });
            put(3, new Integer[] {
                    ItemID.MAPLE_SHORTBOW, ItemID.MAPLE_LONGBOW,
                    ItemID.ADAMANT_ARROW, ItemID.ADAMANT_ARROW_20388,
                    ItemID.ADAMANT_ARROWP, ItemID.ADAMANT_ARROWP_5620, ItemID.ADAMANT_ARROWP_5626
            });
        }};

    public static final List<Integer> RangeWeaponItemIds = new ArrayList<Integer>(){{
        for (int i=0;i<RangeWeaponsPermittedByTier.size();i++){
            Collections.addAll(this,RangeWeaponsPermittedByTier.get(i));
        }
    }};
}

package gg.archipelago;

import gg.archipelago.apEvents.ConnectionResult;
import gg.archipelago.apEvents.ReceiveItem;
import gg.archipelago.client.ArchipelagoClient;
import gg.archipelago.client.ItemFlags;
import gg.archipelago.client.Print.APPrint;
import gg.archipelago.client.Print.APPrintPart;
import gg.archipelago.client.parts.NetworkItem;
import lombok.extern.slf4j.Slf4j;

import java.net.URISyntaxException;

@Slf4j
public class OSRSClient  extends ArchipelagoClient {

    private ArchipelagoPlugin plugin;

    public OSRSClient(ArchipelagoPlugin plugin){
        this.plugin = plugin;
    }

    public void newConnection(ArchipelagoPlugin plugin, String address, String slotName, String password) {
        setGame("Old School Runescape");
        setPassword(password);
        setName(slotName);
        setItemsHandlingFlags(ItemFlags.SEND_ITEMS + ItemFlags.SEND_OWN_ITEMS + ItemFlags.SEND_STARTING_INVENTORY);

        getEventManager().registerListener(new ConnectionResult());
        getEventManager().registerListener(new ReceiveItem());

        try {
            connect(address);
        } catch (URISyntaxException e) {
            e.printStackTrace();
        }
    }

    private OSRSClient() {
        super();
        this.setGame("Old School Runescape");
    }

    @Override
    public void onPrint(String s) {

    }

    @Override
    public void onPrintJson(APPrint apPrint, String s, int i, NetworkItem networkItem) {
        if ("Join".equals(apPrint.type) || "Tutorial".equals(apPrint.type)) return;
        StringBuilder msgBuilder = new StringBuilder();
        for (APPrintPart part : apPrint.parts){
            msgBuilder.append(part.text);
        }
        plugin.DisplayChatMessage(msgBuilder.toString());
    }

    @Override
    public void onError(Exception e) {
        ArchipelagoPlugin.plugin.DisplayNetworkMessage("Server Error: " + e.getMessage());
    }

    @Override
    public void onClose(String message, int i) {
        //ArchipelagoPanel.apPanel.statusText.setText("Connection Closed NL " + message);
    }

    @Override
    public void disconnect(){
        super.disconnect();
        plugin.SetConnectionState(false);
    }
}

