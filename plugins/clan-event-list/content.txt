package com.claneventlist;

import lombok.Data;
import lombok.AllArgsConstructor;
import lombok.NoArgsConstructor;

import java.time.LocalDateTime;
import java.time.LocalTime;
import java.time.ZoneId;
import java.time.format.DateTimeFormatter;
import java.time.temporal.ChronoUnit;

/**
 * Represents a clan event fetched from the Google Sheet.
 * 
 * Expected columns: Event Name, Description, Date, Start Time, End Time, Host, Location, URL
 */
@Data
@AllArgsConstructor
@NoArgsConstructor
public class ClanEvent implements Comparable<ClanEvent>
{
    private String name;
    private String description;
    private LocalDateTime dateTime;      // Start date/time
    private LocalTime endTime;           // End time (same day)
    private String host;
    private String location;
    private String url;                  // Link to more info / signup

    private static final DateTimeFormatter DISPLAY_FORMAT = DateTimeFormatter.ofPattern("MMM dd, yyyy 'at' HH:mm");
    private static final DateTimeFormatter SHORT_FORMAT = DateTimeFormatter.ofPattern("MMM dd HH:mm");
    private static final DateTimeFormatter TIME_ONLY = DateTimeFormatter.ofPattern("HH:mm");
    private static final DateTimeFormatter DAY_FORMAT = DateTimeFormatter.ofPattern("EEE, MMM dd");
    
    private static final ZoneId UTC = ZoneId.of("UTC");
    private static final ZoneId LOCAL = ZoneId.systemDefault();
    
    /**
     * Converts the stored UTC dateTime to local timezone.
     */
    private LocalDateTime getLocalDateTime()
    {
        if (dateTime == null)
        {
            return null;
        }
        return dateTime.atZone(UTC).withZoneSameInstant(LOCAL).toLocalDateTime();
    }
    
    /**
     * Converts the stored UTC endTime to local timezone.
     */
    private LocalTime getLocalEndTime()
    {
        if (endTime == null || dateTime == null)
        {
            return null;
        }
        // Create a full datetime for the end time using same date as start
        LocalDateTime endDateTime = dateTime.toLocalDate().atTime(endTime);
        return endDateTime.atZone(UTC).withZoneSameInstant(LOCAL).toLocalTime();
    }

    /**
     * Returns a formatted string of the event date/time in local timezone.
     */
    public String getFormattedDateTime()
    {
        LocalDateTime local = getLocalDateTime();
        if (local == null)
        {
            return "TBD";
        }
        return local.format(DISPLAY_FORMAT);
    }

    /**
     * Returns a short formatted string of the event date/time in local timezone.
     */
    public String getShortDateTime()
    {
        LocalDateTime local = getLocalDateTime();
        if (local == null)
        {
            return "TBD";
        }
        return local.format(SHORT_FORMAT);
    }

    /**
     * Returns just the day (e.g., "Mon, Dec 15") in local timezone.
     */
    public String getDayString()
    {
        LocalDateTime local = getLocalDateTime();
        if (local == null)
        {
            return "TBD";
        }
        return local.format(DAY_FORMAT);
    }

    /**
     * Returns the time range (e.g., "20:00 - 22:00" or just "20:00") in local timezone.
     */
    public String getTimeRange()
    {
        LocalDateTime local = getLocalDateTime();
        if (local == null)
        {
            return "TBD";
        }
        String start = local.format(TIME_ONLY);
        LocalTime localEnd = getLocalEndTime();
        if (localEnd != null)
        {
            return start + " - " + localEnd.format(TIME_ONLY);
        }
        return start;
    }

    /**
     * Returns the duration string if end time is set.
     */
    public String getDuration()
    {
        if (dateTime == null || endTime == null)
        {
            return null;
        }
        
        LocalTime startTime = dateTime.toLocalTime();
        long minutes = ChronoUnit.MINUTES.between(startTime, endTime);
        
        // Handle overnight events
        if (minutes < 0)
        {
            minutes += 24 * 60;
        }
        
        long hours = minutes / 60;
        long mins = minutes % 60;
        
        if (hours > 0 && mins > 0)
        {
            return hours + "h " + mins + "m";
        }
        else if (hours > 0)
        {
            return hours + "h";
        }
        else
        {
            return mins + "m";
        }
    }

    /**
     * Gets the current time in UTC for comparisons with stored dateTime.
     */
    private LocalDateTime nowUtc()
    {
        return LocalDateTime.now(UTC);
    }

    /**
     * Returns a human-readable time until the event.
     */
    public String getTimeUntil()
    {
        if (dateTime == null)
        {
            return "Unknown";
        }

        LocalDateTime now = nowUtc();
        if (dateTime.isBefore(now))
        {
            return "Started";
        }

        long days = ChronoUnit.DAYS.between(now, dateTime);
        long hours = ChronoUnit.HOURS.between(now, dateTime) % 24;
        long minutes = ChronoUnit.MINUTES.between(now, dateTime) % 60;

        if (days > 0)
        {
            return days + "d " + hours + "h";
        }
        else if (hours > 0)
        {
            return hours + "h " + minutes + "m";
        }
        else
        {
            return minutes + "m";
        }
    }

    /**
     * Checks if this event has a URL.
     */
    public boolean hasUrl()
    {
        return url != null && !url.trim().isEmpty();
    }

    /**
     * Checks if this event is in the future.
     */
    public boolean isUpcoming()
    {
        return dateTime != null && dateTime.isAfter(nowUtc());
    }

    /**
     * Checks if this event is currently happening.
     */
    public boolean isHappeningNow()
    {
        if (dateTime == null)
        {
            return false;
        }
        LocalDateTime now = nowUtc();
        LocalDateTime end = endTime != null 
            ? dateTime.toLocalDate().atTime(endTime) 
            : dateTime.plusHours(2); // Assume 2 hour default
            
        return now.isAfter(dateTime) && now.isBefore(end);
    }

    /**
     * Checks if this event is happening today (in local timezone).
     */
    public boolean isToday()
    {
        LocalDateTime local = getLocalDateTime();
        if (local == null)
        {
            return false;
        }
        LocalDateTime now = LocalDateTime.now();
        return local.toLocalDate().equals(now.toLocalDate());
    }

    /**
     * Checks if this event is happening within the next hour.
     */
    public boolean isImminent()
    {
        if (dateTime == null)
        {
            return false;
        }
        LocalDateTime now = nowUtc();
        long minutes = ChronoUnit.MINUTES.between(now, dateTime);
        return minutes >= 0 && minutes <= 60;
    }

    @Override
    public int compareTo(ClanEvent other)
    {
        if (this.dateTime == null && other.dateTime == null)
        {
            return 0;
        }
        if (this.dateTime == null)
        {
            return 1;
        }
        if (other.dateTime == null)
        {
            return -1;
        }
        return this.dateTime.compareTo(other.dateTime);
    }
}


package com.claneventlist;

import net.runelite.client.config.Config;
import net.runelite.client.config.ConfigGroup;
import net.runelite.client.config.ConfigItem;
import net.runelite.client.config.ConfigSection;
import net.runelite.client.config.Range;

import java.awt.Color;

@ConfigGroup(EventListConfig.CONFIG_GROUP)
public interface EventListConfig extends Config
{
    String CONFIG_GROUP = "claneventlist";

    @ConfigSection(
        name = "Google Sheet",
        description = "Configure Google Sheet data source",
        position = 0
    )
    String sheetSection = "sheetSection";

    @ConfigSection(
        name = "Overlay",
        description = "Configure overlay appearance",
        position = 1
    )
    String overlaySection = "overlaySection";

    @ConfigSection(
        name = "Panel",
        description = "Configure panel settings",
        position = 2
    )
    String panelSection = "panelSection";

    // ========== Google Sheet Settings ==========

    @ConfigItem(
        keyName = "sheetId",
        name = "Google Sheet ID",
        description = "The ID from your Google Sheet URL (the long string between /d/ and /edit)",
        section = sheetSection,
        position = 0
    )
    default String sheetId()
    {
        return "";
    }

    @ConfigItem(
        keyName = "sheetName",
        name = "Sheet Tab Name",
        description = "The name of the specific sheet/tab to read from (leave empty for first sheet)",
        section = sheetSection,
        position = 1
    )
    default String sheetName()
    {
        return "";
    }

    @ConfigItem(
        keyName = "refreshInterval",
        name = "Refresh Interval (min)",
        description = "How often to refresh event data from the sheet (in minutes)",
        section = sheetSection,
        position = 2
    )
    @Range(min = 1, max = 60)
    default int refreshInterval()
    {
        return 60;
    }

    // ========== Overlay Settings ==========

    @ConfigItem(
        keyName = "showOverlay",
        name = "Show Overlay",
        description = "Display the next event overlay on the game screen",
        section = overlaySection,
        position = 0
    )
    default boolean showOverlay()
    {
        return true;
    }

    @ConfigItem(
        keyName = "overlayBackgroundColor",
        name = "Background Color",
        description = "Background color of the overlay",
        section = overlaySection,
        position = 1
    )
    default Color overlayBackgroundColor()
    {
        return new Color(30, 30, 30, 200);
    }

    @ConfigItem(
        keyName = "overlayTextColor",
        name = "Text Color",
        description = "Text color for the overlay",
        section = overlaySection,
        position = 2
    )
    default Color overlayTextColor()
    {
        return Color.WHITE;
    }

    @ConfigItem(
        keyName = "overlayAccentColor",
        name = "Accent Color",
        description = "Accent color for event name and highlights",
        section = overlaySection,
        position = 3
    )
    default Color overlayAccentColor()
    {
        return new Color(255, 200, 0);
    }

    @ConfigItem(
        keyName = "imminentColor",
        name = "Imminent Event Color",
        description = "Color when event is within 1 hour",
        section = overlaySection,
        position = 4
    )
    default Color imminentColor()
    {
        return new Color(255, 100, 100);
    }

    @ConfigItem(
        keyName = "activeColor",
        name = "Active Event Color",
        description = "Color for currently happening events",
        section = overlaySection,
        position = 5
    )
    default Color activeColor()
    {
        return new Color(100, 255, 100);
    }

    @ConfigItem(
        keyName = "simpleOverlay",
        name = "Simple Overlay",
        description = "Use compact overlay (just event name and time, no titles)",
        section = overlaySection,
        position = 6
    )
    default boolean simpleOverlay()
    {
        return false;
    }

    // ========== Panel Settings ==========

    @ConfigItem(
        keyName = "maxEventsShown",
        name = "Max Events Shown",
        description = "Maximum number of events to show in the panel (scroll for more)",
        section = panelSection,
        position = 0
    )
    @Range(min = 1, max = 50)
    default int maxEventsInPanel()
    {
        return 10;
    }

    @ConfigItem(
        keyName = "showPastEvents",
        name = "Show Past Events",
        description = "Include events that have already passed",
        section = panelSection,
        position = 1
    )
    default boolean showPastEvents()
    {
        return false;
    }
}


package com.claneventlist;

import net.runelite.client.ui.overlay.Overlay;
import net.runelite.client.ui.overlay.OverlayLayer;
import net.runelite.client.ui.overlay.OverlayPosition;
import net.runelite.client.ui.overlay.components.LineComponent;
import net.runelite.client.ui.overlay.components.PanelComponent;
import net.runelite.client.ui.overlay.components.TitleComponent;

import javax.inject.Inject;
import java.awt.Color;
import java.awt.Dimension;
import java.awt.Graphics2D;

/**
 * Overlay that displays clan events with dynamic sizing.
 * Supports both verbose and simple modes.
 */
public class EventListOverlay extends Overlay
{
    private final EventListConfig config;
    private final GoogleSheetService sheetService;
    private final PanelComponent panelComponent = new PanelComponent();

    @Inject
    public EventListOverlay(EventListConfig config, GoogleSheetService sheetService)
    {
        this.config = config;
        this.sheetService = sheetService;

        setPosition(OverlayPosition.TOP_LEFT);
        setLayer(OverlayLayer.ABOVE_WIDGETS);
        setMovable(true);
        setResizable(true);
    }

    @Override
    public Dimension render(Graphics2D graphics)
    {
        if (!config.showOverlay())
        {
            return null;
        }

        ClanEvent activeEvent = sheetService.getActiveEvent();
        ClanEvent nextEvent = sheetService.getNextEvent();
        
        // Nothing to show if no active or upcoming events
        if (activeEvent == null && nextEvent == null)
        {
            return null;
        }

        panelComponent.getChildren().clear();
        panelComponent.setBackgroundColor(config.overlayBackgroundColor());
        
        // Use resized width if available, otherwise default
        Dimension size = getPreferredSize();
        int width = (size != null && size.width > 0) ? size.width : 180;
        panelComponent.setPreferredSize(new Dimension(width, 0));
        
        // Calculate how many chars fit per line
        int charsPerLine = Math.max(15, width / 7);

        if (config.simpleOverlay())
        {
            renderSimple(activeEvent, nextEvent, charsPerLine);
        }
        else
        {
            renderVerbose(activeEvent, nextEvent, charsPerLine);
        }

        return panelComponent.render(graphics);
    }

    /**
     * Simple overlay: just labels and times, no event names
     */
    private void renderSimple(ClanEvent activeEvent, ClanEvent nextEvent, int charsPerLine)
    {
        // Title
        panelComponent.getChildren().add(TitleComponent.builder()
            .text("Clan Events")
            .color(config.overlayAccentColor())
            .build());

        // Show current event if one is happening
        if (activeEvent != null)
        {
            panelComponent.getChildren().add(LineComponent.builder()
                .left("Current Event")
                .leftColor(config.activeColor())
                .right("NOW")
                .rightColor(config.activeColor())
                .build());
        }

        // Show next upcoming event
        if (nextEvent != null && (activeEvent == null || !nextEvent.equals(activeEvent)))
        {
            Color labelColor = nextEvent.isImminent() ? config.imminentColor() : config.overlayAccentColor();
            Color timeColor = nextEvent.isImminent() ? config.imminentColor() : config.overlayTextColor();
            
            panelComponent.getChildren().add(LineComponent.builder()
                .left("Next Event")
                .leftColor(labelColor)
                .right(nextEvent.getTimeUntil())
                .rightColor(timeColor)
                .build());
        }
    }

    /**
     * Verbose overlay: titles, multi-line names, separate countdown
     */
    private void renderVerbose(ClanEvent activeEvent, ClanEvent nextEvent, int charsPerLine)
    {
        // Show active event if one is happening
        if (activeEvent != null)
        {
            panelComponent.getChildren().add(TitleComponent.builder()
                .text("Active Event")
                .color(config.activeColor())
                .build());

            // Add event name - split into multiple lines if needed
            addWrappedName(activeEvent.getName(), config.overlayTextColor(), charsPerLine);

            panelComponent.getChildren().add(LineComponent.builder()
                .left("NOW!")
                .leftColor(config.activeColor())
                .build());
        }

        // Show next upcoming event (if different from active)
        if (nextEvent != null && (activeEvent == null || !nextEvent.equals(activeEvent)))
        {
            // Add spacing if we showed an active event
            if (activeEvent != null)
            {
                panelComponent.getChildren().add(LineComponent.builder()
                    .left("")
                    .build());
            }

            Color accentColor = nextEvent.isImminent() ? config.imminentColor() : config.overlayAccentColor();
            Color timeColor = nextEvent.isImminent() ? config.imminentColor() : config.overlayTextColor();

            panelComponent.getChildren().add(TitleComponent.builder()
                .text("Next Event")
                .color(accentColor)
                .build());

            // Add event name - split into multiple lines if needed
            addWrappedName(nextEvent.getName(), config.overlayTextColor(), charsPerLine);

            panelComponent.getChildren().add(LineComponent.builder()
                .left(nextEvent.getTimeUntil())
                .leftColor(timeColor)
                .build());
        }
    }

    /**
     * Adds the event name to the panel, wrapping to multiple lines if needed.
     */
    private void addWrappedName(String name, Color color, int charsPerLine)
    {
        if (name == null || name.isEmpty())
        {
            return;
        }

        // Split name into lines that fit the width
        int maxLines = 3; // Limit to 3 lines max
        int currentLine = 0;
        int start = 0;
        
        while (start < name.length() && currentLine < maxLines)
        {
            int end = Math.min(start + charsPerLine, name.length());
            
            // Try to break at a space if we're not at the end
            if (end < name.length() && name.charAt(end) != ' ')
            {
                int lastSpace = name.lastIndexOf(' ', end);
                if (lastSpace > start)
                {
                    end = lastSpace;
                }
            }
            
            String line = name.substring(start, end).trim();
            
            // Add ellipsis if we're truncating
            if (currentLine == maxLines - 1 && end < name.length())
            {
                line = line + "...";
            }
            
            panelComponent.getChildren().add(LineComponent.builder()
                .left(line)
                .leftColor(color)
                .build());
            
            start = end;
            // Skip the space we broke at
            if (start < name.length() && name.charAt(start) == ' ')
            {
                start++;
            }
            currentLine++;
        }
    }

    /**
     * Truncates a string to the specified length with ellipsis.
     */
    private String truncate(String text, int maxLength)
    {
        if (text == null)
        {
            return "";
        }
        if (text.length() <= maxLength)
        {
            return text;
        }
        return text.substring(0, maxLength - 3) + "...";
    }
}

package com.claneventlist;

import lombok.extern.slf4j.Slf4j;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.FontManager;
import net.runelite.client.ui.PluginPanel;
import net.runelite.client.util.LinkBrowser;

import javax.swing.*;
import javax.swing.border.EmptyBorder;
import java.awt.*;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.util.List;

/**
 * Side panel that displays a list of all clan events.
 */
@Slf4j
public class EventListPanel extends PluginPanel
{
    private static final Color BACKGROUND_COLOR = ColorScheme.DARK_GRAY_COLOR;
    private static final Color PANEL_COLOR = ColorScheme.DARKER_GRAY_COLOR;
    private static final Color HOVER_COLOR = ColorScheme.DARK_GRAY_HOVER_COLOR;
    private static final Color ACCENT_COLOR = new Color(255, 200, 0);
    private static final Color IMMINENT_COLOR = new Color(255, 100, 100);
    private static final Color HAPPENING_COLOR = new Color(100, 255, 100);
    private static final Color LINK_COLOR = new Color(100, 180, 255);
    private static final Color TEXT_COLOR = Color.WHITE;
    private static final Color SECONDARY_TEXT = ColorScheme.LIGHT_GRAY_COLOR;
    
    private static final int EVENT_SPACING = 8;
    private static final int MAX_DESC_LENGTH = 400;
    // RuneLite panel is ~225px usable, minus padding = content width
    private static final int CONTENT_WIDTH = 205;
    private static final int TEXT_WIDTH = 140; // Text wrap width (account for emoji + padding + borders)
    
    private static boolean DEBUG_SIZES = false;

    private final EventListConfig config;
    private final GoogleSheetService sheetService;
    private final Runnable refreshCallback;

    private JPanel eventsContainer;
    private JLabel statusLabel;
    private JLabel lastUpdateLabel;

    public EventListPanel(EventListConfig config, GoogleSheetService sheetService, Runnable refreshCallback)
    {
        super(false); // Don't wrap content - we handle our own scrolling
        
        this.config = config;
        this.sheetService = sheetService;
        this.refreshCallback = refreshCallback;

        setLayout(new BorderLayout());
        setBackground(BACKGROUND_COLOR);

        add(createHeaderPanel(), BorderLayout.NORTH);
        add(createContentPanel(), BorderLayout.CENTER);
        add(createFooterPanel(), BorderLayout.SOUTH);
    }

    private JPanel createHeaderPanel()
    {
        JPanel headerPanel = new JPanel(new BorderLayout());
        headerPanel.setBackground(BACKGROUND_COLOR);
        headerPanel.setBorder(new EmptyBorder(8, 8, 8, 8));

        // Title
        JLabel titleLabel = new JLabel("Clan Events");
        titleLabel.setFont(FontManager.getRunescapeBoldFont().deriveFont(16f));
        titleLabel.setForeground(ACCENT_COLOR);
        headerPanel.add(titleLabel, BorderLayout.WEST);

        // Refresh button
        JButton refreshButton = new JButton("‚Üª");
        refreshButton.setFont(FontManager.getRunescapeBoldFont().deriveFont(14f));
        refreshButton.setForeground(TEXT_COLOR);
        refreshButton.setBackground(PANEL_COLOR);
        refreshButton.setBorder(new EmptyBorder(5, 10, 5, 10));
        refreshButton.setFocusPainted(false);
        refreshButton.setCursor(Cursor.getPredefinedCursor(Cursor.HAND_CURSOR));
        refreshButton.setToolTipText("Refresh events from Google Sheet");
        refreshButton.addActionListener(e -> {
            if (refreshCallback != null)
            {
                refreshCallback.run();
            }
        });
        refreshButton.addMouseListener(new MouseAdapter()
        {
            @Override
            public void mouseEntered(MouseEvent e)
            {
                refreshButton.setBackground(HOVER_COLOR);
            }

            @Override
            public void mouseExited(MouseEvent e)
            {
                refreshButton.setBackground(PANEL_COLOR);
            }
        });
        headerPanel.add(refreshButton, BorderLayout.EAST);

        return headerPanel;
    }

    private JScrollPane createContentPanel()
    {
        // Use BoxLayout for the events container - it respects max sizes
        eventsContainer = new JPanel();
        eventsContainer.setLayout(new BoxLayout(eventsContainer, BoxLayout.Y_AXIS));
        eventsContainer.setBackground(BACKGROUND_COLOR);
        eventsContainer.setBorder(new EmptyBorder(0, 8, 0, 8));

        JScrollPane scrollPane = new JScrollPane(eventsContainer);
        scrollPane.setBackground(BACKGROUND_COLOR);
        scrollPane.getViewport().setBackground(BACKGROUND_COLOR);
        scrollPane.setBorder(null);
        scrollPane.setHorizontalScrollBarPolicy(JScrollPane.HORIZONTAL_SCROLLBAR_NEVER);
        scrollPane.setVerticalScrollBarPolicy(JScrollPane.VERTICAL_SCROLLBAR_AS_NEEDED);
        scrollPane.getVerticalScrollBar().setUnitIncrement(16);

        return scrollPane;
    }

    private JPanel createFooterPanel()
    {
        JPanel footerPanel = new JPanel(new BorderLayout());
        footerPanel.setBackground(BACKGROUND_COLOR);
        footerPanel.setBorder(new EmptyBorder(8, 8, 8, 8));

        statusLabel = new JLabel("Loading...");
        statusLabel.setFont(FontManager.getRunescapeSmallFont());
        statusLabel.setForeground(SECONDARY_TEXT);
        footerPanel.add(statusLabel, BorderLayout.WEST);

        lastUpdateLabel = new JLabel("");
        lastUpdateLabel.setFont(FontManager.getRunescapeSmallFont());
        lastUpdateLabel.setForeground(SECONDARY_TEXT);
        footerPanel.add(lastUpdateLabel, BorderLayout.EAST);

        return footerPanel;
    }

    /**
     * Updates the panel with the latest events.
     */
    public void updateEvents()
    {
        SwingUtilities.invokeLater(() -> {
            eventsContainer.removeAll();

            List<ClanEvent> events;
            if (config.showPastEvents())
            {
                events = sheetService.getCachedEvents();
            }
            else
            {
                events = sheetService.getUpcomingEvents();
            }

            int maxEvents = config.maxEventsInPanel();
            int displayCount = Math.min(events.size(), maxEvents);

            if (events.isEmpty())
            {
                JLabel noEventsLabel = new JLabel("No upcoming events");
                noEventsLabel.setFont(FontManager.getRunescapeFont());
                noEventsLabel.setForeground(SECONDARY_TEXT);
                noEventsLabel.setAlignmentX(Component.CENTER_ALIGNMENT);
                noEventsLabel.setBorder(new EmptyBorder(20, 0, 10, 0));
                eventsContainer.add(noEventsLabel);

                if (config.sheetId().isEmpty())
                {
                    JLabel configLabel = new JLabel("<html><center>Configure your Google Sheet ID<br>in the plugin settings</center></html>");
                    configLabel.setFont(FontManager.getRunescapeSmallFont());
                    configLabel.setForeground(SECONDARY_TEXT);
                    configLabel.setAlignmentX(Component.CENTER_ALIGNMENT);
                    eventsContainer.add(configLabel);
                }
            }
            else
            {
                // Get the highlighted event (active or next upcoming)
                ClanEvent highlightedEvent = sheetService.getHighlightedEvent();
                ClanEvent activeEvent = sheetService.getActiveEvent();
                
                // Show active event section at the top if there's one happening
                if (activeEvent != null)
                {
                    // Active event header
                    JLabel activeHeader = new JLabel("‚óè ACTIVE EVENT");
                    activeHeader.setFont(FontManager.getRunescapeBoldFont());
                    activeHeader.setForeground(HAPPENING_COLOR);
                    activeHeader.setAlignmentX(Component.LEFT_ALIGNMENT);
                    eventsContainer.add(activeHeader);
                    eventsContainer.add(Box.createVerticalStrut(4));
                    
                    eventsContainer.add(createEventPanel(activeEvent, true));
                    eventsContainer.add(Box.createVerticalStrut(EVENT_SPACING));
                    
                    // Separator
                    JSeparator separator = new JSeparator();
                    separator.setForeground(SECONDARY_TEXT);
                    separator.setMaximumSize(new Dimension(CONTENT_WIDTH, 2));
                    separator.setAlignmentX(Component.LEFT_ALIGNMENT);
                    eventsContainer.add(separator);
                    eventsContainer.add(Box.createVerticalStrut(8));
                    
                    // Upcoming events header
                    JLabel upcomingHeader = new JLabel("UPCOMING");
                    upcomingHeader.setFont(FontManager.getRunescapeBoldFont());
                    upcomingHeader.setForeground(ACCENT_COLOR);
                    upcomingHeader.setAlignmentX(Component.LEFT_ALIGNMENT);
                    eventsContainer.add(upcomingHeader);
                    eventsContainer.add(Box.createVerticalStrut(EVENT_SPACING));
                }
                
                for (int i = 0; i < displayCount; i++)
                {
                    ClanEvent event = events.get(i);
                    
                    // Skip active event in the main list since it's shown at top
                    if (activeEvent != null && event.equals(activeEvent))
                    {
                        continue;
                    }
                    
                    // Highlight if this is the next upcoming event (not active, since active is shown separately)
                    boolean isHighlighted = activeEvent == null && highlightedEvent != null && event.equals(highlightedEvent);
                    eventsContainer.add(createEventPanel(event, isHighlighted));
                    
                    // Add spacing between events (not after the last one)
                    if (i < displayCount - 1)
                    {
                        eventsContainer.add(Box.createVerticalStrut(EVENT_SPACING));
                    }
                }

                if (events.size() > maxEvents)
                {
                    eventsContainer.add(Box.createVerticalStrut(EVENT_SPACING));
                    
                    JLabel moreLabel = new JLabel("+" + (events.size() - maxEvents) + " more events");
                    moreLabel.setFont(FontManager.getRunescapeSmallFont());
                    moreLabel.setForeground(SECONDARY_TEXT);
                    moreLabel.setAlignmentX(Component.CENTER_ALIGNMENT);
                    eventsContainer.add(moreLabel);
                }
            }

            // Add vertical glue to push content to top
            eventsContainer.add(Box.createVerticalGlue());

            // Update status
            statusLabel.setText(events.size() + " event" + (events.size() != 1 ? "s" : ""));

            // Update last fetch time
            long lastFetch = sheetService.getLastFetchTime();
            if (lastFetch > 0)
            {
                long minutesAgo = (System.currentTimeMillis() - lastFetch) / 60000;
                if (minutesAgo < 1)
                {
                    lastUpdateLabel.setText("Just now");
                }
                else
                {
                    lastUpdateLabel.setText(minutesAgo + "m ago");
                }
            }
            else
            {
                lastUpdateLabel.setText("Not synced");
            }

            eventsContainer.revalidate();
            eventsContainer.repaint();
            
            // Debug sizes after layout
            if (DEBUG_SIZES)
            {
                SwingUtilities.invokeLater(() -> {
                    log.info("=== DEBUG SIZES ===");
                    log.info("Panel width: {}, Content width constant: {}, Text width constant: {}", 
                        EventListPanel.this.getWidth(), CONTENT_WIDTH, TEXT_WIDTH);
                    log.info("EventsContainer size: {}x{}", eventsContainer.getWidth(), eventsContainer.getHeight());
                    log.info("EventsContainer preferred: {}x{}", 
                        eventsContainer.getPreferredSize().width, eventsContainer.getPreferredSize().height);
                    
                    for (int i = 0; i < eventsContainer.getComponentCount(); i++)
                    {
                        Component c = eventsContainer.getComponent(i);
                        log.info("Component {}: {} - size: {}x{}, preferred: {}x{}, min: {}x{}, max: {}x{}", 
                            i, c.getClass().getSimpleName(),
                            c.getWidth(), c.getHeight(),
                            c.getPreferredSize().width, c.getPreferredSize().height,
                            c.getMinimumSize().width, c.getMinimumSize().height,
                            c.getMaximumSize().width, c.getMaximumSize().height);
                    }
                    log.info("===================");
                });
            }
        });
    }

    private JPanel createEventPanel(ClanEvent event, boolean isNext)
    {
        JPanel eventPanel = new JPanel();
        eventPanel.setLayout(new BoxLayout(eventPanel, BoxLayout.Y_AXIS));
        eventPanel.setBackground(PANEL_COLOR);
        eventPanel.setBorder(new EmptyBorder(8, 8, 8, 8));
        eventPanel.setAlignmentX(Component.LEFT_ALIGNMENT);
        
        // Constrain event panel width - BoxLayout respects this
        eventPanel.setMaximumSize(new Dimension(CONTENT_WIDTH, Short.MAX_VALUE));

        // Determine status and colors
        boolean isHappening = event.isHappeningNow();
        boolean isImminent = event.isImminent();
        
        Color borderColor = null;
        if (isHappening)
        {
            borderColor = HAPPENING_COLOR;
        }
        else if (isImminent)
        {
            borderColor = IMMINENT_COLOR;
        }
        else if (isNext)
        {
            borderColor = ACCENT_COLOR;
        }

        // Apply border
        if (borderColor != null)
        {
            eventPanel.setBorder(BorderFactory.createCompoundBorder(
                BorderFactory.createLineBorder(borderColor, 2),
                new EmptyBorder(6, 6, 6, 6)
            ));
        }

        // === EVENT NAME (wraps to multiple lines, max ~60 chars) ===
        String name = event.getName();
        String displayName = name;
        // Limit characters but allow word wrap for 2+ lines
        int maxNameChars = 60;
        if (name.length() > maxNameChars)
        {
            displayName = name.substring(0, maxNameChars) + "...";
        }
        
        String nameColor;
        if (isHappening)
        {
            nameColor = "#64ff64";
        }
        else if (isImminent)
        {
            nameColor = "#ff6464";
        }
        else if (isNext)
        {
            nameColor = "#ffc800";
        }
        else
        {
            nameColor = "#ffffff";
        }
        // Use word-wrap to allow multi-line names
        JLabel nameLabel = new JLabel("<html><div style='width: " + TEXT_WIDTH + "px; word-wrap: break-word'>" + 
            "<span style='color: " + nameColor + "'>" + escapeHtml(displayName) + "</span></div></html>");
        nameLabel.setFont(FontManager.getRunescapeBoldFont().deriveFont(14f));
        nameLabel.setToolTipText(name); // Full name in tooltip
        nameLabel.setAlignmentX(Component.LEFT_ALIGNMENT);
        eventPanel.add(nameLabel);
        eventPanel.add(Box.createVerticalStrut(8));

        // HTML style for emoji-compatible line height
        String emojiStyle = "style='width: " + TEXT_WIDTH + "px; line-height: 1.4; padding-top: 2px'";

        // === DATE ===
        JLabel dateLabel = new JLabel("<html><body " + emojiStyle + ">" +
            "üìÖ <span style='color: #b0b0b0'>Date:</span> " + 
            "<span style='color: " + (event.isToday() ? "#64c864" : "#ffffff") + "'>" + 
            escapeHtml(event.getDayString()) + "</span></body></html>");
        dateLabel.setFont(FontManager.getRunescapeSmallFont());
        dateLabel.setAlignmentX(Component.LEFT_ALIGNMENT);
        eventPanel.add(dateLabel);
        eventPanel.add(Box.createVerticalStrut(4));

        // === TIME ===
        String timeText = event.getTimeRange();
        String duration = event.getDuration();
        if (duration != null)
        {
            timeText += " (" + duration + ")";
        }
        JLabel timeLabel = new JLabel("<html><body " + emojiStyle + ">" +
            "üïê <span style='color: #b0b0b0'>Time:</span> " + 
            "<span style='color: #ffffff'>" + escapeHtml(timeText) + "</span></body></html>");
        timeLabel.setFont(FontManager.getRunescapeSmallFont());
        timeLabel.setAlignmentX(Component.LEFT_ALIGNMENT);
        eventPanel.add(timeLabel);
        eventPanel.add(Box.createVerticalStrut(4));

        // === HOST ===
        boolean hasHost = event.getHost() != null && !event.getHost().isEmpty();
        if (hasHost)
        {
            JLabel hostLabel = new JLabel("<html><body " + emojiStyle + ">" +
                "üì£ <span style='color: #b0b0b0'>Host:</span> " + 
                "<span style='color: #ffffff'>" + escapeHtml(event.getHost()) + "</span></body></html>");
            hostLabel.setFont(FontManager.getRunescapeSmallFont());
            hostLabel.setAlignmentX(Component.LEFT_ALIGNMENT);
            eventPanel.add(hostLabel);
            eventPanel.add(Box.createVerticalStrut(4));
        }

        // === LOCATION ===
        boolean hasLocation = event.getLocation() != null && !event.getLocation().isEmpty();
        if (hasLocation)
        {
            JLabel locationLabel = new JLabel("<html><body " + emojiStyle + ">" +
                "üìç <span style='color: #b0b0b0'>Location:</span> " + 
                "<span style='color: #ffffff'>" + escapeHtml(event.getLocation()) + "</span></body></html>");
            locationLabel.setFont(FontManager.getRunescapeSmallFont());
            locationLabel.setAlignmentX(Component.LEFT_ALIGNMENT);
            eventPanel.add(locationLabel);
            eventPanel.add(Box.createVerticalStrut(4));
        }

        // === DESCRIPTION ===
        if (event.getDescription() != null && !event.getDescription().isEmpty())
        {
            eventPanel.add(Box.createVerticalStrut(4));
            
            String desc = event.getDescription();
            String fullDesc = desc;
            if (desc.length() > MAX_DESC_LENGTH)
            {
                desc = desc.substring(0, MAX_DESC_LENGTH) + "...";
            }
            
            JLabel descHeaderLabel = new JLabel("<html><body " + emojiStyle + ">" +
                "üìù <span style='color: #b0b0b0'>Description:</span></body></html>");
            descHeaderLabel.setFont(FontManager.getRunescapeSmallFont());
            descHeaderLabel.setAlignmentX(Component.LEFT_ALIGNMENT);
            eventPanel.add(descHeaderLabel);
            eventPanel.add(Box.createVerticalStrut(3));
            
            JLabel descLabel = new JLabel("<html><body style='width: " + TEXT_WIDTH + "px; color: #c8c8c8'>" + 
                escapeHtml(desc) + "</body></html>");
            descLabel.setFont(FontManager.getRunescapeSmallFont());
            descLabel.setAlignmentX(Component.LEFT_ALIGNMENT);
            if (fullDesc.length() > MAX_DESC_LENGTH)
            {
                descLabel.setToolTipText("<html><body style='width: 300px'>" + 
                    escapeHtml(fullDesc) + "</body></html>");
            }
            eventPanel.add(descLabel);
        }

        // === LINK ===
        if (event.hasUrl())
        {
            eventPanel.add(Box.createVerticalStrut(6));
            
            JLabel linkLabel = new JLabel("üîó More Info");
            linkLabel.setFont(FontManager.getRunescapeSmallFont());
            linkLabel.setForeground(LINK_COLOR);
            linkLabel.setCursor(Cursor.getPredefinedCursor(Cursor.HAND_CURSOR));
            linkLabel.setAlignmentX(Component.LEFT_ALIGNMENT);
            
            linkLabel.addMouseListener(new MouseAdapter()
            {
                @Override
                public void mouseClicked(MouseEvent e)
                {
                    LinkBrowser.browse(event.getUrl());
                }

                @Override
                public void mouseEntered(MouseEvent e)
                {
                    linkLabel.setText("<html><u>üîó More Info</u></html>");
                }

                @Override
                public void mouseExited(MouseEvent e)
                {
                    linkLabel.setText("üîó More Info");
                }
            });
            
            eventPanel.add(linkLabel);
        }

        // === STATUS / COUNTDOWN (at bottom) ===
        eventPanel.add(Box.createVerticalStrut(8));
        if (isHappening)
        {
            JLabel statusLbl = new JLabel("<html><body " + emojiStyle + ">" +
                "üü¢ <span style='color: #64ff64'><b>HAPPENING NOW</b></span></body></html>");
            statusLbl.setFont(FontManager.getRunescapeBoldFont());
            statusLbl.setAlignmentX(Component.LEFT_ALIGNMENT);
            eventPanel.add(statusLbl);
        }
        else if (event.isUpcoming())
        {
            String countdownColor = isImminent ? "#ff6464" : "#ffffff";
            JLabel countdownLabel = new JLabel("<html><body " + emojiStyle + ">" +
                "‚è±Ô∏è <span style='color: " + countdownColor + "'><b>Starts in: " + 
                escapeHtml(event.getTimeUntil()) + "</b></span></body></html>");
            countdownLabel.setFont(FontManager.getRunescapeBoldFont());
            countdownLabel.setAlignmentX(Component.LEFT_ALIGNMENT);
            eventPanel.add(countdownLabel);
        }

        // Hover effect for the whole panel
        final Color originalBg = PANEL_COLOR;
        eventPanel.addMouseListener(new MouseAdapter()
        {
            @Override
            public void mouseEntered(MouseEvent e)
            {
                eventPanel.setBackground(HOVER_COLOR);
            }

            @Override
            public void mouseExited(MouseEvent e)
            {
                eventPanel.setBackground(originalBg);
            }
        });

        return eventPanel;
    }

    /**
     * Shows an error message in the panel.
     */
    public void showError(String message)
    {
        SwingUtilities.invokeLater(() -> {
            eventsContainer.removeAll();

            JLabel errorLabel = new JLabel("<html><center>" + message + "</center></html>");
            errorLabel.setFont(FontManager.getRunescapeFont());
            errorLabel.setForeground(IMMINENT_COLOR);
            errorLabel.setAlignmentX(Component.CENTER_ALIGNMENT);
            errorLabel.setBorder(new EmptyBorder(20, 0, 20, 0));
            eventsContainer.add(errorLabel);
            eventsContainer.add(Box.createVerticalGlue());

            statusLabel.setText("Error");
            
            eventsContainer.revalidate();
            eventsContainer.repaint();
        });
    }

    /**
     * Shows a loading state in the panel.
     */
    public void showLoading()
    {
        SwingUtilities.invokeLater(() -> {
            eventsContainer.removeAll();

            JLabel loadingLabel = new JLabel("Loading events...");
            loadingLabel.setFont(FontManager.getRunescapeFont());
            loadingLabel.setForeground(SECONDARY_TEXT);
            loadingLabel.setAlignmentX(Component.CENTER_ALIGNMENT);
            loadingLabel.setBorder(new EmptyBorder(20, 0, 20, 0));
            eventsContainer.add(loadingLabel);
            eventsContainer.add(Box.createVerticalGlue());

            statusLabel.setText("Loading...");

            eventsContainer.revalidate();
            eventsContainer.repaint();
        });
    }

    /**
     * Escapes HTML special characters in a string.
     */
    private String escapeHtml(String text)
    {
        if (text == null)
        {
            return "";
        }
        return text
            .replace("&", "&amp;")
            .replace("<", "&lt;")
            .replace(">", "&gt;")
            .replace("\"", "&quot;")
            .replace("\n", "<br>");
    }
}

package com.claneventlist;

import com.google.inject.Provides;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.GameState;
import net.runelite.api.events.GameStateChanged;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.events.ConfigChanged;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.plugins.PluginDescriptor;
import net.runelite.client.task.Schedule;
import net.runelite.client.ui.ClientToolbar;
import net.runelite.client.ui.NavigationButton;
import net.runelite.client.ui.overlay.OverlayManager;
import net.runelite.client.util.ImageUtil;

import javax.inject.Inject;
import java.awt.image.BufferedImage;
import java.time.temporal.ChronoUnit;
import java.util.concurrent.ScheduledExecutorService;

@Slf4j
@PluginDescriptor(
    name = "Clan Event List",
    description = "Display clan events from a Google Sheet with an overlay and side panel",
    tags = {"clan", "events", "calendar", "schedule", "google", "sheet"}
)
public class EventListPlugin extends Plugin
{
    private static final String ICON_PATH = "calendar_icon.png";

    @Inject
    private EventListConfig config;

    @Inject
    private OverlayManager overlayManager;

    @Inject
    private ClientToolbar clientToolbar;

    @Inject
    private GoogleSheetService sheetService;

    @Inject
    private ScheduledExecutorService executorService;

    private EventListOverlay overlay;
    private EventListPanel panel;
    private NavigationButton navButton;
    private boolean initialized = false;

    @Override
    protected void startUp() throws Exception
    {
        log.info("Clan Event List plugin started");

        // Create overlay
        overlay = new EventListOverlay(config, sheetService);
        overlayManager.add(overlay);

        // Create panel
        panel = new EventListPanel(config, sheetService, this::refreshEvents);

        // Create navigation button with icon
        BufferedImage icon = createCalendarIcon();

        navButton = NavigationButton.builder()
            .tooltip("Clan Events")
            .icon(icon)
            .priority(5)
            .panel(panel)
            .build();

        clientToolbar.addNavigation(navButton);

        // Initial fetch
        initialized = true;
        refreshEvents();
    }

    @Override
    protected void shutDown() throws Exception
    {
        log.info("Clan Event List plugin stopped");

        overlayManager.remove(overlay);
        clientToolbar.removeNavigation(navButton);

        initialized = false;
        overlay = null;
        panel = null;
        navButton = null;
    }

    @Subscribe
    public void onGameStateChanged(GameStateChanged event)
    {
        if (event.getGameState() == GameState.LOGGED_IN && initialized)
        {
            // Refresh events when logging in if cache is stale
            if (sheetService.needsRefresh(config.refreshInterval()))
            {
                refreshEvents();
            }
        }
    }

    @Subscribe
    public void onConfigChanged(ConfigChanged event)
    {
        if (!event.getGroup().equals(EventListConfig.CONFIG_GROUP))
        {
            return;
        }

        // Refresh when sheet configuration changes
        if (event.getKey().equals("sheetId") || event.getKey().equals("sheetName"))
        {
            refreshEvents();
        }

        // Update panel display settings
        if (event.getKey().equals("showPastEvents") || event.getKey().equals("maxEventsShown"))
        {
            if (panel != null)
            {
                panel.updateEvents();
            }
        }
    }

    /**
     * Scheduled task to periodically refresh events.
     * Runs every minute and checks if a refresh is needed based on config.
     */
    @Schedule(period = 1, unit = ChronoUnit.MINUTES)
    public void scheduledRefresh()
    {
        if (!initialized)
        {
            return;
        }

        if (sheetService.needsRefresh(config.refreshInterval()))
        {
            log.debug("Scheduled refresh triggered");
            refreshEvents();
        }
        else
        {
            // Just update the panel to refresh time displays
            if (panel != null)
            {
                panel.updateEvents();
            }
        }
    }

    /**
     * Refreshes the event data from Google Sheets.
     */
    public void refreshEvents()
    {
        if (!initialized)
        {
            return;
        }

        String sheetId = config.sheetId();
        if (sheetId == null || sheetId.trim().isEmpty())
        {
            log.debug("No sheet ID configured, clearing events");
            // Clear events when sheet ID is removed
            sheetService.clearEvents();
            if (panel != null)
            {
                panel.updateEvents();
            }
            return;
        }

        if (panel != null)
        {
            panel.showLoading();
        }

        executorService.submit(() -> {
            try
            {
                sheetService.fetchEvents(config.sheetId(), config.sheetName());
                
                if (panel != null)
                {
                    panel.updateEvents();
                }

                log.debug("Events refreshed successfully");
            }
            catch (Exception e)
            {
                log.warn("Failed to refresh events: {}", e.getMessage());
                if (panel != null)
                {
                    panel.showError("Failed to fetch events.<br>Check your Sheet ID.");
                }
            }
        });
    }

    /**
     * Creates a simple calendar icon for the navigation button.
     */
    private BufferedImage createCalendarIcon()
    {
        // Try to load from resources first
        try
        {
            return ImageUtil.loadImageResource(getClass(), ICON_PATH);
        }
        catch (Exception e)
        {
            log.debug("Calendar icon not found, creating programmatically");
        }

        // Create a simple calendar icon programmatically
        BufferedImage icon = new BufferedImage(16, 16, BufferedImage.TYPE_INT_ARGB);
        java.awt.Graphics2D g = icon.createGraphics();
        
        // Enable anti-aliasing
        g.setRenderingHint(java.awt.RenderingHints.KEY_ANTIALIASING, 
            java.awt.RenderingHints.VALUE_ANTIALIAS_ON);

        // Calendar body (white/light gray)
        g.setColor(new java.awt.Color(220, 220, 220));
        g.fillRoundRect(1, 3, 14, 12, 2, 2);

        // Calendar header (gold/accent)
        g.setColor(new java.awt.Color(255, 200, 0));
        g.fillRoundRect(1, 3, 14, 4, 2, 2);
        g.fillRect(1, 5, 14, 2);

        // Calendar rings
        g.setColor(new java.awt.Color(100, 100, 100));
        g.fillRect(4, 1, 2, 4);
        g.fillRect(10, 1, 2, 4);

        // Calendar dots (representing dates)
        g.setColor(new java.awt.Color(80, 80, 80));
        g.fillRect(3, 9, 2, 2);
        g.fillRect(7, 9, 2, 2);
        g.fillRect(11, 9, 2, 2);
        g.fillRect(3, 12, 2, 2);
        g.fillRect(7, 12, 2, 2);

        g.dispose();
        return icon;
    }

    @Provides
    EventListConfig provideConfig(ConfigManager configManager)
    {
        return configManager.getConfig(EventListConfig.class);
    }
}


package com.claneventlist;

import lombok.extern.slf4j.Slf4j;
import okhttp3.OkHttpClient;
import okhttp3.Request;
import okhttp3.Response;

import javax.inject.Inject;
import javax.inject.Singleton;
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.time.format.DateTimeParseException;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

/**
 * Service for fetching clan event data from a Google Sheet.
 * 
 * The Google Sheet should have the following columns:
 * A: Event Name
 * B: Description
 * C: Date (format: yyyy-MM-dd or MM/dd/yyyy)
 * D: Start Time (format: HH:mm or h:mm a)
 * E: End Time (format: HH:mm or h:mm a)
 * F: Host
 * G: Location
 * H: URL
 * 
 * The sheet must be published to the web (File > Share > Publish to web)
 * and use the CSV format for public access.
 */
@Slf4j
@Singleton
public class GoogleSheetService
{
    private static final String SHEETS_CSV_URL = "https://docs.google.com/spreadsheets/d/%s/gviz/tq?tqx=out:csv";
    private static final String SHEETS_CSV_URL_WITH_SHEET = "https://docs.google.com/spreadsheets/d/%s/gviz/tq?tqx=out:csv&sheet=%s";

    private static final DateTimeFormatter[] DATE_FORMATS = {
        DateTimeFormatter.ofPattern("yyyy-MM-dd"),
        DateTimeFormatter.ofPattern("MM-dd-yy"),      // 12-15-24 format
        DateTimeFormatter.ofPattern("MM-dd-yyyy"),    // 12-15-2024 format
        DateTimeFormatter.ofPattern("M-d-yy"),        // 1-5-24 format
        DateTimeFormatter.ofPattern("M-d-yyyy"),      // 1-5-2024 format
        DateTimeFormatter.ofPattern("MM/dd/yyyy"),
        DateTimeFormatter.ofPattern("MM/dd/yy"),      // 12/15/24 format
        DateTimeFormatter.ofPattern("dd/MM/yyyy"),
        DateTimeFormatter.ofPattern("M/d/yyyy"),
        DateTimeFormatter.ofPattern("M/d/yy"),
        DateTimeFormatter.ofPattern("d/M/yyyy"),
        DateTimeFormatter.ofPattern("yyyy/MM/dd")
    };

    private static final DateTimeFormatter[] TIME_FORMATS = {
        DateTimeFormatter.ofPattern("HH:mm"),
        DateTimeFormatter.ofPattern("H:mm"),
        DateTimeFormatter.ofPattern("h:mm a"),
        DateTimeFormatter.ofPattern("hh:mm a"),
        DateTimeFormatter.ofPattern("h:mm:ss a"),      // Google Sheets often includes seconds
        DateTimeFormatter.ofPattern("hh:mm:ss a"),     // 12-hour with seconds
        DateTimeFormatter.ofPattern("HH:mm:ss"),
        DateTimeFormatter.ofPattern("H:mm:ss"),
        DateTimeFormatter.ofPattern("h:mma"),          // No space before AM/PM
        DateTimeFormatter.ofPattern("hh:mma"),
        DateTimeFormatter.ofPattern("h:mm:ssa"),       // No space, with seconds
        DateTimeFormatter.ofPattern("hh:mm:ssa")
    };

    private final OkHttpClient httpClient;
    private List<ClanEvent> cachedEvents = new ArrayList<>();
    private long lastFetchTime = 0;

    @Inject
    public GoogleSheetService(OkHttpClient httpClient)
    {
        this.httpClient = httpClient;
    }

    /**
     * Fetches events from the configured Google Sheet.
     */
    public List<ClanEvent> fetchEvents(String sheetId, String sheetName)
    {
        if (sheetId == null || sheetId.trim().isEmpty())
        {
            log.debug("No sheet ID configured");
            return Collections.emptyList();
        }

        String url;
        if (sheetName != null && !sheetName.trim().isEmpty())
        {
            url = String.format(SHEETS_CSV_URL_WITH_SHEET, sheetId.trim(), sheetName.trim());
        }
        else
        {
            url = String.format(SHEETS_CSV_URL, sheetId.trim());
        }

        log.debug("Fetching events from: {}", url);

        Request request = new Request.Builder()
            .url(url)
            .header("User-Agent", "RuneLite")
            .build();

        try (Response response = httpClient.newCall(request).execute())
        {
            if (!response.isSuccessful())
            {
                log.warn("Failed to fetch sheet data: HTTP {}", response.code());
                return cachedEvents;
            }

            okhttp3.ResponseBody responseBody = response.body();
            if (responseBody == null)
            {
                log.warn("Empty response body from sheet");
                return cachedEvents;
            }
            String body = responseBody.string();
            List<ClanEvent> events = parseCsv(body);
            cachedEvents = events;
            lastFetchTime = System.currentTimeMillis();
            log.debug("Fetched {} events", events.size());
            return events;
        }
        catch (Exception e)
        {
            log.warn("Error fetching sheet data: {}", e.getMessage());
            return cachedEvents;
        }
    }

    /**
     * Returns the cached events without fetching.
     */
    public List<ClanEvent> getCachedEvents()
    {
        return new ArrayList<>(cachedEvents);
    }

    /**
     * Clears all cached events.
     */
    public void clearEvents()
    {
        cachedEvents.clear();
        lastFetchTime = 0;
        log.debug("Cleared all cached events");
    }

    /**
     * Returns the next upcoming event.
     */
    public ClanEvent getNextEvent()
    {
        return cachedEvents.stream()
            .filter(ClanEvent::isUpcoming)
            .sorted()
            .findFirst()
            .orElse(null);
    }

    /**
     * Returns the currently active (happening now) event, if any.
     */
    public ClanEvent getActiveEvent()
    {
        return cachedEvents.stream()
            .filter(ClanEvent::isHappeningNow)
            .sorted()
            .findFirst()
            .orElse(null);
    }

    /**
     * Returns the event that should be highlighted (active or next upcoming).
     */
    public ClanEvent getHighlightedEvent()
    {
        ClanEvent active = getActiveEvent();
        return active != null ? active : getNextEvent();
    }

    /**
     * Returns all upcoming events sorted by date.
     */
    public List<ClanEvent> getUpcomingEvents()
    {
        List<ClanEvent> upcoming = new ArrayList<>();
        for (ClanEvent event : cachedEvents)
        {
            if (event.isUpcoming())
            {
                upcoming.add(event);
            }
        }
        Collections.sort(upcoming);
        return upcoming;
    }

    /**
     * Parses CSV data into a list of ClanEvent objects.
     * Handles multiline fields (newlines inside quoted strings).
     */
    private List<ClanEvent> parseCsv(String csv)
    {
        List<ClanEvent> events = new ArrayList<>();
        
        log.debug("Parsing CSV data, length: {}", csv.length());
        
        // Parse all rows from CSV (handles multiline fields)
        List<String[]> rows = parseCsvRows(csv);
        
        log.debug("Parsed {} rows from CSV", rows.size());
        
        boolean firstRow = true;
        int rowNum = 0;
        
        for (String[] fields : rows)
        {
            rowNum++;
            
            // Skip header row
            if (firstRow)
            {
                log.debug("Header row: {} fields", fields.length);
                firstRow = false;
                continue;
            }
            
            // Skip rows with no event name
            if (fields.length < 1 || fields[0].trim().isEmpty())
            {
                log.debug("Row {}: skipping empty row", rowNum);
                continue;
            }
            
            // Validate we have enough fields (at least name and date)
            if (fields.length < 3)
            {
                log.debug("Row {}: skipping row with only {} fields", rowNum, fields.length);
                continue;
            }

            ClanEvent event = new ClanEvent();
            event.setName(getField(fields, 0));
            event.setDescription(getField(fields, 1));
            
            // Parse date and start time
            String dateStr = getField(fields, 2);
            String startTimeStr = getField(fields, 3);
            
            // Validate date field looks like a date (not description overflow)
            if (!looksLikeDate(dateStr))
            {
                log.debug("Row {}: skipping, date field '{}' doesn't look like a date", rowNum, 
                    dateStr.length() > 30 ? dateStr.substring(0, 30) + "..." : dateStr);
                continue;
            }
            
            log.debug("Row {}: Parsing date='{}' startTime='{}'", rowNum, dateStr, startTimeStr);
            event.setDateTime(parseDateTime(dateStr, startTimeStr));
            
            // Skip if date couldn't be parsed
            if (event.getDateTime() == null)
            {
                log.debug("Row {}: skipping, couldn't parse date", rowNum);
                continue;
            }
            
            // Parse end time (column 4)
            String endTimeStr = getField(fields, 4);
            if (!endTimeStr.isEmpty())
            {
                event.setEndTime(parseTime(endTimeStr));
            }
            
            event.setHost(getField(fields, 5));
            event.setLocation(getField(fields, 6));
            
            // Parse URL (column 7)
            String urlStr = getField(fields, 7);
            if (!urlStr.isEmpty())
            {
                event.setUrl(urlStr);
            }

            log.debug("Row {}: Created event '{}' on {}", rowNum, event.getName(), event.getDateTime());
            events.add(event);
        }

        return events;
    }

    /**
     * Checks if a string looks like a date (short, contains numbers/dashes/slashes).
     */
    private boolean looksLikeDate(String str)
    {
        if (str == null || str.isEmpty())
        {
            return false;
        }
        // Dates should be short (less than 15 chars) and contain digits
        if (str.length() > 15)
        {
            return false;
        }
        // Should contain at least one digit
        return str.matches(".*\\d.*");
    }

    /**
     * Parses entire CSV string into rows, handling multiline quoted fields.
     */
    private List<String[]> parseCsvRows(String csv)
    {
        List<String[]> rows = new ArrayList<>();
        List<String> currentRow = new ArrayList<>();
        StringBuilder currentField = new StringBuilder();
        boolean inQuotes = false;
        
        for (int i = 0; i < csv.length(); i++)
        {
            char c = csv.charAt(i);
            
            if (c == '"')
            {
                // Check for escaped quote ""
                if (inQuotes && i + 1 < csv.length() && csv.charAt(i + 1) == '"')
                {
                    currentField.append('"');
                    i++; // Skip the next quote
                }
                else
                {
                    inQuotes = !inQuotes;
                }
            }
            else if (c == ',' && !inQuotes)
            {
                // End of field
                currentRow.add(currentField.toString().trim());
                currentField = new StringBuilder();
            }
            else if ((c == '\n' || c == '\r') && !inQuotes)
            {
                // End of row (but skip \r\n as single newline)
                if (c == '\r' && i + 1 < csv.length() && csv.charAt(i + 1) == '\n')
                {
                    i++; // Skip the \n
                }
                
                // Add last field and complete the row
                currentRow.add(currentField.toString().trim());
                if (!currentRow.isEmpty() && !isRowEmpty(currentRow))
                {
                    rows.add(currentRow.toArray(new String[0]));
                }
                currentRow = new ArrayList<>();
                currentField = new StringBuilder();
            }
            else
            {
                // Regular character (including newlines inside quotes)
                currentField.append(c);
            }
        }
        
        // Don't forget the last row
        currentRow.add(currentField.toString().trim());
        if (!currentRow.isEmpty() && !isRowEmpty(currentRow))
        {
            rows.add(currentRow.toArray(new String[0]));
        }
        
        return rows;
    }

    /**
     * Checks if a row is effectively empty.
     */
    private boolean isRowEmpty(List<String> row)
    {
        for (String field : row)
        {
            if (field != null && !field.trim().isEmpty())
            {
                return false;
            }
        }
        return true;
    }

    /**
     * Safely gets a field from the array, returning empty string if out of bounds.
     */
    private String getField(String[] fields, int index)
    {
        if (index < fields.length)
        {
            String value = fields[index].trim();
            // Remove surrounding quotes if present
            if (value.startsWith("\"") && value.endsWith("\""))
            {
                value = value.substring(1, value.length() - 1);
            }
            return value;
        }
        return "";
    }

    /**
     * Parses date and time strings into a LocalDateTime.
     * For 2-digit years, assumes the next upcoming occurrence of that date.
     */
    private LocalDateTime parseDateTime(String dateStr, String timeStr)
    {
        if (dateStr == null || dateStr.isEmpty())
        {
            return null;
        }

        java.time.LocalDate date = null;
        java.time.LocalTime time = java.time.LocalTime.NOON; // Default to noon if no time specified
        boolean usedTwoDigitYear = false;

        // Try to parse the date
        for (DateTimeFormatter format : DATE_FORMATS)
        {
            try
            {
                date = java.time.LocalDate.parse(dateStr, format);
                // Check if this format uses 2-digit year (ends with 2 digits, not 4)
                if (dateStr.matches(".*\\d{2}$") && !dateStr.matches(".*\\d{4}$"))
                {
                    usedTwoDigitYear = true;
                }
                break;
            }
            catch (DateTimeParseException ignored)
            {
            }
        }

        if (date == null)
        {
            log.debug("Could not parse date: {}", dateStr);
            return null;
        }

        // For 2-digit years: if the date is more than 6 months in the past,
        // assume it should be next year (handles year rollover for events)
        if (usedTwoDigitYear)
        {
            java.time.LocalDate today = java.time.LocalDate.now();
            // If the parsed date is more than 6 months ago, add a year
            if (date.isBefore(today.minusMonths(6)))
            {
                date = date.plusYears(1);
                log.debug("Adjusted 2-digit year date to: {}", date);
            }
        }

        // Try to parse the time if provided
        if (timeStr != null && !timeStr.isEmpty())
        {
            String normalizedTime = timeStr.trim().toUpperCase();
            boolean timeParsed = false;
            for (DateTimeFormatter format : TIME_FORMATS)
            {
                try
                {
                    time = java.time.LocalTime.parse(normalizedTime, format);
                    timeParsed = true;
                    break;
                }
                catch (DateTimeParseException ignored)
                {
                }
            }
            if (!timeParsed)
            {
                log.debug("Could not parse time '{}' (normalized: '{}'), using noon default", timeStr, normalizedTime);
            }
        }

        return LocalDateTime.of(date, time);
    }

    /**
     * Parses a time string into a LocalTime.
     */
    private java.time.LocalTime parseTime(String timeStr)
    {
        if (timeStr == null || timeStr.isEmpty())
        {
            return null;
        }
        
        for (DateTimeFormatter format : TIME_FORMATS)
        {
            try
            {
                return java.time.LocalTime.parse(timeStr.toUpperCase(), format);
            }
            catch (DateTimeParseException ignored)
            {
            }
        }
        
        log.debug("Could not parse time: {}", timeStr);
        return null;
    }

    /**
     * Returns the timestamp of the last successful fetch.
     */
    public long getLastFetchTime()
    {
        return lastFetchTime;
    }

    /**
     * Checks if the cache needs refreshing based on the interval.
     */
    public boolean needsRefresh(int intervalMinutes)
    {
        long intervalMs = intervalMinutes * 60 * 1000L;
        return System.currentTimeMillis() - lastFetchTime > intervalMs;
    }
}


package com.claneventlist;

import net.runelite.client.RuneLite;
import net.runelite.client.externalplugins.ExternalPluginManager;

public class EventListPluginTest
{
	public static void main(String[] args) throws Exception
	{
		ExternalPluginManager.loadBuiltin(EventListPlugin.class);
		RuneLite.main(args);
	}
}


