package com.claneventlist;

import lombok.extern.slf4j.Slf4j;
import okhttp3.OkHttpClient;
import okhttp3.Request;
import okhttp3.Response;

import javax.inject.Inject;
import javax.inject.Singleton;
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.time.format.DateTimeParseException;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

/**
 * Service for fetching clan event data from a Google Sheet.
 * 
 * The Google Sheet should have the following columns:
 * A: Event Name
 * B: Description
 * C: Date (format: yyyy-MM-dd or MM/dd/yyyy)
 * D: Start Time (format: HH:mm or h:mm a)
 * E: End Time (format: HH:mm or h:mm a)
 * F: Host
 * G: Location
 * H: URL
 * 
 * The sheet must be published to the web (File > Share > Publish to web)
 * and use the CSV format for public access.
 */
@Slf4j
@Singleton
public class GoogleSheetService
{
    private static final String SHEETS_CSV_URL = "https://docs.google.com/spreadsheets/d/%s/gviz/tq?tqx=out:csv";
    private static final String SHEETS_CSV_URL_WITH_SHEET = "https://docs.google.com/spreadsheets/d/%s/gviz/tq?tqx=out:csv&sheet=%s";

    private static final DateTimeFormatter[] DATE_FORMATS = {
        DateTimeFormatter.ofPattern("yyyy-MM-dd"),
        DateTimeFormatter.ofPattern("MM-dd-yy"),      // 12-15-24 format
        DateTimeFormatter.ofPattern("MM-dd-yyyy"),    // 12-15-2024 format
        DateTimeFormatter.ofPattern("M-d-yy"),        // 1-5-24 format
        DateTimeFormatter.ofPattern("M-d-yyyy"),      // 1-5-2024 format
        DateTimeFormatter.ofPattern("MM/dd/yyyy"),
        DateTimeFormatter.ofPattern("MM/dd/yy"),      // 12/15/24 format
        DateTimeFormatter.ofPattern("dd/MM/yyyy"),
        DateTimeFormatter.ofPattern("M/d/yyyy"),
        DateTimeFormatter.ofPattern("M/d/yy"),
        DateTimeFormatter.ofPattern("d/M/yyyy"),
        DateTimeFormatter.ofPattern("yyyy/MM/dd")
    };

    private static final DateTimeFormatter[] TIME_FORMATS = {
        DateTimeFormatter.ofPattern("HH:mm"),
        DateTimeFormatter.ofPattern("H:mm"),
        DateTimeFormatter.ofPattern("h:mm a"),
        DateTimeFormatter.ofPattern("hh:mm a"),
        DateTimeFormatter.ofPattern("HH:mm:ss")
    };

    private final OkHttpClient httpClient;
    private List<ClanEvent> cachedEvents = new ArrayList<>();
    private long lastFetchTime = 0;

    @Inject
    public GoogleSheetService(OkHttpClient httpClient)
    {
        this.httpClient = httpClient;
    }

    /**
     * Fetches events from the configured Google Sheet.
     */
    public List<ClanEvent> fetchEvents(String sheetId, String sheetName)
    {
        if (sheetId == null || sheetId.trim().isEmpty())
        {
            log.debug("No sheet ID configured");
            return Collections.emptyList();
        }

        String url;
        if (sheetName != null && !sheetName.trim().isEmpty())
        {
            url = String.format(SHEETS_CSV_URL_WITH_SHEET, sheetId.trim(), sheetName.trim());
        }
        else
        {
            url = String.format(SHEETS_CSV_URL, sheetId.trim());
        }

        log.debug("Fetching events from: {}", url);

        Request request = new Request.Builder()
            .url(url)
            .header("User-Agent", "RuneLite")
            .build();

        try (Response response = httpClient.newCall(request).execute())
        {
            if (!response.isSuccessful())
            {
                log.warn("Failed to fetch sheet data: HTTP {}", response.code());
                return cachedEvents;
            }

            okhttp3.ResponseBody responseBody = response.body();
            if (responseBody == null)
            {
                log.warn("Empty response body from sheet");
                return cachedEvents;
            }
            String body = responseBody.string();
            List<ClanEvent> events = parseCsv(body);
            cachedEvents = events;
            lastFetchTime = System.currentTimeMillis();
            log.debug("Fetched {} events", events.size());
            return events;
        }
        catch (Exception e)
        {
            log.warn("Error fetching sheet data: {}", e.getMessage());
            return cachedEvents;
        }
    }

    /**
     * Returns the cached events without fetching.
     */
    public List<ClanEvent> getCachedEvents()
    {
        return new ArrayList<>(cachedEvents);
    }

    /**
     * Clears all cached events.
     */
    public void clearEvents()
    {
        cachedEvents.clear();
        lastFetchTime = 0;
        log.debug("Cleared all cached events");
    }

    /**
     * Returns the next upcoming event.
     */
    public ClanEvent getNextEvent()
    {
        return cachedEvents.stream()
            .filter(ClanEvent::isUpcoming)
            .sorted()
            .findFirst()
            .orElse(null);
    }

    /**
     * Returns all upcoming events sorted by date.
     */
    public List<ClanEvent> getUpcomingEvents()
    {
        List<ClanEvent> upcoming = new ArrayList<>();
        for (ClanEvent event : cachedEvents)
        {
            if (event.isUpcoming())
            {
                upcoming.add(event);
            }
        }
        Collections.sort(upcoming);
        return upcoming;
    }

    /**
     * Parses CSV data into a list of ClanEvent objects.
     * Handles multiline fields (newlines inside quoted strings).
     */
    private List<ClanEvent> parseCsv(String csv)
    {
        List<ClanEvent> events = new ArrayList<>();
        
        log.debug("Parsing CSV data, length: {}", csv.length());
        
        // Parse all rows from CSV (handles multiline fields)
        List<String[]> rows = parseCsvRows(csv);
        
        log.debug("Parsed {} rows from CSV", rows.size());
        
        boolean firstRow = true;
        int rowNum = 0;
        
        for (String[] fields : rows)
        {
            rowNum++;
            
            // Skip header row
            if (firstRow)
            {
                log.debug("Header row: {} fields", fields.length);
                firstRow = false;
                continue;
            }
            
            // Skip rows with no event name
            if (fields.length < 1 || fields[0].trim().isEmpty())
            {
                log.debug("Row {}: skipping empty row", rowNum);
                continue;
            }
            
            // Validate we have enough fields (at least name and date)
            if (fields.length < 3)
            {
                log.debug("Row {}: skipping row with only {} fields", rowNum, fields.length);
                continue;
            }

            ClanEvent event = new ClanEvent();
            event.setName(getField(fields, 0));
            event.setDescription(getField(fields, 1));
            
            // Parse date and start time
            String dateStr = getField(fields, 2);
            String startTimeStr = getField(fields, 3);
            
            // Validate date field looks like a date (not description overflow)
            if (!looksLikeDate(dateStr))
            {
                log.debug("Row {}: skipping, date field '{}' doesn't look like a date", rowNum, 
                    dateStr.length() > 30 ? dateStr.substring(0, 30) + "..." : dateStr);
                continue;
            }
            
            log.debug("Row {}: Parsing date='{}' startTime='{}'", rowNum, dateStr, startTimeStr);
            event.setDateTime(parseDateTime(dateStr, startTimeStr));
            
            // Skip if date couldn't be parsed
            if (event.getDateTime() == null)
            {
                log.debug("Row {}: skipping, couldn't parse date", rowNum);
                continue;
            }
            
            // Parse end time (column 4)
            String endTimeStr = getField(fields, 4);
            if (!endTimeStr.isEmpty())
            {
                event.setEndTime(parseTime(endTimeStr));
            }
            
            event.setHost(getField(fields, 5));
            event.setLocation(getField(fields, 6));
            
            // Parse URL (column 7)
            String urlStr = getField(fields, 7);
            if (!urlStr.isEmpty())
            {
                event.setUrl(urlStr);
            }

            log.debug("Row {}: Created event '{}' on {}", rowNum, event.getName(), event.getDateTime());
            events.add(event);
        }

        return events;
    }

    /**
     * Checks if a string looks like a date (short, contains numbers/dashes/slashes).
     */
    private boolean looksLikeDate(String str)
    {
        if (str == null || str.isEmpty())
        {
            return false;
        }
        // Dates should be short (less than 15 chars) and contain digits
        if (str.length() > 15)
        {
            return false;
        }
        // Should contain at least one digit
        return str.matches(".*\\d.*");
    }

    /**
     * Parses entire CSV string into rows, handling multiline quoted fields.
     */
    private List<String[]> parseCsvRows(String csv)
    {
        List<String[]> rows = new ArrayList<>();
        List<String> currentRow = new ArrayList<>();
        StringBuilder currentField = new StringBuilder();
        boolean inQuotes = false;
        
        for (int i = 0; i < csv.length(); i++)
        {
            char c = csv.charAt(i);
            
            if (c == '"')
            {
                // Check for escaped quote ""
                if (inQuotes && i + 1 < csv.length() && csv.charAt(i + 1) == '"')
                {
                    currentField.append('"');
                    i++; // Skip the next quote
                }
                else
                {
                    inQuotes = !inQuotes;
                }
            }
            else if (c == ',' && !inQuotes)
            {
                // End of field
                currentRow.add(currentField.toString().trim());
                currentField = new StringBuilder();
            }
            else if ((c == '\n' || c == '\r') && !inQuotes)
            {
                // End of row (but skip \r\n as single newline)
                if (c == '\r' && i + 1 < csv.length() && csv.charAt(i + 1) == '\n')
                {
                    i++; // Skip the \n
                }
                
                // Add last field and complete the row
                currentRow.add(currentField.toString().trim());
                if (!currentRow.isEmpty() && !isRowEmpty(currentRow))
                {
                    rows.add(currentRow.toArray(new String[0]));
                }
                currentRow = new ArrayList<>();
                currentField = new StringBuilder();
            }
            else
            {
                // Regular character (including newlines inside quotes)
                currentField.append(c);
            }
        }
        
        // Don't forget the last row
        currentRow.add(currentField.toString().trim());
        if (!currentRow.isEmpty() && !isRowEmpty(currentRow))
        {
            rows.add(currentRow.toArray(new String[0]));
        }
        
        return rows;
    }

    /**
     * Checks if a row is effectively empty.
     */
    private boolean isRowEmpty(List<String> row)
    {
        for (String field : row)
        {
            if (field != null && !field.trim().isEmpty())
            {
                return false;
            }
        }
        return true;
    }

    /**
     * Safely gets a field from the array, returning empty string if out of bounds.
     */
    private String getField(String[] fields, int index)
    {
        if (index < fields.length)
        {
            String value = fields[index].trim();
            // Remove surrounding quotes if present
            if (value.startsWith("\"") && value.endsWith("\""))
            {
                value = value.substring(1, value.length() - 1);
            }
            return value;
        }
        return "";
    }

    /**
     * Parses date and time strings into a LocalDateTime.
     * For 2-digit years, assumes the next upcoming occurrence of that date.
     */
    private LocalDateTime parseDateTime(String dateStr, String timeStr)
    {
        if (dateStr == null || dateStr.isEmpty())
        {
            return null;
        }

        java.time.LocalDate date = null;
        java.time.LocalTime time = java.time.LocalTime.NOON; // Default to noon if no time specified
        boolean usedTwoDigitYear = false;

        // Try to parse the date
        for (DateTimeFormatter format : DATE_FORMATS)
        {
            try
            {
                date = java.time.LocalDate.parse(dateStr, format);
                // Check if this format uses 2-digit year (ends with 2 digits, not 4)
                if (dateStr.matches(".*\\d{2}$") && !dateStr.matches(".*\\d{4}$"))
                {
                    usedTwoDigitYear = true;
                }
                break;
            }
            catch (DateTimeParseException ignored)
            {
            }
        }

        if (date == null)
        {
            log.debug("Could not parse date: {}", dateStr);
            return null;
        }

        // For 2-digit years: if the date is more than 6 months in the past,
        // assume it should be next year (handles year rollover for events)
        if (usedTwoDigitYear)
        {
            java.time.LocalDate today = java.time.LocalDate.now();
            // If the parsed date is more than 6 months ago, add a year
            if (date.isBefore(today.minusMonths(6)))
            {
                date = date.plusYears(1);
                log.debug("Adjusted 2-digit year date to: {}", date);
            }
        }

        // Try to parse the time if provided
        if (timeStr != null && !timeStr.isEmpty())
        {
            for (DateTimeFormatter format : TIME_FORMATS)
            {
                try
                {
                    time = java.time.LocalTime.parse(timeStr.toUpperCase(), format);
                    break;
                }
                catch (DateTimeParseException ignored)
                {
                }
            }
        }

        return LocalDateTime.of(date, time);
    }

    /**
     * Parses a time string into a LocalTime.
     */
    private java.time.LocalTime parseTime(String timeStr)
    {
        if (timeStr == null || timeStr.isEmpty())
        {
            return null;
        }
        
        for (DateTimeFormatter format : TIME_FORMATS)
        {
            try
            {
                return java.time.LocalTime.parse(timeStr.toUpperCase(), format);
            }
            catch (DateTimeParseException ignored)
            {
            }
        }
        
        log.debug("Could not parse time: {}", timeStr);
        return null;
    }

    /**
     * Returns the timestamp of the last successful fetch.
     */
    public long getLastFetchTime()
    {
        return lastFetchTime;
    }

    /**
     * Checks if the cache needs refreshing based on the interval.
     */
    public boolean needsRefresh(int intervalMinutes)
    {
        long intervalMs = intervalMinutes * 60 * 1000L;
        return System.currentTimeMillis() - lastFetchTime > intervalMs;
    }
}


package com.claneventlist;

import com.google.inject.Provides;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.GameState;
import net.runelite.api.events.GameStateChanged;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.events.ConfigChanged;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.plugins.PluginDescriptor;
import net.runelite.client.task.Schedule;
import net.runelite.client.ui.ClientToolbar;
import net.runelite.client.ui.NavigationButton;
import net.runelite.client.ui.overlay.OverlayManager;
import net.runelite.client.util.ImageUtil;

import javax.inject.Inject;
import java.awt.image.BufferedImage;
import java.time.temporal.ChronoUnit;
import java.util.concurrent.ScheduledExecutorService;

@Slf4j
@PluginDescriptor(
    name = "Clan Event List",
    description = "Display clan events from a Google Sheet with an overlay and side panel",
    tags = {"clan", "events", "calendar", "schedule", "google", "sheet"}
)
public class EventListPlugin extends Plugin
{
    private static final String ICON_PATH = "calendar_icon.png";

    @Inject
    private EventListConfig config;

    @Inject
    private OverlayManager overlayManager;

    @Inject
    private ClientToolbar clientToolbar;

    @Inject
    private GoogleSheetService sheetService;

    @Inject
    private ScheduledExecutorService executorService;

    private EventListOverlay overlay;
    private EventListPanel panel;
    private NavigationButton navButton;
    private boolean initialized = false;

    @Override
    protected void startUp() throws Exception
    {
        log.info("Clan Event List plugin started");

        // Create overlay
        overlay = new EventListOverlay(config, sheetService);
        overlayManager.add(overlay);

        // Create panel
        panel = new EventListPanel(config, sheetService, this::refreshEvents);

        // Create navigation button with icon
        BufferedImage icon = createCalendarIcon();

        navButton = NavigationButton.builder()
            .tooltip("Clan Events")
            .icon(icon)
            .priority(5)
            .panel(panel)
            .build();

        clientToolbar.addNavigation(navButton);

        // Initial fetch
        initialized = true;
        refreshEvents();
    }

    @Override
    protected void shutDown() throws Exception
    {
        log.info("Clan Event List plugin stopped");

        overlayManager.remove(overlay);
        clientToolbar.removeNavigation(navButton);

        initialized = false;
        overlay = null;
        panel = null;
        navButton = null;
    }

    @Subscribe
    public void onGameStateChanged(GameStateChanged event)
    {
        if (event.getGameState() == GameState.LOGGED_IN && initialized)
        {
            // Refresh events when logging in if cache is stale
            if (sheetService.needsRefresh(config.refreshInterval()))
            {
                refreshEvents();
            }
        }
    }

    @Subscribe
    public void onConfigChanged(ConfigChanged event)
    {
        if (!event.getGroup().equals(EventListConfig.CONFIG_GROUP))
        {
            return;
        }

        // Refresh when sheet configuration changes
        if (event.getKey().equals("sheetId") || event.getKey().equals("sheetName"))
        {
            refreshEvents();
        }

        // Update panel display settings
        if (event.getKey().equals("showPastEvents") || event.getKey().equals("maxEventsShown"))
        {
            if (panel != null)
            {
                panel.updateEvents();
            }
        }
    }

    /**
     * Scheduled task to periodically refresh events.
     * Runs every minute and checks if a refresh is needed based on config.
     */
    @Schedule(period = 1, unit = ChronoUnit.MINUTES)
    public void scheduledRefresh()
    {
        if (!initialized)
        {
            return;
        }

        if (sheetService.needsRefresh(config.refreshInterval()))
        {
            log.debug("Scheduled refresh triggered");
            refreshEvents();
        }
        else
        {
            // Just update the panel to refresh time displays
            if (panel != null)
            {
                panel.updateEvents();
            }
        }
    }

    /**
     * Refreshes the event data from Google Sheets.
     */
    public void refreshEvents()
    {
        if (!initialized)
        {
            return;
        }

        String sheetId = config.sheetId();
        if (sheetId == null || sheetId.trim().isEmpty())
        {
            log.debug("No sheet ID configured, clearing events");
            // Clear events when sheet ID is removed
            sheetService.clearEvents();
            if (panel != null)
            {
                panel.updateEvents();
            }
            return;
        }

        if (panel != null)
        {
            panel.showLoading();
        }

        executorService.submit(() -> {
            try
            {
                sheetService.fetchEvents(config.sheetId(), config.sheetName());
                
                if (panel != null)
                {
                    panel.updateEvents();
                }

                log.debug("Events refreshed successfully");
            }
            catch (Exception e)
            {
                log.warn("Failed to refresh events: {}", e.getMessage());
                if (panel != null)
                {
                    panel.showError("Failed to fetch events.<br>Check your Sheet ID.");
                }
            }
        });
    }

    /**
     * Creates a simple calendar icon for the navigation button.
     */
    private BufferedImage createCalendarIcon()
    {
        // Try to load from resources first
        try
        {
            return ImageUtil.loadImageResource(getClass(), ICON_PATH);
        }
        catch (Exception e)
        {
            log.debug("Calendar icon not found, creating programmatically");
        }

        // Create a simple calendar icon programmatically
        BufferedImage icon = new BufferedImage(16, 16, BufferedImage.TYPE_INT_ARGB);
        java.awt.Graphics2D g = icon.createGraphics();
        
        // Enable anti-aliasing
        g.setRenderingHint(java.awt.RenderingHints.KEY_ANTIALIASING, 
            java.awt.RenderingHints.VALUE_ANTIALIAS_ON);

        // Calendar body (white/light gray)
        g.setColor(new java.awt.Color(220, 220, 220));
        g.fillRoundRect(1, 3, 14, 12, 2, 2);

        // Calendar header (gold/accent)
        g.setColor(new java.awt.Color(255, 200, 0));
        g.fillRoundRect(1, 3, 14, 4, 2, 2);
        g.fillRect(1, 5, 14, 2);

        // Calendar rings
        g.setColor(new java.awt.Color(100, 100, 100));
        g.fillRect(4, 1, 2, 4);
        g.fillRect(10, 1, 2, 4);

        // Calendar dots (representing dates)
        g.setColor(new java.awt.Color(80, 80, 80));
        g.fillRect(3, 9, 2, 2);
        g.fillRect(7, 9, 2, 2);
        g.fillRect(11, 9, 2, 2);
        g.fillRect(3, 12, 2, 2);
        g.fillRect(7, 12, 2, 2);

        g.dispose();
        return icon;
    }

    @Provides
    EventListConfig provideConfig(ConfigManager configManager)
    {
        return configManager.getConfig(EventListConfig.class);
    }
}


package com.claneventlist;

import lombok.Data;
import lombok.AllArgsConstructor;
import lombok.NoArgsConstructor;

import java.time.LocalDateTime;
import java.time.LocalTime;
import java.time.format.DateTimeFormatter;
import java.time.temporal.ChronoUnit;

/**
 * Represents a clan event fetched from the Google Sheet.
 * 
 * Expected columns: Event Name, Description, Date, Start Time, End Time, Host, Location, URL
 */
@Data
@AllArgsConstructor
@NoArgsConstructor
public class ClanEvent implements Comparable<ClanEvent>
{
    private String name;
    private String description;
    private LocalDateTime dateTime;      // Start date/time
    private LocalTime endTime;           // End time (same day)
    private String host;
    private String location;
    private String url;                  // Link to more info / signup

    private static final DateTimeFormatter DISPLAY_FORMAT = DateTimeFormatter.ofPattern("MMM dd, yyyy 'at' HH:mm");
    private static final DateTimeFormatter SHORT_FORMAT = DateTimeFormatter.ofPattern("MMM dd HH:mm");
    private static final DateTimeFormatter TIME_ONLY = DateTimeFormatter.ofPattern("HH:mm");
    private static final DateTimeFormatter DAY_FORMAT = DateTimeFormatter.ofPattern("EEE, MMM dd");

    /**
     * Returns a formatted string of the event date/time.
     */
    public String getFormattedDateTime()
    {
        if (dateTime == null)
        {
            return "TBD";
        }
        return dateTime.format(DISPLAY_FORMAT);
    }

    /**
     * Returns a short formatted string of the event date/time.
     */
    public String getShortDateTime()
    {
        if (dateTime == null)
        {
            return "TBD";
        }
        return dateTime.format(SHORT_FORMAT);
    }

    /**
     * Returns just the day (e.g., "Mon, Dec 15").
     */
    public String getDayString()
    {
        if (dateTime == null)
        {
            return "TBD";
        }
        return dateTime.format(DAY_FORMAT);
    }

    /**
     * Returns the time range (e.g., "20:00 - 22:00" or just "20:00").
     */
    public String getTimeRange()
    {
        if (dateTime == null)
        {
            return "TBD";
        }
        String start = dateTime.format(TIME_ONLY);
        if (endTime != null)
        {
            return start + " - " + endTime.format(TIME_ONLY);
        }
        return start;
    }

    /**
     * Returns the duration string if end time is set.
     */
    public String getDuration()
    {
        if (dateTime == null || endTime == null)
        {
            return null;
        }
        
        LocalTime startTime = dateTime.toLocalTime();
        long minutes = ChronoUnit.MINUTES.between(startTime, endTime);
        
        // Handle overnight events
        if (minutes < 0)
        {
            minutes += 24 * 60;
        }
        
        long hours = minutes / 60;
        long mins = minutes % 60;
        
        if (hours > 0 && mins > 0)
        {
            return hours + "h " + mins + "m";
        }
        else if (hours > 0)
        {
            return hours + "h";
        }
        else
        {
            return mins + "m";
        }
    }

    /**
     * Returns a human-readable time until the event.
     */
    public String getTimeUntil()
    {
        if (dateTime == null)
        {
            return "Unknown";
        }

        LocalDateTime now = LocalDateTime.now();
        if (dateTime.isBefore(now))
        {
            return "Started";
        }

        long days = ChronoUnit.DAYS.between(now, dateTime);
        long hours = ChronoUnit.HOURS.between(now, dateTime) % 24;
        long minutes = ChronoUnit.MINUTES.between(now, dateTime) % 60;

        if (days > 0)
        {
            return days + "d " + hours + "h";
        }
        else if (hours > 0)
        {
            return hours + "h " + minutes + "m";
        }
        else
        {
            return minutes + "m";
        }
    }

    /**
     * Checks if this event has a URL.
     */
    public boolean hasUrl()
    {
        return url != null && !url.trim().isEmpty();
    }

    /**
     * Checks if this event is in the future.
     */
    public boolean isUpcoming()
    {
        return dateTime != null && dateTime.isAfter(LocalDateTime.now());
    }

    /**
     * Checks if this event is currently happening.
     */
    public boolean isHappeningNow()
    {
        if (dateTime == null)
        {
            return false;
        }
        LocalDateTime now = LocalDateTime.now();
        LocalDateTime end = endTime != null 
            ? dateTime.toLocalDate().atTime(endTime) 
            : dateTime.plusHours(2); // Assume 2 hour default
            
        return now.isAfter(dateTime) && now.isBefore(end);
    }

    /**
     * Checks if this event is happening today.
     */
    public boolean isToday()
    {
        if (dateTime == null)
        {
            return false;
        }
        LocalDateTime now = LocalDateTime.now();
        return dateTime.toLocalDate().equals(now.toLocalDate());
    }

    /**
     * Checks if this event is happening within the next hour.
     */
    public boolean isImminent()
    {
        if (dateTime == null)
        {
            return false;
        }
        LocalDateTime now = LocalDateTime.now();
        long minutes = ChronoUnit.MINUTES.between(now, dateTime);
        return minutes >= 0 && minutes <= 60;
    }

    @Override
    public int compareTo(ClanEvent other)
    {
        if (this.dateTime == null && other.dateTime == null)
        {
            return 0;
        }
        if (this.dateTime == null)
        {
            return 1;
        }
        if (other.dateTime == null)
        {
            return -1;
        }
        return this.dateTime.compareTo(other.dateTime);
    }
}


package com.claneventlist;

import net.runelite.client.config.Config;
import net.runelite.client.config.ConfigGroup;
import net.runelite.client.config.ConfigItem;
import net.runelite.client.config.ConfigSection;
import net.runelite.client.config.Range;

import java.awt.Color;

@ConfigGroup(EventListConfig.CONFIG_GROUP)
public interface EventListConfig extends Config
{
    String CONFIG_GROUP = "claneventlist";

    @ConfigSection(
        name = "Google Sheet",
        description = "Configure Google Sheet data source",
        position = 0
    )
    String sheetSection = "sheetSection";

    @ConfigSection(
        name = "Overlay",
        description = "Configure overlay appearance",
        position = 1
    )
    String overlaySection = "overlaySection";

    @ConfigSection(
        name = "Panel",
        description = "Configure panel settings",
        position = 2
    )
    String panelSection = "panelSection";

    // ========== Google Sheet Settings ==========

    @ConfigItem(
        keyName = "sheetId",
        name = "Google Sheet ID",
        description = "The ID from your Google Sheet URL (the long string between /d/ and /edit)",
        section = sheetSection,
        position = 0
    )
    default String sheetId()
    {
        return "";
    }

    @ConfigItem(
        keyName = "sheetName",
        name = "Sheet Tab Name",
        description = "The name of the specific sheet/tab to read from (leave empty for first sheet)",
        section = sheetSection,
        position = 1
    )
    default String sheetName()
    {
        return "";
    }

    @ConfigItem(
        keyName = "refreshInterval",
        name = "Refresh Interval (min)",
        description = "How often to refresh event data from the sheet (in minutes)",
        section = sheetSection,
        position = 2
    )
    @Range(min = 1, max = 60)
    default int refreshInterval()
    {
        return 5;
    }

    // ========== Overlay Settings ==========

    @ConfigItem(
        keyName = "showOverlay",
        name = "Show Overlay",
        description = "Display the next event overlay on the game screen",
        section = overlaySection,
        position = 0
    )
    default boolean showOverlay()
    {
        return true;
    }

    @ConfigItem(
        keyName = "overlayBackgroundColor",
        name = "Background Color",
        description = "Background color of the overlay",
        section = overlaySection,
        position = 1
    )
    default Color overlayBackgroundColor()
    {
        return new Color(30, 30, 30, 200);
    }

    @ConfigItem(
        keyName = "overlayTextColor",
        name = "Text Color",
        description = "Text color for the overlay",
        section = overlaySection,
        position = 2
    )
    default Color overlayTextColor()
    {
        return Color.WHITE;
    }

    @ConfigItem(
        keyName = "overlayAccentColor",
        name = "Accent Color",
        description = "Accent color for event name and highlights",
        section = overlaySection,
        position = 3
    )
    default Color overlayAccentColor()
    {
        return new Color(255, 200, 0);
    }

    @ConfigItem(
        keyName = "imminentColor",
        name = "Imminent Event Color",
        description = "Color when event is within 1 hour",
        section = overlaySection,
        position = 4
    )
    default Color imminentColor()
    {
        return new Color(255, 100, 100);
    }

    // ========== Panel Settings ==========

    @ConfigItem(
        keyName = "maxEventsShown",
        name = "Max Events Shown",
        description = "Maximum number of events to show in the panel (scroll for more)",
        section = panelSection,
        position = 0
    )
    @Range(min = 1, max = 50)
    default int maxEventsInPanel()
    {
        return 10;
    }

    @ConfigItem(
        keyName = "showPastEvents",
        name = "Show Past Events",
        description = "Include events that have already passed",
        section = panelSection,
        position = 1
    )
    default boolean showPastEvents()
    {
        return false;
    }
}


package com.claneventlist;

import net.runelite.client.ui.overlay.Overlay;
import net.runelite.client.ui.overlay.OverlayLayer;
import net.runelite.client.ui.overlay.OverlayPosition;
import net.runelite.client.ui.overlay.components.LineComponent;
import net.runelite.client.ui.overlay.components.PanelComponent;
import net.runelite.client.ui.overlay.components.TitleComponent;

import javax.inject.Inject;
import java.awt.Color;
import java.awt.Dimension;
import java.awt.Graphics2D;

/**
 * Minimal overlay that displays the next upcoming clan event.
 * Shows only: Event name and countdown timer.
 */
public class EventListOverlay extends Overlay
{
    private final EventListConfig config;
    private final GoogleSheetService sheetService;
    private final PanelComponent panelComponent = new PanelComponent();

    @Inject
    public EventListOverlay(EventListConfig config, GoogleSheetService sheetService)
    {
        this.config = config;
        this.sheetService = sheetService;

        setPosition(OverlayPosition.TOP_LEFT);
        setLayer(OverlayLayer.ABOVE_WIDGETS);
    }

    @Override
    public Dimension render(Graphics2D graphics)
    {
        if (!config.showOverlay())
        {
            return null;
        }

        ClanEvent nextEvent = sheetService.getNextEvent();
        if (nextEvent == null)
        {
            return null;
        }

        panelComponent.getChildren().clear();
        panelComponent.setBackgroundColor(config.overlayBackgroundColor());
        panelComponent.setPreferredSize(new Dimension(160, 0));

        // Determine colors based on urgency
        Color accentColor = nextEvent.isImminent() ? config.imminentColor() : config.overlayAccentColor();
        Color timeColor = nextEvent.isImminent() ? config.imminentColor() : config.overlayTextColor();

        // Title: "Next Clan Event"
        panelComponent.getChildren().add(TitleComponent.builder()
            .text("Next Clan Event")
            .color(accentColor)
            .build());

        // Event name with countdown
        String timeUntil = nextEvent.getTimeUntil();
        String displayText = nextEvent.isHappeningNow() 
            ? "NOW!" 
            : timeUntil;
        
        panelComponent.getChildren().add(LineComponent.builder()
            .left(truncate(nextEvent.getName(), 15))
            .leftColor(config.overlayTextColor())
            .right(displayText)
            .rightColor(timeColor)
            .build());

        return panelComponent.render(graphics);
    }

    /**
     * Truncates a string to the specified length with ellipsis.
     */
    private String truncate(String text, int maxLength)
    {
        if (text == null)
        {
            return "";
        }
        if (text.length() <= maxLength)
        {
            return text;
        }
        return text.substring(0, maxLength - 3) + "...";
    }
}


package com.claneventlist;

import lombok.extern.slf4j.Slf4j;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.FontManager;
import net.runelite.client.ui.PluginPanel;
import net.runelite.client.util.LinkBrowser;

import javax.swing.*;
import javax.swing.border.EmptyBorder;
import java.awt.*;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.util.List;

/**
 * Side panel that displays a list of all clan events.
 */
@Slf4j
public class EventListPanel extends PluginPanel
{
    private static final Color BACKGROUND_COLOR = ColorScheme.DARK_GRAY_COLOR;
    private static final Color PANEL_COLOR = ColorScheme.DARKER_GRAY_COLOR;
    private static final Color HOVER_COLOR = ColorScheme.DARK_GRAY_HOVER_COLOR;
    private static final Color ACCENT_COLOR = new Color(255, 200, 0);
    private static final Color IMMINENT_COLOR = new Color(255, 100, 100);
    private static final Color HAPPENING_COLOR = new Color(100, 255, 100);
    private static final Color TODAY_COLOR = new Color(100, 200, 100);
    private static final Color LINK_COLOR = new Color(100, 180, 255);
    private static final Color TEXT_COLOR = Color.WHITE;
    private static final Color SECONDARY_TEXT = ColorScheme.LIGHT_GRAY_COLOR;
    
    private static final int EVENT_SPACING = 8;
    private static final int MAX_NAME_LENGTH = 40;
    private static final int MAX_DESC_LENGTH = 400;
    private static final int TEXT_WIDTH = 135; // Width for HTML text wrapping
    private static final int EVENT_PANEL_WIDTH = 165; // Max width for event cards

    private final EventListConfig config;
    private final GoogleSheetService sheetService;
    private final Runnable refreshCallback;

    private JPanel eventsContainer;
    private JLabel statusLabel;
    private JLabel lastUpdateLabel;

    public EventListPanel(EventListConfig config, GoogleSheetService sheetService, Runnable refreshCallback)
    {
        super(false); // Don't wrap content - we handle our own scrolling
        
        this.config = config;
        this.sheetService = sheetService;
        this.refreshCallback = refreshCallback;

        setLayout(new BorderLayout());
        setBackground(BACKGROUND_COLOR);

        add(createHeaderPanel(), BorderLayout.NORTH);
        add(createContentPanel(), BorderLayout.CENTER);
        add(createFooterPanel(), BorderLayout.SOUTH);
    }

    private JPanel createHeaderPanel()
    {
        JPanel headerPanel = new JPanel(new BorderLayout());
        headerPanel.setBackground(BACKGROUND_COLOR);
        headerPanel.setBorder(new EmptyBorder(8, 8, 8, 8));

        // Title
        JLabel titleLabel = new JLabel("Clan Events");
        titleLabel.setFont(FontManager.getRunescapeBoldFont().deriveFont(16f));
        titleLabel.setForeground(ACCENT_COLOR);
        headerPanel.add(titleLabel, BorderLayout.WEST);

        // Refresh button
        JButton refreshButton = new JButton("↻");
        refreshButton.setFont(FontManager.getRunescapeBoldFont().deriveFont(14f));
        refreshButton.setForeground(TEXT_COLOR);
        refreshButton.setBackground(PANEL_COLOR);
        refreshButton.setBorder(new EmptyBorder(5, 10, 5, 10));
        refreshButton.setFocusPainted(false);
        refreshButton.setCursor(Cursor.getPredefinedCursor(Cursor.HAND_CURSOR));
        refreshButton.setToolTipText("Refresh events from Google Sheet");
        refreshButton.addActionListener(e -> {
            if (refreshCallback != null)
            {
                refreshCallback.run();
            }
        });
        refreshButton.addMouseListener(new MouseAdapter()
        {
            @Override
            public void mouseEntered(MouseEvent e)
            {
                refreshButton.setBackground(HOVER_COLOR);
            }

            @Override
            public void mouseExited(MouseEvent e)
            {
                refreshButton.setBackground(PANEL_COLOR);
            }
        });
        headerPanel.add(refreshButton, BorderLayout.EAST);

        return headerPanel;
    }

    private JScrollPane createContentPanel()
    {
        eventsContainer = new JPanel();
        eventsContainer.setLayout(new GridBagLayout());
        eventsContainer.setBackground(BACKGROUND_COLOR);
        eventsContainer.setBorder(new EmptyBorder(0, 4, 0, 12)); // Padding inside scroll area (extra right for scrollbar)

        JScrollPane scrollPane = new JScrollPane(eventsContainer);
        scrollPane.setBackground(BACKGROUND_COLOR);
        scrollPane.getViewport().setBackground(BACKGROUND_COLOR);
        scrollPane.setBorder(null);
        scrollPane.setHorizontalScrollBarPolicy(JScrollPane.HORIZONTAL_SCROLLBAR_NEVER);
        scrollPane.setVerticalScrollBarPolicy(JScrollPane.VERTICAL_SCROLLBAR_AS_NEEDED);
        scrollPane.getVerticalScrollBar().setUnitIncrement(16);

        return scrollPane;
    }

    private JPanel createFooterPanel()
    {
        JPanel footerPanel = new JPanel(new BorderLayout());
        footerPanel.setBackground(BACKGROUND_COLOR);
        footerPanel.setBorder(new EmptyBorder(8, 8, 8, 8));

        statusLabel = new JLabel("Loading...");
        statusLabel.setFont(FontManager.getRunescapeSmallFont());
        statusLabel.setForeground(SECONDARY_TEXT);
        footerPanel.add(statusLabel, BorderLayout.WEST);

        lastUpdateLabel = new JLabel("");
        lastUpdateLabel.setFont(FontManager.getRunescapeSmallFont());
        lastUpdateLabel.setForeground(SECONDARY_TEXT);
        footerPanel.add(lastUpdateLabel, BorderLayout.EAST);

        return footerPanel;
    }

    /**
     * Updates the panel with the latest events.
     */
    public void updateEvents()
    {
        SwingUtilities.invokeLater(() -> {
            eventsContainer.removeAll();

            List<ClanEvent> events;
            if (config.showPastEvents())
            {
                events = sheetService.getCachedEvents();
            }
            else
            {
                events = sheetService.getUpcomingEvents();
            }

            int maxEvents = config.maxEventsInPanel();
            int displayCount = Math.min(events.size(), maxEvents);

            GridBagConstraints gbc = new GridBagConstraints();
            gbc.gridx = 0;
            gbc.gridy = 0;
            gbc.weightx = 1;
            gbc.fill = GridBagConstraints.HORIZONTAL;
            gbc.insets = new Insets(0, 0, EVENT_SPACING, 0);

            if (events.isEmpty())
            {
                gbc.anchor = GridBagConstraints.CENTER;
                gbc.fill = GridBagConstraints.NONE;
                
                JLabel noEventsLabel = new JLabel("No upcoming events");
                noEventsLabel.setFont(FontManager.getRunescapeFont());
                noEventsLabel.setForeground(SECONDARY_TEXT);
                noEventsLabel.setBorder(new EmptyBorder(20, 0, 10, 0));
                eventsContainer.add(noEventsLabel, gbc);
                gbc.gridy++;

                if (config.sheetId().isEmpty())
                {
                    JLabel configLabel = new JLabel("<html><center>Configure your Google Sheet ID<br>in the plugin settings</center></html>");
                    configLabel.setFont(FontManager.getRunescapeSmallFont());
                    configLabel.setForeground(SECONDARY_TEXT);
                    eventsContainer.add(configLabel, gbc);
                }
            }
            else
            {
                for (int i = 0; i < displayCount; i++)
                {
                    ClanEvent event = events.get(i);
                    
                    // No spacing after last item
                    if (i == displayCount - 1)
                    {
                        gbc.insets = new Insets(0, 0, 0, 0);
                    }
                    
                    eventsContainer.add(createEventPanel(event, i == 0), gbc);
                    gbc.gridy++;
                }

                if (events.size() > maxEvents)
                {
                    gbc.insets = new Insets(EVENT_SPACING, 0, 0, 0);
                    gbc.anchor = GridBagConstraints.CENTER;
                    gbc.fill = GridBagConstraints.NONE;
                    
                    JLabel moreLabel = new JLabel("+" + (events.size() - maxEvents) + " more events");
                    moreLabel.setFont(FontManager.getRunescapeSmallFont());
                    moreLabel.setForeground(SECONDARY_TEXT);
                    eventsContainer.add(moreLabel, gbc);
                    gbc.gridy++;
                }
            }

            // Add filler to push content to top
            gbc.weighty = 1;
            gbc.fill = GridBagConstraints.BOTH;
            eventsContainer.add(Box.createGlue(), gbc);

            // Update status
            statusLabel.setText(events.size() + " event" + (events.size() != 1 ? "s" : ""));

            // Update last fetch time
            long lastFetch = sheetService.getLastFetchTime();
            if (lastFetch > 0)
            {
                long minutesAgo = (System.currentTimeMillis() - lastFetch) / 60000;
                if (minutesAgo < 1)
                {
                    lastUpdateLabel.setText("Just now");
                }
                else
                {
                    lastUpdateLabel.setText(minutesAgo + "m ago");
                }
            }
            else
            {
                lastUpdateLabel.setText("Not synced");
            }

            eventsContainer.revalidate();
            eventsContainer.repaint();
        });
    }

    private JPanel createEventPanel(ClanEvent event, boolean isNext)
    {
        JPanel eventPanel = new JPanel();
        eventPanel.setLayout(new BoxLayout(eventPanel, BoxLayout.Y_AXIS));
        eventPanel.setBackground(PANEL_COLOR);
        eventPanel.setBorder(new EmptyBorder(8, 8, 8, 8));
        eventPanel.setAlignmentX(Component.LEFT_ALIGNMENT);
        
        // Constrain event panel width
        eventPanel.setMaximumSize(new Dimension(EVENT_PANEL_WIDTH, Integer.MAX_VALUE));

        // Determine status and colors
        boolean isHappening = event.isHappeningNow();
        boolean isImminent = event.isImminent();
        
        Color borderColor = null;
        if (isHappening)
        {
            borderColor = HAPPENING_COLOR;
        }
        else if (isImminent)
        {
            borderColor = IMMINENT_COLOR;
        }
        else if (isNext)
        {
            borderColor = ACCENT_COLOR;
        }

        // Apply border
        if (borderColor != null)
        {
            eventPanel.setBorder(BorderFactory.createCompoundBorder(
                BorderFactory.createLineBorder(borderColor, 2),
                new EmptyBorder(6, 6, 6, 6)
            ));
        }

        // Row 1: Event name (truncated with tooltip)
        String name = event.getName();
        String displayName = name;
        if (name.length() > MAX_NAME_LENGTH)
        {
            displayName = name.substring(0, MAX_NAME_LENGTH) + "...";
        }
        JLabel nameLabel = new JLabel(displayName);
        nameLabel.setFont(FontManager.getRunescapeBoldFont().deriveFont(12f));
        nameLabel.setToolTipText(name);
        if (isHappening)
        {
            nameLabel.setForeground(HAPPENING_COLOR);
        }
        else if (isImminent)
        {
            nameLabel.setForeground(IMMINENT_COLOR);
        }
        else if (isNext)
        {
            nameLabel.setForeground(ACCENT_COLOR);
        }
        else
        {
            nameLabel.setForeground(TEXT_COLOR);
        }
        nameLabel.setAlignmentX(Component.LEFT_ALIGNMENT);
        eventPanel.add(nameLabel);
        eventPanel.add(Box.createVerticalStrut(2));

        // Row 2: Date and time info
        String dateTimeText = event.getDayString() + " • " + event.getTimeRange();
        String duration = event.getDuration();
        if (duration != null)
        {
            dateTimeText += " (" + duration + ")";
        }
        
        JLabel dateTimeLabel = new JLabel(dateTimeText);
        dateTimeLabel.setFont(FontManager.getRunescapeSmallFont());
        dateTimeLabel.setForeground(event.isToday() ? TODAY_COLOR : SECONDARY_TEXT);
        dateTimeLabel.setAlignmentX(Component.LEFT_ALIGNMENT);
        eventPanel.add(dateTimeLabel);
        eventPanel.add(Box.createVerticalStrut(2));

        // Row 3: Countdown / Status
        if (isHappening)
        {
            JLabel statusLbl = new JLabel("● HAPPENING NOW");
            statusLbl.setFont(FontManager.getRunescapeBoldFont());
            statusLbl.setForeground(HAPPENING_COLOR);
            statusLbl.setAlignmentX(Component.LEFT_ALIGNMENT);
            eventPanel.add(statusLbl);
        }
        else if (event.isUpcoming())
        {
            JLabel countdownLabel = new JLabel("Starts in: " + event.getTimeUntil());
            countdownLabel.setFont(FontManager.getRunescapeBoldFont());
            countdownLabel.setForeground(isImminent ? IMMINENT_COLOR : TEXT_COLOR);
            countdownLabel.setAlignmentX(Component.LEFT_ALIGNMENT);
            eventPanel.add(countdownLabel);
        }

        // Row 4: Host and Location (if available)
        boolean hasHost = event.getHost() != null && !event.getHost().isEmpty();
        boolean hasLocation = event.getLocation() != null && !event.getLocation().isEmpty();
        
        if (hasHost || hasLocation)
        {
            eventPanel.add(Box.createVerticalStrut(4));
            
            StringBuilder details = new StringBuilder();
            if (hasHost)
            {
                details.append("Host: ").append(event.getHost());
            }
            if (hasHost && hasLocation)
            {
                details.append(" • ");
            }
            if (hasLocation)
            {
                details.append("@ ").append(event.getLocation());
            }
            
            JLabel detailsLabel = new JLabel("<html><body style='width: " + TEXT_WIDTH + "px'>" + 
                escapeHtml(details.toString()) + "</body></html>");
            detailsLabel.setFont(FontManager.getRunescapeSmallFont());
            detailsLabel.setForeground(SECONDARY_TEXT);
            detailsLabel.setAlignmentX(Component.LEFT_ALIGNMENT);
            eventPanel.add(detailsLabel);
        }

        // Row 5: Description (if available, with text wrapping)
        if (event.getDescription() != null && !event.getDescription().isEmpty())
        {
            eventPanel.add(Box.createVerticalStrut(4));
            
            String desc = event.getDescription();
            String fullDesc = desc;
            if (desc.length() > MAX_DESC_LENGTH)
            {
                desc = desc.substring(0, MAX_DESC_LENGTH) + "...";
            }
            // Use HTML for text wrapping with constrained width
            String htmlDesc = "<html><body style='width: " + TEXT_WIDTH + "px'>" + 
                escapeHtml(desc) + "</body></html>";
            JLabel descLabel = new JLabel(htmlDesc);
            descLabel.setFont(FontManager.getRunescapeSmallFont());
            descLabel.setForeground(SECONDARY_TEXT);
            descLabel.setAlignmentX(Component.LEFT_ALIGNMENT);
            if (fullDesc.length() > MAX_DESC_LENGTH)
            {
                descLabel.setToolTipText("<html><body style='width: 300px'>" + 
                    escapeHtml(fullDesc) + "</body></html>");
            }
            eventPanel.add(descLabel);
        }

        // Row 6: Link button (if URL available)
        if (event.hasUrl())
        {
            eventPanel.add(Box.createVerticalStrut(6));
            
            JLabel linkLabel = new JLabel("[Link] More Info");
            linkLabel.setFont(FontManager.getRunescapeSmallFont());
            linkLabel.setForeground(LINK_COLOR);
            linkLabel.setCursor(Cursor.getPredefinedCursor(Cursor.HAND_CURSOR));
            linkLabel.setAlignmentX(Component.LEFT_ALIGNMENT);
            
            linkLabel.addMouseListener(new MouseAdapter()
            {
                @Override
                public void mouseClicked(MouseEvent e)
                {
                    LinkBrowser.browse(event.getUrl());
                }

                @Override
                public void mouseEntered(MouseEvent e)
                {
                    linkLabel.setText("<html><u>[Link] More Info</u></html>");
                }

                @Override
                public void mouseExited(MouseEvent e)
                {
                    linkLabel.setText("[Link] More Info");
                }
            });
            
            eventPanel.add(linkLabel);
        }

        // Hover effect for the whole panel
        final Color originalBg = PANEL_COLOR;
        eventPanel.addMouseListener(new MouseAdapter()
        {
            @Override
            public void mouseEntered(MouseEvent e)
            {
                eventPanel.setBackground(HOVER_COLOR);
            }

            @Override
            public void mouseExited(MouseEvent e)
            {
                eventPanel.setBackground(originalBg);
            }
        });

        return eventPanel;
    }

    /**
     * Shows an error message in the panel.
     */
    public void showError(String message)
    {
        SwingUtilities.invokeLater(() -> {
            eventsContainer.removeAll();

            GridBagConstraints gbc = new GridBagConstraints();
            gbc.gridx = 0;
            gbc.gridy = 0;
            gbc.anchor = GridBagConstraints.CENTER;

            JLabel errorLabel = new JLabel("<html><center>" + message + "</center></html>");
            errorLabel.setFont(FontManager.getRunescapeFont());
            errorLabel.setForeground(IMMINENT_COLOR);
            errorLabel.setBorder(new EmptyBorder(20, 0, 20, 0));
            eventsContainer.add(errorLabel, gbc);

            statusLabel.setText("Error");
            
            eventsContainer.revalidate();
            eventsContainer.repaint();
        });
    }

    /**
     * Shows a loading state in the panel.
     */
    public void showLoading()
    {
        SwingUtilities.invokeLater(() -> {
            eventsContainer.removeAll();

            GridBagConstraints gbc = new GridBagConstraints();
            gbc.gridx = 0;
            gbc.gridy = 0;
            gbc.anchor = GridBagConstraints.CENTER;

            JLabel loadingLabel = new JLabel("Loading events...");
            loadingLabel.setFont(FontManager.getRunescapeFont());
            loadingLabel.setForeground(SECONDARY_TEXT);
            loadingLabel.setBorder(new EmptyBorder(20, 0, 20, 0));
            eventsContainer.add(loadingLabel, gbc);

            statusLabel.setText("Loading...");

            eventsContainer.revalidate();
            eventsContainer.repaint();
        });
    }

    /**
     * Escapes HTML special characters in a string.
     */
    private String escapeHtml(String text)
    {
        if (text == null)
        {
            return "";
        }
        return text
            .replace("&", "&amp;")
            .replace("<", "&lt;")
            .replace(">", "&gt;")
            .replace("\"", "&quot;")
            .replace("\n", "<br>");
    }
}


package com.claneventlist;

import net.runelite.client.RuneLite;
import net.runelite.client.externalplugins.ExternalPluginManager;

public class EventListPluginTest
{
	public static void main(String[] args) throws Exception
	{
		ExternalPluginManager.loadBuiltin(EventListPlugin.class);
		RuneLite.main(args);
	}
}


