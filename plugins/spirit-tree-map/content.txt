package com.mjhylkema.TeleportMaps.definition;

import lombok.Getter;

@Getter
public class GameObjectDefinition
{
	private int objectId;
	private int worldPointX;
	private int worldPointY;
}

package com.mjhylkema.TeleportMaps.definition;

import lombok.Getter;

@Getter
public class MushtreeDefinition
{
	@Getter
	static private int width = 30;
	@Getter
	static private int height = 35;

	private String name;
	private int x;
	private int y;
	private HotKeyDefinition hotkey;
	private GameObjectDefinition mushtreeObject;
}

package com.mjhylkema.TeleportMaps.definition;

import lombok.Getter;

@Getter
public class AdventureLogEntryDefinition
{
	private String name;
	private int x;
	private int y;
	private HotKeyDefinition hotkey;
}

package com.mjhylkema.TeleportMaps.definition;

import lombok.Getter;

@Getter
public class HotKeyDefinition
{
	@Getter
	static private int width = 20;
	@Getter
	static private int height = 20;
	private int x;
	private int y;
}

package com.mjhylkema.TeleportMaps.definition;

import lombok.Getter;

@Getter
public class ObeliskDefinition extends AdventureLogEntryDefinition
{
	@Getter
	static private int width = 20;
	@Getter
	static private int height = 45;
	private int spriteEnabled;
	private int spriteHover;
	private int spriteSelected;
	private int obeliskObjectId;
	private LabelDefinition label;
}

package com.mjhylkema.TeleportMaps.definition;

import lombok.Getter;

@Getter
public class TreeDefinition extends AdventureLogEntryDefinition
{
	private int id;
	private int width;
	private int height;
	private int spriteEnabled;
	private int spriteHover;
	private int spriteSelected;
	private GameObjectDefinition treeObject;
}

package com.mjhylkema.TeleportMaps.definition;

import lombok.Getter;

@Getter
public class SkillsNecklaceDefinition extends AdventureLogEntryDefinition
{
	private int id;
	private int width;
	private int height;
	private int spriteEnabled;
	private int spriteHover;
	private int spriteDisabled;
}

package com.mjhylkema.TeleportMaps.definition;

import lombok.Getter;

@Getter
public class LabelDefinition
{
	@Getter
	static private int height = 20;
	private int x;
	private int y;
	private int width;
	private String title;
}

package com.mjhylkema.TeleportMaps.definition;

import lombok.Getter;
import net.runelite.client.game.SpriteOverride;

@Getter
public class SpriteDefinition implements SpriteOverride
{
	private int spriteId;
	private String fileName;
}
package com.mjhylkema.TeleportMaps.definition;

import lombok.Getter;

@Getter
public class MinecartDefinition extends AdventureLogEntryDefinition
{
	@Getter
	static private int width = 20;
	@Getter
	static private int height = 20;
	private int npcId;
}
package com.mjhylkema.TeleportMaps.definition;

import lombok.Getter;

@Getter
public class XericsDefinition extends AdventureLogEntryDefinition
{
	@Getter
	static private int width = 23;
	@Getter
	static private int height = 23;

	private int index;
	private LabelDefinition label;
}
package com.mjhylkema.TeleportMaps;

import net.runelite.client.config.Config;
import net.runelite.client.config.ConfigGroup;
import net.runelite.client.config.ConfigItem;
import net.runelite.client.config.ConfigSection;

@ConfigGroup("teleportmaps")
public interface TeleportMapsConfig extends Config
{
	String KEY_DISPLAY_HOTKEYS = "displayHotkeys";
	String KEY_SHOW_SPIRIT_TREE_MAP = "showSpiritTreeMap";
	String KEY_SHOW_MUSHTREE_MAP = "showMushtreeMap";
	String KEY_SHOW_MINECART_MAP = "showMinecartMap";
	String KEY_SHOW_XERICS_MAP = "showXericsMap";
	String KEY_SHOW_XERICS_MAP_LABELS = "showXericsMapLabels";
	String KEY_SHOW_XERICS_MAP_HOTKEY_LABELS = "showXericsMapHotkeyInLabels";
	String KEY_SHOW_OBELISK_MAP = "showObeliskMap";
	String KEY_SHOW_OBELISK_MAP_LABELS = "showObeliskMapLabels";
	String KEY_SHOW_OBELISK_MAP_HOTKEY_LABELS = "showObeliskMapHotkeyInLabels";
	String KEY_SHOW_SKILLS_NECKLACE_MAP = "showSkillsNecklaceMap";

	@ConfigSection(
		name = "Teleport Maps",
		description = "Toggle on/off the supported maps",
		position = 0
	)
	String teleportMaps = "teleportMaps";

	@ConfigSection(
		name = "Xeric's Map Settings",
		description = "Settings related to Xeric's Talisman Map",
		position = 1
	)
	String xericsMap = "xericsMap";

	@ConfigSection(
		name = "Obelisk Map Settings",
		description = "Settings related to the Wilderness Obelisk Map",
		position = 2
	)
	String obeliskMap = "obeliskMap";

	@ConfigSection(
		name = "General Settings",
		description = "Settings that apply to all maps",
		position = 3
	)
	String generalSettings = "generalSettings";

	@ConfigItem(
		keyName = KEY_SHOW_SPIRIT_TREE_MAP,
		name = "Spirit Tree Map",
		description = "Replace the Spirit Tree travel menu with an interactive map",
		section = teleportMaps
	)
	default boolean showSpiritTreeMap()
	{
		return true;
	}

	@ConfigItem(
		keyName = KEY_SHOW_MUSHTREE_MAP,
		name = "Fossil Island Mushtree Map",
		description = "Replace the Fossil Island Mushtree travel menu with an interactive map",
		section = teleportMaps
	)
	default boolean showMushtreeMap()
	{
		return true;
	}

	@ConfigItem(
		keyName = KEY_SHOW_MINECART_MAP,
		name = "Lovakengj Minecart Map",
		description = "Replace the minecart travel menu with an interactive map",
		section = teleportMaps
	)
	default boolean showMinecartMap()
	{
		return true;
	}

	@ConfigItem(
		keyName = KEY_SHOW_XERICS_MAP,
		name = "Xeric's Talisman Map",
		description = "Replace Xeric's talisman travel menu with an interactive map",
		section = teleportMaps
	)
	default boolean showXericsMap()
	{
		return true;
	}

	@ConfigItem(
		keyName = KEY_SHOW_OBELISK_MAP,
		name = "Wilderness Obelisk Map",
		description = "Replace the Wilderness obelisk set destination menu with an interactive map",
		section = teleportMaps
	)
	default boolean showObeliskMap()
	{
		return true;
	}

	@ConfigItem(
		keyName = KEY_SHOW_SKILLS_NECKLACE_MAP,
		name = "Skills Necklace Map",
		description = "Replace the Skills Necklace teleport menu with an interactive map",
		section = teleportMaps
	)
	default boolean showSkillsNecklaceMap()
	{
		return true;
	}

	@ConfigItem(
		keyName = KEY_SHOW_XERICS_MAP_LABELS,
		name = "Display labels",
		description = "Show named labels above each of the Xeric's Talisman teleport locations",
		section = xericsMap,
		position = 1
	)
	default boolean showXericsMapLabels()
	{
		return true;
	}

	@ConfigItem(
		keyName = KEY_SHOW_XERICS_MAP_HOTKEY_LABELS,
		name = "Show hotkey in labels",
		description = "Display the teleport hotkeys as part of the label, rather than hotkey icons",
		section = xericsMap,
		position = 2
	)
	default boolean showXericsMapHotkeyInLabels()
	{
		return true;
	}

	@ConfigItem(
		keyName = KEY_SHOW_OBELISK_MAP_LABELS,
		name = "Display labels",
		description = "Show named labels above each of the Wilderness Obelisk teleport locations",
		section = obeliskMap,
		position = 1
	)
	default boolean showObeliskMapLabels()
	{
		return false;
	}

	@ConfigItem(
		keyName = KEY_SHOW_OBELISK_MAP_HOTKEY_LABELS,
		name = "Show hotkey in labels",
		description = "Display the teleport hotkeys as part of the label, rather than hotkey icons",
		section = obeliskMap,
		position = 2
	)
	default boolean showObeliskMapHotkeyInLabels()
	{
		return false;
	}

	@ConfigItem(
		keyName = KEY_DISPLAY_HOTKEYS,
		name = "Display hotkeys",
		description = "Display the travel keyboard hotkey for each map location",
		section = generalSettings
	)
	default boolean displayHotkeys()
	{
		return true;
	}
}

package com.mjhylkema.TeleportMaps.ui;

/**
 * A listener interface for receiving UI component events
 * Credit to Antipixel for the original implementation
 */
public interface UIComponentEventListener
{
	/**
	 * Invoked upon a component event
	 * @param src the source component responsible for the event
	 */
	void onComponentEvent(UIComponent src);
}
package com.mjhylkema.TeleportMaps.ui;

import com.mjhylkema.TeleportMaps.definition.MushtreeDefinition;
import lombok.Getter;
import net.runelite.api.widgets.Widget;
import net.runelite.client.config.Keybind;

@Getter
public class Mushtree
{
	private Widget widget;
	private MushtreeDefinition definition;
	private Keybind hotkey;

	public Mushtree(MushtreeDefinition definition, Widget widget, Keybind hotkey)
	{
		this.definition = definition;
		this.widget = widget;
		this.hotkey = hotkey;
	}
}
package com.mjhylkema.TeleportMaps.ui;

import com.mjhylkema.TeleportMaps.definition.AdventureLogEntryDefinition;
import lombok.Getter;
import net.runelite.api.widgets.Widget;

@Getter
public class Xerics extends AdventureLogEntry
{
	private String displayedName;

	public Xerics(AdventureLogEntryDefinition definition, Widget widget, String shortcut, String displayedName)
	{
		super(definition, widget, shortcut);
		this.displayedName = displayedName;
	}
}

package com.mjhylkema.TeleportMaps.ui;

import net.runelite.api.widgets.Widget;

public class UIHotkey extends UIComponent
{
	private boolean visible = true;
	private UILabel label;

	public UIHotkey(Widget backgroundWidget, Widget labelWidget)
	{
		super(backgroundWidget);

		this.label = new UILabel(labelWidget);
	}

	@Override
	public void setX(int x)
	{
		// Match the position of the label
		// to that of the checkbox
		super.setX(x);
		this.label.setX(x);
	}

	@Override
	public void setY(int y)
	{
		// Match the position of the label
		// to that of the checkbox
		super.setY(y);
		this.label.setY(y + 1);
	}

	@Override
	public void setSize(int width, int height)
	{
		super.setSize(width, height);
		this.label.setSize(width, height);
	}

	public void setText(String text)
	{
		this.label.setText(text);
	}

	public void setVisibility(boolean visible)
	{
		this.visible = visible;
		super.setVisibility(visible);
		this.label.setVisibility(visible);
	}

	public boolean isVisible()
	{
		return this.visible;
	}
}

package com.mjhylkema.TeleportMaps.ui;

import com.mjhylkema.TeleportMaps.definition.TreeDefinition;
import lombok.Getter;
import net.runelite.api.widgets.Widget;

@Getter
public class Tree extends AdventureLogEntry
{
	private String displayedName;

	public Tree(TreeDefinition definition, Widget widget, String shortcut, String displayedName)
	{
		super(definition, widget, shortcut);
		this.displayedName = displayedName;
	}
}

package com.mjhylkema.TeleportMaps.ui;

import static java.lang.Integer.max;
import static java.lang.Integer.min;
import net.runelite.api.widgets.Widget;

public class UITeleport extends UIComponent
{
	private int spriteStandard;
	private int spriteHover;
	private int spriteDisabled;

	private boolean locked;

	private UIButton teleportButton;
	private UIHotkey hotkeyButton;
	private UILabel label;

	public UITeleport(Widget groupWidget, Widget teleport)
	{
		super(groupWidget);
		this.setOnHoverListener(this::onHover);
		this.setOnLeaveListener(this::onLeave);

		this.teleportButton = new UIButton(teleport);
	}

	@Override
	public void setPosition(int x, int y)
	{
		this.teleportButton.setPosition(x, y);
		this.revalidatePosition();
	}

	@Override
	public void setSize(int width, int height)
	{
		this.teleportButton.setSize(width, height);
		this.revalidateSize();
	}

	protected void onHover(UIComponent src)
	{
		this.teleportButton.getWidget().setSpriteId(this.teleportButton.getSpriteHover());
		this.teleportButton.getWidget().revalidate();
	}

	protected void onLeave(UIComponent src)
	{
		this.teleportButton.getWidget().setSpriteId(this.teleportButton.getSpriteStandard());
		this.teleportButton.getWidget().revalidate();
	}

	public void setLocked(boolean locked)
	{
		this.locked = locked;

		if (locked)
			this.teleportButton.setSprites(this.spriteDisabled, this.spriteDisabled);
		else
			this.teleportButton.setSprites(this.spriteStandard, this.spriteHover);
	}

	public void attachHotkey(UIHotkey hotkeyButton)
	{
		this.hotkeyButton = hotkeyButton;
		this.revalidatePosition();
		this.revalidateSize();
	}

	public void attachLabel(UILabel label)
	{
		this.label = label;
	}

	public void setLabelVisibility(boolean visible)
	{
		if (this.label != null)
			this.label.setVisibility(visible);
	}

	public void setHotkeyInLabel(boolean value)
	{
		if (this.label != null)
			this.label.setShowHotkey(value);
	}

	public void setHotKeyVisibility(boolean visible)
	{
		if (this.hotkeyButton != null)
		{
			this.hotkeyButton.setVisibility(visible);
			this.revalidatePosition();
			this.revalidateSize();
		}
	}

	public void setTeleportSprites(int standard, int hover, int disabled)
	{
		this.spriteStandard = standard;
		this.spriteHover = hover;
		this.spriteDisabled = disabled;

		if (locked)
			this.teleportButton.setSprites(this.spriteDisabled, this.spriteDisabled);
		else
			this.teleportButton.setSprites(this.spriteStandard, this.spriteHover);
	}

	public void revalidatePosition()
	{
		if (this.hotkeyButton != null && this.hotkeyButton.isVisible())
		{
			super.setPosition(
				min(this.teleportButton.getX(), this.hotkeyButton.getX()),
				min(this.teleportButton.getY(), this.hotkeyButton.getY()));
		}
		else
		{
			super.setPosition(this.teleportButton.getX(), this.teleportButton.getY());
		}

		this.getWidget().revalidate();
	}

	public void revalidateSize()
	{
		if (this.hotkeyButton != null && this.hotkeyButton.isVisible())
		{
			super.setSize(
				max(
					this.teleportButton.getXTotal(),
					this.hotkeyButton.getXTotal()
				) - min(this.teleportButton.getX(), this.hotkeyButton.getX()),
				max(
					this.teleportButton.getYTotal(),
					this.hotkeyButton.getYTotal()
				) - min(this.teleportButton.getY(), this.hotkeyButton.getY())
			);
		}
		else
		{
			super.setSize(this.teleportButton.getWidth(), this.teleportButton.getHeight());
		}

		this.getWidget().revalidate();
	}
}

package com.mjhylkema.TeleportMaps.ui;

import net.runelite.api.FontID;
import net.runelite.api.widgets.Widget;
import net.runelite.api.widgets.WidgetTextAlignment;

public class UILabel extends UIComponent
{
	protected static final int HOTKEY_LABEL_COLOR = 3287045; /*322805*/

	private String hotkey;
	private String labelText;

	public UILabel(Widget labelWidget)
	{
		super(labelWidget);

		// Set default font and text colour
		this.setFont(FontID.QUILL_8);
		this.setColour(HOTKEY_LABEL_COLOR);

		// Set the alignment to centre and enable text shadowing
		labelWidget.setXTextAlignment(WidgetTextAlignment.CENTER);
		labelWidget.setYTextAlignment(WidgetTextAlignment.CENTER);
	}

	public void setHotkey(String hotkey)
	{
		this.hotkey = hotkey;
	}

	public void setShowHotkey(boolean visible)
	{
		if (visible && !this.hotkey.isEmpty())
			this.getWidget().setText(this.hotkey + ". " + this.labelText);
		else
			this.getWidget().setText(this.labelText);

		this.getWidget().revalidate();
	}

	public void setText(String text)
	{
		this.labelText = text;
		this.getWidget().setText(text);
	}

	public void setFont(int fontID)
	{
		this.getWidget().setFontId(fontID);
	}

	public void setColour(int colour)
	{
		this.getWidget().setTextColor(colour);
	}
}
package com.mjhylkema.TeleportMaps.ui;

/**
 * A listener interface for receiving menu actions
 * Credit to Antipixel for the original implementation
 */
public interface MenuAction
{
	void onMenuAction();
}

package com.mjhylkema.TeleportMaps.ui;

import java.util.ArrayList;
import java.util.List;
import lombok.Getter;
import lombok.Setter;
import net.runelite.api.ScriptEvent;
import net.runelite.api.widgets.JavaScriptCallback;
import net.runelite.api.widgets.Widget;

/**
 * UI Component classes allow for complex user interface functionality by
 * wrapping the gaming widget and carefully controlling its behaviour.
 * This is a cut down version of the implementation by Antipixel
 */
public abstract class UIComponent
{
	private static final String BTN_NAME_FORMAT = "<col=ff9040>%s</col>";

	@Getter
	private Widget widget;

	/* Actions and events */
	private List<MenuAction> actions;

	@Setter
	private UIComponentEventListener hoverListener;

	@Setter
	private UIComponentEventListener leaveListener;


	/**
	 * Constructs a new UIComponent
	 * @param widget the underlying game widget
	 */
	public UIComponent(Widget widget)
	{
		this.widget = widget;

		// Assign the event listeners to the widget
		this.widget.setOnOpListener((JavaScriptCallback) this::onActionSelected);
		this.widget.setOnMouseOverListener((JavaScriptCallback) this::onMouseHover);
		this.widget.setOnMouseLeaveListener((JavaScriptCallback) this::onMouseLeave);
		this.widget.setHasListener(true);

		this.actions = new ArrayList<>();
	}

	/**
	 * Adds an action option to the component's menu
	 * @param action the action name
	 * @param callback the callback event, which is trigger upon the
	 *                 selection of this menu option
	 */
	public void addAction(String action, MenuAction callback)
	{
		this.widget.setAction(actions.size(), action);
		this.actions.add(callback);
	}

	/**
	 * Triggered upon the selection of menu option
	 * @param e the script event
	 */
	protected void onActionSelected(ScriptEvent e)
	{
		// If there's no actions specified, ignore
		if (this.actions.isEmpty())
			return;

		// Get the action action event object for this menu option
		MenuAction actionEvent = this.actions.get(e.getOp() - 1);

		// Call the action listener for this option
		actionEvent.onMenuAction();
	}

	/**
	 * Triggered upon the mouse entering the component
	 * @param e the script event
	 */
	protected void onMouseHover(ScriptEvent e)
	{
		// If a hover event is specified, trigger it
		if (this.hoverListener != null)
			this.hoverListener.onComponentEvent(this);
	}

	/**
	 * Triggered upon the mouse leaving the component
	 * @param e the script event
	 */
	protected void onMouseLeave(ScriptEvent e)
	{
		// If a leave event is specified, trigger it
		if (this.leaveListener != null)
			this.leaveListener.onComponentEvent(this);
	}

	/**
	 * Sets a listener which will be called upon the mouse
	 * hovering over the widget
	 * @param listener the listener
	 */
	public void setOnHoverListener(UIComponentEventListener listener)
	{
		this.hoverListener = listener;
	}

	/**
	 * Sets a listener which will be called upon the mouse
	 * exiting from over the widget
	 * @param listener the listener
	 */
	public void setOnLeaveListener(UIComponentEventListener listener)
	{
		this.leaveListener = listener;
	}

	/**
	 * Sets the name of the component widget
	 * @param name the component name
	 */
	public void setName(String name)
	{
		this.widget.setName(String.format(BTN_NAME_FORMAT, name));
	}

	/**
	 * Sets the component size
	 * @param width the component width
	 * @param height the component height
	 */
	public void setSize(int width, int height)
	{
		this.widget.setOriginalWidth(width);
		this.widget.setOriginalHeight(height);
		this.widget.revalidate();
	}

	/**
	 * Sets the position of the component, relative
	 * to the parent layer widget
	 * @param x the x position
	 * @param y the y position
	 */
	public void setPosition(int x, int y)
	{
		this.setX(x);
		this.setY(y);
	}

	/**
	 * Sets the X position of the component, relative
	 * to the parent layer
	 * @param x the x position
	 */
	public void setX(int x)
	{
		this.widget.setOriginalX(x);
	}

	/**
	 * Sets the Y position of the component, relative
	 * to the parent layer
	 * @param y the x position
	 */
	public void setY(int y)
	{
		this.widget.setOriginalY(y);
	}

	/**
	 * Gets the X position of the component, relative
	 * to the the parent layer
	 * @return the x position
	 */
	public int getX()
	{
		return this.widget.getOriginalX();
	}

	/**
	 * Gets the Y position of the component, relative
	 * to the the parent layer
	 * @return the y position
	 */
	public int getY()
	{
		return this.widget.getOriginalY();
	}

	public int getXTotal()
	{
		return this.widget.getOriginalX() + this.widget.getOriginalWidth();
	}

	public int getYTotal()
	{
		return this.widget.getOriginalY() + this.widget.getOriginalHeight();
	}

	public int getWidth()
	{
		return this.widget.getOriginalWidth();
	}

	public int getHeight()
	{
		return this.widget.getOriginalHeight();
	}


	/**
	 * Sets the visibility of the component
	 * @param visible true for visible, false for hidden
	 */
	public void setVisibility(boolean visible)
	{
		this.widget.setHidden(!visible);
		this.widget.revalidate();
	}

	public boolean isVisible()
	{
		return !this.widget.isHidden();
	}
}
package com.mjhylkema.TeleportMaps.ui;

import com.mjhylkema.TeleportMaps.definition.AdventureLogEntryDefinition;
import lombok.Getter;
import net.runelite.api.widgets.Widget;

@Getter
public class AdventureLogEntry<T extends AdventureLogEntryDefinition>
{
	private Widget widget;
	private T definition;
	private String keyShortcut;

	public AdventureLogEntry(T definition, Widget widget, String shortcut)
	{
		this.definition = definition;
		this.widget = widget;
		this.keyShortcut = shortcut;
	}
}

package com.mjhylkema.TeleportMaps.ui;

import net.runelite.api.widgets.Widget;

/**
 * This class wraps a game widget and gives it the functionality
 * of a button, with the option of a second sprite shown on hover.
 * Credit to Antipixel for the original implementation
 */
public class UIButton extends UIComponent
{
	private int spriteStandard;
	private int spriteHover;

	/**
	 * Constructs a new button component
	 * @param widget the underlying widget
	 */
	public UIButton(Widget widget)
	{
		super(widget);

		// Blank the sprites
		this.spriteStandard = -1;
		this.spriteHover = -1;
	}

	/**
	 * Sets the button sprite for both standard and hover
	 * @param standard the standard sprite id
	 * @param hover the sprite to display on hover
	 */
	public void setSprites(int standard, int hover)
	{
		this.spriteStandard = standard;
		this.spriteHover = hover;

		// Update the widgets sprite
		this.getWidget().setSpriteId(this.spriteStandard);
	}

	public int getSpriteStandard()
	{
		return spriteStandard;
	}

	public int getSpriteHover()
	{
		return spriteHover;
	}
}
package com.mjhylkema.TeleportMaps.components;

import com.google.common.collect.LinkedHashMultimap;
import com.google.common.collect.Multimap;
import com.mjhylkema.TeleportMaps.TeleportMapsConfig;
import com.mjhylkema.TeleportMaps.TeleportMapsPlugin;
import com.mjhylkema.TeleportMaps.definition.MushtreeDefinition;
import com.mjhylkema.TeleportMaps.ui.Mushtree;
import com.mjhylkema.TeleportMaps.ui.UIButton;
import com.mjhylkema.TeleportMaps.ui.UIHotkey;
import com.mjhylkema.TeleportMaps.ui.UITeleport;
import java.util.Collection;
import java.util.HashMap;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import javax.inject.Inject;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.coords.WorldPoint;
import net.runelite.api.events.GameObjectSpawned;
import net.runelite.api.events.WidgetLoaded;
import net.runelite.api.widgets.JavaScriptCallback;
import net.runelite.api.widgets.Widget;
import net.runelite.api.widgets.WidgetType;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.config.Keybind;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.events.ConfigChanged;

@Slf4j
public class MushtreeMap extends BaseMap
{
	/* Definition JSON files */
	private static final String DEF_FILE_MUSHTREES = "/MushtreeMap/MushtreeDefinitions.json";

	/* Sprite IDs, dimensions and positions */
	private static final int MAP_SPRITE_ID = -19300;
	private static final int MAP_SPRITE_WIDTH = 467;
	private static final int MAP_SPRITE_HEIGHT = 311;
	private static final int MUSHTREE_SPRITE_ID = -19301;
	private static final int MUSHTREE_HIGHLIGHTED_SPRITE_ID = -19302;
	private static final int MUSHTREE_DISABLED_SPRITE_ID = -19303;
	private static final int MUSHTREE_SELECTED_SPRITE_ID = -19304;
	private static final int CLOSE_BUTTON_SPRITE_ID = 537;
	private static final int CLOSE_BUTTON_WIDTH = 26;
	private static final int CLOSE_BUTTON_HEIGH = 23;
	private static final int CLOSE_BUTTON_X = 380;
	private static final int CLOSE_BUTTON_Y = 15;

	private static final int MUSHTREE_DIALOG_ID = 608;
	private static final String TRAVEL_ACTION = "Travel";
	private static final String MUSHTREE_LABEL_NAME_PATTERN = "<col=8f8f8f>([0-9])\\.</col> (.+)";

	private MushtreeDefinition[] mushtreeDefinitions;
	private HashMap<String, MushtreeDefinition> mushtreeDefinitionsLookup;
	private HashMap<String, Mushtree> availableMushtrees;
	private Multimap<Integer, MushtreeDefinition> mushtreeObjectIdLookup = LinkedHashMultimap.create();
	private MushtreeDefinition latestMushtree;

	@Inject
	public MushtreeMap(TeleportMapsPlugin plugin, TeleportMapsConfig config, Client client, ClientThread clientThread)
	{
		super(plugin, config, client, clientThread, config.showMushtreeMap());
		this.loadDefinitions();
		this.buildTreeDefinitionLookup();
	}

	private void loadDefinitions()
	{
		this.mushtreeDefinitions = this.plugin.loadDefinitionResource(MushtreeDefinition[].class, DEF_FILE_MUSHTREES);
	}

	private void buildTreeDefinitionLookup()
	{
		this.mushtreeDefinitionsLookup = new HashMap<>();
		for (MushtreeDefinition treeDefinition: this.mushtreeDefinitions)
		{
			// Place the tree definition in the lookup table indexed by its name
			this.mushtreeDefinitionsLookup.put(treeDefinition.getName(), treeDefinition);
			this.mushtreeObjectIdLookup.put(treeDefinition.getMushtreeObject().getObjectId(), treeDefinition);
		}
	}

	@Subscribe
	public void onWidgetLoaded(WidgetLoaded e)
	{
		if (!this.isActive())
			return;

		if (e.getGroupId() == MUSHTREE_DIALOG_ID)
		{
			// To avoid the default mushtree dialog list flashing on the screen briefly, always hide it upfront.
			// These widgets will be un-hidden in the invokeLater if it's not the "Spirit Tree Locations".
			setWidgetsHidden(MUSHTREE_DIALOG_ID, new int[] {
				0
			}, true);

			this.clientThread.invokeLater(() ->
			{
				Widget mushtreeDialog = this.client.getWidget(MUSHTREE_DIALOG_ID, 1);
				if (mushtreeDialog == null ||
					mushtreeDialog.getChild(1) == null ||
					!mushtreeDialog.getChild(1).getText().equals("Mycelium Transportation System"))
				{
					setWidgetsHidden(MUSHTREE_DIALOG_ID, new int[] {
						0
					}, false);
					return;
				}

				Widget mushtreeInterfaceContainer = this.plugin.getClient().getWidget(MUSHTREE_DIALOG_ID, 0);

				if (mushtreeInterfaceContainer == null)
					return;

				this.buildAvailableMushtreeList();
				this.hideInterfaceChildren(mushtreeInterfaceContainer);
				this.createMapWidget(mushtreeInterfaceContainer);
				this.createMushtreeWidgets(mushtreeInterfaceContainer);
				this.createEscapeButton(mushtreeInterfaceContainer);

				setWidgetsHidden(MUSHTREE_DIALOG_ID, new int[]{0}, false);
			});
		}
	}

	@Subscribe
	public void onConfigChanged(ConfigChanged e)
	{
		switch (e.getKey())
		{
			case TeleportMapsConfig.KEY_SHOW_MUSHTREE_MAP:
				this.setActive(config.showMushtreeMap());
			default:
				super.onConfigChanged(e);
		}
	}

	@Subscribe
	public void onGameObjectSpawned(GameObjectSpawned e)
	{
		final int gameObjectId = e.getGameObject().getId();
		if (mushtreeObjectIdLookup.containsKey(gameObjectId))
		{
			final WorldPoint worldPoint = e.getTile().getWorldLocation();

			Collection<MushtreeDefinition> definitions = mushtreeObjectIdLookup.get(gameObjectId);

			latestMushtree = definitions.stream().filter(def -> {
				return def.getName().equals("Your house")
					|| (def.getMushtreeObject().getWorldPointX() == worldPoint.getX()
					&& def.getMushtreeObject().getWorldPointY() == worldPoint.getY());
			}).findFirst().orElse(null);

			log.debug("Latest Mushtree: {}", latestMushtree.getName());
		}
	}

	private void hideInterfaceChildren(Widget mushtreeInterface)
	{
		Widget[] children = mushtreeInterface.getStaticChildren();

		mushtreeInterface.setOriginalHeight(20);

		Widget mushtreeDialog = children[0]; //client.getWidget(MUSHTREE_DIALOG_ID, 1);
		mushtreeDialog.setHidden(true);

		Widget buttonParent = children[1]; //client.getWidget(MUSHTREE_DIALOG_ID, 2);
		buttonParent.setHidden(true);

		mushtreeInterface.revalidate();
	}

	/**
	 * Constructs the list of trees available for the player to use
	 */
	private void buildAvailableMushtreeList()
	{
		this.availableMushtrees = new HashMap<>();

		// Compile the pattern that will match the teleport label
		// and place the hotkey and teleport name into groups
		Pattern labelPattern = Pattern.compile(MUSHTREE_LABEL_NAME_PATTERN);

		// Get the parent widgets containing the tree list
		Widget mushtreeList = this.client.getWidget(MUSHTREE_DIALOG_ID, 2);

		// Fetch all tree label widgets
		Widget[] mushtreeButtons = mushtreeList.getStaticChildren();

		for (Widget mushtree : mushtreeButtons)
		{
			Widget label = mushtree.getStaticChildren()[1];

			// Create a pattern matcher with the widgets text content
			Matcher matcher = labelPattern.matcher(label.getText());

			// If the text doesn't match the pattern, skip onto the next
			if (!matcher.matches())
				continue;

			// Extract the pertinent information
			char hotKey = Character.toUpperCase(matcher.group(1).charAt(0));
			String mushtreeName = matcher.group(2);

			// Don't include unavailable mushtrees in available collection..
			if (mushtreeName.contains("Not yet found"))
				continue;

			MushtreeDefinition treeDefinition = this.mushtreeDefinitionsLookup.get(mushtreeName);

			// If a tree label by this name cannot be found in the tree definitions lookup,
			// skip. This likely means a new tree has been added to the Spirit Tree list that
			// hasn't been updated into the definitions yet
			if (treeDefinition == null)
				continue;

			this.availableMushtrees.put(mushtreeName, new Mushtree(treeDefinition, mushtree.getStaticChildren()[0], new Keybind(hotKey, 0)));
		}
	}

	private void createMapWidget(Widget mushtreeInterface)
	{
		this.createSpriteWidget(mushtreeInterface, MAP_SPRITE_WIDTH, MAP_SPRITE_HEIGHT, 0, 0, MAP_SPRITE_ID);
	}

	private void createMushtreeWidgets(Widget mushtreeInterface)
	{
		this.clearTeleports();

		for (MushtreeDefinition mushtreeDefinition : this.mushtreeDefinitions)
		{
			Widget widgetContainer = mushtreeInterface.createChild(-1, WidgetType.GRAPHIC);
			Widget treeWidget = mushtreeInterface.createChild(-1, WidgetType.GRAPHIC);

			UITeleport mushtreeTeleport = new UITeleport(widgetContainer, treeWidget);

			if (latestMushtree != null && latestMushtree == mushtreeDefinition)
				mushtreeTeleport.setTeleportSprites(MUSHTREE_SELECTED_SPRITE_ID, MUSHTREE_HIGHLIGHTED_SPRITE_ID, MUSHTREE_DISABLED_SPRITE_ID);
			else
				mushtreeTeleport.setTeleportSprites(MUSHTREE_SPRITE_ID, MUSHTREE_HIGHLIGHTED_SPRITE_ID, MUSHTREE_DISABLED_SPRITE_ID);

			mushtreeTeleport.setPosition(mushtreeDefinition.getX(), mushtreeDefinition.getY());
			mushtreeTeleport.setSize(mushtreeDefinition.getWidth(), mushtreeDefinition.getHeight());
			mushtreeTeleport.setName(mushtreeDefinition.getName());

			if (isMushtreeAvailable(mushtreeDefinition.getName()))
			{
				Mushtree mushtree = this.availableMushtrees.get(mushtreeDefinition.getName());

				mushtreeTeleport.addAction(TRAVEL_ACTION, () -> this.triggerButton(mushtree));
				mushtreeTeleport.getWidget().setOnKeyListener((JavaScriptCallback) e ->
				{
					if (mushtree.getHotkey().getKeyCode() == e.getTypedKeyChar())
						this.triggerButton(mushtree);
				});

				UIHotkey hotkey = this.createHotKey(mushtreeInterface, mushtreeDefinition.getHotkey(), mushtree.getHotkey().toString());
				mushtreeTeleport.attachHotkey(hotkey);
			}
			else
			{
				mushtreeTeleport.setLocked(true);
			}

			this.addTeleport(mushtreeTeleport);
		}
	}

	private void createEscapeButton(Widget mushtreeInterface)
	{
		Widget closeWidget = mushtreeInterface.createChild(-1, WidgetType.GRAPHIC);
		UIButton closeButton = new UIButton(closeWidget);
		closeButton.setPosition(CLOSE_BUTTON_X, CLOSE_BUTTON_Y);
		closeButton.setSize(CLOSE_BUTTON_WIDTH, CLOSE_BUTTON_HEIGH);
		closeButton.setSprites(CLOSE_BUTTON_SPRITE_ID, CLOSE_BUTTON_SPRITE_ID);
		closeButton.addAction("Close", this::triggerExit);
		closeWidget.revalidate();
	}

	private void triggerExit()
	{
		this.clientThread.invoke(() -> {
			Widget mushtreeDialog = this.client.getWidget(MUSHTREE_DIALOG_ID, 1);
			Widget mushtreeExit = mushtreeDialog != null ? mushtreeDialog.getChild(13) : null;
			if (mushtreeExit != null)
				this.plugin.getClient().runScript(mushtreeExit.getOnOpListener());
		});
	}

	private boolean isMushtreeAvailable(String mushtreeName)
	{
		return this.availableMushtrees.containsKey(mushtreeName);
	}

	private void triggerButton(Mushtree mushtree)
	{
		this.clientThread.invokeLater(() -> {
			Widget mushtreeWidget = mushtree.getWidget();
			Object[] listener = mushtreeWidget.getOnKeyListener();

			if (listener == null)
				return;

			listener[1] = mushtree.getHotkey().getKeyCode();
			this.client.runScript(listener);
		});
	}
}

package com.mjhylkema.TeleportMaps.components;

public interface IMap
{
	boolean isActive();
}

package com.mjhylkema.TeleportMaps.components.adventureLog;

import com.mjhylkema.TeleportMaps.components.IMap;
import java.util.ArrayList;
import java.util.List;
import javax.inject.Inject;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.events.ScriptPreFired;
import net.runelite.api.widgets.ComponentID;
import net.runelite.api.widgets.InterfaceID;
import net.runelite.api.widgets.Widget;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.eventbus.Subscribe;

@Slf4j
public class AdventureLogComposite implements IMap
{
	final private int MENU_SETUP_SCRIPT_ID = 219;
	static class AdventureLog
	{
		static final int CONTAINER = 0;
		static final int EVENT_LISTENER_LIST = 1;
		static final int SCROLLBAR = 2;
		static final int LIST = 3;
		static final int CLOSE_BUTTON = 4;
	}

	final private List<IAdventureMap> adventureLogMaps;
	final private Client client;
	final private ClientThread clientThread;

	@Inject
	public AdventureLogComposite(Client client, ClientThread clientThread)
	{
		this.client = client;
		this.clientThread = clientThread;
		this.adventureLogMaps = new ArrayList<>();
	}

	public void addAdventureLogMap(IAdventureMap map)
	{
		this.adventureLogMaps.add(map);
	}

	@Subscribe
	private void onScriptPreFired(ScriptPreFired ev)
	{
		switch (ev.getScriptId())
		{
			case MENU_SETUP_SCRIPT_ID:
			{
				String title = (String) client.getObjectStack()[client.getObjectStackSize() - 1];

				for (IAdventureMap map: this.adventureLogMaps)
				{
					if (!map.isActive())
						continue;

					boolean response = map.matchesTitle(title);

					if (response)
					{
						// To avoid the default adventure log list flashing on the screen briefly, always hide it upfront.
						setAdventureLogWidgetsHidden(new int[] {
							AdventureLog.CONTAINER,
							AdventureLog.LIST,
							AdventureLog.SCROLLBAR
						}, true);

						this.clientThread.invokeLater(() ->
						{
							Widget adventureLogContainer = this.client.getWidget(ComponentID.ADVENTURE_LOG_CONTAINER);
							if (adventureLogContainer == null)
								return;

							setAdventureLogWidgetsHidden(new int[] {
								AdventureLog.CONTAINER
							}, false);

							map.buildInterface(adventureLogContainer);
						});
						break;
					}
				}
				break;
			}
			default:
				return;
		}
	}

	@Override
	public boolean isActive()
	{
		for (IAdventureMap map : this.adventureLogMaps)
		{
			if (map.isActive())
				return true;
		}
		return false;
	}

	protected void setAdventureLogWidgetsHidden(int[] childIDs, boolean hidden)
	{
		for(int childId : childIDs)
		{
			Widget widget = this.client.getWidget(InterfaceID.ADVENTURE_LOG, childId);
			if (widget != null)
			{
				widget.setHidden(hidden);
			}
		}
	}
}

package com.mjhylkema.TeleportMaps.components.adventureLog;

import com.mjhylkema.TeleportMaps.TeleportMapsConfig;
import com.mjhylkema.TeleportMaps.TeleportMapsPlugin;
import com.mjhylkema.TeleportMaps.components.BaseMap;
import com.mjhylkema.TeleportMaps.definition.MinecartDefinition;
import com.mjhylkema.TeleportMaps.ui.AdventureLogEntry;
import com.mjhylkema.TeleportMaps.ui.UIHotkey;
import com.mjhylkema.TeleportMaps.ui.UITeleport;
import java.util.HashMap;
import java.util.HashSet;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import javax.inject.Inject;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.ChatMessageType;
import net.runelite.api.Client;
import net.runelite.api.events.NpcSpawned;
import net.runelite.api.widgets.InterfaceID;
import net.runelite.api.widgets.Widget;
import net.runelite.api.widgets.WidgetType;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.events.ConfigChanged;

@Slf4j
public class MinecartMap extends BaseMap implements IAdventureMap
{
	/* Definition JSON files */
	private static final String DEF_FILE_MINECART = "/MinecartMap/MinecartDefinitions.json";

	/* Sprite IDs, dimensions and positions */
	private static final int MAP_SPRITE_ID = -19400;
	private static final int MAP_SPRITE_WIDTH = 330;
	private static final int MAP_SPRITE_HEIGHT = 285;
	private static final int MINECART_SPRITE_ID = -19501;
	private static final int MINECART_HIGHLIGHTED_SPRITE_ID = -19502;
	private static final int MINECART_DISABLED_SPRITE_ID = -19503;
	private static final int MINECART_SELECTED_SPRITE_ID = -19504;

	private static final int SCRIPT_TRIGGER_KEY = 1437;
	private static final String LABEL_NAME_PATTERN = "<col=735a28>(.+)</col>: (<col=5f5f5f>)?(.+)";
	private static final String TRAVEL_ACTION = "Travel";
	private static final String EXAMINE_ACTION = "Examine";
	private static final int ADVENTURE_LOG_CONTAINER_BACKGROUND = 0;
	private static final int ADVENTURE_LOG_CONTAINER_TITLE = 1;
	private static final String MENU_TITLE = "Minecart rides: .*";

	private MinecartDefinition[] minecartDefinitions;
	private HashMap<String, MinecartDefinition> minecartDefinitionLookup;
	private HashMap<String, AdventureLogEntry<MinecartDefinition>> availableLocations;
	private HashSet<Integer> minecartNpcLookup;
	private int latestNpc;

	@Inject
	public MinecartMap(TeleportMapsPlugin plugin, TeleportMapsConfig config, Client client, ClientThread clientThread)
	{
		super(plugin, config, client, clientThread, config.showMinecartMap());
		this.loadDefinitions();
		this.buildMinecartDefinitionLookup();
	}

	@Override
	public boolean matchesTitle(String title)
	{
		return title.matches(MENU_TITLE);
	}


	private void loadDefinitions()
	{
		this.minecartDefinitions = this.plugin.loadDefinitionResource(MinecartDefinition[].class, DEF_FILE_MINECART);
	}

	private void buildMinecartDefinitionLookup()
	{
		this.minecartDefinitionLookup = new HashMap<>();
		this.minecartNpcLookup = new HashSet<>();
		for (MinecartDefinition minecartDefinition: this.minecartDefinitions)
		{
			// Place the minecart definition in the lookup table indexed by its name
			this.minecartDefinitionLookup.put(minecartDefinition.getName(), minecartDefinition);
			this.minecartNpcLookup.add(minecartDefinition.getNpcId());
		}
	}

	public void buildInterface(Widget adventureLogContainer)
	{
		this.hideAdventureLogContainerChildren(adventureLogContainer);
		this.buildAvailableTeleportList();

		this.createMapWidget(adventureLogContainer);
		this.createTeleportWidgets(adventureLogContainer);
	}

	@Subscribe
	public void onConfigChanged(ConfigChanged e)
	{
		switch (e.getKey())
		{
			case TeleportMapsConfig.KEY_SHOW_MINECART_MAP:
				this.setActive(config.showMinecartMap());
			default:
				super.onConfigChanged(e);
		}
	}

	@Subscribe
	public void onNpcSpawned(NpcSpawned e)
	{
		if (this.minecartNpcLookup.contains(e.getNpc().getId()))
		{
			latestNpc = e.getNpc().getId();

			log.debug("Latest Minecart NPC: {}", e.getNpc().getName());
		}
	}

	private void hideAdventureLogContainerChildren(Widget adventureLogContainer)
	{
		Widget title = adventureLogContainer.getChild(ADVENTURE_LOG_CONTAINER_TITLE);
		if (title != null)
			title.setHidden(true);
	}

	/**
	 * Constructs the list of Minecart teleports available for the player to use
	 */
	private void buildAvailableTeleportList()
	{
		this.availableLocations = new HashMap<>();

		// Compile the pattern that will match the teleport label
		// and place the hotkey and teleport name into groups
		Pattern labelPattern = Pattern.compile(LABEL_NAME_PATTERN);

		// Get the parent widgets containing the teleport locations list
		Widget teleportList = this.client.getWidget(InterfaceID.ADVENTURE_LOG, 3);

		// Fetch all teleport label widgets
		Widget[] labelWidgets = teleportList.getDynamicChildren();

		for (Widget child : labelWidgets)
		{
			String shortcutKey;
			String disabledColor;
			String teleportName;

			// Create a pattern matcher with the widgets text content
			Matcher matcher = labelPattern.matcher(child.getText());

			// If the text doesn't match the pattern, skip onto the next
			if (!matcher.matches())
				continue;

			// Extract the pertinent information
			shortcutKey = matcher.group(1);
			disabledColor = matcher.group(2);
			teleportName = matcher.group(3);

			// Don't include unavailable teleports in available collection..
			if (disabledColor != null)
				continue;


			MinecartDefinition minecartDefinition = this.minecartDefinitionLookup.get(teleportName);

			if (minecartDefinition == null)
				continue;

			this.availableLocations.put(teleportName, new AdventureLogEntry<>(minecartDefinition, child, shortcutKey));
		}
	}

	private void createMapWidget(Widget container)
	{
		this.createSpriteWidget(container,
			MAP_SPRITE_WIDTH,
			MAP_SPRITE_HEIGHT,
			66,
			43,
			MAP_SPRITE_ID);
	}

	private void createTeleportWidgets(Widget container)
	{
		this.clearTeleports();

		for (MinecartDefinition minecartDefinition : this.minecartDefinitions)
		{
			Widget widgetContainer = container.createChild(-1, WidgetType.GRAPHIC);
			Widget teleportWidget = container.createChild(-1, WidgetType.GRAPHIC);

			UITeleport teleport = new UITeleport(widgetContainer, teleportWidget);

			if (this.latestNpc != 0 && this.latestNpc == minecartDefinition.getNpcId())
				teleport.setTeleportSprites(MINECART_SELECTED_SPRITE_ID, MINECART_HIGHLIGHTED_SPRITE_ID, MINECART_DISABLED_SPRITE_ID);
			else
				teleport.setTeleportSprites(MINECART_SPRITE_ID, MINECART_HIGHLIGHTED_SPRITE_ID, MINECART_DISABLED_SPRITE_ID);

			teleport.setPosition(minecartDefinition.getX(), minecartDefinition.getY());
			teleport.setSize(minecartDefinition.getWidth(), minecartDefinition.getHeight());
			teleport.setName(minecartDefinition.getName());

			if (isLocationUnlocked(minecartDefinition.getName()))
			{
				AdventureLogEntry<MinecartDefinition> adventureLogEntry = this.availableLocations.get(minecartDefinition.getName());

				teleport.addAction(TRAVEL_ACTION, () -> this.triggerTeleport(adventureLogEntry));

				UIHotkey hotkey = this.createHotKey(container, minecartDefinition.getHotkey(), adventureLogEntry.getKeyShortcut());
				teleport.attachHotkey(hotkey);
			}
			else
			{
				teleport.setLocked(true);
				teleport.addAction(EXAMINE_ACTION, () -> this.triggerLockedMessage(minecartDefinition));
			}

			this.addTeleport(teleport);
		}
	}

	private boolean isLocationUnlocked(String teleportName)
	{
		return this.availableLocations.containsKey(teleportName);
	}

	private void triggerTeleport(AdventureLogEntry<MinecartDefinition> adventureLogEntry)
	{
		this.clientThread.invokeLater(() -> this.client.runScript(SCRIPT_TRIGGER_KEY, this.client.getWidget(0xBB0003).getId(), adventureLogEntry.getWidget().getIndex()));
	}

	private void triggerLockedMessage(MinecartDefinition minecartDefinition)
	{
		this.clientThread.invokeLater(() -> this.client.addChatMessage(ChatMessageType.GAMEMESSAGE, "", String.format("You are unable to travel to %s.", minecartDefinition.getName()), null));
	}
}

package com.mjhylkema.TeleportMaps.components.adventureLog;

import com.mjhylkema.TeleportMaps.TeleportMapsConfig;
import com.mjhylkema.TeleportMaps.TeleportMapsPlugin;
import com.mjhylkema.TeleportMaps.components.BaseMap;
import com.mjhylkema.TeleportMaps.definition.SkillsNecklaceDefinition;
import com.mjhylkema.TeleportMaps.ui.AdventureLogEntry;
import com.mjhylkema.TeleportMaps.ui.UIHotkey;
import com.mjhylkema.TeleportMaps.ui.UITeleport;
import net.runelite.api.ChatMessageType;
import net.runelite.api.Client;
import net.runelite.api.widgets.InterfaceID;
import net.runelite.api.widgets.Widget;
import net.runelite.api.widgets.WidgetType;
import net.runelite.client.callback.ClientThread;
import javax.inject.Inject;
import lombok.extern.slf4j.Slf4j;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.events.ConfigChanged;

import java.util.HashMap;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

@Slf4j
public class SkillsNecklaceMap extends BaseMap implements IAdventureMap
{
	/* Definition JSON files */
	private static final String DEF_FILE_SKILLS_NECKLACE = "/SkillsNecklaceMap/SkillsNecklaceDefinitions.json";

	/* Sprite IDs, dimensions and positions */
	private static final int MAP_SPRITE_ID = -19700;
	private static final int MAP_SPRITE_WIDTH = 507;
	private static final int MAP_SPRITE_HEIGHT = 319;
	private static final int SCRIPT_TRIGGER_KEY = 1437;
	private static final String LABEL_NAME_PATTERN = "<col=735a28>(.+)</col>: (<col=5f5f5f>)?(.+)";
	private static final String TRAVEL_ACTION = "Travel";
	private static final String EXAMINE_ACTION = "Examine";
	private static final int ADVENTURE_LOG_CONTAINER_BACKGROUND = 0;
	private static final int ADVENTURE_LOG_CONTAINER_TITLE = 1;

	// There has got to be a better way to do this. All other jewelry seems to use the chat window.
	// But they all say this same phrase. Lucky that skills necklace uses the Adventure Log.
	private static final String MENU_TITLE = "Where would you like to teleport to?";

	private SkillsNecklaceDefinition[] skillsNecklaceDefinitions;
	private HashMap<String, SkillsNecklaceDefinition> skillsNecklaceDefinitionLookup;
	private HashMap<String, AdventureLogEntry<SkillsNecklaceDefinition>> availableLocations;

	@Inject
	public SkillsNecklaceMap(TeleportMapsPlugin plugin, TeleportMapsConfig config, Client client, ClientThread clientThread)
	{
		super(plugin, config, client, clientThread, config.showSkillsNecklaceMap());

		this.loadDefinitions();
		this.buildSkillsNecklaceDefinitionLookup();
	}

	@Override
	public boolean matchesTitle(String title)
	{
		return title.equals(MENU_TITLE); // Regex matches fails because title string contains ? character
	}

	private void loadDefinitions()
	{
		this.skillsNecklaceDefinitions = this.plugin.loadDefinitionResource(SkillsNecklaceDefinition[].class, DEF_FILE_SKILLS_NECKLACE);
	}

	private void buildSkillsNecklaceDefinitionLookup()
	{
		this.skillsNecklaceDefinitionLookup = new HashMap<>();
		for (SkillsNecklaceDefinition skillsNecklaceDefinition : this.skillsNecklaceDefinitions)
		{
			// Place the skills necklace definition in the lookup table indexed by its name
			this.skillsNecklaceDefinitionLookup.put(skillsNecklaceDefinition.getName(), skillsNecklaceDefinition);
		}
	}

	@Subscribe
	public void onConfigChanged(ConfigChanged e)
	{
		switch (e.getKey())
		{
			case TeleportMapsConfig.KEY_SHOW_SKILLS_NECKLACE_MAP:
				this.setActive(config.showSkillsNecklaceMap());
			default:
				super.onConfigChanged(e);
		}
	}

	@Override
	public void buildInterface(Widget adventureLogContainer)
	{
		this.hideAdventureLogContainerChildren(adventureLogContainer);
		this.buildAvailableTeleportList();

		this.createMapWidget(adventureLogContainer);
		this.createTeleportWidgets(adventureLogContainer);
	}

	private void hideAdventureLogContainerChildren(Widget adventureLogContainer)
	{
		Widget title = adventureLogContainer.getChild(ADVENTURE_LOG_CONTAINER_TITLE);
		if (title != null)
		{
			title.setHidden(true);
		}
	}

	/**
	 * NOTE: Not even sure if this is needed. Needs confirmation if Zeah needs to be unlocked first.
	 * Farming and Woodcutting might be blocked like Windertodt on a games necklace.
	 */
	private void buildAvailableTeleportList()
	{
		this.availableLocations = new HashMap<>();

		// Compile the pattern that will match the teleport label
		// and place the hotkey and teleport name into groups
		Pattern labelPattern = Pattern.compile(LABEL_NAME_PATTERN);

		// Get the parent widgets containing the teleport locations list
		Widget teleportList = this.client.getWidget(InterfaceID.ADVENTURE_LOG, 3);

		// Fetch all teleport label widgets
		Widget[] labelWidgets = teleportList.getDynamicChildren();

		for (Widget child : labelWidgets)
		{
			String shortcutKey;
			String disabledColor;
			String teleportName;

			// Create a pattern matcher with the widgets text content
			Matcher matcher = labelPattern.matcher(child.getText());

			// If the text doesn't match the pattern, skip onto the next
			if (!matcher.matches())
			{
				continue;
			}

			// Extract the pertinent information
			shortcutKey = matcher.group(1);
			disabledColor = matcher.group(2);
			teleportName = matcher.group(3);

			// Don't include unavailable teleports in available collection..
			if (disabledColor != null)
			{
				continue;
			}

			SkillsNecklaceDefinition skillsNecklaceDefinition = this.skillsNecklaceDefinitionLookup.get(teleportName);

			if (skillsNecklaceDefinition == null)
			{
				continue;
			}

			this.availableLocations.put(teleportName, new AdventureLogEntry<>(skillsNecklaceDefinition, child, shortcutKey));
		}
	}

	private void createMapWidget(Widget container)
	{
		this.createSpriteWidget(container,
			MAP_SPRITE_WIDTH,
			MAP_SPRITE_HEIGHT,
			4,
			12,
			MAP_SPRITE_ID);
	}

	private void createTeleportWidgets(Widget container)
	{
		this.clearTeleports();

		for (SkillsNecklaceDefinition skillsNecklaceDefinition : this.skillsNecklaceDefinitions)
		{
			Widget widgetContainer = container.createChild(-1, WidgetType.GRAPHIC);
			Widget teleportWidget = container.createChild(-1, WidgetType.GRAPHIC);

			UITeleport teleport = new UITeleport(widgetContainer, teleportWidget);
			teleport.setTeleportSprites(skillsNecklaceDefinition.getSpriteEnabled(), skillsNecklaceDefinition.getSpriteHover(), skillsNecklaceDefinition.getSpriteDisabled());

			teleport.setPosition(skillsNecklaceDefinition.getX(), skillsNecklaceDefinition.getY());
			teleport.setSize(skillsNecklaceDefinition.getWidth(), skillsNecklaceDefinition.getHeight());
			teleport.setName(skillsNecklaceDefinition.getName());

			if (this.isLocationUnlocked(skillsNecklaceDefinition.getName()))
			{
				AdventureLogEntry<SkillsNecklaceDefinition> adventureLogEntry = this.availableLocations.get(skillsNecklaceDefinition.getName());

				teleport.addAction(TRAVEL_ACTION, () -> this.triggerTeleport(adventureLogEntry));

				UIHotkey hotkey = this.createHotKey(container, skillsNecklaceDefinition.getHotkey(), adventureLogEntry.getKeyShortcut());
				teleport.attachHotkey(hotkey);
			}
			else
			{
				teleport.setLocked(true);
				teleport.addAction(EXAMINE_ACTION, () -> this.triggerLockedMessage(skillsNecklaceDefinition));
			}

			this.addTeleport(teleport);
		}

	}

	private boolean isLocationUnlocked(String teleportName)
	{
		return this.availableLocations.containsKey(teleportName);
	}

	private void triggerLockedMessage(SkillsNecklaceDefinition skillsNecklaceDefinition)
	{
		this.clientThread.invokeLater(() -> this.client.addChatMessage(ChatMessageType.GAMEMESSAGE, "", String.format("You are unable to travel to %s.", skillsNecklaceDefinition.getName()), null));
	}

	private void triggerTeleport(AdventureLogEntry<SkillsNecklaceDefinition> adventureLogEntry)
	{
		this.clientThread.invokeLater(() -> this.client.runScript(SCRIPT_TRIGGER_KEY, this.client.getWidget(0xBB0003).getId(), adventureLogEntry.getWidget().getIndex()));
	}
}
package com.mjhylkema.TeleportMaps.components.adventureLog;

import com.google.common.collect.LinkedHashMultimap;
import com.google.common.collect.Multimap;
import com.mjhylkema.TeleportMaps.TeleportMapsConfig;
import com.mjhylkema.TeleportMaps.TeleportMapsPlugin;
import com.mjhylkema.TeleportMaps.components.BaseMap;
import com.mjhylkema.TeleportMaps.definition.TreeDefinition;
import com.mjhylkema.TeleportMaps.ui.Tree;
import com.mjhylkema.TeleportMaps.ui.UIHotkey;
import com.mjhylkema.TeleportMaps.ui.UITeleport;
import java.util.Collection;
import java.util.HashMap;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import javax.inject.Inject;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.ChatMessageType;
import net.runelite.api.Client;
import net.runelite.api.coords.WorldPoint;
import net.runelite.api.events.GameObjectSpawned;
import net.runelite.api.widgets.InterfaceID;
import net.runelite.api.widgets.Widget;
import net.runelite.api.widgets.WidgetType;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.events.ConfigChanged;

@Slf4j
public class SpiritTreeMap extends BaseMap implements IAdventureMap
{
	/* Definition JSON files */
	private static final String DEF_FILE_TREES = "/SpiritTreeMap/TreeDefinitions.json";

	/* Sprite IDs, dimensions and positions */
	private static final int MAP_SPRITE_ID = -19000;
	private static final int MAP_SPRITE_WIDTH = 508;
	private static final int MAP_SPRITE_HEIGHT = 319;
	private static final int HOUSE_SPRITE_ID = -19001;
	private static final int HOUSE_SPRITE_WIDTH = 53;
	private static final int HOUSE_SPRITE_HEIGHT = 49;
	private static final int HOUSE_WIDGET_X = 36;
	private static final int HOUSE_WIDGET_Y = 241;
	private static final int DISABLED_TREE_SPRITE_ID = -19102;
	private static final int DISABLED_TREE_SPRITE_WIDTH = 19;
	private static final int DISABLED_TREE_SPRITE_HEIGHT = 27;

	private static final int SCRIPT_TRIGGER_KEY = 1437;
	private static final String TREE_LABEL_NAME_PATTERN = "<col=735a28>(.+)</col>: (<col=5f5f5f>)?(.+)";
	private static final String TRAVEL_ACTION = "Travel";
	private static final String EXAMINE_ACTION = "Examine";
	private static final int ADVENTURE_LOG_CONTAINER_BACKGROUND = 0;
	private static final int ADVENTURE_LOG_CONTAINER_TITLE = 1;
	private static final String MENU_TITLE = "Spirit Tree Locations";
	private static final String YOUR_HOUSE_STRING = "Your house";
	private static final int SPIRITUAL_FAIRY_RING_ID = 29229;

	private TreeDefinition[] treeDefinitions;
	private HashMap<String, TreeDefinition> treeDefinitionsLookup;
	private HashMap<String, Tree> availableTrees;
	private Multimap<Integer, TreeDefinition> treeObjectIdLookup = LinkedHashMultimap.create();
	private TreeDefinition latestTree;

	@Inject
	public SpiritTreeMap(TeleportMapsPlugin plugin, TeleportMapsConfig config, Client client, ClientThread clientThread)
	{
		super(plugin, config, client, clientThread, config.showSpiritTreeMap());
		this.loadDefinitions();
		this.buildTreeDefinitionLookup();
	}

	private void loadDefinitions()
	{
		this.treeDefinitions = this.plugin.loadDefinitionResource(TreeDefinition[].class, DEF_FILE_TREES);
	}

	private void buildTreeDefinitionLookup()
	{
		this.treeDefinitionsLookup = new HashMap<>();
		for (TreeDefinition treeDefinition: this.treeDefinitions)
		{
			// Place the tree definition in the lookup table indexed by its name
			this.treeDefinitionsLookup.put(treeDefinition.getName(), treeDefinition);
			this.treeObjectIdLookup.put(treeDefinition.getTreeObject().getObjectId(), treeDefinition);

			if (treeDefinition.getName().equals(YOUR_HOUSE_STRING))
				this.treeObjectIdLookup.put(SPIRITUAL_FAIRY_RING_ID, treeDefinition); // Spiritual Fairy ring..
		}
	}

	public void buildInterface(Widget adventureLogContainer)
	{
		this.hideAdventureLogContainerChildren(adventureLogContainer);
		this.buildAvailableTreeList();

		this.createMapWidget(adventureLogContainer);
		this.createHouseWidget(adventureLogContainer);
		this.createTeleportWidgets(adventureLogContainer);
	}

	@Subscribe
	public void onConfigChanged(ConfigChanged e)
	{
		switch (e.getKey())
		{
			case TeleportMapsConfig.KEY_SHOW_SPIRIT_TREE_MAP:
				this.setActive(config.showSpiritTreeMap());
			default:
				super.onConfigChanged(e);
		}
	}

	@Subscribe
	public void onGameObjectSpawned(GameObjectSpawned e)
	{
		final int gameObjectId = e.getGameObject().getId();
		if (treeObjectIdLookup.containsKey(gameObjectId))
		{
			final WorldPoint worldPoint = e.getTile().getWorldLocation();

			Collection<TreeDefinition> definitions = treeObjectIdLookup.get(gameObjectId);

			latestTree = definitions.stream().filter(def -> {
				return def.getName().equals(YOUR_HOUSE_STRING)
					|| (def.getTreeObject().getWorldPointX() == worldPoint.getX()
					&& def.getTreeObject().getWorldPointY() == worldPoint.getY());
			}).findFirst().orElse(null);

			log.debug("Latest Spirit Tree: {}", latestTree.getName());
		}
	}

	private void hideAdventureLogContainerChildren(Widget adventureLogContainer)
	{
		Widget existingBackground = adventureLogContainer.getChild(ADVENTURE_LOG_CONTAINER_BACKGROUND);
		if (existingBackground != null)
			existingBackground.setHidden(true);

		Widget title = adventureLogContainer.getChild(ADVENTURE_LOG_CONTAINER_TITLE);
		if (title != null)
			title.setHidden(true);
	}

	/**
	 * Constructs the list of trees available for the player to use
	 */
	private void buildAvailableTreeList()
	{
		this.availableTrees = new HashMap<>();

		// Compile the pattern that will match the teleport label
		// and place the hotkey and teleport name into groups
		Pattern labelPattern = Pattern.compile(TREE_LABEL_NAME_PATTERN);

		// Get the parent widgets containing the tree list
		Widget treeList = this.plugin.getClient().getWidget(InterfaceID.ADVENTURE_LOG, 3);

		// Fetch all tree label widgets
		Widget[] labelWidgets = treeList.getDynamicChildren();

		for (Widget child : labelWidgets)
		{
			String shortcutKey;
			String disabledColor;
			String treeName;

			String displayedName;

			// Create a pattern matcher with the widgets text content
			Matcher matcher = labelPattern.matcher(child.getText());

			// If the text doesn't match the pattern, skip onto the next
			if (!matcher.matches())
				continue;

			// Extract the pertinent information
			shortcutKey = matcher.group(1);
			disabledColor = matcher.group(2);
			treeName = matcher.group(3);

			// Don't include unavailable trees in available collection..
			if (disabledColor != null)
				continue;

			// Your house may include a bracketed location afterwards.
			// Use this full name for the button, but don't use it for the lookup key.
			if (treeName.contains("Your house"))
			{
				displayedName = treeName;
				treeName = "Your house";
			}
			else
			{
				displayedName = treeName;
			}

			TreeDefinition treeDefinition = this.treeDefinitionsLookup.get(treeName);

			// If a tree label by this name cannot be found in the tree definitions lookup,
			// skip. This likely means a new tree has been added to the Spirit Tree list that
			// hasn't been updated into the definitions yet
			if (treeDefinition == null)
				continue;

			this.availableTrees.put(treeName, new Tree(treeDefinition, child, shortcutKey, displayedName));
		}
	}

	private void createMapWidget(Widget container)
	{
		this.createSpriteWidget(container,
			MAP_SPRITE_WIDTH,
			MAP_SPRITE_HEIGHT,
			0,
			0,
			MAP_SPRITE_ID);
	}

	private void createHouseWidget(Widget container)
	{
		this.createSpriteWidget(container,
			HOUSE_SPRITE_WIDTH,
			HOUSE_SPRITE_HEIGHT,
			HOUSE_WIDGET_X,
			HOUSE_WIDGET_Y,
			HOUSE_SPRITE_ID);
	}

	private void createTeleportWidgets(Widget container)
	{
		this.clearTeleports();

		for (TreeDefinition treeDefinition : this.treeDefinitions)
		{
			Widget widgetContainer = container.createChild(-1, WidgetType.GRAPHIC);
			Widget treeWidget = container.createChild(-1, WidgetType.GRAPHIC);

			UITeleport treeTeleport = new UITeleport(widgetContainer, treeWidget);

			treeTeleport.setPosition(treeDefinition.getX(), treeDefinition.getY());
			if (latestTree != null && latestTree == treeDefinition)
				treeTeleport.setTeleportSprites(treeDefinition.getSpriteSelected(), treeDefinition.getSpriteHover(), DISABLED_TREE_SPRITE_ID);
			else
				treeTeleport.setTeleportSprites(treeDefinition.getSpriteEnabled(), treeDefinition.getSpriteHover(), DISABLED_TREE_SPRITE_ID);

			if (isTreeUnlocked(treeDefinition.getName()))
			{
				Tree tree = this.availableTrees.get(treeDefinition.getName());

				treeTeleport.setSize(treeDefinition.getWidth(), treeDefinition.getHeight());
				treeTeleport.setName(tree.getDisplayedName());
				treeTeleport.addAction(TRAVEL_ACTION, () -> this.triggerTeleport(tree));

				UIHotkey hotkey = this.createHotKey(container, treeDefinition.getHotkey(), tree.getKeyShortcut());
				treeTeleport.attachHotkey(hotkey);
			}
			else
			{
				treeTeleport.setLocked(true);
				treeTeleport.setSize(DISABLED_TREE_SPRITE_WIDTH, DISABLED_TREE_SPRITE_HEIGHT);
				treeTeleport.setName(treeDefinition.getName());
				treeTeleport.addAction(EXAMINE_ACTION, () -> this.triggerLockedMessage(treeDefinition));
			}

			this.addTeleport(treeTeleport);
		}
	}

	private boolean isTreeUnlocked(String treeName)
	{
		return this.availableTrees.containsKey(treeName);
	}

	private void triggerTeleport(Tree tree)
	{
		this.clientThread.invokeLater(() -> this.client.runScript(SCRIPT_TRIGGER_KEY, this.client.getWidget(0xBB0003).getId(), tree.getWidget().getIndex()));
	}

	private void triggerLockedMessage(TreeDefinition treeDefinition)
	{
		this.clientThread.invokeLater(() -> this.client.addChatMessage(ChatMessageType.GAMEMESSAGE, "", String.format("The Spirit Tree at %s is not available.", treeDefinition.getName()), null));
	}

	@Override
	public boolean matchesTitle(String title)
	{
		return title.equals(MENU_TITLE);
	}
}

package com.mjhylkema.TeleportMaps.components.adventureLog;

import com.mjhylkema.TeleportMaps.components.IMap;
import net.runelite.api.widgets.Widget;

public interface IAdventureMap extends IMap
{
	boolean matchesTitle(String title);
	void buildInterface(Widget adventureLogContainer);
}

package com.mjhylkema.TeleportMaps.components.adventureLog;

import com.mjhylkema.TeleportMaps.TeleportMapsConfig;
import com.mjhylkema.TeleportMaps.TeleportMapsPlugin;
import com.mjhylkema.TeleportMaps.components.BaseMap;
import com.mjhylkema.TeleportMaps.definition.ObeliskDefinition;
import com.mjhylkema.TeleportMaps.ui.AdventureLogEntry;
import com.mjhylkema.TeleportMaps.ui.UIHotkey;
import com.mjhylkema.TeleportMaps.ui.UILabel;
import com.mjhylkema.TeleportMaps.ui.UITeleport;
import java.awt.Color;
import java.util.HashMap;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import javax.inject.Inject;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.ChatMessageType;
import net.runelite.api.Client;
import net.runelite.api.events.GameObjectSpawned;
import net.runelite.api.widgets.InterfaceID;
import net.runelite.api.widgets.Widget;
import net.runelite.api.widgets.WidgetType;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.events.ConfigChanged;

@Slf4j
public class WildernessObeliskMap extends BaseMap implements IAdventureMap
{
	/* Definition JSON files */
	private static final String DEF_FILE_OBELISKS = "/WildernessObeliskMap/ObeliskDefinitions.json";

	/* Sprite IDs, dimensions and positions */
	private static final int MAP_SPRITE_ID = -19600;
	private static final int MAP_SPRITE_WIDTH = 474;
	private static final int MAP_SPRITE_HEIGHT = 295;
	private static final int OBELISK_SPRITE_DISABLED = -19601;

	private static final int SCRIPT_TRIGGER_KEY = 1437;
	private static final String LABEL_NAME_PATTERN = "<col=735a28>(.+)</col>: (<col=5f5f5f>)?(.+)";
	private static final String SET_ACTION = "Set";
	private static final String EXAMINE_ACTION = "Examine";
	private static final int ADVENTURE_LOG_CONTAINER_BACKGROUND = 0;
	private static final int ADVENTURE_LOG_CONTAINER_TITLE = 1;
	private static final String MENU_TITLE = "Select Obelisk destination";
	private static final int POH_OBELISK_ID = 31554;

	private ObeliskDefinition[] obeliskDefinitions;
	private HashMap<String, ObeliskDefinition> obeliskDefinitionLookup;
	private HashMap<String, AdventureLogEntry<ObeliskDefinition>> availableLocations;
	private HashMap<Integer, ObeliskDefinition> obeliskGameObjectLookup;
	private ObeliskDefinition latestObelisk;

	@Inject
	public WildernessObeliskMap(TeleportMapsPlugin plugin, TeleportMapsConfig config, Client client, ClientThread clientThread)
	{
		super(plugin, config, client, clientThread, config.showObeliskMap());
		this.loadDefinitions();
		this.buildObeliskDefinitionLookup();
	}

	@Override
	public boolean matchesTitle(String title)
	{
		return title.matches(MENU_TITLE);
	}

	private void loadDefinitions()
	{
		this.obeliskDefinitions = this.plugin.loadDefinitionResource(ObeliskDefinition[].class, DEF_FILE_OBELISKS);
	}

	private void buildObeliskDefinitionLookup()
	{
		this.obeliskDefinitionLookup = new HashMap<>();
		this.obeliskGameObjectLookup = new HashMap<>();
		for (ObeliskDefinition obeliskDefinition: this.obeliskDefinitions)
		{
			// Place the obelisk definition in the lookup table indexed by its name
			this.obeliskDefinitionLookup.put(obeliskDefinition.getName(), obeliskDefinition);
			this.obeliskGameObjectLookup.put(obeliskDefinition.getObeliskObjectId(), obeliskDefinition);
		}

		this.obeliskGameObjectLookup.put(POH_OBELISK_ID, null);
	}

	@Override
	public void buildInterface(Widget adventureLogContainer)
	{
		this.hideAdventureLogContainerChildren(adventureLogContainer);
		this.buildAvailableTeleportList();

		this.createMapWidget(adventureLogContainer);
		this.createTeleportWidgets(adventureLogContainer);
	}

	@Subscribe
	public void onConfigChanged(ConfigChanged e)
	{
		switch (e.getKey())
		{
			case TeleportMapsConfig.KEY_SHOW_OBELISK_MAP:
				this.setActive(config.showObeliskMap());
			case TeleportMapsConfig.KEY_SHOW_OBELISK_MAP_LABELS:
			case TeleportMapsConfig.KEY_SHOW_OBELISK_MAP_HOTKEY_LABELS:
			case TeleportMapsConfig.KEY_DISPLAY_HOTKEYS:
				this.updateTeleports((teleport) -> {
					teleport.setLabelVisibility(config.showObeliskMapLabels());
					teleport.setHotkeyInLabel(config.displayHotkeys() && config.showObeliskMapLabels() && config.showObeliskMapHotkeyInLabels());
					teleport.setHotKeyVisibility(config.displayHotkeys() && !(config.showObeliskMapLabels() && config.showObeliskMapHotkeyInLabels()));
				});
			default:
				super.onConfigChanged(e);
		}
	}

	@Subscribe
	public void onGameObjectSpawned(GameObjectSpawned e)
	{
		final int gameObjectId = e.getGameObject().getId();
		if (obeliskGameObjectLookup.containsKey(gameObjectId))
		{
			latestObelisk = obeliskGameObjectLookup.get(gameObjectId);
		}
	}

	private void hideAdventureLogContainerChildren(Widget adventureLogContainer)
	{
		Widget title = adventureLogContainer.getChild(ADVENTURE_LOG_CONTAINER_TITLE);
		if (title != null)
			title.setHidden(true);
	}

	/**
	 * Constructs the list of Obelisk teleports available for the player to use
	 */
	private void buildAvailableTeleportList()
	{
		this.availableLocations = new HashMap<>();

		// Compile the pattern that will match the teleport label
		// and place the hotkey and teleport name into groups
		Pattern labelPattern = Pattern.compile(LABEL_NAME_PATTERN);

		// Get the parent widgets containing the teleport locations list
		Widget teleportList = this.client.getWidget(InterfaceID.ADVENTURE_LOG, 3);

		// Fetch all teleport label widgets
		Widget[] labelWidgets = teleportList.getDynamicChildren();

		for (Widget child : labelWidgets)
		{
			String shortcutKey;
			String disabledColor;
			String teleportName;

			// Create a pattern matcher with the widgets text content
			Matcher matcher = labelPattern.matcher(child.getText());

			// If the text doesn't match the pattern, skip onto the next
			if (!matcher.matches())
				continue;

			// Extract the pertinent information
			shortcutKey = matcher.group(1);
			disabledColor = matcher.group(2);
			teleportName = matcher.group(3);

			// Don't include unavailable teleports in available collection..
			if (disabledColor != null)
				continue;

			ObeliskDefinition obeliskDefinition = this.obeliskDefinitionLookup.get(teleportName);

			if (obeliskDefinition == null)
				continue;

			this.availableLocations.put(teleportName, new AdventureLogEntry<>(obeliskDefinition, child, shortcutKey));
		}
	}

	private void createMapWidget(Widget container)
	{
		this.createSpriteWidget(container,
			MAP_SPRITE_WIDTH,
			MAP_SPRITE_HEIGHT,
			19,
			33,
			MAP_SPRITE_ID);
	}

	private void createTeleportWidgets(Widget container)
	{
		this.clearTeleports();

		for (ObeliskDefinition obeliskDefinition : this.obeliskDefinitions)
		{
			Widget widgetContainer = container.createChild(-1, WidgetType.GRAPHIC);
			Widget teleportWidget = container.createChild(-1, WidgetType.GRAPHIC);

			UITeleport teleport = new UITeleport(widgetContainer, teleportWidget);

			if (latestObelisk != null && latestObelisk == obeliskDefinition)
				teleport.setTeleportSprites(obeliskDefinition.getSpriteSelected(), obeliskDefinition.getSpriteHover(), OBELISK_SPRITE_DISABLED);
			else
				teleport.setTeleportSprites(obeliskDefinition.getSpriteEnabled(), obeliskDefinition.getSpriteHover(), OBELISK_SPRITE_DISABLED);

			teleport.setPosition(obeliskDefinition.getX(), obeliskDefinition.getY());
			teleport.setSize(obeliskDefinition.getWidth(), obeliskDefinition.getHeight());
			teleport.setName(obeliskDefinition.getName());

			UILabel teleportLabel = new UILabel(container.createChild(-1, WidgetType.TEXT));
			teleportLabel.getWidget().setTextColor(Color.white.getRGB());
			teleportLabel.getWidget().setTextShadowed(true);
			teleportLabel.setText(obeliskDefinition.getLabel().getTitle());
			teleportLabel.setPosition(obeliskDefinition.getLabel().getX(), obeliskDefinition.getLabel().getY());
			teleportLabel.setSize(obeliskDefinition.getLabel().getWidth(), obeliskDefinition.getLabel().getHeight());
			teleportLabel.setVisibility(config.showObeliskMapLabels());
			teleport.attachLabel(teleportLabel);

			if (isLocationUnlocked(obeliskDefinition.getName()))
			{
				AdventureLogEntry<ObeliskDefinition> adventureLogEntry = this.availableLocations.get(obeliskDefinition.getName());

				teleport.addAction(SET_ACTION, () -> this.triggerTeleport(adventureLogEntry));

				UIHotkey hotkey = this.createHotKey(container, obeliskDefinition.getHotkey(), adventureLogEntry.getKeyShortcut());
				teleportLabel.setHotkey(adventureLogEntry.getKeyShortcut());
				teleport.attachHotkey(hotkey);

				teleport.setHotkeyInLabel(config.displayHotkeys() && config.showObeliskMapLabels() && config.showObeliskMapHotkeyInLabels());
				teleport.setHotKeyVisibility(config.displayHotkeys() && !(config.showObeliskMapLabels() && config.showObeliskMapHotkeyInLabels()));
			}
			else
			{
				teleport.setLocked(true);
				teleport.addAction(EXAMINE_ACTION, () -> this.triggerLockedMessage(obeliskDefinition));
			}

			this.addTeleport(teleport);
		}
	}

	private boolean isLocationUnlocked(String teleportName)
	{
		return this.availableLocations.containsKey(teleportName);
	}

	private void triggerTeleport(AdventureLogEntry<ObeliskDefinition> adventureLogEntry)
	{
		this.clientThread.invokeLater(() -> this.client.runScript(SCRIPT_TRIGGER_KEY, this.client.getWidget(0xBB0003).getId(), adventureLogEntry.getWidget().getIndex()));
	}

	private void triggerLockedMessage(ObeliskDefinition obeliskDefinition)
	{
		this.clientThread.invokeLater(() -> this.client.addChatMessage(ChatMessageType.GAMEMESSAGE, "", String.format("You are unable to travel to %s.", obeliskDefinition.getName()), null));
	}
}

package com.mjhylkema.TeleportMaps.components.adventureLog;

import com.mjhylkema.TeleportMaps.TeleportMapsConfig;
import com.mjhylkema.TeleportMaps.TeleportMapsPlugin;
import com.mjhylkema.TeleportMaps.components.BaseMap;
import com.mjhylkema.TeleportMaps.definition.XericsDefinition;
import com.mjhylkema.TeleportMaps.ui.AdventureLogEntry;
import com.mjhylkema.TeleportMaps.ui.UIHotkey;
import com.mjhylkema.TeleportMaps.ui.UILabel;
import com.mjhylkema.TeleportMaps.ui.UITeleport;
import com.mjhylkema.TeleportMaps.ui.Xerics;
import java.awt.Color;
import java.util.HashMap;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import javax.inject.Inject;
import net.runelite.api.ChatMessageType;
import net.runelite.api.Client;
import net.runelite.api.widgets.InterfaceID;
import net.runelite.api.widgets.Widget;
import net.runelite.api.widgets.WidgetType;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.events.ConfigChanged;


public class XericsMap extends BaseMap implements IAdventureMap
{
	/* Definition JSON files */
	private static final String DEF_FILE_XERICS = "/XericsMap/XericsDefinitions.json";

	/* Sprite IDs, dimensions and positions */
	private static final int MAP_SPRITE_ID = -19400;
	private static final int MAP_SPRITE_WIDTH = 330;
	private static final int MAP_SPRITE_HEIGHT = 285;
	private static final int XERICS_SPRITE_ID = -19401;
	private static final int XERICS_HIGHLIGHTED_SPRITE_ID = -19402;
	private static final int XERICS_DISABLED_SPRITE_ID = -19403;

	private static final int SCRIPT_TRIGGER_KEY = 1437;
	private static final String XERICS_LABEL_NAME_PATTERN = "<col=735a28>(.+)</col>: (<col=5f5f5f>)?(.+)";
	private static final String TRAVEL_ACTION = "Travel";
	private static final String EXAMINE_ACTION = "Examine";
	private static final int ADVENTURE_LOG_CONTAINER_BACKGROUND = 0;
	private static final int ADVENTURE_LOG_CONTAINER_TITLE = 1;
	private static final String MENU_TITLE = "The talisman has .*";
	private static final String MENU_TITLE_MOUNTED = "Xeric's Talisman teleports";

	private XericsDefinition[] xericsDefinitions;
	private HashMap<Integer, XericsDefinition> xericsDefinitionsLookup;
	private HashMap<String, Xerics> availableLocations;

	@Inject
	public XericsMap(TeleportMapsPlugin plugin, TeleportMapsConfig config, Client client, ClientThread clientThread)
	{
		super(plugin, config, client, clientThread, config.showXericsMap());
		this.loadDefinitions();
		this.buildXericsDefinitionLookup();
	}

	@Override
	public boolean matchesTitle(String title)
	{
		return title.matches(MENU_TITLE) || title.matches(MENU_TITLE_MOUNTED);
	}

	private void loadDefinitions()
	{
		this.xericsDefinitions = this.plugin.loadDefinitionResource(XericsDefinition[].class, DEF_FILE_XERICS);
	}

	private void buildXericsDefinitionLookup()
	{
		this.xericsDefinitionsLookup = new HashMap<>();
		for (XericsDefinition xericsDefinition: this.xericsDefinitions)
		{
			// Place the xerics definition in the lookup table indexed by its name
			this.xericsDefinitionsLookup.put(xericsDefinition.getIndex(), xericsDefinition);
		}
	}

	public void buildInterface(Widget adventureLogContainer)
	{
		this.hideAdventureLogContainerChildren(adventureLogContainer);
		this.buildAvailableTeleportList();

		this.createMapWidget(adventureLogContainer);
		this.createTeleportWidgets(adventureLogContainer);
	}

	@Subscribe
	public void onConfigChanged(ConfigChanged e)
	{
		switch (e.getKey())
		{
			case TeleportMapsConfig.KEY_SHOW_XERICS_MAP:
				this.setActive(config.showXericsMap());
			case TeleportMapsConfig.KEY_SHOW_XERICS_MAP_LABELS:
			case TeleportMapsConfig.KEY_SHOW_XERICS_MAP_HOTKEY_LABELS:
			case TeleportMapsConfig.KEY_DISPLAY_HOTKEYS:
				this.updateTeleports((teleport) -> {
					teleport.setLabelVisibility(config.showXericsMapLabels());
					teleport.setHotkeyInLabel(config.displayHotkeys() && config.showXericsMapLabels() && config.showXericsMapHotkeyInLabels());
					teleport.setHotKeyVisibility(config.displayHotkeys() && !(config.showXericsMapLabels() && config.showXericsMapHotkeyInLabels()));
				});
			default:
				super.onConfigChanged(e);
		}
	}

	private void hideAdventureLogContainerChildren(Widget adventureLogContainer)
	{
		Widget title = adventureLogContainer.getChild(ADVENTURE_LOG_CONTAINER_TITLE);
		if (title != null)
			title.setHidden(true);
	}

	/**
	 * Constructs the list of Xeric's teleports available for the player to use
	 */
	private void buildAvailableTeleportList()
	{
		this.availableLocations = new HashMap<>();

		// Compile the pattern that will match the teleport label
		// and place the hotkey and teleport name into groups
		Pattern labelPattern = Pattern.compile(XERICS_LABEL_NAME_PATTERN);

		// Get the parent widgets containing the teleport locations list
		Widget teleportList = this.plugin.getClient().getWidget(InterfaceID.ADVENTURE_LOG, 3);

		// Fetch all teleport label widgets
		Widget[] labelWidgets = teleportList.getDynamicChildren();

		for (Widget child : labelWidgets)
		{
			String shortcutKey;
			String disabledColor;
			String teleportName;

			// Create a pattern matcher with the widgets text content
			Matcher matcher = labelPattern.matcher(child.getText());

			// If the text doesn't match the pattern, skip onto the next
			if (!matcher.matches())
				continue;

			// Extract the pertinent information
			shortcutKey = matcher.group(1);
			disabledColor = matcher.group(2);
			teleportName = matcher.group(3);

			// Don't include unavailable teleports in available collection..
			if (disabledColor != null)
				continue;

			XericsDefinition xericsDefinition = this.xericsDefinitionsLookup.get(child.getIndex());

			if (xericsDefinition == null)
				continue;

			this.availableLocations.put(xericsDefinition.getName(), new Xerics(xericsDefinition, child, shortcutKey, teleportName));
		}
	}

	private void createMapWidget(Widget container)
	{
		this.createSpriteWidget(container,
			MAP_SPRITE_WIDTH,
			MAP_SPRITE_HEIGHT,
			66,
			43,
			MAP_SPRITE_ID);
	}

	private void createTeleportWidgets(Widget container)
	{
		this.clearTeleports();

		for (XericsDefinition xericsDefinition : this.xericsDefinitions)
		{
			Widget widgetContainer = container.createChild(-1, WidgetType.GRAPHIC);
			Widget teleportWidget = container.createChild(-1, WidgetType.GRAPHIC);

			UITeleport teleport = new UITeleport(widgetContainer, teleportWidget);

			teleport.setPosition(xericsDefinition.getX(), xericsDefinition.getY());
			teleport.setTeleportSprites(XERICS_SPRITE_ID, XERICS_HIGHLIGHTED_SPRITE_ID, XERICS_DISABLED_SPRITE_ID);
			teleport.setSize(xericsDefinition.getWidth(), xericsDefinition.getHeight());

			UILabel teleportLabel = new UILabel(container.createChild(-1, WidgetType.TEXT));
			teleportLabel.getWidget().setTextColor(Color.white.getRGB());
			teleportLabel.getWidget().setTextShadowed(true);
			teleportLabel.setText(xericsDefinition.getLabel().getTitle());
			teleportLabel.setPosition(xericsDefinition.getLabel().getX(), xericsDefinition.getLabel().getY());
			teleportLabel.setSize(xericsDefinition.getLabel().getWidth(), xericsDefinition.getLabel().getHeight());
			teleportLabel.setVisibility(config.showXericsMapLabels());
			teleport.attachLabel(teleportLabel);

			if (isLocationUnlocked(xericsDefinition.getName()))
			{
				Xerics xericsEntry = this.availableLocations.get(xericsDefinition.getName());

				teleport.setName(xericsEntry.getDisplayedName());
				teleport.addAction(TRAVEL_ACTION, () -> this.triggerTeleport(xericsEntry));

				UIHotkey hotkey = this.createHotKey(container, xericsDefinition.getHotkey(), xericsEntry.getKeyShortcut());
				teleportLabel.setHotkey(xericsEntry.getKeyShortcut());

				// If the button displayed name differs from the original,
				// use this for the label instead of our default label name
				if (!xericsEntry.getDisplayedName().equals(xericsDefinition.getName()))
					teleportLabel.setText(xericsEntry.getDisplayedName());

				teleport.attachHotkey(hotkey);

				teleport.setHotkeyInLabel(config.displayHotkeys() && config.showXericsMapLabels() && config.showXericsMapHotkeyInLabels());
				teleport.setHotKeyVisibility(config.displayHotkeys() && !(config.showXericsMapLabels() && config.showXericsMapHotkeyInLabels()));
			}
			else
			{
				teleport.setName(xericsDefinition.getName());
				teleport.setLocked(true);
				teleport.addAction(EXAMINE_ACTION, () -> this.triggerLockedMessage(xericsDefinition));
			}

			this.addTeleport(teleport);
		}
	}

	private boolean isLocationUnlocked(String teleportName)
	{
		return this.availableLocations.containsKey(teleportName);
	}

	private void triggerTeleport(AdventureLogEntry<XericsDefinition> adventureLogEntry)
	{
		this.clientThread.invokeLater(() -> this.client.runScript(SCRIPT_TRIGGER_KEY, this.plugin.getClient().getWidget(0xBB0003).getId(), adventureLogEntry.getWidget().getIndex()));
	}

	private void triggerLockedMessage(XericsDefinition xericsDefinition)
	{
		this.clientThread.invokeLater(() -> this.client.addChatMessage(ChatMessageType.GAMEMESSAGE, "", String.format("The talisman does not have the power to take you to %s yet.", xericsDefinition.getName()), null));
	}
}

package com.mjhylkema.TeleportMaps.components;

import com.mjhylkema.TeleportMaps.TeleportMapsConfig;
import com.mjhylkema.TeleportMaps.TeleportMapsPlugin;
import com.mjhylkema.TeleportMaps.definition.HotKeyDefinition;
import com.mjhylkema.TeleportMaps.ui.UIHotkey;
import com.mjhylkema.TeleportMaps.ui.UITeleport;
import java.util.ArrayList;
import java.util.List;
import java.util.function.Consumer;
import net.runelite.api.Client;
import net.runelite.api.widgets.Widget;
import net.runelite.api.widgets.WidgetType;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.events.ConfigChanged;

public abstract class BaseMap implements IMap
{
	protected static final int HOTKEY_LABEL_SPRITE_ID = -19002;

	protected TeleportMapsPlugin plugin;
	protected TeleportMapsConfig config;
	protected Client client;
	protected ClientThread clientThread;
	final protected List<UITeleport> activeUITeleports;
	private boolean active;

	public BaseMap(TeleportMapsPlugin plugin, TeleportMapsConfig config, Client client, ClientThread clientThread, boolean active)
	{
		this.plugin = plugin;
		this.config = config;
		this.client = client;
		this.clientThread = clientThread;
		this.active = active;
		this.activeUITeleports = new ArrayList<>();
	}

	public void onConfigChanged(ConfigChanged e)
	{
		switch (e.getKey())
		{
			case TeleportMapsConfig.KEY_DISPLAY_HOTKEYS:
				this.updateTeleports((teleport) -> teleport.setHotKeyVisibility(config.displayHotkeys()));
			default:
				return;
		}
	}

	protected void updateTeleports(Consumer<UITeleport> action)
	{
		if (this.activeUITeleports.size() == 0)
			return;

		this.clientThread.invokeLater(() -> this.activeUITeleports.forEach(action));
	}

	public boolean isActive()
	{
		return this.active;
	}

	protected void setActive(boolean active)
	{
		this.active = active;
	}

	protected void addTeleport(UITeleport teleport)
	{
		this.activeUITeleports.add(teleport);
	}

	protected void clearTeleports()
	{
		this.activeUITeleports.clear();
	}

	protected Widget createSpriteWidget(Widget parent, int spriteWidth, int spriteHeight, int originalX, int originalY, int spriteId)
	{
		// Create a graphic widget
		Widget widget = parent.createChild(-1, WidgetType.GRAPHIC);
		widget.setOriginalWidth(spriteWidth);
		widget.setOriginalHeight(spriteHeight);
		widget.setOriginalX(originalX);
		widget.setOriginalY(originalY);
		widget.setSpriteId(spriteId);
		widget.revalidate();
		return widget;
	}

	protected UIHotkey createHotKey(Widget container, HotKeyDefinition hotKeyDefinition, String hotKeyLabel)
	{
		Widget icon = container.createChild(-1, WidgetType.GRAPHIC);
		icon.setSpriteId(HOTKEY_LABEL_SPRITE_ID);
		Widget text = container.createChild(-1, WidgetType.TEXT);

		UIHotkey hotkey = new UIHotkey(icon, text);

		boolean displayHotkeys = this.config.displayHotkeys();

		hotkey.setSize(hotKeyDefinition.getWidth(), hotKeyDefinition.getHeight());
		hotkey.setPosition(hotKeyDefinition.getX(), hotKeyDefinition.getY());
		hotkey.setText(hotKeyLabel);
		hotkey.setVisibility(displayHotkeys);

		return hotkey;
	}

	protected void setWidgetsHidden(int groupID, int[] childIDs, boolean hidden)
	{
		for(int childId : childIDs)
		{
			Widget widget = this.client.getWidget(groupID, childId);
			if (widget != null)
			{
				widget.setHidden(hidden);
			}
		}
	}
}

package com.mjhylkema.TeleportMaps;

import com.google.gson.Gson;
import com.google.inject.Provides;
import com.mjhylkema.TeleportMaps.components.adventureLog.AdventureLogComposite;
import com.mjhylkema.TeleportMaps.components.IMap;
import com.mjhylkema.TeleportMaps.components.adventureLog.MinecartMap;
import com.mjhylkema.TeleportMaps.components.MushtreeMap;
import com.mjhylkema.TeleportMaps.components.adventureLog.SkillsNecklaceMap;
import com.mjhylkema.TeleportMaps.components.adventureLog.SpiritTreeMap;
import com.mjhylkema.TeleportMaps.components.adventureLog.WildernessObeliskMap;
import com.mjhylkema.TeleportMaps.components.adventureLog.XericsMap;
import com.mjhylkema.TeleportMaps.definition.SpriteDefinition;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.util.Arrays;
import java.util.List;
import javax.inject.Inject;
import lombok.Getter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.eventbus.EventBus;
import net.runelite.client.game.SpriteManager;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.plugins.PluginDescriptor;

@Slf4j
@PluginDescriptor(
	name = "Teleport Maps",
	configName = "SpiritTreeMapPlugin", // Original plugin name
	enabledByDefault = true
)
public class TeleportMapsPlugin extends Plugin
{
	private static final String DEF_FILE_SPRITES = "/SpriteDefinitions.json";

	@Inject
	private Gson gson;
	@Inject
	private SpriteManager spriteManager;
	@Inject
	@Getter
	private ClientThread clientThread;
	@Inject
	@Getter
	private Client client;
	@Inject
	private EventBus eventBus;

	@Inject
	@Getter
	private TeleportMapsConfig config;

	@Inject
	private MushtreeMap mushtreeMap;
	@Inject
	private SpiritTreeMap spiritTreeMap;
	@Inject
	private XericsMap xericsMap;
	@Inject
	private MinecartMap minecartMap;
	@Inject
	private WildernessObeliskMap obeliskMap;
	@Inject
	private SkillsNecklaceMap skillsNecklaceMap;
	@Inject
	AdventureLogComposite adventureLogComposite;

	private List<IMap> mapComponents;

	@Override
	protected void startUp()
	{
		SpriteDefinition[] spriteDefinitions = this.loadDefinitionResource(SpriteDefinition[].class, DEF_FILE_SPRITES);
		this.spriteManager.addSpriteOverrides(spriteDefinitions);

		this.mapComponents = Arrays.asList(mushtreeMap, adventureLogComposite, spiritTreeMap, xericsMap, minecartMap, obeliskMap, skillsNecklaceMap);

		this.adventureLogComposite.addAdventureLogMap(spiritTreeMap);
		this.adventureLogComposite.addAdventureLogMap(xericsMap);
		this.adventureLogComposite.addAdventureLogMap(minecartMap);
		this.adventureLogComposite.addAdventureLogMap(obeliskMap);
		this.adventureLogComposite.addAdventureLogMap(skillsNecklaceMap);

		this.mapComponents.forEach(mapComponent -> eventBus.register(mapComponent));
	}

	@Override
	protected void shutDown()
	{
		this.mapComponents.forEach(mapComponent -> eventBus.unregister(mapComponent));
	}

	public  <T> T loadDefinitionResource(Class<T> classType, String resource)
	{
		// Load the resource as a stream and wrap it in a reader
		InputStream resourceStream = classType.getResourceAsStream(resource);
		InputStreamReader definitionReader = new InputStreamReader(resourceStream);

		// Load the objects from the JSON file
		return gson.fromJson(definitionReader, classType);
	}

	@Provides
	TeleportMapsConfig provideConfig(ConfigManager configManager)
	{
		return configManager.getConfig(TeleportMapsConfig.class);
	}
}

package com.mjhylkema.TeleportMaps;

import net.runelite.client.RuneLite;
import net.runelite.client.externalplugins.ExternalPluginManager;

public class TeleportMapsPluginTest
{
	public static void main(String[] args) throws Exception
	{
		ExternalPluginManager.loadBuiltin(TeleportMapsPlugin.class);
		RuneLite.main(args);
	}
}
