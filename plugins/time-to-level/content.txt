package com.ttl;

import net.runelite.client.RuneLite;
import net.runelite.client.externalplugins.ExternalPluginManager;

public class TimeToLevelPluginTest
{
	public static void main(String[] args) throws Exception
	{
		ExternalPluginManager.loadBuiltin(TimeToLevelPlugin.class);
		RuneLite.main(args);
	}
}
package com.ttl;

import net.runelite.api.Skill;
import net.runelite.client.util.ImageUtil;

import java.awt.image.BufferedImage;
import java.util.EnumMap;
import java.util.Map;

public class ImgUtils {
    private static final Map<Skill, BufferedImage> SMALL_ICONS = new EnumMap<>(Skill.class);
    private static final Map<Skill, BufferedImage> ICONS = new EnumMap<>(Skill.class);

    public static BufferedImage getSkillImage(String skill, boolean small) {
        return getSkillImage(Skill.valueOf(skill.toUpperCase()), small);
    }

    public static BufferedImage getSkillImage(Skill skill, boolean small) {
        String skillIconPath = (small ? "/skill_icons_small/" : "/skill_icons/")
                + skill.name().toLowerCase() + ".png";

        Map<Skill, BufferedImage> map = small ? SMALL_ICONS : ICONS;
        return map.computeIfAbsent(skill, s -> ImageUtil.getResourceStreamFromClass(TimeToLevelPlugin.class, skillIconPath));
    }
}

package com.ttl;

import net.runelite.client.config.Config;
import net.runelite.client.config.ConfigGroup;
import net.runelite.client.config.ConfigItem;

import static com.ttl.TimeToLevelConfig.CONFIG_GROUP;

@ConfigGroup(CONFIG_GROUP)
public interface TimeToLevelConfig extends Config {
    String CONFIG_GROUP = "timetolevel";
    String RATES_KEY = "rates";
    String BUYABLE_KEY = "buyableSkills";
    String VIRTUAL_LEVEL_KEY = "virtualLevels";
    static final String DEFAULT_BUYABLES = "cooking,smithing,fletching,firemaking,herblore,crafting,construction,prayer,ranged,magic,farming";

    @ConfigItem(
            keyName = RATES_KEY,
            name = RATES_KEY,
            hidden = true,
            description = ""
    )
    default String rates() {
        return "";
    }


    @ConfigItem(
            keyName = VIRTUAL_LEVEL_KEY,
            name = "Support virtual levels",
            description = "Add TTL for skills greater than 99",
            position = 1
    )
    default boolean virtualLevels() {
        return false;
    }

    @ConfigItem(
            keyName = BUYABLE_KEY,
            name = "Buyable skills",
            description = "List of Buyable skills",
            position = 2
    )
    default String buyableSkills() {
        return DEFAULT_BUYABLES;
    }
}

package com.ttl;

import lombok.AllArgsConstructor;
import lombok.Data;

@Data
@AllArgsConstructor
public class RateMethod {
    int level;
    int rate;
    String method;

    public RateMethod(RateMethod ri) {
        level = ri.level;
        rate = ri.rate;
        method = ri.method;
    }
}

package com.ttl;

import com.google.inject.Provides;
import com.ttl.ui.LevelsPanel;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.Experience;
import net.runelite.api.Skill;
import net.runelite.api.events.StatChanged;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.events.ConfigChanged;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.plugins.PluginDescriptor;
import net.runelite.client.ui.ClientToolbar;
import net.runelite.client.ui.NavigationButton;
import net.runelite.client.util.ImageUtil;

import javax.inject.Inject;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

import static net.runelite.api.Skill.*;

@Slf4j
@PluginDescriptor(
        name = "Time to Level",
        description = "Panel to show how long until you get dopamine fireworks. /s",
        tags = {"xp", "track", "ttl", "skill", "level"}
)
public class TimeToLevelPlugin extends Plugin {
    @Inject
    private Client client;

    @Inject
    private TimeToLevelConfig config;

    @Inject
    private ClientToolbar clientToolbar;

    @Inject
    private RatesManager ratesManager;

    private LevelsPanel panel;

    private NavigationButton navButton;

    public static final List<Skill> COMBAT_SKILLS = Arrays.asList(ATTACK, STRENGTH, DEFENCE, MAGIC, RANGED, PRAYER, HITPOINTS);
    public static final List<Skill> GATHERING_SKILLS = Arrays.asList(MINING, FISHING, WOODCUTTING, HUNTER, FARMING);
    public static final List<Skill> ARTISAN_SKILLS = Arrays.asList(COOKING, SMITHING, FLETCHING, FIREMAKING, HERBLORE, CRAFTING, RUNECRAFT, CONSTRUCTION);
    public static final List<Skill> SUPPORT_SKILLS = Arrays.asList(AGILITY, THIEVING, SLAYER);

    @Override
    protected void startUp() {
        panel = new LevelsPanel(this, config);
        navButton = NavigationButton.builder()
                .tooltip("Time to Level")
                .icon(ImageUtil.getResourceStreamFromClass(getClass(), "/icon.png"))
                .priority(50)
                .panel(panel)
                .build();

        clientToolbar.addNavigation(navButton);
    }

    @Override
    protected void shutDown() {
        clientToolbar.removeNavigation(navButton);
    }

    @Subscribe
    public void onStatChanged(StatChanged event) {
        recalculate();
    }


    @Provides
    TimeToLevelConfig provideConfig(ConfigManager configManager) {
        return configManager.getConfig(TimeToLevelConfig.class);
    }

    @Subscribe
    public void onConfigChanged(ConfigChanged event) {
        if (!event.getGroup().equals(TimeToLevelConfig.CONFIG_GROUP)) {
            return;
        }

        recalculate();
    }

    public List<RateTTL> getTTLs() {
        List<RateTTL> ttls = new ArrayList<>();

        for (Rates e : ratesManager.getRates()) {
            Skill skill = Skill.valueOf(e.getSkill().toUpperCase());
            int xp = client.getSkillExperience(skill);
            int level = Experience.getLevelForXp(xp);
            if (level >= 99 && !config.virtualLevels()) {
                continue;
            }

            int xpLeft = Experience.getXpForLevel(level + 1) - client.getSkillExperience(skill);
            RateMethod rate = null;
            for (RateMethod rateMethod : e.getMethods()) {
                if (rateMethod.level > level) {
                    break;
                }
                rate = rateMethod;
            }
            if (rate == null || rate.rate <= 0) {
                continue;
            }

            double secondsLeft = xpLeft / (rate.rate / 3600.0);
            ttls.add(new RateTTL(skill, level, xpLeft, rate.getRate(), (int) secondsLeft, rate));
        }

        return ttls;
    }

    public void recalculate() {
        panel.update(getTTLs());
    }

    public void saveRates(Rates r) {
        ratesManager.saveRates(r);
        recalculate();
    }

    public Rates getRates(Skill skill) {
        return ratesManager.getRates(skill);
    }

    public void resetRates() {
        ratesManager.resetRates();
        recalculate();
    }

    public String getRatesConfig() {
        return ratesManager.getRatesConfig();
    }

    public boolean setRatesConfig(String rates) {
        boolean success = ratesManager.setRatesConfig(rates);
        if (success) {
            recalculate();
        }

        return success;
    }

    public Rates resetRates(Skill skill) {
        Rates r = ratesManager.resetRates(skill);
        recalculate();
        return r;
    }
}

package com.ttl;

import com.google.gson.Gson;
import com.google.gson.reflect.TypeToken;
import joptsimple.internal.Strings;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Skill;
import net.runelite.client.config.ConfigManager;

import javax.inject.Inject;
import javax.inject.Singleton;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.lang.reflect.Type;
import java.util.List;

@Slf4j
@Singleton
public class RatesManager {
    private static final Gson gson = new Gson();

    private List<Rates> cachedRates;

    ConfigManager configManager;

    @Inject
    public RatesManager(ConfigManager configManager) {
        this.configManager = configManager;
    }

    public synchronized List<Rates> getRates() {
        return getRates(true);
    }

    private synchronized List<Rates> getRates(boolean useConfig) {
        if (useConfig && cachedRates != null) {
            return cachedRates;
        }

        if (useConfig && !Strings.isNullOrEmpty(getRatesConfig())) {
            cachedRates = getConfigRates();
        } else {
            cachedRates = getDefaultRates();
        }

        return cachedRates;
    }

    private List<Rates> getConfigRates() {
        return gson.fromJson(getRatesConfig(), tt());
    }

    private List<Rates> getDefaultRates() {
        return gson.fromJson(new InputStreamReader(TimeToLevelPlugin.class.getResourceAsStream("/rates.json")), tt());
    }

    public Rates getRates(Skill skill) {
        return getRates(skill, true);

    }

    private Rates getRates(Skill skill, boolean useConfig) {
        return getRates(useConfig)
                .stream()
                .filter(r -> r.getSkill().equals(skill.name().toLowerCase()))
                .findFirst()
                .map(Rates::new) // clone this Rates
                .orElse(null);
    }

    public synchronized void saveRates(Rates r) {
        List<Rates> allRates = getRates();

        for (int i = 0; i < allRates.size(); i++) {
            Rates allR = allRates.get(i);
            if (allR.getSkill().equals(r.getSkill())) {
                allRates.set(i, r);
                cachedRates = allRates;
                configManager.setConfiguration(TimeToLevelConfig.CONFIG_GROUP, TimeToLevelConfig.RATES_KEY, gson.toJson(cachedRates));
                break;
            }
        }
    }

    public void resetRates() {
        InputStream ratesStream = TimeToLevelPlugin.class.getResourceAsStream("/rates.json");
        cachedRates = gson.fromJson(new InputStreamReader(ratesStream), new TypeToken<List<Rates>>() {
        }.getType());
        configManager.setConfiguration(TimeToLevelConfig.CONFIG_GROUP, TimeToLevelConfig.RATES_KEY, gson.toJson(cachedRates));
        configManager.setConfiguration(TimeToLevelConfig.CONFIG_GROUP, TimeToLevelConfig.BUYABLE_KEY, TimeToLevelConfig.DEFAULT_BUYABLES);
    }

    public String getRatesConfig() {
        return configManager.getConfiguration(TimeToLevelConfig.CONFIG_GROUP, TimeToLevelConfig.RATES_KEY);
    }

    public boolean setRatesConfig(String rates) {
        if (rates == null || rates.isEmpty()) {
            return false;
        }

        cachedRates = gson.fromJson(rates, tt());
        configManager.setConfiguration(TimeToLevelConfig.CONFIG_GROUP, TimeToLevelConfig.RATES_KEY, gson.toJson(cachedRates));
        return true;
    }

    private static Type tt() {
        return new TypeToken<List<Rates>>() {
        }.getType();
    }

    public Rates resetRates(Skill skill) {
        Rates r = getRates(skill, false);
        saveRates(r);
        return r;
    }
}

package com.ttl.ui;

import com.ttl.TimeToLevelConfig;
import com.ttl.TimeToLevelPlugin;
import com.ttl.RateTTL;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Skill;
import net.runelite.client.ui.PluginPanel;
import net.runelite.client.util.SwingUtil;

import javax.swing.*;
import javax.swing.border.EmptyBorder;
import java.awt.*;
import java.util.ArrayList;
import java.util.Comparator;
import java.util.List;
import java.util.function.Consumer;
import java.util.stream.Collectors;

@Slf4j
public class LevelsListPanel extends JPanel {
    static final int SKILL_COLUMN_WIDTH = 39;
    static final int SKILL_COLUMN_HEIGHT = 25;
    static final int LEVEL_COLUMN_WIDTH = 35;
    static final int XP_COLUMN_WIDTH = 57;
    static final int XP_RATE_COLUMN_WIDTH = 52;
    static final int TTL_COLUMN_WIDTH = 59;

    private final JPanel ratesListPanel = new JPanel();
    private final LevelsListHeader ratesHeaders;
    private List<RateTTL> ttls = new ArrayList<>();
    private final Consumer<Skill> showSkillListener;
    private final Filters filters;

    public LevelsListPanel(TimeToLevelPlugin plugin, TimeToLevelConfig config, Consumer<Skill> showSkillListener, Runnable showRatesConfig) {
        this.showSkillListener = showSkillListener;
        setBorder(new EmptyBorder(0, 0, 0, 0));
        setLayout(new BorderLayout());

        JPanel northPanel = new JPanel(new BorderLayout());
        ratesHeaders = new LevelsListHeader(this, this::onSortChanged);
        filters = new Filters(config, this::updatePanel);

        northPanel.add(new LevelsListPanelHeader(plugin::recalculate, showRatesConfig), BorderLayout.NORTH);
        northPanel.add(filters, BorderLayout.CENTER);
        northPanel.add(ratesHeaders, BorderLayout.SOUTH);

        JPanel wrapped = new JPanel(new BorderLayout());
        wrapped.add(ratesListPanel, BorderLayout.NORTH);
        JScrollPane scroller = new JScrollPane(wrapped);
        scroller.setHorizontalScrollBarPolicy(JScrollPane.HORIZONTAL_SCROLLBAR_NEVER);

        add(northPanel, BorderLayout.NORTH);
        add(scroller, BorderLayout.CENTER);
    }

    private void onSortChanged() {
        update(ttls);
    }

    private List<RateTTL> sortTTLs(List<RateTTL> ts) {
        SortOrder sortOrder = ratesHeaders.getSort();
        Comparator<RateTTL> comp = sortOrder.comparator;
        if (!sortOrder.asc) {
            comp = comp.reversed();
        }
        ts.sort(comp);
        return ts;
    }

    public void update(List<RateTTL> ttls) {
        this.ttls = sortTTLs(ttls);
        SwingUtilities.invokeLater(this::updatePanel);
    }

    private void updatePanel() {
        ratesListPanel.removeAll();
        ratesListPanel.setLayout(new GridBagLayout());

        GridBagConstraints constraints = new GridBagConstraints();
        constraints.fill = GridBagConstraints.HORIZONTAL;
        constraints.weightx = 1;
        constraints.gridx = 0;
        constraints.gridy = 0;

        List<Skill> vis = filters.getVisibleSkills();
        List<RateTTL> shown = ttls
                .stream()
                .filter(rc -> vis.contains(rc.getSkill()))
                .collect(Collectors.toList());

        for (int i = 0; i < shown.size(); i++) {
            RateTTL calc = shown.get(i);
            LevelsListCalcBox llcb = new LevelsListCalcBox(calc, () -> showSkillListener.accept(calc.getSkill()), i % 2 == 1);
            ratesListPanel.add(llcb, constraints);
            constraints.gridy++;
        }

        repaint();
        revalidate();
    }

    private static class Filters extends JPanel {
        private final TimeToLevelConfig config;
        private final JCheckBox cmb;
        private final JCheckBox art;
        private final JCheckBox gath;
        private final JCheckBox supp;
        private final JToggleButton buy;

        private Filters(TimeToLevelConfig config, Runnable refresh) {
            this.config = config;
            setBorder(new EmptyBorder(0, 0, 8, 0));
            setLayout(new GridLayout(3, 2, 2, 4));
            final int height = 18;
            cmb = new JCheckBox("Combat", true);
            SwingUtil.removeButtonDecorations(cmb);
            cmb.setToolTipText(TimeToLevelPlugin.COMBAT_SKILLS.stream().map(Skill::getName).collect(Collectors.joining(",")));
            cmb.addActionListener(l -> refresh.run());
            cmb.setHorizontalAlignment(JLabel.CENTER);
            cmb.setPreferredSize(new Dimension(cmb.getPreferredSize().width, height));

            art = new JCheckBox("Artisan", true);
            SwingUtil.removeButtonDecorations(art);
            art.setToolTipText(TimeToLevelPlugin.ARTISAN_SKILLS.stream().map(Skill::getName).collect(Collectors.joining(",")));
            art.addActionListener(l -> refresh.run());
            art.setHorizontalAlignment(JLabel.CENTER);
            art.setPreferredSize(new Dimension(cmb.getPreferredSize().width, height));

            gath = new JCheckBox("Gathering", true);
            SwingUtil.removeButtonDecorations(gath);
            gath.setToolTipText(TimeToLevelPlugin.GATHERING_SKILLS.stream().map(Skill::getName).collect(Collectors.joining(",")));
            gath.addActionListener(l -> refresh.run());
            gath.setHorizontalAlignment(JLabel.CENTER);
            gath.setPreferredSize(new Dimension(cmb.getPreferredSize().width, height));

            supp = new JCheckBox("Support", true);
            SwingUtil.removeButtonDecorations(supp);
            supp.setToolTipText(TimeToLevelPlugin.SUPPORT_SKILLS.stream().map(Skill::getName).collect(Collectors.joining(",")));
            supp.addActionListener(l -> refresh.run());
            supp.setHorizontalAlignment(JLabel.CENTER);
            supp.setPreferredSize(new Dimension(cmb.getPreferredSize().width, height));

            buy = new ToggleButton("Buyables", true);
            buy.setFocusPainted(false);
            buy.setToolTipText(getBuyables().stream().map(Skill::getName).collect(Collectors.joining(",")));
            buy.addActionListener(l -> refresh.run());
            buy.setHorizontalAlignment(JLabel.CENTER);
            buy.setPreferredSize(new Dimension(cmb.getPreferredSize().width, height));

            add(cmb);
            add(art);
            add(supp);
            add(gath);
            add(buy);
        }

        @Override
        public Dimension getPreferredSize() {
            return new Dimension(PluginPanel.WIDTH, super.getPreferredSize().height);
        }

        private List<Skill> getVisibleSkills() {
            List<Skill> vis = new ArrayList<>();
            if (cmb.isSelected()) {
                vis.addAll(TimeToLevelPlugin.COMBAT_SKILLS);
            }
            if (art.isSelected()) {
                vis.addAll(TimeToLevelPlugin.ARTISAN_SKILLS);
            }
            if (gath.isSelected()) {
                vis.addAll(TimeToLevelPlugin.GATHERING_SKILLS);
            }
            if (supp.isSelected()) {
                vis.addAll(TimeToLevelPlugin.SUPPORT_SKILLS);
            }
            if (!buy.isSelected()) {
                vis.removeAll(getBuyables());
            }

            return vis;
        }

        private List<Skill> getBuyables() {
            List<Skill> buyables = new ArrayList<>();
            for (String s : config.buyableSkills().split(",")) {
                s = s.trim();
                if (s.isEmpty()) {
                    continue;
                }

                try {
                    buyables.add(Skill.valueOf(s.toUpperCase()));
                } catch (Exception ignored) {
                }
            }

            return buyables;
        }
    }
}

package com.ttl.ui;

import com.ttl.TimeToLevelPlugin;
import net.runelite.client.util.ImageUtil;
import net.runelite.client.util.SwingUtil;

import javax.swing.*;
import java.awt.*;
import java.awt.image.BufferedImage;

public class ToggleButton extends JToggleButton {
    private static final ImageIcon ON_SWITCHER;
    private static final ImageIcon OFF_SWITCHER;

    static {
        BufferedImage onSwitcher = ImageUtil.getResourceStreamFromClass(TimeToLevelPlugin.class, "/switcher_on.png");
        ON_SWITCHER = new ImageIcon(onSwitcher);
        OFF_SWITCHER = new ImageIcon(ImageUtil.flipImage(
                ImageUtil.luminanceScale(
                        ImageUtil.grayscaleImage(onSwitcher),
                        0.61f
                ),
                true,
                false
        ));
    }

    public ToggleButton(String text, boolean selected) {
        super(text, OFF_SWITCHER, selected);
        setSelectedIcon(ON_SWITCHER);
        SwingUtil.removeButtonDecorations(this);
        setPreferredSize(new Dimension(25, 0));
    }
}

package com.ttl.ui;

import com.ttl.ImgUtils;
import com.ttl.RateTTL;
import lombok.extern.slf4j.Slf4j;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.util.QuantityFormatter;

import javax.swing.*;
import javax.swing.border.EmptyBorder;
import java.awt.*;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;

import static com.ttl.ui.LevelsListPanel.*;

@Slf4j
public class LevelsListCalcBox extends JPanel {
    private static final Color ODD_ROW = new Color(44, 44, 44);

    private final RateTTL calc;

    public LevelsListCalcBox(RateTTL calc, Runnable onClick, boolean odd) {
        setLayout(new BorderLayout());
        setBorder(new EmptyBorder(2, 0, 2, 0));
        setBackground(odd ? ODD_ROW : ColorScheme.DARK_GRAY_COLOR);

        addMouseListener(new MouseAdapter() {
            @Override
            public void mousePressed(MouseEvent e) {
                mouseExited(e);
                onClick.run();
            }

            @Override
            public void mouseEntered(MouseEvent e) {
                setBackground(getBackground().darker());
            }

            @Override
            public void mouseExited(MouseEvent e) {
                setBackground(odd ? ODD_ROW : ColorScheme.DARK_GRAY_COLOR);
            }
        });
        this.calc = calc;

        JPanel leftSide = new JPanel(new BorderLayout());
        JPanel rightSide = new JPanel(new BorderLayout());
        leftSide.setOpaque(false);
        rightSide.setOpaque(false);

        leftSide.add(buildSkillImage(), BorderLayout.WEST);
        leftSide.add(buildLevelLabel(), BorderLayout.EAST);
        rightSide.add(buildXpLabel(), BorderLayout.WEST);
        rightSide.add(buildRateLabel(), BorderLayout.CENTER);
        rightSide.add(buildTtlLabel(), BorderLayout.EAST);

        setToolTipText(calc.toolTip());

        final JPopupMenu popupMenu = new JPopupMenu();
        final JMenuItem view = new JMenuItem("View skill xp rates");
        view.addActionListener(e -> onClick.run());
        popupMenu.add(view);
        setComponentPopupMenu(popupMenu);


        add(leftSide, BorderLayout.WEST);
        add(rightSide, BorderLayout.EAST);
    }

    private JPanel buildTtlLabel() {
        JPanel column = new JPanel(new BorderLayout());
        JLabel label = new JLabel(calc.ttl());
        column.add(label, BorderLayout.EAST);
        column.setBorder(new EmptyBorder(0, 0, 0, 9));
        column.setOpaque(false);
        column.setPreferredSize(new Dimension(TTL_COLUMN_WIDTH, 0));
        return column;
    }

    private JPanel buildRateLabel() {
        JPanel column = new JPanel(new BorderLayout());
        JLabel label = new JLabel(QuantityFormatter.quantityToRSDecimalStack(calc.getXpRate()));
        column.add(label, BorderLayout.WEST);
        column.setOpaque(false);
        column.setPreferredSize(new Dimension(XP_RATE_COLUMN_WIDTH, 0));
        return column;
    }

    private JPanel buildXpLabel() {
        JPanel column = new JPanel(new BorderLayout());
        JLabel label = new JLabel(QuantityFormatter.quantityToRSDecimalStack(calc.getXpLeft()));
        column.add(label, BorderLayout.WEST);
        column.setOpaque(false);
        column.setPreferredSize(new Dimension(XP_COLUMN_WIDTH, 0));
        return column;
    }

    private JPanel buildLevelLabel() {
        JPanel column = new JPanel(new BorderLayout());

        JLabel label = new JLabel(String.valueOf(calc.getLevel()));
        column.add(label, BorderLayout.CENTER);
        column.setOpaque(false);
        column.setPreferredSize(new Dimension(LEVEL_COLUMN_WIDTH, 0));
        return column;
    }

    private JPanel buildSkillImage() {
        JPanel column = new JPanel(new BorderLayout());
        JLabel label = new JLabel(new ImageIcon(ImgUtils.getSkillImage(calc.getSkill(), true)));
        column.add(label, BorderLayout.CENTER);
        column.setPreferredSize(new Dimension(SKILL_COLUMN_WIDTH, SKILL_COLUMN_HEIGHT));
        column.setOpaque(false);
        return column;
    }
}

package com.ttl.ui;

import com.ttl.TimeToLevelPlugin;
import lombok.extern.slf4j.Slf4j;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.FontManager;
import net.runelite.client.util.ImageUtil;

import javax.swing.*;
import javax.swing.border.EmptyBorder;
import java.awt.*;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.awt.image.BufferedImage;
import java.util.HashMap;
import java.util.Map;

import static com.ttl.ui.LevelsListPanel.XP_COLUMN_WIDTH;

@Slf4j
public class LevelsListHeader extends JPanel {
    private static final ImageIcon ARROW_UP;
    private static final ImageIcon HIGHLIGHT_ARROW_DOWN;
    private static final ImageIcon HIGHLIGHT_ARROW_UP;

    private static final Color ARROW_COLOR = ColorScheme.LIGHT_GRAY_COLOR;
    private static final Color HIGHLIGHT_COLOR = ColorScheme.BRAND_ORANGE;

    static {
        final BufferedImage arrowDown = ImageUtil.getResourceStreamFromClass(TimeToLevelPlugin.class, "/arrow_down.png");
        final BufferedImage arrowUp = ImageUtil.rotateImage(arrowDown, Math.PI);
        final BufferedImage arrowUpFaded = ImageUtil.luminanceOffset(arrowUp, -80);
        ARROW_UP = new ImageIcon(arrowUpFaded);

        final BufferedImage highlightArrowDown = ImageUtil.fillImage(arrowDown, HIGHLIGHT_COLOR);
        final BufferedImage highlightArrowUp = ImageUtil.fillImage(arrowUp, HIGHLIGHT_COLOR);
        HIGHLIGHT_ARROW_DOWN = new ImageIcon(highlightArrowDown);
        HIGHLIGHT_ARROW_UP = new ImageIcon(highlightArrowUp);
    }

    private final Map<SortOrder, JLabel> lables = new HashMap<>();
    private final Map<SortOrder, JLabel> arrows = new HashMap<>();

    private SortOrder sortOrder = SortOrder.TTL;
    private final Runnable onSort;

    public LevelsListHeader(LevelsListPanel list, Runnable onSort) {
        setLayout(new BorderLayout());
        setBorder(new EmptyBorder(0, 0, 0, 0));
        this.onSort = onSort;

        JPanel leftSide = new JPanel(new BorderLayout());
        JPanel rightSide = new JPanel(new BorderLayout());
        leftSide.setOpaque(true);
        rightSide.setOpaque(true);

        leftSide.add(buildHeader("Skill", SortOrder.SKILL, LevelsListPanel.SKILL_COLUMN_WIDTH), BorderLayout.WEST);
        leftSide.add(buildHeader("Lvl", SortOrder.LEVEL, LevelsListPanel.LEVEL_COLUMN_WIDTH), BorderLayout.EAST);
        rightSide.add(buildHeader("XP Left", SortOrder.XP, XP_COLUMN_WIDTH), BorderLayout.WEST);
        rightSide.add(buildHeader("XP/Hr", SortOrder.RATE, LevelsListPanel.XP_RATE_COLUMN_WIDTH), BorderLayout.CENTER);
        rightSide.add(buildHeader("TTL", SortOrder.TTL, LevelsListPanel.TTL_COLUMN_WIDTH), BorderLayout.EAST);

        add(leftSide, BorderLayout.WEST);
        add(rightSide, BorderLayout.EAST);

        SwingUtilities.invokeLater(this::setHighlights);
    }

    private JPanel buildHeader(String name, SortOrder so, int x) {
        JPanel column = new JPanel(new BorderLayout());
        column.setBackground(ColorScheme.SCROLL_TRACK_COLOR);
        column.setPreferredSize(new Dimension(x, 18));
        column.setBorder(new EmptyBorder(0, 1, 0, 1));


        JLabel label = new JLabel(name);
        label.setFont(FontManager.getRunescapeSmallFont());

        JLabel arrowLabel = new JLabel();
        arrowLabel.setIcon(ARROW_UP);

        column.add(label, BorderLayout.WEST);
        column.add(arrowLabel, BorderLayout.EAST);

        column.addMouseListener(new MouseAdapter() {
            @Override
            public void mousePressed(MouseEvent e) {
                if (so == sortOrder) {
                    sortOrder.toggleAsc();
                } else {
                    sortOrder = so;
                }
                setHighlights();
            }

            @Override
            public void mouseEntered(MouseEvent e) {
                label.setForeground(HIGHLIGHT_COLOR);
                if (so != sortOrder) {
                    arrowLabel.setIcon(HIGHLIGHT_ARROW_UP);
                }
            }

            @Override
            public void mouseExited(MouseEvent e) {
                if (so != sortOrder) {
                    label.setForeground(ARROW_COLOR);
                    arrowLabel.setIcon(ARROW_UP);
                }
            }
        });
        lables.put(so, label);
        arrows.put(so, arrowLabel);
        return column;
    }

    private void setHighlights() {
        onSort.run();

        for (Map.Entry<SortOrder, JLabel> e : lables.entrySet()) {
            SortOrder so = e.getKey();
            if (so == sortOrder) {
                e.getValue().setForeground(HIGHLIGHT_COLOR);
                if (sortOrder.asc) {
                    arrows.get(so).setIcon(HIGHLIGHT_ARROW_UP);
                } else {
                    arrows.get(so).setIcon(HIGHLIGHT_ARROW_DOWN);
                }
            } else {
                e.getValue().setForeground(ARROW_COLOR);
                arrows.get(so).setIcon(ARROW_UP);
            }
        }
    }

    public SortOrder getSort() {
        return this.sortOrder;
    }
}

package com.ttl.ui;

import com.ttl.TimeToLevelConfig;
import com.ttl.TimeToLevelPlugin;
import com.ttl.RateTTL;
import net.runelite.api.Skill;
import net.runelite.client.ui.PluginPanel;

import javax.swing.border.EmptyBorder;
import java.awt.*;
import java.util.List;


public class LevelsPanel extends PluginPanel {
    private final LevelsListPanel levelsListPanel;
    private final RatesConfigPanel ratesConfigPanel;

    private final TimeToLevelPlugin plugin;

    public LevelsPanel(TimeToLevelPlugin plugin, TimeToLevelConfig config) {
        super(false);
        this.plugin = plugin;
        this.levelsListPanel = new LevelsListPanel(plugin, config, (skill) -> showSkillRates(skill, true), this::showRatesConfig);
        this.ratesConfigPanel = new RatesConfigPanel(plugin, () -> showList(true), (skill) -> showSkillRates(skill, false));

        setLayout(new BorderLayout());
        setBorder(new EmptyBorder(0, 0, 0, 0));
        showList(true);
    }

    public void update(List<RateTTL> ttls) {
        levelsListPanel.update(ttls);
    }

    public void showList(boolean levelsList) {
        removeAll();
        if (levelsList) {
            add(levelsListPanel, BorderLayout.CENTER);
        } else {
            add(ratesConfigPanel, BorderLayout.CENTER);
        }
        repaint();
        revalidate();
    }

    public void showSkillRates(Skill skill, boolean levelsList) {
        removeAll();
        add(new SkillRatePanel(plugin, plugin.getRates(skill), () -> showList(levelsList)));
        repaint();
        revalidate();
    }

    public void showRatesConfig() {
        removeAll();
        add(ratesConfigPanel);
        repaint();
        revalidate();
    }
}

package com.ttl.ui;

import com.ttl.TimeToLevelPlugin;
import com.ttl.RateMethod;
import lombok.SneakyThrows;
import lombok.extern.slf4j.Slf4j;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.PluginPanel;
import net.runelite.client.util.ImageUtil;
import net.runelite.client.util.SwingUtil;

import javax.swing.*;
import javax.swing.border.EmptyBorder;
import javax.swing.text.NumberFormatter;
import java.awt.*;
import java.awt.event.FocusAdapter;
import java.awt.event.FocusEvent;
import java.awt.image.BufferedImage;
import java.text.NumberFormat;

@Slf4j
public class SkillRateBox extends JPanel {
    private static final ImageIcon DELETE_ICON;
    private static final ImageIcon DELETE_ICON_HOVER;

    static {
        final BufferedImage deleteIcon = ImageUtil.getResourceStreamFromClass(TimeToLevelPlugin.class, "/delete_icon.png");
        DELETE_ICON = new ImageIcon(deleteIcon);
        DELETE_ICON_HOVER = new ImageIcon(ImageUtil.alphaOffset(deleteIcon, 0.53f));
    }

    public SkillRateBox(RateMethod rates, Runnable onDelete) {
        setBackground(ColorScheme.DARKER_GRAY_COLOR);
        setLayout(new BorderLayout(0, 2));
        setBorder(new EmptyBorder(4, 4, 4, 4));


        JPanel top = new JPanel(new BorderLayout());

        JPanel lvlCnts = new JPanel(new FlowLayout(FlowLayout.LEFT, 2, 0));

        NumberFormatter lvlFmt = new NumberFormatter(NumberFormat.getIntegerInstance());
        lvlFmt.setValueClass(Integer.class);
        lvlFmt.setAllowsInvalid(false);
        lvlFmt.setMinimum(1);
        lvlFmt.setCommitsOnValidEdit(true);
        lvlFmt.setMaximum(99);
        JFormattedTextField lvlTxt = new JFormattedTextField(lvlFmt);
        lvlTxt.setColumns(2);
        lvlTxt.setValue(rates.getLevel());
        lvlCnts.add(new JLabel("Lvl: "));
        lvlCnts.add(lvlTxt);

        JPanel xpCnts = new JPanel(new FlowLayout(FlowLayout.CENTER, 2, 0));
        NumberFormatter xpFmt = new NumberFormatter(NumberFormat.getIntegerInstance());
        xpFmt.setValueClass(Integer.class);
        xpFmt.setAllowsInvalid(false);
        xpFmt.setCommitsOnValidEdit(true);
        xpFmt.setMinimum(0);
        xpFmt.setMaximum(Integer.MAX_VALUE);
        JFormattedTextField xpRateTxt = new JFormattedTextField(xpFmt);
        xpRateTxt.setValue(rates.getRate());
        xpRateTxt.setColumns(7);
        xpCnts.add(xpRateTxt);
        xpCnts.add(new JLabel("xp/hr"));

        JButton deleteBtn = new JButton(DELETE_ICON);
        deleteBtn.setRolloverIcon(DELETE_ICON_HOVER);
        SwingUtil.removeButtonDecorations(deleteBtn);
        deleteBtn.addActionListener(e -> onDelete.run());
        deleteBtn.setToolTipText("Delete rate");
        deleteBtn.setPreferredSize(new Dimension(16, 0));

        top.add(lvlCnts, BorderLayout.WEST);
        top.add(xpCnts, BorderLayout.CENTER);
        top.add(deleteBtn, BorderLayout.EAST);

        JTextField methodTxt = new JTextField(rates.getMethod());
        if (rates.getMethod() == null) {
            methodTxt.setText("method description");
        }

        add(top, BorderLayout.NORTH);
        add(methodTxt, BorderLayout.SOUTH);


        lvlTxt.addFocusListener(new FocusAdapter() {
            @SneakyThrows
            @Override
            public void focusLost(FocusEvent e) {
                rates.setLevel((Integer) lvlTxt.getValue());
            }
        });

        xpRateTxt.addFocusListener(new FocusAdapter() {
            @SneakyThrows
            @Override
            public void focusLost(FocusEvent e) {
                rates.setRate((Integer) xpRateTxt.getValue());
            }
        });

        methodTxt.addFocusListener(new FocusAdapter() {
            @Override
            public void focusLost(FocusEvent e) {
                rates.setMethod(methodTxt.getText());
            }
        });
    }

    @Override
    public Dimension getPreferredSize() {
        return new Dimension(PluginPanel.WIDTH, super.getPreferredSize().height);
    }
}

package com.ttl.ui;

import com.ttl.TimeToLevelPlugin;
import com.ttl.RateMethod;
import com.ttl.Rates;
import net.runelite.api.Skill;
import net.runelite.client.util.ImageUtil;
import net.runelite.client.util.SwingUtil;

import javax.swing.*;
import javax.swing.border.EmptyBorder;
import java.awt.*;
import java.awt.image.BufferedImage;
import java.util.Comparator;


public class SkillRatePanel extends JPanel {
    private static final ImageIcon ADD_ICON;
    private static final ImageIcon ADD_ICON_HOVER;

    static {
        BufferedImage addIcon = ImageUtil.getResourceStreamFromClass(TimeToLevelPlugin.class, "/add_icon.png");
        ADD_ICON = new ImageIcon(addIcon);
        ADD_ICON_HOVER = new ImageIcon(ImageUtil.alphaOffset(addIcon, 0.53f));
    }

    private final TimeToLevelPlugin plugin;
    private final JPanel ratesListPanel = new JPanel(new BorderLayout());
    private Rates rates;
    private final JScrollPane scroller;
    private boolean scrollBottom = false;
    private final Runnable onBack;

    public SkillRatePanel(TimeToLevelPlugin plugin, Rates rates, Runnable onBack) {
        this.plugin = plugin;
        this.rates = rates;
        this.onBack = onBack;
        setLayout(new BorderLayout());

        JPanel northPanel = new JPanel(new BorderLayout());
        northPanel.add(new SkillRatePanelHeader(rates.getSkill(), onBack, this::saveRates), BorderLayout.NORTH);

        JButton addButton = new JButton(ADD_ICON);
        addButton.setRolloverIcon(ADD_ICON_HOVER);
        SwingUtil.removeButtonDecorations(addButton);
        addButton.setToolTipText("Add rate");

        JButton resetBtn = new JButton("Reset rates");
        resetBtn.setFocusPainted(false);
        resetBtn.addActionListener(l -> resetRates());

        JPanel wrappedBtb = new JPanel(new BorderLayout());
        wrappedBtb.add(addButton, BorderLayout.EAST);
        wrappedBtb.add(resetBtn, BorderLayout.WEST);
        wrappedBtb.setBorder(new EmptyBorder(8, 8, 8, 0));

        ratesListPanel.setBorder(new EmptyBorder(0, 8, 0, 8));

        JPanel wrapped = new JPanel(new BorderLayout());
        wrapped.add(ratesListPanel, BorderLayout.NORTH);
        scroller = new JScrollPane(wrapped);
        scroller.setHorizontalScrollBarPolicy(JScrollPane.HORIZONTAL_SCROLLBAR_NEVER);

        addButton.addActionListener(e -> {
            addInfo();
            scrollBottom = true;
        });


        add(northPanel, BorderLayout.NORTH);
        add(scroller, BorderLayout.CENTER);
        add(wrappedBtb, BorderLayout.SOUTH);
        update();
    }

    private void resetRates() {
        Skill skill = rates.getRSSkill();
        if (JOptionPane.YES_OPTION == JOptionPane.showConfirmDialog(null,
                "Are you sure you reset custom XP rates?", "Reset Confirmation",
                JOptionPane.YES_NO_OPTION)) {
            rates = plugin.resetRates(skill);
            update();
        }
    }

    public void update() {
        SwingUtilities.invokeLater(this::updatePanel);
    }

    private void updatePanel() {
        ratesListPanel.removeAll();
        ratesListPanel.setLayout(new GridBagLayout());

        GridBagConstraints constraints = new GridBagConstraints();
        constraints.fill = GridBagConstraints.HORIZONTAL;
        constraints.weightx = 1;
        constraints.gridx = 0;
        constraints.gridy = 0;

        rates.getMethods().sort(Comparator.comparingInt(RateMethod::getLevel));
        for (RateMethod info : rates.getMethods()) {
            SkillRateBox srb = new SkillRateBox(info, () -> removeInfo(info));
            ratesListPanel.add(srb, constraints);
            constraints.gridy++;

            ratesListPanel.add(Box.createRigidArea(new Dimension(0, 16)), constraints);
            constraints.gridy++;
        }

        repaint();
        revalidate();

        if (scrollBottom) {
            SwingUtilities.invokeLater(() -> {
                scroller.getVerticalScrollBar().setValue(scroller.getVerticalScrollBar().getMaximum());
                scrollBottom = false;
            });
        }
    }

    private void addInfo() {
        rates.getMethods().add(new RateMethod(99, 0, null));
        update();
    }

    private void removeInfo(RateMethod info) {
        rates.getMethods().remove(info);
        update();
    }

    private void saveRates() {
        plugin.saveRates(rates);
        onBack.run();
    }
}

package com.ttl.ui;

import com.ttl.ImgUtils;
import com.ttl.TimeToLevelPlugin;
import net.runelite.client.util.ImageUtil;
import net.runelite.client.util.SwingUtil;
import org.apache.commons.lang3.StringUtils;

import javax.swing.*;
import javax.swing.border.EmptyBorder;
import java.awt.*;
import java.awt.image.BufferedImage;


public class SkillRatePanelHeader extends JPanel {
    private static final ImageIcon CANCEL_ICON;
    private static final ImageIcon CANCEL_ICON_HOVER;
    private static final ImageIcon CONFIRM_ICON;
    private static final ImageIcon CONFIRM_ICON_HOVER;
    private static final ImageIcon BACK_ICON;
    private static final ImageIcon BACK_ICON_HOVER;

    static {
        final BufferedImage cancelIcon = ImageUtil.getResourceStreamFromClass(TimeToLevelPlugin.class, "/cancel_icon.png");
        CANCEL_ICON = new ImageIcon(cancelIcon);
        CANCEL_ICON_HOVER = new ImageIcon(ImageUtil.alphaOffset(cancelIcon, 0.53f));

        final BufferedImage confirmIcon = ImageUtil.getResourceStreamFromClass(TimeToLevelPlugin.class, "/confirm_icon.png");
        CONFIRM_ICON = new ImageIcon(confirmIcon);
        CONFIRM_ICON_HOVER = new ImageIcon(ImageUtil.alphaOffset(confirmIcon, 0.53f));

        final BufferedImage backIcon = ImageUtil.getResourceStreamFromClass(TimeToLevelPlugin.class, "/back_icon.png");
        BACK_ICON = new ImageIcon(backIcon);
        BACK_ICON_HOVER = new ImageIcon(ImageUtil.alphaOffset(backIcon, 0.53f));
    }

    public SkillRatePanelHeader(String skill, Runnable onBack, Runnable onSave) {
        setLayout(new BorderLayout());
        setBorder(new EmptyBorder(8, 4, 8, 0));

        BufferedImage skillImg = ImgUtils.getSkillImage(skill, true);

        JPanel leftActions = new JPanel(new FlowLayout(FlowLayout.LEFT, 4, 0));
        JPanel rightActions = new JPanel(new FlowLayout(FlowLayout.RIGHT, 4, 0));

        {
            JButton backBtn = new JButton(BACK_ICON);
            backBtn.setRolloverIcon(BACK_ICON_HOVER);
            SwingUtil.removeButtonDecorations(backBtn);
            backBtn.addActionListener(e -> onBack.run());
            backBtn.setToolTipText("Back");

            JLabel skillLabel = new JLabel(new ImageIcon(skillImg));
            skillLabel.setToolTipText(StringUtils.capitalize(skill));

            leftActions.add(backBtn);
            leftActions.add(skillLabel);
        }

        {
            JButton confirmBtn = new JButton(CONFIRM_ICON);
            confirmBtn.setRolloverIcon(CONFIRM_ICON_HOVER);
            SwingUtil.removeButtonDecorations(confirmBtn);
            confirmBtn.setToolTipText("Confirm");
            confirmBtn.addActionListener(e -> onSave.run());

            JButton cancelBtn = new JButton(CANCEL_ICON);
            cancelBtn.setRolloverIcon(CANCEL_ICON_HOVER);
            SwingUtil.removeButtonDecorations(cancelBtn);
            cancelBtn.addActionListener(e -> {
                if (JOptionPane.YES_OPTION == JOptionPane.showConfirmDialog(null,
                        "Are you sure you discard changes?", "Discard Changes",
                        JOptionPane.YES_NO_OPTION)) {
                    onBack.run();
                }
            });
            cancelBtn.setToolTipText("Cancel");

            rightActions.add(confirmBtn, BorderLayout.EAST);
            rightActions.add(cancelBtn, BorderLayout.WEST);
        }

        add(leftActions, BorderLayout.WEST);
        add(rightActions, BorderLayout.EAST);

    }
}

package com.ttl.ui;

import com.ttl.ImgUtils;
import com.ttl.TimeToLevelPlugin;
import net.runelite.api.Skill;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.util.ImageUtil;
import net.runelite.client.util.SwingUtil;

import javax.swing.*;
import javax.swing.border.EmptyBorder;
import java.awt.*;
import java.awt.datatransfer.StringSelection;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.awt.image.BufferedImage;
import java.util.function.Consumer;

import static net.runelite.api.Skill.*;


public class RatesConfigPanel extends JPanel {
    private static final ImageIcon BACK_ICON;
    private static final ImageIcon BACK_ICON_HOVER;

    static {
        final BufferedImage backIcon = ImageUtil.getResourceStreamFromClass(TimeToLevelPlugin.class, "/back_icon.png");
        BACK_ICON = new ImageIcon(backIcon);
        BACK_ICON_HOVER = new ImageIcon(ImageUtil.alphaOffset(backIcon, 0.53f));
    }

    private final JPanel skillsPanel = new JPanel(new GridLayout(8, 3, 8, 16));
    private final TimeToLevelPlugin plugin;

    public RatesConfigPanel(TimeToLevelPlugin plugin, Runnable back, Consumer<Skill> showSkillRates) {
        setLayout(new BorderLayout());
        setBorder(new EmptyBorder(8, 8, 8, 8));
        this.plugin = plugin;

        JPanel northPanel = new JPanel(new BorderLayout());
        JButton backBtn = new JButton(BACK_ICON);
        backBtn.setRolloverIcon(BACK_ICON_HOVER);
        SwingUtil.removeButtonDecorations(backBtn);
        backBtn.setToolTipText("Back");
        backBtn.addActionListener(l -> back.run());
        northPanel.add(backBtn, BorderLayout.WEST);

        JPanel wrapper = new JPanel(new BorderLayout());
        skillsPanel.setBorder(new EmptyBorder(16, 8, 16, 8));
        skillsPanel.setBackground(ColorScheme.MEDIUM_GRAY_COLOR.darker());
        wrapper.add(skillsPanel, BorderLayout.NORTH);

        JButton resetBtn = new JButton("Reset all rates");
        resetBtn.addActionListener(l -> {
            if (JOptionPane.YES_OPTION == JOptionPane.showConfirmDialog(null,
                    "Are you sure you reset ALL custom XP rates?", "Reset Confirmation",
                    JOptionPane.YES_NO_OPTION)) {
                plugin.resetRates();
            }
        });

        JPanel buttons = new JPanel(new BorderLayout(4, 4));
        JPanel importExport = new JPanel(new GridLayout(1, 2, 8, 8));
        JButton imBtn = new JButton("Import rates");
        JButton exBtn = new JButton("Export rates");
        imBtn.addActionListener(l -> importRates());
        exBtn.addActionListener(l -> exportRates());
        exBtn.setFocusPainted(false);
        imBtn.setFocusPainted(false);
        resetBtn.setFocusPainted(false);

        buttons.add(resetBtn, BorderLayout.SOUTH);
        importExport.add(imBtn);
        importExport.add(exBtn);

        buttons.add(importExport, BorderLayout.NORTH);
        buttons.add(resetBtn, BorderLayout.SOUTH);

        add(northPanel, BorderLayout.NORTH);
        add(wrapper, BorderLayout.CENTER);
        add(buttons, BorderLayout.SOUTH);
        addSkills(showSkillRates);
    }

    private void importRates() {
        try {
            final String rates = JOptionPane.showInputDialog(this,
                    "Enter rates data",
                    "Import New Rates",
                    JOptionPane.PLAIN_MESSAGE);

            // cancel button was clicked
            if (rates == null) {
                return;
            }
            boolean success = plugin.setRatesConfig(rates);
            if (!success) {
                throw new Exception("failed to import rates");
            } else {
                JOptionPane.showMessageDialog(this,
                        "Skill rates were successfully imported.",
                        "Import Succeeded",
                        JOptionPane.PLAIN_MESSAGE);
            }
        } catch (Exception e) {
            JOptionPane.showMessageDialog(this,
                    "Invalid rates data.",
                    "Import Rates Failed",
                    JOptionPane.ERROR_MESSAGE);
        }
    }

    private void exportRates() {
        final StringSelection contents = new StringSelection(plugin.getRatesConfig());
        Toolkit.getDefaultToolkit().getSystemClipboard().setContents(contents, null);
        JOptionPane.showMessageDialog(this,
                "Skill rates was copied to clipboard.",
                "Export Succeeded",
                JOptionPane.PLAIN_MESSAGE);
    }

    private static final Skill[] SKILLS = {
            ATTACK, HITPOINTS, MINING,
            STRENGTH, AGILITY, SMITHING,
            DEFENCE, HERBLORE, FISHING,
            RANGED, THIEVING, COOKING,
            PRAYER, CRAFTING, FIREMAKING,
            MAGIC, FLETCHING, WOODCUTTING,
            RUNECRAFT, SLAYER, FARMING,
            CONSTRUCTION, HUNTER
    };

    private void addSkills(Consumer<Skill> showSkillRates) {
        skillsPanel.removeAll();

        for (Skill skill : SKILLS) {
            JLabel img = new JLabel(new ImageIcon(ImgUtils.getSkillImage(skill, false)));
            img.setToolTipText(skill.getName());
            img.addMouseListener(new MouseAdapter() {
                @Override
                public void mousePressed(MouseEvent e) {
                    showSkillRates.accept(skill);
                }
            });
            skillsPanel.add(img);
        }
    }
}

package com.ttl.ui;

import com.ttl.TimeToLevelPlugin;
import net.runelite.client.util.ImageUtil;
import net.runelite.client.util.LinkBrowser;
import net.runelite.client.util.SwingUtil;

import javax.swing.*;
import javax.swing.border.EmptyBorder;
import java.awt.*;
import java.awt.image.BufferedImage;


public class LevelsListPanelHeader extends JPanel {
    private static final ImageIcon REFRESH_ICON;
    private static final ImageIcon REFRESH_ICON_HOVER;
    private static final ImageIcon HELP_ICON;
    private static final ImageIcon HELP_ICON_HOVER;
    private static final ImageIcon CONFIG_ICON;
    private static final ImageIcon CONFIG_ICON_HOVER;

    static {
        final BufferedImage refreshIcon = ImageUtil.getResourceStreamFromClass(TimeToLevelPlugin.class, "/refresh_icon.png");
        REFRESH_ICON = new ImageIcon(refreshIcon);
        REFRESH_ICON_HOVER = new ImageIcon(ImageUtil.alphaOffset(refreshIcon, 0.53f));

        final BufferedImage helpIcon = ImageUtil.getResourceStreamFromClass(TimeToLevelPlugin.class, "/help_icon.png");
        HELP_ICON = new ImageIcon(helpIcon);
        HELP_ICON_HOVER = new ImageIcon(ImageUtil.alphaOffset(helpIcon, 0.53f));

        final BufferedImage configIcon = ImageUtil.getResourceStreamFromClass(TimeToLevelPlugin.class, "/config_icon.png");
        CONFIG_ICON = new ImageIcon(configIcon);
        CONFIG_ICON_HOVER = new ImageIcon(ImageUtil.alphaOffset(configIcon, 0.53f));
    }

    public LevelsListPanelHeader(Runnable onRefresh, Runnable showRatesConfig) {
        setLayout(new BorderLayout());
        setBorder(new EmptyBorder(8, 16, 8, 8));

        JButton refreshBtn = new JButton(REFRESH_ICON);
        refreshBtn.setRolloverIcon(REFRESH_ICON_HOVER);
        SwingUtil.removeButtonDecorations(refreshBtn);
        refreshBtn.setToolTipText("Refresh");
        refreshBtn.addActionListener(e -> onRefresh.run());

        JButton helpBtn = new JButton(HELP_ICON);
        helpBtn.setRolloverIcon(HELP_ICON_HOVER);
        SwingUtil.removeButtonDecorations(helpBtn);
        helpBtn.setToolTipText("Help");
        helpBtn.addActionListener(e -> LinkBrowser.browse("https://github.com/while-loop/runelite-plugins/tree/ttl#time-to-level"));
        JLabel title = new JLabel("Time to Level");
        title.setForeground(Color.WHITE);

        JButton configBtn = new JButton(CONFIG_ICON);
        SwingUtil.removeButtonDecorations(configBtn);
        configBtn.setRolloverIcon(CONFIG_ICON_HOVER);
        configBtn.setToolTipText("Edit XP Rates");
        configBtn.addActionListener(e -> showRatesConfig.run());

        JPanel leftActions = new JPanel(new FlowLayout(FlowLayout.LEFT, 4, 0));
        leftActions.add(title);
        leftActions.add(helpBtn);

        JPanel rightActions = new JPanel(new FlowLayout(FlowLayout.RIGHT, 0, 0));
        rightActions.add(configBtn);
        rightActions.add(refreshBtn);

        add(leftActions, BorderLayout.WEST);
        add(rightActions, BorderLayout.EAST);
    }
}

package com.ttl.ui;

import com.ttl.RateTTL;
import lombok.Getter;

import java.util.Comparator;

public enum SortOrder {
    SKILL((o1, o2) -> o1.getSkill().ordinal() - o2.getSkill().ordinal()),
    LEVEL((o1, o2) -> o1.getLevel() - o2.getLevel()),
    XP((o1, o2) -> o1.getXpLeft() - o2.getXpLeft()),
    RATE((o1, o2) -> o1.getXpRate() - o2.getXpRate()),
    TTL((o1, o2) -> o1.getSecondsLeft() - o2.getSecondsLeft()),
    ;

    Comparator<RateTTL> comparator;

    SortOrder(Comparator<RateTTL> comparator) {
        this.comparator = comparator;
    }

    @Getter
    boolean asc = true;

    void toggleAsc() {
        asc = !asc;
    }
}

package com.ttl;

import lombok.AllArgsConstructor;
import lombok.Data;
import net.runelite.api.Skill;

import java.util.ArrayList;

@Data
@AllArgsConstructor
public class Rates {
    private String skill;
    private ArrayList<RateMethod> methods;

    public Rates(Rates r) {
        skill = r.skill;
        methods = new ArrayList<>(r.methods.size());
        r.methods.forEach(ri -> methods.add(new RateMethod(ri)));
    }

    public Skill getRSSkill(){
        return Skill.valueOf(skill.toUpperCase());
    }
}

package com.ttl;

import lombok.AllArgsConstructor;
import lombok.Data;
import net.runelite.api.Skill;
import net.runelite.client.util.QuantityFormatter;

@Data
@AllArgsConstructor
public class RateTTL {
    Skill skill;
    int level;
    int xpLeft;
    int xpRate;
    int secondsLeft;
    RateMethod info;

    public String ttl() {
        if (secondsLeft < 0) {
            return "\u221e";
        }

        long durationHours = secondsLeft / (60 * 60);
        long durationMinutes = (secondsLeft % (60 * 60)) / 60;
        long durationSeconds = secondsLeft % 60;
        if (durationHours > 0) {
            return String.format("%02d:%02d:%02d", durationHours, durationMinutes, durationSeconds);
        }

        // Minutes and seconds will always be present
        return String.format("%02d:%02d", durationMinutes, durationSeconds);
    }

    public String toolTip() {
        return String.format("<html>Lvl %d<br>%s xp/hr<br>%s</html>", info.getLevel(), QuantityFormatter.quantityToRSDecimalStack(info.getRate()), info.getMethod());
    }
}

