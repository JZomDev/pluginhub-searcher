package com.tasktracker;

import lombok.Data;

@Data
public class CompletedTask
{
    private final long completedAt;
    private final String task;

    public CompletedTask(String taskName)
    {
        this.task = taskName;
        this.completedAt = System.currentTimeMillis();
    }

    public CompletedTask( long completed, String taskName)
    {
        this.task = taskName;
        this.completedAt = completed;
    }

}

package com.tasktracker;

import java.util.regex.Pattern;
import java.util.stream.Collectors;
import java.util.Arrays;

public class TaskChecker
{
    private static final Pattern SKILL_PATTERN = compilePattern("Attack", "Strength", "Defence", "Ranged",
            "Prayer", "Magic", "Runecraft", "Construction", "Hitpoints", "Agility", "Herblore", "Thieving",
            "Crafting", "Fletching", "Slayer", "Hunter", "Mining", "Smithing", "Fishing", "Cooking",
            "Firemaking", "Woodcutting", "Farming", "Sailing");
    private static final Pattern QUEST_PATTERN = compilePattern("A Kingdom Divided", "A Night at the Theatre", "A Porcine of Interest", "A Soul's Bane", "A Tail of Two Cats", "A Taste of Hope", "Alfred Grimhand's Barcrawl", "Animal Magnetism", "Another Slice of H.A.M.", "Architectural Alliance",
            "At First Light", "Barbarian Training", "Bear Your Soul", "Below Ice Mountain", "Between a Rock...", "Big Chompy Bird Hunter", "Biohazard", "Black Knights' Fortress", "Blood Runs Deep", "Bone Voyage",
            "Cabin Fever", "Children of the Sun", "Clock Tower", "Cold War", "Contact!", "Cook's Assistant", "Creature of Fenkenstrain", "Curse of the Empty Lord", "Daddy's Home", "Death on the Isle",
            "Death Plateau", "Death to the Dorgeshuun", "Demon Slayer", "Desert Treasure I", "Desert Treasure II - The Fallen Empire", "Devious Minds", "Dig Site", "Dragon Slayer I", "Dragon Slayer II", "Dream Mentor",
            "Eadgar's Ruse", "Eagles' Peak", "Elemental Workshop I", "Elemental Workshop II", "Enakhra's Lament", "Enchanted Key", "Enlightened Journey", "Enter the Abyss", "Ernest the Chicken", "Ethical Homunculus",
            "Fairytale I - Growing Pains", "Fairytale II - Cure a Queen", "Family Crest", "Family Pest", "Fight Arena", "Fishing Contest", "Forgettable Tale...", "Garden of Death", "Gerev's Grimoire", "Ghosts Ahoy",
            "Giant Dwarf", "Goblin Diplomacy", "Grim Tales", "Haunted Mine", "Hazeel Cult", "Heroes' Quest", "His Faithful Servants", "Holy Grail", "Hopespear's Will", "Horror from the Deep",
            "Icthlarin's Little Helper", "Imp Catcher", "In Aid of the Myreque", "In Search of Knowledge", "In Search of the Myreque", "Into the Tombs", "Jungle Potion", "King's Ransom", "Lair of Tarn Razorlor", "Legends' Quest",
            "Lost City", "Lunar Diplomacy", "Mage Arena I", "Mage Arena II", "Making Friends with Myarm", "Making History", "Merlin's Crystal", "Misthalin Mystery", "Monkey Madness I", "Monkey Madness II",
            "Monk's Friend", "Mountain Daughter", "Mourning's End Part I", "Mourning's End Part II", "Murder Mystery", "My Arm's Big Adventure", "Nature Spirit", "Observatory Quest", "Olaf's Quest", "One Small Favour",
            "Path of Glouphrie", "Perilous Moons", "Pirate's Treasure", "Plague City", "Priest in Peril", "Prince Ali Rescue", "Rag and Bone Man I", "Rag and Bone Man II", "Ratcatchers", "Recipe for Disaster",
            "Recruitment Drive", "Regicide", "Roving Elves", "Royal Trouble", "Rum Deal", "Rune Mysteries", "Scorpion Catcher", "Sea Slug", "Shades of Mort'ton", "Shadow of the Storm",
            "Sheep Herder", "Sheep Shearer", "Shield of Arrav", "Shilo Village", "Sins of the Father", "Skippy and the Mogres", "Sleeping Giants", "Song of the Elves", "Spirits of the Elid", "Swan Song",
            "Tai Bwo Wannai Trio", "Tears of Guthix", "Temple of Ikov", "Temple of the Eye", "The Ascent of Arceuus", "The Corsair Curse", "The Dig Site", "The Eyes of Glouphrie", "The Feud", "The Forsaken Tower",
            "The Fremennik Isles", "The Fremennik Trials", "The Frozen Door", "The General's Shadow", "The Golem", "The Grand Tree", "The Hand in the Sand", "The Knight's Sword", "The Lost Tribe", "The Restless Ghost",
            "The Ribbiting Tale of a Lily Pad Laborer", "The Slug Menace", "The Tourist Trap", "The Vault", "Throne of Miscellania", "Tower of Life", "Tree Gnome Village", "Tribal Totem", "Troll Romance", "Troll Stronghold",
            "Twilight's Promise", "Underground Pass", "Vampyre Slayer", "Watchtower", "Waterfall Quest", "What Lies Below", "While Guthix Sleeps", "Witch's House", "Witch's Potion", "X Marks the Spot",
            "Zogre Flesh Eaters");

    public static boolean containsSkill(String text)
    {
        return contains(SKILL_PATTERN,text);
    }

    public static boolean containsQuest(String text)
    {
        return contains(QUEST_PATTERN,text);
    }

    private static boolean contains(Pattern pattern, String text)
    {
        if (text == null)
        {
            return false;
        }
        return pattern.matcher(text).find();
    }

    private static Pattern compilePattern(String... terms)
    {
        String regex = Arrays.stream(terms)
                .map(Pattern::quote) // Safely handles special characters like "..."
                .collect(Collectors.joining("|"));

        return Pattern.compile(regex, Pattern.CASE_INSENSITIVE);
    }

}

package com.tasktracker;

import lombok.Getter;
import lombok.RequiredArgsConstructor;
import net.runelite.client.config.Config;
import net.runelite.client.config.ConfigGroup;
import net.runelite.client.config.ConfigItem;
import net.runelite.client.config.ConfigSection;
import net.runelite.client.config.Range;
import java.awt.Color;

@ConfigGroup("tasktracker")
public interface TaskTrackerConfig extends Config
{
    @ConfigItem(
            keyName = "enableSfx",
            name = "Enable Sounds",
            description = "Play sound effects when Rolling, Backloging, and Completing tasks.",
            position = 1
    )
    default boolean enableSfx()
    {
        return true;
    }

    @ConfigItem(
            keyName = "enableBacklog",
            name = "Enable Backlog",
            description = "Show the backlog button and panel",
            position = 2
    )
    default boolean enableBacklog()
    {
        return true;
    }

    @ConfigItem(
            keyName = "removeActive",
            name = "Remove from Active",
            description = "Remove the current task from active once completed.",
            position = 3
    )
    default boolean removeActive()
    {
        return true;
    }

    @ConfigItem(
            keyName = "currentTaskHighlightColor",
            name = "Highlight Color",
            description = "The highlight color of the current task in the active tasks list.",
            position = 4
    )
    default Color currentTaskHighlightColor()
    {
        return Color.YELLOW;
    }

    @Getter
    @RequiredArgsConstructor
    enum TimestampFormat
    {
        // Format: (Pattern, Label shown in Dropdown)
        US("MM/dd/yyyy HH:mm", "US (12/31/2024)"),
        EU("dd/MM/yyyy HH:mm", "EU (31/12/2024)"),
        ISO("yyyy-MM-dd HH:mm", "ISO (2024-12-31)");

        private final String pattern;
        private final String label;

        @Override
        public String toString()
        {
            return label;
        }
    }

    @ConfigItem(
            keyName = "timestampFormat",
            name = "Date Format",
            description = "Choose how the completed date will be displayed.",
            position = 5
    )
    default TimestampFormat timestampFormat()
    {
        return TimestampFormat.US;
    }

    @Getter
    @RequiredArgsConstructor
    enum SortStyle
    {
        NEWEST("Newest First"),
        OLDEST("Oldest First");

        private final String name;

        // RuneLite uses toString() to determine what text shows in the dropdown
        @Override
        public String toString()
        {
            return name;
        }
    }

    @ConfigItem(
            keyName = "completedSortStyle",
            name = "Sort Order",
            description = "Choose how to sort the completed tasks list.",
            position = 6
    )
    default SortStyle completedSortStyle()
    {
        return SortStyle.OLDEST;
    }

    @ConfigItem (
            keyName = "completedIndex",
            name = "Show Index Number",
            description = "Show the index number next to completed tasks in the panel.",
            position = 7
    )
    default boolean  completedIndex()
    {
        return true;
    }

    @Range(min = 0)
    @ConfigItem(
            keyName = "milestoneInterval",
            name = "Milestone Interval",
            description = "The number of completed tasks between highlights (e.g., 10). If set to 0 highlighting will be disabled.",
            position = 8
    )
    default int  milestoneInterval()
    {
        return 10;
    }

    @ConfigItem(
            keyName = "milestoneColor",
            name = "Milestone Color",
            description = "The color used to highlight the milestone.",
            position = 9
    )
    default Color  milestoneColor()
    {
        return Color.GREEN;
    }

    @ConfigSection(
            name = "WARNING: IF YOU CLICK RESET THIS WILL ALSO CLEAR ALL TASK DATA!",
            description = "Only click rest after you have saved your task data in a safe location.",
            position = 10
    )
    String warningSection = "warningSection";

    @ConfigItem(
            keyName = "allTasksJson",
            name = "All Tasks Json",
            description = "Json of all tasks currently saved in config",
            hidden = true,
            position = 30
    )
    default String allTasksJson()
    {
        return "";
    }
}

package com.tasktracker;

import lombok.Data;
import java.util.ArrayList;
import java.util.HashSet;
import java.util.List;
import java.util.Set;

@Data
public class TaskTrackerData
{
    private String currentTask = "";
    private List<String> active = new ArrayList<>();
    private List<String> backlog = new ArrayList<>();
    private List<CompletedTask> completed = new ArrayList<>();
    private Set<String> repeatableTasks = new HashSet<>();

    // For existing users updating
    public Set<String> getRepeatableTasks()
    {
        if (repeatableTasks == null)
        {
            repeatableTasks = new HashSet<>();
        }
        return repeatableTasks;
    }
}


package com.tasktracker;

import net.runelite.api.SpriteID;
import net.runelite.client.game.SpriteManager;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.FontManager;
import net.runelite.client.ui.PluginPanel;
import net.runelite.client.util.ImageUtil;
import javax.swing.BorderFactory;
import javax.swing.BoxLayout;
import javax.swing.ImageIcon;
import javax.swing.JButton;
import javax.swing.JCheckBoxMenuItem;
import javax.swing.JLabel;
import javax.swing.JMenuItem;
import javax.swing.JOptionPane;
import javax.swing.JPanel;
import javax.swing.JPopupMenu;
import javax.swing.JScrollPane;
import javax.swing.JTextArea;
import javax.swing.SwingConstants;
import javax.swing.SwingUtilities;
import javax.swing.border.Border;
import javax.swing.border.EmptyBorder;
import java.awt.BorderLayout;
import java.awt.Color;
import java.awt.Component;
import java.awt.Cursor;
import java.awt.GridBagConstraints;
import java.awt.GridBagLayout;
import java.awt.Insets;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.awt.image.BufferedImage;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Date;
import java.util.List;

public class TaskTrackerPanel extends PluginPanel
{
    // Strings used in ListPanels and Headers
    public static final String currentString = "Current Task";
    public static final String activeString = "Active Tasks";
    public static final String backlogString = "Backlog";
    public static final String completedString = "Completed Tasks";
    // Current Task section of UI
    private final JPanel currentTaskPanel = new JPanel();
    private final JLabel currentTaskLabel = new JLabel("No Current Task");
    private final JButton rollTaskButton = new JButton("Roll Task", ROLL_ICON);
    private final JButton completeTaskButton = new JButton("Complete Task", CHECK_ICON);
    private final JButton backlogTaskButton = new JButton("Backlog Task", ARROW_ICON);
    // Active List section of UI
    private final JLabel activeHeader = new JLabel(activeString);
    private final JPanel activeListPanel =  new JPanel();
    private final JButton activeButton = new JButton("Edit");
    // Backlog List section of UI
    private final JLabel backlogHeader =  new JLabel(backlogString);
    private final JPanel backlogListPanel =   new JPanel();
    private final JButton backlogButton =  new JButton("Edit");
    // Completed List section of UI
    private final JLabel completedHeader =  new JLabel(completedString);
    private final JPanel completedListPanel = new JPanel();
    private final JButton completedButton =  new JButton("Edit | Details");
    // Border used in UI construction
    private final Border compoundBorder = BorderFactory.createCompoundBorder(BorderFactory.createLineBorder(Color.WHITE), BorderFactory.createEmptyBorder(10,10,10,10));
    // Managers and logger
    private final TaskTrackerPlugin plugin;
    private final SpriteManager spriteManager;
    private static final org.slf4j.Logger logger = org.slf4j.LoggerFactory.getLogger(TaskTrackerPanel.class);
    // Button Icons
    private static final ImageIcon ROLL_ICON;
    private static final ImageIcon ARROW_ICON;
    private static final ImageIcon CHECK_ICON;


    // Code run only once after initialized
    static {
        // This block runs once when the class is loaded
        final BufferedImage rollImg = ImageUtil.loadImageResource(TaskTrackerPlugin.class, "img/roll.png");
        ROLL_ICON = new ImageIcon(ImageUtil.resizeImage(rollImg, 16, 16));

        final BufferedImage backlogImg = ImageUtil.loadImageResource(TaskTrackerPlugin.class, "img/arrow.png");
        ARROW_ICON = new ImageIcon(ImageUtil.resizeImage(backlogImg, 16, 16));

        final BufferedImage checkImg = ImageUtil.loadImageResource(TaskTrackerPlugin.class, "img/icon.png");
        CHECK_ICON = new ImageIcon(ImageUtil.resizeImage(checkImg, 16, 16));

    }

    // Constructor
    public TaskTrackerPanel(TaskTrackerPlugin plugin, SpriteManager spriteManager)
    {
        super();
        this.plugin = plugin;
        this.spriteManager = spriteManager;

        setLayout(new GridBagLayout());
        setBackground(ColorScheme.DARK_GRAY_COLOR);
        setBorder(new EmptyBorder(10, 10, 10, 10));

        // Add action listeners to buttons
        addButtonListeners();

    }

    // The main function to set up the UI
    public void setupSections()
    {
        // Initialize parent JPanel
        GridBagConstraints c = new GridBagConstraints();
        c.fill = GridBagConstraints.HORIZONTAL;
        c.weightx = 1.0;
        c.gridx = 0;
        c.gridy = 0; // Row counter
        c.insets = new Insets(0, 0, 10, 0); // Bottom margin for spacing

        // Get content from config
        TaskTrackerData data = plugin.getTaskData();

        // SECTION 1: Current Task
        addSection(this, c, new JLabel(currentString), currentTaskPanel, rollTaskButton, data.getActive(), currentString);

        // SECTION 2: Active Tasks
        addSection(this, c, activeHeader, activeListPanel, activeButton, data.getActive(), activeString);

        // SECTION 3: Backlog
        if (plugin.isBacklogEnabled())
        {
            addSection(this, c, backlogHeader, backlogListPanel, backlogButton, data.getBacklog(), backlogString);
        }

        // SECTION 4: Completed Tasks
        addSection(this, c, completedHeader, completedListPanel, completedButton, plugin.getCompletedTaskList(), completedString);

        revalidate();
        repaint();
    }

    // Helper function to add specific section in UI
    private void addSection(JPanel parent, GridBagConstraints c, JLabel header, JPanel panel, JButton button, List<String> contentList, String baseHeader)
    {

        updateTaskButtonLabel();

        setupAndAddHeader(parent, c, header, contentList, baseHeader);

        setupAndAddListPanel(parent, c, panel, contentList, baseHeader);

        setupAndAddButtons(parent, c, panel, button, header, contentList, baseHeader);

        // Reset fill for next section's labels
        c.fill = GridBagConstraints.HORIZONTAL;
        c.anchor = GridBagConstraints.WEST;
        c.insets = new Insets(0, 0, 10, 0);

    }

    // Function used to refresh UI after any config change
    public void refresh()
    {
        // Use SwingUtilities to ensure UI changes happen on the correct thread
        SwingUtilities.invokeLater(() -> {
            try
            {
                this.removeAll(); // Clear the entire panel
                setupSections();  // Re-run logic to add headers, lists, and buttons
                this.revalidate();
                this.repaint();
            }
            catch (Exception e)
            {
                logger.error("Error refreshing TaskTracker panel",e);
            }

        });
    }

    // Button function allows user to edit tasks
    private void openEditDialog(String title, String key)
    {
        TaskTrackerData data = plugin.getTaskData();
        List<CompletedTask> completedTasks = data.getCompleted();
        SimpleDateFormat dateFormat = plugin.getDateTimeFormat();
        List<String> currentList;
        String windowTitle = "Edit " + title;

        // Determine which list we are editing
        switch (key) {
            case "active":
                currentList = data.getActive();
                break;
            case "backlog":
                currentList = data.getBacklog();
                break;
            case "completed":
                currentList = new ArrayList<>();
                for (CompletedTask task : completedTasks)
                {
                    if (dateFormat != null)
                    {
                        Date date = new Date(task.getCompletedAt());

                        currentList.add(dateFormat.format(date) + " - " + task.getTask());
                    }
                    else
                    {
                        currentList.add(task.getTask());
                    }
                }
                break;
            default:
                return;
        }

        // Convert List to a single String with new lines, this will be the starting text
        String textToShow = String.join("\n", currentList);

        while (true)
        {
            // Create a Text Area for the user to type in
            JTextArea textArea = new JTextArea(textToShow);
            textArea.setRows(10);
            textArea.setColumns(40);
            textArea.setBackground(ColorScheme.DARKER_GRAY_COLOR);
            textArea.setForeground(Color.WHITE);
            textArea.setCaretColor(Color.WHITE);

            JScrollPane scrollPane = new JScrollPane(textArea);

            // Layout the panel
            JPanel mainPanel = new JPanel(new BorderLayout(0, 10));
            mainPanel.add(new JLabel("One task per line:"), BorderLayout.NORTH);
            mainPanel.add(scrollPane, BorderLayout.CENTER);


            // Create the "Clear All" button
            JButton clearButton = new JButton("Clear All");
            clearButton.setFocusable(false);
            clearButton.addActionListener(e -> textArea.setText(""));
            mainPanel.add(clearButton, BorderLayout.SOUTH);


            // Show the Dialog
            int result = JOptionPane.showConfirmDialog(
                    this,
                    mainPanel,
                    windowTitle,
                    JOptionPane.OK_CANCEL_OPTION,
                    JOptionPane.PLAIN_MESSAGE
            );

            // User cancelled
            if (result != JOptionPane.OK_OPTION)
            {
                break;
            }

            // Try to update
            boolean success = plugin.updateListFromText(data, key, textArea.getText());

            if (success)
            {
                break;
            }

            // If success is FALSE, the loop runs again
            // Update textToShow so the textArea re-opens with the User's bad input so they can fix it instead of typing it all again
            textToShow = textArea.getText();

        }
    }

    // Helper function for clean error alerts
    public void showError(String message)
    {
        JOptionPane.showMessageDialog(this, message, "Edit Failed", JOptionPane.ERROR_MESSAGE);
    }

    // Sets the current task icon based on recognized strings in taskText
    private void setTaskIcon(JLabel iconLabel, String taskText)
    {
        String text = taskText.toLowerCase();
        int spriteId = -1;

        if (text.contains("quest") || TaskChecker.containsQuest(text))
        {
            spriteId = SpriteID.TAB_QUESTS;
        }
        else if (text.contains("kill") || text.contains("slayer"))
        {
            spriteId = SpriteID.TAB_COMBAT;
        }
        else if (text.contains("level") || text.contains("xp") || TaskChecker.containsSkill(text))
        {
            spriteId = SpriteID.TAB_STATS;
        }
        else if (text.contains("obtain"))
        {
            spriteId = SpriteID.TAB_EQUIPMENT;
        }
        else if (text.contains("diary"))
        {
            spriteId = SpriteID.TAB_QUESTS_GREEN_ACHIEVEMENT_DIARIES;
        }
        else if (text.contains("buy"))
        {
            spriteId = SpriteID.GE_GUIDE_PRICE;
        }

        if (spriteId != -1)
        {
            // This helper handles the asynchronous loading of game sprites
            spriteManager.getSpriteAsync(spriteId, 0, (BufferedImage img) ->
            {
                if (img != null)
                {
                    SwingUtilities.invokeLater(() ->
                    {
                        iconLabel.setIcon(new ImageIcon(img));
                        iconLabel.revalidate();
                        iconLabel.repaint();
                    });
                }
            });
        }
        else
        {
            iconLabel.setIcon(null); // Clear if no match
        }
    }

    // Helper function to set the roll task button label
    private void updateTaskButtonLabel()
    {
        String currentTask = plugin.getCurrentTaskAsString();

        // Set Button Text
        if (currentTask.equals("No Current Task"))
        {
            rollTaskButton.setText("Roll Task");
        }
        else
        {
            rollTaskButton.setText("Reroll Task");
        }
    }

    // Helper function used to set up and add current header into parent panel
    private void setupAndAddHeader(JPanel parent, GridBagConstraints c, JLabel header, List<String> contentList, String baseHeader)
    {
        // Set Header Text for lists
        if(!contentList.isEmpty() && !baseHeader.equals(currentString))
        {
            header.setText(baseHeader + " (" + contentList.size() + ")");
        }
        else
        {
            header.setText(baseHeader);
        }

        // Add Header (Left Aligned)
        header.setFont(FontManager.getRunescapeBoldFont());
        c.anchor = GridBagConstraints.WEST;
        parent.add(header, c);
        c.gridy++;
    }

    // Helper function used to set up and add list panel into parent panel
    private void setupAndAddListPanel(JPanel parent, GridBagConstraints c, JPanel panel, List<String> contentList, String baseHeader )
    {
        String currentTask = plugin.getCurrentTaskAsString();

        // Add Content Text (Left Aligned)
        panel.removeAll();
        panel.setLayout(new BoxLayout(panel, BoxLayout.Y_AXIS));
        panel.setBorder(compoundBorder);
        panel.setOpaque(false);

        JLabel taskLabel;
        JLabel taskIcon = new JLabel();

        if (baseHeader.equals(currentString))
        {
            panel.setLayout(new BorderLayout(10,0));
            setTaskIcon(taskIcon,currentTask);
            currentTaskLabel.setText(currentTask);
            currentTaskLabel.setForeground(Color.WHITE);
            currentTaskLabel.setToolTipText(currentTask);
            currentTaskLabel.setAlignmentX(Component.LEFT_ALIGNMENT);

            panel.add(taskIcon, BorderLayout.WEST);
            panel.add(currentTaskLabel, BorderLayout.CENTER);

        }
        else
        {
            // If list is empty show the no tasks label
            if (contentList.isEmpty())
            {
                JLabel emptyLabel = new JLabel("No " + baseHeader);
                emptyLabel.setForeground(Color.WHITE);
                panel.add(emptyLabel);
            }
            // If list is not empty, add each task to the panel
            else
            {
                int index = plugin.newestCompletedFirst() ? contentList.size() : 1;
                boolean milestoneFound = false;
                int milestoneInterval = plugin.getMilestoneInterval();
                Color milestoneColor = plugin.getMilestoneColor();

                for (String task : contentList)
                {
                    taskLabel = new JLabel();
                    if (baseHeader.equals(completedString))
                    {
                        if (plugin.getShowIndex())
                        {
                            taskLabel.setText(index + ". " + task);
                        }
                        else
                        {
                            taskLabel.setText("• " + task);
                        }
                        if (milestoneInterval != 0)
                        {
                            if (index % milestoneInterval == 0)
                            {
                                milestoneFound = true;
                                taskLabel.setForeground(milestoneColor);
                            }
                            else
                            {
                                milestoneFound = false;
                                taskLabel.setForeground(Color.WHITE);
                            }
                        }
                        else
                        {
                            taskLabel.setForeground(Color.WHITE);
                        }
                    }
                    else
                    {
                        taskLabel.setText("• " + task);
                        taskLabel.setForeground(Color.WHITE);
                    }
                    if (task.equals(currentTaskLabel.getText()) && baseHeader.equals(activeString))
                    {
                        taskLabel.setForeground(plugin.getCurrentTaskHighlightColor());
                    }

                    taskLabel.setAlignmentX(Component.LEFT_ALIGNMENT);
                    taskLabel.setToolTipText(task);
                    addMouseListeners(taskLabel,createPopupMenu(task,baseHeader),milestoneFound,task,baseHeader);
                    panel.add(taskLabel);

                    index = plugin.newestCompletedFirst() ? index - 1 : index + 1;
                }
            }
        }

        c.anchor = GridBagConstraints.WEST;
        c.insets = new Insets(0, 1, 5, 1); // Tighten gap between text and button
        parent.add(panel, c);
        c.gridy++;
    }

    // Helper function used to set up buttons into parent panel
    private void setupAndAddButtons(JPanel parent, GridBagConstraints c, JPanel panel, JButton button, JLabel header, List<String> contentList, String baseHeader)
    {
        // Add Button (Centered)
        // Change anchor to CENTER and fill to NONE
        c.anchor = GridBagConstraints.CENTER;
        c.fill = GridBagConstraints.NONE;
        c.insets = new Insets(5, 0, 20, 0); // Large margin at bottom of section

        if (baseHeader.equals(currentString))
        {
            JPanel buttonContainer = createAndAddTaskButtons();
            parent.add(buttonContainer, c);
        }
        else
        {
            parent.add(button, c);
        }

        c.gridy++;
    }

    // Helper function used to create the buttonContainer for buttons below current task
    private JPanel createAndAddTaskButtons()
    {
        JPanel buttonContainer = new JPanel(new GridBagLayout());
        buttonContainer.setOpaque(false);
        GridBagConstraints gbc = new GridBagConstraints();
        gbc.insets = new Insets(2, 0, 2, 0);
        // Add roll task button ROW 1 BUTTON 1 (LEFT)
        gbc.gridx = 0;
        gbc.gridy = 0;
        gbc.fill = GridBagConstraints.HORIZONTAL;
        if (!plugin.isBacklogEnabled())
        {
            gbc.fill = GridBagConstraints.NONE;
            gbc.anchor = GridBagConstraints.CENTER;
            gbc.gridwidth = 2;
        }
        rollTaskButton.setHorizontalTextPosition(SwingConstants.RIGHT);
        rollTaskButton.setMargin(new Insets(2, 2, 2, 2));
        buttonContainer.add(rollTaskButton, gbc);
        if (plugin.isBacklogEnabled())
        {
            // Add Backlog Task Button ROW 1 BUTTON 2 (RIGHT)
            gbc.gridx = 1;
            gbc.gridy = 0;
            backlogTaskButton.setHorizontalTextPosition(SwingConstants.RIGHT);
            backlogTaskButton.setMargin(new Insets(2, 2, 2, 2));
            buttonContainer.add(backlogTaskButton, gbc);
        }
        // Add Complete Task Button ROW 2 BUTTON 3 (CENTER)
        gbc.gridx = 0;
        gbc.gridy = 1;
        gbc.gridwidth = 2;  // This makes the button span across both columns
        gbc.fill = GridBagConstraints.NONE;
        gbc.anchor = GridBagConstraints.CENTER;
        completeTaskButton.setHorizontalTextPosition(SwingConstants.RIGHT);
        buttonContainer.add(completeTaskButton,gbc);

        return buttonContainer;
    }

    // Helper function to add all action listeners to buttons
    private void addButtonListeners()
    {
        rollTaskButton.addActionListener(e -> plugin.rollTask());
        backlogTaskButton.addActionListener(e -> plugin.backlogCompleteTask("backlog"));
        completeTaskButton.addActionListener(e -> plugin.backlogCompleteTask("complete"));
        activeButton.addActionListener(e -> openEditDialog("Active Tasks","active"));
        backlogButton.addActionListener(e -> openEditDialog("Backlog","backlog"));
        completedButton.addActionListener(e -> openEditDialog("Completed Tasks", "completed"));
    }

    // Helper function to add the right click menu to list items within panels
    private JPopupMenu createPopupMenu(String task, String baseHeader)
    {
        JPopupMenu menu = new JPopupMenu();

        // Option 1: Delete specific task
        JMenuItem deleteItem = new JMenuItem("Delete Task");
        deleteItem.addActionListener(e -> {
            plugin.deleteTask(task,baseHeader);
        });

        //Option 2: Move back to Active
        if (!baseHeader.equals(activeString))
        {
            JMenuItem reactiveItem = new JMenuItem("Move to Active");
            reactiveItem.addActionListener(e -> {
                plugin.moveTaskToActive(task,baseHeader);
            });
            menu.add(reactiveItem);
        }
        // Option 3: Make current task / backlog task
        else
        {
            if (!task.equals(plugin.getCurrentTaskAsString()))
            {
                JMenuItem makeCurrentItem = new JMenuItem("Make Current Task");
                makeCurrentItem.addActionListener(e -> {
                    plugin.makeCurrentTask(task);
                });
                menu.add(makeCurrentItem);
            }
            else
            {
                JMenuItem resetCurrentItem = new JMenuItem("Reset Current Task");
                resetCurrentItem.addActionListener(e -> {
                    plugin.makeCurrentTask("");
                });
                menu.add(resetCurrentItem);
            }

            if (plugin.isBacklogEnabled())
            {
                JMenuItem backlogItem = new JMenuItem("Backlog Task");
                backlogItem.addActionListener(e -> {
                    plugin.backlogTask(task);
                });
                menu.add(backlogItem);
            }

            JCheckBoxMenuItem repeatableItem = new JCheckBoxMenuItem("Repeatable");
            repeatableItem.setSelected(plugin.isTaskRepeatable(task));
            repeatableItem.setHorizontalTextPosition(SwingConstants.LEFT);
            repeatableItem.addActionListener(e -> plugin.toggleRepeatableTask(task));
            menu.add(repeatableItem);

        }

        menu.add(deleteItem);

        return menu;

    }

    // Helper function to add all mouse listeners
    private void addMouseListeners(JLabel label, JPopupMenu menu, boolean milestone, String task, String baseHeader)
    {
        label.addMouseListener(new MouseAdapter() {
            @Override
            public void mouseEntered(MouseEvent e) {
                label.setCursor(new Cursor(Cursor.HAND_CURSOR));
                label.setForeground(ColorScheme.BRAND_ORANGE);
            }

            @Override
            public void mouseExited(MouseEvent e) {
                if (milestone)
                {
                    label.setForeground(plugin.getMilestoneColor());
                }
                if (baseHeader.equals(activeString) && task.equals(plugin.getCurrentTaskAsString()))
                {
                    label.setForeground(plugin.getCurrentTaskHighlightColor());
                }
                else
                {
                    label.setForeground(Color.WHITE);
                }
            }

            @Override
            public void mousePressed(MouseEvent e) {
                if (e.isPopupTrigger()) showMenu(e);
            }

            @Override
            public void mouseReleased(MouseEvent e) {
                if (e.isPopupTrigger()) showMenu(e);
            }

            private void showMenu(MouseEvent e) {
                menu.show(e.getComponent(), e.getX(), e.getY());
            }
        });
    }

}

package com.tasktracker;

import com.google.gson.Gson;
import com.google.inject.Provides;
import javax.inject.Inject;
import javax.swing.SwingUtilities;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.client.audio.AudioPlayer;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.events.ConfigChanged;
import net.runelite.client.game.SpriteManager;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.plugins.PluginDescriptor;
import net.runelite.client.ui.ClientToolbar;
import net.runelite.client.ui.NavigationButton;
import net.runelite.client.util.ImageUtil;
import java.awt.Color;
import java.awt.image.BufferedImage;
import java.io.InputStream;
import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Comparator;
import java.util.Date;
import java.util.HashSet;
import java.util.List;
import java.util.Random;
import java.util.Set;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

@Slf4j
@PluginDescriptor(
	name = "Task Tracker"
)
public class TaskTrackerPlugin extends Plugin
{
	@Inject
	private Client client;

	@Inject
	private TaskTrackerConfig config;

    @Inject
    private ClientToolbar clientToolbar;

    @Inject
    private ConfigManager configManager;

    @Inject
    private SpriteManager spriteManager;

    @Inject
    private Gson gson;

    @Inject
    private AudioPlayer audioPlayer;

    private TaskTrackerPanel panel;
    private NavigationButton navButton;

    private final ExecutorService audioExecutor = Executors.newSingleThreadExecutor();

	@Override
	protected void startUp() throws Exception
	{
		log.debug("Task Tracker started!");

        BufferedImage icon = ImageUtil.loadImageResource(getClass(), "img/icon.png");

        SwingUtilities.invokeLater( () -> {
            panel = new TaskTrackerPanel(this, spriteManager);
            panel.setupSections();

            navButton = NavigationButton.builder()
                    .tooltip("Task Tracker")
                    .icon(icon)
                    .panel(panel)
                    .build();

            clientToolbar.addNavigation(navButton);

        });
	}

	@Override
	protected void shutDown() throws Exception
	{
        clientToolbar.removeNavigation(navButton);
        audioExecutor.shutdown();
		log.debug("Task Tracker stopped!");
	}

    @Subscribe
    public void onConfigChanged(ConfigChanged event)
    {
        // Check if the change belongs to your plugin group
        if (event.getGroup().equals("tasktracker"))
        {
            panel.refresh();
        }
    }

	@Provides
    TaskTrackerConfig provideConfig(ConfigManager configManager)
	{
		return configManager.getConfig(TaskTrackerConfig.class);
	}

    // Get task data from config
    public TaskTrackerData getTaskData()
    {
        String json = configManager.getConfiguration("tasktracker","allTasksJson");
        if (json == null || json.isEmpty())
        {
            return new TaskTrackerData();
        }
        return gson.fromJson(json, TaskTrackerData.class);
    }

    // Save task data to config
    private void saveTaskData(TaskTrackerData data)
    {
        Comparator<String> naturalOrder = createNaturalOrderComparator();

        // Sort Active Tasks
        if (data.getActive() != null)
        {
            data.getActive().sort(naturalOrder);
        }
        // Sort Backlog Tasks
        if (data.getBacklog() != null)
        {
            data.getBacklog().sort(naturalOrder);
        }
        // Sort Completed Tasks
        if (data.getCompleted() != null)
        {
            if (newestCompletedFirst())
            {
                data.getCompleted().sort(Comparator.comparing(CompletedTask::getCompletedAt).reversed());
            }
            else
            {
                data.getCompleted().sort(Comparator.comparing(CompletedTask::getCompletedAt));
            }
        }

        String json = gson.toJson(data);
        configManager.setConfiguration("tasktracker","allTasksJson",json);
    }

    // Button function roll a unique task, rerolling the same task is impossible
    public void rollTask()
    {
        log.info("Rolling Task");
        TaskTrackerData data = getTaskData();

        // Make sure we don't reroll the same task
        List<String> rollableTasks = new ArrayList<>(data.getActive());
        if (rollableTasks.contains(data.getCurrentTask()))
        {
            rollableTasks.remove(data.getCurrentTask());
        }
        // Make sure we have a task to roll
        if (rollableTasks.isEmpty())
        {
            return;
        }

        playSound("dice.wav");

        Random random = new Random();
        String newCurrentTask = rollableTasks.get(random.nextInt(rollableTasks.size()));

        data.setCurrentTask(newCurrentTask);
        saveTaskData(data);
    }

    // Button function backlog or complete a task based on key
    public void backlogCompleteTask(String key)
    {
        log.debug("Backlog Complete Task Button Clicked");
        TaskTrackerData data = getTaskData();
        String currentTask = data.getCurrentTask();
        List<String> activeTasks = data.getActive();

        if (currentTask == null || currentTask.isEmpty() || currentTask.equals("No Current Task"))
        {
            log.debug("No Current Task");
            return;
        }

        if (activeTasks.isEmpty() || !activeTasks.contains(currentTask))
        {
            log.debug("No Active Tasks or Current Task not in list");
            return;
        }

        if (key.equals("backlog"))
        {
            playSound("equip.wav");
            data.getBacklog().add(currentTask);
            data.getActive().remove(currentTask);
        }
        else if (key.equals("complete"))
        {
            playSound("coins.wav");
            data.getCompleted().add(new CompletedTask(currentTask));
            if (removeFromActive() && !isTaskRepeatable(currentTask))
            {
                data.getActive().remove(currentTask);
            }
        }

        data.setCurrentTask("");
        saveTaskData(data);
    }

    // Menu function for right click delete task
    public void deleteTask(String task, String section)
    {
        TaskTrackerData data = getTaskData();

        switch(section)
        {
            case TaskTrackerPanel.activeString:
                data.getActive().remove(task);
                break;
            case TaskTrackerPanel.backlogString:
                data.getBacklog().remove(task);
                break;
            case TaskTrackerPanel.completedString:
                data.getCompleted().removeIf(t -> t.getTask().equals(task));
                break;
            default:
                break;
        }

        saveTaskData(data);
    }

    // Menu function for right click move task to active
    public void moveTaskToActive(String task, String section)
    {
        TaskTrackerData data = getTaskData();

        switch(section)
        {
            case TaskTrackerPanel.backlogString:
                if (!data.getActive().contains(task))
                {
                    data.getActive().add(task);
                }
                data.getBacklog().remove(task);
                break;
            case TaskTrackerPanel.completedString:
                if (!data.getActive().contains(task))
                {
                    data.getActive().add(task);
                }
                data.getCompleted().removeIf(t -> t.getTask().equals(task));
                break;
            default:
                break;
        }

        saveTaskData(data);
    }

    // Menu function for right click make current task
    public void makeCurrentTask(String task)
    {
        TaskTrackerData data = getTaskData();

        data.setCurrentTask(task);

        saveTaskData(data);
    }

    // Menu function for right click backlog task
    public void backlogTask(String task)
    {
        TaskTrackerData data = getTaskData();

        playSound("equip.wav");
        data.getBacklog().add(task);
        data.getActive().remove(task);

        saveTaskData(data);
    }

    // Menu function to toggle repeatable tasks
    public void toggleRepeatableTask(String task)
    {
        TaskTrackerData data = getTaskData();
        Set<String> repeatableTasks = data.getRepeatableTasks();
        if (repeatableTasks.contains(task))
        {
            repeatableTasks.remove(task);
        }
        else
        {
            repeatableTasks.add(task);
        }

        saveTaskData(data);
    }

    // Function to play custom sounds from resources folder
    public void playSound(String soundFile)
    {
        // Check config
        if (!config.enableSfx())
        {
            return;
        }

        audioExecutor.submit( () ->
        {
            String path = "/com/tasktracker/audio/" + soundFile;
            // Load the file from resources
            try (InputStream stream = getClass().getResourceAsStream(path))
            {
                if (stream == null)
                {
                    log.warn("Sound file not found :{}",path);
                    return;
                }

                audioPlayer.play(stream, 0);

            }
            catch (Exception e)
            {
                log.error("Failed to play sound: " + soundFile, e);
            }
        });
    }

    // Helper function to update inner TaskData Lists from text
    public boolean updateListFromText(TaskTrackerData data, String key, String text)
    {
        // HashSet for active and backlogged tasks
        Set<String> uniqueTasks = new HashSet<>();
        // List for completed tasks
        List<CompletedTask> newCompletedTasks = new  ArrayList<>();
        // Date format from configuration
        SimpleDateFormat dateFormat = getDateTimeFormat();

        // Don't allow "rolling over" invalid dates (e.g., 32nd of Jan -> 1st Feb)
        if (dateFormat != null)
        {
            dateFormat.setLenient(false);
        }

        // Split textArea by lines and initiate lineNumber
        String [] lines = text.split("\n");
        int lineNumber = 0;

        for (String line : lines)
        {
            lineNumber++;
            // Skip empty lines
            if (line.isEmpty())
            {
                continue;
            }
            // Completed Task Logic
            if (key.equals("completed"))
            {
                // If no format is selected just create task with current time (This should not happen)
                if (dateFormat == null)
                {
                    newCompletedTasks.add(new CompletedTask(line.trim()));
                    continue;
                }

                // Split string, limit=2 ensures if the task name has a hyphen it doesn't break
                String[] split = line.split(" - ",2);

                // Validate split and text format
                if (split.length < 2)
                {
                    panel.showError("Format Error on Line " + lineNumber + ":\n" +
                            "Missing separator ' - '\n" +
                            "Expected: [Date] - [Task Name]\n" +
                            "Found: " + line);
                    return false;
                }

                String datePart = split[0].trim();
                String taskPart = split[1].trim();

                // Validate date
                try
                {
                    Date date = dateFormat.parse(datePart);
                    newCompletedTasks.add(new CompletedTask(date.getTime(), taskPart));
                }
                catch (ParseException e)
                {
                    panel.showError("Date Error on Line " + lineNumber + ":\n" +
                            "Invalid date format: '" + datePart + "'\n" +
                            "Expected format: " + getTimestampFormat());
                    return false;
                }
            }
            // Active and Backlog Task Logic
            else
            {
                uniqueTasks.add(line.trim());
            }
        }

        // List for active and backlog tasks
        List<String> newList = new ArrayList<>(uniqueTasks);

        switch (key)
        {
            case "active":
                data.setActive(newList);
                break;
            case "backlog":
                data.setBacklog(newList);
                break;
            case "completed":
                data.setCompleted(newCompletedTasks);
                break;
        }

        saveTaskData(data);
        return true;
    }

    // Helper function to see if task is repeatable
    public boolean isTaskRepeatable(String task)
    {
        return getTaskData().getRepeatableTasks().contains(task);
    }

    // Helper function to get the completed task list in the List<String> format
    public List<String> getCompletedTaskList()
    {
        TaskTrackerData data = getTaskData();
        List<CompletedTask> completed = new ArrayList<>(data.getCompleted());
        List<String> list = new ArrayList<>();

        if (completed != null)
        {
            for (CompletedTask task : completed)
            {
                list.add(task.getTask());
            }
        }

        return list;
    }

    // Helper function to get the current task as a string even if config is null
    public String getCurrentTaskAsString()
    {
        // Get current task
        String currentTask = getTaskData().getCurrentTask();
        currentTask = currentTask == null || currentTask.isEmpty() ? "No Current Task" : currentTask;
        return currentTask;

    }

    // Helper function to create the Comparator<String> for comparing numbers naturally
    private Comparator<String> createNaturalOrderComparator()
    {
        return (s1, s2) ->
        {
            // Extract leading numbers from both strings
            Integer n1 = extractLeadingNumber(s1);
            Integer n2 = extractLeadingNumber(s2);

            // If both have numbers, compare the numbers numerically
            if (n1 != null && n2 != null) {
                int numCompare = n1.compareTo(n2);
                if (numCompare != 0) return numCompare;
            }

            // If numbers are equal or one doesn't have a number, fallback to alphabetical
            return s1.compareToIgnoreCase(s2);
        };
    }

    // Helper function to grab the number at the start of the string
    private Integer extractLeadingNumber(String s) {
        try {
            String[] parts = s.split("\\s+"); // Split by space
            if (parts.length > 0) {
                // Remove any non-digit characters (like ':' or letters) from the first part
                String numStr = parts[0].replaceAll("\\D", "");
                return numStr.isEmpty() ? null : Integer.parseInt(numStr);
            }
        } catch (NumberFormatException e) {
            return null;
        }
        return null;
    }

    // Helper function to see if backlog is enabled
    public boolean isBacklogEnabled()
    {
        return config.enableBacklog();
    }

    // Helper function to see if we remove current task from active list after completion
    public boolean removeFromActive()
    {
        return config.removeActive();
    }

    // Helper function to get the current config color
    public Color getCurrentTaskHighlightColor()
    {
        return config.currentTaskHighlightColor();
    }

    // Helper function to get the current dateTimeFormat
    public SimpleDateFormat getDateTimeFormat()
    {
        return new SimpleDateFormat(config.timestampFormat().getPattern());
    }

    // Helper function to get the current timestamp format as a string
    public String getTimestampFormat()
    {
        return config.timestampFormat().getPattern();
    }

    // Helper function to determine sort order for completed tasks
    public boolean newestCompletedFirst()
    {
        return config.completedSortStyle().equals(TaskTrackerConfig.SortStyle.NEWEST);
    }

    public boolean getShowIndex()
    {
        return config.completedIndex();
    }

    // Helper function to get the current milestone interval
    public int getMilestoneInterval()
    {
        return config.milestoneInterval();
    }

    // Helper function to get the current milestone highlight color
    public Color getMilestoneColor()
    {
        return config.milestoneColor();
    }
}

package com.tasktracker;

import net.runelite.client.RuneLite;
import net.runelite.client.externalplugins.ExternalPluginManager;

public class TaskTrackerPluginTest
{
	public static void main(String[] args) throws Exception
	{
		ExternalPluginManager.loadBuiltin(TaskTrackerPlugin.class);
		RuneLite.main(args);
	}
}
