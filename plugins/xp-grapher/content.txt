package com.xpgrapher;

import net.runelite.client.RuneLite;
import net.runelite.client.externalplugins.ExternalPluginManager;

public class XpGrapherTest
{
	public static void main(String[] args) throws Exception
	{
		ExternalPluginManager.loadBuiltin(XpGrapherPlugin.class);
		RuneLite.main(args);
	}
}
package com.xpgrapher;

import net.runelite.api.Skill;

import java.lang.reflect.Array;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.Map;

public class XpGraphPointManager {

    private XpGrapherPlugin grapherPlugin;
    private Map<Skill, ArrayList> skillGraphPointsMap = new HashMap<Skill, ArrayList>();
    public Map<Skill, Boolean> isSkillShownMap = new HashMap<Skill, Boolean>();

    public int maxVertAxisValue = 0;

    public int[] xpGraphMaxValues = {
            0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10,
            12, 15, 20, 25, 30, 40, 50, 60, 80, 100,
            125, 150, 200, 250, 300, 400, 500, 600, 800, 1000,
            1250, 1500, 2000, 2500, 3000, 4000, 5000, 6000, 8000, 10000,
            12500, 15000, 20000, 25000, 30000, 40000, 50000, 60000, 80000, 100000,
            125000, 150000, 200000, 250000, 300000, 400000, 500000, 600000, 800000, 1000000,
            1250000, 1500000, 2000000, 2500000, 3000000, 4000000, 5000000, 6000000, 8000000, 10000000,
            12500000, 15000000, 20000000, 25000000, 30000000, 40000000, 50000000, 60000000, 80000000, 100000000
    };



    public XpGraphPointManager(XpGrapherPlugin grapherPlugin) {

        this.grapherPlugin = grapherPlugin;

        for (int i = 0; i < grapherPlugin.skillList.length; i++) {
            ArrayList<Integer> newGraphPointList = new ArrayList<Integer>();
            skillGraphPointsMap.put(grapherPlugin.skillList[i], newGraphPointList);
            isSkillShownMap.put(grapherPlugin.skillList[i], false);
        }

    }

    public boolean isSkillShown(Skill theSkill) {
        return isSkillShownMap.get(theSkill);
    }

    public int getGraphPointData(Skill skillToGraph, int x) {
        ArrayList<Integer> skillGraphData = skillGraphPointsMap.get(skillToGraph);
        //System.out.println(skillToGraph.getName());
        if (skillGraphData.size() == 0)
            return grapherPlugin.graphHeight;
        else {
            int y = skillGraphData.get(x);
            return y;
        }

    }

    public ArrayList<Integer> getGraphPointDataList(Skill theSkill) {
        return skillGraphPointsMap.get(theSkill);
    }

    public void update() {

        int maxXpGained = -1;

        for (int i = 0; i < grapherPlugin.skillList.length; i++) {

            Skill skillToCheck = grapherPlugin.skillList[i];

            if (grapherPlugin.isSkillShown(skillToCheck)) {
                int skillMinXp = grapherPlugin.xpDataManager.getXpData(skillToCheck, 0);
                //System.out.println(grapherPlugin.tickCount);
                int skillMaxXp = grapherPlugin.xpDataManager.getXpData(skillToCheck, grapherPlugin.tickCount);
                int skillXpGained = skillMaxXp - skillMinXp;
                if (maxXpGained == -1 || skillXpGained > maxXpGained)
                    maxXpGained = skillXpGained;
            }

        }

        boolean maxXpFound = false;
        int maxXpIndex = 0;
        while (!maxXpFound) {
            if (maxXpGained <= xpGraphMaxValues[maxXpIndex]) {
                maxXpFound = true;
                //System.out.println(xpGraphMaxValues[maxXpIndex]);
            } else {
                maxXpIndex++;
            }
        }
        maxVertAxisValue = xpGraphMaxValues[maxXpIndex];

        for (int i = 0; i < grapherPlugin.skillList.length; i++) {

            Skill skillToUpdate = grapherPlugin.skillList[i];

            ArrayList<Integer> newGraphPointList = new ArrayList<Integer>();

            for (int x = 0; x < grapherPlugin.graphWidth; x++) {

                double ratioAcrossGraph = (double)x/((double)grapherPlugin.graphWidth);

                int dataIndex = (int)(Math.floor(ratioAcrossGraph*(grapherPlugin.tickCount+1)));

                //int ceilDataIndex = (int)(Math.ceil(ratioAcrossGraph*(grapherPlugin.tickCount)));
                //int floorDataIndex = (int)(Math.floor(ratioAcrossGraph*(grapherPlugin.tickCount)));
                //System.out.println(ceilDataIndex + ", " + floorDataIndex);

                int dataXpValue = grapherPlugin.xpDataManager.getXpData(skillToUpdate, dataIndex);
                if (x == 0) {
                    dataXpValue = grapherPlugin.xpDataManager.getXpData(skillToUpdate, 0);
                }
                if (x == grapherPlugin.graphWidth - 1) {
                    dataXpValue = grapherPlugin.xpDataManager.getMostRecentXp(skillToUpdate);
                }

                int dataXpMinValue = grapherPlugin.xpDataManager.getXpData(skillToUpdate, 0);
                int dataXpGained = dataXpValue -  dataXpMinValue;

                double ratioVertical = dataXpGained/(double) maxVertAxisValue;
                int y = grapherPlugin.graphHeight - (int)((double)grapherPlugin.graphHeight*ratioVertical);

                //if (x == grapherPlugin.graphWidth-1) {
                //
                //    dataXpValue = grapherPlugin.getClient().getSkillExperience(skillToUpdate);
                //
                //}

                newGraphPointList.add(y);

            }

            skillGraphPointsMap.put(skillToUpdate, newGraphPointList);
        }

    }

}

package com.xpgrapher;

import com.google.inject.Provides;
import javax.inject.Inject;
import javax.sound.midi.SysexMessage;

import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.Skill;
import net.runelite.api.events.GameTick;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.events.ConfigChanged;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.plugins.PluginDescriptor;
import net.runelite.client.ui.overlay.OverlayManager;

import java.awt.*;
import java.sql.Time;
import java.util.ArrayList;

@Slf4j
@PluginDescriptor(
		name = "XP Grapher"
)
public class XpGrapherPlugin extends Plugin {

	@Inject
	private Client client;

	@Inject
	public XpGrapherConfig config;

	public Skill[] skillList;
	public Skill mostRecentSkillGained;

	public int tickCount = 0;
	public long startTime = 0;
	public long currentTime = 0;
	public XpDataManager xpDataManager;
	public XpGraphPointManager xpGraphPointManager;
	public XpGraphColorManager xpGraphColorManager;

	public int graphWidth;
	public int graphHeight;

	public int numVerticalDivisions = 5;

	//public int maxNumberOfGraphedSkills = 8;
	public ArrayList<Skill> currentlyGraphedSkills = new ArrayList<Skill>();

	private boolean lastTickResetGraphSwitch = false;
	private boolean thisTickResetGraphSwitch = false;

	public boolean startMessageDisplaying = true;

	@Provides
	XpGrapherConfig getConfig(ConfigManager configManager)
	{
		return configManager.getConfig(XpGrapherConfig.class);
	}



	@com.google.inject.Inject
	private XpGrapherOverlay overlay;

	@com.google.inject.Inject
	private OverlayManager overlayManager;

	@Override
	public void startUp()
	{
		graphWidth = config.graphWidth();
		graphHeight = config.graphHeight();
		skillList = Skill.values();
		xpDataManager = new XpDataManager(this);
		xpGraphPointManager = new XpGraphPointManager(this);
		xpGraphColorManager = new XpGraphColorManager(this);
		startTime = System.currentTimeMillis();

		overlayManager.add(overlay);

	}

	@Override
	public void shutDown()
	{
		overlayManager.remove(overlay);
	}

	private boolean isSkillCurrentlyGraphed(Skill theSkill) {
		for (int i = 0; i < currentlyGraphedSkills.size(); i++) {
			if (currentlyGraphedSkills.get(i).getName() == theSkill.getName())
				return true;
		}
		return false;
	}

	public void graphSkill(Skill skillToAdd) {
		mostRecentSkillGained = skillToAdd;
		if (!isSkillCurrentlyGraphed(skillToAdd)) {
			if (currentlyGraphedSkills.size() < config.maxSkillsToGraph()) {
				currentlyGraphedSkills.add(skillToAdd);
				xpGraphPointManager.isSkillShownMap.put(skillToAdd, true);
			} else {
				while(currentlyGraphedSkills.size() > config.maxSkillsToGraph())
					removeSkill();
				currentlyGraphedSkills.add(skillToAdd);
				xpGraphPointManager.isSkillShownMap.put(skillToAdd, true);
			}
		}

	}

	public void removeSkill() {
		xpGraphPointManager.isSkillShownMap.put(currentlyGraphedSkills.get(0), false);
		currentlyGraphedSkills.remove(0);
	}

	@Subscribe
	public void onGameTick(GameTick tick)
	{

		currentTime = System.currentTimeMillis();
		graphWidth = config.graphWidth();
		graphHeight = config.graphHeight();
		xpDataManager.update();
		xpGraphPointManager.update();

		if (currentlyGraphedSkills.size() > config.maxSkillsToGraph()) {
			int excessAmount = currentlyGraphedSkills.size() - config.maxSkillsToGraph();
			for (int i = 0; i <  excessAmount; i++) {
				removeSkill();
			}
		}

		//System.out.println(tickCount);
		//System.out.println("fletching xp from data manager " + xpDataManager.getXpData(Skill.FLETCHING, tickCount));
		//System.out.println("y value from graph manager " + xpGraphPointManager.getGraphPointData(Skill.FLETCHING, tickCount));

		tickCount++;

		thisTickResetGraphSwitch = config.resetGraph();
		if (thisTickResetGraphSwitch && !lastTickResetGraphSwitch) {
			resetAll();
		}

		lastTickResetGraphSwitch = thisTickResetGraphSwitch;

	}

	private void resetAll() {
		xpDataManager = new XpDataManager(this);
		xpGraphPointManager = new XpGraphPointManager(this);
		startTime = System.currentTimeMillis();
		currentlyGraphedSkills = new ArrayList<Skill>();
		tickCount = 0;
	}

	public Client getClient() {
		return client;
	}

	public boolean isSkillShown(Skill skill) {

		return xpGraphPointManager.isSkillShown(skill);
	}

}

package com.xpgrapher;

import net.runelite.api.Skill;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.Map;

public class XpDataManager {

    private Map<Skill, ArrayList> skillXpMap = new HashMap<Skill, ArrayList>();

    private XpGrapherPlugin grapherPlugin;

    public XpDataManager(XpGrapherPlugin grapherPlugin) {

        this.grapherPlugin = grapherPlugin;

        for (int i = 0; i < grapherPlugin.skillList.length; i++) {
            ArrayList<Integer> newXpList = new ArrayList<Integer>();
            skillXpMap.put(grapherPlugin.skillList[i], newXpList);
        }

    }

    public void update() {
        for (int i = 0; i < grapherPlugin.skillList.length; i++) {
            Skill skillToUpdate = grapherPlugin.skillList[i];
            ArrayList<Integer> xpListToUpdate = skillXpMap.get(skillToUpdate);
            int xpValueToAdd = grapherPlugin.getClient().getSkillExperience(skillToUpdate);

            if (xpListToUpdate.size() > 0) {

                int lastXpValue = xpListToUpdate.get(xpListToUpdate.size() - 1);
                if (lastXpValue < xpValueToAdd)
                    if (skillToUpdate.getName() != "Overall") {
                        grapherPlugin.xpGraphPointManager.isSkillShownMap.put(skillToUpdate, true);
                        //grapherPlugin.currentlyGraphedSkills.add(skillToUpdate);
                        grapherPlugin.graphSkill(skillToUpdate);
                    }

            }

            xpListToUpdate.add(xpValueToAdd);
            //if (xpValueToAdd > lastXpValue)
            //    grapherPlugin.xpGraphPointManager.isSkillShownMap.put(skillToUpdate, true);
        }
    }

    public int getXpData(Skill skillToGet, int tickNum) {
        ArrayList<Integer> xpListToGet = skillXpMap.get(skillToGet);
        int xpValueAtTickNum = xpListToGet.get(tickNum);
        return xpValueAtTickNum;
    }

    public int getMostRecentXp(Skill skillToGet) {
        ArrayList<Integer> xpListToGet = skillXpMap.get(skillToGet);
        return xpListToGet.get(xpListToGet.size()-1);
    }

}

package com.xpgrapher;

import net.runelite.api.Skill;
import net.runelite.client.config.*;

import java.awt.*;

@ConfigGroup("xpgrapher")
public interface XpGrapherConfig extends Config
{

	@ConfigSection(
			name = "Skill Colors",
			description = "Set a color for each skill",
			position = 99
	)
	String skillColorSection = "skillColorSection";

	@ConfigItem(
			position = 0,
			keyName = "graphWidth",
			name = "Graph Width",
			description = "Configures the width of the graph."
	)
	default int graphWidth()
	{
		return 200;
	}

	@ConfigItem(
			position = 1,
			keyName = "graphHeight",
			name = "Graph Height",
			description = "Configures the height of the graph."
	)
	default int graphHeight()
	{
		return 100;
	}

	@ConfigItem(
			position = 2,
			keyName = "resetGraph",
			name = "Reset Graph",
			description = "Start over with all data. You will lose all saved graphs."
	)
	default boolean resetGraph() { return false; }

	@ConfigItem(
			position = 3,
			keyName = "displayKey",
			name = "Display Key",
			description = "Use this to turn off the color reference key."
	)
	default boolean displayKey() { return true; }

	@ConfigItem(
			position = 4,
			keyName = "displayXpRate",
			name = "Display XP/hr",
			description = ""
	)
	default boolean displayXpRate() { return true; }

	@ConfigItem(
			position = 5,
			keyName = "maxSkillsToGraph",
			name = "# of Skills to Graph",
			description = ""
	)
	default int maxSkillsToGraph() {
		return 8;
	}

	@ConfigItem(
			position = 6,
			keyName = "graphColor",
			name = "Graph Line/Text Color",
			description = "The color of the graph lines, text and border"
	)
	default Color graphColor() {
		return new Color(56, 36, 24);
	}

	@ConfigItem(
			position = 7,
			keyName = "graphBackgroundColor",
			name = "Background Color",
			description = "The background color of the graph."
	)
	default Color graphBackgroundColor() {
		return new Color(132, 109,  71, 200);
	}

	@Range(
			min = 1,
			max = 100
	)
	@ConfigItem(
			position = 8,
			keyName = "graphBackgroundTransparency",
			name = "Background Transparency",
			description = "The background transparency."
	)
	default int graphBackgroundTransparency() { return 70; }



	@ConfigItem(
			position = 101,
			keyName = "attackColor",
			name = "Attack Color",
			description = "Color of the Attack graph line",
			section = skillColorSection
	)
	default Color attackColor()
	{
		return new Color(79,143,35);
	}

	@ConfigItem(
			position = 9,
			keyName = "defenceColor",
			name = "Defence Color",
			description = "Color of the Defence graph line",
			section = skillColorSection
	)
	default Color defenceColor()
	{
		return new Color(115, 115, 115);
	}

	@ConfigItem(
			position = 9,
			keyName = "strengthColor",
			name = "Strength Color",
			description = "Color of the Strength graph line",
			section = skillColorSection
	)
	default Color strengthColor()
	{
		return new Color(115, 115, 115);
	}






	@ConfigItem(
			position = 9,
			keyName = "hitpointsColor",
			name = "Hitpoints Color",
			description = "Color of the Hitpoints graph line",
			section = skillColorSection
	)
	default Color hitpointsColor()
	{
		return new Color(143, 35, 35);
	}

	@ConfigItem(
			position = 10,
			keyName = "rangedColor",
			name = "Ranged Color",
			description = "Color of the Ranged graph line",
			section = skillColorSection
	)
	default Color rangedColor()
	{
		return new Color(106,255,0);
	}

	@ConfigItem(
			position = 11,
			keyName = "prayerColor",
			name = "Prayer Color",
			description = "Color of the Prayer graph line",
			section = skillColorSection
	)
	default Color prayerColor()
	{
		return new Color(255,212,0);
	}

	@ConfigItem(
			position = 12,
			keyName = "magicColor",
			name = "Magic Color",
			description = "Color of the Magic graph line",
			section = skillColorSection
	)
	default Color magicColor()
	{
		return new Color(0,149,255);
	}

	@ConfigItem(
			position = 13,
			keyName = "cookingColor",
			name = "Cooking Color",
			description = "Color of the Cooking graph line",
			section = skillColorSection
	)
	default Color cookingColor()
	{
		return new Color(107,35,143);
	}

	@ConfigItem(
			position = 14,
			keyName = "woodcuttingColor",
			name = "Woodcutting Color",
			description = "Color of the Woodcutting graph line",
			section = skillColorSection
	)
	default Color woodcuttingColor()
	{
		return new Color(35,98,143);
	}

	@ConfigItem(
			position = 15,
			keyName = "fletchingColor",
			name = "Fletching Color",
			description = "Color of the Fletching graph line",
			section = skillColorSection
	)
	default Color fletchingColor()
	{
		return new Color(255, 127, 0);
	}

	@ConfigItem(
			position = 16,
			keyName = "fishingColor",
			name = "Fishing Color",
			description = "Color of the Fishing graph line",
			section = skillColorSection
	)
	default Color fishingColor()
	{
		return new Color(231, 233, 185);
	}

	@ConfigItem(
			position = 17,
			keyName = "firemakingColor",
			name = "Firemaking Color",
			description = "Color of the Firemaking graph line",
			section = skillColorSection
	)
	default Color firemakingColor()
	{
		return new Color(255, 0, 0);
	}

	@ConfigItem(
			position = 18,
			keyName = "craftingColor",
			name = "Crafting Color",
			description = "Color of the Crafting graph line",
			section = skillColorSection
	)
	default Color craftingColor()
	{
		return new Color(255,0,170);
	}

	@ConfigItem(
			position = 19,
			keyName = "smithingColor",
			name = "Smithing Color",
			description = "Color of the Smithing graph line",
			section = skillColorSection
	)
	default Color smithingColor()
	{
		return new Color(185,237,224);
	}

	@ConfigItem(
			position = 20,
			keyName = "miningColor",
			name = "Mining Color",
			description = "Color of the Mining graph line",
			section = skillColorSection
	)
	default Color miningColor()
	{
		return new Color(204,204,204);
	}

	@ConfigItem(
			position = 21,
			keyName = "herbloreColor",
			name = "Herblore Color",
			description = "Color of the Herblore graph line",
			section = skillColorSection
	)
	default Color herbloreColor()
	{
		return new Color(191,255,0);
	}

	@ConfigItem(
			position = 22,
			keyName = "agilityColor",
			name = "Agility Color",
			description = "Color of the Agility graph line",
			section = skillColorSection
	)
	default Color agilityColor()
	{
		return new Color(185,215,237);
	}

	@ConfigItem(
			position = 23,
			keyName = "thievingColor",
			name = "Thieving Color",
			description = "Color of the Thieving graph line",
			section = skillColorSection
	)
	default Color thievingColor()
	{
		return new Color(255,255,0);
	}

	@ConfigItem(
			position = 24,
			keyName = "slayerColor",
			name = "Slayer Color",
			description = "Color of the Slayer graph line",
			section = skillColorSection
	)
	default Color slayerColor()
	{
		return new Color(220,185,237);
	}

	@ConfigItem(
			position = 25,
			keyName = "farmingColor",
			name = "Farming Color",
			description = "Color of the Farming graph line",
			section = skillColorSection
	)
	default Color farmingColor()
	{
		return new Color(0,234,255);
	}

	@ConfigItem(
			position = 26,
			keyName = "runecraftColor",
			name = "Runecraft Color",
			description = "Color of the Runecraft graph line",
			section = skillColorSection
	)
	default Color runecraftColor()
	{
		return new Color(170,0,255);
	}

	@ConfigItem(
			position = 27,
			keyName = "hunterColor",
			name = "Hunter Color",
			description = "Color of the Hunter graph line",
			section = skillColorSection
	)
	default Color hunterColor()
	{
		return new Color(237, 185, 185);
	}

	@ConfigItem(
			position = 28,
			keyName = "constructionColor",
			name = "Construction Color",
			description = "Color of the Construction graph line",
			section = skillColorSection
	)
	default Color constructionColor()
	{
		return new Color(220, 190, 255);
	}

}

package com.xpgrapher;

import com.google.inject.Inject;
import net.runelite.api.Client;
import net.runelite.api.Skill;
import net.runelite.client.ui.overlay.OverlayLayer;
import net.runelite.client.ui.overlay.OverlayPanel;
import net.runelite.client.ui.overlay.OverlayPosition;
import net.runelite.client.ui.overlay.components.LayoutableRenderableEntity;

import java.awt.*;
import java.text.DateFormat;
import java.text.DecimalFormat;
import java.text.SimpleDateFormat;
import java.util.Date;

public class XpGrapherOverlay extends OverlayPanel {

    private final Client client;
    private XpGrapherPlugin grapherPlugin;

    private int borderThickness = 2;
    private int divisionLineThickness = 1;

    private Color textColor = Color.WHITE;
    private Color graphLineColor;
    private Color backgroundColor;
    private int backgroundTransparency;

    private int marginGraphLeft = 43;
    private int marginGraphTop = 11;
    private int marginGraphRight = 24;
    private int marginGraphBottom = 30;
    private int marginTimeLabelTop = 7;

    private int marginOverlayRight = 5;

    //private int marginStartMessageTop = 12;
    private int marginStartMessageBottom = 8;

    private int marginLegendRight = 12;
    private int marginLegendTop = 8;
    private int marginLegendLeft = 10;
    private int marginLegendBoxBottom = 2;
    private int marginLegendBoxRight = 4;
    private int marginLegendBoxLeft = 4;
    private int marginLegendBoxTop = 2;
    private int marginLegendBottom = 3;
    private int legendBoxSize = 10;

    private int legendWidth = 93;
    private int legendHeight = 20;

    private int marginVertAxisValueRight = 4;

    private int bottomAxisTickMarkLength = 6;

    @Inject
    private XpGrapherOverlay(Client client, XpGrapherPlugin grapherPlugin) {
        this.client = client;
        this.grapherPlugin = grapherPlugin;
        graphLineColor = grapherPlugin.config.graphColor();
        backgroundColor = grapherPlugin.config.graphBackgroundColor();
        backgroundTransparency = grapherPlugin.config.graphBackgroundTransparency();
        setLayer(OverlayLayer.ABOVE_WIDGETS);
        setPosition(OverlayPosition.BOTTOM_LEFT);

    }

    private int convertTransparency(int configTransparency) {
        return (int)(255*((double)configTransparency/(double)100));
    }

    private String formatTime(long timePassed) {
        int secondsPassed = (int)timePassed/1000;
        int hours = secondsPassed/(60*60);
        int secondsLeft = secondsPassed%(60*60);
        int minutes = secondsLeft/60;
        int seconds = secondsLeft%60;

        String result = "";
        if (hours > 0)
            result += hours + ":";
        if (minutes > 0 || hours > 0) {
            if (minutes < 10 && hours > 0)
                result += "0";
            result += minutes + ":";
        }
        if (seconds < 10 && (minutes > 0|| hours > 0))
            result += "0";
        result += seconds;
        return result;
    }

    private String formatXpString(int xpToFormat) {

        String result;

        if (xpToFormat < 1000)
            result = Integer.toString(xpToFormat);
        else if (xpToFormat < 1000000) {

            int xpInK = xpToFormat/1000;
            int decimalPart = xpToFormat%1000;
            //System.out.println(xpToFormat + ", " + xpInK + ", " + decimalPart);
            result = Integer.toString(xpInK);
            if (decimalPart > 0) {
                result = result + "." + decimalPart;
                while (result.charAt(result.length()-1) == '0')
                    result = result.substring(0, result.length()-1);
            }


            result = result + "K";

        }
        else {
            int xpInM = xpToFormat/1000000;
            int decimalPart = xpToFormat%1000000;
            //System.out.println(xpToFormat + ", " + xpInK + ", " + decimalPart);
            result = Integer.toString(xpInM);
            if (decimalPart > 0) {
                result = result + "." + decimalPart;
                while (result.charAt(result.length()-1) == '0')
                    result = result.substring(0, result.length()-1);
            }


            result = result + "M";
        }

        return result;
    }

    public void printFormattedXp() {
        for (int i = 0; i < grapherPlugin.xpGraphPointManager.xpGraphMaxValues.length; i++) {
            System.out.println(formatXpString(grapherPlugin.xpGraphPointManager.xpGraphMaxValues[i]));
        }
    }



    LayoutableRenderableEntity graphEntity = new LayoutableRenderableEntity() {

        @Override
        public Dimension render(Graphics2D graphics) {

            graphLineColor = grapherPlugin.config.graphColor();
            backgroundColor = grapherPlugin.config.graphBackgroundColor();
            backgroundTransparency = convertTransparency(grapherPlugin.config.graphBackgroundTransparency());

            if (!grapherPlugin.config.displayKey()) {
                int currentWidth = this.getBounds().width;
                int currentHeight = this.getBounds().height;
                //this.setBounds(new Rectangle(currentWidth - legendWidth, currentHeight));
                //this.setPreferredSize(new Dimension(currentWidth - legendWidth, currentHeight));
                //setBounds(new Rectangle(50, 50));

            }

            //overlay background box
            int r = backgroundColor.getRed();
            int g = backgroundColor.getGreen();
            int b = backgroundColor.getBlue();
            Color backgroundColorTrans = new Color(r, g, b, backgroundTransparency);

            graphics.setColor(backgroundColorTrans);
            //graphics.fillRect(0, 0, this.getBounds().width, this.getBounds().height);
            graphics.fillRect(0, 0, marginGraphLeft+grapherPlugin.graphWidth+marginGraphRight+marginOverlayRight, this.getBounds().height);


            //overlay border box
            graphics.setColor(graphLineColor);
            int borderX = 0;
            int borderY = 0;
            graphics.drawRect(borderX, borderY, marginGraphLeft+grapherPlugin.graphWidth+marginGraphRight+marginOverlayRight, this.getBounds().height);
            graphics.drawRect(borderX+1, borderY+1, marginGraphLeft+grapherPlugin.graphWidth+marginGraphRight+marginOverlayRight-2, this.getBounds().height-2);

            //graph border box
            borderX = marginGraphLeft;
            borderY = marginGraphTop;
            graphics.drawRect(borderX, borderY, grapherPlugin.graphWidth, grapherPlugin.graphHeight);
            graphics.drawRect(borderX-1, borderY-1, grapherPlugin.graphWidth+2, grapherPlugin.graphHeight+2);

            //vertical divisions
            double verticalIncrement = (double)grapherPlugin.graphHeight/(double)grapherPlugin.numVerticalDivisions;
            for (int i = 0; i <= 5; i++) {

                int x = marginGraphLeft;
                int y = (int)(marginGraphTop+verticalIncrement*i);
                graphics.drawLine(x, y, x+grapherPlugin.graphWidth, y);

            }

            //vertical axis values
            int vertAxisMaxValue = grapherPlugin.xpGraphPointManager.maxVertAxisValue;
            int vertAxisXpInc = vertAxisMaxValue/grapherPlugin.numVerticalDivisions;

            for (int i = 0; i <= 5; i++) {
                int xpAtVerticalDiv = vertAxisMaxValue - i*vertAxisXpInc;

                String xpAtVerticalDivString = formatXpString(xpAtVerticalDiv);

                int stringWidth = graphics.getFontMetrics().stringWidth(xpAtVerticalDivString);
                int stringHeight = graphics.getFontMetrics().getHeight();

                if (xpAtVerticalDiv != 0 || i == 5)
                    graphics.drawString(xpAtVerticalDivString, marginGraphLeft-stringWidth-marginVertAxisValueRight, (int)(marginGraphTop+verticalIncrement*i+stringHeight/2-1));


            }

            //actual xp data lines
            for (int i = 0; i < grapherPlugin.skillList.length; i++) {

                Skill skillToGraph = grapherPlugin.skillList[i];
                Color skillColor = grapherPlugin.xpGraphColorManager.getSkillColor(skillToGraph);
                graphics.setColor(skillColor);

                if (grapherPlugin.isSkillShown(skillToGraph)) {

                    int oldX = -1;
                    int oldY = -1;
                    for (int x = 0; x < grapherPlugin.graphWidth; x++) {

                        int y = grapherPlugin.xpGraphPointManager.getGraphPointData(skillToGraph, x);
                        if (y >= 0) {
                            graphics.drawLine(marginGraphLeft+x, marginGraphTop+y, marginGraphLeft+x, marginGraphTop+y);
                            graphics.drawLine(marginGraphLeft+x, marginGraphTop+y+1, marginGraphLeft+x, marginGraphTop+y+1);
                        }

                        if (oldX != -1 && y >= 0) {
                            graphics.drawLine(marginGraphLeft+oldX, marginGraphTop+oldY, marginGraphLeft+x-1, marginGraphTop+y);
                            graphics.drawLine(marginGraphLeft+oldX-1, marginGraphTop+oldY, marginGraphLeft+x-2, marginGraphTop+y);
                        }
                        oldX = x;
                        oldY = y;
                    }

                }

            }

            int legendSkillCount =  grapherPlugin.currentlyGraphedSkills.size();

            if (grapherPlugin.config.displayKey() && legendSkillCount > 0) {

                //legendHeight = legendSkillCount*(legendBoxSize + marginLegendBoxTop + marginLegendBoxBottom) + marginLegendBottom;
                legendHeight = 12*legendSkillCount + 6;
                int legendX = marginGraphLeft+grapherPlugin.graphWidth+marginGraphRight+marginLegendLeft;
                int legendY = marginGraphTop;

                //legend background box
                graphics.setColor(backgroundColorTrans);
                graphics.fillRect(legendX, legendY, legendWidth, legendHeight);

                //legend border box
                graphics.setColor(graphLineColor);
                graphics.drawRect(legendX, legendY, legendWidth, legendHeight);
                graphics.drawRect(legendX-1, legendY-1, legendWidth+2, legendHeight+2);


                //legend boxes and labels
                int legendYOffset = marginGraphTop+2*marginLegendBoxTop-1;
                for (int i = 0; i < grapherPlugin.skillList.length; i++) {
                    Skill theSkill = grapherPlugin.skillList[i];
                    if (grapherPlugin.isSkillShown(theSkill)) {
                        //graphics.setColor(dataLineColors[i]);
                        Color skillColor = grapherPlugin.xpGraphColorManager.getSkillColor(theSkill);
                        graphics.setColor(skillColor);
                        int legendBoxX = legendX + marginLegendBoxLeft;
                        graphics.fillRect(legendBoxX, legendYOffset, legendBoxSize, legendBoxSize);
                        graphics.setColor(Color.BLACK);
                        graphics.drawRect(legendBoxX, legendYOffset, legendBoxSize, legendBoxSize);
                        legendYOffset += legendBoxSize + marginLegendBoxBottom;

                        graphics.setColor(graphLineColor);
                        String skillName = theSkill.getName();
                        int skillNameHeight = graphics.getFontMetrics().getHeight();
                        int skillNameX = legendBoxX + legendBoxSize + marginLegendBoxRight;
                        int skillNameY = legendYOffset;
                        graphics.drawString(skillName, skillNameX, skillNameY);
                    }
                }
            }



            //bottom axis tick marks
            graphics.setColor(graphLineColor);
            int bottomLeftGraphX = marginGraphLeft;
            int bottomLeftGraphY = marginGraphTop+grapherPlugin.graphHeight;
            graphics.drawLine(bottomLeftGraphX, bottomLeftGraphY, bottomLeftGraphX, bottomLeftGraphY + bottomAxisTickMarkLength);
            graphics.drawLine(bottomLeftGraphX-1, bottomLeftGraphY, bottomLeftGraphX-1, bottomLeftGraphY + bottomAxisTickMarkLength);
            int bottomRightGraphX = bottomLeftGraphX + grapherPlugin.graphWidth;
            graphics.drawLine(bottomRightGraphX, bottomLeftGraphY, bottomRightGraphX, bottomLeftGraphY + bottomAxisTickMarkLength);
            graphics.drawLine(bottomRightGraphX+1, bottomLeftGraphY, bottomRightGraphX+1, bottomLeftGraphY + bottomAxisTickMarkLength);

            long timePassed = grapherPlugin.currentTime - grapherPlugin.startTime;
            String timeStartLabel = "0";
            int timeStartLabelWidth = graphics.getFontMetrics().stringWidth(timeStartLabel);
            int timeStartLabelHeight = graphics.getFontMetrics().getHeight();
            graphics.drawString(timeStartLabel, bottomLeftGraphX-timeStartLabelWidth/2, bottomLeftGraphY+timeStartLabelHeight+marginTimeLabelTop);

            //int secondsPassed = (int)timePassed/1000;
            //int timePassedHours = secondsPassed/(60*60);
            //int secondsLeft = secondsPassed%(60*60);
            //int timePassedMinutes = secondsLeft/60;
            //int timePassedSeconds = secondsLeft%60;



            //String timeEndLabel = timePassedHoursString + ":" + timePassedMinutesString + ":" + timePassedSecondsString;

            //String timeEndLabel = formatTime(timePassedHours, timePassedMinutes, timePassedSeconds);
            String timeEndLabel = formatTime(timePassed);
            /*
            if (timePassedHours > 0)
                timeEndLabel += timePassedHours + ":";
            if (timePassedMinutes > 0 || timePassedHours > 0) {
                if (timePassedMinutes < 10 && timePassedHours > 0)
                    timeEndLabel += "0";
                timeEndLabel += timePassedMinutes + ":";
            }
            if (timePassedSeconds < 10 && (timePassedMinutes > 0|| timePassedHours > 0))
                timeEndLabel += "0";
            timeEndLabel += timePassedSeconds;
            */

            /*
            int secondsPassed = (int)(timePassed/1000);
            int timePassedMinutes = secondsPassed/60;
            int secondsLeft = secondsPassed%60;
            String secondsLeftString = Integer.toString(secondsLeft);
            if (secondsLeft < 10) {
                secondsLeftString = "0" + secondsLeftString;
            }
            String timeEndLabel = timePassedMinutes + ":" + secondsLeftString;
            */

            int timeEndLabelWidth = graphics.getFontMetrics().stringWidth(timeEndLabel);
            int timeEndLabelHeight = graphics.getFontMetrics().getHeight();
            graphics.drawString(timeEndLabel, bottomRightGraphX-timeEndLabelWidth/2, bottomLeftGraphY+timeEndLabelHeight+marginTimeLabelTop);


            //xp rate data
            if (grapherPlugin.config.displayXpRate() && grapherPlugin.currentlyGraphedSkills.size() > 0) {
                int endingSkillXp;
                if (grapherPlugin.tickCount > 0)
                    endingSkillXp = grapherPlugin.xpDataManager.getXpData(grapherPlugin.mostRecentSkillGained, grapherPlugin.tickCount-1);
                else
                    endingSkillXp = grapherPlugin.xpDataManager.getXpData(grapherPlugin.mostRecentSkillGained, 0);
                int startingSkillXp = grapherPlugin.xpDataManager.getXpData(grapherPlugin.mostRecentSkillGained, 0);
                int xpGained = endingSkillXp - startingSkillXp;
                long msPassed = System.currentTimeMillis() - grapherPlugin.startTime;
                long secPassed = msPassed/1000;
                double xpPerSecond = (double)xpGained/secPassed;
                double xpPerHour = xpPerSecond*60*60;
                String skillName = grapherPlugin.mostRecentSkillGained.getName();
                DecimalFormat formatter = new DecimalFormat("###,###,###");
                String skillInfoXpRate = formatter.format((int)xpPerHour);
                String skillInfo = skillName + " XP/hr: " + skillInfoXpRate;
                int skillInfoWidth = graphics.getFontMetrics().stringWidth(skillInfo);
                int skillInfoHeight = graphics.getFontMetrics().getHeight();
                //int skillInfoY = grapherPlugin.graphHeight+marginGraphTop+marginGraphBottom+bottomAxisTickMarkLength-skillInfoHeight/2;
                int skillInfoY = bottomLeftGraphY+timeEndLabelHeight+marginTimeLabelTop;
                int skillInfoX = marginGraphLeft+grapherPlugin.graphWidth/2-skillInfoWidth/2;
                graphics.drawString(skillInfo, skillInfoX, skillInfoY);
            }

            //show message to start skilling to start the graph
            //if (legendYOffset == marginGraphTop+2*marginLegendBoxTop-1) {
            if (grapherPlugin.currentlyGraphedSkills.size() == 0) {

                grapherPlugin.startMessageDisplaying = true;

                //0, 0, marginGraphLeft+grapherPlugin.graphWidth+marginGraphRight+marginOverlayRight, this.getBounds().height
                //int overlayWidth = grapherPlugin.graphWidth+marginGraphRight+marginGraphLeft+legendWidth+marginLegendRight;
                //int overlayHeight = marginGraphTop+grapherPlugin.graphHeight+marginGraphBottom;
                int overlayWidth = marginGraphLeft+grapherPlugin.graphWidth+marginGraphRight+marginOverlayRight;
                int overlayHeight = this.getBounds().height;

                int messageHeight = graphics.getFontMetrics().getHeight();

                String message1 = "Gain xp to start";
                int message1Width = graphics.getFontMetrics().stringWidth(message1);
                //int message1x = marginGraphLeft+grapherPlugin.graphWidth/2-message1Width/2;
                int message1x = overlayWidth/2-message1Width/2;

                int totalMessageHeight = 3*messageHeight+3*marginStartMessageBottom;
                int startingYOffset = this.getBounds().height/2 - totalMessageHeight/2;
                int message1y = marginGraphTop+startingYOffset;

                String message2 = "Alt+drag to move";
                int message2Width = graphics.getFontMetrics().stringWidth(message2);
                //int message2x = marginGraphLeft+grapherPlugin.graphWidth/2-message2Width/2;
                int message2x = overlayWidth/2-message2Width/2;
                int message2y = message1y+messageHeight+marginStartMessageBottom;

                String message3 = "Change graph size in settings";
                int message3Width = graphics.getFontMetrics().stringWidth(message3);
                //int message3x = marginGraphLeft+grapherPlugin.graphWidth/2-message3Width/2;
                int message3x = overlayWidth/2-message3Width/2;
                int message3y = message2y+messageHeight+marginStartMessageBottom;

                graphics.setColor(new Color(backgroundColor.getRed(), backgroundColor.getGreen(), backgroundColor.getBlue(), 200));
                //graphics.fillRect(marginGraphLeft+1, marginGraphRight, grapherPlugin.graphWidth+marginGraphRight+legendWidth-1, grapherPlugin.graphHeight-1);
                graphics.fillRect(1, 1,
                        overlayWidth-1,
                        overlayHeight-1
                );


                graphics.setColor(graphLineColor);
                graphics.drawString(message1, message1x, message1y);
                graphics.drawString(message2, message2x, message2y);
                graphics.drawString(message3, message3x, message3y);

            } else {
                grapherPlugin.startMessageDisplaying = false;
            }



            return new Dimension(this.getBounds().width, this.getBounds().height);

        }

        @Override
        public Rectangle getBounds() {
            int boundsWidth = marginGraphLeft+grapherPlugin.graphWidth+marginGraphRight+legendWidth+marginLegendRight;
            int boundsHeight = marginGraphTop+grapherPlugin.graphHeight+marginGraphBottom;
            return new Rectangle(boundsWidth, boundsHeight);
        }

        @Override
        public void setPreferredLocation(Point position) {
            return;
        }

        @Override
        public void setPreferredSize(Dimension dimension) {
            return;
        }

    };

    @Override
    public Dimension render(Graphics2D graphics)
    {

        panelComponent.getChildren().add(graphEntity);
        panelComponent.setBackgroundColor(new Color(0, 0, 0, 0));

        return super.render(graphics);
    }

}


package com.xpgrapher;

import net.runelite.api.Skill;

import java.awt.*;
import java.util.HashMap;

public class XpGraphColorManager {

    private HashMap<Skill, Color> skillColorMap = new HashMap<Skill, Color>();
    private XpGrapherPlugin grapherPlugin;

    private Color[] skillColorData = {

            //attack
            new Color(79,143,35),
            //Defence
            new Color(115, 115, 115),
            //strength
            new Color(0,64,255),
            //hitpoints
            new Color(143, 35, 35),
            //ranged
            new Color(106,255,0),
            //prayer
            new Color(255,212,0),
            //magic
            new Color(0,149,255),
            //cooking
            new Color(107,35,143),
            //woodcutting
            new Color(35,98,143),
            //fletching
            new Color(255, 127, 0),
            //fishing
            new Color(231, 233, 185),
            //firemaking
            new Color(255, 0, 0),
            //crafting
            new Color(255,0,170),
            //smithing
            new Color(185,237,224),
            //mining
            new Color(204,204,204),
            //herblore
            new Color(191,255,0),
            //agility
            new Color(185,215,237),
            //thieving
            new Color(255,255,0),
            //slayer
            new Color(220,185,237),
            //farming
            new Color(0,234,255),
            //runecraft
            new Color(170,0,255),
            //hunter
            new Color(237, 185, 185),
            //construction
            new Color(220, 190, 255),
            //overall
            //new Color(143, 106, 35),
    };

    public XpGraphColorManager(XpGrapherPlugin grapherPlugin) {
        this.grapherPlugin = grapherPlugin;
        for (int i = 0; i < skillColorData.length; i++) {
            skillColorMap.put(grapherPlugin.skillList[i], skillColorData[i]);
        }
    }

    public Color getSkillColor(Skill skill) {
        //return skillColorMap.get(skill);
        if (skill.getName() == "Attack")
            return grapherPlugin.config.attackColor();
        else if (skill.getName() == "Strength")
            return grapherPlugin.config.strengthColor();
        else if (skill.getName() == "Defence")
            return grapherPlugin.config.defenceColor();
        else if (skill.getName() == "Ranged")
            return grapherPlugin.config.rangedColor();
        else if (skill.getName() == "Prayer")
            return grapherPlugin.config.prayerColor();

        else if (skill.getName() == "Magic")
            return grapherPlugin.config.magicColor();
        else if (skill.getName() == "Runecraft")
            return grapherPlugin.config.runecraftColor();
        else if (skill.getName() == "Construction")
            return grapherPlugin.config.constructionColor();
        else if (skill.getName() == "Hitpoints")
            return grapherPlugin.config.hitpointsColor();
        else if (skill.getName() == "Agility")
            return grapherPlugin.config.agilityColor();

        else if (skill.getName() == "Herblore")
            return grapherPlugin.config.herbloreColor();
        else if (skill.getName() == "Thieving")
            return grapherPlugin.config.thievingColor();
        else if (skill.getName() == "Crafting")
            return grapherPlugin.config.craftingColor();
        else if (skill.getName() == "Fletching")
            return grapherPlugin.config.fletchingColor();
        else if (skill.getName() == "Slayer")
            return grapherPlugin.config.slayerColor();
        else if (skill.getName() == "Hunter")
            return grapherPlugin.config.hunterColor();
        else if (skill.getName() == "Mining")
            return grapherPlugin.config.miningColor();
        else if (skill.getName() == "Smithing")
            return grapherPlugin.config.smithingColor();
        else if (skill.getName() == "Fishing")
            return grapherPlugin.config.fishingColor();
        else if (skill.getName() == "Cooking")
            return grapherPlugin.config.cookingColor();

        else if (skill.getName() == "Firemaking")
            return grapherPlugin.config.firemakingColor();
        else if (skill.getName() == "Woodcutting")
            return grapherPlugin.config.woodcuttingColor();
        else if (skill.getName() == "Farming")
            return grapherPlugin.config.farmingColor();
        return Color.BLACK;
    }

    public void setSkillColor(Skill skill, Color color) {
        skillColorMap.put(skill, color);
    }

}

