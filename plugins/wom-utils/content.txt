package net.wiseoldman.util;

import net.wiseoldman.WomUtilsPlugin;
import net.wiseoldman.beans.PlayerType;
import javax.swing.Icon;
import javax.swing.ImageIcon;
import net.runelite.client.util.ImageUtil;
import net.runelite.client.hiscore.HiscoreSkill;

public class Utils
{
	private static final Icon IRONMAN_ICON = new ImageIcon(ImageUtil.loadImageResource(WomUtilsPlugin.class, "ironman.png"));
	private static final Icon ULTIMATE_ICON = new ImageIcon(ImageUtil.loadImageResource(WomUtilsPlugin.class, "ultimate_ironman.png"));
	private static final Icon HARDCORE_ICON = new ImageIcon(ImageUtil.loadImageResource(WomUtilsPlugin.class, "hardcore_ironman.png"));
	private static final Icon FRESH_START_ICON = new ImageIcon(ImageUtil.loadImageResource(WomUtilsPlugin.class, "fresh_start.png"));
	private static final Icon REGULAR_ICON = new ImageIcon(ImageUtil.loadImageResource(WomUtilsPlugin.class, "regular.png"));

    public static int getMinimumKc(HiscoreSkill boss)
    {
        switch (boss)
        {
            case MIMIC:
            case TZKAL_ZUK:
                return 1;
            default:
                return 5;
        }
    }

    public static Icon getIcon(PlayerType type)
	{
		switch (type)
		{
			case IRONMAN:
				return IRONMAN_ICON;
			case HARDCORE:
				return HARDCORE_ICON;
			case ULTIMATE:
				return ULTIMATE_ICON;
			case FRESH_START:
				return FRESH_START_ICON;
			default:
				return REGULAR_ICON;
		}
	}

	public static String ordinalOf(int i) {
		String[] suffixes = new String[] { "th", "st", "nd", "rd", "th", "th", "th", "th", "th", "th" };
		switch (i % 100) {
			case 11:
			case 12:
			case 13:
				return i + "th";
			default:
				return i + suffixes[i % 10];
		}
	}
}

package net.wiseoldman.util;

import java.time.Duration;
import lombok.Value;

@Value
public class DelayedAction
{
	Duration delay;
	Runnable runnable;
}

/*
 * Copyright (c) 2021, Rorro <https://github.com/rorro>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package net.wiseoldman.util;

import net.runelite.client.util.QuantityFormatter;

import java.math.RoundingMode;
import java.text.DecimalFormat;
import java.time.*;
import java.time.format.DateTimeFormatter;

public class Format
{
    public static String formatNumber(long num)
    {
        if ((num < 10000 && num > -10000))
        {
            return QuantityFormatter.formatNumber(num);
        }

        DecimalFormat df = new DecimalFormat();
        df.setGroupingUsed(false);
        df.setRoundingMode(RoundingMode.FLOOR);
        df.setMaximumFractionDigits(2);

        // < 10 million
        if (num < 10_000_000 && num > -10_000_000)
        {
            df.setMaximumFractionDigits(0);
            return df.format(num / 1000.0) + "k";
        }

        // < 1 billion
        if (num < 1_000_000_000 && num > -1_000_000_000)
        {
            return df.format( num / 1_000_000.0) + "m";
        }

        return df.format(num / 1_000_000_000.0) + "b";
    }

    public static String formatNumber(double num)
    {
        if ((num < 10000 && num > -10000))
        {
            return String.format("%.0f", num);
        }

        DecimalFormat df = new DecimalFormat();
        df.setRoundingMode(RoundingMode.FLOOR);
        df.setMaximumFractionDigits(2);

        return df.format(num / 1000.0) + "k";
    }

    public static String formatDate(String date, boolean relative)
    {
        DateTimeFormatter formatter = DateTimeFormatter.ofPattern("dd MMM yyyy, HH:mm");
        ZoneId localZone = ZoneId.systemDefault();
        ZonedDateTime updatedAt = Instant.parse(date).atZone(localZone);

        if (relative)
        {
            String lastUpdated = "";
            ZonedDateTime now = Instant.now().atZone(localZone);
            long difference = Duration.between(updatedAt, now).toHours();

            if (difference == 0)
            {
                return "less than 1 hour ago";
            }

            long days = difference / 24;
            long hours = difference % 24;

            String dayUnit = days > 1 ? " days, " : " day, ";
            String hourUnit = hours > 1 ? " hours ago" : " hour ago";

            lastUpdated += days > 0 ? days + dayUnit : "";
            lastUpdated += hours > 0 ? hours + hourUnit : "";

            return lastUpdated;
        }
        else
        {
            return formatter.format(updatedAt);
        }
    }
}

package net.wiseoldman.web;

import lombok.Getter;

@Getter
public enum WomRequestType
{
	COMPETITIONS_ONGOING("ongoing"),
	COMPETITIONS_UPCOMING("upcoming");

	final String name;

	WomRequestType(String name)
	{
		this.name = name;
	}
}

package net.wiseoldman.web;

import com.google.gson.Gson;

import java.util.Arrays;
import java.util.Set;

import net.runelite.client.RuneLiteProperties;
import net.wiseoldman.WomUtilsPlugin;
import net.wiseoldman.beans.GroupInfoWithMemberships;
import net.wiseoldman.beans.NameChangeEntry;
import net.wiseoldman.beans.ParticipantWithStanding;
import net.wiseoldman.beans.RoleIndex;
import net.wiseoldman.beans.WomStatus;
import net.wiseoldman.beans.ParticipantWithCompetition;
import net.wiseoldman.beans.GroupMemberAddition;
import net.wiseoldman.beans.Member;
import net.wiseoldman.beans.PlayerInfo;
import net.wiseoldman.beans.WomPlayerUpdate;
import net.wiseoldman.events.WomOngoingPlayerCompetitionsFetched;
import net.wiseoldman.events.WomRequestFailed;
import net.wiseoldman.events.WomUpcomingPlayerCompetitionsFetched;
import net.wiseoldman.WomUtilsConfig;
import net.wiseoldman.events.WomGroupSynced;
import java.awt.Color;
import java.io.IOException;
import java.text.DateFormat;
import java.text.DecimalFormat;
import java.util.ArrayList;
import java.util.concurrent.CompletableFuture;
import java.util.function.Consumer;
import javax.inject.Inject;

import lombok.extern.slf4j.Slf4j;
import net.runelite.api.ChatMessageType;
import net.runelite.api.Client;
import net.runelite.api.MessageNode;
import net.runelite.api.events.ChatMessage;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.chat.ChatColorType;
import net.runelite.client.chat.ChatMessageBuilder;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.chat.QueuedMessage;
import net.runelite.client.eventbus.EventBus;
import okhttp3.Callback;
import okhttp3.HttpUrl;
import okhttp3.MediaType;
import okhttp3.OkHttpClient;
import okhttp3.Request;
import okhttp3.RequestBody;
import okhttp3.Response;

@Slf4j
public class WomClient
{
	@Inject
	private OkHttpClient okHttpClient;

	private Gson gson;

	@Inject
	private Client client;

	@Inject
	private WomUtilsConfig config;

	@Inject
	private ChatMessageManager chatMessageManager;

	@Inject
	private ClientThread clientThread;

	@Inject
	private EventBus eventBus;

	private static final Color SUCCESS = new Color(170, 255, 40);
	public final Color ERROR = new Color(204, 66, 66);

	private static final DecimalFormat NUMBER_FORMAT = new DecimalFormat("#.##");

	private final WomUtilsPlugin plugin;
	private final String leagueError = " You are currently in a League world. Your group configurations might be for the main game.";

	private final String userAgent;

	private ArrayList<Member> clanMembers;
	private Set<RoleIndex> roleOrders;

	@Inject
	public WomClient(Gson gson, WomUtilsPlugin plugin, Client client)
	{
		this.gson = gson.newBuilder()
			.setDateFormat(DateFormat.FULL, DateFormat.FULL)
			.create();

		this.plugin = plugin;
		this.client = client;

		String pluginVersion = WomUtilsPlugin.getPluginVersion();
		String runeliteVersion = RuneLiteProperties.getVersion();

		userAgent = "WiseOldManRuneLitePlugin/" + pluginVersion + " " +
			"RuneLite/" + runeliteVersion;
	}

	public void submitNameChanges(NameChangeEntry[] changes)
	{
		Request request = createRequest(changes, HttpMethod.POST, "names", "bulk");
		sendRequest(request);
		log.info("Submitted {} name changes to WOM", changes.length);
	}

	void sendRequest(Request request)
	{
		sendRequest(request, r -> {
		});
	}

	void sendRequest(Request request, Consumer<Response> consumer)
	{
		sendRequest(request, new WomCallback(consumer));
	}

	void sendRequest(Request request, Consumer<Response> consumer, Consumer<Exception> exceptionConsumer)
	{
		sendRequest(request, new WomCallback(consumer, exceptionConsumer));
	}

	void sendRequest(Request request, Callback callback)
	{
		okHttpClient.newCall(request).enqueue(callback);
	}

	private Request createRequest(Object payload, String... pathSegments)
	{
		return createRequest(payload, HttpMethod.POST, pathSegments);
	}

	private Request createRequest(Object payload, HttpMethod httpMethod, String... pathSegments)
	{
		HttpUrl url = buildUrl(pathSegments);
		RequestBody body = RequestBody.create(
			MediaType.parse("application/json; charset=utf-8"),
			gson.toJson(payload)
		);

		Request.Builder requestBuilder = new Request.Builder()
			.header("User-Agent", userAgent)
			.url(url);

		if (httpMethod == HttpMethod.PUT)
		{
			return requestBuilder.put(body).build();
		}
		else if (httpMethod == HttpMethod.DELETE)
		{
			return requestBuilder.delete(body).build();
		}


		return requestBuilder.post(body).build();
	}

	private Request createRequest(String... pathSegments)
	{
		HttpUrl url = buildUrl(pathSegments);
		return new Request.Builder()
			.header("User-Agent", userAgent)
			.url(url)
			.build();
	}

	private HttpUrl buildUrl(String[] pathSegments)
	{
		HttpUrl.Builder urlBuilder = new HttpUrl.Builder()
			.scheme("https")
			.host("api.wiseoldman.net")
			.addPathSegment(this.plugin.isSeasonal ? "league" : "v2");

		for (String pathSegment : pathSegments)
		{
			if (pathSegment.startsWith("?"))
			{
				// A query param
				String[] kv = pathSegment.substring(1).split("=");
				urlBuilder.addQueryParameter(kv[0], kv[1]);
			}
			else
			{
				urlBuilder.addPathSegment(pathSegment);
			}
		}


		return urlBuilder.build();
	}

	public void importGroupMembers()
	{
		if (config.groupId() > 0)
		{
			Request request = createRequest("groups", "" + config.groupId());
			sendRequest(request, this::importMembersCallback);
		}
	}

	private void importMembersCallback(Response response)
	{
		if (!response.isSuccessful())
		{
			return;
		}

		GroupInfoWithMemberships groupInfo = parseResponse(response, GroupInfoWithMemberships.class);
		postEvent(new WomGroupSynced(groupInfo, true));
	}

	private void syncClanMembersCallBack(Response response)
	{
		final String message;

		if (response.isSuccessful())
		{
			GroupInfoWithMemberships data = parseResponse(response, GroupInfoWithMemberships.class);
			postEvent(new WomGroupSynced(data));
		}
		else if (response.code() == 429)
		{
			log.error("wom-utils: reached api limits while syncing clan members");
		}
		else if (response.code() == 403)
		{
			WomStatus data = parseResponse(response, WomStatus.class);

			// This works for now because we only use this for opted out players.
			if (data.getData() == null)
			{
				return;
			}

			String[] optedOutPlayers = Arrays.stream(data.getData()).map(String::toLowerCase).toArray(String[]::new);
			boolean didRemove = this.clanMembers.removeIf(member -> Arrays.asList(optedOutPlayers).contains(member.getUsername().toLowerCase()));

			// If no players were removed, don't send request so we don't end up in an endless loop
			if (!didRemove)
			{
				return;
			}

			GroupMemberAddition payload = new GroupMemberAddition(config.verificationCode(), this.clanMembers, this.roleOrders);
			Request request = createRequest(payload, HttpMethod.PUT, "groups", "" + config.groupId());
			sendRequest(request, this::syncClanMembersCallBack);
		}
		else
		{
			WomStatus data = parseResponse(response, WomStatus.class);
			message = "Error: " + data.getMessage() + (this.plugin.isSeasonal ? leagueError : "");

			sendResponseToChat(message, ERROR);
		}
	}

	private void playerOngoingCompetitionsCallback(String username, Response response)
	{
		boolean showRetry = true;
		if (response.isSuccessful())
		{
			ParticipantWithStanding[] comps = parseResponse(response, ParticipantWithStanding[].class);
			postEvent(new WomOngoingPlayerCompetitionsFetched(username, comps));
			showRetry = false;
		}
		else if (response.code() == 429)
		{
			log.error("wom-utils: reached api limits while fetching ongoing competitions");
		}
		else
		{
			WomStatus data = parseResponse(response, WomStatus.class);
			String message = "Error: " + data.getMessage();
			sendResponseToChat(message, ERROR);
		}

		if (showRetry)
		{
			eventBus.post(new WomRequestFailed(username, WomRequestType.COMPETITIONS_ONGOING));
		}
	}

	private void playerUpcomingCompetitionsCallback(String username, Response response)
	{
		boolean showRetry = true;
		if (response.isSuccessful())
		{
			ParticipantWithCompetition[] comps = parseResponse(response, ParticipantWithCompetition[].class);
			postEvent(new WomUpcomingPlayerCompetitionsFetched(username, comps));
			showRetry = false;
		}
		else if (response.code() == 429)
		{
			log.error("wom-utils: reached api limits while fetching upcoming competitions");
		}
		else
		{
			WomStatus data = parseResponse(response, WomStatus.class);
			String message = "Error: " + data.getMessage();
			sendResponseToChat(message, ERROR);
		}

		if (showRetry)
		{
			eventBus.post(new WomRequestFailed(username, WomRequestType.COMPETITIONS_UPCOMING));
		}
	}


	private <T> T parseResponse(Response r, Class<T> clazz)
	{
		return parseResponse(r, clazz, false);
	}

	private <T> T parseResponse(Response r, Class<T> clazz, boolean nullIferror)
	{
		if (nullIferror && !r.isSuccessful())
		{
			return null;
		}

		String body;
		try
		{
			body = r.body().string();
		}
		catch (IOException e)
		{
			log.error("Could not read response {}", e.getMessage());
			return null;
		}

		return gson.fromJson(body, clazz);
	}

	private void sendResponseToChat(String message, Color color)
	{
		ChatMessageBuilder cmb = new ChatMessageBuilder();
		cmb.append("[WOM] ");
		cmb.append(color, message);

		chatMessageManager.queue(QueuedMessage.builder()
			.type(ChatMessageType.CONSOLE)
			.runeLiteFormattedMessage(cmb.build())
			.build());
	}

	public void syncClanMembers(ArrayList<Member> clanMembers, Set<RoleIndex> roleOrders)
	{
		this.clanMembers = clanMembers;
		this.roleOrders = roleOrders;

		GroupMemberAddition payload = new GroupMemberAddition(config.verificationCode(), clanMembers, roleOrders);
		Request request = createRequest(payload, HttpMethod.PUT, "groups", "" + config.groupId());
		sendRequest(request, this::syncClanMembersCallBack);
	}

	public void commandLookup(String username, WomCommand command, ChatMessage chatMessage)
	{
		Request request = createRequest("players", username);
		sendRequest(request, r -> commandCallback(r, command, chatMessage));
	}

	private void commandCallback(Response response, WomCommand command, ChatMessage chatMessage)
	{
		if (!response.isSuccessful())
		{
			return;
		}

		final PlayerInfo info = parseResponse(response, PlayerInfo.class);

		final double time;

		try
		{
			String cmd = command.getCommand();
			if (cmd.equals("!ehp"))
			{
				time = info.getEhp();
			}
			else if (cmd.equals("!ehb"))
			{
				time = info.getEhb();
			}
			else if (cmd.equals("!ttm"))
			{
				time = info.getTtm();
			}
			else
			{
				time = info.getTt200m();
			}
		}
		catch (Throwable e)
		{
			log.warn("{}", e.getMessage());
			return;
		}

		String value = NUMBER_FORMAT.format(time);

		String message = new ChatMessageBuilder()
			.append(ChatColorType.NORMAL)
			.append(command.getMessage())
			.append(ChatColorType.HIGHLIGHT)
			.append(value)
			.append(".")
			.build();

		final MessageNode messageNode = chatMessage.getMessageNode();
		messageNode.setRuneLiteFormatMessage(message);
		client.refreshChat();
	}

	private void postEvent(Object event)
	{
		// Handle callbacks on the client thread
		clientThread.invokeLater(() -> eventBus.post(event));
	}

	public void fetchUpcomingPlayerCompetitions(String username)
	{
		Request request = createRequest("players", username, "competitions", "?status=upcoming");
		sendRequest(request, r -> playerUpcomingCompetitionsCallback(username, r));
	}

	public void fetchOngoingPlayerCompetitions(String username)
	{
		Request request = createRequest("players", username, "competitions", "standings", "?status=ongoing");
		sendRequest(request, r -> playerOngoingCompetitionsCallback(username, r));
	}

	public void updatePlayer(String username, long accountHash)
	{
		Request request = createRequest(new WomPlayerUpdate(accountHash), "players", username);
		sendRequest(request);
	}

	public CompletableFuture<PlayerInfo> lookupAsync(String username)
	{
		CompletableFuture<PlayerInfo> future = new CompletableFuture<>();
		Request request = createRequest("players", username);
		sendRequest(request, r -> future.complete(parseResponse(r, PlayerInfo.class, true)), future::completeExceptionally);
		return future;
	}

	public CompletableFuture<PlayerInfo> updateAsync(String username)
	{
		CompletableFuture<PlayerInfo> future = new CompletableFuture<>();
		Request request = createRequest(new Object(), "players", username);
		sendRequest(request, r -> future.complete(parseResponse(r, PlayerInfo.class, true)), future::completeExceptionally);
		return future;
	}
}

package net.wiseoldman.web;

import lombok.AllArgsConstructor;
import lombok.Getter;

@Getter
@AllArgsConstructor
public enum WomCommand
{
	EHP("!ehp", "Efficient hours played: "),
	EHB("!ehb", "Efficient hours bossed: "),
	TTM("!ttm","Time to max: "),
	TT200M("!tt200m","Time to 200m: "),
	;

	private final String command;
	private final String message;


	public static WomCommand fromCommand(String command)
	{
		for (WomCommand c : values())
		{
			if (c.getCommand().equals(command.toLowerCase()))
			{
				return c;
			}
		}
		return null;
	}
}

package net.wiseoldman.web;

public enum HttpMethod
{
    POST,
    PUT,
    DELETE
}

package net.wiseoldman.web;

import java.io.IOException;
import java.util.function.Consumer;
import lombok.AllArgsConstructor;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import okhttp3.Call;
import okhttp3.Callback;
import okhttp3.Response;

@Slf4j
@RequiredArgsConstructor
@AllArgsConstructor
public class WomCallback implements Callback
{
	@Override
	public void onFailure(Call call, IOException e)
	{
		if (failureConsumer == null)
		{
			log.warn("Error submitting request, caused by {}.", e.getMessage());
		}
		else
		{
			failureConsumer.accept(e);
		}
	}

	@Override
	public void onResponse(Call call, Response response)
	{
		try
		{
			responseConsumer.accept(response);
		}
		catch (Throwable e)
		{
			log.warn("Error when handling response, caused by {}.", e.getMessage());
		}
		finally
		{
			response.close();
		}
	}

	private final Consumer<Response> responseConsumer;
	private Consumer<Exception> failureConsumer;
}

package net.wiseoldman;

import com.google.common.base.Charsets;
import com.google.common.base.Splitter;
import com.google.common.base.Strings;
import com.google.common.collect.ImmutableList;
import com.google.common.io.Files;
import com.google.common.util.concurrent.Runnables;
import com.google.gson.Gson;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParser;
import com.google.gson.JsonSyntaxException;
import com.google.inject.Binder;
import com.google.inject.Provides;
import java.util.HashSet;
import java.util.Set;
import java.util.stream.Collectors;
import net.runelite.api.IndexedObjectSet;
import net.runelite.api.WorldType;
import net.runelite.api.clan.ClanMember;
import net.runelite.api.clan.ClanTitle;
import net.runelite.api.gameval.InterfaceID;
import net.runelite.api.gameval.VarPlayerID;
import net.runelite.api.gameval.VarbitID;
import net.runelite.api.widgets.WidgetUtil;
import net.wiseoldman.beans.CanvasCompetition;
import net.wiseoldman.beans.Competition;
import net.wiseoldman.beans.NameChangeEntry;
import net.wiseoldman.beans.ParticipantWithStanding;
import net.wiseoldman.beans.GroupMembership;
import net.wiseoldman.beans.ParticipantWithCompetition;
import net.wiseoldman.events.WomGroupSynced;
import net.wiseoldman.events.WomOngoingPlayerCompetitionsFetched;
import net.wiseoldman.events.WomRequestFailed;
import net.wiseoldman.events.WomUpcomingPlayerCompetitionsFetched;
import net.wiseoldman.panel.CompetitionCardPanel;
import net.wiseoldman.panel.NameAutocompleter;
import net.wiseoldman.panel.WomPanel;
import net.wiseoldman.ui.CodeWordOverlay;
import net.wiseoldman.ui.CompetitionInfoBox;
import net.wiseoldman.ui.SyncButton;
import net.wiseoldman.util.DelayedAction;
import net.wiseoldman.web.WomRequestType;
import net.wiseoldman.web.WomClient;
import net.wiseoldman.web.WomCommand;
import java.awt.Color;
import java.awt.image.BufferedImage;
import java.io.File;
import java.io.IOException;
import java.time.temporal.ChronoUnit;
import java.io.InputStream;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.EnumMap;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Properties;
import java.util.concurrent.LinkedBlockingQueue;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.ScheduledFuture;
import java.util.concurrent.TimeUnit;
import java.util.function.Consumer;
import javax.inject.Inject;
import javax.swing.SwingUtilities;
import lombok.Getter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.ChatMessageType;
import net.runelite.api.Client;
import net.runelite.api.GameState;
import net.runelite.api.MenuAction;
import net.runelite.api.MenuEntry;
import net.runelite.api.Nameable;
import net.runelite.api.Player;
import net.runelite.api.Skill;
import net.runelite.api.clan.ClanRank;
import net.runelite.api.clan.ClanSettings;
import net.runelite.api.events.ChatMessage;
import net.runelite.api.events.GameStateChanged;
import net.runelite.api.events.GameTick;
import net.runelite.api.events.MenuEntryAdded;
import net.runelite.api.events.MenuOpened;
import net.runelite.api.events.MenuOptionClicked;
import net.runelite.api.events.NameableNameChanged;
import net.runelite.api.events.StatChanged;
import net.runelite.api.events.WidgetLoaded;
import net.runelite.api.widgets.Widget;
import net.runelite.client.Notifier;
import net.runelite.client.RuneLite;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.chat.ChatColorType;
import net.runelite.client.chat.ChatCommandManager;
import net.runelite.client.chat.ChatMessageBuilder;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.chat.QueuedMessage;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.events.ConfigChanged;
import net.runelite.client.game.chatbox.ChatboxPanelManager;
import net.runelite.client.menus.MenuManager;
import net.runelite.client.menus.WidgetMenuOption;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.plugins.PluginDependency;
import net.runelite.client.plugins.PluginDescriptor;
import net.runelite.client.plugins.PluginManager;
import net.runelite.client.plugins.xpupdater.XpUpdaterConfig;
import net.runelite.client.plugins.xpupdater.XpUpdaterPlugin;
import net.runelite.client.task.Schedule;
import net.runelite.client.ui.ClientToolbar;
import net.runelite.client.ui.NavigationButton;
import net.runelite.client.ui.overlay.OverlayManager;
import net.runelite.client.ui.overlay.infobox.InfoBoxManager;
import net.runelite.client.util.ColorUtil;
import net.runelite.client.util.ImageUtil;
import net.runelite.client.util.LinkBrowser;
import net.runelite.client.util.Text;
import okhttp3.HttpUrl;

@Slf4j
@PluginDependency(XpUpdaterPlugin.class)
@PluginDescriptor(
	name = "Wise Old Man",
	tags = {"wom", "utils", "group", "xp"},
	description = "Helps you manage your wiseoldman.net group and track your competitions."
)
public class WomUtilsPlugin extends Plugin
{
	static final String CONFIG_GROUP = "womutils";
	private static final File WORKING_DIR;
	private static final String NAME_CHANGES = "name-changes.json";

	private static final String IMPORT_MEMBERS = "Import";
	private static final String BROWSE_GROUP = "Browse";
	private static final String MENU_TARGET = "WOM group";
	private static final String LOOKUP = "WOM lookup";
	private static final String IGNORE_RANK = "Ignore rank";
	private static final String UNIGNORE_RANK = "Unignore rank";

	private static final String KICK_OPTION = "Kick";

	private static final ImmutableList<String> AFTER_OPTIONS = ImmutableList.of("Message", "Add ignore", "Remove friend", "Delete", KICK_OPTION);

	private final ImmutableList<WidgetMenuOption> WIDGET_IMPORT_MENU_OPTIONS =
		new ImmutableList.Builder<WidgetMenuOption>()
			.add(new WidgetMenuOption(IMPORT_MEMBERS,
				MENU_TARGET, InterfaceID.Toplevel.STONE7))
			.add(new WidgetMenuOption(IMPORT_MEMBERS,
				MENU_TARGET, InterfaceID.ToplevelOsrsStretch.STONE7))
			.add(new WidgetMenuOption(IMPORT_MEMBERS,
				MENU_TARGET, InterfaceID.ToplevelPreEoc.STONE7))
			.build();

	private final ImmutableList<WidgetMenuOption> WIDGET_BROWSE_MENU_OPTIONS =
		new ImmutableList.Builder<WidgetMenuOption>()
			.add(new WidgetMenuOption(BROWSE_GROUP,
				MENU_TARGET, InterfaceID.Toplevel.STONE7))
			.add(new WidgetMenuOption(BROWSE_GROUP,
				MENU_TARGET, InterfaceID.ToplevelOsrsStretch.STONE7))
			.add(new WidgetMenuOption(BROWSE_GROUP,
				MENU_TARGET, InterfaceID.ToplevelPreEoc.STONE7))
			.build();

	private static final int XP_THRESHOLD = 10_000;

	private static final Color DEFAULT_CLAN_SETTINGS_TEXT_COLOR = new Color(0xff981f);

	private static final Splitter SPLITTER = Splitter.on(',').trimResults().omitEmptyStrings();

	private boolean levelupThisSession = false;

	private static String MESSAGE_PREFIX = "WOM: ";

	public boolean isSeasonal = false;

	private String DEFAULT_ROLE = "member";

	public Double SAME_CLAN_TOLERANCE = 0.5;

	@Inject
	private Client client;

	@Inject
	private WomUtilsConfig config;

	@Inject
	private MenuManager menuManager;

	@Inject
	private ClientThread clientThread;

	@Inject
	private ChatMessageManager chatMessageManager;

	@Inject
	private ChatboxPanelManager chatboxPanelManager;

	@Inject
	private Gson gson;

	@Inject
	private JsonParser jsonParser;

	@Inject
	private ChatCommandManager chatCommandManager;

	@Inject
	private WomClient womClient;

	@Inject
	private XpUpdaterConfig xpUpdaterConfig;

	@Inject
	private PluginManager pluginManager;

	@Inject
	private InfoBoxManager infoBoxManager;

	@Inject
	private ScheduledExecutorService scheduledExecutorService;

	@Inject
	private Notifier notifier;

	@Inject
	private OverlayManager overlayManager;

	@Inject
	private CodeWordOverlay codeWordOverlay;

	private WomPanel womPanel;

	@Inject
	ClientToolbar clientToolbar;

	private Map<String, String> nameChanges = new HashMap<>();
	private LinkedBlockingQueue<NameChangeEntry> queue = new LinkedBlockingQueue<>();
	private Map<String, GroupMembership> groupMembers = new HashMap<>();
	private List<ParticipantWithStanding> playerCompetitionsOngoing = new ArrayList<>();
	private List<ParticipantWithCompetition> playerCompetitionsUpcoming = new ArrayList<>();
	private Map<Integer, CompetitionInfoBox> competitionInfoBoxes = new HashMap<>();
	public List<CanvasCompetition> competitionsOnCanvas = new ArrayList<>();
	private List<ScheduledFuture<?>> scheduledFutures = new ArrayList<>();
	private List<String> ignoredRanks = new ArrayList<>();
	private List<String> alwaysIncludedOnSync = new ArrayList<>();

	private boolean fetchXp;
	private long lastXp;
	private boolean visitedLoginScreen = true;
	private boolean recentlyLoggedIn;
	private String playerName;
	private long accountHash;
	private boolean namechangesSubmitted = false;
	private SyncButton syncButton;
	public boolean fetchedOngoingCompetitions = false;
	public boolean fetchedUpcomingCompetitions = false;

	private NavigationButton navButton;

	private final Map<Skill, Integer> previousSkillLevels = new EnumMap<>(Skill.class);

	private boolean comparedClanMembers = false;
	private int tickCounter = 0;

	@Getter
	private static String pluginVersion = "0.0.0";

	static
	{
		WORKING_DIR = new File(RuneLite.RUNELITE_DIR, "wom-utils");
		WORKING_DIR.mkdirs();

		try (InputStream inputStream = WomUtilsPlugin.class.getResourceAsStream("/version.ini"))
		{
			Properties props = new Properties();
			props.load(inputStream);
			pluginVersion = props.getProperty("pluginVersion");
		}
		catch (IOException e)
		{
			log.error("Failed to read version.ini", e);
		}
	}

	@Override
	protected void startUp() throws Exception
	{
		log.info("Wise Old Man started! (v{})", pluginVersion);

		// This will work, idk why really, but ok
		womPanel = injector.getInstance(WomPanel.class);
		try
		{
			loadFile();
		}
		catch (IOException e)
		{
			log.error("Could not load previous name changes");
		}

		womClient.importGroupMembers();

		if (config.playerLookupOption())
		{
			menuManager.addPlayerMenuItem(LOOKUP);
		}

		if (config.importGroup())
		{
			addGroupImportOptions();
		}

		if (config.browseGroup())
		{
			addGroupBrowseOptions();
		}


		if (client.getGameState() == GameState.LOGGED_IN)
		{
			// Set this to true here so when the plugin is enabled after the player has logged in
			// the player name is set correctly for fetching competitions in onGameTick.
			recentlyLoggedIn = true;

			clientThread.invokeLater(() -> {
				Player local = client.getLocalPlayer();
				if (local != null)
				{
					womClient.fetchOngoingPlayerCompetitions(client.getLocalPlayer().getName());
					womClient.fetchUpcomingPlayerCompetitions(client.getLocalPlayer().getName());
					return true;
				}
				return false;
			});
		}

		for (WomCommand c : WomCommand.values())
		{
			chatCommandManager.registerCommandAsync(c.getCommand(), this::commandHandler);
		}

		ignoredRanks = new ArrayList<>(Arrays.asList(gson.fromJson(config.ignoredRanks(), String[].class)));
		competitionsOnCanvas = new ArrayList<>(Arrays.asList(gson.fromJson(config.competitionsOnCanvas(), CanvasCompetition[].class)));


		String ignoreRanksDisplayText = ignoredRanks.stream()
			.map(Object::toString)
			.collect(Collectors.joining(", "));

		// update the ignored ignoreRanksDisplayed text on load if it was modified, it's meant to be read only.
		if (!config.ignoredRanksDisplay().equals(ignoreRanksDisplayText))
		{
			config.ignoreRanksDisplay(ignoreRanksDisplayText);
		}


		alwaysIncludedOnSync.addAll(SPLITTER.splitToList(config.alwaysIncludedOnSync()));

		final BufferedImage icon = ImageUtil.loadImageResource(getClass(), "wom-icon.png");

		navButton = NavigationButton.builder()
			.tooltip("Wise Old Man")
			.icon(icon)
			.priority(5)
			.panel(womPanel)
			.build();

		clientToolbar.addNavigation(navButton);
		overlayManager.add(codeWordOverlay);

		clientThread.invoke(this::saveCurrentLevels);
	}

	@Override
	protected void shutDown() throws Exception
	{
		removeGroupMenuOptions();
		menuManager.removePlayerMenuItem(LOOKUP);

		for (WomCommand c : WomCommand.values())
		{
			chatCommandManager.unregisterCommand(c.getCommand());
		}
		clientToolbar.removeNavigation(navButton);
		womPanel.shutdown();
		clearInfoBoxes();
		competitionsOnCanvas.clear();
		cancelNotifications();
		previousSkillLevels.clear();
		ignoredRanks.clear();
		alwaysIncludedOnSync.clear();
		levelupThisSession = false;
		overlayManager.remove(codeWordOverlay);
		log.info("Wise Old Man stopped!");
	}

	private void addGroupBrowseOptions()
	{
		addGroupMenuOptions(WIDGET_BROWSE_MENU_OPTIONS, ev -> {
			openGroupInBrowser();
		});
	}

	private void addGroupImportOptions()
	{
		addGroupMenuOptions(WIDGET_IMPORT_MENU_OPTIONS, ev -> {
			womClient.importGroupMembers();
		});
	}

	private void saveCurrentLevels()
	{
		if (client.getGameState() != GameState.LOGGED_IN)
		{
			return;
		}

		for (Skill s : Skill.values())
		{
			previousSkillLevels.put(s, client.getRealSkillLevel(s));
		}
	}

	private void commandHandler(ChatMessage chatMessage, String s)
	{
		// TODO: Handle individual ehp/ehbs.

		WomCommand cmd = WomCommand.fromCommand(s);

		if (cmd == null)
		{
			return;
		}

		commandLookup(cmd, chatMessage);
	}

	private void commandLookup(WomCommand command, ChatMessage chatMessage)
	{
		ChatMessageType type = chatMessage.getType();

		String player;

		if (type == ChatMessageType.PRIVATECHATOUT)
		{
			player = client.getLocalPlayer().getName();
		}
		else
		{
			player = Text.sanitize(chatMessage.getName());
		}

		womClient.commandLookup(player, command, chatMessage);
	}

	private boolean isValidNameChange(String prev, String curr)
	{
		return !(Strings.isNullOrEmpty(prev)
			|| curr.equals(prev)
			|| prev.startsWith("[#")
			|| curr.startsWith("[#"));
	}

	@Subscribe
	public void onNameableNameChanged(NameableNameChanged nameableNameChanged)
	{
		final Nameable nameable = nameableNameChanged.getNameable();

		String name = nameable.getName();
		String prev = nameable.getPrevName();

		if (!isValidNameChange(prev, name))
		{
			return;
		}

		NameChangeEntry entry = new NameChangeEntry(Text.toJagexName(prev), Text.toJagexName(name));

		if (isChangeAlreadyRegistered(entry))
		{
			return;
		}

		registerNameChange(entry);
	}

	private boolean isChangeAlreadyRegistered(NameChangeEntry entry)
	{
		String expected = nameChanges.get(entry.getNewName());
		// We can't just check the key because people can change back and forth between names
		return expected != null && expected.equals(entry.getOldName());
	}

	private void registerNameChange(NameChangeEntry entry)
	{
		nameChanges.put(entry.getNewName(), entry.getOldName());
		queue.add(entry);
	}

	@Schedule(
		period = 30,
		unit = ChronoUnit.MINUTES
	)
	public void sendUpdate()
	{
		if (queue.isEmpty())
		{
			if (syncButton != null)
			{
				syncButton.setEnabled();
			}
			namechangesSubmitted = true;

			return;
		}

		List<Nameable> friendIgnore = new ArrayList<>();
		friendIgnore.addAll(Arrays.asList(client.getFriendContainer().getMembers()));
		friendIgnore.addAll(Arrays.asList(client.getIgnoreContainer().getMembers()));

		// List of current valid name changes in our friends/ignore list.
		List<NameChangeEntry> validNameChanges = friendIgnore.stream()
			.filter(nameable -> isValidNameChange(nameable.getPrevName(), nameable.getName()))
			.map(nameable -> new NameChangeEntry(Text.toJagexName(nameable.getPrevName()), Text.toJagexName(nameable.getName())))
			.collect(Collectors.toList());

		// Remove a name change from the queue if it is no longer in our friends/ignore list at the time
		// of submission.
		queue.removeIf(entry -> {
			if (!validNameChanges.contains(entry))
			{
				nameChanges.remove(entry.getNewName(), entry.getOldName());
				return true;
			}
			return false;
		});

		womClient.submitNameChanges(queue.toArray(new NameChangeEntry[0]));
		clientThread.invoke(queue::clear);

		try
		{
			saveFile();

			if (syncButton != null)
			{
				syncButton.setEnabled();
			}
			namechangesSubmitted = true;
		}
		catch (IOException e)
		{
			log.error("Could not write name changes to filesystem");
		}
	}

	private void loadFile() throws IOException
	{
		File file = new File(WORKING_DIR, NAME_CHANGES);
		if (file.exists())
		{
			try
			{
				String json = Files.asCharSource(file, Charsets.UTF_8).read();
				JsonObject jsonObject = jsonParser.parse(json).getAsJsonObject();

				for (Map.Entry<String, JsonElement> entry : jsonObject.entrySet())
				{
					nameChanges.put(entry.getKey(), entry.getValue().getAsString());
				}
			}
			catch (JsonSyntaxException | IllegalStateException e)
			{
				nameChanges.clear();
				log.debug("name-changes.json file was malformed");
			}
		}
	}

	private void saveFile() throws IOException
	{
		String changes = gson.toJson(this.nameChanges);
		File file = new File(WORKING_DIR, NAME_CHANGES);
		Files.asCharSink(file, Charsets.UTF_8).write(changes);
	}

	@Subscribe
	public void onMenuEntryAdded(MenuEntryAdded event)
	{
		if (!config.menuLookupOption())
		{
			return;
		}

		int groupId = WidgetUtil.componentToInterface(event.getActionParam1());
		String option = event.getOption();

		if (!AFTER_OPTIONS.contains(option)
			// prevent duplicate menu options in friends list
			|| (option.equals("Delete") && groupId != InterfaceID.IGNORE))
		{
			return;
		}

		String name = Text.toJagexName(Text.removeTags(event.getTarget()));

		if (config.menuLookupOption())
		{
			boolean addMenuLookup = (groupId == InterfaceID.FRIENDS
				|| groupId == InterfaceID.CHATCHANNEL_CURRENT
				|| groupId == InterfaceID.CLANS_SIDEPANEL
				|| groupId == InterfaceID.CLANS_GUEST_SIDEPANEL
				// prevent from adding for Kick option (interferes with the raiding party one)
				|| groupId == InterfaceID.CHATBOX && !KICK_OPTION.equals(option)
				|| groupId == InterfaceID.RAIDS_SIDEPANEL
				|| groupId == InterfaceID.PM_CHAT
				|| groupId == InterfaceID.IGNORE);

			if (addMenuLookup)
			{
				client.getMenu().createMenuEntry(-2)
					.setTarget(event.getTarget())
					.setOption(LOOKUP)
					.setType(MenuAction.RUNELITE)
					.setIdentifier(event.getIdentifier())
					.onClick(e -> lookupPlayer(name));
			}
		}
	}

	@Subscribe
	public void onMenuOptionClicked(MenuOptionClicked event)
	{
		if (event.getMenuAction() == MenuAction.RUNELITE_PLAYER && event.getMenuOption().equals(LOOKUP))
		{
			IndexedObjectSet<? extends Player> players = client.getTopLevelWorldView().players();
			Player player = players.byIndex(event.getId());

			if (player == null)
			{
				return;
			}
			String target = player.getName();
			lookupPlayer(target);
		}
	}

	@Subscribe
	public void onStatChanged(StatChanged event)
	{
		Skill s = event.getSkill();
		int levelAfter = client.getRealSkillLevel(s);
		int levelBefore = previousSkillLevels.getOrDefault(s, -1);

		if (levelBefore != -1 && levelAfter > levelBefore)
		{
			levelupThisSession = true;
		}
		previousSkillLevels.put(s, levelAfter);
	}

	private void openGroupInBrowser()
	{
		String url = new HttpUrl.Builder()
			.scheme("https")
			.host(isSeasonal ? "league.wiseoldman.net" : "wiseoldman.net")
			.addPathSegment("groups")
			.addPathSegment("" + config.groupId())
			.build()
			.toString();

		SwingUtilities.invokeLater(() -> LinkBrowser.browse(url));
	}

	@Subscribe
	public void onConfigChanged(ConfigChanged event)
	{
		if (!event.getGroup().equals(CONFIG_GROUP))
		{
			return;
		}

		menuManager.removePlayerMenuItem(LOOKUP);
		if (config.playerLookupOption())
		{
			menuManager.addPlayerMenuItem(LOOKUP);
		}

		removeGroupMenuOptions();
		if (config.groupId() > 0)
		{
			if (config.browseGroup())
			{
				addGroupBrowseOptions();
			}

			if (config.importGroup())
			{
				addGroupImportOptions();
			}
		}

		if (event.getKey().equals("sendCompetitionNotification"))
		{
			updateScheduledNotifications();
		}

		if (event.getKey().equals("alwaysIncludedOnSync"))
		{
			alwaysIncludedOnSync.clear();
			alwaysIncludedOnSync.addAll(SPLITTER.splitToList(config.alwaysIncludedOnSync()));
		}
	}

	@Subscribe
	public void onWidgetLoaded(WidgetLoaded widgetLoaded)
	{
		if (widgetLoaded.getGroupId() != InterfaceID.CLANS_INFO && widgetLoaded.getGroupId() != InterfaceID.CLANS_MEMBERS)
		{
			return;
		}


		switch (widgetLoaded.getGroupId())
		{
			case InterfaceID.CLANS_MEMBERS:
				clientThread.invoke(() ->
				{
					createSyncButton(InterfaceID.ClansMembers.FRAME);
					if (syncButton != null)
					{
						syncButton.setEnabled();
					}
					clientThread.invokeLater(this::updateIgnoredRankColors);
				});
				break;
			case InterfaceID.CLANS_INFO:
				clientThread.invoke(() ->
				{
					createSyncButton(InterfaceID.ClansInfo.FRAME);
					if (namechangesSubmitted)
					{
						if (syncButton != null)
						{
							syncButton.setEnabled();
						}
					}
					else
					{
						clientThread.invokeLater(this::sendUpdate);
					}
				});

				break;
		}
	}

	@Subscribe
	public void onMenuOpened(MenuOpened event)
	{
		if (event.getMenuEntries().length < 2)
		{
			return;
		}

		final MenuEntry entry = event.getMenuEntries()[event.getMenuEntries().length - 1];
		Widget clanWidgetTitleLeftSide = client.getWidget(InterfaceID.ClansMembers.HEADER1);
		boolean leftSideRanks = false;
		if (clanWidgetTitleLeftSide != null)
		{
			if (clanWidgetTitleLeftSide.getDynamicChildren().length == 5)
			{
				leftSideRanks = entry.getParam1() == InterfaceID.ClansMembers.COLUMN1 && clanWidgetTitleLeftSide.getDynamicChildren()[4].getText().equals("Rank");
			}
		}
		boolean rightSideRanks = false;
		Widget clanWidgetTitleRightSide = client.getWidget(InterfaceID.ClansMembers.HEADER2);
		if (clanWidgetTitleRightSide != null)
		{
			if (clanWidgetTitleRightSide.getDynamicChildren().length == 5)
			{
				rightSideRanks = entry.getParam1() == InterfaceID.ClansMembers.COLUMN2 && clanWidgetTitleRightSide.getDynamicChildren()[4].getText().equals("Rank");
			}
		}

		if (entry.getType() != MenuAction.CC_OP)
		{
			return;
		}

		if (!leftSideRanks && !rightSideRanks)
		{
			return;
		}

		ClanSettings clanSettings = client.getClanSettings();
		String targetPlayer = Text.removeTags(entry.getTarget());
		ClanRank rank = clanSettings.findMember(targetPlayer).getRank();
		String rankTitle = clanSettings.titleForRank(rank).getName();
		String targetRank = ColorUtil.wrapWithColorTag(rankTitle, new Color(0xff9040));
		String standardisedRankTitle = rankTitle.toLowerCase().replaceAll("[-\\s]", "_");
		boolean rankIsIgnored = ignoredRanks.contains(standardisedRankTitle);

		client.getMenu().createMenuEntry(-1)
			.setOption(!rankIsIgnored ? IGNORE_RANK : UNIGNORE_RANK)
			.setType(MenuAction.RUNELITE)
			.setTarget(targetRank)
			.onClick(e -> {
				if (!rankIsIgnored)
				{
					chatboxPanelManager.openTextMenuInput("Are you sure you want to ignore " + rankTitle + " from WOM Sync?")
						.option("Yes", () -> addIgnoredRank(standardisedRankTitle))
						.option("No", Runnables.doNothing())
						.build();
				}
				else
				{
					removeIgnoreRank(standardisedRankTitle);
				}
			});
	}

	private void addIgnoredRank(String rankTitle)
	{
		ignoredRanks.add(rankTitle);
		updateIgnoredRanks();
	}

	private void removeIgnoreRank(String rankTitle)
	{
		ignoredRanks.removeIf(r -> r.equals(rankTitle));
		updateIgnoredRanks();
	}

	private void updateIgnoredRanks()
	{
		config.ignoredRanks(gson.toJson(ignoredRanks));
		config.ignoreRanksDisplay(ignoredRanks.stream()
			.map(Object::toString)
			.collect(Collectors.joining(", ")));
		updateIgnoredRankColors();
	}

	private void updateIgnoredRankColors()
	{
		updateIgnoredRankColorsByID(InterfaceID.ClansMembers.COLUMN1);
		updateIgnoredRankColorsByID(InterfaceID.ClansMembers.COLUMN2);
	}

	private void updateIgnoredRankColorsByID(int widgetID)
	{
		Widget parent = client.getWidget(widgetID);
		if (parent == null)
		{
			return;
		}

		Widget[] children = parent.getDynamicChildren();
		if (children == null || children.length == 0)
		{
			return;
		}

		for (Widget child : children)
		{
			if (ignoredRanks.contains(child.getText().toLowerCase().replaceAll("[-\\s]", "_")))
			{
				child.setTextColor(Color.RED.getRGB());
			}
			else
			{
				child.setTextColor(DEFAULT_CLAN_SETTINGS_TEXT_COLOR.getRGB());
			}
		}
	}

	@Subscribe
	public void onGameStateChanged(GameStateChanged gameStateChanged)
	{
		GameState state = gameStateChanged.getGameState();
		switch (state)
		{
			case LOGGED_IN:
				if (accountHash != client.getAccountHash())
				{
					fetchXp = true;
				}

				recentlyLoggedIn = true;
				isSeasonal = client.getWorldType().contains(WorldType.SEASONAL);
				womClient.importGroupMembers();
				break;
			case LOGIN_SCREEN:
				// When a player logs out we want to set these variables
				// and also submit update request
				visitedLoginScreen = true;
				namechangesSubmitted = false;
				womPanel.resetCompetitionsPanel();
				womPanel.resetGroupFilter();
				clearInfoBoxes();

				// Reset so we can compare on log in
				tickCounter = 0;
				comparedClanMembers = false;
			case HOPPING:
				Player local = client.getLocalPlayer();
				if (local == null)
				{
					return;
				}

				long totalXp = client.getOverallExperience();
				// Don't submit update unless xp threshold is reached
				if (Math.abs(totalXp - lastXp) > XP_THRESHOLD || levelupThisSession)
				{
					updateMostRecentPlayer();
					lastXp = totalXp;
					levelupThisSession = false;
				}
				break;
		}
	}

	@Subscribe
	public void onGameTick(GameTick gameTick)
	{
		if (fetchXp)
		{
			lastXp = client.getOverallExperience();
			fetchXp = false;
		}

		Player local = client.getLocalPlayer();

		if (visitedLoginScreen && recentlyLoggedIn && local != null)
		{
			playerName = local.getName();
			accountHash = client.getAccountHash();
			womClient.fetchOngoingPlayerCompetitions(playerName);
			womClient.fetchUpcomingPlayerCompetitions(playerName);
			recentlyLoggedIn = false;
			visitedLoginScreen = false;
		}

		if (!womPanel.noCompetitionsErrorPanel.isVisible() &&
			fetchedUpcomingCompetitions &&
			fetchedOngoingCompetitions &&
			playerCompetitionsUpcoming.isEmpty() &&
			playerCompetitionsOngoing.isEmpty())
		{
			womPanel.showNoCompetitionsError();
		}

		if (client.getGameState() == GameState.LOGGED_IN)
		{
			// Delay comparing the clan members list for a little until clan settings have loaded
			if (tickCounter >= 5 && !comparedClanMembers)
			{
				ClanSettings clanSettings = client.getClanSettings();
				if (clanSettings != null && config.groupId() > 0 && !Strings.isNullOrEmpty(config.verificationCode()))
				{
					compareClanMembersList(clanSettings);
				}
				comparedClanMembers = true;
			}
			else
			{
				tickCounter += 1;
			}
		}

		if (womPanel.active)
		{
			womPanel.updateCompetitionCountdown();
		}
	}

	public boolean isSameClan(Set<String> clanMemberNames, Set<String> groupMemberNames, double tolerance)
	{
		Set<String> alwaysIncluded = alwaysIncludedOnSync.stream().map(String::toLowerCase).collect(Collectors.toSet());
		return isSameClan(clanMemberNames, groupMemberNames, tolerance, alwaysIncluded);
	}

	private boolean isSameClan(Set<String> clanMemberNames, Set<String> groupMemberNames, double tolerance, Set<String> alwaysIncluded)
	{
		Set<String> onlyInClan = new HashSet<>(clanMemberNames);
		onlyInClan.addAll(alwaysIncluded);
		onlyInClan.removeAll(groupMemberNames);

		Set<String> onlyInGroup = new HashSet<>(groupMemberNames);
		onlyInGroup.removeAll(clanMemberNames);
		onlyInGroup.removeAll(alwaysIncluded);

		int totalDifference = onlyInClan.size() + onlyInGroup.size();

		Set<String> combinedLists = new HashSet<>(clanMemberNames);
		combinedLists.addAll(groupMemberNames);
		combinedLists.addAll(alwaysIncluded);
		int totalUniqueNames = combinedLists.size();

		return ((double) totalDifference / totalUniqueNames) <= tolerance;
	}

	private void compareClanMembersList(ClanSettings clanSettings)
	{
		List<ClanMember> clanMembers = clanSettings.getMembers();

		Set<String> clanMemberNames = clanMembers.stream().filter(clanMember -> {
			ClanTitle clanTitle = clanSettings.titleForRank(clanMember.getRank());
			return clanTitle == null || !ignoredRanks.contains(clanTitle.getName().toLowerCase().replaceAll("[-\\s]", "_"));
		}).map(clanMember -> Text.toJagexName(clanMember.getName()).toLowerCase()).collect(Collectors.toSet());
		Set<String> groupMemberNames = groupMembers.keySet();
		Set<String> alwaysIncluded = alwaysIncludedOnSync.stream().map(String::toLowerCase).collect(Collectors.toSet());

		// Don't send the out of sync chat message so we don't encourage syncing
		// when it's not the same clan.
		if (!isSameClan(clanMemberNames, groupMemberNames, SAME_CLAN_TOLERANCE, alwaysIncluded))
		{
			return;
		}

		Set<String> onlyInClan = new HashSet<>(clanMemberNames);
		onlyInClan.addAll(alwaysIncluded);
		onlyInClan.removeAll(groupMemberNames);

		Set<String> onlyInGroup = new HashSet<>(groupMemberNames);
		onlyInGroup.removeAll(clanMemberNames);
		onlyInGroup.removeAll(alwaysIncluded);

		boolean outOfSync = false;
		String outOfSyncMessage = "Your group is out of sync: ";
		if (!onlyInClan.isEmpty())
		{
			outOfSyncMessage += onlyInClan.size() + " player" + (onlyInClan.size() > 1 ? "s" : "") + "joined";
			outOfSync = true;
		}

		if (!onlyInClan.isEmpty() && !onlyInGroup.isEmpty())
		{
			outOfSyncMessage += " and ";
		}

		if (!onlyInGroup.isEmpty())
		{
			outOfSyncMessage += onlyInGroup.size() + " player" + (onlyInGroup.size() > 1 ? "s" : "") + " left";
			outOfSync = true;
		}

		if (onlyInClan.isEmpty() && onlyInGroup.isEmpty())
		{
			// check if ranks differ when the member lists are the same
			int ranksChanged = 0;
			for (ClanMember cm : clanMembers)
			{
				ClanTitle clanTitle = clanSettings.titleForRank(cm.getRank());
				String groupRole = groupMembers.get(Text.toJagexName(cm.getName()).toLowerCase()).getRole();

				// clanTitle=null syncs to default role "member" on WOM.
				if (clanTitle != null && !clanTitle.getName().toLowerCase().replaceAll(" ", "_").equals(groupRole) || clanTitle == null && !groupRole.equals(DEFAULT_ROLE))
				{
					ranksChanged += 1;
				}
			}

			if (ranksChanged > 0)
			{
				outOfSyncMessage += ranksChanged + " rank" + (ranksChanged > 1 ? "s" : "") + " changed";
				outOfSync = true;
			}
		}

		outOfSyncMessage += ".";

		if (outOfSync)
		{
			sendResponseToChat(outOfSyncMessage, womClient.ERROR);
		}
	}

	private void addGroupMenuOptions(List<WidgetMenuOption> menuOptions, Consumer<MenuEntry> callback)
	{
		for (WidgetMenuOption option : menuOptions)
		{
			menuManager.addManagedCustomMenu(option, callback);
		}
	}

	private void removeGroupMenuOptions()
	{
		for (WidgetMenuOption option : WIDGET_BROWSE_MENU_OPTIONS)
		{
			menuManager.removeManagedCustomMenu(option);
		}

		for (WidgetMenuOption option : WIDGET_IMPORT_MENU_OPTIONS)
		{
			menuManager.removeManagedCustomMenu(option);
		}
	}

	private void updateMostRecentPlayer()
	{
		updateMostRecentPlayer(false);
	}

	private void updateMostRecentPlayer(boolean always)
	{
		boolean coreUpdaterIsOff = pluginManager
			.getPlugins().stream()
			.noneMatch(p -> p instanceof XpUpdaterPlugin && pluginManager.isPluginEnabled(p));

		if (always || !xpUpdaterConfig.wiseoldman() || coreUpdaterIsOff)
		{
			log.debug("Submitting update for {}", playerName);
			// Send update requests even if the user has forgotten to enable player updates in the core plugin
			womClient.updatePlayer(playerName, accountHash);
		}
	}

	private void lookupPlayer(String playerName)
	{
		SwingUtilities.invokeLater(() ->
		{
			clientToolbar.openPanel(navButton);
			womPanel.lookup(playerName);
		});
	}

	@Subscribe
	public void onWomGroupSynced(WomGroupSynced event)
	{
		Map<String, GroupMembership> old = new HashMap<>(groupMembers);

		groupMembers.clear();
		for (GroupMembership member : event.getGroupInfo().getMemberships())
		{
			groupMembers.put(member.getPlayer().getUsername(), member);
		}

		if (!event.isSilent())
		{
			String message = compareChanges(old, groupMembers);
			sendResponseToChat(message, getSuccessColor());
		}
	}

	@Subscribe
	public void onWomOngoingPlayerCompetitionsFetched(WomOngoingPlayerCompetitionsFetched event)
	{
		// Filter out competitions with null metrics
		playerCompetitionsOngoing = Arrays.stream(event.getCompetitions())
			.filter(pws -> pws.getCompetition().getMetric() != null)
			.collect(Collectors.toList());

		log.debug("Fetched {} ongoing competitions for player {}", event.getCompetitions().length, event.getUsername());
		for (ParticipantWithStanding pws : playerCompetitionsOngoing)
		{
			Competition c = pws.getCompetition();
			if (config.competitionLoginMessage())
			{
				sendHighlightedMessage(c.getStatus());
			}
		}
		updateScheduledNotifications();
		womPanel.addOngoingCompetitions(playerCompetitionsOngoing);
		womPanel.addGroupFilters(playerCompetitionsOngoing.stream().map(ParticipantWithStanding::getCompetition).toArray(Competition[]::new));
		fetchedOngoingCompetitions = true;
	}

	@Subscribe
	public void onWomUpcomingPlayerCompetitionsFetched(WomUpcomingPlayerCompetitionsFetched event)
	{
		// Filter out competitions with null metrics
		playerCompetitionsUpcoming = Arrays.stream(event.getCompetitions())
			.filter(pwc -> pwc.getCompetition().getMetric() != null)
			.collect(Collectors.toList());

		log.debug("Fetched {} upcoming competitions for player {}", event.getCompetitions().length, event.getUsername());
		updateScheduledNotifications();
		womPanel.addUpcomingCompetitions(playerCompetitionsUpcoming);
		womPanel.addGroupFilters(playerCompetitionsUpcoming.stream().map(ParticipantWithCompetition::getCompetition).toArray(Competition[]::new));
		fetchedUpcomingCompetitions = true;
	}

	@Subscribe
	public void onWomRequestFailed(WomRequestFailed event)
	{
		if (event.getType() == WomRequestType.COMPETITIONS_ONGOING || event.getType() == WomRequestType.COMPETITIONS_UPCOMING)
		{
			womPanel.displayCompetitionFetchError(event.getType(), event.getUsername());
		}
	}

	public void addInfoBox(CompetitionCardPanel p)
	{
		int competitionId = p.getCompetition().getId();
		if (hasInfoBox(competitionId))
		{
			return;
		}

		CompetitionInfoBox infoBox = new CompetitionInfoBox(p, this);
		competitionInfoBoxes.put(competitionId, infoBox);
		infoBoxManager.addInfoBox(infoBox);

		if (competitionsOnCanvas.stream().map(CanvasCompetition::getId).collect(Collectors.toSet()).contains(competitionId))
		{
			return;
		}

		competitionsOnCanvas.add(new CanvasCompetition(competitionId, p.getCompetition().isActive()));
		config.competitionsOnCanvas(gson.toJson(competitionsOnCanvas));
	}

	public void removeInfoBox(CompetitionCardPanel p)
	{
		int id = p.getCompetition().getId();
		infoBoxManager.removeIf(e -> e instanceof CompetitionInfoBox && ((CompetitionInfoBox) e).getCompetition().getId() == id);
		competitionInfoBoxes.remove(id);

		competitionsOnCanvas.removeIf(c -> c.getId() == id);
		config.competitionsOnCanvas(gson.toJson(competitionsOnCanvas));
	}

	public void clearOldCanvasCompetitions(Set<Integer> competitionIds, boolean ongoing)
	{
		competitionsOnCanvas.removeIf(onCanvas -> onCanvas.isOngoing() == ongoing && !competitionIds.contains(onCanvas.getId()));
		config.competitionsOnCanvas(gson.toJson(competitionsOnCanvas));
	}

	public boolean hasInfoBox(int id)
	{
		return competitionInfoBoxes.containsKey(id);
	}

	private void clearInfoBoxes()
	{
		infoBoxManager.removeIf(CompetitionInfoBox.class::isInstance);
		competitionInfoBoxes.clear();
	}

	private void updateScheduledNotifications()
	{
		cancelNotifications();

		List<DelayedAction> delayedActions = new ArrayList<>();

		for (ParticipantWithCompetition pwc : playerCompetitionsUpcoming)
		{
			Competition c = pwc.getCompetition();
			if (!c.hasStarted())
			{
				delayedActions.add(new DelayedAction(c.durationLeft().plusSeconds(1), () ->
					updateMostRecentPlayer(true)));
				if (!config.sendCompetitionNotification())
				{
					continue;
				}
				delayedActions.add(new DelayedAction(c.durationLeft().minusHours(1), () ->
					notifier.notify(c.getStatus())));
				delayedActions.add(new DelayedAction(c.durationLeft().minusMinutes(15), () ->
					notifier.notify(c.getStatus())));
				delayedActions.add(new DelayedAction(c.durationLeft().plusSeconds(1), () ->
					notifier.notify("Competition: " + c.getTitle() + " has started!")));
			}
		}

		for (ParticipantWithStanding pws : playerCompetitionsOngoing)
		{
			Competition c = pws.getCompetition();
			// Send an update when there are 15 minutes left so that there is at least one datapoint in the end
			delayedActions.add(new DelayedAction(c.durationLeft().minusMinutes(15), () ->
				updateMostRecentPlayer(true)));
			if (!config.sendCompetitionNotification())
			{
				continue;
			}
			delayedActions.add(new DelayedAction(c.durationLeft().minusHours(1), () ->
				notifier.notify(c.getStatus())));
			delayedActions.add(new DelayedAction(c.durationLeft().minusMinutes(15), () ->
				notifier.notify(c.getStatus())));
			delayedActions.add(new DelayedAction(c.durationLeft().minusMinutes(4), () ->
				notifier.notify("Competition: " + c.getTitle() + " is ending soon, logout now to record your final datapoint!")));
			delayedActions.add(new DelayedAction(c.durationLeft().plusSeconds(1), () ->
				notifier.notify("Competition: " + c.getTitle() + " is over, thanks for playing!")));
		}

		for (DelayedAction action : delayedActions)
		{
			if (!action.getDelay().isNegative())
			{
				scheduledFutures.add(scheduledExecutorService.schedule(action.getRunnable(),
					action.getDelay().getSeconds(), TimeUnit.SECONDS));
			}
		}
	}

	private void cancelNotifications()
	{
		for (ScheduledFuture<?> sf : scheduledFutures)
		{
			sf.cancel(false);
		}
		scheduledFutures.clear();
	}

	private String compareChanges(Map<String, GroupMembership> oldMembers, Map<String, GroupMembership> newMembers)
	{
		int membersAdded = 0;
		int ranksChanged = 0;
		for (String username : newMembers.keySet())
		{
			if (oldMembers.containsKey(username))
			{
				if (!newMembers.get(username).getRole().equals(oldMembers.get(username).getRole()))
				{
					ranksChanged += 1;
				}
			}
			else
			{
				membersAdded += 1;
			}
		}

		int membersRemoved = oldMembers.size() + membersAdded - newMembers.size();

		return String.format("Synced %d clan members. %d added, %d removed, %d ranks changed, %d ranks ignored.",
			newMembers.size(), membersAdded, membersRemoved, ranksChanged, ignoredRanks.size());
	}

	private void sendResponseToChat(String message, Color color)
	{
		ChatMessageBuilder cmb = new ChatMessageBuilder();
		cmb.append(color, MESSAGE_PREFIX + message);

		chatMessageManager.queue(QueuedMessage.builder()
			.type(ChatMessageType.CONSOLE)
			.runeLiteFormattedMessage(cmb.build())
			.build());
	}

	private void sendHighlightedMessage(String chatMessage)
	{
		final String message = new ChatMessageBuilder()
			.append(ChatColorType.HIGHLIGHT)
			.append(MESSAGE_PREFIX + chatMessage)
			.build();

		chatMessageManager.queue(
			QueuedMessage.builder()
				.type(ChatMessageType.CONSOLE)
				.runeLiteFormattedMessage(message)
				.build());
	}

	private void createSyncButton(int w)
	{
		if (config.syncClanButton() && config.groupId() > 0 && !Strings.isNullOrEmpty(config.verificationCode()))
		{
			syncButton = new SyncButton(client, this, clientThread, womClient, chatboxPanelManager, w, groupMembers, ignoredRanks, alwaysIncludedOnSync);
		}
	}

	private Color getSuccessColor()
	{
		if (client.getVarbitValue(VarbitID.CHATBOX_TRANSPARENCY) == 0 || !client.isResized())
		{
			return new Color(client.getVarpValue(VarPlayerID.OPTION_CHAT_COLOUR_CLANBROADCAST_OPAQUE) - 1);

		}
		else
		{
			return new Color(client.getVarpValue(VarPlayerID.OPTION_CHAT_COLOUR_CLANBROADCAST_TRANSPARENT) - 1);
		}
	}

	@Provides
	WomUtilsConfig provideConfig(ConfigManager configManager)
	{
		return configManager.getConfig(WomUtilsConfig.class);
	}

	@Override
	public void configure(Binder binder)
	{
		binder.bind(NameAutocompleter.class);
		binder.bind(WomClient.class);
		binder.bind(CodeWordOverlay.class);
	}
}

package net.wiseoldman;

import java.awt.Color;
import net.runelite.client.config.Config;
import net.runelite.client.config.ConfigGroup;
import net.runelite.client.config.ConfigItem;
import net.runelite.client.config.ConfigSection;

@ConfigGroup(WomUtilsPlugin.CONFIG_GROUP)
public interface WomUtilsConfig extends Config
{

	enum CompetitionsToAddToCanvas
	{
		NONE,
		UPCOMING,
		ONGOING,
		BOTH
	}

	@ConfigSection(
		name = "Group",
		description = "The group configurations",
		position = 1
	)
	String groupConfig = "groupConfig";

	@ConfigSection(
		name = "Lookup",
		description = "Lookup menu option configurations",
		position = 2
	)
	String lookupConfig = "lookupConfig";

	@ConfigSection(
		name = "Competitions",
		description = "Competition configurations",
		position = 3
	)
	String competitionConfig = "competitionConfig";

	@ConfigSection(
		name = "Event codeword",
		description = "Event codeword configurations",
		position = 4
	)
	String eventCodeword = "eventCodeword";

	@ConfigSection(
		name = "Not Synced Ranks",
		description = "Ignored Ranks for WOM sync",
		position = 5,
		closedByDefault = true
	)
	String ignoredRanks = "ignoredRanks";

	@ConfigItem(
		keyName = "playerLookupOption",
		name = "Player option",
		description = "Add WOM Lookup option to players",
		position = 0,
		section = lookupConfig
	)
	default boolean playerLookupOption()
	{
		return false;
	}

	@ConfigItem(
		keyName = "menuLookupOption",
		name = "Menu option",
		description = "Add WOM Lookup option to menus",
		position = 1,
		section = lookupConfig
	)
	default boolean menuLookupOption()
	{
		return false;
	}

	@ConfigItem(
		keyName = "virtualLevels",
		name = "Virtual levels",
		description = "Show virtual levels in the side bar on lookup",
		position = 2,
		section = lookupConfig
	)
	default boolean virtualLevels()
	{
		return false;
	}

	@ConfigItem(
		keyName = "relativeTime",
		name = "Relative time",
		description = "Display last updated time relative to current date and time",
		position = 3,
		section = lookupConfig
	)
	default boolean relativeTime()
	{
		return false;
	}

	@ConfigItem(
		keyName = "importGroup",
		name = "Import Group option",
		description = "Add Import WOM Group menu option to the clan chat tab",
		position = 1,
		section = groupConfig
	)
	default boolean importGroup()
	{
		return false;
	}

	@ConfigItem(
		keyName = "browseGroup",
		name = "Browse Group option",
		description = "Add Browse WOM Group menu option to the clan chat tab",
		position = 2,
		section = groupConfig
	)
	default boolean browseGroup()
	{
		return false;
	}

	@ConfigItem(
		keyName = "syncClanButton",
		name = "Sync Clan button",
		description = "Add a sync clan button to the clan members list in settings if a group is configured",
		position = 3,
		section = groupConfig
	)
	default boolean syncClanButton()
	{
		return true;
	}

	@ConfigItem(
		keyName = "alwaysIncludedOnSync",
		name = "Always Included",
		description = "Players that will always be included in the group regardless of clan sync method, comma separated names",
		position = 4,
		section = groupConfig
	)
	default String alwaysIncludedOnSync()
	{
		return "";
	}

	@ConfigItem(
		keyName = "groupId",
		name = "Group Id",
		description = "The group id in WOM",
		position = 5,
		section = groupConfig
	)
	default int groupId()
	{
		return 0;
	}

	@ConfigItem(
		keyName = "verificationCode",
		name = "Verification code",
		description = "Verification code for the WOM group",
		secret = true,
		position = 6,
		section = groupConfig
	)
	default String verificationCode()
	{
		return "";
	}

	@ConfigItem(
		keyName = "competitionLoginMessage",
		name = "Login info",
		description = "Show ongoing competition info when logging in",
		position = 1,
		section = competitionConfig
	)
	default boolean competitionLoginMessage()
	{
		return false;
	}

	@ConfigItem(
		keyName = "sendCompetitionNotification",
		name = "Competition Notifications",
		description = "Sends notifications at start and end times for competitions",
		position = 2,
		section = competitionConfig
	)
	default boolean sendCompetitionNotification()
	{
		return false;
	}

	@ConfigItem(
		keyName = "addCompetitionsToCanvas",
		name = "Auto add to canvas",
		description = "Automatically add competitions to canvas",
		position = 3,
		section = competitionConfig
	)
	default CompetitionsToAddToCanvas addCompetitionsToCanvas()
	{
		return CompetitionsToAddToCanvas.NONE;
	}

	@ConfigItem(
		keyName = "displayCodeword",
		name = "Display codeword",
		description = "Displays an event codeword overlay",
		position = 13,
		section = eventCodeword
	)
	default boolean displayCodeword()
	{
		return false;
	}

	@ConfigItem(
		keyName = "configuredCodeword",
		name = "Codeword",
		description = "Event codeword",
		position = 14,
		section = eventCodeword
	)
	default String configuredCodeword()
	{
		return "WOMCodeword";
	}

	@ConfigItem(
		keyName = "showTimestamp",
		name = "Show timestamp",
		description = "Attach a timestamp to the codeword",
		position = 15,
		section = eventCodeword
	)
	default boolean showTimestamp()
	{
		return true;
	}

	@ConfigItem(
		keyName = "codewordColor",
		name = "Codeword color",
		description = "Overlay codeword color",
		position = 16,
		section = eventCodeword
	)
	default Color codewordColor()
	{
		return new Color(0x00FF6A);
	}

	@ConfigItem(
		keyName = "timestampColor",
		name = "Timestamp color",
		description = "Overlay timestamp color",
		position = 16,
		section = eventCodeword
	)
	default Color timestampColor()
	{
		return new Color(0xFFFFFF);
	}

	@ConfigItem(
		keyName = "ignoredRanksDisplay",
		name = "Ignored Ranks from WOM Sync",
		description = "List of ignored ranks from WOM Sync (read only)",
		position = 17,
		section = ignoredRanks
	)
	default String ignoredRanksDisplay()
	{
		return "";
	}

	@ConfigItem(
		keyName = "ignoredRanks",
		name = "",
		description = "",
		hidden = true
	)
	default String ignoredRanks()
	{
		return "[]";
	}

	@ConfigItem(
		keyName = "ignoredRanks",
		name = "",
		description = "",
		hidden = true
	)
	void ignoredRanks(String value);

	@ConfigItem(
		keyName = "ignoredRanksDisplay",
		name = "",
		description = "",
		hidden = true
	)
	void ignoreRanksDisplay(String value);

	@ConfigItem(
		keyName = "competitionsOnCanvas",
		name = "",
		description = "",
		hidden = true
	)
	default String competitionsOnCanvas()
	{
		return "[]";
	}

	@ConfigItem(
		keyName = "competitionsOnCanvas",
		name = "",
		description = "",
		hidden = true
	)
	void competitionsOnCanvas(String value);
}

package net.wiseoldman.ui;

import lombok.Getter;
import net.wiseoldman.WomUtilsPlugin;
import net.wiseoldman.beans.Competition;
import net.wiseoldman.beans.CompetitionProgress;
import net.wiseoldman.beans.Metric;
import net.wiseoldman.panel.CompetitionCardPanel;
import net.wiseoldman.util.Utils;
import java.awt.Color;
import java.text.DecimalFormat;
import java.time.Duration;
import net.runelite.client.hiscore.HiscoreSkillType;
import net.runelite.client.ui.overlay.infobox.InfoBox;
import net.runelite.client.util.ColorUtil;
import org.apache.commons.lang3.time.DurationFormatUtils;

public class CompetitionInfoBox extends InfoBox
{
	@Getter
	final Competition competition;
	final WomUtilsPlugin plugin;
	final int rank;
	final CompetitionProgress progress;

	private static final Color ACTIVE_COLOR = new Color(0x51f542);

	public CompetitionInfoBox(CompetitionCardPanel p, WomUtilsPlugin plugin)
	{
		super(p.getCompetition().getMetric().loadIcon(p.getCompetition().getMetric().getType()), plugin);
		this.competition = p.getCompetition();
		this.rank = p.getRank();
		this.progress = p.getProgress();
		this.plugin = plugin;
	}

	@Override
	public String getTooltip()
	{
		Metric metric = competition.getMetric();
		StringBuilder sb = new StringBuilder();
		sb.append(competition.getTitle()).append("</br>")
			.append("Metric: ").append(metric.getName()).append("</br>")
			.append(competition.getTimeStatus());
		if (progress != null)
		{
			sb.append("</br>");
			double gained = progress.getGained();
			if (gained > 0)
			{
				String coloredRank = ColorUtil.wrapWithColorTag(Utils.ordinalOf(rank), Color.GREEN);
				sb.append("Ranked: ").append(coloredRank);

				final DecimalFormat df;
				if (metric == Metric.EHB || metric == Metric.EHP)
				{
					// These are the only ones actually in decimal
					df = new DecimalFormat("####.##");
				}
				else
				{
					df = new DecimalFormat("###,###,###");
				}

				String formattedProgress = df.format(gained);
				String coloredProgress = ColorUtil.wrapWithColorTag(formattedProgress, Color.GREEN);
				sb.append(" (Gained ").append(coloredProgress);

				switch (metric)
				{
					case EHB:
					case EHP:
						sb.append(" hours");
						break;
					default:
						sb.append(getUnitForType(metric.getType()));
				}
				sb.append(")");
			}
		}
		return sb.toString();
	}

	private String getUnitForType(HiscoreSkillType type)
	{
		if (type == null)
		{
			return "";
		}
		switch (type)
		{
			case SKILL:
				return " xp";
			case BOSS:
				return " kills";
			case ACTIVITY:
				return " points";
			default:
				return "";
		}
	}

	@Override
	public Color getTextColor()
	{
		return competition.isActive() ? ACTIVE_COLOR : Color.YELLOW;
	}

	@Override
	public String getText()
	{
		Duration timeLeft = competition.durationLeft();

		if (timeLeft.toDays() > 9)
		{
			return DurationFormatUtils.formatDuration(timeLeft.toMillis(), "d'd'");
		}
		else if (timeLeft.toDays() > 0)
		{
			return DurationFormatUtils.formatDuration(timeLeft.toMillis(), "d'd'H'h'");
		}
		else if (timeLeft.toHours() > 0)
		{
			return DurationFormatUtils.formatDuration(timeLeft.toMillis(), "H'h'm'm'");
		}
		else
		{
			return DurationFormatUtils.formatDuration(timeLeft.toMillis(), "mm:ss");
		}
	}

	@Override
	public boolean cull()
	{
		return competition.hasEnded();
	}
}

package net.wiseoldman.ui;

import com.google.common.util.concurrent.Runnables;
import java.util.stream.Collectors;
import net.runelite.client.callback.ClientThread;
import net.runelite.api.clan.ClanRank;
import net.wiseoldman.WomUtilsPlugin;
import net.wiseoldman.beans.GroupMembership;
import net.wiseoldman.beans.RoleIndex;
import net.wiseoldman.web.WomClient;
import net.wiseoldman.beans.Member;
import java.util.Arrays;
import java.util.HashMap;
import java.util.Map;
import java.util.HashSet;
import java.util.Set;
import net.runelite.api.*;
import net.runelite.api.clan.ClanMember;
import net.runelite.api.clan.ClanSettings;
import net.runelite.api.clan.ClanTitle;
import net.runelite.api.widgets.*;
import net.runelite.client.game.chatbox.ChatboxPanelManager;
import net.runelite.client.util.Text;

import java.util.ArrayList;
import java.util.List;

public class SyncButton
{
	private final Client client;
	private final WomUtilsPlugin plugin;
	private final ClientThread clientThread;
	private final WomClient womClient;
	private final ChatboxPanelManager chatboxPanelManager;
	private final Widget parent;

	private final List<Widget> cornersAndEdges = new ArrayList<>();
	private final ClanSettings clanSettings;
	private final Map<String, GroupMembership> groupMembers;
	private final List<String> ignoredRanks;
	private final List<String> alwaysIncludedOnSync;
	private Widget textWidget;

	private Set<RoleIndex> roleOrders = new HashSet<>();
	private boolean notSameClanWarning = false;


	private final List<ClanRank> roleOrder = Arrays.asList(
		ClanRank.OWNER, ClanRank.DEPUTY_OWNER, new ClanRank(124), new ClanRank(120),
		new ClanRank(115), new ClanRank(110), new ClanRank(105), new ClanRank(104),
		new ClanRank(103), new ClanRank(102), new ClanRank(101), ClanRank.ADMINISTRATOR,
		new ClanRank(99), new ClanRank(98), new ClanRank(97), new ClanRank(96),
		new ClanRank(95), new ClanRank(90), new ClanRank(80), new ClanRank(70),
		new ClanRank(60), new ClanRank(50), new ClanRank(40), new ClanRank(30),
		new ClanRank(20), new ClanRank(10), new ClanRank(0)
	);

	public SyncButton(Client client, WomUtilsPlugin plugin, ClientThread clientThread, WomClient womClient,
					  ChatboxPanelManager chatboxPanelManager, int parent, Map<String, GroupMembership> groupMembers,
					  List<String> ignoredRanks, List<String> alwaysIncludedOnSync)
	{
		this.client = client;
		this.plugin = plugin;
		this.clientThread = clientThread;
		this.womClient = womClient;
		this.chatboxPanelManager = chatboxPanelManager;
		this.parent = client.getWidget(parent);
		this.clanSettings = client.getClanSettings();
		this.groupMembers = groupMembers;
		this.ignoredRanks = ignoredRanks;
		this.alwaysIncludedOnSync = alwaysIncludedOnSync;

		this.createWidgetWithSprite(SpriteID.EQUIPMENT_BUTTON_METAL_CORNER_TOP_LEFT, 6, 6, 9, 9);
		this.createWidgetWithSprite(SpriteID.EQUIPMENT_BUTTON_METAL_CORNER_TOP_RIGHT, 97, 6, 9, 9);
		this.createWidgetWithSprite(SpriteID.EQUIPMENT_BUTTON_METAL_CORNER_BOTTOM_LEFT, 6, 20, 9, 9);
		this.createWidgetWithSprite(SpriteID.EQUIPMENT_BUTTON_METAL_CORNER_BOTTOM_RIGHT, 97, 20, 9, 9);
		this.createWidgetWithSprite(SpriteID.EQUIPMENT_BUTTON_EDGE_LEFT, 6, 15, 9, 5);
		this.createWidgetWithSprite(SpriteID.EQUIPMENT_BUTTON_EDGE_TOP, 15, 6, 82, 9);
		this.createWidgetWithSprite(SpriteID.EQUIPMENT_BUTTON_EDGE_RIGHT, 97, 15, 9, 5);
		this.createWidgetWithSprite(SpriteID.EQUIPMENT_BUTTON_EDGE_BOTTOM, 15, 20, 82, 9);
		this.textWidget = this.createWidgetWithText();
	}

	private void createWidgetWithSprite(int spriteId, int x, int y, int width, int height)
	{
		Widget w = this.parent.createChild(-1, WidgetType.GRAPHIC);
		w.setSpriteId(spriteId);
		w.setOriginalX(x);
		w.setOriginalY(y);
		w.setOriginalWidth(width);
		w.setOriginalHeight(height);
		w.setXPositionMode(WidgetPositionMode.ABSOLUTE_LEFT);
		w.setYPositionMode(WidgetPositionMode.ABSOLUTE_TOP);
		w.revalidate();
		cornersAndEdges.add(w);
	}

	private Widget createWidgetWithText()
	{
		Widget textWidget = this.parent.createChild(-1, WidgetType.TEXT);
		textWidget.setOriginalX(6);
		textWidget.setOriginalY(6);
		textWidget.setOriginalWidth(100);
		textWidget.setOriginalHeight(23);
		textWidget.setXPositionMode(WidgetPositionMode.ABSOLUTE_LEFT);
		textWidget.setYPositionMode(WidgetPositionMode.ABSOLUTE_TOP);
		textWidget.setXTextAlignment(WidgetTextAlignment.CENTER);
		textWidget.setYTextAlignment(WidgetTextAlignment.CENTER);
		textWidget.setText("<col=9f9f9f>" + "Sync WOM Group" + "</col>");
		textWidget.setFontId(FontID.PLAIN_11);
		textWidget.setTextShadowed(true);

		textWidget.setHasListener(true);
		textWidget.setAction(0, "Sync WOM Group");
		textWidget.setOnMouseOverListener((JavaScriptCallback) e -> update(true));
		textWidget.setOnMouseLeaveListener((JavaScriptCallback) e -> update(false));

		textWidget.revalidate();

		return textWidget;
	}

	private void update(boolean hovered)
	{
		for (Widget w : cornersAndEdges)
		{
			int spriteId = w.getSpriteId();
			w.setSpriteId(hovered ? spriteId + 8 : spriteId - 8);
			w.revalidate();
		}
	}

	private void syncMembers()
	{
		syncMembers(true);
	}

	private void syncMembers(boolean overwrite)
	{
		Map<String, Member> clanMembers = new HashMap<>();

		if (!overwrite)
		{
			groupMembers.forEach((k, v) -> clanMembers.put(k, new Member(v.getPlayer().getDisplayName(), v.getRole())));
		}

		for (ClanMember clanMember : clanSettings.getMembers())
		{
			if (clanMember.getName().startsWith("[#"))
			{
				continue;
			}

			String memberName = Text.toJagexName(clanMember.getName());
			ClanTitle memberTitle = clanSettings.titleForRank(clanMember.getRank());

			String role = memberTitle == null ? "member" : memberTitle.getName().toLowerCase().replaceAll("[-\\s]", "_");

			if (memberTitle != null)
			{
				int roleIndex = roleOrder.indexOf(clanMember.getRank());
				roleOrders.add(new RoleIndex(role, roleIndex));
			}

			if (ignoredRanks.contains(role))
			{
				continue;
			}

			clanMembers.put(memberName.toLowerCase(), new Member(memberName, role));
		}

		for (String name : alwaysIncludedOnSync)
		{
			String nameLower = name.toLowerCase();
			if (!clanMembers.containsKey(nameLower))
			{
				clanMembers.put(nameLower, new Member(name, "member"));
			}
		}

		womClient.syncClanMembers(new ArrayList<>(clanMembers.values()), roleOrders);
	}

	public void setEnabled()
	{
		this.textWidget.setText("<col=ffffff>" + "Sync WOM Group" + "</col>");
		textWidget.setOnOpListener((JavaScriptCallback) e -> {
			List<ClanMember> currentClanMembers = clanSettings.getMembers();
			if (!plugin.isSameClan(currentClanMembers.stream().filter(clanMember -> {
				ClanTitle clanTitle = clanSettings.titleForRank(clanMember.getRank());
				return clanTitle == null || !ignoredRanks.contains(clanTitle.getName().toLowerCase().replaceAll("[-\\s]", "_"));
			}).map(clanMember -> Text.toJagexName(clanMember.getName()).toLowerCase()).collect(Collectors.toSet()), groupMembers.keySet(), plugin.SAME_CLAN_TOLERANCE))

			{
				chatboxPanelManager.openTextMenuInput(
						"<br>WARNING!" +
							"<br>The clan you are trying to sync might not<br>be the same clan previously synced to this group.")
					.option("<br>1. Cancel", Runnables.doNothing())
					.option("2. I understand", this::showSyncOptions)
					.build();
			}
			else
			{
				showSyncOptions();
			}
		});
	}

	private void showSyncOptions()
	{
		chatboxPanelManager.openTextMenuInput(
				"Any members not in your clan will be removed" +
					"<br>from your WOM group. Proceed?")
			.option("1. Yes, overwrite WOM group", () -> clientThread.invoke(() -> syncMembers()))
			.option("2. No, only add new members", () -> clientThread.invoke(() -> syncMembers(false)))
			.option("3. Cancel", Runnables.doNothing())
			.build();
	}
}

package net.wiseoldman.ui;

import com.google.common.collect.ImmutableMap;
import net.wiseoldman.WomUtilsPlugin;
import java.util.Map;
import lombok.AllArgsConstructor;
import net.runelite.client.util.ImageUtil;

import javax.swing.*;

@AllArgsConstructor
public enum CountryIcon
{
	AFGHANISTAN("af", "1f1e6-1f1eb"),
	ALBANIA("al", "1f1e6-1f1f1"),
	ALGERIA("dz", "1f1e9-1f1ff"),
	AMERICAN_SAMOA("as", "1f1e6-1f1f8"),
	ANDORRA("ad", "1f1e6-1f1e9"),
	ANGOLA("ao", "1f1e6-1f1f4"),
	ANGUILLA("ai", "1f1e6-1f1ee"),
	ANTARCTICA("aq", "1f1e6-1f1f6"),
	ANTIGUA_AND_BARBUDA("ag", "1f1e6-1f1ec"),
	ARGENTINA("ar", "1f1e6-1f1f7"),
	ARMENIA("am", "1f1e6-1f1f2"),
	ARUBA("aw", "1f1e6-1f1fc"),
	ASCENSION_ISLAND("ac", "1f1e6-1f1e8"),
	AUSTRALIA("au", "1f1e6-1f1fa"),
	AUSTRIA("at", "1f1e6-1f1f9"),
	AZERBAIJAN("az", "1f1e6-1f1ff"),
	BAHAMAS("bs", "1f1e7-1f1f8"),
	BAHRAIN("bh", "1f1e7-1f1ed"),
	BANGLADESH("bd", "1f1e7-1f1e9"),
	BARBADOS("bb", "1f1e7-1f1e7"),
	BELARUS("by", "1f1e7-1f1fe"),
	BELGIUM("be", "1f1e7-1f1ea"),
	BELIZE("bz", "1f1e7-1f1ff"),
	BENIN("bj", "1f1e7-1f1ef"),
	BERMUDA("bm", "1f1e7-1f1f2"),
	BHUTAN("bt", "1f1e7-1f1f9"),
	BOLIVIA("bo", "1f1e7-1f1f4"),
	BOSNIA_AND_HERZEGOVINA("ba", "1f1e7-1f1e6"),
	BOTSWANA("bw", "1f1e7-1f1fc"),
	BOUVET_ISLAND("bv", "1f1e7-1f1fb"),
	BRAZIL("br", "1f1e7-1f1f7"),
	BRITISH_INDIAN_OCEAN_TERRITORY("io", "1f1ee-1f1f4"),
	BRITISH_VIRGIN_ISLANDS("vg", "1f1fb-1f1ec"),
	BRUNEI("bn", "1f1e7-1f1f3"),
	BULGARIA("bg", "1f1e7-1f1ec"),
	BURKINA_FASO("bf", "1f1e7-1f1eb"),
	BURUNDI("bi", "1f1e7-1f1ee"),
	CAMBODIA("kh", "1f1f0-1f1ed"),
	CAMEROON("cm", "1f1e8-1f1f2"),
	CANADA("ca", "1f1e8-1f1e6"),
	CANARY_ISLANDS("ic", "1f1ee-1f1e8"),
	CAPE_VERDE("cv", "1f1e8-1f1fb"),
	CARIBBEAN_NETHERLANDS("bq", "1f1e7-1f1f6"),
	CAYMAN_ISLANDS("ky", "1f1f0-1f1fe"),
	CENTRAL_AFRICAN_REPUBLIC("cf", "1f1e8-1f1eb"),
	CEUTA_AND_MELILLA("ea", "1f1ea-1f1e6"),
	CHAD("td", "1f1f9-1f1e9"),
	CHILE("cl", "1f1e8-1f1f1"),
	CHINA("cn", "1f1e8-1f1f3"),
	CHRISTMAS_ISLAND("cx", "1f1e8-1f1fd"),
	CLIPPERTON_ISLAND("cp", "1f1e8-1f1f5"),
	COCOS_KEELING_ISLANDS("cc", "1f1e8-1f1e8"),
	COLOMBIA("co", "1f1e8-1f1f4"),
	COMOROS("km", "1f1f0-1f1f2"),
	CONGO__BRAZZAVILLE("cg", "1f1e8-1f1ec"),
	CONGO__KINSHASA("cd", "1f1e8-1f1e9"),
	COOK_ISLANDS("ck", "1f1e8-1f1f0"),
	COSTA_RICA("cr", "1f1e8-1f1f7"),
	CROATIA("hr", "1f1ed-1f1f7"),
	CUBA("cu", "1f1e8-1f1fa"),
	CURAÇAO("cw", "1f1e8-1f1fc"),
	CYPRUS("cy", "1f1e8-1f1fe"),
	CZECH_REPUBLIC("cz", "1f1e8-1f1ff"),
	CÔTE_DIVOIRE("ci", "1f1e8-1f1ee"),
	DENMARK("dk", "1f1e9-1f1f0"),
	DIEGO_GARCIA("dg", "1f1e9-1f1ec"),
	DJIBOUTI("dj", "1f1e9-1f1ef"),
	DOMINICA("dm", "1f1e9-1f1f2"),
	DOMINICAN_REPUBLIC("do", "1f1e9-1f1f4"),
	ECUADOR("ec", "1f1ea-1f1e8"),
	EGYPT("eg", "1f1ea-1f1ec"),
	EL_SALVADOR("sv", "1f1f8-1f1fb"),
	EQUATORIAL_GUINEA("gq", "1f1ec-1f1f6"),
	ERITREA("er", "1f1ea-1f1f7"),
	ESTONIA("ee", "1f1ea-1f1ea"),
	ETHIOPIA("et", "1f1ea-1f1f9"),
	EUROPEAN_UNION("eu", "1f1ea-1f1fa"),
	FALKLAND_ISLANDS("fk", "1f1eb-1f1f0"),
	FAROE_ISLANDS("fo", "1f1eb-1f1f4"),
	FIJI("fj", "1f1eb-1f1ef"),
	FINLAND("fi", "1f1eb-1f1ee"),
	FRANCE("fr", "1f1eb-1f1f7"),
	FRENCH_GUIANA("gf", "1f1ec-1f1eb"),
	FRENCH_POLYNESIA("pf", "1f1f5-1f1eb"),
	FRENCH_SOUTHERN_TERRITORIES("tf", "1f1f9-1f1eb"),
	GABON("ga", "1f1ec-1f1e6"),
	GAMBIA("gm", "1f1ec-1f1f2"),
	GEORGIA("ge", "1f1ec-1f1ea"),
	GERMANY("de", "1f1e9-1f1ea"),
	GHANA("gh", "1f1ec-1f1ed"),
	GIBRALTAR("gi", "1f1ec-1f1ee"),
	GREECE("gr", "1f1ec-1f1f7"),
	GREENLAND("gl", "1f1ec-1f1f1"),
	GRENADA("gd", "1f1ec-1f1e9"),
	GUADELOUPE("gp", "1f1ec-1f1f5"),
	GUAM("gu", "1f1ec-1f1fa"),
	GUATEMALA("gt", "1f1ec-1f1f9"),
	GUERNSEY("gg", "1f1ec-1f1ec"),
	GUINEA("gn", "1f1ec-1f1f3"),
	GUINEABISSAU("gw", "1f1ec-1f1fc"),
	GUYANA("gy", "1f1ec-1f1fe"),
	HAITI("ht", "1f1ed-1f1f9"),
	HEARD_AND_MCDONALD_ISLANDS("hm", "1f1ed-1f1f2"),
	HONDURAS("hn", "1f1ed-1f1f3"),
	HONG_KONG_SAR_CHINA("hk", "1f1ed-1f1f0"),
	HUNGARY("hu", "1f1ed-1f1fa"),
	ICELAND("is", "1f1ee-1f1f8"),
	INDIA("in", "1f1ee-1f1f3"),
	INDONESIA("id", "1f1ee-1f1e9"),
	IRAN("ir", "1f1ee-1f1f7"),
	IRAQ("iq", "1f1ee-1f1f6"),
	IRELAND("ie", "1f1ee-1f1ea"),
	ISLE_OF_MAN("im", "1f1ee-1f1f2"),
	ISRAEL("il", "1f1ee-1f1f1"),
	ITALY("it", "1f1ee-1f1f9"),
	JAMAICA("jm", "1f1ef-1f1f2"),
	JAPAN_FLAG("jp", "1f1ef-1f1f5"),
	JERSEY("je", "1f1ef-1f1ea"),
	JORDAN("jo", "1f1ef-1f1f4"),
	KAZAKHSTAN("kz", "1f1f0-1f1ff"),
	KENYA("ke", "1f1f0-1f1ea"),
	KIRIBATI("ki", "1f1f0-1f1ee"),
	KOSOVO("xk", "1f1fd-1f1f0"),
	KUWAIT("kw", "1f1f0-1f1fc"),
	KYRGYZSTAN("kg", "1f1f0-1f1ec"),
	LAOS("la", "1f1f1-1f1e6"),
	LATVIA("lv", "1f1f1-1f1fb"),
	LEBANON("lb", "1f1f1-1f1e7"),
	LESOTHO("ls", "1f1f1-1f1f8"),
	LIBERIA("lr", "1f1f1-1f1f7"),
	LIBYA("ly", "1f1f1-1f1fe"),
	LIECHTENSTEIN("li", "1f1f1-1f1ee"),
	LITHUANIA("lt", "1f1f1-1f1f9"),
	LUXEMBOURG("lu", "1f1f1-1f1fa"),
	MACAU_SAR_CHINA("mo", "1f1f2-1f1f4"),
	MACEDONIA("mk", "1f1f2-1f1f0"),
	MADAGASCAR("mg", "1f1f2-1f1ec"),
	MALAWI("mw", "1f1f2-1f1fc"),
	MALAYSIA("my", "1f1f2-1f1fe"),
	MALDIVES("mv", "1f1f2-1f1fb"),
	MALI("ml", "1f1f2-1f1f1"),
	MALTA("mt", "1f1f2-1f1f9"),
	MARSHALL_ISLANDS("mh", "1f1f2-1f1ed"),
	MARTINIQUE("mq", "1f1f2-1f1f6"),
	MAURITANIA("mr", "1f1f2-1f1f7"),
	MAURITIUS("mu", "1f1f2-1f1fa"),
	MAYOTTE("yt", "1f1fe-1f1f9"),
	MEXICO("mx", "1f1f2-1f1fd"),
	MICRONESIA("fm", "1f1eb-1f1f2"),
	MOLDOVA("md", "1f1f2-1f1e9"),
	MONACO("mc", "1f1f2-1f1e8"),
	MONGOLIA("mn", "1f1f2-1f1f3"),
	MONTENEGRO("me", "1f1f2-1f1ea"),
	MONTSERRAT("ms", "1f1f2-1f1f8"),
	MOROCCO("ma", "1f1f2-1f1e6"),
	MOZAMBIQUE("mz", "1f1f2-1f1ff"),
	MYANMAR_BURMA("mm", "1f1f2-1f1f2"),
	NAMIBIA("na", "1f1f3-1f1e6"),
	NAURU("nr", "1f1f3-1f1f7"),
	NEPAL("np", "1f1f3-1f1f5"),
	NETHERLANDS("nl", "1f1f3-1f1f1"),
	NEW_CALEDONIA("nc", "1f1f3-1f1e8"),
	NEW_ZEALAND("nz", "1f1f3-1f1ff"),
	NICARAGUA("ni", "1f1f3-1f1ee"),
	NIGER("ne", "1f1f3-1f1ea"),
	NIGERIA("ng", "1f1f3-1f1ec"),
	NIUE("nu", "1f1f3-1f1fa"),
	NORFOLK_ISLAND("nf", "1f1f3-1f1eb"),
	NORTHERN_IRELAND("gb_nir", "1f1ec-1f1e7"),
	NORTH_KOREA("kp", "1f1f0-1f1f5"),
	NORTHERN_MARIANA_ISLANDS("mp", "1f1f2-1f1f5"),
	NORWAY("no", "1f1f3-1f1f4"),
	OMAN("om", "1f1f4-1f1f2"),
	PAKISTAN("pk", "1f1f5-1f1f0"),
	PALAU("pw", "1f1f5-1f1fc"),
	PALESTINIAN_TERRITORIES("ps", "1f1f5-1f1f8"),
	PANAMA("pa", "1f1f5-1f1e6"),
	PAPUA_NEW_GUINEA("pg", "1f1f5-1f1ec"),
	PARAGUAY("py", "1f1f5-1f1fe"),
	PERU("pe", "1f1f5-1f1ea"),
	PHILIPPINES("ph", "1f1f5-1f1ed"),
	PITCAIRN_ISLANDS("pn", "1f1f5-1f1f3"),
	POLAND("pl", "1f1f5-1f1f1"),
	PORTUGAL("pt", "1f1f5-1f1f9"),
	PUERTO_RICO("pr", "1f1f5-1f1f7"),
	QATAR("qa", "1f1f6-1f1e6"),
	ROMANIA("ro", "1f1f7-1f1f4"),
	RUSSIA("ru", "1f1f7-1f1fa"),
	RWANDA("rw", "1f1f7-1f1fc"),
	RÉUNION("re", "1f1f7-1f1ea"),
	SAMOA("ws", "1f1fc-1f1f8"),
	SAN_MARINO("sm", "1f1f8-1f1f2"),
	SAUDI_ARABIA("sa", "1f1f8-1f1e6"),
	SENEGAL("sn", "1f1f8-1f1f3"),
	SERBIA("rs", "1f1f7-1f1f8"),
	SEYCHELLES("sc", "1f1f8-1f1e8"),
	SIERRA_LEONE("sl", "1f1f8-1f1f1"),
	SINGAPORE("sg", "1f1f8-1f1ec"),
	SINT_MAARTEN("sx", "1f1f8-1f1fd"),
	SLOVAKIA("sk", "1f1f8-1f1f0"),
	SLOVENIA("si", "1f1f8-1f1ee"),
	SOLOMON_ISLANDS("sb", "1f1f8-1f1e7"),
	SOMALIA("so", "1f1f8-1f1f4"),
	SOUTH_AFRICA("za", "1f1ff-1f1e6"),
	SOUTH_GEORGIA_AND_SOUTH_SANDWICH_ISLANDS("gs", "1f1ec-1f1f8"),
	SOUTH_KOREA("kr", "1f1f0-1f1f7"),
	SOUTH_SUDAN("ss", "1f1f8-1f1f8"),
	SPAIN("es", "1f1ea-1f1f8"),
	SRI_LANKA("lk", "1f1f1-1f1f0"),
	SCOTLAND("gb_sct", "1f3f4-e0067-e0062-e0073-e0063-e0074-e007f"),
	ST_BARTHÉLEMY("bl", "1f1e7-1f1f1"),
	ST_HELENA("sh", "1f1f8-1f1ed"),
	ST_KITTS_AND_NEVIS("kn", "1f1f0-1f1f3"),
	ST_LUCIA("lc", "1f1f1-1f1e8"),
	ST_MARTIN("mf", "1f1f2-1f1eb"),
	ST_PIERRE_AND_MIQUELON("pm", "1f1f5-1f1f2"),
	ST_VINCENT_AND_GRENADINES("vc", "1f1fb-1f1e8"),
	SUDAN("sd", "1f1f8-1f1e9"),
	SURINAME("sr", "1f1f8-1f1f7"),
	SVALBARD_AND_JAN_MAYEN("sj", "1f1f8-1f1ef"),
	SWAZILAND("sz", "1f1f8-1f1ff"),
	SWEDEN("se", "1f1f8-1f1ea"),
	SWITZERLAND("ch", "1f1e8-1f1ed"),
	SYRIA("sy", "1f1f8-1f1fe"),
	SÃO_TOMÉ_AND_PRÍ­NCIPE("st", "1f1f8-1f1f9"),
	TAIWAN("tw", "1f1f9-1f1fc"),
	TAJIKISTAN("tj", "1f1f9-1f1ef"),
	TANZANIA("tz", "1f1f9-1f1ff"),
	THAILAND("th", "1f1f9-1f1ed"),
	TIMORLESTE("tl", "1f1f9-1f1f1"),
	TOGO("tg", "1f1f9-1f1ec"),
	TOKELAU("tk", "1f1f9-1f1f0"),
	TONGA("to", "1f1f9-1f1f4"),
	TRINIDAD_AND_TOBAGO("tt", "1f1f9-1f1f9"),
	TRISTAN_DA_CUNHA("ta", "1f1f9-1f1e6"),
	TUNISIA("tn", "1f1f9-1f1f3"),
	TURKEY_FLAG("tr", "1f1f9-1f1f7"),
	TURKMENISTAN("tm", "1f1f9-1f1f2"),
	TURKS_AND_CAICOS_ISLANDS("tc", "1f1f9-1f1e8"),
	TUVALU("tv", "1f1f9-1f1fb"),
	US_OUTLYING_ISLANDS("um", "1f1fa-1f1f2"),
	US_VIRGIN_ISLANDS("vi", "1f1fb-1f1ee"),
	UGANDA("ug", "1f1fa-1f1ec"),
	UKRAINE("ua", "1f1fa-1f1e6"),
	UNITED_ARAB_EMIRATES("ae", "1f1e6-1f1ea"),
	UNITED_KINGDOM("gb", "1f1ec-1f1e7"),
	UNITED_STATES("us", "1f1fa-1f1f8"),
	URUGUAY("uy", "1f1fa-1f1fe"),
	UZBEKISTAN("uz", "1f1fa-1f1ff"),
	VANUATU("vu", "1f1fb-1f1fa"),
	VATICAN_CITY("va", "1f1fb-1f1e6"),
	VENEZUELA("ve", "1f1fb-1f1ea"),
	VIETNAM("vn", "1f1fb-1f1f3"),
	WALES("gb_wls", "1f3f4-e0067-e0062-e0077-e006c-e0073-e007f"),
	WALLIS_AND_FUTUNA("wf", "1f1fc-1f1eb"),
	WESTERN_SAHARA("eh", "1f1ea-1f1ed"),
	YEMEN("ye", "1f1fe-1f1ea"),
	ZAMBIA("zm", "1f1ff-1f1f2"),
	ZIMBABWE("zw", "1f1ff-1f1fc"),
	DEFAULT("default", "default");
	private final String languageCode;
	private final String codepoint;

	public static final int ICON_WIDTH = 12;
	private static final Map<String, CountryIcon> ICONS;

	static
	{
		ImmutableMap.Builder<String, CountryIcon> iconBuilder = new ImmutableMap.Builder<>();

		for (final CountryIcon icon : values())
		{
			iconBuilder.put(icon.languageCode, icon);
		}

		ICONS = iconBuilder.build();
	}

	public static ImageIcon loadSquareImage(String languageCode)
	{
		try
		{
			return new ImageIcon(ImageUtil.loadImageResource(WomUtilsPlugin.class, "flags_square/" + ICONS.get(languageCode).codepoint + ".png"));
		}
		catch (Exception e)
		{
			return new ImageIcon(ImageUtil.loadImageResource(WomUtilsPlugin.class, "flags_square/default.png"));
		}
	}
}

package net.wiseoldman.ui;

import com.google.common.base.Strings;
import net.wiseoldman.WomUtilsConfig;
import net.wiseoldman.WomUtilsPlugin;
import java.awt.Dimension;
import java.awt.Graphics2D;
import java.time.Instant;
import java.time.ZoneOffset;
import java.time.format.DateTimeFormatter;
import javax.inject.Inject;
import net.runelite.client.ui.overlay.OverlayPanel;
import net.runelite.client.ui.overlay.OverlayPosition;
import net.runelite.client.ui.overlay.components.LineComponent;
import net.runelite.client.ui.overlay.components.TitleComponent;

public class CodeWordOverlay extends OverlayPanel
{
	private final WomUtilsConfig config;
	private static final DateTimeFormatter FORMATTER = DateTimeFormatter.ofPattern("dd/MM/yyyy HH:mm 'UTC'")
		.withZone(ZoneOffset.UTC);

	@Inject
	private CodeWordOverlay(WomUtilsPlugin plugin, WomUtilsConfig config)
	{
		super(plugin);
		setPosition(OverlayPosition.ABOVE_CHATBOX_RIGHT);
		setPriority(PRIORITY_LOW);
		this.config = config;
	}

	@Override
	public Dimension render(Graphics2D graphics)
	{
		if (!config.displayCodeword() || Strings.isNullOrEmpty(config.configuredCodeword()))
		{
			return null;
		}
		if (config.showTimestamp())
		{
			panelComponent.getChildren().add(LineComponent.builder()
				.left(config.configuredCodeword())
				.leftColor(config.codewordColor())
				.right(FORMATTER.format(Instant.now()))
				.rightColor(config.timestampColor())
				.build());
		}
		else
		{
			panelComponent.getChildren().add(TitleComponent.builder()
				.text(config.configuredCodeword())
				.color(config.codewordColor())
				.build());
		}
		return super.render(graphics);
	}
}

package net.wiseoldman.beans;

import lombok.Data;

@Data
public class CompetitionProgress
{
	double start;
	double end;
	double gained;
}

package net.wiseoldman.beans;

import lombok.Value;

@Value
public class RoleIndex
{
	String role;
	int index;
}

package net.wiseoldman.beans;

import java.time.Duration;
import java.time.Instant;
import java.util.Date;
import lombok.Data;
import org.apache.commons.lang3.time.DurationFormatUtils;

@Data
public class Competition
{
	int id;
	String title;
	Metric metric;
	CompetitionType type;
	Date startsAt;
	Date endsAt;
	int groupId;
	int score;
	Date createdAt;
	Date updatedAt;
	GroupInfo group;
	int participantCount;

	public boolean isActive()
	{
		return hasStarted() && !hasEnded();
	}

	public boolean hasEnded()
	{
		return endsAt.before(new Date());
	}

	public boolean hasStarted()
	{
		return startsAt.before(new Date());
	}

	public Duration durationLeft()
	{
		if (isActive())
		{
			return Duration.between(Instant.now(), endsAt.toInstant());
		}
		else if (!hasStarted())
		{
			return Duration.between(Instant.now(), startsAt.toInstant());
		}
		else
		{
			return Duration.ZERO;
		}
	}

	private String durationLeftPretty()
	{
		return DurationFormatUtils.formatDurationWords(durationLeft().toMillis(), true, true)
			.replaceAll(" days?", "d")
			.replaceAll(" hours?", "h")
			.replaceAll(" minutes?", "m")
			.replaceAll(" seconds?", "s");
	}

	public String getStatus()
	{
		StringBuilder sb = new StringBuilder();
		sb.append("Competition: ").append(title).append(" ");
		if (isActive())
		{
			sb.append("ends in ").append(durationLeftPretty());
		}
		else if (!hasStarted())
		{
			sb.append("starts in ").append(durationLeftPretty());
		}

		return sb.toString();
	}

	public String getTimeStatus()
	{
		StringBuilder sb = new StringBuilder();

		if (isActive())
		{
			sb.append("Ends in ").append(durationLeftPretty());
		}
		else if (!hasStarted())
		{
			sb.append("Starts in ").append(durationLeftPretty());
		}
		else
		{
			sb.append("Ended");
		}
		return sb.toString();
	}
}

package net.wiseoldman.beans;

import lombok.Data;
import lombok.EqualsAndHashCode;

@EqualsAndHashCode(callSuper = true)
@Data
public class CompetitionInfo extends Competition
{
	Participant[] participations;
}

package net.wiseoldman.beans;

import java.util.Date;
import lombok.Data;

@Data
public class ParticipantWithStanding
{
	int playerId;
	int competitionId;
	String teamName;
	Date createdAt;
	Date updatedAt;
	CompetitionProgress progress;
	int rank;
	Competition competition;
}

package net.wiseoldman.beans;

import lombok.Value;

@Value
public class NameChangeEntry
{
	String oldName;
	String newName;
}

package net.wiseoldman.beans;

import lombok.Value;

@Value
public class ParticipantWithCompetition
{
    int playerId;
    int competitionId;
    String teamName;
    String createdAt;
    String updatedAt;
    Competition competition;
}

package net.wiseoldman.beans;

import lombok.Data;

@Data
public class GroupInfo
{
    int id;
    String name;
    String clanChat;
    String description;
    int homeworld;
    boolean verified;
    int score;
    String createdAt;
    String updatedAt;
    int memberCount;
}

package net.wiseoldman.beans;

import lombok.Value;

@Value
public class Snapshot
{
	int id;
	int playerId;
	String createdAt;
	String importedAt;
	SnapshotData data;
}

package net.wiseoldman.beans;

import lombok.Value;

@Value
public class SnapshotComputed
{
    Computed ehp;
    Computed ehb;
}

package net.wiseoldman.beans;

import lombok.Value;
import net.runelite.client.hiscore.HiscoreSkill;

@Value
public class SnapshotSkills
{
    Skill overall;
    Skill attack;
    Skill defence;
    Skill strength;
    Skill hitpoints;
    Skill ranged;
    Skill prayer;
    Skill magic;
    Skill cooking;
    Skill woodcutting;
    Skill fletching;
    Skill fishing;
    Skill firemaking;
    Skill crafting;
    Skill smithing;
    Skill mining;
    Skill herblore;
    Skill agility;
    Skill thieving;
    Skill slayer;
    Skill farming;
    Skill runecrafting;
    Skill hunter;
    Skill construction;

    public Skill getSkill(HiscoreSkill skill)
    {
        switch (skill)
        {
            case ATTACK:
                return getAttack();
            case DEFENCE:
                return getDefence();
            case STRENGTH:
                return getStrength();
            case HITPOINTS:
                return getHitpoints();
            case RANGED:
                return getRanged();
            case PRAYER:
                return getPrayer();
            case MAGIC:
                return getMagic();
            case COOKING:
                return getCooking();
            case WOODCUTTING:
                return getWoodcutting();
            case FLETCHING:
                return getFletching();
            case FISHING:
                return getFishing();
            case FIREMAKING:
                return getFiremaking();
            case CRAFTING:
                return getCrafting();
            case SMITHING:
                return getSmithing();
            case MINING:
                return getMining();
            case HERBLORE:
                return getHerblore();
            case AGILITY:
                return getAgility();
            case THIEVING:
                return getThieving();
            case SLAYER:
                return getSlayer();
            case FARMING:
                return getFarming();
            case RUNECRAFT:
                return getRunecrafting();
            case HUNTER:
                return getHunter();
            case CONSTRUCTION:
                return getConstruction();
            case OVERALL:
                return getOverall();
            default:
                throw new IllegalArgumentException("Invalid hiscore skill");
        }
    }
}
package net.wiseoldman.beans;

import lombok.Value;

@Value
public class Skill
{
	String metric;
	long experience;
	int rank;
	int level;
	double ehp;
}

package net.wiseoldman.beans;

import lombok.Value;

@Value
public class Activity
{
	String metric;
	int score;
	int rank;
}

package net.wiseoldman.beans;

import com.google.gson.annotations.SerializedName;
import net.wiseoldman.WomUtilsPlugin;
import java.awt.image.BufferedImage;
import lombok.AllArgsConstructor;
import lombok.Getter;
import net.runelite.client.util.ImageUtil;
import net.runelite.client.hiscore.HiscoreSkill;
import net.runelite.client.hiscore.HiscoreSkillType;

@AllArgsConstructor
public enum Metric
{
	@SerializedName("abyssal_sire")
	ABYSSAL_SIRE(HiscoreSkill.ABYSSAL_SIRE),
	@SerializedName("agility")
	AGILITY(HiscoreSkill.AGILITY),
	@SerializedName("alchemical_hydra")
	ALCHEMICAL_HYDRA(HiscoreSkill.ALCHEMICAL_HYDRA),
	@SerializedName("amoxliatl")
	AMOXLIATL(HiscoreSkill.AMOXLIATL),
	@SerializedName("araxxor")
	ARAXXOR(HiscoreSkill.ARAXXOR),
	@SerializedName("artio")
	ARTIO(HiscoreSkill.ARTIO),
	@SerializedName("attack")
	ATTACK(HiscoreSkill.ATTACK),
	@SerializedName("barrows_chests")
	BARROWS_CHESTS(HiscoreSkill.BARROWS_CHESTS),
	@SerializedName("bounty_hunter_hunter")
	BOUNTY_HUNTER_HUNTER(HiscoreSkill.BOUNTY_HUNTER_HUNTER),
	@SerializedName("bounty_hunter_rogue")
	BOUNTY_HUNTER_ROGUE(HiscoreSkill.BOUNTY_HUNTER_ROGUE),
	@SerializedName("bryophyta")
	BRYOPHYTA(HiscoreSkill.BRYOPHYTA),
	@SerializedName("callisto")
	CALLISTO(HiscoreSkill.CALLISTO),
	@SerializedName("calvarion")
	CALVARION(HiscoreSkill.CALVARION),
	@SerializedName("cerberus")
	CERBERUS(HiscoreSkill.CERBERUS),
	@SerializedName("chambers_of_xeric_challenge_mode")
	CHAMBERS_OF_XERIC_CHALLENGE_MODE(HiscoreSkill.CHAMBERS_OF_XERIC_CHALLENGE_MODE),
	@SerializedName("chambers_of_xeric")
	CHAMBERS_OF_XERIC(HiscoreSkill.CHAMBERS_OF_XERIC),
	@SerializedName("chaos_elemental")
	CHAOS_ELEMENTAL(HiscoreSkill.CHAOS_ELEMENTAL),
	@SerializedName("chaos_fanatic")
	CHAOS_FANATIC(HiscoreSkill.CHAOS_FANATIC),
	@SerializedName("clue_scrolls_all")
	CLUE_SCROLLS_ALL(HiscoreSkill.CLUE_SCROLL_ALL),
	@SerializedName("clue_scrolls_beginner")
	CLUE_SCROLLS_BEGINNER(HiscoreSkill.CLUE_SCROLL_BEGINNER),
	@SerializedName("clue_scrolls_easy")
	CLUE_SCROLLS_EASY(HiscoreSkill.CLUE_SCROLL_EASY),
	@SerializedName("clue_scrolls_elite")
	CLUE_SCROLLS_ELITE(HiscoreSkill.CLUE_SCROLL_ELITE),
	@SerializedName("clue_scrolls_hard")
	CLUE_SCROLLS_HARD(HiscoreSkill.CLUE_SCROLL_HARD),
	@SerializedName("clue_scrolls_master")
	CLUE_SCROLLS_MASTER(HiscoreSkill.CLUE_SCROLL_MASTER),
	@SerializedName("clue_scrolls_medium")
	CLUE_SCROLLS_MEDIUM(HiscoreSkill.CLUE_SCROLL_MEDIUM),
	@SerializedName("commander_zilyana")
	COMMANDER_ZILYANA(HiscoreSkill.COMMANDER_ZILYANA),
	@SerializedName("colosseum_glory")
	COLOSSEUM_GLORY(HiscoreSkill.COLOSSEUM_GLORY),
	@SerializedName("collections_logged")
	COLLECTIONS_LOGGED(HiscoreSkill.COLLECTIONS_LOGGED),
	@SerializedName("construction")
	CONSTRUCTION(HiscoreSkill.CONSTRUCTION),
	@SerializedName("cooking")
	COOKING(HiscoreSkill.COOKING),
	@SerializedName("corporeal_beast")
	CORPOREAL_BEAST(HiscoreSkill.CORPOREAL_BEAST),
	@SerializedName("crafting")
	CRAFTING(HiscoreSkill.CRAFTING),
	@SerializedName("crazy_archaeologist")
	CRAZY_ARCHAEOLOGIST(HiscoreSkill.CRAZY_ARCHAEOLOGIST),
	@SerializedName("dagannoth_prime")
	DAGANNOTH_PRIME(HiscoreSkill.DAGANNOTH_PRIME),
	@SerializedName("dagannoth_rex")
	DAGANNOTH_REX(HiscoreSkill.DAGANNOTH_REX),
	@SerializedName("dagannoth_supreme")
	DAGANNOTH_SUPREME(HiscoreSkill.DAGANNOTH_SUPREME),
	@SerializedName("defence")
	DEFENCE(HiscoreSkill.DEFENCE),
	@SerializedName("deranged_archaeologist")
	DERANGED_ARCHAEOLOGIST(HiscoreSkill.DERANGED_ARCHAEOLOGIST),
	@SerializedName("doom_of_mokhaiotl")
	DOOM_OF_MOKHAIOTL(HiscoreSkill.DOOM_OF_MOKHAIOTL),
	@SerializedName("duke_sucellus")
	DUKE_SUCELLUS(HiscoreSkill.DUKE_SUCELLUS),
	@SerializedName("ehb")
	EHB(null),
	@SerializedName("ehp")
	EHP(null),
	@SerializedName("farming")
	FARMING(HiscoreSkill.FARMING),
	@SerializedName("firemaking")
	FIREMAKING(HiscoreSkill.FIREMAKING),
	@SerializedName("fishing")
	FISHING(HiscoreSkill.FISHING),
	@SerializedName("fletching")
	FLETCHING(HiscoreSkill.FLETCHING),
	@SerializedName("general_graardor")
	GENERAL_GRAARDOR(HiscoreSkill.GENERAL_GRAARDOR),
	@SerializedName("giant_mole")
	GIANT_MOLE(HiscoreSkill.GIANT_MOLE),
	@SerializedName("grotesque_guardians")
	GROTESQUE_GUARDIANS(HiscoreSkill.GROTESQUE_GUARDIANS),
	@SerializedName("guardians_of_the_rift")
	GUARDIANS_OF_THE_RIFT(HiscoreSkill.RIFTS_CLOSED),
	@SerializedName("herblore")
	HERBLORE(HiscoreSkill.HERBLORE),
	@SerializedName("hespori")
	HESPORI(HiscoreSkill.HESPORI),
	@SerializedName("hitpoints")
	HITPOINTS(HiscoreSkill.HITPOINTS),
	@SerializedName("hunter")
	HUNTER(HiscoreSkill.HUNTER),
	@SerializedName("kalphite_queen")
	KALPHITE_QUEEN(HiscoreSkill.KALPHITE_QUEEN),
	@SerializedName("king_black_dragon")
	KING_BLACK_DRAGON(HiscoreSkill.KING_BLACK_DRAGON),
	@SerializedName("kraken")
	KRAKEN(HiscoreSkill.KRAKEN),
	@SerializedName("kreearra")
	KREEARRA(HiscoreSkill.KREEARRA),
	@SerializedName("kril_tsutsaroth")
	KRIL_TSUTSAROTH(HiscoreSkill.KRIL_TSUTSAROTH),
	@SerializedName("last_man_standing")
	LAST_MAN_STANDING(HiscoreSkill.LAST_MAN_STANDING),
	@SerializedName("lunar_chests")
	LUNAR_CHESTS(HiscoreSkill.LUNAR_CHESTS),
	@SerializedName("pvp_arena")
	PVP_ARENA(HiscoreSkill.PVP_ARENA_RANK),
	@SerializedName("league_points")
	LEAGUE_POINTS(HiscoreSkill.LEAGUE_POINTS),
	@SerializedName("magic")
	MAGIC(HiscoreSkill.MAGIC),
	@SerializedName("mimic")
	MIMIC(HiscoreSkill.MIMIC),
	@SerializedName("mining")
	MINING(HiscoreSkill.MINING),
	@SerializedName("nex")
	NEX(HiscoreSkill.NEX),
	@SerializedName("nightmare")
	NIGHTMARE(HiscoreSkill.NIGHTMARE),
	@SerializedName("obor")
	OBOR(HiscoreSkill.OBOR),
	@SerializedName("overall")
	OVERALL(HiscoreSkill.OVERALL),
	@SerializedName("phantom_muspah")
	PHANTOM_MUSPAH(HiscoreSkill.PHANTOM_MUSPAH),
	@SerializedName("phosanis_nightmare")
	PHOSANIS_NIGHTMARE(HiscoreSkill.PHOSANIS_NIGHTMARE),
	@SerializedName("prayer")
	PRAYER(HiscoreSkill.PRAYER),
	@SerializedName("ranged")
	RANGED(HiscoreSkill.RANGED),
	@SerializedName("runecrafting")
	RUNECRAFTING(HiscoreSkill.RUNECRAFT),
	@SerializedName("sarachnis")
	SARACHNIS(HiscoreSkill.SARACHNIS),
	@SerializedName("scorpia")
	SCORPIA(HiscoreSkill.SCORPIA),
	@SerializedName("scurrius")
	SCURRIUS(HiscoreSkill.SCURRIUS),
	@SerializedName("skotizo")
	SKOTIZO(HiscoreSkill.SKOTIZO),
	@SerializedName("sol_heredit")
	SOL_HEREDIT(HiscoreSkill.SOL_HEREDIT),
	@SerializedName("spindel")
	SPINDEL(HiscoreSkill.SPINDEL),
	@SerializedName("slayer")
	SLAYER(HiscoreSkill.SLAYER),
	@SerializedName("smithing")
	SMITHING(HiscoreSkill.SMITHING),
	@SerializedName("soul_wars_zeal")
	SOUL_WARS_ZEAL(HiscoreSkill.SOUL_WARS_ZEAL),
	@SerializedName("strength")
	STRENGTH(HiscoreSkill.STRENGTH),
	@SerializedName("tempoross")
	TEMPOROSS(HiscoreSkill.TEMPOROSS),
	@SerializedName("theatre_of_blood_hard_mode")
	THEATRE_OF_BLOOD_HARD_MODE(HiscoreSkill.THEATRE_OF_BLOOD_HARD_MODE),
	@SerializedName("theatre_of_blood")
	THEATRE_OF_BLOOD(HiscoreSkill.THEATRE_OF_BLOOD),
	@SerializedName("the_corrupted_gauntlet")
	THE_CORRUPTED_GAUNTLET(HiscoreSkill.THE_CORRUPTED_GAUNTLET),
	@SerializedName("the_hueycoatl")
	THE_HUEYCOATL(HiscoreSkill.THE_HUEYCOATL),
	@SerializedName("the_leviathan")
	THE_LEVIATHAN(HiscoreSkill.THE_LEVIATHAN),
	@SerializedName("the_royal_titans")
	THE_ROYAL_TITANS(HiscoreSkill.THE_ROYAL_TITANS),
	@SerializedName("the_whisperer")
	THE_WHISPERER(HiscoreSkill.THE_WHISPERER),
	@SerializedName("the_gauntlet")
	THE_GAUNTLET(HiscoreSkill.THE_GAUNTLET),
	@SerializedName("thermonuclear_smoke_devil")
	THERMONUCLEAR_SMOKE_DEVIL(HiscoreSkill.THERMONUCLEAR_SMOKE_DEVIL),
	@SerializedName("tombs_of_amascut")
	TOMBS_OF_AMASCUT(HiscoreSkill.TOMBS_OF_AMASCUT),
	@SerializedName("tombs_of_amascut_expert")
	TOMBS_OF_AMASCUT_EXPERT(HiscoreSkill.TOMBS_OF_AMASCUT_EXPERT),
	@SerializedName("thieving")
	THIEVING(HiscoreSkill.THIEVING),
	@SerializedName("tzkal_zuk")
	TZKAL_ZUK(HiscoreSkill.TZKAL_ZUK),
	@SerializedName("tztok_jad")
	TZTOK_JAD(HiscoreSkill.TZTOK_JAD),
	@SerializedName("vardorvis")
	VARDORVIS(HiscoreSkill.VARDORVIS),
	@SerializedName("venenatis")
	VENENATIS(HiscoreSkill.VENENATIS),
	@SerializedName("vetion")
	VETION(HiscoreSkill.VETION),
	@SerializedName("vorkath")
	VORKATH(HiscoreSkill.VORKATH),
	@SerializedName("wintertodt")
	WINTERTODT(HiscoreSkill.WINTERTODT),
	@SerializedName("woodcutting")
	WOODCUTTING(HiscoreSkill.WOODCUTTING),
	@SerializedName("yama")
	YAMA(HiscoreSkill.YAMA),
	@SerializedName("zalcano")
	ZALCANO(HiscoreSkill.ZALCANO),
	@SerializedName("zulrah")
	ZULRAH(HiscoreSkill.ZULRAH);

	@Getter
	private HiscoreSkill hiscoreSkill;

	public BufferedImage loadIcon(HiscoreSkillType type)
	{
		final String directory;
		// Computed metrics: EHP and EHB
		if (type == null)
		{
			directory = "";
		}
		else if (type == HiscoreSkillType.BOSS)
		{
			directory = "bosses/";
		}
		else if (type == HiscoreSkillType.ACTIVITY)
		{
			directory = "activities/";
		}
		else
		{
			directory = "/skill_icons_small/";
		}

		String fileName;
		if (name().equalsIgnoreCase("runecrafting"))
		{
			fileName = "runecraft";
		}
		else if (name().equalsIgnoreCase("guardians_of_the_rift"))
		{
			fileName = "rifts_closed";
		}
		else if (name().contains("SCROLLS"))
		{
			fileName = name().toLowerCase().replace("scrolls", "scroll");
		}
		else
		{
			fileName = name().toLowerCase();
		}

		return ImageUtil.loadImageResource(WomUtilsPlugin.class, directory + fileName + ".png");
	}

	public String getName()
	{
		if (hiscoreSkill == null)
		{
			return this.toString();
		}
		return hiscoreSkill.getName();
	}

	public HiscoreSkillType getType()
	{
		if (hiscoreSkill == null)
		{
			return null;
		}
		return hiscoreSkill.getType();
	}
}

package net.wiseoldman.beans;

import lombok.Value;

@Value
public class GroupMembership
{
    int playerId;
    int groupId;
    String role;
    String createdAt;
    String updatedAt;
    GroupMemberInfo player;
}

package net.wiseoldman.beans;

import lombok.Value;

@Value
public class GroupMemberInfo
{
    int id;
    String username;
    String displayName;
    String type;
    String build;
    String country;
    boolean flagged;
    long exp;
    double ehp;
    double ehb;
    double ttm;
    double tt200m;
    String registeredAt;
    String updatedAt;
    String lastChangedAt;
    String lastImportedAt;
}
package net.wiseoldman.beans;

import com.google.gson.annotations.SerializedName;
import lombok.AllArgsConstructor;

@AllArgsConstructor
public enum PlayerBuild
{
    @SerializedName("1def")
    ONE_DEF_PURE("1 Def Pure"),

    @SerializedName("lvl3")
    LEVEL_3("Level 3"),

    @SerializedName("f2p")
    F2P("F2P"),

    @SerializedName("f2p_lvl3")
    F2P_LEVEL_3("F2P & Level 3"),

    @SerializedName("hp10")
    HP_PURE("10 HP Pure"),

    @SerializedName("main")
    MAIN("Main"),

    @SerializedName("zerker")
    ZERKER("Zerker");

    private final String build;

    @Override
    public String toString()
    {
        return build;
    }
}

package net.wiseoldman.beans;

import java.util.Date;
import lombok.Data;

@Data
public class Participant
{
	int playerId;
	int competitionId;
	String teamName;
	Date createdAt;
	Date updatedAt;
	PlayerInfo player;
	CompetitionProgress progress;
}

package net.wiseoldman.beans;

import lombok.Value;

@Value
public class WomStatus
{
	String message;
	String[] data;
}

package net.wiseoldman.beans;

import lombok.Value;

@Value
public class WomPlayerUpdate
{
    long accountHash;
}
package net.wiseoldman.beans;

import lombok.Value;
import net.runelite.client.hiscore.HiscoreSkill;

@Value
public class SnapshotBosses
{
	Boss abyssal_sire;
	Boss alchemical_hydra;
	Boss amoxliatl;
	Boss araxxor;
	Boss artio;
	Boss barrows_chests;
	Boss bryophyta;
	Boss callisto;
	Boss calvarion;
	Boss cerberus;
	Boss chambers_of_xeric;
	Boss chambers_of_xeric_challenge_mode;
	Boss chaos_elemental;
	Boss chaos_fanatic;
	Boss commander_zilyana;
	Boss corporeal_beast;
	Boss crazy_archaeologist;
	Boss dagannoth_prime;
	Boss dagannoth_rex;
	Boss dagannoth_supreme;
	Boss deranged_archaeologist;
	Boss doom_of_mokhaiotl;
	Boss duke_sucellus;
	Boss general_graardor;
	Boss giant_mole;
	Boss grotesque_guardians;
	Boss hespori;
	Boss kalphite_queen;
	Boss king_black_dragon;
	Boss kraken;
	Boss kreearra;
	Boss kril_tsutsaroth;
	Boss lunar_chests;
	Boss mimic;
	Boss nex;
	Boss nightmare;
	Boss phosanis_nightmare;
	Boss obor;
	Boss phantom_muspah;
	Boss sarachnis;
	Boss scorpia;
	Boss scurrius;
	Boss skotizo;
	Boss sol_heredit;
	Boss spindel;
	Boss tempoross;
	Boss the_gauntlet;
	Boss the_corrupted_gauntlet;
	Boss the_hueycoatl;
	Boss the_leviathan;
	Boss the_royal_titans;
	Boss the_whisperer;
	Boss theatre_of_blood;
	Boss theatre_of_blood_hard_mode;
	Boss thermonuclear_smoke_devil;
	Boss tombs_of_amascut;
	Boss tombs_of_amascut_expert;
	Boss tzkal_zuk;
	Boss tztok_jad;
	Boss vardorvis;
	Boss venenatis;
	Boss vetion;
	Boss vorkath;
	Boss wintertodt;
	Boss yama;
	Boss zalcano;
	Boss zulrah;

	public Boss getBoss(HiscoreSkill skill)
	{
		switch (skill)
		{
			case ABYSSAL_SIRE:
				return getAbyssal_sire();
			case ALCHEMICAL_HYDRA:
				return getAlchemical_hydra();
			case AMOXLIATL:
				return getAmoxliatl();
			case ARAXXOR:
				return getAraxxor();
			case ARTIO:
				return getArtio();
			case BARROWS_CHESTS:
				return getBarrows_chests();
			case BRYOPHYTA:
				return getBryophyta();
			case CALLISTO:
				return getCallisto();
			case CALVARION:
				return getCalvarion();
			case CERBERUS:
				return getCerberus();
			case CHAMBERS_OF_XERIC:
				return getChambers_of_xeric();
			case CHAMBERS_OF_XERIC_CHALLENGE_MODE:
				return getChambers_of_xeric_challenge_mode();
			case CHAOS_ELEMENTAL:
				return getChaos_elemental();
			case CHAOS_FANATIC:
				return getChaos_fanatic();
			case COMMANDER_ZILYANA:
				return getCommander_zilyana();
			case CORPOREAL_BEAST:
				return getCorporeal_beast();
			case CRAZY_ARCHAEOLOGIST:
				return getCrazy_archaeologist();
			case DAGANNOTH_PRIME:
				return getDagannoth_prime();
			case DAGANNOTH_REX:
				return getDagannoth_rex();
			case DAGANNOTH_SUPREME:
				return getDagannoth_supreme();
			case DERANGED_ARCHAEOLOGIST:
				return getDeranged_archaeologist();
			case DOOM_OF_MOKHAIOTL:
				return getDoom_of_mokhaiotl();
			case DUKE_SUCELLUS:
				return getDuke_sucellus();
			case GENERAL_GRAARDOR:
				return getGeneral_graardor();
			case GIANT_MOLE:
				return getGiant_mole();
			case GROTESQUE_GUARDIANS:
				return getGrotesque_guardians();
			case HESPORI:
				return getHespori();
			case THE_HUEYCOATL:
				return getThe_hueycoatl();
			case KALPHITE_QUEEN:
				return getKalphite_queen();
			case KING_BLACK_DRAGON:
				return getKing_black_dragon();
			case KRAKEN:
				return getKraken();
			case KREEARRA:
				return getKreearra();
			case KRIL_TSUTSAROTH:
				return getKril_tsutsaroth();
			case LUNAR_CHESTS:
				return getLunar_chests();
			case MIMIC:
				return getMimic();
			case NEX:
				return getNex();
			case NIGHTMARE:
				return getNightmare();
			case PHOSANIS_NIGHTMARE:
				return getPhosanis_nightmare();
			case OBOR:
				return getObor();
			case PHANTOM_MUSPAH:
				return getPhantom_muspah();
			case SARACHNIS:
				return getSarachnis();
			case SCORPIA:
				return getScorpia();
			case SCURRIUS:
				return getScurrius();
			case SKOTIZO:
				return getSkotizo();
			case SOL_HEREDIT:
				return getSol_heredit();
			case SPINDEL:
				return getSpindel();
			case TEMPOROSS:
				return getTempoross();
			case THE_GAUNTLET:
				return getThe_gauntlet();
			case THE_CORRUPTED_GAUNTLET:
				return getThe_corrupted_gauntlet();
			case THE_LEVIATHAN:
				return getThe_leviathan();
			case THE_ROYAL_TITANS:
				return getThe_royal_titans();
			case THE_WHISPERER:
				return getThe_whisperer();
			case THEATRE_OF_BLOOD:
				return getTheatre_of_blood();
			case THEATRE_OF_BLOOD_HARD_MODE:
				return getTheatre_of_blood_hard_mode();
			case THERMONUCLEAR_SMOKE_DEVIL:
				return getThermonuclear_smoke_devil();
			case TOMBS_OF_AMASCUT:
				return getTombs_of_amascut();
			case TOMBS_OF_AMASCUT_EXPERT:
				return getTombs_of_amascut_expert();
			case TZKAL_ZUK:
				return getTzkal_zuk();
			case TZTOK_JAD:
				return getTztok_jad();
			case VARDORVIS:
				return getVardorvis();
			case VENENATIS:
				return getVenenatis();
			case VETION:
				return getVetion();
			case VORKATH:
				return getVorkath();
			case WINTERTODT:
				return getWintertodt();
			case YAMA:
				return getYama();
			case ZALCANO:
				return getZalcano();
			case ZULRAH:
				return getZulrah();
			default:
				throw new IllegalArgumentException("Invalid hiscore boss");
		}
	}
}

package net.wiseoldman.beans;

import com.google.gson.annotations.SerializedName;
import lombok.AllArgsConstructor;
import lombok.Getter;

@Getter
@AllArgsConstructor
public enum CompetitionType
{
	@SerializedName("classic")
	CLASSIC("Classic"),
	@SerializedName("team")
	TEAM("Team")
	;

	private String type;

	public String toString()
	{
		return type;
	}
}

package net.wiseoldman.beans;

import lombok.Data;
import lombok.EqualsAndHashCode;

@EqualsAndHashCode(callSuper = true)
@Data
public class GroupInfoWithMemberships extends GroupInfo
{
    GroupMembership[] memberships;
}

package net.wiseoldman.beans;

import lombok.Value;

@Value
public class CanvasCompetition
{
	int id;
	boolean isOngoing;
}

package net.wiseoldman.beans;

import lombok.Value;

@Value
public class Boss
{
	String metric;
	int kills;
	int rank;
	double ehb;
}

package net.wiseoldman.beans;

import lombok.Value;

@Value
public class PlayerInfo
{
    int id;
    String username;
    String displayName;
    PlayerType type;
    PlayerBuild build;
    String country;
    boolean flagged;
    long exp;
    double ehp;
    double ehb;
    double ttm;
    double tt200m;
    String registeredAt;
    String updatedAt;
    String lastChangedAt;
    String lastImportedAt;
    int combatLevel;
    Snapshot latestSnapshot;
}
package net.wiseoldman.beans;

import com.google.gson.annotations.SerializedName;
import lombok.AllArgsConstructor;

@AllArgsConstructor
public enum PlayerType
{
    @SerializedName("unknown")
    UNKNOWN("Unknown"),

    @SerializedName("regular")
    REGULAR("Regular"),

    @SerializedName("ironman")
    IRONMAN("Ironman"),

    @SerializedName("hardcore")
    HARDCORE("Hardcore"),

    @SerializedName("ultimate")
    ULTIMATE("Ultimate"),

    @SerializedName("fresh_start")
    FRESH_START("Fresh Start");

    private final String type;

    @Override
    public String toString()
    {
        return type;
    }
}

package net.wiseoldman.beans;

import lombok.Value;
import net.runelite.client.hiscore.HiscoreSkill;

@Value
public class SnapshotActivities
{
	Activity league_points;
	Activity bounty_hunter_hunter;
	Activity bounty_hunter_rogue;
	Activity clue_scrolls_all;
	Activity clue_scrolls_beginner;
	Activity clue_scrolls_easy;
	Activity clue_scrolls_medium;
	Activity clue_scrolls_hard;
	Activity clue_scrolls_elite;
	Activity clue_scrolls_master;
	Activity last_man_standing;
	Activity pvp_arena;
	Activity soul_wars_zeal;
	Activity guardians_of_the_rift;
	Activity colosseum_glory;
	Activity collections_logged;

	public Activity getActivity(HiscoreSkill skill)
	{
		switch (skill)
		{
			case LEAGUE_POINTS:
				return getLeague_points();
			case BOUNTY_HUNTER_HUNTER:
				return getBounty_hunter_hunter();
			case BOUNTY_HUNTER_ROGUE:
				return getBounty_hunter_rogue();
			case CLUE_SCROLL_ALL:
				return getClue_scrolls_all();
			case CLUE_SCROLL_BEGINNER:
				return getClue_scrolls_beginner();
			case CLUE_SCROLL_EASY:
				return getClue_scrolls_easy();
			case CLUE_SCROLL_MEDIUM:
				return getClue_scrolls_medium();
			case CLUE_SCROLL_HARD:
				return getClue_scrolls_hard();
			case CLUE_SCROLL_ELITE:
				return getClue_scrolls_elite();
			case CLUE_SCROLL_MASTER:
				return getClue_scrolls_master();
			case LAST_MAN_STANDING:
				return getLast_man_standing();
			case PVP_ARENA_RANK:
				return getPvp_arena();
			case SOUL_WARS_ZEAL:
				return getSoul_wars_zeal();
			case RIFTS_CLOSED:
				return getGuardians_of_the_rift();
			case COLOSSEUM_GLORY:
				return getColosseum_glory();
			case COLLECTIONS_LOGGED:
				return getCollections_logged();
			default:
				throw new IllegalArgumentException("Invalid hiscore minigame");
		}
	}
}

package net.wiseoldman.beans;

import lombok.Value;

@Value
public class Member
{
    String username;
    String role;
}
package net.wiseoldman.beans;

import lombok.Value;

@Value
public class Computed
{
    String metric;
    double value;
    int rank;
}

package net.wiseoldman.beans;

import java.util.Set;
import lombok.Value;

import java.util.ArrayList;

@Value
public class GroupMemberAddition
{
	String verificationCode;
	ArrayList<Member> members;
	Set<RoleIndex> roleOrders;
}
package net.wiseoldman.beans;

import lombok.Value;

@Value
public class SnapshotData
{
    SnapshotSkills skills;
    SnapshotBosses bosses;
    SnapshotActivities activities;
    SnapshotComputed computed;
}

package net.wiseoldman.events;

import net.wiseoldman.beans.ParticipantWithStanding;
import lombok.Value;

@Value
public class WomOngoingPlayerCompetitionsFetched
{
	String username;
	ParticipantWithStanding[] competitions;
}

package net.wiseoldman.events;

import net.wiseoldman.beans.ParticipantWithCompetition;
import lombok.Value;

@Value
public class WomUpcomingPlayerCompetitionsFetched
{
	String username;
	ParticipantWithCompetition[] competitions;
}

package net.wiseoldman.events;

import net.wiseoldman.beans.GroupInfoWithMemberships;
import lombok.AllArgsConstructor;
import lombok.Getter;

@Getter
@AllArgsConstructor
public class WomGroupSynced
{
	GroupInfoWithMemberships groupInfo;
	boolean silent;

	public WomGroupSynced(GroupInfoWithMemberships groupInfo)
	{
		this(groupInfo, false);
	}
}

package net.wiseoldman.events;

import net.wiseoldman.beans.CompetitionInfo;
import lombok.Value;

@Value
public class WomCompetitionInfoFetched
{
	CompetitionInfo comp;
}

package net.wiseoldman.events;

import lombok.Value;
import net.wiseoldman.web.WomRequestType;

@Value
public class WomRequestFailed
{
	String username;
	WomRequestType type;
}

package net.wiseoldman.panel;

import java.awt.BorderLayout;
import java.awt.Color;
import java.awt.ComponentOrientation;
import java.awt.Dimension;
import java.awt.Font;
import java.awt.FontMetrics;
import java.awt.Graphics2D;
import java.awt.GridBagConstraints;
import java.awt.GridBagLayout;
import java.awt.image.BufferedImage;
import javax.swing.ImageIcon;
import javax.swing.JLabel;
import javax.swing.JMenuItem;
import javax.swing.JPanel;
import javax.swing.JPopupMenu;
import javax.swing.SwingConstants;
import javax.swing.SwingUtilities;
import javax.swing.border.EmptyBorder;
import javax.swing.border.MatteBorder;
import javax.swing.event.PopupMenuEvent;
import javax.swing.event.PopupMenuListener;
import lombok.Getter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.WorldType;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.DynamicGridLayout;
import net.runelite.client.ui.FontManager;
import net.runelite.client.util.ColorUtil;
import net.runelite.client.util.ImageUtil;
import net.runelite.client.util.LinkBrowser;
import net.wiseoldman.WomUtilsPlugin;
import net.wiseoldman.beans.Competition;
import net.wiseoldman.beans.CompetitionProgress;
import net.wiseoldman.beans.GroupInfo;
import net.wiseoldman.beans.Metric;
import net.wiseoldman.beans.ParticipantWithCompetition;
import net.wiseoldman.beans.ParticipantWithStanding;
import net.wiseoldman.util.Format;
import net.wiseoldman.util.Utils;
import okhttp3.HttpUrl;


@Slf4j
public class CompetitionCardPanel extends JPanel
{
	private static final String INFO_LABEL_TEMPLATE =
		"<html><body style='color:%s'>%s<br>%s<span style='color:%s'>%s</span></body></html>";
	private static final String HOSTED_BY_TEMPLATE =
		"<html><body style='color:%s'>%s<span style='color:%s'>%s</span></body></html>";

	private static final String LIGHT_GRAY = ColorUtil.toHexColor(ColorScheme.LIGHT_GRAY_COLOR);
	private static final String WHITE = ColorUtil.toHexColor(Color.WHITE);
	private static final String GREEN = ColorUtil.toHexColor(ColorScheme.PROGRESS_COMPLETE_COLOR);

	private static final String ELLIPSIS = "...";
	private static final String ADD_STATE = "Add to canvas";
	private static final String REMOVE_STATE = "Remove from canvas";

	/* The competition's info box wrapping container */
	private final JPanel container = new JPanel();
	private final JPanel headerPanel = new JPanel();
	private final JPanel titlePanel = new JPanel(new BorderLayout());
	private final JPanel infoPanel = new JPanel();

	// Holds all the competition information
	private final JLabel timerLabel = new JLabel();
	private final JLabel groupLabel = new JLabel();
	private final JLabel logoutReminderLabel =
		new JLabel("<html><body style='color:#FF0000; text-align:center;'>The competition has started. " +
			"Please relog to start tracking your gains.</body></html>", SwingConstants.CENTER);
	private final JLabel statusDotLabel = new JLabel("●");

	private final JMenuItem canvasItem = new JMenuItem(ADD_STATE);

	private final FontMetrics fm = getFontMetrics(FontManager.getRunescapeSmallFont());

	private final Client client;
	private final WomUtilsPlugin plugin;
	@Getter
	private final Competition competition;
	private String groupName;
	private boolean truncated;
	private String fetchedStatus;
	@Getter
	private final CompetitionProgress progress;
	@Getter
	private final int rank;


	CompetitionCardPanel(Client client, WomUtilsPlugin plugin, ParticipantWithStanding p)
	{
		this.client = client;
		this.competition = p.getCompetition();
		this.plugin = plugin;
		this.progress = p.getProgress();
		this.rank = p.getRank();

		Metric metric = p.getCompetition().getMetric();

		setupPanel(competition.getTitle(), metric, competition.getGroup());

		double gained = progress.getGained();
		JLabel gainedLabel = new JLabel(String.format(INFO_LABEL_TEMPLATE, LIGHT_GRAY, "Gained", "", gained > 0 ? GREEN : WHITE,
			(gained > 0 ? "+" : "") + Format.formatNumber(gained)));
		gainedLabel.setFont(FontManager.getRunescapeSmallFont());
//		gainedLabel.setToolTipText(String.format("%,.1f", p.getProgress().getGained()));
		gainedLabel.setPreferredSize(new Dimension(53, gainedLabel.getPreferredSize().height));

		JLabel rankLabel = new JLabel(String.format(INFO_LABEL_TEMPLATE, LIGHT_GRAY, "Rank", "", WHITE, Utils.ordinalOf(rank)));
		rankLabel.setFont(FontManager.getRunescapeSmallFont());

		infoPanel.add(gainedLabel);
		infoPanel.add(rankLabel);

		container.add(headerPanel, BorderLayout.NORTH);
		container.add(infoPanel, BorderLayout.CENTER);

		add(container);
	}

	CompetitionCardPanel(Client client, WomUtilsPlugin plugin, ParticipantWithCompetition p)
	{
		this.client = client;
		this.competition = p.getCompetition();
		this.plugin = plugin;
		this.progress = null;
		this.rank = -1;

		Metric metric = p.getCompetition().getMetric();
		Competition competition = p.getCompetition();

		setupPanel(competition.getTitle(), metric, competition.getGroup());

		container.add(headerPanel, BorderLayout.NORTH);
		container.add(infoPanel, BorderLayout.CENTER);

		add(container);
	}

	private void setupPanel(String title, Metric metric, GroupInfo group)
	{
		groupName = group != null ? group.getName() : null;
		fetchedStatus = competition.hasStarted() ? "ongoing" : "upcoming";

		setLayout(new BorderLayout());
		setBorder(new EmptyBorder(5, 0, 0, 0));

		container.setLayout(new BorderLayout());
		container.setBackground(ColorScheme.DARKER_GRAY_COLOR);

		createHeaderPanel(title, metric, group);

		infoPanel.setLayout(new DynamicGridLayout(1, 4));
		infoPanel.setComponentOrientation(ComponentOrientation.LEFT_TO_RIGHT);
		infoPanel.setBackground(ColorScheme.DARKER_GRAY_COLOR);
		infoPanel.setBorder(new EmptyBorder(7, 7, 5, 7));

		String[] keyValue = getCountdown();
		timerLabel.setText(String.format(INFO_LABEL_TEMPLATE, LIGHT_GRAY, keyValue[0], "", WHITE, keyValue[1]));
		timerLabel.setFont(FontManager.getRunescapeSmallFont());
		timerLabel.setPreferredSize(new Dimension(60, timerLabel.getPreferredSize().height));

		infoPanel.add(timerLabel);

		logoutReminderLabel.setFont(FontManager.getRunescapeBoldFont());
		logoutReminderLabel.setForeground(ColorScheme.PROGRESS_ERROR_COLOR);
		logoutReminderLabel.setVisible(false);
		container.add(logoutReminderLabel, BorderLayout.SOUTH);
		addPopupMenu();
	}

	private void addPopupMenu()
	{
		final JMenuItem openCompetitionPage = new JMenuItem("Open competition page");
		openCompetitionPage.addActionListener(e -> LinkBrowser.browse(competitionPageUrl(String.valueOf(competition.getId()))));


		final JPopupMenu popupMenu = new JPopupMenu();
		popupMenu.setBorder(new EmptyBorder(5, 5, 5, 5));
		popupMenu.add(openCompetitionPage);
		popupMenu.add(canvasItem);
		popupMenu.addPopupMenuListener(new PopupMenuListener()
		{
			@Override
			public void popupMenuWillBecomeVisible(PopupMenuEvent e)
			{
				canvasItem.setText(plugin.hasInfoBox(competition.getId()) ? REMOVE_STATE : ADD_STATE);
			}

			@Override
			public void popupMenuWillBecomeInvisible(PopupMenuEvent e)
			{

			}

			@Override
			public void popupMenuCanceled(PopupMenuEvent e)
			{

			}
		});


		canvasItem.addActionListener(e ->
		{
			if (canvasItem.getText().equals(REMOVE_STATE))
			{
				plugin.removeInfoBox(this);
			}
			else
			{
				plugin.addInfoBox(this);
			}
		});

		container.setComponentPopupMenu(popupMenu);
	}

	private String[] getCountdown()
	{
		String timeStatus = competition.getTimeStatus();
		if (timeStatus.equals("Ended"))
		{
			return new String[]{"Ended", "\u00A0", ""};
		}

		String[] splitStatus = timeStatus.split(" in ");
		String prefix = splitStatus[0] + " in";
		String time = splitStatus[1];

		// when the seconds are 0, the seconds part is removed, so we have to check that seconds are there.
		if (time.contains("d") && time.contains("s"))
		{
			return new String[]{prefix, time.split("m\\s[0-9]{1,2}s")[0] + "m", time};
		}
		else
		{
			return new String[]{prefix, time, time};
		}
	}

	void updateCountDown()
	{
		String[] keyValue = getCountdown();
		if (competition.isActive() && fetchedStatus.equals("upcoming"))
		{
			logoutReminderLabel.setVisible(true);
			fetchedStatus = "ongoing";
		}
		statusDotLabel.setForeground(getStatusColor());
		timerLabel.setText(String.format(INFO_LABEL_TEMPLATE, LIGHT_GRAY, keyValue[0], "", WHITE, keyValue[1]));
	}

	private void createHeaderPanel(String title, Metric metric, GroupInfo group)
	{
		headerPanel.setLayout(new GridBagLayout());
		headerPanel.setBackground(ColorScheme.DARKER_GRAY_COLOR);
		headerPanel.setBorder(new MatteBorder(0, 0, 1, 0, ColorScheme.DARK_GRAY_COLOR));

		GridBagConstraints titleConstraints = new GridBagConstraints();
		titleConstraints.weightx = 1.0;
		titleConstraints.fill = GridBagConstraints.HORIZONTAL;

		GridBagConstraints iconConstraints = new GridBagConstraints();

		headerPanel.add(createIconPanel(metric), iconConstraints);
		headerPanel.add(createTitlePanel(title, group), titleConstraints);
	}

	private JPanel createIconPanel(Metric metric)
	{
		JPanel fixedIconPanel = new JPanel(new BorderLayout());
		fixedIconPanel.setPreferredSize(new Dimension(41, 40));
		fixedIconPanel.setMinimumSize(new Dimension(41, 40));
		fixedIconPanel.setMaximumSize(new Dimension(41, 40));
		fixedIconPanel.setBackground(ColorScheme.DARKER_GRAY_COLOR);
		fixedIconPanel.setBorder(new EmptyBorder(0, 8, 0, 4));

		ImageIcon iconBg = new ImageIcon(ImageUtil.loadImageResource(WomUtilsPlugin.class, "icon_bg.png"));
		ImageIcon metricIcon = new ImageIcon(metric.loadIcon(metric.getType()));

		BufferedImage combinedImage = new BufferedImage(
			iconBg.getIconWidth(),
			iconBg.getIconHeight(),
			BufferedImage.TYPE_INT_ARGB
		);

		Graphics2D g2d = combinedImage.createGraphics();
		g2d.drawImage(iconBg.getImage(), 0, 0, null);
		int x = (iconBg.getIconWidth() - metricIcon.getIconWidth()) / 2;
		int y = (iconBg.getIconHeight() - metricIcon.getIconHeight()) / 2;
		g2d.drawImage(metricIcon.getImage(), x, y, null);
		g2d.dispose();

		ImageIcon combinedIcon = new ImageIcon(combinedImage);

		JLabel metricIconLabel = new JLabel(combinedIcon);
		metricIconLabel.setBounds(0, 0, 41, 40);

		statusDotLabel.setFont(new Font("Arial", Font.BOLD, 9));
		statusDotLabel.setForeground(getStatusColor());
		statusDotLabel.setBounds(27, 24, 9, 9);

		fixedIconPanel.add(metricIconLabel);
		fixedIconPanel.add(statusDotLabel);

		metricIconLabel.setHorizontalAlignment(SwingConstants.CENTER);
		metricIconLabel.setVerticalAlignment(SwingConstants.CENTER);
//		metricIconLabel.setToolTipText(metric.getName());

		fixedIconPanel.add(metricIconLabel, BorderLayout.CENTER);

		return fixedIconPanel;
	}

	private Color getStatusColor()
	{
		if (competition.isActive())
		{
			return ColorScheme.PROGRESS_COMPLETE_COLOR;
		}
		else if (!competition.hasStarted())
		{
			return ColorScheme.PROGRESS_INPROGRESS_COLOR;
		}
		else
		{
			return Color.RED;
		}
	}

	private JPanel createTitlePanel(String title, GroupInfo group)
	{
		titlePanel.setBackground(ColorScheme.DARKER_GRAY_COLOR);

		JLabel titleLabel = new JLabel(title);
		titleLabel.setFont(FontManager.getRunescapeFont());
		titleLabel.setForeground(Color.white);
//		titleLabel.setToolTipText(title);
		titlePanel.add(titleLabel, BorderLayout.NORTH);
		titlePanel.setBorder(new EmptyBorder(8, 0, 8, 0));


		if (group != null)
		{
			groupLabel.setText(String.format(HOSTED_BY_TEMPLATE, LIGHT_GRAY, "Hosted by ",
				ColorUtil.toHexColor(ColorScheme.GRAND_EXCHANGE_LIMIT), group.getName()));
			groupLabel.setFont(FontManager.getRunescapeSmallFont());
			titlePanel.add(groupLabel, BorderLayout.SOUTH);
		}

		return titlePanel;
	}

	private void truncateGroupName()
	{
		if (!isShowing() || groupName == null)
		{
			return;
		}

		int groupNameWidth = fm.stringWidth(groupName);
		int availableWidth = titlePanel.getWidth() - fm.stringWidth("Hosted by ");

		if (availableWidth >= groupNameWidth)
		{
			return;
		}

		double charactersPerPixel = (double) groupName.length() / groupNameWidth;
		int charactersToDisplay = (int) (Math.floor(availableWidth * charactersPerPixel) - ELLIPSIS.length() - 1);

		String truncatedGroupName = groupName.substring(0, charactersToDisplay) + ELLIPSIS;
		groupLabel.setText(String.format(HOSTED_BY_TEMPLATE, LIGHT_GRAY, "Hosted by ",
			ColorUtil.toHexColor(ColorScheme.GRAND_EXCHANGE_LIMIT), truncatedGroupName));
//		groupLabel.setToolTipText(groupName);

		truncated = true;
	}

	private String competitionPageUrl(String id)
	{

		return new HttpUrl.Builder()
			.scheme("https")
			.host(client.getWorldType().contains(WorldType.SEASONAL) ? "league.wiseoldman.net" : "wiseoldman.net")
			.addPathSegment("competitions")
			.addPathSegment(id)
			.build()
			.toString();
	}

	@Override
	public void doLayout()
	{
		super.doLayout();
		if (!truncated)
		{
			SwingUtilities.invokeLater(this::truncateGroupName);
		}
	}
}

package net.wiseoldman.panel;

import lombok.Value;
import net.runelite.client.hiscore.HiscoreSkill;

@Value
public class RowPair
{
    HiscoreSkill skill;
    TableRow row;
}

/*
 * Copyright (c) 2018, John Pettenger
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package net.wiseoldman.panel;

import com.google.common.collect.EvictingQueue;
import com.google.inject.Inject;
import java.awt.event.KeyEvent;
import java.awt.event.KeyListener;
import java.util.Arrays;
import java.util.Objects;
import java.util.Optional;
import java.util.regex.Pattern;
import javax.annotation.Nullable;
import javax.inject.Singleton;
import javax.swing.SwingUtilities;
import javax.swing.text.BadLocationException;
import javax.swing.text.Document;
import javax.swing.text.JTextComponent;
import lombok.NonNull;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.Friend;
import net.runelite.api.FriendsChatManager;
import net.runelite.api.IndexedObjectSet;
import net.runelite.api.Nameable;
import net.runelite.api.NameableContainer;
import net.runelite.api.Player;

@Slf4j
@Singleton
public class NameAutocompleter implements KeyListener
{
	/**
	 * Non-breaking space character.
	 */
	private static final String NBSP = Character.toString((char) 160);

	/**
	 * Character class for characters that cannot be in an RSN.
	 */
	private static final Pattern INVALID_CHARS = Pattern.compile("[^a-zA-Z0-9_ -]");

	private static final int MAX_SEARCH_HISTORY = 25;

	private final Client client;

	private final EvictingQueue<String> searchHistory = EvictingQueue.create(MAX_SEARCH_HISTORY);

	/**
	 * The name currently being autocompleted.
	 */
	private String autocompleteName;

	/**
	 * Pattern for the name currently being autocompleted.
	 */
	private Pattern autocompleteNamePattern;

	@Inject
	private NameAutocompleter(@Nullable Client client)
	{
		this.client = client;
	}

	@Override
	public void keyPressed(KeyEvent e)
	{

	}

	@Override
	public void keyReleased(KeyEvent e)
	{

	}

	@Override
	public void keyTyped(KeyEvent e)
	{
		final JTextComponent input = (JTextComponent) e.getSource();
		final String inputText = input.getText();

		// Only autocomplete if the selection end is at the end of the text.
		if (input.getSelectionEnd() != inputText.length())
		{
			return;
		}

		// Character to be inserted at the selection start.
		final String charToInsert = Character.toString(e.getKeyChar());

		// Don't attempt to autocomplete if the name is invalid.
		// This condition is also true when the user presses a key like backspace.
		if (INVALID_CHARS.matcher(charToInsert).find()
			|| INVALID_CHARS.matcher(inputText).find())
		{
			return;
		}

		// Check if we are already autocompleting.
		if (autocompleteName != null && autocompleteNamePattern.matcher(inputText).matches())
		{
			if (isExpectedNext(input, charToInsert))
			{
				try
				{
					// Insert the character and move the selection.
					final int insertIndex = input.getSelectionStart();
					Document doc = input.getDocument();
					doc.remove(insertIndex, 1);
					doc.insertString(insertIndex, charToInsert, null);
					input.select(insertIndex + 1, input.getSelectionEnd());
				}
				catch (BadLocationException ex)
				{
					log.warn("Could not insert character.", ex);
				}

				// Prevent default behavior.
				e.consume();
			}
			else // Character to insert does not match current autocompletion. Look for another name.
			{
				newAutocomplete(e);
			}
		}
		else // Search for a name to autocomplete
		{
			newAutocomplete(e);
		}
	}

	private void newAutocomplete(KeyEvent e)
	{
		final JTextComponent input = (JTextComponent) e.getSource();
		final String inputText = input.getText();
		final String nameStart = inputText.substring(0, input.getSelectionStart()) + e.getKeyChar();

		if (findAutocompleteName(nameStart))
		{
			// Assert this.autocompleteName != null
			final String name = this.autocompleteName;
			SwingUtilities.invokeLater(() ->
			{
				try
				{
					input.getDocument().insertString(
						nameStart.length(),
						name.substring(nameStart.length()),
						null);
					input.select(nameStart.length(), name.length());
				}
				catch (BadLocationException ex)
				{
					log.warn("Could not autocomplete name.", ex);
				}
			});
		}
	}

	private boolean findAutocompleteName(String nameStart)
	{
		final Pattern pattern;
		Optional<String> autocompleteName;

		// Pattern to match names that start with nameStart.
		// Allows spaces to be represented as common whitespaces, underscores,
		// hyphens, or non-breaking spaces.
		// Matching non-breaking spaces is necessary because the API
		// returns non-breaking spaces when a name has whitespace.
		pattern = Pattern.compile(
			"(?i)^" + nameStart.replaceAll("[ _-]", "[ _" + NBSP + "-]") + ".+?");

		if (client == null)
		{
			return false;
		}

		// Search all previous successful queries
		autocompleteName = searchHistory.stream()
			.filter(n -> pattern.matcher(n).matches())
			.findFirst();

		// Search friends if previous searches weren't matched
		if (!autocompleteName.isPresent())
		{
			NameableContainer<Friend> friendContainer = client.getFriendContainer();
			if (friendContainer != null)
			{
				autocompleteName = Arrays.stream(friendContainer.getMembers())
					.map(Nameable::getName)
					.filter(n -> pattern.matcher(n).matches())
					.findFirst();
			}
		}

		// Search friends chat if a friend wasn't found
		if (!autocompleteName.isPresent())
		{
			final FriendsChatManager friendsChatManager = client.getFriendsChatManager();
			if (friendsChatManager != null)
			{
				autocompleteName = Arrays.stream(friendsChatManager.getMembers())
					.map(Nameable::getName)
					.filter(n -> pattern.matcher(n).matches())
					.findFirst();
			}
		}

		// Search cached players if a friend wasn't found
		if (!autocompleteName.isPresent())
		{
			final IndexedObjectSet<? extends Player> players = client.getTopLevelWorldView().players();
			autocompleteName = players.stream()
				.filter(Objects::nonNull)
				.map(Player::getName)
				.filter(n -> pattern.matcher(n).matches())
				.findFirst();
		}

		if (autocompleteName.isPresent())
		{
			this.autocompleteName = autocompleteName.get().replace(NBSP, " ");
			this.autocompleteNamePattern = Pattern.compile(
				"(?i)^" + this.autocompleteName.replaceAll("[ _-]", "[ _-]") + "$");
		}
		else
		{
			this.autocompleteName = null;
			this.autocompleteNamePattern = null;
		}

		return autocompleteName.isPresent();
	}

	public void addToSearchHistory(@NonNull String name)
	{
		if (!searchHistory.contains(name))
		{
			searchHistory.offer(name);
		}
	}

	private boolean isExpectedNext(JTextComponent input, String nextChar)
	{
		String expected;
		if (input.getSelectionStart() < input.getSelectionEnd())
		{
			try
			{
				expected = input.getText(input.getSelectionStart(), 1);
			}
			catch (BadLocationException ex)
			{
				log.warn("Could not get first character from input selection.", ex);
				return false;
			}
		}
		else
		{
			expected = "";
		}
		return nextChar.equalsIgnoreCase(expected);
	}
}
/*
 * Copyright (c) 2021, Rorro <https://github.com/rorro>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package net.wiseoldman.panel;

import com.google.common.collect.ImmutableMap;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.FontManager;

import javax.swing.*;
import javax.swing.border.EmptyBorder;
import java.awt.*;

public class StatsTableHeader extends JPanel
{
    private static final int ICON_WIDTH = 35;

    private static final String[] SKILLING_LABELS = {"Exp", "Level", "Rank", "EHP"};
    private static final String[] BOSSING_LABELS = {"Kills", "Rank", "EHB"};
    private static final String[] ACTIVITIES_LABELS = {"Score", "Rank"};

    private static final ImmutableMap<String, String[]> HEADER_LABELS = ImmutableMap.of(
        "skilling", SKILLING_LABELS,
        "bossing", BOSSING_LABELS,
        "activities", ACTIVITIES_LABELS
    );

    StatsTableHeader(String stats)
    {
        setLayout(new BorderLayout());
        setBorder(new EmptyBorder(2, 0, 2, 0));
        setBackground(ColorScheme.DARKER_GRAY_COLOR);

        JPanel iconPnl = new JPanel(new BorderLayout());
        iconPnl.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        iconPnl.setPreferredSize(new Dimension(ICON_WIDTH, 0));
        iconPnl.add(new JLabel("", SwingConstants.CENTER));

        JPanel headersPanel = new JPanel(new GridLayout());
        headersPanel.setBackground(ColorScheme.DARKER_GRAY_COLOR);

        for (String label : HEADER_LABELS.get(stats))
        {
            JLabel lbl = new JLabel(label, SwingConstants.CENTER);
            lbl.setFont(FontManager.getRunescapeSmallFont());
            lbl.setForeground(Color.WHITE);
            headersPanel.add(lbl);
        }

        add(iconPnl, BorderLayout.WEST);
        add(headersPanel);
    }
}

package net.wiseoldman.panel;

import com.google.common.collect.ImmutableList;
import net.wiseoldman.util.Format;
import net.wiseoldman.WomUtilsConfig;
import net.wiseoldman.beans.PlayerInfo;
import net.wiseoldman.beans.Skill;
import net.wiseoldman.beans.Snapshot;
import net.runelite.api.Experience;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.util.QuantityFormatter;
import net.runelite.client.hiscore.HiscoreSkill;
import net.runelite.client.hiscore.HiscoreSkillType;

import javax.inject.Inject;
import javax.swing.*;
import java.awt.*;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;

import static net.runelite.client.hiscore.HiscoreSkill.*;

class SkillingPanel extends JPanel
{
    /**
     * Real skills, ordered in the way they should be displayed in the panel.
     */
    private static final List<HiscoreSkill> SKILLS = ImmutableList.of(
        ATTACK, DEFENCE, STRENGTH,
        HITPOINTS, RANGED, PRAYER,
        MAGIC, COOKING, WOODCUTTING,
        FLETCHING, FISHING, FIREMAKING,
        CRAFTING, SMITHING, MINING,
        HERBLORE, AGILITY, THIEVING,
        SLAYER, FARMING, RUNECRAFT,
        HUNTER, CONSTRUCTION
    );
    static Color[] ROW_COLORS = {ColorScheme.DARKER_GRAY_COLOR, new Color(34, 34, 34)};

    TableRow overallRow;
    List<RowPair> tableRows = new ArrayList<>();

    WomUtilsConfig config;

    @Inject
    private SkillingPanel(WomUtilsConfig config)
    {
        this.config = config;

        setLayout(new GridLayout(0, 1));

        StatsTableHeader tableHeader = new StatsTableHeader("skilling");

        // Handle overall separately because it's special
        overallRow = new TableRow(
            OVERALL.name(), OVERALL.getName(), HiscoreSkillType.SKILL,
            "experience", "level", "rank", "ehp"
        );
        overallRow.setBackground(ROW_COLORS[1]);

        add(tableHeader);
        add(overallRow);

        for (int i = 0; i < SKILLS.size(); i++)
        {
            HiscoreSkill skill = SKILLS.get(i);
            TableRow row = new TableRow(
                skill.name(), skill.getName(), HiscoreSkillType.SKILL,
                "experience", "level", "rank", "ehp"
            );
            row.setBackground(ROW_COLORS[i%2]);

            tableRows.add(new RowPair(skill, row));
            add(row);
        }
    }

    public void update(PlayerInfo info)
    {
        if (info == null)
        {
            return;
        }

        Snapshot latestSnapshot = info.getLatestSnapshot();

        for (RowPair rp : tableRows)
        {
            HiscoreSkill skill = rp.getSkill();
            TableRow row = rp.getRow();

            row.update(latestSnapshot.getData().getSkills().getSkill(skill), config.virtualLevels());
        }

        updateTotalLevel(latestSnapshot);
    }

    private void updateTotalLevel(Snapshot snapshot)
    {
        int totalLevel = 0;
        Skill overall = snapshot.getData().getSkills().getSkill(OVERALL);
        long overallExperience = overall.getExperience();
        int overallRank = overall.getRank();

        for (HiscoreSkill skill : SKILLS)
        {
            int experience = (int) snapshot.getData().getSkills().getSkill(skill).getExperience();
            int level = experience >= 0 ? Experience.getLevelForXp(experience) : 0;
            totalLevel += !config.virtualLevels() && level > Experience.MAX_REAL_LEVEL ? Experience.MAX_REAL_LEVEL : level;
        }

        JLabel expLabel = overallRow.labels.get("experience");
        JLabel levelLabel = overallRow.labels.get("level");
        JLabel rankLabel = overallRow.labels.get("rank");
        JLabel ehpLabel = overallRow.labels.get("ehp");

        expLabel.setText(overallExperience >= 0 ? Format.formatNumber(overallExperience) : "--");
        expLabel.setToolTipText(overallExperience >= 0 ? QuantityFormatter.formatNumber(overallExperience) : "");

        levelLabel.setText(totalLevel > 0 ? String.valueOf(totalLevel) : "--");
        levelLabel.setToolTipText(totalLevel > 0 ? QuantityFormatter.formatNumber(totalLevel) : "");

        rankLabel.setText(overallRank > 0 ? Format.formatNumber(overallRank) : "--");
        rankLabel.setToolTipText(overallRank > 0 ? QuantityFormatter.formatNumber(overallRank) : "Unranked");

        ehpLabel.setText(Format.formatNumber(overall.getEhp()));
        ehpLabel.setToolTipText(QuantityFormatter.formatNumber(overall.getEhp()));
    }

    public void reset()
    {
        for (Map.Entry<String, JLabel> entry : overallRow.labels.entrySet())
        {
            JLabel label = entry.getValue();
            label.setText("--");
            label.setToolTipText("");
        }

        for (RowPair rp : tableRows)
        {
            TableRow row = rp.getRow();

            for (Map.Entry<String, JLabel> e : row.labels.entrySet())
            {
                JLabel label = e.getValue();
                label.setText("--");
                label.setToolTipText("");
            }
        }
    }
}

/*
 * Copyright (c) 2021, Rorro <https://github.com/rorro>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package net.wiseoldman.panel;

import net.wiseoldman.util.Format;
import net.wiseoldman.util.Utils;
import net.wiseoldman.WomUtilsPlugin;
import net.wiseoldman.beans.Boss;
import net.wiseoldman.beans.Activity;
import net.wiseoldman.beans.Skill;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Experience;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.FontManager;
import net.runelite.client.util.ImageUtil;
import net.runelite.client.util.QuantityFormatter;
import net.runelite.client.hiscore.HiscoreSkill;
import net.runelite.client.hiscore.HiscoreSkillType;

import javax.swing.*;
import javax.swing.border.EmptyBorder;
import java.awt.*;
import java.util.HashMap;
import java.util.Map;

@Slf4j
public class TableRow extends JPanel
{
    private static final int ICON_WIDTH = 35;

    Map<String, JLabel> labels = new HashMap<>();

    TableRow(String name, String formattedName, HiscoreSkillType type, String... labels)
    {
        setLayout(new BorderLayout());
        setBorder(new EmptyBorder(2, 0, 2, 0));
        setBackground(ColorScheme.DARKER_GRAY_COLOR);

        JPanel dataPanel = new JPanel(new GridLayout());
        dataPanel.setOpaque(false);

        final String directory;

        if (type == HiscoreSkillType.BOSS)
        {
            directory = "bosses/";
        }
        else if (type == HiscoreSkillType.ACTIVITY)
        {
            directory = "activities/";
        }
        else
        {
            directory = "/skill_icons_small/";
        }

        for (String l : labels)
        {
            dataPanel.add(createCell(l));
        }

        String iconDirectory = directory + name.toLowerCase() + ".png";
        log.debug("Loading icon for {}", iconDirectory);

        JPanel iconPanel = new JPanel(new BorderLayout());
        iconPanel.setOpaque(false);
        JLabel iconLabel = new JLabel("", SwingConstants.CENTER);
        iconPanel.add(iconLabel);

        ImageIcon icon = new ImageIcon(ImageUtil.loadImageResource(WomUtilsPlugin.class, iconDirectory));
        iconPanel.setPreferredSize(new Dimension(ICON_WIDTH, icon.getIconHeight()));

        iconLabel.setIcon(icon);
        iconLabel.setToolTipText(formattedName);

        add(iconPanel, BorderLayout.WEST);
        add(dataPanel);
    }

    private JLabel createCell(String l)
    {
        JLabel label = new JLabel("--", SwingConstants.CENTER);
        label.setFont(FontManager.getRunescapeSmallFont());

        labels.put(l, label);

        return label;
    }

    void update(Skill skill, boolean virtualLevels)
    {
        long experience = skill.getExperience();
        int level = skill.getLevel();
        int rank = skill.getRank();
        boolean ranked = rank != -1;
        double ehp = skill.getEhp();

        JLabel experienceLabel = labels.get("experience");
        experienceLabel.setText(experience > 0 ? Format.formatNumber(experience) : "--");
        experienceLabel.setToolTipText(experience > 0 ? QuantityFormatter.formatNumber(experience) : "");

        JLabel levelLabel = labels.get("level");
        int levelToDisplay = !virtualLevels && level > Experience.MAX_REAL_LEVEL ? Experience.MAX_REAL_LEVEL : level;
        levelLabel.setText(String.valueOf(levelToDisplay));
        levelLabel.setToolTipText(String.valueOf(levelToDisplay));

        JLabel rankLabel = labels.get("rank");
        rankLabel.setText(ranked ? Format.formatNumber(rank) : "--");
        rankLabel.setToolTipText(ranked ? QuantityFormatter.formatNumber(rank) : "Unranked");

        JLabel ehpLabel = labels.get("ehp");
        ehpLabel.setText(Format.formatNumber(ehp));
        ehpLabel.setToolTipText(QuantityFormatter.formatNumber(ehp));
    }

    void update(Boss boss, HiscoreSkill b)
    {
        int kills = boss.getKills();
        int minimumKc = Utils.getMinimumKc(b);
        boolean ranked = kills >= minimumKc;

        int rank = boss.getRank();
        double ehb = boss.getEhb();

        JLabel killsLabel = labels.get("kills");
        killsLabel.setText(ranked ? Format.formatNumber(kills) : "< " + minimumKc);
        killsLabel.setToolTipText(ranked ? QuantityFormatter.formatNumber(kills) : "The Hiscores only start tracking " + b.getName() + " after " + minimumKc + " kc");

        JLabel rankLabel = labels.get("rank");
        rankLabel.setText(ranked ? Format.formatNumber(rank) : "--");
        rankLabel.setToolTipText(ranked ? QuantityFormatter.formatNumber(rank) : "Unranked");

        JLabel ehbLabel = labels.get("ehb");
        ehbLabel.setText(Format.formatNumber(ehb));
        ehbLabel.setToolTipText(QuantityFormatter.formatNumber(ehb));
    }

    void update(Activity minigame)
    {
        int score = minigame.getScore();
        int rank = minigame.getRank();
        boolean ranked = rank != -1;

        JLabel killsLabel = labels.get("score");
        killsLabel.setText(ranked ? Format.formatNumber(score) : "--");
        killsLabel.setToolTipText(ranked ? QuantityFormatter.formatNumber(score) : "");

        JLabel rankLabel = labels.get("rank");
        rankLabel.setText(ranked ? Format.formatNumber(rank) : "--");
        rankLabel.setToolTipText(ranked ? QuantityFormatter.formatNumber(rank) : "Unranked");
    }
}

package net.wiseoldman.panel;

import com.google.common.base.Strings;
import java.util.List;
import java.util.Set;
import java.util.stream.Collectors;
import net.runelite.api.WorldType;
import net.runelite.client.ui.components.PluginErrorPanel;
import net.wiseoldman.WomUtilsConfig;
import net.wiseoldman.WomUtilsPlugin;
import net.wiseoldman.beans.Competition;
import net.wiseoldman.beans.GroupInfo;
import net.wiseoldman.beans.ParticipantWithCompetition;
import net.wiseoldman.beans.ParticipantWithStanding;
import net.wiseoldman.beans.PlayerInfo;
import net.wiseoldman.web.WomRequestType;
import net.wiseoldman.web.WomClient;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.Player;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.FontManager;
import net.runelite.client.ui.PluginPanel;
import net.runelite.client.ui.components.IconTextField;
import net.runelite.client.ui.components.materialtabs.MaterialTab;
import net.runelite.client.ui.components.materialtabs.MaterialTabGroup;
import net.runelite.client.util.LinkBrowser;
import okhttp3.HttpUrl;

import javax.inject.Inject;
import javax.swing.*;
import javax.swing.border.EmptyBorder;
import java.awt.*;
import java.awt.event.KeyListener;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.util.ArrayList;

@Slf4j
public class WomPanel extends PluginPanel
{
	@Inject
	private Client client;

	@Inject
	private WomUtilsPlugin plugin;

	/* The maximum allowed username length in RuneScape accounts */
	private static final int MAX_USERNAME_LENGTH = 12;
	private static final String DEFAULT_GROUP_FILTER = "All";
	private static final String FETCHING_ERROR_TEMPLATE =
		"<html><body  style='color:#FF0000; text-align:center;'>Failed to load %s competitions</body></html>";

	private final SkillingPanel skillingPanel;
	private final BossingPanel bossingPanel;
	private final ActivitiesPanel activitiesPanel;
	private final PluginErrorPanel competitionsErrorPanel;
	public final PluginErrorPanel noCompetitionsErrorPanel;
	private final JPanel ongoingCompetitionsPanel;
	private final JPanel upComingCompetitionsPanel;
	private final JPanel groupFilterPanel = new JPanel();
	private final JComboBox<String> groupFilter = new JComboBox<>(new String[]{DEFAULT_GROUP_FILTER});

	private final MaterialTabGroup topTabGroup;

	private final NameAutocompleter nameAutocompleter;
	private final MaterialTab lookupTab;
	private final WomClient womClient;
	private final WomUtilsConfig config;

	private IconTextField searchBar;

	private final java.util.List<MiscInfoLabel> miscInfoLabels = new ArrayList<>();
	private final java.util.List<JButton> buttons = new ArrayList<>();
	private final List<CompetitionCardPanel> competitionCardPanels = new ArrayList<>();

	public boolean active;
	boolean nonGroupCompetitions = false;

	@Inject
	public WomPanel(Client client, WomUtilsPlugin plugin, NameAutocompleter nameAutocompleter, WomClient womClient, WomUtilsConfig config,
					SkillingPanel skillingPanel, BossingPanel bossingPanel, ActivitiesPanel activitiesPanel)
	{
		this.client = client;
		this.plugin = plugin;
		this.nameAutocompleter = nameAutocompleter;
		this.womClient = womClient;
		this.config = config;
		this.skillingPanel = skillingPanel;
		this.bossingPanel = bossingPanel;
		this.activitiesPanel = activitiesPanel;


		// The layout seems to be ignoring the top margin and only gives it
		// a 2-3 pixel margin, so I set the value to 18 to compensate
		// TODO: Figure out why this layout is ignoring most of the top margin
		setBorder(new EmptyBorder(18, 10, 0, 10));
		setBackground(ColorScheme.DARK_GRAY_COLOR);
		setLayout(new GridBagLayout());

		// Expand sub items to fit width of panel, align to top of panel
		GridBagConstraints c = new GridBagConstraints();
		c.fill = GridBagConstraints.HORIZONTAL;
		c.gridx = 0;
		c.gridy = 0;
		c.weightx = 1;
		c.weighty = 0;
		c.insets = new Insets(0, 0, 10, 0);

		JPanel competitionsPanel = new JPanel();
		competitionsPanel.setLayout(new BoxLayout(competitionsPanel, BoxLayout.Y_AXIS));

		competitionsErrorPanel = new PluginErrorPanel();
		competitionsErrorPanel.setContent("No competitions found", "Please log in to load your ongoing and upcoming competitions.");

		noCompetitionsErrorPanel = new PluginErrorPanel();
		noCompetitionsErrorPanel.setContent("No competitions found", "You are not participating in any competitions.");
		noCompetitionsErrorPanel.setVisible(false);

		ongoingCompetitionsPanel = new JPanel();
		ongoingCompetitionsPanel.setLayout(new BoxLayout(ongoingCompetitionsPanel, BoxLayout.Y_AXIS));

		upComingCompetitionsPanel = new JPanel();
		upComingCompetitionsPanel.setLayout(new BoxLayout(upComingCompetitionsPanel, BoxLayout.Y_AXIS));

		JLabel groupFilterLabel = new JLabel("<html><body><p text-align:left;'>Filter by group</p</body></html>");
		groupFilterLabel.setFont(FontManager.getRunescapeSmallFont());
		groupFilterLabel.setAlignmentX(Component.CENTER_ALIGNMENT);
		groupFilterLabel.setBorder(new EmptyBorder(0, -1, 5, 0));

		groupFilter.setFont(FontManager.getRunescapeSmallFont());
		groupFilter.setAlignmentX(Component.CENTER_ALIGNMENT);
		groupFilter.setSelectedItem(DEFAULT_GROUP_FILTER);
		groupFilter.addActionListener(e -> {
			String selectedFilter = (String) groupFilter.getSelectedItem();
			filterCompetitions(selectedFilter);
		});

		groupFilterPanel.setLayout(new BoxLayout(groupFilterPanel, BoxLayout.Y_AXIS));
		groupFilterPanel.add(groupFilterLabel);
		groupFilterPanel.add(groupFilter);
		groupFilterPanel.setVisible(false);

		competitionsPanel.add(groupFilterPanel);
		competitionsPanel.add(competitionsErrorPanel);
		competitionsPanel.add(noCompetitionsErrorPanel);
		competitionsPanel.add(ongoingCompetitionsPanel);
		competitionsPanel.add(upComingCompetitionsPanel);

		// Holds currently visible tab
		JPanel topDisplay = new JPanel();
		topTabGroup = new MaterialTabGroup(topDisplay);
		lookupTab = new MaterialTab("Lookup", topTabGroup, createLookupPanel());
		MaterialTab competitionsTab = new MaterialTab("Competitions", topTabGroup, competitionsPanel);

		topTabGroup.setBorder(new EmptyBorder(0, 0, 0, 0));
		topTabGroup.addTab(competitionsTab);
		topTabGroup.addTab(lookupTab);
		topTabGroup.select(competitionsTab);

		add(topTabGroup, c);
		c.gridy++;
		add(topDisplay, c);

		addInputKeyListener(nameAutocompleter);
	}

	public void shutdown()
	{
		removeInputKeyListener(nameAutocompleter);
	}

	@Override
	public void onActivate()
	{
		super.onActivate();
		searchBar.requestFocusInWindow();
		active = true;
	}

	@Override
	public void onDeactivate()
	{
		super.onDeactivate();
		active = false;
	}

	private void toggleButtons(boolean enabled)
	{
		for (JButton button : buttons)
		{
			button.setEnabled(enabled);
		}
	}

	public void lookup(String username)
	{
		searchBar.setText(username);
		topTabGroup.select(lookupTab);
		lookup();
	}

	private void lookup()
	{
		final String lookup = sanitize(searchBar.getText());
		toggleButtons(false);

		if (Strings.isNullOrEmpty(lookup))
		{
			return;
		}

		/* RuneScape usernames can't be longer than 12 characters long */
		if (lookup.length() > MAX_USERNAME_LENGTH)
		{
			searchBar.setIcon(IconTextField.Icon.ERROR);
			return;
		}

		searchBar.setEditable(false);
		searchBar.setIcon(IconTextField.Icon.LOADING_DARKER);

		resetOverview();
		skillingPanel.reset();
		bossingPanel.reset();
		activitiesPanel.reset();

		womClient.lookupAsync(lookup).whenCompleteAsync((result, ex) -> updateAfterSearch(lookup, result, ex));
	}

	private void updateAfterSearch(String lookup, PlayerInfo result, Throwable ex)
	{
		SwingUtilities.invokeLater(() ->
		{
			if (!sanitize(searchBar.getText()).equals(lookup))
			{
				// search has changed in the meantime
				return;
			}

			toggleButtons(true);

			if (result == null || ex != null)
			{
				if (ex != null)
				{
					log.warn("Error fetching Wise Old Man data " + ex.getMessage());
				}

				searchBar.setIcon(IconTextField.Icon.ERROR);
				searchBar.setEditable(true);

				// Track option
				return;
			}

			if (result.getLatestSnapshot() == null)
			{
				log.warn("Player on WOM without snapshot {}.", lookup);
				searchBar.setIcon(IconTextField.Icon.ERROR);
				searchBar.setEditable(true);

				// Update option
				return;
			}

			//successful player search
			searchBar.setIcon(IconTextField.Icon.SEARCH);
			searchBar.setEditable(true);

			applyResult(result);
		});
	}

	private void applyOverviewResult(PlayerInfo result)
	{
		for (MiscInfoLabel infoLabel : miscInfoLabels)
		{
			infoLabel.format(result, config.relativeTime());
		}
	}

	private void resetOverview()
	{
		for (MiscInfoLabel infoLabel : miscInfoLabels)
		{
			infoLabel.reset();
		}
	}

	private void applyResult(PlayerInfo result)
	{
		assert SwingUtilities.isEventDispatchThread();

		nameAutocompleter.addToSearchHistory(result.getUsername());

		applyOverviewResult(result);
		skillingPanel.update(result);
		bossingPanel.update(result);
		activitiesPanel.update(result);
	}

	void addInputKeyListener(KeyListener l)
	{
		this.searchBar.addKeyListener(l);
	}

	void removeInputKeyListener(KeyListener l)
	{
		this.searchBar.removeKeyListener(l);
	}

	private static String sanitize(String lookup)
	{
		return lookup.replace('\u00A0', ' ');
	}

	private void openPlayerProfile(String username)
	{
		String url = new HttpUrl.Builder()
			.scheme("https")
			.host(client.getWorldType().contains(WorldType.SEASONAL) ? "league.wiseoldman.net" : "wiseoldman.net")
			.addPathSegment("players")
			.addPathSegment(username)
			.build()
			.toString();

		SwingUtilities.invokeLater(() -> LinkBrowser.browse(url));
	}

	private JPanel createLookupPanel()
	{
		JPanel lookupPanel = new JPanel();
		lookupPanel.setLayout(new GridBagLayout());
		lookupPanel.setBorder(new EmptyBorder(0, 0, 0, 0));

		GridBagConstraints c = new GridBagConstraints();
		c.fill = GridBagConstraints.HORIZONTAL;
		c.gridx = 0;
		c.gridy = 0;
		c.weightx = 1;
		c.weighty = 0;
		c.insets = new Insets(0, 0, 10, 0);

		searchBar = new IconTextField();
		searchBar.setIcon(IconTextField.Icon.SEARCH);
		searchBar.setPreferredSize(new Dimension(PluginPanel.PANEL_WIDTH - 20, 30));
		searchBar.setBackground(ColorScheme.DARKER_GRAY_COLOR);
		searchBar.setHoverBackgroundColor(ColorScheme.DARK_GRAY_HOVER_COLOR);
		searchBar.setMinimumSize(new Dimension(0, 30));
		searchBar.addActionListener(e -> lookup());
		searchBar.addMouseListener(new MouseAdapter()
		{
			@Override
			public void mouseClicked(MouseEvent e)
			{
				if (e.getClickCount() != 2)
				{
					return;
				}
				if (client == null)
				{
					return;
				}

				Player localPlayer = client.getLocalPlayer();

				if (localPlayer != null)
				{
					lookup(localPlayer.getName());
				}
			}
		});
		searchBar.addClearListener(() ->
		{
			searchBar.setIcon(IconTextField.Icon.SEARCH);
			searchBar.setEditable(true);
			toggleButtons(false);
		});

		lookupPanel.add(searchBar, c);
		c.gridy++;

		lookupPanel.add(createButtonsPanel(), c);
		c.gridy++;

		JLabel overviewTitle = new JLabel("Overview");
		overviewTitle.setFont(FontManager.getRunescapeBoldFont());
		lookupPanel.add(overviewTitle, c);
		c.gridy++;

		lookupPanel.add(createOverViewPanel(), c);
		c.gridy++;

		MiscInfoLabel lastUpdated = new MiscInfoLabel(MiscInfo.LAST_UPDATED);
		miscInfoLabels.add(lastUpdated);
		lookupPanel.add(lastUpdated, c);
		c.gridy++;

		// Holds currently visible tab
		JPanel display = new JPanel();
		MaterialTabGroup tabGroup = new MaterialTabGroup(display);
		MaterialTab skillingTab = new MaterialTab("Skills", tabGroup, skillingPanel);
		MaterialTab bossingTab = new MaterialTab("Bosses", tabGroup, bossingPanel);
		MaterialTab activitiesTab = new MaterialTab("Activities", tabGroup, activitiesPanel);

		tabGroup.setBorder(new EmptyBorder(10, 0, 0, 0));
		tabGroup.addTab(skillingTab);
		tabGroup.addTab(bossingTab);
		tabGroup.addTab(activitiesTab);
		tabGroup.select(skillingTab);

		lookupPanel.add(tabGroup, c);
		c.gridy++;
		lookupPanel.add(display, c);
		c.gridy++;

		return lookupPanel;
	}

	private JPanel createButtonsPanel()
	{
		JPanel buttonsPanel = new JPanel();
		buttonsPanel.setLayout(new GridBagLayout());
		buttonsPanel.setBorder(new EmptyBorder(0, 0, 10, 0));

		GridBagConstraints gbc = new GridBagConstraints();
		gbc.fill = GridBagConstraints.HORIZONTAL;
		gbc.gridx = 0;
		gbc.weightx = 1;
		gbc.ipady = 10;

		JButton updateButton = new JButton();
		updateButton.setFont(FontManager.getRunescapeSmallFont());
		updateButton.setEnabled(false);
		updateButton.addActionListener(e ->
			womClient.updateAsync(sanitize(searchBar.getText())).whenCompleteAsync((result, ex) ->
			{
				updateAfterSearch(sanitize(searchBar.getText()), result, ex);
			}));
		updateButton.setText("Update");

		JButton profileButton = new JButton();
		profileButton.setFont(FontManager.getRunescapeSmallFont());
		profileButton.setEnabled(false);
		profileButton.addActionListener(e ->
			openPlayerProfile(sanitize(searchBar.getText())));
		profileButton.setText("Open Profile");

		buttons.add(updateButton);
		buttons.add(profileButton);

		buttonsPanel.add(updateButton, gbc);
		gbc.gridx++;
		gbc.insets.left = 7;
		buttonsPanel.add(profileButton, gbc);

		return buttonsPanel;
	}

	private JPanel createOverViewPanel()
	{
		JPanel miscInfoPanel = new JPanel();
		miscInfoPanel.setLayout(new GridLayout(3, 2, 5, 5));

		for (MiscInfo info : MiscInfo.values())
		{
			if (info != MiscInfo.LAST_UPDATED)
			{
				MiscInfoLabel miscInfoLabel = new MiscInfoLabel(info);
				miscInfoLabels.add(miscInfoLabel);
				miscInfoPanel.add(miscInfoLabel);
			}
		}
		return miscInfoPanel;
	}

	public void addOngoingCompetitions(List<ParticipantWithStanding> competitions)
	{
		ongoingCompetitionsPanel.removeAll();

		JPanel ongoingCompetitions = new JPanel();
		ongoingCompetitions.setLayout(new BoxLayout(ongoingCompetitions, BoxLayout.Y_AXIS));

		// Remove any competition from canvas list that are no longer in the newly fetched competitions list
		Set<Integer> currentOngoing = competitions.stream().map(ParticipantWithStanding::getCompetitionId).collect(Collectors.toSet());
		plugin.clearOldCanvasCompetitions(currentOngoing, true);

		for (ParticipantWithStanding c : competitions)
		{
			CompetitionCardPanel competitionPanel = new CompetitionCardPanel(client, plugin, c);
			competitionCardPanels.add(competitionPanel);
			ongoingCompetitions.add(competitionPanel);

			if (plugin.competitionsOnCanvas.stream().anyMatch(cc -> cc.getId() == c.getCompetitionId()) ||
				config.addCompetitionsToCanvas().equals(WomUtilsConfig.CompetitionsToAddToCanvas.ONGOING) ||
				config.addCompetitionsToCanvas().equals(WomUtilsConfig.CompetitionsToAddToCanvas.BOTH))
			{
				plugin.addInfoBox(competitionPanel);
			}
		}

		if (competitionsErrorPanel.isVisible() && !competitionCardPanels.isEmpty())
		{
			competitionsErrorPanel.setVisible(false);
		}

		ongoingCompetitionsPanel.add(ongoingCompetitions);
	}

	public void addUpcomingCompetitions(List<ParticipantWithCompetition> competitions)
	{
		upComingCompetitionsPanel.removeAll();

		JPanel upcomingCompetitions = new JPanel();
		upcomingCompetitions.setLayout(new BoxLayout(upcomingCompetitions, BoxLayout.Y_AXIS));

		// Remove any competition from canvas list that are no longer in the newly fetched competitions list
		Set<Integer> currentUpcoming = competitions.stream().map(ParticipantWithCompetition::getCompetitionId).collect(Collectors.toSet());
		plugin.clearOldCanvasCompetitions(currentUpcoming, false);

		for (ParticipantWithCompetition c : competitions)
		{
			CompetitionCardPanel competitionPanel = new CompetitionCardPanel(client, plugin, c);
			competitionCardPanels.add(competitionPanel);
			upcomingCompetitions.add(competitionPanel);

			if (plugin.competitionsOnCanvas.stream().anyMatch(cc -> cc.getId() == c.getCompetitionId()) ||
				config.addCompetitionsToCanvas().equals(WomUtilsConfig.CompetitionsToAddToCanvas.UPCOMING) ||
				config.addCompetitionsToCanvas().equals(WomUtilsConfig.CompetitionsToAddToCanvas.BOTH))
			{
				plugin.addInfoBox(competitionPanel);
			}
		}


		if (competitionsErrorPanel.isVisible() && !competitionCardPanels.isEmpty())
		{
			competitionsErrorPanel.setVisible(false);
		}

		upComingCompetitionsPanel.add(upcomingCompetitions);
	}

	public void displayCompetitionFetchError(WomRequestType type, String username)
	{
		JPanel retryPanel = new JPanel();
		retryPanel.setLayout(new BorderLayout());
		retryPanel.setBorder(new EmptyBorder(20, 0, 20, 0));
		JLabel errorLabel = new JLabel(String.format(FETCHING_ERROR_TEMPLATE, type.getName()), SwingConstants.CENTER);
		errorLabel.setFont(FontManager.getRunescapeSmallFont());

		JPanel buttonPanel = new JPanel(new FlowLayout(FlowLayout.CENTER));
		JButton retryButton = new JButton();
		retryButton.setFont(FontManager.getRunescapeSmallFont());
		retryButton.setText("Retry");
		buttonPanel.add(retryButton);

		retryPanel.add(errorLabel, BorderLayout.CENTER);
		retryPanel.add(buttonPanel, BorderLayout.SOUTH);
		competitionsErrorPanel.setVisible(false);
		if (type == WomRequestType.COMPETITIONS_UPCOMING)
		{
			upComingCompetitionsPanel.removeAll();
			retryButton.addActionListener(e ->
				womClient.fetchUpcomingPlayerCompetitions(username)
			);
			upComingCompetitionsPanel.add(retryPanel);
		}
		else if (type == WomRequestType.COMPETITIONS_ONGOING)
		{
			ongoingCompetitionsPanel.removeAll();
			retryButton.addActionListener(e ->
				womClient.fetchOngoingPlayerCompetitions(username)
			);
			ongoingCompetitionsPanel.add(retryPanel);
		}
	}

	private void filterCompetitions(String filter)
	{
		for (CompetitionCardPanel p : competitionCardPanels)
		{
			GroupInfo group = p.getCompetition().getGroup();
			p.setVisible(filter.equals(DEFAULT_GROUP_FILTER) || (group != null && group.getName().equals(filter)));
		}
	}

	public void addGroupFilters(Competition[] competitions)
	{
		for (Competition c : competitions)
		{
			GroupInfo group = c.getGroup();
			if (group != null && !filterContainsItem(group.getName()))
			{
				groupFilter.addItem(group.getName());
			}

			nonGroupCompetitions = nonGroupCompetitions || group == null;

		}

		// > 2 because of the default "All" option always being included.
		int itemCount = groupFilter.getItemCount();
		if (itemCount > 2 || (itemCount == 2 && nonGroupCompetitions))
		{
			groupFilterPanel.setVisible(true);
		}
	}

	public void resetGroupFilter()
	{
		groupFilter.removeAllItems();
		groupFilter.addItem(DEFAULT_GROUP_FILTER);
		groupFilter.setSelectedItem(DEFAULT_GROUP_FILTER);
		groupFilter.revalidate();
		groupFilterPanel.setVisible(false);
	}

	public void resetCompetitionsPanel()
	{
		competitionCardPanels.clear();
		ongoingCompetitionsPanel.removeAll();
		upComingCompetitionsPanel.removeAll();
		competitionsErrorPanel.setVisible(true);
		noCompetitionsErrorPanel.setVisible(false);
	}

	public void updateCompetitionCountdown()
	{
		for (CompetitionCardPanel p : competitionCardPanels)
		{
			SwingUtilities.invokeLater(p::updateCountDown);
		}
	}

	private boolean filterContainsItem(String item)
	{
		for (int i = 0; i < groupFilter.getItemCount(); i++)
		{
			if (groupFilter.getItemAt(i).equals(item))
			{
				return true;
			}
		}

		return false;
	}

	public void showNoCompetitionsError()
	{
		competitionsErrorPanel.setVisible(false);
		noCompetitionsErrorPanel.setVisible(true);
	}
}

package net.wiseoldman.panel;

import com.google.common.collect.ImmutableList;
import net.wiseoldman.util.Format;
import net.wiseoldman.beans.PlayerInfo;
import net.wiseoldman.beans.Snapshot;
import net.wiseoldman.beans.Computed;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.util.QuantityFormatter;
import net.runelite.client.hiscore.HiscoreSkill;
import net.runelite.client.hiscore.HiscoreSkillType;

import javax.inject.Inject;
import javax.swing.*;
import java.awt.*;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;

import static net.runelite.client.hiscore.HiscoreSkill.*;

class BossingPanel extends JPanel
{
	/**
	 * Bosses, ordered in the way they should be displayed in the panel.
	 */
	private static final List<HiscoreSkill> BOSSES = ImmutableList.of(
		ABYSSAL_SIRE, ALCHEMICAL_HYDRA, AMOXLIATL, ARAXXOR, ARTIO, BARROWS_CHESTS,
		BRYOPHYTA, CALLISTO, CALVARION, CERBERUS,
		CHAMBERS_OF_XERIC, CHAMBERS_OF_XERIC_CHALLENGE_MODE, CHAOS_ELEMENTAL,
		CHAOS_FANATIC, COMMANDER_ZILYANA, CORPOREAL_BEAST,
		DAGANNOTH_PRIME, DAGANNOTH_REX, DAGANNOTH_SUPREME,
		CRAZY_ARCHAEOLOGIST, DERANGED_ARCHAEOLOGIST, DOOM_OF_MOKHAIOTL, DUKE_SUCELLUS,
		GENERAL_GRAARDOR, GIANT_MOLE, GROTESQUE_GUARDIANS, HESPORI,
		KALPHITE_QUEEN, KING_BLACK_DRAGON, KRAKEN, KREEARRA,
		KRIL_TSUTSAROTH, LUNAR_CHESTS, MIMIC, NEX, NIGHTMARE, PHOSANIS_NIGHTMARE,
		OBOR, PHANTOM_MUSPAH, SARACHNIS, SCORPIA, SCURRIUS, SKOTIZO, SOL_HEREDIT,
		SPINDEL, TEMPOROSS, THE_GAUNTLET, THE_CORRUPTED_GAUNTLET, THE_HUEYCOATL,
		THE_LEVIATHAN, THE_ROYAL_TITANS, THE_WHISPERER, THEATRE_OF_BLOOD,
		THEATRE_OF_BLOOD_HARD_MODE, THERMONUCLEAR_SMOKE_DEVIL, TOMBS_OF_AMASCUT,
		TOMBS_OF_AMASCUT_EXPERT, TZKAL_ZUK, TZTOK_JAD, VARDORVIS, VENENATIS,
		VETION, VORKATH, WINTERTODT, YAMA, ZALCANO, ZULRAH
	);
	static Color[] ROW_COLORS = {ColorScheme.DARKER_GRAY_COLOR, new Color(34, 34, 34)};

	TableRow totalEhbRow;
	List<RowPair> tableRows = new ArrayList<>();

	@Inject
	private BossingPanel()
	{
		setLayout(new GridLayout(0, 1));

		StatsTableHeader tableHeader = new StatsTableHeader("bossing");

		// Handle total ehb row separately because it's special
		totalEhbRow = new TableRow(
			"ehb", "EHB", HiscoreSkillType.BOSS,
			"kills", "rank", "ehb"
		);
		totalEhbRow.setBackground(ROW_COLORS[1]);

		add(tableHeader);
		add(totalEhbRow);

		for (int i = 0; i < BOSSES.size(); i++)
		{
			HiscoreSkill boss = BOSSES.get(i);
			TableRow row = new TableRow(
				boss.name(), boss.getName(), HiscoreSkillType.BOSS,
				"kills", "rank", "ehb"
			);
			row.setBackground(ROW_COLORS[i % 2]);

			tableRows.add(new RowPair(boss, row));
			add(row);
		}
	}

	public void update(PlayerInfo info)
	{
		if (info == null)
		{
			return;
		}

		Snapshot latestSnapshot = info.getLatestSnapshot();

		for (RowPair rp : tableRows)
		{
			HiscoreSkill boss = rp.getSkill();
			TableRow row = rp.getRow();

			row.update(latestSnapshot.getData().getBosses().getBoss(boss), boss);
		}

		updateTotalEhb(latestSnapshot.getData().getComputed().getEhb());
	}

	private void updateTotalEhb(Computed ehb)
	{
		JLabel rankLabel = totalEhbRow.labels.get("rank");
		JLabel ehbLabel = totalEhbRow.labels.get("ehb");

		int rank = ehb.getRank();
		double value = ehb.getValue();

		rankLabel.setText(Format.formatNumber(rank));
		rankLabel.setToolTipText(QuantityFormatter.formatNumber(rank));

		ehbLabel.setText(Format.formatNumber(value));
		ehbLabel.setToolTipText(QuantityFormatter.formatNumber(value));
	}

	public void reset()
	{
		for (Map.Entry<String, JLabel> entry : totalEhbRow.labels.entrySet())
		{
			JLabel label = entry.getValue();
			label.setText("--");
			label.setToolTipText("");
		}

		for (RowPair rp : tableRows)
		{
			TableRow row = rp.getRow();

			for (Map.Entry<String, JLabel> e : row.labels.entrySet())
			{
				JLabel label = e.getValue();
				label.setText("--");
				label.setToolTipText("");
			}
		}
	}
}

package net.wiseoldman.panel;

import lombok.Value;

import javax.swing.*;

@Value
public class InfoLabel
{
    String rawString;
    JLabel label;
}

package net.wiseoldman.panel;


import net.wiseoldman.beans.PlayerBuild;
import net.wiseoldman.ui.CountryIcon;
import net.wiseoldman.util.Format;
import net.wiseoldman.util.Utils;
import net.wiseoldman.beans.PlayerInfo;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.FontManager;

import javax.swing.*;
import javax.swing.border.EmptyBorder;

public class MiscInfoLabel extends JLabel
{
    MiscInfo info;

    public MiscInfoLabel(MiscInfo info)
    {
        this.info = info;

        setFont(FontManager.getRunescapeSmallFont());
        setBorder(new EmptyBorder(5, 10, 5, 5));
        setText(info.getDefaultText());
        setToolTipText(info.getHoverText());

        if (info != MiscInfo.LAST_UPDATED)
        {
            setBackground(ColorScheme.DARKER_GRAY_COLOR);
            setOpaque(true);
            setIcon(info.getIcon());
        }
        else
        {
            setHorizontalAlignment(JLabel.CENTER);
        }
    }

    public void format(PlayerInfo result, boolean relative)
    {
        switch (info)
        {
            case COUNTRY:
                String country = result.getCountry();
                String countryText = country == null ? "--" : country;
                String countryCode = country == null ? "default" : country.toLowerCase();
                setIcon(CountryIcon.loadSquareImage(countryCode));
                setText(countryText);
                break;
            case BUILD:
                PlayerBuild build = result.getBuild();
                String buildText = build == null ? PlayerBuild.MAIN.toString() : build.toString();
                setText(buildText);
                setIcon(Utils.getIcon(result.getType()));
                break;
            case TTM:
                setText(Format.formatNumber(result.getTtm()) + 'h');
                break;
            case EHP:
                setText(Format.formatNumber(result.getEhp()));
                break;
            case EHB:
                setText(Format.formatNumber(result.getEhb()));
                break;
            case EXP:
                long experience = result.getExp();
                setText(experience > 0 ? Format.formatNumber(experience) : "--");
                break;
            case LAST_UPDATED:
                setText(info.getHoverText() + " " + Format.formatDate(result.getUpdatedAt(), relative));
                break;
        }
    }

    public void reset()
    {
        if (info == MiscInfo.COUNTRY || info == MiscInfo.BUILD)
        {
            setIcon(info.getIcon());
        }
        setText(info.getDefaultText());
    }
}
package net.wiseoldman.panel;

import com.google.common.collect.ImmutableList;
import net.wiseoldman.beans.PlayerInfo;
import net.wiseoldman.beans.Snapshot;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.hiscore.HiscoreSkill;
import net.runelite.client.hiscore.HiscoreSkillType;

import javax.inject.Inject;
import javax.swing.*;
import java.awt.*;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;

import static net.runelite.client.hiscore.HiscoreSkill.*;

public class ActivitiesPanel extends JPanel
{
	/**
	 * Activities, ordered in the way they should be displayed in the panel
	 */
	private static final List<HiscoreSkill> ACTIVITIES = ImmutableList.of(
		LEAGUE_POINTS, BOUNTY_HUNTER_HUNTER, BOUNTY_HUNTER_ROGUE,
		CLUE_SCROLL_ALL, CLUE_SCROLL_BEGINNER, CLUE_SCROLL_EASY,
		CLUE_SCROLL_MEDIUM, CLUE_SCROLL_HARD, CLUE_SCROLL_ELITE,
		CLUE_SCROLL_MASTER, LAST_MAN_STANDING, PVP_ARENA_RANK,
		SOUL_WARS_ZEAL, RIFTS_CLOSED, COLOSSEUM_GLORY, COLLECTIONS_LOGGED
	);
	static Color[] ROW_COLORS = {ColorScheme.DARKER_GRAY_COLOR, new Color(34, 34, 34)};

	List<RowPair> tableRows = new ArrayList<>();

	@Inject
	private ActivitiesPanel()
	{
		setLayout(new GridLayout(0, 1));

		StatsTableHeader tableHeader = new StatsTableHeader("activities");

		add(tableHeader);

		for (int i = 0; i < ACTIVITIES.size(); i++)
		{
			HiscoreSkill activity = ACTIVITIES.get(i);
			TableRow row = new TableRow(
				activity.name(), activity.getName(), HiscoreSkillType.ACTIVITY,
				"score", "rank"
			);
			row.setBackground(ROW_COLORS[1 - i % 2]);

			tableRows.add(new RowPair(activity, row));
			add(row);
		}
	}

	public void update(PlayerInfo info)
	{
		if (info == null)
		{
			return;
		}

		Snapshot latestSnapshot = info.getLatestSnapshot();

		for (RowPair rp : tableRows)
		{
			HiscoreSkill minigame = rp.getSkill();
			TableRow row = rp.getRow();

			row.update(latestSnapshot.getData().getActivities().getActivity(minigame));
		}
	}

	public void reset()
	{
		for (RowPair rp : tableRows)
		{
			TableRow row = rp.getRow();

			for (Map.Entry<String, JLabel> e : row.labels.entrySet())
			{
				JLabel label = e.getValue();
				label.setText("--");
				label.setToolTipText("");
			}
		}
	}
}

package net.wiseoldman.panel;

import com.google.common.base.Strings;
import net.wiseoldman.WomUtilsPlugin;
import lombok.Getter;
import net.runelite.client.util.ImageUtil;

import javax.swing.*;

@Getter
public enum MiscInfo
{
    BUILD("Build", "build.png"),
    COUNTRY("Country", "flags_square/default.png"),
    EHP("EHP", "ehp.png"),
	EHB("EHB", "bosses/ehb.png"),
	EXP("Exp", "overall.png"),
	TTM("TTM", "ttm.png"),
    LAST_UPDATED("Last updated", null, "Last updated --");

    private final String hoverText;
    private final ImageIcon icon;
    private final String defaultText;

    MiscInfo(String hoverText, String iconPath, String defaultText)
	{
		this.hoverText = hoverText;
		this.icon = !Strings.isNullOrEmpty(iconPath) ? new ImageIcon(ImageUtil.loadImageResource(WomUtilsPlugin.class, iconPath)) : null;
		this.defaultText = !Strings.isNullOrEmpty(defaultText) ? defaultText : "--";
	}

    MiscInfo(String hoverText, String iconPath)
    {
    	this(hoverText, iconPath, null);
    }
}
package net.wiseoldman;

import net.runelite.client.RuneLite;
import net.runelite.client.externalplugins.ExternalPluginManager;

public class WomUtilsPluginTest
{
	public static void main(String[] args) throws Exception
	{
		ExternalPluginManager.loadBuiltin(WomUtilsPlugin.class);
		RuneLite.main(args);
	}
}
