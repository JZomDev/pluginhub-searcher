/*
 * Copyright (c) 2022, Damen <gh: damencs>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:

 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.

 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.

 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.tobqol.api.util;

import lombok.AccessLevel;
import lombok.NoArgsConstructor;
import net.runelite.api.Client;
import net.runelite.api.Perspective;
import net.runelite.api.coords.LocalPoint;
import net.runelite.api.coords.WorldPoint;

import java.awt.*;
import java.util.Optional;

@NoArgsConstructor(access = AccessLevel.PRIVATE)
public final class PerspectiveUtil extends Perspective
{
	public static Optional<Polygon> toTilePoly(Client client, WorldPoint worldPoint)
	{
		if (client == null || worldPoint == null)
		{
			return Optional.empty();
		}

		LocalPoint localPoint = LocalPoint.fromWorld(client, worldPoint);
		if (localPoint == null)
		{
			return Optional.empty();
		}

		Polygon tile = getCanvasTilePoly(client, localPoint);
		return Optional.ofNullable(tile);
	}
}

/*
 * Copyright (c) 2022, Damen <gh: damencs>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:

 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.

 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.

 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.tobqol.api.util;

import com.tobqol.TheatreQOLConfig;
import com.tobqol.rooms.nylocas.NylocasHandler;
import net.runelite.client.input.MouseAdapter;

import javax.inject.Inject;
import java.awt.event.MouseEvent;

public class TheatreInputListener extends MouseAdapter
{
    @Inject
    private TheatreQOLConfig config;

    @Inject
    private NylocasHandler nylocas;

    @Override
    public MouseEvent mouseReleased(MouseEvent event)
    {
        if (nylocas.getNyloSelectionManager().isHidden())
        {
            return event;
        }

        if (nylocas.getNyloSelectionManager().getBounds().contains(event.getPoint()))
        {
            event.consume();
            return event;
        }

        return event;
    }

    @Override
    public MouseEvent mousePressed(MouseEvent event)
    {
        if (nylocas.getNyloSelectionManager().isHidden())
        {
            return event;
        }

        if (nylocas.getNyloSelectionManager().getBounds().contains(event.getPoint()))
        {
            event.consume();
            return event;
        }

        return event;
    }

    @Override
    public MouseEvent mouseClicked(MouseEvent event)
    {
        if (nylocas.getNyloSelectionManager().isHidden())
        {
            return event;
        }

        if (event.getButton() == MouseEvent.BUTTON1 && nylocas.getNyloSelectionManager().getBounds().contains(event.getPoint()))
        {
            boolean updated;

            if (nylocas.getNyloSelectionManager().getMeleeBounds().contains(event.getPoint()))
            {
                updated = !config.nyloRoleSelectedMelee();
                config.nyloSetRoleSelectedMelee(updated);
                nylocas.getNyloSelectionManager().getMelee().setSelected(updated);
                nylocas.setDisplayRoleMelee(updated);
            }
            else if (nylocas.getNyloSelectionManager().getRangeBounds().contains(event.getPoint()))
            {
                updated = !config.nyloRoleSelectedRange();
                config.nyloSetRoleSelectedRange(updated);
                nylocas.getNyloSelectionManager().getRange().setSelected(updated);
                nylocas.setDisplayRoleRange(updated);
            }
            else if (nylocas.getNyloSelectionManager().getMageBounds().contains(event.getPoint()))
            {
                updated = !config.nyloRoleSelectedMage();
                config.nyloSetRoleSelectedMage(updated);
                nylocas.getNyloSelectionManager().getMage().setSelected(updated);
                nylocas.setDisplayRoleMage(updated);
            }

            event.consume();
        }
        return event;
    }

    @Override
    public MouseEvent mouseMoved(MouseEvent event)
    {
        if (nylocas.getNyloSelectionManager().isHidden())
        {
            return event;
        }

        nylocas.getNyloSelectionManager().getMelee().setHovered(false);
        nylocas.getNyloSelectionManager().getRange().setHovered(false);
        nylocas.getNyloSelectionManager().getMage().setHovered(false);

        if (nylocas.getNyloSelectionManager().getBounds().contains(event.getPoint()))
        {
            if (nylocas.getNyloSelectionManager().getMeleeBounds().contains(event.getPoint()))
            {
                nylocas.getNyloSelectionManager().getMelee().setHovered(true);
            }
            else if (nylocas.getNyloSelectionManager().getRangeBounds().contains(event.getPoint()))
            {
                nylocas.getNyloSelectionManager().getRange().setHovered(true);
            }
            else if (nylocas.getNyloSelectionManager().getMageBounds().contains(event.getPoint()))
            {
                nylocas.getNyloSelectionManager().getMage().setHovered(true);
            }
        }
        return event;
    }
}

/*
 * Copyright (c) 2022, Damen <gh: damencs>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:

 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.

 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.

 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.tobqol.api.util;

@FunctionalInterface
public interface TriConsumer<L, M, R>
{
	void accept(L l, M m, R r);
}

/*
 * Copyright (c) 2022, Damen <gh: damencs>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:

 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.

 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.

 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.tobqol.api.game;

import lombok.Getter;
import lombok.Setter;
import org.apache.commons.lang3.math.NumberUtils;

import java.awt.*;
import java.text.DecimalFormat;

@Getter
public class Health implements Comparable<Health>
{
	private final int base;

	@Setter
	private int current;

	public Health(int base)
	{
		this.base = base;
		this.current = base;
	}

	public boolean zero()
	{
		return current == 0;
	}

	public Health addHealth(int amount)
	{
		current = Math.min(current + amount, base);
		return this;
	}

	public Health removeHealth(int amount)
	{
		current = Math.max(current - amount, 0);
		return this;
	}

	public double percent()
	{
		return (double) current / (double) base;
	}

	public double truncatedPercent()
	{
		return NumberUtils.toDouble(new DecimalFormat("#.0").format(percent() * 100));
	}

	public Color color()
	{
		double percent = percent();

		if (percent > 1)
		{
			percent = 1;
		}
		else if (percent < 0)
		{
			percent = 0;
		}

		int r = (int) (255.0 * (1 - percent));
		int g = (int) (255.0 * percent);
		return new Color(r, g, 0, 0xFF);
	}

	@Override
	public int compareTo(Health o)
	{
		return Integer.compare(current, o.current);
	}
}

/*
 * Copyright (c) 2022, Damen <gh: damencs>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:

 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.

 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.

 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.tobqol.api.game;

import javax.annotation.Nullable;
import java.util.function.Predicate;
import java.util.function.Supplier;

public interface Instance
{
	enum Mode
	{
		STORY, REGULAR, HARD;

		public boolean isStoryMode()
		{
			return this == STORY;
		}

		public boolean isRegularMode()
		{
			return this == REGULAR;
		}

		public boolean isHardMode()
		{
			return this == HARD;
		}
	}

	@Nullable
	static Mode findFirstMode(Predicate<Mode> filter)
	{
		if (filter == null)
		{
			return null;
		}

		for (Mode mode : Mode.values())
		{
			if (filter.test(mode))
			{
				return mode;
			}
		}

		return null;
	}

	// Lazy set mode for performance, don't need to recall heavy functions on an already determined instanced-mode.
	boolean lazySetMode(Supplier<Mode> modeSupplier);
	@Nullable
	Mode mode();

	boolean isStoryMode();
	boolean isRegularMode();
	boolean isHardMode();

	Region getCurrentRegion();
	int getRaidStatus();
	boolean isInRaid();
	int getRoomStatus();

	int getPartyStatus();

	int getPartySize();
	int getDeathSize();
	int getTotalAlive();

	int getTickCycle();
	void resetTickCycle();

	int getBossHealth();
}

/*
 * Copyright (c) 2022, Damen <gh: damencs>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:

 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.

 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.

 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.tobqol.api.game;

import lombok.RequiredArgsConstructor;

@RequiredArgsConstructor
public enum Hitpoints
{
	MAIDEN(
			500,
			2625, 3062, 3500,
			2625, 3062, 3500 // Maiden's HP is identical to Regular Mode
	),
	MAIDEN_MATOMENOS(
			16,
			75, 87, 100,
			75, 87, 100 // Maiden's Matomenos HP is identical to Regular Mode
	),
	MAIDEN_BLOOD_SPAWN(
			0, // TODO -> Find Story Mode SOLO Base HP
			0, 0, 0, // TODO -> Find Regular Mode Base HP
			0, 0, 0 // TODO -> Find Hard Mode Base HP
	),
	BLOAT(
			320,
			1500, 1750, 2000,
			1800, 2100, 2400
	),
	NYLOCAS_BOSS(
			360,
			1875, 2187, 2500,
			0, 0, 0 // TODO -> Find Hard Mode Base HP
	),
	NYLOCAS_DEMI_BOSS(
			-1, //-> Demi-Boss doesn't spawn in Story Mode
			-1, -1, -1, //-> Demi-Boss doesn't spawn in Regular Mode
			0, 0, 0 // TODO -> Find Hard Mode Base HP
	),
	NYLOCAS_SMALL(
			2,
			8, 9, 11,
			0, 0, 0 // TODO -> Find Hard Mode Base HP
	),
	NYLOCAS_BIG(
			3,
			16, 19, 22,
			0, 0, 0 // TODO -> Find Hard Mode Base HP
	),
	SOTETSEG(
			560,
			3000, 3500, 4000,
			3000, 3500, 4000 // Sotetseg's HP is identical to Regular Mode
	),
	XARPUS(
			411,
			3810, 4445, 5080,
			0, 0, 0 // TODO -> Find Hard Mode Base HP
	),
	VERZIK_P1(
			300,
			0, 0, 0, // TODO -> Find Regular Mode Base HP
			0, 0, 0 // TODO -> Find Hard Mode Base HP
	),
	VERZIK_P2(
			400,
			2437, 2843, 3250,
			0, 0, 0 // TODO -> Find Hard Mode Base HP
	),
	VERZIK_P3(
			574,
			2437, 2843, 3250,
			0, 0, 0 // TODO -> Find Hard Mode Base HP
	),
	VERZIK_MATOMENOS(
			0, // TODO -> Find Story Mode SOLO Base HP
			150, 175, 200,
		0, 0, 0 // TODO -> Find Hard Mode Base HP
	),
	VERZIK_NYLOCAS(
			0, // TODO -> Find Story Mode SOLO Base HP
			0, 0, 0, // TODO -> Find Regular Mode Base HP
		0, 0, 0 // TODO -> Find Hard Mode Base HP
	);

	private final int sm_solo;
	private final int rg_trios, rg_fours, rg_fives;
	private final int hm_trios, hm_fours, hm_fives;

	public int getBaseHP(Instance instance)
	{
		if (instance == null)
		{
			return 0;
		}

		Instance.Mode mode = instance.mode();
		int partySize = instance.getPartySize();

		if (mode == null || partySize <= 0)
		{
			return 0;
		}

		// Story Mode HP scales linearly
		if (mode.isStoryMode())
		{
			return sm_solo * partySize;
		}

		switch (partySize)
		{
			case 5: return mode.isRegularMode() ? rg_fives : hm_fives;
			case 4: return mode.isRegularMode() ? rg_fours : hm_fours;
			default: return mode.isRegularMode() ? rg_trios : hm_trios;
		}
	}
}

package com.tobqol.api.game;

import com.google.common.collect.ImmutableSet;

import java.text.DecimalFormat;
import java.util.Set;

public interface RaidConstants
{
    DecimalFormat DECIMAL_FORMAT = new DecimalFormat("##0.0");

    int PRECISE_TIMER = 11866;
    int THEATRE_OF_BLOOD_ROOM_STATUS = 6447;
    int THEATRE_OF_BLOOD_BOSS_HP = 6448;
    int TOB_CHEST_UNLOOTED = 41435;
    int TOB_CHEST_LOOTED = 41436;
    int TOB_BANK_CHEST = 41437;
    int TOB_ENTRANCE = 32653;

    Set<Integer> VER_SINHAZA_REGIONS = ImmutableSet.of(
            14386,
            14642
    );

    Set<String> TOB_CHEST_TARGETS = ImmutableSet.of(
            "Stamina potion(4)",
            "Prayer potion(4)",
            "Saradomin brew(4)",
            "Super restore(4)",
            "Mushroom potato",
            "Shark",
            "Sea turtle",
            "Manta ray"
    );
}

/*
 * Copyright (c) 2022, Damen <gh: damencs>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:

 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.

 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.

 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.tobqol.api.game;

import com.google.common.collect.ImmutableMap;
import com.tobqol.rooms.bloat.commons.BloatTable;
import com.tobqol.rooms.maiden.commons.MaidenTable;
import com.tobqol.rooms.nylocas.commons.NylocasConstants;
import com.tobqol.rooms.sotetseg.commons.SotetsegTable;
import com.tobqol.rooms.verzik.commons.VerzikMap;
import com.tobqol.rooms.xarpus.commons.XarpusTable;
import lombok.Getter;
import lombok.RequiredArgsConstructor;
import lombok.experimental.Accessors;
import net.runelite.api.Client;
import net.runelite.api.Player;
import net.runelite.api.coords.LocalPoint;
import net.runelite.api.coords.WorldArea;
import net.runelite.api.coords.WorldPoint;

import javax.annotation.Nullable;
import java.util.Map;

@RequiredArgsConstructor
@Getter
@Accessors(fluent = true)
public enum Region
{
	LOBBY("Lobby", 12869, 0, 400, 552),
	MAIDEN(MaidenTable.BOSS_NAME_SIMPLE, 12613, 0, 392, 552, new WorldArea(3175, 4421, 4, 1, 0)),
	BLOAT(BloatTable.BOSS_NAME_SIMPLE, 13125, 0, 408, 552, new WorldArea(3268, 4446, 1, 4, 0)),
	NYLOCAS(NylocasConstants.BOSS_NAME, 13122, 0, 408, 528, new WorldArea(3304, 4274, 1, 4, 0)),
	SOTETSEG(SotetsegTable.BOSS_NAME, 13123, 0, 408, 536, new WorldArea(3278, 4292, 4, 1, 0)),
	SOTETSEG_MAZE(SotetsegTable.BOSS_NAME, 13379, 3, 416, 536),
	XARPUS(XarpusTable.BOSS_NAME, 12612, 1, 392, 544, new WorldArea(3169, 4400, 3, 1, 1)),
	VERZIK(VerzikMap.BOSS_NAME, 12611, 0, 392, 536),
	LOOT_ROOM("Loot Room", 12867, 0, 400, 536),
	UNKNOWN("Unknown");

	private final String prettyName;
	private final int regionId;
	private final int zone;
	private final @Nullable WorldArea imaginaryLine;

	private static final Map<Integer, Region> lookupMap;

	static
	{
		ImmutableMap.Builder<Integer, Region> builder = ImmutableMap.builder();

		for (Region region : values())
		{
			builder.put(region.regionId, region);
		}

		lookupMap = builder.build();
	}

	public static Region of(int regionId)
	{
		return lookupMap.getOrDefault(regionId, UNKNOWN);
	}

	public static boolean inRegion(Client client, Region region)
	{
		return getCurrentRegionID(client, client.getLocalPlayer()) == region.regionId;
	}

	public static int getCurrentRegionID(Client client, Player player)
	{
		if (!client.isInInstancedRegion() || player == null)
		{
			return -1;
		}

		WorldPoint location = WorldPoint.fromLocalInstance(client, player.getLocalLocation());

		if (location == null)
		{
			return -1;
		}

		return location.getRegionID();
	}

	Region(String prettyName, int regionID, int p, int x, int y, WorldArea imaginaryLine)
	{
		this(prettyName, regionID, (p << 24 | x << 14 | y << 3), imaginaryLine);
	}

	Region(String prettyName, int regionID, int p, int x, int y)
	{
		this(prettyName, regionID, p, x, y, null);
	}

	Region(String prettyName)
	{
		this(prettyName, -1, -1, null);
	}

	public Region next()
	{
		if (this == SOTETSEG)
		{
			return XARPUS;
		}

		if (this == UNKNOWN)
		{
			return this;
		}

		Region[] regions = values();
		int index = ordinal() + 1;
		return index >= regions.length ? UNKNOWN : regions[index];
	}

	public boolean isPCIL(Client client, Player player)
	{
		if (!client.isInInstancedRegion() || player == null || imaginaryLine == null)
		{
			return false;
		}

		try
		{
			LocalPoint lp = LocalPoint.fromWorld(client, player.getWorldLocation());

			if (lp == null)
			{
				return false;
			}

			WorldPoint wp = WorldPoint.fromLocalInstance(client, lp);
			return wp != null && imaginaryLine.distanceTo2D(wp) <= 0;
		}
		catch (RuntimeException ex)
		{
			return false;
		}
	}

	public boolean isLobby()
	{
		return this == LOBBY;
	}

	public boolean isMaiden()
	{
		return this == MAIDEN;
	}

	public boolean isBloat()
	{
		return this == BLOAT;
	}

	public boolean isNylocas()
	{
		return this == NYLOCAS;
	}

	public boolean isSotetseg()
	{
		return this == SOTETSEG || this == SOTETSEG_MAZE;
	}

	public boolean isSotetsegOverworld()
	{
		return this == SOTETSEG;
	}

	public boolean isSotetsegUnderworld()
	{
		return this == SOTETSEG_MAZE;
	}

	public boolean isXarpus()
	{
		return this == XARPUS;
	}

	public boolean isVerzik()
	{
		return this == VERZIK;
	}

	public boolean isLootRoom()
	{
		return this == LOOT_ROOM;
	}

	public boolean isUnknown()
	{
		return this == UNKNOWN;
	}
}

/*
 * Copyright (c) 2022, Damen <gh: damencs>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:

 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.

 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.

 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.tobqol.api.game;

import com.google.common.primitives.Ints;
import net.runelite.api.*;
import net.runelite.api.coords.WorldPoint;
import net.runelite.client.callback.ClientThread;

import javax.inject.Inject;
import javax.inject.Singleton;
import java.util.Collection;
import java.util.function.BiConsumer;

@Singleton
public class SceneManager
{
	private final Client client;
	private final ClientThread clientThread;

	@Inject
	SceneManager(Client client, ClientThread clientThread)
	{
		this.client = client;
		this.clientThread = clientThread;
	}

	public void refreshScene()
	{
		if (client.getGameState() != GameState.LOGGED_IN)
		{
			return;
		}

		clientThread.invoke(() -> client.setGameState(GameState.LOADING));
	}

	public void forEachTile(int plane, BiConsumer<Scene, Tile> user)
	{
		if (plane < 0 || plane >= 4 || user == null || client.getGameState() != GameState.LOGGED_IN)
		{
			return;
		}

		Scene scene = client.getScene();
		Tile[][] tiles = scene.getTiles()[plane];

		for (int x = 0; x < Constants.SCENE_SIZE; x++)
		{
			for (int y = 0; y < Constants.SCENE_SIZE; y++)
			{
				Tile tile = tiles[x][y];

				if (tile == null)
				{
					continue;
				}

				user.accept(scene, tile);
			}
		}
	}

	public void removeThisTile(int plane, int sceneX, int sceneY)
	{
		if (client.getGameState() != GameState.LOGGED_IN)
		{
			return;
		}

		if (plane < 0 || plane >= Constants.MAX_Z)
		{
			return;
		}

		if (sceneX < 0 || sceneX >= Constants.SCENE_SIZE)
		{
			return;
		}

		if (sceneY < 0 || sceneY >= Constants.SCENE_SIZE)
		{
			return;
		}

		if (client.isClientThread())
		{
			client.getScene().getTiles()[plane][sceneX][sceneY] = null;
			return;
		}

		clientThread.invoke(() -> client.getScene().getTiles()[plane][sceneX][sceneY] = null);
	}

	public void removeThisTile(WorldPoint worldPoint)
	{
		if (worldPoint == null)
		{
			return;
		}

		removeThisTile(worldPoint.getPlane(), worldPoint.getX() - client.getBaseX(), worldPoint.getY() - client.getBaseY());
	}

	private void removeTheseGameObjects(int plane, int... gameObjectIds)
	{
		if (gameObjectIds.length == 0 || plane < 0 || plane > 3)
		{
			return;
		}

		forEachTile(plane, (scene, tile) ->
		{
			GameObject[] arr = tile.getGameObjects();

			if (arr == null || arr.length == 0)
			{
				return;
			}

			for (GameObject o : arr)
			{
				if (o == null)
				{
					continue;
				}

				for (int id : gameObjectIds)
				{
					if (o.getId() != id)
					{
						continue;
					}

					scene.removeGameObject(o);
					break;
				}
			}
		});
	}

	public void removeTheseGameObjects(int plane, Collection<Integer> gameObjectIds)
	{
		if (gameObjectIds == null || gameObjectIds.isEmpty())
		{
			return;
		}

		if (client.isClientThread())
		{
			removeTheseGameObjects(plane, Ints.toArray(gameObjectIds));
			return;
		}

		clientThread.invoke(() -> removeTheseGameObjects(plane, Ints.toArray(gameObjectIds)));
	}

	private void removeTheseGroundObjects(int plane, int... groundObjectIds)
	{
		if (plane < 0 || plane > 3)
		{
			return;
		}

		forEachTile(plane, (scene, tile) ->
		{
			GroundObject object = tile.getGroundObject();

			if (object != null)
			{
				tile.setGroundObject(null);
			}
		});
	}

	public void removeTheseGroundObjects(int plane, Collection<Integer> groundObjectIds)
	{
		if (groundObjectIds == null || groundObjectIds.isEmpty() || plane < 0 || plane > 3)
		{
			return;
		}

		if (client.isClientThread())
		{
			removeTheseGroundObjects(plane, Ints.toArray(groundObjectIds));
			return;
		}

		clientThread.invoke(() -> removeTheseGroundObjects(plane, Ints.toArray(groundObjectIds)));
	}
}

/*
 * Copyright (c) 2022, Damen <gh: damencs>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:

 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.

 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.

 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.tobqol;

import com.google.common.base.Strings;
import com.tobqol.api.game.RaidConstants;
import com.tobqol.api.game.Region;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.GameState;
import net.runelite.api.Varbits;
import net.runelite.api.events.GameStateChanged;
import net.runelite.api.events.GameTick;
import net.runelite.api.events.VarbitChanged;
import net.runelite.client.eventbus.EventBus;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.util.Text;

import javax.inject.Inject;
import javax.inject.Singleton;

@Singleton
@Slf4j
final class EventManager
{
	private final Client client;
	private final EventBus eventBus;
	private final TheatreQOLPlugin plugin;
	private final InstanceService instance;

	@Inject
	EventManager(Client client, EventBus eventBus, TheatreQOLPlugin plugin, InstanceService instance)
	{
		this.client = client;
		this.eventBus = eventBus;
		this.plugin = plugin;
		this.instance = instance;
	}

	void startUp()
	{
		instance.reset();
		eventBus.register(this);
	}

	void shutDown()
	{
		eventBus.unregister(this);
		instance.reset();
	}

	private void reset(boolean global)
	{
		plugin.reset(global);
		instance.reset();
	}

	@Subscribe(priority = 7)
	private void onGameStateChanged(GameStateChanged gsc)
	{
		GameState gs = gsc.getGameState();

		if (gs.equals(GameState.LOGGED_IN) || gs.equals(GameState.LOGIN_SCREEN))
		{
			if (gs.equals(GameState.LOGIN_SCREEN))
			{
				reset(true);
				return;
			}

			boolean inside = false;

			for (Region r : Region.values())
			{
				if (r.isLobby() || r.isUnknown())
				{
					continue;
				}

				if (Region.inRegion(client, r))
				{
					inside = true;
					instance.setRegion(r);
					break;
				}
			}

			if (!inside)
			{
				reset(false);
			}
		}
	}

	@Subscribe(priority = 7)
	private void onVarbitChanged(VarbitChanged e)
	{
		if (client.getLocalPlayer() == null)
		{
			return;
		}

		instance.setPartyStatus(client.getVarbitValue(Varbits.THEATRE_OF_BLOOD));
		instance.setRoomStatus(client.getVarbitValue(RaidConstants.THEATRE_OF_BLOOD_ROOM_STATUS));
		instance.setBossHealth(client.getVarbitValue(RaidConstants.THEATRE_OF_BLOOD_BOSS_HP));
		instance.setPreciseTimers(client.getVarbitValue(RaidConstants.PRECISE_TIMER) == 1);
	}

	@Subscribe(priority = 7)
	private void onGameTick(GameTick e)
	{
		if (instance.outside())
		{
			return;
		}

		for (int varcStrId = 330; varcStrId <= 334; varcStrId++)
		{
			String username = Text.standardize(client.getVarcStrValue(varcStrId));

			if (Strings.isNullOrEmpty(username))
			{
				continue;
			}

			switch (client.getVarbitValue(Varbits.THEATRE_OF_BLOOD_ORB1 + (varcStrId % 5)))
			{
				case 0: break;
				case 1:
					instance.addRaider(username);
					instance.addDeadRaider(username);
					break;
				default:
					instance.addRaider(username);
					break;
			}
		}

		instance.tick();
	}
}
/*
 * Copyright (c) 2022, Damen <gh: damencs>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:

 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.

 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.

 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.tobqol.config.times;

import lombok.Getter;
import lombok.RequiredArgsConstructor;

@RequiredArgsConstructor
@Getter
public enum TimeDisplayType
{
    OFF("Off"),
    CHAT("Chat"),
    INFOBOX("Infobox"),
    LIVE_OVERLAY("Live Overlay"),
    CHAT_AND_INFOBOX("Chat & Infobox"),
    LIVE_OVERLAY_AND_CHAT("Live & Chat"),
    LIVE_OVERLAY_AND_INFOBOX("Live & Infobox"),
    ALL("ALL");

    private final String type;

    @Override
    public String toString()
    {
        return type;
    }

    public boolean isOff()
    {
        return this == OFF;
    }

    public boolean isChat()
    {
        return this == CHAT || this == CHAT_AND_INFOBOX || this == LIVE_OVERLAY_AND_CHAT || this == ALL;
    }

    public boolean isInfobox()
    {
        return this == INFOBOX || this == CHAT_AND_INFOBOX || this == LIVE_OVERLAY_AND_INFOBOX || this == ALL;
    }

    public boolean isLiveOverlay()
    {
        return this == LIVE_OVERLAY || this == LIVE_OVERLAY_AND_CHAT || this == LIVE_OVERLAY_AND_INFOBOX || this == ALL;
    }

    public boolean isAll()
    {
        return this == ALL;
    }

    public boolean isAny()
    {
        return this == CHAT || this == INFOBOX || this == CHAT_AND_INFOBOX || this == LIVE_OVERLAY || this == LIVE_OVERLAY_AND_CHAT || this == LIVE_OVERLAY_AND_INFOBOX || this == ALL;
    }
}

/*
 * Copyright (c) 2022, Damen <gh: damencs>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:

 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.

 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.

 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.tobqol.config;

import lombok.Getter;
import lombok.RequiredArgsConstructor;

@Getter
@RequiredArgsConstructor
public enum SupplyChestPreference
{
    OFF("Value"),
    BUY_1("Buy-1"),
    BUY_X("Buy-x"),
    BUY_ALL("Buy-all");

    private final String name;

    @Override
    public String toString()
    {
        return name;
    }
}

/*
 * Copyright (c) 2022, Damen <gh: damencs>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:

 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.

 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.

 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.tobqol.config;

import lombok.RequiredArgsConstructor;

@RequiredArgsConstructor
public enum RenderType
{
	OFF("Off"),
	TILE("Tile"),
	HULL("Hull");

	private final String name;

	public boolean isOff()
	{
		return this == OFF;
	}

	public boolean isTile()
	{
		return this == TILE;
	}

	@Override
	public String toString()
	{
		return name;
	}
}

/*
 * Copyright (c) 2022, Damen <gh: damencs>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:

 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.

 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.

 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.tobqol.config;

import lombok.RequiredArgsConstructor;
import net.runelite.client.util.ColorUtil;

import java.awt.*;

@RequiredArgsConstructor
public enum HPDisplayTypes
{
	OFF("Off", ColorUtil.fromHex("#FF6961")),
	PERCENT("Percent", ColorUtil.fromHex("#ADCFFF")),
	HITPOINTS("Hitpoints", ColorUtil.fromHex("#FFB347"));

	private final String name;
	private final Color configColorOverride;

	public boolean off()
	{
		return this == OFF;
	}

	public boolean showAsPercent()
	{
		return this == PERCENT;
	}

	public boolean showAsHitpoints()
	{
		return this == HITPOINTS;
	}
}

/*
 * Copyright (c) 2022, Damen <gh: damencs>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:

 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.

 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.

 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.tobqol.config.font;

import lombok.Getter;
import lombok.RequiredArgsConstructor;

@RequiredArgsConstructor
@Getter
public enum FontStyles
{
    PLAIN("Plain", 0),
    BOLD("Bold", 1),
    ITALIC("Italic", 2),
    BOLD_ITALICIZED("Bold & Italic", 3);

    private final String style;

    @Getter
    private final int value;

    @Override
    public String toString()
    {
        return style;
    }
}

/*
 * Copyright (c) 2022, Damen <gh: damencs>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:

 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.

 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.

 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.tobqol.config.font;

import lombok.Getter;
import lombok.RequiredArgsConstructor;

@RequiredArgsConstructor
@Getter
public enum FontTypes
{
	REGULAR("RS Regular"),
	BOLD("RS Bold"),
	SMALL("RS Small"),
	ARIAL("Arial"),
	CAMBRIA("Cambria"),
	ROCKWELL("Rockwell"),
	SEGOE_UI("Segoe Ui"),
	TIMES_NEW_ROMAN("Times New Roman"),
	VERDANA("Verdana");

	private final String name;

	@Override
	public String toString()
	{
		return name;
	}
}

/*
 * Copyright (c) 2022, Damen <gh: damencs>
 * Copyright (c) 2022, WLoumakis <gh: WLoumakis> - Portions of "MES Options"
 * Copyright (c) 2022, Boris - Portions of "Xarpus Sheesh and HM Entry"
 * Copyright (c) 2021, BickusDiggus <gh: BickusDiggus> - Portions of "Loot Reminder"
 * Copyright (c) 2020, Broooklyn <gh: Broooklyn> - "ToB Light Up" Relevant Code
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:

 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.

 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.

 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.tobqol;

import com.tobqol.config.HPDisplayTypes;
import com.tobqol.config.SupplyChestPreference;
import com.tobqol.config.font.FontStyles;
import com.tobqol.config.font.FontTypes;
import com.tobqol.config.times.TimeDisplayType;
import com.tobqol.rooms.nylocas.config.NylocasObjects;
import com.tobqol.rooms.sotetseg.config.SotetsegInstanceTimerTypes;
import com.tobqol.rooms.sotetseg.config.SotetsegProjectileTheme;
import net.runelite.client.config.*;

import java.awt.*;

@ConfigGroup(TheatreQOLConfig.GROUP_NAME)
public interface TheatreQOLConfig extends Config
{
	String GROUP_NAME = "tobqol";

	/**
	 * Sections
	 */
	@ConfigSection(
			name = "General",
			description = "Configuration settings for things that are not room-specific",
			position = 1,
			closedByDefault = true
	)
	String GENERAL_SECTION = "generalSection";

	@ConfigSection(
			name = "The Maiden of Sugadinti",
			description = "Configuration settings for The Maiden of Sugadinti",
			position = 2,
			closedByDefault = true
	)
	String MAIDEN_SECTION = "maidenSection";

	@ConfigSection(
			name = "Pestilent Bloat",
			description = "Configuration settings for Pestilent Bloat",
			position = 3,
			closedByDefault = true
	)
	String BLOAT_SECTION = "bloatSection";

	@ConfigSection(
			name = "Nylocas",
			description = "Configuration settings for Nylocas",
			position = 4,
			closedByDefault = true
	)
	String NYLO_SECTION = "nyloSection";

	@ConfigSection(
			name = "Sotetseg",
			description = "Configuration settings for Sotetseg",
			position = 5,
			closedByDefault = true
	)
	String SOTETSEG_SECTION = "sotetsegSection";

	@ConfigSection(
			name = "Xarpus",
			description = "Configuration settings for Xarpus",
			position = 6,
			closedByDefault = true
	)
	String XARPUS_SECTION = "xarpusSection";

	@ConfigSection(
			name = "Verzik Vitur",
			description = "Configuration settings for Verzik Vitur",
			position = 7,
			closedByDefault = true
	)
	String VERZIK_SECTION = "verzikSection";

	@ConfigSection(
			name = "Font Settings",
			description = "Configuration settings for the plugin's text overlays",
			position = 8,
			closedByDefault = true
	)
	String FONT_SECTION = "fontSection";

	@ConfigSection(
			name = "Time Tracking Settings",
			description = "Configuration settings for the plugin's time tracking features",
			position = 9,
			closedByDefault = true
	)
	String TIME_SECTION = "timeSection";

	/**
	 * General Section
	 */
	@ConfigItem(
			name = "Bank-all MES Loot Chest",
			keyName = "bankAllMES",
			description = "- Removes the 'Force Right Click' flag from the [Bank-all] option inside the Monumental Chest in the Loot Room",
			position = 1,
			section = GENERAL_SECTION
	)
	default boolean bankAllMES()
	{
		return false;
	}

	@ConfigItem(
			name = "Supply Chest MES",
			keyName = "supplyChestMES",
			description = "- Swaps to the preferred purchasing quantity within the supply chests<br>" +
							"~ Credit - gh: WLoumakis",
			position = 2,
			section = GENERAL_SECTION
	)
	default SupplyChestPreference supplyChestMES()
	{
		return SupplyChestPreference.OFF;
	}

	@ConfigItem(
			name = "Light Up Ver Sinhaza",
			keyName = "lightUp",
			description = "- Removes the darkness lighting within Ver Sinhaza (ToB Bank Area)<br>" +
							"~ Credit - gh: Broooklyn",
			position = 3,
			section = GENERAL_SECTION
	)
	default boolean lightUp()
	{
		return false;
	}

	@ConfigItem(
			name = "Loot Reminder",
			keyName = "lootReminder",
			description = "- Indicates whether or not the chest has loot in it by highlighting the chest and putting a message on the entrance<br>" +
							"~ Credit - gh: BickusDiggus",
			position = 4,
			section = GENERAL_SECTION
	)
	default boolean lootReminder()
	{
		return false;
	}

	@ConfigItem(
			name = "Loot Reminder Color",
			keyName = "lootReminderColor",
			description = "- Set a color for the Loot Reminder overlay<br>" +
							"~ Credit - gh: BickusDiggus",
			position = 5,
			section = GENERAL_SECTION
	)
	@Alpha
	default Color lootReminderColor()
	{
		return new Color(196, 89, 89, 200);
	}

	@ConfigItem(
			name = "Salve Reminder",
			keyName = "salveReminder",
			description = "- Indicates whether or not you have salve in your inventory prior to entering the raid and putting a message on the entrance<br>",
			position = 6,
			section = GENERAL_SECTION
	)
	default boolean salveReminder()
	{
		return true;
	}

	@ConfigItem(
			name = "Salve Reminder Color",
			keyName = "salveReminderColor",
			description = "- Set a color for the Salve Reminder overlay<br>",
			position = 7,
			section = GENERAL_SECTION
	)
	@Alpha
	default Color salveReminderColor()
	{
		return Color.CYAN;
	}

	@ConfigItem(
			name = "Spellbook Reminder",
			keyName = "spellbookReminder",
			description = "- Indicates what spellbook you are on by putting a message on the entrance<br>",
			position = 8,
			section = GENERAL_SECTION
	)
	default boolean spellbookReminder()
	{
		return true;
	}

	@ConfigItem(
			name = "Spellbook Reminder Color",
			keyName = "spellbookReminderColor",
			description = "- Set a color for the Spellbook Reminder overlay<br>",
			position = 9,
			section = GENERAL_SECTION
	)
	@Alpha
	default Color spellbookReminderColor()
	{
		return Color.YELLOW;
	}

	@ConfigItem(
			name = "Ammo Reminder",
			keyName = "ammoReminder",
			description = "- Indicates whether or not you have ammo in your equipment slot prior to entering the raid and putting a message on the entrance<br>",
			position = 10,
			section = GENERAL_SECTION
	)
	default boolean ammoReminder() { return false; }

	@ConfigItem(
			name = "Ammo Reminder Color",
			keyName = "ammoReminderColor",
			description = "- Set a color for the Ammo Reminder overlay<br>",
			position = 11,
			section = GENERAL_SECTION
	)
	@Alpha
	default Color ammoReminderColor()
	{
		return Color.GREEN;
	}

	/**
	 * Maiden Configs
	 */
	@ConfigItem(
			name = "Display Crabs Health",
			keyName = "maidenCrabHPDisplayType",
			description = "- Displays the hitpoints percentage or the hitpoints of each alive Nylocas Matomenos",
			position = 1,
			section = MAIDEN_SECTION
	)
	default HPDisplayTypes getMaidenCrabHPType()
	{
		return HPDisplayTypes.OFF;
	}

	@ConfigItem(
			name = "Display Crab Proc",
			keyName = "maidenCrabProcDisplay",
			description = "- Displays what proc a crab is from in the overlay",
			position = 2,
			section = MAIDEN_SECTION
	)
	default boolean displayCrabProc() { return false; }

	@ConfigItem(
			name = "70s Crab Color",
			keyName = "maiden70sColor",
			description = "Crab health color for 70s crabs",
			position = 3,
			section = MAIDEN_SECTION
	)
	@Alpha
	default Color maiden70sColor() { return new Color(255, 255, 255); }

	@ConfigItem(
			name = "50s Crab Color",
			keyName = "maiden50sColor",
			description = "Crab health color for 50s crabs",
			position = 4,
			section = MAIDEN_SECTION
	)
	@Alpha
	default Color maiden50sColor() { return new Color(255, 255, 255); }
	@ConfigItem(
			name = "30s Crab Color",
			keyName = "maiden30sColor",
			description = "Crab overlay color for 30s crabs",
			position = 5,
			section = MAIDEN_SECTION
	)
	@Alpha
	default Color maiden30sColor()
	{
		return new Color(255, 255, 255);
	}

	@ConfigItem(
			name = "Show Leaks",
			keyName = "maidenLeaks",
			description = "- Sends a client message per leak showing what leaked, their hp and on what Maiden phase",
			position = 6,
			section = MAIDEN_SECTION
	)
	default boolean displayMaidenLeaks()
	{
		return false;
	}

	/**
	 * Bloat Configs
	 */
	@ConfigItem(
			name = "Hide Ceiling Chains",
			keyName = "hideCeilingChains",
			description = "- Hides the chains hanging from the ceiling in the Bloat room<br>" +
							"* Disabling this feature whilst in Bloat will cause a stutter to refresh the scene",
			position = 1,
			section = BLOAT_SECTION
	)
	default boolean shouldNullCeilingChains()
	{
		return false;
	}

	@ConfigItem(
			name = "Track Downs in Chat/Infobox",
			keyName = "trackDowns",
			description = "- Track the Bloat downs in chat/tooltip after room completion<br>" +
					"* Must have the Chat/Infobox Data Tracking enabled",
			position = 2,
			section = BLOAT_SECTION
	)
	default boolean trackDowns()
	{
		return false;
	}

	/**
	 * Nylocas Configs
	 */
	@ConfigItem(
			name = "Pillar HP",
			keyName = "nyloPillarHP",
			description = "- Display the health of each pillar",
			position = 1,
			section = NYLO_SECTION
	)
	default boolean showNylocasPillarHP()
	{
		return false;
	}

	@ConfigItem(
			name = "Hide Objects",
			keyName = "nyloHideObjects",
			description = "- Hide the Nylocas Pillars, Spectator Webs, and/or Walls if desired (none provide clickboxes when present)<br>" +
							"* Disabling this feature whilst in the Nylocas room will cause a stutter to refresh the scene",
			position = 2,
			section = NYLO_SECTION
	)
	default NylocasObjects nyloHideObjects()
	{
		return NylocasObjects.OFF;
	}

	@ConfigItem(
			name = "Recolor Menu",
			keyName = "nyloWavesRecolorMenu",
			description = "- Recolors each entry in the menu to their respective color<br>" +
					"* Gray: Melee (Nylocas Ischyros)<br>" +
					"* Green: Range (Nylocas Toxobolos)<br>" +
					"* Blue: Magic (Nylocas Hagios)",
			position = 3,
			section = NYLO_SECTION
	)
	default boolean nyloWavesRecolorMenu()
	{
		return false;
	}

	@ConfigItem(
			name = "Recolor Bigs Menu Darker",
			keyName = "nyloWavesRecolorBigsMenuDarker",
			description = "- Darkens the color on the menu if the Nylocas is big",
			position = 4,
			section = NYLO_SECTION
	)
	default boolean nyloWavesRecolorBigsMenuDarker()
	{
		return false;
	}

	@ConfigItem(
			name = "Role Selector",
			keyName = "displayNyloRoleSelector",
			description = "- Shows the Nylocas Room Role Selection Overlay that you can use to highlight the tiles of your role's nylos",
			position = 5,
			section = NYLO_SECTION
	)
	default boolean displayNyloRoleSelector()
	{
		return false;
	}

	@ConfigItem(
			name = "",
			keyName = "nyloRoleSelectedMage",
			description = "",
			hidden = true
	)
	default boolean nyloRoleSelectedMage()
	{
		return false;
	}

	@ConfigItem(
			name = "",
			keyName = "nyloRoleSelectedMage",
			description = "",
			hidden = true
	)
	void nyloSetRoleSelectedMage(boolean enabled);

	@ConfigItem(
			name = "",
			keyName = "nyloRoleSelectedMelee",
			description = "",
			hidden = true
	)
	default boolean nyloRoleSelectedMelee()
	{
		return false;
	}

	@ConfigItem(
			name = "",
			keyName = "nyloRoleSelectedMelee",
			description = "",
			hidden = true
	)
	void nyloSetRoleSelectedMelee(boolean enabled);

	@ConfigItem(
			name = "",
			keyName = "nyloRoleSelectedRange",
			description = "",
			hidden = true
	)
	default boolean nyloRoleSelectedRange()
	{
		return false;
	}

	@ConfigItem(
			name = "",
			keyName = "nyloRoleSelectedRange",
			description = "",
			hidden = true
	)
	void nyloSetRoleSelectedRange(boolean enabled);

	@ConfigItem(
			name = "Bigs SW Tile",
			keyName = "nyloWavesBigsSWTile",
			description = "- Display the SW Tile of big nylos",
			position = 6,
			section = NYLO_SECTION
	)
	default boolean nyloWavesBigsSWTile()
	{
		return false;
	}

	@ConfigItem(
			name = "Instance Timer",
			keyName = "nyloInstanceTimer",
			description = "- Displays the tick cycle for Nylocas' instance",
			position = 7,
			section = NYLO_SECTION
	)
	default boolean nyloInstanceTimer()
	{
		return false;
	}

	@ConfigItem(
			name = "Low Detail",
			keyName = "nyloLowDetail",
			description = "- Removes the Graphics Objects that spawn when a Nylo dies<br>" +
						"* Entity hider removes them from being displayed, but still allows them to spawn and linger",
			position = 8,
			section = NYLO_SECTION
	)
	default boolean nyloLowDetail()
	{
		return false;
	}

	/**
	 * Sotetseg Configs
	 */
	@ConfigItem(
			name = "Instance Timer",
			keyName = "sotetsegInstanceTimer",
			description = "- Displays the tick cycle for Sotetsegs' instance<br>" +
					"* Pre-Start: Displays before the room starts<br>" +
					"* Maze: Displays during the maze",
			position = 1,
			section = SOTETSEG_SECTION
	)
	default SotetsegInstanceTimerTypes getSotetsegInstanceTimerType()
	{
		return SotetsegInstanceTimerTypes.OFF;
	}

	@ConfigItem(
			name = "Projectile Theme",
			keyName = "getSotetsegProjectileTheme",
			description = "- Modifies the Projectile to appear in a specific theme to assist with colorblind users<br>" +
					"* Inferno: Utilizes the blob mage and range projectiles<br>" +
					"* TOA: Utilizes the red skull and rock projectiles from Wardens",
			position = 2,
			section = SOTETSEG_SECTION
	)
	default SotetsegProjectileTheme getSotetsegProjectileTheme()
	{
		return SotetsegProjectileTheme.DEFAULT;
	}

	@ConfigItem(
			name = "Themed Death Ball",
			keyName = "themedDeathBall",
			description = "- Use the theme's ball to replace Sotetseg's death ball when a theme is selected",
			position = 3,
			section = SOTETSEG_SECTION
	)
	default boolean themedDeathBall()
	{
		return true;
	}

	@ConfigItem(
			name = "Hide White Screen",
			keyName = "sotetsegHideWhiteScreen",
			description = "- Hides the transitional white screen during Sotetseg maze phase procs.",
			position = 4,
			section = SOTETSEG_SECTION
	)
	default boolean hideSotetsegWhiteScreen()
	{
		return false;
	}

	@ConfigItem(
			name = "Show Chosen Text",
			keyName = "showSotetsegChosenText",
			description = "- Displays a simulated version of 'You have been chosen.' text when Hide White Screen is enabled",
			position = 5,
			section = SOTETSEG_SECTION
	)
	default boolean showSotetsegChosenText()
	{
		return true;
	}

	@Range(min=-50, max=50)
	@ConfigItem(
			name = "Chosen Text Offset",
			keyName = "sotetsegChosenTextOffset",
			description = "- Adjusts the height of 'You have been chosen.' text\n" +
					"when Show Chosen Text AND Hide White Screen options are enabled",
			position = 6,
			section = SOTETSEG_SECTION
	)
	default int sotetsegChosenTextOffset()
	{
		return 0;
	}

	@ConfigItem(
			name = "Debug Chosen Text",
			keyName = "debugSotetsegChosenText",
			description = "- Displays a simulated version of 'You have been chosen.' text to see height of text",
			position = 7,
			section = SOTETSEG_SECTION
	)
	default boolean debugSotetsegChosenText()
	{
		return false;
	}

	@ConfigItem(
			name = "Hide Underworld Rocks",
			keyName = "sotetsegHideUnderworldRocks",
			description = "- Hides the rocks surrounding the Sotetseg maze",
			position = 8,
			section = SOTETSEG_SECTION
	)
	default boolean sotetsegHideUnderworldRocks()
	{
		return false;
	}

	@ConfigItem(
			name = "Hide Underworld Tornado",
			keyName = "sotetsegHideUnderworldTornado",
			description = "- Hides the tornado surrounding your player in the Sotetseg maze",
			position = 9,
			section = SOTETSEG_SECTION
	)
	default boolean sotetsegHideUnderworldTornado()
	{
		return false;
	}

	@ConfigItem(
			name = "Sotetseg Death Ball Alarm",
			keyName = "sotetsegSoundClip",
			description = "- Replaces the Death Ball sound effect with a wee-woo sound clip<br>" +
					"* Thank you Hoyaa for providing this sound clip for the project",
			position = 10,
			section = SOTETSEG_SECTION
	)
	default boolean sotetsegSoundClip()
	{
		return false;
	}

	@Range(max = 100)
	@ConfigItem(
			name = "Death Ball Alarm Volume",
			keyName = "sotetsegSoundClipVolume",
			description = "- Sets the volume of the sound clip",
			position = 11,
			section = SOTETSEG_SECTION
	)
	default int sotetsegSoundClipVolume()
	{
		return 65;
	}

	/**
	 * Xarpus Configs
	 */
	@ConfigItem(
			name = "Instance Timer",
			keyName = "xarpusInstanceTimer",
			description = "- Displays Xarpus's tick cycle for the initial exhumed spawn. Enter on 0 to start exhumeds as soon as possible.",
			position = 1,
			section = XARPUS_SECTION
	)
	default boolean displayXarpusInstanceTimer()
	{
		return false;
	}

	@ConfigItem(
			name = "Mute Xarpus HM Entry",
			keyName = "muteXarpusHMEntry",
			description = "- Mutes the Xarpus hardmode entrance noise when poison splats are thrown",
			position = 2,
			section = XARPUS_SECTION
	)
	default boolean muteXarpusHMEntry()
	{
		return false;
	}

	@ConfigItem(
			name = "Xarpus Sheesh Screech",
			keyName = "xarpusSoundClip",
			description = "- Replaces the Screech sound effect with a Sheesh sound clip<br>" +
							"~ Credit - Boris<br>" +
							"* Thank you Hoyaa for providing this sound clip for the project",
			position = 3,
			section = XARPUS_SECTION
	)
	default boolean xarpusSoundClip()
	{
		return false;
	}

	@Range(max = 100)
	@ConfigItem(
			name = "Sheesh Volume",
			keyName = "xarpusSoundClipVolume",
			description = "- Sets the volume of the sound clip",
			position = 4,
			section = XARPUS_SECTION
	)
	default int xarpusSoundClipVolume()
	{
		return 65;
	}

	/**
	 * Verzik Configs
	 */
	@ConfigItem(
			name = "Verzik Reds Health Overlay",
			keyName = "verzikReds",
			description = "- Displays the health of red crabs during Verzik",
			position = 1,
			section = VERZIK_SECTION
	)
	default boolean verzikReds()
	{
		return false;
	}

	@ConfigItem(
			name = "Mark Tornadoes",
			keyName = "verzikTornadoes",
			description = "- Highlight Verzik tornadoes",
			position = 2,
			section = VERZIK_SECTION
	)
	default boolean shouldMarkVerzikTornadoes()
	{
		return false;
	}

	@ConfigItem(
			name = "Marked Tornado Color",
			keyName = "verzikMarkedTornadoColor",
			description = "- Set the color of the marked tornadoes overlay",
			position = 3,
			section = VERZIK_SECTION
	)
	@Alpha
	default Color verzikMarkedTornadoColor()
	{
		return new Color(215, 122, 97);
	}

	@ConfigItem(
			name = "Mute Verzik Sounds",
			keyName = "muteVerzikSounds",
			description = "- Mute Verzik's sounds such as P2 area affect and her walking in P3",
			position = 4,
			section = VERZIK_SECTION
	)
	default boolean muteVerzikSounds()
	{
		return false;
	}

	@ConfigItem(
			name = "Verzik Death Ball Alarm",
			keyName = "verzikSoundClip",
			description = "- Notifies you of the green ball with a wee-woo sound clip on chat message received<br>" +
					"* Thank you Hoyaa for providing this sound clip for the project",
			position = 5,
			section = VERZIK_SECTION
	)
	default boolean verzikSoundClip()
	{
		return false;
	}

	@Range(max = 100)
	@ConfigItem(
			name = "Death Ball Alarm Volume",
			keyName = "verzikSoundClipVolume",
			description = "- Sets the volume of the sound clip",
			position = 6,
			section = VERZIK_SECTION
	)
	default int verzikSoundClipVolume()
	{
		return 65;
	}

	/**
	 * Font Configs
	 */
	@ConfigItem(
			name = "Font Type",
			keyName = "fontType",
			description = "Dynamically change the font for all ToB QoL Overlays",
			position = 1,
			section = FONT_SECTION
	)
	default FontTypes fontType() { return FontTypes.REGULAR; }

	@ConfigItem(
			name = "Font Style",
			keyName = "fontStyle",
			description = "Dynamically change the font style for all ToB QoL Overlays<br>" +
						"* This will not alter the base RS font styles",
			position = 2,
			section = FONT_SECTION
	)
	default FontStyles fontStyle()
	{
		return FontStyles.PLAIN;
	}

	@Range(min = 12, max = 20)
	@ConfigItem(
			name = "Font Size",
			keyName = "fontSize",
			description = "Dynamically change the font size for all ToB QoL Overlays<br>" +
					"* This will not alter the base RS font styles",
			position = 3,
			section = FONT_SECTION
	)
	default int fontSize()
	{
		return 16;
	}

	@Range(min = 12, max = 42)
	@ConfigItem(
			name = "Instance Timer Size",
			keyName = "instanceTimerSize",
			description = "Dynamically change the font size for all the Instance Timers<br>" +
					"* This inherits the font type and style selected above<br>" +
					"* This will not alter the base RS font styles",
			position = 3,
			section = FONT_SECTION
	)
	default int instanceTimerSize()
	{
		return 16;
	}

	@Range(min = -12, max = 12)
	@ConfigItem(
			name = "Instance Timer Offset",
			keyName = "instanceTimerOffset",
			description = "Dynamically change the vertical offset for all the Instance Timers displayed over a character",
			position = 4,
			section = FONT_SECTION
	)
	default int instanceTimerOffset()
	{
		return 0;
	}

	/**
	 * Time Tracking Configs
	 */
	@ConfigItem(
			name = "Display Room Times",
			keyName = "displayRoomTimes",
			description = "- Display live time for each room's boss<br>" +
						"* Please note that this will not show splits on rooms that reveal mechanics until the room has ended (Bloat downs)",
			position = 1,
			section = TIME_SECTION
	)
	default TimeDisplayType displayRoomTimes()
	{
		return TimeDisplayType.OFF;
	}

	@ConfigItem(
			name = "Display Splits",
			keyName = "displayTimeSplits",
			description = "- Displays the splits in the room where tracked<br>" +
						  "- Example: [50s - 1:02.4]",
			position = 2,
			section = TIME_SECTION
	)
	default boolean displayTimeSplits()
	{
		return true;
	}

	@ConfigItem(
			name = "Display Split Differences",
			keyName = "displayTimeSplitDifferences",
			description = "- Displays the difference in time between each split<br>" +
					"- Example: [50s - 1:02.4 (0:24.6)]",
			position = 3,
			section = TIME_SECTION
	)
	default boolean displayTimeSplitDifferences()
	{
		return false;
	}

	@ConfigItem(
			name = "Validate Room Completion",
			keyName = "roomTimeValidation",
			description = "- Displays the room completion time that the plugin tracks independently to validate plugin timing",
			position = 4,
			section = TIME_SECTION
	)
	default boolean roomTimeValidation()
	{
		return false;
	}

	@ConfigItem(
			name = "Shrunk Live Timer Size",
			keyName = "shrunkLiveTimerDesign",
			description = "- Live timer overlay with Plain San Serif at a font size of 11 to minimize the overlay size<br>" +
						"Note: You can use RuneLite's overlay settings in Core 'RuneLite' Settings to configure the overlay",
			position = 5,
			section = TIME_SECTION
	)
	default boolean shrunkLiveTimerDesign()
	{
		return false;
	}
}

/*
 * Copyright (c) 2022, Damen <gh: damencs>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:

 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.

 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.

 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.tobqol.tracking;

import com.tobqol.TheatreQOLConfig;
import com.tobqol.TheatreQOLPlugin;
import lombok.Getter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.client.ui.overlay.Overlay;
import net.runelite.client.ui.overlay.OverlayPosition;
import net.runelite.client.ui.overlay.components.PanelComponent;

import javax.inject.Inject;
import java.awt.*;

@Slf4j
public class RoomTimeOverlay extends Overlay
{
    private TheatreQOLPlugin plugin;
    private TheatreQOLConfig config;

    @Getter
    protected PanelComponent panelComponent = new PanelComponent();

    @Inject
    public RoomTimeOverlay(TheatreQOLPlugin plugin, TheatreQOLConfig config)
    {
        this.plugin = plugin;
        this.config = config;

        setPosition(OverlayPosition.TOP_LEFT);
    }

    @Override
    public Dimension render(Graphics2D graphics)
    {
        if (!config.displayRoomTimes().isLiveOverlay() || !plugin.getInstanceService().isInRaid())
        {
            return null;
        }

        if (config.shrunkLiveTimerDesign())
        {
            graphics.setFont(new Font(Font.SANS_SERIF, Font.PLAIN, 11));
        }

        this.panelComponent = plugin.getDataHandler().preRenderRoomTimes();

        return panelComponent.render(graphics);
    }
}

/*
 * Copyright (c) 2022, Damen <gh: damencs>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:

 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.

 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.

 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.tobqol.tracking;

import com.tobqol.TheatreQOLConfig;
import com.tobqol.TheatreQOLPlugin;
import net.runelite.client.ui.overlay.infobox.InfoBox;
import net.runelite.client.ui.overlay.infobox.InfoBoxPriority;
import org.apache.commons.lang3.StringUtils;

import java.awt.*;
import java.awt.image.BufferedImage;

public class RoomInfoBox extends InfoBox
{
    private final TheatreQOLConfig config;
    private final String room;
    private final String time;
    private final String tooltip;

    public RoomInfoBox(
            BufferedImage image,
            TheatreQOLPlugin plugin,
            TheatreQOLConfig config,
            String room,
            String time,
            String tooltip
    )
    {
        super(image, plugin);

        this.config = config;
        this.room = room;
        this.time = time;
        this.tooltip = tooltip;

        setPriority(InfoBoxPriority.LOW);
    }

    @Override
    public String getName()
    {
        return room;
    }

    @Override
    public String getText()
    {
        return getTime(true);
    }

    @Override
    public Color getTextColor()
    {
        return Color.GREEN;
    }

    @Override
    public String getTooltip()
    {
        return tooltip;
    }

    @Override
    public boolean render()
    {
        return config.displayRoomTimes().isInfobox();
    }

    private String getTime(boolean simple)
    {
        return simple ? StringUtils.substringBefore(time, ".") : time;
    }
}

/*
 * Copyright (c) 2022, Damen <gh: damencs>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:

 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.

 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.

 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.tobqol.tracking;

import com.tobqol.TheatreQOLConfig;
import com.tobqol.TheatreQOLPlugin;
import lombok.Getter;
import lombok.Setter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.client.ui.overlay.components.LineComponent;
import net.runelite.client.ui.overlay.components.PanelComponent;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Optional;

import static com.tobqol.tracking.RoomInfoUtil.formatTime;

@Slf4j
public class RoomDataHandler
{
    private Client client;
    private TheatreQOLPlugin plugin;
    private TheatreQOLConfig config;

    @Getter
    @Setter
    private RoomTimeOverlay timeOverlay;

    @Getter
    private ArrayList<RoomDataItem> data = new ArrayList<>();

    @Getter
    @Setter
    private boolean shouldTrack = false;

    public RoomDataHandler(Client client, TheatreQOLPlugin plugin, TheatreQOLConfig config)
    {
        this.client = client;
        this.plugin = plugin;
        this.config = config;

        timeOverlay = new RoomTimeOverlay(plugin, config);
    }

    public void load()
    {
        plugin.overlayManager.add(timeOverlay);
    }

    public void unload()
    {
        plugin.overlayManager.remove(timeOverlay);
    }

    public PanelComponent preRenderRoomTimes()
    {
        timeOverlay.getPanelComponent().getChildren().clear();

        if (data.isEmpty())
        {
            LineComponent lineComponent = LineComponent.builder().left("Room").right(formatTime(0)).build();
            timeOverlay.getPanelComponent().getChildren().add(lineComponent);

            return timeOverlay.getPanelComponent();
        }

        Optional<RoomDataItem> o = Find("Starting Tick");
        if (o.isPresent() && o.get().isException())
        {
            LineComponent lineComponent = LineComponent.builder().left("Room").right(formatTime(FindValue("Room")) + '*').build();
            timeOverlay.getPanelComponent().getChildren().add(lineComponent);

            return timeOverlay.getPanelComponent();
        }

        boolean splitDifferences = config.displayTimeSplitDifferences();

        Collections.sort(data);

        data.forEach((item) ->
        {
            if (item.isHidden() || (item.isHidden() && item.getName() != "Room"))
            {
                return;
            }

            boolean hasComparable = (item.getCompareName().equals("") || (isShouldTrack() && item.getName().equals("Room"))) ? false : Find(item.getCompareName()).isPresent();

            LineComponent lineComponent = LineComponent.builder().left(item.getName()).right(formatTime(item.getValue()) +
                    (splitDifferences && hasComparable ? formatTime(item.getValue(), FindValue(item.getCompareName())) : "")).build();
            timeOverlay.getPanelComponent().getChildren().add(lineComponent);
        });

        return timeOverlay.getPanelComponent();
    }

    public Optional<RoomDataItem> Find(String name)
    {
        return data.stream().filter(f -> f.getName().equals(name)).findFirst();
    }

    public int FindValue(String name)
    {
        if (!Find(name).isPresent())
        {
            return 0;
        }

        return data.stream().filter(f -> f.getName().equals(name)).findFirst().get().getValue();
    }

    public int getTime()
    {
        return client.getTickCount() - FindValue("Starting Tick");
    }

    public void updateTotalTime()
    {
        if (!Find("Room").isPresent())
        {
            getData().add(new RoomDataItem("Room", getTime(), 99, false));
        }
        else
        {
            Find("Room").get().setValue(getTime());
        }
    }

    public void updateHiddenItems(boolean set)
    {
        data.forEach(item ->
        {
            if (item.getName() != "Starting Tick" && item.getName() != "Room")
            {
                item.setHidden(set);
            }
        });
    }
}

/*
 * Copyright (c) 2022, Damen <gh: damencs>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:

 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.

 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.

 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.tobqol.tracking;

import lombok.Getter;
import lombok.Setter;

public class RoomDataItem implements Comparable
{
    @Getter
    @Setter
    private String name;

    @Getter
    @Setter
    private int value;

    @Getter
    @Setter
    private int sort;

    @Getter
    @Setter
    private boolean hidden;

    @Getter
    @Setter
    private String compareName;

    @Getter
    @Setter
    private boolean exception;

    public RoomDataItem(String name, int value)
    {
        this.name = name;
        this.value = value;
        this.sort = -1;
        this.hidden = false;
        this.compareName = null;
        this.exception = false;
    }

    public RoomDataItem(String name, int value, boolean hidden)
    {
        this.name = name;
        this.value = value;
        this.sort = -1;
        this.hidden = hidden;
        this.compareName = "";
        this.exception = false;
    }

    public RoomDataItem(String name, int value, int sort, boolean hidden)
    {
        this.name = name;
        this.value = value;
        this.sort = sort;
        this.hidden = hidden;
        this.compareName = "";
        this.exception = false;
    }

    public RoomDataItem(String name, int value, int sort, boolean hidden, String compareName)
    {
        this.name = name;
        this.value = value;
        this.sort = sort;
        this.hidden = hidden;
        this.compareName = compareName;
        this.exception = false;
    }

    public RoomDataItem(String name, int value, boolean hidden, boolean exception)
    {
        this.name = name;
        this.value = value;
        this.sort = -1;
        this.hidden = hidden;
        this.compareName = "";
        this.exception = exception;
    }

    public RoomDataItem(String name, int value, int sort, boolean hidden, String compareName, boolean exception)
    {
        this.name = name;
        this.value = value;
        this.sort = sort;
        this.hidden = hidden;
        this.compareName = compareName;
        this.exception = exception;
    }

    @Override
    public int compareTo(Object comparesTo)
    {
        return this.sort - ((RoomDataItem)comparesTo).getSort();
    }

    @Override
    public String toString()
    {
        return "Name: " + name + ", Value: " + value + ", Sort: " + sort + ", Hidden: " + hidden + ", Compared Key Name: " + compareName + ", Exception: " + exception;
    }
}

/*
 * Copyright (c) 2022, Damen <gh: damencs>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:

 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.

 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.

 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.tobqol.tracking;

import com.tobqol.TheatreQOLConfig;
import com.tobqol.TheatreQOLPlugin;
import lombok.AccessLevel;
import lombok.NoArgsConstructor;

import java.awt.image.BufferedImage;
import java.util.concurrent.TimeUnit;

@NoArgsConstructor(access = AccessLevel.PRIVATE)
public final class RoomInfoUtil
{
    static final int TICK_LENGTH = 600;

    public static String formatTime(int current, int previous)
    {
        return " (" + formatTime(current - previous) + ")";
    }

    public static String formatTime(int ticks)
    {
        int millis = ticks * TICK_LENGTH;
        String hundredths = String.valueOf(millis % 1000).substring(0, 1);

        return String.format("%d:%02d.%s",
                TimeUnit.MILLISECONDS.toMinutes(millis) % TimeUnit.HOURS.toMinutes(1),
                TimeUnit.MILLISECONDS.toSeconds(millis) % TimeUnit.MINUTES.toSeconds(1),
                hundredths);
    }

    public static RoomInfoBox createInfoBox(TheatreQOLPlugin plugin, TheatreQOLConfig config, BufferedImage image, String bossName, String time, String tooltip)
    {
        return new RoomInfoBox(image, plugin, config, bossName, time, tooltip);
    }
}

/*
 * Copyright (c) 2022, Damen <gh: damencs>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:

 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.

 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.

 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.tobqol.rooms.verzik.commons;

import com.tobqol.api.util.PerspectiveUtil;
import lombok.Getter;
import lombok.experimental.Accessors;
import net.runelite.api.Client;
import net.runelite.api.NPC;
import net.runelite.api.coords.WorldPoint;

import java.awt.*;
import java.util.Optional;
import java.util.function.Predicate;

@Accessors(fluent = true)
public class Tornado implements Predicate<NPC>
{
	@Getter
	private final NPC npc;

	private WorldPoint first;
	private WorldPoint second;

	public Tornado(NPC npc)
	{
		this.npc = npc;
		this.first = npc.getWorldLocation();
		this.second = this.first;
	}

	public Optional<Polygon> first(Client client)
	{
		return PerspectiveUtil.toTilePoly(client, first);
	}

	public Optional<Polygon> second(Client client)
	{
		return PerspectiveUtil.toTilePoly(client, second);
	}

	public void shift()
	{
		first = second;
		second = npc.getWorldLocation();
	}

	@Override
	public boolean test(NPC npc)
	{
		return this.npc.getIndex() == npc.getIndex();
	}
}

/*
 * Copyright (c) 2022, Damen <gh: damencs>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:

 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.

 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.

 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.tobqol.rooms.verzik.commons;

import com.google.common.collect.ImmutableList;
import com.google.common.collect.ImmutableSet;
import lombok.AccessLevel;
import lombok.NoArgsConstructor;
import net.runelite.api.ItemID;
import net.runelite.api.NpcID;
import net.runelite.api.NullNpcID;

import java.util.List;
import java.util.Set;
import java.util.regex.Pattern;

@NoArgsConstructor(access = AccessLevel.PRIVATE)
public final class VerzikConstants
{
	public static final String VERZIK_NAME = "Verzik Vitur";

	Pattern COMPLETION = Pattern.compile("Theatre of Blood total completion time:");

	// NPC IDs
	public static final int SM_VERZIK_P1_INACTIVE_NPC = NpcID.VERZIK_VITUR_10830; // Not Attackable
	public static final int SM_VERZIK_P1_NPC = NpcID.VERZIK_VITUR_10831;
	public static final int SM_VERZIK_P2_INACTIVE_NPC = NpcID.VERZIK_VITUR_10832; // Transitioning into P2
	public static final int SM_VERZIK_P2_NPC = NpcID.VERZIK_VITUR_10833;
	public static final int SM_VERZIK_P3_INACTIVE_NPC = NpcID.VERZIK_VITUR_10834; // Transitioning into P3
	public static final int SM_VERZIK_P3_NPC = NpcID.VERZIK_VITUR_10835;
	public static final int SM_VERZIK_P3_DEATH_NPC = NpcID.VERZIK_VITUR_10836; // Dying and turning into a bat

	public static final int RG_VERZIK_P1_INACTIVE_NPC = NpcID.VERZIK_VITUR_8369; // Not Attackable
	public static final int RG_VERZIK_P1_NPC = NpcID.VERZIK_VITUR_8370;
	public static final int RG_VERZIK_P2_INACTIVE_NPC = NpcID.VERZIK_VITUR_8371; // Transitioning into P2
	public static final int RG_VERZIK_P2_NPC = NpcID.VERZIK_VITUR_8372;
	public static final int RG_VERZIK_P3_INACTIVE_NPC = NpcID.VERZIK_VITUR_8373; // Transitioning into P3
	public static final int RG_VERZIK_P3_NPC = NpcID.VERZIK_VITUR_8374;
	public static final int RG_VERZIK_P3_DEATH_NPC = NpcID.VERZIK_VITUR_8375; // Dying and turning into a bat

	public static final int HM_VERZIK_P1_INACTIVE_NPC = NpcID.VERZIK_VITUR_10847; // Not Attackable
	public static final int HM_VERZIK_P1_NPC = NpcID.VERZIK_VITUR_10848;
	public static final int HM_VERZIK_P2_INACTIVE_NPC = NpcID.VERZIK_VITUR_10849; // Transitioning into P2
	public static final int HM_VERZIK_P2_NPC = NpcID.VERZIK_VITUR_10850;
	public static final int HM_VERZIK_P3_INACTIVE_NPC = NpcID.VERZIK_VITUR_10851; // Transitioning into P3
	public static final int HM_VERZIK_P3_NPC = NpcID.VERZIK_VITUR_10852;
	public static final int HM_VERZIK_P3_DEATH_NPC = NpcID.VERZIK_VITUR_10853; // Dying and turning into a bat

	public static final List<Integer> P2_NPC_IDS = ImmutableList.of(SM_VERZIK_P2_NPC, RG_VERZIK_P2_NPC, HM_VERZIK_P2_NPC);
	public static final List<Integer> P3_NPC_IDS = ImmutableList.of(SM_VERZIK_P3_NPC, RG_VERZIK_P3_NPC, HM_VERZIK_P3_NPC);

	public static final int TORNADO_NPC = NullNpcID.NULL_8386;

	// Pillar Name has color tags and is called "Supporting Pillar"
	public static final int PILLAR_NPC = NpcID.SUPPORTING_PILLAR;
	public static final int PILLAR_DEATH_NPC = NpcID.COLLAPSING_PILLAR_8378;

	public static final int SM_WEB = NpcID.WEB_10837;
	public static final int RG_WEB = NpcID.WEB;
	public static final int HM_WEB = NpcID.WEB_10854;

	// Graphic Object IDs
	public static final int YELLOW_POOL = 1595;

	// Misc. Stuff
	public static final Set<Integer> WEAPON_SET = ImmutableSet.of(
			ItemID.TOXIC_BLOWPIPE,
			ItemID.ABYSSAL_TENTACLE
	);

	public static final Set<Integer> HELMET_SET = ImmutableSet.of(
			ItemID.SERPENTINE_HELM,
			ItemID.TANZANITE_HELM,
			ItemID.MAGMA_HELM
	);
}

/*
 * Copyright (c) 2022, Damen <gh: damencs>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:

 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.

 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.

 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.tobqol.rooms.verzik.commons;

import com.google.common.collect.*;
import com.tobqol.api.game.Instance;
import lombok.Getter;
import lombok.RequiredArgsConstructor;
import lombok.experimental.Accessors;
import net.runelite.api.NpcID;
import net.runelite.api.NullNpcID;

import javax.annotation.Nullable;
import java.awt.*;
import java.util.regex.Pattern;

@RequiredArgsConstructor
@Getter
@Accessors(fluent = true)
public enum VerzikMap
{
	VERZIK_P1_INACTIVE(NpcID.VERZIK_VITUR_10830, NpcID.VERZIK_VITUR_8369, NpcID.VERZIK_VITUR_10847),
	VERZIK_P1(NpcID.VERZIK_VITUR_10831, NpcID.VERZIK_VITUR_8370, NpcID.VERZIK_VITUR_10848),
	VERZIK_P2_INACTIVE(NpcID.VERZIK_VITUR_10832, NpcID.VERZIK_VITUR_8371, NpcID.VERZIK_VITUR_10849),
	VERZIK_P2(NpcID.VERZIK_VITUR_10833, NpcID.VERZIK_VITUR_8372, NpcID.VERZIK_VITUR_10850),
	VERZIK_P3_INACTIVE(NpcID.VERZIK_VITUR_10834, NpcID.VERZIK_VITUR_8373, NpcID.VERZIK_VITUR_10851),
	VERZIK_P3(NpcID.VERZIK_VITUR_10835, NpcID.VERZIK_VITUR_8374, NpcID.VERZIK_VITUR_10852),
	VERZIK_BAT(NpcID.VERZIK_VITUR_10836, NpcID.VERZIK_VITUR_8375, NpcID.VERZIK_VITUR_10853),
	PURPLE_NYLO(NpcID.NYLOCAS_ATHANATOS_10844, NpcID.NYLOCAS_ATHANATOS, NpcID.NYLOCAS_ATHANATOS_10861),
	RED_NYLO(NpcID.NYLOCAS_MATOMENOS_10845, NpcID.NYLOCAS_MATOMENOS_8385, NpcID.NYLOCAS_MATOMENOS_10862),
	MELEE_NYLO(NpcID.NYLOCAS_ISCHYROS_10841, NpcID.NYLOCAS_ISCHYROS_8381, NpcID.NYLOCAS_ISCHYROS_10858),
	RANGE_NYLO(NpcID.NYLOCAS_TOXOBOLOS_10842, NpcID.NYLOCAS_TOXOBOLOS_8382, NpcID.NYLOCAS_TOXOBOLOS_10859),
	MAGIC_NYLO(NpcID.NYLOCAS_HAGIOS_10843, NpcID.NYLOCAS_HAGIOS_8383, NpcID.NYLOCAS_HAGIOS_10860),
	WEB(NpcID.WEB_10837, NpcID.WEB, NpcID.WEB_10854),
	TORNADO(NullNpcID.NULL_10846, NullNpcID.NULL_8386, NullNpcID.NULL_10863); // TODO -> Confirm Story Mode

	private final int sm;
	private final int rg;
	private final int hm;

	public static final String BOSS_NAME = "Verzik Vitur";

	public static final Pattern VERZIK_WAVE = Pattern.compile("Wave 'The Final Challenge' \\(.*\\) complete!");

	public static final int BOSS_IMAGE = 22473;

	// TODO -> Find Story Mode/Regular Pillar NPC IDs
	public static final int PILLAR_NPC_ID = NpcID.SUPPORTING_PILLAR;
	public static final int COLLAPSING_PILLAR_NPC_ID = NpcID.COLLAPSING_PILLAR;

	public static final int VERZIK_P1_ATK_ANIM = 8109;
	public static final int VERZIK_P2_ATK_ANIM = 8114;
	public static final int VERZIK_P2_BOUNCE_ANIM = 8116;
	public static final int VERZIK_P2_HEALING_STATE_ANIM = 8117;
	public static final int VERZIK_P2_TRANSITION = 8118;
	public static final int VERZIK_P3_MAGIC_ANIM = 8124;
	public static final int VERZIK_P3_RANGE_ANIM = 8125; // Reused animation for the Green Ball attack
	public static final int VERZIK_P3_YELLOWS_ANIM = 8126;
	public static final int VERZIK_P3_WEBS_ANIM = 8127;

	public static final int YELLOW_POOL = 1595;
	public static final int YELLOW_GRAPHIC = 1597;

	public static final int GREEN_BALL = 1598;
	public static final String GREEN_BALL_TEXT = "Verzik Vitur fires a powerful projectile in your direction...";
	public static final String GREEN_BALL_BOUNCE_TEXT = "A powerful projectile bounces into your direction...";

	public static final Color VERZIK_COLOR = new Color(176, 92, 204);

	private static final ImmutableMultimap<VerzikMap, Integer> container;
	private static final Table<Instance.Mode, Integer, VerzikMap> lookupTable;

	static
	{
		ImmutableMultimap.Builder<VerzikMap, Integer> mapBuilder = new ImmutableListMultimap.Builder<>();
		ImmutableTable.Builder<Instance.Mode, Integer, VerzikMap> tableBuilder = new ImmutableTable.Builder<>();

		for (VerzikMap def : values())
		{
			mapBuilder.putAll(def, def.sm, def.rg, def.hm);

			tableBuilder.put(Tables.immutableCell(Instance.Mode.STORY, def.sm, def));
			tableBuilder.put(Tables.immutableCell(Instance.Mode.REGULAR, def.rg, def));
			tableBuilder.put(Tables.immutableCell(Instance.Mode.HARD, def.hm, def));
		}

		container = mapBuilder.build();
		lookupTable = tableBuilder.build();
	}

	public static boolean matchesAnyMode(VerzikMap def, int npcId)
	{
		if (def == null)
		{
			return false;
		}

		return container.get(def).contains(npcId);
	}

	@Nullable
	public static VerzikMap queryTable(Instance.Mode mode, int npcId)
	{
		if (mode == null)
		{
			return null;
		}

		return lookupTable.get(mode, npcId);
	}

	@Nullable
	public static VerzikMap queryTable(int npcId)
	{
		for (Instance.Mode mode : Instance.Mode.values())
		{
			VerzikMap def = queryTable(mode, npcId);

			if (def == null)
			{
				continue;
			}

			return def;
		}

		return null;
	}

	public static boolean isStoryMode(int npcId)
	{
		return queryTable(Instance.Mode.STORY, npcId) != null;
	}

	public static boolean isRegularMode(int npcId)
	{
		return queryTable(Instance.Mode.REGULAR, npcId) != null;
	}

	public static boolean isHardMode(int npcId)
	{
		return queryTable(Instance.Mode.HARD, npcId) != null;
	}

	@Nullable
	public static Instance.Mode findMode(int npcId)
	{
		if (isStoryMode(npcId))
		{
			return Instance.Mode.STORY;
		}

		if (isRegularMode(npcId))
		{
			return Instance.Mode.REGULAR;
		}

		if (isHardMode(npcId))
		{
			return Instance.Mode.HARD;
		}

		return null;
	}
}

/*
 * Copyright (c) 2022, Damen <gh: damencs>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:

 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.

 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.

 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.tobqol.rooms.verzik.commons;

import lombok.Getter;
import lombok.RequiredArgsConstructor;

@Getter
@RequiredArgsConstructor
public enum VerzikSpecialAttacks
{
    WEB_COOLDOWN,
    WEBS,
    YELLOWS,
    GREEN,
    NONE
}
/*
 * Copyright (c) 2022, Damen <gh: damencs>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:

 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.

 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.

 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.tobqol.rooms.verzik;

import com.tobqol.TheatreQOLConfig;
import com.tobqol.TheatreQOLPlugin;
import com.tobqol.api.game.Instance;
import com.tobqol.rooms.RoomSceneOverlay;
import com.tobqol.rooms.verzik.commons.VerzikMap;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.NPC;
import net.runelite.api.Point;
import net.runelite.client.ui.overlay.OverlayLayer;
import net.runelite.client.ui.overlay.OverlayUtil;
import org.apache.commons.lang3.tuple.MutablePair;
import org.apache.commons.lang3.tuple.Pair;

import javax.inject.Inject;
import java.awt.*;
import java.text.DecimalFormat;

@Slf4j
public class VerzikOverlay extends RoomSceneOverlay<VerzikHandler>
{
	private static final DecimalFormat DECIMAL_FORMAT = new DecimalFormat("#0.0");

	@Inject
	protected VerzikOverlay(
			Client client,
			Instance instance,
			VerzikHandler room,
			TheatreQOLPlugin plugin,
			TheatreQOLConfig config
	)
	{
		super(client, instance, room, plugin, config);
	}

	@Override
	public Dimension render(Graphics2D graphics)
	{
		if (!instance.getCurrentRegion().isVerzik())
		{
			return null;
		}

		NPC verzikNpc = room.getVerzikNpc();

		if (verzikNpc == null)
		{
			return null;
		}

		VerzikMap def = VerzikMap.queryTable(verzikNpc.getId());

		if (def == null)
		{
			return null;
		}

		setLayer(OverlayLayer.ABOVE_SCENE);
		graphics.setFont(plugin.getPluginFont());

		switch (def)
		{
			case VERZIK_P2:
				displayRedCrabs(graphics);
				break;
			case VERZIK_P3:
				displayTornadoes(graphics);
		}

		return null;
	}

	private void displayTornadoes(Graphics2D graphics)
	{
		if (!config.shouldMarkVerzikTornadoes() || room.getTornadoes().isEmpty())
		{
			return;
		}

		room.getTornadoes().forEach(t ->
		{
			Color color = config.verzikMarkedTornadoColor();
			t.first(client).ifPresent(p -> OverlayUtil.renderPolygon(graphics, p, color));
			t.second(client).ifPresent(p -> OverlayUtil.renderPolygon(graphics, p, color.darker()));
		});
	}

	private void displayRedCrabs(Graphics2D graphics)
	{
		if (config.verzikReds())
		{
			// First loop: Draw the percentages over the crabs
			room.getVerzikReds().forEach((crab, v) ->
			{
				int v_health = v.getValue();           // Stored health scale
				int v_healthRatio = v.getKey();        // Stored health ratio

				int currentHealthScale = crab.getHealthScale();
				int currentHealthRatio = crab.getHealthRatio();

				// Only update if current health info is valid
				if (crab.getName() != null && currentHealthScale > 0 && currentHealthRatio > 0)
				{
					v_health = currentHealthScale;
					v_healthRatio = Math.min(v_healthRatio, currentHealthRatio);

					// Update the stored values
					room.getVerzikReds().put(crab, new MutablePair<>(v_healthRatio, v_health));
				}
				// Else, keep using the stored v_health and v_healthRatio

				String percentage = DECIMAL_FORMAT.format(((float) v_healthRatio / (float) v_health) * 100f);

				Point textLocation = crab.getCanvasTextLocation(graphics, percentage, 80);

				if (!crab.isDead() && textLocation != null)
				{
					OverlayUtil.renderTextLocation(graphics, textLocation, percentage, Color.WHITE);
				}
			});

			// Second loop: Update stored values if current health info is valid
			NPC[] reds = room.getVerzikReds().keySet().toArray(new NPC[0]);
			for (NPC npc : reds)
			{
				int currentHealthScale = npc.getHealthScale();
				int currentHealthRatio = npc.getHealthRatio();

				if (npc.getName() != null && currentHealthScale > 0 && currentHealthRatio > 0 && currentHealthRatio < 100)
				{
					Pair<Integer, Integer> newVal = new MutablePair<>(currentHealthRatio, currentHealthScale);
					room.getVerzikReds().put(npc, newVal);
				}
				// If current health ratio is invalid, do not update the stored values
			}
		}
	}
}

/*
 * Copyright (c) 2022, Damen <gh: damencs>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:

 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.

 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.

 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.tobqol.rooms.verzik;

import com.tobqol.TheatreQOLConfig;
import com.tobqol.TheatreQOLPlugin;
import com.tobqol.api.game.Region;
import com.tobqol.rooms.RoomHandler;
import com.tobqol.rooms.verzik.commons.Tornado;
import com.tobqol.rooms.verzik.commons.VerzikMap;
import com.tobqol.tracking.RoomDataHandler;
import com.tobqol.tracking.RoomDataItem;
import com.tobqol.tracking.RoomInfoBox;
import lombok.Getter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.*;
import net.runelite.api.coords.WorldPoint;
import net.runelite.api.events.*;
import net.runelite.client.chat.ChatColorType;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.events.ConfigChanged;
import net.runelite.client.util.Text;
import org.apache.commons.lang3.tuple.MutablePair;
import org.apache.commons.lang3.tuple.Pair;

import javax.inject.Inject;
import javax.sound.sampled.Clip;
import javax.sound.sampled.FloatControl;
import java.awt.*;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.function.Predicate;

import static com.tobqol.api.game.Region.XARPUS;
import static com.tobqol.rooms.verzik.commons.VerzikMap.*;
import static com.tobqol.tracking.RoomInfoUtil.createInfoBox;
import static com.tobqol.tracking.RoomInfoUtil.formatTime;

@Slf4j
public class VerzikHandler extends RoomHandler
{
	@Inject
	private VerzikOverlay overlay;

	private RoomDataHandler dataHandler;

	@Getter
	private NPC verzikNpc = null;

	private RoomInfoBox verzikInfoBox;

	@Getter
	private final Map<NPC, Pair<Integer, Integer>> verzikReds = new HashMap<>();

	@Getter
	private final ArrayList<Tornado> tornadoes = new ArrayList<>();

	@Getter
	private final List<WorldPoint> yellows = new ArrayList<>();

	private boolean allYellowsSpawned = false;

	@Getter
	private byte ticksLeft = -1;
	private static Clip soundClip;
	private boolean deathBallSpawned = false;
	private int deathBallSafetyNet = 0;

	@Inject
	protected VerzikHandler(TheatreQOLPlugin plugin, TheatreQOLConfig config)
	{
		super(plugin, config);
		setRoomRegion(Region.VERZIK);

		dataHandler = plugin.getDataHandler();
	}

	@Override
	public void load()
	{
		overlayManager.add(overlay);
		soundClip = generateSoundClip("weewoo-hoyaa.wav", config.sotetsegSoundClipVolume());
	}

	@Override
	public void unload()
	{
		overlayManager.remove(overlay);
		soundClip.close();
		reset();
	}

	@Override
	public boolean active()
	{
		return instance.getCurrentRegion().isVerzik();
	}

	@Override
	public void reset()
	{
		verzikNpc = null;
		verzikReds.clear();
		tornadoes.clear();
		ticksLeft = -1;
		yellows.clear();
		deathBallSpawned = false;
		deathBallSafetyNet = 0;

		if (instance.getRaidStatus() <= 1)
		{
			infoBoxManager.removeInfoBox(verzikInfoBox);
		}
	}

	@Subscribe
	private void onConfigChanged(ConfigChanged e)
	{
		if (!e.getGroup().equals(TheatreQOLConfig.GROUP_NAME) || !instance.getCurrentRegion().isSotetsegUnderworld())
		{
			return;
		}

		switch (e.getKey())
		{
			case "verzikSoundClipVolume":
			{
				if (soundClip != null && config.verzikSoundClip())
				{
					FloatControl control = (FloatControl) soundClip.getControl(FloatControl.Type.MASTER_GAIN);

					if (control != null)
					{
						control.setValue((float)(config.sotetsegSoundClipVolume() / 2 - 45));
					}

					soundClip.setFramePosition(0);
					soundClip.start();
				}
			}
		}
	}

	@Subscribe
	private void onNpcSpawned(NpcSpawned e)
	{
		if (!active())
		{
			return;
		}

		NPC npc = e.getNpc();

		if (npc == null)
		{
			return;
		}

		int id = npc.getId();
		String name = npc.getName();

		if (VerzikMap.matchesAnyMode(VerzikMap.RED_NYLO, npc.getId()))
		{
			verzikReds.putIfAbsent(npc, MutablePair.of(npc.getHealthRatio(), npc.getHealthScale()));

			if (!dataHandler.Find("Reds").isPresent())
			{
				dataHandler.getData().add(new RoomDataItem("Reds", dataHandler.getTime(), false));
			}
		}

		if (VerzikMap.matchesAnyMode(VerzikMap.TORNADO, id))
		{
			tornadoes.add(new Tornado(npc));
		}

		if (name == null)
		{
			return;
		}

		switch (name)
		{
			case VerzikMap.BOSS_NAME:
				instance.lazySetMode(() -> VerzikMap.findMode(id));
				reset();
				verzikNpc = npc;
				break;
		}
	}

	@Subscribe
	private void onNpcChanged(NpcChanged e)
	{
		if (!active())
		{
			return;
		}

		VerzikMap def = VerzikMap.queryTable(e.getNpc().getId());

		if (def == null)
		{
			return;
		}

        if (def == VERZIK_P1)
        {
            if (!dataHandler.Find("Starting Tick").isPresent())
            {
                dataHandler.getData().add(new RoomDataItem("Starting Tick", client.getTickCount(), true));
                dataHandler.setShouldTrack(true);
            }
        }
	}

	@Subscribe
	private void onNpcDespawned(NpcDespawned e)
	{
		if (!active())
		{
			return;
		}

		NPC npc = e.getNpc();
		String name = npc.getName();

		verzikReds.remove(npc);
        tornadoes.remove(npc);

		if(VerzikMap.queryTable(npc.getId()) == VERZIK_P1)
		{
			if (!dataHandler.Find("P1").isPresent())
			{
				dataHandler.getData().add(new RoomDataItem("P1", dataHandler.getTime(), !config.displayTimeSplits()));
			}
		}

		if (name == null)
		{
			return;
		}

		switch (name)
		{
			case VerzikMap.BOSS_NAME:
				reset();
				break;
		}
	}

	@Subscribe
	private void onGameTick(GameTick e)
	{
		if (instance.isInRaid() && instance.getCurrentRegion().isVerzik())
		{
			if (instance.getRoomStatus() == 1 && !dataHandler.Find("Starting Tick").isPresent())
			{
				dataHandler.getData().add(new RoomDataItem("Starting Tick", client.getTickCount(), true, true));
				dataHandler.setShouldTrack(true);

				dataHandler.getData().add(new RoomDataItem("Room", dataHandler.getTime(), 99, false, "P2"));
			}

			if (dataHandler.isShouldTrack() && !dataHandler.getData().isEmpty())
			{
				dataHandler.updateTotalTime();
			}
		}

		if (!active() || verzikNpc == null)
		{
			return;
		}

		VerzikMap def = VerzikMap.queryTable(verzikNpc.getId());

		if (def == null)
		{
			return;
		}

		switch (def)
		{
			case VERZIK_P3:
				tornadoes.forEach(t -> t.shift());

				if (!yellows.isEmpty() && !allYellowsSpawned)
				{
					ticksLeft = 14;

					if (instance.isHardMode())
					{
						ticksLeft = 17;
					}

					allYellowsSpawned = true;
				}

				if (ticksLeft <= 0)
				{
					yellows.clear();
					return;
				}

				ticksLeft--;

				if (deathBallSpawned && deathBallSafetyNet++ == 10)
				{
					deathBallSafetyNet = 0;
					deathBallSpawned = false;
				}
				break;
		}
	}

	@Subscribe
	private void onGraphicsObjectCreated(GraphicsObjectCreated e)
	{
		if (!active() || allYellowsSpawned)
		{
			return;
		}

		GraphicsObject obj = e.getGraphicsObject();

		if (obj.getId() == VerzikMap.YELLOW_POOL)
		{
			WorldPoint wp = WorldPoint.fromLocal(client, obj.getLocation());
			yellows.add(wp);
		}
	}

	@Subscribe
	private void onGraphicChanged(GraphicChanged e)
	{
		if (!active() || yellows.isEmpty() || !(e.getActor() instanceof Player))
		{
			return;
		}

		Player player = (Player) e.getActor();

		if (player.getGraphic() != VerzikMap.YELLOW_GRAPHIC)
		{
			return;
		}

		WorldPoint wp = WorldPoint.fromLocal(client, player.getLocalLocation());
		Predicate<WorldPoint> filter = _wp -> _wp.equals(wp) || _wp.distanceTo2D(wp) <= 1;
		yellows.removeIf(filter);
	}

	@Subscribe
	public void onAnimationChanged(AnimationChanged event)
	{
		if (event.getActor().getAnimation() == VERZIK_P2_TRANSITION)
		{
			if (!dataHandler.Find("P2").isPresent())
			{
				dataHandler.getData().add(new RoomDataItem("P2", dataHandler.getTime(), !config.displayTimeSplits()));
			}
		}
	}

	@Subscribe
	public void onAreaSoundEffectPlayed(AreaSoundEffectPlayed event)
	{
		if (event.getSource() != null && event.getSource().getName() != null && verzikNpc != null && config.muteVerzikSounds())
		{
			if (event.getSoundId() == 3991 || event.getSoundId() == 3987)
			{
				event.consume();
			}
		}
	}

	@Subscribe
	public void onChatMessage(ChatMessage event)
	{
		if (instance.getCurrentRegion() != XARPUS && event.getType() != ChatMessageType.GAMEMESSAGE)
		{
			return;
		}

		String stripped = Text.removeTags(event.getMessage());

		if (VERZIK_WAVE.matcher(stripped).find())
		{
			dataHandler.setShouldTrack(false);
			dataHandler.Find("Room").get().setValue(dataHandler.getTime());

			if (config.displayRoomTimes().isInfobox())
			{
				buildInfobox();
			}

			if (config.displayRoomTimes().isChat())
			{
				sendChatTimes();
			}
		}

		if (event.getMessage().contains(GREEN_BALL_TEXT) || event.getMessage().contains(GREEN_BALL_BOUNCE_TEXT))
		{
			if (!deathBallSpawned)
			{
				if (config.verzikSoundClip())
				{
					soundClip.setFramePosition(0);
					soundClip.start();
				}

				deathBallSpawned = true;
			}
		}
	}

	private void buildInfobox()
	{
		if (!dataHandler.getData().isEmpty())
		{
			String tooltip;

			if (!dataHandler.Find("Starting Tick").get().isException())
			{
				tooltip = "P1 - " + formatTime(dataHandler.FindValue("P1")) + "</br>" +
					"Reds - " + formatTime(dataHandler.FindValue("Reds")) + formatTime(dataHandler.FindValue("Reds"), dataHandler.FindValue("P1")) + "</br>" +
					"P2 - " + formatTime(dataHandler.FindValue("P2")) + formatTime(dataHandler.FindValue("P2"), dataHandler.FindValue("Reds")) + "</br>" +
					"Complete - " + formatTime(dataHandler.FindValue("Room")) + formatTime(dataHandler.FindValue("Room"), dataHandler.FindValue("P2"));
			}
			else
			{
				tooltip = "Complete - " + formatTime(dataHandler.FindValue("Room")) + "*";
			}

			verzikInfoBox = createInfoBox(plugin, config, itemManager.getImage(BOSS_IMAGE), "Verzik", formatTime(dataHandler.FindValue("Room")), tooltip);
			infoBoxManager.addInfoBox(verzikInfoBox);
		}
	}

	private void sendChatTimes()
	{
		if (!dataHandler.getData().isEmpty())
		{
			if (!dataHandler.Find("Starting Tick").get().isException())
			{
				enqueueChatMessage(ChatMessageType.GAMEMESSAGE, b -> b
						.append(Color.RED, "P1")
						.append(ChatColorType.NORMAL)
						.append(" - " + formatTime(dataHandler.FindValue("P1")) + " - ")
						.append(Color.RED, "Reds")
						.append(ChatColorType.NORMAL)
						.append(" - " + formatTime(dataHandler.FindValue("Reds")) + " - " + formatTime(dataHandler.FindValue("Reds"), dataHandler.FindValue("P1")) + " - ")
						.append(Color.RED, "P2")
						.append(ChatColorType.NORMAL)
						.append(" - " + formatTime(dataHandler.FindValue("P2")) + " - " + formatTime(dataHandler.FindValue("P2"), dataHandler.FindValue("Reds"))));

				if (config.roomTimeValidation())
				{
					enqueueChatMessage(ChatMessageType.GAMEMESSAGE, b -> b
							.append(Color.RED, "Verzik - Room Complete")
							.append(ChatColorType.NORMAL)
							.append(" - " + formatTime(dataHandler.FindValue("Room")) + formatTime(dataHandler.FindValue("Room"), dataHandler.FindValue("P2"))));
				}
			}
			else
			{
				if (config.roomTimeValidation())
				{
					enqueueChatMessage(ChatMessageType.GAMEMESSAGE, b -> b
							.append(Color.RED, "Verzik - Room Complete")
							.append(ChatColorType.NORMAL)
							.append(" - " + formatTime(dataHandler.FindValue("Room")) + "*"));
				}
			}
		}
	}
}

/*
 * Copyright (c) 2022, Damen <gh: damencs>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:

 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.

 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.

 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.tobqol.rooms;

import com.tobqol.TheatreQOLConfig;
import net.runelite.client.ui.overlay.Overlay;

public interface RemovableOverlay
{
	Overlay provideOverlay();
	boolean remove(TheatreQOLConfig config);
}

/*
 * Copyright (c) 2022, Damen <gh: damencs>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:

 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.

 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.

 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.tobqol.rooms.sotetseg.commons;

import com.tobqol.api.game.Instance;
import lombok.AccessLevel;
import lombok.Getter;
import lombok.RequiredArgsConstructor;
import net.runelite.api.Point;

import java.util.ArrayList;
import java.util.List;

@RequiredArgsConstructor(access = AccessLevel.PUBLIC)
public class MutableMaze
{
	private static final int xOffset_overworld = 9, yOffset_overworld = 22;
	private static final int xOffset_underworld = 42, yOffset_underworld = 31;

	private final Instance instance;
	private final List<Point> points = new ArrayList();

	@Getter
	private boolean inUnderworld = false;

	@Getter
	private boolean underworldTiles = false;

	public void addPoint(int x, int y)
	{
		Point point = new Point(x - xOffset_overworld, y - yOffset_overworld);

		if (points.contains(point))
		{
			return;
		}

		if (instance.getCurrentRegion().isSotetsegOverworld())
		{
			points.add(new Point(x - xOffset_overworld, y - yOffset_overworld));
		}
		else
		{
			points.add(new Point(x - xOffset_underworld, y - yOffset_underworld));
		}
	}
}

/*
 * Copyright (c) 2022, Damen <gh: damencs>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:

 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.

 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.

 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.tobqol.rooms.sotetseg.commons;

import com.google.common.collect.ImmutableTable;
import com.google.common.collect.Table;
import com.tobqol.api.game.Instance;
import lombok.RequiredArgsConstructor;
import net.runelite.api.GroundObject;
import net.runelite.api.NpcID;
import net.runelite.api.NullNpcID;

@RequiredArgsConstructor
public enum SotetsegTable implements SotetsegConstants
{
	SOTETSEG_NOT_CLICKABLE(NpcID.SOTETSEG_10864, NpcID.SOTETSEG, NpcID.SOTETSEG_10867),
	SOTETSEG_CLICKABLE(NpcID.SOTETSEG_10865, NpcID.SOTETSEG_8388, NpcID.SOTETSEG_10868),
	TORNADO(NullNpcID.NULL_10866, NullNpcID.NULL_8389, NullNpcID.NULL_10869);

	private final int sm;
	private final int rg;
	private final int hm;

	private static final Table<Instance.Mode, Integer, SotetsegTable> TABLE;

	static
	{
		ImmutableTable.Builder<Instance.Mode, Integer, SotetsegTable> builder = ImmutableTable.builder();

		for (SotetsegTable table : values())
		{
			builder.put(Instance.Mode.STORY, table.sm, table);
			builder.put(Instance.Mode.REGULAR, table.rg, table);
			builder.put(Instance.Mode.HARD, table.hm, table);
		}

		TABLE = builder.build();
	}

	public static Instance.Mode findMode(int npcId)
	{
		return Instance.findFirstMode(mode -> TABLE.contains(mode, npcId));
	}

	public static boolean anyMatch(SotetsegTable table, int npcId)
	{
		return table != null && (table.sm == npcId || table.rg == npcId || table.hm == npcId);
	}

	public static boolean isActiveMazeObject(GroundObject obj)
	{
		return obj != null && ACTIVE_MAZE_GROUND_OBJS.contains(obj.getId());
	}
}

package com.tobqol.rooms.sotetseg.commons;

import lombok.EqualsAndHashCode;
import lombok.Value;
import net.runelite.client.party.messages.PartyMemberMessage;

@Value
@EqualsAndHashCode(callSuper = true)
public class SotetsegNotification extends PartyMemberMessage
{
    String name;
    boolean ballSpawned;
}

/*
 * Copyright (c) 2022, Damen <gh: damencs>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:

 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.

 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.

 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.tobqol.rooms.sotetseg.commons;

import com.google.common.collect.ImmutableList;

import java.util.regex.Pattern;

public interface SotetsegConstants
{
	String BOSS_NAME = "Sotetseg";

	int BOSS_IMAGE = 25751;

	Pattern SOTETSEG_WAVE = Pattern.compile("Wave 'Sotetseg' \\(.*\\) complete!");

	String SOTETSEG_DEATHBALL_RAW = "<col=bf0000>A large ball of energy is shot your way...</col>";
	String SOTETSEG_DEATHBALL = "A large ball of energy is shot your way...";

	int MAZE_TELE_ANIM = 1816;

	int SOTETSEG_MELEE_ANIM = 8138;
	int SOTETSEG_MAGIC_ANIM = 8139;

	int DEATH_BALL = 1604;
	int MAGIC_ORB = 1606;
	int RANGE_ORB = 1607;

	int MAZE_UNDERWORLD_PORTAL = 33037; // GameObject

	int INACTIVE_MAZE_GROUND_OBJ_0 = 33033; // Overworld
	int INACTIVE_MAZE_GROUND_OBJ_1 = 33034; // Underworld
	ImmutableList<Integer> ACTIVE_MAZE_GROUND_OBJS = ImmutableList.of(33035, 41750, 41751, 41752, 41753);

	ImmutableList<Integer> UNDERWORLD_ROCKS = ImmutableList.of(33063, 33064, 33065);

	int INFERNO_RANGE = 1378;
	int INFERNO_MAGE = 1380;
	int INFERNO_DEATH_BALL = 1375;
	int TOA_RANGE = 2241;
	int TOA_MAGE = 2224;
	int TOA_DEATH_BALL = 2176;
}

/*
 * Copyright (c) 2022, Damen <gh: damencs>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:

 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.

 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.

 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.tobqol.rooms.sotetseg.config;

import lombok.Getter;
import lombok.RequiredArgsConstructor;

@RequiredArgsConstructor
@Getter
public enum SotetsegProjectileTheme
{
	DEFAULT("Default"),
	INFERNO("Inferno"),
	TOA("ToA");

	private final String option;

	public final boolean isDefault()
	{
		return this == DEFAULT;
	}

	public final boolean isInfernoTheme()
	{
		return this == INFERNO;
	}

	public final boolean isToATheme()
	{
		return this == TOA;
	}

	@Override
	public String toString()
	{
		return option;
	}
}

/*
 * Copyright (c) 2022, Damen <gh: damencs>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:

 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.

 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.

 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.tobqol.rooms.sotetseg.config;

import lombok.Getter;
import lombok.RequiredArgsConstructor;

@RequiredArgsConstructor
@Getter
public enum SotetsegInstanceTimerTypes
{
	OFF("Off"),
	ENTRANCE("Entrance"),
	MAZE("Maze"),
	BOTH("Both");

	private final String option;

	public final boolean showOnlyForEntrance()
	{
		return this == ENTRANCE;
	}

	public final boolean showOnlyForMaze()
	{
		return this == MAZE;
	}

	public final boolean showForAll()
	{
		return this == BOTH;
	}

	@Override
	public String toString()
	{
		return option;
	}
}

/*
 * Copyright (c) 2022, Damen <gh: damencs>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:

 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.

 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.

 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.tobqol.rooms.sotetseg;

import com.tobqol.TheatreQOLConfig;
import com.tobqol.TheatreQOLPlugin;
import com.tobqol.api.game.Region;
import com.tobqol.rooms.RoomHandler;
import com.tobqol.rooms.sotetseg.commons.MutableMaze;
import com.tobqol.rooms.sotetseg.commons.SotetsegNotification;
import com.tobqol.rooms.sotetseg.commons.SotetsegTable;
import com.tobqol.rooms.sotetseg.config.SotetsegProjectileTheme;
import com.tobqol.tracking.RoomDataHandler;
import com.tobqol.tracking.RoomDataItem;
import com.tobqol.tracking.RoomInfoBox;
import lombok.Getter;
import lombok.Setter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.*;
import net.runelite.api.coords.WorldPoint;
import net.runelite.api.events.*;
import net.runelite.api.widgets.Widget;
import net.runelite.client.chat.ChatColorType;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.events.ConfigChanged;
import net.runelite.client.party.PartyService;
import net.runelite.client.party.WSClient;
import net.runelite.client.util.Text;

import javax.annotation.CheckForNull;
import javax.inject.Inject;
import javax.sound.sampled.Clip;
import javax.sound.sampled.FloatControl;
import java.awt.*;

import static com.tobqol.api.game.Region.SOTETSEG;
import static com.tobqol.rooms.sotetseg.commons.SotetsegConstants.*;
import static com.tobqol.rooms.sotetseg.commons.SotetsegTable.SOTETSEG_CLICKABLE;
import static com.tobqol.tracking.RoomInfoUtil.createInfoBox;
import static com.tobqol.tracking.RoomInfoUtil.formatTime;

@Slf4j
public class SotetsegHandler extends RoomHandler
{
	@Inject
	private SotetsegSceneOverlay sceneOverlay;

	private RoomDataHandler dataHandler;

	@Getter
	@CheckForNull
	private NPC sotetsegNpc = null;

	private RoomInfoBox sotetsegInfoBox;

	@Getter
	private boolean clickable = false;

	@Getter
	@CheckForNull
	private MutableMaze maze = null;

	@Getter
	@CheckForNull
	private GameObject portal = null;

	private boolean considerTeleport = true;

	private static Clip soundClip;
	private boolean deathBallSpawned = false;
	private int deathBallSafetyNet = 0;

	@Getter
	@Setter
	private boolean chosen = false;
	public int chosenTextTimeout;

	@Inject
	private WSClient wsClient;

	@Inject
	private PartyService party;

	@Inject
	protected SotetsegHandler(TheatreQOLPlugin plugin, TheatreQOLConfig config)
	{
		super(plugin, config);
		setRoomRegion(Region.SOTETSEG);

		dataHandler = plugin.getDataHandler();
	}

	@Override
	public void load()
	{
		overlayManager.add(sceneOverlay);
		soundClip = generateSoundClip("weewoo-hoyaa.wav", config.sotetsegSoundClipVolume());

		wsClient.registerMessage(SotetsegNotification.class);
	}

	@Override
	public void unload()
	{
		overlayManager.remove(sceneOverlay);
		soundClip.close();
		wsClient.unregisterMessage(SotetsegNotification.class);
		reset();
	}

	@Override
	public boolean active()
	{
		return instance.getCurrentRegion().isSotetseg() && sotetsegNpc != null && !sotetsegNpc.isDead();
	}

	@Override
	public void reset()
	{
		sotetsegNpc = null;
		clickable = false;
		maze = null;
		portal = null;
		considerTeleport = true;
		deathBallSpawned = false;
		deathBallSafetyNet = 0;
		chosen = false;
		chosenTextTimeout = 0;

		if (instance.getRaidStatus() <= 1)
		{
			infoBoxManager.removeInfoBox(sotetsegInfoBox);
		}
	}

	@Subscribe
	private void onConfigChanged(ConfigChanged e)
	{
		if (!e.getGroup().equals(TheatreQOLConfig.GROUP_NAME) || !instance.getCurrentRegion().isSotetsegUnderworld())
		{
			return;
		}

		switch (e.getKey())
		{
			case "sotetsegHideUnderworldRocks":
			{
				when(config.sotetsegHideUnderworldRocks(), this::hideUnderworldRocks, sceneManager::refreshScene);
				break;
			}

			case "sotetsegSoundClipVolume":
			{
				if (soundClip != null && config.sotetsegSoundClip())
				{
					FloatControl control = (FloatControl) soundClip.getControl(FloatControl.Type.MASTER_GAIN);

					if (control != null)
					{
						control.setValue((float)(config.sotetsegSoundClipVolume() / 2 - 45));
					}

					soundClip.setFramePosition(0);
					soundClip.start();
				}
			}
		}
	}

	@Subscribe
	public void onGameTick(GameTick event)
	{
		if (instance.isInRaid() && instance.getCurrentRegion().isSotetseg())
		{
			if (instance.getRoomStatus() == 1 && !dataHandler.Find("Starting Tick").isPresent())
			{
				dataHandler.getData().add(new RoomDataItem("Starting Tick", client.getTickCount(), true, true));
				dataHandler.setShouldTrack(true);

				dataHandler.getData().add(new RoomDataItem("Room", dataHandler.getTime(), 99, false, "33%"));
			}

			if (dataHandler.isShouldTrack() && !dataHandler.getData().isEmpty())
			{
				dataHandler.updateTotalTime();
			}
		}

		if (!active())
		{
			return;
		}

		if (!considerTeleport)
		{
			considerTeleport = true;
		}

		if (deathBallSpawned && deathBallSafetyNet++ == 35)
		{
			deathBallSafetyNet = 0;
			deathBallSpawned = false;
		}

		Widget[] widgetsOfSotetseg = client.getWidget(28, 1).getChildren();
		if (!chosen && config.hideSotetsegWhiteScreen() && client.getWidget(28, 1) != null)
		{
			for (Widget widget : widgetsOfSotetseg)
			{
				if (!widget.getText().isEmpty())
				{
					if (widget.getText().contains("Sotetseg chooses you"))
					{
						chosen = true;
						widget.setText("");
					}
				}
			}
		}
		else if (chosen && chosenTextTimeout++ == 5)
		{
			for (Widget widget : widgetsOfSotetseg)
			{
				if (!widget.getText().isEmpty())
				{
					chosen = false;
					chosenTextTimeout = 0;
					widget.setText("");
				}
			}
		}
	}

	@Subscribe
	public void onClientTick(ClientTick event)
	{
		if (!active())
		{
			return;
		}

		when(config.sotetsegHideUnderworldRocks(), this::hideUnderworldRocks, null);
		when(config.sotetsegHideUnderworldTornado(), this::hideUnderworldTornado, null);
	}

	@Subscribe
	private void onNpcSpawned(NpcSpawned e)
	{
		isNpcFromName(e.getNpc(), BOSS_NAME, n ->
		{
			instance.lazySetMode(() -> SotetsegTable.findMode(n.getId()));
			sotetsegNpc = n;
			clickable = SotetsegTable.anyMatch(SOTETSEG_CLICKABLE, n.getId());
		});
	}

	@Subscribe
	private void onNpcChanged(NpcChanged e)
	{
		if (!active())
		{
			return;
		}

		isNpcFromName(e.getNpc(), BOSS_NAME, n ->
		{
			if (clickable = SotetsegTable.anyMatch(SOTETSEG_CLICKABLE, n.getId()))
			{
				if (!dataHandler.Find("Starting Tick").isPresent())
				{
					dataHandler.getData().add(new RoomDataItem("Starting Tick", client.getTickCount(), true));
					dataHandler.setShouldTrack(true);
				}

				log.debug("[{}] - Sotetseg Changed NPC IDs -> Clickable: {}", client.getTickCount(), clickable);
			}
		});
	}

	@Subscribe
	private void onNpcDespawned(NpcDespawned e)
	{
		if (!active() || client.getPlane() != 0)
		{
			return;
		}

		isNpcFromName(e.getNpc(), BOSS_NAME, n -> reset());
	}

	@Subscribe
	private void onGroundObjectSpawned(GroundObjectSpawned e)
	{
		if (!active())
		{
			return;
		}

		GroundObject obj = e.getGroundObject();

		if (SotetsegTable.isActiveMazeObject(obj))
		{
			if (maze == null)
			{
				maze = new MutableMaze(instance);
			}

			WorldPoint wp = WorldPoint.fromLocal(client, e.getTile().getLocalLocation());
			maze.addPoint(wp.getRegionX(), wp.getRegionY());
		}
	}

	@Subscribe
	private void onGameObjectSpawned(GameObjectSpawned e)
	{
		if (!active() || portal != null)
		{
			return;
		}

		GameObject obj = e.getGameObject();

		if (obj.getId() == SotetsegTable.MAZE_UNDERWORLD_PORTAL)
		{
			portal = obj;
		}

		if (UNDERWORLD_ROCKS.contains(obj.getId()))
		{
			when(config.sotetsegHideUnderworldRocks(), this::hideUnderworldRocks, null);
		}
	}

	@Subscribe
	private void onGameObjectDespawned(GameObjectDespawned e)
	{
		if (!active() || portal == null)
		{
			return;
		}

		if (e.getGameObject().getId() == SotetsegTable.MAZE_UNDERWORLD_PORTAL)
		{
			portal = null;
		}
	}

	@Subscribe
	public void onProjectileMoved(ProjectileMoved projectileMoved)
	{
		if (!instance.getCurrentRegion().isSotetseg())
		{
			return;
		}

		SotetsegProjectileTheme theme = config.getSotetsegProjectileTheme();

		Projectile projectile = projectileMoved.getProjectile();
		int projectileId = projectile.getId();

		if (projectileId == DEATH_BALL && !deathBallSpawned)
		{
			if (config.sotetsegSoundClip())
			{
				soundClip.setFramePosition(0);
				soundClip.start();
			}

			deathBallSpawned = true;
		}

		if (!theme.isDefault())
		{
			int replacement = -1;

			switch (projectileId)
			{
				case RANGE_ORB:
				{
					switch (theme)
					{
						case INFERNO:
							replacement = INFERNO_RANGE;
							break;

						case TOA:
							replacement = TOA_RANGE;
							break;
					}
					break;
				}
				case MAGIC_ORB:
				{
					switch (theme)
					{
						case INFERNO:
							replacement = INFERNO_MAGE;
							break;

						case TOA:
							replacement = TOA_MAGE;
							break;
					}
					break;
				}
				case DEATH_BALL:
				{
					if (config.themedDeathBall())
					{
						switch (theme)
						{
							case INFERNO:
								replacement = INFERNO_DEATH_BALL;
								break;

							case TOA:
								replacement = TOA_DEATH_BALL;
								break;
						}
					}
				}
			}

			if (replacement == -1)
			{
				return;
			}

			Projectile p = client.createProjectile(replacement,
					projectile.getFloor(),
					projectile.getX1(), projectile.getY1(),
					projectile.getHeight(),
					projectile.getStartCycle(), projectile.getEndCycle(),
					projectile.getSlope(),
					projectile.getStartHeight(), projectile.getEndHeight(),
					projectile.getInteracting(),
					projectile.getTarget().getX(), projectile.getTarget().getY());

			client.getProjectiles().addLast(p);
			projectile.setEndCycle(0);
		}
	}

	@Subscribe
	public void onAnimationChanged(AnimationChanged event)
	{
		if (active())
		{
			if (considerTeleport && event.getActor().getAnimation() == MAZE_TELE_ANIM)
			{
				boolean phase = dataHandler.Find("66%").isPresent();
				dataHandler.getData().add(new RoomDataItem(phase ? "33%" : "66%", dataHandler.getTime(), phase ? 2 : 1, !config.displayTimeSplits()));
				considerTeleport = false;

				if (deathBallSpawned)
				{
					deathBallSpawned = false;
				}
			}
		}
	}

	@Subscribe
	public void onChatMessage(ChatMessage event)
	{
		if (instance.getCurrentRegion() != SOTETSEG && event.getType() != ChatMessageType.GAMEMESSAGE)
		{
			return;
		}

		String stripped = Text.removeTags(event.getMessage());

		if (stripped.equals(SOTETSEG_DEATHBALL) && party.isInParty())
		{
			clientThread.invokeLater(() -> party.send(new SotetsegNotification(client.getLocalPlayer().getName(), true)));
		}

		if (SOTETSEG_WAVE.matcher(stripped).find())
		{
			dataHandler.setShouldTrack(false);
			dataHandler.Find("Room").get().setValue(dataHandler.getTime());

			if (config.displayRoomTimes().isInfobox())
			{
				buildInfobox();
			}

			if (config.displayRoomTimes().isChat())
			{
				sendChatTimes();
			}
		}
	}

	@Subscribe
	public void onSotetsegNotification(SotetsegNotification event)
	{
		if (!active())
		{
			return;
		}

		clientThread.invokeLater(() -> {
			if (!deathBallSpawned)
			{
				if (config.sotetsegSoundClip())
				{
					soundClip.setFramePosition(0);
					soundClip.start();
				}

				deathBallSpawned = true;
				enqueueChatMessage(ChatMessageType.GAMEMESSAGE, b -> b
						.append(new Color(167, 112, 225), event.getName() + " has discovered a large ball of energy shot their way..."));
			}
		});
	}

	private void buildInfobox()
	{
		if (!dataHandler.getData().isEmpty())
		{
			String tooltip;

			if (!dataHandler.Find("Starting Tick").get().isException())
			{
				tooltip = "66% - " + formatTime(dataHandler.FindValue("66%")) + "</br>" +
						"33% - " + formatTime(dataHandler.FindValue("33%")) + formatTime(dataHandler.FindValue("33%"), dataHandler.FindValue("66%")) + "</br>" +
						"Complete - " + formatTime(dataHandler.FindValue("Room")) + formatTime(dataHandler.FindValue("Room"), dataHandler.FindValue("33%"));
			}
			else
			{
				tooltip = "Complete - " + formatTime(dataHandler.FindValue("Room")) + "*";
			}

			sotetsegInfoBox = createInfoBox(plugin, config, itemManager.getImage(BOSS_IMAGE), "Sotetseg", formatTime(dataHandler.FindValue("Room")), tooltip);
			infoBoxManager.addInfoBox(sotetsegInfoBox);
		}
	}

	private void sendChatTimes()
	{
		if (!dataHandler.getData().isEmpty())
		{
			if (!dataHandler.Find("Starting Tick").get().isException())
			{
				enqueueChatMessage(ChatMessageType.GAMEMESSAGE, b -> b
						.append(Color.RED, "66%")
						.append(ChatColorType.NORMAL)
						.append(" - " + formatTime(dataHandler.FindValue("66%")) + " - ")
						.append(Color.RED, "33%")
						.append(ChatColorType.NORMAL)
						.append(" - " + formatTime(dataHandler.FindValue("33%")) + formatTime(dataHandler.FindValue("33%"), dataHandler.FindValue("66%"))));

				if (config.roomTimeValidation())
				{
					enqueueChatMessage(ChatMessageType.GAMEMESSAGE, b -> b
							.append(Color.RED, "Sotetseg - Room Complete")
							.append(ChatColorType.NORMAL)
							.append(" - " + formatTime(dataHandler.FindValue("Room")) + formatTime(dataHandler.FindValue("Room"), dataHandler.FindValue("33%"))));
				}
			}
			else
			{
				if (config.roomTimeValidation())
				{
					enqueueChatMessage(ChatMessageType.GAMEMESSAGE, b -> b
							.append(Color.RED, "Sotetseg - Room Complete")
							.append(ChatColorType.NORMAL)
							.append(" - " + formatTime(dataHandler.FindValue("Room")) + "*"));
				}
			}
		}
	}

	private void hideUnderworldRocks()
	{
		if (instance.getCurrentRegion().isSotetsegUnderworld())
		{
			sceneManager.removeTheseGameObjects(3, UNDERWORLD_ROCKS);
		}
	}

	private void hideUnderworldTornado()
	{
		if (instance.getCurrentRegion().isSotetsegUnderworld())
		{
			Player player = client.getLocalPlayer();
			if (player == null)
			{
				return;
			}
			player.clearSpotAnims();
		}
	}
}

/*
 * Copyright (c) 2022, Damen <gh: damencs>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:

 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.

 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.

 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.tobqol.rooms.sotetseg;

import com.tobqol.TheatreQOLConfig;
import com.tobqol.TheatreQOLPlugin;
import com.tobqol.api.game.Instance;
import com.tobqol.rooms.RoomSceneOverlay;
import com.tobqol.rooms.sotetseg.config.SotetsegInstanceTimerTypes;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.client.ui.overlay.OverlayLayer;
import net.runelite.client.ui.overlay.OverlayUtil;

import javax.inject.Inject;
import java.awt.*;

@Slf4j
public class SotetsegSceneOverlay extends RoomSceneOverlay<SotetsegHandler>
{
	@Inject
	protected SotetsegSceneOverlay(
			Client client,
			Instance instance,
			SotetsegHandler room,
			TheatreQOLPlugin plugin,
			TheatreQOLConfig config
	)
	{
		super(client, instance, room, plugin, config);
	}

	@Override
	public Dimension render(Graphics2D graphics)
	{
		if (!room.active() || room.isClickable())
		{
			if (config.debugSotetsegChosenText())
			{
				drawChosenOverlay(graphics);
			}
			return null;
		}

		setLayer(OverlayLayer.UNDER_WIDGETS);
		graphics.setFont(plugin.getInstanceTimerFont());

		drawSoteInstanceTimers(graphics);
		drawChosenOverlay(graphics);

		return null;
	}

	private void drawSoteInstanceTimers(Graphics2D graphics)
	{
		SotetsegInstanceTimerTypes type = config.getSotetsegInstanceTimerType();
		graphics.setFont(plugin.getInstanceTimerFont());

		switch (instance.getRoomStatus())
		{
			case 0:
				if (type.showOnlyForEntrance() || type.showForAll())
				{
					drawInstanceTimer(graphics, room.getSotetsegNpc(), room.getPortal());
				}
				break;
			case 1:
			case 2:
				if (type.showOnlyForMaze() || type.showForAll())
				{
					drawInstanceTimer(graphics, room.getSotetsegNpc(), room.getPortal());
				}
				break;
		}
	}

	private void drawChosenOverlay(Graphics2D graphics)
	{
		if ((room.isChosen() || config.debugSotetsegChosenText()) && config.hideSotetsegWhiteScreen() && config.showSotetsegChosenText())
		{
			String text = "You have been chosen.";
			graphics.setFont(new Font(config.fontType().getName(), config.fontStyle().getValue(), 20));
			int width = graphics.getFontMetrics().stringWidth(text);
			int drawX = client.getViewportWidth() / 2 - width / 2;
			int drawY = client.getViewportHeight() - (client.getViewportHeight() / 2) + (config.sotetsegChosenTextOffset() * 10);
			OverlayUtil.renderTextLocation(graphics, new net.runelite.api.Point(drawX, drawY), text, Color.WHITE);
		}
	}
}

/*
 * Copyright (c) 2022, Damen <gh: damencs>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:

 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.

 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.

 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.tobqol.rooms;

import com.google.common.collect.Multimap;
import com.tobqol.TheatreQOLConfig;
import com.tobqol.TheatreQOLPlugin;
import com.tobqol.api.game.Instance;
import com.tobqol.api.util.TriConsumer;
import com.tobqol.rooms.sotetseg.commons.SotetsegTable;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Point;
import net.runelite.api.*;
import net.runelite.client.ui.overlay.*;

import javax.annotation.Nullable;
import javax.inject.Inject;
import java.awt.*;
import java.util.function.BiConsumer;

import static com.tobqol.rooms.sotetseg.commons.SotetsegTable.SOTETSEG_CLICKABLE;
import static com.tobqol.rooms.sotetseg.commons.SotetsegTable.SOTETSEG_NOT_CLICKABLE;

@Slf4j
public abstract class RoomSceneOverlay<R extends RoomHandler> extends Overlay
{
	protected final Client client;
	protected final Instance instance;
	protected final R room;
	protected final TheatreQOLPlugin plugin;
	protected final TheatreQOLConfig config;

	@Inject
	protected RoomSceneOverlay(
			Client client,
			Instance instance,
			R room,
			TheatreQOLPlugin plugin,
			TheatreQOLConfig config
	)
	{
		this.client = client;
		this.instance = instance;
		this.room = room;
		this.plugin = plugin;
		this.config = config;

		setPriority(OverlayPriority.HIGH);
		setPosition(OverlayPosition.DYNAMIC);
		setLayer(OverlayLayer.ABOVE_SCENE);
	}

	protected final void drawInstanceTimer(Graphics2D graphics, @Nullable NPC npc, @Nullable TileObject tileObject)
	{
		int tickCycle = instance.getTickCycle();

		if (tickCycle == -1)
		{
			return;
		}

		Player player = client.getLocalPlayer();

		if (player == null)
		{
			return;
		}

		String text = Integer.toString(tickCycle);

		Color color;
		if (npc != null && (SotetsegTable.anyMatch(SOTETSEG_CLICKABLE, npc.getId()) || SotetsegTable.anyMatch(SOTETSEG_NOT_CLICKABLE, npc.getId())))
		{
			color = tickCycle == 3 ? Color.GREEN.brighter() : Color.RED.brighter();
		}
		else
		{
			color = tickCycle > 0 ? Color.RED.brighter() : Color.GREEN.brighter();
		}

		Point textLocation = player.getCanvasTextLocation(graphics, text, player.getLogicalHeight() + 60 + (config.instanceTimerOffset() * 10));

		if (textLocation != null)
		{
			OverlayUtil.renderTextLocation(graphics, textLocation, text, color);
		}

		if (tileObject != null)
		{
			Point tileObjectLocation = tileObject.getCanvasTextLocation(graphics, text, 50);
			if (tileObjectLocation != null)
			{
				OverlayUtil.renderTextLocation(graphics, tileObjectLocation, text, color);
			}
		}

		if (npc != null)
		{
			Point npcLocation = npc.getCanvasTextLocation(graphics, text, 50);
			if (npcLocation != null)
			{
				OverlayUtil.renderTextLocation(graphics, npcLocation, text, color);
			}
		}
	}

	public static <K, V> void traverseMultimap(Graphics2D graphics, Multimap<K, V> multimap, BiConsumer<K, Integer> before, TriConsumer<K, V, Integer> after)
	{
		if (multimap == null || multimap.isEmpty())
		{
			return;
		}

		for (K k : multimap.keys())
		{
			int offset = 0;
			if (k != null && before != null)
			{
				before.accept(k, offset);
			}

			for (V v : multimap.get(k))
			{
				if (k != null && v != null && after != null)
				{
					after.accept(k, v, offset);
				}
				offset += graphics.getFontMetrics().getHeight();
			}
		}
	}
}

/*
 * Copyright (c) 2022, Damen <gh: damencs>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:

 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.

 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.

 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.tobqol.rooms.maiden.commons;

import net.runelite.api.NullObjectID;

import java.util.regex.Pattern;

public interface MaidenConstants
{
	String BOSS_NAME = "The Maiden of Sugadinti";
	String BOSS_NAME_SIMPLE = "Maiden";

	int BOSS_IMAGE = 25748;

	Pattern MAIDEN_WAVE = Pattern.compile("Wave 'The Maiden of Sugadinti' \\(.*\\) complete!");

	String RED_CRAB_NAME = "Nylocas Matomenos";
	String BLOOD_SPAWN_NAME = "Blood spawn";

	int MAIDEN_BLOOD_TOSS_ANIM = 8091;
	int MAIDEN_ATTACK_ANIM = 8092;
	int MAIDEN_DEATH_ANIM = 8093;

	int RED_CRAB_DEATH_ANIM = 8097;

	int BLOOD_TOSS_PROJ = 1578;

	int BLOOD_SPLAT_ID = 1579;                      // GraphicObject
	int BLOOD_TRAIL_ID = NullObjectID.NULL_32984;   // GameObject
}

/*
 * Copyright (c) 2022, Damen <gh: damencs>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:

 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.

 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.

 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.tobqol.rooms.maiden.commons;

import com.google.common.collect.ImmutableMap;
import lombok.Getter;
import lombok.RequiredArgsConstructor;
import lombok.experimental.Accessors;
import net.runelite.api.NPC;

import java.util.HashMap;
import java.util.Map;

@RequiredArgsConstructor
@Getter
@Accessors(fluent = true)
public enum MaidenPhase
{
	P1("70s"),
	P2("50s"),
	P3("30s"),
	OTHER("*");

	private final String key;

	private static final Map<Integer, MaidenPhase> LOOKUP;

	static
	{
		ImmutableMap.Builder<Integer, MaidenPhase> builder = ImmutableMap.builder();

		Map<MaidenTable, MaidenPhase> phases = new HashMap<>();

		phases.put(MaidenTable.MAIDEN_P0, MaidenPhase.P1);
		phases.put(MaidenTable.MAIDEN_P1, MaidenPhase.P2);
		phases.put(MaidenTable.MAIDEN_P2, MaidenPhase.P3);


		phases.forEach((table, phase) ->
		{
			builder.put(table.sm(), phase);
			builder.put(table.rg(), phase);
			builder.put(table.hm(), phase);
		});

		LOOKUP = builder.build();
	}

	public static MaidenPhase compose(NPC npc)
	{
		if (npc == null)
		{
			return OTHER;
		}

		return LOOKUP.getOrDefault(npc.getId(), OTHER);
	}

	public boolean isPhaseOne()
	{
		return this == P1;
	}

	public boolean isPhaseTwo()
	{
		return this == P2;
	}

	public boolean isPhaseThree()
	{
		return this == P3;
	}

	public boolean isNonTrackedPhase()
	{
		return this == OTHER;
	}
}

/*
 * Copyright (c) 2022, Damen <gh: damencs>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:

 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.

 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.

 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.tobqol.rooms.maiden.commons;

import com.tobqol.api.game.Health;

public class MaidenHealth extends Health
{
	public MaidenHealth(int base)
	{
		super(base);
	}
}

/*
 * Copyright (c) 2022, Damen <gh: damencs>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:

 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.

 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.

 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.tobqol.rooms.maiden.commons;

import com.google.common.collect.ImmutableTable;
import com.google.common.collect.Table;
import com.tobqol.api.game.Instance;
import lombok.Getter;
import lombok.RequiredArgsConstructor;
import lombok.experimental.Accessors;
import net.runelite.api.Client;
import net.runelite.api.NPC;
import net.runelite.api.NpcID;
import net.runelite.api.coords.WorldPoint;
import org.apache.commons.lang3.tuple.Pair;

import javax.annotation.Nullable;

import static com.google.common.collect.Tables.immutableCell;

@RequiredArgsConstructor
@Getter
@Accessors(fluent = true)
public enum MaidenTable implements MaidenConstants
{
	MAIDEN_P0(NpcID.THE_MAIDEN_OF_SUGADINTI_10814, NpcID.THE_MAIDEN_OF_SUGADINTI, NpcID.THE_MAIDEN_OF_SUGADINTI_10822),         // Pre-70s
	MAIDEN_P1(NpcID.THE_MAIDEN_OF_SUGADINTI_10815, NpcID.THE_MAIDEN_OF_SUGADINTI_8361, NpcID.THE_MAIDEN_OF_SUGADINTI_10823),    // Post-70s
	MAIDEN_P2(NpcID.THE_MAIDEN_OF_SUGADINTI_10816, NpcID.THE_MAIDEN_OF_SUGADINTI_8362, NpcID.THE_MAIDEN_OF_SUGADINTI_10824),    // Post-50s
	MAIDEN_P3(NpcID.THE_MAIDEN_OF_SUGADINTI_10817, NpcID.THE_MAIDEN_OF_SUGADINTI_8363, NpcID.THE_MAIDEN_OF_SUGADINTI_10825),    // Post-30s
	MAIDEN_DESPAWN_0(NpcID.THE_MAIDEN_OF_SUGADINTI_10818, NpcID.THE_MAIDEN_OF_SUGADINTI_8364, NpcID.THE_MAIDEN_OF_SUGADINTI_10826),
	MAIDEN_DESPAWN_1(NpcID.THE_MAIDEN_OF_SUGADINTI_10819, NpcID.THE_MAIDEN_OF_SUGADINTI_8365, NpcID.THE_MAIDEN_OF_SUGADINTI_10827),
	BLOOD_SPAWN(NpcID.BLOOD_SPAWN_10821, NpcID.BLOOD_SPAWN, NpcID.BLOOD_SPAWN_10829),
	RED_CRAB(NpcID.NYLOCAS_MATOMENOS_10820, NpcID.NYLOCAS_MATOMENOS, NpcID.NYLOCAS_MATOMENOS_10828);

	private final int sm, rg, hm;

	private static final Table<Instance.Mode, Integer, MaidenTable> LOOKUP_TABLE;
	private static final Table<String, Integer, Boolean> SPAWNS_TABLE;

	static
	{
		ImmutableTable.Builder<Instance.Mode, Integer, MaidenTable> l_builder = ImmutableTable.builder();

		for (MaidenTable def : values())
		{
			l_builder.put(immutableCell(Instance.Mode.STORY, def.sm, def));
			l_builder.put(immutableCell(Instance.Mode.REGULAR, def.rg, def));
			l_builder.put(immutableCell(Instance.Mode.HARD, def.hm, def));
		}

		LOOKUP_TABLE = l_builder.build();

		ImmutableTable.Builder<String, Integer, Boolean> s_builder = ImmutableTable.builder();
		s_builder.put(immutableCell("N1", 23 << 8 | 42, true));
		s_builder.put(immutableCell("N1", 22 << 8 | 41, false));
		s_builder.put(immutableCell("N2", 27 << 8 | 42, true));
		s_builder.put(immutableCell("N2", 26 << 8 | 41, false));
		s_builder.put(immutableCell("N3", 31 << 8 | 42, true));
		s_builder.put(immutableCell("N3", 30 << 8 | 41, false));
		s_builder.put(immutableCell("N4 (1)", 35 << 8 | 42, true));
		s_builder.put(immutableCell("N4 (1)", 34 << 8 | 41, false));
		s_builder.put(immutableCell("N4 (2)", 35 << 8 | 40, true));
		s_builder.put(immutableCell("N4 (2)", 34 << 8 | 39, false));
		s_builder.put(immutableCell("S1", 23 << 8 | 20, true));
		s_builder.put(immutableCell("S1", 22 << 8 | 21, false));
		s_builder.put(immutableCell("S2", 27 << 8 | 20, true));
		s_builder.put(immutableCell("S2", 26 << 8 | 21, false));
		s_builder.put(immutableCell("S3", 31 << 8 | 20, true));
		s_builder.put(immutableCell("S3", 30 << 8 | 21, false));
		s_builder.put(immutableCell("S4 (1)", 35 << 8 | 20, true));
		s_builder.put(immutableCell("S4 (1)", 34 << 8 | 21, false));
		s_builder.put(immutableCell("S4 (2)", 35 << 8 | 22, true));
		s_builder.put(immutableCell("S4 (2)", 34 << 8 | 23, false));
		SPAWNS_TABLE = s_builder.build();
	}

	@Nullable
	public static Instance.Mode findMode(int npcId)
	{
		return Instance.findFirstMode(mode -> LOOKUP_TABLE.get(mode, npcId) != null);
	}

	@Nullable
	public static Pair<String, Boolean> lookupMatomenosSpawn(Client client, @Nullable NPC npc)
	{
		if (npc == null)
		{
			return null;
		}

		WorldPoint wp = WorldPoint.fromLocal(client, npc.getLocalLocation());
		int packed = wp.getRegionX() << 8 | wp.getRegionY();

		for (String spawnKey : SPAWNS_TABLE.rowKeySet())
		{
			Boolean scuffed = SPAWNS_TABLE.get(spawnKey, packed);

			if (scuffed == null)
			{
				continue;
			}

			return Pair.of(spawnKey, scuffed);
		}

		return null;
	}
}
/*
 * Copyright (c) 2022, Damen <gh: damencs>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:

 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.

 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.

 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.tobqol.rooms.maiden.commons;

import com.tobqol.api.game.Health;
import com.tobqol.api.game.Hitpoints;
import com.tobqol.api.game.Instance;
import lombok.AccessLevel;
import lombok.EqualsAndHashCode;
import lombok.Getter;
import lombok.experimental.Accessors;
import lombok.experimental.FieldDefaults;
import net.runelite.api.Actor;
import net.runelite.api.Client;
import net.runelite.api.NPC;
import org.apache.commons.lang3.tuple.Pair;

import java.util.function.Predicate;

@FieldDefaults(level = AccessLevel.PRIVATE, makeFinal = true)
@Getter
@Accessors(fluent = true)
@EqualsAndHashCode(of = "npc", doNotUseGetters = true)
public class MaidenRedCrab implements Predicate<NPC>
{
	NPC npc;
	Health health;
	String phaseKey;
	String spawnKey;
	boolean scuffed;

	public MaidenRedCrab(Client client, Instance instance, NPC npc, MaidenPhase phase)
	{
		this.npc = npc;
		this.health = new Health(Hitpoints.MAIDEN_MATOMENOS.getBaseHP(instance));
		this.phaseKey = phase.key();

		Pair<String, Boolean> id = MaidenTable.lookupMatomenosSpawn(client, npc);
		this.spawnKey = id == null ? "Unknown" : id.getLeft();
		this.scuffed = id != null && id.getRight();
	}

	public int distance(Actor actor)
	{
		if (actor == null)
		{
			return -1;
		}

		return npc.getWorldArea().distanceTo2D(actor.getWorldArea()) - 1;
	}

	@Override
	public boolean test(NPC npc)
	{
		return npc != null && (npc == this.npc || npc.getIndex() == this.npc.getIndex());
	}
}

/*
 * Copyright (c) 2022, Damen <gh: damencs>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:

 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.

 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.

 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.tobqol.rooms.maiden;

import com.tobqol.TheatreQOLConfig;
import com.tobqol.TheatreQOLPlugin;
import com.tobqol.rooms.RoomHandler;
import com.tobqol.rooms.maiden.commons.MaidenHealth;
import com.tobqol.rooms.maiden.commons.MaidenPhase;
import com.tobqol.rooms.maiden.commons.MaidenRedCrab;
import com.tobqol.rooms.maiden.commons.MaidenTable;
import com.tobqol.tracking.RoomDataHandler;
import com.tobqol.tracking.RoomDataItem;
import com.tobqol.tracking.RoomInfoBox;
import lombok.Getter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.ChatMessageType;
import net.runelite.api.Hitsplat;
import net.runelite.api.NPC;
import net.runelite.api.Point;
import net.runelite.api.events.*;
import net.runelite.client.chat.ChatColorType;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.util.Text;

import javax.annotation.CheckForNull;
import javax.inject.Inject;
import java.awt.*;
import java.util.List;
import java.util.*;

import static com.tobqol.api.game.Region.MAIDEN;
import static com.tobqol.api.game.Region.inRegion;
import static com.tobqol.rooms.maiden.commons.MaidenConstants.*;
import static com.tobqol.tracking.RoomInfoUtil.createInfoBox;
import static com.tobqol.tracking.RoomInfoUtil.formatTime;
import static lombok.AccessLevel.NONE;

@Getter
@Slf4j
public class MaidenHandler extends RoomHandler
{
	@Inject
	private MaidenSceneOverlay sceneOverlay;

	private RoomDataHandler dataHandler;

	@CheckForNull
	private NPC maidenNpc = null;

	private RoomInfoBox maidenInfoBox;

	@CheckForNull
	private MaidenHealth health = null;

	private MaidenPhase phase = MaidenPhase.OTHER;

	private final List<NPC> bloodSpawns = new ArrayList<>();

	private final Map<Integer, MaidenRedCrab> crabsMap = new HashMap<>();

	@Getter(NONE) // Omit Lombok's Getter
	private final List<MaidenRedCrab> crabs_buffer = new ArrayList<>();

	@Getter(NONE) // Omit Lombok's Getter
	private byte totalLeaks = 0;

	private boolean considerCrabs = true;

	private final Point MAIDEN_GATE_START = new Point(32 , 29);
	private final Point MAIDEN_GATE_END = new Point(32, 32);

	@Inject
	protected MaidenHandler(TheatreQOLPlugin plugin, TheatreQOLConfig config)
	{
		super(plugin, config);
		setRoomRegion(MAIDEN);
	}

	@Override
	public void load()
	{
		dataHandler = plugin.getDataHandler();
		overlayManager.add(sceneOverlay);
	}

	@Override
	public void unload()
	{
		overlayManager.remove(sceneOverlay);
		reset();
	}

	@Override
	public void reset()
	{
		maidenNpc = null;
		phase = MaidenPhase.OTHER;

		bloodSpawns.clear();
		crabsMap.clear();
		crabs_buffer.clear();
		totalLeaks = 0;
		considerCrabs = true;

		if (instance.getRaidStatus() <= 1)
		{
			infoBoxManager.removeInfoBox(maidenInfoBox);
		}
	}

	@Override
	public boolean active()
	{
		return inRegion(client, MAIDEN) && maidenNpc != null && !maidenNpc.isDead();
	}

	@Subscribe
	private void onNpcSpawned(NpcSpawned e)
	{
		NPC npc = e.getNpc();

		if (active())
		{
			isNpcFromName(npc, MaidenTable.BLOOD_SPAWN_NAME, (n -> bloodSpawns.add(npc)));
			isNpcFromName(npc, MaidenTable.RED_CRAB_NAME, n ->
			{
				crabsMap.put(n.getIndex(), new MaidenRedCrab(client, instance, n, phase));

				if (!dataHandler.getData().isEmpty() & considerCrabs)
				{
					considerCrabs = false;

					if (!dataHandler.Find("70s").isPresent())
					{
						dataHandler.getData().add(new RoomDataItem("70s", dataHandler.getTime(), 1, !config.displayTimeSplits()));
						return;
					}
					else if (!dataHandler.Find("50s").isPresent() && dataHandler.Find("70s").isPresent())
					{
						dataHandler.getData().add(new RoomDataItem("50s", dataHandler.getTime(), 2, !config.displayTimeSplits(), "70s"));
						return;
					}
					else if (!dataHandler.Find("30s").isPresent() && dataHandler.Find("50s").isPresent())
					{
						dataHandler.getData().add(new RoomDataItem("30s", dataHandler.getTime(), 3, !config.displayTimeSplits(), "50s"));
						return;
					}
				}
			});
			return;
		}

		isNpcFromName(npc, BOSS_NAME, n ->
		{
			if (!dataHandler.Find("Starting Tick").isPresent())
			{
				dataHandler.getData().add(new RoomDataItem("Starting Tick", client.getTickCount(), true));
				dataHandler.setShouldTrack(true);

				dataHandler.getData().add(new RoomDataItem("Room", dataHandler.getTime(), 99, false, "30s"));
			}

			instance.lazySetMode(() -> MaidenTable.findMode(n.getId()));
			maidenNpc = n;
			phase = MaidenPhase.compose(n);
		});
	}

	@Subscribe
	private void onNpcChanged(NpcChanged e)
	{
		if (!active())
		{
			return;
		}

		isNpcFromName(e.getNpc(), BOSS_NAME, n ->
		{
			phase = MaidenPhase.compose(n);
		});
	}

	@Subscribe
	private void onNpcDespawned(NpcDespawned e)
	{
		if (!active())
		{
			return;
		}

		NPC npc = e.getNpc();

		if (isNpcFromName(npc, BOSS_NAME, $ -> reset()))
		{
			return;
		}

		isNpcFromName(npc, MaidenTable.BLOOD_SPAWN_NAME, n -> bloodSpawns.removeIf(s -> s != null && npc.getIndex() == s.getIndex()));

		isNpcFromName(npc, MaidenTable.RED_CRAB_NAME, n ->
		{
			crabsMap.remove(n.getIndex());
			crabs_buffer.removeIf(crab -> crab.test(n));
		});
	}

	@Subscribe
	private void onGameTick(GameTick e)
	{
		if (instance.isInRaid() && inRegion(client, MAIDEN))
		{
			if (!dataHandler.Find("Starting Tick").isPresent())
			{
				boolean crossedMaidenLine = crossedLine(MAIDEN, MAIDEN_GATE_START, MAIDEN_GATE_END, true, client);
				if (crossedMaidenLine)
				{
					dataHandler.getData().add(new RoomDataItem("Starting Tick", client.getTickCount(), true));
					dataHandler.setShouldTrack(true);

					dataHandler.getData().add(new RoomDataItem("Room", dataHandler.getTime(), 99, false, "30s"));
				}

				if (instance.getRoomStatus() == 1)
				{
					dataHandler.getData().add(new RoomDataItem("Starting Tick", client.getTickCount(), true, true));
					dataHandler.setShouldTrack(true);
				}
			}

			if (dataHandler.isShouldTrack() && !dataHandler.getData().isEmpty())
			{
				dataHandler.updateTotalTime();
			}
		}

		if (!active())
		{
			return;
		}

		if (!considerCrabs)
		{
			considerCrabs = true;
		}

		if (!crabs_buffer.isEmpty())
		{
			crabs_buffer.removeIf(crab ->
			{
				if (crab.distance(maidenNpc) == 0 && !crab.health().zero())
				{
					if (config.displayMaidenLeaks())
					{
						enqueueChatMessage(ChatMessageType.FRIENDNOTIFICATION, b -> b
								.append(Color.BLUE, "[" + crab.phaseKey() + "]")
								.append(ChatColorType.NORMAL)
								.append(" - " + crab.spawnKey() + " leaked with ")
								.append(Color.RED, crab.health().truncatedPercent() + "%")
								.append(ChatColorType.NORMAL)
								.append(" hitpoints!"));
					}

					totalLeaks++;
				}

				return true;
			});
		}
	}

	@Subscribe
	private void onAnimationChanged(AnimationChanged e)
	{
		if (!active() || !(e.getActor() instanceof NPC))
		{
			return;
		}

		isNpcFromName((NPC) e.getActor(), BOSS_NAME, n ->
		{
			switch (n.getAnimation())
			{
				case -1: break;
				case MaidenTable.MAIDEN_DEATH_ANIM:
				{
					reset();
					break;
				}
			}
		});

		isNpcFromName((NPC) e.getActor(), RED_CRAB_NAME, n ->
		{
			if (n.getAnimation() == MaidenTable.RED_CRAB_DEATH_ANIM)
			{
				Optional.ofNullable(crabsMap.getOrDefault(n.getIndex(), null)).ifPresent(crabs_buffer::add);
			}
		});
	}

	@Subscribe
	private void onHitsplatApplied(HitsplatApplied e)
	{
		if (!active() || !(e.getActor() instanceof NPC))
		{
			return;
		}

		NPC npc = (NPC) e.getActor();
		Hitsplat hitsplat = e.getHitsplat();
		int amount = hitsplat.getAmount();

		isNpcFromName(npc, BOSS_NAME, n ->
		{
			if (hitsplat.isMine() || hitsplat.isOthers())
			{
				Optional.ofNullable(health).ifPresent(h -> h.removeHealth(amount));
				return;
			}
		});

		isNpcFromName(npc, RED_CRAB_NAME, n ->
		{
			MaidenRedCrab crab = crabsMap.getOrDefault(n.getIndex(), null);

			if (crab == null || (!hitsplat.isMine() && !hitsplat.isOthers()))
			{
				return;
			}

			crab.health().removeHealth(amount);
		});
	}

	@Subscribe
	public void onChatMessage(ChatMessage event)
	{
		if (instance.getCurrentRegion() != MAIDEN && event.getType() != ChatMessageType.GAMEMESSAGE)
		{
			return;
		}

		String stripped = Text.removeTags(event.getMessage());

		if (MAIDEN_WAVE.matcher(stripped).find())
		{
			dataHandler.setShouldTrack(false);
			dataHandler.Find("Room").get().setValue(dataHandler.getTime());

			if (config.displayRoomTimes().isInfobox())
			{
				buildInfobox();
			}

			if (config.displayRoomTimes().isChat())
			{
				sendChatTimes();
			}
		}
	}

	private void buildInfobox()
	{
		if (!dataHandler.getData().isEmpty())
		{
			String tooltip;

			if (!dataHandler.Find("Starting Tick").get().isException())
			{
				tooltip = "70% - " + formatTime(dataHandler.FindValue("70s")) + "</br>" +
						"50% - " + formatTime(dataHandler.FindValue("50s")) + formatTime(dataHandler.FindValue("50s"), dataHandler.FindValue("70s")) + "</br>" +
						"30% - " + formatTime(dataHandler.FindValue("30s")) + formatTime(dataHandler.FindValue("30s"), dataHandler.FindValue("50s")) + "</br>" +
						"Complete - " + formatTime(dataHandler.FindValue("Room")) + formatTime(dataHandler.FindValue("Room"), dataHandler.FindValue("30s"));
			}
			else
			{
				tooltip = "Complete - " + formatTime(dataHandler.FindValue("Room")) + "*";
			}

			maidenInfoBox = createInfoBox(plugin, config, itemManager.getImage(BOSS_IMAGE), "Maiden", formatTime(dataHandler.FindValue("Room")), tooltip);
			infoBoxManager.addInfoBox(maidenInfoBox);
		}
	}

	private void sendChatTimes()
	{
		if (!dataHandler.getData().isEmpty())
		{
			if (!dataHandler.Find("Starting Tick").get().isException())
			{
				enqueueChatMessage(ChatMessageType.GAMEMESSAGE, b -> b
						.append(Color.RED, "70%")
						.append(ChatColorType.NORMAL)
						.append(" - " + formatTime(dataHandler.FindValue("70s")) + " - ")
						.append(Color.RED, "50%")
						.append(ChatColorType.NORMAL)
						.append(" - " + formatTime(dataHandler.FindValue("50s")) + formatTime(dataHandler.FindValue("50s"), dataHandler.FindValue("70s")) + " - ")
						.append(Color.RED, "30%")
						.append(ChatColorType.NORMAL)
						.append(" - " + formatTime(dataHandler.FindValue("30s")) + formatTime(dataHandler.FindValue("30s"), dataHandler.FindValue("50s"))));

				if (config.roomTimeValidation())
				{
					enqueueChatMessage(ChatMessageType.GAMEMESSAGE, b -> b
							.append(Color.RED, "Maiden - Room Complete")
							.append(ChatColorType.NORMAL)
							.append(" - " + formatTime(dataHandler.FindValue("Room")) + formatTime(dataHandler.FindValue("Room"), dataHandler.FindValue("30%"))));
				}
			}
			else
			{
				if (config.roomTimeValidation())
				{
					enqueueChatMessage(ChatMessageType.GAMEMESSAGE, b -> b
							.append(Color.RED, "Maiden - Room Complete")
							.append(ChatColorType.NORMAL)
							.append(" - " + formatTime(dataHandler.FindValue("Room")) + "*"));
				}
			}
		}
	}
}

/*
 * Copyright (c) 2022, Damen <gh: damencs>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:

 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.

 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.

 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.tobqol.rooms.maiden;

import com.google.common.collect.Multimap;
import com.google.common.collect.Multimaps;
import com.tobqol.TheatreQOLConfig;
import com.tobqol.TheatreQOLPlugin;
import com.tobqol.api.game.Health;
import com.tobqol.api.game.Instance;
import com.tobqol.config.HPDisplayTypes;
import com.tobqol.rooms.RoomSceneOverlay;
import com.tobqol.rooms.maiden.commons.MaidenPhase;
import com.tobqol.rooms.maiden.commons.MaidenRedCrab;
import joptsimple.internal.Strings;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.NPC;
import net.runelite.api.Point;
import net.runelite.api.coords.WorldPoint;
import net.runelite.client.ui.overlay.OverlayUtil;

import javax.inject.Inject;
import java.awt.*;
import java.util.ArrayList;
import java.util.List;
import java.util.Optional;

@Slf4j
public class MaidenSceneOverlay extends RoomSceneOverlay<MaidenHandler>
{
	@Inject
	protected MaidenSceneOverlay(
			Client client,
			Instance instance,
			MaidenHandler room,
			TheatreQOLPlugin plugin,
			TheatreQOLConfig config
	)
	{
		super(client, instance, room, plugin, config);
	}

	@Override
	public Dimension render(Graphics2D graphics)
	{
		if (!room.active())
		{
			return null;
		}

		graphics.setFont(plugin.getPluginFont());

		drawCrabOverlays(graphics);

		return null;
	}

	private void drawCrabOverlays(Graphics2D graphics)
	{
		HPDisplayTypes hpDisplayType = config.getMaidenCrabHPType();

		if (hpDisplayType.off())
		{
			return;
		}

		Multimap<WorldPoint, MaidenRedCrab> group = Multimaps.filterValues(
				Multimaps.index(room.getCrabsMap().values(), crab -> crab.npc().getWorldLocation()),
				crab -> !crab.health().zero()
		);

		traverseMultimap(graphics, group, null, (wp, crab, i) ->
		{
			drawCrabTextOverlays(graphics, crab, i);
		});
	}

	private void drawCrabTextOverlays(Graphics2D graphics, MaidenRedCrab crab, int offset)
	{
		HPDisplayTypes hpDisplayType = config.getMaidenCrabHPType();

		List<String> pieces = new ArrayList<>();
		NPC npc = crab.npc();

		if (!hpDisplayType.off())
		{
			Health health = crab.health();
			pieces.add(hpDisplayType.showAsPercent() ? Double.toString(health.truncatedPercent()) : Integer.toString(health.getCurrent()));
		}

		if (config.displayCrabProc())
		{
			pieces.add(crab.phaseKey());
		}

		if (pieces.isEmpty())
		{
			return;
		}

		String text = Strings.join(pieces, " | ");
		Point textLocation = npc.getCanvasTextLocation(graphics, text, 0);

		if (textLocation == null)
		{
			return;
		}
		Color color = getHpColorFromPhaseKey(crab.phaseKey());
		OverlayUtil.renderTextLocation(graphics, new Point(textLocation.getX(), textLocation.getY() - offset), text, color);
	}

	private Color getHpColorFromPhaseKey(String phaseKey)
	{
		if (phaseKey.equals(MaidenPhase.P1.key()))
		{
			return config.maiden70sColor();
		}
		else if (phaseKey.equals(MaidenPhase.P2.key()))
		{
			return config.maiden50sColor();
		}
		else if (phaseKey.equals(MaidenPhase.P3.key()))
		{
			return config.maiden30sColor();
		}
		return Color.WHITE;
	}
}

/*
 * Copyright (c) 2022, Damen <gh: damencs>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:

 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.

 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.

 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.tobqol.rooms.nylocas.commons;

import com.tobqol.TheatreQOLConfig;
import lombok.Getter;
import lombok.Setter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.client.ui.overlay.Overlay;

import java.awt.*;

@Slf4j
public class NyloSelectionManager extends Overlay
{
    @Getter
    private final NyloSelectionBox melee;

    @Getter
    private final NyloSelectionBox mage;

    @Getter
    private final NyloSelectionBox range;

    private final TheatreQOLConfig config;

    @Getter
    @Setter
    private boolean isHidden = true;

    @Getter
    private Rectangle meleeBounds = new Rectangle();

    @Getter
    private Rectangle rangeBounds = new Rectangle();

    @Getter
    private Rectangle mageBounds = new Rectangle();

    public NyloSelectionManager(TheatreQOLConfig config, NyloSelectionBox melee, NyloSelectionBox mage, NyloSelectionBox range)
    {
        this.config = config;
        this.mage = mage;
        this.melee = melee;
        this.range = range;
    }

    @Override
    public Dimension render(Graphics2D graphics)
    {
        if (isHidden)
        {
            return null;
        }

        Dimension meleeD = melee.render(graphics);
        graphics.translate(meleeD.width + 1, 0);

        Dimension rangeD = range.render(graphics);
        graphics.translate(rangeD.width + 1, 0);

        Dimension mageD = mage.render(graphics);
        graphics.translate(-meleeD.width - rangeD.width - 2, 0);

        meleeBounds = new Rectangle(getBounds().getLocation(), meleeD);
        rangeBounds = new Rectangle(new Point(getBounds().getLocation().x + meleeD.width + 1, getBounds().y), rangeD);
        mageBounds = new Rectangle(new Point(getBounds().getLocation().x + meleeD.width + 1 + rangeD.width + 1, getBounds().y), mageD);

        return new Dimension(meleeD.width + rangeD.width + mageD.width, Math.max(Math.max(meleeD.height, rangeD.height), mageD.height));
    }
}

/*
 * Copyright (c) 2022, Damen <gh: damencs>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:

 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.

 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.

 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.tobqol.rooms.nylocas.commons;

import com.tobqol.api.game.Instance;
import lombok.AccessLevel;
import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.experimental.Accessors;
import net.runelite.api.NPC;

import java.util.Optional;

@AllArgsConstructor(access = AccessLevel.PRIVATE)
@Getter
@Accessors(fluent = true)
public class NyloBoss
{
	private final NPC npc;
	private final Instance.Mode mode;

	private NylocasConstants definition;

	public static NyloBoss spawned(NPC npc, Instance.Mode mode)
	{
		return new NyloBoss(npc, mode, NylocasConstants.queryTable(mode, npc.getId()));
	}

	public void changed()
	{
		this.definition = NylocasConstants.queryTable(mode, npc.getId());
	}

	public boolean dead()
	{
		return this.npc.getHealthRatio() == 0;
	}

	public Optional<NylocasConstants> definition()
	{
		return this.definition == null ? Optional.empty() : Optional.of(this.definition);
	}
}

/*
 * Copyright (c) 2022, Damen <gh: damencs>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:

 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.

 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.

 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.tobqol.rooms.nylocas.commons;

import lombok.Getter;
import lombok.Setter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.client.ui.overlay.Overlay;
import net.runelite.client.ui.overlay.components.InfoBoxComponent;

import java.awt.*;

@Slf4j
public class NyloSelectionBox extends Overlay
{
    private final InfoBoxComponent component;

    @Getter
    @Setter
    private boolean isSelected = false;

    @Getter
    @Setter
    private boolean isHovered = false;

    public NyloSelectionBox(InfoBoxComponent component)
    {
        this.component = component;
    }

    @Override
    public Dimension render(Graphics2D graphics)
    {
        if (isSelected)
        {
            component.setColor(Color.GREEN);
            component.setText("On");
        }
        else
        {
            component.setColor(Color.RED);
            component.setText("Off");
        }

        Dimension result = component.render(graphics);

        if (isHovered)
        {
            Color color = graphics.getColor();
            graphics.setColor(new Color(200, 200, 200));
            graphics.drawRect(component.getBounds().x, component.getBounds().y, component.getBounds().width, component.getBounds().height);
            graphics.setColor(color);
        }

        return result;
    }
}
/*
 * Copyright (c) 2022, Damen <gh: damencs>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:

 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.

 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.

 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.tobqol.rooms.nylocas.commons;

import com.google.common.collect.*;
import com.tobqol.api.game.Instance;
import lombok.Getter;
import lombok.RequiredArgsConstructor;
import lombok.experimental.Accessors;
import net.runelite.api.NpcID;
import net.runelite.api.NullNpcID;
import net.runelite.api.Point;

import javax.annotation.Nullable;
import java.awt.*;
import java.util.List;
import java.util.Set;
import java.util.regex.Pattern;

import static com.google.common.collect.Tables.immutableCell;

@RequiredArgsConstructor
@Getter
@Accessors(fluent = true)
public enum NylocasConstants
{
	BOSS_DROPPING_MELEE(NpcID.NYLOCAS_VASILIAS_10786, NpcID.NYLOCAS_VASILIAS, NpcID.NYLOCAS_VASILIAS_10807),
	BOSS_MELEE(NpcID.NYLOCAS_VASILIAS_10787, NpcID.NYLOCAS_VASILIAS_8355, NpcID.NYLOCAS_VASILIAS_10808),
	BOSS_MAGIC(NpcID.NYLOCAS_VASILIAS_10788, NpcID.NYLOCAS_VASILIAS_8356, NpcID.NYLOCAS_VASILIAS_10809),
	BOSS_RANGE(NpcID.NYLOCAS_VASILIAS_10789, NpcID.NYLOCAS_VASILIAS_8357, NpcID.NYLOCAS_VASILIAS_10810),
	DEMI_BOSS_DROPPING_MELEE(NpcID.NYLOCAS_PRINKIPAS),
	DEMI_BOSS_MELEE(NpcID.NYLOCAS_PRINKIPAS_10804),
	DEMI_BOSS_MAGIC(NpcID.NYLOCAS_PRINKIPAS_10805),
	DEMI_BOSS_RANGE(NpcID.NYLOCAS_PRINKIPAS_10806),
	MELEE_SMALL(
			NpcID.NYLOCAS_ISCHYROS_10791,
			NpcID.NYLOCAS_ISCHYROS_8342,
			NpcID.NYLOCAS_ISCHYROS_10791,
			NpcID.NYLOCAS_ISCHYROS_10780,
			NpcID.NYLOCAS_ISCHYROS_8348,
			NpcID.NYLOCAS_ISCHYROS_10797
	),
	RANGE_SMALL(
			NpcID.NYLOCAS_TOXOBOLOS_10775,
			NpcID.NYLOCAS_TOXOBOLOS_8343,
			NpcID.NYLOCAS_TOXOBOLOS_10792,
			NpcID.NYLOCAS_TOXOBOLOS_10781,
			NpcID.NYLOCAS_TOXOBOLOS_8349,
			NpcID.NYLOCAS_TOXOBOLOS_10798
	),
	MAGIC_SMALL(
			NpcID.NYLOCAS_HAGIOS_10776,
			NpcID.NYLOCAS_HAGIOS,
			NpcID.NYLOCAS_HAGIOS_10793,
			NpcID.NYLOCAS_HAGIOS_10782,
			NpcID.NYLOCAS_HAGIOS_8350,
			NpcID.NYLOCAS_HAGIOS_10799
	),
	MELEE_BIG(
			NpcID.NYLOCAS_ISCHYROS_10777,
			NpcID.NYLOCAS_ISCHYROS_8345,
			NpcID.NYLOCAS_ISCHYROS_10794,
			NpcID.NYLOCAS_ISCHYROS_10783,
			NpcID.NYLOCAS_ISCHYROS_8351,
			NpcID.NYLOCAS_ISCHYROS_10800
	),
	RANGE_BIG(
			NpcID.NYLOCAS_TOXOBOLOS_10778,
			NpcID.NYLOCAS_TOXOBOLOS_8346,
			NpcID.NYLOCAS_TOXOBOLOS_10795,
			NpcID.NYLOCAS_TOXOBOLOS_10784,
			NpcID.NYLOCAS_TOXOBOLOS_8352,
			NpcID.NYLOCAS_TOXOBOLOS_10801
	),
	MAGIC_BIG(
			NpcID.NYLOCAS_HAGIOS_10779,
			NpcID.NYLOCAS_HAGIOS_8347,
			NpcID.NYLOCAS_HAGIOS_10796,
			NpcID.NYLOCAS_HAGIOS_10785,
			NpcID.NYLOCAS_HAGIOS_8353,
			NpcID.NYLOCAS_HAGIOS_10802
	),
	PILLAR(NullNpcID.NULL_10790, NullNpcID.NULL_8358, NullNpcID.NULL_10811);

	private final int sm, rg, hm, aggro_sm, aggro_rg, aggro_hm;

	public static int BOSS_IMAGE = 25750;
	public static int NYLOCAS_WAVES_TOTAL = 31;

	public static Pattern NYLOCAS_WAVE = Pattern.compile("Wave 'The Nylocas' \\(.*\\) complete!");

	public static final String BOSS_NAME = "Nylocas Vasilias";
	public static final String DEMI_BOSS_NAME = "Nylocas Prinkipas";
	public static final String MELEE_NAME = "Nylocas Ischyros";
	public static final String RANGE_NAME = "Nylocas Toxobolos";
	public static final String MAGIC_NAME = "Nylocas Hagios";

	public static final int BOSS_MAGIC_ANIM = 7989;
	public static final int BOSS_RANGE_ANIM = 7999;
	public static final int BOSS_MELEE_ANIM = 8004;

	public static final int PILLAR_GO_ID = 32862;
	public static final int PILLAR_COLLAPSED_GO_ID = 32864;
	public static final int SPECTATOR_WEB_1 = 32939;
	public static final int SPECTATOR_WEB_2 = 32865;
	public static final int SPECTATOR_WEB_3 = 32937;
	public static final int WALL_1 = 32876;
	public static final int WALL_2 = 32899;

	public static final int IMMUNE_GRAPHIC = 1558; // Spawns on the SW tile of the nylo
	public static final int MELEE_SMALL_DESPAWN_GRAPHIC = 1562;
	public static final int RANGE_SMALL_DESPAWN_GRAPHIC = 1563;
	public static final int MAGIC_SMALL_DESPAWN_GRAPHIC = 1564;
	public static final int UNK_DESPAWN_GRAPHIC_1 = 1561;
	public static final int UNK_DESPAWN_GRAPHIC_2 = 1891;
	public static final int UNK_DESPAWN_GRAPHIC_3 = 1892;
	public static final int UNK_DESPAWN_GRAPHIC_4 = 1893;
	public static final int UNK_DESPAWN_GRAPHIC_5 = 1894;

	private static final ImmutableMultimap<NylocasConstants, Integer> ENUM_MULTIMAP;
	private static final Table<Instance.Mode, Integer, NylocasConstants> LOOKUP_TABLE;
	private static final ImmutableMultimap<NylocasType, Integer> TYPE_IDS;

	public static final Color MAGIC_COLOR = Color.CYAN;
	public static final Color MELEE_COLOR = new Color(255, 188, 188);
	public static final Color RANGE_COLOR = Color.GREEN;

	public static final Set<Point> NYLOCAS_VALID_SPAWNS = ImmutableSet.of(
			new Point(17, 24), new Point(17, 25), new Point(18, 24), new Point(18, 25),
			new Point(31, 9), new Point(31, 10), new Point(32, 9), new Point(32, 10),
			new Point(46, 24), new Point(46, 25), new Point(47, 24), new Point(47, 25)
	);

	static
	{
		ImmutableMultimap.Builder<NylocasConstants, Integer> enum_builder = ImmutableListMultimap.builder();
		ImmutableTable.Builder<Instance.Mode, Integer, NylocasConstants> t_builder = ImmutableTable.builder();

		for (NylocasConstants def : values())
		{
			if (def.sm == -1 && def.rg == -1)
			{
				enum_builder.put(def, def.hm);
				t_builder.put(immutableCell(Instance.Mode.HARD, def.hm, def));
				continue;
			}

			enum_builder.putAll(def, def.sm, def.rg, def.hm);
			t_builder.put(immutableCell(Instance.Mode.STORY, def.sm, def));
			t_builder.put(immutableCell(Instance.Mode.REGULAR, def.rg, def));
			t_builder.put(immutableCell(Instance.Mode.HARD, def.hm, def));

			if (def.aggro_sm == -1 && def.aggro_rg == -1 && def.aggro_hm == -1)
			{
				continue;
			}

			enum_builder.putAll(def, def.aggro_sm, def.aggro_rg, def.aggro_hm);
			t_builder.put(immutableCell(Instance.Mode.STORY, def.aggro_sm, def));
			t_builder.put(immutableCell(Instance.Mode.REGULAR, def.aggro_rg, def));
			t_builder.put(immutableCell(Instance.Mode.HARD, def.aggro_hm, def));
		}

		ENUM_MULTIMAP = enum_builder.build();
		LOOKUP_TABLE = t_builder.build();

		ImmutableMultimap.Builder<NylocasType, Integer> type_ids = ImmutableListMultimap.builder();

		List<NylocasConstants> melees = ImmutableList.of(
				BOSS_DROPPING_MELEE,
				BOSS_MELEE,
				BOSS_MAGIC,
				BOSS_RANGE
		);

		melees.forEach(def -> type_ids.putAll(NylocasType.BOSS, def.sm, def.rg, def.hm));

		List<NylocasConstants> demis = ImmutableList.of(
				DEMI_BOSS_DROPPING_MELEE,
				DEMI_BOSS_MELEE,
				DEMI_BOSS_MAGIC,
				DEMI_BOSS_RANGE
		);

		demis.forEach(def -> type_ids.putAll(NylocasType.DEMI, def.hm));

		List<NylocasConstants> bigs = ImmutableList.of(
				MELEE_BIG,
				RANGE_BIG,
				MAGIC_BIG
		);

		bigs.forEach(def -> type_ids.putAll(NylocasType.BIG, def.sm, def.rg, def.hm, def.aggro_sm, def.aggro_rg, def.aggro_hm));

		List<NylocasConstants> smalls = ImmutableList.of(
				MELEE_SMALL,
				RANGE_SMALL,
				MAGIC_SMALL
		);

		smalls.forEach(def -> type_ids.putAll(NylocasType.SMALL, def.sm, def.rg, def.hm, def.aggro_sm, def.aggro_rg, def.aggro_hm));

		TYPE_IDS = type_ids.build();
	}

	public static boolean matchesAnyMode(NylocasConstants def, int npcId)
	{
		if (def == null)
		{
			return false;
		}

		return ENUM_MULTIMAP.get(def).contains(npcId);
	}

	@Nullable
	public static NylocasConstants queryTable(Instance.Mode mode, int npcId)
	{
		if (mode == null)
		{
			return null;
		}

		return LOOKUP_TABLE.get(mode, npcId);
	}

	@Nullable
	public static Instance.Mode findMode(int npcId)
	{
		return Instance.findFirstMode(mode -> queryTable(mode, npcId) != null);
	}

	public static boolean isBoss(int npcId)
	{
		return TYPE_IDS.get(NylocasType.BOSS).contains(npcId);
	}

	public static boolean isDemiBoss(int npcId)
	{
		return TYPE_IDS.get(NylocasType.DEMI).contains(npcId);
	}

	public static boolean isBigNylo(int npcId)
	{
		return TYPE_IDS.get(NylocasType.BIG).contains(npcId);
	}

	public static boolean isSmallNylo(int npcId)
	{
		return TYPE_IDS.get(NylocasType.SMALL).contains(npcId);
	}

	public static boolean isWavesNylo(int npcId)
	{
		return isBigNylo(npcId) || isSmallNylo(npcId);
	}

	NylocasConstants(int sm, int rg, int hm)
	{
		this(sm, rg, hm, -1, -1, -1);
	}

	NylocasConstants(int hm)
	{
		this(-1, -1, hm);
	}
}

/*
 * Copyright (c) 2022, Damen <gh: damencs>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:

 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.

 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.

 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.tobqol.rooms.nylocas.commons;

public enum NylocasType
{
	BOSS,
	DEMI,
	SMALL,
	BIG
}

/*
 * Copyright (c) 2022, Damen <gh: damencs>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:

 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.

 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.

 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.tobqol.rooms.nylocas.config;

import lombok.Getter;
import lombok.RequiredArgsConstructor;

@RequiredArgsConstructor
@Getter
public enum NylocasObjects
{
    OFF("Off"),
    PILLARS("Pillars"),
    SPECTATOR_WEBS("Spectator Webs"),
    WALLS("Walls"),
    PILLARS_AND_WEBS("Pillars and Webs"),
    ALL("All");

    private final String option;

    public final boolean isOff()
    {
        return this == OFF;
    }

    public final boolean isPillars()
    {
        return this == PILLARS;
    }

    public final boolean isSpectatorWebs()
    {
        return this == SPECTATOR_WEBS;
    }

    public final boolean isWalls()
    {
        return this == WALLS;
    }

    public final boolean isPillarsAndWebs()
    {
        return this == PILLARS_AND_WEBS;
    }

    public final boolean isAll()
    {
        return this == ALL;
    }

    public final boolean isAnyOrAll()
    {
        return this == PILLARS || this == SPECTATOR_WEBS || this == WALLS || this == PILLARS_AND_WEBS || this == ALL;
    }

    @Override
    public String toString()
    {
        return option;
    }
}

/*
 * Copyright (c) 2022, Damen <gh: damencs>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:

 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.

 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.

 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.tobqol.rooms.nylocas;

import com.google.common.collect.ImmutableList;
import com.tobqol.TheatreQOLConfig;
import com.tobqol.TheatreQOLPlugin;
import com.tobqol.api.game.Region;
import com.tobqol.api.util.TheatreInputListener;
import com.tobqol.rooms.RoomHandler;
import com.tobqol.rooms.nylocas.commons.NyloBoss;
import com.tobqol.rooms.nylocas.commons.NyloSelectionBox;
import com.tobqol.rooms.nylocas.commons.NyloSelectionManager;
import com.tobqol.rooms.nylocas.commons.NylocasConstants;
import com.tobqol.tracking.RoomDataHandler;
import com.tobqol.tracking.RoomDataItem;
import com.tobqol.tracking.RoomInfoBox;
import lombok.Getter;
import lombok.Setter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Point;
import net.runelite.api.*;
import net.runelite.api.coords.WorldPoint;
import net.runelite.api.events.*;
import net.runelite.client.chat.ChatColorType;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.events.ConfigChanged;
import net.runelite.client.game.SkillIconManager;
import net.runelite.client.input.MouseManager;
import net.runelite.client.ui.overlay.components.InfoBoxComponent;
import net.runelite.client.util.ColorUtil;
import net.runelite.client.util.Text;

import javax.inject.Inject;
import java.awt.*;
import java.util.HashMap;
import java.util.Map;

import static com.tobqol.api.game.Region.NYLOCAS;
import static com.tobqol.api.game.Region.inRegion;
import static com.tobqol.rooms.nylocas.commons.NylocasConstants.*;
import static com.tobqol.tracking.RoomInfoUtil.createInfoBox;
import static com.tobqol.tracking.RoomInfoUtil.formatTime;

@Slf4j
public class NylocasHandler extends RoomHandler
{
	@Inject
	private NylocasSceneOverlay sceneOverlay;

	private RoomDataHandler dataHandler;

	@Inject
	private SkillIconManager skillIconManager;

	@Getter
	private NyloSelectionManager nyloSelectionManager;

	@Inject
	private MouseManager mouseManager;

	@Inject
	private TheatreInputListener theatreInputListener;

	@Getter
	private boolean displayRoleSelector;

	@Getter
	@Setter
	private boolean displayRoleMage;

	@Getter
	@Setter
	private boolean displayRoleMelee;

	@Getter
	@Setter
	private boolean displayRoleRange;

	@Getter
	private boolean displayInstanceTimer;

	private RoomInfoBox nylocasInfoBox;

	private int wave = 0;
	private boolean waveSpawned = false;

	@Getter
	private NyloBoss boss = null;

	@Getter
	private NyloBoss demiBoss = null;
	private int demiCount = 0;

	@Getter
	private final Map<NPC, Integer> pillars = new HashMap<>();

	@Getter
	private final Map<NPC, Integer> wavesMap = new HashMap<>();

	@Getter
	private final Map<NPC, Integer> bigsMap = new HashMap<>();

	@Getter
	private final Map<NPC, Integer> splitsMap = new HashMap<>();

	@Inject
	protected NylocasHandler(TheatreQOLPlugin plugin, TheatreQOLConfig config)
	{
		super(plugin, config);
		setRoomRegion(NYLOCAS);

		dataHandler = plugin.getDataHandler();
	}

	@Override
	public void init()
	{
		displayRoleSelector = config.displayNyloRoleSelector();
		displayRoleMage = config.nyloRoleSelectedMage();
		displayRoleMelee = config.nyloRoleSelectedMelee();
		displayRoleRange = config.nyloRoleSelectedRange();

		InfoBoxComponent box = new InfoBoxComponent();
		box.setImage(skillIconManager.getSkillImage(Skill.ATTACK));
		NyloSelectionBox nyloMeleeOverlay = new NyloSelectionBox(box);
		nyloMeleeOverlay.setSelected(displayRoleMelee);

		box = new InfoBoxComponent();
		box.setImage(skillIconManager.getSkillImage(Skill.MAGIC));
		NyloSelectionBox nyloMageOverlay = new NyloSelectionBox(box);
		nyloMageOverlay.setSelected(displayRoleMage);

		box = new InfoBoxComponent();
		box.setImage(skillIconManager.getSkillImage(Skill.RANGED));
		NyloSelectionBox nyloRangeOverlay = new NyloSelectionBox(box);
		nyloRangeOverlay.setSelected(displayRoleRange);

		nyloSelectionManager = new NyloSelectionManager(config, nyloMeleeOverlay, nyloMageOverlay, nyloRangeOverlay);
		nyloSelectionManager.setHidden(!displayRoleSelector);
	}

	@Override
	public void load()
	{
		overlayManager.add(sceneOverlay);
		startupNyloOverlay();
	}

	@Override
	public void unload()
	{
		overlayManager.remove(sceneOverlay);
		shutdownNyloOverlay();
		reset();
	}

	@Override
	public void reset()
	{
		boss = null;
		demiBoss = null;
		softReset();
		displayInstanceTimer = config.nyloInstanceTimer();

		if (instance.getRaidStatus() <= 1)
		{
			wave = 0;
			waveSpawned = false;
			demiCount = 0;
			infoBoxManager.removeInfoBox(nylocasInfoBox);
		}
	}

	private void softReset()
	{
		pillars.clear();
		wavesMap.clear();
		bigsMap.clear();
		splitsMap.clear();
	}

	@Override
	public boolean active()
	{
		return instance.getCurrentRegion().isNylocas();
	}

	private void startupNyloOverlay()
	{
		mouseManager.registerMouseListener(theatreInputListener);

		if (nyloSelectionManager != null)
		{
			overlayManager.add(nyloSelectionManager);
			nyloSelectionManager.setHidden(true);
		}
	}

	private void shutdownNyloOverlay() {
		mouseManager.unregisterMouseListener(theatreInputListener);

		if (nyloSelectionManager != null)
		{
			overlayManager.remove(nyloSelectionManager);
			nyloSelectionManager.setHidden(true);
		}
	}

	@Subscribe
	private void onConfigChanged(ConfigChanged e)
	{
		if (!e.getGroup().equalsIgnoreCase(TheatreQOLConfig.GROUP_NAME))
		{
			return;
		}

		switch (e.getKey())
		{
			case "nyloHideObjects":
				clientThread.invokeLater(() ->
				{
					if (inRegion(client, Region.NYLOCAS) && client.getGameState() == GameState.LOGGED_IN)
					{
						sceneManager.refreshScene();

						if (config.nyloHideObjects().isAnyOrAll())
						{
							hideRoomObjects(config.nyloHideObjects().toString());
						}
						else
						{
							client.setGameState(GameState.LOADING);
						}
					}
				});
				break;
			case "displayNyloRoleSelector":
			{
				displayRoleSelector = Boolean.valueOf(e.getNewValue());
				nyloSelectionManager.setHidden(!displayRoleSelector);
				break;
			}
			case "nyloInstanceTimer":
			{
				displayInstanceTimer = Boolean.valueOf(e.getNewValue());
				break;
			}
		}
	}

	@Subscribe
	private void onGameStateChanged(GameStateChanged e)
	{
		if (e.getGameState() == GameState.LOGGED_IN && active())
		{
			hideRoomObjects(config.nyloHideObjects().toString());

			nyloSelectionManager.setHidden(!displayRoleSelector);
			displayInstanceTimer = config.nyloInstanceTimer();
		}
	}

	@Subscribe
	private void onNpcSpawned(NpcSpawned e)
	{
		if (!active())
		{
			return;
		}

		NPC npc = e.getNpc();
		int id = npc.getId();

		if (NylocasConstants.matchesAnyMode(BOSS_DROPPING_MELEE, id))
		{
			dataHandler.getData().add(new RoomDataItem("Boss", dataHandler.getTime(), 6, !config.displayTimeSplits(), "Cleanup"));
			return;
		}

		if (isNpcFromName(npc, BOSS_NAME) && NylocasConstants.matchesAnyMode(NylocasConstants.BOSS_MELEE, id))
		{
			instance.lazySetMode(() -> NylocasConstants.findMode(id));
			boss = NyloBoss.spawned(npc, instance.mode());
			softReset();
			return;
		}

		if (isNpcFromName(npc, DEMI_BOSS_NAME) && NylocasConstants.matchesAnyMode(NylocasConstants.DEMI_BOSS_MELEE, id))
		{
			instance.lazySetMode(() -> NylocasConstants.findMode(id));
			demiBoss = NyloBoss.spawned(npc, instance.mode());

			demiCount++;
			dataHandler.getData().add(new RoomDataItem("Demi " + demiCount, dataHandler.getTime(), demiCount, true, demiCount > 1 ? "Demi " + (demiCount - 1) : ""));
			return;
		}

		if (NylocasConstants.matchesAnyMode(NylocasConstants.PILLAR, id))
		{
			if (pillars.size() > 3)
			{
				pillars.clear();
			}

			pillars.putIfAbsent(npc, 100);

			if (!dataHandler.Find("Starting Tick").isPresent())
			{
				dataHandler.getData().add(new RoomDataItem("Starting Tick", client.getTickCount(), true));
				dataHandler.setShouldTrack(true);
			}
			return;
		}

		if (isNpcFromName(npc, MELEE_NAME) || isNpcFromName(npc, RANGE_NAME) || isNpcFromName(npc, MAGIC_NAME))
		{
			instance.lazySetMode(() -> NylocasConstants.findMode(id));
			wavesMap.put(npc, 52);

			NPCComposition comp = npc.getTransformedComposition();
			if ((comp == null ? 1 : comp.getSize()) > 1)
			{
				bigsMap.put(npc, 1);
			}

			if (displayInstanceTimer)
			{
				displayInstanceTimer = false;
			}

			// TODO -> Eventually convert this to track split data for nylocas spawns for post-room splits
			if (!waveSpawned)
			{
				WorldPoint worldPoint = WorldPoint.fromLocalInstance(client, npc.getLocalLocation());
				Point spawnPoint = new Point(worldPoint.getRegionX(), worldPoint.getRegionY());

				if (NYLOCAS_VALID_SPAWNS.contains(spawnPoint))
				{
					wave++;
					waveSpawned = true;

					if (wave == NYLOCAS_WAVES_TOTAL)
					{
						dataHandler.getData().add(new RoomDataItem("Waves", dataHandler.getTime(), 4, !config.displayTimeSplits(), dataHandler.Find("Demi 3").isPresent() ? "Demi 3" : ""));
					}
				}
			}
		}
	}

	@Subscribe
	private void onNpcChanged(NpcChanged e)
	{
		if (!active() && boss == null && demiBoss == null)
		{
			return;
		}

		NPC npc = e.getNpc();

		if (npc != null)
		{
			if (boss != null)
			{
				isNpcFromName(npc, BOSS_NAME, n -> boss.changed());
			}
			if (demiBoss != null)
			{
				isNpcFromName(npc, DEMI_BOSS_NAME, n -> demiBoss.changed());
			}
		}
	}

	@Subscribe
	private void onNpcDespawned(NpcDespawned e)
	{
		if (!active())
		{
			return;
		}

		NPC npc = e.getNpc();
		int id = npc.getId();

		if (isNpcFromName(npc, BOSS_NAME) && !NylocasConstants.matchesAnyMode(NylocasConstants.BOSS_DROPPING_MELEE, id))
		{
			reset();
			return;
		}

		if (isNpcFromName(npc, DEMI_BOSS_NAME) && !NylocasConstants.matchesAnyMode(NylocasConstants.DEMI_BOSS_DROPPING_MELEE, id))
		{
			demiBoss = null;
			return;
		}

		pillars.remove(npc);
		wavesMap.remove(npc);

		if (wavesMap.isEmpty() && wave == NYLOCAS_WAVES_TOTAL && !dataHandler.Find("Cleanup").isPresent())
		{
			dataHandler.getData().add(new RoomDataItem("Cleanup", dataHandler.getTime(), 5, false, "Waves"));
		}
	}

	@Subscribe
	private void onMenuEntryAdded(MenuEntryAdded e)
	{
		if (!active() || !config.nyloWavesRecolorMenu() || wavesMap.isEmpty())
		{
			return;
		}

		if (e.getOption().equals("Attack") || e.getType() == MenuAction.WIDGET_TARGET_ON_NPC.getId())
		{
			NPC npc = client.getTopLevelWorldView().npcs().byIndex(e.getIdentifier());

			if (npc == null)
			{
				return;
			}

			String target = e.getTarget();
			MenuEntry[] entries = client.getMenuEntries();
			MenuEntry head = entries[entries.length - 1];

			boolean darker = config.nyloWavesRecolorBigsMenuDarker() && npc.getTransformedComposition() != null && npc.getTransformedComposition().getSize() > 1;
			int id = npc.getId();
			target = Text.removeTags(target);
			Color color = null;

			if (target.contains(MELEE_NAME) || id == NylocasConstants.DEMI_BOSS_MELEE.hm())
			{
				color = darker ? MELEE_COLOR.darker() : MELEE_COLOR;
			}
			else if (target.contains(RANGE_NAME) || id == NylocasConstants.DEMI_BOSS_RANGE.hm())
			{
				color = darker ? RANGE_COLOR.darker() : RANGE_COLOR;
			}
			else if (target.contains(MAGIC_NAME) || id == NylocasConstants.DEMI_BOSS_MAGIC.hm())
			{
				color = darker ? MAGIC_COLOR.darker() : MAGIC_COLOR;
			}

			if (color != null)
			{
				target = ColorUtil.prependColorTag(target, color);
			}

			head.setTarget(target);
			client.setMenuEntries(entries);
		}
	}

	@Subscribe
	private void onGameTick(GameTick e)
	{
		if (instance.isInRaid() && instance.getCurrentRegion().isNylocas())
		{
			if (instance.getRoomStatus() == 1 && !dataHandler.Find("Starting Tick").isPresent())
			{
				dataHandler.getData().add(new RoomDataItem("Starting Tick", client.getTickCount(), true, true));
				dataHandler.setShouldTrack(true);

				dataHandler.getData().add(new RoomDataItem("Room", dataHandler.getTime(), 99, false, "Boss"));
			}

			if (dataHandler.isShouldTrack() && !dataHandler.getData().isEmpty())
			{
				dataHandler.updateTotalTime();
			}
		}

		if (!active())
		{
			if (!nyloSelectionManager.isHidden())
			{
				nyloSelectionManager.setHidden(true);
			}
			return;
		}

		if (!pillars.isEmpty())
		{
			for (NPC pillar : pillars.keySet())
			{
				int ratio = pillar.getHealthRatio();

				if (ratio > -1)
				{
					pillars.replace(pillar, ratio);
				}
			}
		}

		if (!wavesMap.isEmpty())
		{
			wavesMap.values().removeIf(VALUE_IS_ZERO);
			wavesMap.replaceAll(DECREMENT_VALUE);
			waveSpawned = false;
		}

		if (!bigsMap.isEmpty())
		{
			bigsMap.entrySet().removeIf(entry ->
			{
				NPC big = entry.getKey();
				if (big.getHealthRatio() == 0 || entry.getValue() >= 52)
				{
					splitsMap.putIfAbsent(big, 0xFF);
					return true;
				}

				return false;
			});
		}

		if (!splitsMap.isEmpty())
		{
			splitsMap.values().removeIf(VALUE_IS_ZERO);
			splitsMap.replaceAll(DECREMENT_VALUE);
		}
	}

	@Subscribe
	private void onAnimationChanged(AnimationChanged e)
	{
		if (!active() || !(e.getActor() instanceof NPC))
		{
			return;
		}

		NPC npc = (NPC) e.getActor();

		if (NylocasConstants.isBigNylo(npc.getId()))
		{
			switch (npc.getAnimation())
			{
				case 7991:
				case 7998:
				case 8005:
					splitsMap.merge(npc, 5, (o, n) -> n);
					break;
				case 7992:
				case 8000:
				case 8006:
					splitsMap.merge(npc, 3, (o, n) -> n);
					break;
			}
		}
	}

	@Subscribe
	private void onGraphicsObjectCreated(GraphicsObjectCreated e)
	{
		if (!active() || !config.nyloLowDetail())
		{
			return;
		}

		GraphicsObject graphic = e.getGraphicsObject();
		int id = e.getGraphicsObject().getId();

		if ((id >= UNK_DESPAWN_GRAPHIC_1 && id <= MAGIC_SMALL_DESPAWN_GRAPHIC) || (id >= UNK_DESPAWN_GRAPHIC_2 && id <= UNK_DESPAWN_GRAPHIC_5))
		{
			graphic.setFinished(true);
		}
	}

	@Subscribe
	public void onChatMessage(ChatMessage event)
	{
		if (instance.getCurrentRegion() != NYLOCAS && event.getType() != ChatMessageType.GAMEMESSAGE)
		{
			return;
		}

		String stripped = Text.removeTags(event.getMessage());

		if (NYLOCAS_WAVE.matcher(stripped).find())
		{
			dataHandler.setShouldTrack(false);
			dataHandler.Find("Room").get().setValue(dataHandler.getTime());

			if (config.displayRoomTimes().isInfobox())
			{
				buildInfobox();
			}

			if (config.displayRoomTimes().isChat())
			{
				sendChatTimes();
			}
		}
	}

	private void buildInfobox()
	{
		if (!dataHandler.getData().isEmpty())
		{
			String tooltip;

			if (!dataHandler.Find("Starting Tick").get().isException())
			{
				tooltip = "Waves - " + formatTime(dataHandler.FindValue("Waves")) + "</br>" +
						"Cleanup - " + formatTime(dataHandler.FindValue("Cleanup")) + formatTime(dataHandler.FindValue("Cleanup"), dataHandler.FindValue("Waves")) + "</br>" +
						"Boss - " + formatTime(dataHandler.FindValue("Boss")) + formatTime(dataHandler.FindValue("Boss"), dataHandler.FindValue("Cleanup")) + "</br>" +
						"Complete - " + formatTime(dataHandler.FindValue("Room")) + formatTime(dataHandler.FindValue("Room"), dataHandler.FindValue("Boss"));
			}
			else
			{
				tooltip = "Complete - " + formatTime(dataHandler.FindValue("Room")) + "*";
			}

			nylocasInfoBox = createInfoBox(plugin, config, itemManager.getImage(BOSS_IMAGE), "Nylocas", formatTime(dataHandler.FindValue("Room")), tooltip);
			infoBoxManager.addInfoBox(nylocasInfoBox);
		}
	}

	private void sendChatTimes()
	{
		if (!dataHandler.getData().isEmpty())
		{
			if (!dataHandler.Find("Starting Tick").get().isException())
			{
				enqueueChatMessage(ChatMessageType.GAMEMESSAGE, b -> b
						.append(Color.RED, "Waves")
						.append(ChatColorType.NORMAL)
						.append(" - " + formatTime(dataHandler.FindValue("Waves")) + " - ")
						.append(Color.RED, "Cleanup")
						.append(ChatColorType.NORMAL)
						.append(" - " + formatTime(dataHandler.FindValue("Cleanup")) + formatTime(dataHandler.FindValue("Cleanup"), dataHandler.FindValue("Waves")) + " - ")
						.append(Color.RED, "Boss")
						.append(ChatColorType.NORMAL)
						.append(" - " + formatTime(dataHandler.FindValue("Boss")) + formatTime(dataHandler.FindValue("Boss"), dataHandler.FindValue("Cleanup"))));

				if (config.roomTimeValidation())
				{
					enqueueChatMessage(ChatMessageType.GAMEMESSAGE, b -> b
							.append(Color.RED, "Nylocas - Room Complete")
							.append(ChatColorType.NORMAL)
							.append(" - " + formatTime(dataHandler.FindValue("Room")) + formatTime(dataHandler.FindValue("Room"), dataHandler.FindValue("Boss"))));
				}
			}
			else
			{
				if (config.roomTimeValidation())
				{
					enqueueChatMessage(ChatMessageType.GAMEMESSAGE, b -> b
							.append(Color.RED, "Nylocas - Room Complete")
							.append(ChatColorType.NORMAL)
							.append(" - " + formatTime(dataHandler.FindValue("Room")) + "*"));
				}
			}
		}
	}

	private void hideRoomObjects(String option)
	{
		switch (option)
		{
			case "Pillars":
				sceneManager.removeTheseGameObjects(client.getPlane(), ImmutableList.of(PILLAR_GO_ID));
				break;
			case "Spectator Webs":
				sceneManager.removeTheseGameObjects(client.getPlane(), ImmutableList.of(SPECTATOR_WEB_1, SPECTATOR_WEB_2, SPECTATOR_WEB_3));
				break;
			case "Walls":
				sceneManager.removeTheseGameObjects(client.getPlane(), ImmutableList.of(WALL_1, WALL_2));
				break;
			case "Pillars and Webs":
				sceneManager.removeTheseGameObjects(client.getPlane(), ImmutableList.of(PILLAR_GO_ID, SPECTATOR_WEB_1, SPECTATOR_WEB_2, SPECTATOR_WEB_3));
				break;
			case "All":
				sceneManager.removeTheseGameObjects(client.getPlane(), ImmutableList.of(PILLAR_GO_ID, SPECTATOR_WEB_1, SPECTATOR_WEB_2, SPECTATOR_WEB_3, WALL_1, WALL_2));
				break;
		}
	}

	public boolean isAnyRole()
	{
		return displayRoleMage || displayRoleMelee || displayRoleRange;
	}
}

/*
 * Copyright (c) 2022, Damen <gh: damencs>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:

 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.

 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.

 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.tobqol.rooms.nylocas;

import com.tobqol.TheatreQOLConfig;
import com.tobqol.TheatreQOLPlugin;
import com.tobqol.api.game.Instance;
import com.tobqol.rooms.RoomSceneOverlay;
import com.tobqol.rooms.nylocas.commons.NylocasConstants;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.NPC;
import net.runelite.api.Perspective;
import net.runelite.api.Point;
import net.runelite.api.coords.LocalPoint;
import net.runelite.client.ui.overlay.OverlayLayer;
import net.runelite.client.ui.overlay.OverlayUtil;

import javax.inject.Inject;
import java.awt.*;
import java.util.Map;

@Slf4j
public class NylocasSceneOverlay extends RoomSceneOverlay<NylocasHandler>
{
	@Inject
	protected NylocasSceneOverlay(
			Client client,
			Instance instance,
			NylocasHandler room,
			TheatreQOLPlugin plugin,
			TheatreQOLConfig config
	)
	{
		super(client, instance, room, plugin, config);
	}

	@Override
	public Dimension render(Graphics2D graphics)
	{
		if (!room.active())
		{
			return null;
		}

		setLayer(OverlayLayer.ABOVE_SCENE);
		graphics.setFont(plugin.getPluginFont());

		drawPillarsHP(graphics);
		renderRoleOverlays(graphics);

		if (room.isDisplayInstanceTimer())
		{
			graphics.setFont(plugin.getInstanceTimerFont());
			drawInstanceTimer(graphics, null, null);
		}

		return null;
	}

	private void drawPillarsHP(Graphics2D graphics)
	{
		if (!config.showNylocasPillarHP())
		{
			return;
		}

		Map<NPC, Integer> pillars = room.getPillars();

		if (pillars.isEmpty())
		{
			return;
		}

		pillars.forEach((pillar, hp) ->
		{
			String str = hp + "%";
			double rMod = 130.0 * hp / 100.0, gMod = 255.0 * hp / 100.0, bMod = 125.0 * hp / 100.0;
			Point textLocation = Perspective.getCanvasTextLocation(client, graphics, pillar.getLocalLocation(), str, 65);
			OverlayUtil.renderTextLocation(graphics, textLocation, str, new Color((int) (255 - rMod), (int) (0 + gMod), (int) (0 + bMod)));
		});
	}

	private void renderRoleOverlays(Graphics2D graphics)
	{
		// Determine config options rather than consistently drawing data on each render as it can be used multiple times within method
		boolean displaySWTile = config.nyloWavesBigsSWTile();

		if (room.isAnyRole() && !room.getWavesMap().isEmpty())
		{
			room.getWavesMap().forEach((npc, ticks) ->
			{
				if (npc.getName() != null && !npc.isDead())
				{
					Color color = null;

					// Determine whether or not the role even matches prior to matching nylocas name
					if (room.isDisplayRoleMage() && npc.getName().equals("Nylocas Hagios"))
					{
						color = NylocasConstants.MAGIC_COLOR;
					}
					else if (room.isDisplayRoleMelee() && npc.getName().equals("Nylocas Ischyros"))
					{
						color = NylocasConstants.MELEE_COLOR;
					}
					else if (room.isDisplayRoleRange() && npc.getName().equals("Nylocas Toxobolos"))
					{
						color = NylocasConstants.RANGE_COLOR;
					}

					if (color != null)
					{
						final LocalPoint localPoint = npc.getLocalLocation();
						Polygon polygon = npc.getCanvasTilePoly();

						if (polygon != null)
						{
							OverlayUtil.renderPolygon(graphics, polygon, color);
						}

						if (room.getBigsMap().containsKey(npc) && displaySWTile)
						{
							polygon = Perspective.getCanvasTilePoly(client, new LocalPoint(localPoint.getX() - (Perspective.LOCAL_TILE_SIZE / 2), localPoint.getY() - (Perspective.LOCAL_TILE_SIZE / 2)));
							OverlayUtil.renderPolygon(graphics, polygon, color);
						}
					}
				}
			});
		}
	}
}

/*
 * Copyright (c) 2022, Damen <gh: damencs>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:

 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.

 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.

 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.tobqol.rooms.xarpus.commons;

import com.google.common.collect.ImmutableMap;
import lombok.RequiredArgsConstructor;
import net.runelite.api.NPC;

import javax.annotation.Nullable;
import java.util.Map;

@RequiredArgsConstructor
public enum XarpusPhase
{
	INACTIVE(XarpusTable.XARPUS_INACTIVE),
	P1(XarpusTable.XARPUS_P1),
	P2(XarpusTable.XARPUS_P23),
	P3(null),
	DEAD(XarpusTable.XARPUS_DEAD),
	UNKNOWN(null);

	@Nullable
	private final XarpusTable table;

	private static final Map<Integer, XarpusPhase> LOOKUP_MAP;

	static
	{
		ImmutableMap.Builder<Integer, XarpusPhase> builder = ImmutableMap.builder();

		for (XarpusPhase phase : values())
		{
			if (phase.isAbsent() || phase.isP3())
			{
				continue;
			}

			XarpusTable table = phase.table;

			if (table == null)
			{
				continue;
			}

			builder.put(table.sm(), phase);
			builder.put(table.rg(), phase);
			builder.put(table.hm(), phase);
		}

		LOOKUP_MAP = builder.build();
	}

	public static XarpusPhase compose(NPC npc)
	{
		return LOOKUP_MAP.getOrDefault(npc.getId(), UNKNOWN);
	}

	public boolean isInactive()
	{
		return this == INACTIVE;
	}

	public boolean isP1()
	{
		return this == P1;
	}

	public boolean isInactiveOrP1()
	{
		return isInactive() || isP1();
	}

	public boolean isP2()
	{
		return this == P2;
	}

	public boolean isP3()
	{
		return this == P3;
	}

	public boolean isP2OrP3()
	{
		return isP2() || isP3();
	}

	public boolean isAbsent()
	{
		return this == UNKNOWN;
	}

	public boolean isDead()
	{
		return this == DEAD;
	}
}

/*
 * Copyright (c) 2022, Damen <gh: damencs>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:

 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.

 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.

 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.tobqol.rooms.xarpus.commons;

import com.google.common.collect.ImmutableTable;
import com.google.common.collect.Table;
import com.tobqol.api.game.Instance;
import lombok.Getter;
import lombok.RequiredArgsConstructor;
import lombok.experimental.Accessors;
import net.runelite.api.NpcID;

import javax.annotation.Nullable;

@RequiredArgsConstructor
@Getter
@Accessors(fluent = true)
public enum XarpusTable implements XarpusConstants
{
	XARPUS_INACTIVE(NpcID.XARPUS_10766, NpcID.XARPUS, NpcID.XARPUS_10770),
	XARPUS_P1(NpcID.XARPUS_10767, NpcID.XARPUS_8339, NpcID.XARPUS_10771),
	XARPUS_P23(NpcID.XARPUS_10768, NpcID.XARPUS_8340, NpcID.XARPUS_10772),
	XARPUS_DEAD(NpcID.XARPUS_10769, NpcID.XARPUS_8341, NpcID.XARPUS_10773);


	private final int sm;
	private final int rg;
	private final int hm;

	private static final Table<Instance.Mode, Integer, XarpusTable> TABLE;

	static
	{
		ImmutableTable.Builder<Instance.Mode, Integer, XarpusTable> builder = ImmutableTable.builder();

		for (XarpusTable table : values())
		{
			builder.put(Instance.Mode.STORY, table.sm, table);
			builder.put(Instance.Mode.REGULAR, table.rg, table);
			builder.put(Instance.Mode.HARD, table.hm, table);
		}

		TABLE = builder.build();
	}

	@Nullable
	public static Instance.Mode findMode(int npcId)
	{
		return Instance.findFirstMode(mode -> TABLE.contains(mode, npcId));
	}

	public static boolean anyMatch(XarpusTable table, int npcId)
	{
		return table != null && (table.sm == npcId || table.rg == npcId || table.hm == npcId);
	}
}

/*
 * Copyright (c) 2022, Damen <gh: damencs>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:

 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.

 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.

 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.tobqol.rooms.xarpus.commons;

import net.runelite.api.ObjectID;

import java.util.regex.Pattern;

public interface XarpusConstants
{
	String BOSS_NAME = "Xarpus";

	int BOSS_IMAGE = 25752;

	Pattern XARPUS_WAVE = Pattern.compile("Wave 'Xarpus' \\(.*\\) complete!");

	int EXHUMED_GROUND_OBJ = ObjectID.EXHUMED;
}

/*
 * Copyright (c) 2022, Damen <gh: damencs>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:

 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.

 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.

 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.tobqol.rooms.xarpus.commons;

import lombok.Getter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.GroundObject;
import org.apache.commons.lang3.tuple.Pair;

import java.util.Collection;
import java.util.HashMap;
import java.util.Map;
import java.util.function.BiConsumer;

@Slf4j
public class ExhumedTracker
{
	@Getter
	private final Map<Long, Pair<GroundObject, Integer>> exhumeds;

	public ExhumedTracker()
	{
		this.exhumeds = new HashMap<>();
	}

	public boolean track(GroundObject obj)
	{
		if (obj == null || obj.getId() != XarpusTable.EXHUMED_GROUND_OBJ)
		{
			return false;
		}

		long hash = obj.getHash();

		if (exhumeds.containsKey(hash))
		{
			return false;
		}

		exhumeds.put(hash, Pair.of(obj, 12));
		return true;
	}

	public void tick()
	{
		exhumeds.values().removeIf(p -> p.getRight() <= 0);
		exhumeds.replaceAll((k, v) -> Pair.of(v.getLeft(), v.getRight() - 1));
	}

	public void forEachExhumed(BiConsumer<GroundObject, Integer> action)
	{
		if (action == null || exhumeds.isEmpty())
		{
			return;
		}

		Collection<Pair<GroundObject, Integer>> exhumeds = this.exhumeds.values();

		if (exhumeds.isEmpty())
		{
			return;
		}

		exhumeds.forEach(p -> action.accept(p.getLeft(), p.getRight()));
	}
}

/*
 * Copyright (c) 2022, Damen <gh: damencs>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:

 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.

 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.

 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.tobqol.rooms.xarpus;

import com.tobqol.TheatreQOLConfig;
import com.tobqol.TheatreQOLPlugin;
import com.tobqol.api.game.Instance;
import com.tobqol.rooms.RoomSceneOverlay;
import com.tobqol.rooms.xarpus.commons.XarpusPhase;
import net.runelite.api.Client;
import net.runelite.client.ui.overlay.OverlayLayer;

import javax.inject.Inject;
import java.awt.*;

public class XarpusSceneOverlay extends RoomSceneOverlay<XarpusHandler>
{
	@Inject
	protected XarpusSceneOverlay(
			Client client,
			Instance instance,
			XarpusHandler room,
			TheatreQOLPlugin plugin,
			TheatreQOLConfig config
	)
	{
		super(client, instance, room, plugin, config);
	}

	@Override
	public Dimension render(Graphics2D graphics)
	{
		if (!room.active())
		{
			return null;
		}

		setLayer(OverlayLayer.ABOVE_SCENE);
		graphics.setFont(plugin.getInstanceTimerFont());

		XarpusPhase phase = room.getPhase();

		if (config.displayXarpusInstanceTimer() && phase.isInactiveOrP1())
		{
			drawInstanceTimer(graphics, room.getXarpusNpc(), null);
		}

		return null;
	}
}

/*
 * Copyright (c) 2022, Damen <gh: damencs>
 * Copyright (c) 2022, Boris - Portions of Area Sound Effects Played
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:

 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.

 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.

 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.tobqol.rooms.xarpus;

import com.tobqol.TheatreQOLConfig;
import com.tobqol.TheatreQOLPlugin;
import com.tobqol.api.game.Region;
import com.tobqol.rooms.RoomHandler;
import com.tobqol.rooms.xarpus.commons.ExhumedTracker;
import com.tobqol.rooms.xarpus.commons.XarpusConstants;
import com.tobqol.rooms.xarpus.commons.XarpusPhase;
import com.tobqol.rooms.xarpus.commons.XarpusTable;
import com.tobqol.tracking.RoomDataHandler;
import com.tobqol.tracking.RoomDataItem;
import com.tobqol.tracking.RoomInfoBox;
import lombok.Getter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.ChatMessageType;
import net.runelite.api.NPC;
import net.runelite.api.events.*;
import net.runelite.client.chat.ChatColorType;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.events.ConfigChanged;
import net.runelite.client.util.Text;

import javax.annotation.CheckForNull;
import javax.inject.Inject;
import javax.sound.sampled.Clip;
import javax.sound.sampled.FloatControl;
import java.awt.*;

import static com.tobqol.api.game.Region.XARPUS;
import static com.tobqol.rooms.xarpus.commons.XarpusConstants.BOSS_IMAGE;
import static com.tobqol.rooms.xarpus.commons.XarpusConstants.XARPUS_WAVE;
import static com.tobqol.tracking.RoomInfoUtil.createInfoBox;
import static com.tobqol.tracking.RoomInfoUtil.formatTime;

@Slf4j
public class XarpusHandler extends RoomHandler
{
	@Inject
	private XarpusSceneOverlay sceneOverlay;

	private RoomDataHandler dataHandler;

	@Getter
	@CheckForNull
	private NPC xarpusNpc = null;

	private RoomInfoBox xarpuInfoBox;

	@Getter
	private XarpusPhase phase = XarpusPhase.UNKNOWN;

	@Getter
	@CheckForNull
	private ExhumedTracker exhumedTracker = null;

	private static Clip soundClip;

	@Inject
	protected XarpusHandler(TheatreQOLPlugin plugin, TheatreQOLConfig config)
	{
		super(plugin, config);
		setRoomRegion(Region.XARPUS);

		dataHandler = plugin.getDataHandler();
	}

	@Override
	public void load()
	{
		overlayManager.add(sceneOverlay);
		soundClip = generateSoundClip("sheesh-hoyaa.wav", config.xarpusSoundClipVolume());
	}

	@Override
	public void unload()
	{
		overlayManager.remove(sceneOverlay);
		soundClip.close();
		reset();
	}

	@Override
	public boolean active()
	{
		return instance.getCurrentRegion().isXarpus() && xarpusNpc != null && !xarpusNpc.isDead();
	}

	@Override
	public void reset()
	{
		xarpusNpc = null;
		phase = XarpusPhase.UNKNOWN;

		if (exhumedTracker != null)
		{
			exhumedTracker = null;
		}

		if (instance.getRaidStatus() <= 1)
		{
			infoBoxManager.removeInfoBox(xarpuInfoBox);
		}
	}

	@Subscribe
	public void onConfigChanged(ConfigChanged event)
	{
		if (event.getGroup().equals("tobqol"))
		{
			if (event.getKey().equals("xarpusSoundClipVolume") && config.xarpusSoundClip())
			{
				if (soundClip != null)
				{
					FloatControl control = (FloatControl) soundClip.getControl(FloatControl.Type.MASTER_GAIN);

					if (control != null)
					{
						control.setValue((float)(config.xarpusSoundClipVolume() / 2 - 45));
					}

					soundClip.setFramePosition(0);
					soundClip.start();
				}
			}
		}
	}

	@Subscribe
	private void onNpcSpawned(NpcSpawned e)
	{
		if (active())
		{
			return;
		}

		isNpcFromName(e.getNpc(), XarpusConstants.BOSS_NAME, n ->
		{
			instance.lazySetMode(() -> XarpusTable.findMode(n.getId()));
			xarpusNpc = n;
			phase = XarpusPhase.compose(n);

			if (phase == XarpusPhase.P2 && (n.getOverheadText() != null || client.getVarbitValue(6448) <= 250))
			{
				phase = XarpusPhase.P3;
			}

			if (XarpusTable.anyMatch(XarpusTable.XARPUS_P1, n.getId()))
			{
				if (!dataHandler.Find("Starting Tick").isPresent())
				{
					dataHandler.getData().add(new RoomDataItem("Starting Tick", client.getTickCount(), true));
					dataHandler.setShouldTrack(true);
					return;
				}
			}

			exhumedTracker = new ExhumedTracker();
		});
	}

	@Subscribe
	private void onNpcChanged(NpcChanged e)
	{
		if (!active())
		{
			return;
		}

		isNpcFromName(e.getNpc(), XarpusConstants.BOSS_NAME, n ->
		{
			phase = XarpusPhase.compose(n);

			if (XarpusTable.anyMatch(XarpusTable.XARPUS_P1, n.getId()))
			{
				if (!dataHandler.Find("Starting Tick").isPresent())
				{
					dataHandler.getData().add(new RoomDataItem("Starting Tick", client.getTickCount(), true));
					dataHandler.setShouldTrack(true);
					return;
				}
			}
			else if (XarpusTable.anyMatch(XarpusTable.XARPUS_P23, n.getId()))
			{
				if (!dataHandler.Find("Exhumeds").isPresent())
				{
					dataHandler.getData().add(new RoomDataItem("Exhumeds", dataHandler.getTime(), 1, false));
					return;
				}
			}
		});
	}

	@Subscribe
	private void onNpcDespawned(NpcDespawned e)
	{
		if (!active() || xarpusNpc == null || !isNpcFromName(e.getNpc(), XarpusConstants.BOSS_NAME))
		{
			return;
		}

		reset();
	}

	@Subscribe
	private void onGameTick(GameTick e)
	{
		if (instance.isInRaid() && instance.getCurrentRegion().isXarpus())
		{
			if (instance.getRoomStatus() == 1 && !dataHandler.Find("Starting Tick").isPresent())
			{
				dataHandler.getData().add(new RoomDataItem("Starting Tick", dataHandler.getTime(), true, true));
				dataHandler.setShouldTrack(true);
			}

			if (dataHandler.isShouldTrack() && !dataHandler.getData().isEmpty())
			{
				dataHandler.updateTotalTime();
			}
		}

		if (!active())
		{
			return;
		}

		if (exhumedTracker != null)
		{
			exhumedTracker.tick();

			if (exhumedTracker.getExhumeds().isEmpty() && !phase.isInactiveOrP1())
			{
				exhumedTracker = null;
			}
		}

		if (xarpusNpc.getOverheadText() != null && !phase.isP3())
		{
			phase = XarpusPhase.P3;
		}
	}

	@Subscribe
	private void onGroundObjectSpawned(GroundObjectSpawned e)
	{
		if (!active() || exhumedTracker == null)
		{
			return;
		}

		if (exhumedTracker.track(e.getGroundObject()) && instance.getTickCycle() > -1)
		{
			instance.resetTickCycle();
		}
	}

	@Subscribe
	public void onAreaSoundEffectPlayed(AreaSoundEffectPlayed event)
	{
		if(xarpusNpc != null && active())
		{
			if (event.getSoundId() == 4005 && instance.isHardMode() && config.muteXarpusHMEntry())
			{
				event.consume();
			}
			else if (event.getSoundId() == 4007 && config.xarpusSoundClip())
			{
				event.consume();
			}
		}
	}

	@Subscribe
	public void onOverheadTextChanged(OverheadTextChanged event)
	{
		if (active() && event.getActor() instanceof NPC && config.xarpusSoundClip())
		{
			if (xarpusNpc == event.getActor())
			{
				event.getActor().setOverheadText("Sheeeeeesh!");
				soundClip.setFramePosition(0);
				soundClip.start();

				dataHandler.getData().add(new RoomDataItem("Screech", dataHandler.getTime(), 2, false));
			}
		}
	}

	@Subscribe
	public void onChatMessage(ChatMessage event)
	{
		if (instance.getCurrentRegion() != XARPUS && event.getType() != ChatMessageType.GAMEMESSAGE)
		{
			return;
		}

		String stripped = Text.removeTags(event.getMessage());

		if (XARPUS_WAVE.matcher(stripped).find())
		{
			dataHandler.setShouldTrack(false);
			dataHandler.Find("Room").get().setValue(dataHandler.getTime());

			if (config.displayRoomTimes().isInfobox())
			{
				buildInfobox();
			}

			if (config.displayRoomTimes().isChat())
			{
				sendChatTimes();
			}
		}
	}

	private void buildInfobox()
	{
		if (!dataHandler.getData().isEmpty())
		{
			String tooltip;

			if (!dataHandler.Find("Starting Tick").get().isException())
			{
				tooltip = "Exhumeds - " + formatTime(dataHandler.FindValue("Exhumeds")) + "</br>" +
					"Screech - " + formatTime(dataHandler.FindValue("Screech")) + formatTime(dataHandler.FindValue("Screech"), dataHandler.FindValue("Exhumeds")) + "</br>" +
					"Complete - " + formatTime(dataHandler.FindValue("Room")) + formatTime(dataHandler.FindValue("Room"), dataHandler.FindValue("Screech"));
			}
			else
			{
				tooltip = "Complete - " + formatTime(dataHandler.FindValue("Room")) + "*";
			}

			xarpuInfoBox = createInfoBox(plugin, config, itemManager.getImage(BOSS_IMAGE), "Xarpus", formatTime(dataHandler.FindValue("Room")), tooltip);
			infoBoxManager.addInfoBox(xarpuInfoBox);
		}
	}

	private void sendChatTimes()
	{
		if (!dataHandler.getData().isEmpty())
		{
			if (!dataHandler.Find("Starting Tick").get().isException())
			{
				enqueueChatMessage(ChatMessageType.GAMEMESSAGE, b -> b
						.append(Color.RED, "Exhumeds")
						.append(ChatColorType.NORMAL)
						.append(" - " + formatTime(dataHandler.FindValue("Exhumeds")) + " - ")
						.append(Color.RED, "Screech")
						.append(ChatColorType.NORMAL)
						.append(" - " + formatTime(dataHandler.FindValue("Screech")) + formatTime(dataHandler.FindValue("Screech"), dataHandler.FindValue("Exhumeds"))));

				if (config.roomTimeValidation())
				{
					enqueueChatMessage(ChatMessageType.GAMEMESSAGE, b -> b
							.append(Color.RED, "Xarpus - Room Complete")
							.append(ChatColorType.NORMAL)
							.append(" - " + formatTime(dataHandler.FindValue("Room")) + formatTime(dataHandler.FindValue("Room"), dataHandler.FindValue("Screech"))));
				}
			}
			else
			{
				if (config.roomTimeValidation())
				{
					enqueueChatMessage(ChatMessageType.GAMEMESSAGE, b -> b
							.append(Color.RED, "Xarpus - Room Complete")
							.append(ChatColorType.NORMAL)
							.append(" - " + formatTime(dataHandler.FindValue("Room")) + "*"));
				}
			}
		}
	}
}

/*
 * Copyright (c) 2022, Damen <gh: damencs>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:

 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.

 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.

 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.tobqol.rooms;

import com.tobqol.TheatreQOLConfig;
import com.tobqol.TheatreQOLPlugin;
import com.tobqol.api.game.Instance;
import com.tobqol.api.game.Region;
import com.tobqol.api.game.SceneManager;
import lombok.Getter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.*;
import net.runelite.api.coords.WorldPoint;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.chat.ChatMessageBuilder;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.chat.QueuedMessage;
import net.runelite.client.game.ItemManager;
import net.runelite.client.ui.overlay.OverlayManager;
import net.runelite.client.ui.overlay.infobox.InfoBoxManager;

import javax.annotation.Nullable;
import javax.inject.Inject;
import javax.inject.Singleton;
import javax.sound.sampled.*;
import java.io.BufferedInputStream;
import java.util.Optional;
import java.util.function.BiFunction;
import java.util.function.Consumer;
import java.util.function.Predicate;

import static com.google.common.base.Strings.isNullOrEmpty;
import static com.tobqol.api.game.Region.inRegion;
import static lombok.AccessLevel.PROTECTED;

@Singleton
@Slf4j
public abstract class RoomHandler
{
	public static final Predicate<Integer> VALUE_IS_ZERO = v -> v <= 0;

	public static final BiFunction<Object, Integer, Integer> INCREMENT_VALUE = (k, v) -> ++v;
	public static final BiFunction<Object, Integer, Integer> DECREMENT_VALUE = (k, v) -> --v;

	protected final TheatreQOLPlugin plugin;
	protected final TheatreQOLConfig config;

	@Inject
	protected Client client;

	@Inject
	protected ClientThread clientThread;

	@Inject
	protected OverlayManager overlayManager;

	@Inject
	protected Instance instance;

	@Inject
	protected SceneManager sceneManager;

	@Inject
	protected ChatMessageManager chatMessageManager;

	@Inject
	protected ItemManager itemManager;

	@Inject
	protected InfoBoxManager infoBoxManager;

	@Getter(PROTECTED)
	private Region roomRegion = Region.UNKNOWN;

	@Inject
	protected RoomHandler(TheatreQOLPlugin plugin, TheatreQOLConfig config)
	{
		this.plugin = plugin;
		this.config = config;
	}

	public void init()
	{
	}

	public abstract void load();

	public abstract void unload();

	public boolean active()
	{
		return false;
	}

	public abstract void reset();

	protected final void setRoomRegion(Region region)
	{
		if (!roomRegion.isUnknown())
		{
			return;
		}

		if (region == null)
		{
			roomRegion = Region.UNKNOWN;
			return;
		}

		switch (region)
		{
			case LOBBY:
				roomRegion = Region.MAIDEN;
				break;
			case SOTETSEG_MAZE:
				roomRegion = Region.SOTETSEG;
				break;
			default:
				roomRegion = region;
				break;
		}
	}

	protected final boolean isInRoomRegion()
	{
		if (roomRegion.isUnknown())
		{
			return false;
		}

		Region current = instance.getCurrentRegion();
		return roomRegion.equals(current) || (roomRegion.isSotetseg() && current.isSotetseg());
	}

	protected static boolean isNpcFromName(NPC npc, String name)
	{
		if (npc == null || isNullOrEmpty(name))
		{
			return false;
		}

		String _name = npc.getName();
		return !isNullOrEmpty(_name) && _name.equals(name);
	}

	protected static boolean isNpcFromName(NPC npc, String name, Consumer<NPC> action)
	{
		if (isNpcFromName(npc, name))
		{
			if (action != null)
			{
				action.accept(npc);
			}

			return true;
		}

		return false;
	}

	protected static void when(boolean condition, Runnable success, Runnable failure)
	{
		if (condition)
		{
			Optional.ofNullable(success).ifPresent(Runnable::run);
			return;
		}

		Optional.ofNullable(failure).ifPresent(Runnable::run);
	}

	@Nullable
	protected final MessageNode sendChatMessage(ChatMessageType type, String message)
	{
		if (type == null || isNullOrEmpty(message))
		{
			return null;
		}

		return client.addChatMessage(type, "", message, "", false);
	}

	protected final void enqueueChatMessage(ChatMessageType type, Consumer<ChatMessageBuilder> user)
	{
		if (type == null || user == null)
		{
			return;
		}

		ChatMessageBuilder builder = new ChatMessageBuilder();
		user.accept(builder);

		String message = builder.build();

		if (isNullOrEmpty(message))
		{
			return;
		}

		chatMessageManager.queue(QueuedMessage.builder().type(type).runeLiteFormattedMessage(message).build());
	}

	protected final void enqueueChatMessage(ChatMessageType type, ChatMessageBuilder builder)
	{
		if (type == null || builder == null)
		{
			return;
		}

		String message = builder.build();

		if (isNullOrEmpty(message))
		{
			return;
		}

		chatMessageManager.queue(QueuedMessage.builder().type(type).runeLiteFormattedMessage(message).build());
	}

	public static boolean crossedLine(Region region, Point start, Point end, boolean vertical, Client client)
	{
		if (inRegion(client, region))
		{
			for (Player p : client.getTopLevelWorldView().players())
			{
				WorldPoint wp = p.getWorldLocation();

				if (vertical)
				{
					for (int i = start.getY(); i < end.getY() + 1; i++)
					{
						if (wp.getRegionY() == i && wp.getRegionX() == start.getX())
						{
							return true;
						}
					}
				}
				else
				{
					for (int i = start.getX(); i < end.getX() + 1; i++)
					{
						if (wp.getRegionX() == i && wp.getRegionY() == start.getY())
						{
							return true;
						}
					}
				}
			}
		}

		return false;
	}

	public Clip generateSoundClip(String clipName, int volume)
	{
		Clip soundClip;

		try
		{
			AudioInputStream stream = AudioSystem.getAudioInputStream(new BufferedInputStream(TheatreQOLPlugin.class.getResourceAsStream(clipName)));
			AudioFormat format = stream.getFormat();
			DataLine.Info info = new DataLine.Info(Clip.class, format);
			soundClip = (Clip)AudioSystem.getLine(info);
			soundClip.open(stream);
			FloatControl control = (FloatControl) soundClip.getControl(FloatControl.Type.MASTER_GAIN);

			if (control != null)
			{
				control.setValue((float)(volume / 2 - 45));
			}

			return soundClip;
		}
		catch (Exception ex)
		{
			return null;
		}
	}
}
/*
 * Copyright (c) 2022, Damen <gh: damencs>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:

 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.

 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.

 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.tobqol.rooms.bloat;

import com.tobqol.TheatreQOLConfig;
import com.tobqol.TheatreQOLPlugin;
import com.tobqol.api.game.Region;
import com.tobqol.rooms.RoomHandler;
import com.tobqol.rooms.bloat.commons.BloatConstants;
import com.tobqol.rooms.bloat.commons.BloatTable;
import com.tobqol.tracking.RoomDataHandler;
import com.tobqol.tracking.RoomDataItem;
import com.tobqol.tracking.RoomInfoBox;
import com.tobqol.tracking.RoomInfoUtil;
import lombok.Getter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.ChatMessageType;
import net.runelite.api.GameState;
import net.runelite.api.NPC;
import net.runelite.api.Point;
import net.runelite.api.events.*;
import net.runelite.client.chat.ChatColorType;
import net.runelite.client.chat.ChatMessageBuilder;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.events.ConfigChanged;
import net.runelite.client.util.Text;

import javax.annotation.CheckForNull;
import javax.inject.Inject;
import java.awt.*;

import static com.tobqol.api.game.RaidConstants.THEATRE_OF_BLOOD_ROOM_STATUS;
import static com.tobqol.api.game.Region.BLOAT;
import static com.tobqol.api.game.Region.inRegion;
import static com.tobqol.rooms.bloat.commons.BloatConstants.*;
import static com.tobqol.tracking.RoomInfoUtil.formatTime;

@Getter
@Slf4j
public class BloatHandler extends RoomHandler
{
	private RoomDataHandler dataHandler;

	@Getter
	@CheckForNull
	private NPC bloatNpc = null;

	private RoomInfoBox bloatInfoBox;

	private int downs = 0;

	@Inject
	protected BloatHandler(TheatreQOLPlugin plugin, TheatreQOLConfig config)
	{
		super(plugin, config);
		setRoomRegion(Region.BLOAT);

		dataHandler = plugin.getDataHandler();
	}

	@Override
	public void load()
	{
	}

	@Override
	public void unload()
	{
		reset();
	}

	@Override
	public void reset()
	{
		bloatNpc = null;

		if (instance.getRaidStatus() <= 1)
		{
			downs = 0;
			infoBoxManager.removeInfoBox(bloatInfoBox);
		}
	}

	@Override
	public boolean active()
	{
		return inRegion(client, BLOAT);
	}

	@Subscribe
	private void onConfigChanged(ConfigChanged e)
	{
		if (!e.getGroup().equals(TheatreQOLConfig.GROUP_NAME))
		{
			return;
		}

		switch (e.getKey())
		{
			case "hideCeilingChains":
				when(config.shouldNullCeilingChains(), this::nullCeilingChains, sceneManager::refreshScene);
				break;
		}
	}

	@Subscribe(priority = -1)
	private void onGameStateChanged(GameStateChanged e)
	{
		if (!active() || e.getGameState() != GameState.LOGGED_IN)
		{
			return;
		}

		when(config.shouldNullCeilingChains(), this::nullCeilingChains, null);
	}

	@Subscribe
	private void onNpcSpawned(NpcSpawned e)
	{
		if (!active() || bloatNpc != null)
		{
			return;
		}

		isNpcFromName(e.getNpc(), BloatConstants.BOSS_NAME, n ->
		{
			instance.lazySetMode(() -> BloatTable.findMode(n.getId()));
			bloatNpc = n;
		});

		when(config.shouldNullCeilingChains(), this::nullCeilingChains, null);
	}

	@Subscribe
	private void onNpcDespawned(NpcDespawned e)
	{
		if (!active())
		{
			return;
		}

		isNpcFromName(e.getNpc(), BloatConstants.BOSS_NAME, $ -> reset());
	}

	@Subscribe
	private void onGameTick(GameTick event)
	{
		if (instance.isInRaid() && instance.getCurrentRegion().isBloat())
		{
			if (!dataHandler.Find("Starting Tick").isPresent() && crossedLine(BLOAT, new Point(39, 30), new Point(39, 33), true, client))
			{
				dataHandler.getData().add(new RoomDataItem("Starting Tick", client.getTickCount(), true));
				dataHandler.setShouldTrack(true);
			}

			if (!dataHandler.getData().isEmpty() && dataHandler.isShouldTrack())
			{
				dataHandler.updateTotalTime();
			}
		}
	}

	@Subscribe
	private void onVarbitChanged(VarbitChanged event)
	{
		if (instance.isInRaid() && instance.getCurrentRegion().isBloat() && !dataHandler.Find("Starting Tick").isPresent())
		{
			if (client.getVarbitValue(THEATRE_OF_BLOOD_ROOM_STATUS) == 1)
			{
				dataHandler.getData().add(new RoomDataItem("Starting Tick", client.getTickCount(), true, true));
				dataHandler.setShouldTrack(true);
			}
		}
	}

	@Subscribe
	private void onAnimationChanged(AnimationChanged e)
	{
		if (!active() || !(e.getActor() instanceof NPC))
		{
			return;
		}

		NPC npc = (NPC) e.getActor();

		if (npc == bloatNpc && npc.getAnimation() == DOWN_ANIM)
		{
			downs++;
			dataHandler.getData().add(new RoomDataItem("Down " + downs, dataHandler.getTime(), downs, true));
		}
	}

	@Subscribe
	public void onChatMessage(ChatMessage event)
	{
		if (!active() || event.getType() != ChatMessageType.GAMEMESSAGE || !dataHandler.Find("Starting Tick").isPresent())
		{
			return;
		}

		String stripped = Text.removeTags(event.getMessage());

		if (BLOAT_WAVE.matcher(stripped).find())
		{
			dataHandler.setShouldTrack(false);
			dataHandler.Find("Room").get().setValue(dataHandler.getTime());

			if (config.displayRoomTimes().isInfobox())
			{
				buildInfobox();
			}

			if (config.displayRoomTimes().isChat())
			{
				sendChatTimes();
			}
		}
	}

	private void nullCeilingChains()
	{
		sceneManager.removeTheseGameObjects(1, BloatTable.CEILING_CHAINS);
	}

	private void buildInfobox()
	{
		if (dataHandler.FindValue("Starting Tick") > 0)
		{
			String roomTime = formatTime(dataHandler.FindValue("Room"));
			StringBuilder tooltip = new StringBuilder();

			if (!dataHandler.Find("Starting Tick").get().isException())
			{
				if (config.trackDowns())
				{
					if (downs > 0)
					{
						dataHandler.getData().forEach(d ->
						{
							if (d.getName().contains("Down"))
							{
								tooltip.append(d.getName() + " - " + formatTime(dataHandler.FindValue("Down " + d.getSort())) +
										(d.getSort() > 1 ? formatTime(dataHandler.FindValue("Down " + d.getSort()), dataHandler.FindValue("Down " + (d.getSort() - 1))) : "") + "</br>");
							}
						});
					}
					else
					{
						tooltip.append("No downs");
					}
				}

				tooltip.append("Complete - " + roomTime);
			}
			else
			{
				tooltip.append("Complete - " + roomTime + "*");
			}


			bloatInfoBox = RoomInfoUtil.createInfoBox(plugin, config, itemManager.getImage(BOSS_IMAGE), "Bloat", roomTime, tooltip.toString());
			plugin.infoBoxManager.addInfoBox(bloatInfoBox);
		}
	}

	private void sendChatTimes()
	{
		if (dataHandler.Find("Starting Tick").isPresent())
		{
			if (!dataHandler.Find("Starting Tick").get().isException())
			{
				if (downs > 0 && config.trackDowns())
				{
					ChatMessageBuilder chatMessageBuilder = new ChatMessageBuilder();

					int downsRemaining = downs - 1;

					for (RoomDataItem d : dataHandler.getData())
					{
						if (d.getName().contains("Down"))
						{
							chatMessageBuilder.append(Color.RED, d.getName())
									.append(ChatColorType.NORMAL)
									.append(" - " + formatTime(d.getValue()) + (d.getSort() > 1 ? formatTime(d.getValue(), dataHandler.FindValue("Down " + (d.getSort() - 1))) : "") + (downsRemaining > 0 ? " - " : ""));

							downsRemaining--;
						}
					}

					enqueueChatMessage(ChatMessageType.GAMEMESSAGE, chatMessageBuilder);
				}

				if (config.roomTimeValidation())
				{
					enqueueChatMessage(ChatMessageType.GAMEMESSAGE, b -> b
							.append(Color.RED, "Bloat - Room Complete")
							.append(ChatColorType.NORMAL)
							.append(" - " + formatTime(dataHandler.FindValue("Room")) + formatTime(dataHandler.FindValue("Room"), dataHandler.FindValue("Down " + downs))));
				}
			}
			else
			{
				if (config.roomTimeValidation())
				{
					enqueueChatMessage(ChatMessageType.GAMEMESSAGE, b -> b
							.append(Color.RED, "Bloat - Room Complete")
							.append(ChatColorType.NORMAL)
							.append(" - " + formatTime(dataHandler.FindValue("Room")) + "*"));
				}
			}
		}
	}
}

/*
 * Copyright (c) 2022, Damen <gh: damencs>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:

 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.

 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.

 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.tobqol.rooms.bloat.commons;

import com.google.common.collect.ImmutableList;

import java.util.regex.Pattern;

public interface BloatConstants
{
	String BOSS_NAME = "Pestilent Bloat";
	String BOSS_NAME_SIMPLE = "Bloat";

	Pattern BLOAT_WAVE = Pattern.compile("Wave 'The Pestilent Bloat' \\(.*\\) complete!Duration: (\\d+):(\\d+)\\.?(\\d+)");

	int BOSS_IMAGE = 25749;

	int DOWN_ANIM = 8082;

	ImmutableList<Integer> TANK = ImmutableList.of(32957, 32955, 32959, 32960, 32964, 33084);                   // GameObjects
	ImmutableList<Integer> TOP_OF_TANK = ImmutableList.of(32958, 32962, 32964, 32965, 33062);                   // GameObjects
	ImmutableList<Integer> CEILING_CHAINS = ImmutableList.of(32949, 32950, 32951, 32952, 32953, 32954, 32970);  // GameObjects
	ImmutableList<Integer> BLOAT_FLOOR = ImmutableList.of(32941, 32942, 32944, 32946, 32948);                   // GroundObjects
}

/*
 * Copyright (c) 2022, Damen <gh: damencs>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:

 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.

 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.

 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.tobqol.rooms.bloat.commons;

import com.google.common.collect.ImmutableTable;
import com.google.common.collect.Table;
import com.tobqol.api.game.Instance;
import lombok.RequiredArgsConstructor;
import net.runelite.api.NpcID;

import static com.google.common.collect.Tables.immutableCell;

@RequiredArgsConstructor
public enum BloatTable implements BloatConstants
{
	BLOAT(NpcID.PESTILENT_BLOAT_10812, NpcID.PESTILENT_BLOAT, NpcID.PESTILENT_BLOAT_10813);

	private final int sm, rg, hm;

	private static final Table<Instance.Mode, Integer, BloatTable> LOOKUP_TABLE;

	static
	{
		ImmutableTable.Builder<Instance.Mode, Integer, BloatTable> l_builder = ImmutableTable.builder();

		for (BloatTable def : values())
		{
			l_builder.put(immutableCell(Instance.Mode.STORY, def.sm, def));
			l_builder.put(immutableCell(Instance.Mode.REGULAR, def.rg, def));
			l_builder.put(immutableCell(Instance.Mode.HARD, def.hm, def));
		}

		LOOKUP_TABLE = l_builder.build();
	}

	public static Instance.Mode findMode(int npcId)
	{
		return Instance.findFirstMode(mode -> LOOKUP_TABLE.get(mode, npcId) != null);
	}
}

/*
 * Copyright (c) 2022, Damen <gh: damencs>
 * Copyright (c) 2022, WLoumakis <gh: WLoumakis> - Portions of "MES Options"
 * Copyright (c) 2021, BickusDiggus <gh: BickusDiggus> - Portions of "Loot Reminder"
 * Copyright (c) 2020, Broooklyn <gh: Broooklyn> - "ToB Light Up" Relevant Code
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:

 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.

 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.

 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.tobqol;

import com.google.common.base.Strings;
import com.google.common.collect.ArrayListMultimap;
import com.google.common.collect.Multimap;
import com.google.common.collect.MultimapBuilder;
import com.google.inject.Binder;
import com.google.inject.Provides;
import com.tobqol.api.game.Instance;
import com.tobqol.api.game.RaidConstants;
import com.tobqol.api.game.Region;
import com.tobqol.config.SupplyChestPreference;
import com.tobqol.rooms.RemovableOverlay;
import com.tobqol.rooms.RoomHandler;
import com.tobqol.rooms.bloat.BloatHandler;
import com.tobqol.rooms.maiden.MaidenHandler;
import com.tobqol.rooms.nylocas.NylocasHandler;
import com.tobqol.rooms.sotetseg.SotetsegHandler;
import com.tobqol.rooms.verzik.VerzikHandler;
import com.tobqol.rooms.xarpus.XarpusHandler;
import com.tobqol.tracking.RoomDataHandler;
import lombok.Getter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.*;
import net.runelite.api.coords.LocalPoint;
import net.runelite.api.coords.WorldPoint;
import net.runelite.api.events.*;
import net.runelite.api.widgets.Widget;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.eventbus.EventBus;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.events.ConfigChanged;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.plugins.PluginDescriptor;
import net.runelite.client.ui.FontManager;
import net.runelite.client.ui.overlay.Overlay;
import net.runelite.client.ui.overlay.OverlayManager;
import net.runelite.client.ui.overlay.infobox.InfoBoxManager;
import net.runelite.client.util.Text;

import javax.annotation.CheckForNull;
import javax.annotation.Nullable;
import javax.inject.Inject;
import javax.inject.Provider;
import java.awt.*;
import java.util.List;
import java.util.Objects;

@PluginDescriptor(
		name = "ToB QoL",
		description = "Theatre of Blood Quality of Life Enhancement Features to be used throughout a raid",
		tags = { "tob", "tobqol", "of", "blood", "maiden", "bloat", "nylo", "nylocas", "sotetseg", "xarpus", "verzik", "combat", "bosses", "pvm", "pve", "damen" },
		enabledByDefault = true,
		loadInSafeMode = false
)
@Slf4j
public class TheatreQOLPlugin extends Plugin
{
	@Inject
	private Client client;

	@Inject
	private EventBus eventBus;

	@Inject
	public OverlayManager overlayManager;

	@Inject
	private EventManager eventManager;

	@Inject
	@Getter
	private InstanceService instanceService;

	@Inject
	private Provider<MaidenHandler> maiden;

	@Inject
	private Provider<BloatHandler> bloat;

	@Inject
	private Provider<NylocasHandler> nylocas;

	@Inject
	private Provider<SotetsegHandler> sotetseg;

	@Inject
	private Provider<XarpusHandler> xarpus;

	@Inject
	private Provider<VerzikHandler> verzik;

	@Inject
	private TheatreQOLOverlay overlay;

	@Inject
	private TheatreQOLConfig config;

	@Inject
	public InfoBoxManager infoBoxManager;

	@Provides
	TheatreQOLConfig provideConfig(ConfigManager configManager)
	{
		return configManager.getConfig(TheatreQOLConfig.class);
	}

	@CheckForNull
	private RoomHandler[] rooms = null;

	private final Multimap<String, RemovableOverlay> removableOverlays = MultimapBuilder
			.hashKeys()
			.arrayListValues()
			.build();

	@Getter
	private RoomDataHandler dataHandler;

	private boolean darknessHidden;

	@Getter
	private GameObject entrance;

	@Getter
	private GameObject lootChest;

	@Getter
	boolean chestHasLoot = false;

	private final ArrayListMultimap<String, Integer> optionIndexes = ArrayListMultimap.create();

	@Getter
	public Font pluginFont;

	@Getter
	public Font instanceTimerFont;

	@Getter
	public int previousRegion;

	@Override
	public void configure(Binder binder)
	{
		binder.bind(Instance.class).to(com.tobqol.InstanceService.class);
	}

	@Override
	protected void startUp()
	{
		dataHandler = new RoomDataHandler(client, this, config);
		dataHandler.load();

		buildFont(false); // build standard font
		buildFont(true); // build instance timer font

		overlayManager.add(overlay);
		eventManager.startUp();

		if (rooms == null)
		{
			rooms = new RoomHandler[] { maiden.get(), bloat.get(), nylocas.get(), sotetseg.get(), xarpus.get(), verzik.get() };

			for (RoomHandler room : rooms)
			{
				room.init();
			}
		}

		for (RoomHandler room : rooms)
		{
			room.load();
			eventBus.register(room);
		}
	}

	@Override
	protected void shutDown()
	{
		reset(true);

		overlayManager.remove(overlay);
		eventManager.shutDown();

		removableOverlays.forEach((k, v) -> overlayManager.removeIf(v.provideOverlay().getClass()::isInstance)); // Remove all of the active 'RoomHandler' Overlays
		removableOverlays.clear(); // Explode the collection here as this collection gets rebuilt on this.startUp

		if (rooms != null)
		{
			for (RoomHandler room : rooms)
			{
				// Unregister before unloading to prevent potential data population
				eventBus.unregister(room);
				room.unload();
			}
		}

		dataHandler.unload();
	}

	// @TODO -> make this so that it doesn't reset twice every since time you leave the raid.. eventbus/instanceservice
	void reset(boolean global)
	{
		dataHandler.getData().clear();

		if (rooms != null)
		{
			for (RoomHandler room : rooms)
			{
				room.reset();
				log.debug("Resetting {}", room.getClass().getSimpleName());
			}
		}

		if (global)
		{
			darknessHidden = false;
			hideDarkness(false);

			entrance = null;
			lootChest = null;
			chestHasLoot = false;
			client.clearHintArrow();
		}
	}

	public boolean addRemovableOverlay(String configKey, RemovableOverlay removableOverlay)
	{
		if (Strings.isNullOrEmpty(configKey) || removableOverlay == null || removableOverlays.containsValue(removableOverlay))
		{
			return false;
		}

		if (!removableOverlay.remove(config))
		{
			overlayManager.add(removableOverlay.provideOverlay());
		}

		return removableOverlays.put(configKey, removableOverlay);
	}

	@Subscribe(priority = 1) // Reassure parent class has priority over the children classes
	private void onConfigChanged(ConfigChanged e)
	{
		if (!e.getGroup().equals(TheatreQOLConfig.GROUP_NAME))
		{
			return;
		}

		String key = e.getKey();

		removableOverlays.get(key).forEach(removableOverlay ->
		{
			Overlay overlay = removableOverlay.provideOverlay();

			if (removableOverlay.remove(config))
			{
				overlayManager.removeIf(overlay.getClass()::isInstance);
				return;
			}

			overlayManager.add(overlay);
		});

		switch (e.getKey())
		{
			case "lightUp":
			{
				hideDarkness(Boolean.valueOf(e.getNewValue()));
			}

			case "lootReminder":
			{
				if (client.hasHintArrow() && Boolean.valueOf(e.getNewValue()) == false)
				{
					client.clearHintArrow();
				}
			}

			case "fontType":
			case "fontSize":
			case "fontStyle":
			{
				buildFont(false);
			}

			case "instanceTimerSize":
			{
				buildFont(true);
			}

			case "displayTimeSplits":
			{
				dataHandler.updateHiddenItems(!Boolean.valueOf(e.getNewValue()));
				break;
			}
		}
	}

	@Subscribe
	private void onGameTick(GameTick e)
	{
		if ((instanceService.getCurrentRegion() != instanceService.getPreviousRegion()))
		{
			if ((instanceService.getCurrentRegion().isSotetsegUnderworld() && instanceService.getPreviousRegion().isSotetseg()
				|| (instanceService.getCurrentRegion().isMaiden() && instanceService.getPreviousRegion().isUnknown())))
			{
				return;
			}

			dataHandler.getData().clear();
			instanceService.setPreviousRegion(instanceService.getCurrentRegion());
		}

		if (((isInVerSinhaza() && config.lightUp()) || (isInSotetseg() && config.hideSotetsegWhiteScreen())) && !darknessHidden)
		{
			hideDarkness(true);
		}
		else if ((!isInVerSinhaza() && !isInSotetseg()) && darknessHidden)
		{
			hideDarkness(false);
		}

		if (isInVerSinhaza())
		{
			// Determine if chest has loot and draw an arrow overhead
			if (lootChest != null && Objects.requireNonNull(getObjectComposition(lootChest.getId())).getId() == RaidConstants.TOB_CHEST_UNLOOTED && !chestHasLoot)
			{
				chestHasLoot = true;
				if (config.lootReminder())
				{
					client.setHintArrow(lootChest.getWorldLocation());
				}
			}

			// Clear the arrow if the loot is taken
			if (lootChest != null && Objects.requireNonNull(getObjectComposition(lootChest.getId())).getId() == RaidConstants.TOB_CHEST_LOOTED && chestHasLoot)
			{
				chestHasLoot = false;
				client.clearHintArrow();
			}
		}
		else
		{
			if (lootChest != null)
			{
				lootChest = null;
			}
		}
	}

	@Subscribe
	private void onClientTick(ClientTick e)
	{
		if (client.getGameState() != GameState.LOGGED_IN || client.isMenuOpen())
		{
			return;
		}

		if (config.supplyChestMES() != SupplyChestPreference.OFF)
		{
			MenuEntry[] menuEntries = client.getMenuEntries();

			// Build option map for quick lookup in findIndex
			int index = 0;
			optionIndexes.clear();

			for (MenuEntry entry : menuEntries)
			{
				String option = Text.removeTags(entry.getOption());
				optionIndexes.put(option, index++);
			}

			// Perform swaps
			index = 0;

			for (MenuEntry entry : menuEntries)
			{
				swapMenuEntry(index++, entry);
			}
		}

		if (client.getGameState() == GameState.LOGGED_IN && !client.isMenuOpen() && config.bankAllMES() && (isInVerSinhaza() || isInLootRoom()))
		{
			MenuEntry[] entries = client.getMenuEntries();

			for (MenuEntry entry : entries)
			{
				if (entry.getOption().equals("Bank-all"))
				{
					entry.setForceLeftClick(true);
					break;
				}
			}

			client.setMenuEntries(entries);
		}
	}

	@Subscribe
	public void onGameObjectSpawned(GameObjectSpawned event)
	{
		switch (event.getGameObject().getId())
		{
			case RaidConstants.TOB_BANK_CHEST:
				lootChest = event.getGameObject();
				break;
			case RaidConstants.TOB_ENTRANCE:
				entrance = event.getGameObject();
				break;
		}
	}

	@Subscribe
	public void onGameStateChanged(GameStateChanged event)
	{
		if (event.getGameState() == GameState.HOPPING)
		{
			hideDarkness(false);
		}
	}

	@Subscribe
	public void onChatMessage(ChatMessage event)
	{
		if (instanceService.isInRaid() && event.getType().equals(ChatMessageType.GAMEMESSAGE) && event.getMessage().contains("You have failed. The vampyres take pity on you and allow you to try again."))
		{
			reset(false);
		}
	}

	@Nullable
	private ObjectComposition getObjectComposition(int id)
	{
		ObjectComposition objectComposition = client.getObjectDefinition(id);
		return objectComposition.getImpostorIds() == null ? objectComposition : objectComposition.getImpostor();
	}

	protected void hideDarkness(boolean hide)
	{
		Widget darkness = client.getWidget(28 << 16 | 1);
		if (darkness != null)
		{
			darknessHidden = hide;
			darkness.setHidden(hide);
		}
	}

	public boolean isInVerSinhaza()
	{
		return RaidConstants.VER_SINHAZA_REGIONS.contains(client.getLocalPlayer().getWorldLocation().getRegionID());
	}

	public boolean isInSotetseg()
	{
		LocalPoint local = LocalPoint.fromWorld(client, client.getLocalPlayer().getWorldLocation());
		int region = WorldPoint.fromLocalInstance(client, local).getRegionID();
		return region == Region.SOTETSEG.regionId() || region == Region.SOTETSEG_MAZE.regionId();
	}

	private boolean isInLootRoom()
	{
		LocalPoint local = LocalPoint.fromWorld(client, client.getLocalPlayer().getWorldLocation());
		return WorldPoint.fromLocalInstance(client, local).getRegionID() == 12867;
	}

	private void swapMenuEntry(int index, MenuEntry menuEntry)
	{
		final String option = Text.removeTags(menuEntry.getOption());
		final String target = Text.removeTags(menuEntry.getTarget());

		// Swap the "Value" option with "Buy-1" for the given target if it's not off
		if (option.equals("Value") && !config.supplyChestMES().toString().equals("Value"))
		{
			if (RaidConstants.TOB_CHEST_TARGETS.contains(target))
			{
				swap(option, target, index);
			}
		}
	}

	private void swap(String option, String target, int index)
	{
		MenuEntry[] menuEntries = client.getMenuEntries();

		int thisIndex = findIndex(menuEntries, index, option, target);
		int optionIdx = findIndex(menuEntries, thisIndex, config.supplyChestMES().toString(), target);

		if (thisIndex >= 0 && optionIdx >= 0)
		{
			swap(optionIndexes, menuEntries, optionIdx, thisIndex);
		}
	}

	private int findIndex(MenuEntry[] entries, int limit, String option, String target)
	{
		List<Integer> indexes = optionIndexes.get(option);

		// We want the last index which matches the target, as that is what is top-most on the menu
		for (int i = indexes.size() - 1; i >= 0; i--)
		{
			int index = indexes.get(i);
			MenuEntry entry = entries[index];
			String entryTarget = Text.removeTags(entry.getTarget());

			// Limit to the last index which is prior to the current entry
			if (index <= limit && entryTarget.equals(target))
			{
				return index;
			}
		}

		return -1;
	}

	private void swap(ArrayListMultimap<String, Integer> optionIndexes, MenuEntry[] entries, int index1, int index2)
	{
		MenuEntry entry = entries[index1];
		entries[index1] = entries[index2];
		entries[index2] = entry;

		client.setMenuEntries(entries);

		// Rebuild option indexes
		optionIndexes.clear();
		int idx = 0;
		for (MenuEntry menuEntry : entries)
		{
			String option = Text.removeTags(menuEntry.getOption());
			optionIndexes.put(option, idx++);
		}
	}

	private Font buildFont(boolean timer)
	{
		if (timer)
		{
			return instanceTimerFont = new Font(pluginFont.getName(), pluginFont.getStyle(), config.instanceTimerSize());
		}
		else
		{
			String font = null;
			int style = config.fontStyle().getValue();

			switch (config.fontType().getName())
			{
				case "RS Regular":
					font = FontManager.getRunescapeFont().getName();
					style = FontManager.getRunescapeFont().getStyle();
					break;

				case "RS Bold":
					font = FontManager.getRunescapeBoldFont().getName();
					style = FontManager.getRunescapeBoldFont().getStyle();
					break;

				case "RS Small":
					font = FontManager.getRunescapeSmallFont().getName();
					style = FontManager.getRunescapeSmallFont().getStyle();
					break;
			}

			return pluginFont = new Font(font == null ? config.fontStyle().getStyle() : font, style, font == null ? config.fontSize() : 16);
		}
	}

	public boolean hasSalve()
	{
		return containsSalve(client.getItemContainer(InventoryID.INVENTORY)) ||
				containsSalve(client.getItemContainer(InventoryID.EQUIPMENT));
	}

	private boolean containsSalve(ItemContainer container)
	{
		if (container != null)
		{
			int[] salveItemIds = {
					ItemID.SALVE_AMULET, ItemID.SALVE_AMULET_E, ItemID.SALVE_AMULETI,
					ItemID.SALVE_AMULETEI,ItemID.SALVE_AMULETEI_25278,ItemID.SALVE_AMULETEI_26782,
					ItemID.SALVE_AMULETI_25250, ItemID.SALVE_AMULETI_26763
			};

			for (int id : salveItemIds)
				if (container.contains(id))
					return true;
		}

		return false;
	}

	private static final int QUIVER_ITEM_COUNT = 4141;
	private static final int QUIVER_ITEM_ID = 4142;

	public boolean hasAmmo()
	{
		// Get quiver ammo details from VarPlayers
		final int quiverAmmoId = client.getVarpValue(VarPlayer.DIZANAS_QUIVER_ITEM_ID);
		final int quiverAmmoCount = client.getVarpValue(VarPlayer.DIZANAS_QUIVER_ITEM_COUNT);

		// Check the ammo slot in the equipment container
		ItemContainer equipment = client.getItemContainer(InventoryID.EQUIPMENT);
		if (equipment != null)
		{
			Item ammoItem = equipment.getItem(EquipmentInventorySlot.AMMO.getSlotIdx());
			if (ammoItem != null && ammoItem.getId() > -1)
			{
				return true; // Ammo is equipped
			}
		}

		// Check the quiver contents using VarPlayers
		int quiverItemId = client.getVarpValue(QUIVER_ITEM_ID);
		int quiverItemQuantity = client.getVarpValue(QUIVER_ITEM_COUNT);

		if (quiverItemId > -1 && quiverItemQuantity > 0)
		{
			return true; // Ammo is in the quiver
		}

		return false; // No ammo found in either slot
	}


	public String getSpellbook()
	{
		int spellbookId = client.getVarbitValue(4070);

		switch (spellbookId)
		{
			case 0: return "Standard";
			case 1: return "Ancient";
			case 2: return "Lunar";
			case 3: return "Arceuus";
			default: return "n/a";
		}
	}
}
/*
 * Copyright (c) 2022, Damen <gh: damencs>
 * Copyright (c) 2022, WLoumakis <gh: WLoumakis> - Portions of "Loot Reminder" and "MES Options"
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:

 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.

 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.

 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.tobqol;

import com.google.inject.Inject;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Point;
import net.runelite.client.ui.overlay.Overlay;
import net.runelite.client.ui.overlay.OverlayPosition;
import net.runelite.client.ui.overlay.OverlayPriority;
import net.runelite.client.ui.overlay.OverlayUtil;

import java.awt.*;

import static net.runelite.client.ui.overlay.OverlayUtil.renderTextLocation;

@Slf4j
public class TheatreQOLOverlay extends Overlay
{
    private final TheatreQOLPlugin plugin;
    private final TheatreQOLConfig config;

    @Inject
    private TheatreQOLOverlay(TheatreQOLPlugin plugin, TheatreQOLConfig config)
    {
        this.config = config;
        this.plugin = plugin;

        setPosition(OverlayPosition.DYNAMIC);
        setPriority(OverlayPriority.HIGH);
    }

    @Override
    public Dimension render(Graphics2D graphics)
    {
        graphics.setFont(plugin.getPluginFont());

        // Display Chest Loot Reminder
        if (config.lootReminder() && plugin.isInVerSinhaza() && plugin.getLootChest() != null && plugin.isChestHasLoot())
        {
            Shape poly = plugin.getLootChest().getConvexHull();

            if (poly != null)
            {
                OverlayUtil.renderPolygon(graphics, poly, config.lootReminderColor());
            }

            String text = "You have loot in your chest.";
            Point textLocation = plugin.getEntrance().getCanvasTextLocation(graphics, text, 0);

            if (textLocation != null)
            {
                renderTextLocation(graphics, new Point(textLocation.getX(), textLocation.getY()), text, config.lootReminderColor());
            }
        }

        // Display Salve Reminder
        if (config.salveReminder() && plugin.isInVerSinhaza() && !plugin.hasSalve())
        {
            String text = "You have forgotten your salve.";
            Point textLocation = plugin.getEntrance().getCanvasTextLocation(graphics, text, 60);

            if (textLocation != null)
            {
                renderTextLocation(graphics, new Point(textLocation.getX(), textLocation.getY()), text, Color.CYAN);
            }
        }

        // Display Current Spellbook
        if (config.spellbookReminder() && plugin.isInVerSinhaza())
        {
            String text = "Current Spellbook: " + plugin.getSpellbook().toUpperCase();
            Point textLocation = plugin.getEntrance().getCanvasTextLocation(graphics, text, 120);

            if (textLocation != null)
            {
                renderTextLocation(graphics, new Point(textLocation.getX(), textLocation.getY()), text, Color.YELLOW);
            }
        }

        // Display Ammo Reminder
        if (config.ammoReminder() && plugin.isInVerSinhaza() && !plugin.hasAmmo())
        {
            String text = "You have forgotten to equip ammo.";
            Point textLocation = plugin.getEntrance().getCanvasTextLocation(graphics, text, 180);

            if (textLocation != null)
            {
                renderTextLocation(graphics, new Point(textLocation.getX(), textLocation.getY()), text, config.ammoReminderColor());
            }
        }

        return null;
    }
}

/*
 * Copyright (c) 2022, Damen <gh: damencs>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:

 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.

 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.

 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.tobqol;

import com.tobqol.api.game.Instance;
import com.tobqol.api.game.Region;
import lombok.Getter;
import lombok.Setter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.Player;

import javax.annotation.Nullable;
import javax.inject.Inject;
import javax.inject.Singleton;
import java.util.HashSet;
import java.util.Objects;
import java.util.Set;
import java.util.function.Supplier;

@Slf4j
@Singleton
public final class InstanceService implements Instance
{
	private final Client client;
	private final TheatreQOLPlugin plugin;

	// Party Status (0=None, 1=In Party, 2=Inside/Spectator, 3=Dead Spectating)
	private int partyStatus = 0;
	private int roomStatus = 0;

	@Getter
	@Setter
	private int bossHealth = -1;

	@Setter
	private boolean preciseTimers = false;

	private Mode mode = null;
	private Region region = Region.UNKNOWN;

	private final Set<String> raiders = new HashSet<>();
	private final Set<String> deadRaiders = new HashSet<>();

	private boolean regionUpdated = false;
	private int tickCycle = -1;

	@Getter
	@Setter
	private Region previousRegion;

	@Inject
	InstanceService(Client client, TheatreQOLPlugin plugin)
	{
		this.client = client;
		this.plugin = plugin;
	}

	void reset()
	{
		region = Region.UNKNOWN;
		mode = null;
		regionUpdated = false;
		tickCycle = -1;
		deadRaiders.clear();
		raiders.clear();
		bossHealth = -1;
	}

	void tick()
	{
		if (regionUpdated && roomStatus == 0)
		{
			if (region.isLobby() || region.isLootRoom() || region.isUnknown())
			{
				regionUpdated = false;
				tickCycle = -1;
				return;
			}

			for (Player player : client.getTopLevelWorldView().players())
			{
				if (region.isPCIL(client, player))
				{
					log.debug("Updating Theatre of Blood instance timer for '{}'. Previous: {}, New: [2b, 3a]", region.next().prettyName(), tickCycle);
					regionUpdated = false;
					tickCycle = 2;
					break;
				}
			}
		}

		if (tickCycle == -1)
		{
			return;
		}

		tickCycle = ++tickCycle % 4;
	}

	boolean outside()
	{
		return partyStatus <= 1;
	}

	boolean limbo()
	{
		return outside() || roomStatus == 0;
	}

	void setPartyStatus(int value)
	{
		if (partyStatus == value)
		{
			return;
		}

		partyStatus = value;

		if (outside())
		{
			reset();
			plugin.reset(false);
		}
	}

	void setRoomStatus(int value)
	{
		if (roomStatus == value)
		{
			return;
		}

		roomStatus = value;

		if (value == 0)
		{
			deadRaiders.clear();
		}
	}

	void setRegion(Region region)
	{
		if (region == null)
		{
			return;
		}

		if ((this.region.isSotetseg() && !region.isSotetseg()) || this.region != region)
		{
			regionUpdated = true;
		}

		this.region = region;
	}

	void addRaider(String name)
	{
		if (raiders.contains(name))
		{
			return;
		}

		raiders.add(name);
	}

	void addDeadRaider(String name)
	{
		if (deadRaiders.contains(name))
		{
			return;
		}

		deadRaiders.add(name);
	}

	@Override
	public boolean lazySetMode(Supplier<Mode> modeSupplier)
	{
		if (mode != null || modeSupplier == null)
		{
			return false;
		}

		Mode nMode = modeSupplier.get();

		if (nMode == null || Objects.equals(mode, nMode))
		{
			return false;
		}

		log.debug("Setting Theatre of Blood instanced-mode. Previous: {}, New: {}", mode == null ? "UNKNOWN" : mode, nMode);
		mode = nMode;
		return true;
	}

	public boolean isInRaid()
	{
		return partyStatus == 2 || partyStatus == 3;
	}

	@Nullable
	@Override
	public Mode mode()
	{
		return mode;
	}

	@Override
	public boolean isStoryMode()
	{
		return mode != null && mode.isStoryMode();
	}

	@Override
	public boolean isRegularMode()
	{
		return mode != null && mode.isRegularMode();
	}

	@Override
	public boolean isHardMode()
	{
		return mode != null && mode.isHardMode();
	}

	@Override
	public Region getCurrentRegion()
	{
		return region;
	}

	@Override
	public int getRaidStatus()
	{
		return partyStatus;
	}

	@Override
	public int getRoomStatus()
	{
		return roomStatus;
	}

	@Override
	public int getPartyStatus()
	{
		return partyStatus;
	}

	@Override
	public int getPartySize()
	{
		return raiders.size();
	}

	@Override
	public int getDeathSize()
	{
		return deadRaiders.size();
	}

	@Override
	public int getTotalAlive()
	{
		return Math.max(getPartySize() - getDeathSize(), 0);
	}

	@Override
	public int getTickCycle()
	{
		return tickCycle;
	}

	@Override
	public void resetTickCycle()
	{
		tickCycle = -1;
	}
}

package com.tobqol;

import net.runelite.client.RuneLite;
import net.runelite.client.externalplugins.ExternalPluginManager;

public class ThreatreQOLTest
{
	public static void main(String[] args) throws Exception
	{
		ExternalPluginManager.loadBuiltin(TheatreQOLPlugin.class);
		RuneLite.main(args);
	}
}
