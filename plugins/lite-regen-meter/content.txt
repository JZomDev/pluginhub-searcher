package com.literegenmeter;

import net.runelite.client.RuneLite;
import net.runelite.client.externalplugins.ExternalPluginManager;

public class LiteRegenMeterPluginTest
{
	public static void main(String[] args) throws Exception
	{
		ExternalPluginManager.loadBuiltin(LiteRegenMeterPlugin.class);
		RuneLite.main(args);
	}
}
/*
 * Copyright (c) 2018, Raqes <j.raqes@gmail.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.literegenmeter.orbmeters;

import lombok.AllArgsConstructor;
import lombok.Getter;
import net.runelite.api.Prayer;
import net.runelite.api.SpriteID;

@AllArgsConstructor
@Getter
public enum PrayerType
{
	THICK_SKIN("Thick Skin", Prayer.THICK_SKIN, "+5% Defence", SpriteID.PRAYER_THICK_SKIN, false, 1),
	BURST_OF_STRENGTH("Burst of Strength", Prayer.BURST_OF_STRENGTH, "+5% Strength", SpriteID.PRAYER_BURST_OF_STRENGTH, false, 1),
	CLARITY_OF_THOUGHT("Clarity of Thought", Prayer.CLARITY_OF_THOUGHT, "+5% Attack", SpriteID.PRAYER_CLARITY_OF_THOUGHT, false, 1),
	SHARP_EYE("Sharp Eye", Prayer.SHARP_EYE, "+5% Ranged", SpriteID.PRAYER_SHARP_EYE, false, 1),
	MYSTIC_WILL("Mystic Will", Prayer.MYSTIC_WILL, "+5% Magical attack and defence", SpriteID.PRAYER_MYSTIC_WILL, false, 1),
	ROCK_SKIN("Rock Skin", Prayer.ROCK_SKIN, "+10% Defence", SpriteID.PRAYER_ROCK_SKIN, false, 6),
	SUPERHUMAN_STRENGTH("Superhuman Strength", Prayer.SUPERHUMAN_STRENGTH, "+10% Strength", SpriteID.PRAYER_SUPERHUMAN_STRENGTH, false, 6),
	IMPROVED_REFLEXES("Improved Reflexes", Prayer.IMPROVED_REFLEXES, "+10% Attack", SpriteID.PRAYER_IMPROVED_REFLEXES, false, 6),
	RAPID_RESTORE("Rapid Restore", Prayer.RAPID_RESTORE, "2 x Restore rate for all skills except Hitpoints and Prayer", SpriteID.PRAYER_RAPID_RESTORE, false, 1),
	RAPID_HEAL("Rapid Heal", Prayer.RAPID_HEAL, "2 x Restore rate for Hitpoints", SpriteID.PRAYER_RAPID_HEAL, false, 2),
	PROTECT_ITEM("Protect Item", Prayer.PROTECT_ITEM, "Player keeps 1 extra item when they die", SpriteID.PRAYER_PROTECT_ITEM, false, 2),
	HAWK_EYE("Hawk Eye", Prayer.HAWK_EYE, "+10% Ranged", SpriteID.PRAYER_HAWK_EYE, false, 6),
	MYSTIC_LORE("Mystic Lore", Prayer.MYSTIC_LORE, "+10% Magical attack and defence", SpriteID.PRAYER_MYSTIC_LORE, false, 6),
	STEEL_SKIN("Steel Skin", Prayer.STEEL_SKIN, "+15% Defence", SpriteID.PRAYER_STEEL_SKIN, false, 12),
	ULTIMATE_STRENGTH("Ultimate Strength", Prayer.ULTIMATE_STRENGTH, "+15% Strength", SpriteID.PRAYER_ULTIMATE_STRENGTH, false, 12),
	INCREDIBLE_REFLEXES("Incredible reflexes", Prayer.INCREDIBLE_REFLEXES, "+15% Attack", SpriteID.PRAYER_INCREDIBLE_REFLEXES, false, 12),
	PROTECT_FROM_MAGIC("protect from magic", Prayer.PROTECT_FROM_MAGIC, "Protects against magic attacks", SpriteID.PRAYER_PROTECT_FROM_MAGIC, true, 12),
	PROTECT_FROM_MISSILES("Protect from missiles", Prayer.PROTECT_FROM_MISSILES, "Protects against ranged attacks", SpriteID.PRAYER_PROTECT_FROM_MISSILES, true, 12),
	PROTECT_FROM_MELEE("Protect from melee", Prayer.PROTECT_FROM_MELEE, "Protects against melee attacks", SpriteID.PRAYER_PROTECT_FROM_MELEE, true, 12),
	EAGLE_EYE("Eagle Eye", Prayer.EAGLE_EYE, "+15% Ranged", SpriteID.PRAYER_EAGLE_EYE, false, 12),
	MYSTIC_MIGHT("Mystic Might", Prayer.MYSTIC_MIGHT, "+15% Magical attack and defence", SpriteID.PRAYER_MYSTIC_MIGHT, false, 12),
	RETRIBUTION("Retribution", Prayer.RETRIBUTION, "Deals damage up to 25% of your Prayer level to nearby targets upon the user's death", SpriteID.PRAYER_RETRIBUTION, true, 3),
	REDEMPTION("Redemption", Prayer.REDEMPTION, "Heals the player if they fall below 10% health", SpriteID.PRAYER_REDEMPTION, true, 6),
	SMITE("Smite", Prayer.SMITE, "Removes 1 Prayer point from an enemy for every 4 damage inflicted on the enemy", SpriteID.PRAYER_SMITE, true, 18),
	PRESERVE("Preserve", Prayer.PRESERVE, "Boosted stats last 50% longer", SpriteID.PRAYER_PRESERVE, false, 2),
	CHIVALRY("Chivalry", Prayer.CHIVALRY, "+15% Attack, +18% Strength, +20% Defence", SpriteID.PRAYER_CHIVALRY, false, 24),
	PIETY("Piety", Prayer.PIETY, "+20% Attack, +23% Strength, +25% Defence", SpriteID.PRAYER_PIETY, false, 24),
	RIGOUR("Rigour", Prayer.RIGOUR, "+20% Ranged attack, +23% Ranged strength, +25% Defence", SpriteID.PRAYER_RIGOUR, false, 24),
	AUGURY("Augury", Prayer.AUGURY, "+25% Magical attack and defence, +25% Defence", SpriteID.PRAYER_AUGURY, false, 24),

	RP_REJUVENATION("Rejuvenation", Prayer.RP_REJUVENATION, "3x Restore rate for Hitpoints", SpriteID.PRAYER_RP_REJUVENATION, false, 4),
	RP_ANCIENT_STRENGTH("Ancient Strength", Prayer.RP_ANCIENT_STRENGTH, "+20% Attack and Strength", SpriteID.PRAYER_RP_ANCIENT_STRENGTH, false, 18),
	RP_ANCIENT_SIGHT("Ancient Sight", Prayer.RP_ANCIENT_SIGHT, "+20% Ranged Attack & Strength", SpriteID.PRAYER_RP_ANCIENT_SIGHT, false, 18),
	RP_ANCIENT_WILL("Ancient Will", Prayer.RP_ANCIENT_WILL, "+20% Magic Attack", SpriteID.PRAYER_RP_ANCIENT_WILL, false, 18),
	RP_PROTECT_ITEM("Protect Item", Prayer.RP_PROTECT_ITEM, "Keep one extra item upon death", SpriteID.PRAYER_RP_PROTECT_ITEM, false, 18),
	RP_RUINOUS_GRACE("Ruinous Grace", Prayer.RP_RUINOUS_GRACE, "Prayer points are drained in place of run energy whilst running", SpriteID.PRAYER_RP_RUINOUS_GRACE, false, 1),
	RP_DAMPEN_MAGIC("Dampen Magic", Prayer.RP_DAMPEN_MAGIC, "100% protection from magic attacks (40% in PvP), but increases damage taken by 10%", SpriteID.PRAYER_RP_DAMPEN_MAGIC, true, 14),
	RP_DAMPEN_RANGE("Dampen Ranged", Prayer.RP_DAMPEN_RANGED, "100% protection from ranged attacks (40% in PvP), but increases damage taken by 10%", SpriteID.PRAYER_RP_DAMPEN_RANGED, true, 14),
	RP_DAMPEN_MELEE("Dampen Melee", Prayer.RP_DAMPEN_MELEE, "100% protection from melee attacks (40% in PvP), but increases damage taken by 10%", SpriteID.PRAYER_RP_DAMPEN_MELEE, true, 14),
	RP_TRINITAS("Trinitas", Prayer.RP_TRINITAS, "+15% Melee Attack and Strength, +15% Ranged Attack and Strength, and +15% Magic Attack", SpriteID.PRAYER_RP_TRINITAS, false, 22),
	RP_BERSERKER("Berserker", Prayer.RP_BERSERKER, "Boosted combat stats last 50% longer", SpriteID.PRAYER_RP_BERSERKER, false, 2),
	RP_PURGE("Purge", Prayer.RP_PURGE, "Reduces the player's and opponent's prayer points by 33% of damage dealt", SpriteID.PRAYER_RP_PURGE, true, 18),
	RP_METABOLISE("Metabolise", Prayer.RP_METABOLISE, "25 ticks (15 seconds) after activation, allows players to attack 1 tick earlier after eating a piece of food", SpriteID.PRAYER_RP_METABOLISE, false, 12),
	RP_REBUKE("Rebuke", Prayer.RP_REBUKE, "Increases recoil damage by 50%", SpriteID.PRAYER_RP_REBUKE, true, 12),
	RP_VINDICATION("Vindication", Prayer.RP_VINDICATION, "Heals the player by 25% of their base Prayer level if they fall below 10% health, draining their prayer points fully", SpriteID.PRAYER_RP_VINDICATION, true, 9),
	RP_DECIMATE("Decimate", Prayer.RP_DECIMATE, "+25% Attack, +27% Strength", SpriteID.PRAYER_RP_DECIMATE, false, 28),
	RP_ANNIHILATE("Annihilate", Prayer.RP_ANNIHILATE, "+25% Ranged Attack, +27% Ranged Strength", SpriteID.PRAYER_RP_ANNIHILATE, false, 28),
	RP_VAPORISE("Vaporise", Prayer.RP_VAPORISE, "+25% Magic Attack, +4% Magic Damage", SpriteID.PRAYER_RP_VAPORISE, false, 28),
	RP_FUMUS_VOW("Fumus' Vow", Prayer.RP_FUMUS_VOW, "Attacks that inflict poison will deal poison damage instantly", SpriteID.PRAYER_RP_FUMUS_VOW, false, 14),
	RP_UMBRAS_VOW("Umbra's Vow", Prayer.RP_UMBRA_VOW, "Attacks drain 5% of the opponent's Defence, up to 15% of their base level", SpriteID.PRAYER_RP_UMBRAS_VOW, false, 14),
	RP_CRUORS_VOW("Cruor's Vow", Prayer.RP_CRUORS_VOW, "Heals 3 Hitpoints and drains 3 Prayer points upon killing a target", SpriteID.PRAYER_RP_CRUORS_VOW, false, 14),
	RP_GLACIES_VOW("Glacies' Vow", Prayer.RP_GLACIES_VOW, "Attacks drain 5% of the opponent's Magic, up to 15% of their base level", SpriteID.PRAYER_RP_GLACIES_VOW, false, 14),
	RP_WRATH("Wrath", Prayer.RP_WRATH, "Upon death, deals damage up to 25% of the player's base Prayer level to targets in a 5x5 radius", SpriteID.PRAYER_RP_WRATH, false, 3),
	RP_INTENSIFY("Intensify", Prayer.RP_INTENSIFY, "+40% accuracy in all attack styles", SpriteID.PRAYER_RP_INTENSIFY, false, 28),
	;

	private final String name;
	private final Prayer prayer;
	private final String description;
	private final int spriteID;
	private final boolean overhead;
	private final int drainEffect;
}

/*
 * Copyright (c) 2024, Smoke (Smoked today) <https://github.com/Varietyz>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

package com.literegenmeter.orbmeters;

public enum LineThickness {
    SMALL(1, "Small"),
    MEDIUM(2, "Medium"),
    LARGE(3, "Large"),
    EXTRA_LARGE(4, "Extra Large");

    private final int value;
    private final String name;

    LineThickness(int value, String name) {
        this.value = value;
        this.name = name;
    }

    public int getValue() {
        return value;
    }

    public String getName() {
        return name;
    }
}

/*
 * Copyright (c) 2018, Tomas Slusny <slusnucky@gmail.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.literegenmeter.orbmeters;

import com.google.common.collect.ImmutableMap;
import net.runelite.api.ItemID;

import java.util.Map;

public enum PrayerRestoreType
{
	RESTOREPOT(ItemID.SUPER_RESTORE4, ItemID.SUPER_RESTORE3, ItemID.SUPER_RESTORE2, ItemID.SUPER_RESTORE1,
		ItemID.BLIGHTED_SUPER_RESTORE4, ItemID.BLIGHTED_SUPER_RESTORE3, ItemID.BLIGHTED_SUPER_RESTORE2,
		ItemID.BLIGHTED_SUPER_RESTORE1),
	PRAYERPOT(ItemID.PRAYER_POTION4, ItemID.PRAYER_POTION3, ItemID.PRAYER_POTION2, ItemID.PRAYER_POTION1),
	SANFEWPOT(ItemID.SANFEW_SERUM4, ItemID.SANFEW_SERUM3, ItemID.SANFEW_SERUM2, ItemID.SANFEW_SERUM1),
	HOLYWRENCH(ItemID.PRAYER_CAPE, ItemID.PRAYER_CAPET, ItemID.MAX_CAPE,
		ItemID.MAX_CAPE_13342, ItemID.HOLY_WRENCH, ItemID.RING_OF_THE_GODS_I);

	private static final Map<Integer, PrayerRestoreType> prayerRestores;

	private final int[] items;

	PrayerRestoreType(int... items)
	{
		this.items = items;
	}

	static
	{
		ImmutableMap.Builder<Integer, PrayerRestoreType> builder = new ImmutableMap.Builder<>();
		for (PrayerRestoreType prayerRestoreType : values())
		{
			for (int itemId : prayerRestoreType.items)
			{
				builder.put(itemId, prayerRestoreType);
			}
		}
		prayerRestores = builder.build();
	}

	public static PrayerRestoreType getType(final int itemId)
	{
		return prayerRestores.get(itemId);
	}
}

/*
 * Copyright (c) 2018, Tomas Slusny <slusnucky@gmail.com>
 * Copyright (c) 2018, Ron Young <https://github.com/raiyni>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.literegenmeter;

import lombok.Getter;
import lombok.RequiredArgsConstructor;
import net.runelite.client.game.SpriteOverride;

@Getter
@RequiredArgsConstructor
public enum LiteRegenSprites implements SpriteOverride
{
	HEART_POISON(-12991, "/vanilla-poison.png"),
	HEART_VENOM(-12992, "/vanilla-venom.png"),
	HEART_DISEASE(-12993, "/vanilla-disease.png"),
	LITE_HEART_POISON(-12994, "/lite-poison.png"),
	LITE_HEART_VENOM(-12995, "/lite-venom.png"),
	LITE_HEART_DISEASE(-12996, "/lite-disease.png");

	private final int spriteId;

	private final String fileName;

}

/*
 * Copyright (c) 2024, Smoke (Smoked today) <https://github.com/Varietyz>
 * Copyright (c) 2019, Jos <Malevolentdev@gmail.com>
 * Copyright (c) 2019, Rheon <https://github.com/Rheon-D>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.literegenmeter;

import java.awt.Color;
import java.awt.Graphics2D;
import java.awt.Image;
import java.awt.Point;
import java.util.function.Supplier;
import lombok.RequiredArgsConstructor;
import net.runelite.client.ui.FontManager;
import net.runelite.client.ui.overlay.components.TextComponent;

@RequiredArgsConstructor
class LiteStatBarsRenderer
{
	private static final Color BACKGROUND = new Color(23, 23, 23, 255);
	private static final Color OVERHEAL_COLOR = new Color(216, 255, 139, 150);
	private static final int SKILL_ICON_HEIGHT = 35;
	private static final int COUNTER_ICON_HEIGHT = 18;
	private static final int BORDER_SIZE = 1;
	private static final int MIN_ICON_AND_COUNTER_WIDTH = 17;
	static final int DEFAULT_WIDTH = 17;
	static final int MIN_WIDTH = 3;
	static final int MAX_WIDTH = 40;
	static final int DEFAULT_OPACITY = 65;
	static final int MIN_OPACITY = 0;
	static final int MAX_OPACITY = 100;
	private final Supplier<Integer> maxValueSupplier;
	private final Supplier<Integer> currentValueSupplier;
	private final Supplier<Integer> healSupplier;
	private final Supplier<Color> colorSupplier;
	private final Supplier<Color> healColorSupplier;
	private final Supplier<Image> iconSupplier;
	private int maxValue;
	private int currentValue;

	private void refreshSkills()
	{
		maxValue = maxValueSupplier.get();
		currentValue = currentValueSupplier.get();
	}

	/**
	 * Renders a status bar along with its restoration bar(s), icons and counters as appropriate
	 * @param config Plugin configuration which dictates certain settings, such as whether to show restoration bars and
	 *               whether or not to draw icons.
	 * @param graphics Graphics.
	 * @param x The location on the client where it will draw the bar on the x axis starting on the left side.
	 * @param y The location on the client where it will draw the bar on the y axis starting on the bottom side.
	 * @param height The height of the bar.
	 */
	void renderBar(LiteRegenMeterConfig config, Graphics2D graphics, int x, int y, int width, int height)
	{
		final int filledHeight = getBarHeight(maxValue, currentValue, height);
		final Color fill = colorSupplier.get();
		refreshSkills();

		int transparency = config.barTransparency();
		int alpha = (int) ((1 - (transparency / 100.0)) * 255);

		Color backgroundColorWithTransparency = new Color(BACKGROUND.getRed(), BACKGROUND.getGreen(), BACKGROUND.getBlue(), alpha);
		graphics.setColor(backgroundColorWithTransparency);

		graphics.drawRect(x, y, width - BORDER_SIZE, height - BORDER_SIZE);
		graphics.fillRect(x, y, width, height);

		Color fillColorWithTransparency = new Color(fill.getRed(), fill.getGreen(), fill.getBlue(), alpha);

		graphics.setColor(fillColorWithTransparency);
		graphics.fillRect(x + BORDER_SIZE,
				y + BORDER_SIZE + (height - filledHeight),
				width - BORDER_SIZE * 2,
				filledHeight - BORDER_SIZE * 2);

		if (config.enableRestorationBars())
		{
			renderRestore(graphics, x, y, width, height);
		}

		if (config.enableSkillIcon() || config.enableCounter())
		{
			renderIconsAndCounters(config, graphics, x, y, width);
		}
	}


	private void renderIconsAndCounters(LiteRegenMeterConfig config, Graphics2D graphics, int x, int y, int width)
	{
		if (width < MIN_ICON_AND_COUNTER_WIDTH)
		{
			return;
		}

		final boolean skillIconEnabled = config.enableSkillIcon();

		if (skillIconEnabled)
		{
			final Image icon = iconSupplier.get();
			final int xDraw = x + (width / 2) - (icon.getWidth(null) / 2);
			graphics.drawImage(icon, xDraw, y, null);
		}

		if (config.enableCounter())
		{
			graphics.setFont(FontManager.getRunescapeSmallFont());
			final String counterText = Integer.toString(currentValue);
			final int widthOfCounter = graphics.getFontMetrics().stringWidth(counterText);
			final int centerText = (width / 2) - (widthOfCounter / 2);
			final int yOffset = skillIconEnabled ? SKILL_ICON_HEIGHT : COUNTER_ICON_HEIGHT;

			final TextComponent textComponent = new TextComponent();
			textComponent.setText(counterText);
			textComponent.setPosition(new Point(x + centerText, y + yOffset));
			textComponent.render(graphics);
		}
	}

	private void renderRestore(Graphics2D graphics, int x, int y, int width, int height)
	{
		final Color color = healColorSupplier.get();
		final int heal = healSupplier.get();

		if (heal <= 0)
		{
			return;
		}

		final int filledCurrentHeight = getBarHeight(maxValue, currentValue, height);
		final int filledHealHeight = getBarHeight(maxValue, heal, height);
		final int fillY, fillHeight;
		graphics.setColor(color);

		if (filledHealHeight + filledCurrentHeight > height)
		{
			graphics.setColor(OVERHEAL_COLOR);
			fillY = y + BORDER_SIZE;
			fillHeight = height - filledCurrentHeight - BORDER_SIZE;
		}
		else
		{
			fillY = y + BORDER_SIZE + height - (filledCurrentHeight + filledHealHeight);
			fillHeight = filledHealHeight;
		}

		graphics.fillRect(x + BORDER_SIZE,
			fillY,
			width - BORDER_SIZE * 2,
			fillHeight);
	}

	private static int getBarHeight(int base, int current, int size)
	{
		final double ratio = (double) current / base;

		if (ratio >= 1)
		{
			return size;
		}

		return (int) Math.round(ratio * size);
	}
}

/*
 * Copyright (c) 2024, Smoke (Smoked today) <https://github.com/Varietyz>
 * Copyright (c) 2019, Sean Dewar <https://github.com/seandewar>
 * Copyright (c) 2018, Hydrox6 <ikada@protonmail.ch>
 * Copyright (c) 2018, Abex
 * Copyright (c) 2018, Zimaya <https://github.com/Zimaya>
 * Copyright (c) 2018, Jos <Malevolentdev@gmail.com>
 * Copyright (c) 2017, Adam <Adam@sigterm.info>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.literegenmeter;

import com.google.inject.Provides;
import java.awt.Color;
import java.awt.FontMetrics;
import java.awt.Graphics;
import java.awt.image.BufferedImage;
import java.text.MessageFormat;
import java.time.Duration;
import java.time.Instant;
import java.time.LocalTime;
import java.time.format.DateTimeFormatter;
import java.time.temporal.ChronoUnit;
import javax.annotation.Nullable;
import javax.inject.Inject;
import lombok.AccessLevel;
import lombok.Getter;
import lombok.Setter;
import net.runelite.api.Actor;
import net.runelite.api.Client;
import net.runelite.api.Constants;
import net.runelite.api.GameState;
import net.runelite.api.InventoryID;
import net.runelite.api.Item;
import net.runelite.api.ItemContainer;
import net.runelite.api.ItemID;
import net.runelite.api.NPC;
import net.runelite.api.Player;
import net.runelite.api.Prayer;
import net.runelite.api.Skill;
import net.runelite.api.SpriteID;
import net.runelite.api.VarPlayer;
import net.runelite.api.Varbits;
import net.runelite.api.events.GameStateChanged;
import net.runelite.api.events.GameTick;
import net.runelite.api.events.ItemContainerChanged;
import net.runelite.api.events.ScriptPostFired;
import net.runelite.api.events.VarbitChanged;
import net.runelite.api.widgets.Widget;
import net.runelite.client.Notifier;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.events.ConfigChanged;
import net.runelite.client.game.ItemManager;
import net.runelite.client.game.SpriteManager;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.plugins.PluginDependency;
import net.runelite.client.plugins.PluginDescriptor;
import net.runelite.client.plugins.itemstats.ItemStatPlugin;
import com.literegenmeter.orbmeters.*;
import net.runelite.client.ui.FontManager;
import net.runelite.client.ui.overlay.OverlayManager;
import net.runelite.client.ui.overlay.infobox.InfoBoxManager;
import net.runelite.client.util.ColorUtil;
import net.runelite.http.api.item.ItemStats;
import org.apache.commons.lang3.ArrayUtils;

@PluginDescriptor(
	name = "LITE Regen Meter",
	description = "Track Regen timers and display status orbs for any skill, adjusted to work with the RuneLITE theme by Smoke (Smoked today).",
	tags = {"combat", "health", "hitpoints", "special", "attack", "overlay", "notifications", "runelite", "theme", "smoke", "varietyz", "orb", "bar", "poison", "venom", "disease", "heart", "status", "calculate", "dose", "prayer", "skilling"},
	conflicts = {"Regeneration Meter", "Poison", "Status Bars"}
)
@PluginDependency(ItemStatPlugin.class)
public class LiteRegenMeterPlugin extends Plugin
{
	static final int POISON_TICK_MILLIS = 18200;
	static final int VENOM_THRESHOLD = 1000000;
	static final int VENOM_MAXIUMUM_DAMAGE = 20;
	private static final int SPEC_REGEN_TICKS = 50;
	private static final int NORMAL_HP_REGEN_TICKS = 100;

	private int HEART_ICON_ID = 10485776;
	private int HEART_SPRITE_ID = 1067;

	@Inject
	private Client client;

	@Inject
	private OverlayManager overlayManager;

	@Inject
	private Notifier notifier;

	@Inject
	private LitePrayerDoseOverlay doseOverlay;

	@Inject
	private LiteRegenMeterOverlay overlay;

	@Inject
	private LiteStatBarsOverlay statBarOverlay;

	@Inject
	private PoisonOverlay poisonOverlay;

	@Inject
	private LiteRegenMeterConfig config;

	@Inject
	private ClientThread clientThread;

	@Getter(AccessLevel.PACKAGE)
	private boolean prayersActive = false;

	@Getter(AccessLevel.PACKAGE)
	@Setter(AccessLevel.PACKAGE)
	private int prayerBonus;

	@Inject
	private ChatMessageManager chatMessageManager;

	@Inject
	private InfoBoxManager infoBoxManager;

	@Inject
	private SpriteManager spriteManager;

	@Inject
	private ConfigManager configManager;

	@Inject
	private ItemManager itemManager;

	@Getter
	private double hitpointsPercentage;

	@Getter
	private double specialPercentage;

	@Getter(AccessLevel.PACKAGE)
	private boolean barsDisplayed;

	@Getter
	private int lastDamage;
	private boolean envenomed;
	private PoisonInfobox infobox;
	private Instant poisonNaturalCure;
	private Instant nextPoisonTick;

	private int ticksSinceSpecRegen;
	private int ticksSinceHPRegen;
	private int lastCombatActionTickCount;

	private boolean wearingLightbearer;

	@Provides
	LiteRegenMeterConfig provideConfig(ConfigManager configManager)
	{
		return configManager.getConfig(LiteRegenMeterConfig.class);
	}

	@Override
	protected void startUp() throws Exception
	{
		clientThread.invokeLater(this::checkStatusBars);

		overlayManager.add(overlay);
		overlayManager.add(statBarOverlay);
		overlayManager.add(doseOverlay);
		overlayManager.add(poisonOverlay);

		spriteManager.addSpriteOverrides(LiteRegenSprites.values());

		if (client.getGameState() == GameState.LOGGED_IN)
		{
			clientThread.invoke(this::checkHealthIcon);
		}
	}

	@Override
	protected void shutDown() throws Exception
	{
		overlayManager.remove(overlay);
		overlayManager.remove(doseOverlay);
		overlayManager.remove(statBarOverlay);
		overlayManager.remove(poisonOverlay);

		spriteManager.removeSpriteOverrides(LiteRegenSprites.values());

		barsDisplayed = false;

		if (infobox != null)
		{
			infoBoxManager.removeInfoBox(infobox);
			infobox = null;
		}

		envenomed = false;
		lastDamage = 0;
		poisonNaturalCure = null;
		nextPoisonTick = null;

		clientThread.invoke(()-> resetHealthIcon(true));
	}

	@Subscribe
	private void onGameStateChanged(GameStateChanged ev)
	{
		if (ev.getGameState() == GameState.HOPPING || ev.getGameState() == GameState.LOGIN_SCREEN)
		{
			ticksSinceHPRegen = -2;
			ticksSinceSpecRegen = 0;
		}
	}

	@Subscribe
	public void onItemContainerChanged(ItemContainerChanged event)
	{
		final int id = event.getContainerId();
		if (id == InventoryID.INVENTORY.getId())
		{
			updatePotionBonus(event.getItemContainer(),
					client.getItemContainer(InventoryID.EQUIPMENT));
		}
		else if (id == InventoryID.EQUIPMENT.getId())
		{
			prayerBonus = totalPrayerBonus(event.getItemContainer().getItems());
		}

		if (event.getContainerId() != InventoryID.EQUIPMENT.getId())
		{
			return;
		}

		ItemContainer equipment = event.getItemContainer();
		final boolean hasLightbearer = equipment.contains(ItemID.LIGHTBEARER);
		if (hasLightbearer == wearingLightbearer)
		{
			return;
		}

		ticksSinceSpecRegen = Math.max(0, ticksSinceSpecRegen - 25);
		wearingLightbearer = hasLightbearer;
	}

	@Subscribe
	private void onVarbitChanged(VarbitChanged ev)
	{
		if (ev.getVarbitId() == Varbits.PRAYER_RAPID_HEAL)
		{
			ticksSinceHPRegen = 0;
		}
		if (ev.getVarpId() == VarPlayer.POISON)
		{
			final int poisonValue = ev.getValue();
			nextPoisonTick = Instant.now().plus(Duration.of(POISON_TICK_MILLIS, ChronoUnit.MILLIS));

			final int damage = nextDamage(poisonValue);
			this.lastDamage = damage;

			envenomed = poisonValue >= VENOM_THRESHOLD;

			if (poisonValue < VENOM_THRESHOLD)
			{
				poisonNaturalCure = Instant.now().plus(Duration.of(POISON_TICK_MILLIS * poisonValue, ChronoUnit.MILLIS));
			}
			else
			{
				poisonNaturalCure = null;
			}

			if (config.showInfoboxes())
			{
				if (infobox != null)
				{
					infoBoxManager.removeInfoBox(infobox);
					infobox = null;
				}

				if (damage > 0)
				{
					final BufferedImage image = getSplat(envenomed ? SpriteID.HITSPLAT_DARK_GREEN_VENOM : SpriteID.HITSPLAT_GREEN_POISON, damage);

					if (image != null)
					{
						infobox = new PoisonInfobox(image, this);
						infoBoxManager.addInfoBox(infobox);
					}
				}
			}

			checkHealthIcon();
		}
		else if (ev.getVarpId() == VarPlayer.DISEASE_VALUE)
		{
			checkHealthIcon();
		}
	}

	@Subscribe
	public void onGameTick(GameTick event)
	{
		final int ticksPerSpecRegen = wearingLightbearer ? SPEC_REGEN_TICKS / 2 : SPEC_REGEN_TICKS;
		checkStatusBars();

		if (client.getVarpValue(VarPlayer.SPECIAL_ATTACK_PERCENT) == 1000)
		{
			ticksSinceSpecRegen = 0;
		}
		else
		{
			ticksSinceSpecRegen = (ticksSinceSpecRegen + 1) % ticksPerSpecRegen;
		}
		specialPercentage = ticksSinceSpecRegen / (double) ticksPerSpecRegen;


		int ticksPerHPRegen = NORMAL_HP_REGEN_TICKS;
		if (client.isPrayerActive(Prayer.RAPID_HEAL))
		{
			ticksPerHPRegen /= 2;
		}

		ticksSinceHPRegen = (ticksSinceHPRegen + 1) % ticksPerHPRegen;
		hitpointsPercentage = ticksSinceHPRegen / (double) ticksPerHPRegen;

		int currentHP = client.getBoostedSkillLevel(Skill.HITPOINTS);
		int maxHP = client.getRealSkillLevel(Skill.HITPOINTS);
		if (currentHP == maxHP && !config.showWhenNoChange())
		{
			hitpointsPercentage = 0;
		}
		else if (currentHP > maxHP)
		{
			hitpointsPercentage = 1 - hitpointsPercentage;
		}

		if (config.getNotifyBeforeHpRegenSeconds() > 0 && currentHP < maxHP && shouldNotifyHpRegenThisTick(ticksPerHPRegen))
		{
			notifier.notify("Your next hitpoint will regenerate soon!");
		}

		if (config.showPrayerDoseIndicator())
		{
			doseOverlay.onTick();
		}

		if (!config.showInfoboxes())
		{
			infoBoxManager.removeInfoBox(infobox);
			infobox = null;
		}

		for (PrayerType prayerType : PrayerType.values())
		{
			Prayer prayer = prayerType.getPrayer();
			int ord = prayerType.ordinal();

			if (!client.isPrayerActive(prayer)) {
				continue;
			}

		}
	}

	@Subscribe
	public void onConfigChanged(ConfigChanged event)
	{
		if (!event.getGroup().equals(LiteRegenMeterConfig.GROUP))
		{
			return;
		}

		if(event.getKey().equals("hideAfterCombatDelay"))
		{
			clientThread.invokeLater(this::checkStatusBars);
		}

		if(event.getKey().equals("enableStatBars"))
		{
			clientThread.invokeLater(this::checkStatusBars);
		}

		if(event.getKey().equals("poisonIcon"))
		{
			clientThread.invokeLater(this::checkHealthIcon);
		}

		if(event.getKey().equals("packMode"))
		{
			clientThread.invokeLater(this::checkHealthIcon);
		}

	}

	private void checkStatusBars()
	{
		if (!config.enableStatBars())
		{
			barsDisplayed = false;
			return;
		}
		final Player localPlayer = client.getLocalPlayer();
		if (localPlayer == null)
		{
			return;
		}

		final Actor interacting = localPlayer.getInteracting();
		if (config.hideAfterCombatDelay() == 0)
		{
			barsDisplayed = true;
		}
		else if ((interacting instanceof NPC && ArrayUtils.contains(((NPC) interacting).getComposition().getActions(), "Attack"))
				|| (interacting instanceof Player && client.getVarbitValue(Varbits.PVP_SPEC_ORB) == 1))
		{
			lastCombatActionTickCount = client.getTickCount();
			barsDisplayed = true;
		}
		else if (client.getTickCount() - lastCombatActionTickCount >= config.hideAfterCombatDelay())
		{
			barsDisplayed = false;
		}
	}

	private boolean shouldNotifyHpRegenThisTick(int ticksPerHPRegen)
	{
		final int ticksBeforeHPRegen = ticksPerHPRegen - ticksSinceHPRegen;
		final int notifyTick = (int) Math.ceil(config.getNotifyBeforeHpRegenSeconds() * 1000d / Constants.GAME_TICK_LENGTH);
		return ticksBeforeHPRegen == notifyTick;
	}
	private int totalPrayerBonus(Item[] items)
	{
		int total = 0;
		for (Item item : items)
		{
			ItemStats is = itemManager.getItemStats(item.getId(), false);
			if (is != null && is.getEquipment() != null)
			{
				total += is.getEquipment().getPrayer();
			}
		}
		return total;
	}

	private void updatePotionBonus(ItemContainer inventory, @Nullable ItemContainer equip)
	{
		boolean hasPrayerPotion = false;
		boolean hasSuperRestore = false;
		boolean hasSanfew = false;
		boolean hasWrench = false;

		for (Item item : inventory.getItems())
		{
			final PrayerRestoreType type = PrayerRestoreType.getType(item.getId());

			if (type != null)
			{
				switch (type)
				{
					case PRAYERPOT:
						hasPrayerPotion = true;
						break;
					case RESTOREPOT:
						hasSuperRestore = true;
						break;
					case SANFEWPOT:
						hasSanfew = true;
						break;
					case HOLYWRENCH:
						hasWrench = true;
						break;
				}
			}
		}

		if (!hasWrench && equip != null)
		{
			for (Item item : equip.getItems())
			{
				final PrayerRestoreType type = PrayerRestoreType.getType(item.getId());
				if (type == PrayerRestoreType.HOLYWRENCH)
				{
					hasWrench = true;
					break;
				}
			}
		}

		final int prayerLevel = client.getRealSkillLevel(Skill.PRAYER);
		int restored = 0;
		if (hasSanfew)
		{
			restored = Math.max(restored, 4 + (int) Math.floor(prayerLevel *  (hasWrench ? .32 : .30)));
		}
		if (hasSuperRestore)
		{
			restored = Math.max(restored, 8 + (int) Math.floor(prayerLevel *  (hasWrench ? .27 : .25)));
		}
		if (hasPrayerPotion)
		{
			restored = Math.max(restored, 7 + (int) Math.floor(prayerLevel *  (hasWrench ? .27 : .25)));
		}

		doseOverlay.setRestoreAmount(restored);
	}

	private static int nextDamage(int poisonValue)
	{
		int damage;

		if (poisonValue >= VENOM_THRESHOLD)
		{
			poisonValue -= VENOM_THRESHOLD - 3;
			damage = poisonValue * 2;
			if (damage > VENOM_MAXIUMUM_DAMAGE)
			{
				damage = VENOM_MAXIUMUM_DAMAGE;
			}
		}
		else
		{
			damage = (int) Math.ceil(poisonValue / 5.0f);
		}

		return damage;
	}

	private static int getDrainEffect(Client client)
	{
		int drainEffect = 0;

		for (PrayerType prayerType : PrayerType.values())
		{
			if (client.isPrayerActive(prayerType.getPrayer()))
			{
				drainEffect += prayerType.getDrainEffect();
			}
		}

		return drainEffect;
	}

	String getEstimatedTimeRemaining(boolean formatForOrb)
	{
		final int drainEffect = getDrainEffect(client);

		if (drainEffect == 0)
		{
			return "N/A";
		}

		final int drainResistance = 2 * prayerBonus + 60;
		final double secondsPerPoint = 0.6 * ((double) drainResistance / drainEffect);

		final int currentPrayer = client.getBoostedSkillLevel(Skill.PRAYER);
		final double secondsLeft = (currentPrayer * secondsPerPoint);

		LocalTime timeLeft = LocalTime.ofSecondOfDay((long) secondsLeft);

		if (formatForOrb && (timeLeft.getHour() > 0 || timeLeft.getMinute() > 9))
		{
			long minutes = Duration.ofSeconds((long) secondsLeft).toMinutes();
			return String.format("%dm", minutes);
		}
		else if (timeLeft.getHour() > 0)
		{
			return timeLeft.format(DateTimeFormatter.ofPattern("H:mm:ss"));
		}
		else
		{
			return timeLeft.format(DateTimeFormatter.ofPattern("m:ss"));
		}
	}
	private BufferedImage getSplat(int id, int damage)
	{
		final BufferedImage rawSplat = spriteManager.getSprite(id, 0);
		if (rawSplat == null)
		{
			return null;
		}

		final BufferedImage splat = new BufferedImage(
				rawSplat.getColorModel(),
				rawSplat.copyData(null),
				rawSplat.getColorModel().isAlphaPremultiplied(),
				null);

		final Graphics g = splat.getGraphics();
		g.setFont(FontManager.getRunescapeSmallFont());

		final FontMetrics metrics = g.getFontMetrics();
		final String text = String.valueOf(damage);
		final int x = (splat.getWidth() - metrics.stringWidth(text)) / 2;
		final int y = (splat.getHeight() - metrics.getHeight()) / 2 + metrics.getAscent();

		g.setColor(Color.BLACK);
		g.drawString(String.valueOf(damage), x + 1, y + 1);
		g.setColor(Color.WHITE);
		g.drawString(String.valueOf(damage), x, y);
		return splat;
	}

	private static String getFormattedTime(Instant endTime)
	{
		final Duration timeLeft = Duration.between(Instant.now(), endTime);
		int seconds = (int) (timeLeft.toMillis() / 1000L);
		int minutes = seconds / 60;
		int secs = seconds % 60;

		return String.format("%d:%02d", minutes, secs);
	}

	String createTooltip()
	{
		String line1 = MessageFormat.format("Next {0} damage: {1}</br>Time until damage: {2}",
				envenomed ? "venom" : "poison", ColorUtil.wrapWithColorTag(String.valueOf(lastDamage), Color.RED), getFormattedTime(nextPoisonTick));
		String line2 = envenomed ? "" : MessageFormat.format("</br>Time until cure: {0}", getFormattedTime(poisonNaturalCure));

		return line1 + line2;
	}

	@Subscribe
	public void onScriptPostFired(ScriptPostFired event)
	{
		int ORBS_UPDATE_HEALTH = 446;
		if (event.getScriptId() == ORBS_UPDATE_HEALTH)
		{
			checkHealthIcon();
		}
	}

	private void checkHealthIcon()
	{
		if (!config.poisonIcon())
		{
			resetHealthIcon(false);
			return;
		}

		Widget hpIcon = client.getWidget(HEART_ICON_ID);

		if (hpIcon != null)
		{
			int STATUS_ICON_ID;
			int xOffset;
			boolean isVanilla = configManager.getConfiguration(LiteRegenMeterConfig.GROUP, "packMode").equals("VANILLA");

			final int poison = client.getVarpValue(VarPlayer.POISON);

			if (poison >= VENOM_THRESHOLD)
			{
				STATUS_ICON_ID = isVanilla ? LiteRegenSprites.HEART_VENOM.getSpriteId() : LiteRegenSprites.LITE_HEART_VENOM.getSpriteId();
				xOffset = getHealthIconXOffset();
			}
			else if (poison > 0)
			{
				STATUS_ICON_ID = isVanilla ? LiteRegenSprites.HEART_POISON.getSpriteId() : LiteRegenSprites.LITE_HEART_POISON.getSpriteId();
				xOffset = getHealthIconXOffset();
			}
			else if (client.getVarpValue(VarPlayer.DISEASE_VALUE) > 0)
			{
				STATUS_ICON_ID = isVanilla ? LiteRegenSprites.HEART_DISEASE.getSpriteId() : LiteRegenSprites.LITE_HEART_DISEASE.getSpriteId();
				xOffset = getHealthIconXOffset();
			}
			else
			{
				resetHealthIcon(false);
				return;
			}

			hpIcon.setSpriteId(STATUS_ICON_ID);
			hpIcon.setOriginalX(27 - xOffset);
			hpIcon.revalidate();
		}
	}

	private void resetHealthIcon(boolean shutdown)
	{
		Widget hpIcon = client.getWidget(HEART_ICON_ID);
		if (hpIcon != null)
		{
			if (hpIcon.getSpriteId() != HEART_SPRITE_ID)
				hpIcon.setSpriteId(HEART_SPRITE_ID);

			hpIcon.setOriginalX(27);
			hpIcon.revalidate();
		}
	}

	private int getHealthIconXOffset()
	{
		return configManager.getConfiguration(LiteRegenMeterConfig.GROUP, "packMode").equals("VANILLA") ? 0 : 4;
	}
}

/*
 * Copyright (c) 2024, Smoke (Smoked today) <https://github.com/Varietyz>
 * Copyright (c) 2019, Jos <Malevolentdev@gmail.com>
 * Copyright (c) 2018 Abex
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.literegenmeter;

import java.awt.Color;
import net.runelite.client.config.Alpha;
import net.runelite.client.config.Config;
import net.runelite.client.config.ConfigGroup;
import net.runelite.client.config.ConfigItem;
import net.runelite.client.config.ConfigSection;
import net.runelite.client.config.Range;
import net.runelite.client.config.Units;
import com.literegenmeter.config.LiteStatBarsMode;
import com.literegenmeter.orbmeters.LineThickness;

@ConfigGroup(LiteRegenMeterConfig.GROUP)
public interface LiteRegenMeterConfig extends Config
{
	String GROUP = "literegenmeter";

	@ConfigSection(
		name = "Display (Regen Meters)",
		description = "Choose to display the regen meters.",
		position = 3
	)
	String RegenMeterDisplaySettingsSection = "RegenMeterDisplaySettings";

	@ConfigSection(
		name = "Display (Stat Bars)",
		description = "Choose to display the stat bars.",
		position = 6
	)
	String MainBarSettingsSection = "MainBarSettings";

	@ConfigSection(
		name = "Settings (Regen Meters)",
		description = "Configuration for the regen meters.",
		position = 4
	)
	String RegenMeterSettingsSection = "RegenMeterSettings";
	@ConfigSection(
		name = "Settings (Stat Bars)",
		description = "Configuration for the stat bars.",
		position = 7
	)
	String MainSettingsSection = "MainSettings";
	@ConfigSection(
		name = "Colors (Regen Meters)",
		description = "Setup the colors for the regen meters.",
		position = 5,
		closedByDefault = true
	)
	String RegenMeterColorSettingsSection = "RegenMeterColorSettings";
	@ConfigSection(
		name = "HP Colors (Stat Bars)",
		description = "Configuration for health color options.",
		position = 8,
		closedByDefault = true
	)
	String HPColorSettingsSection = "HPColorSettings";

	@ConfigSection(
		name = "Prayer Colors (Stat Bars)",
		description = "Configuration for prayer color options.",
		position = 9,
		closedByDefault = true
	)
	String PrayerColorSettingsSection = "PrayerColorSettings";

	@ConfigSection(
		name = "Energy Colors (Stat Bars)",
		description = "Configuration for prayer color options.",
		position = 10,
		closedByDefault = true
	)
	String EnergyColorSettingsSection = "EnergyColorSettings";

	@ConfigSection(
		name = "Special Colors (Stat Bars)",
		description = "Configuration for special color options.",
		position = 11,
		closedByDefault = true
	)
	String SpecialColorSettingsSection = "SpecialColorSettings";

	@ConfigSection(
		name = "Combat Skill Colors (Stat Bars)",
		description = "Configuration for combat skill color options.",
		position = 12,
		closedByDefault = true
	)
	String CombatColorSettingsSection = "CombatColorSettings";

	@ConfigSection(
		name = "Skill Colors (Stat Bars)",
		description = "Configuration for skill color options.",
		position = 13,
		closedByDefault = true
	)
	String SkillColorSettingsSection = "SkillColorSettings";

	@ConfigItem(
		keyName = "showHitpoints",
		name = "HP Regen",
		description = "Enables a regeneration meter below the hitpoints orb to indicate hitpoint recovery.",
		position = 0,
		section = RegenMeterDisplaySettingsSection
	)
	default boolean showHitpoints()
	{
		return true;
	}
	@ConfigItem(
		keyName = "showWhenNoChange",
		name = "Always Show HP Regen",
		description = "Displays the hitpoints regeneration meter even when the hitpoints are full and there is no change.",
		position = 1,
		section = RegenMeterDisplaySettingsSection
	)
	default boolean showWhenNoChange()
	{
		return false;
	}
	@ConfigItem(
		keyName = "showPrayerDoseIndicator",
		name = "Prayer Dose Indicator",
		description = "Enables the prayer dose indicator.",
		position = 2,
		section = RegenMeterDisplaySettingsSection
	)
	default boolean showPrayerDoseIndicator()
	{
		return true;
	}
	@ConfigItem(
		keyName = "showSpecial",
		name = "Spec. Attack Regen",
		description = "Enables a regeneration meter below the Special Attack orb to indicate special attack recovery.",
		position = 3,
		section = RegenMeterDisplaySettingsSection
	)
	default boolean showSpecial()
	{
		return true;
	}

	@ConfigItem(
		position = 1,
		keyName = "leftBarMode",
		name = "Top Left",
		description = "Configures the top left status bar.",
		section = MainBarSettingsSection
	)
	default LiteStatBarsMode leftBarMode()
	{
		return LiteStatBarsMode.HITPOINTS;
	}
	@ConfigItem(
		position = 3,
		keyName = "rightBarMode",
		name = "Top Right",
		description = "Configures the top right status bar.",
		section = MainBarSettingsSection
	)
	default LiteStatBarsMode rightBarMode()
	{
		return LiteStatBarsMode.SPECIAL_ATTACK;
	}
	@ConfigItem(
		position = 2,
		keyName = "LeftBarMode2",
		name = "Bottom Left",
		description = "Configures the bottom left status bar.",
		section = MainBarSettingsSection
	)
	default LiteStatBarsMode LeftBarMode2()
	{
		return LiteStatBarsMode.PRAYER;
	}
	@ConfigItem(
		position = 4,
		keyName = "RightBarMode2",
		name = "Bottom Right",
		description = "Configures the bottom right status bar.",
		section = MainBarSettingsSection
	)
	default LiteStatBarsMode RightBarMode2()
	{
		return LiteStatBarsMode.DISABLED;
	}

	@ConfigItem(
		keyName = "poisonIcon",
		name = "Poison Icon",
		description = "Configures the hp orb icon to change color for matching poisoned/diseased.",
		section = RegenMeterSettingsSection,
		position = 0
	)
	default boolean poisonIcon()
	{
		return true;
	}
	@ConfigItem(
		keyName = "notifyBeforeHpRegenDuration",
		name = "HP Regen Notification",
		description = "Sets a notification time (in seconds) before the next hitpoint regeneration occurs. A value of 0 disables notifications.",
		position = 5,
		section = RegenMeterSettingsSection
	)
	@Units(Units.SECONDS)
	default int getNotifyBeforeHpRegenSeconds()
	{
		return 0;
	}
	@ConfigItem(
		keyName = "showBackdrops",
		name = "Show Backdrops",
		description = "Enables or disables the display of the backdrop behind the regeneration meters.",
		position = 0,
		section = RegenMeterSettingsSection
	)
	default boolean showBackdrops()
	{
		return true; // Default value to show backdrops
	}
	@ConfigItem(
		keyName = "lineThickness",
		name = "Line Thickness",
		description = "Sets the thickness of the regeneration meters.",
		position = 1,
		section = RegenMeterSettingsSection
	)
	@Units(Units.PIXELS)
	default LineThickness getLineThickness() {
		return LineThickness.MEDIUM; // Default thickness
	}
	@ConfigItem(
		keyName = "barWidth",
		name = "Bar Width",
		description = "Choose the width of the regeneration meters.",
		position = 4,
		section = RegenMeterSettingsSection
	)
	default BarWidth getBarWidth() {
		return BarWidth.WIDER; // Default width
	}
	@ConfigItem(
		keyName = "barXPosition",
		name = "Meter Position",
		description = "Choose the position of the regeneration meters.",
		position = 3,
		section = RegenMeterSettingsSection
	)
	default BarXPosition barXPosition() {
		return BarXPosition.LEFT; // Default position
	}
	@ConfigItem(
		keyName = "barYPosition",
		name = "Meter Attach (LITE)",
		description = "Choose to attach or detach the regeneration meters.",
		position = 2,
		section = RegenMeterSettingsSection
	)
	default BarYPosition barYPosition() {
		return BarYPosition.DETACHED; // Default position
	}

	@ConfigItem(
		position = 3,
		keyName = "enableRestorationBars",
		name = "Restoration Amount",
		description = "Visually shows how much will be restored to your status bar.",
		section = MainSettingsSection
	)
	default boolean enableRestorationBars()
	{
		return true;
	}
	@ConfigItem(
		position = 4,
		keyName = "enableCounter",
		name = "Numeric Counters",
		description = "Shows current value of the status on the bar.",
		section = MainSettingsSection
	)
	default boolean enableCounter()
	{
		return false;
	}
	@ConfigItem(
		position = 5,
		keyName = "enableSkillIcon",
		name = "Icons",
		description = "Adds skill icons at the top of the bars.",
		section = MainSettingsSection
	)
	default boolean enableSkillIcon()
	{
		return true;
	}
	@ConfigItem(
		position = 2,
		keyName = "hideAfterCombatDelay",
		name = "Hide After",
		description = "(0 = always show) Amount of ticks before hiding status bars after combat.",
		section = MainSettingsSection
	)
	@Units(Units.TICKS)
	default int hideAfterCombatDelay()
	{
		return 0;
	}
	@Range(
		min = LiteStatBarsRenderer.MIN_WIDTH,
		max = LiteStatBarsRenderer.MAX_WIDTH
	)
	@ConfigItem(
		position = 1,
		keyName = "statbarWidth",
		name = "Width (resize/modern)",
		description = "The width of the status bars in the modern resizeable layout.",
		section = MainSettingsSection
	)
	default int statbarWidth()
	{
		return LiteStatBarsRenderer.DEFAULT_WIDTH;
	}
	@Range(
		min = LiteStatBarsRenderer.MIN_OPACITY,
		max = LiteStatBarsRenderer.MAX_OPACITY
	)
	@ConfigItem(
		position = 0,
		keyName = "barTransparency",
		name = "Transparency (%)",
		description = "Set the transparency of the status bars (0 - opaque, 100 - transparent).",
		section = MainSettingsSection
	)
	default int barTransparency()
	{
		return LiteStatBarsRenderer.DEFAULT_OPACITY;

	}
	@ConfigItem(
		keyName = "showInfoboxes",
		name = "Show Poison Timers",
		description = "Configures the poison/disease/venom timer infoboxes and tooltips to show.",
		section = MainSettingsSection,
		position = 6
	)
	default boolean showInfoboxes()
	{
		return false;
	}


	@Alpha
	@ConfigItem(
		keyName = "hitpointsColor",
		name = "HP Meter",
		description = "Color of the hitpoints regeneration meters.",
		position = 0,
		section = RegenMeterColorSettingsSection
	)
	default Color getHitpointsColor()
	{
		return Color.RED; // Default color
	}
	@Alpha
	@ConfigItem(
		keyName = "prayerDoseOrbStartColor",
		name = "Prayer Dose Indicator",
		description = "Color of the flashing meter underneath the orb when a potion should be drank",
		position = 1,
		section = RegenMeterColorSettingsSection
	)
	default Color prayerDoseOrbStartColor()
	{

		return Color.CYAN;
	}
	@Alpha
	@ConfigItem(
		keyName = "specialColor",
		name = "Spec. Attack Meter",
		description = "Color of the special attack regeneration meters.",
		position = 2,
		section = RegenMeterColorSettingsSection
	)
	default Color getSpecialColor()
	{
		return Color.ORANGE; // Default color
	}
	@Alpha
	@ConfigItem(
		keyName = "backdropColor",
		name = "Fill Area",
		description = "Color of the backdrop that represents the area to fill the regeneration meters.",
		position = 3,
		section = RegenMeterColorSettingsSection
	)
	default Color getBackdropColor()
	{
		return new Color(0x505050); // Default backdrop color
	}

	@ConfigItem(
		position = 1,
		keyName = "prayerColor",
		name = "Prayer",
		description = "Color for the Prayer bar.",
		section = PrayerColorSettingsSection
	)
	default Color prayerColor() {
		return new Color(50, 200, 200);
	}

	@ConfigItem(
		position = 2,
		keyName = "activePrayerColor",
		name = "Prayer (active)",
		description = "Color for the Active Prayer bar.",
		section = PrayerColorSettingsSection
	)
	default Color activePrayerColor() {
		return new Color(57, 255, 186);
	}

	@ConfigItem(
		position = 3,
		keyName = "prayerHealColor",
		name = "Recharge Volume",
		description = "Color for the Prayer Recharge volume.",
		section = PrayerColorSettingsSection
	)
	default Color prayerHealColor() {
		return new Color(200, 200, 200);
	}

	@ConfigItem(
		position = 1,
		keyName = "healthColor",
		name = "Hitpoints",
		description = "Color for the Health bar.",
		section = HPColorSettingsSection
	)
	default Color healthColor() {
		return new Color(225, 35, 0);
	}

	@ConfigItem(
		position = 2,
		keyName = "healColor",
		name = "Recharge Volume",
		description = "Color for the HP Recharge volume.",
		section = HPColorSettingsSection
	)
	default Color healColor() {
		return new Color(255, 112, 6);
	}

	@ConfigItem(
		position = 3,
		keyName = "poisonedColor",
		name = "Poisoned",
		description = "Color for the Poisoned bar.",
		section = HPColorSettingsSection
	)
	default Color poisonedColor() {
		return new Color(0, 145, 0);
	}

	@ConfigItem(
		position = 4,
		keyName = "venomedColor",
		name = "Venomed",
		description = "Color for the Venomed bar.",
		section = HPColorSettingsSection
	)
	default Color venomedColor() {
		return new Color(0, 65, 0);
	}

	@ConfigItem(
		position = 1,
		keyName = "energyColor",
		name = "Run Energy",
		description = "Color for the Run Energy bar.",
		section = EnergyColorSettingsSection
	)
	default Color energyColor() {
		return new Color(199, 174, 0);
	}
	@ConfigItem(
		position = 2,
		keyName = "energyHealColor",
		name = "Recharge Volume",
		description = "Color for the Run Energy Recharge volume.",
		section = EnergyColorSettingsSection
	)
	default Color energyHealColor() {
		return new Color(199, 118, 0);
	}
	@ConfigItem(
		position = 3,
		keyName = "runStaminaColor",
		name = "Stamina Pot (active)",
		description = "Color for the Stamina potion bar.",
		section = EnergyColorSettingsSection
	)
	default Color runStaminaColor() {
		return new Color(160, 124, 72);
	}

	@ConfigItem(
		position = 1,
		keyName = "specialAttackColor",
		name = "Spec. Attack",
		description = "Color for the Special Attack bar.",
		section = SpecialColorSettingsSection
	)
	default Color specialAttackColor() {
		return new Color(3, 153, 0);
	}

	@ConfigItem(
		position = 2,
		keyName = "diseaseColor",
		name = "Disease",
		description = "Color for the Disease bar.",
		section = SpecialColorSettingsSection
	)
	default Color diseaseColor() {
		return new Color(255, 193, 75);
	}

	@ConfigItem(
		position = 3,
		keyName = "parasiteColor",
		name = "Parasite",
		description = "Color for the Parasite bar.",
		section = SpecialColorSettingsSection
	)
	default Color parasiteColor() {
		return new Color(196, 62, 109);
	}

	@ConfigItem(
		position = 23,
		keyName = "attackColor",
		name = "Attack",
		description = "Color for the Attack bar.",
		section = CombatColorSettingsSection
	)
	default Color attackColor() {
		return new Color(255, 0, 0);
	}

	@ConfigItem(
		position = 24,
		keyName = "defenceColor",
		name = "Defence",
		description = "Color for the Defence bar.",
		section = CombatColorSettingsSection
	)
	default Color defenceColor() {
		return new Color(0, 0, 255);
	}

	@ConfigItem(
		position = 25,
		keyName = "strengthColor",
		name = "Strength",
		description = "Color for the Strength bar.",
		section = CombatColorSettingsSection
	)
	default Color strengthColor() {
		return new Color(0, 255, 0);
	}

	@ConfigItem(
		position = 26,
		keyName = "rangedColor",
		name = "Ranged",
		description = "Color for the Ranged bar.",
		section = CombatColorSettingsSection
	)
	default Color rangedColor() {
		return new Color(255, 165, 0);
	}

	@ConfigItem(
		position = 27,
		keyName = "magicColor",
		name = "Magic",
		description = "Color for the Magic bar.",
		section = CombatColorSettingsSection
	)
	default Color magicColor() {
		return new Color(128, 0, 128);
	}

	@ConfigItem(
		position = 28,
		keyName = "cookingColor",
		name = "Cooking",
		description = "Color for the Cooking bar.",
		section = SkillColorSettingsSection
	)
	default Color cookingColor() {
		return new Color(255, 228, 196);
	}

	@ConfigItem(
		position = 29,
		keyName = "woodcuttingColor",
		name = "Woodcutting",
		description = "Color for the Woodcutting bar.",
		section = SkillColorSettingsSection
	)
	default Color woodcuttingColor() {
		return new Color(34, 139, 34);
	}

	@ConfigItem(
		position = 30,
		keyName = "fletchingColor",
		name = "Fletching",
		description = "Color for the Fletching bar.",
		section = SkillColorSettingsSection
	)
	default Color fletchingColor() {
		return new Color(210, 105, 30);
	}

	@ConfigItem(
		position = 31,
		keyName = "fishingColor",
		name = "Fishing",
		description = "Color for the Fishing bar.",
		section = SkillColorSettingsSection
	)
	default Color fishingColor() {
		return new Color(135, 206, 235);
	}

	@ConfigItem(
		position = 32,
		keyName = "firemakingColor",
		name = "Firemaking",
		description = "Color for the Firemaking bar.",
		section = SkillColorSettingsSection
	)
	default Color firemakingColor() {
		return new Color(255, 99, 71);
	}

	@ConfigItem(
		position = 33,
		keyName = "craftingColor",
		name = "Crafting",
		description = "Color for the Crafting bar.",
		section = SkillColorSettingsSection
	)
	default Color craftingColor() {
		return new Color(173, 216, 230);
	}

	@ConfigItem(
		position = 34,
		keyName = "smithingColor",
		name = "Smithing",
		description = "Color for the Smithing bar.",
		section = SkillColorSettingsSection
	)
	default Color smithingColor() {
		return new Color(128, 128, 128);
	}

	@ConfigItem(
		position = 35,
		keyName = "miningColor",
		name = "Mining",
		description = "Color for the Mining bar.",
		section = SkillColorSettingsSection
	)
	default Color miningColor() {
		return new Color(0, 255, 255);
	}

	@ConfigItem(
		position = 36,
		keyName = "herbloreColor",
		name = "Herblore",
		description = "Color for the Herblore bar.",
		section = SkillColorSettingsSection
	)
	default Color herbloreColor() {
		return new Color(255, 20, 147);
	}

	@ConfigItem(
		position = 37,
		keyName = "agilityColor",
		name = "Agility",
		description = "Color for the Agility bar.",
		section = SkillColorSettingsSection
	)
	default Color agilityColor() {
		return new Color(255, 140, 0);
	}

	@ConfigItem(
		position = 38,
		keyName = "thievingColor",
		name = "Thieving",
		description = "Color for the Thieving bar.",
		section = SkillColorSettingsSection
	)
	default Color thievingColor() {
		return new Color(153, 50, 204);
	}

	@ConfigItem(
		position = 39,
		keyName = "slayerColor",
		name = "Slayer",
		description = "Color for the Slayer bar.",
		section = SkillColorSettingsSection
	)
	default Color slayerColor() {
		return new Color(0, 191, 255);
	}

	@ConfigItem(
		position = 40,
		keyName = "farmingColor",
		name = "Farming",
		description = "Color for the Farming bar.",
		section = SkillColorSettingsSection
	)
	default Color farmingColor() {
		return new Color(154, 205, 50);
	}

	@ConfigItem(
		position = 41,
		keyName = "runecraftColor",
		name = "Runecrafting",
		description = "Color for the Runecrafting bar.",
		section = SkillColorSettingsSection
	)
	default Color runecraftColor() {
		return new Color(186, 85, 211);
	}

	@ConfigItem(
		position = 42,
		keyName = "hunterColor",
		name = "Hunter",
		description = "Color for the Hunter bar.",
		section = SkillColorSettingsSection
	)
	default Color hunterColor() {
		return new Color(255, 228, 181);
	}

	@ConfigItem(
		position = 43,
		keyName = "constructionColor",
		name = "Construction",
		description = "Color for the Construction bar.",
		section = SkillColorSettingsSection
	)
	default Color constructionColor() {
		return new Color(139, 69, 19);
	}

	@ConfigItem(
		keyName = "packMode",
		name = "Theme",
		description = "Switch between Vanilla and RuneLITE functionality!",
		position = 0
	)
	default PackMode packMode()
	{
		return PackMode.VANILLA;
	}
	@ConfigItem(
		position = 1,
		keyName = "enableStatBars",
		name = "Enable Stat Bars",
		description = "Enables/Disables status bars."
	)
	default boolean enableStatBars()
	{
		return true;
	}
	@ConfigItem(
		position = 1,
		keyName = "enableRegenMeters",
		name = "Enable Regen Meters",
		description = "Enables/Disables regeneration Meters."
	)
	default boolean enableRegenMeters()
	{
		return true;
	}

	@ConfigItem(
		keyName = "statBarLocation",
		name = "Location (resize/modern)",
		description = "Set the location of the stat bars when resized: Left, inside or Right",
		position = 1,
		section = MainSettingsSection
	)
	default LocationType statBarLocation()
	{
		return LocationType.LEFT_SIDE;
	}

	public enum BarXPosition {
		LEFT,
		MIDDLE,
		RIGHT
	}

	public enum BarYPosition {
		ATTACHED,
		DETACHED
	}

	public enum BarWidth {
		NORMAL,
		WIDER;
	}

	public enum PackMode
	{
		VANILLA,
		RUNELITE;

		@Override
		public String toString() {
			switch (this) {
				case VANILLA:
					return "Vanilla";
				case RUNELITE:
					return "RuneLITE";
				default:
					return super.toString();
			}
		}
	}
	public enum LocationType
	{
		LEFT_SIDE,
		INSIDE,
		RIGHT_SIDE;
		@Override
		public String toString() {
			switch (this) {
				case LEFT_SIDE:
					return "Left";
				case INSIDE:
					return "Inner";
				case RIGHT_SIDE:
					return "Right";
				default:
					return super.toString();
			}
		}
	}
}

/*
 * Copyright (c) 2024, Smoke (Smoked today) <https://github.com/Varietyz>
 * Copyright (c) 2019, Jos <Malevolentdev@gmail.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.literegenmeter.config;

public enum LiteStatBarsMode
{
	DISABLED,
	HITPOINTS,
	PRAYER,
	RUN_ENERGY,
	SPECIAL_ATTACK,
	ATTACK,
	DEFENCE,
	STRENGTH,
	RANGED,
	MAGIC,
	COOKING,
	WOODCUTTING,
	FLETCHING,
	FISHING,
	FIREMAKING,
	CRAFTING,
	SMITHING,
	MINING,
	HERBLORE,
	AGILITY,
	THIEVING,
	SLAYER,
	FARMING,
	RUNECRAFT,
	HUNTER,
	CONSTRUCTION;
}

/*
 * Copyright (c) 2024, Smoke (Smoked today) <https://github.com/Varietyz>
 * Copyright (c) 2019, Jos <Malevolentdev@gmail.com>
 * Copyright (c) 2019, Rheon <https://github.com/Rheon-D>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.literegenmeter;

import java.awt.Color;
import java.awt.Dimension;
import java.awt.Graphics2D;
import java.awt.Image;
import java.awt.image.BufferedImage;
import java.util.EnumMap;
import java.util.Map;
import javax.inject.Inject;
import net.runelite.api.Client;
import net.runelite.api.Experience;
import net.runelite.api.MenuEntry;
import net.runelite.api.Point;
import net.runelite.api.Prayer;
import net.runelite.api.Skill;
import net.runelite.api.SpriteID;
import net.runelite.api.VarPlayer;
import net.runelite.api.Varbits;
import net.runelite.api.widgets.ComponentID;
import net.runelite.api.widgets.Widget;
import net.runelite.client.game.AlternateSprites;
import net.runelite.client.game.SkillIconManager;
import net.runelite.client.game.SpriteManager;
import net.runelite.client.plugins.itemstats.Effect;
import net.runelite.client.plugins.itemstats.ItemStatChangesService;
import net.runelite.client.plugins.itemstats.StatChange;
import com.literegenmeter.config.LiteStatBarsMode;
import com.literegenmeter.statbars.Viewport;
import net.runelite.client.ui.overlay.Overlay;
import net.runelite.client.ui.overlay.OverlayLayer;
import net.runelite.client.ui.overlay.OverlayPosition;
import net.runelite.client.util.ImageUtil;

class LiteStatBarsOverlay extends Overlay
{
	private static final int HEIGHT = 132;
	private static final int RESIZED_BOTTOM_HEIGHT = 136;
	private static final int IMAGE_SIZE = 16;
	private static final Dimension ICON_DIMENSIONS = new Dimension(26, 25);
	private static final int RESIZED_BOTTOM_OFFSET_Y = 12;
	private static final int RESIZED_BOTTOM_OFFSET_X = 10;
	private static final int MAX_SPECIAL_ATTACK_VALUE = 100;
	private static final int MAX_RUN_ENERGY_VALUE = 100;

	private final Client client;
	private final LiteRegenMeterPlugin plugin;
	private final LiteRegenMeterConfig config;
	private final ItemStatChangesService itemStatService;
	private final SpriteManager spriteManager;

	private final Image prayerIcon;
	private final Image heartDisease;
	private final Image heartPoison;
	private final Image heartVenom;
	private Image heartIcon;
	private Image specialIcon;
	private Image energyIcon;
	private final Image attackIcon;
	private final Image defenceIcon;
	private final Image strengthIcon;
	private final Image rangedIcon;
	private final Image magicIcon;
	private final Image cookingIcon;
	private final Image woodcuttingIcon;
	private final Image fletchingIcon;
	private final Image fishingIcon;
	private final Image firemakingIcon;
	private final Image craftingIcon;
	private final Image smithingIcon;
	private final Image miningIcon;
	private final Image herbloreIcon;
	private final Image agilityIcon;
	private final Image thievingIcon;
	private final Image slayerIcon;
	private final Image farmingIcon;
	private final Image runecraftingIcon;
	private final Image hunterIcon;
	private final Image constructionIcon;
	private final Map<LiteStatBarsMode, LiteStatBarsRenderer> barRenderers = new EnumMap<>(LiteStatBarsMode.class);

	@Inject
	private LiteStatBarsOverlay(Client client, LiteRegenMeterPlugin plugin, LiteRegenMeterConfig config, SkillIconManager skillIconManager, ItemStatChangesService itemstatservice, SpriteManager spriteManager)
	{
		setPosition(OverlayPosition.DYNAMIC);
		setLayer(OverlayLayer.ABOVE_WIDGETS);
		this.client = client;
		this.plugin = plugin;
		this.config = config;
		this.itemStatService = itemstatservice;
		this.spriteManager = spriteManager;

		attackIcon = ImageUtil.resizeCanvas(ImageUtil.resizeImage(skillIconManager.getSkillImage(Skill.ATTACK, true), IMAGE_SIZE, IMAGE_SIZE), ICON_DIMENSIONS.width, ICON_DIMENSIONS.height);
		defenceIcon = ImageUtil.resizeCanvas(ImageUtil.resizeImage(skillIconManager.getSkillImage(Skill.DEFENCE, true), IMAGE_SIZE, IMAGE_SIZE), ICON_DIMENSIONS.width, ICON_DIMENSIONS.height);
		strengthIcon = ImageUtil.resizeCanvas(ImageUtil.resizeImage(skillIconManager.getSkillImage(Skill.STRENGTH, true), IMAGE_SIZE, IMAGE_SIZE), ICON_DIMENSIONS.width, ICON_DIMENSIONS.height);
		rangedIcon = ImageUtil.resizeCanvas(ImageUtil.resizeImage(skillIconManager.getSkillImage(Skill.RANGED, true), IMAGE_SIZE, IMAGE_SIZE), ICON_DIMENSIONS.width, ICON_DIMENSIONS.height);
		magicIcon = ImageUtil.resizeCanvas(ImageUtil.resizeImage(skillIconManager.getSkillImage(Skill.MAGIC, true), IMAGE_SIZE, IMAGE_SIZE), ICON_DIMENSIONS.width, ICON_DIMENSIONS.height);
		cookingIcon = ImageUtil.resizeCanvas(ImageUtil.resizeImage(skillIconManager.getSkillImage(Skill.COOKING, true), IMAGE_SIZE, IMAGE_SIZE), ICON_DIMENSIONS.width, ICON_DIMENSIONS.height);
		woodcuttingIcon = ImageUtil.resizeCanvas(ImageUtil.resizeImage(skillIconManager.getSkillImage(Skill.WOODCUTTING, true), IMAGE_SIZE, IMAGE_SIZE), ICON_DIMENSIONS.width, ICON_DIMENSIONS.height);
		fletchingIcon = ImageUtil.resizeCanvas(ImageUtil.resizeImage(skillIconManager.getSkillImage(Skill.FLETCHING, true), IMAGE_SIZE, IMAGE_SIZE), ICON_DIMENSIONS.width, ICON_DIMENSIONS.height);
		fishingIcon = ImageUtil.resizeCanvas(ImageUtil.resizeImage(skillIconManager.getSkillImage(Skill.FISHING, true), IMAGE_SIZE, IMAGE_SIZE), ICON_DIMENSIONS.width, ICON_DIMENSIONS.height);
		firemakingIcon = ImageUtil.resizeCanvas(ImageUtil.resizeImage(skillIconManager.getSkillImage(Skill.FIREMAKING, true), IMAGE_SIZE, IMAGE_SIZE), ICON_DIMENSIONS.width, ICON_DIMENSIONS.height);
		craftingIcon = ImageUtil.resizeCanvas(ImageUtil.resizeImage(skillIconManager.getSkillImage(Skill.CRAFTING, true), IMAGE_SIZE, IMAGE_SIZE), ICON_DIMENSIONS.width, ICON_DIMENSIONS.height);
		smithingIcon = ImageUtil.resizeCanvas(ImageUtil.resizeImage(skillIconManager.getSkillImage(Skill.SMITHING, true), IMAGE_SIZE, IMAGE_SIZE), ICON_DIMENSIONS.width, ICON_DIMENSIONS.height);
		miningIcon = ImageUtil.resizeCanvas(ImageUtil.resizeImage(skillIconManager.getSkillImage(Skill.MINING, true), IMAGE_SIZE, IMAGE_SIZE), ICON_DIMENSIONS.width, ICON_DIMENSIONS.height);
		herbloreIcon = ImageUtil.resizeCanvas(ImageUtil.resizeImage(skillIconManager.getSkillImage(Skill.HERBLORE, true), IMAGE_SIZE, IMAGE_SIZE), ICON_DIMENSIONS.width, ICON_DIMENSIONS.height);
		agilityIcon = ImageUtil.resizeCanvas(ImageUtil.resizeImage(skillIconManager.getSkillImage(Skill.AGILITY, true), IMAGE_SIZE, IMAGE_SIZE), ICON_DIMENSIONS.width, ICON_DIMENSIONS.height);
		thievingIcon = ImageUtil.resizeCanvas(ImageUtil.resizeImage(skillIconManager.getSkillImage(Skill.THIEVING, true), IMAGE_SIZE, IMAGE_SIZE), ICON_DIMENSIONS.width, ICON_DIMENSIONS.height);
		slayerIcon = ImageUtil.resizeCanvas(ImageUtil.resizeImage(skillIconManager.getSkillImage(Skill.SLAYER, true), IMAGE_SIZE, IMAGE_SIZE), ICON_DIMENSIONS.width, ICON_DIMENSIONS.height);
		farmingIcon = ImageUtil.resizeCanvas(ImageUtil.resizeImage(skillIconManager.getSkillImage(Skill.FARMING, true), IMAGE_SIZE, IMAGE_SIZE), ICON_DIMENSIONS.width, ICON_DIMENSIONS.height);
		runecraftingIcon = ImageUtil.resizeCanvas(ImageUtil.resizeImage(skillIconManager.getSkillImage(Skill.RUNECRAFT, true), IMAGE_SIZE, IMAGE_SIZE), ICON_DIMENSIONS.width, ICON_DIMENSIONS.height);
		hunterIcon = ImageUtil.resizeCanvas(ImageUtil.resizeImage(skillIconManager.getSkillImage(Skill.HUNTER, true), IMAGE_SIZE, IMAGE_SIZE), ICON_DIMENSIONS.width, ICON_DIMENSIONS.height);
		constructionIcon = ImageUtil.resizeCanvas(ImageUtil.resizeImage(skillIconManager.getSkillImage(Skill.CONSTRUCTION, true), IMAGE_SIZE, IMAGE_SIZE), ICON_DIMENSIONS.width, ICON_DIMENSIONS.height);
		prayerIcon = ImageUtil.resizeCanvas(ImageUtil.resizeImage(skillIconManager.getSkillImage(Skill.PRAYER, true), IMAGE_SIZE, IMAGE_SIZE), ICON_DIMENSIONS.width, ICON_DIMENSIONS.height);

		heartDisease = ImageUtil.resizeCanvas(ImageUtil.loadImageResource(AlternateSprites.class, AlternateSprites.DISEASE_HEART), ICON_DIMENSIONS.width, ICON_DIMENSIONS.height);
		heartPoison = ImageUtil.resizeCanvas(ImageUtil.loadImageResource(AlternateSprites.class, AlternateSprites.POISON_HEART), ICON_DIMENSIONS.width, ICON_DIMENSIONS.height);
		heartVenom = ImageUtil.resizeCanvas(ImageUtil.loadImageResource(AlternateSprites.class, AlternateSprites.VENOM_HEART), ICON_DIMENSIONS.width, ICON_DIMENSIONS.height);

		initRenderers();
	}

	private Color brightenColor(Color color, float percentage) {
		int r = (int) Math.min(255, color.getRed() * (1 + percentage));
		int g = (int) Math.min(255, color.getGreen() * (1 + percentage));
		int b = (int) Math.min(255, color.getBlue() * (1 + percentage));
		return new Color(r, g, b);
	}

	private void initRenderers() {
		barRenderers.put(LiteStatBarsMode.DISABLED, null);

		barRenderers.put(LiteStatBarsMode.HITPOINTS, new LiteStatBarsRenderer(
				() -> inLms() ? Experience.MAX_REAL_LEVEL : client.getRealSkillLevel(Skill.HITPOINTS),
				() -> client.getBoostedSkillLevel(Skill.HITPOINTS),
				() -> getRestoreValue(Skill.HITPOINTS.getName()),
				() -> {
					final int poisonState = client.getVarpValue(VarPlayer.POISON);

					if (poisonState >= 1000000) {
						return config.venomedColor();
					}

					if (poisonState > 0) {
						return config.poisonedColor();
					}

					if (client.getVarpValue(VarPlayer.DISEASE_VALUE) > 0) {
						return config.diseaseColor();
					}

					if (client.getVarbitValue(Varbits.PARASITE) >= 1) {
						return config.parasiteColor();
					}

					return config.healthColor();
				},
				config::healColor,
				() -> {
					final int poisonState = client.getVarpValue(VarPlayer.POISON);

					if (poisonState > 0 && poisonState < 50) {
						return heartPoison;
					}

					if (poisonState >= 1000000) {
						return heartVenom;
					}

					if (client.getVarpValue(VarPlayer.DISEASE_VALUE) > 0) {
						return heartDisease;
					}

					return heartIcon;
				}
		));

		barRenderers.put(LiteStatBarsMode.PRAYER, new LiteStatBarsRenderer(
				() -> inLms() ? Experience.MAX_REAL_LEVEL : client.getRealSkillLevel(Skill.PRAYER),
				() -> client.getBoostedSkillLevel(Skill.PRAYER),
				() -> getRestoreValue(Skill.PRAYER.getName()),
				() -> {
					Color prayerColor = config.prayerColor();

					for (Prayer pray : Prayer.values()) {
						if (client.isPrayerActive(pray)) {
							prayerColor = config.activePrayerColor();
							break;
						}
					}

					return prayerColor;
				},
				config::prayerHealColor,
				() -> prayerIcon
		));

		barRenderers.put(LiteStatBarsMode.RUN_ENERGY, new LiteStatBarsRenderer(
				() -> MAX_RUN_ENERGY_VALUE,
				() -> client.getEnergy() / 100,
				() -> getRestoreValue("Run Energy"),
				() -> {
					if (client.getVarbitValue(Varbits.RUN_SLOWED_DEPLETION_ACTIVE) != 0) {
						return config.runStaminaColor();
					} else {
						return config.energyColor();
					}
				},
				config::energyHealColor,
				() -> energyIcon
		));

		barRenderers.put(LiteStatBarsMode.SPECIAL_ATTACK, new LiteStatBarsRenderer(
				() -> MAX_SPECIAL_ATTACK_VALUE,
				() -> client.getVarpValue(VarPlayer.SPECIAL_ATTACK_PERCENT) / 10,
				() -> 0,
				config::specialAttackColor,
				() -> brightenColor(config.specialAttackColor(), 0.5f),
				() -> specialIcon
		));
		barRenderers.put(LiteStatBarsMode.ATTACK, new LiteStatBarsRenderer(
				() -> inLms() ? Experience.MAX_REAL_LEVEL : client.getRealSkillLevel(Skill.ATTACK),
				() -> client.getBoostedSkillLevel(Skill.ATTACK),
				() -> getRestoreValue(Skill.ATTACK.getName()),
				config::attackColor,
				() -> brightenColor(config.attackColor(), 0.5f),
				() -> attackIcon
		));

		barRenderers.put(LiteStatBarsMode.DEFENCE, new LiteStatBarsRenderer(
				() -> inLms() ? Experience.MAX_REAL_LEVEL : client.getRealSkillLevel(Skill.DEFENCE),
				() -> client.getBoostedSkillLevel(Skill.DEFENCE),
				() -> getRestoreValue(Skill.DEFENCE.getName()),
				config::defenceColor,
				() -> brightenColor(config.defenceColor(), 0.5f),
				() -> defenceIcon
		));

		barRenderers.put(LiteStatBarsMode.STRENGTH, new LiteStatBarsRenderer(
				() -> inLms() ? Experience.MAX_REAL_LEVEL : client.getRealSkillLevel(Skill.STRENGTH),
				() -> client.getBoostedSkillLevel(Skill.STRENGTH),
				() -> getRestoreValue(Skill.STRENGTH.getName()),
				config::strengthColor,
				() -> brightenColor(config.strengthColor(), 0.5f),
				() -> strengthIcon
		));

		barRenderers.put(LiteStatBarsMode.RANGED, new LiteStatBarsRenderer(
				() -> inLms() ? Experience.MAX_REAL_LEVEL : client.getRealSkillLevel(Skill.RANGED),
				() -> client.getBoostedSkillLevel(Skill.RANGED),
				() -> getRestoreValue(Skill.RANGED.getName()),
				config::rangedColor,
				() -> brightenColor(config.rangedColor(), 0.5f),
				() -> rangedIcon
		));

		barRenderers.put(LiteStatBarsMode.MAGIC, new LiteStatBarsRenderer(
				() -> inLms() ? Experience.MAX_REAL_LEVEL : client.getRealSkillLevel(Skill.MAGIC),
				() -> client.getBoostedSkillLevel(Skill.MAGIC),
				() -> getRestoreValue(Skill.MAGIC.getName()),
				config::magicColor,
				() -> brightenColor(config.magicColor(), 0.5f),
				() -> magicIcon
		));

		barRenderers.put(LiteStatBarsMode.COOKING, new LiteStatBarsRenderer(
				() -> inLms() ? Experience.MAX_REAL_LEVEL : client.getRealSkillLevel(Skill.COOKING),
				() -> client.getBoostedSkillLevel(Skill.COOKING),
				() -> getRestoreValue(Skill.COOKING.getName()),
				config::cookingColor,
				() -> brightenColor(config.cookingColor(), 0.5f),
				() -> cookingIcon
		));

		barRenderers.put(LiteStatBarsMode.WOODCUTTING, new LiteStatBarsRenderer(
				() -> inLms() ? Experience.MAX_REAL_LEVEL : client.getRealSkillLevel(Skill.WOODCUTTING),
				() -> client.getBoostedSkillLevel(Skill.WOODCUTTING),
				() -> getRestoreValue(Skill.WOODCUTTING.getName()),
				config::woodcuttingColor,
				() -> brightenColor(config.woodcuttingColor(), 0.5f),
				() -> woodcuttingIcon
		));

		barRenderers.put(LiteStatBarsMode.FLETCHING, new LiteStatBarsRenderer(
				() -> inLms() ? Experience.MAX_REAL_LEVEL : client.getRealSkillLevel(Skill.FLETCHING),
				() -> client.getBoostedSkillLevel(Skill.FLETCHING),
				() -> getRestoreValue(Skill.FLETCHING.getName()),
				config::fletchingColor,
				() -> brightenColor(config.fletchingColor(), 0.5f),
				() -> fletchingIcon
		));

		barRenderers.put(LiteStatBarsMode.FISHING, new LiteStatBarsRenderer(
				() -> inLms() ? Experience.MAX_REAL_LEVEL : client.getRealSkillLevel(Skill.FISHING),
				() -> client.getBoostedSkillLevel(Skill.FISHING),
				() -> getRestoreValue(Skill.FISHING.getName()),
				config::fishingColor,
				() -> brightenColor(config.fishingColor(), 0.5f),
				() -> fishingIcon
		));

		barRenderers.put(LiteStatBarsMode.FIREMAKING, new LiteStatBarsRenderer(
				() -> inLms() ? Experience.MAX_REAL_LEVEL : client.getRealSkillLevel(Skill.FIREMAKING),
				() -> client.getBoostedSkillLevel(Skill.FIREMAKING),
				() -> getRestoreValue(Skill.FIREMAKING.getName()),
				config::firemakingColor,
				() -> brightenColor(config.firemakingColor(), 0.5f),
				() -> firemakingIcon
		));

		barRenderers.put(LiteStatBarsMode.CRAFTING, new LiteStatBarsRenderer(
				() -> inLms() ? Experience.MAX_REAL_LEVEL : client.getRealSkillLevel(Skill.CRAFTING),
				() -> client.getBoostedSkillLevel(Skill.CRAFTING),
				() -> getRestoreValue(Skill.CRAFTING.getName()),
				config::craftingColor,
				() -> brightenColor(config.craftingColor(), 0.5f),
				() -> craftingIcon
		));

		barRenderers.put(LiteStatBarsMode.SMITHING, new LiteStatBarsRenderer(
				() -> inLms() ? Experience.MAX_REAL_LEVEL : client.getRealSkillLevel(Skill.SMITHING),
				() -> client.getBoostedSkillLevel(Skill.SMITHING),
				() -> getRestoreValue(Skill.SMITHING.getName()),
				config::smithingColor,
				() -> brightenColor(config.smithingColor(), 0.5f),
				() -> smithingIcon
		));

		barRenderers.put(LiteStatBarsMode.MINING, new LiteStatBarsRenderer(
				() -> inLms() ? Experience.MAX_REAL_LEVEL : client.getRealSkillLevel(Skill.MINING),
				() -> client.getBoostedSkillLevel(Skill.MINING),
				() -> getRestoreValue(Skill.MINING.getName()),
				config::miningColor,
				() -> brightenColor(config.miningColor(), 0.5f),
				() -> miningIcon
		));

		barRenderers.put(LiteStatBarsMode.HERBLORE, new LiteStatBarsRenderer(
				() -> inLms() ? Experience.MAX_REAL_LEVEL : client.getRealSkillLevel(Skill.HERBLORE),
				() -> client.getBoostedSkillLevel(Skill.HERBLORE),
				() -> getRestoreValue(Skill.HERBLORE.getName()),
				config::herbloreColor,
				() -> brightenColor(config.herbloreColor(), 0.5f),
				() -> herbloreIcon
		));

		barRenderers.put(LiteStatBarsMode.AGILITY, new LiteStatBarsRenderer(
				() -> inLms() ? Experience.MAX_REAL_LEVEL : client.getRealSkillLevel(Skill.AGILITY),
				() -> client.getBoostedSkillLevel(Skill.AGILITY),
				() -> getRestoreValue(Skill.AGILITY.getName()),
				config::agilityColor,
				() -> brightenColor(config.agilityColor(), 0.5f),
				() -> agilityIcon
		));

		barRenderers.put(LiteStatBarsMode.THIEVING, new LiteStatBarsRenderer(
				() -> inLms() ? Experience.MAX_REAL_LEVEL : client.getRealSkillLevel(Skill.THIEVING),
				() -> client.getBoostedSkillLevel(Skill.THIEVING),
				() -> getRestoreValue(Skill.THIEVING.getName()),
				config::thievingColor,
				() -> brightenColor(config.thievingColor(), 0.5f),
				() -> thievingIcon
		));

		barRenderers.put(LiteStatBarsMode.SLAYER, new LiteStatBarsRenderer(
				() -> inLms() ? Experience.MAX_REAL_LEVEL : client.getRealSkillLevel(Skill.SLAYER),
				() -> client.getBoostedSkillLevel(Skill.SLAYER),
				() -> getRestoreValue(Skill.SLAYER.getName()),
				config::slayerColor,
				() -> brightenColor(config.slayerColor(), 0.5f),
				() -> slayerIcon
		));

		barRenderers.put(LiteStatBarsMode.FARMING, new LiteStatBarsRenderer(
				() -> inLms() ? Experience.MAX_REAL_LEVEL : client.getRealSkillLevel(Skill.FARMING),
				() -> client.getBoostedSkillLevel(Skill.FARMING),
				() -> getRestoreValue(Skill.FARMING.getName()),
				config::farmingColor,
				() -> brightenColor(config.farmingColor(), 0.5f),
				() -> farmingIcon
		));

		barRenderers.put(LiteStatBarsMode.RUNECRAFT, new LiteStatBarsRenderer(
				() -> inLms() ? Experience.MAX_REAL_LEVEL : client.getRealSkillLevel(Skill.RUNECRAFT),
				() -> client.getBoostedSkillLevel(Skill.RUNECRAFT),
				() -> getRestoreValue(Skill.RUNECRAFT.getName()),
				config::runecraftColor,
				() -> brightenColor(config.runecraftColor(), 0.5f),
				() -> runecraftingIcon
		));

		barRenderers.put(LiteStatBarsMode.HUNTER, new LiteStatBarsRenderer(
				() -> inLms() ? Experience.MAX_REAL_LEVEL : client.getRealSkillLevel(Skill.HUNTER),
				() -> client.getBoostedSkillLevel(Skill.HUNTER),
				() -> getRestoreValue(Skill.HUNTER.getName()),
				config::hunterColor,
				() -> brightenColor(config.hunterColor(), 0.5f),
				() -> hunterIcon
		));

		barRenderers.put(LiteStatBarsMode.CONSTRUCTION, new LiteStatBarsRenderer(
				() -> inLms() ? Experience.MAX_REAL_LEVEL : client.getRealSkillLevel(Skill.CONSTRUCTION),
				() -> client.getBoostedSkillLevel(Skill.CONSTRUCTION),
				() -> getRestoreValue(Skill.CONSTRUCTION.getName()),
				config::constructionColor,
				() -> brightenColor(config.constructionColor(), 0.5f),
				() -> constructionIcon
		));
	}

	@Override
	public Dimension render(Graphics2D g)
	{
		if (!plugin.isBarsDisplayed())
		{
			return null;
		}

		Viewport curViewport = null;
		Widget curWidget = null;

		for (Viewport viewport : Viewport.values())
		{
			final Widget viewportWidget = client.getWidget(viewport.getViewport());
			if (viewportWidget != null && !viewportWidget.isHidden())
			{
				curViewport = viewport;
				curWidget = viewportWidget;
				break;
			}
		}

		if (curViewport == null)
		{
			return null;
		}

		final Point offsetLeft = curViewport.getOffsetLeft();
		final Point offsetRight = curViewport.getOffsetRight();
		final Point location = curWidget.getCanvasLocation();

		LiteRegenMeterConfig.PackMode mode = config.packMode();

		int width = LiteStatBarsRenderer.DEFAULT_WIDTH;
		int height = HEIGHT;
		int offsetLeftBarX, offsetLeftBarY, offsetRightBarX, offsetRightBarY;

		if (curViewport == Viewport.RESIZED_BOTTOM)
		{
			LiteRegenMeterConfig.LocationType locationType = config.statBarLocation();

			if (locationType == LiteRegenMeterConfig.LocationType.INSIDE)
			{
				width = 10;
			}
			else
			{
				width = config.statbarWidth();
			}

			height = RESIZED_BOTTOM_HEIGHT + 1;
			final int barWidthOffset = width - LiteStatBarsRenderer.DEFAULT_WIDTH;

			int shift = 0;

			if (locationType == LiteRegenMeterConfig.LocationType.INSIDE)
			{
				shift = 202;
			}
			else if (locationType == LiteRegenMeterConfig.LocationType.RIGHT_SIDE)
			{
				shift = 235;
			}

			if (locationType == LiteRegenMeterConfig.LocationType.RIGHT_SIDE)
			{
				offsetLeftBarX = (location.getX() + RESIZED_BOTTOM_OFFSET_X + shift - offsetLeft.getX()) + 17;
				offsetRightBarX = (location.getX() + RESIZED_BOTTOM_OFFSET_X + shift - offsetRight.getX()) + 7 + barWidthOffset;
			}
			else
			{
				offsetLeftBarX = (location.getX() + RESIZED_BOTTOM_OFFSET_X - offsetLeft.getX() - 2 * barWidthOffset + shift) + 17;
				offsetRightBarX = (location.getX() + RESIZED_BOTTOM_OFFSET_X - offsetRight.getX() - barWidthOffset + shift) + 7;
			}

			offsetLeftBarY = (location.getY() - RESIZED_BOTTOM_OFFSET_Y - offsetLeft.getY() - 1);
			offsetRightBarY = (location.getY() - RESIZED_BOTTOM_OFFSET_Y - offsetRight.getY() - 1);
		}
		else
		{
			offsetLeftBarX = (location.getX() - offsetLeft.getX());
			offsetRightBarX = (location.getX() - offsetRight.getX() + 4) + curWidget.getWidth();

			offsetLeftBarY = (location.getY() - offsetLeft.getY() - 5);
			offsetRightBarY = (location.getY() - offsetRight.getY() - 5);

			if (mode == LiteRegenMeterConfig.PackMode.VANILLA)
			{
				height -= 6;

				offsetLeftBarY = (location.getY() - offsetLeft.getY());
				offsetRightBarY = (location.getY() - offsetRight.getY());
				offsetRightBarX -= 4;

				width += 3;
			}
		}

		buildIcons();

		LiteStatBarsRenderer left = barRenderers.get(config.leftBarMode());
		LiteStatBarsRenderer right = barRenderers.get(config.rightBarMode());

		int leftBar1Length = height;
		int leftBar2Length = height;
		int rightBar1Length = height;
		int rightBar2Length = height;

		boolean isLeftBar1Off = left == null || config.leftBarMode() == LiteStatBarsMode.DISABLED;
		boolean isLeftBar2Off = barRenderers.get(config.LeftBarMode2()) == null || config.LeftBarMode2() == LiteStatBarsMode.DISABLED;

		boolean isRightBar1Off = right == null || config.rightBarMode() == LiteStatBarsMode.DISABLED;
		boolean isRightBar2Off = barRenderers.get(config.RightBarMode2()) == null || config.RightBarMode2() == LiteStatBarsMode.DISABLED;

		if (isLeftBar1Off && !isLeftBar2Off)
		{
			offsetLeftBarY -= height;
			leftBar2Length = (height * 2) - 1;
		}
		else if (isLeftBar2Off && !isLeftBar1Off)
		{
			leftBar1Length = (height * 2) - 1;
		}

		if (isRightBar1Off && !isRightBar2Off)
		{
			offsetRightBarY -= height;
			rightBar2Length = (height * 2) - 1;
		}
		else if (isRightBar2Off && !isRightBar1Off)
		{
			rightBar1Length = (height * 2) - 1;
		}

		if (left != null)
		{
			left.renderBar(config, g, offsetLeftBarX, offsetLeftBarY, width, leftBar1Length);
		}

		if (right != null)
		{
			right.renderBar(config, g, offsetRightBarX, offsetRightBarY, width, rightBar1Length);
		}

		int secondBarYOffset = height;

		LiteStatBarsRenderer secondLeft = barRenderers.get(config.LeftBarMode2());
		LiteStatBarsRenderer secondRight = barRenderers.get(config.RightBarMode2());

		if (secondLeft != null) {
			if (!isLeftBar1Off) {
				secondLeft.renderBar(config, g, offsetLeftBarX, offsetLeftBarY + secondBarYOffset - 1, width, leftBar2Length);
			} else {
				secondLeft.renderBar(config, g, offsetLeftBarX, offsetLeftBarY + secondBarYOffset, width, leftBar2Length);
			}
		}

		if (secondRight != null) {
			if (!isRightBar1Off) {
				secondRight.renderBar(config, g, offsetRightBarX, offsetRightBarY + secondBarYOffset - 1, width, rightBar2Length);
			} else {
				secondRight.renderBar(config, g, offsetRightBarX, offsetRightBarY + secondBarYOffset, width, rightBar2Length);
			}
		}

		return null;
	}

	private int getRestoreValue(String skill)
	{
		final MenuEntry[] menu = client.getMenuEntries();
		final int menuSize = menu.length;
		if (menuSize == 0)
		{
			return 0;
		}

		final MenuEntry entry = menu[menuSize - 1];
		final Widget widget = entry.getWidget();
		int restoreValue = 0;

		if (widget != null && widget.getId() == ComponentID.INVENTORY_CONTAINER)
		{
			final Effect change = itemStatService.getItemStatChanges(widget.getItemId());

			if (change != null)
			{
				for (final StatChange c : change.calculate(client).getStatChanges())
				{
					final int value = c.getTheoretical();

					if (value != 0 && c.getStat().getName().equals(skill))
					{
						restoreValue = value;
					}
				}
			}
		}

		return restoreValue;
	}

	private void buildIcons()
	{
		if (heartIcon == null)
		{
			heartIcon = loadAndResize(SpriteID.MINIMAP_ORB_HITPOINTS_ICON);
		}
		if (energyIcon == null)
		{
			energyIcon = loadAndResize(SpriteID.MINIMAP_ORB_WALK_ICON);
		}
		if (specialIcon == null)
		{
			specialIcon = loadAndResize(SpriteID.MINIMAP_ORB_SPECIAL_ICON);
		}
	}

	private BufferedImage loadAndResize(int spriteId)
	{
		BufferedImage image = spriteManager.getSprite(spriteId, 0);
		if (image == null)
		{
			return null;
		}

		return ImageUtil.resizeCanvas(image, ICON_DIMENSIONS.width, ICON_DIMENSIONS.height);
	}

	private boolean inLms()
	{
		return client.getWidget(ComponentID.LMS_INGAME_INFO) != null;
	}
}

/*
 * Copyright (c) 2018 Hydrox6 <ikada@protonmail.ch>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.literegenmeter;

import java.awt.Color;
import java.awt.image.BufferedImage;
import java.time.temporal.ChronoUnit;
import net.runelite.client.ui.overlay.infobox.Timer;

class PoisonInfobox extends Timer
{
	private final LiteRegenMeterPlugin plugin;

	PoisonInfobox(BufferedImage image, LiteRegenMeterPlugin plugin)
	{
		super(LiteRegenMeterPlugin.POISON_TICK_MILLIS, ChronoUnit.MILLIS, image, plugin);
		this.plugin = plugin;
	}

	@Override
	public String getTooltip()
	{
		return plugin.createTooltip();
	}

	@Override
	public Color getTextColor()
	{
		return Color.RED.brighter();
	}
}


/*
 * Copyright (c) 2018 Hydrox6 <ikada@protonmail.ch>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.literegenmeter;

import java.awt.Dimension;
import java.awt.Graphics2D;
import java.awt.Rectangle;
import javax.inject.Inject;
import net.runelite.api.Client;
import net.runelite.api.Point;
import net.runelite.api.widgets.ComponentID;
import net.runelite.api.widgets.Widget;
import net.runelite.client.ui.overlay.Overlay;
import net.runelite.client.ui.overlay.OverlayLayer;
import net.runelite.client.ui.overlay.OverlayPosition;
import net.runelite.client.ui.overlay.tooltip.Tooltip;
import net.runelite.client.ui.overlay.tooltip.TooltipManager;

class PoisonOverlay extends Overlay
{
	private final LiteRegenMeterPlugin plugin;
	private final Client client;
	private final TooltipManager tooltipManager;

	@Inject
	private PoisonOverlay(final LiteRegenMeterPlugin plugin, final Client client, final TooltipManager tooltipManager)
	{
		this.plugin = plugin;
		this.client = client;
		this.tooltipManager = tooltipManager;
		setPosition(OverlayPosition.DYNAMIC);
		setLayer(OverlayLayer.ABOVE_WIDGETS);
	}

	@Override
	public Dimension render(Graphics2D graphics)
	{
		if (plugin.getLastDamage() <= 0)
		{
			return null;
		}

		final Widget healthOrb = client.getWidget(ComponentID.MINIMAP_HEALTH_ORB);

		if (healthOrb == null || healthOrb.isHidden())
		{
			return null;
		}

		final Rectangle bounds = healthOrb.getBounds();

		if (bounds.getX() <= 0)
		{
			return null;
		}

		final Point mousePosition = client.getMouseCanvasPosition();

		if (bounds.contains(mousePosition.getX(), mousePosition.getY()))
		{
			tooltipManager.add(new Tooltip(plugin.createTooltip()));
		}

		return null;
	}
}

/*
 * Copyright (c) 2024, Smoke (Smoked today) <https://github.com/Varietyz>
 * Copyright (c) 2018, Ethan <https://github.com/shmeeps>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

package com.literegenmeter;

import java.awt.BasicStroke;
import java.awt.Color;
import java.awt.Dimension;
import java.awt.Graphics2D;
import java.awt.Rectangle;
import java.time.Duration;
import java.time.Instant;
import javax.inject.Inject;
import lombok.AccessLevel;
import lombok.Setter;
import net.runelite.api.Client;
import net.runelite.api.Constants;
import net.runelite.api.Skill;
import net.runelite.api.widgets.ComponentID;
import net.runelite.api.widgets.Widget;
import net.runelite.client.ui.overlay.Overlay;
import net.runelite.client.ui.overlay.OverlayLayer;
import net.runelite.client.ui.overlay.OverlayPosition;

class LitePrayerDoseOverlay extends Overlay
{
    private static final float PULSE_TIME = 2f * Constants.GAME_TICK_LENGTH;
    private static final double DIAMETER = 26D;
    private static final int OFFSET = 27;

    private final Client client;
    private final LiteRegenMeterPlugin plugin;
    private final LiteRegenMeterConfig config;
    private Instant startOfLastTick = Instant.now();
    private boolean trackTick = true;

    @Setter(AccessLevel.PACKAGE)
    private int restoreAmount;

    @Inject
    private LitePrayerDoseOverlay(final Client client, final LiteRegenMeterPlugin plugin, final LiteRegenMeterConfig config)
    {
        this.client = client;
        this.plugin = plugin;
        this.config = config;
        setPosition(OverlayPosition.DYNAMIC);
        setLayer(OverlayLayer.ABOVE_WIDGETS);
    }

    void onTick()
    {
        if (trackTick)
        {
            startOfLastTick = Instant.now();
            trackTick = false;
        }
        else
        {
            trackTick = true;
        }
    }
    @Override
    public Dimension render(Graphics2D graphics)
    {
        final Widget xpOrb = client.getWidget(ComponentID.MINIMAP_QUICK_PRAYER_ORB);
        if (xpOrb == null || xpOrb.isHidden())
        {
            return null;
        }

        final Rectangle bounds = xpOrb.getBounds();
        if (bounds.getX() <= 0)
        {
            return null;
        }

        if (!config.showPrayerDoseIndicator() || restoreAmount == 0)
        {
            return null;
        }

        final int currentPrayer = client.getBoostedSkillLevel(Skill.PRAYER);
        final int maxPrayer = client.getRealSkillLevel(Skill.PRAYER);

        final int prayerPointsMissing = maxPrayer - currentPrayer;
        if (prayerPointsMissing <= 0 || prayerPointsMissing < restoreAmount)
        {
            return null;
        }

        LiteRegenMeterConfig.BarWidth barWidthOption = config.getBarWidth();
        final int BAR_WIDTH = (barWidthOption == LiteRegenMeterConfig.BarWidth.NORMAL) ? 25 : 34;
        int lineThickness = config.getLineThickness().getValue();

        int barX;
        switch (config.barXPosition()) {
            case LEFT:
                barX = (int) (bounds.x + OFFSET - 1 - 25);
                break;
            case MIDDLE:
                if (config.getBarWidth() == LiteRegenMeterConfig.BarWidth.WIDER) {
                    barX = (int) (bounds.x + OFFSET - 1 - 20);
                } else {
                    barX = (int) (bounds.x + OFFSET - 1 - 15);
                }
                break;
            case RIGHT:
                barX = (int) (bounds.x + OFFSET - 3 - (BAR_WIDTH - 25) - 4);
                break;
            default:
                barX = (int) (bounds.x + OFFSET - 1);
        }

        int barY;
        switch (config.barYPosition()) {
            case DETACHED:
                barY = (int) (bounds.y + (bounds.height / 2) + (DIAMETER / 2) - 2 + 2);
                break;
            case ATTACHED:
            default:
                barY = (int) (bounds.y + (bounds.height / 2) + (DIAMETER / 2) - 2);
        }

        final long timeSinceLastTick = Duration.between(startOfLastTick, Instant.now()).toMillis();
        final float tickProgress = Math.min(timeSinceLastTick / PULSE_TIME, 1);

        float flash = (float) Math.sin(tickProgress * Math.PI * 2);
        float alpha = Math.max(0, 0.5f + 0.5f * flash);

        Color barColor = config.prayerDoseOrbStartColor();
        Color flashingColor = new Color(barColor.getRed(), barColor.getGreen(), barColor.getBlue(), (int) (alpha * 255));

        Color outlineColor = new Color(0x171717);
        Color flashingOutlineColor = new Color(outlineColor.getRed(), outlineColor.getGreen(), outlineColor.getBlue(), (int) (alpha * 255));

        double fixedBarWidth = BAR_WIDTH;

        Rectangle bar = new Rectangle(barX, barY, (int) fixedBarWidth, lineThickness);

        Rectangle background = new Rectangle(barX - 1, barY - 1, (int) fixedBarWidth + 2, lineThickness + 2);

        graphics.setColor(flashingOutlineColor);
        graphics.fill(background);

        graphics.setColor(flashingColor);
        graphics.fill(bar);

        graphics.setStroke(new BasicStroke(1));
        graphics.setColor(flashingOutlineColor);
        graphics.drawRect(barX - 1, barY - 1, (int) fixedBarWidth + 1, lineThickness + 1);

        return null;
    }

}

/*
 * Copyright (c) 2018, Jos <Malevolentdev@gmail.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.literegenmeter.statbars;

import lombok.AllArgsConstructor;
import lombok.Getter;
import net.runelite.api.Point;
import net.runelite.api.widgets.ComponentID;

@Getter
@AllArgsConstructor
public enum Viewport
{
	RESIZED_BOX(ComponentID.RESIZABLE_VIEWPORT_RESIZABLE_VIEWPORT_OLD_SCHOOL_BOX, ComponentID.RESIZABLE_VIEWPORT_INTERFACE_CONTAINER,
			new Point(20, -4), new Point(0, -4)),
	RESIZED_BOTTOM(ComponentID.RESIZABLE_VIEWPORT_BOTTOM_LINE_RESIZABLE_VIEWPORT_BOTTOM_LINE, ComponentID.RESIZABLE_VIEWPORT_BOTTOM_LINE_INTERFACE_CONTAINER,
			new Point(61, -12), new Point(35, -12)),
	FIXED(ComponentID.FIXED_VIEWPORT_FIXED_VIEWPORT, ComponentID.FIXED_VIEWPORT_INTERFACE_CONTAINER,
			new Point(20, -4), new Point(0, -4)),
	FIXED_BANK(ComponentID.BANK_CONTAINER, ComponentID.BANK_INVENTORY_ITEM_CONTAINER,
			new Point(20, -4), new Point(0, -4));

	private int container;
	private int viewport;
	private Point offsetLeft;
	private Point offsetRight;
}

/*
 * Copyright (c) 2024, Smoke (Smoked today) <https://github.com/Varietyz>
 * Copyright (c) 2018 Abex
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.literegenmeter;

import java.awt.BasicStroke;
import java.awt.Color;
import java.awt.Dimension;
import java.awt.Graphics2D;
import java.awt.Rectangle;
import java.awt.RenderingHints;
import javax.inject.Inject;
import net.runelite.api.Client;
import net.runelite.api.annotations.Component;
import net.runelite.api.widgets.ComponentID;
import net.runelite.api.widgets.Widget;
import com.literegenmeter.orbmeters.LineThickness;
import net.runelite.client.ui.overlay.Overlay;
import net.runelite.client.ui.overlay.OverlayLayer;
import net.runelite.client.ui.overlay.OverlayPosition;

class LiteRegenMeterOverlay extends Overlay
{
	private static final double DIAMETER = 26D;
	private static final int OFFSET = 27;

	private final Client client;
	private final LiteRegenMeterPlugin plugin;
	private final LiteRegenMeterConfig config;

	private static Color brighter(int color)
	{
		float[] hsv = new float[3];
		Color.RGBtoHSB(color >>> 16, (color >> 8) & 0xFF, color & 0xFF, hsv);
		return Color.getHSBColor(hsv[0], 1.f, 1.f);
	}

	@Inject
	public LiteRegenMeterOverlay(Client client, LiteRegenMeterPlugin plugin, LiteRegenMeterConfig config)
	{
		setPosition(OverlayPosition.DYNAMIC);
		setLayer(OverlayLayer.ABOVE_WIDGETS);
		this.client = client;
		this.plugin = plugin;
		this.config = config;
	}

	@Override
	public Dimension render(Graphics2D g)
	{
		g.setRenderingHint(RenderingHints.KEY_STROKE_CONTROL, RenderingHints.VALUE_STROKE_PURE);

		if (config.showHitpoints())
		{
			Color hitpointsColor = config.getHitpointsColor();
			renderRegen(g, ComponentID.MINIMAP_HEALTH_ORB, plugin.getHitpointsPercentage(), hitpointsColor);
		}

		if (config.showSpecial())
		{
			Color specialColor = config.getSpecialColor();
			renderRegen(g, ComponentID.MINIMAP_SPEC_ORB, plugin.getSpecialPercentage(), specialColor);
		}

		return null;
	}

	private void renderRegen(Graphics2D g, @Component int componentId, double percent, Color color) {
		if (!config.enableRegenMeters()) {
			return;
		}

		Widget widget = client.getWidget(componentId);
		if (widget == null || widget.isHidden()) {
			return;
		}
		Rectangle bounds = widget.getBounds();

		LineThickness lineThickness = config.getLineThickness();

		LiteRegenMeterConfig.BarWidth barWidthOption = config.getBarWidth();

		final int BAR_WIDTH = (barWidthOption == LiteRegenMeterConfig.BarWidth.NORMAL) ? 25 : 34;

		double barWidth = BAR_WIDTH * percent;

		barWidth = Math.min(barWidth, BAR_WIDTH);

		LiteRegenMeterConfig.PackMode mode = config.packMode();
		int vanillaXOffset = (mode == LiteRegenMeterConfig.PackMode.VANILLA) ? -3 : 0;
		int vanillaYOffset = (mode == LiteRegenMeterConfig.PackMode.VANILLA) ? 2 : 0;

		double barX;
		switch (config.barXPosition()) {
			case LEFT:
				barX = bounds.x + OFFSET - 1 - 22 + vanillaXOffset;
				break;
			case MIDDLE:
				if (config.getBarWidth() == LiteRegenMeterConfig.BarWidth.WIDER) {
					barX = bounds.x + OFFSET - 1 - 17;
				} else {
					barX = bounds.x + OFFSET - 1 - 12;
				}
				break;
			case RIGHT:
				barX = bounds.x + OFFSET - 3 - (BAR_WIDTH - 25) - 1 + vanillaXOffset;
				break;
			default:
				barX = bounds.x + OFFSET - 1 + vanillaXOffset;
		}

		double barY;
		switch (config.barYPosition()) {
			case DETACHED:
				if (mode == LiteRegenMeterConfig.PackMode.VANILLA)
				{
					barY = bounds.y + (bounds.height / 2) + (DIAMETER / 2) - 2 + 1 + vanillaYOffset;
				} else {
					barY = bounds.y + (bounds.height / 2) + (DIAMETER / 2) - 2 + 3 + vanillaYOffset;
				}
				break;
			case ATTACHED:
			default:
				barY = bounds.y + (bounds.height / 2) + (DIAMETER / 2) - 2 + 1 + vanillaYOffset;
		}

		Rectangle bar = new Rectangle((int) barX, (int) barY, (int) barWidth, lineThickness.getValue());

		Rectangle background = new Rectangle((int) (barX - 1), (int) (barY - 1), BAR_WIDTH + 2, lineThickness.getValue() + 2);

		if (percent > 0) {
			if (config.showBackdrops()) {
				g.setColor(new Color(0x171717));
				g.fill(background);
			}

			int innerHeight = lineThickness.getValue();

			if (config.showBackdrops()) {
				Color backdropColor = config.getBackdropColor();

				Rectangle innerBackground = new Rectangle((int) (barX), (int) (barY), BAR_WIDTH, innerHeight);
				g.setColor(backdropColor);
				g.fill(innerBackground);
			}

			g.setStroke(new BasicStroke(1f, BasicStroke.CAP_BUTT, BasicStroke.JOIN_MITER));
			g.setColor(color);

			g.fill(bar);
		}
	}

}

