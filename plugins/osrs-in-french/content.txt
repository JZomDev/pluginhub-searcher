package com.playercoder1;

import lombok.extern.slf4j.Slf4j;

import java.io.BufferedReader;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.nio.charset.StandardCharsets;
import java.util.*;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

@Slf4j
public final class FrenchDialogTranslations
{
    private FrenchDialogTranslations() {}

    private static final String RESOURCE = "dialog_french.txt";

    private static final Map<String, String> EXACT = new HashMap<>();
    private static final Map<String, List<Rule>> RULES_BY_PREFIX = new HashMap<>();

    private static volatile boolean loaded = false;

    public static void init()
    {
        ensureLoaded();
    }

    public static String translateDialog(String englishText)
    {
        ensureLoaded();
        if (!loaded || englishText == null || englishText.isEmpty())
        {
            return null;
        }

        final String clean = TranslationFileLoader.visibleText(englishText).trim();
        if (clean.isEmpty())
        {
            return null;
        }

        final String norm = TranslationFileLoader.normKey(clean);

        String exact = EXACT.get(norm);
        if (exact != null)
        {
            return exact;
        }

        String prefix = firstWord(norm);
        List<Rule> rules = RULES_BY_PREFIX.get(prefix);
        if (rules == null)
        {
            rules = RULES_BY_PREFIX.get("");
            if (rules == null)
            {
                return null;
            }
        }

        for (Rule r : rules)
        {
            Matcher m = r.pattern.matcher(clean);
            if (m.matches())
            {
                return r.render(m);
            }
        }

        return null;
    }

    private static void ensureLoaded()
    {
        if (loaded)
        {
            return;
        }

        synchronized (FrenchDialogTranslations.class)
        {
            if (loaded)
            {
                return;
            }

            int count = loadRulesFromResource();
            if (count >= 0)
            {
                loaded = true;
                log.info("Loaded {} dialog translations from {}", count, RESOURCE);
            }
            else
            {
                log.error("Dialog translations failed to load. Dialogs will not be translated.");
            }
        }
    }

    private static int loadRulesFromResource()
    {
        InputStream in = FrenchDialogTranslations.class.getClassLoader().getResourceAsStream(RESOURCE);
        if (in == null)
        {
            log.error("Resource not found on classpath: {}", RESOURCE);
            return -1;
        }

        int loadedCount = 0;
        boolean firstLine = true;

        try (BufferedReader br = new BufferedReader(new InputStreamReader(in, StandardCharsets.UTF_8)))
        {
            String line;
            while ((line = br.readLine()) != null)
            {
                line = stripBom(line).trim();
                if (line.isEmpty() || line.startsWith("#"))
                {
                    continue;
                }

                if (firstLine && line.equalsIgnoreCase("english|french"))
                {
                    firstLine = false;
                    continue;
                }
                firstLine = false;

                int sep = line.indexOf('|');
                if (sep <= 0 || sep >= line.length() - 1)
                {
                    continue;
                }

                String en = line.substring(0, sep).trim();
                String fr = line.substring(sep + 1).trim();
                if (en.isEmpty() || fr.isEmpty())
                {
                    continue;
                }

                if (!looksTemplated(en))
                {
                    EXACT.put(TranslationFileLoader.normKey(en), fr);
                    loadedCount++;
                    continue;
                }

                Rule rule = Rule.compile(en, fr);
                if (rule != null)
                {
                    String prefix = firstWord(rule.prefixKey);
                    RULES_BY_PREFIX.computeIfAbsent(prefix, k -> new ArrayList<>()).add(rule);
                    loadedCount++;
                }
            }
        }
        catch (Exception e)
        {
            log.error("Failed reading resource {}", RESOURCE, e);
            return -1;
        }

        return loadedCount;
    }

    private static boolean looksTemplated(String s)
    {
        if (s == null) return false;

        if (s.indexOf('[') != -1 && s.indexOf(']') != -1)
        {
            return true;
        }

        int i = 0;
        while (true)
        {
            int open = s.indexOf('(', i);
            if (open == -1) break;
            int close = s.indexOf(')', open + 1);
            if (close == -1) break;

            String token = s.substring(open + 1, close).trim();
            if (!token.isEmpty() && !"s".equalsIgnoreCase(token))
            {
                boolean hasLetter = false;
                boolean allDigits = true;

                for (int k = 0; k < token.length(); k++)
                {
                    char c = token.charAt(k);
                    if (Character.isLetter(c)) hasLetter = true;
                    if (!Character.isDigit(c)) allDigits = false;
                }

                if (hasLetter && !allDigits)
                {
                    return true;
                }
            }

            i = close + 1;
        }

        return false;
    }

    private static String firstWord(String s)
    {
        if (s == null) return "";
        int sp = s.indexOf(' ');
        return sp > 0 ? s.substring(0, sp) : s;
    }

    private static String stripBom(String s)
    {
        if (s != null && !s.isEmpty() && s.charAt(0) == '\uFEFF')
        {
            return s.substring(1);
        }
        return s;
    }

    private static final class Rule
    {
        final String prefixKey;
        final Pattern pattern;
        final List<EnPlaceholder> enPlaceholders;
        final List<FrPart> frParts;

        private Rule(String prefixKey, Pattern pattern, List<EnPlaceholder> enPlaceholders, List<FrPart> frParts)
        {
            this.prefixKey = prefixKey;
            this.pattern = pattern;
            this.enPlaceholders = enPlaceholders;
            this.frParts = frParts;
        }

        static Rule compile(String enTemplate, String frTemplate)
        {
            ParseResult en = parseTemplate(enTemplate);
            ParseResult fr = parseTemplate(frTemplate);
            if (en == null || fr == null)
            {
                return null;
            }

            StringBuilder re = new StringBuilder("^");
            int groupIndex = 1;

            List<EnPlaceholder> placeholders = new ArrayList<>();

            for (TemplatePart p : en.parts)
            {
                if (p.isLiteral)
                {
                    re.append(literalToRegex(p.text));
                }
                else
                {
                    String token = p.text;

                    if (token.contains("/"))
                    {
                        String[] opts = token.split("/");
                        List<String> options = new ArrayList<>();
                        StringBuilder group = new StringBuilder("(");

                        for (String o : opts)
                        {
                            String opt = o.trim();
                            if (opt.isEmpty()) continue;
                            options.add(opt);
                            if (group.length() > 1) group.append("|");
                            group.append(Pattern.quote(opt));
                        }
                        group.append(")");

                        if (options.isEmpty())
                        {
                            re.append("(.+?)");
                            placeholders.add(EnPlaceholder.var(groupIndex++));
                        }
                        else
                        {
                            re.append(group);
                            placeholders.add(EnPlaceholder.option(groupIndex++, options));
                        }
                    }
                    else
                    {

                        re.append("(.+?)");
                        placeholders.add(EnPlaceholder.var(groupIndex++));
                    }
                }
            }

            re.append("$");

            Pattern pattern = Pattern.compile(re.toString(), Pattern.CASE_INSENSITIVE | Pattern.UNICODE_CASE);

            List<FrPart> frParts = new ArrayList<>();
            int placeholderCursor = 0;

            for (TemplatePart p : fr.parts)
            {
                if (p.isLiteral)
                {
                    frParts.add(FrPart.literal(p.text));
                }
                else
                {
                    List<String> frOptions = null;
                    String token = p.text;

                    if (token.contains("/"))
                    {
                        frOptions = new ArrayList<>();
                        for (String o : token.split("/"))
                        {
                            String t = o.trim();
                            if (!t.isEmpty()) frOptions.add(t);
                        }
                    }

                    frParts.add(FrPart.placeholder(placeholderCursor++, frOptions));
                }
            }

            String prefixKey = TranslationFileLoader.normKey(enTemplate.replaceAll("\\[[^\\]]*\\]", " ")
                    .replaceAll("\\([^)]*\\)", " ")).trim();

            return new Rule(prefixKey, pattern, placeholders, frParts);
        }

        String render(Matcher m)
        {
            StringBuilder out = new StringBuilder();

            for (FrPart part : frParts)
            {
                if (part.isLiteral)
                {
                    out.append(part.text);
                    continue;
                }

                int idx = part.placeholderIndex;
                if (idx < 0 || idx >= enPlaceholders.size())
                {
                    continue;
                }

                EnPlaceholder ph = enPlaceholders.get(idx);
                String matched = m.group(ph.groupIndex);
                if (matched == null) matched = "";

                if (ph.type == EnPlaceholderType.OPTION)
                {
                    int optIndex = ph.optionIndexOf(matched);

                    if (part.options != null && optIndex >= 0 && optIndex < part.options.size())
                    {
                        out.append(part.options.get(optIndex));
                    }
                    else
                    {
                        out.append(matched);
                    }
                }
                else
                {
                    String v = matched.trim();

                    String frItem = FrenchItemTranslations.translateItemName(v);
                    if (frItem != null)
                    {
                        out.append(frItem);
                        continue;
                    }

                    String frNpc = FrenchNpcTranslations.translateNpcName(v);
                    if (frNpc != null)
                    {
                        out.append(frNpc);
                        continue;
                    }

                    out.append(v);
                }
            }

            return out.toString();
        }
    }

    private enum EnPlaceholderType { OPTION, VAR }

    private static final class EnPlaceholder
    {
        final EnPlaceholderType type;
        final int groupIndex;
        final List<String> optionsLower;

        private EnPlaceholder(EnPlaceholderType type, int groupIndex, List<String> optionsLower)
        {
            this.type = type;
            this.groupIndex = groupIndex;
            this.optionsLower = optionsLower;
        }

        static EnPlaceholder option(int groupIndex, List<String> options)
        {
            List<String> lower = new ArrayList<>(options.size());
            for (String o : options) lower.add(o.toLowerCase(Locale.ROOT));
            return new EnPlaceholder(EnPlaceholderType.OPTION, groupIndex, lower);
        }

        static EnPlaceholder var(int groupIndex)
        {
            return new EnPlaceholder(EnPlaceholderType.VAR, groupIndex, null);
        }

        int optionIndexOf(String matched)
        {
            if (optionsLower == null || matched == null) return -1;
            String m = matched.toLowerCase(Locale.ROOT);
            for (int i = 0; i < optionsLower.size(); i++)
            {
                if (optionsLower.get(i).equals(m)) return i;
            }
            return -1;
        }
    }

    private static final class FrPart
    {
        final boolean isLiteral;
        final String text;
        final int placeholderIndex;
        final List<String> options;

        private FrPart(boolean isLiteral, String text, int placeholderIndex, List<String> options)
        {
            this.isLiteral = isLiteral;
            this.text = text;
            this.placeholderIndex = placeholderIndex;
            this.options = options;
        }

        static FrPart literal(String text) { return new FrPart(true, text, -1, null); }
        static FrPart placeholder(int idx, List<String> options) { return new FrPart(false, null, idx, options); }
    }

    private static final class TemplatePart
    {
        final boolean isLiteral;
        final String text;

        TemplatePart(boolean isLiteral, String text)
        {
            this.isLiteral = isLiteral;
            this.text = text;
        }
    }

    private static final class ParseResult
    {
        final List<TemplatePart> parts;
        ParseResult(List<TemplatePart> parts) { this.parts = parts; }
    }

    private static ParseResult parseTemplate(String template)
    {
        if (template == null) return null;

        List<TemplatePart> parts = new ArrayList<>();
        int i = 0;

        while (i < template.length())
        {
            int nextSq = template.indexOf('[', i);
            int nextPar = template.indexOf('(', i);

            int open;
            char openCh;

            if (nextSq == -1 && nextPar == -1)
            {
                parts.add(new TemplatePart(true, template.substring(i)));
                break;
            }
            else if (nextSq == -1)
            {
                open = nextPar; openCh = '(';
            }
            else if (nextPar == -1)
            {
                open = nextSq; openCh = '[';
            }
            else if (nextPar < nextSq)
            {
                open = nextPar; openCh = '(';
            }
            else
            {
                open = nextSq; openCh = '[';
            }

            char closeCh = (openCh == '[') ? ']' : ')';
            int close = template.indexOf(closeCh, open + 1);
            if (close == -1)
            {
                parts.add(new TemplatePart(true, template.substring(i)));
                break;
            }

            if (open > i)
            {
                parts.add(new TemplatePart(true, template.substring(i, open)));
            }

            String token = template.substring(open + 1, close).trim();

            if (openCh == '(' && "s".equalsIgnoreCase(token))
            {
                parts.add(new TemplatePart(true, "(s)"));
            }
            else
            {
                parts.add(new TemplatePart(false, token));
            }

            i = close + 1;
        }

        return new ParseResult(parts);
    }

    private static String literalToRegex(String literal)
    {
        if (literal == null || literal.isEmpty()) return "";

        String s = literal;
        StringBuilder re = new StringBuilder();
        StringBuilder chunk = new StringBuilder();
        int i = 0;

        while (i < s.length())
        {
            if (s.startsWith("(s)", i))
            {
                if (chunk.length() > 0)
                {
                    re.append(Pattern.quote(chunk.toString()));
                    chunk.setLength(0);
                }
                re.append("(?:s)?");
                i += 3;
                continue;
            }

            char ch = s.charAt(i);

            if (Character.isWhitespace(ch))
            {
                if (chunk.length() > 0)
                {
                    re.append(Pattern.quote(chunk.toString()));
                    chunk.setLength(0);
                }

                while (i < s.length() && Character.isWhitespace(s.charAt(i))) i++;
                re.append("\\s+");
                continue;
            }

            chunk.append(ch);
            i++;
        }

        if (chunk.length() > 0)
        {
            re.append(Pattern.quote(chunk.toString()));
        }

        return re.toString();
    }
}


package com.playercoder1;

import com.google.common.base.Strings;
import lombok.extern.slf4j.Slf4j;
import net.runelite.client.util.Text;

import java.util.HashMap;
import java.util.Locale;
import java.util.Map;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

@Slf4j
public final class FrenchItemTranslations
{
    private FrenchItemTranslations() {}

    private static final String RESOURCE = "item_french.txt";
    private static final Map<String, String> MAP = new HashMap<>();
    private static volatile boolean loaded = false;

    private static final Pattern DOSE_SUFFIX = Pattern.compile("^(.*?)(\\s*)\\((\\d+)\\)$");

    public static void init()
    {
        ensureLoaded();
    }

    public static String translateItemName(String englishName)
    {
        ensureLoaded();
        if (!loaded || Strings.isNullOrEmpty(englishName))
        {
            return null;
        }

        final String original = Text.removeTags(englishName).trim();
        if (original.isEmpty())
        {
            return null;
        }

        String base = original;
        String suffix = "";

        Matcher m = DOSE_SUFFIX.matcher(original);
        if (m.matches())
        {
            base = m.group(1).trim();

            suffix = m.group(2) + "(" + m.group(3) + ")";
        }

        String frBase = MAP.get(TranslationFileLoader.normKey(base));
        if (frBase != null)
        {
            return frBase + suffix;
        }

        String frExact = MAP.get(TranslationFileLoader.normKey(original));
        if (frExact != null)
        {
            return frExact;
        }

        return null;
    }

    private static void ensureLoaded()
    {
        if (loaded)
        {
            return;
        }

        synchronized (FrenchItemTranslations.class)
        {
            if (loaded)
            {
                return;
            }

            int count = TranslationFileLoader.loadPipeSeparated(RESOURCE, MAP);
            if (count >= 0)
            {
                loaded = true;
                log.info("Loaded {} item translations from {}", count, RESOURCE);
            }
            else
            {
                log.error("Item translations failed to load. Items will not be translated.");
            }
        }
    }

    private static String normKey(String s)
    {
        if (s == null)
        {
            return "";
        }

        String clean = Text.removeTags(s);
        return clean.trim().replaceAll("\\s+", " ").toLowerCase(Locale.ROOT);
    }
}


package com.playercoder1;

import java.util.Locale;
import java.util.Map;

public final class FrenchMenuTranslations {
    private FrenchMenuTranslations() {}

    private static String norm(String s) {
        return s.trim().replaceAll("\\s+", " ").toLowerCase(Locale.ROOT);
    }

    private static final Map < String, String > MENU_OPTIONS = Map.ofEntries(

            Map.entry("walk here", "Marcher ici"),
            Map.entry("follow", "Suivre"),
            Map.entry("trade with", "Échanger avec"),
            Map.entry("trade", "Échanger"),
            Map.entry("report", "Signaler"),
            Map.entry("examine", "Examiner"),
            Map.entry("inspect", "Inspecter"),
            Map.entry("attack", "Attaquer"),
            Map.entry("pickpocket", "Voler à la tire"),
            Map.entry("enter", "Entrer"),
            Map.entry("take", "Prendre"),
            Map.entry("talk-to", "Parler à"),
            Map.entry("commune", "Communier"),

            Map.entry("climb-up", "Monter"),
            Map.entry("climb-down", "Descendre"),
            Map.entry("walk-down", "Descendre"),
            Map.entry("pass-through", "Passer"),
            Map.entry("join", "Rejoindre"),
            Map.entry("observe", "Observer"),
            Map.entry("study", "Étudier"),
            Map.entry("read", "Lire"),
            Map.entry("view", "Voir"),
            Map.entry("tutorial", "Tutoriel"),

            Map.entry("bank", "Banque"),
            Map.entry("collect", "Collecter"),
            Map.entry("search", "Fouiller"),
            Map.entry("check", "Vérifier"),
            Map.entry("setup", "Configurer"),
            Map.entry("configure", "Configurer"),
            Map.entry("toggle warnings", "Activer/Désactiver les avertissements"),
            Map.entry("lock", "Verrouiller"),

            Map.entry("wield", "Manier"),
            Map.entry("wear", "Porter"),
            Map.entry("use", "Utiliser"),
            Map.entry("drop", "Jeter"),
            Map.entry("destroy", "Détruire"),
            Map.entry("empty", "Vider"),
            Map.entry("rub", "Frotter"),
            Map.entry("charge", "Charger"),
            Map.entry("uncharge", "Décharger"),
            Map.entry("revert", "Rétablir"),
            Map.entry("upgrade", "Améliorer"),
            Map.entry("armour", "Armure"),

            Map.entry("build", "Construire"),
            Map.entry("travel", "Voyager"),
            Map.entry("travel to plateform", "Voyager vers la plateforme"),
            Map.entry("teleport", "Téléporter"),
            Map.entry("teleport menu", "Menu de téléportation"),

            Map.entry("remove", "Retirer"),
            Map.entry("remove board advert", "Retirer l'annonce du panneau"),
            Map.entry("deposit", "Déposer"),
            Map.entry("dump", "Déverser"),
            Map.entry("exchange", "Échanger"),
            Map.entry("cast", "Lancer"),
            Map.entry("pray-at", "Prier à"),
            Map.entry("venerate", "Vénérer"),
            Map.entry("claim-trophies", "Réclamer les trophées"),
            Map.entry("sacrifice", "Sacrifier"),
            Map.entry("toggle-minerals", "Activer/Désactiver minéraux"),

            Map.entry("pay (north)", "Payer (nord)"),
            Map.entry("pay (south)", "Payer (sud)"),
            Map.entry("pay", "Payer"),

            Map.entry("top-floor", "Étage supérieur"),
            Map.entry("bottom-floor", "Étage inférieur"),

            Map.entry("chop down", "Abattre"),
            Map.entry("chop-down", "Abattre"),

            Map.entry("cook", "Cuisiner"),
            Map.entry("cook-at", "Cuisiner à"),

            Map.entry("pick-up", "Ramasser"),
            Map.entry("take-5", "Prendre-5"),
            Map.entry("take-10", "Prendre-10"),
            Map.entry("take-x", "Prendre-X"),

            Map.entry("get-rewards", "Obtenir les récompenses"),
            Map.entry("claim-rewards", "Réclamer les récompenses"),
            Map.entry("claim-tokens", "Réclamer les jetons"),
            Map.entry("claim-shield", "Réclamer le bouclier"),

            Map.entry("cancel-task", "Annuler la tâche"),

            Map.entry("eat", "Manger"),
            Map.entry("drink", "Boire"),

            Map.entry("cancel", "Annuler"),
            Map.entry("open", "Ouvrir"),
            Map.entry("close", "Fermer"),

            Map.entry("lure", "Leurre"),
            Map.entry("bait", "Appât"),
            Map.entry("small net", "Petit filet de pêche"),
            Map.entry("take-net", "Prendre le filet"),
            Map.entry("net", "Filet"),
            Map.entry("cage", "Cage"),
            Map.entry("harpoon", "Harpon"),

            Map.entry("mine", "Miner"),

            Map.entry("check-health", "Vérifier la santé"),
            Map.entry("guide", "Guide"),
            Map.entry("pick-from", "Cueillir sur"),
            Map.entry("rake", "Râteler"),
            Map.entry("harvest", "Récolter"),
            Map.entry("pick", "Cueillir"),

            Map.entry("loot", "Butin"),
            Map.entry("prices", "Prix"),
            Map.entry("decant", "Décanter"),
            Map.entry("climb-into", "Monter dans"),
            Map.entry("assignment", "Affectation"),
            Map.entry("rewards", "Récompenses"),
            Map.entry("smelt", "Fondre"),
            Map.entry("skull", "Tête de mort"),
            Map.entry("go-down", "Descendre"),
            Map.entry("climb", "Monter"),
            Map.entry("pull", "Tirer"),
            Map.entry("shut", "Fermer"),
            Map.entry("smith", "Forger"),

            Map.entry("check-count", "Vérifier le nombre"),
            Map.entry("slash", "Trancher"),
            Map.entry("relocate", "Déplacer"),
            Map.entry("redecorate", "Redécorer"),

            Map.entry("squeeze-through", "Se faufiler"),
            Map.entry("climb-through", "Grimper à travers"),
            Map.entry("peek", "Jeter un œil"),
            Map.entry("jump", "Sauter"),
            Map.entry("cross", "Traverser"),
            Map.entry("walk-across", "Marcher dessus"),
            Map.entry("climb-over", "Escalader"),
            Map.entry("walk-on", "Marcher dessus"),

            Map.entry("withdraw-1", "Retirer-1"),
            Map.entry("withdraw-5", "Retirer-5"),
            Map.entry("withdraw-10", "Retirer-10"),
            Map.entry("withdraw-x", "Retirer-X"),
            Map.entry("withdraw-all", "Retirer-tout"),
            Map.entry("withdraw-all-but-1", "Retirer-tout-sauf-1"),

            Map.entry("board", "Monter à bord"),
            Map.entry("board-previous", "Monter à bord (précédent)"),
            Map.entry("board-friend", "Monter à bord (ami)"),
            Map.entry("dock", "Accoster"),
            Map.entry("ferry", "Ferry"),

            Map.entry("quick-climb", "Monter rapidement"),
            Map.entry("quick-start", "Démarrage rapide"),
            Map.entry("solo-start", "Démarrer en solo"),
            Map.entry("sort-salvage", "Trier le butin"),
            Map.entry("cut", "Couper"),
            Map.entry("go-through", "Traverser"),
            Map.entry("look-at", "Regarder"),
            Map.entry("reinvigorate", "Revigorer"),
            Map.entry("check-approval", "Vérifier l’approbation"),
            Map.entry("animate", "Animer"),

            Map.entry("fill", "Remplir"),
            Map.entry("check-ammo", "Vérifier les munitions"),
            Map.entry("tether", "Attacher"),
            Map.entry("forfeit", "Abandonner"),
            Map.entry("pet", "Caresser"),
            Map.entry("shoo-away", "Chasser"),
            Map.entry("view-stats", "Voir les statistiques"),
            Map.entry("view-glory", "Voir Glory"),
            Map.entry("exit", "Sortie"),
            Map.entry("craft", "Fabriquer"),
            Map.entry("holiday-items", "Objets de fêtes"),
            Map.entry("redeem-code", "Utiliser le code"),
            Map.entry("take-boat", "Prendre le bateau"),
            Map.entry("buy-boat", "Acheter un bateau"),
            Map.entry("customise-boat", "Personnaliser le bateau"),
            Map.entry("recover-boat", "Récupérer le bateau"),

            Map.entry("take-cargo", "Prendre la cargaison"),
            Map.entry("take-last-cargo", "Prendre la dernière cargaison"),
            Map.entry("take-any-cargo", "Prendre n'importe quelle cargaison"),

            Map.entry("charter", "Affréter"),
            Map.entry("steal-from", "Voler à"),

            Map.entry("quick-deposits", "Dépôts rapides"),
            Map.entry("navigate", "Naviguer"),
            Map.entry("escape", "S'échapper"),
            Map.entry("disembark", "Débarquer"),
            Map.entry("collect-data", "Collecter des données"),
            Map.entry("tend-to", "S'occuper de"),
            Map.entry("rest", "Se reposer"),
            Map.entry("set-trap", "Poser un piège"),
            Map.entry("catch", "Attraper"),

            Map.entry("craft-rune", "Fabriquer une rune"),
            Map.entry("dismantle", "Démonter"),
            Map.entry("investigate", "Enquêter"),
            Map.entry("reset", "Réinitialiser"),

            Map.entry("lay", "Poser"),
            Map.entry("move", "Déplacer"),
            Map.entry("crawl-through", "Ramper à travers"),
            Map.entry("grapple", "S'agripper"),

            Map.entry("remove-room", "Supprimer la salle"),
            Map.entry("challenge-mode", "Mode défi"),
            Map.entry("items", "Objets"),

            Map.entry("enter-member", "Entrer (membre)"),
            Map.entry("enter-guest", "Entrer (invité)"),
            Map.entry("claim", "Réclamer"),
            Map.entry("use-rod", "Utiliser la canne"),
            Map.entry("private", "Privé"),
            Map.entry("pass", "Passer"),
            Map.entry("bury", "Enterrer"),
            Map.entry("toggle", "Activer/Désactiver"),
            Map.entry("unload", "Décharger"),
            Map.entry("load", "Charger"),
            Map.entry("break", "Briser"),
            Map.entry("inside", "À l'intérieur"),
            Map.entry("outside", "À l'extérieur"),
            Map.entry("group", "Groupe"),
            Map.entry("reminisce", "Se remémorer"),
            Map.entry("remove default", "Retirer par défaut"),
            Map.entry("recite-prayer", "Réciter une prière"),
            Map.entry("functions", "Fonctions"),
            Map.entry("chase", "Chasser"),
            Map.entry("interact", "Interagir"),
            Map.entry("combine", "Combiner"),
            Map.entry("check-keys", "Vérifier les clés"),
            Map.entry("sets", "Ensembles"),
            Map.entry("history", "Historique"),
            Map.entry("jump-over", "Sauter par dessus"),
            Map.entry("quick-board", "Monter rapidement"),
            Map.entry("descend", "Descendre"),
            Map.entry("buy", "Acheter")
            );

    public static String translateOption(String englishOption) {
        if (englishOption == null || englishOption.isEmpty()) {
            return null;
        }
        return MENU_OPTIONS.get(norm(englishOption));
    }
}
package com.playercoder1;

import lombok.extern.slf4j.Slf4j;

import java.util.HashMap;
import java.util.Map;

@Slf4j
public final class FrenchNpcTranslations
{
    private FrenchNpcTranslations() {}

    private static final String RESOURCE = "npc_french.txt";
    private static final Map<String, String> MAP = new HashMap<>();

    private static volatile boolean loaded = false;

    public static void init()
    {
        ensureLoaded();
    }

    public static String translateNpcName(String englishName)
    {
        ensureLoaded();
        if (!loaded || englishName == null || englishName.isEmpty())
        {
            return null;
        }

        return MAP.get(TranslationFileLoader.normKey(englishName));
    }

    private static void ensureLoaded()
    {
        if (loaded)
        {
            return;
        }

        synchronized (FrenchNpcTranslations.class)
        {
            if (loaded)
            {
                return;
            }

            int count = TranslationFileLoader.loadPipeSeparated(RESOURCE, MAP);
            if (count >= 0)
            {
                loaded = true;
                log.info("Loaded {} NPC translations from {}", count, RESOURCE);
            }
            else
            {
                log.error("NPC translations failed to load. NPCs will not be translated.");
            }
        }
    }
}

package com.playercoder1;

import com.google.common.base.Strings;
import lombok.extern.slf4j.Slf4j;

import java.util.HashMap;
import java.util.Locale;
import java.util.Map;

@Slf4j
public final class FrenchQuestTranslations
{
    private FrenchQuestTranslations() {}

    public static final int IFACE_QUESTLIST = 399;

    private static final String RESOURCE = "quest_french.txt";
    private static final Map<String, String> MAP = new HashMap<>();
    private static volatile boolean loaded = false;

    private static final String QUEST_LIST_EN = "quest list";
    private static final String QUEST_LIST_FR = "Liste des quêtes";

    private static final String COMPLETED_EN = "completed";
    private static final String COMPLETED_FR = "Terminées";

    private static final String QUEST_POINTS_EN = "quest points";
    private static final String QUEST_POINTS_FR = "Points de quête";

    public static void init()
    {
        ensureLoaded();
    }

    public static String translateQuestName(String englishQuestName)
    {
        ensureLoaded();
        if (!loaded || Strings.isNullOrEmpty(englishQuestName))
        {
            return null;
        }

        String normalized = normalizeApostrophes(englishQuestName);
        return MAP.get(TranslationFileLoader.normKey(normalized));
    }

    public static String translateQuestPanelLabelsRaw(String rawText)
    {
        if (rawText == null || rawText.isEmpty())
        {
            return null;
        }

        String visible = TranslationFileLoader.visibleText(rawText).trim();
        if (visible.isEmpty())
        {
            return null;
        }

        String norm = TranslationFileLoader.normKey(visible);
        String lower = visible.toLowerCase(Locale.ROOT);

        if (QUEST_LIST_EN.equals(norm))
        {
            String out = rawText.replaceAll("(?i)\\bQuest\\s+list\\b", QUEST_LIST_FR);
            return out.equals(rawText) ? null : out;
        }

        if (lower.startsWith(COMPLETED_EN))
        {
            String out = rawText.replaceFirst("(?i)\\bCompleted\\b", COMPLETED_FR);
            return out.equals(rawText) ? null : out;
        }

        if (lower.startsWith(QUEST_POINTS_EN))
        {
            String out = rawText.replaceFirst("(?i)\\bQuest\\s+Points\\b", QUEST_POINTS_FR);
            return out.equals(rawText) ? null : out;
        }

        return null;
    }

    private static void ensureLoaded()
    {
        if (loaded)
        {
            return;
        }

        synchronized (FrenchQuestTranslations.class)
        {
            if (loaded)
            {
                return;
            }

            int count = TranslationFileLoader.loadPipeSeparated(RESOURCE, MAP);
            if (count >= 0)
            {
                loaded = true;
                log.info("Loaded {} quest translations from {}", count, RESOURCE);
            }
            else
            {
                log.error("Quest translations failed to load. Quests will not be translated.");
            }
        }
    }

    private static String normalizeApostrophes(String s)
    {

        return s.replace('\u2019', '\'')
                .replace('\u2018', '\'')
                .replace('\u0060', '\'');
    }
}


package com.playercoder1;

import net.runelite.client.config.Config;
import net.runelite.client.config.ConfigGroup;
import net.runelite.client.config.ConfigItem;

@ConfigGroup(FrenchTranslationConfig.GROUP)
public interface FrenchTranslationConfig extends Config
{
    String GROUP = "osrsinfrench";

    @ConfigItem(
            keyName = "translateMenu",
            name = "Translate menu options",
            description = "Translate right-click menu options (Walk here, Take, etc.)"
    )
    default boolean translateMenu()
    {
        return true;
    }

    @ConfigItem(
            keyName = "translateNpcs",
            name = "Translate NPC names",
            description = "Translate NPC names"
    )
    default boolean translateNpcs()
    {
        return true;
    }

    @ConfigItem(
            keyName = "translateItems",
            name = "Translate item names",
            description = "Translate item names"
    )
    default boolean translateItems()
    {
        return true;
    }

    @ConfigItem(
            keyName = "translateDialogs",
            name = "Translate dialogs",
            description = "Translate NPC dialog text, dialog options, and \"Click here to continue\""
    )
    default boolean translateDialogs()
    {
        return true;
    }

    @ConfigItem(
            keyName = "translateQuests",
            name = "Translate quest list",
            description = "Translate quest list title, quest names, Completed, and Quest Points"
    )
    default boolean translateQuests()
    {
        return true;
    }
}

package com.playercoder1;

import com.google.inject.Provides;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.GameState;
import net.runelite.api.MenuEntry;
import net.runelite.api.NPC;
import net.runelite.api.events.BeforeRender;
import net.runelite.api.events.GameTick;
import net.runelite.api.events.MenuEntryAdded;
import net.runelite.api.events.PostItemComposition;
import net.runelite.api.widgets.Widget;
import net.runelite.api.widgets.WidgetUtil;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.plugins.PluginDescriptor;
import net.runelite.client.util.Text;

import javax.inject.Inject;
import java.util.HashMap;
import java.util.Map;

@Slf4j
@PluginDescriptor(
        name = "Osrs In French",
        description = "Translates partially the game in French"
)
public class FrenchTranslationPlugin extends Plugin
{
    private static final int IFACE_CHATBOX = 162;
    private static final int IFACE_PRIVATE_CHAT = 163;
    private static final int IFACE_FRIENDS_LIST = 429;

    private static final String CONTINUE_EN = "click here to continue";
    private static final String CONTINUE_FR = "Cliquez ici pour continuer";

    private static final int CHATLEFT_GROUP = 231;
    private static final int CHATRIGHT_GROUP = 217;
    private static final int CHATMENU_GROUP = 219;

    private static final int CHILD_NAME = 4;
    private static final int CHILD_CONTINUE = 5;
    private static final int CHILD_TEXT = 6;

    @Inject private Client client;
    @Inject private ClientThread clientThread;

    @Inject private FrenchTranslationConfig config;

    @Provides
    FrenchTranslationConfig provideConfig(ConfigManager configManager)
    {
        return configManager.getConfig(FrenchTranslationConfig.class);
    }

    private final Map<Integer, String> originalItemNames = new HashMap<>();
    private final Map<Integer, String> lastWidgetText = new HashMap<>();

    @Override
    protected void startUp()
    {
        FrenchItemTranslations.init();
        FrenchNpcTranslations.init();
        FrenchDialogTranslations.init();
        FrenchQuestTranslations.init();

        lastWidgetText.clear();
        log.info("French Translation started");
    }

    @Override
    protected void shutDown()
    {
        clientThread.invoke(() ->
        {
            try
            {
                for (Map.Entry<Integer, String> e : originalItemNames.entrySet())
                {
                    client.getItemDefinition(e.getKey()).setName(e.getValue());
                }
                originalItemNames.clear();
                lastWidgetText.clear();
            }
            catch (Exception ex)
            {
                log.debug("Could not fully revert item names: {}", ex.getMessage());
            }

            log.info("French Translation stopped");
        });
    }

    @Subscribe
    public void onPostItemComposition(PostItemComposition event)
    {
        if (!config.translateItems())
        {
            return;
        }

        final int itemId = event.getItemComposition().getId();

        String fr = FrenchItemTranslations.translateItemName(event.getItemComposition().getName());
        if (fr == null)
        {
            return;
        }

        originalItemNames.putIfAbsent(itemId, event.getItemComposition().getName());
        event.getItemComposition().setName(fr);
    }

    @Subscribe
    public void onMenuEntryAdded(MenuEntryAdded event)
    {
        MenuEntry entry = event.getMenuEntry();

        if (config.translateMenu())
        {
            String optFr = FrenchMenuTranslations.translateOption(entry.getOption());
            if (optFr != null)
            {
                entry.setOption(optFr);
            }
        }

        if (!config.translateNpcs() && !config.translateItems())
        {
            return;
        }

        String target = entry.getTarget();
        if (target == null || target.isEmpty())
        {
            return;
        }

        String newTarget = translateMenuTarget(entry, target);
        if (newTarget != null && !newTarget.equals(target))
        {
            entry.setTarget(newTarget);
        }
    }

    private String translateMenuTarget(MenuEntry entry, String targetWithTags)
    {
        String clean = Text.removeTags(targetWithTags);
        String base = stripCombatLevelSuffix(clean);

        NPC npc = entry.getNpc();
        if (npc != null)
        {
            if (!config.translateNpcs())
            {
                return null;
            }

            String frNpc = FrenchNpcTranslations.translateNpcName(npc.getName());
            if (frNpc == null)
            {
                frNpc = FrenchNpcTranslations.translateNpcName(base);
            }
            if (frNpc == null)
            {
                return null;
            }

            return targetWithTags.replace(base, frNpc);
        }

        int itemId = entry.getItemId();
        if (itemId > 0)
        {
            if (!config.translateItems())
            {
                return null;
            }

            String frItem = FrenchItemTranslations.translateItemName(base);
            if (frItem == null)
            {
                return null;
            }

            return targetWithTags.replace(base, frItem);
        }

        if (config.translateNpcs())
        {
            String fr = FrenchNpcTranslations.translateNpcName(base);
            if (fr != null)
            {
                return targetWithTags.replace(base, fr);
            }
        }

        if (config.translateItems())
        {
            String fr = FrenchItemTranslations.translateItemName(base);
            if (fr != null)
            {
                return targetWithTags.replace(base, fr);
            }
        }

        return null;
    }

    private static String stripCombatLevelSuffix(String s)
    {
        if (s == null) return null;
        return s.replaceAll("\\s*\\(level-\\d+\\)$", "");
    }

    @Subscribe
    public void onBeforeRender(BeforeRender event)
    {
        if (client.getGameState() != GameState.LOGGED_IN)
        {
            return;
        }

        if (config.translateDialogs())
        {
            translateDialogWidgets();
        }
    }

    @Subscribe
    public void onGameTick(GameTick tick)
    {
        if (client.getGameState() != GameState.LOGGED_IN)
        {
            return;
        }

        if (!config.translateNpcs() && !config.translateItems() && !config.translateQuests())
        {
            return;
        }

        for (Widget root : client.getWidgetRoots())
        {
            if (root == null)
            {
                continue;
            }

            int iface = WidgetUtil.componentToInterface(root.getId());
            if (iface == IFACE_CHATBOX || iface == IFACE_PRIVATE_CHAT || iface == IFACE_FRIENDS_LIST)
            {
                continue;
            }

            translateGeneralWidgetTree(root);
        }
    }

    private void translateDialogWidgets()
    {
        translateOneDialogWidget(CHATLEFT_GROUP, CHILD_NAME, true);
        translateOneDialogWidget(CHATLEFT_GROUP, CHILD_TEXT, false);
        translateOneDialogWidget(CHATLEFT_GROUP, CHILD_CONTINUE, false);

        translateOneDialogWidget(CHATRIGHT_GROUP, CHILD_NAME, true);
        translateOneDialogWidget(CHATRIGHT_GROUP, CHILD_TEXT, false);
        translateOneDialogWidget(CHATRIGHT_GROUP, CHILD_CONTINUE, false);

        translateChatmenuOptions();
    }

    private void translateOneDialogWidget(int groupId, int childId, boolean isNameWidget)
    {
        Widget w = client.getWidget(groupId, childId);
        if (w == null || w.isHidden())
        {
            return;
        }

        String raw = w.getText();
        if (raw == null || raw.isEmpty())
        {
            return;
        }

        String visible = TranslationFileLoader.visibleText(raw).trim();
        if (visible.isEmpty())
        {
            return;
        }

        if (TranslationFileLoader.normKey(visible).equals(CONTINUE_EN))
        {
            w.setText(preserveOuterTagsFast(raw, CONTINUE_FR));
            return;
        }

        if (isNameWidget)
        {
            if (config.translateNpcs())
            {
                String frNpc = FrenchNpcTranslations.translateNpcName(visible);
                if (frNpc != null)
                {
                    w.setText(preserveOuterTagsFast(raw, frNpc));
                }
            }
            return;
        }

        String fr = FrenchDialogTranslations.translateDialog(raw);
        if (fr != null)
        {
            w.setText(preserveOuterTagsFast(raw, fr));
        }
    }

    private void translateChatmenuOptions()
    {
        Widget options = client.getWidget(CHATMENU_GROUP, 1);

        if (options == null || options.isHidden())
        {
            return;
        }

        Widget[] kids = options.getDynamicChildren();
        if (kids == null)
        {
            return;
        }

        for (Widget k : kids)
        {
            if (k == null || k.isHidden())
            {
                continue;
            }

            String raw = k.getText();
            if (raw == null || raw.isEmpty())
            {
                continue;
            }

            String visible = TranslationFileLoader.visibleText(raw).trim();
            if (visible.isEmpty())
            {
                continue;
            }

            String fr = FrenchDialogTranslations.translateDialog(raw);
            if (fr != null)
            {
                k.setText(preserveOuterTagsFast(raw, fr));
            }
        }
    }

    private void translateGeneralWidgetTree(Widget widget)
    {
        if (widget == null || widget.isHidden())
        {
            return;
        }

        int iface = WidgetUtil.componentToInterface(widget.getId());
        if (iface == IFACE_CHATBOX)
        {
            return;
        }

        translateWidgetTextIfChanged(widget);

        Widget[] kids;

        kids = widget.getDynamicChildren();
        if (kids != null) for (Widget w : kids) translateGeneralWidgetTree(w);

        kids = widget.getStaticChildren();
        if (kids != null) for (Widget w : kids) translateGeneralWidgetTree(w);

        kids = widget.getNestedChildren();
        if (kids != null) for (Widget w : kids) translateGeneralWidgetTree(w);
    }

    private void translateWidgetTextIfChanged(Widget widget)
    {
        final String rawText = widget.getText();
        if (rawText == null || rawText.isEmpty())
        {
            return;
        }

        final int id = widget.getId();
        final String prev = lastWidgetText.get(id);
        if (rawText.equals(prev))
        {
            return;
        }

        final int iface = WidgetUtil.componentToInterface(id);

        if (config.translateQuests() && iface == FrenchQuestTranslations.IFACE_QUESTLIST)
        {

            String labelOut = FrenchQuestTranslations.translateQuestPanelLabelsRaw(rawText);
            if (labelOut != null)
            {
                widget.setText(labelOut);
                lastWidgetText.put(id, labelOut);
                return;
            }

            String visible = TranslationFileLoader.visibleText(rawText).trim();
            if (!visible.isEmpty())
            {
                String frQuest = FrenchQuestTranslations.translateQuestName(visible);
                if (frQuest != null)
                {
                    String newText = preserveOuterTagsFast(rawText, frQuest);
                    widget.setText(newText);
                    lastWidgetText.put(id, newText);
                    return;
                }
            }

            lastWidgetText.put(id, rawText);
            return;
        }

        String cleanVisible = TranslationFileLoader.visibleText(rawText).trim();
        if (cleanVisible.isEmpty())
        {
            lastWidgetText.put(id, rawText);
            return;
        }

        String fr = null;

        if (config.translateNpcs())
        {
            fr = FrenchNpcTranslations.translateNpcName(cleanVisible);
        }

        if (fr == null && config.translateItems())
        {
            fr = FrenchItemTranslations.translateItemName(cleanVisible);
        }

        if (fr != null)
        {
            String newText = preserveOuterTagsFast(rawText, fr);
            widget.setText(newText);
            lastWidgetText.put(id, newText);
        }
        else
        {
            lastWidgetText.put(id, rawText);
        }
    }

    private static String preserveOuterTagsFast(String original, String replacement)
    {
        if (original == null)
        {
            return replacement;
        }

        if (original.indexOf('<') == -1)
        {
            return replacement;
        }

        int i = 0;
        StringBuilder pre = new StringBuilder();
        while (i < original.length() && original.charAt(i) == '<')
        {
            int end = original.indexOf('>', i);
            if (end == -1) break;

            String tag = original.substring(i, end + 1);
            if (tag.startsWith("</"))
            {
                break;
            }

            pre.append(tag);
            i = end + 1;
        }

        int j = original.length();
        StringBuilder post = new StringBuilder();
        while (j > 0)
        {
            int start = original.lastIndexOf('<', j - 1);
            if (start == -1) break;

            int end = original.indexOf('>', start);
            if (end == -1) break;

            String tag = original.substring(start, end + 1);
            if (!tag.startsWith("</"))
            {
                break;
            }

            post.insert(0, tag);
            j = start;
        }

        if (pre.length() == 0 && post.length() == 0)
        {
            return replacement;
        }

        return pre + replacement + post;
    }
}


package com.playercoder1;

import lombok.extern.slf4j.Slf4j;
import net.runelite.client.util.Text;

import java.io.BufferedReader;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.nio.charset.StandardCharsets;
import java.util.Locale;
import java.util.Map;

@Slf4j
public final class TranslationFileLoader
{
    private TranslationFileLoader() {}

    public static int loadPipeSeparated(String resourceName, Map<String, String> out)
    {
        InputStream in = TranslationFileLoader.class.getClassLoader().getResourceAsStream(resourceName);
        if (in == null)
        {
            log.error("Resource not found on classpath: {}", resourceName);
            return -1;
        }

        int loaded = 0;
        boolean firstLine = true;

        try (BufferedReader br = new BufferedReader(new InputStreamReader(in, StandardCharsets.UTF_8)))
        {
            String line;
            while ((line = br.readLine()) != null)
            {
                line = stripBom(line).trim();
                if (line.isEmpty() || line.startsWith("#"))
                {
                    continue;
                }

                if (firstLine && line.toLowerCase(Locale.ROOT).equals("english|french"))
                {
                    firstLine = false;
                    continue;
                }
                firstLine = false;

                int sep = line.indexOf('|');
                if (sep <= 0 || sep >= line.length() - 1)
                {
                    continue;
                }

                String key = normKey(line.substring(0, sep));
                String val = line.substring(sep + 1).trim();

                if (!key.isEmpty() && !val.isEmpty())
                {
                    out.put(key, val);
                    loaded++;
                }
            }
        }
        catch (Exception e)
        {
            log.error("Failed reading resource {}", resourceName, e);
            return -1;
        }

        return loaded;
    }

    public static String visibleText(String s)
    {
        if (s == null)
        {
            return "";
        }

        String t = s
                .replace("<br>", " ")
                .replace("<br/>", " ")
                .replace("<br />", " ");

        t = Text.removeTags(t);
        t = t.replace('\u00A0', ' ');

        return t;
    }

    public static String normKey(String s)
    {
        String clean = visibleText(s);
        int n = clean.length();
        if (n == 0)
        {
            return "";
        }

        StringBuilder sb = new StringBuilder(n);
        boolean inWs = true;

        for (int i = 0; i < n; i++)
        {
            char c = clean.charAt(i);

            if (Character.isWhitespace(c))
            {
                inWs = true;
                continue;
            }

            if (inWs && sb.length() > 0)
            {
                sb.append(' ');
            }

            sb.append(Character.toLowerCase(c));
            inWs = false;
        }

        return sb.toString().trim();
    }

    private static String stripBom(String s)
    {
        if (s != null && !s.isEmpty() && s.charAt(0) == '\uFEFF')
        {
            return s.substring(1);
        }
        return s;
    }
}


package com.playercoder1;

import net.runelite.client.RuneLite;
import net.runelite.client.externalplugins.ExternalPluginManager;

public class ExamplePluginTest
{
	public static void main(String[] args) throws Exception
	{
		ExternalPluginManager.loadBuiltin(FrenchTranslationPlugin.class);
		RuneLite.main(args);
	}
}
