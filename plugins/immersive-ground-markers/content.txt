package com.ImmersiveGroundMarkers;

import net.runelite.client.config.Config;
import net.runelite.client.config.ConfigGroup;
import net.runelite.client.config.ConfigItem;

@ConfigGroup("ImmersiveGroundMarkers")
public interface ImmersiveGroundMarkersConfig extends Config
{

	enum OrientationMethod {
        RANDOM,
        MATCH_PLAYER,
		OPPOSE_PLAYER,
		FACE_PLAYER,
		FACE_AWAY_PLAYER,
        NORTH,
        SOUTH,
        EAST,
        WEST;
	}

	@ConfigItem(
		keyName = "markerOrientation", 
		name = "Marker Orientation", 
		description = "What angle to place markers at"
	)
	default OrientationMethod markerOrientation(){
		return OrientationMethod.RANDOM;
	}

}

/*
 * Copyright (c) 2021, Adam <Adam@sigterm.info>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.ImmersiveGroundMarkers;

import java.awt.Toolkit;
import java.awt.datatransfer.DataFlavor;
import java.awt.datatransfer.StringSelection;
import java.awt.datatransfer.UnsupportedFlavorException;
import java.awt.image.BufferedImage;
import java.io.IOException;
import java.time.Duration;
import java.time.Instant;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.Collections;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.Random;
import java.util.Set;
import java.util.function.Function;
import java.util.stream.Collectors;

import com.google.gson.Gson;
import com.google.gson.JsonSyntaxException;
import com.google.gson.reflect.TypeToken;
import com.google.inject.Provides;
import com.ImmersiveGroundMarkers.ImmersiveGroundMarkersConfig.OrientationMethod;
import com.google.common.base.Strings;
import com.google.common.util.concurrent.Runnables;

import javax.inject.Inject;

import lombok.Setter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Animation;
import net.runelite.api.ChatMessageType;
import net.runelite.api.Client;
import net.runelite.api.GameState;
import net.runelite.api.KeyCode;
import net.runelite.api.MenuAction;
import net.runelite.api.MenuEntry;
import net.runelite.api.Model;
import net.runelite.api.RuneLiteObject;
import net.runelite.api.Tile;
import net.runelite.api.coords.LocalPoint;
import net.runelite.api.coords.WorldPoint;
import net.runelite.api.events.ClientTick;
import net.runelite.api.events.GameStateChanged;
import net.runelite.api.events.GameTick;
import net.runelite.api.events.MenuEntryAdded;
import net.runelite.api.events.PostMenuSort;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.chat.QueuedMessage;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.events.ConfigChanged;
import net.runelite.client.events.ProfileChanged;
import net.runelite.client.game.chatbox.ChatboxPanelManager;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.plugins.PluginDescriptor;
import net.runelite.client.ui.ClientToolbar;
import net.runelite.client.ui.NavigationButton;
import net.runelite.client.util.ImageUtil;

@Slf4j
@PluginDescriptor(
	name = "Immersive Ground Markers"
)
public class ImmersiveGroundMarkersPlugin extends Plugin
{
	@Inject
	private Client client;

	@Inject
	private ClientThread clientThread;

	//@Inject
	//private ImmersiveGroundMarkersConfig config;

	@Inject
	private ConfigManager configManager;

	@Inject
	private ClientToolbar clientToolbar;

	@Inject
	private ChatMessageManager chatMessageManager;

	@Inject ChatboxPanelManager chatboxPanelManager;

	@Inject
	private Gson gson;

	private int lastPlane = -1;

	private MarkerOption markerToPlace = null;

	private boolean isPlacingTile = false;
	
	private RuneLiteObject placingObject;

	Random rnd = new Random();

	private static final String CONFIG_GROUP = "immersiveGroundMarkers";
	private static final String REGION_PREFIX = "imregion_";
	private static final String WALK_HERE = "Walk here";
	private static final String SET_HEADING = "Set heading";
	private static final String ORIENTATION_CONFIG = "markerOrientation";

	private final List<MarkerPoint> markers = new ArrayList<>();
	private final Map<MarkerPoint, List<RuneLiteObject>> objects = new LinkedHashMap<>();

	@Setter
	private boolean shiftPressed = false;

	@Setter
	private boolean escapePressed = false;

	private boolean clientHasFocus = false;

	private PropSelectPanel panel;
	private NavigationButton navButton;

	//Unload and remove from config all markers in loaded map regions
	public void clearMarkers(){
		int[] regions = client.getMapRegions();
		if(regions == null){
			return;
		}
		for(int region : regions){
			configManager.unsetConfiguration(CONFIG_GROUP, REGION_PREFIX + region);
		}
		removeObjects();
		loadMarkers();
	}

	//Copy of Runelite ground markers export
	public void exportMarkers(){
		int[] regions = client.getMapRegions();
		if(regions == null){
			return;
		}

		List<MarkerPoint> activePoints = Arrays.stream(regions)
			.mapToObj(region -> getPoints(region).stream())
			.flatMap(Function.identity())
			.collect(Collectors.toList());

		if(activePoints.isEmpty()){
			sendChatMessage("You have no ground markers to export.");
			return;
		}

		final String exportDump = gson.toJson(activePoints);

		Toolkit.getDefaultToolkit()
			.getSystemClipboard()
			.setContents(new StringSelection(exportDump), null);
		
		sendChatMessage(activePoints.size() + " ground markers were copied to your clipboard.");
	}
	//Copy of Runelite ground markers prompt for import
	protected void promptForImport()
	{
		final String clipboardText;
		try
		{
			clipboardText = Toolkit.getDefaultToolkit()
				.getSystemClipboard()
				.getData(DataFlavor.stringFlavor)
				.toString();
		}
		catch (IOException | UnsupportedFlavorException ex)
		{
			sendChatMessage("Unable to read system clipboard.");
			log.warn("error reading clipboard", ex);
			return;
		}

		log.debug("Clipboard contents: {}", clipboardText);
		if (Strings.isNullOrEmpty(clipboardText))
		{
			sendChatMessage("You do not have any ground markers copied in your clipboard.");
			return;
		}

		List<MarkerPoint> importPoints;
		try
		{
			// CHECKSTYLE:OFF
			importPoints = gson.fromJson(clipboardText, new TypeToken<List<MarkerPoint>>(){}.getType());
			// CHECKSTYLE:ON
		}
		catch (JsonSyntaxException e)
		{
			log.debug("Malformed JSON for clipboard import", e);
			sendChatMessage("You do not have any ground markers copied in your clipboard.");
			return;
		}

		if (importPoints.isEmpty())
		{
			sendChatMessage("You do not have any ground markers copied in your clipboard.");
			return;
		}

		chatboxPanelManager.openTextMenuInput("Are you sure you want to import " + importPoints.size() + " ground markers?")
			.option("Yes", () -> importGroundMarkers(importPoints))
			.option("No", Runnables.doNothing())
			.build();
	}

	//Copy of Runelite ground markers import
	public void importGroundMarkers(List<MarkerPoint> points){
		// regions being imported may not be loaded on client,
		// so need to import each bunch directly into the config
		// first, collate the list of unique region ids in the import
		Map<Integer, List<MarkerPoint>> regionGroupedPoints = points.stream()
			.collect(Collectors.groupingBy(MarkerPoint::getRegionID));

		// now import each region into the config
		regionGroupedPoints.forEach((regionId, groupedPoints) ->
		{
			// combine imported points with existing region points
			log.debug("Importing {} points to region {}", groupedPoints.size(), regionId);
			Collection<MarkerPoint> regionPoints = getPoints(regionId);

			List<MarkerPoint> mergedList = new ArrayList<>(regionPoints.size() + groupedPoints.size());
			// add existing points
			mergedList.addAll(regionPoints);

			// add new points
			for (MarkerPoint point : groupedPoints)
			{
				// filter out duplicates
				if (!mergedList.contains(point))
				{
					mergedList.add(point);
				}
			}

			saveMarkers(regionId, mergedList);
		});

		// reload points from config
		log.debug("Reloading points after import");
		loadMarkers();
		sendChatMessage(points.size() + " ground markers were imported from the clipboard.");
	}

	public void sendChatMessage(final String message){
		chatMessageManager.queue(QueuedMessage.builder()
			.type(ChatMessageType.CONSOLE)
			.runeLiteFormattedMessage(message)
			.build()
			);
	}

	//Using this as opposed to config.markerOrientation as that seemed to be having delays that were messing up selection
	public OrientationMethod getOrientationMethod(){
		try {
			return OrientationMethod.valueOf(configManager.getConfiguration(CONFIG_GROUP, ORIENTATION_CONFIG));
		} catch (Exception e) {
			return OrientationMethod.RANDOM;
		}
	}

	public void setOrientationMethod(OrientationMethod newMethod){
		configManager.setConfiguration(CONFIG_GROUP, ORIENTATION_CONFIG, newMethod);
	}
	
	@Override
	protected void startUp() throws Exception
	{
		//Add panel to sidebar
		panel = new PropSelectPanel(this, chatboxPanelManager);
		final BufferedImage icon = ImageUtil.loadImageResource(getClass(), "icon.png");
		
		navButton = NavigationButton.builder()
		.tooltip("Immersive Ground Markers")
		.icon(icon)
		.panel(panel)
		.build();

		clientToolbar.addNavigation(navButton);
	}

	@Override
	protected void shutDown() throws Exception
	{
		removeObjects();
		clientToolbar.removeNavigation(navButton);
	}

	@Subscribe
	public void onProfileChanged(ProfileChanged profileChanged)
	{
		loadMarkers();
	}

	//Hide, clear and stop placing current marker
	private void stopPlacing(){
		isPlacingTile = false;
		markerToPlace = null;
		placingObject.setActive(false);
		placingObject = null;
	}

	@Subscribe
	public void onClientTick(final ClientTick event){

		//Update location and orientation of marker preview
		if(isPlacingTile && placingObject != null){
			final Tile hoveredTile = client.getSelectedSceneTile();
			placingObject.setLocation(hoveredTile.getLocalLocation(), hoveredTile.getPlane());
			if( getOrientationMethod() != OrientationMethod.RANDOM){
				placingObject.setOrientation(getOrientation(markerToPlace.orientationOffset, hoveredTile.getLocalLocation()));
			}else{
				placingObject.setOrientation((placingObject.getOrientation() + 10) % 2048);
			}
		}
		
		//Delay by one client tick to account for focus switching from panel to client
		if (client.getCanvas().isFocusOwner()){
			if(!clientHasFocus){
				clientHasFocus = true;
			}else{
				escapePressed = client.isKeyPressed(KeyCode.KC_ESCAPE);
				shiftPressed = client.isKeyPressed(KeyCode.KC_SHIFT);
			}
		}else{
			clientHasFocus = false;
		}

		if(escapePressed && placingObject != null){
			stopPlacing();
		}
	}

	@Subscribe 
	public void onGameTick(GameTick event)
	{

		//TODO: Find a way to do as it's own subscribe. Similar to GameStateChanged?
		//Reload markers when switching planes
		int newPlane = client.getPlane();
		if(newPlane != lastPlane){
			loadMarkers();
			lastPlane = newPlane;
		}
	}

	@Subscribe
	public void onGameStateChanged(GameStateChanged gameStateChanged)
	{
		//Reload markers if state changes while logged in
		if (gameStateChanged.getGameState() != GameState.LOGGED_IN)
		{
			return;
		}

		// map region has just been updated
		loadMarkers();
	}

	@Subscribe
	public void onConfigChanged(ConfigChanged event){
		//Filter for orientation method in this plugin's config
		if(event.getGroup().equals(CONFIG_GROUP) && event.getKey().equals(ORIENTATION_CONFIG)){
			try {
				OrientationMethod o = OrientationMethod.valueOf(event.getNewValue());
				panel.reselectOrientationButton(o);
			} catch (IllegalArgumentException e) {
				log.debug("Failed to find Orientation method :{}", event.getNewValue());
			} catch(NullPointerException e){
				log.debug("Config value was null");
			}
		}else{
			return;
		}
	}

	@Provides
	ImmersiveGroundMarkersConfig provideConfig(ConfigManager configManager)
	{
		return configManager.getConfig(ImmersiveGroundMarkersConfig.class);
	}

	//Load all saved marker points for loaded regions
	Collection<MarkerPoint> getPoints(int regionId){
		String json = configManager.getConfiguration(CONFIG_GROUP, REGION_PREFIX + regionId);

		if(Strings.isNullOrEmpty((json))){
			return Collections.emptyList();
		}

		return gson.fromJson(json, new TypeToken<List<MarkerPoint>>(){}.getType());
	}
	
	//Create and setup runelite objects
	void loadObjects(Collection<MarkerPoint> points){
		for(MarkerPoint marker : points){

			//Load world point then find all instances of that in loaded regions
			WorldPoint wp = WorldPoint.fromRegion(marker.getRegionID(), marker.getRegionX(), marker.getRegionY(), marker.getZ());
			Collection<WorldPoint> lWorldPoints = WorldPoint.toLocalInstance(client, wp);

			//Getting shorter variable names than getters
			int modelId = marker.getModelId();
			int animationId = marker.getAnimation();
			short[] findColors = marker.getColorsToFind();
			short[] replaceColors = marker.getColorsToReplace();

			//Prevent crashes when trying to load models off client thread
			if( !client.isClientThread() ){
				log.debug("Not on client thread");
				return;
			}

			//Load model and animation
			Model model = client.loadModel(modelId, findColors, replaceColors);
			Animation modelAnim = client.loadAnimation(animationId);
			if(model == null){
				//Async load based on IdylRS Prop Hunt
				final Instant loadTimeOutInstant = Instant.now().plus(Duration.ofSeconds((5)));
				clientThread.invoke(() -> {
					if(Instant.now().isAfter(loadTimeOutInstant)){
						return true;
					}
					Model reloadedModel = client.loadModel(modelId, findColors, replaceColors);
					Animation reloadedAnimation = null;
					reloadedAnimation = client.loadAnimation(animationId);
					if(reloadedAnimation == null || reloadedModel == null){
						return false;
					}
					loadObjectInstances(reloadedModel, reloadedAnimation, lWorldPoints, marker);
					return true;
				});
			}else{
				loadObjectInstances(model, modelAnim, lWorldPoints, marker);
			}
			
		}
	}

	void loadObjectInstances(Model model, Animation animation, Collection<WorldPoint> instancedWorldPoints, MarkerPoint marker){
		if(!client.isClientThread()){
			log.debug("Attempting to load data on non-client thread");
			return;
		}
		for(WorldPoint point : instancedWorldPoints){
			RuneLiteObject rlObj = client.createRuneLiteObject();
			LocalPoint modelLocation = LocalPoint.fromWorld(client, point);
			if( modelLocation == null ){ 
				log.debug("Failed to get local location");
				continue;
			}
			rlObj.setModel(model);
			rlObj.setAnimation(animation);
			rlObj.setShouldLoop(true);
			rlObj.setLocation(modelLocation, point.getPlane());
			rlObj.setActive(true);
			rlObj.setOrientation(marker.getOrientation());
			if(!objects.containsKey(marker)){
				List<RuneLiteObject> newList = new ArrayList<>();
				objects.put(marker, newList);
			}
			objects.get(marker).add(rlObj);
		}
	}

	//Clear all objects/markers then reload
	void loadMarkers(){
		removeObjects();

		int[] regions = client.getMapRegions();

		if(regions == null){
			return;
		}

		for(int regionId : regions){
			log.debug("Loading points for region {}", regionId);
			Collection<MarkerPoint> regionPoints = getPoints(regionId);
			loadObjects(regionPoints);
			markers.addAll(regionPoints);
		}
		
	}

	//Deactivate all rl objects then clear marker and object arrays
	void removeObjects(){
		Set<MarkerPoint> keys = objects.keySet();
		for(MarkerPoint key : keys){
			for(RuneLiteObject obj : objects.get(key)){
				obj.setActive(false);
			}
		}
		objects.clear();
		markers.clear();
	}

	//Set config for given region
	void saveMarkers(int regionId, Collection<MarkerPoint> markers){
		if(markers == null || markers.isEmpty()){
			configManager.unsetConfiguration(CONFIG_GROUP, REGION_PREFIX + regionId);
			return;
		}
		String json = gson.toJson(markers);
		configManager.setConfiguration(CONFIG_GROUP, REGION_PREFIX + regionId, json);
	}

	//Convert model and orientation of existing marker
	private void remodelTile(MarkerPoint existing, MarkerOption newMarker, LocalPoint localPoint){
		Collection<MarkerPoint> tempPoints = new ArrayList<>(getPoints(existing.getRegionID()));
		var newPoint = new MarkerPoint(
			existing.getRegionID(), 
			existing.getRegionX(), 
			existing.getRegionY(), 
			existing.getZ(), 
			newMarker.modelID, 
			getOrientation(newMarker.orientationOffset, localPoint), 
			newMarker.animation, 
			newMarker.colorsToReplace, 
			newMarker.colorsToFind);
		tempPoints.remove(newPoint);
		tempPoints.add(newPoint);
		saveMarkers(existing.getRegionID(), tempPoints);
		loadMarkers();
	}

	//Setup a new marked tile
	private void markTile(LocalPoint localPoint, MarkerOption markerInfo)
	{	
		if (localPoint == null)
		{
			return;
		}
		
		WorldPoint worldPoint = WorldPoint.fromLocalInstance(client, localPoint);

		int regionId = worldPoint.getRegionID();

		List<MarkerPoint> tempPoints = new ArrayList<>(getPoints(regionId));

		//Setup empty marker
		if(markerInfo == null){
			MarkerPoint point = new MarkerPoint(
			regionId, 
			worldPoint.getRegionX(), 
			worldPoint.getRegionY(),
			worldPoint.getPlane(), 
			0, 
			0, 
			0, 
			null, 
			null);
			tempPoints.remove(point);
			List<RuneLiteObject> affectedObjects = objects.get(point);
			for (RuneLiteObject obj : affectedObjects) {
				obj.setActive(false);
			}
			objects.remove(point);

			saveMarkers(regionId, tempPoints);
	
			loadMarkers();
			return;
		}


		int orientation = getOrientation(markerInfo.orientationOffset, localPoint);

		MarkerPoint point = new MarkerPoint(
			regionId, 
			worldPoint.getRegionX(), 
			worldPoint.getRegionY(),
			worldPoint.getPlane(), 
			markerInfo.modelID, 
			orientation, 
			markerInfo.animation, 
			markerInfo.colorsToReplace, 
			markerInfo.colorsToFind);
		log.debug("Updating point: {} - {}", point, worldPoint);

		tempPoints.add(point);

		//Update saved markers
		saveMarkers(regionId, tempPoints);
		loadMarkers();
	}

	//Setup marker preview and enter state for placement
	void startPlacingTile(MarkerOption newMarker){

		//Don't start placing in menu
		if (client.getGameState() != GameState.LOGGED_IN){
			return;
		}

		//Get client thread to load the model as this is called from the panel
		final Instant loadTimeOutInstant = Instant.now().plus(Duration.ofSeconds((5)));
		clientThread.invoke(() -> {
			if(Instant.now().isAfter(loadTimeOutInstant)){
				return true;
			}
			Model model; ;
			if(newMarker.colorsToFind == null || newMarker.colorsToFind.length == 0 || newMarker.colorsToReplace == null || newMarker.colorsToReplace.length == 0 || newMarker.colorsToFind.length != newMarker.colorsToReplace.length){
				model = client.loadModel(newMarker.modelID);
			}else{
				model = client.loadModel(newMarker.modelID, newMarker.colorsToFind, newMarker.colorsToReplace);
			}
			if (placingObject != null){
				placingObject.setActive(false);
			}
			placingObject = client.createRuneLiteObject();
			LocalPoint modelLocation = client.getLocalPlayer().getLocalLocation();

			if(model == null){
				return false;
			}
			placingObject.setModel(model);
			placingObject.setLocation(modelLocation, client.getLocalPlayer().getWorldLocation().getPlane());
			placingObject.setActive(true);
			placingObject.setOrientation(getOrientation(newMarker.orientationOffset, modelLocation));
			isPlacingTile = true;
			markerToPlace = newMarker;
			return true;
		});
	}

	//Get orientation value for placed tile
	public int getOrientation(int orientationOffset, LocalPoint point){
		int xDiff;
		int yDiff;
		double angle;
		switch(getOrientationMethod()){
			case EAST:
				return (512 + orientationOffset) % 2048;
			case FACE_AWAY_PLAYER:
				xDiff = client.getLocalPlayer().getLocalLocation().getX() - point.getX();
				yDiff = client.getLocalPlayer().getLocalLocation().getY() - point.getY();
				//If on player, face oposite
				if(xDiff == 0 && yDiff == 0){
					return (client.getLocalPlayer().getOrientation() + orientationOffset) % 2048;
				}
				angle = 1.0 + Math.atan2(xDiff,yDiff)/(2.0*3.1415926536);
				return (orientationOffset + 1024 + (int)(angle * 2048)) % 2048;
			case FACE_PLAYER:
				xDiff = client.getLocalPlayer().getLocalLocation().getX() - point.getX();
				yDiff = client.getLocalPlayer().getLocalLocation().getY() - point.getY();
				//If on player, match facing
				if(xDiff == 0&& yDiff == 0){
					return (client.getLocalPlayer().getOrientation() + orientationOffset + 1024) % 2048;
				}
				angle = 1.0 + Math.atan2(xDiff,yDiff)/(2.0*3.1415926536);
				return (orientationOffset + (int)(angle * 2048)) % 2048;
			case MATCH_PLAYER:
				return (client.getLocalPlayer().getOrientation() + orientationOffset + 1024) % 2048;
			case NORTH:
				return orientationOffset;
			case OPPOSE_PLAYER:
				return (client.getLocalPlayer().getOrientation() + orientationOffset) % 2048;
			case RANDOM:
				return rnd.nextInt(2048);
			case SOUTH:
				return (1024 + orientationOffset) % 2048;
			case WEST:
				return (1536 + orientationOffset) % 2048;
			default:
				//Default return north
				return orientationOffset;

		}
	}

	@Subscribe
	public void onPostMenuSort(PostMenuSort postMenuSort){
		//Only change if the menu is not open
		if (client.isMenuOpen())
		{
			return;
		}

		final Tile selectedSceneTile = client.getSelectedSceneTile();
		if(selectedSceneTile == null){
			return;
		}

		//Filter for a tile that can be walkable
		MenuEntry[] menuEntries = client.getMenuEntries();
		boolean isWalkable = false;
		for (MenuEntry menuEntry : menuEntries) {
			String opt = menuEntry.getOption();
			if(opt.equals(WALK_HERE) || opt.equals(SET_HEADING)){
				isWalkable = true;
				break;
			}
		}
		if(!isWalkable) return;

		if(isPlacingTile && markerToPlace != null){

			final WorldPoint worldPoint = WorldPoint.fromLocalInstance(client, selectedSceneTile.getLocalLocation());
			final int regionID = worldPoint.getRegionID();
			var regionPoints = getPoints(regionID);
			var existingOpt = regionPoints.stream()
				.filter(p -> p.getRegionX() == worldPoint.getRegionX() && p.getRegionY() == worldPoint.getRegionY() && p.getZ() == worldPoint.getPlane())
				.findFirst();

			if(existingOpt.isPresent()){//Replace current model and orientation
				MarkerPoint existing = existingOpt.get();
				client.createMenuEntry(-1)
				.setOption("Redecorate")
				.setTarget("Tile")
				.setType(MenuAction.RUNELITE_HIGH_PRIORITY)
				.onClick(e -> {
					Tile target = client.getSelectedSceneTile();
					remodelTile(existing, markerToPlace, target.getLocalLocation());
					if(!shiftPressed){
						stopPlacing();
					}
				});
			}else{//Mark new tile
				client.createMenuEntry(-1)
				.setOption("Decorate")
				.setTarget("Tile")
				.setType(MenuAction.RUNELITE_HIGH_PRIORITY)
				.onClick(e -> {
					Tile target = client.getSelectedSceneTile();
					if (target != null)
					{	
						markTile(target.getLocalLocation(), markerToPlace);
					}
					if(!shiftPressed){
						stopPlacing();
					}
				});
			}

		}
	}

	@Subscribe
	public void onMenuEntryAdded(MenuEntryAdded event)
	{
		final boolean hotKeyPressed = client.isKeyPressed(KeyCode.KC_SHIFT);
		boolean isWalkable = event.getOption().equals(WALK_HERE) || event.getOption().equals(SET_HEADING);
		if(isWalkable &&  hotKeyPressed){ //If holding shift while menu is generated
			final Tile selectedSceneTile = client.getSelectedSceneTile();
			if(selectedSceneTile == null){
				return;
			}

			//Check for existing marker
			final WorldPoint worldPoint = WorldPoint.fromLocalInstance(client, selectedSceneTile.getLocalLocation());
			final int regionID = worldPoint.getRegionID();
			var regionPoints = getPoints(regionID);
			var existingOpt = regionPoints.stream()
				.filter(p -> p.getRegionX() == worldPoint.getRegionX() && p.getRegionY() == worldPoint.getRegionY() && p.getZ() == worldPoint.getPlane())
				.findFirst();
				
			if (existingOpt.isPresent()){

				client.createMenuEntry(-1)
				.setOption("Remove Prop From")
				.setTarget("Tile")
				.setType(MenuAction.RUNELITE)
				.onClick(e ->
				{
					Tile target = client.getSelectedSceneTile();
					if (target != null)
					{	
						markTile(target.getLocalLocation(), null);
					}
				});
		
			}
		}
	}
}
package com.ImmersiveGroundMarkers;

import net.runelite.api.coords.WorldPoint;

import lombok.EqualsAndHashCode;

@EqualsAndHashCode(exclude = {"id"})
public class ImmersiveMarker{

    public ImmersiveMarker(int modelId, WorldPoint worldPoint, int orientation){
        this.id = modelId;
        this.worldPoint = worldPoint;
        this.orientation = orientation;
    }

    public WorldPoint getWorldPoint(){
        return worldPoint;
    }

    public int getModelId(){
        return id;
    }

    public int getOrientation(){
        return orientation;
    }

    public void setModelId(int modelId){
        this.id = modelId;
    }
    
    private WorldPoint worldPoint;
    private int id;
    private int orientation;
}
package com.ImmersiveGroundMarkers;

public class MarkerOption{
    public MarkerOption(String name, int modelID){
        this.name = name;
        this.modelID = modelID;
        this.orientationOffset = 0;
        this.animation = -1;
    }
    public MarkerOption(String name, int modelID, int orientationOffset){
        this.name = name;
        this.modelID = modelID;
        this.orientationOffset = orientationOffset;
        this.animation = -1;
    }
    public MarkerOption(String name, int modelID, int orientationOffset, int animation){
        this.name = name;
        this.modelID = modelID;
        this.orientationOffset = orientationOffset;
        this.animation = animation;
    }
    public MarkerOption(String name, int modelID, int orientationOffset, int animation, short[] colorsToFind, short[] colorsToReplace){
        this.name = name;
        this.modelID = modelID;
        this.orientationOffset = orientationOffset;
        this.animation = animation;
        this.colorsToFind = colorsToFind;
        this.colorsToReplace = colorsToReplace;
    }
    public MarkerOption(String name, int modelID, short[] colorsToFind, short[] colorsToReplace){
        this.name = name;
        this.modelID = modelID;
        this.orientationOffset = 0;
        this.animation = -1;
        this.colorsToFind = colorsToFind;
        this.colorsToReplace = colorsToReplace;
    }
    
    public MarkerOption(String name, int modelID, int orientationOffset, short[] colorsToFind, short[] colorsToReplace){
        this.name = name;
        this.modelID = modelID;
        this.orientationOffset = orientationOffset;
        this.animation = -1;
        this.colorsToFind = colorsToFind;
        this.colorsToReplace = colorsToReplace;
    }
    String name;
    int modelID;
    int orientationOffset;
    int animation;
    short[] colorsToFind;
    short[] colorsToReplace;
}

package com.ImmersiveGroundMarkers;
//NULLPACK("", new String[]{"", "", "", ""}, new int[]{1,1,1,1})

public enum MarkerPack {
    ROCKS("Rocks", 
        new MarkerOption("Rocks", 868),
        new MarkerOption("Mining Rocks", 1390),
        new MarkerOption("Smooth Rock", 1799),
        new MarkerOption("Sandy Rock", 785),
        new MarkerOption("Light Sandy Rocks", 19305),
        new MarkerOption("Purple Crystals", 30680),
        new MarkerOption("Mud", 12027),
        new MarkerOption("Small Rocks", 49742),
        new MarkerOption("Small Rocks 2", 867),
        new MarkerOption("Small Rocks 3", 1407),
        new MarkerOption("Flat Rock", 1046),
        new MarkerOption("Gravel", 1098),
        new MarkerOption("Large Round Gravel", 12125),
        new MarkerOption("Snowy Spots", 1112),
        new MarkerOption("Seaweed Rock", 1517),
        new MarkerOption("Algae Rock", 2157),
        new MarkerOption("Bright Algae Rock", 2163),
        new MarkerOption("Rock X", 5285),
        new MarkerOption("Ice Chunks", 6332),
        new MarkerOption("Ice Specks", 21615),
        new MarkerOption("Glittering Ice", 21590, 0, 5734),
        new MarkerOption("Zanaris Gravel", 12642),
        new MarkerOption("TzHaar Rock", 17016),
        new MarkerOption("God Wars Bricks", 27756),
        new MarkerOption("God Wars Snow Gravel", 27829)
    ),
    SMOOTH_SYMBOLS("Smooth Symbols",
        new MarkerOption("Arrow", 4852),
        new MarkerOption("Zzz", 4626),
        new MarkerOption("Cross", 4856),
        new MarkerOption("Ban", 7669),
        new MarkerOption("Square Highlight", 40787),
        new MarkerOption("Warning", 15427),
        new MarkerOption("Star", 15272),
        new MarkerOption("Crosshair", 14947),
        new MarkerOption("Raised Arrow Grey", 5822),
        new MarkerOption("Raised Arrow Brown", 18389)
    ),
    NUMBERS("Numbers",
        new MarkerOption("0", 42993),
        new MarkerOption("1", 42992),
        new MarkerOption("2", 42995),
        new MarkerOption("3", 42990),
        new MarkerOption("4", 42991),
        new MarkerOption("5", 42997),
        new MarkerOption("6", 42989),
        new MarkerOption("7", 42988),
        new MarkerOption("8", 42996),
        new MarkerOption("9", 42994),
        new MarkerOption("Rough 0", 4863),
        new MarkerOption("Rough 1", 4864),
        new MarkerOption("Rough 2", 4865),
        new MarkerOption("Rough 3", 4866),
        new MarkerOption("Rough 4", 4867),
        new MarkerOption("Rough 5", 4868),
        new MarkerOption("Rough 6", 4869),
        new MarkerOption("Rough 7", 4870),
        new MarkerOption("Rough 8", 4871),
        new MarkerOption("Rough 9", 4872)
    ),
    MAP_SYMBOLS("Map Symbols",
        new MarkerOption("Quest", 7137),
        new MarkerOption("Anvil", 7130),
        new MarkerOption("Bank", 7131),
        new MarkerOption("Range", 7132),
        new MarkerOption("Fishing", 7133),
        new MarkerOption("Furnace", 7134),
        new MarkerOption("Pottery", 7135),
        new MarkerOption("Mine", 7136),
        new MarkerOption("Transport", 35795)
    ),
    WEAPONS_AND_TOOLS("Weapons/Tools",
        new MarkerOption("Staff", 2810, 1280),
        new MarkerOption("Sword", 2604, 1024),
        new MarkerOption("2H Sword", 2754, 1280),
        new MarkerOption("Arrow", 5049),
        new MarkerOption("Axe", 2544, 1024),
        new MarkerOption("Dragon Axe", 9959, 1000),
        new MarkerOption("Pickaxe", 2529, 950),
        new MarkerOption("Dragon Pickaxe", 28315, 1000),
        new MarkerOption("Spade", 2418, 256), //Todo: Find upright spade
        new MarkerOption("Seed Dibber", 7199, 1024),
        new MarkerOption("Rake", 7286, 512 + 256),
        new MarkerOption("Dragon Warhammer", 4041, 1080),
        new MarkerOption("Dragon Scimitar", 6033, 2048-256),
        new MarkerOption("Ancient Staff", 6235, 1024+256),
        new MarkerOption("Dharok's Axe", 6579, 2048-256),
        new MarkerOption("Verac's Flail", 6585, 150),
        new MarkerOption("Ahrim's Staff", 6590, 256),
        new MarkerOption("Torag's Hammers", 6591, 1024),
        new MarkerOption("Guthan's Spear", 6598, 256),
        new MarkerOption("Karil's Crossbow", 6604, 750),
        new MarkerOption("Archers Ring", 9930),
        new MarkerOption("Berserker Ring", 9931),
        new MarkerOption("Seers Ring", 9932),
        new MarkerOption("Warriors Ring", 9933)
    ),
    ROUGH_SYMBOLS("Rough Symbols",
        new MarkerOption("Arrow", 5125),
        new MarkerOption("Cross", 5139),
        new MarkerOption("Defend", 20566),
        new MarkerOption("Attack", 20561, 1792),
        new MarkerOption("Heal", 20569),
        new MarkerOption("No", 8684),
        new MarkerOption("Yes", 8685),
        new MarkerOption("Red Skull and Crossbones", 12110)
    ),
    FOLIAGE("Plants",
        new MarkerOption("Pastel Flowers", 237),
        new MarkerOption("Bright Blue Flowers", 1569),
        new MarkerOption("Lilies", 1581),
        new MarkerOption("Cornflower", 1610),
        new MarkerOption("Daisies", 1699),
        new MarkerOption("Thistle", 1724),
        new MarkerOption("Roses", 42562),
        new MarkerOption("Flax", 1668),
        new MarkerOption("Bush", 1565),
        new MarkerOption("Cactus", 44729),
        new MarkerOption("Cabbage", 1692),
        new MarkerOption("Grass", 4745),
        new MarkerOption("Fern", 1696),
        new MarkerOption("Curly Fern", 1617),
        new MarkerOption("Clover", 48256),
        new MarkerOption("Mushroom", 1686),
        new MarkerOption("Magic Mushroom", 1579),
        new MarkerOption("Mushroom Cluster", 3917),
        new MarkerOption("Chantrelle", 1609),
        new MarkerOption("Small Grass Tuft", 1601),
        new MarkerOption("Wheat", 1586),
        new MarkerOption("Red Vine", 1624),
        new MarkerOption("Green Vine", 1654),
        new MarkerOption("Small Leaves", 1723),
        new MarkerOption("Large Leaves", 22208),
        new MarkerOption("Trollheim Grass Tuft", 3794),
        new MarkerOption("Twigs Grass A", 3946),
        new MarkerOption("Twigs Grass B", 3949),
        new MarkerOption("Pitcher Plant", 7109),
        new MarkerOption("Mini Spirit Tree", 8256, 1024),
        new MarkerOption("Grass Tile Outline", 11584)
    ),
    WATERPLANTS("Water Plants",
        new MarkerOption("Cattails", 1674),
        new MarkerOption("Lilypads A", 1703),
        new MarkerOption("Lilypads B", 1704),
        new MarkerOption("Lilypad Single", 1705)
    ),
    BONES("Bones",
        new MarkerOption("Bones", 222),
        new MarkerOption("Half-Buried", 49004),
        new MarkerOption("Skull Pair", 46258),
        new MarkerOption("Skull Stack", 46172),
        new MarkerOption("Misc Bones", 40112),
        new MarkerOption("Burnt Skeleton", 29271),
        new MarkerOption("Fish Bones", 18177),
        new MarkerOption("Bone Pile", 10594),
        new MarkerOption("Skull", 2388, 1024),
        new MarkerOption("Skeleton", 2595),
        new MarkerOption("Long Skeleton", 1081, 512)
    ),
    SPOOKY("Spooky",
        new MarkerOption("Cobweb", 37309),
        new MarkerOption("Large Cobweb", 28260),
        new MarkerOption("Blood Splat 1", 42797),
        new MarkerOption("Blood Splat 2", 45073),
        new MarkerOption("Blood Splat 3", 35395, 1280),
        new MarkerOption("Miasma", 29475, 0, 7115),
        new MarkerOption("Poison", 36159, 1024),
        new MarkerOption("Ritual Star", 1131),
        new MarkerOption("Grave", 40589, 1024),
        new MarkerOption("Shadow X", 3062),
        new MarkerOption("Abyss Holes", 7420),
        new MarkerOption("Fairy Ring", 11940)
    ),
    HAZARDS("Hazards",
        new MarkerOption("Spikes", 703),
        new MarkerOption("Ghost Bear Trap", 12717),
        new MarkerOption("Runner Trap", 20681),
        new MarkerOption("Lava Pool", 29311)
    ),
    TILES("Tiles",
        new MarkerOption("Plain Tile", 1217),
        new MarkerOption("Boardwalk Tile", 1025),
        new MarkerOption("Hex Tile", 2151, 0, -1, new short[]{9511}, new short[]{24}),
        new MarkerOption("Small Beige Tile", 3639),
        new MarkerOption("Rogue's Den Small Tile", 7576),
        new MarkerOption("Rough Bricks Tile", 8693),
        new MarkerOption("Smooth Tile", 9131),
        new MarkerOption("Light Small Tile", 9136),
        new MarkerOption("Big Bricks Tile", 9560),
        new MarkerOption("Telekinetic Room Tile", 10604),
        new MarkerOption("White Tile", 12477),
        new MarkerOption("Plank Tile", 12480),
        new MarkerOption("Light Grid Tile", 12481),
        new MarkerOption("Grey Grid Tile", 12913),
        new MarkerOption("Ghost Tile", 12673),
        new MarkerOption("Ghost Skull Tile", 12882),
        new MarkerOption("Messy Bricks Tile", 14519),
        new MarkerOption("Plank Tile Border", 15074),
        new MarkerOption("Tarn's Lair Tile", 21486),
        new MarkerOption("Inlaid Parquet Tile", 22951),
        new MarkerOption("Dorgeshuun Tiles", 24359),
        new MarkerOption("Blue Grey Tiles", 25374),
        new MarkerOption("God Wars Tile", 27825, 490)
    ),
    BEACH("Beach",
        new MarkerOption("Orange Starfish", 1414, 512),
        new MarkerOption("Tan Starfish", 1515, 512),
        new MarkerOption("Yellow Shell", 1420),
        new MarkerOption("Scallop Shell", 1426),
        new MarkerOption("Cone Shell", 1462, 1500),
        new MarkerOption("Oyster", 2363, 1024),
        new MarkerOption("Seaweed", 2370)
    ),
    MAGIC("Magical effects",
        new MarkerOption("Ancient Essence", 47096),
        new MarkerOption("Stardust", 41598),
        new MarkerOption("Lightning", 28081, 0, 9958),
        new MarkerOption("Dark Circle", 6399),
        new MarkerOption("Golden Glow", 3567),
        new MarkerOption("Arcane Circle", 3094, 0, 670),
        new MarkerOption("Fireworks", 411, 0, 913),
        //new MarkerOption("Fire", 2289, 0, 473),
        new MarkerOption("Red Sparks", 3668, 0, 1076),
        new MarkerOption("Ecto Slime", 5263)
    ),
    CRITTERS("Critters",
        new MarkerOption("Butterfly", 3023, 1024, 362),
        new MarkerOption("Puffin", 22792, 1024, 5873),
        new MarkerOption("Seagull", 26874, 1024, 6815),
        new MarkerOption("Squirrel", 11723, 1024, 3211),
        new MarkerOption("Racoon", 11724, 1024, 3213),
        new MarkerOption("Ferret", 19373, 1024, 5188),
        //new MarkerOption("Crab", 0),//TODO: Multimodel
        new MarkerOption("Rat", 9610, 1024, 2704),
        new MarkerOption("Duckling", 26872, 1024, 6818),
        new MarkerOption("Three Ducklings", 26871, 1024, 6821),
        new MarkerOption("Spiderling", 47399, 1024, 6247),
        new MarkerOption("Black Chinchompa", 19371, 1024, 5182, new short[]{5169,7343,7335,7339,7343,165}, new short[]{20,33,12,37,45,49}),
        new MarkerOption("Grey Chinchompa", 19371, 1024, 5182),
        new MarkerOption("Scorpion", 24612, 1024, 6258),
        new MarkerOption("Pet Rock", 4271),
        new MarkerOption("Dog", 7755, 1024),
        new MarkerOption("Crow", 26851, 1024, 6785),
        new MarkerOption("Monkey", 7744, 1024, 222),
        //new MarkerOption("Kebbit", 0),//TODO: Multimodel
        new MarkerOption("Orange Salamander", 19391, 1024, 5263, new short[]{61}, new short[]{6059}),
        new MarkerOption("Piglet", 7364, 1024, 2166),
        new MarkerOption("Balloon Animal", 10736, 1024, 3049),
        new MarkerOption("Swarm", 2950, 0, 0)
    ),
    MISCELLANEOUS("Miscellaneous",
        new MarkerOption("Rope", 21517),
        new MarkerOption("Cannonballs", 16517),
        new MarkerOption("Scroll", 10347, 1024),
        new MarkerOption("Potion", 1736),
        new MarkerOption("Spotlight", 3698, 1536),
        new MarkerOption("Puddle", 1026),   
        new MarkerOption("Puddle Outline", 7783),
        new MarkerOption("Bearskin", 1042, 1024),
        new MarkerOption("Bottles", 1084),
        new MarkerOption("Small Hay", 1572),
        new MarkerOption("Large Hay", 1725),
        new MarkerOption("Party Balloons", 2227),
        new MarkerOption("Key", 2372, 768),
        new MarkerOption("Pin", 3046),
        new MarkerOption("Footprints", 3910),
        new MarkerOption("Chain", 9532),
        new MarkerOption("Escape Crystal", 11047),
        new MarkerOption("Candles", 11827, 0, 2564),
        new MarkerOption("Zulrah Scales", 19213),
        new MarkerOption("Rectangular Drain", 18673),
        new MarkerOption("Round Drain", 22713),
        new MarkerOption("Finish Line", 21586)
    ),
    /*SHADOWS("Shades", //TODO: Model Colours
        new MarkerOption("", 0),
        new MarkerOption("", 0),
        new MarkerOption("", 0),
        new MarkerOption("", 0),
        new MarkerOption("", 0)
    )*/
    HANANNIE("Hanannie",
        new MarkerOption("Entling", 49908, 1024, 10537),
        new MarkerOption("Cat on Stool", 42214, 768, 8231),
        new MarkerOption("Goblin", 43835, 1024, 6181),
        new MarkerOption("Swarm", 2950, 0, 0),
        new MarkerOption("Duke Pet", 49195, 1024, 10217),
        new MarkerOption("Floating Fish", 13811, 1024, 3442),
        new MarkerOption("Fake Man", 4065, 1024),
        //new MarkerOption("Rock Crab Rock", 4400, 0, 1315 ), //TODO: Multimodel
        //new MarkerOption("Suspect", 0), //TODO: Multimodel
        //new MarkerOption("Leprechaun", 0), //TODO: Multimodel
        new MarkerOption("Shark Fin", 19778, 1024, 10),
        new MarkerOption("Chompy Toad", 3447, 1024, 1020),
        new MarkerOption("Fly Trap", 14207, 1024),
        new MarkerOption("Fox Trap", 49899),
        new MarkerOption("Toy Soldier", 13227, 1024),
        new MarkerOption("Skavid", 20388, 1024, 257)
    )
    ;

    final MarkerOption[] markers;

    String displayName;
    private MarkerPack(String displayName, MarkerOption... options){
        this.displayName = displayName;
        this.markers = options;
    }
}

/*
 * Copyright (c) 2018, TheLonelyDev <https://github.com/TheLonelyDev>
 * Copyright (c) 2018, Adam <Adam@sigterm.info>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

 //Code from Runelite Ground Markers
package com.ImmersiveGroundMarkers;

import javax.annotation.Nullable;

import lombok.EqualsAndHashCode;
import lombok.Value;

@Value
@EqualsAndHashCode(exclude = {"orientation", "modelId", "animation", "colorsToReplace", "colorsToFind"})
public class MarkerPoint {
    private int regionID;
    private int regionX;
    private int regionY;
    private int z;
    private int modelId;
    private int orientation;
    private int animation;
    @Nullable
    private short[] colorsToReplace;
    @Nullable
    private short[] colorsToFind;
}

package com.ImmersiveGroundMarkers;

import net.runelite.client.game.chatbox.ChatboxPanelManager;
import net.runelite.client.input.KeyListener;
import net.runelite.client.ui.PluginPanel;
import net.runelite.client.util.ImageUtil;

import java.awt.event.KeyEvent;
import java.awt.Color;
import java.awt.Component;
import java.awt.GridBagConstraints;
import java.awt.GridBagLayout;
import java.awt.GridLayout;
import java.awt.RenderingHints.Key;
import java.awt.image.BufferedImage;
import java.security.AlgorithmConstraints;

import javax.swing.BoxLayout;
import javax.swing.ButtonGroup;
import javax.swing.GroupLayout;
import javax.swing.ImageIcon;
import javax.swing.JButton;
import javax.swing.JLabel;
import javax.swing.JPanel;
import javax.swing.JSpinner;
import javax.swing.SpinnerModel;
import javax.swing.SpinnerNumberModel;
import javax.swing.SwingConstants;
import javax.swing.GroupLayout.Alignment;
import javax.swing.border.EmptyBorder;

import com.ImmersiveGroundMarkers.ImmersiveGroundMarkersConfig.OrientationMethod;
import com.google.common.util.concurrent.Runnables;


public class PropSelectPanel extends PluginPanel implements KeyListener{

    private final ImmersiveGroundMarkersPlugin plugin;

    private JPanel titlePanel;

    private JLabel panelTitle;
    private JLabel helpComponent;

    private JPanel customPropPanel;
    private JSpinner idSelectSpinner;

    private final JPanel orientationButtonPanel;
    private final ButtonGroup orientationSelectionGroup;

    private final JButton northButton;
    private final JButton eastButton;
    private final JButton southButton;
    private final JButton westButton;
    private final JButton facePlayerButton;
    private final JButton faceAwayFromPlayerButton;
    private final JButton faceSameAsPlayerButton;
    private final JButton faceOppositePlayerButton;
    private final JButton randomButton;

    //private JButton prevButton;

    private JPanel groupControlPanel;
    private JButton prevGroupButton;
    private JLabel groupTitle;
    private JButton nextGroupButton;

    private JButton clearMarkersButton;
    private JButton exportMarkersButton;
    private JButton importMarkersButton;

    private JPanel propButtonsPanel;

    private MarkerPack currentPack;

    public PropSelectPanel(ImmersiveGroundMarkersPlugin plugin, ChatboxPanelManager chatboxPanelManager){
        //Variable init
        this.plugin = plugin;
        currentPack = MarkerPack.ROCKS;

        GroupLayout fullLayout = new GroupLayout(this);
        fullLayout.setAutoCreateGaps(true);
        setLayout(fullLayout);
        
        //Import/export/clear buttons
        clearMarkersButton = new JButton("Clear");
        clearMarkersButton.setToolTipText("Clears all markers in loaded regions.\nWill check for confirmation.");
        clearMarkersButton.addActionListener(l -> {
            chatboxPanelManager.openTextMenuInput("Are you sure you want to clear all loaded ground markers?")
			.option("Yes", () -> plugin.clearMarkers())
			.option("No", Runnables.doNothing())
			.build();
        });
        exportMarkersButton = new JButton("Export");
        exportMarkersButton.setToolTipText("Export all markers in loaded regions to the clipboard.");
        exportMarkersButton.addActionListener(l -> plugin.exportMarkers());
        importMarkersButton = new JButton("Import");
        importMarkersButton.setToolTipText("Import markers from clipboard.\nWill check for confirmation.");
        importMarkersButton.addActionListener(l -> plugin.promptForImport());

        titlePanel = new JPanel();
        titlePanel.setLayout(new GridBagLayout());
        GridBagConstraints helpConstraints = new GridBagConstraints();
        GridBagConstraints titleAConstraints = new GridBagConstraints();

        try {
            BufferedImage helpIcon = ImageUtil.loadImageResource(getClass(), "help.png");
            helpComponent = new JLabel(new ImageIcon(helpIcon));
        } catch (Exception e) {
            helpComponent = new JLabel("Help");
        }
        helpComponent.setSize(10, 10);
        helpComponent.setToolTipText("- Select a prop from below, then left click in the world to place it.\n- Hold Left Shift while placing to continue placing.\n- Press Escape to cancel placement.\n- Shift + Right Click on a tile with a prop to remove it.");
        helpConstraints.anchor = GridBagConstraints.LINE_END;
        helpConstraints.gridx = 2;
        helpConstraints.gridy = 0;
        helpConstraints.gridwidth = 3;
        helpConstraints.gridheight = 1;
        helpConstraints.weightx = 1.0;
        helpConstraints.weighty = 1.0;
        helpConstraints.ipadx = 8;
        helpConstraints.ipady = 4;

        //Orientation Selection
        panelTitle = new JLabel("Orientation");
        titleAConstraints.anchor = GridBagConstraints.CENTER;
        titleAConstraints.gridx = 1;
        titleAConstraints.gridy = 0;
        titleAConstraints.gridwidth = 3;
        titleAConstraints.gridheight = 1;
        titleAConstraints.weightx = 1.0;
        titleAConstraints.weighty = 1.0;

        titlePanel.add(panelTitle, titleAConstraints);
        titlePanel.add(helpComponent, helpConstraints);
        
        //Custom Prop Panel
        /*customPropPanel = new JPanel();
        JButton placeCustomButton = new JButton("Place");
        placeCustomButton.addKeyListener(this);
        placeCustomButton.addActionListener(l -> {
            placeCustomProp();
        });

        SpinnerModel idSelectModel = new SpinnerNumberModel(0, 0, 100000, 1);
        idSelectSpinner = new JSpinner(idSelectModel);
        
        customPropPanel.add(idSelectSpinner);
        customPropPanel.add(placeCustomButton);*/

        orientationButtonPanel = new JPanel();
        GroupLayout orientationLayout = new GroupLayout(orientationButtonPanel);

        orientationButtonPanel.setLayout(orientationLayout);

        orientationSelectionGroup = new ButtonGroup();

        northButton = new JButton("North");
        setupOrientationButton(northButton, OrientationMethod.NORTH, "Point North");

        eastButton = new JButton("East");
        setupOrientationButton(eastButton, OrientationMethod.EAST, "Point East");
        
        southButton = new JButton("South");
        setupOrientationButton(southButton, OrientationMethod.SOUTH, "Point South");

        westButton = new JButton("West");
        setupOrientationButton(westButton, OrientationMethod.WEST, "Point West");

        facePlayerButton = new JButton("Towards");
        setupOrientationButton(facePlayerButton, OrientationMethod.FACE_PLAYER, "Point towards the Player");

        faceAwayFromPlayerButton = new JButton("Away");
        setupOrientationButton(faceAwayFromPlayerButton, OrientationMethod.FACE_AWAY_PLAYER, "Point away from the Player");

        faceSameAsPlayerButton = new JButton("Match");
        setupOrientationButton(faceSameAsPlayerButton, OrientationMethod.MATCH_PLAYER, "Point the same way the Player is facing");

        faceOppositePlayerButton = new JButton("Oppose");
        setupOrientationButton(faceOppositePlayerButton, OrientationMethod.OPPOSE_PLAYER, "Point the opposite way the Player is facing");

        randomButton = new JButton("Random");
        setupOrientationButton(randomButton, OrientationMethod.RANDOM, "Point in a random direction");

        orientationSelectionGroup.add(northButton);
        orientationSelectionGroup.add(eastButton);
        orientationSelectionGroup.add(southButton);
        orientationSelectionGroup.add(westButton);
        orientationSelectionGroup.add(facePlayerButton);
        orientationSelectionGroup.add(faceAwayFromPlayerButton);
        orientationSelectionGroup.add(faceSameAsPlayerButton);
        orientationSelectionGroup.add(faceOppositePlayerButton);
        orientationSelectionGroup.add(randomButton);
        reselectOrientationButton(plugin.getOrientationMethod());

        final int hMin = 0, hPref = 40, hMax = 95;
        final int vMin = 0, vPref = 40, vMax = 60;

        orientationLayout.setVerticalGroup(
            orientationLayout.createSequentialGroup()
            .addGroup(orientationLayout.createParallelGroup()
            .addComponent(faceSameAsPlayerButton, vMin, vPref, vMax)
            .addComponent(northButton, vMin, vPref, vMax)
            .addComponent(facePlayerButton, vMin, vPref, vMax))

            .addGroup(orientationLayout.createParallelGroup()
            .addComponent(westButton, vMin, vPref, vMax)
            .addComponent(randomButton, vMin, vPref, vMax)
            .addComponent(eastButton, vMin, vPref, vMax))

            .addGroup(orientationLayout.createParallelGroup()
            .addComponent(faceOppositePlayerButton, vMin, vPref, vMax)
            .addComponent(southButton, vMin, vPref, vMax)
            .addComponent(faceAwayFromPlayerButton, vMin, vPref, vMax))
        );

        orientationLayout.setHorizontalGroup(
            orientationLayout.createSequentialGroup()
            .addGroup(orientationLayout.createParallelGroup()
            .addComponent(faceSameAsPlayerButton, hMin, hPref, hMax)
            .addComponent(westButton, hMin, hPref, hMax)
            .addComponent(faceOppositePlayerButton, hMin, hPref, hMax))

            .addGroup(orientationLayout.createParallelGroup()
            .addComponent(northButton, hMin, hPref, hMax)
            .addComponent(randomButton, hMin, hPref, hMax)
            .addComponent(southButton, hMin, hPref, hMax))

            .addGroup(orientationLayout.createParallelGroup()
            .addComponent(facePlayerButton, hMin, hPref, hMax)
            .addComponent(eastButton, hMin, hPref, hMax)
            .addComponent(faceAwayFromPlayerButton, hMin, hPref, hMax))
        );

        //Pack selection
        groupControlPanel = new JPanel();
        groupControlPanel.setLayout(new GridBagLayout());
        groupControlPanel.setBorder(new EmptyBorder(5, 0, 5, 0));
        
        final double weightXPackSelectionButtons = 0.2;
        GridBagConstraints prevConstraints = new GridBagConstraints();
        prevConstraints.weightx = weightXPackSelectionButtons;
        prevConstraints.gridx = 0;
        prevConstraints.gridy = 0;
        prevConstraints.anchor = GridBagConstraints.FIRST_LINE_START;
        GridBagConstraints titleConstraints = new GridBagConstraints();
        titleConstraints.fill = GridBagConstraints.HORIZONTAL;
        titleConstraints.gridx = 1;
        titleConstraints.gridy = 0;
        titleConstraints.anchor = GridBagConstraints.PAGE_START;
        GridBagConstraints nextConstraints = new GridBagConstraints();
        nextConstraints.weightx = weightXPackSelectionButtons;
        nextConstraints.gridx = 2;
        nextConstraints.gridy = 0;
        nextConstraints.anchor = GridBagConstraints.FIRST_LINE_END;

        prevGroupButton = new JButton("<");
        prevGroupButton.addActionListener(l -> {
            int nextPackOrdinal = (MarkerPack.values().length + currentPack.ordinal() - 1)%MarkerPack.values().length;
            currentPack = MarkerPack.values()[nextPackOrdinal];
            groupTitle.setText(currentPack.displayName);
            generatePropButtons();
        });
        prevGroupButton.setToolTipText("Previous");

        nextGroupButton = new JButton(">");
        nextGroupButton.addActionListener(l -> {
            int nextPackOrdinal = (currentPack.ordinal() + 1)%MarkerPack.values().length;
            currentPack = MarkerPack.values()[nextPackOrdinal];
            groupTitle.setText(currentPack.displayName);
            generatePropButtons();
        });
        nextGroupButton.setToolTipText("Next");

        groupTitle = new JLabel(currentPack.displayName, SwingConstants.CENTER);
        groupTitle.setToolTipText("Click and drop props into the world.\nShift-click to keep placing.\nEscape to cancel placement.");

        groupControlPanel.add(prevGroupButton, prevConstraints);
        groupControlPanel.add(groupTitle, titleConstraints);
        groupControlPanel.add(nextGroupButton, nextConstraints);
        
        //Prop selection buttons
        propButtonsPanel = new JPanel();
        propButtonsPanel.setLayout(new GridLayout(0, 4, 2,2));
        generatePropButtons();

        //Combine into panel
        fullLayout.setHorizontalGroup(fullLayout.createParallelGroup(GroupLayout.Alignment.CENTER)
        .addGroup(fullLayout.createSequentialGroup()
            .addComponent(exportMarkersButton)
            .addComponent(importMarkersButton)
            .addComponent(clearMarkersButton)
        )
        .addComponent(titlePanel)
        .addComponent(orientationButtonPanel)
        //.addComponent(customPropPanel)
        .addComponent(groupControlPanel)
        .addComponent(propButtonsPanel)
        );
        
        fullLayout.setVerticalGroup(fullLayout.createSequentialGroup()
        .addGroup(fullLayout.createParallelGroup()
            .addComponent(exportMarkersButton)
            .addComponent(importMarkersButton)
            .addComponent(clearMarkersButton)
        )
        .addComponent(titlePanel)
        .addComponent(orientationButtonPanel)
        //.addComponent(customPropPanel)
        .addComponent(groupControlPanel)
        .addComponent(propButtonsPanel)
        );

        setFocusable(true);
        
    } 

    @Override
    public void keyPressed(KeyEvent e){
        if(e.getKeyCode() == KeyEvent.VK_ESCAPE){
            plugin.setEscapePressed(true);
        }
        if(e.getKeyCode() == KeyEvent.VK_SHIFT){
            plugin.setShiftPressed(true);
        }
    }
    @Override
    public void keyTyped(KeyEvent e){

    }

    @Override
    public void keyReleased(KeyEvent e){
        if(e.getKeyCode() == KeyEvent.VK_ESCAPE){
            plugin.setEscapePressed(false);
        }
        if(e.getKeyCode() == KeyEvent.VK_SHIFT){
            plugin.setShiftPressed(false);
        }
        /*if(e.getKeyCode() == KeyEvent.VK_ADD){
            idSelectSpinner.setValue(idSelectSpinner.getNextValue());
            placeCustomProp();
        }
        if(e.getKeyCode() == KeyEvent.VK_SUBTRACT){
            idSelectSpinner.setValue(idSelectSpinner.getPreviousValue());
            placeCustomProp();
        }*/
    }

    void setupOrientationButton(JButton button, OrientationMethod direction, String tooltip){
        button.addActionListener(l -> {
            plugin.setOrientationMethod(direction);
        });
        button.setBorder(new EmptyBorder(2,2,2,2));
        button.setToolTipText(tooltip);
        button.addKeyListener(this);
    }

    public void reselectOrientationButton(OrientationMethod newOrientationMethod){
        switch(newOrientationMethod){
            case EAST:
                orientationSelectionGroup.setSelected(eastButton.getModel(), true);
                break;
            case FACE_AWAY_PLAYER:
                orientationSelectionGroup.setSelected(faceAwayFromPlayerButton.getModel(), true);
                break;
            case FACE_PLAYER:
                orientationSelectionGroup.setSelected(facePlayerButton.getModel(), true);
                break;
            case MATCH_PLAYER:
                orientationSelectionGroup.setSelected(faceSameAsPlayerButton.getModel(), true);
                break;
            case NORTH:
                orientationSelectionGroup.setSelected(northButton.getModel(), true);
                break;
            case OPPOSE_PLAYER:
                orientationSelectionGroup.setSelected(faceOppositePlayerButton.getModel(), true);
                break;
            case RANDOM:
                orientationSelectionGroup.setSelected(randomButton.getModel(), true);
                break;
            case SOUTH:
                orientationSelectionGroup.setSelected(southButton.getModel(), true);
                break;
            case WEST:
                orientationSelectionGroup.setSelected(westButton.getModel(), true);
                break;
            default:
                break;

        }
    }

    void placeCustomProp(){
        plugin.startPlacingTile(new MarkerOption("", (int)idSelectSpinner.getValue()));
    }

    void generatePropButtons(){
        //Hide images, remove + validate still sometimes left ghosts of old images behind
        for (Component c : propButtonsPanel.getComponents()) {
            JButton button = (JButton)c;
            if(button != null){
                button.setVisible(false);
            }
        }
        propButtonsPanel.removeAll();
        propButtonsPanel.validate();

        //Loop values
        int propCount = currentPack.markers.length;
        BufferedImage defaultIcon = ImageUtil.loadImageResource(getClass(), "icon.png");

        for (int i = 0; i < propCount; i++) {
            JButton newButton;
            final MarkerOption mkOpt = currentPack.markers[i];
            try {
                BufferedImage propIcon = ImageUtil.loadImageResource(getClass(), "props/"+currentPack.name()+"/"+mkOpt.name+".png");
                newButton = new JButton(new ImageIcon(propIcon));
            } catch (Exception e) {
                newButton = new JButton(new ImageIcon(defaultIcon));
            }
            
            newButton.setToolTipText(mkOpt.name);
            newButton.addKeyListener(this);
            newButton.addActionListener(l -> {
                plugin.startPlacingTile(mkOpt);
            });
            propButtonsPanel.add(newButton);
        }
    }
}

package com.ImmersiveGroundMarkers;

import net.runelite.client.RuneLite;
import net.runelite.client.externalplugins.ExternalPluginManager;

public class ImmersiveGroundMarkersPluginTest
{
	public static void main(String[] args) throws Exception
	{
		ExternalPluginManager.loadBuiltin(ImmersiveGroundMarkersPlugin.class);
		RuneLite.main(args);
	}
}
