package com.raidsdrymeter;

import net.runelite.client.RuneLite;
import net.runelite.client.externalplugins.ExternalPluginManager;

public class RaidsDryMeterPluginTest
{
	public static void main(String[] args) throws Exception
	{
		ExternalPluginManager.loadBuiltin(RaidsDryMeterPlugin.class);
		RuneLite.main(args);
	}
}
package com.raidsdrymeter.storage;

import lombok.AllArgsConstructor;
import lombok.Data;

@Data
@AllArgsConstructor
public class UniqueEntry {
    private final String name;
    private final int id;
    private int quantity;
    private long price;

    public long getTotal()
    {
        return this.quantity * this.price;
    }

}

package com.raidsdrymeter.storage;

import lombok.AllArgsConstructor;
import lombok.Data;
import net.runelite.http.api.loottracker.LootRecordType;

import java.util.Collection;

@Data
@AllArgsConstructor
public class RaidRecord {
    private final String name;
    private final int killCount;
    private final int partySize;
    private final int personalPoints;
    private final int teamPoints;
    private final int personalRaidsDry;
    private final int teamRaidsDry;
    private final int personalDeaths;
    private final int teamDeaths;
    private LootRecordType type;
    final Collection<UniqueEntry> uniques;

    public void addUnique(UniqueEntry uniqueEntry)
    {
        uniques.add(uniqueEntry);
    }

}

package com.raidsdrymeter.storage;

import com.google.common.collect.HashMultimap;
import com.google.common.collect.SetMultimap;
import lombok.extern.slf4j.Slf4j;
import net.runelite.http.api.RuneLiteAPI;
import net.runelite.http.api.loottracker.LootRecordType;

import javax.inject.Inject;
import javax.inject.Singleton;

import java.io.*;
import java.util.*;

import static net.runelite.client.RuneLite.RUNELITE_DIR;

@Slf4j
@Singleton
public class RecordWriter {
    private static final String FILE_EXTENSION = ".log";
    private static final File LOOT_RECORD_DIR = new File(RUNELITE_DIR, "raids-dry-meter");

    private File playerFolder = LOOT_RECORD_DIR;

    private final Map<LootRecordType, File> eventFolders = new HashMap<>();
    private String name;

    @Inject
    public RecordWriter()
    {
        LOOT_RECORD_DIR.mkdir();
    }

    public void setPlayerUsername(final String username)
    {
        if (username.equalsIgnoreCase(name))
        {
            return;
        }

        playerFolder = new File(LOOT_RECORD_DIR, username);
        playerFolder.mkdir();
        name = username;
        createSubFolders();
    }

    private void createSubFolders()
    {
        eventFolders.clear();
        for (final LootRecordType type : LootRecordType.values())
        {

            if(type.name() == "EVENT" ) {
                final File folder = new File(playerFolder, type.name().toLowerCase());
                folder.mkdir();
                eventFolders.put(type, folder);
            }
        }
    }


    private static String raidNameToFileName(final String raidName)
    {
        return raidName.toLowerCase().trim() + FILE_EXTENSION;
    }

    public SetMultimap<LootRecordType, String> getKnownFileNames()
    {
        final SetMultimap<LootRecordType, String> fileNames = HashMultimap.create();

        for (final Map.Entry<LootRecordType, File> entry : eventFolders.entrySet())
        {
            final File[] files = entry.getValue().listFiles((dir, name) -> name.endsWith(FILE_EXTENSION));
            if (files != null)
            {
                for (final File f : files)
                {
                    fileNames.put(entry.getKey(), f.getName().replace(FILE_EXTENSION, ""));
                }
            }
        }

        return fileNames;
    }
    public synchronized Collection<RaidRecord> loadRaidTrackerRecords(LootRecordType recordType, String npcName)
    {
        return loadRaidTrackerRecords(npcName, eventFolders.get(recordType));
    }

    @Deprecated
    public synchronized Collection<RaidRecord> loadRaidTrackerRecords(String npcName, File folder)
    {
        final String fileName = raidNameToFileName(npcName);
        final File file = new File(folder, fileName);
        final Collection<RaidRecord> data = new ArrayList<>();

        try (final BufferedReader br = new BufferedReader(new FileReader(file)))
        {
            String line;
            while ((line = br.readLine()) != null)
            {
                // Skips the empty line at end of file
                if (line.length() > 0)
                {
                    final RaidRecord r = RuneLiteAPI.GSON.fromJson(line, RaidRecord.class);
                    data.add(r);
                }
            }

        }
        catch (FileNotFoundException e)
        {
            log.debug("File not found: {}", fileName);
        }
        catch (IOException e)
        {
            log.warn("IOException for file {}: {}", fileName, e.getMessage());
        }

        return data;
    }

    public synchronized boolean addRaidRecord(RaidRecord rec)
    {
        if(rec.getName().equals("Chambers of Xeric") || rec.getName().equals("Theater of Blood")) {
            // Grab file
            final String fileName = raidNameToFileName(rec.getName());
            final File lootFile = new File(eventFolders.get(rec.getType()), fileName);

            // Convert entry to JSON
            final String dataAsString = RuneLiteAPI.GSON.toJson(rec);

            // Open File in append mode and write new data
            try {
                final BufferedWriter file = new BufferedWriter(new FileWriter(String.valueOf(lootFile), true));
                file.append(dataAsString);
                file.newLine();
                file.close();
                return true;
            } catch (IOException ioe) {
                log.warn("Error writing loot data to file {}: {}", fileName, ioe.getMessage());
                return false;
            }
        }
        return false;
    }

}

package com.raidsdrymeter.data;

import com.google.common.collect.ImmutableMap;
import com.google.common.collect.ImmutableMultimap;
import com.google.common.collect.Multimap;
import lombok.AllArgsConstructor;
import lombok.Getter;
import net.runelite.api.ItemID;
import net.runelite.http.api.loottracker.LootRecordType;


import java.util.Collection;
import java.util.Map;

@Getter
@AllArgsConstructor
public enum RaidTab {

    COX("Chambers of Xeric", ItemID.OLMLET, "Raids", LootRecordType.EVENT),
    TOB("Theater of Blood", ItemID.LIL_ZIK, "Raids", LootRecordType.EVENT);

    private final String name;
    private final int itemID;
    private final String category;
    private final LootRecordType type;

    private static final Map<String, RaidTab> NAME_MAP;
    private static final Multimap<String, RaidTab> CATEGORY_MAP;
    static
    {
        final ImmutableMap.Builder<String, RaidTab> byName = ImmutableMap.builder();
        final ImmutableMultimap.Builder<String, RaidTab> categoryMap = ImmutableMultimap.builder();

        for (RaidTab tab : values())
        {
            byName.put(tab.getName().toUpperCase(), tab);
            categoryMap.put(tab.getCategory(), tab);

        }

        NAME_MAP = byName.build();
        CATEGORY_MAP = categoryMap.build();
    }

    public static RaidTab getByName(final String name)
    {
        return NAME_MAP.get(name.toUpperCase());
    }

    public static Collection<RaidTab> getByCategoryName(final String name)
    {
        return CATEGORY_MAP.get(name);
    }
}

package com.raidsdrymeter.data;

import com.google.common.collect.ImmutableMultimap;
import lombok.Getter;
import lombok.RequiredArgsConstructor;
import lombok.Setter;
import net.runelite.api.ItemComposition;
import net.runelite.api.ItemID;
import net.runelite.client.game.ItemManager;

import java.util.ArrayList;
import java.util.Collection;
import java.util.List;

@RequiredArgsConstructor
@Getter
public enum  UniqueItem {

    //Chambers of Xeric uniques
    //Common
    ARCANE_PRAYER_SCROLL(ItemID.ARCANE_PRAYER_SCROLL, RaidTab.COX, 0, 0.14495),
    DEXTEROUS_PRAYER_SCROLL(ItemID.DEXTEROUS_PRAYER_SCROLL, RaidTab.COX, 0, 0.14495),

    //Rare
    TWISTED_BUCKLER(ItemID.TWISTED_BUCKLER, RaidTab.COX, 0, 0.029),
    DRAGON_HUNTER_CROSSBOW(ItemID.DRAGON_HUNTER_CROSSBOW, RaidTab.COX, 0, 0.029),

    //Very Rare
    DINHS_BULWARK(ItemID.DINHS_BULWARK, RaidTab.COX, 1, 0.0087),

    ANCESTRAL_HAT(ItemID.ANCESTRAL_HAT, RaidTab.COX, 1, 0.0087),
    ANCESTRAL_ROBE_TOP(ItemID.ANCESTRAL_ROBE_TOP, RaidTab.COX, 1, 0.0087),
    ANCESTRAL_ROBE_BOTTOM(ItemID.ANCESTRAL_ROBE_BOTTOM, RaidTab.COX, 1, 0.0087),

    DRAGON_CLAWS(ItemID.DRAGON_CLAWS, RaidTab.COX, 2, 0.0087),

    //Mega Rare
    ELDER_MAUL(ItemID.ELDER_MAUL, RaidTab.COX, 2, 0.00966666),
    KODAI_INSIGNIA(ItemID.KODAI_INSIGNIA, RaidTab.COX, 2, 0.00966666),
    TWISTED_BOW(ItemID.TWISTED_BOW, RaidTab.COX, 2, 0.00966666),

    //Theater of Blood uniques
    //Common
    AVERNIC_DEFENDER_HILT(ItemID.AVERNIC_DEFENDER_HILT, RaidTab.TOB, 0, 0.0463),

    //Rare
    GHRAZI_RAPIER(ItemID.GHRAZI_RAPIER, RaidTab.TOB, 0, 0),
    SANGUINESTI_STAFF(ItemID.SANGUINESTI_STAFF_UNCHARGED, RaidTab.TOB, 0, ((double)8/19)),

    JUSTICIAR_FACEGUARD(ItemID.JUSTICIAR_FACEGUARD, RaidTab.TOB, 0, ((double)2/19)),
    JUSTICIAR_CHESTGUARD(ItemID.JUSTICIAR_CHESTGUARD, RaidTab.TOB, 1, ((double)2/19)),
    JUSTICIAR_LEGUARDS(ItemID.JUSTICIAR_LEGGUARDS, RaidTab.TOB, 1, ((double)2/19)),

    //Very Rare
    SCYTHE_OF_VITUR(ItemID.SCYTHE_OF_VITUR, RaidTab.TOB, 1, ((double)1/19))

    ;

    private int itemID;
    private RaidTab[] raids;
    private int position;
    private double dropRate;
    private String name;
    private int price;
    private int linkedID;

    @Setter
    private int qty;

    private static final ImmutableMultimap<String, UniqueItem> RAID_MAP;
    static
    {
        final ImmutableMultimap.Builder<String, UniqueItem> map = ImmutableMultimap.builder();
        for (UniqueItem item : values())
        {
            for (RaidTab b : item.getRaids())
            {
                map.put(b.getName(), item);
            }
        }

        RAID_MAP = map.build();
    }

    UniqueItem(int id, RaidTab raid, int position, double dropRate)
    {
        this.itemID = id;
        this.raids = new RaidTab[]{raid};
        this.position = position;
        this.dropRate = dropRate;
    }

    public static void prepareUniqueItems(final ItemManager itemManager)
    {
        for (final UniqueItem item : values())
        {
            if (item.getName() != null)
            {
                return;
            }

            final ItemComposition c = itemManager.getItemComposition(item.getItemID());
            item.name = c.getName();
            item.linkedID = c.getLinkedNoteId();
            item.price = itemManager.getItemPrice(c.getId());
        }
    }

    public static List<Integer> getUniqueItemList(final ItemManager itemManager)
    {
        List<Integer> uniques = new ArrayList<>();
        for (final UniqueItem item : values())
        {
            uniques.add(item.getItemID());
        }

        return uniques;
    }

    public static Collection<UniqueItem> getUniquesForBoss(final String raidName)
    {
        return RAID_MAP.get(raidName);
    }

}

package com.raidsdrymeter.data;

import com.raidsdrymeter.storage.RaidRecord;
import com.raidsdrymeter.storage.UniqueEntry;
import lombok.Getter;
import net.runelite.http.api.loottracker.LootRecordType;

import java.util.*;
import java.util.stream.Collectors;

@Getter
public class UniqueLog {
    private final String name;
    private final LootRecordType type;

    private final List<RaidRecord> records = new ArrayList<>();
    private final Map<Integer, UniqueEntry> consolidated = new HashMap<>();
    private final Collection<UniqueItem> uniques;

    public UniqueLog(final Collection<RaidRecord> records, final String name)
    {
        this.records.addAll(records);
        this.name = name;

        if(records.size() == 0)
        {
            this.type = LootRecordType.UNKNOWN;
        }
        else
        {
            final RaidRecord record = this.records.get(0);
            this.type = record.getType();
        }

        for(final RaidRecord record : records)
        {
            for(final UniqueEntry entry : record.getUniques())
            {
                addItemEntryToMap(entry);
            }
        }

        final Collection<UniqueItem> unsorted = UniqueItem.getUniquesForBoss(name);
        if (unsorted == null)
        {
            uniques = new ArrayList<>();
            return;
        }

        uniques = unsorted.stream().sorted(Comparator.comparingInt(UniqueItem::getPosition)).collect(Collectors.toList());
    }

    public synchronized void addRecord(final RaidRecord record)
    {
        records.add(record);
        for (final UniqueEntry entry : record.getUniques())
        {
            addItemEntryToMap(entry);
        }
    }

    private void addItemEntryToMap(UniqueEntry unique)
    {
        final String itemNameLowercased = unique.getName().toLowerCase();

        if(type != null)
        {
            unique = new UniqueEntry(unique.getName(), unique.getId(), unique.getQuantity(), unique.getPrice());
        }

        final UniqueEntry oldEntry = consolidated.get(unique.getId());
        if(oldEntry != null)
        {
            oldEntry.setQuantity(oldEntry.getQuantity() + unique.getQuantity());
        }
        else
        {
            consolidated.put(unique.getId(), new UniqueEntry(unique.getName(), unique.getId(), unique.getQuantity(), unique.getPrice()));
        }
    }
}

package com.raidsdrymeter.ui;

import com.raidsdrymeter.data.RaidTab;
import net.runelite.client.game.ItemManager;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.components.materialtabs.MaterialTab;
import net.runelite.client.ui.components.materialtabs.MaterialTabGroup;
import net.runelite.client.util.AsyncBufferedImage;

import javax.swing.*;
import javax.swing.border.EmptyBorder;
import java.awt.*;
import java.util.Collection;

public class SelectionPanel extends JPanel {

    private final static Color BACKGROUND_COLOR = ColorScheme.DARK_GRAY_COLOR;
    private final static Color BUTTON_COLOR = ColorScheme.DARKER_GRAY_COLOR;
    private final static Color BUTTON_HOVER_COLOR = ColorScheme.DARKER_GRAY_HOVER_COLOR;

    private final RaidsDryMeterPanel parent;
    private final ItemManager itemManager;

    SelectionPanel(
            final RaidsDryMeterPanel parent,
            final ItemManager itemManager
    )
    {
        this.parent = parent;
        this.itemManager = itemManager;

        this.setLayout(new GridBagLayout());
        this.setBackground(BACKGROUND_COLOR);

        createPanel();
    }

    private void createPanel()
    {
        final GridBagConstraints c = new GridBagConstraints();
        c.fill = GridBagConstraints.HORIZONTAL;

        c.weightx = 1;
        c.gridx = 0;
        c.gridy = 0;
        c.insets = new Insets(5, 0, 0, 0);

        this.add(createRaidTabPanel(), c);
        c.gridy++;
    }

    private JPanel createRaidTabPanel()
    {
        final GridBagConstraints c = new GridBagConstraints();
        c.fill = GridBagConstraints.HORIZONTAL;
        c.weightx = 1;
        c.gridx = 0;
        c.gridy = 0;
        c.insets = new Insets(5, 0, 0, 0);

        final JPanel container = new JPanel(new GridBagLayout());
        container.setBorder(new EmptyBorder(0, 0, 0, 0));

        container.add(createRaidTabs(), c);

        return container;
    }

    private JPanel createRaidTabs()
    {
        final JPanel container = new JPanel();

        final GridBagConstraints c = new GridBagConstraints();
        c.fill = GridBagConstraints.BOTH;
        c.weightx = 1;
        c.gridx = 0;
        c.gridy = 0;

        final MaterialTabGroup thisTabGroup = new MaterialTabGroup();
        thisTabGroup.setLayout(new GridLayout(0, 2, 7, 0));
        thisTabGroup.setBorder(new EmptyBorder(0, 0, 0, 0));

        final Collection<RaidTab> categoryTabs = RaidTab.getByCategoryName("Raids");
        for(final RaidTab tab : categoryTabs)
        {
            final MaterialTab materialTab = new MaterialTab("", thisTabGroup, null);
            materialTab.setName(tab.getName());
            materialTab.setToolTipText(tab.getName());
            materialTab.setOnSelectEvent(() ->
            {
                parent.setUniqueLogToNull();
                parent.requestUniqueLog(tab.getType(), tab.getName());
                return true;
            });


            final AsyncBufferedImage image = itemManager.getImage(tab.getItemID());
            final Runnable resize = () ->
            {
                materialTab.setIcon(new ImageIcon(image.getScaledInstance(35, 35, Image.SCALE_SMOOTH)));
                materialTab.setOpaque(true);
                materialTab.setBackground(Color.DARK_GRAY);
                materialTab.setHorizontalAlignment(SwingConstants.CENTER);
                materialTab.setVerticalAlignment(SwingConstants.CENTER);
                materialTab.setPreferredSize(new Dimension(55, 35));

            };

            image.onLoaded(resize);
            resize.run();

            thisTabGroup.addTab(materialTab);

        }
        container.add(thisTabGroup, c);

        return container;
    }


}

package com.raidsdrymeter.ui;

import com.raidsdrymeter.RaidsDryMeterPlugin;
import com.raidsdrymeter.data.UniqueLog;
import com.raidsdrymeter.storage.RaidRecord;
import lombok.Getter;
import net.runelite.client.game.ItemManager;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.PluginPanel;
import net.runelite.client.util.ImageUtil;
import net.runelite.http.api.loottracker.LootRecordType;

import javax.swing.*;
import javax.swing.border.EmptyBorder;
import java.awt.*;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.awt.image.BufferedImage;

public class RaidsDryMeterPanel extends PluginPanel {

    private final static Color BACKGROUND_COLOR = ColorScheme.DARK_GRAY_COLOR;
    private final static Color BUTTON_HOVER_COLOR = ColorScheme.DARKER_GRAY_HOVER_COLOR;

    private final RaidsDryMeterPlugin plugin;

    private UniqueLog uniqueLog;

    private final ItemManager itemManager;

    RaidsPanel raidsPanel;

    SelectionPanel selectionPanel;

    EmptyPanel emptyPanel;

    @Getter
    private final JPanel namePanel = new JPanel();

    public RaidsDryMeterPanel(RaidsDryMeterPlugin raidsDryMeterPlugin, ItemManager itemManager)
    {
        super();

        this.itemManager = itemManager;

        this.plugin = raidsDryMeterPlugin;

        this.setBackground(ColorScheme.DARK_GRAY_COLOR);
        this.setLayout(new BorderLayout());

        final GridBagConstraints c = createGridBag();

        showSelectionView();

        c.gridy++;


    }

    public void addLog(final RaidRecord r)
    {
        if (uniqueLog == null)
        {
            requestUniqueLog(r.getType(), r.getName());
        }
        else if (uniqueLog.getName().equalsIgnoreCase(r.getName()))
        {
            raidsPanel.addedRecord(r);
        }
    }


    public void useLog(final UniqueLog log)
    {
        uniqueLog = log;
        showRaidView();
    }

    public void requestUniqueLog(final LootRecordType type, final String name)
    {
        // For some reason removing all the components when there's a lot of names in the selectionPanel causes lag.
        // Removing them here seems to mitigate the lag

        plugin.requestUniqueLog(type, name);
    }


    public void refreshUI()
    {
        if(raidsPanel != null)
        {
            remove(raidsPanel);
            raidsPanel = null;
        }
        showSelectionView();
    }

    public void showSelectionView()
    {
        if(selectionPanel != null)
        {
            this.remove(selectionPanel);
            selectionPanel = null;
        }

        selectionPanel = new SelectionPanel(this, itemManager);

        final GridBagConstraints c = createGridBag();
        this.add(selectionPanel, c);
        c.gridy++;

        this.revalidate();
        this.repaint();
    }

    public void addEmptyPanel(GridBagConstraints c)
    {
        emptyPanel = new EmptyPanel("test");
        this.add(emptyPanel);

        this.revalidate();
        this.repaint();
    }


    public void showRaidView()
    {
        if(emptyPanel !=null) {

            this.remove(emptyPanel);
            emptyPanel = null;
        }

        if(raidsPanel != null)
        {
            this.remove(raidsPanel);
        }

        final GridBagConstraints c = createGridBag();

        raidsPanel = new RaidsPanel(uniqueLog, itemManager);

        c.gridy++;

        this.add(raidsPanel, c);

        this.revalidate();
        this.repaint();
    }

    private JLabel createIconLabel(final BufferedImage icon)
    {
        final JLabel label = new JLabel();
        label.setIcon(new ImageIcon(icon));
        label.setOpaque(true);
        label.setBackground(BACKGROUND_COLOR);

        label.addMouseListener(new MouseAdapter()
        {
            @Override
            public void mouseEntered(MouseEvent e)
            {
                label.setBackground(BUTTON_HOVER_COLOR);
            }

            @Override
            public void mouseExited(MouseEvent e)
            {
                label.setBackground(BACKGROUND_COLOR);
            }
        });

        return label;
    }

    public GridBagConstraints createGridBag()
    {
        this.setBorder(new EmptyBorder(10, 10, 10, 10));

        this.setLayout(new GridBagLayout());


        final GridBagConstraints c = new GridBagConstraints();
        c.fill = GridBagConstraints.HORIZONTAL;
        c.weightx = 1;
        c.gridx = 0;
        c.gridy = 0;

        return c;
    }

    public void setUniqueLogToNull()
    {
        uniqueLog = null;
    }

}

package com.raidsdrymeter.ui;

import com.raidsdrymeter.data.UniqueItem;
import net.runelite.client.game.ItemManager;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.PluginPanel;
import net.runelite.client.util.AsyncBufferedImage;
import net.runelite.client.util.ImageUtil;
import net.runelite.client.util.QuantityFormatter;

import javax.swing.*;
import javax.swing.border.Border;
import javax.swing.border.EmptyBorder;
import java.awt.*;
import java.awt.image.BufferedImage;
import java.util.Collection;

public class UniquePanel extends JPanel {
    private final float alphaHas = 1.0f;

    private static final Dimension panelSize = new Dimension(215, 50);
    private static final Border panelBorder = new EmptyBorder(3, 0, 3, 0);
    private static final Color panelBackgroundColor = ColorScheme.DARKER_GRAY_COLOR;

    UniquePanel(final Collection<UniqueItem> items, final ItemManager itemManager, final int itemMissingAlpha)
    {
        float alphaMissing = itemMissingAlpha / 100f;
        final JPanel panel = new JPanel();
        panel.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        panel.setBorder(new EmptyBorder(3, 6, 0, 3));


        this.setLayout(new BorderLayout());
        this.setBorder(panelBorder);
        this.setBackground(panelBackgroundColor);
        this.setPreferredSize(panelSize);


        GridBagConstraints c = new GridBagConstraints();
        c.fill = GridBagConstraints.BOTH;
        c.weightx = 1;
        c.gridx = 0;
        c.gridy = 0;
        c.ipady = 5;

        for(final UniqueItem l : items)
        {
            final int quantity = l.getQty();
            final float alpha = (quantity > 0 ? alphaHas : alphaMissing);
            final AsyncBufferedImage image = itemManager.getImage(l.getItemID(), quantity, quantity > 1);
            final BufferedImage opaque = ImageUtil.alphaOffset(image, alpha);

            final JLabel icon = new JLabel();
            icon.setToolTipText(buildToolTip(l, quantity));
            icon.setIcon(new ImageIcon(opaque));
            icon.setVerticalAlignment(SwingConstants.CENTER);
            icon.setHorizontalAlignment(SwingConstants.CENTER);
            panel.add(icon, c);
            c.gridx++;

            // in case the image is blank we will refresh it upon load
            // Should only trigger if image hasn't been added
            image.onLoaded(() ->
            {
                icon.setIcon(new ImageIcon(ImageUtil.alphaOffset(image, alpha)));
                icon.revalidate();
                icon.repaint();
            });
        }
        this.add(panel, BorderLayout.NORTH);
    }

    private static String buildToolTip(final UniqueItem item, final int qty)
    {
        String s = "<html>" + item.getName();

        if(item.getPrice() > 0){
            s += "<br/>(x" + QuantityFormatter.quantityToStackSize(item.getPrice()) + ")"; //getPrice
        }

        if (qty > 0)
        {
            s += "<br/>x " + QuantityFormatter.formatNumber(qty);
        }

        if(item.getPrice() > 0 && qty > 0)
        {
            s += "<br/>(" + QuantityFormatter.quantityToStackSize(qty * item.getPrice()) + ")</html;";
        }


        s += "</html>";

        return s;
    }

}

package com.raidsdrymeter.ui;

import com.google.common.collect.ArrayListMultimap;
import com.google.common.collect.Multimap;
import com.raidsdrymeter.data.UniqueItem;
import com.raidsdrymeter.data.UniqueLog;
import com.raidsdrymeter.storage.RaidRecord;
import com.raidsdrymeter.storage.UniqueEntry;
import net.runelite.client.game.ItemManager;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.PluginPanel;
import net.runelite.client.util.QuantityFormatter;

import javax.swing.border.EmptyBorder;
import java.awt.*;
import java.util.*;
import java.util.List;

public class RaidsPanel extends PluginPanel {

    private final static Color BACKGROUND_COLOR = ColorScheme.DARK_GRAY_COLOR;

    private final ItemManager itemManager;
    private final UniqueLog uniqueLog;

    private int totalUniques = 0;
    private double totalGPFromUniques = 0;

    RaidsPanel(
            final UniqueLog log,
            final ItemManager itemManager
    ){
        this.uniqueLog = log;
        this.itemManager = itemManager;

        setLayout(new GridBagLayout());
        setBorder(new EmptyBorder(3, 5, 0, 5));
        setBackground(BACKGROUND_COLOR);

        createPanel(log);
    }

    private void createPanel(final UniqueLog uniqueLog)
    {
        final GridBagConstraints c = new GridBagConstraints();
        c.fill = GridBagConstraints.HORIZONTAL;
        c.weightx = 1;
        c.gridx = 0;
        c.gridy = 0;

        final Multimap<Integer, UniqueItem> positionMap = ArrayListMultimap.create();
        final Set<Integer> uniqueIds = new HashSet<>();

        for(final UniqueItem item : uniqueLog.getUniques())
        {
            final int id = item.getItemID();
            if (id != -1)
            {
                uniqueIds.add(id);
            }

            final int linkedId = item.getLinkedID();
            if (linkedId != -1)
            {
                uniqueIds.add(linkedId);
            }

            final UniqueEntry entry = uniqueLog.getConsolidated().get(id);
            final UniqueEntry notedEntry = uniqueLog.getConsolidated().get(linkedId);
            final int qty = (entry == null ? 0 : entry.getQuantity() + (notedEntry == null ? 0 : notedEntry.getQuantity()));
            item.setQty(qty);
            positionMap.put(item.getPosition(), item);
            totalUniques += qty;
            totalGPFromUniques += (item.getPrice() * qty);
        }

        for (final int position : positionMap.keySet())
        {
            final Collection<UniqueItem> uniques = positionMap.get(position);

            final UniquePanel p = new UniquePanel(uniques, this.itemManager, 35);
            this.add(p, c);
            c.gridy++;
        }

        if(uniqueLog.getRecords().size() > 0)
        {
            final int amount = uniqueLog.getRecords().size();
            final RaidRecord record = uniqueLog.getRecords().get(amount - 1);
            int personalRaidsDry = record.getPersonalRaidsDry();

            int personalPointsDry = 0;
            double personalRaidsOdds = 0;
            int totalPoints = 0;
            int personalStreak = 0;

            if(personalRaidsDry != 0)
            {
                int x = uniqueLog.getRecords().size() - personalRaidsDry;
                for(;x < uniqueLog.getRecords().size(); x++)
                {
                    totalPoints += uniqueLog.getRecords().get(x).getPersonalPoints();
                    if(totalPoints < 867600)
                    {
                        personalPointsDry += uniqueLog.getRecords().get(x).getPersonalPoints();
                    }
                    if(totalPoints > 867600)
                    {
                        totalPoints -= 867600;
                        personalStreak++;
                        personalPointsDry += uniqueLog.getRecords().get(x).getPersonalPoints();
                    }
                }

                personalRaidsOdds = 867600/(double)(personalPointsDry/personalRaidsDry);

            }

            if(record.getKillCount() != -1)
            {
                final DataPanel p = new DataPanel("KillCount: ", record.getKillCount());
                this.add(p, c);
                c.gridy++;

                System.out.println(uniqueLog.getName() + uniqueLog.getRecords().size());
                final DataPanel p2 = new DataPanel("Logged KC: ", uniqueLog.getRecords().size());
                this.add(p2, c);
                c.gridy++;

                final DataPanel p3 = new DataPanel("Total Uniques: ", totalUniques);
                this.add(p3, c);
                c.gridy++;

                String holder = String.format("%,.0f", (double) personalPointsDry);
                final DataPanel p4 = new DataPanel("Personal Points Dry: ", holder);
                this.add(p4, c);
                c.gridy++;

                final DataPanel p6 = new DataPanel("Personal Raids Dry: ", personalRaidsDry);
                this.add(p6, c);
                c.gridy++;

                holder = String.format("%,.2f", personalRaidsOdds);
                final DataPanel p8 = new DataPanel("Personal Raids Odds: ", holder);
                this.add(p8, c);
                c.gridy++;

                final DataPanel p9 = new DataPanel("Personal Raids Dry Streak: ", personalStreak);
                this.add(p9, c);
                c.gridy++;

                final DataPanel p12 = new DataPanel("Gp From Personal Uniques: ", QuantityFormatter.quantityToStackSize((long)totalGPFromUniques));
                this.add(p12, c);
                c.gridy++;

                holder = String.format("%,.2f", getEstimateGpPerPoint());
                final DataPanel p13 = new DataPanel("Est. Gp per Point: ", holder);
                this.add(p13, c);
                c.gridy++;

                holder = String.format("%,.2f", getActualGpPerPoints());
                final DataPanel p14 = new DataPanel("Actual. Gp Per Personal Point: ", holder);
                this.add(p14, c);
                c.gridy++;

            }
        }
        else if(uniqueLog.getName().equals("Theater of Blood"))
        {
                final DataPanel holder = new DataPanel("Coming soon!");
                this.add(holder, c);
                c.gridy++;
        }
    }

    void addedRecord(final RaidRecord record)
    {
        uniqueLog.addRecord(record);

        // TODO: Smarter update system so it only repaints necessary Item and Text Panels
        this.removeAll();
        this.createPanel(uniqueLog);

        this.revalidate();
        this.repaint();
    }

    double getEstimateGpPerPoint()
    {
        double gpPerPoint = 0;
        List<UniqueItem> uniqueItems = new ArrayList<>(UniqueItem.getUniquesForBoss("Chambers of Xeric"));
        for (UniqueItem uniqueItem : uniqueItems) {
            double dropRate = uniqueItem.getDropRate();
            gpPerPoint += (uniqueItem.getPrice() / (712500 / dropRate));
        }
        return gpPerPoint;
    }

    double getActualGpPerPoints()
    {
        double gp = 0;
        List<RaidRecord> records = new ArrayList<>(uniqueLog.getRecords());
        List<UniqueItem> uniqueItems = new ArrayList<>(UniqueItem.getUniquesForBoss("Chambers of Xeric"));
        double totalPoints = 0;
        for (RaidRecord record : records)
        {
            List<UniqueEntry> uniqueDrops = new ArrayList<>(record.getUniques());
            totalPoints += record.getPersonalPoints();
            for(UniqueEntry uniqueDrop : uniqueDrops)
            {
                for(UniqueItem uniqueItem : uniqueItems)
                {
                    if(uniqueDrop.getId() == uniqueItem.getItemID())
                        gp += uniqueItem.getPrice();
                }
            }

        }

        return gp / totalPoints;
    }
}

package com.raidsdrymeter.ui;

import net.runelite.client.ui.ColorScheme;
import net.runelite.client.util.QuantityFormatter;

import javax.swing.*;
import javax.swing.border.Border;
import javax.swing.border.EmptyBorder;
import java.awt.*;

public class EmptyPanel extends JPanel {

    private static final GridBagLayout LAYOUT = new GridBagLayout();

    private static final Border PANEL_BORDER = BorderFactory.createMatteBorder(3, 0, 3, 0, ColorScheme.DARK_GRAY_COLOR);
    private static final Color PANEL_BACKGROUND_COLOR = ColorScheme.DARKER_GRAY_COLOR;

    private static final Border CONTAINER_BORDER = BorderFactory.createMatteBorder(0, 15, 0, 15, PANEL_BACKGROUND_COLOR);

    EmptyPanel(String text) {

        setLayout(LAYOUT);
        setBorder(PANEL_BORDER);
        setBackground(PANEL_BACKGROUND_COLOR);

        JLabel textJ = new JLabel(text, SwingConstants.LEFT);

        JPanel panel = createPanel();

        final GridBagConstraints c = new GridBagConstraints();
        c.fill = GridBagConstraints.BOTH;
        c.weightx = 1;
        c.gridx = 0;
        c.gridy = 0;
        c.ipady = 20;

        this.add(panel, c);
    }

    private static JPanel createPanel()
    {
        final JPanel panel = new JPanel();
        panel.setLayout(new BorderLayout());
        panel.setBorder(CONTAINER_BORDER);
        panel.setBackground(PANEL_BACKGROUND_COLOR);

        return panel;
    }
}

package com.raidsdrymeter.ui;

import lombok.Setter;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.util.QuantityFormatter;

import javax.swing.*;
import javax.swing.border.Border;
import javax.xml.crypto.Data;
import java.awt.*;

public class DataPanel extends JPanel {

    private static final Border PANEL_BORDER = BorderFactory.createMatteBorder(3, 0, 3, 0, ColorScheme.DARK_GRAY_COLOR);
    private static final Color PANEL_BACKGROUND_COLOR = ColorScheme.DARKER_GRAY_COLOR;

    private static final Border CONTAINER_BORDER = BorderFactory.createMatteBorder(0, 15, 0, 15, PANEL_BACKGROUND_COLOR);

    JLabel total;

    DataPanel(String text, int data)
    {
        setLayout(new GridBagLayout());
        setBorder(PANEL_BORDER);
        setBackground(PANEL_BACKGROUND_COLOR);

        JLabel textJ = new JLabel(text, SwingConstants.CENTER);

        total = new JLabel(QuantityFormatter.quantityToStackSize(data), SwingConstants.CENTER);

        JPanel panel = createPanel();

        panel.add(textJ);
        panel.add(total);

        final GridBagConstraints c = new GridBagConstraints();
        c.fill = GridBagConstraints.BOTH;
        c.weightx = 1;
        c.gridx = 0;
        c.gridy = 0;
        c.ipady = 15;

        this.add(panel, c);

    }

    DataPanel(String text, String formattedData)
    {
        setLayout(new GridBagLayout());
        setBorder(PANEL_BORDER);
        setBackground(PANEL_BACKGROUND_COLOR);

        JLabel textJ = new JLabel(text, SwingConstants.CENTER);

        total = new JLabel("" + formattedData, SwingConstants.CENTER);

        JPanel panel = createPanel();

        panel.add(textJ);
        panel.add(total);

        final GridBagConstraints c = new GridBagConstraints();
        c.fill = GridBagConstraints.BOTH;
        c.weightx = 1;
        c.gridx = 0;
        c.gridy = 0;
        c.ipady = 15;

        this.add(panel, c);

    }

    DataPanel(String text)
    {
        setLayout(new BorderLayout());
        setBorder(PANEL_BORDER);
        setBackground(PANEL_BACKGROUND_COLOR);

        JLabel textJ = new JLabel(text, SwingConstants.CENTER);

        textJ.setHorizontalAlignment(SwingConstants.CENTER);

        JPanel panel = createPanel();

        panel.add(textJ);

        this.add(panel, BorderLayout.CENTER);

    }

    private static JPanel createPanel()
    {
        final JPanel panel = new JPanel(new GridLayout(2,1,1,1));
        panel.setBorder(CONTAINER_BORDER);
        panel.setBackground(PANEL_BACKGROUND_COLOR);

        return panel;
    }

    void updateKC(int data)
    {
        total.setText(QuantityFormatter.quantityToStackSize(data));
    }

}

package com.raidsdrymeter;

import com.google.common.collect.HashMultimap;
import com.google.common.collect.SetMultimap;

import javax.inject.Inject;
import javax.swing.*;

import com.raidsdrymeter.data.RaidTab;
import com.raidsdrymeter.data.UniqueItem;
import com.raidsdrymeter.data.UniqueLog;
import com.raidsdrymeter.storage.RaidRecord;
import com.raidsdrymeter.storage.RecordWriter;
import com.raidsdrymeter.storage.UniqueEntry;
import com.raidsdrymeter.ui.RaidsDryMeterPanel;
import lombok.Getter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.*;
import net.runelite.api.events.ChatMessage;
import net.runelite.api.events.GameStateChanged;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.game.ItemManager;
import net.runelite.client.game.ItemStack;
import net.runelite.client.game.SpriteManager;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.plugins.PluginDescriptor;
import net.runelite.client.plugins.loottracker.LootReceived;

import net.runelite.client.ui.ClientToolbar;
import net.runelite.client.ui.NavigationButton;
import net.runelite.client.util.ImageUtil;
import net.runelite.client.util.Text;
import net.runelite.http.api.loottracker.LootRecordType;

import java.awt.image.BufferedImage;
import java.util.*;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.stream.Collectors;

@Slf4j
@PluginDescriptor(
        name = "Dry Meter for Raids",
        description = "Tracks how dry you are while raiding with different group sizes"
)
public class RaidsDryMeterPlugin extends Plugin
{
    private static final Pattern NUMBER_PATTERN = Pattern.compile("([0-9]+)");
    @Inject
    private Client client;

    @Inject
    private ClientThread clientThread;

    @Inject
    private ClientToolbar clientToolbar;

    @Inject
    private SpriteManager spriteManager;

    @Inject
    private ItemManager itemManager;

    @Inject
    private RecordWriter writer;

    String raidType;

    private RaidsDryMeterPanel panel;
    private NavigationButton navButton;

    @Getter
    private SetMultimap<LootRecordType, String> lootNames = HashMultimap.create();

    boolean personalUnique = false;
    boolean teamUnique = false;
    int partySize = 0;

    List<RaidRecord> records;

    private boolean prepared = false;

    private Map<String, Integer> killCountMap = new HashMap<>();

    @Override
    protected void startUp() throws Exception
    {
        panel = new RaidsDryMeterPanel(this, itemManager);
        final BufferedImage icon = ImageUtil.getResourceStreamFromClass(getClass(), "/util/dry_raids_icon.png");

        navButton = NavigationButton.builder()
                .tooltip("Dry Meter for Raids")
                .icon(icon)
                .priority(5)
                .panel(panel)
                .build();

        clientToolbar.addNavigation(navButton);

        if (!prepared)
        {
            prepared = true;
            clientThread.invokeLater(() ->
            {
                switch (client.getGameState())
                {
                    case UNKNOWN:
                    case STARTING:
                        return false;
                }

                UniqueItem.prepareUniqueItems(itemManager);
                return true;
            });
        }

        if (client.getGameState().equals(GameState.LOGGED_IN) || client.getGameState().equals(GameState.LOADING))
        {
            updateWriterUsername();
        }

    }

    @Override
    protected void shutDown()
    {
        clientToolbar.removeNavigation(navButton);
    }
    @Subscribe
    public void onGameStateChanged(final GameStateChanged event)
    {
        if (event.getGameState() == GameState.LOGGING_IN)
        {
            updateWriterUsername();
        }
    }

    @Subscribe
    public void onLootReceived(final LootReceived event)
    {

        if(event.getName().equals("Chambers of Xeric")) {

            Collection<UniqueEntry> drops;

            partySize = client.getPlayers().size();

            drops = convertToUniqueRecords(event.getItems());

            int totalPoints = client.getVar(Varbits.TOTAL_POINTS);
            int personalPoints = client.getVar(Varbits.PERSONAL_POINTS);

            for (int uniqueId : UniqueItem.getUniqueItemList(itemManager)){
                for(ItemStack item : event.getItems())
                {
                    if(item.getId() == uniqueId)
                    {
                        personalUnique = true;
                    }
                }
            }

            int personalRaidsDry;
            int teamRaidsDry;

            records = new ArrayList<>(getDataByName(event.getType(), event.getName()));
            if(records.size() == 0)
            {
                personalRaidsDry = 0;
                teamRaidsDry = 0;
            }
            else {
                int index = records.size() - 1;
                personalRaidsDry = records.get(index).getPersonalRaidsDry();
                teamRaidsDry = records.get(index).getTeamRaidsDry();
            }

            if(personalUnique)
                personalRaidsDry = 0;
            else
                personalRaidsDry++;

            if(teamUnique)
                teamRaidsDry = 0;
            else
                teamRaidsDry++;

            final int kc = killCountMap.getOrDefault(event.getName().toUpperCase(), -1);
            final RaidRecord record = new RaidRecord(event.getName(), kc, partySize, personalPoints, totalPoints, personalRaidsDry,
                    teamRaidsDry, 0, 0, event.getType(), drops);
            addRecord(record);

            personalUnique = false;
            teamUnique = false;


            SwingUtilities.invokeLater(() -> panel.refreshUI());
        }
    }

    private void setRaidType(String raidType)
    {
        this.raidType = raidType;
    }

    private void updateWriterUsername()
    {
        writer.setPlayerUsername(client.getUsername());
        localPlayerNameChanged();
    }

    private void localPlayerNameChanged()
    {
        lootNames = writer.getKnownFileNames();
        SwingUtilities.invokeLater(() -> panel.refreshUI());
    }

    private Collection<UniqueEntry> convertToUniqueRecords(Collection<ItemStack> stacks)
    {
        return stacks.stream().map(i -> createUniqueRecord(i.getId(), i.getQuantity())).collect(Collectors.toList());
    }

    private UniqueEntry createUniqueRecord(final int id, final int qty)
    {
        final ItemComposition c = itemManager.getItemComposition(id);
        final int realId = c.getNote() == -1 ? c.getId() : c.getLinkedNoteId();
        final int price = itemManager.getItemPrice(realId);
        return new UniqueEntry(c.getName(), id, qty, price);
    }

    private void addRecord(final RaidRecord record)
    {
        writer.addRaidRecord(record);
        lootNames.put(record.getType(), record.getName().toLowerCase());

        SwingUtilities.invokeLater(() -> panel.addLog(record));

    }

    public void requestUniqueLog(final LootRecordType type, final String name)
    {
        clientThread.invoke(() ->
        {
            final Collection<RaidRecord> records = getDataByName(type, name);
            final UniqueLog log = new UniqueLog(records, name);
            SwingUtilities.invokeLater(() -> panel.useLog(log));
        });
    }
    public Collection<RaidRecord> getDataByName(LootRecordType type, String name)
    {
        final RaidTab tab = RaidTab.getByName(name);
        if (tab != null)
        {
            name = tab.getName();
        }

        return writer.loadRaidTrackerRecords(type, name);
    }


    @Subscribe
    public void onChatMessage(ChatMessage event)
    {
        if (event.getType() != ChatMessageType.GAMEMESSAGE && event.getType() != ChatMessageType.SPAM)
        {
            return;
        }

        final String chatMessage = Text.removeTags(event.getMessage());

        // Raids KC
        if (chatMessage.startsWith("Your completed Chambers of Xeric count is"))
        {
            Matcher n = NUMBER_PATTERN.matcher(chatMessage);
            if (n.find())
            {
                killCountMap.put("CHAMBERS OF XERIC", Integer.valueOf(n.group()));
                return;
            }
        }

        // Tob KC
        if (chatMessage.startsWith("Your completed Theatre of Blood count is"))
        {
            Matcher n = NUMBER_PATTERN.matcher(chatMessage);
            if (n.find())
            {
                killCountMap.put("THEATRE OF BLOOD", Integer.valueOf(n.group()));
                return;
            }
        }

        if (chatMessage.startsWith("Special loot:"))
        {
            teamUnique = true;
        }

    }




}

