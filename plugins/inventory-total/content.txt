package com.ericversteeg;

import net.runelite.client.RuneLite;
import net.runelite.client.externalplugins.ExternalPluginManager;

public class InventoryTotalPluginTest
{
	public static void main(String[] args) throws Exception
	{
		ExternalPluginManager.loadBuiltin(InventoryTotalPlugin.class);
		RuneLite.main(args);
	}
}
package com.ericversteeg;

import net.runelite.client.config.*;

import java.awt.*;
import java.awt.event.InputEvent;
import java.awt.event.KeyEvent;

@ConfigGroup(InventoryTotalConfig.GROUP)
public interface InventoryTotalConfig extends Config
{
	String GROUP = "inventorytotal";

	@ConfigItem(
			position = -2,
			keyName = "itemPricesKey",
			name = "Prices",
			description = "Configures the price type."
	)
	default InventoryTotalPriceType priceType()
	{
		return InventoryTotalPriceType.GRAND_EXCHANGE;
	}

	@ConfigItem(
			position = -2,
			keyName = "enableProfitLoss",
			name = "Profit / Loss",
			description = "Configures whether or not current total is relative to start amount."
	)
	default boolean enableProfitLoss()
	{
		return false;
	}

	@ConfigItem(
			position = -2,
			keyName = "profitLossToggleKey",
			name = "Switch Mode Key",
			description = "Switch between Total & Profit / Loss modes."
	)
	default Keybind profitLossToggleKey()
	{
		return new Keybind(KeyEvent.VK_G, InputEvent.CTRL_DOWN_MASK);
	}

	@ConfigItem(
			position = -1,
			keyName = "newRunKey",
			name = "Reset Key",
			description = "Resets the ledger and timer."
	)
	default Keybind newRunKey()
	{
		return new Keybind(KeyEvent.VK_K, InputEvent.CTRL_DOWN_MASK);
	}

	@Alpha
	@ConfigItem(
			position = 1,
			keyName = "totalBackgroundColor",
			name = "Background Color",
			description = "Configures the background color."
	)
	default Color totalColor()
	{
		return Color.decode("#99903D");
	}

	@ConfigItem(
			position = 2,
			keyName = "totalTextColor",
			name = "Text Color",
			description = "Configures the text color."
	)
	default Color textColor()
	{
		return Color.decode("#FFF7E3");
	}

	@Alpha
	@ConfigItem(
			position = 3,
			keyName = "totalBorderColor",
			name = "Border Color",
			description = "Configures the border color."
	)
	default Color borderColor()
	{
		return Color.decode("#0E0E0E");
	}

	@Alpha
	@ConfigItem(
			position = 4,
			keyName = "profitBackgroundColor",
			name = "Profit Color",
			description = "Configures profit background color."
	)
	default Color profitColor()
	{
		return Color.decode("#245C2D");
	}

	@ConfigItem(
			position = 5,
			keyName = "profitTextColor",
			name = "Profit Text Color",
			description = "Configures profit text color."
	)
	default Color profitTextColor()
	{
		return Color.decode("#FFF7E3");
	}

	@Alpha
	@ConfigItem(
			position = 6,
			keyName = "profitBorderColor",
			name = "Profit Border Color",
			description = "Configures profit border color."
	)
	default Color profitBorderColor()
	{
		return Color.decode("#0E0E0E");
	}

	@Alpha
	@ConfigItem(
			position = 7,
			keyName = "lossBackgroundColor",
			name = "Loss Color",
			description = "Configures loss background color."
	)
	default Color lossColor()
	{
		return Color.decode("#5F1515");
	}

	@ConfigItem(
			position = 8,
			keyName = "lossTextColor",
			name = "Loss Text Color",
			description = "Configures loss text color."
	)
	default Color lossTextColor()
	{
		return Color.decode("#FFF7E3");
	}

	@Alpha
	@ConfigItem(
			position = 9,
			keyName = "lossBorderColor",
			name = "Loss Border Color",
			description = "Configures loss border color."
	)
	default Color lossBorderColor()
	{
		return Color.decode("#0E0E0E");
	}

	@ConfigItem(
			position = 11,
			keyName = "roundedCorners",
			name = "Rounded Corners",
			description = "Toggle rounded corners."
	)
	default boolean roundCorners()
	{
		return true;
	}

	@ConfigItem(
			position = 12,
			keyName = "cornerRadius",
			name = "Corner Radius",
			description = "Configures the corner radius."
	)
	default int cornerRadius()
	{
		return 10;
	}

	@ConfigItem(
			position = 13,
			keyName = "alignment",
			name = "Alignment",
			description = "Configures alignment."
	)
	default InventoryTotalAlignment horizontalAlignment()
	{
		return InventoryTotalAlignment.CENTER;
	}

	@ConfigItem(
			position = 14,
			keyName = "inventoryOffsetX",
			name = "Inventory Offset X",
			description = "Configures x-axis offset."
	)
	default int inventoryXOffset()
	{
		return 0;
	}

	@ConfigItem(
			position = 15,
			keyName = "inventoryOffsetXNegative",
			name = "Inventory Offset X Negative",
			description = "Configures whether or not the y-axis offset is a negative number."
	)
	default boolean isInventoryXOffsetNegative()
	{
		return false;
	}

	@ConfigItem(
			position = 16,
			keyName = "inventoryOffsetY",
			name = "Inventory Offset Y",
			description = "Configures y-axis offset."
	)
	default int inventoryYOffset()
	{
		return 12;
	}

	@ConfigItem(
			position = 17,
			keyName = "inventoryOffsetYNegative",
			name = "Inventory Offset Y Negative",
			description = "Configures whether or not the y-axis offset is a negative number."
	)
	default boolean isInventoryYOffsetNegative()
	{
		return false;
	}

	@ConfigItem(
			position = 18,
			keyName = "showLapTime",
			name = "Show Run Time",
			description = "Configures whether or not the run time is visible."
	)
	default boolean showRunTime()
	{
		return false;
	}

	@ConfigItem(
			position = 19,
			keyName = "showExactGp",
			name = "Show Exact Gp",
			description = "Configures whether or not the exact gp value is visible."
	)
	default boolean showExactGp()
	{
		return false;
	}

	@ConfigItem(
			position = 20,
			keyName = "showCoinStack",
			name = "Show Coin Stack",
			description = "Configures whether or not the coin stack image is visible."
	)
	default boolean showCoinStack()
	{
		return true;
	}

	@ConfigItem(
			position = 21,
			keyName = "showWhileBanking",
			name = "Show While Banking",
			description = "Configures whether or not the total is visible while banking."
	)
	default boolean showWhileBanking()
	{
		return true;
	}

	@ConfigItem(
			position = 22,
			keyName = "showOnEmpty",
			name = "Show On Empty",
			description = "Configures whether or not to show the total when inventory is empty."
	)
	default boolean showOnEmpty()
	{
		return true;
	}

	@ConfigItem(
			position = 22,
			keyName = "showTooltip",
			name = "Show Ledger",
			description = "Configures whether or not ledger info is shown when mousing over."
	)
	default boolean showTooltip()
	{
		return true;
	}

	@ConfigItem(
			position = 23,
			keyName = "hideWithInventory",
			name = "Hide With Inventory",
			description = "Configures whether or not to hide the tooltip when the inventory is hidden."
	)
	default boolean hideWithInventory()
	{
		return false;
	}

	@ConfigItem(
			position = 23,
			keyName = "newRunAfterBanking",
			name = "Reset After Banking",
			description = "Resets the ledger and timer after banking."
	)
	default boolean newRunAfterBanking() { return true; }

	@ConfigItem(
			position = 24,
			keyName = "ignoredItems",
			name = "Ignored Items",
			description = "Ignore these items in your inventory."
	)
	default String ignoredItems() {
		return "Cannon barrels, Cannon base, Cannon furnace, Cannon stand";
	}
}

package com.ericversteeg;

public enum InventoryTotalMode {
    TOTAL,
    PROFIT_LOSS
}

package com.ericversteeg;

public enum InventoryTotalPriceType {
    GRAND_EXCHANGE,
    HIGH_ALCH
}

package com.ericversteeg;

public enum InventoryTotalState {
    NONE,
    BANK,
    RUN
}

package com.ericversteeg;

public enum InventoryTotalAlignment {
    CENTER,
    LEFT,
    RIGHT
}

package com.ericversteeg;

import net.runelite.api.Client;
import net.runelite.api.InventoryID;
import net.runelite.api.ItemContainer;
import net.runelite.api.ItemID;
import net.runelite.api.widgets.ComponentID;
import net.runelite.api.widgets.Widget;
import net.runelite.client.game.ItemManager;
import net.runelite.client.ui.FontManager;
import net.runelite.client.ui.overlay.Overlay;
import net.runelite.client.ui.overlay.OverlayLayer;
import net.runelite.client.ui.overlay.OverlayPosition;
import net.runelite.client.ui.overlay.components.TextComponent;
import net.runelite.client.util.ImageUtil;

import javax.inject.Inject;
import java.awt.*;
import java.awt.geom.RoundRectangle2D;
import java.awt.image.BufferedImage;
import java.text.NumberFormat;
import java.time.Instant;
import java.util.Arrays;
import java.util.Comparator;
import java.util.LinkedList;
import java.util.Locale;
import java.util.stream.Collectors;
import java.util.stream.IntStream;

class InventoryTotalOverlay extends Overlay
{
	private static final int TEXT_Y_OFFSET = 17;
	private static final String PROFIT_LOSS_TIME_FORMAT = "%02d:%02d:%02d";
	private static final String PROFIT_LOSS_TIME_NO_HOURS_FORMAT = "%02d:%02d";
	private static final int HORIZONTAL_PADDING = 10;
	private static final int BANK_CLOSE_DELAY = 1200;
	private static final Color LEDGER_BACKGROUND_COLOR = new Color(27, 27, 27, 202);
	static final int COINS = ItemID.COINS_995;

	private final Client client;
	private final InventoryTotalPlugin plugin;
	private final InventoryTotalConfig config;

	private final ItemManager itemManager;

	private Widget inventoryWidget;
	private ItemContainer inventoryItemContainer;
	private ItemContainer equipmentItemContainer;

	private boolean onceBank = false;

	private boolean showInterstitial = false;

	private boolean postNewRun = false;
	private long newRunTime = 0;

	private int invX = -1;
	private int invY = -1;
	private int invW = -1;
	private int invH = -1;

	private Widget viewportWidget;
	private int canvasX = 0;
	private int canvasY = 0;
	private int canvasWidth = 0;
	private int canvasHeight = 0;

	private boolean isResizableModern = true;

	@Inject
	private InventoryTotalOverlay(Client client, InventoryTotalPlugin plugin, InventoryTotalConfig config, ItemManager itemManager)
	{
		setPosition(OverlayPosition.DYNAMIC);
		setLayer(OverlayLayer.ABOVE_WIDGETS);

		this.client = client;
		this.plugin = plugin;
		this.config = config;

		this.itemManager = itemManager;
	}

	private Widget getViewportWidget()
	{
		Widget widget;

		widget = client.getWidget(ComponentID.RESIZABLE_VIEWPORT_INTERFACE_CONTAINER);
		if (widget != null && !widget.isHidden())
		{
			isResizableModern = false;
			return widget;
		}

		widget = client.getWidget(ComponentID.RESIZABLE_VIEWPORT_BOTTOM_LINE_INTERFACE_CONTAINER);
		if (widget != null && !widget.isHidden())
		{
			isResizableModern = true;
			return widget;
		}

		widget = client.getWidget(ComponentID.FIXED_VIEWPORT_INTERFACE_CONTAINER);
		if (widget != null && !widget.isHidden())
		{
			isResizableModern = false;
			return widget;
		}

		widget = client.getWidget(ComponentID.BANK_INVENTORY_ITEM_CONTAINER);
		if (widget != null && !widget.isHidden()) return widget;

		return null;
	}

	void updatePluginState()
	{
		inventoryWidget = client.getWidget(ComponentID.INVENTORY_CONTAINER);

		inventoryItemContainer = client.getItemContainer(InventoryID.INVENTORY);
		equipmentItemContainer = client.getItemContainer(InventoryID.EQUIPMENT);

		if (plugin.getPLToggleOverride() == null)
		{
			if (config.enableProfitLoss())
			{
				plugin.setMode(InventoryTotalMode.PROFIT_LOSS);
			}
			else
			{
				plugin.setMode(InventoryTotalMode.TOTAL);
			}
		}
		else if (plugin.getPLToggleOverride() == InventoryTotalMode.PROFIT_LOSS)
		{
			plugin.setMode(InventoryTotalMode.PROFIT_LOSS);
		}
		else if (plugin.getPLToggleOverride() == InventoryTotalMode.TOTAL)
		{
			plugin.setMode(InventoryTotalMode.TOTAL);
		}

		boolean isBank = false;

		if (inventoryWidget == null || inventoryWidget.getCanvasLocation().getX() < 0 || inventoryWidget.isHidden())
		{
			Widget [] altInventoryWidgets = new Widget[]
			{
				client.getWidget(ComponentID.BANK_INVENTORY_ITEM_CONTAINER),
				client.getWidget(ComponentID.DEPOSIT_BOX_INVENTORY_ITEM_CONTAINER)
			};

			for (Widget altInventoryWidget: altInventoryWidgets)
			{
				inventoryWidget = altInventoryWidget;
				if (inventoryWidget != null && !inventoryWidget.isHidden())
				{
					isBank = true;
					if (!onceBank)
					{
						onceBank = true;
					}

					break;
				}
			}
		}

		if (isBank)
		{
			plugin.setState(InventoryTotalState.BANK);
		}
		else
		{
			plugin.setState(InventoryTotalState.RUN);
		}

		// before totals
		boolean newRun = (plugin.getPreviousState() == InventoryTotalState.BANK
				&& plugin.getState() == InventoryTotalState.RUN
				&& config.newRunAfterBanking()) || plugin.isManualNewRun();
		plugin.getRunData().itemQtys.clear();

		// totals
		int [] inventoryTotals = plugin.getInventoryTotals(false);
		int [] equipmentTotals = plugin.getEquipmentTotals(false);

		int inventoryTotal = inventoryTotals[InventoryTotalPlugin.TOTAL_GP_GE_INDEX];
		int equipmentTotal = equipmentTotals[0];

		int inventoryTotalHA = inventoryTotals[InventoryTotalPlugin.TOTAL_GP_HA_INDEX];
		int equipmentTotalHA = equipmentTotals[1];

		int inventoryQty = inventoryTotals[InventoryTotalPlugin.TOTAL_QTY_INDEX];

		int totalGp = 0;
		if (config.priceType() == InventoryTotalPriceType.GRAND_EXCHANGE)
		{
			totalGp += inventoryTotal;
		}
		else
		{
			totalGp += inventoryTotalHA;
		}

		if ((plugin.getState() == InventoryTotalState.RUN || !config.newRunAfterBanking())
				&& plugin.getMode() == InventoryTotalMode.PROFIT_LOSS)
		{
			if (config.priceType() == InventoryTotalPriceType.GRAND_EXCHANGE)
			{
				totalGp += equipmentTotal;
			}
			else
			{
				totalGp += equipmentTotalHA;
			}
		}

		plugin.setTotalGp(totalGp);
		plugin.setTotalQty(inventoryQty);

		// after totals
		if (newRun)
		{
			plugin.onNewRun();

			postNewRun = true;
			newRunTime = Instant.now().toEpochMilli();
		}
		else if (plugin.getPreviousState() == InventoryTotalState.RUN && plugin.getState() == InventoryTotalState.BANK)
		{
			plugin.onBank();
		}

		// check post new run
		if (postNewRun && (Instant.now().toEpochMilli() - newRunTime) > BANK_CLOSE_DELAY)
		{
			plugin.postNewRun();
			postNewRun = false;
		}
	}

	@Override
	public Dimension render(Graphics2D graphics)
	{
		updatePluginState();

		viewportWidget = getViewportWidget();
		Widget depositBox = client.getWidget(ComponentID.DEPOSIT_BOX_INVENTORY_ITEM_CONTAINER);

		if (viewportWidget == null
				|| viewportWidget.isHidden()
				|| (depositBox != null && !depositBox.isHidden()))
		{
			return null;
		}

		canvasX = viewportWidget.getCanvasLocation().getX();
		canvasY = viewportWidget.getCanvasLocation().getY();
		canvasWidth = viewportWidget.getWidth() + 28;
		canvasHeight = viewportWidget.getHeight() + 41;

		if (inventoryWidget != null)
		{
			invX = inventoryWidget.getCanvasLocation().getX();
			invY = inventoryWidget.getCanvasLocation().getY();
			invW = inventoryWidget.getWidth();
			invH = inventoryWidget.getHeight();
		}

		if (invX < 0 || invY < 0 || invW < 0 || invH < 0)
		{
			return null;
		}

		if (config.hideWithInventory() && (inventoryWidget == null || inventoryWidget.isHidden()))
		{
			return null;
		}

		int height = 20;

		String totalText = getTotalText(plugin.getProfitGp());

		String formattedRunTime = getFormattedRunTime();
		String runTimeText = null;

		if (formattedRunTime != null)
		{
			runTimeText = " (" + formattedRunTime + ")";
		}

		long total = plugin.getProfitGp();

		if (showInterstitial)
		{
			total = 0;

			if (plugin.getMode() == InventoryTotalMode.PROFIT_LOSS)
			{
				totalText = "0";
			}
			else
			{
				totalText = getTotalText(plugin.getProfitGp());
			}
		}

		renderTotal(config, graphics, plugin,
				plugin.getTotalQty(), total, totalText, runTimeText, height);

		return null;
	}

	private void renderTotal(InventoryTotalConfig config, Graphics2D graphics, InventoryTotalPlugin plugin,
							 long totalQty, long total, String totalText,
							 String runTimeText, int height) {
		int imageSize = 15;
		boolean showCoinStack = config.showCoinStack();
		int numCoins;
		if (total > Integer.MAX_VALUE)
		{
			numCoins = Integer.MAX_VALUE;
		}
		else if (total < Integer.MIN_VALUE)
		{
			numCoins = Integer.MIN_VALUE;
		}
		else
		{
			numCoins = (int) total;
			if (numCoins == 0)
			{
				numCoins = 1000000;
			}
		}
		numCoins = Math.abs(numCoins);

		if ((totalQty == 0 && !config.showOnEmpty()) || (plugin.getState() == InventoryTotalState.BANK && !config.showWhileBanking())) {
			return;
		}

		graphics.setFont(FontManager.getRunescapeSmallFont());
		final int totalWidth = graphics.getFontMetrics().stringWidth(totalText);

		int fixedRunTimeWidth = 0;
		int actualRunTimeWidth = 0;
		int imageWidthWithPadding = 0;

		if (runTimeText != null && runTimeText.length() >= 2) {
			fixedRunTimeWidth = 5 * (runTimeText.length() - 2) + (3 * 2) + 5;
			actualRunTimeWidth = graphics.getFontMetrics().stringWidth(runTimeText);
		}

		if (showCoinStack)
		{
			imageWidthWithPadding = imageSize + 3;
		}

		int width = totalWidth + fixedRunTimeWidth + imageWidthWithPadding + HORIZONTAL_PADDING * 2;

		int x = (invX + invW / 2) - (width / 2);
		switch (config.horizontalAlignment())
		{
			case CENTER:
				break;

			case LEFT:
				x = invX;
				break;

			case RIGHT:
				x = invX + invW - width;
				break;
		}

		int xOffset = config.inventoryXOffset();
		if (config.isInventoryXOffsetNegative())
		{
			xOffset *= -1;
		}
		x += xOffset;

		int yOffset = config.inventoryYOffset();
		if (!isResizableModern && yOffset == 12)
		{
			yOffset += 30;
		}
		if (config.isInventoryYOffsetNegative())
		{
			yOffset *= -1;
		}
		int y = invY - height - yOffset;

		Color backgroundColor;
		Color borderColor;
		Color textColor;

		if ((plugin.getState() == InventoryTotalState.BANK && config.newRunAfterBanking())
				|| plugin.getMode() == InventoryTotalMode.TOTAL) {
			backgroundColor = config.totalColor();
			borderColor = config.borderColor();
			textColor = config.textColor();
		}
		else if (total >= 0) {
			backgroundColor = config.profitColor();
			borderColor = config.profitBorderColor();
			textColor = config.profitTextColor();
		}
		else {
			backgroundColor = config.lossColor();
			borderColor = config.lossBorderColor();
			textColor = config.lossTextColor();
		}

		int cornerRadius = config.cornerRadius();
		if (!config.roundCorners())
		{
			cornerRadius = 0;
		}

		int containerAlpha = backgroundColor.getAlpha();

		if (containerAlpha > 0) {
			graphics.setColor(borderColor);
			graphics.drawRoundRect(x, y, width + 1, height + 1, cornerRadius, cornerRadius);
		}

		graphics.setColor(backgroundColor);

		graphics.fillRoundRect(x + 1, y + 1, width, height, cornerRadius, cornerRadius);

		TextComponent textComponent = new TextComponent();

		textComponent.setColor(textColor);
		textComponent.setText(totalText);
		textComponent.setPosition(new Point(x + HORIZONTAL_PADDING, y + TEXT_Y_OFFSET));
		textComponent.render(graphics);

		if (runTimeText != null)
		{
			textComponent = new TextComponent();

			textComponent.setColor(textColor);
			textComponent.setText(runTimeText);
			textComponent.setPosition(new Point((x + width) - HORIZONTAL_PADDING - actualRunTimeWidth - imageWidthWithPadding, y + TEXT_Y_OFFSET));
			textComponent.render(graphics);
		}

		if (showCoinStack)
		{
			int imageOffset = 4;

			BufferedImage coinsImage = itemManager.getImage(ItemID.COINS_995, numCoins, false);
			coinsImage = ImageUtil.resizeImage(coinsImage, imageSize, imageSize);
			graphics.drawImage(coinsImage, (x + width) - HORIZONTAL_PADDING - imageSize + imageOffset, y + 3, null);
		}

		net.runelite.api.Point mouse = client.getMouseCanvasPosition();
		int mouseX = mouse.getX();
		int mouseY = mouse.getY();

		RoundRectangle2D roundRectangle2D = new RoundRectangle2D.Double(x, y, width + 1, height + 1, cornerRadius, cornerRadius);
		if (roundRectangle2D.contains(mouseX, mouseY) && (plugin.getState() != InventoryTotalState.BANK || !config.newRunAfterBanking())
				&& (Instant.now().toEpochMilli() - newRunTime) > (BANK_CLOSE_DELAY + 500) && config.showTooltip())
		{
			if (plugin.getMode() == InventoryTotalMode.PROFIT_LOSS)
			{
				renderProfitLossLedger(graphics);
			}
			else
			{
				renderLedger(graphics);
			}
		}
	}

	private void renderLedger(Graphics2D graphics)
	{
		FontMetrics fontMetrics = graphics.getFontMetrics();

		java.util.List<InventoryTotalLedgerItem> ledger = plugin.getInventoryLedger().stream()
				.filter(item -> item.getQty() != 0).collect(Collectors.toList());

		if (ledger.isEmpty())
		{
			return;
		}

		ledger = ledger.stream().sorted(Comparator.comparingInt(o ->
				-(o.getQty() * o.getAmount()))
		).collect(Collectors.toList());

		int total = ledger.stream().mapToInt(item -> item.getQty() * item.getAmount()).sum();

		ledger.add(new InventoryTotalLedgerItem("Total", 1, total));

		String [] descriptions = ledger.stream().map(item -> {
			String desc = item.getDescription();
			if (item.getQty() != 0 && Math.abs(item.getQty()) != 1
					&& !item.getDescription().contains("Total") && !item.getDescription().contains("Coins"))
			{
				desc = NumberFormat.getInstance(Locale.ENGLISH).format(Math.abs(item.getQty())) + " " + desc;
			}
			return desc;
		}).toArray(String[]::new);
		Integer [] prices = ledger.stream().map(item -> item.getQty() * item.getAmount()).toArray(Integer[]::new);

		String [] formattedPrices = Arrays.stream(prices).map(
				p -> NumberFormat.getInstance(Locale.ENGLISH).format(p)
		).toArray(String[]::new);

		Integer [] rowWidths = IntStream.range(0, descriptions.length).mapToObj(
				i -> fontMetrics.stringWidth(descriptions[i])
						+ fontMetrics.stringWidth(formattedPrices[i])
		).toArray(Integer[]::new);

		Arrays.sort(rowWidths);

		net.runelite.api.Point mouse = client.getMouseCanvasPosition();
		int mouseX = mouse.getX();
		int mouseY = mouse.getY();

		int sectionPadding = 5;

		int rowW = rowWidths[rowWidths.length - 1] + 20 + HORIZONTAL_PADDING + 2;
		int rowH = fontMetrics.getHeight();

		int h = descriptions.length * rowH + TEXT_Y_OFFSET / 2 + sectionPadding + 1;

		int x = mouseX - rowW - 10;
		if (x + rowW > canvasX + canvasWidth - 5)
		{
			x = canvasX + canvasWidth - 5 - rowW;
		}
		else if (x < 5)
		{
			x = 5;
		}

		int y = mouseY - h / 2;
		if (y + h > canvasY + canvasHeight - 10)
		{
			y = canvasY + canvasHeight - 10 - h;
		}
		else if (y < 5)
		{
			y = 5;
		}

		int cornerRadius = 0;

		graphics.setColor(LEDGER_BACKGROUND_COLOR);
		graphics.fillRoundRect(x, y, rowW, h, cornerRadius, cornerRadius);

		int borderWidth = 1;

		graphics.setColor(Color.decode("#0b0b0b"));
		graphics.setStroke(new BasicStroke(borderWidth));
		graphics.drawRoundRect(x - borderWidth / 2, y - borderWidth / 2,
				rowW + borderWidth / 2, h + borderWidth / 2, cornerRadius, cornerRadius);

		if (descriptions.length == prices.length)
		{
			int yOffset = 0;
			String prevDesc = "";
			for (int i = 0; i < descriptions.length; i++)
			{
				String desc = descriptions[i];

				if (!prevDesc.contains("Total") && desc.contains("Total"))
				{
					yOffset += sectionPadding;
				}
				else if (i > 0 && prices[i - 1] >= 0 && prices[i] < 0 && !prevDesc.contains("Total"))
				{
					yOffset += sectionPadding;
				}

				int textX = x + HORIZONTAL_PADDING / 2 + 2;
				int textY = y + rowH * i + TEXT_Y_OFFSET + yOffset;

				TextComponent textComponent = new TextComponent();

				if (desc.contains("Total") && desc.length() == 5)
				{
					textComponent.setColor(Color.ORANGE);
				}
				else if (desc.contains("Total"))
				{
					textComponent.setColor(Color.YELLOW);
				}
				else
				{
					textComponent.setColor(Color.decode("#FFF7E3"));
				}

				textComponent.setText(desc);

				textComponent.setPosition(new Point(textX, textY));
				textComponent.render(graphics);

				prevDesc = desc;

				int price = prices[i];

				String formattedPrice = NumberFormat.getInstance(Locale.ENGLISH).format(price);

				int textW = fontMetrics.stringWidth(formattedPrice);
				textX = x + rowW - HORIZONTAL_PADDING / 2 - textW;
				textY = y + rowH * i + TEXT_Y_OFFSET + yOffset;

				textComponent = new TextComponent();
				if (price > 0)
				{
					textComponent.setColor(Color.GREEN);
				}
				else
				{
					textComponent.setColor(Color.WHITE);
				}

				textComponent.setText(formattedPrice);

				textComponent.setPosition(new Point(textX, textY));
				textComponent.render(graphics);
			}
		}
	}

	private void renderProfitLossLedger(Graphics2D graphics)
	{
		FontMetrics fontMetrics = graphics.getFontMetrics();

		java.util.List<InventoryTotalLedgerItem> ledger = plugin.getProfitLossLedger().stream()
				.filter(item -> item.getQty() != 0).collect(Collectors.toList());

		java.util.List<InventoryTotalLedgerItem> gain = ledger.stream().filter(item -> item.getQty() > 0)
				.collect(Collectors.toList());

		java.util.List<InventoryTotalLedgerItem> loss = ledger.stream().filter(item -> item.getQty() < 0)
				.collect(Collectors.toList());

		gain = gain.stream().sorted(Comparator.comparingInt(o -> -(o.getQty() * o.getAmount()))).collect(Collectors.toList());
		loss = loss.stream().sorted(Comparator.comparingInt(o -> (o.getQty() * o.getAmount()))).collect(Collectors.toList());

		ledger = new LinkedList<>();
		ledger.addAll(gain);
		ledger.addAll(loss);

		if (ledger.isEmpty())
		{
			return;
		}

		int totalGain = gain.stream().mapToInt(item -> item.getQty() * item.getAmount()).sum();
		int totalLoss = loss.stream().mapToInt(item -> item.getQty() * item.getAmount()).sum();
		int total = ledger.stream().mapToInt(item -> item.getQty() * item.getAmount()).sum();

		ledger.add(new InventoryTotalLedgerItem("Total Gain", 1, totalGain));
		ledger.add(new InventoryTotalLedgerItem("Total Loss", 1, totalLoss));
		ledger.add(new InventoryTotalLedgerItem("Total", 1, total));

		String [] descriptions = ledger.stream().map(item -> {
			String desc = item.getDescription();
			if (item.getQty() != 0 && Math.abs(item.getQty()) != 1
					&& !item.getDescription().contains("Total") && !item.getDescription().contains("Coins"))
			{
				desc = NumberFormat.getInstance(Locale.ENGLISH).format(Math.abs(item.getQty())) + " " + desc;
			}
			return desc;
		}).toArray(String[]::new);
		Integer [] prices = ledger.stream().map(item -> item.getQty() * item.getAmount()).toArray(Integer[]::new);

		String [] formattedPrices = Arrays.stream(prices).map(
				p -> NumberFormat.getInstance(Locale.ENGLISH).format(p)
		).toArray(String[]::new);

		Integer [] rowWidths = IntStream.range(0, descriptions.length).mapToObj(
				i -> fontMetrics.stringWidth(descriptions[i])
						+ fontMetrics.stringWidth(formattedPrices[i])
		).toArray(Integer[]::new);

		Arrays.sort(rowWidths);

		net.runelite.api.Point mouse = client.getMouseCanvasPosition();
		int mouseX = mouse.getX();
		int mouseY = mouse.getY();

		int sectionPadding = 5;

		int rowW = rowWidths[rowWidths.length - 1] + 20 + HORIZONTAL_PADDING + 2;
		int rowH = fontMetrics.getHeight();

		int sectionPaddingTotal = sectionPadding;
		if (!gain.isEmpty() && !loss.isEmpty())
		{
			sectionPaddingTotal += sectionPadding;
		}

		int h = descriptions.length * rowH + TEXT_Y_OFFSET / 2 + sectionPaddingTotal + 1;

		int x = mouseX - rowW - 10;
		if (x + rowW > canvasX + canvasWidth - 5)
		{
			x = canvasX + canvasWidth - 5 - rowW;
		}
		else if (x < 5)
		{
			x = 5;
		}

		int y = mouseY - h / 2;
		if (y + h > canvasY + canvasHeight - 10)
		{
			y = canvasY + canvasHeight - 10 - h;
		}
		else if (y < 5)
		{
			y = 5;
		}

		int cornerRadius = 0;

		graphics.setColor(LEDGER_BACKGROUND_COLOR);
		graphics.fillRoundRect(x, y, rowW, h, cornerRadius, cornerRadius);

		int borderWidth = 1;

		graphics.setColor(Color.decode("#0b0b0b"));
		graphics.setStroke(new BasicStroke(borderWidth));
		graphics.drawRoundRect(x - borderWidth / 2, y - borderWidth / 2,
				rowW + borderWidth / 2, h + borderWidth / 2, cornerRadius, cornerRadius);

		if (descriptions.length == prices.length)
		{
			int yOffset = 0;
			String prevDesc = "";
			for (int i = 0; i < descriptions.length; i++)
			{
				String desc = descriptions[i];

				if (!prevDesc.contains("Total") && desc.contains("Total"))
				{
					yOffset += sectionPadding;
				}
				else if (i > 0 && prices[i - 1] >= 0 && prices[i] < 0 && !prevDesc.contains("Total"))
				{
					yOffset += sectionPadding;
				}

				int textX = x + HORIZONTAL_PADDING / 2 + 2;
				int textY = y + rowH * i + TEXT_Y_OFFSET + yOffset;

				TextComponent textComponent = new TextComponent();

				if (desc.contains("Total") && desc.length() == 5)
				{
					textComponent.setColor(Color.ORANGE);
				}
				else if (desc.contains("Total"))
				{
					textComponent.setColor(Color.YELLOW);
				}
				else
				{
					textComponent.setColor(Color.decode("#FFF7E3"));
				}

				textComponent.setText(desc);

				textComponent.setPosition(new Point(textX, textY));
				textComponent.render(graphics);

				prevDesc = desc;

				int price = prices[i];

				String formattedPrice = NumberFormat.getInstance(Locale.ENGLISH).format(price);

				int textW = fontMetrics.stringWidth(formattedPrice);
				textX = x + rowW - HORIZONTAL_PADDING / 2 - textW;
				textY = y + rowH * i + TEXT_Y_OFFSET + yOffset;

				textComponent = new TextComponent();

				if (price > 0)
				{
					textComponent.setColor(Color.GREEN);
				}
				else if (price < 0)
				{
					textComponent.setColor(Color.RED);
				}

				textComponent.setText(formattedPrice);

				textComponent.setPosition(new Point(textX, textY));
				textComponent.render(graphics);
			}
		}
	}

	private String getTotalText(long total)
	{
		if (config.showExactGp())
		{
			return getExactFormattedGp(total);
		}
		else
		{
			String totalText = getFormattedGp(total);
			return totalText.replace(".0", "");
		}
	}

	private String getFormattedGp(long total)
	{
		if (total >= 1000000000 || total <= -1000000000)
		{
			double bTotal = total / 1000000000.0;
			return getTruncatedTotal(bTotal) + "B";
		}
		else
		{
			if (total >= 1000000 || total <= -1000000)
			{
				double mTotal = total / 1000000.0;
				return getTruncatedTotal(mTotal) + "M";
			}
			else
			{
				if (total >= 1000 || total <= -1000)
				{
					double kTotal = total / 1000.0;
					return getTruncatedTotal(kTotal) + "K";
				}
				else
				{
					return getExactFormattedGp(total);
				}
			}
		}
	}

	private String getTruncatedTotal(double total)
	{
		String totalString = Double.toString(total);

		int dotIndex = totalString.indexOf('.');
		if (dotIndex < totalString.length() - 1)
		{
			return totalString.substring(0, dotIndex + 2);
		}

		return totalString;
	}

	private String getExactFormattedGp(long total)
	{
		return NumberFormat.getInstance(Locale.ENGLISH).format(total);
	}

	private String getFormattedRunTime()
	{
		long runTime = plugin.elapsedRunTime();

		if (runTime == InventoryTotalPlugin.NO_PROFIT_LOSS_TIME)
		{
			return null;
		}

		long totalSecs = runTime / 1000;
		long totalMins = totalSecs / 60;

		long hrs = totalMins / 60;
		long mins = totalMins % 60;
		long secs = totalSecs % 60;

		if (hrs > 0)
		{
			return String.format(PROFIT_LOSS_TIME_FORMAT, hrs, mins, secs);
		}
		else
		{
			return String.format(PROFIT_LOSS_TIME_NO_HOURS_FORMAT, mins, secs);
		}
	}

	public ItemContainer getInventoryItemContainer()
	{
		return inventoryItemContainer;
	}

	public ItemContainer getEquipmentItemContainer()
	{
		return equipmentItemContainer;
	}

	public void showInterstitial()
	{
		showInterstitial = true;
	}

	public void hideInterstitial()
	{
		showInterstitial = false;
	}
}

package com.ericversteeg;

import com.google.gson.Gson;
import com.google.inject.Provides;
import net.runelite.api.*;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.events.ConfigChanged;
import net.runelite.client.events.RuneScapeProfileChanged;
import net.runelite.client.game.ItemManager;
import net.runelite.client.input.KeyListener;
import net.runelite.client.input.KeyManager;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.plugins.PluginDescriptor;
import net.runelite.client.ui.overlay.OverlayManager;
import net.runelite.client.util.HotkeyListener;

import javax.inject.Inject;
import java.time.Instant;
import java.util.*;
import java.util.stream.Collectors;

@PluginDescriptor(
	name = "Inventory Total",
	description = "Totals item prices in your inventory."
)

public class InventoryTotalPlugin extends Plugin
{
	static final int COINS = ItemID.COINS_995;
	static final int TOTAL_GP_GE_INDEX = 0;
	static final int TOTAL_GP_HA_INDEX = 1;
	static final int TOTAL_QTY_INDEX = 2;
	static final int NO_PROFIT_LOSS_TIME = -1;
	static final int RUNEPOUCH_ITEM_ID = 12791;
	static final int DIVINE_RUNEPOUCH_ITEM_ID = 27281;

	@Inject
	private InventoryTotalOverlay overlay;

	@Inject
	private OverlayManager overlayManager;

	@Inject
	private Client client;

	@Inject
	private InventoryTotalConfig config;

	@Inject
	private ClientThread clientThread;

	@Inject
	private ItemManager itemManager;

	@Inject
	private ConfigManager configManager;

	@Inject
	private Gson gson;

	@Inject
	private KeyManager keyManager;

	private String profileKey = "";

	private InventoryTotalRunData runData;

	private InventoryTotalMode mode = InventoryTotalMode.TOTAL;

	private InventoryTotalState state = InventoryTotalState.NONE;
	private InventoryTotalState prevState = InventoryTotalState.NONE;

	private long totalGp = 0;
	private long totalQty = 0;

	private long runStartTime = 0;

	private long lastWriteSaveTime = 0;

	private InventoryTotalMode plToggleOverride = null;
	private KeyListener plToggleKeyListener;
	private KeyListener newRunKeyListener;

	private boolean manualNewRun = false;

	// from ClueScrollPlugin
	private static final int[] RUNEPOUCH_AMOUNT_VARBITS = {
			Varbits.RUNE_POUCH_AMOUNT1, Varbits.RUNE_POUCH_AMOUNT2, Varbits.RUNE_POUCH_AMOUNT3, Varbits.RUNE_POUCH_AMOUNT4
	};
	private static final int[] RUNEPOUCH_RUNE_VARBITS = {
			Varbits.RUNE_POUCH_RUNE1, Varbits.RUNE_POUCH_RUNE2, Varbits.RUNE_POUCH_RUNE3, Varbits.RUNE_POUCH_RUNE4
	};

	@Override
	protected void startUp() throws Exception
	{
		overlayManager.add(overlay);

		runData = new InventoryTotalRunData();

		registerKeys();
	}

	@Override
	protected void shutDown() throws Exception
	{
		overlayManager.remove(overlay);

		unregisterKeys();
	}

	@Subscribe
	public void onRuneScapeProfileChanged(RuneScapeProfileChanged e)
	{
		profileKey = configManager.getRSProfileKey();
		if (profileKey != null)
		{
			runData = getSavedData();
		}
	}

	@Provides
	InventoryTotalConfig provideConfig(ConfigManager configManager)
	{
		return configManager.getConfig(InventoryTotalConfig.class);
	}

	@Subscribe
	public void onConfigChanged(ConfigChanged config)
	{
		if (config.getGroup().equals(InventoryTotalConfig.GROUP))
		{
			if (config.getKey().equals("enableProfitLoss"))
			{
				plToggleOverride = null;
			}
			else if (config.getKey().equals("profitLossToggleKey"))
			{
				unregisterKeys();
				registerKeys();
			}
			else if (config.getKey().equals("ignoredItems"))
			{
				// update the runData if it's already initialized
				if (runData != null) {
					runData.ignoredItems = getIgnoredItems();
				}
			}
		}
	}

	private void registerKeys()
	{
		// switch mode
		plToggleKeyListener = new HotkeyListener(() -> config.profitLossToggleKey())
		{
			@Override
			public void hotkeyPressed()
			{
				if (mode == InventoryTotalMode.TOTAL)
				{
					plToggleOverride = InventoryTotalMode.PROFIT_LOSS;
				}
				else
				{
					plToggleOverride = InventoryTotalMode.TOTAL;
				}
			}
		};
		keyManager.registerKeyListener(plToggleKeyListener);

		// new run
		newRunKeyListener = new HotkeyListener(() -> config.newRunKey())
		{
			@Override
			public void hotkeyPressed()
			{
				if (state != InventoryTotalState.BANK)
				{
					manualNewRun = true;
				}
			}
		};
		keyManager.registerKeyListener(newRunKeyListener);
	}

	private void unregisterKeys()
	{
		if (plToggleKeyListener != null)
		{
			keyManager.unregisterKeyListener(plToggleKeyListener);
		}
		if (newRunKeyListener != null)
		{
			keyManager.unregisterKeyListener(newRunKeyListener);
		}
	}

	void onNewRun()
	{
		overlay.showInterstitial();

		runStartTime = Instant.now().toEpochMilli();

		runData.ignoredItems = getIgnoredItems();
	}

	// to handle same tick bank closing
	void postNewRun()
	{
		runData.initialItemQtys.clear();

		int [] inventoryTotals = getInventoryTotals(true);
		int [] equipmentTotals = getEquipmentTotals(true);

		int inventoryTotal = inventoryTotals[InventoryTotalPlugin.TOTAL_GP_GE_INDEX];
		int inventoryTotalHA = inventoryTotals[InventoryTotalPlugin.TOTAL_GP_HA_INDEX];

		int equipmentTotal = equipmentTotals[0];
		int equipmentTotalHA = equipmentTotals[1];

		runData.profitLossInitialGp = inventoryTotal + equipmentTotal;
		runData.profitLossInitialGpHA = inventoryTotalHA + equipmentTotalHA;

		writeSavedData();

		overlay.hideInterstitial();
	}

	void onBank()
	{
		if (!config.newRunAfterBanking())
		{
			return;
		}

		runData.profitLossInitialGp = 0;
		runData.profitLossInitialGpHA = 0;
		runData.itemPrices.clear();

		runStartTime = 0;

		writeSavedData();
	}

	int [] getInventoryTotals(boolean isNewRun)
	{
		final ItemContainer itemContainer = overlay.getInventoryItemContainer();

		if (itemContainer == null)
		{
			return new int [2];
		}

		final Item[] items = itemContainer.getItems();

		final LinkedList<Item> allItems = new LinkedList<>(Arrays.asList(items));
		// only add when the runepouch is in the inventory
		if (allItems.stream().anyMatch(s -> s.getId() == RUNEPOUCH_ITEM_ID || s.getId() == DIVINE_RUNEPOUCH_ITEM_ID))
		{
			allItems.addAll(getRunepouchContents());
		}

		int totalQty = 0;
		int totalGp = 0;
		int totalGpHA = 0;

		for (Item item: allItems)
		{
			int itemId = item.getId();

			final ItemComposition itemComposition = itemManager.getItemComposition(itemId);

			String itemName = itemComposition.getName();
			final boolean ignore = runData.ignoredItems.stream().anyMatch(s -> {
				String lcItemName = itemName.toLowerCase();
				String lcS = s.toLowerCase();
				return lcItemName.contains(lcS);
			});
			if (ignore) { continue; }

			final boolean isNoted = itemComposition.getNote() != -1;
			final int realItemId = isNoted ? itemComposition.getLinkedNoteId() : itemId;

			int totalPrice;
			int totalPriceHA;
			int gePrice;
			int haPrice;

			if (runData.itemPrices.containsKey(realItemId))
			{
				gePrice = runData.itemPrices.get(realItemId);
			}
			else
			{
				gePrice = itemManager.getItemPrice(realItemId);
			}

			if (runData.itemPricesHA.containsKey(realItemId))
			{
				haPrice = runData.itemPricesHA.get(realItemId);
			}
			else
			{
				haPrice = itemComposition.getHaPrice();
			}

			int itemQty = item.getQuantity();

			if (realItemId == COINS)
			{
				totalPrice = itemQty;
			}
			else
			{
				totalPrice = itemQty * gePrice;
			}

			if (realItemId == COINS)
			{
				totalPriceHA = itemQty;
			}
			else
			{
				totalPriceHA = itemQty * haPrice;
			}

			totalGp += totalPrice;
			totalGpHA += totalPriceHA;
			totalQty += itemQty;

			if (realItemId != COINS && !runData.itemPrices.containsKey(realItemId))
			{
				runData.itemPrices.put(realItemId, gePrice);
			}

			if (realItemId != COINS && !runData.itemPricesHA.containsKey(realItemId))
			{
				runData.itemPricesHA.put(realItemId, haPrice);
			}

			if (isNewRun)
			{
				if (runData.initialItemQtys.containsKey(realItemId))
				{
					runData.initialItemQtys.put(realItemId, runData.initialItemQtys.get(realItemId) + itemQty);
				}
				else
				{
					runData.initialItemQtys.put(realItemId, itemQty);
				}
			}

			if (runData.itemQtys.containsKey(realItemId))
			{
				runData.itemQtys.put(realItemId, runData.itemQtys.get(realItemId) + itemQty);
			}
			else
			{
				runData.itemQtys.put(realItemId, itemQty);
			}
		}

		int[] totals = new int[3];

		totals[TOTAL_GP_GE_INDEX] = totalGp;
		totals[TOTAL_GP_HA_INDEX] = totalGpHA;
		totals[TOTAL_QTY_INDEX] = totalQty;

		return totals;
	}

	int [] getEquipmentTotals(boolean isNewRun)
	{
		final ItemContainer itemContainer = client.getItemContainer(InventoryID.EQUIPMENT);

		if (itemContainer == null)
		{
			return new int [] {0, 0};
		}

		Item ammo = itemContainer.getItem(EquipmentInventorySlot.AMMO.getSlotIdx());

		List<Integer> eIds = getEquipmentIds();

		int eTotal = 0;
		int eTotalHA = 0;
		for (int itemId: eIds)
		{
			int qty = 1;
			if (ammo != null && itemId == ammo.getId())
			{
				qty = ammo.getQuantity();
			}

			int gePrice;
			int haPrice;

			if (runData.itemPrices.containsKey(itemId))
			{
				gePrice = runData.itemPrices.get(itemId);
			}
			else
			{
				gePrice = itemManager.getItemPrice(itemId);
			}

			if (runData.itemPricesHA.containsKey(itemId))
			{
				haPrice = runData.itemPricesHA.get(itemId);
			}
			else
			{
				ItemComposition itemComposition = itemManager.getItemComposition(itemId);
				haPrice = itemComposition.getHaPrice();
			}

			int totalPrice = qty * gePrice;
			int totalPriceHA = qty * haPrice;

			eTotal += totalPrice;
			eTotalHA += totalPriceHA;

			if (!runData.itemPrices.containsKey(itemId))
			{
				runData.itemPrices.put(itemId, gePrice);
			}

			if (!runData.itemPricesHA.containsKey(itemId))
			{
				runData.itemPricesHA.put(itemId, haPrice);
			}

			if (isNewRun)
			{
				if (runData.initialItemQtys.containsKey(itemId))
				{
					runData.initialItemQtys.put(itemId, runData.initialItemQtys.get(itemId) + qty);
				}
				else
				{
					runData.initialItemQtys.put(itemId, qty);
				}
			}

			if (runData.itemQtys.containsKey(itemId))
			{
				runData.itemQtys.put(itemId, runData.itemQtys.get(itemId) + qty);
			}
			else
			{
				runData.itemQtys.put(itemId, qty);
			}
		}

		return new int [] {eTotal, eTotalHA};
	}

	private List<Integer> getEquipmentIds()
	{
		List<Item> equipment = getEquipment();

		return equipment
				.stream()
				.map(Item::getId)
				.collect(Collectors.toList());
	}

	private List<Item> getEquipment()
	{
		final ItemContainer equipment = client.getItemContainer(InventoryID.EQUIPMENT);

		if (equipment == null)
		{
			return new ArrayList<>();
		}

		Item head = equipment.getItem(EquipmentInventorySlot.HEAD.getSlotIdx());
		Item cape = equipment.getItem(EquipmentInventorySlot.CAPE.getSlotIdx());
		Item amulet = equipment.getItem(EquipmentInventorySlot.AMULET.getSlotIdx());
		Item ammo = equipment.getItem(EquipmentInventorySlot.AMMO.getSlotIdx());
		Item weapon = equipment.getItem(EquipmentInventorySlot.WEAPON.getSlotIdx());
		Item body = equipment.getItem(EquipmentInventorySlot.BODY.getSlotIdx());
		Item shield = equipment.getItem(EquipmentInventorySlot.SHIELD.getSlotIdx());
		Item legs = equipment.getItem(EquipmentInventorySlot.LEGS.getSlotIdx());
		Item gloves = equipment.getItem(EquipmentInventorySlot.GLOVES.getSlotIdx());
		Item boots = equipment.getItem(EquipmentInventorySlot.BOOTS.getSlotIdx());
		Item ring = equipment.getItem(EquipmentInventorySlot.RING.getSlotIdx());

		List<Item> items = new ArrayList<Item>();

		if (head != null)
		{
			items.add(head);
		}

		if (cape != null)
		{
			items.add(cape);
		}

		if (amulet != null)
		{
			items.add(amulet);
		}

		if (ammo != null)
		{
			items.add(ammo);
		}

		if (weapon != null)
		{
			items.add(weapon);
		}

		if (body != null)
		{
			items.add(body);
		}

		if (shield != null)
		{
			items.add(shield);
		}

		if (legs != null)
		{
			items.add(legs);
		}

		if (gloves != null)
		{
			items.add(gloves);
		}

		if (boots != null)
		{
			items.add(boots);
		}

		if (ring != null)
		{
			items.add(ring);
		}

		return items;
	}

	List<InventoryTotalLedgerItem> getInventoryLedger()
	{
		List<InventoryTotalLedgerItem> ledgerItems = new LinkedList<>();

		final ItemContainer itemContainer = overlay.getInventoryItemContainer();

		if (itemContainer == null)
		{
			return new LinkedList<>();
		}

		final Item[] items = itemContainer.getItems();

		final LinkedList<Item> allItems = new LinkedList<>(Arrays.asList(items));
		// only add when the runepouch is in the inventory
		if (allItems.stream().anyMatch(s -> s.getId() == RUNEPOUCH_ITEM_ID || s.getId() == DIVINE_RUNEPOUCH_ITEM_ID))
		{
			allItems.addAll(getRunepouchContents());
		}

		Map<Integer, Integer> qtyMap = new HashMap<>();

		for (Item item: allItems) {
			int itemId = item.getId();

			final ItemComposition itemComposition = itemManager.getItemComposition(itemId);

			String itemName = itemComposition.getName();
			final boolean ignore = runData.ignoredItems.stream().anyMatch(s -> {
				String lcItemName = itemName.toLowerCase();
				String lcS = s.toLowerCase();
				return lcItemName.contains(lcS);
			});
			if (ignore) { continue; }

			final boolean isNoted = itemComposition.getNote() != -1;
			final int realItemId = isNoted ? itemComposition.getLinkedNoteId() : itemId;

			int itemQty = item.getQuantity();

			if (qtyMap.containsKey(realItemId))
			{
				qtyMap.put(realItemId, qtyMap.get(realItemId) + itemQty);
			}
			else
			{
				qtyMap.put(realItemId, itemQty);
			}
		}

		for (Integer itemId: qtyMap.keySet())
		{
			final ItemComposition itemComposition = itemManager.getItemComposition(itemId);

			String itemName = itemComposition.getName();

			Integer qty = qtyMap.get(itemId);

			Integer total;
			if (config.priceType() == InventoryTotalPriceType.GRAND_EXCHANGE)
			{
				total = runData.itemPrices.get(itemId);
			}
			else
			{
				total = runData.itemPricesHA.get(itemId);
			}

			if (itemId == COINS || total == null)
			{
				total = 1;
			}

			ledgerItems.add(new InventoryTotalLedgerItem(itemName, qty, total));
		}

		return ledgerItems;
	}

	List<InventoryTotalLedgerItem> getProfitLossLedger()
	{
		Map<Integer, Integer> prices;
		if (config.priceType() == InventoryTotalPriceType.GRAND_EXCHANGE)
		{
			prices = runData.itemPrices;
		}
		else
		{
			prices = runData.itemPricesHA;
		}

		Map<Integer, Integer> initialQtys = runData.initialItemQtys;
		Map<Integer, Integer> qtys = runData.itemQtys;

		Map<Integer, Integer> qtyDifferences = new HashMap<>();

		HashSet<Integer> combinedQtyKeys = new HashSet<>();
		combinedQtyKeys.addAll(qtys.keySet());
		combinedQtyKeys.addAll(initialQtys.keySet());

		for (Integer itemId: combinedQtyKeys)
		{
			Integer initialQty = initialQtys.get(itemId);
			Integer qty = qtys.get(itemId);

			if (initialQty == null)
			{
				initialQty = 0;
			}

			if (qty == null)
			{
				qty = 0;
			}

			qtyDifferences.put(itemId, qty - initialQty);
		}

		List<InventoryTotalLedgerItem> ledgerItems = new LinkedList<>();

		for (Integer itemId: qtyDifferences.keySet())
		{
			final ItemComposition itemComposition = itemManager.getItemComposition(itemId);
			Integer price = prices.get(itemId);

			if (price == null)
			{
				price = 1;
			}

			Integer qtyDifference = qtyDifferences.get(itemId);

			List<InventoryTotalLedgerItem> filteredList = ledgerItems.stream().filter(
					item -> item.getDescription().equals(itemComposition.getName())).collect(Collectors.toList()
			);

			if (!filteredList.isEmpty())
			{
				filteredList.get(0).addQuantityDifference(qtyDifference);
			}
			else
			{
				if (price > 0)
				{
					ledgerItems.add(new InventoryTotalLedgerItem(itemComposition.getName(), qtyDifference, price));
				}
			}
		}

		return ledgerItems;
	}

	// from ClueScrollPlugin
	private List<Item> getRunepouchContents()
	{
		EnumComposition runepouchEnum = client.getEnum(EnumID.RUNEPOUCH_RUNE);
		List<Item> items = new ArrayList<>(RUNEPOUCH_AMOUNT_VARBITS.length);
		for (int i = 0; i < RUNEPOUCH_AMOUNT_VARBITS.length; i++)
		{
			int amount = client.getVarbitValue(RUNEPOUCH_AMOUNT_VARBITS[i]);
			if (amount <= 0)
			{
				continue;
			}

			int runeId = client.getVarbitValue(RUNEPOUCH_RUNE_VARBITS[i]);
			if (runeId == 0)
			{
				continue;
			}

			final int itemId = runepouchEnum.getIntValue(runeId);
			Item item = new Item(itemId, amount);
			items.add(item);
		}
		return items;
	}

	// max invoke rate approximately once per tick
	// mainly so that initially this isn't getting invoked multiple times after item prices are added to the map
	void writeSavedData()
	{
		if (state == InventoryTotalState.BANK || Instant.now().toEpochMilli() - lastWriteSaveTime < 600)
		{
			return;
		}

		String profile = configManager.getRSProfileKey();

		String json = gson.toJson(runData);
		configManager.setConfiguration(InventoryTotalConfig.GROUP, profile, "inventory_total_data", json);

		lastWriteSaveTime = Instant.now().toEpochMilli();
	}

	private InventoryTotalRunData getSavedData()
	{
		String profile = configManager.getRSProfileKey();
		String json = configManager.getConfiguration(InventoryTotalConfig.GROUP, profile, "inventory_total_data");

		InventoryTotalRunData savedData = gson.fromJson(json, InventoryTotalRunData.class);

		if (savedData == null)
		{
			return new InventoryTotalRunData();
		}
		return savedData;
	}

	private LinkedList<String> getIgnoredItems() {
		return new LinkedList<>(
			Arrays.asList(
				config.ignoredItems().split("\\s*,\\s*")
			)
		);
	}

	long elapsedRunTime()
	{
		if (runStartTime == 0 || !config.showRunTime())
		{
			return NO_PROFIT_LOSS_TIME;
		}

		return Instant
				.now()
				.minusMillis(runStartTime)
				.toEpochMilli();
	}

	void setMode(InventoryTotalMode mode)
	{
		this.mode = mode;
	}

	public InventoryTotalMode getMode()
	{
		return mode;
	}

	void setState(InventoryTotalState state)
	{
		this.prevState = this.state;
		this.state = state;
	}

	public InventoryTotalState getState()
	{
		return state;
	}

	public InventoryTotalState getPreviousState()
	{
		return prevState;
	}

	public long getProfitGp()
	{
		if (mode == InventoryTotalMode.TOTAL)
		{
			return totalGp;
		}
		else if (config.priceType() == InventoryTotalPriceType.GRAND_EXCHANGE)
		{
			return totalGp - runData.profitLossInitialGp;
		}
		else
		{
			return totalGp - runData.profitLossInitialGpHA;
		}
	}

	void setTotalGp(long totalGp)
	{
		this.totalGp = totalGp;
	}

	void setTotalQty(long totalQty)
	{
		this.totalQty = totalQty;
	}

	public long getTotalQty()
	{
		return totalQty;
	}

	public InventoryTotalRunData getRunData()
	{
		return runData;
	}

	public InventoryTotalMode getPLToggleOverride()
	{
		return plToggleOverride;
	}

	public boolean isManualNewRun()
	{
		if (manualNewRun)
		{
			manualNewRun = false;
			return true;
		}
		return false;
	}
}

package com.ericversteeg;

import java.util.HashMap;
import java.util.LinkedList;
import java.util.Map;

public class InventoryTotalRunData {
    long profitLossInitialGp = 0;
    long profitLossInitialGpHA = 0;

    // static item prices so that when ItemManager updates, the Profit / Loss value doesn't all of a sudden change
    // this is cleared and repopulated at the start off each new run (after bank) and whenever new items hit the inventory
    Map<Integer, Integer> itemPrices = new HashMap<>();
    Map<Integer, Integer> itemPricesHA = new HashMap<>();
    Map<Integer, Integer> initialItemQtys = new HashMap<>();
    Map<Integer, Integer> itemQtys = new HashMap<>();

    LinkedList<String> ignoredItems = new LinkedList<>();
}

package com.ericversteeg;

public class InventoryTotalLedgerItem {
    private final String description;
    private int qty;
    private final int amount;

    public InventoryTotalLedgerItem(String description, int qty, int amount)
    {
        this.description = description;
        this.qty = qty;
        this.amount = amount;
    }

    public String getDescription()
    {
        return description;
    }

    public int getQty()
    {
        return qty;
    }

    public int getAmount()
    {
        return amount;
    }

    public void addQuantityDifference(int qtyDifference)
    {
        qty += qtyDifference;
    }
}

