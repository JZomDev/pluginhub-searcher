/*
 * Copyright (c) 2020, dekvall <https://github.com/dekvall>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.rainbowrave;

import com.google.common.base.Strings;
import lombok.Value;

@Value
class ItemThreshold
{
	enum Inequality
	{
		LESS_THAN,
		MORE_THAN
	}

	private final String itemName;
	private final int quantity;
	private final Inequality inequality;

	static ItemThreshold fromConfigEntry(String entry)
	{
		if (Strings.isNullOrEmpty(entry))
		{
			return null;
		}

		Inequality operator = Inequality.MORE_THAN;
		int qty = 0;

		for (int i = entry.length() - 1; i >= 0; i--)
		{
			char c = entry.charAt(i);
			if (c >= '0' && c <= '9' || Character.isWhitespace(c))
			{
				continue;
			}
			switch (c)
			{
				case '<':
					operator = Inequality.LESS_THAN;
					// fallthrough
				case '>':
					if (i + 1 < entry.length())
					{
						try
						{
							qty = Integer.parseInt(entry.substring(i + 1).trim());
						}
						catch (NumberFormatException e)
						{
							qty = 0;
							operator = Inequality.MORE_THAN;
						}
						entry = entry.substring(0, i);
					}
			}
			break;
		}

		return new ItemThreshold(entry.trim(), qty, operator);
	}

	boolean quantityHolds(int itemCount)
	{
		if (inequality == Inequality.LESS_THAN)
		{
			return itemCount < quantity;
		}
		else
		{
			return itemCount > quantity;
		}
	}
}

/*
 * Copyright (c) 2018, Tomas Slusny <slusnucky@gmail.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.rainbowrave;

import com.google.common.base.Strings;
import java.awt.BasicStroke;
import java.awt.Color;
import java.awt.Dimension;
import java.awt.Graphics2D;
import java.awt.Shape;
import java.awt.Stroke;
import net.runelite.api.Client;
import net.runelite.api.DecorativeObject;
import net.runelite.api.GameObject;
import net.runelite.api.GroundObject;
import net.runelite.api.ObjectComposition;
import net.runelite.api.TileObject;
import net.runelite.api.WallObject;
import net.runelite.client.plugins.objectindicators.ObjectIndicatorsConfig;
import net.runelite.client.ui.overlay.Overlay;
import net.runelite.client.ui.overlay.OverlayLayer;
import net.runelite.client.ui.overlay.OverlayPosition;
import net.runelite.client.ui.overlay.OverlayUtil;
import net.runelite.client.ui.overlay.outline.ModelOutlineRenderer;

class RainbowRaveObjectIndicatorsOverlay extends Overlay
{
	private final Client client;
	private final ObjectIndicatorsConfig config;
	private final RainbowRaveObjectIndicatorsPlugin plugin;
	private final RainbowRaveConfig rainbowRaveConfig;
	private final ModelOutlineRenderer modelOutlineRenderer;
	private final RainbowRavePlugin rainbowRavePlugin;

	public RainbowRaveObjectIndicatorsOverlay(Client client, ObjectIndicatorsConfig config, RainbowRaveObjectIndicatorsPlugin plugin,
											   ModelOutlineRenderer modelOutlineRenderer, RainbowRavePlugin rainbowRavePlugin, RainbowRaveConfig rainbowRaveConfig)
	{
		this.client = client;
		this.config = config;
		this.plugin = plugin;
		this.modelOutlineRenderer = modelOutlineRenderer;
		this.rainbowRaveConfig = rainbowRaveConfig;
		this.rainbowRavePlugin = rainbowRavePlugin;
		setPosition(OverlayPosition.DYNAMIC);
		setPriority(Overlay.PRIORITY_LOW);
		setLayer(OverlayLayer.ABOVE_SCENE);
	}

	@Override
	public Dimension render(Graphics2D graphics)
	{
		Stroke stroke = new BasicStroke((float) config.borderWidth());
		int plane = client.getTopLevelWorldView().getPlane();
		for (ColorTileObject colorTileObject : plugin.getObjects())
		{
			TileObject object = colorTileObject.getTileObject();
			Color color = rainbowRavePlugin.getColor(colorTileObject.hashCode());

			if (object.getPlane() != plane)
			{
				continue;
			}

			ObjectComposition composition = colorTileObject.getComposition();
			if (composition.getImpostorIds() != null)
			{
				// This is a multiloc
				composition = composition.getImpostor();
				// Only mark the object if the name still matches
				if (composition == null
					|| Strings.isNullOrEmpty(composition.getName())
					|| "null".equals(composition.getName())
					|| !composition.getName().equals(colorTileObject.getName()))
				{
					continue;
				}
			}

			if (color == null)
			{
				// Fallback to the current config if the object is marked before the addition of multiple colors
				color = config.markerColor();
			}

			if (config.highlightHull())
			{
				renderConvexHull(graphics, object, color, stroke);
			}

			if (config.highlightOutline())
			{
				modelOutlineRenderer.drawOutline(object, (int)config.borderWidth(), color, config.outlineFeather());
			}
		}

		return null;
	}

	private void renderConvexHull(Graphics2D graphics, TileObject object, Color color, Stroke stroke)
	{
		final Shape polygon;
		Shape polygon2 = null;

		if (object instanceof GameObject)
		{
			polygon = ((GameObject) object).getConvexHull();
		}
		else if (object instanceof WallObject)
		{
			polygon = ((WallObject) object).getConvexHull();
			polygon2 = ((WallObject) object).getConvexHull2();
		}
		else if (object instanceof DecorativeObject)
		{
			polygon = ((DecorativeObject) object).getConvexHull();
			polygon2 = ((DecorativeObject) object).getConvexHull2();
		}
		else if (object instanceof GroundObject)
		{
			polygon = ((GroundObject) object).getConvexHull();
		}
		else
		{
			polygon = object.getCanvasTilePoly();
		}

		if (polygon != null)
		{
			OverlayUtil.renderPolygon(graphics, polygon, color, stroke);
		}

		if (polygon2 != null)
		{
			OverlayUtil.renderPolygon(graphics, polygon2, color, stroke);
		}
	}
}
package com.rainbowrave;

import static com.rainbowrave.RainbowRaveConfig.NpcsToHighlight.SAME;
import lombok.RequiredArgsConstructor;
import net.runelite.client.config.Config;
import net.runelite.client.config.ConfigGroup;
import net.runelite.client.config.ConfigItem;
import net.runelite.client.config.ConfigSection;
import net.runelite.client.plugins.grounditems.config.HighlightTier;

@ConfigGroup(RainbowRavePlugin.GROUP)
public interface RainbowRaveConfig extends Config
{

	String LOOT_BEAMS_TIER_CONFIG_KEY = "groundItemsLootbeamTier";
	String LOOT_BEAMS_HIGHLIGHT_CONFIG_KEY = "groundItemsHighlightedItemsLootbeam";

	enum NpcsToHighlight {
		NONE,
		SAME,
		ALL
	}

	enum ObjectsToHighlight {
		NONE,
		SAME,
		ALL
	}

	enum ItemsToTag {
		NONE,
		SAME,
		ALL
	}

	@RequiredArgsConstructor
	enum GroundItemsToColor {
		NONE(HighlightTier.INSANE.ordinal() + 1),
		INSANE(HighlightTier.INSANE.ordinal()),
		HIGH(HighlightTier.HIGH.ordinal()),
		MEDIUM(HighlightTier.MEDIUM.ordinal()),
		LOW(HighlightTier.LOW.ordinal()),
		REGULAR(HighlightTier.LOW.ordinal() - 1),
		HIDDEN(HighlightTier.LOW.ordinal() - 2),
		;

		public final int highlightTierRelativeOrdinal;
	}

	enum GroundMarkerColorMode {
		WAVES,
		RANDOM,
		COLOR_SYNC
	}

	enum MouseTrailStyle {
		NONE,
		ENABLED,
		SYNCED,
		PARTYMODE,
	}

	@ConfigItem(
			keyName = "theme",
			name = "Theme",
			description = "The color theme used for highlighting things.",
			position = 0
	)
	default Theme theme()
	{
		return Theme.RAINBOW;
	}

	@ConfigItem(
		keyName = "colorSpeed",
		name = "Color speed (ms)",
		description = "How fast the colors change (ms per full cycle)",
		position = 0
	)
	default int colorSpeed()
	{
		return 6000;
	}

	@ConfigItem(
		keyName = "syncColor",
		name = "Sync colors",
		description = "Make all highlighted things be the same color as each other.",
		position = 1
	)
	default boolean syncColor()
	{
		return false;
	}

	@ConfigItem(
		keyName = "highlightSelf",
		name = "Highlight self",
		description = "Highlight your own player character. Uses Npc Indicator's settings.",
		position = 2
	)
	default boolean highlightSelf()
	{
		return false;
	}

	@ConfigItem(
		keyName = "highlightOthers",
		name = "Highlight others",
		description = "Highlight other players' characters. Uses Npc Indicator's settings.",
		position = 3
	)
	default boolean highlightOthers()
	{
		return false;
	}

	@ConfigItem(
		keyName = "whichNpcsToHighlight",
		name = "Npc highlight",
		description = "Which npcs to highlight",
		position = 4
	)
	default NpcsToHighlight whichNpcsToHighlight()
	{
		return SAME;
	}

	@ConfigItem(
		keyName = "rainbowTileMarkers",
		name = "Rainbow tile markers",
		description = "Make tile markers rainbow",
		position = 5
	)
	default boolean rainbowTileMarkers()
	{
		return true;
	}

	String OLD_TILE_COLOR_WAVES_KEY = "smoothWaves";
	String GROUND_MARKER_COLOR_MODE_KEY = "groundMarkerColorMode";

	@ConfigItem(name=
		"Tile Color Mode",
		description = "\"waves\" makes tile color smooth between adjacent tiles, and \"color sync\" makes tiles with the same color in ground markers share the same color.", keyName = GROUND_MARKER_COLOR_MODE_KEY, position = 6
	) default GroundMarkerColorMode groundMarkerColorMode() { return GroundMarkerColorMode.RANDOM; }

	@ConfigItem(name=
		"Fill tiles",
		description = "Fills the tile with an opaque square.", keyName = "fillTiles", position = 7
	) default boolean fillTiles() { return false; }

	@ConfigItem(name=
		"Brush Marker Tiles",
		description = "Applies rainbow to tile markers from the \"Brush Markers\" plugin hub plugin. This plugin can be used to mark lots of tiles at once.", keyName = "useBrushMarkerTiles", position = 8
	) default boolean useBrushMarkerTiles() { return false; }

	@ConfigItem(name=
		"Object highlight",
		description = "Which objects to highlight.", keyName = "whichObjectsToHighlight", position = 9
	) default ObjectsToHighlight whichObjectsToHighlight() { return ObjectsToHighlight.SAME; }

	@ConfigItem(name=
		"Inventory tags",
		description = "Which items to tag.", keyName = "whichItemsToInventoryTag", position = 10
	) default ItemsToTag whichItemsToInventoryTag() { return ItemsToTag.SAME; }

	@ConfigItem(name =
		"Highlight Ground Items",
		description = "Applies rainbow to highlighted items.", keyName = "colorHighlightedGroundItems", position = 11
	) default boolean colorHighlightedGroundItems() { return true; }

	@ConfigItem(name =
		"Ground Items",
		description = "Items in this tier and above are colored.", keyName = "whichGroundItemsToColor", position = 12
	) default GroundItemsToColor whichGroundItemsToColor() { return GroundItemsToColor.REGULAR; }

	@ConfigItem(name =
		"Scythe swings",
		description = "Recolor scythe swings. Swing trails may not return to normal after disabling.", keyName = "recolorScytheSwings", position = 13
	) default boolean recolorScytheSwings() { return false; }

	String RECOLOR_LOOT_BEAMS_KEY = "recolorLootBeams";
	@ConfigItem(
		keyName = RECOLOR_LOOT_BEAMS_KEY,
		name = "Loot beams",
		description = "Recolor loot beams.",
		position = 14
	)
	default boolean recolorLootBeams()
	{
		return true;
	}

	@ConfigItem(
			keyName = "whichMouseTrailStyle",
			name = "Mouse Trail Style",
			description = "Which trail style to use.",
			position = 16
	)
	default MouseTrailStyle whichMouseTrailStyle()
	{
		return MouseTrailStyle.NONE;
	}

	@ConfigItem(
		keyName = LOOT_BEAMS_TIER_CONFIG_KEY,
		name = "Lootbeam tier",
		description = "The lowest tier of which lootbeams should be shown for. You should modify this setting instead of the identical setting in Ground items, if you are using rainbow rave to recolor loot beams.",
		position = 101
	)
	default HighlightTier getGroundItemsLootbeamTier() {
		return HighlightTier.OFF; // Needs a value to prevent NPE in some situations.
	}

	@ConfigItem(
		keyName = LOOT_BEAMS_TIER_CONFIG_KEY,
		name = "",
		description = "",
		hidden = true
	)
	default void setGroundItemsLootbeamTier(HighlightTier tier) {

	}

	@ConfigItem(
		keyName = LOOT_BEAMS_HIGHLIGHT_CONFIG_KEY,
		name = "Highlighted item lootbeams",
		description = "Show lootbeams for highlighted items. You should modify this setting instead of the identical setting in Ground items, if you are using rainbow rave to recolor loot beams.",
		position = 100
	)
	default boolean getGroundItemsHighlightedItemsLootbeam() {
		return false;
	}

	@ConfigItem(
		keyName = LOOT_BEAMS_HIGHLIGHT_CONFIG_KEY,
		name = "",
		description = "",
		hidden = true
	)
	default void setGroundItemsHighlightedItemsLootbeam(boolean lootbeamsForHighlightedItems) {

	}

	@ConfigItem(
		keyName = "recolorDukeLights",
		name = "Duke rave",
		description = "Recolor the lights at duke. Duke lights may not return to normal after disabling.",
		position = 110
	)
	default boolean dukeRave()
	{
		return false;
	}

	@ConfigSection(name = "Tile Indicators", description = "Tile Indicators", position = 150)
	String tileIndicatorsSection = "tileIndicatorsSection";

	@ConfigItem(
		keyName = "recolorTileIndicators",
		name = "Tile indicators",
		description = "Recolor the tiles from the tile indicators plugin.",
		section = tileIndicatorsSection,
		position = 150
	)
	default boolean recolorTileIndicators() {
		return false;
	}

	@ConfigItem(
		keyName = "recolorTileIndicatorFill",
		name = "Also recolor fill",
		description = "Recolor the fill color of tile indicators as well",
		section = tileIndicatorsSection,
		position = 151
	)
	default boolean recolorTileIndicatorFill() {
		return false;
	}

	@ConfigItem(
		keyName = "preferCornerTileIndicatorsConfig",
		name = "Prefer \"Corner tile indicators\"",
		description = "Prefers to use the config from my \"Corner tile indicators\" plugin, if it is installed, including true tile fadeout and corner-only highlight.",
		section = tileIndicatorsSection,
		position = 152
	)
	default boolean preferCornerTileIndicatorsConfig() {
		return false;
	}
}

/*
 * Copyright (c) 2019, Jordan Atwood <nightfirecat@protonmail.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.rainbowrave;

import java.awt.Color;
import javax.annotation.Nullable;
import lombok.Value;
import net.runelite.api.coords.WorldPoint;

/**
 * Used to denote marked tiles and their colors.
 * Note: This is not used for serialization of ground markers; see {@link net.runelite.client.plugins.groundmarkers.GroundMarkerPoint}
 */
@Value
class ColorTileMarker
{
	private WorldPoint worldPoint;
	@Nullable
	private Color color;
	@Nullable
	private String label;
}

/*
 * Copyright (c) 2022, Ryan Bell <llaver@live.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.rainbowrave;

import java.awt.*;
import java.util.ArrayList;
import java.util.List;

import net.runelite.api.Point;
import net.runelite.client.ui.overlay.Overlay;
import net.runelite.client.ui.overlay.OverlayLayer;
import net.runelite.client.ui.overlay.OverlayPosition;

class RainbowRaveMouseTrailOverlay extends Overlay
{
    private final RainbowRavePlugin rainbowRavePlugin;
    private final RainbowRaveMouseTrailPlugin plugin;
    private final RainbowRaveConfig rainbowRaveConfig;

    public RainbowRaveMouseTrailOverlay(RainbowRavePlugin rainbowRavePlugin, RainbowRaveMouseTrailPlugin plugin, RainbowRaveConfig rainbowRaveConfig)
    {
        this.plugin = plugin;
        this.rainbowRavePlugin = rainbowRavePlugin;
        this.rainbowRaveConfig = rainbowRaveConfig;
        setPosition(OverlayPosition.DYNAMIC);
        setPriority(Overlay.PRIORITY_HIGH);
        setLayer(OverlayLayer.ABOVE_WIDGETS);
    }

    // Function the get the rainbow color for a particular point based on the size of the trail
    private Color getRainbowColor(int trailSize, int position) {
        float currentPercent = (float) (position) / (trailSize);
        float hue = currentPercent * (trailSize);
        return rainbowRaveConfig.theme().getColor(hue / 100f);
    }

    // Helper method to handle choosing the correct coloring function
    private Color getColor(int size, int position) {
        if (rainbowRaveConfig.whichMouseTrailStyle() == RainbowRaveConfig.MouseTrailStyle.SYNCED) {
            return rainbowRavePlugin.getColor(0);
        }
        // Fall back to standard coloring
        return getRainbowColor(size, position);
    }

    @Override
    public Dimension render(Graphics2D graphics)
    {
        // Disable overlay if mouse trail style set to None
        if (rainbowRaveConfig.whichMouseTrailStyle() == RainbowRaveConfig.MouseTrailStyle.NONE) {
            return null;
        }
        // Set Partymode variables
        boolean isPartyMode = rainbowRaveConfig.whichMouseTrailStyle() == RainbowRaveConfig.MouseTrailStyle.PARTYMODE;
        // Get ArrayList of Curves
        List<Curve> trail = new ArrayList<>(plugin.getTrail());
        // Points to track where to render a line between Curves
        Point midBefore = null;
        Point midAfter = null;

        // Set trail size, stroke, and antialiasing
        graphics.setStroke(new BasicStroke(2, BasicStroke.CAP_BUTT, BasicStroke.JOIN_ROUND));
        graphics.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);
        // Fallback default color
        graphics.setColor(Color.BLUE);
        // Loop through Curves of trail
        for(int i = 0; i < trail.size(); i++) {
            // Get Points from Curve
            List<Point> points = trail.get(i).getCurve();
            // Loop through points
            for(int j = 0; j < points.size(); j++ ) {

                // Initialize points used to calculate parts of trail with null
                Point before = null;
                Point after = null;
                Point previous = null;
                Point current = null;
                // Logic for setting points depending on where in the loops we are
                if(i != 0 && j == 0) {
                    // Get previous list of points from the previous Curve
                    List<Point> previousPoints = trail.get(i - 1).getCurve();
                    before = previousPoints.get(previousPoints.size() - 2);
                    after = points.get(j + 1);
                    previous = previousPoints.get(previousPoints.size() - 1);
                    current = points.get(j);
                } else if(j > 1) {
                    // Set points from current Curve
                    before = points.get(j - 2);
                    previous = points.get(j - 1);
                    current = points.get(j);
                    // If the last point in the Curve, and not the last curve in the trail, get second point from next Curve
                    if(i < trail.size() - 1 && j == points.size() - 1) {
                        after = trail.get(i + 1).getCurve().get(1);
                    }
                }
                // Get second to last in previous Curve and third point in current Curve
                // Will be used to draw another line due to tiny gaps left in between Curves
                if(j == 4) {
                    if (midBefore == null) {
                        midBefore = points.get(j);
                    }
                } else if (j == 2 && midBefore != null) {
                        midAfter = points.get(j);
                }
                // Set position and size of trail
                // Multiply by five due to preset size of Curve
                // TODO hook curve size multiplier into config
                int position = i * 5 + j;
                int size = trail.size() * 5;
                // Get the rainbow color from helper method.
                // Dividing by 3 to throttle the speed of the rainbow color
                final Color color = getColor(isPartyMode ? size : size / 3, isPartyMode ? position : position / 3);
                graphics.setColor(color);

                // Draw lines of the trail
                // We are drawing three to fill in gaps and slight inconsistencies
                // Still a small bug when drawing large circles very quickly
                // Causes lines to occasionally overlap at the edges
                if(previous != null && current != null) {
                    graphics.drawLine(previous.getX(), previous.getY(), current.getX(), current.getY());
                }
                if(before != null && after != null) {
                    graphics.drawLine(before.getX(), before.getY(), after.getX(), after.getY());
                }
                if(midBefore != null && midAfter != null) {
                    graphics.drawLine(midBefore.getX(), midBefore.getY(), midAfter.getX(), midAfter.getY());
                    // Progress mid points
                    midBefore = midAfter;
                    midAfter = null;
                }
            }
        }
        return null;
    }
}
/*
 * Copyright (c) 2021, Trevor <https://github.com/Trevor159>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

package com.rainbowrave;

import java.awt.Color;
import java.util.function.Function;
import lombok.RequiredArgsConstructor;
import net.runelite.api.Animation;
import net.runelite.api.AnimationID;
import net.runelite.api.Client;
import net.runelite.api.JagexColor;
import net.runelite.api.Model;
import net.runelite.api.ModelData;
import net.runelite.api.RuneLiteObject;
import net.runelite.api.WorldView;
import net.runelite.api.coords.LocalPoint;
import net.runelite.api.coords.WorldPoint;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.plugins.grounditems.config.HighlightTier;

class Lootbeam
{
	final RuneLiteObject runeLiteObject;
	private final Client client;
	private final ClientThread clientThread;
	private Color color;
	private Lootbeam.Style style;
	final HighlightTier tier;

	@RequiredArgsConstructor
	public enum Style
	{
		LIGHT(l -> l.client.loadModel(
			5809,
			new short[]{6371},
			new short[]{JagexColor.rgbToHSL(l.color.getRGB(), 1.0d)}
		), anim(AnimationID.RAID_LIGHT_ANIMATION)),
		MODERN(l ->
		{
			ModelData md = l.client.loadModelData(43330);
			if (md == null)
			{
				return null;
			}

			short hsl = JagexColor.rgbToHSL(l.color.getRGB(), 1.0d);
			int hue = JagexColor.unpackHue(hsl);
			int sat = JagexColor.unpackSaturation(hsl);
			int lum = JagexColor.unpackLuminance(hsl);
			int satDelta = sat > 2 ? 1 : 0;

			return md.cloneColors()
				.recolor((short) 26432, JagexColor.packHSL(hue, sat - satDelta, lum))
				.recolor((short) 26584, JagexColor.packHSL(hue, sat, Math.min(lum + 24, JagexColor.LUMINANCE_MAX)))
				.light(75 + ModelData.DEFAULT_AMBIENT, 1875 + ModelData.DEFAULT_CONTRAST,
					ModelData.DEFAULT_X, ModelData.DEFAULT_Y, ModelData.DEFAULT_Z);
		}, anim(AnimationID.LOOTBEAM_ANIMATION)),
		;

		private final Function<Lootbeam, Model> modelSupplier;
		private final Function<Lootbeam, Animation> animationSupplier;
	}

	private static Function<Lootbeam, Animation> anim(int id)
	{
		return b -> b.client.loadAnimation(id);
	}

	public Lootbeam(Client client, ClientThread clientThread, WorldPoint worldPoint, Color color, String style, HighlightTier tier)
	{
		this.client = client;
		this.clientThread = clientThread;
		this.tier = tier;
		runeLiteObject = client.createRuneLiteObject();

		this.color = color;
		this.style = style.equals("MODERN") ? Style.MODERN : Style.LIGHT;
		update();
		runeLiteObject.setShouldLoop(true);

		WorldView worldView = client.getTopLevelWorldView();
		LocalPoint lp = LocalPoint.fromWorld(worldView, worldPoint);
		runeLiteObject.setLocation(lp, worldView.getPlane());

		runeLiteObject.setActive(true);
	}

	public void setColor(Color color)
	{
		if (this.color != null && this.color.equals(color))
		{
			return;
		}

		this.color = color;
		update();
	}

	public void setStyle(String styleString)
	{
		Style style = styleString.equals("MODERN") ? Style.MODERN : Style.LIGHT;
		if (this.style == style)
		{
			return;
		}

		this.style = style;
		update();
	}

	private void update()
	{
		clientThread.invoke(() ->
		{
			Model model = style.modelSupplier.apply(this);
			if (model == null)
			{
				return false;
			}

			Animation anim = style.animationSupplier.apply(this);

			runeLiteObject.setAnimation(anim);
			runeLiteObject.setModel(model);
			return true;
		});
	}

	public void remove()
	{
		runeLiteObject.setActive(false);
	}

}

/*
 * Copyright (c) 2018, Adam <Adam@sigterm.info>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.rainbowrave;

import com.google.inject.Provides;
import com.rainbowrave.RainbowRaveNpcIndicatorsPlugin.HighlightedNpc;
import java.awt.Color;
import java.util.Arrays;
import java.util.List;
import java.util.function.Function;
import javax.inject.Inject;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.GraphicsObject;
import net.runelite.api.Model;
import net.runelite.api.NPC;
import net.runelite.api.events.ClientTick;
import net.runelite.api.events.ItemSpawned;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.eventbus.EventBus;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.events.ConfigChanged;
import net.runelite.client.game.ItemManager;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.plugins.PluginDependency;
import net.runelite.client.plugins.PluginDescriptor;
import net.runelite.client.plugins.grounditems.GroundItemsConfig;
import net.runelite.client.plugins.grounditems.GroundItemsPlugin;
import net.runelite.client.plugins.groundmarkers.GroundMarkerConfig;
import net.runelite.client.plugins.groundmarkers.GroundMarkerPlugin;
import net.runelite.client.plugins.inventorytags.InventoryTagsConfig;
import net.runelite.client.plugins.inventorytags.InventoryTagsPlugin;
import net.runelite.client.plugins.npchighlight.NpcIndicatorsConfig;
import net.runelite.client.plugins.npchighlight.NpcIndicatorsPlugin;
import net.runelite.client.plugins.objectindicators.ObjectIndicatorsConfig;
import net.runelite.client.plugins.objectindicators.ObjectIndicatorsPlugin;
import net.runelite.client.ui.overlay.Overlay;
import net.runelite.client.ui.overlay.OverlayManager;
import net.runelite.client.ui.overlay.outline.ModelOutlineRenderer;

@Slf4j
@PluginDescriptor(
	name = "Rainbow Rave",
	tags = {"loot, beam, ground, item, tile, indicator, npc, object, inventory, tag"}
)
@PluginDependency(NpcIndicatorsPlugin.class)
@PluginDependency(GroundMarkerPlugin.class)
@PluginDependency(ObjectIndicatorsPlugin.class)
@PluginDependency(InventoryTagsPlugin.class)
@PluginDependency(GroundItemsPlugin.class)
public class RainbowRavePlugin extends Plugin
{
	public static final String GROUP = "rainbow_rave";

	@Inject
	private Client client;

	@Inject
	private RainbowRaveConfig config;

	@Inject
	private OverlayManager overlayManager;

	@Inject
	private ModelOutlineRenderer modelOutlineRenderer;

	@Inject
	private NpcIndicatorsConfig npcIndicatorsConfig;

	@Inject
	private RainbowRaveNpcIndicatorsPlugin rainbowRaveNpcIndicatorsPlugin;

	private RainbowRaveNpcSceneOverlay rainbowRaveNpcSceneOverlay;

	@Inject
	private GroundMarkerConfig groundMarkerConfig;

	@Inject
	private RainbowRaveGroundMarkerPlugin rainbowRaveGroundMarkerPlugin;

	private RainbowRaveGroundMarkerOverlay rainbowRaveGroundMarkerOverlay;

	@Inject
	private ObjectIndicatorsConfig objectIndicatorsConfig;

	@Inject
	private RainbowRaveObjectIndicatorsPlugin rainbowRaveObjectIndicatorsPlugin;

	private RainbowRaveObjectIndicatorsOverlay rainbowRaveObjectIndicatorsOverlay;

	private RainbowRaveInventoryTagsOverlay rainbowRaveInventoryTagsOverlay;

	@Inject
	private InventoryTagsConfig inventoryTagsConfig;

	@Inject
	private GroundItemsConfig groundItemsConfig;

	@Inject
	private RainbowRaveGroundItemsPlugin rainbowRaveGroundItemsPlugin;

	private RainbowRaveGroundItemsOverlay rainbowRaveGroundItemsOverlay;

	@Inject
	private RainbowRaveTileIndicatorsPlugin rainbowRaveTileIndicatorsPlugin;

	private RainbowRaveTileIndicatorsOverlay rainbowRaveTileIndicatorsOverlay;

	@Inject
	private RainbowRaveMouseTrailPlugin rainbowRaveMouseTrailPlugin;

	private RainbowRaveMouseTrailOverlay rainbowRaveMouseTrailOverlay;

	@Inject
	private EventBus eventBus;

	@Inject
	private ItemManager itemManager;

	@Inject
	private ConfigManager configManager;

	@Inject
	private ClientThread clientThread;

	@Override
	protected void startUp()
	{
		if (rainbowRaveGroundMarkerOverlay == null) {
			rainbowRaveGroundMarkerOverlay = new RainbowRaveGroundMarkerOverlay(client, groundMarkerConfig, rainbowRaveGroundMarkerPlugin, this, config);
		}
		rainbowRaveGroundMarkerPlugin.startUp();
		overlayManager.add(rainbowRaveGroundMarkerOverlay);
		eventBus.register(rainbowRaveGroundMarkerPlugin);

		if (rainbowRaveObjectIndicatorsOverlay == null) {
			rainbowRaveObjectIndicatorsOverlay = new RainbowRaveObjectIndicatorsOverlay(client, objectIndicatorsConfig, rainbowRaveObjectIndicatorsPlugin, modelOutlineRenderer, this, config);
		}
		rainbowRaveObjectIndicatorsPlugin.startUp();
		overlayManager.add(rainbowRaveObjectIndicatorsOverlay);
		eventBus.register(rainbowRaveObjectIndicatorsPlugin);

		if (rainbowRaveNpcSceneOverlay == null) {
			rainbowRaveNpcSceneOverlay = new RainbowRaveNpcSceneOverlay(client, npcIndicatorsConfig, rainbowRaveNpcIndicatorsPlugin, modelOutlineRenderer, this, config);
		}
		updateNpcHighlighterWithConfigSettings();
		rainbowRaveNpcIndicatorsPlugin.startUp();
		overlayManager.add(rainbowRaveNpcSceneOverlay);
		eventBus.register(rainbowRaveNpcIndicatorsPlugin);

		if (rainbowRaveInventoryTagsOverlay == null) {
			rainbowRaveInventoryTagsOverlay = new RainbowRaveInventoryTagsOverlay(itemManager, this, inventoryTagsConfig, config, configManager);
		}
		overlayManager.add(rainbowRaveInventoryTagsOverlay);

		if (rainbowRaveGroundItemsOverlay == null) {
			rainbowRaveGroundItemsOverlay = new RainbowRaveGroundItemsOverlay(client, rainbowRaveGroundItemsPlugin, groundItemsConfig);
		}
		overlayManager.add(rainbowRaveGroundItemsOverlay);
		rainbowRaveGroundItemsPlugin.startUp();
		eventBus.register(rainbowRaveGroundItemsPlugin);

		if (config.recolorTileIndicators()) {
			startRRTIPlugin();
		}

		if (rainbowRaveMouseTrailOverlay == null) {
			rainbowRaveMouseTrailOverlay = new RainbowRaveMouseTrailOverlay(this, rainbowRaveMouseTrailPlugin, config);
		}
		overlayManager.add(rainbowRaveMouseTrailOverlay);
		rainbowRaveMouseTrailPlugin.startUp();
		eventBus.register(rainbowRaveMouseTrailPlugin);

		migrateConfig();
	}

	private void migrateConfig()
	{
		String previousSmoothWaves = configManager.getConfiguration(GROUP, RainbowRaveConfig.OLD_TILE_COLOR_WAVES_KEY);
		if (previousSmoothWaves != null) {
			if (Boolean.valueOf(previousSmoothWaves)) {
				configManager.setConfiguration(GROUP, RainbowRaveConfig.GROUND_MARKER_COLOR_MODE_KEY, RainbowRaveConfig.GroundMarkerColorMode.WAVES);
			} // else it would be "random" which is default
			configManager.unsetConfiguration(GROUP, RainbowRaveConfig.OLD_TILE_COLOR_WAVES_KEY);
		}
	}

	// Ground items has to use this itemspawned subscriber because registering it in startup is not fast enough to get the itemspawned events that are fired when a plugin is started.
	@Subscribe
	public void onItemSpawned(ItemSpawned e) {
		rainbowRaveGroundItemsPlugin.onItemSpawned(e);
	}

	@Override
	protected void shutDown()
	{
		rainbowRaveGroundMarkerPlugin.shutDown();
		overlayManager.remove(rainbowRaveGroundMarkerOverlay);
		eventBus.unregister(rainbowRaveGroundMarkerPlugin);

		rainbowRaveObjectIndicatorsPlugin.shutDown();
		overlayManager.remove(rainbowRaveObjectIndicatorsOverlay);
		eventBus.unregister(rainbowRaveObjectIndicatorsPlugin);

		rainbowRaveNpcIndicatorsPlugin.shutDown();
		overlayManager.remove(rainbowRaveNpcSceneOverlay);
		eventBus.unregister(rainbowRaveNpcIndicatorsPlugin);

		overlayManager.remove(rainbowRaveInventoryTagsOverlay);

		overlayManager.remove(rainbowRaveGroundItemsOverlay);
		rainbowRaveGroundItemsPlugin.shutDown();
		eventBus.unregister(rainbowRaveGroundItemsPlugin);

		stopRRTIPlugin();

		overlayManager.remove(rainbowRaveMouseTrailOverlay);
		rainbowRaveMouseTrailPlugin.shutDown();
		eventBus.unregister(rainbowRaveMouseTrailPlugin);
	}

	@Provides
	RainbowRaveConfig provideConfig(ConfigManager configManager)
	{
		return configManager.getConfig(RainbowRaveConfig.class);
	}

	private Function<NPC, HighlightedNpc> highlighterPredicate;

	@Subscribe
	public void onConfigChanged(ConfigChanged configChanged) {
		if (configChanged.getGroup().equals("runelite"))
		{
			checkAndPushOverlayToFront(configChanged, "grounditemsplugin", rainbowRaveGroundItemsOverlay);
			checkAndPushOverlayToFront(configChanged, "groundmarkerplugin", rainbowRaveGroundMarkerOverlay);
			checkAndPushOverlayToFront(configChanged, "inventorytagsplugin", rainbowRaveInventoryTagsOverlay);
			checkAndPushOverlayToFront(configChanged, "npcindicatorsplugin", rainbowRaveNpcSceneOverlay);
			checkAndPushOverlayToFront(configChanged, "objectindicatorsplugin", rainbowRaveObjectIndicatorsOverlay);
			checkAndPushOverlayToFront(configChanged, "brushmarkerplugin", rainbowRaveGroundMarkerOverlay);
			if (config.recolorTileIndicators()) {
				checkAndPushOverlayToFront(configChanged, "tileindicatorsplugin", rainbowRaveTileIndicatorsOverlay);
				checkAndPushOverlayToFront(configChanged, "cornertileindicatorsplugin", rainbowRaveTileIndicatorsOverlay);
			}
		}
		else if (configChanged.getGroup().equals("rainbow_rave"))
		{
			if (configChanged.getKey().equals("whichNpcsToHighlight"))
			{
				updateNpcHighlighterWithConfigSettings();
			}
			else if (configChanged.getKey().equals("recolorTileIndicators"))
			{
				if (config.recolorTileIndicators())
				{
					startRRTIPlugin();
				}
				else
				{
					stopRRTIPlugin();
				}
			}
		}
	}

	private void stopRRTIPlugin()
	{
		overlayManager.remove(rainbowRaveTileIndicatorsOverlay);
		rainbowRaveTileIndicatorsPlugin.shutDown();
		eventBus.unregister(rainbowRaveTileIndicatorsPlugin);
	}

	private void startRRTIPlugin()
	{
		if (rainbowRaveTileIndicatorsOverlay == null)
		{
			rainbowRaveTileIndicatorsOverlay = new RainbowRaveTileIndicatorsOverlay(client, rainbowRaveTileIndicatorsPlugin, this);
		}
		overlayManager.add(rainbowRaveTileIndicatorsOverlay);
		rainbowRaveTileIndicatorsPlugin.startUp();
		eventBus.register(rainbowRaveTileIndicatorsPlugin);
	}

	private void checkAndPushOverlayToFront(ConfigChanged configChanged, String key, Overlay overlay)
	{
		if (configChanged.getKey().equals(key) && configChanged.getNewValue().equalsIgnoreCase("true")) {
			clientThread.invokeLater(() -> {
				overlayManager.remove(overlay);
				overlayManager.add(overlay);
			});
		}
	}

	private void updateNpcHighlighterWithConfigSettings()
	{
		Function<NPC, HighlightedNpc> f;
		if (config.whichNpcsToHighlight() == RainbowRaveConfig.NpcsToHighlight.ALL) {
			f = npc -> rainbowRaveNpcIndicatorsPlugin.highlightedNpc(npc);
			rainbowRaveNpcSceneOverlay.enable(true);
		} else if (config.whichNpcsToHighlight() == RainbowRaveConfig.NpcsToHighlight.SAME) {
			f = npc -> null;
			rainbowRaveNpcSceneOverlay.enable(true);
		} else if (config.whichNpcsToHighlight() == RainbowRaveConfig.NpcsToHighlight.NONE) {
			f = npc -> null;
			rainbowRaveNpcSceneOverlay.enable(false);
		} else {
			return;
		}
		if (highlighterPredicate != null) rainbowRaveNpcIndicatorsPlugin.unregisterHighlighter(highlighterPredicate);
		highlighterPredicate = f;
		rainbowRaveNpcIndicatorsPlugin.registerHighlighter(highlighterPredicate);
		clientThread.invoke(rainbowRaveNpcIndicatorsPlugin::rebuild);
	}

	public Color getColor(int hashCode)
	{
		return getColor(hashCode, client.getGameCycle(), config.syncColor(), config.colorSpeed());
	}

	public Color getColor(int hashCode, int gameCycle, boolean syncColor, int colorSpeed)
	{
		if (syncColor) hashCode = 0;
		int clientTicks = colorSpeed / 20;
		return config.theme().getColor(((hashCode + gameCycle) % clientTicks) / ((float) clientTicks));
	}

	private static final List<Integer> scytheTrailIds = Arrays.asList(478, 506, 1172);

	@Subscribe
	public void onClientTick(ClientTick clientTick)
	{
		if(config.dukeRave())
		{
			for (NPC npc : client.getTopLevelWorldView().npcs())
			{
				if(npc.getId()>=12199 && npc.getId() <= 12201)
				{
					recolorAllFaces(npc.getModel(), getColor((int)npc.getHash()));
				}
			}
		}

		if (config.recolorLootBeams())
	{
		boolean colorHighlightedItems = config.colorHighlightedGroundItems();
			int tierOrdinal = config.whichGroundItemsToColor().highlightTierRelativeOrdinal;
			for (Lootbeam value : rainbowRaveGroundItemsPlugin.lootbeams.values())
			{
				if (
					value.tier == null ?
						colorHighlightedItems :
						value.tier.ordinal() >= tierOrdinal
				)
				{
					recolorAllFaces(value.runeLiteObject.getModel(), getColor(value.runeLiteObject.getLocation().hashCode()));
				}
			}
		}
		if (config.recolorScytheSwings())
		{
			for (GraphicsObject graphicsObject : client.getTopLevelWorldView().getGraphicsObjects())
			{
				if (
					scytheTrailIds.contains(graphicsObject.getId()) ||
					(graphicsObject.getId() >= 1231 && graphicsObject.getId() <= 1235) || // chally trails + 1 red trail.
					(graphicsObject.getId() >= 1891 && graphicsObject.getId() <= 1898) // sara and sang scythe swing trails
				)
				{
					recolorAllFaces(graphicsObject.getModel(), getColor(graphicsObject.getLocation().hashCode()));
				}
			}
		}
	}

	private int colorToRs2hsb(Color color)
	{
		float[] hsbVals = Color.RGBtoHSB(color.getRed(), color.getGreen(), color.getBlue(), null);

		// "Correct" the brightness level to avoid going to white at full saturation, or having a low brightness at
		// low saturation
		hsbVals[2] -= Math.min(hsbVals[1], hsbVals[2] / 2);

		int encode_hue = (int)(hsbVals[0] * 63);
		int encode_saturation = (int)(hsbVals[1] * 7);
		int encode_brightness = (int)(hsbVals[2] * 127);
		return (encode_hue << 10) + (encode_saturation << 7) + (encode_brightness);
	}

	private void recolorAllFaces(Model model, Color color)
	{
		if (model == null || color == null)
		{
			return;
		}

		int rs2hsb = colorToRs2hsb(color);
		int[] faceColors1 = model.getFaceColors1();
		int[] faceColors2 = model.getFaceColors2();
		int[] faceColors3 = model.getFaceColors3();

		for (int i = 0; i < faceColors1.length; i++)
		{
			faceColors1[i] = rs2hsb;
		}
		for (int i = 0; i < faceColors2.length; i++)
		{
			faceColors2[i] = rs2hsb;
		}
		for (int i = 0; i < faceColors3.length; i++)
		{
			faceColors3[i] = rs2hsb;
		}
	}
}

/*
 * Copyright (c) 2017, Aria <aria@ar1as.space>
 * Copyright (c) 2018, Adam <Adam@sigterm.info>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.rainbowrave;

import java.awt.Color;
import java.awt.Dimension;
import java.awt.FontMetrics;
import java.awt.Graphics2D;
import java.awt.Polygon;
import java.awt.Rectangle;
import java.time.Instant;
import java.util.AbstractMap.SimpleEntry;
import java.util.ArrayList;
import java.util.Collection;
import java.util.HashMap;
import java.util.Map;
import java.util.Optional;
import javax.inject.Inject;
import net.runelite.api.*;
import net.runelite.api.coords.LocalPoint;
import net.runelite.api.coords.WorldPoint;
import net.runelite.client.plugins.grounditems.GroundItemsConfig;
import net.runelite.client.plugins.grounditems.config.DespawnTimerMode;
import static net.runelite.client.plugins.grounditems.config.ItemHighlightMode.MENU;
import static net.runelite.client.plugins.grounditems.config.ItemHighlightMode.NONE;
import net.runelite.client.plugins.grounditems.config.OwnershipFilterMode;
import net.runelite.client.plugins.grounditems.config.PriceDisplayMode;
import net.runelite.client.ui.overlay.Overlay;
import net.runelite.client.ui.overlay.OverlayLayer;
import net.runelite.client.ui.overlay.OverlayPosition;
import net.runelite.client.ui.overlay.OverlayUtil;
import net.runelite.client.ui.overlay.components.BackgroundComponent;
import net.runelite.client.ui.overlay.components.ProgressPieComponent;
import net.runelite.client.ui.overlay.components.TextComponent;
import net.runelite.client.util.QuantityFormatter;

public class RainbowRaveGroundItemsOverlay extends Overlay
{
	private static final int MAX_DISTANCE = 2500;
	// We must offset the text on the z-axis such that
	// it doesn't obscure the ground items below it.
	private static final int OFFSET_Z = 20;
	// The 15 pixel gap between each drawn ground item.
	private static final int STRING_GAP = 15;
	// Size of the hidden/highlight boxes
	private static final int RECTANGLE_SIZE = 8;
	private static final Color PUBLIC_TIMER_COLOR = Color.YELLOW;
	private static final Color PRIVATE_TIMER_COLOR = Color.GREEN;
	private static final int TIMER_OVERLAY_DIAMETER = 10;

	private final Client client;
	private final RainbowRaveGroundItemsPlugin plugin;
	private final GroundItemsConfig config;
	private final StringBuilder itemStringBuilder = new StringBuilder();
	private final BackgroundComponent backgroundComponent = new BackgroundComponent();
	private final TextComponent textComponent = new TextComponent();
	private final ProgressPieComponent progressPieComponent = new ProgressPieComponent();
	private final Map<WorldPoint, Integer> offsetMap = new HashMap<>();

	@Inject
	public RainbowRaveGroundItemsOverlay(Client client, RainbowRaveGroundItemsPlugin plugin, GroundItemsConfig config)
	{
		setPosition(OverlayPosition.DYNAMIC);
		setLayer(OverlayLayer.ABOVE_SCENE);
		this.client = client;
		this.plugin = plugin;
		this.config = config;
	}

	@Override
	public Dimension render(Graphics2D graphics)
	{
		final boolean dontShowOverlay = (config.itemHighlightMode() == MENU || config.itemHighlightMode() == NONE
			|| plugin.isHideAll()) && !plugin.isHotKeyPressed();

		if (dontShowOverlay && !config.highlightTiles())
		{
			return null;
		}

		final FontMetrics fm = graphics.getFontMetrics();
		final Player player = client.getLocalPlayer();

		if (player == null)
		{
			return null;
		}

		offsetMap.clear();
		final LocalPoint localLocation = player.getLocalLocation();
		final Point mousePos = client.getMouseCanvasPosition();
		Collection<GroundItem> groundItemList = plugin.getCollectedGroundItems().values();
		GroundItem topGroundItem = null;

		if (plugin.isHotKeyPressed())
		{
			// Make copy of ground items because we are going to modify them here, and the array list supports our
			// desired behaviour here
			groundItemList = new ArrayList<>(groundItemList);
			final java.awt.Point awtMousePos = new java.awt.Point(mousePos.getX(), mousePos.getY());
			GroundItem groundItem = null;

			for (GroundItem item : groundItemList)
			{
				item.setOffset(offsetMap.compute(item.getLocation(), (k, v) -> v != null ? v + 1 : 0));

				if (groundItem != null)
				{
					continue;
				}

				if (plugin.getTextBoxBounds() != null
					&& item.equals(plugin.getTextBoxBounds().getValue())
					&& plugin.getTextBoxBounds().getKey().contains(awtMousePos))
				{
					groundItem = item;
					continue;
				}

				if (plugin.getHiddenBoxBounds() != null
					&& item.equals(plugin.getHiddenBoxBounds().getValue())
					&& plugin.getHiddenBoxBounds().getKey().contains(awtMousePos))
				{
					groundItem = item;
					continue;
				}

				if (plugin.getHighlightBoxBounds() != null
					&& item.equals(plugin.getHighlightBoxBounds().getValue())
					&& plugin.getHighlightBoxBounds().getKey().contains(awtMousePos))
				{
					groundItem = item;
				}
			}

			if (groundItem != null)
			{
				groundItemList.remove(groundItem);
				groundItemList.add(groundItem);
				topGroundItem = groundItem;
			}
		}

		plugin.setTextBoxBounds(null);
		plugin.setHiddenBoxBounds(null);
		plugin.setHighlightBoxBounds(null);

		final DespawnTimerMode groundItemTimers = config.groundItemTimers();
		final boolean outline = config.textOutline();
		final OwnershipFilterMode ownershipFilterMode = config.ownershipFilterMode();
		final int accountType = client.getVarbitValue(Varbits.ACCOUNT_TYPE);
		final WorldView worldView = client.getTopLevelWorldView();

		for (GroundItem item : groundItemList)
		{
			final LocalPoint groundPoint = LocalPoint.fromWorld(worldView, item.getLocation());

			if (groundPoint == null || localLocation.distanceTo(groundPoint) > MAX_DISTANCE
				|| !plugin.shouldDisplayItem(ownershipFilterMode, item.getOwnership(), accountType))
			{
				continue;
			}

			final Optional<Color> highlighted = plugin.getHighlighted(new NamedQuantity(item), item.getGePrice(), item.getHaPrice());
			final Optional<Color> hidden = plugin.getHidden(new NamedQuantity(item), item.getGePrice(), item.getHaPrice(), item.isTradeable());
			if (highlighted == null && !plugin.isHotKeyPressed())
			{
				// Do not display hidden items
				if (hidden != null)
				{
					continue;
				}

				// Do not display non-highlighted items
				if (config.showHighlightedOnly())
				{
					continue;
				}
			}

			final Optional<Color> groundItemColor = plugin.getItemColor(highlighted, hidden, new NamedQuantity(item));

			if (groundItemColor == null) continue;
			if (!groundItemColor.isPresent()) {
				if (!plugin.isHotKeyPressed()) offsetMap.compute(item.getLocation(), (k, v) -> v != null ? v + 1 : 0);

				continue;
			}
			Color color = groundItemColor.get();

			if (config.highlightTiles())
			{
				final Polygon poly = Perspective.getCanvasTilePoly(client, groundPoint, item.getHeight());

				if (poly != null)
				{
					OverlayUtil.renderPolygon(graphics, poly, color);
				}
			}

			if (dontShowOverlay)
			{
				continue;
			}

			itemStringBuilder.append(item.getName());

			if (item.getQuantity() > 1)
			{
				itemStringBuilder.append(" (")
					.append(QuantityFormatter.quantityToStackSize(item.getQuantity()))
					.append(')');
			}

			if (item.getId() != ItemID.COINS_995)
			{
				PriceDisplayMode displayMode = config.priceDisplayMode();
				if (displayMode == PriceDisplayMode.BOTH)
				{
					if (item.getGePrice() > 0)
					{
						itemStringBuilder.append(" (GE: ")
							.append(QuantityFormatter.quantityToStackSize(item.getGePrice()))
							.append(" gp)");
					}

					if (item.getHaPrice() > 0)
					{
						itemStringBuilder.append(" (HA: ")
							.append(QuantityFormatter.quantityToStackSize(item.getHaPrice()))
							.append(" gp)");
					}
				}
				else if (displayMode != PriceDisplayMode.OFF)
				{
					final int price = displayMode == PriceDisplayMode.GE
						? item.getGePrice()
						: item.getHaPrice();

					if (price > 0)
					{
						itemStringBuilder
							.append(" (")
							.append(QuantityFormatter.quantityToStackSize(price))
							.append(" gp)");
					}
				}
			}

			final String itemString = itemStringBuilder.toString();
			itemStringBuilder.setLength(0);

			final Point textPoint = Perspective.getCanvasTextLocation(client,
				graphics,
				groundPoint,
				itemString,
				item.getHeight() + OFFSET_Z);

			if (textPoint == null)
			{
				continue;
			}

			final int offset = plugin.isHotKeyPressed()
				? item.getOffset()
				: offsetMap.compute(item.getLocation(), (k, v) -> v != null ? v + 1 : 0);

			final int textX = textPoint.getX();
			final int textY = textPoint.getY() - (STRING_GAP * offset);

			if (plugin.isHotKeyPressed())
			{
				final int stringWidth = fm.stringWidth(itemString);
				final int stringHeight = fm.getHeight();

				// Item bounds
				int x = textX - 2;
				int y = textY - stringHeight - 2;
				int width = stringWidth + 4;
				int height = stringHeight + 4;
				final Rectangle itemBounds = new Rectangle(x, y, width, height);

				// Hidden box
				x += width + 2;
				y = textY - (RECTANGLE_SIZE + stringHeight) / 2;
				width = height = RECTANGLE_SIZE;
				final Rectangle itemHiddenBox = new Rectangle(x, y, width, height);

				// Highlight box
				x += width + 2;
				final Rectangle itemHighlightBox = new Rectangle(x, y, width, height);

				boolean mouseInBox = itemBounds.contains(mousePos.getX(), mousePos.getY());
				boolean mouseInHiddenBox = itemHiddenBox.contains(mousePos.getX(), mousePos.getY());
				boolean mouseInHighlightBox = itemHighlightBox.contains(mousePos.getX(), mousePos.getY());

				if (mouseInBox)
				{
					plugin.setTextBoxBounds(new SimpleEntry<>(itemBounds, item));
				}
				else if (mouseInHiddenBox)
				{
					plugin.setHiddenBoxBounds(new SimpleEntry<>(itemHiddenBox, item));

				}
				else if (mouseInHighlightBox)
				{
					plugin.setHighlightBoxBounds(new SimpleEntry<>(itemHighlightBox, item));
				}

				boolean topItem = topGroundItem == item;

				// Draw background if hovering
				if (topItem && (mouseInBox || mouseInHiddenBox || mouseInHighlightBox))
				{
					backgroundComponent.setRectangle(itemBounds);
//					backgroundComponent.render(graphics);
				}

				// Draw hidden box
//				drawRectangle(graphics, itemHiddenBox, topItem && mouseInHiddenBox ? Color.RED : color, hidden != null, true);

				// Draw highlight box
//				drawRectangle(graphics, itemHighlightBox, topItem && mouseInHighlightBox ? Color.GREEN : color, highlighted != null, false);
			}

			// When the hotkey is pressed the hidden/highlight boxes are drawn to the right of the text,
			// so always draw the pie since it is on the left hand side.
			if (groundItemTimers == DespawnTimerMode.PIE || plugin.isHotKeyPressed())
			{
				drawTimerPieOverlay(graphics, textX, textY, item, color);
			}
			else if (groundItemTimers == DespawnTimerMode.SECONDS || groundItemTimers == DespawnTimerMode.TICKS)
			{
				Instant despawnTime = calculateDespawnTime(item);
				Color timerColor = color;
				if (despawnTime != null && timerColor != null)
				{
					long despawnTimeMillis = despawnTime.toEpochMilli() - Instant.now().toEpochMilli();
					final String timerText;
					if (groundItemTimers == DespawnTimerMode.SECONDS)
					{
						timerText = String.format(" - %.1f", despawnTimeMillis / 1000f);
					}
					else // TICKS
					{
						timerText = String.format(" - %d", despawnTimeMillis / 600);
					}

					// The timer text is drawn separately to have its own color, and is intentionally not included
					// in the getCanvasTextLocation() call because the timer text can change per frame and we do not
					// use a monospaced font, which causes the text location on screen to jump around slightly each frame.
					textComponent.setText(timerText);
					textComponent.setColor(timerColor);
					textComponent.setOutline(outline);
					textComponent.setPosition(new java.awt.Point(textX + fm.stringWidth(itemString), textY));
					textComponent.render(graphics);
				}
			}

			textComponent.setText(itemString);
			textComponent.setColor(color);
			textComponent.setOutline(outline);
			textComponent.setPosition(new java.awt.Point(textX, textY));
			textComponent.render(graphics);
		}

		return null;
	}

	private Instant calculateDespawnTime(GroundItem groundItem)
	{
		Instant spawnTime = groundItem.getSpawnTime();
		if (spawnTime == null)
		{
			return null;
		}

		Instant despawnTime = spawnTime.plus(groundItem.getDespawnTime());
		if (Instant.now().isAfter(despawnTime))
		{
			// that's weird
			return null;
		}

		return despawnTime;
	}

	private Color getItemTimerColor(GroundItem groundItem)
	{
		final Instant spawnTime = groundItem.getSpawnTime();
		if (spawnTime == null)
		{
			return null;
		}

		final Instant now = Instant.now();
		final Instant despawnTime = spawnTime.plus(groundItem.getDespawnTime());

		if (groundItem.isPrivate())
		{
			if (despawnTime.isAfter(now))
			{
				return PRIVATE_TIMER_COLOR;
			}

			return null;
		}

		// otherwise it is private until visibleTime, then it is public
		final Instant visibleTime = spawnTime.plus(groundItem.getVisibleTime());
		if (visibleTime.isAfter(now))
		{
			return PRIVATE_TIMER_COLOR;
		}
		if (despawnTime.isAfter(now))
		{
			return PUBLIC_TIMER_COLOR;
		}

		return null;
	}

	private void drawTimerPieOverlay(Graphics2D graphics, int textX, int textY, GroundItem groundItem, Color color)
	{
		Instant now = Instant.now();
		Instant spawnTime = groundItem.getSpawnTime();
		Instant despawnTime = calculateDespawnTime(groundItem);
		Color fillColor = color;

		if (spawnTime == null || despawnTime == null || fillColor == null)
		{
			return;
		}

		float percent = (float) (now.toEpochMilli() - spawnTime.toEpochMilli()) / (despawnTime.toEpochMilli() - spawnTime.toEpochMilli());

		progressPieComponent.setDiameter(TIMER_OVERLAY_DIAMETER);
		// Shift over to not be on top of the text
		int x = textX - TIMER_OVERLAY_DIAMETER;
		int y = textY - TIMER_OVERLAY_DIAMETER / 2;
		progressPieComponent.setPosition(new Point(x, y));
		progressPieComponent.setFill(fillColor);
		progressPieComponent.setBorderColor(fillColor);
		progressPieComponent.setProgress(1 - percent); // inverse so pie drains over time
		progressPieComponent.render(graphics);
	}

	private void drawRectangle(Graphics2D graphics, Rectangle rect, Color color, boolean inList, boolean hiddenBox)
	{
		graphics.setColor(Color.BLACK);
		graphics.drawRect(rect.x + 1, rect.y + 1, rect.width, rect.height);

		graphics.setColor(color);
		graphics.draw(rect);

		if (inList)
		{
			graphics.fill(rect);
		}

		graphics.setColor(Color.WHITE);
		// Minus symbol
		graphics.drawLine
			(
				rect.x + 2,
				rect.y + (rect.height / 2),
				rect.x + rect.width - 2,
				rect.y + (rect.height / 2)
			);

		if (!hiddenBox)
		{
			// Plus symbol
			graphics.drawLine
				(
					rect.x + (rect.width / 2),
					rect.y + 2,
					rect.x + (rect.width / 2),
					rect.y + rect.height - 2
				);
		}

	}
}

/*
 * Copyright (c) 2018, Tomas Slusny <slusnucky@gmail.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.rainbowrave;

import java.awt.BasicStroke;
import java.awt.Color;
import java.awt.Dimension;
import java.awt.Graphics2D;
import java.awt.Polygon;
import java.awt.Stroke;
import net.runelite.api.Client;
import net.runelite.api.Constants;
import net.runelite.api.Perspective;
import net.runelite.api.WorldView;
import net.runelite.api.coords.LocalPoint;
import net.runelite.client.ui.overlay.Overlay;
import net.runelite.client.ui.overlay.OverlayLayer;
import net.runelite.client.ui.overlay.OverlayPosition;
import net.runelite.client.ui.overlay.OverlayUtil;
import net.runelite.client.util.ColorUtil;

public class RainbowRaveTileIndicatorsOverlay extends Overlay
{
	private final Client client;
	private final RainbowRaveTileIndicatorsPlugin plugin;
	private final RainbowRavePlugin rainbowRavePlugin;

	public RainbowRaveTileIndicatorsOverlay(Client client, RainbowRaveTileIndicatorsPlugin plugin, RainbowRavePlugin rainbowRavePlugin)
	{
		this.client = client;
		this.plugin = plugin;
		this.rainbowRavePlugin = rainbowRavePlugin;
		setPosition(OverlayPosition.DYNAMIC);
		setLayer(OverlayLayer.ABOVE_SCENE);
		setPriority(Overlay.PRIORITY_MED);
	}

	@Override
	public Dimension render(Graphics2D graphics)
	{
		WorldView wv = client.getTopLevelWorldView();
		if (plugin.highlightHoveredTile)
		{
			// If we have tile "selected" render it
			if (wv.getSelectedSceneTile() != null)
			{
				renderTile(graphics, wv.getSelectedSceneTile().getLocalLocation(), rainbowRavePlugin.getColor(0), plugin.hoveredTileBorderWidth, plugin.hoveredTileFillColor, plugin.hoveredTileCornersOnly, plugin.hoveredTileCornerSize);
			}
		}

		if (plugin.highlightDestinationTile)
		{
			renderTile(graphics, client.getLocalDestinationLocation(), rainbowRavePlugin.getColor(0), plugin.destinationTileBorderWidth, plugin.destinationTileFillColor, plugin.destinationTileCornersOnly, plugin.destinationTileCornerSize);
		}

		if (plugin.highlightCurrentTile)
		{
			final LocalPoint playerPosLocal = LocalPoint.fromWorld(wv, plugin.getLastPlayerPosition());
			if (playerPosLocal == null)
			{
				return null;
			}

			Color rainbowColor = rainbowRavePlugin.getColor(0);
			Color color = ColorUtil.colorWithAlpha(rainbowColor, plugin.highlightCurrentColor.getAlpha());
			Color fillColor = plugin.recolorFill ? ColorUtil.colorWithAlpha(rainbowColor, plugin.currentTileFillColor.getAlpha()) : plugin.currentTileFillColor;
			// When not fading out the current tile, or when it has been 1 game tick or less since the player last
			// moved, draw the tile at full opacity. When using fadeout, drawing the indicator at full opacity for 1
			// game tick prevents it from fading out when moving on consecutive ticks.
			if (!plugin.trueTileFadeout || client.getTickCount() - plugin.getLastTickPlayerMoved() <= 1)
			{
				renderTile(graphics, playerPosLocal, color, plugin.currentTileBorderWidth, fillColor, plugin.currentTileCornersOnly, plugin.currentTileCornerSize);
			}
			else
			{
				// It is 1 game tick after the player has stopped moving, so fade out the tile.
				long timeSinceLastMove = System.currentTimeMillis() - plugin.getLastTimePlayerStoppedMoving();
				// The fadeout does not begin for 1 game tick, so subtract that.
				int fadeoutTime = plugin.trueTileFadeoutTime - Constants.GAME_TICK_LENGTH;
				if (fadeoutTime != 0 && timeSinceLastMove < fadeoutTime)
				{
					double opacity = 1.0d - Math.pow(timeSinceLastMove / (double) fadeoutTime, 2);
					renderTile(graphics, playerPosLocal, ColorUtil.colorWithAlpha(color, (int) (opacity * color.getAlpha())), plugin.currentTileBorderWidth, ColorUtil.colorWithAlpha(fillColor, (int) (opacity * fillColor.getAlpha())), plugin.currentTileCornersOnly, plugin.currentTileCornerSize);
				}
			}
		}

		return null;
	}

	private void renderTile(final Graphics2D graphics, final LocalPoint dest, final Color color, final double borderWidth, final Color fillColor, boolean cornersOnly, int divisor)
	{
		if (dest == null)
		{
			return;
		}

		final Polygon poly = Perspective.getCanvasTilePoly(client, dest);

		if (poly == null)
		{
			return;
		}

		if (cornersOnly)
		{
			renderPolygonCorners(graphics, poly, color, fillColor, new BasicStroke((float) borderWidth), divisor);
		}
		else
		{
			OverlayUtil.renderPolygon(graphics, poly, color, fillColor, new BasicStroke((float) borderWidth));
		}
	}

	public static void renderPolygonCorners(Graphics2D graphics, Polygon poly, Color color, Color fillColor, Stroke borderStroke, int divisor)
	{
		graphics.setColor(color);
		final Stroke originalStroke = graphics.getStroke();
		graphics.setStroke(borderStroke);

		for (int i = 0; i < poly.npoints; i++)
		{
			int ptx = poly.xpoints[i];
			int pty = poly.ypoints[i];
			int prev = (i - 1) < 0 ? (poly.npoints - 1) : (i - 1);
			int next = (i + 1) > (poly.npoints - 1) ? 0 : (i + 1);
			int ptxN = ((poly.xpoints[next]) - ptx) / divisor + ptx;
			int ptyN = ((poly.ypoints[next]) - pty) / divisor + pty;
			int ptxP = ((poly.xpoints[prev]) - ptx) / divisor + ptx;
			int ptyP = ((poly.ypoints[prev]) - pty) / divisor + pty;
			graphics.drawLine(ptx, pty, ptxN, ptyN);
			graphics.drawLine(ptx, pty, ptxP, ptyP);
		}

		graphics.setColor(fillColor);
		graphics.fill(poly);

		graphics.setStroke(originalStroke);
	}
}

package com.rainbowrave;

import java.awt.Color;
import java.util.ArrayList;
import java.util.List;


public enum Theme
{
    RAINBOW,
    TRANS(new Color(91, 206, 250),
            new Color(245, 169, 184),
            new Color(255, 255, 255),
            new Color(245, 169, 184)
    ),
	ENBY(
		new Color(255, 255, 255),
		new Color(156, 89, 209),
		new Color(44, 44, 44),
		new Color(252, 244, 52)
	),
	LESBIAN(
		new Color(212, 44, 0),
		new Color(253, 152, 85),
		new Color(255, 255, 255),
		new Color(209, 97, 162),
		new Color(162, 1, 97)
	),
	PAN(
		new Color(255, 33, 140),
		new Color(255, 216, 0),
		new Color(255, 33, 140),
		new Color(33, 177, 255)
	),
	ACE(
		new Color(0, 0, 0),
		new Color(163, 163, 163),
		new Color(255, 255, 255),
		new Color(128, 0, 128)
	),
	BI(
		new Color(214, 2, 112),
		new Color(0, 56, 168),
		new Color(155, 79, 150)
	),
	GENDER_QUEER(
		new Color(181, 126, 220),
		new Color(255, 255, 255),
		new Color(74, 129, 35)
	),
	GAY(
		new Color(255, 255, 255),
		new Color(123, 173, 226),
		new Color(80, 73, 204),
		new Color(61, 26, 120),
		new Color(7, 141, 112),
		new Color(38, 206, 170),
		new Color(152, 232, 193)
	);

	private final List<PerceptualGradient> gradients;

	Theme()
	{
		gradients = new ArrayList<>();
	}

	Theme(Color... colors) {
		gradients = new ArrayList<>();
		for (int i=0; i<colors.length; i++) {
			Color startColor = colors[i];
			// When at the last index then wrap back to first color
			Color endColor = i == colors.length-1 ? colors[0] : colors[i+1];
            gradients.add(new PerceptualGradient(startColor, endColor));
        }
    }

    public Color getColor(float ratio)
    {
        // Subtract floor to match Color.getHSBColor() functionality
        ratio = Math.abs((float) (ratio - Math.floor(ratio)));

        if (gradients.size() == 0) { // This applies to the RAINBOW theme only.
            return Color.getHSBColor(ratio, 1.0f, 1.0f);
        }

        float increment = 1.0f/gradients.size(); // Since size isn't 0, increment is always (0-1]
        PerceptualGradient gradient = gradients.get((int) Math.floor(ratio/increment));
        float relativeRatio = (ratio%increment)/increment;
        return gradient.getColorMix(relativeRatio);
    }
}

/*
 * Copyright (c) 2018 kulers
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.rainbowrave;

import java.awt.Color;
import java.awt.Graphics2D;
import java.awt.Image;
import java.awt.Rectangle;
import java.awt.image.BufferedImage;
import net.runelite.api.widgets.WidgetItem;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.game.ItemManager;
import net.runelite.client.plugins.inventorytags.InventoryTagsConfig;
import net.runelite.client.ui.overlay.WidgetItemOverlay;
import net.runelite.client.util.ColorUtil;
import net.runelite.client.util.ImageUtil;

public class RainbowRaveInventoryTagsOverlay extends WidgetItemOverlay
{
	private final ItemManager itemManager;
	private final RainbowRavePlugin rainbowRavePlugin;
	private final InventoryTagsConfig config;
	private final RainbowRaveConfig rainbowRaveConfig;

	private ConfigManager configManager;

	public RainbowRaveInventoryTagsOverlay(ItemManager itemManager, RainbowRavePlugin rainbowRavePlugin, InventoryTagsConfig config, RainbowRaveConfig rainbowRaveConfig, ConfigManager configManager)
	{
		this.itemManager = itemManager;
		this.rainbowRavePlugin = rainbowRavePlugin;
		this.config = config;
		this.rainbowRaveConfig = rainbowRaveConfig;
		this.configManager = configManager;
		showOnEquipment();
		showOnInventory();
		showOnBank();
	}

	@Override
	public void renderItemOverlay(Graphics2D graphics, int itemId, WidgetItem widgetItem)
	{
		if (rainbowRaveConfig.whichItemsToInventoryTag() == RainbowRaveConfig.ItemsToTag.NONE) return;
		String tag = configManager.getConfiguration(InventoryTagsConfig.GROUP, "item_" + itemId);
		if ((tag != null && !tag.isEmpty()) || rainbowRaveConfig.whichItemsToInventoryTag() == RainbowRaveConfig.ItemsToTag.ALL)
		{
			final Color color = rainbowRavePlugin.getColor(itemId);
			if (color != null)
			{
				Rectangle bounds = widgetItem.getCanvasBounds();
				if (config.showTagOutline())
				{
					final BufferedImage outline = itemManager.getItemOutline(itemId, widgetItem.getQuantity(), color);
					graphics.drawImage(outline, (int) bounds.getX(), (int) bounds.getY(), null);
				}

				if (config.showTagFill())
				{
					final Image image = getFillImage(color, widgetItem.getId(), widgetItem.getQuantity());
					graphics.drawImage(image, (int) bounds.getX(), (int) bounds.getY(), null);
				}

				if (config.showTagUnderline())
				{
					int heightOffSet = (int) bounds.getY() + (int) bounds.getHeight() + 2;
					graphics.setColor(color);
					graphics.drawLine((int) bounds.getX(), heightOffSet, (int) bounds.getX() + (int) bounds.getWidth(), heightOffSet);
				}
			}
		}
	}

	private Image getFillImage(Color color, int itemId, int qty)
	{
		final Color fillColor = ColorUtil.colorWithAlpha(color, config.fillOpacity());
		return ImageUtil.fillImage(itemManager.getImage(itemId, qty, false), fillColor);
	}
}

package com.rainbowrave;

import java.awt.Color;

/*
The explanation of the gradient algorithm used can be found here.
https://stackoverflow.com/questions/22607043/color-gradient-algorithm/49321304#49321304
 */
public class PerceptualGradient
{
    private static final double GAMMA = .43;

    private final float[] normalizedStartColor;
    private final float[] normalizedEndColor;

    private final float startColorBrightness;
    private final float endColorBrightness;


    PerceptualGradient(Color startColor, Color endColor) {
        this.normalizedStartColor = normalize(startColor);
        this.normalizedEndColor = normalize(endColor);
        this.startColorBrightness = (float) Math.pow(sum(this.normalizedStartColor), GAMMA);
        this.endColorBrightness = (float) Math.pow(sum(this.normalizedEndColor), GAMMA);
    }

    public Color getColorMix(float frac) {
        float intensity = (float) Math.pow(lerp(this.startColorBrightness, this.endColorBrightness, frac), (1/GAMMA));

        float total = 0;
        float[] components = new float[3];
        for (int i=0; i<components.length; i++) {
            components[i] = lerp(this.normalizedStartColor[i], this.normalizedEndColor[i], frac);
            total += components[i];
        }
        if (total != 0) {
            for (int i=0; i<components.length; i++) {
                components[i] = components[i] * intensity / total;
            }
        }

        for (int i=0; i<components.length; i++) {
            float x = components[i];
            if (x <= 0.0031308) {
                components[i] = (float) (12.92*x);
            } else {
                components[i] = (float) ((1.055 * Math.pow(x , (1/2.4))) - 0.055);
            }
        }

        return new Color(components[0], components[1], components[2]);
    }

    public float sum(float[] array) {
        float sum = 0;
        for (float v : array)
        {
            sum += v;
        }
        return sum;
    }

    private float[] normalize(Color color) {
        float[] components = {color.getRed(), color.getGreen(), color.getBlue()};

        for (int i=0; i < components.length; i++) {
            double y;
            float x = components[i];

            x /= 255.0;
            if (x <= 0.04045) {
                y = x / 12.92;
            }
            else {
                y = Math.pow(((x + 0.055) / 1.055), 2.4);
            }
            components[i] = (float) y;
        }

        return components;
    }

    private float lerp(float color1, float color2, float frac)
    {
        return color1 * (1 - frac) + color2 * frac;
    }
}

/*
 * Copyright (c) 2022, Ryan Bell <llaver@live.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.rainbowrave;

import java.util.ArrayList;
import java.util.List;

import net.runelite.api.Point;

public class Curve {

    private final Point from;
    private final Point to;
    private final List<Point> curve = new ArrayList<>();

    public Curve(Point from, Point to) {
        this.from = from;
        this.to = to;

        // TODO hook size of Curve into config
        for(int i = 1; i <= 5; i++) {
            curve.add(interpolate(from, to, (double) (i * 2) / 10));
        }
    }

    /**
     * Linearly interpolates between two points.
     *
     * @param from The starting point.
     * @param to The ending point.
     * @param t The interpolation progress starting at 0 and going to 1 (percent of distance between points).
     * @return The interpolated point.
     */
    private Point interpolate(Point from, Point to, double t) {
        double x = from.getX() * (1 - t) + to.getX() * t;
        double y = from.getY() * (1 - t) + to.getY() * t;
        return new Point((int) Math.round(x), (int) Math.round(y));
    }

    public Point getFrom() {
        return from;
    }

    public Point getTo() {
        return to;
    }

    public List<Point> getCurve() {
        return curve;
    }
}

/*
 * Copyright (c) 2022, Ryan Bell <llaver@live.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.rainbowrave;

import java.awt.event.MouseEvent;
import java.util.*;
import java.util.Deque;
import javax.inject.Inject;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.*;
import net.runelite.api.events.ClientTick;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.events.ConfigChanged;
import net.runelite.client.input.MouseAdapter;
import net.runelite.client.input.MouseManager;

@Slf4j
public class RainbowRaveMouseTrailPlugin
{
    private final Deque<Curve> curve = new ArrayDeque<>();
    private Point temp = null;

    @Inject
    private MouseManager mouseManager;

    private final MouseAdapter mouseAdapter = new MouseAdapter() {
        @Override
        public MouseEvent mouseMoved(MouseEvent event)
        {
            updateMousePositions(new Point(event.getX(), event.getY()));
            return event;
        }
        @Override
        public MouseEvent mouseDragged(MouseEvent event)
        {
            updateMousePositions(new Point(event.getX(), event.getY()));
            return event;
        }
    };

    protected void startUp()
    {
        setMouseListenerEnabled(true);
    }

    protected void shutDown()
    {
        curve.clear();

        setMouseListenerEnabled(false);
    }

    public void setMouseListenerEnabled(boolean enabled)
    {
        if (enabled)
        {
            mouseManager.registerMouseListener(mouseAdapter);
        }
        else
        {
            mouseManager.unregisterMouseListener(mouseAdapter);
        }
    }

    @Subscribe
    public void onClientTick(ClientTick event)
    {
        popTrail();
        popTrail();
    }

    @Subscribe
    public void onConfigChanged(ConfigChanged configChanged) {
        if (configChanged.getGroup().equals("rainbow_rave") && configChanged.getKey().equals("whichMouseTrailStyle") && configChanged.getNewValue() != null) {
			setMouseListenerEnabled(!configChanged.getNewValue().equals("NONE"));
		}
    }

    public void updateMousePositions(Point point) {
            if (curve.size() < 50) {
                if (temp != null) {
                    Curve current = new Curve(temp, point);
                    curve.add(current);
                }
                temp = point;
            }
    }

    public Deque<Curve> getTrail() {
        return curve;
    }

    public void popTrail() {
        if(curve.size() > 0) {
            curve.pop();
        }
    }
}
/*
 * Copyright (c) 2020, dekvall <https://github.com/dekvall>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.rainbowrave;

import lombok.RequiredArgsConstructor;
import lombok.Value;

@Value
@RequiredArgsConstructor
class NamedQuantity
{
	private final String name;
	private final int quantity;

	NamedQuantity(GroundItem groundItem)
	{
		this(groundItem.getName(), groundItem.getQuantity());
	}
}

/*
 * Copyright (c) 2018, TheLonelyDev <https://github.com/TheLonelyDev>
 * Copyright (c) 2018, Adam <Adam@sigterm.info>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.rainbowrave;

import com.google.common.base.Strings;
import com.google.gson.Gson;
import com.google.gson.reflect.TypeToken;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.List;
import java.util.Optional;
import java.util.stream.Collectors;
import javax.inject.Inject;
import lombok.AccessLevel;
import lombok.Getter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.GameState;
import net.runelite.api.MenuAction;
import net.runelite.api.Tile;
import net.runelite.api.WorldView;
import net.runelite.api.coords.LocalPoint;
import net.runelite.api.coords.WorldPoint;
import net.runelite.api.events.GameStateChanged;
import net.runelite.api.events.MenuOptionClicked;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.eventbus.EventBus;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.events.ConfigChanged;
import net.runelite.client.game.chatbox.ChatboxPanelManager;
import net.runelite.client.plugins.groundmarkers.GroundMarkerConfig;
import net.runelite.client.ui.overlay.OverlayManager;
import static net.runelite.http.api.RuneLiteAPI.GSON;

@Slf4j
public class RainbowRaveGroundMarkerPlugin
{
	private static final String CONFIG_GROUP = "groundMarker";
	private static final String WALK_HERE = "Walk here";
	private static final String REGION_PREFIX = "region_";

	private static final String BRUSH_CONFIG_GROUP = "brushMarkers";

	@Getter(AccessLevel.PACKAGE)
	private final List<ColorTileMarker> points = new ArrayList<>();

	@Inject
	private Client client;

	@Inject
	private GroundMarkerConfig config;

	@Inject
	private ConfigManager configManager;

	@Inject
	private OverlayManager overlayManager;

	@Inject
	private ChatboxPanelManager chatboxPanelManager;

	@Inject
	private RainbowRaveConfig rainbowRaveConfig;

	@Inject
	private EventBus eventBus;

	@Inject
	private Gson gson;

	Collection<GroundMarkerPoint> getPoints(int regionId)
	{
		String json = configManager.getConfiguration(CONFIG_GROUP, REGION_PREFIX + regionId);
		if (Strings.isNullOrEmpty(json))
		{
			return Collections.emptyList();
		}

		// CHECKSTYLE:OFF
		return gson.fromJson(json, new TypeToken<List<GroundMarkerPoint>>(){}.getType());
		// CHECKSTYLE:ON
	}

	void loadPoints()
	{
		loadPoints(null, false);
	}

	void loadPoints(GroundMarkerPoint extraPoint, boolean added)
	{
		points.clear();

		int[] regions = client.getTopLevelWorldView().getMapRegions();

		if (regions == null)
		{
			return;
		}

		for (int regionId : regions)
		{
			// load points for region
			log.debug("Loading points for region {}", regionId);
			Collection<GroundMarkerPoint> regionPoints = new ArrayList<>(getPoints(regionId));
			if (extraPoint != null && !added)
			{
				regionPoints.remove(extraPoint);
			}
			Collection<ColorTileMarker> colorTileMarkers = translateToColorTileMarker(regionPoints);
			points.addAll(colorTileMarkers);

			if (rainbowRaveConfig.useBrushMarkerTiles())
			{
				Collection<GroundMarkerPoint> brushRegionPoints = getBrushPoints(regionId);
				Collection<ColorTileMarker> brushColorTileMarkers = translateToColorTileMarker(brushRegionPoints);
				points.addAll(brushColorTileMarkers);
			}
		}

		if (extraPoint != null && added) {
			Collection<ColorTileMarker> colorTileMarkers = translateToColorTileMarker(Collections.singletonList(extraPoint));
			points.addAll(colorTileMarkers);
		}
	}

	/**
	 * Translate a collection of ground marker points to color tile markers, accounting for instances
	 *
	 * @param points {@link GroundMarkerPoint}s to be converted to {@link ColorTileMarker}s
	 * @return A collection of color tile markers, converted from the passed ground marker points, accounting for local
	 *         instance points. See {@link WorldPoint#toLocalInstance(WorldView, WorldPoint)}
	 */
	private Collection<ColorTileMarker> translateToColorTileMarker(Collection<GroundMarkerPoint> points)
	{
		if (points.isEmpty())
		{
			return Collections.emptyList();
		}

		WorldView wv = client.getTopLevelWorldView();
		return points.stream()
			.map(point -> new ColorTileMarker(
				WorldPoint.fromRegion(point.getRegionId(), point.getRegionX(), point.getRegionY(), point.getZ()),
				point.getColor(), point.getLabel()))
			.flatMap(colorTile ->
			{
				final Collection<WorldPoint> localWorldPoints = WorldPoint.toLocalInstance(wv, colorTile.getWorldPoint());
				return localWorldPoints.stream().map(wp -> new ColorTileMarker(wp, colorTile.getColor(), colorTile.getLabel()));
			})
			.collect(Collectors.toList());
	}

	public void startUp()
	{
		loadPoints();
	}

	public void shutDown()
	{
		points.clear();
	}

	@Subscribe
	public void onGameStateChanged(GameStateChanged gameStateChanged)
	{
		if (gameStateChanged.getGameState() != GameState.LOGGED_IN)
		{
			return;
		}

		// map region has just been updated
		loadPoints();
	}

	@Subscribe
	public void onMenuOptionClicked(MenuOptionClicked event)
	{
		if (event.getMenuAction().getId() != MenuAction.RUNELITE.getId())
		{
			return;
		}

		Tile target = client.getTopLevelWorldView().getSelectedSceneTile();
		if (target == null || !event.getMenuTarget().equals("Tile"))
		{
			return;
		}

		final String option = event.getMenuOption();
		if (option.equals("Mark") || option.equals("Unmark"))
		{
			markTile(target.getLocalLocation());
		}
		else if (option.equals("Label"))
		{
			labelTile(target);
		}
	}

	@Subscribe
	public void onConfigChanged(ConfigChanged event)
	{
		if (event.getGroup().equals(RainbowRavePlugin.GROUP) && event.getKey().equals("useBrushMarkerTiles")) {
			loadPoints();
		}
		if (event.getGroup().equals(BRUSH_CONFIG_GROUP) && event.getKey().startsWith(REGION_PREFIX)) {
			loadPoints();
		}
//		if (event.getGroup().equals(GroundMarkerConfig.GROUND_MARKER_CONFIG_GROUP)
//			&& (event.getKey().equals(GroundMarkerConfig.SHOW_IMPORT_EXPORT_KEY_NAME)
//				|| event.getKey().equals(GroundMarkerConfig.SHOW_CLEAR_KEY_NAME)))
//		{
			// Maintain consistent menu option order by removing everything then adding according to config
//			sharingManager.removeMenuOptions();
//
//			if (config.showImportExport())
//			{
//				sharingManager.addImportExportMenuOptions();
//			}
//			if (config.showClear())
//			{
//				sharingManager.addClearMenuOption();
//			}
//		}
	}

	private void markTile(LocalPoint localPoint)
	{
		if (localPoint == null)
		{
			return;
		}

		WorldPoint worldPoint = WorldPoint.fromLocalInstance(client, localPoint);

		int regionId = worldPoint.getRegionID();
		GroundMarkerPoint point = new GroundMarkerPoint(regionId, worldPoint.getRegionX(), worldPoint.getRegionY(), worldPoint.getPlane(), config.markerColor(), null);
		log.debug("Updating point: {} - {}", point, worldPoint);

		List<GroundMarkerPoint> groundMarkerPoints = new ArrayList<>(getPoints(regionId));
		if (groundMarkerPoints.contains(point))
		{
			// since I don't save points this won't see any tiles added through ground markers immediately, hence the extra args.
			loadPoints(point, false);
		}
		else
		{
			// since I don't save points this won't see any tiles added through ground markers immediately, hence the extra args.
			loadPoints(point, true);
		}

//		savePoints(regionId, groundMarkerPoints);
	}

	private void labelTile(Tile tile)
	{
		LocalPoint localPoint = tile.getLocalLocation();
		WorldPoint worldPoint = WorldPoint.fromLocalInstance(client, localPoint);
		final int regionId = worldPoint.getRegionID();

		GroundMarkerPoint searchPoint = new GroundMarkerPoint(regionId, worldPoint.getRegionX(), worldPoint.getRegionY(), worldPoint.getPlane(), null, null);
		Collection<GroundMarkerPoint> points = getPoints(regionId);
		GroundMarkerPoint existing = points.stream()
			.filter(p -> p.equals(searchPoint))
			.findFirst().orElse(null);
		if (existing == null)
		{
			return;
		}

		chatboxPanelManager.openTextInput("Tile label")
			.value(Optional.ofNullable(existing.getLabel()).orElse(""))
			.onDone((input) ->
			{
				input = Strings.emptyToNull(input);

				GroundMarkerPoint newPoint = new GroundMarkerPoint(regionId, worldPoint.getRegionX(), worldPoint.getRegionY(), worldPoint.getPlane(), existing.getColor(), input);
				points.remove(searchPoint);
				points.add(newPoint);
//				savePoints(regionId, points);

				loadPoints();
			})
			.build();
	}

	private Collection<GroundMarkerPoint> getBrushPoints(int regionId)
	{
		String json = configManager.getConfiguration(BRUSH_CONFIG_GROUP, REGION_PREFIX + regionId);
		if (Strings.isNullOrEmpty(json))
		{
			return Collections.emptyList();
		}

		// CHECKSTYLE:OFF
		return GSON.fromJson(json, new TypeToken<List<GroundMarkerPoint>>()
		{
		}.getType());
		// CHECKSTYLE:ON
	}
}

/*
 * Copyright (c) 2018, James Swindle <wilingua@gmail.com>
 * Copyright (c) 2018, Adam <Adam@sigterm.info>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.rainbowrave;

import com.rainbowrave.RainbowRaveNpcIndicatorsPlugin.HighlightedNpc;
import java.awt.BasicStroke;
import java.awt.Color;
import java.awt.Dimension;
import java.awt.Graphics2D;
import java.awt.Polygon;
import java.awt.Shape;
import java.text.DecimalFormat;
import java.text.NumberFormat;
import java.time.Instant;
import java.util.Locale;
import net.runelite.api.Actor;
import net.runelite.api.Client;
import net.runelite.api.Constants;
import net.runelite.api.NPCComposition;
import net.runelite.api.Perspective;
import net.runelite.api.Player;
import net.runelite.api.Point;
import net.runelite.api.coords.LocalPoint;
import net.runelite.api.coords.WorldPoint;
import net.runelite.client.plugins.npchighlight.NpcIndicatorsConfig;
import net.runelite.client.ui.overlay.Overlay;
import net.runelite.client.ui.overlay.OverlayLayer;
import net.runelite.client.ui.overlay.OverlayPosition;
import net.runelite.client.ui.overlay.OverlayUtil;
import net.runelite.client.ui.overlay.outline.ModelOutlineRenderer;
import net.runelite.client.util.Text;

public class RainbowRaveNpcSceneOverlay extends Overlay
{
	// Anything but white text is quite hard to see since it is drawn on
	// a dark background
	private static final Color TEXT_COLOR = Color.WHITE;

	private static final NumberFormat TIME_LEFT_FORMATTER = DecimalFormat.getInstance(Locale.US);

	static
	{
		((DecimalFormat)TIME_LEFT_FORMATTER).applyPattern("#0.0");
	}

	private final Client client;
	private final NpcIndicatorsConfig config;
	private final RainbowRaveNpcIndicatorsPlugin plugin;
	private final RainbowRaveConfig rainbowRaveConfig;
	private final ModelOutlineRenderer modelOutlineRenderer;

	private final RainbowRavePlugin rainbowRavePlugin;

	RainbowRaveNpcSceneOverlay(Client client, NpcIndicatorsConfig config, RainbowRaveNpcIndicatorsPlugin plugin,
							   ModelOutlineRenderer modelOutlineRenderer, RainbowRavePlugin rainbowRavePlugin, RainbowRaveConfig rainbowRaveConfig)
	{
		this.client = client;
		this.config = config;
		this.plugin = plugin;
		this.modelOutlineRenderer = modelOutlineRenderer;
		this.rainbowRavePlugin = rainbowRavePlugin;
		this.rainbowRaveConfig = rainbowRaveConfig;
		setPosition(OverlayPosition.DYNAMIC);
		setLayer(OverlayLayer.ABOVE_SCENE);
	}

	@Override
	public Dimension render(Graphics2D graphics)
	{
		if (enabled)
		{
			if (config.showRespawnTimer())
			{
				plugin.getDeadNpcsToDisplay().forEach((id, npc) -> renderNpcRespawn(npc, graphics));
			}

			for (HighlightedNpc highlightedNpc : plugin.getHighlightedNpcs().values())
			{
				renderNpcOverlay(graphics, highlightedNpc, null);
			}
		}

		if (rainbowRaveConfig.highlightSelf() || rainbowRaveConfig.highlightOthers())
		{
			// The NPC here is never used, but HighlightedNpc requires it to be non-null.
			if (rainbowRaveConfig.highlightSelf())
			{
				renderNpcOverlay(graphics, plugin.highlightedPlayer(), client.getLocalPlayer());
			}
			if (rainbowRaveConfig.highlightOthers())
			{
				for (Player player : client.getTopLevelWorldView().players())
				{
					if (player != client.getLocalPlayer())
						renderNpcOverlay(graphics, plugin.highlightedPlayer(), player);
				}
			}
		}

		return null;
	}

	private void renderNpcRespawn(final MemorizedNpc npc, final Graphics2D graphics)
	{
		if (npc.getPossibleRespawnLocations().isEmpty())
		{
			return;
		}

		final WorldPoint respawnLocation = npc.getPossibleRespawnLocations().get(0);
		final LocalPoint lp = LocalPoint.fromWorld(npc.getWorldView(), respawnLocation.getX(), respawnLocation.getY());

		if (lp == null)
		{
			return;
		}

		final LocalPoint centerLp = new LocalPoint(
			lp.getX() + Perspective.LOCAL_TILE_SIZE * (npc.getNpcSize() - 1) / 2,
			lp.getY() + Perspective.LOCAL_TILE_SIZE * (npc.getNpcSize() - 1) / 2,
			npc.getWorldView());

		final Polygon poly = Perspective.getCanvasTileAreaPoly(client, centerLp, npc.getNpcSize());
		renderPoly(graphics, config.highlightColor(), config.fillColor(), poly);

		final Instant now = Instant.now();
		final double baseTick = ((npc.getDiedOnTick() + npc.getRespawnTime()) - client.getTickCount()) * (Constants.GAME_TICK_LENGTH / 1000.0);
		final double sinceLast = (now.toEpochMilli() - plugin.getLastTickUpdate().toEpochMilli()) / 1000.0;
		final double timeLeft = Math.max(0.0, baseTick - sinceLast);
		final String timeLeftStr = TIME_LEFT_FORMATTER.format(timeLeft);

		final int textWidth = graphics.getFontMetrics().stringWidth(timeLeftStr);
		final int textHeight = graphics.getFontMetrics().getAscent();

		final Point canvasPoint = Perspective
			.localToCanvas(client, centerLp, respawnLocation.getPlane());

		if (canvasPoint != null)
		{
			final Point canvasCenterPoint = new Point(
				canvasPoint.getX() - textWidth / 2,
				canvasPoint.getY() + textHeight / 2);

			OverlayUtil.renderTextLocation(graphics, canvasCenterPoint, timeLeftStr, TEXT_COLOR);
		}
	}

	private void renderNpcOverlay(Graphics2D graphics, HighlightedNpc highlightedNpc, Player player)
	{
		Actor actor;
		NPCComposition npcComposition = null;
		if (player == null)
		{
			actor = highlightedNpc.getNpc();
			npcComposition = highlightedNpc.getNpc().getTransformedComposition();
			if (npcComposition == null || !npcComposition.isInteractible()
				|| (actor.isDead() && config.ignoreDeadNpcs()))
			{
				return;
			}
		} else {
			actor = player;
		}

		final Color borderColor = rainbowRavePlugin.getColor(actor.hashCode());
		Color fillColor = rainbowRavePlugin.getColor(actor.hashCode());
		fillColor = new Color(fillColor.getRed(), fillColor.getGreen(), fillColor.getBlue(), config.fillColor().getAlpha());

		if (highlightedNpc.isHull())
		{
			Shape objectClickbox = actor.getConvexHull();
			renderPoly(graphics, borderColor, fillColor, objectClickbox);
		}

		if (highlightedNpc.isTile())
		{
			int size = npcComposition == null ? 1 : npcComposition.getSize();
			LocalPoint lp = actor.getLocalLocation();
			Polygon tilePoly = Perspective.getCanvasTileAreaPoly(client, lp, size);

			renderPoly(graphics, borderColor, fillColor, tilePoly);
		}

		if (highlightedNpc.isTrueTile())
		{
			LocalPoint lp = LocalPoint.fromWorld(actor.getWorldView(), actor.getWorldLocation()); // centered on sw tile
			if (lp != null)
			{
				int size = npcComposition == null ? 1 : npcComposition.getSize();
				final LocalPoint centerLp = new LocalPoint(
					lp.getX() + Perspective.LOCAL_TILE_SIZE * (size - 1) / 2,
					lp.getY() + Perspective.LOCAL_TILE_SIZE * (size - 1) / 2,
					actor.getWorldView());
				Polygon tilePoly = Perspective.getCanvasTileAreaPoly(client, centerLp, size);
				renderPoly(graphics, borderColor, fillColor, tilePoly);
			}
		}

		if (highlightedNpc.isSwTile())
		{
			int size = npcComposition == null ? 1 : npcComposition.getSize();
			LocalPoint lp = actor.getLocalLocation();

			int x = lp.getX() - ((size - 1) * Perspective.LOCAL_TILE_SIZE / 2);
			int y = lp.getY() - ((size - 1) * Perspective.LOCAL_TILE_SIZE / 2);

			Polygon southWestTilePoly = Perspective.getCanvasTilePoly(client, new LocalPoint(x, y, actor.getWorldView()));
			renderPoly(graphics, borderColor, fillColor, southWestTilePoly);
		}

		if (highlightedNpc.isSwTrueTile())
		{
			LocalPoint lp = LocalPoint.fromWorld(actor.getWorldView(), actor.getWorldLocation());
			if (lp != null)
			{
				Polygon tilePoly = Perspective.getCanvasTilePoly(client, lp);
				renderPoly(graphics, borderColor, fillColor, tilePoly);
			}
		}

		if (highlightedNpc.isOutline())
		{
			if (player == null)
			{
				modelOutlineRenderer.drawOutline(highlightedNpc.getNpc(), (int) config.borderWidth(), borderColor, config.outlineFeather());
			} else {
				modelOutlineRenderer.drawOutline(player, (int) config.borderWidth(), borderColor, config.outlineFeather());
			}
		}

		if (highlightedNpc.isName() && actor.getName() != null)
		{
			String npcName = Text.removeTags(actor.getName());
			Point textLocation = actor.getCanvasTextLocation(graphics, npcName, actor.getLogicalHeight() + 40);

			if (textLocation != null)
			{
				OverlayUtil.renderTextLocation(graphics, textLocation, npcName, borderColor);
			}
		}
	}

	private void renderPoly(Graphics2D graphics, Color borderColor, Color fillColor, Shape polygon)
	{
		if (polygon != null)
		{
			graphics.setColor(borderColor);
			graphics.setStroke(new BasicStroke((float) config.borderWidth()));
			graphics.draw(polygon);
			graphics.setColor(fillColor);
			graphics.fill(polygon);
		}
	}

	private boolean enabled = true;
	public void enable(boolean enabled)
	{
		this.enabled = enabled;
	}
}

/*
 * Copyright (c) 2018, Seth <https://github.com/sethtroll>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.rainbowrave;

import java.awt.Point;
import java.awt.event.KeyEvent;
import java.awt.event.MouseEvent;
import java.time.Duration;
import java.time.Instant;
import javax.inject.Inject;
import javax.swing.SwingUtilities;
import net.runelite.client.input.KeyListener;
import net.runelite.client.input.MouseAdapter;
import net.runelite.client.plugins.grounditems.GroundItemsConfig;

public class RainbowRaveGroundItemInputListener extends MouseAdapter implements KeyListener
{
	private static final int HOTKEY = KeyEvent.VK_ALT;

	private Instant lastPress;

	@Inject
	private RainbowRaveGroundItemsPlugin plugin;

	@Inject
	private GroundItemsConfig config;

	@Override
	public void keyTyped(KeyEvent e)
	{

	}

	@Override
	public void keyPressed(KeyEvent e)
	{
		if (e.getKeyCode() == HOTKEY)
		{
			if (plugin.isHideAll())
			{
				plugin.setHideAll(false);
				plugin.setHotKeyPressed(true);
				lastPress = null;
			}
			else if (lastPress != null && !plugin.isHotKeyPressed() && config.doubleTapDelay() > 0 && Duration.between(lastPress, Instant.now()).compareTo(Duration.ofMillis(config.doubleTapDelay())) < 0)
			{
				plugin.setHideAll(true);
				lastPress = null;
			}
			else
			{
				plugin.setHotKeyPressed(true);
				lastPress = Instant.now();
			}
		}
	}

	@Override
	public void keyReleased(KeyEvent e)
	{
		if (e.getKeyCode() == HOTKEY)
		{
			plugin.setHotKeyPressed(false);
			plugin.setTextBoxBounds(null);
			plugin.setHiddenBoxBounds(null);
			plugin.setHighlightBoxBounds(null);
		}
	}

	@Override
	public MouseEvent mousePressed(MouseEvent e)
	{
		final Point mousePos = e.getPoint();

		if (plugin.isHotKeyPressed())
		{
			if (SwingUtilities.isLeftMouseButton(e))
			{
				// Process both click boxes for hidden and highlighted items
				if (plugin.getHiddenBoxBounds() != null && plugin.getHiddenBoxBounds().getKey().contains(mousePos))
				{
					return e;
				}

				if (plugin.getHighlightBoxBounds() != null && plugin.getHighlightBoxBounds().getKey().contains(mousePos))
				{
					return e;
				}

				// There is one name click box for left click and one for right click
				if (plugin.getTextBoxBounds() != null && plugin.getTextBoxBounds().getKey().contains(mousePos))
				{
					return e;
				}
			}
			else if (SwingUtilities.isRightMouseButton(e))
			{
				if (plugin.getTextBoxBounds() != null && plugin.getTextBoxBounds().getKey().contains(mousePos))
				{
					return e;
				}
			}
		}

		return e;
	}
}


/*
 * Copyright (c) 2018, Tomas Slusny <slusnucky@gmail.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.rainbowrave;

import java.awt.Color;
import java.time.Duration;
import java.time.Instant;
import javax.annotation.Nullable;
import lombok.Builder;
import lombok.Data;
import static net.runelite.api.TileItem.OWNERSHIP_OTHER;
import net.runelite.api.coords.WorldPoint;

@Data
@Builder
class GroundItem
{
	private int id;
	private int itemId;
	private String name;
	private int quantity;
	private WorldPoint location;
	private int height;
	private int haPrice;
	private int gePrice;
	private int offset;
	private boolean tradeable;
	private int ownership;
	private boolean isPrivate;
	@Nullable
	private Instant spawnTime;
	private boolean stackable;
	private Duration despawnTime;
	private Duration visibleTime;

	// cached values derived from config
	boolean highlighted;
	boolean hidden;
	Color color;

	int getHaPrice()
	{
		return haPrice * quantity;
	}

	int getGePrice()
	{
		return gePrice * quantity;
	}

	boolean isMine()
	{
		return ownership != OWNERSHIP_OTHER;
	}

	void reset()
	{
		highlighted = hidden = false;
		color = null;
	}
}

/*
 * Copyright (c) 2018, Tomas Slusny <slusnucky@gmail.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

package com.rainbowrave;

import java.awt.Color;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@NoArgsConstructor
@AllArgsConstructor
class ObjectPoint
{
	private int id = -1;
	private String name;
	private int regionId;
	private int regionX;
	private int regionY;
	private int z;
	private Color color;
}

/*
 * Copyright (c) 2018, TheLonelyDev <https://github.com/TheLonelyDev>
 * Copyright (c) 2018, Adam <Adam@sigterm.info>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.rainbowrave;

import com.google.common.base.Strings;
import java.awt.BasicStroke;
import java.awt.Color;
import java.awt.Dimension;
import java.awt.Graphics2D;
import java.awt.Polygon;
import java.awt.Stroke;
import java.util.Collection;
import java.util.ConcurrentModificationException;
import java.util.Random;
import javax.annotation.Nullable;
import net.runelite.api.Client;
import net.runelite.api.Perspective;
import net.runelite.api.Point;
import net.runelite.api.coords.LocalPoint;
import net.runelite.api.coords.WorldPoint;
import net.runelite.client.plugins.groundmarkers.GroundMarkerConfig;
import net.runelite.client.ui.overlay.Overlay;
import net.runelite.client.ui.overlay.OverlayLayer;
import net.runelite.client.ui.overlay.OverlayPosition;
import net.runelite.client.ui.overlay.OverlayUtil;

public class RainbowRaveGroundMarkerOverlay extends Overlay
{
	private static final int MAX_DRAW_DISTANCE = 32;

	private final Client client;
	private final GroundMarkerConfig config;
	private final RainbowRaveGroundMarkerPlugin plugin;
	private final RainbowRaveConfig rainbowRaveConfig;
	private final RainbowRavePlugin rainbowRavePlugin;

	public RainbowRaveGroundMarkerOverlay(Client client, GroundMarkerConfig config, RainbowRaveGroundMarkerPlugin plugin, RainbowRavePlugin rainbowRavePlugin, RainbowRaveConfig rainbowRaveConfig)
	{
		this.client = client;
		this.config = config;
		this.plugin = plugin;
		this.rainbowRavePlugin = rainbowRavePlugin;
		this.rainbowRaveConfig = rainbowRaveConfig;
		setPosition(OverlayPosition.DYNAMIC);
		setPriority(Overlay.PRIORITY_LOW);
		setLayer(OverlayLayer.ABOVE_SCENE);
	}

	private Random random = new Random();

	@Override
	public Dimension render(Graphics2D graphics)
	{
		if (!rainbowRaveConfig.rainbowTileMarkers()) return null;

		final Collection<ColorTileMarker> points = plugin.getPoints();
		if (points.isEmpty())
		{
			return null;
		}

		Stroke stroke = new BasicStroke((float) config.borderWidth());
		try
		{
			int plane = client.getTopLevelWorldView().getPlane();
			for (final ColorTileMarker point : points)
			{
				WorldPoint worldPoint = point.getWorldPoint();
				if (worldPoint.getPlane() != plane)
				{
					continue;
				}

				// This formula does not have a solid concept behind it, I just tried random stuff.
				int hashCode;
				switch (rainbowRaveConfig.groundMarkerColorMode()) {
					case WAVES:
						hashCode = (point.getWorldPoint().getX() + point.getWorldPoint().getY()) * 5;
						break;
					case COLOR_SYNC:
						if (point.getColor() != null) {
							random.setSeed(point.getColor().getRGB());
							hashCode = random.nextInt(1000);
							break;
						}
					case RANDOM:
					default:
						random.setSeed(((long) point.getWorldPoint().getX() << 16) + point.getWorldPoint().getY());
						hashCode = random.nextInt(1000);
				}
				Color tileColor = rainbowRaveConfig.syncColor() ? rainbowRavePlugin.getColor(0) : rainbowRaveConfig.theme().getColor(((hashCode + (client.getGameCycle() * (6000f / rainbowRaveConfig.colorSpeed()))) % 300) / 300f);
				drawTile(graphics, worldPoint, tileColor, point.getLabel(), stroke, rainbowRaveConfig.fillTiles());
			}
		} catch (ConcurrentModificationException e) {
			// can happen when removing stuff from points, such as when disabling drawing brush markers tiles.
			// don't care, doesn't have a significant visual effect.
		}

		return null;
	}

	private void drawTile(Graphics2D graphics, WorldPoint point, Color color, @Nullable String label, Stroke borderStroke, boolean fill)
	{
		WorldPoint playerLocation = client.getLocalPlayer().getWorldLocation();

		if (point.distanceTo(playerLocation) >= MAX_DRAW_DISTANCE)
		{
			return;
		}

		LocalPoint lp = LocalPoint.fromWorld(client.getTopLevelWorldView(), point);
		if (lp == null)
		{
			return;
		}

		Polygon poly = Perspective.getCanvasTilePoly(client, lp);
		if (poly != null)
		{
			if (fill)
			{
				graphics.setColor(color);
				graphics.fillPolygon(poly);
			}
			graphics.setColor(color);
			Stroke originalStroke = graphics.getStroke();
			graphics.setStroke(borderStroke);
			graphics.draw(poly);
			graphics.setStroke(originalStroke);
		}

		if (!Strings.isNullOrEmpty(label))
		{
			Point canvasTextLocation = Perspective.getCanvasTextLocation(client, graphics, lp, label, 0);
			if (canvasTextLocation != null)
			{
				OverlayUtil.renderTextLocation(graphics, canvasTextLocation, label, color);
			}
		}
	}
}

/*
 * Copyright (c) 2017, Aria <aria@ar1as.space>
 * Copyright (c) 2018, Adam <Adam@sigterm.info>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.rainbowrave;

import com.google.common.cache.CacheBuilder;
import com.google.common.cache.LoadingCache;
import com.google.common.collect.HashBasedTable;
import com.google.common.collect.ImmutableList;
import com.google.common.collect.Table;
import static com.rainbowrave.RainbowRaveConfig.GroundItemsToColor.HIGH;
import static com.rainbowrave.RainbowRaveConfig.GroundItemsToColor.INSANE;
import static com.rainbowrave.RainbowRaveConfig.GroundItemsToColor.LOW;
import static com.rainbowrave.RainbowRaveConfig.GroundItemsToColor.MEDIUM;
import java.awt.Color;
import java.awt.Rectangle;
import static java.lang.Boolean.TRUE;
import java.time.Duration;
import java.time.Instant;
import java.util.Collection;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import java.util.concurrent.CopyOnWriteArrayList;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.TimeUnit;
import javax.inject.Inject;
import javax.swing.SwingUtilities;
import lombok.AccessLevel;
import lombok.Getter;
import lombok.Setter;
import lombok.Value;
import net.runelite.api.*;
import net.runelite.api.coords.WorldPoint;
import net.runelite.api.events.FocusChanged;
import net.runelite.api.events.GameStateChanged;
import net.runelite.api.events.ItemDespawned;
import net.runelite.api.events.ItemQuantityChanged;
import net.runelite.api.events.ItemSpawned;
import net.runelite.client.Notifier;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.events.ClientShutdown;
import net.runelite.client.events.ConfigChanged;
import net.runelite.client.game.ItemManager;
import net.runelite.client.input.KeyManager;
import net.runelite.client.input.MouseManager;
import net.runelite.client.plugins.grounditems.GroundItemsConfig;
import net.runelite.client.plugins.grounditems.config.OwnershipFilterMode;
import static net.runelite.api.TileItem.OWNERSHIP_GROUP;
import static net.runelite.api.TileItem.OWNERSHIP_NONE;
import static net.runelite.api.TileItem.OWNERSHIP_OTHER;
import static net.runelite.api.TileItem.OWNERSHIP_SELF;
import net.runelite.client.plugins.grounditems.config.HighlightTier;
import net.runelite.client.ui.overlay.OverlayManager;
import net.runelite.client.util.RSTimeUnit;
import net.runelite.client.util.Text;

public class RainbowRaveGroundItemsPlugin
{

	public static final String GROUND_ITEMS_CONFIG_GROUP = "grounditems";
	public static final String SHOW_LOOTBEAM_TIER_CONFIG_KEY = "showLootbeamTier";
	public static final String SHOW_LOOTBEAM_FOR_HIGHLIGHTED_CONFIG_KEY = "showLootbeamForHighlighted";

	@Value
	static class PriceHighlight
	{
		private final int price;
		private final Color color;
	}

	// ItemID for coins
	private static final int COINS = ItemID.COINS_995;

	@Getter(AccessLevel.PACKAGE)
	@Setter(AccessLevel.PACKAGE)
	private Map.Entry<Rectangle, GroundItem> textBoxBounds;

	@Getter(AccessLevel.PACKAGE)
	@Setter(AccessLevel.PACKAGE)
	private Map.Entry<Rectangle, GroundItem> hiddenBoxBounds;

	@Getter(AccessLevel.PACKAGE)
	@Setter(AccessLevel.PACKAGE)
	private Map.Entry<Rectangle, GroundItem> highlightBoxBounds;

	@Getter(AccessLevel.PACKAGE)
	@Setter(AccessLevel.PACKAGE)
	private boolean hotKeyPressed;

	@Getter(AccessLevel.PACKAGE)
	@Setter(AccessLevel.PACKAGE)
	private boolean hideAll;

	private List<String> hiddenItemList = new CopyOnWriteArrayList<>();
	private List<String> highlightedItemsList = new CopyOnWriteArrayList<>();

	@Inject
	public RainbowRaveGroundItemInputListener inputListener;

	@Inject
	private MouseManager mouseManager;

	@Inject
	private KeyManager keyManager;

	@Inject
	private Client client;

	@Inject
	private ClientThread clientThread;

	@Inject
	private ItemManager itemManager;

	@Inject
	private OverlayManager overlayManager;

	@Inject
	private GroundItemsConfig config;

//	@Inject
//	private RainbowRaveGroundItemsOverlay overlay;
//
	@Inject
	private Notifier notifier;

	@Inject
	private ScheduledExecutorService executor;

	@Inject
	private RainbowRaveConfig rainbowRaveConfig;

	@Inject
	private RainbowRavePlugin rainbowRavePlugin;

	@Inject
	private ConfigManager configManager;

	@Getter
	private final Table<WorldPoint, Integer, GroundItem> collectedGroundItems = HashBasedTable.create();
	private List<PriceHighlight> priceChecks = ImmutableList.of();
	private LoadingCache<NamedQuantity, Boolean> highlightedItems;
	private LoadingCache<NamedQuantity, Boolean> hiddenItems;
	final Map<WorldPoint, Lootbeam> lootbeams = new HashMap<>();

//	@Override
	protected void startUp()
	{
		groundItemsLootBeamChange(false, false, true);
//		overlayManager.add(overlay);
		mouseManager.registerMouseListener(inputListener);
		keyManager.registerKeyListener(inputListener);
		executor.execute(this::reset);
	}

	@Subscribe
	public void onClientShutdown(ClientShutdown e) {
		if (rainbowRaveConfig.recolorLootBeams())
		{
			restoreGroundItemLootBeams();
		}
	}

//	@Override
	protected void shutDown()
	{
		if (rainbowRaveConfig.recolorLootBeams())
		{
			restoreGroundItemLootBeams();
		}
//		overlayManager.remove(overlay);
		mouseManager.unregisterMouseListener(inputListener);
		keyManager.unregisterKeyListener(inputListener);
		if (highlightedItems != null)
		{
			highlightedItems.invalidateAll();
			highlightedItems = null;
		}
		if (hiddenItems != null)
		{
			hiddenItems.invalidateAll();
			hiddenItems = null;
		}
		hiddenItemList = null;
		highlightedItemsList = null;
		collectedGroundItems.clear();
		clientThread.invokeLater(this::removeAllLootbeams);
	}

	private boolean ignoreConfigChange = false;

	@Subscribe
	public void onConfigChanged(ConfigChanged event)
	{
		if (ignoreConfigChange) return;

		if (event.getGroup().equals(GROUND_ITEMS_CONFIG_GROUP))
		{
			if (event.getKey().equals(SHOW_LOOTBEAM_TIER_CONFIG_KEY)) {
				groundItemsLootBeamChange(true, false, false);
			}
			else if (event.getKey().equals(SHOW_LOOTBEAM_FOR_HIGHLIGHTED_CONFIG_KEY))
			{
				groundItemsLootBeamChange(false, true, false);
			}
			else
			{
				executor.execute(this::reset);
			}
		}
		else if (event.getGroup().equals(RainbowRavePlugin.GROUP))
		{
			if (event.getKey().equals(RainbowRaveConfig.RECOLOR_LOOT_BEAMS_KEY))
			{
				if (rainbowRaveConfig.recolorLootBeams())
				{
					groundItemsLootBeamChange(false, false, true);
				}
				else
				{
					restoreGroundItemLootBeams();
				}
			}
		}
	}

	private void groundItemsLootBeamChange(boolean tierChanged, boolean highlightedChanged, boolean turningOnRecolorLootBeams)
	{
		if (rainbowRaveConfig.recolorLootBeams())
		{
			if (!turningOnRecolorLootBeams && SwingUtilities.isEventDispatchThread()) // Changes from profile changes happen on the executor thread, only show the message when it happens on the swing thread.
			{
				clientThread.invoke(() -> client.addChatMessage(ChatMessageType.GAMEMESSAGE, "",
					"Rainbow Rave: Please change loot beam settings through the rainbow rave plugin's settings, as rainbow rave needs to disable regular loot beams in order to recolor them.",
					"", false));
			}
			ignoreConfigChange = true;
			if (tierChanged || turningOnRecolorLootBeams)
			{
				HighlightTier highlightTier = config.showLootbeamTier();
				rainbowRaveConfig.setGroundItemsLootbeamTier(highlightTier);
				configManager.setConfiguration(GROUND_ITEMS_CONFIG_GROUP, SHOW_LOOTBEAM_TIER_CONFIG_KEY, HighlightTier.OFF);
			}
			if (highlightedChanged || turningOnRecolorLootBeams)
			{
				boolean showLootbeamForHighlighted = config.showLootbeamForHighlighted();
				rainbowRaveConfig.setGroundItemsHighlightedItemsLootbeam(showLootbeamForHighlighted);
				configManager.setConfiguration(GROUND_ITEMS_CONFIG_GROUP, SHOW_LOOTBEAM_FOR_HIGHLIGHTED_CONFIG_KEY, false);
			}
			ignoreConfigChange = false;

			executor.execute(this::reset);
		}
	}

	private void restoreGroundItemLootBeams()
	{
		HighlightTier tier = rainbowRaveConfig.getGroundItemsLootbeamTier();
		Boolean showLootbeamForHighlighted = rainbowRaveConfig.getGroundItemsHighlightedItemsLootbeam();
		ignoreConfigChange = true;
		configManager.setConfiguration(GROUND_ITEMS_CONFIG_GROUP, SHOW_LOOTBEAM_TIER_CONFIG_KEY, tier);
		configManager.setConfiguration(GROUND_ITEMS_CONFIG_GROUP, SHOW_LOOTBEAM_FOR_HIGHLIGHTED_CONFIG_KEY, showLootbeamForHighlighted);
		ignoreConfigChange = false;

		executor.execute(this::reset);
	}

	@Subscribe
	public void onGameStateChanged(final GameStateChanged event)
	{
		if (event.getGameState() == GameState.LOADING)
		{
			collectedGroundItems.clear();
			lootbeams.clear();
		}
	}

	public void onItemSpawned(ItemSpawned itemSpawned)
	{
		TileItem item = itemSpawned.getItem();
		Tile tile = itemSpawned.getTile();

		GroundItem groundItem = buildGroundItem(tile, item);
		GroundItem existing = collectedGroundItems.get(tile.getWorldLocation(), item.getId());
		if (existing != null)
		{
			existing.setQuantity(existing.getQuantity() + groundItem.getQuantity());
			// The spawn time remains set at the oldest spawn
		}
		else
		{
			collectedGroundItems.put(tile.getWorldLocation(), item.getId(), groundItem);
		}

//		if (shouldDisplayItem(config.ownershipFilterMode(), groundItem.getOwnership(), client.getVarbitValue(Varbits.ACCOUNT_TYPE)))
//		{
//			notifyHighlightedItem(groundItem);
//		}

		handleLootbeam(tile.getWorldLocation());
	}

	@Subscribe
	public void onItemDespawned(ItemDespawned itemDespawned)
	{
		TileItem item = itemDespawned.getItem();
		Tile tile = itemDespawned.getTile();

		GroundItem groundItem = collectedGroundItems.get(tile.getWorldLocation(), item.getId());
		if (groundItem == null)
		{
			return;
		}

		if (groundItem.getQuantity() <= item.getQuantity())
		{
			collectedGroundItems.remove(tile.getWorldLocation(), item.getId());
		}
		else
		{
			groundItem.setQuantity(groundItem.getQuantity() - item.getQuantity());
			// When picking up an item when multiple stacks appear on the ground,
			// it is not known which item is picked up, so we invalidate the spawn
			// time
			groundItem.setSpawnTime(null);
		}

		handleLootbeam(tile.getWorldLocation());
	}

	@Subscribe
	public void onItemQuantityChanged(ItemQuantityChanged itemQuantityChanged)
	{
		TileItem item = itemQuantityChanged.getItem();
		Tile tile = itemQuantityChanged.getTile();
		int oldQuantity = itemQuantityChanged.getOldQuantity();
		int newQuantity = itemQuantityChanged.getNewQuantity();

		int diff = newQuantity - oldQuantity;
		GroundItem groundItem = collectedGroundItems.get(tile.getWorldLocation(), item.getId());
		if (groundItem != null)
		{
			groundItem.setQuantity(groundItem.getQuantity() + diff);
		}

		handleLootbeam(tile.getWorldLocation());
	}

//	@Subscribe
//	public void onClientTick(ClientTick event)
//	{
//	}

	private GroundItem buildGroundItem(final Tile tile, final TileItem item)
	{
		// Collect the data for the item
		final int itemId = item.getId();
		final ItemComposition itemComposition = itemManager.getItemComposition(itemId);
		final int realItemId = itemComposition.getNote() != -1 ? itemComposition.getLinkedNoteId() : itemId;
		final int alchPrice = itemComposition.getHaPrice();
		final int despawnTime = item.getDespawnTime() - client.getTickCount();
		final int visibleTime = item.getVisibleTime() - client.getTickCount();

		final GroundItem groundItem = GroundItem.builder()
			.id(itemId)
			.location(tile.getWorldLocation())
			.itemId(realItemId)
			.quantity(item.getQuantity())
			.name(itemComposition.getName())
			.haPrice(alchPrice)
			.height(tile.getItemLayer().getHeight())
			.tradeable(itemComposition.isTradeable())
			.ownership(item.getOwnership())
			.isPrivate(item.isPrivate())
			.spawnTime(Instant.now())
			.stackable(itemComposition.isStackable())
			.despawnTime(Duration.of(despawnTime, RSTimeUnit.GAME_TICKS))
			.visibleTime(Duration.of(visibleTime, RSTimeUnit.GAME_TICKS))
			.build();

		// Update item price in case it is coins
		if (realItemId == COINS)
		{
			groundItem.setHaPrice(1);
			groundItem.setGePrice(1);
		}
		else
		{
			groundItem.setGePrice(itemManager.getItemPrice(realItemId));
		}

		return groundItem;
	}

	private void reset()
	{
		// gets the hidden items from the text box in the config
		hiddenItemList = Text.fromCSV(config.getHiddenItems());

		// gets the highlighted items from the text box in the config
		highlightedItemsList = Text.fromCSV(config.getHighlightItems());

		highlightedItems = CacheBuilder.newBuilder()
			.maximumSize(512L)
			.expireAfterAccess(10, TimeUnit.MINUTES)
			.build(new WildcardMatchLoader(highlightedItemsList));

		hiddenItems = CacheBuilder.newBuilder()
			.maximumSize(512L)
			.expireAfterAccess(10, TimeUnit.MINUTES)
			.build(new WildcardMatchLoader(hiddenItemList));

		// Cache colors
		ImmutableList.Builder<PriceHighlight> priceCheckBuilder = ImmutableList.builder();

		if (config.insaneValuePrice() > 0)
		{
			priceCheckBuilder.add(new PriceHighlight(config.insaneValuePrice(), config.insaneValueColor()));
		}

		if (config.highValuePrice() > 0)
		{
			priceCheckBuilder.add(new PriceHighlight(config.highValuePrice(), config.highValueColor()));
		}

		if (config.mediumValuePrice() > 0)
		{
			priceCheckBuilder.add(new PriceHighlight(config.mediumValuePrice(), config.mediumValueColor()));
		}

		if (config.lowValuePrice() > 0)
		{
			priceCheckBuilder.add(new PriceHighlight(config.lowValuePrice(), config.lowValueColor()));
		}

		priceChecks = priceCheckBuilder.build();

		clientThread.invokeLater(this::handleLootbeams);
	}

//	@Subscribe
//	public void onMenuEntryAdded(MenuEntryAdded event)
//	{
//	}

//	void updateList(String item, boolean hiddenList)
//	{
//	}

	Optional<Color> getHighlighted(NamedQuantity item, int gePrice, int haPrice)
	{
		if (TRUE.equals(highlightedItems.getUnchecked(item)))
		{
			return rainbowRaveConfig.colorHighlightedGroundItems() ? Optional.of(rainbowRavePlugin.getColor(item.getName().hashCode())) : Optional.empty();
		}

		// Explicit hide takes priority over implicit highlight
		if (TRUE.equals(hiddenItems.getUnchecked(item)))
		{
			return null;
		}

		final int price = getValueByMode(gePrice, haPrice);
		if (price > config.insaneValuePrice())
		{
			return colorForTier(INSANE, item);
		}

		if (price > config.highValuePrice())
		{
			return colorForTier(HIGH, item);
		}

		if (price > config.mediumValuePrice())
		{
			return colorForTier(MEDIUM, item);
		}

		if (price > config.lowValuePrice())
		{
			return colorForTier(LOW, item);
		}

		return null;
	}

	private Optional<Color> colorForTier(RainbowRaveConfig.GroundItemsToColor tier, NamedQuantity item)
	{
		return rainbowRaveConfig.whichGroundItemsToColor().compareTo(tier) >= 0 ? Optional.of(rainbowRavePlugin.getColor(item.getName().hashCode())) : Optional.empty();
	}

	Optional<Color> getHidden(NamedQuantity item, int gePrice, int haPrice, boolean isTradeable)
	{
		final boolean isExplicitHidden = TRUE.equals(hiddenItems.getUnchecked(item));
		final boolean isExplicitHighlight = TRUE.equals(highlightedItems.getUnchecked(item));
		final boolean canBeHidden = gePrice > 0 || isTradeable || !config.dontHideUntradeables();
		final boolean underGe = gePrice < config.getHideUnderValue();
		final boolean underHa = haPrice < config.getHideUnderValue();

		// Explicit highlight takes priority over implicit hide
		return isExplicitHidden || (!isExplicitHighlight && canBeHidden && underGe && underHa)
			? rainbowRaveConfig.whichGroundItemsToColor().compareTo(RainbowRaveConfig.GroundItemsToColor.HIDDEN) >= 0 ? Optional.of(rainbowRavePlugin.getColor(item.getName().hashCode())) : Optional.empty()
			: null;
	}

	Optional<Color> getItemColor(Optional<Color> highlighted, Optional<Color> hidden, NamedQuantity item)
	{
		if (highlighted != null)
		{
			return highlighted;
		}

		if (hidden != null)
		{
			return hidden;
		}

		return rainbowRaveConfig.whichGroundItemsToColor().compareTo(RainbowRaveConfig.GroundItemsToColor.REGULAR) >= 0 ? Optional.of(rainbowRavePlugin.getColor(item.getName().hashCode())) : Optional.empty();
	}

	@Subscribe
	public void onFocusChanged(FocusChanged focusChanged)
	{
		if (!focusChanged.isFocused())
		{
			setHotKeyPressed(false);
		}
	}

//	private void notifyHighlightedItem(net.runelite.client.plugins.grounditems.GroundItem item)
//	{
//	}

	private int getValueByMode(int gePrice, int haPrice)
	{
		switch (config.valueCalculationMode())
		{
			case GE:
				return gePrice;
			case HA:
				return haPrice;
			default: // Highest
				return Math.max(gePrice, haPrice);
		}
	}

	private void handleLootbeam(WorldPoint worldPoint)
	{
		/*
		 * Return and remove the lootbeam from this location if lootbeam are disabled
		 * Lootbeam can be at this location if the config was just changed
		 */
		if (!rainbowRaveConfig.recolorLootBeams() || !(rainbowRaveConfig.getGroundItemsHighlightedItemsLootbeam() || rainbowRaveConfig.getGroundItemsLootbeamTier() != HighlightTier.OFF))
		{
			removeLootbeam(worldPoint);
			return;
		}

		int price = -1;
		Collection<GroundItem> groundItems = collectedGroundItems.row(worldPoint).values();
		final OwnershipFilterMode ownershipFilterMode = config.ownershipFilterMode();
		final int accountType = client.getVarbitValue(Varbits.ACCOUNT_TYPE);
		for (GroundItem groundItem : groundItems)
		{
			if (!shouldDisplayItem(ownershipFilterMode, groundItem.getOwnership(), accountType))
			{
				continue;
			}

			/*
			 * highlighted items have the highest priority so if an item is highlighted at this location
			 * we can early return
			 */
			NamedQuantity item = new NamedQuantity(groundItem);
			if (rainbowRaveConfig.getGroundItemsHighlightedItemsLootbeam()
				&& TRUE.equals(highlightedItems.getUnchecked(item)))
			{
				addLootbeam(worldPoint, config.highlightedColor(), null);
				return;
			}

			// Explicit hide takes priority over implicit highlight
			if (TRUE.equals(hiddenItems.getUnchecked(item)))
			{
				continue;
			}

			int itemPrice = getValueByMode(groundItem.getGePrice(), groundItem.getHaPrice());
			price = Math.max(itemPrice, price);
		}

		if (rainbowRaveConfig.getGroundItemsLootbeamTier() != HighlightTier.OFF)
		{
			for (PriceHighlight highlight : priceChecks)
			{
				if (price > highlight.getPrice() && price > rainbowRaveConfig.getGroundItemsLootbeamTier().getValueFromTier(config))
				{
					addLootbeam(worldPoint, highlight.color, rainbowRaveConfig.getGroundItemsLootbeamTier());
					return;
				}
			}
		}

		removeLootbeam(worldPoint);
	}

	private void handleLootbeams()
	{
		for (WorldPoint worldPoint : collectedGroundItems.rowKeySet())
		{
			handleLootbeam(worldPoint);
		}
	}

	private void removeAllLootbeams()
	{
		for (Lootbeam lootbeam : lootbeams.values())
		{
			lootbeam.remove();
		}

		lootbeams.clear();
	}

	private void addLootbeam(WorldPoint worldPoint, Color color, HighlightTier tier)
	{
		Lootbeam lootbeam = lootbeams.get(worldPoint);
		if (lootbeam == null)
		{
			lootbeam = new Lootbeam(client, clientThread, worldPoint, color, config.lootbeamStyle().name(), tier);
			lootbeams.put(worldPoint, lootbeam);
		}
		else
		{
			lootbeam.setColor(color);
			lootbeam.setStyle(config.lootbeamStyle().name());
		}
	}

	private void removeLootbeam(WorldPoint worldPoint)
	{
		Lootbeam lootbeam = lootbeams.remove(worldPoint);
		if (lootbeam != null)
		{
			lootbeam.remove();
		}
	}

	/*
	 * All      -> none | self | other | group
	 * Drops    -> self | group
	 * Takeable -> none | self | group | (if a main then other)
	 */
	boolean shouldDisplayItem(OwnershipFilterMode filterMode, int ownership, int accountType)
	{
		switch (filterMode)
		{
			case DROPS:
				return ownership == OWNERSHIP_SELF || ownership == OWNERSHIP_GROUP;
			case TAKEABLE:
				return ownership != OWNERSHIP_OTHER || accountType == 0; // Mains can always take items
			default:
				return true;
		}
	}
}

/*
 * Copyright (c) 2018, Tomas Slusny <slusnucky@gmail.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.rainbowrave;

import java.awt.Color;
import javax.inject.Inject;
import javax.swing.SwingUtilities;
import lombok.Getter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.coords.WorldPoint;
import net.runelite.api.events.GameTick;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.events.ConfigChanged;
import net.runelite.client.events.ProfileChanged;
import net.runelite.client.ui.overlay.OverlayManager;

@Slf4j
public class RainbowRaveTileIndicatorsPlugin
{
	@Inject private Client client;
	@Inject private OverlayManager overlayManager;
	@Inject private ConfigManager configManager;
	@Inject private RainbowRaveConfig rainbowRaveConfig;

	@Getter private WorldPoint lastPlayerPosition = new WorldPoint(0, 0, 0);
	@Getter private int lastTickPlayerMoved = 0;
	@Getter private long lastTimePlayerStoppedMoving = 0;

	boolean recolorFill;

	boolean highlightDestinationTile;
	Color highlightDestinationColor;
	Color destinationTileFillColor;
	double destinationTileBorderWidth;
	boolean highlightHoveredTile;
	Color highlightHoveredColor;
	Color hoveredTileFillColor;
	double hoveredTileBorderWidth;
	boolean highlightCurrentTile;
	Color highlightCurrentColor;
	Color currentTileFillColor;
	double currentTileBorderWidth;

	boolean trueTileFadeout;
	int trueTileFadeoutTime;
	boolean destinationTileCornersOnly;
	boolean hoveredTileCornersOnly;
	boolean currentTileCornersOnly;
	int hoveredTileCornerSize;
	int destinationTileCornerSize;
	int currentTileCornerSize;

	protected void startUp()
	{
		loadConfig();
	}

	@Subscribe
	public void onProfileChanged(ProfileChanged e) {
		loadConfig();
	}

	protected void shutDown()
	{
	}

	@Subscribe
	public void onConfigChanged(ConfigChanged e) {
		// I don't want this to apply to profile change config changes because the config is in an invalid state
		// during a profile change, so I check the thread since the EDT is where normal config changes happen.
		if (!SwingUtilities.isEventDispatchThread()) return;
		if (e.getGroup().equals("cornertileindicators") || e.getGroup().equals("tileindicators") || e.getGroup().equals("rainbow_rave"))
		{
			loadConfig();
		}
	}

	private void loadConfig() {
		boolean cornerTileIndicatorsInstalled = configManager.getConfiguration("runelite", "externalPlugins").contains("corner-tile-indicators");
		String group = cornerTileIndicatorsInstalled && rainbowRaveConfig.preferCornerTileIndicatorsConfig() ? "cornertileindicators" : "tileindicators";

		recolorFill = rainbowRaveConfig.recolorTileIndicatorFill();

		highlightDestinationTile = configManager.getConfiguration(group, "highlightDestinationTile", boolean.class);
		highlightDestinationColor = configManager.getConfiguration(group, "highlightDestinationColor", Color.class);
		destinationTileFillColor = configManager.getConfiguration(group, "destinationTileFillColor", Color.class);
		destinationTileBorderWidth = configManager.getConfiguration(group, "destinationTileBorderWidth", double.class);
		highlightHoveredTile = configManager.getConfiguration(group, "highlightHoveredTile", boolean.class);
		highlightHoveredColor = configManager.getConfiguration(group, "highlightHoveredColor", Color.class);
		hoveredTileFillColor = configManager.getConfiguration(group, "hoveredTileFillColor", Color.class);
		hoveredTileBorderWidth = configManager.getConfiguration(group, "hoveredTileBorderWidth", double.class);
		highlightCurrentTile = configManager.getConfiguration(group, "highlightCurrentTile", boolean.class);
		highlightCurrentColor = configManager.getConfiguration(group, "highlightCurrentColor", Color.class);
		currentTileFillColor = configManager.getConfiguration(group, "currentTileFillColor", Color.class);
		currentTileBorderWidth = configManager.getConfiguration(group, "currentTileBorderWidth", double.class);

		if ("cornertileindicators".equals(group))
		{
			trueTileFadeout = configManager.getConfiguration(group, "trueTileFadeout", boolean.class);
			trueTileFadeoutTime = configManager.getConfiguration(group, "trueTileFadeoutTime", int.class);
			destinationTileCornersOnly = configManager.getConfiguration(group, "destinationTileCornersOnly", boolean.class);
			hoveredTileCornersOnly = configManager.getConfiguration(group, "hoveredTileCornersOnly", boolean.class);
			currentTileCornersOnly = configManager.getConfiguration(group, "currentTileCornersOnly", boolean.class);
			hoveredTileCornerSize = configManager.getConfiguration(group, "hoveredTileCornerSize", int.class);
			destinationTileCornerSize = configManager.getConfiguration(group, "destinationTileCornerSize", int.class);
			currentTileCornerSize = configManager.getConfiguration(group, "currentTileCornerSize", int.class);
		} else {
			trueTileFadeout = false;
			destinationTileCornersOnly = false;
			hoveredTileCornersOnly = false;
			currentTileCornersOnly = false;
		}
	}

	@Subscribe
	public void onGameTick(GameTick e)
	{
		WorldPoint playerPos = client.getLocalPlayer().getWorldLocation();

		if (!playerPos.equals(lastPlayerPosition))
		{
			lastTickPlayerMoved = client.getTickCount();
		}
		else if (lastTickPlayerMoved + 1 == client.getTickCount())
		{
			lastTimePlayerStoppedMoving = System.currentTimeMillis();
		}

		lastPlayerPosition = playerPos;
	}
}

/*
 * Copyright (c) 2018, Tomas Slusny <slusnucky@gmail.com>
 * Copyright (c) 2018, Adam <Adam@sigterm.info>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.rainbowrave;

import com.google.common.base.Strings;
import com.google.gson.Gson;
import com.google.gson.reflect.TypeToken;
import java.awt.Color;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.stream.Collectors;
import javax.annotation.Nullable;
import javax.inject.Inject;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.DecorativeObject;
import net.runelite.api.GameObject;
import net.runelite.api.GameState;
import net.runelite.api.GroundObject;
import net.runelite.api.MenuAction;
import net.runelite.api.ObjectComposition;
import net.runelite.api.Scene;
import net.runelite.api.Tile;
import net.runelite.api.TileObject;
import net.runelite.api.WallObject;
import net.runelite.api.WorldView;
import net.runelite.api.coords.WorldPoint;
import net.runelite.api.events.DecorativeObjectDespawned;
import net.runelite.api.events.DecorativeObjectSpawned;
import net.runelite.api.events.GameObjectDespawned;
import net.runelite.api.events.GameObjectSpawned;
import net.runelite.api.events.GameStateChanged;
import net.runelite.api.events.GroundObjectDespawned;
import net.runelite.api.events.GroundObjectSpawned;
import net.runelite.api.events.MenuOptionClicked;
import net.runelite.api.events.WallObjectDespawned;
import net.runelite.api.events.WallObjectSpawned;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.plugins.objectindicators.ObjectIndicatorsConfig;
import net.runelite.client.ui.overlay.OverlayManager;

@Slf4j
public class RainbowRaveObjectIndicatorsPlugin
{
	private static final String CONFIG_GROUP = "objectindicators";
	private static final String MARK = "Mark object";
	private static final String UNMARK = "Unmark object";

	private final List<ColorTileObject> objects = new ArrayList<>();
	private final List<ColorTileObject> allObjects = new ArrayList<>();
	private final Map<Integer, Set<ObjectPoint>> points = new HashMap<>();

	@Inject
	private Client client;

	@Inject
	private ConfigManager configManager;

	@Inject
	private OverlayManager overlayManager;

	@Inject
	private ObjectIndicatorsConfig config;

	@Inject
	private Gson gson;

	@Inject
	private RainbowRaveConfig rainbowRaveConfig;

	@Inject
	private ClientThread clientThread;

	protected void startUp()
	{
	}

	protected void shutDown()
	{
		points.clear();
		objects.clear();
		allObjects.clear();
	}

	@Subscribe
	public void onWallObjectSpawned(WallObjectSpawned event)
	{
		checkObjectPoints(event.getWallObject());
	}

	@Subscribe
	public void onWallObjectDespawned(WallObjectDespawned event)
	{
		objects.removeIf(o -> o.getTileObject() == event.getWallObject());
		allObjects.removeIf(o -> o.getTileObject() == event.getWallObject());
	}

	@Subscribe
	public void onGameObjectSpawned(GameObjectSpawned event)
	{
		checkObjectPoints(event.getGameObject());
	}

	@Subscribe
	public void onDecorativeObjectSpawned(DecorativeObjectSpawned event)
	{
		checkObjectPoints(event.getDecorativeObject());
	}

	@Subscribe
	public void onGameObjectDespawned(GameObjectDespawned event)
	{
		objects.removeIf(o -> o.getTileObject() == event.getGameObject());
		allObjects.removeIf(o -> o.getTileObject() == event.getGameObject());
	}

	@Subscribe
	public void onDecorativeObjectDespawned(DecorativeObjectDespawned event)
	{
		objects.removeIf(o -> o.getTileObject() == event.getDecorativeObject());
		allObjects.removeIf(o -> o.getTileObject() == event.getDecorativeObject());
	}

	@Subscribe
	public void onGroundObjectSpawned(GroundObjectSpawned event)
	{
		checkObjectPoints(event.getGroundObject());
	}

	@Subscribe
	public void onGroundObjectDespawned(GroundObjectDespawned event)
	{
		objects.removeIf(o -> o.getTileObject() == event.getGroundObject());
		allObjects.removeIf(o -> o.getTileObject() == event.getGroundObject());
	}

	@Subscribe
	public void onGameStateChanged(GameStateChanged gameStateChanged)
	{
		GameState gameState = gameStateChanged.getGameState();
		if (gameState == GameState.LOADING)
		{
			// Reload points with new map regions

			points.clear();
			for (int regionId : client.getTopLevelWorldView().getMapRegions())
			{
				// load points for region
				final Set<ObjectPoint> regionPoints = loadPoints(regionId);
				if (regionPoints != null)
				{
					points.put(regionId, regionPoints);
				}
			}
		}

		if (gameStateChanged.getGameState() != GameState.LOGGED_IN && gameStateChanged.getGameState() != GameState.CONNECTION_LOST)
		{
			allObjects.clear();
			objects.clear();
		}
	}

	@Subscribe
	public void onMenuOptionClicked(MenuOptionClicked event)
	{
		if (event.getMenuAction() != MenuAction.RUNELITE
			|| !(event.getMenuOption().equals(MARK) || event.getMenuOption().equals(UNMARK)))
		{
			return;
		}

		WorldView wv = client.getTopLevelWorldView();
		Scene scene = wv.getScene();
		Tile[][][] tiles = scene.getTiles();
		final int x = event.getParam0();
		final int y = event.getParam1();
		final int z = wv.getPlane();
		final Tile tile = tiles[z][x][y];

		TileObject object = findTileObject(tile, event.getId());
		if (object == null)
		{
			return;
		}

		// object.getId() is always the base object id, getObjectComposition transforms it to
		// the correct object we see
		ObjectComposition objectDefinition = getObjectComposition(object.getId());
		String name = objectDefinition.getName();
		// Name is probably never "null" - however prevent adding it if it is, as it will
		// become ambiguous as objects with no name are assigned name "null"
		if (Strings.isNullOrEmpty(name) || name.equals("null"))
		{
			return;
		}

		markObject(objectDefinition, name, object);
	}

	private void checkObjectPoints(TileObject object)
	{
		final WorldPoint worldPoint = WorldPoint.fromLocalInstance(client, object.getLocalLocation(), object.getPlane());
		final Set<ObjectPoint> objectPoints = points.get(worldPoint.getRegionID());

		if (objectPoints == null && rainbowRaveConfig.whichObjectsToHighlight() != RainbowRaveConfig.ObjectsToHighlight.ALL)
		{
			return;
		}

		ObjectComposition objectComposition = client.getObjectDefinition(object.getId());
		if (objectComposition.getImpostorIds() == null)
		{
			// Multiloc names are instead checked in the overlay
			String name = objectComposition.getName();
			if (Strings.isNullOrEmpty(name) || name.equals("null"))
			{
				// was marked, but name has changed
				return;
			}
		}

		boolean found = false;
		if (objectPoints != null)
		{
			for (ObjectPoint objectPoint : objectPoints)
			{
				if (worldPoint.getRegionX() == objectPoint.getRegionX()
					&& worldPoint.getRegionY() == objectPoint.getRegionY()
					&& worldPoint.getPlane() == objectPoint.getZ()
					&& objectPoint.getId() == object.getId())
				{
					log.debug("Marking object {} due to matching {}", object, objectPoint);
					objects.add(new ColorTileObject(object,
						objectComposition,
						objectPoint.getName(),
						objectPoint.getColor()));
					found = true;
					break;
				}
			}
		}

		if (!found && rainbowRaveConfig.whichObjectsToHighlight() == RainbowRaveConfig.ObjectsToHighlight.ALL) {
			allObjects.add(new ColorTileObject(object,
				objectComposition,
				"name",
				Color.WHITE));
			return;
		}
	}

	private TileObject findTileObject(Tile tile, int id)
	{
		if (tile == null)
		{
			return null;
		}

		final GameObject[] tileGameObjects = tile.getGameObjects();
		final DecorativeObject tileDecorativeObject = tile.getDecorativeObject();
		final WallObject tileWallObject = tile.getWallObject();
		final GroundObject groundObject = tile.getGroundObject();

		if (objectIdEquals(tileWallObject, id))
		{
			return tileWallObject;
		}

		if (objectIdEquals(tileDecorativeObject, id))
		{
			return tileDecorativeObject;
		}

		if (objectIdEquals(groundObject, id))
		{
			return groundObject;
		}

		for (GameObject object : tileGameObjects)
		{
			if (objectIdEquals(object, id))
			{
				return object;
			}
		}

		return null;
	}

	private boolean objectIdEquals(TileObject tileObject, int id)
	{
		if (tileObject == null)
		{
			return false;
		}

		if (tileObject.getId() == id)
		{
			return true;
		}

		// Menu action EXAMINE_OBJECT sends the transformed object id, not the base id, unlike
		// all of the GAME_OBJECT_OPTION actions, so check the id against the impostor ids
		final ObjectComposition comp = client.getObjectDefinition(tileObject.getId());

		if (comp.getImpostorIds() != null)
		{
			for (int impostorId : comp.getImpostorIds())
			{
				if (impostorId == id)
				{
					return true;
				}
			}
		}

		return false;
	}

	/** mark or unmark an object
	 *
	 * @param objectComposition transformed composition of object based on vars
	 * @param name name of objectComposition
	 * @param object tile object, for multilocs object.getId() is the base id
	 */
	private void markObject(ObjectComposition objectComposition, String name, final TileObject object)
	{
		final WorldPoint worldPoint = WorldPoint.fromLocalInstance(client, object.getLocalLocation());
		final int regionId = worldPoint.getRegionID();
		final Color color = config.markerColor();
		final ObjectPoint point = new ObjectPoint(
			object.getId(),
			name,
			regionId,
			worldPoint.getRegionX(),
			worldPoint.getRegionY(),
			worldPoint.getPlane(),
			color);

		Set<ObjectPoint> objectPoints = points.computeIfAbsent(regionId, k -> new HashSet<>());

		if (objects.removeIf(o -> o.getTileObject() == object))
		{
			// Find the object point that caused this object to be marked, there are two cases:
			// 1) object is a multiloc, the name may have changed since marking - match from base id
			// 2) not a multiloc, but an object has spawned with an identical name and a different
			//    id as what was originally marked
			if (!objectPoints.removeIf(op -> ((op.getId() == -1 || op.getId() == object.getId()) || op.getName().equals(objectComposition.getName()))
				&& op.getRegionX() == worldPoint.getRegionX()
				&& op.getRegionY() == worldPoint.getRegionY()
				&& op.getZ() == worldPoint.getPlane()))
			{
				log.warn("unable to find object point for unmarked object {}", object.getId());
			}

			log.debug("Unmarking object: {}", point);

			allObjects.add(new ColorTileObject(object,
				objectComposition,
				"name",
				Color.WHITE));
		}
		else
		{
			objectPoints.add(point);
			ColorTileObject o = new ColorTileObject(object,
				client.getObjectDefinition(object.getId()),
				name,
				color);
			objects.add(o);
			allObjects.removeIf(allO -> allO.getTileObject().equals(o.getTileObject()));
			log.debug("Marking object: {}", point);
		}
	}

	private Set<ObjectPoint> loadPoints(final int id)
	{
		final String json = configManager.getConfiguration(CONFIG_GROUP, "region_" + id);

		if (Strings.isNullOrEmpty(json))
		{
			return null;
		}

		Set<ObjectPoint> points = gson.fromJson(json, new TypeToken<Set<ObjectPoint>>()
		{
		}.getType());
		// Prior to multiloc support the plugin would mark objects named "null", which breaks
		// in most cases due to the specific object being identified being ambiguous, so remove
		// them
		return points.stream()
			.filter(point -> !point.getName().equals("null"))
			.collect(Collectors.toSet());
	}

	@Nullable
	private ObjectComposition getObjectComposition(int id)
	{
		ObjectComposition objectComposition = client.getObjectDefinition(id);
		return objectComposition.getImpostorIds() == null ? objectComposition : objectComposition.getImpostor();
	}

	public List<ColorTileObject> getObjects() {
		if (rainbowRaveConfig.whichObjectsToHighlight() == RainbowRaveConfig.ObjectsToHighlight.NONE) return Collections.emptyList();
		else if (rainbowRaveConfig.whichObjectsToHighlight() == RainbowRaveConfig.ObjectsToHighlight.SAME) return objects;

		ArrayList<ColorTileObject> combinedObjects = new ArrayList<>(allObjects);
		combinedObjects.addAll(objects);
		return combinedObjects;
	}
}
/*
 * Copyright (c) 2018, TheLonelyDev <https://github.com/TheLonelyDev>
 * Copyright (c) 2018, Adam <Adam@sigterm.info>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.rainbowrave;

import java.awt.Color;
import javax.annotation.Nullable;
import lombok.EqualsAndHashCode;
import lombok.Value;

/**
 * Used for serialization of ground marker points.
 */
@Value
@EqualsAndHashCode(exclude = { "color", "label" })
class GroundMarkerPoint
{
	private int regionId;
	private int regionX;
	private int regionY;
	private int z;
	@Nullable
	private Color color;
	@Nullable
	private String label;
}

/*
 * Copyright (c) 2018, Tomas Slusny <slusnucky@gmail.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.rainbowrave;

import com.google.common.base.Strings;
import com.google.common.cache.CacheLoader;
import java.util.List;
import java.util.Objects;
import java.util.stream.Collectors;
import javax.annotation.Nonnull;
import net.runelite.client.util.WildcardMatcher;

class WildcardMatchLoader extends CacheLoader<NamedQuantity, Boolean>
{
	private final List<ItemThreshold> itemThresholds;

	WildcardMatchLoader(List<String> configEntries)
	{
		this.itemThresholds = configEntries.stream()
			.map(ItemThreshold::fromConfigEntry)
			.filter(Objects::nonNull)
			.collect(Collectors.toList());
	}

	@Override
	public Boolean load(@Nonnull final NamedQuantity key)
	{
		if (Strings.isNullOrEmpty(key.getName()))
		{
			return false;
		}

		final String filteredName = key.getName().trim();

		for (final ItemThreshold entry : itemThresholds)
		{
			if (WildcardMatcher.matches(entry.getItemName(), filteredName)
				&& entry.quantityHolds(key.getQuantity()))
			{
				return true;
			}
		}

		return false;
	}
}

/*
 * Copyright (c) 2020, dekvall <https://github.com/dekvall>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.rainbowrave;

import java.awt.Color;
import lombok.RequiredArgsConstructor;
import lombok.Value;
import net.runelite.api.ObjectComposition;
import net.runelite.api.TileObject;

/**
 * Used to denote marked objects and their colors.
 * Note: This is not used for serialization of object indicators; see {@link ObjectPoint}
 */
@Value
@RequiredArgsConstructor
class ColorTileObject
{
	private final TileObject tileObject;
	/**
	 * Non-transformed object composition for the object
	 */
	private final ObjectComposition composition;
	/**
	 * Name to highlight for multilocs
	 */
	private final String name;
	private final Color color;
}

/*
 * Copyright (c) 2018, Woox <https://github.com/wooxsolo>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.rainbowrave;

import java.util.ArrayList;
import java.util.List;
import lombok.Getter;
import lombok.Setter;
import net.runelite.api.NPC;
import net.runelite.api.NPCComposition;
import net.runelite.api.WorldView;
import net.runelite.api.coords.WorldPoint;

class MemorizedNpc
{
	@Getter
	private int npcIndex;

	@Getter
	private WorldView worldView;

	@Getter
	private String npcName;

	@Getter
	private int npcSize;

	/**
	 * The time the npc died at, in game ticks, relative to the tick counter
	 */
	@Getter
	@Setter
	private int diedOnTick;

	/**
	 * The time it takes for the npc to respawn, in game ticks
	 */
	@Getter
	@Setter
	private int respawnTime;

	@Getter
	@Setter
	private List<WorldPoint> possibleRespawnLocations;

	MemorizedNpc(NPC npc)
	{
		this.npcName = npc.getName();
		this.npcIndex = npc.getIndex();
		this.worldView = npc.getWorldView();
		this.possibleRespawnLocations = new ArrayList<>();
		this.respawnTime = -1;
		this.diedOnTick = -1;

		final NPCComposition composition = npc.getTransformedComposition();

		if (composition != null)
		{
			this.npcSize = composition.getSize();
		}
	}
}
/*
 * Copyright (c) 2018, James Swindle <wilingua@gmail.com>
 * Copyright (c) 2018, Adam <Adam@sigterm.info>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.rainbowrave;

import com.google.common.annotations.VisibleForTesting;
import com.google.common.base.MoreObjects;
import java.awt.Color;
import java.time.Instant;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.function.Function;
import java.util.function.Predicate;
import javax.inject.Inject;
import lombok.AccessLevel;
import lombok.Builder;
import lombok.Getter;
import lombok.NonNull;
import lombok.Value;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.GameState;
import net.runelite.api.GraphicID;
import net.runelite.api.GraphicsObject;
import net.runelite.api.MenuAction;
import net.runelite.api.NPC;
import net.runelite.api.NPCComposition;
import net.runelite.api.WorldView;
import net.runelite.api.coords.WorldPoint;
import net.runelite.api.events.GameStateChanged;
import net.runelite.api.events.GameTick;
import net.runelite.api.events.GraphicsObjectCreated;
import net.runelite.api.events.MenuOptionClicked;
import net.runelite.api.events.NpcChanged;
import net.runelite.api.events.NpcDespawned;
import net.runelite.api.events.NpcSpawned;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.events.ConfigChanged;
import net.runelite.client.game.NpcUtil;
import net.runelite.client.plugins.npchighlight.NpcIndicatorsConfig;
import net.runelite.client.ui.overlay.OverlayManager;
import net.runelite.client.util.Text;
import net.runelite.client.util.WildcardMatcher;

@Slf4j
public class RainbowRaveNpcIndicatorsPlugin
{
	private static final int MAX_ACTOR_VIEW_RANGE = 15;

	// Option added to NPC menu
	private static final String TAG = "Tag";
	private static final String UNTAG = "Un-tag";

	private static final String TAG_ALL = "Tag-All";
	private static final String UNTAG_ALL = "Un-tag-All";

	private static final String STYLE_HULL = "hull";
	private static final String STYLE_TILE = "tile";
	private static final String STYLE_TRUE_TILE = "truetile";
	private static final String STYLE_SW_TILE = "swtile";
	private static final String STYLE_SW_TRUE_TILE = "swtruetile";
	private static final String STYLE_OUTLINE = "outline";

	@Inject private Client client;
	@Inject private NpcIndicatorsConfig config;
	@Inject private OverlayManager overlayManager;
	@Inject private ClientThread clientThread;
	@Inject private NpcUtil npcUtil;
	@Inject private ConfigManager configManager;

	/**
	 * NPCs to highlight
	 */
	@Getter(AccessLevel.PACKAGE)
	private final Map<NPC, HighlightedNpc> highlightedNpcs = new HashMap<>();

	/**
	 * Dead NPCs that should be displayed with a respawn indicator if the config is on.
	 */
	@Getter(AccessLevel.PACKAGE)
	private final Map<Integer, MemorizedNpc> deadNpcsToDisplay = new HashMap<>();

	/**
	 * The time when the last game tick event ran.
	 */
	@Getter(AccessLevel.PACKAGE)
	private Instant lastTickUpdate;

	/**
	 * Tagged NPCs that have died at some point, which are memorized to
	 * remember when and where they will respawn
	 */
	private final Map<Integer, MemorizedNpc> memorizedNpcs = new HashMap<>();

	/**
	 * Highlight strings from the configuration
	 */
	private List<String> highlights = new ArrayList<>();

	/**
	 * NPC ids marked with the Tag option
	 */
	private final Set<Integer> npcTags = new HashSet<>();

	/**
	 * Tagged NPCs that spawned this tick, which need to be verified that
	 * they actually spawned and didn't just walk into view range.
	 */
	private final List<NPC> spawnedNpcsThisTick = new ArrayList<>();

	/**
	 * Tagged NPCs that despawned this tick, which need to be verified that
	 * they actually spawned and didn't just walk into view range.
	 */
	private final List<NPC> despawnedNpcsThisTick = new ArrayList<>();

	/**
	 * World locations of graphics object which indicate that an
	 * NPC teleported that were played this tick.
	 */
	private final Set<WorldPoint> teleportGraphicsObjectSpawnedThisTick = new HashSet<>();

	/**
	 * The players location on the last game tick.
	 */
	private WorldPoint lastPlayerLocation;

	/**
	 * When hopping worlds, NPCs can spawn without them actually respawning,
	 * so we would not want to mark it as a real spawn in those cases.
	 */
	private boolean skipNextSpawnCheck = false;

	private final List<Function<NPC, HighlightedNpc>> higlightPredicates = new ArrayList<>();

	protected void startUp()
	{
		clientThread.invoke(() ->
		{
			skipNextSpawnCheck = true;
			rebuild();
		});
	}

	protected void shutDown()
	{
		clientThread.invoke(() ->
		{
			deadNpcsToDisplay.clear();
			memorizedNpcs.clear();
			spawnedNpcsThisTick.clear();
			despawnedNpcsThisTick.clear();
			teleportGraphicsObjectSpawnedThisTick.clear();
			npcTags.clear();
			highlightedNpcs.clear();
		});
	}

	@Subscribe
	public void onGameStateChanged(GameStateChanged event)
	{
		if (event.getGameState() == GameState.LOGIN_SCREEN ||
			event.getGameState() == GameState.HOPPING)
		{
			highlightedNpcs.clear();
			deadNpcsToDisplay.clear();
			memorizedNpcs.forEach((id, npc) -> npc.setDiedOnTick(-1));
			lastPlayerLocation = null;
			skipNextSpawnCheck = true;
		}
	}

	@Subscribe
	public void onConfigChanged(ConfigChanged configChanged)
	{
		if (!configChanged.getGroup().equals(NpcIndicatorsConfig.GROUP))
		{
			return;
		}

		clientThread.invoke(this::rebuild);
	}

	@Subscribe
	public void onMenuOptionClicked(MenuOptionClicked click)
	{
		if (click.getMenuAction() != MenuAction.RUNELITE ||
			!(click.getMenuOption().equals(TAG) || click.getMenuOption().equals(UNTAG) ||
				click.getMenuOption().equals(TAG_ALL) || click.getMenuOption().equals(UNTAG_ALL)))
		{
			return;
		}

		WorldView worldView = client.getTopLevelWorldView();
		final int id = click.getId();
		final NPC npc = worldView.npcs().byIndex(id);

		if (npc == null || npc.getName() == null)
		{
			return;
		}

		if (click.getMenuOption().equals(TAG) || click.getMenuOption().equals(UNTAG))
		{
			final boolean removed = npcTags.remove(id);

			if (removed)
			{
				if (!highlightMatchesNPCName(npc.getName()))
				{
					highlightedNpcs.remove(npc);
					memorizedNpcs.remove(npc.getIndex());
				}
			}
			else
			{
				if (!worldView.isInstance())
				{
					memorizeNpc(npc);
					npcTags.add(id);
				}
				highlightedNpcs.put(npc, highlightedNpc(npc));
			}
		}
	}

	@Subscribe
	public void onNpcSpawned(NpcSpawned npcSpawned)
	{
		final NPC npc = npcSpawned.getNpc();
		final String npcName = npc.getName();

		if (npcName == null)
		{
			return;
		}

		if (npcTags.contains(npc.getIndex()))
		{
			memorizeNpc(npc);
			highlightedNpcs.put(npc, highlightedNpc(npc));
			spawnedNpcsThisTick.add(npc);
			return;
		}

		WorldView worldView = client.getTopLevelWorldView();
		if (highlightMatchesNPCName(npcName))
		{
			highlightedNpcs.put(npc, highlightedNpc(npc));
			if (!worldView.isInstance())
			{
				memorizeNpc(npc);
				spawnedNpcsThisTick.add(npc);
			}
			return;
		}

		for (Function<NPC, HighlightedNpc> predicate : higlightPredicates)
		{
			HighlightedNpc highlightedNpc = predicate.apply(npc);
			if (highlightedNpc != null)
			{
				highlightedNpcs.put(npc, highlightedNpc);
				if (!worldView.isInstance())
				{
					memorizeNpc(npc);
					spawnedNpcsThisTick.add(npc);
				}
				return;
			}
		}

	}

	@Subscribe
	public void onNpcDespawned(NpcDespawned npcDespawned)
	{
		final NPC npc = npcDespawned.getNpc();

		if (memorizedNpcs.containsKey(npc.getIndex()))
		{
			despawnedNpcsThisTick.add(npc);
		}

		highlightedNpcs.remove(npc);
	}

	@Subscribe
	public void onNpcChanged(NpcChanged event)
	{
		final NPC npc = event.getNpc();
		final String npcName = npc.getName();

		highlightedNpcs.remove(npc);

		if (npcName == null)
		{
			return;
		}

		if (npcTags.contains(npc.getIndex())
			|| highlightMatchesNPCName(npcName))
		{
			highlightedNpcs.put(npc, highlightedNpc(npc));
			return;
		}

		for (Function<NPC, HighlightedNpc> predicate : higlightPredicates)
		{
			HighlightedNpc highlightedNpc = predicate.apply(npc);
			if (highlightedNpc != null)
			{
				highlightedNpcs.put(npc, highlightedNpc);
				return;
			}
		}
	}

	@Subscribe
	public void onGraphicsObjectCreated(GraphicsObjectCreated event)
	{
		final GraphicsObject go = event.getGraphicsObject();

		if (go.getId() == GraphicID.GREY_BUBBLE_TELEPORT)
		{
			teleportGraphicsObjectSpawnedThisTick.add(WorldPoint.fromLocal(client, go.getLocation()));
		}
	}

	@Subscribe
	public void onGameTick(GameTick event)
	{
		removeOldHighlightedRespawns();
		validateSpawnedNpcs();
		lastTickUpdate = Instant.now();
		lastPlayerLocation = client.getLocalPlayer().getWorldLocation();
	}

	private static boolean isInViewRange(WorldPoint wp1, WorldPoint wp2)
	{
		int distance = wp1.distanceTo(wp2);
		return distance < MAX_ACTOR_VIEW_RANGE;
	}

	private static WorldPoint getWorldLocationBehind(NPC npc)
	{
		final int orientation = npc.getOrientation() / 256;
		int dx = 0, dy = 0;

		switch (orientation)
		{
			case 0: // South
				dy = -1;
				break;
			case 1: // Southwest
				dx = -1;
				dy = -1;
				break;
			case 2: // West
				dx = -1;
				break;
			case 3: // Northwest
				dx = -1;
				dy = 1;
				break;
			case 4: // North
				dy = 1;
				break;
			case 5: // Northeast
				dx = 1;
				dy = 1;
				break;
			case 6: // East
				dx = 1;
				break;
			case 7: // Southeast
				dx = 1;
				dy = -1;
				break;
		}

		final WorldPoint currWP = npc.getWorldLocation();
		return new WorldPoint(currWP.getX() - dx, currWP.getY() - dy, currWP.getPlane());
	}

	private void memorizeNpc(NPC npc)
	{
		final int npcIndex = npc.getIndex();
		memorizedNpcs.putIfAbsent(npcIndex, new MemorizedNpc(npc));
	}

	private void removeOldHighlightedRespawns()
	{
		deadNpcsToDisplay.values().removeIf(x -> x.getDiedOnTick() + x.getRespawnTime() <= client.getTickCount() + 1);
	}

	@VisibleForTesting
	List<String> getHighlights()
	{
		final String configNpcs = config.getNpcToHighlight();

		if (configNpcs.isEmpty())
		{
			return Collections.emptyList();
		}

		return Text.fromCSV(configNpcs);
	}

	public void rebuild()
	{
		highlights = getHighlights();
		highlightedNpcs.clear();

		if (client.getGameState() != GameState.LOGGED_IN &&
			client.getGameState() != GameState.LOADING)
		{
			// NPCs are still in the client after logging out,
			// but we don't want to highlight those.
			return;
		}

		WorldView worldView = client.getTopLevelWorldView();
		outer:
		for (NPC npc : worldView.npcs())
		{
			final String npcName = npc.getName();

			if (npcName == null)
			{
				continue;
			}

			if (npcTags.contains(npc.getIndex()))
			{
				highlightedNpcs.put(npc, highlightedNpc(npc));
				continue;
			}

			if (highlightMatchesNPCName(npcName))
			{
				if (!worldView.isInstance())
				{
					memorizeNpc(npc);
				}
				highlightedNpcs.put(npc, highlightedNpc(npc));
				continue;
			}

			for (Function<NPC, HighlightedNpc> predicate : higlightPredicates)
			{
				HighlightedNpc highlightedNpc = predicate.apply(npc);
				if (highlightedNpc != null)
				{
					if (!worldView.isInstance())
					{
						memorizeNpc(npc);
					}
					highlightedNpcs.put(npc, highlightedNpc);
					continue outer;
				}
			}

			// NPC is not highlighted
			memorizedNpcs.remove(npc.getIndex());
		}
	}

	private boolean highlightMatchesNPCName(String npcName)
	{
		for (String highlight : highlights)
		{
			if (WildcardMatcher.matches(highlight, npcName))
			{
				return true;
			}
		}

		return false;
	}

	private void validateSpawnedNpcs()
	{
		if (skipNextSpawnCheck)
		{
			skipNextSpawnCheck = false;
		}
		else
		{
			for (NPC npc : despawnedNpcsThisTick)
			{
				if (!teleportGraphicsObjectSpawnedThisTick.isEmpty())
				{
					if (teleportGraphicsObjectSpawnedThisTick.contains(npc.getWorldLocation()))
					{
						// NPC teleported away, so we don't want to add the respawn timer
						continue;
					}
				}

				if (isInViewRange(client.getLocalPlayer().getWorldLocation(), npc.getWorldLocation()))
				{
					final MemorizedNpc mn = memorizedNpcs.get(npc.getIndex());

					if (mn != null)
					{
						mn.setDiedOnTick(client.getTickCount() + 1); // This runs before tickCounter updates, so we add 1

						if (!mn.getPossibleRespawnLocations().isEmpty())
						{
							log.debug("Starting {} tick countdown for {}", mn.getRespawnTime(), mn.getNpcName());
							deadNpcsToDisplay.put(mn.getNpcIndex(), mn);
						}
					}
				}
			}

			for (NPC npc : spawnedNpcsThisTick)
			{
				if (!teleportGraphicsObjectSpawnedThisTick.isEmpty())
				{
					if (teleportGraphicsObjectSpawnedThisTick.contains(npc.getWorldLocation()) ||
						teleportGraphicsObjectSpawnedThisTick.contains(getWorldLocationBehind(npc)))
					{
						// NPC teleported here, so we don't want to update the respawn timer
						continue;
					}
				}

				if (lastPlayerLocation != null && isInViewRange(lastPlayerLocation, npc.getWorldLocation()))
				{
					final MemorizedNpc mn = memorizedNpcs.get(npc.getIndex());

					if (mn.getDiedOnTick() != -1)
					{
						final int respawnTime = client.getTickCount() + 1 - mn.getDiedOnTick();

						// By killing a monster and leaving the area before seeing it again, an erroneously lengthy
						// respawn time can be recorded. Thus, if the respawn time is already set and is greater than
						// the observed time, assume that the lower observed respawn time is correct.
						if (mn.getRespawnTime() == -1 || respawnTime < mn.getRespawnTime())
						{
							mn.setRespawnTime(respawnTime);
						}

						mn.setDiedOnTick(-1);
					}

					final WorldPoint npcLocation = npc.getWorldLocation();

					// An NPC can move in the same tick as it spawns, so we also have
					// to consider whatever tile is behind the npc
					final WorldPoint possibleOtherNpcLocation = getWorldLocationBehind(npc);

					mn.getPossibleRespawnLocations().removeIf(x ->
						!x.equals(npcLocation) && !x.equals(possibleOtherNpcLocation));

					if (mn.getPossibleRespawnLocations().isEmpty())
					{
						mn.getPossibleRespawnLocations().add(npcLocation);
						mn.getPossibleRespawnLocations().add(possibleOtherNpcLocation);
					}
				}
			}
		}

		spawnedNpcsThisTick.clear();
		despawnedNpcsThisTick.clear();
		teleportGraphicsObjectSpawnedThisTick.clear();
	}

	@Value
	@Builder
	public static class HighlightedNpc
	{
		NPC npc;
		@NonNull
		Color highlightColor;
		@Builder.Default
		Color fillColor = new Color(0, 0, 0, 50);
		boolean hull;
		boolean tile;
		boolean trueTile;
		boolean swTile;
		boolean swTrueTile;
		boolean outline;
		boolean name;
		boolean nameOnMinimap;
		@Builder.Default
		float borderWidth = 2.0f;
		int outlineFeather;
		Predicate<NPC> render;
	}

	public HighlightedNpc highlightedPlayer()
	{
		return HighlightedNpc.builder()
			.highlightColor(config.highlightColor())
			.fillColor(config.fillColor())
			.hull(config.highlightHull())
			.tile(config.highlightTile())
			.trueTile(config.highlightTrueTile())
			.swTile(config.highlightSouthWestTile())
			.swTrueTile(config.highlightSouthWestTrueTile())
			.outline(config.highlightOutline())
			.name(config.drawNames())
			.nameOnMinimap(config.drawMinimapNames())
			.borderWidth((float) config.borderWidth())
			.outlineFeather(config.outlineFeather())
			.render(this::render)
			.build();
	}

	public HighlightedNpc highlightedNpc(NPC npc)
	{
		final int npcId = npc.getId();

		final String style = getNpcTagStyle(npcId);
		final boolean hull, tile, trueTile, swTile, swTrueTile, outline;
		// if set, value from config overrides global config
		if (style != null)
		{
			hull = STYLE_HULL.equals(style);
			tile = STYLE_TILE.equals(style);
			trueTile = STYLE_TRUE_TILE.equals(style);
			swTile = STYLE_SW_TILE.equals(style);
			swTrueTile = STYLE_SW_TRUE_TILE.equals(style);
			outline = STYLE_OUTLINE.equals(style);
		}
		else
		{
			hull = config.highlightHull();
			tile = config.highlightTile();
			trueTile = config.highlightTrueTile();
			swTile = config.highlightSouthWestTile();
			swTrueTile = config.highlightSouthWestTrueTile();
			outline = config.highlightOutline();
		}

		return HighlightedNpc.builder()
			.npc(npc)
			.highlightColor(MoreObjects.firstNonNull(getNpcHighlightColor(npcId), config.highlightColor()))
			.fillColor(config.fillColor())
			.hull(hull)
			.tile(tile)
			.trueTile(trueTile)
			.swTile(swTile)
			.swTrueTile(swTrueTile)
			.outline(outline)
			.name(config.drawNames())
			.nameOnMinimap(config.drawMinimapNames())
			.borderWidth((float) config.borderWidth())
			.outlineFeather(config.outlineFeather())
			.render(this::render)
			.build();
	}

	private boolean render(NPC n)
	{
		if (npcUtil.isDying(n) && config.ignoreDeadNpcs())
		{
			return false;
		}

		final NPCComposition c = n.getTransformedComposition();
		if (c != null && c.isFollower() && config.ignorePets())
		{
			return false;
		}

		return true;
	}

	private Color getNpcHighlightColor(int npcId)
	{
		return configManager.getConfiguration(NpcIndicatorsConfig.GROUP, "highlightcolor_" + npcId, Color.class);
	}

	private String getNpcTagStyle(int npcId)
	{
		return configManager.getConfiguration(NpcIndicatorsConfig.GROUP, "tagstyle_" + npcId);
	}

	public void registerHighlighter(Function<NPC, HighlightedNpc> p)
	{
		higlightPredicates.add(p);
	}

	public void unregisterHighlighter(Function<NPC, HighlightedNpc> p)
	{
		higlightPredicates.remove(p);
	}
}

package com.rainbowrave;

//import lombok.Builder;

public class ConfigGenerator
{
//	private static final boolean autoPosition = true;
//
//	private static int i = 0;
//
//	public static void main(String[] args)
//	{
//		System.out.println(
//			SingleConfigGenerator.builder()
//				.key("colorSpeed")
//				.name("Color speed (ms)")
//				.description("How fast the colors change (ms per full cycle)")
//				.defaultValue(6000)
//				.typeName("int")
//				.build().generate()
//		);
//
//		System.out.println(
//		SingleConfigGenerator.builder()
//			.key("syncColor")
//			.name("Sync colors")
//			.description("Make all highlighted things be the same color as each other.")
//			.defaultValue(false)
//			.typeName("boolean")
//			.build().generate()
//		);
//
//		System.out.println(
//		SingleConfigGenerator.builder()
//			.key("highlightSelf")
//			.name("Highlight self")
//			.description("Highlight your own player character. Uses Npc Indicator's settings.")
//			.defaultValue(false)
//			.typeName("boolean")
//			.build().generate()
//		);
//
//		System.out.println(
//		SingleConfigGenerator.builder()
//			.key("highlightOthers")
//			.name("Highlight others")
//			.description("Highlight other players' characters. Uses Npc Indicator's settings.")
//			.defaultValue(false)
//			.typeName("boolean")
//			.build().generate()
//		);
//
//		System.out.println(
//		SingleConfigGenerator.builder()
//			.key("whichNpcsToHighlight")
//			.name("Npc highlight")
//			.description("Which npcs to highlight")
//			.defaultValue(RainbowRaveConfig.NpcsToHighlight.SAME)
//			.typeName("NpcsToHighlight")
//			.build().generate()
//		);
//
//		System.out.println(
//			SingleConfigGenerator.builder()
//				.key("smoothWaves")
//				.name("Tile color waves")
//				.description("Whether the tiles should have a smooth transition from color to color between two adjacent tiles.")
//				.defaultValue(false)
//				.typeName("boolean")
//				.build().generate()
//		);
//
//		System.out.println(
//			SingleConfigGenerator.builder()
//				.key("fillTiles")
//				.name("Fill tiles")
//				.description("Fills the tile with an opaque square.")
//				.defaultValue(false)
//				.typeName("boolean")
//				.build().generate()
//		);
//
//		System.out.println(
//			SingleConfigGenerator.builder()
//				.key("useBrushMarkerTiles")
//				.name("Brush Marker Tiles")
//				.description("Applies rainbow to tile markers from the \\\"Brush Markers\\\" plugin hub plugin. This plugin can be used to mark lots of tiles at once.")
//				.defaultValue(false)
//				.typeName("boolean")
//				.build().generate()
//		);
//
//		System.out.println(
//			SingleConfigGenerator.builder()
//				.key("whichObjectsToHighlight")
//				.name("Object highlight")
//				.description("Which objects to highlight.")
//				.defaultValue(RainbowRaveConfig.ObjectsToHighlight.SAME)
//				.typeName("ObjectsToHighlight")
//				.build().generate()
//		);
//
//		System.out.println(
//			SingleConfigGenerator.builder()
//				.key("whichItemsToInventoryTag")
//				.name("Inventory tags")
//				.description("Which items to tag.")
//				.defaultValue(RainbowRaveConfig.ItemsToTag.SAME)
//				.typeName("ItemsToTag")
//				.build().generate()
//		);
//
//		System.out.println(
//			SingleConfigGenerator.builder()
//				.key("colorHighlightedGroundItems")
//				.name("Highlight Ground Items")
//				.description("Applies rainbow to highlighted items.")
//				.defaultValue(true)
//				.typeName("boolean")
//				.build().generate()
//		);
//
//		System.out.println(
//			SingleConfigGenerator.builder()
//				.key("whichGroundItemsToColor")
//				.name("Ground Items")
//				.description("Items in this tier and above are colored.")
//				.defaultValue(RainbowRaveConfig.GroundItemsToColor.REGULAR)
//				.typeName("GroundItemsToColor")
//				.build().generate()
//		);
//
//		System.out.println(
//			SingleConfigGenerator.builder()
//				.key("recolorScytheSwings")
//				.name("Scythe swings")
//				.description("Recolor scythe swings. Swing trails may not return to normal after disabling.")
//				.defaultValue(false)
//				.typeName("boolean")
//				.build().generate()
//		);
//
//	}
//
//	@Builder
//	public static final class SingleConfigGenerator<T> {
//		private final String key;
//		private final String name;
//		private String description;
//		private String section;
//		private T defaultValue;
//		private String typeName;
//
//		public String generate() {
//			String n = "\n";
//			return String.format(
//					"\t@ConfigItem(" + n +
//					"\t\tkeyName = \"%s\"," + n +
//					"\t\tname = \"%s\"," + n +
//					"\t\tdescription = \"%s\"," + n +
//					(section == null ? "%s" : "\t\tsection = %s," + n) +
//					"\t\tposition = " + i++ + "" + n +
//					"\t)" + n +
//					"\tdefault " + ((typeName == null) ? defaultValue.getClass().getSimpleName() : typeName) + " %s()" + n +
//					"\t{" + n +
//					"\t\treturn %s;" + n +
//					"\t}" + n,
//				key, name, description, (section == null) ? "" : section, key, defaultValue
//			);
//		}
//	}
}

package com.rainbowrave;

import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.lang.reflect.Field;
import java.util.Properties;
import net.runelite.client.RuneLite;
import net.runelite.client.RuneLiteProperties;
import net.runelite.client.externalplugins.ExternalPluginManager;

public class ExamplePluginTest
{
	public static void main(String[] args) throws Exception
	{
		setWindowTitle("rainbow-rave (" + getCurrentGitBranch() + ") RL-" + RuneLiteProperties.getVersion());

		ExternalPluginManager.loadBuiltin(RainbowRavePlugin.class);
		RuneLite.main(args);
	}

	private static void setWindowTitle(String title) throws NoSuchFieldException, IllegalAccessException
	{
		Field propertiesField = RuneLiteProperties.class.getDeclaredField("properties");
		propertiesField.setAccessible(true);
		Properties properties = (Properties) propertiesField.get(null);
		properties.setProperty("runelite.title", title);
	}

	public static String getCurrentGitBranch() {
		try
		{
			Process process = Runtime.getRuntime().exec("git rev-parse --abbrev-ref HEAD");
			process.waitFor();

			BufferedReader reader = new BufferedReader(
				new InputStreamReader(process.getInputStream()));

			return reader.readLine();
		}catch (Exception e) {
			return "threw exception";
		}
	}
}
