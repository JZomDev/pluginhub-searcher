package com.shopprices;

import net.runelite.client.config.Alpha;
import net.runelite.client.config.Config;
import net.runelite.client.config.ConfigGroup;
import net.runelite.client.config.ConfigItem;

import java.awt.Color;

@ConfigGroup("shopprices")
public interface ShopPricesConfig extends Config {
    @ConfigItem(
        position = 0,
        keyName = "displayOverlay",
        name = "Display prices below Items",
        description = "Shows a item value below each item in the shop."
    )
    default boolean displayOverlay() {
        return true;
    }

    @ConfigItem(
        position = 1,
        keyName = "displayTooltip",
        name = "Display prices in Tooltip",
        description = "Shows a small tooltip with items total price when hovering over an item."
    )
    default boolean displayTooltip() {
        return true;
    }

    @ConfigItem(
        position = 2,
        keyName = "overlayValueColor",
        name = "Shop price color",
        description = "Sets the default item value color."
    )
    @Alpha default Color defaultOverlayColor() {
        return Color.WHITE;
    }

    @ConfigItem(
        position = 3,
        keyName = "enablePriceThreshold",
        name = "Enable price threshold",
        description = "Allows you to set a threshold for when a price reaches a certain percentage."
    )
    default boolean priceThresholdEnabled() {
        return true;
    }

    @ConfigItem(
        position = 4,
        keyName = "priceThresholdPercentage",
        name = "Threshold Percentage",
        description = "Sets the threshold percentage."
    )
    default int priceThreshold() {
        return 15;
    }

    @ConfigItem(
        position = 5,
        keyName = "priceThresholdColor",
        name = "Price threshold color",
        description = "Sets the threshold item value color."
    )
    default Color thresholdOverlayColor() {
        return new Color(221, 69, 69);
    }

    @ConfigItem(
        position = 6,
        keyName = "blockOnThreshold",
        name = "Block buy on threshold",
        description = "Blocks buying when multiplier is past threshold."
    )
    default boolean blockOnThreshold() {
        return false;
    }

    @ConfigItem(
        position = 7,
        keyName = "blockCheckQuantity",
        name = "Check buy quantity on Block",
        description = "Blocks buying if the quantity will go past threshold. (Block on Threshold needs to be ON)"
    )
    default boolean blockCheckQuantity() {
        return false;
    }
}

package com.shopprices;

import lombok.Getter;

public enum ShopQuantity {
    VALUE(0,"Value", 1),
    BUY1(1, "Buy 1", 1),
    BUY5(2,"Buy 5", 5),
    BUY10(3,"Buy 10", 10),
    BUY50(4,"Buy 50", 50);

    @Getter
    private final int id;

    @Getter
    private final String option;

    @Getter
    private final int amount;

    ShopQuantity(int id, String option, int amount) {
        this.id = id;
        this.option = option;
        this.amount = amount;
    }

    private static final ShopQuantity[] VALUES = values();

    public static ShopQuantity getById(int id) {
        for (ShopQuantity quantity : VALUES) {
            if (quantity.id == id) {
                return quantity;
            }
        }

        return ShopQuantity.VALUE;
    }
}

package com.shopprices;

import com.google.common.reflect.TypeToken;
import com.google.gson.Gson;
import com.google.inject.Provides;
import lombok.Getter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.ItemComposition;
import net.runelite.api.ScriptID;
import net.runelite.api.events.MenuOptionClicked;
import net.runelite.api.events.ScriptPreFired;
import net.runelite.api.events.VarbitChanged;
import net.runelite.api.events.WidgetClosed;
import net.runelite.api.gameval.InterfaceID;
import net.runelite.api.widgets.Widget;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.game.ItemManager;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.plugins.PluginDescriptor;
import net.runelite.client.ui.overlay.OverlayManager;
import net.runelite.client.ui.overlay.tooltip.TooltipManager;

import javax.inject.Inject;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.lang.reflect.Type;
import java.util.HashMap;
import java.util.Map;

@Slf4j
@PluginDescriptor(
    name = "Shop Prices",
    description = "Display prices for items in NPC shops.",
    tags = {"qol", "shop", "prices", "overlay"}
)
public class ShopPricesPlugin extends Plugin {
    @Inject
    private Client client;

    @Inject
    private ItemManager itemManager;

    @Inject
    private OverlayManager overlayManager;

    @Inject
    private TooltipManager tooltipManager;

    @Inject
    private ShopPricesOverlay shopPricesOverlay;

    @Getter
    @Inject
    private ShopPricesConfig config;

    @Inject
    private Gson gson;

    private static final int SHOP_SCROLL_HEIGHT = 235;
    private static final int SHOP_MAIN_INIT = 1074;
    private static final int SHOP_QUANTITY_VARP_ID = 1022;
    private static final String SHOPS_RESOURCE = "shops.json";
    private static final Type SHOP_TYPE = new TypeToken<Map<String, Shop>>(){}.getType();
    public Map<String, Shop> shopsMap = new HashMap<>();
    public Shop activeShop = null;

    @Provides
    ShopPricesConfig provideConfig(ConfigManager configManager) {
        return configManager.getConfig(ShopPricesConfig.class);
    }

    @Override
    protected void startUp() {
        InputStream stream = getClass().getClassLoader().getResourceAsStream(SHOPS_RESOURCE);

        if (stream == null) {
            throw new IllegalArgumentException("Resource not found.");
        }

        try (InputStreamReader reader = new InputStreamReader(stream)) {
            this.shopsMap = gson.fromJson(reader, SHOP_TYPE);
            this.overlayManager.add(this.shopPricesOverlay);
        } catch (IOException e) {
            log.error("Failed to read JSON file \"{}\": {}", SHOPS_RESOURCE, e.getMessage());
        }
    }

    @Override
    protected void shutDown() {
        this.overlayManager.remove(this.shopPricesOverlay);
        this.shopsMap.clear();
    }

    @Subscribe
    protected void onWidgetClosed(WidgetClosed event) {
        if (event.getGroupId() == InterfaceID.SHOPMAIN) {
            log.debug("Closing shop \"{}\".", this.activeShop.name);
            this.activeShop = null;
        }
    }

    @Subscribe
    protected void onScriptPreFired(ScriptPreFired event) {
        if (event.getScriptId() == SHOP_MAIN_INIT) {
           // [clientscript,shop_main_init](inv $inv0, string $string0, obj $obj1, int $int2, boolean $boolean3)
            String name = (String) event.getScriptEvent().getArguments()[2];
            String shopKey = Shop.formatShopName(name);

            this.activeShop = shopsMap.get(shopKey);
            this.activeShop.name = shopKey;
            log.debug("Opened shop \"{}\". ({})", name, shopKey);
        }

        Widget itemsWidget = client.getWidget(InterfaceID.Shopmain.ITEMS);

        if (itemsWidget != null && event.getScriptId() == ScriptID.UPDATE_SCROLLBAR) {
            Widget scrollbar = client.getWidget(InterfaceID.Shopmain.SCROLLBAR);

            if (scrollbar != null && scrollbar.isHidden()) {
                itemsWidget.setScrollHeight(0);
                itemsWidget.revalidateScroll();
                return;
            }

            itemsWidget.setScrollHeight(SHOP_SCROLL_HEIGHT);
            itemsWidget.revalidateScroll();
        }
    }

    @Subscribe
    protected void onVarbitChanged(VarbitChanged event) {
        // Varbit ID: 6348
        if (event.getVarpId() == SHOP_QUANTITY_VARP_ID) {
            this.activeShop.quantityOption = ShopQuantity.getById(event.getValue());
            log.debug("Shop quantity option set to \"{}\". ({})", event.getValue(), this.activeShop.quantityOption.getOption());
        }
    }

    @Subscribe
    protected void onMenuOptionClicked(MenuOptionClicked event) {
        if (this.activeShop == null) {
            return;
        }

        if (!Shop.MENU_OPTIONS.contains(event.getMenuOption())) {
            return;
        }

        if (this.config.blockOnThreshold()) {
            Widget eventWidget = event.getWidget();

            if (eventWidget == null) {
                return;
            }

            ItemComposition itemComposition = itemManager.getItemComposition(event.getItemId());
            int multiplierThreshold = this.config.priceThreshold();
            int currentStock = eventWidget.getItemQuantity();

            if (this.activeShop.isPriceAtThreshold(itemComposition, multiplierThreshold, currentStock)) {
                event.consume();
                return;
            }

            if (this.config.blockCheckQuantity() && this.activeShop.isQuantityAtThreshold(itemComposition, multiplierThreshold, currentStock)) {
                event.consume();
            }
        }
    }
}

package com.shopprices;

import com.google.common.collect.ImmutableSet;
import net.runelite.api.ItemComposition;
import net.runelite.api.MenuAction;
import net.runelite.client.util.QuantityFormatter;

import java.text.DecimalFormat;
import java.util.Map;
import java.util.Set;

public final class Shop {
    public static final Set<String> MENU_OPTIONS = ImmutableSet.of("Value", "Buy 50", "Buy 10", "Buy 5", "Buy 1");
    public static final Set<MenuAction> MENU_ACTIONS = ImmutableSet.of(
        MenuAction.CC_OP,
        MenuAction.CC_OP_LOW_PRIORITY
    );
    public static final String SHOP_KEY_PATTERN = "[^a-zA-Z ]+";
    public static final float MIN_SELL_MULTIPLIER = 30.0f;

    /** Shop's formatted name */
    String name;

    /** Shops default sell multiplier for every item */
    int sellMultiplier;

    /** A price percentage change per shops stock surplus/deficit based on default stock. */
    float shopDelta;

    /** Shops currently set quantity option, default is {@code Value}. */
    ShopQuantity quantityOption = ShopQuantity.VALUE;

    /**
     * A map of items that contains their default shop stock.
     * Items stock defaulted to {@code 0} on {@code null}.
     */
     Map<String, Integer> itemStocks;

    /**
     * Gets the map key by formatting the shops name.
     *
     * @param shopName Shops name displayed in Shop frame widget.
     * @return         Shop key for accessing a structured map.
     */
    public static String formatShopName(String shopName) {
        return String.join(
            "_",
            shopName.replaceAll(SHOP_KEY_PATTERN, "")
                .toUpperCase()
                .trim()
                .split("\\s+")
        );
    }

    /**
     * Gets RuneScape's precise decimal currency stack value.
     *
     * @param priceValue Items sell price value.
     * @see QuantityFormatter#quantityToRSDecimalStack(int, boolean)
     *
     */
    public static String getPriceValue(int priceValue) {
        return QuantityFormatter.quantityToRSDecimalStack(priceValue, true) + " gp";
    }

    /**
     * Gets the formatted string price value.
     *
     * @param priceValue Items calculated value.
     * @return           Exact price value formatted with commas.
     */
    public static String getExactPriceValue(int priceValue) {
        DecimalFormat formatter = new DecimalFormat("#,###,###,### gp");
        return formatter.format(priceValue);
    }

    /**
     * Checks if multiplier is at/past price threshold.
     *
     * @param itemComposition       Items compositions.
     * @param multiplierThreshold   Items percentage multiplier threshold.
     * @param currentStock          Items current stock in the shop.
     * @return                      {@code True} if, multipliers threshold is greater than or equal to an items current multiplier.
     */
    public boolean isPriceAtThreshold(ItemComposition itemComposition, int multiplierThreshold, int currentStock) {
        return this.sellMultiplier + multiplierThreshold <= this.getSellMultiplier(itemComposition, currentStock);
    }

    /**
     * Checks if quantity is at/past price threshold.
     *
     * @param itemComposition       Items compositions.
     * @param multiplierThreshold   Items percentage multiplier threshold.
     * @param currentStock          Items current stock in the shop.
     * @return                      {@code True} if, current quantity option will pass or is at price threshold.
     */
    public boolean isQuantityAtThreshold(ItemComposition itemComposition, int multiplierThreshold, int currentStock) {
        return isPriceAtThreshold(itemComposition, multiplierThreshold, currentStock - this.quantityOption.getAmount());
    }

    /**
     * Gets the items selling multiplier based on its current stock.
     *
     * @param itemComposition   Items compositions.
     * @param currentStock      Items current stock in the shop.
     * @return                  A percentage sell multiplier.
     */
    public float getSellMultiplier(ItemComposition itemComposition, int currentStock) {
        Integer defaultStock = this.itemStocks.get(itemComposition.getName());

        if (defaultStock == null) {
            defaultStock = 0;
        }

        int stockDelta = defaultStock - currentStock;
        return sellMultiplier + (this.shopDelta * stockDelta);
    }

    /**
     * Gets the items selling price based on its current stock.
     *
     * @param itemComposition   Items compositions.
     * @param currentStock      Items current stock in the shop.
     * @return                  Items price value when buying a single quantity.
     */
    public int getSellPrice(ItemComposition itemComposition, int currentStock) {
        int itemValue = itemComposition.getPrice();

        // TODO: Look over this equation again and confirm its validity with tests.
        return (int) Math.max(
            itemValue * this.getSellMultiplier(itemComposition, currentStock) / 100,
            Math.max(MIN_SELL_MULTIPLIER * itemValue / 100, 1)
        );
    }

    /**
     * Gets the items selling price based on its current stock and amount being bought.
     *
     * @param itemComposition   Items compositions.
     * @param currentStock      Items current stock in the shop.
     * @param buyAmount         Amount of items being bought.
     * @return                  Items total price value when buying X quantity.
     */
    public int getSellPriceTotal(ItemComposition itemComposition, int currentStock, int buyAmount) {
        int totalCost = 0;

        for (int amount = 0; amount < buyAmount; amount++) {
            int stockDelta = currentStock - amount;
            totalCost += this.getSellPrice(itemComposition, stockDelta);
        }

        return totalCost;
    }
}
package com.shopprices;

import com.google.common.collect.ImmutableSet;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.ItemComposition;
import net.runelite.api.ItemContainer;
import net.runelite.api.MenuAction;
import net.runelite.api.MenuEntry;
import net.runelite.api.gameval.InterfaceID;
import net.runelite.api.gameval.InventoryID;
import net.runelite.api.gameval.ItemID;
import net.runelite.api.widgets.WidgetItem;
import net.runelite.client.game.ItemManager;
import net.runelite.client.ui.overlay.WidgetItemOverlay;
import net.runelite.client.ui.overlay.tooltip.Tooltip;
import net.runelite.client.ui.overlay.tooltip.TooltipManager;
import net.runelite.client.util.ColorUtil;

import javax.inject.Inject;
import java.awt.Graphics2D;
import java.awt.Rectangle;
import java.awt.Color;
import java.util.Set;

@Slf4j
public class ShopPricesOverlay extends WidgetItemOverlay {
    private static final int PRICE_PADDING = 10;
    private static final int WIDTH_CLIP_PADDING = 10;
    private static final int INVENTORY_SIZE = 28;
    private static final String WARN_TAG = ColorUtil.wrapWithColorTag("Warn: ", Color.YELLOW);
    private static final String INVENTORY_FULL_TEXT = WARN_TAG + "Inventory is full.";
    private static final String THRESHOLD_BLOCK_TEXT = WARN_TAG + "Blocking - at threshold.";
    private static final String QUANTITY_BLOCK_TEXT = WARN_TAG + "Blocking - quantity will pass threshold.";

    // FIXME: Item skip list, band-aid fix for issues like #21 and #22 until a proper solution is found.
    // Add ID's for items that are very inaccurate in price.
    private static final Set<Integer> ITEM_BLACKLIST = ImmutableSet.of(
        ItemID.DISCOFRETURNING
    );

    private final Client client;
    private final ItemManager itemManager;
    private final TooltipManager tooltipManager;
    private final ShopPricesPlugin plugin;

    @Inject
    public ShopPricesOverlay(ShopPricesPlugin plugin, Client client, ItemManager itemManager, TooltipManager tooltipManager) {
        drawAfterLayer(InterfaceID.Shopmain.ITEMS);
        this.plugin = plugin;
        this.client = client;
        this.tooltipManager = tooltipManager;
        this.itemManager = itemManager;
    }

    @Override
    public void renderItemOverlay(Graphics2D graphics, int itemId, WidgetItem itemWidget) {
        if (plugin.activeShop == null) {
            return;
        }

        if (ITEM_BLACKLIST.contains(itemWidget.getId())) {
            return;
        }

        if (plugin.getConfig().displayOverlay()) {
            onDisplayOverlay(graphics, plugin.activeShop, itemWidget);
        }

        if (plugin.getConfig().displayTooltip()) {
            onDisplayTooltip(plugin.activeShop, itemWidget);
        }
    }

    private void onDisplayOverlay(Graphics2D graphics, Shop activeShop, WidgetItem itemWidget) {
        ItemComposition itemComposition = itemManager.getItemComposition(itemWidget.getId());
        int currentStock = itemWidget.getQuantity();
        int sellPrice = activeShop.getSellPrice(itemComposition, currentStock);

        int multiplierThreshold = plugin.getConfig().priceThreshold();
        String sellValue = Shop.getPriceValue(sellPrice);
        Rectangle bounds = itemWidget.getCanvasBounds();

        if (plugin.getConfig().priceThresholdEnabled() && activeShop.isPriceAtThreshold(itemComposition, multiplierThreshold, currentStock)) {
            graphics.setColor(plugin.getConfig().thresholdOverlayColor());
        } else {
            graphics.setColor(plugin.getConfig().defaultOverlayColor());
        }

        Rectangle parentBounds = itemWidget.getWidget().getParent().getBounds();

        parentBounds.setSize(parentBounds.width + WIDTH_CLIP_PADDING, parentBounds.height);

        graphics.setClip(parentBounds);
        graphics.drawString(sellValue, bounds.x, (int) bounds.getMaxY() + PRICE_PADDING);
    }

    private void onDisplayTooltip(Shop activeShop, WidgetItem itemWidget) {
        MenuEntry[] menuEntries = client.getMenu().getMenuEntries();
        int lastEntry = menuEntries.length - 1;

        if (client.isMenuOpen()) {
            return;
        }

        if (lastEntry < 0) {
            return;
        }

        MenuEntry menuEntry = menuEntries[lastEntry];
        MenuAction type = menuEntry.getType();
        String option = menuEntry.getOption();
        int itemId = menuEntry.getItemId();

        if (itemId != itemWidget.getId()) {
            return;
        }

        if (!Shop.MENU_ACTIONS.contains(type)) {
            return;
        }

        if (!Shop.MENU_OPTIONS.contains(option)) {
            return;
        }

        ItemContainer itemContainer = client.getItemContainer(InventoryID.INV);
        int inventorySpace = itemContainer != null ? INVENTORY_SIZE - itemContainer.count() : 0;

        Tooltip tooltip;

        if (inventorySpace <= 0) {
            tooltip = new Tooltip(INVENTORY_FULL_TEXT);
            tooltipManager.add(tooltip);
            return;
        }

        ItemComposition itemComposition = itemManager.getItemComposition(itemId);
        int currentStock = itemWidget.getQuantity();
        int multiplierThreshold = plugin.getConfig().priceThreshold();
        boolean atThreshold = activeShop.isPriceAtThreshold(itemComposition, multiplierThreshold, currentStock);

        if (plugin.getConfig().blockOnThreshold()) {
            if (atThreshold) {
                tooltip = new Tooltip(THRESHOLD_BLOCK_TEXT);
                tooltipManager.add(tooltip);
                return;
            }

            if (plugin.getConfig().blockCheckQuantity() && activeShop.isQuantityAtThreshold(itemComposition, multiplierThreshold, currentStock)) {
                tooltip = new Tooltip(QUANTITY_BLOCK_TEXT);
                tooltipManager.add(tooltip);
                return;
            }
        }

        Color priceColor;
        if (plugin.getConfig().priceThresholdEnabled() && atThreshold) {
            priceColor = plugin.getConfig().thresholdOverlayColor();
        } else {
            priceColor = Color.WHITE;
        }

        int buyAmount = plugin.activeShop.quantityOption.getAmount();
        int totalPrice = activeShop.getSellPriceTotal(itemComposition, currentStock, buyAmount);

        if (itemComposition.isStackable() && buyAmount > currentStock) {
            buyAmount = currentStock;
        } else if (buyAmount > inventorySpace) {
            buyAmount = inventorySpace;
        }

        String priceText = ColorUtil.wrapWithColorTag(
            Shop.getExactPriceValue(totalPrice),
            priceColor
        );

        tooltip = new Tooltip(
            String.format("Sells at: %s (%d)", priceText, buyAmount)
        );

        tooltipManager.add(tooltip);
    }
}

package com.shopprices;

import com.google.common.reflect.TypeToken;
import com.google.gson.Gson;
import org.junit.jupiter.api.AfterAll;
import org.junit.jupiter.api.BeforeAll;
import org.junit.jupiter.api.Test;

import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.Reader;
import java.lang.reflect.Type;
import java.util.Map;

import static org.junit.jupiter.api.Assertions.*;

public class JsonResourceTest {
    private static final String SHOPS_RESOURCE = "shops.json";
    private static final Type SHOP_TYPE = new TypeToken<Map<String, Shop>>(){}.getType();
    private static final Gson gson = new Gson();
    private static Map<String, Shop> shops;
    private static Reader reader;

    @BeforeAll
    public static void start()  {
        InputStream stream = JsonResourceTest.class.getClassLoader().getResourceAsStream(SHOPS_RESOURCE);
        assertNotNull(stream, "Resource not found.");
        reader = new InputStreamReader(stream);
        assertDoesNotThrow(() -> {
            shops = gson.fromJson(reader, SHOP_TYPE);
            assertNotNull(shops);
        });
    }

    @Test
    void testJsonMatchesExpectedKeys() {
        assertTrue(shops.entrySet().stream().allMatch(
            shop -> shop.getKey().matches("[A-Z_]+")
        ));
    }

    @Test
    void testJsonMatchesExpectedValues() {
        Shop shop = shops.get("VARROCK_GENERAL_STORE");

        assertEquals(3.0f, shop.shopDelta);
        assertEquals(130, shop.sellMultiplier);
        assertNotNull(shop.itemStocks.get("Pot"));
        assertEquals(5, shop.itemStocks.get("Pot"));
    }

    @AfterAll
    public static void close() throws IOException {
        reader.close();
    }
}

package com.shopprices;

import net.runelite.client.RuneLite;
import net.runelite.client.externalplugins.ExternalPluginManager;

public class ShopPricesPluginTest {
	public static void main(String[] args) throws Exception {
		ExternalPluginManager.loadBuiltin(ShopPricesPlugin.class);
		RuneLite.main(args);
	}
}
