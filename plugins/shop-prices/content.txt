package com.shopprices;

import net.runelite.client.config.Alpha;
import net.runelite.client.config.Config;
import net.runelite.client.config.ConfigGroup;
import net.runelite.client.config.ConfigItem;

import java.awt.Color;

@ConfigGroup("shopprices")
public interface ShopPricesConfig extends Config {
    @ConfigItem(
        position = 0,
        keyName = "displayOverlay",
        name = "Display prices below Items",
        description = "Shows a item value below each item in the shop."
    )
    default boolean displayOverlay() {
        return true;
    }

    @ConfigItem(
        position = 1,
        keyName = "displayTooltip",
        name = "Display prices in Tooltip",
        description = "Shows a small tooltip with items total price when hovering over an item."
    )
    default boolean displayTooltip() {
        return true;
    }

    @ConfigItem(
        position = 2,
        keyName = "overlayValueColor",
        name = "Shop price color",
        description = "Sets the default item value color."
    )
    @Alpha default Color defaultOverlayColor() {
        return Color.WHITE;
    }

    @ConfigItem(
        position = 3,
        keyName = "enablePriceThreshold",
        name = "Enable price threshold",
        description = "Allows you to set a threshold for when a price reaches a certain percentage."
    )
    default boolean priceThresholdEnabled() {
        return true;
    }

    @ConfigItem(
        position = 4,
        keyName = "priceThresholdPercentage",
        name = "Threshold Percentage",
        description = "Sets the threshold percentage."
    )
    default int priceThreshold() {
        return 15;
    }

    @ConfigItem(
        position = 5,
        keyName = "priceThresholdColor",
        name = "Price threshold color",
        description = "Sets the threshold item value color."
    )
    default Color thresholdOverlayColor() {
        return new Color(221, 69, 69);
    }
}

package com.shopprices;

import com.google.common.reflect.TypeToken;
import com.google.gson.Gson;
import com.google.inject.Provides;
import lombok.Getter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.game.ItemManager;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.plugins.PluginDescriptor;
import net.runelite.client.ui.overlay.OverlayManager;
import net.runelite.client.ui.overlay.tooltip.TooltipManager;

import javax.inject.Inject;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.lang.reflect.Type;
import java.util.HashMap;
import java.util.Map;


@Slf4j
@PluginDescriptor(
    name = "Shop Prices",
    description = "Display prices for items in NPC shops.",
    tags = {"qol", "shop", "prices", "overlay"}
)
public class ShopPricesPlugin extends Plugin {
    @Inject
    private Client client;

    @Inject
    private ItemManager itemManager;

    @Inject
    private OverlayManager overlayManager;

    @Inject
    private TooltipManager tooltipManager;

    @Inject
    private ShopPricesOverlay shopPricesOverlay;

    @Getter
    @Inject
    private ShopPricesConfig config;

    @Inject
    private Gson gson;

    public static final String SHOPS_RESOURCE = "shops.json";
    public static final Type SHOP_TYPE = new TypeToken<Map<String, Shop>>(){}.getType();
    public static Map<String, Shop> shopsMap = new HashMap<>();

    @Provides
    ShopPricesConfig provideConfig(ConfigManager configManager) {
        return configManager.getConfig(ShopPricesConfig.class);
    }

    @Override
    protected void startUp() {
        InputStream stream = getClass().getClassLoader().getResourceAsStream(SHOPS_RESOURCE);

        if (stream == null) {
            throw new IllegalArgumentException("Resource not found.");
        }

        try (InputStreamReader reader = new InputStreamReader(stream)) {
            ShopPricesPlugin.shopsMap = gson.fromJson(reader, SHOP_TYPE);
            overlayManager.add(shopPricesOverlay);
        } catch (IOException e) {
            log.error("Failed to read JSON file \"{}\": {}", SHOPS_RESOURCE, e.getMessage());
        }
    }

    @Override
    protected void shutDown() {
        overlayManager.remove(shopPricesOverlay);
        shopsMap.clear();
    }
}

package com.shopprices;

import net.runelite.api.ItemComposition;
import net.runelite.client.util.QuantityFormatter;

import java.text.DecimalFormat;
import java.util.Map;

public final class Shop {
    public static final String SHOP_KEY_PATTERN = "[^a-zA-Z ]+";
    public static final float MIN_SELL_MULTIPLIER = 30.0f;

    /** Shops default sell multiplier for every item */
    int sellMultiplier;

    /** A price percentage change per shops stock surplus/deficit based on default stock. */
    float shopDelta;

    /**
     * A map of items that contains their default shop stock.
     * Items stock defaulted to 0 on null.
     */
    Map<String, Integer> itemStocks;

    /**
     * Gets the map key by formatting the shops name.
     *
     * @param shopName Shops name displayed in Shop frame widget.
     * @return         Shop key for accessing a structured map.
     */
    public static String formatShopName(String shopName) {
        return String.join("_", shopName.replaceAll(SHOP_KEY_PATTERN, "").toUpperCase().split(" "));
    }

    /**
     * Gets RuneScape's precise decimal currency stack value.
     *
     * @param priceValue Items sell price value.
     * @see QuantityFormatter#quantityToRSDecimalStack(int, boolean)
     *
     */
    public static String getPriceValue(int priceValue) {
        return QuantityFormatter.quantityToRSDecimalStack(priceValue, true) + " gp";
    }

    /**
     * Gets the formatted string price value.
     *
     * @param priceValue Items calculated value.
     * @return           Exact price value formatted with commas.
     */
    public static String getExactPriceValue(int priceValue) {
        DecimalFormat formatter = new DecimalFormat("#,###,###,### gp");
        return formatter.format(priceValue);
    }

    /**
     * Gets the items selling multiplier based on its current stock.
     *
     * @param itemComposition       Items compositions.
     * @param multiplierThreshold   Items percentage multiplier threshold.
     * @param currentStock          Items current stock in the shop.
     * @return                      True when multipliers threshold is greater than or equal to an items current multiplier.
     */
    public boolean isPriceAtThreshold(ItemComposition itemComposition, int multiplierThreshold, int currentStock) {
        return this.sellMultiplier + multiplierThreshold <= this.getSellMultiplier(itemComposition, currentStock);
    }

    /**
     * Gets the items selling multiplier based on its current stock.
     *
     * @param itemComposition   Items compositions.
     * @param currentStock      Items current stock in the shop.
     * @return                  A percentage sell multiplier.
     */
    public float getSellMultiplier(ItemComposition itemComposition, int currentStock) {
        Integer defaultStock = this.itemStocks.get(itemComposition.getName());

        if (defaultStock == null) {
            defaultStock = 0;
        }

        int stockDelta = defaultStock - currentStock;
        return sellMultiplier + (this.shopDelta * stockDelta);
    }

    /**
     * Gets the items selling price based on its current stock.
     *
     * @param itemComposition   Items compositions.
     * @param currentStock      Items current stock in the shop.
     * @return                  Items price value when buying a single quantity.
     */
    public int getSellPrice(ItemComposition itemComposition, int currentStock) {
        int itemValue = itemComposition.getPrice();

        // TODO: Look over this equation again and confirm its validity with tests.
        return (int) Math.max(
            itemValue * this.getSellMultiplier(itemComposition, currentStock) / 100,
            Math.max(MIN_SELL_MULTIPLIER * itemValue / 100, 1)
        );
    }

    /**
     * Gets the items selling price based on its current stock and amount being bought.
     *
     * @param itemComposition   Items compositions.
     * @param currentStock      Items current stock in the shop.
     * @param buyAmount         Amount of items being bought.
     * @return                  Items total price value when buying X quantity.
     */
    public int getSellPriceTotal(ItemComposition itemComposition, int currentStock, int buyAmount) {
        int totalCost = 0;

        for (int amount = 0; amount < buyAmount; amount++) {
            int stockDelta = currentStock - amount;
            totalCost += this.getSellPrice(itemComposition, stockDelta);
        }

        return totalCost;
    }
}
package com.shopprices;

import com.google.common.collect.ImmutableSet;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.ItemComposition;
import net.runelite.api.ItemContainer;
import net.runelite.api.MenuAction;
import net.runelite.api.MenuEntry;
import net.runelite.api.gameval.InterfaceID;
import net.runelite.api.gameval.InventoryID;
import net.runelite.api.widgets.Widget;
import net.runelite.client.game.ItemManager;
import net.runelite.client.ui.overlay.Overlay;
import net.runelite.client.ui.overlay.OverlayLayer;
import net.runelite.client.ui.overlay.OverlayPosition;
import net.runelite.client.ui.overlay.tooltip.Tooltip;
import net.runelite.client.ui.overlay.tooltip.TooltipManager;
import net.runelite.client.util.ColorUtil;

import javax.inject.Inject;
import java.awt.Graphics2D;
import java.awt.Rectangle;
import java.awt.Dimension;
import java.awt.Color;
import java.util.Set;

@Slf4j
public class ShopPricesOverlay extends Overlay {
    private static final int PRICE_PADDING = 10;
    private static final int INVENTORY_SIZE = 28;
    private static final Set<MenuAction> SHOP_WIDGET_ACTIONS = ImmutableSet.of(
        MenuAction.CC_OP,
        MenuAction.CC_OP_LOW_PRIORITY
    );
    private static final String INVENTORY_FULL_TEXT =
        ColorUtil.wrapWithColorTag("Warn: ", Color.YELLOW) + "Inventory is full.";

    private final Client client;
    private final ItemManager itemManager;
    private final TooltipManager tooltipManager;
    private final ShopPricesPlugin plugin;

    @Inject
    public ShopPricesOverlay(ShopPricesPlugin plugin, Client client, ItemManager itemManager, TooltipManager tooltipManager) {
        setPosition(OverlayPosition.DYNAMIC);
        setLayer(OverlayLayer.ABOVE_WIDGETS);
        this.plugin = plugin;
        this.client = client;
        this.itemManager = itemManager;
        this.tooltipManager = tooltipManager;
    }

    @Override
    public Dimension render(Graphics2D graphics) {
        Widget shopWidget = client.getWidget(InterfaceID.Shopmain.ITEMS);
        Widget frameWidget = client.getWidget(InterfaceID.Shopmain.FRAME);
        if (shopWidget == null || frameWidget == null) {
            return null;
        }

        Widget[] shopItems = shopWidget.getDynamicChildren();
        Widget[] frameChildren = frameWidget.getDynamicChildren();

        if (shopItems == null || frameChildren == null) {
            return null;
        }

        String shopName = Shop.formatShopName(frameChildren[1].getText());

        for (Widget itemWidget : shopItems) {
            if (itemWidget.getItemId() == -1 || itemWidget.getName().isBlank()) {
                continue;
            }

            Shop activeShop = ShopPricesPlugin.shopsMap.get(shopName);

            if (activeShop == null) {
                return null;
            }

            if (plugin.getConfig().displayOverlay()) {
                onDisplayOverlay(graphics, activeShop, itemWidget);
            }

            if (plugin.getConfig().displayTooltip()) {
                onDisplayTooltip(activeShop, itemWidget);
            }
        }

        return null;
    }

    private void onDisplayOverlay(Graphics2D graphics, Shop activeShop, Widget itemWidget) {
        ItemComposition itemComposition = itemManager.getItemComposition(itemWidget.getItemId());
        int currentStock = itemWidget.getItemQuantity();
        int sellPrice = activeShop.getSellPrice(itemComposition, currentStock);

        int multiplierThreshold = plugin.getConfig().priceThreshold();
        String sellValue = Shop.getPriceValue(sellPrice);
        Rectangle bounds = itemWidget.getBounds();

        if (plugin.getConfig().priceThresholdEnabled() && activeShop.isPriceAtThreshold(itemComposition, multiplierThreshold, currentStock)) {
            graphics.setColor(plugin.getConfig().thresholdOverlayColor());
        } else {
            graphics.setColor(plugin.getConfig().defaultOverlayColor());
        }

        graphics.drawString(sellValue, bounds.x, (int) bounds.getMaxY() + PRICE_PADDING);
    }

    private void onDisplayTooltip(Shop activeShop, Widget itemWidget) {
        MenuEntry[] menuEntries = client.getMenu().getMenuEntries();
        int lastEntry = menuEntries.length - 1;

        if (client.isMenuOpen()) {
            return;
        }

        if (lastEntry < 0) {
            return;
        }

        MenuEntry menuEntry = menuEntries[lastEntry];
        MenuAction type = menuEntry.getType();
        String option = menuEntry.getOption();
        int itemId = menuEntry.getItemId();

        if (itemId != itemWidget.getItemId()) {
            return;
        }

        if (!SHOP_WIDGET_ACTIONS.contains(type)) {
            return;
        }

        int buyAmount;

        switch (option) {
            case "Buy 50":
                buyAmount = 50;
                break;
            case "Buy 10":
                buyAmount = 10;
                break;
            case "Buy 5":
                buyAmount = 5;
                break;
            case "Buy 1":
            case "Value":
                buyAmount = 1;
                break;
            default:
                return;
        }

        ItemContainer itemContainer = client.getItemContainer(InventoryID.INV);
        int inventorySpace = itemContainer != null ? INVENTORY_SIZE - itemContainer.count() : 0;

        ItemComposition itemComposition = itemManager.getItemComposition(itemWidget.getItemId());
        int currentStock = itemWidget.getItemQuantity();

        Tooltip tooltip;

        if (inventorySpace <= 0) {
            tooltip = new Tooltip(INVENTORY_FULL_TEXT);
            tooltipManager.add(tooltip);
            return;
        }

        if (itemComposition.isStackable() && buyAmount > currentStock) {
            buyAmount = currentStock;
        } else if (buyAmount > inventorySpace) {
            buyAmount = inventorySpace;
        }

        int totalPrice = activeShop.getSellPriceTotal(itemComposition, currentStock, buyAmount);
        int multiplierThreshold = plugin.getConfig().priceThreshold();

        Color priceColor;
        if (plugin.getConfig().priceThresholdEnabled() && activeShop.isPriceAtThreshold(itemComposition, multiplierThreshold, currentStock)) {
            priceColor = plugin.getConfig().thresholdOverlayColor();
        } else {
            priceColor = Color.WHITE;
        }

        String priceText = ColorUtil.wrapWithColorTag(totalPrice + " gp", priceColor);

        tooltip = new Tooltip(
            String.format("Sells at: %s (%d)", priceText, buyAmount)
        );

        tooltipManager.add(tooltip);
    }
}

package com.shopprices;

import com.google.common.reflect.TypeToken;
import com.google.gson.Gson;
import org.junit.jupiter.api.AfterAll;
import org.junit.jupiter.api.BeforeAll;
import org.junit.jupiter.api.Test;

import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.Reader;
import java.lang.reflect.Type;
import java.util.Map;

import static org.junit.jupiter.api.Assertions.*;

public class JsonResourceTest {
    private static final String SHOPS_RESOURCE = "shops.json";
    private static final Type SHOP_TYPE = new TypeToken<Map<String, Shop>>(){}.getType();
    private static final Gson gson = new Gson();
    private static Map<String, Shop> shops;
    private static Reader reader;

    @BeforeAll
    public static void start()  {
        InputStream stream = JsonResourceTest.class.getClassLoader().getResourceAsStream(SHOPS_RESOURCE);
        assertNotNull(stream, "Resource not found.");
        reader = new InputStreamReader(stream);
        assertDoesNotThrow(() -> {
            shops = gson.fromJson(reader, SHOP_TYPE);
            assertNotNull(shops);
        });
    }

    @Test
    void testJsonMatchesExpectedKeys() {
        assertTrue(shops.entrySet().stream().allMatch(
            shop -> shop.getKey().matches("[A-Z_]+")
        ));
    }

    @Test
    void testJsonMatchesExpectedValues() {
        Shop shop = shops.get("VARROCK_GENERAL_STORE");

        assertEquals(3.0f, shop.shopDelta);
        assertEquals(130, shop.sellMultiplier);
        assertNotNull(shop.itemStocks.get("Pot"));
        assertEquals(5, shop.itemStocks.get("Pot"));
    }

    @AfterAll
    public static void close() throws IOException {
        reader.close();
    }
}

package com.shopprices;

import net.runelite.client.RuneLite;
import net.runelite.client.externalplugins.ExternalPluginManager;

public class ShopPricesPluginTest {
	public static void main(String[] args) throws Exception {
		ExternalPluginManager.loadBuiltin(ShopPricesPlugin.class);
		RuneLite.main(args);
	}
}
