package com.objecthider;

import net.runelite.api.*;
import net.runelite.api.gameval.ObjectID;
import net.runelite.client.callback.RenderCallback;

import javax.inject.Inject;
import java.util.HashSet;
import java.util.Set;

public class ObjectHiderRenderCallback implements RenderCallback {
  @Inject
  private Client client;

  private Set<Integer> idsToHide = new HashSet<>();
  private boolean hideAll = false;
  private boolean hideMapIcons = false;

  @Inject
  ObjectHiderRenderCallback() {
  }

  @Override
  public boolean drawTile(Scene scene, Tile tile) {
    if (tile.getGroundObject() == null) {
      return RenderCallback.super.drawTile(scene, tile);
    }

    // Disallow hiding in Sotetseg regions.
    for (int i : scene.getMapRegions()) {
      if (i == 13123 || i == 13379) {
        return RenderCallback.super.drawTile(scene, tile);
      }
    }

    GroundObject groundObject = tile.getGroundObject();
    if (groundObject == null) {
      return RenderCallback.super.drawTile(scene, tile);
    }

    // Handle non hide all cases first
    if (!hideAll && idsToHide.contains(groundObject.getId())) {
      tile.setGroundObject(null);
      return RenderCallback.super.drawTile(scene, tile);
    }

    ObjectComposition oc = client.getObjectDefinition(groundObject.getId());
    if (oc == null) {
      return RenderCallback.super.drawTile(scene, tile);
    }

    if (this.hideMapIcons && oc.getMapIconId() != -1) {
      tile.setGroundObject(null);
      return RenderCallback.super.drawTile(scene, tile);
    }

    // If object has an imposter, don't hide
    if (this.hideAll && oc.getMapIconId() == -1) {
      int[] imposters = oc.getImpostorIds();
      if (imposters == null) {
        tile.setGroundObject(null);
      } else if (imposters.length == 0) {
        tile.setGroundObject(null);
      }
    }

    return RenderCallback.super.drawTile(scene, tile);
  }

  void setHideAll(boolean hideAll) {
    this.hideAll = hideAll;
  }

  void setHideMapIcons(boolean hideMapIcons) {
    this.hideMapIcons = hideMapIcons;
  }

  void setTilesToHide(Set<Integer> ids) {
    idsToHide = ids;
  }

  void clearHiddenTiles() {
    idsToHide.clear();
  }
}

package com.objecthider;

import net.runelite.client.config.Config;
import net.runelite.client.config.ConfigGroup;
import net.runelite.client.config.ConfigItem;
import net.runelite.client.config.ConfigSection;
import net.runelite.client.config.Keybind;

@ConfigGroup("objecthider")
public interface ObjectHiderConfig extends Config {
  @ConfigSection(name = "IDs to hide", description = "The list of Ground Object IDs to hide", position = 0, closedByDefault = true)
  String listSection = "listSection";

  @ConfigItem(keyName = "toHide", name = "", description = "List of Ground Objects IDs to hide", position = 0, section = "listSection")
  default String getGroundObjectsToHide() {
    return "";
  }

  @ConfigItem(keyName = "toHide", name = "", description = "")
  void setGroundObjectsToHide(String groundObjectsToHide);

  @ConfigItem(keyName = "hotkey", name = "Hotkey", description = "When you hold this key and right-click a tile, you'll hide the Ground Object on it", position = 1)
  default Keybind hideGroundObjectKey() {
    return Keybind.NOT_SET;
  }

  @ConfigItem(keyName = "hideAll", name = "Hide All", description = "Whether to hide all Ground Objects regardless of the list", position = 2)
  default boolean getHideAll() {
    return false;
  }

  @ConfigItem(keyName = "hideMinimapIcons", name = "Hide Minimap Icons", description = "Whether to hide all minimap icons regardless of the list", position = 3)
  default boolean getHideMinimapIcons() {
    return false;
  }
}

package com.objecthider;

import com.google.inject.Provides;
import net.runelite.api.*;
import net.runelite.api.events.GameTick;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.callback.RenderCallbackManager;
import net.runelite.client.chat.ChatMessageBuilder;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.chat.QueuedMessage;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.events.ConfigChanged;
import net.runelite.client.input.KeyManager;
import net.runelite.client.input.MouseListener;
import net.runelite.client.input.MouseManager;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.plugins.PluginDescriptor;
import net.runelite.client.ui.ClientUI;
import net.runelite.client.ui.overlay.OverlayManager;
import net.runelite.client.util.HotkeyListener;
import net.runelite.client.util.Text;

import javax.inject.Inject;
import javax.swing.*;
import java.awt.event.KeyEvent;
import java.awt.event.MouseEvent;
import java.util.*;
import java.util.stream.Collectors;

@PluginDescriptor(name = "Ground Object Hider", description = "Hides Ground Objects. A selector is used to choose objects to hide.", tags = {"external", "objects", "memory", "usage", "ground", "decorations", "performance"})
public class ObjectHiderPlugin extends Plugin {
  @Inject
  private Client client;

  @Inject
  private ClientUI clientUI;

  @Inject
  private ClientThread clientThread;

  @Inject
  private ObjectHiderConfig config;

  @Inject
  private OverlayManager overlayManager;

  @Inject
  private ObjectHiderOverlay overlay;

  @Inject
  private KeyManager keyManager;

  @Inject
  private MouseManager mouseManager;

  @Inject
  private ChatMessageManager chatMessageManager;

  @Inject
  private RenderCallbackManager renderCallbackManager;

  @Inject
  private ObjectHiderRenderCallback callback;

  public boolean selectGroundObjectMode = false;

  /**
   * groundObjectsKeyListener is an instance of `HotkeyListener` designed to let
   * the user pick a tile in-game to have its Ground Object hidden.
   */
  private final HotkeyListener groundObjectsKeyListener = new HotkeyListener(() -> config.hideGroundObjectKey()) {
    @Override
    public void keyPressed(KeyEvent e) {
      if (config.hideGroundObjectKey().matches(e)) {
        if (!selectGroundObjectMode) {
          ChatMessageBuilder message = new ChatMessageBuilder().append("Ground Object Hider hotkey triggered.");
          chatMessageManager.queue(QueuedMessage.builder().type(ChatMessageType.CONSOLE).runeLiteFormattedMessage(message.build()).build());
        }
        selectGroundObjectMode = true;
      }
    }

    @Override
    public void keyReleased(KeyEvent e) {
      if (config.hideGroundObjectKey().matches(e)) {
        if (selectGroundObjectMode) {
          ChatMessageBuilder message = new ChatMessageBuilder().append("Ground Object Hider hotkey released.");
          chatMessageManager.queue(QueuedMessage.builder().type(ChatMessageType.CONSOLE).runeLiteFormattedMessage(message.build()).build());
        }
        selectGroundObjectMode = false;
      }
    }
  };

  /**
   * mouseListener is an instance of `MouseListener` designed solely to let the
   * user pick a tile in-game to have its Ground Object hidden.
   */
  private final MouseListener mouseListener = new MouseListener() {
    @Override
    public MouseEvent mouseClicked(MouseEvent mouseEvent) {
      if (SwingUtilities.isRightMouseButton(mouseEvent)) {
        if (!selectGroundObjectMode) {
          return mouseEvent;
        }
        final Tile tile = client.getSelectedSceneTile();
        if (tile == null) {
          return mouseEvent;
        }
        // have a selected tile, in a suitable mode, so consume event:
        mouseEvent.consume();

        // get current list:
        final List<Integer> curGroundHide = new ArrayList<>(getGroundObjects());
        final GroundObject obj = tile.getGroundObject();
        if (obj != null) {
          if (!curGroundHide.contains(obj.getId())) {
            curGroundHide.add(obj.getId());
          }
          config.setGroundObjectsToHide(Text.toCSV(curGroundHide.stream().map(String::valueOf).collect(Collectors.toList())));
        }
      }
      return mouseEvent;
    }

    @Override
    public MouseEvent mousePressed(MouseEvent mouseEvent) {
      if (selectGroundObjectMode && SwingUtilities.isRightMouseButton(mouseEvent)) {
        mouseEvent.consume();
      }
      return mouseEvent;
    }

    @Override
    public MouseEvent mouseReleased(MouseEvent mouseEvent) {
      return mouseEvent;
    }

    @Override
    public MouseEvent mouseEntered(MouseEvent mouseEvent) {
      return mouseEvent;
    }

    @Override
    public MouseEvent mouseExited(MouseEvent mouseEvent) {
      return mouseEvent;
    }

    @Override
    public MouseEvent mouseDragged(MouseEvent mouseEvent) {
      return mouseEvent;
    }

    @Override
    public MouseEvent mouseMoved(MouseEvent mouseEvent) {
      return mouseEvent;
    }
  };

  @Provides
  ObjectHiderConfig provideConfig(ConfigManager configManager) {
    return configManager.getConfig(ObjectHiderConfig.class);
  }

  @Override
  protected void startUp() {
    keyManager.registerKeyListener(groundObjectsKeyListener);
    mouseManager.registerMouseListener(mouseListener);
    overlayManager.add(overlay);
    renderCallbackManager.register(callback);

    callback.setHideAll(config.getHideAll());
    callback.setHideMapIcons(config.getHideMinimapIcons());
    callback.setTilesToHide(this.getGroundObjects());
    this.tryReloadScene();
  }

  @Override
  protected void shutDown() {
    // on shutDown make sure to remove the draw callbacks and clear lists:
    keyManager.unregisterKeyListener(groundObjectsKeyListener);
    mouseManager.unregisterMouseListener(mouseListener);
    overlayManager.remove(overlay);
    renderCallbackManager.unregister(callback);

    callback.setHideAll(false);
    callback.setHideMapIcons(false);
    callback.clearHiddenTiles();
    this.tryReloadScene();
  }

  /**
   * getGroundObjects retrieves the list of Ground Objects to hide from the
   * config, and transforms into a `List<Integer>` for consumption.
   * <p>
   * If something goes wrong, an empty list will be returned.
   *
   * @return configured list of Ground Objects to hide
   */
  Set<Integer> getGroundObjects() {
    try {
      return new HashSet<Integer>(intsFromCSVString(config.getGroundObjectsToHide()));
    } catch (NumberFormatException ex) {
      return Collections.emptySet();
    }
  }

  /**
   * intsFromCSVStrong takes a String containing a list of Integers and returns
   * those Integers in a `List<Integer>` format.
   *
   * @param val - the string containing integers to parse
   * @return a list of integers
   * @throws NumberFormatException - if the string contains non-integers or is
   *                               badly formatted.
   */
  private static List<Integer> intsFromCSVString(String val) throws NumberFormatException {
    // parse a string of CSV integers:
    if (val.isEmpty()) {
      return Collections.emptyList();
    }
    return Text.fromCSV(val).stream().map(Integer::parseInt).collect(Collectors.toList());
  }

  /**
   * onGameTick listens for game ticks to schedule a regular garbage collection of
   * Game Objects that are no longer in the scene.
   *
   * @param event - the tick event
   */
  @Subscribe
  public void onGameTick(GameTick event) {
    if (selectGroundObjectMode && !clientUI.isFocused()) {
      ChatMessageBuilder message = new ChatMessageBuilder().append("Ground Object Hider hotkey released.");
      chatMessageManager.queue(QueuedMessage.builder().type(ChatMessageType.CONSOLE).runeLiteFormattedMessage(message.build()).build());
      selectGroundObjectMode = false;
    }
  }

  /**
   * onConfigChanged listens for changes to the plugin configuration to ensure the
   * client is synchronised when the config changes.
   *
   * @param configChanged - the change event (not used)
   */
  @Subscribe
  public void onConfigChanged(ConfigChanged configChanged) {
    if (!configChanged.getGroup().equals("objecthider")) {
      return;
    }
    callback.setHideAll(config.getHideAll());
    callback.setHideMapIcons(config.getHideMinimapIcons());
    callback.setTilesToHide(this.getGroundObjects());
    this.tryReloadScene();
  }

  private void tryReloadScene() {
    clientThread.invokeLater(() -> {
      if (client.getGameState() == GameState.LOGGED_IN) client.setGameState(GameState.LOADING);
    });
  }
}

package com.objecthider;

import net.runelite.api.Client;
import net.runelite.api.Perspective;
import net.runelite.client.ui.overlay.Overlay;
import net.runelite.client.ui.overlay.OverlayLayer;
import net.runelite.client.ui.overlay.OverlayPosition;
import net.runelite.client.ui.overlay.OverlayPriority;
import net.runelite.client.ui.overlay.OverlayUtil;

import javax.inject.Inject;
import java.awt.Color;
import java.awt.Dimension;
import java.awt.Graphics2D;
import java.awt.Polygon;

/**
 * ObjectHiderOverlay adds a magenta colored border around the currently
 * highlighted tile when in selection mode.
 */
public class ObjectHiderOverlay extends Overlay {
  private final Client client;
  private final ObjectHiderPlugin plugin;

  @Inject
  private ObjectHiderOverlay(Client client, ObjectHiderPlugin plugin, ObjectHiderConfig config) {
    this.client = client;
    this.plugin = plugin;
    // position, layer + priority copied from `plugins.tileindicator`
    setPosition(OverlayPosition.DYNAMIC);
    setLayer(OverlayLayer.ABOVE_SCENE);
    setPriority(OverlayPriority.MED);
  }

  @Override
  public Dimension render(Graphics2D graphics) {
    if (plugin.selectGroundObjectMode && client.getSelectedSceneTile() != null) {
      // create a polygon
      final Polygon poly = Perspective.getCanvasTilePoly(client,
          client.getSelectedSceneTile().getLocalLocation());
      if (poly != null) {
        // and render it
        OverlayUtil.renderPolygon(graphics, poly, Color.MAGENTA);
      }
    }
    return null;
  }
}

package com.objecthider;

import net.runelite.client.RuneLite;
import net.runelite.client.externalplugins.ExternalPluginManager;

public class ObjectHiderPluginTest
{
	public static void main(String[] args) throws Exception
	{
		ExternalPluginManager.loadBuiltin(ObjectHiderPlugin.class);
		RuneLite.main(args);
	}
}
