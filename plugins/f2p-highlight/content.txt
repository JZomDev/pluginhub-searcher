/*
 * Copyright (c) 2021, Zoinkwiz <https://github.com/Zoinkwiz>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package io.mark.f2p.utils;

import net.runelite.api.Client;
import net.runelite.api.Point;
import net.runelite.api.coords.WorldPoint;
import net.runelite.api.gameval.InterfaceID;
import net.runelite.api.widgets.Widget;

import java.awt.*;

public class WorldPerspective {

    public static Rectangle getWorldMapClipArea(Client client) {
        Widget widget = client.getWidget(InterfaceID.Worldmap.MAP_CONTAINER);
        if (widget == null) {
            return null;
        }

        return widget.getBounds();
    }

    public static Point mapWorldPointToGraphicsPoint(Client client, WorldPoint worldPoint) {
        var worldMap = client.getWorldMap();
        if (worldPoint == null) return null;
        if (!worldMap.getWorldMapData().surfaceContainsPosition(worldPoint.getX(), worldPoint.getY())) {
            return null;
        }

        float pixelsPerTile = worldMap.getWorldMapZoom();

        Widget map = client.getWidget(InterfaceID.Worldmap.MAP_CONTAINER);
        if (map != null) {
            Rectangle worldMapRect = map.getBounds();

            int widthInTiles = (int) Math.ceil(worldMapRect.getWidth() / pixelsPerTile);
            int heightInTiles = (int) Math.ceil(worldMapRect.getHeight() / pixelsPerTile);

            var worldMapPosition = worldMap.getWorldMapPosition();

            int yTileMax = worldMapPosition.getY() - heightInTiles / 2;
            int yTileOffset = (yTileMax - worldPoint.getY() - 1) * -1;
            int xTileOffset = worldPoint.getX() + widthInTiles / 2 - worldMapPosition.getX();

            int xGraphDiff = ((int) (xTileOffset * pixelsPerTile));
            int yGraphDiff = (int) (yTileOffset * pixelsPerTile);

            yGraphDiff -= (int) (pixelsPerTile - Math.ceil(pixelsPerTile / 2));
            xGraphDiff += (int) (pixelsPerTile - Math.ceil(pixelsPerTile / 2));

            yGraphDiff = worldMapRect.height - yGraphDiff;
            yGraphDiff += (int) worldMapRect.getY();
            xGraphDiff += (int) worldMapRect.getX();

            return new Point(xGraphDiff, yGraphDiff);
        }
        return null;
    }

}
/*
 * Copyright (c) 2022, Mark
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package io.mark.f2p;

import com.google.inject.Provides;
import io.mark.f2p.config.ActiveType;
import io.mark.f2p.overlay.WorldMapOverlay;
import lombok.Getter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.GameState;
import net.runelite.api.ItemComposition;
import net.runelite.api.ScriptID;
import net.runelite.api.events.GameStateChanged;
import net.runelite.api.events.PostItemComposition;
import net.runelite.api.events.ScriptPostFired;
import net.runelite.api.events.WorldChanged;
import net.runelite.api.widgets.Widget;
import net.runelite.api.widgets.WidgetInfo;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.events.ConfigChanged;
import net.runelite.client.game.ItemManager;
import net.runelite.client.game.WorldService;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.plugins.PluginDescriptor;
import net.runelite.client.ui.overlay.OverlayManager;
import net.runelite.http.api.worlds.WorldType;

import javax.inject.Inject;
import java.awt.*;
import java.util.Objects;

@PluginDescriptor(
	name = "F2P Utilities",
	description = "Overlay members items with customizable visual effects (grayscale, outline, or fill)",
	tags = {"f2p", "members", "items", "overlay", "highlight", "grand exchange"}
)
@Slf4j
public class F2pPlugin extends Plugin
{

	@Inject
	@Getter
	private Client client;

	@Inject
	@Getter
	private F2pConfig config;

	@Inject
	@Getter
	private ItemManager itemManager;

	@Provides
	F2pConfig provideConfig(ConfigManager configManager)
	{
		return configManager.getConfig(F2pConfig.class);
	}

	@Inject
	private ClientThread clientThread;

	@Inject
	WorldService worldService;

    @Inject
    private OverlayManager overlayManager;

    @Inject
    private ItemOverlay overlay;

    @Inject
    private WorldMapOverlay worldMapOverlay;

	@Subscribe
	public void onGameStateChanged(GameStateChanged event) {
		if (event.getGameState() == GameState.LOGIN_SCREEN || event.getGameState() == GameState.LOGGING_IN) {
			overlay.invalidateAllCaches();
		}
	}

    @Override
    protected void startUp() {
        worldMapOverlay.loadPointsFromJson();
        overlayManager.add(overlay);
        overlayManager.add(worldMapOverlay);
    }

    @Override
    protected void shutDown() {
        overlayManager.remove(overlay);
        overlayManager.remove(worldMapOverlay);
        overlay.invalidateAllCaches();
        client.getItemCompositionCache().reset();
    }

	@Subscribe
	public void onPostItemComposition(PostItemComposition event) {
		ItemComposition item = event.getItemComposition();
		if(item.isMembers() && config.icon() != -1 && isActive()) {
			event.getItemComposition().setName(formatName(event.getItemComposition().getName()));
		}
	}

    @Subscribe
    public void onWorldChanged(WorldChanged event) {
        try {
            if (client == null || worldService == null) {
                return;
            }
            overlay.invalidateAllCaches();
        } catch (Exception e) {
            log.warn("Error handling world change", e);
            overlay.invalidateAllCaches();
        }
    }

	private String formatName(String name) {
		return "<img=" + config.icon() + ">" + name;
	}

	@Subscribe
	public void onConfigChanged(ConfigChanged event)
	{

		if (!event.getGroup().equals("f2p"))
		{
			return;
		}

		String key = event.getKey();

		switch (key) {
			case "overlayMode":
			case "overlayColor":
			case "overlayAlpha":
				overlay.invalidateCache();
			break;
		}

	}

	public boolean isActive() {
        ActiveType type = config.overlayActive();
		if (type == null) {
			return false;
		}
		
		if (type == ActiveType.ALWAYS) {
			return true;
		}
		
		if (type == ActiveType.NEVER) {
			return false;
		}
		
		if (type == ActiveType.FREE_WORLDS_ONLY) {
			try {
				if (client == null || worldService == null) {
					return false;
				}
				int world = client.getWorld();
				return !Objects.requireNonNull(worldService.getWorlds()).findWorld(world).getTypes().contains(WorldType.MEMBERS);
			} catch (Exception e) {
				return false;
			}
		}
		
		return false;
	}

}

package io.mark.f2p;

import com.google.common.cache.Cache;
import com.google.common.cache.CacheBuilder;
import com.google.inject.Inject;
import io.mark.f2p.config.OverlayMode;
import io.mark.f2p.overlay.CacheKey;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.widgets.WidgetItem;
import net.runelite.client.game.ItemManager;
import net.runelite.client.ui.overlay.WidgetItemOverlay;

import java.awt.*;
import java.awt.image.BufferedImage;
import java.util.concurrent.ExecutionException;

@Slf4j
public class ItemOverlay extends WidgetItemOverlay {

    private final ItemManager itemManager;
    private final F2pConfig config;
    private final F2pPlugin plugin;
    private final Cache<CacheKey, BufferedImage> imageCache;
    private final Cache<Integer, Boolean> membersCache;

    @Inject
    private ItemOverlay(ItemManager itemManager, F2pPlugin plugin, F2pConfig config) {
        this.itemManager = itemManager;
        this.config = config;
        this.plugin = plugin;
        this.imageCache = CacheBuilder.newBuilder()
                .maximumSize(1000)
                .build();
        this.membersCache = CacheBuilder.newBuilder()
                .maximumSize(1300)
                .build();

        showOnEquipment();
        showOnInventory();
        showOnBank();
    }



    @Override
    public void renderItemOverlay(Graphics2D graphics, int itemId, WidgetItem widgetItem)
    {
        if (!plugin.isActive()) {
            return;
        }
        if (!isMembers(itemId)) {
            return;
        }

        OverlayMode mode = config.overlayMode();
        Rectangle bounds = widgetItem.getCanvasBounds();
        Color color = null;
        
        if (mode == OverlayMode.OUTLINE || mode == OverlayMode.FILL) {
            Color baseColor = config.overlayColor();
            int alpha = config.overlayAlpha();
            color = new Color(baseColor.getRed(), baseColor.getGreen(), baseColor.getBlue(), alpha);
        }

        try {
            BufferedImage cachedImage = getCachedImage(itemId, widgetItem.getQuantity(), mode, color);
            if (cachedImage != null) {
                graphics.drawImage(cachedImage, (int) bounds.getX(), (int) bounds.getY(), null);
            }
        } catch (ExecutionException e) {
            log.info("Unable to Render item: " + itemId);
        }
    }

    private boolean isMembers(int itemId) {
        try {
            return membersCache.get(itemId, () -> {
                try {
                    return itemManager.getItemComposition(itemId).isMembers();
                } catch (Exception e) {
                    log.warn("Error checking members status for item: " + itemId, e);
                    return false;
                }
            });
        } catch (ExecutionException e) {
            log.warn("Error getting members status from cache for item: " + itemId, e);
            return false;
        }
    }

    private BufferedImage getCachedImage(int itemId, int quantity, OverlayMode mode, Color color) throws ExecutionException {
        CacheKey key = new CacheKey(itemId, quantity, mode, color);
        return imageCache.get(key, () -> {
            if (mode == OverlayMode.BLACK_AND_WHITE) {
                return createBlackAndWhiteImage(itemId, quantity);
            }
            else if (mode == OverlayMode.OUTLINE) {
                return itemManager.getItemOutline(itemId, quantity, color);
            }
            else if (mode == OverlayMode.FILL) {
                return createFillImage(itemId, quantity, color);
            }

            return null;
        });
    }

    private BufferedImage createBlackAndWhiteImage(int itemId, int quantity) {
        BufferedImage itemImage = itemManager.getImage(itemId, quantity, false);
        if (itemImage == null) {
            return null;
        }
        BufferedImage grayImage = new BufferedImage(itemImage.getWidth(), itemImage.getHeight(), BufferedImage.TYPE_INT_ARGB);
        Graphics2D g2d = grayImage.createGraphics();
        g2d.drawImage(itemImage, 0, 0, null);
        g2d.dispose();

        for (int y = 0; y < grayImage.getHeight(); y++) {
            for (int x = 0; x < grayImage.getWidth(); x++) {
                int rgb = grayImage.getRGB(x, y);
                int alpha = (rgb >> 24) & 0xFF;
                if (alpha > 0) {
                    int r = (rgb >> 16) & 0xFF;
                    int g = (rgb >> 8) & 0xFF;
                    int b = rgb & 0xFF;
                    int gray = (int) (0.299 * r + 0.587 * g + 0.114 * b);
                    grayImage.setRGB(x, y, (alpha << 24) | (gray << 16) | (gray << 8) | gray);
                }
            }
        }
        return grayImage;
    }

    private BufferedImage createFillImage(int itemId, int quantity, Color color) {
        BufferedImage itemImage = itemManager.getImage(itemId, quantity, false);
        if (itemImage == null) {
            return null;
        }
        BufferedImage filledImage = new BufferedImage(itemImage.getWidth(), itemImage.getHeight(), BufferedImage.TYPE_INT_ARGB);
        Graphics2D g2d = filledImage.createGraphics();
        g2d.drawImage(itemImage, 0, 0, null);
        g2d.setComposite(AlphaComposite.SrcAtop);
        g2d.setColor(color);
        g2d.fillRect(0, 0, itemImage.getWidth(), itemImage.getHeight());
        g2d.dispose();
        return filledImage;
    }


    public void invalidateCache() {
        imageCache.invalidateAll();
    }

    public void invalidateMembersCache() {
        membersCache.invalidateAll();
    }

    public void invalidateAllCaches() {
        imageCache.invalidateAll();
        membersCache.invalidateAll();
    }

}

/*
 * Copyright (c) 2022, Mark
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package io.mark.f2p.config;

import lombok.Getter;
import lombok.RequiredArgsConstructor;

@Getter
@RequiredArgsConstructor
public enum ActiveType {
    ALWAYS,
    NEVER,
    FREE_WORLDS_ONLY
}

/*
 * Copyright (c) 2022, Mark
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package io.mark.f2p.config;

import lombok.Getter;
import lombok.RequiredArgsConstructor;

@Getter
@RequiredArgsConstructor
public enum OverlayMode {
    BLACK_AND_WHITE,
    OUTLINE,
    FILL
}


package io.mark.f2p.overlay;

import com.google.inject.Singleton;

import java.awt.*;
import java.awt.color.ColorSpace;
import java.awt.geom.Area;
import java.awt.geom.GeneralPath;
import java.awt.geom.Line2D;
import java.awt.geom.Path2D;
import java.awt.image.BufferedImage;
import java.awt.image.ColorConvertOp;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.nio.charset.StandardCharsets;
import java.util.ArrayList;
import java.util.List;
import javax.inject.Inject;

import com.google.gson.Gson;
import com.google.gson.reflect.TypeToken;

import io.mark.f2p.F2pConfig;
import io.mark.f2p.F2pPlugin;
import io.mark.f2p.utils.WorldPerspective;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.*;
import net.runelite.api.Point;
import net.runelite.api.coords.*;
import net.runelite.client.ui.overlay.Overlay;
import net.runelite.client.ui.overlay.OverlayLayer;
import net.runelite.client.ui.overlay.OverlayManager;
import net.runelite.client.ui.overlay.OverlayPosition;


@Slf4j
@Singleton
public class WorldMapOverlay extends Overlay {

    @Inject
    private Client client;

    @Inject
    private OverlayManager overlayManager;

    @Inject
    private F2pConfig config;

    @Inject
    private F2pPlugin f2pPlugin;

    @Inject
    private Gson gson;

    private List<int[]> pts;
    private List<OverrideArea> overrideNonMembers;
    private List<OverrideArea> overrideMembers;
    
    private float cachedZoom = -1;
    private Point cachedMapPosition = null;
    private Rectangle cachedMapViewArea = null;
    private GeneralPath cachedF2pPolygon = null;
    private List<GeneralPath> cachedOverridePolygons = null;
    private Rectangle cachedGrayscaleBoundsRect = null;
    private Area cachedF2pArea = null;

    public void loadPointsFromJson() {
        try {
            InputStream inputStream = WorldMapOverlay.class.getResourceAsStream("/f2p-area.json");
            if (inputStream == null) {
                log.warn("Could not find f2p-area.json resource, using empty lists");
                this.pts = new ArrayList<>();
                this.overrideNonMembers = new ArrayList<>();
                this.overrideMembers = new ArrayList<>();
                return;
            }

            F2pAreaData data = gson.fromJson(new InputStreamReader(inputStream, StandardCharsets.UTF_8), F2pAreaData.class);
            
            if (data != null) {
                this.pts = data.points != null ? data.points : new ArrayList<>();
                this.overrideNonMembers = data.overrideNonMembers != null ? data.overrideNonMembers : new ArrayList<>();
                this.overrideMembers = data.overrideMembers != null ? data.overrideMembers : new ArrayList<>();
            } else {
                this.pts = new ArrayList<>();
                this.overrideNonMembers = new ArrayList<>();
                this.overrideMembers = new ArrayList<>();
            }
            
            inputStream.close();
            log.info("Loaded {} points, {} override non-members, and {} override members from f2p-area.json", 
                this.pts.size(), this.overrideNonMembers.size(), this.overrideMembers.size());
        } catch (Exception e) {
            log.error("Error loading points from JSON", e);
            this.pts = new ArrayList<>();
            this.overrideNonMembers = new ArrayList<>();
            this.overrideMembers = new ArrayList<>();
        }
    }
    
    private static class F2pAreaData {
        List<int[]> points;
        List<OverrideArea> overrideNonMembers;
        List<OverrideArea> overrideMembers;
    }
    
    private static class OverrideArea {
        String name;
        List<int[]> points;
    }


    public WorldMapOverlay() {
        setLayer(OverlayLayer.ABOVE_WIDGETS);
        setPosition(OverlayPosition.DYNAMIC);
    }

    @Override
    public Dimension render(Graphics2D graphics) {
        if (!f2pPlugin.isActive()) {
            return null;
        }
        Rectangle mapViewArea = WorldPerspective.getWorldMapClipArea(client);
        if (mapViewArea == null) {
            return null;
        }

        if (!config.showMapOverlay()) {
            return null;
        }
        
        var worldMap = client.getWorldMap();
        if (worldMap == null) {
            return null;
        }
        
        float currentZoom = worldMap.getWorldMapZoom();
        Point currentMapPosition = worldMap.getWorldMapPosition();
        boolean mapStateChanged = cachedZoom != currentZoom || 
                                  cachedMapPosition == null || 
                                  !cachedMapPosition.equals(currentMapPosition);
        
        boolean viewAreaChanged = cachedMapViewArea == null || 
                                  !cachedMapViewArea.equals(mapViewArea);
        
        if (mapStateChanged) {
            invalidateMapCache();
            cachedZoom = currentZoom;
            cachedMapPosition = currentMapPosition;
        }
        
        if (viewAreaChanged) {
            cachedGrayscaleBoundsRect = null;
            cachedMapViewArea = mapViewArea;
        }

        applyGrayscaleOverlay(graphics, client, mapViewArea, mapStateChanged, viewAreaChanged);
        drawBlackBorder(graphics, client, mapViewArea);

        return null;
    }
    
    private void invalidateMapCache() {
        cachedF2pPolygon = null;
        cachedOverridePolygons = null;
        cachedGrayscaleBoundsRect = null;
        cachedF2pArea = null;
        cachedMapViewArea = null;
    }

    private Rectangle getGrayscaleBoundsRect(Client client, Rectangle mapViewArea) {
        if (cachedGrayscaleBoundsRect != null) {
            return cachedGrayscaleBoundsRect;
        }
        
        try {
            int bottomRightX = 4030, bottomRightY = 2049;
            int bottomLeftX = 960, bottomLeftY = 2049;
            int topLeftX = 960, topLeftY = 4222;
            int topRightX = 4030, topRightY = 4222;
            
            net.runelite.api.Point topLeft = WorldPerspective.mapWorldPointToGraphicsPoint(client, new WorldPoint(topLeftX, topLeftY, 0));
            net.runelite.api.Point topRight = WorldPerspective.mapWorldPointToGraphicsPoint(client, new WorldPoint(topRightX, topRightY, 0));
            net.runelite.api.Point bottomLeft = WorldPerspective.mapWorldPointToGraphicsPoint(client, new WorldPoint(bottomLeftX, bottomLeftY, 0));
            net.runelite.api.Point bottomRight = WorldPerspective.mapWorldPointToGraphicsPoint(client, new WorldPoint(bottomRightX, bottomRightY, 0));
            
            if (topLeft != null && topRight != null && bottomLeft != null && bottomRight != null) {
                int minX = Math.min(Math.min(topLeft.getX(), topRight.getX()), Math.min(bottomLeft.getX(), bottomRight.getX()));
                int maxX = Math.max(Math.max(topLeft.getX(), topRight.getX()), Math.max(bottomLeft.getX(), bottomRight.getX()));
                int minY = Math.min(Math.min(topLeft.getY(), topRight.getY()), Math.min(bottomLeft.getY(), bottomRight.getY()));
                int maxY = Math.max(Math.max(topLeft.getY(), topRight.getY()), Math.max(bottomLeft.getY(), bottomRight.getY()));
                
                cachedGrayscaleBoundsRect = new Rectangle(minX, minY, maxX - minX, maxY - minY);
                return cachedGrayscaleBoundsRect;
            }
            
            cachedGrayscaleBoundsRect = mapViewArea;
            return cachedGrayscaleBoundsRect;
        } catch (Exception e) {
            log.warn("Error creating grayscale bounds rect", e);
            cachedGrayscaleBoundsRect = mapViewArea;
            return cachedGrayscaleBoundsRect;
        }
    }

    private GeneralPath createPolygonFromPoints(Client client, List<int[]> points) {
        if (points == null || points.isEmpty()) {
            return null;
        }
        
        GeneralPath polygon = new GeneralPath(Path2D.WIND_EVEN_ODD);
        boolean first = true;
        int validPoints = 0;
        
        for (int[] point : points) {
            int x = point[0];
            int y = point[1];
            net.runelite.api.Point graphicsPoint = WorldPerspective.mapWorldPointToGraphicsPoint(client, new WorldPoint(x, y, 0));
            if (graphicsPoint == null) {
                continue;
            }
            
            if (first) {
                polygon.moveTo(graphicsPoint.getX(), graphicsPoint.getY());
                first = false;
                validPoints++;
            } else {
                polygon.lineTo(graphicsPoint.getX(), graphicsPoint.getY());
                validPoints++;
            }
        }
        
        if (validPoints < 3) {
            return null;
        }
        
        polygon.closePath();
        return polygon;
    }
    
    private GeneralPath getOrCreateF2pPolygon(Client client, boolean forceRecalculate) {
        if (!forceRecalculate && cachedF2pPolygon != null) {
            return cachedF2pPolygon;
        }
        
        cachedF2pPolygon = createPolygonFromPoints(client, pts);
        return cachedF2pPolygon;
    }
    
    private List<GeneralPath> getOrCreateOverridePolygons(Client client, boolean forceRecalculate) {
        if (!forceRecalculate && cachedOverridePolygons != null) {
            return cachedOverridePolygons;
        }
        
        cachedOverridePolygons = new ArrayList<>();
        for (OverrideArea overrideArea : overrideNonMembers) {
            if (overrideArea.points != null) {
                GeneralPath overridePath = createPolygonFromPoints(client, overrideArea.points);
                if (overridePath != null) {
                    cachedOverridePolygons.add(overridePath);
                }
            }
        }
        return cachedOverridePolygons;
    }
    
    private List<GeneralPath> getOrCreateOverrideMembersPolygons(Client client, boolean forceRecalculate) {
        List<GeneralPath> overrideMembersPolygons = new ArrayList<>();
        for (OverrideArea overrideArea : overrideMembers) {
            if (overrideArea.points != null) {
                GeneralPath overridePath = createPolygonFromPoints(client, overrideArea.points);
                if (overridePath != null) {
                    overrideMembersPolygons.add(overridePath);
                }
            }
        }
        return overrideMembersPolygons;
    }
    
    private Area getOrCreateF2pArea(Client client, boolean forceRecalculate) {
        if (!forceRecalculate && cachedF2pArea != null) {
            return cachedF2pArea;
        }
        
        GeneralPath f2pPolygon = getOrCreateF2pPolygon(client, forceRecalculate);
        if (f2pPolygon == null) {
            return null;
        }
        
        cachedF2pArea = new Area(f2pPolygon);
        
        List<GeneralPath> overridePolygons = getOrCreateOverridePolygons(client, forceRecalculate);
        for (GeneralPath overridePath : overridePolygons) {
            cachedF2pArea.subtract(new Area(overridePath));
        }
        
        return cachedF2pArea;
    }

    private void applyGrayscaleOverlay(Graphics2D graphics, Client client, Rectangle mapViewArea, boolean mapStateChanged, boolean viewAreaChanged) {
        try {
            Rectangle grayscaleBoundsRect = getGrayscaleBoundsRect(client, mapViewArea);
            if (grayscaleBoundsRect == null || grayscaleBoundsRect.isEmpty()) {
                return;
            }
            
            Area grayscaleArea = new Area(grayscaleBoundsRect);
            
            Area f2pArea = getOrCreateF2pArea(client, mapStateChanged);
            if (f2pArea != null) {
                grayscaleArea.subtract(f2pArea);
                
                List<GeneralPath> overridePolygons = getOrCreateOverridePolygons(client, mapStateChanged);
                for (GeneralPath overridePath : overridePolygons) {
                    grayscaleArea.add(new Area(overridePath));
                }
            }
            
            List<GeneralPath> overrideMembersPolygons = getOrCreateOverrideMembersPolygons(client, mapStateChanged);
            for (GeneralPath overridePath : overrideMembersPolygons) {
                grayscaleArea.subtract(new Area(overridePath));
            }
            
            grayscaleArea.intersect(new Area(mapViewArea));
            
            if (grayscaleArea.isEmpty()) {
                return;
            }

            Composite originalComposite = graphics.getComposite();
            Shape originalClip = graphics.getClip();
            
            Rectangle clipRect = mapViewArea.intersection(grayscaleBoundsRect);
            graphics.setClip(clipRect);
            
            Color fillColor = config.mapFillColor();
            int alpha = config.mapAlpha();
            Color fillColorWithAlpha = new Color(fillColor.getRed(), fillColor.getGreen(), fillColor.getBlue(), alpha);
            
            graphics.setComposite(AlphaComposite.getInstance(AlphaComposite.SRC_OVER, alpha / 255.0f));
            graphics.setColor(fillColorWithAlpha);
            graphics.fill(grayscaleArea);
            
            graphics.setComposite(AlphaComposite.getInstance(AlphaComposite.SRC_ATOP, 0.4f));
            graphics.setColor(new Color(150, 150, 150, 180));
            graphics.fill(grayscaleArea);
            
            graphics.setComposite(originalComposite);
            graphics.setClip(originalClip);
        } catch (Exception e) {
            log.warn("Error applying grayscale overlay", e);
        }
    }

    private void drawBlackBorder(Graphics2D graphics, Client client, Rectangle mapViewArea) {
        try {
            GeneralPath f2pPolygon = getOrCreateF2pPolygon(client, false);
            if (f2pPolygon == null) {
                return;
            }

            Stroke originalStroke = graphics.getStroke();
            Shape originalClip = graphics.getClip();
            
            graphics.setClip(mapViewArea);
            
            Color borderColor = config.mapBorderColor();
            float borderThickness = config.mapBorderThickness();
            
            graphics.setStroke(new BasicStroke(borderThickness, BasicStroke.CAP_ROUND, BasicStroke.JOIN_ROUND));
            graphics.setColor(borderColor);
            graphics.draw(f2pPolygon);
            
            List<GeneralPath> overridePolygons = getOrCreateOverridePolygons(client, false);
            for (GeneralPath overridePath : overridePolygons) {
                graphics.draw(overridePath);
            }
            
            graphics.setStroke(originalStroke);
            graphics.setClip(originalClip);
        } catch (Exception e) {
            log.warn("Error drawing border", e);
        }
    }

}
package io.mark.f2p.overlay;

import io.mark.f2p.config.OverlayMode;

import java.awt.*;
import java.util.Objects;

public class CacheKey {
    private final int itemId;
    private final int quantity;
    private final OverlayMode mode;
    private final int colorHash;

    public CacheKey(int itemId, int quantity, OverlayMode mode, Color color) {
        this.itemId = itemId;
        this.quantity = quantity;
        this.mode = mode;
        this.colorHash = color != null ? color.hashCode() : 0;
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        CacheKey cacheKey = (CacheKey) o;
        return itemId == cacheKey.itemId &&
                quantity == cacheKey.quantity &&
                colorHash == cacheKey.colorHash &&
                mode == cacheKey.mode;
    }

    @Override
    public int hashCode() {
        return Objects.hash(itemId, quantity, mode, colorHash);
    }
}
/*
 * Copyright (c) 2022, Mark
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package io.mark.f2p;

import io.mark.f2p.config.ActiveType;
import io.mark.f2p.config.OverlayMode;
import net.runelite.client.config.*;

import java.awt.*;

@ConfigGroup(F2pConfig.GROUP)
public interface F2pConfig extends Config
{
	String GROUP = "f2p";

    @ConfigItem(
            keyName = "overlayActive",
            name = "Overlay Active",
            description = "When to show the overlay: Always, Never, or Only on Members Worlds",
            position = 0
    )
    default ActiveType overlayActive()
    {
        return ActiveType.FREE_WORLDS_ONLY;
    }


    @ConfigSection(
			name = "Item Overlay",
			description = "Item Overlay Settings",
			position = 1
	)
	String itemOverlaySettings = "itemoverlaysettings";

	@Range(
			min = -1,
			max = 390
	)
	@ConfigItem(
			keyName = "icon",
			name = "Item Icon",
			description = "Icon that shows if f2p (-1 = none)",
			position = 1,
			section = itemOverlaySettings
	)
	default int icon()
	{
		return -1;
	}

	@ConfigItem(
			keyName = "overlayMode",
			name = "Item Mode",
			description = "Select the rendering mode for item overlays: Black and White (grayscale), Outline (colored outline), or Fill (colored fill)",
			position = 2,
			section = itemOverlaySettings
	)
	default OverlayMode overlayMode()
	{
		return OverlayMode.BLACK_AND_WHITE;
	}

	@ConfigItem(
			keyName = "overlayColor",
			name = "Item Overlay Color",
			description = "Color for outline and fill overlay modes",
			position = 3,
			section = itemOverlaySettings
	)
	default Color overlayColor()
	{
		return Color.RED;
	}

	@Range(max = 255)
	@ConfigItem(
			keyName = "overlayAlpha",
			name = "Item Overlay Alpha",
			description = "Transparency for overlay (0 = fully transparent, 255 = fully opaque)",
			position = 4,
			section = itemOverlaySettings
	)
	default int overlayAlpha()
	{
		return 125;
	}

	@ConfigSection(
			name = "World Map",
			description = "World Map Overlay Settings",
			position = 1
	)
	String worldMapSettings = "worldmapsettings";

	@ConfigItem(
			keyName = "showMapOverlay",
			name = "Show Map Overlay",
			description = "Show the grayscale overlay and border on the world map",
			position = 1,
			section = worldMapSettings
	)
	default boolean showMapOverlay()
	{
		return true;
	}

	@ConfigItem(
			keyName = "mapBorderColor",
			name = "Border Color",
			description = "Color for the F2P area border on the world map",
			position = 2,
			section = worldMapSettings
	)
	default Color mapBorderColor()
	{
		return Color.BLACK;
	}

	@Range(
			min = 1,
			max = 10
	)
	@ConfigItem(
			keyName = "mapBorderThickness",
			name = "Border Thickness",
			description = "Thickness of the F2P area border (1-10)",
			position = 3,
			section = worldMapSettings
	)
	default int mapBorderThickness()
	{
		return 2;
	}

	@ConfigItem(
			keyName = "mapFillColor",
			name = "Fill Color",
			description = "Color for the grayscale overlay fill (outside F2P area)",
			position = 4,
			section = worldMapSettings
	)
	default Color mapFillColor()
	{
		return new Color(128, 128, 128);
	}

	@Range(
			min = 0,
			max = 255
	)
	@ConfigItem(
			keyName = "mapAlpha",
			name = "Overlay Alpha",
			description = "Transparency for the grayscale overlay (0 = fully transparent, 255 = fully opaque)",
			position = 5,
			section = worldMapSettings
	)
	default int mapAlpha()
	{
		return 125;
	}

}

package io.mark.f2p;

import net.runelite.client.RuneLite;
import net.runelite.client.externalplugins.ExternalPluginManager;

public class F2pPluginLauncher
{
	public static void main(String[] args) throws Exception
	{
		ExternalPluginManager.loadBuiltin(F2pPlugin.class);
		RuneLite.main(args);
	}
}
