/*
 * Copyright (c) 2021, Andrew McAdams
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.andmcadams.shootingstars;

import java.awt.Dimension;
import java.awt.Graphics2D;
import javax.inject.Inject;
import net.runelite.client.ui.overlay.OverlayPanel;
import net.runelite.client.ui.overlay.OverlayPosition;
import net.runelite.client.ui.overlay.OverlayPriority;
import net.runelite.client.ui.overlay.components.LineComponent;

public class ShootingStarsOverlayPanel extends OverlayPanel
{
	private final ShootingStarsPlugin plugin;

	@Inject
	private ShootingStarsOverlayPanel(ShootingStarsPlugin plugin)
	{
		super(plugin);
		this.plugin = plugin;

		setPosition(OverlayPosition.TOP_LEFT);
		setPriority(OverlayPriority.HIGH);
	}

	@Override
	public Dimension render(Graphics2D graphics)
	{
		panelComponent.getChildren().clear();

		if (plugin.isPostError())
		{
			LineComponent l = LineComponent.builder().left("Shooting Stars Error: Failed to post, check POST endpoint in config").build();
			panelComponent.getChildren().add(l);
		}
		if (plugin.isGetError())
		{
			LineComponent l = LineComponent.builder().left("Shooting Stars Error: Failed to get, check GET endpoint in config").build();
			panelComponent.getChildren().add(l);
		}
		if (plugin.isKeyError())
		{
			LineComponent l = LineComponent.builder().left("Key error: Please set a valid key in the plugin config. Valid keys are 1-10 alpha characters").build();
			panelComponent.getChildren().add(l);
		}
		return super.render(graphics);
	}
}

/*
 * Copyright (c) 2021, Andrew McAdams
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.andmcadams.shootingstars;

import com.andmcadams.shootingstars.ui.ShootingStarsPanelType;
import net.runelite.client.config.Config;
import net.runelite.client.config.ConfigGroup;
import net.runelite.client.config.ConfigItem;
import net.runelite.client.config.ConfigSection;
import net.runelite.client.config.Range;
import net.runelite.client.config.Units;

@ConfigGroup(ShootingStarsPlugin.CONFIG_GROUP_KEY)
public interface ShootingStarsConfig extends Config
{
	String SHOOTING_STAR_POST_ENDPOINT_KEYNAME = "post endpoint";
	String SHOOTING_STAR_GET_ENDPOINT_KEYNAME = "get endpoint";
	String SHOOTING_STAR_SHARED_KEY_KEYNAME = "password";
	String SHOOTING_STAR_EXPIRATION_LENGTH = "expiration";
	String SHOOTING_STAR_PANEL_CLASS = "panelclass";
	String SHOOTING_STAR_SHOW_PVP_WORLDS_KEYNAME = "pvp worlds";
	String SHOOTING_STAR_SHOW_ASGARNIA_KEYNAME = "asgarnia";
	String SHOOTING_STAR_SHOW_KARAMJA_KEYNAME = "karamja";
	String SHOOTING_STAR_SHOW_FELDIP_HILLS_KEYNAME = "feldip hills";
	String SHOOTING_STAR_SHOW_FOSSIL_ISLAND_KEYNAME = "fossil island";
	String SHOOTING_STAR_SHOW_FREMENNIK_KEYNAME = "fremennik";
	String SHOOTING_STAR_SHOW_KOUREND_KEYNAME = "kourend";
	String SHOOTING_STAR_SHOW_KANDARIN_KEYNAME = "kandarin";
	String SHOOTING_STAR_SHOW_KEBOS_KEYNAME = "kebos";
	String SHOOTING_STAR_SHOW_KHARIDIAN_DESERT_KEYNAME = "desert";
	String SHOOTING_STAR_SHOW_MISTHALIN_KEYNAME = "misthalin";
	String SHOOTING_STAR_SHOW_MORYTANIA_KEYNAME = "morytania";
	String SHOOTING_STAR_SHOW_PISCATORIS_KEYNAME = "piscatoris";
	String SHOOTING_STAR_SHOW_TIRANNWN_KEYNAME = "tirannwn";
	String SHOOTING_STAR_SHOW_WILDERNESS_KEYNAME = "wilderness";
	String SHOOTING_STAR_SHOW_VARLAMORE_KEYNAME = "varlamore";
	String SHOOTING_STAR_SHOW_SKILL_TOTAL_KEYNAME = "skill total";
	String SHOOTING_STAR_SHOW_SIDEBAR_ICON = "sidebar icon";

	@ConfigItem(keyName = SHOOTING_STAR_POST_ENDPOINT_KEYNAME, position = 0, name = "POST endpoint", description = "Web endpoint to post star data to")
	default String shootingStarPostEndpointConfig()
	{
		return "";
	}

	@ConfigItem(keyName = SHOOTING_STAR_GET_ENDPOINT_KEYNAME, position = 1, name = "GET endpoint", description = "Web endpoint to get star data from")
	default String shootingStarGetEndpointConfig()
	{
		return "";
	}

	@ConfigItem(keyName = SHOOTING_STAR_SHARED_KEY_KEYNAME, position = 2, name = "Key", description = "A keyword to use to share stars with friends. Must be 1-10 alpha characters")
	default String shootingStarSharedKeyConfig()
	{
		return "global";
	}

	@ConfigItem(
		keyName = SHOOTING_STAR_EXPIRATION_LENGTH,
		position = 2,
		name = "Show landed stars for",
		description = "How many minutes landed stars should remain listed in the side panel<br>" +
			"Different APIs may return less than the maximum of 120 minutes"
	)
	@Range(
		max = 120
	)
	@Units(
		value = Units.MINUTES
	)
	default int shootingStarExpirationLength()
	{
		return 5;
	}

	@ConfigItem(
		keyName = SHOOTING_STAR_PANEL_CLASS,
		position = 3,
		name = "Stars Panel",
		description = "Choose the shooting stars panel implementation"
	)
	default ShootingStarsPanelType shootingStarsPanelType()
	{
		return ShootingStarsPanelType.CONDENSED;
	}

	@ConfigItem(
		keyName = "worldHopperEnabled",
		position = 4,
		name = "Double click to Hop",
		description = "Enables double clicking worlds in the side view panels to quick-hop to them"
	)
	default boolean isWorldHopperEnabled()
	{
		return true;
	}

	@ConfigSection(
		name = "World Toggles",
		description = "Settings to show and hide certain types of worlds from the list of scouted worlds",
		position = 5
	)
	String toggleSection = "World Toggles";

	@ConfigItem(
		keyName = SHOOTING_STAR_SHOW_PVP_WORLDS_KEYNAME,
		position = 3,
		name = "PVP worlds",
		description = "Show scouted PVP worlds",
		section = toggleSection
	)
	default boolean shootingStarShowPvpWorlds()
	{
		return false;
	}

	@ConfigItem(
		keyName = SHOOTING_STAR_SHOW_WILDERNESS_KEYNAME,
		position = 4,
		name = "Wilderness",
		description = "Show scouted Wilderness worlds",
		section = toggleSection
	)
	default boolean shootingStarShowWildernessWorlds()
	{
		return false;
	}

	@ConfigItem(
		keyName = SHOOTING_STAR_SHOW_SKILL_TOTAL_KEYNAME,
		position = 5,
		name = "Skill Total worlds",
		description = "Show scouted Skill Total worlds",
		section = toggleSection
	)
	default boolean shootingStarShowSkillTotalWorlds()
	{
		return true;
	}

	@ConfigItem(
		keyName = SHOOTING_STAR_SHOW_ASGARNIA_KEYNAME,
		position = 6,
		name = "Asgarnia",
		description = "Show scouted Asgarnia worlds",
		section = toggleSection
	)
	default boolean shootingStarShowAsgarniaWorlds()
	{
		return true;
	}

	@ConfigItem(
		keyName = SHOOTING_STAR_SHOW_KARAMJA_KEYNAME,
		position = 7,
		name = "Crandor and Karamja",
		description = "Show scouted Crandor and Karamja worlds",
		section = toggleSection
	)
	default boolean shootingStarShowKaramjaWorlds()
	{
		return true;
	}

	@ConfigItem(
		keyName = SHOOTING_STAR_SHOW_FELDIP_HILLS_KEYNAME,
		position = 8,
		name = "Feldip Hills and Isle of Souls",
		description = "Show scouted Feldip Hills and Isle of Souls worlds",
		section = toggleSection
	)
	default boolean shootingStarShowFeldipWorlds()
	{
		return true;
	}

	@ConfigItem(
		keyName = SHOOTING_STAR_SHOW_FOSSIL_ISLAND_KEYNAME,
		position = 9,
		name = "Fossil Island and Mos Le'Harmless",
		description = "Show scouted Fossil Island and Mos Le'Harmless worlds",
		section = toggleSection
	)
	default boolean shootingStarShowFossilIslandWorlds()
	{
		return true;
	}

	@ConfigItem(
		keyName = SHOOTING_STAR_SHOW_FREMENNIK_KEYNAME,
		position = 10,
		name = "Fremennik Lands and Lunar Isle",
		description = "Show scouted Fremennik Lands and Lunar Isle worlds",
		section = toggleSection
	)
	default boolean shootingStarShowFremennikWorlds()
	{
		return true;
	}

	@ConfigItem(
		keyName = SHOOTING_STAR_SHOW_KOUREND_KEYNAME,
		position = 11,
		name = "Great Kourend",
		description = "Show scouted Great Kourend worlds",
		section = toggleSection
	)
	default boolean shootingStarShowKourendWorlds()
	{
		return true;
	}

	@ConfigItem(
		keyName = SHOOTING_STAR_SHOW_KANDARIN_KEYNAME,
		position = 12,
		name = "Kandarin",
		description = "Show scouted Kandarin worlds",
		section = toggleSection
	)
	default boolean shootingStarShowKandarinWorlds()
	{
		return true;
	}

	@ConfigItem(
		keyName = SHOOTING_STAR_SHOW_KEBOS_KEYNAME,
		position = 13,
		name = "Kebos Lowlands",
		description = "Show scouted Kebos Lowlands worlds",
		section = toggleSection
	)
	default boolean shootingStarShowKebosWorlds()
	{
		return true;
	}

	@ConfigItem(
		keyName = SHOOTING_STAR_SHOW_KHARIDIAN_DESERT_KEYNAME,
		position = 14,
		name = "Kharidian Desert",
		description = "Show scouted Kharidian Desert worlds",
		section = toggleSection
	)
	default boolean shootingStarShowDesertWorlds()
	{
		return true;
	}

	@ConfigItem(
		keyName = SHOOTING_STAR_SHOW_MISTHALIN_KEYNAME,
		position = 15,
		name = "Misthalin",
		description = "Show scouted Misthalin worlds",
		section = toggleSection
	)
	default boolean shootingStarShowMisthalinWorlds()
	{
		return true;
	}

	@ConfigItem(
		keyName = SHOOTING_STAR_SHOW_MORYTANIA_KEYNAME,
		position = 16,
		name = "Morytania",
		description = "Show scouted Morytania worlds",
		section = toggleSection
	)
	default boolean shootingStarShowMorytaniaWorlds()
	{
		return true;
	}

	@ConfigItem(
		keyName = SHOOTING_STAR_SHOW_PISCATORIS_KEYNAME,
		position = 17,
		name = "Piscatoris and the Gnome Stronghold",
		description = "Show scouted Piscatoris and Gnome Stronghold worlds",
		section = toggleSection
	)
	default boolean shootingStarShowPiscatorisWorlds()
	{
		return true;
	}

	@ConfigItem(
		keyName = SHOOTING_STAR_SHOW_TIRANNWN_KEYNAME,
		position = 18,
		name = "Tirannwn",
		description = "Show scouted Tirannwn worlds",
		section = toggleSection
	)
	default boolean shootingStarShowTirannwnWorlds()
	{
		return true;
	}

	@ConfigItem(
		keyName = SHOOTING_STAR_SHOW_VARLAMORE_KEYNAME,
		position = 19,
		name = "Varlamore",
		description = "Show scouted Varlamore worlds",
		section = toggleSection
	)
	default boolean shootingStarShowVarlamoreWorlds()
	{
		return true;
	}

	@ConfigItem(
			keyName = SHOOTING_STAR_SHOW_SIDEBAR_ICON,
			position = 19,
			name = "Show side panel",
			description = "Show the side panel with landing times"
	)
	default boolean showSidebarIcon() {
		return true;
	}
}
/*
 * Copyright (c) 2021, Andrew McAdams
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.andmcadams.shootingstars.ui.panels;

import com.andmcadams.shootingstars.ShootingStarsData;
import com.andmcadams.shootingstars.ShootingStarsPlugin;
import com.andmcadams.shootingstars.ui.ShootingStarsPluginPanelBase;
import java.awt.BorderLayout;
import java.awt.Color;
import java.awt.GridBagConstraints;
import java.awt.GridBagLayout;
import java.awt.Insets;
import java.util.ArrayList;
import java.util.List;
import javax.swing.JLabel;
import javax.swing.JPanel;
import javax.swing.JScrollPane;
import javax.swing.ScrollPaneConstants;
import javax.swing.border.EmptyBorder;
import net.runelite.client.ui.ColorScheme;

public class ShootingStarsPluginPanel extends ShootingStarsPluginPanelBase
{
	FixedWidthPanel starsListPanel = new FixedWidthPanel();
	ArrayList<ShootingStarsSinglePanel> starsList = new ArrayList<>();

	private JScrollPane scrollPane;
	private GridBagConstraints c = new GridBagConstraints();

	public ShootingStarsPluginPanel(ShootingStarsPlugin plugin)
	{
		super(plugin, false);

		setBackground(ColorScheme.DARK_GRAY_COLOR);
		setLayout(new BorderLayout());

		// Create the container for the title and refresh task button
		JPanel topContainer = new JPanel();
		topContainer.setLayout(new BorderLayout());

		JPanel titlePanel = new JPanel();
		titlePanel.setBorder(new EmptyBorder(10, 10, 10, 10));
		titlePanel.setLayout(new BorderLayout());

		JLabel title = new JLabel();
		title.setText("Shooting Stars");
		title.setForeground(Color.WHITE);
		titlePanel.add(title, BorderLayout.WEST);
		topContainer.add(titlePanel, BorderLayout.NORTH);

		add(topContainer, BorderLayout.NORTH);

		// Create the task list panel
		starsListPanel.setLayout(new GridBagLayout());
		starsListPanel.setBackground(ColorScheme.DARK_GRAY_COLOR);
		c.insets = new Insets(0, 2, 2, 2);
		c.fill = GridBagConstraints.HORIZONTAL;
		c.weightx = 1;
		c.gridx = 0;
		c.anchor = GridBagConstraints.PAGE_START;

		scrollPane = new JScrollPane(starsListPanel);
		scrollPane.setHorizontalScrollBarPolicy(ScrollPaneConstants.HORIZONTAL_SCROLLBAR_NEVER);
		scrollPane.setBorder(new EmptyBorder(1, 0, 0, 0));
		scrollPane.setBackground(ColorScheme.DARKER_GRAY_COLOR);

		add(scrollPane, BorderLayout.CENTER);
	}

	public void addStar(JPanel shootingStarsPanel, ShootingStarsData data)
	{
		ShootingStarsSinglePanel starsSinglePanel = new ShootingStarsSinglePanel(data, plugin::hopTo);
		starsSinglePanel.createRightClickMenu(this);
		shootingStarsPanel.add(starsSinglePanel, c);
		c.gridy += 1;
		starsList.add(starsSinglePanel);
	}

	@Override
	public void populate(List<ShootingStarsData> starsData)
	{
		c.gridy = 0;
		c.weighty = 0;
		// Remove all old panels
		for (ShootingStarsSinglePanel starsSinglePanel : starsList)
		{
			starsListPanel.remove(starsSinglePanel);
		}
		starsList.clear();

		// Add new panels. Need to keep track of the last one to give it extra weighty (to put all extra space after it)
		ShootingStarsData lastData = null;
		for (ShootingStarsData starData : starsData)
		{
			if (lastData != null)
				addStar(starsListPanel, lastData);
			lastData = starData;
		}

		// Add the last panel with weighty 1
		c.weighty = 1;
		if (lastData != null)
			addStar(starsListPanel, lastData);

		repaint();
		revalidate();
	}

	@Override
	public void updateList()
	{
		for (ShootingStarsSinglePanel starsSinglePanel : starsList)
		{
			starsSinglePanel.updateLabels();
		}
	}

}

/*
 * Copyright (c) 2017, Adam <Adam@sigterm.info>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.andmcadams.shootingstars.ui.panels;

import java.awt.Dimension;
import javax.swing.JPanel;
import net.runelite.client.ui.PluginPanel;

class FixedWidthPanel extends JPanel
{
	@Override
	public Dimension getPreferredSize()
	{
		return new Dimension(PluginPanel.PANEL_WIDTH, super.getPreferredSize().height);
	}

}

/*
 * Copyright (c) 2021, Andrew McAdams
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.andmcadams.shootingstars.ui.panels;

import com.andmcadams.shootingstars.ShootingStarsData;
import com.andmcadams.shootingstars.ui.condensed.ShootingStarsCondensedPluginPanel;
import java.awt.BorderLayout;
import java.awt.Color;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.util.function.Consumer;
import javax.swing.JLabel;
import javax.swing.JMenuItem;
import javax.swing.JPanel;
import javax.swing.JPopupMenu;
import javax.swing.SwingConstants;
import javax.swing.border.EmptyBorder;
import lombok.Getter;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.DynamicGridLayout;
import net.runelite.client.ui.FontManager;

public class ShootingStarsSinglePanel extends JPanel
{

	private static final Color INCOMING = Color.YELLOW;
	private static final Color LANDED = Color.GREEN;

	private JLabel nameLabel;
	private JLabel world;
	private JLabel time;

	@Getter
	private ShootingStarsData starData;

	private Color lastBackground;

	public ShootingStarsSinglePanel(ShootingStarsData starData, Consumer<Integer> onSelect)
	{
		super();
		this.starData = starData;

		setLayout(new DynamicGridLayout(2, 1, 0, 5));
		setBorder(new EmptyBorder(5, 5, 5, 5));
		setBackground(ColorScheme.DARKER_GRAY_COLOR);

		JPanel topPanel = new JPanel(new BorderLayout());
		topPanel.setOpaque(false);

		world = new JLabel("World " + starData.getWorld());
		nameLabel = new JLabel("<html>" + starData.getShootingStarsLocation().getName() + "</html>");
		nameLabel.setHorizontalAlignment(SwingConstants.LEFT);
		nameLabel.setBorder(new EmptyBorder(0, 10, 0, 0));

		topPanel.add(world, BorderLayout.WEST);
		topPanel.add(nameLabel, BorderLayout.CENTER);

		time = new JLabel();

		updateLabels();
		add(topPanel);
		add(time);

		// From WorldHopper/Condensed Stars Panel
		addMouseListener(new MouseAdapter()
		{
			@Override
			public void mouseClicked(MouseEvent mouseEvent)
			{
				if (mouseEvent.getClickCount() == 2)
				{
					if (onSelect != null)
					{
						onSelect.accept(starData.getWorld());
					}
				}
			}

			@Override
			public void mousePressed(MouseEvent mouseEvent)
			{
				if (mouseEvent.getClickCount() == 2)
				{
					setBackground(getBackground().brighter());
				}
			}

			@Override
			public void mouseReleased(MouseEvent mouseEvent)
			{
				if (mouseEvent.getClickCount() == 2)
				{
					setBackground(getBackground().darker());
				}
			}

			@Override
			public void mouseEntered(MouseEvent mouseEvent)
			{
				ShootingStarsSinglePanel.this.lastBackground = getBackground();
				setBackground(getBackground().brighter());
			}

			@Override
			public void mouseExited(MouseEvent mouseEvent)
			{
				setBackground(lastBackground);
			}
		});
	}

	private boolean updateLanded()
	{
		Color c;
		boolean hasLanded = starData.hasLanded();
		if (hasLanded)
			c = LANDED;
		else
			c = INCOMING;
		nameLabel.setForeground(c);
		return hasLanded;
	}

	private void updateTime()
	{
		time.setText(starData.getLandingTime());
	}

	public void updateLabels()
	{
		updateLanded();
		updateTime();
		repaint();
		revalidate();
	}

	public void createRightClickMenu(ShootingStarsPluginPanel panel)
	{
		JPopupMenu rightClickMenu = new JPopupMenu();
		rightClickMenu.setBorder(new EmptyBorder(1, 1, 1, 1));
		JMenuItem removeEntryOption = new JMenuItem();
		removeEntryOption.setText("Hide for this wave");
		removeEntryOption.setFont(FontManager.getRunescapeSmallFont());
		removeEntryOption.addActionListener(e -> panel.hideWorld(this.starData.getWorld(), this.starData.getMaxTime()));
		removeEntryOption.setBorder(new EmptyBorder(5, 0, 5, 0));

		JMenuItem resetHiddenWorldsOptions = new JMenuItem();
		resetHiddenWorldsOptions.setText("Unhide all worlds");
		resetHiddenWorldsOptions.setFont(FontManager.getRunescapeSmallFont());
		resetHiddenWorldsOptions.addActionListener(e -> panel.resetHiddenWorlds());
		resetHiddenWorldsOptions.setBorder(new EmptyBorder(5, 0, 5, 0));

		rightClickMenu.add(removeEntryOption);
		rightClickMenu.add(resetHiddenWorldsOptions);
		this.setComponentPopupMenu(rightClickMenu);
	}
}

/*
 * Copyright (c) 2021, Andrew McAdams, Cyborger1, Psikoi <https://github.com/Psikoi> (Basis)
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.andmcadams.shootingstars.ui.condensed;

import com.andmcadams.shootingstars.ShootingStarsData;
import com.andmcadams.shootingstars.ShootingStarsLocation;
import com.andmcadams.shootingstars.ShootingStarsPlugin;
import com.andmcadams.shootingstars.ui.ShootingStarsPluginPanelBase;
import java.awt.BorderLayout;
import java.awt.Color;
import java.awt.Dimension;
import java.awt.GridLayout;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.time.Duration;
import java.time.Instant;
import java.util.ArrayList;
import java.util.Comparator;
import static java.util.Comparator.comparing;
import static java.util.Comparator.reverseOrder;
import static java.util.Comparator.naturalOrder;
import java.util.EnumSet;
import java.util.List;
import java.util.function.Function;
import javax.swing.JPanel;
import javax.swing.SwingUtilities;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.DynamicGridLayout;
import net.runelite.http.api.worlds.World;
import net.runelite.http.api.worlds.WorldType;

public class ShootingStarsCondensedPluginPanel extends ShootingStarsPluginPanelBase
{
	private static final Color ODD_ROW = new Color(44, 44, 44);

	private static final int WORLD_COLUMN_WIDTH = 35;
	private static final int TIME_COLUMN_WIDTH = 45;
	private static final int TYPE_COLUMN_WIDTH = 35;

	private final JPanel listContainer = new JPanel();

	private ShootingStarsPanelHeader worldHeader;
	private ShootingStarsPanelHeader minTimeHeader;
	private ShootingStarsPanelHeader maxTimeHeader;
	private ShootingStarsPanelHeader locationHeader;
	private ShootingStarsPanelHeader worldTypeHeader;

	private ShootingStarsOrder orderIndex = ShootingStarsOrder.MAX_TIME;
	private boolean ascendingOrder = true;

	private final ArrayList<ShootingStarsTableRow> rows = new ArrayList<>();

	public ShootingStarsCondensedPluginPanel(ShootingStarsPlugin plugin)
	{
		super(plugin);

		setBorder(null);
		setLayout(new DynamicGridLayout(0, 1));

		JPanel headerContainer = buildHeader();

		listContainer.setLayout(new GridLayout(0, 1));

		add(headerContainer);
		add(listContainer);
	}

	/**
	 * Builds the entire table header.
	 */
	private JPanel buildHeader()
	{
		JPanel header = new JPanel(new BorderLayout());
		JPanel leftSide = new JPanel(new BorderLayout());
		JPanel rightSide = new JPanel(new BorderLayout());

		worldHeader = new ShootingStarsPanelHeader("W", orderIndex == ShootingStarsOrder.WORLD, ascendingOrder);
		worldHeader.setPreferredSize(new Dimension(WORLD_COLUMN_WIDTH, 0));
		worldHeader.addMouseListener(new MouseAdapter()
		{
			@Override
			public void mousePressed(MouseEvent mouseEvent)
			{
				if (SwingUtilities.isRightMouseButton(mouseEvent))
				{
					return;
				}
				ascendingOrder = orderIndex != ShootingStarsOrder.WORLD || !ascendingOrder;
				orderBy(ShootingStarsOrder.WORLD);
			}
		});

		minTimeHeader = new ShootingStarsPanelHeader("Min", orderIndex == ShootingStarsOrder.MIN_TIME, ascendingOrder);
		minTimeHeader.setPreferredSize(new Dimension(TIME_COLUMN_WIDTH, 0));
		minTimeHeader.addMouseListener(new MouseAdapter()
		{
			@Override
			public void mousePressed(MouseEvent mouseEvent)
			{
				if (SwingUtilities.isRightMouseButton(mouseEvent))
				{
					return;
				}
				ascendingOrder = orderIndex != ShootingStarsOrder.MIN_TIME || !ascendingOrder;
				orderBy(ShootingStarsOrder.MIN_TIME);
			}
		});

		maxTimeHeader = new ShootingStarsPanelHeader("Max", orderIndex == ShootingStarsOrder.MAX_TIME, ascendingOrder);
		maxTimeHeader.setPreferredSize(new Dimension(TIME_COLUMN_WIDTH, 0));
		maxTimeHeader.addMouseListener(new MouseAdapter()
		{
			@Override
			public void mousePressed(MouseEvent mouseEvent)
			{
				if (SwingUtilities.isRightMouseButton(mouseEvent))
				{
					return;
				}
				ascendingOrder = orderIndex != ShootingStarsOrder.MAX_TIME || !ascendingOrder;
				orderBy(ShootingStarsOrder.MAX_TIME);
			}
		});

		locationHeader = new ShootingStarsPanelHeader("Location", orderIndex == ShootingStarsOrder.LOCATION, ascendingOrder);
		locationHeader.addMouseListener(new MouseAdapter()
		{
			@Override
			public void mousePressed(MouseEvent mouseEvent)
			{
				if (SwingUtilities.isRightMouseButton(mouseEvent))
				{
					return;
				}
				ascendingOrder = orderIndex != ShootingStarsOrder.LOCATION || !ascendingOrder;
				orderBy(ShootingStarsOrder.LOCATION);
			}
		});

		worldTypeHeader = new ShootingStarsPanelHeader("T", orderIndex == ShootingStarsOrder.TYPE, ascendingOrder);
		worldTypeHeader.setPreferredSize(new Dimension(TYPE_COLUMN_WIDTH, 0));
		worldTypeHeader.addMouseListener(new MouseAdapter()
		{
			@Override
			public void mousePressed(MouseEvent mouseEvent)
			{
				if (SwingUtilities.isRightMouseButton(mouseEvent))
				{
					return;
				}
				ascendingOrder = orderIndex != ShootingStarsOrder.TYPE || !ascendingOrder;
				orderBy(ShootingStarsOrder.TYPE);
			}
		});

		leftSide.add(worldHeader, BorderLayout.WEST);
		leftSide.add(minTimeHeader, BorderLayout.CENTER);
		leftSide.add(maxTimeHeader, BorderLayout.EAST);
		rightSide.add(locationHeader, BorderLayout.CENTER);
		rightSide.add(worldTypeHeader, BorderLayout.EAST);

		header.add(leftSide, BorderLayout.WEST);
		header.add(rightSide, BorderLayout.CENTER);

		return header;
	}

	private void orderBy(ShootingStarsOrder order)
	{
		worldHeader.highlight(false, ascendingOrder);
		minTimeHeader.highlight(false, ascendingOrder);
		maxTimeHeader.highlight(false, ascendingOrder);
		locationHeader.highlight(false, ascendingOrder);
		worldTypeHeader.highlight(false, ascendingOrder);

		switch (order)
		{
			case WORLD:
				worldHeader.highlight(true, ascendingOrder);
				break;
			case MIN_TIME:
				minTimeHeader.highlight(true, ascendingOrder);
				break;
			case MAX_TIME:
				maxTimeHeader.highlight(true, ascendingOrder);
				break;
			case LOCATION:
				locationHeader.highlight(true, ascendingOrder);
				break;
			case TYPE:
				worldTypeHeader.highlight(true, ascendingOrder);
				break;
		}

		orderIndex = order;
		updateList();
	}

	@Override
	public void updateList()
	{
		rows.sort((r1, r2) ->
		{
			switch (orderIndex)
			{
				case WORLD:
					return getCompareValue(r1, r2, row -> row.getWorld().getId());
				case MIN_TIME:
					return getCompareValue(r1, r2, ShootingStarsTableRow::getMinTime);
				case MAX_TIME:
					return getCompareValue(r1, r2, ShootingStarsTableRow::getMaxTime);
				case LOCATION:
					return getCompareValue(r1, r2, row -> row.getStarLocation().getShortName());
				case TYPE:
					return getCompareValue(r1, r2, ShootingStarsTableRow::getWorldType);
				default:
					return 0;
			}
		});

		listContainer.removeAll();

		int currentWorld = plugin.getCurrentWorld();

		int i = 0;
		for (ShootingStarsTableRow row : rows)
		{
			// Disallow old stars from being displayed
			Duration timeSinceLanded = Duration.between(row.getMaxTime(), Instant.now());
			if (timeSinceLanded.toMinutes() < plugin.getConfig().shootingStarExpirationLength())
			{
				row.updateStatus(row.getWorld().getId() == currentWorld);
				setColorOnRow(row, i++ % 2 == 0);
				listContainer.add(row);
			}
		}

		listContainer.revalidate();
		listContainer.repaint();
	}

	@SuppressWarnings("rawtypes")
	private int getCompareValue(ShootingStarsTableRow row1, ShootingStarsTableRow row2,
								Function<ShootingStarsTableRow, Comparable> compareByFn)
	{
		Comparator<ShootingStarsTableRow> c = ascendingOrder ?
			comparing(compareByFn, naturalOrder()) : comparing(compareByFn, reverseOrder());
		// Always default to ordering by Max time for the second sort pass
		return c.thenComparing(ShootingStarsTableRow::getMaxTime, naturalOrder()).compare(row1, row2);
	}

	@Override
	public void populate(List<ShootingStarsData> stars)
	{
		rows.clear();

		for (int i = 0; i < stars.size(); i++)
		{
			ShootingStarsData star = stars.get(i);
			rows.add(buildRow(star, i % 2 == 0));
		}

		updateList();
	}

	private ShootingStarsTableRow buildRow(ShootingStarsData star, boolean stripe)
	{
		World world = plugin.getWorldService().getWorlds().findWorld(star.getWorld());
		boolean current = plugin.getCurrentWorld() == star.getWorld();
		ShootingStarsTableRow row = new ShootingStarsTableRow(
			world, current,
			Instant.ofEpochSecond(star.getMinTime()),
			Instant.ofEpochSecond(star.getMaxTime()),
			star.getShootingStarsLocation(), plugin::hopTo);

		// Create a right click menu that can hide the world
		row.createRightClickMenu(this);

		setColorOnRow(row, stripe);
		return row;
	}

	private void setColorOnRow(ShootingStarsTableRow row, boolean stripe)
	{
		EnumSet<WorldType> types = row.getWorld().getTypes();
		Color c = stripe ? ODD_ROW : ColorScheme.DARK_GRAY_COLOR;
		if (row.getStarLocation() == ShootingStarsLocation.WILDERNESS
			|| types.contains(WorldType.PVP)
			|| types.contains(WorldType.DEADMAN)
			|| types.contains(WorldType.TOURNAMENT))
		{
			c = new Color(
				c.getRed(),
				c.getGreen() / 2,
				c.getBlue() / 2,
				c.getAlpha()
			);
		}

		row.setBackground(c);
	}

}

/*
 * Copyright (c) 2021, Cyborger1, Psikoi <https://github.com/Psikoi> (Basis)
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

package com.andmcadams.shootingstars.ui.condensed;

public enum ShootingStarsOrder
{
	WORLD,
	MIN_TIME,
	MAX_TIME,
	LOCATION,
	TYPE
}

/*
 * Copyright (c) 2021, Cyborger1, Psikoi <https://github.com/Psikoi> (Basis)
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.andmcadams.shootingstars.ui.condensed;

import com.andmcadams.shootingstars.ShootingStarsPlugin;
import java.awt.BorderLayout;
import java.awt.Color;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.awt.event.MouseListener;
import java.awt.image.BufferedImage;
import javax.swing.BorderFactory;
import javax.swing.ImageIcon;
import javax.swing.JLabel;
import javax.swing.JPanel;
import javax.swing.border.CompoundBorder;
import javax.swing.border.EmptyBorder;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.FontManager;
import net.runelite.client.util.ImageUtil;

class ShootingStarsPanelHeader extends JPanel
{
	private static final ImageIcon ARROW_UP;
	private static final ImageIcon HIGHLIGHT_ARROW_DOWN;
	private static final ImageIcon HIGHLIGHT_ARROW_UP;

	private static final Color ARROW_COLOR = ColorScheme.LIGHT_GRAY_COLOR;
	private static final Color HIGHLIGHT_COLOR = ColorScheme.BRAND_ORANGE;

	static
	{
		final BufferedImage arrowDown = ImageUtil.loadImageResource(ShootingStarsPlugin.class, "/arrow_down.png");
		final BufferedImage arrowUp = ImageUtil.rotateImage(arrowDown, Math.PI);
		final BufferedImage arrowUpFaded = ImageUtil.luminanceOffset(arrowUp, -80);
		ARROW_UP = new ImageIcon(arrowUpFaded);

		final BufferedImage highlightArrowDown = ImageUtil.fillImage(arrowDown, HIGHLIGHT_COLOR);
		final BufferedImage highlightArrowUp = ImageUtil.fillImage(arrowUp, HIGHLIGHT_COLOR);
		HIGHLIGHT_ARROW_DOWN = new ImageIcon(highlightArrowDown);
		HIGHLIGHT_ARROW_UP = new ImageIcon(highlightArrowUp);
	}

	private final JLabel textLabel = new JLabel();
	private final JLabel arrowLabel = new JLabel();
	// Determines if this header column is being used to order the list
	private boolean ordering = false;

	ShootingStarsPanelHeader(String title, boolean ordered, boolean ascending)
	{
		setLayout(new BorderLayout(5, 0));
		setBorder(new CompoundBorder(
			BorderFactory.createMatteBorder(0, 0, 0, 1, ColorScheme.MEDIUM_GRAY_COLOR),
			new EmptyBorder(0, 5, 0, 2)));
		setBackground(ColorScheme.SCROLL_TRACK_COLOR);

		addMouseListener(new MouseAdapter()
		{
			@Override
			public void mouseEntered(MouseEvent mouseEvent)
			{
				textLabel.setForeground(HIGHLIGHT_COLOR);
				if (!ordering)
				{
					arrowLabel.setIcon(HIGHLIGHT_ARROW_UP);
				}
			}

			@Override
			public void mouseExited(MouseEvent mouseEvent)
			{
				if (!ordering)
				{
					textLabel.setForeground(ARROW_COLOR);
					arrowLabel.setIcon(ARROW_UP);
				}
			}
		});

		textLabel.setText(title);
		textLabel.setFont(FontManager.getRunescapeSmallFont());

		highlight(ordered, ascending);

		add(textLabel, BorderLayout.WEST);
		add(arrowLabel, BorderLayout.EAST);
	}

	/**
	 * The labels inherit the parent's mouse listeners.
	 */
	@Override
	public void addMouseListener(MouseListener mouseListener)
	{
		super.addMouseListener(mouseListener);
		textLabel.addMouseListener(mouseListener);
		arrowLabel.addMouseListener(mouseListener);
	}

	/**
	 * If this column header is being used to order, then it should be
	 * highlighted, changing it's font color and icon.
	 */
	public void highlight(boolean on, boolean ascending)
	{
		ordering = on;
		arrowLabel.setIcon(on ? (ascending ? HIGHLIGHT_ARROW_DOWN : HIGHLIGHT_ARROW_UP) : ARROW_UP);
		textLabel.setForeground(on ? HIGHLIGHT_COLOR : ARROW_COLOR);
	}

}
/*
 * Copyright (c) 2021, Cyborger1, Psikoi <https://github.com/Psikoi> (Basis)
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.andmcadams.shootingstars.ui.condensed;

import com.andmcadams.shootingstars.ShootingStarsLocation;
import java.awt.BorderLayout;
import java.awt.Color;
import java.awt.Dimension;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.time.Duration;
import java.time.Instant;
import java.util.EnumSet;
import java.util.function.Consumer;
import javax.swing.JLabel;
import javax.swing.JMenuItem;
import javax.swing.JPanel;
import javax.swing.JPopupMenu;
import javax.swing.SwingConstants;
import javax.swing.border.EmptyBorder;
import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.Value;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.FontManager;
import net.runelite.http.api.worlds.World;
import net.runelite.http.api.worlds.WorldType;

public class ShootingStarsTableRow extends JPanel
{
	private static final int WORLD_COLUMN_WIDTH = 35;
	private static final int TIME_COLUMN_WIDTH = 45;
	private static final int TYPE_COLUMN_WIDTH = 35;

	private static final Color CURRENT_WORLD = new Color(66, 227, 17);
	private static final Color DANGEROUS_WORLD = new Color(251, 62, 62);
	private static final Color BETA_WORLD = new Color(79, 145, 255);
	private static final Color MEMBERS_WORLD = new Color(210, 193, 53);
	private static final Color FREE_WORLD = new Color(200, 200, 200);
	private static final Color LEAGUE_WORLD = new Color(133, 177, 178);


	private static final Color COLOR_NEGATIVE = new Color(255, 80, 80);

	private JLabel worldField;
	private JLabel minTimeField;
	private JLabel maxTimeField;
	private JLabel locationField;
	private JLabel worldTypeField;

	@Getter
	private final World world;

	@Getter
	private Instant minTime;

	@Getter
	private boolean minPast;

	@Getter
	private Instant maxTime;

	@Getter
	private boolean maxPast;

	@Getter
	private ShootingStarsLocation starLocation;

	private Color lastBackground;

	// bubble up events
	private final MouseAdapter labelMouseListener = new MouseAdapter()
	{
		@Override
		public void mouseClicked(MouseEvent mouseEvent)
		{
			dispatchEvent(mouseEvent);
		}

		@Override
		public void mousePressed(MouseEvent mouseEvent)
		{
			dispatchEvent(mouseEvent);
		}

		@Override
		public void mouseReleased(MouseEvent mouseEvent)
		{
			dispatchEvent(mouseEvent);
		}

		@Override
		public void mouseEntered(MouseEvent mouseEvent)
		{
			dispatchEvent(mouseEvent);
		}

		@Override
		public void mouseExited(MouseEvent mouseEvent)
		{
			dispatchEvent(mouseEvent);
		}
	};

	ShootingStarsTableRow(World world, boolean current, Instant minTime, Instant maxTime, ShootingStarsLocation location, Consumer<World> onSelect)
	{
		this.world = world;
		this.minTime = minTime;
		this.maxTime = maxTime;
		this.starLocation = location;

		setLayout(new BorderLayout());
		setBorder(new EmptyBorder(2, 0, 2, 0));

		addMouseListener(new MouseAdapter()
		{
			@Override
			public void mouseClicked(MouseEvent mouseEvent)
			{
				if (mouseEvent.getButton() == MouseEvent.BUTTON1 && mouseEvent.getClickCount() == 2)
				{
					if (onSelect != null)
					{
						onSelect.accept(world);
					}
				}
			}

			@Override
			public void mousePressed(MouseEvent mouseEvent)
			{
				if (mouseEvent.getClickCount() == 2)
				{
					setBackground(getBackground().brighter());
				}
			}

			@Override
			public void mouseReleased(MouseEvent mouseEvent)
			{
				if (mouseEvent.getClickCount() == 2)
				{
					setBackground(getBackground().darker());
				}
			}

			@Override
			public void mouseEntered(MouseEvent mouseEvent)
			{
				ShootingStarsTableRow.this.lastBackground = getBackground();
				setBackground(getBackground().brighter());
			}

			@Override
			public void mouseExited(MouseEvent mouseEvent)
			{
				setBackground(lastBackground);
			}
		});

		JPanel leftSide = new JPanel(new BorderLayout());
		JPanel rightSide = new JPanel(new BorderLayout());
		leftSide.setOpaque(false);
		rightSide.setOpaque(false);

		JPanel worldField = buildWorldField();
		worldField.setPreferredSize(new Dimension(WORLD_COLUMN_WIDTH, 0));
		worldField.setOpaque(false);

		JPanel minTimeField = buildMinTimeField();
		minTimeField.setPreferredSize(new Dimension(TIME_COLUMN_WIDTH, 0));
		minTimeField.setOpaque(false);

		JPanel maxTimeField = buildMaxTimeField();
		maxTimeField.setPreferredSize(new Dimension(TIME_COLUMN_WIDTH, 0));
		maxTimeField.setOpaque(false);

		JPanel locationField = buildLocationField();
		locationField.setBorder(new EmptyBorder(5, 5, 5, 5));
		locationField.setOpaque(false);

		JPanel typeField = buildTypeField();
		typeField.setPreferredSize(new Dimension(TYPE_COLUMN_WIDTH, 0));
		typeField.setOpaque(false);

		updateStatus(current);

		leftSide.add(worldField, BorderLayout.WEST);
		leftSide.add(minTimeField, BorderLayout.CENTER);
		leftSide.add(maxTimeField, BorderLayout.EAST);
		rightSide.add(locationField, BorderLayout.CENTER);
		rightSide.add(typeField, BorderLayout.EAST);

		add(leftSide, BorderLayout.WEST);
		add(rightSide, BorderLayout.CENTER);
	}

	void updateStatus(boolean current)
	{
		StringBool min = timeString(minTime);
		StringBool max = timeString(maxTime);
		minTimeField.setText(min.getString());
		maxTimeField.setText(max.getString());
		locationField.setText(starLocation.getShortName());
		if (!starLocation.getName().equals(starLocation.getShortName()))
		{
			((JPanel)locationField.getParent()).setToolTipText(starLocation.getName());
		}

		minPast = min.isBoolValue();
		maxPast = max.isBoolValue();
		if (minPast && maxPast)
		{
			minTimeField.setForeground(COLOR_NEGATIVE);
			maxTimeField.setForeground(COLOR_NEGATIVE);
			locationField.setForeground(ColorScheme.PROGRESS_COMPLETE_COLOR);
		}
		else if (minPast)
		{
			minTimeField.setForeground(COLOR_NEGATIVE);
			maxTimeField.setForeground(Color.WHITE);
			locationField.setForeground(Color.YELLOW);
		}
		else
		{
			minTimeField.setForeground(Color.WHITE);
			maxTimeField.setForeground(Color.WHITE);
			locationField.setForeground(ColorScheme.PROGRESS_INPROGRESS_COLOR);
		}

		recolour(current);
	}

	void updateInfo(Instant minTime, Instant maxTime, ShootingStarsLocation location, boolean current)
	{
		this.minTime = minTime;
		this.maxTime = maxTime;
		this.starLocation = location;
		updateStatus(current);
	}

	private static StringBool timeString(Instant time)
	{
		long s = Duration.between(Instant.now(), time).getSeconds();
		boolean negative = false;
		if (s < 0)
		{
			s *= -1;
			negative = true;
		}

		String str;
		long mins = s / 60;
		long secs = s % 60;

		if (negative)
		{
			if (mins > 9)
			{
				str = String.format("-%dm", mins);
			}
			else
			{
				str = String.format("-%1d:%02d", mins, secs);
			}
		}
		else
		{
			if (mins > 99)
			{
				str = String.format("%dm", mins);
			}
			else
			{
				str = String.format("%1d:%02d", mins, secs);
			}
		}

		return new StringBool(str, negative);
	}

	public void recolour(boolean current)
	{
		if (current)
		{
			worldTypeField.setForeground(CURRENT_WORLD);
			worldField.setForeground(CURRENT_WORLD);
			return;
		}
		else if (world.getTypes().contains(WorldType.PVP)
			|| world.getTypes().contains(WorldType.HIGH_RISK)
			|| world.getTypes().contains(WorldType.DEADMAN)
			|| world.getTypes().contains(WorldType.TOURNAMENT))
		{
			worldTypeField.setForeground(DANGEROUS_WORLD);
		}
		else if (world.getTypes().contains(WorldType.SEASONAL))
		{
			worldTypeField.setForeground(LEAGUE_WORLD);
		}
		else if (world.getTypes().contains(WorldType.NOSAVE_MODE))
		{
			worldTypeField.setForeground(BETA_WORLD);
		}
		else
		{
			worldTypeField.setForeground(Color.WHITE);
		}

		worldField.setForeground(world.getTypes().contains(WorldType.MEMBERS) ? MEMBERS_WORLD : FREE_WORLD);
	}

	private JPanel buildWorldField()
	{
		JPanel column = new JPanel(new BorderLayout());
		column.setBorder(new EmptyBorder(0, 5, 0, 5));

		worldField = new JLabel(world.getId() + "");
		column.add(worldField, BorderLayout.WEST);

		return column;
	}

	private JPanel buildMinTimeField()
	{
		JPanel column = new JPanel(new BorderLayout());
		column.setBorder(new EmptyBorder(0, 5, 0, 5));

		minTimeField = new JLabel();
		minTimeField.setFont(FontManager.getRunescapeSmallFont());
		minTimeField.setHorizontalAlignment(SwingConstants.RIGHT);
		column.add(minTimeField, BorderLayout.CENTER);

		return column;
	}

	private JPanel buildMaxTimeField()
	{
		JPanel column = new JPanel(new BorderLayout());
		column.setBorder(new EmptyBorder(0, 5, 0, 5));

		maxTimeField = new JLabel();
		maxTimeField.setFont(FontManager.getRunescapeSmallFont());
		maxTimeField.setHorizontalAlignment(SwingConstants.RIGHT);
		column.add(maxTimeField, BorderLayout.CENTER);

		return column;
	}

	private JPanel buildLocationField()
	{
		JPanel column = new JPanel(new BorderLayout());
		column.setBorder(new EmptyBorder(0, 5, 0, 5));

		locationField = new JLabel();
		locationField.setFont(FontManager.getRunescapeSmallFont());

		column.add(locationField, BorderLayout.CENTER);
		column.addMouseListener(labelMouseListener);

		return column;
	}

	private JPanel buildTypeField()
	{
		JPanel column = new JPanel(new BorderLayout());
		column.setBorder(new EmptyBorder(0, 5, 0, 5));

		String act = world.getActivity();

		StringBuilder sb = new StringBuilder();
		EnumSet<WorldType> types = world.getTypes();

		if (types.contains(WorldType.SKILL_TOTAL))
		{
			sb.append(act.split(" ")[0]);
		}
		if (types.contains(WorldType.PVP))
		{
			sb.append("P");
		}
		if (types.contains(WorldType.DEADMAN))
		{
			sb.append("D");
		}
		if (types.contains(WorldType.TOURNAMENT))
		{
			sb.append("C");
		}
		if (types.contains(WorldType.SEASONAL))
		{
			sb.append("S");
		}
		if (types.contains(WorldType.FRESH_START_WORLD))
		{
			sb.append("F");
		}
		if (types.contains(WorldType.HIGH_RISK))
		{
			sb.append("H");
		}
		if (types.contains(WorldType.NOSAVE_MODE))
		{
			sb.append("B");
		}
		if (act.toLowerCase().contains("target"))
		{
			sb.append("T");
		}

		worldTypeField = new JLabel(sb.toString());
		worldTypeField.setFont(FontManager.getRunescapeSmallFont());

		column.add(worldTypeField, BorderLayout.EAST);
		if (!act.equals("-"))
		{
			column.setToolTipText(act);
		}
		column.addMouseListener(labelMouseListener);
		return column;
	}

	public void createRightClickMenu(ShootingStarsCondensedPluginPanel panel)
	{
        JPopupMenu rightClickMenu = new JPopupMenu();
		rightClickMenu.setBorder(new EmptyBorder(1, 1, 1, 1));
        JMenuItem removeEntryOption = new JMenuItem();
        removeEntryOption.setText("Hide for this wave");
        removeEntryOption.setFont(FontManager.getRunescapeSmallFont());
        removeEntryOption.addActionListener(e -> panel.hideWorld(this.world.getId(), this.maxTime.getEpochSecond()));
		removeEntryOption.setBorder(new EmptyBorder(5, 0, 5, 0));

		JMenuItem resetHiddenWorldsOptions = new JMenuItem();
		resetHiddenWorldsOptions.setText("Unhide all worlds");
		resetHiddenWorldsOptions.setFont(FontManager.getRunescapeSmallFont());
		resetHiddenWorldsOptions.addActionListener(e -> panel.resetHiddenWorlds());
		resetHiddenWorldsOptions.setBorder(new EmptyBorder(5, 0, 5, 0));

		rightClickMenu.add(removeEntryOption);
		rightClickMenu.add(resetHiddenWorldsOptions);
		this.setComponentPopupMenu(rightClickMenu);
		// Yeah, this isn't great but honestly I'm not sure why these two in particular aren't covered by setting the
		// parent's component popup menu.
		((JPanel)locationField.getParent()).setComponentPopupMenu(rightClickMenu);
		((JPanel)worldTypeField.getParent()).setComponentPopupMenu(rightClickMenu);
	}

	public String getWorldType()
	{
		return worldTypeField.getText();
	}

	@Value
	@AllArgsConstructor
	private static class StringBool
	{
		String string;
		boolean boolValue;
	}
}

/*
 * Copyright (c) 2021, Cyborger1
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.andmcadams.shootingstars.ui;

import com.andmcadams.shootingstars.ShootingStarsData;
import com.andmcadams.shootingstars.ShootingStarsPlugin;
import java.util.List;
import lombok.Getter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.client.ui.PluginPanel;

@Slf4j
public abstract class ShootingStarsPluginPanelBase extends PluginPanel
{
	@Getter
	private boolean open = false;

	protected ShootingStarsPlugin plugin;

	protected ShootingStarsPluginPanelBase(ShootingStarsPlugin plugin)
	{
		this(plugin, true);
	}

	protected ShootingStarsPluginPanelBase(ShootingStarsPlugin plugin, boolean wrap)
	{
		super(wrap);
		this.plugin = plugin;
	}

	public abstract void populate(List<ShootingStarsData> stars);
	public abstract void updateList();

	public void onActivate()
	{
		// If the panel is opened, try to run a get request to populate/refresh the panel.
		log.debug("Activated");
		open = true;
		plugin.hitAPI();
	}

	public void onDeactivate()
	{
		log.debug("Deactivated");
		open = false;
	}

	public void hideWorld(int world, long maxTime)
	{
		plugin.hideWorld(world, maxTime);
	}

	public void resetHiddenWorlds()
	{
		plugin.resetHiddenWorlds();
	}
}

/*
 * Copyright (c) 2021, Cyborger1
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.andmcadams.shootingstars.ui;

import com.andmcadams.shootingstars.ui.condensed.ShootingStarsCondensedPluginPanel;
import com.andmcadams.shootingstars.ui.panels.ShootingStarsPluginPanel;
import lombok.AllArgsConstructor;
import lombok.Getter;

@Getter
@AllArgsConstructor
public enum ShootingStarsPanelType
{
	LARGE_PANELS("Large Panels", ShootingStarsPluginPanel.class.asSubclass(ShootingStarsPluginPanelBase.class)),
	CONDENSED("Condensed", ShootingStarsCondensedPluginPanel.class.asSubclass(ShootingStarsPluginPanelBase.class))
	;

	private final String name;
	private final Class<? extends ShootingStarsPluginPanelBase> panelClass;

	@Override
	public String toString()
	{
		return getName();
	}
}

/*
 * Copyright (c) 2019, Weird Gloop <admin@weirdgloop.org>
 * Copyright (c) 2021, Andrew McAdams
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.andmcadams.shootingstars;

import com.google.gson.Gson;
import com.google.gson.JsonArray;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonSyntaxException;
import java.io.IOException;
import java.util.ArrayList;
import java.util.List;
import javax.inject.Inject;
import javax.inject.Singleton;
import lombok.extern.slf4j.Slf4j;
import okhttp3.Call;
import okhttp3.Callback;
import okhttp3.MediaType;
import okhttp3.OkHttpClient;
import okhttp3.Request;
import okhttp3.RequestBody;
import okhttp3.Response;

@Slf4j
@Singleton
public class ShootingStarsDataManager
{
	private static final MediaType JSON = MediaType.parse("application/json; charset=utf-8");

	@Inject
	private OkHttpClient okHttpClient;

	@Inject
	private Gson gson;

	@Inject
	private ShootingStarsPlugin plugin;

	private List<Object> data = new ArrayList<>();

	public void storeEvent(Object event)
	{
		synchronized (this)
		{
			data.add(event);
		}
	}

	protected void submitToAPI()
	{
		List<Object> temp;
		synchronized (this)
		{
			if (data.isEmpty())
			{
				return;
			}
			temp = data;
			data = new ArrayList<>();
		}
		makePostRequest(temp);
	}

	private ArrayList<ShootingStarsData> parseData(JsonArray j)
	{
		ArrayList<ShootingStarsData> l = new ArrayList<>();
		for (JsonElement jsonElement : j)
		{
			JsonObject jObj = jsonElement.getAsJsonObject();
			ShootingStarsData d = new ShootingStarsData(ShootingStarsLocation.getLocation(jObj.get("location").getAsInt()),
				jObj.get("world").getAsInt(), jObj.get("minTime").getAsLong(), jObj.get("maxTime").getAsLong());
			l.add(d);
		}
		return l;
	}

	protected void makePostRequest(List<Object> temp)
	{
		String endpoint = plugin.getShootingStarPostEndpoint();
		if (endpoint == null || endpoint.isEmpty()) {
			plugin.setGetError(true);
			log.debug("POST endpoint not set");
			return;
		}
		try
		{
			Request r = new Request.Builder()
				.url(endpoint)
				.addHeader("Authorization", plugin.getShootingStarsSharedKey())
				.post(RequestBody.create(JSON, gson.toJson(temp)))
				.build();

			okHttpClient.newCall(r).enqueue(new Callback()
			{
				@Override
				public void onFailure(Call call, IOException e)
				{
					log.debug("Error sending shooting star data", e);
					plugin.setPostError(true);
				}

				@Override
				public void onResponse(Call call, Response response)
				{
					if (response.isSuccessful())
					{
						log.debug("Successfully sent shooting star data");
						plugin.setPostError(false);
						response.close();
					}
					else
					{
						log.error("Post request unsuccessful");
						plugin.setPostError(true);
					}
				}
			});
		}
		catch (IllegalArgumentException e)
		{
			log.error("Bad URL given: " + e.getLocalizedMessage());
			plugin.setPostError(true);
		}
	}

	protected void makeGetRequest()
	{
		String endpoint = plugin.getShootingStarGetEndpoint();
		if (endpoint == null || endpoint.isEmpty()) {
			plugin.setGetError(true);
			log.debug("GET endpoint not set");
			return;
		}
		try
		{
			Request r = new Request.Builder()
				.url(endpoint)
				.addHeader("Authorization", plugin.getShootingStarsSharedKey())
				.build();
			okHttpClient.newCall(r).enqueue(new Callback()
			{
				@Override
				public void onFailure(Call call, IOException e)
				{
					log.debug("Error retrieving shooting star data", e);
					plugin.setGetError(true);
				}

				@Override
				public void onResponse(Call call, Response response)
				{
					if (response.isSuccessful())
					{
						try
						{
							JsonArray j = gson.fromJson(response.body().string(), JsonArray.class);
							plugin.setStarData(parseData(j));
							log.debug(j.toString());
							plugin.setGetError(false);
							plugin.updatePanelList();
						}
						catch (IOException | JsonSyntaxException e)
						{
							plugin.setGetError(true);
							log.error(e.getMessage());
						}
					}
					else
					{
						log.error("Get request unsuccessful");
						plugin.setGetError(true);
					}
				}
			});
		}
		catch (IllegalArgumentException e)
		{
			log.error("Bad URL given: " + e.getLocalizedMessage());
		}
	}
}

/*
 * Copyright (c) 2021, Andrew McAdams
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.andmcadams.shootingstars;
import java.util.function.Function;
import lombok.AllArgsConstructor;
import lombok.Getter;

@Getter
@AllArgsConstructor
public enum ShootingStarsLocation
{
	ASGARNIA(0, "Asgarnia", "Asgarnia", ShootingStarsConfig::shootingStarShowAsgarniaWorlds),
	KARAMJA(1, "Crandor or Karamja", "Cran/Karam", ShootingStarsConfig::shootingStarShowKaramjaWorlds),
	FELDIP_HILLS(2, "Feldip Hills or on the Isle of Souls", "Feldip/Souls", ShootingStarsConfig::shootingStarShowFeldipWorlds),
	FOSSIL_ISLAND(3, "Fossil Island or on Mos Le'Harmless", "Fossil/Mos", ShootingStarsConfig::shootingStarShowFossilIslandWorlds),
	FREMENNIK(4, "Fremennik Lands or on Lunar Isle", "Frem/Lunar", ShootingStarsConfig::shootingStarShowFremennikWorlds),
	KOUREND(5, "Great Kourend", "Kourend", ShootingStarsConfig::shootingStarShowKourendWorlds),
	KANDARIN(6, "Kandarin", "Kandarin", ShootingStarsConfig::shootingStarShowKandarinWorlds),
	KEBOS(7, "Kebos Lowlands", "Lowlands", ShootingStarsConfig::shootingStarShowKebosWorlds),
	KHARIDIAN_DESERT(8, "Kharidian Desert", "Desert", ShootingStarsConfig::shootingStarShowDesertWorlds),
	MISTHALIN(9, "Misthalin", "Misthalin", ShootingStarsConfig::shootingStarShowMisthalinWorlds),
	MORYTANIA(10, "Morytania", "Morytania", ShootingStarsConfig::shootingStarShowMorytaniaWorlds),
	PISCATORIS(11, "Piscatoris or the Gnome Stronghold", "Pisc/Gnome", ShootingStarsConfig::shootingStarShowPiscatorisWorlds),
	TIRANNWN(12, "Tirannwn", "Tirannwn", ShootingStarsConfig::shootingStarShowTirannwnWorlds),
	WILDERNESS(13, "Wilderness", "Wilderness", ShootingStarsConfig::shootingStarShowWildernessWorlds),
	UNKNOWN(14, "Unknown", "Unknown", c -> false),
	VARLAMORE(15, "Varlamore", "Varlamore", ShootingStarsConfig::shootingStarShowVarlamoreWorlds);

	private int id;
	private String name;
	private String shortName;
	private Function<ShootingStarsConfig, Boolean> configFunction;

	public static ShootingStarsLocation determineLocation(String text)
	{
		text = text.replace("<br>", " ");
		for (ShootingStarsLocation l : values())
		{
			if (text.contains(l.name))
			{
				return l;
			}
		}
		return ShootingStarsLocation.UNKNOWN;
	}

	public static ShootingStarsLocation getLocation(int id)
	{
		for (ShootingStarsLocation l : values())
		{
			if (l.getId() == id)
			{
				return l;
			}
		}

		return ShootingStarsLocation.UNKNOWN;
	}
}

/*
 * Copyright (c) 2021, Andrew McAdams
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.andmcadams.shootingstars;

import com.andmcadams.shootingstars.ui.ShootingStarsPluginPanelBase;
import com.google.inject.Provides;
import java.awt.image.BufferedImage;
import java.time.Duration;
import java.time.Instant;
import java.time.temporal.ChronoUnit;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.Timer;
import java.util.TimerTask;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.stream.Collectors;
import javax.inject.Inject;
import javax.swing.SwingUtilities;
import lombok.Getter;
import lombok.Setter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.ChatMessageType;
import net.runelite.api.Client;
import net.runelite.api.GameState;
import net.runelite.api.events.ChatMessage;
import net.runelite.api.events.GameTick;
import net.runelite.api.gameval.InterfaceID;
import net.runelite.api.widgets.ComponentID;
import net.runelite.api.widgets.Widget;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.chat.ChatColorType;
import net.runelite.client.chat.ChatMessageBuilder;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.chat.QueuedMessage;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.events.ConfigChanged;
import net.runelite.client.game.WorldService;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.plugins.PluginDescriptor;
import net.runelite.client.task.Schedule;
import net.runelite.client.ui.ClientToolbar;
import net.runelite.client.ui.NavigationButton;
import net.runelite.client.ui.overlay.OverlayManager;
import net.runelite.client.util.ImageUtil;
import net.runelite.client.util.WorldUtil;
import net.runelite.http.api.worlds.World;
import net.runelite.http.api.worlds.WorldResult;
import net.runelite.http.api.worlds.WorldType;

@Slf4j
@PluginDescriptor(
	name = "Shooting Stars",
	description = "Crowdsources the locations of shooting stars",
	tags = {"stars", "mining", "shooting star"}
)
public class ShootingStarsPlugin extends Plugin
{
	@Inject
	Client client;

	@Inject
	private ChatMessageManager chatMessageManager;

	@Inject
	private ShootingStarsDataManager manager;

	@Inject
	@Getter
	private ShootingStarsConfig config;

	@Inject
	private ShootingStarsOverlayPanel overlayPanel;

	@Inject
	private OverlayManager overlayManager;

	@Inject
	private ClientToolbar clientToolbar;

	@Inject
	private ClientThread clientThread;

	@Inject
	@Getter
	private WorldService worldService;

	private final int SECONDS_BETWEEN_UPLOADS = 10;
	private final int SECONDS_BETWEEN_GET = 5;
	private final int SECONDS_BETWEEN_PANEL_REFRESH = 5;
	private boolean canRefresh;

	private ShootingStarsLocation lastLoc;
	private int lastWorld;

	static final String CONFIG_GROUP_KEY = "shootingstar";

	@Getter
	private String shootingStarPostEndpoint;

	@Getter
	private String shootingStarGetEndpoint;

	@Getter
	private String shootingStarsSharedKey;

	@Getter
	@Setter
	private ArrayList<ShootingStarsData> starData = new ArrayList<>();

	// Map of World => MaxTime so that we can hide stars for that World with max time < MaxTime (hide this wave's stars)
	private final HashMap<Integer, Long> hiddenWorlds = new HashMap<>();

	@Getter
	@Setter
	private boolean postError = false;

	@Getter
	@Setter
	private boolean getError = false;

	@Getter
	private boolean keyError = false;

	private ShootingStarsPluginPanelBase shootingStarsPanel;
	private NavigationButton navButton = null;
	private final BufferedImage icon = ImageUtil.loadImageResource(getClass(), "/shooting_stars_icon.png");

	@Provides
	ShootingStarsConfig getConfig(ConfigManager configManager)
	{
		return configManager.getConfig(ShootingStarsConfig.class);
	}

	@Override
	protected void startUp() throws Exception
	{
		lastLoc = null;
		lastWorld = -1;
		canRefresh = true;

		// Set up config variables
		shootingStarPostEndpoint = config.shootingStarPostEndpointConfig();
		shootingStarGetEndpoint = config.shootingStarGetEndpointConfig();
		shootingStarsSharedKey = config.shootingStarSharedKeyConfig();
		keyError = isInvalidKey(shootingStarsSharedKey);

		// Add the overlay to the OverlayManager
		overlayManager.add(overlayPanel);

		// Set up the sidebar panel
		loadPluginPanel();
	}

	@Override
	protected void shutDown() throws Exception
	{
		// Reset non-config vars
		lastLoc = null;
		lastWorld = -1;

		// Remove the overlay from the OverlayManager
		overlayManager.remove(overlayPanel);

		// Remove sidebar panel button
		clientToolbar.removeNavigation(navButton);
	}

	@Subscribe
	public void onConfigChanged(ConfigChanged event)
	{
		if (!event.getGroup().equals(CONFIG_GROUP_KEY))
		{
			return;
		}
		switch (event.getKey())
		{
			case ShootingStarsConfig.SHOOTING_STAR_POST_ENDPOINT_KEYNAME:
				shootingStarPostEndpoint = config.shootingStarPostEndpointConfig();
				manager.makePostRequest(new ArrayList<Object>());
				break;
			case ShootingStarsConfig.SHOOTING_STAR_GET_ENDPOINT_KEYNAME:
				shootingStarGetEndpoint = config.shootingStarGetEndpointConfig();
				manager.makeGetRequest();
				break;
			case ShootingStarsConfig.SHOOTING_STAR_SHARED_KEY_KEYNAME:
				shootingStarsSharedKey = config.shootingStarSharedKeyConfig();
				keyError = isInvalidKey(shootingStarsSharedKey);
				canRefresh = true;
				break;
			case ShootingStarsConfig.SHOOTING_STAR_PANEL_CLASS:
				loadPluginPanel();
				updatePanelList();
				break;
			case ShootingStarsConfig.SHOOTING_STAR_SHOW_SIDEBAR_ICON:
				if (config.showSidebarIcon())
					clientToolbar.addNavigation(navButton);
				else
					clientToolbar.removeNavigation(navButton);
				break;
			default:
				updatePanelList();
				break;
		}
	}

	private void loadPluginPanel()
	{
		if (navButton != null)
		{
			clientToolbar.removeNavigation(navButton);
		}

		Class<? extends ShootingStarsPluginPanelBase> clazz = config.shootingStarsPanelType().getPanelClass();
		try
		{
			shootingStarsPanel = clazz.getDeclaredConstructor(this.getClass()).newInstance(this);
		}
		catch (Exception e)
		{
			log.error("Error loading panel class", e);
			return;
		}

		navButton = NavigationButton.builder().tooltip("Shooting Stars").icon(icon).priority(7).panel(shootingStarsPanel).build();
		if (config.showSidebarIcon())
			clientToolbar.addNavigation(navButton);
	}

	private final Pattern firstMinThenHour = Pattern.compile(".* next (\\d+) minutes to (\\d+) hours? (\\d+) .*");
	private final Pattern hourRegex = Pattern.compile(".* next (\\d+) hours? (\\d+) minutes? to (\\d+) hours? (\\d+) .*");
	private final Pattern minutes = Pattern.compile(".* (\\d+) to (\\d+) .*");
	private static final int MAX_TIME_ADJ = 59;

	private void recordEvent(ShootingStarsLocation loc, int world, int minTime, int maxTime)
	{
		long currentTime = Instant.now().toEpochMilli();
		long lminTime = currentTime / 1000 + (minTime * 60);
		long lmaxTime = currentTime / 1000 + (maxTime * 60) + MAX_TIME_ADJ;
		manager.storeEvent(new ShootingStarsData(loc, world, lminTime, lmaxTime));
		lastWorld = world;
		lastLoc = loc;
	}

	@Subscribe
	public void onGameTick(GameTick gameTick)
	{
		handleHop();
		Widget messageBoxTextWidget = client.getWidget(InterfaceID.Messagebox.TEXT);
		if (messageBoxTextWidget != null)
		{
			int world = client.getWorld();
			ShootingStarsLocation loc = ShootingStarsLocation.determineLocation(messageBoxTextWidget.getText());
			if (world != lastWorld || (loc != null && loc != lastLoc))
			{
				String text = messageBoxTextWidget.getText();
				text = text.replace("<br>", " ");

				Matcher m = firstMinThenHour.matcher(text);
				if (m.find())
				{
					int minTime = Integer.parseInt(m.group(1));
					int maxTime = 60 * Integer.parseInt(m.group(2)) + Integer.parseInt(m.group(3));
					recordEvent(loc, world, minTime, maxTime);
					return;
				}
				m = hourRegex.matcher(text);
				if (m.find())
				{
					int minTime = 60 * Integer.parseInt(m.group(1)) + Integer.parseInt(m.group(2));
					int maxTime = 60 * Integer.parseInt(m.group(3)) + Integer.parseInt(m.group(4));
					recordEvent(loc, world, minTime, maxTime);
					return;
				}
				m = minutes.matcher(text);
				if (m.find())
				{
					int minTime = Integer.parseInt(m.group(1));
					int maxTime = Integer.parseInt(m.group(2));
					recordEvent(loc, world, minTime, maxTime);
					return;
				}
			}
		}
	}

	public void updatePanelList()
	{
		log.debug("Update panel list");
		SwingUtilities.invokeLater(() -> shootingStarsPanel.populate(starData.stream().filter(this::isAllowedWorld).collect(Collectors.toList())));
	}

	@Schedule(
		period = SECONDS_BETWEEN_PANEL_REFRESH,
		unit = ChronoUnit.SECONDS,
		asynchronous = true
	)
	public void updatePanels()
	{
		log.debug("Update panels");
		if (shootingStarsPanel.isOpen())
		{
			SwingUtilities.invokeLater(() -> shootingStarsPanel.updateList());
		}
	}

	@Schedule(
		period = SECONDS_BETWEEN_UPLOADS,
		unit = ChronoUnit.SECONDS,
		asynchronous = true
	)
	public void submitToAPI()
	{
		manager.submitToAPI();
	}

	@Schedule(
		period = SECONDS_BETWEEN_GET,
		unit = ChronoUnit.SECONDS,
		asynchronous = true
	)
	public void attemptGetRequest()
	{
		log.debug("Attempt get request");
		hitAPI();
	}

	private final Pattern validKeyRegex = Pattern.compile("^[a-zA-Z]{1,10}$");

	private boolean isInvalidKey(String sharedKey)
	{
		log.debug("key is valid: " + validKeyRegex.matcher(sharedKey).find());
		return !validKeyRegex.matcher(sharedKey).find();
	}

	public void hitAPI()
	{
		if (canRefresh)
		{
			if ((client.getGameState() == GameState.LOGGED_IN || client.getGameState() == GameState.HOPPING) &&
				!keyError && shootingStarsPanel.isOpen())
			{
				canRefresh = false;
				manager.makeGetRequest();
				Timer t = new Timer();
				t.schedule(new TimerTask()
				{
					@Override
					public void run()
					{
						log.debug("Resetting canRefresh");
						canRefresh = true;
					}
				}, 30 * 1000);
			}
		}
	}

	private boolean isAllowedWorld(ShootingStarsData starData)
	{
		// Protect against non-existent world ids
		WorldResult worldResult = worldService.getWorlds();
		if (worldResult == null)
		{
			return false;
		}
		World world = worldResult.findWorld(starData.getWorld());
		if (world == null)
		{
			return false;
		}

		// Disallow old stars from being displayed
		Duration timeSinceLanded = Duration.between(Instant.ofEpochSecond(starData.getMaxTime()), Instant.now());
		if (timeSinceLanded.toMinutes() >= config.shootingStarExpirationLength())
		{
			return false;
		}

		// Disallow hidden stars from being displayed
		if (isWorldHidden(starData))
		{
			return false;
		}

		// Disallow PVP worlds from being displayed (depending on config)
		if (!config.shootingStarShowPvpWorlds() && world.getTypes().contains(WorldType.PVP))
		{
			return false;
		}

		// Disallow Skill Total worlds from being displayed (depending on config)
		if (!config.shootingStarShowSkillTotalWorlds() && world.getTypes().contains(WorldType.SKILL_TOTAL))
		{
			return false;
		}

		// Disallow non-members worlds from showing up
		if (!world.getTypes().contains(WorldType.MEMBERS))
		{
			return false;
		}

		// Disallow various landing sites (depending on config)
		return starData.getShootingStarsLocation().getConfigFunction().apply(config);
	}

	/*
		Stealing from quick hopper plugin from here on, close your eyes...
	*/
	public int getCurrentWorld()
	{
		return client.getWorld();
	}

	private static final int DISPLAY_SWITCHER_MAX_ATTEMPTS = 3;
	private net.runelite.api.World quickHopTargetWorld;
	private int displaySwitcherAttempts = 0;

	public void hopTo(World world)
	{
		hopTo(world.getId());
	}

	public void hopTo(int worldId)
	{
		clientThread.invoke(() -> hop(worldId));
	}

	private void hop(int worldId)
	{
		assert client.isClientThread();

		if (!config.isWorldHopperEnabled())
		{
			return;
		}

		WorldResult worldResult = worldService.getWorlds();
		if (worldResult == null)
		{
			return;
		}
		// Don't try to hop if the world doesn't exist
		World world = worldResult.findWorld(worldId);
		if (world == null)
		{
			return;
		}

		final net.runelite.api.World rsWorld = client.createWorld();
		rsWorld.setActivity(world.getActivity());
		rsWorld.setAddress(world.getAddress());
		rsWorld.setId(world.getId());
		rsWorld.setPlayerCount(world.getPlayers());
		rsWorld.setLocation(world.getLocation());
		rsWorld.setTypes(WorldUtil.toWorldTypes(world.getTypes()));

		String chatMessage = new ChatMessageBuilder()
			.append(ChatColorType.NORMAL)
			.append("Quick-hopping to World ")
			.append(ChatColorType.HIGHLIGHT)
			.append(Integer.toString(world.getId()))
			.append(ChatColorType.NORMAL)
			.append("..")
			.build();

		chatMessageManager
			.queue(QueuedMessage.builder()
				.type(ChatMessageType.CONSOLE)
				.runeLiteFormattedMessage(chatMessage)
				.build());

		if (client.getGameState() == GameState.LOGIN_SCREEN)
		{
			// on the login screen we can just change the world by ourselves
			client.changeWorld(rsWorld);
			return;
		}

		quickHopTargetWorld = rsWorld;
	}

	private void handleHop()
	{
		if (quickHopTargetWorld == null)
		{
			return;
		}

		if (client.getWidget(ComponentID.WORLD_SWITCHER_WORLD_LIST) == null)
		{
			client.openWorldHopper();

			if (++displaySwitcherAttempts >= DISPLAY_SWITCHER_MAX_ATTEMPTS)
			{
				String chatMessage = new ChatMessageBuilder()
					.append(ChatColorType.NORMAL)
					.append("Failed to quick-hop after ")
					.append(ChatColorType.HIGHLIGHT)
					.append(Integer.toString(displaySwitcherAttempts))
					.append(ChatColorType.NORMAL)
					.append(" attempts.")
					.build();

				chatMessageManager
					.queue(QueuedMessage.builder()
						.type(ChatMessageType.CONSOLE)
						.runeLiteFormattedMessage(chatMessage)
						.build());

				resetQuickHopper();
			}
		}
		else
		{
			client.hopToWorld(quickHopTargetWorld);
			resetQuickHopper();
		}
	}

	private void resetQuickHopper()
	{
		quickHopTargetWorld = null;
		displaySwitcherAttempts = 0;
	}

	@Subscribe
	public void onChatMessage(ChatMessage event)
	{
		if (event.getType() != ChatMessageType.GAMEMESSAGE)
		{
			return;
		}

		if (event.getMessage().equals("Please finish what you're doing before using the World Switcher."))
		{
			resetQuickHopper();
		}
	}

	public void hideWorld(int world, long maxTime)
	{
		hiddenWorlds.put(world, maxTime);
		updatePanelList();
	}

	public boolean isWorldHidden(ShootingStarsData data)
	{
		return hiddenWorlds.containsKey(data.getWorld()) && hiddenWorlds.get(data.getWorld()) >= data.getMaxTime();
	}

	public void resetHiddenWorlds()
	{
		hiddenWorlds.clear();
		updatePanelList();
	}
}

/*
 * Copyright (c) 2021, Andrew McAdams
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.andmcadams.shootingstars;

import java.time.Duration;
import java.time.Instant;
import lombok.Data;
import lombok.Getter;

@Data
public class ShootingStarsData
{
	@Getter
	private final int location;

	@Getter
	private final int world;

	@Getter
	private final long minTime;

	@Getter
	private final long maxTime;

	private static final String NOW_STRING = "Now";

	public ShootingStarsData(ShootingStarsLocation loc, int world, long minTime, long maxTime)
	{
		this.location = loc.getId();
		this.world = world;
		this.minTime = minTime;
		this.maxTime = maxTime;
	}

	public ShootingStarsLocation getShootingStarsLocation()
	{
		return ShootingStarsLocation.getLocation(this.location);
	}

	public boolean hasLanded()
	{
		Duration timeUntil = Duration.between(Instant.now(), Instant.ofEpochMilli(this.minTime * 1000));
		return NOW_STRING.equals(prettyPrintTime(timeUntil));
	}

	private String prettyPrintTime(Duration d)
	{
		long hours = d.toHours();
		StringBuilder timeStringBuilder = new StringBuilder();
		if (hours != 0)
			timeStringBuilder.append(hours).append(" hr ");

		long minutes = d.toMinutes() % 60;
		if (hours == 0 && minutes <= 0)
		{
			long seconds = d.getSeconds() % 60;
			if (seconds > 0)
				timeStringBuilder.append(String.format("%d sec", seconds));
			else
				timeStringBuilder.append(NOW_STRING);
		}
		else
			timeStringBuilder.append(String.format("%d min", minutes));

		return timeStringBuilder.toString();
	}

	public String getLandingTime()
	{
		String minTimeString = prettyPrintTime(Duration.between(Instant.now(), Instant.ofEpochMilli(this.minTime * 1000)));
		String maxTimeString = prettyPrintTime(Duration.between(Instant.now(), Instant.ofEpochMilli(this.maxTime * 1000)));

		// If the star has definitely landed, just return "Now"
		if (NOW_STRING.equals(maxTimeString))
			return NOW_STRING;

		return minTimeString + " - " + maxTimeString;
	}
}

package com.andmcadams.shootingstars;

import net.runelite.client.RuneLite;
import net.runelite.client.externalplugins.ExternalPluginManager;

public class ShootingStarsPluginTest
{
	public static void main(String[] args) throws Exception
	{
		ExternalPluginManager.loadBuiltin(ShootingStarsPlugin.class);
		RuneLite.main(args);
	}
}
