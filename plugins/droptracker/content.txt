package io.droptracker.util;

import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;

import java.io.IOException;
import java.time.Duration;
import java.time.format.DateTimeParseException;

/**
 * Serializes and deserializes {@link Duration} instances
 * from their equivalent ISO-8601 string representation.
 * <p>
 * This adapter exists because GSON does not ship with
 * a module for the Java 8 time API.
 *
 * @see <a href="https://github.com/google/gson/issues/1059">GSON Issue</a>
 */
public class DurationAdapter extends TypeAdapter<Duration> {
    @Override
    public void write(JsonWriter out, Duration duration) throws IOException {
        out.value(duration != null ? duration.toString() : null);
    }

    @Override
    public Duration read(JsonReader in) throws IOException {
        if (in.hasNext()) {
            try {
                return Duration.parse(in.nextString());
            } catch (DateTimeParseException ignored) {
            }
        }
        return null;
    }

    public static String formatDuration(Duration duration) {
        if (duration.toDays() > 0) {
			return duration.toDays() + " day ago";
		} else if (duration.toHours() > 0) {
			return duration.toHours() + " hr ago"; 
		} else if (duration.toMinutes() > 0) {
			return duration.toMinutes() + " min ago";
		} else {    
			return "just now";
		}
    }
}

package io.droptracker.util;


import com.google.gson.Gson;
import com.google.gson.annotations.SerializedName;
import com.google.gson.reflect.TypeToken;
import lombok.AccessLevel;
import lombok.Data;
import lombok.Setter;
import lombok.Value;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.ItemComposition;
import net.runelite.client.game.ItemManager;
import net.runelite.client.game.ItemVariationMapping;

import javax.inject.Inject;
import javax.inject.Singleton;
import java.io.BufferedReader;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.Reader;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.OptionalDouble;
import java.util.stream.Collectors;

@Slf4j
@Singleton
public class Rarity {
    private final Map<String, Collection<Drop>> dropsByNpcName = new HashMap<>(1024);
    private @Inject Gson gson;
    private @Inject ItemManager itemManager;
    public static final double EPSILON = 0.00001;
    private static final int[] FACTORIALS;

    @Inject
    void init() {
        Map<String, List<RawDrop>> raw;
        try (InputStream is = getClass().getResourceAsStream("/npc_drops.json");
             Reader reader = new BufferedReader(new InputStreamReader(Objects.requireNonNull(is)))) {
            raw = gson.fromJson(reader,
                    new TypeToken<Map<String, List<RawDrop>>>() {}.getType());
        } catch (Exception e) {
            log.error("Failed to read monster drop rates", e);
            return;
        }

        raw.forEach((npcName, rawDrops) -> {
            List<Drop> drops = rawDrops.stream()
                    .map(RawDrop::transform)
                    .flatMap(Collection::stream)
                    .collect(Collectors.toList());
            dropsByNpcName.put(npcName, drops);
        });
    }

    public OptionalDouble getRarity(String npcName, int itemId, int quantity) {
        ItemComposition composition = itemId >= 0 ? itemManager.getItemComposition(itemId) : null;
        int canonical = composition != null && composition.getNote() != -1 ? composition.getLinkedNoteId() : itemId;
        String itemName = composition != null ? composition.getMembersName() : "";
        Collection<Integer> variants = new HashSet<>(
                ItemVariationMapping.getVariations(ItemVariationMapping.map(canonical))
        );
        return dropsByNpcName.getOrDefault(npcName, Collections.emptyList())
                .stream()
                .filter(drop -> drop.getMinQuantity() <= quantity && quantity <= drop.getMaxQuantity())
                .filter(drop -> {
                    int id = drop.getItemId();
                    if (id == itemId) return true;
                    return variants.contains(id) && itemName.equals(itemManager.getItemComposition(id).getMembersName());
                })
                .mapToDouble(Drop::getProbability)
                .reduce(Double::sum);
    }

    @Value
    private static class Drop {
        int itemId;
        int minQuantity;
        int maxQuantity;
        double probability;
    }

    @Data
    @Setter(AccessLevel.PRIVATE)
    private static class RawDrop {
        private @SerializedName("i") int itemId;
        private @SerializedName("r") Integer rolls;
        private @SerializedName("d") double denominator;
        private @SerializedName("q") Integer quantity;
        private @SerializedName("m") Integer quantMin;
        private @SerializedName("n") Integer quantMax;

        Collection<Drop> transform() {
            int rounds = rolls != null ? rolls : 1;
            int min = quantMin != null ? quantMin : quantity;
            int max = quantMax != null ? quantMax : quantity;
            double prob = 1 / denominator;

            if (rounds == 1) {
                return List.of(new Drop(itemId, min, max, prob));
            }
            List<Drop> drops = new ArrayList<>(rounds);
            for (int successCount = 1; successCount <= rounds; successCount++) {
                double density = binomialProbability(prob, rounds, successCount);
                drops.add(new Drop(itemId, min * successCount, max * successCount, density));
            }
            return drops;
        }
        public double binomialProbability(double p, int nTrials, int kSuccess) {
            // https://en.wikipedia.org/wiki/Binomial_distribution#Probability_mass_function
            return binomialCoefficient(nTrials, kSuccess) * Math.pow(p, kSuccess) * Math.pow(1 - p, nTrials - kSuccess);
        }
        private int binomialCoefficient(int n, int k) {
            assert n < FACTORIALS.length && k <= n && k >= 0;
            return FACTORIALS[n] / (FACTORIALS[k] * FACTORIALS[n - k]); // https://en.wikipedia.org/wiki/nCk
        }
    }

    static {
        // precompute factorials from 0 to 9 for n-choose-k formula
        int n = 10; // max rolls in npc_drops.json is 9 (for Bloodthirsty Leagues IV tier 5 relic)
        int[] facts = new int[n];
        facts[0] = 1; // 0! = 1
        for (int i = 1; i < n; i++) {
            facts[i] = i * facts[i - 1];
        }
        FACTORIALS = facts;
    }
}
package io.droptracker.util;


import com.google.gson.Gson;
import lombok.extern.slf4j.Slf4j;
import okhttp3.*;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.annotations.Nullable;
import org.jetbrains.annotations.VisibleForTesting;

import javax.inject.Inject;
import javax.inject.Singleton;
import java.io.IOException;
import java.io.Reader;
import java.util.*;
import java.util.concurrent.CompletableFuture;
import java.util.function.Function;

/**
 * This thread-safe singleton holds a mapping of item names to their item id, using the RuneLite API.
 * <p>
 * Unlike {@link net.runelite.client.game.ItemManager#search(String)}, this mapping supports untradable items.
 *
 * Author: iProdigy ( https://github.com/pajlads/DinkPlugin )
 */

@Slf4j
@Singleton
public class ItemIDSearch {
    final String ITEM_CACHE_BASE_URL = "https://static.runelite.net/cache/item/";
    private final Map<String, Integer> itemIdByName = Collections.synchronizedMap(new HashMap<>(16384));
    private @Inject OkHttpClient httpClient;
    private @Inject Gson gson;

    /**
     * @param name the exact in-game name of an item
     * @return the id associated with the item name, or null if not found
     */
    @Nullable
    public Integer findItemId(@NotNull String name) {
        return itemIdByName.get(name);
    }

    /**
     * Begins the initialization process for {@link #itemIdByName}
     * by querying item names and noted item ids from the RuneLite API,
     * before passing them to {@link #populate(Map, Set)}
     *
     * @implNote This operation does not block the current thread,
     * by utilizing OkHttp's thread pool and Java's Fork-Join common pool.
     */
    @Inject
    void init() {
        queryNamesById()
                .thenAcceptBothAsync(
                        queryNotedItemIds().exceptionally(e -> {
                            log.error("Failed to read noted items", e);
                            return Collections.emptySet();
                        }),
                        this::populate
                )
                .exceptionally(e -> {
                    log.error("Failed to read item names", e);
                    return null;
                });
    }

    /**
     * Populates {@link #itemIdByName} with the inverted mappings of {@code namesById},
     * while skipping noted items specified in {@code notedIds}.
     *
     * @param namesById a mapping of item id's to the corresponding in-game name
     * @param notedIds  the id's of noted items
     * @implNote When multiple non-noted item id's have the same in-game name, only the earliest id is saved
     */
    @VisibleForTesting
    void populate(@NotNull Map<Integer, String> namesById, @NotNull Set<Integer> notedIds) {
        namesById.forEach((id, name) -> {
            if (!notedIds.contains(id))
                itemIdByName.putIfAbsent(name, id);
        });

        log.debug("Completed initialization of item cache with {} entries", itemIdByName.size());
    }

    /**
     * @return a mapping of item ids to their in-game names, provided by the RuneLite API
     */
    private CompletableFuture<Map<Integer, String>> queryNamesById() {
        // Read JSON as Map<String, String> first
        return queryCache("names.json", Map.class)
                .thenApply(stringMap -> {
                    Map<Integer, String> result = new HashMap<>();
                    for (Object keyObj : stringMap.keySet()) {
                        String keyStr = (String) keyObj;
                        Object valObj = stringMap.get(keyStr);
                        // Defensive: valObj might be String or something else
                        String valueStr = valObj != null ? valObj.toString() : null;
                        result.put(Integer.parseInt(keyStr), valueStr);
                    }
                    return result;
                });

    }

    /**
     * @return a set of id's of noted items, provided by the RuneLite API
     */
    private CompletableFuture<Set<Integer>> queryNotedItemIds() {
        return queryCache("notes.json", Map.class)
                .thenApply(stringMap -> {
                    Set<Integer> keys = new HashSet<>();
                    for (Object keyObj : stringMap.keySet()) {
                        keys.add(Integer.parseInt((String) keyObj));
                    }
                    return keys;
                });

    }

    /**
     * @param fileName the name of the file to query from RuneLite's cache
     * @param type     a type token that indicates how the json response should be parsed
     * @return the transformed cache response, wrapped in a future
     */
    private <T> CompletableFuture<T> queryCache(@NotNull String fileName, @NotNull Class<T> clazz) {
        return readJson(httpClient, gson, ITEM_CACHE_BASE_URL + fileName, clazz);
    }

    public <T> CompletableFuture<T> readJson(@NotNull OkHttpClient httpClient, @NotNull Gson gson, @NotNull String url, @NotNull Class<T> clazz) {
        return readUrl(httpClient, url, reader -> gson.fromJson(reader, clazz));
    }

    public <T> CompletableFuture<T> readUrl(@NotNull OkHttpClient httpClient, @NotNull String url, @NotNull Function<Reader, T> transformer) {
        CompletableFuture<T> future = new CompletableFuture<>();
        Request request = new Request.Builder().url(url).build();
        httpClient.newCall(request).enqueue(new Callback() {
            @Override
            public void onFailure(@NotNull Call call, @NotNull IOException e) {
                future.completeExceptionally(e);
            }

            @Override
            public void onResponse(@NotNull Call call, @NotNull Response response) {
                assert response.body() != null;
                try (Reader reader = response.body().charStream()) {
                    future.complete(transformer.apply(reader));
                } catch (Exception e) {
                    future.completeExceptionally(e);
                } finally {
                    response.close();
                }
            }
        });
        return future;
    }
    public class IntStringEntry {
        public int key;
        public String value;
    }
    public class IntIntEntry {
        public int key;
        public int value;
    }


}

package io.droptracker.util;

import com.google.inject.Inject;

import io.droptracker.DropTrackerConfig;
import io.droptracker.DropTrackerPlugin;
import io.droptracker.api.DropTrackerApi;
import net.runelite.client.chat.ChatColorType;
import net.runelite.client.chat.ChatMessageBuilder;
import net.runelite.api.ChatMessageType;
import net.runelite.api.Client;
import net.runelite.api.events.CommandExecuted;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.chat.QueuedMessage;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.util.ColorUtil;
import net.runelite.client.util.LinkBrowser;

import java.awt.*;


public class ChatMessageUtil {

    private boolean isMessageChecked = false;
    @Inject
    private DropTrackerConfig config;
    @Inject
    private DropTrackerApi api;
    @Inject
    private DropTrackerPlugin plugin;

    @Inject
    private ChatMessageManager chatMessageManager;

    @Inject
    private Client client;
    @Inject
    private ClientThread clientThread;

    public void checkForMessage() {
        if (isMessageChecked) {
            return;
        }
        // determine whether the player needs to be notified about a possible change to
        // the plugin
        // based on the last version they loaded, and the currently stored version
        String currentVersion = config.lastVersionNotified();
        if (currentVersion != null && !plugin.pluginVersion.equals(currentVersion + "1")) {
            api.getLatestUpdateString(newNotificationData -> {
                sendChatMessage(newNotificationData);
                // Update the internal config value of this update message
                config.setLastVersionNotified(currentVersion);
                // Add a flag to prevent multiple checks in the same session
            });
            isMessageChecked = true;

        }
    }

    @Subscribe
    public void onCommandExecuted(CommandExecuted event)
    {
        if (event.getCommand().equals("droptracker"))
        {
            LinkBrowser.browse("https://www.droptracker.io/wiki/why-api/");
        }
        if (event.getCommand().equals("debugurl"))
        {
            String apiUrlToUse = event.getArguments()[0];
            config.setCustomApiEndpoint(apiUrlToUse);
            sendChatMessage("All outgoing requests will now be sent to " + apiUrlToUse);
        }
    }
    public void warnApiSetting() {
        String message = "It is strongly recommended that you enable our API connections in the DropTracker plugin configuration. To learn more, type ::droptracker";
        Color color = ColorUtil.fromHex("#ff0000");
        String formatted = String.format("[%s] %s: %s",
                ColorUtil.wrapWithColorTag("DropTracker.io", color),
                "Warning",
                ColorUtil.wrapWithColorTag(message, color));
        chatMessageManager.queue(
                QueuedMessage.builder()
                        .type(ChatMessageType.CONSOLE)
                        .runeLiteFormattedMessage(formatted)
                        .build()
        );
    }
    public void warnClogSetting() {
        String message = "Your collection log slots will not be tracked unless you enabled the game setting: Collection log - New addition notification";
        Color color = ColorUtil.fromHex("#ff0000");
        String formatted = String.format("[%s] %s: %s",
                ColorUtil.wrapWithColorTag("DropTracker.io", color),
                "Warning",
                ColorUtil.wrapWithColorTag(message, color));
        chatMessageManager.queue(
                QueuedMessage.builder()
                        .type(ChatMessageType.CONSOLE)
                        .runeLiteFormattedMessage(formatted)
                        .build()
        );
    }

    public void sendChatMessage(String messageContent) {
        ChatMessageBuilder messageBuilder = new ChatMessageBuilder();
        messageBuilder.append(ChatColorType.HIGHLIGHT)
                .append("[")
                .append(ChatColorType.NORMAL)
                .append("DropTracker")
                .append(ChatColorType.HIGHLIGHT)
                .append("] ")
                .append(ChatColorType.NORMAL);
        messageBuilder.append(messageContent);
        final String finalMessage = messageBuilder.build();
        Color color = ColorUtil.fromHex("#ff0000");
        String formatted = String.format("[%s] %s: %s",
                ColorUtil.wrapWithColorTag("DropTracker.io", color),
                "Warning",
                ColorUtil.wrapWithColorTag(finalMessage, Color.black));
        chatMessageManager.queue(
                QueuedMessage.builder()
                        .type(ChatMessageType.CONSOLE)
                        .runeLiteFormattedMessage(finalMessage)
                        .build()
        );
    }
}

package io.droptracker.util;

import java.io.File;
import java.io.FileWriter;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.StandardCopyOption;
import java.text.SimpleDateFormat;
import java.util.Date;

import io.droptracker.DropTrackerConfig;
import javax.inject.Inject;

import lombok.extern.slf4j.Slf4j;
import net.runelite.client.RuneLite;
@Slf4j
public class DebugLogger {

    private static final String PLUGIN_DIR_NAME = "droptracker";
    private static final String LOGS_DIR_NAME = "logs";
    private static final String BASE_LOG_FILENAME = "droptracker.log";

    private static volatile DebugLogger activeInstance;

    private final DropTrackerConfig config;
    private final File logsDir;
    private final File currentLogFile;
    private final Object writeLock = new Object();
    private FileWriter writer;

    @Inject
    public DebugLogger(DropTrackerConfig config) {
        this.config = config;

        File pluginDir = new File(RuneLite.RUNELITE_DIR, PLUGIN_DIR_NAME);
        this.logsDir = new File(pluginDir, LOGS_DIR_NAME);
        if (!logsDir.exists()) {
            logsDir.mkdirs();
        }

        this.currentLogFile = new File(logsDir, BASE_LOG_FILENAME);
        rotateIfExists(currentLogFile);

        try {
            this.writer = new FileWriter(currentLogFile, true);
        } catch (IOException e) {
            // If we cannot open the writer, logging will become a no-op
            this.writer = null;
        }

        activeInstance = this;
    }

    public boolean isEnabled() {
        return config.debugLogging();
    }

    public static void log(String message) {
        DebugLogger instance = activeInstance;
        if (instance == null) {
            return;
        }
        if (!instance.isEnabled()) {
            /* Still forwarding these messages to the default Sl4fj logger;
                since we use the DebugLogger throughout as an alternative in our plugin
            */
            log.debug(message);
            return;
        }
        log.debug("DebugLogger message: " + message);
        instance.writeLine(message);
    }

    private void writeLine(String message) {
        synchronized (writeLock) {
            if (writer == null) {
                return;
            }
            try {
                writer.write(message + System.lineSeparator());
                writer.flush();
            } catch (IOException e) {
                // Swallow to avoid impacting game thread; debugging only
            }
        }
    }

    private void rotateIfExists(File file) {
        if (!file.exists()) {
            return;
        }

        long lastModified = file.lastModified();
        String ts = new SimpleDateFormat("yyyy-MM-dd_HHmmss").format(new Date(lastModified));
        File target = new File(logsDir, "droptracker-" + ts + ".log");

        if (target.exists()) {
            int idx = 1;
            File candidate;
            do {
                candidate = new File(logsDir, "droptracker-" + ts + "-" + idx + ".log");
                idx++;
            } while (candidate.exists());
            target = candidate;
        }

        try {
            Files.move(file.toPath(), target.toPath(), StandardCopyOption.ATOMIC_MOVE);
        } catch (IOException moveEx) {
            // Fallback to simple numeric roll if atomic move fails
            int idx = 1;
            File candidate;
            do {
                candidate = new File(logsDir, "droptracker-" + idx + ".log");
                idx++;
            } while (candidate.exists());
            // Best-effort rename; ignore result
            //noinspection ResultOfMethodCallIgnored
            file.renameTo(candidate);
        }
    }

    public void close() {
        synchronized (writeLock) {
            if (writer != null) {
                try {
                    writer.flush();
                    writer.close();
                } catch (IOException e) {
                    // Ignore on close
                } finally {
                    writer = null;
                }
            }
            if (activeInstance == this) {
                activeInstance = null;
            }
        }
    }
}
package io.droptracker.util;

import java.util.Optional;
import java.util.Set;
import java.util.function.Predicate;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import javax.annotation.Nullable;

import org.apache.commons.lang3.tuple.Pair;

import io.droptracker.DropTrackerPlugin;

import net.runelite.client.plugins.loottracker.LootReceived;
import net.runelite.http.api.loottracker.LootRecordType;

public class NpcUtilities {

    public static final String GAUNTLET_NAME = "Gauntlet", GAUNTLET_BOSS = "Crystalline Hunllef";
    public static final String CG_NAME = "Corrupted Gauntlet", CG_BOSS = "Corrupted Hunllef";

    public static final String TOA = "Tombs of Amascut";
    public static final String TOB = "Theatre of Blood";
    public static final String COX = "Chambers of Xeric";

    public static final Set<String> SPECIAL_NPC_NAMES = Set.of("The Whisperer", "Araxxor", "Branda the Fire Queen",
            "Eldric the Ice King", "Dusk");
    public static final Set<String> LONG_TICK_NPC_NAMES = Set.of("Grotesque Guardians", "Yama");

    public static final Pattern PRIMARY_REGEX = Pattern.compile(
            "Your (?<key>[\\w\\s:'-]+) (?<type>kill|chest|completion|success) count is:? (?<value>[\\d,]+)");
    public static final Pattern SECONDARY_REGEX = Pattern
            .compile("Your (?<type>kill|chest|completed) (?<key>[\\w\\s:]+) count is:? (?<value>[\\d,]+)");

    @SuppressWarnings("null")
    public static String getStandardizedSource(LootReceived event, DropTrackerPlugin plugin) {
        if (isCorruptedGauntlet(event, plugin)) {
            return CG_NAME;
        }
        if (plugin.lastDrop == null) {
            return event.getName();
        } else if (shouldUseChatName(event, plugin) && plugin.lastDrop.getSource() != null) {
            return plugin.lastDrop.getSource(); // distinguish entry/expert/challenge modes
        }
        return event.getName();
    }

    @SuppressWarnings("null")
    private static boolean isCorruptedGauntlet(LootReceived event, DropTrackerPlugin plugin) {
        return event.getType() == LootRecordType.EVENT && plugin.lastDrop != null
                && "The Gauntlet".equals(event.getName())
                && (CG_NAME.equals(plugin.lastDrop.getSource()) || CG_BOSS.equals(plugin.lastDrop.getSource()));
    }

    private static boolean shouldUseChatName(LootReceived event, DropTrackerPlugin plugin) {
        assert plugin.lastDrop != null;
        String lastSource = plugin.lastDrop.getSource();
        Predicate<String> coincides = source -> source.equals(event.getName()) && lastSource.startsWith(source);
        return coincides.test(TOA) || coincides.test(TOB) || coincides.test(COX);
    }

    public static Optional<Pair<String, Integer>> parseBoss(String message, DropTrackerPlugin plugin) {
        Matcher primary = PRIMARY_REGEX.matcher(message);
        Matcher secondary = SECONDARY_REGEX.matcher(message);
        Pair<String, Integer> mostRecentNpcData = null;

        if (primary.find()) {
            String boss = parsePrimaryBoss(primary.group("key"), primary.group("type"));
            String count = primary.group("value");
            if (boss != null) {
                try {
                    int killCount = Integer.parseInt(count.replace(",", ""));
                    mostRecentNpcData = Pair.of(boss, killCount);
                    plugin.ticksSinceNpcDataUpdate = 0;
                    return Optional.of(mostRecentNpcData);
                } catch (NumberFormatException e) {
                }
            }
        } else if (secondary.find()) {
            String key = parseSecondary(secondary.group("key"));
            String value = secondary.group("value");
            if (key != null) {
                try {
                    int killCount = Integer.parseInt(value.replace(",", ""));
                    mostRecentNpcData = Pair.of(key, killCount);
                    plugin.ticksSinceNpcDataUpdate = 0;
                    return Optional.of(mostRecentNpcData);
                } catch (NumberFormatException e) {
                }
            }
        }
        return Optional.empty();
    }

    @Nullable
    private static String parsePrimaryBoss(String boss, String type) {
        switch (type.toLowerCase()) {
            case "chest":
                if ("Barrows".equalsIgnoreCase(boss))
                    return boss;
                if ("Lunar".equals(boss))
                    return boss + " " + type;
                return null;

            case "completion":
                if (GAUNTLET_NAME.equalsIgnoreCase(boss))
                    return GAUNTLET_BOSS;
                if (CG_NAME.equalsIgnoreCase(boss))
                    return CG_BOSS;
                return null;

            case "kill":
                return boss;

            case "success":
                return boss;

            default:
                return null;
        }
    }

    private static String parseSecondary(String boss) {
        if (boss == null || "Wintertodt".equalsIgnoreCase(boss))
            return boss;

        int modeSeparator = boss.lastIndexOf(':');
        String raid = modeSeparator > 0 ? boss.substring(0, modeSeparator) : boss;
        if (raid.equalsIgnoreCase("Theatre of Blood")
                || raid.equalsIgnoreCase("Tombs of Amascut")
                || raid.equalsIgnoreCase("Chambers of Xeric")
                || raid.equalsIgnoreCase("Chambers of Xeric Challenge Mode"))
            return boss;

        return null;
    }

}

package io.droptracker;

import net.runelite.client.config.Config;
import net.runelite.client.config.ConfigGroup;
import net.runelite.client.config.ConfigItem;
import net.runelite.client.config.ConfigSection;

@ConfigGroup(DropTrackerConfig.GROUP)
public interface DropTrackerConfig extends Config {
    /*
     * Section Positions:
     * 1 (0) - General Settings
     * 2 (1) - Values
     * 2 (2) - Screenshots
     */
    String GROUP = "droptracker";

    /* Loot related Tracking */
    @ConfigSection(
        name = "Loot Tracking",
        description = "Define what rules you want set for loot",
        position = 1,
        closedByDefault = false
    )
    String LootSection = "Loot Tracking";

    @ConfigItem(
        keyName = "lootEmbeds",
        name = "Enable Loot Tracking",
        description = "Should we send your drops to the DropTracker?",
        position = 0,
        section = LootSection
    )
    default boolean lootEmbeds() {
        return true;
    }

    @ConfigItem(
        keyName = "valueableDrops",
        name = "Screenshot Drops",
        description = "Do you want to submit screenshots when a drop<br />"
            + "Exceeds the threshold you set?",
        position = 1,
        section = LootSection
    )
    default boolean screenshotDrops() {
        return true;
    }

    @ConfigItem(
        keyName = "screenshotValue",
        name = "Screenshot minimum",
        description = "What minimum value would you like drops to be sent with an attached image for?",
        position = 2,
        section = LootSection
    )
    default int screenshotValue() {
        return 250000;
    }

    /* Personal Best related Tracking */
    @ConfigSection(
        name = "Personal Bests",
        description = "Should we send your personal bests to the DropTracker?",
        position = 2,
        closedByDefault = false
    )
    String PbSection = "Personal Bests";

    @ConfigItem(
        keyName = "pbEmbeds",
        name = "Enable PBs",
        description = "Do you want DropTracker to track your PBs?",
        position = 1,
        section = PbSection
    )
    default boolean pbEmbeds() {
        return true;
    }

    @ConfigItem(
        keyName = "screenshotPB",
        name = "Screenshot PBs",
        description = "Do you want a screenshot to be sent\n"
            + "when you acquire a new Personal Best?",
        position = 2,
        section = PbSection
    )
    default boolean screenshotPBs() {
        return true;
    }

    /* Collection Log related Tracking */
    @ConfigSection(
        name = "Collection Logs",
        description = "<html>Define what rules you want set for Collection Log <br>"
            + "<b>Note</b>: Requires Collection Log Notification and popup Enabled in OSRS settings</html>",
        position = 3,
        closedByDefault = false
    )
    String ClogSection = "Collection Logs";

    @ConfigItem(
        keyName = "clogEmbeds",
        name = "Enable Clogs",
        description = "Should we send new collection log slot unlocks to the DropTracker?",
        position = 1,
        section = ClogSection
    )
    default boolean clogEmbeds() {
        return true;
    }

    @ConfigItem(
        keyName = "screenshotClog",
        name = "Screenshot Clogs",
        description = "Do you want screenshots to be sent when you\n"
            + "receive new collection log slots?",
        position = 2,
        section = ClogSection
    )
    default boolean screenshotNewClogs() {
        return true;
    }

    /* Combat Achievement related Tracking */
    @ConfigSection(
        name = "Combat Achievements",
        description = "Define what rules you want set for Combat Achievements",
        position = 4,
        closedByDefault = false
    )
    String CaSection = "Combat Achievements";

    @ConfigItem(
        keyName = "caEmbeds",
        name = "Enable CAs",
        description = "Should we send your Combat Achievements to the DropTracker?",
        position = 3,
        section = CaSection
    )
    default boolean caEmbeds() {
        return true;
    }

    @ConfigItem(
        keyName = "screenshotCAs",
        name = "Screenshot CAs",
        description = "Do you want a screenshot to be sent\n"
            + "when you complete a Combat Task?",
        position = 3,
        section = CaSection
    )
    default boolean screenshotCAs() {
        return true;
    }

    /* Pet related Tracking */
    @ConfigSection(
            name = "Pet Tracking",
            description = "Should we send your pets to the DropTracker?",
            position = 5,
            closedByDefault = false
    )
    String PetSection = "Pet Tracking";

    @ConfigItem(
            keyName = "petEmbeds",
            name = "Enable Pets",
            description = "Do you want DropTracker to track your Pets?",
            position = 1,
            section = PetSection
    )
    default boolean petEmbeds() {
        return true;
    }

    @ConfigItem(
            keyName = "screenshotPets",
            name = "Screenshot Pets",
            description = "Do you want to send screenshots when you acquire a pet?",
            position = 2,
            section = PetSection
    )
    default boolean screenshotPets() {
        return true;
    }


    /* Experience/Level related Tracking */
    @ConfigSection(
            name = "Experience / Level ",
            description = "Should we send your experience to the DropTracker?",
            position = 6,
            closedByDefault = false
    )
    String XPSection = "Experience / Level ";

    @ConfigItem(
            keyName = "trackExperience",
            name = "Track Experience",
            description = "Do you want to send experience gains to the DropTracker?",
            position = 1,
            section = XPSection
    )
    default boolean trackExperience() {
        return true;
    }

    @ConfigItem(
            keyName = "levelEmbed",
            name = "Enable Levels",
            description = "Do you want to send level gains to the DropTracker",
            position = 2,
            section = XPSection
    )
    default boolean levelEmbed(){ return true;}

    @ConfigItem(
            keyName = "screenshotLevel",
            name = "Screenshot Levels",
            description = "Do you want to send screenshots when you level up?",
            position = 3,
            section = XPSection
    )
    default boolean screenshotLevel(){ return true;}

    @ConfigItem(
            keyName = "minLevelToScreenshot",
            name = "Minimum Level to Screenshot",
            description = "<html>What minimum level should we take screenshots for you achieving?<br />",
            position = 4,
            section = XPSection
    )
    default int minLevelToScreenshot() {return 1;}

    /* Quest related Tracking */
    @ConfigSection(
            name = "Quest Tracking",
            description = "Should we send your quests to the DropTracker?",
            position = 7,
            closedByDefault = false
    )
    String QuestSection = "Quest Tracking";

    @ConfigItem(
            keyName = "questsEmbed",
            name = "Track Quests",
            description = "Do you want to send quest completions to the DropTracker?",
            position = 1,
            section = QuestSection
    )
    default boolean questsEmbed() {
        return true;
    }

    @ConfigItem(
            keyName = "screenshotQuests",
            name = "Screenshot Quests",
            description = "Do you want to send screenshots when you complete a quest?",
            position = 2,
            section = QuestSection
    )
    default boolean screenshotQuests() {
        return true;
    }

    /* Settings for Hiding Split Chat, Side Panel and API connections */
    @ConfigSection(
        name = "Miscellaneous",
        description = "Miscellaneous plugin config options",
        position = 8,
        closedByDefault = false
    )
    String miscSettings = "Additional Settings";

    @ConfigItem(
        keyName = "hideWhispers",
        name = "Hide PMs",
        description = "Do you want your private chat to be\n" + "hidden when screenshots are taken?",
        position = 7,
        section = miscSettings
    )
    default boolean hideDMs() {
        return false;
    }

    /* API Configuration */
    @ConfigSection(
        name = "API Configuration",
        description = "Configure settings related to integration with our external API",
        position = 9,
        closedByDefault = true
    )
    String apiSection = "API Configuration";

    @ConfigItem(
        name = "Use API Connections",
        keyName = "useApi",
        description = "Enables external connections to the DropTracker database, for panel data.<br />"
            + "<b>Note</b>: The API is currently <b>required</b> for participation in events!",
        position = 1,
        section = apiSection,
        warning = "<html><b>WARNING</b>: In order to connect to the DropTracker API,<br>"
            + "your client must make out-going connections to the developer's server.<br>"
            + "This server can not be verified by the RuneLite developers.<br>"
            + "<b>Are you sure?</b></html>"
    )
    default boolean useApi() {
        return false;
    }

    @ConfigItem(
        name = "Receive in-game messages",
        keyName = "receiveInGameMessages",
        description = "Do you want to see chat messages from the plugin to confirm your submissions/etc?",
        position = 2,
        section = apiSection
    )
    default boolean receiveInGameMessages() {
        return true;
    }
    /*
    @ConfigItem(
        name = "[ADVANCED] Custom API Endpoint",
        keyName = "customApiEndpoint",
        description = "<html><b>Warning!</b>: Changing this option will likely cause<br>your submissions to no longer be processed at all!<br>This is intended as a debugging option.</html>",
        position = 3,
        section = apiSection
    )

     */


    @ConfigItem(
        name = "Debug Logging",
        keyName = "debugLogging",
        description = "Do you want the DropTracker to log data locally to your machine for debugging purposes?",
        position = 4,
        section = apiSection
    )
    default boolean debugLogging() {
        return false;
    }

    // Removed retry queue and maxRetryAttempts settings in favor of simplified per-call retry

    /* Side panel settings */
    @ConfigSection(
        name = "Side Panel",
        description = "Configure options related to the DropTracker Panel",
        position = 10,
        closedByDefault = true
    )
    String sidePanelSection = "Side Panel";

    @ConfigItem(
        name = "Show Side Panel",
        keyName = "showSidePanel",
        description = "<html>Do you want to render the <br>side-panel to lookup players, etc?<br>"
            + "<b>Note</b>: Requires the API to be enabled.</html>",
        position = 0,
        section = sidePanelSection
    )
    default boolean showSidePanel() {
        return true;
    }
	
	@ConfigItem(
		name = "Polling Updates",
		keyName = "pollUpdates",
		description = "<html>Do you want to auto-update your DropTracker<br>" 
			+ "side panel content/stats periodically?</html>",
		position = 1,
		section = sidePanelSection
	)
	default boolean pollUpdates() {
		return true;
	}


    /* Hidden config items for storing internal info */
    @ConfigItem(
        name = "lastVersionNotified",
        keyName = "lastVersionNotified",
        description = "lastVersionNotified",
        hidden = true
    )
    default String lastVersionNotified() {
        return "0";
    }
    public void setLastVersionNotified(String versionNotified);

    @ConfigItem(
        name = "lastAccountName",
        keyName = "lastAccountName",
        description = "lastAccountName",
        hidden = true
    )
    default String lastAccountName() {
        return null;
    }
    void setLastAccountName(String accountName);

    @ConfigItem(
            name = "customApiEndpoint",
            keyName = "customApiEndpoint",
            description = "customApiEndpoint",
            hidden = true
    )
    default String customApiEndpoint() {return "";}
    void setCustomApiEndpoint(String customApiEndpoint);

    @ConfigItem(
        name = "lastAccountHash",
        keyName = "lastAccountHash",
        description = "lastAccountHash",
        hidden = true
    )
    default String lastAccountHash() {
        return null;
    }
    void setLastAccountHash(String accountHash);
}

package io.droptracker.api;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.net.URL;
import java.time.LocalDate;
import java.time.format.DateTimeFormatter;
import java.util.ArrayList;
import java.util.List;
import java.util.Random;
import java.util.concurrent.CompletableFuture;

import javax.inject.Inject;

import com.google.gson.JsonArray;
import com.google.gson.JsonElement;
import com.google.gson.JsonParser;

import lombok.extern.slf4j.Slf4j;
import net.runelite.api.annotations.Component;
import net.runelite.api.gameval.InterfaceID;
import net.runelite.api.widgets.WidgetUtil;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.util.LinkBrowser;
import io.droptracker.util.ChatMessageUtil;
import okhttp3.HttpUrl;

import io.droptracker.DropTrackerConfig;
import io.droptracker.DropTrackerPlugin;

/* Helps determine what URL to send submissions to, populates the list on startup, etc. */
@Slf4j
public class UrlManager {

    private final DropTrackerConfig config;


    @Inject
    private DropTrackerPlugin plugin;

    @Inject
    private ClientThread clientThread;

    @Inject
    private ChatMessageUtil chatMessageUtil;


    @Inject
    public UrlManager(DropTrackerConfig config, DropTrackerPlugin plugin, ClientThread clientThread, ChatMessageUtil chatMessageUtil) {
        this.config = config;
        this.plugin = plugin;
        this.clientThread = clientThread;
        this.chatMessageUtil = chatMessageUtil;
    }

    
    private static CompletableFuture<Void> endpointUrlsLoaded = new CompletableFuture<>();

    public static List<String> endpointUrls = new ArrayList<>();

    private static int webhookResetCount = 0;

	public static List<String> backupUrls = new ArrayList<>();
	
	public static Boolean usingBackups = false;


    /**
	 * Grabs a random webhook URL from a preloaded list.
	 * If not loaded yet, throws or returns null.
	 */
	public static String getRandomUrl() throws IllegalStateException {
		// Wait for URLs to be loaded, but don't block the main thread
		if (!endpointUrlsLoaded.isDone()) {
			throw new IllegalStateException("Endpoints are not yet loaded; cannot submit...");
		}
		if (endpointUrls.isEmpty()) {
			throw new IllegalStateException("No valid URLs were loaded - check logs for loading errors");
		}
		Random randomP = new Random();
		String randomUrl = endpointUrls.get(randomP.nextInt(endpointUrls.size()));
		log.debug("Selected webhook URL: {}", randomUrl.substring(0, Math.min(50, randomUrl.length())) + "...");
		return randomUrl;
	}   

    /* Determine whether the given URL is a properly-formatted Discord webhook URL or not */
    public boolean isValidDiscordWebhookUrl(HttpUrl url) {
		if (config.useApi() && (url.host().equals("api.droptracker.io") || !config.customApiEndpoint().equals(""))) {
			return true;
		}
		// Ensure that any webhook URLs returned from the GitHub page are actual Discord webhooks
		// And not external connections of some sort
		if (!"discord.com".equals(url.host()) && !url.host().endsWith(".discord.com")) {
			if(!"discordapp.com".equals(url.host()) && !url.host().endsWith(".discordapp.com")){
				return false;
			}
		}
		List<String> segments = url.pathSegments();
		if (segments.size() >= 4 && "api".equals(segments.get(0)) && "webhooks".equals(segments.get(1))) {
			return true;
		}
		return false;
	}

    /* Fetch a new list of webhook URLs from the GitHub page */
    public void fetchNewList() throws IOException {
		if (UrlManager.webhookResetCount > 10) {
			// At this point we just stop attempting to fetch new webhooks
			// Assuming that something on the backend is broken and they're not replenishing properly
			plugin.isTracking = false;
			// isTracking prevents all event processing
			return;
		}
		// Attempt to obtain a new list
		 if (backupUrls.isEmpty()) {
			 LocalDate currentDate = LocalDate.now();

			 // Define formatter for YYYYMMDD pattern
			 DateTimeFormatter formatter = DateTimeFormatter.ofPattern("yyyyMMdd");

			 // Format the date as YYYYMMDD string
			String dateString = currentDate.format(formatter);
			URL url = null;
			 // Print the result
			 if (usingBackups) {
				 url = new URL("https://droptracker-io.github.io/content/" + dateString + ".json");
			 } else {
				 url = new URL("https://droptracker-io.github.io/content/" + dateString + "-1.json");
			 }
			BufferedReader in = new BufferedReader(new InputStreamReader(url.openStream()));
			StringBuilder response = new StringBuilder();
			String inputLine;
			while ((inputLine = in.readLine()) != null) {
				response.append(inputLine);
			}
			in.close();

			JsonArray jsonArray = new JsonParser().parse(response.toString()).getAsJsonArray();

			for (JsonElement element : jsonArray) {
				try {
					String encrypted = element.getAsString();
					try {
						String decryptedUrl = FernetDecrypt.decryptWebhook(encrypted);
						if (decryptedUrl.contains("discord")) {
							backupUrls.add(decryptedUrl);
						} else {
							log.error("[DropTracker] Decrypted URL is not based on discord; skipping");
						}
					} catch (Exception e) {
						log.error("Decryption failed with error: " + e.getMessage());
					}
				} catch (Exception e) {
					log.error("Error processing element: " + e.getMessage());
				}
			}
			if (!backupUrls.isEmpty()) {
				// swap the sets out and clear the back-up set
				endpointUrls = backupUrls;
				backupUrls.clear();
				clientThread.invokeLater(() -> {
					chatMessageUtil.sendChatMessage("We are currently having some trouble transmitting your drops to our server...");
					chatMessageUtil.sendChatMessage("Please consider enabling our API in the plugin configuration to continue tracking seamlessly.");
				});

				UrlManager.webhookResetCount++;
				// toggle whether the current set of webhooks is from the backup endpoint or the main one
				// incase we need to grab a new set before the client restarts again.
				usingBackups = !usingBackups;
			}

		}

	}

    
    /* Open a link in the browser */
    public void openLink(String destination) {
		HttpUrl webUrl = HttpUrl.parse("https://discord.gg/dvb7yP7JJH");
		if (!destination.contains("https://")) {
			if (destination == "website" && config.useApi()) {
				webUrl = HttpUrl.parse("https://www.droptracker.io/");
			}
		} else {
			webUrl = HttpUrl.parse(destination);
		}
		if (webUrl == null) {
			return;
		}
		HttpUrl.Builder urlBuilder = webUrl.newBuilder();
		HttpUrl url = urlBuilder.build();
		LinkBrowser.browse(url.toString());
		return;
	}

    
	/* Load URLs in the background from the GitHub pages site */
	public void loadEndpoints() {
		try {
			if (endpointUrls.isEmpty()) {
				
				LocalDate currentDate = LocalDate.now();

				// Define formatter for YYYYMMDD pattern
				DateTimeFormatter formatter = DateTimeFormatter.ofPattern("yyyyMMdd");
   
				// Format the date as YYYYMMDD string
			    String dateString = currentDate.format(formatter);
				URL url = new URL("https://droptracker-io.github.io/content/" + dateString + ".json");
				BufferedReader in = new BufferedReader(new InputStreamReader(url.openStream()));
				// Get the encryption key first from github
				URL keyUrl = new URL("https://droptracker-io.github.io/content/" + dateString + "-k.txt");
				BufferedReader keyIn = new BufferedReader(new InputStreamReader(keyUrl.openStream()));	
				String loaded_key = keyIn.readLine();
				keyIn.close();
				if (loaded_key != null) {
					FernetDecrypt.ENCRYPTION_KEY = loaded_key;
				} else {
					return;
				}
				StringBuilder response = new StringBuilder();
				String inputLine;
				while ((inputLine = in.readLine()) != null) {
					response.append(inputLine);
				}
				in.close();

				JsonArray jsonArray = new JsonParser().parse(response.toString()).getAsJsonArray();

				for (JsonElement element : jsonArray) {
					try {
						String encrypted = element.getAsString();
						try {
							String decryptedUrl = FernetDecrypt.decryptWebhook(encrypted);
							// Always load Discord webhook URLs as they're needed for both API disabled users
							// and as fallback URLs when API is enabled but fails
							if (decryptedUrl.contains("discord")) {
								endpointUrls.add(decryptedUrl);
							} else {
								log.error("[DropTracker] Decrypted URL is not based on discord; skipping: " + decryptedUrl);
							}
						} catch (Exception e) {
							log.error("Decryption failed with error: " + e.getMessage());
						}
					} catch (Exception e) {
						log.error("Error processing element: " + e.getMessage());
					}
				}
			}
			log.info("Successfully loaded {} webhook URLs from GitHub", endpointUrls.size());
			endpointUrlsLoaded.complete(null);
		} catch (Exception e) {
			log.error("Failed to load webhook URLs from GitHub", e);
			endpointUrlsLoaded.completeExceptionally(e);
		}
	}


}

package io.droptracker.api;

import javax.crypto.Cipher;
import javax.crypto.Mac;
import javax.crypto.spec.IvParameterSpec;
import javax.crypto.spec.SecretKeySpec;
import java.nio.charset.StandardCharsets;
import java.util.Arrays;
import java.util.Base64;

import javax.inject.Inject;
import javax.inject.Singleton;
import lombok.extern.slf4j.Slf4j;

@Slf4j
@Singleton
public class FernetDecrypt {
    public static String ENCRYPTION_KEY = "";

    @Inject
    public FernetDecrypt() {
    }

    public static String decryptWebhook(String webhookHash) throws Exception {
        try {
            // First decode - get the Fernet token
            String fernetToken = new String(Base64.getUrlDecoder().decode(webhookHash), StandardCharsets.UTF_8);
            
            // Second decode - get the encrypted data
            byte[] token = Base64.getUrlDecoder().decode(fernetToken);
            
            // Decode the key
            byte[] keyBytes = Base64.getUrlDecoder().decode(ENCRYPTION_KEY);
            byte[] signingKey = Arrays.copyOfRange(keyBytes, 0, 16);
            byte[] encryptionKey = Arrays.copyOfRange(keyBytes, 16, 32);

            // Extract components according to Fernet spec:
            // Version (1 byte) + Timestamp (8 bytes) + IV (16 bytes) + Ciphertext + HMAC (32 bytes)
            if (token.length < 57) { // Minimum size: 1+8+16+0+32
                throw new IllegalArgumentException("Token too short: " + token.length);
            }
            
            byte version = token[0];
            
            // Skip timestamp (bytes 1-8) - not needed for decryption
            
            // Extract IV (bytes 9-24)  
            byte[] iv = Arrays.copyOfRange(token, 9, 25);

            // Get the HMAC (last 32 bytes)
            byte[] hmac = Arrays.copyOfRange(token, token.length - 32, token.length);
            byte[] message = Arrays.copyOfRange(token, 0, token.length - 32);
            
            // Verify HMAC
            Mac mac = Mac.getInstance("HmacSHA256");
            mac.init(new SecretKeySpec(signingKey, "HmacSHA256"));
            byte[] calculatedHmac = mac.doFinal(message);
            
            if (!Arrays.equals(hmac, calculatedHmac)) {
                throw new SecurityException("Invalid HMAC");
            }

            // Get ciphertext (everything between IV and HMAC)
            // Start at byte 25 (after version + timestamp + IV)
            byte[] ciphertext = Arrays.copyOfRange(token, 25, token.length - 32);
            // Decrypt
            Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5Padding");
            cipher.init(Cipher.DECRYPT_MODE, 
                       new SecretKeySpec(encryptionKey, "AES"),
                       new IvParameterSpec(iv));
            
            byte[] decryptedBytes = cipher.doFinal(ciphertext);
            String result = new String(decryptedBytes, StandardCharsets.UTF_8);
            
            // Post-process the result to fix common issues
            result = postProcessDecryptedUrl(result);
            
            return result; 
        } catch (Exception e) {
            log.error("Decryption failed for webhook hash: {}", webhookHash.substring(0, Math.min(20, webhookHash.length())) + "...", e);
            throw e;
        }
    }
    
    /**
     * Post-process decrypted URL to fix common corruption issues
     */
    private static String postProcessDecryptedUrl(String decrypted) {
        if (decrypted == null || decrypted.isEmpty()) {
            return decrypted;
        }
        
        // Remove non-printable characters from the beginning
        String cleaned = decrypted.replaceAll("^[\\p{Cntrl}\\p{So}\\p{Cn}]+", "");
        
        // Look for the webhook path pattern
        int webhookIndex = cleaned.indexOf("/api/webhooks/");
        if (webhookIndex > 0) {
            // Extract just the webhook path part
            cleaned = cleaned.substring(webhookIndex);
        }
        
        // If it starts with /api/webhooks/, prepend the Discord domain
        if (cleaned.startsWith("/api/webhooks/")) {
            cleaned = "https://discord.com" + cleaned;
        }
        
        // If it contains .com/api/webhooks but doesn't start with https://, try to fix it
        if (cleaned.contains("com/api/webhooks/") && !cleaned.startsWith("https://")) {
            int comIndex = cleaned.indexOf("com/api/webhooks/");
            if (comIndex >= 0) {
                cleaned = "https://discord." + cleaned.substring(comIndex);
            }
        }
        return cleaned;
    }
}

package io.droptracker.api;

import com.google.gson.Gson;
import com.google.gson.JsonSyntaxException;

import io.droptracker.DropTrackerConfig;
import io.droptracker.DropTrackerPlugin;
import io.droptracker.models.api.GroupConfig;
import io.droptracker.models.api.GroupSearchResult;
import io.droptracker.models.api.PlayerSearchResult;
import io.droptracker.models.api.TopGroupResult;
import io.droptracker.models.api.TopPlayersResult;
import io.droptracker.util.DebugLogger;
import lombok.extern.slf4j.Slf4j;
import okhttp3.*;
import net.runelite.api.Client;
import org.jetbrains.annotations.NotNull;

import javax.inject.Inject;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.Map;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.ThreadLocalRandom;

@Slf4j
public class DropTrackerApi {
    private final DropTrackerConfig config;
    @Inject
    private Gson gson;
    @Inject
    private OkHttpClient httpClient;
    @Inject
    private DropTrackerPlugin plugin;

    @Inject
    private Client client;

    public List<GroupConfig> groupConfigs = new ArrayList<>();

    private int lastGroupConfigUpdateUnix = 0;
    private boolean isLoadingGroupConfigs = false;

    public int lastCommunicationTime = (int) (System.currentTimeMillis() / 1000);
    
   

    @Inject
    public DropTrackerApi(DropTrackerConfig config, Gson gson, OkHttpClient httpClient, DropTrackerPlugin plugin, Client client) {
            this.config = config;
            this.gson = gson;
            this.httpClient = httpClient;
            this.plugin = plugin;
            this.client = client;
    }
    


    /* Group Configs */
    @SuppressWarnings({ "null" })
    public synchronized void loadGroupConfigs(String playerName) throws IOException {
        if (!config.useApi()) {
            return;
        }
        
        if (client.getAccountHash() == -1 || playerName == null) {
            return;
        }
        
        // Prevent concurrent loading
        if (isLoadingGroupConfigs) {
            return;
        }
        
        isLoadingGroupConfigs = true;
        
        CompletableFuture.runAsync(() -> {
            String responseData = null;
            try {
                String apiUrl = getApiUrl();
                String fullUrl = apiUrl + "/load_config?player_name=" + playerName + "&acc_hash=" + client.getAccountHash();
                
                HttpUrl url = HttpUrl.parse(fullUrl);
                if (url == null) {
                    return;
                }
                
                Request request = new Request.Builder().url(url).build();
                
                try (Response response = httpClient.newCall(request).execute()) {
                    lastCommunicationTime = (int) (System.currentTimeMillis() / 1000);
                    
                    if (!response.isSuccessful()) {
                        throw new IOException("API request failed with status: " + response.code());
                    }
                    
                    if (response.body() == null) {
                        throw new IOException("Empty response body");
                    }
                    
                    responseData = response.body().string();
                    
                    // Parse the response
                    GroupConfig[] configArray = gson.fromJson(responseData, GroupConfig[].class);
                    List<GroupConfig> parsedConfigs = new ArrayList<>(Arrays.asList(configArray));
                    
                    if (parsedConfigs != null) {
                        groupConfigs = parsedConfigs;
                    }
                    
                    lastGroupConfigUpdateUnix = (int) (System.currentTimeMillis() / 1000);
                    
                } catch (IOException e) {
                    log.debug("Couldn't load group config in side panel (IOException) " + e);
                } catch (JsonSyntaxException e) {
                    log.debug("Couldn't load group config in side panel (JsonSyntaxException) " + e);
                } catch (Exception e) {
                    log.debug("Couldn't load group config in side panel (Exception) " + e);
                }
            } finally {
                isLoadingGroupConfigs = false;
            }
        }).exceptionally(ex -> {
            log.debug(ex.getMessage());
            isLoadingGroupConfigs = false;
            return null;
        });
    }

    /* Get all players' group configs from memory */
    public List<GroupConfig> getGroupConfigs() {
        if (!config.useApi()) {
            return null;
        }
        /* Reload group configs if they haven't been updated in the last 120 seconds */
        if (lastGroupConfigUpdateUnix < (int) (System.currentTimeMillis() / 1000) - 120 && !isLoadingGroupConfigs) {
            try {
                loadGroupConfigs(plugin.getLocalPlayerName());
            } catch (IOException e) {
                log.debug("Couldn't get group config in side panel (IOException) " + e);
            }
        }
        
        return groupConfigs;
    }

    /* Submissions */
    public String generateGuidForSubmission() {
        long timestamp = System.currentTimeMillis() / 1000L;
        long accountHash = client != null ? client.getAccountHash() : -1L;
        long randomPart = ThreadLocalRandom.current().nextLong(Long.MAX_VALUE);
        return timestamp + "-" + accountHash + "-" + randomPart;
    }
    


    @SuppressWarnings("null")
    public TopGroupResult getTopGroups() {
        if (!config.useApi()) {
            return null;
        }
        String apiUrl = getApiUrl();
        try {
            HttpUrl url = HttpUrl.parse(apiUrl + "/top_groups");
            Request request = new Request.Builder().url(url).build();
            try (Response response = httpClient.newCall(request).execute()) {
                lastCommunicationTime = (int) (System.currentTimeMillis() / 1000);
                if (!response.isSuccessful()) {
                    throw new IOException("API request failed with status: " + response.code());
                }
                if (response.body() == null) {
                    throw new IOException("Empty response body");
                } else {
                    String responseData = response.body().string();
                    return this.gson.fromJson(responseData, TopGroupResult.class);
                }
            }
        } catch (IOException e) {
            log.debug("Couldn't get top groups (IOException) " + e);
            return null;
        }
    }

    @SuppressWarnings("null")
    public TopPlayersResult getTopPlayers() {
        if (!config.useApi()) {
            return null;
        }
        String apiUrl = getApiUrl();
        try {
            HttpUrl url = HttpUrl.parse(apiUrl + "/top_players");
            Request request = new Request.Builder().url(url).build();
            try (Response response = httpClient.newCall(request).execute()) {
                lastCommunicationTime = (int) (System.currentTimeMillis() / 1000);
                if (!response.isSuccessful()) {
                    throw new IOException("API request failed with status: " + response.code());
                }
                if (response.body() == null) {
                    throw new IOException("Empty response body");
                } else {
                    String responseData = response.body().string();
                    return gson.fromJson(responseData, TopPlayersResult.class);
                }
            }
        } catch (IOException e) {
            log.debug("Couldn't get top players (IOException) " + e);
            return null;
        }
    }

    /**
     * Sends a request to the API to search for a group and returns the GroupSearchResult.
     */
    @SuppressWarnings({ "null", "unchecked" })
    public GroupSearchResult searchGroup(String groupName) throws IOException {
        if (!config.useApi()) {
            return null;
        }

        String apiUrl = getApiUrl();
        HttpUrl url = HttpUrl.parse(apiUrl + "/group_search?name=" + groupName);

        if (url == null) {
            throw new IllegalArgumentException("Invalid URL");
        }

        Request request = new Request.Builder().url(url).build();
        lastCommunicationTime = (int) (System.currentTimeMillis() / 1000);

        try (Response response = httpClient.newCall(request).execute()) {
            if (!response.isSuccessful()) {
                throw new IOException("API request failed with status: " + response.code());
            }

            if (response.body() == null) {
                throw new IOException("Empty response body");
            }

            String responseData = response.body().string();
            
            // Try to parse as GroupSearchResult first
            try {
                return gson.fromJson(responseData, GroupSearchResult.class);
            } catch (Exception e) {
                // If direct parsing fails, try to parse as Map and convert
                // NOTE: This feels very ugly - we own the API. We should know the returned format
                Map<String, Object> responseMap = gson.fromJson(responseData, Map.class);
                String jsonString = gson.toJson(responseMap);
                return gson.fromJson(jsonString, GroupSearchResult.class);
            }
        }
    }

    /**
     * Sends a request to the API to look up a player's data and returns the PlayerSearchResult.
     */
    @SuppressWarnings("null")
    public PlayerSearchResult lookupPlayer(String playerName) throws IOException {
        if (!config.useApi()) {
            return null;
        }

        String apiUrl = getApiUrl();
        HttpUrl url = HttpUrl.parse(apiUrl + "/player_search?name=" + playerName);

        if (url == null) {
            throw new IllegalArgumentException("Invalid URL");
        }

        Request request = new Request.Builder().url(url).build();
        lastCommunicationTime = (int) (System.currentTimeMillis() / 1000);
        try (Response response = httpClient.newCall(request).execute()) {
            if (!response.isSuccessful()) {
                throw new IOException("API request failed with status: " + response.code());
            }

            if (response.body() == null) {
                throw new IOException("Empty response body");
            }

            String responseData = response.body().string();
            
            // Try to parse as PlayerSearchResult first
            try {
                return gson.fromJson(responseData, PlayerSearchResult.class);
            } catch (Exception e) {
                // If direct parsing fails, try to parse as Map and convert
                // NOTE: We own the API - we should make sure we return values that can be parsed
                @SuppressWarnings("unchecked")
                Map<String, Object> responseMap = gson.fromJson(responseData, Map.class);
                String jsonString = gson.toJson(responseMap);
                return gson.fromJson(jsonString, PlayerSearchResult.class);
            }
        }
    }

    public String getApiUrl() {
        if (config.customApiEndpoint().equals("")) {
            return config.useApi() ? "https://api.droptracker.io" : "";
        } else {
            if (!config.customApiEndpoint().startsWith("http")) {
                return "http://" + config.customApiEndpoint();
            }
            return config.customApiEndpoint();
        }
    }


    /**
     * Check whether a submission with the given uuid has been processed by the API.
     * Sends a JSON body {"uuid": "..."} to {apiUrl}/check via POST.
     * Returns true if the API explicitly reports the submission as processed.
     */
    public boolean checkSubmissionProcessed(String uuid) throws IOException {
        if (!config.useApi() || uuid == null || uuid.isEmpty()) {
            return false;
        }

        String apiUrl = getApiUrl();
        HttpUrl url = HttpUrl.parse(apiUrl + "/check");
        if (url == null) {
            throw new IllegalArgumentException("Invalid URL");
        }

        // Build JSON body
        String jsonBody = gson.toJson(java.util.Collections.singletonMap("uuid", uuid));
        RequestBody body = RequestBody.create(MediaType.parse("application/json; charset=utf-8"), jsonBody);

        Request request = new Request.Builder()
            .url(url)
            .post(body)
            .build();

        try (Response response = httpClient.newCall(request).execute()) {
            lastCommunicationTime = (int) (System.currentTimeMillis() / 1000);
            
            if (!response.isSuccessful()) {
                return false;
            }
            ResponseBody responseBody = response.body();
            if (responseBody == null) {
                return false;
            }
            String responseData = responseBody.string();
            
            try {
                // Response is expected to contain at least { processed: boolean } for the given uuid
                @SuppressWarnings("unchecked")
                java.util.Map<String, Object> map = gson.fromJson(responseData, java.util.Map.class);
                Object processedVal = map != null ? map.get("processed") : null;
                
                if (processedVal instanceof Boolean) {
                    return (Boolean) processedVal;
                }
                // Some APIs might return status: "processed"
                Object statusVal = map != null ? map.get("status") : null;
                
                if (statusVal instanceof String) {
                    return "processed".equalsIgnoreCase((String) statusVal);
                }
            } catch (Exception e) {
                // If parsing fails, consider it not processed
                return false;
            }
        }

        return false;
    }

    /**
     * Asynchronously fetches the latest welcome string to avoid blocking the EDT.
     * @param callback Function to call with the result when ready
     */
    public void getLatestWelcomeString(java.util.function.Consumer<String> callback) {
        String endpoint;
        if (config.useApi()) {
            endpoint = getApiUrl() + "/latest_welcome";
        } else {
            endpoint = "https://droptracker-io.github.io/content/welcome.txt";
        }

        Request request = new Request.Builder().url(endpoint).build();
        httpClient.newCall(request).enqueue(new Callback() {
            @Override
            public void onFailure(@NotNull Call call, @NotNull IOException e) {
                // Run callback on EDT to update UI safely
                javax.swing.SwingUtilities.invokeLater(() -> 
                    callback.accept("Welcome to the DropTracker!"));
            }

            @Override
            public void onResponse(@NotNull Call call, @NotNull Response response) throws IOException {
                try (Response autoCloseResponse = response; ResponseBody responseBody = response.body()) {
                    String result;
                    if (response.isSuccessful() && responseBody != null) {
                        result = responseBody.string();
                    } else {
                        result = "Welcome to the DropTracker!";
                    }
                    
                    // Run callback on EDT to update UI safely
                    javax.swing.SwingUtilities.invokeLater(() -> callback.accept(result));
                }
            }
        });
    }

    /**
     * Asynchronously fetches the latest update string to avoid blocking the EDT.
     * @param callback Function to call with the result when ready
     */
    public void getLatestUpdateString(java.util.function.Consumer<String> callback) {
        String endpoint;
        if (config.useApi()) {
            endpoint = getApiUrl() + "/latest_news";
        } else {
            endpoint = "https://droptracker-io.github.io/content/news.txt";
        }

        Request request = new Request.Builder().url(endpoint).build();
        httpClient.newCall(request).enqueue(new Callback() {
            @Override
            public void onFailure(@NotNull Call call, @NotNull IOException e) {
                // Run callback on EDT to update UI safely
                javax.swing.SwingUtilities.invokeLater(() -> 
                    callback.accept("Error fetching latest update: " + e.getMessage()));
            }

            @Override
            public void onResponse(@NotNull Call call, @NotNull Response response) throws IOException {
                try (Response autoCloseResponse = response; ResponseBody responseBody = response.body()) {
                    String result;
                    if (response.isSuccessful() && responseBody != null) {
                        result = responseBody.string();
                    } else {
                        result = "Error fetching latest update: " + (responseBody != null ? responseBody.string() : "Unknown error");
                    }
                    
                    // Run callback on EDT to update UI safely
                    javax.swing.SwingUtilities.invokeLater(() -> callback.accept(result));
                }
            }
        });
    }

    /**
     * Query the API (or github pages) for a list of 'valuable' untradeables; or in other words,
     * a list of items that have modified 'true' values based on what they are components towards
     * For example, a bludgeon axon should be worth 1/3 the price of a bludgeon.
     * Since this list should be updated infrequently, we can simply load only if not present.
     */
    public ArrayList<Integer> getValuedUntradeables() {
        String valued;
        String url;
        if (config.useApi()) {
            url = getApiUrl() + "/value_mods";
        } else {
            url = "https://droptracker-io.github.io/content/valued_items.txt";
        }
        try {
            Request request = new Request.Builder().url(url).build();
            try (Response response = httpClient.newCall(request).execute()) {
                lastCommunicationTime = (int) (System.currentTimeMillis() / 1000);
                if (!response.isSuccessful()) {
                    throw new IOException("API request failed with status: " + response.code());
                }
                if (response.body() == null) {
                    throw new IOException("Empty response body");
                } else {
                    valued = response.body().string();
                    String[] valuedList = valued.split(",");
                    ArrayList<Integer> itemIdList = new ArrayList<>();
                    for (String itemIdString : valuedList) {
                        try {
                            String idStripped = itemIdString.replace("\"", "").replace("[", "").replace("]", "");
                            int itemId = Integer.parseInt(idStripped.trim());
                            itemIdList.add(itemId);
                        } catch (NumberFormatException e) {
                            // Handle cases where a part of the string isn't a valid integer
                            DebugLogger.log("Skipping invalid item ID: " + itemIdString);
                        }
                    }
                    DebugLogger.log("Loaded item ID list: " + itemIdList.toString());
                    return itemIdList;
                }
            }
        } catch (IOException e) {
            DebugLogger.log("Unable to load 'valued untradeables' from " + (config.useApi() ? "API" : "GitHub") + e);
            return null;
        }
    }

    public interface PanelDataLoadedCallback {
        void onDataLoaded(Map<String, Object> data);
    }
}

/*
 * Copyright (c) 2021, Illya Myshakov <https://github.com/IllyaMyshakov>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package io.droptracker.models;

import lombok.AllArgsConstructor;
import lombok.Getter;
import net.runelite.api.ItemID;

@AllArgsConstructor
@Getter
public enum Pet
{
    ABYSSAL_ORPHAN("Abyssal orphan", ItemID.ABYSSAL_ORPHAN),
    IKKLE_HYDRA("Ikkle hydra", ItemID.IKKLE_HYDRA),
    CALLISTO_CUB("Callisto cub", ItemID.CALLISTO_CUB),
    HELLPUPPY("Hellpuppy", ItemID.HELLPUPPY),
    PET_CHAOS_ELEMENTAL("Pet chaos elemental", ItemID.PET_CHAOS_ELEMENTAL),
    PET_ZILYANA("Pet zilyana", ItemID.PET_ZILYANA),
    PET_DARK_CORE("Pet dark core", ItemID.PET_DARK_CORE),
    PET_DAGANNOTH_PRIME("Pet dagannoth prime", ItemID.PET_DAGANNOTH_PRIME),
    PET_DAGANNOTH_SUPREME("Pet dagannoth supreme", ItemID.PET_DAGANNOTH_SUPREME),
    PET_DAGANNOTH_REX("Pet dagannoth rex", ItemID.PET_DAGANNOTH_REX),
    TZREKJAD("Tzrek-jad", ItemID.TZREKJAD),
    PET_GENERAL_GRAARDOR("Pet general graardor", ItemID.PET_GENERAL_GRAARDOR),
    BABY_MOLE("Baby mole", ItemID.BABY_MOLE),
    NOON("Noon", ItemID.NOON),
    JALNIBREK("Jal-nib-rek", ItemID.JALNIBREK),
    KALPHITE_PRINCESS("Kalphite princess", ItemID.KALPHITE_PRINCESS),
    PRINCE_BLACK_DRAGON("Prince black dragon", ItemID.PRINCE_BLACK_DRAGON),
    PET_KRAKEN("Pet kraken", ItemID.PET_KRAKEN),
    PET_KREEARRA("Pet kree'arra", ItemID.PET_KREEARRA),
    PET_KRIL_TSUTSAROTH("Pet k'ril tsutsaroth", ItemID.PET_KRIL_TSUTSAROTH),
    SCORPIAS_OFFSPRING("Scorpia's offspring", ItemID.SCORPIAS_OFFSPRING),
    SKOTOS("Skotos", ItemID.SKOTOS),
    PET_SMOKE_DEVIL("Pet smoke devil", ItemID.PET_SMOKE_DEVIL),
    VENENATIS_SPIDERLING("Venenatis spiderling", ItemID.VENENATIS_SPIDERLING),
    VETION_JR("Vet'ion jr.", ItemID.VETION_JR),
    VORKI("Vorki", ItemID.VORKI),
    PHOENIX("Phoenix", ItemID.PHOENIX),
    PET_SNAKELING("Pet snakeling", ItemID.PET_SNAKELING),
    OLMLET("Olmlet", ItemID.OLMLET),
    LIL_ZIK("Lil' zik", ItemID.LIL_ZIK),
    BLOODHOUND("Bloodhound", ItemID.BLOODHOUND),
    PET_PENANCE_QUEEN("Pet penance queen", ItemID.PET_PENANCE_QUEEN),
    HERON("Heron", ItemID.HERON),
    ROCK_GOLEM("Rock golem", ItemID.ROCK_GOLEM),
    BEAVER("Beaver", ItemID.BEAVER),
    BABY_CHINCHOMPA("Baby chinchompa", ItemID.BABY_CHINCHOMPA_13324),
    GIANT_SQUIRREL("Giant squirrel", ItemID.GIANT_SQUIRREL),
    TANGLEROOT("Tangleroot", ItemID.TANGLEROOT),
    ROCKY("Rocky", ItemID.ROCKY),
    RIFT_GUARDIAN("Rift guardian", ItemID.RIFT_GUARDIAN),
    HERBI("Herbi", ItemID.HERBI),
    CHOMPY_CHICK("Chompy chick", ItemID.CHOMPY_CHICK),
    SRARACHA("Sraracha", ItemID.SRARACHA),
    SMOLCANO("Smolcano", ItemID.SMOLCANO),
    YOUNGLLEF("Youngllef", ItemID.YOUNGLLEF),
    LITTLE_NIGHTMARE("Little nightmare", ItemID.LITTLE_NIGHTMARE),
    LIL_CREATOR("Lil' creator", ItemID.LIL_CREATOR),
    TINY_TEMPOR("Tiny tempor", ItemID.TINY_TEMPOR),
    NEXLING("Nexling", ItemID.NEXLING),
    ABYSSAL_PROTECTOR("Abyssal protector", ItemID.ABYSSAL_PROTECTOR),
    ;

    private final String name;
    private final Integer iconID;

    static Pet findPet(String petName)
    {
        for (Pet pet : values())
        {
            if (pet.name.equals(petName))
            {
                return pet;
            }
        }
        return null;
    }
}
package io.droptracker.models;

import java.util.ArrayList;
import java.util.List;
import lombok.Data;

@Data
public class CustomWebhookBody
{
	private String content;
	private List<Embed> embeds = new ArrayList<>();
	private static Author DropTracker = new Author("https://www.droptracker.io/",
			"DropTracker",
			"https://www.droptracker.io/img/droptracker-small.gif");

	@Data
	public static class Embed
	{
		public String title = "";
		UrlEmbed image = null;
		final Author author = DropTracker;
		final List<Field> fields = new ArrayList<>();
		public void addField(String name, String value, boolean inline) {
			this.fields.add(new Field(name, value, inline));
		}
		public void setImage(String imageUrl) {
			this.image = new UrlEmbed(imageUrl);
		}
	}

	@Data
	public static class UrlEmbed
	{
		final String url;
	}
	@Data
	public static class Author
	{
		final String url;
		final String name;
		final String icon_url;
	}
	@Data
	public static class Field
	{
		final String name;
		final String value;
		final boolean inline;
	}

	public String getField(CustomWebhookBody.Embed embed, String fieldName) {
        for (CustomWebhookBody.Field field : embed.getFields()) {
            if (field.getName().equals(fieldName)) {
                return field.getValue();
            }   
        }
        return null;
    }
}

package io.droptracker.models.api;

import com.google.gson.annotations.SerializedName;

import io.droptracker.models.submissions.RecentSubmission;
import lombok.Data;

import java.util.List;
import java.util.Map;

@Data
public class PlayerSearchResult {
    @SerializedName("player_name")
    private String playerName;
    
    @SerializedName("droptracker_player_id")
    private Integer dropTrackerPlayerId;
    
    @SerializedName("registered")
    private boolean registered;
    
    @SerializedName("total_loot")
    private String totalLoot;
    
    @SerializedName("global_rank")
    private int globalRank;
    
    
    @SerializedName("groups")
    private List<PlayerGroup> groups;
    
    @SerializedName("recent_submissions")
    private List<RecentSubmission> recentSubmissions;
    
    @SerializedName("top_npcs_by_loot")
    private List<TopNpcByLoot> topNpcsByLoot;
    
    @SerializedName("player_stats")  
    private PlayerStats playerStats;

    @SerializedName("points")
    private int points;
    
    // Raw JSON data for any additional fields not explicitly mapped
    private transient Map<String, Object> additionalData;

    @Data
    public static class TopNpcByLoot {
        @SerializedName("npc_name")
        private String npcName;
        
        @SerializedName("total_loot_value")
        private long totalLootValue;
        
        @SerializedName("kill_count")
        private int killCount;
        
        @SerializedName("average_loot")
        private long averageLoot;
        
        @SerializedName("best_drop_value")
        private long bestDropValue;
        
        @SerializedName("rank")
        private Integer rank;
    }

    @Data
    public static class PlayerStats {
        @SerializedName("total_submissions")
        private int totalSubmissions;
        
        @SerializedName("total_loot_value")
        private long totalLootValue;
        
        @SerializedName("favorite_boss")
        private String favoriteBoss;
        
        @SerializedName("registration_date")
        private String registrationDate;
    }

    @Data
    public static class TopNpc {
        @SerializedName("name")
        private String name;
        
        @SerializedName("rank")
        private Integer rank;
        
        @SerializedName("loot")
        private String loot;
    }

    @Data
    public static class PlayerGroup {
        @SerializedName("name")
        private String name;
        
        @SerializedName("id")
        private Integer id;
        
        @SerializedName("loot")
        private String loot;
        
        @SerializedName("members")
        private Integer members;
    }
}

package io.droptracker.models.api;

import java.util.List;
import com.google.gson.annotations.SerializedName;
import lombok.Data;
import lombok.Value;

@Data
public class TopPlayersResult {
    private List<TopPlayer> players;

    @Value
    public static class TopPlayer {
        @SerializedName("player_name")
        String playerName;
        
        @SerializedName("rank")
        Integer rank;
        
        @SerializedName("total_loot")
        String totalLoot;
    }
} 
package io.droptracker.models.api;

import java.util.List;

import com.google.gson.annotations.SerializedName;
import lombok.Data;

/// Defines the top groups as returned by the API when the panel initially loads, or when the user refreshes the group page
@Data
public class TopGroupResult {
    @SerializedName("groups")
    private List<TopGroup> groups;

    /// Nested class for individual group data
    @Data
    public static class TopGroup {
        @SerializedName("group_name")
        private String groupName;
        
        @SerializedName("total_loot")
        private String totalLoot;
        
        @SerializedName("rank")
        private Integer rank;
        
        @SerializedName("group_id")
        private Integer groupId;
        
        @SerializedName("member_count")
        private Integer memberCount;

        @SerializedName("top_member")
        private String topMemberString;
    }
    
}

package io.droptracker.models.api;

import com.google.gson.annotations.SerializedName;

import io.droptracker.models.submissions.RecentSubmission;
import lombok.Data;

import java.util.List;
import java.util.Map;

@Data
public class GroupSearchResult {
    @SerializedName("group_name")
    private String groupName;
    
    @SerializedName("group_description")
    private String groupDescription;
    
    @SerializedName("group_image_url")
    private String groupImageUrl;
    
    @SerializedName("group_droptracker_id")
    private Integer groupDropTrackerId;
    
    @SerializedName("group_members")
    private String groupMembers;
    
    @SerializedName("group_rank")
    private String groupRank;
    
    @SerializedName("group_loot")
    private String groupLoot;
    
    @SerializedName("group_top_player")
    private String groupTopPlayer;
    
    @SerializedName("group_recent_submissions")
    private List<RecentSubmission> groupRecentSubmissions;
    
    @SerializedName("group_stats")
    private GroupStats groupStats;

    @SerializedName("public_discord_link")
    private String publicDiscordLink;
    
    // Raw JSON data for any additional fields not explicitly mapped
    private transient Map<String, Object> additionalData;

    @Data
    public static class GroupStats {
        @SerializedName("total_members")
        private int totalMembers;
        
        @SerializedName("monthly_loot")
        private String monthlyLoot;
        
        @SerializedName("global_rank")
        private String globalRank;
        
        @SerializedName("total_submissions")
        private int totalSubmissions;
    }
}

package io.droptracker.models.api;

import com.google.gson.annotations.SerializedName;

import lombok.Getter;
import lombok.Setter;

@Getter
public class GroupConfig {
    /* Represents each of a players' group(s) configurations, defining what minimum values
     * and other notification-related settings they have configured for use with ValidSubmissions.
     */
    @SerializedName("group_id")
    private String groupId;
    @SerializedName("group_name")
    private String groupName;
    @SerializedName("min_value")
    private int minValue;
    @SerializedName("only_screenshots")
    private boolean onlyScreenshots;
    @SerializedName("send_drops")
    private boolean sendDrops;
    @SerializedName("send_pbs")
    private boolean sendPbs;
    @SerializedName("send_clogs")
    private boolean sendClogs;
    @SerializedName("send_cas")
    private boolean sendCAs;
    @SerializedName("minimum_ca_tier")
    private String minimumCATier;
    @SerializedName("minimum_drop_value")
    private Integer minimumDropValue;
    @SerializedName("send_stacked_items")
    private boolean sendStackedItems;
    @SerializedName("send_pets")
    private boolean sendPets;
    @SerializedName("send_quests")
    private boolean sendQuests;
    @SerializedName("send_xp")
    private boolean sendXP;
    @SerializedName("minimum_level")
    private int minimumLevel;
    // add for later -- these handlers don't exist "properly" yet
    @SerializedName("send_kills")
    private boolean sendKills;
    @SerializedName("send_deaths")
    private boolean sendDeaths;

    /* Variables that we'll modify after init */
    @Setter
    private int lastUpdateUnix;
}

package io.droptracker.models.submissions;

import java.time.Duration;
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.util.List;
import java.util.Map;

import lombok.Getter;
import lombok.Setter;

import com.google.gson.annotations.SerializedName;
import lombok.ToString;

/// Nested classes for complex JSON structures
@ToString
public class RecentSubmission {
    @SerializedName("player_name")
    @Getter @Setter
    private String playerName;
    
    @SerializedName("submission_type") // pb, clog, drop  
    @Getter @Setter  
    private String submissionType;  
    
    @SerializedName("source_name") 
    @Getter @Setter
    private String sourceName;
    
    @SerializedName("date_received")
    @Getter @Setter
    private String dateReceived;
    
    @SerializedName("display_name") 
    @Getter @Setter
    private String displayName;

    @SerializedName("value") // if not a pb
    @Getter @Setter
    private String value;

    @SerializedName("data")
    @Getter @Setter
    private List<Map<String, Object>> data;

    @SerializedName("image_url")
    @Getter @Setter
    private String imageUrl;

    @SerializedName("submission_image_url")
    @Getter @Setter
    private String submissionImageUrl;

    // Getters and setters
    public String timeSinceReceived() {
        if (dateReceived == null) {
            return "Unknown";
        }
        try {
            DateTimeFormatter formatter = DateTimeFormatter.ISO_DATE_TIME;
            LocalDateTime receivedDate = LocalDateTime.parse(dateReceived, formatter);
            LocalDateTime now = LocalDateTime.now();
            
            Duration duration = Duration.between(receivedDate, now);
            
            if (duration.toDays() > 0) {
                return duration.toDays() + " days ago";
            } else if (duration.toHours() > 0) {
                return duration.toHours() + " hours ago"; 
            } else if (duration.toMinutes() > 0) {
                return duration.toMinutes() + " minutes ago";
            } else {
                return "Just now";
            }
        } catch (Exception e) {
            return "Unknown";
        }
    }

    // Generic method to extract data by type and key
    private Object getDataValueByTypeAndKey(String dataType, String key) {
        if (data == null || data.isEmpty()) {
            return null;
        }
        
        for (Map<String, Object> dataEntry : data) {
            if (dataEntry != null && dataEntry.containsKey("type")) {
                String entryType = dataEntry.get("type").toString();
                if (entryType.equalsIgnoreCase(dataType) && dataEntry.containsKey(key)) {
                    return dataEntry.get(key);
                }
            }
        }
        return null;
    }

    // Generic method to get all data entries of a specific type
    

    // Personal Best related methods
    public String getPbTime() {
        if (!submissionType.equalsIgnoreCase("pb")) {
            return null;
        }
        
        Object timeValue = getDataValueByTypeAndKey("best_time", "time");
        return timeValue != null ? timeValue.toString() : null;
    }

    
    // Drop related methods
    public String getDropItemName() {
        if (!submissionType.equalsIgnoreCase("drop")) {
            return null;
        }
        
        Object itemName = getDataValueByTypeAndKey("item", "name");
        return itemName != null ? itemName.toString() : null;
    }

    public Integer getDropItemId() {
        if (!submissionType.equalsIgnoreCase("drop")) {
            return null;
        }
        
        Object itemId = getDataValueByTypeAndKey("item", "id");
        if (itemId != null) {
            try {
                // Handle both Integer and Double/Float types from JSON
                if (itemId instanceof Number) {
                    return ((Number) itemId).intValue();
                }
                return Integer.valueOf(itemId.toString().replaceAll("\\.0*$", ""));
            } catch (NumberFormatException e) {
                return null;
            }
        }
        return null;
    }

    public Integer getDropQuantity() {
        if (!submissionType.equalsIgnoreCase("drop")) {
            return null;
        }
        
        Object quantity = getDataValueByTypeAndKey("item", "quantity");
        if (quantity != null) {
            try {
                // Handle both Integer and Double/Float types from JSON
                if (quantity instanceof Number) {
                    return ((Number) quantity).intValue();
                }
                return Integer.valueOf(quantity.toString().replaceAll("\\.0*$", ""));
            } catch (NumberFormatException e) {
                return 1; // Default to 1 if parsing fails
            }
        }
        // Default to 1 if quantity field is missing (as it appears to be in your API)
        return 1;
    }

    // Collection Log related methods
    public String getClogItemName() {
        if (!submissionType.equalsIgnoreCase("clog")) {
            return null;
        }
        
        Object itemName = getDataValueByTypeAndKey("clog_item", "name");
        return itemName != null ? itemName.toString() : null;
    }

    public Integer getClogItemId() {
        if (!submissionType.equalsIgnoreCase("clog")) {
            return null;
        }
        
        Object itemId = getDataValueByTypeAndKey("clog_item", "id");
        if (itemId != null) {
            try {
                // Handle both Integer and Double/Float types from JSON
                if (itemId instanceof Number) {
                    return ((Number) itemId).intValue();
                }
                return Integer.valueOf(itemId.toString().replaceAll("\\.0*$", ""));
            } catch (NumberFormatException e) {
                return null;
            }
        }
        return null;
    }

    public boolean isDrop() {
        return submissionType != null && submissionType.equalsIgnoreCase("drop");
    }
}

package io.droptracker.models.submissions;

import java.awt.Font;
import java.time.Duration;
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.util.Arrays;

import javax.swing.BoxLayout;
import javax.swing.JPanel;
import javax.swing.JTextArea;

import io.droptracker.models.CustomWebhookBody;
import lombok.Data;

/**
 * Can represent any type of outgoing submission, such as a drop, pb, clog, ca, etc.
 * ValidSubmissions are created when a user receives something that their registered group(s)
 * have configured to have notifications sent for.
 * <p>
 * We generate an ID when sending data, and store this ID in the ValidSubmission object,
 * so that we can update/track whether the submission arrived at the API and had its notifications
 * processed properly.
 */
@Data
public class ValidSubmission {
    // generated ID
    private String uuid;
    // type of submission
    private SubmissionType type;
    // group ID(s) that the submission should have been sent to
    private String[] groupIds;
    // account hash
    private String accountHash;
    // item ID
    private String itemId;
    // item name
    private String itemName;
    // npc name
    private String npcName;
    // description
    private String description;
    // time since submission was created on the client-side
    private String timeReceived;

    // message or response from the API on initial submission
    private String initialResponse;
    // time that the API responded with a successful processing of the submission
    private String timeProcessedAt;
    // current status of the submission
    private String status;
    
    // number of retry attempts made
    private int retryAttempts;
    
    // last failure reason
    private String lastFailureReason;

    // array of responses from the API on retry attempts
    private String[] retryResponses;
    
    // Store the entire webhook data for retry functionality
    private CustomWebhookBody originalWebhook;

    // Default constructor
    public ValidSubmission() {
        this.timeReceived = LocalDateTime.now().format(DateTimeFormatter.ISO_DATE_TIME);
        this.status = "pending";
        this.groupIds = new String[0];
        this.retryResponses = new String[0];
        this.retryAttempts = 0;
    }

    // Constructor that takes a webhook and extracts relevant data
    public ValidSubmission(CustomWebhookBody webhook, String groupId, SubmissionType type) {
        this();
        this.originalWebhook = webhook;
        this.type = type;
        this.groupIds = new String[] {groupId};
        
        // Extract data from webhook
        extractDataFromWebhook(webhook);
    }

    private void extractDataFromWebhook(CustomWebhookBody webhook) {
        if (webhook != null && webhook.getEmbeds() != null && !webhook.getEmbeds().isEmpty()) {
            CustomWebhookBody.Embed embed = webhook.getEmbeds().get(0);
            
            // Extract title for description
            if (embed.getTitle() != null) {
                this.description = embed.getTitle();
            }
            
            // Extract data from fields - process GUID field with highest priority
            String tempGuid = null;
            
            if (embed.getFields() != null) {
                for (CustomWebhookBody.Field field : embed.getFields()) {
                    String fieldName = field.getName();
                    String fieldValue = field.getValue();
                    
                    if (fieldName != null && fieldValue != null) {
                        switch (fieldName.toLowerCase()) {
                            case "guid":
                                tempGuid = fieldValue;
                                break;
                            case "item":
                            case "item_name":
                                this.itemName = fieldValue;
                                break;
                            case "item_id":
                                this.itemId = fieldValue;
                                break;
                            case "npc":
                            case "npc_name":
                            case "boss":
                                this.npcName = fieldValue;
                                break;
                            case "account_hash":
                            case "player":
                                this.accountHash = fieldValue;
                                break;
                        }
                    }
                }
                if (tempGuid != null) {
                    this.uuid = tempGuid;
                } 
            }
        }
    }

    public void addGroupId(String groupId) {
        String[] newGroupIds = Arrays.copyOf(groupIds, groupIds.length + 1);
        newGroupIds[groupIds.length] = groupId;
        this.groupIds = newGroupIds;
    }
    
    /**
     * Mark the submission as failed with a reason
     */
    public void markAsFailed(String reason) {
        this.status = "failed";
        this.lastFailureReason = reason;
    }
    
    /**
     * Mark the submission as queued for retry
     */
    public void markAsQueued() {
        this.status = "queued";
    }
    
    /**
     * Mark the submission as currently retrying
     */
    public void markAsRetrying() {
        this.status = "retrying";
        this.retryAttempts++;
    }
    
    /**
     * Mark the submission as successfully sent
     */
    public void markAsSuccess() {
        this.status = "sent";
        this.timeProcessedAt = LocalDateTime.now().format(DateTimeFormatter.ISO_DATE_TIME);
    }
    
    /**
     * Mark the submission as processed by the API
     */
    public void markAsProcessed() {
        this.status = "processed";
        this.timeProcessedAt = LocalDateTime.now().format(DateTimeFormatter.ISO_DATE_TIME);
        // Clear webhook data to free memory since we no longer need to retry
        this.originalWebhook = null;
    }
    
    /**
     * Check if this submission can be retried
     */
    public boolean canRetry() {
        // only allow up to 5 retries from the API panel--after this, we assume it's "broken" somehow
        return retryAttempts < 5 && !"sent".equals(status) && !"processed".equals(status);
    }
    
    /**
     * Get a human-readable status description
     */
    public String getStatusDescription() {
        switch (status) {
            case "pending":
                return "Sending...";
            case "sent":
                return "Sent successfully";
            case "processed":
                return "Processed by API";
            case "failed":
                return "Failed" + (lastFailureReason != null ? ": " + lastFailureReason : "");
            case "queued":
                return "Queued for retry";
            case "retrying":
                return "Retrying... (attempt " + (retryAttempts + 1) + ")";
            default:
                return status;
        }
    }

    public JPanel toSubmissionPanel() {
        JPanel entryPanel = new JPanel();
        entryPanel.setLayout(new BoxLayout(entryPanel, BoxLayout.Y_AXIS));

        // Create a text area to display the submission information
        JTextArea textArea = new JTextArea();
        String text;
        switch (this.type) {
            case DROP:
                text = "Drop: " + this.itemName + " - " + this.timeSinceReceived();
                break;
            case KILL_TIME:
                text = "Personal Best: " + this.itemName + " - " + this.timeSinceReceived();
                break;
            case COLLECTION_LOG:
                text = "Collection Log: " + this.itemName + " - " + this.timeSinceReceived();
                break;
            case COMBAT_ACHIEVEMENT:
                text = "Combat Achievement: " + this.itemName + " - " + this.timeSinceReceived();
                break;
            case LEVEL_UP:
                text = "Level Up: " + this.itemName + " - " + this.timeSinceReceived();
                break;
            case QUEST_COMPLETION:
                text = "Quest Completion: " + this.itemName + " - " + this.timeSinceReceived();
                break;
            case EXPERIENCE:
                text = "Experience: " + this.itemName + " - " + this.timeSinceReceived();
                break;
            case EXPERIENCE_MILESTONE:
                text = "Experience Milestone: " + this.itemName + " - " + this.timeSinceReceived();
                break;  
            case PET:
                text = "Pet: " + this.itemName + " - " + this.timeSinceReceived();
                break;  
            default:
                text = "Unknown submission type: " + this.type;
                break;
        }
        textArea.setText(text);
        textArea.setEditable(false);
        textArea.setLineWrap(true);
        textArea.setWrapStyleWord(true);
        textArea.setFont(new Font("Arial", Font.PLAIN, 12));    
        entryPanel.add(textArea);
        return entryPanel;
    }

    private String timeSinceReceived() {
            if (timeReceived == null) {
                return "Unknown";
            }
            try {
                DateTimeFormatter formatter = DateTimeFormatter.ISO_DATE_TIME;
                LocalDateTime receivedDate = LocalDateTime.parse(timeReceived, formatter);
                LocalDateTime now = LocalDateTime.now();
                
                Duration duration = Duration.between(receivedDate, now);
                
                if (duration.toDays() > 0) {
                    return duration.toDays() + " days ago";
                } else if (duration.toHours() > 0) {
                    return duration.toHours() + " hours ago"; 
                } else if (duration.toMinutes() > 0) {
                    return duration.toMinutes() + " minutes ago";
                } else {
                    return "Just now";
                }
            } catch (Exception e) {
                return "Unknown";
            }
        }
}

package io.droptracker.models.submissions;

public enum SubmissionType {
    DROP,
    KILL_TIME,
    COLLECTION_LOG,
    COMBAT_ACHIEVEMENT,
    LEVEL_UP,
    QUEST_COMPLETION,
    EXPERIENCE,
    EXPERIENCE_MILESTONE,
    ADVENTURE_LOG,
    PET
}

package io.droptracker.models.submissions;
/*
*  Author: https://github.com/pajlads/DinkPlugin
* */
import lombok.Value;
import net.runelite.client.game.ItemStack;
import net.runelite.http.api.loottracker.LootRecordType;

import java.time.Instant;
import java.util.Collection;

@Value
public class Drop {
    String source;
    LootRecordType category;
    Collection<ItemStack> items;
    Instant time = Instant.now();

    public static String getAction(LootRecordType type) {
        switch (type) {
            case NPC:
                return "Kill";
            case PLAYER:
                return "Player Kill";
            case PICKPOCKET:
                return "Pickpocket";
            default:
                return "Completion";
        }
    }
}

package io.droptracker.models.submissions;

import lombok.Getter;

import java.util.Arrays;
import java.util.Collections;
import java.util.Map;
import java.util.function.Function;
import java.util.stream.Collectors;

@Getter
public enum CombatAchievement {
    EASY,
    MEDIUM,
    HARD,
    ELITE,
    MASTER,
    GRANDMASTER;

    /**
     * The points-based achievement system assigns one point to {@link #EASY} tasks,
     * and increments by one for each difficulty level.
     *
     * @see <a href="https://gachi.gay/01CAv">Point values documented in blog post</a>
     */
    private final int points = this.ordinal() + 1;
    private final String displayName = this.name().charAt(0) + this.name().substring(1).toLowerCase();

    @Override
    public String toString() {
        return this.displayName;
    }

    public static final Map<String, CombatAchievement> TIER_BY_LOWER_NAME = Collections.unmodifiableMap(
            Arrays.stream(values()).collect(Collectors.toMap(t -> t.name().toLowerCase(), Function.identity()))
    );
}


package io.droptracker.models;
/*  Original Author @pajlads - DinkPlugin

    https://github.com/pajlads/DinkPlugin

 */

import com.google.gson.annotations.JsonAdapter;
import io.droptracker.util.DurationAdapter;
import lombok.EqualsAndHashCode;
import lombok.Value;
import lombok.experimental.Accessors;

import java.time.Duration;
import java.util.Collections;
import java.util.List;

@Value
@EqualsAndHashCode(callSuper = false)
public class BossNotification {
    public List<CustomWebhookBody.Embed> getFields() {
        return Collections.emptyList();
    }
    String boss;
    Integer count;
    String gameMessage;
    @JsonAdapter(DurationAdapter.class)
    Duration time;
    @JsonAdapter(DurationAdapter.class)
    Duration bestTime;
    @Accessors(fluent = true)
    Boolean isPersonalBest;

}

package io.droptracker.models;

/* Author: Dink Plugin */

import lombok.AccessLevel;
import lombok.Data;
import lombok.Setter;

/**
 * Contains kill count observed by base runelite loot tracker plugin, stored in profile configuration.
 *
 * @see <a href="https://github.com/runelite/runelite/blob/master/runelite-client/src/main/java/net/runelite/client/plugins/loottracker/ConfigLoot.java#L41">RuneLite class</a>
 */
@Data
@Setter(AccessLevel.PRIVATE)
public class SerializedDrop {
    private int kills;
}

package io.droptracker.ui.pages;

import io.droptracker.DropTrackerConfig;
import io.droptracker.DropTrackerPlugin;
import io.droptracker.api.DropTrackerApi;
import io.droptracker.models.api.PlayerSearchResult;
import io.droptracker.models.api.TopPlayersResult;
import io.droptracker.models.submissions.RecentSubmission;
import io.droptracker.ui.components.LeaderboardComponents;
import io.droptracker.ui.components.PanelElements;
import net.runelite.api.Client;
import net.runelite.client.game.ItemManager;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.FontManager;
import net.runelite.client.ui.PluginPanel;
import net.runelite.client.util.LinkBrowser;

import javax.swing.*;
import javax.swing.border.EmptyBorder;
import java.awt.*;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.CompletableFuture;

public class PlayerStatsPanel {
    private final Client client;
    private final DropTrackerConfig config;
    private final DropTrackerApi api;
    private final DropTrackerPlugin plugin;
    private final ItemManager itemManager;

    // UI components that we need to update
    private JPanel contentPanel;
    private JTextField searchField;
    private JPanel leaderboardPlaceholder;

    public PlayerStatsPanel(Client client, DropTrackerPlugin plugin, DropTrackerConfig config, DropTrackerApi api, ItemManager itemManager) {
        this.client = client;
        this.plugin = plugin;
        this.config = config;
        this.api = api;
        this.itemManager = itemManager;
    }

    public JPanel create() {
        var mainPanel = new JPanel();
        mainPanel.setLayout(new BoxLayout(mainPanel, BoxLayout.Y_AXIS));
        mainPanel.setBackground(ColorScheme.DARK_GRAY_COLOR);

        // Header section with title and search using LeaderboardComponents
        LeaderboardComponents.HeaderResult headerResult = LeaderboardComponents.createHeaderPanel(
                "DropTracker - Players",
                "Search for a player",
                () -> performPlayerSearch("")
        );
        searchField = headerResult.searchField;

        // Content panel that will change based on state
        contentPanel = new JPanel();
        contentPanel.setLayout(new BoxLayout(contentPanel, BoxLayout.Y_AXIS));
        contentPanel.setBackground(ColorScheme.DARK_GRAY_COLOR);
        contentPanel.setAlignmentX(Component.LEFT_ALIGNMENT);

        // Show default state
        showDefaultState();

        // Add components to main panel - match GroupPanel structure
        mainPanel.add(headerResult.panel);
        mainPanel.add(Box.createRigidArea(new Dimension(0, 10)));
        mainPanel.add(contentPanel);
        mainPanel.add(Box.createVerticalGlue());

        return mainPanel;
    }

    private void showDefaultState() {
        contentPanel.removeAll();

        // Create center panel for instructions and leaderboard
        JPanel defaultPanel = new JPanel();
        defaultPanel.setLayout(new BoxLayout(defaultPanel, BoxLayout.Y_AXIS));
        defaultPanel.setBackground(ColorScheme.DARK_GRAY_COLOR);
        defaultPanel.setAlignmentX(Component.CENTER_ALIGNMENT);

        // Add some spacing
        defaultPanel.add(Box.createRigidArea(new Dimension(0, 5)));

        // Instructions text
        JLabel instructionLabel = new JLabel("Search for a player by name above");
        instructionLabel.setFont(FontManager.getRunescapeFont());
        instructionLabel.setForeground(Color.LIGHT_GRAY);
        instructionLabel.setAlignmentX(Component.CENTER_ALIGNMENT);
        instructionLabel.setHorizontalAlignment(JLabel.CENTER);

        defaultPanel.add(instructionLabel);
        defaultPanel.add(Box.createRigidArea(new Dimension(0, 5)));

        // Get current player and add button if logged in
        String playerName = (config.lastAccountName() != null) ? config.lastAccountName() : null;

        if (playerName != null && !"Not logged in".equals(playerName)) {
            // Button to view current player stats
            JPanel buttonPanel = new JPanel(new FlowLayout(FlowLayout.CENTER));
            buttonPanel.setBackground(ColorScheme.DARK_GRAY_COLOR);
            buttonPanel.setAlignmentX(Component.CENTER_ALIGNMENT);
            buttonPanel.setMaximumSize(new Dimension(Integer.MAX_VALUE, 30));
            buttonPanel.setPreferredSize(new Dimension(PluginPanel.PANEL_WIDTH, 30));

            JButton viewStatsButton = new JButton(" View My Stats (" + playerName + ")");
            viewStatsButton.setFont(FontManager.getRunescapeSmallFont());
            viewStatsButton.setPreferredSize(new Dimension(200, 30));
            viewStatsButton.setToolTipText("View your DropTracker statistics");
            viewStatsButton.addActionListener(e -> performPlayerSearch(playerName));

            buttonPanel.add(viewStatsButton);
            defaultPanel.add(buttonPanel);
            defaultPanel.add(Box.createRigidArea(new Dimension(0, 10)));
        }

        if (config.useApi()) {
            // Create placeholder for leaderboard (same pattern as GroupPanel)
            leaderboardPlaceholder = LeaderboardComponents.createLoadingPlaceholder("Loading top players...");
            defaultPanel.add(leaderboardPlaceholder);

            // Start loading data
            obtainPlayerLeaderboardData();
        }

        defaultPanel.add(Box.createVerticalGlue());

        contentPanel.add(defaultPanel);
        contentPanel.revalidate();
        contentPanel.repaint();
    }

    // New method to obtain player leaderboard data (similar to GroupPanel)
    private void obtainPlayerLeaderboardData() {
        LeaderboardComponents.loadLeaderboardAsync(
                leaderboardPlaceholder,
                () -> {
                    try {
                        return api.getTopPlayers();
                    } catch (Exception e) {
                        // Fallback to demo data for testing
                        return createDemoTopPlayersResult();
                    }
                },
                this::showPlayerLeaderboard
        );
    }

    // New method to show player leaderboard using LeaderboardComponents
    private JPanel showPlayerLeaderboard(TopPlayersResult leaderboardData) {
        return LeaderboardComponents.createLeaderboardTable(
                "Top Players",
                "Player",
                leaderboardData != null ? leaderboardData.getPlayers() : null,
                new LeaderboardComponents.LeaderboardItemRenderer<TopPlayersResult.TopPlayer>() {
                    @Override
                    public String getName(TopPlayersResult.TopPlayer player) {
                        return player.getPlayerName() != null ? player.getPlayerName() : "Unknown Player";
                    }

                    @Override
                    public String getLootValue(TopPlayersResult.TopPlayer player) {
                        String loot = player.getTotalLoot();
                        return (loot != null && !loot.trim().isEmpty()) ? loot : "0 GP";
                    }

                    @Override
                    public Integer getRank(TopPlayersResult.TopPlayer player) {
                        return player.getRank();
                    }

                    @Override
                    public void onItemClick(TopPlayersResult.TopPlayer player) {
                        // Search for this player when clicked
                        performPlayerSearch(player.getPlayerName());
                    }
                }
        );
    }

    // Create demo data for testing (same as before)
    private TopPlayersResult createDemoTopPlayersResult() {
        TopPlayersResult demo = new TopPlayersResult();
        List<TopPlayersResult.TopPlayer> players = new ArrayList<>();

        players.add(new TopPlayersResult.TopPlayer("Woox", 1, "2.1B"));
        players.add(new TopPlayersResult.TopPlayer("Lynx Titan", 2, "1.8B"));
        players.add(new TopPlayersResult.TopPlayer("Zezima", 3, "1.2B"));
        players.add(new TopPlayersResult.TopPlayer("B0aty", 4, "890M"));
        players.add(new TopPlayersResult.TopPlayer("Framed", 5, "650M"));

        demo.setPlayers(players);
        return demo;
    }

    public void performPlayerSearch(String searchQuery) {
        String toSearch;
        if (searchQuery.isEmpty()) {
            if (searchField != null && searchField.getText() != null && !searchField.getText().isEmpty()) {
                toSearch = searchField.getText().trim();
            } else {
                if (plugin.getLocalPlayerName() != null && !plugin.getLocalPlayerName().isEmpty()) {
                    toSearch = plugin.getLocalPlayerName();
                } else {
                    return;
                }
            }
        } else {
            toSearch = searchQuery;
        }


        // Show loading message
        contentPanel.removeAll();
        JLabel loadingLabel = new JLabel("Searching for player...");
        loadingLabel.setFont(FontManager.getRunescapeFont());
        loadingLabel.setForeground(Color.LIGHT_GRAY);
        loadingLabel.setHorizontalAlignment(JLabel.CENTER);
        contentPanel.add(loadingLabel);
        contentPanel.revalidate();
        contentPanel.repaint();

        // Perform search in background
        CompletableFuture.supplyAsync(() -> {
            try {
                PlayerSearchResult playerResult = api.lookupPlayer(toSearch);
                return playerResult;
            } catch (Exception e) {
                return null;
            }
        }).thenAccept(playerResult -> {
            SwingUtilities.invokeLater(() -> {
                if (playerResult != null) {
                    showPlayerDetails(playerResult);
                } else {
                    showSearchError("Player '" + toSearch + "' not found. API search failed.");
                }
            });
        });
    }

    private void showSearchError(String message) {
        contentPanel.removeAll();

        JPanel errorPanel = LeaderboardComponents.createErrorPanel(message, () -> {
            searchField.setText("");
            showDefaultState();
        });

        contentPanel.add(errorPanel);
        contentPanel.revalidate();
        contentPanel.repaint();
    }

    private void showPlayerDetails(PlayerSearchResult playerResult) {
        contentPanel.removeAll();

        // Match GroupPanel structure exactly
        JPanel playerInfoPanel = new JPanel();
        playerInfoPanel.setLayout(new BoxLayout(playerInfoPanel, BoxLayout.Y_AXIS));
        playerInfoPanel.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        playerInfoPanel.setBorder(new EmptyBorder(10, 10, 10, 10));

        // Player header panel - like groupHeaderPanel
        JPanel playerHeaderPanel = new JPanel(new BorderLayout(10, 0));
        playerHeaderPanel.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        playerHeaderPanel.setMaximumSize(new Dimension(PluginPanel.PANEL_WIDTH - 40, 60));
        playerHeaderPanel.setPreferredSize(new Dimension(PluginPanel.PANEL_WIDTH - 40, 60));
        playerHeaderPanel.setAlignmentX(Component.LEFT_ALIGNMENT);

        // Player name and description
        JPanel playerNamePanel = new JPanel();
        playerNamePanel.setLayout(new BoxLayout(playerNamePanel, BoxLayout.Y_AXIS));
        playerNamePanel.setBackground(ColorScheme.DARKER_GRAY_COLOR);

        JLabel playerNameLabel = new JLabel(playerResult.getPlayerName());
        playerNameLabel.setFont(FontManager.getRunescapeBoldFont());
        playerNameLabel.setForeground(Color.WHITE);
        playerNameLabel.setAlignmentX(Component.LEFT_ALIGNMENT);

        String statusText = playerResult.isRegistered() ? "Registered Player" : "Unregistered Player";
        JLabel playerDescLabel = new JLabel(statusText);
        playerDescLabel.setFont(FontManager.getRunescapeSmallFont());
        playerDescLabel.setForeground(playerResult.isRegistered() ? Color.GREEN : Color.ORANGE);
        playerDescLabel.setAlignmentX(Component.LEFT_ALIGNMENT);

        playerNamePanel.add(playerNameLabel);
        playerNamePanel.add(Box.createRigidArea(new Dimension(0, 5)));
        playerNamePanel.add(playerDescLabel);

        // Add groups information if available
        if (playerResult.getGroups() != null && !playerResult.getGroups().isEmpty()) {
            JPanel groupsPanel = createGroupsPanel(playerResult.getGroups());
            playerNamePanel.add(groupsPanel);
        }

        // Clear button for closing the search result
        JButton clearButton = LeaderboardComponents.createClearButton(() -> {
            searchField.setText("");
            showDefaultState();
        });

        playerHeaderPanel.add(playerNamePanel, BorderLayout.CENTER);
        playerHeaderPanel.add(clearButton, BorderLayout.EAST);

        // Stats panel - exactly like GroupPanel statsPanel
        JPanel statsPanel = new JPanel(new GridLayout(2, 2, 5, 5));
        statsPanel.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        statsPanel.setBorder(new EmptyBorder(10, 0, 10, 0));
        statsPanel.setMaximumSize(new Dimension(PluginPanel.PANEL_WIDTH, 100));
        statsPanel.setPreferredSize(new Dimension(PluginPanel.PANEL_WIDTH - 40, 100));
        statsPanel.setAlignmentX(Component.LEFT_ALIGNMENT);

        // Format numbers nicely
        String globalRankFormatted = "#" + playerResult.getGlobalRank();

        // Format top NPC information

        JPanel totalLootBox = PanelElements.createStatBox("Total Loot", playerResult.getTotalLoot() + " GP");
        JPanel globalRankBox = PanelElements.createStatBox("Global Rank", globalRankFormatted);
        JPanel playerPointsBox = PanelElements.createStatBox("Lifetime Points", playerResult.getPoints() + " pts");

        statsPanel.add(totalLootBox);
        statsPanel.add(globalRankBox);
        statsPanel.add(playerPointsBox);

        playerPointsBox.addMouseListener(new java.awt.event.MouseAdapter() {
            @Override
            public void mouseClicked(java.awt.event.MouseEvent e) {
                LinkBrowser.browse("https://www.droptracker.io/wiki/points");
            }

            @Override
            public void mouseEntered(java.awt.event.MouseEvent e) {
                playerPointsBox.setBackground(ColorScheme.DARKER_GRAY_HOVER_COLOR);
                playerPointsBox.setCursor(Cursor.getPredefinedCursor(Cursor.HAND_CURSOR));
            }

            @Override
            public void mouseExited(java.awt.event.MouseEvent e) {
                playerPointsBox.setBackground(ColorScheme.MEDIUM_GRAY_COLOR);
                playerPointsBox.setCursor(Cursor.getDefaultCursor());
            }
        });
        playerPointsBox.setToolTipText("View more info about points (click to open wiki)");

        // Action buttons - exactly like GroupPanel actionPanel
        JPanel actionPanel = new JPanel();
        actionPanel.setLayout(new FlowLayout(FlowLayout.CENTER, 10, 0));
        actionPanel.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        actionPanel.setMaximumSize(new Dimension(PluginPanel.PANEL_WIDTH - 40, 40));
        actionPanel.setPreferredSize(new Dimension(PluginPanel.PANEL_WIDTH - 40, 40));
        actionPanel.setAlignmentX(Component.LEFT_ALIGNMENT);

        JButton refreshButton = new JButton("Refresh Stats");
        refreshButton.setMargin(new Insets(0, 5, 0, 5));
        refreshButton.addActionListener(e -> {
            performPlayerSearch(playerResult.getPlayerName());
        });

        JButton viewProfileButton = new JButton(" View Profile");
        viewProfileButton.setFont(FontManager.getRunescapeSmallFont());
        viewProfileButton.setMargin(new Insets(0, 5, 0, 5));
        viewProfileButton.addActionListener(e -> {
            if (playerResult.getDropTrackerPlayerId() != null) {
                LinkBrowser.browse("https://www.droptracker.io/players/" + playerResult.getDropTrackerPlayerId() + "/view");
            } else {
                LinkBrowser.browse("https://www.droptracker.io/players/" + playerResult.getPlayerName() + "/view");
            }
        });

        actionPanel.add(refreshButton);
        actionPanel.add(viewProfileButton);

        // Add components exactly like GroupPanel
        playerInfoPanel.add(playerHeaderPanel);
        playerInfoPanel.add(Box.createRigidArea(new Dimension(0, 10)));
        playerInfoPanel.add(statsPanel);
        playerInfoPanel.add(Box.createRigidArea(new Dimension(0, 10)));

        // Add recent submissions panel if available
        if (playerResult.getRecentSubmissions() != null && !playerResult.getRecentSubmissions().isEmpty()) {
            List<RecentSubmission> recentSubmissions = playerResult.getRecentSubmissions();
            playerInfoPanel.add(PanelElements.createRecentSubmissionPanel(recentSubmissions, itemManager, client, false));
            playerInfoPanel.add(Box.createRigidArea(new Dimension(0, 10)));
        } else {
            // Create a placeholder panel that matches the exact dimensions of createRecentSubmissionPanel
            JPanel noSubmissionsContainer = new JPanel();
            noSubmissionsContainer.setLayout(new BoxLayout(noSubmissionsContainer, BoxLayout.Y_AXIS));
            noSubmissionsContainer.setBackground(ColorScheme.DARKER_GRAY_COLOR);
            noSubmissionsContainer.setBorder(new EmptyBorder(10, 0, 10, 0));
            noSubmissionsContainer.setPreferredSize(new Dimension(PluginPanel.PANEL_WIDTH - 40, 120)); // Match original
            noSubmissionsContainer.setMaximumSize(new Dimension(PluginPanel.PANEL_WIDTH - 40, 120));
            noSubmissionsContainer.setAlignmentX(Component.LEFT_ALIGNMENT);

            // Title panel to match original structure
            JPanel titlePanel = new JPanel(new FlowLayout(FlowLayout.CENTER, 0, 0));
            titlePanel.setBackground(ColorScheme.DARKER_GRAY_COLOR);
            titlePanel.setMaximumSize(new Dimension(PluginPanel.PANEL_WIDTH - 40, 20));
            titlePanel.setPreferredSize(new Dimension(PluginPanel.PANEL_WIDTH - 40, 20));

            JLabel title = new JLabel("Recent Submissions");
            title.setFont(FontManager.getRunescapeSmallFont());
            title.setForeground(Color.WHITE);
            titlePanel.add(title);

            // Content panel to match original structure
            JPanel contentWrapper = new JPanel(new FlowLayout(FlowLayout.CENTER, 0, 0));
            contentWrapper.setBackground(ColorScheme.DARKER_GRAY_COLOR);
            contentWrapper.setPreferredSize(new Dimension(PluginPanel.PANEL_WIDTH - 40, 80));
            contentWrapper.setMaximumSize(new Dimension(PluginPanel.PANEL_WIDTH - 40, 80));

            JLabel noSubmissionsLabel = new JLabel("No recent submissions available");
            noSubmissionsLabel.setFont(FontManager.getRunescapeSmallFont());
            noSubmissionsLabel.setForeground(Color.LIGHT_GRAY);
            noSubmissionsLabel.setHorizontalAlignment(JLabel.CENTER);
            contentWrapper.add(noSubmissionsLabel);

            // Assemble the container exactly like the original
            noSubmissionsContainer.add(titlePanel);
            noSubmissionsContainer.add(Box.createRigidArea(new Dimension(0, 5))); // Match original spacing
            noSubmissionsContainer.add(contentWrapper);

            playerInfoPanel.add(noSubmissionsContainer);
            playerInfoPanel.add(Box.createRigidArea(new Dimension(0, 10)));
        }

        playerInfoPanel.add(actionPanel);

        contentPanel.add(playerInfoPanel);
        contentPanel.revalidate();
        contentPanel.repaint();
    }

    private JPanel createGroupsPanel(List<PlayerSearchResult.PlayerGroup> groups) {
        if (groups == null || groups.isEmpty()) {
            return new JPanel(); // Return empty panel if no groups
        }

        JPanel groupsContainer = new JPanel();
        groupsContainer.setLayout(new BoxLayout(groupsContainer, BoxLayout.Y_AXIS));
        groupsContainer.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        groupsContainer.setAlignmentX(Component.LEFT_ALIGNMENT);

        // Groups header
        JLabel groupsHeaderLabel = new JLabel("Groups:");
        groupsHeaderLabel.setFont(FontManager.getRunescapeSmallFont());
        groupsHeaderLabel.setForeground(Color.LIGHT_GRAY);
        groupsHeaderLabel.setAlignmentX(Component.LEFT_ALIGNMENT);
        groupsContainer.add(groupsHeaderLabel);

        // Add each group as a separate label for proper scaling
        for (PlayerSearchResult.PlayerGroup group : groups) {
            StringBuilder groupText = new StringBuilder(" ");
            groupText.append(group.getName());
            if (group.getMembers() != null) {
                groupText.append(" (").append(group.getMembers()).append(" members)");
            }

            JLabel groupLabel = new JLabel(groupText.toString());
            groupLabel.setFont(FontManager.getRunescapeSmallFont());
            groupLabel.setForeground(Color.LIGHT_GRAY);
            groupLabel.setAlignmentX(Component.LEFT_ALIGNMENT);

            groupsContainer.add(groupLabel);
        }

        return groupsContainer;
    }

}

package io.droptracker.ui.pages;

import io.droptracker.DropTrackerConfig;
import io.droptracker.api.DropTrackerApi;
import io.droptracker.ui.DropTrackerPanel;
import io.droptracker.ui.components.PanelElements;
import net.runelite.api.Client;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.FontManager;
import net.runelite.client.ui.PluginPanel;
import net.runelite.client.util.LinkBrowser;

import javax.annotation.Nullable;
import javax.swing.*;
import java.awt.*;

public class HomePanel {
    private final DropTrackerConfig config;
    private final DropTrackerApi api;
    private final Client client;
    private final DropTrackerPanel panel;

    // Store references for dynamic updates
    private JPanel homePanel;
    private @Nullable JPanel playerButtonRow;
    private int playerButtonIndex = -1; // Tracks where to insert the button

    public HomePanel(DropTrackerConfig config, DropTrackerApi api, Client client, DropTrackerPanel panel) {
        this.config = config;
        this.api = api;
        this.client = client;
        this.panel = panel;
    }

    public JPanel create() {
        homePanel = new JPanel();
        homePanel.setLayout(new BoxLayout(homePanel, BoxLayout.Y_AXIS));
        homePanel.setBackground(ColorScheme.DARK_GRAY_COLOR);

        // Set maximum width to prevent expansion
        homePanel.setMaximumSize(new Dimension(PluginPanel.PANEL_WIDTH, Integer.MAX_VALUE));

        final JPanel welcomeMessagePanel = PanelElements.createCollapsiblePanel("Welcome to the DropTracker", PanelElements.getLatestWelcomeContent(api), true);
        // Patch notes panel (collapsible)
        welcomeMessagePanel.setMaximumSize(new Dimension(PluginPanel.PANEL_WIDTH, Integer.MAX_VALUE));
        welcomeMessagePanel.setAlignmentX(Component.LEFT_ALIGNMENT);
        final JPanel patchNotesPanel = PanelElements.createCollapsiblePanel("News / Updates", PanelElements.getLatestUpdateContent(config, api), false);
        patchNotesPanel.setMaximumSize(new Dimension(PluginPanel.PANEL_WIDTH, Integer.MAX_VALUE));
        patchNotesPanel.setAlignmentX(Component.LEFT_ALIGNMENT);

        // Quick access buttons in a grid (without subtexts)
        JPanel quickAccessPanel = new JPanel();
        quickAccessPanel.setLayout(new BoxLayout(quickAccessPanel, BoxLayout.Y_AXIS));
        quickAccessPanel.setBackground(ColorScheme.DARK_GRAY_COLOR);
        quickAccessPanel.setAlignmentX(Component.LEFT_ALIGNMENT);

        // Create two separate panels for each row of buttons
        JPanel topButtonRow = new JPanel(new GridLayout(1, 2, 5, 0));
        topButtonRow.setBackground(ColorScheme.DARK_GRAY_COLOR);

        JPanel bottomButtonRow = new JPanel(new GridLayout(1, 2, 5, 0));
        bottomButtonRow.setBackground(ColorScheme.DARK_GRAY_COLOR);


        // Create the global board button
        // Create button to view lootboard

        // Add buttons to the top row with proper sizing
        JButton guideButton = new JButton("Read the Wiki");
        guideButton.setFocusPainted(false);
        guideButton.setFont(FontManager.getRunescapeSmallFont());
        guideButton.addActionListener(e -> LinkBrowser.browse("https://www.droptracker.io/wiki"));
        // Prevent text truncation
        guideButton.setMargin(new Insets(0, 0, 0, 0));

        JButton discordButton = new JButton("Join Discord");
        discordButton.setFocusPainted(false);
        discordButton.setFont(FontManager.getRunescapeSmallFont());
        discordButton.addActionListener(e -> LinkBrowser.browse("https://www.droptracker.io/discord"));
        // Prevent text truncation
        discordButton.setMargin(new Insets(0, 0, 0, 0));

        topButtonRow.add(guideButton);
        topButtonRow.add(discordButton);

        // Add buttons to the bottom row with proper sizing
        JButton suggestButton = new JButton("Suggest Features");
        suggestButton.setFocusPainted(false);
        suggestButton.setFont(FontManager.getRunescapeSmallFont());
        suggestButton.addActionListener(e -> LinkBrowser.browse("https://www.droptracker.io/forums/suggestions"));
        // Prevent text truncation
        suggestButton.setMargin(new Insets(0, 0, 0, 0));

        JButton bugReportButton = new JButton("Report a Bug");
        bugReportButton.setFocusPainted(false);
        bugReportButton.setFont(FontManager.getRunescapeSmallFont());
        bugReportButton.addActionListener(e -> LinkBrowser.browse("https://www.droptracker.io/forums/bug-reports"));
        // Prevent text truncation
        bugReportButton.setMargin(new Insets(0, 0, 0, 0));

        bottomButtonRow.add(suggestButton);
        bottomButtonRow.add(bugReportButton);

        // Add rows to the main panel with a rigid area between them for spacing
        quickAccessPanel.add(topButtonRow);
        quickAccessPanel.add(Box.createRigidArea(new Dimension(0, 8))); // 8px gap between rows
        quickAccessPanel.add(bottomButtonRow);

        // Set maximum size to prevent expansion
        quickAccessPanel.setMaximumSize(new Dimension(PluginPanel.PANEL_WIDTH, 68)); // Adjusted for the gap

        // Create a rigid container for feature panels to prevent expansion
        JPanel featurePanelsContainer = new JPanel();
        featurePanelsContainer.setLayout(new BoxLayout(featurePanelsContainer, BoxLayout.Y_AXIS));
        featurePanelsContainer.setBackground(ColorScheme.DARK_GRAY_COLOR);
        featurePanelsContainer.setAlignmentX(Component.LEFT_ALIGNMENT);

        // Feature panels with fixed heights
        JPanel trackDropsPanel = PanelElements.createFeaturePanel("Track Your Drops",
                "Automatically record and analyze all your valuable drops from almost anywhere in the game.");
        trackDropsPanel.setAlignmentX(Component.LEFT_ALIGNMENT);

        JPanel discordPanel = PanelElements.createFeaturePanel("Discord Integration",
                "Share your achievements with friends via customizable Discord webhooks.");
        discordPanel.setAlignmentX(Component.LEFT_ALIGNMENT);

        JPanel pbPanel = PanelElements.createFeaturePanel("Personal Bests",
                "Track and compare your boss kill times and personal records.");
        pbPanel.setAlignmentX(Component.LEFT_ALIGNMENT);

        // Add feature panels to the container with fixed spacing
        featurePanelsContainer.add(trackDropsPanel);
        featurePanelsContainer.add(Box.createRigidArea(new Dimension(0, 8)));
        featurePanelsContainer.add(discordPanel);
        featurePanelsContainer.add(Box.createRigidArea(new Dimension(0, 8)));
        featurePanelsContainer.add(pbPanel);

        // Add all panels to home panel with proper spacing
        homePanel.add(welcomeMessagePanel);
        homePanel.add(Box.createRigidArea(new Dimension(0, 8)));

        JButton viewGlobalButton = PanelElements.createLootboardButton("Global Lootboard", "Click to view the global lootboard", () -> PanelElements.showLootboardForGroup(client, 2));

        viewGlobalButton.setMargin(new Insets(3, 3, 3, 3));
        viewGlobalButton.setAlignmentX(Component.LEFT_ALIGNMENT);

        JPanel buttonPanel = new JPanel(new BorderLayout(10, 0));
        buttonPanel.setLayout(new BoxLayout(buttonPanel, BoxLayout.X_AXIS));
        buttonPanel.setAlignmentX(Component.LEFT_ALIGNMENT);
        buttonPanel.add(viewGlobalButton);

        homePanel.add(buttonPanel);

        // Note: playerButtonIndex will be set to the next component index
        playerButtonIndex = homePanel.getComponentCount();

        // Initialize player button (will add if config is available)
        updatePlayerButton();

        homePanel.add(Box.createRigidArea(new Dimension(0, 8)));
        homePanel.add(patchNotesPanel);
        homePanel.add(Box.createRigidArea(new Dimension(0, 8)));
        homePanel.add(quickAccessPanel);
        homePanel.add(Box.createRigidArea(new Dimension(0, 8)));
        homePanel.add(featurePanelsContainer);

        return homePanel;
    }

    /**
     * Updates the player button based on current config state.
     * Can be called dynamically when the config changes.
     */
    public void updatePlayerButton() {
        if (homePanel == null) {
            return; // Panel not initialized yet
        }

        // Remove existing player button if it exists
        if (playerButtonRow != null) {
            homePanel.remove(playerButtonRow);
            playerButtonRow = null;
        }

        // Add player button if config is available
        if (config.lastAccountName() != null && !config.lastAccountName().isEmpty()) {
            playerButtonRow = new JPanel(new GridLayout(1, 2, 5, 0));
            playerButtonRow.setBackground(ColorScheme.DARK_GRAY_COLOR);
            playerButtonRow.setAlignmentX(Component.LEFT_ALIGNMENT);

            JButton playerStatsButton = new JButton("View your Stats");
            playerStatsButton.setFocusPainted(false);
            playerStatsButton.setFont(FontManager.getRunescapeSmallFont());
            playerStatsButton.addActionListener(e -> {
                panel.selectPanel("players");
                panel.updatePlayerPanel(config.lastAccountName());
            });
            playerStatsButton.setMargin(new Insets(0, 0, 0, 0));

            playerButtonRow.add(playerStatsButton);

            // Insert at the correct position (after the global lootboard button)
            homePanel.add(playerButtonRow, playerButtonIndex);
        }

        // Refresh the panel
        homePanel.revalidate();
        homePanel.repaint();
    }
}

package io.droptracker.ui.pages;

import io.droptracker.DropTrackerConfig;
import io.droptracker.api.DropTrackerApi;
import io.droptracker.models.api.GroupConfig;
import io.droptracker.models.submissions.ValidSubmission;
import io.droptracker.service.SubmissionManager;
import io.droptracker.ui.DropTrackerPanel;
import io.droptracker.ui.components.PanelElements;
import io.droptracker.util.DurationAdapter;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.FontManager;
import net.runelite.client.ui.PluginPanel;

import javax.swing.*;
import javax.swing.border.EmptyBorder;
import java.awt.*;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.time.Duration;
import java.time.Instant;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

public class ApiPanel {
    private final DropTrackerConfig config;
    private final DropTrackerApi api;
    private final SubmissionManager submissionManager;

    private JPanel apiPanel;
    private JPanel submissionsPanel;
    private JPanel statisticsPanel;
    private Timer statusUpdateTimer;
    private JPanel groupConfigPanel;
    private JPanel groupsContainerPanel;
    private DropTrackerPanel mainPanel;
    private JScrollPane groupsScrollPane;
    private final Map<String, Boolean> groupExpandStates = new HashMap<>(); // Track expand/collapse state by group ID


    public ApiPanel(DropTrackerConfig config, DropTrackerApi api, SubmissionManager submissionManager, DropTrackerPanel mainPanel) {
        this.config = config;
        this.api = api;
        this.submissionManager = submissionManager;
        this.mainPanel = mainPanel;
    }

    public JPanel create() {
        apiPanel = new JPanel();
        apiPanel.setLayout(new BoxLayout(apiPanel, BoxLayout.Y_AXIS));
        apiPanel.setBackground(ColorScheme.DARK_GRAY_COLOR);
        apiPanel.setBorder(new EmptyBorder(0, 0, 0, 0));

        // Communication status is now handled in the main panel header

        JPanel configPanel = initializeConfigPanel();


        // Initialize statistics panel
        JPanel statisticsPanel = initializeStatisticsPanel();
        
        // Initialize submissions panel
        initializeSubmissionsPanel();

        // Add all components to the API panel
        apiPanel.add(statisticsPanel);
        apiPanel.add(Box.createRigidArea(new Dimension(0, 5)));
        apiPanel.add(submissionsPanel);
        apiPanel.add(Box.createRigidArea(new Dimension(0, 10)));
        // Add configs beneath the submissions panel
        apiPanel.add(configPanel);
        apiPanel.add(Box.createVerticalGlue());

        // Initial update
        updateStatusLabel();
        refreshStatistics();
        refreshSubmissions();
        refreshGroupConfigs();

        // Start timer to update status every 10 seconds
        if (config.pollUpdates()) {
            statusUpdateTimer = new Timer(10000, e -> {
                updateStatusLabel();
                refreshStatistics();
                refreshGroupConfigs();
                // Poll pending submissions for processed status when API is enabled
                if (config.useApi()) {
                    // Only check pending statuses if there are submissions that need checking
                    if (hasPendingOrFailedSubmissions()) {
                        submissionManager.checkPendingStatuses();
                        // After polling, refresh the submissions list
                        refreshSubmissions();
                    }
                }
            });
            statusUpdateTimer.start();
        }

        JPanel wrapperPanel = new JPanel(new BorderLayout());
        wrapperPanel.add(apiPanel, BorderLayout.CENTER);
        return wrapperPanel;
    }

    private void initializeSubmissionsPanel() {
        submissionsPanel = new JPanel();
        submissionsPanel.setLayout(new BoxLayout(submissionsPanel, BoxLayout.Y_AXIS));
        submissionsPanel.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        submissionsPanel.setBorder(new EmptyBorder(10, 10, 10, 10));

        submissionsPanel.setPreferredSize(new Dimension(PluginPanel.PANEL_WIDTH - 20, 200));
        submissionsPanel.setMaximumSize(new Dimension(PluginPanel.PANEL_WIDTH - 20, 300));
        submissionsPanel.setMinimumSize(new Dimension(PluginPanel.PANEL_WIDTH - 20, 50));

        // Create title for submissions section
        JLabel submissionsTitle = new JLabel("Session Submissions");
        submissionsTitle.setFont(FontManager.getRunescapeBoldFont());
        submissionsTitle.setForeground(Color.WHITE);
        submissionsTitle.setAlignmentX(Component.CENTER_ALIGNMENT);
        submissionsPanel.add(submissionsTitle);
        submissionsPanel.add(Box.createRigidArea(new Dimension(0, 3)));

        JTextArea descriptionText = new JTextArea("");
        descriptionText.setWrapStyleWord(true);
        descriptionText.setLineWrap(true);
        descriptionText.setOpaque(false);
        descriptionText.setEditable(false);
        descriptionText.setFocusable(false);
        descriptionText.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        descriptionText.setForeground(Color.LIGHT_GRAY);
        descriptionText.setFont(FontManager.getRunescapeSmallFont());
        descriptionText.setBorder(new EmptyBorder(5, 5, 5, 5));
        submissionsPanel.add(descriptionText);
        submissionsPanel.add(Box.createRigidArea(new Dimension(0, 3)));
    }

    private JPanel initializeStatisticsPanel() {
        statisticsPanel = new JPanel();
        statisticsPanel.setLayout(new BoxLayout(statisticsPanel, BoxLayout.Y_AXIS));
        statisticsPanel.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        statisticsPanel.setBorder(new EmptyBorder(10, 10, 10, 10));

        statisticsPanel.setPreferredSize(new Dimension(PluginPanel.PANEL_WIDTH - 20, 80));
        statisticsPanel.setMaximumSize(new Dimension(PluginPanel.PANEL_WIDTH - 20, 100));
        statisticsPanel.setMinimumSize(new Dimension(PluginPanel.PANEL_WIDTH - 20, 60));

        // Create title for statistics section
        JLabel statisticsTitle = new JLabel("Session Statistics");
        statisticsTitle.setFont(FontManager.getRunescapeBoldFont());
        statisticsTitle.setForeground(Color.WHITE);
        statisticsTitle.setAlignmentX(Component.CENTER_ALIGNMENT);
        statisticsPanel.add(statisticsTitle);
        statisticsPanel.add(Box.createRigidArea(new Dimension(0, 5)));

        // Create streamlined statistics display
        JPanel statsContainer = createStreamlinedStatsDisplay();
        statisticsPanel.add(statsContainer);

        return statisticsPanel;
    }

    private JPanel createStreamlinedStatsDisplay() {
        JPanel container = new JPanel();
        container.setLayout(new BoxLayout(container, BoxLayout.Y_AXIS));
        container.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        container.setMaximumSize(new Dimension(PluginPanel.PANEL_WIDTH - 40, 50));
        
        // Create two rows of statistics in a compact format
        JPanel row1 = createStatsRow(
            "Notified count:", String.valueOf(submissionManager.totalSubmissions), Color.CYAN,
            "Sent:", String.valueOf(submissionManager.notificationsSent), Color.GREEN
        );
        row1.setToolTipText("Total number of submissions you have sent, and number of those which have created Discord notifications");
        
        JPanel row2 = createStatsRow(
            "# Failed:", String.valueOf(submissionManager.failedSubmissions), Color.RED,
            "GP value:", formatValue(submissionManager.totalValue), Color.YELLOW
        );
        
        // Get retry stats for status indicator
        JPanel statusRow = createStatusRow();
        
        container.add(row1);
        container.add(Box.createRigidArea(new Dimension(0, 2)));
        container.add(row2);
        container.add(Box.createRigidArea(new Dimension(0, 3)));
        container.add(statusRow);
        
        return container;
    }
    
    private JPanel createStatsRow(String label1, String value1, Color color1, 
                                  String label2, String value2, Color color2) {
        JPanel row = new JPanel(new FlowLayout(FlowLayout.CENTER, 15, 0));
        row.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        row.setMaximumSize(new Dimension(PluginPanel.PANEL_WIDTH - 40, 16));
        row.setPreferredSize(new Dimension(PluginPanel.PANEL_WIDTH - 40, 16));
        
        // First stat
        JPanel stat1 = createCompactStat(label1, value1, color1);
        row.add(stat1);
        
        // Separator
        JLabel separator = new JLabel("|");
        separator.setForeground(Color.GRAY);
        separator.setFont(FontManager.getRunescapeSmallFont());
        row.add(separator);
        
        // Second stat
        JPanel stat2 = createCompactStat(label2, value2, color2);
        row.add(stat2);
        
        return row;
    }
    
    private JPanel createCompactStat(String label, String value, Color valueColor) {
        JPanel stat = new JPanel(new FlowLayout(FlowLayout.LEFT, 3, 0));
        stat.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        
        JLabel labelComponent = new JLabel(label);
        labelComponent.setFont(FontManager.getRunescapeSmallFont());
        labelComponent.setForeground(Color.LIGHT_GRAY);
        
        JLabel valueComponent = new JLabel(value);
        valueComponent.setFont(FontManager.getRunescapeSmallFont());
        valueComponent.setForeground(valueColor);
        
        stat.add(labelComponent);
        stat.add(valueComponent);
        
        return stat;
    }
    
    private JPanel createStatusRow() {
        JPanel row = new JPanel(new FlowLayout(FlowLayout.CENTER, 8, 0));
        row.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        row.setMaximumSize(new Dimension(PluginPanel.PANEL_WIDTH - 40, 14));
        row.setPreferredSize(new Dimension(PluginPanel.PANEL_WIDTH - 40, 14));
        
        // Simple status based on last communication time
        JLabel healthIcon = new JLabel("");
        boolean healthy = true; // consider healthy here; header shows real timing
        healthIcon.setForeground(healthy ? Color.GREEN : Color.RED);
        healthIcon.setFont(FontManager.getRunescapeSmallFont());
        
        JLabel healthLabel = new JLabel("API Status");
        healthLabel.setFont(FontManager.getRunescapeSmallFont());
        healthLabel.setForeground(Color.LIGHT_GRAY);
        
        
        
        row.add(healthIcon);
        row.add(healthLabel);
        row.add(new JLabel(" "));
        
        return row;
    }

    
    private String formatValue(Long value) {
        if (value == null || value == 0) return "0";
        
        if (value >= 1_000_000) {
            return String.format("%.1fM", value / 1_000_000.0);
        } else if (value >= 1_000) {
            return String.format("%.1fK", value / 1_000.0);
        } else {
            return String.valueOf(value);
        }
    }

    private JPanel initializeConfigPanel() {
        // Create a wrapper panel to contain the group configs
        JPanel wrapperPanel = new JPanel();
        wrapperPanel.setLayout(new BoxLayout(wrapperPanel, BoxLayout.Y_AXIS));
        wrapperPanel.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        wrapperPanel.setMaximumSize(new Dimension(PluginPanel.PANEL_WIDTH - 20, 400)); // Limit wrapper size

        // Status label removed - now shown in main panel header

        // Create the content panel that will hold all group configs
        JPanel groupsContainer = new JPanel();
        groupsContainer.setLayout(new BoxLayout(groupsContainer, BoxLayout.Y_AXIS));
        groupsContainer.setBackground(ColorScheme.DARKER_GRAY_COLOR);

        // Build the group config panels
        buildGroupConfigPanels(groupsContainer);

        // Create scroll pane for the groups
        groupsScrollPane = new JScrollPane(groupsContainer);
        groupsScrollPane.setHorizontalScrollBarPolicy(ScrollPaneConstants.HORIZONTAL_SCROLLBAR_NEVER);
        groupsScrollPane.setVerticalScrollBarPolicy(ScrollPaneConstants.VERTICAL_SCROLLBAR_AS_NEEDED);
        groupsScrollPane.setBorder(null);
        groupsScrollPane.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        groupsScrollPane.getViewport().setBackground(ColorScheme.DARKER_GRAY_COLOR);
        groupsScrollPane.setMaximumSize(new Dimension(PluginPanel.PANEL_WIDTH - 20, 150)); // Limit scroll pane height
        groupsScrollPane.setPreferredSize(new Dimension(PluginPanel.PANEL_WIDTH - 20, 150));

        // Add the scroll pane to wrapper
        wrapperPanel.add(groupsScrollPane);

        // Store reference to groups container for refresh
        this.groupsContainerPanel = groupsContainer;

        // Create the main collapsible panel - use custom method for consistent behavior
        groupConfigPanel = createMainCollapsiblePanel("Group Configurations", wrapperPanel);

        return groupConfigPanel;
    }

    /**
     * Creates the main collapsible panel with consistent sizing behavior
     */
    private JPanel createMainCollapsiblePanel(String title, JPanel content) {
        JPanel panel = new JPanel();
        panel.setLayout(new BoxLayout(panel, BoxLayout.Y_AXIS));
        panel.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        panel.setBorder(new EmptyBorder(10, 10, 10, 10)); // Standard padding for main panel

        // Set initial size constraints
        panel.setMaximumSize(new Dimension(PluginPanel.PANEL_WIDTH, 200));
        panel.setPreferredSize(new Dimension(PluginPanel.PANEL_WIDTH, 200));

        JPanel headerPanel = new JPanel(new BorderLayout());
        headerPanel.setBackground(ColorScheme.DARKER_GRAY_COLOR);

        // Create title
        JLabel titleLabel = new JLabel(title);
        titleLabel.setFont(FontManager.getRunescapeBoldFont());
        titleLabel.setForeground(Color.WHITE);

        // Get the static icons from PanelElements using getter methods
        ImageIcon expandedIcon = PanelElements.getExpandedIcon();
        ImageIcon collapsedIcon = PanelElements.getCollapsedIcon();

        final ImageIcon finalExpandedIcon = expandedIcon;
        final ImageIcon finalCollapsedIcon = collapsedIcon;
        final JLabel toggleIcon = new JLabel(expandedIcon);

        headerPanel.add(titleLabel, BorderLayout.WEST);
        headerPanel.add(toggleIcon, BorderLayout.EAST);

        // Store initial expanded state
        final boolean[] isCollapsed = {false};

        // Add click listener for collapsing/expanding
        headerPanel.addMouseListener(new MouseAdapter() {
            @Override
            public void mouseClicked(MouseEvent e) {
                isCollapsed[0] = !isCollapsed[0];
                toggleIcon.setIcon(isCollapsed[0] ? finalCollapsedIcon : finalExpandedIcon);
                content.setVisible(!isCollapsed[0]);

                // Maintain consistent sizing
                if (isCollapsed[0]) {
                    panel.setPreferredSize(new Dimension(PluginPanel.PANEL_WIDTH, headerPanel.getPreferredSize().height + 20));
                    panel.setMaximumSize(new Dimension(PluginPanel.PANEL_WIDTH, headerPanel.getPreferredSize().height + 20));
                } else {
                    panel.setPreferredSize(new Dimension(PluginPanel.PANEL_WIDTH, 200));
                    panel.setMaximumSize(new Dimension(PluginPanel.PANEL_WIDTH, 200));
                }

                panel.revalidate();
                panel.repaint();
            }

            @Override
            public void mouseEntered(MouseEvent e) {
                headerPanel.setCursor(new Cursor(Cursor.HAND_CURSOR));
            }

            @Override
            public void mouseExited(MouseEvent e) {
                headerPanel.setCursor(new Cursor(Cursor.DEFAULT_CURSOR));
            }
        });

        // Add separator
        JSeparator separator = new JSeparator();
        separator.setBackground(ColorScheme.LIGHT_GRAY_COLOR);
        separator.setForeground(ColorScheme.LIGHT_GRAY_COLOR);

        panel.add(headerPanel);
        panel.add(separator);
        panel.add(content);

        return panel;
    }

    /**
     * Builds individual collapsible panels for each group configuration
     */
    private void buildGroupConfigPanels(JPanel parentPanel) {
        parentPanel.removeAll();

        List<GroupConfig> groupConfigs = api.getGroupConfigs();
        if (groupConfigs != null && groupConfigs.size() > 0) {
            for (GroupConfig groupConfig : groupConfigs) {
                // Create content for this group
                JPanel groupContentPanel = createGroupConfigPanel(groupConfig);

                // Create collapsible panel for this group with reduced padding
                String groupTitle = groupConfig.getGroupName() + " (ID: " + groupConfig.getGroupId() + ")";
                String groupKey = String.valueOf(groupConfig.getGroupId());

                // Check if we have a saved state for this group, default to collapsed (true)
                boolean isCollapsed = groupExpandStates.getOrDefault(groupKey, true);

                JPanel collapsibleGroup = createCompactCollapsiblePanel(groupTitle, groupContentPanel, groupKey, isCollapsed);

                parentPanel.add(collapsibleGroup);
                parentPanel.add(Box.createRigidArea(new Dimension(0, 2))); // Reduced space between groups
            }
        } else {
            // Show "no configs" message with minimal height
            JPanel emptyPanel = new JPanel();
            emptyPanel.setLayout(new BoxLayout(emptyPanel, BoxLayout.Y_AXIS));
            emptyPanel.setBackground(ColorScheme.DARKER_GRAY_COLOR);
            emptyPanel.setMaximumSize(new Dimension(Integer.MAX_VALUE, 30));
            emptyPanel.setPreferredSize(new Dimension(PluginPanel.PANEL_WIDTH - 40, 30));

            JLabel noConfigsLabel = new JLabel("No group configurations loaded.");
            noConfigsLabel.setFont(FontManager.getRunescapeSmallFont());
            noConfigsLabel.setForeground(Color.GRAY);
            noConfigsLabel.setAlignmentX(Component.CENTER_ALIGNMENT);
            emptyPanel.add(Box.createVerticalGlue());
            emptyPanel.add(noConfigsLabel);
            emptyPanel.add(Box.createVerticalGlue());

            parentPanel.add(emptyPanel);
        }
    }

    /**
     * Creates a compact collapsible panel with reduced padding
     */
    private JPanel createCompactCollapsiblePanel(String title, JPanel content, String groupKey, boolean isCollapsed) {
        JPanel panel = new JPanel();
        panel.setLayout(new BoxLayout(panel, BoxLayout.Y_AXIS));
        panel.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        panel.setBorder(new EmptyBorder(2, 5, 2, 5)); // Further reduced padding

        // Set maximum size when expanded
        panel.setMaximumSize(new Dimension(Integer.MAX_VALUE, 130)); // Limit total height

        JPanel headerPanel = new JPanel(new BorderLayout());
        headerPanel.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        headerPanel.setMaximumSize(new Dimension(Integer.MAX_VALUE, 18)); // Reduced header height
        headerPanel.setPreferredSize(new Dimension(PluginPanel.PANEL_WIDTH - 40, 18));

        // Create title
        JLabel titleLabel = new JLabel(title);
        titleLabel.setFont(FontManager.getRunescapeSmallFont()); // Use small font for group titles
        titleLabel.setForeground(Color.WHITE);

        // Get the static icons from PanelElements using getter methods
        ImageIcon expandedIcon = PanelElements.getExpandedIcon();
        ImageIcon collapsedIcon = PanelElements.getCollapsedIcon();

        // Toggle icon - set initial state based on isCollapsed parameter
        final ImageIcon finalExpandedIcon = expandedIcon;
        final ImageIcon finalCollapsedIcon = collapsedIcon;
        final JLabel toggleIcon = new JLabel(isCollapsed ? collapsedIcon : expandedIcon);

        headerPanel.add(titleLabel, BorderLayout.WEST);
        headerPanel.add(toggleIcon, BorderLayout.EAST);

        // Set initial visibility based on collapsed state
        content.setVisible(!isCollapsed);

        // Set initial panel size based on collapsed state
        if (isCollapsed) {
            panel.setMaximumSize(new Dimension(Integer.MAX_VALUE, 24));
            panel.setPreferredSize(new Dimension(PluginPanel.PANEL_WIDTH - 40, 24));
        }

        // Create a final reference to the content for use in the listener
        final boolean[] isCollapsedRef = {isCollapsed};

        // Add click listener for collapsing/expanding
        MouseAdapter clickListener = new MouseAdapter() {
            @Override
            public void mouseClicked(MouseEvent e) {
                isCollapsedRef[0] = !isCollapsedRef[0];
                toggleIcon.setIcon(isCollapsedRef[0] ? finalCollapsedIcon : finalExpandedIcon);
                content.setVisible(!isCollapsedRef[0]);

                // Save the state
                groupExpandStates.put(groupKey, isCollapsedRef[0]);

                // Update panel size
                if (isCollapsedRef[0]) {
                    panel.setMaximumSize(new Dimension(Integer.MAX_VALUE, 24)); // Just header + borders
                    panel.setPreferredSize(new Dimension(PluginPanel.PANEL_WIDTH - 40, 24));
                } else {
                    panel.setMaximumSize(new Dimension(Integer.MAX_VALUE, 130)); // Limited height when expanded
                    panel.setPreferredSize(null);
                }

                // Force the parent to re-layout
                panel.revalidate();
                panel.repaint();
                if (panel.getParent() != null) {
                    panel.getParent().revalidate();
                    panel.getParent().repaint();
                }
            }

            @Override
            public void mouseEntered(MouseEvent e) {
                headerPanel.setCursor(new Cursor(Cursor.HAND_CURSOR));
            }

            @Override
            public void mouseExited(MouseEvent e) {
                headerPanel.setCursor(new Cursor(Cursor.DEFAULT_CURSOR));
            }
        };

        headerPanel.addMouseListener(clickListener);

        // Add separator
        JSeparator separator = new JSeparator();
        separator.setBackground(ColorScheme.LIGHT_GRAY_COLOR);
        separator.setForeground(ColorScheme.LIGHT_GRAY_COLOR);
        separator.setMaximumSize(new Dimension(Integer.MAX_VALUE, 1));

        panel.add(headerPanel);
        panel.add(separator);
        panel.add(content);

        return panel;
    }

    /**
     * Creates the configuration panel for a single group
     */
    private JPanel createGroupConfigPanel(GroupConfig groupConfig) {
        JPanel panel = new JPanel();
        panel.setLayout(new BoxLayout(panel, BoxLayout.Y_AXIS));
        panel.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        panel.setBorder(new EmptyBorder(2, 5, 2, 5));

        // Notifications header
        JPanel headerPanel = new JPanel(new FlowLayout(FlowLayout.LEFT, 2, 0));
        headerPanel.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        headerPanel.setMaximumSize(new Dimension(Integer.MAX_VALUE, 18));
        headerPanel.setPreferredSize(new Dimension(PluginPanel.PANEL_WIDTH - 70, 18));
        
        JLabel notificationsLabel = new JLabel("Notifications:");
        notificationsLabel.setFont(FontManager.getRunescapeSmallFont());
        notificationsLabel.setForeground(Color.WHITE);
        headerPanel.add(notificationsLabel);
        
        panel.add(headerPanel);
        panel.add(Box.createRigidArea(new Dimension(0, 2)));

        // Drops configuration
        panel.add(createConfigRow("Drops",
                groupConfig.isSendDrops(),
                "Min: " + groupConfig.getMinimumDropValue()));

        // CAs configuration
        panel.add(createConfigRow("CAs",
                groupConfig.isSendCAs(),
                "Min Tier: " + groupConfig.getMinimumCATier()));

        // PBs configuration
        panel.add(createConfigRow("PBs",
                groupConfig.isSendPbs(),
                null));

        // CLogs configuration
        panel.add(createConfigRow("CLogs",
                groupConfig.isSendClogs(),
                null));
        
        // Pets config
        panel.add(createConfigRow("Pets",
                groupConfig.isSendPets(),
                null));
        
        // Quests config
        panel.add(createConfigRow("Quests",
                groupConfig.isSendQuests(),
                null));
        
        // Level config
        String levelText = "";
        if (groupConfig.isSendXP()) {
            levelText = "Levels (" + groupConfig.getMinimumLevel() + " min)";
        } else {
            levelText = "Levels";
        }
        panel.add(createConfigRow(levelText,
                groupConfig.isSendXP(),
                null));
        return panel;
    }

    /**
     * Creates a configuration row with label, status, and optional details
     */
    private JPanel createConfigRow(String label, boolean enabled, String details) {
        JPanel row = new JPanel(new FlowLayout(FlowLayout.LEFT, 2, 0));
        row.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        row.setMaximumSize(new Dimension(Integer.MAX_VALUE, 18)); // Reduced from 20
        row.setPreferredSize(new Dimension(PluginPanel.PANEL_WIDTH - 70, 18));

        // Label
        JLabel nameLabel = new JLabel(label + ":");
        nameLabel.setFont(FontManager.getRunescapeSmallFont());
        nameLabel.setForeground(Color.LIGHT_GRAY);
        row.add(nameLabel);

        // Status
        JLabel statusLabel = new JLabel(enabled ? "On" : "Off");
        statusLabel.setFont(FontManager.getRunescapeSmallFont());
        statusLabel.setForeground(enabled ? Color.GREEN : Color.RED);
        row.add(statusLabel);

        // Optional details
        if (details != null && !details.isEmpty()) {
            JLabel detailsLabel = new JLabel("(" + details + ")");
            detailsLabel.setFont(FontManager.getRunescapeSmallFont());
            detailsLabel.setForeground(Color.GRAY);
            row.add(detailsLabel);
        }

        return row;
    }

    public void updateStatusLabel() {
        if (!config.useApi()) {
            return; // No need to update communication status when API is disabled
        }
        
        long nowEpochSeconds = Instant.now().getEpochSecond();
        long lastEpochSeconds = api.lastCommunicationTime;
        long deltaSeconds = Math.max(0L, nowEpochSeconds - lastEpochSeconds);
        Duration duration = Duration.ofSeconds(deltaSeconds);

        String lastCommunicationTime = DurationAdapter.formatDuration(duration);
        String statusText;
        Color statusColor;
        
        // More conservative disconnect detection
        if (duration.toSeconds() < 60) {
            // Connected - recent communication
            statusText = "Last ping: " + lastCommunicationTime;
            statusColor = ColorScheme.PROGRESS_COMPLETE_COLOR;
        } else if (duration.toSeconds() < 300) { // 5 minutes
            // Warning state - might be having issues
            statusText = "Last ping: " + lastCommunicationTime;
            statusColor = Color.YELLOW;
        } else {
            // Likely disconnected after 5+ minutes of no communication
            statusText = "Disconnected (" + lastCommunicationTime + ")";
            statusColor = ColorScheme.PROGRESS_ERROR_COLOR;
        }

        // Update the header communication status
        if (mainPanel != null) {
            mainPanel.updateCommunicationStatus(statusText, statusColor);
        }
    }

    /**
     * Refreshes the submissions display with current data from SubmissionManager
     */
    public void refreshSubmissions() {
        if (submissionManager != null) {
            List<ValidSubmission> validSubmissions = submissionManager.getValidSubmissions();
            if (validSubmissions != null) {
                updateSentSubmissions(validSubmissions);
            }
        }
    }

    /**
     * Updates the submissions panel with the provided list of ValidSubmissions
     *
     * @param validSubmissions List of submissions to display
     */
    public void updateSentSubmissions(List<ValidSubmission> validSubmissions) {
        if (submissionsPanel == null) {
            return;
        }

        // Clear existing submission entries (keep title)
        Component[] components = submissionsPanel.getComponents();
        for (int i = components.length - 1; i >= 2; i--) { // Keep title and spacer
            submissionsPanel.remove(i);
        }

        if (validSubmissions != null && validSubmissions.size() > 0) {
            // Separate submissions by status - pending submissions first, then processed
            List<ValidSubmission> pendingSubmissions = new ArrayList<>();
            List<ValidSubmission> processedSubmissions = new ArrayList<>();
            
            for (ValidSubmission submission : validSubmissions) {
                String status = submission.getStatus();
                if ("processed".equals(status)) {
                    processedSubmissions.add(submission);
                } else {
                    // Treat everything else (pending, sent, queued, retrying, failed, etc.) as in-progress list
                    pendingSubmissions.add(submission);
                }
            }
            
            // Add pending submissions with full action panels
            for (ValidSubmission submission : pendingSubmissions) {
                JPanel submissionPanel = createSubmissionPanel(submission);
                submissionsPanel.add(submissionPanel);
                submissionsPanel.add(Box.createRigidArea(new Dimension(0, 5)));
            }
            
            // Add processed submissions with compact display
            for (ValidSubmission submission : processedSubmissions) {
                JPanel compactPanel = createCompactSubmissionPanel(submission);
                submissionsPanel.add(compactPanel);
                submissionsPanel.add(Box.createRigidArea(new Dimension(0, 3)));
            }
        } else {
            // Show "no submissions" message
            JLabel noSubmissionsLabel = new JLabel("<html>Your achievements/drops will show up here as you receive them, if they qualify for notifications in any of your groups.<br />" +
                    "You can then re-try them if they appear to have not properly sent to your Discord server.</html>");
            noSubmissionsLabel.setFont(FontManager.getRunescapeSmallFont());
            noSubmissionsLabel.setForeground(Color.GRAY);
            noSubmissionsLabel.setAlignmentX(Component.CENTER_ALIGNMENT);
            submissionsPanel.add(noSubmissionsLabel);
        }

        // Refresh the UI
        submissionsPanel.revalidate();
        submissionsPanel.repaint();
        if (apiPanel != null) {
            apiPanel.revalidate();
            apiPanel.repaint();
        }
    }

    /**
     * Creates an enhanced panel for displaying a single ValidSubmission with retry/dismiss buttons
     *
     * @param submission The submission to display
     * @return A JPanel containing the submission display
     */
    private JPanel createSubmissionPanel(ValidSubmission submission) {
        JPanel card = new JPanel();
        card.setLayout(new BorderLayout(8, 0));
        card.setBackground(ColorScheme.MEDIUM_GRAY_COLOR);
        card.setBorder(new EmptyBorder(8, 12, 8, 12));
        card.setPreferredSize(new Dimension(PluginPanel.PANEL_WIDTH - 40, 70));
        card.setMaximumSize(new Dimension(PluginPanel.PANEL_WIDTH - 40, 70));

        // Left side - Submission type indicator with color coding
        JPanel typePanel = createSubmissionTypeIndicator(submission);
        card.add(typePanel, BorderLayout.WEST);

        // Center - Enhanced submission details
        JPanel detailsPanel = createValidSubmissionDetails(submission);
        card.add(detailsPanel, BorderLayout.CENTER);

        // Right side - Action buttons
        JPanel actionPanel = createActionButtons(submission);
        card.add(actionPanel, BorderLayout.EAST);

        // Add enhanced tooltip
        String tooltip = buildValidSubmissionTooltip(submission);
        card.setToolTipText(tooltip);

        // Add hover effect
        card.addMouseListener(new java.awt.event.MouseAdapter() {
            @Override
            public void mouseEntered(java.awt.event.MouseEvent e) {
                card.setBackground(ColorScheme.DARKER_GRAY_HOVER_COLOR);
            }

            @Override
            public void mouseExited(java.awt.event.MouseEvent e) {
                card.setBackground(ColorScheme.MEDIUM_GRAY_COLOR);
            }
        });

        return card;
    }
    
    /**
     * Creates a compact panel for processed submissions with just dismiss option
     */
    private JPanel createCompactSubmissionPanel(ValidSubmission submission) {
        JPanel card = new JPanel();
        card.setLayout(new BorderLayout(5, 0));
        card.setBackground(ColorScheme.DARK_GRAY_COLOR);
        card.setBorder(new EmptyBorder(4, 8, 4, 8));
        card.setPreferredSize(new Dimension(PluginPanel.PANEL_WIDTH - 40, 35));
        card.setMaximumSize(new Dimension(PluginPanel.PANEL_WIDTH - 40, 35));

        // Left side - Small status indicator
        JLabel statusIndicator = new JLabel("");
        statusIndicator.setFont(FontManager.getRunescapeSmallFont());
        statusIndicator.setForeground(Color.GREEN);
        statusIndicator.setPreferredSize(new Dimension(15, 20));
        card.add(statusIndicator, BorderLayout.WEST);

        // Center - Compact submission text
        JPanel textPanel = new JPanel();
        textPanel.setLayout(new BoxLayout(textPanel, BoxLayout.Y_AXIS));
        textPanel.setBackground(ColorScheme.DARK_GRAY_COLOR);
        
        // Get submission content but make it more compact
        JPanel originalPanel = submission.toSubmissionPanel();
        String submissionText = extractTextFromPanel(originalPanel);
        
        // Fallback: if text extraction failed or returned empty, create text from submission fields
        if (submissionText == null || submissionText.trim().isEmpty()) {
            submissionText = createSubmissionTextFromFields(submission);
        }
        
        JLabel mainLabel = new JLabel();
        mainLabel.setFont(FontManager.getRunescapeSmallFont());
        mainLabel.setForeground(Color.LIGHT_GRAY);
        mainLabel.setAlignmentX(Component.LEFT_ALIGNMENT);
        // Truncate for compact display
        if (submissionText.length() > 45) {
            mainLabel.setText(submissionText.substring(0, 42) + "...");
        } else {
            mainLabel.setText(submissionText);
        }
        
        JLabel statusLabel = new JLabel(submission.getStatusDescription());
        statusLabel.setFont(FontManager.getRunescapeSmallFont());
        statusLabel.setForeground(getStatusColor(submission.getStatus()));
        statusLabel.setAlignmentX(Component.LEFT_ALIGNMENT);
        
        textPanel.add(mainLabel);
        textPanel.add(statusLabel);
        card.add(textPanel, BorderLayout.CENTER);

        // Right side - Only dismiss button
        JButton dismissButton = new JButton("");
        dismissButton.setFont(FontManager.getRunescapeSmallFont());
        dismissButton.setPreferredSize(new Dimension(18, 18));
        dismissButton.setMaximumSize(new Dimension(18, 18));
        dismissButton.setMinimumSize(new Dimension(18, 18));
        dismissButton.setMargin(new java.awt.Insets(0, 0, 0, 0));
        dismissButton.setFocusPainted(false);
        dismissButton.setBorderPainted(true);
        dismissButton.setContentAreaFilled(true);
        dismissButton.setBackground(new Color(120, 40, 40));
        dismissButton.setForeground(Color.WHITE);
        dismissButton.setToolTipText("Remove from list");
        dismissButton.addActionListener(e -> {
            submissionManager.removeSubmission(submission);
            refreshSubmissions();
        });
        
        card.add(dismissButton, BorderLayout.EAST);

        // Add subtle hover effect
        card.addMouseListener(new java.awt.event.MouseAdapter() {
            @Override
            public void mouseEntered(java.awt.event.MouseEvent e) {
                card.setBackground(ColorScheme.DARKER_GRAY_HOVER_COLOR);
            }

            @Override
            public void mouseExited(java.awt.event.MouseEvent e) {
                card.setBackground(ColorScheme.DARK_GRAY_COLOR);
            }
        });

        return card;
    }

    private JPanel createSubmissionTypeIndicator(ValidSubmission submission) {
        JPanel typePanel = new JPanel();
        typePanel.setLayout(new BorderLayout());
        typePanel.setPreferredSize(new Dimension(40, 40)); // 1:1 square ratio
        typePanel.setMaximumSize(new Dimension(40, 40));
        typePanel.setMinimumSize(new Dimension(40, 40));
        typePanel.setBackground(ColorScheme.DARK_GRAY_COLOR);
        typePanel.setBorder(new javax.swing.border.StrokeBorder(new java.awt.BasicStroke(1), ColorScheme.BORDER_COLOR));

        JLabel typeLabel = new JLabel();
        typeLabel.setHorizontalAlignment(SwingConstants.CENTER);
        typeLabel.setVerticalAlignment(SwingConstants.CENTER);
        typeLabel.setFont(FontManager.getRunescapeSmallFont());

        // Determine submission type and set appropriate styling
        String submissionType = getSubmissionTypeFromValidSubmission(submission);
        switch (submissionType.toLowerCase()) {
            case "drop":
                typeLabel.setText("DROP");
                typeLabel.setForeground(Color.YELLOW);
                break;
            case "clog":
                typeLabel.setText("CLOG");
                typeLabel.setForeground(Color.ORANGE);
                break;
            case "pb":
                typeLabel.setText("PB");
                typeLabel.setForeground(Color.CYAN);
                break;
            case "ca":
                typeLabel.setText("CA");
                typeLabel.setForeground(Color.MAGENTA);
                break;
            default:
                typeLabel.setText("SUB");
                typeLabel.setForeground(Color.WHITE);
        }

        typePanel.add(typeLabel, BorderLayout.CENTER);
        return typePanel;
    }

    private JPanel createValidSubmissionDetails(ValidSubmission submission) {
        JPanel detailsPanel = new JPanel();
        detailsPanel.setLayout(new BoxLayout(detailsPanel, BoxLayout.Y_AXIS));
        detailsPanel.setBackground(ColorScheme.MEDIUM_GRAY_COLOR);

        // Get submission content from the original panel but format it better
        JPanel originalPanel = submission.toSubmissionPanel();
        String submissionText = extractTextFromPanel(originalPanel);
        
        // Fallback: if text extraction failed or returned empty, create text from submission fields
        if (submissionText == null || submissionText.trim().isEmpty()) {
            submissionText = createSubmissionTextFromFields(submission);
        }

        // Main submission text - allow more space for longer text
        JLabel mainLabel = new JLabel();
        mainLabel.setFont(FontManager.getRunescapeBoldFont());
        mainLabel.setForeground(Color.WHITE);
        mainLabel.setAlignmentX(Component.LEFT_ALIGNMENT);

        // Truncate long text for better display but allow more characters
        if (submissionText.length() > 70) {
            mainLabel.setText(submissionText.substring(0, 67) + "...");
        } else {
            mainLabel.setText(submissionText);
        }

        // Status information - use HTML to prevent cutoff
        JLabel statusLabel = new JLabel("<html>Status: " + submission.getStatus() + "</html>");
        statusLabel.setFont(FontManager.getRunescapeSmallFont());
        statusLabel.setForeground(getStatusColor(submission.getStatus()));
        statusLabel.setAlignmentX(Component.LEFT_ALIGNMENT);
        statusLabel.setBackground(null);

        // Group information - use HTML to prevent cutoff
        

        detailsPanel.add(mainLabel);
        detailsPanel.add(Box.createRigidArea(new Dimension(0, 2)));
        detailsPanel.add(statusLabel);
        detailsPanel.add(Box.createRigidArea(new Dimension(0, 1)));

        return detailsPanel;
    }

    private JPanel createActionButtons(ValidSubmission submission) {
        JPanel actionPanel = new JPanel();
        actionPanel.setLayout(new BoxLayout(actionPanel, BoxLayout.Y_AXIS));
        actionPanel.setBackground(ColorScheme.MEDIUM_GRAY_COLOR);
        actionPanel.setPreferredSize(new Dimension(35, 50)); // Reduced width for small icon buttons
        actionPanel.setMaximumSize(new Dimension(35, 50));

        // Retry button - small icon button
        JButton retryButton = new JButton("");
        retryButton.setFont(FontManager.getRunescapeSmallFont());
        retryButton.setPreferredSize(new Dimension(20, 20));
        retryButton.setMaximumSize(new Dimension(20, 20));
        retryButton.setMinimumSize(new Dimension(20, 20));
        retryButton.setAlignmentX(Component.CENTER_ALIGNMENT);
        retryButton.setMargin(new java.awt.Insets(0, 0, 0, 0));
        retryButton.setFocusPainted(false);
        retryButton.setBorderPainted(true);
        retryButton.setContentAreaFilled(true);
        retryButton.setToolTipText("<html><div style='font-size: 10px;'>Retry sending this submission<br>to configured Discord servers</div></html>");
        retryButton.addActionListener(e -> {
            submissionManager.retrySubmission(submission);
            refreshSubmissions(); // Refresh to show updated status
        });

        // Dismiss button - small red X button
        JButton dismissButton = new JButton("");
        dismissButton.setFont(FontManager.getRunescapeSmallFont());
        dismissButton.setPreferredSize(new Dimension(20, 20));
        dismissButton.setMaximumSize(new Dimension(20, 20));
        dismissButton.setMinimumSize(new Dimension(20, 20));
        dismissButton.setAlignmentX(Component.CENTER_ALIGNMENT);
        dismissButton.setMargin(new java.awt.Insets(0, 0, 0, 0));
        dismissButton.setFocusPainted(false);
        dismissButton.setBorderPainted(true);
        dismissButton.setContentAreaFilled(true);
        dismissButton.setBackground(new Color(180, 50, 50)); // Red background
        dismissButton.setForeground(Color.WHITE);
        dismissButton.setToolTipText("<html><div style='font-size: 10px;'>Remove this submission<br>from the pending list</div></html>");
        dismissButton.addActionListener(e -> {
            submissionManager.removeSubmission(submission);
            refreshSubmissions(); // Refresh to remove from display
        });

        actionPanel.add(Box.createVerticalGlue());
        actionPanel.add(retryButton);
        actionPanel.add(Box.createRigidArea(new Dimension(0, 8)));
        actionPanel.add(dismissButton);
        actionPanel.add(Box.createVerticalGlue());

        return actionPanel;
    }

    private String buildValidSubmissionTooltip(ValidSubmission submission) {
        StringBuilder tooltip = new StringBuilder();
        tooltip.append("<html><div style='font-size: 10px; line-height: 1.2; padding: 3px;'>");

        // Submission type header
        String submissionType = getSubmissionTypeFromValidSubmission(submission).toUpperCase();
        tooltip.append("<div style='color: #FFFF00; font-weight: bold; margin-bottom: 3px;'>")
               .append(submissionType).append(" SUBMISSION</div>");

        // Get full submission text
        JPanel originalPanel = submission.toSubmissionPanel();
        String submissionText = extractTextFromPanel(originalPanel);
        
        // Fallback: if text extraction failed or returned empty, create text from submission fields
        if (submissionText == null || submissionText.trim().isEmpty()) {
            submissionText = createSubmissionTextFromFields(submission);
        }
        
        tooltip.append("<div style='color: #FFFFFF; margin-bottom: 3px;'>")
               .append(submissionText.replaceAll("<.*?>", "")).append("</div>");

        // Status with color coding
        String status = submission.getStatus();
        String statusColor = getStatusHexColor(status);
        tooltip.append("<div style='color: ").append(statusColor).append("; margin-bottom: 3px;'>")
               .append("Status: ").append(status).append("</div>");

        // Group information
        if (submission.getGroupIds() != null && submission.getGroupIds().length > 0) {
            tooltip.append("<div style='color: #C0C0C0; margin-bottom: 3px;'>")
                   .append("Configured for ").append(submission.getGroupIds().length).append(" group(s)</div>");
        }

        tooltip.append("<div style='color: #A0A0A0; font-style: italic; margin-top: 5px;'>")
               .append("Click Retry to resend or  to dismiss</div>");

        tooltip.append("</div></html>");
        return tooltip.toString();
    }

    private String getSubmissionTypeFromValidSubmission(ValidSubmission submission) {
        // Try to determine type from the submission panel content
        JPanel panel = submission.toSubmissionPanel();
        String text = extractTextFromPanel(panel).toLowerCase();
        
        if (text.contains("drop") || text.contains("received")) {
            return "drop";
        } else if (text.contains("collection") || text.contains("clog")) {
            return "clog";
        } else if (text.contains("personal best") || text.contains("pb") || text.contains("time")) {
            return "pb";
        } else if (text.contains("combat achievement") || text.contains("ca")) {
            return "ca";
        }
        return "unknown";
    }

    private String extractTextFromPanel(JPanel panel) {
        StringBuilder text = new StringBuilder();
        extractTextRecursive(panel, text);
        return text.toString().trim();
    }

    private void extractTextRecursive(java.awt.Container container, StringBuilder text) {
        for (java.awt.Component component : container.getComponents()) {
            if (component instanceof JLabel) {
                String labelText = ((JLabel) component).getText();
                if (labelText != null && !labelText.isEmpty()) {
                    text.append(labelText).append(" ");
                }
            } else if (component instanceof JTextArea) {
                String textAreaText = ((JTextArea) component).getText();
                if (textAreaText != null && !textAreaText.isEmpty()) {
                    text.append(textAreaText).append(" ");
                }
            } else if (component instanceof java.awt.Container) {
                extractTextRecursive((java.awt.Container) component, text);
            }
        }
    }

    /**
     * Creates submission text directly from ValidSubmission fields as a fallback
     * when panel-based text extraction fails
     */
    private String createSubmissionTextFromFields(ValidSubmission submission) {
        if (submission == null) {
            return "Unknown submission";
        }
        
        String itemName = submission.getItemName();
        if (itemName == null || itemName.trim().isEmpty()) {
            itemName = submission.getDescription();
        }
        if (itemName == null || itemName.trim().isEmpty()) {
            itemName = "Unknown item";
        }
        
        String typeText = "Submission";
        if (submission.getType() != null) {
            switch (submission.getType()) {
                case DROP:
                    typeText = "Drop";
                    break;
                case KILL_TIME:
                    typeText = "Personal Best";
                    break;
                case COLLECTION_LOG:
                    typeText = "Collection Log";
                    break;
                case COMBAT_ACHIEVEMENT:
                    typeText = "Combat Achievement";
                    break;
                case LEVEL_UP:
                    typeText = "Level Up";
                    break;
                case QUEST_COMPLETION:
                    typeText = "Quest Completion";
                    break;
                case EXPERIENCE:
                    typeText = "Experience";
                    break;
                case EXPERIENCE_MILESTONE:
                    typeText = "Experience Milestone";
                    break;
                case PET:
                    typeText = "Pet";
                    break;
                default:
                    typeText = "Submission";
                    break;
            }
        }
        
        return typeText + ": " + itemName;
    }

    private String getStatusHexColor(String status) {
        if (status == null) return "#808080";
        
        switch (status.toLowerCase()) {
            case "success":
            case "processed":
            case "sent":
                return "#00FF00";
            case "pending":
            case "retrying":
            case "queued":
                return "#FFFF00";
            case "failed":
            case "error":
                return "#FF0000";
            default:
                return "#808080";
        }
    }

    /**
     * Gets the appropriate color for a submission status
     *
     * @param status The submission status
     * @return Color for the status
     */
    private Color getStatusColor(String status) {
        if (status == null) return Color.GRAY;

        switch (status.toLowerCase()) {
            case "success":
            case "processed":
            case "sent":
                return Color.GREEN;
            case "pending":
            case "retrying":
            case "queued":
                return Color.YELLOW;
            case "failed":
            case "error":
                return Color.RED;
            default:
                return Color.GRAY;
        }
    }

    /**
     * Refreshes the statistics panel with current data from SubmissionManager
     */
    public void refreshStatistics() {
        if (statisticsPanel == null) {
            return;
        }
        
        // Remove existing components except title
        Component[] components = statisticsPanel.getComponents();
        for (int i = components.length - 1; i >= 2; i--) { // Keep title and spacer
            statisticsPanel.remove(i);
        }
        
        // Recreate the streamlined statistics display
        JPanel statsContainer = createStreamlinedStatsDisplay();
        statisticsPanel.add(statsContainer);
        
        // Refresh the UI
        statisticsPanel.revalidate();
        statisticsPanel.repaint();
    }

    /**
     * Public method to refresh the entire API panel
     * Can be called from outside to update the display
     */
    public void refresh() {
        updateStatusLabel();
        refreshStatistics();
        refreshSubmissions();
        refreshGroupConfigs();
    }

    /**
     * Cleanup method to stop the timer when the panel is no longer needed
     */
    public void cleanup() {
        if (statusUpdateTimer != null && statusUpdateTimer.isRunning()) {
            statusUpdateTimer.stop();
        }
    }

    /**
     * Check if there are any submissions that need status checking
     */
    private boolean hasPendingOrFailedSubmissions() {
        if (submissionManager == null) {
            return false;
        }
        
        List<ValidSubmission> validSubmissions = submissionManager.getValidSubmissions();
        if (validSubmissions == null || validSubmissions.isEmpty()) {
            return false;
        }
        
        // Check if any submissions are in states that need polling
        for (ValidSubmission submission : validSubmissions) {
            String status = submission.getStatus();
            if (status != null && (
                "pending".equalsIgnoreCase(status) || 
                "sent".equalsIgnoreCase(status) || 
                "retrying".equalsIgnoreCase(status) ||
                "queued".equalsIgnoreCase(status)
            )) {
                return true;
            }
        }
        
        return false;
    }

    /**
     * Refreshes the group configurations display
     */
    public void refreshGroupConfigs() {
        if (groupsContainerPanel == null || groupsScrollPane == null) {
            return;
        }

        // Save current scroll position
        int scrollPosition = groupsScrollPane.getVerticalScrollBar().getValue();

        // Rebuild all group config panels
        buildGroupConfigPanels(groupsContainerPanel);
        groupsContainerPanel.revalidate();
        groupsContainerPanel.repaint();

        // Restore scroll position after a brief delay to allow layout
        SwingUtilities.invokeLater(() -> {
            groupsScrollPane.getVerticalScrollBar().setValue(scrollPosition);
        });

        // Also update the parent panel
        if (groupConfigPanel != null) {
            groupConfigPanel.revalidate();
            groupConfigPanel.repaint();
        }
    }
}

package io.droptracker.ui.pages;

import io.droptracker.DropTrackerConfig;
import io.droptracker.api.DropTrackerApi;
import io.droptracker.models.api.GroupSearchResult;
import io.droptracker.models.api.TopGroupResult;
import io.droptracker.models.submissions.RecentSubmission;
import io.droptracker.ui.DropTrackerPanel;
import io.droptracker.ui.components.LeaderboardComponents;
import io.droptracker.ui.components.PanelElements;
import net.runelite.api.Client;
import net.runelite.client.game.ItemManager;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.FontManager;
import net.runelite.client.ui.PluginPanel;
import net.runelite.client.util.LinkBrowser;

import javax.imageio.ImageIO;
import javax.swing.*;
import javax.swing.border.EmptyBorder;
import java.awt.*;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.awt.image.BufferedImage;
import java.io.IOException;
import java.net.URL;
import java.util.List;
import java.util.concurrent.CompletableFuture;

public class GroupPanel {
    private final Client client;
    private final DropTrackerConfig config;
    private final DropTrackerPanel panel;
    private final DropTrackerApi api;
    private final ItemManager itemManager;

    private int currentGroupId = 2; // Track group ID instead of URL

    // UI components that we need to update
    private JPanel contentPanel;
    private JTextField searchField;

    // Add field for tracking leaderboard placeholder
    private JPanel leaderboardPlaceholder;

    public GroupPanel(Client client, DropTrackerConfig config, DropTrackerApi api, ItemManager itemManager, DropTrackerPanel panel) {
        this.client = client;
        this.config = config;
        this.api = api;
        this.itemManager = itemManager;
        this.panel = panel;
    }

    public JPanel create() {
        var mainPanel = new JPanel();
        mainPanel.setLayout(new BoxLayout(mainPanel, BoxLayout.Y_AXIS));
        mainPanel.setBackground(ColorScheme.DARK_GRAY_COLOR);

        // Header section with title and search using LeaderboardComponents
        LeaderboardComponents.HeaderResult headerResult = LeaderboardComponents.createHeaderPanel(
                "DropTracker - Groups",
                "Search for a group",
                () -> performGroupSearch("")
        );
        searchField = headerResult.searchField;

        // Content panel that will change based on state - fix alignment
        contentPanel = new JPanel();
        contentPanel.setLayout(new BoxLayout(contentPanel, BoxLayout.Y_AXIS));
        contentPanel.setBackground(ColorScheme.DARK_GRAY_COLOR);
        contentPanel.setAlignmentX(Component.LEFT_ALIGNMENT);

        // Show default state
        showDefaultState();

        // Add components to main panel - match PlayerStatsPanel structure
        mainPanel.add(headerResult.panel);
        mainPanel.add(Box.createRigidArea(new Dimension(0, 10)));
        mainPanel.add(contentPanel);
        mainPanel.add(Box.createVerticalGlue());

        return mainPanel;
    }


    private void showDefaultState() {
        contentPanel.removeAll();

        // Create center panel for the button
        JPanel defaultPanel = new JPanel();
        defaultPanel.setLayout(new BoxLayout(defaultPanel, BoxLayout.Y_AXIS));
        defaultPanel.setBackground(ColorScheme.DARK_GRAY_COLOR);
        defaultPanel.setAlignmentX(Component.CENTER_ALIGNMENT);

        // Instructions text
        JLabel instructionLabel = new JLabel("Search for a group by name above");
        instructionLabel.setFont(FontManager.getRunescapeFont());
        instructionLabel.setForeground(Color.LIGHT_GRAY);
        instructionLabel.setAlignmentX(Component.CENTER_ALIGNMENT);
        instructionLabel.setHorizontalAlignment(JLabel.CENTER);


        JButton createGroupButton = PanelElements.createExternalLinkButton(" Create a Group", "Click to visit the group creation documentation", false, this::openCreateGroupPage);

        JButton groupPageButton = PanelElements.createExternalLinkButton("View All Groups", "Click to visit the group page", true, this::openGroupPage);


        // Panel for first button - centered horizontally
        JPanel createButtonPanel = new JPanel(new FlowLayout(FlowLayout.CENTER, 0, 0));
        createButtonPanel.setBackground(ColorScheme.DARK_GRAY_COLOR);
        createButtonPanel.setAlignmentX(Component.CENTER_ALIGNMENT);
        createButtonPanel.setMaximumSize(new Dimension(Integer.MAX_VALUE, 30));
        createButtonPanel.setPreferredSize(new Dimension(PluginPanel.PANEL_WIDTH, 30));
        createButtonPanel.add(createGroupButton);

        // Panel for second button - centered horizontally
        JPanel groupButtonPanel = new JPanel(new FlowLayout(FlowLayout.CENTER, 0, 0));
        groupButtonPanel.setBackground(ColorScheme.DARK_GRAY_COLOR);
        groupButtonPanel.setAlignmentX(Component.CENTER_ALIGNMENT);
        groupButtonPanel.setMaximumSize(new Dimension(Integer.MAX_VALUE, 30));
        groupButtonPanel.setPreferredSize(new Dimension(PluginPanel.PANEL_WIDTH, 30));
        groupButtonPanel.add(groupPageButton);

        defaultPanel.add(instructionLabel);
        defaultPanel.add(Box.createRigidArea(new Dimension(0, 5)));

        if (config.useApi()) {
            // Create placeholder for leaderboard using LeaderboardComponents
            leaderboardPlaceholder = LeaderboardComponents.createLoadingPlaceholder("Loading top groups...");
            defaultPanel.add(leaderboardPlaceholder);
            defaultPanel.add(Box.createRigidArea(new Dimension(0, 10)));

            // Start loading data
            obtainLeaderboardData();
        }

        defaultPanel.add(createButtonPanel);
        defaultPanel.add(Box.createRigidArea(new Dimension(0, 5)));
        defaultPanel.add(groupButtonPanel);
        defaultPanel.add(Box.createVerticalGlue());

        contentPanel.add(defaultPanel);
        contentPanel.revalidate();
        contentPanel.repaint();
    }

    private JPanel showLeaderboard(TopGroupResult leaderboardData) {
        return LeaderboardComponents.createLeaderboardTable(
                "Top Groups",
                "Name",
                leaderboardData != null ? leaderboardData.getGroups() : null,
                new LeaderboardComponents.LeaderboardItemRenderer<TopGroupResult.TopGroup>() {
                    @Override
                    public String getName(TopGroupResult.TopGroup group) {
                        return group.getGroupName() != null && !group.getGroupName().trim().isEmpty()
                                ? group.getGroupName()
                                : "Unknown Group";
                    }

                    @Override
                    public String getLootValue(TopGroupResult.TopGroup group) {
                        String loot = group.getTotalLoot();
                        return (loot != null && !loot.trim().isEmpty()) ? loot : "0 GP";
                    }

                    @Override
                    public Integer getRank(TopGroupResult.TopGroup group) {
                        return group.getRank();
                    }

                    @Override
                    public void onItemClick(TopGroupResult.TopGroup group) {
                        // Search for this group when clicked
                        CompletableFuture.supplyAsync(() -> {
                            try {
                                showLoadingState();
                                GroupSearchResult groupResult = api.searchGroup(group.getGroupName());
                                if (groupResult != null) {
                                    currentGroupId = groupResult.getGroupDropTrackerId();
                                    PanelElements.loadLootboardForGroup(currentGroupId);
                                    showGroupDetails(groupResult);
                                }
                                return null;
                            } catch (Exception ex) {
                                return null;
                            }
                        });
                    }
                }
        );
    }

    private void obtainLeaderboardData() {
        LeaderboardComponents.loadLeaderboardAsync(
                leaderboardPlaceholder,
                () -> {
                    try {
                        return api.getTopGroups();
                    } catch (Exception e) {
                        return null;
                    }
                },
                this::showLeaderboard
        );
    }

    public void performGroupSearch(String directQuery) {
        String searchQuery;
        if (directQuery.equalsIgnoreCase("")) {
            searchQuery = searchField.getText().trim();
        } else {
            searchQuery = directQuery;
        }

        if (searchQuery.isEmpty()) {
            JOptionPane.showMessageDialog(contentPanel, "Please enter a group name to search for.");
            return;
        }


        // Show loading message
        showLoadingState();

        // Perform search in background
        CompletableFuture.supplyAsync(() -> {
            try {
                GroupSearchResult groupResult = api.searchGroup(searchQuery);
                return groupResult;
            } catch (Exception e) {
                return null;
            }
        }).thenAccept(groupResult -> {
            SwingUtilities.invokeLater(() -> {
                if (groupResult != null) {
                    showGroupDetails(groupResult);
                    // Load the lootboard image when group is found
                    if (groupResult.getGroupDropTrackerId() != null) {
                        currentGroupId = groupResult.getGroupDropTrackerId();
                        PanelElements.loadLootboardForGroup(currentGroupId);
                    }
                    PanelElements.cachedGroupName = groupResult.getGroupName();
                } else {
                    // Fallback to demo data for testing
                    if (searchQuery.equalsIgnoreCase("test") || searchQuery.equalsIgnoreCase("demo")) {
                        showGroupDetails(createDemoGroupResult());
                    } else {
                        showSearchError("Group '" + searchQuery + "' not found. API search failed.");
                    }
                }
            });
        });
    }

    private void showLoadingState() {
        contentPanel.removeAll();
        JLabel loadingLabel = new JLabel("Loading...");
        loadingLabel.setFont(FontManager.getRunescapeFont());
        loadingLabel.setForeground(Color.LIGHT_GRAY);
        loadingLabel.setHorizontalAlignment(JLabel.CENTER);
        contentPanel.add(loadingLabel);
        contentPanel.revalidate();
        contentPanel.repaint();
    }

    private void showSearchError(String message) {
        contentPanel.removeAll();

        JPanel errorPanel = LeaderboardComponents.createErrorPanel(message, () -> {
            searchField.setText("");
            showDefaultState();
        });

        contentPanel.add(errorPanel);
        contentPanel.revalidate();
        contentPanel.repaint();
    }

    private GroupSearchResult createDemoGroupResult() {
        // Create demo data for testing
        GroupSearchResult demo = new GroupSearchResult();
        demo.setGroupName("Demo Group");
        demo.setGroupDescription("This is a demo group that shows how the group panel works. You can see member statistics, lootboards, and other group information here.");
        //demo.setGroupDropTrackerId(2);
        demo.setGroupDropTrackerId(7);
        currentGroupId = 7;

        // Create demo stats
        GroupSearchResult.GroupStats stats = new GroupSearchResult.GroupStats();
        stats.setTotalMembers(5);
        stats.setGlobalRank("127");
        stats.setMonthlyLoot("15.2M"); // 15.2M GP
        demo.setGroupStats(stats);
        demo.setGroupTopPlayer("DemoPlayer");

        return demo;
    }

    private void showGroupDetails(GroupSearchResult groupResult) {
        contentPanel.removeAll();

        // Match PlayerStatsPanel structure exactly - no custom borders
        JPanel groupInfoPanel = new JPanel();
        groupInfoPanel.setLayout(new BoxLayout(groupInfoPanel, BoxLayout.Y_AXIS));
        groupInfoPanel.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        groupInfoPanel.setBorder(new EmptyBorder(10, 10, 10, 10)); // Same as playerInfoPanel

        // Group header panel - exactly like playerHeaderPanel with clear button
        JPanel groupHeaderPanel = new JPanel(new BorderLayout(10, 0));
        groupHeaderPanel.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        groupHeaderPanel.setMaximumSize(new Dimension(PluginPanel.PANEL_WIDTH - 40, 60));
        groupHeaderPanel.setPreferredSize(new Dimension(PluginPanel.PANEL_WIDTH - 40, 60));
        groupHeaderPanel.setAlignmentX(Component.LEFT_ALIGNMENT);

        // Group icon
        BufferedImage placeholderImg = new BufferedImage(50, 50, BufferedImage.TYPE_INT_ARGB);
        JLabel groupIcon = new JLabel(new ImageIcon(placeholderImg));
        groupIcon.setBackground(ColorScheme.MEDIUM_GRAY_COLOR);
        groupIcon.setPreferredSize(new Dimension(50, 50));
        groupIcon.setMaximumSize(new Dimension(50, 50));
        groupIcon.setMinimumSize(new Dimension(50, 50));
        loadGroupIcon(groupIcon, groupResult.getGroupImageUrl());

        // Group name and description
        JPanel groupNamePanel = new JPanel();
        groupNamePanel.setLayout(new BoxLayout(groupNamePanel, BoxLayout.Y_AXIS));
        groupNamePanel.setBackground(ColorScheme.DARKER_GRAY_COLOR);

        JLabel groupNameLabel = new JLabel(groupResult.getGroupName());
        groupNameLabel.setFont(FontManager.getRunescapeBoldFont());
        groupNameLabel.setForeground(Color.WHITE);
        groupNameLabel.setAlignmentX(Component.LEFT_ALIGNMENT);

        JLabel groupDescLabel = new JLabel("<html>" + groupResult.getGroupDescription() + "</html>");
        groupDescLabel.setFont(FontManager.getRunescapeSmallFont());
        groupDescLabel.setForeground(Color.LIGHT_GRAY);
        groupDescLabel.setAlignmentX(Component.LEFT_ALIGNMENT);

        groupNamePanel.add(groupNameLabel);
        groupNamePanel.add(groupDescLabel);

        // Clear button for closing the search result
        JButton clearButton = LeaderboardComponents.createClearButton(() -> {
            searchField.setText("");
            showDefaultState();
        });

        groupHeaderPanel.add(groupIcon, BorderLayout.WEST);
        groupHeaderPanel.add(groupNamePanel, BorderLayout.CENTER);
        groupHeaderPanel.add(clearButton, BorderLayout.EAST);

        // Stats panel - exactly like playerStatsPanel
        JPanel statsPanel = new JPanel(new GridLayout(2, 2, 5, 5));
        statsPanel.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        statsPanel.setBorder(new EmptyBorder(10, 0, 10, 0)); // Same as playerStatsPanel
        statsPanel.setMaximumSize(new Dimension(PluginPanel.PANEL_WIDTH, 100));
        statsPanel.setPreferredSize(new Dimension(PluginPanel.PANEL_WIDTH - 40, 100));
        statsPanel.setAlignmentX(Component.LEFT_ALIGNMENT);

        JPanel membersBox = PanelElements.createStatBox("Members", String.valueOf(groupResult.getGroupStats().getTotalMembers()));
        JPanel rankBox = PanelElements.createStatBox("Global Rank", "#" + groupResult.getGroupStats().getGlobalRank());
        JPanel lootBox = PanelElements.createStatBox("Monthly Loot", groupResult.getGroupStats().getMonthlyLoot() + " GP");
        JPanel topPlayerBox = PanelElements.createStatBox("Top Player", groupResult.getGroupTopPlayer());
        topPlayerBox.setCursor(Cursor.getPredefinedCursor(Cursor.HAND_CURSOR));
        topPlayerBox.addMouseListener(new MouseAdapter() {
            @Override
            public void mouseClicked(MouseEvent e) {
                panel.selectPanel("players");
                String topPlayer = groupResult.getGroupTopPlayer().split("\\(")[0].trim();
                panel.updatePlayerPanel(topPlayer);
            }
        });

        statsPanel.add(membersBox);
        statsPanel.add(rankBox);
        statsPanel.add(lootBox);
        statsPanel.add(topPlayerBox);

        // Action buttons - exactly like actionPanel
        JPanel actionPanel = new JPanel();
        actionPanel.setLayout(new FlowLayout(FlowLayout.CENTER, 10, 0));
        actionPanel.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        actionPanel.setMaximumSize(new Dimension(PluginPanel.PANEL_WIDTH - 40, 40));
        actionPanel.setPreferredSize(new Dimension(PluginPanel.PANEL_WIDTH - 40, 40));
        actionPanel.setAlignmentX(Component.LEFT_ALIGNMENT);

        if (groupResult.getPublicDiscordLink() != null && !groupResult.getPublicDiscordLink().isEmpty()) {
            JButton joinButton = new JButton("Discord");
            joinButton.setMargin(new Insets(0, 5, 0, 5));
            joinButton.addActionListener(e -> LinkBrowser.browse(groupResult.getPublicDiscordLink()));
            actionPanel.add(joinButton);
        }

        JButton viewLootboardButton = PanelElements.createLootboardButton("View Lootboard", "Click to view the lootboard", () -> PanelElements.showLootboardForGroup(client, currentGroupId));
        actionPanel.add(viewLootboardButton);

        // Add components exactly like PlayerStatsPanel
        groupInfoPanel.add(groupHeaderPanel);
        groupInfoPanel.add(Box.createRigidArea(new Dimension(0, 10)));
        groupInfoPanel.add(statsPanel);
        groupInfoPanel.add(Box.createRigidArea(new Dimension(0, 10)));
        // Get recent submission data to draw
        List<RecentSubmission> recentSubmissions = groupResult.getGroupRecentSubmissions();
        if (recentSubmissions != null && !recentSubmissions.isEmpty()) {
            groupInfoPanel.add(PanelElements.createRecentSubmissionPanel(recentSubmissions, itemManager, client, true));
        } else {
            // Create a placeholder panel that matches the exact dimensions of createRecentSubmissionPanel
            JPanel noSubmissionsContainer = new JPanel();
            noSubmissionsContainer.setLayout(new BoxLayout(noSubmissionsContainer, BoxLayout.Y_AXIS));
            noSubmissionsContainer.setBackground(ColorScheme.DARKER_GRAY_COLOR);
            noSubmissionsContainer.setBorder(new EmptyBorder(10, 0, 10, 0));
            noSubmissionsContainer.setPreferredSize(new Dimension(PluginPanel.PANEL_WIDTH - 40, 120)); // Match original
            noSubmissionsContainer.setMaximumSize(new Dimension(PluginPanel.PANEL_WIDTH - 40, 120));
            noSubmissionsContainer.setAlignmentX(Component.LEFT_ALIGNMENT);

            // Title panel to match original structure
            JPanel titlePanel = new JPanel(new FlowLayout(FlowLayout.CENTER, 0, 0));
            titlePanel.setBackground(ColorScheme.DARKER_GRAY_COLOR);
            titlePanel.setMaximumSize(new Dimension(PluginPanel.PANEL_WIDTH - 40, 20));
            titlePanel.setPreferredSize(new Dimension(PluginPanel.PANEL_WIDTH - 40, 20));

            JLabel title = new JLabel("Recent Submissions");
            title.setFont(FontManager.getRunescapeSmallFont());
            title.setForeground(Color.WHITE);
            titlePanel.add(title);

            // Content panel to match original structure
            JPanel contentWrapper = new JPanel(new FlowLayout(FlowLayout.CENTER, 0, 0));
            contentWrapper.setBackground(ColorScheme.DARKER_GRAY_COLOR);
            contentWrapper.setPreferredSize(new Dimension(PluginPanel.PANEL_WIDTH - 40, 80));
            contentWrapper.setMaximumSize(new Dimension(PluginPanel.PANEL_WIDTH - 40, 80));

            JLabel noSubmissionsLabel = new JLabel("No recent submissions available");
            noSubmissionsLabel.setFont(FontManager.getRunescapeSmallFont());
            noSubmissionsLabel.setForeground(Color.LIGHT_GRAY);
            noSubmissionsLabel.setHorizontalAlignment(JLabel.CENTER);
            contentWrapper.add(noSubmissionsLabel);

            // Assemble the container exactly like the original
            noSubmissionsContainer.add(titlePanel);
            noSubmissionsContainer.add(Box.createRigidArea(new Dimension(0, 5))); // Match original spacing
            noSubmissionsContainer.add(contentWrapper);

            groupInfoPanel.add(noSubmissionsContainer);
        }
        groupInfoPanel.add(Box.createRigidArea(new Dimension(0, 10)));
        groupInfoPanel.add(actionPanel);

        contentPanel.add(groupInfoPanel);
        contentPanel.revalidate();
        contentPanel.repaint();
    }

    private void openGroupPage() {
        try {
            LinkBrowser.browse("https://www.droptracker.io/groups");
        } catch (Exception e) {
            // Fallback: copy URL to clipboard or show message
            JOptionPane.showMessageDialog(contentPanel,
                    "Could not open browser. Please visit:\nhttps://www.droptracker.io/groups",
                    "Group Page",
                    JOptionPane.INFORMATION_MESSAGE);
        }
    }

    private void openCreateGroupPage() {
        try {
            LinkBrowser.browse("https://www.droptracker.io/wiki/create-group");
        } catch (Exception e) {
            // Fallback: copy URL to clipboard or show message
            JOptionPane.showMessageDialog(contentPanel,
                    "Could not open browser. Please visit:\nhttps://droptracker.io/wiki/create-group",
                    "Create Group Guide",
                    JOptionPane.INFORMATION_MESSAGE);
        }
    }

    /**
     * Downloads the group icon from the provided URL, scales it to 5050, then swaps it into the given label.
     * This runs off the EDT to avoid blocking the UI.
     */
    private void loadGroupIcon(JLabel iconLabel, String inputString) {
        if (inputString == null || inputString.trim().isEmpty()) {
            return; // nothing to load
        }

        // we can't load gifs in swing panels natively, so we swap for a png alternative hoping it exists
        String urlString = inputString.replace(".gif", ".png");

        // Validate URL format
        try {
            new URL(urlString); // This will throw if URL is malformed
        } catch (Exception e) {
            return;
        }

        CompletableFuture.supplyAsync(() -> {
            try {
                BufferedImage img = ImageIO.read(new URL(urlString));
                if (img == null) {
                    return null;
                }
                Image scaled = img.getScaledInstance(50, 50, Image.SCALE_SMOOTH);
                return new ImageIcon(scaled);
            } catch (IOException e) {
                // Try the original URL if the .png replacement failed
                if (urlString.endsWith(".png") && !inputString.endsWith(".png")) {
                    try {
                        BufferedImage img = ImageIO.read(new URL(inputString));
                        if (img != null) {
                            Image scaled = img.getScaledInstance(50, 50, Image.SCALE_SMOOTH);
                            return new ImageIcon(scaled);
                        }
                    } catch (IOException ex) {
                        return null;
                    }
                }
                return null;
            } catch (Exception e) {
                return null;
            }
        }).thenAccept(icon -> {
            if (icon != null) {
                SwingUtilities.invokeLater(() -> iconLabel.setIcon(icon));
            }
        });
    }

}

package io.droptracker.ui.components;

import io.droptracker.DropTrackerConfig;
import io.droptracker.DropTrackerPlugin;
import io.droptracker.api.DropTrackerApi;
import io.droptracker.models.submissions.RecentSubmission;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.client.game.ItemManager;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.FontManager;
import net.runelite.client.ui.PluginPanel;
import net.runelite.client.util.AsyncBufferedImage;
import net.runelite.client.util.ImageUtil;

import javax.annotation.Nullable;
import javax.imageio.ImageIO;
import javax.swing.*;
import javax.swing.border.EmptyBorder;
import javax.swing.border.StrokeBorder;
import java.awt.*;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.awt.image.BufferedImage;
import java.io.IOException;
import java.net.URL;
import java.util.List;
import java.util.concurrent.CompletableFuture;

@Slf4j
public class PanelElements {


    private static final ImageIcon COLLAPSED_ICON;
    private static final ImageIcon EXPANDED_ICON;
    private static final ImageIcon BOARD_ICON;
    private static final ImageIcon EXTERNAL_LINK_ICON;
    public static @Nullable BufferedImage cachedLootboardImage;
    public static String cachedGroupName = "All Players";
    private static String currentImageUrl = "https://www.droptracker.io/img/clans/2/lb/lootboard.png";
    private static Integer cachedGroupId = null; // Track which group's lootboard is currently cached

    static {
        Image collapsedImg = ImageUtil.loadImageResource(DropTrackerPlugin.class, "util/collapse.png");
        Image expandedImg = ImageUtil.loadImageResource(DropTrackerPlugin.class, "util/expand.png");
        Image boardIcon = ImageUtil.loadImageResource(DropTrackerPlugin.class, "util/board.png");
        Image extLinkIcon = ImageUtil.loadImageResource(DropTrackerPlugin.class, "util/external-link.png");
        Image boardResized = boardIcon.getScaledInstance(16, 16, Image.SCALE_SMOOTH);
        Image extRecolored = ImageUtil.recolorImage(extLinkIcon, ColorScheme.LIGHT_GRAY_COLOR);
        Image extLinkResized = extRecolored.getScaledInstance(16, 16, Image.SCALE_SMOOTH);

        Image collapsedResized = collapsedImg.getScaledInstance(16, 16, Image.SCALE_SMOOTH);
        Image expandedResized = expandedImg.getScaledInstance(16, 16, Image.SCALE_SMOOTH);
        Image collapsedRecolored = ImageUtil.recolorImage(collapsedResized, ColorScheme.LIGHT_GRAY_COLOR);
        Image expandedRecolored = ImageUtil.recolorImage(expandedResized, ColorScheme.LIGHT_GRAY_COLOR);
        COLLAPSED_ICON = new ImageIcon(collapsedRecolored);
        EXPANDED_ICON = new ImageIcon(expandedRecolored);
        BOARD_ICON = new ImageIcon(boardResized);
        EXTERNAL_LINK_ICON = new ImageIcon(extLinkResized);

        // Initialize with default global group lootboard (group 2)
        loadLootboardForGroup(2);
    }

    /**
     * Get the collapsed icon for collapsible panels
     *
     * @return ImageIcon for collapsed state
     */
    public static ImageIcon getCollapsedIcon() {
        return COLLAPSED_ICON;
    }

    /**
     * Get the expanded icon for collapsible panels
     *
     * @return ImageIcon for expanded state
     */
    public static ImageIcon getExpandedIcon() {
        return EXPANDED_ICON;
    }

    // Method to load lootboard for a specific group ID
    public static void loadLootboardForGroup(int groupId) {
        // Check if we already have this group cached
        if (cachedGroupId != null && cachedGroupId == groupId && cachedLootboardImage != null) {
            return;
        }

        String imageUrl = "https://www.droptracker.io/img/clans/" + groupId + "/lb/lootboard.png";

        CompletableFuture.supplyAsync(() -> {
            try {
                URL url = new URL(imageUrl);
                return ImageIO.read(url);
            } catch (IOException e) {
                return null;
            }
        }).thenAccept(image -> {
            SwingUtilities.invokeLater(() -> {
                cachedLootboardImage = image;
                cachedGroupId = groupId;
                currentImageUrl = imageUrl;
            });
        });
    }

    // Method to load lootboard for a specific group ID with callback
    public static void loadLootboardForGroup(int groupId, Runnable onComplete) {
        // Check if we already have this group cached
        if (cachedGroupId != null && cachedGroupId == groupId && cachedLootboardImage != null) {
            if (onComplete != null) {
                SwingUtilities.invokeLater(onComplete);
            }
            return;
        }

        String imageUrl = "https://www.droptracker.io/img/clans/" + groupId + "/lb/lootboard.png";

        CompletableFuture.supplyAsync(() -> {
            try {
                URL url = new URL(imageUrl);
                return ImageIO.read(url);
            } catch (IOException e) {
                return null;
            }
        }).thenAccept(image -> {
            SwingUtilities.invokeLater(() -> {
                cachedLootboardImage = image;
                cachedGroupId = groupId;
                currentImageUrl = imageUrl;
                // Call the completion callback
                if (onComplete != null) {
                    onComplete.run();
                }
            });
        });
    }

    /**
     * Creates a styled container for submission icons with border and background,
     * with optional enter/exit effects (if an image is provided for the submission)
     */
    public static JLabel createStyledIconContainer(boolean withEffects) {
        JLabel container = new JLabel();
        container.setVerticalAlignment(SwingConstants.CENTER);
        container.setHorizontalAlignment(SwingConstants.CENTER);
        container.setPreferredSize(new Dimension(32, 32));
        container.setMinimumSize(new Dimension(32, 32));
        container.setMaximumSize(new Dimension(32, 32));

        // Add styling with border and background
        container.setOpaque(true);
        container.setBackground(ColorScheme.DARK_GRAY_COLOR);
        container.setBorder(new StrokeBorder(new BasicStroke(1), ColorScheme.BORDER_COLOR));

        // Add hover effect
        if (withEffects) {
            container.addMouseListener(new MouseAdapter() {
                @Override
                public void mouseEntered(MouseEvent e) {
                    container.setBackground(ColorScheme.DARKER_GRAY_HOVER_COLOR);
                    container.setCursor(Cursor.getPredefinedCursor(Cursor.HAND_CURSOR));
                }

                @Override
                public void mouseExited(MouseEvent e) {
                    container.setBackground(ColorScheme.DARK_GRAY_COLOR);
                    container.setCursor(Cursor.getDefaultCursor());
                }
            });
        }

        return container;
    }

    // Method to show lootboard popup for a specific group ID
    public static void showLootboardForGroup(Client client, int groupId) {
        if (cachedGroupName == null) {
            cachedGroupName = "All Players";
        }
        final JFrame parentFrame = getParentFrame(client);
        JDialog imageDialog = new JDialog(parentFrame, cachedGroupName + " - Lootboard", false);
        imageDialog.setDefaultCloseOperation(JDialog.DISPOSE_ON_CLOSE);

        // Check if we already have the right group cached
        if (cachedLootboardImage != null && cachedGroupId != null && cachedGroupId == groupId) {
            displayImageInDialog(imageDialog, cachedLootboardImage, parentFrame);
            imageDialog.revalidate();
            imageDialog.repaint();
            imageDialog.setVisible(true);
            return;
        }

        // Show loading dialog first
        JLabel loadingLabel = new JLabel("Loading group " + groupId + " lootboard...");
        loadingLabel.setForeground(Color.WHITE);
        loadingLabel.setFont(FontManager.getRunescapeBoldFont());
        loadingLabel.setHorizontalAlignment(JLabel.CENTER);
        loadingLabel.setVerticalAlignment(JLabel.CENTER);
        loadingLabel.setPreferredSize(new Dimension(400, 300));
        loadingLabel.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        loadingLabel.setOpaque(true);

        // Add click to close
        addCloseListener(loadingLabel, imageDialog);

        imageDialog.add(loadingLabel);
        imageDialog.pack();
        imageDialog.setLocationRelativeTo(parentFrame);

        // Start loading BEFORE showing the dialog to avoid modality blocking
        loadLootboardForGroup(groupId, () -> {
            if (cachedLootboardImage != null) {
                imageDialog.getContentPane().removeAll();
                displayImageInDialog(imageDialog, cachedLootboardImage, parentFrame);
                imageDialog.revalidate();
                imageDialog.repaint();
            } else {
                loadingLabel.setText("Failed to load group " + groupId + " lootboard");
                loadingLabel.setForeground(Color.RED);
                imageDialog.revalidate();
                imageDialog.repaint();
            }
        });

        imageDialog.setVisible(true);
    }

    // Method to show submission image popup
    public static void showSubmissionImage(Client client, String submissionType, String submissionImageUrl, String tooltip) {
        final JFrame parentFrame = getParentFrame(client);
        String dialogTitle = getSubmissionDialogTitle(submissionType);
        JDialog imageDialog = new JDialog(parentFrame, dialogTitle, false);
        imageDialog.setDefaultCloseOperation(JDialog.DISPOSE_ON_CLOSE);

        // Show loading dialog first
        JLabel loadingLabel = new JLabel("Loading " + submissionType + " image...");
        loadingLabel.setForeground(Color.WHITE);
        loadingLabel.setFont(FontManager.getRunescapeBoldFont());
        loadingLabel.setHorizontalAlignment(JLabel.CENTER);
        loadingLabel.setVerticalAlignment(JLabel.CENTER);
        loadingLabel.setPreferredSize(new Dimension(400, 300));
        loadingLabel.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        loadingLabel.setOpaque(true);

        // Add click to close
        addCloseListener(loadingLabel, imageDialog);

        imageDialog.add(loadingLabel);
        imageDialog.pack();
        imageDialog.setLocationRelativeTo(parentFrame);

        // Load image from submission URL (similar to lootboard loading)
        loadUrlImage(submissionImageUrl, imageDialog, loadingLabel, parentFrame, tooltip);

        // Show the modal dialog
        imageDialog.setVisible(true);
    }

    private static String getSubmissionDialogTitle(String submissionType) {
        switch (submissionType.toLowerCase()) {
            case "drop":
                return "Drop Submission";
            case "clog":
                return "Collection Log Submission";
            case "pb":
                return "Personal Best Submission";
            default:
                return "Submission";
        }
    }


    private static void loadUrlImage(String imageUrl, JDialog imageDialog, JLabel loadingLabel, JFrame parentFrame, String tooltip) {
        if (imageUrl == null || imageUrl.isEmpty()) {
            loadingLabel.setText("No image URL available");
            loadingLabel.setForeground(Color.RED);
            return;
        }

        CompletableFuture.supplyAsync(() -> {
            try {
                URL url = new URL(imageUrl);
                return ImageIO.read(url);
            } catch (IOException e) {
                return null;
            }
        }).thenAccept(image -> {
            SwingUtilities.invokeLater(() -> {
                if (image != null) {
                    imageDialog.getContentPane().removeAll();
                    displayImageInDialog(imageDialog, image, parentFrame);
                    imageDialog.revalidate();
                    imageDialog.repaint();
                } else {
                    loadingLabel.setText("Failed to load image... (likely a bug on our end)");
                    loadingLabel.setForeground(Color.RED);
                    imageDialog.revalidate();
                    imageDialog.repaint();
                }
            });
        });
    }

    // Helper method to create a stat box with fixed size
    public static JPanel createStatBox(String label, String value) {
        JPanel box = new JPanel();
        box.setLayout(new BoxLayout(box, BoxLayout.Y_AXIS));
        box.setBackground(ColorScheme.MEDIUM_GRAY_COLOR);
        box.setBorder(new EmptyBorder(5, 5, 5, 5));

        JLabel valueLabel = new JLabel(value);
        valueLabel.setFont(FontManager.getRunescapeBoldFont());
        valueLabel.setForeground(Color.WHITE);
        valueLabel.setAlignmentX(Component.CENTER_ALIGNMENT);

        JLabel nameLabel = new JLabel(label);
        nameLabel.setFont(FontManager.getRunescapeSmallFont());
        nameLabel.setForeground(Color.LIGHT_GRAY);
        nameLabel.setAlignmentX(Component.CENTER_ALIGNMENT);

        box.add(valueLabel);
        box.add(nameLabel);

        return box;
    }

    public static JPanel getLatestWelcomeContent(DropTrackerApi api) {
        JPanel contentPanel = new JPanel();
        contentPanel.setLayout(new BorderLayout());
        contentPanel.setBackground(ColorScheme.DARKER_GRAY_COLOR);

        // Start with default welcome text
        JTextArea textArea = collapsibleSubText("Welcome to the DropTracker!");
        contentPanel.add(textArea, BorderLayout.CENTER);

        /* getLatestWelcomeString method contains a check for whether config enabled API connections */
        api.getLatestWelcomeString(welcomeText -> {
            // Update the text area with the loaded content
            textArea.setText(welcomeText != null ? welcomeText : "Welcome to the DropTracker!");
            textArea.revalidate();
            textArea.repaint();
        });
        

        return contentPanel;
    }

    public static JPanel getLatestUpdateContent(DropTrackerConfig config, DropTrackerApi api) {
        JPanel contentPanel = new JPanel();
        contentPanel.setLayout(new BorderLayout());
        contentPanel.setBackground(ColorScheme.DARKER_GRAY_COLOR);

        String defaultUpdateText = " Implemented support for tracking Personal Bests from a POH adventure log.\n\n" +
                " Added pet collection submissions when adventure logs are opened.\n\n" +
                " Fixed various personal best tracking bugs.\n\n" +
                " A new side panel & stats functionality";

        // Start with default or fallback text
        String initialText = (config != null && config.useApi()) ? "Loading updates..." : defaultUpdateText;
        JTextArea textArea = collapsibleSubText(initialText);
        contentPanel.add(textArea, BorderLayout.CENTER);

        /* getLatestUpdateString method contains a check for whether config enabled API connections */
        api.getLatestUpdateString(updateText -> {
            // Update the text area with the loaded content
            textArea.setText(updateText != null ? updateText : "No updates found.");
            textArea.revalidate();
            textArea.repaint();
        });
        

        return contentPanel;
    }

    public static JTextArea collapsibleSubText(String inputString) {
        JTextArea textArea = new JTextArea();
        textArea.setText(inputString);
        textArea.setWrapStyleWord(true);
        textArea.setLineWrap(true);
        textArea.setOpaque(false);
        textArea.setEditable(false);
        textArea.setFocusable(false);
        textArea.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        textArea.setForeground(Color.LIGHT_GRAY);
        Font textAreaFont = FontManager.getRunescapeSmallFont();
        textArea.setFont(textAreaFont);
        textArea.setBorder(new EmptyBorder(5, 5, 5, 5));

        return textArea;
    }

    public static JPanel createFeaturePanel(String title, String description) {
        // Create a panel with fixed dimensions
        JPanel panel = new JPanel();
        panel.setLayout(new BorderLayout());
        panel.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        panel.setBorder(new EmptyBorder(10, 10, 10, 10));

        // Fixed height for the entire panel
        Dimension panelSize = new Dimension(PluginPanel.PANEL_WIDTH, 90);
        panel.setPreferredSize(panelSize);
        panel.setMinimumSize(panelSize);
        panel.setMaximumSize(panelSize);

        JLabel titleLabel = new JLabel(title);
        titleLabel.setFont(FontManager.getRunescapeBoldFont());
        titleLabel.setForeground(Color.WHITE);

        JTextArea descArea = new JTextArea(description);
        descArea.setWrapStyleWord(true);
        descArea.setLineWrap(true);
        descArea.setOpaque(false);
        descArea.setEditable(false);
        descArea.setFocusable(false);
        descArea.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        descArea.setForeground(Color.LIGHT_GRAY);
        descArea.setFont(FontManager.getRunescapeSmallFont());
        descArea.setBorder(new EmptyBorder(5, 0, 0, 0));

        panel.add(titleLabel, BorderLayout.NORTH);
        panel.add(descArea, BorderLayout.CENTER);

        return panel;
    }


    public static JPanel createCollapsiblePanel(String title, JPanel content, boolean isUnderlined) {
        JPanel panel = new JPanel();
        panel.setLayout(new BoxLayout(panel, BoxLayout.Y_AXIS));
        panel.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        panel.setBorder(new EmptyBorder(10, 10, 10, 10));

        JPanel headerPanel = new JPanel(new BorderLayout());
        headerPanel.setBackground(ColorScheme.DARKER_GRAY_COLOR);

        // Create title with optional underline
        JLabel titleLabel;
        if (isUnderlined) {
            titleLabel = new JLabel("<html><u>" + title + "</u></html>");
        } else {
            titleLabel = new JLabel(title);
        }
        titleLabel.setFont(FontManager.getRunescapeBoldFont());
        titleLabel.setForeground(Color.WHITE);

        JLabel toggleIcon = new JLabel(EXPANDED_ICON);

        headerPanel.add(titleLabel, BorderLayout.WEST);
        headerPanel.add(toggleIcon, BorderLayout.EAST);

        // Create a final reference to the content for use in the listener
        final JPanel contentRef = content;
        final boolean[] isCollapsed = {false};

        // Add click listener for collapsing/expanding
        headerPanel.addMouseListener(new MouseAdapter() {
            @Override
            public void mouseClicked(MouseEvent e) {
                isCollapsed[0] = !isCollapsed[0];
                toggleIcon.setIcon(isCollapsed[0] ? COLLAPSED_ICON : EXPANDED_ICON);
                contentRef.setVisible(!isCollapsed[0]);

                // Force fixed height when collapsed
                if (isCollapsed[0]) {
                    panel.setPreferredSize(
                            new Dimension(PluginPanel.PANEL_WIDTH, headerPanel.getPreferredSize().height + 20));
                    panel.setMaximumSize(
                            new Dimension(PluginPanel.PANEL_WIDTH, headerPanel.getPreferredSize().height + 20));
                    panel.revalidate();
                    panel.repaint();
                } else {
                    panel.setPreferredSize(null);
                    panel.setMaximumSize(new Dimension(PluginPanel.PANEL_WIDTH, Integer.MAX_VALUE));
                    panel.revalidate();
                    panel.repaint();
                }
            }
        });

        panel.add(headerPanel);
        panel.add(getJSeparator(ColorScheme.LIGHT_GRAY_COLOR));
        panel.add(content);

        return panel;
    }

    private static JSeparator getJSeparator(Color color) {
        JSeparator sep = new JSeparator();
        sep.setBackground(color);
        sep.setForeground(color);
        return sep;
    }

    public static JFrame getParentFrame(Client client) {
        try {
            if (SwingUtilities.getWindowAncestor(client.getCanvas()) instanceof JFrame) {
                return (JFrame) SwingUtilities.getWindowAncestor(client.getCanvas());
            }
        } catch (Exception ignored) {
        }
        return null;
    }

    public static JButton createExternalLinkButton(String text, String tooltip, boolean withIcon, Runnable action) {
        JButton button = new JButton(text);
        if (withIcon) {
            button.setIcon(EXTERNAL_LINK_ICON);
        }
        button.setText(text);
        button.setToolTipText(tooltip);
        button.setFont(FontManager.getRunescapeSmallFont());
        button.setPreferredSize(new Dimension(150, 30));
        button.addActionListener(e -> action.run());
        return button;
    }

    public static JButton createLootboardButton(String text, String tooltip, Runnable action) {
        JButton button = new JButton(text);
        button.setIcon(BOARD_ICON);
        button.setText("<html>" + text + "&nbsp;&nbsp;<img src='https://www.droptracker.io/img/external-16px-g.png'></img></html>");
        button.setToolTipText(tooltip);
        button.addActionListener(e -> action.run());
        return button;
    }

    public static JPanel createRecentSubmissionPanel(List<RecentSubmission> recentSubmissions,
                                                     ItemManager itemManager, Client client, boolean forGroup) {

        // Main container with title and submissions
        JPanel container = new JPanel();
        container.setLayout(new BoxLayout(container, BoxLayout.Y_AXIS));
        container.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        container.setBorder(new EmptyBorder(10, 0, 10, 0));
        container.setPreferredSize(new Dimension(PluginPanel.PANEL_WIDTH - 40, 150)); // Increased from 120 to 150
        container.setMaximumSize(new Dimension(PluginPanel.PANEL_WIDTH - 40, 150));
        container.setAlignmentX(Component.LEFT_ALIGNMENT); // Keep consistent with parent

        // Title panel to ensure centering
        JPanel titlePanel = new JPanel();
        titlePanel.setLayout(new BoxLayout(titlePanel, BoxLayout.Y_AXIS)); // Changed to vertical layout
        titlePanel.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        titlePanel.setMaximumSize(new Dimension(PluginPanel.PANEL_WIDTH - 40, 50)); // Increased from 20 to 50
        titlePanel.setPreferredSize(new Dimension(PluginPanel.PANEL_WIDTH - 40, 50));

        JLabel title = new JLabel("Recent Submissions");
        title.setFont(FontManager.getRunescapeSmallFont());
        title.setForeground(Color.WHITE);
        title.setAlignmentX(Component.CENTER_ALIGNMENT); // Center the title

        // Create a text area that looks like a label but handles wrapping better
        JTextArea titleDesc = new JTextArea("Clicking an icon opens a screenshot, if available.");
        titleDesc.setForeground(Color.LIGHT_GRAY);
        titleDesc.setFont(FontManager.getRunescapeSmallFont());
        titleDesc.setBackground(titlePanel.getBackground());
        titleDesc.setEditable(false);
        titleDesc.setWrapStyleWord(true);
        titleDesc.setLineWrap(true);
        titleDesc.setBorder(null);
        titleDesc.setOpaque(false);
        titleDesc.setColumns(20);
        titleDesc.setAlignmentX(Component.CENTER_ALIGNMENT); // Center the description

        titlePanel.add(title);
        titlePanel.add(Box.createRigidArea(new Dimension(0, 3)));

        // Alternative: Single HTML label combining warning and text
        JLabel combinedLabel = new JLabel("<html><div style='text-align: center;'><font color='orange'></font> <font color='#C0C0C0'>Clicking an icon opens a screenshot, if available.</font></div></html>");
        combinedLabel.setFont(FontManager.getRunescapeSmallFont());
        combinedLabel.setHorizontalAlignment(SwingConstants.CENTER);
        combinedLabel.setAlignmentX(Component.CENTER_ALIGNMENT);

        titlePanel.add(combinedLabel);
        titlePanel.add(Box.createRigidArea(new Dimension(0, 8)));

        // Submissions panel - use FlowLayout wrapper to center the GridBagLayout
        JPanel submissionWrapper = new JPanel(new FlowLayout(FlowLayout.CENTER, 0, 0));
        submissionWrapper.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        submissionWrapper.setPreferredSize(new Dimension(PluginPanel.PANEL_WIDTH - 40, 80)); // Keep same
        submissionWrapper.setMaximumSize(new Dimension(PluginPanel.PANEL_WIDTH - 40, 80));

        JPanel panel = new JPanel();
        panel.setLayout(new GridBagLayout());
        panel.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        panel.setPreferredSize(new Dimension(PluginPanel.PANEL_WIDTH - 40, 80));

        submissionWrapper.add(updateValidSubmissionPanel(panel, recentSubmissions, itemManager, client, forGroup));

        // Add components to container
        container.add(titlePanel);
        container.add(Box.createRigidArea(new Dimension(0, 5))); // Small gap between title and submissions
        container.add(submissionWrapper);

        return container;
    }

    private static JPanel updateValidSubmissionPanel(JPanel panel, List<RecentSubmission> recentSubmissions, ItemManager itemManager, Client client, boolean forGroup) {
        panel.removeAll();

        // Debug logging

        GridBagConstraints c = new GridBagConstraints();
        c.fill = GridBagConstraints.NONE;
        c.anchor = GridBagConstraints.CENTER;
        c.weightx = 0.2; // Equal weight for 5 columns
        c.weighty = 0.5; // Equal weight for 2 rows
        c.gridx = 0;
        c.gridy = 0;
        c.insets = new Insets(1, 1, 1, 1); // Padding around each icon

        int successfullyAdded = 0;
        final int ITEMS_PER_ROW = 5;
        final int MAX_ITEMS = 10;

        // Add each submission icon to the panel (limit to 10 items)
        for (int i = 0; i < Math.min(recentSubmissions.size(), MAX_ITEMS); i++) {
            RecentSubmission submission = recentSubmissions.get(i);
            boolean effects = false;
            if (submission.getSubmissionImageUrl() != null && !submission.getSubmissionImageUrl().isEmpty()) {
                effects = true;
            }
            try {
                JLabel iconContainer = null;
                if (submission.getSubmissionType().equalsIgnoreCase("drop")) {
                    // Handle drops
                    Integer itemId = submission.getDropItemId();
                    Integer quantity = submission.getDropQuantity();

                    if (itemId != null && quantity != null && itemManager != null) {
                        final AsyncBufferedImage originalImage = itemManager.getImage(itemId, quantity, quantity > 1);
                        final float alpha = (quantity > 0 ? 1.0f : 0.5f);

                        // Create a scaled version of the image for initial display
                        BufferedImage scaledImage = new BufferedImage(28, 28, BufferedImage.TYPE_INT_ARGB);
                        BufferedImage opaque = ImageUtil.alphaOffset(scaledImage, alpha);
                        final JLabel dropContainer = PanelElements.createStyledIconContainer(effects);
                        dropContainer.setToolTipText(buildSubmissionTooltip(submission, forGroup));
                        dropContainer.setIcon(new ImageIcon(opaque));
                        iconContainer = dropContainer;

                        originalImage.onLoaded(() -> {
                            // Scale the loaded image to 16x16
                            Image scaled = originalImage.getScaledInstance(28, 28, Image.SCALE_SMOOTH);
                            BufferedImage scaledBuffered = new BufferedImage(28, 28, BufferedImage.TYPE_INT_ARGB);
                            Graphics g = scaledBuffered.getGraphics();
                            g.drawImage(scaled, 0, 0, null);
                            g.dispose(); // Clean up graphics resources

                            BufferedImage finalImage = ImageUtil.alphaOffset(scaledBuffered, alpha);
                            dropContainer.setIcon(new ImageIcon(finalImage));
                            dropContainer.setToolTipText(buildSubmissionTooltip(submission, forGroup));
                            dropContainer.revalidate();
                            dropContainer.repaint();
                        });
                    }
                } else if (submission.getSubmissionType().equalsIgnoreCase("clog")) {
                    // Handle collection log items
                    Integer itemId = submission.getClogItemId();

                    if (itemId != null && itemManager != null) {
                        final AsyncBufferedImage originalImage = itemManager.getImage(itemId, 1, false);
                        final float alpha = 1.0f;

                        // Create a scaled version of the image for initial display
                        BufferedImage scaledImage = new BufferedImage(28, 28, BufferedImage.TYPE_INT_ARGB);
                        BufferedImage opaque = ImageUtil.alphaOffset(scaledImage, alpha);

                        final JLabel clogContainer = PanelElements.createStyledIconContainer(effects);
                        clogContainer.setToolTipText(buildSubmissionTooltip(submission, forGroup));
                        clogContainer.setIcon(new ImageIcon(opaque));
                        iconContainer = clogContainer;

                        originalImage.onLoaded(() -> {
                            // Scale the loaded image to 16x16
                            Image scaled = originalImage.getScaledInstance(28, 28, Image.SCALE_SMOOTH);
                            BufferedImage scaledBuffered = new BufferedImage(28, 28, BufferedImage.TYPE_INT_ARGB);
                            Graphics g = scaledBuffered.getGraphics();
                            g.drawImage(scaled, 0, 0, null);
                            g.dispose(); // Clean up graphics resources

                            BufferedImage finalImage = ImageUtil.alphaOffset(scaledBuffered, alpha);
                            clogContainer.setIcon(new ImageIcon(finalImage));
                            clogContainer.revalidate();
                            clogContainer.repaint();
                        });
                    }
                } else if (submission.getSubmissionType().equalsIgnoreCase("pb")) {
                    // Handle personal best submissions with image URL
                    String imageUrl = submission.getImageUrl();

                    if (imageUrl != null && !imageUrl.isEmpty()) {
                        final JLabel pbContainer = PanelElements.createStyledIconContainer(effects);
                        pbContainer.setToolTipText(buildSubmissionTooltip(submission, forGroup));
                        pbContainer.setText("PB");
                        pbContainer.setFont(FontManager.getRunescapeSmallFont());
                        pbContainer.setForeground(Color.WHITE);
                        iconContainer = pbContainer;

                        // Load image asynchronously
                        CompletableFuture.supplyAsync(() -> {
                            try {
                                BufferedImage image = ImageIO.read(new URL(imageUrl));
                                if (image != null) {
                                    Image scaled = image.getScaledInstance(16, 16, Image.SCALE_SMOOTH);
                                    return new ImageIcon(scaled);
                                }
                            } catch (IOException ignored) {
                            }
                            return null;
                        }).thenAccept(imageIcon -> {
                            if (imageIcon != null) {
                                SwingUtilities.invokeLater(() -> {
                                    pbContainer.setText(""); // Remove text
                                    pbContainer.setIcon(imageIcon);
                                    pbContainer.revalidate();
                                    pbContainer.repaint();
                                });
                            }
                        });
                    }
                }


                // Add the icon container if it was created successfully
                if (iconContainer != null) {
                    if (submission.getSubmissionImageUrl() != null && !submission.getSubmissionImageUrl().isEmpty()) {
                        // Capture submission data for the click listener
                        final String submissionTypeForListener = submission.getSubmissionType();
                        final String submissionImageUrlForListener = submission.getSubmissionImageUrl();
                        final String tooltipForListener = buildSubmissionTooltip(submission, forGroup);
                        // Add hover effect and click listener
                        iconContainer.addMouseListener(new MouseAdapter() {
                            @Override
                            public void mouseClicked(MouseEvent e) {
                                PanelElements.showSubmissionImage(client, submissionTypeForListener, submissionImageUrlForListener, tooltipForListener);
                            }
                        });
                    }

                    panel.add(iconContainer, c);
                    successfullyAdded++;

                    // Move to next position
                    c.gridx++;
                    if (c.gridx >= ITEMS_PER_ROW) {
                        c.gridx = 0;
                        c.gridy++;
                    }
                }
            } catch (Exception e) {
                log.warn("Failed updating submission panel", e);
            }
        }


        // If no icons were added, show a message
        if (successfullyAdded == 0) {
            JLabel debugLabel = new JLabel("No recent submissions to display");
            debugLabel.setForeground(Color.LIGHT_GRAY);
            debugLabel.setFont(FontManager.getRunescapeSmallFont());
            c.gridx = 0;
            c.gridy = 0;
            c.gridwidth = ITEMS_PER_ROW;
            c.gridheight = 2;
            panel.add(debugLabel, c);
        }

        panel.revalidate();
        panel.repaint();
        return panel;
    }

    public static String buildSubmissionTooltip(RecentSubmission submission, boolean forGroup) {
        try {
            String tooltip = "<html><p style='font-size:10px;'>";
            if (forGroup) {
                if (submission.getSubmissionType().equalsIgnoreCase("pb")) {
                    String pbTime = sanitizeTxt(submission.getPbTime());
                    tooltip += "<b>" + pbTime + "</b> at " + sanitizeTxt(submission.getSourceName()) + "<br>" +
                            sanitizeTxt(submission.getPlayerName()) + " - new personal best!<br><br>" +
                            "<i>" + sanitizeTxt(submission.timeSinceReceived()) + "</i>";
                } else if (submission.getSubmissionType().equalsIgnoreCase("drop")) {
                    String itemName = sanitizeTxt(submission.getDropItemName());
                    tooltip += "<b>" + itemName + "</b><br>" +
                            sanitizeTxt(submission.getPlayerName()) + "<br>" +
                            "from: <i>" + sanitizeTxt(submission.getSourceName()) + "</i><br>" +
                            "<i>" + sanitizeTxt(submission.timeSinceReceived()) + "</i>";
                } else if (submission.getSubmissionType().equalsIgnoreCase("clog")) {
                    String itemName = sanitizeTxt(submission.getClogItemName());
                    tooltip += sanitizeTxt(submission.getPlayerName()) + " - New Collection Log:<br>" +
                            "<b>" + itemName + "</b><br>" +
                            "<i>from: " + sanitizeTxt(submission.getSourceName()) + "</i><br>" +
                            "<i>" + sanitizeTxt(submission.timeSinceReceived()) + "</i>";
                }
            } else {
                if (submission.getSubmissionType().equalsIgnoreCase("pb")) {
                    String pbTime = sanitizeTxt(submission.getPbTime());
                    tooltip += "<b>" + pbTime + "</b> at " + sanitizeTxt(submission.getSourceName()) + "<br>" +
                            sanitizeTxt(submission.getPlayerName()) + " - new personal best!<br><br>" +
                            "<i>" + sanitizeTxt(submission.timeSinceReceived()) + "</i>";
                } else if (submission.getSubmissionType().equalsIgnoreCase("drop")) {
                    String itemName = sanitizeTxt(submission.getDropItemName());
                    tooltip += "<b>" + itemName + "</b><br>" +
                            sanitizeTxt(submission.getPlayerName()) + "<br>" +
                            "from: <i>" + sanitizeTxt(submission.getSourceName()) + "</i><br>" +
                            "<i>" + sanitizeTxt(submission.timeSinceReceived()) + "</i>";
                } else if (submission.getSubmissionType().equalsIgnoreCase("clog")) {
                    String itemName = sanitizeTxt(submission.getClogItemName());
                    tooltip += sanitizeTxt(submission.getPlayerName()) + " - New Collection Log:<br>" +
                            "<b>" + itemName + "</b><br>" +
                            "<i>" + sanitizeTxt(submission.timeSinceReceived()) + "</i>";
                }
            }
            tooltip += "</p></html>";
            return tooltip;

        } catch (Exception e) {
            return sanitizeTxt(submission.getPlayerName() + " - " + submission.getSubmissionType() + " - " + submission.getSourceName());
        }
    }

    private static String sanitizeTxt(String tooltip) {
        return tooltip.replaceAll("\\<.*?\\>", "");
    }

    private static void displayImageInDialog(JDialog imageDialog, BufferedImage originalImage, JFrame parentFrame) {
        // Calculate display size based on screen dimensions
        Dimension screenSize = java.awt.Toolkit.getDefaultToolkit().getScreenSize();
        int maxWidth = (int) (screenSize.width * 0.9);
        int maxHeight = (int) (screenSize.height * 0.9);

        int originalWidth = originalImage.getWidth();
        int originalHeight = originalImage.getHeight();

        int displayWidth = originalWidth;
        int displayHeight = originalHeight;

        // Scale down if image is too large for screen
        if (originalWidth > maxWidth || originalHeight > maxHeight) {
            double scaleX = (double) maxWidth / originalWidth;
            double scaleY = (double) maxHeight / originalHeight;
            double scale = Math.min(scaleX, scaleY);

            displayWidth = (int) (originalWidth * scale);
            displayHeight = (int) (originalHeight * scale);
        }

        // Create image label
        JLabel imageLabel = new JLabel();
        imageLabel.setPreferredSize(new Dimension(displayWidth, displayHeight));
        imageLabel.setBorder(new StrokeBorder(new BasicStroke(2), ColorScheme.LIGHT_GRAY_COLOR));
        imageLabel.setHorizontalAlignment(JLabel.CENTER);
        imageLabel.setVerticalAlignment(JLabel.CENTER);
        imageLabel.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        imageLabel.setOpaque(true);

        // Scale image if needed
        Image displayImage;
        if (displayWidth == originalWidth && displayHeight == originalHeight) {
            displayImage = originalImage;
        } else {
            displayImage = originalImage.getScaledInstance(displayWidth, displayHeight, Image.SCALE_SMOOTH);
        }

        imageLabel.setIcon(new ImageIcon(displayImage));

        // Add listeners
        addCloseListener(imageLabel, imageDialog);
        addEscapeKeyListener(imageLabel, imageDialog);

        // Set up dialog
        imageDialog.add(imageLabel);
        imageDialog.pack();
        imageDialog.setLocationRelativeTo(parentFrame);

        // Request focus for escape key
        SwingUtilities.invokeLater(() -> imageLabel.requestFocusInWindow());

    }

    // Helper methods to reduce code duplication
    private static void addCloseListener(JLabel label, JDialog dialog) {
        label.addMouseListener(new MouseAdapter() {
            @Override
            public void mouseClicked(MouseEvent e) {
                dialog.dispose();
            }
        });
    }

    private static void addEscapeKeyListener(JLabel label, JDialog dialog) {
        label.setFocusable(true);
        label.addKeyListener(new java.awt.event.KeyAdapter() {
            @Override
            public void keyPressed(java.awt.event.KeyEvent e) {
                if (e.getKeyCode() == java.awt.event.KeyEvent.VK_ESCAPE) {
                    dialog.dispose();
                }
            }
        });
    }

}

package io.droptracker.ui.components;

import javax.swing.*;
import java.awt.*;
import java.util.HashMap;
import java.util.Map;

class TableRow extends JPanel {
    Map<String, JLabel> labels = new HashMap<>();

    TableRow(String boss, String killsText, String rankText, String ehbText) {
        setLayout(new GridLayout(1, 4));
        addLabel(boss);
        addLabel(killsText);
        addLabel(rankText);
        addLabel(ehbText);
    }

    private void addLabel(String text) {
        JLabel label = new JLabel(text);
        label.setForeground(Color.WHITE);
        labels.put(text, label);
        add(label);
    }

    // Updates the row's labels with data
    public void update(String kills, String rank, String ehb) {
        labels.get("kills").setText(String.valueOf(kills));
        labels.get("rank").setText(String.valueOf(rank));
        labels.get("ehb").setText(String.valueOf(ehb));
    }

    // Resets the row to default state
    public void reset() {
        labels.get("kills").setText("--");
        labels.get("rank").setText("--");
        labels.get("ehb").setText("--");
    }
}

class RowPair {
    private final String skill;
    private final TableRow row;

    public RowPair(String skill, TableRow row) {
        this.skill = skill;
        this.row = row;
    }

    public String getSkill() {
        return skill;
    }

    public TableRow getRow() {
        return row;
    }
}

package io.droptracker.ui.components;

import java.awt.BorderLayout;
import java.awt.Color;
import java.awt.BasicStroke;
import java.awt.Component;
import java.awt.Container;
import java.awt.Dimension;
import java.awt.Font;
import java.awt.Insets;
import java.util.List;
import java.util.function.Supplier;
import java.util.concurrent.CompletableFuture;

import javax.swing.Box;
import javax.swing.BoxLayout;
import javax.swing.JButton;
import javax.swing.JLabel;
import javax.swing.JPanel;
import javax.swing.JTextField;
import javax.swing.SwingUtilities;
import javax.swing.border.EmptyBorder;
import javax.swing.border.StrokeBorder;

import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.FontManager;
import net.runelite.client.ui.PluginPanel;

public class LeaderboardComponents {

    /**
     * Creates a standard header panel with title and search functionality
     */
    public static HeaderResult createHeaderPanel(String title, String searchPlaceholder, Runnable searchAction) {
        JPanel headerPanel = new JPanel(new BorderLayout());
        headerPanel.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        headerPanel.setBorder(new EmptyBorder(10, 10, 10, 10));
        headerPanel.setAlignmentX(Component.LEFT_ALIGNMENT);
        headerPanel.setPreferredSize(new Dimension(PluginPanel.PANEL_WIDTH, 90));
        headerPanel.setMaximumSize(new Dimension(PluginPanel.PANEL_WIDTH, 90));
        headerPanel.setMinimumSize(new Dimension(PluginPanel.PANEL_WIDTH, 90));
        
        // Create a vertical panel for title and search
        JPanel titleAndSearchPanel = new JPanel();
        titleAndSearchPanel.setLayout(new BoxLayout(titleAndSearchPanel, BoxLayout.Y_AXIS));
        titleAndSearchPanel.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        
        JLabel titleLabel = new JLabel(title);
        titleLabel.setFont(FontManager.getRunescapeBoldFont());
        titleLabel.setForeground(Color.WHITE);
        titleLabel.setAlignmentX(Component.CENTER_ALIGNMENT);
        titleLabel.setHorizontalAlignment(JLabel.CENTER);
        titleLabel.setPreferredSize(new Dimension(PluginPanel.PANEL_WIDTH - 40, 25));
        titleLabel.setMaximumSize(new Dimension(PluginPanel.PANEL_WIDTH - 40, 25));
        
        // Search field
        JPanel searchPanel = new JPanel(new BorderLayout(5, 0));
        searchPanel.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        searchPanel.setBorder(new StrokeBorder(new BasicStroke(1), ColorScheme.DARKER_GRAY_HOVER_COLOR));
        searchPanel.setAlignmentX(Component.CENTER_ALIGNMENT);
        searchPanel.setPreferredSize(new Dimension(PluginPanel.PANEL_WIDTH - 40, 35));
        searchPanel.setMaximumSize(new Dimension(PluginPanel.PANEL_WIDTH - 40, 35));
        searchPanel.setMinimumSize(new Dimension(PluginPanel.PANEL_WIDTH - 40, 35));
        
        JTextField searchField = new JTextField();
        searchField.setBorder(new StrokeBorder(new BasicStroke(1), ColorScheme.DARKER_GRAY_HOVER_COLOR));
        searchField.setToolTipText(searchPlaceholder);
        searchField.setHorizontalAlignment(JTextField.LEFT);
        searchField.setMargin(new Insets(5, 8, 5, 8));
        searchField.setFont(FontManager.getRunescapeSmallFont());
        searchField.setPreferredSize(new Dimension(200, 35));
        searchField.setMinimumSize(new Dimension(100, 35));
        
        JButton searchButton = new JButton("Search");
        searchButton.setPreferredSize(new Dimension(70, 35));
        searchButton.setMaximumSize(new Dimension(70, 35));
        searchButton.setMinimumSize(new Dimension(70, 35));
        searchButton.setMargin(new Insets(5, 5, 5, 5));
        searchButton.addActionListener(e -> searchAction.run());
        
        searchPanel.add(searchField, BorderLayout.CENTER);
        searchPanel.add(searchButton, BorderLayout.EAST);
        
        titleAndSearchPanel.add(titleLabel);
        titleAndSearchPanel.add(Box.createRigidArea(new Dimension(0, 10)));
        titleAndSearchPanel.add(searchPanel);
        
        headerPanel.add(titleAndSearchPanel, BorderLayout.CENTER);
        
        return new HeaderResult(headerPanel, searchField);
    }

    /**
     * Creates a standard leaderboard table with rank, name, and value columns
     */
    public static <T> JPanel createLeaderboardTable(String title, String nameColumnHeader, 
            List<T> data, LeaderboardItemRenderer<T> renderer) {
        
        JPanel leaderboardPanel = new JPanel();
        leaderboardPanel.setLayout(new BoxLayout(leaderboardPanel, BoxLayout.Y_AXIS));
        leaderboardPanel.setBackground(ColorScheme.DARK_GRAY_COLOR);
        leaderboardPanel.setAlignmentX(Component.CENTER_ALIGNMENT);
        
        // Title for the leaderboard
        JLabel leaderboardTitle = new JLabel(title);
        leaderboardTitle.setFont(FontManager.getRunescapeBoldFont());
        leaderboardTitle.setForeground(Color.WHITE);
        leaderboardTitle.setAlignmentX(Component.CENTER_ALIGNMENT);
        leaderboardTitle.setHorizontalAlignment(JLabel.CENTER);
        
        // Create table container
        JPanel tableContainer = new JPanel();
        tableContainer.setLayout(new BoxLayout(tableContainer, BoxLayout.Y_AXIS));
        tableContainer.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        tableContainer.setBorder(new EmptyBorder(10, 10, 10, 10));
        tableContainer.setAlignmentX(Component.CENTER_ALIGNMENT);
        tableContainer.setMaximumSize(new Dimension(PluginPanel.PANEL_WIDTH - 20, 200));
        
        // Create table header
        JPanel headerRow = createTableHeader(nameColumnHeader);
        
        // Create data rows
        JPanel dataContainer = new JPanel();
        dataContainer.setLayout(new BoxLayout(dataContainer, BoxLayout.Y_AXIS));
        dataContainer.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        dataContainer.setAlignmentX(Component.CENTER_ALIGNMENT);
        
        if (data != null && !data.isEmpty()) {
            int displayRank = 1;
            for (T item : data) {
                if (displayRank > 5) break; // Only show top 5
                
                JPanel dataRow = createDataRow(item, displayRank, renderer);
                dataContainer.add(dataRow);
                
                if (displayRank < Math.min(5, data.size())) {
                    dataContainer.add(Box.createRigidArea(new Dimension(0, 3)));
                }
                displayRank++;
            }
        } else {
            // No data fallback
            JLabel noDataLabel = new JLabel("No leaderboard data available");
            noDataLabel.setFont(FontManager.getRunescapeSmallFont());
            noDataLabel.setForeground(Color.LIGHT_GRAY);
            noDataLabel.setHorizontalAlignment(JLabel.CENTER);
            noDataLabel.setAlignmentX(Component.CENTER_ALIGNMENT);
            dataContainer.add(noDataLabel);
        }
        
        // Assemble the table
        tableContainer.add(headerRow);
        tableContainer.add(Box.createRigidArea(new Dimension(0, 5)));
        tableContainer.add(dataContainer);
        
        // Add to main panel
        leaderboardPanel.add(leaderboardTitle);
        leaderboardPanel.add(Box.createRigidArea(new Dimension(0, 10)));
        leaderboardPanel.add(tableContainer);
        
        return leaderboardPanel;
    }

    /**
     * Creates table header row
     */
    private static JPanel createTableHeader(String nameColumnHeader) {
        JPanel headerRow = new JPanel(new BorderLayout(5, 0));
        headerRow.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        headerRow.setMaximumSize(new Dimension(PluginPanel.PANEL_WIDTH - 40, 25));
        headerRow.setPreferredSize(new Dimension(PluginPanel.PANEL_WIDTH - 40, 25));
        
        JLabel rankHeader = new JLabel("Rank");
        rankHeader.setFont(FontManager.getRunescapeBoldFont());
        rankHeader.setForeground(ColorScheme.LIGHT_GRAY_COLOR);
        rankHeader.setHorizontalAlignment(JLabel.LEFT);
        rankHeader.setPreferredSize(new Dimension(40, 25));
        
        JPanel nameAndLootHeader = new JPanel(new BorderLayout(10, 0));
        nameAndLootHeader.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        
        JLabel nameHeader = new JLabel(nameColumnHeader);
        nameHeader.setFont(FontManager.getRunescapeBoldFont());
        nameHeader.setForeground(ColorScheme.LIGHT_GRAY_COLOR);
        nameHeader.setHorizontalAlignment(JLabel.LEFT);
        
        JLabel lootHeader = new JLabel("Loot");
        lootHeader.setFont(FontManager.getRunescapeBoldFont());
        lootHeader.setForeground(ColorScheme.LIGHT_GRAY_COLOR);
        lootHeader.setHorizontalAlignment(JLabel.RIGHT);
        lootHeader.setPreferredSize(new Dimension(50, 25));
        
        nameAndLootHeader.add(nameHeader, BorderLayout.CENTER);
        nameAndLootHeader.add(lootHeader, BorderLayout.EAST);
        
        headerRow.add(rankHeader, BorderLayout.WEST);
        headerRow.add(nameAndLootHeader, BorderLayout.CENTER);
        
        return headerRow;
    }

    /**
     * Creates a data row for the leaderboard table
     */
    private static <T> JPanel createDataRow(T item, int displayRank, LeaderboardItemRenderer<T> renderer) {
        JPanel dataRow = new JPanel(new BorderLayout(5, 0));
        dataRow.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        dataRow.setMaximumSize(new Dimension(PluginPanel.PANEL_WIDTH - 40, 25));
        dataRow.setPreferredSize(new Dimension(PluginPanel.PANEL_WIDTH - 40, 25));
        
        // Rank
        Integer apiRank = renderer.getRank(item);
        int rankToShow = (apiRank != null) ? apiRank : displayRank;
        
        JLabel rankLabel = new JLabel("#" + rankToShow);
        rankLabel.setFont(FontManager.getRunescapeSmallFont());
        rankLabel.setForeground(rankToShow <= 3 ? ColorScheme.PROGRESS_COMPLETE_COLOR : Color.WHITE);
        rankLabel.setHorizontalAlignment(JLabel.LEFT);
        rankLabel.setPreferredSize(new Dimension(40, 25));
        
        // Name and loot panel
        JPanel nameAndLootData = new JPanel(new BorderLayout(10, 0));
        nameAndLootData.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        
        // Name button
        String name = renderer.getName(item);
        JButton nameButton = new JButton("<html>" + name + "&nbsp;&nbsp;<img src='https://www.droptracker.io/img/external-8px-g.png'></html>");
        nameButton.setFont(FontManager.getRunescapeSmallFont());
        nameButton.setForeground(Color.WHITE);
        nameButton.setHorizontalAlignment(JLabel.LEFT);
        nameButton.setBorder(null);
        nameButton.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        nameButton.setOpaque(false);
        nameButton.setContentAreaFilled(false);
        nameButton.addActionListener(e -> renderer.onItemClick(item));
        
        // Loot value
        String lootValue = renderer.getLootValue(item);
        JLabel lootLabel = new JLabel(lootValue);
        lootLabel.setFont(FontManager.getRunescapeSmallFont());
        lootLabel.setForeground(ColorScheme.GRAND_EXCHANGE_PRICE);
        lootLabel.setHorizontalAlignment(JLabel.RIGHT);
        lootLabel.setPreferredSize(new Dimension(50, 25));
        
        nameAndLootData.add(nameButton, BorderLayout.CENTER);
        nameAndLootData.add(lootLabel, BorderLayout.EAST);
        
        dataRow.add(rankLabel, BorderLayout.WEST);
        dataRow.add(nameAndLootData, BorderLayout.CENTER);
        
        return dataRow;
    }

    /**
     * Creates a loading placeholder panel
     */
    public static JPanel createLoadingPlaceholder(String loadingText) {
        JPanel placeholder = new JPanel();
        placeholder.setLayout(new BoxLayout(placeholder, BoxLayout.Y_AXIS));
        placeholder.setBackground(ColorScheme.DARK_GRAY_COLOR);
        placeholder.setAlignmentX(Component.CENTER_ALIGNMENT);
        
        JLabel loadingLabel = new JLabel(loadingText);
        loadingLabel.setFont(FontManager.getRunescapeSmallFont());
        loadingLabel.setForeground(Color.LIGHT_GRAY);
        loadingLabel.setAlignmentX(Component.CENTER_ALIGNMENT);
        loadingLabel.setHorizontalAlignment(JLabel.CENTER);
        
        placeholder.add(loadingLabel);
        return placeholder;
    }

    /**
     * Replaces a placeholder panel with the actual content
     */
    public static void replacePlaceholder(JPanel placeholder, JPanel replacement) {
        SwingUtilities.invokeLater(() -> {
            if (placeholder != null && replacement != null) {
                Container parent = placeholder.getParent();
                if (parent != null) {
                    // Find the index of the placeholder
                    int index = -1;
                    for (int i = 0; i < parent.getComponentCount(); i++) {
                        if (parent.getComponent(i) == placeholder) {
                            index = i;
                            break;
                        }
                    }
                    
                    if (index != -1) {
                        parent.remove(index);
                        parent.add(replacement, index);
                        parent.revalidate();
                        parent.repaint();
                    }
                }
            }
        });
    }

    /**
     * Creates an error panel for search failures
     */
    public static JPanel createErrorPanel(String message, Runnable backAction) {
        JPanel errorPanel = new JPanel();
        errorPanel.setLayout(new BoxLayout(errorPanel, BoxLayout.Y_AXIS));
        errorPanel.setBackground(ColorScheme.DARK_GRAY_COLOR);
        errorPanel.setAlignmentX(Component.CENTER_ALIGNMENT);
        
        errorPanel.add(Box.createRigidArea(new Dimension(0, 50)));
        
        JLabel errorLabel = new JLabel(message);
        errorLabel.setFont(FontManager.getRunescapeFont());
        errorLabel.setForeground(Color.RED);
        errorLabel.setAlignmentX(Component.CENTER_ALIGNMENT);
        errorLabel.setHorizontalAlignment(JLabel.CENTER);
        
        JButton backButton = new JButton("Back to Search");
        backButton.setAlignmentX(Component.CENTER_ALIGNMENT);
        backButton.addActionListener(e -> backAction.run());
        
        errorPanel.add(errorLabel);
        errorPanel.add(Box.createRigidArea(new Dimension(0, 20)));
        errorPanel.add(backButton);
        errorPanel.add(Box.createVerticalGlue());
        
        return errorPanel;
    }

    /**
     * Creates a clear button for search results
     */
    public static JButton createClearButton(Runnable clearAction) {
        JButton clearButton = new JButton("");
        clearButton.setFont(new Font(Font.SANS_SERIF, Font.BOLD, 16));
        clearButton.setForeground(Color.LIGHT_GRAY);
        clearButton.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        clearButton.setBorder(new EmptyBorder(5, 8, 5, 8));
        clearButton.setPreferredSize(new Dimension(30, 30));
        clearButton.setMaximumSize(new Dimension(30, 30));
        clearButton.setMinimumSize(new Dimension(30, 30));
        clearButton.setToolTipText("Clear search");
        clearButton.setOpaque(false);
        clearButton.setContentAreaFilled(false);
        clearButton.addActionListener(e -> clearAction.run());
        return clearButton;
    }

    /**
     * Handles asynchronous leaderboard loading
     */
    public static <T> void loadLeaderboardAsync(JPanel placeholder, 
            Supplier<T> dataLoader, 
            java.util.function.Function<T, JPanel> panelCreator) {
        
        CompletableFuture.supplyAsync(() -> {
            try {
                T data = dataLoader.get();
                if (data != null) {
                    return panelCreator.apply(data);
                }
            } catch (Exception e) {
            }
            return null;
        }).thenAccept(leaderboardPanel -> {
            if (leaderboardPanel != null) {
                replacePlaceholder(placeholder, leaderboardPanel);
            }
        });
    }

    /**
     * Result container for header creation
     */
    public static class HeaderResult {
        public final JPanel panel;
        public final JTextField searchField;

        public HeaderResult(JPanel panel, JTextField searchField) {
            this.panel = panel;
            this.searchField = searchField;
        }
    }

    /**
     * Interface for rendering leaderboard items
     */
    public interface LeaderboardItemRenderer<T> {
        String getName(T item);
        String getLootValue(T item);
        Integer getRank(T item);
        void onItemClick(T item);
    }
} 
package io.droptracker.ui;

import io.droptracker.DropTrackerConfig;
import io.droptracker.DropTrackerPlugin;
import io.droptracker.service.SubmissionManager;

import javax.inject.Inject;
import javax.swing.*;

import io.droptracker.api.DropTrackerApi;
import io.droptracker.ui.pages.GroupPanel;
import io.droptracker.ui.pages.HomePanel;
import io.droptracker.ui.pages.ApiPanel;
import io.droptracker.ui.pages.PlayerStatsPanel;

import io.droptracker.util.DebugLogger;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.FontManager;
import net.runelite.client.ui.PluginPanel;
import net.runelite.client.game.ItemManager;
import net.runelite.client.util.ImageUtil;

import javax.swing.border.EmptyBorder;
import java.awt.BorderLayout;
import java.awt.Color;
import java.awt.Dimension;
import java.awt.Image;
import java.util.Map;
import java.awt.FlowLayout;
import java.awt.Component;

@Slf4j
public class DropTrackerPanel extends PluginPanel implements DropTrackerApi.PanelDataLoadedCallback {

	private static final ImageIcon LOGO_GIF;


	static {
		Image logoGif = ImageUtil.loadImageResource(DropTrackerPlugin.class, "brand/droptracker-small.gif");
		Image logoResized = logoGif.getScaledInstance(100, 100, Image.SCALE_SMOOTH);
		LOGO_GIF = new ImageIcon(logoResized);
	}

	private final DropTrackerPlugin plugin;
	private final DropTrackerApi api;
	private JPanel headerPanel;

	@Inject
	private Client client;
	@Inject
	private ItemManager itemManager;
	@Inject
	private DropTrackerConfig config;
	@Inject
	private SubmissionManager submissionManager;
	
	private PlayerStatsPanel statsPanel;
	private GroupPanel groupPanel;
	private ApiPanel apiPanel;
	private HomePanel homePanel;
	private JTabbedPane tabbedPane;
	
	// Add references to the actual panel components added to tabs
	private JPanel welcomePanel;
	private JPanel apiInfoPanel;
	private JPanel playerStatsPanel;
	private JPanel groupStatsPanel;
	private JLabel communicationStatusLabel;

	private boolean testing = false;

	@Inject
	public DropTrackerPanel(DropTrackerConfig config, DropTrackerApi api, DropTrackerPlugin plugin, Client client) {
		this.config = config;
		this.api = api;
		this.plugin = plugin;
		this.client = client;

		
		setLayout(new BorderLayout());
		setBorder(new EmptyBorder(10, 10, 10, 10));
		setBackground(ColorScheme.DARK_GRAY_COLOR);

		// init() will be called by the plugin - don't call it here to avoid double initialization
	}

	public void init() {
		removeAll();

		// Main layout
		setLayout(new BorderLayout());
		headerPanel = new JPanel(new BorderLayout());

		addHeaderElements();
		/* Test button
		if(testing){
			DebugLogger.log("Testing is set true... adding button");
			JButton testButton = new JButton("Create Game Message");
			testButton.addActionListener(e -> plugin.pbHandler.generateTestMessage());
			testButton.setAlignmentX(Component.CENTER_ALIGNMENT);
			headerPanel.add(testButton, BorderLayout.NORTH);
		}
		 */

		// Create tabbed pane
		tabbedPane = new JTabbedPane();
		tabbedPane.setBackground(ColorScheme.DARK_GRAY_COLOR);
		tabbedPane.setForeground(Color.WHITE);

		// Home tab
		homePanel = new HomePanel(config, api, client, this);
		welcomePanel = homePanel.create();	// Store reference




		// Tabs for users with API enabled
		if (config.useApi()) {
			// API Info tab
			apiPanel = new ApiPanel(config, api, submissionManager, this);
			apiInfoPanel = apiPanel.create();   // Store reference
			statsPanel = new PlayerStatsPanel(client, plugin, config, api, itemManager);
			groupPanel = new GroupPanel(client, config, api, itemManager, this);
			playerStatsPanel = statsPanel.create(); // Store reference
			groupStatsPanel = groupPanel.create();   // Store reference
			tabbedPane.addTab("Players", playerStatsPanel);
			tabbedPane.addTab("Groups", groupStatsPanel);
			tabbedPane.addTab("Welcome", welcomePanel);
			tabbedPane.addTab("API", apiInfoPanel); // added first to place it at the top
		} else {
			tabbedPane.addTab("Welcome", welcomePanel);
		}

		// Welcome tab


		// Add components to main panel
		add(headerPanel, BorderLayout.NORTH);
		add(tabbedPane, BorderLayout.CENTER);
		tabbedPane.setSelectedComponent(welcomePanel);

		// Initialize communication status after everything is set up
		if (config.useApi() && apiPanel != null) {
			apiPanel.updateStatusLabel();
		}

		revalidate();
		repaint();
	}

	private void addHeaderElements() {
		// Header panel (stays constant across tabs)
		headerPanel.setBackground(ColorScheme.DARKER_GRAY_COLOR);
		headerPanel.setBorder(new EmptyBorder(10, 10, 10, 10));

		// Create a vertical panel for just the title
		JPanel titlePanel = new JPanel();
		titlePanel.setLayout(new BoxLayout(titlePanel, BoxLayout.Y_AXIS));
		titlePanel.setBackground(ColorScheme.DARKER_GRAY_COLOR);

		// Main title
		JLabel welcomeText = new JLabel("DropTracker");
		welcomeText.setFont(FontManager.getRunescapeBoldFont());
		welcomeText.setAlignmentX(Component.CENTER_ALIGNMENT);
		welcomeText.setForeground(Color.WHITE);

		// Add only the title to title panel
		titlePanel.add(welcomeText);

		// Create a subtle info panel for version and API status
		JPanel infoPanel = new JPanel(new FlowLayout(FlowLayout.CENTER, 5, 0));
		infoPanel.setBackground(ColorScheme.DARKER_GRAY_COLOR);

		JLabel versionText = new JLabel("v" + plugin.pluginVersion);
		versionText.setFont(FontManager.getRunescapeSmallFont());
		versionText.setForeground(ColorScheme.LIGHT_GRAY_COLOR); // More subtle color

		JLabel separatorText = new JLabel(""); // Bullet separator
		separatorText.setFont(FontManager.getRunescapeSmallFont());
		separatorText.setForeground(ColorScheme.LIGHT_GRAY_COLOR);

		// Create API status label
		String apiStatus = config.useApi() ? "ENABLED" : "DISABLED";
		JLabel apiStatusText = new JLabel("API: " + apiStatus);
		apiStatusText.setFont(FontManager.getRunescapeSmallFont());
		apiStatusText.setForeground(config.useApi() ? ColorScheme.PROGRESS_COMPLETE_COLOR : ColorScheme.PROGRESS_ERROR_COLOR);
		
		// Create communication status label (only shown when API is enabled)
		communicationStatusLabel = new JLabel("Loading...");
		communicationStatusLabel.setFont(FontManager.getRunescapeSmallFont());
		communicationStatusLabel.setForeground(ColorScheme.LIGHT_GRAY_COLOR);

		JButton refreshButton = new JButton(" Refresh Panel");
		refreshButton.setFont(FontManager.getRunescapeSmallFont());
		refreshButton.setForeground(ColorScheme.LIGHT_GRAY_COLOR);
		refreshButton.setBackground(ColorScheme.DARKER_GRAY_COLOR);
		refreshButton.setBorder(new EmptyBorder(5, 8, 5, 8));
		refreshButton.setPreferredSize(new Dimension(100, 30));
		refreshButton.setMaximumSize(new Dimension(100, 30));

		// Add info components to info panel (version and API status only)
		infoPanel.add(versionText);
		infoPanel.add(separatorText);
		infoPanel.add(apiStatusText);
		
		// Create communication status panel (separate line, only when API is enabled)
		JPanel communicationPanel = new JPanel(new FlowLayout(FlowLayout.CENTER, 0, 0));
		communicationPanel.setBackground(ColorScheme.DARKER_GRAY_COLOR);
		if (config.useApi()) {
			communicationStatusLabel.setAlignmentX(Component.CENTER_ALIGNMENT);
			communicationPanel.add(communicationStatusLabel);
		}
		
		// Logo panel with logo and version info below it
		JPanel logoPanel = new JPanel();
		logoPanel.setLayout(new BoxLayout(logoPanel, BoxLayout.Y_AXIS));
		logoPanel.setBackground(ColorScheme.DARKER_GRAY_COLOR);
		
		JLabel logoLabel = new JLabel(LOGO_GIF);
		logoLabel.setAlignmentX(Component.CENTER_ALIGNMENT);
		logoPanel.add(logoLabel);
		logoPanel.add(Box.createRigidArea(new Dimension(0, 5))); // Small spacing between logo and info
		logoPanel.add(infoPanel);
		
		// Add communication status on its own line if API is enabled
		if (config.useApi()) {
			logoPanel.add(Box.createRigidArea(new Dimension(0, 2))); // Small spacing
			logoPanel.add(communicationPanel);
		}

		// Add to header panel
		headerPanel.add(titlePanel, BorderLayout.NORTH);
		headerPanel.add(Box.createRigidArea(new Dimension(0, 10)), BorderLayout.CENTER); // Spacing
		headerPanel.add(logoPanel, BorderLayout.SOUTH);
	}
	
	public void deinit() {
		removeAll();
		if (apiPanel != null) {
			apiPanel.cleanup();
		}
	}

	public void selectPanel(String panelToSelect) {
		if (tabbedPane == null) {
			return;
		}
		
		switch (panelToSelect.toLowerCase()) {
			case "home":
			case "welcome":
				if (welcomePanel != null) {
					tabbedPane.setSelectedComponent(welcomePanel);
				} 
				break;
			case "players":
			case "stats":
				if (playerStatsPanel != null && config.useApi()) {
					tabbedPane.setSelectedComponent(playerStatsPanel);
				} 
				break;
			case "groups":
				if (groupStatsPanel != null && config.useApi()) {
					tabbedPane.setSelectedComponent(groupStatsPanel);
				}
				break;
			case "api":
				if (apiInfoPanel != null) {
					tabbedPane.setSelectedComponent(apiInfoPanel);
				} 
				break;
			default:
				break;
		}
	}

	// Allow searched for player by name (Perhaps for right-click lookups later, etc)
	public void updatePlayerPanel(String playerToLoad) {
		if (statsPanel != null) {
			statsPanel.performPlayerSearch(playerToLoad);
		}
	}

	// Update the player panel with the current player's name
	public void updatePlayerPanel() {
		if (statsPanel != null) {
			statsPanel.performPlayerSearch("");
		}
	}

	// Update the group panel from sources other than direct searches
	public void updateGroupPanel(String groupToLoad) {
		if (groupPanel != null && groupToLoad != null && !groupToLoad.trim().isEmpty()) {
			groupPanel.performGroupSearch(groupToLoad);
		}
	}


	// Update the API panel with the current session's valid submissions
	public void updateSentSubmissions() {
		if (apiPanel != null) {
			apiPanel.refresh();
		}
	}

	/**
	 * Updates the player button on the home panel if a local name becomes available after initial render
	 */
	public void updateHomePlayerButton() {
		if (homePanel != null) {
			homePanel.updatePlayerButton();
		}
	}

	/**
	 * Updates the communication status in the header panel
	 */
	public void updateCommunicationStatus(String statusText, Color statusColor) {
		if (communicationStatusLabel != null) {
			communicationStatusLabel.setText(statusText);
			communicationStatusLabel.setForeground(statusColor);
			// Force repaint of header
			if (headerPanel != null) {
				headerPanel.revalidate();
				headerPanel.repaint();
			}
		}
	}

	@Override
	public void onDataLoaded(Map<String, Object> data) {
		updatePlayerPanel();
		updateGroupPanel("");
	}
}
/*
BSD 2-Clause License

		Copyright (c) 2022, Jake Barter
		All rights reserved.

		Copyright (c) 2022, pajlads

		Redistribution and use in source and binary forms, with or without
		modification, are permitted provided that the following conditions are met:

		1. Redistributions of source code must retain the above copyright notice, this
		list of conditions and the following disclaimer.

		2. Redistributions in binary form must reproduce the above copyright notice,
		this list of conditions and the following disclaimer in the documentation
		and/or other materials provided with the distribution.

		THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
		AND ANY EXPRESS OR 951bd712c5b3a41fd2f42f0cdfbfb1c27154b1bfIMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
		IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
		DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
		FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
		DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
		SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
		CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
		OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
		OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/
package io.droptracker;

import com.google.gson.*;
import com.google.inject.Provides;
import java.awt.image.BufferedImage;
import java.io.IOException;
import java.util.ArrayList;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.concurrent.atomic.AtomicReference;

import javax.annotation.Nullable;
import javax.inject.Inject;
import javax.swing.SwingUtilities;

import io.droptracker.api.DropTrackerApi;
import io.droptracker.api.UrlManager;
import io.droptracker.events.CaHandler;
import io.droptracker.events.ClogHandler;
import io.droptracker.events.DropHandler;
import io.droptracker.events.ExperienceHandler;
import io.droptracker.events.PbHandler;
import io.droptracker.events.QuestHandler;
import io.droptracker.events.PetHandler;
import io.droptracker.events.WidgetEventHandler;
import io.droptracker.models.submissions.Drop;
import io.droptracker.service.KCService;
import io.droptracker.service.SubmissionManager;
import io.droptracker.ui.DropTrackerPanel;
import io.droptracker.util.ChatMessageUtil;
import io.droptracker.util.DebugLogger;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.*;
import net.runelite.api.events.*;
import net.runelite.api.gameval.NpcID;
import net.runelite.api.gameval.VarbitID;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.events.ConfigChanged;
import net.runelite.client.events.NpcLootReceived;
import net.runelite.client.events.PlayerLootReceived;
import net.runelite.client.events.ServerNpcLoot;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.plugins.PluginDescriptor;
import net.runelite.client.plugins.loottracker.LootReceived;
import net.runelite.client.ui.ClientToolbar;
import net.runelite.client.ui.NavigationButton;


import net.runelite.client.util.ColorUtil;
import net.runelite.client.util.ImageUtil;
import okhttp3.*;

@Slf4j
@PluginDescriptor(
		name = "DropTracker",
		description = "Track your drops, compete in events, and send Discord webhooks!",
		tags = {"droptracker", "drop", "webhook", "events"}
)
public class DropTrackerPlugin extends Plugin {
	@Inject
	private DropTrackerConfig config;
	@Inject
	public static DropTrackerApi api;

	private DropTrackerPanel panel;

	private NavigationButton navButton;

	@Inject
	private Gson gson;

	@Inject
	private OkHttpClient httpClient;

	@Inject
	private KCService kcService;

	/* Event Handlers */
	@Inject
	private DropHandler dropHandler;
	@Inject
	private QuestHandler questHandler;
	@Inject
	public ClogHandler clogHandler;
	@Inject
	public CaHandler caHandler;
	@Inject
	public PbHandler pbHandler;
	@Inject
	public PetHandler petHandler;
	@Inject
	public ExperienceHandler experienceHandler;

	@Inject
	public ChatMessageUtil chatMessageUtil;
	@Inject
	private SubmissionManager submissionManager;

	private AtomicBoolean justLoggedIn = new AtomicBoolean(false);

	@Inject
	private ScheduledExecutorService executor;

	@Inject
	private DebugLogger debugLogger;

	@Nullable
	public Drop lastDrop = null;

	private boolean statsLoaded = false; 

	public Boolean isTracking = true;
	public Integer ticksSinceNpcDataUpdate = 0;

	private static final BufferedImage PANEL_ICON = ImageUtil.loadImageResource(DropTrackerPlugin.class, "icon.png");


	@Inject
	public WidgetEventHandler widgetEventHandler;

	@Inject
	private ClientToolbar clientToolbar;

	@Inject
	private UrlManager urlManager;

	@Inject
	private Client client;

	public String pluginVersion = "5.2.3";

	// Add a new flag to track when we need to update on next available tick
	private boolean needsPanelUpdateOnLogin = false;

	private final AtomicReference<GameState> gameState = new AtomicReference<>();

	public ArrayList<Integer> valuedItemIds;

	@Override
	protected void startUp() {
		api = new DropTrackerApi(config, gson, httpClient, this, client);
		if(config.showSidePanel()) {
			createSidePanel();
		}
		// Preload webhook URLs asynchronously
		executor.submit(() -> urlManager.loadEndpoints());
		// Load untradeable item IDs on startup for screenshotting purposes
		executor.submit(() -> loadUntradeables());

	}

	private void loadUntradeables() {
		this.valuedItemIds = api.getValuedUntradeables();
	}


	private void createSidePanel() {

		panel = injector.getInstance(DropTrackerPanel.class);
		panel.init();

		// Trigger initial UI refreshes so the panel is populated immediately
		SwingUtilities.invokeLater(() -> {
			if (panel != null) {
				panel.updateSentSubmissions();
				panel.updateHomePlayerButton();
				panel.updatePlayerPanel();
			}
		});

		submissionManager.setUpdateCallback(() -> {
			SwingUtilities.invokeLater(() -> {
				if (panel != null) {
					panel.updateSentSubmissions();
				}
			});
		});
		submissionManager.setUpdatesEnabled(true);

		navButton = NavigationButton.builder()
				.tooltip("DropTracker")
				.icon(PANEL_ICON)
				.priority(1)
				.panel(panel)
				.build();

		clientToolbar.addNavigation(navButton);
	}

	// public void updateSubmissionsPanel() {
	// 	if (panel != null) {
	// 		panel.updateSentSubmissions();
	// 	}
	// }




	public void updatePanelOnLogin(String chatMessage) {
		if (chatMessage.contains("Welcome to Old School RuneScape.")) {
			// Instead of updating immediately, set a flag to update when player is available
			needsPanelUpdateOnLogin = true;
		}
	}


	public String itemImageUrl(int itemId) {
		return "https://static.runelite.net/cache/item/icon/" + itemId + ".png";
	}

	@Override
	protected void shutDown() {
    gameState.lazySet(null);
		if (navButton != null) {
			clientToolbar.removeNavigation(navButton);
			navButton = null;
		}
		if (panel != null) {
			panel.deinit();
			panel = null;
		}
		// Disable updates while panel is not present
		submissionManager.setUpdatesEnabled(false);
		if (debugLogger != null) {
			debugLogger.close();
		}
		this.resetAll();	
	}

	@Provides
	DropTrackerConfig provideConfig(ConfigManager configManager) {
		return configManager.getConfig(DropTrackerConfig.class);
	}

	protected void resetAll() {
		kcService.reset();
		petHandler.reset();
	}

	@Subscribe
	public void onConfigChanged(ConfigChanged configChanged) {
		if (configChanged.getGroup().equalsIgnoreCase(DropTrackerConfig.GROUP)) {
			if (configChanged.getKey().equals("useApi")) {
				// Recreate the side panel which will reset the callback
				if (panel != null) {
					clientToolbar.removeNavigation(navButton);
					panel.deinit();
					panel = null;
					navButton = null;
					// Disable updates when removing the panel
					submissionManager.setUpdatesEnabled(false);
				}
				if (config.showSidePanel()) {
					createSidePanel();
				}
				// panel.refreshData();
				if (client.getAccountHash() != -1) {
					try {
						api.lookupPlayer(client.getLocalPlayer().getName());
					} catch (Exception e) {
						log.debug("Couldn't look the current player up in the DropTracker database");
					}
				}
			} else if (configChanged.getKey().equals("showSidePanel")) {
				if (!config.showSidePanel()) {
					if (panel != null) {
						clientToolbar.removeNavigation(navButton);
						panel.deinit();
						panel = null;
						navButton = null;
						// Disable updates when panel is removed
						submissionManager.setUpdatesEnabled(false);
					}
				} else {
					if (panel == null) {
						createSidePanel();
					}
				}
			}


			//sendChatReminder();
		}
	}

	@Subscribe
	public void onCommandExecuted(CommandExecuted command) {
		chatMessageUtil.onCommandExecuted(command);
	}

	@Subscribe
	public void onScriptPreFired(ScriptPreFired event) {
		if(clogHandler.isEnabled()) {
			clogHandler.onScript(event.getScriptId());
		}
	}

	@Subscribe
	public void onWidgetLoaded(WidgetLoaded widget) {
		widgetEventHandler.onWidgetLoaded(widget);
		// Also check for quest completion widgets
		questHandler.onWidgetLoaded(widget);
	}

	/** Add support for Yama's special drop mechanics */
	@Subscribe(priority = 1)
    public void onServerNpcLoot(ServerNpcLoot event) {
        if (event.getComposition().getId() != NpcID.YAMA) {
            return;
        }
        kcService.onServerNpcLoot(event);
        dropHandler.onServerNpcLoot(event);
    }

	@Subscribe(priority=1)
	public void onNpcLootReceived(NpcLootReceived npcLootReceived) {
		if (npcLootReceived.getNpc().getId() == NpcID.YAMA) {
			/* Handled by onServerNpcLoot */
            return;
        }
		dropHandler.onNpcLootReceived(npcLootReceived);
		kcService.onNpcKill(npcLootReceived);
	}

	@Subscribe(priority=1)
	public void onPlayerLootReceived(PlayerLootReceived playerLootReceived) {
		dropHandler.onPlayerLootReceived(playerLootReceived);
		kcService.onPlayerKill(playerLootReceived);
	}

	@Subscribe(priority=1)
	public void onLootReceived(LootReceived lootReceived) {
		dropHandler.onLootReceived(lootReceived);
		kcService.onLoot(lootReceived);
	}

	@Subscribe(priority = 1)
	public void onChatMessage(ChatMessage message) {
		if (!isTracking) {
			return;
		}
		String chatMessage = submissionManager.sanitize(message.getMessage());
		switch (message.getType()) {
			case WELCOME:
				if (!statsLoaded) {
					updatePanelOnLogin(chatMessage);
				}
				/* Welcome should only be called a single time on each login, 
					so we can call this regardless of whether statsLoaded is true,
					to load/refresh configurations respective to the current player logged in
				*/
				if (config.useApi()) {
					try {
						api.loadGroupConfigs(getLocalPlayerName());
						// Refresh the API panel to show updated group configs
						// Since loading is async, we need to delay the refresh
						if (panel != null) {
							// Initial refresh to show loading state
							SwingUtilities.invokeLater(() -> {
								panel.updateSentSubmissions();
							});

							// Schedule a panel submission update on the executor instead of directly waiting on the thread

							executor.schedule(() -> { panel.updateSentSubmissions(); }, 2, TimeUnit.SECONDS); // Wait 2 seconds for async load

						}
					} catch (IOException e) {
						log.debug("Couldn't refresh api Panel");
					}
				}
				break;
			case GAMEMESSAGE:
				if(pbHandler.isEnabled()){
					pbHandler.onGameMessage(chatMessage);
				}
				if(caHandler.isEnabled()){
					caHandler.onGameMessage(chatMessage);
				}
				if(clogHandler.isEnabled()) {
					clogHandler.onChatMessage(chatMessage);
				}
				if(petHandler.isEnabled()) {
					petHandler.onGameMessage(chatMessage);
				}
			case FRIENDSCHATNOTIFICATION:
				pbHandler.onFriendsChatNotification(chatMessage);
			case CLAN_MESSAGE:
			case CLAN_GIM_MESSAGE:
                petHandler.onClanChatNotification(chatMessage);
                break;
			default:
				break;
		}
		kcService.onGameMessage(chatMessage);
	}

	@Subscribe
	public void onGameTick(GameTick event) {
		if (!isTracking) {
			return;
		}

		// Check if we need to update panel on login and player is now available
		if (needsPanelUpdateOnLogin && client.getLocalPlayer() != null && client.getLocalPlayer().getName() != null) {
			needsPanelUpdateOnLogin = false; // Clear the flag

			// Use SwingUtilities to ensure UI updates happen on EDT
			String playerName = client.getLocalPlayer().getName();
			if (config.lastAccountName() != null && !config.lastAccountName().equals(playerName)) {
				/* In the case that the player has changed from the last time we stored their name/hash, we need to call the reset method on KCService... */
				kcService.reset();
			}
			config.setLastAccountName(playerName);
			config.setLastAccountHash(String.valueOf(client.getAccountHash()));
			SwingUtilities.invokeLater(() -> {
				try {
					if (panel != null) {
						panel.updatePlayerPanel();

						// Also update the home player button since config might now have player name
						panel.updateHomePlayerButton();
						statsLoaded = true;
					}
				} catch (Exception e) {
					log.debug("Couldn't Load Side Panel UI");
					statsLoaded = true;
				}
			});
		}

		/* Call individual event handlers */
		experienceHandler.onTick();
		pbHandler.onTick();
		widgetEventHandler.onGameTick(event);

		petHandler.onTick();


		// Also tick the experience handler
		if (config.trackExperience()) {
			experienceHandler.onTick();
		}
	}

	@Subscribe
	public void onStatChanged(StatChanged statChanged) {
		if (!isTracking || !config.trackExperience()) {
			return;
		}
		experienceHandler.onStatChanged(statChanged);
	}

	@Subscribe
	public void onGameStateChanged(GameStateChanged gameStateChanged) {
    GameState newState = gameStateChanged.getGameState();

    if (newState == GameState.LOADING) {
      // an intermediate state that is irrelevant; ignore
      return;
    }

    GameState previousState = gameState.getAndSet(newState);
    if (previousState == newState) {
      // no real change occured (just momentarily went through LOADING); ignore
		return;
    }

    // Track if the user just logged in
    justLoggedIn.set(newState == GameState.LOGGED_IN);

    if (previousState == GameState.HOPPING) {
      // ignore
      return;
    }

    // Ensure the user didn't just logged in
    if (justLoggedIn.get()) {
      return;
    }

    if (config.clogEmbeds() && client.getVarbitValue(VarbitID.OPTION_COLLECTION_NEW_ITEM) == 0) {
      chatMessageUtil.warnClogSetting();
    }

    if (!config.useApi() && config.customApiEndpoint().equalsIgnoreCase("")) {
    /* Warn non-API users that they are strongly recommended to enable it for heightened reliability */
      chatMessageUtil.warnApiSetting();
    }

    // Experience tracking
		if (!isTracking || !config.trackExperience()) {
			return;
		}
		experienceHandler.onGameStateChanged(gameStateChanged);
	}

	public String getLocalPlayerName() {
		if (client.getLocalPlayer() != null) {
			return client.getLocalPlayer().getName();
		} else {
			return "";
		}
	}

	public void sendRankChangeChatMessage(String rankChangeType, Integer currentRankNpc, Integer currentRankAll, Integer totalRankChange, String totalLootReceived,
										  Integer totalRankChangeAtNpc, String totalLootNpc, Integer totalMembers, Integer totalMembersNpc,
										  String totalReceivedAllTime, String totalLootNpcAllTime) {

	}
}

package io.droptracker.service;
/* Author: https://github.com/pajlads/DinkPlugin */

import com.google.common.cache.Cache;
import com.google.common.cache.CacheBuilder;
import com.google.gson.Gson;
import com.google.gson.JsonSyntaxException;

import io.droptracker.DropTrackerPlugin;
import io.droptracker.models.SerializedDrop;
import io.droptracker.util.NpcUtilities;
import io.droptracker.util.Rarity;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.NPC;
import net.runelite.api.NpcID;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.config.RuneLiteConfig;
import net.runelite.client.events.NpcLootReceived;
import net.runelite.client.events.PlayerLootReceived;
import net.runelite.client.events.ServerNpcLoot;
import net.runelite.client.game.ItemStack;
import net.runelite.client.plugins.chatcommands.ChatCommandsPlugin;
import net.runelite.client.plugins.loottracker.LootReceived;
import net.runelite.client.plugins.loottracker.LootTrackerConfig;
import net.runelite.client.plugins.loottracker.LootTrackerPlugin;
import net.runelite.http.api.loottracker.LootRecordType;
import org.apache.commons.lang3.StringUtils;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.annotations.Nullable;

import javax.inject.Inject;
import javax.inject.Singleton;
import java.util.*;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.TimeUnit;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

@Slf4j
@Singleton
public class KCService {


    private static final String RL_CHAT_CMD_PLUGIN_NAME = ChatCommandsPlugin.class.getSimpleName().toLowerCase();
    private static final String RL_LOOT_PLUGIN_NAME = LootTrackerPlugin.class.getSimpleName().toLowerCase();
    private static final Pattern CLUE_SCROLL_REGEX = Pattern.compile("You have completed (?<scrollCount>\\d+) (?<scrollType>\\w+) Treasure Trails\\.");

    private ConfigManager configManager;


    private Gson gson;

    @Inject
    private ScheduledExecutorService executor;

    private Rarity rarityService;

    @Inject
    private DropTrackerPlugin plugin;

    private List<Integer> whispererIds = Arrays.asList(12204, 12205, 12206, 12207);


    private static final Cache<String, Integer> killCounts = CacheBuilder.newBuilder()
            .expireAfterAccess(10, TimeUnit.MINUTES)
            .maximumSize(64L)
            .build();


    @Inject
    public KCService(ConfigManager configManager, Gson gson,
                     ScheduledExecutorService executor,
                     Rarity rarityService, DropTrackerPlugin plugin) {
        this.configManager = configManager;
        this.gson = gson;
        this.rarityService = rarityService;
        this.executor = executor;
        this.plugin = plugin;
    }

    public void reset() {
        plugin.lastDrop = null;
        KCService.killCounts.invalidateAll();
    }

    @SuppressWarnings("deprecation")
    public void onNpcKill(NpcLootReceived event) {
        NPC npc = event.getNpc();
        int id = npc.getId();
        if (whispererIds.contains(id)) {
            return;
        }

        String name = npc.getName();
        if (NpcUtilities.GAUNTLET_BOSS.equals(name) || NpcUtilities.CG_BOSS.equals(name)) {
            // already handled by onGameMessage
            return;
        }
        if (name != null) {
            this.incrementKills(LootRecordType.NPC, name, event.getItems());
        }
    }

    public void onPlayerKill(PlayerLootReceived event) {
        String name = event.getPlayer().getName();
        if (name != null) {
            this.incrementKills(LootRecordType.PLAYER, name, event.getItems());
        }
    }

    public void onLoot(LootReceived event) {
        boolean increment;
        switch (event.getType()) {
            case NPC:
                // Special case: upstream fires LootReceived for the whisperer, but not NpcLootReceived
                increment = "The Whisperer".equalsIgnoreCase(event.getName());
                break;
            case PLAYER:
                increment = false; // handled by PlayerLootReceived
                break;
            default:
                increment = true;
                break;
        }

        if (increment) {
            this.incrementKills(event.getType(), NpcUtilities.getStandardizedSource(event, plugin), event.getItems());
        }
    }
    public void onServerNpcLoot(ServerNpcLoot event) {
        /* Currently only called for Yama events */
        this.incrementKills(LootRecordType.NPC, event.getComposition().getName(), event.getItems());
    }

    public void onGameMessage(String message) {
        // update cached clue casket count
        Map.Entry<String, Integer> clue = parseClue(message);
        if (clue != null) {
            String tier = ucFirst(clue.getKey());
            int count = clue.getValue() - 1; // decremented since onLoot will increment
            killCounts.put("Clue Scroll (" + tier + ")", count);
            return;
        }

        NpcUtilities.parseBoss(message, plugin).ifPresent(pair -> {
            String boss = pair.getKey();
            Integer kc = pair.getValue();

            // Update cache. We store kc - 1 since onNpcLootReceived will increment; kc - 1 + 1 == kc
            String cacheKey = getCacheKey(LootRecordType.UNKNOWN, boss);
            killCounts.asMap().merge(cacheKey, kc - 1, Math::max);

            if (boss.equals(NpcUtilities.GAUNTLET_BOSS) || boss.equals(NpcUtilities.CG_BOSS) || boss.startsWith(NpcUtilities.TOA) || boss.startsWith(NpcUtilities.TOB) || boss.startsWith(NpcUtilities.COX)) {
                // populate lastDrop to workaround loot tracker quirks

                if (!isPluginDisabled(RL_LOOT_PLUGIN_NAME)) {   
                    // onLoot will already increment kc, no need to schedule task below.
                    // this early return also simplifies our test code
                    return;
                }
            }

            // However: we don't know if boss message appeared before/after the loot event.
            // If after, we should store kc. If before, we should store kc - 1.
            // Given this uncertainty, we wait so that the loot event has passed, and then we can store latest kc.

            
            /* -- We are using the executor here -- */
            executor.schedule(() -> {
                killCounts.asMap().merge(cacheKey, kc, Math::max);
            }, 15, TimeUnit.SECONDS);
        });
    }

    @Nullable
    public Integer getKillCount(LootRecordType type, String sourceName) {
        if (sourceName == null) return null;
        // This static method is deprecated - use instance method instead
        return killCounts.getIfPresent(getCacheKey(type, sourceName));
    }

    @Nullable
    public Integer getKillCountWithStorage(LootRecordType type, String sourceName) {
        if (sourceName == null) return null;
        Integer stored = getStoredKillCount(type, sourceName);
        if (stored != null) {
            return killCounts.asMap().merge(getCacheKey(type, sourceName), stored, Math::max);
        }
        return killCounts.getIfPresent(getCacheKey(type, sourceName));
    }

    private void incrementKills(@NotNull LootRecordType type, @NotNull String sourceName, @NotNull Collection<ItemStack> items) {
        String cacheKey = getCacheKey(type, sourceName);
        killCounts.asMap().compute(cacheKey, (key, cachedKc) -> {
            if (cachedKc != null) {
                // increment kill count
                return cachedKc + 1;
            } else {
                // pull kc from loot tracker or chat commands plugin
                Integer kc = getStoredKillCount(type, sourceName);
                // increment if found
                return kc != null ? kc + 1 : null;
            }
        });
    }

    /**
     * @param type       {@link LootReceived#getType()}
     * @param sourceName {@link NPC#getName()} or {@link LootReceived#getName()}
     * @return the kill count stored by base runelite plugins
     */
    @Nullable
    private Integer getStoredKillCount(@NotNull LootRecordType type, @NotNull String sourceName) {
        // get kc from base runelite chat commands plugin (if enabled)
        if (!isPluginDisabled(RL_CHAT_CMD_PLUGIN_NAME)) {
            Integer kc = configManager.getRSProfileConfiguration("killcount", cleanBossName(sourceName), int.class);
            if (kc != null) {
                return kc - 1; // decremented since chat event typically occurs before loot event
            }
        }

        if (isPluginDisabled(RL_LOOT_PLUGIN_NAME)) {
            // assume stored kc is useless if loot tracker plugin is disabled
            return null;
        }
        String json = configManager.getConfiguration(LootTrackerConfig.GROUP,
                configManager.getRSProfileKey(),
                "drops_" + type + "_" + sourceName
        );
        if (json == null) {
            // no kc stored implies first kill
            return 0;
        }
        try {
            int kc = gson.fromJson(json, SerializedDrop.class).getKills();

            // loot tracker doesn't count kill if no loot - https://github.com/runelite/runelite/issues/5077
            OptionalDouble nothingProbability = rarityService.getRarity(sourceName, -1, 0);
            if (nothingProbability.isPresent() && nothingProbability.getAsDouble() < 1.0) {
                // estimate the actual kc (including kills with no loot)
                kc = (int) Math.round(kc / (1 - nothingProbability.getAsDouble()));
            }

            return kc;
        } catch (JsonSyntaxException e) {
            // should not occur unless loot tracker changes stored loot POJO structure
            log.warn("Failed to read kills from loot tracker config", e);
            return null;
        }
    }

    /**
     * @param boss {@link LootReceived#getName()}
     * @return lowercase boss name that {@link ChatCommandsPlugin} uses during serialization
     */
    private static String cleanBossName(String boss) {
        if ("The Gauntlet".equalsIgnoreCase(boss)) return "gauntlet";
        if ("The Leviathan".equalsIgnoreCase(boss)) return "leviathan";
        if ("The Whisperer".equalsIgnoreCase(boss)) return "whisperer";
        if (boss.startsWith("Barrows")) return "barrows chests";
        if (boss.endsWith("Hallowed Sepulchre)")) return "hallowed sepulchre";
        if (boss.endsWith("Tempoross)")) return "tempoross";
        if (boss.endsWith("Wintertodt)")) return "wintertodt";
        return StringUtils.remove(boss.toLowerCase(), ':');
    }

    private static String getCacheKey(@NotNull LootRecordType type, @NotNull String sourceName) {
        switch (type) {
            case PICKPOCKET:
                return "pickpocket_" + sourceName;
            case PLAYER:
                return "player_" + sourceName;
            default:
                if ("The Gauntlet".equals(sourceName)) return NpcUtilities.GAUNTLET_BOSS;
                if (NpcUtilities.CG_NAME.equals(sourceName)) return NpcUtilities.CG_BOSS;
                return sourceName;
        }
    }
    @Nullable
    public static Map.Entry<String, Integer> parseClue(String gameMessage) {
        Matcher clueMatcher = CLUE_SCROLL_REGEX.matcher(gameMessage);
        if (!clueMatcher.find()) return null;
        String tier = clueMatcher.group("scrollType");
        String count = clueMatcher.group("scrollCount");
        return Map.entry(tier, Integer.parseInt(count));
    }

    public String ucFirst(@NotNull String text) {
        if (text.length() < 2) return text.toUpperCase();
        return Character.toUpperCase(text.charAt(0)) + text.substring(1).toLowerCase();
    }

    protected boolean isPluginDisabled(String simpleLowerClassName) {
        return "false".equals(configManager.getConfiguration(RuneLiteConfig.GROUP_NAME, simpleLowerClassName));
    }
}

package io.droptracker.service;

import com.google.gson.Gson;
import com.google.gson.annotations.SerializedName;
import io.droptracker.DropTrackerConfig;
import io.droptracker.api.DropTrackerApi;
import io.droptracker.api.UrlManager;
import io.droptracker.models.CustomWebhookBody;
import io.droptracker.models.api.GroupConfig;
import io.droptracker.models.submissions.SubmissionType;
import io.droptracker.models.submissions.ValidSubmission;
import io.droptracker.util.ChatMessageUtil;
import io.droptracker.util.DebugLogger;
import lombok.Getter;
import lombok.Setter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.WorldType;
import net.runelite.api.annotations.Component;
import net.runelite.api.gameval.InterfaceID;
import net.runelite.api.widgets.Widget;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.ui.DrawManager;
import net.runelite.client.util.Text;
import okhttp3.*;
import okio.Buffer;
import org.jetbrains.annotations.NotNull;

import javax.imageio.ImageIO;
import javax.inject.Inject;
import javax.inject.Singleton;
import java.awt.image.BufferedImage;
import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.ScheduledExecutorService;

import static net.runelite.http.api.RuneLiteAPI.GSON;

@Slf4j
@Singleton
public class SubmissionManager {

    private final DropTrackerConfig config;
    private final DropTrackerApi api;
    private final ChatMessageUtil chatMessageUtil;
    private final Gson gson;
    private final OkHttpClient okHttpClient;
    private final Client client;
    private final ClientThread clientThread;
    private final UrlManager urlManager;
    private final DrawManager drawManager;
    /// Store a list of submissions that the player has received which qualified for a notification to be sent
    @Getter
    private final List<ValidSubmission> validSubmissions = new ArrayList<>();
    /// Callback for UI updates when submissions change
    @Setter
    private SubmissionUpdateCallback updateCallback;
    @Setter
    private boolean updatesEnabled = true;
    @Inject
    private ScheduledExecutorService executor;

    // Variables to store counts and values for the UI
    public int totalSubmissions = 0;
    public int notificationsSent = 0;
    public int failedSubmissions = 0;
    public Long totalValue = 0L;
    
    @Inject
    public SubmissionManager(DropTrackerConfig config, DropTrackerApi api, ChatMessageUtil chatMessageUtil, Gson gson, OkHttpClient okHttpClient, Client client, ClientThread clientThread, UrlManager urlManager, DrawManager drawManager) {
        this.config = config;
        this.api = api;
        this.chatMessageUtil = chatMessageUtil;
        this.gson = gson;
        this.okHttpClient = okHttpClient;
        this.client = client;
        this.clientThread = clientThread;
        this.urlManager = urlManager;
        this.drawManager = drawManager;
    }

    public static void hideWidget(Client client, ClientThread clientThread, @Component int info) {
        Widget widget = client.getWidget(info);
        if (widget != null) {
            widget.setHidden(true);
        }
    }
    public static void showWidget(Client client, ClientThread clientThread, @Component int info) {
        clientThread.invoke(() -> {
            Widget widget = client.getWidget(info);
            if (widget != null)
                widget.setHidden(false);
        });
    }

    private static byte[] convertImageToByteArray(BufferedImage bufferedImage) throws IOException {
        ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();
        ImageIO.write(bufferedImage, "jpeg", byteArrayOutputStream);
        return byteArrayOutputStream.toByteArray();
    }

    /**
     * Notifies the UI callback that submissions have been updated
     */
    private void notifyUpdateCallback() {
        if (updatesEnabled && updateCallback != null) {
            updateCallback.onSubmissionsUpdated();
        }
    }

    public void sendDataToDropTracker(CustomWebhookBody webhook, SubmissionType type) {
        /* Drops are still handled in a separate method due to the way values are handled */
        /* Here, we send the webhook and submission type, and check against the stored group config values
         * to determine whether the submission "should" create a notification on Discord based on their group settings.
         * If so, we create a ValidSubmission object and add it to the in-memory list, allowing the UI to display the submission,
         * and later updating the status of it with whether or not it properly got sent to the API and had its notifications
         * processed properly for the target group(s).
         */
        var requiredScreenshot = false;
        var shouldHideDm = config.hideDMs();

        switch (type) {
            case DROP:
                // We do not need to do anything for drop submissions as the required processing is done prior to being sent here
                break;

            case KILL_TIME:
                // Kc / kill time
                List<CustomWebhookBody.Embed> embeds = webhook.getEmbeds();
                if (!config.pbEmbeds()) {
                    return;
                }
                boolean isPb = false;
                for (CustomWebhookBody.Embed embed : embeds) {
                    for (CustomWebhookBody.Field field : embed.getFields()) {
                        if (field.getName().equalsIgnoreCase("is_pb")) {
                            if (field.getValue().equalsIgnoreCase("true")) {
                                isPb = true;
                            }
                        }
                    }
                }
                if (config.screenshotPBs() && isPb) {
                    requiredScreenshot = true;
                }
                // Check if we should create any ValidSubmission objects for this pb
                if (isPb && config.useApi()) {
                    ValidSubmission pbSubmission = null;
                    for (GroupConfig groupConfig : api.getGroupConfigs()) {
                        if (groupConfig.isSendPbs()) {
                            if (groupConfig.isOnlyScreenshots()) {
                                if (!requiredScreenshot) {
                                    continue; // Skip this group if screenshots required but not happening
                                }
                            }

                            // Create or find existing submission for this webhook
                            if (pbSubmission == null) {
                                pbSubmission = new ValidSubmission(webhook, groupConfig.getGroupId(), SubmissionType.KILL_TIME);
                                addSubmissionToMemory(pbSubmission);
                            } else {
                                pbSubmission.addGroupId(groupConfig.getGroupId());
                            }
                        }
                    }
                }
                break;

            case COLLECTION_LOG:
                if (!config.clogEmbeds()) {
                    return;
                }
                if (config.screenshotNewClogs()) {
                    requiredScreenshot = true;
                }
                // Create ValidSubmission for collection log entries
                ValidSubmission clogSubmission = null;
                // Check if we should create any ValidSubmission objects for this collection log slot
                if (config.useApi()) {
                    for (GroupConfig groupConfig : api.getGroupConfigs()) {
                        if (groupConfig.isSendClogs()) {
                            if (groupConfig.isOnlyScreenshots()) {
                                if (!requiredScreenshot) {
                                    continue; // Skip this group if screenshots required but not happening
                                }
                            }

                            // Create or find existing submission for this webhook
                            if (clogSubmission == null) {
                                clogSubmission = new ValidSubmission(webhook, groupConfig.getGroupId(), SubmissionType.COLLECTION_LOG);
                                addSubmissionToMemory(clogSubmission);
                            } else {
                                clogSubmission.addGroupId(groupConfig.getGroupId());
                            }
                        }
                    }
                }
                break;

            case COMBAT_ACHIEVEMENT:
                // combat achievements
                if (!config.caEmbeds()) {
                    return;
                }
                if (config.screenshotCAs()) {
                    requiredScreenshot = true;
                }
                // Create ValidSubmission for combat achievements
                ValidSubmission caSubmission = null;
                // Check if we should create any ValidSubmission objects for this combat achievement
                if (config.useApi()) {
                    for (GroupConfig groupConfig : api.getGroupConfigs()) {
                        if (groupConfig.isSendCAs()) {
                            if (groupConfig.isOnlyScreenshots()) {
                                if (!requiredScreenshot) {
                                    continue; // Skip this group if screenshots required but not happening
                                }
                            }

                            // Create or find existing submission for this webhook
                            if (caSubmission == null) {
                                caSubmission = new ValidSubmission(webhook, groupConfig.getGroupId(), SubmissionType.COMBAT_ACHIEVEMENT);
                                addSubmissionToMemory(caSubmission);
                            } else {
                                caSubmission.addGroupId(groupConfig.getGroupId());
                            }
                        }
                    }
                }
                break;

            case LEVEL_UP:
                if (!config.levelEmbed()){
                    return;
                }
                if(config.screenshotLevel()){
                    requiredScreenshot = true;
                }
                CustomWebhookBody.Embed embed = webhook.getEmbeds().get(0);
                // Check the skills that leveled up
                for (CustomWebhookBody.Field field : embed.getFields()) {
                    String fieldName = field.getName();
                    if (fieldName.endsWith("_level") && !fieldName.equals("total_level") && !fieldName.equals("combat_level")) {
                        int newLevel = Integer.parseInt(field.getValue());
                        // Check if this level qualifies for a screenshot
                        if (newLevel >= config.minLevelToScreenshot()) {
                            break;
                        }
                    }
                }
                break;

            case QUEST_COMPLETION:
                // TODO -- need to add group config values for tracking for ValidSubmission object creation where necessary later
                if (!config.questsEmbed()) {
                    return;
                }
                if (config.screenshotQuests()) {
                    // TODO -- need to add group config values for tracking for ValidSubmission object creation where necessary later
                    requiredScreenshot = true;
                }
                break;

            case EXPERIENCE:
                /* We don't need to take screenshots for experience */
                break;

            case EXPERIENCE_MILESTONE:
                /* We don't need to take screenshots for experience milestones */
                break;

            case ADVENTURE_LOG:
                // Nothing extra needs to be done for adventure log data
                break;

            case PET:
                // TODO -- need to add group config values for tracking for ValidSubmission object creation where necessary later
                if(!config.petEmbeds()){
                    break;
                }
                if (config.screenshotPets()) {
                    requiredScreenshot = true;
                }
                break;
        }

        // UI notification is handled by addSubmissionToMemory() when submissions are actually added

        if (requiredScreenshot) {
            captureScreenshotWithPrivacy(webhook, shouldHideDm);
        } else {
            sendDataToDropTracker(webhook, (byte[]) null);
        }
    }

    public void sendDataToDropTracker(CustomWebhookBody customWebhookBody, int totalValue, int singleValue, boolean valueModified) {
        // Handles sending drops exclusively
        if (!config.lootEmbeds()) {
            return;
        }

        boolean requiredScreenshot = config.screenshotDrops() && totalValue > config.screenshotValue() || valueModified;

        // Create ValidSubmission for drops only when they qualify for group notifications
        ValidSubmission dropSubmission = null;
        
        // Check each group configuration to see if this drop qualifies
        if (config.useApi()) {
            for (GroupConfig groupConfig : api.getGroupConfigs()) {
                if (groupConfig.isSendDrops() && totalValue >= groupConfig.getMinimumDropValue()) {
                    // Check if group allows stacked items
                    if (!groupConfig.isSendStackedItems() && totalValue > singleValue) {
                        continue; // Skip this group if items were stacked but group disabled that
                    }

                    if (groupConfig.isOnlyScreenshots()) {
                        if (!requiredScreenshot) {
                            continue; // Skip this group if screenshots required but not happening
                        }
                    }

                    // Create or find existing submission for this webhook
                    if (dropSubmission == null) {
                        dropSubmission = new ValidSubmission(customWebhookBody, groupConfig.getGroupId(), SubmissionType.DROP);
                        addSubmissionToMemory(dropSubmission);
                    } else {
                        dropSubmission.addGroupId(groupConfig.getGroupId());
                    }
                }
            }
        }
        
        // Update total value statistics  
        this.totalValue += (long) totalValue;

        // Notify UI if submissions were added
        if (dropSubmission != null) {
            notifyUpdateCallback();
        }

        if (requiredScreenshot) {
            boolean shouldHideDm = config.hideDMs();
            captureScreenshotWithPrivacy(customWebhookBody, shouldHideDm);
        } else {
            sendDataToDropTracker(customWebhookBody, (byte[]) null);
        }
    }

    private void sendDataToDropTracker(CustomWebhookBody customWebhookBody, byte[] screenshot) {
        DebugLogger.log("data has arrived at final sendDataToDropTracker method; == " + customWebhookBody.toString());
        sendWebhookWithRetry(customWebhookBody, screenshot, 0);
    }

    private static final long BASE_RETRY_DELAY_MS = 1000L;

    private void sendWebhookWithRetry(CustomWebhookBody webhook, byte[] screenshot, int attempt) {
        if (isFakeWorld()) {
            DebugLogger.log("Returning due to this being a fake world");
            return;
        }

        MultipartBody.Builder requestBodyBuilder = new MultipartBody.Builder()
                .setType(MultipartBody.FORM)
                .addFormDataPart("payload_json", GSON.toJson(webhook));

        if (screenshot != null) {
            requestBodyBuilder.addFormDataPart("file", "image.jpeg",
                    RequestBody.create(MediaType.parse("image/jpeg"), screenshot));
        }

        MultipartBody requestBody = requestBodyBuilder.build();

        String url;
        if (!config.useApi()) {
            try {
                url = UrlManager.getRandomUrl();
            } catch (Exception e) {
                return; // Exit gracefully
            }
        } else {
            url = api.getApiUrl() + "/webhook";
        }
        DebugLogger.log("Using the following URL for this submission: " + url);
        HttpUrl u = HttpUrl.parse(url);
        if (u == null || !urlManager.isValidDiscordWebhookUrl(u)) {
            log.debug("Invalid or malformed webhook URL: {}", url);
            return;
        }

        Request request = new Request.Builder()
                .url(url)
                .post(requestBody)
                .build();

        ValidSubmission validSubmission = findValidSubmissionForWebhook(webhook);

        okHttpClient.newCall(request).enqueue(new Callback() {
            @Override
            public void onFailure(@NotNull Call call, @NotNull IOException e) {
                DebugLogger.log("onFailure received; scheduleRetryOrFail method called...");
                scheduleRetryOrFail(webhook, screenshot, validSubmission, attempt, e);
            }

            @Override
            public void onResponse(@NotNull Call call, @NotNull Response response) throws IOException {
                try (ResponseBody body = response.body()) {
                    if (config.useApi()) {
                        DebugLogger.log("onResponse received with API enabled...");
                        api.lastCommunicationTime = (int) (System.currentTimeMillis() / 1000);
                        if (body != null) {
                            try {
                                String bodyString = body.string();
                                if (!bodyString.isEmpty()) {
                                    ApiResponse apiResponse = gson.fromJson(bodyString, ApiResponse.class);
                                    if (apiResponse != null) {
                                        String noticeMessage = apiResponse.getNotice();
                                        if (noticeMessage != null && !noticeMessage.isEmpty() && config.receiveInGameMessages()) {
                                            chatMessageUtil.sendChatMessage(noticeMessage);
                                        }
                                        String updateMessage = apiResponse.getRankUpdate();
                                        if (updateMessage != null && !updateMessage.isEmpty() && config.receiveInGameMessages()) {
                                            chatMessageUtil.sendChatMessage(updateMessage);
                                        }
                                    }
                                }
                            } catch (Exception e) {
                                log.debug("Failed to parse API response: {}", e.getMessage());
                            }
                        }
                    }

                    if (!response.isSuccessful()) {
                        int code = response.code();

                        if (code == 400 || code == 401 || code == 403) {
                            if (validSubmission != null) {
                                validSubmission.markAsFailed("HTTP " + code);
                                notifyUpdateCallback();
                            }
                            return;
                        }

                        if (code == 404) {
                            executor.submit(() -> {
                                try {
                                    urlManager.fetchNewList();
                                } catch (Exception ex) {
                                    log.debug("Failed to fetch new webhook list: {}", ex.getMessage());
                                }
                            });
                        }

                        scheduleRetryOrFail(webhook, screenshot, validSubmission, attempt, new IOException("HTTP " + code + ": " + response.message()));
                        return;
                    }

                    // Success
                    if (validSubmission != null) {
                        validSubmission.markAsSuccess();
                        notifyUpdateCallback();
                    }
                    notificationsSent++;

                    if (config.useApi() && validSubmission != null && validSubmission.getUuid() != null && !validSubmission.getUuid().isEmpty()) {
                        executor.submit(() -> {
                            try {
                                boolean processed = api.checkSubmissionProcessed(validSubmission.getUuid());
                                if (processed) {
                                    validSubmission.markAsProcessed();
                                    if (updatesEnabled) {
                                        notifyUpdateCallback();
                                    }
                                }
                            } catch (IOException ignored) {
                            }
                        });
                    }
                }
            }
        });
    }

    private void scheduleRetryOrFail(CustomWebhookBody webhook, byte[] screenshot, ValidSubmission validSubmission, int attempt, Throwable e) {
        int maxAttempts = 10;
        if (attempt < maxAttempts) {
            long delay = BASE_RETRY_DELAY_MS * (1L << Math.min(attempt, 16));
            if (validSubmission != null) {
                validSubmission.markAsRetrying();
                notifyUpdateCallback();
            }
            executor.schedule(() -> sendWebhookWithRetry(webhook, screenshot, attempt + 1), delay, java.util.concurrent.TimeUnit.MILLISECONDS);
            log.debug("Scheduled webhook retry in {} ms (attempt {}/{})", delay, attempt + 1, maxAttempts);
        } else {
            if (validSubmission != null) {
                String reason = e != null && e.getMessage() != null ? e.getMessage() : "Retry limit reached";
                validSubmission.markAsFailed(reason);
                notifyUpdateCallback();
            }
            failedSubmissions++;
            log.warn("Exhausted retry attempts when sending webhook");
        }
    }

    public void addSubmissionToMemory(ValidSubmission validSubmission) {
        if (validSubmissions.size() > 20) {
            // Remove oldest submissions once the list starts to exceed 20
            validSubmissions.remove(0);
        }
        validSubmissions.add(validSubmission);
        
        // Increment total submissions when player generates a qualifying submission
        totalSubmissions++;
        
        notifyUpdateCallback();
    }

    /**
     * Retry a failed submission using the stored webhook data
     *
     * @param validSubmission The submission to retry
     */
    public void retrySubmission(ValidSubmission validSubmission) {
        if (validSubmission == null || validSubmission.getOriginalWebhook() == null) {
            log.warn("Cannot retry submission: missing webhook data");
            return;
        }
        validSubmission.markAsRetrying();
        notifyUpdateCallback();
        sendWebhookWithRetry(validSubmission.getOriginalWebhook(), null, 0);
    }

    /**
     * Remove a submission from the in-memory list (e.g., when user dismisses it)
     *
     * @param validSubmission The submission to remove
     */
    public void removeSubmission(ValidSubmission validSubmission) {
        validSubmissions.remove(validSubmission);
        notifyUpdateCallback();
    }
    
    /**
     * Get retry service statistics for UI display
     */
    public String getRetryStatusText() {
        // Simple status for UI: based on last communication time; detailed queue/health removed
        return "";
    }
    
    /**
     * Clear the retry queue (for manual intervention)
     */
    public void clearRetryQueue() {
        // No-op after removing queue; keep method to avoid UI breakage if referenced elsewhere
        notifyUpdateCallback();
    }
    
    /**
     * Enable or disable retry processing
     */
    public void setRetryProcessingEnabled(boolean enabled) {
        // No-op in simplified retry model
    }

    private boolean isFakeWorld() {
        var worldType = client.getWorldType();
        return worldType.contains(WorldType.BETA_WORLD)
                || worldType.contains(WorldType.DEADMAN)
                || worldType.contains(WorldType.FRESH_START_WORLD)
                || worldType.contains(WorldType.LAST_MAN_STANDING)
                || worldType.contains(WorldType.NOSAVE_MODE)
                || worldType.contains(WorldType.PVP_ARENA)
                || worldType.contains(WorldType.QUEST_SPEEDRUNNING)
                || worldType.contains(WorldType.SEASONAL)
                || worldType.contains(WorldType.TOURNAMENT_WORLD);
    }

    public String sanitize(String str) {
        if (str == null || str.isEmpty())
            return "";
        return Text.removeTags(str.replace("<br>", "\n")).replace('\u00A0', ' ').trim();
    }

    private void captureScreenshotWithPrivacy(CustomWebhookBody webhook, boolean hideDMs) {
        // First hide DMs if configured
        hideWidget(client, clientThread, InterfaceID.PmChat.CONTAINER);

        drawManager.requestNextFrameListener(image -> {
            BufferedImage bufferedImage = (BufferedImage) image;

            // Restore DM visibility immediately after capturing
            showWidget(client, clientThread, InterfaceID.PmChat.CONTAINER);

            byte[] imageBytes = null;
            try {
                imageBytes = convertImageToByteArray(bufferedImage);
                if (imageBytes.length > 5 * 1024 * 1024) {
                    // perform compression here
                }
            } catch (IOException e) {
                log.error("Error converting image to byte array", e);
            }

            sendDataToDropTracker(webhook, imageBytes);
        });
    }
    
    /**
     * Process a queued submission from the retry service
     */
    // Queue processing removed in simplified retry model
    
    /**
     * Find a ValidSubmission that matches the given webhook
     */
    private ValidSubmission findValidSubmissionForWebhook(CustomWebhookBody webhook) {
        if (webhook == null) return null;
        
        // Try to match based on webhook content - prefer identity match
        for (ValidSubmission submission : validSubmissions) {
            if (submission.getOriginalWebhook() == webhook) {
                return submission;
            }
        }
        
        // Try to match based on recent submissions with pending status
        for (int i = validSubmissions.size() - 1; i >= 0 && i >= validSubmissions.size() - 5; i--) {
            ValidSubmission submission = validSubmissions.get(i);
            if ("pending".equals(submission.getStatus()) || "retrying".equals(submission.getStatus())) {
                return submission;
            }
        }
        
        return null;
    }
    
    /**
     * Determine the submission type from webhook content
     */
    private SubmissionType getSubmissionTypeFromWebhook(CustomWebhookBody webhook) {
        if (webhook == null || webhook.getEmbeds() == null || webhook.getEmbeds().isEmpty()) {
            return SubmissionType.DROP; // Default fallback
        }
        
        CustomWebhookBody.Embed embed = webhook.getEmbeds().get(0);
        String title = embed.getTitle();
        
        if (title != null) {
            String lowerTitle = title.toLowerCase();
            if (lowerTitle.contains("personal best") || lowerTitle.contains("pb")) {
                return SubmissionType.KILL_TIME;
            }
            if (lowerTitle.contains("collection log") || lowerTitle.contains("clog")) {
                return SubmissionType.COLLECTION_LOG;
            }
            if (lowerTitle.contains("combat achievement") || lowerTitle.contains("ca")) {
                return SubmissionType.COMBAT_ACHIEVEMENT;
            }
            if (lowerTitle.contains("level") || lowerTitle.contains("leveled")) {
                return SubmissionType.LEVEL_UP;
            }
            if (lowerTitle.contains("quest")) {
                return SubmissionType.QUEST_COMPLETION;
            }
            if (lowerTitle.contains("pet")) {
                return SubmissionType.PET;
            }
            if (lowerTitle.contains("experience") || lowerTitle.contains("xp")) {
                return SubmissionType.EXPERIENCE;
            }
        }
        
        return SubmissionType.DROP; // Default fallback
    }

    /**
     * Poll the API to update statuses of pending submissions. Only runs if API is enabled.
     * This should be invoked periodically by the UI timer when the side panel is visible.
     */
    public void checkPendingStatuses() {
        if (!config.useApi()) {
            return;
        }
        // Avoid blocking EDT: schedule on executor
        executor.submit(() -> {
            try {
                boolean changed = false;
                for (ValidSubmission submission : new java.util.ArrayList<>(validSubmissions)) {
                    String status = submission.getStatus();
                    if (status == null) {
                        continue;
                    }
                    // Poll anything not completed (processed) and not failed
                    if (!"processed".equalsIgnoreCase(status) && !"failed".equalsIgnoreCase(status)) {
                        String uuid = submission.getUuid();
                        if (uuid == null || uuid.isEmpty()) {
                            continue;
                        }
                        try {
                            boolean processed = api.checkSubmissionProcessed(uuid);
                            if (processed) {
                                submission.markAsProcessed();
                                changed = true;
                            }
                        } catch (IOException e) {
                            // Swallow per-submission errors to continue polling others
                            log.debug("/check failed for uuid {}: {}", uuid, e.getMessage());
                        }
                    }
                }
                if (changed && updatesEnabled) {
                    notifyUpdateCallback();
                }
            } catch (Exception e) {
                log.debug("Error while checking pending statuses: {}", e.getMessage());
            }
        });
    }

    public interface SubmissionUpdateCallback {
        void onSubmissionsUpdated();
    }

    @Getter
    private static class ApiResponse {
        @SerializedName("notice")
        private String notice;

        @SerializedName("rank_update")
        private String rankUpdate;
        
        @SerializedName("status")
        private String status;
        
        @SerializedName("processed")
        private Boolean processed;
        
        @SerializedName("submission_id")
        private String submissionId;
    }

}

package io.droptracker.events;

import lombok.AccessLevel;
import lombok.Setter;
import net.runelite.api.gameval.VarbitID;
import net.runelite.http.api.loottracker.LootRecordType;
import org.apache.commons.lang3.StringUtils;
import org.jetbrains.annotations.VisibleForTesting;

import javax.inject.Inject;
import javax.inject.Singleton;

import java.util.HashMap;
import java.util.Map;
import java.util.Optional;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import io.droptracker.service.KCService;
import io.droptracker.util.ItemIDSearch;
import io.droptracker.models.CustomWebhookBody;
import io.droptracker.models.submissions.SubmissionType;
import lombok.extern.slf4j.Slf4j;

@Slf4j
@Singleton
public class PetHandler extends BaseEventHandler {

    public static final String UNTRADEABLE_WARNING = "Pet Notifier cannot reliably identify pet names unless you enable the game setting: Untradeable loot notifications";

    @VisibleForTesting
    static final Pattern PET_REGEX = Pattern.compile("You (?:have a funny feeling like you|feel something weird sneaking).*");

    @VisibleForTesting
    static final Pattern CLAN_REGEX = Pattern.compile("\\b(?<user>[\\w\\s]+) (?:has a funny feeling like .+ followed|feels something weird sneaking into .+ backpack): (?<pet>.+) at (?<milestone>.+)");

    private static final Pattern UNTRADEABLE_REGEX = Pattern.compile("Untradeable drop: (.+)");
    private static final Pattern COLLECTION_LOG_REGEX = Pattern.compile("New item added to your collection log: (.+)");
    
    /**
     * The maximum number ticks to wait for milestone to be populated,
     * before firing notification with only the petName.
     */
    @VisibleForTesting
    static final int MAX_TICKS_WAIT = 5;

    /**
     * Tracks the number of ticks that occur where milestone is not populated
     * while petName is populated.
     */
    private final AtomicInteger ticksWaited = new AtomicInteger();

    @Inject
    private ItemIDSearch itemSearcher;

    @Inject
    private KCService kcService;

    @Setter(AccessLevel.PRIVATE)
    private volatile String petName = null;

    private volatile String milestone = null;

    private volatile boolean duplicate = false;

    private volatile boolean backpack = false;

    private volatile boolean collection = false;

    private static final String PRIMED_NAME = "";

    @Override
    public boolean isEnabled() {
        return true; // Always track pets
    }

    public void onGameMessage(String chatMessage) {
        if (!isEnabled()) return;

        if (petName == null) {
            if (PET_REGEX.matcher(chatMessage).matches()) {
                // Prime the notifier to trigger next tick
                this.petName = PRIMED_NAME;
                this.duplicate = chatMessage.contains("would have been");
                this.backpack = chatMessage.contains(" backpack");
            }
        } else if (PRIMED_NAME.equals(petName) || !collection) {
            parseItemFromGameMessage(chatMessage)
                    .filter(item -> item.itemName.startsWith("Pet ") || isPetName(item.itemName))
                    .ifPresent(parseResult -> {
                        this.petName = parseResult.itemName;
                        if (parseResult.collectionLog) {
                            this.collection = true;
                        }
                    });
        }
    }

    public void onClanChatNotification(String message) {
        if (petName == null) {
            // We have not received the normal message about a pet drop, so this clan message cannot be relevant to us
            return;
        }

        Matcher matcher = CLAN_REGEX.matcher(message);
        if (matcher.find()) {
            String user = matcher.group("user").trim();
            if (user.equals(getPlayerName())) {
                this.petName = matcher.group("pet");
                this.milestone = StringUtils.removeEnd(matcher.group("milestone"), ".");
            }
        }
    }

    public void onTick() {
        if (petName == null) return;

        if (milestone != null || ticksWaited.incrementAndGet() > MAX_TICKS_WAIT) {
            // ensure notifier was not disabled during wait ticks
            if (isEnabled()) {
                this.handleNotify();
            }
            this.reset();
        }
    }

    public void reset() {
        this.petName = null;
        this.milestone = null;
        this.duplicate = false;
        this.backpack = false;
        this.collection = false;
        this.ticksWaited.set(0);
    }

    private void handleNotify() {
        Boolean previouslyOwned;
        if (duplicate) {
            previouslyOwned = true;
        } else if (client.getVarbitValue(VarbitID.OPTION_COLLECTION_NEW_ITEM) % 2 == 1) {
            // when collection log chat notification is enabled, presence or absence of notification indicates ownership history
            previouslyOwned = !collection;
        } else {
            previouslyOwned = null;
        }

        String gameMessage;
        if (backpack) {
            gameMessage = "feels something weird sneaking into their backpack";
        } else if (previouslyOwned != null && previouslyOwned) {
            gameMessage = "has a funny feeling like they would have been followed...";
        } else {
            gameMessage = "has a funny feeling like they're being followed";
        }

        // Create webhook body
        CustomWebhookBody webhook = createWebhookBody(getPlayerName() + " received a pet!");
        CustomWebhookBody.Embed embed = createEmbed("Pet Drop!", "pet");
        
        // Add fields
        Map<String, Object> fieldData = new HashMap<>();
        fieldData.put("pet_name", petName != null && !petName.isEmpty() ? ucFirst(petName) : "Unknown Pet");
        fieldData.put("game_message", gameMessage);
        fieldData.put("duplicate", duplicate);
        
        if (milestone != null) {
            fieldData.put("milestone", milestone);
        }
        
        if (previouslyOwned != null) {
            fieldData.put("previously_owned", previouslyOwned);
        }
        
        // Try to get KC information for the pet source
        String pet = petName != null ? ucFirst(petName) : null;
        if (pet != null && PET_TO_SOURCE.containsKey(pet)) {
            String source = PET_TO_SOURCE.get(pet);
            Integer kc = kcService.getKillCount(LootRecordType.UNKNOWN, source);
            if (kc != null && kc > 0) {
                fieldData.put("source", source);
                fieldData.put("killcount", kc);
            }
        }
        
        // Add timestamp
        fieldData.put("timestamp", System.currentTimeMillis() / 1000);
        
        addFields(embed, fieldData);
        
        // Try to set pet image
        if (pet != null && !pet.isEmpty()) {
            Integer itemId = itemSearcher.findItemId(pet);
            if (itemId != null) {
                embed.setImage(plugin.itemImageUrl(itemId));
            }
        }
        
        webhook.getEmbeds().add(embed);
        
        // Send the data
        sendData(webhook, SubmissionType.PET); 
    }

    private static Optional<ParseResult> parseItemFromGameMessage(String message) {
        Matcher untradeableMatcher = UNTRADEABLE_REGEX.matcher(message);
        if (untradeableMatcher.find()) {
            return Optional.of(new ParseResult(untradeableMatcher.group(1), false));
        }

        Matcher collectionMatcher = COLLECTION_LOG_REGEX.matcher(message);
        if (collectionMatcher.find()) {
            return Optional.of(new ParseResult(collectionMatcher.group(1), true));
        }

        return Optional.empty();
    }

    private static class ParseResult {
        final String itemName;
        final boolean collectionLog;

        ParseResult(String itemName, boolean collectionLog) {
            this.itemName = itemName;
            this.collectionLog = collectionLog;
        }
    }

    /**
     * Converts text into "upper case first" form, as is used by OSRS for item names.
     *
     * @param text the string to be transformed
     * @return the text with only the first character capitalized
     */
    private static String ucFirst(String text) {
        if (text == null || text.isEmpty()) return text;
        if (text.length() < 2) return text.toUpperCase();
        return Character.toUpperCase(text.charAt(0)) + text.substring(1).toLowerCase();
    }

    private static boolean isPetName(String itemName) {
        return PET_TO_SOURCE.containsKey(ucFirst(itemName));
    }

    // Simplified pet to source mapping - just for basic KC tracking
    private static final Map<String, String> PET_TO_SOURCE = Map.ofEntries(
        Map.entry("Abyssal orphan", "Abyssal Sire"),
        Map.entry("Baby mole", "Giant Mole"),
        Map.entry("Baron", "Duke Sucellus"),
        Map.entry("Butch", "Vardorvis"),
        Map.entry("Callisto cub", "Callisto"),
        Map.entry("Chompy chick", "Chompy bird"),
        Map.entry("Hellpuppy", "Cerberus"),
        Map.entry("Herbi", "Herbiboar"),
        Map.entry("Huberte", "The Hueycoatl"),
        Map.entry("Ikkle hydra", "Alchemical Hydra"),
        Map.entry("Jal-nib-rek", "TzKal-Zuk"),
        Map.entry("Kalphite princess", "Kalphite Queen"),
        Map.entry("Lil' creator", "Spoils of war"),
        Map.entry("Lil' zik", "Theatre of Blood"),
        Map.entry("Lil'viathan", "The Leviathan"),
        Map.entry("Little nightmare", "Nightmare"),
        Map.entry("Moxi", "Amoxliatl"),
        Map.entry("Muphin", "Phantom Muspah"),
        Map.entry("Nexling", "Nex"),
        Map.entry("Nid", "Araxxor"),
        Map.entry("Noon", "Grotesque Guardians"),
        Map.entry("Pet chaos elemental", "Chaos Elemental"),
        Map.entry("Pet dagannoth prime", "Dagannoth Prime"),
        Map.entry("Pet dagannoth rex", "Dagannoth Rex"),
        Map.entry("Pet dagannoth supreme", "Dagannoth Supreme"),
        Map.entry("Pet dark core", "Corporeal Beast"),
        Map.entry("Pet general graardor", "General Graardor"),
        Map.entry("Pet k'ril tsutsaroth", "K'ril Tsutsaroth"),
        Map.entry("Pet kraken", "Kraken"),
        Map.entry("Pet smoke devil", "Thermonuclear smoke devil"),
        Map.entry("Pet snakeling", "Zulrah"),
        Map.entry("Pet zilyana", "Commander Zilyana"),
        Map.entry("Phoenix", "Wintertodt"),
        Map.entry("Prince black dragon", "King Black Dragon"),
        Map.entry("Scorpia's offspring", "Scorpia"),
        Map.entry("Scurry", "Scurrius"),
        Map.entry("Skotos", "Skotizo"),
        Map.entry("Smolcano", "Zalcano"),
        Map.entry("Sraracha", "Sarachnis"),
        Map.entry("Tiny tempor", "Tempoross"),
        Map.entry("Tzrek-jad", "TzTok-Jad"),
        Map.entry("Venenatis spiderling", "Venenatis"),
        Map.entry("Vet'ion jr.", "Vet'ion"),
        Map.entry("Vorki", "Vorkath"),
        Map.entry("Wisp", "The Whisperer"),
        Map.entry("Yami", "Yama"),
        Map.entry("Youngllef", "Gauntlet"),
        Map.entry("Dom", "Doom of Mokhaitl")
    );
}
package io.droptracker.events;

import java.util.ArrayList;
import java.util.Collection;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.concurrent.atomic.AtomicReference;

import javax.inject.Inject;

import io.droptracker.models.CustomWebhookBody;
import io.droptracker.models.submissions.Drop;
import io.droptracker.service.KCService;
import io.droptracker.util.ChatMessageUtil;
import io.droptracker.util.NpcUtilities;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.ItemComposition;
import net.runelite.api.NPC;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.events.NpcLootReceived;
import net.runelite.client.events.PlayerLootReceived;
import net.runelite.client.events.ServerNpcLoot;
import net.runelite.client.game.ItemStack;
import net.runelite.client.game.ItemManager;
import net.runelite.client.plugins.loottracker.LootReceived;
import net.runelite.http.api.loottracker.LootRecordType;

@Slf4j
public class DropHandler extends BaseEventHandler {

    @Inject
    private ChatMessageUtil chatMessageUtil;

    @Inject
    private KCService kcService;

    @Inject
    private ItemManager itemManager;



    @Subscribe
	public void onNpcLootReceived(NpcLootReceived event) {
		chatMessageUtil.checkForMessage();
		if (!plugin.isTracking) {
			return;
		}
		NPC npc = event.getNpc();
		Collection<ItemStack> items = event.getItems();
		processDropEvent(npc.getName(), "npc", LootRecordType.NPC, items);
		//sendChatReminder();
	}

	@Subscribe
	public void onPlayerLootReceived(PlayerLootReceived playerLootReceived) {
		chatMessageUtil.checkForMessage();
		if (!plugin.isTracking) {
			return;
		}
		Collection<ItemStack> items = playerLootReceived.getItems();
		processDropEvent(playerLootReceived.getPlayer().getName(), "pvp", LootRecordType.PLAYER, items);
		kcService.onPlayerKill(playerLootReceived);
		//sendChatReminder();
	}

	@Subscribe(priority=1)
	public void onServerNpcLoot(ServerNpcLoot event) {
		chatMessageUtil.checkForMessage();
		if (!plugin.isTracking) {
			return;
		}
		var comp = event.getComposition();
		processDropEvent(comp.getName(), "npc", LootRecordType.NPC, event.getItems());
	}

	@Subscribe
	public void onLootReceived(LootReceived lootReceived) {
		chatMessageUtil.checkForMessage();
		if (!plugin.isTracking) {
			return;
		}
		/* A select few npc loot sources will arrive here, instead of npclootreceived events */
		String npcName = NpcUtilities.getStandardizedSource(lootReceived, plugin);
		log.debug("onLootReceived called ...");
		if (lootReceived.getType() == LootRecordType.NPC && NpcUtilities.SPECIAL_NPC_NAMES.contains(npcName)) {
			log.debug("Special NPC loot received: {}", npcName);
			if(npcName.equals("Branda the Fire Queen")|| npcName.equals("Eldric the Ice King")) {
				npcName = "Royal Titans";
			}
			if(npcName.equals("Dusk")){
				npcName = "Grotesque Guardians";
			}

			processDropEvent(npcName, "npc", LootRecordType.NPC, lootReceived.getItems());
			return;
		}
		if (lootReceived.getType() != LootRecordType.EVENT && lootReceived.getType() != LootRecordType.PICKPOCKET) {
			return;
		}
		log.debug("Other NPC loot received: {}", npcName);
		processDropEvent(npcName, "other", lootReceived.getType(), lootReceived.getItems());
		kcService.onLoot(lootReceived);
		//sendChatReminder();
	}

    private void processDropEvent(String npcName, String sourceType, LootRecordType lootRecordType, Collection<ItemStack> items) {
		chatMessageUtil.checkForMessage();
		final Collection<ItemStack> finalItems = new ArrayList<>(items);
		if (!plugin.isTracking) {
			return;
		} 
		if (NpcUtilities.LONG_TICK_NPC_NAMES.contains(npcName)){
			plugin.ticksSinceNpcDataUpdate -= 30;
		}
        plugin.lastDrop = new Drop(npcName, lootRecordType, finalItems);
		if (plugin.valuedItemIds == null) {
			/* Load target 'valued item ids' if they are not present
			To help properly screenshot un-tradeables that are later given values
			 */
			plugin.valuedItemIds = api.getValuedUntradeables();
		}
		AtomicReference<Boolean> untradeableScreenshot = null;
		clientThread.invokeLater(() -> {
			// Gather all game state info needed
			List<ItemStack> stackedItems = new ArrayList<>(stack(finalItems));
			String localPlayerName = getPlayerName();
			AtomicInteger totalValue = new AtomicInteger(0);
			List<CustomWebhookBody.Embed> embeds = new ArrayList<>();
			AtomicInteger singleValue = new AtomicInteger(0);
			
			for (ItemStack item : stackedItems) {
				int itemId = item.getId();
				/* Check if the itemId exists in the valued list we obtained */
				if (plugin.valuedItemIds.contains(itemId)) {
					untradeableScreenshot.set(true);
				}
				int qty = item.getQuantity();
				int price = itemManager.getItemPrice(itemId);
				ItemComposition itemComposition = itemManager.getItemComposition(itemId);
				totalValue.addAndGet(qty * price);
				singleValue.addAndGet(price);
				CustomWebhookBody.Embed itemEmbed = createEmbed(localPlayerName + " received some drops:", "drop");
				itemEmbed.setImage(plugin.itemImageUrl(itemId));
				Map<String, Object> fieldData = new HashMap<>();
				fieldData.put("source_type", sourceType);
				fieldData.put("item", itemComposition.getName());
				fieldData.put("id", itemComposition.getId());
				fieldData.put("quantity", qty);
				fieldData.put("value", price);
				fieldData.put("source", npcName);
				
				if (npcName != null) {
					Integer killCount = getKillCount(npcName);
					fieldData.put("killcount", killCount);
				}
				
				addFields(itemEmbed, fieldData);
				embeds.add(itemEmbed);
			}

			// Now do the heavy work off the client thread


			executor.submit(() -> {
				try {
					CustomWebhookBody customWebhookBody = createWebhookBody(localPlayerName + " received some drops:");
					customWebhookBody.getEmbeds().addAll(embeds);

					if (!customWebhookBody.getEmbeds().isEmpty()) {
						int valueToSend = totalValue.get();
						/* 'untradeableScreenshot' is true here if any of the obtained items' IDs were contained
						inside the list of valuedItemIds, populated through the api call (or github pages url).
						*/
						Boolean valueModified;
						if (untradeableScreenshot != null) {
							Boolean untradeable = untradeableScreenshot.get(); // Get the value *once*
							valueModified = (untradeable != null && untradeable == true);
						} else {
							valueModified = false;
						}
						sendData(customWebhookBody, valueToSend, singleValue.get(), valueModified);
					}
				} catch (Exception e) {
					log.error("Error processing drop event", e);
				}
			});
		});
	}

    @SuppressWarnings("deprecation")
	private static Collection<ItemStack> stack(Collection<ItemStack> items) {
		final List<ItemStack> list = new ArrayList<>();

		for (final ItemStack item : items) {
			int quantity = 0;
			for (final ItemStack i : list) {
				if (i.getId() == item.getId()) {
					quantity = i.getQuantity();
					list.remove(i);
					break;
				}
			}
			if (quantity > 0) {
				list.add(new ItemStack(item.getId(), item.getQuantity() + quantity, item.getLocation()));
			} else {
				list.add(item);
			}
		}

		return list;
	}

	

}

package io.droptracker.events;

import com.google.inject.Inject;
import io.droptracker.DropTrackerConfig;
import io.droptracker.DropTrackerPlugin;
import io.droptracker.api.DropTrackerApi;
import io.droptracker.models.CustomWebhookBody;
import io.droptracker.models.submissions.SubmissionType;
import io.droptracker.service.SubmissionManager;
import io.droptracker.util.DebugLogger;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.config.ConfigManager;

import java.util.concurrent.ScheduledExecutorService;
import java.util.Map;

/**
 * Base abstract class for all event handlers
 * Provides common dependencies, shared logic, and standardized methods for webhook creation and data transmission.
 */
@Slf4j
public abstract class BaseEventHandler {

    @Inject
    protected DropTrackerPlugin plugin;

    @Inject
    protected Client client;

    @Inject
    protected ConfigManager configManager;

    @Inject
    protected ClientThread clientThread;

    @Inject
    protected DropTrackerApi api;

    @Inject
    protected DropTrackerConfig config;

    @Inject
    protected SubmissionManager submissionManager;

    // Optional dependency - not all handlers use the executor
    @Inject(optional = true)
    protected ScheduledExecutorService executor;

    /**
     * Determines if this event handler is currently enabled.
     * Override this method in subclasses to implement specific enable/disable logic.
     * 
     * @return true if the handler is enabled, false otherwise
     */
    public boolean isEnabled() {
        return true;
    }

    /**
     * Gets the local player's name.
     * 
     * @return the local player's name, or "Unknown" if null/empty
     */
    protected String getPlayerName() {
        String playerName = plugin.getLocalPlayerName();
        return (playerName != null && !playerName.trim().isEmpty()) ? playerName : "Unknown";
    }

    /**
     * Gets the account hash as a string.
     * 
     * @return the account hash, or "0" if client is null
     */
    protected String getAccountHash() {
        return client != null ? String.valueOf(client.getAccountHash()) : "0";
    }

    /**
     * Adds common fields that are present in all webhook embeds.
     * This includes player_name, acc_hash, p_v, and any global fields.
     * 
     * @param embed the embed to add fields to
     */
    protected void addCommonFields(CustomWebhookBody.Embed embed) {
        if (embed == null) {
            log.warn("Attempted to add common fields to null embed");
            return;
        }
        
        String playerName = getPlayerName();
        String accountHash = getAccountHash();
        String pluginVersion = plugin != null && plugin.pluginVersion != null ? plugin.pluginVersion : "unknown";
        String guid = api != null ? api.generateGuidForSubmission() : "unknown";
        
        embed.addField("player_name", playerName, true);
        embed.addField("acc_hash", accountHash, true);
        embed.addField("p_v", pluginVersion, true);
        embed.addField("guid", guid, true);
    }

    /**
     * Creates a new webhook body with basic setup.
     * 
     * @param content the main content message for the webhook
     * @return a new CustomWebhookBody instance
     */
    protected CustomWebhookBody createWebhookBody(String content) {
        CustomWebhookBody webhook = new CustomWebhookBody();
        webhook.setContent(content != null ? content : "DropTracker Event");
        return webhook;
    }

    /**
     * Creates a new embed with the specified title and type, and automatically adds common fields.
     * 
     * @param title the title for the embed
     * @param type the type of the embed (e.g., "drop", "combat_achievement", "collection_log", "npc_kill")
     * @return a new CustomWebhookBody.Embed instance with common fields already added
     */
    protected CustomWebhookBody.Embed createEmbed(String title, String type) {
        CustomWebhookBody.Embed embed = new CustomWebhookBody.Embed();
        if (title != null && !title.trim().isEmpty()) {
            embed.setTitle(title);
        } else {
            embed.setTitle("DropTracker Event");
        }
        if (type != null && !type.trim().isEmpty()) {
            embed.addField("type", type, true);
        }
        addCommonFields(embed);
        return embed;
    }

    /**
     * Creates a new embed with the specified title (no type field).
     * 
     * @param title the title for the embed
     * @return a new CustomWebhookBody.Embed instance
     */
    protected CustomWebhookBody.Embed createEmbed(String title) {
        return createEmbed(title, null);
    }

    /**
     * Adds multiple fields to an embed from a map of field data.
     * 
     * @param embed the embed to add fields to
     * @param fieldData map of field names to values
     */
    protected void addFields(CustomWebhookBody.Embed embed, Map<String, Object> fieldData) {
        addFields(embed, fieldData, true);
    }

    /**
     * Adds multiple fields to an embed from a map of field data.
     * 
     * @param embed the embed to add fields to
     * @param fieldData map of field names to values
     * @param inline whether the fields should be inline
     */
    protected void addFields(CustomWebhookBody.Embed embed, Map<String, Object> fieldData, boolean inline) {
        if (embed == null) {
            log.warn("Attempted to add fields to null embed");
            return;
        }
        if (fieldData == null) {
            log.warn("Attempted to add null fieldData to embed");
            return;
        }
        
        for (Map.Entry<String, Object> entry : fieldData.entrySet()) {
            String fieldName = entry.getKey();
            if (fieldName == null || fieldName.trim().isEmpty()) {
                log.debug("Skipping field with null/empty name");
                continue;
            }
            
            String value;
            Object rawValue = entry.getValue();
            if (rawValue == null) {
                value = "N/A";
            } else if (rawValue instanceof String && ((String) rawValue).trim().isEmpty()) {
                value = "N/A";
            } else {
                value = String.valueOf(rawValue);
            }
            
            embed.addField(fieldName, value, inline);
        }
    }

    /**
     * Sends webhook data to the DropTracker API with a string type identifier.
     * Used for events like combat achievements, collection logs, and kills.
     * 
     * @param webhook the webhook body to send
     * @param type the event type identifier
     */
    protected void sendData(CustomWebhookBody webhook, SubmissionType type) {
        DebugLogger.log("Sending webhook body: " + webhook.toString());
        if (webhook == null) {
            log.warn("Attempted to send null webhook data");
            return;
        }
        if (webhook.getEmbeds() == null || webhook.getEmbeds().isEmpty()) {
            log.warn("Attempted to send webhook with no embeds");
            return;
        }
        if (type == null) {
            log.warn("Attempted to send webhook with null submission type");
            return;
        }
        if (submissionManager == null) {
            log.error("SubmissionManager is null, cannot send webhook data");
            return;
        }
        
        try {
            submissionManager.sendDataToDropTracker(webhook, type);
        } catch (Exception e) {
            log.error("Failed to send webhook data: {}", e.getMessage(), e);
        }
    }

    /**
     * Sends webhook data to the DropTracker API with a numeric value.
     * Used for drops where the value is the total drop value.
     * 
     * @param webhook the webhook body to send
     * @param value the total value of the event
     * @param singleValue the value of individual items (for stacked item checking)
     */
    protected void sendData(CustomWebhookBody webhook, int value, int singleValue, boolean valueModified) {
        if (webhook == null) {
            log.warn("Attempted to send null webhook data");
            return;
        }
        if (webhook.getEmbeds() == null || webhook.getEmbeds().isEmpty()) {
            log.warn("Attempted to send webhook with no embeds");
            return;
        }
        if (submissionManager == null) {
            log.error("SubmissionManager is null, cannot send webhook data");
            return;
        }
        
        try {
            submissionManager.sendDataToDropTracker(webhook, value, singleValue, valueModified);
        } catch (Exception e) {
            log.error("Failed to send webhook data: {}", e.getMessage(), e);
        }
    }

    /**
     * Gets the kill count for a specific boss from the configuration.
     * 
     * @param bossName the name of the boss
     * @return the kill count, or 0 if not found
     */
    protected int getKillCount(String bossName) {
        if (bossName == null) {
            return 0;
        }
        Integer killCount = configManager.getRSProfileConfiguration("killcount", bossName.toLowerCase(), int.class);
        return killCount != null ? killCount : 0;
    }

    
} 
package io.droptracker.events;

import java.util.Collection;
import java.util.HashMap;
import java.util.Map;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import javax.annotation.Nullable;
import javax.inject.Singleton;

import org.apache.commons.lang3.StringUtils;

import com.google.common.collect.ImmutableList;

import io.droptracker.models.CustomWebhookBody;
import io.droptracker.models.submissions.SubmissionType;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.VarPlayer;
import net.runelite.api.events.WidgetLoaded;
import net.runelite.api.gameval.InterfaceID;
import net.runelite.api.widgets.Widget;

@Slf4j
@Singleton
public class QuestHandler extends BaseEventHandler {
    
    private static final Pattern QUEST_PATTERN_1 = Pattern.compile(".+?ve\\.*? (?<verb>been|rebuilt|.+?ed)? ?(?:the )?'?(?<quest>.+?)'?(?: [Qq]uest)?[!.]?$");
    private static final Pattern QUEST_PATTERN_2 = Pattern.compile("'?(?<quest>.+?)'?(?: [Qq]uest)? (?<verb>[a-z]\\w+?ed)?(?: f.*?)?[!.]?$");
    private static final Collection<String> RFD_TAGS = ImmutableList.of("Another Cook", "freed", "defeated", "saved");
    private static final Collection<String> WORD_QUEST_IN_NAME_TAGS = ImmutableList.of("Another Cook", "Doric", "Heroes", "Legends", "Observatory", "Olaf", "Waterfall");
    private static final Map<String, String> QUEST_REPLACEMENTS = Map.of(
        "Lumbridge Cook... again", "Another Cook's",
        "Skrach 'Bone Crusher' Uglogwee", "Skrach Uglogwee"
    );

    /* VarbitIDs for quest tracking */
    private static final int VARBIT_QUESTS_COMPLETED_COUNT = 6347;
    private static final int VARBIT_QUESTS_TOTAL_COUNT = 11877;
    private static final int VARBIT_QP_MAX = 1782;

    
    @Override
    public boolean isEnabled() {
        return config.questsEmbed();
    }

    public void onWidgetLoaded(WidgetLoaded event) {
        if (event.getGroupId() == InterfaceID.QUESTSCROLL && isEnabled()) {
            Widget questTitle = client.getWidget(InterfaceID.Questscroll.QUEST_TITLE); // Quest title widget
            if (questTitle != null) {
                String questText = questTitle.getText();
                // 1 tick delay to ensure relevant varbits have been processed by the client
                clientThread.invokeLater(() -> handleQuestCompletion(questText));
            }
        }
    }

    @SuppressWarnings("deprecation")
    private void handleQuestCompletion(String questText) {
        // Get quest completion stats
        int completedQuests = client.getVarbitValue(VARBIT_QUESTS_COMPLETED_COUNT);
        int totalQuests = client.getVarbitValue(VARBIT_QUESTS_TOTAL_COUNT);
        boolean validQuests = completedQuests > 0 && totalQuests > 0;

        // Get quest points
        int questPoints = client.getVarpValue(VarPlayer.QUEST_POINTS);
        int totalQuestPoints = client.getVarbitValue(VARBIT_QP_MAX);
        boolean validPoints = questPoints > 0 && totalQuestPoints > 0;

        // Parse the quest name
        String parsedQuestName = parseQuestWidget(questText);
        if (parsedQuestName == null) {
            return;
        }

        // Create webhook body
        CustomWebhookBody webhook = createWebhookBody(getPlayerName() + " completed a quest!");
        CustomWebhookBody.Embed embed = createEmbed("Quest Completed!", "quest");
        
        // Add fields
        Map<String, Object> fieldData = new HashMap<>();
        fieldData.put("quest_name", parsedQuestName);
        
        if (validQuests) {
            fieldData.put("quests_completed", completedQuests);
            fieldData.put("total_quests", totalQuests);
            fieldData.put("completion_percentage", String.format("%.1f%%", (completedQuests * 100.0) / totalQuests));
        }
        
        if (validPoints) {
            fieldData.put("quest_points", questPoints);
            fieldData.put("total_quest_points", totalQuestPoints);
            fieldData.put("qp_percentage", String.format("%.1f%%", (questPoints * 100.0) / totalQuestPoints));
        }
        
        // Add timestamp
        fieldData.put("timestamp", System.currentTimeMillis() / 1000);
        
        addFields(embed, fieldData);
        webhook.getEmbeds().add(embed);
        
        // Send the data
        sendData(webhook, SubmissionType.QUEST_COMPLETION);
    }

    /* Helper methods */

    @Nullable
    private String parseQuestWidget(final String text) {
        if (text == null || text.isEmpty()) {
            return null;
        }

        // Try to match the quest completion text
        Matcher matcher = getMatcher(text);
        if (matcher == null) {
            // If no pattern matches, try to extract quest name directly
            // Some quests might just show the name without additional text
            return cleanQuestName(text);
        }

        String quest = matcher.group("quest");
        quest = QUEST_REPLACEMENTS.getOrDefault(quest, quest);

        String verb = StringUtils.defaultString(matcher.group("verb"));

        if (verb.contains("kind of")) {
            return null;
        } else if (verb.contains("completely")) {
            quest += " II";
        }

        // Handle Recipe for Disaster subquests
        if (RFD_TAGS.stream().anyMatch((quest + verb)::contains)) {
            quest = "Recipe for Disaster - " + quest;
        }

        // Add "Quest" to certain quest names that need it
        if (WORD_QUEST_IN_NAME_TAGS.stream().anyMatch(quest::contains)) {
            quest += " Quest";
        }

        return quest;
    }

    @Nullable
    private Matcher getMatcher(String text) {
        if (text == null || text.isEmpty()) {
            return null;
        }


        // "You have completed The Corsair Curse!"
        Matcher questMatch1 = QUEST_PATTERN_1.matcher(text);
        if (questMatch1.matches()) {
            return questMatch1;
        }

        // "'One Small Favour' completed!"
        Matcher questMatch2 = QUEST_PATTERN_2.matcher(text);
        if (questMatch2.matches()) {
            return questMatch2;
        }

        return null;
    }

    private String cleanQuestName(String text) {
        // Remove common prefixes/suffixes
        String cleaned = text;
        cleaned = cleaned.replaceAll("^You have completed ", "");
        cleaned = cleaned.replaceAll("^Congratulations! You've completed ", "");
        cleaned = cleaned.replaceAll("[!.]$", "");
        cleaned = cleaned.trim();
        // If it's still empty or too short, return null
        if (cleaned.isEmpty() || cleaned.length() < 3) {
            return null;
        }
        
        return cleaned;
    }
}

package io.droptracker.events;

import com.google.common.collect.ImmutableSet;

import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Experience;
import net.runelite.api.GameState;
import net.runelite.api.Skill;
import net.runelite.api.WorldType;
import net.runelite.api.events.GameStateChanged;
import net.runelite.api.events.StatChanged;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.util.QuantityFormatter;
import org.jetbrains.annotations.VisibleForTesting;

import io.droptracker.models.CustomWebhookBody;
import io.droptracker.models.submissions.SubmissionType;
import com.google.gson.Gson;

import javax.inject.Inject;
import javax.inject.Singleton;
import java.util.ArrayList;
import java.util.EnumMap;
import java.util.EnumSet;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.BlockingQueue;

import static net.runelite.api.Experience.MAX_REAL_LEVEL;

@Slf4j
@Singleton
public class ExperienceHandler extends BaseEventHandler {
    public static final int LEVEL_FOR_MAX_XP = Experience.MAX_VIRT_LEVEL + 1; // 127
    static final @VisibleForTesting int INIT_GAME_TICKS = 16; // ~10s
    private static final Set<WorldType> SPECIAL_WORLDS = EnumSet.of(WorldType.PVP_ARENA, WorldType.QUEST_SPEEDRUNNING, WorldType.BETA_WORLD, WorldType.NOSAVE_MODE, WorldType.TOURNAMENT_WORLD, WorldType.DEADMAN, WorldType.SEASONAL);
    private static final int SKILL_COUNT = Skill.values().length;
    private static final String COMBAT_NAME = "Combat";
    private static final Set<String> COMBAT_COMPONENTS;
    
    // Configuration constants
    private static final int XP_INTERVAL_MILLIONS = 1; // Track every 1M XP milestone
    private static final int LEVEL_MIN_VALUE = 1; // Minimum level to track
    private static final int LEVEL_INTERVAL = 1; // Track every level
    private static final boolean TRACK_VIRTUAL_LEVELS = true; // Track levels above 99
    private static final boolean TRACK_COMBAT_LEVEL = true; // Track combat level increases
    
    private final BlockingQueue<String> levelledSkills = new ArrayBlockingQueue<>(SKILL_COUNT + 1);
    private final Set<Skill> xpReached = EnumSet.noneOf(Skill.class);
    private final Map<String, Integer> currentLevels = new HashMap<>();
    private final Map<Skill, Integer> currentXp = new EnumMap<>(Skill.class);
    private final Map<String, Integer> previousLevels = new HashMap<>(); // Track previous levels for level increase calculation
    
    private int ticksWaited = 0;
    private int initTicks = 0;
    private Set<WorldType> specialWorldType = null;

    @Inject
    private ClientThread clientThread;
    
    @Inject 
    private static Gson gson;

    
    @Override
    public boolean isEnabled() {
        return config.trackExperience();
    }

    private void initLevels() {
        for (Skill skill : Skill.values()) {
            int xp = client.getSkillExperience(skill);
            int level = client.getRealSkillLevel(skill); // O(1)
            if (level >= MAX_REAL_LEVEL) {
                level = getLevel(xp);
            }
            currentLevels.put(skill.getName(), level);
            currentXp.put(skill, xp);
        }
        currentLevels.put(COMBAT_NAME, calculateCombatLevel());
        this.initTicks = 0;
        this.specialWorldType = getSpecialWorldTypes();
        log.debug("Initialized current skill levels: {}", currentLevels);
    }

    public void reset() {
        levelledSkills.clear();
        clientThread.invoke(() -> {
            this.initTicks = 0;
            this.ticksWaited = 0;
            xpReached.clear();
            currentXp.clear();
            currentLevels.clear();
            previousLevels.clear();
            this.specialWorldType = null;
        });
    }

    public void onTick() {
        if (this.initTicks > INIT_GAME_TICKS) {
            initLevels();
            return;
        }

        if (currentLevels.size() < SKILL_COUNT) {
            this.initTicks++;
            return;
        }

        // Handle level ups and XP milestones
        if (!levelledSkills.isEmpty() || !xpReached.isEmpty()) {
            // We wait a couple extra ticks so we can ensure that we process all the levels of the previous tick
            if (++this.ticksWaited > 2) {
                this.ticksWaited = 0;
                // ensure notifier was not disabled during ticks waited
                if (isEnabled()) {
                    attemptNotify();
                } else {
                    levelledSkills.clear();
                    xpReached.clear();
                }
            }
        }
    }

    public void onStatChanged(StatChanged statChange) {
        this.handleStatChange(statChange.getSkill(), statChange.getLevel(), statChange.getXp());
    }

    public void onGameStateChanged(GameStateChanged gameStateChanged) {
        if (gameStateChanged.getGameState() == GameState.LOGIN_SCREEN) {
            this.reset();
        } else if (gameStateChanged.getGameState() == GameState.LOGGED_IN && !getSpecialWorldTypes().equals(this.specialWorldType)) {
            // world switched where player may have different level profiles; re-initialize
            this.reset();
        }
    }

    private void handleStatChange(Skill skill, int level, int xp) {
        if (xp <= 0 || level <= 1 || !isEnabled()) return;

        Integer previousXp = currentXp.put(skill, xp);
        if (previousXp == null) {
            return;
        }

        String skillName = skill.getName();
        int virtualLevel = level < MAX_REAL_LEVEL ? level : getLevel(xp); // avoid log(n) query when not needed
        Integer previousLevel = currentLevels.put(skillName, virtualLevel);

        if (previousLevel == null) {
            this.initTicks = INIT_GAME_TICKS; // force init on next tick
            return;
        }

        if (virtualLevel < previousLevel || xp < previousXp) {
            // base skill level should never regress; reset notifier state
            reset();
            return;
        }

        // Check normal skill level up
        checkLevelUp(true, skillName, previousLevel, virtualLevel);

        // Check if xp milestone reached
        int xpInterval = XP_INTERVAL_MILLIONS * 1_000_000;
        if (xpInterval > 0 && level >= MAX_REAL_LEVEL && xp > previousXp) {
            int remainder = xp % xpInterval;
            if (remainder == 0 || xp - remainder > previousXp || xp >= Experience.MAX_SKILL_XP) {
                log.debug("Observed XP milestone for {} to {}", skill, xp);
                xpReached.add(skill);
                this.ticksWaited = 0;
            }
        }

        // Skip combat level checking if no level up has occurred
        if (virtualLevel <= previousLevel) {
            // only return if we don't need to initialize combat level for the first time
            if (currentLevels.containsKey(COMBAT_NAME))
                return;
        }

        // Check for combat level increase
        if (COMBAT_COMPONENTS.contains(skillName) && currentLevels.size() >= SKILL_COUNT) {
            int combatLevel = calculateCombatLevel();
            Integer previousCombatLevel = currentLevels.put(COMBAT_NAME, combatLevel);
            checkLevelUp(TRACK_COMBAT_LEVEL, COMBAT_NAME, previousCombatLevel, combatLevel);
        }
    }

    private void checkLevelUp(boolean configEnabled, String skill, Integer previousLevel, int currentLevel) {
        if (previousLevel == null || currentLevel <= previousLevel) {
            log.trace("Ignoring non-level-up for {}: {}", skill, currentLevel);
            return;
        }

        if (!configEnabled) {
            log.trace("Ignoring level up of {} to {} due to disabled config setting", skill, currentLevel);
            return;
        }

        if (!checkLevelInterval(previousLevel, currentLevel, COMBAT_NAME.equals(skill))) {
            log.trace("Ignoring level up of {} from {} to {} that does not align with config interval", skill, previousLevel, currentLevel);
            return;
        }

        if (levelledSkills.offer(skill)) {
            log.debug("Observed level up for {} to {}", skill, currentLevel);
            
            // Track previous level for level increase calculation
            previousLevels.put(skill, previousLevel);

            // allow more accumulation of level ups into single notification
            this.ticksWaited = 0;
        }
    }

    private void attemptNotify() {
        notifyLevels();
        notifyXp();
    }

    /**
     * Creates a simplified field data map for level-up submissions.
     * 
     * @param skillsTrainedList list of skill names that were trained
     * @param skillsLeveledList list of skill names that leveled up
     * @param experienceData map containing experience data for relevant skills
     * @return a map containing only the essential fields
     */
    private Map<String, Object> createLevelUpFieldData(List<String> skillsTrainedList, 
                                                      List<String> skillsLeveledList,
                                                      Map<String, Object> experienceData) {
        Map<String, Object> fieldData = new HashMap<>();
        
        // General player stats
        fieldData.put("total_level", client.getTotalLevel());
        fieldData.put("total_xp", client.getOverallExperience());
        fieldData.put("combat_level", currentLevels.get(COMBAT_NAME));
        
        // Skills data - flatten to simple fields
        fieldData.put("skills_trained", String.join(",", skillsTrainedList));
        fieldData.put("skills_leveled", String.join(",", skillsLeveledList));
        
        // Experience data - flatten to individual fields
        for (Map.Entry<String, Object> entry : experienceData.entrySet()) {
            String key = entry.getKey();
            Object value = entry.getValue();
            
            if (value instanceof Map) {
                @SuppressWarnings("unchecked")
                Map<String, Object> skillData = (Map<String, Object>) value;
                for (Map.Entry<String, Object> skillEntry : skillData.entrySet()) {
                    fieldData.put(key + "_" + skillEntry.getKey(), skillEntry.getValue());
                }
            } else {
                fieldData.put(key, value);
            }
        }
        
        return fieldData;
    }

    private void notifyXp() {
        final int n = xpReached.size();
        if (n == 0) return;

        int interval = XP_INTERVAL_MILLIONS * 1_000_000;
        List<String> milestones = new ArrayList<>(n);
        
        StringBuilder skillMessage = new StringBuilder();
        boolean first = true;
        
        for (Skill skill : xpReached) {
            int xp = currentXp.getOrDefault(skill, 0);
            xp -= xp % interval;
            milestones.add(skill.getName());
            
            if (!first) {
                skillMessage.append(", ");
            }
            first = false;
            
            skillMessage.append(skill.getName())
                       .append(" to ")
                       .append(QuantityFormatter.formatNumber(xp))
                       .append(" XP");
        }
        
        // Create experience data for milestone skills
        Map<String, Object> experienceData = new HashMap<>();
        experienceData.put("xp_milestone_interval", interval);
        
        for (Skill skill : xpReached) {
            int xp = currentXp.getOrDefault(skill, 0);
            xp -= xp % interval; // Get the milestone XP amount
            String skillName = skill.getName().toLowerCase();
            Map<String, Object> skillData = new HashMap<>();
            skillData.put("xp_milestone", xp);
            skillData.put("xp_total", currentXp.get(skill));
            experienceData.put(skillName, skillData);
        }
        
        // Create standardized field data
        List<String> skillsLeveled = new ArrayList<>(); // No level ups for XP milestones
        Map<String, Object> fieldData = createLevelUpFieldData(milestones, skillsLeveled, experienceData);
        
        // Create webhook body
        CustomWebhookBody webhook = createWebhookBody(getPlayerName() + " reached an XP milestone!");
        CustomWebhookBody.Embed embed = createEmbed("XP Milestone Reached", "xp_milestone");
        
        addFields(embed, fieldData);
        webhook.getEmbeds().add(embed);
        
        // Clear the reached skills set
        xpReached.clear();
        
        // Send the data
        sendData(webhook, SubmissionType.EXPERIENCE_MILESTONE);
    }

    private void notifyLevels() {
        /* For level ups specifically  */
        int n = levelledSkills.size();
        if (n == 0) return;

        // Prepare level state
        List<String> levelled = new ArrayList<>(n);
        int count = levelledSkills.drainTo(levelled);
        if (count == 0) return;

        Map<String, Integer> lSkills = new HashMap<>(count);
        Map<String, Integer> currentLevels = new HashMap<>(this.currentLevels);

        // Build skill message and collect skills involved
        Set<Skill> skillsInvolved = EnumSet.noneOf(Skill.class);
        StringBuilder skillMessage = new StringBuilder();
        
        for (int index = 0; index < count; index++) {
            String skill = levelled.get(index);
            if (index > 0) {
                if (count > 2) {
                    skillMessage.append(",");
                }
                skillMessage.append(" ");
                if (index + 1 == count) {
                    skillMessage.append("and ");
                }
            }
            Integer level = currentLevels.get(skill);
            skillMessage.append(skill)
                        .append(" to ")
                        .append(level < LEVEL_FOR_MAX_XP ? level : "Max XP (200M)");
            lSkills.put(skill, level);
            
            // Add skill to involved skills if it's not combat
            if (!COMBAT_NAME.equals(skill)) {
                for (Skill s : Skill.values()) {
                    if (s.getName().equals(skill)) {
                        skillsInvolved.add(s);
                        break;
                    }
                }
            }
        }

        // Check for combat level increase
        Boolean combatLevelUp = lSkills.remove(COMBAT_NAME) != null;
        Integer combatLevel = currentLevels.get(COMBAT_NAME);
        if (combatLevel == null) {
            combatLevel = calculateCombatLevel();
        }

        // Create skills leveled list and experience data
        List<String> skillsLeveledList = new ArrayList<>();
        List<String> skillsTrainedList = new ArrayList<>();
        Map<String, Object> experienceData = new HashMap<>();
        
        for (String skill : levelled) {
            if (!COMBAT_NAME.equals(skill)) {
                skillsTrainedList.add(skill);
                skillsLeveledList.add(skill);
                
                Integer previousLevel = previousLevels.get(skill);
                Integer currentLevel = currentLevels.get(skill);
                if (previousLevel != null && currentLevel != null) {
                    String skillName = skill.toLowerCase();
                    Map<String, Object> skillData = new HashMap<>();
                    skillData.put("level_gained", currentLevel - previousLevel);
                    skillData.put("new_level", currentLevel);
                    
                    // Add XP data if available
                    for (Skill s : Skill.values()) {
                        if (s.getName().equals(skill)) {
                            Integer skillXp = currentXp.get(s);
                            if (skillXp != null) {
                                skillData.put("xp_total", skillXp);
                            }
                            break;
                        }
                    }
                    
                    experienceData.put(skillName, skillData);
                }
            }
        }
        
        // Handle combat level separately
        if (combatLevelUp != null && combatLevelUp) {
            skillsLeveledList.add("Combat");
            Map<String, Object> combatData = new HashMap<>();
            combatData.put("level_gained", 1); // Assume +1 for combat level increases
            combatData.put("new_level", combatLevel);
            experienceData.put("combat", combatData);
        }
        
        // Create level-up field data
        Map<String, Object> fieldData = createLevelUpFieldData(skillsTrainedList, skillsLeveledList, experienceData);
        
        // Update combat level if it leveled up
        if (combatLevelUp != null && combatLevelUp) {
            fieldData.put("combat_level", combatLevel);
        }
        
        // Create webhook body
        CustomWebhookBody webhook = createWebhookBody(getPlayerName() + " leveled up!");
        CustomWebhookBody.Embed embed = createEmbed("Level Up!", "level_up");
        
        addFields(embed, fieldData);
        webhook.getEmbeds().add(embed);
        
        // Send the data
        sendData(webhook, SubmissionType.LEVEL_UP);
    }

    private boolean checkLevelInterval(int previous, int level, boolean skipVirtualCheck) {
        if (level < LEVEL_MIN_VALUE)
            return false;

        if (!skipVirtualCheck && level > MAX_REAL_LEVEL && !TRACK_VIRTUAL_LEVELS)
            return false;

        int interval = LEVEL_INTERVAL;
        if (interval <= 1 || level == MAX_REAL_LEVEL || level == LEVEL_FOR_MAX_XP)
            return true;

        // Check levels in (previous, current] for divisibility by interval
        // Allows for firing notification if jumping over a level that would've notified
        int remainder = level % interval;
        return remainder == 0 || (level - remainder) > previous;
    }

    private int calculateCombatLevel() {
        return Experience.getCombatLevel(
            getRealLevel(Skill.ATTACK),
            getRealLevel(Skill.STRENGTH),
            getRealLevel(Skill.DEFENCE),
            getRealLevel(Skill.HITPOINTS),
            getRealLevel(Skill.MAGIC),
            getRealLevel(Skill.RANGED),
            getRealLevel(Skill.PRAYER)
        );
    }

    private int getRealLevel(Skill skill) {
        Integer cachedLevel = currentLevels.get(skill.getName());
        return cachedLevel != null
            ? Math.min(cachedLevel, MAX_REAL_LEVEL)
            : client.getRealSkillLevel(skill);
    }

    private int getLevel(int xp) {
        // treat 200M XP as level 127
        if (xp >= Experience.MAX_SKILL_XP)
            return LEVEL_FOR_MAX_XP;

        // log(n) operation to support virtual levels
        return Experience.getLevelForXp(xp);
    }

    private Set<WorldType> getSpecialWorldTypes() {
        var world = client.getWorldType().clone();
        world.retainAll(SPECIAL_WORLDS); // O(1)
        return world;
    }

    static {
        COMBAT_COMPONENTS = ImmutableSet.of(
            Skill.ATTACK.getName(),
            Skill.STRENGTH.getName(),
            Skill.DEFENCE.getName(),
            Skill.HITPOINTS.getName(),
            Skill.MAGIC.getName(),
            Skill.RANGED.getName(),
            Skill.PRAYER.getName()
        );
    }
}

package io.droptracker.events;

import io.droptracker.models.CustomWebhookBody;
import io.droptracker.models.submissions.SubmissionType;
import io.droptracker.util.NpcUtilities;
import io.droptracker.util.DebugLogger;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.*;
import net.runelite.api.annotations.Varbit;
import org.apache.commons.lang3.ObjectUtils;
import org.apache.commons.lang3.tuple.Pair;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.annotations.Nullable;
import org.jetbrains.annotations.VisibleForTesting;

import java.time.Duration;
import java.time.LocalTime;
import java.time.temporal.Temporal;
import java.util.*;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.concurrent.atomic.AtomicReference;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import static java.time.temporal.ChronoField.*;
import static org.apache.commons.lang3.ObjectUtils.defaultIfNull;

@Slf4j
public class PbHandler extends BaseEventHandler {

    @VisibleForTesting
    static final int MAX_BAD_TICKS = 10;
    private static final long DUPLICATE_THRESHOLD = 5000;

    private static final Pattern BOSS_COUNT_PATTERN = Pattern.compile(
        "Your (?<key>[\\w\\s:'-]+) (?<type>kill|chest|completion|success) count is:? (?<value>[\\d,]+)", 
        Pattern.CASE_INSENSITIVE
    );
    
    private static final Pattern SECONDARY_BOSS_PATTERN = Pattern.compile(
        "Your (?<type>completed|subdued) (?<key>[\\w\\s:]+) count is:?[ \\t]*(?<value>[\\d,]+)",
        Pattern.CASE_INSENSITIVE
    );
    
    private static final Pattern TIME_WITH_PB_PATTERN = Pattern.compile(
        "(?<prefix>.*?)(?<duration>\\d*:?\\d+:\\d+(?:\\.\\d+)?)\\.?\\s*(?:Personal best: (?<pbtime>\\d*:?\\d+:\\d+(?:\\.\\d+)?)\\.?\\s*)?(?<pbIndicator>\\(new personal best\\))?",
        Pattern.CASE_INSENSITIVE
    );
    
    private static final Pattern TEAM_SIZE_PATTERN = Pattern.compile(
        "Team size:\\s*(?<size>\\d+|Solo|\\d\\+)\\s*(?:players?)?",
        Pattern.CASE_INSENSITIVE
    );

    private final AtomicInteger badTicks = new AtomicInteger();
    private final AtomicReference<KillData> killData = new AtomicReference<>();
    private String lastProcessedKill = null;
    private long lastProcessedTime = 0;
    private long lastKillDataUpdate = 0L;

    private static class KillData {
        final String boss;
        final Integer count;
        final Duration time;
        final Duration bestTime;
        final boolean isPersonalBest;
        final String teamSize;
        final String gameMessage;

        KillData(String boss, Integer count, Duration time, Duration bestTime, 
                boolean isPersonalBest, String teamSize, String gameMessage) {
            this.boss = boss;
            this.count = count;
            this.time = time;
            this.bestTime = bestTime;
            this.isPersonalBest = isPersonalBest;
            this.teamSize = teamSize;
            this.gameMessage = gameMessage;
        }

        boolean isValid() {
            if (boss != null) {
                if (boss.contains("Doom")) {
                    // Doom levels do not include count; so we do not need a null check here
                    return time != null && !time.isZero();
                }
            }
            return boss != null && count != null && time != null && !time.isZero();
        }
    }

    @Override
    public boolean isEnabled() {
        return config.pbEmbeds();
    }

    public void onGameMessage(String message) {
        if (!isEnabled()) return;
        parseMessage(message).ifPresent(this::updateKillData);
    }

    public void onFriendsChatNotification(String message) {
        if (message.startsWith("Congratulations - your raid is complete!")) {
            onGameMessage(message);
        }
    }

    public void onTick() {
        KillData data = killData.get();
        if (data == null) {
            if (badTicks.incrementAndGet() > MAX_BAD_TICKS) {
                reset();
            }
            return;
        }

        if (data.isValid() && isEnabled()) {
            if (data.count == null) {
                /* Doom does not have KCs available for individual floors, so we need to handle the data anyways for this boss */
                /* Otherwise, we should handle other data with no count included consistently with before */
                if (data.boss.contains("Doom")) {
                    processKill(data);
                    reset();
                }
            } else {
                processKill(data);
                reset();
            }
        } else {
            // Allow partial data (e.g., time before count or vice versa) to coalesce for up to 10 seconds
            long now = System.currentTimeMillis();
            if (now - lastKillDataUpdate > 10_000) {
                reset();
            }
        }
    }

    private Optional<KillData> parseMessage(String message) {
        if (message.startsWith("Preparation")) {
            return Optional.empty();
        }

        // Try boss count first
        Optional<Pair<String, Integer>> bossCount = parseBossCount(message);
        if (bossCount.isPresent()) {
            Pair<String, Integer> pair = bossCount.get();
            return Optional.of(new KillData(pair.getLeft(), pair.getRight(), 
                Duration.ZERO, Duration.ZERO, false, null, message));
        }

        // Try time data
        return parseTimeData(message);
    }

    private Optional<Pair<String, Integer>> parseBossCount(String message) {
        Matcher primary = BOSS_COUNT_PATTERN.matcher(message);
        if (primary.find()) {
            String boss = parsePrimaryBoss(primary.group("key"), primary.group("type"));
            if (boss != null) {
                try {
                    int count = Integer.parseInt(primary.group("value").replace(",", ""));
                    return Optional.of(Pair.of(boss, count));
                } catch (NumberFormatException e) {
                    log.debug("Failed to parse kill count: {}", primary.group("value"));
                }
            }
        }

        Matcher secondary = SECONDARY_BOSS_PATTERN.matcher(message);
        if (secondary.find()) {
            String boss = parseSecondaryBoss(secondary.group("key"));
            if (boss != null) {
                try {
                    int count = Integer.parseInt(secondary.group("value").replace(",", ""));
                    return Optional.of(Pair.of(boss, count));
                } catch (NumberFormatException e) {
                    log.debug("Failed to parse kill count: {}", secondary.group("value"));
                }
            }
        }

        return Optional.empty();
    }

    private Optional<KillData> parseTimeData(String message) {
        Matcher matcher = TIME_WITH_PB_PATTERN.matcher(message);
        if (!matcher.find()) {
            return Optional.empty();
        }

        try {
            Duration time = parseTime(matcher.group("duration"));
            String pbTimeStr = matcher.group("pbtime");
            Duration bestTime = pbTimeStr != null ? parseTime(pbTimeStr) : Duration.ZERO;
            boolean isPersonalBest = matcher.group("pbIndicator") != null;
            
            String bossName = determineBossFromContext(message);
            String teamSize = extractTeamSize(message, bossName);
            
            // For CoX, PB lines often include Olm split but team size isn't always on KC line. If team size missing, try to extract now.
            if (teamSize == null && message.contains("Team size:")) {
                teamSize = extractTeamSize(message, bossName);
            }
            return Optional.of(new KillData(bossName, null, time, bestTime, 
                isPersonalBest, teamSize, message));
                
        } catch (Exception e) {
            log.error("Error parsing time data: {}", e.getMessage());
            return Optional.empty();
        }
    }

    private String determineBossFromContext(String message) {
        if (message.contains("Tombs of Amascut")) {
            return message.contains("Expert Mode") ? "Tombs of Amascut: Expert Mode" : "Tombs of Amascut";
        }
        if (message.contains("Theatre of Blood")) {
            return "Theatre of Blood";
        }
        if (message.contains("Chambers of Xeric")) {
            return "Chambers of Xeric";
        }
        // Chambers of Xeric time lines often omit the raid name but include the Olm split
        if (message.contains("Olm Duration")) {
            return "Chambers of Xeric";
        }
        if (message.contains("Corrupted challenge")) {
            return "Corrupted Hunllef";
        }
        if (message.contains("Challenge duration")) {
            return "Crystalline Hunllef";
        }
        if (message.contains("Colosseum duration")) {
            return "Sol Heredit";
        }
        if (message.contains("Delve level")) {
            return extractDelveBoss(message);
        }
        // With an unknown context, don't guess--defer to subsequent kill-count parsing
        return null;
    }

    private String extractDelveBoss(String message) {
        Pattern delvePattern = Pattern.compile("Delve level: (\\S+)");
        Matcher matcher = delvePattern.matcher(message);
        if (matcher.find()) {
            return "Doom of Mokhaiotl (Level:" + matcher.group(1).trim() + ")";
        }
        return "Doom of Mokhaiotl";
    }

    private String extractTeamSize(String message, String bossName) {
        Matcher teamMatcher = TEAM_SIZE_PATTERN.matcher(message);
        if (teamMatcher.find()) {
            String raw = teamMatcher.group("size");
            if (raw == null) {
                return "Solo";
            }
            if (raw.equalsIgnoreCase("solo")) {
                return "Solo";
            }
            return raw;
        }

        boolean mentionsToa = message.contains("Tombs of Amascut") || (bossName != null && bossName.contains("Tombs of Amascut"));
        boolean mentionsTob = message.contains("Theatre of Blood") || (bossName != null && bossName.contains("Theatre of Blood"));
        boolean mentionsRoyalTitans = message.contains("Royal Titans") || (bossName != null && bossName.contains("Royal Titans"));

        if (mentionsToa) {
            return getToaTeamSize();
        }
        if (mentionsTob) {
            return getTobTeamSize();
        }
        if (mentionsRoyalTitans) {
            return getRoyalTitansTeamSize();
        }

        return "Solo";
    }

    private void updateKillData(KillData newData) {
        DebugLogger.log("[PbHandler.java:247] updateKillData called with newData: " + newData);
        killData.getAndUpdate(old -> {
            if (old == null) {
                lastKillDataUpdate = System.currentTimeMillis();
                return newData;
            }

            String boss = defaultIfNull(newData.boss, old.boss);
            DebugLogger.log("[PbHandler.java:254] set boss to new data: " + newData.boss + " from old: " + old.boss);
            Integer count = defaultIfNull(newData.count, old.count);
            Duration time = newData.time != null && !newData.time.isZero() ? newData.time : old.time;
            Duration bestTime = newData.bestTime != null && !newData.bestTime.isZero() ? newData.bestTime : old.bestTime;
            boolean isPersonalBest = newData.isPersonalBest || old.isPersonalBest;
            String teamSize = defaultIfNull(newData.teamSize, old.teamSize);
            String gameMessage = defaultIfNull(newData.gameMessage, old.gameMessage);
            DebugLogger.log("[PbHandler.java:260] updateKillData completed -- returning: " + new KillData(boss, count, time, bestTime, isPersonalBest, teamSize, gameMessage).toString());
            lastKillDataUpdate = System.currentTimeMillis();
            return new KillData(boss, count, time, bestTime, isPersonalBest, teamSize, gameMessage);
        });
        DebugLogger.log("[PbHandler.java:263] updateKillData completed. boss / time / count:" + newData.boss + "/" + newData.time + "/" + newData.count);
    }

    // === KILL PROCESSING ===
    private void processKill(KillData data) {
        DebugLogger.log("[PbHandler.java:109] processKill: " + data);
        if (data == null || !data.isValid()) {
            DebugLogger.log("[PbHandler.java:268] Invalid kill data, skipping processing");
            log.debug("Invalid kill data, skipping processing");
            return;
        }

        // Duplicate prevention
        String killIdentifier = data.boss + "-" + data.count;
        long currentTime = System.currentTimeMillis();
        
        if (killIdentifier.equals(lastProcessedKill) && 
            (currentTime - lastProcessedTime) < DUPLICATE_THRESHOLD) {
            if (!data.boss.contains("1-8")) {
                
                DebugLogger.log("[PbHandler.java:281] Duplicate kill detected, skipping: " + killIdentifier);
                log.debug("Duplicate kill detected, skipping: {}", killIdentifier);
                return;
            }
        }
        
        lastProcessedKill = killIdentifier;
        lastProcessedTime = currentTime;

        if (clientThread == null) {
            DebugLogger.log("[PbHandler.java:291] ClientThread is null, cannot process kill");
            log.error("ClientThread is null, cannot process kill");
            return;
        }

        clientThread.invokeLater(() -> {
            try {
                sendKillNotification(data);
            } catch (Exception e) {
                DebugLogger.log("[PbHandler.java:300] Error processing kill notification: " + e.getMessage());
                log.error("Error processing kill notification: {}", e.getMessage(), e);
            }
        });
    }

    private void sendKillNotification(KillData data) {
        String player = getPlayerName();
        String formattedTime = formatTime(data.time, isPreciseTiming(client));
        String formattedBestTime = formatTime(data.bestTime, isPreciseTiming(client));
        
        CustomWebhookBody webhook = createWebhookBody(player + " has killed a boss:");
        CustomWebhookBody.Embed embed = createEmbed(player + " has killed a boss:", "npc_kill");
        
        Map<String, Object> fieldData = new HashMap<>();
        fieldData.put("boss_name", data.boss);
        fieldData.put("kill_time", formattedTime != null ? formattedTime : "N/A");
        fieldData.put("best_time", formattedBestTime != null ? formattedBestTime : "N/A");
        fieldData.put("is_pb", data.isPersonalBest);
        fieldData.put("team_size", data.teamSize != null ? data.teamSize : "Solo");
        fieldData.put("killcount", data.count);
        
        addFields(embed, fieldData);
        webhook.getEmbeds().add(embed);
        
        sendData(webhook, SubmissionType.KILL_TIME);
    }

    public void reset() {
        killData.set(null);
        badTicks.set(0);
    }

    private Duration parseTime(String timeStr) {
        if (timeStr == null || timeStr.trim().isEmpty()) {
            return Duration.ZERO;
        }

        try {
            String timePart = timeStr.contains(".") ? timeStr.substring(0, timeStr.indexOf('.')) : timeStr;
            String[] timeParts = timePart.split(":");

            long hours = 0, minutes = 0, seconds = 0, millis = 0;

            if (timeParts.length == 3) {  // h:m:s
                hours = Long.parseLong(timeParts[0]);
                minutes = Long.parseLong(timeParts[1]);
                seconds = Long.parseLong(timeParts[2]);
            } else if (timeParts.length == 2) {  // m:s
                minutes = Long.parseLong(timeParts[0]);
                seconds = Long.parseLong(timeParts[1]);
            }

            if (timeStr.contains(".")) {
                String millisStr = timeStr.substring(timeStr.indexOf('.') + 1);
                while (millisStr.length() < 3) {
                    millisStr += "0";
                }
                millis = Long.parseLong(millisStr);
            }

            return Duration.ofHours(hours).plusMinutes(minutes).plusSeconds(seconds).plusMillis(millis);

        } catch (Exception e) {
            log.error("Error parsing time: {}", e.getMessage());
            return Duration.ZERO;
        }
    }

    @NotNull
    public String formatTime(@Nullable Duration duration, boolean precise) {
        Temporal time = ObjectUtils.defaultIfNull(duration, Duration.ZERO).addTo(LocalTime.of(0, 0));
        StringBuilder sb = new StringBuilder();

        int h = time.get(HOUR_OF_DAY);
        if (h > 0) sb.append(String.format("%02d", h)).append(':');

        sb.append(String.format("%02d", time.get(MINUTE_OF_HOUR))).append(':');
        sb.append(String.format("%02d", time.get(SECOND_OF_MINUTE)));

        if (precise) sb.append('.').append(String.format("%02d", time.get(MILLI_OF_SECOND) / 10));

        return sb.toString();
    }

    public boolean isPreciseTiming(@NotNull Client client) {
        @Varbit int ENABLE_PRECISE_TIMING = 11866;
        return client.getVarbitValue(ENABLE_PRECISE_TIMING) > 0;
    }

    // === BOSS PARSING METHODS ===
    @Nullable
    private static String parsePrimaryBoss(String boss, String type) {
        switch (type.toLowerCase()) {
            case "chest":
                if ("Barrows".equalsIgnoreCase(boss)) return boss;
                if ("Lunar".equals(boss)) return boss + " " + type;
                return null;
            case "completion":
                if (NpcUtilities.GAUNTLET_NAME.equalsIgnoreCase(boss)) return NpcUtilities.GAUNTLET_BOSS;
                if (NpcUtilities.CG_NAME.equalsIgnoreCase(boss)) return NpcUtilities.CG_BOSS;
                return null;
            case "kill":
            case "success":
                return boss;
            default:
                return null;
        }
    }

    private static String parseSecondaryBoss(String boss) {
        if (boss == null || "Wintertodt".equalsIgnoreCase(boss)) return boss;

        int modeSeparator = boss.lastIndexOf(':');
        String raid = modeSeparator > 0 ? boss.substring(0, modeSeparator) : boss;
        if (raid.equalsIgnoreCase("Theatre of Blood") || raid.equalsIgnoreCase("Tombs of Amascut") ||
            raid.equalsIgnoreCase("Chambers of Xeric") || raid.equalsIgnoreCase("Chambers of Xeric Challenge Mode")) {
            return boss;
        }
        return null;
    }

    // === TEAM SIZE METHODS ===
    @SuppressWarnings("deprecation")
    private String getTobTeamSize() {
        Integer teamSize = Math.min(client.getVarbitValue(Varbits.THEATRE_OF_BLOOD_ORB1), 1) +
                Math.min(client.getVarbitValue(Varbits.THEATRE_OF_BLOOD_ORB2), 1) +
                Math.min(client.getVarbitValue(Varbits.THEATRE_OF_BLOOD_ORB3), 1) +
                Math.min(client.getVarbitValue(Varbits.THEATRE_OF_BLOOD_ORB4), 1) +
                Math.min(client.getVarbitValue(Varbits.THEATRE_OF_BLOOD_ORB5), 1);
        return teamSize == 1 ? "Solo" : teamSize.toString();
    }

    @SuppressWarnings("deprecation")
    private String getToaTeamSize() {
        Integer teamSize = Math.min(client.getVarbitValue(Varbits.TOA_MEMBER_0_HEALTH), 1) +
                Math.min(client.getVarbitValue(Varbits.TOA_MEMBER_1_HEALTH), 1) +
                Math.min(client.getVarbitValue(Varbits.TOA_MEMBER_2_HEALTH), 1) +
                Math.min(client.getVarbitValue(Varbits.TOA_MEMBER_3_HEALTH), 1) +
                Math.min(client.getVarbitValue(Varbits.TOA_MEMBER_4_HEALTH), 1) +
                Math.min(client.getVarbitValue(Varbits.TOA_MEMBER_5_HEALTH), 1) +
                Math.min(client.getVarbitValue(Varbits.TOA_MEMBER_6_HEALTH), 1) +
                Math.min(client.getVarbitValue(Varbits.TOA_MEMBER_7_HEALTH), 1);
        return teamSize == 1 ? "Solo" : teamSize.toString();
    }

    @SuppressWarnings("deprecation")
    private String getRoyalTitansTeamSize() {
        int size = client.getPlayers().size();
        return size == 1 ? "Solo" : String.valueOf(size);
    }

//    public void generateTestBossMessage(String bossName, boolean newPersonalBest) {
//        DebugLogger.log("Got bossName and newPersonalBest from generateTestBossMessage call:");
//        DebugLogger.log(bossName + " - " + newPersonalBest + " -- status of bool in pbhandler= " + shouldSendTestAsPb);
//        if (bossName == null) {
//            return;
//        }
//        String b = bossName.toLowerCase(Locale.ROOT).trim();
//        switch (b) {
//            /* Chambers of Xeric */
//            case "cox":
//            case "chambers":
//            case "chambers of xeric":
//                onGameMessage("Congratulations - Your raid is complete!");
//                onGameMessage(newPersonalBest
//                    ? "Team size: 3 players Duration: 27:32 (new personal best) Olm Duration: 4:11"
//                    : "Team size: 3 players Duration: 27:32 Personal best: 22:26 Olm Duration: 4:11");
//                onGameMessage("Your completed Chambers of Xeric count is 52.");
//                return;
//            case "cox cm":
//            case "chambers cm":
//            case "chambers of xeric challenge mode":
//            case "challenge mode":
//                onGameMessage("Congratulations - Your raid is complete!");
//                onGameMessage(newPersonalBest
//                    ? "Team size: 3 players Duration: 32:32 (new personal best) Olm Duration: 4:11"
//                    : "Team size: 3 players Duration: 32:32 Personal best: 28:26 Olm Duration: 4:11");
//                onGameMessage("Your completed Chambers of Xeric Challenge Mode count is 61.");
//                return;
//
//            /* Tombs of Amascut */
//            case "toa entry":
//            case "tombs entry":
//            case "tombs of amascut: entry mode":
//            case "tombs of amascut entry mode":
//                onGameMessage("Challenge complete: The Wardens. Duration: 3:02");
//                onGameMessage(newPersonalBest
//                    ? "Tombs of Amascut: Entry Mode total completion time: 14:36.4 (new personal best)"
//                    : "Tombs of Amascut: Entry Mode total completion time: 16:37.4. Personal best: 14:37.4");
//                onGameMessage("Your completed Tombs of Amascut: Entry Mode count is 15.");
//                return;
//            case "toa":
//            case "tombs":
//            case "tombs of amascut":
//                onGameMessage("Challenge complete: The Wardens. Duration: 3:02");
//                onGameMessage(newPersonalBest
//                    ? "Tombs of Amascut total completion time: 14:36.4 (new personal best)"
//                    : "Tombs of Amascut total completion time: 16:37.4. Personal best: 14:37.4");
//                onGameMessage("Your completed Tombs of Amascut count is 15.");
//                return;
//            case "toa expert":
//            case "tombs expert":
//            case "tombs of amascut expert mode":
//                onGameMessage("Challenge complete: The Wardens. Duration: 3:02");
//                onGameMessage(newPersonalBest
//                    ? "Tombs of Amascut: Expert Mode total completion time: 18:37.4 (new personal best)"
//                    : "Tombs of Amascut: Expert Mode total completion time: 1:23:38.2. Personal best: 1:20:38.4");
//                onGameMessage("Your completed Tombs of Amascut: Expert Mode count is 20.");
//                return;
//
//            /* Theatre of Blood */
//            case "tob entry":
//            case "theatre entry":
//            case "theatre of blood: entry mode":
//            case "theatre of blood entry mode":
//                onGameMessage(newPersonalBest
//                    ? "Theatre of Blood completion time: 25:40 (new personal best)"
//                    : "Theatre of Blood completion time: 18:12. Personal best: 17:09");
//                onGameMessage("Your completed Theatre of Blood: Entry Mode count is: 1.");
//                return;
//            case "tob":
//            case "theatre":
//            case "theatre of blood":
//                onGameMessage(newPersonalBest
//                    ? "Theatre of Blood completion time: 25:40 (new personal best)"
//                    : "Theatre of Blood completion time: 18:12. Personal best: 17:09");
//                onGameMessage("Your completed Theatre of Blood count is 11.");
//                return;
//            case "tob hard":
//            case "tob hm":
//            case "theatre of blood: hard mode":
//            case "theatre of blood hard mode":
//                onGameMessage(newPersonalBest
//                    ? "Theatre of Blood completion time: 24:40 (new personal best)"
//                    : "Theatre of Blood completion time: 25:12. Personal best: 23:09");
//                onGameMessage("Your completed Theatre of Blood: Hard Mode count is 11.");
//                return;
//
//            /* Gauntlet */
//            case "gauntlet":
//                onGameMessage(newPersonalBest
//                    ? "Challenge duration: 6:22 (new personal best)."
//                    : "Challenge duration: 3:06. Personal best: 1:47.");
//                onGameMessage("Your Gauntlet completion count is 40.");
//                return;
//            case "cg":
//            case "corrupted gauntlet":
//                onGameMessage(newPersonalBest
//                    ? "Corrupted challenge duration: 7:55 (new personal best)."
//                    : "Corrupted challenge duration: 3:06. Personal best: 1:47.");
//                onGameMessage("Your Corrupted Gauntlet completion count is 40.");
//                return;
//
//            /* Nightmare */
//            case "nightmare":
//                onGameMessage(newPersonalBest
//                    ? "Team size: 6+ players Fight duration: 3:57 (new personal best)"
//                    : "Team size: 6+ players Fight duration: 1:46. Personal best: 1:46");
//                onGameMessage("Your nightmare kill count is 31.");
//                return;
//            case "phosani":
//            case "phosani's nightmare":
//                onGameMessage(newPersonalBest
//                    ? "Team size: Solo Fight Duration: 1:05:30 (new personal best)"
//                    : "Team size: Solo Fight Duration: 8:58. Personal best: 8:30");
//                onGameMessage("Your Phosani's Nightmare kill count is: 100.");
//                return;
//
//            /* Other bosses */
//            case "zulrah":
//                onGameMessage(newPersonalBest
//                    ? "Fight duration: 0:58 (new personal best)"
//                    : "Fight duration: 1:02. Personal best: 0:59");
//                onGameMessage("Congratulations - Your Zulrah kill count is: 559.");
//                return;
//            case "hydra":
//            case "alchemical hydra":
//                onGameMessage(newPersonalBest
//                    ? "Fight duration: 1:20 (new personal best)."
//                    : "Fight duration: 1:49. Personal best: 1:28.");
//                onGameMessage("Your Alchemical Hydra kill count is: 150.");
//                return;
//            case "amoxliatl":
//            case "amoxialtl":
//                onGameMessage(newPersonalBest
//                    ? "Fight duration: 0:29.40 (new personal best)"
//                    : "Fight duration: 1:05.40. Personal best: 0:29.40");
//                onGameMessage("Your Amoxliatl kill count is: 42.");
//                return;
//            case "araxxor":
//                onGameMessage(newPersonalBest
//                    ? "Fight duration: 1:15.60 (new personal best)"
//                    : "Fight duration: 1:19.20. Personal best: 1:00.00");
//                onGameMessage("Your Araxxor kill count is 75.");
//                return;
//            case "duke":
//            case "duke sucellus":
//                onGameMessage(newPersonalBest
//                    ? "Fight duration: 1:34.20 (new personal best)"
//                    : "Fight duration: 2:52.20. Personal best: 1:37.80");
//                onGameMessage("Your Duke Sucellus kill count is: 150.");
//                return;
//            case "jad":
//            case "tztok-jad":
//            case "fight caves":
//                onGameMessage(newPersonalBest
//                    ? "Duration: 1:47:28.20 (new personal best)"
//                    : "Duration: 59:20. Personal best: 46:16");
//                onGameMessage("Your TzTok-Jad kill count is 5.");
//                return;
//            case "colosseum":
//            case "fortis colosseum":
//            case "sol heredit":
//                onGameMessage(newPersonalBest
//                    ? "Colosseum duration: 26:13.20 (new personal best)"
//                    : "Colosseum duration: 37:51.60. Personal best: 30:12.00");
//                onGameMessage("Your Sol Heredit kill count is: 10.");
//                return;
//            case "fragment of seren":
//                onGameMessage(newPersonalBest
//                    ? "Fight duration: 3:29 (new personal best)."
//                    : "Fight duration: 4:25.20. Personal best: 3:25.20.");
//                onGameMessage("Your Fragment of Seren kill count is: 2.");
//                return;
//            case "galvek":
//                onGameMessage(newPersonalBest
//                    ? "Fight duration: 2:19 (new personal best)"
//                    : "Fight duration: 3:48.60. Personal best: 2:58.80");
//                onGameMessage("Your Galvek kill count is: 2.");
//                return;
//            case "grotesque guardians":
//                onGameMessage(newPersonalBest
//                    ? "Fight duration: 1:55 (new personal best)"
//                    : "Fight duration: 2:12. Personal best: 1:18");
//                onGameMessage("Your Grotesque Guardians kill count is 413.");
//                return;
//            case "hespori":
//                onGameMessage(newPersonalBest
//                    ? "Fight duration: 0:35 (new personal best)"
//                    : "Fight duration: 1:16. Personal best: 0:44");
//                onGameMessage("Your Hespori kill count is: 134.");
//                return;
//            case "colossal wyrm basic":
//            case "colossal wyrm agility basic":
//                onGameMessage(newPersonalBest
//                    ? "Lap duration: 2:52.80 (new personal best)"
//                    : "Lap duration: 2:52.80. Personal best: 1:22.20");
//                onGameMessage("Your Colossal Wyrm Agility Course (Basic) lap count is: 3.");
//                return;
//            case "colossal wyrm advanced":
//            case "colossal wyrm agility advanced":
//                onGameMessage(newPersonalBest
//                    ? "Lap duration: 1:01.80 (new personal best)"
//                    : "Lap duration: 1:01.80. Personal best: 0:59.40");
//                onGameMessage("Your Colossal Wyrm Agility Course (Advanced) lap count is: 217.");
//                return;
//            case "priff agility":
//            case "prifddinas agility":
//                onGameMessage(newPersonalBest
//                    ? "Lap duration: 1:15.00 (new personal best)"
//                    : "Lap duration: 1:15.00. Personal best: 1:04.80");
//                onGameMessage("Your Prifddinas Agility Course lap count is: 92.");
//                return;
//            case "sepulchre floor":
//            case "hallowed sepulchre floor":
//                onGameMessage(newPersonalBest
//                    ? "Floor 4 time: 1:46.80 (new personal best)"
//                    : "Floor 4 time: 1:46.80. Personal best: 1:36.60");
//                onGameMessage("You have completed Floor 4 of the Hallowed Sepulchre! Total completions: 125.");
//                return;
//            case "sepulchre total":
//            case "hallowed sepulchre total":
//                onGameMessage(newPersonalBest
//                    ? "Overall time: 6:48.60 (new personal best)"
//                    : "Overall time: 6:48.60. Personal best: 6:18.00");
//                onGameMessage("You have completed Floor 5 of the Hallowed Sepulchre! Total completions: 95.");
//                return;
//            case "inferno":
//            case "tzkal-zuk":
//                onGameMessage(newPersonalBest
//                    ? "Duration: 2:21:41 (new personal best)"
//                    : "Duration: 2:23:41. Personal best: 1:09:04");
//                onGameMessage("Your TzKal-Zuk kill count is 1.");
//                return;
//            case "muspah":
//            case "phantom muspah":
//                onGameMessage(newPersonalBest
//                    ? "Fight duration: 2:02 (new personal best)"
//                    : "Fight duration: 3:11. Personal best: 2:17");
//                onGameMessage("Your Phantom Muspah kill count is: 12.");
//                return;
//            case "six jads":
//            case "6 jads":
//            case "sixth challenge":
//                onGameMessage(newPersonalBest
//                    ? "Challenge duration: 6:31.80 (new personal best)"
//                    : "Challenge duration: 6:02. Personal best: 5:31");
//                onGameMessage("Your completion count for Tzhaar-Ket-Rak's Sixth Challenge is 1.");
//                return;
//            case "hueycoatl":
//                onGameMessage(newPersonalBest
//                    ? "Fight duration: 3:04 (new personal best)"
//                    : "Fight duration: 3:09.60. Personal best: 0:58.20");
//                onGameMessage("Your Hueycoatl kill count is 3.");
//                return;
//            case "leviathan":
//                onGameMessage(newPersonalBest
//                    ? "Fight duration: 2:16.80 (new personal best)"
//                    : "Fight duration: 3:19. Personal best: 2:50");
//                onGameMessage("Your Leviathan kill count is 2.");
//                return;
//            case "royal titans":
//                onGameMessage(newPersonalBest
//                    ? "Fight duration: 2:50 (new personal best)"
//                    : "Fight Duration: 2:33. Personal best: 0:53");
//                onGameMessage("Your Royal Titans kill count is: 9.");
//                return;
//            case "whisperer":
//                onGameMessage(newPersonalBest
//                    ? "Fight duration: 2:18.60 (new personal best)"
//                    : "Fight duration: 3:06.00. Personal best: 2:29.40");
//                onGameMessage("Your whisperer kill count is 4.");
//                return;
//            case "vardorvis":
//                onGameMessage(newPersonalBest
//                    ? "Fight duration: 2:39 (new personal best)"
//                    : "Fight duration: 4:04. Personal best: 1:13");
//                onGameMessage("Your Vardorvis kill count is: 18.");
//                return;
//            case "vorkath":
//                onGameMessage(newPersonalBest
//                    ? "Fight duration: 1:53 (new personal best)"
//                    : "Fight duration: 4:04. Personal best: 1:13");
//                onGameMessage("Your Vorkath kill count is: 168.");
//                return;
//            case "yama":
//                onGameMessage(newPersonalBest
//                    ? "Fight duration: 3:22 (new personal best)"
//                    : "Fight duration: 4:04. Personal best: 3:50");
//                onGameMessage("Your Yama success count is 20.");
//                return;
//
//            /* Doom of Mokhaiotl */
//            case "doom-4":
//            case "doom-l4":
//                onGameMessage(newPersonalBest
//                    ? "Delve level: 4 duration: 1:53 (new personal best)"
//                    : "Delve level: 4 duration: 2:34. Personal best: 1:54");
//                return;
//            case "doom1-8":
//            case "doom-all":
//                onGameMessage(newPersonalBest
//                    ? "Delve level 1 - 8 duration: 9:33 (new personal best)"
//                    : "Delve level 1 - 8 duration: 9:40. Personal best: 9:33");
//                onGameMessage("Deep delves completed: 2");
//                return;
//
//            default:
//                return;
//        }
//    }\
}

/*
 * Copyright (c) 2017. l2-
 * Copyright (c) 2017, Adam <Adam@sigterm.info>
 * All rights reserved.
 *
 * Borrowed from ChatCommandsPlugin and modified for use within the
 * DropTracker by @joelhalen <andy@joelhalen.net>
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package io.droptracker.events;

import com.google.common.annotations.VisibleForTesting;
import com.google.gson.Gson;
import com.google.gson.JsonSyntaxException;
import com.google.gson.reflect.TypeToken;
import com.google.inject.Inject;
import io.droptracker.models.CustomWebhookBody;
import io.droptracker.models.Pet;
import io.droptracker.models.submissions.SubmissionType;
import net.runelite.api.Client;
import net.runelite.api.EnumComposition;
import net.runelite.api.EnumID;
import net.runelite.api.IndexedSprite;
import net.runelite.api.events.*;
import net.runelite.api.widgets.ComponentID;
import net.runelite.api.widgets.InterfaceID;
import net.runelite.api.widgets.Widget;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.game.ItemManager;
import io.droptracker.service.SubmissionManager;
import net.runelite.client.util.ImageUtil;
import net.runelite.client.util.AsyncBufferedImage;
import net.runelite.client.util.Text;
import org.apache.commons.text.WordUtils;

import java.awt.image.BufferedImage;
import java.util.*;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.stream.Collectors;

public class WidgetEventHandler {


    @Inject
    protected Client client;

    @Inject
    private ConfigManager configManager;

    @Inject
    private ItemManager itemManager;

    @Inject
    private Gson gson;

    @Inject
    private SubmissionManager submissionManager;

    private int petsIconIdx = -1;
    private int[] pets;


    private boolean advLogLoaded = false;
    private boolean bossLogLoaded = false;
    private boolean scrollInterfaceLoaded = false;
    private String pohOwner;

    private static final String TEAM_SIZES = "(?<teamsize>\\d+(?:\\+|-\\d+)? players?|Solo)";

    private static final Pattern ADVENTURE_LOG_TITLE_PATTERN = Pattern.compile("The Exploits of (.+)");
    private static final Pattern ADVENTURE_LOG_PB_PATTERN = Pattern.compile("Fastest (?:kill|run|Room time)(?: - \\(Team size: \\(?" + TEAM_SIZES + "\\)\\)?)?: (?<time>[0-9:]+(?:\\.[0-9]+)?)");

    static final int ADV_LOG_EXPLOITS_TEXT_INDEX = 1;

    private static class BossPB {
        private final String bossName;
        private final String teamSize;
        private final double time;
    
        public BossPB(String bossName, String teamSize, double time) {
            this.bossName = bossName;
            this.teamSize = teamSize;
            this.time = time;
        }
    
        public String getBossName() {
            return bossName;
        }
    
        public String getTeamSize() {
            return teamSize;
        }
    
        public double getTime() {
            return time;
        }
    }


    @SuppressWarnings("deprecation")
    public void onWidgetLoaded(WidgetLoaded widget)
    {
        switch (widget.getGroupId())
        {
            case InterfaceID.ADVENTURE_LOG:
                advLogLoaded = true;
                break;
            case InterfaceID.KILL_LOG:
                bossLogLoaded = true;
                break;
            case InterfaceID.ACHIEVEMENT_DIARY_SCROLL:
                scrollInterfaceLoaded = true;
                break;
        }
    }

    @SuppressWarnings({ "deprecation", "null" })
    @Subscribe
    public void onGameTick(GameTick event)
    {
        if (client.getLocalPlayer() == null)
        {
            return;
        }

        if (advLogLoaded)
        {
            advLogLoaded = false;

            Widget adventureLog = client.getWidget(ComponentID.ADVENTURE_LOG_CONTAINER);

            if (adventureLog != null && adventureLog.getChild(ADV_LOG_EXPLOITS_TEXT_INDEX) != null)
            {
                Matcher advLogExploitsText = ADVENTURE_LOG_TITLE_PATTERN.matcher(adventureLog.getChild(ADV_LOG_EXPLOITS_TEXT_INDEX).getText());
                if (advLogExploitsText.find())
                {
                    pohOwner = advLogExploitsText.group(1);
                }
            }
        }

        if (bossLogLoaded && (pohOwner == null || pohOwner.equals(client.getLocalPlayer().getName())))
        {
            bossLogLoaded = false;

            Widget title = client.getWidget(ComponentID.KILL_LOG_TITLE);
            Widget bossMonster = client.getWidget(ComponentID.KILL_LOG_MONSTER);
            Widget bossKills = client.getWidget(ComponentID.KILL_LOG_KILLS);

            if (title == null || bossMonster == null || bossKills == null
                || !"Boss Kill Log".equals(title.getText()))
            {
                return;
            }

        }

        // Adventure log - Counters
        if (scrollInterfaceLoaded)
        {
            scrollInterfaceLoaded = false;
            
            collectAndSendAdventureLogPBs();
        }
    }



    @VisibleForTesting
    static String secondsToTimeString(double seconds)
    {
        int hours = (int) (Math.floor(seconds) / 3600);
        int minutes = (int) (Math.floor(seconds / 60) % 60);
        seconds = seconds % 60;

        String timeString = hours > 0 ? String.format("%d:%02d:", hours, minutes) : String.format("%d:", minutes);

        // If the seconds is an integer, it is ambiguous if the pb is a precise
        // pb or not. So we always show it without the trailing .00.
        return timeString + (Math.floor(seconds) == seconds ? String.format("%02d", (int) seconds) : String.format("%05.2f", seconds));
    }

    // Method to collect all PBs from the adventure log
    @SuppressWarnings({ "null", "deprecation" })
    private void collectAndSendAdventureLogPBs() {
        if (client.getLocalPlayer() == null || client.getLocalPlayer().getName() == null || pohOwner == null) {
            return;
        }
        // Only process if we're in our own POH
        if (!client.getLocalPlayer().getName().equals(pohOwner)) {
            return;
        }
        
        List<BossPB> personalBests = new ArrayList<>();
        
        Widget parent = client.getWidget(ComponentID.ACHIEVEMENT_DIARY_SCROLL_TEXT);
        if (parent == null) {
            return;
        }
        
        // Each line is a separate static child
        Widget[] children = parent.getStaticChildren();
        String[] text = Arrays.stream(children)
            .map(Widget::getText)
            .map(Text::removeTags)
            .toArray(String[]::new);
    
        for (int i = 0; i < text.length; ++i) {
            String boss = longBossName(text[i]);
    
            for (i = i + 1; i < text.length; ++i) {
                String line = text[i];
                if (line.isEmpty()) {
                    break;
                }
    
                Matcher matcher = ADVENTURE_LOG_PB_PATTERN.matcher(line);
                if (matcher.find()) {
                    final double seconds = timeStringToSeconds(matcher.group("time"));
                    String teamSize = matcher.group("teamsize");
                    if (teamSize != null) {
                        // 3 player -> 3 players
                        // 1 player -> Solo
                        // Solo -> Solo
                        // 2 players -> 2 players
                        if (teamSize.equals("1 player")) {
                            teamSize = "Solo";
                        } else if (teamSize.endsWith("player")) {
                            teamSize = teamSize.replace("player", "").strip();
                        } else if (teamSize.endsWith("players")) {
                            teamSize = teamSize.replace("players", "").strip();
                        }

                        personalBests.add(new BossPB(boss, teamSize, seconds));
                    } else {
                        personalBests.add(new BossPB(boss, "Solo", seconds));
                    }
                }
            }
        }
        
        if (!personalBests.isEmpty()) {
            sendPersonalBestsWebhook(pohOwner, personalBests);
        }
    }
    private void sendPersonalBestsWebhook(String playerName, List<BossPB> personalBests) {
        if (personalBests.isEmpty()) {
            return;
        }
    
        CustomWebhookBody customWebhookBody = new CustomWebhookBody();
        customWebhookBody.setContent(playerName + "'s Personal Best Times:");
    
        // Create a main embed for the PBs
        CustomWebhookBody.Embed pbEmbed = new CustomWebhookBody.Embed();
        pbEmbed.title = playerName + "'s Personal Best Times";
        
        // Add player info fields
        String accountHash = String.valueOf(client.getAccountHash());
        pbEmbed.addField("type", "adventure_log", true);
        pbEmbed.addField("player", playerName, true);
        pbEmbed.addField("acc_hash", accountHash, true);
        
        // Group PBs into batches (5 PBs per field)
        int pbsPerField = 5;
        int fieldCount = (int) Math.ceil(personalBests.size() / (double) pbsPerField);

        List<Integer> playerPets = getPetList();
        
        for (int i = 0; i < fieldCount; i++) {
            StringBuilder fieldContent = new StringBuilder();
            int startIdx = i * pbsPerField;
            int endIdx = Math.min(startIdx + pbsPerField, personalBests.size());
            
            for (int j = startIdx; j < endIdx; j++) {
                BossPB pb = personalBests.get(j);
                String formattedTime = formatTime(pb.getTime());
                
                // Format each PB as with "`boss name` - `team_size` : `time`" for easy parsing
                fieldContent.append("`" + pb.getBossName() + "`")
                           .append(" - ")
                           .append("`" + pb.getTeamSize() + "`")
                           .append(" : ")
                           .append("`" + formattedTime + "`");
                
                // Add a newline between entries (except the last one)
                if (j < endIdx - 1) {
                    fieldContent.append("\n");
                }
            }
            
            // Add the field with a batch number
            pbEmbed.addField("" + (i + 1), fieldContent.toString(), false);
        }
        pbEmbed.addField("Pets", playerPets.toString(), false);
        
        customWebhookBody.getEmbeds().add(pbEmbed);
        
        // Use the main plugin class' sendWebhook method
        submissionManager.sendDataToDropTracker(customWebhookBody, SubmissionType.ADVENTURE_LOG);
    }
    /**
     * Formats a time in seconds to a string in the format mm:ss or h:mm:ss
     */
    private String formatTime(double seconds)
    {
        int hours = (int) (seconds / 3600);
        int minutes = (int) ((seconds % 3600) / 60);
        double secs = seconds % 60;

        if (hours > 0)
        {
            return String.format("%d:%02d:%05.2f", hours, minutes, secs);
        }
        else
        {
            return String.format("%d:%05.2f", minutes, secs);
        }
    }

    private static String longBossName(String boss)
    {
        String lowerBoss = boss.toLowerCase();
        if (lowerBoss.endsWith(" (echo)"))
        {
            String actualBoss = lowerBoss.substring(0, lowerBoss.length() - " (echo)".length());
            return longBossName(actualBoss) + " (Echo)";
        }

        switch (lowerBoss)
        {
            case "corp":
                return "Corporeal Beast";

            case "jad":
            case "tzhaar fight cave":
                return "TzTok-Jad";

            case "kq":
                return "Kalphite Queen";

            case "chaos ele":
                return "Chaos Elemental";

            case "dusk":
            case "dawn":
            case "gargs":
            case "ggs":
            case "gg":
                return "Grotesque Guardians";

            case "crazy arch":
                return "Crazy Archaeologist";

            case "deranged arch":
                return "Deranged Archaeologist";

            case "mole":
                return "Giant Mole";

            case "vetion":
                return "Vet'ion";

            case "calvarion":
            case "calv":
                return "Calvar'ion";

            case "vene":
                return "Venenatis";

            case "kbd":
                return "King Black Dragon";

            case "vork":
                return "Vorkath";

            case "sire":
                return "Abyssal Sire";

            case "smoke devil":
            case "thermy":
                return "Thermonuclear Smoke Devil";

            case "cerb":
                return "Cerberus";

            case "zuk":
            case "inferno":
                return "TzKal-Zuk";

            case "hydra":
                return "Alchemical Hydra";

            // gwd
            case "sara":
            case "saradomin":
            case "zilyana":
            case "zily":
                return "Commander Zilyana";
            case "zammy":
            case "zamorak":
            case "kril":
            case "kril tsutsaroth":
                return "K'ril Tsutsaroth";
            case "arma":
            case "kree":
            case "kreearra":
            case "armadyl":
                return "Kree'arra";
            case "bando":
            case "bandos":
            case "graardor":
                return "General Graardor";

            // dks
            case "supreme":
                return "Dagannoth Supreme";
            case "rex":
                return "Dagannoth Rex";
            case "prime":
                return "Dagannoth Prime";

            case "wt":
                return "Wintertodt";
            case "barrows":
                return "Barrows Chests";
            case "herbi":
                return "Herbiboar";

            // Chambers of Xeric
            case "cox":
            case "xeric":
            case "chambers":
            case "olm":
            case "raids":
                return "Chambers of Xeric";
            case "cox 1":
            case "cox solo":
                return "Chambers of Xeric Solo";
            case "cox 2":
            case "cox duo":
                return "Chambers of Xeric 2 players";
            case "cox 3":
                return "Chambers of Xeric 3 players";
            case "cox 4":
                return "Chambers of Xeric 4 players";
            case "cox 5":
                return "Chambers of Xeric 5 players";
            case "cox 6":
                return "Chambers of Xeric 6 players";
            case "cox 7":
                return "Chambers of Xeric 7 players";
            case "cox 8":
                return "Chambers of Xeric 8 players";
            case "cox 9":
                return "Chambers of Xeric 9 players";
            case "cox 10":
                return "Chambers of Xeric 10 players";
            case "cox 11-15":
            case "cox 11":
            case "cox 12":
            case "cox 13":
            case "cox 14":
            case "cox 15":
                return "Chambers of Xeric 11-15 players";
            case "cox 16-23":
            case "cox 16":
            case "cox 17":
            case "cox 18":
            case "cox 19":
            case "cox 20":
            case "cox 21":
            case "cox 22":
            case "cox 23":
                return "Chambers of Xeric 16-23 players";
            case "cox 24":
            case "cox 24+":
                return "Chambers of Xeric 24+ players";

            // Chambers of Xeric Challenge Mode
            case "chambers of xeric: challenge mode":
            case "cox cm":
            case "xeric cm":
            case "chambers cm":
            case "olm cm":
            case "raids cm":
            case "chambers of xeric - challenge mode":
                return "Chambers of Xeric Challenge Mode";
            case "cox cm 1":
            case "cox cm solo":
                return "Chambers of Xeric Challenge Mode Solo";
            case "cox cm 2":
            case "cox cm duo":
                return "Chambers of Xeric Challenge Mode 2 players";
            case "cox cm 3":
                return "Chambers of Xeric Challenge Mode 3 players";
            case "cox cm 4":
                return "Chambers of Xeric Challenge Mode 4 players";
            case "cox cm 5":
                return "Chambers of Xeric Challenge Mode 5 players";
            case "cox cm 6":
                return "Chambers of Xeric Challenge Mode 6 players";
            case "cox cm 7":
                return "Chambers of Xeric Challenge Mode 7 players";
            case "cox cm 8":
                return "Chambers of Xeric Challenge Mode 8 players";
            case "cox cm 9":
                return "Chambers of Xeric Challenge Mode 9 players";
            case "cox cm 10":
                return "Chambers of Xeric Challenge Mode 10 players";
            case "cox cm 11-15":
            case "cox cm 11":
            case "cox cm 12":
            case "cox cm 13":
            case "cox cm 14":
            case "cox cm 15":
                return "Chambers of Xeric Challenge Mode 11-15 players";
            case "cox cm 16-23":
            case "cox cm 16":
            case "cox cm 17":
            case "cox cm 18":
            case "cox cm 19":
            case "cox cm 20":
            case "cox cm 21":
            case "cox cm 22":
            case "cox cm 23":
                return "Chambers of Xeric Challenge Mode 16-23 players";
            case "cox cm 24":
            case "cox cm 24+":
                return "Chambers of Xeric Challenge Mode 24+ players";

            // Theatre of Blood
            case "tob":
            case "theatre":
            case "verzik":
            case "verzik vitur":
            case "raids 2":
                return "Theatre of Blood";
            case "tob 1":
            case "tob solo":
                return "Theatre of Blood Solo";
            case "tob 2":
            case "tob duo":
                return "Theatre of Blood 2 players";
            case "tob 3":
                return "Theatre of Blood 3 players";
            case "tob 4":
                return "Theatre of Blood 4 players";
            case "tob 5":
                return "Theatre of Blood 5 players";

            // Theatre of Blood Entry Mode
            case "theatre of blood: story mode":
            case "tob sm":
            case "tob story mode":
            case "tob story":
            case "theatre of blood: entry mode":
            case "tob em":
            case "tob entry mode":
            case "tob entry":
                return "Theatre of Blood Entry Mode";

            // Theatre of Blood Hard Mode
            case "theatre of blood: hard mode":
            case "tob cm":
            case "tob hm":
            case "tob hard mode":
            case "tob hard":
            case "hmt":
                return "Theatre of Blood Hard Mode";
            case "hmt 1":
            case "hmt solo":
                return "Theatre of Blood Hard Mode Solo";
            case "hmt 2":
            case "hmt duo":
                return "Theatre of Blood Hard Mode 2 players";
            case "hmt 3":
                return "Theatre of Blood Hard Mode 3 players";
            case "hmt 4":
                return "Theatre of Blood Hard Mode 4 players";
            case "hmt 5":
                return "Theatre of Blood Hard Mode 5 players";

            // Tombs of Amascut
            case "toa":
            case "tombs":
            case "amascut":
            case "warden":
            case "wardens":
            case "raids 3":
                return "Tombs of Amascut";
            case "toa 1":
            case "toa solo":
                return "Tombs of Amascut Solo";
            case "toa 2":
            case "toa duo":
                return "Tombs of Amascut 2 players";
            case "toa 3":
                return "Tombs of Amascut 3 players";
            case "toa 4":
                return "Tombs of Amascut 4 players";
            case "toa 5":
                return "Tombs of Amascut 5 players";
            case "toa 6":
                return "Tombs of Amascut 6 players";
            case "toa 7":
                return "Tombs of Amascut 7 players";
            case "toa 8":
                return "Tombs of Amascut 8 players";
            case "toa entry":
            case "tombs of amascut - entry":
            case "toa entry mode":
                return "Tombs of Amascut Entry Mode";
            case "toa entry 1":
            case "toa entry solo":
                return "Tombs of Amascut Entry Mode Solo";
            case "toa entry 2":
            case "toa entry duo":
                return "Tombs of Amascut Entry Mode 2 players";
            case "toa entry 3":
                return "Tombs of Amascut Entry Mode 3 players";
            case "toa entry 4":
                return "Tombs of Amascut Entry Mode 4 players";
            case "toa entry 5":
                return "Tombs of Amascut Entry Mode 5 players";
            case "toa entry 6":
                return "Tombs of Amascut Entry Mode 6 players";
            case "toa entry 7":
                return "Tombs of Amascut Entry Mode 7 players";
            case "toa entry 8":
                return "Tombs of Amascut Entry Mode 8 players";
            case "tombs of amascut: expert mode":
            case "toa expert":
            case "tombs of amascut - expert":
            case "toa expert mode":
                return "Tombs of Amascut Expert Mode";
            case "toa expert 1":
            case "toa expert solo":
                return "Tombs of Amascut Expert Mode Solo";
            case "toa expert 2":
            case "toa expert duo":
                return "Tombs of Amascut Expert Mode 2 players";
            case "toa expert 3":
                return "Tombs of Amascut Expert Mode 3 players";
            case "toa expert 4":
                return "Tombs of Amascut Expert Mode 4 players";
            case "toa expert 5":
                return "Tombs of Amascut Expert Mode 5 players";
            case "toa expert 6":
                return "Tombs of Amascut Expert Mode 6 players";
            case "toa expert 7":
                return "Tombs of Amascut Expert Mode 7 players";
            case "toa expert 8":
                return "Tombs of Amascut Expert Mode 8 players";

            // The Gauntlet
            case "gaunt":
            case "gauntlet":
            case "the gauntlet":
                return "Gauntlet";

            // Corrupted Gauntlet
            case "cgaunt":
            case "cgauntlet":
            case "the corrupted gauntlet":
            case "cg":
                return "Corrupted Gauntlet";

            // The Nightmare
            case "nm":
            case "tnm":
            case "nmare":
            case "the nightmare":
                return "Nightmare";

            // Phosani's Nightmare
            case "pnm":
            case "phosani":
            case "phosanis":
            case "phosani nm":
            case "phosani nightmare":
            case "phosanis nightmare":
                return "Phosani's Nightmare";

            // Hallowed Sepulchre
            case "hs":
            case "sepulchre":
            case "ghc":
                return "Hallowed Sepulchre";
            case "hs1":
            case "hs 1":
                return "Hallowed Sepulchre Floor 1";
            case "hs2":
            case "hs 2":
                return "Hallowed Sepulchre Floor 2";
            case "hs3":
            case "hs 3":
                return "Hallowed Sepulchre Floor 3";
            case "hs4":
            case "hs 4":
                return "Hallowed Sepulchre Floor 4";
            case "hs5":
            case "hs 5":
                return "Hallowed Sepulchre Floor 5";

            // Colossal Wyrm Basic Agility Course
            case "wbac":
            case "cwbac":
            case "wyrmb":
            case "wyrmbasic":
            case "wyrm basic":
            case "colossal basic":
            case "colossal wyrm basic":
                return "Colossal Wyrm Agility Course (Basic)";

            // Colossal Wyrm Advanced Agility Course
            case "waac":
            case "cwaac":
            case "wyrma":
            case "wyrmadvanced":
            case "wyrm advanced":
            case "colossal advanced":
            case "colossal wyrm advanced":
                return "Colossal Wyrm Agility Course (Advanced)";

            // Prifddinas Agility Course
            case "prif":
            case "prifddinas":
                return "Prifddinas Agility Course";

            // Shayzien Basic Agility Course
            case "shayb":
            case "sbac":
            case "shayzienbasic":
            case "shayzien basic":
                return "Shayzien Basic Agility Course";

            // Shayzien Advanced Agility Course
            case "shaya":
            case "saac":
            case "shayadv":
            case "shayadvanced":
            case "shayzien advanced":
                return "Shayzien Advanced Agility Course";

            // Ape Atoll Agility
            case "aa":
            case "ape atoll":
                return "Ape Atoll Agility";

            // Draynor Village Rooftop Course
            case "draynor":
            case "draynor agility":
                return "Draynor Village Rooftop";

            // Al-Kharid Rooftop Course
            case "al kharid":
            case "al kharid agility":
            case "al-kharid":
            case "al-kharid agility":
            case "alkharid":
            case "alkharid agility":
                return "Al Kharid Rooftop";

            // Varrock Rooftop Course
            case "varrock":
            case "varrock agility":
                return "Varrock Rooftop";

            // Canifis Rooftop Course
            case "canifis":
            case "canifis agility":
                return "Canifis Rooftop";

            // Falador Rooftop Course
            case "fally":
            case "fally agility":
            case "falador":
            case "falador agility":
                return "Falador Rooftop";

            // Seers' Village Rooftop Course
            case "seers":
            case "seers agility":
            case "seers village":
            case "seers village agility":
            case "seers'":
            case "seers' agility":
            case "seers' village":
            case "seers' village agility":
            case "seer's":
            case "seer's agility":
            case "seer's village":
            case "seer's village agility":
                return "Seers' Village Rooftop";

            // Pollnivneach Rooftop Course
            case "pollnivneach":
            case "pollnivneach agility":
                return "Pollnivneach Rooftop";

            // Rellekka Rooftop Course
            case "rellekka":
            case "rellekka agility":
                return "Rellekka Rooftop";

            // Ardougne Rooftop Course
            case "ardy":
            case "ardy agility":
            case "ardy rooftop":
            case "ardougne":
            case "ardougne agility":
                return "Ardougne Rooftop";

            // Agility Pyramid
            case "ap":
            case "pyramid":
                return "Agility Pyramid";

            // Barbarian Outpost
            case "barb":
            case "barb outpost":
                return "Barbarian Outpost";

            // Brimhaven Agility Arena
            case "brimhaven":
            case "brimhaven agility":
                return "Agility Arena";

            // Dorgesh-Kaan Agility Course
            case "dorg":
            case "dorgesh kaan":
            case "dorgesh-kaan":
                return "Dorgesh-Kaan Agility";

            // Gnome Stronghold Agility Course
            case "gnome stronghold":
                return "Gnome Stronghold Agility";

            // Penguin Agility
            case "penguin":
                return "Penguin Agility";

            // Werewolf Agility
            case "werewolf":
                return "Werewolf Agility";

            // Skullball
            case "skullball":
                return "Werewolf Skullball";

            // Wilderness Agility Course
            case "wildy":
            case "wildy agility":
                return "Wilderness Agility";

            // Jad challenge
            case "jad 1":
                return "TzHaar-Ket-Rak's First Challenge";
            case "jad 2":
                return "TzHaar-Ket-Rak's Second Challenge";
            case "jad 3":
                return "TzHaar-Ket-Rak's Third Challenge";
            case "jad 4":
                return "TzHaar-Ket-Rak's Fourth Challenge";
            case "jad 5":
                return "TzHaar-Ket-Rak's Fifth Challenge";
            case "jad 6":
                return "TzHaar-Ket-Rak's Sixth Challenge";

            // Guardians of the Rift
            case "gotr":
            case "runetodt":
            case "rifts closed":
                return "Guardians of the Rift";

            // Tempoross
            case "fishingtodt":
            case "fishtodt":
                return "Tempoross";

            // Phantom Muspah
            case "phantom":
            case "muspah":
            case "pm":
                return "Phantom Muspah";

            // Desert Treasure 2 bosses
            case "the leviathan":
            case "levi":
                return "Leviathan";
            case "duke":
                return "Duke Sucellus";
            case "the whisperer":
            case "whisp":
            case "wisp":
                return "Whisperer";
            case "vard":
                return "Vardorvis";

            // dt2 awakened variants
            case "leviathan awakened":
            case "the leviathan awakened":
            case "levi awakened":
                return "Leviathan (awakened)";
            case "duke sucellus awakened":
            case "duke awakened":
                return "Duke Sucellus (awakened)";
            case "whisperer awakened":
            case "the whisperer awakened":
            case "whisp awakened":
            case "wisp awakened":
                return "Whisperer (awakened)";
            case "vardorvis awakened":
            case "vard awakened":
                return "Vardorvis (awakened)";

            // lunar chest variants
            case "lunar chests":
            case "perilous moons":
            case "perilous moon":
            case "moons of peril":
                return "Lunar Chest";

            // hunter rumour variants
            case "hunterrumour":
            case "hunter contract":
            case "hunter contracts":
            case "hunter tasks":
            case "hunter task":
            case "rumours":
            case "rumour":
                return "Hunter Rumours";

            // sol heredit
            case "sol":
            case "colo":
            case "colosseum":
            case "fortis colosseum":
                return "Sol Heredit";

            case "bird egg":
            case "bird eggs":
            case "bird's egg":
            case "bird's eggs":
                return "Bird's egg offerings";

            case "amox":
                return "Amoxliatl";

            case "the hueycoatl":
            case "huey":
                return "Hueycoatl";

            case "crystal chest":
                return "crystal chest";

            case "larran small chest":
            case "larran's small chest":
                return "Larran's small chest";

            case "larran chest":
            case "larran's chest":
            case "larran big chest":
            case "larran's big chest":
                return "Larran's big chest";

            case "brimstone chest":
                return "Brimstone chest";

            default:
                return WordUtils.capitalize(boss);
        }
    }

    private void loadPets()
    {
        assert petsIconIdx == -1;

        // !pets requires off thread pets access, so we just store a copy
        EnumComposition petsEnum = client.getEnum(EnumID.PETS);
        pets = new int[petsEnum.size()];
        for (int i = 0; i < petsEnum.size(); ++i)
        {
            pets[i] = petsEnum.getIntValue(i);
        }

        final IndexedSprite[] modIcons = client.getModIcons();
        assert modIcons != null;

        final IndexedSprite[] newModIcons = Arrays.copyOf(modIcons, modIcons.length + pets.length);
        petsIconIdx = modIcons.length;

        client.setModIcons(newModIcons);

        for (int i = 0; i < pets.length; i++)
        {
            final int petId = pets[i];

            final AsyncBufferedImage abi = itemManager.getImage(petId);
            final int idx = petsIconIdx + i;
            abi.onLoaded(() ->
            {
                final BufferedImage image = ImageUtil.resizeImage(abi, 18, 16);
                final IndexedSprite sprite = ImageUtil.getImageIndexedSprite(image, client);
                client.getModIcons()[idx] = sprite;
            });
        }
    }

    /**
     * Looks up the list of owned pets for the local player
     */
    private List<Pet> getPetListOld()
    {
        String petListJson = configManager.getRSProfileConfiguration("chatcommands", "pets",
                String.class);

        List<Pet> petList;
        try
        {
            // CHECKSTYLE:OFF
            petList = gson.fromJson(petListJson, new TypeToken<List<Pet>>(){}.getType());
            // CHECKSTYLE:ON
        }
        catch (JsonSyntaxException ex)
        {
            return Collections.emptyList();
        }

        return petList != null ? petList : Collections.emptyList();
    }

    private List<Integer> getPetList()
    {
        List<Pet> old = getPetListOld();
        if (!old.isEmpty())
        {
            List<Integer> l = old.stream().map(Pet::getIconID).collect(Collectors.toList());
            return l;
        }

        String petListJson = configManager.getRSProfileConfiguration("chatcommands", "pets2",
                String.class);

        List<Integer> petList;
        try
        {
            // CHECKSTYLE:OFF
            petList = gson.fromJson(petListJson, new TypeToken<List<Integer>>(){}.getType());
            // CHECKSTYLE:ON
        }
        catch (JsonSyntaxException ex)
        {
            return Collections.emptyList();
        }

        return petList != null ? petList : Collections.emptyList();
    }

    @VisibleForTesting
    static double timeStringToSeconds(String timeString)
    {
        String[] s = timeString.split(":");
        if (s.length == 2) // mm:ss
        {
            return Integer.parseInt(s[0]) * 60 + Double.parseDouble(s[1]);
        }
        else if (s.length == 3) // h:mm:ss
        {
            return Integer.parseInt(s[0]) * 60 * 60 + Integer.parseInt(s[1]) * 60 + Double.parseDouble(s[2]);
        }
        return Double.parseDouble(timeString);
    }
    @Subscribe
    public void onGameStateChanged(GameStateChanged event)
    {
        switch (event.getGameState())
        {
            case LOADING:
            case HOPPING:
                pohOwner = null;
                break;
            case STARTING:
                petsIconIdx = -1;
                pets = null;
                break;
            case LOGIN_SCREEN:
                if (petsIconIdx == -1)
                {
                    loadPets();
                }
                break;
            default:
                break;
        }
    }
    
}
package io.droptracker.events;

import com.google.inject.Inject;
import io.droptracker.models.CustomWebhookBody;
import io.droptracker.models.submissions.Drop;
import io.droptracker.models.submissions.SubmissionType;
import io.droptracker.service.KCService;
import io.droptracker.util.ItemIDSearch;
import io.droptracker.util.Rarity;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.*;
import net.runelite.api.gameval.VarPlayerID;
import net.runelite.api.gameval.VarbitID;
import net.runelite.client.game.ItemStack;
import net.runelite.http.api.loottracker.LootRecordType;
import org.jetbrains.annotations.Nullable;

import java.time.Duration;
import java.time.Instant;
import java.util.*;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.regex.Matcher;
import java.util.regex.Pattern;


@Slf4j
public class ClogHandler extends BaseEventHandler {
    private final Rarity rarity;
    private final KCService kcService;
    private final ItemIDSearch itemIDFinder;

    private final AtomicBoolean popupStarted = new AtomicBoolean(false);

    private static final Duration RECENT_DROP = Duration.ofSeconds(30L);
    
    @Inject
    public ClogHandler(ItemIDSearch itemIDFinder, Rarity rarity, KCService kcService) {
        this.itemIDFinder = itemIDFinder;
        this.rarity = rarity;
        this.kcService = kcService;
    }


    static final Pattern COLLECTION_LOG_REGEX = Pattern.compile("New item added to your collection log: (?<itemName>(.*))");
    private static final int POPUP_PREFIX_LENGTH = "New item:".length();



    @Override
    public boolean isEnabled() {
        return config.clogEmbeds();
    }


    public void onChatMessage(String chatMessage) {
        if (client.getVarbitValue(VarbitID.OPTION_COLLECTION_NEW_ITEM) != 1 || !this.isEnabled()) {
            // require notifier enabled without popup mode to use chat event
            return;
        }
        Matcher collectionMatcher = COLLECTION_LOG_REGEX.matcher(chatMessage);
        if (collectionMatcher.find()) {
            String itemName = collectionMatcher.group("itemName");
            clientThread.invokeLater(() -> processCollection(itemName));
        }
    }

    public void onScript(int scriptId) {
        if (scriptId == ScriptID.NOTIFICATION_START) {
            popupStarted.set(true);
        } else if (scriptId == ScriptID.NOTIFICATION_DELAY) {
            String topText = client.getVarcStrValue(VarClientStr.NOTIFICATION_TOP_TEXT);
            if (popupStarted.getAndSet(false) && "Collection log".equalsIgnoreCase(topText) && this.isEnabled()) {
                String bottomText = submissionManager.sanitize(client.getVarcStrValue(VarClientStr.NOTIFICATION_BOTTOM_TEXT));
                processCollection(bottomText.substring(POPUP_PREFIX_LENGTH).trim());
            }
        }
    }




    private void processCollection(String itemName) {
        if (!this.isEnabled()) {
            log.debug("Collection log processing disabled");
            return;
        }

        if (itemName == null || itemName.trim().isEmpty()) {
            log.debug("Cannot process collection log with null/empty item name");
            return;
        }

        try {
            int completed = 0;
            int total = 0;
            
            if (client != null) {
                completed = client.getVarpValue(VarPlayerID.COLLECTION_COUNT);
                total = client.getVarpValue(VarPlayerID.COLLECTION_COUNT_MAX);
            }

            boolean varpValid = total > 0 && completed > 0;
            if (!varpValid) {
                // This occurs if the player doesn't have the character summary tab selected
                log.debug("Collection log progress varps were invalid ({} / {})", completed, total);
            }
            
            Integer itemId = null;
            if (itemIDFinder != null) {
                try {
                    itemId = itemIDFinder.findItemId(itemName);
                } catch (Exception e) {
                    log.debug("Error finding item ID for {}: {}", itemName, e.getMessage());
                }
            }
            
            Drop loot = itemId != null ? getLootSource(itemId) : null;
            Integer killCount = 0;
            if (loot != null && kcService != null) {
                try {
                    killCount = kcService.getKillCountWithStorage(loot.getCategory(), loot.getSource());
                } catch (Exception e) {
                    log.debug("Error getting kill count: {}", e.getMessage());
                }
            }
            
            OptionalDouble itemRarity = OptionalDouble.empty();
            if (loot != null && loot.getCategory() == LootRecordType.NPC && itemId != null && rarity != null) {
                try {
                    itemRarity = rarity.getRarity(loot.getSource(), itemId, 1);
                } catch (Exception e) {
                    log.debug("Error calculating rarity: {}", e.getMessage());
                }
            }
                    
            String player = getPlayerName();
            CustomWebhookBody collectionLogBody = createWebhookBody(player + " received a collection log:");
            CustomWebhookBody.Embed collEmbed = createEmbed(player + " received a collection log:", "collection_log");
            
            Map<String, Object> fieldData = new HashMap<>();
            fieldData.put("source", loot != null && loot.getSource() != null ? loot.getSource() : "unknown");
            fieldData.put("item", itemName);
            fieldData.put("kc", killCount);
            fieldData.put("rarity", itemRarity.isPresent() ? itemRarity.getAsDouble() : "unknown");
            fieldData.put("item_id", itemId);
            fieldData.put("slots", varpValid ? completed + "/" + total : "unknown");
            
            addFields(collEmbed, fieldData);
            
            if (collectionLogBody != null && collEmbed != null) {
                collectionLogBody.getEmbeds().add(collEmbed);
                sendData(collectionLogBody, SubmissionType.COLLECTION_LOG);
            } else {
                log.warn("Failed to create webhook or embed for collection log");
            }
        } catch (Exception e) {
            log.error("Error processing collection log for item {}: {}", itemName, e.getMessage(), e);
        }
    }

    @Nullable
    private Drop getLootSource(int itemId) {
        if (plugin == null) {
            return null;
        }
        
        Drop drop = plugin.lastDrop;
        if (drop == null || drop.getTime() == null) {
            return null;
        }
        
        try {
            if (Duration.between(drop.getTime(), Instant.now()).compareTo(RECENT_DROP) > 0) {
                return null;
            }
            
            if (drop.getItems() == null) {
                return null;
            }
            
            for (ItemStack item : drop.getItems()) {
                if (item != null && item.getId() == itemId) {
                    return drop;
                }
            }
        } catch (Exception e) {
            log.debug("Error checking loot source for item {}: {}", itemId, e.getMessage());
        }
        
        return null;
    }

}



package io.droptracker.events;

import io.droptracker.models.CustomWebhookBody;
import io.droptracker.models.submissions.CombatAchievement;
import io.droptracker.models.submissions.SubmissionType;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.annotations.Varbit;
import org.apache.commons.lang3.tuple.Pair;
import org.jetbrains.annotations.VisibleForTesting;

import java.util.*;
import java.util.regex.Matcher;
import java.util.regex.Pattern;


@Slf4j
public class CaHandler extends BaseEventHandler {
    private static final Pattern ACHIEVEMENT_PATTERN = Pattern.compile("Congratulations, you've completed an? (?<tier>\\w+) combat task: (?<task>.+)\\.");
    private static final Pattern TASK_POINTS = Pattern.compile("\\s+\\(\\d+ points?\\)$");
    @Varbit
    public static final int COMBAT_TASK_REPEAT_POPUP = 12456;

    @Varbit
    public static final int TOTAL_POINTS_ID = 14815;
    @Varbit
    public static final int GRANDMASTER_TOTAL_POINTS_ID = 14814;

    public void onGameMessage(String message) {
        if (!isEnabled()) return;
        parseCombatAchievement(message).ifPresent(pair -> processCombatAchievement(pair.getLeft(), pair.getRight()));
    }

    private void processCombatAchievement(CombatAchievement tier, String task) {
        // delay notification for varbits to be updated
        clientThread.invokeAtTickEnd(() -> {
            int taskPoints = tier.getPoints();
            int totalPoints = client.getVarbitValue(TOTAL_POINTS_ID);

            String player = getPlayerName();
            CustomWebhookBody combatWebhook = createWebhookBody(player + " has completed a new combat task:");
            CustomWebhookBody.Embed combatAchievementEmbed = createEmbed(null, "combat_achievement");
            
            Map<String, Object> fieldData = new HashMap<>();
            fieldData.put("tier", tier.toString());
            fieldData.put("task", task);
            fieldData.put("points", taskPoints);
            fieldData.put("total_points", totalPoints);
            
            addFields(combatAchievementEmbed, fieldData);
            
            combatWebhook.getEmbeds().add(combatAchievementEmbed);
            sendData(combatWebhook, SubmissionType.COMBAT_ACHIEVEMENT);
        });
    }

    @VisibleForTesting
    static Optional<Pair<CombatAchievement, String>> parseCombatAchievement(String message) {
        Matcher matcher = ACHIEVEMENT_PATTERN.matcher(message);
        if (!matcher.find()) return Optional.empty();
        return Optional.of(matcher.group("tier"))
                .map(CombatAchievement.TIER_BY_LOWER_NAME::get)
                .map(tier -> Pair.of(
                        tier,
                        TASK_POINTS.matcher(
                                matcher.group("task")
                        ).replaceFirst("") // remove points suffix
                ));
    }
}

package io.droptracker;

import net.runelite.client.RuneLite;
import net.runelite.client.externalplugins.ExternalPluginManager;

public class DropTrackerPluginTest
{
	public static void main(String[] args) throws Exception
	{
		ExternalPluginManager.loadBuiltin(DropTrackerPlugin.class);
		RuneLite.main(args);
	}
}
