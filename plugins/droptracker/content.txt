package io.droptracker.util;

import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;

import java.io.IOException;
import java.time.Duration;
import java.time.format.DateTimeParseException;

/**
 * Serializes and deserializes {@link Duration} instances
 * from their equivalent ISO-8601 string representation.
 * <p>
 * This adapter exists because GSON does not ship with
 * a module for the Java 8 time API.
 *
 * @see <a href="https://github.com/google/gson/issues/1059">GSON Issue</a>
 */
public class DurationAdapter extends TypeAdapter<Duration> {
    @Override
    public void write(JsonWriter out, Duration duration) throws IOException {
        out.value(duration != null ? duration.toString() : null);
    }

    @Override
    public Duration read(JsonReader in) throws IOException {
        if (in.hasNext()) {
            try {
                return Duration.parse(in.nextString());
            } catch (DateTimeParseException ignored) {
            }
        }
        return null;
    }
}

package io.droptracker.util;


import com.google.gson.Gson;
import com.google.gson.annotations.SerializedName;
import com.google.gson.reflect.TypeToken;
import lombok.AccessLevel;
import lombok.Data;
import lombok.Setter;
import lombok.Value;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.ItemComposition;
import net.runelite.client.game.ItemManager;
import net.runelite.client.game.ItemVariationMapping;

import javax.inject.Inject;
import javax.inject.Singleton;
import java.io.BufferedReader;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.Reader;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.OptionalDouble;
import java.util.stream.Collectors;

@Slf4j
@Singleton
public class Rarity {
    private final Map<String, Collection<Drop>> dropsByNpcName = new HashMap<>(1024);
    private @Inject Gson gson;
    private @Inject ItemManager itemManager;
    public static final double EPSILON = 0.00001;
    private static final int[] FACTORIALS;

    @Inject
    void init() {
        Map<String, List<RawDrop>> raw;
        try (InputStream is = getClass().getResourceAsStream("/npc_drops.json");
             Reader reader = new BufferedReader(new InputStreamReader(Objects.requireNonNull(is)))) {
            raw = gson.fromJson(reader,
                    new TypeToken<Map<String, List<RawDrop>>>() {}.getType());
        } catch (Exception e) {
            log.error("Failed to read monster drop rates", e);
            return;
        }

        raw.forEach((npcName, rawDrops) -> {
            List<Drop> drops = rawDrops.stream()
                    .map(RawDrop::transform)
                    .flatMap(Collection::stream)
                    .collect(Collectors.toList());
            dropsByNpcName.put(npcName, drops);
        });
    }

    public OptionalDouble getRarity(String npcName, int itemId, int quantity) {
        ItemComposition composition = itemId >= 0 ? itemManager.getItemComposition(itemId) : null;
        int canonical = composition != null && composition.getNote() != -1 ? composition.getLinkedNoteId() : itemId;
        String itemName = composition != null ? composition.getMembersName() : "";
        Collection<Integer> variants = new HashSet<>(
                ItemVariationMapping.getVariations(ItemVariationMapping.map(canonical))
        );
        return dropsByNpcName.getOrDefault(npcName, Collections.emptyList())
                .stream()
                .filter(drop -> drop.getMinQuantity() <= quantity && quantity <= drop.getMaxQuantity())
                .filter(drop -> {
                    int id = drop.getItemId();
                    if (id == itemId) return true;
                    return variants.contains(id) && itemName.equals(itemManager.getItemComposition(id).getMembersName());
                })
                .mapToDouble(Drop::getProbability)
                .reduce(Double::sum);
    }

    @Value
    private static class Drop {
        int itemId;
        int minQuantity;
        int maxQuantity;
        double probability;
    }

    @Data
    @Setter(AccessLevel.PRIVATE)
    private static class RawDrop {
        private @SerializedName("i") int itemId;
        private @SerializedName("r") Integer rolls;
        private @SerializedName("d") double denominator;
        private @SerializedName("q") Integer quantity;
        private @SerializedName("m") Integer quantMin;
        private @SerializedName("n") Integer quantMax;

        Collection<Drop> transform() {
            int rounds = rolls != null ? rolls : 1;
            int min = quantMin != null ? quantMin : quantity;
            int max = quantMax != null ? quantMax : quantity;
            double prob = 1 / denominator;

            if (rounds == 1) {
                return List.of(new Drop(itemId, min, max, prob));
            }
            List<Drop> drops = new ArrayList<>(rounds);
            for (int successCount = 1; successCount <= rounds; successCount++) {
                double density = binomialProbability(prob, rounds, successCount);
                drops.add(new Drop(itemId, min * successCount, max * successCount, density));
            }
            return drops;
        }
        public double binomialProbability(double p, int nTrials, int kSuccess) {
            // https://en.wikipedia.org/wiki/Binomial_distribution#Probability_mass_function
            return binomialCoefficient(nTrials, kSuccess) * Math.pow(p, kSuccess) * Math.pow(1 - p, nTrials - kSuccess);
        }
        private int binomialCoefficient(int n, int k) {
            assert n < FACTORIALS.length && k <= n && k >= 0;
            return FACTORIALS[n] / (FACTORIALS[k] * FACTORIALS[n - k]); // https://en.wikipedia.org/wiki/nCk
        }
    }

    static {
        // precompute factorials from 0 to 9 for n-choose-k formula
        int n = 10; // max rolls in npc_drops.json is 9 (for Bloodthirsty Leagues IV tier 5 relic)
        int[] facts = new int[n];
        facts[0] = 1; // 0! = 1
        for (int i = 1; i < n; i++) {
            facts[i] = i * facts[i - 1];
        }
        FACTORIALS = facts;
    }
}

package io.droptracker.util;

import com.google.common.collect.ImmutableMap;
import com.google.inject.Inject;
import io.droptracker.DropTrackerConfig;
import io.droptracker.models.BossNotification;
import io.droptracker.DropTrackerPlugin;
import io.droptracker.models.CombatAchievement;
import io.droptracker.models.CustomWebhookBody;
import io.droptracker.models.Drop;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.*;
import net.runelite.api.annotations.Varbit;
import net.runelite.api.annotations.Varp;
import net.runelite.api.events.WidgetLoaded;
import net.runelite.api.widgets.ComponentID;
import net.runelite.api.widgets.InterfaceID;
import net.runelite.api.widgets.Widget;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.game.ItemStack;
import net.runelite.client.plugins.chatcommands.ChatCommandsPlugin;
import net.runelite.client.plugins.loottracker.LootReceived;
import net.runelite.client.plugins.loottracker.LootTrackerPlugin;
import net.runelite.http.api.loottracker.LootRecordType;
import org.apache.commons.lang3.ObjectUtils;
import org.apache.commons.lang3.tuple.Pair;
import org.apache.commons.lang3.tuple.Triple;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.annotations.Nullable;
import org.jetbrains.annotations.VisibleForTesting;

import java.time.Duration;
import java.time.Instant;
import java.time.LocalTime;
import java.time.temporal.Temporal;
import java.util.*;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.concurrent.atomic.AtomicReference;
import java.util.function.Predicate;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.TimeUnit;

import static io.droptracker.util.KCService.lastDrop;
import static java.time.temporal.ChronoField.*;
import static org.apache.commons.lang3.ObjectUtils.defaultIfNull;

@Slf4j
public class ChatMessageEvent {
    @Inject
    private final DropTrackerPlugin plugin;
    private final DropTrackerConfig config;

    @Inject
    protected Client client;

    @Inject
    private Rarity rarity;

    @Inject
    private ConfigManager configManager;

    @Inject
    private ClientThread clientThread;

    private ItemIDSearch itemIDFinder;
    private final AtomicInteger completed = new AtomicInteger(-1);
    private final AtomicBoolean popupStarted = new AtomicBoolean(false);
    public static final @Varp int COMPLETED_VARP = 2943, TOTAL_VARP = 2944;

    private static final Duration RECENT_DROP = Duration.ofSeconds(30L);
    @Inject
    public ChatMessageEvent(DropTrackerPlugin plugin, DropTrackerConfig config, ItemIDSearch itemIDFinder,
                            ScheduledExecutorService executor, ConfigManager configManager) {
        this.plugin = plugin;
        this.config = config;
        this.itemIDFinder = itemIDFinder;
        this.executor = executor;
        this.configManager = configManager;
    }
    private static final Pattern ACHIEVEMENT_PATTERN = Pattern.compile("Congratulations, you've completed an? (?<tier>\\w+) combat task: (?<task>.+)\\.");
    private static final Pattern TASK_POINTS = Pattern.compile("\\s+\\(\\d+ points?\\)$");
    @Varbit
    public static final int COMBAT_TASK_REPEAT_POPUP = 12456;
    /**
     * @see <a href="https://github.com/Joshua-F/cs2-scripts/blob/master/scripts/%5Bproc,ca_tasks_progress_bar%5D.cs2#L6-L11">CS2 Reference</a>
     */
    @VisibleForTesting
    public static final Map<CombatAchievement, Integer> CUM_POINTS_VARBIT_BY_TIER;

    /**
     * The cumulative points needed to unlock rewards for each tier, in a Red-Black tree.
     * <p>
     * This is populated by {@link #initThresholds()} based on {@link #CUM_POINTS_VARBIT_BY_TIER}.
     *
     * @see <a href="https://gachi.gay/01CAv">Rewards Thresholds at the launch of the points-based system</a>
     */
    private final NavigableMap<Integer, CombatAchievement> cumulativeUnlockPoints = new TreeMap<>();

    private static final Pattern PRIMARY_REGEX = Pattern.compile(
            "Your (?<key>[\\w\\s:'-]+) (?<type>kill|chest|completion) count is:? (?<value>[\\d,]+)"
    );
    private static final Pattern SECONDARY_REGEX = Pattern.compile("Your (?<type>kill|chest|completed) (?<key>[\\w\\s:]+) count is:? (?<value>[\\d,]+)");


    private static final String BA_BOSS_NAME = "Penance Queen";
    public static final String GAUNTLET_NAME = "Gauntlet", GAUNTLET_BOSS = "Crystalline Hunllef";

    static final Pattern COLLECTION_LOG_REGEX = Pattern.compile("New item added to your collection log: (?<itemName>(.*))");
    public static final String ADDITION_WARNING = "Collection notifier will not fire unless you enable the game setting: Collection log - New addition notification";
    private static final int POPUP_PREFIX_LENGTH = "New item:".length();
    public static final String CG_NAME = "Corrupted Gauntlet", CG_BOSS = "Corrupted Hunllef";
    private static final String TOA = "Tombs of Amascut";
    private static final String TOB = "Theatre of Blood";
    private static final String COX = "Chambers of Xeric";
    private static final String RL_CHAT_CMD_PLUGIN_NAME = ChatCommandsPlugin.class.getSimpleName().toLowerCase();
    private static final String RL_LOOT_PLUGIN_NAME = LootTrackerPlugin.class.getSimpleName().toLowerCase();
    @Varbit
    public static final int TOTAL_POINTS_ID = 14815;
    @Varbit
    public static final int GRANDMASTER_TOTAL_POINTS_ID = 14814;
    @VisibleForTesting
    static final int MAX_BAD_TICKS = 10;

    private final AtomicInteger badTicks = new AtomicInteger();
    private final AtomicReference<BossNotification> bossData = new AtomicReference<>();

    private static Pair<String, Integer> mostRecentNpcData = null;


    @Varbit
    public static final int KILL_COUNT_SPAM_FILTER = 4930;

    private static final long MESSAGE_LOOT_WINDOW = 15000; // 15 seconds
    private final Map<String, BossNotification> pendingNotifications = new HashMap<>();
    private final ScheduledExecutorService executor;

    private static final Duration PB_MESSAGE_WINDOW = Duration.ofSeconds(5); // Adjust window as needed
    private final Map<String, Triple<Duration, Duration, Boolean>> recentTimeMessages = new HashMap<>();
    private final Map<String, Instant> timeMessageTimestamps = new HashMap<>();

    private static final Pattern[] TIME_PATTERNS = {
            // Team patterns
            Pattern.compile("Team size: .+? Duration: (\\d*:*\\d+:\\d+\\.?\\d*) Personal best: (\\d*:*\\d+:\\d+\\.?\\d*)\\.*"),
            Pattern.compile("Team size: .+? Fight duration: (\\d*:*\\d+:\\d+\\.?\\d*) Personal best: (\\d*:*\\d+:\\d+\\.?\\d*)\\.*"),
            // ToA patterns
            Pattern.compile("Tombs of Amascut: Expert Mode total completion time: (\\d*:*\\d+:\\d+\\.?\\d*)\\. Personal best: (\\d*:*\\d+:\\d+\\.*\\d*)\\.*"),
            Pattern.compile("Tombs of Amascut total completion time: (\\d*:*\\d+:\\d+\\.?\\d*)\\. Personal best: (\\d*:*\\d+:\\d+\\.?\\d*)\\.*"),
            // ToB pattern
            Pattern.compile("Theatre of Blood completion time: (\\d*:*\\d+:\\d+\\.?\\d*)\\. Personal best: (\\d*:*\\d+:\\d+\\.?\\d*)\\.*"),
            // Gauntlet pattern - fixed spacing and case
            Pattern.compile("Challenge duration: (\\d*:*\\d+:\\d+\\.?\\d*)\\. Personal best: (\\d*:*\\d+:\\d+\\.?\\d*)\\.*"),
            Pattern.compile("Corrupted challenge duration: (\\d*:*\\d+:\\d+\\.?\\d*)\\. Personal best: (\\d*:*\\d+:\\d+\\.?\\d*)\\.*"),
            //Colosseum Pattern
            Pattern.compile("Colosseum duration: (\\d*:*\\d+:\\d+\\.?\\d*)\\. Personal best: (\\d*:*\\d+:\\d+\\.?\\d*)\\.*"),
            // Generic boss pattern
            Pattern.compile("Duration: (\\d*:*\\d+:\\d+\\.?\\d*)\\. Personal best: (\\d*:*\\d+:\\d+\\.?\\d*)\\.*"),
            Pattern.compile("Fight duration: (\\d*:*\\d+:\\d+\\.?\\d*)\\. Personal best: (\\d*:*\\d+:\\d+\\.?\\d*)\\.*"),
            Pattern.compile("Fight duration: (\\d*:*\\d+:\\d+\\.?\\d*)\\. Personal best: (\\d*:*\\d+:\\d+\\.?\\d*)\\.*")
    };
    private static final Pattern[] PB_PATTERNS = {
            // Team patterns
            Pattern.compile("Team size: .+? Duration: (\\d*:*\\d+:\\d+\\.?\\d*) \\(new personal best\\)\\.*"),
            Pattern.compile("Team size: .+? Fight duration: (\\d*:*\\d+:\\d+\\.?\\d*) \\(new personal best\\)\\.*"),
            // ToA patterns
            Pattern.compile("Tombs of Amascut: Expert Mode total completion time: (\\d*:*\\d+:\\d+\\.?\\d*) \\(new personal best\\)\\.*"),
            Pattern.compile("Tombs of Amascut total completion time: (\\d*:*\\d+:\\d+\\.?\\d*) \\(new personal best\\)\\.*"),
            // ToB pattern
            Pattern.compile("Theatre of Blood completion time: (\\d*:*\\d+:\\d+\\.?\\d*) \\(new personal best\\)\\.*"),
            // Gauntlet pattern - fixed spacing and case
            Pattern.compile("Challenge duration: (\\d*:*\\d+:\\d+\\.?\\d*) \\(new personal best\\)\\.*"),
            Pattern.compile("Corrupted challenge duration: (\\d*:*\\d+:\\d+\\.?\\d*) \\(new personal best\\)\\.*"),
            // Colosseum Pattern
            Pattern.compile("Colosseum duration: (\\d*:*\\d+:\\d+\\.?\\d*) \\(new personal best\\)\\.*"),
            // Generic boss pattern
            Pattern.compile("Duration: (\\d*:*\\d+:\\d+\\.?\\d*) \\(new personal best\\)\\.*"),
            Pattern.compile("Fight duration: (\\d*:*\\d+:\\d+\\.?\\d*) \\(new personal best\\)\\.*"),
    };
    private final Map<String,TimeData> pendingTimeData = new HashMap<>();
    private final Map<String,TimeData> recentTimeData = new HashMap<>();
    private String lastProcessedKill = null;
    private long lastProcessedTime = 0;
    private static final long DUPLICATE_THRESHOLD = 5000;
    private String teamSize = null;
    private int lastNpcTypeTarget;

    public boolean isEnabled() {
        return true;
    }

    public void onGameMessage(String message) {
        if (!isEnabled()) return;
        checkPB(message);
        checkTime(message);


        parseBossKill(message).ifPresent(this::updateData);
        parseCombatAchievement(message).ifPresent(pair -> processCombatAchievement(pair.getLeft(), pair.getRight()));
    }

    public void onChatMessage(String chatMessage) {
        if (client.getVarbitValue(Varbits.COLLECTION_LOG_NOTIFICATION) != 1) {
            // require notifier enabled without popup mode to use chat event
            return;
        }
        Matcher collectionMatcher = COLLECTION_LOG_REGEX.matcher(chatMessage);
        if (collectionMatcher.find()) {
            String itemName = collectionMatcher.group("itemName");
            clientThread.invokeLater(() -> processCollection(itemName));
        }
    }

    public void onScript(int scriptId) {
        if (scriptId == ScriptID.NOTIFICATION_START) {
            popupStarted.set(true);
        } else if (scriptId == ScriptID.NOTIFICATION_DELAY) {
            String topText = client.getVarcStrValue(VarClientStr.NOTIFICATION_TOP_TEXT);
            if (popupStarted.getAndSet(false) && "Collection log".equalsIgnoreCase(topText) && isEnabled()) {
                String bottomText = plugin.sanitize(client.getVarcStrValue(VarClientStr.NOTIFICATION_BOTTOM_TEXT));
                processCollection(bottomText.substring(POPUP_PREFIX_LENGTH).trim());
            }
        }
    }

    private boolean isCorruptedGauntlet(LootReceived event) {
        return event.getType() == LootRecordType.EVENT && lastDrop != null && "The Gauntlet".equals(event.getName())
                && (CG_NAME.equals(lastDrop.getSource()) || CG_BOSS.equals(lastDrop.getSource()));
    }

    public void onFriendsChatNotification(String message) {
        /* Chambers of Xeric completions are sent in the Friends chat channel */
        if (message.startsWith("Congratulations - your raid is complete!"))
            this.onGameMessage(message);
    }

    public String getStandardizedSource(LootReceived event) {
        if (isCorruptedGauntlet(event)) {
            return CG_NAME;
        } else if (lastDrop != null && shouldUseChatName(event)) {
            return lastDrop.getSource(); // distinguish entry/expert/challenge modes
        }
        return event.getName();
    }

    private boolean shouldUseChatName(LootReceived event) {
        assert lastDrop != null;
        String lastSource = lastDrop.getSource();
        Predicate<String> coincides = source -> source.equals(event.getName()) && lastSource.startsWith(source);
        return coincides.test(TOA) || coincides.test(TOB) || coincides.test(COX);
    }

    public void onWidget(WidgetLoaded event) {
        if (!isEnabled())
            return;
        /* Handle BA events */
        if (event.getGroupId() == InterfaceID.BA_REWARD) {
            Widget widget = client.getWidget(ComponentID.BA_REWARD_REWARD_TEXT);
            if (widget != null && widget.getText().contains("80 ") && widget.getText().contains("5 ")) {
                int gambleCount = client.getVarbitValue(Varbits.BA_GC);
                BossNotification notification = new BossNotification(BA_BOSS_NAME, gambleCount, "The Queen is dead!", null, null,null);
                bossData.set(notification);
            }
        }
    }
    public void onTick() {
        BossNotification data = this.bossData.get();

        if (data != null) {
            if (data.getBoss() != null) {
                if (isEnabled()) {
                    processKill(data);
                    return;
                }
                reset();
            } else if (badTicks.incrementAndGet() > MAX_BAD_TICKS) {
                reset();
            }
        }
        else if (mostRecentNpcData != null) {
            if (bossData.get() != null) {
                processKill(bossData.get());
            }
            plugin.ticksSinceNpcDataUpdate += 1;
        } else {
            if (plugin.ticksSinceNpcDataUpdate > 1)  {
                plugin.ticksSinceNpcDataUpdate = 0;
            }
        }
        if (plugin.ticksSinceNpcDataUpdate >= 5 && mostRecentNpcData != null) {
            mostRecentNpcData = null;
        }

        // Clean up old time messages
        Instant cutoff = Instant.now().minus(PB_MESSAGE_WINDOW);
        timeMessageTimestamps.entrySet().removeIf(entry ->
                entry.getValue().isBefore(cutoff)
        );
        recentTimeMessages.keySet().removeIf(boss ->
                !timeMessageTimestamps.containsKey(boss)
        );
    }
    private void processCollection(String itemName) {
        int completed = client.getVarpValue(COMPLETED_VARP);
        int total = client.getVarpValue(TOTAL_VARP);

        boolean varpValid = total > 0 && completed > 0;
        if (!varpValid) {
            // This occurs if the player doesn't have the character summary tab selected
            log.debug("Collection log progress varps were invalid ({} / {})", completed, total);
        }
        Integer itemId = itemIDFinder.findItemId(itemName);
        Drop loot = itemId != null ? getLootSource(itemId) : null;
        Integer killCount = loot != null ? KCService.getKillCount(loot.getCategory(), loot.getSource()) : null;
        OptionalDouble itemRarity = ((loot != null) && (loot.getCategory() == LootRecordType.NPC)) ?
                rarity.getRarity(loot.getSource(), itemId, 1) : OptionalDouble.empty();
        CustomWebhookBody collectionLogBody = new CustomWebhookBody();
        CustomWebhookBody.Embed collEmbed = new CustomWebhookBody.Embed();
        collEmbed.addField("type", "collection_log",true);
        if (loot != null) {
            if (loot.getSource() != null) {
                Drop drop = getLootSource(itemId);
            }
        }
        collEmbed.addField("source", loot != null ? loot.getSource() : "unknown", true);
        collEmbed.addField("item", itemName, true);
        collEmbed.addField("kc", String.valueOf(killCount),true);
        collEmbed.addField("rarity", String.valueOf(itemRarity),true);
        collEmbed.addField("item_id", String.valueOf(itemId),true);
        collEmbed.addField("player", client.getLocalPlayer().getName(), true);
        collEmbed.addField("slots", completed + "/" + total, true);
        collEmbed.addField("p_v",plugin.pluginVersion,true);
        String accountHash = String.valueOf(client.getAccountHash());
        collEmbed.addField("acc_hash", accountHash, true);
        collectionLogBody.getEmbeds().add(collEmbed);

        plugin.sendDataToDropTracker(collectionLogBody, "2");
    }

    private void processCombatAchievement(CombatAchievement tier, String task) {
        // delay notification for varbits to be updated
        clientThread.invokeAtTickEnd(() -> {
            int taskPoints = tier.getPoints();
            int totalPoints = client.getVarbitValue(TOTAL_POINTS_ID);

            Integer nextUnlockPointsThreshold = cumulativeUnlockPoints.ceilingKey(totalPoints + 1);
            Map.Entry<Integer, CombatAchievement> prev = cumulativeUnlockPoints.floorEntry(totalPoints);
            int prevThreshold = prev != null ? prev.getKey() : 0;

            Integer tierProgress, tierTotalPoints;
            if (nextUnlockPointsThreshold != null) {
                tierProgress = totalPoints - prevThreshold;
                tierTotalPoints = nextUnlockPointsThreshold - prevThreshold;
            } else {
                tierProgress = tierTotalPoints = null;
            }

            boolean crossedThreshold = prevThreshold > 0 && totalPoints - taskPoints < prevThreshold;
            CombatAchievement completedTier = crossedThreshold ? prev.getValue() : null;
            String completedTierName = completedTier != null ? completedTier.getDisplayName() : "N/A";

            String player = client.getLocalPlayer().getName();
            String accountHash = String.valueOf(client.getAccountHash());
            CustomWebhookBody combatWebhook = new CustomWebhookBody();
            combatWebhook.setContent(player + " has completed a new combat task:");
            CustomWebhookBody.Embed combatAchievementEmbed = new CustomWebhookBody.Embed();
            combatAchievementEmbed.addField("type", "combat_achievement",true);
            combatAchievementEmbed.addField("tier", tier.toString(),true);
            combatAchievementEmbed.addField("task", task,true);
            combatAchievementEmbed.addField("player_name", plugin.getLocalPlayerName(), true);
            combatAchievementEmbed.addField("acc_hash", accountHash, true);
            combatAchievementEmbed.addField("points", String.valueOf(taskPoints),true);
            combatAchievementEmbed.addField("total_points", String.valueOf(totalPoints),true);
            combatAchievementEmbed.addField("completed", completedTierName,true);
            combatAchievementEmbed.addField("p_v", plugin.pluginVersion,true);
            combatWebhook.getEmbeds().add(combatAchievementEmbed);
            plugin.sendDataToDropTracker(combatWebhook, "3");
        });
    }

    private int getKc(String boss)
    {
        Integer killCount = configManager.getRSProfileConfiguration("killcount", boss.toLowerCase(), int.class);
        return killCount == null ? 0 : killCount;
    }

    private void processKill(BossNotification data) {
        if (data == null) {
            return;
        }
        if (data.getBoss() == null || data.getCount() == null)
            return;

        String killIdentifier = data.getBoss() + "-" + data.getCount();
        long currentTime = System.currentTimeMillis();

        if(killIdentifier.equals(lastProcessedKill) && (currentTime - lastProcessedTime) < DUPLICATE_THRESHOLD){
            return;
        }
        lastProcessedKill = killIdentifier;
        lastProcessedTime = currentTime;
        boolean ba = data.getBoss().equals(BA_BOSS_NAME);
        boolean isPb = data.isPersonalBest() == Boolean.TRUE;
        String player = plugin.getLocalPlayerName();
        String time = null;
        final String[] timeRef = {null};
        final String[] bestTimeRef = {null};
        clientThread.invokeLater(() -> {
            timeRef[0] = formatTime(data.getTime(), isPreciseTiming(client));
            bestTimeRef[0] = formatTime(data.getBestTime(), isPreciseTiming(client));
            String accountHash = String.valueOf(client.getAccountHash());
            CustomWebhookBody.Embed killEmbed = null;
            CustomWebhookBody killWebhook = new CustomWebhookBody();
            killEmbed = new CustomWebhookBody.Embed();
            String bossName = "";
            if (teamSize == null || teamSize.equals("")) {
                teamSize = "Solo";
            }
            if (mostRecentNpcData != null) {
                bossName = mostRecentNpcData.getLeft();
            } else if (!pendingNotifications.isEmpty()) {
                if (pendingNotifications.size() > 1) {
                } else {
                    bossName = pendingNotifications.get(0).getBoss();
                }
            }
            if (bossName == null || bossName.equalsIgnoreCase("")){
                return;
            }
            killEmbed.setTitle(player + " has killed a boss:");
            killEmbed.addField("type", "npc_kill", true);
            killEmbed.addField("boss_name", bossName, true);
            killEmbed.addField("player_name", plugin.getLocalPlayerName(), true);
            killEmbed.addField("kill_time", timeRef[0], true);
            killEmbed.addField("best_time", bestTimeRef[0], true);
            killEmbed.addField("is_pb", String.valueOf(isPb), true);
            killEmbed.addField("team_size", teamSize,true);
            killEmbed.addField("acc_hash", accountHash, true);
            killEmbed.addField("p_v",plugin.pluginVersion,true);
            killWebhook.getEmbeds().add(killEmbed);
            plugin.sendDataToDropTracker(killWebhook, "1");
            mostRecentNpcData = null;
            pendingNotifications.clear();
            bossData.set(null);
            teamSize = null;
        });
    }

    private void updateData(BossNotification updated) {
        bossData.getAndUpdate(old -> {
            if (old == null) {
                // Store pending notification for later processing
                pendingNotifications.put(updated.getBoss(), updated);

                // Schedule cleanup task
                executor.schedule(() -> {
                    BossNotification pending = pendingNotifications.remove(updated.getBoss());
                    if (pending != null) {
                        // If notification wasn't processed by loot event, process it now
                        processKill(pending);
                    }
                }, MESSAGE_LOOT_WINDOW, TimeUnit.MILLISECONDS);

                return updated;
            } else {

                return new BossNotification(
                        defaultIfNull(updated.getBoss(), old.getBoss()),
                        defaultIfNull(updated.getCount(), old.getCount()),
                        defaultIfNull(updated.getGameMessage(), old.getGameMessage()),
                        defaultIfNull(updated.getTime(), old.getTime()),
                        defaultIfNull(updated.getBestTime(), old.getBestTime()),
                        defaultIfNull(updated.isPersonalBest(), old.isPersonalBest())
                );
            }
        });
    }
    public void reset() {
        bossData.set(null);
        badTicks.set(0);
        teamSize = null;
    }
    @VisibleForTesting
    static Optional<Pair<CombatAchievement, String>> parseCombatAchievement(String message) {
        Matcher matcher = ACHIEVEMENT_PATTERN.matcher(message);
        if (!matcher.find()) return Optional.empty();
        return Optional.of(matcher.group("tier"))
                .map(CombatAchievement.TIER_BY_LOWER_NAME::get)
                .map(tier -> Pair.of(
                        tier,
                        TASK_POINTS.matcher(
                                matcher.group("task")
                        ).replaceFirst("") // remove points suffix
                ));
    }

    private Optional<BossNotification> parseBossKill(String message) {
        Optional<Pair<String, Integer>> boss = parseBoss(message);
        return boss.flatMap(pair -> {
            String bossName = pair.getLeft();
            // retrieve the stored timeData for this bossName, if any is stored...
            // for cases where a time message may appear before the boss name/kc message appears
            TimeData timeData = pendingTimeData.get(bossName);

            //Search for stored TimeData
            if(timeData != null){


                BossNotification newBossData  = new BossNotification(
                        bossName,
                        pair.getRight(),
                        message,
                        timeData.time,
                        timeData.bestTime,
                        timeData.isPb
                );
                bossData.set(newBossData);
                return Optional.of(newBossData);
            } else {
                BossNotification currentData = bossData.get();
                if (currentData != null) {
                    BossNotification newBossData = new BossNotification(
                            bossName,
                            pair.getRight(),
                            "",
                            currentData.getTime(),
                            currentData.getBestTime(),
                            currentData.isPersonalBest()
                    );
                    bossData.set(newBossData);
                    return Optional.of(newBossData);
                }
                return Optional.empty();
            }
        });
    }
    private Optional<Triple<Duration, Duration, Boolean>> parseKillTime(String message, String bossName) {

        //check for Pb
        for(Pattern pattern: PB_PATTERNS){
            Matcher timeMatcher = pattern.matcher(message);
            if (timeMatcher.find()) {
                String timeStr = "";
                String bestTimeStr = "";
                boolean isPb = true;
                try {
                    timeStr = timeMatcher.group(1);
                    bestTimeStr = timeMatcher.group(1);
                }catch (Exception e){
                }
                Duration time = parseTime(timeStr);
                Duration bestTime = parseTime(bestTimeStr);
                setTeamSize(bossName,message);
                storeBossTime(bossName,time,bestTime,isPb);
                return Optional.of(Triple.of(time, bestTime, isPb));
            }
        }
        //check for time
        for(Pattern pattern: TIME_PATTERNS) {
            boolean isPb = false;
            Matcher timeMatcher = pattern.matcher(message);

            if (timeMatcher.find()) {
                String timeStr = "";
                String bestTimeStr = "";
                try {
                    timeStr = timeMatcher.group(1);
                    bestTimeStr = timeMatcher.group(2);
                } catch (Exception e) {
                }
                Duration time = parseTime(timeStr);
                Duration bestTime = parseTime(bestTimeStr);
                setTeamSize(bossName,message);
                storeBossTime(bossName,time,bestTime,isPb);

                return Optional.of(Triple.of(time, bestTime, isPb));
            }

        }
        return Optional.empty();

    }

    @NotNull
    private Duration parseTime(String timeStr) {

        try {
            // Split into parts based on : and .
            String timePart = timeStr.contains(".") ? timeStr.substring(0, timeStr.indexOf('.')) : timeStr;
            String[] timeParts = timePart.split(":");

            long hours = 0;
            long minutes = 0;
            long seconds = 0;
            long millis = 0;

            // Parse hours:minutes:seconds or minutes:seconds
            if (timeParts.length == 3) {  // h:m:s
                hours = Long.parseLong(timeParts[0]);
                minutes = Long.parseLong(timeParts[1]);
                seconds = Long.parseLong(timeParts[2]);
            } else if (timeParts.length == 2) {  // m:s
                minutes = Long.parseLong(timeParts[0]);
                seconds = Long.parseLong(timeParts[1]);
            }

            // Parse milliseconds if present
            if (timeStr.contains(".")) {
                String millisStr = timeStr.substring(timeStr.indexOf('.') + 1);
                // Pad with zeros if needed
                while (millisStr.length() < 3) {
                    millisStr += "0";
                }
                millis = Long.parseLong(millisStr);
            }

            Duration duration = Duration.ofHours(hours)
                    .plusMinutes(minutes)
                    .plusSeconds(seconds)
                    .plusMillis(millis);
            return duration;

        } catch (Exception e) {
            e.printStackTrace();
            return null;
        }
    }

    public Optional<Pair<String, Integer>> parseBoss(String message) {
        Matcher primary = PRIMARY_REGEX.matcher(message);
        Matcher secondary = SECONDARY_REGEX.matcher(message);


        if (primary.find()) {
            String boss = parsePrimaryBoss(primary.group("key"), primary.group("type"));
            String count = primary.group("value");
            if (boss != null) {
                try {
                    int killCount = Integer.parseInt(count.replace(",", ""));
                    mostRecentNpcData = Pair.of(boss, killCount);
                    plugin.ticksSinceNpcDataUpdate = 0;
                    return Optional.of(mostRecentNpcData);
                } catch (NumberFormatException e) {
                }
            }
        } else
        if (secondary.find()){
            String key = parseSecondary(secondary.group("key"));
            String value = secondary.group("value");
            if (key != null) {
                try {
                    int killCount = Integer.parseInt(value.replace(",", ""));
                    mostRecentNpcData = Pair.of(key, killCount);
                    plugin.ticksSinceNpcDataUpdate = 0;
                    return Optional.of(mostRecentNpcData);
                } catch (NumberFormatException e) {
                }
            }
        }
        return Optional.empty();
    }


    private static Optional<Pair<String, Integer>> result(String boss, String count) {
        try {
            return Optional.ofNullable(boss).map(k -> Pair.of(boss, Integer.parseInt(count)));
        } catch (NumberFormatException e) {
            log.debug("Failed to parse kill count [{}] for boss [{}]", count, boss);
            return Optional.empty();
        }
    }

    @Nullable
    private static String parsePrimaryBoss(String boss, String type) {
        switch (type.toLowerCase()) {
            case "chest":
                if ("Barrows".equalsIgnoreCase(boss))
                    return boss;
                if ("Lunar".equals(boss))
                    return boss + " " + type;
                return null;

            case "completion":
                if (GAUNTLET_NAME.equalsIgnoreCase(boss))
                    return GAUNTLET_BOSS;
                if (CG_NAME.equalsIgnoreCase(boss))
                    return CG_BOSS;
                return null;

            case "kill":
                return boss;

            default:
                return null;
        }
    }

    private static String parseSecondary(String boss) {
        if (boss == null || "Wintertodt".equalsIgnoreCase(boss))
            return boss;

        int modeSeparator = boss.lastIndexOf(':');
        String raid = modeSeparator > 0 ? boss.substring(0, modeSeparator) : boss;
        if (raid.equalsIgnoreCase("Theatre of Blood")
                || raid.equalsIgnoreCase("Tombs of Amascut")
                || raid.equalsIgnoreCase("Chambers of Xeric")
                || raid.equalsIgnoreCase("Chambers of Xeric Challenge Mode"))
            return boss;

        return null;
    }



    @NotNull
    public String formatTime(@Nullable Duration duration, boolean precise) {
        Temporal time = ObjectUtils.defaultIfNull(duration, Duration.ZERO).addTo(LocalTime.of(0, 0));
        StringBuilder sb = new StringBuilder();

        int h = time.get(HOUR_OF_DAY);
        if (h > 0)
            sb.append(String.format("%02d", h)).append(':');

        sb.append(String.format("%02d", time.get(MINUTE_OF_HOUR))).append(':');
        sb.append(String.format("%02d", time.get(SECOND_OF_MINUTE)));

        if (precise)
            sb.append('.').append(String.format("%02d", time.get(MILLI_OF_SECOND) / 10));

        return sb.toString();
    }

    public boolean isPreciseTiming(@NotNull Client client) {
        @Varbit int ENABLE_PRECISE_TIMING = 11866;
        return client.getVarbitValue(ENABLE_PRECISE_TIMING) > 0;
    }

    private void initThresholds() {
        CUM_POINTS_VARBIT_BY_TIER.forEach((tier, varbitId) -> {
            int cumulativePoints = client.getVarbitValue(varbitId);
            if (cumulativePoints > 0)
                cumulativeUnlockPoints.put(cumulativePoints, tier);
        });
    }
    static {
        CUM_POINTS_VARBIT_BY_TIER = ImmutableMap.<CombatAchievement, Integer>builderWithExpectedSize(6)
                .put(CombatAchievement.EASY, 4132) // 33 = 33 * 1
                .put(CombatAchievement.MEDIUM, 10660) // 115 = 33 + 41 * 2
                .put(CombatAchievement.HARD, 10661) // 304 = 115 + 63 * 3
                .put(CombatAchievement.ELITE, 14812) // 820 = 304 + 129 * 4
                .put(CombatAchievement.MASTER, 14813) // 1465 = 820 + 129 * 5
                .put(CombatAchievement.GRANDMASTER, GRANDMASTER_TOTAL_POINTS_ID) // 2005 = 1465 + 90 * 6
                .build();
    }
    @Nullable
    private Drop getLootSource(int itemId) {
        Drop drop = KCService.getLastDrop();
        if (drop == null) return null;
        if (Duration.between(drop.getTime(), Instant.now()).compareTo(RECENT_DROP) > 0) return null;
        for (ItemStack item : drop.getItems()) {
            if (item.getId() == itemId) {
                return drop;
            }
        }
        return null;
    }

    public void onLootReceived(LootReceived event) {
        String source = getStandardizedSource(event);
        BossNotification pending = pendingNotifications.remove(source);

        if (pending != null) {
            // We found a pending notification for this boss, process it now
            if (pending.getBoss().equals("")) {
                String npcName = source;
                BossNotification trueBossNoti = new BossNotification(npcName, pending.getCount(), pending.getGameMessage(), pending.getTime(), pending.getBestTime(), pending.isPersonalBest());
                bossData.set(trueBossNoti);
            }
            processKill(pending);
        } else {
            // Store the loot event info for later matching with chat message
            lastDrop = new Drop(source, event.getType(), event.getItems());
        }
    }

    //Storing boss Time to either access at a later point or to move through sending the time
    private void storeBossTime(String bossName, Duration time, Duration bestTime, boolean isPb){
        TimeData timeData = new TimeData(time,bestTime,isPb);
        pendingTimeData.put(bossName,timeData);
        BossNotification withTime = null;
        if (mostRecentNpcData != null) {
            withTime = new BossNotification(
                    bossName,
                    mostRecentNpcData.getRight(),
                    "",
                    time,
                    bestTime,
                    isPb
            );

        } else {
            withTime = new BossNotification(
                    "",
                    0,
                    "",
                    time,
                    bestTime,
                    isPb
            );
        }
        bossData.set(withTime);
        processKill(withTime);

    }
    private static class TimeData {
        final Duration time;
        final Duration bestTime;
        final boolean isPb;
        final Instant timestamp;

        TimeData(Duration time, Duration bestTime, boolean isPb) {
            this.time = time;
            this.bestTime = bestTime;
            this.isPb = isPb;
            this.timestamp = Instant.now();
        }

        boolean isRecent() {
            return Duration.between(timestamp, Instant.now()).compareTo(Duration.ofSeconds(2)) <= 0;
        }
        @Override
        public String toString(){
            return String.format("TimeData(time=%s, bestTime=%s, isPb%s)",time,bestTime,isPb);
        }
    }

    //Checking current message for time Message containing PB
    private void checkPB(String message){
        //Check for PB time
        for(Pattern pattern: PB_PATTERNS){
            Matcher timeMatcher = pattern.matcher(message);

            if (timeMatcher.find()) {
                String timeStr = "";
                String bestTimeStr = "";
                boolean isPb = true;
                try {
                    timeStr = timeMatcher.group(1);
                    bestTimeStr = timeMatcher.group(1);
                }catch (Exception e){
                }
                Duration time = parseTime(timeStr);
                Duration bestTime = parseTime(bestTimeStr);
                String bossName = mostRecentNpcData != null ? mostRecentNpcData.getLeft() : null;
                if (bossName != null) {
                    setTeamSize(bossName,message);
                    storeBossTime(bossName, time, bestTime, isPb);
                } else {
                    storeBossTime("Grotesque Guardians",time,bestTime,isPb);
                    teamSize = "Solo";
                }

                if (message.contains("Team Size:")) {
                    setTeamSize("Chambers of Xeric",message);
                    storeBossTime("Chambers of Xeric", time, bestTime, isPb);
                    storeBossTime("Chambers of Xeric Challenge Mode", time, bestTime, isPb);
                    storeBossTime("The Nightmare", time, bestTime, isPb);
                    storeBossTime("Phosani's Nightmare",time,bestTime,isPb);
                } else if (message.contains("Tombs of Amascut")) {
                    setTeamSize("Tombs of Amascut",message);
                    storeBossTime("Tombs of Amascut: Entry Mode", time,bestTime,isPb);
                    storeBossTime("Tombs of Amascut", time, bestTime, isPb);
                    storeBossTime("Tombs of Amascut: Expert Mode", time, bestTime, isPb);
                }else if(message.contains("Theatre of Blood")){
                    setTeamSize("Theatre of Blood",message);
                    storeBossTime("Theatre of Blood: Entry Mode", time,bestTime,isPb);
                    storeBossTime("Theatre of Blood",time,bestTime,isPb);
                    storeBossTime("Theatre of Blood: Hard Mode",time,bestTime,isPb);
                }else if (message.contains("Corrupted challenge")) {
                    setTeamSize("Corrupted Hunllef",message);
                    storeBossTime("Corrupted Hunllef", time, bestTime, isPb);
                } else if (message.contains("Challenge duration")) {
                    setTeamSize("Crystalline Hunllef",message);
                    storeBossTime("Crystalline Hunllef", time, bestTime, isPb);
                } else if (message.contains("Colosseum duration")){
                    setTeamSize("Sol Heredit",message);
                    storeBossTime("Sol Heredit",time,bestTime,isPb);
                }



            }

        }
    }
    //Checking current message for time Message (not containing PB)
    private void checkTime(String message){
        //check for time
        for(Pattern pattern: TIME_PATTERNS) {

            Matcher timeMatcher = pattern.matcher(message);
            if (timeMatcher.find()) {
                String timeStr = "";
                String bestTimeStr = "";
                boolean isPb = false;
                try {
                    timeStr = timeMatcher.group(1);
                    bestTimeStr = timeMatcher.group(2);
                }catch (Exception e){
                }

                Duration time = parseTime(timeStr);
                Duration bestTime = parseTime(bestTimeStr);

                String bossName = mostRecentNpcData != null ? mostRecentNpcData.getLeft() : null;
                if (bossName != null) {
                    setTeamSize(bossName, message);
                    storeBossTime(bossName, time, bestTime, isPb);
                    return;
                } else {
                    storeBossTime("Grotesque Guardians",time,bestTime,isPb);
                    teamSize = "Solo";
                }
                // removed else if here, as if we only entered the below clauses
                // where bossname is null, it may not work as expected...
                if (message.contains("Team size:")) {
                    setTeamSize("Chambers of Xeric",message);
                    storeBossTime("Chambers of Xeric", time, bestTime, isPb);
                    storeBossTime("Chambers of Xeric Challenge Mode", time, bestTime, isPb);
                    storeBossTime("The Nightmare", time, bestTime, isPb);
                    storeBossTime("Phosani's Nightmare",time,bestTime,isPb);
                } else if (message.contains("Tombs of Amascut")) {
                    setTeamSize("Tombs of Amascut",message);
                    storeBossTime("Tombs of Amascut", time, bestTime, isPb);
                    storeBossTime("Tombs of Amascut: Expert Mode", time, bestTime, isPb);
                }else if(message.contains("Theatre of Blood")){
                    setTeamSize("Theatre of Blood",message);
                    storeBossTime("Theatre of Blood",time,bestTime,isPb);
                    storeBossTime("Theatre of Blood: Hard Mode",time,bestTime,isPb);
                }else if (message.contains("Corrupted challenge")) {
                    setTeamSize("Corrupted Hunllef",message);
                    storeBossTime("Corrupted Hunllef", time, bestTime, isPb);
                } else if (message.contains("Challenge duration")) {
                    setTeamSize("Crystalline Hunllef",message);
                    storeBossTime("Crystalline Hunllef", time, bestTime, isPb);
                }

            }
        }
    }

    /*
        We can obtain the group size for TOB/TOA using the player orb varbits
    */
    private String tobTeamSize() {

        Integer teamSize = Math.min(client.getVarbitValue(Varbits.THEATRE_OF_BLOOD_ORB1), 1) +
                Math.min(client.getVarbitValue(Varbits.THEATRE_OF_BLOOD_ORB2), 1) +
                Math.min(client.getVarbitValue(Varbits.THEATRE_OF_BLOOD_ORB3), 1) +
                Math.min(client.getVarbitValue(Varbits.THEATRE_OF_BLOOD_ORB4), 1) +
                Math.min(client.getVarbitValue(Varbits.THEATRE_OF_BLOOD_ORB5), 1);
        if(teamSize == 1){
            return "Solo";
        }
        return teamSize.toString();
    }

    private String toaTeamSize() {
        Integer teamSize = Math.min(client.getVarbitValue(Varbits.TOA_MEMBER_0_HEALTH), 1 +
                Math.min(client.getVarbitValue(Varbits.TOA_MEMBER_1_HEALTH), 1) +
                Math.min(client.getVarbitValue(Varbits.TOA_MEMBER_2_HEALTH), 1) +
                Math.min(client.getVarbitValue(Varbits.TOA_MEMBER_3_HEALTH), 1) +
                Math.min(client.getVarbitValue(Varbits.TOA_MEMBER_4_HEALTH), 1) +
                Math.min(client.getVarbitValue(Varbits.TOA_MEMBER_5_HEALTH), 1) +
                Math.min(client.getVarbitValue(Varbits.TOA_MEMBER_6_HEALTH), 1) +
                Math.min(client.getVarbitValue(Varbits.TOA_MEMBER_7_HEALTH), 1));
        if(teamSize==1){
            return "Solo";
        }
        return teamSize.toString();
    }
    private void setTeamSize (String bossName, String message){

        if(bossName.contains("Theatre of Blood")){
            teamSize = tobTeamSize();
        }else if (bossName.contains("Tombs of Amascut")){
            teamSize = toaTeamSize();
        }else if (message.contains("Team size")){
            Pattern teamSizePattern = Pattern.compile("Team size: (\\S+) players.*");
            Matcher teamMatch = teamSizePattern.matcher(message);
            if(teamMatch.find())
                teamSize = teamMatch.group(1);

        }else if(bossName.contains("Royal Titans")){
            int size = client.getPlayers().size();
            if(size == 1){
                teamSize = "Solo";
            }else{
                teamSize = String.valueOf(size);
            }

        } else if(message.contains("ersonal best")){
            teamSize = "Solo";
        }

    }

}


package io.droptracker.util;

import com.google.gson.Gson;
import lombok.experimental.UtilityClass;
import net.runelite.api.Client;
import net.runelite.api.widgets.ComponentID;
import net.runelite.api.widgets.Widget;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.config.RuneLiteConfig;
import net.runelite.client.util.ColorUtil;
import org.apache.commons.lang3.StringUtils;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.annotations.Nullable;

import java.awt.Color;
import java.lang.reflect.ParameterizedType;
import java.lang.reflect.Type;
import java.time.Duration;
import java.time.Instant;
import java.util.Collection;
import java.util.regex.Pattern;
import java.util.stream.Stream;

@UtilityClass
public class ConfigUtilities {

    private final Pattern DELIM = Pattern.compile("[,;\\n]");

    public Stream<String> readDelimited(String value) {
        if (value == null) return Stream.empty();
        return DELIM.splitAsStream(value)
                .map(String::trim)
                .filter(StringUtils::isNotEmpty);
    }

    public boolean isPluginDisabled(ConfigManager configManager, String simpleLowerClassName) {
        return "false".equals(configManager.getConfiguration(RuneLiteConfig.GROUP_NAME, simpleLowerClassName));
    }

    @Nullable
    public Object convertTypeFromJson(@NotNull Gson gson, @NotNull Type type, @NotNull Object in) {
        if (in instanceof Boolean)
            return type == boolean.class || type == Boolean.class ? in : null;

        if (in instanceof Number) {
            Number n = (Number) in;

            if (type == int.class || type == Integer.class)
                return n.intValue();

            if (type == long.class || type == Long.class)
                return n.longValue();

            if (type == float.class || type == Float.class)
                return n.floatValue();

            if (type == double.class || type == Double.class)
                return n.doubleValue();

            if (type == byte.class || type == Byte.class)
                return n.byteValue();

            if (type == short.class || type == Short.class)
                return n.shortValue();

            if (type == Instant.class)
                return Instant.ofEpochMilli(n.longValue());

            if (type == Duration.class)
                return Duration.ofMillis(n.longValue());

            return null;
        }

        if (in instanceof String) {
            String s = (String) in;

            if (type == String.class)
                return s;

            if (type == Color.class)
                return ColorUtil.fromString(s);

            if (type instanceof Class && ((Class<?>) type).isEnum()) {
                try {
                    // noinspection unchecked,rawtypes
                    return Enum.valueOf((Class<? extends Enum>) type, s);
                } catch (Exception e) {
                    return null;
                }
            }

            if (type == Instant.class) {
                try {
                    return Instant.parse(s);
                } catch (Exception e) {
                    return null;
                }
            }

            if (type == Duration.class) {
                try {
                    return Duration.parse(s);
                } catch (Exception e) {
                    return null;
                }
            }
        }

        if (in instanceof Collection && type instanceof ParameterizedType) {
            Type rawType = ((ParameterizedType) type).getRawType();
            if (rawType instanceof Class && Collection.class.isAssignableFrom((Class<?>) rawType)) {
                try {
                    return gson.fromJson(gson.toJson(in), type); // inefficient, but unimportant
                } catch (Exception e) {
                    return null;
                }
            }
        }

        return null;
    }

    public boolean isSettingsOpen(@NotNull Client client) {
        Widget widget = client.getWidget(ComponentID.SETTINGS_INIT);
        return widget != null && !widget.isHidden();
    }

    public boolean isKillCountFilterInvalid(int varbitValue) {
        // spam filter must be disabled for kill count chat message
        return varbitValue > 0;
    }

    public boolean isCollectionLogInvalid(int varbitValue) {
        // collection log notifier requires chat or pop-up notification
        return varbitValue == 0;
    }

    public boolean isRepeatPopupInvalid(int varbitValue) {
        // we discourage repeat notifications for combat task notifier if unintentional
        return varbitValue > 0;
    }

    public boolean isPetLootInvalid(int varbitValue) {
        // LOOT_DROP_NOTIFICATIONS and UNTRADEABLE_LOOT_DROPS must both be set to 1 for reliable pet name parsing
        return varbitValue < 1;
    }
}

package io.droptracker.util;

import com.google.common.collect.ImmutableSet;
import io.droptracker.models.CustomWebhookBody;
import lombok.experimental.UtilityClass;
import net.runelite.api.Client;
import net.runelite.api.InventoryID;
import net.runelite.api.Item;
import net.runelite.api.ItemComposition;
import net.runelite.api.ItemContainer;
import net.runelite.api.ItemID;
import net.runelite.client.game.ItemManager;
import net.runelite.client.game.ItemStack;
import net.runelite.client.game.ItemVariationMapping;
import net.runelite.client.util.QuantityFormatter;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.annotations.Nullable;

import java.util.*;
import java.util.function.BinaryOperator;
import java.util.function.Function;
import java.util.stream.Collectors;
import java.util.stream.Stream;

import static net.runelite.api.ItemID.*;

@UtilityClass
public class ItemUtilities {

    final String ITEM_CACHE_BASE_URL = "https://static.runelite.net/cache/item/";

    public final Collection<Integer> COIN_VARIATIONS = new HashSet<>(ItemVariationMapping.getVariations(ItemID.COINS));

    private final Set<Integer> NEVER_KEPT_ITEMS = ImmutableSet.of(
            CLUE_BOX, LOOTING_BAG, FLAMTAER_BAG, JAR_GENERATOR,
            AMULET_OF_THE_DAMNED, RING_OF_CHAROS, RING_OF_CHAROSA,
            BRACELET_OF_ETHEREUM, BRACELET_OF_ETHEREUM_UNCHARGED,
            AVAS_ACCUMULATOR, AVAS_ATTRACTOR, MAGIC_SECATEURS, MAGIC_BUTTERFLY_NET,
            COOKING_GAUNTLETS, GOLDSMITH_GAUNTLETS, CHAOS_GAUNTLETS, STEEL_GAUNTLETS,
            SILLY_JESTER_HAT, SILLY_JESTER_TOP, SILLY_JESTER_TIGHTS, SILLY_JESTER_BOOTS,
            LUNAR_HELM, LUNAR_TORSO, LUNAR_LEGS, LUNAR_GLOVES, LUNAR_BOOTS,
            LUNAR_CAPE, LUNAR_AMULET, LUNAR_RING, LUNAR_STAFF,
            SHATTERED_RELICS_ADAMANT_TROPHY, SHATTERED_RELICS_BRONZE_TROPHY, SHATTERED_RELICS_DRAGON_TROPHY,
            SHATTERED_RELICS_IRON_TROPHY, SHATTERED_RELICS_MITHRIL_TROPHY, SHATTERED_RELICS_RUNE_TROPHY, SHATTERED_RELICS_STEEL_TROPHY,
            TRAILBLAZER_ADAMANT_TROPHY, TRAILBLAZER_BRONZE_TROPHY, TRAILBLAZER_DRAGON_TROPHY, TRAILBLAZER_IRON_TROPHY,
            TRAILBLAZER_MITHRIL_TROPHY, TRAILBLAZER_RUNE_TROPHY, TRAILBLAZER_STEEL_TROPHY,
            TWISTED_ADAMANT_TROPHY, TWISTED_BRONZE_TROPHY, TWISTED_DRAGON_TROPHY, TWISTED_IRON_TROPHY,
            TWISTED_MITHRIL_TROPHY, TWISTED_RUNE_TROPHY, TWISTED_STEEL_TROPHY
    );

    private final BinaryOperator<Item> SUM_ITEM_QUANTITIES = (a, b) -> new Item(a.getId(), a.getQuantity() + b.getQuantity());
    private final BinaryOperator<ItemStack> SUM_ITEM_STACK_QUANTITIES = (a, b) -> new ItemStack(a.getId(), a.getQuantity() + b.getQuantity());

    public boolean isItemNeverKeptOnDeath(int itemId) {
        return NEVER_KEPT_ITEMS.contains(itemId);
    }


    public Collection<Item> getItems(Client client) {
        return Stream.of(InventoryID.INVENTORY, InventoryID.EQUIPMENT)
                .map(client::getItemContainer)
                .filter(Objects::nonNull)
                .map(ItemContainer::getItems)
                .flatMap(Arrays::stream)
                .filter(Objects::nonNull)
                .filter(item -> item.getId() >= 0) // -1 implies empty slot
                .collect(Collectors.toList());
    }

    public <K, V> Map<K, V> reduce(@NotNull Iterable<V> items, Function<V, K> deriveKey, BinaryOperator<V> aggregate) {
        final Map<K, V> map = new LinkedHashMap<>();
        items.forEach(v -> map.merge(deriveKey.apply(v), v, aggregate));
        return map;
    }

    public Map<Integer, Item> reduceItems(@NotNull Iterable<Item> items) {
        return reduce(items, Item::getId, SUM_ITEM_QUANTITIES);
    }

    @NotNull
    public Collection<ItemStack> reduceItemStack(@NotNull Iterable<ItemStack> items) {
        return reduce(items, ItemStack::getId, SUM_ITEM_STACK_QUANTITIES).values();
    }

    public String getItemImageUrl(int itemId) {
        return ITEM_CACHE_BASE_URL + "icon/" + itemId + ".png";
    }

    public String getNpcImageUrl(int npcId) {
        return String.format("https://chisel.weirdgloop.org/static/img/osrs-npc/%d_128.png", npcId);
    }

    private static Collection<ItemStack> stack(Collection<ItemStack> items) {
        final List<ItemStack> list = new ArrayList<>();

        for (final ItemStack item : items) {
            int quantity = 0;
            for (final ItemStack i : list) {
                if (i.getId() == item.getId()) {
                    quantity = i.getQuantity();
                    list.remove(i);
                    break;
                }
            }
            if (quantity > 0) {
                list.add(new ItemStack(item.getId(), item.getQuantity() + quantity, item.getLocation()));
            } else {
                list.add(item);
            }
        }

        return list;
    }

}

package io.droptracker.util;
/* Author: https://github.com/pajlads/DinkPlugin */

import com.google.common.cache.Cache;
import com.google.common.cache.CacheBuilder;
import com.google.gson.Gson;
import com.google.gson.JsonSyntaxException;
import io.droptracker.DropTrackerConfig;
import io.droptracker.DropTrackerPlugin;
import io.droptracker.models.Drop;
import lombok.Getter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.NPC;
import net.runelite.api.NpcID;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.events.NpcLootReceived;
import net.runelite.client.events.PlayerLootReceived;
import net.runelite.client.game.ItemStack;
import net.runelite.client.plugins.chatcommands.ChatCommandsPlugin;
import net.runelite.client.plugins.loottracker.LootReceived;
import net.runelite.client.plugins.loottracker.LootTrackerConfig;
import net.runelite.client.plugins.loottracker.LootTrackerPlugin;
import net.runelite.http.api.loottracker.LootRecordType;
import org.apache.commons.lang3.StringUtils;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.annotations.Nullable;

import javax.inject.Inject;
import javax.inject.Singleton;
import java.util.Collection;
import java.util.Collections;
import java.util.Map;
import java.util.OptionalDouble;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.TimeUnit;
import java.util.function.Predicate;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

@Slf4j
@Singleton
public class KCService {

    public static final String GAUNTLET_NAME = "Gauntlet", GAUNTLET_BOSS = "Crystalline Hunllef";
    public static final String CG_NAME = "Corrupted Gauntlet", CG_BOSS = "Corrupted Hunllef";
    private static final String TOA = "Tombs of Amascut";
    private static final String TOB = "Theatre of Blood";
    private static final String COX = "Chambers of Xeric";


    private static final String RL_CHAT_CMD_PLUGIN_NAME = ChatCommandsPlugin.class.getSimpleName().toLowerCase();
    private static final String RL_LOOT_PLUGIN_NAME = LootTrackerPlugin.class.getSimpleName().toLowerCase();
    private static final Pattern CLUE_SCROLL_REGEX = Pattern.compile("You have completed (?<scrollCount>\\d+) (?<scrollType>\\w+) Treasure Trails\\.");

    @Inject
    private static ConfigManager configManager;

    private ChatMessageEvent chatMessageEventHandler;

    @Inject
    private static Gson gson;

    @Inject
    private ScheduledExecutorService executor;

    @Inject
    private static Rarity rarityService;

    private static final Cache<String, Integer> killCounts = CacheBuilder.newBuilder()
            .expireAfterAccess(10, TimeUnit.MINUTES)
            .maximumSize(64L)
            .build();

    @Getter
    @Nullable
    protected static Drop lastDrop = null;

    @Inject
    public KCService(ConfigManager configManager, Gson gson,
                     ScheduledExecutorService executor,
                     ChatMessageEvent chatMessageEventHandler,
                     Rarity rarityService) {
        this.configManager = configManager;
        this.gson = gson;
        this.chatMessageEventHandler = chatMessageEventHandler;
        this.rarityService = rarityService;
    }

    public void reset() {
        this.lastDrop = null;
        this.killCounts.invalidateAll();
    }

    public void onNpcKill(NpcLootReceived event) {
        NPC npc = event.getNpc();
        int id = npc.getId();
        if (id == NpcID.THE_WHISPERER || id == NpcID.THE_WHISPERER_12205 || id == NpcID.THE_WHISPERER_12206 || id == NpcID.THE_WHISPERER_12207) {
            // Upstream does not fire NpcLootReceived for the whisperer, since they do not hold a reference to the NPC.
            // So, we use LootReceived instead (and return here just in case they change their implementation).
            return;
        }

        String name = npc.getName();
        if (GAUNTLET_BOSS.equals(name) || CG_BOSS.equals(name)) {
            // already handled by onGameMessage
            return;
        }
        if (name != null) {
            this.incrementKills(LootRecordType.NPC, name, event.getItems());
        }
    }

    public void onPlayerKill(PlayerLootReceived event) {
        String name = event.getPlayer().getName();
        if (name != null) {
            this.incrementKills(LootRecordType.PLAYER, name, event.getItems());
        }
    }

    public void onLoot(LootReceived event) {
        boolean increment;
        switch (event.getType()) {
            case NPC:
                // Special case: upstream fires LootReceived for the whisperer, but not NpcLootReceived
                increment = "The Whisperer".equalsIgnoreCase(event.getName());
                break;
            case PLAYER:
                increment = false; // handled by PlayerLootReceived
                break;
            default:
                increment = true;
                break;
        }

        if (increment) {
            this.incrementKills(event.getType(), getStandardizedSource(event), event.getItems());
        }
    }

    public void onGameMessage(String message) {
        // update cached clue casket count
        Map.Entry<String, Integer> clue = parseClue(message);
        if (clue != null) {
            String tier = ucFirst(clue.getKey());
            int count = clue.getValue() - 1; // decremented since onLoot will increment
            killCounts.put("Clue Scroll (" + tier + ")", count);
            return;
        }

        chatMessageEventHandler.parseBoss(message).ifPresent(pair -> {
            String boss = pair.getKey();
            Integer kc = pair.getValue();

            // Update cache. We store kc - 1 since onNpcLootReceived will increment; kc - 1 + 1 == kc
            String cacheKey = getCacheKey(LootRecordType.UNKNOWN, boss);
            killCounts.asMap().merge(cacheKey, kc - 1, Math::max);

            if (boss.equals(GAUNTLET_BOSS) || boss.equals(CG_BOSS) || boss.startsWith(TOA) || boss.startsWith(TOB) || boss.startsWith(COX)) {
                // populate lastDrop to workaround loot tracker quirks
                this.lastDrop = new Drop(boss, LootRecordType.EVENT, Collections.emptyList());

                if (!ConfigUtilities.isPluginDisabled(configManager, RL_LOOT_PLUGIN_NAME)) {
                    // onLoot will already increment kc, no need to schedule task below.
                    // this early return also simplifies our test code
                    return;
                }
            }

            // However: we don't know if boss message appeared before/after the loot event.
            // If after, we should store kc. If before, we should store kc - 1.
            // Given this uncertainty, we wait so that the loot event has passed, and then we can store latest kc.
            executor.schedule(() -> {
                killCounts.asMap().merge(cacheKey, kc, Math::max);
            }, 15, TimeUnit.SECONDS);
        });
    }

    public String getStandardizedSource(LootReceived event) {
        if (isCorruptedGauntlet(event)) {
            return KCService.CG_NAME;
        } else if (lastDrop != null && shouldUseChatName(event)) {
            return lastDrop.getSource(); // distinguish entry/expert/challenge modes
        }
        return event.getName();
    }

    private boolean shouldUseChatName(LootReceived event) {
        assert lastDrop != null;
        String lastSource = lastDrop.getSource();
        Predicate<String> coincides = source -> source.equals(event.getName()) && lastSource.startsWith(source);
        return coincides.test(TOA) || coincides.test(TOB) || coincides.test(COX);
    }

    /**
     * @param event a loot received event that was just fired
     * @return whether the event represents corrupted gauntlet
     * @apiNote Useful to distinguish normal vs. corrupted gauntlet since the base loot tracker plugin does not,
     * which was <a href="https://github.com/pajlads/DinkPlugin/issues/469">reported</a> to our issue tracker.
     */
    private boolean isCorruptedGauntlet(LootReceived event) {
        return event.getType() == LootRecordType.EVENT && lastDrop != null && "The Gauntlet".equals(event.getName())
                && (CG_NAME.equals(lastDrop.getSource()) || CG_BOSS.equals(lastDrop.getSource()));
    }

    @Nullable
    public static Integer getKillCount(LootRecordType type, String sourceName) {
        if (sourceName == null) return null;
        Integer stored = getStoredKillCount(type, sourceName);
        if (stored != null) {
            return killCounts.asMap().merge(getCacheKey(type, sourceName), stored, Math::max);
        }
        return killCounts.getIfPresent(getCacheKey(type, sourceName));
    }

    private void incrementKills(@NotNull LootRecordType type, @NotNull String sourceName, @NotNull Collection<ItemStack> items) {
        String cacheKey = getCacheKey(type, sourceName);
        killCounts.asMap().compute(cacheKey, (key, cachedKc) -> {
            if (cachedKc != null) {
                // increment kill count
                return cachedKc + 1;
            } else {
                // pull kc from loot tracker or chat commands plugin
                Integer kc = getStoredKillCount(type, sourceName);
                // increment if found
                return kc != null ? kc + 1 : null;
            }
        });
        this.lastDrop = new Drop(sourceName, type, items);
    }

    /**
     * @param type       {@link LootReceived#getType()}
     * @param sourceName {@link NPC#getName()} or {@link LootReceived#getName()}
     * @return the kill count stored by base runelite plugins
     */
    @Nullable
    private static Integer getStoredKillCount(@NotNull LootRecordType type, @NotNull String sourceName) {
        // get kc from base runelite chat commands plugin (if enabled)
        if (!ConfigUtilities.isPluginDisabled(configManager, RL_CHAT_CMD_PLUGIN_NAME)) {
            Integer kc = configManager.getRSProfileConfiguration("killcount", cleanBossName(sourceName), int.class);
            if (kc != null) {
                return kc - 1; // decremented since chat event typically occurs before loot event
            }
        }

        if (ConfigUtilities.isPluginDisabled(configManager, RL_LOOT_PLUGIN_NAME)) {
            // assume stored kc is useless if loot tracker plugin is disabled
            return null;
        }
        String json = configManager.getConfiguration(LootTrackerConfig.GROUP,
                configManager.getRSProfileKey(),
                "drops_" + type + "_" + sourceName
        );
        if (json == null) {
            // no kc stored implies first kill
            return 0;
        }
        try {
            int kc = gson.fromJson(json, SerializedDrop.class).getKills();

            // loot tracker doesn't count kill if no loot - https://github.com/runelite/runelite/issues/5077
            OptionalDouble nothingProbability = rarityService.getRarity(sourceName, -1, 0);
            if (nothingProbability.isPresent() && nothingProbability.getAsDouble() < 1.0) {
                // estimate the actual kc (including kills with no loot)
                kc = (int) Math.round(kc / (1 - nothingProbability.getAsDouble()));
            }

            return kc;
        } catch (JsonSyntaxException e) {
            // should not occur unless loot tracker changes stored loot POJO structure
            log.warn("Failed to read kills from loot tracker config", e);
            return null;
        }
    }

    /**
     * @param boss {@link LootReceived#getName()}
     * @return lowercase boss name that {@link ChatCommandsPlugin} uses during serialization
     */
    private static String cleanBossName(String boss) {
        if ("The Gauntlet".equalsIgnoreCase(boss)) return "gauntlet";
        if ("The Leviathan".equalsIgnoreCase(boss)) return "leviathan";
        if ("The Whisperer".equalsIgnoreCase(boss)) return "whisperer";
        if (boss.startsWith("Barrows")) return "barrows chests";
        if (boss.endsWith("Hallowed Sepulchre)")) return "hallowed sepulchre";
        if (boss.endsWith("Tempoross)")) return "tempoross";
        if (boss.endsWith("Wintertodt)")) return "wintertodt";
        return StringUtils.remove(boss.toLowerCase(), ':');
    }

    private static String getCacheKey(@NotNull LootRecordType type, @NotNull String sourceName) {
        switch (type) {
            case PICKPOCKET:
                return "pickpocket_" + sourceName;
            case PLAYER:
                return "player_" + sourceName;
            default:
                if ("The Gauntlet".equals(sourceName)) return GAUNTLET_BOSS;
                if (CG_NAME.equals(sourceName)) return CG_BOSS;
                return sourceName;
        }
    }
    @Nullable
    public static Map.Entry<String, Integer> parseClue(String gameMessage) {
        Matcher clueMatcher = CLUE_SCROLL_REGEX.matcher(gameMessage);
        if (!clueMatcher.find()) return null;
        String tier = clueMatcher.group("scrollType");
        String count = clueMatcher.group("scrollCount");
        return Map.entry(tier, Integer.parseInt(count));
    }

    public String ucFirst(@NotNull String text) {
        if (text.length() < 2) return text.toUpperCase();
        return Character.toUpperCase(text.charAt(0)) + text.substring(1).toLowerCase();
    }
}

/*
 * Copyright (c) 2017. l2-
 * Copyright (c) 2017, Adam <Adam@sigterm.info>
 * All rights reserved.
 *
 * Borrowed from ChatCommandsPlugin and modified for use within the
 * DropTracker by @joelhalen <andy@joelhalen.net>
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package io.droptracker.util;

import com.google.common.annotations.VisibleForTesting;
import com.google.gson.Gson;
import com.google.gson.JsonSyntaxException;
import com.google.gson.reflect.TypeToken;
import com.google.inject.Inject;
import io.droptracker.DropTrackerConfig;
import io.droptracker.DropTrackerPlugin;
import io.droptracker.models.CustomWebhookBody;
import io.droptracker.models.Pet;
import net.runelite.api.Client;
import net.runelite.api.EnumComposition;
import net.runelite.api.EnumID;
import net.runelite.api.IndexedSprite;
import net.runelite.api.events.*;
import net.runelite.api.widgets.ComponentID;
import net.runelite.api.widgets.InterfaceID;
import net.runelite.api.widgets.Widget;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.game.ItemManager;
import net.runelite.client.util.ImageUtil;
import net.runelite.client.util.AsyncBufferedImage;
import net.runelite.client.util.Text;
import org.apache.commons.text.WordUtils;

import java.awt.image.BufferedImage;
import java.util.*;
import java.util.concurrent.ScheduledExecutorService;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.stream.Collectors;

public class WidgetEvent {

    @Inject
    private final DropTrackerPlugin plugin;
    private final DropTrackerConfig config;

    @Inject
    protected Client client;

    @Inject
    private ConfigManager configManager;

    @Inject
    private ClientThread clientThread;

    @Inject
    private ItemManager itemManager;

    @Inject
    private Gson gson;

    private int petsIconIdx = -1;
    private int[] pets;

    @Inject
    private ScheduledExecutorService executor;

    private boolean advLogLoaded = false;
    private boolean bossLogLoaded = false;
    private boolean scrollInterfaceLoaded = false;
    private String pohOwner;

    private static final String TEAM_SIZES = "(?<teamsize>\\d+(?:\\+|-\\d+)? players?|Solo)";

    private static final Pattern ADVENTURE_LOG_TITLE_PATTERN = Pattern.compile("The Exploits of (.+)");
    private static final Pattern ADVENTURE_LOG_PB_PATTERN = Pattern.compile("Fastest (?:kill|run|Room time)(?: - \\(Team size: \\(?" + TEAM_SIZES + "\\)\\)?)?: (?<time>[0-9:]+(?:\\.[0-9]+)?)");

    static final int ADV_LOG_EXPLOITS_TEXT_INDEX = 1;

    private static class BossPB {
        private final String bossName;
        private final String teamSize;
        private final double time;
    
        public BossPB(String bossName, String teamSize, double time) {
            this.bossName = bossName;
            this.teamSize = teamSize;
            this.time = time;
        }
    
        public String getBossName() {
            return bossName;
        }
    
        public String getTeamSize() {
            return teamSize;
        }
    
        public double getTime() {
            return time;
        }
    }

    @Inject
    public WidgetEvent(DropTrackerPlugin plugin, DropTrackerConfig config,
                            ScheduledExecutorService executor) {
        this.plugin = plugin;
        this.config = config;
        this.executor = executor;
    }

    public void onWidgetLoaded(WidgetLoaded widget)
    {
        switch (widget.getGroupId())
        {
            case InterfaceID.ADVENTURE_LOG:
                advLogLoaded = true;
                break;
            case InterfaceID.KILL_LOG:
                bossLogLoaded = true;
                break;
            case InterfaceID.ACHIEVEMENT_DIARY_SCROLL:
                scrollInterfaceLoaded = true;
                break;
        }
    }

    @Subscribe
    public void onGameTick(GameTick event)
    {
        if (client.getLocalPlayer() == null)
        {
            return;
        }

        if (advLogLoaded)
        {
            advLogLoaded = false;

            Widget adventureLog = client.getWidget(ComponentID.ADVENTURE_LOG_CONTAINER);

            if (adventureLog != null)
            {
                Matcher advLogExploitsText = ADVENTURE_LOG_TITLE_PATTERN.matcher(adventureLog.getChild(ADV_LOG_EXPLOITS_TEXT_INDEX).getText());
                if (advLogExploitsText.find())
                {
                    pohOwner = advLogExploitsText.group(1);
                }
            }
        }

        if (bossLogLoaded && (pohOwner == null || pohOwner.equals(client.getLocalPlayer().getName())))
        {
            bossLogLoaded = false;

            Widget title = client.getWidget(ComponentID.KILL_LOG_TITLE);
            Widget bossMonster = client.getWidget(ComponentID.KILL_LOG_MONSTER);
            Widget bossKills = client.getWidget(ComponentID.KILL_LOG_KILLS);

            if (title == null || bossMonster == null || bossKills == null
                || !"Boss Kill Log".equals(title.getText()))
            {
                return;
            }

            Widget[] bossChildren = bossMonster.getChildren();
            Widget[] killsChildren = bossKills.getChildren();

            for (int i = 0; i < bossChildren.length; ++i)
            {
                Widget boss = bossChildren[i];
                Widget kill = killsChildren[i];

                String bossName = boss.getText().replace(":", "");
                int kc = Integer.parseInt(kill.getText().replace(",", ""));
            }
        }

        // Adventure log - Counters
        if (scrollInterfaceLoaded)
        {
            scrollInterfaceLoaded = false;
            
            collectAndSendAdventureLogPBs();
        }
    }



    @VisibleForTesting
    static String secondsToTimeString(double seconds)
    {
        int hours = (int) (Math.floor(seconds) / 3600);
        int minutes = (int) (Math.floor(seconds / 60) % 60);
        seconds = seconds % 60;

        String timeString = hours > 0 ? String.format("%d:%02d:", hours, minutes) : String.format("%d:", minutes);

        // If the seconds is an integer, it is ambiguous if the pb is a precise
        // pb or not. So we always show it without the trailing .00.
        return timeString + (Math.floor(seconds) == seconds ? String.format("%02d", (int) seconds) : String.format("%05.2f", seconds));
    }

    // Method to collect all PBs from the adventure log
    private void collectAndSendAdventureLogPBs() {
        if (client.getLocalPlayer() == null || client.getLocalPlayer().getName() == null || pohOwner == null) {
            return;
        }
        // Only process if we're in our own POH
        if (!client.getLocalPlayer().getName().equals(pohOwner)) {
            return;
        }
        
        List<BossPB> personalBests = new ArrayList<>();
        
        Widget parent = client.getWidget(ComponentID.ACHIEVEMENT_DIARY_SCROLL_TEXT);
        if (parent == null) {
            return;
        }
        
        // Each line is a separate static child
        Widget[] children = parent.getStaticChildren();
        String[] text = Arrays.stream(children)
            .map(Widget::getText)
            .map(Text::removeTags)
            .toArray(String[]::new);
    
        for (int i = 0; i < text.length; ++i) {
            String boss = longBossName(text[i]);
    
            for (i = i + 1; i < text.length; ++i) {
                String line = text[i];
                if (line.isEmpty()) {
                    break;
                }
    
                Matcher matcher = ADVENTURE_LOG_PB_PATTERN.matcher(line);
                if (matcher.find()) {
                    final double seconds = timeStringToSeconds(matcher.group("time"));
                    String teamSize = matcher.group("teamsize");
                    if (teamSize != null) {
                        // 3 player -> 3 players
                        // 1 player -> Solo
                        // Solo -> Solo
                        // 2 players -> 2 players
                        if (teamSize.equals("1 player")) {
                            teamSize = "Solo";
                        } else if (teamSize.endsWith("player")) {
                            teamSize = teamSize.replace("player", "").strip();
                        } else if (teamSize.endsWith("players")) {
                            teamSize = teamSize.replace("players", "").strip();
                        }

                        personalBests.add(new BossPB(boss, teamSize, seconds));
                    } else {
                        personalBests.add(new BossPB(boss, "Solo", seconds));
                    }
                }
            }
        }
        
        if (!personalBests.isEmpty()) {
            sendPersonalBestsWebhook(pohOwner, personalBests);
        }
    }
    private void sendPersonalBestsWebhook(String playerName, List<BossPB> personalBests) {
        if (personalBests.isEmpty()) {
            return;
        }
    
        CustomWebhookBody customWebhookBody = new CustomWebhookBody();
        customWebhookBody.setContent(playerName + "'s Personal Best Times:");
    
        // Create a main embed for the PBs
        CustomWebhookBody.Embed pbEmbed = new CustomWebhookBody.Embed();
        pbEmbed.title = playerName + "'s Personal Best Times";
        
        // Add player info fields
        String accountHash = String.valueOf(client.getAccountHash());
        pbEmbed.addField("type", "adventure_log", true);
        pbEmbed.addField("player", playerName, true);
        pbEmbed.addField("acc_hash", accountHash, true);
        
        // Group PBs into batches (5 PBs per field)
        int pbsPerField = 5;
        int fieldCount = (int) Math.ceil(personalBests.size() / (double) pbsPerField);

        List<Integer> playerPets = getPetList();
        
        for (int i = 0; i < fieldCount; i++) {
            StringBuilder fieldContent = new StringBuilder();
            int startIdx = i * pbsPerField;
            int endIdx = Math.min(startIdx + pbsPerField, personalBests.size());
            
            for (int j = startIdx; j < endIdx; j++) {
                BossPB pb = personalBests.get(j);
                String formattedTime = formatTime(pb.getTime());
                
                // Format each PB as with "`boss name` - `team_size` : `time`" for easy parsing
                fieldContent.append("`" + pb.getBossName() + "`")
                           .append(" - ")
                           .append("`" + pb.getTeamSize() + "`")
                           .append(" : ")
                           .append("`" + formattedTime + "`");
                
                // Add a newline between entries (except the last one)
                if (j < endIdx - 1) {
                    fieldContent.append("\n");
                }
            }
            
            // Add the field with a batch number
            pbEmbed.addField("" + (i + 1), fieldContent.toString(), false);
        }
        pbEmbed.addField("Pets", playerPets.toString(), false);
        
        customWebhookBody.getEmbeds().add(pbEmbed);
        
        // Use the main plugin class' sendWebhook method
        plugin.sendDataToDropTracker(customWebhookBody, 0);
    }

    private double getPb(String boss)
    {
        Double personalBest = configManager.getRSProfileConfiguration("personalbest", boss.toLowerCase(), double.class);
        return personalBest == null ? 0 : personalBest;
    }


    private int getKc(String boss)
    {
        Integer killCount = configManager.getRSProfileConfiguration("killcount", boss.toLowerCase(), int.class);
        return killCount == null ? 0 : killCount;
    }

    /**
     * Formats a time in seconds to a string in the format mm:ss or h:mm:ss
     */
    private String formatTime(double seconds)
    {
        int hours = (int) (seconds / 3600);
        int minutes = (int) ((seconds % 3600) / 60);
        double secs = seconds % 60;

        if (hours > 0)
        {
            return String.format("%d:%02d:%05.2f", hours, minutes, secs);
        }
        else
        {
            return String.format("%d:%05.2f", minutes, secs);
        }
    }

    private static String longBossName(String boss)
    {
        String lowerBoss = boss.toLowerCase();
        if (lowerBoss.endsWith(" (echo)"))
        {
            String actualBoss = lowerBoss.substring(0, lowerBoss.length() - " (echo)".length());
            return longBossName(actualBoss) + " (Echo)";
        }

        switch (lowerBoss)
        {
            case "corp":
                return "Corporeal Beast";

            case "jad":
            case "tzhaar fight cave":
                return "TzTok-Jad";

            case "kq":
                return "Kalphite Queen";

            case "chaos ele":
                return "Chaos Elemental";

            case "dusk":
            case "dawn":
            case "gargs":
            case "ggs":
            case "gg":
                return "Grotesque Guardians";

            case "crazy arch":
                return "Crazy Archaeologist";

            case "deranged arch":
                return "Deranged Archaeologist";

            case "mole":
                return "Giant Mole";

            case "vetion":
                return "Vet'ion";

            case "calvarion":
            case "calv":
                return "Calvar'ion";

            case "vene":
                return "Venenatis";

            case "kbd":
                return "King Black Dragon";

            case "vork":
                return "Vorkath";

            case "sire":
                return "Abyssal Sire";

            case "smoke devil":
            case "thermy":
                return "Thermonuclear Smoke Devil";

            case "cerb":
                return "Cerberus";

            case "zuk":
            case "inferno":
                return "TzKal-Zuk";

            case "hydra":
                return "Alchemical Hydra";

            // gwd
            case "sara":
            case "saradomin":
            case "zilyana":
            case "zily":
                return "Commander Zilyana";
            case "zammy":
            case "zamorak":
            case "kril":
            case "kril tsutsaroth":
                return "K'ril Tsutsaroth";
            case "arma":
            case "kree":
            case "kreearra":
            case "armadyl":
                return "Kree'arra";
            case "bando":
            case "bandos":
            case "graardor":
                return "General Graardor";

            // dks
            case "supreme":
                return "Dagannoth Supreme";
            case "rex":
                return "Dagannoth Rex";
            case "prime":
                return "Dagannoth Prime";

            case "wt":
                return "Wintertodt";
            case "barrows":
                return "Barrows Chests";
            case "herbi":
                return "Herbiboar";

            // Chambers of Xeric
            case "cox":
            case "xeric":
            case "chambers":
            case "olm":
            case "raids":
                return "Chambers of Xeric";
            case "cox 1":
            case "cox solo":
                return "Chambers of Xeric Solo";
            case "cox 2":
            case "cox duo":
                return "Chambers of Xeric 2 players";
            case "cox 3":
                return "Chambers of Xeric 3 players";
            case "cox 4":
                return "Chambers of Xeric 4 players";
            case "cox 5":
                return "Chambers of Xeric 5 players";
            case "cox 6":
                return "Chambers of Xeric 6 players";
            case "cox 7":
                return "Chambers of Xeric 7 players";
            case "cox 8":
                return "Chambers of Xeric 8 players";
            case "cox 9":
                return "Chambers of Xeric 9 players";
            case "cox 10":
                return "Chambers of Xeric 10 players";
            case "cox 11-15":
            case "cox 11":
            case "cox 12":
            case "cox 13":
            case "cox 14":
            case "cox 15":
                return "Chambers of Xeric 11-15 players";
            case "cox 16-23":
            case "cox 16":
            case "cox 17":
            case "cox 18":
            case "cox 19":
            case "cox 20":
            case "cox 21":
            case "cox 22":
            case "cox 23":
                return "Chambers of Xeric 16-23 players";
            case "cox 24":
            case "cox 24+":
                return "Chambers of Xeric 24+ players";

            // Chambers of Xeric Challenge Mode
            case "chambers of xeric: challenge mode":
            case "cox cm":
            case "xeric cm":
            case "chambers cm":
            case "olm cm":
            case "raids cm":
            case "chambers of xeric - challenge mode":
                return "Chambers of Xeric Challenge Mode";
            case "cox cm 1":
            case "cox cm solo":
                return "Chambers of Xeric Challenge Mode Solo";
            case "cox cm 2":
            case "cox cm duo":
                return "Chambers of Xeric Challenge Mode 2 players";
            case "cox cm 3":
                return "Chambers of Xeric Challenge Mode 3 players";
            case "cox cm 4":
                return "Chambers of Xeric Challenge Mode 4 players";
            case "cox cm 5":
                return "Chambers of Xeric Challenge Mode 5 players";
            case "cox cm 6":
                return "Chambers of Xeric Challenge Mode 6 players";
            case "cox cm 7":
                return "Chambers of Xeric Challenge Mode 7 players";
            case "cox cm 8":
                return "Chambers of Xeric Challenge Mode 8 players";
            case "cox cm 9":
                return "Chambers of Xeric Challenge Mode 9 players";
            case "cox cm 10":
                return "Chambers of Xeric Challenge Mode 10 players";
            case "cox cm 11-15":
            case "cox cm 11":
            case "cox cm 12":
            case "cox cm 13":
            case "cox cm 14":
            case "cox cm 15":
                return "Chambers of Xeric Challenge Mode 11-15 players";
            case "cox cm 16-23":
            case "cox cm 16":
            case "cox cm 17":
            case "cox cm 18":
            case "cox cm 19":
            case "cox cm 20":
            case "cox cm 21":
            case "cox cm 22":
            case "cox cm 23":
                return "Chambers of Xeric Challenge Mode 16-23 players";
            case "cox cm 24":
            case "cox cm 24+":
                return "Chambers of Xeric Challenge Mode 24+ players";

            // Theatre of Blood
            case "tob":
            case "theatre":
            case "verzik":
            case "verzik vitur":
            case "raids 2":
                return "Theatre of Blood";
            case "tob 1":
            case "tob solo":
                return "Theatre of Blood Solo";
            case "tob 2":
            case "tob duo":
                return "Theatre of Blood 2 players";
            case "tob 3":
                return "Theatre of Blood 3 players";
            case "tob 4":
                return "Theatre of Blood 4 players";
            case "tob 5":
                return "Theatre of Blood 5 players";

            // Theatre of Blood Entry Mode
            case "theatre of blood: story mode":
            case "tob sm":
            case "tob story mode":
            case "tob story":
            case "theatre of blood: entry mode":
            case "tob em":
            case "tob entry mode":
            case "tob entry":
                return "Theatre of Blood Entry Mode";

            // Theatre of Blood Hard Mode
            case "theatre of blood: hard mode":
            case "tob cm":
            case "tob hm":
            case "tob hard mode":
            case "tob hard":
            case "hmt":
                return "Theatre of Blood Hard Mode";
            case "hmt 1":
            case "hmt solo":
                return "Theatre of Blood Hard Mode Solo";
            case "hmt 2":
            case "hmt duo":
                return "Theatre of Blood Hard Mode 2 players";
            case "hmt 3":
                return "Theatre of Blood Hard Mode 3 players";
            case "hmt 4":
                return "Theatre of Blood Hard Mode 4 players";
            case "hmt 5":
                return "Theatre of Blood Hard Mode 5 players";

            // Tombs of Amascut
            case "toa":
            case "tombs":
            case "amascut":
            case "warden":
            case "wardens":
            case "raids 3":
                return "Tombs of Amascut";
            case "toa 1":
            case "toa solo":
                return "Tombs of Amascut Solo";
            case "toa 2":
            case "toa duo":
                return "Tombs of Amascut 2 players";
            case "toa 3":
                return "Tombs of Amascut 3 players";
            case "toa 4":
                return "Tombs of Amascut 4 players";
            case "toa 5":
                return "Tombs of Amascut 5 players";
            case "toa 6":
                return "Tombs of Amascut 6 players";
            case "toa 7":
                return "Tombs of Amascut 7 players";
            case "toa 8":
                return "Tombs of Amascut 8 players";
            case "toa entry":
            case "tombs of amascut - entry":
            case "toa entry mode":
                return "Tombs of Amascut Entry Mode";
            case "toa entry 1":
            case "toa entry solo":
                return "Tombs of Amascut Entry Mode Solo";
            case "toa entry 2":
            case "toa entry duo":
                return "Tombs of Amascut Entry Mode 2 players";
            case "toa entry 3":
                return "Tombs of Amascut Entry Mode 3 players";
            case "toa entry 4":
                return "Tombs of Amascut Entry Mode 4 players";
            case "toa entry 5":
                return "Tombs of Amascut Entry Mode 5 players";
            case "toa entry 6":
                return "Tombs of Amascut Entry Mode 6 players";
            case "toa entry 7":
                return "Tombs of Amascut Entry Mode 7 players";
            case "toa entry 8":
                return "Tombs of Amascut Entry Mode 8 players";
            case "tombs of amascut: expert mode":
            case "toa expert":
            case "tombs of amascut - expert":
            case "toa expert mode":
                return "Tombs of Amascut Expert Mode";
            case "toa expert 1":
            case "toa expert solo":
                return "Tombs of Amascut Expert Mode Solo";
            case "toa expert 2":
            case "toa expert duo":
                return "Tombs of Amascut Expert Mode 2 players";
            case "toa expert 3":
                return "Tombs of Amascut Expert Mode 3 players";
            case "toa expert 4":
                return "Tombs of Amascut Expert Mode 4 players";
            case "toa expert 5":
                return "Tombs of Amascut Expert Mode 5 players";
            case "toa expert 6":
                return "Tombs of Amascut Expert Mode 6 players";
            case "toa expert 7":
                return "Tombs of Amascut Expert Mode 7 players";
            case "toa expert 8":
                return "Tombs of Amascut Expert Mode 8 players";

            // The Gauntlet
            case "gaunt":
            case "gauntlet":
            case "the gauntlet":
                return "Gauntlet";

            // Corrupted Gauntlet
            case "cgaunt":
            case "cgauntlet":
            case "the corrupted gauntlet":
            case "cg":
                return "Corrupted Gauntlet";

            // The Nightmare
            case "nm":
            case "tnm":
            case "nmare":
            case "the nightmare":
                return "Nightmare";

            // Phosani's Nightmare
            case "pnm":
            case "phosani":
            case "phosanis":
            case "phosani nm":
            case "phosani nightmare":
            case "phosanis nightmare":
                return "Phosani's Nightmare";

            // Hallowed Sepulchre
            case "hs":
            case "sepulchre":
            case "ghc":
                return "Hallowed Sepulchre";
            case "hs1":
            case "hs 1":
                return "Hallowed Sepulchre Floor 1";
            case "hs2":
            case "hs 2":
                return "Hallowed Sepulchre Floor 2";
            case "hs3":
            case "hs 3":
                return "Hallowed Sepulchre Floor 3";
            case "hs4":
            case "hs 4":
                return "Hallowed Sepulchre Floor 4";
            case "hs5":
            case "hs 5":
                return "Hallowed Sepulchre Floor 5";

            // Colossal Wyrm Basic Agility Course
            case "wbac":
            case "cwbac":
            case "wyrmb":
            case "wyrmbasic":
            case "wyrm basic":
            case "colossal basic":
            case "colossal wyrm basic":
                return "Colossal Wyrm Agility Course (Basic)";

            // Colossal Wyrm Advanced Agility Course
            case "waac":
            case "cwaac":
            case "wyrma":
            case "wyrmadvanced":
            case "wyrm advanced":
            case "colossal advanced":
            case "colossal wyrm advanced":
                return "Colossal Wyrm Agility Course (Advanced)";

            // Prifddinas Agility Course
            case "prif":
            case "prifddinas":
                return "Prifddinas Agility Course";

            // Shayzien Basic Agility Course
            case "shayb":
            case "sbac":
            case "shayzienbasic":
            case "shayzien basic":
                return "Shayzien Basic Agility Course";

            // Shayzien Advanced Agility Course
            case "shaya":
            case "saac":
            case "shayadv":
            case "shayadvanced":
            case "shayzien advanced":
                return "Shayzien Advanced Agility Course";

            // Ape Atoll Agility
            case "aa":
            case "ape atoll":
                return "Ape Atoll Agility";

            // Draynor Village Rooftop Course
            case "draynor":
            case "draynor agility":
                return "Draynor Village Rooftop";

            // Al-Kharid Rooftop Course
            case "al kharid":
            case "al kharid agility":
            case "al-kharid":
            case "al-kharid agility":
            case "alkharid":
            case "alkharid agility":
                return "Al Kharid Rooftop";

            // Varrock Rooftop Course
            case "varrock":
            case "varrock agility":
                return "Varrock Rooftop";

            // Canifis Rooftop Course
            case "canifis":
            case "canifis agility":
                return "Canifis Rooftop";

            // Falador Rooftop Course
            case "fally":
            case "fally agility":
            case "falador":
            case "falador agility":
                return "Falador Rooftop";

            // Seers' Village Rooftop Course
            case "seers":
            case "seers agility":
            case "seers village":
            case "seers village agility":
            case "seers'":
            case "seers' agility":
            case "seers' village":
            case "seers' village agility":
            case "seer's":
            case "seer's agility":
            case "seer's village":
            case "seer's village agility":
                return "Seers' Village Rooftop";

            // Pollnivneach Rooftop Course
            case "pollnivneach":
            case "pollnivneach agility":
                return "Pollnivneach Rooftop";

            // Rellekka Rooftop Course
            case "rellekka":
            case "rellekka agility":
                return "Rellekka Rooftop";

            // Ardougne Rooftop Course
            case "ardy":
            case "ardy agility":
            case "ardy rooftop":
            case "ardougne":
            case "ardougne agility":
                return "Ardougne Rooftop";

            // Agility Pyramid
            case "ap":
            case "pyramid":
                return "Agility Pyramid";

            // Barbarian Outpost
            case "barb":
            case "barb outpost":
                return "Barbarian Outpost";

            // Brimhaven Agility Arena
            case "brimhaven":
            case "brimhaven agility":
                return "Agility Arena";

            // Dorgesh-Kaan Agility Course
            case "dorg":
            case "dorgesh kaan":
            case "dorgesh-kaan":
                return "Dorgesh-Kaan Agility";

            // Gnome Stronghold Agility Course
            case "gnome stronghold":
                return "Gnome Stronghold Agility";

            // Penguin Agility
            case "penguin":
                return "Penguin Agility";

            // Werewolf Agility
            case "werewolf":
                return "Werewolf Agility";

            // Skullball
            case "skullball":
                return "Werewolf Skullball";

            // Wilderness Agility Course
            case "wildy":
            case "wildy agility":
                return "Wilderness Agility";

            // Jad challenge
            case "jad 1":
                return "TzHaar-Ket-Rak's First Challenge";
            case "jad 2":
                return "TzHaar-Ket-Rak's Second Challenge";
            case "jad 3":
                return "TzHaar-Ket-Rak's Third Challenge";
            case "jad 4":
                return "TzHaar-Ket-Rak's Fourth Challenge";
            case "jad 5":
                return "TzHaar-Ket-Rak's Fifth Challenge";
            case "jad 6":
                return "TzHaar-Ket-Rak's Sixth Challenge";

            // Guardians of the Rift
            case "gotr":
            case "runetodt":
            case "rifts closed":
                return "Guardians of the Rift";

            // Tempoross
            case "fishingtodt":
            case "fishtodt":
                return "Tempoross";

            // Phantom Muspah
            case "phantom":
            case "muspah":
            case "pm":
                return "Phantom Muspah";

            // Desert Treasure 2 bosses
            case "the leviathan":
            case "levi":
                return "Leviathan";
            case "duke":
                return "Duke Sucellus";
            case "the whisperer":
            case "whisp":
            case "wisp":
                return "Whisperer";
            case "vard":
                return "Vardorvis";

            // dt2 awakened variants
            case "leviathan awakened":
            case "the leviathan awakened":
            case "levi awakened":
                return "Leviathan (awakened)";
            case "duke sucellus awakened":
            case "duke awakened":
                return "Duke Sucellus (awakened)";
            case "whisperer awakened":
            case "the whisperer awakened":
            case "whisp awakened":
            case "wisp awakened":
                return "Whisperer (awakened)";
            case "vardorvis awakened":
            case "vard awakened":
                return "Vardorvis (awakened)";

            // lunar chest variants
            case "lunar chests":
            case "perilous moons":
            case "perilous moon":
            case "moons of peril":
                return "Lunar Chest";

            // hunter rumour variants
            case "hunterrumour":
            case "hunter contract":
            case "hunter contracts":
            case "hunter tasks":
            case "hunter task":
            case "rumours":
            case "rumour":
                return "Hunter Rumours";

            // sol heredit
            case "sol":
            case "colo":
            case "colosseum":
            case "fortis colosseum":
                return "Sol Heredit";

            case "bird egg":
            case "bird eggs":
            case "bird's egg":
            case "bird's eggs":
                return "Bird's egg offerings";

            case "amox":
                return "Amoxliatl";

            case "the hueycoatl":
            case "huey":
                return "Hueycoatl";

            case "crystal chest":
                return "crystal chest";

            case "larran small chest":
            case "larran's small chest":
                return "Larran's small chest";

            case "larran chest":
            case "larran's chest":
            case "larran big chest":
            case "larran's big chest":
                return "Larran's big chest";

            case "brimstone chest":
                return "Brimstone chest";

            default:
                return WordUtils.capitalize(boss);
        }
    }

    private void loadPets()
    {
        assert petsIconIdx == -1;

        // !pets requires off thread pets access, so we just store a copy
        EnumComposition petsEnum = client.getEnum(EnumID.PETS);
        pets = new int[petsEnum.size()];
        for (int i = 0; i < petsEnum.size(); ++i)
        {
            pets[i] = petsEnum.getIntValue(i);
        }

        final IndexedSprite[] modIcons = client.getModIcons();
        assert modIcons != null;

        final IndexedSprite[] newModIcons = Arrays.copyOf(modIcons, modIcons.length + pets.length);
        petsIconIdx = modIcons.length;

        client.setModIcons(newModIcons);

        for (int i = 0; i < pets.length; i++)
        {
            final int petId = pets[i];

            final AsyncBufferedImage abi = itemManager.getImage(petId);
            final int idx = petsIconIdx + i;
            abi.onLoaded(() ->
            {
                final BufferedImage image = ImageUtil.resizeImage(abi, 18, 16);
                final IndexedSprite sprite = ImageUtil.getImageIndexedSprite(image, client);
                client.getModIcons()[idx] = sprite;
            });
        }
    }

    /**
     * Looks up the list of owned pets for the local player
     */
    private List<Pet> getPetListOld()
    {
        String petListJson = configManager.getRSProfileConfiguration("chatcommands", "pets",
                String.class);

        List<Pet> petList;
        try
        {
            // CHECKSTYLE:OFF
            petList = gson.fromJson(petListJson, new TypeToken<List<Pet>>(){}.getType());
            // CHECKSTYLE:ON
        }
        catch (JsonSyntaxException ex)
        {
            return Collections.emptyList();
        }

        return petList != null ? petList : Collections.emptyList();
    }

    private List<Integer> getPetList()
    {
        List<Pet> old = getPetListOld();
        if (!old.isEmpty())
        {
            List<Integer> l = old.stream().map(Pet::getIconID).collect(Collectors.toList());
            return l;
        }

        String petListJson = configManager.getRSProfileConfiguration("chatcommands", "pets2",
                String.class);

        List<Integer> petList;
        try
        {
            // CHECKSTYLE:OFF
            petList = gson.fromJson(petListJson, new TypeToken<List<Integer>>(){}.getType());
            // CHECKSTYLE:ON
        }
        catch (JsonSyntaxException ex)
        {
            return Collections.emptyList();
        }

        return petList != null ? petList : Collections.emptyList();
    }

    @VisibleForTesting
    static double timeStringToSeconds(String timeString)
    {
        String[] s = timeString.split(":");
        if (s.length == 2) // mm:ss
        {
            return Integer.parseInt(s[0]) * 60 + Double.parseDouble(s[1]);
        }
        else if (s.length == 3) // h:mm:ss
        {
            return Integer.parseInt(s[0]) * 60 * 60 + Integer.parseInt(s[1]) * 60 + Double.parseDouble(s[2]);
        }
        return Double.parseDouble(timeString);
    }
    @Subscribe
    public void onGameStateChanged(GameStateChanged event)
    {
        switch (event.getGameState())
        {
            case LOADING:
            case HOPPING:
                pohOwner = null;
                break;
            case STARTING:
                petsIconIdx = -1;
                pets = null;
                break;
            case LOGIN_SCREEN:
                if (petsIconIdx == -1)
                {
                    loadPets();
                }
                break;
        }
    }
    
}

package io.droptracker.util;


import com.google.gson.Gson;
import com.google.gson.reflect.TypeToken;
import lombok.extern.slf4j.Slf4j;
import okhttp3.*;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.annotations.Nullable;
import org.jetbrains.annotations.VisibleForTesting;

import javax.inject.Inject;
import javax.inject.Singleton;
import java.io.IOException;
import java.io.Reader;
import java.util.Collections;
import java.util.HashMap;
import java.util.Map;
import java.util.Set;
import java.util.concurrent.CompletableFuture;
import java.util.function.Function;

/**
 * This thread-safe singleton holds a mapping of item names to their item id, using the RuneLite API.
 * <p>
 * Unlike {@link net.runelite.client.game.ItemManager#search(String)}, this mapping supports untradable items.
 *
 * Author: iProdigy ( https://github.com/pajlads/DinkPlugin )
 */

@Slf4j
@Singleton
public class ItemIDSearch {
    final String ITEM_CACHE_BASE_URL = "https://static.runelite.net/cache/item/";
    private final Map<String, Integer> itemIdByName = Collections.synchronizedMap(new HashMap<>(16384));
    private @Inject OkHttpClient httpClient;
    private @Inject Gson gson;

    /**
     * @param name the exact in-game name of an item
     * @return the id associated with the item name, or null if not found
     */
    @Nullable
    public Integer findItemId(@NotNull String name) {
        return itemIdByName.get(name);
    }

    /**
     * Begins the initialization process for {@link #itemIdByName}
     * by querying item names and noted item ids from the RuneLite API,
     * before passing them to {@link #populate(Map, Set)}
     *
     * @implNote This operation does not block the current thread,
     * by utilizing OkHttp's thread pool and Java's Fork-Join common pool.
     */
    @Inject
    void init() {
        queryNamesById()
                .thenAcceptBothAsync(
                        queryNotedItemIds().exceptionally(e -> {
                            log.error("Failed to read noted items", e);
                            return Collections.emptySet();
                        }),
                        this::populate
                )
                .exceptionally(e -> {
                    log.error("Failed to read item names", e);
                    return null;
                });
    }

    /**
     * Populates {@link #itemIdByName} with the inverted mappings of {@code namesById},
     * while skipping noted items specified in {@code notedIds}.
     *
     * @param namesById a mapping of item id's to the corresponding in-game name
     * @param notedIds  the id's of noted items
     * @implNote When multiple non-noted item id's have the same in-game name, only the earliest id is saved
     */
    @VisibleForTesting
    void populate(@NotNull Map<Integer, String> namesById, @NotNull Set<Integer> notedIds) {
        namesById.forEach((id, name) -> {
            if (!notedIds.contains(id))
                itemIdByName.putIfAbsent(name, id);
        });

        log.debug("Completed initialization of item cache with {} entries", itemIdByName.size());
    }

    /**
     * @return a mapping of item ids to their in-game names, provided by the RuneLite API
     */
    private CompletableFuture<Map<Integer, String>> queryNamesById() {
        return queryCache("names.json", new TypeToken<Map<Integer, String>>() {});
    }

    /**
     * @return a set of id's of noted items, provided by the RuneLite API
     */
    private CompletableFuture<Set<Integer>> queryNotedItemIds() {
        return queryCache("notes.json", new TypeToken<Map<Integer, Integer>>() {})
                .thenApply(Map::keySet);
    }

    /**
     * @param fileName the name of the file to query from RuneLite's cache
     * @param type     a type token that indicates how the json response should be parsed
     * @return the transformed cache response, wrapped in a future
     */
    private <T> CompletableFuture<T> queryCache(@NotNull String fileName, @NotNull TypeToken<T> type) {
        return readJson(httpClient, gson, ITEM_CACHE_BASE_URL + fileName, type);
    }
    public <T> CompletableFuture<T> readJson(@NotNull OkHttpClient httpClient, @NotNull Gson gson, @NotNull String url, @NotNull TypeToken<T> type) {
        return readUrl(httpClient, url, reader -> gson.fromJson(reader, type.getType()));
    }
    public <T> CompletableFuture<T> readUrl(@NotNull OkHttpClient httpClient, @NotNull String url, @NotNull Function<Reader, T> transformer) {
        CompletableFuture<T> future = new CompletableFuture<>();
        Request request = new Request.Builder().url(url).build();
        httpClient.newCall(request).enqueue(new Callback() {
            @Override
            public void onFailure(@NotNull Call call, @NotNull IOException e) {
                future.completeExceptionally(e);
            }

            @Override
            public void onResponse(@NotNull Call call, @NotNull Response response) {
                assert response.body() != null;
                try (Reader reader = response.body().charStream()) {
                    future.complete(transformer.apply(reader));
                } catch (Exception e) {
                    future.completeExceptionally(e);
                } finally {
                    response.close();
                }
            }
        });
        return future;
    }
}

package io.droptracker.util;

/* Author: Dink Plugin */

import lombok.AccessLevel;
import lombok.Data;
import lombok.Setter;

/**
 * Contains kill count observed by base runelite loot tracker plugin, stored in profile configuration.
 *
 * @see <a href="https://github.com/runelite/runelite/blob/master/runelite-client/src/main/java/net/runelite/client/plugins/loottracker/ConfigLoot.java#L41">RuneLite class</a>
 */
@Data
@Setter(AccessLevel.PRIVATE)
public class SerializedDrop {
    private int kills;
}

package io.droptracker;

import net.runelite.client.config.Config;
import net.runelite.client.config.ConfigGroup;
import net.runelite.client.config.ConfigItem;
import net.runelite.client.config.ConfigSection;

@ConfigGroup(DropTrackerConfig.GROUP)
public interface DropTrackerConfig extends Config
	/* Section Positions:
	1 (0) - General Settings
	2 (1) - Values
	2 (2) - Screenshots
	 */
{
	String GROUP = "droptracker";

	/* Loot related Tracking */
	@ConfigSection(
			name = "Loot Tracking",
			description = "Define what rules you want set for loot",
			position = 1,
			closedByDefault = false
	) String LootSection = "Loot Tracking";
	@ConfigItem(
			keyName = "lootEmbeds",
			name = "Enable Loot Tracking",
			description = "Should we send your drops to the DropTracker?",
			position = 0,
			section = LootSection

	) default boolean lootEmbeds(){ return true;}
	@ConfigItem(
			keyName = "valueableDrops",
			name = "Screenshot Drops",
			description = "Do you want to submit screenshots when a drop<br />" +
					"Exceeds the threshold you set?",
			position = 1,
			section = LootSection
	) default boolean screenshotDrops() { return true; }
	@ConfigItem(
			keyName = "screenshotValue",
			name = "Screenshot minimum",
			description = "What minimum value would you like drops to be sent with an attached image for?",
			position = 2,
			section = LootSection
	)default int screenshotValue() { return 250000; }

	/* Personal Best related Tracking */
	@ConfigSection(
			name = "Personal Bests",
			description = "Should we send your personal bests to the DropTracker?",
			position = 2,
			closedByDefault = false
	) String PbSection = "Personal Bests";
	@ConfigItem(
			keyName = "pbEmbeds",
			name = "Enable PBs",
			description = "Do you want DropTracker to track your PBs?",
			position = 1,
			section = PbSection
	) default boolean pbEmbeds() { return true; }
	@ConfigItem(
			keyName = "screenshotPB",
			name = "Screenshot PBs",
			description = "Do you want a screenshot to be sent\n" +
					"when you acquire a new Personal Best?",
			position = 2,
			section = PbSection
	) default boolean screenshotPBs() { return true; }

	/* Collection Log related Tracking */
	@ConfigSection(
			name = "Collection Logs",
			description = "<html>Define what rules you want set for Collection Log <br>" +
					"<b>Note</b>: Requires Collection Log Notification and popup Enabled in OSRS settings</html>",
			position = 3,
			closedByDefault = false
	) String ClogSection = "Collection Logs";
	@ConfigItem(
			keyName = "clogEmbeds",
			name = "Enable Clogs",
			description = "Should we send new collection log slot unlocks to the DropTracker?",
			position = 1,
			section = ClogSection
	) default boolean clogEmbeds() { return true; }
	@ConfigItem(
			keyName = "screenshotClog",
			name = "Screenshot Clogs",
			description = "Do you want screenshots to be sent when you\n" +
					"receive new collection log slots?",
			position = 2,
			section = ClogSection
	) default boolean screenshotNewClogs() { return true; }

	/* Combat Achievement related Tracking */
	@ConfigSection(
			name = "Combat Achievements",
			description = "Define what rules you want set for Combat Achievements",
			position = 4,
			closedByDefault = false
	) String CaSection = "Combat Achievements";
	@ConfigItem(
			keyName = "caEmbeds",
			name = "Enable CAs",
			description = "Should we send your drops to the DropTracker?",
			position = 3,
			section = CaSection
	) default boolean caEmbeds() { return true; }
	@ConfigItem(
			keyName = "screenshotCAs",
			name = "Screenshot CAs",
			description = "Do you want a screenshot to be sent\n" +
					"when you complete a Combat Task?",
			position = 3,
			section = CaSection
	) default boolean screenshotCAs() { return true; }


	@ConfigSection(
			name = "Additonal Settings",
			description = "Configure your client settings for the DropTracker database",
			position= 5 ,
			closedByDefault = false
	) String apiSection = "Additional Settings";
	/* Settings for Hiding Split Chat, Side Panel and API connections */
	@ConfigItem(
			keyName = "hideWhispers",
			name = "Hide PMs",
			description = "Do you want your private chat to be\n" +
					"hidden when screenshots are taken?",
			position = -1,
			section = apiSection
	) default boolean hideDMs() { return false; }
	@ConfigItem(
			name = "Show Side Panel",
			keyName = "showSidePanel",
			description = "<html>Do you want to render the <br>side-panel to lookup players, etc?<br>" +
					"<b>Note</b>: Requires the API to be enabled.</html>",
			position = 0,
			section = apiSection
	) default boolean showSidePanel() { return true; }

	@ConfigItem(
			name="Use API Connections",
			keyName = "useApi",
			description = "Enables external connections to the DropTracker database, for panel data.<br />" +
					"<b>Note</b>: The API is currently <b>required</b> for participation in events!",
			position = 1,
			section = apiSection,
			warning = "<html><b>WARNING</b>: Enabling this feature will send external<br>connections" +
					"to the DropTracker server, which" +
					"can not<br> be verified by the RuneLite Developers.<br>" +
					"<b>Are you sure that you want to enable external connections?</b><br></html>"
	) default boolean useApi() { return false; }

}

package io.droptracker.api;

import javax.crypto.Cipher;
import javax.crypto.Mac;
import javax.crypto.spec.IvParameterSpec;
import javax.crypto.spec.SecretKeySpec;
import java.nio.ByteBuffer;
import java.nio.charset.StandardCharsets;
import java.util.Arrays;
import java.util.Base64;

import javax.inject.Inject;
import javax.inject.Singleton;

@Singleton
public class FernetDecrypt {
    private static final String ENCRYPTION_KEY = "bKWn6PnBLfJHNM7nrxuotRTcn3hzHnl-eANL54Il2Hw=";
    private static final byte VERSION = (byte) 0x80;

    @Inject
    public FernetDecrypt() {
    }

    public static String decryptWebhook(String webhookHash) throws Exception {
        // First decode - get the Fernet token
        String fernetToken = new String(Base64.getUrlDecoder().decode(webhookHash), StandardCharsets.UTF_8);
        
        // Second decode - get the encrypted data
        byte[] token = Base64.getUrlDecoder().decode(fernetToken);
        
        // Decode the key
        byte[] keyBytes = Base64.getUrlDecoder().decode(ENCRYPTION_KEY);
        byte[] signingKey = Arrays.copyOfRange(keyBytes, 0, 16);
        byte[] encryptionKey = Arrays.copyOfRange(keyBytes, 16, 32);

        // Extract components
        ByteBuffer buffer = ByteBuffer.wrap(token);
        byte version = buffer.get();
        long timestamp = buffer.getLong();
        byte[] iv = new byte[16];
        buffer.get(iv);
        
        // Get the HMAC (last 32 bytes)
        byte[] hmac = Arrays.copyOfRange(token, token.length - 32, token.length);
        byte[] message = Arrays.copyOfRange(token, 0, token.length - 32);
        
        // Verify HMAC
        Mac mac = Mac.getInstance("HmacSHA256");
        mac.init(new SecretKeySpec(signingKey, "HmacSHA256"));
        byte[] calculatedHmac = mac.doFinal(message);
        
        if (!Arrays.equals(hmac, calculatedHmac)) {
            throw new SecurityException("Invalid HMAC");
        }

        // Get ciphertext (everything between IV and HMAC)
        byte[] ciphertext = Arrays.copyOfRange(token, 25, token.length - 32);
        
        // Decrypt
        Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5Padding");
        cipher.init(Cipher.DECRYPT_MODE, 
                   new SecretKeySpec(encryptionKey, "AES"),
                   new IvParameterSpec(iv));
        
        return new String(cipher.doFinal(ciphertext), StandardCharsets.UTF_8);
    }
}
package io.droptracker.api;

import com.google.gson.Gson;
import io.droptracker.DropTrackerConfig;
import net.runelite.api.ChatMessageType;
import net.runelite.api.Client;
import net.runelite.client.chat.ChatColorType;
import net.runelite.client.chat.ChatMessageBuilder;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.chat.QueuedMessage;
import okhttp3.*;

import javax.inject.Inject;
import javax.inject.Inject;
import javax.swing.*;
import java.io.IOException;
import java.text.DecimalFormat;
import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.CompletionStage;

public class DropTrackerApi {
    private final DropTrackerConfig config;
    @Inject
    public ChatMessageManager msgManager;
    @Inject
    private Client client;
    @Inject
    private Gson gson;
    @Inject
    private OkHttpClient httpClient;
    private PanelDataLoadedCallback dataLoadedCallback;

    @Inject
    public DropTrackerApi(DropTrackerConfig config, ChatMessageManager chatMessageManager, Gson gson, OkHttpClient httpClient, Client client) {
        this.config = config;
        this.msgManager = chatMessageManager;
        this.gson = gson;
        this.httpClient = httpClient;
        this.client = client;
    }

    public void setDataLoadedCallback(PanelDataLoadedCallback callback) {
        this.dataLoadedCallback = callback;
    }

    /**
     * Sends a request to the API to look up a player's data and returns a CompletionStage for async handling.
     */
    public CompletionStage<Map<String, Object>> lookupPlayer(String playerName) {
        CompletableFuture<Map<String, Object>> future = new CompletableFuture<>();

        // Check if the API is enabled
        if (!config.useApi()) {
            future.completeExceptionally(new IllegalStateException("API is not enabled in the plugin config"));
            return future;
        }

        String apiUrl = getApiUrl();
        HttpUrl url = HttpUrl.parse(apiUrl + "/player_lookup/" + playerName);

        if (url == null) {
            future.completeExceptionally(new IllegalArgumentException("Invalid URL"));
            return future;
        }

        Request request = new Request.Builder().url(url).build();

        httpClient.newCall(request).enqueue(new Callback() {
            @Override
            public void onFailure(Call call, IOException e) {
                e.printStackTrace();
                future.completeExceptionally(e);
            }

            @Override
            public void onResponse(Call call, Response response) throws IOException {
                try (ResponseBody responseBody = response.body()) {
                    String responseData = responseBody.string();
                    Map<String, Object> responseMap = gson.fromJson(responseData, Map.class);

                    if (!response.isSuccessful()) {
                        // Return the error message as part of the response to be handled
                        future.complete(responseMap);
                        return;
                    }

                    // If response is successful, return the response map
                    future.complete(responseMap);
                } catch (IllegalStateException e) {
                    // If the webserver is down or malfunctioning, this is the likely outcome
                    future.cancel(true);
                }
            }
        });

        return future;
    }



    public String getApiUrl() {
        return config.useApi() ? "https://www.droptracker.io/api/" : "";
    }

    public String getLatestUpdateString() {
        String endpoint = "https://www.droptracker.io/api/latest_news";
        try {
            Request request = new Request.Builder().url(endpoint).build();
            try (Response response = httpClient.newCall(request).execute()) {
                if (response.isSuccessful() && response.body() != null) {
                    return response.body().string();
                } else {
                    return "Error fetching latest update";
                }
            }
        } catch (IOException e) {
            return "Error fetching latest update";
        }
    }

    public interface PanelDataLoadedCallback {
        void onDataLoaded(Map<String, Object> data);
    }

    public static String formatNumber(double number) {
        if (number == 0) {
            return "0";
        }
        String[] units = new String[]{"", "K", "M", "B", "T"};
        int unit = (int) Math.floor((Math.log10(number) / 3));

        if (unit >= units.length) unit = units.length - 1;

        double num = number / Math.pow(1000, unit);
        DecimalFormat df = new DecimalFormat("#.#");
        String formattedNum = df.format(num);
        return formattedNum + units[unit];
    }
}

/*
 * Copyright (c) 2021, Illya Myshakov <https://github.com/IllyaMyshakov>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package io.droptracker.models;

import lombok.AllArgsConstructor;
import lombok.Getter;
import net.runelite.api.ItemID;

@AllArgsConstructor
@Getter
public enum Pet
{
    ABYSSAL_ORPHAN("Abyssal orphan", ItemID.ABYSSAL_ORPHAN),
    IKKLE_HYDRA("Ikkle hydra", ItemID.IKKLE_HYDRA),
    CALLISTO_CUB("Callisto cub", ItemID.CALLISTO_CUB),
    HELLPUPPY("Hellpuppy", ItemID.HELLPUPPY),
    PET_CHAOS_ELEMENTAL("Pet chaos elemental", ItemID.PET_CHAOS_ELEMENTAL),
    PET_ZILYANA("Pet zilyana", ItemID.PET_ZILYANA),
    PET_DARK_CORE("Pet dark core", ItemID.PET_DARK_CORE),
    PET_DAGANNOTH_PRIME("Pet dagannoth prime", ItemID.PET_DAGANNOTH_PRIME),
    PET_DAGANNOTH_SUPREME("Pet dagannoth supreme", ItemID.PET_DAGANNOTH_SUPREME),
    PET_DAGANNOTH_REX("Pet dagannoth rex", ItemID.PET_DAGANNOTH_REX),
    TZREKJAD("Tzrek-jad", ItemID.TZREKJAD),
    PET_GENERAL_GRAARDOR("Pet general graardor", ItemID.PET_GENERAL_GRAARDOR),
    BABY_MOLE("Baby mole", ItemID.BABY_MOLE),
    NOON("Noon", ItemID.NOON),
    JALNIBREK("Jal-nib-rek", ItemID.JALNIBREK),
    KALPHITE_PRINCESS("Kalphite princess", ItemID.KALPHITE_PRINCESS),
    PRINCE_BLACK_DRAGON("Prince black dragon", ItemID.PRINCE_BLACK_DRAGON),
    PET_KRAKEN("Pet kraken", ItemID.PET_KRAKEN),
    PET_KREEARRA("Pet kree'arra", ItemID.PET_KREEARRA),
    PET_KRIL_TSUTSAROTH("Pet k'ril tsutsaroth", ItemID.PET_KRIL_TSUTSAROTH),
    SCORPIAS_OFFSPRING("Scorpia's offspring", ItemID.SCORPIAS_OFFSPRING),
    SKOTOS("Skotos", ItemID.SKOTOS),
    PET_SMOKE_DEVIL("Pet smoke devil", ItemID.PET_SMOKE_DEVIL),
    VENENATIS_SPIDERLING("Venenatis spiderling", ItemID.VENENATIS_SPIDERLING),
    VETION_JR("Vet'ion jr.", ItemID.VETION_JR),
    VORKI("Vorki", ItemID.VORKI),
    PHOENIX("Phoenix", ItemID.PHOENIX),
    PET_SNAKELING("Pet snakeling", ItemID.PET_SNAKELING),
    OLMLET("Olmlet", ItemID.OLMLET),
    LIL_ZIK("Lil' zik", ItemID.LIL_ZIK),
    BLOODHOUND("Bloodhound", ItemID.BLOODHOUND),
    PET_PENANCE_QUEEN("Pet penance queen", ItemID.PET_PENANCE_QUEEN),
    HERON("Heron", ItemID.HERON),
    ROCK_GOLEM("Rock golem", ItemID.ROCK_GOLEM),
    BEAVER("Beaver", ItemID.BEAVER),
    BABY_CHINCHOMPA("Baby chinchompa", ItemID.BABY_CHINCHOMPA_13324),
    GIANT_SQUIRREL("Giant squirrel", ItemID.GIANT_SQUIRREL),
    TANGLEROOT("Tangleroot", ItemID.TANGLEROOT),
    ROCKY("Rocky", ItemID.ROCKY),
    RIFT_GUARDIAN("Rift guardian", ItemID.RIFT_GUARDIAN),
    HERBI("Herbi", ItemID.HERBI),
    CHOMPY_CHICK("Chompy chick", ItemID.CHOMPY_CHICK),
    SRARACHA("Sraracha", ItemID.SRARACHA),
    SMOLCANO("Smolcano", ItemID.SMOLCANO),
    YOUNGLLEF("Youngllef", ItemID.YOUNGLLEF),
    LITTLE_NIGHTMARE("Little nightmare", ItemID.LITTLE_NIGHTMARE),
    LIL_CREATOR("Lil' creator", ItemID.LIL_CREATOR),
    TINY_TEMPOR("Tiny tempor", ItemID.TINY_TEMPOR),
    NEXLING("Nexling", ItemID.NEXLING),
    ABYSSAL_PROTECTOR("Abyssal protector", ItemID.ABYSSAL_PROTECTOR),
    ;

    private final String name;
    private final Integer iconID;

    static Pet findPet(String petName)
    {
        for (Pet pet : values())
        {
            if (pet.name.equals(petName))
            {
                return pet;
            }
        }
        return null;
    }
}
package io.droptracker.models;

import java.util.ArrayList;
import java.util.List;
import lombok.Data;

@Data
public class CustomWebhookBody
{
	private String content;
	private List<Embed> embeds = new ArrayList<>();
	private static Author DropTracker = new Author("https://www.droptracker.io/",
			"DropTracker",
			"https://www.droptracker.io/img/droptracker-small.gif");

	@Data
	public static class Embed
	{
		public String title = "";
		UrlEmbed image = null;
		final Author author = DropTracker;
		final List<Field> fields = new ArrayList<>();
		public void addField(String name, String value, boolean inline) {
			this.fields.add(new Field(name, value, inline));
		}
		public void setImage(String imageUrl) {
			this.image = new UrlEmbed(imageUrl);
		}
	}

	@Data
	public static class UrlEmbed
	{
		final String url;
	}
	@Data
	public static class Author
	{
		final String url;
		final String name;
		final String icon_url;
	}
	@Data
	public static class Field
	{
		final String name;
		final String value;
		final boolean inline;
	}
}

package io.droptracker.models;
/*
*  Author: https://github.com/pajlads/DinkPlugin
* */
import lombok.Value;
import net.runelite.client.game.ItemStack;
import net.runelite.http.api.loottracker.LootRecordType;

import java.time.Instant;
import java.util.Collection;

@Value
public class Drop {
    String source;
    LootRecordType category;
    Collection<ItemStack> items;
    Instant time = Instant.now();

    public static String getAction(LootRecordType type) {
        switch (type) {
            case NPC:
                return "Kill";
            case PLAYER:
                return "Player Kill";
            case PICKPOCKET:
                return "Pickpocket";
            default:
                return "Completion";
        }
    }
}

package io.droptracker.models;

import lombok.Getter;

import java.util.Arrays;
import java.util.Collections;
import java.util.Map;
import java.util.function.Function;
import java.util.stream.Collectors;

@Getter
public enum CombatAchievement {
    EASY,
    MEDIUM,
    HARD,
    ELITE,
    MASTER,
    GRANDMASTER;

    /**
     * The points-based achievement system assigns one point to {@link #EASY} tasks,
     * and increments by one for each difficulty level.
     *
     * @see <a href="https://gachi.gay/01CAv">Point values documented in blog post</a>
     */
    private final int points = this.ordinal() + 1;
    private final String displayName = this.name().charAt(0) + this.name().substring(1).toLowerCase();

    @Override
    public String toString() {
        return this.displayName;
    }

    public static final Map<String, CombatAchievement> TIER_BY_LOWER_NAME = Collections.unmodifiableMap(
            Arrays.stream(values()).collect(Collectors.toMap(t -> t.name().toLowerCase(), Function.identity()))
    );
}


package io.droptracker.models;
/*  Original Author @pajlads - DinkPlugin

    https://github.com/pajlads/DinkPlugin

 */

import com.google.gson.annotations.JsonAdapter;
import io.droptracker.util.DurationAdapter;
import lombok.EqualsAndHashCode;
import lombok.Setter;
import lombok.Value;
import lombok.experimental.Accessors;

import java.time.Duration;
import java.util.Collections;
import java.util.List;

@Value
@EqualsAndHashCode(callSuper = false)
public class BossNotification {
    public List<CustomWebhookBody.Embed> getFields() {
        return Collections.emptyList();
    }
    String boss;
    Integer count;
    String gameMessage;
    @JsonAdapter(DurationAdapter.class)
    Duration time;
    @JsonAdapter(DurationAdapter.class)
    Duration bestTime;
    @Accessors(fluent = true)
    Boolean isPersonalBest;

}

package io.droptracker.ui;

import javax.swing.*;
import java.awt.*;
import java.util.HashMap;
import java.util.Map;

class TableRow extends JPanel {
    Map<String, JLabel> labels = new HashMap<>();

    TableRow(String boss, String killsText, String rankText, String ehbText) {
        setLayout(new GridLayout(1, 4));
        addLabel(boss);
        addLabel(killsText);
        addLabel(rankText);
        addLabel(ehbText);
    }

    private void addLabel(String text) {
        JLabel label = new JLabel(text);
        label.setForeground(Color.WHITE);
        labels.put(text, label);
        add(label);
    }

    // Updates the row's labels with data
    public void update(String kills, String rank, String ehb) {
        labels.get("kills").setText(String.valueOf(kills));
        labels.get("rank").setText(String.valueOf(rank));
        labels.get("ehb").setText(String.valueOf(ehb));
    }

    // Resets the row to default state
    public void reset() {
        labels.get("kills").setText("--");
        labels.get("rank").setText("--");
        labels.get("ehb").setText("--");
    }
}

class RowPair {
    private final String skill;
    private final TableRow row;

    public RowPair(String skill, TableRow row) {
        this.skill = skill;
        this.row = row;
    }

    public String getSkill() {
        return skill;
    }

    public TableRow getRow() {
        return row;
    }
}

package io.droptracker.ui;

import io.droptracker.DropTrackerPlugin;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.util.ImageUtil;

import javax.swing.*;
import javax.swing.table.DefaultTableCellRenderer;
import javax.swing.table.TableColumn;
import javax.swing.table.TableColumnModel;
import java.awt.*;
import java.awt.event.MouseEvent;
import java.util.Arrays;
import java.util.Map;
import java.util.Objects;

public class BossPanel extends JPanel {
    private static final String[] COLUMNS = {"", "Loot", "Rank"};
    private JTable bossTable;
    private String[] npcNames;
    private Map<String, Map<String, Object>> npcDetailsCache; // Cache for npc details

    public BossPanel() {
        setLayout(new BorderLayout());
        npcNames = new String[0];
        bossTable = new JTable(new String[0][COLUMNS.length], COLUMNS) {
            @Override
            public String getToolTipText(MouseEvent e) {
                int row = rowAtPoint(e.getPoint());
                int column = columnAtPoint(e.getPoint());
                if (row != -1) {
                    String npcName = npcNames[row];
                    Map<String, Object> details = npcDetailsCache.get(npcName);
                    return buildTooltip(details, row, column);
                }
                return super.getToolTipText();
            }
        };
        bossTable.setEnabled(false); // Prevent editing
        JScrollPane scrollPane = new JScrollPane(bossTable);
        add(scrollPane, BorderLayout.CENTER);
        setCustomRenderers();
    }

    public void update(Map<String, Map<String, Object>> npcData) {
        // Clear previous content from the bossPanel
        removeAll();

        if (npcData == null || npcData.isEmpty()) {
            revalidate();
            repaint();
            return;
        }

        // Ensure npcNames array matches the size of the incoming data
        npcNames = new String[npcData.size()];
        npcDetailsCache = npcData; // Store NPC data for tooltips

        String[][] rowData = new String[npcData.size()][COLUMNS.length];
        int i = 0;

        for (Map.Entry<String, Map<String, Object>> entry : npcData.entrySet()) {
            String npcName = entry.getKey();
            npcNames[i] = npcName;

            Map<String, Object> details = entry.getValue();
            Map<String, String> loot = (Map<String, String>) details.get("loot");
            if (loot.get("all-time").equals("0")) {
                // skip npcs that the user has never reported loot from
                continue;
            }
            Map<String, Object> rankDetails = (Map<String, Object>) details.get("rank");

            String globalRank = rankDetails.get("global") != null ? rankDetails.get("global").toString() : "--";

            // Store row data in array
            rowData[i][0] = npcName;
            rowData[i][1] = loot.get("all-time") + " gp";
            rowData[i][2] = globalRank;

            i++;
        }

        // Update the table model without recreating the table
        bossTable.setModel(new javax.swing.table.DefaultTableModel(rowData, COLUMNS));
        setCustomRenderers();

        // Re-add the updated table to the panel
        JScrollPane scrollPane = new JScrollPane(bossTable);
        if (rowData.length > 0) {
            int height = Math.min(bossTable.getRowHeight() * rowData.length + 300, 1000); // Limit the height
            scrollPane.setPreferredSize(new Dimension(scrollPane.getPreferredSize().width, height));
        }
        add(scrollPane, BorderLayout.CENTER);
        int windowHeight = Math.min(bossTable.getRowHeight() * rowData.length + 200, 600);
        Dimension preferredSize = new Dimension(220, windowHeight);
        setPreferredSize(preferredSize);
        // Revalidate and repaint the panel to trigger a layout update
        revalidate();
        repaint();
    }


    // Custom renderer to display NPC icons with tooltips
    private class NpcImageRenderer extends DefaultTableCellRenderer {
        @Override
        public Component getTableCellRendererComponent(JTable table, Object value, boolean isSelected, boolean hasFocus, int row, int column) {
            JLabel label = (JLabel) super.getTableCellRendererComponent(table, value, isSelected, hasFocus, row, column);
            String npcName = npcNames[row];
            String imagePath;
            String lowerName = (npcName.toLowerCase());
            // Handle edge-case NPCs
            if (lowerName.contains("barrows")) {
                imagePath = sanitizeNpcNameForImagePath("barrows chests");
            } else if (lowerName.contains("fortis")) {
                imagePath = sanitizeNpcNameForImagePath("sol heredit");
            } else if(lowerName.contains("gauntlet")){
                imagePath = sanitizeNpcNameForImagePath("gauntlet");
            } else if(lowerName.contains(("perilous moons"))) {
                imagePath = sanitizeNpcNameForImagePath("lunar chests");
            } else if(lowerName.contains("dagannoth kings")) {
                imagePath = sanitizeNpcNameForImagePath("dagannoth rex");
            } else if(lowerName.contains(("theatre of blood"))) {
                imagePath = sanitizeNpcNameForImagePath("theatre of blood");
            } else if(lowerName.contains("chambers of xeric")) {
                imagePath = sanitizeNpcNameForImagePath("chambers of xeric");
            } else if(lowerName.contains("tombs of amascut")){
                imagePath = sanitizeNpcNameForImagePath("tombs of amascut");
            } else if(lowerName.contains("vet'ion")){
                imagePath = sanitizeNpcNameForImagePath("vetion");
            } else if( lowerName.contains("callisto")){
                imagePath = sanitizeNpcNameForImagePath("callisto");
            } else if(lowerName.contains("venenatis")){
                imagePath = sanitizeNpcNameForImagePath("venenatis");
            } else if(lowerName.contains("nightmare")){
                imagePath = sanitizeNpcNameForImagePath("nightmare");
            } else {
                imagePath = sanitizeNpcNameForImagePath(npcName);
            }

            // Load the NPC icon
            ImageIcon npcIcon = new ImageIcon(ImageUtil.loadImageResource(DropTrackerPlugin.class, imagePath));

            label.setIcon(npcIcon);
            label.setText("");  // Hides the NPC name text

            // Ensure npcDetailsCache is not null and contains the data for npcName
            if (npcDetailsCache != null && npcDetailsCache.containsKey(npcName)) {
                Map<String, Object> details = npcDetailsCache.get(npcName);
                label.setToolTipText(buildTooltip(details, row, column));
            } else {
                label.setToolTipText("No data available");
            }

            return label;
        }
        private String sanitizeNpcNameForImagePath(String npcName) {
            String sanitizedNpcName = npcName.toLowerCase().replace(" ", "_");
            sanitizedNpcName = sanitizedNpcName.replace("'", "").replace(",", "")
                    .replace("-", "_");

            if (sanitizedNpcName.equals("the_nightmare")) {
                sanitizedNpcName = "nightmare";
            }

            return "icons/bosses/" + sanitizedNpcName + ".png";
        }
    }


    // Renderer to apply alternating row colors and provide tooltips
    private class AlternatingColorRenderer extends DefaultTableCellRenderer {
        @Override
        public Component getTableCellRendererComponent(JTable table, Object value, boolean isSelected, boolean hasFocus, int row, int column) {
            Component c = super.getTableCellRendererComponent(table, value, isSelected, hasFocus, row, column);
            c.setBackground(row % 2 == 0 ? ColorScheme.DARKER_GRAY_COLOR : ColorScheme.DARK_GRAY_COLOR);
            String npcName = npcNames[row];
            Map<String, Object> details = npcDetailsCache.get(npcName);
            return c;
        }
    }

    private String buildTooltip(Map<String, Object> details, int row, int column) {
        Map<String, String> loot = (Map<String, String>) details.get("loot");
        Map<String, Object> rank = (Map<String, Object>) details.get("rank");
        Map<String, Object> pbDetails = (Map<String, Object>) details.get("PB");

        String monthLoot = loot.get("month") != null ? loot.get("month").toString() : "--";
        String allTimeLoot = loot.get("all-time") != null ? loot.get("all-time").toString() : "--";

        String groupRank = rank != null && rank.get("clan") != null ? rank.get("clan").toString() : "--";
        String globalRank = rank != null && rank.get("global") != null ? rank.get("global").toString() : "--";

        String pbTime = pbDetails != null && pbDetails.get("time") != null ? pbDetails.get("time").toString() : "--";
        String pbRankGlobal = pbDetails != null && pbDetails.get("rank_global") != null ? pbDetails.get("rank_global").toString() : "--";
        String pbRankClan = pbDetails != null && pbDetails.get("rank_clan") != null ? pbDetails.get("rank_clan").toString() : "--";

        String tooltip = "<html>";
        switch (column) {
            case 1: // Loot column
                tooltip += "All-time: " + allTimeLoot + "<br>This month: " + monthLoot;
                break;
            case 2: // Rank column
                if (groupRank != null && !groupRank.equals("0")) {
                    tooltip += "Rank (global): " + globalRank + "<br>Rank (clan): " + groupRank;
                } else {
                    tooltip += "Rank (global): " + globalRank;
                }
                break;
//            case 3: // PB column
//                tooltip += "PB: " + pbTime + "<br>Global Rank: " + pbRankGlobal + "<br>Clan Rank: " + pbRankClan;
//                break;
            default:
                // show pb time on tooltip for the boss if there is one present in the server response
                if (!Objects.equals(pbTime, "--")) {
                    if (!pbRankClan.equals("--") && pbRankClan != null) {
                        tooltip += npcNames[row] + "<br>PB: " + pbTime + "<br>Global Rank: " + pbRankGlobal + "<br>Clan Rank: " + pbRankClan;
                    } else {
                        tooltip += npcNames[row] + "<br>PB: " + pbTime + " (Rank: " + pbRankGlobal + ")";
                    }
                } else {
                    tooltip += npcNames[row];
            }
                break;
        }
        tooltip += "</html>";
        return tooltip;
    }

    private void setCustomRenderers() {
        // Get the table's column model
        TableColumnModel columnModel = bossTable.getColumnModel();

        TableColumn npcColumn = columnModel.getColumn(0);
        npcColumn.setCellRenderer(new NpcImageRenderer());
        npcColumn.setPreferredWidth(50);

        TableColumn lootColumn = columnModel.getColumn(1);
        lootColumn.setCellRenderer(new AlternatingColorRenderer());
        lootColumn.setPreferredWidth(150);

        // Column 2 (Rank)
        TableColumn rankColumn = columnModel.getColumn(2);
        rankColumn.setCellRenderer(new AlternatingColorRenderer());
        rankColumn.setPreferredWidth(75);

    }

}

package io.droptracker.ui;

import com.google.inject.Inject;
import io.droptracker.DropTrackerConfig;
import io.droptracker.DropTrackerPlugin;
import io.droptracker.api.DropTrackerApi;
import net.runelite.api.Client;
import net.runelite.client.eventbus.EventBus;
import net.runelite.client.plugins.info.InfoPanel;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.FontManager;
import net.runelite.client.ui.PluginPanel;
import net.runelite.client.ui.components.IconTextField;
import net.runelite.client.util.ImageUtil;
import net.runelite.client.util.LinkBrowser;

import javax.swing.*;
import javax.swing.border.EmptyBorder;
import java.awt.*;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.util.Map;

public class DropTrackerPanel extends PluginPanel implements DropTrackerApi.PanelDataLoadedCallback {
    private static final ImageIcon ARROW_RIGHT_ICON;
    private static final ImageIcon DISCORD_ICON;
    private static final ImageIcon WIKI_ICON;
    private static final ImageIcon TOP_LOGO;

    private final DropTrackerConfig config;
    private final DropTrackerApi api;
    private final DropTrackerPlugin plugin;
    private final Client client;

    private IconTextField searchBar;
    private JPanel mainContentPanel;
    private final BossPanel bossPanel;
    @Inject
    private EventBus eventBus;


    @Inject
    public DropTrackerPanel(DropTrackerConfig config, DropTrackerApi api, DropTrackerPlugin plugin, Client client) {
        this.config = config;
        this.api = api;
        this.plugin = plugin;
        this.client = client;
        this.bossPanel = new BossPanel();  // Initialize BossPanel
        init();
    }

    // Initializes the panel components
    public void init() {
        setLayout(new BorderLayout());
        setBackground(ColorScheme.DARK_GRAY_COLOR);
        setBorder(new EmptyBorder(10, 10, 10, 10));


        JPanel logoPanel = new JPanel(new BorderLayout());
        JLabel logoLabel = new JLabel(TOP_LOGO);
        logoLabel.setHorizontalAlignment(SwingConstants.CENTER);
        logoPanel.add(logoLabel, BorderLayout.CENTER);

        // Create the search panel
        JPanel searchPanel = new JPanel();
        searchPanel.setLayout(new GridBagLayout());
        GridBagConstraints gbc = new GridBagConstraints();
        gbc.gridx = 0;
        gbc.gridy = GridBagConstraints.RELATIVE;
        gbc.anchor = GridBagConstraints.WEST;
        gbc.fill = GridBagConstraints.HORIZONTAL;
        gbc.weightx = 1;
        gbc.insets = new Insets(0, 0, 0, 0);
        searchPanel.setBackground(ColorScheme.DARK_GRAY_COLOR);

        if (config.useApi()) {
            searchBar = new IconTextField();
            searchBar.setIcon(IconTextField.Icon.SEARCH);
            searchBar.setBackground(ColorScheme.DARKER_GRAY_COLOR);
            searchBar.addActionListener(e -> lookupPlayer());
            searchBar.addClearListener(this::resetPanel);

            JLabel infoText = new JLabel("<html><h2>Welcome to the DropTracker</h2>" +
                    "You should register your account<br>" +
                    "through our Discord bot (linked below) to " +
                    "enhance your experience with the plugin. " +
                    "Feel free to also visit our website to learn more.<br><br></html>");
            infoText.setForeground(Color.WHITE);
            JLabel searchBarText = new JLabel("Search for a player:");
            searchBarText.setForeground(Color.WHITE); // Ensure visibility on dark background

            searchPanel.add(infoText, gbc);
            searchPanel.add(searchBarText, gbc);
            searchPanel.add(searchBar, gbc);
        } else {
            JLabel noSearchText = new JLabel("<html>Enable the API (plugin config)<br>to search for players.</html>");
            noSearchText.setForeground(Color.WHITE);
            searchBar = new IconTextField();
            searchBar.setIcon(IconTextField.Icon.SEARCH);
            searchBar.setBackground(ColorScheme.DARKER_GRAY_COLOR);
            searchBar.addClearListener(this::resetPanel);

            searchPanel.add(noSearchText, gbc);
            searchPanel.add(searchBar, gbc);
        }
        logoPanel.add(searchPanel, BorderLayout.SOUTH);

        mainContentPanel = new JPanel();
        mainContentPanel.setLayout(new BoxLayout(mainContentPanel, BoxLayout.Y_AXIS));
        mainContentPanel.add(logoPanel);
        add(mainContentPanel, BorderLayout.CENTER);

        // Footer buttons (Discord, Docs)
        JPanel actionsContainer = new JPanel(new FlowLayout(FlowLayout.CENTER, 10, 0));
        actionsContainer.setBorder(new EmptyBorder(10, 0, 0, 0));
        actionsContainer.add(buildRoundedPanel("Discord", "https://www.droptracker.io/discord"));
        actionsContainer.add(buildRoundedPanel("Website", "https://www.droptracker.io"));
        add(actionsContainer, BorderLayout.SOUTH);


        if (config.useApi()) {
            this.api.setDataLoadedCallback(this);
        }

        revalidate();
        repaint();
    }
    public void deinit()
    {
        eventBus.unregister(this);
    }
    static
    {
        ARROW_RIGHT_ICON = new ImageIcon(ImageUtil.loadImageResource(InfoPanel.class, "/util/arrow_right.png"));
        DISCORD_ICON = new ImageIcon(ImageUtil.loadImageResource(InfoPanel.class, "discord_icon.png"));
        WIKI_ICON = new ImageIcon(ImageUtil.loadImageResource(InfoPanel.class, "wiki_icon.png"));
        TOP_LOGO = new ImageIcon(ImageUtil.loadImageResource(DropTrackerPlugin.class, "toplogo.png"));
    }

    // Helper method to create rounded buttons
    private JPanel buildRoundedPanel(String text, String url) {
        JPanel roundedContainer = new JPanel(new BorderLayout()) {
            @Override
            protected void paintComponent(Graphics g) {
                super.paintComponent(g);
                Graphics2D g2 = (Graphics2D) g.create();
                g2.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);
                g2.setColor(ColorScheme.MEDIUM_GRAY_COLOR);
                g2.fillRoundRect(0, 0, getWidth(), getHeight(), 10, 10);
                g2.dispose();
            }
        };
        roundedContainer.setOpaque(false);
        roundedContainer.setPreferredSize(new Dimension(100, 35));

        JLabel textLabel = new JLabel(text, SwingConstants.CENTER);
        textLabel.setForeground(Color.LIGHT_GRAY);
        textLabel.setFont(FontManager.getRunescapeFont().deriveFont(16f));
        roundedContainer.add(textLabel, BorderLayout.CENTER);

        roundedContainer.addMouseListener(new MouseAdapter() {
            @Override
            public void mousePressed(MouseEvent e) {
                roundedContainer.setBackground(ColorScheme.DARKER_GRAY_COLOR.darker());
            }

            @Override
            public void mouseReleased(MouseEvent e) {
                LinkBrowser.browse(url);
                roundedContainer.setBackground(ColorScheme.DARKER_GRAY_COLOR);
            }

            @Override
            public void mouseEntered(MouseEvent e) {
                roundedContainer.setBackground(ColorScheme.DARK_GRAY_COLOR);
            }

            @Override
            public void mouseExited(MouseEvent e) {
                roundedContainer.setBackground(ColorScheme.DARKER_GRAY_COLOR);
            }
        });
        return roundedContainer;
    }

    // Resets the panel to its default state
    private void resetPanel() {
        searchBar.setIcon(IconTextField.Icon.SEARCH);
        searchBar.setEditable(true);


        bossPanel.removeAll();


        revalidate();
        repaint();
    }


    // Triggers the player lookup when the search bar is used
    private void lookupPlayer() {
        String playerName = searchBar.getText().trim();
        if (!playerName.isEmpty() && config.useApi()) {
            api.lookupPlayer(playerName).whenCompleteAsync((result, ex) -> updateAfterSearch(playerName, result, ex));
        }
    }

    private void updateAfterSearch(String playerName, Map<String, Object> result, Throwable ex) {
        SwingUtilities.invokeLater(() -> {
            if (ex != null || result == null) {
                searchBar.setIcon(IconTextField.Icon.ERROR);
                JLabel errorMessage = new JLabel("An error occurred: " + ex.getMessage());
                bossPanel.add(errorMessage, BorderLayout.CENTER);
                mainContentPanel.add(bossPanel);
                revalidate();
                repaint();
                return;
            }

            searchBar.setIcon(IconTextField.Icon.SEARCH);

            String message = (String) result.get("message");
            if (result.get("bossData") != null) {
                applySearchResult(result);
                return;
            }

            // If there is a message from the server, display it
            JLabel errorMessage;
            if (message != null) {
                errorMessage = new JLabel(message);
            } else {
                errorMessage = new JLabel("Couldn't search for this player...");
            }

            bossPanel.removeAll();  // Clear previous content
            bossPanel.add(errorMessage, BorderLayout.CENTER);
            mainContentPanel.add(bossPanel);
            revalidate();
            repaint();
        });
    }


    private void applySearchResult(Map<String, Object> data) {
        mainContentPanel.remove(bossPanel);

        Map<String, Map<String, Object>> bossData = (Map<String, Map<String, Object>>) data.get("bossData");
        if (bossData == null) {
            return;
        }

        // Clear the previous content in bossPanel
        bossPanel.removeAll();


        // Update the BossPanel with the new NPC data
        bossPanel.update(bossData);

        // Re-add the BossPanel to the mainContentPanel
        mainContentPanel.add(bossPanel);

        revalidate();
        repaint();
    }

    @Override
    public void onDataLoaded(Map<String, Object> data) {
        applySearchResult(data);
    }


}
/*
BSD 2-Clause License

		Copyright (c) 2022, Jake Barter
		All rights reserved.

		Copyright (c) 2022, pajlads

		Redistribution and use in source and binary forms, with or without
		modification, are permitted provided that the following conditions are met:

		1. Redistributions of source code must retain the above copyright notice, this
		list of conditions and the following disclaimer.

		2. Redistributions in binary form must reproduce the above copyright notice,
		this list of conditions and the following disclaimer in the documentation
		and/or other materials provided with the distribution.

		THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
		AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
		IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
		DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
		FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
		DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
		SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
		CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
		OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
		OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/
package io.droptracker;

import com.google.gson.Gson;
import com.google.inject.Provides;
import java.awt.image.BufferedImage;
import java.io.BufferedReader;
import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.InputStreamReader;
import java.net.URL;
import java.time.LocalDate;
import java.time.format.DateTimeFormatter;
import java.util.*;
import java.util.concurrent.*;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.function.BiConsumer;
import javax.imageio.ImageIO;
import javax.inject.Inject;

import io.droptracker.api.DropTrackerApi;
import io.droptracker.api.FernetDecrypt;
import io.droptracker.models.CustomWebhookBody;
import io.droptracker.ui.DropTrackerPanel;
import io.droptracker.util.ChatMessageEvent;
import io.droptracker.util.KCService;
import io.droptracker.util.WidgetEvent;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.*;
import net.runelite.api.annotations.Component;
import net.runelite.api.events.ChatMessage;
import net.runelite.api.events.GameTick;
import net.runelite.api.events.ScriptPreFired;
import net.runelite.api.events.WidgetLoaded;
import net.runelite.api.widgets.InterfaceID;
import net.runelite.api.widgets.Widget;
import net.runelite.api.widgets.WidgetUtil;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.chat.*;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.events.ConfigChanged;
import net.runelite.client.events.NpcLootReceived;
import net.runelite.client.events.PlayerLootReceived;
import net.runelite.client.game.ItemManager;
import net.runelite.client.game.ItemStack;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.plugins.PluginDescriptor;
import net.runelite.client.plugins.loottracker.LootReceived;
import net.runelite.client.ui.ClientToolbar;
import net.runelite.client.ui.DrawManager;
import net.runelite.client.ui.NavigationButton;
import net.runelite.client.util.ImageCapture;

import static net.runelite.http.api.RuneLiteAPI.GSON;

import net.runelite.client.util.ImageUtil;
import net.runelite.client.util.LinkBrowser;
import net.runelite.client.util.Text;
import net.runelite.http.api.loottracker.LootRecordType;
import okhttp3.*;
import com.google.gson.JsonArray;
import com.google.gson.JsonElement;
import com.google.gson.JsonParser;
import okio.Buffer;

@Slf4j
@PluginDescriptor(
		name = "DropTracker",
		description = "Track your drops, compete in events, and send Discord webhooks!",
		tags = {"droptracker", "drop", "webhook", "events"}
)
public class DropTrackerPlugin extends Plugin {
	@Inject
	private DropTrackerConfig config;
	@Inject
	public static DropTrackerApi api;
	private DropTrackerPanel panel;

	private NavigationButton navButton;

	private NavigationButton newNavButton;

	@Inject
	private Gson gson;
	@Inject
	private ItemManager itemManager;

	@Inject
	private OkHttpClient okHttpClient;

	@Inject
	private ImageCapture imageCapture;

	@Inject
	private OkHttpClient httpClient;
	public static final Set<String> SPECIAL_NPC_NAMES = Set.of("The Whisperer", "Araxxor","Branda the Fire Queen","Eldric the Ice King","Dusk");
	public static final Set<String> LONG_TICK_NPC_NAMES = Set.of("Grotesque Guardians");

	@Inject
	private DrawManager drawManager;
	@Inject
	private ChatCommandManager chatCommandManager;

	@Inject
	private KCService kcService;

	@Inject
	public ChatMessageManager msgManager;
	private final ScheduledExecutorService scheduler = Executors.newScheduledThreadPool(1);
	private String currentKillTime = "";
	private String currentPbTime = "";
	private String currentNpcName = "";
	private boolean readyToSendPb = false;
	private ScheduledFuture<?> skillDataResetTask = null;
	private final Object lock = new Object();
	
	public static List<String> endpointUrls = new ArrayList<>();

	public static List<String> backupUrls = new ArrayList<>();
	
	public static Boolean usingBackups = false;

	private static Boolean isTracking = true;
	public Integer ticksSinceNpcDataUpdate = 0;

	private final ExecutorService executor = Executors.newCachedThreadPool();
	private static final BufferedImage PANEL_ICON = ImageUtil.loadImageResource(DropTrackerPlugin.class, "icon.png");
	private int timesTried = 0;
	@Inject
	public ChatMessageEvent chatMessageEventHandler;

	@Inject
	public WidgetEvent widgetEventHandler;

	@Inject
	private ClientToolbar clientToolbar;

	@Inject
	private Client client;
	@Inject
	private ClientThread clientThread;

	private Integer webhookResetCount = 0;

	// In the event of a 429 response from discord,
	// we'll force the user to wait 10 minutes before sending more webhooks
	// hopefully preventing them from being ip banned by discord
	private int timeToRetry = 0;

	public String pluginVersion = "3.83";

	public static final @Component int PRIVATE_CHAT_WIDGET = WidgetUtil.packComponentId(InterfaceID.PRIVATE_CHAT, 0);

	// Add a future to track loading state
	private CompletableFuture<Void> endpointUrlsLoaded = new CompletableFuture<>();

	@Override
	protected void startUp() {
		api = new DropTrackerApi(config, msgManager, gson, httpClient, client);
		if(config.showSidePanel()) {
			createSidePanel();
		}
		// Preload webhook URLs asynchronously
		executor.submit(this::loadEndpoints);

		chatCommandManager.registerCommandAsync("!droptracker", (chatMessage, s) -> {
			BiConsumer<ChatMessage, String> linkOpener = openLink("discord");
			if (linkOpener != null && chatMessage.getSender().equalsIgnoreCase(client.getLocalPlayer().getName())) {
				linkOpener.accept(chatMessage, s);
			}
		});
		chatCommandManager.registerCommandAsync("!loot", (chatMessage, s) -> {
			BiConsumer<ChatMessage, String> linkOpener = openLink("website");
			if (linkOpener != null && chatMessage.getSender().equalsIgnoreCase(client.getLocalPlayer().getName())) {
				linkOpener.accept(chatMessage, s);
			}
		});
	}
	private void createSidePanel() {
		panel = injector.getInstance(DropTrackerPanel.class);
		panel.init();


		navButton = NavigationButton.builder()
				.tooltip("DropTracker")
				.icon(PANEL_ICON)
				.priority(1)
				.panel(panel)
				.build();


		clientToolbar.addNavigation(navButton);
	}


	// New method to load webhook URLs in the background
	private void loadEndpoints() {
		try {
			if (endpointUrls.isEmpty()) {
				URL url = new URL("https://joelhalen.github.io/docs/crypt.json");
				BufferedReader in = new BufferedReader(new InputStreamReader(url.openStream()));
				StringBuilder response = new StringBuilder();
				String inputLine;
				while ((inputLine = in.readLine()) != null) {
					response.append(inputLine);
				}
				in.close();

				JsonArray jsonArray = new JsonParser().parse(response.toString()).getAsJsonArray();

				for (JsonElement element : jsonArray) {
					try {
						String encrypted = element.getAsString();
						try {
							String decryptedUrl = FernetDecrypt.decryptWebhook(encrypted);
							if (decryptedUrl.contains("discord")) {
								endpointUrls.add(decryptedUrl);
							} else {
								log.error("[DropTracker] Decrypted URL is not based on discord; skipping");
							}
						} catch (Exception e) {
							log.error("Decryption failed with error: " + e.getMessage());
						}
					} catch (Exception e) {
						log.error("Error processing element: " + e.getMessage());
					}
				}
			}
			endpointUrlsLoaded.complete(null);
		} catch (Exception e) {
			endpointUrlsLoaded.completeExceptionally(e);
		} finally {
			log.debug("Successfully loaded webhook URLs from GitHub.");
		}
	}

	/**
	 * Grabs a random webhook URL from a preloaded list.
	 * If not loaded yet, throws or returns null.
	 */
	public String getRandomUrl() throws Exception {
		// Wait for URLs to be loaded, but don't block the main thread
		if (!endpointUrlsLoaded.isDone()) {
			throw new IllegalStateException("Endpoints are not yet loaded; cannot submit...");
		}
		if (endpointUrls.isEmpty()) {
			throw new IllegalStateException("No valid URLs were loaded");
		}
		Random randomP = new Random();
		String randomUrl = endpointUrls.get(randomP.nextInt(endpointUrls.size()));
		return randomUrl;
	}

	public void fetchNewList() throws Exception {
		if (this.webhookResetCount > 10) {
			// At this point we just stop attempting to fetch new webhooks
			// Assuming that something on the backend is broken and they're not replenishing properly
			isTracking = false;
			// isTracking prevents all event processing
			return;
		}
		// Attempt to obtain a new list
		 if (backupUrls.isEmpty()) {
			 LocalDate currentDate = LocalDate.now();

			 // Define formatter for YYYYMMDD pattern
			 DateTimeFormatter formatter = DateTimeFormatter.ofPattern("yyyyMMdd");

			 // Format the date as YYYYMMDD string
			String dateString = currentDate.format(formatter);
			URL url = null;
			 // Print the result
			 if (usingBackups) {
				 url = new URL("https://joelhalen.github.io/docs/crypt.json");
			 } else {
				 url = new URL("https://joelhalen.github.io/docs/" + dateString + ".json");
			 }
			BufferedReader in = new BufferedReader(new InputStreamReader(url.openStream()));
			StringBuilder response = new StringBuilder();
			String inputLine;
			while ((inputLine = in.readLine()) != null) {
				response.append(inputLine);
			}
			in.close();

			JsonArray jsonArray = new JsonParser().parse(response.toString()).getAsJsonArray();

			for (JsonElement element : jsonArray) {
				try {
					String encrypted = element.getAsString();
					try {
						String decryptedUrl = FernetDecrypt.decryptWebhook(encrypted);
						if (decryptedUrl.contains("discord")) {
							backupUrls.add(decryptedUrl);
						} else {
							log.error("[DropTracker] Decrypted URL is not based on discord; skipping");
						}
					} catch (Exception e) {
						log.error("Decryption failed with error: " + e.getMessage());
					}
				} catch (Exception e) {
					log.error("Error processing element: " + e.getMessage());
				}
			}
			if (!backupUrls.isEmpty()) {
				// swap the sets out and clear the back-up set
				endpointUrls = backupUrls;
				sendChatMessage(ChatColorType.HIGHLIGHT +
						"[DropTracker] " +
						ChatColorType.NORMAL +
						"We're currently having some trouble trasmitting your drops to our server...");
				sendChatMessage(ChatColorType.HIGHLIGHT +
						"[DropTracker] " + ChatColorType.NORMAL + "If you continue to see this message appear, please reach out in our Discord server and let us know! (type !droptracker)");

				this.webhookResetCount++;
				// toggle whether the current set of webhooks is from the backup endpoint or the main one
				// incase we need to grab a new set before the client restarts again.
				usingBackups = !usingBackups;
			}

		}

	}

	private static String itemImageUrl(int itemId) {
		return "https://static.runelite.net/cache/item/icon/" + itemId + ".png";
	}

	private BiConsumer<ChatMessage, String> openLink(String destination) {
		HttpUrl webUrl = HttpUrl.parse("https://discord.gg/dvb7yP7JJH");
		if (destination == "website" && config.useApi()) {
			webUrl = HttpUrl.parse(api.getApiUrl());
		}
		HttpUrl.Builder urlBuilder = webUrl.newBuilder();
		HttpUrl url = urlBuilder.build();
		LinkBrowser.browse(url.toString());
		return null;
	}

	@Override
	protected void shutDown() {
		if(navButton != null) {
			clientToolbar.removeNavigation(navButton);
		}
		chatCommandManager.unregisterCommand("!droptracker");
		chatCommandManager.unregisterCommand("!loot");
		if (panel != null) {
			panel.deinit();
			panel = null;
		}
		executor.shutdown();
	}

	@Provides
	DropTrackerConfig provideConfig(ConfigManager configManager) {
		return configManager.getConfig(DropTrackerConfig.class);
	}

	public boolean isFakeWorld() {
		var worldType = client.getWorldType();
		return worldType.contains(WorldType.BETA_WORLD)
				|| worldType.contains(WorldType.DEADMAN)
				|| worldType.contains(WorldType.FRESH_START_WORLD)
				|| worldType.contains(WorldType.LAST_MAN_STANDING)
				|| worldType.contains(WorldType.NOSAVE_MODE)
				|| worldType.contains(WorldType.PVP_ARENA)
				|| worldType.contains(WorldType.QUEST_SPEEDRUNNING)
				|| worldType.contains(WorldType.SEASONAL)
				|| worldType.contains(WorldType.TOURNAMENT_WORLD);
	}

	@Subscribe
	public void onConfigChanged(ConfigChanged configChanged) {
		if (configChanged.getGroup().equalsIgnoreCase(DropTrackerConfig.GROUP)) {
			if (configChanged.getKey().equals("useApi")) {
				panel.deinit();
				
				if(navButton != null) {
					clientToolbar.removeNavigation(navButton);
				}
				createSidePanel();
				// panel.refreshData();
				if (client.getAccountHash() != -1) {
					try {
						api.lookupPlayer(client.getLocalPlayer().getName());
					} catch (Exception e) {
						log.debug("Couldn't look the current player up in the DropTracker database");
					}
				}
			} else if (configChanged.getKey().equals("showSidePanel")) {
				if (!config.showSidePanel()) {
					if(navButton != null) {
						clientToolbar.removeNavigation(navButton);
					}
					panel.deinit();
					panel = null;
				} else {
					if(panel == null) {
						createSidePanel();
					}
				}
			}


			//sendChatReminder();
		}
	}

	@Subscribe
	public void onNpcLootReceived(NpcLootReceived npcLootReceived) {
		if (!isTracking) {
			return;
		}
		NPC npc = npcLootReceived.getNpc();
		Collection<ItemStack> items = npcLootReceived.getItems();
		kcService.onNpcKill(npcLootReceived);
		processDropEvent(npc.getName(), "npc", items);
		//sendChatReminder();
	}

	@Subscribe
	public void onPlayerLootReceived(PlayerLootReceived playerLootReceived) {
		if (!isTracking) {
			return;
		}
		Collection<ItemStack> items = playerLootReceived.getItems();
		processDropEvent(playerLootReceived.getPlayer().getName(), "pvp", items);
		kcService.onPlayerKill(playerLootReceived);
		//sendChatReminder();
	}

	@Subscribe
	public void onLootReceived(LootReceived lootReceived) {
		if (!isTracking) {
			return;
		}
		/* A select few npc loot sources will arrive here, instead of npclootreceived events */
		String npcName = chatMessageEventHandler.getStandardizedSource(lootReceived);

		if (lootReceived.getType() == LootRecordType.NPC && SPECIAL_NPC_NAMES.contains(npcName)) {

			if(npcName.equals("Branda the Fire Queen")|| npcName.equals("Eldric the Ice King")) {
				npcName = "Royal Titans";
			}
			if(npcName.equals("Dusk")){
				npcName = "Grotesque Guardians";
			}
			processDropEvent(npcName, "npc", lootReceived.getItems());
			return;
		}
		if (lootReceived.getType() != LootRecordType.EVENT && lootReceived.getType() != LootRecordType.PICKPOCKET) {
			return;
		}
		processDropEvent(npcName, "other", lootReceived.getItems());
		kcService.onLoot(lootReceived);
		//sendChatReminder();
	}

	public String sanitize(String str) {
		if (str == null || str.isEmpty()) return "";
		return Text.removeTags(str.replace("<br>", "\n")).replace('\u00A0', ' ').trim();
	}

	@Subscribe
	public void onScriptPreFired(ScriptPreFired event) {
		chatMessageEventHandler.onScript(event.getScriptId());
	}

	@Subscribe
	public void onWidgetLoaded(WidgetLoaded widget) {
		widgetEventHandler.onWidgetLoaded(widget);
	}

	@Subscribe(priority = 1)
	public void onChatMessage(ChatMessage message) {
		if (!isTracking) {
			return;
		}
		String chatMessage = sanitize(message.getMessage());
		switch (message.getType()) {
			case GAMEMESSAGE:
				chatMessageEventHandler.onGameMessage(chatMessage);
				chatMessageEventHandler.onChatMessage(chatMessage);
			case FRIENDSCHATNOTIFICATION:
				chatMessageEventHandler.onFriendsChatNotification(chatMessage);
		}
		kcService.onGameMessage(chatMessage);
	}

	@Subscribe
	public void onGameTick(GameTick event) {
		if (!isTracking) {
			return;
		}
		chatMessageEventHandler.onTick();
		widgetEventHandler.onGameTick(event);
	}


	private void scheduleKillTimeReset() {
		if (skillDataResetTask != null) {
			skillDataResetTask.cancel(false);
		}
		skillDataResetTask = scheduler.schedule(this::resetState, 500, TimeUnit.MILLISECONDS);
	}

	private void resetState() {
		synchronized (lock) {
			currentKillTime = "";
			currentPbTime = "";
			currentNpcName = "";
			readyToSendPb = false;
		}
	}

	private void processDropEvent(String npcName, String sourceType, Collection<ItemStack> items) {
		if (!isTracking) {
			return;
		}
		if (LONG_TICK_NPC_NAMES.contains(npcName)){
			ticksSinceNpcDataUpdate -= 30;
		}
		clientThread.invokeLater(() -> {
			// Gather all game state info needed
			List<ItemStack> stackedItems = new ArrayList<>(stack(items));
			String localPlayerName = getLocalPlayerName();
			String accountHash = String.valueOf(client.getAccountHash());
			AtomicInteger totalValue = new AtomicInteger(0);
			List<CustomWebhookBody.Embed> embeds = new ArrayList<>();

			for (ItemStack item : stackedItems) {
				int itemId = item.getId();
				int qty = item.getQuantity();
				int price = itemManager.getItemPrice(itemId);
				ItemComposition itemComposition = itemManager.getItemComposition(itemId);
				totalValue.addAndGet(qty * price);

				CustomWebhookBody.Embed itemEmbed = new CustomWebhookBody.Embed();
				itemEmbed.setImage(itemImageUrl(itemId));
				itemEmbed.addField("type", "drop", true);
				itemEmbed.addField("source_type", sourceType, true);
				itemEmbed.addField("acc_hash", accountHash, true);
				itemEmbed.addField("item", itemComposition.getName(), true);
				itemEmbed.addField("player", localPlayerName, true);
				itemEmbed.addField("id", String.valueOf(itemComposition.getId()), true);
				itemEmbed.addField("quantity", String.valueOf(qty), true);
				itemEmbed.addField("value", String.valueOf(price), true);
				itemEmbed.addField("source", npcName, true);
				itemEmbed.addField("type", sourceType, true);
				itemEmbed.addField("p_v", pluginVersion, true);
				itemEmbed.title = localPlayerName + " received some drops:";
				embeds.add(itemEmbed);
			}

			// Now do the heavy work off the client thread
			int valueToSend = totalValue.get();
			executor.submit(() -> {
				CustomWebhookBody customWebhookBody = new CustomWebhookBody();
				customWebhookBody.getEmbeds().addAll(embeds);
				customWebhookBody.setContent(localPlayerName + " received some drops:");
				if (!customWebhookBody.getEmbeds().isEmpty()) {
					sendDataToDropTracker(customWebhookBody, valueToSend);
				}
			});
		});
	}

	public String getLocalPlayerName() {
		if (client.getLocalPlayer() != null) {
			return client.getLocalPlayer().getName();
		} else {
			return "";
		}
	}
	public void sendDataToDropTracker(CustomWebhookBody webhook, String type) {
		/* Requires a type ID to be passed
		 * "1" = a "Kill Time" or "KC" submission
		 * "2" = a "Collection Log" submission
		 * "3" = a "Combat Achievement" submission
		 *  */
		Boolean requiredScreenshot = false;
		if (type.equalsIgnoreCase("1")) {
			// Kc / kill time
			List<CustomWebhookBody.Embed> embeds = webhook.getEmbeds();
			if(!config.pbEmbeds()){
				return;
			}
			if (config.screenshotPBs()) {
				for (CustomWebhookBody.Embed embed : embeds) {
					for (CustomWebhookBody.Field field : embed.getFields()) {
						if (field.getName().equalsIgnoreCase("is_pb")) {
							if (field.getValue().equalsIgnoreCase("true")) {
								requiredScreenshot = true;
							}
						}
					}
				}
			}

		}
		else if (type.equalsIgnoreCase("2")) {
			if(!config.clogEmbeds()){
				return;
			}
			if (config.screenshotNewClogs()) {
				requiredScreenshot = true;
			}
		} else if(type.equalsIgnoreCase("3")){ // combat achievements
			if(!config.caEmbeds()){
				return;
			}
			if (config.screenshotCAs()) {
				requiredScreenshot = true;
			}
		}

		if (requiredScreenshot) {
			boolean shouldHideDm = config.hideDMs();
			captureScreenshotWithPrivacy(webhook, shouldHideDm);
		} else {
			sendDataToDropTracker(webhook, (byte[]) null);
		}
	}


	public void sendDataToDropTracker(CustomWebhookBody customWebhookBody, int totalValue) {
		// Handles sending drops exclusively
		if(!config.lootEmbeds()){
			return;
		}
		if (config.screenshotDrops() && totalValue > config.screenshotValue()) {
			boolean shouldHideDm = config.hideDMs();
			captureScreenshotWithPrivacy(customWebhookBody, shouldHideDm);
		} else {
			sendDataToDropTracker(customWebhookBody, (byte[]) null);
		}
	}
	private void sendDataToDropTracker(CustomWebhookBody customWebhookBody, byte[] screenshot) {

		if (timeToRetry != 0 && timeToRetry > (int) (System.currentTimeMillis() / 1000)) {
			return;
		} else if (timeToRetry < (int) (System.currentTimeMillis() / 1000)) {
			timeToRetry = 0;
		}
		if (isFakeWorld()) {
			return;
		}
		this.timesTried++;
		MultipartBody.Builder requestBodyBuilder = new MultipartBody.Builder()
				.setType(MultipartBody.FORM)
				.addFormDataPart("payload_json", GSON.toJson(customWebhookBody));

		if (screenshot != null) {
			requestBodyBuilder.addFormDataPart("file", "image.jpeg",
					RequestBody.create(MediaType.parse("image/jpeg"), screenshot));
		}

		MultipartBody requestBody = requestBodyBuilder.build();
		for (MultipartBody.Part part : requestBody.parts()) {
			Headers headers = part.headers();
			if (headers != null) {
				for (int i = 0; i < headers.size(); i++) {
				}
			}

			// Try to read the body content
			RequestBody body = part.body();
			if (body != null) {
				// Safely check content type
				MediaType contentType = body.contentType();
				if (contentType != null && 
						(contentType.toString().contains("text") || 
						 contentType.toString().contains("json"))) {
					Buffer buffer = new Buffer();
					try {
						body.writeTo(buffer);
					} catch (IOException e) {
					}
				} else {
				}
			}
		}
		String url;
		try {
			url = getRandomUrl();
		} catch (Exception e) {
			throw new RuntimeException(e);
		}
		HttpUrl u = HttpUrl.parse(url);
		if (u == null || !isValidDiscordWebhookUrl(u)) {
			log.debug("Invalid or malformed webhook URL: {}", url);
			return;
		}
		Request request = new Request.Builder()
				.url(url)
				.post(requestBody)
				.build();
		okHttpClient.newCall(request).enqueue(new Callback() {
			@Override
			public void onFailure(Call call, IOException e) {
				log.error("Error submitting: ", e);
				timesTried = 0;
			}

			@Override
			public void onResponse(Call call, Response response) throws IOException {

				if (response.isSuccessful()) {
					timesTried = 0;
				} else if (response.code() == 429) {
					timeToRetry = (int) (System.currentTimeMillis() / 1000) + 600;
					sendDataToDropTracker(customWebhookBody, screenshot);

				} else if (response.code() == 400) {

					response.close();
					return;

				} else if(response.code() == 404){
					// On the first 404 error, we'll populate the list with new ones.
					executor.submit(() -> {
						try {
							fetchNewList();
						} catch (Exception e) {
							log.error("Failed to fetch new webhook list", e);
						}
					});
					sendDataToDropTracker(customWebhookBody, screenshot);

				} else {
					sendDataToDropTracker(customWebhookBody, screenshot);
				}
				response.close();
			}
		});

	}
	
	private boolean isValidDiscordWebhookUrl(HttpUrl url) {
		// Ensure that any webhook URLs returned from the GitHub page are actual Discord webhooks
		// And not external connections of some sort
		if (!"discord.com".equals(url.host()) && !url.host().endsWith(".discord.com")) {
			if(!"discordapp.com".equals(url.host()) && !url.host().endsWith(".discordapp.com")){
				return false;
			}
		}
		List<String> segments = url.pathSegments();
		if (segments.size() >= 4 && "api".equals(segments.get(0)) && "webhooks".equals(segments.get(1))) {
			return true;
		}
		return false;
	}
	private static byte[] convertImageToByteArray(BufferedImage bufferedImage) throws IOException {
		ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();
		ImageIO.write(bufferedImage, "jpeg", byteArrayOutputStream);
		return byteArrayOutputStream.toByteArray();
	}
	public static void modWidget(boolean shouldHide, Client client, ClientThread clientThread, @Component int info) {
		clientThread.invoke(() -> {
			Widget widget = client.getWidget(info);
			if (widget != null) {
				widget.setHidden(shouldHide);
			}
		});
	}
	private static Collection<ItemStack> stack(Collection<ItemStack> items) {
		final List<ItemStack> list = new ArrayList<>();

		for (final ItemStack item : items) {
			int quantity = 0;
			for (final ItemStack i : list) {
				if (i.getId() == item.getId()) {
					quantity = i.getQuantity();
					list.remove(i);
					break;
				}
			}
			if (quantity > 0) {
				list.add(new ItemStack(item.getId(), item.getQuantity() + quantity, item.getLocation()));
			} else {
				list.add(item);
			}
		}

		return list;
	}

	public void sendChatMessage(String messageContent) {
		client.addChatMessage(ChatMessageType.GAMEMESSAGE, messageContent, messageContent, "DropTracker.io");
	}

	private void captureScreenshotWithPrivacy(CustomWebhookBody webhook, boolean hideDMs) {
		// First hide DMs if configured
		modWidget(hideDMs, client, clientThread, PRIVATE_CHAT_WIDGET);

		drawManager.requestNextFrameListener(image -> {
			BufferedImage bufferedImage = (BufferedImage) image;

			// Restore DM visibility immediately after capturing
			modWidget(false, client, clientThread, PRIVATE_CHAT_WIDGET);

			byte[] imageBytes = null;
			try {
				imageBytes = convertImageToByteArray(bufferedImage);
				if (imageBytes.length > 5 * 1024 * 1024) {
					// perform compression here
				}
			} catch (IOException e) {
				log.error("Error converting image to byte array", e);
			}
			sendDataToDropTracker(webhook, imageBytes);
		});
	}
}

package io.droptracker;

import io.droptracker.DropTrackerPlugin;
import net.runelite.client.RuneLite;
import net.runelite.client.externalplugins.ExternalPluginManager;

public class DropTrackerPluginTest
{
	public static void main(String[] args) throws Exception
	{
		ExternalPluginManager.loadBuiltin(DropTrackerPlugin.class);
		RuneLite.main(args);
	}
}
