package com.afkcrabhelper;

import com.google.inject.Provides;
import javax.inject.Inject;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Actor;
import net.runelite.api.ChatMessageType;
import net.runelite.api.Client;
import net.runelite.api.NPC;
import net.runelite.api.events.ChatMessage;
import net.runelite.api.events.GameTick;
import net.runelite.api.events.InteractingChanged;
import net.runelite.api.events.NpcDespawned;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.plugins.PluginDescriptor;
import net.runelite.client.ui.overlay.OverlayManager;

@Slf4j
@PluginDescriptor(
    name = "AFK Crab Helper",
    description = "Gemstone Crab AFK timer overlay shows time remaining until crab dies. Also supports Sand Crabs, Rock Crabs, and Ammonite Crabs with HP percentage display and flash alerts",
    tags = {"afk", "crab", "training", "overlay", "distraction", "gemstone", "sand", "rock", "ammonite"}
)
public class AfkCrabHelperPlugin extends Plugin
{
    @Inject
    private Client client;

    @Inject
    private AfkCrabHelperConfig config;

    @Inject
    private OverlayManager overlayManager;

    @Inject
    private AfkCrabHelperOverlay overlay;

    private boolean isInteractingWithCrab = false;
    private long lastCrabInteraction = 0;
    private long overlayStartTime = 0;
    
    // Crab tracking variables
    private NPC currentCrab = null;
    private long timerStartTime = 0;
    private double initialTimeMinutes = 0.0;

    @Override
    protected void startUp() throws Exception
    {
        overlayManager.add(overlay);
        log.info("AFK Crab Helper started!");
    }

    @Override
    protected void shutDown() throws Exception
    {
        overlayManager.remove(overlay);
        isInteractingWithCrab = false;
        log.info("AFK Crab Helper stopped!");
    }

    @Subscribe
    public void onGameTick(GameTick gameTick)
    {
        if (client.getLocalPlayer() == null)
        {
            return;
        }

        checkCrabInteraction();
        checkCrabStatus();
    }

    private void checkCrabInteraction()
    {
        Actor target = client.getLocalPlayer().getInteracting();
        boolean currentlyInteractingWithCrab = false;
        NPC targetCrab = null;

        if (target instanceof NPC)
        {
            NPC npc = (NPC) target;
            String npcName = npc.getName();
            
            if (npcName != null && isCrabNpc(npcName))
            {
                currentlyInteractingWithCrab = true;
                lastCrabInteraction = System.currentTimeMillis();
                targetCrab = npc;
                
                // If this is a new crab or we weren't tracking before, update tracking
                if (currentCrab != npc)
                {
                    currentCrab = npc;
                    // Start countdown timer
                    timerStartTime = System.currentTimeMillis();
                    // Calculate initial time based on health%
                    int healthRatio = Math.max(0, npc.getHealthRatio());
                    int healthScale = Math.max(1, npc.getHealthScale());
                    double healthPercent = (double) healthRatio / healthScale * 100.0;
                    initialTimeMinutes = healthPercent / 10.0;
                }
            }
        }

        // Check if we recently interacted with a crab (within hide delay period)
        long timeSinceLastInteraction = System.currentTimeMillis() - lastCrabInteraction;
        if (timeSinceLastInteraction <= config.hideDelay() * 1000)
        {
            currentlyInteractingWithCrab = true;
        }
        
        // Also check if we have a valid crab target and are still actively interacting
        // Only keep overlay up if we're actually still targeting the crab
        if (currentCrab != null && client.getNpcs().contains(currentCrab) && target == currentCrab)
        {
            currentlyInteractingWithCrab = true;
        }

        // Handle activation delay for overlay
        if (currentlyInteractingWithCrab && !isInteractingWithCrab)
        {
            // Starting interaction - set overlay start time
            overlayStartTime = System.currentTimeMillis();
        }
        else if (!currentlyInteractingWithCrab && isInteractingWithCrab)
        {
            // Stopping interaction - reset crab tracking
            currentCrab = null;
            timerStartTime = 0;
            initialTimeMinutes = 0.0;
        }
        
        // Update overlay start time if we don't have one but should be showing
        if (currentlyInteractingWithCrab && overlayStartTime == 0)
        {
            overlayStartTime = System.currentTimeMillis();
        }

        isInteractingWithCrab = currentlyInteractingWithCrab;
    }
    
    private void checkCrabStatus()
    {
        // Check if our tracked crab is still valid
        if (currentCrab != null)
        {
            // Check if crab is no longer valid (burrowed or moved away)
            if (!client.getNpcs().contains(currentCrab))
            {
                // Reset tracking
                isInteractingWithCrab = false;
                currentCrab = null;
                timerStartTime = 0;
                initialTimeMinutes = 0.0;
            }
        }
    }

    private boolean isCrabNpc(String npcName)
    {
        if (npcName == null) return false;
        String lowerName = npcName.toLowerCase();
        return lowerName.equals("sand crab") ||
               lowerName.equals("rock crab") ||
               lowerName.equals("ammonite crab") ||
               lowerName.equals("gemstone crab");
    }
    
    private boolean isGemstoneCrab(String npcName)
    {
        return npcName != null && npcName.toLowerCase().equals("gemstone crab");
    }
    
    @Subscribe
    public void onInteractingChanged(InteractingChanged event)
    {
        // Track when player starts interacting with something new
        if (event.getSource() == client.getLocalPlayer())
        {
            Actor newTarget = event.getTarget();
            if (newTarget instanceof NPC)
            {
                NPC npc = (NPC) newTarget;
                if (isCrabNpc(npc.getName()))
                {
                    // Starting to interact with a crab
                    lastCrabInteraction = System.currentTimeMillis();
                }
            }
        }
    }
    
    @Subscribe
    public void onNpcDespawned(NpcDespawned event)
    {
        NPC npc = event.getNpc();
        
        // Check if it's our current crab that despawned
        if (npc == currentCrab)
        {
            // Crab despawned - stop overlay immediately
            isInteractingWithCrab = false;
            currentCrab = null;
            timerStartTime = 0;
            initialTimeMinutes = 0.0;
        }
    }
    
    

    public boolean isShowingOverlay()
    {
        if (!isInteractingWithCrab)
        {
            return false;
        }
        
        // Check activation delay
        long timeSinceOverlayStart = System.currentTimeMillis() - overlayStartTime;
        return timeSinceOverlayStart >= config.activationDelay() * 1000;
    }
    
    public String getDisplayText()
    {
        if (currentCrab == null)
        {
            return null;
        }
        
        // Check if this is a Gemstone Crab
        boolean isGemstone = isGemstoneCrab(currentCrab.getName());
        
        // Get crab health info
        int healthRatio = Math.max(0, currentCrab.getHealthRatio());
        int healthScale = Math.max(1, currentCrab.getHealthScale());
        double healthPercent = (double) healthRatio / healthScale * 100.0;
        
        // Only show "Crab dead" for Gemstone Crabs
        if (healthPercent <= 0 && isGemstone)
        {
            return "Crab dead";
        }
        
        // For non-Gemstone crabs, only show black screen with no text when dead
        if (healthPercent <= 0 && !isGemstone)
        {
            return null;
        }
        
        // Only show health/time info for Gemstone Crabs
        if (!isGemstone)
        {
            return null;
        }
        
        AfkCrabHelperConfig.DisplayMode mode = config.displayMode();
        
        switch (mode)
        {
            case HP_PERCENTAGE:
                return String.format("%.1f%% HP", healthPercent);
                
            case TIME_REMAINING:
                // Use countdown timer if we have one, otherwise calculate from health%
                double minutes;
                if (timerStartTime > 0) {
                    // Calculate remaining time from countdown
                    long elapsedMs = System.currentTimeMillis() - timerStartTime;
                    double elapsedMinutes = elapsedMs / 1000.0 / 60.0;
                    minutes = Math.max(0, initialTimeMinutes - elapsedMinutes);
                } else {
                    // Fallback to health% calculation
                    minutes = healthPercent / 10.0;
                }
                
                if (minutes < 1.0) {
                    return String.format("%.0f seconds", minutes * 60);
                } else {
                    int mins = (int) minutes;
                    int secs = (int) ((minutes - mins) * 60);
                    return String.format("%d:%02d remaining", mins, secs);
                }
                
            case BOTH:
                // Use countdown timer if we have one, otherwise calculate from health%
                double mins;
                if (timerStartTime > 0) {
                    // Calculate remaining time from countdown
                    long elapsedMs = System.currentTimeMillis() - timerStartTime;
                    double elapsedMinutes = elapsedMs / 1000.0 / 60.0;
                    mins = Math.max(0, initialTimeMinutes - elapsedMinutes);
                } else {
                    // Fallback to health% calculation
                    mins = healthPercent / 10.0;
                }
                
                String timeStr;
                if (mins < 1.0) {
                    timeStr = String.format("%.0fs", mins * 60);
                } else {
                    int m = (int) mins;
                    int s = (int) ((mins - m) * 60);
                    timeStr = String.format("%d:%02d", m, s);
                }
                return String.format("%.1f%% HP | %s", healthPercent, timeStr);
                
            default:
                return null;
        }
    }
    
    public boolean shouldFlash()
    {
        if (!config.enableFlash() || currentCrab == null)
        {
            return false;
        }
        
        // Only flash for Gemstone Crabs
        if (!isGemstoneCrab(currentCrab.getName()))
        {
            return false;
        }
        
        int healthRatio = Math.max(0, currentCrab.getHealthRatio());
        int healthScale = Math.max(1, currentCrab.getHealthScale());
        double healthPercent = (double) healthRatio / healthScale * 100.0;
        
        return healthPercent <= config.flashThreshold();
    }
    
    public NPC getCurrentCrab()
    {
        return currentCrab;
    }

    @Provides
    AfkCrabHelperConfig provideConfig(ConfigManager configManager)
    {
        return configManager.getConfig(AfkCrabHelperConfig.class);
    }
}
package com.afkcrabhelper;

import java.awt.Color;
import net.runelite.client.config.Config;
import net.runelite.client.config.ConfigGroup;
import net.runelite.client.config.ConfigItem;
import net.runelite.client.config.ConfigSection;
import net.runelite.client.config.Range;

@ConfigGroup("afkcrabhelper")
public interface AfkCrabHelperConfig extends Config
{
    @ConfigSection(
        name = "Display",
        description = "Configure what information to display",
        position = 0
    )
    String displaySection = "display";

    @ConfigSection(
        name = "Appearance",
        description = "Configure overlay appearance",
        position = 1
    )
    String appearanceSection = "appearance";

    @ConfigSection(
        name = "Flash Alert",
        description = "Configure low HP flash alert",
        position = 2
    )
    String flashSection = "flash";

    @ConfigSection(
        name = "Timing",
        description = "Configure overlay timing",
        position = 3
    )
    String timingSection = "timing";

    @ConfigItem(
        keyName = "displayMode",
        name = "Display Mode",
        description = "What information to display in the overlay",
        section = displaySection,
        position = 0
    )
    default DisplayMode displayMode()
    {
        return DisplayMode.TIME_REMAINING;
    }

    @ConfigItem(
        keyName = "overlayColor",
        name = "Overlay Color",
        description = "Color of the distraction overlay",
        section = appearanceSection,
        position = 0
    )
    default Color overlayColor()
    {
        return Color.BLACK;
    }

    @ConfigItem(
        keyName = "overlayOpacity",
        name = "Overlay Opacity",
        description = "Opacity of the distraction overlay (0-255)",
        section = appearanceSection,
        position = 1
    )
    @Range(min = 0, max = 255)
    default int overlayOpacity()
    {
        return 200;
    }

    @ConfigItem(
        keyName = "enableFlash",
        name = "Enable Low HP Flash",
        description = "Flash the text when crab HP is below threshold",
        section = flashSection,
        position = 0
    )
    default boolean enableFlash()
    {
        return true;
    }

    @ConfigItem(
        keyName = "flashThreshold",
        name = "Flash Threshold %",
        description = "Start flashing when crab HP% falls below this value",
        section = flashSection,
        position = 1
    )
    @Range(min = 1, max = 50)
    default int flashThreshold()
    {
        return 2;
    }

    @ConfigItem(
        keyName = "flashColor",
        name = "Flash Color",
        description = "Color to flash when HP is low",
        section = flashSection,
        position = 2
    )
    default Color flashColor()
    {
        return Color.YELLOW;
    }

    @ConfigItem(
        keyName = "activationDelay",
        name = "Activation Delay",
        description = "Seconds to wait before showing overlay after crab interaction starts",
        section = timingSection,
        position = 0
    )
    @Range(min = 0, max = 30)
    default int activationDelay()
    {
        return 0;
    }

    @ConfigItem(
        keyName = "hideDelay",
        name = "Hide Delay",
        description = "Seconds to wait before hiding overlay after crab interaction stops",
        section = timingSection,
        position = 1
    )
    @Range(min = 0, max = 30)
    default int hideDelay()
    {
        return 0;
    }

    enum DisplayMode
    {
        TIME_REMAINING("Time Remaining"),
        HP_PERCENTAGE("HP Percentage"),
        BOTH("Both");

        private final String name;

        DisplayMode(String name)
        {
            this.name = name;
        }

        @Override
        public String toString()
        {
            return name;
        }
    }
}
package com.afkcrabhelper;

import java.awt.Color;
import java.awt.Dimension;
import java.awt.Font;
import java.awt.FontMetrics;
import java.awt.Graphics2D;
import java.awt.RenderingHints;
import java.time.Duration;
import java.time.Instant;
import javax.inject.Inject;
import net.runelite.api.Actor;
import net.runelite.api.Client;
import net.runelite.api.NPC;
import net.runelite.client.ui.overlay.Overlay;
import net.runelite.client.ui.overlay.OverlayLayer;
import net.runelite.client.ui.overlay.OverlayPosition;
import net.runelite.client.ui.overlay.OverlayPriority;

public class AfkCrabHelperOverlay extends Overlay
{
    private final Client client;
    private final AfkCrabHelperPlugin plugin;
    private final AfkCrabHelperConfig config;
    private Instant trainingStartTime;

    @Inject
    public AfkCrabHelperOverlay(Client client, AfkCrabHelperPlugin plugin, AfkCrabHelperConfig config)
    {
        this.client = client;
        this.plugin = plugin;
        this.config = config;
        setPosition(OverlayPosition.DETACHED);
        setLayer(OverlayLayer.ALWAYS_ON_TOP);
        setPriority(OverlayPriority.HIGH);
    }

    @Override
    public Dimension render(Graphics2D graphics)
    {
        if (!plugin.isShowingOverlay())
        {
            trainingStartTime = null;
            return null;
        }

        // Initialize training start time
        if (trainingStartTime == null)
        {
            trainingStartTime = Instant.now();
        }

        // Create overlay color with configured opacity
        Color overlayColor = config.overlayColor();
        Color transparentColor = new Color(
            overlayColor.getRed(),
            overlayColor.getGreen(), 
            overlayColor.getBlue(),
            config.overlayOpacity()
        );
        
        // Fill the entire screen with overlay (using a large size to ensure full coverage)
        graphics.setColor(transparentColor);
        graphics.fillRect(0, 0, 2560, 1440);

        // Render display text in center
        renderDisplayText(graphics);

        return new Dimension(2560, 1440);
    }

    private void renderDisplayText(Graphics2D graphics)
    {
        String displayText = plugin.getDisplayText();
        if (displayText == null)
        {
            return;
        }

        // Enable anti-aliasing for smooth text
        graphics.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);
        graphics.setRenderingHint(RenderingHints.KEY_TEXT_ANTIALIASING, RenderingHints.VALUE_TEXT_ANTIALIAS_ON);

        // Set large font
        Font font = new Font(Font.SANS_SERIF, Font.BOLD, 36);
        graphics.setFont(font);
        FontMetrics metrics = graphics.getFontMetrics(font);

        // Get the game canvas dimensions for proper centering
        int canvasWidth = client.getCanvasWidth();
        int canvasHeight = client.getCanvasHeight();
        
        // Calculate center position based on game canvas
        int textWidth = metrics.stringWidth(displayText);
        int x = (canvasWidth - textWidth) / 2;
        int y = canvasHeight / 2;

        // Draw shadow (slightly offset)
        graphics.setColor(Color.BLACK);
        graphics.drawString(displayText, x + 2, y + 2);

        // Determine text color - flash if needed
        Color textColor = Color.WHITE;
        if (plugin.shouldFlash())
        {
            // Flash between normal color and flash color based on time
            long currentTime = System.currentTimeMillis();
            boolean flashState = (currentTime / 500) % 2 == 0; // Flash every 500ms
            textColor = flashState ? config.flashColor() : Color.WHITE;
        }
        
        // Draw main text
        graphics.setColor(textColor);
        graphics.drawString(displayText, x, y);
    }

}
