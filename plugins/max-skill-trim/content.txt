package com.maxskilltrim;

import net.runelite.client.config.Config;
import net.runelite.client.config.ConfigGroup;
import net.runelite.client.config.ConfigItem;

@ConfigGroup(MaxSkillTrimConfig.GROUP_NAME)
public interface MaxSkillTrimConfig extends Config
{
    String GROUP_NAME = "maxskilltrim";
    String SHOW_MAX_LEVEL_TRIM = "showMaxLevelTrim";
    String SELECTED_MAX_LEVEL_TRIM = "selectedMaxLevelTrim";
    String SHOW_MAX_EXPERIENCE_TRIM = "showMaxExperienceTrim";
    String SELECTED_MAX_EXPERIENCE_TRIM = "selectedMaxExperienceTrim";
    String SHOW_NAV_BUTTON = "showNavButton";

    @ConfigItem(
            keyName = SHOW_MAX_LEVEL_TRIM,
            name = "Show trims on level 99 skills?",
            description = "Toggles whether or not show skill trims on level 99 skills"
    )
    default boolean showMaxLevelTrim() { return true; }

    @ConfigItem(
            keyName = SELECTED_MAX_LEVEL_TRIM,
            name = "Selected max skill trim",
            description = "Name of the selected max skill trim",
            hidden = true
    )
    default String getSelectedMaxLevelTrimFilename()
    {
        return "full-trim.png";
    }

    @ConfigItem(
            keyName = SHOW_MAX_EXPERIENCE_TRIM,
            name = "Show trims on 200m skills?",
            description = "Toggles whether or not show skill trims on 200m skills"
    )
    default boolean getShowMaxExperienceTrim() { return true; }

    @ConfigItem(
            keyName = SELECTED_MAX_EXPERIENCE_TRIM,
            name = "Selected max skill trim",
            description = "Name of the selected max skill trim",
            hidden = true
    )
    default String getSelectedMaxExperienceTrimFilename()
    {
        return "full-trim.png";
    }

    @ConfigItem(
            keyName = SHOW_NAV_BUTTON,
            name = "Show navigation button in sidebar?",
            description = "Toggles whether or not show the navigation button (icon) in the Runelite sidebar"
    )
    default boolean getShowNavButton() { return true; }
}

package com.maxskilltrim;

import lombok.extern.slf4j.Slf4j;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.PluginPanel;
import net.runelite.client.util.LinkBrowser;

import javax.inject.Inject;
import javax.inject.Named;
import javax.inject.Singleton;
import javax.swing.*;
import java.awt.*;
import java.awt.event.ItemEvent;
import java.io.File;
import java.util.Objects;

@Slf4j
@Singleton
public class MaxSkillTrimPanel extends PluginPanel
{
    @Inject
    ConfigManager configManager;

    @Inject
    public MaxSkillTrimPanel(MaxSkillTrimConfig config, MaxSkillTrimPlugin plugin, @Named("developerMode") boolean developerMode)
    {
        JPanel container = new JPanel();
        container.setBackground(ColorScheme.DARK_GRAY_COLOR);
        GridBagLayout layout = new GridBagLayout();
        GridBagConstraints constraints = new GridBagConstraints();
        constraints.anchor = GridBagConstraints.LINE_START;
        constraints.insets = new Insets(3, 3, 3, 3);
        container.setLayout(layout);

        JComboBox<String> maxLevelComboBox = buildComboBoxPanel(MaxSkillTrimConfig.SELECTED_MAX_LEVEL_TRIM, config.getSelectedMaxLevelTrimFilename());
        JComboBox<String> maxExperienceComboBox = buildComboBoxPanel(MaxSkillTrimConfig.SELECTED_MAX_EXPERIENCE_TRIM, config.getSelectedMaxExperienceTrimFilename());

        JButton openFolderButton = new JButton("Open Folder");
        openFolderButton.addActionListener(e ->
        {
            try
            {
                Desktop.getDesktop().open(MaxSkillTrimPlugin.MAXSKILLTRIMS_DIR);
            }
            catch (Exception ex)
            {
                log.warn(null, ex);
            }
        });
        constraints.gridx = 0;
        constraints.gridy = 0;
        container.add(openFolderButton, constraints);

        JButton refreshButton = new JButton("Refresh");
        refreshButton.addActionListener((ev) -> {
            refreshComboBoxOptions(maxLevelComboBox);
            refreshComboBoxOptions(maxExperienceComboBox);
        });
        constraints.gridx = 1;
        constraints.gridy = 0;
        container.add(refreshButton, constraints);

        JButton getMoreTrimsButton = new JButton("Get more trims!");
        getMoreTrimsButton.addActionListener((e) -> LinkBrowser.browse("https://github.com/Nerdpuff/max-skill-trim/tree/custom-trims"));
        constraints.gridx = 0;
        constraints.gridy = 1;
        constraints.gridwidth = GridBagConstraints.REMAINDER;
        constraints.fill = GridBagConstraints.HORIZONTAL;
        container.add(getMoreTrimsButton, constraints);

        JLabel maxLevelTrimLabel = new JLabel("Max level trim");
        constraints.gridx = 0;
        constraints.gridy = 2;
        constraints.gridwidth = GridBagConstraints.REMAINDER;
        constraints.fill = GridBagConstraints.HORIZONTAL;
        container.add(maxLevelTrimLabel, constraints);

        constraints.gridx = 0;
        constraints.gridy = 3;
        constraints.gridwidth = GridBagConstraints.REMAINDER;
        constraints.fill = GridBagConstraints.HORIZONTAL;
        container.add(maxLevelComboBox, constraints);

        JLabel maxExperienceTrimLabel = new JLabel("Max experience trim");
        constraints.gridx = 0;
        constraints.gridy = 4;
        constraints.gridwidth = GridBagConstraints.REMAINDER;
        constraints.fill = GridBagConstraints.HORIZONTAL;
        container.add(maxExperienceTrimLabel, constraints);

        constraints.gridx = 0;
        constraints.gridy = 5;
        constraints.gridwidth = GridBagConstraints.REMAINDER;
        constraints.fill = GridBagConstraints.HORIZONTAL;
        container.add(maxExperienceComboBox, constraints);

        if (developerMode) addDeveloperSection(plugin, container);

        add(container);
    }

    private static void addDeveloperSection(MaxSkillTrimPlugin plugin, JPanel container) {
        JPanel devPanel = new JPanel();
        devPanel.setLayout(new BoxLayout(devPanel, BoxLayout.Y_AXIS));
        devPanel.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        devPanel.setBorder(BorderFactory.createTitledBorder("Developer Tools"));

        JPanel developerPanel = new JPanel(new GridBagLayout());

        GridBagConstraints buttonConstraints = new GridBagConstraints();
        JCheckBox enableOverridesCheckbox = new JCheckBox("Enable Overrides");
        enableOverridesCheckbox.addActionListener(e -> plugin.setMockOverridesEnabled(enableOverridesCheckbox.isSelected()));
        buttonConstraints.gridx = 0;
        buttonConstraints.gridy = 0;
        buttonConstraints.gridwidth = GridBagConstraints.REMAINDER;
        buttonConstraints.anchor = GridBagConstraints.LINE_START;
        developerPanel.add(enableOverridesCheckbox, buttonConstraints);

        GridBagConstraints skillConstraints = new GridBagConstraints();
        skillConstraints.insets = new Insets(2, 2, 2, 2);
        skillConstraints.anchor = GridBagConstraints.LINE_START;
        skillConstraints.fill = GridBagConstraints.HORIZONTAL;

        SkillData[] skills = SkillData.values();
        for (int i = 0; i < skills.length; i++) {
            SkillData skill = skills[i];
            skillConstraints.gridx = 0;
            skillConstraints.gridy = i + 1;
            developerPanel.add(new JLabel(skill.name()), skillConstraints);

            // Max Level checkbox
            skillConstraints.gridx = 1;
            JCheckBox maxLevelToggle = new JCheckBox("ML");
            maxLevelToggle.addActionListener(e -> plugin.setMockTrimState(skill, maxLevelToggle.isSelected(), TrimType.MAX_LEVEL));
            developerPanel.add(maxLevelToggle, skillConstraints);

            // Max Experience checkbox
            skillConstraints.gridx = 2;
            JCheckBox maxExpToggle = new JCheckBox("ME");
            maxExpToggle.addActionListener(e -> plugin.setMockTrimState(skill, maxExpToggle.isSelected(), TrimType.MAX_EXPERIENCE));
            developerPanel.add(maxExpToggle, skillConstraints);
        }

        JScrollPane scrollPane = new JScrollPane(developerPanel);
        scrollPane.setPreferredSize(new Dimension(220, 400));
        scrollPane.setBorder(null);
        devPanel.add(scrollPane);

        GridBagConstraints devConstraints = new GridBagConstraints();
        devConstraints.gridx = 0;
        devConstraints.gridy = 6;
        devConstraints.gridwidth = GridBagConstraints.REMAINDER;
        devConstraints.fill = GridBagConstraints.BOTH;
        devConstraints.weightx = 1.0;
        devConstraints.weighty = 1.0;
        container.add(devPanel, devConstraints);
    }

    private JComboBox<String> buildComboBoxPanel(String selectedTrimConfigKey, String selectedFilename) {
        JComboBox<String> comboBox = new JComboBox<>();

        // Forces long item names to not cause the JPanel to overflow.
        comboBox.setPrototypeDisplayValue("");

        refreshComboBoxOptions(comboBox);

        comboBox.addItemListener((e) -> {
            if (e.getStateChange() == ItemEvent.SELECTED && configManager != null)
            {
                configManager.setConfiguration(MaxSkillTrimConfig.GROUP_NAME, selectedTrimConfigKey, e.getItem());
            }
        });

        comboBox.setSelectedItem(selectedFilename);

        return comboBox;
    }

    private void refreshComboBoxOptions(JComboBox<String> comboBox)
    {
        Object selectedItem = comboBox.getSelectedItem();
        comboBox.removeAllItems();

        for (File f : Objects.requireNonNull(MaxSkillTrimPlugin.MAXSKILLTRIMS_DIR.listFiles()))
        {
            comboBox.addItem(f.getName());
        }

        comboBox.setSelectedItem(selectedItem);
    }
}

package com.maxskilltrim;

import javax.imageio.ImageIO;
import javax.inject.Inject;
import com.google.inject.Provides;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.*;
import net.runelite.api.events.*;
import net.runelite.api.gameval.InterfaceID;
import net.runelite.api.widgets.*;
import net.runelite.client.RuneLite;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.events.ConfigChanged;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.plugins.PluginDescriptor;
import net.runelite.client.ui.ClientToolbar;
import net.runelite.client.ui.NavigationButton;
import net.runelite.client.util.ImageUtil;
import java.awt.image.BufferedImage;
import java.io.File;
import java.io.IOException;
import java.lang.management.ManagementFactory;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.nio.file.StandardCopyOption;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Objects;
import java.util.stream.Stream;

@Slf4j
@PluginDescriptor(
        name = "Max Skill Trim"
)
public class MaxSkillTrimPlugin extends Plugin
{
    private static final Trim maxLevelTrim = new Trim(-432432, TrimType.MAX_LEVEL);
    private static final Trim maxExperienceTrim = new Trim(-432433, TrimType.MAX_EXPERIENCE);
    @Inject
    private MaxSkillTrimConfig maxSkillTrimConfig;
    private NavigationButton navButton;
    @Inject
    private ClientToolbar pluginToolbar;
    public static final File MAXSKILLTRIMS_DIR = new File(RuneLite.RUNELITE_DIR.getPath(), "max-skill-trims");
    private static final int SCRIPTID_STATS_INIT = 393;
    private static final int SCRIPTID_STATS_REFRESH = 394;
    @Inject
    private Client client;
    @Inject
    private ClientThread clientThread;
    private Widget currentWidget;

    private boolean mockOverridesEnabled = false;

    public void setMockOverridesEnabled(boolean enabled) {
        this.mockOverridesEnabled = enabled;
        clientThread.invokeLater(this::updateTrims);
    }

    private final HashMap<String, MaxSkillTrimWidget> maxSkillTrimWidgetHashMap = new HashMap<>();

    private final List<Skill> skillsInLastRow = new ArrayList<Skill>(3) {
        {
            add(Skill.CONSTRUCTION);
            add(Skill.SAILING);
            add(Skill.HUNTER);
        }
    };

    @Provides
    MaxSkillTrimConfig provideConfig(ConfigManager configManager)
    {
        return configManager.getConfig(MaxSkillTrimConfig.class);
    }

    @Override
    protected void startUp() throws Exception
    {
        if (!MAXSKILLTRIMS_DIR.exists())
        {
            MAXSKILLTRIMS_DIR.mkdirs();
        }

        addDefaultTrims();

        MaxSkillTrimPanel maxSkillTrimPanel = injector.getInstance(MaxSkillTrimPanel.class);

        BufferedImage icon;
        synchronized (ImageIO.class)
        {
            icon = ImageIO.read(Objects.requireNonNull(getClass().getResourceAsStream("/icon.png")));
        }

        navButton = NavigationButton.builder()
                .tooltip("Max Skill Trim")
                .priority(5)
                .icon(icon)
                .panel(maxSkillTrimPanel)
                .build();

        if(maxSkillTrimConfig.getShowNavButton()) {
            pluginToolbar.addNavigation(navButton);
        }

        overrideSprites(maxLevelTrim, maxSkillTrimConfig.getSelectedMaxLevelTrimFilename());
        overrideSprites(maxExperienceTrim, maxSkillTrimConfig.getSelectedMaxExperienceTrimFilename());

        if (client.getGameState() == GameState.LOGGED_IN) {
            clientThread.invoke(this::buildTrimWidgetContainers);
        }
    }

    @Override
    protected void shutDown() throws Exception
    {
        pluginToolbar.removeNavigation(navButton);
        clientThread.invoke(() -> {
            removeTrimWidgetContainers(maxSkillTrimWidgetHashMap);
        });
    }

    @Subscribe
    public void onScriptPreFired(ScriptPreFired event) {
        if (event.getScriptId() == SCRIPTID_STATS_INIT || event.getScriptId() == SCRIPTID_STATS_REFRESH) {
            Widget widget = event.getScriptEvent().getSource();

            currentWidget = widget.getId() == InterfaceID.Stats.UNIVERSE ? null : widget;
        }
    }

    @Subscribe
    public void onScriptPostFired(ScriptPostFired event) {
        if ((event.getScriptId() == SCRIPTID_STATS_INIT || event.getScriptId() == SCRIPTID_STATS_REFRESH) && currentWidget != null) {
            buildTrim(currentWidget);
        }
    }

    private void buildTrimWidgetContainers() {
        Widget skillsContainer = client.getWidget(InterfaceID.Stats.UNIVERSE);
        if (skillsContainer == null) return;

        for (Widget skillTile : skillsContainer.getStaticChildren()) {
            buildTrim(skillTile);
        }
    }

    private void removeTrimWidgetContainers(HashMap<String, MaxSkillTrimWidget> trims) {
        maxSkillTrimWidgetHashMap.values().removeIf(trim -> {
            if(trim.widget != null) {
                Widget[] children = trim.widget.getParent().getChildren();

                if(children == null) {
                    return true;
                }

                for (int i = 0; i < children.length; i++) {
                    if (trim.widget == children[i]) {
                        children[i] = null;
                    }
                }
            }
            return true;
        });
    }

    private void buildTrim(Widget parent) {
        if(parent.getType() != WidgetType.LAYER) return;

        int idx = (parent.getId() & 0xFFFF) - 1;
        SkillData skill = SkillData.get(idx);
        if (skill == null) return;

        MaxSkillTrimWidget maxLevel = maxSkillTrimWidgetHashMap.putIfAbsent(TrimType.MAX_LEVEL.name() + skill.name(), new MaxSkillTrimWidget(skill, TrimType.MAX_LEVEL, false, null));
        if(maxLevel != null && maxLevel.widget == null) {
            maxLevel.widget = createWidget(parent, skill, maxLevelTrim);
            updateTrim(maxLevel);
        }

        MaxSkillTrimWidget maxExp = maxSkillTrimWidgetHashMap.putIfAbsent(TrimType.MAX_EXPERIENCE.name() + skill.name(), new MaxSkillTrimWidget(skill, TrimType.MAX_EXPERIENCE, false, null));
        if(maxExp != null && maxExp.widget == null) {
            maxExp.widget = createWidget(parent, skill, maxExperienceTrim);
            updateTrim(maxExp);
        }
    }

    private Widget createWidget(Widget parent, SkillData skill, Trim trim) {
        boolean isSkillLastRow = skillsInLastRow.contains(skill.getSkill());

        return parent.createChild(-1, WidgetType.GRAPHIC)
                .setYPositionMode(isSkillLastRow ? WidgetPositionMode.ABSOLUTE_TOP + 1 : WidgetPositionMode.ABSOLUTE_TOP + 2)
                .setXPositionMode(WidgetPositionMode.ABSOLUTE_LEFT + 1)
                .setOriginalHeight(29)
                .setOriginalWidth(60)
                .setWidthMode(parent.getWidthMode())
                .setHeightMode(parent.getHeightMode())
                .setOpacity(255)
                .setSpriteId(trim.spriteID)
                .setName("Max Skill Trim - " + trim.trimType + " - " + skill.getSkill().getName());
    }

    private void updateTrim(MaxSkillTrimWidget widget) {
        int currentXP = client.getSkillExperience(widget.skillData.getSkill());
        boolean isMaxExperience = currentXP >= Experience.MAX_SKILL_XP;
        int currentLevel = Experience.getLevelForXp(currentXP);

        boolean showMaxLevelTrim = maxSkillTrimConfig.showMaxLevelTrim();
        boolean showMaxExperienceTrim = maxSkillTrimConfig.getShowMaxExperienceTrim();

        // Highest priority: developer mode with mock enabled
        if (mockOverridesEnabled) {
            widget.widget.setOpacity(widget.isMockEnabled ? 0 : 255);
            return;
        }

        boolean maxExpActive = showMaxExperienceTrim && isMaxExperience;
        boolean showTrim = false;

        if (widget.trimType == TrimType.MAX_EXPERIENCE) {
            showTrim = maxExpActive;
        }

        if (widget.trimType == TrimType.MAX_LEVEL) {
            showTrim = !maxExpActive && showMaxLevelTrim && currentLevel >= Experience.MAX_REAL_LEVEL;
        }

        widget.widget.setOpacity(showTrim ? 0 : 255);
    }

    void setMockTrimState(SkillData skill, boolean isMockEnabled, TrimType trimType) {
        MaxSkillTrimWidget widget = maxSkillTrimWidgetHashMap.get(trimType.name() + skill.name());
        if (widget != null) {
            widget.isMockEnabled = isMockEnabled;
            updateTrim(widget);
        }
    }

    void updateTrims() {
        for (MaxSkillTrimWidget widget : maxSkillTrimWidgetHashMap.values()) {
            updateTrim(widget);
        }
    }

    private void addDefaultTrims()
    {
        try
        {
            Files.copy(Objects.requireNonNull(getClass().getResourceAsStream("/full-trim.png")), Paths.get(MAXSKILLTRIMS_DIR.toString(), "/full-trim.png"), StandardCopyOption.REPLACE_EXISTING);
        }
        catch (IOException e)
        {
            log.warn(null, e);
        }
    }

    @Subscribe
    public void onConfigChanged(ConfigChanged event)
    {
        if (event.getGroup().equals(MaxSkillTrimConfig.GROUP_NAME))
        {
            switch(event.getKey()) {
                case MaxSkillTrimConfig.SELECTED_MAX_LEVEL_TRIM:
                    overrideSprites(maxLevelTrim, event.getNewValue());
                    break;
                case MaxSkillTrimConfig.SELECTED_MAX_EXPERIENCE_TRIM:
                    overrideSprites(maxExperienceTrim, event.getNewValue());
                    break;
                case MaxSkillTrimConfig.SHOW_MAX_EXPERIENCE_TRIM:
                case MaxSkillTrimConfig.SHOW_MAX_LEVEL_TRIM:
                    clientThread.invokeLater(this::updateTrims);
                    break;
                case MaxSkillTrimConfig.SHOW_NAV_BUTTON:
                    boolean showNavButton = Boolean.TRUE.toString().equals(event.getNewValue());

                    if(showNavButton) pluginToolbar.addNavigation(navButton);
                    if(!showNavButton) pluginToolbar.removeNavigation(navButton);
                    break;
            }
        }
    }

    public SpritePixels getSpritePixels(String filename)
    {
        File spriteFile = new File(MAXSKILLTRIMS_DIR, filename);
        if (!spriteFile.exists()) {
            log.debug("Sprite doesn't exist ({}): ", spriteFile.getPath());
            spriteFile = new File(MAXSKILLTRIMS_DIR, "full-trim.png");
            if (!spriteFile.exists()) {
                log.debug("Fallback sprite doesn't exist ({}): ", spriteFile.getPath());
                return null;
            }
        }
        try
        {
            synchronized (ImageIO.class)
            {
                BufferedImage image = ImageIO.read(spriteFile);
                return ImageUtil.getImageSpritePixels(image, client);
            }
        }
        catch (RuntimeException | IOException ex)
        {
            log.debug("Unable to find image ({}): ", spriteFile.getPath());
        }
        return null;
    }

    void overrideSprites(Trim trim, String filename)
    {
        SpritePixels spritePixels = getSpritePixels(filename);

        if (spritePixels == null)
        {
            return;
        }

        client.getSpriteOverrides().remove(trim.spriteID);
        client.getWidgetSpriteCache().reset();
        client.getSpriteOverrides().put(trim.spriteID, spritePixels);
    }
}

package com.maxskilltrim;

import net.runelite.api.widgets.Widget;

public class MaxSkillTrimWidget {
    SkillData skillData;
    TrimType trimType;
    boolean isMockEnabled;
    Widget widget;

    MaxSkillTrimWidget(SkillData skillData, TrimType trimType, boolean isMockEnabled, Widget widget) {
        this.skillData = skillData;
        this.trimType = trimType;
        this.isMockEnabled = isMockEnabled;
        this.widget = widget;
    }
}

package com.maxskilltrim;

public class MockTrimState {
    boolean mockMaxLevel = false;
    boolean mockMaxExperience = false;
}

/*
 * Copyright (c) 2021, Hydrox6 <ikada@protonmail.ch>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.maxskilltrim;

import lombok.AllArgsConstructor;
import lombok.Getter;
import net.runelite.api.Skill;

@Getter
@AllArgsConstructor
enum SkillData {
    ATTACK(Skill.ATTACK),
    STRENGTH(Skill.STRENGTH),
    DEFENCE(Skill.DEFENCE),
    RANGED(Skill.RANGED),
    PRAYER(Skill.PRAYER),
    MAGIC(Skill.MAGIC),
    RUNECRAFT(Skill.RUNECRAFT),
    CONSTRUCTION(Skill.CONSTRUCTION),
    HITPOINTS(Skill.HITPOINTS),
    AGILITY(Skill.AGILITY),
    HERBLORE(Skill.HERBLORE),
    THIEVING(Skill.THIEVING),
    CRAFTING(Skill.CRAFTING),
    FLETCHING(Skill.FLETCHING),
    SLAYER(Skill.SLAYER),
    HUNTER(Skill.HUNTER),
    MINING(Skill.MINING),
    SMITHING(Skill.SMITHING),
    FISHING(Skill.FISHING),
    COOKING(Skill.COOKING),
    FIREMAKING(Skill.FIREMAKING),
    WOODCUTTING(Skill.WOODCUTTING),
    FARMING(Skill.FARMING),
    SAILING(Skill.SAILING);

    private final Skill skill;

    static SkillData get(int idx) {
        if (idx < 0 || idx >= values().length) {
            return null;
        }

        return values()[idx];
    }
}
package com.maxskilltrim;

public class Trim
{
    public int spriteID;
    public TrimType trimType;

    public Trim(int spriteId, TrimType trimType) {
        this.spriteID = spriteId;
        this.trimType = trimType;
    }
}


package com.maxskilltrim;

public enum TrimType
{
    MAX_LEVEL,
    MAX_EXPERIENCE
}

package com.maxskilltrim;

import net.runelite.client.RuneLite;
import net.runelite.client.externalplugins.ExternalPluginManager;

public class MaxSkillTrimPluginTest
{
	public static void main(String[] args) throws Exception
	{
		ExternalPluginManager.loadBuiltin(MaxSkillTrimPlugin.class);
		RuneLite.main(args);
	}
}
