package com.toamistaketracker;

import net.runelite.client.RuneLite;
import net.runelite.client.externalplugins.ExternalPluginManager;

public class ToaMistakeTrackerPluginTest
{
	public static void main(String[] args) throws Exception
	{
		ExternalPluginManager.loadBuiltin(ToaMistakeTrackerPlugin.class);
		RuneLite.main(args);
	}
}
package com.toamistaketracker.detector.death;

import com.google.common.collect.ImmutableMap;
import com.toamistaketracker.RaidRoom;
import com.toamistaketracker.Raider;
import com.toamistaketracker.ToaMistake;
import com.toamistaketracker.detector.BaseMistakeDetector;
import lombok.NonNull;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Player;
import net.runelite.api.events.ActorDeath;
import net.runelite.client.eventbus.Subscribe;

import javax.inject.Singleton;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import static com.toamistaketracker.ToaMistake.DEATH;
import static com.toamistaketracker.ToaMistake.DEATH_APMEKEN;
import static com.toamistaketracker.ToaMistake.DEATH_CRONDIS;
import static com.toamistaketracker.ToaMistake.DEATH_HET;
import static com.toamistaketracker.ToaMistake.DEATH_SCABARAS;
import static com.toamistaketracker.ToaMistake.DEATH_WARDENS;

/**
 * Track deaths for each player in the raid using the {@link ActorDeath} event. Also map each room to the room death.
 */
@Slf4j
@Singleton
public class DeathDetector extends BaseMistakeDetector {

    private static final Map<RaidRoom, ToaMistake> ROOM_DEATHS = ImmutableMap.<RaidRoom, ToaMistake>builder()
            .put(RaidRoom.HET_PUZZLE, DEATH_HET)
            .put(RaidRoom.AKKHA, DEATH_HET)
            .put(RaidRoom.CRONDIS_PUZZLE, DEATH_CRONDIS)
            .put(RaidRoom.ZEBAK, DEATH_CRONDIS)
            .put(RaidRoom.SCABARAS_PUZZLE, DEATH_SCABARAS)
            .put(RaidRoom.KEPHRI, DEATH_SCABARAS)
            .put(RaidRoom.APMEKEN_PUZZLE, DEATH_APMEKEN)
            .put(RaidRoom.BABA, DEATH_APMEKEN)
            .put(RaidRoom.WARDENS_P1_P2, DEATH_WARDENS)
            .put(RaidRoom.WARDENS_P3, DEATH_WARDENS)
            .build();

    private final Set<String> raiderDeaths;

    public DeathDetector() {
        raiderDeaths = new HashSet<>();
    }

    @Override
    public void cleanup() {
        raiderDeaths.clear();
    }

    @Override
    public RaidRoom getRaidRoom() {
        return null; // null means *all* rooms
    }

    @Override
    public List<ToaMistake> detectMistakes(@NonNull Raider raider) {
        List<ToaMistake> mistakes = new ArrayList<>();

        if (raiderDeaths.contains(raider.getName())) {
            mistakes.add(DEATH);

            if (!ROOM_DEATHS.containsKey(raidState.getCurrentRoom())) {
                // Should never happen. If it does, log and return empty mistakes for this death
                log.error("Unknown room death: {}", raidState.getCurrentRoom());
                return Collections.emptyList();
            }

            mistakes.add(ROOM_DEATHS.get(raidState.getCurrentRoom()));
        }

        return mistakes;
    }

    @Override
    public void afterDetect() {
        raiderDeaths.clear();
    }

    @Subscribe
    public void onActorDeath(ActorDeath event) {
        if (!(event.getActor() instanceof Player)) return;

        if (raidState.isRaider(event.getActor()))
            raiderDeaths.add(event.getActor().getName());
    }
}
package com.toamistaketracker.detector.puzzle;

import com.google.common.collect.ImmutableSet;
import com.toamistaketracker.RaidRoom;
import com.toamistaketracker.Raider;
import com.toamistaketracker.ToaMistake;
import com.toamistaketracker.detector.BaseMistakeDetector;
import lombok.Getter;
import lombok.NonNull;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.HitsplatID;
import net.runelite.api.NPC;
import net.runelite.api.Player;
import net.runelite.api.coords.LocalPoint;
import net.runelite.api.coords.WorldPoint;
import net.runelite.api.events.AnimationChanged;
import net.runelite.api.events.HitsplatApplied;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.util.Text;

import javax.inject.Singleton;
import java.util.ArrayList;
import java.util.HashSet;
import java.util.List;
import java.util.Set;
import java.util.stream.Collectors;

import static com.toamistaketracker.RaidRoom.CRONDIS_PUZZLE;
import static com.toamistaketracker.ToaMistake.CRONDIS_PUZZLE_LOW_WATER;

/**
 * Path of Crondis puzzle is a bit of a tricky one. If a watering amount < 100 is applied to the palm tree, a mistake
 * was made. The question is, by whom?
 *
 * To answer this, we track a few things:
 * 1. The raiders that have filled their jugs with water. This is done by checking AnimationChanged events for players
 * that are standing on a "waterfall" tile.
 * 2. The raiders that have taken damage with water. This is done by checking HitsplatApplied events for damage done
 * on raiders that have already filled their jugs.
 * 3. The raiders that have watered the palm tree this tick. Once again, we check AnimationChanged events for players
 * that are standing on a "palm tree" tile.
 *
 * With all of this information, we also defensively check for HitsplatApplied events on the palm tree itself being
 * lower than 100, and then we can try to resolve the player that was damaged when detecting. Most of this special
 * logic is really only needed to handle the edge case of two players watering on the same tick, with only one having
 * less than 100.
 */
@Slf4j
@Singleton
public class CrondisPuzzleDetector extends BaseMistakeDetector {

    private static final Set<WorldPoint> WATERFALL_REGION_TILES = ImmutableSet.of(
            // SW
            WorldPoint.fromRegion(CRONDIS_PUZZLE.getRegionId(), 23, 7, 0),
            WorldPoint.fromRegion(CRONDIS_PUZZLE.getRegionId(), 24, 7, 0),
            WorldPoint.fromRegion(CRONDIS_PUZZLE.getRegionId(), 26, 7, 0),
            WorldPoint.fromRegion(CRONDIS_PUZZLE.getRegionId(), 27, 7, 0),

            // SE
            WorldPoint.fromRegion(CRONDIS_PUZZLE.getRegionId(), 37, 7, 0),
            WorldPoint.fromRegion(CRONDIS_PUZZLE.getRegionId(), 38, 7, 0),
            WorldPoint.fromRegion(CRONDIS_PUZZLE.getRegionId(), 40, 7, 0),
            WorldPoint.fromRegion(CRONDIS_PUZZLE.getRegionId(), 41, 7, 0),

            // NW
            WorldPoint.fromRegion(CRONDIS_PUZZLE.getRegionId(), 23, 57, 0),
            WorldPoint.fromRegion(CRONDIS_PUZZLE.getRegionId(), 24, 57, 0),
            WorldPoint.fromRegion(CRONDIS_PUZZLE.getRegionId(), 26, 57, 0),
            WorldPoint.fromRegion(CRONDIS_PUZZLE.getRegionId(), 27, 57, 0),

            // NE
            WorldPoint.fromRegion(CRONDIS_PUZZLE.getRegionId(), 37, 57, 0),
            WorldPoint.fromRegion(CRONDIS_PUZZLE.getRegionId(), 38, 57, 0),
            WorldPoint.fromRegion(CRONDIS_PUZZLE.getRegionId(), 40, 57, 0),
            WorldPoint.fromRegion(CRONDIS_PUZZLE.getRegionId(), 41, 57, 0)
    );

    private static final Set<WorldPoint> PALM_TREE_REGION_TILES = ImmutableSet.of(
            // S
            WorldPoint.fromRegion(CRONDIS_PUZZLE.getRegionId(), 30, 29, 0),
            WorldPoint.fromRegion(CRONDIS_PUZZLE.getRegionId(), 31, 29, 0),
            WorldPoint.fromRegion(CRONDIS_PUZZLE.getRegionId(), 32, 29, 0),
            WorldPoint.fromRegion(CRONDIS_PUZZLE.getRegionId(), 33, 29, 0),
            WorldPoint.fromRegion(CRONDIS_PUZZLE.getRegionId(), 34, 29, 0),

            // E
            WorldPoint.fromRegion(CRONDIS_PUZZLE.getRegionId(), 35, 30, 0),
            WorldPoint.fromRegion(CRONDIS_PUZZLE.getRegionId(), 35, 31, 0),
            WorldPoint.fromRegion(CRONDIS_PUZZLE.getRegionId(), 35, 32, 0),
            WorldPoint.fromRegion(CRONDIS_PUZZLE.getRegionId(), 35, 33, 0),
            WorldPoint.fromRegion(CRONDIS_PUZZLE.getRegionId(), 35, 34, 0),

            // N
            WorldPoint.fromRegion(CRONDIS_PUZZLE.getRegionId(), 30, 35, 0),
            WorldPoint.fromRegion(CRONDIS_PUZZLE.getRegionId(), 31, 35, 0),
            WorldPoint.fromRegion(CRONDIS_PUZZLE.getRegionId(), 32, 35, 0),
            WorldPoint.fromRegion(CRONDIS_PUZZLE.getRegionId(), 33, 35, 0),
            WorldPoint.fromRegion(CRONDIS_PUZZLE.getRegionId(), 34, 35, 0),

            // W
            WorldPoint.fromRegion(CRONDIS_PUZZLE.getRegionId(), 29, 30, 0),
            WorldPoint.fromRegion(CRONDIS_PUZZLE.getRegionId(), 29, 31, 0),
            WorldPoint.fromRegion(CRONDIS_PUZZLE.getRegionId(), 29, 32, 0),
            WorldPoint.fromRegion(CRONDIS_PUZZLE.getRegionId(), 29, 33, 0),
            WorldPoint.fromRegion(CRONDIS_PUZZLE.getRegionId(), 29, 34, 0)
    );

    private static final String PALM_TREE_NAME = "Palm of Resourcefulness";
    private static final int PLAYER_WATER_ANIMATION_ID = 827;
    private static final int WATER_HITSPLAT_UP_ID = 11;
    private static final int WATER_HITSPLAT_DOWN_ID = 15;
    private static final int MAX_WATER_HITSPLAT_UP_AMOUNT = 100;

    @Getter
    private Set<WorldPoint> waterFallTiles;
    @Getter
    private Set<WorldPoint> palmTreeTiles;

    private final Set<String> raidersAnimatingWater;
    private final Set<String> raidersWithWater;
    private final Set<String> raidersLostWater;
    private final Set<String> raidersWatering;
    private int lowWaterHitsplats;

    public CrondisPuzzleDetector() {
        waterFallTiles = new HashSet<>();
        palmTreeTiles = new HashSet<>();

        raidersAnimatingWater = new HashSet<>();
        raidersWithWater = new HashSet<>();
        raidersLostWater = new HashSet<>();
        raidersWatering = new HashSet<>();
    }

    @Override
    public void startup() {
        super.startup();
        computeTiles();
    }

    @Override
    public void cleanup() {
        waterFallTiles.clear();
        palmTreeTiles.clear();

        raidersAnimatingWater.clear();
        raidersWithWater.clear();
        raidersLostWater.clear();
        raidersWatering.clear();
    }

    @Override
    public RaidRoom getRaidRoom() {
        return CRONDIS_PUZZLE;
    }

    @Override
    public List<ToaMistake> detectMistakes(@NonNull Raider raider) {
        // This needs to be done here, as the player's location hasn't been updated yet during HitsplatApplied-time.
        if (raidersAnimatingWater.contains(raider.getName())) {
            computeRaiderWatering(raider);
        }

        List<ToaMistake> mistakes = new ArrayList<>();

        if (raidersWatering.contains(raider.getName())) {
            if (lowWaterHitsplats > 0 && raidersLostWater.contains(raider.getName())) {
                mistakes.add(CRONDIS_PUZZLE_LOW_WATER);
                lowWaterHitsplats -= 1;
            }

            raidersWithWater.remove(raider.getName());
            raidersLostWater.remove(raider.getName());
        }

        return mistakes;
    }

    @Override
    public void afterDetect() {
        raidersAnimatingWater.clear();
        raidersWatering.clear();
        lowWaterHitsplats = 0;
    }

    @Subscribe
    public void onHitsplatApplied(HitsplatApplied event) {
        if (event.getActor().getName() == null) return;

        String name = Text.removeTags(event.getActor().getName());
        if (raidState.isRaider(event.getActor()) &&
                raidersWithWater.contains(name) &&
                isDamageHitsplat(event.getHitsplat().getHitsplatType())) {
            raidersLostWater.add(name);
        } else if (event.getActor() instanceof NPC && PALM_TREE_NAME.equals(name) &&
                event.getHitsplat().getHitsplatType() == WATER_HITSPLAT_UP_ID &&
                event.getHitsplat().getAmount() < MAX_WATER_HITSPLAT_UP_AMOUNT) {
            lowWaterHitsplats += 1;
        }
    }

    @Subscribe
    public void onAnimationChanged(AnimationChanged event) {
        if (!(event.getActor() instanceof Player) ||
                event.getActor().getAnimation() != PLAYER_WATER_ANIMATION_ID ||
                !raidState.isRaider(event.getActor())) {
            return;
        }

        raidersAnimatingWater.add(event.getActor().getName());
    }

    private boolean isDamageHitsplat(int hitsplatType) {
        return hitsplatType == HitsplatID.DAMAGE_ME || hitsplatType == HitsplatID.DAMAGE_OTHER;
    }

    private void computeTiles() {
        WorldPoint wpPlayer = client.getLocalPlayer().getWorldLocation();
        LocalPoint lpPlayer = LocalPoint.fromWorld(client, wpPlayer);
        if (lpPlayer == null) return;

        int dx = lpPlayer.getSceneX() - wpPlayer.getRegionX();
        int dy = lpPlayer.getSceneY() - wpPlayer.getRegionY();

        waterFallTiles = WATERFALL_REGION_TILES.stream()
                .map(wp -> WorldPoint.fromScene(client, wp.getRegionX() + dx, wp.getRegionY() + dy, wp.getPlane()))
                .collect(Collectors.toSet());
        palmTreeTiles = PALM_TREE_REGION_TILES.stream()
                .map(wp -> WorldPoint.fromScene(client, wp.getRegionX() + dx, wp.getRegionY() + dy, wp.getPlane()))
                .collect(Collectors.toSet());
    }

    private void computeRaiderWatering(Raider raider) {
        if (waterFallTiles.contains(raider.getCurrentWorldLocation())) {
            raidersWithWater.add(raider.getName());
            raidersLostWater.remove(raider.getName());
        } else if (palmTreeTiles.contains(raider.getCurrentWorldLocation())) {
            raidersWatering.add(raider.getName());
        }
    }
}
package com.toamistaketracker.detector.puzzle;

import com.toamistaketracker.RaidRoom;
import com.toamistaketracker.Raider;
import com.toamistaketracker.ToaMistake;
import com.toamistaketracker.detector.BaseMistakeDetector;
import lombok.Getter;
import lombok.NonNull;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.ChatMessageType;
import net.runelite.api.coords.WorldPoint;
import net.runelite.api.events.ChatMessage;
import net.runelite.api.events.GameObjectDespawned;
import net.runelite.api.events.GameObjectSpawned;
import net.runelite.api.events.GraphicsObjectCreated;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.util.Text;

import javax.inject.Singleton;
import java.util.ArrayList;
import java.util.HashSet;
import java.util.List;
import java.util.Set;

import static com.toamistaketracker.RaidRoom.APMEKEN_PUZZLE;
import static com.toamistaketracker.ToaMistake.APMEKEN_PUZZLE_CORRUPTION;
import static com.toamistaketracker.ToaMistake.APMEKEN_PUZZLE_PILLAR;
import static com.toamistaketracker.ToaMistake.APMEKEN_PUZZLE_VENOM;
import static com.toamistaketracker.ToaMistake.APMEKEN_PUZZLE_VENT;
import static com.toamistaketracker.ToaMistake.APMEKEN_PUZZLE_VOLATILE;

/**
 * Apmeken has some group mechanics to detect mistakes for, and then personal ones.
 *
 * For the group mechanics, the most consistent way to detect these mistakes is seemingly by checking for the
 * corresponding game message. Since these are always sent to *everyone* in the raid, it should be safe to use. If these
 * messages ever change in the future, then these mistakes will unfortunately break.
 *
 * While I'd like to also count accidentally venting or repairing pillars when you're not supposed to, there's no real
 * way to consistently detect pillars if two players are on the same tile as the graphics spawn, since only one takes
 * damage. The hitsplat is also not always consistently applied on the first tick. Could come back to this in the future
 * but for now I think it's fine to only count the team mechanic mistakes.
 *
 * For venom, it's straight forward and almost identical to Zebak acid. And for volatile, when it explodes it spawns
 * a graphics object at the center of the explosion, and all tiles in a 3x3 around that center are damaging.
 */
@Slf4j
@Singleton
public class ApmekenPuzzleDetector extends BaseMistakeDetector {

    private static final int VENT_GRAPHICS_ID = 2138;
    private static final int PILLAR_GRAPHICS_ID = 2139;
    private static final int VENOM_TILE_GAME_OBJECT_ID = 45493;
    private static final int VOLATILE_GRAPHICS_ID = 131;

    // TODO: Should these be partials that we regex match on in case they slightly change?
    private static final String VENT_FAILURE_MESSAGE = "The fumes filling the room suddenly ignite!";
    private static final String PILLAR_FAILURE_MESSAGE = "Damaged roof supports cause some debris to fall on you!";
    private static final String CORRUPTION_FAILURE_MESSAGE = "Your group is overwhelmed by Amascut's corruption!";

    private ToaMistake teamMistake;

    private final Set<WorldPoint> venomTilesToSpawn;
    private final Set<WorldPoint> venomTiles;

    @Getter
    private final Set<WorldPoint> volatileHitTiles;

    public ApmekenPuzzleDetector() {
        venomTilesToSpawn = new HashSet<>();
        venomTiles = new HashSet<>();
        volatileHitTiles = new HashSet<>();
    }

    @Override
    public void cleanup() {
        teamMistake = null;
        venomTilesToSpawn.clear();
        venomTiles.clear();
        volatileHitTiles.clear();
    }

    @Override
    public RaidRoom getRaidRoom() {
        return APMEKEN_PUZZLE;
    }

    @Override
    public List<ToaMistake> detectMistakes(@NonNull Raider raider) {
        List<ToaMistake> mistakes = new ArrayList<>();

        // All raiders get team mistakes
        if (teamMistake != null) {
            mistakes.add(teamMistake);
        }

        if (venomTiles.contains(raider.getPreviousWorldLocation())) {
            mistakes.add(APMEKEN_PUZZLE_VENOM);
        }

        if (volatileHitTiles.contains(raider.getPreviousWorldLocation())) {
            mistakes.add(APMEKEN_PUZZLE_VOLATILE);
        }

        return mistakes;
    }

    @Override
    public void afterDetect() {
        teamMistake = null;
        volatileHitTiles.clear();

        venomTiles.addAll(venomTilesToSpawn);
        venomTilesToSpawn.clear();
    }

    @Subscribe
    public void onChatMessage(ChatMessage event) {
        if (event.getType() != ChatMessageType.GAMEMESSAGE) return;

        String message = Text.removeTags(event.getMessage());
        if (VENT_FAILURE_MESSAGE.equals(message)) {
            teamMistake = APMEKEN_PUZZLE_VENT;
        } else if (PILLAR_FAILURE_MESSAGE.equals(message)) {
            teamMistake = APMEKEN_PUZZLE_PILLAR;
        } else if (CORRUPTION_FAILURE_MESSAGE.equals(message)) {
            teamMistake = APMEKEN_PUZZLE_CORRUPTION;
        }
    }

    @Subscribe
    public void onGameObjectSpawned(GameObjectSpawned event) {
        if (event.getGameObject().getId() == VENOM_TILE_GAME_OBJECT_ID) {
            // Venom tiles don't hit you for the first tick they're spawned, so delay their detection by a tick.
            venomTilesToSpawn.add(event.getGameObject().getWorldLocation());
        }
    }

    @Subscribe
    public void onGameObjectDespawned(GameObjectDespawned event) {
        if (event.getGameObject().getId() == VENOM_TILE_GAME_OBJECT_ID) {
            venomTilesToSpawn.remove(event.getGameObject().getWorldLocation());
            venomTiles.remove(event.getGameObject().getWorldLocation());
        }
    }

    @Subscribe
    public void onGraphicsObjectCreated(GraphicsObjectCreated event) {
        if (event.getGraphicsObject().getId() != VOLATILE_GRAPHICS_ID) return;

        // Hits in 3x3 around center, so compute and add all
        Set<WorldPoint> newHitTiles = compute3By3TilesFromCenter(getWorldPoint(event.getGraphicsObject()));
        volatileHitTiles.addAll(newHitTiles);
    }
}
package com.toamistaketracker.detector.puzzle;

import com.toamistaketracker.RaidRoom;
import com.toamistaketracker.Raider;
import com.toamistaketracker.ToaMistake;
import com.toamistaketracker.detector.BaseMistakeDetector;
import lombok.NonNull;
import lombok.extern.slf4j.Slf4j;

import javax.inject.Singleton;
import java.util.ArrayList;
import java.util.List;

import static com.toamistaketracker.RaidRoom.SCABARAS_PUZZLE;

/**
 *
 */
@Slf4j
@Singleton
public class ScabarasPuzzleDetector extends BaseMistakeDetector {

    public ScabarasPuzzleDetector() {
    }

    @Override
    public void cleanup() {
    }

    @Override
    public RaidRoom getRaidRoom() {
        return SCABARAS_PUZZLE;
    }

    @Override
    public List<ToaMistake> detectMistakes(@NonNull Raider raider) {
        List<ToaMistake> mistakes = new ArrayList<>();

        return mistakes;
    }

    @Override
    public void afterDetect() {
    }
}
package com.toamistaketracker.detector.puzzle;

import com.google.common.collect.ImmutableSet;
import com.toamistaketracker.RaidRoom;
import com.toamistaketracker.Raider;
import com.toamistaketracker.ToaMistake;
import com.toamistaketracker.detector.tracker.AppliedHitsplatsTracker;
import com.toamistaketracker.detector.BaseMistakeDetector;
import com.toamistaketracker.detector.tracker.DelayedMistakeTracker;
import lombok.NonNull;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.coords.WorldPoint;
import net.runelite.api.events.GraphicsObjectCreated;
import net.runelite.api.events.HitsplatApplied;
import net.runelite.client.eventbus.Subscribe;

import javax.inject.Singleton;
import java.util.ArrayList;
import java.util.HashSet;
import java.util.List;
import java.util.Set;

import static com.toamistaketracker.RaidRoom.HET_PUZZLE;
import static com.toamistaketracker.ToaMistake.HET_PUZZLE_DARK_ORB;
import static com.toamistaketracker.ToaMistake.HET_PUZZLE_LIGHT;

/**
 * There are a few ways to detect an orb of darkness hitting a player. The easiest is probably to check if a graphics
 * ID of 379 spawns under the player's location. If multiple players are standing on the same location, it seems like
 * only one of them gets hit. Currently, we try to resolve by checking to see which players also had a hitsplat applied
 * to them on that same tick. This can obviously be bypassed, like with locator orb, or by both players standing and
 * taking a light attack on that same tick, but that should be pretty rare and there doesn't seem to be a great way
 * to resolve that otherwise.
 *
 * For detecting the light beam, we can see if the graphics ids are spawned on the player's tile. ALL players standing
 * in the light's path should be hit, so we don't need to resolve to a single player. One other thing is to delay the
 * mistake by one tick, as technically the damage doesn't come in until one tick after the light spawns, for some reason
 */
@Slf4j
@Singleton
public class HetPuzzleDetector extends BaseMistakeDetector {

    private static final Set<Integer> LIGHT_BEAM_GRAPHICS_IDS = ImmutableSet.of(2064, 2114);
    private static final int ORB_OF_DARKNESS_GRAPHICS_ID = 379;

    private final Set<WorldPoint> orbHitTiles;
    private final Set<WorldPoint> lightHitTiles;

    private final AppliedHitsplatsTracker appliedHitsplats;
    private final DelayedMistakeTracker delayedMistakes;

    public HetPuzzleDetector() {
        orbHitTiles = new HashSet<>();
        lightHitTiles = new HashSet<>();

        appliedHitsplats = new AppliedHitsplatsTracker();
        delayedMistakes = new DelayedMistakeTracker();
    }

    @Override
    public void cleanup() {
        orbHitTiles.clear();
        lightHitTiles.clear();
        appliedHitsplats.clear();
        delayedMistakes.clear();
    }

    @Override
    public RaidRoom getRaidRoom() {
        return HET_PUZZLE;
    }

    @Override
    public List<ToaMistake> detectMistakes(@NonNull Raider raider) {
        List<ToaMistake> mistakes = new ArrayList<>();

        if (orbHitTiles.contains(raider.getPreviousWorldLocation()) &&
                appliedHitsplats.popHitsplatApplied(raider.getName())) {
            mistakes.add(HET_PUZZLE_DARK_ORB);
        }

        if (lightHitTiles.contains(raider.getPreviousWorldLocation())) {
            // Delay this mistake until 1 tick, since it takes 1 tick for the hitsplat to show up
            delayedMistakes.addDelayedMistake(raider.getName(), HET_PUZZLE_LIGHT, client.getTickCount(), 1);
        }

        // Add any delayed mistakes from previous ticks
        mistakes.addAll(delayedMistakes.popDelayedMistakes(raider.getName(), client.getTickCount()));

        return mistakes;
    }

    @Override
    public void afterDetect() {
        orbHitTiles.clear();
        lightHitTiles.clear();
        appliedHitsplats.clear();
        // Don't clear delayedMistakes on afterDetect, since we need it to persist across ticks.
    }

    @Subscribe
    public void onGraphicsObjectCreated(GraphicsObjectCreated event) {
        if (event.getGraphicsObject().getId() == ORB_OF_DARKNESS_GRAPHICS_ID) {
            orbHitTiles.add(getWorldPoint(event.getGraphicsObject()));
        } else if (LIGHT_BEAM_GRAPHICS_IDS.contains(event.getGraphicsObject().getId())) {
            lightHitTiles.add(getWorldPoint(event.getGraphicsObject()));
        }
    }

    @Subscribe
    public void onHitsplatApplied(HitsplatApplied event) {
        if (raidState.isRaider(event.getActor())) {
            appliedHitsplats.addHitsplatForRaider(event.getActor().getName());
        }
    }
}

package com.toamistaketracker.detector;

import com.google.common.annotations.VisibleForTesting;
import com.toamistaketracker.RaidState;
import com.toamistaketracker.Raider;
import com.toamistaketracker.ToaMistake;
import com.toamistaketracker.detector.boss.AkkhaDetector;
import com.toamistaketracker.detector.boss.BabaDetector;
import com.toamistaketracker.detector.boss.KephriDetector;
import com.toamistaketracker.detector.boss.WardensP1P2Detector;
import com.toamistaketracker.detector.boss.WardensP3Detector;
import com.toamistaketracker.detector.boss.ZebakDetector;
import com.toamistaketracker.detector.death.DeathDetector;
import com.toamistaketracker.detector.puzzle.ApmekenPuzzleDetector;
import com.toamistaketracker.detector.puzzle.CrondisPuzzleDetector;
import com.toamistaketracker.detector.puzzle.HetPuzzleDetector;
import com.toamistaketracker.detector.puzzle.ScabarasPuzzleDetector;
import com.toamistaketracker.detector.tracker.BaseRaidTracker;
import com.toamistaketracker.detector.tracker.VengeanceTracker;
import com.toamistaketracker.events.RaidRoomChanged;
import lombok.Getter;
import lombok.NonNull;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.ChatMessageType;
import net.runelite.api.Client;
import net.runelite.api.events.ChatMessage;
import net.runelite.client.eventbus.EventBus;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.util.Text;

import javax.inject.Inject;
import javax.inject.Singleton;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.List;

/**
 * Manager for all the {@link BaseMistakeDetector}. It keeps all the detectors in memory in order to manage events.
 * <p>
 * All detectors initialized in the manager are responsible for determining when to start detecting mistakes.
 * The manager may call the startup() or shutdown() method on a detector at any time.
 * <p>
 * When the manager is on (started = true), then all other detectors are subscribed to the EventBus and
 * listening for events on when to turn themselves on/off. This will only be true while the player is in Toa.
 */
@Slf4j
@Singleton
public class MistakeDetectorManager {

    private static final String WIPE_GAME_MESSAGE = "Your party failed to complete the challenge";

    private final Client client;
    private final EventBus eventBus;
    private final RaidState raidstate;
    private final VengeanceTracker vengeanceTracker;

    @Getter
    private final List<BaseRaidTracker> raidTrackers;

    @Getter
    private final List<BaseMistakeDetector> mistakeDetectors;

    @Getter
    @VisibleForTesting
    private boolean started;

    @Inject
    public MistakeDetectorManager(Client client,
                                  EventBus eventBus,
                                  RaidState raidState,
                                  VengeanceTracker vengeanceTracker,
                                  HetPuzzleDetector hetPuzzleDetector,
                                  CrondisPuzzleDetector crondisPuzzleDetector,
                                  ScabarasPuzzleDetector scabarasPuzzleDetector,
                                  ApmekenPuzzleDetector apmekenPuzzleDetector,
                                  AkkhaDetector akkhaDetector,
                                  ZebakDetector zebakDetector,
                                  KephriDetector kephriDetector,
                                  BabaDetector babaDetector,
                                  WardensP1P2Detector wardensP1P2Detector,
                                  WardensP3Detector wardensP3Detector,
                                  DeathDetector deathDetector) {
        this.raidTrackers = Arrays.asList(vengeanceTracker);

        // Order matters, since it's last write wins for which mistake gets put on overhead text. Death should be last.
        this.mistakeDetectors = new ArrayList<>(Arrays.asList(
                hetPuzzleDetector,
                crondisPuzzleDetector,
                scabarasPuzzleDetector,
                apmekenPuzzleDetector,
                akkhaDetector,
                zebakDetector,
                kephriDetector,
                babaDetector,
                wardensP1P2Detector,
                wardensP3Detector,
                deathDetector
        ));

        this.client = client;
        this.eventBus = eventBus;
        this.raidstate = raidState;
        this.vengeanceTracker = vengeanceTracker;
        this.started = false;
    }

    public void startup() {
        started = true;
        eventBus.register(this);

        // Startup all raid trackers
        raidTrackers.forEach(BaseRaidTracker::startup);

        // Startup any detectors that should be active in *all* rooms
        mistakeDetectors.stream().filter(d -> d.getRaidRoom() == null).forEach(BaseMistakeDetector::startup);
    }

    public void shutdown() {
        mistakeDetectors.forEach(BaseMistakeDetector::shutdown);
        // Don't clear mistakeDetectors or else we can't get them back.

        raidTrackers.forEach(BaseRaidTracker::shutdown);

        eventBus.unregister(this);
        started = false;
    }

    public List<ToaMistake> detectMistakes(@NonNull Raider raider) {
        if (!started) return Collections.emptyList();

        List<ToaMistake> mistakes = new ArrayList<>();
        for (BaseMistakeDetector mistakeDetector : mistakeDetectors) {
            if (mistakeDetector.isDetectingMistakes() && !raider.isDead()) {
                mistakes.addAll(mistakeDetector.detectMistakes(raider));
            }
        }

        return mistakes;
    }

    public void afterDetect() {
        if (!started) return;

        raidTrackers.forEach(BaseRaidTracker::afterDetect);

        for (BaseMistakeDetector mistakeDetector : mistakeDetectors) {
            if (mistakeDetector.isDetectingMistakes()) {
                mistakeDetector.afterDetect();
            }
        }
    }

    @Subscribe
    public void onRaidRoomChanged(RaidRoomChanged event) {
        // Detectors that run in *all* rooms do not need to handle these events
        mistakeDetectors.stream().filter(d -> d.getRaidRoom() != null).forEach(detector -> {
            if (detector.getRaidRoom() == event.getNewRaidRoom()) {
                detector.startup();
            } else if (detector.getRaidRoom() == event.getPrevRaidRoom()) {
                detector.shutdown();
            }
        });
    }

    @Subscribe
    public void onChatMessage(ChatMessage event) {
        if (event.getType() != ChatMessageType.GAMEMESSAGE) return;

        String message = Text.removeTags(event.getMessage());
        if (message != null && message.startsWith(WIPE_GAME_MESSAGE)) {
            // If the team has wiped, all active detectors should reset state just in case.
            log.debug("Team wiped -- Resetting all active detectors");
            mistakeDetectors.stream()
                    .filter(BaseMistakeDetector::isDetectingMistakes)
                    .forEach(d -> {
                        d.shutdown();
                        d.startup();
                    });
        }
    }
}

package com.toamistaketracker.detector.boss;

import com.google.common.collect.ImmutableSet;
import com.toamistaketracker.RaidRoom;
import com.toamistaketracker.Raider;
import com.toamistaketracker.ToaMistake;
import com.toamistaketracker.detector.BaseMistakeDetector;
import com.toamistaketracker.detector.tracker.AppliedHitsplatsTracker;
import com.toamistaketracker.detector.tracker.DelayedHitTilesTracker;
import lombok.NonNull;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Actor;
import net.runelite.api.GameObject;
import net.runelite.api.GraphicsObject;
import net.runelite.api.NPC;
import net.runelite.api.coords.WorldPoint;
import net.runelite.api.events.GameObjectDespawned;
import net.runelite.api.events.GameObjectSpawned;
import net.runelite.api.events.GameTick;
import net.runelite.api.events.GraphicChanged;
import net.runelite.api.events.GraphicsObjectCreated;
import net.runelite.api.events.HitsplatApplied;
import net.runelite.api.events.NpcDespawned;
import net.runelite.api.events.NpcSpawned;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.util.Text;

import javax.inject.Singleton;
import java.util.ArrayList;
import java.util.HashSet;
import java.util.List;
import java.util.Set;

import static com.toamistaketracker.RaidRoom.AKKHA;
import static com.toamistaketracker.ToaMistake.AKKHA_SPECIAL_ELEMENTAL_ORBS;
import static com.toamistaketracker.ToaMistake.AKKHA_SPECIAL_QUADRANT_BOMB;
import static com.toamistaketracker.ToaMistake.AKKHA_UNSTABLE_ORB;

/**
 * Akkha's memory/simon says special is the same attack as the hourglass special, which is also the same attack as
 * the explode special, and as such they are all counted as the same mistake. It's fairly straightforward, just looking
 * at if the graphics object spawned under the player's tile. ALL players on that tile are affected.
 *
 * UPDATE: As of 10/03/2022 Jagex recently changed Akkha's quadrant special behavior in the past week or two. Now, all
 * of the graphics objects spawn immediately, with a 1-tick delay. Seemingly this is to stop cheesing in the corners
 * where some of the orbs spawn 1-tick after others and you can "skip". We still need to account for the explode
 * special, as there is a 0-tick delay for those hitting the player.
 *
 * UPDATE: On 02/08/2023 an issue (#6) was filed that mentions a bug with Akkha's quadrant special detection. This may
 * have been introduced during the 10/03/2022 update, or was recently changed by Jagex. In any case, it's been fixed for
 * memory special.
 * The hourglass special graphics objects are misleading, though, as their animation plays out in
 * reverse, which in theory would make the inner tiles (up to distance 3 from center) the delayed ones. However, it
 * looks like in practice it's the same delayed tiles as the normal special, which means the outer tiles are on tick-1
 * and everything else is on tick-2. To account for this, there's a slight hack of subtracting a few cycles from the
 * startCycles.
 * Additionally, it looks like there is a 1-tick cooldown between when you can actually get hit by the quadrant special,
 * meaning if you mess up the skip and get "hit" two ticks in a row, the game doesn't actually give you a second
 * hitsplat, so we account for that in order to not double-count the mistake.
 *
 * For the elemental orbs special, those are detected through NPC despawn events, again checking the player's tile
 *
 * For the unstable orbs in the final phase, checking for despawn events isn't reliable as the NPC doesn't despawn until
 * a tick after it hits the player. Since a single orb can only
 * affect one player, we check for hitsplatApplied events to resolve which player took the damage from the orb, in the
 * case that multiple players are on the same tile.
 * Trying to find the correct local tile for a moving NPC is a real pain. By using the graphics update of the unstable
 * orb "popping", the server WorldPoint is 1 tile too far of where the player was standing, and the client's local
 * position mapped to WorldPoint is sometimes correct and sometimes 1 tile too early. Since the server's WorldPoint is
 * always consistent, we use that and subtract 1 in the direction of the client's local position in order to obtain
 * the tile that the orb was actually popped on, and compare with the player. Checking for despawn events isn't reliable
 * as the NPC doesn't despawn until a tick after it hits the player.
 */
@Slf4j
@Singleton
public class AkkhaDetector extends BaseMistakeDetector {

    private static final Set<Integer> FULL_HOURGLASS_GAME_OBJECT_IDS = ImmutableSet.of(46064, 46065, 46066, 46067);
    private static final Set<Integer> QUADRANT_BOMB_GRAPHICS_IDS = ImmutableSet.of(2256, 2257, 2258, 2259);
    private static final Set<String> ELEMENTAL_ORB_NAMES = ImmutableSet.of(
            "Orb of Lightning", "Orb of Darkness", "Burning Orb", "Frozen Orb");
    private static final String UNSTABLE_ORB_NAME = "Unstable Orb";
    private static final int UNSTABLE_ORB_POPPED_GRAPHICS_ID = 2260;

    private static final String AKKHA_NAME = "Akkha";
    private static final int HOURGLASS_SPECIAL_SUBTRACTED_CYCLES = 9; // 3 cycles per tile, up to 3 tiles away
    private static final int HOURGLASS_SPECIAL_HIT_DELAY_IN_TICKS = 1; // extra hit delay to offset, due to subtraction

    private static final int QUADRANT_EXPLODE_HIT_DELAY_IN_TICKS = 0;

    private boolean isAkkhaPresent;
    private final Set<String> raidersPreviouslyMadeQuadrantMistake = new HashSet<>();
    private final List<GameObject> activeFullHourglasses = new ArrayList<>();

    private final DelayedHitTilesTracker quadrantBombTiles = new DelayedHitTilesTracker();
    private final Set<WorldPoint> elementalOrbHitTiles;
    private final Set<WorldPoint> unstableOrbHitTiles;

    private final AppliedHitsplatsTracker appliedHitsplats;

    public AkkhaDetector() {
        elementalOrbHitTiles = new HashSet<>();
        unstableOrbHitTiles = new HashSet<>();
        appliedHitsplats = new AppliedHitsplatsTracker();
    }

    @Override
    public void cleanup() {
        isAkkhaPresent = false;
        activeFullHourglasses.clear();
        raidersPreviouslyMadeQuadrantMistake.clear();

        quadrantBombTiles.clear();
        elementalOrbHitTiles.clear();
        unstableOrbHitTiles.clear();
        appliedHitsplats.clear();
    }

    @Override
    public RaidRoom getRaidRoom() {
        return AKKHA;
    }

    @Override
    public List<ToaMistake> detectMistakes(@NonNull Raider raider) {
        List<ToaMistake> mistakes = new ArrayList<>();

        if (isQuadrantHit(raider)) {
            mistakes.add(AKKHA_SPECIAL_QUADRANT_BOMB);
            raidersPreviouslyMadeQuadrantMistake.add(raider.getName());
        } else {
            raidersPreviouslyMadeQuadrantMistake.remove(raider.getName());
        }

        if (elementalOrbHitTiles.contains(raider.getPreviousWorldLocation())) {
            mistakes.add(AKKHA_SPECIAL_ELEMENTAL_ORBS);
        }

        if (unstableOrbHitTiles.contains(raider.getPreviousWorldLocation()) &&
                appliedHitsplats.popHitsplatApplied(raider.getName())) {
            mistakes.add(AKKHA_UNSTABLE_ORB);
        }

        return mistakes;
    }

    @Override
    public void afterDetect() {
        elementalOrbHitTiles.clear();
        unstableOrbHitTiles.clear();
        appliedHitsplats.clear();
    }

    @Subscribe
    public void onGameTick(GameTick event) {
        quadrantBombTiles.onGameTick(client.getTickCount());
    }

    @Subscribe
    public void onGraphicsObjectCreated(GraphicsObjectCreated event) {
        if (!QUADRANT_BOMB_GRAPHICS_IDS.contains(event.getGraphicsObject().getId())) return;

        final int activationTick;
        if (isHourglassSpecial()) {
            // Hourglass special works differently. The animation is reversed but the hit tiles are *not* reversed,
            // they're inversed from the memory special. Instead of hardcoding the tiles, we can do some math.
            activationTick = getActivationTickWithSubtractedCycles(event.getGraphicsObject(),
                    HOURGLASS_SPECIAL_HIT_DELAY_IN_TICKS, HOURGLASS_SPECIAL_SUBTRACTED_CYCLES);
        } else {
            activationTick = getActivationTick(event.getGraphicsObject(), QUADRANT_EXPLODE_HIT_DELAY_IN_TICKS);
        }
        quadrantBombTiles.put(activationTick, getWorldPoint(event.getGraphicsObject()));
    }

    @Subscribe
    public void onGraphicChanged(GraphicChanged event) {
        if (!(event.getActor() instanceof NPC) || event.getActor().getName() == null) return;

        String name = Text.removeTags(event.getActor().getName());
        if (event.getActor() instanceof NPC &&
                UNSTABLE_ORB_NAME.equals(name) &&
                event.getActor().getGraphic() == UNSTABLE_ORB_POPPED_GRAPHICS_ID) {
            // We need to use the *actual* world location here, since the moving orb despawns too late and changes
            // graphics too early. Transform the world location 1 tile towards the client's local location.
            unstableOrbHitTiles.add(getWorldPointTransformedTowardsLocal(event.getActor()));
        }
    }

    @Subscribe
    public void onGameObjectSpawned(GameObjectSpawned event) {
        if (isFullHourglass(event.getGameObject())) {
            activeFullHourglasses.add(event.getGameObject());
        }
    }

    @Subscribe
    public void onGameObjectDespawned(GameObjectDespawned event) {
        if (isFullHourglass(event.getGameObject())) {
            activeFullHourglasses.remove(event.getGameObject());
        }
    }

    private boolean isFullHourglass(GameObject gameObject) {
        return FULL_HOURGLASS_GAME_OBJECT_IDS.contains(gameObject.getId());
    }

    /**
     * Try to get the actor's WorldPoint, transformed towards the direction of the LocalPoint by 1 tile. This is to try
     * to retrieve the "previous" WorldPoint of a moving actor. It seems that the server-side WorldPoint is always
     * consistent, but the client's LocalPoint translated to WorldPoint can be off by 1 at times, but always before the
     * server's.
     *
     * @param actor The actor
     * @return The actor's WorldPoint that is 1 tile towards the client's local point
     */
    private WorldPoint getWorldPointTransformedTowardsLocal(Actor actor) {
        WorldPoint worldPoint = actor.getWorldLocation();
        WorldPoint worldPointFromLocal = getWorldPoint(actor);

        int distX = worldPoint.getX() - worldPointFromLocal.getX();
        int distY = worldPoint.getY() - worldPointFromLocal.getY();

        int dx = Integer.compare(0, distX);
        int dy = Integer.compare(0, distY);

        WorldPoint transformed = worldPoint.dx(dx).dy(dy);
        return transformed;
    }

    @Subscribe
    public void onNpcSpawned(NpcSpawned event) {
        if (event.getNpc().getName() == null) return;

        String name = Text.removeTags(event.getNpc().getName());
        if (AKKHA_NAME.equals(name)) {
            isAkkhaPresent = true;
        }
    }

    @Subscribe
    public void onNpcDespawned(NpcDespawned event) {
        if (event.getNpc().getName() == null) return;

        String name = Text.removeTags(event.getNpc().getName());
        if (ELEMENTAL_ORB_NAMES.contains(name)) {
            elementalOrbHitTiles.add(getWorldPoint(event.getActor()));
        } else if (AKKHA_NAME.equals(name)) {
            isAkkhaPresent = false;
        }
    }

    @Subscribe
    public void onHitsplatApplied(HitsplatApplied event) {
        if (raidState.isRaider(event.getActor())) {
            appliedHitsplats.addHitsplatForRaider(event.getActor().getName());
        }
    }

    public boolean isHourglassSpecial() {
        // If there's at least one full hourglass, *and* Akkha is around, it's an hourglass special.
        // The hourglass special cannot create its graphics objects while Akkha is not around (from what I've seen)
        // If Akkha despawns to do the memory special right when the hourglass fills up, the memory special happens
        // first and then once Akkha spawns back in, the hourglass special kicks off.
        return !activeFullHourglasses.isEmpty() && isAkkhaPresent;
    }

    private boolean isQuadrantHit(Raider raider) {
        return quadrantBombTiles.getActiveHitTiles().contains(raider.getPreviousWorldLocation()) &&
                !raidersPreviouslyMadeQuadrantMistake.contains(raider.getName());
    }

    private int getActivationTickWithSubtractedCycles(GraphicsObject graphicsObject,
                                                      int hitDelay,
                                                      int subtractedCycles) {
        int ticksToStart =
                (graphicsObject.getStartCycle() - client.getGameCycle() - subtractedCycles) / CYCLES_PER_GAME_TICK;
        return client.getTickCount() + ticksToStart + hitDelay;
    }
}

package com.toamistaketracker.detector.boss;

import com.google.common.collect.ImmutableMap;
import com.google.common.collect.ImmutableSet;
import com.toamistaketracker.RaidRoom;
import com.toamistaketracker.Raider;
import com.toamistaketracker.ToaMistake;
import com.toamistaketracker.detector.BaseMistakeDetector;
import com.toamistaketracker.detector.tracker.DelayedHitTilesTracker;
import com.toamistaketracker.detector.tracker.DelayedMistakeTracker;
import com.toamistaketracker.detector.tracker.InstantHitTilesTracker;
import com.toamistaketracker.detector.tracker.OverheadTracker;
import lombok.Getter;
import lombok.NonNull;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.HeadIcon;
import net.runelite.api.events.GameTick;
import net.runelite.api.events.GraphicsObjectCreated;
import net.runelite.api.events.ProjectileMoved;
import net.runelite.client.eventbus.Subscribe;

import javax.inject.Singleton;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.Set;

import static com.toamistaketracker.RaidRoom.WARDENS_P3;
import static com.toamistaketracker.ToaMistake.WARDENS_P3_AKKHA;
import static com.toamistaketracker.ToaMistake.WARDENS_P3_BABA;
import static com.toamistaketracker.ToaMistake.WARDENS_P3_EARTHQUAKE;
import static com.toamistaketracker.ToaMistake.WARDENS_P3_KEPHRI;
import static com.toamistaketracker.ToaMistake.WARDENS_P3_LIGHTNING;
import static com.toamistaketracker.ToaMistake.WARDENS_P3_ZEBAK;

/**
 * Wardens P3 is actually one of the most straightforward rooms, especially now that I've written all of the other
 * detectors, trackers, etc. and am more familiar with the detection flow.
 *
 * Earthquakes are just graphics objects that start their animation at some point in the future, and so we make use of
 * our {@link DelayedHitTilesTracker} to track the tiles that activate after a delay.
 *
 * Kephri bombs create a graphics object on the tick that they detonate, so we just look for that
 *
 * Ba-Ba boulders are similar to how they work in their boss room. We delay the graphics object spawn by a set number
 * of ticks before detecting
 *
 * Finally, the lightning attack is similar to Kephri bombs in that it spawns a graphics object on the tick it detonates
 *
 * Also lastly added, overhead tracker for Akkha and Zebak to give a mistake if a prayer is missed. Since this isn't
 * the crux of the fight, and the punish has already happened (unless you tanked), then this is not considered cheaty.
 * Since the overhead detection on the server happens the same tick that the projectile, we calculate the mistake
 * right away but delay it for the remaining cycles of the projectile. Also, I ended up deciding to just not announce
 * this mistake at all anyway, and only put it in the tracker panel, so that it can't be used to know to switch prayers
 * as easily.
 */
@Slf4j
@Singleton
public class WardensP3Detector extends BaseMistakeDetector {

    private final Set<Integer> EARTHQUAKE_GRAPHICS_IDS = ImmutableSet.of(2220, 2221, 2222, 2223);
    private final Set<Integer> KEPHRI_BOMB_GRAPHICS_IDS = ImmutableSet.of(2156, 2157, 2158, 2159);
    // Projectile ID -> correct overhead icon
    private static final Map<Integer, HeadIcon> AKKHA_ATTACKS = ImmutableMap.of(
            2253, HeadIcon.MAGIC,
            2255, HeadIcon.RANGED
    );
    // Projectile ID -> correct overhead icon
    private static final Map<Integer, HeadIcon> ZEBAK_ATTACKS = ImmutableMap.of(
            2181, HeadIcon.MAGIC,
            2187, HeadIcon.RANGED
    );

    // Graphics ID -> tick delay
    private final Map<Integer, Integer> BABA_BOULDERS = ImmutableMap.of(
            2250, 6,
            2251, 4
    );

    private static final int EARTHQUAKE_HIT_DELAY_IN_TICKS = 0;
    private static final int P3_LIGHTNING_GRAPHICS_ID = 2197;

    @Getter
    private final DelayedHitTilesTracker earthquakeHitTiles = new DelayedHitTilesTracker();
    @Getter
    private final InstantHitTilesTracker kephriBombHitTiles = new InstantHitTilesTracker();
    @Getter
    private final DelayedHitTilesTracker babaBoulderTiles = new DelayedHitTilesTracker();
    @Getter
    private final InstantHitTilesTracker lightningHitTiles = new InstantHitTilesTracker();

    private final OverheadTracker akkhaOverheadTracker = new OverheadTracker(AKKHA_ATTACKS);
    private final OverheadTracker zebakOverheadTracker = new OverheadTracker(ZEBAK_ATTACKS);
    private final DelayedMistakeTracker delayedMistakeTracker = new DelayedMistakeTracker();

    @Override
    public void cleanup() {
        earthquakeHitTiles.clear();
        kephriBombHitTiles.clear();
        babaBoulderTiles.clear();
        lightningHitTiles.clear();
        akkhaOverheadTracker.clear();
        zebakOverheadTracker.clear();
    }

    @Override
    public RaidRoom getRaidRoom() {
        return WARDENS_P3;
    }

    @Override
    public List<ToaMistake> detectMistakes(@NonNull Raider raider) {
        List<ToaMistake> mistakes = new ArrayList<>();

        if (earthquakeHitTiles.getActiveHitTiles().contains(raider.getPreviousWorldLocation())) {
            mistakes.add(WARDENS_P3_EARTHQUAKE);
        }

        if (kephriBombHitTiles.getActiveHitTiles().contains(raider.getPreviousWorldLocation())) {
            mistakes.add(WARDENS_P3_KEPHRI);
        }

        if (babaBoulderTiles.getActiveHitTiles().contains(raider.getPreviousWorldLocation())) {
            mistakes.add(WARDENS_P3_BABA);
        }

        if (lightningHitTiles.getActiveHitTiles().contains(raider.getPreviousWorldLocation())) {
            mistakes.add(WARDENS_P3_LIGHTNING);
        }

        mistakes.addAll(delayedMistakeTracker.popDelayedMistakes(raider.getName(), client.getTickCount()));

        if (akkhaOverheadTracker.didMissPrayer(raider)) {
            delayedMistakeTracker.addDelayedMistake(raider.getName(),
                    WARDENS_P3_AKKHA,
                    client.getTickCount(),
                    getActivationTick(akkhaOverheadTracker.getActiveProjectileForRaider(raider)) -
                            client.getTickCount());
        }

        if (zebakOverheadTracker.didMissPrayer(raider)) {
            delayedMistakeTracker.addDelayedMistake(raider.getName(),
                    WARDENS_P3_ZEBAK,
                    client.getTickCount(),
                    getActivationTick(zebakOverheadTracker.getActiveProjectileForRaider(raider)) -
                            client.getTickCount());
        }

        return mistakes;
    }

    @Override
    public void afterDetect() {
    }

    @Subscribe
    public void onGameTick(GameTick event) {
        earthquakeHitTiles.onGameTick(client.getTickCount());
        kephriBombHitTiles.onGameTick(client.getTickCount());
        babaBoulderTiles.onGameTick(client.getTickCount());
        lightningHitTiles.onGameTick(client.getTickCount());
        akkhaOverheadTracker.onGameTick(client.getTickCount());
        zebakOverheadTracker.onGameTick(client.getTickCount());
    }

    @Subscribe
    public void onGraphicsObjectCreated(GraphicsObjectCreated event) {
        int id = event.getGraphicsObject().getId();
        if (EARTHQUAKE_GRAPHICS_IDS.contains(id)) {
            int activationTick = getActivationTick(event.getGraphicsObject(), EARTHQUAKE_HIT_DELAY_IN_TICKS);
            earthquakeHitTiles.put(activationTick, getWorldPoint(event.getGraphicsObject()));
        } else if (KEPHRI_BOMB_GRAPHICS_IDS.contains(id)) {
            kephriBombHitTiles.add(getWorldPoint(event.getGraphicsObject()));
        } else if (BABA_BOULDERS.containsKey(id)) {
            int activationTick = getActivationTick(event.getGraphicsObject(), BABA_BOULDERS.get(id));
            babaBoulderTiles.put(activationTick, getWorldPoint(event.getGraphicsObject()));
        } else if (id == P3_LIGHTNING_GRAPHICS_ID) {
            lightningHitTiles.add(getWorldPoint(event.getGraphicsObject()));
        }
    }

    @Subscribe
    public void onProjectileMoved(ProjectileMoved event) {
        if (!AKKHA_ATTACKS.containsKey(event.getProjectile().getId()) &&
                !ZEBAK_ATTACKS.containsKey(event.getProjectile().getId())) {
            return;
        }

        // Akkha prayer matters on spawn tick
        int activationTick = client.getTickCount();
        akkhaOverheadTracker.trackProjectile(event, activationTick);

        // Zebak prayer matters on projectile hit (3 ticks later)
        activationTick = getActivationTick(event.getProjectile());
        zebakOverheadTracker.trackProjectile(event, activationTick);
    }
}
package com.toamistaketracker.detector.boss;

import com.google.common.collect.ImmutableMap;
import com.google.common.collect.ImmutableSet;
import com.toamistaketracker.RaidRoom;
import com.toamistaketracker.Raider;
import com.toamistaketracker.ToaMistake;
import com.toamistaketracker.detector.BaseMistakeDetector;
import com.toamistaketracker.detector.tracker.AppliedHitsplatsTracker;
import com.toamistaketracker.detector.tracker.DelayedHitTilesTracker;
import lombok.Getter;
import lombok.NonNull;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.HitsplatID;
import net.runelite.api.NPC;
import net.runelite.api.Player;
import net.runelite.api.coords.LocalPoint;
import net.runelite.api.coords.WorldPoint;
import net.runelite.api.events.AnimationChanged;
import net.runelite.api.events.GameTick;
import net.runelite.api.events.GraphicsObjectCreated;
import net.runelite.api.events.HitsplatApplied;
import net.runelite.api.events.NpcDespawned;
import net.runelite.api.events.NpcSpawned;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.util.Text;

import javax.inject.Singleton;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.stream.Collectors;

import static com.toamistaketracker.RaidRoom.BABA;
import static com.toamistaketracker.ToaMistake.BABA_BANANA;
import static com.toamistaketracker.ToaMistake.BABA_FALLING_BOULDER;
import static com.toamistaketracker.ToaMistake.BABA_GAP;
import static com.toamistaketracker.ToaMistake.BABA_PROJECTILE_BOULDER;
import static com.toamistaketracker.ToaMistake.BABA_ROLLING_BOULDER;
import static com.toamistaketracker.ToaMistake.BABA_SLAM;

/**
 * Ba-Ba is a mess. By far the hardest to detect mistakes for. Look at the docs for a different room instead.
 *
 * Oh man what a nightmare.
 *
 * The slam attack is simply just looking for the graphics object ID spawning under the player. Nice easy one here.
 *
 * For rolling boulders, it seems like there's no super consistent way to detect. The animation ID that the player
 * enacts is usually the most reliable, though it can be overwritten entirely by an attack animation (like fang) with
 * the right timing, or just by getting double hit by a boulder quickly. We could also check to see if the player
 * moves >2 tiles like in Zebak waves, but that's not always the case if you're already at the bottom edge (and can't
 * move anymore). The final option is to check if the player is colliding with the boulder NPC tiles, though there is
 * a delay until when the boulder can hit you again. Also the boulder despawns one tick too early for collision
 * detection against the low wall, so we have to extend it an extra tick too. Together, these should account for the
 * majority/all of cases.
 *
 * The banana slip is just looking for an AnimationChanged event on a raider for the slip animation. However, this can
 * be overridden by doing another animation (like attacking) as soon as the slip animation should be going off. To
 * account for this, we also check the graphic of the player during an animation change, to see if it's the slip
 * graphic. While this could *also* be overridden, it seems unlikely (if even possible) that neither of these will be
 * set at any point during the slip duration. To make sure we don't double count, we add a cooldown for when a player
 * can be slipping again after its most recent slip mistake.
 *
 * The falling boulder looks at graphics objects and delays the hit accordingly. Since Ba-Ba can phase transition
 * during this, we also ensure that a hitsplat is applied and the animation of the player is not the knock back.
 *
 * Finally, the rubble attack (where you have a large boulder tracking onto you). This is the worst one by far, and is
 * currently unfinished (now mostly finished)
 * It sets a graphics ID if it actually collides with a player (or object). This unfortunately can be bypassed by
 * overwriting on the same tick with a spec(like fang), which makes that an unreliable way of detection. Another way
 * is to check the projectile spawn, and calculate when it would activate and hit the players, seemingly always 7
 * ticks later. Unfortunately, if Ba-Ba phase transitions while this is out, it's not trivial to detect as his
 * animation change sometimes happens *after* the projectile is set to hit the player. Additionally, even if we were
 * able to reliably detect when the boulder hits, we would still need to resolve which players made the mistake and
 * which got hit "correctly" by standing next to the rubble. If too many players are next to the same rubble, *all*
 * (or at least the number of "over" players) take damage. This likely will require maintaining the full state of the
 * game with rubble and simulating what the server would do, on the client.
 * This is something I may come back to and add in the future.
 * EDIT: I have mostly added this now by looking to see if the player received a "large" hitsplat after the 7-tick delay
 * of the boulder spawn and if they're not standing on a safe tile of a rubble object. If they're on a safe tile but
 * have multiple hitsplats, some extra logic gets put into place. The method is pretty spaghetti. Ah well.
 */
@Slf4j
@Singleton
public class BabaDetector extends BaseMistakeDetector {

    private static final Set<WorldPoint> GAP_REGION_TILES = ImmutableSet.of(
            WorldPoint.fromRegion(BABA.getRegionId(), 20, 30, 0),
            WorldPoint.fromRegion(BABA.getRegionId(), 20, 31, 0),
            WorldPoint.fromRegion(BABA.getRegionId(), 20, 32, 0),
            WorldPoint.fromRegion(BABA.getRegionId(), 20, 33, 0),
            WorldPoint.fromRegion(BABA.getRegionId(), 20, 34, 0),
            WorldPoint.fromRegion(BABA.getRegionId(), 21, 30, 0),
            WorldPoint.fromRegion(BABA.getRegionId(), 21, 31, 0),
            WorldPoint.fromRegion(BABA.getRegionId(), 21, 32, 0),
            WorldPoint.fromRegion(BABA.getRegionId(), 21, 33, 0),
            WorldPoint.fromRegion(BABA.getRegionId(), 21, 34, 0)
    );

    private static final WorldPoint BOULDER_WALL_REGION_TILE = WorldPoint.fromRegion(BABA.getRegionId(), 22, 25, 0);

    private static final Map<Integer, Integer> FALLING_BOULDER_GRAPHICS_IDS = ImmutableMap.of(
            2250, 6,
            2251, 4
    );

    private static final int BABA_SLAM_GRAPHICS_ID = 1103;
    private static final int BOULDER_ROLLED_ANIMATION_ID = 7210;
    private static final int GAP_FALLING_ANIMATION_ID = 4366;
    private static final int BANANA_GAME_OBJECT_ID = 45755; // If you 1-tick the banana it never even spawns :/
    private static final int BANANA_SLIP_ANIMATION_ID = 4030;
    private static final int BANANA_GRAPHICS_ID = 1575;
    private static final int BANANA_SLIP_COOLDOWN_IN_TICKS = 3;
    private static final int PLAYER_KNOCK_BACK_ANIMATION_ID = 9799;
    private static final int RUBBLE_EXPLOSION_GRAPHICS_ID = 1463;
    private static final int BABA_PROJECTILE_BOULDER_ANIMATION_ID = 9744;

    // This is pretty arbitrary. AFAICT correctly handling the projectile boulder will never deal more than ~4 damage
    // and failing will never deal less than ~40ish. To be safe let's put the threshold somewhere in the middle. It
    // also always seems to over-hit. Also you can half it by standing next to a baboon/sarcophagus.
    private static final int PROJECTILE_BOULDER_DAMAGE_THRESHOLD = 15;

    // The boulder collision doesn't really start for 1-2 ticks. Let's use 3 to be safe and rely on the other forms
    // of boulder detection in those early ticks anyway, as they should always be safe.
    private static final Integer BOULDER_SPAWN_DELAY_IN_TICKS = 3;
    private static final String BOULDER_NAME = "Boulder";
    private static final String RUBBLE_NAME = "Rubble";
    private static final String BABA_NAME = "Ba-Ba";
    private static final Integer PROJECTILE_BOULDER_DELAY_IN_TICKS = 7;
    private static final int RUBBLE_SAFE_TILES_LENGTH = 5;

    @Getter
    private Set<WorldPoint> gapTiles;
    private WorldPoint boulderWallTile;

    private final Set<WorldPoint> slamHitTiles;
    private final Set<String> raidersFell;
    private final Set<String> raidersSlipping;
    private final Map<String, Integer> raidersRecentlySlipped; // name -> tick they last slipped
    private final Set<String> raidersRolledAnimation;
    private final Set<String> raidersRolled;
    private final Set<String> raidersRolledLastTick;

    @Getter
    private final List<NPC> boulders;
    private final Map<Integer, List<NPC>> spawnedBoulders; // tick to spawn -> list of boulders
    private final List<NPC> despawnedBoulders;

    @Getter
    private final Set<WorldPoint> boulderTiles;
    private final Set<WorldPoint> finalBoulderTiles;

    @Getter
    private final List<NPC> rubbles = new ArrayList<>();
    @Getter
    private final Map<NPC, Set<WorldPoint>> safeRubbleTiles = new HashMap<>();
    private final Map<NPC, Integer> rubbleHitsplats = new HashMap<>();

    @Getter
    private final DelayedHitTilesTracker fallingBoulderHitTiles = new DelayedHitTilesTracker();
    private final AppliedHitsplatsTracker fallingBoulderAppliedHitsplats = new AppliedHitsplatsTracker();

    @Getter
    // This is really just used for timing, not for the tile itself
    // TODO: Can now refactor this to use DelayedObjects interface
    private final DelayedHitTilesTracker projectileBoulderHitTiles = new DelayedHitTilesTracker();
    // name -> list of hitsplat amounts
    private final Map<String, List<Integer>> projectileBoulderAppliedHitsplats = new HashMap<>();

    public BabaDetector() {
        gapTiles = new HashSet<>();

        slamHitTiles = new HashSet<>();
        raidersFell = new HashSet<>();
        raidersSlipping = new HashSet<>();
        raidersRecentlySlipped = new HashMap<>();
        raidersRolledAnimation = new HashSet<>();
        raidersRolled = new HashSet<>();
        raidersRolledLastTick = new HashSet<>();

        boulders = new ArrayList<>();
        spawnedBoulders = new HashMap<>();
        despawnedBoulders = new ArrayList<>();
        boulderTiles = new HashSet<>();
        finalBoulderTiles = new HashSet<>();
    }

    @Override
    public void startup() {
        super.startup();
        computeGapTiles();
    }

    @Override
    public void cleanup() {
        gapTiles.clear();
        boulderWallTile = null;

        slamHitTiles.clear();
        raidersFell.clear();
        raidersSlipping.clear();
        raidersRecentlySlipped.clear();
        raidersRolledAnimation.clear();
        raidersRolled.clear();
        raidersRolledLastTick.clear();

        boulders.clear();
        spawnedBoulders.clear();
        despawnedBoulders.clear();
        boulderTiles.clear();
        finalBoulderTiles.clear();

        rubbles.clear();
        safeRubbleTiles.clear();
        rubbleHitsplats.clear();

        fallingBoulderHitTiles.clear();
        fallingBoulderAppliedHitsplats.clear();

        projectileBoulderHitTiles.clear();
        projectileBoulderAppliedHitsplats.clear();
    }

    @Override
    public RaidRoom getRaidRoom() {
        return BABA;
    }

    @Override
    public List<ToaMistake> detectMistakes(@NonNull Raider raider) {
        List<ToaMistake> mistakes = new ArrayList<>();

        if (slamHitTiles.contains(raider.getPreviousWorldLocation())) {
            mistakes.add(BABA_SLAM);
        }

        if (gapTiles.contains(raider.getPreviousWorldLocation()) && !raidersFell.contains(raider.getName())) {
            mistakes.add(BABA_GAP);
            raidersFell.add(raider.getName());
        }

        if (isSlip(raider)) {
            mistakes.add(BABA_BANANA);
            raidersRecentlySlipped.put(raider.getName(), client.getTickCount());
        }

        if (isRollingBoulder(raider)) {
            mistakes.add(BABA_ROLLING_BOULDER);
            raidersRolled.add(raider.getName());
        }

        if (isFallingBoulder(raider)) {
            mistakes.add(BABA_FALLING_BOULDER);
        }

        if (isProjectileBoulder(raider)) {
            mistakes.add(BABA_PROJECTILE_BOULDER);
        }

        return mistakes;
    }

    @Override
    public void afterDetect() {
        slamHitTiles.clear();
        raidersSlipping.clear();
        raidersRolledAnimation.clear();

        raidersRolledLastTick.clear();
        raidersRolledLastTick.addAll(raidersRolled);
        raidersRolled.clear();

        rubbleHitsplats.clear();

        finalBoulderTiles.clear();
        fallingBoulderAppliedHitsplats.clear();
        projectileBoulderAppliedHitsplats.clear();
    }

    @Subscribe
    public void onGameTick(GameTick event) {
        if (spawnedBoulders.containsKey(client.getTickCount())) {
            List<NPC> spawned = spawnedBoulders.remove(client.getTickCount());
            // Ignore boulders that have already despawned
            List<NPC> bouldersToSpawn = spawned.stream()
                    .filter(b -> !despawnedBoulders.remove(b))
                    .collect(Collectors.toList());
            boulders.addAll(bouldersToSpawn);
        }

        boulderTiles.clear();
        boulders.stream()
                .filter(b -> !b.isDead())
                .forEach(boulder -> boulderTiles.addAll(computeBoulderTiles(boulder.getWorldLocation())));
        boulderTiles.addAll(finalBoulderTiles);

        fallingBoulderHitTiles.onGameTick(client.getTickCount());
        projectileBoulderHitTiles.onGameTick(client.getTickCount());
    }

    @Subscribe
    public void onGraphicsObjectCreated(GraphicsObjectCreated event) {
        int id = event.getGraphicsObject().getId();
        if (id == BABA_SLAM_GRAPHICS_ID) {
            slamHitTiles.add(getWorldPoint(event.getGraphicsObject()));
        } else if (FALLING_BOULDER_GRAPHICS_IDS.containsKey(id)) {
            int activationTick = client.getTickCount() + FALLING_BOULDER_GRAPHICS_IDS.get(id);
            fallingBoulderHitTiles.put(activationTick, getWorldPoint(event.getGraphicsObject()));
        }
    }

    @Subscribe
    public void onNpcSpawned(NpcSpawned event) {
        if (event.getNpc().getName() == null) return;

        String name = Text.removeTags(event.getNpc().getName());
        if (BOULDER_NAME.equals(name)) {
            spawnedBoulders
                    .computeIfAbsent(client.getTickCount() + BOULDER_SPAWN_DELAY_IN_TICKS, k -> new ArrayList<>())
                    .add(event.getNpc());
        } else if (RUBBLE_NAME.equals(name)) {
            rubbles.add(event.getNpc());
            safeRubbleTiles.put(event.getNpc(), computeSafeRubbleTiles(event.getNpc().getWorldLocation()));
        }
    }

    @Subscribe
    public void onNpcDespawned(NpcDespawned event) {
        if (event.getNpc().getName() == null) return;

        String name = Text.removeTags(event.getNpc().getName());
        if (BOULDER_NAME.equals(name)) {
            despawnedBoulders.add(event.getNpc());
            boolean removed = boulders.remove(event.getNpc());
            if (removed &&
                    !event.getNpc().isDead() &&
                    event.getNpc().getWorldLocation().getX() == boulderWallTile.getX()) {
                // This despawned from hitting the wall, not from a player killing it. Extend tiles for one more tick
                // Pretend the SW tile is 1 tile lower
                finalBoulderTiles.addAll(computeBoulderTiles(event.getNpc().getWorldLocation().dx(-1)));
            }
        } else if (RUBBLE_NAME.equals(name)) {
            rubbles.remove(event.getNpc());
            safeRubbleTiles.remove(event.getNpc());
        }
    }

    @Subscribe
    public void onAnimationChanged(AnimationChanged event) {
        if (event.getActor() == null || event.getActor().getName() == null) return;

        String name = Text.removeTags(event.getActor().getName());
        if (event.getActor() instanceof Player && raidState.isRaider(event.getActor())) {
            if (event.getActor().getAnimation() == BANANA_SLIP_ANIMATION_ID ||
                    event.getActor().getGraphic() == BANANA_GRAPHICS_ID) {
                raidersSlipping.add(name);
            } else if (event.getActor().getAnimation() == BOULDER_ROLLED_ANIMATION_ID) {
                raidersRolledAnimation.add(name);
            }
        } else if (event.getActor() instanceof NPC &&
                BABA_NAME.equals(name) &&
                event.getActor().getAnimation() == BABA_PROJECTILE_BOULDER_ANIMATION_ID) {
            int activationTick = client.getTickCount() + PROJECTILE_BOULDER_DELAY_IN_TICKS;
            // Add dummy location for the correct activation tick
            projectileBoulderHitTiles.put(activationTick, event.getActor().getWorldLocation());
        }
    }

    @Subscribe
    public void onHitsplatApplied(HitsplatApplied event) {
        if (event.getActor() == null || event.getActor().getName() == null) return;

        String name = Text.removeTags(event.getActor().getName());
        if (raidState.isRaider(event.getActor())) {
            fallingBoulderAppliedHitsplats.addHitsplatForRaider(name);

            if (isDamageHitsplat(event.getHitsplat().getHitsplatType()) &&
                    event.getHitsplat().getAmount() > 0) {
                projectileBoulderAppliedHitsplats.computeIfAbsent(name, k -> new ArrayList<>())
                        .add(event.getHitsplat().getAmount());

            }
        } else if (event.getActor() instanceof NPC && RUBBLE_NAME.equals(name)) {
            if (event.getActor().getGraphic() == RUBBLE_EXPLOSION_GRAPHICS_ID) {
                rubbleHitsplats.compute((NPC) event.getActor(), (k, v) -> v == null ? 1 : v + 1);
            } else {
                // phase transition happening, all tracking boulder projectiles are nulled
                projectileBoulderHitTiles.clear();
            }
        }
    }

    private boolean isDamageHitsplat(int hitsplatType) {
        return hitsplatType == HitsplatID.DAMAGE_ME || hitsplatType == HitsplatID.DAMAGE_OTHER;
    }

    // This is super hacky and was written at 4am without testing in a group so who knows if this works...
    private boolean isProjectileBoulder(Raider raider) {
        if (projectileBoulderHitTiles.getActiveHitTiles().isEmpty()) {
            // No explosion this tick
            return false;
        }

        if (rubbles.isEmpty()) {
            return false;
        }

        if (!projectileBoulderAppliedHitsplats.containsKey(raider.getName())) {
            // Somehow there was no hitsplat, so no mistake. This can happen if boss dies
            return false;
        }

        if (safeRubbleTiles.values().stream().noneMatch(tiles -> tiles.contains(raider.getPreviousWorldLocation()))) {
            // Raider isn't standing on a safe tile. Definitely a mistake.
            return true;
        }

        List<Integer> hitsplats = projectileBoulderAppliedHitsplats.get(raider.getName());
        if (hitsplats.size() == 1) {
            return isLargeBoulderHitsplat(hitsplats.get(0));
        }

        if (hitsplats.stream().noneMatch(this::isLargeBoulderHitsplat)) {
            // No large hitsplats, so we're safe.
            return false;
        }

        if (hitsplats.stream().allMatch(this::isLargeBoulderHitsplat)) {
            // Only large hitsplats, so we made a mistake.
            return true;
        }

        // The player must have taken more than one hitsplats this tick (possibly from baba, baboons, etc). One of them
        // is "large", and at least one isn't. To resolve this, we need to check which rubble this player is standing on
        // and check other players too.
        NPC standingRubble = getStandingRubble(raider);
        if (standingRubble == null) {
            // Should never happen since we already know the player is standing on a rubble tile
            return false;
        }

        List<String> raiderNamesOnSameRubble = getRaidersStandingOnRubble(standingRubble, raider.getName());
        if (raiderNamesOnSameRubble.isEmpty()) {
            // There are no other players on this rubble. I have to be safe.
            return false;
        }

        boolean allHaveOneHitsplat = raiderNamesOnSameRubble.stream()
                .filter(projectileBoulderAppliedHitsplats::containsKey)
                .allMatch(r -> projectileBoulderAppliedHitsplats.get(r).size() == 1);
        if (!allHaveOneHitsplat) {
            // Some other raiders have multiple hitsplats (possibly from baba, baboons, etc). Let's not bother resolving
            // this and just determine no mistake.
            return false;
        }

        if (!rubbleHitsplats.containsKey(standingRubble)) {
            // Should never happen, as there should be hitsplats for this rubble
            return false;
        }
        int currRubbleHitsplats = rubbleHitsplats.get(standingRubble);
        int numSafeRaiders = (int) raiderNamesOnSameRubble.stream()
                .map(r -> projectileBoulderAppliedHitsplats.get(r).get(0))
                .filter(amount -> !isLargeBoulderHitsplat(amount))
                .count();
        if (currRubbleHitsplats == numSafeRaiders) {
            // If there are already enough safe raiders, then we made the mistake
            return true;
        } else if (currRubbleHitsplats - numSafeRaiders == 1) {
            // There's one unaccounted for safe raider. It's us.
            return false;
        } else {
            // Should never happen as this means there's a mismatch between safe raiders and number of rubble hitsplats
            // Return no mistake just in case.
            return false;
        }
    }

    private List<String> getRaidersStandingOnRubble(NPC rubble, String currentRaider) {
        return raidState.getRaiders().values().stream()
                .filter(r -> !currentRaider.equals(r.getName()))
                .filter(r -> !r.isDead())
                .filter(r -> rubble.equals(getStandingRubble(r)))
                .map(Raider::getName)
                .collect(Collectors.toList());
    }

    private NPC getStandingRubble(Raider raider) {
        for (Map.Entry<NPC, Set<WorldPoint>> entry : safeRubbleTiles.entrySet()) {
            if (entry.getValue().contains(raider.getPreviousWorldLocation())) {
                return entry.getKey();
            }
        }

        return null;
    }

    private boolean isLargeBoulderHitsplat(int hitsplatAmount) {
        return hitsplatAmount > PROJECTILE_BOULDER_DAMAGE_THRESHOLD;
    }

    private Set<WorldPoint> computeSafeRubbleTiles(WorldPoint sw) {
        WorldPoint start = new WorldPoint(sw.getX() - 1, sw.getY() - 1, sw.getPlane());

        Set<WorldPoint> safeTiles = new HashSet<>(RUBBLE_SAFE_TILES_LENGTH * RUBBLE_SAFE_TILES_LENGTH);
        for (int i = 0; i < RUBBLE_SAFE_TILES_LENGTH; i++) {
            for (int j = 0; j < RUBBLE_SAFE_TILES_LENGTH; j++) {
                safeTiles.add(new WorldPoint(start.getX() + i, start.getY() + j, start.getPlane()));
            }
        }

        return safeTiles;
    }

    private boolean isFallingBoulder(Raider raider) {
        if (raider.getPlayer().getAnimation() == PLAYER_KNOCK_BACK_ANIMATION_ID) {
            // If we're in the knock back animation, we can't possibly be taking a small boulder hit
            return false;
        }

        if (!fallingBoulderAppliedHitsplats.popHitsplatApplied(raider.getName())) {
            // If there's not a hitsplat on the player at all, we also can't possibly be taking a hit
            return false;
        }

        if (!fallingBoulderHitTiles.getActiveHitTiles().contains(raider.getPreviousWorldLocation())) {
            // The player isn't even on a hit tile
            return false;
        }

        if (rubbles.isEmpty()) {
            // This might be possible when the room finishes. If there are no rubbles left, then no hit.
            return false;
        }

        return true;
    }

    private boolean isSlip(Raider raider) {
        if (!raidersSlipping.contains(raider.getName())) {
            return false;
        }

        boolean wasRecentlySlipped = raidersRecentlySlipped.containsKey(raider.getName()) &&
                client.getTickCount() - raidersRecentlySlipped.get(raider.getName()) <= BANANA_SLIP_COOLDOWN_IN_TICKS;

        return !wasRecentlySlipped;
    }

    private boolean isRollingBoulder(Raider raider) {
        if (raider.getPreviousWorldLocation() == null ||
                !isBoulderPhase() ||
                // Can't be rolled two ticks in a row
                raidersRolledLastTick.contains(raider.getName())) {
            return false;
        }

        // HACK
        // Normally a player cannot move > 2 tiles in 1 tick. The boulders often push you back more. Baba pushes you
        // back all the way to the wall when phase transition, but checking for boulder phase above handles that.
        // Always in negative X direction.
        boolean wasMovedFar = raider.getPreviousWorldLocation().getX() - raider.getCurrentWorldLocation().getX() > 2;

        // All of these together should catch the majority of cases
        return wasMovedFar ||
                raidersRolledAnimation.contains(raider.getName()) ||
                boulderTiles.contains(raider.getPreviousWorldLocation());
    }

    private boolean isBoulderPhase() {
        return !boulders.isEmpty() ||
                !spawnedBoulders.isEmpty() ||
                !boulderTiles.isEmpty() ||
                !finalBoulderTiles.isEmpty();
    }

    /**
     * Boulders are 3x3, so calculate them from the sw tile
     *
     * @param sw The sw tile of the boulder
     * @return The set of WorldPoints around and including the sw
     */
    private Set<WorldPoint> computeBoulderTiles(WorldPoint sw) {
        WorldPoint cw = sw.dy(1);
        WorldPoint nw = sw.dy(2);

        return ImmutableSet.of(
                sw.dx(1), cw.dx(1), nw.dx(1),
                sw.dx(2), cw.dx(2), nw.dx(2),
                sw.dx(3), cw.dx(3), nw.dx(3));
    }

    private void computeGapTiles() {
        WorldPoint wpPlayer = client.getLocalPlayer().getWorldLocation();
        LocalPoint lpPlayer = LocalPoint.fromWorld(client, wpPlayer);
        if (lpPlayer == null) return;

        int dx = lpPlayer.getSceneX() - wpPlayer.getRegionX();
        int dy = lpPlayer.getSceneY() - wpPlayer.getRegionY();

        gapTiles = GAP_REGION_TILES.stream()
                .map(wp -> WorldPoint.fromScene(client, wp.getRegionX() + dx, wp.getRegionY() + dy, wp.getPlane()))
                .collect(Collectors.toSet());

        // Also compute the boulder wall tile
        boulderWallTile = WorldPoint.fromScene(client,
                BOULDER_WALL_REGION_TILE.getRegionX() + dx,
                BOULDER_WALL_REGION_TILE.getRegionY() + dy,
                BOULDER_WALL_REGION_TILE.getPlane());
    }
}
package com.toamistaketracker.detector.boss;

import com.google.common.collect.ImmutableMap;
import com.google.common.collect.ImmutableSet;
import com.toamistaketracker.RaidRoom;
import com.toamistaketracker.Raider;
import com.toamistaketracker.ToaMistake;
import com.toamistaketracker.detector.BaseMistakeDetector;
import com.toamistaketracker.detector.tracker.DelayedHitTilesTracker;
import com.toamistaketracker.detector.tracker.InstantHitTilesTracker;
import com.toamistaketracker.detector.tracker.OverheadTracker;
import lombok.Getter;
import lombok.NonNull;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Animation;
import net.runelite.api.DynamicObject;
import net.runelite.api.GameObject;
import net.runelite.api.HeadIcon;
import net.runelite.api.NPC;
import net.runelite.api.Player;
import net.runelite.api.events.AnimationChanged;
import net.runelite.api.events.GameObjectDespawned;
import net.runelite.api.events.GameObjectSpawned;
import net.runelite.api.events.GameTick;
import net.runelite.api.events.GraphicsObjectCreated;
import net.runelite.api.events.NpcChanged;
import net.runelite.api.events.ProjectileMoved;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.util.Text;

import javax.inject.Singleton;
import java.util.ArrayList;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import static com.toamistaketracker.RaidRoom.WARDENS_P1_P2;
import static com.toamistaketracker.ToaMistake.WARDENS_P1_PYRAMID;
import static com.toamistaketracker.ToaMistake.WARDENS_P2_BIND;
import static com.toamistaketracker.ToaMistake.WARDENS_P2_BOMBS;
import static com.toamistaketracker.ToaMistake.WARDENS_P2_DDR;
import static com.toamistaketracker.ToaMistake.WARDENS_P2_SPECIAL_PRAYER;
import static com.toamistaketracker.ToaMistake.WARDENS_P2_WINDMILL;

/**
 * The pyramids are GameObjects that change their animations through changing their Renderables. Since we can't
 * listen for an AnimationChanged event for GameObjects, we manually detect when the animation is the one that hurts
 * the player. Also, the pyramid animation starts 1 tick earlier and ends 1 tick earlier than when the player actually
 * takes damage, so we delay the detection by a tick.
 *
 * DDR tiles spawn all of their graphics objects at once and delay their activation for some set number of ticks. We
 * calculate that and delay the hit tile activations with the new {@link DelayedHitTilesTracker}. This means we only
 * need to check for the player standing on the hit tile once the activation tick is played.
 *
 * The Bombs are the same, as the outer ring activates one tile later than the inner ones, using graphics objects to
 * detect
 *
 * The windmill attack is similar, but activates instantly on the current game tick. For that, we use the aptly named
 * {@link InstantHitTilesTracker} which is also a new class that helps track these hit tiles and when they should
 * activate. Once again graphics objects are used for detection here.
 *
 * Sometimes the obelisk can be in different phases but use an attack from a separate special. For example, the DDR
 * phase starts with graphics ids that are the same as the windmill, but we should count that as screwing up the DDR
 * phase not the windmill phase, and as such we detect the obelisk phase to account for that.
 */
@Slf4j
@Singleton
public class WardensP1P2Detector extends BaseMistakeDetector {

    // P1 constants
    private static final int RED_PYRAMID_GAME_OBJECT_ID = 45750;
    private static final int YELLOW_PYRAMID_GAME_OBJECT_ID = 45751;
    private static final int PYRAMID_ACTIVE_ANIMATION_ID = 9524;
    private final int PYRAMID_HIT_DELAY_IN_TICKS = 1;
    private static final int DEATH_DOT_PROJECTILE_ID = 2237;
    private static final int DISPERSE_PROJECTILE_ID = 2238;

    // P2 constants
    private static final String OBELISK_NAME = "Obelisk";
    private static final int DDR_GRAPHICS_ID = 2235;
    private static final int WINDMILL_SHADOW_GRAPHICS_ID = 2236;
    private static final int WINDMILL_HIT_GRAPHICS_ID = 2234;
    private static final int BOMB_GRAPHICS_ID = 2198;
    private static final int DDR_HIT_DELAY_IN_TICKS = 1;
    private static final int LIGHTNING_HIT_DELAY_IN_TICKS = 0;
    private static final int OBELISK_DDR_ANIMATION_ID = 9732;
    private static final int OBELISK_WINDMILL_ANIMATION_ID = 9733;
    private static final int OBELISK_BOMB_ANIMATION_ID = 9727;
    private static final int OBELISK_DEATH_ANIMATION_ID = 9734;
    private static final int OBELISK_DDR_LIGHTNING_GRAPHICS_ID = 2199;
    private static final int OBELISK_WINDMILL_LIGHTNING_GRAPHICS_ID = 2200;
    private static final int PLAYER_BIND_ANIMATION_ID = 9714;
    // Projectile ID -> correct overhead icon
    private static final Map<Integer, HeadIcon> SPECIAL_PRAYER_ATTACKS = ImmutableMap.of(
            2204, HeadIcon.MELEE,
            2206, HeadIcon.RANGED,
            2208, HeadIcon.MAGIC
    );
    private static final Set<Integer> WARDENS_HEALTH_PHASE = ImmutableSet.of(11755, 11758);

    @RequiredArgsConstructor
    enum ObeliskPhase {
        DDR(OBELISK_DDR_ANIMATION_ID),
        WINDMILL(OBELISK_WINDMILL_ANIMATION_ID),
        BOMBS(OBELISK_BOMB_ANIMATION_ID),
        DEATH(OBELISK_DEATH_ANIMATION_ID);

        @NonNull
        @Getter
        private final Integer animationId;

        static ObeliskPhase fromAnimationId(int animationId) {
            for (ObeliskPhase obeliskPhase : ObeliskPhase.values()) {
                if (obeliskPhase.getAnimationId() == animationId) {
                    return obeliskPhase;
                }
            }

            return null;
        }
    }

    // P1 fields
    @Getter
    private final List<GameObject> activePyramids = new ArrayList<>();
    @Getter
    private final DelayedHitTilesTracker pyramidHitTiles = new DelayedHitTilesTracker();

    // P2 fields
    private ObeliskPhase obeliskPhase;
    @Getter
    private final DelayedHitTilesTracker ddrHitTiles = new DelayedHitTilesTracker();
    @Getter
    private final InstantHitTilesTracker windmillHitTiles = new InstantHitTilesTracker();
    @Getter
    private final DelayedHitTilesTracker bombHitTiles = new DelayedHitTilesTracker();
    private final Set<String> raidersBound = new HashSet<>();

    private final OverheadTracker specialPrayerOverheadTracker = new OverheadTracker(SPECIAL_PRAYER_ATTACKS);

    @Override
    public void cleanup() {
        activePyramids.clear();
        pyramidHitTiles.clear();

        obeliskPhase = null;
        ddrHitTiles.clear();
        windmillHitTiles.clear();
        bombHitTiles.clear();
        raidersBound.clear();
        specialPrayerOverheadTracker.clear();
    }

    @Override
    public RaidRoom getRaidRoom() {
        return WARDENS_P1_P2;
    }

    @Override
    public List<ToaMistake> detectMistakes(@NonNull Raider raider) {
        List<ToaMistake> mistakes = new ArrayList<>();

        if (pyramidHitTiles.getActiveHitTiles().contains(raider.getPreviousWorldLocation())) {
            mistakes.add(WARDENS_P1_PYRAMID);
        }

        if (ddrHitTiles.getActiveHitTiles().contains(raider.getPreviousWorldLocation())) {
            mistakes.add(WARDENS_P2_DDR);
        }

        if (windmillHitTiles.getActiveHitTiles().contains(raider.getPreviousWorldLocation())) {
            mistakes.add(WARDENS_P2_WINDMILL);
        }

        if (bombHitTiles.getActiveHitTiles().contains(raider.getPreviousWorldLocation())) {
            mistakes.add(WARDENS_P2_BOMBS);
        }

        if (raidersBound.contains(raider.getName())) {
            mistakes.add(WARDENS_P2_BIND);
        }

        if (isSpecialPrayerHit(raider)) {
            mistakes.add(WARDENS_P2_SPECIAL_PRAYER);
        }

        return mistakes;
    }

    @Override
    public void afterDetect() {
        raidersBound.clear();
    }

    @Subscribe
    public void onAnimationChanged(AnimationChanged event) {
        if (event.getActor() == null || event.getActor().getName() == null) return;

        String name = Text.removeTags(event.getActor().getName());
        if (event.getActor() instanceof NPC && OBELISK_NAME.equals(name)) {
            ObeliskPhase newObeliskPhase = ObeliskPhase.fromAnimationId(event.getActor().getAnimation());
            if (newObeliskPhase != null) {
                obeliskPhase = newObeliskPhase;
            }
        } else if (event.getActor() instanceof Player && raidState.getRaiders().containsKey(name)) {
            if (event.getActor().getAnimation() == PLAYER_BIND_ANIMATION_ID) {
                raidersBound.add(name);
            }
        }
    }

    @Subscribe
    public void onGameTick(GameTick event) {
        computePyramidHitTiles();
        pyramidHitTiles.onGameTick(client.getTickCount());

        ddrHitTiles.onGameTick(client.getTickCount());
        windmillHitTiles.onGameTick(client.getTickCount());
        bombHitTiles.onGameTick(client.getTickCount());
        specialPrayerOverheadTracker.onGameTick(client.getTickCount());
    }

    @Subscribe
    public void onGameObjectSpawned(GameObjectSpawned event) {
        if (isPyramid(event.getGameObject())) {
            activePyramids.add(event.getGameObject());
        }
    }

    @Subscribe
    public void onGameObjectDespawned(GameObjectDespawned event) {
        if (isPyramid(event.getGameObject())) {
            activePyramids.remove(event.getGameObject());
        }
    }

    @Subscribe
    public void onGraphicsObjectCreated(GraphicsObjectCreated event) {
        int activationTick;
        switch (event.getGraphicsObject().getId()) {
            case DDR_GRAPHICS_ID:
                activationTick = getActivationTick(event.getGraphicsObject(), DDR_HIT_DELAY_IN_TICKS);
                ddrHitTiles.put(activationTick, getWorldPoint(event.getGraphicsObject()));
                break;
            case OBELISK_DDR_LIGHTNING_GRAPHICS_ID:
                activationTick = getActivationTick(event.getGraphicsObject(), LIGHTNING_HIT_DELAY_IN_TICKS);
                ddrHitTiles.put(activationTick, getWorldPoint(event.getGraphicsObject()));
                break;
            case WINDMILL_HIT_GRAPHICS_ID:
                if (obeliskPhase == ObeliskPhase.DDR) {
                    ddrHitTiles.put(client.getTickCount(), getWorldPoint(event.getGraphicsObject()));
                } else if (obeliskPhase == ObeliskPhase.WINDMILL) {
                    windmillHitTiles.add(getWorldPoint(event.getGraphicsObject()));
                }
                break;
            case OBELISK_WINDMILL_LIGHTNING_GRAPHICS_ID:
                windmillHitTiles.add(getWorldPoint(event.getGraphicsObject()));
                break;
            case BOMB_GRAPHICS_ID:
                if (obeliskPhase == ObeliskPhase.BOMBS) {
                    activationTick = getActivationTick(event.getGraphicsObject(), LIGHTNING_HIT_DELAY_IN_TICKS);
                    bombHitTiles.put(activationTick, getWorldPoint(event.getGraphicsObject()));
                }
                break;
        }
    }

    @Subscribe
    public void onProjectileMoved(ProjectileMoved event) {
        if (!SPECIAL_PRAYER_ATTACKS.containsKey(event.getProjectile().getId())) return;

        specialPrayerOverheadTracker.trackProjectile(event, getActivationTick(event.getProjectile()));
    }

    @Subscribe
    public void onNpcChanged(NpcChanged event) {
        if (WARDENS_HEALTH_PHASE.contains(event.getNpc().getId())) {
            // Wardens changed to health phase with core. DDR special can no longer deal damage here as of 09/21/2022
            ddrHitTiles.clear();
            // Clear all other sources of damage too just in case
            windmillHitTiles.clear();
            bombHitTiles.clear();
            specialPrayerOverheadTracker.clear();
        }
    }

    private boolean isSpecialPrayerHit(Raider raider) {
        if (vengeanceTracker.didPopVengeance(raider)) {
            return false;
        }

        return specialPrayerOverheadTracker.didMissPrayer(raider);
    }

    private void computePyramidHitTiles() {
        activePyramids.forEach(pyramid -> {
            if (pyramid.getRenderable() instanceof DynamicObject) {
                Animation animation = ((DynamicObject) pyramid.getRenderable()).getAnimation();
                if (animation != null && animation.getId() == PYRAMID_ACTIVE_ANIMATION_ID) {
                    int activationTick = client.getTickCount() + PYRAMID_HIT_DELAY_IN_TICKS;
                    pyramidHitTiles.putAll(activationTick, compute3By3TilesFromCenter(pyramid.getWorldLocation()));
                }
            }
        });
    }

    private boolean isPyramid(GameObject gameObject) {
        return gameObject.getId() == RED_PYRAMID_GAME_OBJECT_ID || gameObject.getId() == YELLOW_PYRAMID_GAME_OBJECT_ID;
    }
}
package com.toamistaketracker.detector.boss;

import com.google.common.collect.ImmutableMap;
import com.google.common.collect.ImmutableSet;
import com.toamistaketracker.RaidRoom;
import com.toamistaketracker.Raider;
import com.toamistaketracker.ToaMistake;
import com.toamistaketracker.detector.BaseMistakeDetector;
import com.toamistaketracker.detector.tracker.DelayedHitTilesTracker;
import lombok.Getter;
import lombok.NonNull;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Actor;
import net.runelite.api.NPC;
import net.runelite.api.NPCComposition;
import net.runelite.api.events.AnimationChanged;
import net.runelite.api.events.GameTick;
import net.runelite.api.events.GraphicsObjectCreated;
import net.runelite.api.events.HitsplatApplied;
import net.runelite.api.events.NpcChanged;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.util.Text;

import javax.inject.Singleton;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.Set;

import static com.toamistaketracker.RaidRoom.KEPHRI;
import static com.toamistaketracker.ToaMistake.KEPHRI_BOMB;

/**
 * The Kephri bomb, exploding scarabs, and exploding eggs all reuse the same set of graphics IDs on impact, though they
 * each behave differently. The Kephri bomb spawns a graphics object on *each* of its tiles (including the 3x3) on
 * impact, but the exploding scarab and the exploding egg only spawn it on the 1x1 hit tile. The exploding scarab still
 * deals damage in a 3x3 area if the Aerial Assault invocation is turned on. Therefore, using just GraphicsObjectCreated
 * events on the explosion won't suffice, so instead we use the shadows that spawn from the incoming bomb attacks.
 */
@Slf4j
@Singleton
public class KephriDetector extends BaseMistakeDetector {

    // Graphics ID -> tick delay
    private static final Map<Integer, Integer> KEPHRI_BOMB_SHADOW_GRAPHICS = ImmutableMap.of(
            1447, 4,
            1446, 3,
            2111, 2
    );

    private static final Set<Integer> KEPHRI_BOMB_GRAPHICS_ID = ImmutableSet.of(2156, 2157, 2158, 2159);
    private static final int SWARM_HEAL_ANIMATION_ID = 9607;
    private static final String SWARM_NAME = "Scarab Swarm";
    private static final int KEPHRI_BOMB_PROJECTILE_ID = 2266;
    private static final int EXPLODING_SCARAB_PROJECTILE_ID = 2147;

    private static final String KEPHRI_NAME = "Kephri";
    private static final Set<Integer> KEPHRI_PHASE_IDS = ImmutableSet.of(11719, 11720, 11721);
    private static final int KEPHRI_DEAD_ID = 11722;

    private int swarmsHealing = 0;

    private Actor kephri;
    private int kephriHealthInternal = -1;

    private static final int KEPHRI_UNVENGEABLE_PHASE = 11720;

    @Getter
    private final DelayedHitTilesTracker bombHitTiles = new DelayedHitTilesTracker();

    @Override
    public void cleanup() {
        swarmsHealing = 0;
        kephriHealthInternal = -1;
        kephri = null;
        bombHitTiles.clear();
    }

    @Override
    public RaidRoom getRaidRoom() {
        return KEPHRI;
    }

    @Override
    public List<ToaMistake> detectMistakes(@NonNull Raider raider) {
        List<ToaMistake> mistakes = new ArrayList<>();

        // Disabling Swarm mistakes for now, as currently it's not even possible to fully kill them all in solos, and
        // it can just be noisy.
//        for (int i = 0; i < swarmsHealing; i++) {
//            mistakes.add(KEPHRI_SWARM_HEAL);
//        }

        if (isBombHit(raider)) {
            mistakes.add(KEPHRI_BOMB);
        }

        return mistakes;
    }

    @Override
    public void afterDetect() {
        swarmsHealing = 0;
        kephri = null;
    }

    @Subscribe
    public void onGameTick(GameTick event) {
        if (kephri != null) {
            kephriHealthInternal = kephri.getHealthRatio();
        }
        bombHitTiles.onGameTick(client.getTickCount());
    }

    @Subscribe
    public void onGraphicsObjectCreated(GraphicsObjectCreated event) {
        int id = event.getGraphicsObject().getId();
        if (KEPHRI_BOMB_SHADOW_GRAPHICS.containsKey(id)) {
            int activationTick = client.getTickCount() + KEPHRI_BOMB_SHADOW_GRAPHICS.get(id);
            bombHitTiles.put(activationTick, getWorldPoint(event.getGraphicsObject()));
        }
    }

    @Subscribe
    public void onAnimationChanged(AnimationChanged event) {
        if (event.getActor() == null || event.getActor().getName() == null) return;

        String name = Text.removeTags(event.getActor().getName());
        if (event.getActor() instanceof NPC && SWARM_NAME.equals(name) &&
                event.getActor().getAnimation() == SWARM_HEAL_ANIMATION_ID &&
                !event.getActor().isDead()) {
            swarmsHealing += 1;
        }
    }

    @Subscribe
    public void onNpcChanged(NpcChanged event) {
        if (!KEPHRI_NAME.equals(event.getNpc().getName())) return;

        if (isPhaseTransition(event.getOld(), event.getNpc().getComposition())) {
            kephriHealthInternal = -1; // something non-zero to initialize to
        } else if (event.getNpc().getId() == KEPHRI_DEAD_ID) {
            shutdown(); // Shut down and clean up all state. Any incoming bombs shouldn't count as mistakes.
        }
    }

    @Subscribe
    public void onHitsplatApplied(HitsplatApplied event) {
        if (event.getActor() == null || event.getActor().getName() == null) return;

        String name = Text.removeTags(event.getActor().getName());
        if (event.getActor() instanceof NPC && KEPHRI_NAME.equals(name)) {
            kephri = event.getActor();
        }
    }

    private boolean isBombHit(Raider raider) {
        if (!bombHitTiles.getActiveHitTiles().contains(raider.getPreviousWorldLocation())) {
            return false;
        }

        if (kephriHealthInternal == 0) {
            // Kephri bomb for some reason can't do damage when her health is 0, until she phase transitions in
            // which we update this to be non-zero and the next hitsplat corrects it.
            return false;
        }

        // Vengeance only counts for phases that allow it (non-swarm phase)
        if (vengeanceTracker.didPopVengeance(raider) && !isUnvengeablePhase()) {
            return false;
        }

        return true;
    }

    private boolean isUnvengeablePhase() {
        return client.getNpcs().stream().anyMatch(npc -> npc.getId() == KEPHRI_UNVENGEABLE_PHASE);
    }

    private boolean isPhaseTransition(NPCComposition oldComp, NPCComposition newComp) {
        return KEPHRI_PHASE_IDS.contains(oldComp.getId()) &&
                KEPHRI_PHASE_IDS.contains(newComp.getId()) &&
                oldComp.getId() != newComp.getId();
    }
}
package com.toamistaketracker.detector.boss;

import com.google.common.collect.ImmutableSet;
import com.toamistaketracker.RaidRoom;
import com.toamistaketracker.Raider;
import com.toamistaketracker.ToaMistake;
import com.toamistaketracker.detector.BaseMistakeDetector;
import lombok.NonNull;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.HitsplatID;
import net.runelite.api.NPC;
import net.runelite.api.coords.WorldPoint;
import net.runelite.api.events.AnimationChanged;
import net.runelite.api.events.GameObjectDespawned;
import net.runelite.api.events.GameObjectSpawned;
import net.runelite.api.events.GraphicsObjectCreated;
import net.runelite.api.events.HitsplatApplied;
import net.runelite.api.events.NpcDespawned;
import net.runelite.api.events.NpcSpawned;
import net.runelite.api.events.PlayerChanged;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.util.Text;

import javax.inject.Singleton;
import java.util.ArrayList;
import java.util.HashSet;
import java.util.List;
import java.util.Set;

import static com.toamistaketracker.RaidRoom.ZEBAK;
import static com.toamistaketracker.ToaMistake.ZEBAK_ACID_TILE;
import static com.toamistaketracker.ToaMistake.ZEBAK_BLOOD_CLOUD;
import static com.toamistaketracker.ToaMistake.ZEBAK_EARTHQUAKE;
import static com.toamistaketracker.ToaMistake.ZEBAK_WAVE;

/**
 * Zebak has quite a few things to keep track of. The acidTiles spawn and are detected through their game object IDs,
 * though they don't actually damage the player on the first tick that they spawn, so they get delayed.
 *
 * The blood clouds move around the arena and damage the player (and heal themselves) when they come into contact with
 * a player. Here we check HitsplatApplied events for HEAL and find all raiders on the actor's tile.
 *
 * The earthquake is also straightforward, as it spawns a graphics object when it hits. The one issue here is that when
 * jugs spawn, they spawn the same graphics object on the tile they land for a tick, since they can land on the player
 * and deal damage. However, I don't want to track this (at least not the same as earthquakes), so there's extra logic
 * to only detect the earthquake graphics IDs when zebak is doing the scream animation.
 *
 * The waves are pretty inconsistent. Again, detecting tile collisions with other pathing NPCs is a bit tricky. In fact,
 * there's an even instance I have on video of my *skipping over* a wave, which shouldn't be possible. Anyway, I ended
 * up just checking to see if the raider's current tile is >2 |distance| away, since that's not normally possible. The
 * waves seem to push you back at least 3 tiles (sometimes 4 if you're at the edge tile which you can't stand on). This
 * seems to be the easiest and most consistent way to detect if you got pushed, since there's no other animation.
 *
 * I decided to get rid of the chomp mistake, as Jagex is changing the timing of when the chomp actually hits you, and
 * also it doesn't always cause bleed or do damage.
 */
@Slf4j
@Singleton
public class ZebakDetector extends BaseMistakeDetector {

    private static final int CHOMP_ANIMATION_ID = 9620;
    private static final int CHOMP_HIT_DELAY_IN_TICKS = 2;

    private static final Set<Integer> SWIMMING_POSE_IDS = ImmutableSet.of(772, 773);
    private static final Set<Integer> ACID_TILE_GAME_OBJECT_IDS = ImmutableSet.of(
            45570, 45571, 45572, 45573, 45574, 45575, 45576);
    private static final int EARTHQUAKE_GRAPHICS_ID = 2184;
    private static final int ZEBAK_SCREAM_ANIMATION_ID = 9628;
    private static final String ZEBAK_NAME = "Zebak";
    private static final String WAVE_NAME = "Wave";
    private static final String BLOOD_CLOUD_NAME = "Blood Cloud";

    private final Set<WorldPoint> acidTilesToSpawn;
    private final Set<WorldPoint> acidTiles;
    private final Set<WorldPoint> bloodHealedTiles;
    private final Set<WorldPoint> earthquakeHitTiles;
    private final Set<String> raidersCurrentlySwimming;
    private final Set<String> raidersPreviouslySwimming;

    private final List<NPC> waves;
    private boolean isZebakScreaming;

    public ZebakDetector() {
        acidTilesToSpawn = new HashSet<>();
        acidTiles = new HashSet<>();
        bloodHealedTiles = new HashSet<>();
        earthquakeHitTiles = new HashSet<>();
        raidersCurrentlySwimming = new HashSet<>();
        raidersPreviouslySwimming = new HashSet<>();

        waves = new ArrayList<>();
        isZebakScreaming = false;

    }

    @Override
    public void cleanup() {
        acidTilesToSpawn.clear();
        acidTiles.clear();
        bloodHealedTiles.clear();
        earthquakeHitTiles.clear();
        raidersCurrentlySwimming.clear();
        raidersPreviouslySwimming.clear();
        waves.clear();
        isZebakScreaming = false;
    }

    @Override
    public RaidRoom getRaidRoom() {
        return ZEBAK;
    }

    @Override
    public List<ToaMistake> detectMistakes(@NonNull Raider raider) {
        List<ToaMistake> mistakes = new ArrayList<>();

        if (acidTiles.contains(raider.getPreviousWorldLocation())) {
            mistakes.add(ZEBAK_ACID_TILE);
        }

        if (bloodHealedTiles.contains(raider.getPreviousWorldLocation())) {
            mistakes.add(ZEBAK_BLOOD_CLOUD);
        }

        if (isEarthquakeHit(raider)) {
            mistakes.add(ZEBAK_EARTHQUAKE);
        }

        if (isWaveHit(raider)) {
            mistakes.add(ZEBAK_WAVE);
        }

        return mistakes;
    }

    @Override
    public void afterDetect() {
        acidTiles.addAll(acidTilesToSpawn);
        acidTilesToSpawn.clear();
        bloodHealedTiles.clear();
        earthquakeHitTiles.clear();

        raidersPreviouslySwimming.clear();
        raidersPreviouslySwimming.addAll(raidersCurrentlySwimming);
        raidersCurrentlySwimming.clear();
    }

    private boolean isEarthquakeHit(Raider raider) {
        return earthquakeHitTiles.contains(raider.getPreviousWorldLocation()) && isZebakScreaming;
    }

    private boolean isWaveHit(Raider raider) {
        // Jumping back up from swimming can bring you forward 3 tiles, so don't allow that to count in the hack below.
        if (raider.getPreviousWorldLocation() == null ||
                waves.isEmpty() ||
                raidersPreviouslySwimming.contains(raider.getName())) {
            return false;
        }

        // HACK
        // Normally a player cannot move > 2 tiles in 1 tick. The waves push you back at least 3, so use that to detect.
        return Math.abs(raider.getCurrentWorldLocation().getY() - raider.getPreviousWorldLocation().getY()) > 2;
    }

    @Subscribe
    public void onGameObjectSpawned(GameObjectSpawned event) {
        if (ACID_TILE_GAME_OBJECT_IDS.contains(event.getGameObject().getId())) {
            // Acid tiles don't hit you for the first tick they're spawned, so delay their detection by a tick.
            // The first ones sometimes only poison you and not damage you on the second tick, but we count that anyway.
            acidTilesToSpawn.add(event.getGameObject().getWorldLocation());
        }
    }

    @Subscribe
    public void onGameObjectDespawned(GameObjectDespawned event) {
        if (ACID_TILE_GAME_OBJECT_IDS.contains(event.getGameObject().getId())) {
            acidTilesToSpawn.remove(event.getGameObject().getWorldLocation());
            acidTiles.remove(event.getGameObject().getWorldLocation());
        }
    }

    @Subscribe
    public void onHitsplatApplied(HitsplatApplied event) {
        if (event.getActor().getName() != null &&
                BLOOD_CLOUD_NAME.equals(event.getActor().getName()) &&
                event.getHitsplat().getHitsplatType() == HitsplatID.HEAL) {
            bloodHealedTiles.add(event.getActor().getWorldLocation()); // Is this correct? Should it be local toWorld?
        }
    }

    @Subscribe
    public void onGraphicsObjectCreated(GraphicsObjectCreated event) {
        if (event.getGraphicsObject().getId() == EARTHQUAKE_GRAPHICS_ID) {
            earthquakeHitTiles.add(getWorldPoint(event.getGraphicsObject()));
        }
    }

    @Subscribe
    public void onNpcSpawned(NpcSpawned event) {
        if (event.getNpc().getName() == null) return;

        String name = Text.removeTags(event.getNpc().getName());
        if (WAVE_NAME.equals(name)) {
            waves.add(event.getNpc());
        }
    }

    @Subscribe
    public void onNpcDespawned(NpcDespawned event) {
        if (event.getNpc().getName() == null) return;

        String name = Text.removeTags(event.getNpc().getName());
        if (WAVE_NAME.equals(name)) {
            waves.remove(event.getNpc());
        }
    }

    @Subscribe
    public void onPlayerChanged(PlayerChanged event) {
        if (event.getPlayer() != null && SWIMMING_POSE_IDS.contains(event.getPlayer().getPoseAnimation())) {
            raidersCurrentlySwimming.add(event.getPlayer().getName());
        }
    }

    @Subscribe
    public void onAnimationChanged(AnimationChanged event) {
        if (event.getActor() == null || event.getActor().getName() == null) return;

        String name = Text.removeTags(event.getActor().getName());
        if (event.getActor() instanceof NPC && ZEBAK_NAME.equals(name)) {
            isZebakScreaming = event.getActor().getAnimation() == ZEBAK_SCREAM_ANIMATION_ID;
        }
    }
}
package com.toamistaketracker.detector;

import com.google.common.collect.ImmutableSet;
import com.toamistaketracker.RaidRoom;
import com.toamistaketracker.RaidState;
import com.toamistaketracker.Raider;
import com.toamistaketracker.ToaMistake;
import com.toamistaketracker.detector.tracker.VengeanceTracker;
import lombok.NonNull;
import lombok.Setter;
import net.runelite.api.Actor;
import net.runelite.api.Client;
import net.runelite.api.Constants;
import net.runelite.api.GraphicsObject;
import net.runelite.api.Projectile;
import net.runelite.api.coords.WorldPoint;
import net.runelite.client.eventbus.EventBus;

import javax.inject.Inject;
import java.util.List;
import java.util.Set;

/**
 * Interface for detecting mistakes during The Tombs of Amascut
 */
public abstract class BaseMistakeDetector {

    protected static final int CYCLES_PER_GAME_TICK = Constants.GAME_TICK_LENGTH / Constants.CLIENT_TICK_LENGTH;

    @Inject
    @Setter
    protected Client client;

    @Inject
    @Setter
    protected EventBus eventBus;

    @Inject
    @Setter
    protected RaidState raidState;

    @Inject
    @Setter
    protected VengeanceTracker vengeanceTracker;

    /**
     * Used to tell a detector to start listening for events.
     */
    public void startup() {
        cleanup();
        eventBus.register(this);
    }

    /**
     * Shutdown and cleanup state. This is always called when the plugin is shutdown, or when a detector is finished.
     */
    public void shutdown() {
        eventBus.unregister(this);
        cleanup();
    }

    /**
     * Cleanup all relevant state in the detector. This is called during startup to reset state, and shutdown to cleanup
     * This is also called for active detectors whenever raiders are loaded, which is during room transitions and room
     * resets (wipes).
     */
    public abstract void cleanup();

    /**
     * Retrieve the raid room that this detector should startup in. A null value means *all* rooms
     *
     * @return The raid room that the detector should startup in, or null for *all* rooms
     */
    public abstract RaidRoom getRaidRoom();

    /**
     * Detects mistakes for the given raider.
     * This is called during handling the {@link net.runelite.api.events.GameTick} event, each tick.
     *
     * @param raider - The raider to detect mistakes for
     * @return The list of {@link ToaMistake} detected on this tick
     */
    public abstract List<ToaMistake> detectMistakes(@NonNull Raider raider);

    /**
     * This method allows detectors to handle some logic after all detectMistakes methods have been invoked
     * for this {@link net.runelite.api.events.GameTick}. Commonly, this is to cleanup state from after this tick.
     */
    public abstract void afterDetect();

    /**
     * Determines whether or not this detector is currently detecting mistakes. Commonly this is by checking the current
     * {@link RaidRoom} in the {@link RaidState}
     *
     * @return True if the detector is detecting mistakes, else false
     */
    public boolean isDetectingMistakes() {
        if (getRaidRoom() == null) { // null means *all* rooms
            return raidState.isInRaid();
        }

        return raidState.getCurrentRoom() == getRaidRoom();
    }

    protected WorldPoint getWorldPoint(Actor actor) {
        return WorldPoint.fromLocal(client, actor.getLocalLocation());
    }

    protected WorldPoint getWorldPoint(GraphicsObject graphicsObject) {
        return WorldPoint.fromLocal(client, graphicsObject.getLocation());
    }

    /**
     * This method computes the WorldPoints in a 3x3 area given a center point.
     *
     * @param center The center point of the 3x3 area
     * @return The set of WorldPoints around and including the center
     */
    protected Set<WorldPoint> compute3By3TilesFromCenter(WorldPoint center) {
        WorldPoint west = center.dx(-1);
        WorldPoint east = center.dx(1);

        return ImmutableSet.of(
                west, center, east,
                west.dy(-1), center.dy(-1), east.dy(-1),
                west.dy(1), center.dy(1), east.dy(1));
    }

    /**
     * Calculates and retrieves the activation tick for the specified GraphicsObject based on the start cycle and
     * the given hit delay.
     *
     * @param graphicsObject The graphics object
     * @param hitDelay       The delay in ticks from when the graphics object animation starts and when it causes a hit
     * @return The activation tick for when the graphics object will denote a hit on the player
     */
    protected int getActivationTick(GraphicsObject graphicsObject, int hitDelay) {
        int ticksToStart = (graphicsObject.getStartCycle() - client.getGameCycle()) / CYCLES_PER_GAME_TICK;
        return client.getTickCount() + ticksToStart + hitDelay; // Add the hit delay for how long between start to hit
    }

    /**
     * Calculates and retrieves the activation tick for the specified Projectile based on the remaining cycles.
     *
     * @param projectile The projectile object
     * @return The activation tick for when the projectile object will reach its target
     */
    protected int getActivationTick(Projectile projectile) {
        int ticksRemaining = projectile.getRemainingCycles() / CYCLES_PER_GAME_TICK;
        return client.getTickCount() + ticksRemaining;
    }
}

package com.toamistaketracker.detector.tracker;

import com.toamistaketracker.Raider;
import lombok.Getter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.ChatMessageType;
import net.runelite.api.Player;
import net.runelite.api.Varbits;
import net.runelite.api.events.ChatMessage;
import net.runelite.api.events.GameTick;
import net.runelite.api.events.OverheadTextChanged;
import net.runelite.api.events.VarbitChanged;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.util.Text;

import javax.inject.Singleton;
import java.util.HashSet;
import java.util.Set;

@Slf4j
@Singleton
public class VengeanceTracker extends BaseRaidTracker {

    public static final String VENGEANCE_TEXT = "Taste vengeance!";

    @Getter
    private final Set<String> raidersVengeance = new HashSet<>();
    private final Set<String> raidersChatVengeance = new HashSet<>();

    @Override
    public void cleanup() {
        raidersVengeance.clear();
        raidersChatVengeance.clear();
    }

    @Override
    public void afterDetect() {
        cleanup();
    }

    @Subscribe
    public void onGameTick(GameTick event) {
        raidersVengeance.removeAll(raidersChatVengeance);
    }

    @Subscribe
    public void onVarbitChanged(VarbitChanged event) {
        if (event.getVarbitId() == Varbits.VENGEANCE_ACTIVE && event.getValue() == 0) {
            // Local player just procc'd veng
            if (client.getLocalPlayer() != null && raidState.isRaider(client.getLocalPlayer())) {
                raidersVengeance.add(client.getLocalPlayer().getName());
            }
        }
    }

    @Subscribe
    public void onOverheadTextChanged(OverheadTextChanged event) {
        if (!(event.getActor() instanceof Player) || event.getActor().getName() == null) return;

        String name = Text.sanitize(event.getActor().getName());
        if (isOtherVengeance(name, event.getOverheadText())) {
            raidersVengeance.add(name);
        }
    }

    @Subscribe
    public void onChatMessage(ChatMessage event) {
        if (event.getType() != ChatMessageType.PUBLICCHAT) return;

        String name = Text.sanitize(event.getName());
        if (isOtherVengeance(name, event.getMessage())) {
            raidersChatVengeance.add(name);
        }
    }

    public boolean didPopVengeance(Raider raider) {
        return raidersVengeance.contains(raider.getName());
    }

    /**
     * Determine if the given message is a vengeance message from another non-local player
     *
     * @param name    The name of the sender of the message
     * @param message The message
     * @return True if a non-local player has the vengeance text, false otherwise
     */
    private boolean isOtherVengeance(String name, String message) {
        if (client.getLocalPlayer() != null &&
                client.getLocalPlayer().getName() != null &&
                client.getLocalPlayer().getName().equals(name)) {
            return false;
        }

        return VENGEANCE_TEXT.equals(message);
    }
}


package com.toamistaketracker.detector.tracker;

import com.toamistaketracker.Raider;
import lombok.NonNull;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.HeadIcon;
import net.runelite.api.Projectile;
import net.runelite.api.events.ProjectileMoved;

import java.util.Collection;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;
import java.util.stream.Collectors;

import static com.toamistaketracker.ToaMistakeTrackerPlugin.CYCLES_PER_GAME_TICK;

@RequiredArgsConstructor
@Slf4j
public class OverheadTracker extends DelayedObjectsTracker<Projectile>{

    // Projectile ID -> correct overhead icon
    private final Map<Integer, HeadIcon> attacks;

    private final Set<Projectile> trackedProjectiles = new HashSet<>();

    /**
     * Tracks a Projectile from the specified ProjectileMoved event
     *
     * @param event    The event containing the Projectile and metadata
     * @param activationTick The activationTick for when this projectile activates its overhead detection
     */
    public void trackProjectile(@NonNull ProjectileMoved event, @NonNull Integer activationTick) {
        Projectile projectile = event.getProjectile();
        if (!attacks.containsKey(projectile.getId()) ||
                trackedProjectiles.contains(projectile)) {
            return;
        }

        if (!hasEnoughRemainingCycles(projectile)) {
            // There's no way there's a new projectile that only has at most 1 game tick left. It's probably
            // hanging around from a previous attack, so let's ignore
            return;
        }

        put(activationTick, projectile);
        trackedProjectiles.add(projectile);
    }

    @Override
    public void onGameTick(@NonNull Integer gameTick) {
        super.onGameTick(gameTick);

        // Clear state of projectiles that have at most 1 game tick left, as they can't be added anyway
        trackedProjectiles.removeIf(projectile ->!hasEnoughRemainingCycles(projectile));
    }

    @Override
    public void clear() {
        super.clear();
        trackedProjectiles.clear();
    }

    public Set<Projectile> getActiveProjectiles() {
        return getActiveObjects();
    }

    /**
     * Determine whether the given raider missed their prayer for the active projectile on them for this tick
     * @param raider The raider
     * @return True if the raider missed their prayer, false otherwise
     */
    public boolean didMissPrayer(Raider raider) {
        if (getActiveProjectiles().isEmpty()) {
            return false;
        }

        HeadIcon playerHeadIcon = raider.getPlayer().getOverheadIcon();
        if (playerHeadIcon == null) {
            return true;
        }

        Projectile activeProjectile = getActiveProjectileForRaider(raider);
        if (activeProjectile == null) {
            // Should never happen
            return false;
        }

        HeadIcon requiredHeadIcon = attacks.get(activeProjectile.getId());
        if (requiredHeadIcon == null) {
            // Can't happen, but just in case, not a miss
            return false;
        }

        return playerHeadIcon != requiredHeadIcon;
    }

    /**
     * Return the current active projectile for the specified Raider
     *
     * @param raider The raider
     * @return The projectile that activated on this tick for the raider
     */
    public Projectile getActiveProjectileForRaider(Raider raider) {
        for (Projectile projectile : getActiveProjectiles()) {
            if (projectile != null &&
                    raider.getPlayer().equals(projectile.getInteracting())) {
                return projectile;
            }
        }

        return null;
    }

    private boolean hasEnoughRemainingCycles(Projectile projectile) {
        // There's no way there's a new projectile that only has at most 1 game tick left. It's probably
        // hanging around from a previous attack, so let's ignore
        return projectile.getRemainingCycles() > CYCLES_PER_GAME_TICK;
    }
}

package com.toamistaketracker.detector.tracker;

import com.toamistaketracker.ToaMistake;
import lombok.Builder;
import lombok.NonNull;
import lombok.Value;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;

/**
 * Class to track mistakes that should be delayed for a specified number of ticks, or until actively retrieved
 */
public class DelayedMistakeTracker {

    private final Logger log = LoggerFactory.getLogger(DelayedMistakeTracker.class);

    private final Map<String, List<DelayedMistake>> delayedMistakes; // name -> list of delayed mistakes

    public DelayedMistakeTracker() {
        delayedMistakes = new HashMap<>();
    }

    /**
     * Add a delayed mistake which can be retrieved after a specified number of ticks in the future
     *
     * @param raiderName  The raider to retrieve mistakes for
     * @param mistake     The mistake
     * @param currentTick The current game tick
     * @param tickDelay   The amount of ticks to delay until the mistake can successfully be retrieved
     */
    public void addDelayedMistake(@NonNull String raiderName, @NonNull ToaMistake mistake, @NonNull Integer currentTick,
                                  Integer tickDelay) {
        delayedMistakes.computeIfAbsent(raiderName, k -> new ArrayList<>())
                .add(DelayedMistake.builder()
                        .raiderName(raiderName)
                        .mistake(mistake)
                        .tickAdded(currentTick)
                        .tickDelay(tickDelay)
                        .build());
    }

    /**
     * Retrieve the delayed mistakes for the specified raider if enough ticks have passed. This removes all found
     * mistakes
     *
     * @param raiderName  The raider to retrieve mistakes for
     * @param currentTick The current game tick
     * @return The tracked mistakes that have had enough ticks passed
     */
    public List<ToaMistake> popDelayedMistakes(@NonNull String raiderName, @NonNull Integer currentTick) {
        if (delayedMistakes.get(raiderName) == null) return Collections.emptyList();

        List<DelayedMistake> foundMistakes = new ArrayList<>();
        for (DelayedMistake delayedMistake : delayedMistakes.get(raiderName)) {
            int ticksSince = currentTick - delayedMistake.getTickAdded();
            if (ticksSince >= delayedMistake.getTickDelay()) {
                foundMistakes.add(delayedMistake);
            }
        }

        delayedMistakes.get(raiderName).removeAll(foundMistakes);
        return foundMistakes.stream().map(DelayedMistake::getMistake).collect(Collectors.toList());
    }

    /**
     * Forcibly retrieve all tracked delayed mistakes for the specified raider. This removes all tracked delayed
     * mistakes for that raider.
     *
     * @param raiderName The raider to retrieve mistakes for
     * @return The tracked mistakes
     */
    public List<ToaMistake> popAllDelayedMistakes(@NonNull String raiderName) {
        if (delayedMistakes.get(raiderName) == null) return Collections.emptyList();

        List<ToaMistake> mistakes = delayedMistakes.get(raiderName).stream()
                .map(DelayedMistake::getMistake)
                .collect(Collectors.toList());
        delayedMistakes.get(raiderName).clear();

        return mistakes;
    }

    public void clear() {
        delayedMistakes.clear();
    }

    @Value
    @Builder
    private static class DelayedMistake {

        @NonNull String raiderName;
        @NonNull ToaMistake mistake;
        @NonNull Integer tickAdded;
        Integer tickDelay;
    }
}

package com.toamistaketracker.detector.tracker;

import lombok.NonNull;
import lombok.extern.slf4j.Slf4j;

import java.util.HashSet;
import java.util.Set;

/**
 * Wrapper class for a map tracking objects that are active on the tick they are added
 */
@Slf4j
public class InstantObjectsTracker<T> implements ObjectsTracker<T> {

    private final Set<T> activeObjects = new HashSet<>();
    private final Set<T> newObjects = new HashSet<>();

    /**
     * Add the specified object to be activated this tick
     *
     * @param object The object to track
     */
    public void add(@NonNull T object) {
        newObjects.add(object);
    }

    /**
     * Sets the active objects for the given game tick, and removes retrieved objects from the delayed map. This
     * should be called once every GameTick update.
     *
     * @param gameTick the game tick
     */
    @Override
    public void onGameTick(@NonNull Integer gameTick) {
        activeObjects.clear();
        activeObjects.addAll(newObjects);
        newObjects.clear();
    }

    @Override
    public Set<T> getActiveObjects() {
        return activeObjects;
    }

    @Override
    public void clear() {
        activeObjects.clear();
        newObjects.clear();
    }
}

package com.toamistaketracker.detector.tracker;

import net.runelite.api.coords.WorldPoint;

import java.util.Set;

/**
 * Wrapper class for a map tracking hit tiles delayed for a specified activation tick
 */
public class DelayedHitTilesTracker extends DelayedObjectsTracker<WorldPoint> {

    public Set<WorldPoint> getActiveHitTiles() {
        return getActiveObjects();
    }

}

package com.toamistaketracker.detector.tracker;

import com.toamistaketracker.RaidState;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.client.eventbus.EventBus;

import javax.inject.Inject;

@Slf4j
public abstract class BaseRaidTracker {

    @Inject
    protected Client client;
    @Inject
    protected EventBus eventBus;
    @Inject
    protected RaidState raidState;

    public void startup() {
        cleanup();
        log.debug("Starting tracker");
        eventBus.register(this);
    }

    public void shutdown() {
        log.debug("Shutting down tracker");
        eventBus.unregister(this);
        cleanup();
    }

    public abstract void afterDetect();

    public abstract void cleanup();
}

package com.toamistaketracker.detector.tracker;

import java.util.HashMap;
import java.util.Map;

/**
 * Wrapper class for a map tracking applied hitsplats for a raider
 */
public class AppliedHitsplatsTracker {

    private final Map<String, Integer> appliedHitsplats; // name -> # of hitsplats applied this tick

    public AppliedHitsplatsTracker() {
        appliedHitsplats = new HashMap<>();
    }

    /**
     * Since multiple players could be on this tile, confirm there's a corresponding hitsplat applied to that raider.
     * This will pop a corresponding hitsplat for the player, if there are any and return true, otherwise false
     *
     * @param name The name of the raider
     * @return True if there was a hitsplat applied to the specified raider on this tick, else false
     */
    public boolean popHitsplatApplied(String name) {
        boolean hasHitsplat = appliedHitsplats.containsKey(name) && appliedHitsplats.get(name) > 0;
        if (hasHitsplat) {
            removeHitsplatForRaider(name);
        }
        return hasHitsplat;
    }

    public void addHitsplatForRaider(String name) {
        appliedHitsplats.compute(name, this::increment);
    }

    public void addAllHitsplats(AppliedHitsplatsTracker other) {
        this.appliedHitsplats.putAll(other.appliedHitsplats);
    }

    private void removeHitsplatForRaider(String name) {
        appliedHitsplats.compute(name, this::decrement);
    }

    public void clear() {
        appliedHitsplats.clear();
    }

    private Integer increment(String key, Integer value) {
        return value == null ? 1 : value + 1;
    }

    private Integer decrement(String key, Integer value) {
        return value == null ? -1 : value - 1;
    }
}

package com.toamistaketracker.detector.tracker;

import com.google.common.annotations.VisibleForTesting;
import lombok.Getter;
import lombok.NonNull;
import lombok.extern.slf4j.Slf4j;

import java.util.HashMap;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;

/**
 * Wrapper class for a map tracking objects delayed for a specified activation tick
 */
@Slf4j
public class DelayedObjectsTracker<T> implements ObjectsTracker<T> {

    protected final Set<T> activeObjects = new HashSet<>();

    @Getter
    @VisibleForTesting
    protected final Map<Integer, Set<T>> delayedObjects = new HashMap<>(); // activationTick -> set of tracked objects

    /**
     * Put the specified object to be retrieved at the specified activationTick
     *
     * @param activationTick The game tick to retrieve the object
     * @param object         The object to track
     */
    public void put(@NonNull Integer activationTick, @NonNull T object) {
        delayedObjects.computeIfAbsent(activationTick, k -> new HashSet<>()).add(object);
    }

    /**
     * Put the specified objects to be retrieved at the specified activationTick
     *
     * @param activationTick The game tick to retrieve the object
     * @param objects        The objects to track
     */
    public void putAll(@NonNull Integer activationTick, @NonNull Set<T> objects) {
        delayedObjects.computeIfAbsent(activationTick, k -> new HashSet<>()).addAll(objects);
    }

    /**
     * Sets the active objects  for the given game tick, and removes retrieved objects from the delayed map. This
     * should be called once every GameTick update.
     *
     * @param gameTick the game tick
     */
    @Override
    public void onGameTick(@NonNull Integer gameTick) {
        activeObjects.clear();
        if (delayedObjects.containsKey(gameTick)) {
            activeObjects.addAll(delayedObjects.remove(gameTick));
        }
    }

    @Override
    public Set<T> getActiveObjects() {
        return activeObjects;
    }

    @Override
    public void clear() {
        activeObjects.clear();
        delayedObjects.clear();
    }
}

package com.toamistaketracker.detector.tracker;

import net.runelite.api.coords.WorldPoint;

import java.util.Set;

/**
 * Wrapper class for a map tracking hit tiles that are active on the tick they are added
 */
public class InstantHitTilesTracker extends InstantObjectsTracker<WorldPoint> {

    public Set<WorldPoint> getActiveHitTiles() {
        return getActiveObjects();
    }
}

package com.toamistaketracker.detector.tracker;

import lombok.NonNull;

import java.util.Set;

/**
 * Track objects that should be activated at a specified {@link net.runelite.api.events.GameTick}
 */
public interface ObjectsTracker<T> {

    /**
     * Sets the active objects for the given game tick. This should be called once every GameTick update.
     *
     * @param gameTick the game tick
     */
    void onGameTick(@NonNull Integer gameTick);

    /**
     * Retrieve the active objects for this game tick
     *
     * @return The set of active objects this game tick
     */
    Set<T> getActiveObjects();

    /**
     * Clears all active objects and other state
     */
    void clear();
}

package com.toamistaketracker;

import lombok.Getter;
import lombok.RequiredArgsConstructor;

@RequiredArgsConstructor
public enum RaidRoom {

    // limbo 13392
    RAID_LOBBY_OUTSIDE(13454),
    RAID_LOBBY_INSIDE(14160),
    HET_PUZZLE(14674),
    CRONDIS_PUZZLE(15698),
    SCABARAS_PUZZLE(14162),
    APMEKEN_PUZZLE(15186),
    AKKHA(14676),
    ZEBAK(15700),
    KEPHRI(14164),
    BABA(15188),
    WARDENS_P1_P2(15184),
    WARDENS_P3(15696),
    ;

    @Getter
    private final int regionId;

    public static RaidRoom forRegionId(int region) {
        for (RaidRoom r : RaidRoom.values()) {
            if (r.getRegionId() == region) {
                return r;
            }
        }

        return null;
    }
}

package com.toamistaketracker.events;

import com.toamistaketracker.RaidRoom;
import com.toamistaketracker.RaidState;
import lombok.Builder;
import lombok.Value;

/**
 * An event where the current {@link RaidRoom} has changed in the {@link RaidState}.
 */
@Value
@Builder
public class RaidRoomChanged {

    /**
     * The new RaidRoom
     */
    RaidRoom newRaidRoom;

    /**
     * The previous RaidRoom
     */
    RaidRoom prevRaidRoom;
}
package com.toamistaketracker.events;

import lombok.Value;

import java.util.List;

/**
 * An event denoting that a new raid has been entered.
 */
@Value
public class RaidEntered {

    List<String> raiderNames;
}
package com.toamistaketracker.events;

import lombok.Value;

/**
 * An event denoting that the inRaid raid state has changed.
 */
@Value
public class InRaidChanged {

    boolean inRaid;
}
package com.toamistaketracker;

import com.google.inject.Provides;
import com.toamistaketracker.detector.MistakeDetectorManager;
import com.toamistaketracker.detector.tracker.VengeanceTracker;
import com.toamistaketracker.events.InRaidChanged;
import com.toamistaketracker.events.RaidEntered;
import com.toamistaketracker.panel.ToaMistakeTrackerPanel;
import lombok.NonNull;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.ChatMessageType;
import net.runelite.api.Client;
import net.runelite.api.Constants;
import net.runelite.api.Player;
import net.runelite.api.events.GameTick;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.eventbus.EventBus;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.plugins.PluginDescriptor;
import net.runelite.client.ui.ClientToolbar;
import net.runelite.client.ui.NavigationButton;
import net.runelite.client.ui.overlay.OverlayManager;
import net.runelite.client.util.ImageUtil;

import javax.inject.Inject;
import javax.swing.SwingUtilities;
import java.awt.image.BufferedImage;
import java.util.List;

@Slf4j
@PluginDescriptor(
        name = "Toa Mistake Tracker"
)
public class ToaMistakeTrackerPlugin extends Plugin {

    public static final int CYCLES_PER_GAME_TICK = Constants.GAME_TICK_LENGTH / Constants.CLIENT_TICK_LENGTH;

    static final String CONFIG_GROUP = "toaMistakeTracker";

    private static final int OVERHEAD_TEXT_TICK_TIMEOUT = 5;
    private static final int CYCLES_FOR_OVERHEAD_TEXT = OVERHEAD_TEXT_TICK_TIMEOUT * CYCLES_PER_GAME_TICK;

    @Inject
    private Client client;

    @Inject
    private ClientThread clientThread;

    @Inject
    private ToaMistakeTrackerConfig config;

    @Inject
    private EventBus eventBus;

    @Inject
    private MistakeDetectorManager mistakeDetectorManager;

    @Inject
    private RaidState raidState;

    @Inject
    private VengeanceTracker vengeanceTracker;

    @Inject
    private OverlayManager overlayManager;

    // UI fields
    @Inject
    private ClientToolbar clientToolbar;
    private final BufferedImage icon = ImageUtil.loadImageResource(ToaMistakeTrackerPlugin.class, "panel-icon.png");
    private ToaMistakeTrackerPanel panel;
    private NavigationButton navButton;

    @Override
    protected void startUp() throws Exception {
        // Can't @Inject because we null it out in shutdown()
        panel = injector.getInstance(ToaMistakeTrackerPanel.class);

        // Add UI
        panel.loadHeaderIcon(icon);
        navButton = NavigationButton.builder()
                .tooltip("Toa Mistake Tracker")
                .icon(icon)
                .priority(5)
                .panel(panel)
                .build();
        clientToolbar.addNavigation(navButton);

        // Start raid state detection
        clientThread.invoke(() -> {
            raidState.startUp();
        });

        // Reload the panel with all loaded mistakes
        panel.reload();
    }

    @Override
    protected void shutDown() throws Exception {
        // Clear all state
        raidState.shutDown();
        mistakeDetectorManager.shutdown();

        // Remove UI
        clientToolbar.removeNavigation(navButton);
        panel = null;
    }

    // This should run *after* all detectors have handled the GameTick.
    @Subscribe(priority = -1)
    public void onGameTick(GameTick event) {
        if (!raidState.isInRaid()) return;

        // Try detecting all possible mistakes for this GameTick
        detectAll();

        // Invoke post-processing method for detectors to get ready for the next GameTick
        afterDetectAll();
    }

    private void detectAll() {
        for (Raider raider : raidState.getRaiders().values()) {
            if (raider != null) {
                detect(raider);
            }
        }
    }

    private void detect(@NonNull Raider raider) {
        List<ToaMistake> mistakes = mistakeDetectorManager.detectMistakes(raider);
        if (!mistakes.isEmpty()) {
            log.debug(client.getTickCount() + " Found mistakes for " + raider.getName() + " - " + mistakes);

            for (ToaMistake mistake : mistakes) {
                // Handle special logic for deaths
                if (mistake == ToaMistake.DEATH) {
                    raider.setDead(true);
                }

                addChatMessageForMistake(raider, mistake);
                addMistakeToOverlayPanel(raider, mistake);
            }
        }

        afterDetect(raider);
    }

    private void afterDetect(Raider raider) {
        raider.setPreviousWorldLocationForOverlay(raider.getPreviousWorldLocation());
        raider.setPreviousWorldLocation(raider.getCurrentWorldLocation());
    }

    private void afterDetectAll() {
        mistakeDetectorManager.afterDetect();
    }

    private void addChatMessageForMistake(Raider raider, ToaMistake mistake) {
        int mistakeCount = config.mistakeMessageStacking() == StackingBehavior.SAME_MISTAKES_ONLY
                ? panel.getCurrentMistakeCountForPlayer(raider.getName(), mistake)
                : panel.getCurrentTotalMistakeCountForPlayer(raider.getName());
        String msg = ToaMistake.getChatMessageForMistakeCount(config, mistake, mistakeCount);

        // Truncate message length to prevent overly-spammy messages taking up too much screen space
        if (msg.length() > ToaMistake.MAX_MESSAGE_LENGTH) {
            msg = msg.substring(0, ToaMistake.MAX_MESSAGE_LENGTH);
        }

        if (msg.isEmpty()) return;

        // Add to overhead text if config is enabled
        final Player player = raider.getPlayer();
        if (config.showMistakesOnOverheadText()) {
            String overheadText = msg;
            if (vengeanceTracker.didPopVengeance(raider)) {
                overheadText = VengeanceTracker.VENGEANCE_TEXT + " " + overheadText;
            }
            player.setOverheadText(overheadText);
            player.setOverheadCycle(CYCLES_FOR_OVERHEAD_TEXT);
        }

        // Add to chat box if config is enabled
        if (config.showMistakesInChat()) {
            client.addChatMessage(ChatMessageType.PUBLICCHAT, player.getName(), msg, null);
        }
    }

    private void addMistakeToOverlayPanel(Raider raider, ToaMistake mistake) {
        // Certain mistakes have their own detection and chat messages, but should be grouped together as one in the
        // tracker panel and written state.
        ToaMistake groupedMistake = ToaMistake.toGroupedMistake(mistake);
        SwingUtilities.invokeLater(() -> panel.addMistakeForPlayer(raider.getName(), groupedMistake));
    }

    @Subscribe
    public void onInRaidChanged(InRaidChanged e) {
        if (e.isInRaid()) {
            log.debug("Starting detectors");
            mistakeDetectorManager.startup();
        } else {
            log.debug("Shutting down detectors");
            mistakeDetectorManager.shutdown();
        }
    }

    @Subscribe
    public void onRaidEntered(RaidEntered event) {
        panel.newRaid(event.getRaiderNames());
    }

    @Provides
    ToaMistakeTrackerConfig provideConfig(ConfigManager configManager) {
        return configManager.getConfig(ToaMistakeTrackerConfig.class);
    }
}

package com.toamistaketracker.mistakestate;

import com.toamistaketracker.ToaMistake;
import lombok.Getter;
import lombok.NonNull;

import java.util.HashMap;
import java.util.Map;

/**
 * Encapsulating class for relevant tracking information for a player, including mistakes.
 */
public class PlayerTrackingInfo {

    @NonNull
    @Getter
    private final String playerName;
    @NonNull
    @Getter
    private final Map<ToaMistake, Integer> mistakes;
    @Getter
    private int raidCount;

    public PlayerTrackingInfo(@NonNull final String playerName) {
        this.playerName = playerName;
        this.mistakes = new HashMap<>();
        this.raidCount = 1; // Default raid count is 1 since just by creating this object it's assumed there's a raid
    }

    public void incrementMistake(ToaMistake mistake) {
        mistakes.compute(mistake, PlayerTrackingInfo::increment);
    }

    public void incrementRaidCount() {
        raidCount++;
    }

    public boolean hasMistakes() {
        return !mistakes.isEmpty();
    }

    private static <T> Integer increment(T key, Integer oldValue) {
        return oldValue == null ? 1 : oldValue + 1;
    }
}

package com.toamistaketracker.mistakestate;

import com.google.gson.Gson;
import lombok.extern.slf4j.Slf4j;
import net.runelite.http.api.RuneLiteAPI;

import javax.inject.Inject;
import javax.inject.Named;
import javax.inject.Singleton;
import java.io.BufferedWriter;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;

import static com.toamistaketracker.mistakestate.MistakeStateUtil.getMistakeStateDir;
import static com.toamistaketracker.mistakestate.MistakeStateUtil.getMistakeStateFilePath;

/**
 * Writes MistakeState to disk
 */
@Slf4j
@Singleton
public class MistakeStateWriter {

    private static final Gson GSON = RuneLiteAPI.GSON;

    private final Path mistakeStateDir;
    private final Path mistakeStateFilePath;

    @Inject
    public MistakeStateWriter(@Named("developerMode") boolean developerMode) {
        this.mistakeStateDir = getMistakeStateDir();
        this.mistakeStateFilePath = getMistakeStateFilePath(developerMode);
    }

    public void write(MistakeStateManager mistakeStateManager) {
        try {
            Files.createDirectories(mistakeStateDir);
        } catch (IOException e) {
            log.error("Unable to create directories " + mistakeStateDir, e);
            return;
        }

        final Path filepath = mistakeStateFilePath;
        try (BufferedWriter writer = Files.newBufferedWriter(filepath)) {
            writer.write(GSON.toJson(mistakeStateManager));
        } catch (IOException e) {
            log.error("Unable to write mistake state to " + filepath, e);
        }
    }
}
package com.toamistaketracker.mistakestate;

import com.toamistaketracker.ToaMistake;

import java.util.HashMap;
import java.util.Map;
import java.util.Set;
import java.util.stream.Collectors;

/**
 * Keeps track of mistakes for players
 */
class MistakeManager {

    private final Map<String, PlayerTrackingInfo> trackingInfo;
    private int trackedRaids;

    MistakeManager() {
        trackingInfo = new HashMap<>();
        trackedRaids = 0;
    }

    public void clearAllMistakes() {
        trackingInfo.clear();
        trackedRaids = 0;
    }

    public void addMistakeForPlayer(String playerName, ToaMistake mistake) {
        PlayerTrackingInfo playerInfo = trackingInfo.computeIfAbsent(playerName,
                k -> new PlayerTrackingInfo(playerName));
        playerInfo.incrementMistake(mistake);
    }

    public void newRaid(Set<String> playerNames) {
        // TODO: Small bug where if plugin is installed mid-raid (or mistakes reset), then player raids gets 1 but
        // total tracked raids is still 0
        trackedRaids++;

        for (String playerName : playerNames) {
            PlayerTrackingInfo playerInfo = trackingInfo.get(playerName);
            if (playerInfo != null) {
                playerInfo.incrementRaidCount();
            } else {
                trackingInfo.put(playerName, new PlayerTrackingInfo(playerName));
            }
        }
    }

    public void removeAllMistakesForPlayer(String playerName) {
        trackingInfo.remove(playerName);
    }

    public Set<String> getPlayersWithMistakes() {
        return trackingInfo.values().stream()
                .filter(PlayerTrackingInfo::hasMistakes)
                .map(PlayerTrackingInfo::getPlayerName)
                .collect(Collectors.toSet());
    }

    public int getMistakeCountForPlayer(String playerName, ToaMistake mistake) {
        PlayerTrackingInfo playerInfo = trackingInfo.get(playerName);
        if (playerInfo != null) {
            Integer count = playerInfo.getMistakes().get(mistake);
            if (count != null) {
                return count;
            }
        }

        return 0;
    }

    public int getTotalMistakeCountForPlayer(String playerName) {
        int totalMistakes = 0;
        PlayerTrackingInfo playerInfo = trackingInfo.get(playerName);
        if (playerInfo != null) {
            for (int mistakes : playerInfo.getMistakes().values()) {
                totalMistakes += mistakes;
            }
        }
        return totalMistakes;
    }

    public int getTotalMistakeCountForAllPlayers() {
        // TODO: Fix bug where room death and raid death count as 2 distinct mistakes, but they're the same.
        int totalMistakes = 0;
        for (PlayerTrackingInfo playerInfo : trackingInfo.values()) {
            for (int mistakes : playerInfo.getMistakes().values()) {
                totalMistakes += mistakes;
            }
        }

        return totalMistakes;
    }

    public int getRaidCountForPlayer(String playerName) {
        PlayerTrackingInfo playerInfo = trackingInfo.get(playerName);
        if (playerInfo != null) {
            return playerInfo.getRaidCount();
        }

        return 0;
    }

    public int getTrackedRaids() {
        return trackedRaids;
    }
}

package com.toamistaketracker.mistakestate;

import com.toamistaketracker.ToaMistake;
import lombok.Setter;
import lombok.extern.slf4j.Slf4j;

import javax.inject.Singleton;
import java.util.Set;

/**
 * In charge of the different MistakeManagers, and knowing which one is the currently viewed one.
 * <p>
 * For now, these are very small and writes are relatively infrequent, so let's write to disk for every write API.
 */
@Slf4j
@Singleton
public class MistakeStateManager {

    private final MistakeManager currentRaidMistakeManager;
    private final MistakeManager allRaidsMistakeManager;

    private transient boolean isAll;
    @Setter
    private transient MistakeStateWriter mistakeStateWriter;

    public MistakeStateManager(MistakeStateWriter mistakeStateWriter) {
        this.currentRaidMistakeManager = new MistakeManager();
        this.allRaidsMistakeManager = new MistakeManager();
        this.mistakeStateWriter = mistakeStateWriter;

        this.isAll = false;
    }

    public void addMistakeForPlayer(String playerName, ToaMistake mistake) {
        // Always add to both
        currentRaidMistakeManager.addMistakeForPlayer(playerName, mistake);
        allRaidsMistakeManager.addMistakeForPlayer(playerName, mistake);

        mistakeStateWriter.write(this);
    }

    public void removeAllMistakesForPlayer(String playerName) {
        // Always remove from both
        currentRaidMistakeManager.removeAllMistakesForPlayer(playerName);
        allRaidsMistakeManager.removeAllMistakesForPlayer(playerName);

        mistakeStateWriter.write(this);
    }

    public void resetAll() {
        // Always clear from both
        currentRaidMistakeManager.clearAllMistakes();
        allRaidsMistakeManager.clearAllMistakes();

        mistakeStateWriter.write(this);
    }

    public void newRaid(Set<String> playerNames) {
        // Clear just the current mistakes
        currentRaidMistakeManager.clearAllMistakes();

        // Denote to the manager that there's a new raid, incrementing the raid count for all players in this raid
        // Raid count for current raid isn't valid, so only do for all raids
        allRaidsMistakeManager.newRaid(playerNames);

        mistakeStateWriter.write(this);
    }

    public Set<String> getPlayersWithMistakes() {
        return isAll ?
                allRaidsMistakeManager.getPlayersWithMistakes() :
                currentRaidMistakeManager.getPlayersWithMistakes();
    }

    public int getMistakeCountForPlayer(String playerName, ToaMistake mistake) {
        return isAll ?
                allRaidsMistakeManager.getMistakeCountForPlayer(playerName, mistake) :
                currentRaidMistakeManager.getMistakeCountForPlayer(playerName, mistake);
    }

    public int getCurrentMistakeCountForPlayer(String playerName, ToaMistake mistake) {
        return currentRaidMistakeManager.getMistakeCountForPlayer(playerName, mistake);
    }

    public int getCurrentTotalMistakeCountForPlayer(String playerName) {
        return currentRaidMistakeManager.getTotalMistakeCountForPlayer(playerName);
    }

    public int getTotalMistakeCountForAllPlayers() {
        return isAll ?
                allRaidsMistakeManager.getTotalMistakeCountForAllPlayers() :
                currentRaidMistakeManager.getTotalMistakeCountForAllPlayers();
    }

    public int getRaidCountForPlayer(String playerName) {
        return isAll ? allRaidsMistakeManager.getRaidCountForPlayer(playerName) :
                0; // Raid count for current raid isn't valid, so return 0
    }

    public int getTrackedRaids() {
        return isAll ? allRaidsMistakeManager.getTrackedRaids() :
                1; // Tracked raids for current raid is always just the 1 raid
    }

    public void switchMistakes() {
        isAll = !isAll;
    }
}

package com.toamistaketracker.mistakestate;

import java.nio.file.Path;

import static net.runelite.client.RuneLite.RUNELITE_DIR;

public class MistakeStateUtil {

    private static final Path MISTAKE_STATE_DIR = RUNELITE_DIR.toPath().resolve("toa-mistake-tracker");

    // Use the same mistake state file regardless of user
    private static final String MISTAKE_STATE_FILE_NAME = "mistake-state.txt";

    private static final String DEVELOPER_MODE_PREFIX = "dev-";

    static Path getMistakeStateDir() {
        return MISTAKE_STATE_DIR;
    }

    static Path getMistakeStateFilePath(boolean developerMode) {
        final String filename;
        if (developerMode) {
            filename = DEVELOPER_MODE_PREFIX + MISTAKE_STATE_FILE_NAME;
        } else {
            filename = MISTAKE_STATE_FILE_NAME;
        }

        return getMistakeStateDir().resolve(filename);
    }
}

package com.toamistaketracker.mistakestate;

import com.google.gson.Gson;
import com.google.gson.JsonSyntaxException;
import com.google.gson.stream.JsonReader;
import lombok.extern.slf4j.Slf4j;
import net.runelite.http.api.RuneLiteAPI;

import javax.inject.Inject;
import javax.inject.Named;
import javax.inject.Singleton;
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;

import static com.toamistaketracker.mistakestate.MistakeStateUtil.getMistakeStateFilePath;

/**
 * Reads MistakeState from disk
 */
@Slf4j
@Singleton
public class MistakeStateReader {

    private static final Gson GSON = RuneLiteAPI.GSON;

    private final MistakeStateWriter mistakeStateWriter;
    private final Path mistakeStateFilePath;

    @Inject
    public MistakeStateReader(MistakeStateWriter mistakeStateWriter, @Named("developerMode") boolean developerMode) {
        this.mistakeStateWriter = mistakeStateWriter;
        this.mistakeStateFilePath = getMistakeStateFilePath(developerMode);
    }

    public MistakeStateManager read() {
        if (Files.exists(mistakeStateFilePath)) {
            try (BufferedReader reader = Files.newBufferedReader(mistakeStateFilePath);
                 JsonReader jsonReader = new JsonReader(reader)) {
                MistakeStateManager mistakeStateManager = GSON.fromJson(jsonReader, MistakeStateManager.class);
                if (mistakeStateManager == null) {
                    return new MistakeStateManager(mistakeStateWriter);
                }
                mistakeStateManager.setMistakeStateWriter(mistakeStateWriter);
                return mistakeStateManager;
            } catch (IOException | JsonSyntaxException e) {
                log.error("Unable to read mistake state from " + mistakeStateFilePath, e);
            }
        }

        return new MistakeStateManager(mistakeStateWriter);
    }
}
package com.toamistaketracker;

import com.google.common.collect.ImmutableList;
import com.toamistaketracker.events.InRaidChanged;
import com.toamistaketracker.events.RaidEntered;
import com.toamistaketracker.events.RaidRoomChanged;
import lombok.Getter;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Actor;
import net.runelite.api.Client;
import net.runelite.api.GameState;
import net.runelite.api.Player;
import net.runelite.api.coords.LocalPoint;
import net.runelite.api.coords.WorldPoint;
import net.runelite.api.events.GameStateChanged;
import net.runelite.api.events.GameTick;
import net.runelite.api.events.ScriptPostFired;
import net.runelite.client.eventbus.EventBus;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.util.Text;

import javax.inject.Inject;
import javax.inject.Singleton;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import static com.toamistaketracker.RaidRoom.RAID_LOBBY_INSIDE;
import static com.toamistaketracker.RaidRoom.RAID_LOBBY_OUTSIDE;

@Slf4j
@Singleton
@RequiredArgsConstructor(onConstructor_ = @Inject)
public class RaidState {

    private static final int TOA_HUD_INIT_STATUS_NAMES_SCRIPT_ID = 6585;
    private static final int TOA_RAIDERS_VARC_START = 1099;
    private static final int MAX_RAIDERS = 8;

    private final Client client;
    private final EventBus eventBus;

    @Getter
    private boolean inRaid;
    @Getter
    private RaidRoom currentRoom;
    @Getter
    private final Map<String, Raider> raiders = new HashMap<>(); // name -> raider

    private int prevRegion;
    private boolean newRaid;

    public void startUp() {
        clearState();
        eventBus.register(this);
    }

    public void shutDown() {
        eventBus.unregister(this);
        clearState();
    }

    private void clearState() {
        inRaid = false;
        currentRoom = null;
        raiders.clear();
        prevRegion = -1;
        newRaid = false;
    }

    @Subscribe(priority = 5)
    public void onGameTick(GameTick e) {
        if (client.getGameState() != GameState.LOGGED_IN) return;

        int newRegion = getRegion();
        if (newRegion == -1) return;

        if (prevRegion != newRegion) {
            regionChanged(newRegion);
        }
        prevRegion = newRegion;

        if (!inRaid) {
            raiders.clear();
            return;
        }

        // If we still haven't loaded any raiders, keep trying. This can happen if the plugin is turned on mid-raid,
        // after the script can run. Or if the script runs but the relevant players aren't actually in the raid
        // yet for the client to retrieve.
        if (raiders.isEmpty()) {
            tryLoadRaiders();
        }
    }

    @Subscribe
    public void onGameStateChanged(GameStateChanged event) {
        if (event.getGameState() == GameState.LOADING) {
            // If there are still raiders, they can't be dead anymore after loading.
            for (Raider raider : raiders.values()) {
                raider.setDead(false);
            }
        }
    }

    @Subscribe
    public void onScriptPostFired(ScriptPostFired event) {
        if (event.getScriptId() == TOA_HUD_INIT_STATUS_NAMES_SCRIPT_ID) {
            tryLoadRaiders();
        }
    }

    public boolean isRaider(Actor actor) {
        return raiders.containsKey(actor.getName());
    }

    private int getRegion() {
        LocalPoint localPoint = client.getLocalPlayer().getLocalLocation();
        if (localPoint == null) {
            return -1;
        } else {
            return WorldPoint.fromLocalInstance(client, localPoint).getRegionID();
        }
    }

    private void regionChanged(int newRegion) {
        currentRoom = RaidRoom.forRegionId(newRegion);
        if (currentRoom == null) {
            return;
        }

        log.debug("New room: {}", currentRoom);

        boolean newInRaid = currentRoom != RAID_LOBBY_OUTSIDE;
        if (newInRaid != inRaid) {
            log.debug("In Raid changed: {}", newInRaid);
            eventBus.post(new InRaidChanged(newInRaid));
        }
        inRaid = newInRaid;

        RaidRoom prevRoom = RaidRoom.forRegionId(prevRegion);
        if (prevRoom == RAID_LOBBY_OUTSIDE && currentRoom == RAID_LOBBY_INSIDE) {
            // We can't load the raiders yet, as they're not set in the varcs until a few ticks later. The toa hud init
            // script will take care of it for us
            newRaid = true;
        } else {
            log.debug("Raid room changed: {}", currentRoom);
            eventBus.post(RaidRoomChanged.builder().newRaidRoom(currentRoom).prevRaidRoom(prevRoom).build());
        }

        // TODO: RaidFinished?
    }

    private void tryLoadRaiders() {
        log.debug("Setting raiders");
        raiders.clear();

        Set<String> raiderNames = new HashSet<>(MAX_RAIDERS);
        for (int i = 0; i < MAX_RAIDERS; i++) {
            String name = client.getVarcStrValue(TOA_RAIDERS_VARC_START + i);
            if (name != null && !name.isEmpty()) {
                raiderNames.add(Text.sanitize(name));
            }
        }

        for (Player player : client.getPlayers()) {
            if (player != null &&
                    player.getName() != null &&
                    !raiders.containsKey(player.getName()) &&
                    raiderNames.contains(player.getName())) {
                raiders.put(player.getName(), new Raider(player));
            }
        }

        log.debug("Loaded raiderNames: {}", raiderNames);
        log.debug("Loaded raiders: {}", raiders.keySet());

        if (raiders.isEmpty() || raiders.size() < raiderNames.size()) {
            log.debug("Not enough raiders loaded. Will try again later...");
            raiders.clear();
            return;
        }

        if (newRaid) {
            log.debug("New raid");
            eventBus.post(new RaidEntered(ImmutableList.copyOf(raiders.keySet())));
            newRaid = false;
        }
    }
}

package com.toamistaketracker;

import lombok.Getter;
import lombok.NonNull;
import net.runelite.client.util.ImageUtil;

import java.awt.image.BufferedImage;
import java.util.function.Function;
import java.util.Arrays;
import java.util.EnumSet;
import java.util.Set;

public enum ToaMistake {
    // Deaths
    DEATH("Death", (config) -> "", "", "death.png"), // Chat message handled in deaths below
    DEATH_HET("Path of Het Death", ToaMistakeTrackerConfig::deathMessage, defaultDeathMessage(), "death-akkha.png"),
    DEATH_CRONDIS("Path of Crondis Death", ToaMistakeTrackerConfig::deathMessage, defaultDeathMessage(), "death-zebak.png"),
    DEATH_SCABARAS("Path of Scabaras Death", ToaMistakeTrackerConfig::deathMessage, defaultDeathMessage(), "death-kephri.png"),
    DEATH_APMEKEN("Path of Apmeken Death", ToaMistakeTrackerConfig::deathMessage, defaultDeathMessage(), "death-baba.png"),
    DEATH_WARDENS("Wardens Death", ToaMistakeTrackerConfig::deathMessage, defaultDeathMessage(), "death-wardens.png"),

    // Het
    HET_PUZZLE_LIGHT("Het Puzzle Energy Beam", ToaMistakeTrackerConfig::hetPuzzleBeamMessage, "Ah! It burns!",
            "het-light.png"),
    HET_PUZZLE_DARK_ORB("Het Puzzle Dark Orb", ToaMistakeTrackerConfig::hetPuzzleOrbMessage, "Embrace Darkness!",
            "het-dark-orb2.png"),
    AKKHA_SPECIAL_QUADRANT_BOMB("Akkha Quadrant Bombs", ToaMistakeTrackerConfig::akkhaQuadrantMessage, "I'm too slow!",
            "akkha-quadrant3.png"),
    AKKHA_SPECIAL_ELEMENTAL_ORBS("Akkha Elemental Orbs", ToaMistakeTrackerConfig::akkhaElementalOrbMessage, "I'm griefing!",
            "akkha-elemental2.png"),
    AKKHA_UNSTABLE_ORB("Akkha Unstable Orb", ToaMistakeTrackerConfig::akkhaUnstableOrbMessage, "?",
            "akkha-unstable-orb.png"),

    // Crondis
    CRONDIS_PUZZLE_LOW_WATER("Path of Crondis Watering", ToaMistakeTrackerConfig::crondisWaterMessage,
            "This jug feels a little light...", "crondis-water.png"),
    ZEBAK_ACID_TILE("Zebak Acid Tile", ToaMistakeTrackerConfig::zebakAcidMessage, "I'm drowning in acid!",
            "zebak-acid.png"),
    ZEBAK_BLOOD_CLOUD("Zebak Blood Cloud", ToaMistakeTrackerConfig::zebakBloodMessage, "I'm on a blood cloud!",
            "zebak-blood-cloud.png"),
    ZEBAK_EARTHQUAKE("Zebak Scream", ToaMistakeTrackerConfig::zebakScreamMessage, "Nihil!", "zebak-scream.png"),
    ZEBAK_WAVE("Zebak Wave", ToaMistakeTrackerConfig::zebakWaveMessage, "I'm surfing!", "zebak-wave.png"),

    // Scabaras
    KEPHRI_BOMB("Kephri Bomb", ToaMistakeTrackerConfig::kephriBombMessage, "I'm exploding!", "kephri-bomb.png"),
    KEPHRI_SWARM_HEAL("Kephri Swarm Heal", (config) -> "The swarms are going in!", "The swarms are going in!",
            "kephri-swarm.png"),
    KEPHRI_EGG_EXPLODE("Kephri Egg Explode", (config) -> "I've been hatched!", "I've been hatched!", ""),

    // Apmeken
    APMEKEN_PUZZLE_SIGHT("Apmeken Sight", (config) -> "", "", "apmeken-sight.png"),
    APMEKEN_PUZZLE_VENT("Apmeken Vent", ToaMistakeTrackerConfig::apmekenVentMessage, "I'm fuming!", ""),
    APMEKEN_PUZZLE_PILLAR("Apmeken Pillar", ToaMistakeTrackerConfig::apmekenPillarMessage, "The sky is falling!", ""),
    APMEKEN_PUZZLE_CORRUPTION("Apmeken Corruption", ToaMistakeTrackerConfig::apmekenCorruptionMessage,
            "I've been corrupted!", ""),
    APMEKEN_PUZZLE_VENOM("Apmeken Venom Tile", ToaMistakeTrackerConfig::apmekenVenomMessage, "It's venomous!",
            "apmeken-venom.png"),
    APMEKEN_PUZZLE_VOLATILE("Apmeken Volatile", ToaMistakeTrackerConfig::apmekenVolatileMessage, "I'm exploding!",
            "apmeken-volatile.png"),
    BABA_SLAM("Ba-Ba Slam", ToaMistakeTrackerConfig::babaSlamMessage, "Come on and slam!|And welcome to the jam!",
            "baba-slam.png"),
    BABA_PROJECTILE_BOULDER("Ba-Ba Projectile Boulder", ToaMistakeTrackerConfig::babaProjectileBoulderMessage,
            "I got rocked!", "baba-projectile-boulder.png"),
    BABA_ROLLING_BOULDER("Ba-Ba Rolling Boulder", ToaMistakeTrackerConfig::babaRollingBoulderMessage,
            "They see me rollin'...", "baba-rolling-boulder.png"),
    BABA_FALLING_BOULDER("Ba-Ba Falling Boulder", ToaMistakeTrackerConfig::babaFallingBoulderMessage, "It's raining!",
            "baba-falling-boulder.png"),
    BABA_BANANA("Ba-Ba Banana", ToaMistakeTrackerConfig::babaBananaMessage, "Who put that there?", "baba-banana.png"),
    BABA_GAP("Ba-Ba Gap", ToaMistakeTrackerConfig::babaGapMessage, "I'm going down!", "baba-gap.png"),

    // Wardens
    WARDENS_P1_PYRAMID("Wardens P1 Pyramid", ToaMistakeTrackerConfig::wardensPyramidMessage, "I'm disco-ing!",
            "wardens-pyramid.png"),
    WARDENS_P2_OBELISK("Wardens P2 Obelisk", (config) -> "", "", "wardens-obelisk.png"),
    WARDENS_P2_DDR("Wardens P2 DDR", ToaMistakeTrackerConfig::wardensDDRMessage, "I'm dancing!", ""),
    WARDENS_P2_WINDMILL("Wardens P2 Windmill", ToaMistakeTrackerConfig::wardensWindmillMessage, "I'm winded!", ""),
    WARDENS_P2_BOMBS("Wardens P2 Bombs", ToaMistakeTrackerConfig::wardensBombsMessage, "I'm getting bombed!", ""),
    WARDENS_P2_BIND("Wardens P2 Bind", ToaMistakeTrackerConfig::wardensBindMessage, "I'm in jail!", "wardens-bind.png"),
    WARDENS_P2_SPECIAL_PRAYER("Wardens P2 Special Prayer", ToaMistakeTrackerConfig::wardensPrayerMessage,
            "What even was that attack?", "wardens-special-prayer.png"),
    WARDENS_P3_EARTHQUAKE("Wardens P3 Slam", ToaMistakeTrackerConfig::wardensSlamMessage, "I'm tripping!",
            "wardens-earthquake.png"),
    WARDENS_P3_AKKHA("Wardens P3 Akkha", (config) -> "", "", "wardens-akkha.png"),
    WARDENS_P3_ZEBAK("Wardens P3 Zebak", (config) -> "", "", "wardens-zebak.png"),
    WARDENS_P3_KEPHRI("Wardens P3 Kephri", ToaMistakeTrackerConfig::kephriBombMessage, KEPHRI_BOMB.getDefaultMessage(),
            "wardens-kephri.png"),
    WARDENS_P3_BABA("Wardens P3 Ba-Ba", ToaMistakeTrackerConfig::babaFallingBoulderMessage,
            BABA_FALLING_BOULDER.getDefaultMessage(), "wardens-baba.png"),
    WARDENS_P3_LIGHTNING("Wardens P3 Lightning", (config) -> "", "", "wardens-lightning.png"), // Too noisy
    ;

    private static final Set<ToaMistake> ROOM_DEATHS = EnumSet.of(DEATH_HET, DEATH_CRONDIS, DEATH_SCABARAS,
            DEATH_APMEKEN, DEATH_WARDENS);

    private static final Set<ToaMistake> APMEKEN_SIGHT_MISTAKES = EnumSet.of(APMEKEN_PUZZLE_VENT, APMEKEN_PUZZLE_PILLAR,
            APMEKEN_PUZZLE_CORRUPTION);
    private static final Set<ToaMistake> WARDENS_P2_OBELISK_MISTAKES = EnumSet.of(WARDENS_P2_DDR, WARDENS_P2_WINDMILL,
            WARDENS_P2_BOMBS);

    private static final String FALLBACK_IMAGE_PATH = "death.png";

    private static final int MAX_STACKING_CHAT_MESSAGE_LENGTH = 10;
    public static final int MAX_MESSAGE_LENGTH = 40;

    @Getter
    @NonNull
    private final String mistakeName;

    @Getter
    @NonNull
    private final String defaultMessage;

    @NonNull
    private final Function<ToaMistakeTrackerConfig, String> chatMessageFunc;

    @Getter
    @NonNull
    private final BufferedImage mistakeImage;

    ToaMistake(@NonNull String mistakeName, @NonNull Function<ToaMistakeTrackerConfig, String> chatMessageFunc, @NonNull String defaultMessage,
            @NonNull String mistakeImagePath) {
        this.mistakeName = mistakeName;
        this.chatMessageFunc = chatMessageFunc;
        this.defaultMessage = defaultMessage;

        final String imagePath;
        if (mistakeImagePath.isEmpty()) {
            imagePath = FALLBACK_IMAGE_PATH;
        } else {
            imagePath = mistakeImagePath;
        }
        this.mistakeImage = ImageUtil.loadImageResource(getClass(), imagePath);
    }

    public String getChatMessage(ToaMistakeTrackerConfig config) {
        return chatMessageFunc.apply(config);
    }

    public static String defaultDeathMessage() {
        return "I'm planking!";
    }

    public static boolean isRoomDeath(ToaMistake mistake) {
        return ROOM_DEATHS.contains(mistake);
    }

    /**
     * Get the grouped mistake for the specified detected mistake.
     *
     * @param mistake The detected mistake
     * @return The grouped mistake
     */
    public static ToaMistake toGroupedMistake(ToaMistake mistake) {
        if (APMEKEN_SIGHT_MISTAKES.contains(mistake)) {
            return APMEKEN_PUZZLE_SIGHT;
        } else if (WARDENS_P2_OBELISK_MISTAKES.contains(mistake)) {
            return WARDENS_P2_OBELISK;
        } else {
            return mistake;
        }
    }

    /**
     * Retrieve the chat message for the given mistake, considering special cases given the config
     * settings about whether to stack question marks and the current mistake count of either
     * this specific mistake in the raid for the current raider, *or* the total current raid mistake
     * count for the current raider.
     *
     * @param config       The configuration object to retrieve chat message from
     * @param mistake      The mistake
     * @param mistakeCount The current mistake count of this mistake *or* the current raid mistake count for the
     *                     raider in this raid
     *
     * @return The mistake chat message to use for the raider
     */
    public static String getChatMessageForMistakeCount(ToaMistakeTrackerConfig config, ToaMistake mistake,
            int mistakeCount) {
        String mistakeMessage = mistake.getChatMessage(config);
        // Special case a few mistake chat messages based on config
        if (config.mistakeMessageStacking() != StackingBehavior.NONE && mistakeMessage.equals("?")) {
            return getStackingChatMessage(mistakeMessage, mistakeCount);
        }
        if (mistakeMessage.contains("|")) {
            return getAlternatingChatMessage(mistakeMessage, mistake.getDefaultMessage(), mistakeCount);
        }

        return mistakeMessage;
    }

    private static String getStackingChatMessage(String message, int mistakeCount) {
        // Keep adding ?s to the text for every subsequent mistake in this raid. A bit hacky but it's funny.
        StringBuilder sb = new StringBuilder(message);
        for (int i = 0; i < Math.min(mistakeCount, MAX_STACKING_CHAT_MESSAGE_LENGTH); i++) {
            sb.append(message);
        }
        return sb.toString();
    }

    private static String getAlternatingChatMessage(String message, String defaultMessage, int mistakeCount) {
        String[] messageChoices = Arrays.stream(message.split("\\|")).filter(msg -> !msg.isEmpty())
                .toArray(String[]::new);
        if (messageChoices.length == 0) {
            return defaultMessage;
        }
        return messageChoices[mistakeCount % messageChoices.length];
    }
}

package com.toamistaketracker;

import net.runelite.client.config.Config;
import net.runelite.client.config.ConfigGroup;
import net.runelite.client.config.ConfigItem;
import net.runelite.client.config.ConfigSection;

@ConfigGroup(ToaMistakeTrackerPlugin.CONFIG_GROUP)
public interface ToaMistakeTrackerConfig extends Config {

    @ConfigItem(
            keyName = "showMistakesInChat",
            name = "Show Mistakes In Chat",
            description = "When a player makes a mistake in ToA, whether or not to log the mistake message to your " +
                    "public chat. Max message length of " + ToaMistake.MAX_MESSAGE_LENGTH + " to prevent spamming chat.",
            position = 0
    )
    default boolean showMistakesInChat() {
        return true;
    }

    @ConfigItem(
            keyName = "showMistakesOnOverheadText",
            name = "Show Mistakes On Overhead Text",
            description = "When a player makes a mistake in ToA, whether or not to show the mistake message above " +
                    "their head as overhead text.",
            position = 1
    )
    default boolean showMistakesOnOverheadText() {
        return true;
    }

    @ConfigItem(
            keyName = "mistakeMessageStacking",
            name = "Mistake Message Stacking",
            description = "When a player makes a mistake in ToA and the message is set to \"?\", how to handle " +
                    "repeated mistakes for the current raid.",
            position = 2
    )
    default StackingBehavior mistakeMessageStacking() {
        return StackingBehavior.SAME_MISTAKES_ONLY;
    }

    @ConfigSection(
            name = "Death Messages",
            description = "Settings for the messages shown on Death mistakes (separate multiple messages by \"|\").",
            position = 3,
            closedByDefault = true
    )
    String deathMistakeSettings = "deathMistakeSettings";

    @ConfigItem(
            keyName = "deathMessage",
            name = "Death",
            description = "Message to show on death.",
            section = deathMistakeSettings,
            position = 0
    )
    default String deathMessage() {
        return ToaMistake.defaultDeathMessage();
    }

    @ConfigSection(
            name = "Akkha Mistake Messages",
            description = "Settings for the messages shown on Het puzzle and Akkha room mistakes (separate multiple messages by \"|\").",
            position = 5,
            closedByDefault = true
    )
    String hetAndAkkhaMistakeSettings = "hetAndAkkhaMistakeSettings";

    @ConfigItem(
            keyName = "hetPuzzleBeamMessage",
            name = "Het Puzzle Beam",
            description = "Message to show when hit by the beam in the Het puzzle room.",
            section = hetAndAkkhaMistakeSettings,
            position = 0
    )
    default String hetPuzzleBeamMessage() {
        return ToaMistake.HET_PUZZLE_LIGHT.getDefaultMessage();
    }

    @ConfigItem(
            keyName = "hetPuzzleOrbMessage",
            name = "Het Puzzle Orb",
            description = "Message to show when hit by an orb in the Het puzzle room.",
            section = hetAndAkkhaMistakeSettings,
            position = 1
    )
    default String hetPuzzleOrbMessage() {
        return ToaMistake.HET_PUZZLE_DARK_ORB.getDefaultMessage();
    }

    @ConfigItem(
            keyName = "akkhaQuadrantMessage",
            name = "Akkha Quadrant",
            description = "Message to show when hit by a quadrant attack in the Akkha room.",
            section = hetAndAkkhaMistakeSettings,
            position = 2
    )
    default String akkhaQuadrantMessage() {
        return ToaMistake.AKKHA_SPECIAL_QUADRANT_BOMB.getDefaultMessage();
    }

    @ConfigItem(
            keyName = "akkhaElementalOrbMessage",
            name = "Akkha Elemental Orb",
            description = "Message to show when hit by an elemental orb in the Akkha room.",
            section = hetAndAkkhaMistakeSettings,
            position = 3
    )
    default String akkhaElementalOrbMessage() {
        return ToaMistake.AKKHA_SPECIAL_ELEMENTAL_ORBS.getDefaultMessage();
    }

    @ConfigItem(
            keyName = "akkhaUnstableOrbMessage",
            name = "Akkha Unstable Orb",
            description = "Message to show when hit by an unstable orb in the Akkha room.",
            section = hetAndAkkhaMistakeSettings,
            position = 4
    )
    default String akkhaUnstableOrbMessage() {
        return ToaMistake.AKKHA_UNSTABLE_ORB.getDefaultMessage();
    }

    @ConfigSection(
            name = "Zebak Mistake Messages",
            description = "Settings for the messages shown on Crondis puzzle and Zebak room mistakes (separate multiple messages by \"|\").",
            position = 6,
            closedByDefault = true
    )
    String crondisAndZebakMistakeSettings = "crondisAndZebakMistakeSettings";

    @ConfigItem(
            keyName = "crondisWaterMessage",
            name = "Crondis Water",
            description = "Message to show when depositing a less than full jug in the Crondis puzzle room.",
            section = crondisAndZebakMistakeSettings,
            position = 0
    )
    default String crondisWaterMessage() {
        return ToaMistake.CRONDIS_PUZZLE_LOW_WATER.getDefaultMessage();
    }

    @ConfigItem(
            keyName = "zebakAcidMessage",
            name = "Zebak Acid",
            description = "Message to show when hit by an acid pool in the Zebak room.",
            section = crondisAndZebakMistakeSettings,
            position = 1
    )
    default String zebakAcidMessage() {
        return ToaMistake.ZEBAK_ACID_TILE.getDefaultMessage();
    }

    @ConfigItem(
            keyName = "zebakBloodMessage",
            name = "Zebak Blood Cloud",
            description = "Message to show when hit by a blood cloud in the Zebak room.",
            section = crondisAndZebakMistakeSettings,
            position = 2
    )
    default String zebakBloodMessage() {
        return ToaMistake.ZEBAK_BLOOD_CLOUD.getDefaultMessage();
    }

    @ConfigItem(
            keyName = "zebakScreamMessage",
            name = "Zebak Scream",
            description = "Message to show when hit by a scream attack in the Zebak room.",
            section = crondisAndZebakMistakeSettings,
            position = 3
    )
    default String zebakScreamMessage() {
        return ToaMistake.ZEBAK_EARTHQUAKE.getDefaultMessage();
    }

    @ConfigItem(
            keyName = "zebakWaveMessage",
            name = "Zebak Wave",
            description = "Message to show when hit by a wave in the Zebak room.",
            section = crondisAndZebakMistakeSettings,
            position = 4
    )
    default String zebakWaveMessage() {
        return ToaMistake.ZEBAK_WAVE.getDefaultMessage();
    }

    @ConfigSection(
            name = "Kephri Mistake Messages",
            description = "Settings for the messages shown on Kephri room mistakes (separate multiple messages by \"|\").",
            position = 7,
            closedByDefault = true
    )
    String kephriMistakeSettings = "kephriMistakeSettings";

    @ConfigItem(
            keyName = "kephriBombMessage",
            name = "Kephri Bomb",
            description = "Message to show when hit by a bomb in the Kephri room.",
            section = kephriMistakeSettings,
            position = 0
    )
    default String kephriBombMessage() {
        return ToaMistake.KEPHRI_BOMB.getDefaultMessage();
    }

    @ConfigSection(
            name = "Ba-Ba Mistake Messages",
            description = "Settings for the messages shown on Apmeken puzzle and Ba-Ba room mistakes (separate multiple messages by \"|\").",
            position = 8,
            closedByDefault = true
    )
    String apmekenAndBabaMistakeSettings = "apmekenAndBabaMistakeSettings";

    @ConfigItem(
            keyName = "apmekenVentMessage",
            name = "Apmeken Vent",
            description = "Message to show when failing the vents special in the Apmeken puzzle room.",
            section = apmekenAndBabaMistakeSettings,
            position = 0
    )
    default String apmekenVentMessage() {
        return ToaMistake.APMEKEN_PUZZLE_VENT.getDefaultMessage();
    }

    @ConfigItem(
            keyName = "apmekenPillarMessage",
            name = "Apmeken Pillar",
            description = "Message to show when failing the pillars special in the Apmeken puzzle room.",
            section = apmekenAndBabaMistakeSettings,
            position = 1
    )
    default String apmekenPillarMessage() {
        return ToaMistake.APMEKEN_PUZZLE_PILLAR.getDefaultMessage();
    }

    @ConfigItem(
            keyName = "apmekenCorruptionMessage",
            name = "Apmeken Corruption",
            description = "Message to show when failing the corruption special in the Apmeken puzzle room.",
            section = apmekenAndBabaMistakeSettings,
            position = 2
    )
    default String apmekenCorruptionMessage() {
        return ToaMistake.APMEKEN_PUZZLE_CORRUPTION.getDefaultMessage();
    }

    @ConfigItem(
            keyName = "apmekenVenomMessage",
            name = "Apmeken Venom",
            description = "Message to show when stepping on venom in the Apmeken puzzle room.",
            section = apmekenAndBabaMistakeSettings,
            position = 3
    )
    default String apmekenVenomMessage() {
        return ToaMistake.APMEKEN_PUZZLE_VENOM.getDefaultMessage();
    }

    @ConfigItem(
            keyName = "apmekenVolatileMessage",
            name = "Apmeken Volatile",
            description = "Message to show when hit by a Volatile monkey in the Apmeken puzzle room.",
            section = apmekenAndBabaMistakeSettings,
            position = 4
    )
    default String apmekenVolatileMessage() {
        return ToaMistake.APMEKEN_PUZZLE_VOLATILE.getDefaultMessage();
    }

    @ConfigItem(
            keyName = "babaSlamMessage",
            name = "Ba-Ba Slam",
            description = "Message to show when hit by a slam attack in the Ba-Ba room.",
            section = apmekenAndBabaMistakeSettings,
            position = 5
    )
    default String babaSlamMessage() {
        return ToaMistake.BABA_SLAM.getDefaultMessage();
    }

    @ConfigItem(
            keyName = "babaProjectileBoulderMessage",
            name = "Ba-Ba Projectile Boulder",
            description = "Message to show when hit by a projectile boulder attack in the Ba-Ba room.",
            section = apmekenAndBabaMistakeSettings,
            position = 6
    )
    default String babaProjectileBoulderMessage() {
        return ToaMistake.BABA_PROJECTILE_BOULDER.getDefaultMessage();
    }

    @ConfigItem(
            keyName = "babaRollingBoulderMessage",
            name = "Ba-Ba Rolling Boulder",
            description = "Message to show when hit by a rolling boulder in the Ba-Ba room.",
            section = apmekenAndBabaMistakeSettings,
            position = 7
    )
    default String babaRollingBoulderMessage() {
        return ToaMistake.BABA_ROLLING_BOULDER.getDefaultMessage();
    }

    @ConfigItem(
            keyName = "babaFallingBoulderMessage",
            name = "Ba-Ba Falling Boulder",
            description = "Message to show when hit by a falling boulder in the Ba-Ba room.",
            section = apmekenAndBabaMistakeSettings,
            position = 8
    )
    default String babaFallingBoulderMessage() {
        return ToaMistake.BABA_FALLING_BOULDER.getDefaultMessage();
    }

    @ConfigItem(
            keyName = "babaBananaMessage",
            name = "Ba-Ba Banana",
            description = "Message to show when slipping on a banana in the Ba-Ba room.",
            section = apmekenAndBabaMistakeSettings,
            position = 9
    )
    default String babaBananaMessage() {
        return ToaMistake.BABA_BANANA.getDefaultMessage();
    }

    @ConfigItem(
            keyName = "babaGapMessage",
            name = "Ba-Ba Gap",
            description = "Message to show when falling into the gap in the Ba-Ba room.",
            section = apmekenAndBabaMistakeSettings,
            position = 10
    )
    default String babaGapMessage() {
        return ToaMistake.BABA_GAP.getDefaultMessage();
    }

    @ConfigSection(
            name = "Wardens Mistake Messages",
            description = "Settings for the messages shown on Warden room mistakes (separate multiple messages by \"|\").",
            position = 9,
            closedByDefault = true
    )
    String wardensMistakeSettings = "wardensMistakeSettings";

    @ConfigItem(
            keyName = "wardensPyramidMessage",
            name = "P1 Pyramids",
            description = "Message to show when hit by a pyramid during Wardens P1.",
            section = wardensMistakeSettings,
            position = 0
    )
    default String wardensPyramidMessage() {
        return ToaMistake.WARDENS_P1_PYRAMID.getDefaultMessage();
    }

    @ConfigItem(
            keyName = "wardensDDRMessage",
            name = "P2 DDR",
            description = "Message to show when hit by a DDR obelisk special during Wardens P2.",
            section = wardensMistakeSettings,
            position = 1
    )
    default String wardensDDRMessage() {
        return ToaMistake.WARDENS_P2_DDR.getDefaultMessage();
    }

    @ConfigItem(
            keyName = "wardensWindmillMessage",
            name = "P2 Windmill",
            description = "Message to show when hit by a windmill obelisk special during Wardens P2.",
            section = wardensMistakeSettings,
            position = 2
    )
    default String wardensWindmillMessage() {
        return ToaMistake.WARDENS_P2_WINDMILL.getDefaultMessage();
    }

    @ConfigItem(
            keyName = "wardensBombsMessage",
            name = "P2 Bombs",
            description = "Message to show when hit by the bombs obelisk special during Wardens P2.",
            section = wardensMistakeSettings,
            position = 3
    )
    default String wardensBombsMessage() {
        return ToaMistake.WARDENS_P2_BOMBS.getDefaultMessage();
    }

    @ConfigItem(
            keyName = "wardensBindMessage",
            name = "P2 Bind",
            description = "Message to show when hit by the binding warden attack during Wardens P2.",
            section = wardensMistakeSettings,
            position = 4
    )
    default String wardensBindMessage() {
        return ToaMistake.WARDENS_P2_BIND.getDefaultMessage();
    }

    @ConfigItem(
            keyName = "wardensPrayerMessage",
            name = "P2 Special Prayer",
            description = "Message to show when hit by the special prayer warden attack during Wardens P2.",
            section = wardensMistakeSettings,
            position = 5
    )
    default String wardensPrayerMessage() {
        return ToaMistake.WARDENS_P2_SPECIAL_PRAYER.getDefaultMessage();
    }

    @ConfigItem(
            keyName = "wardensSlamMessage",
            name = "P3 Slam",
            description = "Message to show when hit by the slam warden attack during Wardens P3.",
            section = wardensMistakeSettings,
            position = 6
    )
    default String wardensSlamMessage() {
        return ToaMistake.WARDENS_P3_EARTHQUAKE.getDefaultMessage();
    }
}

package com.toamistaketracker.panel;

import com.toamistaketracker.ToaMistake;
import com.toamistaketracker.ToaMistakeTrackerPlugin;
import com.toamistaketracker.mistakestate.MistakeStateManager;
import com.toamistaketracker.mistakestate.MistakeStateReader;
import net.runelite.api.Client;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.FontManager;
import net.runelite.client.ui.PluginPanel;
import net.runelite.client.ui.components.PluginErrorPanel;
import net.runelite.client.util.ColorUtil;
import net.runelite.client.util.ImageUtil;
import net.runelite.client.util.QuantityFormatter;
import net.runelite.client.util.SwingUtil;

import javax.inject.Inject;
import javax.inject.Named;
import javax.inject.Singleton;
import javax.swing.BorderFactory;
import javax.swing.BoxLayout;
import javax.swing.ButtonGroup;
import javax.swing.ImageIcon;
import javax.swing.JButton;
import javax.swing.JLabel;
import javax.swing.JMenuItem;
import javax.swing.JOptionPane;
import javax.swing.JPanel;
import javax.swing.JPopupMenu;
import javax.swing.JRadioButton;
import javax.swing.SwingUtilities;
import javax.swing.border.EmptyBorder;
import java.awt.BorderLayout;
import java.awt.Color;
import java.awt.Dimension;
import java.awt.FlowLayout;
import java.awt.GridLayout;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.awt.image.BufferedImage;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;

/**
 * The panel for the plugin. This was copied over from TobMistakeTracker, with minor changes
 */
@Singleton
public class ToaMistakeTrackerPanel extends PluginPanel {

    private static final String HTML_LABEL_TEMPLATE =
            "<html><body style='color:%s'>%s<span style='color:white'>%s</span></body></html>";

    private static final boolean DEFAULT_IS_RAID_DEATHS = false;

    private static final ImageIcon RAID_DEATHS_ICON;
    private static final ImageIcon RAID_DEATHS_ICON_FADED;
    private static final ImageIcon RAID_DEATHS_ICON_HOVER;

    private static final ImageIcon ROOM_DEATHS_ICON;
    private static final ImageIcon ROOM_DEATHS_ICON_FADED;
    private static final ImageIcon ROOM_DEATHS_ICON_HOVER;

    private final Client client;

    private final MistakeStateManager mistakeStateManager;

    private List<String> currentRaiderNames;

    private final JLabel currentViewTitle = new JLabel();
    private final JButton switchMistakesViewBtn = new JButton();

    private final JRadioButton raidDeathsBtn = new JRadioButton();
    private final JRadioButton roomDeathsBtn = new JRadioButton();

    // Panel for overall mistake data
    private final JPanel overallPanel = new JPanel();
    private final JLabel overallPlayersLabel = new JLabel();
    private final JLabel overallMistakesLabel = new JLabel();
    private final JLabel overallRaidsLabel = new JLabel();
    private final JLabel overallIcon = new JLabel();

    // Panel for all PlayerMistakesBoxes
    private final JPanel mistakesContainer = new JPanel();

    // Keep track of all boxes
    private final List<PlayerMistakesBox> playerMistakesBoxes = new ArrayList<>();

    // Keep track of the current death grouping
    private boolean isRaidDeaths;
    // Keep track of the current view we're showing
    private boolean isShowingAll = false;

    private final PluginErrorPanel errorPanel = new PluginErrorPanel();

    static {
        final BufferedImage raidDeathsImg = ImageUtil.loadImageResource(
                ToaMistakeTrackerPlugin.class, "raid-deaths.png");
        final BufferedImage roomDeathsImg = ImageUtil.loadImageResource(
                ToaMistakeTrackerPlugin.class, "room-deaths.png");

        RAID_DEATHS_ICON = new ImageIcon(raidDeathsImg);
        RAID_DEATHS_ICON_FADED = new ImageIcon(ImageUtil.alphaOffset(raidDeathsImg, -180));
        RAID_DEATHS_ICON_HOVER = new ImageIcon(ImageUtil.alphaOffset(raidDeathsImg, -220));

        ROOM_DEATHS_ICON = new ImageIcon(roomDeathsImg);
        ROOM_DEATHS_ICON_FADED = new ImageIcon(ImageUtil.alphaOffset(roomDeathsImg, -180));
        ROOM_DEATHS_ICON_HOVER = new ImageIcon(ImageUtil.alphaOffset(roomDeathsImg, -220));
    }

    @Inject
    public ToaMistakeTrackerPanel(Client client, MistakeStateReader mistakeStateReader,
                                  @Named("developerMode") boolean developerMode) {
        this.client = client;
        this.mistakeStateManager = mistakeStateReader.read();
        this.currentRaiderNames = Collections.emptyList();

        setBorder(new EmptyBorder(6, 6, 6, 6));
        setBackground(ColorScheme.DARK_GRAY_COLOR);
        setLayout(new BorderLayout());

        // Add the outer panel for wrapping everything else inside
        final JPanel layoutPanel = new JPanel();
        layoutPanel.setLayout(new BoxLayout(layoutPanel, BoxLayout.Y_AXIS));
        add(layoutPanel, BorderLayout.NORTH);

        // Create panel for the header (contains things like view, action buttons, etc.)
        JPanel headerContainer = new JPanel(new GridLayout(2, 1, 0, 0));
        headerContainer.setBackground(ColorScheme.DARKER_GRAY_COLOR);

        // Create the view container
        final JPanel viewContainer = new JPanel(new BorderLayout());
        viewContainer.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        viewContainer.setPreferredSize(new Dimension(0, 30));
        viewContainer.setBorder(new EmptyBorder(5, 5, 5, 10));

        // Create the container for the view title
        final JPanel leftTitleContainer = new JPanel(new BorderLayout(5, 0));
        leftTitleContainer.setBackground(ColorScheme.DARKER_GRAY_COLOR);

        // Create the current view title
        currentViewTitle.setForeground(Color.WHITE);
        currentViewTitle.setText(getCurrentViewTitleText());
        leftTitleContainer.add(currentViewTitle, BorderLayout.WEST);

        // Create the switch view button
        switchMistakesViewBtn.setText(getSwitchMistakesViewButtonText());
        switchMistakesViewBtn.setBackground(Color.DARK_GRAY);
        switchMistakesViewBtn.setBorder(new EmptyBorder(10, 10, 10, 10));
        switchMistakesViewBtn.setBorderPainted(true);
        switchMistakesViewBtn.setPreferredSize(new Dimension(100, 10));

        // Add the listeners to the button
        switchMistakesViewBtn.addActionListener(e -> switchMistakesView());
        switchMistakesViewBtn.addMouseListener(new MouseAdapter() {
            public void mouseEntered(MouseEvent e) {
                switchMistakesViewBtn.setBackground(Color.GRAY);
            }

            public void mouseExited(MouseEvent e) {
                switchMistakesViewBtn.setBackground(Color.DARK_GRAY);
            }
        });

        // Add the view container to header
        viewContainer.add(leftTitleContainer, BorderLayout.WEST);
        viewContainer.add(switchMistakesViewBtn, BorderLayout.EAST);
        headerContainer.add(viewContainer);

        // Create the panel for the action buttons
        final JPanel actionButtons = new JPanel(new FlowLayout(FlowLayout.RIGHT, 0, 0));
        actionButtons.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        actionButtons.setPreferredSize(new Dimension(0, 30));
        actionButtons.setBorder(new EmptyBorder(5, 5, 5, 10));

        // Create the raid deaths button
        SwingUtil.removeButtonDecorations(raidDeathsBtn);
        raidDeathsBtn.setIcon(RAID_DEATHS_ICON_FADED);
        raidDeathsBtn.setRolloverIcon(RAID_DEATHS_ICON_HOVER);
        raidDeathsBtn.setSelectedIcon(RAID_DEATHS_ICON);
        raidDeathsBtn.setToolTipText("Group all raid deaths into a singular mistake");
        raidDeathsBtn.addActionListener(e -> changeDeathGrouping(true));

        // Create the room deaths button
        SwingUtil.removeButtonDecorations(roomDeathsBtn);
        roomDeathsBtn.setIcon(ROOM_DEATHS_ICON_FADED);
        roomDeathsBtn.setRolloverIcon(ROOM_DEATHS_ICON_HOVER);
        roomDeathsBtn.setSelectedIcon(ROOM_DEATHS_ICON);
        roomDeathsBtn.setToolTipText("Show each room's deaths as their own mistakes");
        roomDeathsBtn.addActionListener(e -> changeDeathGrouping(false));

        ButtonGroup raidRoomGroup = new ButtonGroup();
        raidRoomGroup.add(raidDeathsBtn);
        raidRoomGroup.add(roomDeathsBtn);

        // Add all action buttons to the header
        actionButtons.add(raidDeathsBtn);
        actionButtons.add(roomDeathsBtn);
        headerContainer.add(actionButtons);

        changeDeathGrouping(DEFAULT_IS_RAID_DEATHS);
        headerContainer.setVisible(true);

        // Create panel that will contain overall data (at the top)
        overallPanel.setBorder(BorderFactory.createCompoundBorder(
                BorderFactory.createMatteBorder(5, 0, 0, 0, ColorScheme.DARK_GRAY_COLOR),
                BorderFactory.createEmptyBorder(8, 10, 8, 10)
        ));
        overallPanel.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        overallPanel.setLayout(new BorderLayout());

        // Add icon and contents to overallPanel
        final JPanel overallInfo = new JPanel();
        overallInfo.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        overallInfo.setLayout(new GridLayout(3, 1));
        overallInfo.setBorder(new EmptyBorder(2, 10, 2, 0));
        overallPlayersLabel.setFont(FontManager.getRunescapeSmallFont());
        overallMistakesLabel.setFont(FontManager.getRunescapeSmallFont());
        overallRaidsLabel.setFont(FontManager.getRunescapeSmallFont());
        overallInfo.add(overallPlayersLabel);
        overallInfo.add(overallMistakesLabel);
        overallInfo.add(overallRaidsLabel);
        overallPanel.add(overallIcon, BorderLayout.WEST);
        overallPanel.add(overallInfo, BorderLayout.CENTER);

        // Create reset all menu
        final JMenuItem reset = new JMenuItem("Reset All");
        reset.addActionListener(e ->
        {
            final int result = JOptionPane.showOptionDialog(overallPanel,
                    "This will permanently delete ALL mistakes across ALL raids from the client.",
                    "Are you sure?", JOptionPane.YES_NO_OPTION, JOptionPane.WARNING_MESSAGE,
                    null, new String[]{"Yes", "No"}, "No");

            if (result != JOptionPane.YES_OPTION) {
                return;
            }

            resetAll();
        });

        // Create popup menu
        final JPopupMenu popupMenu = new JPopupMenu();
        popupMenu.setBorder(new EmptyBorder(5, 5, 5, 5));
        popupMenu.add(reset);
        overallPanel.setComponentPopupMenu(popupMenu);

        // Create the mistakes panel which shows all mistakes for all players
        mistakesContainer.setLayout(new BoxLayout(mistakesContainer, BoxLayout.Y_AXIS));

        // Add all our panels in the order we want them to appear
        layoutPanel.add(headerContainer);
        layoutPanel.add(overallPanel);
        layoutPanel.add(mistakesContainer);

        // Create testing button
        if (developerMode) {
            JButton testButton = new JButton("Test Mistakes");
            testButton.addActionListener(e ->
            {
                for (ToaMistake mistake : ToaMistake.values()) {
                    addMistakeForPlayer("Test Player", mistake);
                }
            });
            layoutPanel.add(testButton);
        }

        // Add the error for when there are no mistakes yet
        errorPanel.setContent("Toa Mistake Tracker", "You have not tracked any mistakes yet.");
        updateVisiblePanels(true);
    }

    /**
     * The plugin has been reloaded, reload the panel
     */
    public void reload() {
        rebuildAll();
    }

    public void loadHeaderIcon(BufferedImage img) {
        overallIcon.setIcon(new ImageIcon(img));
    }

    /**
     * Resets the current raid mistakes and panel, and notifies the manager that a new raid has been entered
     */
    public void newRaid(List<String> playerNames) {
        currentRaiderNames = playerNames;
        mistakeStateManager.newRaid(new HashSet<>(playerNames));
        if (isShowingAll) {
            updateOverallPanel();
            reorderRaiderBoxes();
        } else {
            // We're looking at the current raid view, reset it and start over
            resetUi();
        }
    }

    /**
     * Adds a mistake for the specified player, both in the manager and the panel.
     *
     * @param playerName - The player name that a mistake was added for
     */
    public void addMistakeForPlayer(String playerName, ToaMistake mistake) {
        mistakeStateManager.addMistakeForPlayer(playerName, mistake);

        PlayerMistakesBox box = buildBox(playerName);
        box.rebuildAllMistakes(isRaidDeaths);
        updateOverallPanel();

        // Ensure ordering is correct
        reorderRaiderBoxes();
    }

    /**
     * Retrieve the current mistake count for the specified player in the current raid
     *
     * @param playerName The player name to get the mistake count for
     * @param mistake    The mistake to get the count for
     * @return The total number of times this mistake has been made in this raid by this player
     */
    public int getCurrentMistakeCountForPlayer(String playerName, ToaMistake mistake) {
        return mistakeStateManager.getCurrentMistakeCountForPlayer(playerName, mistake);
    }

    /**
     * Retrieve the current total mistake count for the specified player in the current raid
     *
     * @param playerName The player name to get the mistake count for
     * @return The total number of mistakes made in this raid by this player
     */
    public int getCurrentTotalMistakeCountForPlayer(String playerName) {
        return mistakeStateManager.getCurrentTotalMistakeCountForPlayer(playerName);
    }

    /**
     * Rebuilds all the boxes from scratch based on which view we're currently looking at
     */
    private void rebuildAll() {
        if (SwingUtilities.isEventDispatchThread()) {
            SwingUtil.fastRemoveAll(mistakesContainer);
        } else {
            mistakesContainer.removeAll();
        }
        playerMistakesBoxes.clear();

        for (String playerName : mistakeStateManager.getPlayersWithMistakes()) {
            buildBox(playerName);
        }

        playerMistakesBoxes.forEach(box -> box.rebuildAllMistakes(isRaidDeaths));
        updateOverallPanel();
        reorderRaiderBoxes();
        mistakesContainer.revalidate();
        mistakesContainer.repaint();

        updateVisiblePanels(playerMistakesBoxes.isEmpty());
    }

    private PlayerMistakesBox buildBox(String playerName) {
        for (PlayerMistakesBox box : playerMistakesBoxes) {
            if (box.getPlayerName().equals(playerName)) {
                return box;
            }
        }

        // Create a new box if one could not be found
        PlayerMistakesBox box = new PlayerMistakesBox(mistakeStateManager, playerName);

        // Use the existing popup menu or create a new one
        JPopupMenu popupMenu = box.getComponentPopupMenu();
        if (popupMenu == null) {
            popupMenu = new JPopupMenu();
            popupMenu.setBorder(new EmptyBorder(5, 5, 5, 5));
            box.setComponentPopupMenu(popupMenu);
        }

        // Create reset menu
        final JMenuItem reset = new JMenuItem("Reset ALL Mistakes for " + playerName);
        reset.addActionListener(e -> {
            mistakeStateManager.removeAllMistakesForPlayer(playerName);
            playerMistakesBoxes.remove(box);

            updateOverallPanel();
            mistakesContainer.remove(box);
            mistakesContainer.repaint();

            if (playerMistakesBoxes.isEmpty()) {
                updateVisiblePanels(true);
            }
        });

        popupMenu.add(reset);

        // Show main view
        updateVisiblePanels(false);

        // Add box to panel
        mistakesContainer.add(box);
        playerMistakesBoxes.add(box);

        return box;
    }

    private void reorderRaiderBoxes() {
        // For lookups
        Map<String, PlayerMistakesBox> playerNameToBox = playerMistakesBoxes.stream()
                .collect(Collectors.toMap(PlayerMistakesBox::getPlayerName, e -> e));

        // Reverse iteration so that we can put each player's box at the top, meaning last raider will be at the bottom
        for (int i = currentRaiderNames.size() - 1; i >= 0; i--) {
            PlayerMistakesBox box = playerNameToBox.get(currentRaiderNames.get(i));
            if (box != null) {
                moveBoxToTop(box);
            }
        }

        // Always put local player at the top
        if (client.getLocalPlayer() != null && playerNameToBox.get(client.getLocalPlayer().getName()) != null) {
            PlayerMistakesBox box = playerNameToBox.get(client.getLocalPlayer().getName());
            moveBoxToTop(box);
        }
    }

    private void resetAll() {
        mistakeStateManager.resetAll();
        resetUi();
    }

    private void resetUi() {
        playerMistakesBoxes.clear();

        updateOverallPanel();
        mistakesContainer.removeAll();
        mistakesContainer.repaint();

        updateVisiblePanels(true);
    }

    private void updateOverallPanel() {
        overallPlayersLabel.setText(htmlLabel("Total players: ",
                mistakeStateManager.getPlayersWithMistakes().size()));
        overallMistakesLabel.setText(htmlLabel("Total mistakes: ",
                mistakeStateManager.getTotalMistakeCountForAllPlayers()));
        overallRaidsLabel.setText(htmlLabel("Tracked raids: ",
                mistakeStateManager.getTrackedRaids()));
    }

    private static String htmlLabel(String key, long value) {
        final String valueStr = QuantityFormatter.quantityToStackSize(value);
        return String.format(HTML_LABEL_TEMPLATE, ColorUtil.toHexColor(ColorScheme.LIGHT_GRAY_COLOR), key, valueStr);
    }

    private boolean doesLocalPlayerHaveMistakesBox() {
        if (client.getLocalPlayer() != null) {
            String name = client.getLocalPlayer().getName();
            return playerMistakesBoxes.stream().anyMatch(b -> b.getPlayerName().equals(name));
        }

        return false;
    }

    private void moveBoxToTop(PlayerMistakesBox box) {
        mistakesContainer.setComponentZOrder(box, 0);
    }

    private void updateVisiblePanels(boolean isEmpty) {
        if (isEmpty) {
            add(errorPanel);
            overallPanel.setVisible(false);
            mistakesContainer.setVisible(false);
        } else {
            remove(errorPanel);
            overallPanel.setVisible(true);
            mistakesContainer.setVisible(true);
        }
    }

    private void changeDeathGrouping(boolean isRaid) {
        isRaidDeaths = isRaid;
        (isRaid ? raidDeathsBtn : roomDeathsBtn).setSelected(true);
        rebuildAll();
    }

    private void switchMistakesView() {
        // TODO: Minor UI bug: Switching panels re-orders mistakes on the first switch, and is consistent afterwards
        // until another mistake is added. This is because we re-order the boxes we add, but don't persist that ordering
        // in the underlying manager.
        isShowingAll = !isShowingAll;
        currentViewTitle.setText(getCurrentViewTitleText());
        switchMistakesViewBtn.setText(getSwitchMistakesViewButtonText());

        mistakeStateManager.switchMistakes();
        rebuildAll();
    }

    private String getCurrentViewTitleText() {
        return isShowingAll ? "All Raids" : "Current Raid";
    }

    private String getSwitchMistakesViewButtonText() {
        return isShowingAll ? "Show Current" : "Show All";
    }
}

package com.toamistaketracker.panel;

import com.toamistaketracker.ToaMistake;
import com.toamistaketracker.mistakestate.MistakeStateManager;
import lombok.Getter;
import lombok.NonNull;
import lombok.Value;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.FontManager;

import javax.swing.ImageIcon;
import javax.swing.JLabel;
import javax.swing.JPanel;
import javax.swing.JPopupMenu;
import javax.swing.SwingConstants;
import javax.swing.border.EmptyBorder;
import java.awt.BorderLayout;
import java.awt.Color;
import java.awt.Dimension;
import java.awt.GridLayout;
import java.awt.image.BufferedImage;
import java.util.ArrayList;
import java.util.List;

/**
 * A panel box for a mistake. This was copied over from ToaMistakeTracker, with minor changes
 */
public class PlayerMistakesBox extends JPanel {

    private static final int ITEMS_PER_ROW = 5;

    private final MistakeStateManager mistakeStateManager;

    @NonNull
    @Getter
    private final String playerName;
    private int totalMistakes;

    private final JPanel mistakesContainer = new JPanel();
    private final JLabel raidCountLabel;
    private final JLabel mistakeCountLabel;

    protected PlayerMistakesBox(MistakeStateManager mistakeStateManager, @NonNull String playerName) {
        this.mistakeStateManager = mistakeStateManager;
        this.playerName = playerName;

        setLayout(new BorderLayout(0, 1));
        setBorder(new EmptyBorder(5, 0, 0, 0));

        final JPanel playerMistakesTitle = new JPanel(new BorderLayout(5, 0));
        playerMistakesTitle.setBorder(new EmptyBorder(7, 7, 7, 7));
        playerMistakesTitle.setBackground(ColorScheme.DARKER_GRAY_COLOR.darker());

        final JLabel playerNameLabel = new JLabel(playerName); // e.g. Questing Pet
        playerNameLabel.setFont(FontManager.getRunescapeSmallFont());
        playerNameLabel.setForeground(Color.WHITE);
        playerMistakesTitle.add(playerNameLabel, BorderLayout.WEST);

        mistakeCountLabel = new JLabel(); // e.g. 78 Mistakes
        mistakeCountLabel.setFont(FontManager.getRunescapeSmallFont());
        mistakeCountLabel.setForeground(Color.LIGHT_GRAY);
        mistakeCountLabel.setHorizontalAlignment(SwingConstants.RIGHT);
        playerMistakesTitle.add(mistakeCountLabel, BorderLayout.CENTER);

        raidCountLabel = new JLabel(); // e.g. (53 Raids)
        raidCountLabel.setFont(FontManager.getRunescapeSmallFont());
        raidCountLabel.setForeground(Color.GRAY);
        playerMistakesTitle.add(raidCountLabel, BorderLayout.EAST);

        add(playerMistakesTitle, BorderLayout.NORTH);
        add(mistakesContainer, BorderLayout.CENTER);

        // Create popup menu for resetting the player's mistakes
        final JPopupMenu popupMenu = new JPopupMenu();
        popupMenu.setBorder(new EmptyBorder(5, 5, 5, 5));
        setComponentPopupMenu(popupMenu);
    }

    void rebuildAllMistakes(boolean isRaidDeaths) {
        buildMistakes(isRaidDeaths);

        final String mistakeString = totalMistakes == 1 ? "Mistake" : "Mistakes";
        mistakeCountLabel.setText(String.format("%s %s", totalMistakes, mistakeString));

        final int totalRaids = mistakeStateManager.getRaidCountForPlayer(playerName);
        if (totalRaids > 0) {
            final String raidString = totalRaids == 1 ? "Raid" : "Raids";
            raidCountLabel.setText(String.format("(%s %s)", totalRaids, raidString));
        }

        validate();
        repaint();
    }

    private void buildMistakes(boolean isRaidDeaths) {
        totalMistakes = 0;
        setVisible(true);

        List<ToaMistakeCount> mistakeCountsForPlayer = new ArrayList<>();
        for (ToaMistake mistake : ToaMistake.values()) {
            if (isRaidDeaths && ToaMistake.isRoomDeath(mistake)) {
                continue;
            } else if (!isRaidDeaths && mistake == ToaMistake.DEATH) {
                continue;
            }

            int mistakeCount = mistakeStateManager.getMistakeCountForPlayer(playerName, mistake);
            if (mistakeCount > 0) {
                totalMistakes += mistakeCount;
                mistakeCountsForPlayer.add(new ToaMistakeCount(mistake, mistakeCount));
            }
        }

        int numRows = calculateNumRows(mistakeCountsForPlayer.size());

        mistakesContainer.removeAll();
        mistakesContainer.setLayout(new GridLayout(numRows, ITEMS_PER_ROW, 1, 1));

        for (int i = 0; i < numRows * ITEMS_PER_ROW; i++) {
            // Create the panel for this mistake
            final JPanel mistakeContainer = new JPanel(new BorderLayout(0, 0));
            mistakeContainer.setMaximumSize(new Dimension(36, 32));
            mistakeContainer.setBackground(ColorScheme.DARKER_GRAY_COLOR);

            // If we still have mistakes to show for this row
            if (i < mistakeCountsForPlayer.size()) {
                ToaMistakeCount mistakeCount = mistakeCountsForPlayer.get(i);

                // Create the image label
                final JLabel imageLabel = new JLabel();
                imageLabel.setLayout(new BorderLayout(0, 0));
                imageLabel.setToolTipText(mistakeCount.getTooltipText());
                imageLabel.setVerticalAlignment(SwingConstants.CENTER);
                imageLabel.setHorizontalAlignment(SwingConstants.CENTER);

                BufferedImage mistakeImage = mistakeCount.getMistake().getMistakeImage();
                imageLabel.setIcon(new ImageIcon(mistakeImage));

                // Create the quantity label
                final JLabel quantityLabel = new JLabel();
                quantityLabel.setText(String.valueOf(mistakeCount.getCount()));
                quantityLabel.setFont(FontManager.getRunescapeSmallFont());
                quantityLabel.setForeground(Color.YELLOW);
                quantityLabel.setVerticalAlignment(SwingConstants.BOTTOM);
                quantityLabel.setHorizontalAlignment(SwingConstants.LEFT);

                // Add them to the panel
                imageLabel.add(quantityLabel, BorderLayout.NORTH); // Add the quantity to the image so it's on top of it
                mistakeContainer.add(imageLabel);

            }
            mistakesContainer.add(mistakeContainer);
        }

        mistakesContainer.repaint();
    }

    private static int calculateNumRows(int numItems) {
        return (int) Math.ceil((double) numItems / ITEMS_PER_ROW);
    }

    @Value
    private static class ToaMistakeCount {

        ToaMistake mistake;
        int count;
        String tooltipText;

        ToaMistakeCount(ToaMistake mistake, int count) {
            this.mistake = mistake;
            this.count = count;
            this.tooltipText = String.format("%s x %s", mistake.getMistakeName(), count);
        }
    }
}

package com.toamistaketracker;

import com.google.common.collect.ImmutableSet;
import lombok.AccessLevel;
import lombok.Getter;
import lombok.NonNull;
import lombok.Setter;
import net.runelite.api.Player;
import net.runelite.api.coords.WorldPoint;

import java.util.Set;

/**
 * Encapsulating class for a {@link Player} and other relevant metadata in a raid.
 */
public class Raider {

    private static final Set<Integer> GHOST_POSE_IDS = ImmutableSet.of(5538, 5539);

    @Getter
    @NonNull
    private final Player player;

    @Getter
    @Setter(AccessLevel.PACKAGE)
    private WorldPoint previousWorldLocation;

    @Getter
    @Setter(AccessLevel.PACKAGE)
    private WorldPoint previousWorldLocationForOverlay;

    @Setter(AccessLevel.PACKAGE)
    private boolean isDead;

    Raider(@NonNull Player player) {
        this.player = player;
    }

    public String getName() {
        return player.getName();
    }

    public WorldPoint getCurrentWorldLocation() {
        return player.getWorldLocation();
    }

    public boolean isDead() {
        // If the plugin is turned off and on, or just as a safety net, also check to see if we're a ghost
        return isDead || GHOST_POSE_IDS.contains(player.getPoseAnimation());
    }
}

package com.toamistaketracker;

public enum StackingBehavior {
    ALL_MISTAKES,
    SAME_MISTAKES_ONLY,
    NONE
    ;
}

