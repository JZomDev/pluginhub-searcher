package com.venomnpctracker;

import lombok.Getter;

@Getter
public enum CompatibilityMode
{
	INTEGRATE("Integrate", 0),
	OVERRIDE("Override", 1);

	private final String name;
	private final int id;

	CompatibilityMode(String name, int id)
	{
		this.name = name;
		this.id = id;
	}
}

package com.venomnpctracker;

import lombok.Getter;

@Getter
public enum DisplayMode
{
	LEVEL("Level", 0),
	NAME("Name", 1),
	BOTH("Both", 2),
	SUFFIXONLY("Suffix-Only", 3);

	private final String name;
	private final int id;

	DisplayMode(String name, int id)
	{
		this.name = name;
		this.id = id;
	}
}
package com.venomnpctracker;

import java.awt.Color;
import net.runelite.client.config.Config;
import net.runelite.client.config.ConfigGroup;
import net.runelite.client.config.ConfigItem;

@ConfigGroup("venomnpctracker")
public interface VenomNpcTrackerConfig extends Config
{
	@ConfigItem(
		keyName = "hpColor",
		name = "HP color",
		description = "The HP color for the monster's menu HP bar",
		position = 1
	)
	default Color hpColor()
	{
		return new Color(0, 99, 67);
	}

	@ConfigItem(
		keyName = "trackPoisonedNpcs",
		name = "Track Poisoned NPCs",
		description = "Configures whether to track poisoned NPCs as well as venomed NPCs",
		position = 2
	)
	default boolean trackPoisonedNpcs()
	{
		return false;
	}

	@ConfigItem(
		keyName = "showVenomSuffix",
		name = "Show Suffix",
		description = "Configures whether to show a -V suffix in the menu of venomed NPCs",
		position = 3
	)
	default boolean showVenomSuffix()
	{
		return true;
	}

	@ConfigItem(
		keyName = "displayMode",
		name = "Display Mode",
		description = "Configures how to display venomed NPCs in the menu",
		position = 4
	)
	default DisplayMode displayMode()
	{
		return DisplayMode.BOTH;
	}

	@ConfigItem(
		keyName = "compatibilityMode",
		name = "Compatibility Behaviour",
		description = "Configures how to behave when Monster Menu HP is also installed",
		position = 5
	)
	default CompatibilityMode compatibilityMode()
	{
		return CompatibilityMode.INTEGRATE;
	}
}

package com.venomnpctracker;

import com.google.common.collect.ImmutableSet;
import com.google.inject.Provides;
import java.awt.Color;
import java.util.Set;
import java.util.ArrayList;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import javax.inject.Inject;
import org.apache.commons.lang3.ArrayUtils;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.MenuAction;
import static net.runelite.api.MenuAction.MENU_ACTION_DEPRIORITIZE_OFFSET;
import static net.runelite.api.HitsplatID.VENOM;
import static net.runelite.api.HitsplatID.POISON;
import net.runelite.api.MenuEntry;
import net.runelite.api.NPC;
import net.runelite.api.WorldView;
import net.runelite.api.events.HitsplatApplied;
import net.runelite.api.events.MenuEntryAdded;
import net.runelite.api.events.NpcDespawned;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.plugins.PluginDescriptor;
import net.runelite.client.plugins.PluginManager;
import net.runelite.client.util.ColorUtil;
import net.runelite.client.util.Text;

@Slf4j
@PluginDescriptor(
	name = "Venomed NPC Tracker",
	description = "Tracks NPCs that have been venomed"
)
public class VenomNpcTrackerPlugin extends Plugin
{
	@Inject
	private Client client;

	@Inject
	private VenomNpcTrackerConfig config;

	private final ArrayList<NPC> venomedNpcs = new ArrayList<>();

	private static final Set<MenuAction> NPC_MENU_ACTIONS = ImmutableSet.of(MenuAction.NPC_FIRST_OPTION, MenuAction.NPC_SECOND_OPTION,
		MenuAction.NPC_THIRD_OPTION, MenuAction.NPC_FOURTH_OPTION, MenuAction.NPC_FIFTH_OPTION, MenuAction.WIDGET_TARGET_ON_NPC,
		MenuAction.ITEM_USE_ON_NPC);

	private static final Pattern COLOR_TAG_PATTERN = Pattern.compile("<col=([a-zA-Z0-9]+)>");

	@Inject
	private PluginManager pluginManager;

	@Inject
	private ConfigManager configManager;

	@Override
	protected void shutDown() throws Exception
	{
		venomedNpcs.clear();
	}

	@Subscribe
	public void onHitsplatApplied(HitsplatApplied hitsplatApplied)
	{
		if ((hitsplatApplied.getHitsplat().getHitsplatType() == VENOM) ||
			(config.trackPoisonedNpcs() && hitsplatApplied.getHitsplat().getHitsplatType() == POISON))
		{
			if (hitsplatApplied.getActor() instanceof NPC)
			{
				if (!venomedNpcs.contains((NPC) hitsplatApplied.getActor()))
				{
					venomedNpcs.add((NPC) hitsplatApplied.getActor());
				}
			}
		}
	}

	@Subscribe
	public void onNpcDespawned(NpcDespawned event)
	{
		venomedNpcs.remove(event.getNpc());
	}

	@Subscribe(priority = -1.0f)
	public void onMenuEntryAdded(MenuEntryAdded event)
	{
		int type = event.getType();

		if (type >= MENU_ACTION_DEPRIORITIZE_OFFSET)
		{
			type -= MENU_ACTION_DEPRIORITIZE_OFFSET;
		}

		final MenuAction menuAction = MenuAction.of(type);

		if (NPC_MENU_ACTIONS.contains(menuAction))
		{
			WorldView wv = client.getTopLevelWorldView();

			NPC npc = wv.npcs().byIndex(event.getIdentifier());

			if (venomedNpcs.contains(npc))
			{

				String target = event.getTarget();
				String finalTarget = null;

				// get MenuHpPlugin if enabled
				Plugin menuHpPlugin = pluginManager.getPlugins().stream()
					.filter(plugin -> "Monster Menu HP".equals(plugin.getName()))
					.findFirst()
					.orElse(null);

				// Integrate with Menu HP if it's installed and enabled
				// Only replace the HP colour tags with our configured colour tags
				// If compatibility mode is set to "INTEGRATE"
				if (menuHpPlugin != null && pluginManager.isPluginEnabled(menuHpPlugin) && config.compatibilityMode().name().equals("INTEGRATE"))
				{
					Color menuHpHpColor = (Color) configManager.getConfiguration("menuhp", "hpColor", Color.class);

					String menuHpHpColorTag = ColorUtil.colorTag(menuHpHpColor);
					String hpColorTag = ColorUtil.colorTag(config.hpColor());

					// Replace only colours of segments wrapped with the menuHpHpColorTag
					finalTarget = target.replaceAll(
						Pattern.quote(menuHpHpColorTag) + "(.*?)</col>",
						hpColorTag + "$1</col>"
					);
				}
				else if (config.displayMode().name().equals("SUFFIXONLY"))
				{
					finalTarget = target;
				}
				// Otherwise, completely override the target with our own formatting
				else
				{
					String cleanTarget = Text.removeTags(event.getTarget());
					Color[] tagColors = getColorsFromTags(target);
					int levelStartIndex = cleanTarget.lastIndexOf('(');
					int nameStartIndex = 0;
					// If there's an arrow, start of name is after the arrow
					int arrowIndex = cleanTarget.lastIndexOf("->");
					String preArrowText = "";
					String arrowText = "";
					if (arrowIndex != -1)
					{
						preArrowText = cleanTarget.substring(0, arrowIndex);
						preArrowText = ColorUtil.wrapWithColorTag(preArrowText, tagColors.length > 0 ? tagColors[0] : Color.WHITE);
						arrowText = "->";
						arrowText = ColorUtil.wrapWithColorTag(arrowText, tagColors.length > 0 ? tagColors[1] : Color.WHITE);
						nameStartIndex = arrowIndex + 2;
					}
					String nameText = levelStartIndex != -1 ? cleanTarget.substring(nameStartIndex, levelStartIndex) : cleanTarget;
					String levelText = levelStartIndex != -1 ? cleanTarget.substring(levelStartIndex) : "";

					switch (config.displayMode())
					{
						case LEVEL:
							levelText = ColorUtil.wrapWithColorTag(levelText, config.hpColor());
							if (arrowIndex != -1)
							{
								nameText = ColorUtil.wrapWithColorTag(nameText, tagColors.length > 2 ? tagColors[2] : Color.WHITE);
							}
							else
							{
								nameText = ColorUtil.wrapWithColorTag(nameText, tagColors.length > 0 ? tagColors[0] : Color.WHITE);
							}
							break;
						case NAME:
							nameText = ColorUtil.wrapWithColorTag(nameText, config.hpColor());
							if (arrowIndex != -1)
							{
								levelText = ColorUtil.wrapWithColorTag(levelText, tagColors.length > 3 ? tagColors[3] : Color.WHITE);
							}
							else
							{
								levelText = ColorUtil.wrapWithColorTag(levelText, tagColors.length > 1 ? tagColors[1] : Color.WHITE);
							}
							break;
						case BOTH:
							nameText = ColorUtil.wrapWithColorTag(nameText, config.hpColor());
							levelText = ColorUtil.wrapWithColorTag(levelText, config.hpColor());
							break;
						default:
							// Shouldn't happen, but just in case, fallback to original colors
							if (arrowIndex != -1)
							{
								nameText = ColorUtil.wrapWithColorTag(nameText, tagColors.length > 2 ? tagColors[2] : Color.WHITE);
								levelText = ColorUtil.wrapWithColorTag(levelText, tagColors.length > 3 ? tagColors[3] : Color.WHITE);
							}
							else
							{
								nameText = ColorUtil.wrapWithColorTag(nameText, tagColors.length > 0 ? tagColors[0] : Color.WHITE);
								levelText = ColorUtil.wrapWithColorTag(levelText, tagColors.length > 1 ? tagColors[1] : Color.WHITE);
							}
					}
					// Construct final string
					finalTarget = preArrowText + arrowText + nameText + levelText;

				}

				if (config.showVenomSuffix())
				{
					String venomIcon = ColorUtil.wrapWithColorTag("V", config.hpColor());
					finalTarget = finalTarget + " - " + venomIcon;
				}

				MenuEntry[] menuEntries = client.getMenuEntries();
				final MenuEntry menuEntry = menuEntries[menuEntries.length - 1];
				menuEntry.setTarget(finalTarget);
				client.setMenuEntries(menuEntries);
			}
		}
	}

	private Color[] getColorsFromTags(String text)
	{
		Color[] result = new Color[]{};
		Matcher matcher = COLOR_TAG_PATTERN.matcher(text);
		while (matcher.find())
		{
			result = ArrayUtils.add(result, Color.decode('#' + matcher.group(1)));
		}
		return result;
	}

	@Provides
	VenomNpcTrackerConfig provideConfig(ConfigManager configManager)
	{
		return configManager.getConfig(VenomNpcTrackerConfig.class);
	}
}

package com.venomnpctracker;

import net.runelite.client.RuneLite;
import net.runelite.client.externalplugins.ExternalPluginManager;

public class VenomNpcTrackerPluginTest
{
	public static void main(String[] args) throws Exception
	{
		ExternalPluginManager.loadBuiltin(VenomNpcTrackerPlugin.class);
		RuneLite.main(args);
	}
}
