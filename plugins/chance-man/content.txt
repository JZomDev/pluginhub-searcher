package com.chanceman.drops;

import lombok.Getter;
import lombok.Setter;

@Setter
@Getter
public class DropItem
{
    private int itemId;
    private String name;
    private String rarity;

    public DropItem(int itemId, String name, String rarity)
    {
        this.itemId = itemId;
        this.name = name;
        this.rarity = rarity;
    }

    /**
     * Convert a raw rarity string like "2/128" to a simplified
     * one-over form, e.g. "1/64". If no fraction is detected,
     * return the original string.
     */
    public String getOneOverRarity()
    {
        if (rarity == null)
        {
            return "";
        }

        java.util.regex.Matcher m = java.util.regex.Pattern
                .compile("(\\d+(?:\\.\\d+)?)\\s*/\\s*(\\d+(?:\\.\\d+)?)")
                .matcher(rarity);

        if (m.find())
        {
            double a = Double.parseDouble(m.group(1));
            double b = Double.parseDouble(m.group(2));
            if (a != 0)
            {
                double val = b / a;
                if (Math.abs(val - Math.round(val)) < 0.01)
                {
                    return "1/" + Math.round(val);
                }
                return String.format("1/%.2f", val);
            }
        }

        return rarity;
    }
}
package com.chanceman.drops;

import lombok.Getter;
import lombok.Setter;

import java.util.List;

@Setter
@Getter
public class DropTableSection
{
    private List<DropItem> items;

    public DropTableSection(String header, List<DropItem> items)
    {
        this.items = items;
    }

}
package com.chanceman.drops;

import static net.runelite.client.RuneLite.RUNELITE_DIR;

import com.chanceman.account.AccountManager;
import com.google.gson.Gson;
import lombok.extern.slf4j.Slf4j;
import javax.inject.Inject;
import javax.inject.Singleton;
import java.io.IOException;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.StandardOpenOption;
import java.time.Duration;
import java.time.Instant;
import java.util.concurrent.CompletableFuture;
import java.util.stream.Stream;

@Slf4j
@Singleton
public class DropCache
{
    private final Gson gson;
    private final AccountManager accountManager;
    private final DropFetcher dropFetcher;
    private static final Duration MAX_AGE = Duration.ofDays(7);

    @Inject
    public DropCache(Gson gson, AccountManager accountManager, DropFetcher dropFetcher)
    {
        this.gson = gson;
        this.accountManager = accountManager;
        this.dropFetcher = dropFetcher;
    }

    /**
     * Load from disk if possible; otherwise fetch from the wiki,
     * write out the JSON, and return the data.
     */
    public CompletableFuture<NpcDropData> get(int npcId, String name, int level)
    {
        final Path file;
        try
        {
            file = getCacheFile(npcId, name, level);
        }
        catch (IOException ex)
        {
            log.error("Could not resolve cache file for {} ({}, lvl {})", npcId, name, level, ex);
            return CompletableFuture.failedFuture(ex);
        }

        return CompletableFuture.supplyAsync(() ->
                {
                    if (Files.exists(file))
                    {
                        try
                        {
                            String json = Files.readString(file, StandardCharsets.UTF_8);
                            return gson.fromJson(json, NpcDropData.class);
                        }
                        catch (Exception e)
                        {
                            log.warn("Failed to read cache {}, will re-fetch", file, e);
                            try
                            {
                                Files.deleteIfExists(file);
                            }
                            catch (IOException ignored) { }
                        }
                    }
                    return null;
                })
                // If we had a valid cache, return it; otherwise fetch & write
                .thenCompose(cached ->
                {
                    if (cached != null)
                    {
                        return CompletableFuture.completedFuture(cached);
                    }

                    return dropFetcher.fetch(npcId, name, level)
                            .thenApply(data ->
                            {
                                try
                                {
                                    String json = gson.toJson(data);
                                    Files.createDirectories(file.getParent());
                                    Files.writeString(
                                            file,
                                            json,
                                            StandardCharsets.UTF_8,
                                            StandardOpenOption.CREATE,
                                            StandardOpenOption.TRUNCATE_EXISTING
                                    );
                                }
                                catch (Exception e)
                                {
                                    log.error("Failed to write cache file: {}", file, e);
                                }
                                return data;
                            })
                            .exceptionally(ex ->
                            {
                                log.error("Error fetching drop data for NPC {}", npcId, ex);
                                return null;
                            });
                });
    }

    private Path getCacheFile(int npcId, String name, int level) throws IOException
    {
        String player = accountManager.getPlayerName();
        if (player == null)
        {
            throw new IOException("Player name is not available");
        }

        String safeName = name.replaceAll("[^A-Za-z0-9]", "_");
        Path dir = RUNELITE_DIR.toPath()
                .resolve("chanceman")
                .resolve(player)
                .resolve("drops");
        Files.createDirectories(dir);

        String fn = npcId + "_" + safeName + "_" + level + ".json";
        return dir.resolve(fn);
    }

    /**
     * Deletes cached drop table files older than {@link #MAX_AGE}.
     */
    public void pruneOldCaches()
    {
        String player = accountManager.getPlayerName();
        if (player == null)
        {
            return;
        }

        Path dir = RUNELITE_DIR.toPath()
                .resolve("chanceman")
                .resolve(player)
                .resolve("drops");

        if (!Files.exists(dir))
        {
            return;
        }

        Instant cutoff = Instant.now().minus(MAX_AGE);
        try (Stream<Path> files = Files.list(dir))
        {
            files.filter(Files::isRegularFile)
                    .forEach(p ->
                    {
                        try
                        {
                            Instant mod = Files.getLastModifiedTime(p).toInstant();
                            if (mod.isBefore(cutoff))
                            {
                                Files.deleteIfExists(p);
                            }
                        }
                        catch (IOException ex)
                        {
                            log.debug("Failed to delete old drop cache {}", p, ex);
                        }
                    });
        }
        catch (IOException ex)
        {
            log.debug("Error pruning drop cache directory {}", dir, ex);
        }
    }
}

package com.chanceman.drops;

import com.google.common.util.concurrent.ThreadFactoryBuilder;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.ItemComposition;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.game.ItemManager;
import net.runelite.http.api.item.ItemPrice;
import okhttp3.OkHttpClient;
import okhttp3.Request;
import okhttp3.Response;
import org.jsoup.Jsoup;
import org.jsoup.nodes.Document;
import org.jsoup.nodes.Element;
import org.jsoup.select.Elements;

import javax.inject.Inject;
import javax.inject.Singleton;
import java.io.IOException;
import java.io.UncheckedIOException;
import java.net.URLEncoder;
import java.nio.charset.StandardCharsets;
import java.util.*;
import java.util.concurrent.*;
import java.util.stream.Collectors;

@Slf4j
@Singleton
public class DropFetcher
{
    private final OkHttpClient httpClient;
    private final ItemManager itemManager;
    private final ClientThread clientThread;
    private ExecutorService fetchExecutor;

    @Inject
    public DropFetcher(OkHttpClient httpClient, ItemManager itemManager, ClientThread clientThread)
    {
        this.httpClient = httpClient;
        this.itemManager  = itemManager;
        this.clientThread = clientThread;
        startUp();
    }

    /**
     * Asynchronously fetches an NPC’s drop tables via the OldSchool RuneScape Wiki’s
     * Special:Lookup endpoint.
     *
     * <p>The lookup URL is constructed as
     * `/w/Special:Lookup?type=npc&amp;id={npcId}&amp;name={fallback}#Drops`,
     * which forces an ID‐first redirect to the exact NPC page (infobox match), and
     * only falls back to the provided name (or a search) if no ID match is found.
     *
     * @param npcId  the numeric NPC ID to look up in the wiki infobox
     * @param name   the NPC name (used as a fallback if the ID lookup fails)
     * @param level  the NPC’s combat level (carried through into the returned data)
     * @return a CompletableFuture that, when complete, yields an NpcDropData
     *         containing the raw HTML‐parsed drop sections and resolved item IDs
     */
    public CompletableFuture<NpcDropData> fetch(int npcId, String name, int level)
    {
        return CompletableFuture.supplyAsync(() -> {
                    String url = buildWikiUrl(npcId, name);
                    String html = fetchHtml(url);
                    List<DropTableSection> sections = parseSections(html);
                    return new NpcDropData(npcId, name, level, sections);
                }, fetchExecutor)

                .thenCompose(data -> {
                    CompletableFuture<NpcDropData> resolved = new CompletableFuture<>();
                    clientThread.invoke(() -> {
                        for (DropTableSection sec : data.getDropTableSections())
                        {
                            for (DropItem d : sec.getItems())
                            {
                                String itemName = d.getName();
                                int resolvedId = itemManager.search(itemName).stream()
                                        .map(ItemPrice::getId)
                                        .filter(id -> {
                                            ItemComposition comp = itemManager.getItemComposition(id);
                                            return comp != null
                                                    && comp.getName().equalsIgnoreCase(itemName);
                                        })
                                        .findFirst()
                                        .orElse(0);
                                d.setItemId(resolvedId);
                            }
                        }
                        resolved.complete(data);
                    });
                    return resolved;
                });
    }

    /**
     * Extract drop table sections from HTML.
     */
    private List<DropTableSection> parseSections(String html)
    {
        Document doc = Jsoup.parse(html);
        Elements tables = doc.select("table.item-drops");

        List<DropTableSection> sections = new ArrayList<>();

        for (Element table : tables)
        {
            String header = "Drops";
            Element prev = table.previousElementSibling();
            while (prev != null)
            {
                if (prev.tagName().matches("h[2-4]"))
                {
                    header = prev.text();
                    break;
                }
                prev = prev.previousElementSibling();
            }

            List<DropItem> items = table.select("tbody tr").stream()
                    .map(row -> row.select("td"))
                    .filter(td -> td.size() >= 6)
                    .map(td -> new DropItem(
                            0,
                            td.get(1).text().replace("(m)", "").trim(),
                            td.get(3).text().trim()))
                    .collect(Collectors.toList());

            if (!items.isEmpty())
            {
                sections.add(new DropTableSection(header, items));
            }
        }
        return sections;
    }

    private String buildWikiUrl(int npcId, String name)
    {
        String fallback = URLEncoder.encode(name.replace(' ', '_'), StandardCharsets.UTF_8);
        return "https://oldschool.runescape.wiki/w/Special:Lookup"
                + "?type=npc"
                + "&id="   + npcId
                + "&name=" + fallback
                + "#Drops";
    }

    private String fetchHtml(String url)
    {
        Request req = new Request.Builder()
                .url(url)
                .header("User-Agent", "RuneLite-ChanceMan/2.4.0")
                .build();
        try (Response res = httpClient.newCall(req).execute())
        {
            if (!res.isSuccessful())
                throw new IOException("HTTP " + res.code());
            return res.body().string();
        }
        catch (IOException ex)
        {
            throw new UncheckedIOException(ex);
        }
    }

    /**
     * Creates the fetch executor if it is missing or has been shut down.
     */
    public void startUp()
    {
        if (fetchExecutor == null || fetchExecutor.isShutdown() || fetchExecutor.isTerminated())
        {
            fetchExecutor = Executors.newFixedThreadPool(
                    2,
                    new ThreadFactoryBuilder().setNameFormat("dropfetch-%d").build()
            );
        }
    }

    /**
     *  shut down the executor
     */
    public void shutdown()
    {
        if (fetchExecutor != null)
        {
            fetchExecutor.shutdownNow();
            fetchExecutor = null;
        }
    }
}

package com.chanceman.drops;

import lombok.Getter;
import lombok.Setter;

import java.util.List;

@Setter
@Getter
public class NpcDropData
{
    private int npcId;
    private String name;
    private int level;
    private List<DropTableSection> dropTableSections;

    public NpcDropData(int npcId, String name, int level, List<DropTableSection> dropTableSections)
    {
        this.npcId = npcId;
        this.name = name;
        this.level = level;
        this.dropTableSections = dropTableSections;
    }

}

package com.chanceman.managers;

import com.chanceman.ChanceManOverlay;
import com.chanceman.ChanceManPanel;
import lombok.Getter;
import lombok.Setter;
import net.runelite.api.ChatMessageType;
import net.runelite.api.Client;
import net.runelite.api.ItemComposition;
import net.runelite.client.game.ItemManager;
import net.runelite.client.callback.ClientThread;

import javax.inject.Inject;
import javax.inject.Singleton;
import javax.swing.*;
import java.util.*;
import java.util.concurrent.ConcurrentLinkedQueue;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

/**
 * Manages the roll animation for unlocking items.
 * It processes roll requests asynchronously and handles the roll animation through the overlay.
 */
@Singleton
public class RollAnimationManager
{
    @Inject private ItemManager itemManager;
    @Inject private Client client;
    @Inject private ClientThread clientThread;
    @Inject private UnlockedItemsManager unlockedManager;
    @Inject private ChanceManOverlay overlay;
    @Setter private ChanceManPanel chanceManPanel;

    @Setter private HashSet<Integer> allTradeableItems;
    private final Queue<Integer> rollQueue = new ConcurrentLinkedQueue<>();
    private ExecutorService executor = Executors.newSingleThreadExecutor();
    private volatile boolean isRolling = false;
    private final int rollDuration = 3000; // Continuous phase duration (ms)
    private final int highlightDuration = 1500; // Highlight phase (ms)
    private final Random random = new Random();

    @Getter
    @Setter
    private volatile boolean manualRoll = false;

    /**
     * Enqueues an item ID for the roll animation.
     *
     * @param itemId The item ID to be rolled.
     */
    public void enqueueRoll(int itemId)
    {
        rollQueue.offer(itemId);
    }

    /**
     * Processes the roll queue by initiating a roll animation if not already rolling.
     */
    public void process()
    {
        if (!isRolling && !rollQueue.isEmpty())
        {
            int queuedItemId = rollQueue.poll();
            isRolling = true;
            executor.submit(() -> performRoll(queuedItemId));
        }
    }

    /**
     * Performs the roll animation, unlocking the final item and sending a chat message.
     */
    private void performRoll(int queuedItemId)
    {
        overlay.startRollAnimation(0, rollDuration, this::getRandomLockedItem);
        try {
            Thread.sleep(rollDuration + highlightDuration);
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        }
        int finalRolledItem = overlay.getFinalItem();
        unlockedManager.unlockItem(finalRolledItem);
        final boolean wasManualRoll = isManualRoll();
        clientThread.invoke(() -> {
            String message;
            if (wasManualRoll)
            {
                message = "Unlocked " + "<col=267567>" + getItemName(finalRolledItem) + "</col>" +
                      " by" + "<col=ff0000> pressing a button</col>";
            }
            else
            {
                message = "Unlocked " + "<col=267567>" + getItemName(finalRolledItem) + "</col>"
                        + " by rolling " + "<col=ff0000>" + getItemName(queuedItemId) + "</col>";
            }
            client.addChatMessage(ChatMessageType.GAMEMESSAGE, "", message, null);
            if (chanceManPanel != null) {
                SwingUtilities.invokeLater(() -> chanceManPanel.updatePanel());
            }
        });
        setManualRoll(false);
        isRolling = false;
    }

    /**
     * Checks if a roll animation is currently in progress.
     *
     * @return true if a roll is in progress, false otherwise.
     */
    public boolean isRolling() {
        return isRolling;
    }

    /**
     * Retrieves a random locked item from the list of tradeable items.
     *
     * @return A random locked item ID, or a fallback if all items are unlocked.
     */
    public int getRandomLockedItem()
    {
        List<Integer> locked = new ArrayList<>();
        for (int id : allTradeableItems)
        {
            if (!unlockedManager.isUnlocked(id))
            {
                locked.add(id);
            }
        }
        if (locked.isEmpty())
        {
            int fallback = overlay.getFinalItem();
            return fallback;
        }
        int selected = locked.get(random.nextInt(locked.size()));
        return selected;
    }

    public String getItemName(int itemId)
    {
        ItemComposition comp = itemManager.getItemComposition(itemId);
        return comp != null ? comp.getName() : "Unknown";
    }

    public void startUp() {
        if (executor == null || executor.isShutdown() || executor.isTerminated()) {
            executor = Executors.newSingleThreadExecutor();
        }
    }

    /**
     * Shuts down the roll animation executor service.
     */
    public void shutdown()
    {
        executor.shutdownNow();
    }
}

package com.chanceman.managers;

import com.chanceman.account.AccountManager;
import com.google.gson.Gson;
import lombok.Setter;
import lombok.extern.slf4j.Slf4j;

import javax.inject.Inject;
import javax.inject.Singleton;
import java.io.BufferedWriter;
import java.io.IOException;
import java.io.Reader;
import java.nio.file.*;
import java.text.SimpleDateFormat;
import java.util.*;
import java.util.concurrent.ExecutorService;

import static net.runelite.client.RuneLite.RUNELITE_DIR;

/**
 * Manages the set of rolled items with atomic persistence.
 * Provides thread-safe operations for marking items as rolled,
 * loading from and saving to disk with backups and atomic moves.
 */
@Slf4j
@Singleton
public class RolledItemsManager
{
    private static final int MAX_BACKUPS = 10;
    private final Set<Integer> rolledItems = Collections.synchronizedSet(new LinkedHashSet<>());

    @Inject private AccountManager accountManager;
    @Inject private Gson gson;
    @Setter private ExecutorService executor;

    /**
     * Atomically moves source→target, but if ATOMIC_MOVE fails retries a normal move with REPLACE_EXISTING.
     */
    private void safeMove(Path source, Path target, CopyOption... opts) throws IOException
    {
        try
        {
            Files.move(source, target, opts);
        }
        catch (AtomicMoveNotSupportedException | AccessDeniedException ex)
        {
            // remove ATOMIC_MOVE, add REPLACE_EXISTING
            Set<CopyOption> fallback = new HashSet<>(Arrays.asList(opts));
            fallback.remove(StandardCopyOption.ATOMIC_MOVE);
            fallback.add(StandardCopyOption.REPLACE_EXISTING);
            Files.move(source, target, fallback.toArray(new CopyOption[0]));
        }
    }

    /**
     * Builds the file path for the current account's rolled-items JSON file.
     *
     * @return path to the rolled items JSON file
     */
    private Path getFilePath() throws IOException
    {
        String name = accountManager.getPlayerName();
        if (name == null)
        {
            throw new IOException("Player name is null");
        }
        Path dir = RUNELITE_DIR.toPath()
                .resolve("chanceman")
                .resolve(name);
        Files.createDirectories(dir);
        return dir.resolve("chanceman_rolled.json");
    }

      /**
     * Checks if an item has been rolled.
     *
     * @param itemId The item ID.
     * @return true if the item has been rolled, false otherwise.
     */
    public boolean isRolled(int itemId)
    {
        return rolledItems.contains(itemId);
    }

    /**
     * Marks an item as rolled and triggers an asynchronous save.
     *
     * @param itemId The item ID to mark as rolled.
     */
    public void markRolled(int itemId)
    {
        if (rolledItems.add(itemId))
        {
            saveRolledItems();
        }
    }

    /**
     * Loads the set of rolled items from disk into memory.
     * If the file does not exist or is empty, initializes an empty set.
     */
    public void loadRolledItems()
    {
        if (accountManager.getPlayerName() == null)
        {
            return;
        }

        rolledItems.clear();
        Path file;
        try
        {
            file = getFilePath();
        }
        catch (IOException ioe)
        {
            return;
        }

        if (!Files.exists(file))
        {
            // first run: write an empty file
            saveRolledItems();
            return;
        }

        try (Reader r = Files.newBufferedReader(file))
        {
            Set<Integer> loaded = gson.fromJson(r,
                    new com.google.gson.reflect.TypeToken<Set<Integer>>() {}.getType());
            if (loaded != null)
            {
                rolledItems.addAll(loaded);
            }
        }
        catch (IOException e)
        {
            log.error("Error loading rolled items", e);
        }
    }

    /**
     * Saves the current set of rolled items to disk.
     * Uses a temporary file and backups for atomicity and data safety.
     */
    public void saveRolledItems()
    {
        executor.submit(() ->
        {
            Path file;
            try
            {
                file = getFilePath();
            }
            catch (IOException ioe)
            {
                log.error("Could not resolve rolled‑items path", ioe);
                return;
            }

            try
            {
                // 1) backup current .json
                if (Files.exists(file))
                {
                    Path backups = file.getParent().resolve("backups");
                    Files.createDirectories(backups);
                    String ts = new SimpleDateFormat("yyyyMMddHHmmss").format(new Date());
                    Path bak = backups.resolve(file.getFileName() + "." + ts + ".bak");
                    safeMove(file, bak,
                            StandardCopyOption.ATOMIC_MOVE,
                            StandardCopyOption.REPLACE_EXISTING);
                    // prune old backups…
                    Files.list(backups)
                            .filter(p -> p.getFileName().toString().startsWith(file.getFileName() + "."))
                            .sorted(Comparator.comparing(Path::getFileName).reversed())
                            .skip(MAX_BACKUPS)
                            .forEach(p -> p.toFile().delete());
                }

                // 2) write new JSON to .tmp
                Path tmp = file.resolveSibling(file.getFileName() + ".tmp");
                try (BufferedWriter w = Files.newBufferedWriter(tmp))
                {
                    gson.toJson(rolledItems, w);
                }

                // 3) atomically replace .json
                safeMove(tmp, file, StandardCopyOption.ATOMIC_MOVE);
            }
            catch (IOException e)
            {
                log.error("Error saving rolled items", e);
            }
        });
    }

    /**
     * Retrieves an unmodifiable set of rolled item IDs.
     *
     * @return An unmodifiable set of rolled item IDs.
     */
    public Set<Integer> getRolledItems()
    {
        return Collections.unmodifiableSet(rolledItems);
    }
}
package com.chanceman.managers;

import com.chanceman.account.AccountManager;
import com.google.gson.Gson;
import lombok.Setter;
import lombok.extern.slf4j.Slf4j;

import javax.inject.Inject;
import javax.inject.Singleton;
import java.io.BufferedWriter;
import java.io.IOException;
import java.io.Reader;
import java.nio.file.*;
import java.text.SimpleDateFormat;
import java.util.*;
import java.util.concurrent.ExecutorService;

import static net.runelite.client.RuneLite.RUNELITE_DIR;

/**
 * Manages the set of unlocked items with robust, atomic persistence and 10‑file backup rotation.
 */
@Slf4j
@Singleton
public class UnlockedItemsManager
{
    private static final int MAX_BACKUPS = 10;

    private final Set<Integer> unlockedItems = Collections.synchronizedSet(new LinkedHashSet<>());

    @Inject private AccountManager accountManager;
    @Inject private Gson gson;
    @Setter private ExecutorService executor;

    public boolean ready()
    {
        return accountManager.getPlayerName() != null;
    }

    /**
     * Atomically moves source→target, but if ATOMIC_MOVE fails retries a normal move with REPLACE_EXISTING.
     */
    private void safeMove(Path source, Path target, CopyOption... opts) throws IOException
    {
        try
        {
            Files.move(source, target, opts);
        }
        catch (AtomicMoveNotSupportedException | AccessDeniedException ex)
        {
            // retry without ATOMIC_MOVE but with REPLACE_EXISTING
            Set<CopyOption> fallback = new HashSet<>(Arrays.asList(opts));
            fallback.remove(StandardCopyOption.ATOMIC_MOVE);
            fallback.add(StandardCopyOption.REPLACE_EXISTING);
            Files.move(source, target, fallback.toArray(new CopyOption[0]));
        }
    }

    private Path getFilePath() throws IOException
    {
        String name = accountManager.getPlayerName();
        if (name == null)
        {
            throw new IOException("Player name is null");
        }
        Path dir = RUNELITE_DIR.toPath()
                .resolve("chanceman")
                .resolve(name);
        Files.createDirectories(dir);
        return dir.resolve("chanceman_unlocked.json");
    }

    public boolean isUnlocked(int itemId)
    {
        return unlockedItems.contains(itemId);
    }

    public void unlockItem(int itemId)
    {
        if (unlockedItems.add(itemId))
        {
            saveUnlockedItems();
        }
    }

    public void loadUnlockedItems()
    {
        if (!ready())
        {
            return;
        }

        unlockedItems.clear();
        Path file;
        try
        {
            file = getFilePath();
        }
        catch (IOException ioe)
        {
            return;
        }

        if (!Files.exists(file))
        {
            // first‑run: empty set → write an empty JSON file
            saveUnlockedItems();
            return;
        }

        try (Reader r = Files.newBufferedReader(file))
        {
            Set<Integer> loaded = gson.fromJson(r,
                    new com.google.gson.reflect.TypeToken<Set<Integer>>() {}.getType());
            if (loaded != null)
            {
                unlockedItems.addAll(loaded);
            }
        }
        catch (IOException e)
        {
            log.error("Error loading unlocked items", e);
        }
    }

    public void saveUnlockedItems()
    {
        executor.submit(() ->
        {
            Path file;
            try
            {
                file = getFilePath();
            }
            catch (IOException ioe)
            {
                log.error("Could not resolve file path", ioe);
                return;
            }

            try
            {
                // 1) rotate .json → .bak
                if (Files.exists(file))
                {
                    Path backups = file.getParent().resolve("backups");
                    Files.createDirectories(backups);
                    String ts = new SimpleDateFormat("yyyyMMddHHmmss").format(new Date());
                    Path bak = backups.resolve(file.getFileName() + "." + ts + ".bak");
                    safeMove(file, bak,
                            StandardCopyOption.ATOMIC_MOVE,
                            StandardCopyOption.REPLACE_EXISTING);
                    // prune older backups…
                    Files.list(backups)
                            .filter(p -> p.getFileName().toString().startsWith(file.getFileName() + "."))
                            .sorted(Comparator.comparing(Path::getFileName).reversed())
                            .skip(MAX_BACKUPS)
                            .forEach(p -> p.toFile().delete());
                }

                // 2) write new JSON to .tmp
                Path tmp = file.resolveSibling(file.getFileName() + ".tmp");
                try (BufferedWriter w = Files.newBufferedWriter(tmp))
                {
                    gson.toJson(unlockedItems, w);
                }

                // 3) atomically replace .json with .tmp
                safeMove(tmp, file, StandardCopyOption.ATOMIC_MOVE);
            }
            catch (IOException e)
            {
                log.error("Error saving unlocked items", e);
            }
        });
    }


    /**
     * Retrieves an unmodifiable set of unlocked item IDs.
     *
     * @return An unmodifiable set of unlocked item IDs.
     */
    public Set<Integer> getUnlockedItems()
    {
        return Collections.unmodifiableSet(unlockedItems);
    }
}

package com.chanceman;


import com.chanceman.account.AccountChanged;
import com.chanceman.account.AccountManager;
import com.chanceman.drops.DropFetcher;
import com.chanceman.drops.DropCache;
import com.chanceman.filters.EnsouledHeadMapping;
import com.chanceman.menus.ActionHandler;
import com.chanceman.filters.ItemsFilter;
import com.chanceman.ui.DropsTabUI;
import com.chanceman.ui.DropsTooltipOverlay;
import com.chanceman.ui.MusicWidgetController;
import com.google.gson.Gson;
import com.google.inject.Provides;
import lombok.Getter;
import com.chanceman.managers.RollAnimationManager;
import com.chanceman.managers.RolledItemsManager;
import com.chanceman.managers.UnlockedItemsManager;
import net.runelite.api.*;
import net.runelite.api.events.*;
import net.runelite.api.widgets.Widget;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.eventbus.EventBus;
import net.runelite.client.game.ItemManager;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.plugins.PluginDescriptor;
import net.runelite.client.ui.ClientToolbar;
import net.runelite.client.ui.NavigationButton;
import net.runelite.client.ui.overlay.OverlayManager;
import net.runelite.client.util.ImageUtil;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.config.ConfigManager;
import javax.inject.Inject;
import javax.swing.*;
import java.awt.image.BufferedImage;
import java.util.*;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

@PluginDescriptor(
        name = "ChanceMan",
        description = "Locks tradeable items until unlocked via a random roll.",
        tags = {"osrs", "chance", "roll", "lock", "unlock"}
)
public class ChanceManPlugin extends Plugin
{
    @Inject
    private Client client;
    @Inject
    private ClientThread clientThread;
    @Inject
    private ClientToolbar clientToolbar;
    @Inject
    private OverlayManager overlayManager;
    @Inject
    private ChatMessageManager chatMessageManager;
    @Inject
    private ItemManager itemManager;
    @Inject
    private ChanceManOverlay chanceManOverlay;
    @Inject
    private DropsTooltipOverlay dropsTooltipOverlay;
    @Inject
    private Gson gson;
    @Inject
    private ChanceManConfig config;
    @Inject
    private ConfigManager configManager;
    @Inject
    private AccountManager accountManager;
    @Inject
    private UnlockedItemsManager unlockedItemsManager;
    @Inject
    private RolledItemsManager rolledItemsManager;
    @Inject
    private RollAnimationManager rollAnimationManager;
    @Inject
    private EventBus eventBus;
    @Inject
    private ItemsFilter itemsFilter;
    @Inject private DropsTabUI dropsTabUI;
    @Inject private DropFetcher dropFetcher;
    @Inject private DropCache dropCache;
    @Inject private MusicWidgetController musicWidgetController;

    private ChanceManPanel chanceManPanel;
    private NavigationButton navButton;
    private ExecutorService fileExecutor;
    @Getter private final HashSet<Integer> allTradeableItems = new LinkedHashSet<>();
    private static final int GE_SEARCH_BUILD_SCRIPT = 751;
    private boolean tradeableItemsInitialized = false;
    private boolean featuresActive = false;

    @Provides
    ChanceManConfig provideConfig(ConfigManager configManager)
    {
        return configManager.getConfig(ChanceManConfig.class);
    }

    @Override
    protected void startUp() throws Exception
    {
        eventBus.register(this);
        if (isNormalWorld()) enableFeatures();
    }

    @Override
    protected void shutDown() throws Exception
    {
        if (featuresActive) disableFeatures();
        eventBus.unregister(this);
    }

    private void enableFeatures()
    {
        if (featuresActive) return;
        featuresActive = true;

        getInjector().getInstance(ActionHandler.class).startUp();
        dropFetcher.startUp();
        eventBus.register(accountManager);
        overlayManager.add(chanceManOverlay);
        overlayManager.add(dropsTooltipOverlay);
        fileExecutor = Executors.newSingleThreadExecutor();
        unlockedItemsManager.setExecutor(fileExecutor);
        rolledItemsManager.setExecutor(fileExecutor);
        rollAnimationManager.startUp();
        dropsTabUI.startUp();

        chanceManPanel = new ChanceManPanel(
                unlockedItemsManager,
                rolledItemsManager,
                itemManager,
                allTradeableItems,
                clientThread,
                rollAnimationManager
        );
        rollAnimationManager.setChanceManPanel(chanceManPanel);

        BufferedImage icon = ImageUtil.loadImageResource(
                getClass(), "/net/runelite/client/plugins/chanceman/icon.png"
        );
        navButton = NavigationButton.builder()
                .tooltip("ChanceMan")
                .icon(icon)
                .priority(5)
                .panel(chanceManPanel)
                .build();
        clientToolbar.addNavigation(navButton);

        accountManager.init();
    }

    private void disableFeatures()
    {
        if (!featuresActive) return;
        featuresActive = false;
        dropsTabUI.shutDown();
        eventBus.unregister(accountManager);
        getInjector().getInstance(ActionHandler.class).shutDown();
        clientThread.invokeLater(musicWidgetController::restore);

        if (clientToolbar != null && navButton != null)
        {
            clientToolbar.removeNavigation(navButton);
            navButton = null;
        }
        if (overlayManager != null)
        {
            overlayManager.remove(chanceManOverlay);
            overlayManager.remove(dropsTooltipOverlay);
        }
        if (rollAnimationManager != null)
        {
            rollAnimationManager.shutdown();
        }
        if (fileExecutor != null)
        {
            fileExecutor.shutdownNow();
            fileExecutor = null;
        }
        dropFetcher.shutdown();

        // reset panel/tradeable state
        chanceManPanel = null;
        allTradeableItems.clear();
        tradeableItemsInitialized = false;
        accountManager.reset();
    }

    @Subscribe
    public void onWorldChanged(WorldChanged event)
    {
        if (isNormalWorld()) enableFeatures();
        else disableFeatures();
    }

    /**
     * Refreshes the list of tradeable item IDs based on the current configuration.
     */
    public void refreshTradeableItems() {
        clientThread.invokeLater(() -> {
            allTradeableItems.clear();
            for (int i = 0; i < 40000; i++) {
                ItemComposition comp = itemManager.getItemComposition(i);
                if (comp != null && comp.isTradeable() && !isNotTracked(i)
                        && !ItemsFilter.isBlocked(i, config)) {
                    if (config.freeToPlay() && comp.isMembers()) {
                        continue;
                    }
                    if (!ItemsFilter.isPoisonEligible(i, config.requireWeaponPoison(),
                            unlockedItemsManager.getUnlockedItems())) {
                        continue;
                    }
                    allTradeableItems.add(i);
                }
            }
            rollAnimationManager.setAllTradeableItems(allTradeableItems);
            if (chanceManPanel != null) {
                SwingUtilities.invokeLater(() -> chanceManPanel.updatePanel());
            }
        });
    }


    @Subscribe
    public void onConfigChanged(net.runelite.client.events.ConfigChanged event)
    {
        if (!featuresActive) return;
        if (!event.getGroup().equals("chanceman")) return;
        switch (event.getKey())
        {
            case "freeToPlay":
            case "includeF2PTradeOnlyItems":
            case "enableFlatpacks":
            case "enableItemSets":
            case "requireWeaponPoison":
                refreshTradeableItems();
                break;
        }
    }

    @Subscribe
    private void onAccountChanged(AccountChanged event)
    {
        if (!featuresActive) return;
        dropCache.pruneOldCaches();
        unlockedItemsManager.loadUnlockedItems();
        rolledItemsManager.loadRolledItems();
        if (chanceManPanel != null)
        {
            SwingUtilities.invokeLater(() -> chanceManPanel.updatePanel());
        }
    }

    @Subscribe
    public void onGameTick(GameTick event)
    {
        if (!featuresActive) return;
        if (!tradeableItemsInitialized && client.getGameState() == GameState.LOGGED_IN)
        {
            refreshTradeableItems();
            tradeableItemsInitialized = true;
        }

        rollAnimationManager.process();
    }

    @Subscribe
    public void onScriptPostFired(ScriptPostFired event)
    {
        if (!featuresActive) return;
        if (event.getScriptId() == GE_SEARCH_BUILD_SCRIPT) { killSearchResults(); }
    }

    private void killSearchResults() {
        Widget geSearchResults = client.getWidget(162, 51);
        if (geSearchResults == null) {
            return;
        }
        Widget[] children = geSearchResults.getDynamicChildren();
        if (children == null || children.length < 2 || children.length % 3 != 0) {
            return;
        }
        Set<Integer> unlocked = unlockedItemsManager.getUnlockedItems();
        Set<Integer> rolled = rolledItemsManager.getRolledItems();
        boolean requireRolled = config.requireRolledUnlockedForGe();
        for (int i = 0; i < children.length; i += 3) {
            int offerItemId = children[i + 2].getItemId();
            boolean isUnlocked = unlocked.contains(offerItemId);
            boolean isRolled = rolled.contains(offerItemId);
            boolean hide = requireRolled ? !(isUnlocked && isRolled) : !isUnlocked;
            if (hide) {
                children[i].setHidden(true);
                children[i + 1].setOpacity(70);
                children[i + 2].setOpacity(70);
            }
        }
    }

    @Subscribe
    public void onItemSpawned(ItemSpawned event)
    {
        if (!featuresActive) return;
        if (!accountManager.ready()) return;

        TileItem tileItem = (TileItem) event.getItem();
        int itemId = tileItem.getId();
        ItemComposition comp = itemManager.getItemComposition(itemId);
        String name = (comp != null && comp.getName() != null) ? comp.getName() : tileItem.toString();
        if (name.toLowerCase().contains("ensouled")) {
            int mappedId = ItemsFilter.getEnsouledHeadId(name);
            if (mappedId != EnsouledHeadMapping.DEFAULT_ENSOULED_HEAD_ID) { itemId = mappedId; }
        }
        int canonicalItemId = itemManager.canonicalize(itemId);
        if (!isTradeable(canonicalItemId) || isNotTracked(canonicalItemId))
        {
            return;
        }
        if (tileItem.getOwnership() != TileItem.OWNERSHIP_SELF)
        {
            return;
        }
        if (rolledItemsManager == null)
        {
            return;
        }
        if (!rolledItemsManager.isRolled(canonicalItemId))
        {
            rollAnimationManager.enqueueRoll(canonicalItemId);
            rolledItemsManager.markRolled(canonicalItemId);
        }
    }

    @Subscribe
    public void onItemContainerChanged(ItemContainerChanged event)
    {
        if (!featuresActive) return;
        if (!accountManager.ready()) return;

        if (event.getContainerId() == 93)
        {
            Set<Integer> processed = new HashSet<>();
            for (net.runelite.api.Item item : event.getItemContainer().getItems())
            {
                int rawItemId = item.getId();
                int canonicalId = itemManager.canonicalize(rawItemId);
                if (!isTradeable(canonicalId) || isNotTracked(canonicalId))
                {
                    continue;
                }
                if (!processed.contains(canonicalId) && !rolledItemsManager.isRolled(canonicalId))
                {
                    rollAnimationManager.enqueueRoll(canonicalId);
                    rolledItemsManager.markRolled(canonicalId);
                    processed.add(canonicalId);
                }
            }
        }
    }

    public boolean isNormalWorld()
    {
        EnumSet<WorldType> worldTypes = client.getWorldType();
        return !(worldTypes.contains(WorldType.DEADMAN)
                || worldTypes.contains(WorldType.SEASONAL)
                || worldTypes.contains(WorldType.BETA_WORLD)
                || worldTypes.contains(WorldType.PVP_ARENA)
                || worldTypes.contains(WorldType.QUEST_SPEEDRUNNING)
                || worldTypes.contains(WorldType.TOURNAMENT_WORLD));
    }

    public boolean isTradeable(int itemId)
    {
        ItemComposition comp = itemManager.getItemComposition(itemId);
        return comp != null && comp.isTradeable();
    }

    public boolean isNotTracked(int itemId)
    {
        return itemId == 995 || itemId == 13191 || itemId == 13190 ||
                itemId == 7587 || itemId == 7588 || itemId == 7589 || itemId == 7590 || itemId == 7591;
    }

    public boolean isInPlay(int itemId)
    {
        return allTradeableItems.contains(itemId);
    }

    public ItemManager getItemManager() { return itemManager; }

}

package com.chanceman;

import net.runelite.client.config.Config;
import net.runelite.client.config.ConfigGroup;
import net.runelite.client.config.ConfigItem;

@ConfigGroup("chanceman")
public interface ChanceManConfig extends Config
{
    @ConfigItem(
            keyName = "freeToPlay",
            name = "Free To Play Mode",
            description = "Only allow free-to-play items",
            position = 1
    )
    default boolean freeToPlay()
    {
        return false;
    }

    @ConfigItem(
            keyName = "includeF2PTradeOnlyItems",
            name = "Include F2P trade-only items",
            description = "When Free-to-Play mode is enabled, also roll items that can only " +
                    "be obtained via trading or the Grand Exchange.",
            position = 2
    )
    default boolean includeF2PTradeOnlyItems() { return false; }

    @ConfigItem(
            keyName = "enableItemSets",
            name = "Roll Item Sets",
            description = "Include item set items in the rollable items list. Disabling this will exclude any" +
                    " item set items from random rolls.",
            position = 3
    )
    default boolean enableItemSets() { return true; }

    @ConfigItem(
            keyName = "enableFlatpacks",
            name = "Roll Flatpacks",
            description = "Include flatpacks in the rollable items list. Disabling this will prevent" +
                    " flatpacks from being rolled.",
            position = 4
    )
    default boolean enableFlatpacks() { return true; }

    @ConfigItem(
            keyName = "requireWeaponPoison",
            name = "Weapon Poison Unlock Requirements",
            description = "Force poison variants to roll only if both the base weapon and the corresponding" +
                    " weapon poison are unlocked. (Disabling this will allow poisoned variants to roll even if " +
                    "the poison is locked.)",
            position = 5
    )
    default boolean requireWeaponPoison() { return true; }

    @ConfigItem(
            keyName = "enableRollSounds",
            name = "Enable Roll Sounds",
            description = "Toggle Roll Sound",
            position = 6
    )
    default boolean enableRollSounds() { return true; }

    @ConfigItem(
            keyName = "requireRolledUnlockedForGe",
            name = "GE Requires Rolled and Unlocked",
            description = "Only allow Grand Exchange purchases once items are both rolled and unlocked.",
            position = 7
    )
    default boolean requireRolledUnlockedForGe() { return true; }
}

package com.chanceman.ui;

import com.chanceman.drops.NpcDropData;
import com.chanceman.drops.DropItem;
import com.chanceman.managers.RolledItemsManager;
import lombok.Getter;
import lombok.extern.slf4j.Slf4j;
import javax.inject.Inject;
import javax.inject.Singleton;
import java.util.*;
import java.util.stream.Collectors;
import net.runelite.api.Client;
import net.runelite.client.callback.ClientThread;
import net.runelite.api.widgets.Widget;
import net.runelite.api.widgets.WidgetType;
import net.runelite.api.widgets.ItemQuantityMode;

@Slf4j
@Singleton
public class MusicWidgetController
{
    private static final int MUSIC_GROUP = 239;
    private final Client client;
    private final ClientThread clientThread;
    private final RolledItemsManager rolledItemsManager;
    private final SpriteOverrideManager spriteOverrideManager;
    private final ItemSpriteCache itemSpriteCache;

    private NpcDropData currentDrops = null;
    private List<Widget> backupJukeboxStaticKids = null;
    private List<Widget> backupJukeboxDynamicKids = null;
    private List<Widget> backupScrollStaticKids = null;
    private List<Widget> backupScrollDynamicKids = null;
    private String originalTitleText = null;
    @Getter private final Map<Widget, DropItem> iconItemMap = new HashMap<>();
    @Getter private boolean overrideActive = false;

    @Inject
    public MusicWidgetController(
            Client client,
            ClientThread clientThread,
            RolledItemsManager rolledItemsManager,
            SpriteOverrideManager spriteOverrideManager,
            ItemSpriteCache itemSpriteCache
    )
    {
        this.client = client;
        this.clientThread = clientThread;
        this.rolledItemsManager = rolledItemsManager;
        this.spriteOverrideManager = spriteOverrideManager;
        this.itemSpriteCache = itemSpriteCache;
    }

    public boolean hasData()
    {
        return currentDrops != null;
    }

    public NpcDropData getCurrentData()
    {
        return currentDrops;
    }

    public void override(NpcDropData dropData)
    {
        if (dropData == null) return;
        this.currentDrops = dropData;
        this.overrideActive = true;
        applyOverride(dropData);
        spriteOverrideManager.register();
    }

    public void restore()
    {
        if (!overrideActive) return;
        spriteOverrideManager.unregister();
        itemSpriteCache.clear();
        revertOverride();
    }

    private void applyOverride(NpcDropData dropData)
    {
        iconItemMap.clear();
        int[] toHide = {9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19};
        for (int childId : toHide)
        {
            Widget w = client.getWidget(MUSIC_GROUP, childId);
            if (w != null) w.setHidden(true);
        }

        List<DropItem> drops = dropData.getDropTableSections().stream()
                .flatMap(sec -> sec.getItems().stream())
                .collect(Collectors.toList());
        drops = WidgetUtils.dedupeAndSort(drops);

        Set<Integer> rolledIds = rolledItemsManager.getRolledItems();
        int totalDrops = drops.size();
        int rolledCount = (int) drops.stream()
                .filter(d -> rolledIds.contains(d.getItemId()))
                .count();

        Widget root = client.getWidget(MUSIC_GROUP, 0);
        if (root != null)
        {
            Widget title = client.getWidget(MUSIC_GROUP, 8);
            if (title != null && originalTitleText == null) originalTitleText = title.getText();

            if (title != null && dropData != null)
            {
                title.setText(dropData.getName());
                title.revalidate();
            }

            int fontId = title != null ? title.getFontId() : 0;
            boolean shadowed = title != null && title.getTextShadowed();
            root.setHidden(false);
            root.setType(WidgetType.LAYER);
            root.revalidate();

            WidgetUtils.hideAllChildrenSafely(root);

            int lvlX = Objects.requireNonNull(title).getOriginalX() + title.getOriginalWidth() + 83;
            int lvlY = title.getOriginalY();

            Widget lvl = root.createChild(-1);
            lvl.setHidden(false);
            lvl.setType(WidgetType.TEXT);
            lvl.setText(String.format("Lvl %d", dropData.getLevel()));
            lvl.setFontId(fontId);
            lvl.setTextShadowed(shadowed);
            lvl.setTextColor(0x00b33c);
            lvl.setOriginalX(lvlX);
            lvl.setOriginalY(lvlY);
            lvl.setOriginalWidth(title.getOriginalWidth());
            lvl.setOriginalHeight(title.getOriginalHeight());
            lvl.revalidate();

            Widget oldBar = client.getWidget(MUSIC_GROUP, 9);
            if (oldBar == null) return;
            int xOld = oldBar.getOriginalX();
            int yOld = oldBar.getOriginalY();
            int wOld = oldBar.getOriginalWidth();
            int hOld = oldBar.getOriginalHeight();

            final int BAR_HEIGHT    = 15;
            final float WIDTH_RATIO = 0.7f;
            int newW  = Math.round(wOld * WIDTH_RATIO);

            int newY  = yOld + (hOld - BAR_HEIGHT) / 2;

            Widget bg = root.createChild(-1);
            bg.setHidden(false);
            bg.setType(WidgetType.RECTANGLE);
            bg.setOriginalX(xOld);
            bg.setOriginalY(newY);
            bg.setOriginalWidth(newW);
            bg.setOriginalHeight(BAR_HEIGHT);
            bg.setFilled(true);
            bg.setTextColor(0x000000);
            bg.revalidate();

            final int BORDER = 1;
            int innerWidth = newW - BORDER * 2;
            int fillW = Math.round(innerWidth * (float) rolledCount / totalDrops);

            Widget fill = root.createChild(-1);
            fill.setHidden(false);
            fill.setType(WidgetType.RECTANGLE);
            fill.setOriginalX(xOld + BORDER);
            fill.setOriginalY(newY + BORDER);
            fill.setOriginalWidth(fillW);
            fill.setOriginalHeight(BAR_HEIGHT - BORDER * 2);
            fill.setFilled(true);
            fill.setTextColor(0x00b33c);
            fill.revalidate();

            String txt = String.format("%d/%d", rolledCount, totalDrops);
            Widget label = root.createChild(-1);
            label.setHidden(false);
            label.setType(WidgetType.TEXT);
            label.setText(txt);
            label.setTextColor(0xFFFFFF);
            label.setFontId(title.getFontId());
            label.setTextShadowed(title.getTextShadowed());
            label.setOriginalWidth(newW);
            label.setOriginalHeight(BAR_HEIGHT);
            label.setOriginalX(xOld + (newW / 2) - (txt.length() * 4));
            label.setOriginalY(newY + (BAR_HEIGHT / 2) - 6);
            label.revalidate();

            root.revalidate();
        }

        final int ICON_SIZE = 32, PADDING = 4, COLUMNS = 4, MARGIN_X = 8, MARGIN_Y = 8;
        Widget scrollable = client.getWidget(MUSIC_GROUP, 4);
        Widget jukebox    = client.getWidget(MUSIC_GROUP, 6);
        Widget overlay    = client.getWidget(MUSIC_GROUP, 5);
        Widget scrollbar  = client.getWidget(MUSIC_GROUP, 7);

        if (backupJukeboxStaticKids == null && jukebox != null)
        {
            Widget[] kids = jukebox.getChildren();
            backupJukeboxStaticKids = (kids != null)
                    ? new ArrayList<>(Arrays.asList(kids))
                    : new ArrayList<>();
        }

        // backup dynamic children of jukebox
        if (backupJukeboxDynamicKids == null && jukebox != null)
        {
            Widget[] kids = jukebox.getDynamicChildren();
            backupJukeboxDynamicKids = (kids != null)
                    ? new ArrayList<>(Arrays.asList(kids))
                    : new ArrayList<>();
        }

        // backup static children of scrollable
        if (backupScrollStaticKids == null && scrollable != null)
        {
            Widget[] kids = scrollable.getChildren();
            backupScrollStaticKids = (kids != null)
                    ? new ArrayList<>(Arrays.asList(kids))
                    : new ArrayList<>();
        }

        // backup dynamic children of scrollable
        if (backupScrollDynamicKids == null && scrollable != null)
        {
            Widget[] kids = scrollable.getDynamicChildren();
            backupScrollDynamicKids = (kids != null)
                    ? new ArrayList<>(Arrays.asList(kids))
                    : new ArrayList<>();
        }

        WidgetUtils.hideAllChildrenSafely(jukebox);
        WidgetUtils.hideAllChildrenSafely(scrollable);

        int displayIndex = 0;
        for (DropItem d : drops)
        {
            int itemId = d.getItemId();
            int col    = displayIndex % COLUMNS;
            int row    = displayIndex / COLUMNS;
            int x      = MARGIN_X + col * (ICON_SIZE + PADDING);
            int y      = MARGIN_Y + row * (ICON_SIZE + PADDING);

            Widget icon = Objects.requireNonNull(scrollable).createChild(-1);
            icon.setHidden(false);
            icon.setType(WidgetType.GRAPHIC);
            int spriteId = itemSpriteCache.getSpriteId(itemId);
            icon.setSpriteId(spriteId);
            icon.setItemQuantityMode(ItemQuantityMode.NEVER);
            icon.setOriginalX(x);
            icon.setOriginalY(y);
            icon.setOriginalWidth(ICON_SIZE);
            icon.setOriginalHeight(ICON_SIZE);
            icon.setOpacity(rolledIds.contains(itemId) ? 0 : 150);
            icon.revalidate();

            iconItemMap.put(icon, d);

            displayIndex++;
        }

        int rows = (displayIndex + COLUMNS - 1) / COLUMNS;
        Objects.requireNonNull(scrollable).setScrollHeight(MARGIN_Y * 2 + rows * (ICON_SIZE + PADDING));
        Objects.requireNonNull(scrollbar).revalidateScroll();
    }

    private void revertOverride()
    {
        if (!overrideActive)
        {
            return;
        }

        Widget root       = client.getWidget(MUSIC_GROUP, 0);
        Widget scrollable = client.getWidget(MUSIC_GROUP, 4);
        Widget jukebox    = client.getWidget(MUSIC_GROUP, 6);

        // 1) Hide any dynamic widgets under the root (lvl text, bar, counter)
        if (root != null)
        {
            Widget[] dynRoot = root.getDynamicChildren();
            if (dynRoot != null)
            {
                for (Widget w : dynRoot)
                {
                    w.setHidden(true);
                    w.revalidate();
                }
            }
        }

        // 2) Hide injected drop icons under scrollable
        if (scrollable != null && backupScrollStaticKids != null && backupScrollDynamicKids != null)
        {
            Widget[] staticKids = scrollable.getChildren();
            if (staticKids != null) {for (Widget w : staticKids) {w.setHidden(true);}}

            Widget[] dynamicKids = scrollable.getDynamicChildren();
            if (dynamicKids != null) {for (Widget w : dynamicKids) {w.setHidden(true);}}
            for (Widget w : backupScrollStaticKids) {w.setHidden(false);}
            for (Widget w : backupScrollDynamicKids) {w.setHidden(false);}
            scrollable.revalidate();
        }

        if (jukebox != null && backupJukeboxStaticKids != null && backupJukeboxDynamicKids != null)
        {
            Widget[] jbStaticKids = jukebox.getChildren();
            if (jbStaticKids != null) {for (Widget w : jbStaticKids) {w.setHidden(true);}}

            Widget[] jbDynamicKids = jukebox.getDynamicChildren();
            if (jbDynamicKids != null) {for (Widget w : jbDynamicKids) {w.setHidden(true);}}
            for (Widget w : backupJukeboxStaticKids) {w.setHidden(false);}
            for (Widget w : backupJukeboxDynamicKids) {w.setHidden(false);}
            jukebox.revalidate();
        }

        Widget title     = client.getWidget(MUSIC_GROUP, 8);
        Widget overlay   = client.getWidget(MUSIC_GROUP, 5);
        Widget scrollbar = client.getWidget(MUSIC_GROUP, 7);
        Widget progress  = client.getWidget(MUSIC_GROUP, 9);

        if (title != null && originalTitleText != null)
        {
            title.setText(originalTitleText);
            title.revalidate();
            for (int id = 9; id <= 19; id++)
            {
                Widget w = client.getWidget(MUSIC_GROUP, id);
                if (w != null)
                {
                    w.setHidden(false);
                    w.revalidate();
                }
            }
        }

        if (overlay != null)
        {
            overlay.setHidden(false);
            overlay.revalidate();
        }
        if (scrollbar != null)
        {
            scrollbar.setHidden(false);
            scrollbar.revalidate();
        }
        if (progress != null)
        {
            progress.setHidden(false);
            progress.revalidate();
        }

        if (root != null && root.getOnLoadListener() != null)
        {
            client.createScriptEvent(root.getOnLoadListener())
                    .setSource(root)
                    .run();
            root.revalidate();
        }
        if (overlay != null && overlay.getOnLoadListener() != null)
        {
            client.createScriptEvent(overlay.getOnLoadListener())
                    .setSource(overlay)
                    .run();
            overlay.revalidate();
        }
        if (scrollbar != null && scrollbar.getOnLoadListener() != null)
        {
            client.createScriptEvent(scrollbar.getOnLoadListener())
                    .setSource(scrollbar)
                    .run();
            scrollbar.revalidate();
        }
        if (jukebox != null && jukebox.getOnLoadListener() != null)
        {
            client.createScriptEvent(jukebox.getOnLoadListener())
                    .setSource(jukebox)
                    .run();
            jukebox.revalidate();
        }

        originalTitleText = null;
        currentDrops      = null;
        overrideActive    = false;
        backupJukeboxStaticKids = null;
        backupJukeboxDynamicKids = null;
        backupScrollStaticKids  = null;
        backupScrollDynamicKids = null;
        iconItemMap.clear();
    }
}
package com.chanceman.ui;


import javax.inject.Inject;
import javax.inject.Singleton;
import lombok.extern.slf4j.Slf4j;
import net.runelite.client.eventbus.EventBus;

@Slf4j
@Singleton
public class DropsTabUI
{
    private final EventBus eventBus;
    private final DropsMenuListener menuListener;
    private final TabListener tabListener;

    @Inject
    public DropsTabUI(
            EventBus eventBus,
            DropsMenuListener menuListener,
            TabListener tabListener
    )
    {
        this.eventBus = eventBus;
        this.menuListener = menuListener;
        this.tabListener = tabListener;
    }

    public void startUp()
    {
        eventBus.register(menuListener);
        eventBus.register(tabListener);
    }

    public void shutDown()
    {
        eventBus.unregister(menuListener);
        eventBus.unregister(tabListener);
    }
}

package com.chanceman.ui;

import com.chanceman.drops.DropCache;
import lombok.extern.slf4j.Slf4j;
import javax.inject.Inject;
import javax.inject.Singleton;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import net.runelite.api.Client;
import net.runelite.api.MenuAction;
import net.runelite.api.MenuEntry;
import net.runelite.api.NPC;
import net.runelite.api.events.MenuOpened;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.eventbus.Subscribe;

@Slf4j
@Singleton
public class DropsMenuListener
{
    private final Client client;
    private final ClientThread clientThread;
    private final DropCache dropCache;
    private final MusicWidgetController widgetController;

    @Inject
    public DropsMenuListener(
            Client client,
            ClientThread clientThread,
            DropCache dropCache,
            MusicWidgetController widgetController
    )
    {
        this.client = client;
        this.clientThread = clientThread;
        this.dropCache = dropCache;
        this.widgetController = widgetController;
    }

    @Subscribe
    public void onMenuOpened(MenuOpened event)
    {
        List<MenuEntry> entries = new ArrayList<>(Arrays.asList(event.getMenuEntries()));
        NPC target = null;
        MenuEntry attackEntry = null;
        int attackIdx = -1;

        for (int i = 0; i < entries.size(); i++)
        {
            MenuEntry e = entries.get(i);
            if (e.getType() == MenuAction.NPC_SECOND_OPTION && "Attack".equals(e.getOption()))
            {
                try
                {
                    NPC possible = client.getTopLevelWorldView()
                            .npcs()
                            .byIndex(e.getIdentifier());
                    if (possible != null && possible.getCombatLevel() > 0)
                    {
                        target = possible;
                        attackEntry = e;
                        attackIdx = i;
                        break;
                    }
                }
                catch (ArrayIndexOutOfBoundsException ex)
                {
                    // ignore invalid indices
                }
            }
        }
        if (attackEntry == null || target == null)
        {
            return;
        }

        int id = target.getId();
        String name = target.getName();
        int level = target.getCombatLevel();

        MenuEntry showDrops = WidgetUtils.createShowDropsEntry(
                client,
                attackIdx - 1,
                attackEntry
        );
        showDrops.onClick(me -> fetchAndDisplayDrops(id, name, level, 1));

        entries.add(attackIdx + 1, showDrops);
        event.setMenuEntries(entries.toArray(new MenuEntry[0]));
    }
    private void fetchAndDisplayDrops(int id, String name, int level, int attemptsLeft)
    {
        dropCache.get(id, name, level)
                .whenComplete((dropData, ex) ->
                {
                    if (dropData != null && ex == null)
                    {
                        clientThread.invokeLater(() -> widgetController.override(dropData));
                        return;
                    }

                    if (attemptsLeft > 0) fetchAndDisplayDrops(id, name, level, attemptsLeft - 1);
                    else log.error("Failed to fetch drop data for {}", name, ex);

                });
    }
}
package com.chanceman.ui;

import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.SpriteID;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.game.SpriteManager;
import net.runelite.client.game.SpriteOverride;

import javax.inject.Inject;
import javax.inject.Singleton;

/**
 * Overrides the RuneLite music tab sprite with drops.png.
 * Call register() when showing drops and unregister() to restore the original.
 * Clears the widget sprite cache to force the client to pick up the new override.
 */
@Slf4j
@Singleton
public class SpriteOverrideManager implements SpriteOverride
{
    private static final int SPRITE_ID = SpriteID.TAB_MUSIC;
    private static final String RESOURCE_PATH = "/com/chanceman/drops.png";

    private final SpriteManager spriteManager;
    private final Client client;
    private final ClientThread clientThread;

    @Inject
    public SpriteOverrideManager(SpriteManager spriteManager, Client client, ClientThread clientThread)
    {
        this.spriteManager = spriteManager;
        this.client = client;
        this.clientThread = clientThread;
    }

    /**
     * Apply the custom drops icon override.
     */
    public void register()
    {
        spriteManager.addSpriteOverrides(new SpriteOverride[]{this});
        clientThread.invokeLater(() -> {
            client.getWidgetSpriteCache().reset();
        });
    }

    /**
     * Remove the override, restoring the original music tab icon.
     */
    public void unregister()
    {
        spriteManager.removeSpriteOverrides(new SpriteOverride[]{this});
        clientThread.invokeLater(() -> {
            client.getWidgetSpriteCache().reset();
        });
    }

    @Override
    public int getSpriteId()
    {
        return SPRITE_ID;
    }

    @Override
    public String getFileName()
    {
        // Resource path relative to the classpath
        return RESOURCE_PATH;
    }
}

package com.chanceman.ui;

import java.awt.Dimension;
import java.awt.Graphics2D;
import java.awt.FontMetrics;
import java.awt.Color;
import java.awt.Rectangle;
import java.util.Map;
import javax.inject.Inject;
import javax.inject.Singleton;

import com.chanceman.drops.DropItem;

import net.runelite.api.Client;
import net.runelite.api.Point;
import net.runelite.api.widgets.Widget;
import net.runelite.client.ui.overlay.Overlay;
import net.runelite.client.ui.overlay.OverlayLayer;
import net.runelite.client.ui.overlay.OverlayPosition;

/**
 * Overlay that displays item name tooltips when hovering drop icons
 * injected into the music tab by {@link MusicWidgetController}.
 */
@Singleton
public class DropsTooltipOverlay extends Overlay
{
    private final Client client;
    private final MusicWidgetController widgetController;

    @Inject
    public DropsTooltipOverlay(
            Client client,
            MusicWidgetController widgetController
    )
    {
        this.client = client;
        this.widgetController = widgetController;
        setPosition(OverlayPosition.DYNAMIC);
        setLayer(OverlayLayer.ABOVE_WIDGETS);
    }

    @Override
    public Dimension render(Graphics2D graphics)
    {
        if (!widgetController.isOverrideActive()) {return null;}

        Point mouse = client.getMouseCanvasPosition();
        for (Map.Entry<Widget, DropItem> entry : widgetController.getIconItemMap().entrySet())
        {
            Widget w = entry.getKey();
            if (w == null || w.isHidden()) {continue;}
            Rectangle bounds = w.getBounds();
            if (bounds.contains(mouse.getX(), mouse.getY()))
            {
                DropItem drop = entry.getValue();
                drawTooltip(graphics, drop.getName(), drop.getOneOverRarity(), mouse);
                break;
            }
        }
        return null;
    }

    private void drawTooltip(Graphics2D g, String name, String rarity, Point mouse)
    {
        FontMetrics fm = g.getFontMetrics();
        int padding = 4;
        int gap = 2;
        int lineH  = fm.getHeight();

        String rateText = "Rate: " + rarity;

        int nameW = fm.stringWidth(name);
        int rateW = fm.stringWidth(rateText);

        int nameBoxW = nameW + padding * 2;
        int rateBoxW = rateW + padding * 2;
        int boxH     = lineH + padding * 2;
        int totalH   = boxH * 2 + gap;
        int clampW   = Math.max(nameBoxW, rateBoxW);

        int x = mouse.getX() + 10;
        int y = mouse.getY() - 10;

        Rectangle clip = g.getClipBounds();
        x = Math.max(clip.x, Math.min(x, clip.x + clip.width  - clampW));
        y = Math.max(clip.y + totalH, Math.min(y, clip.y + clip.height));

        int nameTop = y - totalH;
        drawBox(g, x, nameTop, nameBoxW, boxH);
        drawBox(g, x, y - boxH, rateBoxW, boxH);

        g.setColor(Color.WHITE);
        int base = nameTop + padding + fm.getAscent();
        g.drawString(name, x + padding, base);

        int rateBase = y - boxH + padding + fm.getAscent();
        String prefix = "Rate: ";
        int prefixW = fm.stringWidth(prefix);

        g.setColor(Color.WHITE);
        g.drawString(prefix, x + padding, rateBase);

        g.setColor(Color.ORANGE);
        g.drawString(rarity, x + padding + prefixW, rateBase);
    }

    private void drawBox(Graphics2D g, int x, int y, int w, int h)
    {
        g.setColor(new Color(0, 0, 0, 100));
        g.fillRect(x, y, w, h);
        g.setColor(new Color(50, 50, 50, 200));
        g.drawRect(x, y, w, h);
    }
}

package com.chanceman.ui;

import com.chanceman.drops.DropItem;
import net.runelite.api.Client;
import net.runelite.api.MenuEntry;
import net.runelite.api.MenuAction;
import net.runelite.api.widgets.Widget;

import java.util.*;
import java.util.stream.Collectors;
import java.util.LinkedHashMap;

public final class WidgetUtils
{
    /**
     * Creates a "Show Drops" menu entry identical to the original Attack entry.
     *
     * @param client      The RuneLite client.
     * @param insertIndex The index at which to insert the new entry.
     * @param attackEntry The original "Attack" menu entry to clone.
     * @return A configured MenuEntry that runs a custom drop display.
     */
    public static MenuEntry createShowDropsEntry(
            Client client,
            int insertIndex,
            MenuEntry attackEntry
    )
    {
        return client.getMenu()
                .createMenuEntry(insertIndex)
                .setOption("Show Drops")
                .setTarget(attackEntry.getTarget())
                .setIdentifier(attackEntry.getIdentifier())
                .setParam0(attackEntry.getParam0())
                .setParam1(attackEntry.getParam1())
                .setType(MenuAction.RUNELITE);
    }

    /**
     * Hides all static and dynamic children of the given widget, if any exist.
     *
     * @param widget The widget whose children should be hidden.
     */
    public static void hideAllChildrenSafely(Widget widget)
    {
        if (widget == null)
            return;

        Widget[] staticKids = widget.getChildren();
        if (staticKids != null)
        {
            for (Widget child : staticKids)
            {
                if (child != null) child.setHidden(true);
            }
        }

        Widget[] dynamicKids = widget.getDynamicChildren();
        if (dynamicKids != null)
        {
            for (Widget child : dynamicKids)
            {
                if (child != null) child.setHidden(true);
            }
        }
    }

    /**
     * Deduplicates a list of DropItems by item ID and sorts them ascending.
     *
     * @param drops The list of DropItems to process.
     * @return A new sorted, deduplicated list.
     */
    public static List<DropItem> dedupeAndSort(List<DropItem> drops)
    {
        return drops.stream()
                .filter(d -> d.getItemId() > 0)
                .collect(Collectors.toMap(
                        DropItem::getItemId,
                        d -> d,
                        (first, second) -> first,
                        LinkedHashMap::new
                ))
                .values().stream()
                .sorted(Comparator.comparingInt(DropItem::getItemId))
                .collect(Collectors.toList());
    }
}

package com.chanceman.ui;

import javax.inject.Inject;
import javax.inject.Singleton;
import java.awt.image.BufferedImage;
import java.util.HashMap;
import java.util.Map;

import net.runelite.api.Client;
import net.runelite.api.SpritePixels;
import net.runelite.client.game.ItemManager;
import net.runelite.client.util.ImageUtil;

/**
 * Caches custom item sprites scaled for widget display.
 */
@Singleton
public class ItemSpriteCache
{
    private static final int ICON_SIZE = 32;

    private final ItemManager itemManager;
    private final Client client;
    private final Map<Integer, Integer> spriteIds = new HashMap<>();
    private int nextGeneratedSpriteId = 0x10000;

    @Inject
    public ItemSpriteCache(ItemManager itemManager, Client client)
    {
        this.itemManager = itemManager;
        this.client = client;
    }

    private int generateNextId()
    {
        return nextGeneratedSpriteId++;
    }

    /**
     * Returns a sprite ID for the given item
     */
    public int getSpriteId(int itemId)
    {
        return spriteIds.computeIfAbsent(itemId, id ->
        {
            BufferedImage img = itemManager.getImage(id, 1, false);
            if (img == null)
            {
                return -1;
            }

            // resize to ICON_SIZE x ICON_SIZE
            BufferedImage resized = ImageUtil.resizeImage(img, ICON_SIZE, ICON_SIZE);

            // convert to SpritePixels for the client's override map
            SpritePixels pixels = ImageUtil.getImageSpritePixels(resized, client);

            // generate a unique sprite ID and register the override
            int spriteId = generateNextId();
            client.getSpriteOverrides().put(spriteId, pixels);

            return spriteId;
        });
    }

    /**
     * Clears all cached sprites and unregisters them from the client's override map.
     */
    public void clear()
    {
        spriteIds.values().forEach(client.getSpriteOverrides()::remove);
        spriteIds.clear();
        nextGeneratedSpriteId = 0x10000;
    }
}

package com.chanceman.ui;

import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.VarClientInt;
import net.runelite.api.events.VarClientIntChanged;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.eventbus.Subscribe;

import javax.inject.Inject;
import javax.inject.Singleton;

@Slf4j
@Singleton
public class TabListener
{
    private final Client client;
    private final ClientThread clientThread;
    private final MusicWidgetController widgetController;

    @Inject
    public TabListener(
            Client client,
            ClientThread clientThread,
            MusicWidgetController widgetController
    )
    {
        this.client = client;
        this.clientThread = clientThread;
        this.widgetController = widgetController;
    }

    @Subscribe
    public void onVarClientIntChanged(VarClientIntChanged ev)
    {
        if (ev.getIndex() != VarClientInt.INVENTORY_TAB) return;

        int newTab = client.getVarcIntValue(VarClientInt.INVENTORY_TAB);
        if (widgetController.isOverrideActive() && newTab != 13)
        {
            clientThread.invokeLater(widgetController::restore);
        }
        else if (!widgetController.isOverrideActive() && newTab == 13 && widgetController.hasData())
        {
            clientThread.invokeLater(() ->
                    widgetController.override(widgetController.getCurrentData())
            );
        }
    }
}

package com.chanceman.account;

import com.chanceman.managers.RolledItemsManager;
import com.chanceman.managers.UnlockedItemsManager;
import lombok.Getter;
import lombok.Setter;
import net.runelite.api.Client;
import net.runelite.api.GameState;
import net.runelite.api.Player;
import net.runelite.api.events.AccountHashChanged;
import net.runelite.api.events.ClientTick;
import net.runelite.api.events.GameStateChanged;
import net.runelite.client.eventbus.EventBus;
import net.runelite.client.eventbus.Subscribe;

import javax.inject.Inject;
import javax.inject.Singleton;

/**
 * Monitors for account changes and updates the stored display name.
 */
@Singleton
public class AccountManager
{

	@Inject
	private Client client;

	@Inject
	private UnlockedItemsManager unlockedItemsManager;

	@Inject
	private RolledItemsManager rolledItemsManager;

	@Inject
	private EventBus eventBus;

	private long hash = -1;
	@Getter @Setter private volatile String playerName;
	private boolean nameSet = false;

	public boolean ready() { return hash != -1 && nameSet; }

	public void init()
	{
		if (client.getGameState() == GameState.LOGGED_IN && client.getAccountHash() != -1)
		{
			hash = client.getAccountHash();
			nameSet = false;
		}
	}

	@Subscribe
	private void onAccountHashChanged(AccountHashChanged event)
	{
		long newHash = client.getAccountHash();
		if (hash != newHash)
		{
			hash = newHash;
			nameSet = false; // Player is null at this point, so name is set in onClientTick
		}
	}

	@Subscribe
	private void onClientTick(ClientTick event)
	{
		if (client.getGameState().getState() < GameState.LOADING.getState()) return;
		if (hash == -1) return;
		if (nameSet) return;

		Player player = client.getLocalPlayer();
		if (player == null) return;

		String name = player.getName();
		if (name == null) return;

		setPlayerName(name);
		nameSet = true;
		emit();
	}

	@Subscribe
	private void onGameStateChanged(GameStateChanged event)
	{
		if (event.getGameState() == GameState.LOGIN_SCREEN && hash != -1)
		{
			reset();
		}
	}

	public void reset() {
		hash = -1;
		setPlayerName(null);
		emit();
	}

	private void emit()
	{
		eventBus.post(new AccountChanged(hash, playerName));
	}
}

package com.chanceman.account;

import lombok.Getter;

@Getter
public class AccountChanged
{
	private final long hash;
	private final String playerName;
	private final boolean loggedIn;

	public AccountChanged(long hash, String playerName)
	{
		this.hash = hash;
		this.playerName = playerName;
		this.loggedIn = hash != -1;
	}

	@Override
	public String toString() {
		return "AccountChanged{" +
				"hash=" + hash +
				", playerName='" + playerName + '\'' +
				", loggedIn=" + loggedIn +
				'}';
	}
}

package com.chanceman;

import com.chanceman.managers.RollAnimationManager;
import com.chanceman.managers.RolledItemsManager;
import com.chanceman.managers.UnlockedItemsManager;
import net.runelite.api.ItemComposition;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.game.ItemManager;
import net.runelite.client.ui.PluginPanel;
import net.runelite.client.util.LinkBrowser;

import javax.swing.*;
import javax.swing.DefaultListModel;
import javax.swing.JList;
import javax.swing.JScrollPane;
import javax.swing.ListSelectionModel;
import javax.swing.ListCellRenderer;
import javax.swing.SwingUtilities;
import javax.swing.border.*;
import java.awt.Component;
import java.awt.*;
import java.awt.event.KeyAdapter;
import java.awt.event.KeyEvent;
import java.awt.image.BufferedImage;
import java.util.*;
import java.util.List;
import java.util.function.Consumer;

/**
 * Panel for displaying rolled and unlocked items.
 * It provides UI for manual roll actions, search/filter functionality,
 * and displays each item with its icon and full item name.
 * Each item panel shows a tooltip on both the icon and the panel with the item name.
 */
public class ChanceManPanel extends PluginPanel
{
    private final UnlockedItemsManager unlockedItemsManager;
    private final RolledItemsManager rolledItemsManager;
    private final ItemManager itemManager;
    private final HashSet<Integer> allTradeableItems;
    private final ClientThread clientThread;
    private final RollAnimationManager rollAnimationManager;

    // Caches for item icons and names
    private final Map<Integer, ImageIcon> itemIconCache = new HashMap<>();
    private final Map<Integer, String> itemNameCache = new HashMap<>();

    // CardLayout panel to show either Rolled or Unlocked view
    private final JPanel centerCardPanel = new JPanel(new CardLayout());
    private final DefaultListModel<Integer> rolledModel = new DefaultListModel<>();
    private final JList<Integer> rolledList = new JList<>(rolledModel);
    private final DefaultListModel<Integer> unlockedModel = new DefaultListModel<>();
    private final JList<Integer> unlockedList = new JList<>(unlockedModel);

    // View selection row: 3 buttons (swap, filter unlocked-not-rolled, filter unlocked-and-rolled)
    private final JButton swapViewButton = new JButton("🔄");
    private final JToggleButton filterUnlockedNotRolledButton = new JToggleButton("🔓");
    private final JToggleButton filterUnlockedAndRolledButton = new JToggleButton("🔀");

    // Flag for current view: true = showing Unlocked, false = showing Rolled
    private boolean showingUnlocked = true;

    // Search text
    private String searchText = "";

    // Single count label at the bottom
    private final JLabel countLabel = new JLabel("Unlocked: 0/0");

    // Roll button for manual roll actions
    private final JButton rollButton = new JButton("Roll");

    // Active filter: "NONE", "UNLOCKED_NOT_ROLLED", or "UNLOCKED_AND_ROLLED"
    private String activeFilter = "NONE";

    // Join Discord Button links to discord invite
    private final JButton discordButton = new JButton();

    // Default color for item text
    private final Color defaultItemTextColor = new Color(220, 220, 220);

    /**
     * Constructs a ChanceManPanel.
     *
     * @param unlockedItemsManager Manager for unlocked items.
     * @param rolledItemsManager   Manager for rolled items.
     * @param itemManager          The item manager.
     * @param allTradeableItems    List of all tradeable item IDs.
     * @param clientThread         The client thread for scheduling UI updates.
     * @param rollAnimationManager The roll animation manager to trigger animations.
     */
    public ChanceManPanel(
            UnlockedItemsManager unlockedItemsManager,
            RolledItemsManager rolledItemsManager,
            ItemManager itemManager,
            HashSet<Integer> allTradeableItems,
            ClientThread clientThread,
            RollAnimationManager rollAnimationManager
    )
    {
        this.unlockedItemsManager = unlockedItemsManager;
        this.rolledItemsManager = rolledItemsManager;
        this.itemManager = itemManager;
        this.allTradeableItems = allTradeableItems;
        this.clientThread = clientThread;
        this.rollAnimationManager = rollAnimationManager;
        init();
    }

    /**
     * Initializes the panel UI components.
     */
    private void init()
    {
        setLayout(new BorderLayout());
        setBorder(new EmptyBorder(15, 15, 15, 15));
        setBackground(new Color(37, 37, 37));

        // ========== TOP PANEL (Header, Search, Buttons Row) ==========
        JPanel topPanel = new JPanel();
        topPanel.setLayout(new BoxLayout(topPanel, BoxLayout.Y_AXIS));
        topPanel.setOpaque(false);

        // Header
        topPanel.add(buildHeaderPanel());
        topPanel.add(Box.createVerticalStrut(10));

        // Search Bar
        topPanel.add(buildSearchBar());
        topPanel.add(Box.createVerticalStrut(10));

        // Button row: 3 columns, each for one button
        JPanel buttonRowPanel = new JPanel(new GridLayout(1, 3, 10, 0));
        buttonRowPanel.setOpaque(false);

        // Style the 3 buttons identically
        styleButton(swapViewButton);
        styleToggleButton(filterUnlockedNotRolledButton);
        styleToggleButton(filterUnlockedAndRolledButton);

        // Tooltips & actions
        swapViewButton.setToolTipText("Swap between Unlocked and Rolled views");
        swapViewButton.addActionListener(e -> toggleView());

        filterUnlockedNotRolledButton.setToolTipText("Filter: Show items that are unlocked but not rolled");
        filterUnlockedNotRolledButton.addActionListener(e ->
        {
            if (filterUnlockedNotRolledButton.isSelected())
            {
                activeFilter = "UNLOCKED_NOT_ROLLED";
                filterUnlockedAndRolledButton.setSelected(false);
            }
            else
            {
                activeFilter = "NONE";
            }
            updatePanel();
        });

        filterUnlockedAndRolledButton.setToolTipText("Filter: Show items that are both unlocked and rolled");
        filterUnlockedAndRolledButton.addActionListener(e ->
        {
            if (filterUnlockedAndRolledButton.isSelected())
            {
                activeFilter = "UNLOCKED_AND_ROLLED";
                filterUnlockedNotRolledButton.setSelected(false);
            }
            else
            {
                activeFilter = "NONE";
            }
            updatePanel();
        });

        // Add them in left->right order
        buttonRowPanel.add(swapViewButton);
        buttonRowPanel.add(filterUnlockedNotRolledButton);
        buttonRowPanel.add(filterUnlockedAndRolledButton);

        // Add the row to the top panel
        topPanel.add(buttonRowPanel);

        // EXTRA SPACE between the buttons row and the icon panel
        topPanel.add(Box.createVerticalStrut(10));

        add(topPanel, BorderLayout.NORTH);

        // ========== CENTER PANEL (CardLayout) ==========
        rolledList.setCellRenderer(new ItemCellRenderer());
        rolledList.setVisibleRowCount(10);
        rolledList.setSelectionMode(ListSelectionModel.SINGLE_SELECTION);
        JScrollPane rolledScroll = new JScrollPane(
                rolledList,
                JScrollPane.VERTICAL_SCROLLBAR_AS_NEEDED,
                JScrollPane.HORIZONTAL_SCROLLBAR_NEVER
        );
        rolledScroll.setPreferredSize(new Dimension(250, 300));
        JPanel rolledContainer = createTitledPanel("Rolled Items", rolledScroll);

        unlockedList.setCellRenderer(new ItemCellRenderer());
        unlockedList.setVisibleRowCount(10);
        unlockedList.setSelectionMode(ListSelectionModel.SINGLE_SELECTION);
        JScrollPane unlockedScroll = new JScrollPane(
                unlockedList,
                JScrollPane.VERTICAL_SCROLLBAR_AS_NEEDED,
                JScrollPane.HORIZONTAL_SCROLLBAR_NEVER
        );
        unlockedScroll.setPreferredSize(new Dimension(250, 300));
        JPanel unlockedContainer = createTitledPanel("Unlocked Items", unlockedScroll);

        centerCardPanel.add(rolledContainer, "ROLLED");
        centerCardPanel.add(unlockedContainer, "UNLOCKED");
        add(centerCardPanel, BorderLayout.CENTER);

        // ========== BOTTOM PANEL (Count + Roll) ==========
        JPanel bottomPanel = new JPanel();
        bottomPanel.setLayout(new BoxLayout(bottomPanel, BoxLayout.Y_AXIS));
        bottomPanel.setOpaque(false);

        // Single count label
        JPanel countPanel = new JPanel(new FlowLayout(FlowLayout.CENTER, 0, 0));
        countPanel.setOpaque(false);
        countLabel.setFont(new Font("Arial", Font.BOLD, 11));
        countLabel.setForeground(new Color(220, 220, 220));
        countPanel.add(countLabel);
        bottomPanel.add(countPanel);
        bottomPanel.add(Box.createVerticalStrut(10));

        // Roll button
        JPanel rollButtonPanel = new JPanel(new FlowLayout(FlowLayout.CENTER));
        rollButtonPanel.setOpaque(false);
        rollButton.setPreferredSize(new Dimension(100, 30));
        rollButton.setFocusPainted(false);
        rollButton.setBackground(new Color(60, 63, 65));
        rollButton.setForeground(Color.WHITE);
        rollButton.setFont(new Font("SansSerif", Font.BOLD, 12));
        rollButton.addActionListener(this::performManualRoll);
        rollButtonPanel.add(rollButton);
        bottomPanel.add(rollButtonPanel);

        add(bottomPanel, BorderLayout.SOUTH);

        // Default to Unlocked view
        showingUnlocked = true;
        ((CardLayout) centerCardPanel.getLayout()).show(centerCardPanel, "UNLOCKED");
        updatePanel();
    }

    /**
     * Renders each item ID as an icon + name in the JList.
     */
    private class ItemCellRenderer extends JPanel implements ListCellRenderer<Integer>
    {
        private final JLabel iconLabel = new JLabel();
        private final JLabel nameLabel = new JLabel();

        public ItemCellRenderer()
        {
            setLayout(new BorderLayout(5, 0));
            setOpaque(true);
            add(iconLabel, BorderLayout.WEST);
            add(nameLabel, BorderLayout.CENTER);
            nameLabel.setFont(new Font("SansSerif", Font.PLAIN, 11));
        }

        @Override
        public Component getListCellRendererComponent(JList<? extends Integer> list,
                                                      Integer itemId,
                                                      int index,
                                                      boolean isSelected,
                                                      boolean cellHasFocus)
        {
            // icon
            iconLabel.setIcon(getItemIcon(itemId));

            // name (async load if missing)
            String name = itemNameCache.get(itemId);
            if (name == null)
            {
                nameLabel.setText("Loading…");
                getItemNameAsync(itemId, n ->
                {
                    itemNameCache.put(itemId, n);
                    list.repaint(list.getCellBounds(index, index));
                });
            }
            else
            {
                nameLabel.setText(name);
            }

            // selection styling
            if (isSelected)
            {
                setBackground(list.getSelectionBackground());
                setForeground(list.getSelectionForeground());
            }
            else
            {
                setBackground(new Color(60, 63, 65));
                nameLabel.setForeground(defaultItemTextColor);
            }

            return this;
        }
    }

    /**
     * Toggles between Unlocked view and Rolled view.
     */
    private void toggleView()
    {
        showingUnlocked = !showingUnlocked;
        CardLayout cl = (CardLayout) centerCardPanel.getLayout();
        if (showingUnlocked)
        {
            cl.show(centerCardPanel, "UNLOCKED");
        }
        else
        {
            cl.show(centerCardPanel, "ROLLED");
        }
        updatePanel();
    }

    /**
     * Creates a titled container panel that wraps the given content panel.
     *
     * @param title        The title to display on the border.
     * @return The container panel.
     */
    private JPanel createTitledPanel(String title, Component content)
    {
        JPanel container = new JPanel(new BorderLayout());
        container.setOpaque(false);

        Border line = new LineBorder(new Color(80, 80, 80));
        Border empty = new EmptyBorder(5, 5, 5, 5);
        TitledBorder titled = BorderFactory.createTitledBorder(line, title);
        titled.setTitleColor(new Color(200, 200, 200));
        container.setBorder(new CompoundBorder(titled, empty));

        // Directly add the passed-in component (which may itself be a JScrollPane)
        container.add(content, BorderLayout.CENTER);
        return container;
    }

    /**
     * Styles a general JButton to match the design.
     *
     * @param button The button to style.
     */
    private void styleButton(JButton button)
    {
        button.setFocusPainted(false);
        button.setBackground(new Color(60, 63, 65));
        button.setForeground(Color.WHITE);
        button.setFont(new Font("SansSerif", Font.BOLD, 12));
        button.setPreferredSize(new Dimension(50, 30));
    }

    /**
     * Styles a JToggleButton to match the design.
     *
     * @param button The toggle button to style.
     */
    private void styleToggleButton(JToggleButton button)
    {
        button.setFocusPainted(false);
        button.setBackground(new Color(60, 63, 65));
        button.setForeground(Color.WHITE);
        button.setFont(new Font("SansSerif", Font.BOLD, 12));
        button.setPreferredSize(new Dimension(50, 30));
    }

    /**
     * Builds the header panel with an icon and title.
     *
     * @return The header panel.
     */
    private JPanel buildHeaderPanel()
    {
        JPanel headerPanel = new JPanel(new FlowLayout(FlowLayout.LEFT));
        headerPanel.setOpaque(false);

        // Header icon
        ImageIcon headerIcon = new ImageIcon(getClass().getResource("/net/runelite/client/plugins/chanceman/icon.png"));
        JLabel iconLabel = new JLabel(headerIcon);

        // Title label
        JLabel titleLabel = new JLabel("Chance Man");
        titleLabel.setFont(new Font("SansSerif", Font.BOLD, 18));
        titleLabel.setForeground(new Color(220, 220, 220));

        // Create the Discord button
        JButton discordButton = new JButton();
        discordButton.setToolTipText("Join The Chance Man Discord");
        // Scale the Discord icon to 16x16
        ImageIcon discordIcon = new ImageIcon(getClass().getResource("/net/runelite/client/plugins/chanceman/discord.png"));
        Image scaledImage = discordIcon.getImage().getScaledInstance(20, 20, Image.SCALE_SMOOTH);
        discordButton.setIcon(new ImageIcon(scaledImage));
        // Make the button look flat (no border or background)
        discordButton.setOpaque(false);
        discordButton.setContentAreaFilled(false);
        discordButton.setBorderPainted(false);
        // Add an action to open the Discord link
        discordButton.addActionListener(e -> LinkBrowser.browse("https://discord.gg/TMkAYXxncU"));

        // Assemble the header panel
        headerPanel.add(iconLabel);
        headerPanel.add(Box.createHorizontalStrut(10));
        headerPanel.add(titleLabel);
        headerPanel.add(discordButton);

        return headerPanel;
    }

    /**
     * Builds the search bar panel.
     *
     * @return The search bar panel.
     */
    private JPanel buildSearchBar()
    {
        JPanel searchBarPanel = new JPanel(new BorderLayout());
        searchBarPanel.setOpaque(false);
        searchBarPanel.setBorder(new EmptyBorder(5, 5, 5, 5));

        JPanel searchContainer = new JPanel(new BorderLayout());
        searchContainer.setBackground(new Color(30, 30, 30));
        searchContainer.setBorder(BorderFactory.createEmptyBorder(2, 5, 2, 5));

        // Search icon
        JLabel searchIcon = new JLabel("\uD83D\uDD0D");
        searchIcon.setForeground(new Color(200, 200, 200));
        searchIcon.setBorder(new EmptyBorder(0, 5, 0, 5));
        searchContainer.add(searchIcon, BorderLayout.WEST);

        // Search field
        JTextField searchField = new JTextField();
        searchField.setBackground(new Color(45, 45, 45));
        searchField.setForeground(Color.WHITE);
        searchField.setBorder(null);
        searchField.setCaretColor(Color.WHITE);
        searchField.setMaximumSize(new Dimension(Integer.MAX_VALUE, 24));
        searchField.addKeyListener(new KeyAdapter()
        {
            @Override
            public void keyReleased(KeyEvent e)
            {
                SwingUtilities.invokeLater(() ->
                {
                    searchText = searchField.getText().toLowerCase();
                    updatePanel();
                });
            }
        });
        searchContainer.add(searchField, BorderLayout.CENTER);

        // Clear label to reset search
        JLabel clearLabel = new JLabel("❌");
        clearLabel.setFont(new Font("SansSerif", Font.PLAIN, 9));
        clearLabel.setForeground(Color.RED);
        clearLabel.setBorder(new EmptyBorder(0, 6, 0, 6));
        clearLabel.setCursor(Cursor.getPredefinedCursor(Cursor.HAND_CURSOR));
        clearLabel.addMouseListener(new java.awt.event.MouseAdapter()
        {
            @Override
            public void mouseClicked(java.awt.event.MouseEvent e)
            {
                searchField.setText("");
                searchText = "";
                updatePanel();
            }
        });
        searchContainer.add(clearLabel, BorderLayout.EAST);

        searchBarPanel.add(searchContainer, BorderLayout.CENTER);
        return searchBarPanel;
    }

    /**
     * Triggers a manual roll animation when the Roll button is clicked.
     *
     * @param e The action event.
     */
    private void performManualRoll(java.awt.event.ActionEvent e)
    {
        if (rollAnimationManager.isRolling())
        {
            return;
        }
        List<Integer> locked = new ArrayList<>();
        for (int id : allTradeableItems)
        {
            if (!unlockedItemsManager.isUnlocked(id))
            {
                locked.add(id);
            }
        }
        if (locked.isEmpty())
        {
            JOptionPane.showMessageDialog(
                    this,
                    "All items are unlocked!",
                    "ChanceMan",
                    JOptionPane.INFORMATION_MESSAGE
            );
            return;
        }
        int randomItemId = locked.get(new Random().nextInt(locked.size()));
        rollAnimationManager.setManualRoll(true);
        rollAnimationManager.enqueueRoll(randomItemId);
    }

    /**
     * Main update routine: filters the active set (Unlocked or Rolled), applies search text and filter toggles,
     * updates the single count label, and then builds the item list without trailing gaps.
     */
    public void updatePanel()
    {
        clientThread.invokeLater(() ->
        {
            // Build filtered lists
            List<Integer> filteredRolled = new ArrayList<>();
            for (Integer id : rolledItemsManager.getRolledItems())
            {
                ItemComposition comp = itemManager.getItemComposition(id);
                if (comp != null)
                {
                    String name = comp.getName().toLowerCase();
                    if (searchText.isEmpty() || name.contains(searchText))
                    {
                        filteredRolled.add(id);
                    }
                }
            }

            Collections.reverse(filteredRolled);

            List<Integer> filteredUnlocked = new ArrayList<>();
            for (Integer id : unlockedItemsManager.getUnlockedItems())
            {
                ItemComposition comp = itemManager.getItemComposition(id);
                if (comp != null)
                {
                    String name = comp.getName().toLowerCase();
                    if (searchText.isEmpty() || name.contains(searchText))
                    {
                        filteredUnlocked.add(id);
                    }
                }
            }

            Collections.reverse(filteredUnlocked);

            // Apply active filter toggles
            if (activeFilter.equals("UNLOCKED_NOT_ROLLED"))
            {
                filteredUnlocked.removeIf(id -> rolledItemsManager.getRolledItems().contains(id));
                filteredRolled.clear();
            }
            else if (activeFilter.equals("UNLOCKED_AND_ROLLED"))
            {
                filteredUnlocked.removeIf(id -> !rolledItemsManager.getRolledItems().contains(id));
                filteredRolled.removeIf(id -> !unlockedItemsManager.getUnlockedItems().contains(id));
            }

            SwingUtilities.invokeLater(() ->
            {
                rolledModel.clear();
                for (int id : filteredRolled)
                {
                    rolledModel.addElement(id);
                }

                unlockedModel.clear();
                for (int id : filteredUnlocked)
                {
                    unlockedModel.addElement(id);
                }

                int total = allTradeableItems.size();
                countLabel.setText(showingUnlocked
                        ? "Unlocked: " + unlockedModel.size() + "/" + total
                        : "Rolled:  " + rolledModel.size()   + "/" + total);
            });
        });
    }

    /**
     * Retrieves (and caches) the item icon for a given item ID.
     *
     * @param itemId The item ID.
     * @return The ImageIcon for the item, or null if not available.
     */
    private ImageIcon getItemIcon(int itemId)
    {
        if (itemIconCache.containsKey(itemId))
        {
            return itemIconCache.get(itemId);
        }
        BufferedImage image = itemManager.getImage(itemId, 1, false);
        if (image == null)
        {
            return null;
        }
        ImageIcon icon = new ImageIcon(image);
        itemIconCache.put(itemId, icon);
        return icon;
    }

    /**
     * Asynchronously retrieves the item name for a given item ID and passes it to the callback.
     *
     * @param itemId   The item ID.
     * @param callback Consumer to receive the item name.
     */
    private void getItemNameAsync(int itemId, Consumer<String> callback)
    {
        clientThread.invokeLater(() -> {
            ItemComposition comp = itemManager.getItemComposition(itemId);
            String name = (comp != null) ? comp.getName() : "Unknown";
            SwingUtilities.invokeLater(() -> callback.accept(name));
        });
    }
}

package com.chanceman.filters;

import lombok.Getter;
import net.runelite.api.gameval.ItemID;
import java.util.Collections;
import java.util.HashSet;
import java.util.Set;

/**
 * Enum representing every poisonable weapon and its four variants:
 *   - Base (unpoisoned)
 *   - (p)
 *   - (p+)
 *   - (p++)
 */
@Getter
public enum PoisonWeapons {
    // Global prerequisites for poisonable weapons
    WEAPON_POISON(ItemID.WEAPON_POISON),
    WEAPON_POISON_(ItemID.WEAPON_POISON_),
    WEAPON_POISON__(ItemID.WEAPON_POISON__),

    // --- Daggers ---
    BRONZE_DAGGER(ItemID.BRONZE_DAGGER, ItemID.BRONZE_DAGGER_P, ItemID.BRONZE_DAGGER_P_, ItemID.BRONZE_DAGGER_P__),
    IRON_DAGGER(ItemID.IRON_DAGGER, ItemID.IRON_DAGGER_P, ItemID.IRON_DAGGER_P_, ItemID.IRON_DAGGER_P__),
    BONE_DAGGER(ItemID.DTTD_BONE_DAGGER, ItemID.DTTD_BONE_DAGGER_P, ItemID.DTTD_BONE_DAGGER_P_,
            ItemID.DTTD_BONE_DAGGER_P__),
    BLACK_DAGGER(ItemID.BLACK_DAGGER, ItemID.BLACK_DAGGER_P, ItemID.BLACK_DAGGER_P_, ItemID.BLACK_DAGGER_P__),
    WHITE_DAGGER(ItemID.WHITE_DAGGER, ItemID.WHITE_DAGGER_P, ItemID.WHITE_DAGGER_P_, ItemID.WHITE_DAGGER_P__),
    STEEL_DAGGER(ItemID.STEEL_DAGGER, ItemID.STEEL_DAGGER_P, ItemID.STEEL_DAGGER_P_, ItemID.STEEL_DAGGER_P__),
    MITHRIL_DAGGER(ItemID.MITHRIL_DAGGER, ItemID.MITHRIL_DAGGER_P, ItemID.MITHRIL_DAGGER_P_, ItemID.MITHRIL_DAGGER_P__),
    ADAMANT_DAGGER(ItemID.ADAMANT_DAGGER, ItemID.ADAMANT_DAGGER_P, ItemID.ADAMANT_DAGGER_P_, ItemID.ADAMANT_DAGGER_P__),
    RUNE_DAGGER(ItemID.RUNE_DAGGER, ItemID.RUNE_DAGGER_P, ItemID.RUNE_DAGGER_P_, ItemID.RUNE_DAGGER_P__),
    DRAGON_DAGGER(ItemID.DRAGON_DAGGER, ItemID.DRAGON_DAGGER_P, ItemID.DRAGON_DAGGER_P_, ItemID.DRAGON_DAGGER_P__),
    ABYSSAL_DAGGER(ItemID.ABYSSAL_DAGGER, ItemID.ABYSSAL_DAGGER_P, ItemID.ABYSSAL_DAGGER_P_, ItemID.ABYSSAL_DAGGER_P__),

    // --- Javelins ---
    BRONZE_JAVELIN(ItemID.BRONZE_JAVELIN, ItemID.BRONZE_JAVELIN_P, ItemID.BRONZE_JAVELIN_P_, ItemID.BRONZE_JAVELIN_P__),
    IRON_JAVELIN(ItemID.IRON_JAVELIN, ItemID.IRON_JAVELIN_P, ItemID.IRON_JAVELIN_P_, ItemID.IRON_JAVELIN_P__),
    STEEL_JAVELIN(ItemID.STEEL_JAVELIN, ItemID.STEEL_JAVELIN_P, ItemID.STEEL_JAVELIN_P_, ItemID.STEEL_JAVELIN_P__),
    MITHRIL_JAVELIN(ItemID.MITHRIL_JAVELIN, ItemID.MITHRIL_JAVELIN_P, ItemID.MITHRIL_JAVELIN_P_,
            ItemID.MITHRIL_JAVELIN_P__),
    ADAMANT_JAVELIN(ItemID.ADAMANT_JAVELIN, ItemID.ADAMANT_JAVELIN_P, ItemID.ADAMANT_JAVELIN_P_,
            ItemID.ADAMANT_JAVELIN_P__),
    RUNE_JAVELIN(ItemID.RUNE_JAVELIN, ItemID.RUNE_JAVELIN_P, ItemID.RUNE_JAVELIN_P_, ItemID.RUNE_JAVELIN_P__),
    DRAGON_JAVELIN(ItemID.DRAGON_JAVELIN, ItemID.DRAGON_JAVELIN_P, ItemID.DRAGON_JAVELIN_P_, ItemID.DRAGON_JAVELIN_P__),
    AMETHYST_JAVELIN(ItemID.AMETHYST_JAVELIN, ItemID.AMETHYST_JAVELIN_P, ItemID.AMETHYST_JAVELIN_P_,
            ItemID.AMETHYST_JAVELIN_P__),

    // --- Spears ---
    BRONZE_SPEAR(ItemID.BRONZE_SPEAR, ItemID.BRONZE_SPEAR_P, ItemID.BRONZE_SPEAR_P_, ItemID.BRONZE_SPEAR_P__),
    IRON_SPEAR(ItemID.IRON_SPEAR, ItemID.IRON_SPEAR_P, ItemID.IRON_SPEAR_P_, ItemID.IRON_SPEAR_P__),
    BLACK_SPEAR(ItemID.BLACK_SPEAR, ItemID.BLACK_SPEAR_P, ItemID.BLACK_SPEAR_P_, ItemID.BLACK_SPEAR_P__),
    STEEL_SPEAR(ItemID.STEEL_SPEAR, ItemID.STEEL_SPEAR_P, ItemID.STEEL_SPEAR_P_, ItemID.STEEL_SPEAR_P__),
    MITHRIL_SPEAR(ItemID.MITHRIL_SPEAR, ItemID.MITHRIL_SPEAR_P, ItemID.MITHRIL_SPEAR_P_, ItemID.MITHRIL_SPEAR_P__),
    ADAMANT_SPEAR(ItemID.ADAMANT_SPEAR, ItemID.ADAMANT_SPEAR_P, ItemID.ADAMANT_SPEAR_P_, ItemID.ADAMANT_SPEAR_P__),
    RUNE_SPEAR(ItemID.RUNE_SPEAR, ItemID.RUNE_SPEAR_P, ItemID.RUNE_SPEAR_P_, ItemID.RUNE_SPEAR_P__),
    DRAGON_SPEAR(ItemID.DRAGON_SPEAR, ItemID.DRAGON_SPEAR_P, ItemID.DRAGON_SPEAR_P_, ItemID.DRAGON_SPEAR_P__),

    // --- Hastas ---
    BRONZE_HASTA(ItemID.BRUT_BRONZE_SPEAR, ItemID.BRUT_BRONZE_SPEAR_P, ItemID.BRUT_BRONZE_SPEAR_P_,
            ItemID.BRUT_BRONZE_SPEAR_P__),
    IRON_HASTA(ItemID.BRUT_IRON_SPEAR, ItemID.BRUT_IRON_SPEAR_P, ItemID.BRUT_IRON_SPEAR_P_,
            ItemID.BRUT_IRON_SPEAR_P__),
    STEEL_HASTA(ItemID.BRUT_STEEL_SPEAR, ItemID.BRUT_STEEL_SPEAR_P, ItemID.BRUT_STEEL_SPEAR_P_,
            ItemID.BRUT_STEEL_SPEAR_P__),
    MITHRIL_HASTA(ItemID.BRUT_MITHRIL_SPEAR, ItemID.BRUT_MITHRIL_SPEAR_P, ItemID.BRUT_MITHRIL_SPEAR_P_,
            ItemID.BRUT_MITHRIL_SPEAR_P__),
    ADAMANT_HASTA(ItemID.BRUT_ADAMANT_SPEAR, ItemID.BRUT_ADAMANT_SPEAR_P, ItemID.BRUT_ADAMANT_SPEAR_P_,
            ItemID.BRUT_ADAMANT_SPEAR_P__),
    RUNE_HASTA(ItemID.BRUT_RUNE_SPEAR, ItemID.BRUT_RUNE_SPEAR_P, ItemID.BRUT_RUNE_SPEAR_P_,
            ItemID.BRUT_RUNE_SPEAR_P__),
    DRAGON_HASTA(ItemID.BRUT_DRAGON_SPEAR, ItemID.BRUT_DRAGON_SPEAR_P, ItemID.BRUT_DRAGON_SPEAR_P_,
            ItemID.BRUT_DRAGON_SPEAR_P__),

    // --- Darts ---
    BRONZE_DART(ItemID.BRONZE_DART, ItemID.BRONZE_DART_P, ItemID.BRONZE_DART_P_, ItemID.BRONZE_DART_P__),
    IRON_DART(ItemID.IRON_DART, ItemID.IRON_DART_P, ItemID.IRON_DART_P_, ItemID.IRON_DART_P__),
    BLACK_DART(ItemID.BLACK_DART, ItemID.BLACK_DART_P, ItemID.BLACK_DART_P_, ItemID.BLACK_DART_P__),
    STEEL_DART(ItemID.STEEL_DART, ItemID.STEEL_DART_P, ItemID.STEEL_DART_P_, ItemID.STEEL_DART_P__),
    MITHRIL_DART(ItemID.MITHRIL_DART, ItemID.MITHRIL_DART_P, ItemID.MITHRIL_DART_P_, ItemID.MITHRIL_DART_P__),
    ADAMANT_DART(ItemID.ADAMANT_DART, ItemID.ADAMANT_DART_P, ItemID.ADAMANT_DART_P_, ItemID.ADAMANT_DART_P__),
    RUNE_DART(ItemID.RUNE_DART, ItemID.RUNE_DART_P, ItemID.RUNE_DART_P_, ItemID.RUNE_DART_P__),
    DRAGON_DART(ItemID.DRAGON_DART, ItemID.DRAGON_DART_P, ItemID.DRAGON_DART_P_, ItemID.DRAGON_DART_P__),
    AMETHYST_DART(ItemID.AMETHYST_DART, ItemID.AMETHYST_DART_P, ItemID.AMETHYST_DART_P_, ItemID.AMETHYST_DART_P__),

    // --- Knives ---
    BRONZE_KNIFE(ItemID.BRONZE_KNIFE, ItemID.BRONZE_KNIFE_P, ItemID.BRONZE_KNIFE_P_, ItemID.BRONZE_KNIFE_P__),
    IRON_KNIFE(ItemID.IRON_KNIFE, ItemID.IRON_KNIFE_P, ItemID.IRON_KNIFE_P_, ItemID.IRON_KNIFE_P__),
    BLACK_KNIFE(ItemID.BLACK_KNIFE, ItemID.BLACK_KNIFE_P, ItemID.BLACK_KNIFE_P_, ItemID.BLACK_KNIFE_P__),
    STEEL_KNIFE(ItemID.STEEL_KNIFE, ItemID.STEEL_KNIFE_P, ItemID.STEEL_KNIFE_P_, ItemID.STEEL_KNIFE_P__),
    MITHRIL_KNIFE(ItemID.MITHRIL_KNIFE, ItemID.MITHRIL_KNIFE_P, ItemID.MITHRIL_KNIFE_P_, ItemID.MITHRIL_KNIFE_P__),
    ADAMANT_KNIFE(ItemID.ADAMANT_KNIFE, ItemID.ADAMANT_KNIFE_P, ItemID.ADAMANT_KNIFE_P_, ItemID.ADAMANT_KNIFE_P__),
    RUNE_KNIFE(ItemID.RUNE_KNIFE, ItemID.RUNE_KNIFE_P, ItemID.RUNE_KNIFE_P_, ItemID.RUNE_KNIFE_P__),
    DRAGON_KNIFE(ItemID.DRAGON_KNIFE, ItemID.DRAGON_KNIFE_P, ItemID.DRAGON_KNIFE_P_, ItemID.DRAGON_KNIFE_P__),

    // --- Arrows ---
    BRONZE_ARROW(ItemID.BRONZE_ARROW, ItemID.BRONZE_ARROW_P, ItemID.BRONZE_ARROW_P_, ItemID.BRONZE_ARROW_P__),
    IRON_ARROW(ItemID.IRON_ARROW, ItemID.IRON_ARROW_P, ItemID.IRON_ARROW_P_, ItemID.IRON_ARROW_P__),
    STEEL_ARROW(ItemID.STEEL_ARROW, ItemID.STEEL_ARROW_P, ItemID.STEEL_ARROW_P_, ItemID.STEEL_ARROW_P__),
    MITHRIL_ARROW(ItemID.MITHRIL_ARROW, ItemID.MITHRIL_ARROW_P, ItemID.MITHRIL_ARROW_P_, ItemID.MITHRIL_ARROW_P__),
    ADAMANT_ARROW(ItemID.ADAMANT_ARROW, ItemID.ADAMANT_ARROW_P, ItemID.ADAMANT_ARROW_P_, ItemID.ADAMANT_ARROW_P__),
    RUNE_ARROW(ItemID.RUNE_ARROW, ItemID.RUNE_ARROW_P, ItemID.RUNE_ARROW_P_, ItemID.RUNE_ARROW_P__),
    DRAGON_ARROW(ItemID.DRAGON_ARROW, ItemID.DRAGON_ARROW_P, ItemID.DRAGON_ARROW_P_, ItemID.DRAGON_ARROW_P__),
    AMETHYST_ARROW(ItemID.AMETHYST_ARROW, ItemID.AMETHYST_ARROW_P, ItemID.AMETHYST_ARROW_P_, ItemID.AMETHYST_ARROW_P__),

    // --- Bolts ---
    BRONZE_BOLTS(ItemID.BOLT, ItemID.POISON_BOLT, ItemID.POISON_BOLT_, ItemID.POISON_BOLT__),
    IRON_BOLTS(ItemID.XBOWS_CROSSBOW_BOLTS_IRON, ItemID.XBOWS_CROSSBOW_BOLTS_IRON_POISONED,
            ItemID.XBOWS_CROSSBOW_BOLTS_IRON_POISONED_, ItemID.XBOWS_CROSSBOW_BOLTS_IRON_POISONED__),
    SILVER_BOLTS(ItemID.XBOWS_CROSSBOW_BOLTS_SILVER, ItemID.XBOWS_CROSSBOW_BOLTS_SILVER_POISONED,
            ItemID.XBOWS_CROSSBOW_BOLTS_SILVER_POISONED_, ItemID.XBOWS_CROSSBOW_BOLTS_SILVER_POISONED__),
    STEEL_BOLTS(ItemID.XBOWS_CROSSBOW_BOLTS_STEEL, ItemID.XBOWS_CROSSBOW_BOLTS_STEEL_POISONED,
            ItemID.XBOWS_CROSSBOW_BOLTS_STEEL_POISONED_, ItemID.XBOWS_CROSSBOW_BOLTS_STEEL_POISONED__),
    MITHRIL_BOLTS(ItemID.XBOWS_CROSSBOW_BOLTS_MITHRIL, ItemID.XBOWS_CROSSBOW_BOLTS_MITHRIL_POISONED,
            ItemID.XBOWS_CROSSBOW_BOLTS_MITHRIL_POISONED_, ItemID.XBOWS_CROSSBOW_BOLTS_MITHRIL_POISONED__),
    ADAMANTITE_BOLTS(ItemID.XBOWS_CROSSBOW_BOLTS_ADAMANTITE, ItemID.XBOWS_CROSSBOW_BOLTS_ADAMANTITE_POISONED,
            ItemID.XBOWS_CROSSBOW_BOLTS_ADAMANTITE_POISONED_, ItemID.XBOWS_CROSSBOW_BOLTS_ADAMANTITE_POISONED__),
    RUNITE_BOLTS(ItemID.XBOWS_CROSSBOW_BOLTS_RUNITE, ItemID.XBOWS_CROSSBOW_BOLTS_RUNITE_POISONED,
            ItemID.XBOWS_CROSSBOW_BOLTS_RUNITE_POISONED_, ItemID.XBOWS_CROSSBOW_BOLTS_RUNITE_POISONED__),
    DRAGON_BOLTS(ItemID.DRAGON_BOLTS, ItemID.DRAGON_BOLTS_P, ItemID.DRAGON_BOLTS_P_, ItemID.DRAGON_BOLTS_P__);

    private final int baseId;
    private final int poisonId;
    private final int poisonPlusId;
    private final int poisonPlusPlusId;

    // Overloaded constructor for global prerequisites
    PoisonWeapons(int id) {
        this.baseId = id;
        this.poisonId = id;
        this.poisonPlusId = id;
        this.poisonPlusPlusId = id;
    }

    // Constructor for weapons with distinct variant IDs.
    PoisonWeapons(int baseId, int poisonId, int poisonPlusId, int poisonPlusPlusId) {
        this.baseId = baseId;
        this.poisonId = poisonId;
        this.poisonPlusId = poisonPlusId;
        this.poisonPlusPlusId = poisonPlusPlusId;
    }

    /**
     * Checks whether the given item id matches any variant of this weapon.
     *
     * @param id the item id to check.
     * @return true if the id matches base, poison, poison+ or poison++.
     */
    public boolean matches(int id) {
        return id == baseId || id == poisonId || id == poisonPlusId || id == poisonPlusPlusId;
    }

    /**
     * Returns an unmodifiable set of all base weapon ids from poisonable weapons, excluding poison constants.
     */
    public static Set<Integer> getAllBaseWeaponIds() {
        Set<Integer> ids = new HashSet<>();
        for (PoisonWeapons weapon : values()) {
            if (!weapon.name().startsWith("WEAPON_POISON")) {
                ids.add(weapon.getBaseId());
            }
        }
        return Collections.unmodifiableSet(ids);
    }

    /**
     * Checks if a given item id is a poisonable weapon variant.
     *
     * @param itemId the item id to check.
     * @return true if it matches any poisonable weapon variant.
     */
    public static boolean isPoisonableWeapon(int itemId) {
        for (PoisonWeapons weapon : values()) {
            if (weapon.name().startsWith("WEAPON_POISON")) continue;
            if (weapon.matches(itemId)) {
                return true;
            }
        }
        return false;
    }

    /**
     * Checks if a poisonable weapon variant is eligible.
     * Base weapons are always eligible.
     * For poisoned variants:
     *   - (p) requires WEAPON_POISON,
     *   - (p+) requires WEAPON_POISON_,
     *   - (p++) requires WEAPON_POISON__,
     * to be unlocked along with the base weapon.
     * @param itemId the item ID to check
     * @param requireWeaponPoison if true, the corresponding global poison must be unlocked
     * @param unlockedItems the set of unlocked item IDs
     * @return true if eligible; false otherwise
     */
    public static boolean isPoisonVariantEligible(int itemId, boolean requireWeaponPoison, Set<Integer> unlockedItems) {
        PoisonWeapons matchingWeapon = null;
        for (PoisonWeapons weapon : values()) {
            if (weapon.name().startsWith("WEAPON_POISON")) continue;
            if (weapon.matches(itemId)) {
                matchingWeapon = weapon;
                break;
            }
        }
        if (matchingWeapon == null) {
            return true;
        }
        // Base weapon is always eligible.
        if (itemId == matchingWeapon.getBaseId()) {
            return true;
        }
        if (!requireWeaponPoison) {
            return true;
        }
        int requiredGlobalId;
        if (itemId == matchingWeapon.getPoisonId()) {
            requiredGlobalId = PoisonWeapons.WEAPON_POISON.getBaseId();
        } else if (itemId == matchingWeapon.getPoisonPlusId()) {
            requiredGlobalId = PoisonWeapons.WEAPON_POISON_.getBaseId();
        } else if (itemId == matchingWeapon.getPoisonPlusPlusId()) {
            requiredGlobalId = PoisonWeapons.WEAPON_POISON__.getBaseId();
        } else {
            return true;
        }
        boolean eligible = unlockedItems.contains(matchingWeapon.getBaseId()) && unlockedItems.contains(requiredGlobalId);
        return eligible;
    }

}

package com.chanceman.filters;

import lombok.Getter;
import net.runelite.api.gameval.ItemID;
import java.util.Collections;
import java.util.HashSet;
import java.util.Set;

/**
 * Enum representing all POH flatpack items.
 */
public enum Flatpacks {
    // Chair variants
    Crudechair(ItemID.POH_FLATPACK_ARMCHAIR1),
    Woodenchair(ItemID.POH_FLATPACK_ARMCHAIR2),
    Rockingchair(ItemID.POH_FLATPACK_ARMCHAIR3),
    Oakchair(ItemID.POH_FLATPACK_ARMCHAIR4),
    Oakarmchair(ItemID.POH_FLATPACK_ARMCHAIR5),
    Teakarmchair(ItemID.POH_FLATPACK_ARMCHAIR6),
    Mahoganyarmchair(ItemID.POH_FLATPACK_ARMCHAIR7),

    // Bookcase variants
    Bookcase(ItemID.POH_FLATPACK_BOOKCASE1),
    Oakbookcase(ItemID.POH_FLATPACK_BOOKCASE2),
    Mahoganybookcase(ItemID.POH_FLATPACK_BOOKCASE3),

    // Beer barrel variants
    Beerbarrel(ItemID.POH_FLATPACK_BEERBARREL1),
    Ciderbarrel(ItemID.POH_FLATPACK_BEERBARREL2),
    Asgarnianale(ItemID.POH_FLATPACK_BEERBARREL3),
    Greensmansale(ItemID.POH_FLATPACK_BEERBARREL4),
    Dragonbitter(ItemID.POH_FLATPACK_BEERBARREL5),
    Chefsdelight(ItemID.POH_FLATPACK_BEERBARREL6),

    // Kitchen table variants
    Kitchentable(ItemID.POH_FLATPACK_KITCHENTABLE1),
    Oakkitchentable(ItemID.POH_FLATPACK_KITCHENTABLE2),
    Teakkitchentable(ItemID.POH_FLATPACK_KITCHENTABLE3),

    // Dining table variants
    Wooddiningtable(ItemID.POH_FLATPACK_DININGTABLE1),
    Oakdiningtable(ItemID.POH_FLATPACK_DININGTABLE2),
    Carvedoaktable(ItemID.POH_FLATPACK_DININGTABLE3),
    Teaktable(ItemID.POH_FLATPACK_DININGTABLE4),
    Carvedteaktable(ItemID.POH_FLATPACK_DININGTABLE5),
    Mahoganytable(ItemID.POH_FLATPACK_DININGTABLE6),
    OpulentsTable(ItemID.POH_FLATPACK_DININGTABLE7),

    // Dining chair (bench) variants
    Woodenbench(ItemID.POH_FLATPACK_DININGCHAIR1),
    Oakbench(ItemID.POH_FLATPACK_DININGCHAIR2),
    Carvedoakbench(ItemID.POH_FLATPACK_DININGCHAIR3),
    Teakdiningbench(ItemID.POH_FLATPACK_DININGCHAIR4),
    Carvedteakbench(ItemID.POH_FLATPACK_DININGCHAIR5),
    Mahoganybench(ItemID.POH_FLATPACK_DININGCHAIR6),
    Gildedbench(ItemID.POH_FLATPACK_DININGCHAIR7),

    // Bed variants
    Woodenbed(ItemID.POH_FLATPACK_BED1),
    Oakbed(ItemID.POH_FLATPACK_BED2),
    Largeoakbed(ItemID.POH_FLATPACK_BED3),
    Teakbed(ItemID.POH_FLATPACK_BED4),
    Largeteakbed(ItemID.POH_FLATPACK_BED5),
    Fourposterbed(ItemID.POH_FLATPACK_BED6),
    Gildedfourposter(ItemID.POH_FLATPACK_BED7),

    // Clock variants
    Oakclock(ItemID.POH_FLATPACK_CLOCK1),
    Teakclock(ItemID.POH_FLATPACK_CLOCK2),
    Gildedclock(ItemID.POH_FLATPACK_CLOCK3),

    // Dresser variants
    Shavingstand(ItemID.POH_FLATPACK_DRESSER1),
    Oakshavingstand(ItemID.POH_FLATPACK_DRESSER2),
    Oakdresser(ItemID.POH_FLATPACK_DRESSER3),
    Teakdresser(ItemID.POH_FLATPACK_DRESSER4),
    Fancyteakdresser(ItemID.POH_FLATPACK_DRESSER5),
    Mahoganydresser(ItemID.POH_FLATPACK_DRESSER6),
    Gildeddresser(ItemID.POH_FLATPACK_DRESSER7),

    // Wardrobe variants
    Shoebox(ItemID.POH_FLATPACK_WARDROBE1),
    Oakdrawers(ItemID.POH_FLATPACK_WARDROBE2),
    Oakwardrobe(ItemID.POH_FLATPACK_WARDROBE3),
    Teakdrawers(ItemID.POH_FLATPACK_WARDROBE4),
    Teakwardrobe(ItemID.POH_FLATPACK_WARDROBE5),
    Mahoganywardrobe(ItemID.POH_FLATPACK_WARDROBE6),
    Gildedwardrobe(ItemID.POH_FLATPACK_WARDROBE7),

    // Cape rack variants
    Oakcaperack(ItemID.POH_FLATPACK_CAPE_RACK),
    Teakcaperack(ItemID.POH_FLATPACK_CAPE_RACK2),
    Mahoganycaperack(ItemID.POH_FLATPACK_CAPE_RACK3),
    Gildedcaperack(ItemID.POH_FLATPACK_CAPE_RACK4),
    Marblecaperack(ItemID.POH_FLATPACK_CAPE_RACK5),
    Magiccaperack(ItemID.POH_FLATPACK_CAPE_RACK6),

    // Toy box variants
    Oaktoybox(ItemID.POH_FLATPACK_TOY_BOX),
    Teaktoybox(ItemID.POH_FLATPACK_TOY_BOX2),
    Mahoganytoybox(ItemID.POH_FLATPACK_TOY_BOX3),

    // Magic wardrobe variants
    Oakmagicwardrobe(ItemID.POH_FLATPACK_MAGIC_WARDROBE),
    Carvedoakmagicwardrobe(ItemID.POH_FLATPACK_MAGIC_WARDROBE2),
    Teakmagicwardrobe(ItemID.POH_FLATPACK_MAGIC_WARDROBE3),
    Carvedteakmagicwardrobe(ItemID.POH_FLATPACK_MAGIC_WARDROBE4),
    Mahoganymagicwardrobe(ItemID.POH_FLATPACK_MAGIC_WARDROBE5),
    Gildedmagicwardrobe(ItemID.POH_FLATPACK_MAGIC_WARDROBE6),
    Marblemagicwardrobe(ItemID.POH_FLATPACK_MAGIC_WARDROBE7),

    // Armour case variants
    Oakarmourcase(ItemID.POH_FLATPACK_ARMOUR_CASE),
    Teakarmourcase(ItemID.POH_FLATPACK_ARMOUR_CASE2),
    Mahoganyarmourcase(ItemID.POH_FLATPACK_ARMOUR_CASE3),

    // Treasure chest variants
    Oaktreasurechest(ItemID.POH_FLATPACK_TREASURE_CHEST),
    Teaktreasurechest(ItemID.POH_FLATPACK_TREASURE_CHEST2),
    Magictreasurechest(ItemID.POH_FLATPACK_TREASURE_CHEST3),

    // Fancy dress box variants
    Oakfancydressbox(ItemID.POH_FLATPACK_FANCY_DRESS_BOX),
    Teakfancydressbox(ItemID.POH_FLATPACK_FANCY_DRESS_BOX2),
    Mahoganyfancydressbox(ItemID.POH_FLATPACK_FANCY_DRESS_BOX3);

    @Getter
    private final int id;

    Flatpacks(int id) {
        this.id = id;
    }

    /**
     * Returns an unmodifiable set of all flatpack item IDs.
     */
    public static Set<Integer> getAllFlatpackIds() {
        Set<Integer> ids = new HashSet<>();
        for (Flatpacks fp : Flatpacks.values()) {
            ids.add(fp.getId());
        }
        return Collections.unmodifiableSet(ids);
    }

    /**
     * Checks if the given item ID is a flatpack.
     *
     * @param id the item id to check.
     * @return true if the id is a flatpack, false otherwise.
     */
    public static boolean isFlatpack(int id) {
        return getAllFlatpackIds().contains(id);
    }
}

package com.chanceman.filters;

import lombok.Getter;
import net.runelite.api.gameval.ItemID;

import java.util.Collections;
import java.util.HashSet;
import java.util.Set;

public enum FreeToPlayBlockedItems {

    // Random
    Charcoal(ItemID.CHARCOAL),
    RawBoarMeat(ItemID.RAW_BOAR_MEAT),
    PureEssence(ItemID.BLANKRUNE_HIGH),
    CastleWarsBracelet3(ItemID.JEWL_CASTLEWARS_BRACELET3),
    CursedAmuletOfMagic(ItemID.AMULET_OF_MAGIC_CURSED),
    Dust(ItemID.DUST),

    // Dyed boots and gloves
    GreyBoots(ItemID.WOLFENBOOTS_GREY),
    RedBoots(ItemID.WOLFENBOOTS_CRIMSON),
    YellowBoots(ItemID.WOLFENBOOTS_TANGERINE),
    TealBoots(ItemID.WOLFENBOOTS_OCEAN),
    PurpleBoots(ItemID.WOLFENBOOTS_PURPLE),
    GreyGloves(ItemID.WOLFENGLOVES_GREY),
    RedGloves(ItemID.WOLFENGLOVES_CRIMSON),
    YellowGloves(ItemID.WOLFENGLOVES_TANGERINE),
    TealGloves(ItemID.WOLFENGLOVES_OCEAN),
    PurpleGloves(ItemID.WOLFENGLOVES_PURPLE),

    // Shade
    ShadeRobeTop(ItemID.BLACKROBETOP),
    ShadeRobe(ItemID.BLACKROBEBOTTOM),

    // Elven wear
    ElvenTop(ItemID.PRIF_ELVEN_CLOTHES_TOP_1),
    ElvenSkirt(ItemID.PRIF_ELVEN_CLOTHES_BOTTOMS_1),
    ElvenTop2(ItemID.PRIF_ELVEN_CLOTHES_TOP_2),
    ElvenSkirt2(ItemID.PRIF_ELVEN_CLOTHES_BOTTOMS_2),
    ElvenTop3(ItemID.PRIF_ELVEN_CLOTHES_TOP_3),
    ElvenLegwear(ItemID.PRIF_ELVEN_CLOTHES_BOTTOMS_3),
    ElvenTop4(ItemID.PRIF_ELVEN_CLOTHES_TOP_4),

    // Dragonstone
    DragonstoneFullHelm(ItemID.DRAGONSTONE_HELMET),
    DragonstonePlatebody(ItemID.DRAGONSTONE_PLATEBODY),
    DragonstonePlatelegs(ItemID.DRAGONSTONE_PLATELEGS),

    // Wilderness capes (the rest are accessible on f2p)
    Team4Cape(ItemID.WILDERNESS_CAPE_4),
    Team5Cape(ItemID.WILDERNESS_CAPE_5),
    Team14Cape(ItemID.WILDERNESS_CAPE_14),
    Team15Cape(ItemID.WILDERNESS_CAPE_15),
    Team24Cape(ItemID.WILDERNESS_CAPE_24),
    Team25Cape(ItemID.WILDERNESS_CAPE_25),
    Team34Cape(ItemID.WILDERNESS_CAPE_34),
    Team35Cape(ItemID.WILDERNESS_CAPE_35),
    Team44Cape(ItemID.WILDERNESS_CAPE_44),
    Team45Cape(ItemID.WILDERNESS_CAPE_45),

    // Clue Scroll - Random
    WillowCompBow(ItemID.TRAIL_COMPOSITE_BOW_WILLOW),
    HamJoint(ItemID.JOINT_OF_HAM),
    WoodenShieldG(ItemID.WOODEN_SHIELD_GOLD),

    // Clue Scroll - Random Gilded
    GildedScimitar(ItemID.RUNE_SCIMITAR_GOLD),
    Gilded2HSword(ItemID.RUNE_2H_SWORD_GOLD),
    GoldenChefsHat(ItemID.CHEFS_HAT_GOLD),
    GoldenApron(ItemID.GOLDEN_APRON),
    GildedPickaxe(ItemID.TRAIL_GILDED_PICKAXE),
    GildedAxe(ItemID.TRAIL_GILDED_AXE),
    GildedSpade(ItemID.TRAIL_GILDED_SPADE),

    // Clue Scroll - Cape
    TeamCapeZero(ItemID.WILDERNESS_CAPE_ZERO),
    TeamCapeX(ItemID.WILDERNESS_CAPE_X),
    TeamCapeI(ItemID.WILDERNESS_CAPE_I),
    WolfCloak(ItemID.WOLF_CLOAK),

    // Clue Scroll - Amulet
    StrengthAmuletT(ItemID.TRAIL_AMULET_OF_STRENGTH),
    AmuletOfMagicT(ItemID.TRAIL_AMULET_OF_MAGIC),
    AmuletOfPowerT(ItemID.TRAIL_POWER_AMMY),

    // Clue Scroll - Ring
    RingOfNature(ItemID.RING_OF_NATURE),
    RingOfCoins(ItemID.RING_OF_COINS),
    RingOf3RdAge(ItemID.RING_OF_3RD_AGE),

    // Clue Scroll - Bronze Armor
    BronzePlatebodyG(ItemID.BRONZE_PLATEBODY_GOLD),
    BronzePlatelegsG(ItemID.BRONZE_PLATELEGS_GOLD),
    BronzePlateskirtG(ItemID.BRONZE_PLATESKIRT_GOLD),
    BronzeFullHelmG(ItemID.BRONZE_FULL_HELM_GOLD),
    BronzeKiteshieldG(ItemID.BRONZE_KITESHIELD_GOLD),
    BronzePlatebodyT(ItemID.BRONZE_PLATEBODY_TRIM),
    BronzePlatelegsT(ItemID.BRONZE_PLATELEGS_TRIM),
    BronzePlateskirtT(ItemID.BRONZE_PLATESKIRT_TRIM),
    BronzeFullHelmT(ItemID.BRONZE_FULL_HELM_TRIM),
    BronzeKiteshieldT(ItemID.BRONZE_KITESHIELD_TRIM),

    // Clue Scroll - Iron Armor
    IronPlatebodyT(ItemID.IRON_PLATEBODY_TRIM),
    IronPlatelegsT(ItemID.IRON_PLATELEGS_TRIM),
    IronPlateskirtT(ItemID.IRON_PLATESKIRT_TRIM),
    IronFullHelmT(ItemID.IRON_FULL_HELM_TRIM),
    IronKiteshieldT(ItemID.IRON_KITESHIELD_TRIM),
    IronPlatebodyG(ItemID.IRON_PLATEBODY_GOLD),
    IronPlatelegsG(ItemID.IRON_PLATELEGS_GOLD),
    IronPlateskirtG(ItemID.IRON_PLATESKIRT_GOLD),
    IronFullHelmG(ItemID.IRON_FULL_HELM_GOLD),
    IronKiteshieldG(ItemID.IRON_KITESHIELD_GOLD),

    // Clue Scroll - Steel Armor
    SteelPlatebodyG(ItemID.STEEL_PLATEBODY_GOLD),
    SteelPlatelegsG(ItemID.STEEL_PLATELEGS_GOLD),
    SteelPlateskirtG(ItemID.STEEL_PLATESKIRT_GOLD),
    SteelFullHelmG(ItemID.STEEL_FULL_HELM_GOLD),
    SteelKiteshieldG(ItemID.STEEL_KITESHIELD_GOLD),
    SteelPlatebodyT(ItemID.STEEL_PLATEBODY_TRIM),
    SteelPlatelegsT(ItemID.STEEL_PLATELEGS_TRIM),
    SteelPlateskirtT(ItemID.STEEL_PLATESKIRT_TRIM),
    SteelFullHelmT(ItemID.STEEL_FULL_HELM_TRIM),
    SteelKiteshieldT(ItemID.STEEL_KITESHIELD_TRIM),

    // Clue Scroll - Mithril Armor
    MithrilPlatebodyG(ItemID.MITHRIL_PLATEBODY_GOLD),
    MithrilPlatelegsG(ItemID.MITHRIL_PLATELEGS_GOLD),
    MithrilKiteshieldG(ItemID.MITHRIL_KITESHIELD_GOLD),
    MithrilFullHelmG(ItemID.MITHRIL_FULL_HELM_GOLD),
    MithrilPlateskirtG(ItemID.MITHRIL_PLATESKIRT_GOLD),
    MithrilPlatebodyT(ItemID.MITHRIL_PLATEBODY_TRIM),
    MithrilPlatelegsT(ItemID.MITHRIL_PLATELEGS_TRIM),
    MithrilKiteshieldT(ItemID.MITHRIL_KITESHIELD_TRIM),
    MithrilFullHelmT(ItemID.MITHRIL_FULL_HELM_TRIM),
    MithrilPlateskirtT(ItemID.MITHRIL_PLATESKIRT_TRIM),

    // Clue Scroll - Black Armor
    BlackPlatebodyT(ItemID.BLACK_PLATEBODY_TRIM),
    BlackPlatelegsT(ItemID.BLACK_PLATELEGS_TRIM),
    BlackFullHelmT(ItemID.BLACK_FULL_HELM_TRIM),
    BlackKiteshieldT(ItemID.BLACK_KITESHIELD_TRIM),
    BlackPlateskirtT(ItemID.BLACK_PLATESKIRT_TRIM),
    BlackPlatebodyG(ItemID.BLACK_PLATEBODY_GOLD),
    BlackPlatelegsG(ItemID.BLACK_PLATELEGS_GOLD),
    BlackFullHelmG(ItemID.BLACK_FULL_HELM_GOLD),
    BlackKiteshieldG(ItemID.BLACK_KITESHIELD_GOLD),
    BlackPlateskirtG(ItemID.BLACK_PLATESKIRT_GOLD),
    BlackShieldH1(ItemID.BLACK_HERALDIC_KITESHIELD1),
    BlackShieldH2(ItemID.BLACK_HERALDIC_KITESHIELD2),
    BlackShieldH3(ItemID.BLACK_HERALDIC_KITESHIELD3),
    BlackShieldH4(ItemID.BLACK_HERALDIC_KITESHIELD4),
    BlackShieldH5(ItemID.BLACK_HERALDIC_KITESHIELD5),
    BlackHelmH1(ItemID.TRAIL_HERALDIC_HELM_1_BLACK),
    BlackHelmH2(ItemID.TRAIL_HERALDIC_HELM_2_BLACK),
    BlackHelmH3(ItemID.TRAIL_HERALDIC_HELM_3_BLACK),
    BlackHelmH4(ItemID.TRAIL_HERALDIC_HELM_4_BLACK),
    BlackHelmH5(ItemID.TRAIL_HERALDIC_HELM_5_BLACK),
    BlackPlatebodyH1(ItemID.BLACK_PLATEBODY_H1),
    BlackPlatebodyH2(ItemID.BLACK_PLATEBODY_H2),
    BlackPlatebodyH3(ItemID.BLACK_PLATEBODY_H3),
    BlackPlatebodyH4(ItemID.BLACK_PLATEBODY_H4),
    BlackPlatebodyH5(ItemID.BLACK_PLATEBODY_H5),

    // Clue Scroll - Adamant Armor
    AdamantPlatebodyT(ItemID.ADAMANT_PLATEBODY_TRIM),
    AdamantPlatelegsT(ItemID.ADAMANT_PLATELEGS_TRIM),
    AdamantKiteshieldT(ItemID.ADAMANT_KITESHIELD_TRIM),
    AdamantFullHelmT(ItemID.ADAMANT_FULL_HELM_TRIM),
    AdamantPlateskirtT(ItemID.ADAMANT_PLATESKIRT_TRIM),
    AdamantPlatebodyG(ItemID.ADAMANT_PLATEBODY_GOLD),
    AdamantPlatelegsG(ItemID.ADAMANT_PLATELEGS_GOLD),
    AdamantKiteshieldG(ItemID.ADAMANT_KITESHIELD_GOLD),
    AdamantFullHelmG(ItemID.ADAMANT_FULL_HELM_GOLD),
    AdamantPlateskirtG(ItemID.ADAMANT_PLATESKIRT_GOLD),
    AdamantShieldH1(ItemID.ADAMANT_HERALDIC_KITESHIELD1),
    AdamantShieldH2(ItemID.ADAMANT_HERALDIC_KITESHIELD2),
    AdamantShieldH3(ItemID.ADAMANT_HERALDIC_KITESHIELD3),
    AdamantShieldH4(ItemID.ADAMANT_HERALDIC_KITESHIELD4),
    AdamantShieldH5(ItemID.ADAMANT_HERALDIC_KITESHIELD5),
    AdamantHelmH1(ItemID.TRAIL_HERALDIC_HELM_1_ADAMANT),
    AdamantHelmH2(ItemID.TRAIL_HERALDIC_HELM_2_ADAMANT),
    AdamantHelmH3(ItemID.TRAIL_HERALDIC_HELM_3_ADAMANT),
    AdamantHelmH4(ItemID.TRAIL_HERALDIC_HELM_4_ADAMANT),
    AdamantHelmH5(ItemID.TRAIL_HERALDIC_HELM_5_ADAMANT),
    AdamantPlatebodyH1(ItemID.ADAMANT_PLATEBODY_H1),
    AdamantPlatebodyH2(ItemID.ADAMANT_PLATEBODY_H2),
    AdamantPlatebodyH3(ItemID.ADAMANT_PLATEBODY_H3),
    AdamantPlatebodyH4(ItemID.ADAMANT_PLATEBODY_H4),
    AdamantPlatebodyH5(ItemID.ADAMANT_PLATEBODY_H5),

    // Clue Scroll - Rune Armor
    RunePlatebodyT(ItemID.RUNE_PLATEBODY_TRIM),
    RunePlatelegsT(ItemID.RUNE_PLATELEGS_TRIM),
    RuneFullHelmT(ItemID.RUNE_FULL_HELM_TRIM),
    RuneKiteshieldT(ItemID.RUNE_KITESHIELD_TRIM),
    RunePlateskirtT(ItemID.RUNE_PLATESKIRT_TRIM),
    RunePlatebodyG(ItemID.RUNE_PLATEBODY_GOLD),
    RunePlatelegsG(ItemID.RUNE_PLATELEGS_GOLD),
    RuneFullHelmG(ItemID.RUNE_FULL_HELM_GOLD),
    RuneKiteshieldG(ItemID.RUNE_KITESHIELD_GOLD),
    RunePlateskirtG(ItemID.RUNE_PLATESKIRT_GOLD),
    RuneShieldH1(ItemID.RUNE_HERALDIC_KITESHIELD1),
    RuneShieldH2(ItemID.RUNE_HERALDIC_KITESHIELD2),
    RuneShieldH3(ItemID.RUNE_HERALDIC_KITESHIELD3),
    RuneShieldH4(ItemID.RUNE_HERALDIC_KITESHIELD4),
    RuneShieldH5(ItemID.RUNE_HERALDIC_KITESHIELD5),
    RuneHelmH1(ItemID.TRAIL_HERALDIC_HELM_1_RUNE),
    RuneHelmH2(ItemID.TRAIL_HERALDIC_HELM_2_RUNE),
    RuneHelmH3(ItemID.TRAIL_HERALDIC_HELM_3_RUNE),
    RuneHelmH4(ItemID.TRAIL_HERALDIC_HELM_4_RUNE),
    RuneHelmH5(ItemID.TRAIL_HERALDIC_HELM_5_RUNE),
    RunePlatebodyH1(ItemID.RUNE_PLATEBODY_H1),
    RunePlatebodyH2(ItemID.RUNE_PLATEBODY_H2),
    RunePlatebodyH3(ItemID.RUNE_PLATEBODY_H3),
    RunePlatebodyH4(ItemID.RUNE_PLATEBODY_H4),
    RunePlatebodyH5(ItemID.RUNE_PLATEBODY_H5),

    // Clue Scroll - God Armor
    ZamorakPlatebody(ItemID.RUNE_PLATEBODY_ZAMORAK),
    ZamorakPlatelegs(ItemID.RUNE_PLATELEGS_ZAMORAK),
    ZamorakFullHelm(ItemID.RUNE_FULL_HELM_ZAMORAK),
    ZamorakKiteshield(ItemID.RUNE_KITESHIELD_ZAMORAK),
    ZamorakPlateskirt(ItemID.RUNE_PLATESKIRT_ZAMORAK),
    SaradominPlatebody(ItemID.RUNE_PLATEBODY_SARADOMIN),
    SaradominPlatelegs(ItemID.RUNE_PLATELEGS_SARADOMIN),
    SaradominFullHelm(ItemID.RUNE_FULL_HELM_SARADOMIN),
    SaradominKiteshield(ItemID.RUNE_KITESHIELD_SARADOMIN),
    SaradominPlateskirt(ItemID.RUNE_PLATESKIRT_SARADOMIN),
    GuthixPlatebody(ItemID.RUNE_PLATEBODY_GUTHIX),
    GuthixPlatelegs(ItemID.RUNE_PLATELEGS_GUTHIX),
    GuthixFullHelm(ItemID.RUNE_FULL_HELM_GUTHIX),
    GuthixKiteshield(ItemID.RUNE_KITESHIELD_GUTHIX),
    GuthixPlateskirt(ItemID.RUNE_PLATESKIRT_GUTHIX),
    AncientPlatebody(ItemID.RUNE_PLATEBODY_ANCIENT),
    AncientPlatelegs(ItemID.RUNE_PLATELEGS_ANCIENT),
    AncientPlateskirt(ItemID.RUNE_PLATESKIRT_ANCIENT),
    AncientFullHelm(ItemID.RUNE_FULL_HELM_ANCIENT),
    AncientKiteshield(ItemID.RUNE_KITESHIELD_ANCIENT),
    ArmadylPlatebody(ItemID.RUNE_PLATEBODY_ARMADYL),
    ArmadylPlatelegs(ItemID.RUNE_PLATELEGS_ARMADYL),
    ArmadylPlateskirt(ItemID.RUNE_PLATESKIRT_ARMADYL),
    ArmadylFullHelm(ItemID.RUNE_FULL_HELM_ARMADYL),
    ArmadylKiteshield(ItemID.RUNE_KITESHIELD_ARMADYL),
    BandosPlatebody(ItemID.RUNE_PLATEBODY_BANDOS),
    BandosPlatelegs(ItemID.RUNE_PLATELEGS_BANDOS),
    BandosPlateskirt(ItemID.RUNE_PLATESKIRT_BANDOS),
    BandosFullHelm(ItemID.RUNE_FULL_HELM_BANDOS),
    BandosKiteshield(ItemID.RUNE_KITESHIELD_BANDOS),

    // Clue Scroll - Gilded Armor
    GildedPlatebody(ItemID.RUNE_PLATEBODY_GOLDPLATE),
    GildedPlatelegs(ItemID.RUNE_PLATELEGS_GOLDPLATE),
    GildedPlateskirt(ItemID.RUNE_PLATESKIRT_GOLDPLATE),
    GildedFullHelm(ItemID.RUNE_FULL_HELM_GOLDPLATE),
    GildedKiteshield(ItemID.RUNE_KITESHIELD_GOLDPLATE),
    GildedMedHelm(ItemID.RUNE_MED_HELM_GOLD),
    GildedChainbody(ItemID.RUNE_CHAINBODY_GOLD),
    GildedSqShield(ItemID.RUNE_SQ_SHIELD_GOLD),
    GildedDhideVambraces(ItemID.TRAIL_GILDED_DHIDE_VAMBRACES),
    GildedDhideBody(ItemID.TRAIL_GILDED_DHIDE_TOP),
    GildedDhideChaps(ItemID.TRAIL_GILDED_DHIDE_CHAPS),

    // Clue Scroll - Ranged Armor
    StuddedBodyG(ItemID.STUDDED_BODY_TRIM_GOLD),
    StuddedBodyT(ItemID.STUDDED_BODY_TRIM_FUR),
    StuddedChapsG(ItemID.STUDDED_CHAPS_TRIM_GOLD),
    StuddedChapsT(ItemID.STUDDED_CHAPS_TRIM_FUR),
    GreenDhideBodyG(ItemID.DRAGONHIDE_BODY_TRIM_GOLD),
    GreenDhideBodyT(ItemID.DRAGONHIDE_BODY_TRIM),
    GreenDhideChapsG(ItemID.DRAGONHIDE_CHAPS_TRIM_GOLD),
    GreenDhideChapsT(ItemID.DRAGONHIDE_CHAPS_TRIM),
    LeatherBodyG(ItemID.LEATHER_ARMOUR_TRIM_GOLD),
    LeatherChapsG(ItemID.LEATHER_CHAPS_TRIM_GOLD),

    // Clue Scroll - Magic Armor
    BlueSkirtG(ItemID.BLUE_SKIRT_TRIM_GOLD),
    BlueSkirtT(ItemID.BLUE_SKIRT_TRIM),
    BlueWizardRobeG(ItemID.WIZARDS_ROBE_TRIM_GOLD),
    BlueWizardRobeT(ItemID.WIZARDS_ROBE_TRIM),
    BlueWizardHatG(ItemID.BLUEWIZHAT_TRIM_GOLD),
    BlueWizardHatT(ItemID.BLUEWIZHAT_TRIM),
    BlackSkirtG(ItemID.BLACK_SKIRT_GOLD),
    BlackSkirtT(ItemID.BLACK_SKIRT_TRIM),
    BlackWizardRobeG(ItemID.BLACK_WIZARDS_ROBE_GOLD),
    BlackWizardRobeT(ItemID.BLACK_WIZARDS_ROBE_TRIM),
    BlackWizardHatG(ItemID.BLACKWIZHAT_GOLD),
    BlackWizardHatT(ItemID.BLACKWIZHAT_TRIM),

    // Clue Scroll - Prayer Armor
    MonksRobeTopG(ItemID.MONK_ROBETOP_GOLD),
    MonksRobeG(ItemID.MONK_ROBEBOTTOM_GOLD),

    // Item Sets
    BronzeLegsTrim(ItemID.SET_BRONZE_LEGS_TRIM),
    BronzeSkirtTrim(ItemID.SET_BRONZE_SKIRT_TRIM),
    BronzeLegsGold(ItemID.SET_BRONZE_LEGS_GOLD),
    BronzeSkirtGold(ItemID.SET_BRONZE_SKIRT_GOLD),
    IronLegsTrim(ItemID.SET_IRON_LEGS_TRIM),
    IronSkirtTrim(ItemID.SET_IRON_SKIRT_TRIM),
    IronLegsGold(ItemID.SET_IRON_LEGS_GOLD),
    IronSkirtGold(ItemID.SET_IRON_SKIRT_GOLD),
    SteelLegsTrim(ItemID.SET_STEEL_LEGS_TRIM),
    SteelSkirtTrim(ItemID.SET_STEEL_SKIRT_TRIM),
    SteelLegsGold(ItemID.SET_STEEL_LEGS_GOLD),
    SteelSkirtGold(ItemID.SET_STEEL_SKIRT_GOLD),
    BlackLegsTrim(ItemID.SET_BLACK_LEGS_TRIM),
    BlackSkirtTrim(ItemID.SET_BLACK_SKIRT_TRIM),
    BlackLegsGold(ItemID.SET_BLACK_LEGS_GOLD),
    BlackSkirtGold(ItemID.SET_BLACK_SKIRT_GOLD),
    MithrilLegsTrim(ItemID.SET_MITHRIL_LEGS_TRIM),
    MithrilSkirtTrim(ItemID.SET_MITHRIL_SKIRT_TRIM),
    MithrilLegsGold(ItemID.SET_MITHRIL_LEGS_GOLD),
    MithrilSkirtGold(ItemID.SET_MITHRIL_SKIRT_GOLD),
    AdamantLegsTrim(ItemID.SET_ADAMANT_LEGS_TRIM),
    AdamantSkirtTrim(ItemID.SET_ADAMANT_SKIRT_TRIM),
    AdamantLegsGold(ItemID.SET_ADAMANT_LEGS_GOLD),
    AdamantSkirtGold(ItemID.SET_ADAMANT_SKIRT_GOLD),
    RuneLegsTrim(ItemID.SET_RUNE_LEGS_TRIM),
    RuneSkirtTrim(ItemID.SET_RUNE_SKIRT_TRIM),
    RuneLegsGold(ItemID.SET_RUNE_LEGS_GOLD),
    RuneSkirtGold(ItemID.SET_RUNE_SKIRT_GOLD),
    GildedArmourLegs(ItemID.SET_RUNE_LEGS_GOLDPLATE),
    GildedArmourSkirt(ItemID.SET_RUNE_SKIRT_GOLDPLATE),
    SaradominLegs(ItemID.SET_RUNE_LEGS_SARADOMIN),
    SaradominSkirt(ItemID.SET_RUNE_SKIRT_SARADOMIN),
    ZamorakLegs(ItemID.SET_RUNE_LEGS_ZAMORAK),
    ZamorakSkirt(ItemID.SET_RUNE_SKIRT_ZAMORAK),
    GuthixLegs(ItemID.SET_RUNE_LEGS_GUTHIX),
    GuthixSkirt(ItemID.SET_RUNE_SKIRT_GUTHIX),
    ArmadylLegs(ItemID.SET_RUNE_LEGS_ARMADYL),
    ArmadylSkirt(ItemID.SET_RUNE_SKIRT_ARMADYL),
    BandosLegs(ItemID.SET_RUNE_LEGS_BANDOS),
    BandosSkirt(ItemID.SET_RUNE_SKIRT_BANDOS),
    AncientLegs(ItemID.SET_RUNE_LEGS_ANCIENT),
    AncientSkirt(ItemID.SET_RUNE_SKIRT_ANCIENT),
    GildedDragonhide(ItemID.SET_DHIDE_GILDED),
;

    @Getter
    private final int id;
    private static final Set<Integer> ids;
    static {
        Set<Integer> idsBuilder = new HashSet<>();
        for (FreeToPlayBlockedItems as : FreeToPlayBlockedItems.values()) {
            idsBuilder.add(as.getId());
        }
        ids = Collections.unmodifiableSet(idsBuilder);
    }

    FreeToPlayBlockedItems(int id) {
        this.id = id;
    }

    /**
     * Returns an unmodifiable set of all item set item IDs.
     */
    public static Set<Integer> getFreeToPlayTradeOnlyItemIds() {
        return ids;
    }

    /**
     * Checks if the given item ID is one of the items that cannot be self-sufficiently
     * obtained on a free to play server.
     *
     * @param id the item id to check.
     * @return true if the id cannot be self-sufficiently obtained, false otherwise.
     */
    public static boolean isFreeToPlayTradeOnlyItem(int id) {
        return getFreeToPlayTradeOnlyItemIds().contains(id);
    }
}

package com.chanceman.filters;

import lombok.Getter;

import java.util.Collections;
import java.util.HashSet;
import java.util.Set;
import net.runelite.api.gameval.ItemID;


public final class BlockedItems {
    @Getter private static final Set<Integer> BLOCKED_ITEMS;

    static {
        Set<Integer> blocked = new HashSet<>();
        //Dead Man Mode
        blocked.add(ItemID.DEADMAN_BLIGHTED_AGS); // Corrupted Armadyl Godsword
        blocked.add(ItemID.DEADMAN_BLIGHTED_DARK_BOW); // Corrupted Dark Bow
        blocked.add(ItemID.DEADMAN_BLIGHTED_DRAGON_CLAWS); // Corrupted Dragon Claws
        blocked.add(ItemID.DEADMAN_BLIGHTED_TWISTED_BOW); // Corrupted Twisted Bow
        blocked.add(ItemID.DEADMAN_BLIGHTED_VOIDWAKER); // Corrupted Voidwaker
        blocked.add(ItemID.DEADMAN_BLIGHTED_VOLATILE_STAFF); // Corrupted Volatile Nightmare Staff
        blocked.add(ItemID.DEADMAN_BLIGHTED_TUMEKENS_SHADOW_UNCHARGED); // Corrupted Tumeken's Shadow (uncharged)
        blocked.add(ItemID.DEADMAN_BLIGHTED_SCYTHE_OF_VITUR_UNCHARGED);// Corrupted Scythe of Vitur (uncharged)
        blocked.add(ItemID.DEADMAN_NIMBLENESS_CHARM); // Nimbleness Charm
        blocked.add(ItemID.DEADMAN_STOCKPILING_CHARM); // Stockpiling Charm
        blocked.add(ItemID.DEADMAN_ACCUMULATION_CHARM); // Accumulation Charm
        blocked.add(ItemID.DEADMAN_VULNERABILITY_CHARM); // Vulnerability Charm
        blocked.add(ItemID.DEADMAN_2024_HOME_TELEPORT_SCROLL); // Armageddon Teleport Scroll
        blocked.add(ItemID.DEADMAN_2024_CAPE_ORNAMENT_SCROLL); // Armageddon Cape Fabric
        blocked.add(ItemID.DEADMAN_2024_WEAPON_ORNAMENT_SCROLL); // Armageddon Weapon Scroll
        blocked.add(ItemID.DEADMAN_RUG); // Armageddon Rug
        blocked.add(ItemID.DEADMAN1DOSEOVERLOAD); // Blighted Overload (1)
        blocked.add(ItemID.DEADMAN2DOSEOVERLOAD); // Blighted Overload (2)
        blocked.add(ItemID.DEADMAN3DOSEOVERLOAD); // Blighted Overload (3)
        blocked.add(ItemID.DEADMAN4DOSEOVERLOAD); // Blighted Overload (4)
        blocked.add(ItemID.DEADMAN_OVERLOAD_CHITIN); // Chitin
        blocked.add(ItemID.DEADMAN_STARTER_BOW); // Starter Bow
        blocked.add(ItemID.DEADMAN_STARTER_STAFF); // Starter Staff
        blocked.add(ItemID.DEADMAN_STARTER_SWORD); // Starter Sword
        blocked.add(ItemID.MAGIC_ROCK_OF_WEAPONS); // Trinket of Advanced Weaponry
        blocked.add(ItemID.MAGIC_ROCK_OF_FAIRIES); // Trinket of Fairies
        blocked.add(ItemID.MAGIC_ROCK_OF_UNDEAD); // Trinket of Undead
        blocked.add(ItemID.MAGIC_ROCK_OF_VENGEANCE); // Trinket of Vengeance
        blocked.add(ItemID.MORRIGANS_COIF); // Morrigan's Coif
        blocked.add(ItemID.MORRIGANS_LEATHER_BODY); // Morrigan's Leather Body
        blocked.add(ItemID.MORRIGANS_LEATHER_CHAPS); // Morrigan's Leather Chaps
        blocked.add(ItemID.MORRIGANS_THROWNAXE); // Morrigan's Thrown axe
        blocked.add(ItemID.MORRIGANS_JAVELIN); // Morrigan's Javelin
        blocked.add(ItemID.STATIUS_FULL_HELM); // Statius' Full Helm
        blocked.add(ItemID.STATIUS_PLATEBODY); // Statius' Platebody
        blocked.add(ItemID.STATIUS_PLATELEGS); // Statius' Platelegs
        blocked.add(ItemID.STATIUS_WARHAMMER); // Statius' Warhammer
        blocked.add(ItemID.VESTAS_CHAINBODY); // Vesta's Chainbody
        blocked.add(ItemID.VESTAS_PLATESKIRT); // Vesta's Plateskirt
        blocked.add(ItemID.VESTAS_LONGSWORD); // Vesta's Longsword
        blocked.add(ItemID.VESTAS_SPEAR); // Vesta's Spear
        blocked.add(ItemID.ZURIELS_HOOD); // Zuriel's Hood
        blocked.add(ItemID.ZURIELS_ROBE_TOP); // Zuriel's Robe Top
        blocked.add(ItemID.ZURIELS_ROBE_BOTTOM); // Zuriel's Robe Bottom
        blocked.add(ItemID.ZURIELS_STAFF); // Zuriel's Staff
        blocked.add(ItemID.SIGIL_OF_ADROIT_UNATTUNED); // Sigil Of Adroit
        blocked.add(ItemID.SIGIL_OF_AGGRESSION_UNATTUNED); // Sigil Of Aggression
        blocked.add(ItemID.SIGIL_OF_AGILE_FORTUNE_UNATTUNED); // Sigil Of Agile Fortune
        blocked.add(ItemID.SIGIL_OF_ARCANE_SWIFTNESS_UNATTUNED); // Sigil Of Arcane Swiftness
        blocked.add(ItemID.SIGIL_OF_BARROWS_UNATTUNED); // Sigil Of Barrows
        blocked.add(ItemID.SIGIL_OF_BINDING_UNATTUNED); // Sigil Of Binding
        blocked.add(ItemID.SIGIL_OF_CONSISTENCY_UNATTUNED); // Sigil Of Consistency
        blocked.add(ItemID.SIGIL_OF_DECEPTION_UNATTUNED); // Sigil Of Deception
        blocked.add(ItemID.SIGIL_OF_DEFT_STRIKES_UNATTUNED); // Sigil Of Deft Strikes
        blocked.add(ItemID.SIGIL_OF_DEVOTION_UNATTUNED); // Sigil Of Devotion
        blocked.add(ItemID.SIGIL_OF_ENHANCED_HARVEST_UNATTUNED); // Sigil Of Enhanced Harvest
        blocked.add(ItemID.SIGIL_OF_ESCAPING_UNATTUNED); // Sigil Of Escaping
        blocked.add(ItemID.SIGIL_OF_EXAGGERATION_UNATTUNED); // Sigil Of Exaggeration
        blocked.add(ItemID.SIGIL_OF_FAITH_UNATTUNED); // Sigil Of Faith
        blocked.add(ItemID.SIGIL_OF_FINALITY_UNATTUNED); // Sigil Of Finality
        blocked.add(ItemID.SIGIL_OF_FORTIFICATION_UNATTUNED); // Sigil Of Fortification
        blocked.add(ItemID.SIGIL_OF_FREEDOM_UNATTUNED); // Sigil Of Freedom
        blocked.add(ItemID.SIGIL_OF_GARMENTS_UNATTUNED); // Sigil Of Garments
        blocked.add(ItemID.SIGIL_OF_GUNSLINGER_UNATTUNED); // Sigil Of Gunslinger
        blocked.add(ItemID.SIGIL_OF_HOARDING_UNATTUNED); // Sigil Of Hoarding
        blocked.add(ItemID.SIGIL_OF_LAST_RECALL_UNATTUNED); // Sigil Of Last Recall
        blocked.add(ItemID.SIGIL_OF_LITHE_UNATTUNED); // Sigil Of Lithe
        blocked.add(ItemID.SIGIL_OF_METICULOUSNESS_UNATTUNED); // Sigil Of Meticulousness
        blocked.add(ItemID.SIGIL_OF_MOBILITY_UNATTUNED); // Sigil Of Mobility
        blocked.add(ItemID.SIGIL_OF_NATURE_UNATTUNED); // Sigil Of Nature
        blocked.add(ItemID.SIGIL_OF_ONSLAUGHT_UNATTUNED); // Sigil Of Onslaught
        blocked.add(ItemID.SIGIL_OF_PIOUS_PROTECTION_UNATTUNED); // Sigil Of Pious Protection
        blocked.add(ItemID.SIGIL_OF_PRECISION_UNATTUNED); // Sigil Of Precision
        blocked.add(ItemID.SIGIL_OF_PRESERVATION_UNATTUNED); // Sigil Of Preservation
        blocked.add(ItemID.SIGIL_OF_PROSPERITY_UNATTUNED); // Sigil Of Prosperity
        blocked.add(ItemID.SIGIL_OF_RAMPAGE_UNATTUNED); // Sigil Of Rampage
        blocked.add(ItemID.SIGIL_OF_RAMPART_UNATTUNED); // Sigil Of Rampart
        blocked.add(ItemID.SIGIL_OF_REMOTE_STORAGE_UNATTUNED); // Sigil Of Remote Storage
        blocked.add(ItemID.SIGIL_OF_RESILIENCE_UNATTUNED); // Sigil Of Resilience
        blocked.add(ItemID.SIGIL_OF_RESISTANCE_UNATTUNED); // Sigil Of Resistance
        blocked.add(ItemID.SIGIL_OF_RESTORATION_UNATTUNED); // Sigil Of Restoration
        blocked.add(ItemID.SIGIL_OF_REVOKED_LIMITATION_UNATTUNED); // Sigil Of Revoked Limitations
        blocked.add(ItemID.SIGIL_OF_SLAUGHTER_UNATTUNED); // Sigil Of Slaughter
        blocked.add(ItemID.SIGIL_OF_SPECIALISED_STRIKES_UNATTUNED); // Sigil Of Specialised Strikes
        blocked.add(ItemID.SIGIL_OF_STAMINA_UNATTUNED); // Sigil Of Stamina
        blocked.add(ItemID.SIGIL_OF_STORAGE_UNATTUNED); // Sigil Of Storage
        blocked.add(ItemID.SIGIL_OF_SUPREME_STAMINA_UNATTUNED); // Sigil Of Supreme Stamina
        blocked.add(ItemID.SIGIL_OF_SUSTENANCE_UNATTUNED); // Sigil Of Sustenance
        blocked.add(ItemID.SIGIL_OF_SWASHBUCKLER_UNATTUNED); // Sigil Of Swashbuckler
        blocked.add(ItemID.SIGIL_OF_THE_ABYSS_UNATTUNED); // Sigil Of The Abyss
        blocked.add(ItemID.SIGIL_OF_THE_ALCHEMIST_UNATTUNED); // Sigil Of The Alchemist
        blocked.add(ItemID.SIGIL_OF_THE_ALCHEMANIAC_UNATTUNED); // Sigil Of The Alchemaniac
        blocked.add(ItemID.SIGIL_OF_THE_AUGMENTED_THRALL_UNATTUNED); // Sigil Of The Augmented Thrall
        blocked.add(ItemID.SIGIL_OF_THE_BARBARIANS_UNATTUNED); // Sigil Of The Barbarians
        blocked.add(ItemID.SIGIL_OF_THE_BLOODHOUND_UNATTUNED); // Sigil Of The Bloodhound
        blocked.add(ItemID.SIGIL_OF_THE_CHEF_UNATTUNED); // Sigil Of The Chef
        blocked.add(ItemID.SIGIL_OF_THE_CRAFTER_UNATTUNED); // Sigil Of The Craftsman
        blocked.add(ItemID.SIGIL_OF_THE_DWARVES_UNATTUNED); // Sigil Of The Dwarves
        blocked.add(ItemID.SIGIL_OF_THE_ELVES_UNATTUNED); // Sigil Of The Elves
        blocked.add(ItemID.SIGIL_OF_THE_ETERNAL_JEWELLER_UNATTUNED); // Sigil Of The Eternal Jeweller
        blocked.add(ItemID.SIGIL_OF_THE_FERAL_FIGHTER_UNATTUNED); // Sigil Of The Feral Fighter
        blocked.add(ItemID.SIGIL_OF_THE_FLETCHER_UNATTUNED); // Sigil Of The Fletcher
        blocked.add(ItemID.SIGIL_OF_THE_FOOD_MASTER_UNATTUNED); // Sigil Of The Food Master
        blocked.add(ItemID.SIGIL_OF_THE_FORAGER_UNATTUNED); // Sigil Of The Forger
        blocked.add(ItemID.SIGIL_OF_THE_FORMIDABLE_FIGHTER_UNATTUNED); // Sigil Of The Formidable Fighter
        blocked.add(ItemID.SIGIL_OF_THE_FORTUNE_FARMER_UNATTUNED); // Sigil Of The Fortune Farmer
        blocked.add(ItemID.SIGIL_OF_THE_GNOMES_UNATTUNED); // Sigil Of The Gnomes
        blocked.add(ItemID.SIGIL_OF_THE_GUARDIAN_ANGEL_UNATTUNED); // Sigil Of The Guardian Angel
        blocked.add(ItemID.SIGIL_OF_THE_HUNTER_UNATTUNED); // Sigil Of The Hunter
        blocked.add(ItemID.SIGIL_OF_THE_INFERNAL_CHEF_UNATTUNED); // Sigil Of The Infernal Chef
        blocked.add(ItemID.SIGIL_OF_THE_INFERNAL_SMITH_UNATTUNED); // Sigil Of The Infernal Smith
        blocked.add(ItemID.SIGIL_OF_THE_LIGHTBEARER_UNATTUNED); // Sigil Of The Lighterbearer
        blocked.add(ItemID.SIGIL_OF_THE_MENACING_MAGE_UNATTUNED); // Sigil Of The Menacing Mage
        blocked.add(ItemID.SIGIL_OF_THE_METICULOUS_MAGE_UNATTUNED); // Sigil Of The Meticulous Mage
        blocked.add(ItemID.SIGIL_OF_THE_NINJA_UNATTUNED); // Sigil Of The Ninja
        blocked.add(ItemID.SIGIL_OF_THE_PORCUPINE_UNATTUNED); // Sigil Of The Porcupine
        blocked.add(ItemID.SIGIL_OF_THE_POTION_MASTER_UNATTUNED); // Sigil Of The Potion Master
        blocked.add(ItemID.SIGIL_OF_THE_RIGOROUS_RANGER_UNATTUNED); // Sigil Of The Rigorous Ranger
        blocked.add(ItemID.SIGIL_OF_THE_RUTHLESS_RANGER_UNATTUNED); // Sigil Of The Ruthless Ranger
        blocked.add(ItemID.SIGIL_OF_THE_SERPENT_UNATTUNED); // Sigil Of The Serpent
        blocked.add(ItemID.SIGIL_OF_THE_SKILLER_UNATTUNED); // Sigil Of The Skiller
        blocked.add(ItemID.SIGIL_OF_THE_SMITH_UNATTUNED); // Sigil Of The Smith
        blocked.add(ItemID.SIGIL_OF_THE_TREASURE_HUNTER_UNATTUNED); // Sigil Of The Treasure Hunter
        blocked.add(ItemID.SIGIL_OF_THE_WELL_FED_UNATTUNED); // Sigil Of The Well-Fed
        blocked.add(ItemID.SIGIL_OF_TITANIUM_UNATTUNED); // Sigil Of Titanium
        blocked.add(ItemID.SIGIL_OF_VERSATILITY_UNATTUNED); // Sigil Of Versatility
        blocked.add(ItemID.SIGIL_OF_WOODCRAFT_UNATTUNED); // Sigil Of Woodcraft

        // Twisted Leagues Rewards
        blocked.add(ItemID.TWISTED_BANNER); // Twisted Banner
        blocked.add(ItemID.TWISTED_BLUEPRINTS); // Twisted Blueprints
        blocked.add(ItemID.TWISTED_CANE); // Twisted Cane
        blocked.add(ItemID.TWISTED_RELIC_HUNTER_HAT_T1); // Twisted Hat (t1)
        blocked.add(ItemID.TWISTED_RELIC_HUNTER_HAT_T2); // Twisted Hat (t2)
        blocked.add(ItemID.TWISTED_RELIC_HUNTER_HAT_T3); // Twisted Hat (t3)
        blocked.add(ItemID.TWISTED_HORNS); // Twisted Horns
        blocked.add(ItemID.TWISTED_RELIC_HUNTER_TOP_T1); // Twisted Coat (t1)
        blocked.add(ItemID.TWISTED_RELIC_HUNTER_TOP_T2); // Twisted Coat (t2)
        blocked.add(ItemID.TWISTED_RELIC_HUNTER_TOP_T3); // Twisted Coat (t3)
        blocked.add(ItemID.TWISTED_RELIC_HUNTER_LEGS_T1); // Twisted Trouser (t1)
        blocked.add(ItemID.TWISTED_RELIC_HUNTER_LEGS_T2); // Twisted Trouser (t2)
        blocked.add(ItemID.TWISTED_RELIC_HUNTER_LEGS_T3); // Twisted Trouser (t3)
        blocked.add(ItemID.TWISTED_RELIC_HUNTER_BOOTS_T1); // Twisted Boots (t1)
        blocked.add(ItemID.TWISTED_RELIC_HUNTER_BOOTS_T2); // Twisted Boots (t2)
        blocked.add(ItemID.TWISTED_RELIC_HUNTER_BOOTS_T3); // Twisted Boots (t3)
        blocked.add(ItemID.SET_TWISTED_RELICHUNTER_T1); // Twisted Relic Hunter (t1) Armour Set
        blocked.add(ItemID.SET_TWISTED_RELICHUNTER_T2); // Twisted Relic Hunter (t2) Armour Set
        blocked.add(ItemID.SET_TWISTED_RELICHUNTER_T3); // Twisted Relic Hunter (t3) Armour Set
        blocked.add(ItemID.TWISTED_HOME_TELEPORT_SCROLL); // Twisted Teleport Scroll

        // Trailblazer Leagues Rewards
        blocked.add(ItemID.TRAILBLAZER_BANNER); // Trailblazer Banner
        blocked.add(ItemID.TRAILBLAZER_HOME_TELEPORT_SCROLL); // Trailblazer Teleport Scroll
        blocked.add(ItemID.TRAILBLAZER_TOOL_ORNAMENTKIT); // Trailblazer Tool Ornament Kit
        blocked.add(ItemID.TRAILBLAZER_GRACEFUL_KIT); // Trailblazer Graceful Ornament Kit
        blocked.add(ItemID.TRAILBLAZER_STATUE); // Trailblazer Globe
        blocked.add(ItemID.TRAILBLAZER_RUG); // Trailblazer Rug
        blocked.add(ItemID.TRAILBLAZER_CANE); // Trailblazer Cane
        blocked.add(ItemID.TRAILBLAZER_RELIC_HUNTER_HOOD_T1); // Trailblazer Hood (t1)
        blocked.add(ItemID.TRAILBLAZER_RELIC_HUNTER_HOOD_T2); // Trailblazer Hood (t2)
        blocked.add(ItemID.TRAILBLAZER_RELIC_HUNTER_HOOD_T3); // Trailblazer Hood (t3)
        blocked.add(ItemID.TRAILBLAZER_RELIC_HUNTER_TOP_T1); // Trailblazer Top (t1)
        blocked.add(ItemID.TRAILBLAZER_RELIC_HUNTER_TOP_T2); // Trailblazer Top (t2)
        blocked.add(ItemID.TRAILBLAZER_RELIC_HUNTER_TOP_T3); // Trailblazer Top (t3)
        blocked.add(ItemID.TRAILBLAZER_RELIC_HUNTER_LEGS_T1); // Trailblazer Trousers (t1)
        blocked.add(ItemID.TRAILBLAZER_RELIC_HUNTER_LEGS_T2); // Trailblazer Trousers (t2)
        blocked.add(ItemID.TRAILBLAZER_RELIC_HUNTER_LEGS_T3); // Trailblazer Trouser (t3)
        blocked.add(ItemID.TRAILBLAZER_RELIC_HUNTER_BOOTS_T1); // Trailblazer Boots (t1)
        blocked.add(ItemID.TRAILBLAZER_RELIC_HUNTER_BOOTS_T2); // Trailblazer Boots (t2)
        blocked.add(ItemID.TRAILBLAZER_RELIC_HUNTER_BOOTS_T3); // Trailblazer Boots (t3)
        blocked.add(ItemID.SET_TRAILBLAZER_RELICHUNTER_T1); // Trailblazer Relic Hunter (t1) Armour Set
        blocked.add(ItemID.SET_TRAILBLAZER_RELICHUNTER_T2); // Trailblazer Relic Hunter (t2) Armour Set
        blocked.add(ItemID.SET_TRAILBLAZER_RELICHUNTER_T3); // Trailblazer Relic Hunter (t3) Armour Set

        // Shattered Leagues Rewards
        blocked.add(ItemID.LEAGUE_3_BANNER); // Shattered Banner
        blocked.add(ItemID.LEAGUE_3_HOME_TELEPORT_SCROLL); // Shattered Teleport Scroll
        blocked.add(ItemID.LEAGUE_3_CANE); // Shattered Cane
        blocked.add(ItemID.LEAGUE_3_WEAPON_VARIETY_PACK); // Shattered Relics Variety Ornament Kit
        blocked.add(ItemID.LEAGUE_3_VOID_KIT); // Shattered Relics Void Ornament Kit
        blocked.add(ItemID.LEAGUE_3_MYSTIC_ORNAMENT_PACK); // Shattered Relics Mystic Ornament Kit
        blocked.add(ItemID.LEAGUE_3_MULTICANNON_PACK); // Shattered Cannon Ornament Kit
        blocked.add(ItemID.LEAGUE_3_RELIC_HUNTER_HOOD_T1); // Shattered Hood (t1)
        blocked.add(ItemID.LEAGUE_3_RELIC_HUNTER_HOOD_T2); // Shattered Hood (t2)
        blocked.add(ItemID.LEAGUE_3_RELIC_HUNTER_HOOD_T3); // Shattered Hood (t3)
        blocked.add(ItemID.LEAGUE_3_RELIC_HUNTER_TOP_T1); // Shattered Top (t1)
        blocked.add(ItemID.LEAGUE_3_RELIC_HUNTER_TOP_T2); // Shattered Top (t2)
        blocked.add(ItemID.LEAGUE_3_RELIC_HUNTER_TOP_T3); // Shattered Top (t3)
        blocked.add(ItemID.LEAGUE_3_RELIC_HUNTER_LEGS_T1); // Shattered Trousers (t1)
        blocked.add(ItemID.LEAGUE_3_RELIC_HUNTER_LEGS_T2); // Shattered Trousers (t2)
        blocked.add(ItemID.LEAGUE_3_RELIC_HUNTER_LEGS_T3); // Shattered Trousers (t3)
        blocked.add(ItemID.LEAGUE_3_RELIC_HUNTER_BOOTS_T1); // Shattered Boots (t1)
        blocked.add(ItemID.LEAGUE_3_RELIC_HUNTER_BOOTS_T2); // Shattered Boots (t2)
        blocked.add(ItemID.LEAGUE_3_RELIC_HUNTER_BOOTS_T3); // Shattered Boots (t3)
        blocked.add(ItemID.SET_LEAGUE_3_RELICHUNTER_T1); // Shattered Relic Hunter (t1) Armour Set
        blocked.add(ItemID.SET_LEAGUE_3_RELICHUNTER_T2); // Shattered Relic Hunter (t2) Armour Set
        blocked.add(ItemID.SET_LEAGUE_3_RELICHUNTER_T3); // Shattered Relic Hunter (t3) Armour Set

        // Trailblazer Reloaded Leagues Rewards
        blocked.add(ItemID.LEAGUE_4_BANNER); // Trailblazer Reloaded Banner
        blocked.add(ItemID.LEAGUE_4_HOME_TELEPORT_SCROLL); // Trailblazer Reloaded Home Teleport Scroll
        blocked.add(ItemID.LEAGUE_4_DEATH_SCROLL); // Trailblazer Reloaded Death Scroll
        blocked.add(ItemID.LEAGUE_4_ALCHEMY_SCROLL); // Trailblazer Reloaded Alchemy Scroll
        blocked.add(ItemID.LEAGUE_4_VENGEANCE_SCROLL); // Trailblazer Reloaded Vengeance Scroll
        blocked.add(ItemID.LEAGUE_4_REJUVINATION_POOL_SCROLL); // Trailblazer Reloaded Rejuvenation Pool Scroll
        blocked.add(ItemID.LEAGUE_4_TORCH); // Trailblazer Reloaded Torch
        blocked.add(ItemID.TOXIC_BLOWPIPE_ORNAMENT_KIT); // Trailblazer Reloaded Blowpipe Ornament Kit
        blocked.add(ItemID.DINHS_BULWARK_ORNAMENT_KIT); // Trailblazer Reloaded Banner Bulwark Ornament Kit
        blocked.add(ItemID.LEAGUE_4_RELIC_HUNTER_HAT_T1); // Trailblazer Reloaded Headband (t1)
        blocked.add(ItemID.LEAGUE_4_RELIC_HUNTER_HAT_T2); // Trailblazer Reloaded Headband (t2)
        blocked.add(ItemID.LEAGUE_4_RELIC_HUNTER_HAT_T3); // Trailblazer Reloaded Headband (t3)
        blocked.add(ItemID.LEAGUE_4_RELIC_HUNTER_TOP_T1); // Trailblazer Reloaded Top (t1)
        blocked.add(ItemID.LEAGUE_4_RELIC_HUNTER_TOP_T2); // Trailblazer Reloaded Top (t2)
        blocked.add(ItemID.LEAGUE_4_RELIC_HUNTER_TOP_T3); // Trailblazer Reloaded Top (t3)
        blocked.add(ItemID.LEAGUE_4_RELIC_HUNTER_LEGS_T1); // Trailblazer Reloaded Trousers (t1)
        blocked.add(ItemID.LEAGUE_4_RELIC_HUNTER_LEGS_T2); // Trailblazer Reloaded Trousers (t2)
        blocked.add(ItemID.LEAGUE_4_RELIC_HUNTER_LEGS_T3); // Trailblazer Reloaded Trousers (t3)
        blocked.add(ItemID.LEAGUE_4_RELIC_HUNTER_BOOTS_T1); // Trailblazer Reloaded Boots (t1)
        blocked.add(ItemID.LEAGUE_4_RELIC_HUNTER_BOOTS_T2); // Trailblazer Reloaded Boots (t2)
        blocked.add(ItemID.LEAGUE_4_RELIC_HUNTER_BOOTS_T3); // Trailblazer Reloaded Boots (t3)
        blocked.add(ItemID.SET_LEAGUE_4_RELICHUNTER_T1); // Trailblazer Reloaded Relic Hunter (t1) Armour Set
        blocked.add(ItemID.SET_LEAGUE_4_RELICHUNTER_T2); // Trailblazer Reloaded Relic Hunter (t2) Armour Set
        blocked.add(ItemID.SET_LEAGUE_4_RELICHUNTER_T3); // Trailblazer Reloaded Relic Hunter (t3) Armour Set

        // Raging Echoes Leagues Rewards
        blocked.add(ItemID.LEAGUE_5_BANNER); // Raging Echoes
        blocked.add(ItemID.LEAGUE_5_RUG); // Raging Echoes Rug
        blocked.add(ItemID.LEAGUE_5_CURTAINS); // Raging Echoes Curtains
        blocked.add(ItemID.LEAGUE_5_SPIRIT_TREE_SCROLL); // Raging Echoes Spirit Tree Scroll
        blocked.add(ItemID.LEAGUE_5_NEXUS_SCROLL); // Raging Echoes Portal Nexus Scroll
        blocked.add(ItemID.LEAGUE_5_SCRYING_SCROLL); // Raging Echoes Scrying Pool Scroll
        blocked.add(ItemID.LEAGUE_5_PORTAL_SCROLL); // Raging Echoes Portal Scroll
        blocked.add(ItemID.LEAGUE_5_HOME_TELEPORT_SCROLL); // Raging Echoes Home Teleport
        blocked.add(ItemID.LEAGUE_5_DEATH_SCROLL); // Raging Echoes Death Scroll
        blocked.add(ItemID.LEAGUE_5_CONTACT_SCROLL); // Raging Echoes NPC Contact Scroll
        blocked.add(ItemID.LEAGUE5_RELIC_HUNTER_CANE); // Raging Echoes Cane
        blocked.add(ItemID.BARROWS_AHRIM_ORNAMENT_KIT); // Echo Ahrim's Robes Ornament Kit
        blocked.add(ItemID.BARROWS_AHRIM_WEAPON); // Echo Ahrim's Staff Ornament Kit
        blocked.add(ItemID.VIRTUS_ORNAMENT_KIT); // Echo Virtus Robes Ornament Kit
        blocked.add(ItemID.VENATOR_BOW_ORNAMENT_KIT); // Echo Venator Bow Ornament Kit
        blocked.add(ItemID.LEAGUE5_RELIC_HUNTER_HAT_T1); // Raging Echoes Hat (t1)
        blocked.add(ItemID.LEAGUE5_RELIC_HUNTER_HAT_T2); // Raging Echoes Hat (t2)
        blocked.add(ItemID.LEAGUE5_RELIC_HUNTER_HAT_T3); // Raging Echoes Hat (t3)
        blocked.add(ItemID.LEAGUE5_RELIC_HUNTER_TOP_T1); // Raging Echoes Top (t1)
        blocked.add(ItemID.LEAGUE5_RELIC_HUNTER_TOP_T2); // Raging Echoes Top (t2)
        blocked.add(ItemID.LEAGUE5_RELIC_HUNTER_TOP_T3); // Raging Echoes Top (t3)
        blocked.add(ItemID.LEAGUE5_RELIC_HUNTER_LEGS_T1); // Raging Echoes Robeskirt (t1)
        blocked.add(ItemID.LEAGUE5_RELIC_HUNTER_LEGS_T2); // Raging Echoes Robeskirt (t2)
        blocked.add(ItemID.LEAGUE5_RELIC_HUNTER_LEGS_T3); // Raging Echoes Robeskirt (t3)
        blocked.add(ItemID.LEAGUE5_RELIC_HUNTER_BOOTS_T1); // Raging Echoes Boots (t1)
        blocked.add(ItemID.LEAGUE5_RELIC_HUNTER_BOOTS_T2); // Raging Echoes Boots (t2)
        blocked.add(ItemID.LEAGUE5_RELIC_HUNTER_BOOTS_T3); // Raging Echoes Boots (t3)
        blocked.add(ItemID.SET_LEAGUE_5_RELICHUNTER_T1); // Raging Echoes Relic Hunter (t1) Armour Set
        blocked.add(ItemID.SET_LEAGUE_5_RELICHUNTER_T2); // Raging Echoes Relic Hunter (t2) Armour Set
        blocked.add(ItemID.SET_LEAGUE_5_RELICHUNTER_T3); // Raging Echoes Relic Hunter (t3) Armour Set

        // Unobtainable Items
        blocked.add(ItemID.CHOMPY_COOKED); // Cooked Chompy (roasted)
        blocked.add(ItemID.CHICKENQUEST_CORNFLOUR); // Cornflour
        blocked.add(ItemID.POH_FLATPACK_CRYSTALBALL1); // Crystal Ball (FLATPACK)
        blocked.add(ItemID.POH_FLATPACK_CRYSTALBALL2); // Elemental Sphere (FLATPACK)
        blocked.add(ItemID.POH_FLATPACK_CRYSTALBALL3); // Crystal Of Power (FLATPACK)
        blocked.add(ItemID.POH_FLATPACK_GLOBE1); // Globe (FLATPACK)
        blocked.add(ItemID.POH_FLATPACK_GLOBE2); // Ornamental Globe (FLATPACK)
        blocked.add(ItemID.POH_FLATPACK_GLOBE3); // Lunar Globe (FLATPACK)
        blocked.add(ItemID.POH_FLATPACK_GLOBE4); // Celestial Globe (FLATPACK)
        blocked.add(ItemID.POH_FLATPACK_GLOBE5); // Armillary Globe (FLATPACK)
        blocked.add(ItemID.POH_FLATPACK_GLOBE6); // Small Orrery (FLATPACK)
        blocked.add(ItemID.POH_FLATPACK_GLOBE7); // Large Orrery (FLATPACK)
        blocked.add(ItemID.POH_FLATPACK_TELESCOPE1); // Oak Telescope (FLATPACK)
        blocked.add(ItemID.POH_FLATPACK_TELESCOPE2); // Teak Telescope (FLATPACK)
        blocked.add(ItemID.POH_FLATPACK_TELESCOPE3); // Mahogany (FLATPACK)
        blocked.add(ItemID.UNFINISHED_WORM_CRUNCHIES); // Rock-Climbing Boots
        blocked.add(ItemID.OSB9_REPORT); // Osman's Report
        blocked.add(ItemID.FEUD_KARIDIAN_FAKEBEARD_AND_HAT); // Karidian Disguise
        blocked.add(ItemID.POH_FLATPACK_LECTURN1); // Oak Lectern (FLATPACK)
        blocked.add(ItemID.POH_FLATPACK_LECTURN2); // Eagle Lectern (FLATPACK)
        blocked.add(ItemID.POH_FLATPACK_LECTURN3); // Demon Lectern (FLATPACK)
        blocked.add(ItemID.POH_FLATPACK_LECTURN4); // Teak Eagle Lectern (FLATPACK)
        blocked.add(ItemID.POH_FLATPACK_LECTURN5); // Teak Demon Lectern (FLATPACK)
        blocked.add(ItemID.POH_FLATPACK_LECTURN6); // Mahogany Eagle (FLATPACK)
        blocked.add(ItemID.POH_FLATPACK_LECTURN7); // Mahogany Demon (FLATPACK)
        blocked.add(ItemID.BH_SUPPLY_CRATE); // Bounty Supply Crate
        BLOCKED_ITEMS = Collections.unmodifiableSet(blocked);
    }
}

package com.chanceman.filters;

import lombok.Getter;
import net.runelite.api.gameval.ItemID;
import java.util.Collections;
import java.util.HashSet;
import java.util.Set;

public enum ItemSets {

    // Items are sorted in the same order as displayed on the Grand Exchange interface
    DwarfCannon(ItemID.SET_CANNON),

    // Dragonhide sets
    GreenDragonhide(ItemID.SET_DHIDE_GREEN),
    BlueDragonhide(ItemID.SET_DHIDE_BLUE),
    RedDragonhide(ItemID.SET_DHIDE_RED),
    BlackDragonhide(ItemID.SET_DHIDE_BLACK),

    // Barrows armour sets
    Guthans(ItemID.SET_BARROWS_GUTHAN),
    Veracs(ItemID.SET_BARROWS_VERAC),
    Dharoks(ItemID.SET_BARROWS_DHAROK),
    Torags(ItemID.SET_BARROWS_TORAG),
    Ahrims(ItemID.SET_BARROWS_AHRIM),
    Karils(ItemID.SET_BARROWS_KARIL),

    // Potion sets
    CombatPotion(ItemID.SET_COMBAT_POTION),
    SuperPotion(ItemID.SET_SUPERCOMBAT_POTION),

    // Base metal armour sets
    BronzeLegs(ItemID.SET_BRONZE_LEGS),
    BronzeSkirt(ItemID.SET_BRONZE_SKIRT),

    IronLegs(ItemID.SET_IRON_LEGS),
    IronSkirt(ItemID.SET_IRON_SKIRT),

    SteelLegs(ItemID.SET_STEEL_LEGS),
    SteelSkirt(ItemID.SET_STEEL_SKIRT),

    BlackLegs(ItemID.SET_BLACK_LEGS),
    BlackSkirt(ItemID.SET_BLACK_SKIRT),

    MithrilLegs(ItemID.SET_MITHRIL_LEGS),
    MithrilSkirt(ItemID.SET_MITHRIL_SKIRT),

    AdamantLegs(ItemID.SET_ADAMANT_LEGS),
    AdamantSkirt(ItemID.SET_ADAMANT_SKIRT),

    RuneLegs(ItemID.SET_RUNE_LEGS),
    RuneSkirt(ItemID.SET_RUNE_SKIRT),

    // Trimmed and gilded base metal armour sets

    BronzeLegsTrim(ItemID.SET_BRONZE_LEGS_TRIM),
    BronzeSkirtTrim(ItemID.SET_BRONZE_SKIRT_TRIM),
    BronzeLegsGold(ItemID.SET_BRONZE_LEGS_GOLD),
    BronzeSkirtGold(ItemID.SET_BRONZE_SKIRT_GOLD),

    IronLegsTrim(ItemID.SET_IRON_LEGS_TRIM),
    IronSkirtTrim(ItemID.SET_IRON_SKIRT_TRIM),
    IronLegsGold(ItemID.SET_IRON_LEGS_GOLD),
    IronSkirtGold(ItemID.SET_IRON_SKIRT_GOLD),

    SteelLegsTrim(ItemID.SET_STEEL_LEGS_TRIM),
    SteelSkirtTrim(ItemID.SET_STEEL_SKIRT_TRIM),
    SteelLegsGold(ItemID.SET_STEEL_LEGS_GOLD),
    SteelSkirtGold(ItemID.SET_STEEL_SKIRT_GOLD),

    BlackLegsTrim(ItemID.SET_BLACK_LEGS_TRIM),
    BlackSkirtTrim(ItemID.SET_BLACK_SKIRT_TRIM),
    BlackLegsGold(ItemID.SET_BLACK_LEGS_GOLD),
    BlackSkirtGold(ItemID.SET_BLACK_SKIRT_GOLD),

    MithrilLegsTrim(ItemID.SET_MITHRIL_LEGS_TRIM),
    MithrilSkirtTrim(ItemID.SET_MITHRIL_SKIRT_TRIM),
    MithrilLegsGold(ItemID.SET_MITHRIL_LEGS_GOLD),
    MithrilSkirtGold(ItemID.SET_MITHRIL_SKIRT_GOLD),

    AdamantLegsTrim(ItemID.SET_ADAMANT_LEGS_TRIM),
    AdamantSkirtTrim(ItemID.SET_ADAMANT_SKIRT_TRIM),
    AdamantLegsGold(ItemID.SET_ADAMANT_LEGS_GOLD),
    AdamantSkirtGold(ItemID.SET_ADAMANT_SKIRT_GOLD),

    RuneLegsTrim(ItemID.SET_RUNE_LEGS_TRIM),
    RuneSkirtTrim(ItemID.SET_RUNE_SKIRT_TRIM),
    RuneLegsGold(ItemID.SET_RUNE_LEGS_GOLD),
    RuneSkirtGold(ItemID.SET_RUNE_SKIRT_GOLD),

    // Dragon armour sets
    DragonLegs(ItemID.SET_DRAGON_LEGS),
    DragonSkirt(ItemID.SET_DRAGON_SKIRT),

    // God rune armour sets
    SaradominLegs(ItemID.SET_RUNE_LEGS_SARADOMIN),
    SaradominSkirt(ItemID.SET_RUNE_SKIRT_SARADOMIN),

    ZamorakLegs(ItemID.SET_RUNE_LEGS_ZAMORAK),
    ZamorakSkirt(ItemID.SET_RUNE_SKIRT_ZAMORAK),

    GuthixLegs(ItemID.SET_RUNE_LEGS_GUTHIX),
    GuthixSkirt(ItemID.SET_RUNE_SKIRT_GUTHIX),

    ArmadylLegs(ItemID.SET_RUNE_LEGS_ARMADYL),
    ArmadylSkirt(ItemID.SET_RUNE_SKIRT_ARMADYL),

    BandosLegs(ItemID.SET_RUNE_LEGS_BANDOS),
    BandosSkirt(ItemID.SET_RUNE_SKIRT_BANDOS),

    AncientLegs(ItemID.SET_RUNE_LEGS_ANCIENT),
    AncientSkirt(ItemID.SET_RUNE_SKIRT_ANCIENT),

    // Gilded armour sets
    GildedArmourLegs(ItemID.SET_RUNE_LEGS_GOLDPLATE),
    GildedArmourSkirt(ItemID.SET_RUNE_SKIRT_GOLDPLATE),

    // God book page sets
    HolyBookPage(ItemID.SET_HOLY_BOOK),
    UnholyBookPage(ItemID.SET_UNHOLY_BOOK),
    BookBalancePage(ItemID.SET_BOOK_BALANCE),
    BookWarPage(ItemID.SET_BOOK_WAR),
    BookLawPage(ItemID.SET_BOOK_LAW),
    BookDarknessPage(ItemID.SET_BOOK_DARKNESS),

    // Dragonhide sets
    GildedDragonhide(ItemID.SET_DHIDE_GILDED),
    ZamorakDragonhide(ItemID.SET_DHIDE_ZAMORAK),
    SaradominDragonhide(ItemID.SET_DHIDE_SARADOMIN),
    GuthixDragonhide(ItemID.SET_DHIDE_GUTHIX),
    BandosDragonhide(ItemID.SET_DHIDE_BANDOS),
    ArmadylDragonhide(ItemID.SET_DHIDE_ARMADYL),
    AncientDragonhide(ItemID.SET_DHIDE_ANCIENT),

    // Miscellaneous sets
    OathplateSet(ItemID.SET_OATHPLATE_ARMOUR),
    PartyhatSet(ItemID.SET_PARTYHAT),
    HalloweenMaskSet(ItemID.SET_HALLOWEEN_MASK),
    AncestralRobes(ItemID.SET_ANCESTRAL_ROBES),
    ObsidianArmour(ItemID.SET_OBSIDIAN_ARMOUR),
    JusticiarArmour(ItemID.SET_JUSTICIAR_ARMOUR),
    MysticLight(ItemID.SET_MYSTIC_LIGHT),
    MysticBlue(ItemID.SET_MYSTIC_BLUE),
    MysticDark(ItemID.SET_MYSTIC_DARK),
    MysticDusk(ItemID.SET_MYSTIC_DUSK),
    DragonstoneArmour(ItemID.SET_DRAGONSTONE_ARMOUR),
    DagonhaiRobes(ItemID.SET_DAGONHAI_ROBES),
    InquisitorsArmour(ItemID.SET_INQUISITORS_ARMOUR),
    MasoriFortified(ItemID.SET_MASORI_FORTIFIED),
    // Leagues item sets are omitted as they are globally blocked
    SunfireFanatic(ItemID.SET_SUNFIRE_FANATIC);

    @Getter
    private final int id;

    ItemSets(int id) {
        this.id = id;
    }

    /**
     * Returns an unmodifiable set of all item set item IDs.
     */
    public static Set<Integer> getAllItemSetIds() {
        Set<Integer> ids = new HashSet<>();
        for (ItemSets as : ItemSets.values()) {
            ids.add(as.getId());
        }
        return Collections.unmodifiableSet(ids);
    }

    /**
     * Checks if the given item ID is one of the item set items.
     *
     * @param id the item id to check.
     * @return true if the id belongs to an item set, false otherwise.
     */
    public static boolean isItemSet(int id) {
        return getAllItemSetIds().contains(id);
    }
}

package com.chanceman.filters;

import lombok.Getter;

import java.util.Collections;
import java.util.HashMap;
import java.util.Map;

public final class EnsouledHeadMapping {
    public static final int DEFAULT_ENSOULED_HEAD_ID = -1;

    @Getter public static final Map<String, Integer> ENSOULED_HEAD_MAP;

    static {
        Map<String, Integer> ensouledMap = new HashMap<>();
        ensouledMap.put("ensouled abyssal head", 13508);
        ensouledMap.put("ensouled aviansie head", 13505);
        ensouledMap.put("ensouled bear head", 13463);
        ensouledMap.put("ensouled bloodveld head", 13496);
        ensouledMap.put("ensouled chaos druid head", 13472);
        ensouledMap.put("ensouled dagannoth head", 13493);
        ensouledMap.put("ensouled demon head", 13502);
        ensouledMap.put("ensouled dog head", 13469);
        ensouledMap.put("ensouled dragon head", 13511);
        ensouledMap.put("ensouled elf head", 13481);
        ensouledMap.put("ensouled giant head", 13475);
        ensouledMap.put("ensouled goblin head", 13448);
        ensouledMap.put("ensouled hellhound head", 26997);
        ensouledMap.put("ensouled horror head", 13487);
        ensouledMap.put("ensouled imp head", 13454);
        ensouledMap.put("ensouled kalphite head", 13490);
        ensouledMap.put("ensouled minotaur head", 13457);
        ensouledMap.put("ensouled monkey head", 13451);
        ensouledMap.put("ensouled ogre head", 13478);
        ensouledMap.put("ensouled scorpion head", 13460);
        ensouledMap.put("ensouled troll head", 13484);
        ensouledMap.put("ensouled tzhaar head", 13499);
        ensouledMap.put("ensouled unicorn head", 13466);
        ENSOULED_HEAD_MAP = Collections.unmodifiableMap(ensouledMap);
    }
}

package com.chanceman.filters;

import com.chanceman.ChanceManConfig;

import java.util.Set;

/**
 * Utility class for additional item filtering logic.
 */
public class ItemsFilter {

    /**
     * Checks if an item is blocked.
     * An item is blocked if it is in the blocked set,
     * or if it is a flatpack and flatpacks are disabled,
     * or if it is an item set and item sets are disabled.
     *
     * @param itemId the item id
     * @param config determines if item sets, flatpacks, and/or trade-only f2p items
     *               should be blocked
     * @return true if the item is blocked; false otherwise
     */
    public static boolean isBlocked(int itemId, ChanceManConfig config) {
        return (!config.enableFlatpacks() && Flatpacks.isFlatpack(itemId))
                || (!config.enableItemSets() && ItemSets.isItemSet(itemId))
                || BlockedItems.getBLOCKED_ITEMS().contains(itemId)
                || (config.freeToPlay() && isBlockedOnFreeToPlay(itemId, config));
    }

    private static boolean isBlockedOnFreeToPlay(int itemId, ChanceManConfig config) {
        return !config.includeF2PTradeOnlyItems() &&
                FreeToPlayBlockedItems.isFreeToPlayTradeOnlyItem(itemId);
    }

    /**
     * Returns the correct ensouled head ID for the given item name.
     * If not found, returns DEFAULT_ENSOULED_HEAD_ID.
     *
     * @param itemName the item name to check.
     * @return the ensouled head ID if found; otherwise DEFAULT_ENSOULED_HEAD_ID.
     */
    public static int getEnsouledHeadId(String itemName) {
        return (itemName == null)
                ? EnsouledHeadMapping.DEFAULT_ENSOULED_HEAD_ID
                : EnsouledHeadMapping.getENSOULED_HEAD_MAP().getOrDefault(
                itemName.toLowerCase(), EnsouledHeadMapping.DEFAULT_ENSOULED_HEAD_ID);
    }

    /**
     * Scans the provided text and returns the ensouled head ID if any known ensouled head key is found.
     * Returns DEFAULT_ENSOULED_HEAD_ID if no match is found.
     *
     * @param text the text to scan.
     * @return the ensouled head ID if a key is found; otherwise DEFAULT_ENSOULED_HEAD_ID.
     */
    public static int getEnsouledHeadIdFromText(String text) {
        if (text == null) {
            return EnsouledHeadMapping.DEFAULT_ENSOULED_HEAD_ID;
        }
        String lowerText = text.toLowerCase();
        for (String key : EnsouledHeadMapping.getENSOULED_HEAD_MAP().keySet()) {
            if (lowerText.contains(key)) {
                return EnsouledHeadMapping.getENSOULED_HEAD_MAP().get(key);
            }
        }
        return EnsouledHeadMapping.DEFAULT_ENSOULED_HEAD_ID;
    }

    /**
     * Checks if a poisonable weapon variant is eligible for rolling.
     * Base weapons are always eligible; for poisoned variants, if requireWeaponPoison is true,
     * the corresponding global weapon poison must also be unlocked.
     *
     * @param itemId the item id to check
     * @param requireWeaponPoison if true, the matching global poison must be unlocked
     * @param unlockedItems the set of unlocked item ids
     * @return true if eligible; false otherwise
     */
    public static boolean isPoisonEligible(int itemId, boolean requireWeaponPoison, Set<Integer> unlockedItems) {
        return PoisonWeapons.isPoisonVariantEligible(itemId, requireWeaponPoison, unlockedItems);
    }

    private boolean isGlobalWeaponPoison(int itemId) {
        return itemId == PoisonWeapons.WEAPON_POISON.getBaseId() ||
                itemId == PoisonWeapons.WEAPON_POISON_.getBaseId() ||
                itemId == PoisonWeapons.WEAPON_POISON__.getBaseId();
    }
}

package com.chanceman;

import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.client.audio.AudioPlayer;
import net.runelite.client.game.ItemManager;
import net.runelite.client.ui.overlay.Overlay;
import net.runelite.client.ui.overlay.OverlayLayer;
import net.runelite.client.ui.overlay.OverlayPosition;
import javax.inject.Inject;
import javax.inject.Singleton;
import java.io.IOException;
import javax.sound.sampled.LineUnavailableException;
import javax.sound.sampled.UnsupportedAudioFileException;

import java.awt.*;
import java.awt.geom.RoundRectangle2D;
import java.awt.image.BufferedImage;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.function.Supplier;

/**
 * Overlay for displaying the roll animation.
 * It renders a scrolling set of item icons and highlights the final item.
 */
@Singleton @Slf4j
public class ChanceManOverlay extends Overlay
{
    @Inject private AudioPlayer audioPlayer;
    @Inject private ChanceManConfig config;
    private final Client client;
    private final ItemManager itemManager;

    // Animation state
    private volatile boolean isAnimating = false;
    private long rollDuration;             // spin duration (ms)
    private long highlightDuration = 2000; // highlight duration (ms)
    private long rollStartTime = 0;

    // Spin parameters
    private float rollOffset = 0f;
    private float currentSpeed;
    private final float initialSpeed = 975f;   // start speed (px/sec)
    private final float deceleration = 425f;    // px/sec^2
    private final float minSpeed = 120f;        // never go below this speed

    // Icon layout
    private final int iconCount = 5;
    private final int iconWidth = 32;
    private final int iconHeight = 32;
    private final int spacing = 5;

    // Extra width so icons don't spill out mid-scroll
    private final int extraWidthBuffer = 17;

    // Overall bounding box padding (internal margin)
    private final int outerPad = 5;

    // Vertical offset from the top of the 3D viewport
    private final int offsetFromTop = 20;

    // Shift the entire background box left by 20 pixels
    private final int boxShift = -20;

    // For drawing the background
    private final int cornerRadius = 10;
    private final float borderStrokeWidth = 2f;

    // List of rolling items (synchronized for thread safety)
    private final List<Integer> rollingItems = Collections.synchronizedList(new ArrayList<>());
    private Supplier<Integer> randomLockedItemSupplier;

    @Inject
    public ChanceManOverlay(Client client, ItemManager itemManager)
    {
        this.client = client;
        this.itemManager = itemManager;
        setPosition(OverlayPosition.DYNAMIC);
        setLayer(OverlayLayer.ABOVE_WIDGETS);
    }

    /**
     * Starts the roll animation.
     *
     * @param dummy Unused parameter.
     * @param rollDurationMs The duration of the roll phase in milliseconds.
     * @param randomLockedItemSupplier Supplier for obtaining random locked items.
     */
    public void startRollAnimation(int dummy, int rollDurationMs, Supplier<Integer> randomLockedItemSupplier)
    {
        if (config.enableRollSounds())
        {
            try
            {
                audioPlayer.play(ChanceManOverlay.class,
                        "/com/chanceman/tick.wav",
                        0.0f);
            }
            catch (IOException | UnsupportedAudioFileException | LineUnavailableException ex)
            {
                log.warn("ChanceMan: failed to play tick.wav", ex);
            }
        }
        this.rollDuration = rollDurationMs;
        this.rollStartTime = System.currentTimeMillis();
        this.rollOffset = 0f;
        this.currentSpeed = initialSpeed;
        this.randomLockedItemSupplier = randomLockedItemSupplier;
        this.isAnimating = true;

        synchronized (rollingItems) {
            rollingItems.clear();
            for (int i = 0; i < iconCount; i++)
            {
                rollingItems.add(randomLockedItemSupplier.get());
            }
        }
    }

    /**
     * Retrieves the final item ID based on the center icon after the roll animation finishes.
     *
     * @return The final item ID.
     */
    public int getFinalItem()
    {
        synchronized (rollingItems) {
            int centerIndex = iconCount / 2;
            if (rollingItems.size() > centerIndex)
            {
                return rollingItems.get(centerIndex);
            }
        }
        return 0;
    }

    /**
     * Renders the roll animation overlay.
     *
     * @param g The graphics context.
     * @return null (no preferred size).
     */
    @Override
    public Dimension render(Graphics2D g)
    {
        if (!isAnimating)
        {
            return null;
        }

        g.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);
        g.setRenderingHint(RenderingHints.KEY_INTERPOLATION, RenderingHints.VALUE_INTERPOLATION_BILINEAR);

        long now = System.currentTimeMillis();
        long elapsed = now - rollStartTime;
        boolean inHighlightPhase = (elapsed > rollDuration);

        if (elapsed > rollDuration + highlightDuration)
        {
            isAnimating = false;
            return null;
        }

        int vpX = client.getViewportXOffset();
        int vpY = client.getViewportYOffset();
        int vpWidth = client.getViewportWidth();
        int centerX = vpX + (vpWidth / 2);
        int boxTopY = vpY + offsetFromTop;

        int totalIconsWidth = iconCount * iconWidth + (iconCount - 1) * spacing;
        int totalWidthWithBuffer = totalIconsWidth + extraWidthBuffer;
        int boxWidth = totalWidthWithBuffer + outerPad * 2;
        int boxHeight = iconHeight + outerPad * 2;
        int boxLeftX = centerX - (boxWidth / 2) + boxShift;

        Shape backgroundRect = new RoundRectangle2D.Float(
                boxLeftX, boxTopY, boxWidth, boxHeight,
                cornerRadius, cornerRadius
        );
        g.setColor(new Color(0, 0, 0, 180));
        g.fill(backgroundRect);
        g.setColor(new Color(0, 0, 0, 255));
        g.setStroke(new BasicStroke(borderStrokeWidth));
        g.draw(backgroundRect);

        synchronized (rollingItems) {
            if (!inHighlightPhase)
            {
                float dt = 1f / 60f;
                rollOffset += currentSpeed * dt;
                currentSpeed = Math.max(currentSpeed - deceleration * dt, minSpeed);

                if (rollOffset >= (iconWidth + spacing))
                {
                    rollOffset -= (iconWidth + spacing);
                    if (!rollingItems.isEmpty())
                    {
                        rollingItems.remove(0);
                    }
                    rollingItems.add(randomLockedItemSupplier.get());
                }
            }

            int iconsLeftX = centerX - (totalIconsWidth / 2);
            int iconsY = boxTopY + outerPad;
            for (int i = 0; i < rollingItems.size(); i++)
            {
                int itemId = rollingItems.get(i);
                BufferedImage image = itemManager.getImage(itemId, 1, false);
                if (image != null)
                {
                    int drawX = (int) (iconsLeftX + i * (iconWidth + spacing) - rollOffset);
                    g.drawImage(image, drawX, iconsY, iconWidth, iconHeight, null);
                }
            }

            if (inHighlightPhase)
            {
                int centerIndex = iconCount / 2;
                int highlightX = (int) (iconsLeftX + centerIndex * (iconWidth + spacing) - rollOffset);
                g.setColor(Color.YELLOW);
                g.setStroke(new BasicStroke(3f));
                g.drawRect(highlightX, iconsY, iconWidth, iconHeight);
            }
        }
        return null;
    }
}

package com.chanceman.menus;

import lombok.Getter;

import java.util.HashMap;
import java.util.HashSet;

@Getter
public enum SkillOp
{
	CHOP_DOWN("Chop down"),
	MINE("Mine"),
	NET("Net"),
	CAGE("Cage"),
	BAIT("Bait"),
	LURE("Lure"),
	RAKE("Rake"),
	PRUNE("Prune"),
	CURE("Cure"),
	GRIND("Grind"),
	SMITH("Smith"),
	SMELT("Smelt"),
	SHEAR("Shear"),
	CLEAN("Clean"),
	FIRE("Fire"),
	CRAFT_RUNE("Craft-rune");

	private final String option;

	SkillOp(String option)
	{
		this.option = option;
	}

	private static final HashSet<String> ALL_SKILL_OPS = new HashSet<>();
	private static final HashMap<String, SkillOp> STRING_TO_OP = new HashMap<>();

	static
	{
		for (SkillOp skillOp : SkillOp.values())
		{
			ALL_SKILL_OPS.add(skillOp.option);
			STRING_TO_OP.put(skillOp.option, skillOp);
		}
	}

	public static boolean isSkillOp(String option)
	{
		return ALL_SKILL_OPS.contains(option);
	}

	public static SkillOp fromString(String option)
	{
		if (!isSkillOp(option)) return null;
		return STRING_TO_OP.get(option);
	}
}

package com.chanceman.menus;

import com.chanceman.ChanceManPlugin;
import com.chanceman.managers.UnlockedItemsManager;
import lombok.Getter;
import lombok.Setter;
import net.runelite.api.Client;
import net.runelite.api.GameState;
import net.runelite.api.MenuAction;
import net.runelite.api.MenuEntry;
import net.runelite.api.events.MenuOptionClicked;
import net.runelite.api.events.MenuEntryAdded;
import net.runelite.api.events.WidgetClosed;
import net.runelite.api.events.WidgetLoaded;
import net.runelite.client.eventbus.EventBus;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.game.ItemManager;
import net.runelite.client.util.Text;

import javax.inject.Inject;
import javax.inject.Singleton;
import java.util.EnumSet;
import java.util.HashSet;
import java.util.Set;
import java.util.function.Consumer;

@Singleton
public class ActionHandler {


	private static final Set<MenuAction> disabledActions = EnumSet.of(
			MenuAction.CC_OP,               // inventory “Use” on locked
			MenuAction.WIDGET_TARGET,       // “Use” on widgets
			MenuAction.WIDGET_TARGET_ON_WIDGET  // “Use” on widget -> widget
	);

	private static final Set<MenuAction> GROUND_ACTIONS = EnumSet.of(
			MenuAction.GROUND_ITEM_FIRST_OPTION,
			MenuAction.GROUND_ITEM_SECOND_OPTION,
			MenuAction.GROUND_ITEM_THIRD_OPTION,
			MenuAction.GROUND_ITEM_FOURTH_OPTION,
			MenuAction.GROUND_ITEM_FIFTH_OPTION
	);

	/**
	 * Normalize a MenuEntryAdded into the base item ID.
	 */
	private int getItemId(MenuEntryAdded event, MenuEntry entry)
	{
		MenuAction type = entry.getType();
		boolean hasItemId = entry.getItemId() > 0 || event.getItemId() > 0;
		if (!GROUND_ACTIONS.contains(type) && !hasItemId) {return -1;}
		int raw = GROUND_ACTIONS.contains(type)
				? event.getIdentifier()
				: Math.max(event.getItemId(), entry.getItemId());
		return plugin.getItemManager().canonicalize(raw);
	}

	private final HashSet<Integer> enabledUIs = new HashSet<>() {{
		add(EnabledUI.BANK.getId());
		add(EnabledUI.DEPOSIT_BOX.getId());
	}};

	@Inject
	private Client client;
	@Inject
	private EventBus eventBus;
	@Inject
	private ChanceManPlugin plugin;
	@Inject
	private Restrictions restrictions;
	@Inject
	private UnlockedItemsManager unlockedItemsManager;
	@Getter
	@Setter
	private int enabledUIOpen = -1;

	// A no-op click handler that marks a menu entry as disabled.
	private final Consumer<MenuEntry> DISABLED = e -> { };

	public void startUp() {
		eventBus.register(this);
		eventBus.register(restrictions);
	}

	public void shutDown() {
		eventBus.unregister(this);
		eventBus.unregister(restrictions);
	}

	private boolean enabledUiOpen() {
		return enabledUIOpen != -1;
	}

	private boolean inactive() {
		if (!unlockedItemsManager.ready()) return true;
		return client.getGameState().getState() < GameState.LOADING.getState();
	}

	@Subscribe
	public void onWidgetClosed(WidgetClosed event) {
		if (enabledUIs.contains(event.getGroupId()))
			enabledUIOpen = -1;
	}

	@Subscribe
	public void onWidgetLoaded(WidgetLoaded event) {
		if (enabledUIs.contains(event.getGroupId()))
			enabledUIOpen = event.getGroupId();
	}

	@Subscribe
	public void onMenuEntryAdded(MenuEntryAdded event) {
		if (inactive()) return;

		MenuEntry entry = event.getMenuEntry();
		MenuAction action = entry.getType();
		int id = getItemId(event, entry);
		boolean enabled;
		// Check if the entry looks like it's for a ground item.
		if (isGroundItem(entry)) {
			enabled = !isLockedGroundItem(id);
		} else {
			enabled = isEnabled(id, entry, action);
		}
		// If not enabled, grey out the text and set the click handler to DISABLED.
		if (!enabled) {
			String option = Text.removeTags(entry.getOption());
			String target = Text.removeTags(entry.getTarget());
			entry.setOption("<col=808080>" + option);
			entry.setTarget("<col=808080>" + target);
			entry.onClick(DISABLED);
		}
	}

	@Subscribe
	public void onMenuOptionClicked(MenuOptionClicked event) {
		// If the entry is disabled, consume the event.
		if (event.getMenuEntry().onClick() == DISABLED) {
			event.consume();
			return;
		}
		// Extra safeguard for ground items.
		handleGroundItems(plugin.getItemManager(), unlockedItemsManager, event, plugin);
	}

	/**
	 * Returns true if the entry appears to be for a ground item.
	 */
	private boolean isGroundItem(MenuEntry entry)
	{
		return GROUND_ACTIONS.contains(entry.getType());
	}

	/**
	 * @param itemId canonicalized item ID of a ground item
	 * @return true if it’s tradeable, tracked, and still locked
	 */
	private boolean isLockedGroundItem(int itemId)
	{
		return plugin.isTradeable(itemId)
				&& !plugin.isNotTracked(itemId)
				&& !unlockedItemsManager.isUnlocked(itemId);
	}

	/**
	 * This method handles non-ground items (or any other cases) by checking if the item is enabled.
	 * It returns true if the action should be allowed.
	 */
	private boolean isEnabled(int id, MenuEntry entry, MenuAction action) {
		String option = Text.removeTags(entry.getOption());
		String target = Text.removeTags(entry.getTarget());

		// Always allow "Drop"
		if (option.equalsIgnoreCase("drop"))
			return true;
		if (option.equalsIgnoreCase("clean") || option.equalsIgnoreCase("rub"))
		{
			if (!plugin.isInPlay(id)) { return true; }
			return unlockedItemsManager.isUnlocked(id);
		}
		if (SkillOp.isSkillOp(option))
			return restrictions.isSkillOpEnabled(option);
		if (Spell.isSpell(option))
			return restrictions.isSpellOpEnabled(option);
		if (Spell.isSpell(target))
			return restrictions.isSpellOpEnabled(target);

		boolean enabled;
		if (enabledUiOpen()) {
			enabled = option.startsWith("Deposit") || option.startsWith("Examine") || option.startsWith("Withdraw")
					|| option.startsWith("Release") || option.startsWith("Destroy");
		} else {
			enabled = !disabledActions.contains(action);
		}
		if (enabled)
			return true;
		if (id == 0 || id == -1 || !plugin.isInPlay(id))
			return true;
		return unlockedItemsManager.isUnlocked(id);
	}

	/**
	 * A static helper to further safeguard ground item actions.
	 * If a ground item is locked, this method consumes the event.
	 */
	public static void handleGroundItems(ItemManager itemManager, UnlockedItemsManager unlockedItemsManager,
										 MenuOptionClicked event, ChanceManPlugin plugin)
	{
		if (event.getMenuAction() != null && GROUND_ACTIONS.contains(event.getMenuAction()))
		{
			int rawItemId = event.getId() != -1 ? event.getId() : event.getMenuEntry().getItemId();
			int canonicalGroundId = itemManager.canonicalize(rawItemId);
			if (plugin.isTradeable(canonicalGroundId)
					&& !plugin.isNotTracked(canonicalGroundId)
					&& unlockedItemsManager != null
					&& !unlockedItemsManager.isUnlocked(canonicalGroundId)) {
				event.consume();
			}
		}
	}
}

package com.chanceman.menus;

import lombok.Getter;
import net.runelite.api.gameval.ItemID;

import java.util.Arrays;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;

@Getter
public enum BlightedSack
{
    ENTANGLE(
            ItemID.BLIGHTED_SACK_ENTANGLE,
            Collections.unmodifiableSet(new HashSet<>(Arrays.asList(
                    "Snare", "Entangle", "Bind"
            )))
    ),
    SURGE(
            ItemID.BLIGHTED_SACK_SURGE,
            Collections.unmodifiableSet(new HashSet<>(Arrays.asList(
                    "Wind Surge", "Water Surge", "Earth Surge", "Fire Surge",
                    "Wind Wave",  "Water Wave",  "Earth Wave",  "Fire Wave"
            )))
    ),
    TELEBLOCK(
            ItemID.BLIGHTED_SACK_TELEBLOCK,
            Collections.unmodifiableSet(new HashSet<>(Arrays.asList(
                    "Tele Block", "Teleport to Target"
            )))
    ),
    VENGEANCE(
            ItemID.BLIGHTED_SACK_VENGEANCE,
            Collections.unmodifiableSet(new HashSet<>(Arrays.asList(
                    "Vengeance", "Vengeance Other"
            )))
    ),
    ANCIENT_ICE(
            ItemID.BLIGHTED_SACK_ICEBARRAGE,
            Collections.unmodifiableSet(new HashSet<>(Arrays.asList(
                    "Ice Rush", "Ice Burst", "Ice Blitz", "Ice Barrage"
            )))
    );

    private final int sackItemId;
    private final Set<String> allowedSpells;
    private static final Map<String, BlightedSack> SPELL_TO_SACK;
    static
    {
        Map<String, BlightedSack> map = new HashMap<>();
        for (BlightedSack sack : values())
        {
            for (String spell : sack.allowedSpells)
            {
                map.put(spell, sack);
            }
        }
        SPELL_TO_SACK = Collections.unmodifiableMap(map);
    }

    BlightedSack(int sackItemId, Set<String> allowedSpells)
    {
        this.sackItemId = sackItemId;
        this.allowedSpells = allowedSpells;
    }

    /**
     * @return the BlightedSack that grants this spell, or null if none.
     */
    public static BlightedSack fromSpell(String spellName)
    {
        return SPELL_TO_SACK.get(spellName);
    }
}

package com.chanceman.menus;

import lombok.Getter;

import java.util.HashSet;

@Getter
public enum Spell
{
	// STANDARD
	WIND_STRIKE("Wind Strike"),
	WATER_STRIKE("Water Strike"),
	EARTH_STRIKE("Earth Strike"),
	FIRE_STRIKE("Fire Strike"),
	WIND_BOLT("Wind Bolt"),
	WATER_BOLT("Water Bolt"),
	EARTH_BOLT("Earth Bolt"),
	FIRE_BOLT("Fire Bolt"),
	WIND_BLAST("Wind Blast"),
	WATER_BLAST("Water Blast"),
	EARTH_BLAST("Earth Blast"),
	FIRE_BLAST("Fire Blast"),
	WIND_WAVE("Wind Wave"),
	WATER_WAVE("Water Wave"),
	EARTH_WAVE("Earth Wave"),
	FIRE_WAVE("Fire Wave"),
	WIND_SURGE("Wind Surge"),
	WATER_SURGE("Water Surge"),
	EARTH_SURGE("Earth Surge"),
	FIRE_SURGE("Fire Surge"),
	SARADOMIN_STRIKE("Saradomin Strike"),
	CLAWS_OF_GUTHIX("Claws of Guthix"),
	FLAMES_OF_ZAMORAK("Flames of Zamorak"),
	CHARGE("Charge"),
	TELEBLOCK("Tele Block"),
	WEAKEN("Weaken"),
	CONFUSE("Confuse"),
	CURSE("Curse"),
	STUN("Stun"),
	VULNERABILITY("Vulnerability"),
	ENFEEBLE("Enfeeble"),
	BIND("Bind"),
	SNARE("Snare"),
	ENTANGLE("Entangle"),
	LOW_LEVEL_ALCHEMY("Low Level Alchemy"),
	HIGH_LEVEL_ALCHEMY("High Level Alchemy"),
	TELEKINETIC_GRAB("Telekinetic Grab"),
	VARROCK_TELEPORT("Varrock Teleport"),
	LUMBRIDGE_TELEPORT("Lumbridge Teleport"),
	FALADOR_TELEPORT("Falador Teleport"),
	CAMELOT_TELEPORT("Camelot Teleport"),
	ARDOUGNE_TELEPORT("Ardougne Teleport"),
	CIVITAS_ILLA_FORTIS_TELEPORT("Civitas illa Fortis Teleport"),
	TROLLHEIM_TELEPORT("Trollheim Teleport"),
	WATCHTOWER_TELEPORT("Watchtower Teleport"),
	TELEPORT_TO_HOUSE("Teleport to House"),
	APE_ATOLL_TELEPORT("Ape Atoll Teleport"),
	KOUREND_CASTLE_TELEPORT("Kourend Castle Teleport"),
	LVL_1_ENCHANT("Lvl-1 Enchant"),
	LVL_2_ENCHANT("Lvl-2 Enchant"),
	LVL_3_ENCHANT("Lvl-3 Enchant"),
	LVL_4_ENCHANT("Lvl-4 Enchant"),
	LVL_5_ENCHANT("Lvl-5 Enchant"),
	LVL_6_ENCHANT("Lvl-6 Enchant"),
	LVL_7_ENCHANT("Lvl-7 Enchant"),
	CRUMBLE_UNDEAD("Crumble Undead"),
	MAGIC_DART("Magic Dart"),
	IBAN_BLAST("Iban Blast"),
	BONES_TO_BANANAS("Bones to Bananas"),
	BONES_TO_PEACHES("Bones to Peaches"),
	SUPERHEAT_ITEM("Superheat Item"),
	TELEOTHER_LUMBRIDGE("Teleother Lumbridge"),
	TELEOTHER_VARROCK("Teleother Varrock"),
	TELEOTHER_FALADOR("Teleother Falador"),
	TELEOTHER_CAMELOT("Teleother Camelot"),
	CHARGE_WATER_ORB("Charge Water Orb"),
	CHARGE_EARTH_ORB("Charge Earth Orb"),
	CHARGE_FIRE_ORB("Charge Fire Orb"),
	CHARGE_AIR_ORB("Charge Air Orb"),
	MONSTER_INSPECT("Monster Inspect"),

	// ANCIENT
	SMOKE_RUSH("Smoke Rush"),
	SHADOW_RUSH("Shadow Rush"),
	BLOOD_RUSH("Blood Rush"),
	ICE_RUSH("Ice Rush"),
	SMOKE_BURST("Smoke Burst"),
	SHADOW_BURST("Shadow Burst"),
	BLOOD_BURST("Blood Burst"),
	ICE_BURST("Ice Burst"),
	SMOKE_BLITZ("Smoke Blitz"),
	SHADOW_BLITZ("Shadow Blitz"),
	BLOOD_BLITZ("Blood Blitz"),
	ICE_BLITZ("Ice Blitz"),
	SMOKE_BARRAGE("Smoke Barrage"),
	SHADOW_BARRAGE("Shadow Barrage"),
	BLOOD_BARRAGE("Blood Barrage"),
	ICE_BARRAGE("Ice Barrage"),
	PADDEWWA_TELEPORT("Paddewwa Teleport"),
	SENNTISTEN_TELEPORT("Senntisten Teleport"),
	KHARYRLL_TELEPORT("Kharyrll Teleport"),
	LASSAR_TELEPORT("Lassar Teleport"),
	DAREEYAK_TELEPORT("Dareeyak Teleport"),
	CARRALLANGER_TELEPORT("Carrallanger Teleport"),
	TELEPORT_TO_TARGET("Teleport to Target"),
	ANNAKARL_TELEPORT("Annakarl Teleport"),
	GHORROCK_TELEPORT("Ghorrock Teleport"),

	// ARCEUUS
	ARCEUUS_LIBRARY_TELEPORT("Arceuus Library Teleport"),
	DRAYNOR_MANOR_TELEPORT("Draynor Manor Teleport"),
	BATTLEFRONT_TELEPORT("Battlefront Teleport"),
	MIND_ALTAR_TELEPORT("Mind Altar Teleport"),
	RESPAWN_TELEPORT("Respawn Teleport"),
	SALVE_GRAVEYARD_TELEPORT("Salve Graveyard Teleport"),
	FENKENSTRAINS_CASTLE_TELEPORT("Fenkenstrain's Castle Teleport"),
	WEST_ARDOUGNE_TELEPORT("West Ardougne Teleport"),
	HARMONY_ISLAND_TELEPORT("Harmony Island Teleport"),
	CEMETERY_TELEPORT("Cemetery Teleport"),
	BARROWS_TELEPORT("Barrows Teleport"),
	TELEPORT_TO_TARGET_ARC("Teleport to Target"),
	GHOSTLY_GRASP("Ghostly Grasp"),
	SKELETAL_GRASP("Skeletal Grasp"),
	UNDEAD_GRASP("Undead Grasp"),
	INFERIOR_DEMONBANE("Inferior Demonbane"),
	SUPERIOR_DEMONBANE("Superior Demonbane"),
	DARK_DEMONBANE("Dark Demonbane"),
	LESSER_CORRUPTION("Lesser Corruption"),
	GREATER_CORRUPTION("Greater Corruption"),
	RESURRECT_LESSER_GHOST("Resurrect Lesser Ghost"),
	RESURRECT_LESSER_SKELETON("Resurrect Lesser Skeleton"),
	RESURRECT_LESSER_ZOMBIE("Resurrect Lesser Zombie"),
	RESURRECT_SUPERIOR_GHOST("Resurrect Superior Ghost"),
	RESURRECT_SUPERIOR_SKELETON("Resurrect Superior Skeleton"),
	RESURRECT_SUPERIOR_ZOMBIE("Resurrect Superior Zombie"),
	RESURRECT_GREATER_GHOST("Resurrect Greater Ghost"),
	RESURRECT_GREATER_SKELETON("Resurrect Greater Skeleton"),
	RESURRECT_GREATER_ZOMBIE("Resurrect Greater Zombie"),
	DARK_LURE("Dark Lure"),
	MARK_OF_DARKNESS("Mark of Darkness"),
	WARD_OF_ARCEUUS("Ward of Arceuus"),
	BASIC_REANIMATION("Basic Reanimation"),
	ADEPT_REANIMATION("Adept Reanimation"),
	EXPERT_REANIMATION("Expert Reanimation"),
	MASTER_REANIMATION("Master Reanimation"),
	DEMONIC_OFFERING("Demonic Offering"),
	SINISTER_OFFERING("Sinister Offering"),
	SHADOW_VEIL("Shadow Veil"),
	VILE_VIGOUR("Vile Vigour"),
	DEGRIME("Degrime"),
	RESURRECT_CROPS("Resurrect Crops"),
	DEATH_CHARGE("Death Charge");

	private final String spellName;

	Spell(String spellName)
	{
		this.spellName = spellName;
	}

	private static final HashSet<String> ALL_SPELLS = new HashSet<>();

	static
	{
		for (Spell spell : Spell.values())
		{
			ALL_SPELLS.add(spell.getSpellName());
		}
	}

	public static boolean isSpell(String target)
	{
		return ALL_SPELLS.contains(target);
	}
}

package com.chanceman.menus;

import lombok.Getter;
import net.runelite.api.gameval.ItemID;

import java.util.HashSet;
import java.util.HashMap;

@Getter
public enum SkillItem
{

	BRONZE_AXE(1351, SkillOp.CHOP_DOWN),
	IRON_AXE(1349, SkillOp.CHOP_DOWN),
	STEEL_AXE(1353, SkillOp.CHOP_DOWN),
	BLACK_AXE(1361, SkillOp.CHOP_DOWN),
	MITHRIL_AXE(1355, SkillOp.CHOP_DOWN),
	ADAMANT_AXE(1357, SkillOp.CHOP_DOWN),
	RUNE_AXE(1359, SkillOp.CHOP_DOWN),
	DRAGON_AXE(6739, SkillOp.CHOP_DOWN),
	GILDED_AXE(23279, SkillOp.CHOP_DOWN),
	THIRD_AGE_AXE(20011, SkillOp.CHOP_DOWN),

	BRONZE_FELLING_AXE(28196, SkillOp.CHOP_DOWN),
	IRON_FELLING_AXE(28199, SkillOp.CHOP_DOWN),
	STEEL_FELLING_AXE(28202, SkillOp.CHOP_DOWN),
	BLACK_FELLING_AXE(28205, SkillOp.CHOP_DOWN),
	MITHRIL_FELLING_AXE(28208, SkillOp.CHOP_DOWN),
	ADAMANT_FELLING_AXE(28211, SkillOp.CHOP_DOWN),
	RUNE_FELLING_AXE(28214, SkillOp.CHOP_DOWN),
	DRAGON_FELLING_AXE(28217, SkillOp.CHOP_DOWN),
	THIRD_AGE_FELLING_AXE(28226, SkillOp.CHOP_DOWN),

	BRONZE_PICKAXE(1265, SkillOp.MINE),
	IRON_PICKAXE(1267, SkillOp.MINE),
	STEEL_PICKAXE(1269, SkillOp.MINE),
	BLACK_PICKAXE(12297, SkillOp.MINE),
	MITHRIL_PICKAXE(1273, SkillOp.MINE),
	ADAMANT_PICKAXE(1271, SkillOp.MINE),
	RUNE_PICKAXE(1275, SkillOp.MINE),
	DRAGON_PICKAXE(12797,SkillOp.MINE),
	GILDED_PICKAXE(23276, SkillOp.MINE),
	THIRD_AGE_PICKAXE(20014, SkillOp.MINE),

	SMALL_FISHING_NET(303, SkillOp.NET),
	BIG_FISHING_NET(305, SkillOp.NET),
	LOBSTER_POT(301, SkillOp.CAGE),
	FISHING_BAIT(313, SkillOp.BAIT),
	FLY_FISHING_ROD(309, SkillOp.LURE),
	RAKE(5341, SkillOp.RAKE),
	SHEARS(1735, SkillOp.SHEAR),
	SECATEURS(5329, SkillOp.PRUNE),

	BRONZE_BAR(2349, SkillOp.SMITH),
	IRON_BAR(2351, SkillOp.SMITH),
	STEEL_BAR(2353, SkillOp.SMITH),
	MITHRIL_BAR(2359, SkillOp.SMITH),
	ADAMANTITE_BAR(2361, SkillOp.SMITH),
	RUNITE_BAR(2363, SkillOp.SMITH),

	TIN_ORE(438, SkillOp.SMELT),
	COPPER_ORE(436, SkillOp.SMELT),
	IRON_ORE(440, SkillOp.SMELT),
	COAL(453, SkillOp.SMELT),
	MITHRIL_ORE(447, SkillOp.SMELT),
	RUNITE_ORE(451, SkillOp.SMELT),
	SILVER_ORE(442, SkillOp.SMELT),
	SILVER_BAR(2355,SkillOp.SMELT),
	GOLD_ORE(444, SkillOp.SMELT),
	GOLD_BAR(2357, SkillOp.SMELT),

	GRIMY_GUAM_LEAF(199, SkillOp.CLEAN),
	GRIMY_MARRENTILL(201, SkillOp.CLEAN),
	GRIMY_TARROMIN(203, SkillOp.CLEAN),
	GRIMY_HARRALANDER(205, SkillOp.CLEAN),
	GRIMY_RANARR_WEED(207, SkillOp.CLEAN),
	GRIMY_IRIT_LEAF(209, SkillOp.CLEAN),
	GRIMY_AVANTOE(211, SkillOp.CLEAN),
	GRIMY_KWUARM(213, SkillOp.CLEAN),
	GRIMY_CADANTINE(215, SkillOp.CLEAN),
	GRIMY_DWARF_WEED(217, SkillOp.CLEAN),
	GRIMY_TORSTOL(219, SkillOp.CLEAN),
	GRIMY_LANTADYME(2485, SkillOp.CLEAN),
	GRIMY_TOADFLAX(3049, SkillOp.CLEAN),
	GRIMY_SNAPDRAGON(3051, SkillOp.CLEAN),

	UNFIRED_BOWL(1791, SkillOp.FIRE),
	UNFIRED_CUP(28193, SkillOp.FIRE),
	UNFIRED_PIE_DISH(1789, SkillOp.FIRE),
	UNFIRED_PLANT_POT(5352, SkillOp.FIRE),
	UNFIRED_POT(1787, SkillOp.FIRE),
	UNFIRED_POT_LID(4438, SkillOp.FIRE),

	RUNE_ESSENCE(1436, SkillOp.CRAFT_RUNE),
	PURE_ESSENCE(7936, SkillOp.CRAFT_RUNE),

	//Blackjacks
	OAK_BLACKJACK_O(6408, SkillOp.LURE),
	OAK_BLACKJACK_D(6410, SkillOp.LURE),
	WILLOW_BLACKJACK(4600, SkillOp.LURE),
	WILLOW_BLACKJACK_O(6412, SkillOp.LURE),
	WILLOW_BLACKJACK_D(6414, SkillOp.LURE),
	MAPLE_BLACKJACK(6416, SkillOp.LURE),
	MAPLE_BLACKJACK_O(6418, SkillOp.LURE),
	MAPLE_BLACKJACK_D(6420, SkillOp.LURE),

	// Untradeables that conflict
	OAK_BLACKJACK(4599, SkillOp.LURE, false),
	RED_VINE_WORMS(25, SkillOp.BAIT, false),
	BOBS_NET(6209, SkillOp.NET, false);

	private final int id;
	private final SkillOp option;
	private final boolean requiresUnlock;

	SkillItem(int id, SkillOp option)
	{
		this(id, option, true);
	}

	SkillItem(int id, SkillOp option, boolean requiresUnlock)
	{
		this.id = id;
		this.option = option;
		this.requiresUnlock = requiresUnlock;
	}

	public SkillOp getSkillOp()
	{
		return option;
	}

	private static final HashSet<Integer> ALL_SKILL_ITEMS = new HashSet<>();
	private static final HashMap<Integer, SkillItem> ID_TO_ITEM = new HashMap<>();

	static
	{
		for (SkillItem skillItem : SkillItem.values())
		{
			ALL_SKILL_ITEMS.add(skillItem.getId());
			ID_TO_ITEM.put(skillItem.getId(), skillItem);
		}
	}

	public static boolean isSkillItem(int id)
	{
		return ALL_SKILL_ITEMS.contains(id);
	}

	public static SkillItem fromId(int id)
	{
		return ID_TO_ITEM.get(id);
	}
}

package com.chanceman.menus;

import lombok.Getter;

import java.util.HashMap;
import java.util.HashSet;

@Getter
public enum RuneProvider
{
	// Banana (yeah)
	BANANA(1963),

	// Runes
	AIR_RUNE(556),
	WATER_RUNE(555),
	EARTH_RUNE(557),
	FIRE_RUNE(554),
	MIND_RUNE(558),
	BODY_RUNE(559),
	COSMIC_RUNE(564),
	CHAOS_RUNE(562),
	NATURE_RUNE(561),
	LAW_RUNE(563),
	DEATH_RUNE(560),
	BLOOD_RUNE(565),
	SOUL_RUNE(566),
	WRATH_RUNE(21880),
	SUNFIRE_RUNE(false, 28929, FIRE_RUNE),

	// Elemental equipment
	AIR_STAFF(true, 1381, AIR_RUNE),
	MYSTIC_AIR_STAFF(true, 1405, AIR_RUNE),
	WATER_STAFF(true, 1383, WATER_RUNE),
	MYSTIC_WATER_STAFF(true, 1403, WATER_RUNE),
	EARTH_STAFF(true, 1385, EARTH_RUNE),
	MYSTIC_EARTH_STAFF(true, 1407, EARTH_RUNE),
	FIRE_STAFF(true, 1387, FIRE_RUNE),
	MYSTIC_FIRE_STAFF(true, 1401, FIRE_RUNE),
	AIR_BATTLESTAFF(true, 1397, AIR_RUNE),
	WATER_BATTLESTAFF(true, 1395, WATER_RUNE),
	KODAI_WAND(true, 21006, WATER_RUNE),
	EARTH_BATTLESTAFF(true, 1399, EARTH_RUNE),
	FIRE_BATTLESTAFF(true, 1393, FIRE_RUNE),
	TOME_OF_FIRE(true, 20714, FIRE_RUNE),
	TOME_OF_WATER(true, 25574, WATER_RUNE),
	TOME_OF_EARTH(true, 30064, EARTH_RUNE),

	// Combo runes
	AETHER_RUNE(false,30844,COSMIC_RUNE, SOUL_RUNE),
	MIST_RUNE(false, 4695, AIR_RUNE, WATER_RUNE),
	DUST_RUNE(false, 4696, AIR_RUNE, EARTH_RUNE),
	MUD_RUNE(false, 4698, WATER_RUNE, EARTH_RUNE),
	SMOKE_RUNE(false, 4697, FIRE_RUNE, AIR_RUNE),
	STEAM_RUNE(false, 4694, WATER_RUNE, FIRE_RUNE),
	LAVA_RUNE(false, 4699, EARTH_RUNE, FIRE_RUNE),

	// Combo staves
	MIST_STAFF(true, 20730, AIR_RUNE, WATER_RUNE),
	MYSTIC_MIST_STAFF(true, 20733, AIR_RUNE, WATER_RUNE),
	DUST_STAFF(true, 20736, AIR_RUNE, EARTH_RUNE),
	MYSTIC_DUST_STAFF(true, 20739, AIR_RUNE, EARTH_RUNE),
	MUD_STAFF(true, 6562, WATER_RUNE, EARTH_RUNE),
	MYSTIC_MUD_STAFF(true, 6563, WATER_RUNE, EARTH_RUNE),
	SMOKE_STAFF(true, 11998, FIRE_RUNE, AIR_RUNE),
	MYSTIC_SMOKE_STAFF(true, 12000, FIRE_RUNE, AIR_RUNE),
	STEAM_STAFF(true, 11787, WATER_RUNE, FIRE_RUNE),
	STEAM_STAFF_OR(true, 12795, WATER_RUNE, FIRE_RUNE),
	MYSTIC_STEAM_STAFF(true, 11789, WATER_RUNE, FIRE_RUNE),
	MYSTIC_STEAM_STAFF_OR(true, 12796, WATER_RUNE, FIRE_RUNE),
	LAVA_STAFF(true, 3053, EARTH_RUNE, FIRE_RUNE),
	LAVA_STAFF_OR(true, 21198, EARTH_RUNE, FIRE_RUNE),
	MYSTIC_LAVA_STAFF(true, 3054, EARTH_RUNE, FIRE_RUNE),
	MYSTIC_LAVA_STAFF_OR(true, 21200, EARTH_RUNE, FIRE_RUNE),
	TWINFLAME_STAFF(true, 30634, WATER_RUNE, FIRE_RUNE),

	// Other
	BRYOPHYTAS_STAFF_CHARGED(true, 22370, NATURE_RUNE);

	private final boolean requiresEquipped;
	private final int id;
	private final HashSet<Integer> provides = new HashSet<>();

	RuneProvider(int id)
	{
		this.requiresEquipped = false;
		this.id = id;
		this.provides.add(id);
	}

	RuneProvider(boolean requiresEquipped, int id, RuneProvider... provides)
	{
		this.requiresEquipped = requiresEquipped;
		this.id = id;
		for (RuneProvider runeProvider : provides) this.provides.addAll(runeProvider.getProvides());
	}

	private static final HashSet<Integer> EQUIPPED_PROVIDERS = new HashSet<>();
	private static final HashSet<Integer> INV_PROVIDERS = new HashSet<>();
	private static final HashMap<Integer, HashSet<Integer>> PROVIDER_TO_PROVIDED = new HashMap<>();

	static
	{
		for (RuneProvider runeProvider : RuneProvider.values())
		{
			PROVIDER_TO_PROVIDED.put(runeProvider.getId(), runeProvider.getProvides());
			if (runeProvider.isRequiresEquipped())
			{
				EQUIPPED_PROVIDERS.add(runeProvider.getId());
			} else {
				INV_PROVIDERS.add(runeProvider.getId());
			}
		}
	}

	public static boolean isEquippedProvider(int id) { return EQUIPPED_PROVIDERS.contains(id); }
	public static boolean isInvProvider(int id) { return INV_PROVIDERS.contains(id); }
	public static HashSet<Integer> getProvidedRunes(int id) { return PROVIDER_TO_PROVIDED.get(id); }
}

package com.chanceman.menus;

import com.chanceman.ChanceManPlugin;
import com.chanceman.managers.UnlockedItemsManager;
import net.runelite.api.*;
import net.runelite.api.coords.WorldArea;
import net.runelite.api.coords.WorldPoint;
import net.runelite.api.gameval.InventoryID;
import net.runelite.api.gameval.ItemID;
import net.runelite.api.events.GameTick;
import net.runelite.api.widgets.Widget;
import net.runelite.client.eventbus.Subscribe;

import javax.inject.Inject;
import javax.inject.Singleton;
import java.util.*;

@Singleton
public class Restrictions
{
	private static final int[] RUNE_POUCH_TYPE_VARBITS = {
			29,    // RUNE_POUCH_RUNE1
			1622,  // RUNE_POUCH_RUNE2
			1623,  // RUNE_POUCH_RUNE3
			14285, // RUNE_POUCH_RUNE4
			15373, // RUNE_POUCH_RUNE5
			15374  // RUNE_POUCH_RUNE6
	};

	private static final int[] RUNE_POUCH_AMOUNT_VARBITS = {
			1624,  // RUNE_POUCH_AMOUNT1
			1625,  // RUNE_POUCH_AMOUNT2
			1626,  // RUNE_POUCH_AMOUNT3
			14286, // RUNE_POUCH_AMOUNT4
			15375, // RUNE_POUCH_AMOUNT5
			15376  // RUNE_POUCH_AMOUNT6
	};

	private static final WorldArea FOUNTAIN_OF_RUNE_AREA =
			new WorldArea(3367, 3890, 13, 9, 0);

	private boolean isInFountainArea()
	{
		WorldPoint lp = client.getLocalPlayer().getWorldLocation();
		return FOUNTAIN_OF_RUNE_AREA.contains(lp);
	}

	private boolean isInLMS()
	{
		EnumSet<WorldType> worldTypes = client.getWorldType();
		return (worldTypes.contains(WorldType.LAST_MAN_STANDING));

	}

	public static final int SPELL_REQUIREMENT_OVERLAY_NORMAL = 14287051;
	public static final int AUTOCAST_REQUIREMENT_OVERLAY_NORMAL = 13172738;

	@Inject private ChanceManPlugin plugin;
	@Inject private Client client;
	@Inject private UnlockedItemsManager unlockedItemsManager;
	private final Set<SkillOp> enabledSkillOps = EnumSet.noneOf(SkillOp.class);
	private final HashSet<Integer> availableRunes = new HashSet<>();

	@Subscribe
	public void onGameTick(GameTick event)
	{
		if (!unlockedItemsManager.ready()) return;
		enabledSkillOps.clear();
		availableRunes.clear();

		ItemContainer equippedItems = client.getItemContainer(InventoryID.WORN);
		ItemContainer inventoryItems = client.getItemContainer(InventoryID.INV);

		if (equippedItems != null)
		{
			Arrays.stream(equippedItems.getItems()).forEach(item -> {
				int id = item.getId();
				SkillItem skillItem = SkillItem.fromId(id);
				if (skillItem != null && !skillItem.isRequiresUnlock())
				{
					enabledSkillOps.add(skillItem.getSkillOp());
					return;
				}

				if (shouldSkipItem(id)) return;
				if (RuneProvider.isEquippedProvider(id))
					availableRunes.addAll(RuneProvider.getProvidedRunes(id));
				if (skillItem != null) enabledSkillOps.add(skillItem.getSkillOp());
			});
		}

		if (inventoryItems != null)
		{
			Arrays.stream(inventoryItems.getItems()).forEach(item -> {
				int id = item.getId();
				SkillItem skillItem = SkillItem.fromId(id);
				if (skillItem != null && !skillItem.isRequiresUnlock())
				{
					enabledSkillOps.add(skillItem.getSkillOp());
					return;
				}

				if (shouldSkipItem(id)) return;
				if (RuneProvider.isInvProvider(id))
					availableRunes.addAll(RuneProvider.getProvidedRunes(id));
				if (skillItem != null) enabledSkillOps.add(skillItem.getSkillOp());
			});
		}

		EnumComposition pouchEnum = client.getEnum(EnumID.RUNEPOUCH_RUNE);
		for (int i = 0; i < 6; i++)
		{
			int qty     = client.getVarbitValue(RUNE_POUCH_AMOUNT_VARBITS[i]);
			int typeIdx = client.getVarbitValue(RUNE_POUCH_TYPE_VARBITS[i]);
			if (qty <= 0)
			{
				continue;
			}

			int runeId = pouchEnum.getIntValue(typeIdx);
			if (shouldSkipItem(runeId))
			{
				continue;
			}

			if (RuneProvider.isInvProvider(runeId))
			{
				availableRunes.addAll(RuneProvider.getProvidedRunes(runeId));
			}
		}
	}

	public boolean isSkillOpEnabled(String option)
	{
		SkillOp op = SkillOp.fromString(option);
		return enabledSkillOps.contains(op);
	}

	private boolean shouldSkipItem(int id)
	{
		if (!plugin.isInPlay(id))
		{
			return !(RuneProvider.isEquippedProvider(id)
					|| RuneProvider.isInvProvider(id));
		}
		return !unlockedItemsManager.isUnlocked(id);
	}

	public boolean isSpellOpEnabled(String spellName)
	{
		if (isInFountainArea() || isInLMS()) { return true; }
		BlightedSack sack = BlightedSack.fromSpell(spellName);
		if (sack != null)
		{
			int sackId = sack.getSackItemId();
			ItemContainer inv = client.getItemContainer(InventoryID.INV);
			if (inv != null	&& (sackId == ItemID.BLIGHTED_SACK_SURGE || unlockedItemsManager.isUnlocked(sackId)))
			{
				for (Item item : inv.getItems())
				{
					if (item.getId() == sackId)
					{
						return true;
					}
				}
			}
		}

		Widget autocastOverlay = client.getWidget(AUTOCAST_REQUIREMENT_OVERLAY_NORMAL);
		if (autocastOverlay != null) return processChildren(autocastOverlay);

		Widget spellOverlay = client.getWidget(SPELL_REQUIREMENT_OVERLAY_NORMAL);
		if (spellOverlay != null) return processChildren(spellOverlay);
		return false;
	}

	public boolean processChildren(Widget widget)
	{
		Widget[] children = widget.getDynamicChildren();
		if (children == null) return true;

		for (Widget child : children)
		{
			int id = child.getItemId();
			if (id == -1) continue;

			if (plugin.isInPlay(id) && !availableRunes.contains(id))
				return false;
		}
		return true;
	}
}

package com.chanceman.menus;

import lombok.Getter;

@Getter
public enum EnabledUI
{
	BANK(12),
	DEPOSIT_BOX(192);

	private final int id;

	EnabledUI(int id) {
		this.id = id;
	}
}

package com.chanceman;

import net.runelite.client.RuneLite;
import net.runelite.client.externalplugins.ExternalPluginManager;

public class ExamplePluginTest
{
	public static void main(String[] args) throws Exception
	{
		ExternalPluginManager.loadBuiltin(ChanceManPlugin.class);
		RuneLite.main(args);
	}
}
