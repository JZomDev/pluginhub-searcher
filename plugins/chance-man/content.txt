package com.chanceman;

import lombok.Getter;
import lombok.Setter;
import net.runelite.api.ChatMessageType;
import net.runelite.api.Client;
import net.runelite.api.ItemComposition;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.game.ItemManager;
import net.runelite.client.callback.ClientThread;

import javax.inject.Inject;
import javax.inject.Singleton;
import java.util.*;
import java.util.concurrent.ConcurrentLinkedQueue;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

/**
 * Manages the roll animation for unlocking items.
 * It processes roll requests asynchronously and handles the roll animation through the overlay.
 */
@Singleton
public class RollAnimationManager
{
    @Inject private ItemManager itemManager;
    @Inject private Client client;
    @Inject private ChatMessageManager chatMessageManager;
    @Inject private ClientThread clientThread;
    @Inject private UnlockedItemsManager unlockedManager;
    @Inject private ChanceManOverlay overlay;

    @Setter private HashSet<Integer> allTradeableItems;
    private final Queue<Integer> rollQueue = new ConcurrentLinkedQueue<>();
    private ExecutorService executor = Executors.newSingleThreadExecutor();
    private volatile boolean isRolling = false;
    private final int rollDuration = 4000; // Continuous phase duration (ms)
    private final int highlightDuration = 1500; // Highlight phase (ms)
    private final Random random = new Random();

    @Getter
    @Setter
    private volatile boolean manualRoll = false;

    /**
     * Enqueues an item ID for the roll animation.
     *
     * @param itemId The item ID to be rolled.
     */
    public void enqueueRoll(int itemId)
    {
        rollQueue.offer(itemId);
    }

    /**
     * Processes the roll queue by initiating a roll animation if not already rolling.
     */
    public void process()
    {
        if (!isRolling && !rollQueue.isEmpty())
        {
            int queuedItemId = rollQueue.poll();
            isRolling = true;
            executor.submit(() -> performRoll(queuedItemId));
        }
    }

    /**
     * Performs the roll animation, unlocking the final item and sending a chat message.
     */
    private void performRoll(int queuedItemId)
    {
        overlay.startRollAnimation(0, rollDuration, this::getRandomLockedItem);
        try {
            Thread.sleep(rollDuration + highlightDuration);
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        }
        int finalRolledItem = overlay.getFinalItem();
        unlockedManager.unlockItem(finalRolledItem);
        final boolean wasManualRoll = isManualRoll();
        clientThread.invoke(() -> {
            String message;
            if (wasManualRoll)
            {
                message = "Unlocked " + "<col=267567>" + getItemName(finalRolledItem) + "</col>" +
                      " by" + "<col=ff0000> pressing a button</col>";
            }
            else
            {
                message = "Unlocked " + "<col=267567>" + getItemName(finalRolledItem) + "</col>"
                        + " by rolling " + "<col=ff0000>" + getItemName(queuedItemId) + "</col>";
            }
            client.addChatMessage(ChatMessageType.GAMEMESSAGE, "", message, null);
        });
        setManualRoll(false);
        isRolling = false;
    }

    /**
     * Checks if a roll animation is currently in progress.
     *
     * @return true if a roll is in progress, false otherwise.
     */
    public boolean isRolling() {
        return isRolling;
    }

    /**
     * Retrieves a random locked item from the list of tradeable items.
     *
     * @return A random locked item ID, or a fallback if all items are unlocked.
     */
    public int getRandomLockedItem()
    {
        List<Integer> locked = new ArrayList<>();
        for (int id : allTradeableItems)
        {
            if (!unlockedManager.isUnlocked(id))
            {
                locked.add(id);
            }
        }
        if (locked.isEmpty())
        {
            int fallback = overlay.getFinalItem();
            return fallback;
        }
        int selected = locked.get(random.nextInt(locked.size()));
        return selected;
    }

    public String getItemName(int itemId)
    {
        ItemComposition comp = itemManager.getItemComposition(itemId);
        return comp != null ? comp.getName() : "Unknown";
    }

    public void startUp() {
        if (executor == null || executor.isShutdown() || executor.isTerminated()) {
            executor = Executors.newSingleThreadExecutor();
        }
    }

    /**
     * Shuts down the roll animation executor service.
     */
    public void shutdown()
    {
        executor.shutdownNow();
    }
}

package com.chanceman;

import com.chanceman.account.AccountManager;
import com.google.gson.Gson;
import com.google.gson.reflect.TypeToken;
import lombok.Setter;
import lombok.extern.slf4j.Slf4j;

import javax.inject.Inject;
import java.io.File;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.lang.reflect.Type;
import java.nio.file.Path;
import java.util.Collections;
import java.util.HashSet;
import java.util.LinkedHashSet;
import java.util.Set;
import java.util.concurrent.ExecutorService;

import static net.runelite.client.RuneLite.RUNELITE_DIR;

/**
 * Manages the set of rolled items.
 * This class persists the rolled item IDs to a JSON file so that rolled items remain tracked across sessions.
 */
@Slf4j
public class RolledItemsManager
{
    private final Set<Integer> rolledItems = Collections.synchronizedSet(new LinkedHashSet<>());
    @Inject private AccountManager accountManager;
    @Inject private Gson gson;
    @Setter private ExecutorService executor;

    private File getFile()
    {
        return Path.of(RUNELITE_DIR.getPath(), "chanceman", accountManager.getPlayerName(), "chanceman_rolled.json").toFile();
    }

	/**
     * Checks if an item has been rolled.
     *
     * @param itemId The item ID.
     * @return true if the item has been rolled, false otherwise.
     */
    public boolean isRolled(int itemId)
    {
        return rolledItems.contains(itemId);
    }

    /**
     * Marks an item as rolled and saves the state.
     *
     * @param itemId The item ID to mark as rolled.
     */
    public void markRolled(int itemId)
    {
        rolledItems.add(itemId);
        saveRolledItems();
    }

    /**
     * Loads the set of rolled items from the JSON file.
     */
    public void loadRolledItems()
    {
        rolledItems.clear();
        executor.submit(() -> {
            File file = getFile();
            if (!file.exists())
            {
                file.getParentFile().mkdirs();
                return;
            }
            try (FileReader reader = new FileReader(file))
            {
                Type setType = new TypeToken<Set<Integer>>() {}.getType();
                Set<Integer> loaded = gson.fromJson(reader, setType);
                if (loaded != null)
                {
                    rolledItems.addAll(loaded);
                }
            }
            catch (IOException e)
            {
                log.error("Error loading rolled items", e);
            }
        });
    }

    /**
     * Saves the current set of rolled items to the JSON file.
     */
    public synchronized void saveRolledItems()
    {
        executor.submit(() -> {
            File file = getFile();
            file.getParentFile().mkdirs();
            try (FileWriter writer = new FileWriter(file))
            {
                gson.toJson(rolledItems, writer);
            }
            catch (IOException e)
            {
                log.error("Error saving rolled items", e);
            }
        });
    }

    /**
     * Retrieves an unmodifiable set of rolled item IDs.
     *
     * @return An unmodifiable set of rolled item IDs.
     */
    public Set<Integer> getRolledItems()
    {
        return Collections.unmodifiableSet(rolledItems);
    }
}

package com.chanceman;


import com.chanceman.account.AccountChanged;
import com.chanceman.account.AccountManager;
import com.chanceman.filters.EnsouledHeadMapping;
import com.chanceman.menus.ActionHandler;
import com.chanceman.filters.ItemsFilter;
import com.google.gson.Gson;
import com.google.inject.Provides;
import lombok.Getter;
import net.runelite.api.*;
import net.runelite.api.events.*;
import net.runelite.api.widgets.Widget;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.eventbus.EventBus;
import net.runelite.client.game.ItemManager;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.plugins.PluginDescriptor;
import net.runelite.client.ui.ClientToolbar;
import net.runelite.client.ui.NavigationButton;
import net.runelite.client.ui.overlay.OverlayManager;
import net.runelite.client.util.ImageUtil;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.config.ConfigManager;
import javax.inject.Inject;
import javax.swing.*;
import java.awt.image.BufferedImage;
import java.util.*;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

@PluginDescriptor(
        name = "ChanceMan",
        description = "Locks tradeable items until unlocked via a random roll.",
        tags = {"osrs", "chance", "roll", "lock", "unlock"}
)
public class ChanceManPlugin extends Plugin
{
    @Inject
    private Client client;
    @Inject
    private ClientThread clientThread;
    @Inject
    private ClientToolbar clientToolbar;
    @Inject
    private OverlayManager overlayManager;
    @Inject
    private ChatMessageManager chatMessageManager;
    @Inject
    private ItemManager itemManager;
    @Inject
    private ChanceManOverlay chanceManOverlay;
    @Inject
    private Gson gson;
    @Inject
    private ChanceManConfig config;
    @Inject
    private ConfigManager configManager;
    @Inject
    private AccountManager accountManager;
    @Inject
    private UnlockedItemsManager unlockedItemsManager;
    @Inject
    private RolledItemsManager rolledItemsManager;
    @Inject
    private RollAnimationManager rollAnimationManager;
    @Inject
    private EventBus eventBus;
    @Inject
    private ItemsFilter itemsFilter;

    private ChanceManPanel chanceManPanel;
    private NavigationButton navButton;
    private ExecutorService fileExecutor;
    @Getter private final HashSet<Integer> allTradeableItems = new LinkedHashSet<>();
    private static final int GE_SEARCH_BUILD_SCRIPT = 751;

    @Provides
    ChanceManConfig provideConfig(ConfigManager configManager)
    {
        return configManager.getConfig(ChanceManConfig.class);
    }

    @Override
    protected void startUp() throws Exception
    {
        getInjector().getInstance(ActionHandler.class).startUp();
        eventBus.register(accountManager);
        overlayManager.add(chanceManOverlay);
        fileExecutor = Executors.newSingleThreadExecutor();
        unlockedItemsManager.setExecutor(fileExecutor);
        rolledItemsManager.setExecutor(fileExecutor);
        rollAnimationManager.startUp();
        if (!isNormalWorld())
        {
            return;
        }
        refreshTradeableItems();

        chanceManPanel = new ChanceManPanel(
                unlockedItemsManager, rolledItemsManager, itemManager, allTradeableItems, clientThread,
                rollAnimationManager
        );
        BufferedImage icon = ImageUtil.loadImageResource(
                getClass(), "/net/runelite/client/plugins/chanceman/icon.png");
        navButton = NavigationButton.builder()
                                    .tooltip("ChanceMan")
                                    .icon(icon)
                                    .priority(5)
                                    .panel(chanceManPanel)
                                    .build();
        clientToolbar.addNavigation(navButton);
        overlayManager.add(chanceManOverlay);

        accountManager.init();
    }

    @Override
    protected void shutDown() throws Exception
    {
        eventBus.unregister(accountManager);
        if (clientToolbar != null && navButton != null)
        {
            clientToolbar.removeNavigation(navButton);
        }
        if (overlayManager != null)
        {
            overlayManager.remove(chanceManOverlay);
        }
        if (rollAnimationManager != null)
        {
            rollAnimationManager.shutdown();
        }
        if (fileExecutor != null)
        {
            fileExecutor.shutdownNow();
        }
        getInjector().getInstance(ActionHandler.class).shutDown();

        // Reset plugin state for a fresh initialization on restart.
        chanceManPanel = null;
        navButton = null;
        fileExecutor = null;
        allTradeableItems.clear();
        accountManager.reset();
    }

    /**
     * Refreshes the list of tradeable item IDs based on the current configuration.
     */
    public void refreshTradeableItems() {
        clientThread.invokeLater(() -> {
            allTradeableItems.clear();
            for (int i = 0; i < 40000; i++) {
                ItemComposition comp = itemManager.getItemComposition(i);
                if (comp != null && comp.isTradeable() && !isNotTracked(i)
                        && !ItemsFilter.isBlocked(i, config.enableFlatpacks(), config.enableItemSets())) {
                    if (config.freeToPlay() && comp.isMembers()) {
                        continue;
                    }
                    if (!ItemsFilter.isPoisonEligible(i, config.requireWeaponPoison(),
                            unlockedItemsManager.getUnlockedItems())) {
                        continue;
                    }
                    allTradeableItems.add(i);
                }
            }
            rollAnimationManager.setAllTradeableItems(allTradeableItems);
            if (chanceManPanel != null) {
                SwingUtilities.invokeLater(() -> chanceManPanel.updatePanel());
            }
        });
    }


    @Subscribe
    public void onConfigChanged(net.runelite.client.events.ConfigChanged event)
    {
        if (!event.getGroup().equals("chanceman")) { return; }
        if (event.getKey().equals("freeToPlay")) { refreshTradeableItems(); }
        if (event.getKey().equals("enableFlatpacks")) { refreshTradeableItems(); }
        if (event.getKey().equals("enableItemSets")) { refreshTradeableItems(); }
        if (event.getKey().equals("requireWeaponPoison")) { refreshTradeableItems(); }
    }

    @Subscribe
    private void onAccountChanged(AccountChanged event)
    {
        unlockedItemsManager.loadUnlockedItems();
        rolledItemsManager.loadRolledItems();
        if (chanceManPanel != null)
        {
            SwingUtilities.invokeLater(() -> chanceManPanel.updatePanel());
        }
    }

    @Subscribe
    public void onGameTick(GameTick event)
    {
        rollAnimationManager.process();
        if (chanceManPanel != null)
        {
            SwingUtilities.invokeLater(() -> chanceManPanel.updatePanel());
        }
    }

    @Subscribe
    public void onScriptPostFired(ScriptPostFired event)
    {
        if (event.getScriptId() == GE_SEARCH_BUILD_SCRIPT) { killSearchResults(); }
    }

    private void killSearchResults() {
        Widget geSearchResults = client.getWidget(162, 51);
        if (geSearchResults == null) {
            return;
        }
        Widget[] children = geSearchResults.getDynamicChildren();
        if (children == null || children.length < 2 || children.length % 3 != 0) {
            return;
        }
        Set<Integer> unlocked = unlockedItemsManager.getUnlockedItems();
        for (int i = 0; i < children.length; i += 3) {
            int offerItemId = children[i + 2].getItemId();
            if (!unlocked.contains(offerItemId)) {
                children[i].setHidden(true);
                children[i + 1].setOpacity(70);
                children[i + 2].setOpacity(70);
            }
        }
    }

    @Subscribe
    public void onItemSpawned(ItemSpawned event)
    {
        if (!accountManager.ready()) return;
        if (!isNormalWorld()) return;

        TileItem tileItem = (TileItem) event.getItem();
        int itemId = tileItem.getId();
        ItemComposition comp = itemManager.getItemComposition(itemId);
        String name = (comp != null && comp.getName() != null) ? comp.getName() : tileItem.toString();
        if (name.toLowerCase().contains("ensouled")) {
            int mappedId = ItemsFilter.getEnsouledHeadId(name);
            if (mappedId != EnsouledHeadMapping.DEFAULT_ENSOULED_HEAD_ID) { itemId = mappedId; }
        }
        int canonicalItemId = itemManager.canonicalize(itemId);
        if (!isTradeable(canonicalItemId) || isNotTracked(canonicalItemId))
        {
            return;
        }
        if (tileItem.getOwnership() != TileItem.OWNERSHIP_SELF)
        {
            return;
        }
        if (rolledItemsManager == null)
        {
            return;
        }
        if (!rolledItemsManager.isRolled(canonicalItemId))
        {
            rollAnimationManager.enqueueRoll(canonicalItemId);
            rolledItemsManager.markRolled(canonicalItemId);
        }
    }

    @Subscribe
    public void onItemContainerChanged(ItemContainerChanged event)
    {
        if (!accountManager.ready()) return;
        if (event.getContainerId() == 93)
        {
            Set<Integer> processed = new HashSet<>();
            for (net.runelite.api.Item item : event.getItemContainer().getItems())
            {
                int rawItemId = item.getId();
                int canonicalId = itemManager.canonicalize(rawItemId);
                if (!isTradeable(canonicalId) || isNotTracked(canonicalId))
                {
                    continue;
                }
                if (!processed.contains(canonicalId) && !rolledItemsManager.isRolled(canonicalId))
                {
                    rollAnimationManager.enqueueRoll(canonicalId);
                    rolledItemsManager.markRolled(canonicalId);
                    processed.add(canonicalId);
                }
            }
        }
    }

    public boolean isNormalWorld()
    {
        EnumSet<WorldType> worldTypes = client.getWorldType();
        return !(worldTypes.contains(WorldType.DEADMAN)
                || worldTypes.contains(WorldType.SEASONAL)
                || worldTypes.contains(WorldType.BETA_WORLD)
                || worldTypes.contains(WorldType.PVP_ARENA)
                || worldTypes.contains(WorldType.QUEST_SPEEDRUNNING)
                || worldTypes.contains(WorldType.TOURNAMENT_WORLD));
    }

    public boolean isTradeable(int itemId)
    {
        ItemComposition comp = itemManager.getItemComposition(itemId);
        return comp != null && comp.isTradeable();
    }

    public boolean isNotTracked(int itemId)
    {
        return itemId == 995 || itemId == 13191 || itemId == 13190 ||
                itemId == 7587 || itemId == 7588 || itemId == 7589 || itemId == 7590 || itemId == 7591;
    }

    public boolean isInPlay(int itemId)
    {
        return allTradeableItems.contains(itemId);
    }

    public ItemManager getItemManager() { return itemManager; }

}

package com.chanceman;

import net.runelite.client.config.Config;
import net.runelite.client.config.ConfigGroup;
import net.runelite.client.config.ConfigItem;

@ConfigGroup("chanceman")
public interface ChanceManConfig extends Config
{
    @ConfigItem(
            keyName = "freeToPlay",
            name = "Free To Play Mode",
            description = "Only allow free-to-play items",
            position = 1
    )
    default boolean freeToPlay()
    {
        return false;
    }

    @ConfigItem(
            keyName = "enableItemSets",
            name = "Roll Item Sets",
            description = "Include item set items in the rollable items list. Disabling this will exclude any" +
                    " item set items from random rolls.",
            position = 2
    )
    default boolean enableItemSets() { return true; }

    @ConfigItem(
            keyName = "enableFlatpacks",
            name = "Roll Flatpacks",
            description = "Include flatpacks in the rollable items list. Disabling this will prevent" +
                    " flatpacks from being rolled.",
            position = 3
    )
    default boolean enableFlatpacks() { return true; }

    @ConfigItem(
            keyName = "requireWeaponPoison",
            name = "Weapon Poison Unlock Requirements",
            description = "Force poison variants to roll only if both the base weapon and the corresponding" +
                    " weapon poison are unlocked. (Disabling this will allow poisoned variants to roll even if " +
                    "the poison is locked.)",
            position = 4
    )
    default boolean requireWeaponPoison() { return true; }
}

package com.chanceman.account;

import com.chanceman.RolledItemsManager;
import com.chanceman.UnlockedItemsManager;
import lombok.Getter;
import lombok.Setter;
import net.runelite.api.Client;
import net.runelite.api.GameState;
import net.runelite.api.Player;
import net.runelite.api.events.AccountHashChanged;
import net.runelite.api.events.ClientTick;
import net.runelite.api.events.GameStateChanged;
import net.runelite.client.eventbus.EventBus;
import net.runelite.client.eventbus.Subscribe;

import javax.inject.Inject;
import javax.inject.Singleton;

/**
 * Monitors for account changes and updates the stored display name.
 */
@Singleton
public class AccountManager
{

	@Inject
	private Client client;

	@Inject
	private UnlockedItemsManager unlockedItemsManager;

	@Inject
	private RolledItemsManager rolledItemsManager;

	@Inject
	private EventBus eventBus;

	private long hash = -1;
	@Getter @Setter private volatile String playerName;
	private boolean nameSet = false;

	public boolean ready() { return hash != -1 && nameSet; }

	public void init()
	{
		if (client.getGameState() == GameState.LOGGED_IN && client.getAccountHash() != -1)
		{
			hash = client.getAccountHash();
			nameSet = false;
		}
	}

	@Subscribe
	private void onAccountHashChanged(AccountHashChanged event)
	{
		long newHash = client.getAccountHash();
		if (hash != newHash)
		{
			hash = newHash;
			nameSet = false; // Player is null at this point, so name is set in onClientTick
		}
	}

	@Subscribe
	private void onClientTick(ClientTick event)
	{
		if (client.getGameState().getState() < GameState.LOADING.getState()) return;
		if (hash == -1) return;
		if (nameSet) return;

		Player player = client.getLocalPlayer();
		if (player == null) return;

		String name = player.getName();
		if (name == null) return;

		setPlayerName(name);
		nameSet = true;
		emit();
	}

	@Subscribe
	private void onGameStateChanged(GameStateChanged event)
	{
		if (event.getGameState() == GameState.LOGIN_SCREEN && hash != -1)
		{
			reset();
		}
	}

	public void reset() {
		hash = -1;
		setPlayerName(null);
		emit();
	}

	private void emit()
	{
		eventBus.post(new AccountChanged(hash, playerName));
	}
}

package com.chanceman.account;

import lombok.Getter;

@Getter
public class AccountChanged
{
	private final long hash;
	private final String playerName;
	private final boolean loggedIn;

	public AccountChanged(long hash, String playerName)
	{
		this.hash = hash;
		this.playerName = playerName;
		this.loggedIn = hash != -1;
	}

	@Override
	public String toString() {
		return "AccountChanged{" +
				"hash=" + hash +
				", playerName='" + playerName + '\'' +
				", loggedIn=" + loggedIn +
				'}';
	}
}

package com.chanceman;

import net.runelite.api.ItemComposition;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.game.ItemManager;
import net.runelite.client.ui.PluginPanel;
import net.runelite.client.util.LinkBrowser;

import javax.swing.*;
import javax.swing.border.*;
import java.awt.*;
import java.awt.event.KeyAdapter;
import java.awt.event.KeyEvent;
import java.awt.image.BufferedImage;
import java.util.*;
import java.util.List;
import java.util.function.Consumer;
import javax.swing.JColorChooser;

/**
 * Panel for displaying rolled and unlocked items.
 * It provides UI for manual roll actions, search/filter functionality,
 * and displays each item with its icon and full item name.
 * Each item panel shows a tooltip on both the icon and the panel with the item name.
 */
public class ChanceManPanel extends PluginPanel
{
    private final UnlockedItemsManager unlockedItemsManager;
    private final RolledItemsManager rolledItemsManager;
    private final ItemManager itemManager;
    private final HashSet<Integer> allTradeableItems;
    private final ClientThread clientThread;
    private final RollAnimationManager rollAnimationManager;

    // Caches for item icons and names
    private final Map<Integer, ImageIcon> itemIconCache = new HashMap<>();
    private final Map<Integer, String> itemNameCache = new HashMap<>();

    // CardLayout panel to show either Rolled or Unlocked view
    private final JPanel centerCardPanel = new JPanel(new CardLayout());
    private final JPanel rolledContentPanel = new JPanel();
    private final JPanel unlockedContentPanel = new JPanel();

    // View selection row: 3 buttons (swap, filter unlocked-not-rolled, filter unlocked-and-rolled)
    private final JButton swapViewButton = new JButton("🔄");
    private final JToggleButton filterUnlockedNotRolledButton = new JToggleButton("🔓");
    private final JToggleButton filterUnlockedAndRolledButton = new JToggleButton("🔀");

    // Flag for current view: true = showing Unlocked, false = showing Rolled
    private boolean showingUnlocked = true;

    // Search text
    private String searchText = "";

    // Single count label at the bottom
    private final JLabel countLabel = new JLabel("Unlocked: 0/0");

    // Roll button for manual roll actions
    private final JButton rollButton = new JButton("Roll");

    // Active filter: "NONE", "UNLOCKED_NOT_ROLLED", or "UNLOCKED_AND_ROLLED"
    private String activeFilter = "NONE";

    // Join Discord Button links to discord invite
    private final JButton discordButton = new JButton();

    // Default color for item text
    private final Color defaultItemTextColor = new Color(220, 220, 220);

    // Map to hold custom text colors for specific items (key: itemId, value: chosen Color)
    private final Map<Integer, Color> itemTextColorMap = new HashMap<>();

    /**
     * Constructs a ChanceManPanel.
     *
     * @param unlockedItemsManager Manager for unlocked items.
     * @param rolledItemsManager   Manager for rolled items.
     * @param itemManager          The item manager.
     * @param allTradeableItems    List of all tradeable item IDs.
     * @param clientThread         The client thread for scheduling UI updates.
     * @param rollAnimationManager The roll animation manager to trigger animations.
     */
    public ChanceManPanel(
            UnlockedItemsManager unlockedItemsManager,
            RolledItemsManager rolledItemsManager,
            ItemManager itemManager,
            HashSet<Integer> allTradeableItems,
            ClientThread clientThread,
            RollAnimationManager rollAnimationManager
    )
    {
        this.unlockedItemsManager = unlockedItemsManager;
        this.rolledItemsManager = rolledItemsManager;
        this.itemManager = itemManager;
        this.allTradeableItems = allTradeableItems;
        this.clientThread = clientThread;
        this.rollAnimationManager = rollAnimationManager;
        init();
    }

    /**
     * Initializes the panel UI components.
     */
    private void init()
    {
        setLayout(new BorderLayout());
        setBorder(new EmptyBorder(15, 15, 15, 15));
        setBackground(new Color(37, 37, 37));

        // ========== TOP PANEL (Header, Search, Buttons Row) ==========
        JPanel topPanel = new JPanel();
        topPanel.setLayout(new BoxLayout(topPanel, BoxLayout.Y_AXIS));
        topPanel.setOpaque(false);

        // Header
        topPanel.add(buildHeaderPanel());
        topPanel.add(Box.createVerticalStrut(10));

        // Search Bar
        topPanel.add(buildSearchBar());
        topPanel.add(Box.createVerticalStrut(10));

        // Button row: 3 columns, each for one button
        JPanel buttonRowPanel = new JPanel(new GridLayout(1, 3, 10, 0));
        buttonRowPanel.setOpaque(false);

        // Style the 3 buttons identically
        styleButton(swapViewButton);
        styleToggleButton(filterUnlockedNotRolledButton);
        styleToggleButton(filterUnlockedAndRolledButton);

        // Tooltips & actions
        swapViewButton.setToolTipText("Swap between Unlocked and Rolled views");
        swapViewButton.addActionListener(e -> toggleView());

        filterUnlockedNotRolledButton.setToolTipText("Filter: Show items that are unlocked but not rolled");
        filterUnlockedNotRolledButton.addActionListener(e ->
        {
            if (filterUnlockedNotRolledButton.isSelected())
            {
                activeFilter = "UNLOCKED_NOT_ROLLED";
                filterUnlockedAndRolledButton.setSelected(false);
            }
            else
            {
                activeFilter = "NONE";
            }
            updatePanel();
        });

        filterUnlockedAndRolledButton.setToolTipText("Filter: Show items that are both unlocked and rolled");
        filterUnlockedAndRolledButton.addActionListener(e ->
        {
            if (filterUnlockedAndRolledButton.isSelected())
            {
                activeFilter = "UNLOCKED_AND_ROLLED";
                filterUnlockedNotRolledButton.setSelected(false);
            }
            else
            {
                activeFilter = "NONE";
            }
            updatePanel();
        });

        // Add them in left->right order
        buttonRowPanel.add(swapViewButton);
        buttonRowPanel.add(filterUnlockedNotRolledButton);
        buttonRowPanel.add(filterUnlockedAndRolledButton);

        // Add the row to the top panel
        topPanel.add(buttonRowPanel);

        // EXTRA SPACE between the buttons row and the icon panel
        topPanel.add(Box.createVerticalStrut(10));

        add(topPanel, BorderLayout.NORTH);

        // ========== CENTER PANEL (CardLayout) ==========
        rolledContentPanel.setLayout(new BoxLayout(rolledContentPanel, BoxLayout.Y_AXIS));
        rolledContentPanel.setBackground(new Color(60, 63, 65));

        unlockedContentPanel.setLayout(new BoxLayout(unlockedContentPanel, BoxLayout.Y_AXIS));
        unlockedContentPanel.setBackground(new Color(60, 63, 65));

        JPanel rolledContainer = createTitledPanel("Rolled Items", rolledContentPanel);
        JPanel unlockedContainer = createTitledPanel("Unlocked Items", unlockedContentPanel);

        centerCardPanel.add(rolledContainer, "ROLLED");
        centerCardPanel.add(unlockedContainer, "UNLOCKED");
        add(centerCardPanel, BorderLayout.CENTER);

        // ========== BOTTOM PANEL (Count + Roll) ==========
        JPanel bottomPanel = new JPanel();
        bottomPanel.setLayout(new BoxLayout(bottomPanel, BoxLayout.Y_AXIS));
        bottomPanel.setOpaque(false);

        // Single count label
        JPanel countPanel = new JPanel(new FlowLayout(FlowLayout.CENTER, 0, 0));
        countPanel.setOpaque(false);
        countLabel.setFont(new Font("Arial", Font.BOLD, 11));
        countLabel.setForeground(new Color(220, 220, 220));
        countPanel.add(countLabel);
        bottomPanel.add(countPanel);
        bottomPanel.add(Box.createVerticalStrut(10));

        // Roll button
        JPanel rollButtonPanel = new JPanel(new FlowLayout(FlowLayout.CENTER));
        rollButtonPanel.setOpaque(false);
        rollButton.setPreferredSize(new Dimension(100, 30));
        rollButton.setFocusPainted(false);
        rollButton.setBackground(new Color(60, 63, 65));
        rollButton.setForeground(Color.WHITE);
        rollButton.setFont(new Font("SansSerif", Font.BOLD, 12));
        rollButton.addActionListener(this::performManualRoll);
        rollButtonPanel.add(rollButton);
        bottomPanel.add(rollButtonPanel);

        add(bottomPanel, BorderLayout.SOUTH);

        // Default to Unlocked view
        showingUnlocked = true;
        ((CardLayout) centerCardPanel.getLayout()).show(centerCardPanel, "UNLOCKED");
        updatePanel();
    }

    /**
     * Toggles between Unlocked view and Rolled view.
     */
    private void toggleView()
    {
        showingUnlocked = !showingUnlocked;
        CardLayout cl = (CardLayout) centerCardPanel.getLayout();
        if (showingUnlocked)
        {
            cl.show(centerCardPanel, "UNLOCKED");
        }
        else
        {
            cl.show(centerCardPanel, "ROLLED");
        }
        updatePanel();
    }

    /**
     * Creates a titled container panel that wraps the given content panel.
     *
     * @param title        The title to display on the border.
     * @param contentPanel The panel to wrap.
     * @return The container panel.
     */
    private JPanel createTitledPanel(String title, JPanel contentPanel)
    {
        JPanel container = new JPanel(new BorderLayout());
        container.setOpaque(false);

        Border line = new LineBorder(new Color(80, 80, 80));
        Border empty = new EmptyBorder(5, 5, 5, 5);
        TitledBorder titled = BorderFactory.createTitledBorder(line, title);
        titled.setTitleColor(new Color(200, 200, 200));
        container.setBorder(new CompoundBorder(titled, empty));

        JScrollPane scrollPane = new JScrollPane(
                contentPanel,
                JScrollPane.VERTICAL_SCROLLBAR_AS_NEEDED,
                JScrollPane.HORIZONTAL_SCROLLBAR_NEVER
        );
        scrollPane.setOpaque(false);
        scrollPane.getViewport().setOpaque(false);
        scrollPane.setPreferredSize(new Dimension(250, 300));

        container.add(scrollPane, BorderLayout.CENTER);
        return container;
    }

    /**
     * Styles a general JButton to match the design.
     *
     * @param button The button to style.
     */
    private void styleButton(JButton button)
    {
        button.setFocusPainted(false);
        button.setBackground(new Color(60, 63, 65));
        button.setForeground(Color.WHITE);
        button.setFont(new Font("SansSerif", Font.BOLD, 12));
        button.setPreferredSize(new Dimension(50, 30));
    }

    /**
     * Styles a JToggleButton to match the design.
     *
     * @param button The toggle button to style.
     */
    private void styleToggleButton(JToggleButton button)
    {
        button.setFocusPainted(false);
        button.setBackground(new Color(60, 63, 65));
        button.setForeground(Color.WHITE);
        button.setFont(new Font("SansSerif", Font.BOLD, 12));
        button.setPreferredSize(new Dimension(50, 30));
    }

    /**
     * Builds the header panel with an icon and title.
     *
     * @return The header panel.
     */
    private JPanel buildHeaderPanel()
    {
        JPanel headerPanel = new JPanel(new FlowLayout(FlowLayout.LEFT));
        headerPanel.setOpaque(false);

        // Header icon
        ImageIcon headerIcon = new ImageIcon(getClass().getResource("/net/runelite/client/plugins/chanceman/icon.png"));
        JLabel iconLabel = new JLabel(headerIcon);

        // Title label
        JLabel titleLabel = new JLabel("Chance Man");
        titleLabel.setFont(new Font("SansSerif", Font.BOLD, 18));
        titleLabel.setForeground(new Color(220, 220, 220));

        // Create the Discord button
        JButton discordButton = new JButton();
        discordButton.setToolTipText("Join The Chance Man Discord");
        // Scale the Discord icon to 16x16
        ImageIcon discordIcon = new ImageIcon(getClass().getResource("/net/runelite/client/plugins/chanceman/discord.png"));
        Image scaledImage = discordIcon.getImage().getScaledInstance(20, 20, Image.SCALE_SMOOTH);
        discordButton.setIcon(new ImageIcon(scaledImage));
        // Make the button look flat (no border or background)
        discordButton.setOpaque(false);
        discordButton.setContentAreaFilled(false);
        discordButton.setBorderPainted(false);
        // Add an action to open the Discord link
        discordButton.addActionListener(e -> LinkBrowser.browse("https://discord.gg/TMkAYXxncU"));

        // Assemble the header panel
        headerPanel.add(iconLabel);
        headerPanel.add(Box.createHorizontalStrut(10));
        headerPanel.add(titleLabel);
        headerPanel.add(discordButton);

        return headerPanel;
    }

    /**
     * Builds the search bar panel.
     *
     * @return The search bar panel.
     */
    private JPanel buildSearchBar()
    {
        JPanel searchBarPanel = new JPanel(new BorderLayout());
        searchBarPanel.setOpaque(false);
        searchBarPanel.setBorder(new EmptyBorder(5, 5, 5, 5));

        JPanel searchContainer = new JPanel(new BorderLayout());
        searchContainer.setBackground(new Color(30, 30, 30));
        searchContainer.setBorder(BorderFactory.createEmptyBorder(2, 5, 2, 5));

        // Search icon
        JLabel searchIcon = new JLabel("\uD83D\uDD0D");
        searchIcon.setForeground(new Color(200, 200, 200));
        searchIcon.setBorder(new EmptyBorder(0, 5, 0, 5));
        searchContainer.add(searchIcon, BorderLayout.WEST);

        // Search field
        JTextField searchField = new JTextField();
        searchField.setBackground(new Color(45, 45, 45));
        searchField.setForeground(Color.WHITE);
        searchField.setBorder(null);
        searchField.setCaretColor(Color.WHITE);
        searchField.setMaximumSize(new Dimension(Integer.MAX_VALUE, 24));
        searchField.addKeyListener(new KeyAdapter()
        {
            @Override
            public void keyReleased(KeyEvent e)
            {
                SwingUtilities.invokeLater(() ->
                {
                    searchText = searchField.getText().toLowerCase();
                    updatePanel();
                });
            }
        });
        searchContainer.add(searchField, BorderLayout.CENTER);

        // Clear label to reset search
        JLabel clearLabel = new JLabel("❌");
        clearLabel.setFont(new Font("SansSerif", Font.PLAIN, 9));
        clearLabel.setForeground(Color.RED);
        clearLabel.setBorder(new EmptyBorder(0, 6, 0, 6));
        clearLabel.setCursor(Cursor.getPredefinedCursor(Cursor.HAND_CURSOR));
        clearLabel.addMouseListener(new java.awt.event.MouseAdapter()
        {
            @Override
            public void mouseClicked(java.awt.event.MouseEvent e)
            {
                searchField.setText("");
                searchText = "";
                updatePanel();
            }
        });
        searchContainer.add(clearLabel, BorderLayout.EAST);

        searchBarPanel.add(searchContainer, BorderLayout.CENTER);
        return searchBarPanel;
    }

    /**
     * Triggers a manual roll animation when the Roll button is clicked.
     *
     * @param e The action event.
     */
    private void performManualRoll(java.awt.event.ActionEvent e)
    {
        if (rollAnimationManager.isRolling())
        {
            return;
        }
        List<Integer> locked = new ArrayList<>();
        for (int id : allTradeableItems)
        {
            if (!unlockedItemsManager.isUnlocked(id))
            {
                locked.add(id);
            }
        }
        if (locked.isEmpty())
        {
            JOptionPane.showMessageDialog(
                    this,
                    "All items are unlocked!",
                    "ChanceMan",
                    JOptionPane.INFORMATION_MESSAGE
            );
            return;
        }
        int randomItemId = locked.get(new Random().nextInt(locked.size()));
        rollAnimationManager.setManualRoll(true);
        rollAnimationManager.enqueueRoll(randomItemId);
    }

    /**
     * Main update routine: filters the active set (Unlocked or Rolled), applies search text and filter toggles,
     * updates the single count label, and then builds the item list without trailing gaps.
     */
    public void updatePanel()
    {
        clientThread.invokeLater(() ->
        {
            // Build filtered lists
            List<Integer> filteredRolled = new ArrayList<>();
            for (Integer id : rolledItemsManager.getRolledItems())
            {
                ItemComposition comp = itemManager.getItemComposition(id);
                if (comp != null)
                {
                    String name = comp.getName().toLowerCase();
                    if (searchText.isEmpty() || name.contains(searchText))
                    {
                        filteredRolled.add(id);
                    }
                }
            }

            Collections.reverse(filteredRolled);

            List<Integer> filteredUnlocked = new ArrayList<>();
            for (Integer id : unlockedItemsManager.getUnlockedItems())
            {
                ItemComposition comp = itemManager.getItemComposition(id);
                if (comp != null)
                {
                    String name = comp.getName().toLowerCase();
                    if (searchText.isEmpty() || name.contains(searchText))
                    {
                        filteredUnlocked.add(id);
                    }
                }
            }

            Collections.reverse(filteredUnlocked);

            // Apply active filter toggles
            if (activeFilter.equals("UNLOCKED_NOT_ROLLED"))
            {
                filteredUnlocked.removeIf(id -> rolledItemsManager.getRolledItems().contains(id));
                filteredRolled.clear();
            }
            else if (activeFilter.equals("UNLOCKED_AND_ROLLED"))
            {
                filteredUnlocked.removeIf(id -> !rolledItemsManager.getRolledItems().contains(id));
                filteredRolled.removeIf(id -> !unlockedItemsManager.getUnlockedItems().contains(id));
            }

            int totalTrackable = allTradeableItems.size();
            int rolledCount = rolledItemsManager.getRolledItems().size();
            int unlockedCount = unlockedItemsManager.getUnlockedItems().size();

            // Switch to the Swing thread to update the UI
            SwingUtilities.invokeLater(() ->
            {
                // If we're showing unlocked, show "Unlocked: X/Y"; otherwise "Rolled: X/Y"
                if (showingUnlocked)
                {
                    countLabel.setText("Unlocked: " + unlockedCount + "/" + totalTrackable);
                }
                else
                {
                    countLabel.setText("Rolled: " + rolledCount + "/" + totalTrackable);
                }

                // Determine which panel is active (rolled or unlocked)
                JPanel activeContentPanel = showingUnlocked ? unlockedContentPanel : rolledContentPanel;
                activeContentPanel.removeAll();

                // Decide which list of item IDs to show
                List<Integer> filteredIds = showingUnlocked ? filteredUnlocked : filteredRolled;
                for (int i = 0; i < filteredIds.size(); i++)
                {
                    int itemId = filteredIds.get(i);
                    activeContentPanel.add(createHorizontalItemPanel(itemId));

                    // Only add a vertical strut if this isn't the last item
                    if (i < filteredIds.size() - 1)
                    {
                        activeContentPanel.add(Box.createVerticalStrut(3));
                    }
                }

                activeContentPanel.revalidate();
                activeContentPanel.repaint();
            });
        });
    }

    /**
     * Creates a horizontal panel with an icon on the left and item name on the right.
     * Also sets a hover tooltip on both the panel and the icon to display the full item name.
     *
     * @param itemId The item ID.
     * @return The horizontal item panel.
     */
    private JPanel createHorizontalItemPanel(int itemId)
    {
        // Use BoxLayout on the X axis for a tight horizontal layout
        JPanel itemPanel = new JPanel();
        itemPanel.setLayout(new BoxLayout(itemPanel, BoxLayout.X_AXIS));
        itemPanel.setOpaque(false);
        itemPanel.setAlignmentX(LEFT_ALIGNMENT);

        // Create and add the icon label with fixed size
        ImageIcon icon = getItemIcon(itemId);
        JLabel iconLabel = new JLabel(icon != null ? icon : new ImageIcon());
        iconLabel.setPreferredSize(new Dimension(32, 32));
        iconLabel.setAlignmentY(Component.CENTER_ALIGNMENT);
        itemPanel.add(iconLabel);

        // Add a small horizontal gap between the icon and the name label
        itemPanel.add(Box.createHorizontalStrut(5));

        // Determine the text color for this item: either a custom color or the default
        Color textColor = itemTextColorMap.getOrDefault(itemId, defaultItemTextColor);

        // Create and add the name label with the chosen text color
        String cachedName = itemNameCache.get(itemId);
        JLabel nameLabel = new JLabel(cachedName != null ? cachedName : "Loading...");
        nameLabel.setForeground(textColor);
        nameLabel.setFont(new Font("SansSerif", Font.PLAIN, 11));
        nameLabel.setAlignmentY(Component.CENTER_ALIGNMENT);
        itemPanel.add(nameLabel);

        // If the item name is not cached, fetch it asynchronously
        if (cachedName == null)
        {
            itemPanel.setToolTipText("Loading...");
            iconLabel.setToolTipText("Loading...");
            getItemNameAsync(itemId, name -> {
                itemNameCache.put(itemId, name);
                nameLabel.setText(name);
                // Update tooltips for both the panel and the icon
                itemPanel.setToolTipText(name);
                iconLabel.setToolTipText(name);
                nameLabel.repaint();
            });
        }
        else
        {
            itemPanel.setToolTipText(cachedName);
            iconLabel.setToolTipText(cachedName);
        }

        // Constrain the panel's height to match the icon's height
        itemPanel.setMaximumSize(new Dimension(Integer.MAX_VALUE, 32));

        // Add a mouse listener to show the context menu on right-click for this specific item
        itemPanel.addMouseListener(new java.awt.event.MouseAdapter() {
            @Override
            public void mousePressed(java.awt.event.MouseEvent e) {
                if (e.isPopupTrigger()) {
                    showItemTextColorPopup(e, itemId, nameLabel);
                }
            }
            @Override
            public void mouseReleased(java.awt.event.MouseEvent e) {
                if (e.isPopupTrigger()) {
                    showItemTextColorPopup(e, itemId, nameLabel);
                }
            }
        });

        return itemPanel;
    }

    private void showItemTextColorPopup(java.awt.event.MouseEvent e, int itemId, JLabel label) {
        JPopupMenu popup = new JPopupMenu();

        JMenuItem changeColorItem = new JMenuItem("Change Text Color");
        JMenuItem resetColorItem = new JMenuItem("Reset Color");

        changeColorItem.addActionListener(ev -> {
            // Get current color or default
            Color currentColor = itemTextColorMap.getOrDefault(itemId, defaultItemTextColor);
            Color chosen = JColorChooser.showDialog(ChanceManPanel.this, "Choose Text Color", currentColor);
            if (chosen != null) {
                // Save the chosen color and update the label
                itemTextColorMap.put(itemId, chosen);
                label.setForeground(chosen);
            }
        });

        resetColorItem.addActionListener(ev -> {
            // Remove any custom color for this item and revert to default
            itemTextColorMap.remove(itemId);
            label.setForeground(defaultItemTextColor);
        });

        popup.add(changeColorItem);
        popup.add(resetColorItem);
        popup.show(e.getComponent(), e.getX(), e.getY());
    }

    /**
     * Retrieves (and caches) the item icon for a given item ID.
     *
     * @param itemId The item ID.
     * @return The ImageIcon for the item, or null if not available.
     */
    private ImageIcon getItemIcon(int itemId)
    {
        if (itemIconCache.containsKey(itemId))
        {
            return itemIconCache.get(itemId);
        }
        BufferedImage image = itemManager.getImage(itemId, 1, false);
        if (image == null)
        {
            return null;
        }
        ImageIcon icon = new ImageIcon(image);
        itemIconCache.put(itemId, icon);
        return icon;
    }

    /**
     * Asynchronously retrieves the item name for a given item ID and passes it to the callback.
     *
     * @param itemId   The item ID.
     * @param callback Consumer to receive the item name.
     */
    private void getItemNameAsync(int itemId, Consumer<String> callback)
    {
        clientThread.invokeLater(() -> {
            ItemComposition comp = itemManager.getItemComposition(itemId);
            String name = (comp != null) ? comp.getName() : "Unknown";
            SwingUtilities.invokeLater(() -> callback.accept(name));
        });
    }
}

package com.chanceman;

import com.chanceman.account.AccountManager;
import com.chanceman.filters.PoisonWeapons;
import com.google.gson.Gson;
import com.google.gson.reflect.TypeToken;
import lombok.Setter;
import lombok.extern.slf4j.Slf4j;

import javax.inject.Inject;
import javax.inject.Singleton;
import java.io.File;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.lang.reflect.Type;
import java.nio.file.Path;
import java.util.Collections;
import java.util.HashSet;
import java.util.LinkedHashSet;
import java.util.Set;
import java.util.concurrent.ExecutorService;

import static net.runelite.client.RuneLite.RUNELITE_DIR;

/**
 * Manages the set of unlocked items.
 * This class persists the unlocked item IDs to a JSON file so that items remain unlocked across sessions.
 * It uses an asynchronous executor for saving the data.
 */
@Slf4j
@Singleton
public class UnlockedItemsManager
{
    private final Set<Integer> unlockedItems = Collections.synchronizedSet(new LinkedHashSet<>());
    @Inject private AccountManager accountManager;
    @Inject private Gson gson;
    @Setter private ExecutorService executor;

    public boolean ready() { return accountManager.getPlayerName() != null; }

    private File getFile()
    {
        return Path.of(RUNELITE_DIR.getPath(), "chanceman", accountManager.getPlayerName(), "chanceman_unlocked.json").toFile();
    }

	/**
     * Checks if an item is unlocked.
     *
     * @param itemId The item ID.
     * @return true if the item is unlocked, false otherwise.
     */
    public boolean isUnlocked(int itemId)
    {
        return unlockedItems.contains(itemId);
    }

    /**
     * Unlocks an item and saves the state.
     *
     * @param itemId The item ID to unlock.
     */
    public void unlockItem(int itemId)
    {
        unlockedItems.add(itemId);
        saveUnlockedItems();
    }

    /**
     * Loads the set of unlocked items from the JSON file.
     */
    public void loadUnlockedItems()
    {
        unlockedItems.clear();
        executor.submit(() -> {
            File file = getFile();
            if (!file.exists())
            {
                file.getParentFile().mkdirs();
                return;
            }
            try (FileReader reader = new FileReader(file))
            {
                Type setType = new TypeToken<Set<Integer>>() {}.getType();
                Set<Integer> loaded = gson.fromJson(reader, setType);
                if (loaded != null)
                {
                    unlockedItems.addAll(loaded);
                }
            }
            catch (IOException e)
            {
                log.error("Error loading unlocked items", e);
            }
        });
    }

    /**
     * Saves the current set of unlocked items asynchronously to the JSON file.
     */
    public synchronized void saveUnlockedItems()
    {
        executor.submit(() -> {
            File file = getFile();
            file.getParentFile().mkdirs();
            try (FileWriter writer = new FileWriter(file))
            {
                gson.toJson(unlockedItems, writer);
            }
            catch (IOException e)
            {
                log.error("Error saving unlocked items", e);
            }
        });
    }

    /**
     * Retrieves an unmodifiable set of unlocked item IDs.
     *
     * @return An unmodifiable set of unlocked item IDs.
     */
    public Set<Integer> getUnlockedItems()
    {
        return Collections.unmodifiableSet(unlockedItems);
    }
}

package com.chanceman.filters;

import lombok.Getter;
import net.runelite.api.gameval.ItemID;
import java.util.Collections;
import java.util.HashSet;
import java.util.Set;

/**
 * Enum representing every poisonable weapon and its four variants:
 *   - Base (unpoisoned)
 *   - (p)
 *   - (p+)
 *   - (p++)
 */
@Getter
public enum PoisonWeapons {
    // Global prerequisites for poisonable weapons
    WEAPON_POISON(ItemID.WEAPON_POISON),
    WEAPON_POISON_(ItemID.WEAPON_POISON_),
    WEAPON_POISON__(ItemID.WEAPON_POISON__),

    // --- Daggers ---
    BRONZE_DAGGER(ItemID.BRONZE_DAGGER, ItemID.BRONZE_DAGGER_P, ItemID.BRONZE_DAGGER_P_, ItemID.BRONZE_DAGGER_P__),
    IRON_DAGGER(ItemID.IRON_DAGGER, ItemID.IRON_DAGGER_P, ItemID.IRON_DAGGER_P_, ItemID.IRON_DAGGER_P__),
    BONE_DAGGER(ItemID.DTTD_BONE_DAGGER, ItemID.DTTD_BONE_DAGGER_P, ItemID.DTTD_BONE_DAGGER_P_,
            ItemID.DTTD_BONE_DAGGER_P__),
    BLACK_DAGGER(ItemID.BLACK_DAGGER, ItemID.BLACK_DAGGER_P, ItemID.BLACK_DAGGER_P_, ItemID.BLACK_DAGGER_P__),
    WHITE_DAGGER(ItemID.WHITE_DAGGER, ItemID.WHITE_DAGGER_P, ItemID.WHITE_DAGGER_P_, ItemID.WHITE_DAGGER_P__),
    STEEL_DAGGER(ItemID.STEEL_DAGGER, ItemID.STEEL_DAGGER_P, ItemID.STEEL_DAGGER_P_, ItemID.STEEL_DAGGER_P__),
    MITHRIL_DAGGER(ItemID.MITHRIL_DAGGER, ItemID.MITHRIL_DAGGER_P, ItemID.MITHRIL_DAGGER_P_, ItemID.MITHRIL_DAGGER_P__),
    ADAMANT_DAGGER(ItemID.ADAMANT_DAGGER, ItemID.ADAMANT_DAGGER_P, ItemID.ADAMANT_DAGGER_P_, ItemID.ADAMANT_DAGGER_P__),
    RUNE_DAGGER(ItemID.RUNE_DAGGER, ItemID.RUNE_DAGGER_P, ItemID.RUNE_DAGGER_P_, ItemID.RUNE_DAGGER_P__),
    DRAGON_DAGGER(ItemID.DRAGON_DAGGER, ItemID.DRAGON_DAGGER_P, ItemID.DRAGON_DAGGER_P_, ItemID.DRAGON_DAGGER_P__),
    ABYSSAL_DAGGER(ItemID.ABYSSAL_DAGGER, ItemID.ABYSSAL_DAGGER_P, ItemID.ABYSSAL_DAGGER_P_, ItemID.ABYSSAL_DAGGER_P__),

    // --- Javelins ---
    BRONZE_JAVELIN(ItemID.BRONZE_JAVELIN, ItemID.BRONZE_JAVELIN_P, ItemID.BRONZE_JAVELIN_P_, ItemID.BRONZE_JAVELIN_P__),
    IRON_JAVELIN(ItemID.IRON_JAVELIN, ItemID.IRON_JAVELIN_P, ItemID.IRON_JAVELIN_P_, ItemID.IRON_JAVELIN_P__),
    STEEL_JAVELIN(ItemID.STEEL_JAVELIN, ItemID.STEEL_JAVELIN_P, ItemID.STEEL_JAVELIN_P_, ItemID.STEEL_JAVELIN_P__),
    MITHRIL_JAVELIN(ItemID.MITHRIL_JAVELIN, ItemID.MITHRIL_JAVELIN_P, ItemID.MITHRIL_JAVELIN_P_,
            ItemID.MITHRIL_JAVELIN_P__),
    ADAMANT_JAVELIN(ItemID.ADAMANT_JAVELIN, ItemID.ADAMANT_JAVELIN_P, ItemID.ADAMANT_JAVELIN_P_,
            ItemID.ADAMANT_JAVELIN_P__),
    RUNE_JAVELIN(ItemID.RUNE_JAVELIN, ItemID.RUNE_JAVELIN_P, ItemID.RUNE_JAVELIN_P_, ItemID.RUNE_JAVELIN_P__),
    DRAGON_JAVELIN(ItemID.DRAGON_JAVELIN, ItemID.DRAGON_JAVELIN_P, ItemID.DRAGON_JAVELIN_P_, ItemID.DRAGON_JAVELIN_P__),
    AMETHYST_JAVELIN(ItemID.AMETHYST_JAVELIN, ItemID.AMETHYST_JAVELIN_P, ItemID.AMETHYST_JAVELIN_P_,
            ItemID.AMETHYST_JAVELIN_P__),

    // --- Spears ---
    BRONZE_SPEAR(ItemID.BRONZE_SPEAR, ItemID.BRONZE_SPEAR_P, ItemID.BRONZE_SPEAR_P_, ItemID.BRONZE_SPEAR_P__),
    IRON_SPEAR(ItemID.IRON_SPEAR, ItemID.IRON_SPEAR_P, ItemID.IRON_SPEAR_P_, ItemID.IRON_SPEAR_P__),
    BLACK_SPEAR(ItemID.BLACK_SPEAR, ItemID.BLACK_SPEAR_P, ItemID.BLACK_SPEAR_P_, ItemID.BLACK_SPEAR_P__),
    STEEL_SPEAR(ItemID.STEEL_SPEAR, ItemID.STEEL_SPEAR_P, ItemID.STEEL_SPEAR_P_, ItemID.STEEL_SPEAR_P__),
    MITHRIL_SPEAR(ItemID.MITHRIL_SPEAR, ItemID.MITHRIL_SPEAR_P, ItemID.MITHRIL_SPEAR_P_, ItemID.MITHRIL_SPEAR_P__),
    ADAMANT_SPEAR(ItemID.ADAMANT_SPEAR, ItemID.ADAMANT_SPEAR_P, ItemID.ADAMANT_SPEAR_P_, ItemID.ADAMANT_SPEAR_P__),
    RUNE_SPEAR(ItemID.RUNE_SPEAR, ItemID.RUNE_SPEAR_P, ItemID.RUNE_SPEAR_P_, ItemID.RUNE_SPEAR_P__),
    DRAGON_SPEAR(ItemID.DRAGON_SPEAR, ItemID.DRAGON_SPEAR_P, ItemID.DRAGON_SPEAR_P_, ItemID.DRAGON_SPEAR_P__),

    // --- Hastas ---
    BRONZE_HASTA(ItemID.BRUT_BRONZE_SPEAR, ItemID.BRUT_BRONZE_SPEAR_P, ItemID.BRUT_BRONZE_SPEAR_P_,
            ItemID.BRUT_BRONZE_SPEAR_P__),
    IRON_HASTA(ItemID.BRUT_IRON_SPEAR, ItemID.BRUT_IRON_SPEAR_P, ItemID.BRUT_IRON_SPEAR_P_,
            ItemID.BRUT_IRON_SPEAR_P__),
    STEEL_HASTA(ItemID.BRUT_STEEL_SPEAR, ItemID.BRUT_STEEL_SPEAR_P, ItemID.BRUT_STEEL_SPEAR_P_,
            ItemID.BRUT_STEEL_SPEAR_P__),
    MITHRIL_HASTA(ItemID.BRUT_MITHRIL_SPEAR, ItemID.BRUT_MITHRIL_SPEAR_P, ItemID.BRUT_MITHRIL_SPEAR_P_,
            ItemID.BRUT_MITHRIL_SPEAR_P__),
    ADAMANT_HASTA(ItemID.BRUT_ADAMANT_SPEAR, ItemID.BRUT_ADAMANT_SPEAR_P, ItemID.BRUT_ADAMANT_SPEAR_P_,
            ItemID.BRUT_ADAMANT_SPEAR_P__),
    RUNE_HASTA(ItemID.BRUT_RUNE_SPEAR, ItemID.BRUT_RUNE_SPEAR_P, ItemID.BRUT_RUNE_SPEAR_P_,
            ItemID.BRUT_RUNE_SPEAR_P__),
    DRAGON_HASTA(ItemID.BRUT_DRAGON_SPEAR, ItemID.BRUT_DRAGON_SPEAR_P, ItemID.BRUT_DRAGON_SPEAR_P_,
            ItemID.BRUT_DRAGON_SPEAR_P__),

    // --- Darts ---
    BRONZE_DART(ItemID.BRONZE_DART, ItemID.BRONZE_DART_P, ItemID.BRONZE_DART_P_, ItemID.BRONZE_DART_P__),
    IRON_DART(ItemID.IRON_DART, ItemID.IRON_DART_P, ItemID.IRON_DART_P_, ItemID.IRON_DART_P__),
    BLACK_DART(ItemID.BLACK_DART, ItemID.BLACK_DART_P, ItemID.BLACK_DART_P_, ItemID.BLACK_DART_P__),
    STEEL_DART(ItemID.STEEL_DART, ItemID.STEEL_DART_P, ItemID.STEEL_DART_P_, ItemID.STEEL_DART_P__),
    MITHRIL_DART(ItemID.MITHRIL_DART, ItemID.MITHRIL_DART_P, ItemID.MITHRIL_DART_P_, ItemID.MITHRIL_DART_P__),
    ADAMANT_DART(ItemID.ADAMANT_DART, ItemID.ADAMANT_DART_P, ItemID.ADAMANT_DART_P_, ItemID.ADAMANT_DART_P__),
    RUNE_DART(ItemID.RUNE_DART, ItemID.RUNE_DART_P, ItemID.RUNE_DART_P_, ItemID.RUNE_DART_P__),
    DRAGON_DART(ItemID.DRAGON_DART, ItemID.DRAGON_DART_P, ItemID.DRAGON_DART_P, ItemID.DRAGON_DART_P__),
    AMETHYST_DART(ItemID.AMETHYST_DART, ItemID.AMETHYST_DART_P, ItemID.AMETHYST_DART_P_, ItemID.AMETHYST_DART_P__),

    // --- Knives ---
    BRONZE_KNIFE(ItemID.BRONZE_KNIFE, ItemID.BRONZE_KNIFE_P, ItemID.BRONZE_KNIFE_P_, ItemID.BRONZE_KNIFE_P__),
    IRON_KNIFE(ItemID.IRON_KNIFE, ItemID.IRON_KNIFE_P, ItemID.IRON_KNIFE_P_, ItemID.IRON_KNIFE_P__),
    BLACK_KNIFE(ItemID.BLACK_KNIFE, ItemID.BLACK_KNIFE_P, ItemID.BLACK_KNIFE_P_, ItemID.BLACK_KNIFE_P__),
    STEEL_KNIFE(ItemID.STEEL_KNIFE, ItemID.STEEL_KNIFE_P, ItemID.STEEL_KNIFE_P_, ItemID.STEEL_KNIFE_P__),
    MITHRIL_KNIFE(ItemID.MITHRIL_KNIFE, ItemID.MITHRIL_KNIFE_P, ItemID.MITHRIL_KNIFE_P_, ItemID.MITHRIL_KNIFE_P__),
    ADAMANT_KNIFE(ItemID.ADAMANT_KNIFE, ItemID.ADAMANT_KNIFE_P, ItemID.ADAMANT_KNIFE_P_, ItemID.ADAMANT_KNIFE_P__),
    RUNE_KNIFE(ItemID.RUNE_KNIFE, ItemID.RUNE_KNIFE_P, ItemID.RUNE_KNIFE_P_, ItemID.RUNE_KNIFE_P__),
    DRAGON_KNIFE(ItemID.DRAGON_KNIFE, ItemID.DRAGON_KNIFE_P, ItemID.DRAGON_KNIFE_P_, ItemID.DRAGON_KNIFE_P__),

    // --- Arrows ---
    BRONZE_ARROW(ItemID.BRONZE_ARROW, ItemID.BRONZE_ARROW_P, ItemID.BRONZE_ARROW_P_, ItemID.BRONZE_ARROW_P__),
    IRON_ARROW(ItemID.IRON_ARROW, ItemID.IRON_ARROW_P, ItemID.IRON_ARROW_P_, ItemID.IRON_ARROW_P__),
    STEEL_ARROW(ItemID.STEEL_ARROW, ItemID.STEEL_ARROW_P, ItemID.STEEL_ARROW_P_, ItemID.STEEL_ARROW_P__),
    MITHRIL_ARROW(ItemID.MITHRIL_ARROW, ItemID.MITHRIL_ARROW_P, ItemID.MITHRIL_ARROW_P_, ItemID.MITHRIL_ARROW_P__),
    ADAMANT_ARROW(ItemID.ADAMANT_ARROW, ItemID.ADAMANT_ARROW_P, ItemID.ADAMANT_ARROW_P_, ItemID.ADAMANT_ARROW_P__),
    RUNE_ARROW(ItemID.RUNE_ARROW, ItemID.RUNE_ARROW_P, ItemID.RUNE_ARROW_P_, ItemID.RUNE_ARROW_P__),
    DRAGON_ARROW(ItemID.DRAGON_ARROW, ItemID.DRAGON_ARROW_P, ItemID.DRAGON_ARROW_P_, ItemID.DRAGON_ARROW_P__),
    AMETHYST_ARROW(ItemID.AMETHYST_ARROW, ItemID.AMETHYST_ARROW_P, ItemID.AMETHYST_ARROW_P, ItemID.AMETHYST_ARROW_P__),

    // --- Bolts ---
    BRONZE_BOLTS(ItemID.BOLT, ItemID.POISON_BOLT, ItemID.POISON_BOLT_, ItemID.POISON_BOLT__),
    IRON_BOLTS(ItemID.XBOWS_CROSSBOW_BOLTS_IRON, ItemID.XBOWS_CROSSBOW_BOLTS_IRON_POISONED,
            ItemID.XBOWS_CROSSBOW_BOLTS_IRON_POISONED_, ItemID.XBOWS_CROSSBOW_BOLTS_IRON_POISONED__),
    SILVER_BOLTS(ItemID.XBOWS_CROSSBOW_BOLTS_SILVER, ItemID.XBOWS_CROSSBOW_BOLTS_SILVER_POISONED,
            ItemID.XBOWS_CROSSBOW_BOLTS_SILVER_POISONED_, ItemID.XBOWS_CROSSBOW_BOLTS_SILVER_POISONED__),
    STEEL_BOLTS(ItemID.XBOWS_CROSSBOW_BOLTS_STEEL, ItemID.XBOWS_CROSSBOW_BOLTS_STEEL_POISONED,
            ItemID.XBOWS_CROSSBOW_BOLTS_STEEL_POISONED_, ItemID.XBOWS_CROSSBOW_BOLTS_STEEL_POISONED__),
    MITHRIL_BOLTS(ItemID.XBOWS_CROSSBOW_BOLTS_MITHRIL, ItemID.XBOWS_CROSSBOW_BOLTS_MITHRIL_POISONED,
            ItemID.XBOWS_CROSSBOW_BOLTS_MITHRIL_POISONED_, ItemID.XBOWS_CROSSBOW_BOLTS_MITHRIL_POISONED__),
    ADAMANTITE_BOLTS(ItemID.XBOWS_CROSSBOW_BOLTS_ADAMANTITE, ItemID.XBOWS_CROSSBOW_BOLTS_ADAMANTITE_POISONED,
            ItemID.XBOWS_CROSSBOW_BOLTS_ADAMANTITE_POISONED_, ItemID.XBOWS_CROSSBOW_BOLTS_ADAMANTITE_POISONED__),
    RUNITE_BOLTS(ItemID.XBOWS_CROSSBOW_BOLTS_RUNITE, ItemID.XBOWS_CROSSBOW_BOLTS_RUNITE_POISONED,
            ItemID.XBOWS_CROSSBOW_BOLTS_RUNITE_POISONED_, ItemID.XBOWS_CROSSBOW_BOLTS_RUNITE_POISONED__),
    DRAGON_BOLTS(ItemID.DRAGON_BOLTS, ItemID.DRAGON_BOLTS_P, ItemID.DRAGON_BOLTS_P_, ItemID.DRAGON_BOLTS_P__);

    private final int baseId;
    private final int poisonId;
    private final int poisonPlusId;
    private final int poisonPlusPlusId;

    // Overloaded constructor for global prerequisites
    PoisonWeapons(int id) {
        this.baseId = id;
        this.poisonId = id;
        this.poisonPlusId = id;
        this.poisonPlusPlusId = id;
    }

    // Constructor for weapons with distinct variant IDs.
    PoisonWeapons(int baseId, int poisonId, int poisonPlusId, int poisonPlusPlusId) {
        this.baseId = baseId;
        this.poisonId = poisonId;
        this.poisonPlusId = poisonPlusId;
        this.poisonPlusPlusId = poisonPlusPlusId;
    }

    /**
     * Checks whether the given item id matches any variant of this weapon.
     *
     * @param id the item id to check.
     * @return true if the id matches base, poison, poison+ or poison++.
     */
    public boolean matches(int id) {
        return id == baseId || id == poisonId || id == poisonPlusId || id == poisonPlusPlusId;
    }

    /**
     * Returns an unmodifiable set of all base weapon ids from poisonable weapons, excluding poison constants.
     */
    public static Set<Integer> getAllBaseWeaponIds() {
        Set<Integer> ids = new HashSet<>();
        for (PoisonWeapons weapon : values()) {
            if (!weapon.name().startsWith("WEAPON_POISON")) {
                ids.add(weapon.getBaseId());
            }
        }
        return Collections.unmodifiableSet(ids);
    }

    /**
     * Checks if a given item id is a poisonable weapon variant.
     *
     * @param itemId the item id to check.
     * @return true if it matches any poisonable weapon variant.
     */
    public static boolean isPoisonableWeapon(int itemId) {
        for (PoisonWeapons weapon : values()) {
            if (weapon.name().startsWith("WEAPON_POISON")) continue;
            if (weapon.matches(itemId)) {
                return true;
            }
        }
        return false;
    }

    /**
     * Checks if a poisonable weapon variant is eligible.
     * Base weapons are always eligible.
     * For poisoned variants:
     *   - (p) requires WEAPON_POISON,
     *   - (p+) requires WEAPON_POISON_,
     *   - (p++) requires WEAPON_POISON__,
     * to be unlocked along with the base weapon.
     * @param itemId the item ID to check
     * @param requireWeaponPoison if true, the corresponding global poison must be unlocked
     * @param unlockedItems the set of unlocked item IDs
     * @return true if eligible; false otherwise
     */
    public static boolean isPoisonVariantEligible(int itemId, boolean requireWeaponPoison, Set<Integer> unlockedItems) {
        PoisonWeapons matchingWeapon = null;
        for (PoisonWeapons weapon : values()) {
            if (weapon.name().startsWith("WEAPON_POISON")) continue;
            if (weapon.matches(itemId)) {
                matchingWeapon = weapon;
                break;
            }
        }
        if (matchingWeapon == null) {
            return true;
        }
        // Base weapon is always eligible.
        if (itemId == matchingWeapon.getBaseId()) {
            return true;
        }
        if (!requireWeaponPoison) {
            return true;
        }
        int requiredGlobalId;
        if (itemId == matchingWeapon.getPoisonId()) {
            requiredGlobalId = PoisonWeapons.WEAPON_POISON.getBaseId();
        } else if (itemId == matchingWeapon.getPoisonPlusId()) {
            requiredGlobalId = PoisonWeapons.WEAPON_POISON_.getBaseId();
        } else if (itemId == matchingWeapon.getPoisonPlusPlusId()) {
            requiredGlobalId = PoisonWeapons.WEAPON_POISON__.getBaseId();
        } else {
            return true;
        }
        boolean eligible = unlockedItems.contains(matchingWeapon.getBaseId()) && unlockedItems.contains(requiredGlobalId);
        return eligible;
    }

}

package com.chanceman.filters;

import lombok.Getter;
import net.runelite.api.gameval.ItemID;
import java.util.Collections;
import java.util.HashSet;
import java.util.Set;

/**
 * Enum representing all POH flatpack items.
 */
public enum Flatpacks {
    // Chair variants
    Crudechair(ItemID.POH_FLATPACK_ARMCHAIR1),
    Woodenchair(ItemID.POH_FLATPACK_ARMCHAIR2),
    Rockingchair(ItemID.POH_FLATPACK_ARMCHAIR3),
    Oakchair(ItemID.POH_FLATPACK_ARMCHAIR4),
    Oakarmchair(ItemID.POH_FLATPACK_ARMCHAIR5),
    Teakarmchair(ItemID.POH_FLATPACK_ARMCHAIR6),
    Mahoganyarmchair(ItemID.POH_FLATPACK_ARMCHAIR7),

    // Bookcase variants
    Bookcase(ItemID.POH_FLATPACK_BOOKCASE1),
    Oakbookcase(ItemID.POH_FLATPACK_BOOKCASE2),
    Mahoganybookcase(ItemID.POH_FLATPACK_BOOKCASE3),

    // Beer barrel variants
    Beerbarrel(ItemID.POH_FLATPACK_BEERBARREL1),
    Ciderbarrel(ItemID.POH_FLATPACK_BEERBARREL2),
    Asgarnianale(ItemID.POH_FLATPACK_BEERBARREL3),
    Greensmansale(ItemID.POH_FLATPACK_BEERBARREL4),
    Dragonbitter(ItemID.POH_FLATPACK_BEERBARREL5),
    Chefsdelight(ItemID.POH_FLATPACK_BEERBARREL6),

    // Kitchen table variants
    Kitchentable(ItemID.POH_FLATPACK_KITCHENTABLE1),
    Oakkitchentable(ItemID.POH_FLATPACK_KITCHENTABLE2),
    Teakkitchentable(ItemID.POH_FLATPACK_KITCHENTABLE3),

    // Dining table variants
    Wooddiningtable(ItemID.POH_FLATPACK_DININGTABLE1),
    Oakdiningtable(ItemID.POH_FLATPACK_DININGTABLE2),
    Carvedoaktable(ItemID.POH_FLATPACK_DININGTABLE3),
    Teaktable(ItemID.POH_FLATPACK_DININGTABLE4),
    Carvedteaktable(ItemID.POH_FLATPACK_DININGTABLE5),
    Mahoganytable(ItemID.POH_FLATPACK_DININGTABLE6),
    OpulentsTable(ItemID.POH_FLATPACK_DININGTABLE7),

    // Dining chair (bench) variants
    Woodenbench(ItemID.POH_FLATPACK_DININGCHAIR1),
    Oakbench(ItemID.POH_FLATPACK_DININGCHAIR2),
    Carvedoakbench(ItemID.POH_FLATPACK_DININGCHAIR3),
    Teakdiningbench(ItemID.POH_FLATPACK_DININGCHAIR4),
    Carvedteakbench(ItemID.POH_FLATPACK_DININGCHAIR5),
    Mahoganybench(ItemID.POH_FLATPACK_DININGCHAIR6),
    Gildedbench(ItemID.POH_FLATPACK_DININGCHAIR7),

    // Bed variants
    Woodenbed(ItemID.POH_FLATPACK_BED1),
    Oakbed(ItemID.POH_FLATPACK_BED2),
    Largeoakbed(ItemID.POH_FLATPACK_BED3),
    Teakbed(ItemID.POH_FLATPACK_BED4),
    Largeteakbed(ItemID.POH_FLATPACK_BED5),
    Fourposterbed(ItemID.POH_FLATPACK_BED6),
    Gildedfourposter(ItemID.POH_FLATPACK_BED7),

    // Clock variants
    Oakclock(ItemID.POH_FLATPACK_CLOCK1),
    Teakclock(ItemID.POH_FLATPACK_CLOCK2),
    Gildedclock(ItemID.POH_FLATPACK_CLOCK3),

    // Dresser variants
    Shavingstand(ItemID.POH_FLATPACK_DRESSER1),
    Oakshavingstand(ItemID.POH_FLATPACK_DRESSER2),
    Oakdresser(ItemID.POH_FLATPACK_DRESSER3),
    Teakdresser(ItemID.POH_FLATPACK_DRESSER4),
    Fancyteakdresser(ItemID.POH_FLATPACK_DRESSER5),
    Mahoganydresser(ItemID.POH_FLATPACK_DRESSER6),
    Gildeddresser(ItemID.POH_FLATPACK_DRESSER7),

    // Wardrobe variants
    Shoebox(ItemID.POH_FLATPACK_WARDROBE1),
    Oakdrawers(ItemID.POH_FLATPACK_WARDROBE2),
    Oakwardrobe(ItemID.POH_FLATPACK_WARDROBE3),
    Teakdrawers(ItemID.POH_FLATPACK_WARDROBE4),
    Teakwardrobe(ItemID.POH_FLATPACK_WARDROBE5),
    Mahoganywardrobe(ItemID.POH_FLATPACK_WARDROBE6),
    Gildedwardrobe(ItemID.POH_FLATPACK_WARDROBE7),

    // Cape rack variants
    Oakcaperack(ItemID.POH_FLATPACK_CAPE_RACK),
    Teakcaperack(ItemID.POH_FLATPACK_CAPE_RACK2),
    Mahoganycaperack(ItemID.POH_FLATPACK_CAPE_RACK3),
    Gildedcaperack(ItemID.POH_FLATPACK_CAPE_RACK4),
    Marblecaperack(ItemID.POH_FLATPACK_CAPE_RACK5),
    Magiccaperack(ItemID.POH_FLATPACK_CAPE_RACK6),

    // Toy box variants
    Oaktoybox(ItemID.POH_FLATPACK_TOY_BOX),
    Teaktoybox(ItemID.POH_FLATPACK_TOY_BOX2),
    Mahoganytoybox(ItemID.POH_FLATPACK_TOY_BOX3),

    // Magic wardrobe variants
    Oakmagicwardrobe(ItemID.POH_FLATPACK_MAGIC_WARDROBE),
    Carvedoakmagicwardrobe(ItemID.POH_FLATPACK_MAGIC_WARDROBE2),
    Teakmagicwardrobe(ItemID.POH_FLATPACK_MAGIC_WARDROBE3),
    Carvedteakmagicwardrobe(ItemID.POH_FLATPACK_MAGIC_WARDROBE4),
    Mahoganymagicwardrobe(ItemID.POH_FLATPACK_MAGIC_WARDROBE5),
    Gildedmagicwardrobe(ItemID.POH_FLATPACK_MAGIC_WARDROBE6),
    Marblemagicwardrobe(ItemID.POH_FLATPACK_MAGIC_WARDROBE7),

    // Armour case variants
    Oakarmourcase(ItemID.POH_FLATPACK_ARMOUR_CASE),
    Teakarmourcase(ItemID.POH_FLATPACK_ARMOUR_CASE2),
    Mahoganyarmourcase(ItemID.POH_FLATPACK_ARMOUR_CASE3),

    // Treasure chest variants
    Oaktreasurechest(ItemID.POH_FLATPACK_TREASURE_CHEST),
    Teaktreasurechest(ItemID.POH_FLATPACK_TREASURE_CHEST2),
    Magictreasurechest(ItemID.POH_FLATPACK_TREASURE_CHEST3),

    // Fancy dress box variants
    Oakfancydressbox(ItemID.POH_FLATPACK_FANCY_DRESS_BOX),
    Teakfancydressbox(ItemID.POH_FLATPACK_FANCY_DRESS_BOX2),
    Mahoganyfancydressbox(ItemID.POH_FLATPACK_FANCY_DRESS_BOX3);

    @Getter
    private final int id;

    Flatpacks(int id) {
        this.id = id;
    }

    /**
     * Returns an unmodifiable set of all flatpack item IDs.
     */
    public static Set<Integer> getAllFlatpackIds() {
        Set<Integer> ids = new HashSet<>();
        for (Flatpacks fp : Flatpacks.values()) {
            ids.add(fp.getId());
        }
        return Collections.unmodifiableSet(ids);
    }

    /**
     * Checks if the given item ID is a flatpack.
     *
     * @param id the item id to check.
     * @return true if the id is a flatpack, false otherwise.
     */
    public static boolean isFlatpack(int id) {
        return getAllFlatpackIds().contains(id);
    }
}

package com.chanceman.filters;

import lombok.Getter;

import java.util.Collections;
import java.util.HashSet;
import java.util.Set;
import net.runelite.api.gameval.ItemID;


public final class BlockedItems {
    @Getter private static final Set<Integer> BLOCKED_ITEMS;

    static {
        Set<Integer> blocked = new HashSet<>();
        //Dead Man Mode
        blocked.add(ItemID.DEADMAN_BLIGHTED_AGS); // Corrupted Armadyl Godsword
        blocked.add(ItemID.DEADMAN_BLIGHTED_DARK_BOW); // Corrupted Dark Bow
        blocked.add(ItemID.DEADMAN_BLIGHTED_DRAGON_CLAWS); // Corrupted Dragon Claws
        blocked.add(ItemID.DEADMAN_BLIGHTED_TWISTED_BOW); // Corrupted Twisted Bow
        blocked.add(ItemID.DEADMAN_BLIGHTED_VOIDWAKER); // Corrupted Voidwaker
        blocked.add(ItemID.DEADMAN_BLIGHTED_VOLATILE_STAFF); // Corrupted Volatile Nightmare Staff
        blocked.add(ItemID.DEADMAN_BLIGHTED_TUMEKENS_SHADOW_UNCHARGED); // Corrupted Tumeken's Shadow (uncharged)
        blocked.add(ItemID.DEADMAN_BLIGHTED_SCYTHE_OF_VITUR_UNCHARGED);// Corrupted Scythe of Vitur (uncharged)
        blocked.add(ItemID.DEADMAN_NIMBLENESS_CHARM); // Nimbleness Charm
        blocked.add(ItemID.DEADMAN_STOCKPILING_CHARM); // Stockpiling Charm
        blocked.add(ItemID.DEADMAN_ACCUMULATION_CHARM); // Accumulation Charm
        blocked.add(ItemID.DEADMAN_VULNERABILITY_CHARM); // Vulnerability Charm
        blocked.add(ItemID.DEADMAN_2024_HOME_TELEPORT_SCROLL); // Armageddon Teleport Scroll
        blocked.add(ItemID.DEADMAN_2024_CAPE_ORNAMENT_SCROLL); // Armageddon Cape Fabric
        blocked.add(ItemID.DEADMAN_2024_WEAPON_ORNAMENT_SCROLL); // Armageddon Weapon Scroll
        blocked.add(ItemID.DEADMAN_RUG); // Armageddon Rug
        blocked.add(ItemID.DEADMAN1DOSEOVERLOAD); // Blighted Overload (1)
        blocked.add(ItemID.DEADMAN2DOSEOVERLOAD); // Blighted Overload (2)
        blocked.add(ItemID.DEADMAN3DOSEOVERLOAD); // Blighted Overload (3)
        blocked.add(ItemID.DEADMAN4DOSEOVERLOAD); // Blighted Overload (4)
        blocked.add(ItemID.DEADMAN_OVERLOAD_CHITIN); // Chitin
        blocked.add(ItemID.DEADMAN_STARTER_BOW); // Starter Bow
        blocked.add(ItemID.DEADMAN_STARTER_STAFF); // Starter Staff
        blocked.add(ItemID.DEADMAN_STARTER_SWORD); // Starter Sword
        blocked.add(ItemID.MAGIC_ROCK_OF_WEAPONS); // Trinket of Advanced Weaponry
        blocked.add(ItemID.MAGIC_ROCK_OF_FAIRIES); // Trinket of Fairies
        blocked.add(ItemID.MAGIC_ROCK_OF_UNDEAD); // Trinket of Undead
        blocked.add(ItemID.MAGIC_ROCK_OF_VENGEANCE); // Trinket of Vengeance
        blocked.add(ItemID.MORRIGANS_COIF); // Morrigan's Coif
        blocked.add(ItemID.MORRIGANS_LEATHER_BODY); // Morrigan's Leather Body
        blocked.add(ItemID.MORRIGANS_LEATHER_CHAPS); // Morrigan's Leather Chaps
        blocked.add(ItemID.MORRIGANS_THROWNAXE); // Morrigan's Thrown axe
        blocked.add(ItemID.MORRIGANS_JAVELIN); // Morrigan's Javelin
        blocked.add(ItemID.STATIUS_FULL_HELM); // Statius' Full Helm
        blocked.add(ItemID.STATIUS_PLATEBODY); // Statius' Platebody
        blocked.add(ItemID.STATIUS_PLATELEGS); // Statius' Platelegs
        blocked.add(ItemID.STATIUS_WARHAMMER); // Statius' Warhammer
        blocked.add(ItemID.VESTAS_CHAINBODY); // Vesta's Chainbody
        blocked.add(ItemID.VESTAS_PLATESKIRT); // Vesta's Plateskirt
        blocked.add(ItemID.VESTAS_LONGSWORD); // Vesta's Longsword
        blocked.add(ItemID.VESTAS_SPEAR); // Vesta's Spear
        blocked.add(ItemID.ZURIELS_HOOD); // Zuriel's Hood
        blocked.add(ItemID.ZURIELS_ROBE_TOP); // Zuriel's Robe Top
        blocked.add(ItemID.ZURIELS_ROBE_BOTTOM); // Zuriel's Robe Bottom
        blocked.add(ItemID.ZURIELS_STAFF); // Zuriel's Staff
        blocked.add(ItemID.SIGIL_OF_ADROIT_UNATTUNED); // Sigil Of Adroit
        blocked.add(ItemID.SIGIL_OF_AGGRESSION_UNATTUNED); // Sigil Of Aggression
        blocked.add(ItemID.SIGIL_OF_AGILE_FORTUNE_UNATTUNED); // Sigil Of Agile Fortune
        blocked.add(ItemID.SIGIL_OF_ARCANE_SWIFTNESS_UNATTUNED); // Sigil Of Arcane Swiftness
        blocked.add(ItemID.SIGIL_OF_BARROWS_UNATTUNED); // Sigil Of Barrows
        blocked.add(ItemID.SIGIL_OF_BINDING_UNATTUNED); // Sigil Of Binding
        blocked.add(ItemID.SIGIL_OF_CONSISTENCY_UNATTUNED); // Sigil Of Consistency
        blocked.add(ItemID.SIGIL_OF_DECEPTION_UNATTUNED); // Sigil Of Deception
        blocked.add(ItemID.SIGIL_OF_DEFT_STRIKES_UNATTUNED); // Sigil Of Deft Strikes
        blocked.add(ItemID.SIGIL_OF_DEVOTION_UNATTUNED); // Sigil Of Devotion
        blocked.add(ItemID.SIGIL_OF_ENHANCED_HARVEST_UNATTUNED); // Sigil Of Enhanced Harvest
        blocked.add(ItemID.SIGIL_OF_ESCAPING_UNATTUNED); // Sigil Of Escaping
        blocked.add(ItemID.SIGIL_OF_EXAGGERATION_UNATTUNED); // Sigil Of Exaggeration
        blocked.add(ItemID.SIGIL_OF_FAITH_UNATTUNED); // Sigil Of Faith
        blocked.add(ItemID.SIGIL_OF_FINALITY_UNATTUNED); // Sigil Of Finality
        blocked.add(ItemID.SIGIL_OF_FORTIFICATION_UNATTUNED); // Sigil Of Fortification
        blocked.add(ItemID.SIGIL_OF_FREEDOM_UNATTUNED); // Sigil Of Freedom
        blocked.add(ItemID.SIGIL_OF_GARMENTS_UNATTUNED); // Sigil Of Garments
        blocked.add(ItemID.SIGIL_OF_GUNSLINGER_UNATTUNED); // Sigil Of Gunslinger
        blocked.add(ItemID.SIGIL_OF_HOARDING_UNATTUNED); // Sigil Of Hoarding
        blocked.add(ItemID.SIGIL_OF_LAST_RECALL_UNATTUNED); // Sigil Of Last Recall
        blocked.add(ItemID.SIGIL_OF_LITHE_UNATTUNED); // Sigil Of Lithe
        blocked.add(ItemID.SIGIL_OF_METICULOUSNESS_UNATTUNED); // Sigil Of Meticulousness
        blocked.add(ItemID.SIGIL_OF_MOBILITY_UNATTUNED); // Sigil Of Mobility
        blocked.add(ItemID.SIGIL_OF_NATURE_UNATTUNED); // Sigil Of Nature
        blocked.add(ItemID.SIGIL_OF_ONSLAUGHT_UNATTUNED); // Sigil Of Onslaught
        blocked.add(ItemID.SIGIL_OF_PIOUS_PROTECTION_UNATTUNED); // Sigil Of Pious Protection
        blocked.add(ItemID.SIGIL_OF_PRECISION_UNATTUNED); // Sigil Of Precision
        blocked.add(ItemID.SIGIL_OF_PRESERVATION_UNATTUNED); // Sigil Of Preservation
        blocked.add(ItemID.SIGIL_OF_PROSPERITY_UNATTUNED); // Sigil Of Prosperity
        blocked.add(ItemID.SIGIL_OF_RAMPAGE_UNATTUNED); // Sigil Of Rampage
        blocked.add(ItemID.SIGIL_OF_RAMPART_UNATTUNED); // Sigil Of Rampart
        blocked.add(ItemID.SIGIL_OF_REMOTE_STORAGE_UNATTUNED); // Sigil Of Remote Storage
        blocked.add(ItemID.SIGIL_OF_RESILIENCE_UNATTUNED); // Sigil Of Resilience
        blocked.add(ItemID.SIGIL_OF_RESISTANCE_UNATTUNED); // Sigil Of Resistance
        blocked.add(ItemID.SIGIL_OF_RESTORATION_UNATTUNED); // Sigil Of Restoration
        blocked.add(ItemID.SIGIL_OF_REVOKED_LIMITATION_UNATTUNED); // Sigil Of Revoked Limitations
        blocked.add(ItemID.SIGIL_OF_SLAUGHTER_UNATTUNED); // Sigil Of Slaughter
        blocked.add(ItemID.SIGIL_OF_SPECIALISED_STRIKES_UNATTUNED); // Sigil Of Specialised Strikes
        blocked.add(ItemID.SIGIL_OF_STAMINA_UNATTUNED); // Sigil Of Stamina
        blocked.add(ItemID.SIGIL_OF_STORAGE_ATTUNED); // Sigil Of Storage
        blocked.add(ItemID.SIGIL_OF_SUPREME_STAMINA_UNATTUNED); // Sigil Of Supreme Stamina
        blocked.add(ItemID.SIGIL_OF_SUSTENANCE_UNATTUNED); // Sigil Of Sustenance
        blocked.add(ItemID.SIGIL_OF_SWASHBUCKLER_UNATTUNED); // Sigil Of Swashbuckler
        blocked.add(ItemID.SIGIL_OF_THE_ABYSS_UNATTUNED); // Sigil Of The Abyss
        blocked.add(ItemID.SIGIL_OF_THE_ALCHEMIST_UNATTUNED); // Sigil Of The Alchemist
        blocked.add(ItemID.SIGIL_OF_THE_ALCHEMANIAC_UNATTUNED); // Sigil Of The Alchemaniac
        blocked.add(ItemID.SIGIL_OF_THE_AUGMENTED_THRALL_UNATTUNED); // Sigil Of The Augmented Thrall
        blocked.add(ItemID.SIGIL_OF_THE_BARBARIANS_UNATTUNED); // Sigil Of The Barbarians
        blocked.add(ItemID.SIGIL_OF_THE_BLOODHOUND_UNATTUNED); // Sigil Of The Bloodhound
        blocked.add(ItemID.SIGIL_OF_THE_CHEF_UNATTUNED); // Sigil Of The Chef
        blocked.add(ItemID.SIGIL_OF_THE_CRAFTER_UNATTUNED); // Sigil Of The Craftsman
        blocked.add(ItemID.SIGIL_OF_THE_DWARVES_UNATTUNED); // Sigil Of The Dwarves
        blocked.add(ItemID.SIGIL_OF_THE_ELVES_UNATTUNED); // Sigil Of The Elves
        blocked.add(ItemID.SIGIL_OF_THE_ETERNAL_JEWELLER_UNATTUNED); // Sigil Of The Eternal Jeweller
        blocked.add(ItemID.SIGIL_OF_THE_FERAL_FIGHTER_UNATTUNED); // Sigil Of The Feral Fighter
        blocked.add(ItemID.SIGIL_OF_THE_FLETCHER_UNATTUNED); // Sigil Of The Fletcher
        blocked.add(ItemID.SIGIL_OF_THE_FOOD_MASTER_UNATTUNED); // Sigil Of The Food Master
        blocked.add(ItemID.SIGIL_OF_THE_FORAGER_UNATTUNED); // Sigil Of The Forger
        blocked.add(ItemID.SIGIL_OF_THE_FORMIDABLE_FIGHTER_UNATTUNED); // Sigil Of The Formidable Fighter
        blocked.add(ItemID.SIGIL_OF_THE_FORTUNE_FARMER_UNATTUNED); // Sigil Of The Fortune Farmer
        blocked.add(ItemID.SIGIL_OF_THE_GNOMES_UNATTUNED); // Sigil Of The Gnomes
        blocked.add(ItemID.SIGIL_OF_THE_GUARDIAN_ANGEL_UNATTUNED); // Sigil Of The Guardian Angel
        blocked.add(ItemID.SIGIL_OF_THE_HUNTER_UNATTUNED); // Sigil Of The Hunter
        blocked.add(ItemID.SIGIL_OF_THE_INFERNAL_CHEF_UNATTUNED); // Sigil Of The Infernal Chef
        blocked.add(ItemID.SIGIL_OF_THE_INFERNAL_SMITH_UNATTUNED); // Sigil Of The Infernal Smith
        blocked.add(ItemID.SIGIL_OF_THE_LIGHTBEARER_UNATTUNED); // Sigil Of The Lighterbearer
        blocked.add(ItemID.SIGIL_OF_THE_MENACING_MAGE_UNATTUNED); // Sigil Of The Menacing Mage
        blocked.add(ItemID.SIGIL_OF_THE_METICULOUS_MAGE_UNATTUNED); // Sigil Of The Meticulous Mage
        blocked.add(ItemID.SIGIL_OF_THE_NINJA_UNATTUNED); // Sigil Of The Ninja
        blocked.add(ItemID.SIGIL_OF_THE_PORCUPINE_UNATTUNED); // Sigil Of The Porcupine
        blocked.add(ItemID.SIGIL_OF_THE_POTION_MASTER_UNATTUNED); // Sigil Of The Potion Master
        blocked.add(ItemID.SIGIL_OF_THE_RIGOROUS_RANGER_UNATTUNED); // Sigil Of The Rigorous Ranger
        blocked.add(ItemID.SIGIL_OF_THE_RUTHLESS_RANGER_UNATTUNED); // Sigil Of The Ruthless Ranger
        blocked.add(ItemID.SIGIL_OF_THE_SERPENT_UNATTUNED); // Sigil Of The Serpent
        blocked.add(ItemID.SIGIL_OF_THE_SKILLER_UNATTUNED); // Sigil Of The Skiller
        blocked.add(ItemID.SIGIL_OF_THE_SMITH_UNATTUNED); // Sigil Of The Smith
        blocked.add(ItemID.SIGIL_OF_THE_TREASURE_HUNTER_UNATTUNED); // Sigil Of The Treasure Hunter
        blocked.add(ItemID.SIGIL_OF_THE_WELL_FED_UNATTUNED); // Sigil Of The Well-Fed
        blocked.add(ItemID.SIGIL_OF_TITANIUM_UNATTUNED); // Sigil Of Titanium
        blocked.add(ItemID.SIGIL_OF_VERSATILITY_UNATTUNED); // Sigil Of Versatility
        blocked.add(ItemID.SIGIL_OF_WOODCRAFT_UNATTUNED); // Sigil Of Woodcraft

        // Twisted Leagues Rewards
        blocked.add(ItemID.TWISTED_BANNER); // Twisted Banner
        blocked.add(ItemID.TWISTED_BLUEPRINTS); // Twisted Blueprints
        blocked.add(ItemID.TWISTED_CANE); // Twisted Cane
        blocked.add(ItemID.TWISTED_RELIC_HUNTER_HAT_T1); // Twisted Hat (t1)
        blocked.add(ItemID.TWISTED_RELIC_HUNTER_HAT_T2); // Twisted Hat (t2)
        blocked.add(ItemID.TWISTED_RELIC_HUNTER_HAT_T3); // Twisted Hat (t3)
        blocked.add(ItemID.TWISTED_HORNS); // Twisted Horns
        blocked.add(ItemID.TWISTED_RELIC_HUNTER_TOP_T1); // Twisted Coat (t1)
        blocked.add(ItemID.TWISTED_RELIC_HUNTER_TOP_T2); // Twisted Coat (t2)
        blocked.add(ItemID.TWISTED_RELIC_HUNTER_TOP_T3); // Twisted Coat (t3)
        blocked.add(ItemID.TWISTED_RELIC_HUNTER_LEGS_T1); // Twisted Trouser (t1)
        blocked.add(ItemID.TWISTED_RELIC_HUNTER_LEGS_T2); // Twisted Trouser (t2)
        blocked.add(ItemID.TWISTED_RELIC_HUNTER_LEGS_T3); // Twisted Trouser (t3)
        blocked.add(ItemID.TWISTED_RELIC_HUNTER_BOOTS_T1); // Twisted Boots (t1)
        blocked.add(ItemID.TWISTED_RELIC_HUNTER_BOOTS_T2); // Twisted Boots (t2)
        blocked.add(ItemID.TWISTED_RELIC_HUNTER_BOOTS_T3); // Twisted Boots (t3)
        blocked.add(ItemID.SET_TWISTED_RELICHUNTER_T1); // Twisted Relic Hunter (t1) Armour Set
        blocked.add(ItemID.SET_TWISTED_RELICHUNTER_T2); // Twisted Relic Hunter (t2) Armour Set
        blocked.add(ItemID.SET_TWISTED_RELICHUNTER_T3); // Twisted Relic Hunter (t3) Armour Set
        blocked.add(ItemID.TWISTED_HOME_TELEPORT_SCROLL); // Twisted Teleport Scroll

        // Trailblazer Leagues Rewards
        blocked.add(ItemID.TRAILBLAZER_BANNER); // Trailblazer Banner
        blocked.add(ItemID.TRAILBLAZER_HOME_TELEPORT_SCROLL); // Trailblazer Teleport Scroll
        blocked.add(ItemID.TRAILBLAZER_TOOL_ORNAMENTKIT); // Trailblazer Tool Ornament Kit
        blocked.add(ItemID.TRAILBLAZER_GRACEFUL_KIT); // Trailblazer Graceful Ornament Kit
        blocked.add(ItemID.TRAILBLAZER_STATUE); // Trailblazer Globe
        blocked.add(ItemID.TRAILBLAZER_RUG); // Trailblazer Rug
        blocked.add(ItemID.TRAILBLAZER_CANE); // Trailblazer Cane
        blocked.add(ItemID.TRAILBLAZER_RELIC_HUNTER_HOOD_T1); // Trailblazer Hood (t1)
        blocked.add(ItemID.TRAILBLAZER_RELIC_HUNTER_HOOD_T2); // Trailblazer Hood (t2)
        blocked.add(ItemID.TRAILBLAZER_RELIC_HUNTER_HOOD_T3); // Trailblazer Hood (t3)
        blocked.add(ItemID.TRAILBLAZER_RELIC_HUNTER_TOP_T1); // Trailblazer Top (t1)
        blocked.add(ItemID.TRAILBLAZER_RELIC_HUNTER_TOP_T2); // Trailblazer Top (t2)
        blocked.add(ItemID.TRAILBLAZER_RELIC_HUNTER_TOP_T3); // Trailblazer Top (t3)
        blocked.add(ItemID.TRAILBLAZER_RELIC_HUNTER_LEGS_T1); // Trailblazer Trousers (t1)
        blocked.add(ItemID.TRAILBLAZER_RELIC_HUNTER_LEGS_T2); // Trailblazer Trousers (t2)
        blocked.add(ItemID.TRAILBLAZER_RELIC_HUNTER_LEGS_T3); // Trailblazer Trouser (t3)
        blocked.add(ItemID.TRAILBLAZER_RELIC_HUNTER_BOOTS_T1); // Trailblazer Boots (t1)
        blocked.add(ItemID.TRAILBLAZER_RELIC_HUNTER_BOOTS_T2); // Trailblazer Boots (t2)
        blocked.add(ItemID.TRAILBLAZER_RELIC_HUNTER_BOOTS_T3); // Trailblazer Boots (t3)
        blocked.add(ItemID.SET_TRAILBLAZER_RELICHUNTER_T1); // Trailblazer Relic Hunter (t1) Armour Set
        blocked.add(ItemID.SET_TRAILBLAZER_RELICHUNTER_T2); // Trailblazer Relic Hunter (t2) Armour Set
        blocked.add(ItemID.SET_TRAILBLAZER_RELICHUNTER_T3); // Trailblazer Relic Hunter (t3) Armour Set

        // Shattered Leagues Rewards
        blocked.add(ItemID.LEAGUE_3_BANNER); // Shattered Banner
        blocked.add(ItemID.LEAGUE_3_HOME_TELEPORT_SCROLL); // Shattered Teleport Scroll
        blocked.add(ItemID.LEAGUE_3_CANE); // Shattered Cane
        blocked.add(ItemID.LEAGUE_3_WEAPON_VARIETY_PACK); // Shattered Relics Variety Ornament Kit
        blocked.add(ItemID.LEAGUE_3_VOID_KIT); // Shattered Relics Void Ornament Kit
        blocked.add(ItemID.LEAGUE_3_MYSTIC_ORNAMENT_PACK); // Shattered Relics Mystic Ornament Kit
        blocked.add(ItemID.LEAGUE_3_MULTICANNON_PACK); // Shattered Cannon Ornament Kit
        blocked.add(ItemID.LEAGUE_3_RELIC_HUNTER_HOOD_T1); // Shattered Hood (t1)
        blocked.add(ItemID.LEAGUE_3_RELIC_HUNTER_HOOD_T2); // Shattered Hood (t2)
        blocked.add(ItemID.LEAGUE_3_RELIC_HUNTER_HOOD_T3); // Shattered Hood (t3)
        blocked.add(ItemID.LEAGUE_3_RELIC_HUNTER_TOP_T1); // Shattered Top (t1)
        blocked.add(ItemID.LEAGUE_3_RELIC_HUNTER_TOP_T2); // Shattered Top (t2)
        blocked.add(ItemID.LEAGUE_3_RELIC_HUNTER_TOP_T3); // Shattered Top (t3)
        blocked.add(ItemID.LEAGUE_3_RELIC_HUNTER_LEGS_T1); // Shattered Trousers (t1)
        blocked.add(ItemID.LEAGUE_3_RELIC_HUNTER_LEGS_T2); // Shattered Trousers (t2)
        blocked.add(ItemID.LEAGUE_3_RELIC_HUNTER_LEGS_T3); // Shattered Trousers (t3)
        blocked.add(ItemID.LEAGUE_3_RELIC_HUNTER_BOOTS_T1); // Shattered Boots (t1)
        blocked.add(ItemID.LEAGUE_3_RELIC_HUNTER_BOOTS_T2); // Shattered Boots (t2)
        blocked.add(ItemID.LEAGUE_3_RELIC_HUNTER_BOOTS_T3); // Shattered Boots (t3)
        blocked.add(ItemID.SET_LEAGUE_3_RELICHUNTER_T1); // Shattered Relic Hunter (t1) Armour Set
        blocked.add(ItemID.SET_LEAGUE_3_RELICHUNTER_T2); // Shattered Relic Hunter (t2) Armour Set
        blocked.add(ItemID.SET_LEAGUE_3_RELICHUNTER_T3); // Shattered Relic Hunter (t3) Armour Set

        // Trailblazer Reloaded Leagues Rewards
        blocked.add(ItemID.LEAGUE_4_BANNER); // Trailblazer Reloaded Banner
        blocked.add(ItemID.LEAGUE_4_HOME_TELEPORT_SCROLL); // Trailblazer Reloaded Home Teleport Scroll
        blocked.add(ItemID.LEAGUE_4_DEATH_SCROLL); // Trailblazer Reloaded Death Scroll
        blocked.add(ItemID.LEAGUE_4_ALCHEMY_SCROLL); // Trailblazer Reloaded Alchemy Scroll
        blocked.add(ItemID.LEAGUE_4_VENGEANCE_SCROLL); // Trailblazer Reloaded Vengeance Scroll
        blocked.add(ItemID.LEAGUE_4_REJUVINATION_POOL_SCROLL); // Trailblazer Reloaded Rejuvenation Pool Scroll
        blocked.add(ItemID.LEAGUE_4_TORCH); // Trailblazer Reloaded Torch
        blocked.add(ItemID.TOXIC_BLOWPIPE_ORNAMENT_KIT); // Trailblazer Reloaded Blowpipe Ornament Kit
        blocked.add(ItemID.DINHS_BULWARK_ORNAMENT_KIT); // Trailblazer Reloaded Banner Bulwark Ornament Kit
        blocked.add(ItemID.LEAGUE_4_RELIC_HUNTER_HAT_T1); // Trailblazer Reloaded Headband (t1)
        blocked.add(ItemID.LEAGUE_4_RELIC_HUNTER_HAT_T2); // Trailblazer Reloaded Headband (t2)
        blocked.add(ItemID.LEAGUE_4_RELIC_HUNTER_HAT_T3); // Trailblazer Reloaded Headband (t3)
        blocked.add(ItemID.LEAGUE_4_RELIC_HUNTER_TOP_T1); // Trailblazer Reloaded Top (t1)
        blocked.add(ItemID.LEAGUE_4_RELIC_HUNTER_TOP_T2); // Trailblazer Reloaded Top (t2)
        blocked.add(ItemID.LEAGUE_4_RELIC_HUNTER_TOP_T3); // Trailblazer Reloaded Top (t3)
        blocked.add(ItemID.LEAGUE_4_RELIC_HUNTER_LEGS_T1); // Trailblazer Reloaded Trousers (t1)
        blocked.add(ItemID.LEAGUE_4_RELIC_HUNTER_LEGS_T2); // Trailblazer Reloaded Trousers (t2)
        blocked.add(ItemID.LEAGUE_4_RELIC_HUNTER_LEGS_T3); // Trailblazer Reloaded Trousers (t3)
        blocked.add(ItemID.LEAGUE_4_RELIC_HUNTER_BOOTS_T1); // Trailblazer Reloaded Boots (t1)
        blocked.add(ItemID.LEAGUE_4_RELIC_HUNTER_BOOTS_T2); // Trailblazer Reloaded Boots (t2)
        blocked.add(ItemID.LEAGUE_4_RELIC_HUNTER_BOOTS_T3); // Trailblazer Reloaded Boots (t3)
        blocked.add(ItemID.SET_LEAGUE_4_RELICHUNTER_T1); // Trailblazer Reloaded Relic Hunter (t1) Armour Set
        blocked.add(ItemID.SET_LEAGUE_4_RELICHUNTER_T2); // Trailblazer Reloaded Relic Hunter (t2) Armour Set
        blocked.add(ItemID.SET_LEAGUE_4_RELICHUNTER_T3); // Trailblazer Reloaded Relic Hunter (t3) Armour Set

        // Raging Echoes Leagues Rewards
        blocked.add(ItemID.LEAGUE_5_BANNER); // Raging Echoes
        blocked.add(ItemID.LEAGUE_5_RUG); // Raging Echoes Rug
        blocked.add(ItemID.LEAGUE_5_CURTAINS); // Raging Echoes Curtains
        blocked.add(ItemID.LEAGUE_5_SPIRIT_TREE_SCROLL); // Raging Echoes Spirit Tree Scroll
        blocked.add(ItemID.LEAGUE_5_NEXUS_SCROLL); // Raging Echoes Portal Nexus Scroll
        blocked.add(ItemID.LEAGUE_5_SCRYING_SCROLL); // Raging Echoes Scrying Pool Scroll
        blocked.add(ItemID.LEAGUE_5_PORTAL_SCROLL); // Raging Echoes Portal Scroll
        blocked.add(ItemID.LEAGUE_5_HOME_TELEPORT_SCROLL); // Raging Echoes Home Teleport
        blocked.add(ItemID.LEAGUE_5_DEATH_SCROLL); // Raging Echoes Death Scroll
        blocked.add(ItemID.LEAGUE_5_CONTACT_SCROLL); // Raging Echoes NPC Contact Scroll
        blocked.add(ItemID.LEAGUE5_RELIC_HUNTER_CANE); // Raging Echoes Cane
        blocked.add(ItemID.BARROWS_AHRIM_ORNAMENT_KIT); // Echo Ahrim's Robes Ornament Kit
        blocked.add(ItemID.BARROWS_AHRIM_WEAPON); // Echo Ahrim's Staff Ornament Kit
        blocked.add(ItemID.VIRTUS_ORNAMENT_KIT); // Echo Virtus Robes Ornament Kit
        blocked.add(ItemID.VENATOR_BOW_ORNAMENT_KIT); // Echo Venator Bow Ornament Kit
        blocked.add(ItemID.LEAGUE5_RELIC_HUNTER_HAT_T1); // Raging Echoes Hat (t1)
        blocked.add(ItemID.LEAGUE5_RELIC_HUNTER_HAT_T2); // Raging Echoes Hat (t2)
        blocked.add(ItemID.LEAGUE5_RELIC_HUNTER_HAT_T3); // Raging Echoes Hat (t3)
        blocked.add(ItemID.LEAGUE5_RELIC_HUNTER_TOP_T1); // Raging Echoes Top (t1)
        blocked.add(ItemID.LEAGUE5_RELIC_HUNTER_TOP_T2); // Raging Echoes Top (t2)
        blocked.add(ItemID.LEAGUE5_RELIC_HUNTER_TOP_T3); // Raging Echoes Top (t3)
        blocked.add(ItemID.LEAGUE5_RELIC_HUNTER_LEGS_T1); // Raging Echoes Robeskirt (t1)
        blocked.add(ItemID.LEAGUE5_RELIC_HUNTER_LEGS_T2); // Raging Echoes Robeskirt (t2)
        blocked.add(ItemID.LEAGUE5_RELIC_HUNTER_LEGS_T3); // Raging Echoes Robeskirt (t3)
        blocked.add(ItemID.LEAGUE5_RELIC_HUNTER_BOOTS_T1); // Raging Echoes Boots (t1)
        blocked.add(ItemID.LEAGUE5_RELIC_HUNTER_BOOTS_T2); // Raging Echoes Boots (t2)
        blocked.add(ItemID.LEAGUE5_RELIC_HUNTER_BOOTS_T3); // Raging Echoes Boots (t3)
        blocked.add(ItemID.SET_LEAGUE_5_RELICHUNTER_T1); // Raging Echoes Relic Hunter (t1) Armour Set
        blocked.add(ItemID.SET_LEAGUE_5_RELICHUNTER_T2); // Raging Echoes Relic Hunter (t2) Armour Set
        blocked.add(ItemID.SET_LEAGUE_5_RELICHUNTER_T3); // Raging Echoes Relic Hunter (t3) Armour Set

        // Unobtainable Items
        blocked.add(ItemID.CHOMPY_COOKED); // Cooked Chompy (roasted)
        blocked.add(ItemID.CHICKENQUEST_CORNFLOUR); // Cornflour
        blocked.add(ItemID.POH_FLATPACK_CRYSTALBALL1); // Crystal Ball (FLATPACK)
        blocked.add(ItemID.POH_FLATPACK_CRYSTALBALL2); // Elemental Sphere (FLATPACK)
        blocked.add(ItemID.POH_FLATPACK_CRYSTALBALL3); // Crystal Of Power (FLATPACK)
        blocked.add(ItemID.POH_FLATPACK_GLOBE1); // Globe (FLATPACK)
        blocked.add(ItemID.POH_FLATPACK_GLOBE2); // Ornamental Globe (FLATPACK)
        blocked.add(ItemID.POH_FLATPACK_GLOBE3); // Lunar Globe (FLATPACK)
        blocked.add(ItemID.POH_FLATPACK_GLOBE4); // Celestial Globe (FLATPACK)
        blocked.add(ItemID.POH_FLATPACK_GLOBE5); // Armillary Globe (FLATPACK)
        blocked.add(ItemID.POH_FLATPACK_GLOBE6); // Small Orrery (FLATPACK)
        blocked.add(ItemID.POH_FLATPACK_GLOBE7); // Large Orrery (FLATPACK)
        blocked.add(ItemID.POH_FLATPACK_TELESCOPE1); // Oak Telescope (FLATPACK)
        blocked.add(ItemID.POH_FLATPACK_TELESCOPE2); // Teak Telescope (FLATPACK)
        blocked.add(ItemID.POH_FLATPACK_TELESCOPE3); // Mahogany (FLATPACK)
        blocked.add(ItemID.UNFINISHED_WORM_CRUNCHIES); // Rock-Climbing Boots
        blocked.add(ItemID.OSB9_REPORT); // Osman's Report
        blocked.add(ItemID.FEUD_KARIDIAN_FAKEBEARD_AND_HAT); // Karidian Disguise
        blocked.add(ItemID.POH_FLATPACK_LECTURN1); // Oak Lectern (FLATPACK)
        blocked.add(ItemID.POH_FLATPACK_LECTURN2); // Eagle Lectern (FLATPACK)
        blocked.add(ItemID.POH_FLATPACK_LECTURN3); // Demon Lectern (FLATPACK)
        blocked.add(ItemID.POH_FLATPACK_LECTURN4); // Teak Eagle Lectern (FLATPACK)
        blocked.add(ItemID.POH_FLATPACK_LECTURN5); // Teak Demon Lectern (FLATPACK)
        blocked.add(ItemID.POH_FLATPACK_LECTURN6); // Mahogany Eagle (FLATPACK)
        blocked.add(ItemID.POH_FLATPACK_LECTURN7); // Mahogany Demon (FLATPACK)
        blocked.add(ItemID.BH_SUPPLY_CRATE); // Bounty Supply Crate
        BLOCKED_ITEMS = Collections.unmodifiableSet(blocked);
    }
}

package com.chanceman.filters;

import lombok.Getter;
import net.runelite.api.gameval.ItemID;
import java.util.Collections;
import java.util.HashSet;
import java.util.Set;

public enum ItemSets {

    // Items are sorted in the same order as displayed on the Grand Exchange interface
    DwarfCannon(ItemID.SET_CANNON),

    // Dragonhide sets
    GreenDragonhide(ItemID.SET_DHIDE_GREEN),
    BlueDragonhide(ItemID.SET_DHIDE_BLUE),
    RedDragonhide(ItemID.SET_DHIDE_RED),
    BlackDragonhide(ItemID.SET_DHIDE_BLACK),

    // Barrows armour sets
    Guthans(ItemID.SET_BARROWS_GUTHAN),
    Veracs(ItemID.SET_BARROWS_VERAC),
    Dharoks(ItemID.SET_BARROWS_DHAROK),
    Torags(ItemID.SET_BARROWS_TORAG),
    Ahrims(ItemID.SET_BARROWS_AHRIM),
    Karils(ItemID.SET_BARROWS_KARIL),

    // Potion sets
    CombatPotion(ItemID.SET_COMBAT_POTION),
    SuperPotion(ItemID.SET_SUPERCOMBAT_POTION),

    // Base metal armour sets
    BronzeLegs(ItemID.SET_BRONZE_LEGS),
    BronzeSkirt(ItemID.SET_BRONZE_SKIRT),

    IronLegs(ItemID.SET_IRON_LEGS),
    IronSkirt(ItemID.SET_IRON_SKIRT),

    SteelLegs(ItemID.SET_STEEL_LEGS),
    SteelSkirt(ItemID.SET_STEEL_SKIRT),

    BlackLegs(ItemID.SET_BLACK_LEGS),
    BlackSkirt(ItemID.SET_BLACK_SKIRT),

    MithrilLegs(ItemID.SET_MITHRIL_LEGS),
    MithrilSkirt(ItemID.SET_MITHRIL_SKIRT),

    AdamantLegs(ItemID.SET_ADAMANT_LEGS),
    AdamantSkirt(ItemID.SET_ADAMANT_SKIRT),

    RuneLegs(ItemID.SET_RUNE_LEGS),
    RuneSkirt(ItemID.SET_RUNE_SKIRT),

    // Trimmed and gilded base metal armour sets

    BronzeLegsTrim(ItemID.SET_BRONZE_LEGS_TRIM),
    BronzeSkirtTrim(ItemID.SET_BRONZE_SKIRT_TRIM),
    BronzeLegsGold(ItemID.SET_BRONZE_LEGS_GOLD),
    BronzeSkirtGold(ItemID.SET_BRONZE_SKIRT_GOLD),

    IronLegsTrim(ItemID.SET_IRON_LEGS_TRIM),
    IronSkirtTrim(ItemID.SET_IRON_SKIRT_TRIM),
    IronLegsGold(ItemID.SET_IRON_LEGS_GOLD),
    IronSkirtGold(ItemID.SET_IRON_SKIRT_GOLD),

    SteelLegsTrim(ItemID.SET_STEEL_LEGS_TRIM),
    SteelSkirtTrim(ItemID.SET_STEEL_SKIRT_TRIM),
    SteelLegsGold(ItemID.SET_STEEL_LEGS_GOLD),
    SteelSkirtGold(ItemID.SET_STEEL_SKIRT_GOLD),

    BlackLegsTrim(ItemID.SET_BLACK_LEGS_TRIM),
    BlackSkirtTrim(ItemID.SET_BLACK_SKIRT_TRIM),
    BlackLegsGold(ItemID.SET_BLACK_LEGS_GOLD),
    BlackSkirtGold(ItemID.SET_BLACK_SKIRT_GOLD),

    MithrilLegsTrim(ItemID.SET_MITHRIL_LEGS_TRIM),
    MithrilSkirtTrim(ItemID.SET_MITHRIL_SKIRT_TRIM),
    MithrilLegsGold(ItemID.SET_MITHRIL_LEGS_GOLD),
    MithrilSkirtGold(ItemID.SET_MITHRIL_SKIRT_GOLD),

    AdamantLegsTrim(ItemID.SET_ADAMANT_LEGS_TRIM),
    AdamantSkirtTrim(ItemID.SET_ADAMANT_SKIRT_TRIM),
    AdamantLegsGold(ItemID.SET_ADAMANT_LEGS_GOLD),
    AdamantSkirtGold(ItemID.SET_ADAMANT_SKIRT_GOLD),

    RuneLegsTrim(ItemID.SET_RUNE_LEGS_TRIM),
    RuneSkirtTrim(ItemID.SET_RUNE_SKIRT_TRIM),
    RuneLegsGold(ItemID.SET_RUNE_LEGS_GOLD),
    RuneSkirtGold(ItemID.SET_RUNE_SKIRT_GOLD),

    // Dragon armour sets
    DragonLegs(ItemID.SET_DRAGON_LEGS),
    DragonSkirt(ItemID.SET_DRAGON_SKIRT),

    // God rune armour sets
    SaradominLegs(ItemID.SET_RUNE_LEGS_SARADOMIN),
    SaradominSkirt(ItemID.SET_RUNE_SKIRT_SARADOMIN),

    ZamorakLegs(ItemID.SET_RUNE_LEGS_ZAMORAK),
    ZamorakSkirt(ItemID.SET_RUNE_SKIRT_ZAMORAK),

    GuthixLegs(ItemID.SET_RUNE_LEGS_GUTHIX),
    GuthixSkirt(ItemID.SET_RUNE_SKIRT_GUTHIX),

    ArmadylLegs(ItemID.SET_RUNE_LEGS_ARMADYL),
    ArmadylSkirt(ItemID.SET_RUNE_SKIRT_ARMADYL),

    BandosLegs(ItemID.SET_RUNE_LEGS_BANDOS),
    BandosSkirt(ItemID.SET_RUNE_SKIRT_BANDOS),

    AncientLegs(ItemID.SET_RUNE_LEGS_ANCIENT),
    AncientSkirt(ItemID.SET_RUNE_SKIRT_ANCIENT),

    // Gilded armour sets
    GildedArmourLegs(ItemID.SET_RUNE_LEGS_GOLDPLATE),
    GildedArmourSkirt(ItemID.SET_RUNE_SKIRT_GOLDPLATE),

    // God book page sets
    HolyBookPage(ItemID.SET_HOLY_BOOK),
    UnholyBookPage(ItemID.SET_UNHOLY_BOOK),
    BookBalancePage(ItemID.SET_BOOK_BALANCE),
    BookWarPage(ItemID.SET_BOOK_WAR),
    BookLawPage(ItemID.SET_BOOK_LAW),
    BookDarknessPage(ItemID.SET_BOOK_DARKNESS),

    // Dragonhide sets
    GildedDragonhide(ItemID.SET_DHIDE_GILDED),
    ZamorakDragonhide(ItemID.SET_DHIDE_ZAMORAK),
    SaradominDragonhide(ItemID.SET_DHIDE_SARADOMIN),
    GuthixDragonhide(ItemID.SET_DHIDE_GUTHIX),
    BandosDragonhide(ItemID.SET_DHIDE_BANDOS),
    ArmadylDragonhide(ItemID.SET_DHIDE_ARMADYL),
    AncientDragonhide(ItemID.SET_DHIDE_ANCIENT),

    // Miscellaneous sets
    PartyhatSet(ItemID.SET_PARTYHAT),
    HalloweenMaskSet(ItemID.SET_HALLOWEEN_MASK),
    AncestralRobes(ItemID.SET_ANCESTRAL_ROBES),
    ObsidianArmour(ItemID.SET_OBSIDIAN_ARMOUR),
    JusticiarArmour(ItemID.SET_JUSTICIAR_ARMOUR),
    MysticLight(ItemID.SET_MYSTIC_LIGHT),
    MysticBlue(ItemID.SET_MYSTIC_BLUE),
    MysticDark(ItemID.SET_MYSTIC_DARK),
    MysticDusk(ItemID.SET_MYSTIC_DUSK),
    DragonstoneArmour(ItemID.SET_DRAGONSTONE_ARMOUR),
    DagonhaiRobes(ItemID.SET_DAGONHAI_ROBES),
    InquisitorsArmour(ItemID.SET_INQUISITORS_ARMOUR),
    MasoriFortified(ItemID.SET_MASORI_FORTIFIED),
    // Leagues item sets are omitted as they are globally blocked
    SunfireFanatic(ItemID.SET_SUNFIRE_FANATIC);

    @Getter
    private final int id;

    ItemSets(int id) {
        this.id = id;
    }

    /**
     * Returns an unmodifiable set of all item set item IDs.
     */
    public static Set<Integer> getAllItemSetIds() {
        Set<Integer> ids = new HashSet<>();
        for (ItemSets as : ItemSets.values()) {
            ids.add(as.getId());
        }
        return Collections.unmodifiableSet(ids);
    }

    /**
     * Checks if the given item ID is one of the item set items.
     *
     * @param id the item id to check.
     * @return true if the id belongs to an item set, false otherwise.
     */
    public static boolean isItemSet(int id) {
        return getAllItemSetIds().contains(id);
    }
}

package com.chanceman.filters;

import lombok.Getter;

import java.util.Collections;
import java.util.HashMap;
import java.util.Map;

public final class EnsouledHeadMapping {
    public static final int DEFAULT_ENSOULED_HEAD_ID = -1;

    @Getter public static final Map<String, Integer> ENSOULED_HEAD_MAP;

    static {
        Map<String, Integer> ensouledMap = new HashMap<>();
        ensouledMap.put("ensouled abyssal head", 13508);
        ensouledMap.put("ensouled aviansie head", 13505);
        ensouledMap.put("ensouled bear head", 13463);
        ensouledMap.put("ensouled bloodveld head", 13496);
        ensouledMap.put("ensouled chaos druid head", 13472);
        ensouledMap.put("ensouled dagannoth head", 13493);
        ensouledMap.put("ensouled demon head", 13502);
        ensouledMap.put("ensouled dog head", 13469);
        ensouledMap.put("ensouled dragon head", 13511);
        ensouledMap.put("ensouled elf head", 13481);
        ensouledMap.put("ensouled giant head", 13475);
        ensouledMap.put("ensouled goblin head", 13448);
        ensouledMap.put("ensouled hellhound head", 26997);
        ensouledMap.put("ensouled horror head", 13487);
        ensouledMap.put("ensouled imp head", 13454);
        ensouledMap.put("ensouled kalphite head", 13490);
        ensouledMap.put("ensouled minotaur head", 13457);
        ensouledMap.put("ensouled monkey head", 13451);
        ensouledMap.put("ensouled ogre head", 13478);
        ensouledMap.put("ensouled scorpion head", 13460);
        ensouledMap.put("ensouled troll head", 13484);
        ensouledMap.put("ensouled tzhaar head", 13499);
        ensouledMap.put("ensouled unicorn head", 13466);
        ENSOULED_HEAD_MAP = Collections.unmodifiableMap(ensouledMap);
    }
}

package com.chanceman.filters;

import java.util.Set;

/**
 * Utility class for additional item filtering logic.
 */
public class ItemsFilter {

    /**
     * Checks if an item is blocked.
     * An item is blocked if it is in the blocked set,
     * or if it is a flatpack and flatpacks are disabled,
     * or if it is an item set and item sets are disabled.
     *
     * @param itemId the item id
     * @param enableFlatpacks true if flatpack items are allowed
     * @param enableItemSets true if item set items are allowed
     * @return true if the item is blocked; false otherwise
     */
    public static boolean isBlocked(int itemId, boolean enableFlatpacks, boolean enableItemSets) {
        return (!enableFlatpacks && Flatpacks.isFlatpack(itemId))
                || (!enableItemSets && ItemSets.isItemSet(itemId))
                || BlockedItems.getBLOCKED_ITEMS().contains(itemId);
    }

    /**
     * Returns the correct ensouled head ID for the given item name.
     * If not found, returns DEFAULT_ENSOULED_HEAD_ID.
     *
     * @param itemName the item name to check.
     * @return the ensouled head ID if found; otherwise DEFAULT_ENSOULED_HEAD_ID.
     */
    public static int getEnsouledHeadId(String itemName) {
        return (itemName == null)
                ? EnsouledHeadMapping.DEFAULT_ENSOULED_HEAD_ID
                : EnsouledHeadMapping.getENSOULED_HEAD_MAP().getOrDefault(
                itemName.toLowerCase(), EnsouledHeadMapping.DEFAULT_ENSOULED_HEAD_ID);
    }

    /**
     * Scans the provided text and returns the ensouled head ID if any known ensouled head key is found.
     * Returns DEFAULT_ENSOULED_HEAD_ID if no match is found.
     *
     * @param text the text to scan.
     * @return the ensouled head ID if a key is found; otherwise DEFAULT_ENSOULED_HEAD_ID.
     */
    public static int getEnsouledHeadIdFromText(String text) {
        if (text == null) {
            return EnsouledHeadMapping.DEFAULT_ENSOULED_HEAD_ID;
        }
        String lowerText = text.toLowerCase();
        for (String key : EnsouledHeadMapping.getENSOULED_HEAD_MAP().keySet()) {
            if (lowerText.contains(key)) {
                return EnsouledHeadMapping.getENSOULED_HEAD_MAP().get(key);
            }
        }
        return EnsouledHeadMapping.DEFAULT_ENSOULED_HEAD_ID;
    }

    /**
     * Checks if a poisonable weapon variant is eligible for rolling.
     * Base weapons are always eligible; for poisoned variants, if requireWeaponPoison is true,
     * the corresponding global weapon poison must also be unlocked.
     *
     * @param itemId the item id to check
     * @param requireWeaponPoison if true, the matching global poison must be unlocked
     * @param unlockedItems the set of unlocked item ids
     * @return true if eligible; false otherwise
     */
    public static boolean isPoisonEligible(int itemId, boolean requireWeaponPoison, Set<Integer> unlockedItems) {
        return PoisonWeapons.isPoisonVariantEligible(itemId, requireWeaponPoison, unlockedItems);
    }

    private boolean isGlobalWeaponPoison(int itemId) {
        return itemId == PoisonWeapons.WEAPON_POISON.getBaseId() ||
                itemId == PoisonWeapons.WEAPON_POISON_.getBaseId() ||
                itemId == PoisonWeapons.WEAPON_POISON__.getBaseId();
    }
}

package com.chanceman;

import net.runelite.api.Client;
import net.runelite.client.game.ItemManager;
import net.runelite.client.ui.overlay.Overlay;
import net.runelite.client.ui.overlay.OverlayLayer;
import net.runelite.client.ui.overlay.OverlayPosition;

import javax.inject.Inject;
import javax.inject.Singleton;
import java.awt.*;
import java.awt.geom.RoundRectangle2D;
import java.awt.image.BufferedImage;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.function.Supplier;

/**
 * Overlay for displaying the roll animation.
 * It renders a scrolling set of item icons and highlights the final item.
 */
@Singleton
public class ChanceManOverlay extends Overlay
{
    private final Client client;
    private final ItemManager itemManager;

    // Animation state
    private volatile boolean isAnimating = false;
    private long rollDuration;             // spin duration (ms)
    private long highlightDuration = 2000; // highlight duration (ms)
    private long rollStartTime = 0;

    // Spin parameters
    private float rollOffset = 0f;
    private float currentSpeed;
    private final float initialSpeed = 1200f;   // start speed (px/sec)
    private final float deceleration = 900f;    // px/sec^2
    private final float minSpeed = 300f;        // never go below this speed

    // Icon layout
    private final int iconCount = 5;
    private final int iconWidth = 32;
    private final int iconHeight = 32;
    private final int spacing = 5;

    // Extra width so icons don't spill out mid-scroll
    private final int extraWidthBuffer = 17;

    // Overall bounding box padding (internal margin)
    private final int outerPad = 5;

    // Vertical offset from the top of the 3D viewport
    private final int offsetFromTop = 20;

    // Shift the entire background box left by 20 pixels
    private final int boxShift = -20;

    // For drawing the background
    private final int cornerRadius = 10;
    private final float borderStrokeWidth = 2f;

    // List of rolling items (synchronized for thread safety)
    private final List<Integer> rollingItems = Collections.synchronizedList(new ArrayList<>());
    private Supplier<Integer> randomLockedItemSupplier;

    @Inject
    public ChanceManOverlay(Client client, ItemManager itemManager)
    {
        this.client = client;
        this.itemManager = itemManager;
        setPosition(OverlayPosition.DYNAMIC);
        setLayer(OverlayLayer.ABOVE_WIDGETS);
    }

    /**
     * Starts the roll animation.
     *
     * @param dummy Unused parameter.
     * @param rollDurationMs The duration of the roll phase in milliseconds.
     * @param randomLockedItemSupplier Supplier for obtaining random locked items.
     */
    public void startRollAnimation(int dummy, int rollDurationMs, Supplier<Integer> randomLockedItemSupplier)
    {
        this.rollDuration = rollDurationMs;
        this.rollStartTime = System.currentTimeMillis();
        this.rollOffset = 0f;
        this.currentSpeed = initialSpeed;
        this.randomLockedItemSupplier = randomLockedItemSupplier;
        this.isAnimating = true;

        synchronized (rollingItems) {
            rollingItems.clear();
            for (int i = 0; i < iconCount; i++)
            {
                rollingItems.add(randomLockedItemSupplier.get());
            }
        }
    }

    /**
     * Retrieves the final item ID based on the center icon after the roll animation finishes.
     *
     * @return The final item ID.
     */
    public int getFinalItem()
    {
        synchronized (rollingItems) {
            int centerIndex = iconCount / 2;
            if (rollingItems.size() > centerIndex)
            {
                return rollingItems.get(centerIndex);
            }
        }
        return 0;
    }

    /**
     * Renders the roll animation overlay.
     *
     * @param g The graphics context.
     * @return null (no preferred size).
     */
    @Override
    public Dimension render(Graphics2D g)
    {
        if (!isAnimating)
        {
            return null;
        }

        g.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);
        g.setRenderingHint(RenderingHints.KEY_INTERPOLATION, RenderingHints.VALUE_INTERPOLATION_BILINEAR);

        long now = System.currentTimeMillis();
        long elapsed = now - rollStartTime;
        boolean inHighlightPhase = (elapsed > rollDuration);

        if (elapsed > rollDuration + highlightDuration)
        {
            isAnimating = false;
            return null;
        }

        int vpX = client.getViewportXOffset();
        int vpY = client.getViewportYOffset();
        int vpWidth = client.getViewportWidth();
        int centerX = vpX + (vpWidth / 2);
        int boxTopY = vpY + offsetFromTop;

        int totalIconsWidth = iconCount * iconWidth + (iconCount - 1) * spacing;
        int totalWidthWithBuffer = totalIconsWidth + extraWidthBuffer;
        int boxWidth = totalWidthWithBuffer + outerPad * 2;
        int boxHeight = iconHeight + outerPad * 2;
        int boxLeftX = centerX - (boxWidth / 2) + boxShift;

        Shape backgroundRect = new RoundRectangle2D.Float(
                boxLeftX, boxTopY, boxWidth, boxHeight,
                cornerRadius, cornerRadius
        );
        g.setColor(new Color(0, 0, 0, 180));
        g.fill(backgroundRect);
        g.setColor(new Color(0, 0, 0, 255));
        g.setStroke(new BasicStroke(borderStrokeWidth));
        g.draw(backgroundRect);

        synchronized (rollingItems) {
            if (!inHighlightPhase)
            {
                float dt = 1f / 60f;
                rollOffset += currentSpeed * dt;
                currentSpeed = Math.max(currentSpeed - deceleration * dt, minSpeed);

                if (rollOffset >= (iconWidth + spacing))
                {
                    rollOffset -= (iconWidth + spacing);
                    if (!rollingItems.isEmpty())
                    {
                        rollingItems.remove(0);
                    }
                    rollingItems.add(randomLockedItemSupplier.get());
                }
            }

            int iconsLeftX = centerX - (totalIconsWidth / 2);
            int iconsY = boxTopY + outerPad;
            for (int i = 0; i < rollingItems.size(); i++)
            {
                int itemId = rollingItems.get(i);
                BufferedImage image = itemManager.getImage(itemId, 1, false);
                if (image != null)
                {
                    int drawX = (int) (iconsLeftX + i * (iconWidth + spacing) - rollOffset);
                    g.drawImage(image, drawX, iconsY, iconWidth, iconHeight, null);
                }
            }

            if (inHighlightPhase)
            {
                int centerIndex = iconCount / 2;
                int highlightX = (int) (iconsLeftX + centerIndex * (iconWidth + spacing) - rollOffset);
                g.setColor(Color.YELLOW);
                g.setStroke(new BasicStroke(3f));
                g.drawRect(highlightX, iconsY, iconWidth, iconHeight);
            }
        }
        return null;
    }
}

package com.chanceman.menus;

import lombok.Getter;

import java.util.HashMap;
import java.util.HashSet;

public enum SkillOp
{
	CHOP_DOWN("Chop down"),
	MINE("Mine"),
	SMALL_NET("Small Net"),
	BIG_NET("Big Net"),
	CAGE("Cage"),
	BAIT("Bait"),
	LURE("Lure"),
	RAKE("Rake"),
	PRUNE("Prune"),
	CURE("Cure"),
	GRIND("Grind"),
	SMITH("Smith"),
	SMELT("Smelt"),
	SHEAR("Shear"),
	CLEAN("Clean"),
	CRAFT_RUNE("Craft-rune");

	@Getter private final String option;

	SkillOp(String option)
	{
		this.option = option;
	}

	private static final HashSet<String> ALL_SKILL_OPS = new HashSet<>();
	private static final HashMap<String, SkillOp> STRING_TO_OP = new HashMap<>();

	static
	{
		for (SkillOp skillOp : SkillOp.values())
		{
			ALL_SKILL_OPS.add(skillOp.option);
			STRING_TO_OP.put(skillOp.option, skillOp);
		}
	}

	public static boolean isSkillOp(String option)
	{
		return ALL_SKILL_OPS.contains(option);
	}

	public static SkillOp fromString(String option)
	{
		if (!isSkillOp(option)) return null;
		return STRING_TO_OP.get(option);
	}
}

package com.chanceman.menus;

import com.chanceman.ChanceManPlugin;
import com.chanceman.UnlockedItemsManager;
import lombok.Getter;
import lombok.Setter;
import net.runelite.api.Client;
import net.runelite.api.GameState;
import net.runelite.api.MenuAction;
import net.runelite.api.MenuEntry;
import net.runelite.api.events.MenuOptionClicked;
import net.runelite.api.events.MenuEntryAdded;
import net.runelite.api.events.WidgetClosed;
import net.runelite.api.events.WidgetLoaded;
import net.runelite.client.eventbus.EventBus;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.game.ItemManager;
import net.runelite.client.util.Text;

import javax.inject.Inject;
import javax.inject.Singleton;
import java.util.HashSet;
import java.util.function.Consumer;

@Singleton
public class ActionHandler {

	private final HashSet<MenuAction> disabledActions = new HashSet<>() {{
		add(MenuAction.CC_OP); // covers all inventory item ops
		add(MenuAction.WIDGET_TARGET); // disable Use options on locked items
		add(MenuAction.WIDGET_TARGET_ON_WIDGET); // disable using other items on locked items
		add(MenuAction.GROUND_ITEM_FIRST_OPTION);
		add(MenuAction.GROUND_ITEM_SECOND_OPTION);
		add(MenuAction.GROUND_ITEM_THIRD_OPTION);
		add(MenuAction.GROUND_ITEM_FOURTH_OPTION);
		add(MenuAction.GROUND_ITEM_FIFTH_OPTION);
	}};

	private final HashSet<Integer> enabledUIs = new HashSet<>() {{
		add(EnabledUI.BANK.getId());
		add(EnabledUI.DEPOSIT_BOX.getId());
	}};

	@Inject
	private Client client;
	@Inject
	private EventBus eventBus;
	@Inject
	private ChanceManPlugin plugin;
	@Inject
	private Restrictions restrictions;
	@Inject
	private UnlockedItemsManager unlockedItemsManager;
	@Getter
	@Setter
	private int enabledUIOpen = -1;

	// A no-op click handler that marks a menu entry as disabled.
	private final Consumer<MenuEntry> DISABLED = e -> { };

	public void startUp() {
		eventBus.register(this);
		eventBus.register(restrictions);
	}

	public void shutDown() {
		eventBus.unregister(this);
		eventBus.unregister(restrictions);
	}

	private boolean enabledUiOpen() {
		return enabledUIOpen != -1;
	}

	private boolean inactive() {
		if (!unlockedItemsManager.ready()) return true;
		return client.getGameState().getState() < GameState.LOADING.getState();
	}

	@Subscribe
	public void onWidgetClosed(WidgetClosed event) {
		if (enabledUIs.contains(event.getGroupId()))
			enabledUIOpen = -1;
	}

	@Subscribe
	public void onWidgetLoaded(WidgetLoaded event) {
		if (enabledUIs.contains(event.getGroupId()))
			enabledUIOpen = event.getGroupId();
	}

	@Subscribe
	public void onMenuEntryAdded(MenuEntryAdded event) {
		if (inactive()) return;

		MenuEntry entry = event.getMenuEntry();
		MenuAction action = entry.getType();
		int id = Math.max(event.getItemId(), entry.getItemId());
		boolean enabled;
		// Check if the entry looks like it's for a ground item.
		if (isGroundItem(entry)) {
			enabled = !isLockedGroundItem(entry);
		} else {
			enabled = isEnabled(id, entry, action);
		}
		// If not enabled, grey out the text and set the click handler to DISABLED.
		if (!enabled) {
			String option = Text.removeTags(entry.getOption());
			String target = Text.removeTags(entry.getTarget());
			entry.setOption("<col=808080>" + option);
			entry.setTarget("<col=808080>" + target);
			entry.onClick(DISABLED);
		}
	}

	@Subscribe
	public void onMenuOptionClicked(MenuOptionClicked event) {
		// If the entry is disabled, consume the event.
		if (event.getMenuEntry().onClick() == DISABLED) {
			event.consume();
			return;
		}
		// Extra safeguard for ground items.
		handleGroundItems(plugin.getItemManager(), unlockedItemsManager, event, plugin);
	}

	/**
	 * Returns true if the entry appears to be for a ground item.
	 */
	private boolean isGroundItem(MenuEntry entry) {
		String option = Text.removeTags(entry.getOption()).toLowerCase();
		MenuAction action = entry.getType();
		return action.toString().contains("GROUND_ITEM")
				|| option.contains("take")
				|| option.contains("pick-up")
				|| option.contains("pickup");
	}

	/**
	 * Checks if a MenuEntry represents a locked ground item.
	 * That is, if it's a ground item action (such as "Take") for an item that is tradeable,
	 * not excluded, and still locked.
	 */
	private boolean isLockedGroundItem(MenuEntry entry) {
		String option = Text.removeTags(entry.getOption()).toLowerCase();
		// Always allow "Drop" actions.
		if (option.equalsIgnoreCase("drop"))
			return false;
		int rawItemId = entry.getIdentifier() != -1 ? entry.getIdentifier() : entry.getItemId();
		int canonicalId = plugin.getItemManager().canonicalize(rawItemId);
		return plugin.isTradeable(canonicalId)
				&& !plugin.isNotTracked(canonicalId)
				&& !unlockedItemsManager.isUnlocked(canonicalId);
	}

	/**
	 * This method handles non-ground items (or any other cases) by checking if the item is enabled.
	 * It returns true if the action should be allowed.
	 */
	private boolean isEnabled(int id, MenuEntry entry, MenuAction action) {
		String option = Text.removeTags(entry.getOption());
		String target = Text.removeTags(entry.getTarget());

		// Always allow "Drop"
		if (option.equalsIgnoreCase("drop"))
			return true;

		if (SkillOp.isSkillOp(option))
			return restrictions.isSkillOpEnabled(option);
		else if (Spell.isSpell(target))
			return restrictions.isSpellOpEnabled();

		boolean enabled;
		if (enabledUiOpen()) {
			enabled = option.startsWith("Deposit") || option.startsWith("Examine") || option.startsWith("Withdraw");
		} else {
			enabled = !disabledActions.contains(action);
		}
		if (enabled)
			return true;
		if (id == 0 || id == -1 || !plugin.isInPlay(id))
			return true;
		return unlockedItemsManager.isUnlocked(entry.getItemId());
	}

	/**
	 * A static helper to further safeguard ground item actions.
	 * If a ground item is locked, this method consumes the event.
	 */
	public static void handleGroundItems(ItemManager itemManager, UnlockedItemsManager unlockedItemsManager,
										 MenuOptionClicked event, ChanceManPlugin plugin) {
		String option = event.getMenuEntry().getOption().toLowerCase();
		if (event.getMenuAction() != null &&
				(event.getMenuAction().toString().contains("GROUND_ITEM")
						|| option.contains("take")
						|| option.contains("pick-up")
						|| option.contains("pickup"))) {
			int rawItemId = event.getId() != -1 ? event.getId() : event.getMenuEntry().getItemId();
			int canonicalGroundId = itemManager.canonicalize(rawItemId);
			if (plugin.isTradeable(canonicalGroundId)
					&& !plugin.isNotTracked(canonicalGroundId)
					&& unlockedItemsManager != null
					&& !unlockedItemsManager.isUnlocked(canonicalGroundId)) {
				event.consume();
			}
		}
	}
}

package com.chanceman.menus;

import lombok.Getter;

import java.util.HashSet;

public enum Spell
{
	// STANDARD
	WIND_STRIKE("Wind Strike"),
	WATER_STRIKE("Water Strike"),
	EARTH_STRIKE("Earth Strike"),
	FIRE_STRIKE("Fire Strike"),
	WIND_BOLT("Wind Bolt"),
	WATER_BOLT("Water Bolt"),
	EARTH_BOLT("Earth Bolt"),
	FIRE_BOLT("Fire Bolt"),
	WIND_BLAST("Wind Blast"),
	WATER_BLAST("Water Blast"),
	EARTH_BLAST("Earth Blast"),
	FIRE_BLAST("Fire Blast"),
	WIND_WAVE("Wind Wave"),
	WATER_WAVE("Water Wave"),
	EARTH_WAVE("Earth Wave"),
	FIRE_WAVE("Fire Wave"),
	WIND_SURGE("Wind Surge"),
	WATER_SURGE("Water Surge"),
	EARTH_SURGE("Earth Surge"),
	FIRE_SURGE("Fire Surge"),
	SARADOMIN_STRIKE("Saradomin Strike"),
	CLAWS_OF_GUTHIX("Claws of Guthix"),
	FLAMES_OF_ZAMORAK("Flames of Zamorak"),
	CHARGE("Charge"),
	TELEBLOCK("Tele Block"),
	WEAKEN("Weaken"),
	CONFUSE("Confuse"),
	CURSE("Curse"),
	STUN("Stun"),
	VULNERABILITY("Vulnerability"),
	ENFEEBLE("Enfeeble"),
	BIND("Bind"),
	SNARE("Snare"),
	ENTANGLE("Entangle"),
	LOW_LEVEL_ALCHEMY("Low Level Alchemy"),
	HIGH_LEVEL_ALCHEMY("High Level Alchemy"),
	TELEKINETIC_GRAB("Telekinetic Grab"),
	VARROCK_TELEPORT("Varrock Teleport"),
	LUMBRIDGE_TELEPORT("Lumbridge Teleport"),
	FALADOR_TELEPORT("Falador Teleport"),
	CAMELOT_TELEPORT("Camelot Teleport"),
	ARDOUGNE_TELEPORT("Ardougne Teleport"),
	CIVITAS_ILLA_FORTIS_TELEPORT("Civitas illa Fortis Teleport"),
	TROLLHEIM_TELEPORT("Trollheim Teleport"),
	WATCHTOWER_TELEPORT("Watchtower Teleport"),
	TELEPORT_TO_HOUSE("Teleport to House"),
	APE_ATOLL_TELEPORT("Ape Atoll Teleport"),
	KOUREND_CASTLE_TELEPORT("Kourend Castle Teleport"),
	LVL_1_ENCHANT("Lvl-1 Enchant"),
	LVL_2_ENCHANT("Lvl-2 Enchant"),
	LVL_3_ENCHANT("Lvl-3 Enchant"),
	LVL_4_ENCHANT("Lvl-4 Enchant"),
	LVL_5_ENCHANT("Lvl-5 Enchant"),
	LVL_6_ENCHANT("Lvl-6 Enchant"),
	LVL_7_ENCHANT("Lvl-7 Enchant"),
	CRUMBLE_UNDEAD("Crumble Undead"),
	MAGIC_DART("Magic Dart"),
	IBAN_BLAST("Iban Blast"),
	BONES_TO_BANANAS("Bones to Bananas"),
	BONES_TO_PEACHES("Bones to Peaches"),
	SUPERHEAT_ITEM("Superheat Item"),
	TELEOTHER_LUMBRIDGE("Teleother Lumbridge"),
	TELEOTHER_VARROCK("Teleother Varrock"),
	TELEOTHER_FALADOR("Teleother Falador"),
	TELEOTHER_CAMELOT("Teleother Camelot"),
	CHARGE_WATER_ORB("Charge Water Orb"),
	CHARGE_EARTH_ORB("Charge Earth Orb"),
	CHARGE_FIRE_ORB("Charge Fire Orb"),
	CHARGE_AIR_ORB("Charge Air Orb"),

	// ANCIENT
	SMOKE_RUSH("Smoke Rush"),
	SHADOW_RUSH("Shadow Rush"),
	BLOOD_RUSH("Blood Rush"),
	ICE_RUSH("Ice Rush"),
	SMOKE_BURST("Smoke Burst"),
	SHADOW_BURST("Shadow Burst"),
	BLOOD_BURST("Blood Burst"),
	ICE_BURST("Ice Burst"),
	SMOKE_BLITZ("Smoke Blitz"),
	SHADOW_BLITZ("Shadow Blitz"),
	BLOOD_BLITZ("Blood Blitz"),
	ICE_BLITZ("Ice Blitz"),
	SMOKE_BARRAGE("Smoke Barrage"),
	SHADOW_BARRAGE("Shadow Barrage"),
	BLOOD_BARRAGE("Blood Barrage"),
	ICE_BARRAGE("Ice Barrage"),
	PADDEWWA_TELEPORT("Paddewwa Teleport"),
	SENNTISTEN_TELEPORT("Senntisten Teleport"),
	KHARYRLL_TELEPORT("Kharyrll Teleport"),
	LASSAR_TELEPORT("Lassar Teleport"),
	DAREEYAK_TELEPORT("Dareeyak Teleport"),
	CARRALLANGER_TELEPORT("Carrallanger Teleport"),
	TELEPORT_TO_TARGET("Teleport to Target"),
	ANNAKARL_TELEPORT("Annakarl Teleport"),
	GHORROCK_TELEPORT("Ghorrock Teleport"),

	// ARCEUUS
	ARCEUUS_LIBRARY_TELEPORT("Arceuus Library Teleport"),
	DRAYNOR_MANOR_TELEPORT("Draynor Manor Teleport"),
	BATTLEFRONT_TELEPORT("Battlefront Teleport"),
	MIND_ALTAR_TELEPORT("Mind Altar Teleport"),
	RESPAWN_TELEPORT("Respawn Teleport"),
	SALVE_GRAVEYARD_TELEPORT("Salve Graveyard Teleport"),
	FENKENSTRAINS_CASTLE_TELEPORT("Fenkenstrain's Castle Teleport"),
	WEST_ARDOUGNE_TELEPORT("West Ardougne Teleport"),
	HARMONY_ISLAND_TELEPORT("Harmony Island Teleport"),
	CEMETERY_TELEPORT("Cemetery Teleport"),
	BARROWS_TELEPORT("Barrows Teleport"),
	TELEPORT_TO_TARGET_ARC("Teleport to Target"),
	GHOSTLY_GRASP("Ghostly Grasp"),
	SKELETAL_GRASP("Skeletal Grasp"),
	UNDEAD_GRASP("Undead Grasp"),
	INFERIOR_DEMONBANE("Inferior Demonbane"),
	SUPERIOR_DEMONBANE("Superior Demonbane"),
	DARK_DEMONBANE("Dark Demonbane"),
	LESSER_CORRUPTION("Lesser Corruption"),
	GREATER_CORRUPTION("Greater Corruption"),
	RESURRECT_LESSER_GHOST("Resurrect Lesser Ghost"),
	RESURRECT_LESSER_SKELETON("Resurrect Lesser Skeleton"),
	RESURRECT_LESSER_ZOMBIE("Resurrect Lesser Zombie"),
	RESURRECT_SUPERIOR_GHOST("Resurrect Superior Ghost"),
	RESURRECT_SUPERIOR_SKELETON("Resurrect Superior Skeleton"),
	RESURRECT_SUPERIOR_ZOMBIE("Resurrect Superior Zombie"),
	RESURRECT_GREATER_GHOST("Resurrect Greater Ghost"),
	RESURRECT_GREATER_SKELETON("Resurrect Greater Skeleton"),
	RESURRECT_GREATER_ZOMBIE("Resurrect Greater Zombie"),
	DARK_LURE("Dark Lure"),
	MARK_OF_DARKNESS("Mark of Darkness"),
	WARD_OF_ARCEUUS("Ward of Arceuus"),
	BASIC_REANIMATION("Basic Reanimation"),
	ADEPT_REANIMATION("Adept Reanimation"),
	EXPERT_REANIMATION("Expert Reanimation"),
	MASTER_REANIMATION("Master Reanimation"),
	DEMONIC_OFFERING("Demonic Offering"),
	SINISTER_OFFERING("Sinister Offering"),
	SHADOW_VEIL("Shadow Veil"),
	VILE_VIGOUR("Vile Vigour"),
	DEGRIME("Degrime"),
	RESURRECT_CROPS("Resurrect Crops"),
	DEATH_CHARGE("Death Charge");

	@Getter private final String spellName;

	Spell(String spellName)
	{
		this.spellName = spellName;
	}

	private static final HashSet<String> ALL_SPELLS = new HashSet<>();

	static
	{
		for (Spell spell : Spell.values())
		{
			ALL_SPELLS.add(spell.getSpellName());
		}
	}

	public static boolean isSpell(String target)
	{
		return ALL_SPELLS.contains(target);
	}
}

package com.chanceman.menus;

import lombok.Getter;

import java.util.HashSet;

public enum SkillItem
{

	BRONZE_AXE(1351, SkillOp.CHOP_DOWN),
	IRON_AXE(1349, SkillOp.CHOP_DOWN),
	STEEL_AXE(1353, SkillOp.CHOP_DOWN),
	BLACK_AXE(1361, SkillOp.CHOP_DOWN),
	MITHRIL_AXE(1355, SkillOp.CHOP_DOWN),
	ADAMANT_AXE(1357, SkillOp.CHOP_DOWN),
	RUNE_AXE(1359, SkillOp.CHOP_DOWN),
	DRAGON_AXE(6739, SkillOp.CHOP_DOWN),
	THIRD_AGE_AXE(20011, SkillOp.CHOP_DOWN),

	BRONZE_PICKAXE(1265, SkillOp.MINE),
	IRON_PICKAXE(1267, SkillOp.MINE),
	STEEL_PICKAXE(1269, SkillOp.MINE),
	BLACK_PICKAXE(12297, SkillOp.MINE),
	MITHRIL_PICKAXE(1273, SkillOp.MINE),
	RUNE_PICKAXE(1275, SkillOp.MINE),

	SMALL_FISHING_NET(303, SkillOp.SMALL_NET),
	BIG_FISHING_NET(305, SkillOp.BIG_NET),
	LOBSTER_POT(301, SkillOp.CAGE),
	FISHING_BAIT(313, SkillOp.BAIT),
	FLY_FISHING_ROD(309, SkillOp.LURE),
	RAKE(5341, SkillOp.RAKE),

	BRONZE_BAR(2349, SkillOp.SMITH),
	IRON_BAR(2351, SkillOp.SMITH),
	STEEL_BAR(2353, SkillOp.SMITH),
	MITHRIL_BAR(2359, SkillOp.SMITH),
	ADAMANTITE_BAR(2361, SkillOp.SMITH),
	RUNITE_BAR(2363, SkillOp.SMITH),

	TIN_ORE(438, SkillOp.SMELT),
	COPPER_ORE(436, SkillOp.SMELT),
	IRON_ORE(440, SkillOp.SMELT),
	COAL(453, SkillOp.SMELT),
	MITHRIL_ORE(447, SkillOp.SMELT),
	RUNITE_ORE(451, SkillOp.SMELT),
	SILVER_ORE(442, SkillOp.SMELT),
	GOLD_ORE(444, SkillOp.SMELT),

	GRIMY_GUAM_LEAF(199, SkillOp.CLEAN),
	GRIMY_MARRENTILL(201, SkillOp.CLEAN),
	GRIMY_TARROMIN(203, SkillOp.CLEAN),
	GRIMY_HARRALANDER(205, SkillOp.CLEAN),
	GRIMY_RANARR_WEED(207, SkillOp.CLEAN),
	GRIMY_IRIT_LEAF(209, SkillOp.CLEAN),
	GRIMY_AVANTOE(211, SkillOp.CLEAN),
	GRIMY_KWUARM(213, SkillOp.CLEAN),
	GRIMY_CADANTINE(215, SkillOp.CLEAN),
	GRIMY_DWARF_WEED(217, SkillOp.CLEAN),
	GRIMY_TORSTOL(219, SkillOp.CLEAN),
	GRIMY_LANTADYME(2485, SkillOp.CLEAN),
	GRIMY_TOADFLAX(3049, SkillOp.CLEAN),
	GRIMY_SNAPDRAGON(3051, SkillOp.CLEAN),

	RUNE_ESSENCE(1436, SkillOp.CRAFT_RUNE),
	PURE_ESSENCE(7936, SkillOp.CRAFT_RUNE);

	@Getter private final int id;
	@Getter private final SkillOp option;

	SkillItem(int id, SkillOp option)
	{
		this.id = id;
		this.option = option;
	}

	public SkillOp getSkillOp()
	{
		return option;
	}

	private static final HashSet<Integer> ALL_SKILL_ITEMS = new HashSet<>();

	static
	{
		for (SkillItem skillItem : SkillItem.values())
		{
			ALL_SKILL_ITEMS.add(skillItem.getId());
		}
	}

	public static boolean isSkillItem(int id)
	{
		return ALL_SKILL_ITEMS.contains(id);
	}
}

package com.chanceman.menus;

import lombok.Getter;

import java.util.HashMap;
import java.util.HashSet;

public enum RuneProvider
{
	// Banana (yeah)
	BANANA(1963),

	// Runes
	AIR_RUNE(556),
	WATER_RUNE(555),
	EARTH_RUNE(557),
	FIRE_RUNE(554),
	MIND_RUNE(558),
	BODY_RUNE(559),
	COSMIC_RUNE(564),
	CHAOS_RUNE(562),
	NATURE_RUNE(561),
	LAW_RUNE(563),
	DEATH_RUNE(560),
	BLOOD_RUNE(565),
	SOUL_RUNE(566),
	WRATH_RUNE(21880),
	SUNFIRE_RUNE(false, 28929, FIRE_RUNE),

	// Elemental equipment
	AIR_STAFF(true, 1381, AIR_RUNE),
	WATER_STAFF(true, 1383, WATER_RUNE),
	EARTH_STAFF(true, 1385, EARTH_RUNE),
	FIRE_STAFF(true, 1387, FIRE_RUNE),
	AIR_BATTLESTAFF(true, 1397, AIR_RUNE),
	WATER_BATTLESTAFF(true, 1395, WATER_RUNE),
	EARTH_BATTLESTAFF(true, 1399, EARTH_RUNE),
	FIRE_BATTLESTAFF(true, 1393, FIRE_RUNE),
	TOME_OF_FIRE(true, 20714, FIRE_RUNE),
	TOME_OF_WATER(true, 25574, WATER_RUNE),
	TOME_OF_EARTH(true, 30064, EARTH_RUNE),

	// Combo runes
	MIST_RUNE(false, 4695, AIR_RUNE, WATER_RUNE),
	DUST_RUNE(false, 4696, AIR_RUNE, EARTH_RUNE),
	MUD_RUNE(false, 4698, WATER_RUNE, EARTH_RUNE),
	SMOKE_RUNE(false, 4697, FIRE_RUNE, AIR_RUNE),
	STEAM_RUNE(false, 4694, WATER_RUNE, FIRE_RUNE),
	LAVA_RUNE(false, 4699, EARTH_RUNE, FIRE_RUNE),

	// Combo staves
	MIST_STAFF(true, 20730, AIR_RUNE, WATER_RUNE),
	MYSTIC_MIST_STAFF(true, 20733, AIR_RUNE, WATER_RUNE),
	DUST_STAFF(true, 20736, AIR_RUNE, EARTH_RUNE),
	MYSTIC_DUST_STAFF(true, 20739, AIR_RUNE, EARTH_RUNE),
	MUD_STAFF(true, 6562, WATER_RUNE, EARTH_RUNE),
	MYSTIC_MUD_STAFF(true, 6563, WATER_RUNE, EARTH_RUNE),
	SMOKE_STAFF(true, 11998, FIRE_RUNE, AIR_RUNE),
	MYSTIC_SMOKE_STAFF(true, 12000, FIRE_RUNE, AIR_RUNE),
	STEAM_STAFF(true, 11787, WATER_RUNE, FIRE_RUNE),
	MYSTIC_STEAM_STAFF(true, 11789, WATER_RUNE, FIRE_RUNE),
	LAVA_STAFF(true, 3053, EARTH_RUNE, FIRE_RUNE),
	MYSTIC_LAVA_STAFF(true, 3054, EARTH_RUNE, FIRE_RUNE),

	// Other
	BRYOPHYTAS_STAFF_CHARGED(true, 22370, NATURE_RUNE);

	@Getter private final boolean requiresEquipped;
	@Getter private final int id;
	@Getter private final HashSet<Integer> provides = new HashSet<>();

	RuneProvider(int id)
	{
		this.requiresEquipped = false;
		this.id = id;
		this.provides.add(id);
	}

	RuneProvider(boolean requiresEquipped, int id, RuneProvider... provides)
	{
		this.requiresEquipped = requiresEquipped;
		this.id = id;
		for (RuneProvider runeProvider : provides) this.provides.addAll(runeProvider.getProvides());
	}

	private static final HashSet<Integer> EQUIPPED_PROVIDERS = new HashSet<>();
	private static final HashSet<Integer> INV_PROVIDERS = new HashSet<>();
	private static final HashMap<Integer, HashSet<Integer>> PROVIDER_TO_PROVIDED = new HashMap<>();

	static
	{
		for (RuneProvider runeProvider : RuneProvider.values())
		{
			PROVIDER_TO_PROVIDED.put(runeProvider.getId(), runeProvider.getProvides());
			if (runeProvider.isRequiresEquipped())
			{
				EQUIPPED_PROVIDERS.add(runeProvider.getId());
			} else {
				INV_PROVIDERS.add(runeProvider.getId());
			}
		}
	}

	public static boolean isEquppedProvider(int id) { return EQUIPPED_PROVIDERS.contains(id); }
	public static boolean isInvProvider(int id) { return INV_PROVIDERS.contains(id); }
	public static HashSet<Integer> getProvidedRunes(int id) { return PROVIDER_TO_PROVIDED.get(id); }
}

package com.chanceman.menus;

import com.chanceman.ChanceManPlugin;
import com.chanceman.UnlockedItemsManager;
import net.runelite.api.Client;
import net.runelite.api.gameval.InventoryID;
import net.runelite.api.ItemContainer;
import net.runelite.api.events.GameTick;
import net.runelite.api.widgets.Widget;
import net.runelite.client.eventbus.Subscribe;

import javax.inject.Inject;
import javax.inject.Singleton;
import java.util.*;

@Singleton
public class Restrictions
{

	public static final int SPELL_REQUIREMENT_OVERLAY_NORMAL = 14287050;
	public static final int AUTOCAST_REQUIREMENT_OVERLAY_NORMAL = 13172738;

	private static final HashMap<Integer, SkillOp> ITEM_TO_OP = new HashMap<>();
	static
	{
		for (SkillItem skillItem : SkillItem.values())
		{
			ITEM_TO_OP.put(skillItem.getId(), skillItem.getSkillOp());
		}
	}

	@Inject private ChanceManPlugin plugin;
	@Inject private Client client;
	@Inject private UnlockedItemsManager unlockedItemsManager;
	private final HashSet<SkillOp> enabledSkillOps = new HashSet<>();
	private final HashSet<Integer> availableRunes = new HashSet<>();

	@Subscribe
	public void onGameTick(GameTick event)
	{
		if (!unlockedItemsManager.ready()) return;
		enabledSkillOps.clear();
		availableRunes.clear();

		ItemContainer equippedItems = client.getItemContainer(InventoryID.WORN);
		ItemContainer inventoryItems = client.getItemContainer(InventoryID.INV);

		if (equippedItems != null)
		{
			Arrays.stream(equippedItems.getItems()).forEach(item -> {
				int id = item.getId();
				if (!plugin.isInPlay(id) || !unlockedItemsManager.isUnlocked(id)) return;
				if (RuneProvider.isEquppedProvider(id)) availableRunes.addAll(RuneProvider.getProvidedRunes(id));
				if (SkillItem.isSkillItem(id)) enabledSkillOps.add(ITEM_TO_OP.get(id));
			});
		}

		if (inventoryItems != null)
		{
			Arrays.stream(inventoryItems.getItems()).forEach(item -> {
				int id = item.getId();
				if (!plugin.isInPlay(id) || !unlockedItemsManager.isUnlocked(id)) return;
				if (RuneProvider.isInvProvider(id)) availableRunes.addAll(RuneProvider.getProvidedRunes(id));
				if (SkillItem.isSkillItem(id)) enabledSkillOps.add(ITEM_TO_OP.get(id));
			});
		}
	}

	public boolean isSkillOpEnabled(String option)
	{
		SkillOp op = SkillOp.fromString(option);
		return enabledSkillOps.contains(op);
	}

	public boolean isSpellOpEnabled()
	{
		Widget spellOverlay = client.getWidget(SPELL_REQUIREMENT_OVERLAY_NORMAL);
		if (spellOverlay != null) return processChildren(spellOverlay);

		Widget autocastOverlay = client.getWidget(AUTOCAST_REQUIREMENT_OVERLAY_NORMAL);
		if (autocastOverlay != null) return processChildren(autocastOverlay);
		return false;
	}

	public boolean processChildren(Widget widget)
	{
		Widget[] children = widget.getDynamicChildren();
		if (children == null) return true;

		for (Widget child : children)
		{
			int id = child.getItemId();
			if (id == -1) continue;

			if (plugin.isInPlay(id) && !availableRunes.contains(id))
				return false;
		}
		return true;
	}
}

package com.chanceman.menus;

import lombok.Getter;

public enum EnabledUI
{
	BANK(12),
	DEPOSIT_BOX(192);

	@Getter private final int id;

	EnabledUI(int id) {
		this.id = id;
	}
}

package com.chanceman;

import net.runelite.client.RuneLite;
import net.runelite.client.externalplugins.ExternalPluginManager;

public class ExamplePluginTest
{
	public static void main(String[] args) throws Exception
	{
		ExternalPluginManager.loadBuiltin(ChanceManPlugin.class);
		RuneLite.main(args);
	}
}
