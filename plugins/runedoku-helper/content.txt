/*
 * Copyright (c) 2021, Iris Ward <aditu.venyhandottir@gmail.com>
 *
 * This file is a modified version of net.runelite.client.ui.overlay.components.TextComponent
 * originally by Tomas Slusny.  The copyright notice for the original file is given below.
 */

/*
 * Copyright (c) 2017, Tomas Slusny <slusnucky@gmail.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

package com.github.adituv.runedokuplugin;

import lombok.Setter;
import net.runelite.client.ui.overlay.RenderableEntity;
import net.runelite.client.util.ColorUtil;
import net.runelite.client.util.Text;

import javax.annotation.Nullable;
import java.awt.*;
import java.util.regex.Pattern;

@Setter
public class OutlineTextComponent implements RenderableEntity {
    private static final String COL_TAG_REGEX = "(<col=([0-9a-fA-F]){2,6}>)";
    private static final Pattern COL_TAG_PATTERN_W_LOOKAHEAD = Pattern.compile("(?=" + COL_TAG_REGEX + ")");

    private String text;
    private Point position = new Point();
    private Color color = Color.WHITE;

    // If there is no outline, draw a black drop-shadow if this is true, or draw nothing extra otherwise
    private boolean shadow = true;

    @Nullable
    private Font font;

    private int outlineWidth = 1;
    private Color outlineColor = Color.BLACK;

    @Override
    public Dimension render(Graphics2D graphics) {
        Font originalFont = graphics.getFont();

        if (font != null) {
            graphics.setFont(font);
        }

        final FontMetrics fontMetrics = graphics.getFontMetrics();

        if (COL_TAG_PATTERN_W_LOOKAHEAD.matcher(text).find())
        {
            final String[] parts = COL_TAG_PATTERN_W_LOOKAHEAD.split(text);
            int x = position.x;

            for (String textSplitOnCol : parts)
            {
                final String textWithoutCol = Text.removeTags(textSplitOnCol);
                final String colColor = textSplitOnCol.substring(textSplitOnCol.indexOf("=") + 1, textSplitOnCol.indexOf(">"));

                if (outlineWidth > 0)
                {
                    graphics.setColor(ColorUtil.colorWithAlpha(outlineColor, 0xFF));

                    graphics.drawString(textWithoutCol, x + outlineWidth, position.y + outlineWidth);
                    graphics.drawString(textWithoutCol, x, position.y + outlineWidth);
                    graphics.drawString(textWithoutCol, x - outlineWidth, position.y + outlineWidth);

                    graphics.drawString(textWithoutCol, x + outlineWidth, position.y);
                    graphics.drawString(textWithoutCol, x - outlineWidth, position.y);

                    graphics.drawString(textWithoutCol, x + outlineWidth, position.y - outlineWidth);
                    graphics.drawString(textWithoutCol, x, position.y - outlineWidth);
                    graphics.drawString(textWithoutCol, x - outlineWidth, position.y - outlineWidth);
                }
                else if(shadow)
                {
                    graphics.setColor(Color.BLACK);

                    graphics.drawString(textWithoutCol, x + 1, position.y + 1);
                }

                // actual text
                graphics.setColor(Color.decode("#" + colColor));
                graphics.drawString(textWithoutCol, x, position.y);

                x += fontMetrics.stringWidth(textWithoutCol);
            }
        }
        else
        {
            graphics.setColor(Color.BLACK);

            if (outlineWidth > 0)
            {
                graphics.setColor(ColorUtil.colorWithAlpha(outlineColor, 0xFF));

                graphics.drawString(text, position.x + outlineWidth, position.y + outlineWidth);
                graphics.drawString(text, position.x,position.y + outlineWidth);
                graphics.drawString(text, position.x - outlineWidth, position.y + outlineWidth);

                graphics.drawString(text, position.x + outlineWidth, position.y);
                graphics.drawString(text, position.x - outlineWidth, position.y);

                graphics.drawString(text, position.x + outlineWidth, position.y - outlineWidth);
                graphics.drawString(text, position.x, position.y - outlineWidth);
                graphics.drawString(text, position.x - outlineWidth, position.y - outlineWidth);
            }
            else if(shadow)
            {
                graphics.setColor(Color.BLACK);

                graphics.drawString(text, position.x + 1, position.y + 1);
            }

            // actual text
            graphics.setColor(ColorUtil.colorWithAlpha(color, 0xFF));
            graphics.drawString(text, position.x, position.y);
        }

        int width = fontMetrics.stringWidth(text);
        int height = fontMetrics.getHeight();

        if (originalFont != null)
        {
            graphics.setFont(originalFont);
        }

        return new Dimension(width, height);
    }

    // Convenience setter for all outline properties
    public void setOutline(int width, Color color) {
        this.setOutlineWidth(width);
        this.setOutlineColor(color);
    }
}

package com.github.adituv.runedokuplugin;

import lombok.Getter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.widgets.Widget;

/**
 * A data structure to store the current state of the board
 */
@Getter
@Slf4j
public class RunedokuBoard {
    private final Widget containerWidget;
    private final RunedokuCell[] cells;

    private final int width;

    private final int[][] rowNumbers;
    private final int[][] colNumbers;
    private final int[][] boxNumbers;
    private SudokuSolver solver;

    /**
     Check cell to verify it does not exist in an invalid location
     @param cell Runedoku cell to check
     */
    public boolean cellHasClash(RunedokuCell cell) {
        int sudokuIndex = cell.getSudokuNumber() - 1;
        return ( rowNumbers[cell.getRowNumber()][sudokuIndex] > 1
                || colNumbers[cell.getColumnNumber()][sudokuIndex] > 1
                || boxNumbers[cell.getBoxNumber()][sudokuIndex] > 1);
    }

    /**
     Check that cell has a solution. If showSolution is off, this will always return false
     @param cell Runedoku cell to check
     */
    public boolean cellHasSolution(RunedokuCell cell) {
        return cell.getSolutionNumber() != 0;
    }

    /**
     * Grab widget and update each RunedokuCell within the board with new values
     */
    public void updateCells() {
        Widget[] children = containerWidget.getChildren();
        if (children == null) {
            log.error("error: children null");
            return;
        }

        for(int i = 0; i < width; i++) {
            for(int j = 0; j < width; j++) {
                rowNumbers[i][j] = 0;
                colNumbers[i][j] = 0;
                boxNumbers[i][j] = 0;
            }
        }

        for(int i = 0; i < children.length; i++) {
            cells[i].updateFromWidget(children[i]);
            int sudokuIndex = cells[i].getSudokuNumber() - 1;

            if(sudokuIndex >= 0) {
                this.rowNumbers[cells[i].getRowNumber()][sudokuIndex]++;
                this.colNumbers[cells[i].getColumnNumber()][sudokuIndex]++;
                this.boxNumbers[cells[i].getBoxNumber()][sudokuIndex]++;
            }
        }
    }

    /**
     * Generate solution to current board state, if possible
     * Updates each cell to contain its the solution value
     * Accessible at cell.solutionNumber
     *
     * This function only runs once at the creation of the board, as the solution algorithm is computationally expensive
     * especially if someone creates an unsolvable board
     */
    public void solveBoard() {
        // try to solve the board
        if (solver.solve()) {

            // grab the solved board state
            int[][] solutionGrid = solver.getSolution();

            for(int i = 0; i < width; i++) {
                for (int j = 0; j < width; j++) {
                    // Update each cell with its solution value
                    cells[(i * width) + j].updateSolution(solutionGrid[i][j]);
                }
            }
        } else {
            // Hopefully we never get here, as runescape should always generate a solvable board.
            log.error("Unsolvable board state");
        }
    }

    /**
     * Get cell at a specific offset
     * @param   index   offset
     * @return  RunedokuCell at offset
     */
    public RunedokuCell getCell(int index) {
        if(index >= 0 && index < cells.length) {
            return cells[index];
        } else {
            return null;
        }
    }

    /**
     * Create a new Runedoku board based on the given widget
     * @param containerWidget A runedoku UI widget
     */
    public RunedokuBoard(Widget containerWidget, boolean solve) {
        this.containerWidget = containerWidget;

        Widget[] children = containerWidget.getChildren();

        if(children != null) {
            if(children.length == 81) {
                width = 9;
                cells = new RunedokuCell[81];

                for(int i = 0; i < children.length; i++) {
                    cells[i] = new RunedokuCell(width, i);
                }

                rowNumbers = new int[9][9];

                colNumbers = new int[9][9];
                boxNumbers = new int[9][9];
            } else if(children.length == 16) {
                width = 4;
                cells = new RunedokuCell[16];

                for(int i = 0; i < children.length; i++) {
                    cells[i] = new RunedokuCell(width,i);
                }

                rowNumbers = new int[4][4];
                colNumbers = new int[4][4];
                boxNumbers = new int[4][4];
            } else {
                log.error(String.format("constructor: invalid board size %d", children.length));
                width = 0;
                cells = null;
                rowNumbers = null;
                colNumbers = null;
                boxNumbers = null;
            }
            if (solve) {
                if (cells != null) {
                    int[][] solutionBuilder = new int[9][9];

                    for(int i = 0; i < children.length; i++) {
                        cells[i].updateFromWidget(children[i]);
                        int sudokuIndex = cells[i].getSudokuNumber() - 1;

                        solutionBuilder[cells[i].getRowNumber()][cells[i].getColumnNumber()] = sudokuIndex + 1;
                    }
                    solver = new SudokuSolver(solutionBuilder);

                    // this should never error because runescape should always generate a solvable board
                    solveBoard();
                }
            }
        } else {
            log.error("render: containerWidget children array is null");
            width = 0;
            cells = null;
            rowNumbers = null;
            colNumbers = null;
            boxNumbers = null;
        }
    }
}

package com.github.adituv.runedokuplugin;

import lombok.Getter;
import lombok.Setter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.widgets.Widget;

@Getter
@Slf4j
public class RunedokuCell {
    private RunedokuRune rune;
    private int sudokuNumber;
    private int solutionNumber;
    private Widget widget;

    private final int columnNumber;
    private final int rowNumber;
    private final int boxNumber;

    @Setter
    private boolean[] marks = new boolean[9];

    /**
     * Data structure containing a rune, mark, or solution at a position
     * @param boardWidth size of the board 9 or 4
     * @param cellId index of cell, translates to row and column
     */
    public RunedokuCell(int boardWidth, int cellId) {
        this.columnNumber = cellId % boardWidth;
        this.rowNumber = cellId / boardWidth;

        if (boardWidth == 9) {
            this.boxNumber = 3*(rowNumber/3) + (columnNumber/3);
        } else if(boardWidth == 4) {
            this.boxNumber = 2*(rowNumber/2) + (columnNumber/2);
        } else {
            log.error(String.format("constructor: invalid boardWidth %d", boardWidth));
            this.boxNumber = 0;
        }
    }

    /**
     * Update cell from UI widget
     * @param w Widget of a specific cell in the board
     */
    public void updateFromWidget(Widget w) {
        this.widget = w;
        this.rune = RunedokuRune.getByItemId(w.getItemId());
        this.sudokuNumber = this.rune != null ? rune.getSudokuNumber() : 0;
    }

    /**
     * Literally a setter
     * Set the value of this cell that would lead to a solved board state
     * @param solution integer value of solution to cell
     */
    public void updateSolution(int solution) {
        solutionNumber = solution;
    }
}

package com.github.adituv.runedokuplugin;

import net.runelite.client.config.Config;
import net.runelite.client.config.ConfigGroup;
import net.runelite.client.config.ConfigItem;

import java.awt.*;

import static com.github.adituv.runedokuplugin.RunedokuConstants.RUNEDOKU_CONFIG_GROUP;

@ConfigGroup(RUNEDOKU_CONFIG_GROUP)
public interface RunedokuConfig extends Config
{
	@ConfigItem(
			keyName = "showSolution",
			name = "Show solution",
			description = "Lazy"
	)
	default boolean showSolution() { return true; }
	@ConfigItem(
		keyName = "useNumbers",
		name = "Show numbers over runes",
		description = "Whether to overlay a number over each rune to help input into a sudoku solver"
	)
	default boolean useNumbers() { return false; }

	@ConfigItem(
		keyName = "markOnShift",
		name = "Shift-Mark",
		description = "Hold shift to make mark the left click menu option"
	)
	default boolean markOnShift() { return true;}

	@ConfigItem(
		keyName = "foregroundColor",
		name = "Foreground color",
		description = "The default foreground color for the overlay"
	)
	default Color foregroundColor() { return Color.YELLOW; }

	@ConfigItem(
		keyName = "errorColor",
		name = "Error color",
		description = "The color used to highlight errors in the overlay"
	)
	default Color errorColor() { return Color.RED; }

	@ConfigItem(
			keyName = "solutionColor",
			name = "Solution color",
			description = "The color used to highlight correct solution in the overlay"
	)
	default Color solutionColor() { return Color.GREEN; }

	@ConfigItem(
		keyName = "outlineColor",
		name = "Outline color",
		description = "The outline color for text in the overlay"
	)
	default Color outlineColor() { return Color.BLACK; }
}

package com.github.adituv.runedokuplugin;

import net.runelite.api.widgets.WidgetInfo;

public final class RunedokuConstants {
    public static final String RUNEDOKU_CONFIG_GROUP = "runedoku";

    public static final int RUNEDOKU_WIDGET_GROUP_ID = 292;
    public static final int RUNEDOKU_CONTAINER_WIDGET_ID = WidgetInfo.PACK(RUNEDOKU_WIDGET_GROUP_ID, 0);
    public static final int RUNEDOKU_BOARD_WIDGET_ID = WidgetInfo.PACK(RUNEDOKU_WIDGET_GROUP_ID,13);
    public static final int RUNEDOKU_RUNE_WIDGET_ID = WidgetInfo.PACK(RUNEDOKU_WIDGET_GROUP_ID,9);
    public static final int RUNEDOKU_BUTTON_WIDGET_ID = WidgetInfo.PACK(RUNEDOKU_WIDGET_GROUP_ID,10);
    public static final int RUNEDOKU_EXIT_WIDGET_ID = WidgetInfo.PACK(RUNEDOKU_WIDGET_GROUP_ID, 15);
    public static final int RUNEDOKU_BOARD_CLICK_WIDGET_ID = WidgetInfo.PACK(RUNEDOKU_WIDGET_GROUP_ID, 14);
}

package com.github.adituv.runedokuplugin;

import com.google.inject.Inject;
import lombok.AccessLevel;
import lombok.Setter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.widgets.Widget;
import net.runelite.client.game.ItemManager;
import net.runelite.client.ui.FontManager;
import net.runelite.client.ui.overlay.*;
import net.runelite.client.util.AsyncBufferedImage;
import net.runelite.client.util.ColorUtil;

import java.awt.*;
import java.awt.geom.Rectangle2D;
import java.awt.image.RescaleOp;

import static com.github.adituv.runedokuplugin.RunedokuConstants.*;

@Setter
@Slf4j
public class RunedokuOverlay extends Overlay {
    private final Client client;

    @Setter(AccessLevel.NONE)
    private boolean isActive;

    @Setter(AccessLevel.NONE)
    private RunedokuBoard board;

    @Setter(AccessLevel.NONE)
    private RunedokuRune selectedRune;

    private boolean shouldDrawNumbers;
    private boolean shouldShowSolution;
    private Color foregroundColor;
    private Color outlineColor;
    private Color errorColor;
    private Color solutionColor;
    private final AsyncBufferedImage[] runeImages;

    private final Font bigFont;
    private final Font markFont;

    private final int BOX_X_OFFSET = -2;
    private final int BOX_Y_OFFSET = 0;
    private final int BOX_WIDTH_OFFSET = -1;
    private final int BOX_HEIGHT_OFFSET = -1;

    private final float BIG_FONT_SIZE = 24.0f;
    private final float BIG_FONT_X_OFFSET = -2.5f;

    /**
     * 'main' class to determine what to draw on screen for Runedoku.
     * @param graphics 2D graphics object handler for runelite
     * @return a Dimension. I think this is like a layer, but I am not sure
     */
    @Override
    public Dimension render(Graphics2D graphics) {
        if(this.isActive) {
            final Widget containerWidget = client.getWidget(RUNEDOKU_CONTAINER_WIDGET_ID);
            if(containerWidget == null || containerWidget.isHidden()) {
                return null;
            }

            final int boardWidth = this.board.getWidth();

            if(!(boardWidth == 4 || boardWidth == 9)) {
                log.error(String.format("render: Invalid board width %d", boardWidth));
            }

            final Widget boardWidget = client.getWidget(RUNEDOKU_BOARD_WIDGET_ID);
            final Widget runeWidget = client.getWidget(RUNEDOKU_RUNE_WIDGET_ID);

            final FontMetrics bigFontMetrics = graphics.getFontMetrics(bigFont);
            final FontMetrics markFontMetrics = graphics.getFontMetrics(markFont);

            if(boardWidget == null) {
                log.error("render: boardWidget is null");
                return null;
            }
            if(runeWidget == null) {
                log.error("render: runeWidget is null");
                return null;
            }

            final OutlineTextComponent bigNumberText = new OutlineTextComponent();
            bigNumberText.setOutline(2,outlineColor);
            bigNumberText.setColor(foregroundColor);
            bigNumberText.setFont(bigFont);

            final OutlineTextComponent markNumberText = new OutlineTextComponent();
            markNumberText.setOutline(1,outlineColor);
            markNumberText.setColor(foregroundColor);
            markNumberText.setFont(markFont);

            // innocent until proven guilty
            boolean solved = true;
            for(RunedokuCell c : board.getCells()) {
                if(c.getSudokuNumber() > 0) {
                    // Show errors in sudoku gameplay
                    if(board.cellHasClash(c)) {
                        // This rune clashes with another rune.  Highlight it with an error box
                        drawErrorBox(graphics, c.getWidget());
                    }
                    // Show numbers over runes for clarity
                    if(shouldDrawNumbers) {
                        final Widget w = c.getWidget();
                        final String numberAsText = String.format("%d", c.getSudokuNumber());

                        Rectangle2D stringBounds = bigFontMetrics.getStringBounds(numberAsText,graphics);
                        double x = w.getBounds().getCenterX() - stringBounds.getCenterX() + BIG_FONT_X_OFFSET;
                        double y = w.getBounds().getCenterY() - stringBounds.getCenterY();
                        Point location = new Point((int)x,(int)y);

                        bigNumberText.setText(numberAsText);
                        bigNumberText.setPosition(location);
                        bigNumberText.render(graphics);
                    }
                } else {

                    // If there isn't a number in the cell, draw pencil marks
                    Rectangle cellBounds = c.getWidget().getBounds();
                    int xPos = cellBounds.x + BOX_X_OFFSET;
                    int yPos = cellBounds.y + BOX_Y_OFFSET + markFontMetrics.getHeight();
                    cellBounds.x += BOX_X_OFFSET + 1;
                    cellBounds.y += BOX_Y_OFFSET + 1;
                    cellBounds.width += BOX_WIDTH_OFFSET - 1;
                    cellBounds.height += BOX_HEIGHT_OFFSET - 1;

                    StringBuilder marks = new StringBuilder("");

                    for(int i = 0; i < 9; i++) {
                        if(c.getMarks()[i]) {
                            marks.append(i+1);
                            if(marks.length() == 5) {
                                // Render first line and start again
                                markNumberText.setText(marks.toString());
                                markNumberText.setPosition(new Point(xPos, yPos));
                                Dimension textBounds = markNumberText.render(graphics);

                                yPos += textBounds.height;

                                marks = new StringBuilder("");
                            }

                            markNumberText.setText(marks.toString());
                            markNumberText.setPosition(new Point(xPos, yPos));
                            markNumberText.render(graphics);
                        }
                    }

                    // Show the solution values and highlight current rune solutions
                    if (shouldShowSolution) {
                        if (c.getRune() != null) {
                            if (c.getRune().getSudokuNumber() != c.getSolutionNumber()) {
                                solved = false;
                            }
                        } else {
                            solved = false;
                        }
                        final Color tintColor = new Color(128,128,153,255);
                        final float[] tintChannels = new float[]
                                { tintColor.getRed()/255f, tintColor.getGreen()/255f,
                                        tintColor.getBlue()/255f, tintColor.getAlpha()/255f
                                };
                        final RescaleOp darkenImageOp = new RescaleOp(tintChannels, new float[]{0f,0f,0f,0f}, null);
                        Rectangle bounds = c.getWidget().getBounds();
                        graphics.drawImage(runeImages[c.getSolutionNumber()], darkenImageOp, bounds.x, bounds.y);

                        if (this.selectedRune != null) {
                            if (board.cellHasSolution(c) && c.getSolutionNumber() == this.selectedRune.getSudokuNumber()) {
                                drawSolutionBox(graphics, c.getWidget());
                            }
                        }

                        if(shouldDrawNumbers) {
                            final Widget w = c.getWidget();
                            final String numberAsText = String.format("%d", c.getSolutionNumber());

                            Rectangle2D stringBounds = bigFontMetrics.getStringBounds(numberAsText, graphics);
                            double x = w.getBounds().getCenterX() - stringBounds.getCenterX() + BIG_FONT_X_OFFSET;
                            double y = w.getBounds().getCenterY() - stringBounds.getCenterY();
                            Point location = new Point((int) x, (int) y);

                            bigNumberText.setText(numberAsText);
                            bigNumberText.setPosition(location);
                            bigNumberText.render(graphics);
                        }
                    } else {
                        solved = false;
                    }
                }
            }

            if (solved) {
                drawComplete(graphics, client.getWidget(RUNEDOKU_BUTTON_WIDGET_ID));
            }

            Widget[] children = runeWidget.getChildren();

            if(children == null) {
                log.error("render: runeWidget children array is null");
                return null;
            }

            for (Widget w : children) {
                if(shouldDrawNumbers) {
                    RunedokuRune rune = RunedokuRune.getByItemId(w.getItemId());

                    if(rune != null) {
                        String numberAsText = String.format("%d",rune.getSudokuNumber());

                        Rectangle2D stringBounds = bigFontMetrics.getStringBounds(numberAsText,graphics);
                        double x = w.getBounds().getCenterX() - stringBounds.getCenterX() + BIG_FONT_X_OFFSET;
                        double y = w.getBounds().getCenterY() - stringBounds.getCenterY();
                        Point location = new Point((int)x,(int)y);

                        bigNumberText.setText(numberAsText);
                        bigNumberText.setPosition(location);
                        bigNumberText.render(graphics);
                    }
                }
            }
        }
        return null;
    }

    private Point getMarkLocation(int i, Graphics2D graphics, Rectangle cellBounds) {
        final FontMetrics fontMetrics = graphics.getFontMetrics(markFont);
        double x = -1.0;
        double y = -1.0;
        int boardWidth = board.getWidth();
        Rectangle2D stringBounds = fontMetrics.getStringBounds(String.format("%d", i+1), graphics);

        if(boardWidth == 4) {
            if(i % 2 == 0) {
                x = cellBounds.x;
            } else {
                x = cellBounds.getMaxX() - stringBounds.getMaxX();
            }

            if(i / 2 == 0) {
                y = cellBounds.y + stringBounds.getHeight();
            } else {
                y = cellBounds.getMaxY() + fontMetrics.getDescent();
            }
        } else if(boardWidth == 9) {
            if(i % 3 == 0) {
                x = cellBounds.x;
            } else if(i % 3 == 1) {
                x = cellBounds.getCenterX() - stringBounds.getCenterX();
            } else {
                x = cellBounds.getMaxX() - stringBounds.getMaxX();
            }

            if(i / 3 == 0) {
                y = cellBounds.y + stringBounds.getHeight();
            } else if(i / 3 == 1) {
                y = cellBounds.getCenterY() - stringBounds.getCenterY() + fontMetrics.getDescent()/2.0;
            } else {
                y = cellBounds.getMaxY() + fontMetrics.getDescent();
            }
        }

        return new Point((int)x,(int)y);
    }

    public void activate(RunedokuBoard board) {
        this.board = board;
        this.isActive = true;
    }

    public void deactivate() {
        this.board = null;
        this.isActive = false;
    }

    private void drawErrorBox(Graphics2D graphics, Widget w) {

        graphics.setColor(ColorUtil.colorWithAlpha(errorColor, 0xFF));
        graphics.setStroke(new BasicStroke(2.0f));

        Rectangle bounds = w.getBounds();
        graphics.drawRect(bounds.x + BOX_X_OFFSET,
                bounds.y + BOX_Y_OFFSET,
                bounds.width + BOX_WIDTH_OFFSET,
                bounds.height + BOX_HEIGHT_OFFSET
        );
    }

    private void drawSolutionBox(Graphics2D graphics, Widget w) {
        graphics.setColor(ColorUtil.colorWithAlpha(solutionColor, 0xFF));
        graphics.setStroke(new BasicStroke(2.0f));

        Rectangle bounds = w.getBounds();
        graphics.drawRect(bounds.x + BOX_X_OFFSET,
                bounds.y + BOX_Y_OFFSET,
                bounds.width + BOX_WIDTH_OFFSET,
                bounds.height + BOX_HEIGHT_OFFSET
        );
    }

    private void drawComplete(Graphics2D graphics, Widget w) {
        graphics.setColor(ColorUtil.colorWithAlpha(solutionColor, 0xFF));
        graphics.setStroke(new BasicStroke(2.0f));

        Rectangle bounds = w.getBounds();
        graphics.drawRect(bounds.x + BOX_X_OFFSET,
                bounds.y + BOX_Y_OFFSET,
                bounds.width + BOX_WIDTH_OFFSET,
                bounds.height + BOX_HEIGHT_OFFSET
        );
    }

    @Inject
    public RunedokuOverlay(final RunedokuPlugin plugin, Client client, final ItemManager itemManager) {
        super(plugin);
        this.client = client;
        this.bigFont = FontManager.getDefaultBoldFont().deriveFont(BIG_FONT_SIZE);
        this.markFont = FontManager.getRunescapeSmallFont();

        setPosition(OverlayPosition.DETACHED);
        setLayer(OverlayLayer.ABOVE_WIDGETS);
        setPriority(OverlayPriority.MED);

        // Preload images for runes
        this.runeImages = new AsyncBufferedImage[10];
        for(int i = 1; i < 10; i++) {
            this.runeImages[i] = itemManager.getImage(RunedokuRune.getBySudokuNumber(i).getItemId());
        }
    }

    /**
     * Setter for the currently selected rune
     * @param rune RunedokuRune
     */
    public void updateSelectedRune(RunedokuRune rune) {
        this.selectedRune = rune;
    }
}

package com.github.adituv.runedokuplugin;

import com.google.inject.Provides;
import javax.inject.Inject;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.*;
import net.runelite.api.events.*;
import net.runelite.api.widgets.Widget;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.events.ConfigChanged;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.plugins.PluginDescriptor;
import net.runelite.client.ui.overlay.OverlayManager;
import net.runelite.api.MenuEntry;

import static com.github.adituv.runedokuplugin.RunedokuConstants.*;

@Slf4j
@PluginDescriptor(
	name = "Runedoku Helper"
)
public class RunedokuPlugin extends Plugin
{
	@Inject
	private Client client;

	@Inject
	private ClientThread clientThread;

	@Inject
	private RunedokuConfig config;

	@Inject
	private OverlayManager overlayManager;

	@Inject
	private RunedokuOverlay overlay;

	private RunedokuRune selectedRune = RunedokuRune.WATER_RUNE;
	private String selectedRuneText = "<col=ff9040>Water rune</col>";
	private RunedokuBoard board = null;

	private boolean markOnShift;

	@Subscribe
	public void onConfigChanged(ConfigChanged configChanged) {
		if(configChanged.getGroup().equals(RUNEDOKU_CONFIG_GROUP)) {
			switch (configChanged.getKey()) {
				case "useNumbers":
					overlay.setShouldDrawNumbers(config.useNumbers());
					break;
				case "showSolution":
					overlay.setShouldShowSolution(config.showSolution());
					break;
				case "solutionColor":
					overlay.setSolutionColor(config.solutionColor());
					break;
				case "foregroundColor":
					overlay.setForegroundColor(config.foregroundColor());
					break;
				case "outlineColor":
					overlay.setOutlineColor(config.outlineColor());
					break;
				case "errorColor":
					overlay.setErrorColor(config.errorColor());
					break;
				case "markOnShift":
					this.markOnShift = config.markOnShift();
					break;
			}
		}
	}

	@Subscribe
	public void onWidgetLoaded(WidgetLoaded widgetLoaded) {
		if(widgetLoaded.getGroupId() == RUNEDOKU_WIDGET_GROUP_ID) {
			log.debug("Runedoku widget loaded");
			this.selectedRune = RunedokuRune.WATER_RUNE;

			clientThread.invokeLater(() -> {
				Widget boardWidget = client.getWidget(RUNEDOKU_BOARD_WIDGET_ID);
				if (boardWidget != null) {
					this.board = new RunedokuBoard(boardWidget, config.showSolution());
					this.board.updateCells();
					this.overlay.activate(board);
					this.overlay.updateSelectedRune(this.selectedRune);
				}
			});
		}
	}

	@Subscribe
	public void onWidgetClosed(WidgetClosed widgetClosed) {
		if(widgetClosed.getGroupId() == RUNEDOKU_WIDGET_GROUP_ID) {
			board = null;
			overlay.deactivate();
		}
	}

	@Subscribe
	public void onCanvasSizeChanged(CanvasSizeChanged canvasSizeChanged) {
	    if (board != null) {
			board.updateCells();
			if (config.showSolution()) {
				this.board.solveBoard();
			}
		}
	}

	// Must run before Inventory Tags
	@Subscribe(priority = -1.0f)
	public void onMenuOptionClicked(MenuOptionClicked menuOptionClicked) {
		if(menuOptionClicked.getWidgetId() == RUNEDOKU_RUNE_WIDGET_ID) {
			clientThread.invokeLater(() -> {
				// Update the currently selected rune
				Widget w = client.getWidget(menuOptionClicked.getWidgetId());

				for(Widget cw : w.getChildren()) {
					if(cw.getBorderType() == 2) {
						this.selectedRune = RunedokuRune.getByItemId(cw.getItemId());
						this.overlay.updateSelectedRune(this.selectedRune);
						String name = cw.getName();
						if(name.isEmpty()) {
							name="<col=ff9040>None</col>";
						}
						this.selectedRuneText = name;
						break;
					}
				}
			});
		} else if(menuOptionClicked.getWidgetId() == RUNEDOKU_BOARD_CLICK_WIDGET_ID) {
			if(menuOptionClicked.getMenuOption().equals("Mark")) {
				menuOptionClicked.consume();

				int cellId = menuOptionClicked.getActionParam();
				int sudokuIndex = this.selectedRune.getSudokuNumber()-1;

				log.debug(String.format("Marking cell=%d num=%d", cellId, sudokuIndex+1));

				if(sudokuIndex >= 0) {
					RunedokuCell c = board.getCell(cellId);
					boolean[] marks = c.getMarks();
					marks[sudokuIndex] = !marks[sudokuIndex];
					c.setMarks(marks);
				}
			} else {
				clientThread.invokeLater(() -> board.updateCells());
			}
		}
	}

	// Manually create an extra menu entry for pencil marks when the right-click menu is opened
	@Subscribe
	public void onMenuOpened(MenuOpened menuOpened) {
		int widgetId = menuOpened.getFirstEntry().getParam1();
		int widgetIndex = menuOpened.getFirstEntry().getParam0();

		if(widgetId == RUNEDOKU_BOARD_CLICK_WIDGET_ID && selectedRune != null) {
			Widget cell = client.getWidget(RUNEDOKU_BOARD_WIDGET_ID).getChild(widgetIndex);
			if(cell.getBorderType() == 2) {
				// If it's a fixed rune, don't show the mark option
				return;
			}

			MenuEntry markEntry = makeMarkMenuEntry(widgetId, widgetIndex);

			MenuEntry[] newEntries = insertMarkMenuEntry(markEntry);

			client.setMenuEntries(newEntries);
		}
	}

	@Subscribe
	public void onMenuEntryAdded(MenuEntryAdded menuEntryAdded) {
		if(menuEntryAdded.getActionParam1() != RUNEDOKU_BOARD_CLICK_WIDGET_ID || client.isMenuOpen()) {
			return;
		}

		if(markOnShift && client.isKeyPressed(KeyCode.KC_SHIFT)) {
			if(menuEntryAdded.getOption().startsWith("Place")) {
				MenuEntry[] menuEntries = client.getMenuEntries();

				for(MenuEntry entry : menuEntries) {
					if(entry.getOption().equals(menuEntryAdded.getOption())) {

						// Our onMenuOptionClicked code consumes the click event for the menu option "Mark"
						// so we can just change the option and target to get the desired functionality
						entry.setOption("Mark");
						entry.setTarget(this.selectedRuneText);
					}
				}

				client.setMenuEntries(menuEntries);
			}
		}
	}

	private MenuEntry makeMarkMenuEntry(int widgetId, int widgetIndex) {
		return client.createMenuEntry(MenuAction.CC_OP.getId())
			.setOption("Mark")
			.setTarget(selectedRuneText)
			.setType(MenuAction.CC_OP)
			.setParam0(widgetIndex)
			.setParam1(widgetId);
	}

	private MenuEntry[] insertMarkMenuEntry(MenuEntry markEntry) {
		MenuEntry[] oldEntries = client.getMenuEntries();
		MenuEntry[] newEntries = new MenuEntry[oldEntries.length + 1];

		System.arraycopy(oldEntries, 0, newEntries, 0, oldEntries.length);

		if(markOnShift && client.isKeyPressed(KeyCode.KC_SHIFT)) {
			newEntries[newEntries.length-1] = markEntry;
		} else {
			newEntries[newEntries.length-2] = markEntry;
			newEntries[newEntries.length-1] = oldEntries[oldEntries.length-1];
		}

		return newEntries;
	}

	protected void loadConfig() {
		overlay.setShouldDrawNumbers(config.useNumbers());
		overlay.setShouldShowSolution(config.showSolution());
		overlay.setSolutionColor(config.solutionColor());
		overlay.setForegroundColor(config.foregroundColor());
		overlay.setOutlineColor(config.outlineColor());
		overlay.setErrorColor(config.errorColor());
		this.markOnShift = config.markOnShift();
	}

	@Override
	protected void startUp() throws Exception {
		loadConfig();

		overlayManager.add(overlay);
	}

	@Override
	protected void shutDown() throws Exception {
		overlayManager.remove(overlay);
	}

	@Provides
	RunedokuConfig provideConfig(ConfigManager configManager)
	{
		return configManager.getConfig(RunedokuConfig.class);
	}
}

package com.github.adituv.runedokuplugin;

public enum RunedokuRune {
    WATER_RUNE(555,1),
    FIRE_RUNE(554,2),
    EARTH_RUNE(557,3),
    AIR_RUNE(556,4),
    MIND_RUNE(558,5),
    BODY_RUNE(559,6),
    LAW_RUNE(563,7),
    CHAOS_RUNE(562,8),
    DEATH_RUNE(560,9);

    private final int itemId;
    private final int sudokuNumber;

    RunedokuRune(int itemID, int sudokuNumber) {
        this.itemId = itemID;
        this.sudokuNumber = sudokuNumber;
    }

    int getItemId() {
        return this.itemId;
    }

    int getSudokuNumber() {
        return this.sudokuNumber;
    }

    public static RunedokuRune getBySudokuNumber(int sudokuNumber) {
        for(RunedokuRune rune : RunedokuRune.values()) {
            if(rune.sudokuNumber == sudokuNumber) {
                return rune;
            }
        }
        return null;
    }

    public static RunedokuRune getByItemId(int itemId) {
        for(RunedokuRune rune : RunedokuRune.values()) {
            if(rune.getItemId() == itemId) {
                return rune;
            }
        }
        return null;
    }


}

package com.github.adituv.runedokuplugin;

// Naive backtracking sudoku solver
public class SudokuSolver {
	private final int size;

	// The initial puzzle grid
	private final int[][] puzzle;

	// The working copy of the puzzle
	private final int[][] board;

	private boolean additionIsValid(int x, int y, int n) {
		for(int i = 0; i < size; i++) {
			if(board[y][i] == n) {
				// Number already present in row
				return false;
			}
		}

		for(int j = 0; j < size; j++) {
			if(board[j][x] == n) {
				// Number already present in column
				return false;
			}
		}

		for(int k = 0; k < size; k++) {
			int i,j;

			if(size == 4) {
				i = (x/2)*2 + k%2;
				j = (y/2)*2 + k/2;
			}
			else {
				i = (x/3)*3 + k%3;
				j = (y/3)*3 + k/3;
			}

			if(board[j][i] == n) {
				// Number already present in box
				return false;
			}
		}

		return true;
	}

	public int[][] getSolution() {
		return board;
	}

	public boolean solve() {
		for(int j = 0; j < size; j++) {
			for(int i = 0; i < size; i++) {
				if(board[j][i] == 0) {
					for(int n = 1; n <= size; n++) {
						if(additionIsValid(i,j,n)) {
							board[j][i] = n;

							if(solve()) {
								return true;
							} else {
								board[j][i] = 0;
							}
						}
					}

					// We have tried every number for this cell and none are valid
					return false;
				}
			}
		}

		return true;
	}

	public SudokuSolver(int[][] puzzle) {
		this.size = puzzle.length;
		this.puzzle = puzzle;
		this.board = new int[size][size];

		for(int j = 0; j < size; j++) {
			for(int i = 0; i < size; i++) {
				this.board[j][i] = puzzle[j][i];
			}
		}
	}
}
package com.github.adituv.runedokuplugin;

import net.runelite.client.RuneLite;
import net.runelite.client.externalplugins.ExternalPluginManager;

public class RunedokuPluginTest
{
	public static void main(String[] args) throws Exception
	{
		ExternalPluginManager.loadBuiltin(RunedokuPlugin.class);
		RuneLite.main(args);
	}
}
