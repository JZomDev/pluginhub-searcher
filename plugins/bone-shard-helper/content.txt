package com.boneshardhelper;

import java.util.Map;

public class PrayerCalculationEngine {

    public CalculationResult calculateForTarget(PrayerData prayerData) {
        if (prayerData == null) {
            throw new IllegalArgumentException("Prayer data cannot be null");
        }

        validatePrayerData(prayerData);

        int currentLevel = prayerData.getCurrentLevel();
        int targetLevel = prayerData.getTargetLevel();
        double xpPerShard = prayerData.getXPPerShard(); // Changed to double for zealot robes support

        // Calculate required XP for target (either from target level or target XP)
        int currentXP = prayerData.getCurrentXP();
        int targetXP;

        // Use target XP if set, otherwise calculate from target level
        if (prayerData.getTargetXP() > 0) {
            targetXP = prayerData.getTargetXP();
        } else {
            targetXP = PrayerConstants.getXPForLevel(targetLevel);
        }

        int requiredXP = targetXP - currentXP;

        // Check if goal is already achieved
        boolean goalAlreadyAchieved;
        if (prayerData.getTargetXP() > 0) {
            goalAlreadyAchieved = currentXP >= targetXP;
        } else {
            goalAlreadyAchieved = currentLevel >= targetLevel;
        }

        // Calculate required shards
        int requiredShards = goalAlreadyAchieved ? 0 : (int) Math.ceil((double) requiredXP / xpPerShard);

        // Get available resources
        int totalAvailableShards = prayerData.getTotalAvailableShards();

        // Create result with XP per shard tracking (convert double to int for display)
        CalculationResult result = new CalculationResult(requiredShards, currentLevel, totalAvailableShards,
                (int) Math.round(xpPerShard));
        result.setRemainingXP(goalAlreadyAchieved ? 0 : requiredXP);
        result.setTotalXPGain(goalAlreadyAchieved ? 0 : requiredXP);
        result.setBoneBreakdown(prayerData.getAvailableBones());
        result.setGoalAlreadyAchieved(goalAlreadyAchieved);

        // Calculate achievable level with available resources
        int achievableLevel = calculateAchievableLevelFromShardsWithXP(prayerData.getCurrentXP(), totalAvailableShards,
                xpPerShard);
        result.setAchievableLevel(achievableLevel);

        // Calculate wine information using the corrected 400 shards per wine formula
        int winesNeeded = calculateWinesNeeded(requiredShards);

        // Populate wine information in result
        result.setWinesNeeded(winesNeeded);

        return result;
    }

    public CalculationResult calculateFromResources(PrayerData prayerData) {
        if (prayerData == null) {
            throw new IllegalArgumentException("Prayer data cannot be null");
        }

        validatePrayerData(prayerData);

        int currentLevel = prayerData.getCurrentLevel();
        double xpPerShard = prayerData.getXPPerShard(); // Changed to double for zealot robes support
        int totalAvailableShards = prayerData.getTotalAvailableShards();

        // Calculate achievable level
        int achievableLevel = calculateAchievableLevelFromShardsWithXP(prayerData.getCurrentXP(), totalAvailableShards,
                xpPerShard);

        // Calculate XP gain
        int currentXP = prayerData.getCurrentXP();
        int achievableXP = PrayerConstants.getXPForLevel(achievableLevel);
        int totalXPGain = achievableXP - currentXP;

        // Create result with XP per shard tracking (convert double to int for display)
        CalculationResult result = new CalculationResult(0, achievableLevel, totalAvailableShards,
                (int) Math.round(xpPerShard));
        result.setTotalXPGain(totalXPGain);
        result.setBoneBreakdown(prayerData.getAvailableBones());
        result.setGoalAlreadyAchieved(false); // Resource mode doesn't have a specific goal

        // If we can't reach the next level, calculate remaining XP needed
        if (achievableLevel == currentLevel) {
            int nextLevelXP = PrayerConstants.getXPForLevel(currentLevel + 1);
            double availableXP = totalAvailableShards * xpPerShard;
            int remainingXP = (int) Math.max(0, nextLevelXP - currentXP - availableXP);
            result.setRemainingXP(remainingXP);
        }

        int winesNeeded = calculateWinesNeeded(totalAvailableShards);

        // Populate wine information in result
        result.setWinesNeeded(winesNeeded);

        return result;
    }

    public int calculateRequiredShards(int requiredXP, double xpPerShard) {
        if (requiredXP <= 0) {
            return 0;
        }
        if (xpPerShard <= 0) {
            throw new IllegalArgumentException("XP per shard must be positive");
        }

        return (int) Math.ceil((double) requiredXP / xpPerShard);
    }

    public int calculateAchievableLevelFromShards(int currentLevel, int availableShards, double xpPerShard) {
        if (availableShards <= 0) {
            return currentLevel;
        }

        int currentXP = PrayerConstants.getXPForLevel(currentLevel);
        double availableXP = availableShards * xpPerShard;
        int totalXP = (int) (currentXP + availableXP);

        return PrayerConstants.getLevelForXP(totalXP);
    }

    public int calculateAchievableLevelFromShardsWithXP(int currentXP, int availableShards, double xpPerShard) {
        if (availableShards <= 0) {
            return PrayerConstants.getLevelForXP(currentXP);
        }

        double availableXP = availableShards * xpPerShard;
        int totalXP = (int) (currentXP + availableXP);

        return PrayerConstants.getLevelForXP(totalXP);
    }

    public int calculateXPDifference(int fromLevel, int toLevel) {
        return PrayerConstants.getXPDifference(fromLevel, toLevel);
    }

    public int calculateTotalShards(Map<BoneType, Integer> boneBreakdown) {
        if (boneBreakdown == null || boneBreakdown.isEmpty()) {
            return 0;
        }

        return boneBreakdown.entrySet().stream()
                .mapToInt(entry -> entry.getKey().getShardValue() * entry.getValue())
                .sum();
    }

    public int calculateXPFromShards(int shards, double xpPerShard) {
        if (shards < 0) {
            throw new IllegalArgumentException("Shards cannot be negative");
        }
        if (xpPerShard <= 0) {
            throw new IllegalArgumentException("XP per shard must be positive");
        }

        return (int) (shards * xpPerShard);
    }

    public int calculateShardsForNextLevel(int currentLevel, double xpPerShard) {
        if (currentLevel >= PrayerConstants.MAX_PRAYER_LEVEL) {
            return 0;
        }

        int currentXP = PrayerConstants.getXPForLevel(currentLevel);
        int nextLevelXP = PrayerConstants.getXPForLevel(currentLevel + 1);
        int requiredXP = nextLevelXP - currentXP;

        return calculateRequiredShards(requiredXP, xpPerShard);
    }

    public int calculateShardsForNextLevelFromXP(int currentXP, double xpPerShard) {
        int currentLevel = PrayerConstants.getLevelForXP(currentXP);
        if (currentLevel >= PrayerConstants.MAX_PRAYER_LEVEL) {
            return 0;
        }

        int nextLevelXP = PrayerConstants.getXPForLevel(currentLevel + 1);
        int requiredXP = nextLevelXP - currentXP;

        return calculateRequiredShards(requiredXP, xpPerShard);
    }

    public int calculateWinesNeeded(int totalShards) {
        if (totalShards < 0) {
            throw new IllegalArgumentException("Total shards cannot be negative");
        }

        if (totalShards == 0) {
            return 0;
        }

        return (int) Math.ceil((double) totalShards / PrayerConstants.SHARDS_PER_WINE);
    }

    private void validatePrayerData(PrayerData prayerData) {
        if (prayerData.getCurrentLevel() < PrayerConstants.MIN_PRAYER_LEVEL ||
                prayerData.getCurrentLevel() > PrayerConstants.MAX_PRAYER_LEVEL) {
            throw new IllegalArgumentException("Invalid current prayer level: " + prayerData.getCurrentLevel());
        }

        // Validate target level if no target XP is set
        if (prayerData.getTargetXP() <= 0) {
            if (prayerData.getTargetLevel() < PrayerConstants.MIN_PRAYER_LEVEL ||
                    prayerData.getTargetLevel() > PrayerConstants.MAX_PRAYER_LEVEL) {
                throw new IllegalArgumentException("Invalid target prayer level: " + prayerData.getTargetLevel());
            }

            // Allow target level to equal current level (in case goal is already achieved, or if there's an xp goal)
            if (prayerData.getTargetLevel() < prayerData.getCurrentLevel()) {
                throw new IllegalArgumentException("Target level cannot be lower than current level");
            }
        } else {
            // When target XP is set, allow target level to be higher than normal max for 200M XP goals
            if (prayerData.getTargetLevel() < PrayerConstants.MIN_PRAYER_LEVEL) {
                throw new IllegalArgumentException("Invalid target prayer level: " + prayerData.getTargetLevel());
            }
            // Validate target XP
            if (prayerData.getTargetXP() < prayerData.getCurrentXP()) {
                throw new IllegalArgumentException("Target XP cannot be lower than current XP");
            }

            if (prayerData.getTargetXP() > 200_000_000) {
                throw new IllegalArgumentException("Target XP exceeds maximum prayer XP (200,000,000)");
            }
        }
    }
}
package com.boneshardhelper;

import com.google.common.collect.ImmutableList;
import java.awt.BorderLayout;
import java.awt.Dimension;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.awt.image.BufferedImage;
import java.util.ArrayList;
import java.util.Collection;
import java.util.List;
import javax.swing.BoxLayout;
import javax.swing.ImageIcon;
import javax.swing.JButton;
import javax.swing.JComponent;
import javax.swing.JLabel;
import javax.swing.JPanel;
import javax.swing.border.CompoundBorder;
import javax.swing.border.EmptyBorder;
import javax.swing.border.MatteBorder;
import lombok.Getter;
import net.runelite.client.plugins.config.ConfigPlugin;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.DynamicGridLayout;
import net.runelite.client.ui.FontManager;
import net.runelite.client.ui.PluginPanel;
import net.runelite.client.util.ImageUtil;
import net.runelite.client.util.SwingUtil;

// RuneLite's ConfigPanel Section, reimplemented
public class FoldingSection extends JPanel 
{
    private static final ImageIcon SECTION_EXPAND_ICON;
    private static final ImageIcon SECTION_EXPAND_ICON_HOVER;
    private static final ImageIcon SECTION_RETRACT_ICON;
    private static final ImageIcon SECTION_RETRACT_ICON_HOVER;
    static 
    {
        BufferedImage sectionRetractIcon = ImageUtil.loadImageResource(ConfigPlugin.class, "/util/arrow_right.png");
        sectionRetractIcon = ImageUtil.luminanceOffset(sectionRetractIcon, -121);
        SECTION_EXPAND_ICON = new ImageIcon(sectionRetractIcon);
        SECTION_EXPAND_ICON_HOVER = new ImageIcon(ImageUtil.alphaOffset(sectionRetractIcon, -100));
        final BufferedImage sectionExpandIcon = ImageUtil.rotateImage(sectionRetractIcon, Math.PI / 2);
        SECTION_RETRACT_ICON = new ImageIcon(sectionExpandIcon);
        SECTION_RETRACT_ICON_HOVER = new ImageIcon(ImageUtil.alphaOffset(sectionExpandIcon, -100));
    }
    private final JButton sectionToggle;
    private final JPanel sectionContents;

    @Getter
    private boolean isOpen = true;

    private final List<Runnable> expansionListeners = new ArrayList<>();

    public FoldingSection(final String header, final String description, JComponent... components) 
    {
        this(header, description, ImmutableList.copyOf(components));
    }

    public FoldingSection(final String header, final String description, Collection<JComponent> components) 
    {
        this.setLayout(new BoxLayout(this, BoxLayout.Y_AXIS));
        this.setMinimumSize(new Dimension(PluginPanel.PANEL_WIDTH, 0));

        final JPanel sectionHeader = new JPanel();
        sectionHeader.setLayout(new BorderLayout());
        sectionHeader.setMinimumSize(new Dimension(PluginPanel.PANEL_WIDTH, 0));
        sectionHeader.setBorder(new CompoundBorder(
                new MatteBorder(0, 0, 1, 0, ColorScheme.MEDIUM_GRAY_COLOR),
                new EmptyBorder(0, 0, 3, 1)));
        this.add(sectionHeader, BorderLayout.NORTH);

        sectionToggle = new JButton();
        sectionToggle.setIcon(isOpen ? SECTION_RETRACT_ICON : SECTION_EXPAND_ICON);
        sectionToggle.setRolloverIcon(isOpen ? SECTION_RETRACT_ICON_HOVER : SECTION_EXPAND_ICON_HOVER);
        sectionToggle.setPreferredSize(new Dimension(18, 0));
        sectionToggle.setBorder(new EmptyBorder(0, 0, 0, 5));
        sectionToggle.setToolTipText(isOpen ? "Retract" : "Expand");
        SwingUtil.removeButtonDecorations(sectionToggle);
        sectionHeader.add(sectionToggle, BorderLayout.WEST);

        final JLabel sectionName = new JLabel(header);
        sectionName.setForeground(ColorScheme.BRAND_ORANGE);
        sectionName.setFont(FontManager.getRunescapeBoldFont());
        if (description != null) 
        {
            sectionName.setToolTipText("<html>" + header + ":<br>" + description + "</html>");
        }
        sectionHeader.add(sectionName, BorderLayout.CENTER);

        sectionContents = new JPanel();
        sectionContents.setLayout(new DynamicGridLayout(0, 1, 0, 5));
        sectionContents.setMinimumSize(new Dimension(PluginPanel.PANEL_WIDTH, 0));
        sectionContents.setBorder(new CompoundBorder(
                new MatteBorder(0, 0, 1, 0, ColorScheme.MEDIUM_GRAY_COLOR),
                new EmptyBorder(PluginPanel.BORDER_OFFSET, 0, PluginPanel.BORDER_OFFSET, 0)));
        sectionContents.setVisible(isOpen);
        for (final JComponent c : components) 
        {
            sectionContents.add(c);
        }
        this.add(sectionContents, BorderLayout.SOUTH);

        // Add listeners to each part of the header so that it's easier to toggle them
        final MouseAdapter adapter = new MouseAdapter()
        {
            @Override
            public void mouseClicked(MouseEvent e) 
            {
                toggle();
            }
        };
        sectionToggle.addActionListener(actionEvent -> toggle());
        sectionName.addMouseListener(adapter);
        sectionHeader.addMouseListener(adapter);
    }

    private void toggle() 
    {
        boolean wasOpen = isOpen;
        isOpen = !isOpen;
        sectionToggle.setIcon(isOpen ? SECTION_RETRACT_ICON : SECTION_EXPAND_ICON);
        sectionToggle.setRolloverIcon(isOpen ? SECTION_RETRACT_ICON_HOVER : SECTION_EXPAND_ICON_HOVER);
        sectionToggle.setToolTipText(isOpen ? "Retract" : "Expand");
        sectionContents.setVisible(isOpen);

        if (!wasOpen && isOpen) 
            {
            for (Runnable listener : expansionListeners) {
                listener.run();
            }
        }
    }

    public void setOpen(final boolean open) 
    {
        if (isOpen == open) 
            {
            return;
        }

        toggle();
    }

    public void addExpansionListener(Runnable listener) 
    {
        if (listener != null) {
            expansionListeners.add(listener);
        }
    }
}
package com.boneshardhelper;

import java.awt.BorderLayout;
import java.awt.FlowLayout;
import java.awt.event.FocusAdapter;
import java.awt.event.FocusEvent;
import java.util.HashMap;
import java.util.Map;
import java.util.function.Consumer;
import java.util.regex.Pattern;
import javax.inject.Inject;
import javax.swing.JButton;
import javax.swing.JLabel;
import javax.swing.JPanel;
import javax.swing.border.EmptyBorder;
import com.google.inject.Singleton;
import lombok.Getter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.Experience;
import net.runelite.api.Skill;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.game.ItemManager;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.FontManager;
import net.runelite.client.ui.PluginPanel;
import net.runelite.client.ui.components.materialtabs.MaterialTab;
import net.runelite.client.ui.components.materialtabs.MaterialTabGroup;

@Getter
@Singleton
@Slf4j
class BoneShardHelperPanel extends PluginPanel {
	private static final Pattern NON_NUMERIC = Pattern.compile("\\D");

	// Panel that holds the content of the currently selected tab
	private final JPanel display = new JPanel();

	// Tab group and individual tabs
	private final MaterialTabGroup tabGroup = new MaterialTabGroup(display);
	private final MaterialTab goalModeTab;
	private final MaterialTab resourceModeTab;

	// Individual tab panels
	private final GoalModePanel goalModePanel;
	private final ResourceModePanel resourceModePanel;

	// Refresh button panel
	private final JPanel refreshPanel = new JPanel();
	private final JButton refreshButton = new JButton("Refresh Current Stats");

	// Client for getting current player stats
	private final Client client;

	// Resource scanner for inventory scanning
	private final BoneResourceScanner resourceScanner;

	// Config for plugin settings
	private final BoneShardHelperConfig config;

	// Session tracking for first-time initialization
	private boolean hasBeenInitializedThisSession = false;

	// Sample text label that changes based on active tab
	private JLabel sampleTextLabel;

	@Inject
	BoneShardHelperPanel(Client client, BoneResourceScanner resourceScanner, BoneShardHelperConfig config,
			ItemManager itemManager, net.runelite.client.hiscore.HiscoreClient hiscoreClient) {
		super();
		this.client = client;
		this.resourceScanner = resourceScanner;
		this.config = config;

		// Initialize tab panels (each with their own UI components)
		goalModePanel = new GoalModePanel();
		resourceModePanel = new ResourceModePanel(config);

		// Set up synchronized event handling for checkboxes and scan buttons
		setupSynchronizedEventHandlers();

		// Inject dependencies into Goal Mode panel
		goalModePanel.setResourceScanner(resourceScanner);
		goalModePanel.setItemManager(itemManager);
		goalModePanel.setHiscoreClient(hiscoreClient);

		// Set up debug mode in Goal Mode panel
		goalModePanel.setDebugMode(config.debugMode(), this);

		// Set dependencies for Resource Mode panel
		resourceModePanel.setParentPanel(this);
		resourceModePanel.setItemManager(itemManager);

		// Set up automatic calculation listeners
		setupCalculationListeners();

		// Set up resource scanning functionality
		setupResourceScanning();

		// Set up main panel layout
		setLayout(new BorderLayout());
		setBackground(ColorScheme.DARK_GRAY_COLOR);

		// Create tabs
		goalModeTab = new MaterialTab("Goal Mode", tabGroup, goalModePanel);
		resourceModeTab = new MaterialTab("Resource Mode", tabGroup, resourceModePanel);

		// Configure tab group
		tabGroup.setBorder(new EmptyBorder(5, 0, 0, 0));
		tabGroup.addTab(goalModeTab);
		tabGroup.addTab(resourceModeTab);
		tabGroup.select(goalModeTab); // Default to Goal Mode

		// Add tab switching logic to preserve shared state
		goalModeTab.setOnSelectEvent(this::onGoalModeSelected);
		resourceModeTab.setOnSelectEvent(this::onResourceModeSelected);

		// Create sample text panel that changes based on active tab
		JPanel sampleTextPanel = new JPanel(new FlowLayout(FlowLayout.LEFT, 5, 5));
		sampleTextPanel.setBackground(ColorScheme.DARK_GRAY_COLOR);
		JLabel sampleTextLabel = new JLabel("Calculate what you need to reach your goal");
		sampleTextLabel.setForeground(java.awt.Color.LIGHT_GRAY);
		sampleTextLabel.setFont(FontManager.getRunescapeSmallFont());
		sampleTextPanel.add(sampleTextLabel);

		// Set up refresh button panel
		refreshPanel.setLayout(new FlowLayout(FlowLayout.CENTER));
		refreshPanel.setBackground(ColorScheme.DARK_GRAY_COLOR);
		refreshButton.setBackground(ColorScheme.DARKER_GRAY_COLOR);
		refreshButton.setForeground(java.awt.Color.WHITE);
		refreshButton.setFont(FontManager.getRunescapeSmallFont());
		refreshButton.setBorder(new EmptyBorder(5, 10, 5, 10));
		refreshButton.addActionListener(e -> refreshCurrentStats());
		refreshPanel.add(refreshButton);

		// Create a container for tabs, sample text, and refresh button
		JPanel topPanel = new JPanel(new BorderLayout());
		topPanel.setBackground(ColorScheme.DARK_GRAY_COLOR);
		topPanel.add(tabGroup, BorderLayout.NORTH);

		// Create middle panel for sample text and refresh button
		JPanel middlePanel = new JPanel(new BorderLayout());
		middlePanel.setBackground(ColorScheme.DARK_GRAY_COLOR);
		middlePanel.add(sampleTextPanel, BorderLayout.NORTH);
		middlePanel.add(refreshPanel, BorderLayout.SOUTH);

		topPanel.add(middlePanel, BorderLayout.SOUTH);

		// Store reference to sample text label for updating when tabs change
		this.sampleTextLabel = sampleTextLabel;

		// Add components to main panel
		add(topPanel, BorderLayout.NORTH);
		add(display, BorderLayout.CENTER);
	}

	@Override
	public void setVisible(boolean visible) {
		super.setVisible(visible);

		// Initialize fields with current player stats the first time the panel is
		// opened this session
		if (visible && !hasBeenInitializedThisSession) {
			hasBeenInitializedThisSession = true;
			try {
				// Refresh current stats to populate fields with player's current prayer data
				refreshCurrentStats();
			} catch (Exception e) {
				log.error("Error initializing prayer calculator on first panel open", e);
			}
		}
	}

	// Tab switching event handlers that preserve shared state
	private boolean onGoalModeSelected() {
		// Update sample text for Goal Mode
		if (sampleTextLabel != null) {
			sampleTextLabel.setText("Calculate what you need to reach your goal");
		}

		// Sync shared state from Resource Mode to Goal Mode
		syncSharedState(resourceModePanel, goalModePanel);

		// Update zealot robes warning to reflect current checkbox state
		goalModePanel.updateZealotRobesWarningDisplay();

		// Update calculations to reflect any changes made in Resource Mode
		// Call directly since tab selection might not be complete yet
		try {
			goalModePanel.updateBoneShardsRequired();
		} catch (Exception e) {
			handleCalculationError("Error updating calculations on mode switch", e);
		}

		// Trigger resource planning recalculation (same as XP field listener)
		triggerResourcePlanningRecalculation();

		return true;
	}

	private boolean onResourceModeSelected() {
		// Update sample text for Resource Mode
		if (sampleTextLabel != null) {
			sampleTextLabel.setText("Calculate the shard value of your inventory");
		}

		// Sync shared state from Goal Mode to Resource Mode
		syncSharedState(goalModePanel, resourceModePanel);

		// Update zealot robes warning to reflect current checkbox state
		resourceModePanel.updateZealotRobesWarningDisplay();

		// Update Resource Mode calculations if we have scanned data
		// This ensures checkbox changes made in Goal Mode are reflected in Resource
		// Mode calculations
		if (resourceModePanel.getResourceBreakdownTable().getRowCount() > 0) {
			// Re-scan to update achievable level with current checkbox settings
			performResourceScan();
		}

		// Trigger resource planning recalculation (same as XP field listener)
		triggerResourcePlanningRecalculation();

		return true;
	}

	// Synchronize shared state between panels
	private void syncSharedState(GoalModePanel source, ResourceModePanel target) {
		target.setCurrentLevelInput(source.getCurrentLevelInput());
		// Apply formatting when syncing XP values (setCurrentXPInput updates both
		// panels)
		int currentXP = source.getCurrentXPInput();
		setCurrentXPInput(String.format("%,d", currentXP));
		target.setSunfireWineSelected(source.isSunfireWineSelected());
		target.setZealotRobesSelected(source.isZealotRobesSelected());
	}

	private void syncSharedState(ResourceModePanel source, GoalModePanel target) {
		target.setCurrentLevelInput(source.getCurrentLevelInput());
		// Apply formatting when syncing XP values (setCurrentXPInput updates both
		// panels)
		int currentXP = source.getCurrentXPInput();
		setCurrentXPInput(String.format("%,d", currentXP));
		target.setSunfireWineSelected(source.isSunfireWineSelected());
		target.setZealotRobesSelected(source.isZealotRobesSelected());
	}

	// Accessor methods for current level and XP (shared between both modes)
	int getCurrentLevelInput() {
		// Get from currently active tab
		if (goalModeTab.isSelected()) {
			return getNumericInput(goalModePanel.getUiFieldCurrentLevel().getText());
		} else {
			return getNumericInput(resourceModePanel.getUiFieldCurrentLevel().getText());
		}
	}

	void setCurrentLevelInput(int value) {
		// Set on both panels to keep them in sync
		goalModePanel.setCurrentLevelInput(value);
		resourceModePanel.setCurrentLevelInput(value);
	}

	int getCurrentXPInput() {
		// Get from currently active tab
		if (goalModeTab.isSelected()) {
			return getNumericInput(goalModePanel.getUiFieldCurrentXP().getText());
		} else {
			return getNumericInput(resourceModePanel.getUiFieldCurrentXP().getText());
		}
	}

	void setCurrentXPInput(Object value) {
		// Set on both panels to keep them in sync
		goalModePanel.setCurrentXPInput(value);
		resourceModePanel.setCurrentXPInput(value);
	}

	// Goal Mode specific methods
	int getTargetLevelInput() {
		return getNumericInput(goalModePanel.getUiFieldTargetLevel().getText());
	}

	void setTargetLevelInput(Object value) {
		goalModePanel.setTargetLevelInput(value);
	}

	int getTargetXPInput() {
		return getNumericInput(goalModePanel.getUiFieldTargetXP().getText());
	}

	void setTargetXPInput(Object value) {
		goalModePanel.setTargetXPInput(value);
	}

	// Checkbox state methods (shared between both modes)
	boolean isSunfireWineSelected() {
		// Get from currently active tab
		if (goalModeTab.isSelected()) {
			return goalModePanel.isSunfireWineSelected();
		} else {
			return resourceModePanel.isSunfireWineSelected();
		}
	}

	void setSunfireWineSelected(boolean selected) {
		// Set on both panels to keep them in sync
		goalModePanel.setSunfireWineSelected(selected);
		resourceModePanel.setSunfireWineSelected(selected);
	}

	boolean isZealotRobesSelected() {
		// Get from currently active tab
		if (goalModeTab.isSelected()) {
			return goalModePanel.isZealotRobesSelected();
		} else {
			return resourceModePanel.isZealotRobesSelected();
		}
	}

	void setZealotRobesSelected(boolean selected) {
		// Set on both panels to keep them in sync
		goalModePanel.setZealotRobesSelected(selected);
		resourceModePanel.setZealotRobesSelected(selected);
	}

	// Method to show Goal Mode tab
	void showGoalMode() {
		if (goalModePanel.isShowing()) {
			return;
		}
		tabGroup.select(goalModeTab);
		revalidate();
	}

	// Method to show Resource Mode tab
	void showResourceMode() {
		if (resourceModePanel.isShowing()) {
			return;
		}
		tabGroup.select(resourceModeTab);
		revalidate();
	}

	// Method to refresh current player stats
	public void refreshCurrentStats() {
		refreshCurrentStats(false);
	}

	public void refreshCurrentStatsFromPlugin() {
		refreshCurrentStats(true);
	}

	private void refreshCurrentStats(boolean fromPlugin) {
		Integer currentXP = null;
		Integer currentLevel = null;
		boolean dataAvailable = false;

		if (client != null) {
			try {
				// Test that reading of current prayer XP from game client works correctly
				currentXP = client.getSkillExperience(Skill.PRAYER);
				currentLevel = Experience.getLevelForXp(currentXP);
				dataAvailable = true;

				// Validate that XP and level are consistent
				int expectedLevel = Experience.getLevelForXp(currentXP);
				if (currentLevel != expectedLevel) {
					log.warn("Prayer XP/Level inconsistency detected. XP: {}, Level: {}, Expected: {}",
							currentXP, currentLevel, expectedLevel);
				}

				// Validate XP bounds
				if (currentXP < 0 || currentXP > Experience.MAX_SKILL_XP) {
					log.warn("Prayer XP out of bounds: {}", currentXP);
					dataAvailable = false;
					currentXP = null;
					currentLevel = null;
				}

				// Validate level bounds
				if (currentLevel != null && (currentLevel < 1 || currentLevel > Experience.MAX_VIRT_LEVEL)) {
					log.warn("Prayer level out of bounds: {}", currentLevel);
					dataAvailable = false;
					currentXP = null;
					currentLevel = null;
				}

				if (fromPlugin && dataAvailable) {
					log.debug("Prayer XP detection working: Level {} ({} XP)", currentLevel,
							String.format("%,d", currentXP));
				}
			} catch (Exception e) {
				log.error("Error retrieving prayer data from client", e);
				dataAvailable = false;
				currentXP = null;
				currentLevel = null;
			}
		}

		// Update fields only when manually refreshing and data is available
		if (!fromPlugin) {
			if (dataAvailable && currentXP != null && currentLevel != null) {
				try {
					// Clear any previous error messages when data becomes available
					clearValidationError();

					// Calculate target: next level for most players, or 200M XP if level 99+ Prayer
					int targetLevel;
					int targetXP;

					if (currentLevel >= 99) {
						// For level 99+ players, default to 200M XP goal
						targetXP = Experience.MAX_SKILL_XP;
						targetLevel = Experience.getLevelForXp(targetXP);
					} else {
						// For lower level players, target next level
						targetLevel = Math.min(currentLevel + 1, Experience.MAX_VIRT_LEVEL);
						targetXP = Experience.getXpForLevel(targetLevel);
					}

					// Manual refresh - update all fields with actual data
					setCurrentLevelInput(currentLevel);
					setCurrentXPInput(String.format("%,d", currentXP));
					setTargetLevelInput(targetLevel);
					setTargetXPInput(String.format("%,d", targetXP));

					// Update Goal Mode calculations after refresh
					updateGoalModeCalculations();
				} catch (Exception e) {
					handleCalculationError("Error updating fields after refresh", e);
				}
			} else {
				// No data available - show error but don't populate fields with defaults
				showValidationError(
						"Game data unavailable. Please log in and try again, or manually enter your current stats.");
			}
		} else if (fromPlugin && !dataAvailable) {
			log.debug("Prayer data unavailable during validation");
		}
	}

	// Set up automatic calculation listeners for level/XP fields
	private void setupCalculationListeners() {
		// Goal Mode listeners
		goalModePanel.getUiFieldCurrentLevel().addActionListener(e -> onCurrentLevelUpdated());
		goalModePanel.getUiFieldCurrentLevel().addFocusListener(buildFocusAdapter(e -> onCurrentLevelUpdated()));

		goalModePanel.getUiFieldCurrentXP().addActionListener(e -> onCurrentXPUpdated());
		goalModePanel.getUiFieldCurrentXP().addFocusListener(buildFocusAdapter(e -> onCurrentXPUpdated()));

		goalModePanel.getUiFieldTargetLevel().addActionListener(e -> onTargetLevelUpdated());
		goalModePanel.getUiFieldTargetLevel().addFocusListener(buildFocusAdapter(e -> onTargetLevelUpdated()));

		goalModePanel.getUiFieldTargetXP().addActionListener(e -> onTargetXPUpdated());
		goalModePanel.getUiFieldTargetXP().addFocusListener(buildFocusAdapter(e -> onTargetXPUpdated()));

		// Resource Mode listeners (only for current level/XP since it doesn't have
		// target fields)
		resourceModePanel.getUiFieldCurrentLevel().addActionListener(e -> onCurrentLevelUpdated());
		resourceModePanel.getUiFieldCurrentLevel().addFocusListener(buildFocusAdapter(e -> onCurrentLevelUpdated()));

		resourceModePanel.getUiFieldCurrentXP().addActionListener(e -> onCurrentXPUpdated());
		resourceModePanel.getUiFieldCurrentXP().addFocusListener(buildFocusAdapter(e -> onCurrentXPUpdated()));
	}

	// Event handlers for automatic calculations with validation
	private void onCurrentLevelUpdated() {
		try {
			clearValidationError();
			int currentLevel = enforceSkillBounds(getCurrentLevelInput());
			int currentXP = Experience.getXpForLevel(currentLevel);
			setCurrentXPInput(String.format("%,d", currentXP));

			// Update Goal Mode calculations
			updateGoalModeCalculations();
		} catch (Exception e) {
			handleCalculationError("Error updating current level", e);
		}
	}

	private void onCurrentXPUpdated() {
		try {
			clearValidationError();
			int currentXP = enforceXPBounds(getCurrentXPInput());
			int currentLevel = Experience.getLevelForXp(currentXP);
			setCurrentLevelInput(currentLevel);

			// Format the XP value with commas
			setCurrentXPInput(String.format("%,d", currentXP));

			// Update Goal Mode calculations
			updateGoalModeCalculations();
		} catch (Exception e) {
			handleCalculationError("Error updating current XP", e);
		}
	}

	private void onTargetLevelUpdated() {
		try {
			clearValidationError();
			int targetLevel = getTargetLevelInput();

			// This implementation sucks but my brain is fried. Maybe fixing QOL in later
			// update.
			int targetXP = getTargetXPInput();
			if (targetLevel > Experience.MAX_VIRT_LEVEL && targetXP < Experience.MAX_SKILL_XP) {
				showValidationError("Target level cannot exceed " + Experience.MAX_VIRT_LEVEL
						+ ". Use 'Target Experience' input box if pursuing 200M XP.");
				return;
			}

			// Calculate target XP, but cap at 200M if level would exceed that
			int maxPossibleXP = Experience.MAX_SKILL_XP;
			int calculatedTargetXP = Math.min(Experience.getXpForLevel(targetLevel), maxPossibleXP);
			setTargetXPInput(String.format("%,d", calculatedTargetXP));

			// Update Goal Mode calculations
			updateGoalModeCalculations();
		} catch (Exception e) {
			handleCalculationError("Error updating target level", e);
		}
	}

	private void onTargetXPUpdated() {
		try {
			clearValidationError();
			int targetXP = enforceXPBounds(getTargetXPInput());
			int targetLevel = Experience.getLevelForXp(targetXP);
			setTargetLevelInput(targetLevel);

			// Format the XP value with commas
			setTargetXPInput(String.format("%,d", targetXP));

			// Update Goal Mode calculations
			updateGoalModeCalculations();
		} catch (Exception e) {
			handleCalculationError("Error updating target XP", e);
		}
	}

	private void updateGoalModeCalculations() {
		// Update Goal Mode calculation results when inputs change.
		if (goalModeTab.isSelected()) {
			try {
				goalModePanel.updateBoneShardsRequired();
			} catch (Exception e) {
				handleCalculationError("Error updating calculations", e);
			}
		}
	}

	public void performResourceModeResourceScan() {
		if (resourceScanner == null) {
			resourceModePanel.updateDebugError("Resource scanner not available");
			return;
		}

		try {
			resourceModePanel.updateDebugStatus("Scanning inventory...");

			// Use ClientThread to safely access game data
			resourceScanner.getClientThread().invoke(() -> {
				try {
					// Scan inventory for bones
					Map<BoneType, Integer> inventoryBones = resourceScanner.scanInventory();

					// Calculate current total shards from inventory
					int currentShards = resourceScanner.calculateTotalShards(inventoryBones);

					// Update UI on EDT
					javax.swing.SwingUtilities.invokeLater(() -> {
						try {
							// Update resource breakdown table
							resourceModePanel.updateResourceBreakdown(inventoryBones);

							// Update achievable level calculation (use debug override if available)
							int currentXP = resourceModePanel.getCurrentXPInput();
							boolean useSunfireWine = resourceModePanel.isSunfireWineSelected();
							int effectiveShards = resourceModePanel.getEffectiveTotalShards(currentShards);
							resourceModePanel.updateAchievableLevel(effectiveShards, currentXP, useSunfireWine);

							// Show success message
							resourceModePanel.updateDebugSuccess("Resource display updated");
						} catch (Exception e) {
							resourceModePanel.updateDebugError("Error updating display: " + e.getMessage());
						}
					});
				} catch (Exception e) {
					javax.swing.SwingUtilities.invokeLater(() -> {
						resourceModePanel.updateDebugError("Error scanning inventory: " + e.getMessage());
					});
				}
			});
		} catch (Exception e) {
			resourceModePanel.updateDebugError("Error: " + e.getMessage());
		}
	}

	private void handleCalculationError(String context, Exception e) {
		log.error("Prayer Calculator: {}", context, e);
		showValidationError("Calculation error: Please check your input values");
	}

	// Helper methods for input validation with error handling
	private static int enforceSkillBounds(int input) {
		return Math.min(Experience.MAX_VIRT_LEVEL, Math.max(1, input));
	}

	private static int enforceXPBounds(int input) {
		return Math.min(Experience.MAX_SKILL_XP, Math.max(0, input));
	}

	private void showValidationError(String message) {
		if (goalModeTab.isSelected()) {
			goalModePanel.showValidationError(message);
		}
	}

	private void clearValidationError() {
		goalModePanel.clearValidationError();
	}

	// Helper method to parse numeric input from text fields
	private static int getNumericInput(String text) {
		try {
			return Integer.parseInt(NON_NUMERIC.matcher(text).replaceAll(""));
		} catch (NumberFormatException e) {
			return 0;
		}
	}

	// Helper method to build focus adapters
	private static FocusAdapter buildFocusAdapter(Consumer<FocusEvent> focusLostConsumer) {
		return new FocusAdapter() {
			@Override
			public void focusLost(FocusEvent e) {
				focusLostConsumer.accept(e);
			}
		};
	}

	// Set up resource scanning functionality
	private void setupResourceScanning() {
		try {
			// Add action listener to the scan resources button
			resourceModePanel.updateDebugStatus("Setting up button listener...");
			resourceModePanel.getUiButtonScanResources().addActionListener(e -> {
				resourceModePanel.updateDebugStatus("Main button clicked!");
				performResourceScan();
			});

			// Note: Synchronized event handlers are set up in
			// setupSynchronizedEventHandlers()

			resourceModePanel.updateDebugSuccess("Setup complete");
		} catch (Exception ex) {
			resourceModePanel.updateDebugError("Setup failed: " + ex.getMessage());
		}
	}

	private void performResourceScan() {
		// Perform resource scanning and update the breakdown table
		resourceModePanel.updateDebugStatus("Button clicked - starting inventory scan...");

		if (client == null) {
			resourceModePanel.updateDebugError("Game client unavailable - cannot scan inventory");
			return;
		}

		if (resourceScanner == null) {
			resourceModePanel.updateDebugError("Resource scanner unavailable");
			return;
		}

		ClientThread clientThread = resourceScanner.getClientThread();
		if (clientThread == null) {
			resourceModePanel.updateDebugError("Client thread unavailable");
			return;
		}

		// Execute inventory access on ClientThread with error handling
		clientThread.invoke(() -> {
			try {
				resourceModePanel.updateDebugStatus("Accessing inventory...");

				// Get inventory container with validation
				net.runelite.api.ItemContainer inventory = client.getItemContainer(93);
				if (inventory == null) {
					resourceModePanel.updateDebugError("Inventory not accessible - make sure you're logged in");
					return;
				}

				// Get items array with validation
				net.runelite.api.Item[] items = inventory.getItems();
				if (items == null) {
					resourceModePanel.updateDebugError("Inventory items not accessible");
					return;
				}

				// Process inventory items with error handling
				Map<Integer, String[]> debugInfo = new HashMap<>();
				Map<BoneType, Integer> boneResources = new HashMap<>();
				int totalItems = 0;
				int errorCount = 0;

				for (int i = 0; i < items.length; i++) {
					try {
						net.runelite.api.Item item = items[i];
						if (item == null || item.getId() <= 0) {
							continue;
						}

						totalItems++;
						int itemId = item.getId();
						int quantity = item.getQuantity();

						// Validate quantity bounds
						if (quantity < 0 || quantity > Integer.MAX_VALUE / 1000) {
							errorCount++;
							continue;
						}

						// Get proper item name using ItemManager with error handling
						String itemName = "Item " + itemId;
						try {
							if (resourceScanner.getItemManager() != null) {
								itemName = resourceScanner.getItemManager().getItemComposition(itemId).getMembersName();
							}
						} catch (Exception e) {
							itemName = "Item " + itemId + " (name error)";
							errorCount++;
						}

						// Check if it's a bone item with error handling
						BoneType boneType = null;
						try {
							boneType = BoneResourceScanner.getBoneTypeForItem(itemId);
							if (boneType != null) {
								boneResources.merge(boneType, quantity, Integer::sum);
								itemName += " [BONE: " + boneType.name() + "]";
							}
						} catch (Exception e) {
							errorCount++;
							// Continue processing other items
						}

						// Add to debug table
						debugInfo.put(i, new String[] {
								String.valueOf(itemId),
								itemName,
								String.valueOf(quantity)
						});

					} catch (Exception e) {
						errorCount++;
						// Continue processing other items
					}
				}

				// Debug inventory table removed - no longer needed

				if (boneResources.isEmpty()) {
					String message = "Found " + totalItems + " items, no bones detected";
					if (errorCount > 0) {
						message += " (" + errorCount + " items had errors)";
					}
					resourceModePanel.updateDebugStatus(message);

					// Update with empty bone resources to show 0 values with icons
					resourceModePanel.updateResourceBreakdown(boneResources);

					// Update achievable level with 0 shards to show proper 0 values and icons (use
					// debug override if available)
					int currentXP = getCurrentXPInput();
					boolean useSunfireWine = isSunfireWineSelected();
					int effectiveShards = resourceModePanel.getEffectiveTotalShards(0);
					resourceModePanel.updateAchievableLevel(effectiveShards, currentXP, useSunfireWine);
				} else {
					try {
						// Update bone breakdown with error handling
						resourceModePanel.updateResourceBreakdown(boneResources);

						// Calculate achievable level with bounds checking
						int totalShards = 0;
						for (Map.Entry<BoneType, Integer> entry : boneResources.entrySet()) {
							int shardValue = entry.getKey().getShardValue() * entry.getValue();
							// Prevent integer overflow
							if (totalShards > Integer.MAX_VALUE - shardValue) {
								resourceModePanel.updateDebugError("Too many shards - calculation overflow");
								return;
							}
							totalShards += shardValue;
						}

						int currentXP = getCurrentXPInput();
						boolean useSunfireWine = isSunfireWineSelected();
						int effectiveShards = resourceModePanel.getEffectiveTotalShards(totalShards);
						resourceModePanel.updateAchievableLevel(effectiveShards, currentXP, useSunfireWine);

						String message = "Resource display updated";
						if (errorCount > 0) {
							message += " (" + errorCount + " items had errors)";
						}
						resourceModePanel.updateDebugSuccess(message);

					} catch (Exception e) {
						resourceModePanel.updateDebugError("Error calculating results: " + e.getMessage());
					}
				}

			} catch (Exception ex) {
				// Requirement 10.5: Log errors without crashing RuneLite
				log.error("Prayer Calculator: Resource scan failed", ex);
				resourceModePanel.updateDebugError("Scan failed: " + ex.getMessage());
			}
		});
	}

	// Handle wine type changes to recalculate levels
	private void onWineTypeChanged() {
		// Update Goal Mode calculations - call directly to ensure it runs regardless of
		// tab selection
		try {
			goalModePanel.updateBoneShardsRequired();
		} catch (Exception e) {
			handleCalculationError("Error updating calculations on wine type change", e);
		}

		// Update Resource Mode calculations if we have scanned data (regardless of tab
		// selection)
		try {
			// Recalculate using existing data with new wine type (no inventory rescan
			// needed)
			resourceModePanel.recalculateWithCurrentSettings();
		} catch (Exception e) {
			handleCalculationError("Error updating Resource Mode calculations on wine type change", e);
		}

		// Trigger resource planning recalculation (will recalculate immediately if expanded, or flag for update if collapsed)
		triggerResourcePlanningRecalculation();
	}

	// Handle zealot robes checkbox changes to update calculations
	private void onZealotRobesChanged() {
		// Update Goal Mode calculations - call directly to ensure it runs regardless of
		// tab selection
		try {
			goalModePanel.updateBoneShardsRequired();
		} catch (Exception e) {
			handleCalculationError("Error updating calculations on zealot robes change", e);
		}

		// Update Resource Mode calculations if we have scanned data (regardless of tab
		// selection)
		try {
			// Recalculate using existing data with new zealot robes setting (no inventory
			// rescan needed)
			resourceModePanel.recalculateWithCurrentSettings();
		} catch (Exception e) {
			handleCalculationError("Error updating Resource Mode calculations on zealot robes change", e);
		}

		// Update zealot robes warning display for both modes
		goalModePanel.updateZealotRobesWarningDisplay();
		resourceModePanel.updateZealotRobesWarningDisplay();
		triggerResourcePlanningRecalculation();
	}

	public void updateDebugMode(boolean debugMode) {
		// Update debug mode in Resource Mode panel
		if (resourceModePanel != null) {
			resourceModePanel.updateDebugSectionVisibility();
		}

		// Update debug mode in Goal Mode panel
		if (goalModePanel != null) {
			goalModePanel.setDebugMode(debugMode, this);
		}
	}

	private void triggerResourcePlanningRecalculation() {
		// Delegate to Goal Mode panel's resource planning recalculation
		goalModePanel.triggerResourcePlanningRecalculation();
	}

	private void setupSynchronizedEventHandlers() {
		// Set up synchronized checkbox event handlers
		goalModePanel.getUiCheckboxSunfireWine().addActionListener(e -> {
			// Sync state to Resource Mode
			resourceModePanel.setSunfireWineSelected(goalModePanel.isSunfireWineSelected());
			onWineTypeChanged();
		});

		resourceModePanel.getUiCheckboxSunfireWine().addActionListener(e -> {
			// Sync state to Goal Mode
			goalModePanel.setSunfireWineSelected(resourceModePanel.isSunfireWineSelected());
			onWineTypeChanged();
		});

		goalModePanel.getUiCheckboxZealotRobes().addActionListener(e -> {
			// Sync state to Resource Mode
			resourceModePanel.setZealotRobesSelected(goalModePanel.isZealotRobesSelected());
			onZealotRobesChanged();
		});

		resourceModePanel.getUiCheckboxZealotRobes().addActionListener(e -> {
			// Sync state to Goal Mode
			goalModePanel.setZealotRobesSelected(resourceModePanel.isZealotRobesSelected());
			onZealotRobesChanged();
		});

		// Set up synchronized scan button handlers
		goalModePanel.getUiButtonScanInventory().addActionListener(e -> performUnifiedInventoryScan());
		resourceModePanel.getUiButtonScanResources().addActionListener(e -> performUnifiedInventoryScan());
	}

	private void performUnifiedInventoryScan() {
		// Performs unified inventory scan that updates both Goal Mode and Resource Mode
		// Perform the resource scan (this updates Resource Mode)
		performResourceScan();

		// Also trigger Goal Mode resource planning scan if it's expanded
		if (goalModePanel.isResourcePlanningExpanded()) {
			goalModePanel.performInventoryScan();
		}
	}
}
package com.boneshardhelper;

import java.util.Set;
import javax.annotation.Nullable;
import lombok.AllArgsConstructor;
import lombok.Value;
import net.runelite.api.Tile;
import net.runelite.api.TileObject;

@Value
@AllArgsConstructor
class PrayerObject
{
    public static final Set<Integer> PRAYER_OBJECT_IDS = Set.of(
        52799, // EXPOSED_ALTAR
        52405, // SHRINE_OF_RALOS
        53018 // LIBATION_BOWL
    );

    private final Tile tile;
    @Nullable
    private final TileObject tileObject;
    private final int objectId;
    private final String name;

    public static PrayerObject fromTileObject(Tile tile, @Nullable TileObject tileObject)
    {
        if (tileObject == null)
        {
            return null;
        }

        int objectId = tileObject.getId();
        if (!PRAYER_OBJECT_IDS.contains(objectId))
        {
            return null;
        }

        String name = getObjectName(objectId);
        return new PrayerObject(tile, tileObject, objectId, name);
    }

    public static String getObjectName(int objectId)
    {
        switch (objectId)
        {
            case 52799:
                return "Exposed Altar";
            case 52405:
                return "Shrine of Ralos";
            case 53018:
                return "Libation Bowl";
            default:
                return "Unknown Prayer Object";
        }
    }

    public boolean shouldHighlight()
    {
        return tileObject != null && PRAYER_OBJECT_IDS.contains(objectId);
    }

    public java.awt.Color getHighlightColor(BoneShardHelperConfig config, BoneShardTrainingState trainingState)
    // Gets highlight color from config based on current training state.
    {
        BoneShardTrainingState.TrainingState currentState = trainingState.getCurrentTrainingState();
        
        switch (objectId)
        {
            case 52799: // EXPOSED_ALTAR
                // Active in BLESS_WINES state, inactive otherwise
                if (currentState == BoneShardTrainingState.TrainingState.BLESS_WINES) {
                    return config.activeObjectColor();
                } else {
                    return config.inactiveObjectColor();
                }
                
            case 52405: // SHRINE_OF_RALOS
                // Active in RECHARGE_PRAYER state, inactive otherwise
                if (currentState == BoneShardTrainingState.TrainingState.RECHARGE_PRAYER) {
                    return config.activeObjectColor();
                } else {
                    return config.inactiveObjectColor();
                }
            case 53018: // LIBATION_BOWL
                // Active in SACRIFICE_SHARDS state, inactive otherwise
                if (currentState == BoneShardTrainingState.TrainingState.SACRIFICE_SHARDS) {
                    return config.activeObjectColor();
                } else {
                    return config.inactiveObjectColor();
                }
                
            default:
                return null; // Don't highlight unknown objects
        }
    }
}
package com.boneshardhelper;

import java.awt.BasicStroke;
import java.awt.Color;
import java.awt.Dimension;
import java.awt.Graphics2D;
import java.awt.Shape;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import javax.inject.Inject;
import net.runelite.api.Client;
import net.runelite.api.Point;
import net.runelite.api.Tile;
import net.runelite.api.TileObject;
import net.runelite.api.coords.LocalPoint;
import net.runelite.api.coords.WorldPoint;
import net.runelite.client.ui.overlay.Overlay;
import net.runelite.client.ui.overlay.OverlayLayer;
import net.runelite.client.ui.overlay.OverlayPosition;
import net.runelite.client.ui.overlay.OverlayUtil;
import net.runelite.client.ui.overlay.outline.ModelOutlineRenderer;
import net.runelite.client.util.ColorUtil;
import net.runelite.api.Perspective;

class PrayerObjectOverlay extends Overlay {
    // Overlay for highlighting relevant objects in Ralos' rise (implemented similar to agility plugin)
    private static final int MAX_DISTANCE = 2350;
    private static final int EXPOSED_ALTAR_ID = 52799;
    private static final int LIBATION_BOWL_ID = 53018;
    private static final int RALOS_REGION_ID = 5681;

    private final Client client;
    private final BoneShardHelperConfig config;
    private final ModelOutlineRenderer modelOutlineRenderer;
    private BoneShardHelperPlugin plugin;
    private BoneShardTrainingState trainingState;

    // Path caching to improve performance
    private List<WorldPoint> cachedPath = null;
    private WorldPoint lastPlayerPosition = null;
    private WorldPoint lastAltarPosition = null;
    private BoneShardTrainingState.TrainingState lastTrainingState = null;

    @Inject
    private PrayerObjectOverlay(Client client, BoneShardHelperConfig config, BoneShardTrainingState trainingState, 
                                ModelOutlineRenderer modelOutlineRenderer) {
        setPosition(OverlayPosition.DYNAMIC);
        setLayer(OverlayLayer.ABOVE_SCENE);
        this.client = client;
        this.config = config;
        this.trainingState = trainingState;
        this.modelOutlineRenderer = modelOutlineRenderer;
    }

    void setPlugin(BoneShardHelperPlugin plugin) {
        this.plugin = plugin;
    }

    @Override
    public Dimension render(Graphics2D graphics) {
        LocalPoint playerLocation = client.getLocalPlayer().getLocalLocation();
        Point mousePosition = client.getMouseCanvasPosition();

        // Render object highlighting if enabled and plugin is set
        if (plugin != null && config.highlightPrayerObjects()) {
            // Render each object that should be highlighted
            plugin.getPrayerObjects().forEach((tileObject, prayerObject) -> {
                if (prayerObject == null || !prayerObject.shouldHighlight()) {
                    return;
                }

                Tile tile = prayerObject.getTile();
                TileObject object = prayerObject.getTileObject();

                // Only highlight objects on the same plane and within distance
                if (tile.getPlane() == client.getLocalPlayer().getWorldLocation().getPlane()
                        && object.getLocalLocation().distanceTo(playerLocation) < MAX_DISTANCE) {
                    Color configColor = prayerObject.getHighlightColor(config, trainingState);

                    // Render based on selected highlight style
                    if (config.highlightStyle() == HighlightStyle.HIGHLIGHT_CLICKBOX) {
                        // Clickbox style: draw outline and fill
                        Shape objectClickbox = object.getClickbox();
                        if (objectClickbox != null) {
                            Color renderColor = configColor;
                            if (objectClickbox.contains(mousePosition.getX(), mousePosition.getY())) {
                                renderColor = configColor.darker();
                            }

                            graphics.setColor(renderColor);
                            graphics.draw(objectClickbox);

                            graphics.setColor(ColorUtil.colorWithAlpha(configColor, configColor.getAlpha() / 5));
                            graphics.fill(objectClickbox);
                        }
                    } else if (config.highlightStyle() == HighlightStyle.HIGHLIGHT_OUTLINE) {
                        modelOutlineRenderer.drawOutline(object, 2, configColor, 4);
                    }

                    // Draw text overlay for libation bowl
                    if ((config.toggleOverlayActionsLeft() || config.toggleOverlayStageName()) 
                            && prayerObject.getObjectId() == LIBATION_BOWL_ID) {
                        drawLibationBowlText(graphics, object, prayerObject);
                    }
                }
            });
        }

        // Draw path to exposed altar when in BLESS_WINES state and enabled in config
        if (plugin != null && config.exposedAltarPath() && trainingState.inTrainingRegion()) {
            BoneShardTrainingState.TrainingState currentState = trainingState.getCurrentTrainingState();

            // Only show path when in BLESS_WINES state
            if (currentState == BoneShardTrainingState.TrainingState.BLESS_WINES) {
                drawPathToExposedAltar(graphics);
            } else {
                // Clear cached path when not in BLESS_WINES state
                clearPathCache();
            }
        } else {
            clearPathCache();
        }

        return null;
    }

    private void drawPathToExposedAltar(Graphics2D graphics) {
        // Find the exposed altar
        TileObject exposedAltar = findExposedAltar();
        if (exposedAltar == null) {
            cachedPath = null;
            return;
        }

        WorldPoint playerPos = client.getLocalPlayer().getWorldLocation();
        WorldPoint altarPos = exposedAltar.getWorldLocation();
        BoneShardTrainingState.TrainingState currentState = trainingState.getCurrentTrainingState();

        if (playerPos == null || altarPos == null) {
            cachedPath = null;
            return;
        }

        // Get the closest accessible tile near the altar
        WorldPoint targetPos = getClosestAltarAccessTile(playerPos, altarPos);
        if (targetPos == null) {
            cachedPath = null;
            return;
        }

        // Check if we need to recalculate the path
        boolean needsRecalculation = cachedPath == null ||
                !playerPos.equals(lastPlayerPosition) ||
                !targetPos.equals(lastAltarPosition) ||
                currentState != lastTrainingState;

        if (needsRecalculation) {
            // Find path using pathfinding
            cachedPath = findPath(playerPos, targetPos);
            lastPlayerPosition = playerPos;
            lastAltarPosition = targetPos;
            lastTrainingState = currentState;
        }

        if (cachedPath != null && !cachedPath.isEmpty()) {
            // Draw the cached path
            drawPath(graphics, cachedPath);
        }
    }

    private WorldPoint getClosestAltarAccessTile(WorldPoint playerPos, WorldPoint altarPos) {
        // Define the accessible tiles around the exposed altar in region 5681
        // These are the tiles where players can stand to interact with the altar
        WorldPoint[] accessTiles = {
                convertRegionToWorld(28, 12, altarPos.getPlane()),
                convertRegionToWorld(27, 12, altarPos.getPlane()),
                convertRegionToWorld(31, 9, altarPos.getPlane()),
                convertRegionToWorld(31, 8, altarPos.getPlane())
        };

        WorldPoint closest = null;
        double minDistance = Double.MAX_VALUE;

        for (WorldPoint tile : accessTiles) {
            if (tile != null) {
                double distance = Math.sqrt(
                        Math.pow(playerPos.getX() - tile.getX(), 2) +
                                Math.pow(playerPos.getY() - tile.getY(), 2));

                if (distance < minDistance) {
                    minDistance = distance;
                    closest = tile;
                }
            }
        }

        return closest;
    }

    private WorldPoint convertRegionToWorld(int regionX, int regionY, int plane) {
        // Convert region coordinates to world coordinates
        // Region 5681 base coordinates need to be calculated
        int baseX = (RALOS_REGION_ID >> 8) * 64;
        int baseY = (RALOS_REGION_ID & 0xFF) * 64;

        return new WorldPoint(baseX + regionX, baseY + regionY, plane);
    }

    private TileObject findExposedAltar() {
        for (Map.Entry<TileObject, PrayerObject> entry : plugin.getPrayerObjects().entrySet()) {
            PrayerObject prayerObject = entry.getValue();
            if (prayerObject != null && prayerObject.getObjectId() == EXPOSED_ALTAR_ID) {
                return entry.getKey();
            }
        }
        return null;
    }

    private List<WorldPoint> findPath(WorldPoint start, WorldPoint end) {
        // Simple two-point path for drawing a straight line
        List<WorldPoint> path = new ArrayList<>();
        path.add(start);
        path.add(end);
        return path;
    }

    private void drawPath(Graphics2D graphics, List<WorldPoint> path) {
        if (path.size() < 2) {
            return;
        }

        // Draw a simple geometric line from start to end
        WorldPoint start = path.get(0);
        WorldPoint end = path.get(path.size() - 1);

        LocalPoint startLocal = LocalPoint.fromWorld(client, start);
        LocalPoint endLocal = LocalPoint.fromWorld(client, end);

        if (startLocal != null && endLocal != null) {
            Point startPoint = Perspective.localToCanvas(client, startLocal, start.getPlane());
            Point endPoint = Perspective.localToCanvas(client, endLocal, end.getPlane());

            if (startPoint != null && endPoint != null) {
                // Set up line drawing style
                Color pathColor = config.exposedAltarPathColor();
                graphics.setColor(ColorUtil.colorWithAlpha(pathColor, 200));
                graphics.setStroke(new BasicStroke(3.0f, BasicStroke.CAP_ROUND, BasicStroke.JOIN_ROUND));

                // Draw the straight line
                graphics.drawLine(startPoint.getX(), startPoint.getY(),
                        endPoint.getX(), endPoint.getY());

                // Draw a small circle at the destination
                graphics.setColor(ColorUtil.colorWithAlpha(pathColor, 255));
                graphics.fillOval(endPoint.getX() - 4, endPoint.getY() - 4, 8, 8);
            }
        }
    }

    private void clearPathCache() {
        cachedPath = null;
        lastPlayerPosition = null;
        lastAltarPosition = null;
        lastTrainingState = null;
    }

    private void drawLibationBowlText(Graphics2D graphics, TileObject object, PrayerObject prayerObject) {
        BoneShardTrainingState.TrainingState currentState = trainingState.getCurrentTrainingState();
        String text = null;
        Color textColor;

        // Determine text and color based on training state
        switch (currentState) {
            case BLESS_WINES:
                if (config.toggleOverlayStageName()) {
                    text = currentState.getDisplayName();
                    textColor = config.blessWinesColor();
                } else {
                    return;
                }
                break;
            case RECHARGE_PRAYER:
                if (config.toggleOverlayStageName()) {
                    text = currentState.getDisplayName();
                    textColor = config.rechargePrayerColor();
                } else {
                    return;
                }
                break;
            case SACRIFICE_SHARDS:
                if (config.toggleOverlayActionsLeft()) {
                    int actionsRemaining = trainingState.getActionsRemaining();
                    text = "Actions: " + actionsRemaining;
                    textColor = config.sacrificeShardsColor();
                } else if (config.toggleOverlayStageName()) {
                    text = currentState.getDisplayName();
                    textColor = config.sacrificeShardsColor();
                } else {
                    return;
                }
                break;
            case RESUPPLY:
                if (config.toggleOverlayStageName()) {
                    text = currentState.getDisplayName();
                    textColor = config.resupplyColor();
                } else {
                    return;
                }
                break;
            default:
                if (config.toggleOverlayStageName()) {
                    text = currentState.getDisplayName();
                    textColor = Color.WHITE;
                } else {
                    return;
                }
                break;
        }

        // Get the canvas text location for the object with vertical offset
        int verticalOffset = 100;
        Point pos = Perspective.getCanvasTextLocation(client, graphics, object.getLocalLocation(), text, verticalOffset);
        if (pos == null) {
            return;
        }

        // Render text with custom outline/shadow
        if (config.textOutline()) {
            // Draw outline in 4 directions
            graphics.setColor(Color.BLACK);
            graphics.drawString(text, pos.getX(), pos.getY() + 1);
            graphics.drawString(text, pos.getX(), pos.getY() - 1);
            graphics.drawString(text, pos.getX() + 1, pos.getY());
            graphics.drawString(text, pos.getX() - 1, pos.getY());
        }
        
        // Render main text (with shadow if outline is disabled)
        OverlayUtil.renderTextLocation(graphics, pos, text, textColor);
    }
}
package com.boneshardhelper;

import java.awt.BorderLayout;
import java.awt.Color;
import java.awt.Dimension;
import java.awt.FlowLayout;
import java.awt.GridLayout;
import java.util.Map;
import java.util.regex.Pattern;
import javax.swing.JButton;
import javax.swing.JCheckBox;
import javax.swing.JLabel;
import javax.swing.JPanel;
import javax.swing.JScrollPane;
import javax.swing.JTable;
import javax.swing.JTextField;
import javax.swing.border.EmptyBorder;
import javax.swing.table.DefaultTableModel;
import lombok.Getter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.FontManager;
import net.runelite.client.ui.components.FlatTextField;

@Getter
@Slf4j
class ResourceModePanel extends JPanel {
	private static final Pattern NON_NUMERIC = Pattern.compile("\\D");

	private final JTextField uiFieldCurrentLevel;
	private final JTextField uiFieldCurrentXP;
	private final JCheckBox uiCheckboxSunfireWine;
	private final JCheckBox uiCheckboxZealotRobes;
	private final JButton uiButtonScanResources;

	// Reference to parent panel for resource scanning
	private BoneShardHelperPanel parentPanel;

	// Config reference for debug mode
	private BoneShardHelperConfig config;

	// Debug section (only visible when debug mode is enabled)
	private FoldingSection debugSection;
	private JTextField uiFieldDebugShardOverride;

	// Store the last scanned shard total for debug override functionality
	private int lastScannedShardTotal = 0;

	// Item manager for icons
	private net.runelite.client.game.ItemManager itemManager;
	private JTable referenceTable;
	private final JTable resourceBreakdownTable;
	private final JLabel totalShardsLabel;
	private final JLabel totalXPValueLabel;
	private final JLabel totalWineLabel;
	private final JLabel sunfireSplinterLabel;
	private final JLabel achievableLevelLabel;
	private final JLabel zealotRobesWarningLabel;
	private final JLabel debugStatusLabel;

	ResourceModePanel(BoneShardHelperConfig config) {
		this.config = config;
		setLayout(new BorderLayout());
		setBackground(ColorScheme.DARK_GRAY_COLOR);

		// Create top panel for input fields and controls
		JPanel topPanel = new JPanel(new BorderLayout());
		topPanel.setBackground(ColorScheme.DARK_GRAY_COLOR);
		topPanel.setBorder(new EmptyBorder(5, 5, 5, 5));

		// Create main grid panel with BorderLayout to stack components
		JPanel gridPanel = new JPanel(new BorderLayout());
		gridPanel.setBackground(ColorScheme.DARK_GRAY_COLOR);

		// Create fields panel with 1x2 grid layout for level/XP fields only
		JPanel fieldsPanel = new JPanel(new GridLayout(1, 2, 7, 7));
		fieldsPanel.setBackground(ColorScheme.DARK_GRAY_COLOR);

		// Input fields (shared with Goal Mode)
		uiFieldCurrentLevel = addComponent(fieldsPanel, "Current Level");
		uiFieldCurrentXP = addComponent(fieldsPanel, "Current Experience");

		// Create checkboxes panel with vertical layout
		JPanel checkboxPanel = new JPanel(new GridLayout(2, 1, 0, 5));
		checkboxPanel.setBackground(ColorScheme.DARK_GRAY_COLOR);
		checkboxPanel.setBorder(new EmptyBorder(10, 0, 0, 0)); // Add some top spacing

		// Checkboxes stacked vertically (shared with Goal Mode)
		uiCheckboxSunfireWine = addCheckboxComponent(checkboxPanel, "Sunfire Wine");
		uiCheckboxZealotRobes = addCheckboxComponent(checkboxPanel, "Zealot's Robes");

		// Add tooltips to checkboxes
		uiCheckboxSunfireWine.setToolTipText("+20% prayer XP per blessed bone shard");
		uiCheckboxZealotRobes.setToolTipText("5% chance to save bone resources");

		uiButtonScanResources = createStyledScanButton("Scan Inventory");

		debugStatusLabel = new JLabel("Status: Ready to scan");
		debugStatusLabel.setForeground(Color.YELLOW);
		debugStatusLabel.setFont(FontManager.getRunescapeSmallFont());

		// Create a panel to hold just checkboxes (no button/status)
		JPanel checkboxAndFieldsPanel = new JPanel(new BorderLayout());
		checkboxAndFieldsPanel.setBackground(ColorScheme.DARK_GRAY_COLOR);
		checkboxAndFieldsPanel.add(fieldsPanel, BorderLayout.CENTER);
		checkboxAndFieldsPanel.add(checkboxPanel, BorderLayout.SOUTH);

		// Add panels to grid panel
		gridPanel.add(checkboxAndFieldsPanel, BorderLayout.CENTER);

		// Add grid panel to top panel
		topPanel.add(gridPanel, BorderLayout.CENTER);

		// Create collapsible reference table section
		FoldingSection collapsibleReferenceSection = createCollapsibleReferenceSection();

		// Create resource breakdown table (initially empty)
		resourceBreakdownTable = createResourceBreakdownTable();
		JScrollPane breakdownScrollPane = new JScrollPane(resourceBreakdownTable);
		breakdownScrollPane.setPreferredSize(new Dimension(0, 100));
		breakdownScrollPane.setBorder(new EmptyBorder(5, 5, 5, 5));

		// Initialize calculation result labels
		totalShardsLabel = new JLabel("Scan inventory to see results");
		totalXPValueLabel = new JLabel("Scan inventory to see results");
		totalWineLabel = new JLabel("Scan inventory to see results");
		sunfireSplinterLabel = new JLabel("Scan inventory to see results");
		achievableLevelLabel = new JLabel("Scan inventory to see results");

		// Create Goal Mode-style results section
		FoldingSection resultsSection = createCalculationResultsSection();

		// Create warning panel below the results section
		JPanel warningPanel = new JPanel(new BorderLayout());
		warningPanel.setBackground(ColorScheme.DARK_GRAY_COLOR);
		warningPanel.setBorder(new EmptyBorder(5, 5, 5, 5));

		zealotRobesWarningLabel = new JLabel("<html>&nbsp;</html>");
		zealotRobesWarningLabel.setForeground(Color.ORANGE);
		zealotRobesWarningLabel.setFont(FontManager.getRunescapeSmallFont());
		// Allow natural height for proper text wrapping

		warningPanel.add(zealotRobesWarningLabel, BorderLayout.CENTER);

		// Combine results section and warning panel
		JPanel resultsAndWarningPanel = new JPanel(new BorderLayout());
		resultsAndWarningPanel.setBackground(ColorScheme.DARK_GRAY_COLOR);
		resultsAndWarningPanel.add(resultsSection, BorderLayout.NORTH);
		resultsAndWarningPanel.add(warningPanel, BorderLayout.CENTER);

		// Create inventory resources folding section
		FoldingSection inventoryResourcesSection = createInventoryResourcesSection(breakdownScrollPane);

		// Since we only have the inventory resources section now, use it directly
		JPanel tablesPanel = inventoryResourcesSection;

		// Create scan button panel (centered, with spacing)
		JPanel scanButtonPanel = new JPanel(new FlowLayout(FlowLayout.CENTER));
		scanButtonPanel.setBackground(ColorScheme.DARK_GRAY_COLOR);
		scanButtonPanel.setBorder(new EmptyBorder(10, 0, 5, 0)); // Top and bottom spacing
		scanButtonPanel.add(uiButtonScanResources);

		// Create status panel (centered, below button)
		JPanel statusPanel = new JPanel(new FlowLayout(FlowLayout.CENTER));
		statusPanel.setBackground(ColorScheme.DARK_GRAY_COLOR);
		statusPanel.setBorder(new EmptyBorder(0, 0, 5, 0)); // Bottom spacing
		statusPanel.add(debugStatusLabel);

		// Create combined button and status panel
		JPanel buttonAndStatusPanel = new JPanel(new BorderLayout());
		buttonAndStatusPanel.setBackground(ColorScheme.DARK_GRAY_COLOR);
		buttonAndStatusPanel.add(scanButtonPanel, BorderLayout.NORTH);
		buttonAndStatusPanel.add(statusPanel, BorderLayout.CENTER);

		// Create middle section with button/status and tables
		JPanel middleSection = new JPanel(new BorderLayout());
		middleSection.setBackground(ColorScheme.DARK_GRAY_COLOR);
		middleSection.add(buttonAndStatusPanel, BorderLayout.NORTH);
		middleSection.add(tablesPanel, BorderLayout.CENTER);

		// Create debug section (only if debug mode is enabled)
		debugSection = null;
		if (config.debugMode()) {
			debugSection = createDebugSection();
		}

		// Create bottom panel for reference section and optional debug section
		JPanel bottomPanel = new JPanel(new BorderLayout());
		bottomPanel.setBackground(ColorScheme.DARK_GRAY_COLOR);
		bottomPanel.add(collapsibleReferenceSection, BorderLayout.NORTH);

		if (debugSection != null) {
			bottomPanel.add(debugSection, BorderLayout.CENTER);
		}

		JPanel centerPanel = new JPanel(new BorderLayout());
		centerPanel.setBackground(ColorScheme.DARK_GRAY_COLOR);
		centerPanel.add(resultsAndWarningPanel, BorderLayout.NORTH);
		centerPanel.add(middleSection, BorderLayout.CENTER);
		centerPanel.add(bottomPanel, BorderLayout.SOUTH);

		add(topPanel, BorderLayout.NORTH);
		add(centerPanel, BorderLayout.CENTER);
	}

	int getCurrentLevelInput() {
		return getInput(uiFieldCurrentLevel);
	}

	void setCurrentLevelInput(int value) {
		setInput(uiFieldCurrentLevel, value);
	}

	int getCurrentXPInput() {
		return getInput(uiFieldCurrentXP);
	}

	void setCurrentXPInput(Object value) {
		setInput(uiFieldCurrentXP, value);
	}

	boolean isSunfireWineSelected() {
		return uiCheckboxSunfireWine.isSelected();
	}

	void setSunfireWineSelected(boolean selected) {
		uiCheckboxSunfireWine.setSelected(selected);
	}

	boolean isZealotRobesSelected() {
		return uiCheckboxZealotRobes.isSelected();
	}

	void setZealotRobesSelected(boolean selected) {
		uiCheckboxZealotRobes.setSelected(selected);
	}

	// Getter methods for checkboxes (needed for action listener setup)
	JCheckBox getUiCheckboxSunfireWine() {
		return uiCheckboxSunfireWine;
	}

	JCheckBox getUiCheckboxZealotRobes() {
		return uiCheckboxZealotRobes;
	}

	// Getter methods for UI fields (needed for BoneShardHelperPanel)
	JTextField getUiFieldCurrentLevel() {
		return uiFieldCurrentLevel;
	}

	JTextField getUiFieldCurrentXP() {
		return uiFieldCurrentXP;
	}

	JButton getUiButtonScanResources() {
		return uiButtonScanResources;
	}

	JTable getResourceBreakdownTable() {
		return resourceBreakdownTable;
	}

	// Debug field getter methods (only available when debug mode is enabled)
	JTextField getUiFieldDebugShardOverride() {
		return uiFieldDebugShardOverride;
	}

	FoldingSection getDebugSection() {
		return debugSection;
	}

	int getDebugShardOverrideInput() {
		if (uiFieldDebugShardOverride == null) {
			return 0;
		}
		return getInput(uiFieldDebugShardOverride);
	}

	void setDebugShardOverrideInput(Object value) {
		if (uiFieldDebugShardOverride != null) {
			setInput(uiFieldDebugShardOverride, value);
		}
	}

	boolean isDebugModeEnabled() {
		return config != null && config.debugMode();
	}

	public int getEffectiveTotalShards(int scannedTotalShards) {
		// If debug mode is enabled and debug override field has a non-zero value, use that
		if (isDebugModeEnabled() && uiFieldDebugShardOverride != null) {
			int debugOverride = getDebugShardOverrideInput();
			if (debugOverride > 0) {
				return debugOverride;
			}
		}
		return scannedTotalShards;
	}

	public void triggerDebugRecalculation() {
		// Get the effective shards (debug override if available, otherwise last scanned total)
		int currentXP = getCurrentXPInput();
		boolean useSunfireWine = isSunfireWineSelected();

		int effectiveShards = getEffectiveTotalShards(lastScannedShardTotal);
		updateAchievableLevel(effectiveShards, currentXP, useSunfireWine);

		updateTotalShardsLabel();
	}

	private void updateTotalShardsLabel() {
		try {
			int effectiveShards = getEffectiveTotalShards(lastScannedShardTotal);

			// Show different text based on whether debug override is active
			if (isDebugModeEnabled() && uiFieldDebugShardOverride != null && getDebugShardOverrideInput() > 0) {
				totalShardsLabel.setText(String.format("%,d shard value (DEBUG OVERRIDE)", effectiveShards));
			} else {
				// If no debug override, show the last scanned value or prompt to scan
				if (resourceBreakdownTable.getRowCount() > 0 || lastScannedShardTotal > 0) {
					totalShardsLabel.setText(String.format("%,d shard value in inventory", effectiveShards));
				} else {
					totalShardsLabel.setText("Scan inventory to see results");
				}
			}
		} catch (Exception e) {
			totalShardsLabel.setText("Calculation error");
		}
	}

	public void clearDebugOverride() {
		// Clear the debug shard override value and trigger recalculation.
		// Reverts to using scanned inventory values.
		if (uiFieldDebugShardOverride != null) {
			uiFieldDebugShardOverride.setText("");
			triggerDebugRecalculation();
		}
	}

	private static int getInput(JTextField field) {
		try {
			return Integer.parseInt(NON_NUMERIC.matcher(field.getText()).replaceAll(""));
		} catch (NumberFormatException e) {
			return 0;
		}
	}

	private static void setInput(JTextField field, Object value) {
		field.setText(String.valueOf(value));
	}

	private JTextField addComponent(JPanel parent, String label) {
		final JPanel container = new JPanel();
		container.setLayout(new BorderLayout());
		container.setBackground(ColorScheme.DARK_GRAY_COLOR);

		final JLabel uiLabel = new JLabel(label);
		final FlatTextField uiInput = new FlatTextField();

		uiInput.setBackground(ColorScheme.DARKER_GRAY_COLOR);
		uiInput.setHoverBackgroundColor(ColorScheme.DARK_GRAY_HOVER_COLOR);
		uiInput.setBorder(new EmptyBorder(5, 7, 5, 7));

		uiLabel.setFont(FontManager.getRunescapeSmallFont());
		uiLabel.setBorder(new EmptyBorder(0, 0, 4, 0));
		uiLabel.setForeground(Color.WHITE);

		container.add(uiLabel, BorderLayout.NORTH);
		container.add(uiInput, BorderLayout.CENTER);

		parent.add(container);

		return uiInput.getTextField();
	}

	private JCheckBox addCheckboxComponent(JPanel parent, String label) {
		final JPanel container = new JPanel();
		container.setLayout(new BorderLayout());
		container.setBackground(ColorScheme.DARK_GRAY_COLOR);

		final JCheckBox checkbox = new JCheckBox(label);
		checkbox.setBackground(ColorScheme.DARK_GRAY_COLOR);
		checkbox.setForeground(Color.WHITE);
		checkbox.setFont(FontManager.getRunescapeSmallFont());
		checkbox.setBorder(new EmptyBorder(5, 7, 5, 7));

		container.add(checkbox, BorderLayout.CENTER);
		parent.add(container);

		return checkbox;
	}

	private static JButton createStyledScanButton(String buttonText) {
		JButton button = new JButton(buttonText);
		button.setBackground(ColorScheme.DARKER_GRAY_COLOR);
		button.setForeground(Color.WHITE);
		button.setFont(FontManager.getRunescapeSmallFont());
		button.setBorder(new EmptyBorder(5, 10, 5, 10));
		button.setCursor(new java.awt.Cursor(java.awt.Cursor.HAND_CURSOR));

		// Add hover effect for better UX
		button.addMouseListener(new java.awt.event.MouseAdapter() {
			@Override
			public void mouseEntered(java.awt.event.MouseEvent e) {
				button.setBackground(ColorScheme.DARK_GRAY_HOVER_COLOR);
			}

			@Override
			public void mouseExited(java.awt.event.MouseEvent e) {
				button.setBackground(ColorScheme.DARKER_GRAY_COLOR);
			}
		});

		return button;
	}

	private FoldingSection createCalculationResultsSection() {
		// Creates a calculation results section with labels for total shards, XP, wine,
		// 		and achievable level enclosed in a FoldingSection.

		// Initialize the labels
		totalShardsLabel.setText("Scan inventory to see results");
		totalShardsLabel.setForeground(Color.WHITE);
		totalShardsLabel.setFont(FontManager.getRunescapeSmallFont());

		totalXPValueLabel.setText("Scan inventory to see results");
		totalXPValueLabel.setForeground(Color.WHITE);
		totalXPValueLabel.setFont(FontManager.getRunescapeSmallFont());

		totalWineLabel.setText("Scan inventory to see results");
		totalWineLabel.setForeground(Color.WHITE);
		totalWineLabel.setFont(FontManager.getRunescapeSmallFont());

		sunfireSplinterLabel.setText("Scan inventory to see results");
		sunfireSplinterLabel.setForeground(Color.WHITE);
		sunfireSplinterLabel.setFont(FontManager.getRunescapeSmallFont());
		sunfireSplinterLabel.setVisible(false); // Hide initially - only show when sunfire wine is selected and results are calculated

		achievableLevelLabel.setText("Scan inventory to see results");
		achievableLevelLabel.setForeground(Color.WHITE);
		achievableLevelLabel.setFont(FontManager.getRunescapeSmallFont());

		// Create a panel that handles visibility and aligns text properly
		JPanel labelsPanel = new JPanel();
		labelsPanel.setLayout(new javax.swing.BoxLayout(labelsPanel, javax.swing.BoxLayout.Y_AXIS));
		labelsPanel.setBackground(ColorScheme.DARK_GRAY_COLOR);

		// Add labels with small borders for spacing instead of struts
		totalShardsLabel.setBorder(new EmptyBorder(1, 0, 1, 0));
		totalXPValueLabel.setBorder(new EmptyBorder(1, 0, 1, 0));
		totalWineLabel.setBorder(new EmptyBorder(1, 0, 1, 0));
		sunfireSplinterLabel.setBorder(new EmptyBorder(1, 0, 1, 0));
		achievableLevelLabel.setBorder(new EmptyBorder(1, 0, 1, 0));

		labelsPanel.add(totalShardsLabel);
		labelsPanel.add(totalXPValueLabel);
		labelsPanel.add(totalWineLabel);
		labelsPanel.add(sunfireSplinterLabel);
		labelsPanel.add(achievableLevelLabel);

		// Create the folding section
		FoldingSection section = new FoldingSection(
				"Calculation Results",
				"Summary of your inventory's shard value and achievable prayer level",
				labelsPanel);

		// Set to expanded by default
		section.setOpen(true);

		return section;
	}

	private JTable createReferenceTable() {
		String[] columnNames = { "Bone Type", "Shards" };
		DefaultTableModel model = new DefaultTableModel(columnNames, 0) {
			@Override
			public boolean isCellEditable(int row, int column) {
				return false; // Make table read-only
			}
		};

		java.util.List<BoneType> boneTypesList = new java.util.ArrayList<>();

		java.util.Set<BoneType> processedTypes = new java.util.HashSet<>();

		for (BoneType boneType : BoneType.values()) {
			// Skip bone shards themselves
			if (boneType == BoneType.BLESSED_BONE_SHARDS) {
				continue;
			}

			// Get the consolidated bone type
			BoneType consolidatedType = getConsolidatedBoneType(boneType);

			// Skip if we've already processed this consolidated type (necessary in some conditions)
			if (processedTypes.contains(consolidatedType)) {
				continue;
			}

			processedTypes.add(consolidatedType);
			boneTypesList.add(consolidatedType);

			model.addRow(new Object[] { consolidatedType.getDisplayName(), consolidatedType.getShardValue() });
		}

		JTable table = new JTable(model);
		table.setBackground(ColorScheme.DARKER_GRAY_COLOR);
		table.setForeground(Color.WHITE);
		table.setFont(FontManager.getRunescapeSmallFont());
		table.setGridColor(ColorScheme.DARK_GRAY_COLOR);
		table.setSelectionBackground(ColorScheme.DARK_GRAY_HOVER_COLOR);
		table.setSelectionForeground(Color.WHITE);
		table.getTableHeader().setBackground(ColorScheme.DARKER_GRAY_COLOR);
		table.getTableHeader().setForeground(Color.WHITE);
		table.getTableHeader().setFont(FontManager.getRunescapeSmallFont());

		// Set custom cell renderer for the first column (Bone Type) to display icons
		table.getColumnModel().getColumn(0).setCellRenderer(new BoneTypeIconRenderer(boneTypesList));

		// Set fixed row height to prevent stretching from icons
		table.setRowHeight(20); // Consistent with other tables

		// Configure column widths and alignment (80% / 20%)
		setupReferenceTableColumns(table);

		return table;
	}

	private FoldingSection createInventoryResourcesSection(JScrollPane breakdownScrollPane) {
		// Creates the inventory resources folding section.
		// Create the content components
		JPanel content = createInventoryResourcesContent(breakdownScrollPane);

		// Create the folding section with the content
		FoldingSection section = new FoldingSection(
				"Inventory Resources",
				"Breakdown of bone types and their shard values found in your inventory",
				content);

		// Set to expanded by default
		section.setOpen(true);

		return section;
	}

	private JPanel createInventoryResourcesContent(JScrollPane breakdownScrollPane) {
		// Creates the content for the Inventory Resources section.
		JPanel content = new JPanel(new BorderLayout());
		content.setBackground(ColorScheme.DARK_GRAY_COLOR);
		content.setBorder(new EmptyBorder(5, 10, 5, 5)); // Indent content

		content.add(breakdownScrollPane, BorderLayout.CENTER);

		return content;
	}

	private JTable createResourceBreakdownTable() {
		String[] columnNames = { "Qty", "Bone Type", "# Shards" };
		DefaultTableModel model = new DefaultTableModel(columnNames, 0) {
			@Override
			public boolean isCellEditable(int row, int column) {
				return false; // Make table read-only
			}
		};

		JTable table = new JTable(model);
		table.setBackground(ColorScheme.DARKER_GRAY_COLOR);
		table.setForeground(Color.WHITE);
		table.setFont(FontManager.getRunescapeSmallFont());
		table.setGridColor(ColorScheme.DARK_GRAY_COLOR);
		table.setSelectionBackground(ColorScheme.DARK_GRAY_HOVER_COLOR);
		table.setSelectionForeground(Color.WHITE);
		table.getTableHeader().setBackground(ColorScheme.DARKER_GRAY_COLOR);
		table.getTableHeader().setForeground(Color.WHITE);
		table.getTableHeader().setFont(FontManager.getRunescapeSmallFont());

		javax.swing.table.DefaultTableCellRenderer rightRenderer = new javax.swing.table.DefaultTableCellRenderer();
		rightRenderer.setHorizontalAlignment(javax.swing.SwingConstants.RIGHT);
		rightRenderer.setBackground(ColorScheme.DARKER_GRAY_COLOR);
		rightRenderer.setForeground(Color.WHITE);
		rightRenderer.setFont(FontManager.getRunescapeSmallFont());
		table.getColumnModel().getColumn(2).setCellRenderer(rightRenderer);

		table.getColumnModel().getColumn(1).setCellRenderer(new ResourceBreakdownIconRenderer());

		setupResourceBreakdownTableColumns(table);

		return table;
	}

	private void setupResourceBreakdownTableColumns(JTable table) {
		// Configures column widths and alignment for the resource breakdown table.
		table.getColumnModel().getColumn(0).setPreferredWidth(45); // Qty - 15%
		table.getColumnModel().getColumn(1).setPreferredWidth(180); // Bone Type - 60% (widest)
		table.getColumnModel().getColumn(2).setPreferredWidth(75); // Shard Value - 25%

		table.getColumnModel().getColumn(0).setMinWidth(35); // Qty minimum
		table.getColumnModel().getColumn(1).setMinWidth(100); // Bone Type minimum
		table.getColumnModel().getColumn(2).setMinWidth(55); // Shard Value minimum

		table.getColumnModel().getColumn(0).setMaxWidth(60);
	}

	public void updateResourceBreakdown(Map<BoneType, Integer> boneResources) {
		// Updates the resource breakdown table with scanned bone resources.
		try {
			if (boneResources == null) {
				updateDebugError("Bone resources data is null");
				return;
			}

			DefaultTableModel model = (DefaultTableModel) resourceBreakdownTable.getModel();
			model.setRowCount(0); // Clear existing data

			long totalShardsLong = 0;
			int validEntries = 0;

			for (Map.Entry<BoneType, Integer> entry : boneResources.entrySet()) {
				try {
					BoneType boneType = entry.getKey();
					Integer quantityObj = entry.getValue();

					if (boneType == null || quantityObj == null) {
						continue; // Skip invalid entries
					}

					int quantity = quantityObj;
					if (quantity <= 0) {
						continue; // Skip zero or negative quantities
					}

					// Calculate shard value with overflow protection
					long shardValueLong = (long) boneType.getShardValue() * quantity;
					if (shardValueLong > Integer.MAX_VALUE) {
						updateDebugError("Shard calculation overflow for " + boneType.getDisplayName());
						continue;
					}

					int shardValue = (int) shardValueLong;

					// Check for total overflow before adding
					if (totalShardsLong > Long.MAX_VALUE - shardValue) {
						updateDebugError("Total shards calculation overflow");
						break;
					}

					totalShardsLong += shardValue;
					validEntries++;

					model.addRow(new Object[] {
							String.format("%,d", quantity),
							boneType.getDisplayName(),
							String.format("%,d", shardValue)
					});

				} catch (Exception e) {
					// Skip this entry and continue with others
					log.error("Prayer Calculator: Error processing bone entry", e);
				}
			}

			// Update total shards label with bounds checking
			if (totalShardsLong > Integer.MAX_VALUE) {
				totalShardsLabel.setText("Too many shards");
				updateDebugError("Total shards exceed maximum calculable amount");
			} else {
				int scannedShards = (int) totalShardsLong;

				// Store the scanned total for debug override functionality
				lastScannedShardTotal = scannedShards;

				int effectiveShards = getEffectiveTotalShards(scannedShards);

				// Show different text based on whether debug override is active
				if (isDebugModeEnabled() && uiFieldDebugShardOverride != null && getDebugShardOverrideInput() > 0) {
					totalShardsLabel.setText(String.format("%,d shard value (DEBUG OVERRIDE)", effectiveShards));
				} else {
					totalShardsLabel.setText(String.format("%,d shard value in inventory", effectiveShards));
				}

				if (validEntries == 0 && effectiveShards == 0) {
					updateDebugStatus("No valid bone resources found");
				}
			}

		} catch (Exception e) {
			log.error("Prayer Calculator: Error updating resource breakdown", e);
			updateDebugError("Error updating resource breakdown: " + e.getMessage());
			totalShardsLabel.setText("Calculation error");
		}
	}

	public void updateAchievableLevel(int totalShards, int currentXP, boolean useSunfireWine) {
		// Updates the achievable level display based on available shards and wine type.
		try {
			// Validate inputs
			if (totalShards < 0) {
				updateDebugError("Invalid shard count: " + totalShards);
				return;
			}

			if (currentXP < 0) {
				updateDebugError("Invalid current XP: " + currentXP);
				return;
			}

			// Calculate XP per shard including zealot robes multiplier
			boolean useZealotRobes = isZealotRobesSelected();
			double baseXpPerShard = useSunfireWine ? 6.0 : 5.0;
			double xpPerShard = useZealotRobes ? baseXpPerShard * 1.05 : baseXpPerShard;

			// Calculate total XP gain with overflow protection
			long totalXPGainLong = (long) Math.round(totalShards * xpPerShard);
			if (totalXPGainLong > Integer.MAX_VALUE) {
				updateDebugError("XP calculation overflow - too many shards");
				totalXPValueLabel.setText("Calculation overflow");
				achievableLevelLabel.setText("Too many shards");
				return;
			}

			int totalXPGain = (int) totalXPGainLong;

			// Calculate final XP with overflow protection
			long finalXPLong = (long) currentXP + totalXPGain;
			if (finalXPLong > Integer.MAX_VALUE) {
				updateDebugError("Final XP calculation overflow");
				totalXPValueLabel.setText("Calculation overflow");
				achievableLevelLabel.setText("XP overflow");
				return;
			}

			int finalXP = (int) finalXPLong;

			int achievableLevel;
			try {
				achievableLevel = net.runelite.api.Experience.getLevelForXp(finalXP);

				// Validate the result
				if (achievableLevel < 1 || achievableLevel > 126) {
					updateDebugError("Calculated level out of bounds: " + achievableLevel);
					achievableLevel = Math.max(1, Math.min(126, achievableLevel));
				}
			} catch (Exception e) {
				updateDebugError("Error calculating level from XP: " + e.getMessage());
				achievableLevel = net.runelite.api.Experience.getLevelForXp(currentXP); // Fallback to current level
			}

			// Update displays with improved format
			String wineType = useSunfireWine ? "sunfire" : "regular";
			String robesText = useZealotRobes ? ", zealot's robes" : "";
			totalXPValueLabel.setText(String.format("%,d XP (%s wine%s)",
					totalXPGain, wineType, robesText));

			// Calculate wine requirements using existing calculation engine (400 shards per wine)
			PrayerCalculationEngine calculationEngine = new PrayerCalculationEngine();
			int winesNeeded = calculationEngine.calculateWinesNeeded(totalShards);
			String wineTypeCapitalized = useSunfireWine ? "Sunfire wine" : "Regular wine";
			totalWineLabel.setText(String.format("%,d %s", winesNeeded, wineTypeCapitalized.toLowerCase()));

			// Update wine icon based on current wine type
			if (itemManager != null) {
				try {
					int wineItemId = useSunfireWine ? 29384 : 1993; // Sunfire wine or regular wine
					totalWineLabel.setIcon(null);
					itemManager.getImage(wineItemId).addTo(totalWineLabel);
				} catch (Exception e) {
					log.error("Error loading wine icon", e);
				}
			}

			if (useSunfireWine) {
				int splintersNeeded = winesNeeded * 2;

				if (itemManager != null) {
					try {
						sunfireSplinterLabel.setIcon(null);
						itemManager.getImage(28924, 10, false).addTo(sunfireSplinterLabel);
					} catch (Exception e) {
						log.error("Error loading sunfire splinter icon", e);
					}
				}

				String splintersText = String.format("%,d sunfire splinters for wines", splintersNeeded);
				sunfireSplinterLabel.setText(splintersText);
				sunfireSplinterLabel.setVisible(true);
			} else {
				sunfireSplinterLabel.setVisible(false);
			}

			// Calculate level gain and format with color
			int currentLevel = net.runelite.api.Experience.getLevelForXp(currentXP);
			int levelGain = achievableLevel - currentLevel;

			String levelGainText;
			if (levelGain <= 0) {
				levelGainText = "(+0)";
			} else {
				levelGainText = String.format("<font color='#00FF00'>(+%d)</font>", levelGain);
			}

			achievableLevelLabel.setText(String.format("<html>Ending Level: %d %s</html>",
					achievableLevel, levelGainText));

			// Update zealot robes warning
			updateZealotRobesWarning();

		} catch (Exception e) {
			log.error("Prayer Calculator: Error updating achievable level", e);
			updateDebugError("Calculation error: " + e.getMessage());
			totalXPValueLabel.setText("Calculation error");
			achievableLevelLabel.setText("Calculation error");
		}
	}

	private void updateZealotRobesWarning() {
		if (isZealotRobesSelected()) {
			zealotRobesWarningLabel.setText(
					"<html>!! Zealot's robes: Actual XP values may vary slightly due to resource-save triggers.</html>");
		} else {
			zealotRobesWarningLabel.setText("<html>&nbsp;</html>"); // Non-breaking space maintains height
		}
	}

	public void updateZealotRobesWarningDisplay() {
		updateZealotRobesWarning();
	}

	public void updateDebugStatus(String status) {
		debugStatusLabel.setText("Status: " + status);
		debugStatusLabel.setForeground(Color.YELLOW);
	}

	public void updateDebugError(String error) {
		// Updates the debug status label with an error message if needed.
		debugStatusLabel.setText("Error: " + error);
		debugStatusLabel.setForeground(Color.RED);
	}

	public void updateDebugSuccess(String success) {
		debugStatusLabel.setText("Success: " + success);
		debugStatusLabel.setForeground(Color.GREEN);
	}

	public void clearResourceBreakdown() {
		// Clears the resource breakdown table and resets labels.
		DefaultTableModel model = (DefaultTableModel) resourceBreakdownTable.getModel();
		model.setRowCount(0);

		// Reset the stored scanned total
		lastScannedShardTotal = 0;

		totalShardsLabel.setText("Scan inventory to see results");
		totalXPValueLabel.setText("Scan inventory to see results");
		totalWineLabel.setText("Scan inventory to see results");
		sunfireSplinterLabel.setText("Scan inventory to see results");
		sunfireSplinterLabel.setVisible(false); // Hide splinter label when clearing
		achievableLevelLabel.setText("Scan inventory to see results");
		zealotRobesWarningLabel.setText("<html>&nbsp;</html>"); // Clear warning

		// Clear icons
		totalShardsLabel.setIcon(null);
		totalXPValueLabel.setIcon(null);
		totalWineLabel.setIcon(null);
		sunfireSplinterLabel.setIcon(null);
		achievableLevelLabel.setIcon(null);
	}

	public void updateCalculations() {
		// Use the existing recalculateWithCurrentSettings method which properly handles
		// debug override
		recalculateWithCurrentSettings();
	}

	public void setItemManager(net.runelite.client.game.ItemManager itemManager) {
		this.itemManager = itemManager;

		if (itemManager != null) {
			loadStaticIcons();
		}
	}

	public void recalculateWithCurrentSettings() {
		// Only recalculate if we have existing data (breakdown table has rows) or debug override is active
		if (resourceBreakdownTable.getRowCount() == 0 &&
				!(isDebugModeEnabled() && uiFieldDebugShardOverride != null && getDebugShardOverrideInput() > 0)) {
			return;
		}

		try {
			// Calculate total shards from the breakdown table (if any)
			int scannedShards = 0;
			if (resourceBreakdownTable.getRowCount() > 0) {
				DefaultTableModel model = (DefaultTableModel) resourceBreakdownTable.getModel();

				for (int i = 0; i < model.getRowCount(); i++) {
					String shardValueStr = (String) model.getValueAt(i, 2); // Shard # column
					// Remove commas and parse
					int shardValue = Integer.parseInt(shardValueStr.replaceAll(",", ""));
					scannedShards += shardValue;
				}
			} else {
				// Use the stored last scanned total if no table data
				scannedShards = lastScannedShardTotal;
			}

			// Get current settings
			int currentXP = getCurrentXPInput();
			boolean useSunfireWine = isSunfireWineSelected();

			// Use effective shards (respects debug override)
			int effectiveShards = getEffectiveTotalShards(scannedShards);
			updateAchievableLevel(effectiveShards, currentXP, useSunfireWine);

			// Also update the total shards label to reflect any debug override
			updateTotalShardsLabel();

		} catch (Exception e) {
			log.error("Prayer Calculator: Error recalculating with current settings", e);
			updateDebugError("Error recalculating: " + e.getMessage());
		}
	}

	public void setParentPanel(BoneShardHelperPanel parentPanel) {
		this.parentPanel = parentPanel;
	}

	private void loadStaticIcons() {
		if (itemManager == null) {
			return;
		}

		try {
			// Load blessed bone shards icon immediately (item ID: 29381)
			totalShardsLabel.setIcon(null);
			itemManager.getImage(29381).addTo(totalShardsLabel);

			// Load overall skill icon from resources (for XP label) - scale to match item icons
			java.awt.image.BufferedImage overallIcon = net.runelite.client.util.ImageUtil
					.loadImageResource(getClass(), "/skill_icons/overall.png");
			if (overallIcon != null) {
				// Scale to 32x32 to match ItemManager icon size
				java.awt.Image scaledOverallIcon = overallIcon.getScaledInstance(32, 32, java.awt.Image.SCALE_SMOOTH);
				totalXPValueLabel.setIcon(new javax.swing.ImageIcon(scaledOverallIcon));
			}

			// Load wine icon based on current wine type (default to regular wine initially)
			boolean useSunfireWine = isSunfireWineSelected();
			int wineItemId = useSunfireWine ? 29384 : 1993; // Sunfire wine or regular wine
			totalWineLabel.setIcon(null);
			itemManager.getImage(wineItemId).addTo(totalWineLabel);

			// Load splinter icon if sunfire wine is selected and results are displayed
			if (useSunfireWine && !sunfireSplinterLabel.getText().equals("Scan inventory to see results")) {
				try {
					sunfireSplinterLabel.setIcon(null);
					itemManager.getImage(28924, 10, false).addTo(sunfireSplinterLabel);
				} catch (Exception e) {
					log.error("Error loading sunfire splinter icon", e);
				}
			}

			// Load prayer skill icon from resources (for level label) - scale to match item icons
			java.awt.image.BufferedImage prayerIcon = net.runelite.client.util.ImageUtil
					.loadImageResource(getClass(), "/skill_icons/prayer.png");
			if (prayerIcon != null) {
				// Scale to 32x32 to match ItemManager icon size
				java.awt.Image scaledPrayerIcon = prayerIcon.getScaledInstance(32, 32, java.awt.Image.SCALE_SMOOTH);
				achievableLevelLabel.setIcon(new javax.swing.ImageIcon(scaledPrayerIcon));
			}
		} catch (Exception e) {
			log.error("Error loading static icons", e);
		}
	}

	private FoldingSection createCollapsibleReferenceSection() {
		// Create reference table first
		referenceTable = createReferenceTable();

		// Create content panel for the reference table
		JPanel content = new JPanel(new BorderLayout());
		content.setBackground(ColorScheme.DARK_GRAY_COLOR);
		content.setBorder(new EmptyBorder(5, 10, 5, 5)); // Indent content

		// Add descriptive text above the table
		JLabel descriptionLabel = new JLabel(
				"<html>This table shows how many blessed bone shards you get by breaking down various types of bones.</html>");
		descriptionLabel.setForeground(Color.LIGHT_GRAY);
		descriptionLabel.setFont(FontManager.getRunescapeSmallFont());
		descriptionLabel.setBorder(new EmptyBorder(0, 0, 8, 0)); // Add some spacing below the text

		// Create scroll pane for the reference table
		JScrollPane referenceScrollPane = new JScrollPane(referenceTable);
		referenceScrollPane.setBorder(new EmptyBorder(0, 0, 0, 0));

		// Add components to content panel
		content.add(descriptionLabel, BorderLayout.NORTH);
		content.add(referenceScrollPane, BorderLayout.CENTER);

		// Create the folding section with the content
		FoldingSection section = new FoldingSection(
				"Bone Shard Sources",
				"Reference table showing how many blessed bone shards each bone type provides after being broken down",
				content);

		// Set to collapsed by default (matching old behavior)
		section.setOpen(false);

		return section;
	}

	private FoldingSection createDebugSection() {
		// Create content panel for the debug section
		JPanel content = new JPanel(new BorderLayout());
		content.setBackground(ColorScheme.DARK_GRAY_COLOR);
		content.setBorder(new EmptyBorder(5, 10, 5, 5)); // Indent content

		// Add descriptive text (same style as Bone Shard Sources description)
		JLabel descriptionLabel = new JLabel(
				"<html>Override the scanned bone shard value in inventory</html>");
		descriptionLabel.setForeground(Color.LIGHT_GRAY);
		descriptionLabel.setFont(FontManager.getRunescapeSmallFont());
		descriptionLabel.setBorder(new EmptyBorder(0, 0, 8, 0)); // Add some spacing below the text

		// Create the debug input field using the same style as other input fields
		JPanel inputPanel = new JPanel(new BorderLayout());
		inputPanel.setBackground(ColorScheme.DARK_GRAY_COLOR);
		inputPanel.setBorder(new EmptyBorder(8, 0, 0, 0)); // Add spacing above the input field

		uiFieldDebugShardOverride = addComponent(inputPanel, "Bone Shard Override");

		// Add event listeners to trigger recalculation when debug value changes
		uiFieldDebugShardOverride.addActionListener(e -> triggerDebugRecalculation());
		uiFieldDebugShardOverride.addFocusListener(new java.awt.event.FocusAdapter() {
			@Override
			public void focusLost(java.awt.event.FocusEvent e) {
				triggerDebugRecalculation();
			}
		});

		// Create a container panel to hold both description and input
		JPanel containerPanel = new JPanel(new BorderLayout());
		containerPanel.setBackground(ColorScheme.DARK_GRAY_COLOR);
		containerPanel.add(descriptionLabel, BorderLayout.NORTH);
		containerPanel.add(inputPanel, BorderLayout.CENTER);

		// Add the container to content panel
		content.add(containerPanel, BorderLayout.NORTH);

		// Create the folding section with the content
		FoldingSection section = new FoldingSection(
				"DEBUG: CUSTOM SHARD AMOUNT",
				"Override the scanned bone shard value in inventory for testing purposes",
				content);

		// Set to collapsed by default
		section.setOpen(false);

		return section;
	}

	public void updateDebugSectionVisibility() {
		// Get the bottom panel that contains the reference section and debug section
		JPanel centerPanel = (JPanel) getComponent(1); // The center panel from constructor
		JPanel bottomPanel = (JPanel) centerPanel.getComponent(2); // The bottom panel from constructor

		boolean debugModeEnabled = config.debugMode();

		if (debugModeEnabled && debugSection == null) {
			// Debug mode was enabled - create and add the debug section
			debugSection = createDebugSection();
			bottomPanel.add(debugSection, BorderLayout.CENTER);
		} else if (!debugModeEnabled && debugSection != null) {
			// Debug mode was disabled - remove the debug section
			bottomPanel.remove(debugSection);
			debugSection = null;
			uiFieldDebugShardOverride = null;
		}

		// Refresh the layout
		bottomPanel.revalidate();
		bottomPanel.repaint();

		// If debug mode was disabled and we had a debug override active, trigger recalculation
		if (!debugModeEnabled) {
			triggerDebugRecalculation();
		}
	}

	private int getBoneItemId(BoneType boneType) {
		// Map blessed bone types to their unblessed item IDs for icon display
		switch (boneType) {
			case BLESSED_BONES:
				return 526; // Regular bones
			case BLESSED_BAT_BONES:
				return 530; // Bat bones
			case BLESSED_BIG_BONES:
				return 532; // Big bones
			case BLESSED_BABYDRAGON_BONES:
				return 534; // Babydragon bones
			case BLESSED_DRAGON_BONES:
				return 536; // Dragon bones
			case BLESSED_WYVERN_BONES:
				return 6812; // Wyvern bones
			case BLESSED_DRAKE_BONES:
				return 22783; // Drake bones
			case BLESSED_FAYRG_BONES:
				return 4830; // Fayrg bones
			case BLESSED_LAVA_DRAGON_BONES:
				return 11943; // Lava dragon bones
			case BLESSED_RAURG_BONES:
				return 4832; // Raurg bones
			case BLESSED_DAGANNOTH_BONES:
				return 6729; // Dagannoth bones
			case BLESSED_OURG_BONES:
				return 4834; // Ourg bones
			case BLESSED_SUPERIOR_DRAGON_BONES:
				return 22124; // Superior dragon bones
			case BLESSED_BABYWYRM_BONES:
				return 28899; // Babywyrm bones (wyrmling bones)
			case BLESSED_WYRM_BONES:
				return 22780; // Wyrm bones
			case BLESSED_HYDRA_BONES:
				return 22786; // Hydra bones
			case BLESSED_ZOGRE_BONES:
				return 4812; // Zogre bones
			case BLESSED_FROST_DRAGON_BONES:
				return 31729; // Frost dragon bones
			case BLESSED_STRYKEWYRM_BONES:
				return 31726; // Strykewyrm bones
			case BLESSED_BONE_STATUETTE0:
			case BLESSED_BONE_STATUETTE1:
			case BLESSED_BONE_STATUETTE2:
			case BLESSED_BONE_STATUETTE3:
			case BLESSED_BONE_STATUETTE4:
				return 29338; // Use blessed bone statuette icon (no unblessed version)
			case BLESSED_BONE_SHARDS:
				return 29381; // Bone shards (no unblessed version)
			case SUN_KISSED_BONES:
				return 29380; // Sun-kissed bones (no unblessed version)
			default:
				// For unblessed bones and other types I may have missed, use regular version
				return boneType.getBaseItemId();
		}
	}

	private void setupReferenceTableColumns(JTable table) {
		if (table.getColumnCount() >= 2) {
			table.getColumnModel().getColumn(0).setPreferredWidth(225); // Bone Type - 75%
			table.getColumnModel().getColumn(1).setPreferredWidth(75); // Shard Value - 25%

			table.getColumnModel().getColumn(0).setMinWidth(150); // Bone Type minimum
			table.getColumnModel().getColumn(1).setMinWidth(50); // Shard Value minimum

			table.getColumnModel().getColumn(0).setMaxWidth(250); // Bone Type maximum
			table.getColumnModel().getColumn(1).setMaxWidth(100); // Shard Value maximum

			table.getTableHeader().setResizingAllowed(false);
			table.getTableHeader().setReorderingAllowed(false);

			javax.swing.table.DefaultTableCellRenderer rightRenderer = new javax.swing.table.DefaultTableCellRenderer();
			rightRenderer.setHorizontalAlignment(javax.swing.SwingConstants.RIGHT);
			rightRenderer.setBackground(ColorScheme.DARKER_GRAY_COLOR);
			rightRenderer.setForeground(Color.WHITE);

			table.getColumnModel().getColumn(1).setCellRenderer(rightRenderer);
		}
	}

	private BoneType getConsolidatedBoneType(BoneType boneType) {
		// Consolidate variations
		switch (boneType) {
			case BLESSED_BONE_STATUETTE1:
			case BLESSED_BONE_STATUETTE2:
			case BLESSED_BONE_STATUETTE3:
			case BLESSED_BONE_STATUETTE4:
				return BoneType.BLESSED_BONE_STATUETTE0;
			case BONES:
				return BoneType.BLESSED_BONES;
			case BAT_BONES:
				return BoneType.BLESSED_BAT_BONES;
			case BIG_BONES:
				return BoneType.BLESSED_BIG_BONES;
			case BABYDRAGON_BONES:
				return BoneType.BLESSED_BABYDRAGON_BONES;
			case DRAGON_BONES:
				return BoneType.BLESSED_DRAGON_BONES;
			case WYVERN_BONES:
				return BoneType.BLESSED_WYVERN_BONES;
			case DRAKE_BONES:
				return BoneType.BLESSED_DRAKE_BONES;
			case FAYRG_BONES:
				return BoneType.BLESSED_FAYRG_BONES;
			case LAVA_DRAGON_BONES:
				return BoneType.BLESSED_LAVA_DRAGON_BONES;
			case RAURG_BONES:
				return BoneType.BLESSED_RAURG_BONES;
			case DAGANNOTH_BONES:
				return BoneType.BLESSED_DAGANNOTH_BONES;
			case OURG_BONES:
				return BoneType.BLESSED_OURG_BONES;
			case SUPERIOR_DRAGON_BONES:
				return BoneType.BLESSED_SUPERIOR_DRAGON_BONES;
			case BABYWYRM_BONES:
				return BoneType.BLESSED_BABYWYRM_BONES;
			case WYRM_BONES:
				return BoneType.BLESSED_WYRM_BONES;
			case HYDRA_BONES:
				return BoneType.BLESSED_HYDRA_BONES;
			case ZOGRE_BONES:
				return BoneType.BLESSED_ZOGRE_BONES;
			case FROST_DRAGON_BONES:
				return BoneType.BLESSED_FROST_DRAGON_BONES;
			case STRYKEWYRM_BONES:
				return BoneType.BLESSED_STRYKEWYRM_BONES;
			default:
				return boneType; // Return original type for blessed bones and special types
		}
	}

	private class BoneTypeIconRenderer extends javax.swing.table.DefaultTableCellRenderer {
		private final java.util.List<BoneType> boneTypes;
		private static final int MAX_ICON_SIZE = 16; // Maximum icon size in pixels

		public BoneTypeIconRenderer(java.util.List<BoneType> boneTypes) {
			this.boneTypes = boneTypes;
		}

		@Override
		public java.awt.Component getTableCellRendererComponent(JTable table, Object value, boolean isSelected,
				boolean hasFocus, int row, int column) {

			// Get the default renderer component
			super.getTableCellRendererComponent(table, value, isSelected, hasFocus, row, column);

			// Set the background and foreground colors to match the table
			if (isSelected) {
				setBackground(table.getSelectionBackground());
				setForeground(table.getSelectionForeground());
			} else {
				setBackground(table.getBackground());
				setForeground(table.getForeground());
			}

			// Set the font
			setFont(table.getFont());

			// Add icon if we have a valid row and ItemManager is available
			if (row >= 0 && row < boneTypes.size() && itemManager != null) {
				BoneType boneType = boneTypes.get(row);
				try {
					int itemId = getBoneItemId(boneType);
					if (itemId > 0) {
						// Clear any existing icon first
						setIcon(null);
						// Load and scale the icon using ItemManager
						loadScaledIcon(itemId);
					}
				} catch (Exception e) {
					log.error("Error loading icon for {}", boneType.getDisplayName(), e);
					setIcon(null);
				}
			} else {
				setIcon(null);
			}

			return this;
		}

		private void loadScaledIcon(int itemId) {
			try {
				// Clear any existing icon first
				setIcon(null);
				// Load the icon using ItemManager
				itemManager.getImage(itemId).addTo(this);
				// Scale the icon after it's loaded
				scaleIconToMaxSize(MAX_ICON_SIZE);
			} catch (Exception e) {
				log.error("Error loading icon for item {}", itemId, e);
				setIcon(null);
			}
		}

		private void scaleIconToMaxSize(int maxSize) {
			javax.swing.Icon currentIcon = getIcon();
			if (currentIcon == null) {
				return;
			}

			int iconWidth = currentIcon.getIconWidth();
			int iconHeight = currentIcon.getIconHeight();

			// Only scale if the icon is larger than maxSize
			if (iconWidth <= maxSize && iconHeight <= maxSize) {
				return;
			}

			try {
				// Calculate scaling factor to maintain aspect ratio
				double scaleX = (double) maxSize / iconWidth;
				double scaleY = (double) maxSize / iconHeight;
				double scale = Math.min(scaleX, scaleY);

				int newWidth = (int) (iconWidth * scale);
				int newHeight = (int) (iconHeight * scale);

				// Create scaled image if the icon is an ImageIcon
				if (currentIcon instanceof javax.swing.ImageIcon) {
					javax.swing.ImageIcon imageIcon = (javax.swing.ImageIcon) currentIcon;
					java.awt.Image originalImage = imageIcon.getImage();
					java.awt.Image scaledImage = originalImage.getScaledInstance(newWidth, newHeight,
							java.awt.Image.SCALE_SMOOTH);
					setIcon(new javax.swing.ImageIcon(scaledImage));
				}
			} catch (Exception e) {
				log.error("Error scaling icon", e);
			}
		}

	}

	private class ResourceBreakdownIconRenderer extends javax.swing.table.DefaultTableCellRenderer {
		private static final int MAX_ICON_SIZE = 16; // Maximum icon size in pixels

		@Override
		public java.awt.Component getTableCellRendererComponent(JTable table, Object value, boolean isSelected,
				boolean hasFocus, int row, int column) {

			// Get the default renderer component
			super.getTableCellRendererComponent(table, value, isSelected, hasFocus, row, column);

			// Set the background and foreground colors to match the table
			if (isSelected) {
				setBackground(table.getSelectionBackground());
				setForeground(table.getSelectionForeground());
			} else {
				setBackground(table.getBackground());
				setForeground(table.getForeground());
			}

			// Set the font
			setFont(table.getFont());

			// Add icon if we have a valid value and ItemManager is available
			if (value != null && itemManager != null) {
				String boneTypeName = value.toString();
				try {
					// Find the bone type by display name
					BoneType boneType = findBoneTypeByDisplayName(boneTypeName);
					if (boneType != null) {
						int itemId = getBoneItemId(boneType);
						if (itemId > 0) {
							// Clear any existing icon first
							setIcon(null);
							// Load and scale the icon using ItemManager
							loadScaledIcon(itemId);
						}
					}
				} catch (Exception e) {
					log.error("Error loading icon for {}", boneTypeName, e);
					setIcon(null);
				}
			} else {
				setIcon(null);
			}

			return this;
		}

		private BoneType findBoneTypeByDisplayName(String displayName) {
			for (BoneType boneType : BoneType.values()) {
				if (boneType.getDisplayName().equals(displayName)) {
					return boneType;
				}
			}
			return null;
		}

		private void loadScaledIcon(int itemId) {
			try {
				// Clear any existing icon first
				setIcon(null);
				// Load the icon using ItemManager
				itemManager.getImage(itemId).addTo(this);
				// Scale the icon after it's loaded
				scaleIconToMaxSize(MAX_ICON_SIZE);
			} catch (Exception e) {
				log.error("Error loading icon for item {}", itemId, e);
				setIcon(null);
			}
		}

		private void scaleIconToMaxSize(int maxSize) {
			javax.swing.Icon currentIcon = getIcon();
			if (currentIcon == null) {
				return;
			}

			int iconWidth = currentIcon.getIconWidth();
			int iconHeight = currentIcon.getIconHeight();

			// Only scale if the icon is larger than maxSize
			if (iconWidth <= maxSize && iconHeight <= maxSize) {
				return;
			}

			try {
				// Calculate scaling factor to maintain aspect ratio
				double scaleX = (double) maxSize / iconWidth;
				double scaleY = (double) maxSize / iconHeight;
				double scale = Math.min(scaleX, scaleY);

				int newWidth = (int) (iconWidth * scale);
				int newHeight = (int) (iconHeight * scale);

				// Create scaled image if the icon is an ImageIcon
				if (currentIcon instanceof javax.swing.ImageIcon) {
					javax.swing.ImageIcon imageIcon = (javax.swing.ImageIcon) currentIcon;
					java.awt.Image originalImage = imageIcon.getImage();
					java.awt.Image scaledImage = originalImage.getScaledInstance(newWidth, newHeight,
							java.awt.Image.SCALE_SMOOTH);
					setIcon(new javax.swing.ImageIcon(scaledImage));
				}
			} catch (Exception e) {
				log.error("Error scaling icon", e);
			}
		}
	}

}
package com.boneshardhelper;

import java.awt.Color;
import net.runelite.client.config.Alpha;
import net.runelite.client.config.Config;
import net.runelite.client.config.ConfigGroup;
import net.runelite.client.config.ConfigItem;
import net.runelite.client.config.ConfigSection;

@ConfigGroup("boneshardhelper")
public interface BoneShardHelperConfig extends Config {
    @ConfigSection(name = "Overlay", description = "Configure prayer object overlay", position = 0)
    String overlaySection = "overlaySection";

    // Object Highlighting Settings
    @ConfigItem(keyName = "highlightPrayerObjects", name = "Highlight Prayer Objects", description = "Enable highlighting of prayer objects with colored outlines", section = overlaySection, position = 0)
    default boolean highlightPrayerObjects() {
        return true;
    }

    @ConfigItem(keyName = "highlightStyle", name = "Highlight Style", description = "Choose the style for highlighting prayer objects", section = overlaySection, position = 1)
    default HighlightStyle highlightStyle() {
        return HighlightStyle.HIGHLIGHT_CLICKBOX;
    }

    @Alpha
    @ConfigItem(keyName = "activeObjectColor", name = "Active object color", description = "Highlight the color of the active object for training", section = overlaySection, position = 2)
    default Color activeObjectColor() {
        return Color.GREEN;
    }

    @Alpha
    @ConfigItem(keyName = "inactiveObjectColor", name = "Inactive object color", description = "Highlight color for non-active training objects", section = overlaySection, position = 3)
    default Color inactiveObjectColor() {
        return Color.DARK_GRAY;
    }

    @ConfigItem(keyName = "exposedAltarPath", name = "Draw line to Exposed altar", description = "Draw a line to the Exposed altar when you have blessed bone shards and unblessed wines", section = overlaySection, position = 4)
    default boolean exposedAltarPath() {
        return true;
    }

    @Alpha
    @ConfigItem(keyName = "exposedAltarPathColor", name = "Path color", description = "Color of ground path to exposed altar", section = overlaySection, position = 5)
    default Color exposedAltarPathColor() {
        return Color.CYAN;
    }

    // Text overlay
    @ConfigSection(name = "Libation Bowl Text", description = "Display information about the training progress as an overlay on the Libation Bowl", position = 1)
    String infoOverlaySection = "infoOverlaySection";

    @ConfigItem(keyName = "overlayActionsLeft", name = "Actions Left Overlay", description = "Display the number of actions left until the next stage near the Libation Bowl at Ralos' Rise", section = infoOverlaySection, position = 0)
    default boolean toggleOverlayActionsLeft() {
        return true;
    }

    @ConfigItem(keyName = "overlayStageName", name = "Training Stage Overlay", description = "When not in the \"Sacrifice Shards\" training stage, display the current stage name.", section = infoOverlaySection, position = 1)
    default boolean toggleOverlayStageName() {
        return true;
    }

    @ConfigItem(keyName = "textOutline", name = "Text Outline", description = "Use an outline around text instead of a shadow.", section = infoOverlaySection, position = 2)
    default boolean textOutline() {
        return false;
    }

    // Training Stage Colors
    @ConfigSection(name = "Training Stage Colors", description = "Configure colors for each training stage", position = 2)
    String stageColorsSection = "stageColorsSection";

    @Alpha
    @ConfigItem(keyName = "blessWinesColor", name = "Bless Wines", description = "Color for the Bless Wines training stage", section = stageColorsSection, position = 0)
    default Color blessWinesColor() {
        return Color.ORANGE;
    }

    @Alpha
    @ConfigItem(keyName = "sacrificeShardsColor", name = "Sacrifice Shards", description = "Color for the Sacrifice Shards training stage", section = stageColorsSection, position = 1)
    default Color sacrificeShardsColor() {
        return Color.GREEN;
    }

    @Alpha
    @ConfigItem(keyName = "rechargePrayerColor", name = "Recharge Prayer", description = "Color for the Recharge Prayer training stage", section = stageColorsSection, position = 2)
    default Color rechargePrayerColor() {
        return Color.CYAN;
    }

    @Alpha
    @ConfigItem(keyName = "resupplyColor", name = "Resupply", description = "Color for the Resupply training stage", section = stageColorsSection, position = 3)
    default Color resupplyColor() {
        return Color.YELLOW;
    }

    // Infobox Settings
    @ConfigSection(name = "Infobox", description = "Configure training infobox", position = 3)
    String infoboxSection = "infoboxSection";

    @ConfigItem(keyName = "toggleInfobox", name = "Enable infobox at Ralos' Rise", description = "Toggle for \"Bone Shard Helper\" infobox (only shows while in Ralos' Rise map region)", section = infoboxSection, position = 0)
    default boolean toggleInfobox() {
        return true;
    }

    @ConfigItem(keyName = "infoboxTitle", name = "Title", description = "Show title for infobox", section = infoboxSection, position = 1)
    default boolean infoboxTitle() {
        return true;
    }

    @ConfigItem(keyName = "infoboxCurrentState", name = "Display training stage", description = "Show current training stage (bless wines, recharge prayer, sacrifice shards, or resupply)", section = "infoboxSection", position = 2)
    default boolean infoboxCurrentState() {
        return true;
    }

    @ConfigItem(keyName = "infoboxActionsLeft", name = "Remaining actions", description = "Show number of actions left in current training stage", section = infoboxSection, position = 3)
    default boolean infoboxActionsLeft() {
        return true;
    }

    @ConfigItem(keyName = "infoboxInventoriesLeft", name = "Remaining inventories", description = "Show number of inventories remaining until goal. Calculated from number of wine jugs held in inventory.", section = infoboxSection, position = 4)
    default boolean infoboxInventoriesLeft() {
        return true;
    }

    @ConfigItem(keyName = "infoboxRegularWineWarning", name = "Warn if using regular wines", description = "Show a warning if you bring regular jugs of wine to Ralos' Rise", section = infoboxSection, position = 5)
    default boolean infoboxRegularWineWarning() {
        return true;
    }

    // Debug Settings
    @ConfigSection(name = "Debug Settings", description = "Configure debug and development options", position = 4)
    String debugSection = "debugSection";

    @ConfigItem(keyName = "debugMode", name = "Debug Mode", description = "Enable debug mode to show additional debugging information and tables", section = debugSection, position = 0)
    default boolean debugMode() {
        return false;
    }
}
package com.boneshardhelper;

import java.util.HashMap;
import java.util.Map;

public class PrayerData {
    private int currentXP;
    private int currentLevel;
    private int targetLevel;
    private int targetXP;
    private boolean useSunfireWine;
    private boolean useZealotRobes;
    private Map<BoneType, Integer> availableBones;
    private boolean manualLevelOverride;

    public PrayerData() {
        this.currentXP = 0;
        this.currentLevel = 1;
        this.targetLevel = 2;
        this.targetXP = 0;
        this.useSunfireWine = false;
        this.useZealotRobes = false;
        this.availableBones = new HashMap<>();
        this.manualLevelOverride = false;
    }

    public PrayerData(int currentXP, int currentLevel, int targetLevel, boolean useSunfireWine) {
        this.currentXP = currentXP;
        this.currentLevel = currentLevel;
        this.targetLevel = targetLevel;
        this.targetXP = 0; // Will be calculated from target level if not set
        this.useSunfireWine = useSunfireWine;
        this.useZealotRobes = false;
        this.availableBones = new HashMap<>();
        this.manualLevelOverride = false;
    }

    // Getters and setters
    public int getCurrentXP() {
        return currentXP;
    }

    public void setCurrentXP(int currentXP) {
        this.currentXP = currentXP;
    }

    public int getCurrentLevel() {
        return currentLevel;
    }

    public void setCurrentLevel(int currentLevel) {
        this.currentLevel = currentLevel;
    }

    public int getTargetLevel() {
        return targetLevel;
    }

    public void setTargetLevel(int targetLevel) {
        this.targetLevel = targetLevel;
    }

    public int getTargetXP() {
        return targetXP;
    }

    public void setTargetXP(int targetXP) {
        this.targetXP = targetXP;
    }

    public boolean isUseSunfireWine() {
        return useSunfireWine;
    }

    public void setUseSunfireWine(boolean useSunfireWine) {
        this.useSunfireWine = useSunfireWine;
    }

    public boolean isUseZealotRobes() {
        return useZealotRobes;
    }

    public void setUseZealotRobes(boolean useZealotRobes) {
        this.useZealotRobes = useZealotRobes;
    }

    public Map<BoneType, Integer> getAvailableBones() {
        return new HashMap<>(availableBones);
    }

    public void setAvailableBones(Map<BoneType, Integer> availableBones) {
        this.availableBones = new HashMap<>(availableBones);
    }

    public boolean isManualLevelOverride() {
        return manualLevelOverride;
    }

    public void setManualLevelOverride(boolean manualLevelOverride) {
        this.manualLevelOverride = manualLevelOverride;
    }

    public double getXPPerShard() {
        // Gets the XP per shard, accounting for wine type and zealot robes
        double baseXP = useSunfireWine ? 6.0 : 5.0;
        return useZealotRobes ? baseXP * 1.05 : baseXP;
    }

    public int getTotalAvailableShards() {
        // Calculates total available bone shards from all bone types.
        return availableBones.entrySet().stream()
                .mapToInt(entry -> entry.getKey().getShardValue() * entry.getValue())
                .sum();
    }

    public boolean isValidTargetLevel() {
        return targetLevel > currentLevel && targetLevel <= 126;
    }

    @Override
    public String toString() {
        return "PrayerData{" +
                "currentXP=" + currentXP +
                ", currentLevel=" + currentLevel +
                ", targetLevel=" + targetLevel +
                ", targetXP=" + targetXP +
                ", useSunfireWine=" + useSunfireWine +
                ", useZealotRobes=" + useZealotRobes +
                ", availableBones=" + availableBones.size() + " types" +
                ", manualLevelOverride=" + manualLevelOverride +
                '}';
    }
}
package com.boneshardhelper;

public enum HighlightStyle {
    HIGHLIGHT_CLICKBOX("Clickbox"),
    HIGHLIGHT_OUTLINE("Outline");

    private final String name;

    HighlightStyle(String name) {
        this.name = name;
    }

    @Override
    public String toString() {
        return name;
    }
}

package com.boneshardhelper;

import java.awt.Color;
import java.awt.Dimension;
import java.awt.Graphics2D;
import javax.inject.Inject;
import javax.inject.Singleton;

import net.runelite.client.ui.overlay.OverlayPanel;
import net.runelite.client.ui.overlay.OverlayPosition;
import net.runelite.client.ui.overlay.components.LineComponent;
import net.runelite.client.ui.overlay.components.TitleComponent;

@Singleton
public class BoneShardOverlay2D extends OverlayPanel {
        private final BoneShardHelperConfig config;
        private final BoneShardTrainingState state;

        @Inject
        private BoneShardOverlay2D(
                        BoneShardHelperConfig config,
                        BoneShardTrainingState state) {
                this.config = config;
                this.state = state;
                this.setPosition(OverlayPosition.BOTTOM_LEFT);
        }

        @Override
        public Dimension render(Graphics2D graphics) {
                if (!config.toggleInfobox() || state.getCurrentTrainingState() == BoneShardTrainingState.TrainingState.NO_STATE) {
                        return null;
                }

                if (!state.inTrainingRegion()) {
                        return null;
                }

                if (config.infoboxTitle()) {
                        panelComponent.getChildren().add(TitleComponent.builder().text("Bone Shard Helper").build());
                }

                // Show components regardless of training state for testing
                BoneShardTrainingState.TrainingState currentState = state.getCurrentTrainingState();
                Color stageColor;
                
                switch (currentState) {
                        case BLESS_WINES:
                                stageColor = config.blessWinesColor();
                                break;
                        case RECHARGE_PRAYER:
                                stageColor = config.rechargePrayerColor();
                                break;
                        case SACRIFICE_SHARDS:
                                stageColor = config.sacrificeShardsColor();
                                break;
                        case RESUPPLY:
                                stageColor = config.resupplyColor();
                                break;
                        default:
                                stageColor = Color.WHITE;
                                break;
                }
                
                panelComponent.getChildren().add(
                                LineComponent.builder().left("Stage: ")
                                                .right(currentState.getDisplayName())
                                                .rightColor(stageColor)
                                                .build());

                if (config.infoboxActionsLeft() && state.getCurrentTrainingState() == BoneShardTrainingState.TrainingState.SACRIFICE_SHARDS) {
                        panelComponent.getChildren().add(
                                        LineComponent.builder().left("Actions left: ")
                                                        .right(state.getActionsRemaining() + "").build());
                }

                if (config.infoboxInventoriesLeft() 
                                && state.getCurrentTrainingState() != BoneShardTrainingState.TrainingState.NO_STATE) {
                        panelComponent.getChildren().add(
                                        LineComponent.builder().left("Inventories left: ")
                                                        .right(state.getInventoriesRemaining() + "").build());
                }

                if (config.debugMode()) {
                        panelComponent.getChildren().add(
                                        LineComponent.builder().left("Wine in bowl: ")
                                                        .right(state.getWineActionsInBowl() + "").build());
                }

                // Show regular wine warning if enabled and in a valid training state
                if (config.infoboxRegularWineWarning() 
                                && state.getCurrentTrainingState() != BoneShardTrainingState.TrainingState.NO_STATE
                                && state.hasRegularWines()) {
                        panelComponent.getChildren().add(
                                        TitleComponent.builder()
                                                        .text("Holding regular wine!")
                                                        .color(Color.RED)
                                                        .build());
                }
                return super.render(graphics);
        }
}

package com.boneshardhelper;

import lombok.Getter;
import lombok.Setter;
import net.runelite.api.Client;
import net.runelite.api.ItemContainer;
import net.runelite.api.Skill;

import javax.inject.Inject;
import javax.inject.Singleton;

@Singleton
public class BoneShardTrainingState {
    private static final int REGION_ID = 5681;
    private static final int EMPTY_JUG_ID = 1935;
    private static final int WINE_ID = 1993;
    private static final int SUNFIRE_WINE_ID = 29382;
    private static final int BLESSED_SUNFIRE_WINE_ID = 29384;
    private static final int BLESSED_WINE_ID = 29386;
    private static final int BLESSED_BONE_SHARDS_ID = 29381;

    @Inject
    private Client client;

    @Setter
    @Getter
    private boolean enabled;

    // Tracking variables
    private int cachedVarbitValue = -1; // Cache the varbit value

    @Setter
    private int wineActionsInBowl; // Track wine actions in bowl separately

    public enum TrainingState {
        NO_STATE(-1, ""),
        BLESS_WINES(1, "Bless wines"),
        SACRIFICE_SHARDS(2, "Sacrifice shards"),
        RECHARGE_PRAYER(3, "Recharge prayer"),
        RESUPPLY(4, "Resupply");

        private final int id;
        private final String displayName;

        TrainingState(int id, String displayName) {
            this.id = id;
            this.displayName = displayName;
        }

        public int getId() {
            return id;
        }

        public String getDisplayName() {
            return displayName;
        }
    }

    // Core inventory checks
    private ItemContainer getInventory() {
        return client.getItemContainer(93);
    }

    private boolean hasItem(int... itemIds) {
        ItemContainer inv = getInventory();
        if (inv == null)
            return false;
        for (int id : itemIds) {
            if (inv.contains(id))
                return true;
        }
        return false;
    }

    private int getItemCount(int... itemIds) {
        ItemContainer inv = getInventory();
        if (inv == null)
            return 0;
        int total = 0;
        for (int id : itemIds) {
            total += inv.count(id);
        }
        return total;
    }

    // Simple state checks
    public boolean inTrainingRegion() {
        int currentRegion = client.getLocalPlayer().getWorldLocation().getRegionID();

        // Check if in the main training region (5681)
        if (currentRegion == REGION_ID) {
            return true;
        }

        // Check if in the additional training area in region 5680
        //   Includes the tiles along the path from the ralos' rise Pendant of Ates tp to the altar
        if (currentRegion == 5680) {
            // Check if within the rectangular area from (39,63) to (52,57)
            int regionX = client.getLocalPlayer().getWorldLocation().getRegionX();
            int regionY = client.getLocalPlayer().getWorldLocation().getRegionY();

            return regionX >= 39 && regionX <= 52 && regionY >= 57 && regionY <= 63;
        }

        return false;
    }

    public boolean hasUnblessedWines() {
        return hasItem(WINE_ID, SUNFIRE_WINE_ID);
    }

    public boolean hasBlessedWines() {
        return hasItem(BLESSED_SUNFIRE_WINE_ID, BLESSED_WINE_ID);
    }

    public boolean hasRegularWines() {
        return hasItem(WINE_ID, BLESSED_WINE_ID);
    }

    public boolean hasEmptyJugs() {
        return hasItem(EMPTY_JUG_ID);
    }

    public boolean hasShards() {
        return hasItem(BLESSED_BONE_SHARDS_ID);
    }

    public boolean hasSufficientPrayer() {
        return client.getBoostedSkillLevel(Skill.PRAYER) >= 2;
    }

    // Get the number of wine actions remaining in the bowl directly from varbit
    public int getWineActionsInBowl() {
        updateVarbitCache();
        return wineActionsInBowl;
    }

    public boolean hasWineInBowl() {
        return getWineActionsInBowl() > 0;
    }

    public void onVarbitChanged(int newValue) {
        cachedVarbitValue = newValue;
        wineActionsInBowl = newValue / 100; // Convert varbit value to actions (100 shards per action)
    }

    private void updateVarbitCache() {
        if (client != null) {
            int currentVarbitValue = client.getVarbitValue(9945);
            if (currentVarbitValue != cachedVarbitValue) {
                cachedVarbitValue = currentVarbitValue;
                wineActionsInBowl = currentVarbitValue / 100;
            }
        }
    }

    // Action calculations
    public int getBlessedWineCount() {
        return getItemCount(BLESSED_SUNFIRE_WINE_ID, BLESSED_WINE_ID);
    }

    public int getBlessedBoneShardCount() {
        return getItemCount(BLESSED_BONE_SHARDS_ID);
    }

    public int getTotalWineJugCount() {
        return getItemCount(EMPTY_JUG_ID, BLESSED_SUNFIRE_WINE_ID, BLESSED_WINE_ID, WINE_ID, SUNFIRE_WINE_ID);
    }

    public int getCurrentPrayerPoints() {
        return client.getBoostedSkillLevel(Skill.PRAYER);
    }

    // Debug method to get raw varbit value
    public int getRawVarbitValue() {
        updateVarbitCache();
        return cachedVarbitValue;
    }

    // Main state logic
    public TrainingState getCurrentTrainingState() {
        boolean hasShards = hasShards();
        boolean hasUnblessed = hasUnblessedWines();
        boolean hasBlessed = hasBlessedWines();
        boolean hasWineInBowl = getWineActionsInBowl() > 0;
        boolean hasPrayer = hasSufficientPrayer();
        boolean hasEmptyJugs = hasEmptyJugs();

        TrainingState currentState;

        if (!hasShards || (!hasUnblessed && !hasBlessed && !hasWineInBowl && !hasEmptyJugs)) {
            currentState = TrainingState.NO_STATE;
        } else if (hasUnblessed) {
            currentState = TrainingState.BLESS_WINES;
        } else if ((hasBlessed || hasWineInBowl) && hasPrayer) {
            currentState = TrainingState.SACRIFICE_SHARDS;
        } else if ((hasBlessed || hasWineInBowl) && !hasPrayer) {
            currentState = TrainingState.RECHARGE_PRAYER;
        } else if (!hasBlessed && !hasWineInBowl && hasEmptyJugs && hasShards) {
            currentState = TrainingState.RESUPPLY;
        } else {
            currentState = TrainingState.NO_STATE;
        }

        return currentState;
    }

    // Counter methods
    public int getRemainingInventoryActions() {
        // Calculate wine actions from inventory wines + bowl wine actions
        return (getBlessedWineCount() * 4) + getWineActionsInBowl();
    }

    public int getActionsUntilPrayerRestore() {
        int prayerActions = getCurrentPrayerPoints() / 2;
        int wineActions = getRemainingInventoryActions();
        int shardActions = (int) Math.ceil(getBlessedBoneShardCount() / 100.0);

        int availableActions = Math.min(wineActions, shardActions);
        return Math.min(prayerActions, availableActions);
    }

    public int getActionsRemaining() {
        int inventoryActions = getRemainingInventoryActions();
        int prayerActions = getActionsUntilPrayerRestore();

        // Return the smaller of the two (the limiting factor)
        return Math.min(inventoryActions, prayerActions);
    }

    public int getInventoriesRemaining() {
        TrainingState currentState = getCurrentTrainingState();
        if (currentState == TrainingState.NO_STATE) {
            return 0;
        }
        
        int blessedShards = getBlessedBoneShardCount();
        int actionsNeeded = (int) Math.ceil((double) blessedShards / 100);
        int currentActionsAvailable = getRemainingInventoryActions();
        int remainingActionsNeeded = Math.max(0, actionsNeeded - currentActionsAvailable);
        
        // Inventory isn't enough to handle shards
        if (remainingActionsNeeded > 0) {
            int totalWineCapacity = getTotalWineJugCount();
            if (totalWineCapacity == 0) {
                return 0;
            }
            int remainingWinesNeeded = (int) Math.ceil((double) remainingActionsNeeded / 4);
            return (int) Math.ceil((double) remainingWinesNeeded / totalWineCapacity);
        } else {
            // Current inventory is sufficient - 0 more trips needed
            return 0;
        }
    }
}

package com.boneshardhelper;

public final class PrayerConstants {

    // XP table for levels 1-126, and ending with 200,000,000 for the crazies out there.
    public static final int[] PRAYER_XP_TABLE = {
            0, 83, 174, 276, 388, 512, 650, 801, 969, 1154, 1358, 1584, 1833, 2107,
            2411, 2746, 3115, 3523, 3973, 4470, 5018, 5624, 6291, 7028, 7842, 8740,
            9730, 10824, 12031, 13363, 14833, 16456, 18247, 20224, 22406, 24815, 27473,
            30408, 33648, 37224, 41171, 45529, 50339, 55649, 61512, 67983, 75127, 83014,
            91721, 101333, 111945, 123660, 136594, 150872, 166636, 184040, 203254, 224466,
            247886, 273742, 302288, 333804, 368599, 407015, 449428, 496254, 547953, 605032,
            668051, 737627, 814445, 899257, 992895, 1096278, 1210421, 1336443, 1475581, 1629200,
            1798808, 1986068, 2192818, 2421087, 2673114, 2951373, 3258594, 3597792, 3972294, 4385776,
            4842295, 5346332, 5902831, 6517253, 7195629, 7944614, 8771558, 9684577, 10692629, 11805606,
            13034431, 14391160, 15889109, 17542976, 19368992, 21385073, 23611006, 26068632, 28782069,
            31777943, 35085654, 38737661, 42769801, 47221641, 52136869, 57563718, 63555443, 70170840,
            77474828, 85539082, 94442737, 104273167, 115126838, 127110260, 140341028, 154948977,
            171077457, 188884740, 200000000
    };

    public static final int MAX_PRAYER_LEVEL = 126;

    public static final int MIN_PRAYER_LEVEL = 1;

    public static final int REGULAR_WINE_XP_PER_SHARD = 5;

    public static final int SUNFIRE_WINE_XP_PER_SHARD = 6;

    public static final int SHARDS_PER_WINE = 400;



    // Private constructor to prevent instantiation
    private PrayerConstants() {
        throw new UnsupportedOperationException("This is a utility class and cannot be instantiated");
    }

    public static int getXPForLevel(int level) {
        if (level < MIN_PRAYER_LEVEL || level > MAX_PRAYER_LEVEL) {
            throw new IllegalArgumentException(
                    "Prayer level must be between " + MIN_PRAYER_LEVEL + " and " + MAX_PRAYER_LEVEL);
        }
        return PRAYER_XP_TABLE[level - 1];
    }

    public static int getLevelForXP(int xp) {
        if (xp < 0) {
            return MIN_PRAYER_LEVEL;
        }

        for (int level = MAX_PRAYER_LEVEL; level >= MIN_PRAYER_LEVEL; level--) {
            if (xp >= PRAYER_XP_TABLE[level - 1]) {
                return level;
            }
        }

        return MIN_PRAYER_LEVEL;
    }

    public static int getXPDifference(int fromLevel, int toLevel) {
        return getXPForLevel(toLevel) - getXPForLevel(fromLevel);
    }

    public static boolean isValidLevel(int level) {
        return level >= MIN_PRAYER_LEVEL && level <= MAX_PRAYER_LEVEL;
    }
}
package com.boneshardhelper;

// All blessed bone types and their corresponding shard values
public enum BoneType {
    BLESSED_BONE_SHARDS(1, 29381), // No base item for bone shards
    BLESSED_BONE_STATUETTE0(125, 29338), // Variations of blessed bone statuette
    BLESSED_BONE_STATUETTE1(125, 29339),
    BLESSED_BONE_STATUETTE2(125, 29340),
    BLESSED_BONE_STATUETTE3(125, 29342),
    BLESSED_BONE_STATUETTE4(125, 29343),
    SUPERIOR_DRAGON_BONES(121, 22124),
    OURG_BONES(115, 4834),
    DAGANNOTH_BONES(100, 6729),
    HYDRA_BONES(93, 22786),
    FROST_DRAGON_BONES(84, 31729),
    RAURG_BONES(77, 4832),
    LAVA_DRAGON_BONES(68, 11943),
    DRAKE_BONES(67, 22783),
    FAYRG_BONES(67, 4830),
    DRAGON_BONES(58, 536),
    WYVERN_BONES(58, 6812),
    SUN_KISSED_BONES(45, 29380),
    WYRM_BONES(42, 22780),
    STRYKEWYRM_BONES(37, 31726),
    BABYDRAGON_BONES(24, 534),
    BABYWYRM_BONES(21, 28899), // Wyrmling bones
    WYRMLING_BONES(21, 28899),
    ZOGRE_BONES(18, 4812),
    BIG_BONES(12, 532),
    BAT_BONES(5, 530),
    BONES(4, 526),
    BLESSED_BONES(4, 29344),
    BLESSED_BAT_BONES(5, 29346),
    BLESSED_BIG_BONES(12, 29348),
    BLESSED_BABYDRAGON_BONES(24, 29352),
    BLESSED_DRAGON_BONES(58, 29356),
    BLESSED_WYVERN_BONES(58, 29360),
    BLESSED_DRAKE_BONES(67, 29366),
    BLESSED_FAYRG_BONES(67, 29370),
    BLESSED_LAVA_DRAGON_BONES(68, 29358),
    BLESSED_RAURG_BONES(77, 29372),
    BLESSED_DAGANNOTH_BONES(100, 29376),
    BLESSED_OURG_BONES(115, 29374),
    BLESSED_SUPERIOR_DRAGON_BONES(121, 29362),
    BLESSED_BABYWYRM_BONES(21, 29354), // Wyrmling bones
    BLESSED_WYRM_BONES(42, 29364),
    BLESSED_HYDRA_BONES(93, 29368),
    BLESSED_FROST_DRAGON_BONES(84, 31266),
    BLESSED_STRYKEWYRM_BONES(37, 31264),
    BLESSED_ZOGRE_BONES(18, 29350);

    private final int shardValue;
    private final int baseItemId;

    BoneType(int shardValue, int baseItemId) {
        this.shardValue = shardValue;
        this.baseItemId = baseItemId;
    }

    public int getShardValue() {
        return shardValue;
    }

    public int getBaseItemId() {
        // Gets the base (unblessed) item ID for this bone type.
        return baseItemId;
    }

    public boolean hasBaseItem() {
        // Some bone types don't have blessed versions so we gotta check it
        return baseItemId > 0;
    }

    public String getDisplayName() {
        // Special case for blessed bone statuette (consolidated display)
        if (name().startsWith("BLESSED_BONE_STATUETTE")) {
            return "Blessed Bone Statuette";
        }

        // Special case for blessed bone shards
        if (name().equals("BLESSED_BONE_SHARDS")) {
            return "Bone Shards";
        }

        // Special case for sun-kissed bones
        if (name().equals("SUN_KISSED_BONES")) {
            return "Sun-kissed Bones";
        }

        String name = name().toLowerCase()
                .replace("_", " ")
                .replace("blessed ", ""); // Remove "blessed" prefix for clean display

        // Capitalize first letter of each word
        StringBuilder result = new StringBuilder();
        boolean capitalizeNext = true;

        for (char c : name.toCharArray()) {
            if (Character.isWhitespace(c)) {
                capitalizeNext = true;
                result.append(c);
            } else if (capitalizeNext) {
                result.append(Character.toUpperCase(c));
                capitalizeNext = false;
            } else {
                result.append(c);
            }
        }

        return result.toString();
    }
}
package com.boneshardhelper;

import java.awt.BorderLayout;
import java.awt.Color;
import java.awt.Dimension;
import java.awt.FlowLayout;
import java.awt.GridLayout;
import java.util.ArrayList;
import java.util.Comparator;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.regex.Pattern;
import javax.swing.BorderFactory;
import javax.swing.JButton;
import javax.swing.JCheckBox;
import javax.swing.JLabel;
import javax.swing.JPanel;
import javax.swing.JScrollPane;
import javax.swing.JTable;
import javax.swing.JTextField;
import javax.swing.border.EmptyBorder;
import javax.swing.table.DefaultTableModel;
import lombok.Getter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.client.game.ItemManager;
import net.runelite.client.hiscore.HiscoreClient;
import net.runelite.client.hiscore.HiscoreSkill;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.FontManager;
import net.runelite.client.ui.PluginPanel;
import net.runelite.client.ui.components.FlatTextField;
import net.runelite.client.ui.components.IconTextField;

@Getter
@Slf4j
class GoalModePanel extends JPanel {
	private static final Pattern NON_NUMERIC = Pattern.compile("\\D");

	private final JTextField uiFieldCurrentLevel;
	private final JTextField uiFieldCurrentXP;
	private final JTextField uiFieldTargetLevel;
	private final JTextField uiFieldTargetXP;
	private final JCheckBox uiCheckboxSunfireWine;
	private final JCheckBox uiCheckboxZealotRobes;

	// Results display components
	private FoldingSection resourcesRequiredSection;
	private JLabel boneShardsLabel;
	private JLabel wineLabel;
	private JLabel sunfireSplinterLabel;
	private final JLabel warningLabel;

	// Item manager for icons
	private ItemManager itemManager;

	// Resource Planning components
	private FoldingSection resourcePlanningSection;
	private JButton scanInventoryButton;
	private JLabel resourceStatusLabel;
	private JTable recommendationsTable;
	private DefaultTableModel recommendationsTableModel;

	// Resource scanner reference (injected later)
	private BoneResourceScanner resourceScanner;

	// Calculation engine for centralized calculation logic
	private final PrayerCalculationEngine calculationEngine;

	// HiscoreClient for player lookups
	private HiscoreClient hiscoreClient;

	// Debug panel components (only visible in debug mode)
	private FoldingSection debugSection;
	private IconTextField hiscoreLookupField;
	private JLabel debugStatusLabel;

	// Resource planning recalculation tracking
	private boolean resourcePlanningNeedsRecalculation = false;
	private boolean hasInventoryData = false;

	GoalModePanel() {
		setLayout(new BorderLayout());
		setBackground(ColorScheme.DARK_GRAY_COLOR);

		// Initialize calculation engine
		this.calculationEngine = new PrayerCalculationEngine();

		// Create input panel with BorderLayout to stack components
		JPanel inputPanel = new JPanel(new BorderLayout());
		inputPanel.setBackground(ColorScheme.DARK_GRAY_COLOR);
		inputPanel.setBorder(new EmptyBorder(5, 5, 5, 5));

		// Create fields panel with 2x2 grid layout for level/XP fields
		JPanel fieldsPanel = new JPanel(new GridLayout(2, 2, 7, 7));
		fieldsPanel.setBackground(ColorScheme.DARK_GRAY_COLOR);

		// Input fields in 2x2 grid layout
		uiFieldCurrentLevel = addComponent(fieldsPanel, "Current Level");
		uiFieldCurrentXP = addComponent(fieldsPanel, "Current Experience");
		uiFieldTargetLevel = addComponent(fieldsPanel, "Target Level");
		uiFieldTargetXP = addComponent(fieldsPanel, "Target Experience");

		// Create checkboxes panel with vertical layout
		JPanel checkboxPanel = new JPanel(new GridLayout(2, 1, 0, 5));
		checkboxPanel.setBackground(ColorScheme.DARK_GRAY_COLOR);
		checkboxPanel.setBorder(new EmptyBorder(10, 0, 0, 0)); // Add some top spacing

		// Checkboxes stacked vertically
		uiCheckboxSunfireWine = addCheckboxComponent(checkboxPanel, "Sunfire Wine");
		uiCheckboxZealotRobes = addCheckboxComponent(checkboxPanel, "Zealot's Robes");

		// Add tooltips to checkboxes
		uiCheckboxSunfireWine.setToolTipText("+20% prayer XP per blessed bone shard");
		uiCheckboxZealotRobes.setToolTipText("5% chance to save bone resources");

		// Add panels to input panel
		inputPanel.add(fieldsPanel, BorderLayout.CENTER);
		inputPanel.add(checkboxPanel, BorderLayout.SOUTH);

		// Create results panel with BorderLayout to avoid equal height distribution
		JPanel resultsPanel = new JPanel(new BorderLayout());
		resultsPanel.setBackground(ColorScheme.DARK_GRAY_COLOR);
		resultsPanel.setBorder(new EmptyBorder(10, 5, 5, 5));

		// Create resources required section
		resourcesRequiredSection = createResourcesRequiredSection();

		warningLabel = new JLabel("<html>&nbsp;</html>"); // Non-breaking space to maintain consistent height
		warningLabel.setForeground(Color.ORANGE);
		warningLabel.setFont(FontManager.getRunescapeSmallFont());
		warningLabel.setBorder(new EmptyBorder(3, 0, 0, 0)); // Small top margin for spacing

		resultsPanel.add(resourcesRequiredSection, BorderLayout.NORTH);
		resultsPanel.add(warningLabel, BorderLayout.CENTER);

		// Create Resource Planning section
		resourcePlanningSection = createResourcePlanningSection();

		// Add expansion listener to trigger recalculation when section is expanded
		resourcePlanningSection.addExpansionListener(() -> {
			if (hasInventoryData && resourcePlanningNeedsRecalculation) {
				performInventoryScanInternal();
				resourcePlanningNeedsRecalculation = false;
			}
		});

		// Create debug section (initially hidden)
		debugSection = createDebugSection();

		// Create main content panel to hold results, resource planning, and debug panel
		JPanel bottomPanel = new JPanel(new BorderLayout());
		bottomPanel.setBackground(ColorScheme.DARK_GRAY_COLOR);
		bottomPanel.add(resultsPanel, BorderLayout.NORTH);

		// Create center panel for resource planning and debug
		JPanel centerPanel = new JPanel(new BorderLayout());
		centerPanel.setBackground(ColorScheme.DARK_GRAY_COLOR);
		centerPanel.add(resourcePlanningSection, BorderLayout.NORTH);
		centerPanel.add(debugSection, BorderLayout.SOUTH);

		bottomPanel.add(centerPanel, BorderLayout.CENTER);

		// Add panels to main layout
		add(inputPanel, BorderLayout.CENTER);
		add(bottomPanel, BorderLayout.SOUTH);
	}

	public void triggerResourcePlanningRecalculation() {
		if (hasInventoryData) {
			if (resourcePlanningSection.isOpen()) {
				// If section is open, recalculate immediately
				performInventoryScanInternal();
			} else {
				// If section is closed, mark for recalculation when expanded
				resourcePlanningNeedsRecalculation = true;
			}
		}
	}

	int getCurrentLevelInput() {
		return getInput(uiFieldCurrentLevel);
	}

	void setCurrentLevelInput(int value) {
		setInput(uiFieldCurrentLevel, value);
	}

	int getCurrentXPInput() {
		return getInput(uiFieldCurrentXP);
	}

	void setCurrentXPInput(Object value) {
		setInput(uiFieldCurrentXP, value);
	}

	int getTargetLevelInput() {
		return getInput(uiFieldTargetLevel);
	}

	void setTargetLevelInput(Object value) {
		setInput(uiFieldTargetLevel, value);
	}

	int getTargetXPInput() {
		return getInput(uiFieldTargetXP);
	}

	void setTargetXPInput(Object value) {
		setInput(uiFieldTargetXP, value);
	}

	// Getter methods for UI fields (needed for BoneShardHelperPanel)
	JTextField getUiFieldCurrentLevel() {
		return uiFieldCurrentLevel;
	}

	JTextField getUiFieldCurrentXP() {
		return uiFieldCurrentXP;
	}

	JTextField getUiFieldTargetLevel() {
		return uiFieldTargetLevel;
	}

	JTextField getUiFieldTargetXP() {
		return uiFieldTargetXP;
	}

	boolean isSunfireWineSelected() {
		return uiCheckboxSunfireWine.isSelected();
	}

	void setSunfireWineSelected(boolean selected) {
		uiCheckboxSunfireWine.setSelected(selected);
	}

	boolean isZealotRobesSelected() {
		return uiCheckboxZealotRobes.isSelected();
	}

	void setZealotRobesSelected(boolean selected) {
		uiCheckboxZealotRobes.setSelected(selected);
	}

	// Getter methods for checkboxes (needed for action listener setup)
	JCheckBox getUiCheckboxSunfireWine() {
		return uiCheckboxSunfireWine;
	}

	JCheckBox getUiCheckboxZealotRobes() {
		return uiCheckboxZealotRobes;
	}

	JButton getUiButtonScanInventory() {
		return scanInventoryButton;
	}

	public boolean isResourcePlanningExpanded() {
		return resourcePlanningSection.isOpen();
	}

	public void performInventoryScan() {
		performInventoryScanInternal();
	}

	public void updateBoneShardsRequired() {
		try {
			// Clear warning first
			clearValidationError();

			// Create PrayerData from current inputs
			PrayerData prayerData = new PrayerData();
			prayerData.setCurrentLevel(getCurrentLevelInput());
			prayerData.setCurrentXP(getCurrentXPInput());
			prayerData.setTargetLevel(getTargetLevelInput());
			prayerData.setTargetXP(getTargetXPInput());
			prayerData.setUseSunfireWine(isSunfireWineSelected());
			prayerData.setUseZealotRobes(isZealotRobesSelected());

			// Use centralized calculation engine (single source of truth)
			CalculationResult result = calculationEngine.calculateForTarget(prayerData);

			// Handle special cases
			if (result.isGoalAlreadyAchieved()) {
				updateResourcesDisplay(result, prayerData.isUseSunfireWine(), prayerData.isUseZealotRobes(), true);
				return;
			}

			// Check for invalid inputs (engine validation will catch these)
			int shardsNeeded = result.getRequiredShards();
			if (shardsNeeded <= 0) {
				updateResourcesDisplay(result, prayerData.isUseSunfireWine(), prayerData.isUseZealotRobes(), true);
				return;
			}

			// Update the resources display with calculated values
			updateResourcesDisplay(result, prayerData.isUseSunfireWine(), prayerData.isUseZealotRobes(), false);

		} catch (Exception e) {
			log.error("Prayer Calculator: Error updating bone shards calculation", e);

			// Create empty result for error display
			CalculationResult errorResult = new CalculationResult();
			errorResult.setRequiredShards(0);
			errorResult.setWinesNeeded(0);

			boneShardsLabel.setText("Calculation error");
			wineLabel.setText("Calculation error");
			sunfireSplinterLabel.setText("Calculation error");
			showValidationError("Calculation error: Please check your input values");
		}
	}

	public void clearResults() {
		boneShardsLabel.setText("Calculate to see results");
		boneShardsLabel.setIcon(null);
		wineLabel.setText("Calculate to see results");
		wineLabel.setIcon(null);
		sunfireSplinterLabel.setText("Calculate to see results");
		sunfireSplinterLabel.setIcon(null);
		warningLabel.setText("<html>&nbsp;</html>");
	}

	public void showValidationError(String message) {
		// Validation message in case inputs are invalid, like if current xp > target xp
		warningLabel.setText("<html>!! " + message + "</html>");
		warningLabel.setForeground(Color.RED);
	}

	private void updateResourcesDisplay(CalculationResult result, boolean useSunfireWine, boolean useZealotRobes,
			boolean goalAchieved) {
		// Updates the resources display with bone shards and wine requirements.
		try {
			// Get values from centralized calculation result
			int shardsNeeded = result.getRequiredShards();
			int winesNeeded = result.getWinesNeeded();

			// Update bone shards display - use blessed bone shards item ID (29381)
			if (itemManager != null) {
				try {
					// Clear any existing icon first
					boneShardsLabel.setIcon(null);
					// Use blessed bone shards item ID for the icon
					itemManager.getImage(29381).addTo(boneShardsLabel);
				} catch (Exception e) {
					log.error("Error loading bone shard icon", e);
				}
			}

			String shardsText;
			if (goalAchieved) {
				shardsText = "0 (goal achieved)";
			} else {
				shardsText = String.format("%,d bone shards", shardsNeeded);
			}

			boneShardsLabel.setText(shardsText);

			// Update wine display - use correct wine item IDs
			if (itemManager != null) {
				try {
					// Clear any existing icon first
					wineLabel.setIcon(null);
					// Use correct wine item IDs: Jug of sunfire wine (29384) for sunfire, Jug of
					// wine (1993) for regular
					int wineItemId = useSunfireWine ? 29384 : 1993;
					itemManager.getImage(wineItemId).addTo(wineLabel);
				} catch (Exception e) {
					log.error("Error loading wine icon", e);
				}
			}

			// Calculate wine display text
			String wineText;
			String wineType = useSunfireWine ? "Sunfire wine" : "Regular wine";

			if (goalAchieved) {
				wineText = String.format("0 %s", wineType.toLowerCase());
			} else {
				wineText = String.format("%,d %s", winesNeeded, wineType.toLowerCase());
			}

			wineLabel.setText(wineText);

			if (useSunfireWine) {
				int splintersNeeded = winesNeeded * 2;

				if (itemManager != null) {
					try {
						sunfireSplinterLabel.setIcon(null);
						itemManager.getImage(28924, 10, false).addTo(sunfireSplinterLabel);
					} catch (Exception e) {
						log.error("Error loading sunfire splinter icon", e);
					}
				}

				String splintersText;
				if (goalAchieved) {
					splintersText = "0 sunfire splinters";
				} else {
					splintersText = String.format("%,d sunfire splinters for wines", splintersNeeded);
				}

				sunfireSplinterLabel.setText(splintersText);
				sunfireSplinterLabel.setVisible(true);
			} else {
				sunfireSplinterLabel.setVisible(false);
			}

			// Update zealot robes warning
			updateZealotRobesWarning();

		} catch (Exception e) {
			log.error("Prayer Calculator: Error updating resources display", e);
			boneShardsLabel.setText("Error loading display");
			wineLabel.setText("Error loading display");
			sunfireSplinterLabel.setText("Error loading display");
		}
	}

	public void clearValidationError() {
		warningLabel.setText("<html>&nbsp;</html>");
		warningLabel.setForeground(Color.ORANGE);
	}

	private FoldingSection createResourcesRequiredSection() {
		// Create labels for the content
		boneShardsLabel = new JLabel("Calculate to see results");
		boneShardsLabel.setForeground(Color.WHITE);
		boneShardsLabel.setFont(FontManager.getRunescapeSmallFont());

		wineLabel = new JLabel("Calculate to see results");
		wineLabel.setForeground(Color.WHITE);
		wineLabel.setFont(FontManager.getRunescapeSmallFont());

		sunfireSplinterLabel = new JLabel("Calculate to see results");
		sunfireSplinterLabel.setForeground(Color.WHITE);
		sunfireSplinterLabel.setFont(FontManager.getRunescapeSmallFont());

		// Create a panel that properly handles visibility
		JPanel labelsPanel = new JPanel();
		labelsPanel.setLayout(new javax.swing.BoxLayout(labelsPanel, javax.swing.BoxLayout.Y_AXIS));
		labelsPanel.setBackground(ColorScheme.DARK_GRAY_COLOR);

		// Add labels with small borders for spacing
		boneShardsLabel.setBorder(new EmptyBorder(1, 0, 1, 0));
		wineLabel.setBorder(new EmptyBorder(1, 0, 1, 0));
		sunfireSplinterLabel.setBorder(new EmptyBorder(1, 0, 1, 0));

		labelsPanel.add(boneShardsLabel);
		labelsPanel.add(wineLabel);
		labelsPanel.add(sunfireSplinterLabel);

		// Create the folding section with the panel
		return new FoldingSection(
				"Total Resources Needed",
				"Bone shards and wines required to reach your goal",
				labelsPanel);
	}

	public void setItemManager(ItemManager itemManager) {
		this.itemManager = itemManager;
		// Refresh icons if we have results displayed
		refreshIcons();
	}

	private void refreshIcons() {
		// Refreshes the item icons if ItemManager is available
		if (itemManager == null) {
			return;
		}

		// Only refresh if we have actual results (not the default "Calculate to see
		// results" text)
		if (!boneShardsLabel.getText().equals("Calculate to see results") &&
				!boneShardsLabel.getText().equals("Calculation error")) {

			try {
				// Refresh bone shard icon
				boneShardsLabel.setIcon(null);
				itemManager.getImage(29381).addTo(boneShardsLabel);
			} catch (Exception e) {
				log.error("Error refreshing bone shard icon", e);
			}
		}

		// Only refresh wine icon if we have actual results
		if (!wineLabel.getText().equals("Calculate to see results") &&
				!wineLabel.getText().equals("Calculation error")) {

			try {
				// Determine wine type from current checkbox state
				boolean useSunfireWine = isSunfireWineSelected();
				int wineItemId = useSunfireWine ? 29384 : 1993;

				wineLabel.setIcon(null);
				itemManager.getImage(wineItemId).addTo(wineLabel);
			} catch (Exception e) {
				log.error("Error refreshing wine icon", e);
			}
		}

		if (!sunfireSplinterLabel.getText().equals("Calculate to see results") &&
				!sunfireSplinterLabel.getText().equals("Calculation error") &&
				isSunfireWineSelected() && sunfireSplinterLabel.isVisible()) {

			try {
				sunfireSplinterLabel.setIcon(null);
				itemManager.getImage(28924, 10, false).addTo(sunfireSplinterLabel);
			} catch (Exception e) {
				log.error("Error refreshing sunfire splinter icon", e);
			}
		}
	}

	public void setResourceScanner(BoneResourceScanner scanner) {
		this.resourceScanner = scanner;
	}

	public void setHiscoreClient(HiscoreClient hiscoreClient) {
		this.hiscoreClient = hiscoreClient;
	}

	private void updateZealotRobesWarning() {
		if (isZealotRobesSelected()) {
			warningLabel.setText(
					"<html>!! Zealot robes: Actual XP values may vary slightly due to resource-save triggers.</html>");
		} else {
			warningLabel.setText("<html>&nbsp;</html>"); // Non-breaking space maintains height
		}
	}

	public void updateZealotRobesWarningDisplay() {
		updateZealotRobesWarning();
	}

	private FoldingSection createResourcePlanningSection() {
		// Creates the collapsible Resource Planning section using FoldingSection.
		JPanel content = createResourcePlanningContent();

		// Create the folding section with the content
		FoldingSection section = new FoldingSection(
				"Resource Planning",
				"Scan your inventory to see how many more bones you need for your goal",
				content);

		// Set to closed by default (matching original behavior)
		section.setOpen(false);

		return section;
	}

	private JPanel createResourcePlanningContent() {
		JPanel content = new JPanel(new BorderLayout());
		content.setBackground(ColorScheme.DARK_GRAY_COLOR);
		content.setBorder(new EmptyBorder(5, 10, 5, 5)); // Indent content

		// Create scan button (will be moved below table)
		scanInventoryButton = new JButton("Scan Inventory");
		scanInventoryButton.setBackground(ColorScheme.DARKER_GRAY_COLOR);
		scanInventoryButton.setForeground(Color.WHITE);
		scanInventoryButton.setFont(FontManager.getRunescapeSmallFont());
		scanInventoryButton.setBorder(new EmptyBorder(5, 10, 5, 10));

		// Add descriptive text above the table
		JLabel descriptionLabel = new JLabel(
				"<html>Click the \"Scan Inventory\" button to find out how many more bones you need for your goal.<br/><br/>Note: This tool assumes that all bones in your inventory will be broken down into bone shards and used for Prayer training.</html>");
		descriptionLabel.setForeground(Color.LIGHT_GRAY);
		descriptionLabel.setFont(FontManager.getRunescapeSmallFont());
		descriptionLabel.setBorder(new EmptyBorder(0, 5, 8, 5)); // Add some spacing below the text

		// Create status label (will be moved below button)
		resourceStatusLabel = new JLabel("Click 'Scan Inventory' to begin.");
		resourceStatusLabel.setForeground(Color.LIGHT_GRAY);
		resourceStatusLabel.setFont(FontManager.getRunescapeSmallFont());

		// Create recommendations table
		String[] columnNames = { "Bone Type", "# Needed" };
		recommendationsTableModel = new DefaultTableModel(columnNames, 0) {
			@Override
			public boolean isCellEditable(int row, int column) {
				return false; // Make table read-only
			}
		};

		recommendationsTable = new JTable(recommendationsTableModel);
		recommendationsTable.setBackground(ColorScheme.DARKER_GRAY_COLOR);
		recommendationsTable.setForeground(Color.WHITE);
		recommendationsTable.setFont(FontManager.getRunescapeSmallFont());
		recommendationsTable.setGridColor(ColorScheme.LIGHT_GRAY_COLOR);
		recommendationsTable.getTableHeader().setBackground(ColorScheme.DARKER_GRAY_COLOR);
		recommendationsTable.getTableHeader().setForeground(Color.WHITE);
		recommendationsTable.getTableHeader().setFont(FontManager.getRunescapeSmallFont());
		recommendationsTable.setRowHeight(20);

		// Configure column widths and alignment
		setupTableColumns();

		JScrollPane scrollPane = new JScrollPane(recommendationsTable);
		scrollPane.setBackground(ColorScheme.DARKER_GRAY_COLOR);
		scrollPane.setBorder(BorderFactory.createLineBorder(ColorScheme.LIGHT_GRAY_COLOR));
		scrollPane.setPreferredSize(new Dimension(0, 150));

		JPanel buttonPanel = new JPanel(new FlowLayout(FlowLayout.CENTER));
		buttonPanel.setBackground(ColorScheme.DARK_GRAY_COLOR);
		buttonPanel.setBorder(new EmptyBorder(10, 0, 10, 0)); // Top and bottom spacing
		buttonPanel.add(scanInventoryButton);

		JPanel bottomPanel = new JPanel(new BorderLayout());
		bottomPanel.setBackground(ColorScheme.DARK_GRAY_COLOR);
		bottomPanel.add(buttonPanel, BorderLayout.NORTH);

		resourceStatusLabel.setBorder(new EmptyBorder(0, 10, 5, 10)); // Left and right padding
		bottomPanel.add(resourceStatusLabel, BorderLayout.SOUTH);

		content.add(descriptionLabel, BorderLayout.NORTH);
		content.add(scrollPane, BorderLayout.CENTER);
		content.add(bottomPanel, BorderLayout.SOUTH);

		return content;
	}

	private void setupTableColumns() {
		if (recommendationsTable.getColumnCount() >= 2) {
			recommendationsTable.getColumnModel().getColumn(0).setPreferredWidth(80); // Bone Type
			recommendationsTable.getColumnModel().getColumn(1).setPreferredWidth(20); // Needed

			// Disable column resizing to maintain proportions
			recommendationsTable.getTableHeader().setResizingAllowed(false);
			recommendationsTable.getTableHeader().setReorderingAllowed(false);

			// Set up right alignment for "Needed" column
			javax.swing.table.DefaultTableCellRenderer rightRenderer = new javax.swing.table.DefaultTableCellRenderer();
			rightRenderer.setHorizontalAlignment(javax.swing.SwingConstants.RIGHT);
			rightRenderer.setBackground(ColorScheme.DARKER_GRAY_COLOR);
			rightRenderer.setForeground(Color.WHITE);

			// Apply right alignment to "Needed" column (column 1)
			recommendationsTable.getColumnModel().getColumn(1).setCellRenderer(rightRenderer);
		}
	}

	private void performInventoryScanInternal() {
		// Performs inventory scan and calculates bone recommendations.
		if (resourceScanner == null) {
			resourceStatusLabel.setText("Error: Resource scanner not available");
			resourceStatusLabel.setForeground(Color.RED);
			return;
		}

		try {
			resourceStatusLabel.setText("Scanning inventory...");
			resourceStatusLabel.setForeground(Color.YELLOW);

			// Use ClientThread to safely access game data
			resourceScanner.getClientThread().invoke(() -> {
				try {
					// Scan inventory for bones
					Map<BoneType, Integer> inventoryBones = resourceScanner.scanInventory();

					// Calculate current total shards from inventory
					int currentShards = resourceScanner.calculateTotalShards(inventoryBones);

					// Calculate required shards for goal
					int requiredShards = calculateRequiredShards();

					// Update UI
					javax.swing.SwingUtilities.invokeLater(
							() -> updateResourceRecommendations(inventoryBones, currentShards, requiredShards));
				} catch (Exception e) {
					javax.swing.SwingUtilities.invokeLater(() -> {
						resourceStatusLabel.setText("Error scanning inventory: " + e.getMessage());
						resourceStatusLabel.setForeground(Color.RED);
					});
				}
			});
		} catch (Exception e) {
			resourceStatusLabel.setText("Error: " + e.getMessage());
			resourceStatusLabel.setForeground(Color.RED);
		}
	}

	private int calculateRequiredShards() {
		// Calculates the required shards based on current goal settings.
		try {
			// Create PrayerData from current inputs
			PrayerData prayerData = new PrayerData();
			prayerData.setCurrentLevel(getCurrentLevelInput());
			prayerData.setCurrentXP(getCurrentXPInput());
			prayerData.setTargetLevel(getTargetLevelInput());
			prayerData.setTargetXP(getTargetXPInput());
			prayerData.setUseSunfireWine(isSunfireWineSelected());
			prayerData.setUseZealotRobes(isZealotRobesSelected());

			// Use centralized calculation engine (single source of truth)
			CalculationResult result = calculationEngine.calculateForTarget(prayerData);

			return result.getRequiredShards();
		} catch (Exception e) {
			return 0;
		}
	}

	private void updateResourceRecommendations(Map<BoneType, Integer> inventoryBones, int currentShards,
			int requiredShards) {
		// Mark that we have inventory data available for recalculation
		hasInventoryData = true;

		// Clear existing recommendations
		recommendationsTableModel.setRowCount(0);

		// First, always display the bone shard value found
		if (currentShards == 0) {
			resourceStatusLabel.setText("0 bone shard value found in inventory");
			resourceStatusLabel.setForeground(Color.ORANGE);
		} else {
			resourceStatusLabel.setText(String.format("%,d bone shard value found in inventory\n", currentShards));
			resourceStatusLabel.setForeground(Color.GREEN);
		}

		if (requiredShards <= 0) {
			// Keep the shard value message but don't show recommendations
			return;
		}

		// Check if goal is already achieved
		if (currentShards >= requiredShards) {
			// Update message to show both shard value and goal achievement
			int surplus = currentShards - requiredShards;
			if (surplus > 0) {
				resourceStatusLabel.setText(String.format(
						"<html>%,d bone shard value found in inventory<br/>Goal achieved! (%,d surplus shards)</html>",
						currentShards, surplus));
			} else {
				resourceStatusLabel.setText(String.format(
						"<html>%,d bone shard value found in inventory<br/>Goal achieved! (exactly %,d needed)</html>",
						currentShards, requiredShards));
			}
			resourceStatusLabel.setForeground(Color.GREEN);

			// Show all bone types with 0 needed since goal is achieved
			List<BoneRecommendation> zeroRecommendations = generateZeroBoneRecommendations();

			// Populate table with zero recommendations (sorted by efficiency)
			for (BoneRecommendation rec : zeroRecommendations) {
				recommendationsTableModel.addRow(new Object[] {
						rec.boneType.getDisplayName(),
						String.format("%,d", rec.quantityNeeded)
				});
			}
			return;
		}

		// Calculate additional shards needed
		int additionalShards = requiredShards - currentShards;

		// Calculate percentage
		double percentage = (double) currentShards / requiredShards * 100;

		// Update status with HTML for word wrapping - show shard value first, then goal
		// progress
		resourceStatusLabel.setText(String.format(
				"<html>Your inventory contains resources worth %,d blessed bone shards (%.1f%% of goal)<br/><br/>You need to get %,d more shards to reach your XP goals </html>",
				currentShards, percentage, additionalShards));
		resourceStatusLabel.setForeground(Color.ORANGE);

		List<BoneRecommendation> recommendations = generateBoneRecommendations(additionalShards);

		// Populate table with bone types (sorted by efficiency)
		for (BoneRecommendation rec : recommendations) {
			recommendationsTableModel.addRow(new Object[] {
					rec.boneType.getDisplayName(),
					String.format("%,d", rec.quantityNeeded)
			});
		}
	}

	private List<BoneRecommendation> generateBoneRecommendations(int additionalShards) {
		List<BoneRecommendation> recommendations = new ArrayList<>();
		Set<BoneType> processedTypes = new HashSet<>();

		// Generate recommendations for each bone type, using consolidated types
		for (BoneType boneType : BoneType.values()) {
			// Skip bone shards themselves
			if (boneType == BoneType.BLESSED_BONE_SHARDS) {
				continue;
			}

			// Get the consolidated bone type (this will map unblessed to blessed versions)
			BoneType consolidatedType = getConsolidatedBoneType(boneType);

			// Skip if we've already processed this consolidated type
			if (processedTypes.contains(consolidatedType)) {
				continue;
			}

			processedTypes.add(consolidatedType);

			int shardsPerBone = consolidatedType.getShardValue();
			int quantityNeeded = (int) Math.ceil((double) additionalShards / shardsPerBone);

			recommendations.add(new BoneRecommendation(consolidatedType, quantityNeeded, shardsPerBone));
		}

		// Sort by efficiency (highest shards per bone first)
		recommendations.sort(Comparator.comparingInt((BoneRecommendation r) -> r.efficiency).reversed());

		return recommendations;
	}

	private List<BoneRecommendation> generateZeroBoneRecommendations() {
		List<BoneRecommendation> recommendations = new ArrayList<>();
		Set<BoneType> processedTypes = new HashSet<>();

		// Generate recommendations for each bone type, using consolidated types
		for (BoneType boneType : BoneType.values()) {
			// Skip bone shards themselves
			if (boneType == BoneType.BLESSED_BONE_SHARDS) {
				continue;
			}

			// Get the consolidated bone type (this will map unblessed to blessed versions)
			BoneType consolidatedType = getConsolidatedBoneType(boneType);

			// Skip if we've already processed this consolidated type
			if (processedTypes.contains(consolidatedType)) {
				continue;
			}

			processedTypes.add(consolidatedType);

			int shardsPerBone = consolidatedType.getShardValue();
			// Set quantity needed to 0 since goal is already achieved
			int quantityNeeded = 0;

			recommendations.add(new BoneRecommendation(consolidatedType, quantityNeeded, shardsPerBone));
		}

		// Sort by efficiency (highest shards per bone first)
		recommendations.sort(Comparator.comparingInt((BoneRecommendation r) -> r.efficiency).reversed());

		return recommendations;
	}

	private BoneType getConsolidatedBoneType(BoneType boneType) {
		// Gets the consolidated bone type for display purposes.
		switch (boneType) {
			case BLESSED_BONE_STATUETTE1:
			case BLESSED_BONE_STATUETTE2:
			case BLESSED_BONE_STATUETTE3:
			case BLESSED_BONE_STATUETTE4:
				return BoneType.BLESSED_BONE_STATUETTE0; // Use the first one as the consolidated entry
			case BONES:
				return BoneType.BLESSED_BONES;
			case BAT_BONES:
				return BoneType.BLESSED_BAT_BONES;
			case BIG_BONES:
				return BoneType.BLESSED_BIG_BONES;
			case BABYDRAGON_BONES:
				return BoneType.BLESSED_BABYDRAGON_BONES;
			case DRAGON_BONES:
				return BoneType.BLESSED_DRAGON_BONES;
			case WYVERN_BONES:
				return BoneType.BLESSED_WYVERN_BONES;
			case DRAKE_BONES:
				return BoneType.BLESSED_DRAKE_BONES;
			case FAYRG_BONES:
				return BoneType.BLESSED_FAYRG_BONES;
			case LAVA_DRAGON_BONES:
				return BoneType.BLESSED_LAVA_DRAGON_BONES;
			case RAURG_BONES:
				return BoneType.BLESSED_RAURG_BONES;
			case DAGANNOTH_BONES:
				return BoneType.BLESSED_DAGANNOTH_BONES;
			case OURG_BONES:
				return BoneType.BLESSED_OURG_BONES;
			case SUPERIOR_DRAGON_BONES:
				return BoneType.BLESSED_SUPERIOR_DRAGON_BONES;
			case BABYWYRM_BONES:
				return BoneType.BLESSED_BABYWYRM_BONES;
			case WYRM_BONES:
				return BoneType.BLESSED_WYRM_BONES;
			case HYDRA_BONES:
				return BoneType.BLESSED_HYDRA_BONES;
			case ZOGRE_BONES:
				return BoneType.BLESSED_ZOGRE_BONES;
			case FROST_DRAGON_BONES:
				return BoneType.BLESSED_FROST_DRAGON_BONES;
			case STRYKEWYRM_BONES:
				return BoneType.BLESSED_STRYKEWYRM_BONES;
			default:
				return boneType; // Return original type for blessed bones and special types
		}
	}

	private static class BoneRecommendation {
		final BoneType boneType;
		final int quantityNeeded;
		final int efficiency;

		BoneRecommendation(BoneType boneType, int quantityNeeded, int efficiency) {
			this.boneType = boneType;
			this.quantityNeeded = quantityNeeded;
			this.efficiency = efficiency;
		}
	}

	private static int getInput(JTextField field) {
		try {
			return Integer.parseInt(NON_NUMERIC.matcher(field.getText()).replaceAll(""));
		} catch (NumberFormatException e) {
			return 0;
		}
	}

	private static void setInput(JTextField field, Object value) {
		field.setText(String.valueOf(value));
	}

	private JTextField addComponent(JPanel parent, String label) {
		final JPanel container = new JPanel();
		container.setLayout(new BorderLayout());
		container.setBackground(ColorScheme.DARK_GRAY_COLOR);

		final JLabel uiLabel = new JLabel(label);
		final FlatTextField uiInput = new FlatTextField();

		uiInput.setBackground(ColorScheme.DARKER_GRAY_COLOR);
		uiInput.setHoverBackgroundColor(ColorScheme.DARK_GRAY_HOVER_COLOR);
		uiInput.setBorder(new EmptyBorder(5, 7, 5, 7));

		uiLabel.setFont(FontManager.getRunescapeSmallFont());
		uiLabel.setBorder(new EmptyBorder(0, 0, 4, 0));
		uiLabel.setForeground(Color.WHITE);

		container.add(uiLabel, BorderLayout.NORTH);
		container.add(uiInput, BorderLayout.CENTER);

		parent.add(container);

		return uiInput.getTextField();
	}

	private JCheckBox addCheckboxComponent(JPanel parent, String label) {
		final JPanel container = new JPanel();
		container.setLayout(new BorderLayout());
		container.setBackground(ColorScheme.DARK_GRAY_COLOR);

		final JCheckBox checkbox = new JCheckBox(label);
		checkbox.setBackground(ColorScheme.DARK_GRAY_COLOR);
		checkbox.setForeground(Color.WHITE);
		checkbox.setFont(FontManager.getRunescapeSmallFont());
		checkbox.setBorder(new EmptyBorder(5, 7, 5, 7));

		container.add(checkbox, BorderLayout.CENTER);
		parent.add(container);

		return checkbox;
	}

	private FoldingSection createDebugSection() {
		// Create hiscore lookup field. Only used when debugging is enabled
		hiscoreLookupField = new IconTextField();
		hiscoreLookupField.setIcon(IconTextField.Icon.SEARCH);
		hiscoreLookupField.setPreferredSize(new Dimension(PluginPanel.PANEL_WIDTH - 20, 25));
		hiscoreLookupField.setBackground(ColorScheme.DARKER_GRAY_COLOR);
		hiscoreLookupField.setHoverBackgroundColor(ColorScheme.DARK_GRAY_HOVER_COLOR);
		hiscoreLookupField.setMinimumSize(new Dimension(0, 25));
		hiscoreLookupField.addActionListener(e -> performHiscoreLookup());
		hiscoreLookupField.addClearListener(() -> {
			hiscoreLookupField.setIcon(IconTextField.Icon.SEARCH);
			hiscoreLookupField.setEditable(true);
			// Clear status message when field is cleared
			debugStatusLabel.setText("<html></html>");
		});

		// Create debug status label with word wrap
		debugStatusLabel = new JLabel("");
		debugStatusLabel.setForeground(Color.LIGHT_GRAY);
		debugStatusLabel.setFont(FontManager.getRunescapeSmallFont());
		debugStatusLabel.setVerticalAlignment(javax.swing.SwingConstants.TOP);

		// Add descriptive text above the search field
		JLabel descriptionLabel = new JLabel(
				"<html>Lookup a player's name to populate the Current Level/XP and Target Level/XP boxes with that player's Prayer level and a sensible default goal.</html>");
		descriptionLabel.setForeground(Color.LIGHT_GRAY);
		descriptionLabel.setFont(FontManager.getRunescapeSmallFont());
		descriptionLabel.setBorder(new javax.swing.border.EmptyBorder(0, 5, 8, 5)); // Add some spacing below the text

		// Create content panel
		JPanel contentPanel = new JPanel(new BorderLayout());
		contentPanel.setBackground(ColorScheme.DARK_GRAY_COLOR);
		contentPanel.add(descriptionLabel, BorderLayout.NORTH);
		contentPanel.add(hiscoreLookupField, BorderLayout.CENTER);
		contentPanel.add(debugStatusLabel, BorderLayout.SOUTH);

		// Create the folding section
		FoldingSection section = new FoldingSection(
				"DEBUG: PLAYER LOOKUP",
				"Player lookup functionality for testing and debugging",
				contentPanel);

		// Initially hidden and closed
		section.setVisible(false);
		section.setOpen(false);

		return section;
	}

	private void performHiscoreLookup() {
		// Lookup player name using HiscoreClient and populate current/target fields
		String username = hiscoreLookupField.getText().trim();
		if (username.isEmpty()) {
			return;
		}

		// Validate username length
		if (username.length() > 12) {
			hiscoreLookupField.setIcon(IconTextField.Icon.ERROR);
			return;
		}

		// Check if HiscoreClient is available
		if (hiscoreClient == null) {
			hiscoreLookupField.setIcon(IconTextField.Icon.ERROR);
			debugStatusLabel.setText("<html>Error: HiscoreClient not available</html>");
			return;
		}

		// Set loading state
		hiscoreLookupField.setEditable(false);
		hiscoreLookupField.setIcon(IconTextField.Icon.LOADING_DARKER);
		debugStatusLabel.setText("<html></html>"); // Clear previous status

		// Capture username for use in async callback
		final String finalUsername = username;

		// Perform async lookup using RuneLite's HiscoreClient
		java.util.concurrent.CompletableFuture.supplyAsync(() -> {
			try {
				return hiscoreClient.lookup(finalUsername);
			} catch (Exception e) {
				log.error("Error fetching hiscore data for player: " + finalUsername, e);
				return null;
			}
		}).whenCompleteAsync((hiscoreResult, ex) -> javax.swing.SwingUtilities.invokeLater(() -> {
			// Reset field state
			hiscoreLookupField.setEditable(true);

			if (hiscoreResult == null || ex != null) {
				hiscoreLookupField.setIcon(IconTextField.Icon.ERROR);
				debugStatusLabel.setText("<html>Player not found or hiscores unavailable</html>");
				return;
			}

			// Success - extract Prayer skill data
			hiscoreLookupField.setIcon(IconTextField.Icon.SEARCH);
			try {
				// Get Prayer skill from hiscore result
				net.runelite.client.hiscore.Skill prayerSkill = hiscoreResult.getSkill(HiscoreSkill.PRAYER);
				if (prayerSkill == null) {
					hiscoreLookupField.setIcon(IconTextField.Icon.ERROR);
					debugStatusLabel.setText("<html>Prayer data not available for this player</html>");
					return;
				}

				long prayerXP = prayerSkill.getExperience();
				int prayerXPInt = (int) Math.min(prayerXP, Integer.MAX_VALUE);
				int prayerLevel = net.runelite.api.Experience.getLevelForXp(prayerXPInt);

				// Calculate target: next level for most players, or 200M XP for high-level players
				int targetLevel;
				int targetXP;

				if (prayerLevel >= 99) {
					// For level 99+ players, default to 200M XP goal
					targetXP = net.runelite.api.Experience.MAX_SKILL_XP;
					targetLevel = net.runelite.api.Experience.getLevelForXp(targetXP);
				} else {
					// For lower level players, target next level
					targetLevel = Math.min(prayerLevel + 1, net.runelite.api.Experience.MAX_VIRT_LEVEL);
					targetXP = net.runelite.api.Experience.getXpForLevel(targetLevel);
				}

				// Update current XP and level fields
				setCurrentXPInput(String.format("%,d", prayerXPInt));
				setCurrentLevelInput(prayerLevel);

				// Update target XP and level fields
				setTargetLevelInput(targetLevel);
				setTargetXPInput(String.format("%,d", targetXP));

				// Update calculations
				updateBoneShardsRequired();

				// Show success status message with word wrap
				debugStatusLabel.setText(
						"<html>Current/target fields populated using Prayer level lookup for \"" + finalUsername
								+ "\"</html>");

			} catch (Exception e) {
				log.error("Error processing hiscore result", e);
				hiscoreLookupField.setIcon(IconTextField.Icon.ERROR);
				debugStatusLabel.setText("<html>Error processing player data</html>");
			}
		}));
	}

	public void setDebugMode(boolean debugMode, BoneShardHelperPanel parentPanel) {
		if (debugSection != null) {
			debugSection.setVisible(debugMode);
			revalidate();
			repaint();
		}
	}

}
package com.boneshardhelper;

import java.util.HashMap;
import java.util.Map;

public class CalculationResult {
    private int requiredShards;
    private int achievableLevel;
    private int totalAvailableShards;
    private Map<BoneType, Integer> boneBreakdown;
    private int remainingXP;
    private int totalXPGain;
    private boolean hasEnoughResources;
    private int xpPerShard;
    private boolean goalAlreadyAchieved;
    private int winesNeeded;

    public CalculationResult() {
        this.requiredShards = 0;
        this.achievableLevel = 1;
        this.totalAvailableShards = 0;
        this.boneBreakdown = new HashMap<>();
        this.remainingXP = 0;
        this.totalXPGain = 0;
        this.hasEnoughResources = false;
        this.xpPerShard = 5; // Default to regular wine
        this.goalAlreadyAchieved = false;
        this.winesNeeded = 0;
    }

    public CalculationResult(int requiredShards, int achievableLevel, int totalAvailableShards) {
        this.requiredShards = requiredShards;
        this.achievableLevel = achievableLevel;
        this.totalAvailableShards = totalAvailableShards;
        this.boneBreakdown = new HashMap<>();
        this.remainingXP = 0;
        this.totalXPGain = 0;
        this.hasEnoughResources = totalAvailableShards >= requiredShards;
        this.xpPerShard = 5; // Default to regular wine
        this.goalAlreadyAchieved = false;
        this.winesNeeded = 0;
    }

    public CalculationResult(int requiredShards, int achievableLevel, int totalAvailableShards, int xpPerShard) {
        this.requiredShards = requiredShards;
        this.achievableLevel = achievableLevel;
        this.totalAvailableShards = totalAvailableShards;
        this.boneBreakdown = new HashMap<>();
        this.remainingXP = 0;
        this.totalXPGain = 0;
        this.hasEnoughResources = totalAvailableShards >= requiredShards;
        this.xpPerShard = xpPerShard;
        this.goalAlreadyAchieved = false;
        this.winesNeeded = 0;
    }

    // Getters and setters
    public int getRequiredShards() {
        return requiredShards;
    }

    public void setRequiredShards(int requiredShards) {
        this.requiredShards = requiredShards;
        updateHasEnoughResources();
    }

    public int getAchievableLevel() {
        return achievableLevel;
    }

    public void setAchievableLevel(int achievableLevel) {
        this.achievableLevel = achievableLevel;
    }

    public int getTotalAvailableShards() {
        return totalAvailableShards;
    }

    public void setTotalAvailableShards(int totalAvailableShards) {
        this.totalAvailableShards = totalAvailableShards;
        updateHasEnoughResources();
    }

    public Map<BoneType, Integer> getBoneBreakdown() {
        return new HashMap<>(boneBreakdown);
    }

    public void setBoneBreakdown(Map<BoneType, Integer> boneBreakdown) {
        this.boneBreakdown = new HashMap<>(boneBreakdown);
    }

    public int getRemainingXP() {
        return remainingXP;
    }

    public void setRemainingXP(int remainingXP) {
        this.remainingXP = remainingXP;
    }

    public int getTotalXPGain() {
        return totalXPGain;
    }

    public void setTotalXPGain(int totalXPGain) {
        this.totalXPGain = totalXPGain;
    }

    public boolean hasEnoughResources() {
        return hasEnoughResources;
    }

    public void setHasEnoughResources(boolean hasEnoughResources) {
        this.hasEnoughResources = hasEnoughResources;
    }

    public int getXpPerShard() {
        return xpPerShard;
    }

    public void setXpPerShard(int xpPerShard) {
        this.xpPerShard = xpPerShard;
    }

    public boolean isGoalAlreadyAchieved() {
        return goalAlreadyAchieved;
    }

    public void setGoalAlreadyAchieved(boolean goalAlreadyAchieved) {
        this.goalAlreadyAchieved = goalAlreadyAchieved;
    }

    public int getWinesNeeded() {
        return winesNeeded;
    }

    public void setWinesNeeded(int winesNeeded) {
        this.winesNeeded = winesNeeded;
    }

    private void updateHasEnoughResources() {
        // Update the hasEnoughResources flag based on current values.
        this.hasEnoughResources = totalAvailableShards >= requiredShards;
    }

    public int getShardShortage() {
        // Gets the shortage of shards if resources are insufficient.
        return Math.max(0, requiredShards - totalAvailableShards);
    }

    public int getExcessShards() {
        // Gets the excess shards if resources exceed requirements.
        return Math.max(0, totalAvailableShards - requiredShards);
    }

    public boolean isValid() {
        // Checks if this result represents a valid calculation.
        return achievableLevel > 0 && (requiredShards > 0 || totalAvailableShards > 0);
    }

    @Override
    public String toString() {
        return "CalculationResult{" +
                "requiredShards=" + requiredShards +
                ", achievableLevel=" + achievableLevel +
                ", totalAvailableShards=" + totalAvailableShards +
                ", boneTypes=" + boneBreakdown.size() +
                ", remainingXP=" + remainingXP +
                ", totalXPGain=" + totalXPGain +
                ", hasEnoughResources=" + hasEnoughResources +
                ", xpPerShard=" + xpPerShard +
                ", goalAlreadyAchieved=" + goalAlreadyAchieved +
                ", winesNeeded=" + winesNeeded +
                '}';
    }
}
package com.boneshardhelper;

import net.runelite.api.Client;
import net.runelite.api.Item;
import net.runelite.api.ItemContainer;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.game.ItemManager;

import javax.inject.Inject;
import javax.inject.Singleton;
import java.util.HashMap;
import java.util.Map;

@Singleton
public class BoneResourceScanner {

    private final Client client;
    private final ClientThread clientThread;
    private final ItemManager itemManager;

    // Mapping from item IDs to BoneType enum values
    // Built dynamically from the BoneType enum data
    private static final Map<Integer, BoneType> ITEM_TO_BONE_TYPE_MAPPING = new HashMap<>();

    // Mapping for consolidating bone types (unblessed -> blessed)
    private static final Map<BoneType, BoneType> BONE_TYPE_CONSOLIDATION = new HashMap<>();

    static {
        // Build mappings from the BoneType enum data
        for (BoneType boneType : BoneType.values()) {
            int itemId = boneType.getBaseItemId();
            if (itemId > 0) {
                ITEM_TO_BONE_TYPE_MAPPING.put(itemId, boneType);

                // Map noted versions (base + 1) for unblessed bones only
                if (!boneType.name().startsWith("BLESSED_") && !boneType.name().equals("SUN_KISSED_BONES")) {
                    ITEM_TO_BONE_TYPE_MAPPING.put(itemId + 1, boneType);
                }
            }
        }

        // Build consolidation mapping (unblessed -> blessed)
        BONE_TYPE_CONSOLIDATION.put(BoneType.BONES, BoneType.BLESSED_BONES);
        BONE_TYPE_CONSOLIDATION.put(BoneType.BAT_BONES, BoneType.BLESSED_BAT_BONES);
        BONE_TYPE_CONSOLIDATION.put(BoneType.BIG_BONES, BoneType.BLESSED_BIG_BONES);
        BONE_TYPE_CONSOLIDATION.put(BoneType.BABYDRAGON_BONES, BoneType.BLESSED_BABYDRAGON_BONES);
        BONE_TYPE_CONSOLIDATION.put(BoneType.DRAGON_BONES, BoneType.BLESSED_DRAGON_BONES);
        BONE_TYPE_CONSOLIDATION.put(BoneType.WYVERN_BONES, BoneType.BLESSED_WYVERN_BONES);
        BONE_TYPE_CONSOLIDATION.put(BoneType.DRAKE_BONES, BoneType.BLESSED_DRAKE_BONES);
        BONE_TYPE_CONSOLIDATION.put(BoneType.FAYRG_BONES, BoneType.BLESSED_FAYRG_BONES);
        BONE_TYPE_CONSOLIDATION.put(BoneType.LAVA_DRAGON_BONES, BoneType.BLESSED_LAVA_DRAGON_BONES);
        BONE_TYPE_CONSOLIDATION.put(BoneType.RAURG_BONES, BoneType.BLESSED_RAURG_BONES);
        BONE_TYPE_CONSOLIDATION.put(BoneType.DAGANNOTH_BONES, BoneType.BLESSED_DAGANNOTH_BONES);
        BONE_TYPE_CONSOLIDATION.put(BoneType.OURG_BONES, BoneType.BLESSED_OURG_BONES);
        BONE_TYPE_CONSOLIDATION.put(BoneType.SUPERIOR_DRAGON_BONES, BoneType.BLESSED_SUPERIOR_DRAGON_BONES);
        BONE_TYPE_CONSOLIDATION.put(BoneType.BABYWYRM_BONES, BoneType.BLESSED_BABYWYRM_BONES);
        BONE_TYPE_CONSOLIDATION.put(BoneType.WYRMLING_BONES, BoneType.BLESSED_BABYWYRM_BONES);
        BONE_TYPE_CONSOLIDATION.put(BoneType.WYRM_BONES, BoneType.BLESSED_WYRM_BONES);
        BONE_TYPE_CONSOLIDATION.put(BoneType.HYDRA_BONES, BoneType.BLESSED_HYDRA_BONES);
        BONE_TYPE_CONSOLIDATION.put(BoneType.ZOGRE_BONES, BoneType.BLESSED_ZOGRE_BONES);
        BONE_TYPE_CONSOLIDATION.put(BoneType.FROST_DRAGON_BONES, BoneType.BLESSED_FROST_DRAGON_BONES);
        BONE_TYPE_CONSOLIDATION.put(BoneType.STRYKEWYRM_BONES, BoneType.BLESSED_STRYKEWYRM_BONES);

        // Consolidate blessed bone statuette variations
        BONE_TYPE_CONSOLIDATION.put(BoneType.BLESSED_BONE_STATUETTE1, BoneType.BLESSED_BONE_STATUETTE0);
        BONE_TYPE_CONSOLIDATION.put(BoneType.BLESSED_BONE_STATUETTE2, BoneType.BLESSED_BONE_STATUETTE0);
        BONE_TYPE_CONSOLIDATION.put(BoneType.BLESSED_BONE_STATUETTE3, BoneType.BLESSED_BONE_STATUETTE0);
        BONE_TYPE_CONSOLIDATION.put(BoneType.BLESSED_BONE_STATUETTE4, BoneType.BLESSED_BONE_STATUETTE0);
    }

    @Inject
    public BoneResourceScanner(Client client, ClientThread clientThread, ItemManager itemManager) {
        this.client = client;
        this.clientThread = clientThread;
        this.itemManager = itemManager;
    }

    public ClientThread getClientThread() {
        return clientThread;
    }

    public ItemManager getItemManager() {
        return itemManager;
    }

    public Map<BoneType, Integer> scanInventory() {
        Map<BoneType, Integer> bones = new HashMap<>();

        ItemContainer inventory = client.getItemContainer(93); // Inventory container ID
        if (inventory == null) {
            return bones;
        }

        Item[] items = inventory.getItems();
        if (items == null) {
            return bones;
        }

        for (Item item : items) {
            if (item == null || item.getId() <= 0) {
                continue;
            }

            BoneType boneType = getBoneTypeForItem(item.getId());
            if (boneType != null) {
                BoneType consolidatedType = consolidateBoneType(boneType);
                bones.merge(consolidatedType, item.getQuantity(), Integer::sum);
            }
        }

        return bones;
    }

    public int calculateTotalShards(Map<BoneType, Integer> boneResources) {
        return boneResources.entrySet().stream()
                .mapToInt(entry -> entry.getKey().getShardValue() * entry.getValue())
                .sum();
    }

    public int scanAndCalculateTotalShards() {
        return calculateTotalShards(scanInventory());
    }

    public static BoneType getBoneTypeForItem(int itemId) {
        return ITEM_TO_BONE_TYPE_MAPPING.get(itemId);
    }

    public static boolean isBoneItem(int itemId) {
        return ITEM_TO_BONE_TYPE_MAPPING.containsKey(itemId);
    }

    private BoneType consolidateBoneType(BoneType boneType) {
        // Consolidates bone types (unblessed -> blessed, statuette variations -> base).
        return BONE_TYPE_CONSOLIDATION.getOrDefault(boneType, boneType);
    }
}
package com.boneshardhelper;

import java.awt.image.BufferedImage;
import java.util.HashMap;
import java.util.Map;
import javax.inject.Inject;
import com.google.inject.Provider;
import com.google.inject.Provides;
import lombok.Getter;
import net.runelite.api.Client;
import net.runelite.api.Tile;
import net.runelite.api.TileObject;
import net.runelite.api.events.DecorativeObjectDespawned;
import net.runelite.api.events.DecorativeObjectSpawned;
import net.runelite.api.events.GameObjectDespawned;
import net.runelite.api.events.GameObjectSpawned;
import net.runelite.api.events.GameStateChanged;
import net.runelite.api.events.GroundObjectDespawned;
import net.runelite.api.events.GroundObjectSpawned;
import net.runelite.api.events.WallObjectDespawned;
import net.runelite.api.events.WallObjectSpawned;
import net.runelite.api.events.VarbitChanged;
import net.runelite.api.gameval.VarbitID;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.plugins.PluginDescriptor;
import net.runelite.client.ui.ClientToolbar;
import net.runelite.client.ui.NavigationButton;
import net.runelite.client.ui.overlay.OverlayManager;
import net.runelite.client.util.ImageUtil;

@PluginDescriptor(name = "Bone Shard Helper", description = "A helper plugin for Prayer training using bone shards in Varlamore.", tags = {
		"prayer", "varlamore", "calculator", "planning", "bone", "xp", "training", "wine", "shard", "blessed",
		"skilling", "teomat", "ralos" })
public class BoneShardHelperPlugin extends Plugin {
	@Inject
	private Client client;

	@Inject
	private ClientToolbar clientToolbar;

	@Inject
	private Provider<BoneShardHelperPanel> uiPanel;

	@Inject
	private OverlayManager overlayManager;

	@Inject
	private PrayerObjectOverlay prayerObjectOverlay;

	@Inject
	private BoneShardOverlay2D boneShardOverlay2D;

	@Inject
	private BoneShardTrainingState trainingState;

	@Getter
	private final Map<TileObject, PrayerObject> prayerObjects = new HashMap<>();

	private NavigationButton uiNavigationButton;

	@Provides
	BoneShardHelperConfig getConfig(ConfigManager configManager) {
		return configManager.getConfig(BoneShardHelperConfig.class);
	}

	@Override
	protected void startUp() throws Exception {
		final BufferedImage icon = ImageUtil.loadImageResource(getClass(), "/bone_shard_helper_icon.png");

		uiNavigationButton = NavigationButton.builder()
				.tooltip("Bone Shard Helper")
				.icon(icon)
				.priority(6)
				.panel(uiPanel.get())
				.build();

		clientToolbar.addNavigation(uiNavigationButton);

		// Set plugin reference in overlay to avoid circular dependency
		prayerObjectOverlay.setPlugin(this);
		overlayManager.add(prayerObjectOverlay);
		overlayManager.add(boneShardOverlay2D);
	}

	@Override
	protected void shutDown() throws Exception {
		clientToolbar.removeNavigation(uiNavigationButton);
		overlayManager.remove(prayerObjectOverlay);
		overlayManager.remove(boneShardOverlay2D);
		prayerObjects.clear();
	}

	@Subscribe
	public void onConfigChanged(net.runelite.client.events.ConfigChanged event) {
		if ("boneshardhelper".equals(event.getGroup())) {
			if ("debugMode".equals(event.getKey())) {
				boolean debugMode = Boolean.parseBoolean(event.getNewValue());
				uiPanel.get().updateDebugMode(debugMode);
			}
		}
	}

	@Subscribe
	public void onGameStateChanged(GameStateChanged event) {
		switch (event.getGameState()) {
			case HOPPING:
			case LOGIN_SCREEN:
			case LOADING:
				prayerObjects.clear();
				break;
		}
	}

	@Subscribe
	public void onGameObjectSpawned(GameObjectSpawned event) {
		onTileObject(event.getTile(), null, event.getGameObject());
	}

	@Subscribe
	public void onGameObjectDespawned(GameObjectDespawned event) {
		onTileObject(event.getTile(), event.getGameObject(), null);
	}

	@Subscribe
	public void onGroundObjectSpawned(GroundObjectSpawned event) {
		onTileObject(event.getTile(), null, event.getGroundObject());
	}

	@Subscribe
	public void onGroundObjectDespawned(GroundObjectDespawned event) {
		onTileObject(event.getTile(), event.getGroundObject(), null);
	}

	@Subscribe
	public void onWallObjectSpawned(WallObjectSpawned event) {
		onTileObject(event.getTile(), null, event.getWallObject());
	}

	@Subscribe
	public void onWallObjectDespawned(WallObjectDespawned event) {
		onTileObject(event.getTile(), event.getWallObject(), null);
	}

	@Subscribe
	public void onDecorativeObjectSpawned(DecorativeObjectSpawned event) {
		onTileObject(event.getTile(), null, event.getDecorativeObject());
	}

	@Subscribe
	public void onDecorativeObjectDespawned(DecorativeObjectDespawned event) {
		onTileObject(event.getTile(), event.getDecorativeObject(), null);
	}

	@Subscribe
	public void onVarbitChanged(VarbitChanged event) {
		// Listen for VARLAMORE_PRAYER_WINEQUANT (tracks wine in libation bowl)
		if (event.getVarbitId() == VarbitID.VARLAMORE_PRAYER_WINEQUANT) {
			trainingState.onVarbitChanged(event.getValue());
		}
	}

	private void onTileObject(Tile tile, TileObject oldObject, TileObject newObject) {
		// Remove old object if it exists
		prayerObjects.remove(oldObject);

		if (newObject == null) {
			return;
		}

		// Check if this is a prayer object we should track
		if (PrayerObject.PRAYER_OBJECT_IDS.contains(newObject.getId())) {
			PrayerObject prayerObject = PrayerObject.fromTileObject(tile, newObject);
			if (prayerObject != null) {
				prayerObjects.put(newObject, prayerObject);
			}
		}
	}
}
package com.boneshardhelper;

import net.runelite.client.RuneLite;
import net.runelite.client.externalplugins.ExternalPluginManager;

public class BoneShardHelperPluginTest
{
	public static void main(String[] args) throws Exception
	{
		ExternalPluginManager.loadBuiltin(BoneShardHelperPlugin.class);
		RuneLite.main(args);
	}
}
