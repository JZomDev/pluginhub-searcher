/*
BSD 2-Clause License

Copyright (c) 2022, LlemonDuck
Copyright (c) 2022, TheStonedTurtle
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

1. Redistributions of source code must retain the above copyright notice, this
   list of conditions and the following disclaimer.

2. Redistributions in binary form must reproduce the above copyright notice,
   this list of conditions and the following disclaimer in the documentation
   and/or other materials provided with the distribution.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/
package com.raidtracker.toapointstracker.util;

import lombok.Value;

@Value
public class RaidState
{

	private final boolean inLobby;
	private final boolean inRaid;
	private final RaidRoom currentRoom;
	private final int playerCount;

}

/*
BSD 2-Clause License

Copyright (c) 2022, LlemonDuck
Copyright (c) 2022, TheStonedTurtle
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

1. Redistributions of source code must retain the above copyright notice, this
   list of conditions and the following disclaimer.

2. Redistributions in binary form must reproduce the above copyright notice,
   this list of conditions and the following disclaimer in the documentation
   and/or other materials provided with the distribution.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/
package com.raidtracker.toapointstracker.util;

import lombok.Value;

@Value
public class RaidStateChanged
{

	private final RaidState previousState;
	private final RaidState newState;

}

/*
BSD 2-Clause License

Copyright (c) 2022, LlemonDuck
Copyright (c) 2022, TheStonedTurtle
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

1. Redistributions of source code must retain the above copyright notice, this
   list of conditions and the following disclaimer.

2. Redistributions in binary form must reproduce the above copyright notice,
   this list of conditions and the following disclaimer in the documentation
   and/or other materials provided with the distribution.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/
package com.raidtracker.toapointstracker.util;

import com.raidtracker.toapointstracker.module.PluginLifecycleComponent;
import javax.inject.Inject;
import javax.inject.Singleton;
import lombok.Getter;
import lombok.RequiredArgsConstructor;
import net.runelite.api.Client;
import net.runelite.api.Varbits;
import net.runelite.api.coords.LocalPoint;
import net.runelite.api.coords.WorldPoint;
import net.runelite.api.events.GameStateChanged;
import net.runelite.api.events.GameTick;
import net.runelite.api.widgets.Widget;
import net.runelite.client.eventbus.EventBus;
import net.runelite.client.eventbus.Subscribe;

@Singleton
@RequiredArgsConstructor(onConstructor_ = @Inject)
public class RaidStateTracker implements PluginLifecycleComponent
{

	private static final int REGION_LOBBY = 13454;
	private static final int WIDGET_PARENT_ID = 481;
	private static final int WIDGET_CHILD_ID = 40;

	private static final RaidState DEFAULT_STATE = new RaidState(false, false, null, 0);

	private final Client client;
	private final EventBus eventBus;

	@Getter
	private RaidState currentState = DEFAULT_STATE;

	// delay inRaid = false by 3 ticks to alleviate any unexpected delays between rooms
	private int raidLeaveTicks = 0;

	@Override
	public void startUp()
	{
		eventBus.register(this);
	}

	@Override
	public void shutDown()
	{
		eventBus.unregister(this);
	}

	@Subscribe(priority = 5)
	public void onGameTick(GameTick e)
	{
		LocalPoint lp = client.getLocalPlayer().getLocalLocation();
		int region = lp == null ? -1 : WorldPoint.fromLocalInstance(client, lp).getRegionID();

		Widget w = client.getWidget(WIDGET_PARENT_ID, WIDGET_CHILD_ID);

		boolean inLobby = region == REGION_LOBBY;
		RaidRoom currentRoom = RaidRoom.forRegionId(region);
		boolean inRaidRaw = currentRoom != null || (w != null && !w.isHidden());

		raidLeaveTicks = inRaidRaw ? 3 : raidLeaveTicks - 1;
		boolean inRaid = raidLeaveTicks > 0;

		setRaidState(new RaidState(inLobby, inRaid, currentRoom, countPlayers()), false);
	}

	public int getPlayerCount()
	{
		return this.currentState.getPlayerCount();
	}

	@Subscribe
	public void onGameStateChanged(GameStateChanged e)
	{
		switch (e.getGameState())
		{
			case LOGGING_IN:
			case HOPPING:
				raidLeaveTicks = 0;
				setRaidState(DEFAULT_STATE, true);
		}
	}

	private void setRaidState(RaidState newValue, boolean forceEvent)
	{
		RaidState previous = currentState;
		currentState = newValue;

		if (forceEvent || !currentState.equals(previous))
		{
			eventBus.post(new RaidStateChanged(previous, currentState));
		}
	}

	private int countPlayers()
	{
		return 1 +
			(client.getVarbitValue(Varbits.TOA_MEMBER_1_HEALTH) != 0 ? 1 : 0) +
			(client.getVarbitValue(Varbits.TOA_MEMBER_2_HEALTH) != 0 ? 1 : 0) +
			(client.getVarbitValue(Varbits.TOA_MEMBER_3_HEALTH) != 0 ? 1 : 0) +
			(client.getVarbitValue(Varbits.TOA_MEMBER_4_HEALTH) != 0 ? 1 : 0) +
			(client.getVarbitValue(Varbits.TOA_MEMBER_5_HEALTH) != 0 ? 1 : 0) +
			(client.getVarbitValue(Varbits.TOA_MEMBER_6_HEALTH) != 0 ? 1 : 0) +
			(client.getVarbitValue(Varbits.TOA_MEMBER_7_HEALTH) != 0 ? 1 : 0);
	}
}
/*
BSD 2-Clause License

Copyright (c) 2022, LlemonDuck
Copyright (c) 2022, TheStonedTurtle
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

1. Redistributions of source code must retain the above copyright notice, this
   list of conditions and the following disclaimer.

2. Redistributions in binary form must reproduce the above copyright notice,
   this list of conditions and the following disclaimer in the documentation
   and/or other materials provided with the distribution.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/
package com.raidtracker.toapointstracker.util;

import lombok.Getter;
import lombok.RequiredArgsConstructor;

@RequiredArgsConstructor
public enum RaidRoom
{

	NEXUS(new int[]{14160}, "Nexus", RaidRoomType.LOBBY),
	CRONDIS(new int[]{15698}, "Crondis", RaidRoomType.PUZZLE),
	ZEBAK(new int[]{15700}, "Zebak", RaidRoomType.BOSS),
	SCABARAS(new int[]{14162}, "Scabaras", RaidRoomType.PUZZLE),
	KEPHRI(new int[]{14164}, "Kephri", RaidRoomType.BOSS),
	APMEKEN(new int[]{15186}, "Apmeken", RaidRoomType.PUZZLE),
	BABA(new int[]{15188}, "Ba-Ba", RaidRoomType.BOSS),
	HET(new int[]{14674}, "Het", RaidRoomType.PUZZLE),
	AKKHA(new int[]{14676}, "Akkha", RaidRoomType.BOSS),
	WARDENS(new int[]{15184, 15696}, "Wardens", RaidRoomType.BOSS),
	TOMB(new int[]{14672}, "Tomb", RaidRoomType.LOBBY);

	public enum RaidRoomType
	{
		LOBBY,
		PUZZLE,
		BOSS;
	}

	private final int[] regionIds;

	@Getter
	private final String displayName;

	@Getter
	private final RaidRoomType roomType;

	public static RaidRoom forRegionId(int region)
	{
		for (RaidRoom r : RaidRoom.values())
		{
			for (int regionId : r.regionIds)
			{
				if (regionId == region)
				{
					return r;
				}
			}
		}

		return null;
	}

	public static RaidRoom forString(String roomName)
	{
		for (RaidRoom r : RaidRoom.values())
		{
			if (r.getDisplayName().equals(roomName))
			{
				return r;
			}
		}

		return null;
	}

	@Override
	public String toString()
	{
		return displayName;
	}
}

/*
BSD 2-Clause License

Copyright (c) 2022, LlemonDuck
Copyright (c) 2022, TheStonedTurtle
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

1. Redistributions of source code must retain the above copyright notice, this
   list of conditions and the following disclaimer.

2. Redistributions in binary form must reproduce the above copyright notice,
   this list of conditions and the following disclaimer in the documentation
   and/or other materials provided with the distribution.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/
package com.raidtracker.toapointstracker.util;

import java.awt.Color;
import lombok.Getter;
import lombok.RequiredArgsConstructor;

@RequiredArgsConstructor
public enum RaidMode
{

	ENTRY_MODE(0, 149, new Color(255, 208, 73)),
	NORMAL(150, 299, new Color(60, 79, 144)),
	EXPERT_MODE(300, Integer.MAX_VALUE, new Color(190, 38, 51));

	private final int minRaidLevel;
	private final int maxRaidLevel;

	@Getter
	private final Color color;

	public static RaidMode forRaidLevel(int raidLevel)
	{
		for (RaidMode mode : RaidMode.values())
		{
			if (mode.minRaidLevel <= raidLevel && raidLevel <= mode.maxRaidLevel)
			{
				return mode;
			}
		}

		throw new IllegalArgumentException("No raid mode exists for raid level " + raidLevel);
	}

}

/*
BSD 2-Clause License

Copyright (c) 2022, LlemonDuck
Copyright (c) 2022, TheStonedTurtle
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

1. Redistributions of source code must retain the above copyright notice, this
   list of conditions and the following disclaimer.

2. Redistributions in binary form must reproduce the above copyright notice,
   this list of conditions and the following disclaimer in the documentation
   and/or other materials provided with the distribution.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/
package com.raidtracker.toapointstracker.module;

import com.raidtracker.RaidTrackerConfig;
import com.raidtracker.toapointstracker.util.RaidState;

public interface PluginLifecycleComponent
{

	default boolean isEnabled(RaidTrackerConfig config, RaidState raidState)
	{
		return true;
	}

	void startUp();

	void shutDown();

}

/*
BSD 2-Clause License

Copyright (c) 2022, LlemonDuck
Copyright (c) 2022, TheStonedTurtle
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

1. Redistributions of source code must retain the above copyright notice, this
   list of conditions and the following disclaimer.

2. Redistributions in binary form must reproduce the above copyright notice,
   this list of conditions and the following disclaimer in the documentation
   and/or other materials provided with the distribution.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/
package com.raidtracker.toapointstracker.module;


import com.raidtracker.RaidTrackerConfig;
import com.raidtracker.toapointstracker.util.RaidState;
import com.raidtracker.toapointstracker.util.RaidStateChanged;
import com.raidtracker.toapointstracker.util.RaidStateTracker;
import java.util.HashMap;
import java.util.Map;
import java.util.Set;
import javax.inject.Inject;
import javax.inject.Singleton;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import net.runelite.client.eventbus.EventBus;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.events.ConfigChanged;
import net.runelite.client.util.GameEventManager;

/**
 * Manages all the subcomponents of the plugin
 * so they can register themselves to RuneLite resources
 * e.g. EventBus/OverlayManager/init on startup/etc
 * instead of the TombsOfAmascutPlugin class handling everything.
 */
@Singleton
@RequiredArgsConstructor(onConstructor = @__(@Inject))
@Slf4j
public class ComponentManager
{

	private final EventBus eventBus;
	private final GameEventManager gameEventManager;
	private final RaidTrackerConfig config;
	private final RaidStateTracker raidStateTracker;
	private final Set<PluginLifecycleComponent> components;

	private final Map<PluginLifecycleComponent, Boolean> states = new HashMap<>();

	public void onPluginStart()
	{
		eventBus.register(this);
		components.forEach(c -> states.put(c, false));
		revalidateComponentStates();
	}

	public void onPluginStop()
	{
		eventBus.unregister(this);
		components.stream()
			.filter(states::get)
			.forEach(this::tryShutDown);
	}

	@Subscribe
	public void onConfigChanged(ConfigChanged e)
	{
		revalidateComponentStates();
	}

	@Subscribe
	public void onRaidStateChanged(RaidStateChanged e)
	{
		revalidateComponentStates();
	}

	private void revalidateComponentStates()
	{
		RaidState raidState = raidStateTracker.getCurrentState();
		components.forEach(c ->
		{
			boolean shouldBeEnabled = c.isEnabled(config, raidState);
			boolean isEnabled = states.get(c);
			if (shouldBeEnabled == isEnabled)
			{
				return;
			}

			if (shouldBeEnabled)
			{
				tryStartUp(c);
			}
			else
			{
				tryShutDown(c);
			}
		});
	}

	private void tryStartUp(PluginLifecycleComponent component)
	{
		if (states.get(component))
		{
			return;
		}

		if (log.isDebugEnabled())
		{
			log.debug("Enabling ToA plugin component [{}]", component.getClass().getName());
		}

		try
		{
			component.startUp();
			gameEventManager.simulateGameEvents(component);
			states.put(component, true);
		}
		catch (Exception e)
		{
			log.error("Failed to start ToA plugin component [{}]", component.getClass().getName(), e);
		}
	}

	private void tryShutDown(PluginLifecycleComponent component)
	{
		if (!states.get(component))
		{
			return;
		}

		if (log.isDebugEnabled())
		{
			log.debug("Disabling ToA plugin component [{}]", component.getClass().getName());
		}

		try
		{
			component.shutDown();
		}
		catch (Exception e)
		{
			log.error("Failed to cleanly shut down ToA plugin component [{}]", component.getClass().getName());
		}
		finally
		{
			states.put(component, false);
		}
	}

}

/*
BSD 2-Clause License

Copyright (c) 2022, LlemonDuck
Copyright (c) 2022, TheStonedTurtle
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

1. Redistributions of source code must retain the above copyright notice, this
   list of conditions and the following disclaimer.

2. Redistributions in binary form must reproduce the above copyright notice,
   this list of conditions and the following disclaimer in the documentation
   and/or other materials provided with the distribution.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/
package com.raidtracker.toapointstracker.module;

import com.raidtracker.RaidTrackerConfig;
import com.raidtracker.toapointstracker.pointstracker.PointsTracker;
import com.raidtracker.toapointstracker.util.RaidStateTracker;
import com.google.inject.AbstractModule;
import com.google.inject.Provides;
import com.google.inject.Singleton;
import com.google.inject.multibindings.Multibinder;
import lombok.extern.slf4j.Slf4j;
import net.runelite.client.config.ConfigManager;

@Slf4j
public class TombsOfAmascutModule extends AbstractModule
{

	@Override
	protected void configure()
	{
		Multibinder<PluginLifecycleComponent> lifecycleComponents = Multibinder.newSetBinder(binder(), PluginLifecycleComponent.class);
		lifecycleComponents.addBinding().to(PointsTracker.class);
		lifecycleComponents.addBinding().to(RaidStateTracker.class);
	}

}

/*
BSD 2-Clause License

Copyright (c) 2022, LlemonDuck
Copyright (c) 2022, TheStonedTurtle
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

1. Redistributions of source code must retain the above copyright notice, this
   list of conditions and the following disclaimer.

2. Redistributions in binary form must reproduce the above copyright notice,
   this list of conditions and the following disclaimer in the documentation
   and/or other materials provided with the distribution.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/
package com.raidtracker.toapointstracker.pointstracker;

import com.google.gson.annotations.SerializedName;
import lombok.Getter;
import lombok.RequiredArgsConstructor;
import net.runelite.client.party.messages.PartyMemberMessage;

@RequiredArgsConstructor
@Getter
public class RaidTrackerPointsMessage extends PartyMemberMessage
{

	@SerializedName("p")
	private final int points;

}

/*
BSD 2-Clause License

Copyright (c) 2022, LlemonDuck
Copyright (c) 2022, TheStonedTurtle
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

1. Redistributions of source code must retain the above copyright notice, this
   list of conditions and the following disclaimer.

2. Redistributions in binary form must reproduce the above copyright notice,
   this list of conditions and the following disclaimer in the documentation
   and/or other materials provided with the distribution.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/
package com.raidtracker.toapointstracker.pointstracker;

import com.raidtracker.RaidTrackerConfig;
import com.raidtracker.RaidTrackerPlugin;
import com.raidtracker.RaidType;
import com.raidtracker.toapointstracker.module.PluginLifecycleComponent;
import com.raidtracker.toapointstracker.util.RaidRoom;
import com.raidtracker.toapointstracker.util.RaidState;
import com.raidtracker.toapointstracker.util.RaidStateChanged;
import com.raidtracker.toapointstracker.util.RaidStateTracker;
import com.google.common.collect.ImmutableMap;
import com.google.common.collect.ImmutableSet;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import javax.inject.Inject;
import javax.inject.Singleton;
import lombok.Getter;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.ChatMessageType;
import net.runelite.api.Client;
import net.runelite.api.ItemID;
import net.runelite.api.NPC;
import net.runelite.api.NpcID;
import net.runelite.api.Varbits;
import net.runelite.api.events.AnimationChanged;
import net.runelite.api.events.ChatMessage;
import net.runelite.api.events.GameTick;
import net.runelite.api.events.HitsplatApplied;
import net.runelite.api.events.ItemSpawned;
import net.runelite.client.eventbus.EventBus;
import net.runelite.client.eventbus.Subscribe;

@Slf4j
@Singleton
@RequiredArgsConstructor(onConstructor_ = @Inject)
public class PointsTracker implements PluginLifecycleComponent
{

	/* I have some insider knowledge here that the blog was describing points earning slightly wrong wrt deaths.
	 * Points are earned to both total and room points at the same time,
	 * rather than being queued up in room points and added onto total after the room.
	 * When dying, you preserve the room points amount toward cap, but subtract 20% from total.
	 * There is no special behaviour when wiping a room; the 20% points lost is intended to account for that.
	 */

	private static final String START_MESSAGE = "You enter the Tombs of Amascut";
	private static final String DEATH_MESSAGE = "You have died";
	private static final String ROOM_FAIL_MESSAGE = "Your party failed to complete";
	private static final String ROOM_FINISH_MESSAGE = "Challenge complete";

	private static final int BASE_POINTS = 5000;
	private static final int MAX_ROOM_POINTS = 20_000;
	private static final int CRONDIS_MAX_ROOM_POINTS = 10_000;

	private static final int MAX_TOTAL_POINTS = 64_000;

	private static final int ANIMATION_ID_WARDEN_DOWN = 9670;

	private static final Map<Integer, Double> DAMAGE_POINTS_FACTORS = ImmutableMap.<Integer, Double>builder()
		.put(NpcID.CORE, 0.0)
		.put(NpcID.CORE_11771, 0.0)
		.put(NpcID.ENERGY_SIPHON, 0.0)
		.put(NpcID.BOULDER_11782, 0.0)
		.put(NpcID.BOULDER_11783, 0.0)
		.put(NpcID.BABOON_BRAWLER, 1.2)
		.put(NpcID.BABOON_BRAWLER_11712, 1.2)
		.put(NpcID.BABOON_THROWER, 1.2)
		.put(NpcID.BABOON_THROWER_11713, 1.2)
		.put(NpcID.BABOON_MAGE, 1.2)
		.put(NpcID.BABOON_MAGE_11714, 1.2)
		.put(NpcID.BABOON_SHAMAN, 1.2)
		.put(NpcID.VOLATILE_BABOON, 1.2)
		.put(NpcID.CURSED_BABOON, 1.2)
		.put(NpcID.BABOON_THRALL, 1.2)
		.put(NpcID.BABA, 2.0)
		.put(NpcID.BABA_11779, 2.0)
		.put(NpcID.BABA_11780, 2.0)
		.put(NpcID.ZEBAK, 1.5)
		.put(NpcID.ZEBAK_11730, 1.5)
		.put(NpcID.ZEBAK_11732, 1.5)
		.put(NpcID.ZEBAK_11733, 1.5)
		.put(NpcID.SPITTING_SCARAB, 0.5)
		.put(NpcID.SOLDIER_SCARAB, 0.5)
		.put(NpcID.ARCANE_SCARAB, 0.5)
		.put(NpcID.HETS_SEAL_WEAKENED, 2.5)
		.put(NpcID.OBELISK_11750, 1.5)
		.put(NpcID.OBELISK_11751, 1.5)
		.put(NpcID.OBELISK_11752, 1.5)
		.put(NpcID.ELIDINIS_WARDEN, 0.0) // non-combat wardens (prevents extra points during p1->p2 transition)
		.put(NpcID.ELIDINIS_WARDEN_11748, 0.0)
		.put(NpcID.TUMEKENS_WARDEN, 0.0)
		.put(NpcID.TUMEKENS_WARDEN_11749, 0.0)
		.put(NpcID.ELIDINIS_WARDEN_11759, 0.0)
		.put(NpcID.TUMEKENS_WARDEN_11760, 0.0)
		.put(NpcID.ELIDINIS_WARDEN_11753, 2.0) // p2 wardens
		.put(NpcID.ELIDINIS_WARDEN_11754, 2.0)
		.put(NpcID.ELIDINIS_WARDEN_11755, 0.0) // downed
		.put(NpcID.TUMEKENS_WARDEN_11756, 2.0)
		.put(NpcID.TUMEKENS_WARDEN_11757, 2.0)
		.put(NpcID.TUMEKENS_WARDEN_11758, 0.0) // downed
		.put(NpcID.ELIDINIS_WARDEN_11761, 2.5) // p3 wardens
		.put(NpcID.ELIDINIS_WARDEN_11763, 2.5)
		.put(NpcID.TUMEKENS_WARDEN_11762, 2.5)
		.put(NpcID.TUMEKENS_WARDEN_11764, 2.5)
		.build();

	// these have a cap at 3 "downs"
	private static final ImmutableSet<Integer> P2_WARDENS = ImmutableSet.of(
		NpcID.ELIDINIS_WARDEN_11753,
		NpcID.ELIDINIS_WARDEN_11754,
		NpcID.ELIDINIS_WARDEN_11755,
		NpcID.TUMEKENS_WARDEN_11756,
		NpcID.TUMEKENS_WARDEN_11757,
		NpcID.TUMEKENS_WARDEN_11758
	);

	private static final ImmutableSet<Integer> MVP_ITEMS = ImmutableSet.of(
		ItemID.FANG_27219,
		ItemID.SCARAB_DUNG,
		ItemID.BIG_BANANA,
		ItemID.ELDRITCH_ASHES
	);

	private final EventBus eventBus;
	private final Client client;
	private final RaidTrackerConfig config;
	private final RaidStateTracker raidStateTracker;

	@Inject
	private RaidTrackerPlugin raidTrackerPlugin;

	@Getter
	private int personalRoomPoints;
	private int personalTotalPoints;
	private int nonPartyPoints; // points that are earned once by the entire party
	private final List<Integer> seenMvpItems = new ArrayList<>(4);

	@Getter
	private int teamSize;
	private int raidLevel;
	private int wardenDowns;

	@Override
	public boolean isEnabled(RaidTrackerConfig config, RaidState raidState)
	{
		// always track even if not displaying, so that party members get points totals
		return raidState.isInRaid();
	}

	@Override
	public void startUp()
	{
		eventBus.register(this);

		reset();
	}

	@Override
	public void shutDown()
	{
		eventBus.unregister(this);
	}

	@Subscribe
	public void onGameTick(GameTick e)
	{
		raidLevel = client.getVarbitValue(Varbits.TOA_RAID_LEVEL);
	}

	@Subscribe
	public void onRaidStateChanged(RaidStateChanged e)
	{
		teamSize = e.getNewState().getPlayerCount();
		if (e.getPreviousState() == null || e.getPreviousState().getCurrentRoom() == null)
		{
			return;
		}

		switch (e.getPreviousState().getCurrentRoom())
		{
			case TOMB:
				raidTrackerPlugin.updateCurrentRT(RaidType.TOA);
				break;

			// puzzle estimates
			case SCABARAS:
				personalTotalPoints += 300;
				nonPartyPoints += 300;
				break;

			case APMEKEN:
				personalTotalPoints += 450;
				nonPartyPoints += 300;
				break;

			case CRONDIS:
				personalTotalPoints += 400;
				nonPartyPoints += 300;
				break;

			case HET:
			case WARDENS:
				nonPartyPoints += 300;
				break;
		}
	}

	@Subscribe
	public void onChatMessage(ChatMessage e)
	{
		if (e.getType() != ChatMessageType.GAMEMESSAGE)
		{
			return;
		}

		if (e.getMessage().startsWith(START_MESSAGE))
		{
			reset();
		}
		else if (e.getMessage().startsWith(DEATH_MESSAGE))
		{
			personalTotalPoints -= (int) Math.max(0.2 * personalTotalPoints, 1000);
			if (personalTotalPoints < 0)
			{
				personalTotalPoints = 0;
			}

		}
		else if (e.getMessage().startsWith(ROOM_FAIL_MESSAGE))
		{
			wardenDowns = 0;
		}
		else if (e.getMessage().startsWith(ROOM_FINISH_MESSAGE))
		{
			personalRoomPoints = 0;

			boolean isWardens = e.getMessage().contains("Wardens");
		}
	}

	@Subscribe
	public void onHitsplatApplied(HitsplatApplied e)
	{
		if (e.getHitsplat().getAmount() < 1 || !(e.getActor() instanceof NPC))
		{
			return;
		}

		NPC target = (NPC) e.getActor();
		log.debug("Hitsplat type {} damage {} on {}", e.getHitsplat().getHitsplatType(), e.getHitsplat().getAmount(), target.getId());
		if (P2_WARDENS.contains(target.getId()) && wardenDowns > 3)
		{
			return;
		}

		double factor = DAMAGE_POINTS_FACTORS.getOrDefault(target.getId(), 1.0);
		if (e.getHitsplat().isMine())
		{
			int pointsEarned = (int) (e.getHitsplat().getAmount() * factor);
			int roomMax = raidStateTracker.getCurrentState().getCurrentRoom() == RaidRoom.CRONDIS ? CRONDIS_MAX_ROOM_POINTS : MAX_ROOM_POINTS;
			if (personalRoomPoints + pointsEarned > roomMax)
			{
				pointsEarned = roomMax - personalRoomPoints;
			}

			this.personalRoomPoints = Math.min(roomMax, personalRoomPoints + pointsEarned);
			this.personalTotalPoints = Math.min(MAX_TOTAL_POINTS, personalTotalPoints + pointsEarned);
		}
	}

	@Subscribe
	public void onItemSpawned(ItemSpawned e)
	{
		if (MVP_ITEMS.contains(e.getItem().getId()) && !seenMvpItems.contains(e.getItem().getId()))
		{
			personalTotalPoints += 300 * teamSize;
			seenMvpItems.add(e.getItem().getId());
		}
	}

	@Subscribe
	public void onAnimationChanged(AnimationChanged e)
	{
		if (!(e.getActor() instanceof NPC) || !P2_WARDENS.contains(((NPC) e.getActor()).getId()))
		{
			return;
		}

		if (e.getActor().getAnimation() == ANIMATION_ID_WARDEN_DOWN)
		{
			wardenDowns++;
		}
	}

	public int getPersonalTotalPoints()
	{
		return this.personalTotalPoints - BASE_POINTS;
	}

	public double getPersonalPercent()
	{
		if (raidStateTracker.getPlayerCount() == 1)
		{
			return 1.0;
		}

		return (double) getPersonalTotalPoints() / getTotalPoints();
	}

	public int getTotalPoints()
	{
		return getPersonalTotalPoints() + nonPartyPoints;
	}

	private void reset()
	{
		this.personalTotalPoints = BASE_POINTS;
		this.personalRoomPoints = 0;
		this.nonPartyPoints = 0;
		this.teamSize = 0;
		this.raidLevel = -1;
		this.wardenDowns = 0;
		this.seenMvpItems.clear();
	}

}

package com.raidtracker;

import lombok.Data;

@Data
public class RaidTrackerItem {
    public String name;
    public int id;
    public int quantity;
    public int price;
}

package com.raidtracker;

import net.runelite.api.Client;
import net.runelite.api.WorldType;

public final class WorldUtils {
    private WorldUtils() {}

    public static Boolean playerOnBetaWorld(Client client) {
        return client.getWorldType().contains(WorldType.BETA_WORLD);
    }
}

package com.raidtracker;

public enum RaidType {
    COX,
    TOB,
    TOA
}

package com.raidtracker;

import net.runelite.client.config.Config;
import net.runelite.client.config.ConfigGroup;
import net.runelite.client.config.ConfigItem;

@ConfigGroup(RaidTrackerConfig.CONFIG_GROUP)
public interface RaidTrackerConfig extends Config
{

	String CONFIG_GROUP = "raidtracker";
	@ConfigItem(
		keyName = "defaultFFA",
		name = "default FFA",
		description = "Sets the default split to free for all, rather than split"
	)
	default boolean defaultFFA()
	{
		return false;
	}

	@ConfigItem(
			keyName = "FFACutoff",
			name = "FFA cut off",
			description = "The value of which, when the split reaches under that value, is considered free for all"
	)

	default int FFACutoff() {
		return 1000000;
	}

	@ConfigItem(
			keyName = "lastXKills",
			name = "Last X Kills",
			description = "When the 'Last X Kills' option is selected, this value is used as X"
	)

	default int lastXKills() {return 50;}

	@ConfigItem(
			keyName = "showTitle",
			name = "Show Title",
			description = "Disable this checkmark to hide the title in the ui"
	)
	default boolean showTitle()
	{
		return true;
	}

	@ConfigItem(
			keyName = "showKillsLogged",
			name = "Show Kills Logged",
			description = "Disable this checkmark to hide the Kills Logged panel in the ui"
	)
	default boolean showKillsLogged()
	{
		return true;
	}


	@ConfigItem(
			keyName = "showFilters",
			name = "Show Filters",
			description = "Disable this checkmark to hide the Filter Panel in the ui"
	)
	default boolean showFilters()
	{
		return true;
	}

	@ConfigItem(
			keyName = "showUniquesTable",
			name = "Show Uniques Table",
			description = "Disable this checkmark to hide the Uniques Table in the ui"
	)
	default boolean showUniquesTable()
	{
		return true;
	}

	@ConfigItem(
			keyName = "showPoints",
			name = "Show Points",
			description = "Disable this checkmark to hide the Points Panel in the ui"
	)
	default boolean showPoints()
	{
		return true;
	}

	@ConfigItem(
			keyName = "showTimeSplits",
			name = "Show Time Splits",
			description = "Disable this checkmark to hide the Time Splits Panel in the ui"
	)
	default boolean showTimeSplits()
	{
		return true;
	}

	@ConfigItem(
			keyName = "showSplitGPEarned",
			name = "Show Split GP Earned",
			description = "Disable this checkmark to hide the Split GP Earned Panel in the ui"
	)
	default boolean showSplitGPEarned()
	{
		return true;
	}

	@ConfigItem(
			keyName = "showMVPs",
			name = "Show MVP's",
			description = "Disable this checkmark to hide the MVP's Panel in the ui"
	)
	default boolean showMVPs()
	{
		return true;
	}

	@ConfigItem(
			keyName = "showRegularDrops",
			name = "Show Regular Drops",
			description = "Disable this checkmark to hide the Regular Drops Panel in the ui"
	)
	default boolean showRegularDrops()
	{
		return true;
	}

	@ConfigItem(
			keyName = "showSplitChanger",
			name = "Show Split Changer",
			description = "Disable this checkmark to hide the Split Changer in the ui"
	)
	default boolean showSplitChanger()
	{
		return true;
	}

	@ConfigItem(
		keyName = "toaFilterCustomLow",
		name = "toaFilterCustomLow",
		description = "toaFilterCustomLow",
		hidden = true
	)
	default int toaFilterCustomLow() { return 0; }

	@ConfigItem(
		keyName = "toaFilterCustomHigh",
		name = "toaFilterCustomHigh",
		description = "toaFilterCustomHigh",
		hidden = true
	)
	default int toaFilterCustomHigh() { return 600; }
}

package com.raidtracker.filereadwriter;

import com.google.gson.Gson;
import com.google.gson.JsonArray;
import com.google.gson.JsonObject;
import com.google.gson.JsonParser;
import com.google.gson.JsonSyntaxException;
import com.google.gson.reflect.TypeToken;
import com.google.inject.Inject;
import com.raidtracker.RaidTracker;
import com.raidtracker.RaidTrackerItem;
import com.raidtracker.RaidType;
import lombok.Getter;
import lombok.extern.slf4j.Slf4j;
import java.io.BufferedReader;
import java.io.File;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.List;

import static net.runelite.client.RuneLite.RUNELITE_DIR;

@Slf4j
public class FileReadWriter {

	@Getter
	private String username;
	private String coxDir;
	private String tobDir;
	private String toaDir;
    private String defaultDir;

	@Inject
	private Gson gson;

    public void writeToFile(RaidTracker raidTracker) {
        String fileName;
		if (raidTracker.isInTheatreOfBlood()) {
            fileName = getRaidFileName(RaidType.TOB);
		} else if (raidTracker.isInTombsOfAmascut()) {
            fileName = getRaidFileName(RaidType.TOA);
		} else if (raidTracker.isInRaidChambers()) {
            fileName = getRaidFileName(RaidType.COX);
		} else {
            fileName = getRaidFileName(null);
			log.warn("writeToFile called without an inRaid flag set.", new IllegalStateException());
		}

        try {
			log.info("writer started");
			//use json format so serializing and deserializing is easy
			JsonParser parser = new JsonParser();
			FileWriter fw = new FileWriter(fileName,true); //the true will append the new data
			gson.toJson(parser.parse(getJSONString(raidTracker, gson, parser)), fw);
			fw.append("\n");
			fw.close();
        } catch (IOException ioe) {
			log.error("IOException: {} in writeToFile", ioe.getMessage());
		}
	}

    public String getJSONString(RaidTracker raidTracker, Gson gson, JsonParser parser) {
		JsonObject RTJson =  parser.parse(gson.toJson(raidTracker)).getAsJsonObject();

		List<RaidTrackerItem> lootList = raidTracker.getLootList();

		//------------------ temporary fix until I can get gson.tojson to work for arraylist<RaidTrackerItem> ---------
		JsonArray lootListToString = new JsonArray();

		for (RaidTrackerItem item : lootList) {
			lootListToString.add(parser.parse(gson.toJson(item, new TypeToken<RaidTrackerItem>() {
			}.getType())));
		}

		RTJson.addProperty("lootList", lootListToString.toString());

		//-------------------------------------------------------------------------------------------------------------

		//massive bodge, works for now
        return RTJson.toString().replace("\\\"", "\"").replace("\"[", "[").replace("]\"", "]");
	}

    public ArrayList<RaidTracker> readFromFile(String alternateFile, RaidType raidType) {
        String fileName = getRaidFileName(raidType);

		if (alternateFile.length() != 0) {
			fileName = alternateFile;
		}

		try {
			JsonParser parser = new JsonParser();
			BufferedReader bufferedreader = new BufferedReader(new FileReader(fileName));
			String line;
			ArrayList<RaidTracker> RTList = new ArrayList<>();

			while ((line = bufferedreader.readLine()) != null && line.length() > 0) {
				try {
					RaidTracker parsed = gson.fromJson(parser.parse(line), RaidTracker.class);
					RTList.add(parsed);
				} catch (JsonSyntaxException e) {
					log.warn("Bad line: {}", line);
				}
			}

			bufferedreader.close();
			return RTList;
		} catch (IOException e) {
			log.error("Error occurred reading from file", e);
			return new ArrayList<>();
		}
	}

	public ArrayList<RaidTracker> readFromFile() {
		return readFromFile("", RaidType.COX);
	}

	public ArrayList<RaidTracker> readFromFile(RaidType raidType) {
		return readFromFile("", raidType);
	}

    public void createFolders() {
		File dir = new File(RUNELITE_DIR, "raid-data tracker");
		IGNORE_RESULT(dir.mkdir());
		dir = new File(dir, username);
		IGNORE_RESULT(dir.mkdir());
		File dir_cox = new File(dir, "cox");
		File dir_tob = new File(dir, "tob");
		File dir_toa = new File(dir, "toa");
        File dir_default = new File(dir, "unknown");
		IGNORE_RESULT(dir_cox.mkdir());
		IGNORE_RESULT(dir_tob.mkdir());
		IGNORE_RESULT(dir_toa.mkdir());
        IGNORE_RESULT(dir_default.mkdir());
		this.coxDir = dir_cox.getAbsolutePath();
		this.tobDir = dir_tob.getAbsolutePath();
		this.toaDir = dir_toa.getAbsolutePath();
        this.defaultDir = dir_default.getAbsolutePath();

		try {
            IGNORE_RESULT(new File(getRaidFileName(RaidType.COX)).createNewFile());
            IGNORE_RESULT(new File(getRaidFileName(RaidType.TOB)).createNewFile());
            IGNORE_RESULT(new File(getRaidFileName(RaidType.TOA)).createNewFile());
            IGNORE_RESULT(new File(getRaidFileName(null)).createNewFile());
		} catch (IOException e) {
			log.error("Error occurred creating new files", e);
		}
	}

	public void updateUsername(final String username) {
		this.username = username;
		createFolders();
	}

	// Used for making sure ToA loot and points is accurate
	// Initial write made on reward chest interface opened,
	// this updates after player leaves to account for purples/pets others receive
	public void updateRTLog(RaidTracker raidTracker, RaidType raidType) {
		try {
			JsonParser parser = new JsonParser();
            String fileName = getRaidFileName(raidType);
			ArrayList<RaidTracker> RTList = readFromFile(raidType);

			FileWriter fw = new FileWriter(fileName, false); // the true will append the new data

			for (RaidTracker RT : RTList) {

				if (RT.getUniqueID().equals(raidTracker.getUniqueID()) && !RT.equals(raidTracker)) {
					log.info("writer updated log");
					RT = raidTracker;
				}

				gson.toJson(parser.parse(getJSONString(RT, gson, parser)), fw);

				fw.append("\n");
			}

			fw.close();
		} catch (IOException e) {
			log.error("Error occurred updating the log", e);
		}
	}

	public void updateRTList(ArrayList<RaidTracker> RTList, RaidType raidType) {
		try {
			JsonParser parser = new JsonParser();
            String fileName = getRaidFileName(raidType);
			FileWriter fw = new FileWriter(fileName, false); // the true will append the new data

			for (RaidTracker RT : RTList) {
				if (RT.getLootSplitPaid() > 0) {
					RT.setSpecialLootInOwnName(true);
                } else {
					// bit of a wonky check, so try to avoid with lootsplitpaid if possible
                    RT.setSpecialLootInOwnName(!RT.getLootList().isEmpty()
                            && RT.getLootList().get(0).getName().equalsIgnoreCase(RT.getSpecialLoot()));
				}

				gson.toJson(parser.parse(getJSONString(RT, gson, parser)), fw);

				fw.append("\n");
			}

			fw.close();

		} catch (IOException e) {
			log.error("Error occurred updating the log list", e);
		}
	}

	public boolean delete(RaidType raidType) {
        File newFile = new File(getRaidFileName(raidType));

		boolean isDeleted = newFile.delete();

		try {
			IGNORE_RESULT(newFile.createNewFile());
		} catch (IOException e) {
			log.error("Error occurred creating new file", e);
		}

		return isDeleted;
	}

    public void IGNORE_RESULT(boolean b) {
    }

    public String getRaidFileName(RaidType raidType) {
        final String DATA_FILE_NAME = "/raid_tracker_data.log";

        if (raidType == null) {
            return defaultDir + DATA_FILE_NAME;
        }

		switch(raidType) {
            case COX:
                return coxDir + DATA_FILE_NAME;
			case TOB:
                return tobDir + DATA_FILE_NAME;
			case TOA:
                return toaDir + DATA_FILE_NAME;
            default:
                return defaultDir + DATA_FILE_NAME;
		}
	}
}

package com.raidtracker;

import com.google.inject.Binder;
import com.google.inject.Provides;
import com.google.inject.Inject;
import com.raidtracker.filereadwriter.FileReadWriter;
import com.raidtracker.ui.RaidTrackerPanel;
import java.util.Objects;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import lombok.Setter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.ChatMessageType;
import net.runelite.api.Client;
import net.runelite.api.GameState;
import net.runelite.api.InventoryID;
import net.runelite.api.Item;
import net.runelite.api.ItemComposition;
import net.runelite.api.ItemContainer;
import net.runelite.api.VarPlayer;
import net.runelite.api.Varbits;
import net.runelite.api.coords.WorldPoint;
import net.runelite.api.events.ChatMessage;
import net.runelite.api.events.GameStateChanged;
import net.runelite.api.events.GameTick;
import net.runelite.api.events.VarbitChanged;
import net.runelite.api.events.WidgetLoaded;
import net.runelite.api.widgets.InterfaceID;
import net.runelite.api.widgets.Widget;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.plugins.PluginDescriptor;
import net.runelite.client.plugins.PluginManager;
import net.runelite.client.ui.ClientToolbar;
import net.runelite.client.ui.NavigationButton;
import net.runelite.client.util.ImageUtil;
import net.runelite.client.util.Text;
import net.runelite.client.game.ItemManager;
import net.runelite.api.widgets.WidgetUtil;
import com.raidtracker.toapointstracker.pointstracker.PointsTracker;
import com.raidtracker.toapointstracker.module.ComponentManager;
import com.raidtracker.toapointstracker.module.TombsOfAmascutModule;
import net.runelite.client.events.ConfigChanged;
import net.runelite.client.events.PluginMessage;

import javax.swing.SwingUtilities;
import java.awt.image.BufferedImage;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.concurrent.atomic.AtomicReference;

import static java.lang.Integer.parseInt;
import static java.lang.Float.parseFloat;
import net.runelite.http.api.item.ItemPrice;

@Slf4j
@PluginDescriptor(
	name = "Raid Data Tracker"
)
public class RaidTrackerPlugin extends Plugin
{
	private static final String LEVEL_COMPLETE_MESSAGE = "complete! Duration:";
	private static final String RAID_COMPLETE_MESSAGE_COX_TOB = "Congratulations - your raid is complete!";
	private static final String RAID_COMPLETE_MESSAGE_TOA = "Challenge complete: The Wardens.";
	private static final String DUST_RECIPIENTS = "Dust recipients: ";
	private static final String TWISTED_KIT_RECIPIENTS = "Twisted Kit recipients: ";

	private static final Pattern TOA_ROOM_COMPLETE_PATTERN = Pattern.compile("Challenge complete: ([A-Za-z- ]+).*Duration:.*?(\\d+:\\d+\\.?\\d+)(?:\\. )?.*");
	private static final Pattern TOA_COMPLETION_PATTERN = Pattern.compile(".*Tombs of Amascut: (.*) Mode (total|challenge) completion time:.*?(\\d+:\\d+\\.?\\d+)\\..*");

	private static final String TOA_EVENT_NAMESPACE = "tombs-of-amascut";
	private static final String TOA_EVENT_NAME_POINTS = "raidCompletedPoints";

    private static final int TOA_CANVAS_WIDGET_ID = 481;
    private static final int TOA_TIMER_WIDGET_ID = 46;

    private static final int RAID_PARTY_SIZE = 5424;

	@Inject
	private Client client;

	@Inject
	private ClientThread clientThread;

	@Inject
	private ClientToolbar clientToolbar;

	@Inject
	private RaidTrackerConfig config;

	@Inject
	private ItemManager itemManager;

	@Inject
	private RaidTracker raidTracker;

	@Inject
	private PointsTracker pointsTracker;

	private ComponentManager componentManager = null;

	@Inject
	private FileReadWriter fw;
	private boolean writerStarted = false;
	private boolean raidStarted = false;

	private static final WorldPoint TEMP_LOCATION = new WorldPoint(3360, 5152, 2);

	@Setter
	private RaidTrackerPanel panel;
	private NavigationButton navButton;

	@Inject
	private ConfigManager configManager;

	@Inject
	private PluginManager pluginManager;

	@Provides
	RaidTrackerConfig provideConfig(ConfigManager configManager)
	{
		return configManager.getConfig(RaidTrackerConfig.class);
	}

	@Override
	public void configure(Binder binder)
	{
		binder.install(new TombsOfAmascutModule());
	}

	@Override
	protected void startUp() {
		panel = new RaidTrackerPanel(itemManager, fw, config, clientThread, client, configManager, pluginManager);

		final BufferedImage icon = ImageUtil.loadImageResource(getClass(), "panel-icon.png");

		navButton = NavigationButton.builder()
				.tooltip("Raid Data Tracker")
				.priority(6)
				.icon(icon)
				.panel(panel)
				.build();

		clientToolbar.addNavigation(navButton);

		if (componentManager == null) {
			componentManager = injector.getInstance(ComponentManager.class);
		}
		componentManager.onPluginStart();

		if (client.getGameState().equals(GameState.LOGGED_IN) || client.getGameState().equals(GameState.LOADING))
		{
			fw.updateUsername(client.getUsername());
			SwingUtilities.invokeLater(() -> panel.loadRTList());
		}
	}

	@Override
	protected void shutDown() {
		raidTracker.setInRaidChambers(false);
		clientToolbar.removeNavigation(navButton);
		reset();
	}

	@Subscribe
	public void onConfigChanged(ConfigChanged e) {
		if (!e.getGroup().equals(RaidTrackerConfig.CONFIG_GROUP)) {
			return;
		}
		panel.loadRTList();
	}

	@Subscribe
	public void onVarbitChanged(VarbitChanged event) {
		if (WorldUtils.playerOnBetaWorld(client)) {
			return;
		}

		boolean tempInRaid = client.getVarbitValue(Varbits.IN_RAID) == 1;
		boolean tempInTob = client.getVarbitValue(Varbits.THEATRE_OF_BLOOD) > 1;
		boolean tempInToa = client.getVarbitValue(Varbits.TOA_RAID_LEVEL) > 0;

		// if the player's raid state has changed
		if (tempInRaid ^ raidTracker.isInRaidChambers()) {
			// if the player is inside of a raid then check the raid
			if (tempInRaid && raidTracker.isLoggedIn()) {
				checkRaidPresence();
			}
			else if (raidTracker.isRaidComplete() && !raidTracker.isChestOpened()) {
				//player just exited a raid, if the chest is not looted write the raid tracker anyway.
				//might deprecate the writing after widgetloaded in the future, not decided yet.
				if (writerStarted) {
					return;
				}

				fw.writeToFile(raidTracker);

				writerStarted = true;

				SwingUtilities.invokeLater(() -> {
					panel.addDrop(raidTracker);
					reset();
				});
			}
		}

		if (tempInTob ^ raidTracker.isInTheatreOfBlood()) {
			if (tempInTob && raidTracker.isLoggedIn()) {
				checkTobPresence();
			}
			else if (raidTracker.isRaidComplete()) {
				//not tested

				if (writerStarted) {
					return;
				}

				fw.writeToFile(raidTracker);

				writerStarted = true;

				SwingUtilities.invokeLater(() -> {
					panel.addDrop(raidTracker);
					reset();
				});
			}
			else {
				reset();
			}
		}

		if (tempInToa ^ raidTracker.isInTombsOfAmascut()) {

			// Removed else if for ToA
			// No varbits are changed when a player leaves ToA, so the else-if would never fire
			if (tempInToa && raidTracker.isLoggedIn()) {
				checkToaPresence();
			}
			else {
				reset();
			}
		}

		if (raidTracker.isInTombsOfAmascut()) {
			// Tombs of Amascut orb healths 0=hide 1-27=% of health - 27 is 100% health and 1 is 0% health, 30=dead
			if (event.getVarbitId() >= Varbits.TOA_MEMBER_0_HEALTH && event.getVarbitId() <= Varbits.TOA_MEMBER_7_HEALTH && event.getValue() == 30) {
				int toa_member = event.getVarbitId() - Varbits.TOA_MEMBER_0_HEALTH;
				if (toa_member == 0) {
					raidTracker.personalDeathCount++;
				}

				raidTracker.totalTeamDeathCount++;
			}
		}
	}

	@Subscribe
	public void onGameStateChanged(GameStateChanged event) {
		if (WorldUtils.playerOnBetaWorld(client)) {
			return;
		}

		if (event.getGameState() == GameState.LOGGING_IN)
		{
			fw.updateUsername(client.getUsername());
			SwingUtilities.invokeLater(() -> panel.loadRTList());

		}

		if (client.getGameState() == GameState.LOGGED_IN) {
			// skip event while the game decides if the player belongs in a raid or not
			if (client.getLocalPlayer() == null
					|| client.getLocalPlayer().getWorldLocation().equals(TEMP_LOCATION))
			{
				//noinspection UnnecessaryReturnStatement
				return;
			}
		}
		else if (client.getGameState() == GameState.LOGIN_SCREEN
				|| client.getGameState() == GameState.CONNECTION_LOST)
		{
			raidTracker.setLoggedIn(false);
		}
		else if (client.getGameState() == GameState.HOPPING)
		{
			reset();
		}
	}

	@Subscribe
	public void onChatMessage(ChatMessage event) {
		if (WorldUtils.playerOnBetaWorld(client)) {
			return;
		}

		checkChatMessage(event, raidTracker);
	}

	@Subscribe
	public void onGameTick(GameTick gameTick) {

		int WIDGET_TIMER = WidgetUtil.packComponentId(TOA_CANVAS_WIDGET_ID, TOA_TIMER_WIDGET_ID);
		if (raidTracker.isInTombsOfAmascut() && client.getWidget(WIDGET_TIMER) != null) {
			if (!Objects.equals(Objects.requireNonNull(client.getWidget(WIDGET_TIMER)).getText(), "00:00")
                    && !Objects.equals(Objects.requireNonNull(client.getWidget(WIDGET_TIMER)).getText(), "0:00.00")
                    && !raidStarted
            ) {
				raidStarted = true;
				raidTracker.setTeamSize(pointsTracker.getTeamSize());
				raidTracker.setRaidLevel(client.getVarbitValue(Varbits.TOA_RAID_LEVEL));
			}
		}
	}

	// Thank Adam, LlemonDuck, and jocopa3 for creating PluginMessage event in core for us
	@Subscribe
	public void onPluginMessage(PluginMessage message) {
		if (message.getNamespace().equals(TOA_EVENT_NAMESPACE)
                && message.getName().equals(TOA_EVENT_NAME_POINTS)
                && (Integer) message.getData().get("version") == 1
        ) {
			log.info("received PluginMessage from Tombs of Amascut plugin");
			int personalPoints = (Integer) message.getData().get("personalPoints");
			int totalPoints = (Integer) message.getData().get("totalPoints");

			raidTracker.setPersonalPoints(personalPoints);
			raidTracker.setTotalPoints(totalPoints);
			raidTracker.setPercentage(raidTracker.getPersonalPoints() / (raidTracker.getTotalPoints() / 100.0));
		}
	}

	@Subscribe
	public void onWidgetLoaded(WidgetLoaded event) {
		if (WorldUtils.playerOnBetaWorld(client)) {
			return;
		}

		ItemContainer rewardItemContainer;
		switch (event.getGroupId()) {
			case (InterfaceID.CHAMBERS_OF_XERIC_REWARD):
				if (raidTracker.isChestOpened() || !raidTracker.isRaidComplete()) {
					return;
				}

				raidTracker.setChestOpened(true);

				rewardItemContainer = client.getItemContainer(InventoryID.CHAMBERS_OF_XERIC_CHEST);

				if (rewardItemContainer == null) {
					return;
				}

				if (writerStarted) {
					//unnecessary return check?
					return;
				}

				raidTracker.setLootList(lootListFactory(rewardItemContainer.getItems()));

				fw.writeToFile(raidTracker);

				writerStarted = true;

				SwingUtilities.invokeLater(() -> {
					panel.addDrop(raidTracker);
					reset();
				});

				break;

			case (InterfaceID.TOB):
				if (raidTracker.isChestOpened() || !raidTracker.isRaidComplete()) {
					return;
				}

				raidTracker.setChestOpened(true);

				rewardItemContainer = client.getItemContainer(InventoryID.THEATRE_OF_BLOOD_CHEST);

				if (rewardItemContainer == null) {
					return;
				}

				raidTracker.setLootList(lootListFactory(rewardItemContainer.getItems()));

				break;
			//459 is the mvp screen of TOB
			case (459):
				AtomicReference<String> mvp = new AtomicReference<>("");
				AtomicReference<String> player1 = new AtomicReference<>("");
				AtomicReference<String> player2 = new AtomicReference<>("");
				AtomicReference<String> player3 = new AtomicReference<>("");
				AtomicReference<String> player4 = new AtomicReference<>("");
				AtomicReference<String> player5 = new AtomicReference<>("");
				AtomicInteger deathsPlayer1 = new AtomicInteger();
				AtomicInteger deathsPlayer2 = new AtomicInteger();
				AtomicInteger deathsPlayer3 = new AtomicInteger();
				AtomicInteger deathsPlayer4 = new AtomicInteger();
				AtomicInteger deathsPlayer5 = new AtomicInteger();

				clientThread.invokeLater(() -> {
					mvp.set(getWidgetText(client.getWidget(459, 14)));
					player1.set(getWidgetText(client.getWidget(459, 22)));
					player2.set(getWidgetText(client.getWidget(459, 24)));
					player3.set(getWidgetText(client.getWidget(459, 26)));
					player4.set(getWidgetText(client.getWidget(459, 28)));
					player5.set(getWidgetText(client.getWidget(459, 30)));
					deathsPlayer1.set(getWidgetNumber(client.getWidget(459, 23)));
					deathsPlayer2.set(getWidgetNumber(client.getWidget(459, 25)));
					deathsPlayer3.set(getWidgetNumber(client.getWidget(459, 27)));
					deathsPlayer4.set(getWidgetNumber(client.getWidget(459, 29)));
					deathsPlayer5.set(getWidgetNumber(client.getWidget(459, 31)));

					raidTracker.setMvp(mvp.get());
					raidTracker.setTobPlayer1(player1.get());
					raidTracker.setTobPlayer2(player2.get());
					raidTracker.setTobPlayer3(player3.get());
					raidTracker.setTobPlayer4(player4.get());
					raidTracker.setTobPlayer5(player5.get());

					raidTracker.setTobPlayer1DeathCount(deathsPlayer1.get());
					raidTracker.setTobPlayer2DeathCount(deathsPlayer2.get());
					raidTracker.setTobPlayer3DeathCount(deathsPlayer3.get());
					raidTracker.setTobPlayer4DeathCount(deathsPlayer4.get());
					raidTracker.setTobPlayer5DeathCount(deathsPlayer5.get());

					if (client.getLocalPlayer() != null && client.getLocalPlayer().getName() != null) {
						raidTracker.setMvpInOwnName(mvp.get().equalsIgnoreCase(client.getLocalPlayer().getName()));
					}
				});
				break;

			case (InterfaceID.TOA_REWARD):
				if (raidTracker.isChestOpened() || !raidTracker.isRaidComplete()) {
					return;
				}

				raidTracker.setChestOpened(true);

				rewardItemContainer = client.getItemContainer(InventoryID.TOA_REWARD_CHEST);

				if (rewardItemContainer == null) {
					return;
				}

				raidTracker.setLootList(lootListFactory(rewardItemContainer.getItems()));

				fw.writeToFile(raidTracker);

				writerStarted = true;

				SwingUtilities.invokeLater(() -> {
					// Doesn't use reset() due to ToA using a log update function on tomb exit
					panel.addDrop(raidTracker);
					writerStarted = false;
				});
				break;
			case (InterfaceID.TOA_PARTY):
				SwingUtilities.invokeLater(() -> panel.showWarningView());
				break;
		}
	}

	private String getWidgetText(Widget widget) {
		if (widget == null) {
			return "";
		}
		else if (widget.getText().equals("-")) {
			return "";
		}
		return widget.getText();
	}

	private int getWidgetNumber(Widget widget) {
		if (widget == null) {
			return 0;
		}
		else if (widget.getText().equals("-")) {
			return 0;
		}
		return Integer.parseInt(widget.getText());
	}

	public void checkChatMessage(ChatMessage event, RaidTracker raidTracker)
	{
		raidTracker.setLoggedIn(true);

		String playerName = "";

		if (client.getLocalPlayer() != null && client.getLocalPlayer().getName() != null) {
			playerName = client.getLocalPlayer().getName();
		}

		if ((raidTracker.isInRaidChambers() || raidTracker.isInTheatreOfBlood() || raidTracker.isInTombsOfAmascut()) &&
			(event.getType() == ChatMessageType.FRIENDSCHATNOTIFICATION || event.getType() == ChatMessageType.GAMEMESSAGE)) {
			//unescape java to avoid unicode
			String message = unescapeJavaString(Text.removeTags(event.getMessage()));

			// Fixes issue with inconsistent resets due to
			// Varbits.TOA_RAID_LEVEL not resetting when you leave
			if (message.contains("You enter the Tombs of Amascut")) {
				reset();
			}

			if (message.contains(LEVEL_COMPLETE_MESSAGE)) {
				String timeString = message.split("complete! Duration: ")[1];

				if (message.startsWith("Upper")) {
					raidTracker.setUpperTime(stringTimeToSeconds(timeString.split(" ")[timeString.split(" ").length - 1]));
				}
				if (message.startsWith("Middle")) {
					raidTracker.setMiddleTime(stringTimeToSeconds(timeString.split(" ")[timeString.split(" ").length - 1]));
				}
				if (message.startsWith("Lower")) {
					raidTracker.setLowerTime(stringTimeToSeconds(timeString.split(" ")[timeString.split(" ").length - 1]));
				}

				if (message.toLowerCase().contains("shamans")) {
					raidTracker.setShamansTime(stringTimeToSeconds(timeString.split(" ")[0]));
				}

				if (message.toLowerCase().contains("vasa")) {
					raidTracker.setVasaTime(stringTimeToSeconds(timeString.split(" ")[0]));
				}

				if (message.toLowerCase().contains("vanguards")) {
					raidTracker.setVanguardsTime(stringTimeToSeconds(timeString.split(" ")[0]));
				}

				if (message.toLowerCase().contains("mystics")) {
					raidTracker.setMysticsTime(stringTimeToSeconds(timeString.split(" ")[0]));
				}

				if (message.toLowerCase().contains("tekton")) {
					raidTracker.setTektonTime(stringTimeToSeconds(timeString.split(" ")[0]));
				}

				if (message.toLowerCase().contains("muttadiles")) {
					raidTracker.setMuttadilesTime(stringTimeToSeconds(timeString.split(" ")[0]));
				}

				if (message.toLowerCase().contains("vespula")) {
					raidTracker.setVespulaTime(stringTimeToSeconds(timeString.split(" ")[0]));
				}

				if (message.toLowerCase().contains("ice demon")) {
					raidTracker.setIceDemonTime(stringTimeToSeconds(timeString.split(" ")[0]));
				}

				if (message.toLowerCase().contains("thieving")) {
					raidTracker.setThievingTime(stringTimeToSeconds(timeString.split(" ")[0]));
				}

				if (message.toLowerCase().contains("tightrope")) {
					raidTracker.setTightropeTime(stringTimeToSeconds(timeString.split(" ")[0]));
				}

				if (message.toLowerCase().contains("crabs")) {
					raidTracker.setCrabsTime(stringTimeToSeconds(timeString.split(" ")[0]));
				}

			}

			if (message.startsWith(RAID_COMPLETE_MESSAGE_COX_TOB) || message.startsWith(RAID_COMPLETE_MESSAGE_TOA)) {
				if (raidTracker.isInRaidChambers()) {
					raidTracker.setTotalPoints(client.getVarbitValue(Varbits.TOTAL_POINTS));
					raidTracker.setPersonalPoints(client.getVarpValue(VarPlayer.RAIDS_PERSONAL_POINTS));
					raidTracker.setTeamSize(client.getVarbitValue(RAID_PARTY_SIZE));
				} else if (raidTracker.isInTombsOfAmascut()) {
					raidTracker.setPersonalPoints(pointsTracker.getPersonalTotalPoints());
				}


				raidTracker.setPercentage(raidTracker.getPersonalPoints() / (raidTracker.getTotalPoints() / 100.0));

				// Points being 0 (for any reason) causes the % to be NaN and cause a log writing error
				if (Double.isNaN(raidTracker.getPercentage())) {
					raidTracker.setTotalPoints(-1);
					raidTracker.setPersonalPoints(-1);
					raidTracker.setPercentage(-1);
				}

				// Without TOA party point tracking, the points percentage can't be calculated properly
				if (raidTracker.getPercentage() < 0 && raidTracker.getPercentage() != -1) {
					raidTracker.setPercentage(-1);
				}

				raidTracker.setRaidComplete(true);

				raidTracker.setDate(System.currentTimeMillis());
			}

			//the message after every completed tob wave.
			if (message.toLowerCase().contains("wave '")) {
				String wave = message.toLowerCase().split("'")[1];

				switch (wave) {
					case("the maiden of sugadinti"):
						raidTracker.setMaidenTime(stringTimeToSeconds(message.toLowerCase().split("duration: ")[1].split(" total")[0]));
						break;
					case("the pestilent bloat"):
						raidTracker.setBloatTime(stringTimeToSeconds(message.toLowerCase().split("duration: ")[1].split(" total")[0]));
						break;
					case("the nylocas"):
						raidTracker.setNyloTime(stringTimeToSeconds(message.toLowerCase().split("duration: ")[1].split(" total")[0]));
						break;
					case("sotetseg"):
						raidTracker.setSotetsegTime(stringTimeToSeconds(message.toLowerCase().split("duration: ")[1].split(" total")[0]));
						break;
					case("xarpus"):
						raidTracker.setXarpusTime(stringTimeToSeconds(message.toLowerCase().split("duration: ")[1].split(" total")[0]));
						break;
					case("the final challenge"):
						raidTracker.setVerzikTime(stringTimeToSeconds(message.toLowerCase().split("duration: ")[1].split("theatre")[0]));
						break;
				}
			}

			if (message.contains("Challenge complete") || message.contains("total completion")) {

				Matcher m;
				if ((m = TOA_ROOM_COMPLETE_PATTERN.matcher(message)).matches()) {
					String room = m.group(1).toLowerCase();
					int duration = stringTimeToSeconds(m.group(2));
					if (room == null || room.isEmpty()) {
						log.warn("Failed to find room {} for completion string {}", m.group(1), event.getMessage());
						return;
					}

					switch (room) {
						case "path of crondis":
							raidTracker.setCrondisTime(duration);
							break;
						case "zebak":
							raidTracker.setZebakTime(duration);
							break;
						case "path of apmeken":
							raidTracker.setApmekenTime(duration);
							break;
						case "ba-ba":
							raidTracker.setBabaTime(duration);
							break;
						case "path of scabaras":
							raidTracker.setScabarasTime(duration);
							break;
						case "kephri":
							raidTracker.setKephriTime(duration);
							break;
						case "path of het":
							raidTracker.setHetTime(duration);
							break;
						case "akkha":
							raidTracker.setAkkhaTime(duration);
							break;
						case "the wardens":
							raidTracker.setWardensTime(duration);
							break;
					}
				}

				if ((m = TOA_COMPLETION_PATTERN.matcher(message)).matches()) {
					int duration = stringTimeToSeconds(m.group(3));
					if (Objects.equals(m.group(2), "challenge"))
					{
						raidTracker.setToaCompTime(duration);
					}
					if (Objects.equals(m.group(2), "total"))
					{
						raidTracker.setRaidTime(duration);
					}
				}
			}

			if (message.toLowerCase().contains("theatre of blood wave completion")) {
				raidTracker.setRaidTime(stringTimeToSeconds(message.toLowerCase().split("time: ")[1].split("personal")[0]));
			}

			if (raidTracker.isRaidComplete() && message.contains("Team size:")) {
				raidTracker.setRaidTime(stringTimeToSeconds(message.split("Duration: ")[1].split(" ")[0]));
			}

			//works for tob
			if (message.contains("count is:")) {
				raidTracker.setChallengeMode(message.contains("Chambers of Xeric Challenge Mode"));
				raidTracker.setCompletionCount(parseInt(message.split("count is:")[1].trim().replace(".", "")));
				if (raidTracker.isInTheatreOfBlood()) {
					int teamSize = 0;

					for (int i = 6442; i  < 6447; i++) {
						if (client.getVarbitValue(i) != 0) {
							teamSize++;
						}
					}
					raidTracker.setTeamSize(teamSize);
					raidTracker.setRaidComplete(true);
				}
			}

			//only special loot contain the "-" (except for the raid complete message)
			if (raidTracker.isRaidComplete() && message.contains("-") && !message.startsWith(RAID_COMPLETE_MESSAGE_COX_TOB)) {
				//in case of multiple purples, a new purple is stored on a new line in the file, so a new raidtracker object will be used and written to the file
				if (!raidTracker.getSpecialLootReceiver().isEmpty()) {
					RaidTracker altRT = copyData();

					altRT.setSpecialLootReceiver(message.split(" - ")[0]);
					altRT.setSpecialLoot(message.split(" - ")[1]);

					altRT.setSpecialLootInOwnName(altRT.getSpecialLootReceiver().toLowerCase().trim().equals(playerName.toLowerCase().trim()));


					altRT.setSpecialLootValue(getItemPrice(itemManager.search(raidTracker.getSpecialLoot()).get(0)));

					setSplits(altRT);

					fw.writeToFile(altRT);

					SwingUtilities.invokeLater(() -> panel.addDrop(altRT, false));
				}
				else {
					raidTracker.setSpecialLootReceiver(message.split(" - ")[0]);
					raidTracker.setSpecialLoot(message.split(" - ")[1]);

					raidTracker.setSpecialLootValue(getItemPrice(itemManager.search(raidTracker.getSpecialLoot()).get(0)));

					raidTracker.setSpecialLootInOwnName(raidTracker.getSpecialLootReceiver().toLowerCase().trim().equals(playerName.toLowerCase().trim()));

					setSplits(raidTracker);
				}
			}

			//for tob & toa it works a bit different, not possible to get duplicates.
			//toa tested, tob untested in game
			if (raidTracker.isRaidComplete() && message.toLowerCase().contains("found something special") && !message.toLowerCase().contains("lil' zik") && !message.toLowerCase().contains("tumeken's guardian")) {
				raidTracker.setSpecialLootReceiver(message.split(" found something special: ")[0]);
				raidTracker.setSpecialLoot(message.split(" found something special: ")[1]);

				raidTracker.setSpecialLootValue(getItemPrice(itemManager.search(raidTracker.getSpecialLoot()).get(0)));

				raidTracker.setSpecialLootInOwnName(raidTracker.getSpecialLootReceiver().toLowerCase().trim().equals(playerName.toLowerCase().trim()));

				setSplits(raidTracker);
			}

			if (raidTracker.isRaidComplete() && message.startsWith(TWISTED_KIT_RECIPIENTS)) {
				String[] recipients = message.split(TWISTED_KIT_RECIPIENTS)[1].split(",");

				for (String recip : recipients) {
					if (raidTracker.getKitReceiver().isEmpty()) {
						raidTracker.setKitReceiver(recip.trim());
					}
					else {
						RaidTracker altRT = copyData();
						altRT.setKitReceiver(recip.trim());

						fw.writeToFile(altRT);

						SwingUtilities.invokeLater(() -> panel.addDrop(altRT, false));
					}
				}
			}

			if (raidTracker.isRaidComplete() && message.startsWith(DUST_RECIPIENTS)) {
				String[] recipients = message.split(DUST_RECIPIENTS)[1].split(",");

				for (String recip : recipients) {
					if (raidTracker.getDustReceiver().isEmpty()) {
						raidTracker.setDustReceiver(recip.trim());
					}
					else {
						RaidTracker altRT = copyData();
						altRT.setDustReceiver(recip.trim());

						fw.writeToFile(altRT);

						SwingUtilities.invokeLater(() -> panel.addDrop(altRT, false));
					}
				}
			}

			if (raidTracker.isRaidComplete() && (message.toLowerCase().contains("olmlet") || message.toLowerCase().contains("lil' zik")) || message.toLowerCase().contains("tumeken's guardian") || message.toLowerCase().contains("would have been followed")) {
				boolean inOwnName = false;
				boolean duplicate = message.toLowerCase().contains("would have been followed");

				if (playerName.equals(message.split(" ")[0]) || duplicate)	{
					inOwnName = true;
				}

				if (!raidTracker.getPetReceiver().isEmpty()) {
					RaidTracker altRT = copyData();

					if (duplicate) {
						altRT.setPetReceiver(playerName);
					}
					else {
						altRT.setPetReceiver(message.split(" ")[0]);
					}

					altRT.setPetInMyName(inOwnName);

					fw.writeToFile(altRT);

					SwingUtilities.invokeLater(() -> panel.addDrop(altRT, false));
				}
				else {
					if (duplicate) {
						raidTracker.setPetReceiver(playerName);
					}
					else {
						raidTracker.setPetReceiver(message.split(" ")[0]);
					}
					raidTracker.setPetInMyName(inOwnName);
				}
			}
		}
	}

	public void setSplits(RaidTracker raidTracker)
	{

		int lootSplit = raidTracker.getSpecialLootValue() / raidTracker.getTeamSize();

		int cutoff = config.FFACutoff();

		//
		if (raidTracker.getSpecialLoot().length() > 0) {
			if (config.defaultFFA() || lootSplit < cutoff) {
				raidTracker.setFreeForAll(true);
				if (raidTracker.isSpecialLootInOwnName()) {
					raidTracker.setLootSplitReceived(raidTracker.getSpecialLootValue());
				}
			} else if (raidTracker.isSpecialLootInOwnName()) {
				raidTracker.setLootSplitPaid(raidTracker.getSpecialLootValue() - lootSplit);
				raidTracker.setLootSplitReceived(lootSplit);
			} else {
				raidTracker.setLootSplitReceived(lootSplit);
			}
		}
	}

	public ArrayList<RaidTrackerItem> lootListFactory(Item[] items)
	{
		ArrayList<RaidTrackerItem> lootList = new ArrayList<>();
		Arrays.stream(items)
				.filter(item -> item.getId() > -1)
				.forEach(item -> {
					ItemComposition comp = itemManager.getItemComposition(item.getId());
					lootList.add(new RaidTrackerItem() {
						{
							name = comp.getName();
							id = comp.getId();
							quantity = item.getQuantity();
							price = getItemPrice(id) * quantity;
						}
					});
				});
		return lootList;
	}

	private void checkRaidPresence()
	{
		if (client.getGameState() != GameState.LOGGED_IN) {
			return;
		}

		raidTracker.setInRaidChambers(client.getVarbitValue(Varbits.IN_RAID) == 1);
	}

	private void checkTobPresence() {
		if (client.getGameState() != GameState.LOGGED_IN) {
			return;
		}
		//1 = in party outside, 2 = spectating, 3 = dead spectating
		raidTracker.setInTheatreOfBlood(client.getVarbitValue(Varbits.THEATRE_OF_BLOOD) > 1);
	}

	private void checkToaPresence() {
		if (client.getGameState() != GameState.LOGGED_IN) {
			return;
		}

		raidTracker.setInTombsOfAmascut(client.getVarbitValue(Varbits.TOA_RAID_LEVEL) > 0);
	}

	private int stringTimeToSeconds(String s)
	{
		String[] split = s.split(":");
		return split.length == 3 ? parseInt(split[0]) * 3600 + parseInt(split[1]) * 60 + Math.round(parseFloat(split[2])) : parseInt(split[0]) * 60 + Math.round(parseFloat(split[1]));
	}

	public RaidTracker copyData() {
		RaidTracker RT = new RaidTracker();

		RT.setDate(raidTracker.getDate());
		RT.setTeamSize(raidTracker.getTeamSize());
		RT.setChallengeMode(raidTracker.isChallengeMode());
		RT.setInTheatreOfBlood(raidTracker.isInTheatreOfBlood());
		RT.setCompletionCount(raidTracker.getCompletionCount());
		RT.setKillCountID(raidTracker.getKillCountID());

		return RT;
	}

	private void reset()
	{
		raidTracker = new RaidTracker();
		writerStarted = false;
		raidStarted = false;
	}

	//from stackoverflow
	public String unescapeJavaString(String st) {

		if (st == null) {
			return null;
		}

		StringBuilder sb = new StringBuilder(st.length());

		for (int i = 0; i < st.length(); i++) {
			char ch = st.charAt(i);
			if (ch == '\\') {
				char nextChar = (i == st.length() - 1) ? '\\' : st
						.charAt(i + 1);
				// Octal escape?
				if (nextChar >= '0' && nextChar <= '7') {
					String code = "" + nextChar;
					i++;
					if ((i < st.length() - 1) && st.charAt(i + 1) >= '0'
							&& st.charAt(i + 1) <= '7') {
						code += st.charAt(i + 1);
						i++;
						if ((i < st.length() - 1) && st.charAt(i + 1) >= '0'
								&& st.charAt(i + 1) <= '7') {
							code += st.charAt(i + 1);
							i++;
						}
					}
					sb.append((char) Integer.parseInt(code, 8));
					continue;
				}
				switch (nextChar) {
					case '\\':
						break;
					case 'b':
						ch = '\b';
						break;
					case 'f':
						ch = '\f';
						break;
					case 'n':
						ch = '\n';
						break;
					case 'r':
						ch = '\r';
						break;
					case 't':
						ch = '\t';
						break;
					case '\"':
						ch = '\"';
						break;
					case '\'':
						ch = '\'';
						break;
					// Hex Unicode: u????
					case 'u':
						if (i >= st.length() - 5) {
							ch = 'u';
							break;
						}
						int code = Integer.parseInt(
								"" + st.charAt(i + 2) + st.charAt(i + 3)
										+ st.charAt(i + 4) + st.charAt(i + 5), 16);
						sb.append(Character.toChars(code));
						i += 5;
						continue;
				}
				i++;
			}
			sb.append(ch);
		}
		return sb.toString();
	}

	public int getItemPrice(ItemPrice itemPrice) {
		return itemPrice.getWikiPrice() > 0 ? itemPrice.getWikiPrice() : itemPrice.getPrice();
	}
	public int getItemPrice(int itemID) {
		return itemManager.getItemPrice(itemID) > 0 ? itemManager.getItemPrice(itemID) : itemManager.getItemComposition(itemID).getPrice();
	}

	public void setFw(FileReadWriter fw) {
		this.fw = fw;
	}

	public void updateCurrentRT(RaidType raidType) {
		if (writerStarted) {
			return;
		}

		writerStarted = true;

		fw.updateRTLog(raidTracker, raidType);

		SwingUtilities.invokeLater(() -> {
			panel.updateView(true);
			reset();
		});
	}

}

package com.raidtracker.ui;

import lombok.AllArgsConstructor;
import lombok.Getter;
import net.runelite.api.ItemID;

@AllArgsConstructor
public enum RaidUniques {
    DEX("Dexterous Prayer Scroll", ItemID.DEXTEROUS_PRAYER_SCROLL),
    ARCANE("Arcane Prayer Scroll", ItemID.ARCANE_PRAYER_SCROLL),
    TWISTED_BUCKLER("Twisted Buckler", ItemID.TWISTED_BUCKLER),
    DHCB("Dragon Hunter Crossbow", ItemID.DRAGON_HUNTER_CROSSBOW),
    DINNY_B("Dinh's Bulwark", ItemID.DINHS_BULWARK),
    ANCESTRAL_HAT("Ancestral Hat", ItemID.ANCESTRAL_HAT),
    ANCESTRAL_TOP("Ancestral Robe Top", ItemID.ANCESTRAL_ROBE_TOP),
    ANCESTRAL_BOTTOM("Ancestral Robe Bottom", ItemID.ANCESTRAL_ROBE_BOTTOM),
    DRAGON_CLAWS("Dragon Claws", ItemID.DRAGON_CLAWS),
    ELDER_MAUL("Elder Maul", ItemID.ELDER_MAUL),
    KODAI("Kodai Insignia", ItemID.KODAI_INSIGNIA),
    TWISTED_BOW("Twisted Bow", ItemID.TWISTED_BOW),
    DUST("Metamorphic Dust", ItemID.METAMORPHIC_DUST),
    TWISTED_KIT("Twisted Kit", ItemID.TWISTED_ANCESTRAL_COLOUR_KIT),
    OLMLET("Olmlet", ItemID.OLMLET),

    AVERNIC("Avernic defender hilt", ItemID.AVERNIC_DEFENDER_HILT),
    RAPIER("Ghrazi rapier", ItemID.GHRAZI_RAPIER),
    SANGSTAFF("Sanguinesti staff (uncharged)", ItemID.SANGUINESTI_STAFF_UNCHARGED),
    JUSTI_FACEGUARD("Justiciar faceguard", ItemID.JUSTICIAR_FACEGUARD),
    JUSTI_CHESTGUARD("Justiciar chestguard", ItemID.JUSTICIAR_CHESTGUARD),
    JUSTI_LEGGUARDS("Justiciar legguards", ItemID.JUSTICIAR_LEGGUARDS),
    SCYTHE("Scythe of vitur (uncharged)", ItemID.SCYTHE_OF_VITUR_UNCHARGED),
    LILZIK("Lil' Zik", ItemID.LIL_ZIK),

	OSMUMTENS_FANG("Osmumten's fang", ItemID.OSMUMTENS_FANG),
	LIGHTBEARER("Lightbearer", ItemID.LIGHTBEARER),
	ELIDINIS_WARD("Elidinis' ward", ItemID.ELIDINIS_WARD),
	MASORI_MASK("Masori mask", ItemID.MASORI_MASK),
	MASORI_BODY("Masori body", ItemID.MASORI_BODY),
	MASORI_CHAPS("Masori chaps", ItemID.MASORI_CHAPS),
    TUMEKENS_SHADOW("Tumeken's shadow (uncharged)", ItemID.TUMEKENS_SHADOW),
	TUMEKENS_GUARDIAN("Tumeken's guardian", ItemID.TUMEKENS_GUARDIAN);

    @Getter
    private final String name;

    @Getter
    private final int itemID;
}
package com.raidtracker.ui;


import com.raidtracker.RaidTracker;
import com.raidtracker.RaidTrackerConfig;
import com.raidtracker.RaidTrackerItem;
import com.raidtracker.RaidType;
import com.raidtracker.WorldUtils;
import com.raidtracker.filereadwriter.FileReadWriter;

import java.awt.Insets;
import javax.swing.BorderFactory;
import javax.swing.JTextPane;
import javax.swing.text.SimpleAttributeSet;
import javax.swing.text.StyleConstants;
import javax.swing.text.StyledDocument;
import lombok.Getter;
import lombok.Setter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.ItemComposition;
import net.runelite.api.ItemID;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.game.ItemManager;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.plugins.PluginManager;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.FontManager;
import net.runelite.client.ui.PluginPanel;
import net.runelite.client.util.AsyncBufferedImage;
import net.runelite.client.util.ImageUtil;

import javax.swing.Box;
import javax.swing.BoxLayout;
import javax.swing.ImageIcon;
import javax.swing.JButton;
import javax.swing.JComboBox;
import javax.swing.JLabel;
import javax.swing.JOptionPane;
import javax.swing.JPanel;
import javax.swing.JTextField;
import javax.swing.SwingConstants;
import javax.swing.SwingUtilities;
import javax.swing.border.CompoundBorder;
import javax.swing.border.EmptyBorder;
import javax.swing.border.MatteBorder;
import java.awt.BorderLayout;
import java.awt.Color;
import java.awt.Component;
import java.awt.Dimension;
import java.awt.GridBagConstraints;
import java.awt.GridBagLayout;
import java.awt.GridLayout;
import java.awt.event.KeyAdapter;
import java.awt.event.KeyEvent;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.awt.geom.AffineTransform;
import java.awt.image.AffineTransformOp;
import java.awt.image.BufferedImage;
import java.text.NumberFormat;
import java.util.ArrayList;
import java.util.Comparator;
import java.util.EnumSet;
import java.util.HashMap;
import java.util.HashSet;
import java.util.LinkedHashMap;
import java.util.Map;
import java.util.NavigableMap;
import java.util.TreeMap;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.Future;
import java.util.stream.Collectors;
import java.util.regex.Pattern;
import static java.util.Comparator.comparing;

@Slf4j
public class RaidTrackerPanel extends PluginPanel {

	@Setter
    private ItemManager itemManager;
    private final FileReadWriter fw;
    private final RaidTrackerConfig config;
    private final ClientThread clientThread;
    private final Client client;
	private final ConfigManager configManager;
	private final PluginManager pluginManager;

    @Setter
    private ArrayList<RaidTracker> coxRTList;
    private ArrayList<RaidTracker> tobRTList;
	private ArrayList<RaidTracker> toaRTList;

    private final HashMap<String, RaidTracker> coxUUIDMap = new LinkedHashMap<>();
    private final HashMap<String, RaidTracker> tobUUIDMap = new LinkedHashMap<>();
	private final HashMap<String, RaidTracker> toaUUIDMap = new LinkedHashMap<>();

    @Setter
    private boolean loaded = false;
    private final JPanel panel = new JPanel();

    private JButton update;

    @Setter
    private String dateFilter = "All Time";
    @Setter
    private String cmFilter = "CM & Normal";
    @Setter
    private String mvpFilter = "Both";
	@Setter
	private String raidLevelFilter = "All Levels";
    @Setter
    private String teamSizeFilter = "All sizes";

	private final HashMap<String, int[]> toaFilterMap = new HashMap<>(4);

	@Setter
	private int raidLevelFilterLow = 0;
	@Setter
	private int raidLevelFilterHigh = 600;

    private static final int toaRaidLevelMin = 0;
    private static final int toaRaidLevelMax = 600;

	@Setter
	private boolean raidLevelFilterIsAPI = false;

	@Getter
	@Setter
	private RaidType selectedRaidTab = RaidType.COX;

    private JPanel regularDrops = new JPanel();

    @Getter
    EnumSet<RaidUniques> tobUniques = EnumSet.of(
            RaidUniques.AVERNIC,
            RaidUniques.RAPIER,
            RaidUniques.SANGSTAFF,
            RaidUniques.JUSTI_FACEGUARD,
            RaidUniques.JUSTI_CHESTGUARD,
            RaidUniques.JUSTI_LEGGUARDS,
            RaidUniques.SCYTHE,
            RaidUniques.LILZIK
    );

    @Getter
    EnumSet<RaidUniques> coxUniques = EnumSet.of(
            RaidUniques.DEX,
            RaidUniques.ARCANE,
            RaidUniques.TWISTED_BUCKLER,
            RaidUniques.DHCB,
            RaidUniques.DINNY_B,
            RaidUniques.ANCESTRAL_HAT,
            RaidUniques.ANCESTRAL_TOP,
            RaidUniques.ANCESTRAL_BOTTOM,
            RaidUniques.DRAGON_CLAWS,
            RaidUniques.ELDER_MAUL,
            RaidUniques.KODAI,
            RaidUniques.TWISTED_BOW,
            RaidUniques.DUST,
            RaidUniques.TWISTED_KIT,
            RaidUniques.OLMLET
    );

	@Getter
	EnumSet<RaidUniques> toaUniques = EnumSet.of(
		RaidUniques.OSMUMTENS_FANG,
		RaidUniques.LIGHTBEARER,
		RaidUniques.ELIDINIS_WARD,
		RaidUniques.MASORI_MASK,
		RaidUniques.MASORI_BODY,
		RaidUniques.MASORI_CHAPS,
		RaidUniques.TUMEKENS_SHADOW,
		RaidUniques.TUMEKENS_GUARDIAN
	);

	private Component titleComponent;
	private Component filterComponent;

    public RaidTrackerPanel(
        final ItemManager itemManager,
        FileReadWriter fw,
        RaidTrackerConfig config,
        ClientThread clientThread,
        Client client,
        ConfigManager configManager,
        PluginManager pluginManager
    ) {
        this.itemManager = itemManager;
        this.fw = fw;
        this.config = config;
        this.clientThread = clientThread;
        this.client = client;
		this.configManager = configManager;
		this.pluginManager = pluginManager;

		toaFilterMap.put("All Levels", new int[]{0, 600});
		toaFilterMap.put("Entry Mode", new int[]{0, 149});
		toaFilterMap.put("Normal Mode", new int[]{150, 299});
		toaFilterMap.put("Expert Mode", new int[]{300, 600});
		toaFilterMap.put("Custom", new int[]{config.toaFilterCustomLow(), config.toaFilterCustomHigh()});

        panel.setBackground(ColorScheme.DARK_GRAY_COLOR);

        panel.setLayout(new BoxLayout(panel, BoxLayout.Y_AXIS));

        add(panel, BorderLayout.NORTH);

        updateView();
    }

    /*
    View to show when the tracker is disabled.
    This could occur due to being on a temporary world where we don't want to save the data.
     */
    private void showDisabledView() {
        panel.removeAll();

        JPanel title = new JPanel();
        JPanel titleLabelWrapper = new JPanel();
        JLabel titleLabel = new JLabel("Tracker Disabled on Beta Worlds");
        titleLabel.setForeground(Color.WHITE);

        titleLabelWrapper.add(titleLabel, BorderLayout.CENTER);

        title.add(titleLabelWrapper);

        panel.add(title);
        panel.revalidate();
        panel.repaint();
    }

	public void showWarningView() {
		panel.removeAll();

		JPanel title = new JPanel();
		title.setLayout(new GridBagLayout());
		GridBagConstraints gbc = new GridBagConstraints();
		gbc.gridx = 0;
		gbc.gridy = 0;
		gbc.weightx = 1;
		gbc.weighty = 1;
		gbc.fill = GridBagConstraints.BOTH;
        gbc.insets = new Insets(5, 5, 5, 5);

		Plugin toaPlugin = pluginManager.getPlugins()
			.stream()
			.filter(p -> p.getName().contains("Tombs of Amascut"))
			.findFirst()
			.orElse(null);

		boolean isToaPluginInstalled = toaPlugin != null;
		boolean isToaPluginEnabled = isToaPluginInstalled && pluginManager.isPluginEnabled(toaPlugin);
        boolean isToaPluginConfigSendToExternalEnabled = Boolean.parseBoolean(
            configManager.getConfiguration("tombsofamascut", "pointsTrackerAllowExternal")
        );

		if (!isToaPluginInstalled || !isToaPluginEnabled || !isToaPluginConfigSendToExternalEnabled) {
            JTextPane warningPane = getTextPane("Raid Data Tracker has detected<br>" +
                "that the <span style='color:lime'>Tombs of Amascut</span> plugin is " +
                "either not installed, not enabled,<br> " +
                "or the 'Send to external plugins'<br> " +
                "setting is disabled.<br><br>" +
                "To enable total raid party point<br>" +
                "tracking in the Tombs of Amascut, please install and enable the plugin, " +
                "and make sure that the<br>" +
                "<strong>'Send to external plugins'</strong> option " +
                "is enabled under the<br> <strong>'Points Tracker'</strong> settings.");
            title.add(warningPane, gbc);

            gbc.gridy++;
            JButton close = new JButton();
            close.setText("Close");
            close.addActionListener(e -> updateView());
            title.add(close, gbc);
		} else {
			updateView();
            return;
		}

		panel.add(title);
		panel.revalidate();
		panel.repaint();
	}

    private JTextPane getTextPane(String htmlString) {
        JTextPane pane = new JTextPane();

        pane.setEditable(false);
        pane.setBorder(BorderFactory.createEmptyBorder(5, 5, 5, 5));
        pane.setContentType("text/html");
        pane.setText("<html>" + htmlString + "</html>");

        SimpleAttributeSet set = new SimpleAttributeSet();
        StyleConstants.setAlignment(set, StyleConstants.ALIGN_CENTER);
        StyledDocument doc = pane.getStyledDocument();
        doc.setParagraphAttributes(0, doc.getLength(), set, false);

        return pane;
    }

	public void updateView() {
		updateView(false);
	}

    public void updateView(boolean filterUpdate) {

        // If the panel is updated we don't need to show data for Beta worlds
        if (WorldUtils.playerOnBetaWorld(client)) {
			panel.removeAll();
            showDisabledView();
            return;
        }

        JPanel title = getTitle();
        JPanel filterPanel = getFilterPanel();
        JPanel killsLoggedPanel = getKillsLoggedPanel();
        JPanel uniquesPanel = getUniquesPanel();
        JPanel pointsPanel = getPointsPanel();
        JPanel splitsEarnedPanel = getSplitsEarnedPanel();
        JPanel changePurples = getChangePurples();
        JPanel mvpPanel = getMvpPanel();
        JPanel timeSplitsPanel = getTimeSplitsPanel();

		// Replaces panel.removeAll() to allow for selective component removal when dealing with ToA filter keypresses
		for(Component component : panel.getComponents()) {
			if ((component.equals(titleComponent) || component.equals(filterComponent)) && filterUpdate) {
				continue;
			}
			panel.remove(component);
		}

        if (config.showRegularDrops()) {
            SwingUtilities.invokeLater(() -> {
                regularDrops = getRegularDropsPanel();

				for(Component component : panel.getComponents()) {
					if ((component.equals(titleComponent) || component.equals(filterComponent)) && filterUpdate) {
						continue;
					}
					panel.remove(component);
				}

				if (config.showTitle() && !filterUpdate) {
					panel.add(title);
					titleComponent = title;
				}

				if (config.showFilters() && !filterUpdate) {
					panel.add(filterPanel);
					filterComponent = filterPanel;
				}

                panel.add(Box.createRigidArea(new Dimension(0, 5)));

                if (config.showKillsLogged()) {
                    panel.add(killsLoggedPanel);
                    panel.add(Box.createRigidArea(new Dimension(0, 5)));
                }

                if (config.showUniquesTable()) {
                    panel.add(uniquesPanel, BorderLayout.CENTER);
                    panel.add(Box.createRigidArea(new Dimension(0, 5)));
                }

                if (selectedRaidTab.equals(RaidType.TOB) && config.showMVPs()) {
                    panel.add(mvpPanel);
                    panel.add(Box.createRigidArea(new Dimension(0, 5)));
                }
                else if (config.showPoints()){
                    panel.add(pointsPanel);
                    panel.add(Box.createRigidArea(new Dimension(0, 5)));
                }

                if (config.showSplitGPEarned()) {
                    panel.add(splitsEarnedPanel);
                    panel.add(Box.createRigidArea(new Dimension(0, 15)));
                }

                if (config.showTimeSplits()) {
                    panel.add(timeSplitsPanel);
                    panel.add(Box.createRigidArea(new Dimension(0, 15)));
                }

                if (config.showRegularDrops()) {
                    panel.add(regularDrops);
                    panel.add(Box.createRigidArea(new Dimension(0, 15)));
                }

                if (config.showSplitChanger()) {
                    panel.add(changePurples);
                }

                panel.revalidate();
                panel.repaint();
            });
        }

		if (config.showTitle() && !filterUpdate) {
			panel.add(title);
			titleComponent = title;
		}

		if (config.showFilters() && !filterUpdate) {
			panel.add(filterPanel);
			filterComponent = filterPanel;
		}

        panel.add(Box.createRigidArea(new Dimension(0, 5)));

        if (config.showKillsLogged()) {
            panel.add(killsLoggedPanel);
            panel.add(Box.createRigidArea(new Dimension(0, 5)));
        }

        if (config.showUniquesTable()) {
            panel.add(uniquesPanel, BorderLayout.CENTER);
            panel.add(Box.createRigidArea(new Dimension(0, 5)));
        }

        if (selectedRaidTab.equals(RaidType.TOB) && config.showMVPs()) {
            panel.add(mvpPanel);
            panel.add(Box.createRigidArea(new Dimension(0, 5)));
        }
        else if (config.showPoints()){
            panel.add(pointsPanel);
            panel.add(Box.createRigidArea(new Dimension(0, 5)));
        }

        if (config.showSplitGPEarned()) {
            panel.add(splitsEarnedPanel);
            panel.add(Box.createRigidArea(new Dimension(0, 15)));
        }

        if (config.showTimeSplits()) {
            panel.add(timeSplitsPanel);
            panel.add(Box.createRigidArea(new Dimension(0, 15)));
        }

        if (config.showRegularDrops()) {
            panel.add(regularDrops);
            panel.add(Box.createRigidArea(new Dimension(0, 15)));
        }

        if (config.showSplitChanger()) {
            panel.add(changePurples);
        }

        panel.revalidate();
        panel.repaint();
    }

    private JPanel getTitle() {
        final JPanel title = new JPanel();
        title.setBorder(new EmptyBorder(3, 0, 10, 0));
        title.setLayout(new BoxLayout(title, BoxLayout.Y_AXIS));


        final JPanel buttonWrapper = new JPanel();
        buttonWrapper.setLayout(new GridLayout(0, 3));
        buttonWrapper.setBorder(new EmptyBorder(5, 0, 0, 0));

        JPanel coxButtonWrapper = new JPanel();
        coxButtonWrapper.setLayout(new GridLayout(0, 1));
        JButton coxButton = new JButton();

		JPanel tobButtonWrapper = new JPanel();
		tobButtonWrapper.setLayout(new GridLayout(0, 1));
		JButton tobButton = new JButton();

		JPanel toaButtonWrapper = new JPanel();
		toaButtonWrapper.setLayout(new GridLayout(0, 1));
		JButton toaButton = new JButton();

        coxButton.setText("CoX");
        coxButton.setForeground(Color.white);
        coxButton.setFont(FontManager.getRunescapeSmallFont());
        coxButton.setContentAreaFilled(false);
        coxButton.setOpaque(false);
        coxButton.setFocusable(false);
        coxButton.setBorderPainted(false);
        coxButton.setBorder(new EmptyBorder(10, 0, 10, 0));

		if (selectedRaidTab.equals(RaidType.COX)) {
			coxButtonWrapper.setBorder(new MatteBorder(1, 1, 0, 1, ColorScheme.LIGHT_GRAY_COLOR.darker()));
		} else {
			coxButtonWrapper.setBorder(new MatteBorder(0, 0, 1, 0, ColorScheme.LIGHT_GRAY_COLOR.darker()));
		}

        coxButton.setFocusPainted(false);
        coxButton.setToolTipText("Show Chambers of Xeric Loot");
        coxButton.addActionListener(e -> {
			if (!selectedRaidTab.equals(RaidType.COX)) {
				selectedRaidTab = RaidType.COX;
				updateView();
			}
        });

        tobButton.setText("ToB");
        tobButton.setForeground(Color.white);
        tobButton.setFont(FontManager.getRunescapeSmallFont());
        tobButton.setContentAreaFilled(false);
		tobButton.setOpaque(false);
        tobButton.setFocusable(false);
        tobButton.setBorderPainted(false);
        tobButton.setBorder(new EmptyBorder(7, 0, 7, 0));

		if (selectedRaidTab.equals(RaidType.TOB)) {
			tobButtonWrapper.setBorder(new MatteBorder(1, 1, 0, 1, ColorScheme.LIGHT_GRAY_COLOR.darker()));
		} else {
			tobButtonWrapper.setBorder(new MatteBorder(0, 0, 1, 0, ColorScheme.LIGHT_GRAY_COLOR.darker()));
		}

        tobButton.setFocusPainted(false);
        tobButton.setToolTipText("Show Theatre of Blood Loot");
        tobButton.addActionListener(e -> {
			if (!selectedRaidTab.equals(RaidType.TOB)) {
				selectedRaidTab = RaidType.TOB;
				updateView();
			}
        });

		toaButton.setText("ToA");
		toaButton.setForeground(Color.white);
		toaButton.setFont(FontManager.getRunescapeSmallFont());
		toaButton.setContentAreaFilled(false);
		toaButton.setOpaque(false);
		toaButton.setFocusable(false);
		toaButton.setBorderPainted(false);
		toaButton.setBorder(new EmptyBorder(10, 0, 10, 0));

		if (selectedRaidTab.equals(RaidType.TOA)){
			toaButtonWrapper.setBorder(new MatteBorder(1, 1, 0, 1, ColorScheme.LIGHT_GRAY_COLOR.darker()));
		} else {
			toaButtonWrapper.setBorder(new MatteBorder(0, 0, 1, 0, ColorScheme.LIGHT_GRAY_COLOR.darker()));
		}

		toaButton.setFocusPainted(false);
		toaButton.setToolTipText("Show Tombs of Amascut Loot");
		toaButton.addActionListener(e -> {
			if (!selectedRaidTab.equals(RaidType.TOA)) {
				selectedRaidTab = RaidType.TOA;
				updateView();
			}
		});

        coxButtonWrapper.add(coxButton);
        tobButtonWrapper.add(tobButton);
		toaButtonWrapper.add(toaButton);

        buttonWrapper.add(coxButtonWrapper);
        buttonWrapper.add(tobButtonWrapper);
		buttonWrapper.add(toaButtonWrapper);

        JPanel titleLabelWrapper = new JPanel();
        JLabel titleLabel = new JLabel("Raid Data Tracker");
        titleLabel.setForeground(Color.WHITE);
        titleLabel.setBorder(new CompoundBorder(
                new MatteBorder(0, 0, 1, 0, ColorScheme.LIGHT_GRAY_COLOR.darker()),
                new EmptyBorder(0, 20, 5, 20)
        ));

        titleLabelWrapper.add(titleLabel, BorderLayout.CENTER);

        title.add(titleLabelWrapper);
        title.add(buttonWrapper);

        return title;
    }

    private JPanel getUniquesPanel() {
        final JPanel wrapper = new JPanel();
        wrapper.setLayout(new BoxLayout(wrapper, BoxLayout.Y_AXIS));

        final JPanel title = new JPanel();
        title.setLayout(new GridLayout(0,3));
        title.setBorder(new EmptyBorder(3, 3, 3, 3));
        title.setBackground(ColorScheme.DARKER_GRAY_COLOR.darker());

        JLabel drop = textPanel("Drop");
        JLabel titleSeen = textPanel("Seen");
        JLabel titleReceived = textPanel("Received");

        title.add(drop);
        title.add(titleReceived);
        title.add(titleSeen);


        final JPanel uniques = new JPanel();

        uniques.setLayout(new GridLayout(0,3));
        uniques.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        uniques.setBorder(new EmptyBorder(5, 5, 5, 5));

        int totalUniques = 0;
        int totalOwnName = 0;

        for (RaidUniques unique : getUniquesList()) {
            boolean isKit = false;
            boolean isDust = false;
            boolean isPet = false;

            final AsyncBufferedImage image = itemManager.getImage(unique.getItemID(), 1, false);

            final JLabel icon = new JLabel();


            icon.setIcon(new ImageIcon(resizeImage(image, 0.7, AffineTransformOp.TYPE_BILINEAR)));
            uniques.add(icon);

            image.onLoaded(() ->
            {
                icon.setIcon(new ImageIcon(resizeImage(image, 0.7, AffineTransformOp.TYPE_BILINEAR)));
                icon.revalidate();
                icon.repaint();
            });

            String amountReceived;
            String amountSeen;
            ArrayList<RaidTracker> l;
            ArrayList<RaidTracker> l2;

            switch (unique.getName()) {
                case "Metamorphic Dust":
                    l = filterDustReceivers();
                    l2 = filterOwnDusts(l);
                    isDust = true;
                    break;
                case "Twisted Kit":
                    l = filterKitReceivers();
                    l2 = filterOwnKits(l);
                    isKit = true;
                    break;
                case "Olmlet":
                case "Lil' Zik":
				case "Tumeken's guardian":
                    l = filterPetReceivers();
                    l2 = filterOwnPets(l);
                    isPet = true;
                    break;
                default:
                    l = filterRTListByName(unique.getName());
                    l2 = filterOwnDrops(l);
                    break;
            }

            amountSeen = Integer.toString(l.size());
            amountReceived = Integer.toString(l2.size());


            final JLabel received = new JLabel(amountReceived, SwingConstants.LEFT);
            final JLabel seen = new JLabel(amountSeen, SwingConstants.LEFT);

            received.setForeground(Color.WHITE);
            received.setFont(FontManager.getRunescapeSmallFont());
            seen.setForeground(Color.WHITE);
            seen.setFont(FontManager.getRunescapeSmallFont());

            final String tooltip = getUniqueToolTip(unique, l.size(), l2.size());

            if (!isDust && !isKit && !isPet) {
                totalUniques += l.size();
                totalOwnName += l2.size();
            }

            int bottomBorder = 1;

            if (isPet) {
                bottomBorder = 0;
            }

            icon.setToolTipText(tooltip);
            icon.setBorder(new MatteBorder(0,0,bottomBorder,1,ColorScheme.LIGHT_GRAY_COLOR.darker()));
            icon.setVerticalAlignment(SwingConstants.CENTER);
            icon.setHorizontalAlignment(SwingConstants.CENTER);

            received.setToolTipText(tooltip);
            received.setBorder(new MatteBorder(0,0,bottomBorder,1,ColorScheme.LIGHT_GRAY_COLOR.darker()));
            received.setVerticalAlignment(SwingConstants.CENTER);
            received.setHorizontalAlignment(SwingConstants.CENTER);

            seen.setToolTipText(tooltip);
            seen.setBorder(new MatteBorder(0,0,bottomBorder,0,ColorScheme.LIGHT_GRAY_COLOR.darker()));
            seen.setVerticalAlignment(SwingConstants.CENTER);
            seen.setHorizontalAlignment(SwingConstants.CENTER);

            uniques.add(received);

            uniques.add(seen);
        }

        JPanel total = new JPanel();
        total.setLayout(new GridLayout(0,3));
        total.setBorder(new EmptyBorder(3, 3, 3, 3));
        total.setBackground(ColorScheme.DARKER_GRAY_COLOR.darker());

        JLabel totalText = textPanel("Total Purples:");
        JLabel totalOwnNameLabel = textPanel(Integer.toString(totalOwnName));
        JLabel totalUniquesLabel = textPanel(Integer.toString(totalUniques));

        total.add(totalText);
        total.add(totalOwnNameLabel);
        total.add(totalUniquesLabel);

        wrapper.add(title);
        wrapper.add(uniques);
        wrapper.add(total);

        return wrapper;
    }

    private JPanel getPointsPanel() {
        final JPanel points = new JPanel();
        points.setLayout(new GridLayout(0,2));
        points.setBorder(new EmptyBorder(3, 3, 3, 3));
        points.setBackground(ColorScheme.DARKER_GRAY_COLOR.darker());

        JLabel personalTitle = textPanel("Personal Points");
        JLabel totalTitle = textPanel("Total Points");

        points.add(personalTitle);
        points.add(totalTitle);

        int personalPoints = 0;
        int totalPoints = 0;

        if (loaded) {
            personalPoints = atLeastZero(getFilteredRTList().stream().mapToInt(RaidTracker::getPersonalPoints).sum());
            totalPoints = atLeastZero(getFilteredRTList().stream().mapToInt(RaidTracker::getTotalPoints).sum());
        }

        JLabel personalPointsLabel = textPanel(format(personalPoints));
        personalPointsLabel.setToolTipText(NumberFormat.getInstance().format(personalPoints) + " Personal Points");
        personalTitle.setToolTipText(NumberFormat.getInstance().format(personalPoints) + " Personal Points");

        JLabel totalPointsLabel = textPanel(format(totalPoints));
        totalPointsLabel.setToolTipText(NumberFormat.getInstance().format(totalPoints) + " Total Points");
        totalTitle.setToolTipText(NumberFormat.getInstance().format(totalPoints) + " Total Points");

        points.add(personalPointsLabel);
        points.add(totalPointsLabel);

        return points;
    }

    private JPanel getSplitsEarnedPanel() {
        final JPanel wrapper = new JPanel();
        wrapper.setLayout(new GridLayout(0,2));
        wrapper.setBorder(new EmptyBorder(3, 3, 3, 3));
        wrapper.setBackground(ColorScheme.DARKER_GRAY_COLOR.darker());

        int splitGP = 0;

        if (loaded) {
            splitGP = atLeastZero(getFilteredRTList().stream().mapToInt(RaidTracker::getLootSplitReceived).sum());


        }

        JLabel textLabel = textPanel("Split GP earned:");
        textLabel.setToolTipText("GP earned counting the split GP you earned from a drop");

        JLabel valueLabel = textPanel(format(splitGP));
        valueLabel.setToolTipText(NumberFormat.getInstance().format(splitGP) + " gp");

        if (splitGP > 1000000) {
            valueLabel.setForeground(Color.GREEN);
        }

        wrapper.add(textLabel);
        wrapper.add(valueLabel);

        return wrapper;
    }

    private JPanel getKillsLoggedPanel() {
        final JPanel wrapper = new JPanel();
        wrapper.setLayout(new GridLayout(0,2));
        wrapper.setBorder(new EmptyBorder(3, 3, 3, 3));
        wrapper.setBackground(ColorScheme.DARKER_GRAY_COLOR.darker());

        int killsLogged = 0;

        if (loaded) {
            killsLogged = getDistinctKills(getFilteredRTList()).size();
        }

        JLabel textLabel = textPanel("Kills Logged:");
        JLabel valueLabel = textPanel(Integer.toString(killsLogged));

        wrapper.add(textLabel);
        wrapper.add(valueLabel);

        return wrapper;
    }

    private JPanel getRegularDropsPanel() {
        final JPanel wrapper = new JPanel();
        wrapper.setLayout(new BoxLayout(wrapper, BoxLayout.Y_AXIS));

        if (loaded) {
            Map<Integer, RaidTrackerItem> uniqueIDs = new HashMap<>();
            try {
                uniqueIDs = getDistinctRegularDrops().get();
            } catch (InterruptedException | ExecutionException e) {
                uniqueIDs = new HashMap<>();
            } finally {
                Map<Integer, Integer> priceMap = new HashMap<>();

                for (RaidTrackerItem item : uniqueIDs.values()) {
                    priceMap.put(item.getId(), item.getPrice());
                }

                if (!uniqueIDs.values().isEmpty()) {
                    for (RaidTracker RT : getFilteredRTList()) {
                        for (RaidTrackerItem item : RT.getLootList()) {
                            RaidTrackerItem RTI = uniqueIDs.get(item.getId());

                            //making sure to not change the clues here as it's been handled in getDistinctRegularDrops
                            if (RTI != null && RTI.getId() != 12073) {
                                int qty = RTI.getQuantity();
                                RTI.setQuantity(qty + item.getQuantity());

                                RTI.setPrice(priceMap.get(item.getId()) * RTI.getQuantity());

                                uniqueIDs.replace(item.getId(), RTI);
                            }
                        }
                    }

                    ArrayList<RaidTrackerItem> regularDropsList = new ArrayList<>(uniqueIDs.values());

                    regularDropsList.sort((o2, o1) -> Integer.compare(o1.getPrice(), o2.getPrice()));


                    int regularDropsSum = regularDropsList.stream().mapToInt(RaidTrackerItem::getPrice).sum();

                    final JPanel drops = new JPanel();
                    drops.setLayout(new GridLayout(0, 5));

                    for (RaidTrackerItem drop : regularDropsList) {
                        AsyncBufferedImage image = itemManager.getImage(drop.getId(), drop.getQuantity(), drop.getQuantity() > 1);

                        JPanel iconWrapper = new JPanel();
                        iconWrapper.setPreferredSize(new Dimension(40, 40));
                        iconWrapper.setBackground(ColorScheme.DARKER_GRAY_COLOR);

                        JLabel icon = new JLabel();
                        image.addTo(icon);
                        icon.setBorder(new EmptyBorder(0, 5, 0, 0));

                        image.onLoaded(() ->
                        {
                            image.addTo(icon);
                            icon.revalidate();
                            icon.repaint();
                        });

                        iconWrapper.add(icon, BorderLayout.CENTER);
                        iconWrapper.setBorder(new MatteBorder(1, 0, 0, 1, ColorScheme.DARK_GRAY_COLOR));
                        iconWrapper.setToolTipText(getRegularToolTip(drop));

                        drops.add(iconWrapper);
                    }

                    final JPanel title = new JPanel();
                    title.setLayout(new GridLayout(0, 2));
                    title.setBorder(new EmptyBorder(3, 20, 3, 10));
                    title.setBackground(ColorScheme.DARKER_GRAY_COLOR.darker());

                    JLabel textLabel = textPanel("Regular Drops");
                    textLabel.setHorizontalAlignment(SwingConstants.LEFT);

                    JLabel valueLabel = textPanel(format(regularDropsSum) + " gp");
                    valueLabel.setHorizontalAlignment(SwingConstants.RIGHT);
                    valueLabel.setForeground(Color.LIGHT_GRAY.darker());
                    valueLabel.setToolTipText(NumberFormat.getInstance().format(regularDropsSum));

                    title.add(textLabel);
                    title.add(valueLabel);


                    wrapper.add(title);
                    wrapper.add(drops);
                }
            }
        }

        return wrapper;
    }

    private JPanel getChangePurples() {
        final JPanel wrapper = new JPanel();
        wrapper.setLayout(new BoxLayout(wrapper, BoxLayout.Y_AXIS));

        ArrayList<SplitChanger> SCList = new ArrayList<>();

        JPanel titleWrapper = new JPanel();
        titleWrapper.setLayout(new GridBagLayout());
        titleWrapper.setBackground(ColorScheme.DARKER_GRAY_COLOR.darker());
        titleWrapper.setBorder(new EmptyBorder(3,3,3,3));

        GridBagConstraints c = new GridBagConstraints();
        c.fill = SwingConstants.HORIZONTAL;
        c.gridx = 0;
        c.weightx = 1;

        JLabel changes = textPanel("Change Purple Splits");
        changes.setBorder(new EmptyBorder(0,5,0,0));

        update = new JButton();
        update.setText("Update");
        update.setFont(FontManager.getRunescapeSmallFont());
        update.setPreferredSize(new Dimension(60,20));
        update.setEnabled(false);
        update.setBorder(new EmptyBorder(2,2,2,2));
        update.setFocusPainted(false);
        update.setToolTipText("Nothing to update");
        update.addActionListener(e -> {
			switch(selectedRaidTab) {
                case COX:
                    SCList.forEach(SC -> {
                        RaidTracker tempRaidTracker = SC.getRaidTracker();
                        coxUUIDMap.put(tempRaidTracker.getUniqueID(), tempRaidTracker);
                    });
                    coxRTList = new ArrayList<>(coxUUIDMap.values());
                    fw.updateRTList(coxRTList, RaidType.COX);
                    break;
				case TOB:
					SCList.forEach(SC -> {
						RaidTracker tempRaidTracker = SC.getRaidTracker();
						tobUUIDMap.put(tempRaidTracker.getUniqueID(), tempRaidTracker);
					});
					tobRTList = new ArrayList<>(tobUUIDMap.values());
					fw.updateRTList(tobRTList, RaidType.TOB);
					break;
				case TOA:
					SCList.forEach(SC -> {
						RaidTracker tempRaidTracker = SC.getRaidTracker();
						toaUUIDMap.put(tempRaidTracker.getUniqueID(), tempRaidTracker);
					});
					toaRTList = new ArrayList<>(toaUUIDMap.values());
					fw.updateRTList(toaRTList, RaidType.TOA);
					break;
				default:
                    log.error("Unexpected selectedRaidTab value, unable to update purple splits.");
                    break;
			}

            updateView();
        });

        c.anchor = GridBagConstraints.WEST;
        titleWrapper.add(changes, c);

        c.gridx++;
        c.anchor = GridBagConstraints.EAST;

        titleWrapper.add(update , c);

        if (loaded) {
            ArrayList<RaidTracker> purpleList = filterPurples();
            purpleList.sort((o2, o1) -> Long.compare(o1.getDate(), o2.getDate()));

            if (purpleList.size() > 0) {
                wrapper.add(titleWrapper);
                wrapper.add(Box.createRigidArea(new Dimension(0, 2)));

                for (int i = 0; i < Math.min(purpleList.size(), 10); i++) {
                    RaidTracker RT = purpleList.get(i);
                    SplitChanger SC = new SplitChanger(itemManager, RT, this);
                    SCList.add(SC);
                    wrapper.add(SC);
                    wrapper.add(Box.createRigidArea(new Dimension(0, 7)));
                }
            }
        }

        return wrapper;
    }

    @SuppressWarnings("ConstantConditions")
    private JPanel getFilterPanel() {
        final JPanel wrapper = new JPanel();
        wrapper.setLayout(new GridBagLayout());
        wrapper.setBackground(ColorScheme.DARKER_GRAY_COLOR.darker());
        wrapper.setBorder(new EmptyBorder(5,5,5,5));

        GridBagConstraints c = new GridBagConstraints();
        c.fill = SwingConstants.HORIZONTAL;
        c.weightx = 1;
        c.weighty = 1;
        c.gridx = 0;
        c.gridy = 0;

        JLabel filter = textPanel("Filter kills logged");
        filter.setHorizontalAlignment(SwingConstants.LEFT);
        filter.setBorder(new EmptyBorder(0,0,0,17));
        c.anchor = GridBagConstraints.WEST;
        wrapper.add(filter);

        JComboBox<String> choices = new JComboBox<>(new String []{"All Time", "12 Hours", "Today", "3 Days", "Week", "Month","3 Months", "Year", "X Kills"});
        choices.setSelectedItem(dateFilter);
		choices.setPreferredSize(new Dimension(105, 25));
		choices.setMinimumSize(new Dimension(100, 25));
		choices.setMaximumSize(new Dimension(110, 25));
        choices.setFocusable(false);

        choices.addActionListener(e ->  {
            dateFilter = choices.getSelectedItem().toString();
            if (dateFilter.equals("X Kills")) {
                choices.setToolTipText("X can be changed in the settings");
            }
            else {
                choices.setToolTipText(null);
            }
            if (loaded) {
                updateView();
            }
        });

        JComboBox<String> cm = new JComboBox<>(new String []{"CM & Normal", "Normal Only", "CM Only"});
        cm.setFocusable(false);
		cm.setPreferredSize(new Dimension(105,25));
		cm.setMinimumSize(new Dimension(100, 25));
		cm.setMaximumSize(new Dimension(110, 25));
        cm.setSelectedItem(cmFilter);

        cm.addActionListener(e -> {
            cmFilter = cm.getSelectedItem().toString();
            if (loaded) {
                updateView();
            }
        });

        JComboBox<String> mvp = new JComboBox<>(new String []{"Both", "My MVP", "Not My MVP"});
        mvp.setFocusable(false);
		mvp.setPreferredSize(new Dimension(105,25));
		mvp.setMinimumSize(new Dimension(100, 25));
		mvp.setMaximumSize(new Dimension(110, 25));
        mvp.setSelectedItem(mvpFilter);

        mvp.addActionListener(e -> {
            mvpFilter = mvp.getSelectedItem().toString();
            if (loaded) {
                updateView();
            }
        });

		JComboBox<String> raidLevel = new JComboBox<>(new String []{"All Levels", "Entry Mode", "Normal Mode", "Expert Mode", "Custom"});
		raidLevel.setFocusable(false);
		raidLevel.setPreferredSize(new Dimension(105,25));
		raidLevel.setMinimumSize(new Dimension(100, 25));
		raidLevel.setMaximumSize(new Dimension(110, 25));
		raidLevel.setSelectedItem(raidLevelFilter);

		raidLevel.addActionListener(e -> {

			if (raidLevelFilterIsAPI) {
				raidLevelFilterIsAPI = false;
				return;
			}

			raidLevelFilter = raidLevel.getSelectedItem().toString();
			raidLevelFilterLow = toaFilterMap.get(raidLevelFilter)[0];
			raidLevelFilterHigh = toaFilterMap.get(raidLevelFilter)[1];

			if (loaded) {
				updateView();
			}
		});

        JComboBox<String> teamSize;

		switch (selectedRaidTab) {
            case COX:
                teamSize = new JComboBox<>(new String [] {
                    "All sizes",
                    "Solo",
                    "Duo",
                    "Trio",
                    "4-man",
                    "5-man",
                    "6-man",
                    "7-man",
                    "8-10 Players",
                    "11-14 Players",
                    "15-24 Players",
                    "24+ Players"
                });
                break;
			case TOB:
				teamSize = new JComboBox<>(new String [] {
                    "All sizes",
                    "Solo",
                    "Duo",
                    "Trio",
                    "4-man",
                    "5-man"
                });
				break;
			case TOA:
				teamSize = new JComboBox<>(new String [] {
                    "All sizes",
                    "Solo",
                    "Duo",
                    "Trio",
                    "4-man",
                    "5-man",
                    "6-man",
                    "7-man",
                    "8-man"
                });
				break;
			default:
                teamSize = new JComboBox<>(new String [] {
                    "All sizes",
                    "Solo"
                });
                break;
		}

        teamSize.setFocusable(false);
        teamSize.setPreferredSize(new Dimension(105, 25));
		teamSize.setMinimumSize(new Dimension(100, 25));
		teamSize.setMaximumSize(new Dimension(110, 25));
        teamSize.setSelectedItem(teamSizeFilter);

        teamSize.addActionListener(e -> {
            teamSizeFilter = teamSize.getSelectedItem().toString();
            if (loaded) {
                updateView();
            }
        });


        c.gridy = 1;
        wrapper.add(Box.createRigidArea(new Dimension(0, 5)), c);

        c.gridy = 2;
        wrapper.add(choices, c);

		c.gridy = 4;

		wrapper.add(teamSize, c);

		c.gridy = 2;
        c.gridx = 1;
        c.anchor = GridBagConstraints.EAST;

		switch (selectedRaidTab) {
            case COX:
                wrapper.add(cm, c);
                break;
			case TOB:
				wrapper.add(mvp, c);
				break;
			case TOA:
				wrapper.add(raidLevel, c);
				break;
			default:
				break;

		}

        c.gridy = 3;
        wrapper.add(Box.createRigidArea(new Dimension(0, 2)), c);

		c.gridy = 4;

		if (selectedRaidTab.equals(RaidType.TOA)) {
			wrapper.add(getToAFilterPanel(), c);
		}

        JPanel buttonWrapper = new JPanel();
        buttonWrapper.setPreferredSize(new Dimension(82, 20));
        buttonWrapper.setBackground(ColorScheme.DARKER_GRAY_COLOR.darker());
		buttonWrapper.setLayout(new GridLayout(0, 2, 2 ,0));
		if (selectedRaidTab.equals(RaidType.TOA)) {
			buttonWrapper.setLayout(new GridLayout(0, 3, 2 ,0));
		}

		BufferedImage saveIcon = ImageUtil.loadImageResource(getClass(), "save-grey.png");
		BufferedImage saveHover = ImageUtil.loadImageResource(getClass(), "save-white.png");
        BufferedImage refreshIcon = ImageUtil.loadImageResource(getClass(), "refresh-grey.png");
        BufferedImage refreshHover = ImageUtil.loadImageResource(getClass(), "refresh-white.png");
        BufferedImage deleteIcon = ImageUtil.loadImageResource(getClass(), "delete-grey.png");
        BufferedImage deleteHover = ImageUtil.loadImageResource(getClass(), "delete-white.png");

		JButton save = imageButton(saveIcon);
		save.setToolTipText("Save Custom Filter");
		save.addActionListener(e -> {
			final int saveInput = JOptionPane.showConfirmDialog(
                this.getRootPane(),
                "<html>Are you sure you want to save this Custom filter preset?<br>" +
                    "It will overwrite your previous Custom filter values.<br>" +
                    "There is no way to undo this action.</html>",
                "Warning - Raid Data Tracker Custom Filter",
                JOptionPane.YES_NO_OPTION);
			if (saveInput == JOptionPane.YES_OPTION)
			{
				configManager.setConfiguration(RaidTrackerConfig.CONFIG_GROUP, "toaFilterCustomLow", raidLevelFilterLow);
				configManager.setConfiguration(RaidTrackerConfig.CONFIG_GROUP, "toaFilterCustomHigh", raidLevelFilterHigh);
				toaFilterMap.put("Custom", new int[]{raidLevelFilterLow, raidLevelFilterHigh});
				updateView();
			}
		});

        JButton refresh = imageButton(refreshIcon);
        refresh.setToolTipText("Refresh kills logged");
        refresh.addActionListener(e -> {
            if (loaded) {
                loadRTList();
            }
        });

        JButton delete = imageButton(deleteIcon);
        delete.setToolTipText("Delete all logged kills");
        delete.addActionListener(e -> {
            if (loaded) {
                clearData();
            }
        });

		save.addMouseListener(new MouseAdapter() {
			public void mouseEntered (MouseEvent e){
				save.setIcon(new ImageIcon(saveHover));
			}

			public void mouseExited (MouseEvent e){
				save.setIcon(new ImageIcon(saveIcon));
			}
		});
        refresh.addMouseListener(new MouseAdapter() {
            public void mouseEntered (MouseEvent e){
                refresh.setIcon(new ImageIcon(refreshHover));
            }

            public void mouseExited (MouseEvent e){
                refresh.setIcon(new ImageIcon(refreshIcon));
            }
        });

        delete.addMouseListener(new MouseAdapter() {
            public void mouseEntered (MouseEvent e){
                delete.setIcon(new ImageIcon(deleteHover));
            }

            public void mouseExited (MouseEvent e){
                delete.setIcon(new ImageIcon(deleteIcon));
            }
        });

		if (selectedRaidTab.equals(RaidType.TOA)) {
			buttonWrapper.add(save);
		}
        buttonWrapper.add(refresh);
        buttonWrapper.add(delete);

        c.gridy = 0;

        wrapper.add(buttonWrapper, c);
        return wrapper;
    }

    private JPanel getMvpPanel() {
        final JPanel wrapper = new JPanel();
        wrapper.setLayout(new GridLayout(0,2));
        wrapper.setBorder(new EmptyBorder(3, 3, 3, 3));
        wrapper.setBackground(ColorScheme.DARKER_GRAY_COLOR.darker());

        int mvpAmount = 0;


        if (loaded) {
            mvpAmount = tobRTList.stream().mapToInt(RT -> {
                if (RT.isMvpInOwnName()) {
                    return 1;
                }
                return 0;
            }).sum();


        }

        JLabel textLabel = textPanel("Total MVP's:");

        JLabel valueLabel = textPanel(Integer.toString(mvpAmount));

        wrapper.add(textLabel);
        wrapper.add(valueLabel);
        return wrapper;
    }

	private JPanel getToAFilterPanel() {
		JPanel wrapper = new JPanel();
		wrapper.setLayout(new GridBagLayout());
		wrapper.setBackground(ColorScheme.DARKER_GRAY_COLOR.darker());
		wrapper.setPreferredSize(new Dimension(105,25));
		wrapper.setMinimumSize(new Dimension(100, 25));
		wrapper.setMaximumSize(new Dimension(110, 25));

		GridBagConstraints c2 = new GridBagConstraints();

		c2.weightx = 1;
		c2.weighty = 1;
		c2.gridx = 0;
		c2.gridy = 0;

		JTextField filterFieldLow = new JTextField();
		JTextField filterFieldHigh = new JTextField();

		filterFieldLow.setMinimumSize(new Dimension(40, 25));
		filterFieldLow.setMaximumSize(new Dimension(42, 25));
		filterFieldLow.setText(String.valueOf(raidLevelFilterLow));
		filterFieldLow.setFocusable(true);
		filterFieldLow.putClientProperty("JTextField.selectAllOnFocusPolicy", "never");

		String val1 = filterFieldLow.getText();
		filterFieldLow.addKeyListener(new KeyAdapter() {
			@Override
			public void keyReleased(KeyEvent e) {
				String userInput = filterFieldLow.getText();


				if (userInput.isEmpty()) {
					raidLevelFilterLow = toaRaidLevelMin;
					return;
				}

				if (!Pattern.matches("-?\\d+", userInput)) {
					filterFieldLow.setText(val1);
					return;
				}

				if (userInput.startsWith("0")) {
					filterFieldLow.setText(String.valueOf(Integer.parseInt(userInput)));
				}

				raidLevelFilterLow = Integer.parseInt(userInput);

				if (Integer.parseInt(userInput) == toaRaidLevelMin) {
					raidLevelFilterLow = toaRaidLevelMin;
				}

				if (Integer.parseInt(userInput) > toaRaidLevelMax) {
					SwingUtilities.invokeLater(new Runnable() {

						@Override
						public void run() {
							filterFieldLow.setText(String.valueOf(toaRaidLevelMax));
							raidLevelFilterLow = toaRaidLevelMax;
						}
					});
				}

				updateRaidFilterSilently(wrapper);
			}
		});


		filterFieldHigh.setMinimumSize(new Dimension(40, 25));
		filterFieldHigh.setMaximumSize(new Dimension(42, 25));
		filterFieldHigh.setText(String.valueOf(raidLevelFilterHigh));
		filterFieldHigh.setFocusable(true);
		filterFieldHigh.putClientProperty("JTextField.selectAllOnFocusPolicy", "never");

		String val2 = filterFieldHigh.getText();

		filterFieldHigh.addKeyListener(new KeyAdapter() {

			@Override
			public void keyReleased(KeyEvent e) {
				String userInput = filterFieldHigh.getText();

				if (userInput.isEmpty()) {
					raidLevelFilterHigh = toaRaidLevelMax;
					return;
				}

				if (!Pattern.matches("-?\\d+", userInput)) {
					filterFieldHigh.setText(val2);
					return;
				}

				if (Integer.parseInt(userInput) == toaRaidLevelMin) {
					return;
				}

				if (userInput.startsWith("0")) {
					filterFieldHigh.setText(String.valueOf(Integer.parseInt(userInput)));
				}

				raidLevelFilterHigh = Integer.parseInt(userInput);

				if (Integer.parseInt(userInput) > toaRaidLevelMax) {
					SwingUtilities.invokeLater(new Runnable()
					{
						@Override
						public void run()
						{
							filterFieldHigh.setText(String.valueOf(toaRaidLevelMax));
							raidLevelFilterHigh = toaRaidLevelMax;
						}
					});
				}

				updateRaidFilterSilently(wrapper);

			}
		});

		wrapper.add(filterFieldLow, c2);

		c2.gridx = 1;

		JLabel to = new JLabel();
		to.setText("to");

		to.setHorizontalAlignment(SwingConstants.CENTER);

		to.setMinimumSize(new Dimension(22, 25));

		wrapper.add(to, c2);
		c2.gridx = 2;
		wrapper.add(filterFieldHigh, c2);

		return wrapper;
	}

	@SuppressWarnings("unchecked")
	private void updateRaidFilterSilently(JPanel wrapper) {
		JComboBox<String> tempField;
		for (int i = wrapper.getParent().getComponentCount() - 1; i >= 0; i--) {
			if (wrapper.getParent().getComponent(i) instanceof JComboBox) {
				tempField = (JComboBox<String>) wrapper.getParent().getComponent(i);

				SwingUtilities.invokeLater(new Runnable()
				{
					@Override
					public void run()
					{

						raidLevelFilterIsAPI = true;
						tempField.setSelectedIndex(tempField.getItemCount() - 1);
					}
				});

				break;
			}
		}

		raidLevelFilter = "Custom";
		updateView(true);
	}

	private JPanel getTimeSplitsPanel() {
        final JPanel wrapper = new JPanel();

        if (loaded) {
            wrapper.setLayout(new BoxLayout(wrapper, BoxLayout.Y_AXIS));
            wrapper.setBorder(new EmptyBorder(3, 0, 0, 0));
            wrapper.setBackground(ColorScheme.DARKER_GRAY_COLOR.darker());

            final JPanel title = new JPanel();

            title.setBorder(new EmptyBorder(3, 20, 3, 10));
            title.setLayout(new GridLayout(0, 1));
            title.setBackground(ColorScheme.DARKER_GRAY_COLOR.darker());

            JLabel textLabel = textPanel("Best Recorded Times");

            title.add(textLabel);

			wrapper.add(title);

			JPanel timeTableContainer = new JPanel();
			timeTableContainer.setBorder(new EmptyBorder(1, 7, 5, 7));
			timeTableContainer.setLayout(new GridLayout(0, 1));
			timeTableContainer.setBackground(ColorScheme.DARKER_GRAY_COLOR);

			JPanel timeTable = new JPanel();
			JPanel timeTableFourCol = new JPanel();

			switch(selectedRaidTab) {
                case COX:
                    timeTable.setLayout(new GridLayout(0, 2));
                    timeTable.setBorder(new EmptyBorder(5,3,1,3));
                    timeTable.setBackground(ColorScheme.DARKER_GRAY_COLOR);

                    timeTable.add(textPanel("Upper Level", 0));
                    timeTable.add(textPanel(secondsToMinuteString(
                        getFilteredRTList().stream()
                            .filter(RT -> RT.getUpperTime() > 0)
                            .min(comparing(RaidTracker::getUpperTime))
                            .orElse(new RaidTracker())
                            .getUpperTime()
                    ), 1));

                    if (!cmFilter.equals("Normal Only")) {
                        int middleTime = getFilteredRTList().stream()
                                            .filter(RT -> RT.getMiddleTime() > 0)
                                            .min(comparing(RaidTracker::getMiddleTime))
                                            .orElse(new RaidTracker())
                                            .getMiddleTime();
                        if (middleTime > 0) {
                            timeTable.add(textPanel("Middle Level", 0));
                            timeTable.add(textPanel(secondsToMinuteString(middleTime), 1));
                        }

                    }
                    timeTable.add(textPanel("Lower Level", 0));
                    timeTable.add(textPanel(secondsToMinuteString(
                        getFilteredRTList().stream()
                            .filter(RT -> RT.getLowerTime() > 0)
                            .min(comparing(RaidTracker::getLowerTime))
                            .orElse(new RaidTracker())
                            .getLowerTime()
                    ), 1));

                    timeTable.add(textPanel("Olm Time", 0));

                    RaidTracker olmTimeRT = getFilteredRTList().stream()
                        .filter(RT -> RT.getLowerTime() > 0 && RT.getRaidTime() > 0)
                        .min(Comparator.comparingInt(o -> o.getRaidTime() - o.getLowerTime()))
                        .orElse(new RaidTracker());

                    timeTable.add(textPanel(secondsToMinuteString(
                        olmTimeRT.getRaidTime() - olmTimeRT.getLowerTime()
                    ), 1));
                    wrapper.add(timeTable);
                    break;
				case TOB:
					timeTable.setLayout(new GridLayout(0, 2));
					timeTable.setBorder(new EmptyBorder(5,3,1,3));
					timeTable.setBackground(ColorScheme.DARKER_GRAY_COLOR);
					timeTable.add(textPanel("Maiden Time", 0));
					timeTable.add(textPanel(secondsToMinuteString(
                        getFilteredRTList().stream()
                            .filter(RT -> RT.getMaidenTime() > 0)
                            .min(comparing(RaidTracker::getMaidenTime))
                            .orElse(new RaidTracker())
                            .getMaidenTime()
                    ), 1));
					timeTable.add(textPanel("Bloat Time", 0));
					timeTable.add(textPanel(secondsToMinuteString(
                        getFilteredRTList().stream()
                            .filter(RT -> RT.getBloatTime() > 0)
                            .min(comparing(RaidTracker::getBloatTime))
                            .orElse(new RaidTracker())
                            .getBloatTime()
                    ), 1));
					timeTable.add(textPanel("Nylo Time", 0));
					timeTable.add(textPanel(secondsToMinuteString(
                        getFilteredRTList().stream()
                            .filter(RT -> RT.getNyloTime() > 0)
                            .min(comparing(RaidTracker::getNyloTime))
                            .orElse(new RaidTracker())
                            .getNyloTime()
                    ), 1));
					timeTable.add(textPanel("Sotetseg Time", 0));
					timeTable.add(textPanel(secondsToMinuteString(
                        getFilteredRTList().stream()
                            .filter(RT -> RT.getSotetsegTime() > 0)
                            .min(comparing(RaidTracker::getSotetsegTime))
                            .orElse(new RaidTracker())
                            .getSotetsegTime()
                    ), 1));
					timeTable.add(textPanel("Xarpus Time", 0));
					timeTable.add(textPanel(secondsToMinuteString(
                            getFilteredRTList().stream()
                                .filter(RT -> RT.getNyloTime() > 0)
                                .min(comparing(RaidTracker::getXarpusTime))
                                .orElse(new RaidTracker())
                                .getXarpusTime()
                        ), 1));
					timeTable.add(textPanel("Verzik Time", 0));
					timeTable.add(textPanel(
                            secondsToMinuteString(
                                getFilteredRTList().stream()
                                    .filter(RT -> RT.getVerzikTime() > 0)
                                    .min(comparing(RaidTracker::getVerzikTime))
                                    .orElse(new RaidTracker())
                                    .getVerzikTime()
                            ),
                        1));
					break;
				case TOA:
					timeTableFourCol.setLayout(new GridLayout(0, 4));
					timeTableFourCol.setBorder(new EmptyBorder(5,0,0,0));
					timeTableFourCol.setBackground(ColorScheme.DARKER_GRAY_COLOR);
					timeTableFourCol.add(textPanel("", 0));
					timeTableFourCol.add(textPanel("Puzzle", 0));
					timeTableFourCol.add(textPanel("Boss", 0));
					timeTableFourCol.add(textPanel("Path", 1));
					timeTableContainer.add(timeTableFourCol);

					timeTableFourCol = stripedPanel(true);
					timeTableFourCol.add(textPanel("Ba-Ba", 2));
					timeTableFourCol.add(textPanel(secondsToMinuteString(
                        getFilteredRTList().stream()
                            .filter(RT -> RT.getApmekenTime() > 0)
                            .min(comparing(RaidTracker::getApmekenTime))
                            .orElse(new RaidTracker())
                            .getApmekenTime()
                    ), 2));
					timeTableFourCol.add(textPanel(secondsToMinuteString(
                        getFilteredRTList().stream()
                            .filter(RT -> RT.getBabaTime() > 0)
                            .min(comparing(RaidTracker::getBabaTime))
                            .orElse(new RaidTracker())
                            .getBabaTime()), 2));
					timeTableFourCol.add(textPanel(secondsToMinuteString(
                        getFilteredRTList().stream()
                            .filter(RT -> RT.getApmekenTime() > 0 && RT.getBabaTime() > 0)
                            .mapToInt(RT -> RT.getApmekenTime() + RT.getBabaTime())
                            .reduce(Math::min)
                            .orElse(0)
                    ), 3));
					timeTableContainer.add(timeTableFourCol);

					timeTableFourCol = stripedPanel(false);
					timeTableFourCol.add(textPanel("Kephri", 2));
					timeTableFourCol.add(textPanel(secondsToMinuteString(
                        getFilteredRTList().stream()
                            .filter(RT -> RT.getScabarasTime() > 0)
                            .min(comparing(RaidTracker::getScabarasTime))
                            .orElse(new RaidTracker())
                            .getScabarasTime()
                    ), 2));
					timeTableFourCol.add(textPanel(secondsToMinuteString(
                        getFilteredRTList().stream()
                            .filter(RT -> RT.getKephriTime() > 0)
                            .min(comparing(RaidTracker::getKephriTime))
                            .orElse(new RaidTracker())
                            .getKephriTime()
                    ), 2));
					timeTableFourCol.add(textPanel(secondsToMinuteString(
                        getFilteredRTList().stream()
                            .filter(RT -> RT.getScabarasTime() > 0 && RT.getKephriTime() > 0)
                            .mapToInt(RT -> RT.getScabarasTime() + RT.getKephriTime())
                            .reduce(Math::min)
                            .orElse(0)
                    ), 3));
					timeTableContainer.add(timeTableFourCol);

					timeTableFourCol = stripedPanel(true);
					timeTableFourCol.add(textPanel("Akkha", 2));
					timeTableFourCol.add(textPanel(secondsToMinuteString(
                        getFilteredRTList().stream()
                            .filter(RT -> RT.getHetTime() > 0)
                            .min(comparing(RaidTracker::getHetTime))
                            .orElse(new RaidTracker())
                            .getHetTime()
                    ), 2));
					timeTableFourCol.add(textPanel(secondsToMinuteString(
                        getFilteredRTList().stream()
                            .filter(RT -> RT.getAkkhaTime() > 0)
                            .min(comparing(RaidTracker::getAkkhaTime))
                            .orElse(new RaidTracker())
                            .getAkkhaTime()
                    ), 2));
					timeTableFourCol.add(textPanel(secondsToMinuteString(
                        getFilteredRTList().stream()
                            .filter(RT -> RT.getHetTime() > 0 && RT.getAkkhaTime() > 0)
                            .mapToInt(RT -> RT.getHetTime() + RT.getAkkhaTime())
                            .reduce(Math::min)
                            .orElse(0)
                    ), 3));
					timeTableContainer.add(timeTableFourCol);

					timeTableFourCol = stripedPanel(false);
					timeTableFourCol.add(textPanel("Zebak", 4));
					timeTableFourCol.add(textPanel(secondsToMinuteString(
                        getFilteredRTList().stream()
                            .filter(RT -> RT.getCrondisTime() > 0)
                            .min(comparing(RaidTracker::getCrondisTime))
                            .orElse(new RaidTracker())
                            .getCrondisTime()
                    ), 4));
					timeTableFourCol.add(textPanel(secondsToMinuteString(
                        getFilteredRTList().stream()
                            .filter(RT -> RT.getZebakTime() > 0)
                            .min(comparing(RaidTracker::getZebakTime))
                            .orElse(new RaidTracker())
                            .getZebakTime()
                    ), 4));
					timeTableFourCol.add(textPanel(secondsToMinuteString(
                        getFilteredRTList().stream()
                            .filter(RT -> RT.getCrondisTime() > 0 && RT.getZebakTime() > 0)
                            .mapToInt(RT -> RT.getCrondisTime() + RT.getZebakTime())
                            .reduce(Math::min)
                            .orElse(0)
                    ), 5));
					timeTableContainer.add(timeTableFourCol);

					timeTable = new JPanel();
					timeTable.setLayout(new GridLayout(0, 2));
					timeTable.setBackground(ColorScheme.DARK_GRAY_COLOR);
					timeTable.add(textPanel("Completion Time", 4));
					timeTable.add(textPanel(secondsToMinuteString(
                        getFilteredRTList().stream()
                            .filter(RT -> RT.getToaCompTime() > 0)
                            .min(comparing(RaidTracker::getToaCompTime))
                            .orElse(new RaidTracker())
                            .getToaCompTime()
                    ), 5));
					timeTableContainer.add(timeTable);
					break;
				default:
                    break;
			}

			timeTable = new JPanel();
			timeTable.setLayout(new GridLayout(0, 2));
			timeTable.setBorder(new EmptyBorder(0,3,0,3));
			timeTable.setBackground(ColorScheme.DARKER_GRAY_COLOR);

			if (selectedRaidTab == RaidType.TOA) {
				timeTable.add(textPanel("Overall Time", 7));
				timeTable.add(textPanel(secondsToMinuteString(
                    getFilteredRTList().stream()
                        .filter(RT -> RT.getRaidTime() > 0)
                        .min(comparing(RaidTracker::getRaidTime))
                        .orElse(new RaidTracker())
                        .getRaidTime()
                ), 6));
				timeTableContainer.add(timeTable);
				wrapper.add(timeTableContainer);
			} else {
				timeTable.add(textPanel("Overall Time", 2));
				timeTable.add(textPanel(secondsToMinuteString(
                    getFilteredRTList().stream()
                        .filter(RT -> RT.getRaidTime() > 0)
                        .min(comparing(RaidTracker::getRaidTime))
                        .orElse(new RaidTracker())
                        .getRaidTime()
                ), 3));
				wrapper.add(timeTable);
			}
        }

        return wrapper;
    }

    public void setUpdateButton(boolean b) {
        update.setEnabled(b);
        update.setBackground(ColorScheme.BRAND_ORANGE);
        update.setToolTipText("Update");
    }

    public JLabel textPanel(String text) {
        JLabel label = new JLabel();
        label.setText(text);
        label.setForeground(Color.WHITE);
        label.setVerticalAlignment(SwingConstants.CENTER);
        label.setHorizontalAlignment(SwingConstants.CENTER);
        label.setFont(FontManager.getRunescapeSmallFont());

        return label;
    }

    public JLabel textPanel(String text, int borderOptions) {
        JLabel label = new JLabel();
        label.setText(text);
        label.setForeground(Color.WHITE);
        label.setVerticalAlignment(SwingConstants.CENTER);
        label.setHorizontalAlignment(SwingConstants.CENTER);
        label.setFont(FontManager.getRunescapeSmallFont());

        if (borderOptions == 0) {
            label.setBorder(new CompoundBorder(
                    new MatteBorder(0,0,1,1,ColorScheme.LIGHT_GRAY_COLOR.darker()),
                    new EmptyBorder(5,3,5,3)));
        }
        else if (borderOptions == 1) {
            label.setBorder(new MatteBorder(0,0,1,0,ColorScheme.LIGHT_GRAY_COLOR.darker()));
        }
        else if (borderOptions == 2) {
            label.setBorder(new MatteBorder(0,0,0,1,ColorScheme.LIGHT_GRAY_COLOR.darker()));
        }
		else if (borderOptions == 3) {
			label.setBorder(new CompoundBorder(
				new MatteBorder(0,0,0,0,ColorScheme.LIGHT_GRAY_COLOR.darker()),
				new EmptyBorder(5,3,5,3)));
		}  else if (borderOptions == 4) {
			label.setBorder(new MatteBorder(0,0,1,1,ColorScheme.LIGHT_GRAY_COLOR.darker()));
		} else if (borderOptions == 5) {
			label.setBorder(new CompoundBorder(
				new MatteBorder(0, 0, 1, 0, ColorScheme.LIGHT_GRAY_COLOR.darker()),
				new EmptyBorder(5, 3, 5, 3)));
		} else if (borderOptions == 6) {
			label.setBorder(new CompoundBorder(
				new MatteBorder(0,0,0,0,ColorScheme.LIGHT_GRAY_COLOR.darker()),
				new EmptyBorder(5,3,0,3)));
		}  else if (borderOptions == 7) {
			label.setBorder(new CompoundBorder(
				new MatteBorder(0,0,0,1,ColorScheme.LIGHT_GRAY_COLOR.darker()),
				new EmptyBorder(5,3,0,3)));
		} else {
            label.setBorder(new MatteBorder(0,0,0,0,ColorScheme.LIGHT_GRAY_COLOR.darker()));
        }

        return label;
    }

	public JPanel stripedPanel(boolean striped) {
		JPanel panel = new JPanel();
		panel.setLayout(new GridLayout(0, 4));

		if (striped) {
			panel.setBackground(ColorScheme.DARK_GRAY_COLOR);
		} else {
			panel.setBackground(ColorScheme.DARKER_GRAY_COLOR);
		}
		return panel;
	}

    public BufferedImage resizeImage(BufferedImage before, double scale, int af) {
        int w = before.getWidth();
        int h = before.getHeight();
        int w2 = (int) (w * scale);
        int h2 = (int) (h * scale);
        BufferedImage after = new BufferedImage(w2, h2, before.getType());
        AffineTransform scaleInstance = AffineTransform.getScaleInstance(scale, scale);
        AffineTransformOp scaleOp = new AffineTransformOp(scaleInstance, af);
        scaleOp.filter(before, after);

        return after;
    }

    public JButton imageButton(BufferedImage image) {
        JButton b = new JButton();
        b.setIcon(new ImageIcon(image));
        b.setOpaque(false);
        b.setContentAreaFilled(false);
        b.setBorderPainted(false);
        b.setFocusPainted(false);

        return b;
    }

    public void loadRTList() {
        //TODO: support for a custom file so that it can be added to onedrive for example.
        coxRTList = fw.readFromFile(RaidType.COX);
        for (RaidTracker RT : coxRTList) {
            coxUUIDMap.put(RT.getUniqueID(), RT);
        }

        tobRTList = fw.readFromFile(RaidType.TOB);

        for (RaidTracker RT : tobRTList) {
            tobUUIDMap.put(RT.getUniqueID(), RT);
        }

		toaRTList = fw.readFromFile(RaidType.TOA);

		for (RaidTracker RT : toaRTList) {
			toaUUIDMap.put(RT.getUniqueID(), RT);
		}

        loaded = true;
        updateView();
    }

    public ArrayList<RaidTracker> filterRTListByName(String name) {
        if (loaded) {
            return getFilteredRTList().stream().filter(RT -> name.toLowerCase().equals(RT.getSpecialLoot().toLowerCase()))
                    .collect(Collectors.toCollection(ArrayList::new));
        }
        return new ArrayList<>();
    }

    public ArrayList<RaidTracker> filterKitReceivers() {
        if (loaded) {
            return getFilteredRTList().stream().filter(RT -> !RT.getKitReceiver().isEmpty())
                    .collect(Collectors.toCollection(ArrayList::new));
        }
        return new ArrayList<>();
    }

    public ArrayList<RaidTracker> filterDustReceivers() {
        if (loaded) {
            return getFilteredRTList().stream().filter(RT -> !RT.getDustReceiver().isEmpty()).collect(Collectors.toCollection(ArrayList::new));
        }
        return new ArrayList<>();
    }

    public ArrayList<RaidTracker> filterPetReceivers() {
        if (loaded) {
            return getFilteredRTList().stream().filter(RT -> !RT.getPetReceiver().isEmpty()).collect(Collectors.toCollection(ArrayList::new));
        }
        return new ArrayList<>();
    }

    public ArrayList<RaidTracker> filterOwnDrops(ArrayList<RaidTracker> l) {
        if (loaded) {
            return l.stream().filter(RT -> {

                if (RT.getSpecialLoot().isEmpty() || RT.getLootList().size() == 0) {
                    return false;
                }
                return RT.getLootList().get(0).getId() == getByName(RT.getSpecialLoot()).getItemID();
            }).collect(Collectors.toCollection(ArrayList::new));
        }
        return new ArrayList<>();
    }

    public ArrayList<RaidTracker> filterOwnKits(ArrayList<RaidTracker> l) {
        if (loaded) {
            return l.stream().filter(RT -> RT.getLootList().stream()
                    .anyMatch(loot -> loot.getId() == ItemID.TWISTED_ANCESTRAL_COLOUR_KIT))
                    .collect(Collectors.toCollection(ArrayList::new));
        }
        return new ArrayList<>();
    }

    public ArrayList<RaidTracker> filterOwnDusts(ArrayList<RaidTracker> l) {
        if (loaded) {

            return l.stream().filter(RT -> RT.getLootList().stream()
                    .anyMatch(loot -> loot.getId() == ItemID.METAMORPHIC_DUST))
                    .collect(Collectors.toCollection(ArrayList::new));
        }
        return new ArrayList<>();
    }

    public ArrayList<RaidTracker> filterOwnPets(ArrayList<RaidTracker> l) {
        if (loaded) {
            return l.stream().filter(RaidTracker::isPetInMyName).collect(Collectors.toCollection(ArrayList::new));
        }
        return new ArrayList<>();
    }

    public ArrayList<RaidTracker> filterPurples() {
        if (loaded) {
            return getFilteredRTList().stream().filter(RT -> {
                for (RaidUniques unique : getUniquesList()) {
                    if (unique.getName().toLowerCase().equals(RT.getSpecialLoot().toLowerCase())) {
                        return true;
                    }
                }
                return false;
            }).collect(Collectors.toCollection(ArrayList::new));
        }
        return new ArrayList<>();

    }

    public String getUniqueToolTip(RaidUniques unique, int amountSeen, int amountReceived) {

        return "<html>" +
                unique.getName() +  "<br>" +
                "Received: " + amountReceived + "x" + "<br>" +
                "Seen: " + amountSeen + "x";
    }

    public String getRegularToolTip(RaidTrackerItem drop) {
        return "<html>" + drop.getName() + " x " + drop.getQuantity() + "<br>" +
                "Price: " + format(drop.getPrice()) + " gp";
    }

    public void addDrop(RaidTracker RT, boolean update) {
        if (RT.isInRaidChambers()) {
            coxRTList.add(RT);
        } else if (RT.isInTheatreOfBlood()) {
            tobRTList.add(RT);
        } else if (RT.isInTombsOfAmascut()) {
			toaRTList.add(RT);
		} else {
            log.error("New drop detected but no inRaid flags set.");
        }

        if (update) {
            //only add  item to the map when the parent raidtracker is added (child RT's are getting update false)
            if (RT.isInRaidChambers()) {
                coxUUIDMap.put(RT.getUniqueID(), RT);
            } else if (RT.isInTheatreOfBlood()) {
                tobUUIDMap.put(RT.getUniqueID(), RT);
            } else if (RT.isInTombsOfAmascut()) {
				toaUUIDMap.put(RT.getUniqueID(), RT);
			} else {
                log.error("Drop update detected but no inRaid flags set.");
            }
            updateView();
        }
    }

    public void addDrop(RaidTracker RT) {
        addDrop(RT, true);
    }

    public int atLeastZero(int maybeLessThanZero) {
        return Math.max(maybeLessThanZero, 0);
    }

    //yoinked from stackoverflow
    private static final NavigableMap<Long, String> suffixes = new TreeMap<>();
    static {
        suffixes.put(1_000L, "k");
        suffixes.put(1_000_000L, "m");
        suffixes.put(1_000_000_000L, "b");
    }

    public static String format(long value) {
        //Long.MIN_VALUE == -Long.MIN_VALUE so we need an adjustment here
        if (value == Long.MIN_VALUE) return format(Long.MIN_VALUE + 1);
        if (value < 0) return "-" + format(-value);
        if (value < 1000) return Long.toString(value); //deal with easy case

        Map.Entry<Long, String> e = suffixes.floorEntry(value);
        Long divideBy = e.getKey();
        String suffix = e.getValue();

        long truncated = value / (divideBy / 100); //the number part of the output times 100
        boolean hasDecimal = truncated < 1000;
        return hasDecimal ? (truncated / 100d) + suffix : (truncated / 100) + suffix;
    }

    public Future<Map<Integer, RaidTrackerItem>> getDistinctRegularDrops()  {
        CompletableFuture<Map<Integer, RaidTrackerItem>> future = new CompletableFuture<>();

        clientThread.invokeLater(() -> {

            if (loaded) {
                HashSet<Integer> uniqueIDs = new HashSet<>();

                int clues = 0;

                for (RaidTracker RT : getFilteredRTList()) {
                    for (RaidTrackerItem item : RT.getLootList()) {
                        boolean addToSet = true;
                        for (RaidUniques unique : getUniquesList()) {
                            if (item.getId() == unique.getItemID()) {
                                addToSet = false;
                                break;
                            }
                        }
                        if (item.getName().toLowerCase().contains("clue")) {
                            addToSet = false;
                            clues++;
                        }
                        if (addToSet) {
                            uniqueIDs.add(item.id);
                        }
                    }
                }

                Map<Integer, RaidTrackerItem> m = new HashMap<>();

                for (Integer i : uniqueIDs) {
                    ItemComposition IC = itemManager.getItemComposition(i);

                    m.put(i, new RaidTrackerItem() {
                        {
                            name = IC.getName();
                            id = i;
                            quantity = 0;
                            price = itemManager.getItemPrice(i);
                        }
                    });

                }

                if (clues > 0) {
                    int finalClues = clues;
                    m.put(12073, new RaidTrackerItem() {
                        {
                            name = "Clue scroll (elite)";
                            id = 12073;
                            quantity = finalClues;
                            price = itemManager.getItemPrice(12073);
                        }
                    });
                }

                future.complete(m);
                return;
            }

            future.complete(new HashMap<>());

        });
        return future;
    }

    private ArrayList<RaidTracker> getFilteredRTList() {
        ArrayList<RaidTracker> tempRTList;

        if (!loaded) {
            return new ArrayList<>();
        }

		switch(selectedRaidTab) {
            case COX:
                if (cmFilter.equals("CM & Normal")) {
                    tempRTList = coxRTList;
                } else if (cmFilter.equals("CM Only")) {
                    tempRTList = coxRTList.stream().filter(RaidTracker::isChallengeMode)
                        .collect(Collectors.toCollection(ArrayList::new));
                } else {
                    tempRTList = coxRTList.stream().filter(RT -> !RT.isChallengeMode())
                        .collect(Collectors.toCollection(ArrayList::new));
                }
                break;
			case TOB:
				if (mvpFilter.equals("Both")) {
					tempRTList = tobRTList;
				} else if (mvpFilter.equals("My MVP")) {
					tempRTList = tobRTList.stream().filter(RaidTracker::isMvpInOwnName)
						.collect(Collectors.toCollection(ArrayList::new));
				} else {
					tempRTList = tobRTList.stream().filter(RT -> !RT.isMvpInOwnName())
						.collect(Collectors.toCollection(ArrayList::new));
				}
				break;
			case TOA:
				tempRTList = toaRTList.stream().filter(RT -> RT.getRaidLevel() >= raidLevelFilterLow && RT.getRaidLevel() <= raidLevelFilterHigh)
					.collect(Collectors.toCollection(ArrayList::new));
				break;
			default:
                tempRTList = new ArrayList<>();
                break;
		}

        switch (teamSizeFilter) {
            case "Solo":
                tempRTList = tempRTList.stream().filter(RT -> (RT.getTeamSize() == 1))
                        .collect(Collectors.toCollection(ArrayList::new));
                break;
            case "Duo":
                tempRTList = tempRTList.stream().filter(RT -> (RT.getTeamSize() == 2))
                        .collect(Collectors.toCollection(ArrayList::new));
                break;
            case "Trio":
                tempRTList = tempRTList.stream().filter(RT -> (RT.getTeamSize() == 3))
                        .collect(Collectors.toCollection(ArrayList::new));
                break;
            case "4-man":
                tempRTList = tempRTList.stream().filter(RT -> (RT.getTeamSize() == 4))
                        .collect(Collectors.toCollection(ArrayList::new));
                break;
            case "5-man":
                tempRTList = tempRTList.stream().filter(RT -> (RT.getTeamSize() == 5))
                        .collect(Collectors.toCollection(ArrayList::new));
                break;
            case "6-man":
                tempRTList = tempRTList.stream().filter(RT -> (RT.getTeamSize() == 6))
                        .collect(Collectors.toCollection(ArrayList::new));
                break;
            case "7-man":
                tempRTList = tempRTList.stream().filter(RT -> (RT.getTeamSize() == 7))
                        .collect(Collectors.toCollection(ArrayList::new));
                break;
			case "8-man":
				tempRTList = tempRTList.stream().filter(RT -> (RT.getTeamSize() == 8))
					.collect(Collectors.toCollection(ArrayList::new));
				break;
            case "8-10 Players":
                tempRTList = tempRTList.stream().filter(RT -> (RT.getTeamSize() >= 8 && RT.getTeamSize() <= 10))
                        .collect(Collectors.toCollection(ArrayList::new));
                break;
            case "11-14 Players":
                tempRTList = tempRTList.stream().filter(RT -> (RT.getTeamSize() >= 11 && RT.getTeamSize() <= 14))
                        .collect(Collectors.toCollection(ArrayList::new));
                break;
            case "15-24 Players":
				tempRTList = tempRTList.stream().filter(RT -> (RT.getTeamSize() >= 15 && RT.getTeamSize() <= 24))
					.collect(Collectors.toCollection(ArrayList::new));
			case "24+ Players":
                tempRTList = tempRTList.stream().filter(RT -> (RT.getTeamSize() >= 25))
                        .collect(Collectors.toCollection(ArrayList::new));
                break;
            default:
                //all sizes

        }

        //if people want to crash my plugin using a system year of before 1970, that's fine
        long now = System.currentTimeMillis();


        long last12Hours = now - 43200000L;
        long yesterday = now - 86400000L;
        long last3Days = now - 259200000L;
        long lastWeek = now - 604800000L;
        long lastMonth = now - 2629746000L;
        long last3Months = now - 7889400000L;
        long lastYear = now - 31536000000L;

        switch (dateFilter) {
            case "All Time":
                return tempRTList;
			case "12 Hours":
				return tempRTList.stream().filter(RT -> RT.getDate() > last12Hours)
					.collect(Collectors.toCollection(ArrayList::new));
            case "Today":
                return tempRTList.stream().filter(RT -> RT.getDate() > yesterday)
                        .collect(Collectors.toCollection(ArrayList::new));
			case "3 Days":
				return tempRTList.stream().filter(RT -> RT.getDate() > last3Days)
					.collect(Collectors.toCollection(ArrayList::new));
            case "Week":
                return tempRTList.stream().filter(RT -> RT.getDate() > lastWeek)
                        .collect(Collectors.toCollection(ArrayList::new));
            case "Month":
                return tempRTList.stream().filter(RT -> RT.getDate() > lastMonth)
                        .collect(Collectors.toCollection(ArrayList::new));
			case "3 Months":
				return tempRTList.stream().filter(RT -> RT.getDate() > last3Months)
					.collect(Collectors.toCollection(ArrayList::new));
            case "Year":
                return tempRTList.stream().filter(RT -> RT.getDate() > lastYear)
                        .collect(Collectors.toCollection(ArrayList::new));
            case "X Kills":
                ArrayList<RaidTracker> tempUniqueKills = getDistinctKills(tempRTList);
                ArrayList<RaidTracker> uniqueKills = new ArrayList<>(tempUniqueKills.subList(Math.max(tempUniqueKills.size() - config.lastXKills(), 0), tempUniqueKills.size()));

                return tempRTList.stream().filter(RT -> uniqueKills.stream()
                        .anyMatch(temp -> RT.getKillCountID().equals(temp.getKillCountID())))
                        .collect(Collectors.toCollection(ArrayList::new));
        }

        return tempRTList;
    }

    public EnumSet<RaidUniques> getUniquesList() {
		switch(selectedRaidTab) {
            case COX:
                return coxUniques;
			case TOB:
				return tobUniques;
			case TOA:
				return toaUniques;
			default:
                return null;
		}
	}

    public RaidUniques getByName(String name) {
        EnumSet<RaidUniques> uniquesList = getUniquesList();
        for (RaidUniques unique: uniquesList) {
            if (unique.getName().toLowerCase().equals(name.toLowerCase())) {
                return unique;
            }
        }
        //should never reach this
        return RaidUniques.OLMLET;
    }

    public ArrayList<RaidTracker> getDistinctKills(ArrayList<RaidTracker> tempRTList) {
        HashMap<String, RaidTracker> tempUUIDMap = new LinkedHashMap<>();

        for (RaidTracker RT : tempRTList) {
            tempUUIDMap.put(RT.getKillCountID(), RT);
        }

        return new ArrayList<>(tempUUIDMap.values());
    }

    private void clearData()
    {
        // Confirm delete action
        final int delete = JOptionPane.showConfirmDialog(this.getRootPane(), "<html>Are you sure you want to clear all data for this tab?<br/>There is no way to undo this action.</html>", "Warning", JOptionPane.YES_NO_OPTION);
        if (delete == JOptionPane.YES_OPTION)
        {
            if (!fw.delete(selectedRaidTab))
            {
                JOptionPane.showMessageDialog(this.getRootPane(), "Unable to clear stored data, please try again.");
                return;
            }

            loadRTList();
        }
    }

    private String secondsToMinuteString(int seconds) {
        if (seconds < 0) {
            return "No time";
        }
        return seconds / 60 + ":" + (seconds % 60 < 10 ? "0" : "") + seconds % 60;
    }

}


package com.raidtracker.ui;

import com.raidtracker.RaidTracker;
import lombok.Getter;
import net.runelite.client.game.ItemManager;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.util.AsyncBufferedImage;

import javax.swing.BorderFactory;
import javax.swing.Box;
import javax.swing.BoxLayout;
import javax.swing.ImageIcon;
import javax.swing.JCheckBox;
import javax.swing.JFormattedTextField;
import javax.swing.JLabel;
import javax.swing.JPanel;
import javax.swing.JSpinner;
import javax.swing.JTextField;
import javax.swing.SpinnerNumberModel;
import javax.swing.SwingConstants;
import javax.swing.border.EmptyBorder;
import javax.swing.event.DocumentEvent;
import javax.swing.event.DocumentListener;
import java.awt.Component;
import java.awt.Dimension;
import java.awt.GridLayout;
import java.awt.image.AffineTransformOp;
import java.awt.image.BufferedImage;
import java.text.NumberFormat;
import java.time.Instant;
import java.time.LocalDate;
import java.time.ZoneId;
import java.util.EnumSet;
import java.util.Map;
import java.util.NavigableMap;
import java.util.TreeMap;

public class SplitChanger extends JPanel {

    @Getter
    public final RaidTracker raidTracker;
    private final ItemManager itemManager;
    private final RaidTrackerPanel raidTrackerPanel;
    private boolean locked = false;

    public SplitChanger(final ItemManager itemManager, final RaidTracker raidTracker, final RaidTrackerPanel raidTrackerPanel) {
        this.itemManager = itemManager;
        this.raidTracker = raidTracker;
        this.raidTrackerPanel = raidTrackerPanel;

        this.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        this.setLayout(new BoxLayout(this, BoxLayout.X_AXIS));
        this.setBorder(new EmptyBorder(3,5,5,5));

        this.add(getImagePanel());
        this.add(getVarPanel());
    }

    private JPanel getImagePanel() {
        AsyncBufferedImage image = itemManager.getImage(getByName(raidTracker.getSpecialLoot()).getItemID(), 1, false);

        JPanel iconWrapper = new JPanel();
        iconWrapper.setLayout(new BoxLayout(iconWrapper, BoxLayout.Y_AXIS));
        iconWrapper.setBackground(ColorScheme.DARKER_GRAY_COLOR);

        JLabel icon = new JLabel();
        icon.setIcon(new ImageIcon(resizeImage(image)));
        icon.setVerticalAlignment(SwingConstants.CENTER);
        icon.setHorizontalAlignment(SwingConstants.CENTER);
        icon.setBorder(new EmptyBorder(0,0,0,0));
        icon.setToolTipText(raidTracker.getSpecialLoot());


        image.onLoaded(() ->
        {
            icon.setIcon(new ImageIcon(resizeImage(image)));
            icon.revalidate();
            icon.repaint();
        });

        JLabel date = textPanel(getDateText());
        date.setForeground(ColorScheme.LIGHT_GRAY_COLOR.darker());

        iconWrapper.add(date);
        iconWrapper.add(Box.createRigidArea(new Dimension(0, 10)));
        iconWrapper.add(icon);
        iconWrapper.add(Box.createRigidArea(new Dimension(0, 10)));

        return iconWrapper;
    }

    private JPanel getVarPanel() {
        JPanel panel = new JPanel();
        panel.setLayout(new BoxLayout(panel, BoxLayout.Y_AXIS));
        panel.setBorder(new EmptyBorder(5,5,5,0));
        panel.setBackground(ColorScheme.DARKER_GRAY_COLOR);

        JPanel splitReceivedWrapper = new JPanel();
        splitReceivedWrapper.setLayout(new GridLayout(0,2));
        JLabel splitReceivedLabel = textPanel("Split Amount: ");
        splitReceivedLabel.setHorizontalAlignment(SwingConstants.LEFT);
        splitReceivedWrapper.setBackground(ColorScheme.DARKER_GRAY_COLOR);

        JTextField splitReceived = getTextField();
        splitReceived.setText(format(atLeastZero(raidTracker.getLootSplitReceived())));
        splitReceived.setToolTipText(NumberFormat.getInstance().format(atLeastZero(raidTracker.getLootSplitReceived())));

        splitReceived.getDocument().addDocumentListener((SimpleDocumentListener) e -> {
            if (!locked) {
                int value = parse(splitReceived.getText());

                if (value != raidTracker.getLootSplitReceived() && value != -5) {
                    raidTracker.setLootSplitReceived(value);
                    if (raidTracker.isFreeForAll()) {
                        raidTracker.setSpecialLootValue(value);
                    } else {
                        raidTracker.setSpecialLootValue(value * raidTracker.getTeamSize());
                        setSplit();
                    }

                    splitReceived.setToolTipText(NumberFormat.getInstance().format(atLeastZero(raidTracker.getLootSplitReceived())));

                    variablesChanged();
                }
            }
        });

        splitReceived.addActionListener(e -> {
            //format the number when losing focus
            splitReceived.setText(format(atLeastZero(raidTracker.getLootSplitReceived())));
        });

        splitReceivedWrapper.add(splitReceivedLabel);
        splitReceivedWrapper.add(splitReceived);

        JPanel ffaWrapper = new JPanel();
        ffaWrapper.setLayout(new GridLayout(0, 2));
        ffaWrapper.setBackground(ColorScheme.DARKER_GRAY_COLOR);

        JCheckBox ffa = new JCheckBox("FFA?");
        ffa.setBorder(new EmptyBorder(0,15,0,0));
        ffa.setSelected(raidTracker.isFreeForAll());
        ffa.addActionListener((e) -> {
            raidTracker.setFreeForAll(ffa.isSelected());

            locked = true;

            if (ffa.isSelected()) {
                setFFA();
            }
            else {
                setSplit();
            }
            splitReceived.setText(format(atLeastZero(raidTracker.getLootSplitReceived())));
            splitReceived.setToolTipText(NumberFormat.getInstance().format(atLeastZero(raidTracker.getLootSplitReceived())));

            variablesChanged();

            locked = false;
        });

        JPanel ReceivedWrapper = new JPanel();
        ReceivedWrapper.setLayout(new BoxLayout(ReceivedWrapper, BoxLayout.Y_AXIS));
        ReceivedWrapper.setBackground(ColorScheme.DARKER_GRAY_COLOR);

        JLabel receivedBy = textPanel("received by: ");
        receivedBy.setForeground(ColorScheme.LIGHT_GRAY_COLOR.brighter());

        JLabel receiver = textPanel(fixSpaces(raidTracker.getSpecialLootReceiver()));
        receiver.setForeground(ColorScheme.LIGHT_GRAY_COLOR.brighter());

        ReceivedWrapper.add(receivedBy);
        ReceivedWrapper.add(receiver);

        ffaWrapper.add(ReceivedWrapper);
        ffaWrapper.add(ffa);

        JPanel teamSizeWrapper = new JPanel();
        teamSizeWrapper.setLayout(new GridLayout(0, 2));
        JLabel teamSizeLabel = textPanel("Team Size: ");
        teamSizeLabel.setHorizontalAlignment(SwingConstants.LEFT);
        teamSizeWrapper.setBackground(ColorScheme.DARKER_GRAY_COLOR);

        SpinnerNumberModel model = new SpinnerNumberModel(Math.min(Math.max(1, raidTracker.getTeamSize()), 100), 1, 100, 1);
        JSpinner teamSize = new JSpinner(model);
        teamSize.setBackground(ColorScheme.DARKER_GRAY_COLOR.darker());
        Component editor = teamSize.getEditor();

        JFormattedTextField spinnerTextField = ((JSpinner.DefaultEditor) editor).getTextField();
        spinnerTextField.setColumns(2);
        teamSize.addChangeListener(e -> {
            locked = true;
            raidTracker.setTeamSize(Math.min(Math.max(1, Integer.parseInt(teamSize.getValue().toString())), 100));
            setSplit();
            splitReceived.setText(format(atLeastZero(raidTracker.getLootSplitReceived())));
            splitReceived.setToolTipText(NumberFormat.getInstance().format(atLeastZero(raidTracker.getLootSplitReceived())));

            variablesChanged();

            locked = false;
        });

        teamSizeWrapper.add(teamSizeLabel);
        teamSizeWrapper.add(teamSize);

        panel.add(ffaWrapper);
        panel.add(Box.createRigidArea(new Dimension(0, 3)));
        panel.add(splitReceivedWrapper);
        panel.add(Box.createRigidArea(new Dimension(0, 3)));
        panel.add(teamSizeWrapper);

        return panel;
    }

    private JTextField getTextField()
    {
        JTextField textField = new JTextField();

        textField.setBorder(BorderFactory.createEmptyBorder(5, 5, 5, 5));
        textField.setBackground(ColorScheme.DARKER_GRAY_COLOR.darker());
        textField.setAlignmentX(RIGHT_ALIGNMENT);

        return textField;
    }

    private int atLeastZero(int maybeLessThanZero) {
        return Math.max(maybeLessThanZero, 0);
    }

    private void variablesChanged() {
        raidTrackerPanel.setUpdateButton(true);
    }

    private void setFFA() {
        boolean inOwnName = raidTracker.isSpecialLootInOwnName();

        if (inOwnName) {
            raidTracker.setLootSplitReceived(raidTracker.getSpecialLootValue());
            raidTracker.setLootSplitPaid(-1);
        }
        else {
            raidTracker.setLootSplitPaid(-1);
            raidTracker.setLootSplitReceived(-1);
        }
    }

    private void setSplit() {
        boolean inOwnName = raidTracker.isSpecialLootInOwnName();

        int splitSize = raidTracker.getSpecialLootValue() / raidTracker.getTeamSize();

        if (!raidTracker.isFreeForAll()) {
            if (inOwnName) {
                raidTracker.setLootSplitPaid(splitSize);
            } else {
                raidTracker.setLootSplitPaid(-1);
            }

            raidTracker.setLootSplitReceived(splitSize);
        }
    }

    private JLabel textPanel(String text) {
        return raidTrackerPanel.textPanel(text);
    }

    private BufferedImage resizeImage(BufferedImage before) {
        return raidTrackerPanel.resizeImage(before, 1.75, AffineTransformOp.TYPE_NEAREST_NEIGHBOR);
    }

    private String getDateText() {
        String dateText;

        LocalDate date = Instant.ofEpochMilli(raidTracker.getDate()).atZone(ZoneId.systemDefault()).toLocalDate();
        LocalDate today = LocalDate.now();
        LocalDate yesterday = today.minusDays(1);
        LocalDate lastWeek = today.minusDays(7);
        LocalDate lastMonth = today.minusDays(30);
        LocalDate lastYear = today.minusDays(365);


        if (date.equals(today)) {
            dateText = "today";
        } else if (date.equals(yesterday)) {
            dateText = "yesterday";
        } else if (date.isAfter(lastWeek)) {
            dateText = "last week";
        } else if (date.isAfter(lastMonth)) {
            dateText = "last month";
        } else if (date.isAfter(lastYear)) {
            dateText = "last year"; //todo ???
        } else {
            dateText = "a long time ago";
        }

        return dateText;
    }

    //yoinked from stackoverflow
    private static final NavigableMap<Long, String> suffixes = new TreeMap<> ();
    static {
        suffixes.put(1_000L, "k");
        suffixes.put(1_000_000L, "m");
        suffixes.put(1_000_000_000L, "b");
    }

    public static String format(long value) {
        //Long.MIN_VALUE == -Long.MIN_VALUE so we need an adjustment here
        if (value == Long.MIN_VALUE) return format(Long.MIN_VALUE + 1);
        if (value < 0) return "-" + format(-value);
        if (value < 1000) return Long.toString(value); //deal with easy case

        Map.Entry<Long, String> e = suffixes.floorEntry(value);
        Long divideBy = e.getKey();
        String suffix = e.getValue();

        long truncated = value / (divideBy / 10); //the number part of the output times 10
        boolean hasDecimal = truncated < 1000;
        return hasDecimal ? (truncated / 10d) + suffix : (truncated / 10) + suffix;
    }

    public static int parse (String s) {
        if (s == null || s.length() == 0) {
            return -5;
        }
        char c = s.charAt(s.length() - 1);
        if (Character.isLetter(c)) {
            int multiplier;

            if (c == 'k') {
                multiplier = 1000;
            }
            else if (c == 'm') {
                multiplier = 1000000;
            }
            else if (c == 'b') {
                multiplier = 1000000000;
            }
            else {
                return -5;
            }

            String substr = s.substring(0, s.length() - 1);

            if (isNumeric(substr)) {
                return (int) Math.round(Double.parseDouble(substr) * multiplier);
            }
        }
        else if (isNumeric(s)) {
            return (int) Math.round(Double.parseDouble(s));
        }
        return -5;
    }

    public static boolean isNumeric(String strNum) {
        if (strNum == null) {
            return false;
        }
        try {
            Double.parseDouble(strNum);
        } catch (NumberFormatException nfe) {
            return false;
        }
        return true;
    }

    public String fixSpaces(String s) {
        //replace null characters with spaces
        return unescapeJavaString(s.replace("ï¿½", " ").replace("Â ", " "));
    }

    private RaidUniques getByName(String name) {
        EnumSet<RaidUniques> uniquesList = getUniquesList();
        for (RaidUniques unique: uniquesList) {
            if (unique.getName().equalsIgnoreCase(name)) {
                return unique;
            }
        }
        //should never reach this
        return RaidUniques.OLMLET;
    }

    EnumSet<RaidUniques> getUniquesList() {
		switch (raidTrackerPanel.getSelectedRaidTab()) {
            case COX:
                return raidTrackerPanel.getCoxUniques();
			case TOB:
				return raidTrackerPanel.getTobUniques();
			case TOA:
				return raidTrackerPanel.getToaUniques();
            default:
                return null;
		}
    }

    //from stackoverflow
    public String unescapeJavaString(String st) {

        if (st == null) {
            return null;
        }

        StringBuilder sb = new StringBuilder(st.length());

        for (int i = 0; i < st.length(); i++) {
            char ch = st.charAt(i);
            if (ch == '\\') {
                char nextChar = (i == st.length() - 1) ? '\\' : st
                        .charAt(i + 1);
                // Octal escape?
                if (nextChar >= '0' && nextChar <= '7') {
                    String code = "" + nextChar;
                    i++;
                    if ((i < st.length() - 1) && st.charAt(i + 1) >= '0'
                            && st.charAt(i + 1) <= '7') {
                        code += st.charAt(i + 1);
                        i++;
                        if ((i < st.length() - 1) && st.charAt(i + 1) >= '0'
                                && st.charAt(i + 1) <= '7') {
                            code += st.charAt(i + 1);
                            i++;
                        }
                    }
                    sb.append((char) Integer.parseInt(code, 8));
                    continue;
                }
                switch (nextChar) {
                    case '\\':
                        break;
                    case 'b':
                        ch = '\b';
                        break;
                    case 'f':
                        ch = '\f';
                        break;
                    case 'n':
                        ch = '\n';
                        break;
                    case 'r':
                        ch = '\r';
                        break;
                    case 't':
                        ch = '\t';
                        break;
                    case '\"':
                        ch = '\"';
                        break;
                    case '\'':
                        ch = '\'';
                        break;
                    // Hex Unicode: u????
                    case 'u':
                        if (i >= st.length() - 5) {
                            ch = 'u';
                            break;
                        }
                        int code = Integer.parseInt(
                                "" + st.charAt(i + 2) + st.charAt(i + 3)
                                        + st.charAt(i + 4) + st.charAt(i + 5), 16);
                        sb.append(Character.toChars(code));
                        i += 5;
                        continue;
                }
                i++;
            }
            sb.append(ch);
        }
        return sb.toString();
    }

    //also from stackoverflow
    @FunctionalInterface
    public interface SimpleDocumentListener extends DocumentListener {
        void update(DocumentEvent e);

        @Override
        default void insertUpdate(DocumentEvent e) {
            update(e);
        }
        @Override
        default void removeUpdate(DocumentEvent e) {
            update(e);
        }
        @Override
        default void changedUpdate(DocumentEvent e) {
            update(e);
        }
    }

}

package com.raidtracker;

import lombok.Data;

import java.util.ArrayList;
import java.util.UUID;

@Data
public class RaidTracker {

    boolean chestOpened = false;
    boolean raidComplete = false;
    boolean loggedIn = false;
    boolean challengeMode = false;
    boolean inRaidChambers = false;
    boolean inTheatreOfBlood = false;
	// I'd prefer a single k:v pair with a RaidType enum, leaving as separate bools to simplify backwards compatability
	boolean inTombsOfAmascut = false;
    boolean FreeForAll = false;

    int upperTime = -1;
    int middleTime = -1;
    int lowerTime = -1;
    int raidTime = -1;

    int shamansTime = -1;
    int vasaTime = -1;
    int vanguardsTime = -1;
    int mysticsTime = -1;
    int tektonTime = -1;
    int muttadilesTime = -1;
    int guardiansTime = -1;
    int vespulaTime = -1;
    int iceDemonTime = -1;
    int thievingTime = -1;
    int tightropeTime = -1;
    int crabsTime = -1;

	int raidLevel = -1;
    int totalPoints = -1;
    int personalPoints = -1;
	int personalDeathCount = 0;
	int totalTeamDeathCount = 0;
    int teamSize = -1;
    double percentage = -1.0;
    int completionCount = -1;
    String specialLoot = "";
    String specialLootReceiver = "";
    boolean specialLootInOwnName = false;
    int specialLootValue = -1;
    String kitReceiver = "";
    String dustReceiver = "";
    String petReceiver = "";
    boolean petInMyName = false;
    int lootSplitReceived = -1;
    int lootSplitPaid = -1;
    ArrayList<RaidTrackerItem> lootList = new ArrayList<>();

    int maidenTime = -1;
    int bloatTime = -1;
    int nyloTime = -1;
    int sotetsegTime = -1;
    int xarpusTime = -1;
    int verzikTime = -1;

    String mvp= "";
    boolean mvpInOwnName = false;
    String tobPlayer1 = "";
    String tobPlayer2 = "";
    String tobPlayer3 = "";
    String tobPlayer4 = "";
    String tobPlayer5 = "";

    int tobPlayer1DeathCount = 0;
    int tobPlayer2DeathCount = 0;
    int tobPlayer3DeathCount = 0;
    int tobPlayer4DeathCount = 0;
    int tobPlayer5DeathCount = 0;

	int apmekenTime = -1;
	int babaTime = -1;
	int scabarasTime = -1;
	int kephriTime = -1;
	int hetTime = -1;
	int akkhaTime = -1;
	int crondisTime = -1;
	int zebakTime = -1;
	int wardensTime = -1;
	int toaCompTime = -1;

    //Every RaidTracker has a unique uniqueID but not necessarily a unique killCountID, if there are multiple drops.
    String uniqueID = UUID.randomUUID().toString();
    String killCountID = UUID.randomUUID().toString();
    long date = System.currentTimeMillis();
}

package com.raidtracker;

import com.google.inject.Guice;
import com.google.inject.Inject;
import com.raidtracker.filereadwriter.FileReadWriter;
import com.raidtracker.ui.RaidTrackerPanel;
import junit.framework.TestCase;
import net.runelite.api.ChatMessageType;
import net.runelite.api.Client;
import net.runelite.api.Item;
import net.runelite.api.ItemComposition;
import net.runelite.api.Player;
import net.runelite.api.events.ChatMessage;
import net.runelite.client.game.ItemManager;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.plugins.PluginManager;
import net.runelite.client.ui.ClientToolbar;
import net.runelite.http.api.item.ItemPrice;
import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.mockito.Mock;
import org.mockito.junit.MockitoJUnitRunner;
import com.google.inject.testing.fieldbinder.Bind;
import com.google.inject.testing.fieldbinder.BoundFieldModule;

import java.util.ArrayList;
import java.util.List;

import static org.mockito.ArgumentMatchers.anyInt;
import static org.mockito.ArgumentMatchers.anyString;
import static org.mockito.Mockito.mock;
import static org.mockito.Mockito.when;

@RunWith(MockitoJUnitRunner.class)
public class RaidTrackerTest extends TestCase
{

    @Mock
    @Bind
    private Client client;

    @Mock
    @Bind
    private ConfigManager configManager;

    @Mock
    @Bind
    private ItemManager itemManager;

    @Mock
    @Bind
    private ClientToolbar clientToolbar;

    @Mock
    @Bind
    private RaidTrackerConfig raidTrackerConfig;

    @Mock
    @Bind
    private PluginManager pluginManager;

    @Inject
    private RaidTrackerPlugin raidTrackerPlugin;

    @Before
    public void setUp() {
        Guice.createInjector(BoundFieldModule.of(this)).injectMembers(this);
    }

	@Test
	public void TestLootSplits() {
		//TODO: double purples
		RaidTracker raidTracker = new RaidTracker();
		raidTracker.setInRaidChambers(true);
		raidTracker.setRaidComplete(true);

		List<ItemPrice> kodaiTestList = new ArrayList<>();

		ItemPrice kodaiTest = new ItemPrice();

		kodaiTest.setId(0);
		kodaiTest.setName("Kodai Insignia");
		kodaiTest.setPrice(50505050);

		kodaiTestList.add(kodaiTest);

		Player player = mock(Player.class);

		RaidTrackerPanel panel = mock(RaidTrackerPanel.class);
		raidTrackerPlugin.setPanel(panel);

		FileReadWriter fw = mock(FileReadWriter.class);
		raidTrackerPlugin.setFw(fw);

		when(itemManager.search(anyString())).thenReturn(kodaiTestList);
		when(client.getLocalPlayer()).thenReturn(player);
		when(player.getName()).thenReturn("Canvasba");
		when(raidTrackerConfig.FFACutoff()).thenReturn(1000000);

		raidTracker.setTeamSize(3);

        ChatMessage message = new ChatMessage(
            null,
            ChatMessageType.FRIENDSCHATNOTIFICATION,
            "",
            "K1NG DK - Kodai insignia",
            "",
            0);
        raidTrackerPlugin.checkChatMessage(message, raidTracker);


		raidTrackerPlugin.setSplits(raidTracker);

		assertTrue(raidTracker.getLootSplitReceived() > -1);
		assertEquals(-1, raidTracker.lootSplitPaid);


		raidTracker.setSpecialLootReceiver("Canvasba");
		raidTracker.setSpecialLootInOwnName(true);
		raidTrackerPlugin.setSplits(raidTracker);

		assertTrue(raidTracker.getLootSplitReceived() > -1);
		assertTrue(raidTracker.getLootSplitPaid() > -1);

		assertFalse(raidTracker.isFreeForAll());

		//check ffa for below 1m split
		raidTracker.setSpecialLootValue(2000000);
		raidTracker.setLootSplitPaid(-1);
		raidTrackerPlugin.setSplits(raidTracker);

		assertTrue(raidTracker.isFreeForAll());
		assertEquals(2000000, raidTracker.getLootSplitReceived());
		assertEquals(-1, raidTracker.getLootSplitPaid());

		raidTracker.setSpecialLootReceiver("K1NG DK");
		raidTracker.setSpecialLootInOwnName(false);

		raidTracker.setLootSplitReceived(-1);
		raidTrackerPlugin.setSplits(raidTracker);

		assertEquals(-1, raidTracker.getLootSplitReceived());
	}

	//---------------------------------- onChatMessage tests ------------------------------------------------
	@Test
	public void TestRaidComplete()
	{
		RaidTracker raidTracker = new RaidTracker();

		when(client.getVarbitValue(anyInt())).thenReturn(5); //random integer, I chose 5
		raidTracker.setInRaidChambers(true);

        ChatMessage message = new ChatMessage(
            null,
            ChatMessageType.FRIENDSCHATNOTIFICATION,
            "",
            "Congratulations - your raid is complete! Team size: 15 Players Duration: 50:26 Personal best: 31:12",
            "",
            0);
        raidTrackerPlugin.checkChatMessage(message, raidTracker);

		assertTrue(raidTracker.isRaidComplete());
	}

	@Test
	public void TestCoxDuration()
	{
		RaidTracker raidTracker = new RaidTracker();
		raidTracker.setInRaidChambers(true);
		raidTracker.setRaidComplete(true);

        ChatMessage message = new ChatMessage(
            null,
            ChatMessageType.FRIENDSCHATNOTIFICATION,
            "",
            "Congratulations - your raid is complete! Team size: Solo Duration: 1:40:26 Personal best: 31:12",
            "",
            0);
        raidTrackerPlugin.checkChatMessage(message, raidTracker);

		assertEquals(6026, raidTracker.getRaidTime());

		message.setMessage("Congratulations - your raid is complete! Team size: 11-15 Players Duration: 50:26.6 Personal best: 31:12");
		raidTrackerPlugin.checkChatMessage(message, raidTracker);

		assertEquals(3027, raidTracker.getRaidTime());

		//dey0 case
		message.setMessage("Middle level complete! Duration: 7:53 Total: 20:50");
		raidTrackerPlugin.checkChatMessage(message, raidTracker);

		assertEquals(1250, raidTracker.getMiddleTime());

		//regular case
		message.setMessage("Middle level complete! Duration: 20:50");
		raidTrackerPlugin.checkChatMessage(message, raidTracker);

		assertEquals(1250, raidTracker.getMiddleTime());

		message.setMessage("Combat room 'Vanguards' complete! Duration: 3:19 Total: 16:16");
		raidTrackerPlugin.checkChatMessage(message, raidTracker);

		assertEquals(199, raidTracker.getVanguardsTime());


	}

	@Test
	public void TestToaDuration()
	{
		RaidTracker raidTracker = new RaidTracker();
		raidTracker.setInTombsOfAmascut(true);
		raidTracker.setRaidComplete(true);

        ChatMessage message = new ChatMessage(
            null,
            ChatMessageType.FRIENDSCHATNOTIFICATION,
            "",
            "Challenge complete: Path of Crondis. Duration: 0:34.20. Total: 0:34.20",
            "",
            0);
        raidTrackerPlugin.checkChatMessage(message, raidTracker);

		assertEquals(34, raidTracker.getCrondisTime());

        message = new ChatMessage(
            null,
            ChatMessageType.FRIENDSCHATNOTIFICATION,
            "",
            "Challenge complete: The Wardens. Duration: 10:15.60Tombs of Amascut: Expert Mode challenge completion time: 34:07.20. Personal best: 28:16.20",
            "",
            0);
        raidTrackerPlugin.checkChatMessage(message, raidTracker);

		assertEquals(616, raidTracker.getWardensTime());
		assertEquals(2047, raidTracker.getToaCompTime());

        message = new ChatMessage(
            null,
            ChatMessageType.FRIENDSCHATNOTIFICATION,
            "",
            "Tombs of Amascut: Expert Mode total completion time: 36:51.00. Personal best: 30:57.00",
            "",
            0);
        raidTrackerPlugin.checkChatMessage(message, raidTracker);

		assertEquals(2211, raidTracker.getRaidTime());

	}

	@Test
	public void TestPurple()
	{
		RaidTracker raidTracker = new RaidTracker();
		raidTracker.setInRaidChambers(true);
		raidTracker.setRaidComplete(true);

		List<ItemPrice> kodaiTestList = new ArrayList<>();

		ItemPrice kodaiTest = new ItemPrice();

		kodaiTest.setId(0);
		kodaiTest.setName("Kodai Insignia");
		kodaiTest.setPrice(505050);

		kodaiTestList.add(kodaiTest);

		when(itemManager.search(anyString())).thenReturn(kodaiTestList);

        ChatMessage message = new ChatMessage(
            null,
            ChatMessageType.FRIENDSCHATNOTIFICATION,
            "",
            "K1NG DK - Kodai insignia",
            "",
            0);
        raidTrackerPlugin.checkChatMessage(message, raidTracker);

		assertEquals("K1NG DK", raidTracker.getSpecialLootReceiver());
		assertEquals("Kodai insignia", raidTracker.getSpecialLoot());
		assertEquals(505050, raidTracker.getSpecialLootValue());
	}

	@Test
	public void TestTobPurple()
	{
		RaidTracker raidTracker = new RaidTracker();
		raidTracker.setRaidComplete(true);
		raidTracker.setInTheatreOfBlood(true);

		List<ItemPrice> avernicTestList = new ArrayList<>();

		ItemPrice avernicTest = new ItemPrice();

		avernicTest.setId(0);
		avernicTest.setName("Avernic defender hilt");
		avernicTest.setPrice(50505050);

		avernicTestList.add(avernicTest);

		when(itemManager.search(anyString())).thenReturn(avernicTestList);

        ChatMessage message = new ChatMessage(
            null,
            ChatMessageType.FRIENDSCHATNOTIFICATION,
            "",
            "Canvasba found something special: Avernic defender hilt",
            "",
            0);
        raidTrackerPlugin.checkChatMessage(message, raidTracker);

        message = new ChatMessage(
            null,
            ChatMessageType.FRIENDSCHATNOTIFICATION,
            "",
            "Canvasba found something special: Lil\\u0027 Zik",
            "",
            0);
        raidTrackerPlugin.checkChatMessage(message, raidTracker);

		assertEquals("Canvasba", raidTracker.getSpecialLootReceiver());
		assertEquals("Avernic defender hilt", raidTracker.getSpecialLoot());
		assertFalse(raidTracker.petReceiver.isEmpty());
		assertEquals("Canvasba", raidTracker.getPetReceiver());
		assertEquals(50505050, raidTracker.getSpecialLootValue());
	}

	@Test
	public void TestToaPurple()
	{
		RaidTracker raidTracker = new RaidTracker();
		raidTracker.setRaidComplete(true);
		raidTracker.setInTombsOfAmascut(true);

		List<ItemPrice> lightbearerTestList = new ArrayList<>();

		ItemPrice lightbearerTest = new ItemPrice();

		lightbearerTest.setId(0);
		lightbearerTest.setName("Lightbearer");
		lightbearerTest.setPrice(50505050);

		lightbearerTestList.add(lightbearerTest);

		when(itemManager.search(anyString())).thenReturn(lightbearerTestList);

        ChatMessage message = new ChatMessage(
            null,
            ChatMessageType.FRIENDSCHATNOTIFICATION,
            "",
            "Canvasba found something special: Lightbearer",
            "",
            0);
        raidTrackerPlugin.checkChatMessage(message, raidTracker);

        message = new ChatMessage(
            null,
            ChatMessageType.FRIENDSCHATNOTIFICATION,
            "",
            "Canvasba found something special: Tumeken\\u0027s guardian",
            "",
            0);
        raidTrackerPlugin.checkChatMessage(message, raidTracker);

		assertEquals("Canvasba", raidTracker.getSpecialLootReceiver());
		assertEquals("Lightbearer", raidTracker.getSpecialLoot());
		assertFalse(raidTracker.petReceiver.isEmpty());
		assertEquals(50505050, raidTracker.getSpecialLootValue());
	}

	@Test
	public void TestDustAndKitRecipients()
	{
		RaidTracker raidTracker = new RaidTracker();
		raidTracker.setInRaidChambers(true);
		raidTracker.setRaidComplete(true);

        ChatMessage message = new ChatMessage(
            null,
            ChatMessageType.FRIENDSCHATNOTIFICATION,
            "",
            "Dust recipients: Canvasba",
            "",
            0);
        raidTrackerPlugin.checkChatMessage(message, raidTracker);

		message.setMessage("Twisted Kit recipients: BallerTom");
		raidTrackerPlugin.checkChatMessage(message, raidTracker);

		assertEquals("Canvasba", raidTracker.getDustReceiver());
		assertEquals("BallerTom", raidTracker.getKitReceiver());
	}

	@Test
	public void TestChallengeModeAndCompletionCount()
	{
		RaidTracker raidTracker = new RaidTracker();
		raidTracker.setInRaidChambers(true);
		raidTracker.setRaidComplete(true);

        ChatMessage message = new ChatMessage(
            null,
            ChatMessageType.GAMEMESSAGE,
            "",
            "Your completed Chambers of Xeric Challenge Mode count is: 57.",
            "",
            0);
        raidTrackerPlugin.checkChatMessage(message, raidTracker);

		assertTrue(raidTracker.isChallengeMode());
		assertEquals(57, raidTracker.getCompletionCount());

		message.setMessage("Your completed Chambers of Xeric count is: 443");
		raidTrackerPlugin.checkChatMessage(message, raidTracker);

		assertEquals(443, raidTracker.getCompletionCount());
	}


	//---------------------------------- onWidgetLoaded tests ------------------------------------------------


	@Test
	public void TestLootListFactory()
	{
		RaidTracker raidTracker = new RaidTracker();
		raidTracker.setInRaidChambers(true);
		raidTracker.setRaidComplete(true);


		//------------------- general case - 2 stacks of regular items --------------------------
		Item[] items = new Item[2];

		items[0] = new Item(1, 500);
		items[1] = new Item(2, 600);

		ItemComposition comp1 = mock(ItemComposition.class);
		ItemComposition comp2 = mock(ItemComposition.class);

		when(itemManager.getItemComposition(1)).thenReturn(comp1);
		when(itemManager.getItemComposition(2)).thenReturn(comp2);

		when(comp1.getName()).thenReturn("Pure Essence");
		when(comp1.getId()).thenReturn(1);
		when(comp1.getPrice()).thenReturn(5);

		when(comp2.getName()).thenReturn("Teak Planks");
		when(comp2.getId()).thenReturn(2);
		when(comp2.getPrice()).thenReturn(255);

		ArrayList<RaidTrackerItem> lootList = raidTrackerPlugin.lootListFactory(items);

		assertEquals(2, lootList.size());
		assertEquals(2500, lootList.get(0).getPrice());
		assertEquals(153000, lootList.get(1).getPrice());

		//----------------------------------------- purple ----------------------------------------
		items = new Item[1];
		items[0] = new Item(3, 1);

		ItemComposition comp3 = mock(ItemComposition.class);
		when(itemManager.getItemComposition(3)).thenReturn(comp3);

		when(comp3.getName()).thenReturn("Twisted Bow");
		when(comp3.getId()).thenReturn(3);
		when(comp3.getPrice()).thenReturn(1198653000);

		lootList = raidTrackerPlugin.lootListFactory(items);

		assertEquals(1, lootList.size());
		assertEquals(1198653000, lootList.get(0).getPrice());


	}

}
package com.raidtracker;

import com.google.inject.Guice;
import com.google.inject.Inject;
import com.google.inject.testing.fieldbinder.Bind;
import com.google.inject.testing.fieldbinder.BoundFieldModule;
import com.raidtracker.filereadwriter.FileReadWriter;
import com.raidtracker.ui.RaidTrackerPanel;
import com.raidtracker.ui.RaidUniques;
import junit.framework.TestCase;
import net.runelite.api.Client;
import net.runelite.client.game.ItemManager;
import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.mockito.Mock;
import org.mockito.junit.MockitoJUnitRunner;

import java.util.ArrayList;
import java.util.EnumSet;
import java.util.concurrent.ExecutionException;

import static org.mockito.Answers.CALLS_REAL_METHODS;
import static org.mockito.Mockito.mock;
import static org.mockito.Mockito.when;

@RunWith(MockitoJUnitRunner.class)
public class TestRaidTrackerPanel extends TestCase
{
    @Mock
    @Bind
    private Client client;

    @Inject
    private FileReadWriter fw;

    @Before
    public void setUp()
    {
        Guice.createInjector(BoundFieldModule.of(this)).injectMembers(this);
    }

    @Test
    public void TestFilter() throws ExecutionException, InterruptedException {
        fw.updateUsername("Canvasba");

        ArrayList<RaidTracker> l = fw.readFromFile();

        assertEquals(9, l.size());
        assertEquals("Adamantite ore", l.get(0).getLootList().get(0).getName());

        RaidTrackerPanel panel = mock(RaidTrackerPanel.class, CALLS_REAL_METHODS);
        panel.setLoaded(true);
        panel.setCoxRTList(l);
        panel.setCmFilter("CM & Normal");
        panel.setDateFilter("All Time");
        panel.setMvpFilter("Both");
        panel.setTeamSizeFilter("All sizes");
		panel.setSelectedRaidTab(RaidType.COX);

        when(panel.getUniquesList()).thenReturn(EnumSet.of(
                RaidUniques.DEX,
                RaidUniques.ARCANE,
                RaidUniques.TWISTED_BUCKLER,
                RaidUniques.DHCB,
                RaidUniques.DINNY_B,
                RaidUniques.ANCESTRAL_HAT,
                RaidUniques.ANCESTRAL_TOP,
                RaidUniques.ANCESTRAL_BOTTOM,
                RaidUniques.DRAGON_CLAWS,
                RaidUniques.ELDER_MAUL,
                RaidUniques.KODAI,
                RaidUniques.TWISTED_BOW,
                RaidUniques.DUST,
                RaidUniques.TWISTED_KIT,
                RaidUniques.OLMLET
        ));

        ItemManager IM = mock(ItemManager.class);

        panel.setItemManager(IM);

        ArrayList<RaidTracker> arcanes = panel.filterRTListByName("Arcane Prayer Scroll");
        ArrayList<RaidTracker> dexes = panel.filterRTListByName("Dexterous Prayer Scroll");
        ArrayList<RaidTracker> dusts = panel.filterDustReceivers();
        ArrayList<RaidTracker> kits = panel.filterKitReceivers();
        ArrayList<RaidTracker> pets = panel.filterPetReceivers();
        ArrayList<RaidTracker> ownArcanes = panel.filterOwnDrops(arcanes);
        ArrayList<RaidTracker> ownDexes = panel.filterOwnDrops(dexes);
        ArrayList<RaidTracker> ownDusts = panel.filterOwnDusts(dusts);
        ArrayList<RaidTracker> ownKits = panel.filterOwnKits(kits);
        ArrayList<RaidTracker> ownPets = panel.filterOwnPets(pets);


        assertEquals(2, arcanes.size());
        assertEquals(1, ownArcanes.size());
        assertEquals(1, dexes.size());
        assertEquals(0, ownDexes.size());
        assertEquals(2, dusts.size());
        assertEquals(1, ownDusts.size());
        assertEquals(4, kits.size());
        assertEquals(2, ownKits.size());
        assertEquals(4, pets.size());
        assertEquals(2, ownPets.size());

        assertEquals(4, panel.getDistinctKills(l).size());

    }
}

package com.raidtracker;

import net.runelite.client.RuneLite;
import net.runelite.client.externalplugins.ExternalPluginManager;

public class RunClientAndPlugin {
    public static void main(String[] args) throws Exception
    {
        ExternalPluginManager.loadBuiltin(RaidTrackerPlugin.class);
        RuneLite.main(args);
    }
}

