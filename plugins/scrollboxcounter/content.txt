package com.scrollboxinfo;

import com.scrollboxinfo.data.ClueCountStorage;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.*;
import net.runelite.client.game.ItemManager;

import javax.inject.Inject;

@Slf4j
public class ClueCounter
{
    private final Client client;
    private final ClueCountStorage storage;
    private final ItemManager itemManager;

    @Inject
    public ClueCounter(Client client, ClueCountStorage storage, ItemManager itemManager)
    {
        this.client = client;
        this.storage = storage;
        this.itemManager = itemManager;
    }

    public int getClueCounts(ClueTier tier)
    {
        return storage.getCount(tier);
    }

    public ClueCounts getClueCounts(ClueTier tier, ItemContainer container)
    {
        int scrollBoxCount = 0;
        boolean hasClueScroll = false;
        boolean hasChallengeScroll = false;

        if (container != null)
        {
            for (Item item : container.getItems())
            {
                if (item == null || item.getId() <= 0)
                    continue;

                ClueTier itemTier = ClueUtils.getClueTier(client, item.getId());
                if (itemTier != tier)
                    continue;

                ItemComposition itemDef = client.getItemDefinition(item.getId());
                if (itemDef == null)
                    continue;

                String name = itemDef.getName().toLowerCase();

                if (name.startsWith("scroll box ("))
                {
                    scrollBoxCount += item.getQuantity();
                }
                else if (name.startsWith("clue scroll ("))
                {
                    hasClueScroll = true;
                }
                else if (name.startsWith("challenge scroll ("))
                {
                    hasChallengeScroll = true;
                }
            }
        }

        return new ClueCounts(scrollBoxCount, hasClueScroll, hasChallengeScroll);
    }
}
package com.scrollboxinfo;

import net.runelite.api.Client;
import net.runelite.api.ItemComposition;
import net.runelite.api.ItemID;

import javax.inject.Inject;

public class ClueUtils
{
    @Inject
    private ScrollBoxInfoConfig config;

    public static ClueTier getClueTier(Client client, int itemId)
    {
        switch (itemId)
        {
            case ItemID.SCROLL_BOX_BEGINNER:
            case ItemID.CLUE_SCROLL_BEGINNER:
                return ClueTier.BEGINNER;

            case ItemID.SCROLL_BOX_EASY:
            case ItemID.CLUE_SCROLL_EASY:
                return ClueTier.EASY;

            case ItemID.SCROLL_BOX_MEDIUM:
            case ItemID.CLUE_SCROLL_MEDIUM:
                return ClueTier.MEDIUM;

            case ItemID.SCROLL_BOX_HARD:
            case ItemID.CLUE_SCROLL_HARD:
                return ClueTier.HARD;

            case ItemID.SCROLL_BOX_ELITE:
            case ItemID.CLUE_SCROLL_ELITE:
                return ClueTier.ELITE;

            case ItemID.SCROLL_BOX_MASTER:
            case ItemID.CLUE_SCROLL_MASTER:
                return ClueTier.MASTER;

            default:
                ItemComposition item = client.getItemDefinition(itemId);
                if (item == null)
                {
                    return null;
                }

                String name = item.getName().toLowerCase();

                if (name.startsWith("clue scroll (beginner)"))
                {
                    return ClueTier.BEGINNER;
                }
                else if (name.startsWith("clue scroll (easy)"))
                {
                    return ClueTier.EASY;
                }
                else if (name.startsWith("clue scroll (medium)"))
                {
                    return ClueTier.MEDIUM;
                }
                else if (name.startsWith("clue scroll (hard)"))
                {
                    return ClueTier.HARD;
                }
                else if (name.startsWith("clue scroll (elite)"))
                {
                    return ClueTier.ELITE;
                }
                else if (name.startsWith("clue scroll (master)"))
                {
                    return ClueTier.MASTER;
                }
                else if (name.startsWith("challenge scroll (medium)"))
                {
                    return ClueTier.MEDIUM;
                }
                else if (name.startsWith("challenge scroll (hard)"))
                {
                    return ClueTier.HARD;
                }
                else if (name.startsWith("challenge scroll (elite)"))
                {
                    return ClueTier.ELITE;
                }
                else
                {
                    return null;
                }
        }
    }

    public int getClueItemId(ClueTier tier) {
        switch (tier) {
            case BEGINNER:
                return ItemID.SCROLL_BOX_BEGINNER;
            case EASY:
                return ItemID.SCROLL_BOX_EASY;
            case MEDIUM:
                return ItemID.SCROLL_BOX_MEDIUM;
            case HARD:
                return ItemID.SCROLL_BOX_HARD;
            case ELITE:
                return ItemID.SCROLL_BOX_ELITE;
            case MASTER:
                return ItemID.SCROLL_BOX_MASTER;
            default:
                throw new IllegalStateException("Unexpected value: " + this);
        }
    }

    public static String formatTierName(ClueTier tier) {
        String name = tier.name().toLowerCase();
        return Character.toUpperCase(name.charAt(0)) + name.substring(1);
    }

    public String getFormattedTierName(ClueTier tier)
    {
        String tierName = ClueUtils.formatTierName(tier);

        if (tier == ClueTier.BEGINNER)
        {
            tierName = tierName.substring(0, tierName.length() - 2);
        }

        if (config.useTierShortnames())
        {
            switch (tier)
            {
                case BEGINNER:
                    return "Beg";
                case MEDIUM:
                    return "Med";
                case MASTER:
                    return "Mstr";
                default:
                    return tierName;
            }
        }

        return tierName;
    }

}
package com.scrollboxinfo;

public enum ClueTier
{
    BEGINNER,
    EASY,
    MEDIUM,
    HARD,
    ELITE,
    MASTER
}
package com.scrollboxinfo.data;

import com.scrollboxinfo.ClueTier;
import com.scrollboxinfo.ScrollBoxInfoConfig;

import javax.inject.Inject;
import javax.inject.Singleton;
import java.util.EnumMap;

@Singleton
public class ClueCountStorage
{
    private final EnumMap<ClueTier, Integer> clueCounts = new EnumMap<>(ClueTier.class);
    private final EnumMap<ClueTier, Integer> bankCounts = new EnumMap<>(ClueTier.class);

    private final ScrollBoxInfoConfig config;

    @Inject
    public ClueCountStorage(ScrollBoxInfoConfig config)
    {
        this.config = config;
    }

    public void setCount(ClueTier tier, int count)
    {
        clueCounts.put(tier, count);
    }

    public int getCount(ClueTier tier)
    {
        return clueCounts.getOrDefault(tier, 0);
    }

    public void setBankCount(ClueTier tier, int count)
    {
        bankCounts.put(tier, count);

        switch (tier)
        {
            case BEGINNER:
                config.setBankedBeginner(count);
                break;
            case EASY:
                config.setBankedEasy(count);
                break;
            case MEDIUM:
                config.setBankedMedium(count);
                break;
            case HARD:
                config.setBankedHard(count);
                break;
            case ELITE:
                config.setBankedElite(count);
                break;
            case MASTER:
                config.setBankedMaster(count);
                break;
        }
    }


    public void loadBankCountsFromConfig()
    {
        bankCounts.put(ClueTier.BEGINNER, config.bankedBeginner());
        bankCounts.put(ClueTier.EASY, config.bankedEasy());
        bankCounts.put(ClueTier.MEDIUM, config.bankedMedium());
        bankCounts.put(ClueTier.HARD, config.bankedHard());
        bankCounts.put(ClueTier.ELITE, config.bankedElite());
        bankCounts.put(ClueTier.MASTER, config.bankedMaster());
    }

    public int getBankCount(ClueTier tier)
    {
        return bankCounts.getOrDefault(tier, 0);
    }
}
package com.scrollboxinfo;

public class ClueCounts {

    private final int scrollBoxCount;
    private final boolean hasClueScroll;
    private final boolean hasChallengeScroll;

    public ClueCounts(int scrollBoxCount, boolean hasClueScroll, boolean hasChallengeScroll) {
        this.scrollBoxCount = scrollBoxCount;
        this.hasClueScroll = hasClueScroll;
        this.hasChallengeScroll = hasChallengeScroll;
    }

    public int scrollBoxCount() {
        return scrollBoxCount;
    }

    public boolean hasClueScroll() {
        return hasClueScroll;
    }

    public boolean hasChallengeScroll() {
        return hasChallengeScroll;
    }
}
package com.scrollboxinfo;

import net.runelite.client.config.Config;
import net.runelite.client.config.ConfigGroup;
import net.runelite.client.config.ConfigItem;
import net.runelite.client.config.ConfigSection;

import java.awt.*;

@ConfigGroup("scrollboxinfo")
public interface ScrollBoxInfoConfig extends Config
{
	public enum TextPosition
	{
		OFF,
		TOP_RIGHT,
		BOTTOM_LEFT,
		BOTTOM_RIGHT
	}

	@ConfigSection(
			name = "Tooltip overlay",
			description = "Customize how clue scroll information is shown in the tooltip overlay",
			position = 0
	)
	String tooltipOverlay = "tooltipOverlay";

	@ConfigSection(
			name = "Item overlay",
			description = "Customize how clue scroll information is shown in the item overlay",
			position = 100
	)
	String itemOverlay = "itemOverlay";

	@ConfigSection(
			name = "Infobox",
			description = "Customize how clue scroll information is shown in the infobox",
			position = 200
	)
	String infobox = "infobox";

	@ConfigSection(
			name = "Chat message",
			description = "Customize how chat messages are sent",
			position = 300
	)
	String chatMessage = "chatMessage";

	@ConfigSection(
			name = "Menu option",
			description = "Customize which menu options are displayed",
			position = 400
	)
	String menuOption = "menuOption";

	// ===== Tooltip overlay =====

	@ConfigItem(
			keyName = "showBanked",
			name = "Show banked",
			description = "Display the number of scroll boxes and clues banked",
			position = 1,
			section = tooltipOverlay
	)
	default boolean showBanked()
	{
		return true;
	}

	@ConfigItem(
			keyName = "showCurrent",
			name = "Show current total",
			description = "Display the total number of scroll boxes and clue scrolls currently owned",
			position = 2,
			section = tooltipOverlay
	)
	default boolean showCurrent()
	{
		return true;
	}

	@ConfigItem(
			keyName = "showCap",
			name = "Show stack limit",
			description = "Display the stack limit amount of how many scroll boxes you can hold of the same tier",
			position = 3,
			section = tooltipOverlay
	)
	default boolean showCap()
	{
		return true;
	}

	@ConfigItem(
			keyName = "showNextUnlock",
			name = "Show next increase",
			description = "Display how many clue completions until next stack limit increase",
			position = 4,
			section = tooltipOverlay
	)
	default boolean showNextUnlock()
	{
		return true;
	}

	// ===== Item overlay =====

	@ConfigItem(
			keyName = "markFullStack",
			name = "Mark full stacks red",
			description = "Mark the scroll box amount red when you’ve hit your stack limit",
			position = 101,
			section = itemOverlay
	)
	default boolean markFullStack()
	{
		return true;
	}

	@ConfigItem(
			name = "Show tier label",
			keyName = "showTierLabel",
			description = "Show the clue tier name on clue items",
			position = 102,
			section = itemOverlay
	)
	default boolean showTierLabel()
	{
		return true;
	}

	@ConfigItem(
			keyName = "useTierShortnames",
			name = "Use tier shortnames",
			description = "Use shortnames for tier labels",
			position = 103,
			section = itemOverlay
	)
	default boolean useTierShortnames()
	{
		return false;
	}


	@ConfigItem(
			name = "Color tier label",
			keyName = "colorTierLabel",
			description = "Color the tier labels over clue items",
			position = 104,
			section = itemOverlay
	)
	default boolean colorTierLabel()
	{
		return true;
	}

	@ConfigItem(
			keyName = "beginnerTierColor",
			name = "Beginner tier color",
			description = "Text color for beginner clues",
			position = 105,
			section = itemOverlay
	)
	default Color beginnerTierColor() {
		return new Color(0xc3bbba);
	}

	@ConfigItem(
			keyName = "easyTierColor",
			name = "Easy tier color",
			description = "Text color for easy clues",
			position = 106,
			section = itemOverlay
	)
	default Color easyTierColor() {
		return new Color(0x2b952f);
	}

	@ConfigItem(
			keyName = "mediumTierColor",
			name = "Medium tier color",
			description = "Text color for medium clues",
			position = 107,
			section = itemOverlay
	)
	default Color mediumTierColor() {
		return new Color(0x5ea4a7);
	}

	@ConfigItem(
			keyName = "hardTierColor",
			name = "Hard tier color",
			description = "Text color for hard clues",
			position = 108,
			section = itemOverlay
	)
	default Color hardTierColor() {
		return new Color(0xc870e0);
	}

	@ConfigItem(
			keyName = "eliteTierColor",
			name = "Elite tier color",
			description = "Text color for elite clues",
			position = 109,
			section = itemOverlay
	)
	default Color eliteTierColor() {
		return new Color(0xc2aa18);
	}

	@ConfigItem(
			keyName = "masterTierColor",
			name = "Master tier color",
			description = "Text color for master clues",
			position = 110,
			section = itemOverlay
	)
	default Color masterTierColor() {
		return new Color(0xa7342a);
	}

	@ConfigItem(
			keyName = "showBankedPosition",
			name = "Show banked",
			description = "Position of the banked count text",
			position = 111,
			section = itemOverlay
	)
	default TextPosition showBankedPosition()
	{
		return TextPosition.OFF;
	}

	@ConfigItem(
			keyName = "showCurrentTotalPosition",
			name = "Show current total",
			description = "Position of the current total count text",
			position = 112,
			section = itemOverlay
	)
	default TextPosition showCurrentTotalPosition()
	{
		return TextPosition.OFF;
	}

	@ConfigItem(
			keyName = "showStackLimitPosition",
			name = "Show stack limit",
			description = "Position of the stack limit text",
			position = 113,
			section = itemOverlay
	)
	default TextPosition showStackLimitPosition()
	{
		return TextPosition.OFF;
	}

	// ===== Infobox =====

	@ConfigItem(
			keyName = "showFullStackInfobox",
			name = "Show full stack",
			description = "Display an infobox when you've reached your clue stack limit",
			position = 201,
			section = infobox
	)
	default boolean showFullStackInfobox()
	{
		return true;
	}

	@ConfigItem(
			keyName = "showBeginnerInfobox",
			name = "Show beginner",
			description = "Show infobox for beginner clues",
			position = 202,
			section = infobox
	)
	default boolean showBeginnerInfobox() { return true; }

	@ConfigItem(
			keyName = "showEasyInfobox",
			name = "Show easy",
			description = "Show infobox for easy clues",
			position = 203,
			section = infobox
	)
	default boolean showEasyInfobox() { return true; }

	@ConfigItem(
			keyName = "showMediumInfobox",
			name = "Show medium",
			description = "Show infobox for medium clues",
			position = 204,
			section = infobox
	)
	default boolean showMediumInfobox() { return true; }

	@ConfigItem(
			keyName = "showHardInfobox",
			name = "Show hard",
			description = "Show infobox for hard clues",
			position = 205,
			section = infobox
	)
	default boolean showHardInfobox() { return true; }

	@ConfigItem(
			keyName = "showEliteInfobox",
			name = "Show elite",
			description = "Show infobox for elite clues",
			position = 206,
			section = infobox
	)
	default boolean showEliteInfobox() { return true; }

	@ConfigItem(
			keyName = "showMasterInfobox",
			name = "Show master",
			description = "Show infobox for master clues",
			position = 207,
			section = infobox
	)
	default boolean showMasterInfobox() { return true; }

	// ===== Chat message =====

	@ConfigItem(
			keyName = "showChatMessage",
			name = "Show chat message",
			description = "Send a chat message of your current scroll box/clue scroll total when a scroll box is received",
			position = 301,
			section = chatMessage
	)
	default boolean showChatMessage()
	{
		return true;
	}

	// ===== Menu option =====

	@ConfigItem(
			keyName = "showInventoryRightClickOption",
			name = "Show clue counts menu option",
			description = "Show 'View clue counts' menu option in the inventory tab right-click menu",
			position = 401,
			section = menuOption
	)
	default boolean showInventoryRightClickOption()
	{
		return true;
	}


	// ===== Persistent banked clue counts =====

	@ConfigItem(
			keyName = "bankedBeginner",
			name = "",
			description = "",
			hidden = true
	)
	default int bankedBeginner() { return 0; }

	@ConfigItem(
			keyName = "bankedBeginner",
			name = "",
			description = "",
			hidden = true
	)
	void setBankedBeginner(int value);

	@ConfigItem(
			keyName = "bankedEasy",
			name = "",
			description = "",
			hidden = true
	)
	default int bankedEasy() { return 0; }

	@ConfigItem(
			keyName = "bankedEasy",
			name = "",
			description = "",
			hidden = true
	)
	void setBankedEasy(int value);

	@ConfigItem(
			keyName = "bankedMedium",
			name = "",
			description = "",
			hidden = true
	)
	default int bankedMedium() { return 0; }

	@ConfigItem(
			keyName = "bankedMedium",
			name = "",
			description = "",
			hidden = true
	)
	void setBankedMedium(int value);

	@ConfigItem(
			keyName = "bankedHard",
			name = "",
			description = "",
			hidden = true
	)
	default int bankedHard() { return 0; }

	@ConfigItem(
			keyName = "bankedHard",
			name = "",
			description = "",
			hidden = true
	)
	void setBankedHard(int value);

	@ConfigItem(
			keyName = "bankedElite",
			name = "",
			description = "",
			hidden = true
	)
	default int bankedElite() { return 0; }

	@ConfigItem(
			keyName = "bankedElite",
			name = "",
			description = "",
			hidden = true
	)
	void setBankedElite(int value);

	@ConfigItem(
			keyName = "bankedMaster",
			name = "",
			description = "",
			hidden = true
	)
	default int bankedMaster() { return 0; }

	@ConfigItem(
			keyName = "bankedMaster",
			name = "",
			description = "",
			hidden = true
	)
	void setBankedMaster(int value);

	@ConfigItem(
			keyName = "hasClueOrChallengeScrollInBank_BEGINNER",
			name = "",
			description = "",
			hidden = true
	)
	default boolean hasClueOrChallengeScrollInBank_BEGINNER()
	{
		return false;
	}

	@ConfigItem(
			keyName = "hasClueOrChallengeScrollInBank_EASY",
			name = "",
			description = "",
			hidden = true
	)
	default boolean hasClueOrChallengeScrollInBank_EASY()
	{
		return false;
	}

	@ConfigItem(
			keyName = "hasClueOrChallengeScrollInBank_MEDIUM",
			name = "",
			description = "",
			hidden = true
	)
	default boolean hasClueOrChallengeScrollInBank_MEDIUM()
	{
		return false;
	}

	@ConfigItem(
			keyName = "hasClueOrChallengeScrollInBank_HARD",
			name = "",
			description = "",
			hidden = true
	)
	default boolean hasClueOrChallengeScrollInBank_HARD()
	{
		return false;
	}

	@ConfigItem(
			keyName = "hasClueOrChallengeScrollInBank_ELITE",
			name = "",
			description = "",
			hidden = true
	)
	default boolean hasClueOrChallengeScrollInBank_ELITE()
	{
		return false;
	}

	@ConfigItem(
			keyName = "hasClueOrChallengeScrollInBank_MASTER",
			name = "",
			description = "",
			hidden = true
	)
	default boolean hasClueOrChallengeScrollInBank_MASTER()
	{
		return false;
	}

}
package com.scrollboxinfo;

import com.google.inject.Provides;
import javax.inject.Inject;

import com.scrollboxinfo.data.ClueCountStorage;
import com.scrollboxinfo.overlay.ClueWidgetItemOverlay;
import com.scrollboxinfo.overlay.StackLimitInfoBox;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.*;
import net.runelite.api.events.GameTick;
import net.runelite.api.events.MenuEntryAdded;
import net.runelite.api.widgets.ComponentID;
import net.runelite.api.widgets.Widget;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.events.ConfigChanged;
import net.runelite.client.game.ItemManager;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.plugins.PluginDescriptor;
import net.runelite.client.ui.overlay.OverlayManager;
import net.runelite.api.events.ItemContainerChanged;
import net.runelite.api.InventoryID;
import net.runelite.client.ui.overlay.infobox.InfoBoxManager;

import java.awt.image.BufferedImage;
import java.util.HashMap;
import java.util.Map;

@Slf4j
@PluginDescriptor(
	name = "Scroll Box Info",
	description = "Keep track of how many clues you have, your current clue stack limit, and how many clues until next stack limit increase",
	tags = {"scroll", "watson", "case"}
)
public class ScrollBoxInfoPlugin extends Plugin
{
	@Inject
	private Client client;
	@Inject
	private ScrollBoxInfoConfig config;
	@Inject
	private QuestChecker questChecker;
	@Inject
	private ClueCountStorage clueCountStorage;
	@Inject
	private ClueCounter clueCounter;
	@Inject
	private ClueWidgetItemOverlay clueWidgetItemOverlay;
	@Inject
	private OverlayManager overlayManager;
	@Inject
	private ConfigManager configManager;
	@Inject
	private ClueUtils clueUtils;
	@Inject
	private InfoBoxManager infoBoxManager;
	@Inject
	private ItemManager itemManager;
	private StackLimitInfoBox stackInfoBox;
	@Inject
	private ClientThread clientThread;

	private boolean bankWasOpenLastTick = false;
	private boolean bankIsOpen = false;
	private boolean depositBoxIsOpen = false;
	private boolean depositBoxWasOpenLastTick = false;
	private final Map<ClueTier, Integer> previousInventoryScrollBoxCount = new HashMap<>();
	private final Map<ClueTier, Boolean> previousInventoryClueScrollState = new HashMap<>();
	private final Map<ClueTier, Boolean> previousInventoryChallengeScrollState = new HashMap<>();
	private final Map<ClueTier, Integer> previousBankScrollBoxCount = new HashMap<>();
	private final Map<ClueTier, Boolean> previousBankClueScrollState = new HashMap<>();
	private final Map<ClueTier, Boolean> previousBankChallengeScrollState = new HashMap<>();
	private final Map<ClueTier, Integer> previousTotalClueCounts = new HashMap<>();
	private final Map<ClueTier, StackLimitInfoBox> stackInfoBoxes = new HashMap<>();

	private void checkAndDisplayInfobox(ClueTier tier, int count, int cap) {
		if (!config.showFullStackInfobox() || !isTierInfoboxEnabled(tier)) {
			StackLimitInfoBox box = stackInfoBoxes.remove(tier);
			if (box != null) {
				infoBoxManager.removeInfoBox(box);
			}
			return;
		}

		StackLimitInfoBox box = stackInfoBoxes.get(tier);

		if (count >= cap) {
			if (box == null) {
				int clueItemId = clueUtils.getClueItemId(tier);
				BufferedImage image = itemManager.getImage(clueItemId);
				box = new StackLimitInfoBox(image, this, tier, count);
				infoBoxManager.addInfoBox(box);
				stackInfoBoxes.put(tier, box);
			}
		} else if (box != null) {
			infoBoxManager.removeInfoBox(box);
			stackInfoBoxes.remove(tier);
		}
	}

	private boolean isTierInfoboxEnabled(ClueTier tier) {
		switch (tier) {
			case BEGINNER:
				return config.showBeginnerInfobox();
			case EASY:
				return config.showEasyInfobox();
			case MEDIUM:
				return config.showMediumInfobox();
			case HARD:
				return config.showHardInfobox();
			case ELITE:
				return config.showEliteInfobox();
			case MASTER:
				return config.showMasterInfobox();
			default:
				return true;
		}
	}

	private void sendTotalClueCountsChatMessage()
	{
		for (ClueTier tier : ClueTier.values())
		{
			int current = clueCounter.getClueCounts(tier);
			int cap = StackLimitCalculator.getStackLimit(tier, client);

			String color = (current == cap) ? "ff0000" : "006600"; // red : green
			String message = String.format(
					"<col=%s>%s clue count: %d/%d",
					color,
					ClueUtils.formatTierName(tier),
					current,
					cap
			);

			client.addChatMessage(ChatMessageType.GAMEMESSAGE, "", message, null);
		}
	}

	@Override
	protected void startUp() throws Exception
	{
		clueCountStorage.loadBankCountsFromConfig();
		overlayManager.add(clueWidgetItemOverlay);
	}

	@Override
	protected void shutDown() throws Exception
	{
		overlayManager.remove(clueWidgetItemOverlay);
		clueWidgetItemOverlay.resetMarkedStacks();
	}

	@Subscribe
	public void onConfigChanged(ConfigChanged event)
	{
		if (!event.getGroup().equals("scrollboxinfo"))
			return;

		if (event.getKey().equals("markFullStack") && !config.markFullStack())
		{
			clueWidgetItemOverlay.resetMarkedStacks();
		}

		if (event.getKey().equals("showFullStackInfobox")
				|| event.getKey().equals("showBeginnerInfobox")
				|| event.getKey().equals("showEasyInfobox")
				|| event.getKey().equals("showMediumInfobox")
				|| event.getKey().equals("showHardInfobox")
				|| event.getKey().equals("showEliteInfobox")
				|| event.getKey().equals("showMasterInfobox"))
		{
			clientThread.invokeLater(() ->
			{
				for (ClueTier tier : ClueTier.values())
				{
					int count = clueCounter.getClueCounts(tier);
					int cap = StackLimitCalculator.getStackLimit(tier, client);
					checkAndDisplayInfobox(tier, count, cap);
				}
			});
		}
	}

	@Subscribe
	public void onGameTick(GameTick tick)
	{
		bankWasOpenLastTick = bankIsOpen;
		depositBoxWasOpenLastTick = depositBoxIsOpen;

		Widget bankWidget = client.getWidget(ComponentID.BANK_CONTAINER);
		bankIsOpen = bankWidget != null && !bankWidget.isHidden();

		Widget depositBoxWidget = client.getWidget(ComponentID.DEPOSIT_BOX_INVENTORY_ITEM_CONTAINER);
		depositBoxIsOpen = depositBoxWidget != null && !depositBoxWidget.isHidden();
	}

	@Subscribe
	public void onItemContainerChanged(ItemContainerChanged event)
	{
		ItemContainer inventoryContainer = client.getItemContainer(InventoryID.INVENTORY);
		ItemContainer bankContainer = client.getItemContainer(InventoryID.BANK);

		for (ClueTier tier : ClueTier.values())
		{
			ClueCounts inventory = clueCounter.getClueCounts(tier, inventoryContainer);
			ClueCounts bank = clueCounter.getClueCounts(tier, bankContainer);

			boolean clueEnteredInv = inventory.hasClueScroll() && !previousInventoryClueScrollState.getOrDefault(tier, false);
			boolean clueLeftInv = !inventory.hasClueScroll() && previousInventoryClueScrollState.getOrDefault(tier, false);
			boolean challengeEnteredInv = inventory.hasChallengeScroll() && !previousInventoryChallengeScrollState.getOrDefault(tier, false);
			boolean challengeLeftInv = !inventory.hasChallengeScroll() && previousInventoryChallengeScrollState.getOrDefault(tier, false);
			boolean scrollBoxEnteredInv = inventory.scrollBoxCount() > previousInventoryScrollBoxCount.getOrDefault(tier, 0);
			boolean scrollBoxLeftInv = inventory.scrollBoxCount() < previousInventoryScrollBoxCount.getOrDefault(tier, 0);

			boolean bankedClueScroll = previousBankClueScrollState.getOrDefault(tier, false);
			boolean bankedChallengeScroll = previousBankChallengeScrollState.getOrDefault(tier, false);
			int assumedBankedScrollBoxCount = previousBankScrollBoxCount.getOrDefault(tier, 0);
			boolean hasScrollInBank = Boolean.TRUE.equals(
					configManager.getRSProfileConfiguration("scrollboxinfo", "hasClueOrChallengeScrollInBank_" + tier.name(), Boolean.class)
			);


			int count = inventory.scrollBoxCount();
			if (inventory.hasClueScroll())
				count++;
			if (inventory.hasChallengeScroll())
				count++;

			if (bankContainer != null) {
				bankedClueScroll = bank.hasClueScroll();
				bankedChallengeScroll = bank.hasChallengeScroll();
				assumedBankedScrollBoxCount = bank.scrollBoxCount();

				int bankCount = assumedBankedScrollBoxCount;
				bankCount += bankedClueScroll ? 1 : 0;
				bankCount += bankedChallengeScroll ? 1 : 0;

				if (bankedChallengeScroll && bankedClueScroll)
					bankCount -= 1;

				if (bankedChallengeScroll || bankedClueScroll)
				{
					configManager.setRSProfileConfiguration("scrollboxinfo", "hasClueOrChallengeScrollInBank_" + tier.name(), true);
				}
				if (!bankedChallengeScroll && !bankedClueScroll)
				{
					configManager.setRSProfileConfiguration("scrollboxinfo", "hasClueOrChallengeScrollInBank_" + tier.name(), false);
				}

				clueCountStorage.setBankCount(tier, bankCount);
			} else if (bankWasOpenLastTick || depositBoxIsOpen || depositBoxWasOpenLastTick) {
				if (scrollBoxLeftInv)
					assumedBankedScrollBoxCount += 1;
				else if (scrollBoxEnteredInv)
					assumedBankedScrollBoxCount -= 1;

				if (clueEnteredInv) {
					bankedClueScroll = false;
				} else if (clueLeftInv) {
					bankedClueScroll = true;
				}
				if (challengeEnteredInv) {
					bankedChallengeScroll = false;
				} else if (challengeLeftInv) {
					bankedChallengeScroll = true;
				}

				if (bankedChallengeScroll || bankedClueScroll)
				{
					configManager.setRSProfileConfiguration("scrollboxinfo", "hasClueOrChallengeScrollInBank_" + tier.name(), true);
				}
				if (!bankedChallengeScroll && !bankedClueScroll)
				{
					configManager.setRSProfileConfiguration("scrollboxinfo", "hasClueOrChallengeScrollInBank_" + tier.name(), false);
				}

				int assumedBankCount = assumedBankedScrollBoxCount;
				if (bankedChallengeScroll || bankedClueScroll)
					assumedBankCount += 1;

				clueCountStorage.setBankCount(tier, assumedBankCount);
			}

			count += clueCountStorage.getBankCount(tier);
			if ((inventory.hasClueScroll() && inventory.hasChallengeScroll())
				|| (inventory.hasClueScroll() && bankedChallengeScroll)
				|| (inventory.hasChallengeScroll() && bankedClueScroll)
				|| ((inventory.hasClueScroll() || inventory.hasChallengeScroll()) && hasScrollInBank))
				count -= 1;
			clueCountStorage.setCount(tier, count);

			int cap = StackLimitCalculator.getStackLimit(tier, client);

			if (config.showFullStackInfobox())
				checkAndDisplayInfobox(tier, count, cap);

			int previousTotalClueCount = previousTotalClueCounts.getOrDefault(tier, 0);
			if (config.showChatMessage()) {
				if (scrollBoxEnteredInv
						&& (clueCounter.getClueCounts(tier) != previousTotalClueCount)
						&& previousTotalClueCounts.containsKey(tier)
						&& bankContainer == null
						&& !bankWasOpenLastTick
						&& !depositBoxIsOpen
						&& !depositBoxWasOpenLastTick) {

					String color = (count == cap) ? "ff0000" : "006600"; // red : green
					String message = String.format("<col=%s>Current %s clue count: %d/%d", color, tier.name().toLowerCase(), count, cap);
					client.addChatMessage(ChatMessageType.GAMEMESSAGE, "", message, null);
				}
			}

			previousBankScrollBoxCount.put(tier, assumedBankedScrollBoxCount);
			previousBankClueScrollState.put(tier, bankedClueScroll);
			previousBankChallengeScrollState.put(tier, bankedChallengeScroll);
			previousInventoryScrollBoxCount.put(tier, inventory.scrollBoxCount());
			previousInventoryClueScrollState.put(tier, inventory.hasClueScroll());
			previousInventoryChallengeScrollState.put(tier, inventory.hasChallengeScroll());
			previousTotalClueCounts.put(tier, clueCountStorage.getCount(tier));
		}
	}

	@Subscribe
	public void onMenuEntryAdded(MenuEntryAdded event)
	{
		if (!config.showInventoryRightClickOption()) return;

		if (event.getOption().equals("Inventory"))
		{
			client.getMenu().createMenuEntry(1)
					.setOption("View clue counts")
					.setType(MenuAction.RUNELITE)
					.onClick(e -> sendTotalClueCountsChatMessage())
					.setDeprioritized(true);
		}
	}


	@Provides
	ScrollBoxInfoConfig provideConfig(ConfigManager configManager)
	{
		return configManager.getConfig(ScrollBoxInfoConfig.class);
	}
}
package com.scrollboxinfo;

import net.runelite.api.Client;

public class StackLimitCalculator
{
    public static final int SCROLL_CASE_BEGINNER_MINOR = 16565;
    public static final int SCROLL_CASE_BEGINNER_MAJOR = 16566;
    public static final int SCROLL_CASE_EASY_MINOR = 16567;
    public static final int SCROLL_CASE_EASY_MAJOR = 16586;
    public static final int SCROLL_CASE_MEDIUM_MINOR = 16587;
    public static final int SCROLL_CASE_MEDIUM_MAJOR = 16588;
    public static final int SCROLL_CASE_HARD_MINOR = 16589;
    public static final int SCROLL_CASE_HARD_MAJOR = 16590;
    public static final int SCROLL_CASE_ELITE_MINOR = 16591;
    public static final int SCROLL_CASE_ELITE_MAJOR = 16592;
    public static final int SCROLL_CASE_MASTER_MINOR = 16593;
    public static final int SCROLL_CASE_MASTER_MAJOR = 16594;
    public static final int SCROLL_CASE_MIMIC = 16595;
    private static final int BASE_CLUE_CAP = 2;

    public static int getStackLimit(ClueTier tier, Client client)
    {
        int tierBonus = getTierBonus(tier, client);
        int mimicBonus = client.getVarbitValue(SCROLL_CASE_MIMIC);
        return BASE_CLUE_CAP + tierBonus + mimicBonus;
    }

    private static int getTierBonus(ClueTier tier, Client client)
    {
        switch (tier)
        {
            case BEGINNER:
                return client.getVarbitValue(SCROLL_CASE_BEGINNER_MINOR)
                        + client.getVarbitValue(SCROLL_CASE_BEGINNER_MAJOR);
            case EASY:
                return client.getVarbitValue(SCROLL_CASE_EASY_MINOR)
                        + client.getVarbitValue(SCROLL_CASE_EASY_MAJOR);
            case MEDIUM:
                return client.getVarbitValue(SCROLL_CASE_MEDIUM_MINOR)
                        + client.getVarbitValue(SCROLL_CASE_MEDIUM_MAJOR);
            case HARD:
                return client.getVarbitValue(SCROLL_CASE_HARD_MINOR)
                        + client.getVarbitValue(SCROLL_CASE_HARD_MAJOR);
            case ELITE:
                return client.getVarbitValue(SCROLL_CASE_ELITE_MINOR)
                        + client.getVarbitValue(SCROLL_CASE_ELITE_MAJOR);
            case MASTER:
                return client.getVarbitValue(SCROLL_CASE_MASTER_MINOR)
                        + client.getVarbitValue(SCROLL_CASE_MASTER_MAJOR);
            default:
                return 0;
        }
    }
}
package com.scrollboxinfo;

import net.runelite.api.Client;
import net.runelite.api.Quest;
import net.runelite.api.QuestState;
import lombok.extern.slf4j.Slf4j;

import javax.inject.Inject;

@Slf4j
public class QuestChecker
{
    private final Client client;

    @Inject
    public QuestChecker(Client client)
    {
        this.client = client;
    }

    public boolean isXMarksTheSpotComplete()
    {
        QuestState state = Quest.X_MARKS_THE_SPOT.getState(client);
        return state == QuestState.FINISHED;
    }
}
package com.scrollboxinfo.overlay;

import com.scrollboxinfo.ClueTier;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.ui.overlay.infobox.InfoBox;

import java.awt.*;
import java.awt.image.BufferedImage;

public class StackLimitInfoBox extends InfoBox {
    private final ClueTier tier;
    private final int clueCount;

    public StackLimitInfoBox(BufferedImage image, Plugin plugin, ClueTier tier, int clueCount) {
        super(image, plugin);
        this.tier = tier;
        this.clueCount = clueCount;
    }

    @Override
    public String getText() {
        //return String.valueOf(clueCount);
        return "Full";
    }

    @Override
    public Color getTextColor() {
        return Color.RED;
    }

    @Override
    public String getTooltip() {
        return "Your " + tier.name().toLowerCase() + " clue stack is full.";
    }
}
package com.scrollboxinfo.overlay;

import com.scrollboxinfo.*;
import com.scrollboxinfo.data.ClueCountStorage;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.ItemID;
import net.runelite.api.Point;
import net.runelite.api.widgets.ItemQuantityMode;
import net.runelite.api.widgets.Widget;
import net.runelite.api.widgets.ComponentID;
import net.runelite.api.widgets.WidgetItem;
import net.runelite.client.ui.overlay.WidgetItemOverlay;
import net.runelite.client.ui.overlay.components.TextComponent;
import net.runelite.client.ui.overlay.tooltip.Tooltip;
import net.runelite.client.ui.overlay.tooltip.TooltipManager;
import net.runelite.client.ui.FontManager;

import javax.inject.Inject;
import java.awt.*;
import java.util.Arrays;
import java.util.List;
import java.util.ArrayList;
import java.util.Map;
@Slf4j
@RequiredArgsConstructor(onConstructor_ = @Inject)
public class ClueWidgetItemOverlay extends WidgetItemOverlay
{
    private final Client client;
    private final TooltipManager tooltipManager;
    private final ClueCountStorage storage;

    @Inject
    private ClueCounter clueCounter;

    @Inject
    private ScrollBoxInfoConfig config;

    @Inject
    private QuestChecker questChecker;

    @Inject
    private ClueUtils clueUtils;

    @Inject
    public void setup()
    {
        showOnInventory();
        showOnBank();
    }

    @Override
    public void renderItemOverlay(Graphics2D graphics, int itemId, WidgetItem widgetItem)
    {
        ClueTier tier = ClueUtils.getClueTier(client, itemId);
        if (tier == null)
            return;

        int current = clueCounter.getClueCounts(tier);
        int cap = StackLimitCalculator.getStackLimit(tier, client);
        Rectangle bounds = widgetItem.getCanvasBounds();

        if (isScrollBox(itemId) && config.markFullStack())
        {
            Color textColor = (config.markFullStack() && current >= cap) ? Color.RED : Color.YELLOW;
            widgetItem.getWidget().setItemQuantityMode(ItemQuantityMode.NEVER);
            renderQuantity(graphics, widgetItem.getCanvasBounds(), widgetItem.getQuantity(), textColor);
        }

        // Render tier label in bottom-left corner
        if (config.showTierLabel() && tier != null)
        {
            String tierName = clueUtils.getFormattedTierName(tier);

            Color tierColor;

            if (!config.colorTierLabel())
            {
                tierColor = Color.WHITE;
            }
            else
            {
                switch (tier)
                {
                    case BEGINNER:
                        tierColor = config.beginnerTierColor();
                        break;
                    case EASY:
                        tierColor = config.easyTierColor();
                        break;
                    case MEDIUM:
                        tierColor = config.mediumTierColor();
                        break;
                    case HARD:
                        tierColor = config.hardTierColor();
                        break;
                    case ELITE:
                        tierColor = config.eliteTierColor();
                        break;
                    case MASTER:
                        tierColor = config.masterTierColor();
                        break;
                    default:
                        tierColor = Color.WHITE;
                        break;
                }
            }

            final TextComponent label = new TextComponent();
            label.setText(tierName);
            label.setColor(tierColor); // use config color
            label.setPosition(new java.awt.Point(bounds.x, bounds.y + bounds.height));
            label.setFont(FontManager.getRunescapeSmallFont());
            label.render(graphics);
        }

        int banked = storage.getBankCount(tier);

        if (banked > 0 && config.showBankedPosition() != ScrollBoxInfoConfig.TextPosition.OFF)
        {
            renderPositionedText(graphics, bounds, "+" + banked, Color.WHITE, config.showBankedPosition());
        }

        if (config.showStackLimitPosition() != ScrollBoxInfoConfig.TextPosition.OFF)
        {
            renderPositionedText(graphics, bounds, String.valueOf(!questChecker.isXMarksTheSpotComplete() ? 1 : cap), Color.WHITE, config.showStackLimitPosition());
        }

        if (config.showCurrentTotalPosition() != ScrollBoxInfoConfig.TextPosition.OFF)
        {
            renderPositionedText(graphics, bounds, String.valueOf(current), Color.WHITE, config.showCurrentTotalPosition());
        }


        Point mousePos = client.getMouseCanvasPosition();
        if (!widgetItem.getCanvasBounds().contains(mousePos.getX(), mousePos.getY())) {
            return;
        }

        if (!questChecker.isXMarksTheSpotComplete()) {
            //tooltipManager.add(new Tooltip("Complete X Marks the Spot quest to start tracking clues"));
            return;
        }

        List<String> lines = new ArrayList<>();

        if (config.showBanked() && banked != 0)
        {
            lines.add("Banked: " + banked);
        }

        if (config.showCurrent())
        {
            lines.add("Current total: " + current);
        }

        if (config.showCap())
        {
            lines.add("Stack limit: " + cap);
        }

        if (config.showNextUnlock())
        {
            Integer varpId = tierToVarpId.get(tier);
            int completed = varpId != null ? client.getVarpValue(varpId) : 0;
            int[] unlocks = tierUnlockThresholds.getOrDefault(tier, new int[0]);

            for (int threshold : unlocks)
            {
                if (completed < threshold)
                {
                    lines.add("Next increase in: " + (threshold - completed) + " clues");
                    break;
                }
            }
        }

        if (!lines.isEmpty())
        {
            if (questChecker.isXMarksTheSpotComplete())
                tooltipManager.add(new Tooltip(String.join("<br>", lines)));
        }
    }

    private void renderQuantity(Graphics2D graphics, Rectangle bounds, int quantity, Color textColor)
    {
        final TextComponent textComponent = new TextComponent();
        String quantityText = String.valueOf(quantity);
        graphics.setFont(FontManager.getRunescapeSmallFont());
        textComponent.setPosition(new java.awt.Point(bounds.x, bounds.y + 10));
        textComponent.setText(quantityText);
        textComponent.setColor(textColor);
        textComponent.render(graphics);
    }

    private void renderPositionedText(Graphics2D graphics, Rectangle bounds, String text, Color color, ScrollBoxInfoConfig.TextPosition position)
    {
        if (position == ScrollBoxInfoConfig.TextPosition.OFF)
            return;

        int x = bounds.x;
        int y = bounds.y;
        FontMetrics fontMetrics = graphics.getFontMetrics();
        // Grabbing the width of the entire text string was offsetting incorrectly when toggling mark full stacks
        // Only grab width of +
        int textWidth = fontMetrics.stringWidth("+");

        int textPositionOffset = text.startsWith("+") ? textWidth + 5 : 5;
        switch (position)
        {
            case TOP_RIGHT:
                x = bounds.x + bounds.width - textPositionOffset;
                y = bounds.y + 10;
                break;
            case BOTTOM_LEFT:
                x = bounds.x;
                y = bounds.y + bounds.height;
                break;
            case BOTTOM_RIGHT:
                x = bounds.x + bounds.width - textPositionOffset;
                y = bounds.y + bounds.height;
                break;
        }

        final TextComponent component = new TextComponent();
        component.setText(text);
        component.setColor(color);
        component.setPosition(new java.awt.Point(x, y));
        component.setFont(FontManager.getRunescapeSmallFont());
        component.render(graphics);
    }


    private boolean isScrollBox(int itemId)
    {
        switch (itemId)
        {
            case ItemID.SCROLL_BOX_BEGINNER:
            case ItemID.SCROLL_BOX_EASY:
            case ItemID.SCROLL_BOX_MEDIUM:
            case ItemID.SCROLL_BOX_HARD:
            case ItemID.SCROLL_BOX_ELITE:
            case ItemID.SCROLL_BOX_MASTER:
                return true;
            default:
                return false;
        }
    }


    public void resetMarkedStacks()
    {
        List<Integer> containerComponentIds = Arrays.asList(
                ComponentID.INVENTORY_CONTAINER,
                ComponentID.BANK_ITEM_CONTAINER,
                ComponentID.BANK_INVENTORY_ITEM_CONTAINER,
                ComponentID.BANK_EQUIPMENT_PARENT,
                ComponentID.DEPOSIT_BOX_INVENTORY_ITEM_CONTAINER,
                ComponentID.EQUIPMENT_INVENTORY_ITEM_CONTAINER,
                ComponentID.GRAND_EXCHANGE_INVENTORY_INVENTORY_ITEM_CONTAINER,
                ComponentID.SHOP_INVENTORY_ITEM_CONTAINER,
                ComponentID.GUIDE_PRICES_INVENTORY_ITEM_CONTAINER,
                ComponentID.BANK_INVENTORY_EQUIPMENT_ITEM_CONTAINER
        );

        for (int componentId : containerComponentIds)
        {
            Widget container = client.getWidget(componentId);
            if (container == null || container.getDynamicChildren() == null)
                continue;

            for (Widget child : container.getDynamicChildren())
            {
                if (child != null && child.getItemId() > 0 && isScrollBox(child.getItemId()))
                {
                    child.setItemQuantityMode(ItemQuantityMode.ALWAYS);
                }
            }
        }
    }


    private static final Map<ClueTier, Integer> tierToVarpId = Map.of(
            ClueTier.BEGINNER, 2201,
            ClueTier.EASY, 1111,
            ClueTier.MEDIUM, 1112,
            ClueTier.HARD, 1354,
            ClueTier.ELITE, 1533,
            ClueTier.MASTER, 1534
    );

    private static final Map<ClueTier, int[]> tierUnlockThresholds = Map.of(
            ClueTier.BEGINNER, new int[] {50, 100},
            ClueTier.EASY, new int[] {100, 200},
            ClueTier.MEDIUM, new int[] {100, 250},
            ClueTier.HARD, new int[] {50, 150},
            ClueTier.ELITE, new int[] {50, 150},
            ClueTier.MASTER, new int[] {25, 75}
    );

}
package com.scrollboxinfo;

import net.runelite.client.RuneLite;
import net.runelite.client.externalplugins.ExternalPluginManager;

public class ScrollBoxInfoPluginTest
{
	public static void main(String[] args) throws Exception
	{
		ExternalPluginManager.loadBuiltin(ScrollBoxInfoPlugin.class);
		RuneLite.main(args);
	}
}
