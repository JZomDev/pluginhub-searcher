package com.pinggraph;

import net.runelite.client.config.*;

import java.awt.Color;

import lombok.AllArgsConstructor;

@ConfigGroup("pinggraph")
public interface PingGraphConfig extends Config {

    @ConfigSection(
            name = "Font Settings",
            description = "Font Settings",
            position = 98
    )
    String fontSection = "fontSection";

    @ConfigSection(
            name = "Warning Settings",
            description = "Change the colors of the overlay when lagging",
            position = 99
    )
    String warnSection = "warnSection";


    @Alpha
    @ConfigItem(
            position = 0,
            keyName = "graphTextColor",
            name = "Graph Text Color",
            description = "The color of the text"
    )
    default Color graphTextColor() {
        return new Color(255, 255, 24, 255);
    }



    @Alpha
    @ConfigItem(
            position = 1,
            keyName = "graphLineColor",
            name = "Graph Line Color",
            description = "The color of the graph line"
    )
    default Color graphLineColor() {
        return new Color(255, 255, 0, 255);
    }



    @Alpha
    @ConfigItem(
            position = 2,
            keyName = "OverlayBackgroundColor",
            name = "Overlay BG Color",
            description = "The background color of the overlay"
    )
    default Color overlayBackgroundColor() {
        return new Color(17, 17, 17, 100);
    }



    @Alpha
    @ConfigItem(
            position = 3,
            keyName = "OverlayBorderColor",
            name = "Overlay Border Color",
            description = "The border color of the overlay"
    )
    default Color overlayBorderColor() {
        return new Color(17, 17, 17, 70);
    }



    @Alpha
    @ConfigItem(
            position = 4,
            keyName = "graphBackgroundColor",
            name = "Graph BG Color",
            description = "The background color of the graph"
    )
    default Color graphBackgroundColor() {
        return new Color(17, 17, 17, 120);
    }



    @Alpha
    @ConfigItem(
            position = 5,
            keyName = "graphBorderColor",
            name = "Graph Border Color",
            description = "The border color of the graph"
    )
    default Color graphBorderColor() {
        return new Color(17, 17, 17, 70);
    }



    @ConfigItem(
            position = 6,
            keyName = "toggleLineOnly",
            name = "Hide Labels",
            description = "Changes the plugin to only show a line"
    )
    default boolean toggleLineOnly() {
        return false;
    }



    @ConfigItem(
            position = 7,
            keyName = "toggleBehind",
            name = "Hide Behind Interfaces",
            description = "Hides graph behind interfaces i.e bank and map"
    )
    default boolean toggleBehind() {
        return false;
    }



    @ConfigItem(
            position = 8,
            keyName = "toggleMaxMin",
            name = "Scale Between Max and Min Ping",
            description = "Only show range between max and min ping"
    )
    default boolean toggleRange() {
        return false;
    }



    @ConfigItem(
            position = 9,
            keyName = "hideMargin",
            name = "Remove Margins",
            description = "Removes the margins that surround the graph"
    )
    default boolean hideMargin() {
        return false;
    }



    @ConfigItem(
            position = 9,
            keyName = "textMargin",
            name = "Text Margins",
            description = "Spacing between the text and the sides of the overlay"
    )
    @Range(min = -1000, max = 1000)
    default int textMargin() {
        return 10;
    }



    @ConfigItem(
            position = 10,
            keyName = "graphTicks",
            name = "Graph Game Ticks",
            description = "Changes the graph to show game ticks(normally around 600ms)"
    )
    default boolean graphTicks() {
        return false;
    }



    @ConfigItem(
            position = 10,
            keyName = "hideGraph",
            name = "Hide Graph",
            description = "Hides the Graph leaving only labels"
    )
    default boolean hideGraph() {
        return false;
    }



    @ConfigItem(
            position = 11,
            keyName = "leftLabel",
            name = "Top Left Label",
            description = "Default: \"Current Latency\"",
            section = fontSection
    )
    default Labels leftLabel() {
        return Labels.LATENCY;
    }



    @ConfigItem(
            position = 12,
            keyName = "rightLabel",
            name = "Top Right Label",
            description = "Default: \"Max Ping Value\"",
            section = fontSection
    )
    default Labels rightLabel() {
        return Labels.PINGMAX;
    }



    @ConfigItem(
            position = 13,
            keyName = "bottomLeftLabel",
            name = "Bottom Left Label",
            description = "Default: \"Blank\"",
            section = fontSection
    )
    default Labels bottomLeftLabel() {
        return Labels.NONE;
    }



    @ConfigItem(
            position = 14,
            keyName = "bottomRightLabel",
            name = "Bottom Right Label",
            description = "Default: \"Blank\"",
            section = fontSection
    )
    default Labels bottomRightLabel() {
        return Labels.NONE;
    }



    @ConfigItem(
            position = 15,
            keyName = "fontName",
            name = "Font Name",
            description = "Default: \"Runescape Small\"",
            section = fontSection
    )
    default String fontName() {
        return "Runescape Small";
    }



    @ConfigItem(
            position = 16,
            keyName = "fontSize",
            name = "Font Size",
            description = "Default: 16",
            section = fontSection
    )
    default int fontSize() {
        return 16;
    }



    @ConfigItem(
            position = 17,
            keyName = "fontStyle",
            name = "Font Style",
            description = "Default: Regular",
            section = fontSection
    )
    default FontStyle fontStyle() {
        return FontStyle.REGULAR;
    }



    enum FontStyle {
        REGULAR(0),
        BOLD(1),
        ITALICS(2);

        private final int value;

        FontStyle(int value) {
            this.value = value;
        }

        public int getValue() {
            return value;
        }
    }



    @AllArgsConstructor
    enum Labels {
        PING("Current Ping"),
        LATENCY("Current Latency"),
        PINGMAX("Max Ping Value"),
        PINGMIN("Min Ping Value"),
        TICK("Current Tick"),
        TICKMAX("Max Tick Value"),
        TICKDEV("Tick Deviation"),
        TICKDEVMAX("Max Tick Deviation"),
        FPS("FPS"),
        NONE("Blank");


        private final String name;

        @Override
        public String toString() {
            return name;
        }
    }



    @ConfigItem(
            position = 1,
            keyName = "warnPingVal",
            name = "Ping Threshold (ms)",
            description = "Warns you when the ping exceeds this threshold",
            section = warnSection
    )
    default int warnPingVal() {
        return 100;
    }



    @ConfigItem(
            position = 2,
            keyName = "warnTickVal",
            name = "Tick Threshold (ms)",
            description = "Warns you when the tick exceeds this threshold",
            section = warnSection
    )
    default int warnTickVal() {
        return 800;
    }



    @ConfigItem(
            position = 3,
            keyName = "warnMaxToggle",
            name = "Persisting Warning",
            description = "The warning will persist until the all displayed values are below the warning values",
            section = warnSection
    )
    default boolean warnMaxToggle() {
        return false;
    }



    @ConfigItem(
            position = 4,
            keyName = "warningOverlayToggle",
            name = "Hide Overlay Unless Warning",
            description = "Only shows the overlay if there is a warning",
            section = warnSection
    )
    default boolean warningHideOverlay() {
        return false;
    }



    @ConfigItem(
            position = 5,
            keyName = "warningFontToggle",
            name = "Swap Text Color",
            description = "Change the text color when the Ping/Tick value is too high",
            section = warnSection
    )
    default boolean warningFontToggle() {
        return false;
    }



    @Alpha
    @ConfigItem(
            position = 6,
            keyName = "warningFontColor",
            name = "Text Warn Color",
            description = "The color text will change to while exceeding the threshold",
            section = warnSection
    )
    default Color warningFontColor() {
            return new Color(255, 17, 17, 255);
    }



    @ConfigItem(
            position = 7,
            keyName = "warningLineToggle",
            name = "Swap Graph Line Color",
            description = "Change the Graph Line Color when the Ping/Tick value is too high",
            section = warnSection
    )
    default boolean warningLineToggle() {
        return false;
    }



    @Alpha
    @ConfigItem(
            position = 8,
            keyName = "warningLineColor",
            name = "Graph Line Warn Color",
            description = "The color the Graph Line will change to while exceeding the threshold",
            section = warnSection
    )
    default Color warningLineColor() {
        return new Color(255, 17, 17, 255);
    }



    @ConfigItem(
            position = 9,
            keyName = "warningBGToggle",
            name = "Swap Overlay BG Color",
            description = "Change the Overlays background color when the Ping/Tick value is too high",
            section = warnSection
    )
    default boolean warningOverlayBGToggle() {
        return false;
    }



    @Alpha
    @ConfigItem(
            position = 10,
            keyName = "warningBGColor",
            name = "Overlay BG Warn Color",
            description = "The color the Overlays background will change to while exceeding the threshold",
            section = warnSection
    )
    default Color warningOverlayBGColor() {
        return new Color(255, 30, 30, 64);
    }



    @ConfigItem(
            position = 11,
            keyName = "warnOverlayBorderToggle",
            name = "Swap Overlay Border Color",
            description = "Change the Overlays Border Color when the Ping/Tick value is too high",
            section = warnSection
    )
    default boolean warnOverlayBorderToggle() {
        return false;
    }



    @Alpha
    @ConfigItem(
            position = 12,
            keyName = "warningOverlayBorderColor",
            name = "Overlay Border Warn Color",
            description = "The color the Overlays Border will change to while exceeding the threshold",
            section = warnSection
    )
    default Color warnOverlayBorderColor() {
        return new Color(90, 17, 17, 100);
    }



    @ConfigItem(
            position = 13,
            keyName = "warningGraphBGToggle",
            name = "Swap Graph BG Color",
            description = "Change the Graph background color when the Ping/Tick value is too high",
            section = warnSection
    )
    default boolean warningGraphBGToggle() {
        return false;
    }



    @Alpha
    @ConfigItem(
            position = 14,
            keyName = "warningGraphBGColor",
            name = "Graph BG Warn Color",
            description = "The color the Graph Background will change to while exceeding the threshold",
            section = warnSection
    )
    default Color warningGraphBGColor() {
        return new Color(255, 30, 30, 64);
    }



    @ConfigItem(
            position = 15,
            keyName = "warningGraphBorderToggle",
            name = "Swap Graph Border Color",
            description = "Change the Graph Border Color when the Ping/Tick value is too high",
            section = warnSection
    )
    default boolean warnGraphBorderToggle() {
        return false;
    }



    @Alpha
    @ConfigItem(
            position = 16,
            keyName = "warnGraphBorderColor",
            name = "Graph Border Warn Color",
            description = "The color the Graphs Border will change to while exceeding the threshold",
            section = warnSection
    )
    default Color warnGraphBorderColor() {
        return new Color(90, 17, 17, 100);
    }



    @ConfigItem(
            position = 25,
            keyName = "enablePingSpikes",
            name = "Graph Ping Time Outs",
            description = "Re-enable Spikes on Graph when getting no response",
            warning = "Ping spikes may not accurately reflect your network connection to the world.\n" +
                      "This will reset the current Ping graph!"
    )
    default boolean enablePingSpikes() {
        return false;
    }



    @ConfigItem(
            position = 26,
            keyName = "noResponseLimit",
            name = "Time Out Limit",
            description = "Number of times getting \"Timed Out\" before changing ping label."
    )
    @Range(min = 1, max = 100)
    default int noResponseLimit() {
        return 3;
    }



    @ConfigItem(
            position = 27,
            keyName = "noResponseMsg",
            name = "Timed Out Label",
            description = "Default: \"-\""
    )
    default String noResponseMsg() {
        return "-";
    }



    @ConfigItem(
            position = 28,
            keyName = "simpleLabels",
            name = "Simple Labels",
            description = "Removes extra text in labels, e.g. Ping: and Tick: +/-"
    )
    default boolean simpleLabels() {
        return false;
    }

}

package com.pinggraph;

import com.google.inject.Provides;

import net.runelite.api.Client;
import net.runelite.api.GameState;
import net.runelite.api.events.ClientTick;
import net.runelite.api.events.GameTick;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.game.WorldService;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.plugins.PluginDescriptor;
import net.runelite.client.plugins.worldhopper.ping.Ping;
import net.runelite.client.ui.overlay.OverlayManager;
import net.runelite.http.api.worlds.World;
import net.runelite.http.api.worlds.WorldResult;

import java.util.Date;
import java.util.LinkedList;
import java.util.List;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.ScheduledFuture;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReadWriteLock;
import java.util.concurrent.locks.ReentrantReadWriteLock;
import java.util.function.Supplier;

import javax.inject.Inject;

import lombok.Getter;
import lombok.Setter;
import lombok.extern.slf4j.Slf4j;

@Slf4j
@PluginDescriptor(
    name = "Ping Grapher"
)
public class PingGraphPlugin extends Plugin {
    private final int numCells = 100;
    @Getter
    private final ReadWriteLock pingLock = new ReentrantReadWriteLock();
    @Getter
    private final ReadWriteLock tickLock = new ReentrantReadWriteLock();
    @Getter
    private final LinkedList<Integer> pingList = new LinkedList<>();
    @Getter
    private final LinkedList<Integer> tickTimeList = new LinkedList<>();
    @Inject
    private Client client;
    @Inject
    private PingGraphConfig config;
    @Inject
    private WorldService worldService;
    @Inject
    private OverlayManager overlayManager;
    @Inject
    private PingGraphOverlay pingGraphOverlay;
    private ScheduledFuture<?> currPingFuture;
    @Getter
    private volatile int currentPing = 1;
    @Getter
    private volatile int maxPing = -1;
    @Getter
    private volatile int minPing = Integer.MAX_VALUE;
    @Getter
    private volatile int currentTick = 600;
    @Getter
    private volatile int maxTick = -1;
    @Getter
    private volatile int minTick = Integer.MAX_VALUE;
    @Getter
    private boolean isLagging;
    private long lastTickTime;
    @Setter
    private volatile int graphStart;
    @Getter
    private int noResponseCount;

    private int lastPing = 1;

    private boolean resetGraphToggle = false;

    @Inject
    private ScheduledExecutorService pingExecutorService;

    @Override
    protected void startUp() throws Exception {
        write(pingLock, () -> {
            pingList.clear();
            for (int i = 0; i < numCells; i++) pingList.add(1);
            return null;
        });

        write(tickLock, () -> {
            tickTimeList.clear();
            for (int i = 0; i < numCells; i++) tickTimeList.add(600);
            return null;
        });

        log.info("Ping Graph started!");
        resetGraphToggle = config.enablePingSpikes();
        overlayManager.add(pingGraphOverlay);
        currPingFuture = pingExecutorService.scheduleWithFixedDelay(this::pingCurrentWorld, 1000, 1000, TimeUnit.MILLISECONDS);
    }

    @Override
    protected void shutDown() throws Exception {
        currPingFuture.cancel(true);
        currPingFuture = null;
        overlayManager.remove(pingGraphOverlay);
        write(pingLock, () -> {
            pingList.clear();
            return null;
        });
        write(tickLock, () -> {
            tickTimeList.clear();
            return null;
        });
        log.info("Ping Graph stopped!");
    }

    @Provides
    PingGraphConfig provideConfig(ConfigManager configManager) {
        return configManager.getConfig(PingGraphConfig.class);
    }

    @Subscribe
    public void onGameTick(GameTick tick) {
        long tickTime = new Date().getTime();
        int tickDiff = (int) (tickTime - lastTickTime);
        currentTick = tickDiff;
        write(tickLock, () -> {
            if (tickDiff < 10000) { // should be enough to hide initial tick on startup
                tickTimeList.add(tickDiff);
            } else {
                tickTimeList.add(600);
            }
            return tickTimeList.remove();
        });
        lastTickTime = new Date().getTime();
    }

    @Subscribe
    public void onClientTick(ClientTick tick) {
        long now = new Date().getTime();
        isLagging = (now - lastTickTime) > 700;

        //update Max min values
        int[] temp = read(tickLock, () -> getMaxMinFromList(tickTimeList, graphStart));
        maxTick = temp[0];
        minTick = temp[1];

        temp = read(pingLock, () -> getMaxMinFromList(pingList, graphStart));
        maxPing = temp[0];
        minPing = temp[1];

        if(config.enablePingSpikes() != resetGraphToggle){
            write(pingLock, () -> {
                pingList.clear();
                for (int i = 0; i < numCells; i++) pingList.add(1);
                return null;
            });
            resetGraphToggle = !resetGraphToggle;
        }
    }

    // Code used from runelites worldhopper
    private void pingCurrentWorld() {
        WorldResult worldResult = worldService.getWorlds();
        // There is no reason to ping the current world if not logged in, as the overlay doesn't draw
        if (worldResult == null || client.getGameState() != GameState.LOGGED_IN) return;
        final World currentWorld = worldResult.findWorld(client.getWorld());
        if (currentWorld == null) return;

        lastPing = currentPing;
        currentPing = Ping.ping(currentWorld);

        if(currentPing < 0) {
            noResponseCount++;
            if(config.enablePingSpikes()){
                write(pingLock, () -> {
                    pingList.add(currentPing);
                    return pingList.remove();
                });
            }
            currentPing = lastPing;
        } else {
            noResponseCount = 0;
            write(pingLock, () -> {
                pingList.add(currentPing);
                return pingList.remove(); // remove the first ping
            });
        }

        if (!config.graphTicks()) {
            int[] temp = read(pingLock, () -> getMaxMinFromList(pingList, graphStart));
            maxPing = temp[0];
            minPing = temp[1];
        }
    }

    private static int[] getMaxMinFromList(List<Integer> list, int start) {
        int maxVal = -1;
        int minVal = Integer.MAX_VALUE;

        for (int i = start; i < list.size(); i++) {
            int val = list.get(i);
            if (val > 0) {
                if (maxVal < val)
                    maxVal = val;
                if (minVal > val)
                    minVal = val;
            }
        }
        return new int[] { maxVal, minVal };
    }

    public static <T> T read(ReadWriteLock lock, Supplier<T> supplier) {
        return supplyLocked(lock.readLock(), supplier);
    }

    public static <T> T write(ReadWriteLock lock, Supplier<T> supplier) {
        return supplyLocked(lock.writeLock(), supplier);
    }

    private static <T> T supplyLocked(Lock lock, Supplier<T> supplier) {
        lock.lock();
        try {
            return supplier.get();
        } finally {
            lock.unlock();
        }
    }
}

package com.pinggraph;

import net.runelite.api.Client;
import net.runelite.client.ui.overlay.OverlayLayer;
import net.runelite.client.ui.overlay.OverlayPanel;
import net.runelite.client.ui.overlay.OverlayPosition;
import net.runelite.client.ui.overlay.components.LayoutableRenderableEntity;


import java.awt.*;
import java.util.LinkedList;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReadWriteLock;

import javax.inject.Inject;

import lombok.extern.slf4j.Slf4j;

@Slf4j
public class PingGraphOverlay extends OverlayPanel {

    private final Client client;
    private final PingGraphPlugin pingGraphPlugin;
    private final PingGraphConfig pingGraphConfig;

    public int marginGraphHeight;
    public int marginGraphWidth = 10;
    LayoutableRenderableEntity graphEntity = new LayoutableRenderableEntity() {
        @Override
        public Dimension render(Graphics2D graphics) {
            graphics.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_OFF);

            int tempPing  = pingGraphPlugin.getCurrentPing();
            int tempTick  = pingGraphPlugin.getCurrentTick();
            if(pingGraphConfig.warnMaxToggle()) {
                tempTick  = pingGraphPlugin.getMaxTick();
                tempPing = pingGraphPlugin.getMaxPing();
            }

            boolean warning = (tempPing > pingGraphConfig.warnPingVal() || tempTick > pingGraphConfig.warnTickVal());
            warning = warning || (pingGraphPlugin.getCurrentPing() < 0); //warn if ping timed out

            if(!warning && pingGraphConfig.warningHideOverlay()){
                return new Dimension(0, 0);
            }

            if (pingGraphConfig.toggleBehind()) {
                setLayer(OverlayLayer.ABOVE_SCENE);
            } else {
                setLayer(OverlayLayer.ABOVE_WIDGETS);
            }

            int overlayWidth, overlayHeight;                // width and height of the entire overlay
            try {
                overlayWidth = getPreferredSize().width;
                overlayHeight = getPreferredSize().height;
            } catch (NullPointerException e) {
                overlayWidth = 180;                         // Default settings for first time
                overlayHeight = 60;
                PingGraphOverlay.this.setPreferredSize(new Dimension(overlayWidth, overlayHeight));
            }

            boolean hasBottomLabels = !pingGraphConfig.bottomRightLabel().equals(PingGraphConfig.Labels.NONE) ||
                    !pingGraphConfig.bottomLeftLabel().equals(PingGraphConfig.Labels.NONE);

            boolean hasTopLabels = !pingGraphConfig.rightLabel().equals(PingGraphConfig.Labels.NONE) ||
                    !pingGraphConfig.leftLabel().equals(PingGraphConfig.Labels.NONE);


            marginGraphHeight = pingGraphConfig.fontSize();

            int xOrigin = marginGraphWidth - 1;
            int yOrigin = marginGraphHeight + 1;

            int graphWidth = overlayWidth - marginGraphWidth * 2;
            int graphHeight = overlayHeight - marginGraphHeight * 2;

            if (pingGraphConfig.hideMargin()) {
                graphWidth = overlayWidth;                           // set graph width to whole plugin width
                if (!hasTopLabels) {
                    graphHeight += marginGraphHeight;                // remove the extra height for top and bottom text
                }
                if (!hasBottomLabels){
                    graphHeight += marginGraphHeight;
                }
            }

            if (pingGraphConfig.hideGraph()) {
                graphWidth = 0;
                graphHeight = 0;
                overlayHeight = pingGraphConfig.fontSize();

                if (hasBottomLabels) {
                    overlayHeight += pingGraphConfig.fontSize();
                }
            }

            //background rect
            if (pingGraphConfig.warningOverlayBGToggle() && warning) {
                graphics.setColor(pingGraphConfig.warningOverlayBGColor());
            } else {
                graphics.setColor(pingGraphConfig.overlayBackgroundColor());
            }
            graphics.fillRect(0, 0, overlayWidth, overlayHeight);

            //outside border
            if (pingGraphConfig.warnOverlayBorderToggle() && warning) {
                graphics.setColor(pingGraphConfig.warnOverlayBorderColor());
            } else {
                graphics.setColor(pingGraphConfig.overlayBorderColor());
            }
            graphics.drawRect(0, 0, overlayWidth, overlayHeight);

            if (!pingGraphConfig.toggleLineOnly()) {
                //inside border
                graphics.setColor(pingGraphConfig.graphBorderColor());

                if (pingGraphConfig.warnGraphBorderToggle() && warning) {
                    graphics.setColor(pingGraphConfig.warnGraphBorderColor());
                } else {
                    graphics.setColor(pingGraphConfig.graphBorderColor());
                }

                if(pingGraphConfig.hideMargin()){
                    xOrigin = 0;
                    if(!hasTopLabels)
                        yOrigin = 1;
                }

                graphics.drawRect(xOrigin, yOrigin, graphWidth, graphHeight);


                //inside rect
                if (pingGraphConfig.warningGraphBGToggle() && warning) {
                    graphics.setColor(pingGraphConfig.warningGraphBGColor());
                } else {
                    graphics.setColor(pingGraphConfig.graphBackgroundColor());
                }
                graphics.fillRect(xOrigin, yOrigin, graphWidth, graphHeight);

                //Font Settings
                Color textColor;
                if (pingGraphConfig.warningFontToggle() && warning){
                    textColor = pingGraphConfig.warningFontColor();
                } else {
                    textColor = pingGraphConfig.graphTextColor();
                }
                String fontName = pingGraphConfig.fontName();
                if (pingGraphConfig.fontName().equals("")) {
                    fontName = "Runescape Small";           // Default name if the font name is empty
                }

                Font userFont = new Font(fontName, pingGraphConfig.fontStyle().getValue(), pingGraphConfig.fontSize());

                if (userFont.getFamily().equals("Dialog")) { // Can't find the font, change to default
                    userFont = new Font("Runescape Small", pingGraphConfig.fontStyle().getValue(), pingGraphConfig.fontSize());
                }
                int textMargin = pingGraphConfig.textMargin();
                graphics.setFont(userFont);


                //Right label
                String rightLabel = labelText(pingGraphConfig.rightLabel());
                int strWidth = graphics.getFontMetrics().stringWidth(rightLabel);
                drawlabel(graphics, rightLabel, overlayWidth - strWidth - textMargin, marginGraphHeight - 1, textColor);
                //Left label
                String leftLabel = labelText(pingGraphConfig.leftLabel());
                drawlabel(graphics, leftLabel, textMargin, marginGraphHeight - 1, textColor);

                //Right label
                rightLabel = labelText(pingGraphConfig.bottomRightLabel());
                strWidth = graphics.getFontMetrics().stringWidth(rightLabel);
                drawlabel(graphics, rightLabel, overlayWidth - strWidth - textMargin, overlayHeight, textColor);

                //Left label
                leftLabel = labelText(pingGraphConfig.bottomLeftLabel());
                drawlabel(graphics, leftLabel, textMargin, overlayHeight, textColor);


            } else {
                graphWidth = overlayWidth;
                graphHeight = overlayHeight;
                xOrigin = 0;
                yOrigin = 0;
            }

            LinkedList<Integer> data;
            ReadWriteLock lock;
            if (pingGraphConfig.graphTicks()) {
                data = pingGraphPlugin.getTickTimeList();
                lock = pingGraphPlugin.getTickLock();
            } else {
                data = pingGraphPlugin.getPingList();
                lock = pingGraphPlugin.getPingLock();
            }

            int dataSize = PingGraphPlugin.read(lock, data::size);
            int dataStart = (dataSize > overlayWidth) ? (dataSize - overlayWidth) : 0;
            pingGraphPlugin.setGraphStart(dataStart);

            int maxValue;
            int minValue;
            if (pingGraphConfig.graphTicks()) {
                maxValue = pingGraphPlugin.getMaxTick();
                minValue = pingGraphPlugin.getMinTick();
            } else {
                maxValue = pingGraphPlugin.getMaxPing();
                minValue = pingGraphPlugin.getMinPing();
            }


            // change maxPing to 100, prevents div by 0 in-case of error
            if (maxValue <= 0) {
                maxValue = 100;
            }
            //if checked, the graph will scale between min and max ping
            int tempMax = maxValue;
            if (!pingGraphConfig.toggleRange()) {
                minValue = 0;
                double round = maxValue > 50 ? 50 : 10; // round up to nearest 50 ms if > 50 else 10 ms
                maxValue = (int) (Math.ceil((double) tempMax / round) * round);

                if ((maxValue - tempMax) <= (0.2 * maxValue)) {
                    maxValue += (int) round; // increase the max value to move the graph away from the top
                }
            }


            Color graphColor;
            if (pingGraphConfig.warningLineToggle() && warning){
                graphColor = pingGraphConfig.warningLineColor();
            } else {
                graphColor = pingGraphConfig.graphLineColor();
            }


            if (maxValue == minValue) {
                maxValue++;
                minValue--;
            }
            if (!pingGraphConfig.hideGraph()) {
                Lock l = lock.readLock();
                l.lock();
                try {
                    //drawing line graph
                    drawGraph(graphics, dataStart, data, xOrigin, yOrigin, graphHeight, graphWidth, maxValue, minValue, graphColor);
                } finally {
                    l.unlock();
                }
            }
            return new Dimension(overlayWidth - 8, overlayHeight - 8);
        }

        @Override
        public Rectangle getBounds() {
            return new Rectangle(getPreferredSize().width, getPreferredSize().height);
        }

        @Override
        public void setPreferredLocation(Point position) {
        }

        @Override
        public void setPreferredSize(Dimension dimension) {
        }
    };

    @Inject
    private PingGraphOverlay(Client client, PingGraphPlugin pingGraphPlugin, PingGraphConfig pingGraphConfig) {
        this.client = client;
        this.pingGraphPlugin = pingGraphPlugin;
        this.pingGraphConfig = pingGraphConfig;
        if (getPreferredSize() == null) {
            PingGraphOverlay.this.setPreferredSize(new Dimension(180, 60));
        }
        setPosition(OverlayPosition.TOP_LEFT);
        setMinimumSize(15);
    }

    @Override
    public Dimension render(Graphics2D graphics) {
        panelComponent.render(graphics);
        panelComponent.getChildren().add(graphEntity);
        panelComponent.setBackgroundColor(new Color(0, 0, 0, 0));
        return super.render(graphics);
    }

    // returns a string based on user settings
    private String labelText(PingGraphConfig.Labels setting) {
        String tempLabel = "";
        switch (setting) {
            case LATENCY:
            case PING:
                String labelType = (setting == PingGraphConfig.Labels.LATENCY) ? "Latency:" : "Ping:";
                if(!pingGraphConfig.simpleLabels())
                    tempLabel = labelType;

                tempLabel += pingGraphPlugin.getCurrentPing() + "ms";

                if (pingGraphPlugin.getNoResponseCount() >= pingGraphConfig.noResponseLimit()) {
                    tempLabel = "";
                    if(!pingGraphConfig.simpleLabels())
                        tempLabel = labelType;
                    tempLabel += pingGraphConfig.noResponseMsg();
                }
            break;
            case PINGMAX:
                if(!pingGraphConfig.simpleLabels()) {
                    tempLabel = "Max(P):";
                }
                tempLabel += pingGraphPlugin.getMaxPing() + "ms";
                break;
            case PINGMIN:
                if(!pingGraphConfig.simpleLabels())
                    tempLabel = "Min(P):";
                tempLabel +=  pingGraphPlugin.getMinPing() + "ms";
                break;
            case TICK:
                if(!pingGraphConfig.simpleLabels())
                    tempLabel = "Tick:";
                tempLabel += pingGraphPlugin.getCurrentTick() + "ms";
                break;
            case TICKMAX:
                if(!pingGraphConfig.simpleLabels())
                    tempLabel = "Max(T):";
                tempLabel += pingGraphPlugin.getMaxTick() + "ms";
                break;
            case TICKDEV:
                if(!pingGraphConfig.simpleLabels())
                    tempLabel = "Tick: +/-";
                tempLabel += (Math.abs(pingGraphPlugin.getCurrentTick() - 600)) + "ms";
                break;
            case TICKDEVMAX:
                if(!pingGraphConfig.simpleLabels())
                    tempLabel = "Max(T): +/-";
                tempLabel += (Math.abs(pingGraphPlugin.getMaxTick() - 600)) + "ms";
                break;
            case FPS:
                tempLabel += client.getFPS() + " FPS";
                break;
            case NONE:
                tempLabel = "";
                break;
        }
        return tempLabel;
    }

    private void drawGraph(Graphics2D graphics, int dataStart, LinkedList<Integer> data,int xOrigin, int yOrigin, int height, int width, int maxValue, int minValue, Color lineColor){
        //drawing line graph
        int tempX;
        graphics.setColor(lineColor);

        int oldX, oldY = oldX = -1;

        for (int x = dataStart; x < data.size(); x++) {
            int y = data.get(x);
            y = y < 0 ? maxValue : y; // change a "timed out" to spike rather than drop

            //((limitMax - limitMin) * (valueIn - baseMin) / (baseMax - baseMin)) + limitMin;
            //scale the x and y values to fit to the plugin
            y = height - (height * (y - minValue) / (maxValue - minValue) - yOrigin);
            tempX = ((width - 1) * (x - dataStart) / (data.size() - dataStart - 1));

            if (!pingGraphConfig.hideMargin()) {
                tempX += marginGraphWidth;
            }

            if (pingGraphConfig.toggleLineOnly()) {
                if (!pingGraphConfig.hideMargin())
                    tempX -= marginGraphWidth;
            }

            if (oldX != -1 && y >= 0) {
                graphics.drawLine(oldX, oldY, tempX, y);
            }

            oldX = tempX;
            oldY = y;
        }
    }


    private void drawlabel(Graphics2D graphics, String text, int x, int y, Color color){
        //draw text shadow
        graphics.setColor(new Color(0,0,0,color.getAlpha()));
        graphics.drawString(text, x + 1, y + 1);

        //draw actual text
        graphics.setColor(color);
        graphics.drawString(text, x, y);
    }



}

package com.pinggraph;

import net.runelite.client.RuneLite;
import net.runelite.client.externalplugins.ExternalPluginManager;

public class PingGraphPluginTest
{
	public static void main(String[] args) throws Exception
	{
		ExternalPluginManager.loadBuiltin(PingGraphPlugin.class);
		RuneLite.main(args);
	}
}

