package com.twitchliveloadout.skills;

import com.twitchliveloadout.twitch.TwitchState;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;

@Slf4j
public class SkillStateManager {
	private final TwitchState twitchState;
	private final Client client;

	public SkillStateManager(TwitchState twitchState, Client client)
	{
		this.twitchState = twitchState;
		this.client = client;
	}

	public void updateSkills()
	{
		try {
			final int[] skillExperiences = client.getSkillExperiences();
			final int[] boostedSkillLevels = client.getBoostedSkillLevels();

			twitchState.setSkillExperiences(skillExperiences);
			twitchState.setBoostedSkillLevels(boostedSkillLevels);
		} catch (Exception exception) {
			log.warn("An error occurred when updating skills: ", exception);
		}
	}
}

package com.twitchliveloadout.quests;

import com.google.gson.JsonArray;
import com.twitchliveloadout.TwitchLiveLoadoutPlugin;
import com.twitchliveloadout.twitch.TwitchState;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.widgets.Widget;

@Slf4j
public class QuestManager {
	private static final int QUEST_LIST_GROUP_ID = 399;
	private static final int QUEST_LIST_CHILD_ID = 7;

	private static final int CATEGORY_QUEST_TEXT_COLOR = 16750623; // free / member / mini quests title
	private static final int INVALID_QUEST_TEXT_COLOR = 0; // recipe for disaster subquests

	private final TwitchLiveLoadoutPlugin plugin;
	private final TwitchState twitchState;
	private final Client client;

	public QuestManager(TwitchLiveLoadoutPlugin plugin, TwitchState twitchState, Client client)
	{
		this.plugin = plugin;
		this.twitchState = twitchState;
		this.client = client;
	}

	public void updateQuests()
	{
		Widget questListWidget = client.getWidget(QUEST_LIST_GROUP_ID, QUEST_LIST_CHILD_ID);
		JsonArray questsState = new JsonArray();

		// guard: check if the quest list is valid
		if (questListWidget == null)
		{
			return;
		}

		for (Widget questWidget : questListWidget.getDynamicChildren())
		{
			String text = questWidget.getText();
			int textColor = questWidget.getTextColor();
			JsonArray questEntryState = new JsonArray();

			// guard: skip invalid text colors
			if (textColor == CATEGORY_QUEST_TEXT_COLOR || textColor == INVALID_QUEST_TEXT_COLOR)
			{
				continue;
			}

			// add the color directly because we GZIP it anyways
			// so it will become more efficient in terms of transfer
			// the reason why we do this is because you can customize the text colors
			// in the settings, so it is hard to predict what the status is
			questEntryState.add(text);
			questEntryState.add(textColor);
			questsState.add(questEntryState);
		}

		twitchState.setQuests(questsState);
	}
}

package com.twitchliveloadout.marketplace.products;

public class EbsEquipmentFrame extends EbsEffectFrame {
	public Integer npcId = -1;
	public Integer head = -1;
	public Integer cape = -1;
	public Integer amulet = -1;
	public Integer weapon = -1;
	public Integer torso = -1;
	public Integer shield = -1;
	public Integer arms = -1;
	public Integer legs = -1;
	public Integer hair = -1;
	public Integer hands = -1;
	public Integer boots = -1;
	public Integer jaw = -1;

	public Integer getEquipmentIdBySlotId(int slotId)
	{
		switch (slotId) {
			case 0: return head;
			case 1: return cape;
			case 2: return amulet;
			case 3: return weapon;
			case 4: return torso;
			case 5: return shield;
			case 6: return arms;
			case 7: return legs;
			case 8: return hair;
			case 9: return hands;
			case 10: return boots;
			case 11: return jaw;
		}

		return -1;
	}
}

package com.twitchliveloadout.marketplace.products;

import java.util.ArrayList;

public class EbsBehaviour {
	public ArrayList<ArrayList<EbsEffect>> startEffectsOptions;
	public ArrayList<ArrayList<EbsEffect>> stopEffectsOptions;
	public EbsInterval effectsInterval;
	public ArrayList<ArrayList<EbsEffect>> effectsOptions;
	public ArrayList<EbsSpawnOption> startSpawnOptions;
	public EbsInterval spawnInterval;
	public ArrayList<EbsSpawnOption> spawnOptions;
	public EbsModelPlacement requiredModelPlacement;
}

package com.twitchliveloadout.marketplace.products;

public class EbsModelOverheadFrame extends EbsEffectFrame {
	public String text;
	public Integer textHeight = 230;
	public Integer textColorHex = 0xffff00; // yellow
}

package com.twitchliveloadout.marketplace.products;

import java.util.ArrayList;

public class EbsProjectileFrame extends EbsEffectFrame {
	public String startLocationType;
	public String endLocationType;
	public EbsProjectileFrameLocation startLocation;
	public EbsProjectileFrameLocation endLocation;
	public Boolean followEndLocation = true;
	public EbsRandomRange startLocationRadiusRange;
	public EbsRandomRange endLocationRadiusRange;
	public ArrayList<EbsSpawnOption> startSpawnOptions;
	public ArrayList<EbsSpawnOption> endSpawnOptions;
	public Boolean inLineOfSight = false;
	public Boolean avoidExistingSpawns = false;
	public Boolean avoidPlayerLocation = false;
	public Boolean avoidInvalidOverlay = true;

	// defaults are based on cannonballs
	public Integer startZ = -170;
	public Integer slope = 2;
	public Integer startHeight = 11;
	public Integer endHeight = 140;
}

package com.twitchliveloadout.marketplace.products;

public class TwitchProduct {
	public String sku;
	public String domain;
	public TwitchProductCost cost;
	public Boolean inDevelopment = false;
	public String displayName;
	public String expiration;
	public Boolean broadcast = false;
}

package com.twitchliveloadout.marketplace.products;

import java.util.ArrayList;

import static com.twitchliveloadout.marketplace.MarketplaceConstants.*;

public class EbsCondition {
	public Integer varbitId = -1;
	public Integer varbitValue = -1;
	public Integer minTimeMs = 0;
	public Integer maxTimeMs = Integer.MAX_VALUE;
	public Double minTimePercentage = 0d;
	public Double maxTimePercentage = 1d;
	public Integer maxSpawnsInView = -1;
	public Integer maxSpawnsInViewRadius = CHUNK_SIZE;
	public Integer minSpawnsInView = -1;
	public Integer minSpawnsInViewRadius = CHUNK_SIZE;
	public Integer spawnInViewRadius = -1;
	public String stateType = PRODUCT_STATE_TYPE;
	public String stateFormat = STRING_STATE_FORMAT;
	public String stateComparator = EQUAL_STATE_COMPARISON;
	public String stateKey = null;
	public String stateValue = null;
	public Double chance = 1d;
	public String combatStyle = null;
	public Integer regionId = null;
	public Integer genderId = null;
	public ArrayList<EbsCondition> or;
	public ArrayList<EbsCondition> and;
	public ArrayList<EbsCondition> not;
}

package com.twitchliveloadout.marketplace.products;

public class EbsSoundEffectFrame extends EbsEffectFrame {

}

package com.twitchliveloadout.marketplace.products;

import static com.twitchliveloadout.marketplace.MarketplaceConstants.*;

public class EbsStateFrame {
	public String type = PRODUCT_STATE_TYPE;
	public String format = STRING_STATE_FORMAT;
	public String operation = SET_STATE_OPERATION;
	public String key;
	public String value = null;
	public Integer delayMs = 0;
}

package com.twitchliveloadout.marketplace.products;

import java.util.ArrayList;

public class EbsModelSet {
	public ArrayList<Integer> ids;
	public EbsRandomRange scale;
	public Integer scalePerOneTile;
	public ArrayList<EbsRecolor> recolors;
	public EbsTranslation translation;
	public ArrayList<EbsMenuEntry> menuEntries;
}

package com.twitchliveloadout.marketplace.products;

import java.util.ArrayList;

public class EbsEffect {
	public ArrayList<EbsCondition> conditions;
	public Boolean blockingConditions = false; // TMP: for backwards compatibility, remove after full update
	public Boolean breakOnInvalidConditions = false;
	public Boolean breakOnValidConditions = false;
	public EbsRandomRange durationMs;
	public ArrayList<EbsSpawnOption> spawnOptions;
	public Boolean modelExpired = false;
	public Boolean productExpired = false;
	public EbsAnimationFrame modelAnimation;
	public EbsModelOverheadFrame modelOverhead;
	public EbsModelSet modelSet;
	public EbsAnimationFrame playerAnimation;
	public EbsMovementFrame playerMovement;
	public EbsGraphicFrame playerGraphic;
	public EbsEquipmentFrame playerEquipment;
	public ArrayList<EbsMenuOptionFrame> menuOptions;
	public ArrayList<EbsInterfaceWidgetFrame> interfaceWidgets;
	public EbsDrawFrame drawEffect;
	public EbsSoundEffectFrame soundEffect;
	public EbsStateFrame stateChange;
	public ArrayList<EbsNotification> notifications;
	public ArrayList<EbsProjectileFrame> projectiles;
	public ArrayList<ArrayList<EbsEffect>> effectsOptions;
}

package com.twitchliveloadout.marketplace.products;

public class EbsEffectFrame {
	public Integer id = -1;
	public Integer durationMs = -1;
	public Double durationPercentage = -1d;
	public EbsRandomRange delayMs;
}

package com.twitchliveloadout.marketplace.products;

public class EbsDrawFrame extends EbsEffectFrame {
    public Boolean hideOthers = false;
    public Boolean hideOthers2D = false;
    public Boolean hideLocalPlayer = false;
    public Boolean hideLocalPlayer2D = false;
    public Boolean hideNPCs = false;
    public Boolean hideNPCs2D = false;
    public Boolean hideProjectiles = false;
}

package com.twitchliveloadout.marketplace.products;

public class EbsTranslation {
	public EbsRandomRange x;
	public EbsRandomRange y;
	public EbsRandomRange z;
}

package com.twitchliveloadout.marketplace.products;

import java.util.ArrayList;

public class EbsInterval {
	public Double chance = 1.0d;
	public Integer delayMs = 0;
	public Integer afterTriggerDelayMs = 0;
	public Integer repeatAmount = -1; // infinite by default
	public Boolean triggerOnStart = false;
	public Integer startDelayMs = 0;
	public ArrayList<EbsCondition> conditions;
}

package com.twitchliveloadout.marketplace.products;

public class EbsAnimationFrame extends EbsEffectFrame {
	Boolean shouldLoop = true;
}

package com.twitchliveloadout.marketplace.products;

import java.util.ArrayList;

import static com.twitchliveloadout.marketplace.MarketplaceConstants.INDIVIDUAL_SPAWN_POINT_TYPE;

public class EbsSpawnOption {
	public Double chance;
	public ArrayList<EbsCondition> conditions;
	public EbsRandomRange spawnAmount;
	public EbsRandomRange spawnDelayMs;
	public ArrayList<EbsSpawn> spawns;
	public String spawnPointType = INDIVIDUAL_SPAWN_POINT_TYPE;
}

package com.twitchliveloadout.marketplace.products;

import com.twitchliveloadout.marketplace.LambdaIterator;
import com.twitchliveloadout.marketplace.MarketplaceEffect;
import com.twitchliveloadout.marketplace.draws.DrawManager;
import com.twitchliveloadout.marketplace.interfaces.MenuManager;
import com.twitchliveloadout.marketplace.interfaces.WidgetManager;
import com.twitchliveloadout.marketplace.spawns.SpawnOverheadManager;
import com.twitchliveloadout.marketplace.transactions.TwitchTransaction;
import com.twitchliveloadout.marketplace.MarketplaceRandomizers;
import com.twitchliveloadout.marketplace.MarketplaceManager;
import com.twitchliveloadout.marketplace.animations.AnimationManager;
import com.twitchliveloadout.marketplace.spawns.SpawnPoint;
import com.twitchliveloadout.marketplace.spawns.SpawnedObject;
import com.twitchliveloadout.marketplace.spawns.SpawnManager;
import com.twitchliveloadout.marketplace.transmogs.TransmogManager;
import lombok.Getter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.*;
import net.runelite.api.coords.LocalPoint;
import net.runelite.api.coords.WorldPoint;

import javax.annotation.Nullable;
import java.time.Duration;
import java.time.Instant;
import java.util.*;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.CopyOnWriteArrayList;
import java.util.concurrent.atomic.AtomicInteger;

import static com.twitchliveloadout.marketplace.MarketplaceConstants.*;

@Slf4j
public class MarketplaceProduct
{

	/**
	 * The Marketplace manager
	 */
	private final MarketplaceManager manager;

	/**
	 * The Twitch transaction attributed to this product
	 */
	@Getter
	private final TwitchTransaction transaction;

	/**
	 * The Twitch transaction attributed to this product
	 */
	@Getter
	private final EbsProduct ebsProduct;

	/**
	 * The Twitch transaction attributed to this product
	 */
	@Getter
	private final StreamerProduct streamerProduct;

	/**
	 * The Twitch product attributed to this product
	 */
	@Getter
	private final TwitchProduct twitchProduct;

	/**
	 * Current status
	 */
	@Getter
	private boolean isActive = false;
	@Getter
	private boolean isPaused = false;

	/**
	 * Long-term interval trackers
	 */
	private Instant lastSpawnBehaviourAt;
	private int spawnBehaviourCounter = 0;
	private Instant lastEffectBehaviourAt;
	private int effectBehaviourCounter = 0;

	/**
	 * Expiration trackers
	 */
	@Getter
	private final Instant startedAt;
	@Getter
	private Instant expiredAt;
	@Getter
	private final Instant loadedAt;
	@Getter
	private final Instant transactionAt;

	/**
	 * A list of all the spawned objects for this product
	 */
	@Getter
	private final CopyOnWriteArrayList<SpawnedObject> spawnedObjects = new CopyOnWriteArrayList<>();
	@Getter
	private int spawnAmount = 0;

	/**
	 * Lookup table with the current key value pairs of the state frames to assign state values to this product
	 * which are to be used in conditions to check whether certain effects are allowed to be executed.
	 * This very simple mechanism makes the MarketplaceProduct and SpawnedObject stateful where logic can be based on.
	 */
	private final ConcurrentHashMap<String, String> stateFrameValues = new ConcurrentHashMap<>();

	public MarketplaceProduct(MarketplaceManager manager, TwitchTransaction transaction, EbsProduct ebsProduct, StreamerProduct streamerProduct, TwitchProduct twitchProduct)
	{
		this.manager = manager;
		this.transaction = transaction;
		this.ebsProduct = ebsProduct;
		this.streamerProduct = streamerProduct;
		this.twitchProduct = twitchProduct;

		// determine when this product should expire which is
		// based on the moment the transaction is executed with a correction
		// added along with the actual duration. A correction is added because
		// it takes a few seconds before the transaction is added.
		int duration = streamerProduct.duration;
		this.loadedAt = Instant.now();
		this.transactionAt = Instant.parse(transaction.timestamp);

		// Check when the transaction was loaded in and if it was loaded too late
		// compared to when the transaction was made. With this mechanism we still allow
		// queued transactions to be handled while a streamer is logged out for 30 seconds while keeping RL open.
		// but we will not handle transactions that RL will load when booting up without any in the queue.
		// Finally, this allows transactions that might've been missed to be handled properly (e.g. after an EBS crash)
		int transactionExpiryToleranceS = 5 * 60;
		Instant transactionExpiredAt = transactionAt.plusSeconds(duration + transactionExpiryToleranceS);
		Instant transactionLoadedAt = Instant.parse(transaction.loaded_at);
		boolean loadedTooLate = transactionLoadedAt.isAfter(transactionExpiredAt);

		this.startedAt = (!loadedTooLate && manager.getConfig().marketplaceStartOnLoadedAt() ? loadedAt : transactionAt);
		this.expiredAt = startedAt.plusSeconds(duration).plusMillis(TRANSACTION_DELAY_CORRECTION_MS);
	}

	public void handleBehaviour()
	{

		// guard: make sure the EBS product is active and valid
		if (!isActive || ebsProduct == null)
		{
			return;
		}

		handleNewEffects();
		handleNewSpawns();
		handleSpawnLocations();
		handleSpawnRandomEffects();
	}

	public void start()
	{
		play();
		triggerEffectsOptions(
			ebsProduct.behaviour.startEffectsOptions,
			null,
			0
		);
	}

	public void play()
	{
		// guard: skip when already active
		if (isActive)
		{
			return;
		}

		isPaused = false;
		isActive = true;

		handleSpawnedObjects(spawnedObjects, 0, SpawnedObject::show);
	}

	public void pause()
	{

		// guard: skip when already inactive
		if (!isActive)
		{
			return;
		}

		isPaused = true;
		isActive = false;

		handleSpawnedObjects(spawnedObjects, 0, SpawnedObject::hide);
	}

	public void stop(boolean force)
	{
		// guard: skip if already stopped
		if (!isActive && !isPaused && !force)
		{
			return;
		}

		// do this before setting active to FALSE, otherwise some effects are skipped
		if (!force)
		{
			triggerEffectsOptions(
				ebsProduct.behaviour.stopEffectsOptions,
				null,
				0
			);
		}

		// start with disabling all behaviours
		isPaused = false;
		isActive = false;

		// force the expiry when not expired yet
		// this allows us to prematurely clean up this product
		if (!isExpired())
		{
			expiredAt = Instant.now();
		}

		// clean up all the spawned objects
		handleSpawnedObjects(spawnedObjects, 0, (spawnedObject) -> {

			// when forced hide instantly, otherwise trigger the hide effects
			if (force) {
				spawnedObject.hide();
			} else {
				hideSpawnedObject(spawnedObject, 0);
			}

			manager.getSpawnManager().deregisterSpawnedObjectPlacement(spawnedObject);
		});
		spawnedObjects.clear();
	}

	/**
	 * Spawns of this product can expire by itself as well, without the whole product
	 * being expired. This handled removing those expired spawns while the product is active
	 */
	public void cleanExpiredSpawnedObjects()
	{
		handleSpawnedObjects(spawnedObjects, 0, (spawnedObject) -> {

			// guard: check if the spawned object is not expired yet
			if (!spawnedObject.isExpired())
			{
				return;
			}

			// hide and free up the spawn point for future spawns
			hideSpawnedObject(spawnedObject, 0);
			manager.getSpawnManager().deregisterSpawnedObjectPlacement(spawnedObject);
			spawnedObjects.remove(spawnedObject);
		});
	}

	public boolean isExpired(int nowDeltaMs)
	{
		return expiredAt == null || Instant.now().plusMillis(nowDeltaMs).isAfter(expiredAt);
	}

	public boolean isExpired()
	{
		return isExpired(0);
	}

	public long getExpiresInMs()
	{
		return expiredAt.toEpochMilli() - Instant.now().toEpochMilli();
	}

	public void handleSpawnRotations()
	{

		// guard: make sure the product is active
		if (!isActive)
		{
			return;
		}

		Iterator<SpawnedObject> spawnedObjectIterator = spawnedObjects.iterator();

		while (spawnedObjectIterator.hasNext())
		{
			SpawnedObject spawnedObject = spawnedObjectIterator.next();
			EbsModelPlacement modelPlacement = spawnedObject.getSpawn().modelPlacement;
			String rotationType = modelPlacement.rotationType;
			Player player = manager.getClient().getLocalPlayer();

			// guard: make sure the rotation and player are valid
			if (rotationType == null || player == null)
			{
				continue;
			}

			Actor interacting = player.getInteracting();

			switch (rotationType)
			{
				case PLAYER_ROTATION_TYPE:
					LocalPoint playerLocalLocation = player.getLocalLocation();
					spawnedObject.rotateTowards(playerLocalLocation);
					break;
				case MIRROR_PLAYER_ROTATION_TYPE:
					spawnedObject.setOrientation(player.getCurrentOrientation());
					break;
				case INTERACTING_ROTATION_TYPE:
					if (interacting == null)
					{
						continue;
					}

					LocalPoint interactingLocalLocation = interacting.getLocalLocation();
					spawnedObject.rotateTowards(interactingLocalLocation);
					break;
				case MIRROR_INTERACTING_ROTATION_TYPE:
					if (interacting == null)
					{
						continue;
					}

					spawnedObject.setOrientation(interacting.getCurrentOrientation());
					break;
			}
		}
	}

	private void handleSpawnLocations()
	{
		SpawnManager spawnManager = manager.getSpawnManager();
		Iterator<SpawnedObject> spawnedObjectIterator = spawnedObjects.iterator();

		// lookup table to change the spawn points consistently across objects
		// this is needed, because we want objects that are on the same location
		// to move to the new same location
		HashMap<WorldPoint, SpawnPoint> newSpawnPoints = new HashMap<>();

		while (spawnedObjectIterator.hasNext())
		{
			SpawnedObject spawnedObject = spawnedObjectIterator.next();
			EbsSpawn spawn = spawnedObject.getSpawn();
			WorldPoint worldPoint = spawnedObject.getSpawnPoint().getWorldPoint();

			if (spawn == null)
			{
				continue;
			}

			EbsModelPlacement modelRespawnPlacement = spawn.modelRespawnPlacement;
			EbsModelPlacement modelPlacement = spawn.modelPlacement;

			// override the model placement with a respawn model placement when set
			// this allows us to have different behaviours for the initial spawn placement
			// and the placement and follow behaviour afterwards
			if (modelRespawnPlacement != null)
			{
				modelPlacement = modelRespawnPlacement;
			}

			// make sure the selected model placement is always valid
			if (modelPlacement == null)
			{
				modelPlacement = new EbsModelPlacement();
			}

			String followType = modelPlacement.followType;
			ArrayList<EbsCondition> followConditions = modelPlacement.followConditions;
			String validFollowType = (followType == null ? NONE_FOLLOW_TYPE : followType);
			EbsRandomRange radiusRange = modelPlacement.radiusRange;
			int followRadius = DEFAULT_MAX_RADIUS;

			// override the follow radius with a set oe or the max in the radius range
			if (modelPlacement.followRadius != null) {
				followRadius = modelPlacement.followRadius;
			} else if (radiusRange != null && radiusRange.max != null) {
				followRadius = radiusRange.max.intValue();
			}

			// guard: skip when no follow type
			if (validFollowType.equals(NONE_FOLLOW_TYPE))
			{
				continue;
			}

			// guard: check if we can execute the follow behaviour according to its conditions
			if (!verifyConditions(followConditions, spawnedObject))
			{
				continue;
			}

			// this follow type makes sure that the spawned object is always in view
			if (validFollowType.equals(IN_RADIUS_FOLLOW_TYPE)) {

				// guard: skip this behaviour if it is already in the scene
				if (spawnedObject.isInView(followRadius))
				{
					continue;
				}

				// use lookup to get new spawn point candidate
				SpawnPoint newInSceneSpawnPoint = null;

				// the same new location should be used when moving form the same tile
				// for this reason we have a lookup so that objects placed on the same tile
				// move the the same new tile
				if (newSpawnPoints.containsKey(worldPoint)) {
					newInSceneSpawnPoint = newSpawnPoints.get(worldPoint);
				} else {
					WorldPoint modelWorldPoint = spawnedObject.getSpawnPoint().getWorldPoint();
					newInSceneSpawnPoint = spawnManager.getSpawnPoint(modelPlacement, modelWorldPoint);
					newSpawnPoints.put(worldPoint, newInSceneSpawnPoint);
				}

				// guard: skip if no new spawn point could be found
				if (newInSceneSpawnPoint == null)
				{
					continue;
				}

				// move to the the in scene location and make sure the tile registration is updated
				spawnManager.moveSpawnedObject(spawnedObject, newInSceneSpawnPoint);
			}

			// this follow type moves the spawned object to be on the previous location of the player
			if (validFollowType.equals(PREVIOUS_TILE_FOLLOW_TYPE))
			{
				WorldPoint previousPlayerWorldPoint = spawnManager.getPreviousPlayerLocation();

				// guard: skip when already on the previous player location
				if (worldPoint.equals(previousPlayerWorldPoint))
				{
					continue;
				}

				// create a new spawn point without checking the already taken locations
				// TODO: check if this is what we really want as behaviour
				SpawnPoint previousPlayerSpawnPoint = new SpawnPoint(previousPlayerWorldPoint);

				// move to the previous player tile to follow and make sure the tile registration is updated
				spawnManager.moveSpawnedObject(spawnedObject, previousPlayerSpawnPoint);
			}
		}
	}

	private void handleSpawnRandomEffects()
	{

		// guard: don't trigger effects when the product has gone active
		// this for example makes sure the hideEffect is not interrupted by the random ones
		if (!isActive)
		{
			return;
		}

		Instant now = Instant.now();
		Iterator<SpawnedObject> spawnedObjectIterator = spawnedObjects.iterator();

		while (spawnedObjectIterator.hasNext())
		{
			SpawnedObject spawnedObject = spawnedObjectIterator.next();
			Instant spawnedAt = spawnedObject.getSpawnedAt();
			Instant lastRandomEffectAt = spawnedObject.getLastRandomEffectAt();
			int randomEffectCounter = spawnedObject.getRandomEffectCounter();
			EbsSpawn spawn = spawnedObject.getSpawn();
			EbsInterval randomInterval = spawn.randomEffectsInterval;
			ArrayList<ArrayList<EbsEffect>> randomEffectsOptions = spawn.randomEffectsOptions;

			// guard: make sure there is a valid interval and animation
			if (randomInterval == null || randomEffectsOptions == null || randomEffectsOptions.size() <= 0)
			{
				continue;
			}

			Boolean triggerOnStart = randomInterval.triggerOnStart;
			Double chance = randomInterval.chance;
			ArrayList<EbsCondition> conditions = randomInterval.conditions;

			// guard: check whether the interval is allowed
			if (!verifyIntervalDelay(randomInterval, lastRandomEffectAt, spawnedAt, randomEffectCounter)) {
				continue;
			}

			// guard: skip when this spawned object is not in the region,
			// because this can feel random when graphics/animations are triggered
			// without the spawned object in view
			if (!spawnedObject.isInRegion())
			{
				continue;
			}

			// guard: make sure the conditions are met
			if (!verifyConditions(conditions, spawnedObject))
			{
				continue;
			}

			// guard: skip this effect when not rolled, while setting the timer before this roll
			if (!MarketplaceRandomizers.rollChance(chance))
			{
				// we will allow effects that are to be triggered on spawn
				if (lastRandomEffectAt != null || !triggerOnStart)
				{
					continue;
				}
			}

			// select a random entry from all the candidates
			ArrayList<EbsEffect> randomEffects = MarketplaceRandomizers.getRandomEntryFromList(randomEffectsOptions);

			// trigger the animations on this single spawned object
			triggerEffects(
				randomEffects,
				0,
				spawnedObject,
				null,
				false,
				null
			);

			// increase the counter that will be used to check if the max repeat count is reached
			spawnedObject.registerRandomEffect();
		}
	}

	private void handleNewEffects()
	{
		EbsBehaviour behaviour = ebsProduct.behaviour;
		ArrayList<ArrayList<EbsEffect>> effectOptions = behaviour.effectsOptions;

		// guard: check if there are any effect options
		if (effectOptions == null)
		{
			return;
		}

		String transactionId = transaction.id;
		String productId = ebsProduct.id;
		EbsInterval effectsInterval = behaviour.effectsInterval;

		// make sure the behaviour interval is valid
		if (effectsInterval == null)
		{
			effectsInterval = new EbsInterval();

			// when the spawn interval is not set it can only trigger once
			// this makes the most sense in the JSON configuration of the product
			// if no interval is set -> no repetition
			effectsInterval.repeatAmount = 1;
		}

		ArrayList<EbsCondition> conditions = effectsInterval.conditions;
		int afterTriggerDelayMs = effectsInterval.afterTriggerDelayMs;

		// guard: check whether the interval is allowed
		if (!verifyIntervalDelay(effectsInterval, lastEffectBehaviourAt, startedAt, effectBehaviourCounter)) {
			return;
		}

		// guard: check if the interval is allowed to be triggered based on the conditions
		if (!verifyConditions(conditions))
		{

			// when the conditions are not verified we will set the last behaviour at to prevent the effects
			// to be check too many times in a row, this gives some throttling in some possible heavy checks
			lastEffectBehaviourAt = Instant.now();
			return;
		}

		// select a random option
		ArrayList<EbsEffect> effectsOption = MarketplaceRandomizers.getRandomEntryFromList(effectOptions);

		// guard: check if a valid option was selected
		if (effectsOption == null)
		{
			log.warn("Could not find valid effect behaviour option for product ("+ productId +")");
			return;
		}

//		log.warn("Executing effect behaviours for product ("+ productId +") and transaction ("+ transactionId +")");
		lastEffectBehaviourAt = Instant.now().plusMillis(afterTriggerDelayMs);
		effectBehaviourCounter += 1;

		triggerEffects(
			effectsOption,
			0,
			null,
			null,
			false,
			null
		);
	}

	private void handleNewSpawns()
	{
		Instant now = Instant.now();
		EbsBehaviour behaviour = ebsProduct.behaviour;
		ArrayList<EbsSpawnOption> startSpawnOptions = behaviour.startSpawnOptions;
		ArrayList<EbsSpawnOption> spawnOptions = behaviour.spawnOptions;
		EbsInterval spawnInterval = behaviour.spawnInterval;
		boolean hasSpawnedAtLeastOnce = (lastSpawnBehaviourAt != null);

		// override the spawn options with the initial ones when they are valid
		// and the first spawn still needs to happen
		if (!hasSpawnedAtLeastOnce && startSpawnOptions != null)
		{
			spawnOptions = startSpawnOptions;
		}

		// guard: check if objects need to be spawned
		if (spawnOptions == null)
		{
			return;
		}

		// make sure the behaviour interval is valid
		if (spawnInterval == null)
		{
			spawnInterval = new EbsInterval();

			// when the spawn interval is not set it can only trigger once
			// this makes the most sense in the JSON configuration of the product
			// if no interval is set -> no repetition
			spawnInterval.repeatAmount = 1;
		}

		int afterTriggerDelayMs = spawnInterval.afterTriggerDelayMs;
		ArrayList<EbsCondition> conditions = spawnInterval.conditions;

		// guard: check whether the interval is allowed
		if (!verifyIntervalDelay(spawnInterval, lastSpawnBehaviourAt, startedAt, spawnBehaviourCounter)) {
			return;
		}

		// guard: check if the conditions are met
		if (!verifyConditions(conditions))
		{
			return;
		}

		// update timer and count and add extra time requested to delay the effect after a successful trigger
		lastSpawnBehaviourAt = now.plusMillis(afterTriggerDelayMs);
		spawnBehaviourCounter += 1;

		triggerSpawnOptions(null, spawnOptions);
	}

	private void triggerSpawnOptions(SpawnedObject spawnedObject, ArrayList<EbsSpawnOption> spawnOptions)
	{
		WorldPoint worldPoint = null;

		if (spawnedObject !=  null) {
			worldPoint = spawnedObject.getSpawnPoint().getWorldPoint();
		}

		triggerSpawnOptionsAtWorldPoint(worldPoint, spawnOptions);
	}

	private void triggerSpawnOptionsAtWorldPoint(WorldPoint modelWorldPoint, ArrayList<EbsSpawnOption> spawnOptions)
	{

		// guard: make sure the spawn options are valid
		if (spawnOptions == null || spawnOptions.size() <= 0)
		{
			return;
		}

		SpawnManager spawnManager = manager.getSpawnManager();
		String transactionId = transaction.id;
		String productId = ebsProduct.id;
		EbsSpawnOption spawnOption = MarketplaceRandomizers.getSpawnBehaviourByChance(spawnOptions);

		// guard: check if a valid option was selected
		if (spawnOption == null)
		{
			log.warn("Could not find valid spawn behaviour option for product ("+ productId +")");
			return;
		}

		// randomize the amount of spawns
		int spawnGroupAmount = (int) MarketplaceRandomizers.getValidRandomNumberByRange(spawnOption.spawnAmount, 1, 1, 0, MAX_SPAWN_AMOUNT);
		ArrayList<EbsSpawn> spawns = spawnOption.spawns;
		String spawnPointType = spawnOption.spawnPointType;

		// multiply the spawn amount when chaos mode is activate
		if (manager.isChaosModeActive())
		{
			spawnGroupAmount *= manager.getConfig().chaosModeSpawnMultiplier();
		}

		// guard: make sure the spawn behaviours are valid
		if (spawns == null)
		{
			log.warn("Could not find valid spawn behaviours for product ("+ productId +")");
			return;
		}

		// valid option is found
		log.debug("Executing spawn behaviours for product ("+ productId +") and transaction ("+ transactionId +")");

		// guard: check if the conditions are satisfied
		// NOTE: this should happen after the timer is being set!
		if (!verifyConditions(spawnOption.conditions, null))
		{
			return;
		}

		// make sure spawning is on client thread for e.g. using client instance
		int finalSpawnGroupAmount = spawnGroupAmount;
		manager.getPlugin().runOnClientThread(() -> {

			// execute the spawn for the requested amount of times along with all spawn behaviours
			for (int spawnGroupIndex = 0; spawnGroupIndex < finalSpawnGroupAmount; spawnGroupIndex++)
			{

				// spawn points can be shared between spawns depending on the settings
				SpawnPoint spawnPoint = null;

				for (EbsSpawn spawn : spawns)
				{
					int spawnAmount = (int) MarketplaceRandomizers.getValidRandomNumberByRange(spawn.spawnAmount, 1, 1, 0, MAX_SPAWN_AMOUNT);

					for (int spawnIndex = 0; spawnIndex < spawnAmount; spawnIndex++)
					{
						int spawnDelayMs = (int) MarketplaceRandomizers.getValidRandomNumberByRange(spawnOption.spawnDelayMs, 0, 0);
						EbsModelPlacement placement = spawn.modelPlacement;

						// determine whether we re-use the same spawn-point we already got
						// or if we should generate a new one
						if (spawnPoint == null || INDIVIDUAL_SPAWN_POINT_TYPE.equals(spawnPointType))
						{
							spawnPoint = spawnManager.getSpawnPoint(placement, modelWorldPoint);
						}

						triggerSpawn(spawn, spawnPoint, spawnDelayMs);
					};
				}
			}
		});
	}

	private void triggerSpawn(EbsSpawn spawn, SpawnPoint spawnPoint, int spawnDelayMs)
	{

		// guard: make sure the spawn is valid
		if (spawn == null)
		{
			log.error("An invalid spawn object was passed when triggering spawn!");
			return;
		}

		SpawnManager spawnManager = manager.getSpawnManager();
		Client client = manager.getClient();

		// guard: make sure the spawn point is valid
		if (spawnPoint == null)
		{
			log.debug("Could not find valid spawn point when triggering spawn behaviour!");
			return;
		}

		// roll a random set of model IDs
		EbsModelSet modelSet = MarketplaceRandomizers.getRandomEntryFromList(spawn.modelSetOptions);
		EbsRandomRange durationMs = spawn.durationMs;
		int randomDurationMs = -1;
		Instant spawnedObjectExpiredAt = null;

		// guard: make sure the selected model is valid
		if (modelSet == null || modelSet.ids == null)
		{
			log.warn("Could not find valid model set when triggering spawn behaviour!");
			return;
		}

		if (durationMs != null)
		{
			randomDurationMs = (int) MarketplaceRandomizers.getValidRandomNumberByRange(durationMs, 0,0);
			spawnedObjectExpiredAt = Instant.now().plusMillis(randomDurationMs);
		}

		SpawnedObject spawnedObject = new SpawnedObject(
			this,
			client,
			spawnPoint,
			spawn,
			modelSet,
			spawnedObjectExpiredAt
		);

		// schedule showing of the object as it is initially hidden
		showSpawnedObject(spawnedObject, spawnDelayMs);

		// set timeout to hide object at the exact time of duration
		// the cleanup will remove it later, but this runs on game ticks
		if (randomDurationMs >= 0)
		{
			hideSpawnedObject(spawnedObject, spawnDelayMs + randomDurationMs);
		}

		// register the objects to the product and manager to make the spawn point unavailable
		spawnedObjects.add(spawnedObject);
		spawnAmount += 1;
		spawnManager.registerSpawnedObjectPlacement(spawnedObject);
	}

	public void triggerEffects(ArrayList<EbsEffect> effects, int startDelayMs, SpawnedObject spawnedObject, MarketplaceEffect marketplaceEffect, boolean forceModelAnimation, ResetEffectHandler resetModelAnimationHandler)
	{

		// guard: make sure the effect is valid
		if (effects == null)
		{
			return;
		}

		Iterator<EbsEffect> effectIterator = effects.iterator();

		// only trigger the first effect, because we want certain effect frames to be blocking for the future ones
		// depending on what the outcome of the conditions are, for this reason we cannot queue all frames at once
		// because certain conditions need to be evaluated when executing the frame and not beforehand.
		triggerEffect(effectIterator, startDelayMs, spawnedObject, marketplaceEffect, forceModelAnimation, resetModelAnimationHandler);
	}

	public void triggerEffect(Iterator<EbsEffect> effectIterator, int frameDelayMs, SpawnedObject spawnedObject, MarketplaceEffect marketplaceEffect, boolean forceModelAnimation, ResetEffectHandler resetModelAnimationHandler)
	{

		// guard: check if the iterator is valid
		if (effectIterator == null || !effectIterator.hasNext())
		{
			return;
		}

		EbsEffect effect = effectIterator.next();
		boolean isLast = !effectIterator.hasNext();
		int durationMs = (int) MarketplaceRandomizers.getValidRandomNumberByRange(effect.durationMs, 0, 0);
		ArrayList<EbsCondition> conditions = effect.conditions;
		boolean blockingConditions = effect.blockingConditions; // TMP: for backwards compatibility, remove after full update
		boolean breakOnInvalidConditions = effect.breakOnInvalidConditions || blockingConditions;
		boolean breakOnValidConditions = effect.breakOnValidConditions;

		// schedule all the individual effects
		manager.getPlugin().scheduleOnClientThread(() -> {
			int nextFrameDelayMs = durationMs;
			int innerDelayMs = 0; // potentially handy in the future to delay a full effect
			boolean conditionsVerified = verifyConditions(conditions, spawnedObject);
			boolean satisfiedInvalidBreak = conditionsVerified || !breakOnInvalidConditions;
			boolean satisfiedValidBreak = !conditionsVerified || !breakOnValidConditions;

			// check if we should schedule the next frame
			// this is allowed when there are no blocking conditions or when the conditions of this frame are okay
			if (satisfiedInvalidBreak && satisfiedValidBreak)
			{
				triggerEffect(effectIterator, nextFrameDelayMs, spawnedObject, marketplaceEffect, forceModelAnimation, resetModelAnimationHandler);
			}

			// guard: check if all the conditions for this effect are met
			if (!conditionsVerified)
			{
				// when this is the last one make sure we still reset the model animations or hide them
				if (isLast && resetModelAnimationHandler != null) {
					resetModelAnimationHandler.execute(innerDelayMs);
				}
				return;
			}

			triggerSpawnOptions(spawnedObject, effect.spawnOptions);
			triggerModelExpired(spawnedObject, effect.modelExpired);
			triggerProductExpired(effect.productExpired);
			triggerModelAnimation(
				spawnedObject,
				effect.modelAnimation,
				// when there is no model animation add the frame duration to the delay for the reset model animation handler
				// to be executed after the frame has been done
				(effect.modelAnimation == null ? nextFrameDelayMs + innerDelayMs : innerDelayMs),
				forceModelAnimation,
				isLast ? resetModelAnimationHandler : null
			);
			triggerModelOverhead(spawnedObject, effect.modelOverhead, innerDelayMs);
			triggerModelSetUpdate(
				spawnedObject,
				effect.modelSet
			);
			triggerPlayerGraphic(effect.playerGraphic, innerDelayMs);
			triggerPlayerAnimation(effect.playerAnimation, innerDelayMs);
			triggerPlayerEquipment(effect.playerEquipment, innerDelayMs);
			triggerPlayerMovement(effect.playerMovement, innerDelayMs);
			triggerInterfaceWidgets(effect.interfaceWidgets, innerDelayMs);
			triggerDrawEffect(effect.drawEffect, innerDelayMs);
			triggerMenuOptions(effect.menuOptions, innerDelayMs);
			triggerSoundEffect(effect.soundEffect, innerDelayMs);
			triggerStateChange(spawnedObject, effect.stateChange, innerDelayMs);
			triggerNotifications(marketplaceEffect, effect.notifications, innerDelayMs);
			triggerProjectiles(spawnedObject, effect.projectiles, innerDelayMs);
			triggerEffectsOptions(effect.effectsOptions, spawnedObject, innerDelayMs);
		}, frameDelayMs);
	}

	public void triggerEffectsOptions(ArrayList<ArrayList<EbsEffect>> effectsOptions, SpawnedObject spawnedObject, int startDelayMs)
	{
		// trigger the animations on this single spawned object
		ArrayList<EbsEffect> effects = MarketplaceRandomizers.getRandomEntryFromList(effectsOptions);
		triggerEffects(effects, spawnedObject, startDelayMs);
	}

	public void triggerEffects(ArrayList<EbsEffect> effects, SpawnedObject spawnedObject, int startDelayMs)
	{
		triggerEffects(
			effects,
			startDelayMs,
			spawnedObject,
			null,
			false,
			null
		);
	}

	private boolean verifyIntervalDelay(EbsInterval interval, Instant lastTriggeredAt, Instant startedAt, int triggeredAmount)
	{
		Instant now = Instant.now();
		boolean triggerOnStart = interval.triggerOnStart;
		int repeatAmount = interval.repeatAmount;
		int startDelayMs = interval.startDelayMs;
		int delayMs = interval.delayMs;
		Instant delayReferenceTime = (lastTriggeredAt == null ? startedAt : lastTriggeredAt);
		boolean hasTriggeredAtLeastOnce = (lastTriggeredAt != null);

		// guard: check if the amount has passed
		// NOTE: -1 repeat amount for infinity!
		if (repeatAmount >= 0 && triggeredAmount >= repeatAmount)
		{
			return false;
		}

		// guard: check if the interval has not passed
		// this interval can be skipped the initial time when requested
		if (delayReferenceTime != null && delayReferenceTime.plusMillis(delayMs).isAfter(now))
		{
			if (hasTriggeredAtLeastOnce || !triggerOnStart)
			{
				return false;
			}
		}

		// guard: check if the minimum required time after the creation time has not passed
		if (startDelayMs > 0 && startedAt.plusMillis(startDelayMs).isAfter(now))
		{
			return false;
		}

		return true;
	}

	public boolean verifyConditions(ArrayList<EbsCondition> conditions)
	{
		return verifyConditions(conditions, null);
	}

	public boolean verifyConditions(ArrayList<EbsCondition> conditions, SpawnedObject spawnedObject)
	{

		// guard: check if collection is valid
		if (conditions == null)
		{
			return true;
		}

		Iterator<EbsCondition> iterator = conditions.iterator();

		while (iterator.hasNext())
		{
			EbsCondition condition = iterator.next();
			boolean conditionVerified = verifyCondition(condition, spawnedObject);

			// guard: if one condition is not verified return false
			// this means the top-level conditions are using AND logic
			if (!conditionVerified)
			{
				return false;
			}
		}

		return true;
	}

	public boolean verifyCondition(EbsCondition condition, SpawnedObject spawnedObject)
	{

		// guard: check if collection is valid
		if (condition == null)
		{
			return true;
		}

		Integer varbitId = condition.varbitId;
		Integer varbitValue = condition.varbitValue;
		Integer minTimeMs = condition.minTimeMs;
		Integer maxTimeMs = condition.maxTimeMs;
		Double minTimePercentage = condition.minTimePercentage;
		Double maxTimePercentage = condition.maxTimePercentage;
		Integer maxSpawnsInView = condition.maxSpawnsInView;
		Integer maxSpawnsInViewRadius = condition.maxSpawnsInViewRadius;
		Integer minSpawnsInView = condition.minSpawnsInView;
		Integer minSpawnsInViewRadius = condition.minSpawnsInViewRadius;
		Integer spawnInViewRadius = condition.spawnInViewRadius;
		String stateType = condition.stateType;
		String stateFormat = condition.stateFormat;
		String stateComparator = condition.stateComparator;
		String stateKey = condition.stateKey;
		String stateValue = condition.stateValue;
		Double chance = condition.chance;
		String combatStyle = condition.combatStyle;
		Integer regionId = condition.regionId;
		Integer genderId = condition.genderId;
		ArrayList<EbsCondition> orConditions = condition.or;
		ArrayList<EbsCondition> andConditions = condition.and;
		ArrayList<EbsCondition> notConditions = condition.not;
		boolean orConditionsVerified = false;

		Client client = manager.getClient();
		Player localPlayer = client.getLocalPlayer();
		PlayerComposition localPlayerComposition = (localPlayer == null ? null : localPlayer.getPlayerComposition());
		int localGenderId = (localPlayerComposition == null ? MALE_GENDER_ID : localPlayerComposition.getGender()); // default to male gender?

		// guard: check if the chance is passed
		if (!MarketplaceRandomizers.rollChance(chance))
		{
			return false;
		}

		// guard: check if the required state is valid
		if (!verifyStateValue(stateType, stateFormat, stateComparator, stateKey, stateValue, spawnedObject))
		{
			return false;
		}

		// guard: check if it is allowed within an absolute time-frame
		if (!verifyTimePassedMs(minTimeMs, maxTimeMs))
		{
			return false;
		}

		// guard: check if it is allowed withing a relative time-frame
		if (!verifyTimePassedPercentage(minTimePercentage, maxTimePercentage))
		{
			return false;
		}

		// guard: check if this condition should check a varbit
		if (varbitId >= 0 && client.getVarbitValue(varbitId) != varbitValue)
		{
			return false;
		}

		// guard: check whether a specific combat style is requested
		if (combatStyle != null && !manager.getFightStateManager().isCurrentCombatStyle(combatStyle))
		{
			return false;
		}

		// guard: check whether a specific region is requested
		if (regionId != null && regionId != manager.getCurrentRegionId())
		{
			return false;
		}

		// guard: check whether a specific gender is requested
		if (genderId != null && genderId != localGenderId)
		{
			return false;
		}

		// guard: check for max spawns in view
		if (maxSpawnsInView > 0 && countSpawnedObjectsInView(maxSpawnsInViewRadius) > maxSpawnsInView)
		{
			return false;
		}

		// guard: check for min spawns in view
		if (minSpawnsInView > 0 && countSpawnedObjectsInView(minSpawnsInViewRadius) < minSpawnsInView)
		{
			return false;
		}

		// guard: check for request to check the current spawn and if its in radius
		if (spawnedObject != null && spawnInViewRadius >= 0 && !spawnedObject.isInView(spawnInViewRadius))
		{
			return false;
		}

		// check if one AND condition is not valid to set to false
		if (andConditions != null)
		{
			for (EbsCondition andCondition : andConditions)
			{
				if (!verifyCondition(andCondition, spawnedObject))
				{
					return false;
				}
			}
		}

		// check if one NOT condition is not valid to set to false
		// the collection is handled as an AND statement on the root-level of the NOT conditions
		if (notConditions != null)
		{
			for (EbsCondition notCondition : notConditions)
			{
				// NOTE: when verified we will set to false
				if (verifyCondition(notCondition, spawnedObject))
				{
					return false;
				}
			}
		}

		// check if one OR condition is valid to set the flag to true
		if (orConditions != null)
		{
			for (EbsCondition orCondition : orConditions)
			{
				if (verifyCondition(orCondition, spawnedObject))
				{
					orConditionsVerified = true;
					break;
				}
			}

			// guard: check if the or conditions are valid
			if (!orConditionsVerified)
			{
				return false;
			}
		}

		return true;
	}

	private boolean verifyStateValue(String stateType, String stateFormat, String stateComparator, String stateKey, String comparedStateValue, SpawnedObject spawnedObject)
	{

		// guard: make sure the state check is valid
		if (stateType == null || stateKey == null)
		{
			return true;
		}

		// default state is NULL
		String currentStateValue = null;

		if (PRODUCT_STATE_TYPE.equals(stateType)) {
			currentStateValue = stateFrameValues.get(stateKey);
		} else if (OBJECT_STATE_TYPE.equals(stateType) && spawnedObject != null) {
			currentStateValue = spawnedObject.getStateFrameValue(stateKey);
		}

		// guard: compare with a simple if when the current state is NULL
		// it might be possible a NULL state is requested, so it can still be verified
		if (currentStateValue == null)
		{
			if (comparedStateValue == null) {
				return true;
			} else {
				return false;
			}
		}

		// guard: check for other formats
		try {
			if (INTEGER_STATE_FORMAT.equals(stateFormat)) {
				int currentValue = (currentStateValue == null ? 0 : Integer.parseInt(currentStateValue));
				int comparedValue = (comparedStateValue == null ? 0 : Integer.parseInt(comparedStateValue));

				switch (stateComparator) {
					case EQUAL_STATE_COMPARISON: return currentValue == comparedValue;
					case LARGER_EQUAL_THAN_STATE_COMPARISON: return currentValue >= comparedValue;
					case LARGER_THAN_STATE_COMPARISON: return currentValue > comparedValue;
					case SMALLER_EQUAL_THAN_STATE_COMPARISON: return currentValue <= comparedValue;
					case SMALLER_THAN_STATE_COMPARISON: return currentValue < comparedValue;
				}
			}
		} catch (Exception exception) {
			return false;
		}

		// make the null-safe comparison
		return currentStateValue.equals(comparedStateValue);
	}

	/**
	 * Check whether a certain time-frame absolute to the starting time is valid
	 */
	private boolean verifyTimePassedMs(int minMs, int maxMs)
	{

		// guard: make sure the time-frame is valid
		if (minMs < 0 || maxMs < 0)
		{
			return true;
		}

		// guard: skip any passed time calculations when it is the full time-frame
		if (minMs == 0 && maxMs == Integer.MAX_VALUE)
		{
			return true;
		}

		long passedMs = getDurationPassed().toMillis();

		// guard: check whether the requested time-frame is outside of the current passed time
		if (passedMs < minMs || passedMs > maxMs)
		{
			return false;
		}

		return true;
	}

	/**
	 * Check whether a certain time-frame relative to the total duration with percentages is what we are now at
	 */
	private boolean verifyTimePassedPercentage(double minPercentage, double maxPercentage)
	{

		// guard: make sure the percentages are valid
		if (minPercentage < 0 || maxPercentage < 0 || maxPercentage > 1 || minPercentage > 1)
		{
			return true;
		}

		// guard: skip any calculations when it is the full time-frame
		if (minPercentage == 0 && maxPercentage == 1)
		{
			return true;
		}

		long durationMs = getDuration().toMillis();

		// guard: make sure the duration is valid
		if (durationMs <= 0)
		{
			return false;
		}

		long passedMs = getDurationPassed().toMillis();
		double passedTimePercentage = (((double) passedMs) / ((double) durationMs));

		// guard: check whether the current elapsed time is outside of the requested range
		if (passedTimePercentage < minPercentage || passedTimePercentage > maxPercentage)
		{
			return false;
		}

		return true;
	}

	private void triggerModelSetUpdate(SpawnedObject spawnedObject, EbsModelSet modelSet)
	{
		// guard: make sure the spawned object and model set are valid
		if (spawnedObject == null || modelSet == null)
		{
			return;
		}

		spawnedObject.setModelSet(modelSet);
		spawnedObject.updateModelSet(true);
	}

	private void triggerModelExpired(SpawnedObject spawnedObject, Boolean modelExpired)
	{

		// guard: check if everything is valid and if a model expiry should be triggered
		if (spawnedObject == null || modelExpired == null || !modelExpired)
		{
			return;
		}

		spawnedObject.expireNow();
	}

	private void triggerProductExpired(Boolean productExpired)
	{

		// guard: check if everything is valid and if a product expiry should be triggered
		if (productExpired == null || !productExpired)
		{
			return;
		}

		stop(false);
	}

	private void triggerModelAnimation(SpawnedObject spawnedObject, EbsAnimationFrame animation, int baseDelayMs, boolean force, ResetEffectHandler resetAnimationHandler)
	{
		// guard: make sure the spawned object and animation are valid
		if (spawnedObject == null || animation == null)
		{

			// always execute the reset animation handler when passed to for example hide the object
			if (resetAnimationHandler != null)
			{
				resetAnimationHandler.execute(baseDelayMs);
			}
			return;
		}

		// add default reset handler
		if (resetAnimationHandler == null)
		{
			resetAnimationHandler = (resetDelayMs) -> {
				resetAnimation(spawnedObject, resetDelayMs);
			};
		}

		// guard: skip when the animation is locked
		// NOTE: some animations we want to force, such as hide animations
		if (!force && spawnedObject.isAnimationLocked())
		{
			return;
		}

		// add an animation lock to prevent animations to override each other
		spawnedObject.lockAnimationUntil(animation.durationMs);

		// perform the actual animation along with a possible reset after it is done
		handleEffectFrame(animation, baseDelayMs, (startDelayMs) -> {
			setAnimation(spawnedObject, animation.id, animation.shouldLoop, startDelayMs);
		}, resetAnimationHandler);
	}

	private void triggerPlayerGraphic(EbsGraphicFrame graphicFrame, int delayMs)
	{
		AnimationManager animationManager = manager.getAnimationManager();

		// create a unique key for this specific product and graphic frame
		// this feels unique enough to support multiple spot anims at once
		// overflowing of this integer is NOT a problem, so we can just add everything
		int graphicKey = hashCode() + manager.getClient().getGameCycle();

		handleEffectFrame(graphicFrame, delayMs, (startDelayMs) -> {
			animationManager.setPlayerGraphic(graphicKey, graphicFrame.id, graphicFrame.height, startDelayMs, graphicFrame.durationMs);
		}, (resetDelayMs) -> {
			animationManager.resetPlayerGraphic(graphicKey, resetDelayMs);
		});
	}

	private void triggerPlayerAnimation(EbsAnimationFrame animationFrame, int delayMs)
	{
		AnimationManager animationManager = manager.getAnimationManager();

		handleEffectFrame(animationFrame, delayMs, (startDelayMs) -> {
			animationManager.setPlayerAnimation(animationFrame.id, startDelayMs, animationFrame.durationMs);
		}, animationManager::resetPlayerAnimation);
	}

	private void triggerPlayerEquipment(EbsEquipmentFrame equipmentFrame, int baseDelayMs)
	{
		TransmogManager transmogManager = manager.getTransmogManager();

		// guard: make sure the frame is valid
		if (equipmentFrame == null)
		{
			return;
		}

		int delayMs = (int) MarketplaceRandomizers.getValidRandomNumberByRange(equipmentFrame.delayMs, 0, 0);

		manager.getPlugin().scheduleOnClientThread(() -> {
			transmogManager.addEffect(this, equipmentFrame,  null);
		}, baseDelayMs + delayMs);
	}

	private void triggerPlayerMovement(EbsMovementFrame movementFrame, int baseDelayMs)
	{
		AnimationManager animationManager = manager.getAnimationManager();

		// guard: make sure the frame is valid
		if (movementFrame == null)
		{
			return;
		}

		int delayMs = (int) MarketplaceRandomizers.getValidRandomNumberByRange(movementFrame.delayMs, 0, 0);

		manager.getPlugin().scheduleOnClientThread(() -> {
			animationManager.addEffect(this, movementFrame, null);
		}, baseDelayMs + delayMs);
	}

	private void triggerModelOverhead(SpawnedObject spawnedObject, EbsModelOverheadFrame overheadFrame, int baseDelayMs)
	{
		SpawnOverheadManager spawnOverheadManager = manager.getSpawnOverheadManager();

		// guard: make sure the frame is valid
		if (overheadFrame == null)
		{
			return;
		}

		int delayMs = (int) MarketplaceRandomizers.getValidRandomNumberByRange(overheadFrame.delayMs, 0, 0);

		manager.getPlugin().scheduleOnClientThread(() -> {
			spawnOverheadManager.addEffect(this, overheadFrame, spawnedObject);
		}, baseDelayMs + delayMs);
	}

	private void triggerInterfaceWidgets(ArrayList<EbsInterfaceWidgetFrame> interfaceWidgetFrames, int delayMs)
	{
		WidgetManager widgetManager = manager.getWidgetManager();

		// guard: make sure there are valid widget frames
		if (interfaceWidgetFrames == null)
		{
			return;
		}

		// TODO: allow delayMs of the effect frame to be included!
		manager.getPlugin().scheduleOnClientThread(() -> {
			Iterator<EbsInterfaceWidgetFrame> interfaceWidgetFrameIterator = interfaceWidgetFrames.iterator();

			while (interfaceWidgetFrameIterator.hasNext())
			{
				EbsInterfaceWidgetFrame interfaceWidgetFrame = interfaceWidgetFrameIterator.next();
				widgetManager.addEffect(this, interfaceWidgetFrame, null);
			}
		}, delayMs);
	}

	private void triggerMenuOptions(ArrayList<EbsMenuOptionFrame> menuOptionFrames, int delayMs)
	{
		MenuManager menuManager = manager.getMenuManager();

		// guard: make sure there are valid frames
		if (menuOptionFrames == null)
		{
			return;
		}

		// TODO: allow delayMs of the effect frame to be included!
		manager.getPlugin().scheduleOnClientThread(() -> {
			Iterator<EbsMenuOptionFrame> menuOptionFrameIterator = menuOptionFrames.iterator();

			while (menuOptionFrameIterator.hasNext())
			{
				EbsMenuOptionFrame menuOptionFrame = menuOptionFrameIterator.next();
				menuManager.addEffect(this, menuOptionFrame, null);
			}
		}, delayMs);
	}

	private void triggerDrawEffect(EbsDrawFrame drawFrame, int baseDelayMs)
	{
		DrawManager drawManager = manager.getDrawManager();

		// guard: make sure the sound is valid
		if (drawFrame == null)
		{
			return;
		}

		int delayMs = (int) MarketplaceRandomizers.getValidRandomNumberByRange(drawFrame.delayMs, 0, 0);

		manager.getPlugin().scheduleOnClientThread(() -> {
			drawManager.addEffect(this, drawFrame, null);
		}, baseDelayMs + delayMs);
	}

	private void triggerSoundEffect(EbsSoundEffectFrame soundEffect, int baseDelayMs)
	{

		// guard: make sure the sound is valid
		if (soundEffect == null)
		{
			return;
		}

		Integer soundEffectId = soundEffect.id;
		int delayMs = (int) MarketplaceRandomizers.getValidRandomNumberByRange(soundEffect.delayMs, 0, 0);

		if (soundEffectId <= 0)
		{
			return;
		}

		manager.getPlugin().scheduleOnClientThread(() -> {
			manager.getSoundManager().playSound(soundEffectId);
		}, baseDelayMs + delayMs);
	}

	private void triggerStateChange(SpawnedObject spawnedObject, EbsStateFrame stateFrame, int baseDelayMs)
	{

		// guard: make sure the state change is valid
		if (stateFrame == null)
		{
			return;
		}

		String stateType = stateFrame.type;
		String stateKey = stateFrame.key;
		Integer delayMs = stateFrame.delayMs;

		// guard: make sure the properties are valid
		if (stateType == null || stateKey == null || delayMs == null)
		{
			return;
		}

		manager.getPlugin().scheduleOnClientThread(() -> {
			if (PRODUCT_STATE_TYPE.equals(stateType)) {
				String currentStateValue = stateFrameValues.get(stateKey);
				String newStateValue = calculateNewStateValue(currentStateValue, stateFrame);
				stateFrameValues.put(stateKey, newStateValue);
			} else if (OBJECT_STATE_TYPE.equals(stateType) && spawnedObject != null) {
				String currentStateValue = spawnedObject.getStateFrameValue(stateKey);
				String newStateValue = calculateNewStateValue(currentStateValue, stateFrame);
				spawnedObject.setStateFrameValue(stateKey, newStateValue);
			}
		}, baseDelayMs + delayMs);
	}

	private String calculateNewStateValue(String currentStateValue, EbsStateFrame stateFrame)
	{

		// guard: make sure the state change is valid
		if (stateFrame == null)
		{
			return null;
		}

		String stateFormat = stateFrame.format;
		String stateOperation = stateFrame.operation;
		String stateDeltaValue = stateFrame.value;
		String newStateValue = stateDeltaValue;

		// due to some operations that can be done here make sure we fallback to the current value
		// when something goes wrong here, because things like division by 0 can happen
		try {
			// for integers use different handler
			if (INTEGER_STATE_FORMAT.equals(stateFormat)) {
				int currentValue = (currentStateValue == null ? 0 : Integer.parseInt(currentStateValue));
				int deltaValue = (stateDeltaValue == null ? 0 : Integer.parseInt(stateDeltaValue));
				int newValue = deltaValue;

				switch (stateOperation) {
					case SET_STATE_OPERATION:
						// empty
						break;
					case ADD_STATE_OPERATION:
						newValue = currentValue + deltaValue;
						break;
					case SUBTRACT_STATE_OPERATION:
						newValue = currentValue - deltaValue;
						break;
					case DIVIDE_STATE_OPERATION:
						newValue = currentValue / deltaValue;
						break;
					case MULTIPLY_STATE_OPERATION:
						newValue = currentValue * deltaValue;
						break;
				}

				newStateValue = String.valueOf(newValue);
			}
		} catch (Exception exception) {
			log.error("Could not calculate new state value because of error:", exception);
			return currentStateValue;
		}

		return newStateValue;
	}

	private void triggerNotifications(MarketplaceEffect marketplaceEffect, ArrayList<EbsNotification> notifications, int delayMs)
	{
		// guard: make sure there are any notifications
		if (notifications == null || notifications.size() <= 0)
		{
			return;
		}

		// queue at the start of the effect
		manager.getPlugin().scheduleOnClientThread(() -> {
			boolean isExpired = ((!isActive && !isExpired()) || isExpired(-1 * END_NOTIFICATION_GRACE_PERIOD_MS));

			// guard: make sure the product is active
			if (isExpired)
			{
				log.debug("Skipping notifications because product is expired by time: "+ getExpiresInMs());
				return;
			}

			// now queue them in the manager, so we also safely remove this product anywhere else
			// while making sure the notifications ARE going to be triggered
			manager.getNotificationManager().handleEbsNotifications(this, marketplaceEffect, notifications);
		}, delayMs);
	}

	private void triggerProjectiles(SpawnedObject spawnedObject, ArrayList<EbsProjectileFrame> projectiles, int delayMs)
	{
		// guard: make sure there are valid frames
		if (projectiles == null)
		{
			return;
		}

		Iterator<EbsProjectileFrame> projectileFrameIterator = projectiles.iterator();
		Client client = manager.getClient();

		while (projectileFrameIterator.hasNext())
		{
			EbsProjectileFrame projectileFrame = projectileFrameIterator.next();
			int projectileDelayMs = (int) MarketplaceRandomizers.getValidRandomNumberByRange(projectileFrame.delayMs, 0, 0, 0, Integer.MAX_VALUE);

			manager.getPlugin().scheduleOnClientThread(() -> {

				// calculate most of the things here to make sure the delay is taken into account once the projectile is really fired
				// for example an animation can still take place before the projectile is fired.
				Integer projectileId = projectileFrame.id;
				String startLocationType = projectileFrame.startLocationType;
				String endLocationType = projectileFrame.endLocationType;
				EbsProjectileFrameLocation startAbsoluteLocation = projectileFrame.startLocation;
				EbsProjectileFrameLocation endAbsoluteLocation = projectileFrame.endLocation;
				Boolean followEndLocation = projectileFrame.followEndLocation;
				Boolean inLineOfSight = projectileFrame.inLineOfSight;
				Boolean avoidExistingSpawns = projectileFrame.avoidExistingSpawns;
				Boolean avoidPlayerLocation = projectileFrame.avoidPlayerLocation;
				Boolean avoidInvalidOverlay = projectileFrame.avoidInvalidOverlay;
				Actor endActor = followEndLocation ? getActorByLocationType(endLocationType) : null;
				LocalPoint startReferenceLocation = getProjectileLocalPointByLocationType(startLocationType, startAbsoluteLocation, spawnedObject);
				LocalPoint endReferenceLocation = getProjectileLocalPointByLocationType(endLocationType, endAbsoluteLocation, spawnedObject);

				// offset the locations with possible radiuses
				LocalPoint startLocation = offsetLocalPointByRadius(startReferenceLocation, inLineOfSight, avoidExistingSpawns, avoidPlayerLocation, avoidInvalidOverlay, projectileFrame.startLocationRadiusRange);
				LocalPoint endLocation = offsetLocalPointByRadius(endReferenceLocation, inLineOfSight, avoidExistingSpawns, avoidPlayerLocation, avoidInvalidOverlay, projectileFrame.endLocationRadiusRange);
				WorldView worldView = client.getTopLevelWorldView();

				int startZ = projectileFrame.startZ;
				int slope = projectileFrame.slope;
				int startHeight = projectileFrame.startHeight;
				int endHeight = projectileFrame.endHeight;
				int durationMs = projectileFrame.durationMs;
				int durationCycles = (durationMs / GAME_CYCLE_DURATION_MS);

				// guard: make sure the parameters are valid
				if (projectileId == null || durationCycles <= 0 || startLocation == null || endLocation == null)
				{
					return;
				}

				WorldPoint startWorldLocation = WorldPoint.fromLocal(client, startLocation);
				WorldPoint endWorldLocation = WorldPoint.fromLocal(client, endLocation);

				int plane = worldView.getPlane();
				int sceneX = startLocation.getSceneX();
				int sceneY = startLocation.getSceneY();
				int tileHeight = worldView.getTileHeights()[plane][sceneX][sceneY];
				int correctedStartZ = tileHeight + startZ; // correct for the starting tile height
				int startCycle = client.getGameCycle();
				int endCycle = startCycle + durationCycles;

				// trigger start spawns
				triggerSpawnOptionsAtWorldPoint(startWorldLocation, projectileFrame.startSpawnOptions);

				Projectile projectile = worldView.createProjectile(
					projectileId,
					plane,
					startLocation.getX(),
					startLocation.getY(),
			    	correctedStartZ,
					startCycle,
					endCycle,
					slope,
					startHeight,
					endHeight,
					endActor,
					endLocation.getX(),
					endLocation.getY()
				);
				worldView.getProjectiles().addLast(projectile);

				// trigger end spawns
				manager.getPlugin().scheduleOnClientThread(() -> {
					triggerSpawnOptionsAtWorldPoint(endWorldLocation, projectileFrame.endSpawnOptions);
				}, durationMs);
			}, delayMs + projectileDelayMs);
		}
	}

	@Nullable
	private Actor getActorByLocationType(String locationType)
	{
		Player localPlayer = manager.getClient().getLocalPlayer();
		Actor interactingActor = localPlayer.getInteracting();

		switch (locationType)
		{
			case CURRENT_TILE_LOCATION_TYPE:
			case PREVIOUS_TILE_LOCATION_TYPE:
				return localPlayer;
			case MODEL_TILE_LOCATION_TYPE:
				return null;
			case INTERACTING_TILE_LOCATION_TYPE:
				return interactingActor;
		}

		return null;
	}

	@Nullable
	private LocalPoint getProjectileLocalPointByLocationType(String locationType, EbsProjectileFrameLocation location, SpawnedObject spawnedObject)
	{
		Client client = manager.getClient();
		WorldView worldView = client.getTopLevelWorldView();
		Actor actor = getActorByLocationType(locationType);
		WorldPoint actorLocation = null;
		WorldPoint referenceWorldPoint = null;
		Integer worldPointX = null;
		Integer worldPointY = null;
		Integer worldPointPlane = null;
		Integer deltaPointX = null;
		Integer deltaPointY = null;

		if (location != null)
		{
			worldPointX = location.worldPointX;
			worldPointY = location.worldPointY;
			worldPointPlane = location.worldPointPlane;
			deltaPointX = location.deltaPointX;
			deltaPointY = location.deltaPointY;
		}

		if (actor != null)
		{
			actorLocation = actor.getWorldLocation();
		}

		if (worldPointPlane == null)
		{
			worldPointPlane = worldView.getPlane();
		}

		switch (locationType)
		{
			case CURRENT_TILE_LOCATION_TYPE:
			case INTERACTING_TILE_LOCATION_TYPE:
				referenceWorldPoint = actorLocation;
				break;
			case PREVIOUS_TILE_LOCATION_TYPE:
				WorldPoint previousLocation =  manager.getSpawnManager().getPreviousPlayerLocation();

				// guard: fallback to the current location
				if (previousLocation == null)
				{
					referenceWorldPoint = actorLocation;
					break;
				}

				referenceWorldPoint = previousLocation;
				break;
			case MODEL_TILE_LOCATION_TYPE:
				referenceWorldPoint = spawnedObject.getSpawnPoint().getWorldPoint();
				break;
			case ABSOLUTE_TILE_LOCATION_TYPE:
				if (worldPointX != null && worldPointY != null)
				{
					referenceWorldPoint = new WorldPoint(worldPointX, worldPointY, worldPointPlane);
				}
				break;
		}

		if (referenceWorldPoint == null)
		{
			return null;
		}

		if (deltaPointX != null)
		{
			referenceWorldPoint = referenceWorldPoint.dx(deltaPointX);
		}

		if (deltaPointY != null)
		{
			referenceWorldPoint = referenceWorldPoint.dy(deltaPointY);
		}

		return LocalPoint.fromWorld(worldView, referenceWorldPoint);
	}

	private LocalPoint offsetLocalPointByRadius(LocalPoint localPoint, boolean inLineOfSight, boolean avoidExistingSpawns, boolean avoidPlayerLocation, boolean avoidInvalidOverlay, EbsRandomRange radiusRange)
	{

		// guard: ensure valid parameters
		if (localPoint == null || radiusRange == null)
		{
			return localPoint;
		}

		Client client = manager.getClient();
		WorldPoint worldPoint =  WorldPoint.fromLocal(client, localPoint);
		int minRadius = radiusRange.min.intValue();
		int maxRadius = radiusRange.max.intValue();

		SpawnPoint spawnPoint = manager.getSpawnManager().getSpawnPoint(
				minRadius,
				maxRadius,
				inLineOfSight,
				avoidExistingSpawns,
				avoidPlayerLocation,
				avoidInvalidOverlay,
				worldPoint
		);

		// guard: its possible no candidate can be found and if so we just pick the original point
		if (spawnPoint == null)
		{
			return localPoint;
		}

		return spawnPoint.getLocalPoint(client);
	}

	private void handleEffectFrame(EbsEffectFrame effect, int baseDelayMs, StartEffectHandler startHandler, ResetEffectHandler resetHandler)
	{

		// guard: make sure the animation is valid
		if (effect == null)
		{
			return;
		}

		int effectId = effect.id;

		// guard: make sure there is an effect ID
		if (effectId < 0)
		{
			return;
		}

		EbsRandomRange delayMsRange = effect.delayMs;
		int delayMs = (int) MarketplaceRandomizers.getValidRandomNumberByRange(delayMsRange, 0, 0);
		int durationMs = effect.durationMs;
		int startDelayMs = baseDelayMs + delayMs;

		// schedule to start the effect
		startHandler.execute(startDelayMs);

		// only reset effects when there is a max duration
		if (durationMs >= 0) {
			int resetDelayMs = startDelayMs + durationMs;
			resetHandler.execute(resetDelayMs);
		}
	}

	private interface StartEffectHandler {
		public void execute(int delayMs);
	}

	private interface ResetEffectHandler {
		public void execute(int delayMs);
	}

	/**
	 * Schedule showing of a spawned object where it will trigger the show effects if available
	 */
	private void showSpawnedObject(SpawnedObject spawnedObject, long delayMs)
	{
		handleSpawnedObject(spawnedObject, delayMs, () -> {
			ArrayList<EbsEffect> showEffects = spawnedObject.getSpawn().showEffects;

			// trigger effects and graphics on show
			triggerEffects(
				showEffects,
				0,
				spawnedObject,
				null,
				true,
				null
			);

			spawnedObject.show();
		});
	}

	/**
	 * Schedule hiding of a spawned object where it will trigger the hide effects if available
	 */
	private void hideSpawnedObject(SpawnedObject spawnedObject, long delayMs)
	{
		handleSpawnedObject(spawnedObject, delayMs, () -> {
			ArrayList<EbsEffect> hideEffects = spawnedObject.getSpawn().hideEffects;

			// guard: check if the hide animation is set
			if (hideEffects == null || hideEffects.size() <= 0)
			{
				spawnedObject.hide();
				manager.getSpawnManager().deregisterSpawnedObjectPlacement(spawnedObject);
				return;
			}

			// trigger the effects and at the end hide the object
			triggerEffects(
				hideEffects,
				0,
				spawnedObject,
				null,
				true,
				(resetDelayMs) -> {
					handleSpawnedObject(spawnedObject, resetDelayMs, () -> {
						spawnedObject.hide();
						manager.getSpawnManager().deregisterSpawnedObjectPlacement(spawnedObject);
					});
				}
			);
		});
	}

	/**
	 * Schedule a set animation for a spawned object
	 */
	private void setAnimation(SpawnedObject spawnedObject, int animationId, boolean shouldLoop, long delayMs)
	{
		handleSpawnedObject(spawnedObject, delayMs, () -> {
			spawnedObject.setAnimation(animationId, shouldLoop);
		});
	}

	/**
	 * Schedule a reset of animation for a spawned object
	 */
	private void resetAnimation(SpawnedObject spawnedObject, long delayMs)
	{
		handleSpawnedObject(spawnedObject, delayMs, () -> {

			// guard: check if this product has been disabled in the mean time after this was scheduled
			// this means we will not trigger the reset animation, because it can interrupt the hide effects.
			// it will not do this when paused, because with paused objects we still want to reset the animation in the background.
			if (!isActive && !isPaused)
			{
				return;
			}

			spawnedObject.resetAnimation();
		});
	}

	/**
	 * Count the amount of spawned objects that are in view of the player
	 */
	private int countSpawnedObjectsInView(int radius)
	{
		AtomicInteger inViewAmount = new AtomicInteger();

		LambdaIterator.handleAll(spawnedObjects, (spawnedObject) -> {
			if (spawnedObject.isInView(radius))
			{
				inViewAmount.addAndGet(1);
			}
		});

		return inViewAmount.get();
	}

	/**
	 * Shortcut to loop all the spawned objects and handle thhem with a delay on the client thread.
	 */
	private void handleSpawnedObjects(CopyOnWriteArrayList<SpawnedObject> spawnedObjects, long delayMs, MarketplaceManager.SpawnedObjectHandler handler)
	{
		// guard: check if the collection is valid
		if (spawnedObjects == null || spawnedObjects.size() <= 0)
		{
			return;
		}

		// make the iterator before the delay to make sure any modifications
		// after calling this handlers are ignored, because a snapshot is made
		Iterator<SpawnedObject> iterator = spawnedObjects.iterator();

		manager.getPlugin().scheduleOnClientThread(() -> {
			while(iterator.hasNext())
			{
				SpawnedObject spawnedObject = iterator.next();
				handler.execute(spawnedObject);
			}
		}, delayMs);
	}

	/**
	 * Shortcut to handle a spawned object on the client thread with a delay
	 */
	private void handleSpawnedObject(SpawnedObject spawnedObject, long delayMs, MarketplaceManager.EmptyHandler handler)
	{
		// guard: check if the collection is valid
		if (spawnedObject == null)
		{
			return;
		}

		manager.getPlugin().scheduleOnClientThread(() -> {
			handler.execute();
		}, delayMs);
	}

	/**
	 * Calculate how long this product is going to be active
	 */
	public Duration getDuration()
	{
		return Duration.between(startedAt, expiredAt);
	}

	/**
	 * Calculate how long this product is going to be active
	 */
	public Duration getDurationLeft()
	{
		Instant now = Instant.now();

		return Duration.between(now, expiredAt);
	}

	/**
	 * Calculate the amount of time in milliseconds since this product was started
	 */
	public Duration getDurationPassed()
	{
		Instant now = Instant.now();

		return Duration.between(startedAt, now);
	}

	/**
	 * Get whether this effect can be seen as potentially dangerous.
	 */
	public boolean isDangerous()
	{
		return ebsProduct.dangerous;
	}
}

package com.twitchliveloadout.marketplace.products;

import java.util.ArrayList;

import static com.twitchliveloadout.marketplace.MarketplaceConstants.*;

public class EbsModelPlacement {
	public String locationType = CURRENT_TILE_LOCATION_TYPE;
	public String followType = NONE_FOLLOW_TYPE;
	public ArrayList<EbsCondition> followConditions;
	public String radiusType = OUTWARD_RADIUS_TYPE;
	public Integer worldPointX;
	public Integer worldPointY;
	public Integer worldPointPlane;
	public Integer deltaPointX;
	public Integer deltaPointY;
	public Boolean inLineOfSight = false;
	public Boolean avoidExistingSpawns = true;
	public Boolean avoidPlayerLocation = true;
	public boolean avoidInvalidOverlay = true;
	public EbsRandomRange radiusRange = new EbsRandomRange(DEFAULT_MIN_RADIUS, DEFAULT_MAX_RADIUS);
	public Integer followRadius;
	public Integer radiusStepSize = 2;
	public String rotationType;
	public EbsRandomRange rotation;
	public EbsTranslation translation;
}

package com.twitchliveloadout.marketplace.products;

import java.util.ArrayList;

public class EbsMenuEntry {
    public String option;
    public String target;
    public ArrayList<EbsEffect> onClickEffects;
}

package com.twitchliveloadout.marketplace.products;

import java.time.Instant;

public class EbsProduct {
	public String id;
	public Integer version = 1;
	public Boolean enabled = true;
	public Boolean dangerous = false;
	public String category;
	public String name;
	public String description;
	public Integer fixedDurationMs;
	public EbsBehaviour behaviour;
	public final String loaded_at = Instant.now().toString();
}



package com.twitchliveloadout.marketplace.products;

import static com.twitchliveloadout.marketplace.MarketplaceConstants.*;

public class EbsNotification {
	public String messageType = NONE_NOTIFICATION_MESSAGE_TYPE;
	public String message;
	public Boolean queue = true;
	public String popupTitle = null;
}

package com.twitchliveloadout.marketplace.products;

import static com.twitchliveloadout.marketplace.MarketplaceConstants.EXTENSION_BITS_TWITCH_PRODUCT_TYPE;

public class StreamerProduct {
	public String id;
	public String ebsProductId;
	public String twitchProductSku;
	public String twitchProductType = EXTENSION_BITS_TWITCH_PRODUCT_TYPE; // by default bits for backwards compatibility
	public String name;
	public Integer duration = 10; // minimum of 10 seconds as a fallback
	public Integer cooldown = 0; // no cooldown in seconds by default
}

package com.twitchliveloadout.marketplace.products;

public class EbsInterfaceWidgetFrame extends EbsEffectFrame {
	public String effectType;
	public Integer parentId = -1;
	public Integer childId = -1;
	public Integer listIndex = -1;

	public Integer widgetType;
	public Integer contentType;
	public String text;
	public Integer textColor;
	public Integer opacity;
	public Integer itemId;
	public Integer itemQuantity;
	public String name;
	public Integer spriteId;
	public Integer modelId;
	public Integer modelZoom;
	public Integer animationId;
}

package com.twitchliveloadout.marketplace.products;

public class EbsRecolor {
	public Integer sourceColorIndex = -1;
	public Integer sourceColorHsl = null;
	public Integer targetColorHsl = null;
	public Integer targetColorHex = null;
}

package com.twitchliveloadout.marketplace.products;

public class EbsRandomRange {
	public Double min = 0.0d;
	public Double max = 0.0d;

	public EbsRandomRange()
	{
		// empty
	}

	public EbsRandomRange(double min, double max)
	{
		this.min = min;
		this.max = max;
	}
}

package com.twitchliveloadout.marketplace.products;

public class EbsMovementFrame extends EbsEffectFrame {
	public Integer idle = -1;
	public Integer idleRotateLeft = -1;
	public Integer idleRotateRight = -1;
	public Integer walk = -1;
	public Integer walkRotate180 = -1;
	public Integer walkRotateLeft = -1;
	public Integer walkRotateRight = -1;
	public Integer run = -1;
}

package com.twitchliveloadout.marketplace.products;

public class TwitchProductCost {
	public Double amount = 0d;
	public String type;
}

package com.twitchliveloadout.marketplace.products;

public class EbsGraphicFrame extends EbsEffectFrame {
	public Integer height = 0;
}

package com.twitchliveloadout.marketplace.products;

public class EbsProjectileFrameLocation {
    public Integer worldPointX;
    public Integer worldPointY;
    public Integer worldPointPlane;
    public Integer deltaPointX;
    public Integer deltaPointY;
}

package com.twitchliveloadout.marketplace.products;

public class ChannelPointReward {
    public String broadcaster_name;
    public String broadcaster_login;
    public String broadcaster_id;
    public String id;
    public Object image;
    public String background_color;
    public boolean is_enabled;
    public int cost;
    public String title;
    public String prompt;
    public boolean is_user_input_required;
    public boolean is_paused;
    public boolean is_in_stock;
    public boolean should_redemptions_skip_request_queue;
    public Object redemptions_redeemed_current_stream;
    public Object cooldown_expires_at;
}

package com.twitchliveloadout.marketplace.products;

import java.util.ArrayList;

public class EbsMenuOptionFrame extends EbsEffectFrame {
	public String type;
	public ArrayList<EbsCondition> conditions;
	public ArrayList<String> matchedOptions;
	public ArrayList<String> matchedTargets;
	public ArrayList<String> matchedEntityTypes;
	public ArrayList<EbsEffect> onClickEffects;
	public Integer minClickRange;
	public Integer maxClickRange;
}

package com.twitchliveloadout.marketplace.products;

public class EbsProductDuration {
	public String name;
	public Integer duration = 0;
}

package com.twitchliveloadout.marketplace.products;

import java.util.ArrayList;

public class EbsSpawn {
	public ArrayList<EbsModelSet> modelSetOptions;
	public EbsRandomRange spawnAmount;
	public EbsModelPlacement modelPlacement = new EbsModelPlacement();
	public EbsModelPlacement modelRespawnPlacement;
	public EbsMovementFrame movementAnimations;
	public ArrayList<EbsEffect> hideEffects;
	public ArrayList<EbsEffect> showEffects;
	public ArrayList<ArrayList<EbsEffect>> randomEffectsOptions;
	public EbsInterval randomEffectsInterval;
	public EbsRandomRange durationMs;
}

package com.twitchliveloadout.marketplace;

import com.google.gson.Gson;
import com.google.gson.JsonArray;
import com.google.gson.JsonObject;
import com.google.gson.JsonParser;
import com.twitchliveloadout.TwitchLiveLoadoutConfig;
import com.twitchliveloadout.TwitchLiveLoadoutPlugin;
import com.twitchliveloadout.fights.FightStateManager;
import com.twitchliveloadout.marketplace.animations.AnimationManager;
import com.twitchliveloadout.marketplace.draws.DrawManager;
import com.twitchliveloadout.marketplace.interfaces.MenuManager;
import com.twitchliveloadout.marketplace.interfaces.WidgetManager;
import com.twitchliveloadout.marketplace.notifications.NotificationManager;
import com.twitchliveloadout.marketplace.products.*;
import com.twitchliveloadout.marketplace.sounds.SoundManager;
import com.twitchliveloadout.marketplace.spawns.SpawnManager;
import com.twitchliveloadout.marketplace.spawns.SpawnOverheadManager;
import com.twitchliveloadout.marketplace.spawns.SpawnPoint;
import com.twitchliveloadout.marketplace.spawns.SpawnedObject;
import com.twitchliveloadout.marketplace.transactions.TwitchTransaction;
import com.twitchliveloadout.marketplace.transactions.TwitchTransactionOrigin;
import com.twitchliveloadout.marketplace.transactions.TwitchTransactionProductType;
import com.twitchliveloadout.marketplace.transmogs.TransmogManager;
import com.twitchliveloadout.twitch.TwitchApi;
import com.twitchliveloadout.twitch.TwitchSegmentType;
import com.twitchliveloadout.twitch.TwitchState;
import com.twitchliveloadout.twitch.TwitchStateEntry;
import com.twitchliveloadout.twitch.eventsub.TwitchEventSubType;
import com.twitchliveloadout.twitch.eventsub.messages.BaseMessage;
import lombok.Getter;
import lombok.Setter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.*;
import net.runelite.api.events.GameStateChanged;
import net.runelite.api.events.MenuOpened;
import net.runelite.api.events.MenuOptionClicked;
import net.runelite.api.events.PlayerChanged;
import net.runelite.api.geometry.SimplePolygon;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.game.ItemManager;
import net.runelite.client.ui.overlay.OverlayManager;
import okhttp3.Response;

import java.time.Instant;
import java.util.*;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.CopyOnWriteArrayList;
import java.util.concurrent.atomic.AtomicBoolean;

import static com.twitchliveloadout.TwitchLiveLoadoutPlugin.IN_DEVELOPMENT;
import static com.twitchliveloadout.marketplace.MarketplaceConstants.EVENT_SUB_DEFAULT_EBS_PRODUCT_ID;

@Slf4j
public class MarketplaceManager {

	@Getter
	private final TwitchLiveLoadoutPlugin plugin;
	private final TwitchApi twitchApi;
	@Getter
	private final TwitchState twitchState;

	@Getter
	private final Client client;

	@Getter
	private final TwitchLiveLoadoutConfig config;

	@Getter
	private final SpawnManager spawnManager;

	@Getter
	private final SpawnOverheadManager spawnOverheadManager;

	@Getter
	private final AnimationManager animationManager;

	@Getter
	private final TransmogManager transmogManager;

	@Getter
	private final WidgetManager widgetManager;

	@Getter
	private final MenuManager menuManager;

	@Getter
	private final DrawManager drawManager;

	@Getter
	private final NotificationManager notificationManager;

	@Getter
	private final SoundManager soundManager;

	@Getter
	private final Gson gson;

	@Getter
	private final FightStateManager fightStateManager;

	/**
	 * List to keep track of all the active products
	 */
	private final CopyOnWriteArrayList<MarketplaceProduct> activeProducts = new CopyOnWriteArrayList<>();

	/**
	 * List of all streamer products from the Twitch configuration segment
	 */
	private CopyOnWriteArrayList<StreamerProduct> streamerProducts = new CopyOnWriteArrayList<>();

	/**
	 * List of all EBS products from Twitch
	 */
	private CopyOnWriteArrayList<EbsProduct> ebsProducts = new CopyOnWriteArrayList<>();

	/**
	 * List of all custom EBS products loaded within RL
	 */
	@Getter
	private CopyOnWriteArrayList<EbsProduct> customEbsProducts = new CopyOnWriteArrayList<>();

	/**
	 * List of all EBS products from Twitch
	 */
	private CopyOnWriteArrayList<ChannelPointReward> channelPointRewards = new CopyOnWriteArrayList<>();

	/**
	 * List of all extension transactions that should be handled
	 */
	private final CopyOnWriteArrayList<TwitchTransaction> queuedTransactions = new CopyOnWriteArrayList<>();
	private final CopyOnWriteArrayList<TwitchTransaction> archivedTransactions = new CopyOnWriteArrayList<>();

	private final CopyOnWriteArrayList<String> handledTransactionIds = new CopyOnWriteArrayList<>();
	private String lastTransactionId = null;

	/**
	 * Track several times that should be slower than client ticks but faster than game ticks
	 */
	private final ConcurrentHashMap<String, Instant> timerLastTriggeredAt = new ConcurrentHashMap<>();

	/**
	 * Flag whether any events are allowed to be active
	 */
	@Getter
	private boolean isActive = true;

	/**
	 * Timers for various modes where events can be tested through the Twitch extension
	 */
	private Instant testModeActivatedAt = null;
	public final static int TEST_MODE_EXPIRY_TIME_S = 1 * 60 * 60;
	public final static String TEST_MODE_EXPIRY_TIME_READABLE = "1h";
	private Instant chaosModeActivatedAt = null;
	public final static int CHAOS_MODE_EXPIRY_TIME_S = 8 * 60 * 60;
	public final static String CHAOS_MODE_EXPIRY_TIME_READABLE = "8h";
	private Instant freeModeActivatedAt = null;
	public final static int FREE_MODE_EXPIRY_TIME_S = 8 * 60 * 60;
	public final static String FREE_MODE_EXPIRY_TIME_READABLE = "8h";

	/**
	 * Flag to identify we are already fetching data so requests are not hoarding
	 */
	private boolean isFetchingEbsTransactions = false;
	private boolean isFetchingEbsProducts = false;
	private boolean isFetchingChannelPointRewards = false;
	@Getter
	private boolean fetchingEbsTransactionsErrored = false;

	/**
	 * Lookup to see until when a certain product is cooled down and should stay in the queue if there are any
	 * transactions made at the same time. This lookup also informs the viewers which products are in cooldown.
	 */
	private final ConcurrentHashMap<String, Instant> streamerProductCooldownUntil = new ConcurrentHashMap<>();
	private Instant sharedCooldownUntil;

	/**
	 * Testing variables for the end-to-end testing of marketplace products
	 */
	private int currentTestEbsProductIndex = 0;
	private Instant lastEbsProductTestedAt;

	/**
	 * Several states that are needed for various product effects / conditions
	 */
	@Getter
	@Setter
	private int currentRegionId = 0;

	public MarketplaceManager(TwitchLiveLoadoutPlugin plugin, TwitchApi twitchApi, TwitchState twitchState, Client client, TwitchLiveLoadoutConfig config, ChatMessageManager chatMessageManager, ItemManager itemManager, OverlayManager overlayManager, Gson gson, FightStateManager fightStateManager)
	{
		this.plugin = plugin;
		this.twitchApi = twitchApi;
		this.twitchState = twitchState;
		this.client = client;
		this.config = config;
		this.gson = gson;
		this.fightStateManager = fightStateManager;
		this.spawnManager = new SpawnManager(plugin, client, this);
		this.spawnOverheadManager = new SpawnOverheadManager(client, overlayManager);
		this.animationManager = new AnimationManager(plugin, client);
		this.transmogManager = new TransmogManager(plugin, client, itemManager);
		this.notificationManager = new NotificationManager(plugin, config, chatMessageManager, client, twitchApi, this);
		this.widgetManager = new WidgetManager(plugin, client);
		this.menuManager = new MenuManager(plugin, config, client);
		this.drawManager = new DrawManager(client);
		this.soundManager = new SoundManager(client, config);
	}

	/**
	 * Get new Twitch transactions where the effects should be queued for.
	 */
	public void fetchAsyncNewEbsTransactions()
	{

		// guard: block when already fetching
		if (isFetchingEbsTransactions)
		{
			return;
		}

		// guard: skip updating new transactions when no products are enabled
		// fetching of new transactions in this case is useless anyways because
		// the configurations for them are not available without products
		if (streamerProducts.size() <= 0 || ebsProducts.size() <= 0)
		{
			return;
		}

		try {
			isFetchingEbsTransactions = true;
			twitchApi.fetchAsyncEbsTransactions(lastTransactionId, (Response response) -> {
				isFetchingEbsTransactions = false;
				fetchingEbsTransactionsErrored = false;
				JsonObject result = (new JsonParser()).parse(response.body().string()).getAsJsonObject();
				boolean status = result.get("status").getAsBoolean();
				String message = result.get("message").getAsString();
				JsonArray newTransactionsJson = result.getAsJsonArray("transactions");
				ArrayList<TwitchTransaction> newTransactions = new ArrayList<>();
				final AtomicBoolean updatedLastTransactionId = new AtomicBoolean(false);

				// guard: check if the status is valid
				if (!status)
				{
					plugin.logSupport("Could not fetch EBS transactions from Twitch as the status is invalid with message: "+ message);
					fetchingEbsTransactionsErrored = true;
					return;
				}

				newTransactionsJson.forEach((element) -> {

					// try catch for each individual transaction to not have one invalid transaction
					// cancel all others with the top-level try-catch in this function
					try {
						TwitchTransaction twitchTransaction = gson.fromJson(element, TwitchTransaction.class);
						String transactionId = twitchTransaction.id;

						// update the ID to tell for next requests to fetch newer transactions
						if (!updatedLastTransactionId.get())
						{
							lastTransactionId = transactionId;
							updatedLastTransactionId.set(true);
						}

						// guard: check if this transaction is already handled
						// this is required because we have an offset on the last checked at date
						// because with the HTTP request delays it is possible to miss a transaction
						if (handledTransactionIds.contains(transactionId))
						{
							log.info("Skipping Twitch transaction because it was already handled: " + transactionId);
							return;
						}

						handledTransactionIds.add(transactionId);
						newTransactions.add(twitchTransaction);
						log.info("Queued a new Twitch transaction with ID: " + transactionId);
					} catch (Exception exception) {
						log.error("Could not parse Twitch Extension transaction due to the following error: ", exception);
					}
				});

				// guard: only update the lists and the panel when new transactions were found
				if (newTransactions.size() <= 0)
				{
					return;
				}

				// add in front of the archive as it is from new to old
				archivedTransactions.addAll(0, newTransactions);

				// add at the end of the queue from old to new
				// reverse is needed because the list is from NEW to OLD
				// and we want the oldest transactions to be first in the queue
				Collections.reverse(newTransactions);
				queuedTransactions.addAll(newTransactions);
				updateMarketplacePanel();

				// clean up archived transactions when exceeding maximum amount
				while (archivedTransactions.size() > config.marketplaceTransactionHistoryAmount())
				{
					archivedTransactions.remove(archivedTransactions.size() - 1);
				}
			}, (exception) -> {
				isFetchingEbsTransactions = false;
				fetchingEbsTransactionsErrored = true;
			});
		} catch (Exception exception) {
			// empty
		}

		// always set to false, also when there is an error
		isFetchingEbsTransactions = false;
	}

	/**
	 * Check for new products that should be applied. This process is a little bit more complex
	 * than you would expect at first, because we need to hook in to the Twitch product configuration and
	 * transactions. From the transaction we can fetch the Twitch product (by SKU). Then we can check
	 * whether the streamer really configured this product to have a specific effect (done in the configuration service).
	 * If yes, we have a Streamer product containing a reference to the Ebs Product, which contains the effect information.
	 * When applying new transactions we will check whether all of these steps are valid to prevent viewers
	 * triggering any effects that were never configured by the streamer.
	 */
	public void handleQueuedTransactions()
	{

		// guard: only apply the products when the player is logged in
		if (!plugin.isLoggedIn())
		{
			return;
		}

		// guard: skip when marketplace is paused
		if (!isActive())
		{
			return;
		}

		Iterator<TwitchTransaction> iterator = queuedTransactions.iterator();

		while (iterator.hasNext())
		{
			TwitchTransaction transaction = iterator.next();
			int activeProductAmount = activeProducts.size();

			// guard: check if the maximum amount of active products is exceeded
			// this means this transaction is kept in the queue until one of the products
			// is done with its effects.
			if (activeProductAmount >= config.marketplaceMaxActiveProducts())
			{
				break;
			}

			// try to handle each individual transaction to prevent one invalid transaction in the queue
			// to cancel all other transactions and with that all their effects
			try {
				String transactionId = transaction.id;
				TwitchProduct twitchProduct = getTwitchProductByTransaction(transaction);
				StreamerProduct streamerProduct = getStreamerProductByTransaction(transaction);

				// guard: make sure a products are exist for this transaction
				if (twitchProduct == null || streamerProduct == null)
				{
					plugin.logSupport("Could not match the transaction product details to a Twitch and Streamer product. Transaction ID: "+ transactionId);
					continue;
				}

				String streamerProductId = streamerProduct.id;
				String ebsProductId = streamerProduct.ebsProductId;
				Instant now = Instant.now();
				Instant cooldownUntil = streamerProductCooldownUntil.get(streamerProductId);
				EbsProduct ebsProduct = getEbsProductById(ebsProductId);
				String productType = transaction.product_type;
				boolean isProductCoolingDown = cooldownUntil != null && now.isBefore(cooldownUntil);
				boolean isSharedCoolingDown = sharedCooldownUntil != null && now.isBefore(sharedCooldownUntil);
				boolean isTestTransaction = productType.equals(TwitchTransactionProductType.TEST.getType());
				boolean isFreeTransaction = productType.equals(TwitchTransactionProductType.FREE.getType());
				boolean isManualTransaction = productType.equals(TwitchTransactionProductType.MANUAL.getType());
				boolean isValidEbsProduct = ebsProduct != null && ebsProduct.enabled && ebsProduct.behaviour != null;
				boolean hasValidAccountType = plugin.getAccountType() != null; // NOTE: can only run on client thread

				// guard: make sure this product is not cooling down
				// this can be the case when two transactions are done at the same time
				if (isProductCoolingDown || isSharedCoolingDown)
				{
					continue;
				}

				// guard: make sure an EBS product is configured for this streamer product
				// we will not remove from the queue because the EBS product might need to be loaded still
				if (!isValidEbsProduct)
				{
					continue;
				}

				// guard: while there is no account type known at the moment skip handling any transactions
				// the check for dangerous account types will come later to actually skip specific effects
				if (!hasValidAccountType)
				{
					continue;
				}

				EbsModelPlacement requiredModelPlacement = ebsProduct.behaviour.requiredModelPlacement;

				// guard: check if at least one spawn point is required for this product to be handled
				// if not then it will stay in the queue until there is a spawn point available
				// this allows support for tight spaces or when many random events are active to not waste
				// any incoming donations
				if (requiredModelPlacement != null)
				{
					SpawnPoint spawnPoint = spawnManager.getSpawnPoint(requiredModelPlacement, null);

					// guard: continue with the queue and don't remove from queue because we will wait for a valid spawn point
					if (spawnPoint == null)
					{
						plugin.logSupport("Skipping transaction because required model placement could not be satisfied: "+ transaction.id);
						continue;
					}
				}

				// keep this info verbose as it is a way of logging to debug any issues that might occur
				// when random events don't trigger and support is required
				log.info("Found a valid transaction that we can start: " + transaction.id);
				log.info("Twitch product SKU: " + streamerProduct.twitchProductSku);
				log.info("Streamer product name: " + streamerProduct.name);
				log.info("Ebs product ID: " + ebsProduct.id);

				// remove the transaction now it is going to be handled
				// we do this after the validation of all products
				// to queue transactions that might receive valid product data later
				queuedTransactions.remove(transaction);

				// guard: check if the version number is supported
				if (ebsProduct.version != MarketplaceConstants.EBS_REQUIRED_PRODUCT_VERSION)
				{
					log.info("Skipping transaction the version number of the EBS product ("+ ebsProduct.version +") is not compatible. Transaction ID: "+ transactionId);
					continue;
				}

				// guard: check for hardcore protection and dangerous random events
				if (ebsProduct.dangerous && !plugin.canPerformDangerousEffects())
				{
					log.error("Skipping transaction because it is deemed dangerous and protection is on, please notify the maintainer: "+ transactionId);
					continue;
				}

				// guard: check for a test transaction while testing mode is not active
				if (isTestTransaction && !isTestModeActive())
				{
					log.warn("Skipping transaction because it is a test transaction while testing is not active: "+ transactionId);
					continue;
				}

				// guard: check for a free transaction while free mode is not active
				if (isFreeTransaction && !isFreeModeActive())
				{
					log.warn("Skipping transaction because it is a free transaction while free mode is not active: "+ transactionId);
					continue;
				}

				if (isManualTransaction && !config.manualMarketplaceProductsEnabled())
				{
					log.warn("Skipping transaction because it is a manual transaction while manual mode is not active: "+ transactionId);
					continue;
				}

				// create a new marketplace product where all the other products
				// are merged together in one instance for reference
				MarketplaceProduct newProduct = new MarketplaceProduct(
					this,
					transaction,
					ebsProduct,
					streamerProduct,
					twitchProduct
				);

				log.info("The marketplace product is configured for the time-frame:");
				log.info("It starts at: " + newProduct.getStartedAt());

				// guard: check if the product is already expired
				// skipping it here is a bit more efficient, because there is a chance
				// some of the behaviours are triggered right before removing it immediately.
				if (newProduct.isExpired())
				{

					// in case there are system clock differences we can handle some degree of offsets and
					// adjust the timestamp of the transaction to now if it falls within the tolerance
					// this is only an issue when the clock is AHEAD of time
					if (!newProduct.isExpired(-1 * MarketplaceConstants.TRANSACTION_EXPIRY_CLOCK_TOLERANCE_MS)) {
						transaction.timestamp = Instant.now().toString();
						log.info("Transaction falls within the clock tolerance settings and is therefore requeued with a new timestamp: " + transaction.timestamp);
						queuedTransactions.add(transaction);
					}

					log.info("It is skipped, because it has already expired at: "+ newProduct.getExpiredAt());
					continue;
				}

				log.info("It expires at: " + newProduct.getExpiredAt() + ", which is in " + newProduct.getExpiresInMs() + "ms");

				// start the product because all the checks have passed
				newProduct.start();

				// update the cooldown after the product is really started an not expired instantly
				// otherwise old transactions can impact the cooldown time
				// NOTE: set the cooldowns AFTER the product is activated completely, because
				// we want cooldowns between the actual activation of them and not between the queueing of them
				// otherwise it is possible that you still have a burst of products being spawned at once because
				// they were all cooled down before and in the queue, but not yet triggered.
				updateCooldown(streamerProduct);

				// register this product to be active, which is needed to check
				// for any periodic effects that might need to trigger
				activeProducts.add(newProduct);
				updateMarketplacePanel();
			} catch (Exception exception) {
				queuedTransactions.remove(transaction);
				log.error("Could not handle transaction due to the following error, it is being skipped: ", exception);
				log.error("The ID of the skipped transaction was: "+ transaction.id);
			}
		}
	}

	/**
	 * Rerun a transaction in full by removing the ID from the handled list and adjusting the timestamp it is received.
	 */
	public void rerunTransaction(TwitchTransaction transaction)
	{

		// guard: make sure the transaction is valid and not queued yet
		if (transaction == null || queuedTransactions.contains(transaction))
		{
			return;
		}

		String transactionId = transaction.id;

		if (isTransactionActive(transactionId))
		{
			return;
		}

		log.info("A transaction is going to be rerun, transaction ID: "+ transactionId);

		// update the timestamp, so it appears to be a recent transaction
		transaction.timestamp = Instant.now().toString();

		// remove from the handled transactions and queue once again
		handledTransactionIds.remove(transactionId);
		queuedTransactions.add(transaction);
	}

	public boolean isTransactionActive(String transactionId)
	{

		// guard: don't rerun the transaction when it is already active
		for (MarketplaceProduct marketplaceProduct : activeProducts)
		{
			if (marketplaceProduct.getTransaction().id.equals(transactionId))
			{
				return true;
			}
		}

		return false;
	}

	public void handleCustomTransaction(TwitchTransaction transaction)
	{

		// guard: skip when not valid
		if (transaction == null)
		{
			return;
		}

		String transactionId = transaction.id;

		// guard: skip when already handled
		if (handledTransactionIds.contains(transactionId))
		{
			return;
		}

		// add it to the queue and archive
		queuedTransactions.add(transaction);
		handledTransactionIds.add(transactionId);
		archivedTransactions.add(0, transaction);
		updateMarketplacePanel();
	}

	/**
	 * Cyclic method to cycle through all the available EBS products and test them one by one at a configurable interval
	 */
	public void testNextEbsProduct()
	{
		Instant now = Instant.now();

		// guard: check if enough time has passed for the next product to be tested
		if (lastEbsProductTestedAt != null && lastEbsProductTestedAt.plusSeconds(config.testRandomEventsDelay()).isAfter(now))
		{
			return;
		}

		// guard: skip when there are no products loaded yet
		if (ebsProducts.size() <= 0)
		{
			return;
		}

		// make sure the index is valid
		if (currentTestEbsProductIndex >= ebsProducts.size() || currentTestEbsProductIndex < 0)
		{
			currentTestEbsProductIndex = 0;
		}

		EbsProduct ebsProduct = ebsProducts.get(currentTestEbsProductIndex);

		// check if a random one should be selected rather than selecting it in a cyclic way
		if (config.testRandomEventsRandomly())
		{
			ArrayList<EbsProduct> newEbsProducts = new ArrayList<>();
			newEbsProducts.addAll(ebsProducts);
			ebsProduct = MarketplaceRandomizers.getRandomEntryFromList(newEbsProducts);
		}

		// test this single product
		testEbsProduct(ebsProduct, TwitchTransactionProductType.TEST, TwitchTransactionOrigin.TEST);

		// move to the next products and delay
		currentTestEbsProductIndex += 1;
		lastEbsProductTestedAt = now;
	}

	/**
	 * Test an EBS product by manually creating a fake Twitch donation and queueing it.
	 */
	public void testEbsProduct(EbsProduct ebsProduct, TwitchTransactionProductType productType, TwitchTransactionOrigin origin)
	{
		TwitchTransaction twitchTransaction = new TwitchTransaction();
		TwitchProduct twitchProduct = new TwitchProduct();
		TwitchProductCost twitchProductCost = new TwitchProductCost();
		String transactionId = generateRandomTestId();
		String twitchSku = generateRandomTestId();
		double currencyAmount = 100d;
		String currencyType = "gp";

		twitchProductCost.amount = currencyAmount;
		twitchProductCost.type = currencyType;

		twitchProduct.sku = twitchSku;
		twitchProduct.domain = "test.ext.twitch.tv";
		twitchProduct.cost = twitchProductCost;
		twitchProduct.inDevelopment = true;
		twitchProduct.displayName = currencyAmount +" "+ currencyType;
		twitchProduct.expiration = "";
		twitchProduct.broadcast = true;

		twitchTransaction.id = transactionId;
		twitchTransaction.timestamp = Instant.now().toString();
		twitchTransaction.broadcaster_id = "0";
		twitchTransaction.broadcaster_login = "test-streamer";
		twitchTransaction.broadcaster_name = "Test Streamer";
		twitchTransaction.user_id = "0";
		twitchTransaction.user_login = "test-viewer";
		twitchTransaction.user_name = "Test Viewer";
		twitchTransaction.product_type = productType.getType();
		twitchTransaction.product_data = twitchProduct;
		twitchTransaction.ebs_product_id = ebsProduct.id;
		twitchTransaction.handled_at = Instant.now().toString();
		twitchTransaction.origin = origin;

		queuedTransactions.add(twitchTransaction);
	}

	private String generateRandomTestId()
	{
		return "test_"+ UUID.randomUUID();
	}

	/**
	 * Update the cooldown period of a streamer product that will block future usage for x seconds
	 */
	private void updateCooldown(StreamerProduct streamerProduct)
	{

		// guard: make sure the product is valid
		if (streamerProduct == null)
		{
			return;
		}

		Instant now = Instant.now();
		String streamerProductId = streamerProduct.id;
		Integer productCooldownSeconds = streamerProduct.cooldown;
		int sharedCooldownSeconds = getSharedCooldownS();

		// check if the shared cooldown needs to be updated
		if (sharedCooldownSeconds > 0)
		{
			sharedCooldownUntil = now.plusSeconds(sharedCooldownSeconds);

			// sync the shared cooldown
			twitchState.setCurrentSharedCooldown(sharedCooldownUntil);
		}

		// check if a product cooldown is needed to be set
		if (productCooldownSeconds > 0)
		{
			// determine the cooldown ending time and update it
			Instant cooldownUntil = now.plusSeconds(productCooldownSeconds);
			streamerProductCooldownUntil.put(streamerProductId, cooldownUntil);

			// sync the cooldown map to the twitch state to update to users
			// that have missed the PubSub message, because they open the stream after the transaction
			twitchState.setCurrentProductCooldowns(streamerProductCooldownUntil);
		}
	}

	/**
	 * Get the shared cooldown timer depending on which mode is active.
	 */
	public int getSharedCooldownS()
	{
		int cooldownS = config.marketplaceNormalModeCooldownS();

		if (isFreeModeActive())
		{
			cooldownS += config.marketplaceFreeModeCooldownS();
		}

		if (isChaosModeActive())
		{
			cooldownS += config.marketplaceChaosModeCooldownS();
		}

		return cooldownS;
	}

	/**
	 * Check to clean any existing products that are expired
	 */
	public void cleanExpiredProducts()
	{
		handleActiveProducts((marketplaceProduct) -> {
			boolean skipDangerous = marketplaceProduct.isDangerous() && !plugin.canPerformDangerousEffects();

			// guard: check if the product is not expired yet and is allowed to stay active
			if (!marketplaceProduct.isExpired() && !skipDangerous)
			{
				return;
			}

			marketplaceProduct.stop(false);
			activeProducts.remove(marketplaceProduct);
			updateMarketplacePanel();

			TwitchTransaction transaction = marketplaceProduct.getTransaction();
			String transactionId = marketplaceProduct.getTransaction().id;
			String ebsProductId = marketplaceProduct.getEbsProduct().id;
			int spawnAmount = marketplaceProduct.getSpawnAmount();
			boolean hasRequiredModelPlacement = marketplaceProduct.getEbsProduct().behaviour.requiredModelPlacement != null;

			// guard: check whether nothing has been spawned, but the effect has a spawn requirement
			// there has been unusual cases in very specific areas where this has been the case reported by streamers
			// for reference: https://github.com/pepijnverburg/osrs-runelite-twitch-live-loadout-plugin/issues/143
			// when this happens we will rerun the event.
			// NOTE: disabled because we'll be testing this more first.
//			if (spawnAmount == 0 && hasRequiredModelPlacement)
//			{
//				log.error("Rerunning an expired marketplace product due to not having spawned enough effects (EBS ID: "+ ebsProductId +", spawn amount: "+ spawnAmount +") for transaction: "+ transactionId);
//				rerunTransaction(transaction);
//				return;
//			}

			log.info("Cleaned an expired marketplace product (EBS ID: "+ ebsProductId +", spawn amount: "+ spawnAmount +") for transaction: "+ transactionId);
		});

		// fail-safe to check any spawned objects that are expired, but not properly cleaned up
		spawnManager.handleAllSpawnedObjects((spawnedObject) -> {
			MarketplaceProduct product = spawnedObject.getProduct();
			boolean hasExpiry = spawnedObject.getExpiredAt() != null;

			// guard: check if spawned object is not expired
			// NOTE: when there is no expiry set it is required the product is still active
			if ((hasExpiry && !spawnedObject.isExpired()) || activeProducts.contains(product))
			{
				return;
			}

			// hide and free up the tile
			spawnedObject.hide();
			spawnManager.deregisterSpawnedObjectPlacement(spawnedObject);
		});
	}

	/**
	 * Update the products the streamer has configured in the Twitch Extension.
	 */
	public void updateStreamerProducts()
	{
		JsonObject segmentContent = twitchApi.getConfigurationSegmentContent(TwitchSegmentType.BROADCASTER);

		// guard: skip when invalid configuration service content
		if (segmentContent == null)
		{
			return;
		}

		// guard: don't update the streamer products when in testing mode
		if (IN_DEVELOPMENT && config.testRandomEventsEnabled())
		{
			return;
		}

		try {
			JsonArray rawStreamerProducts = segmentContent.getAsJsonArray(TwitchStateEntry.STREAMER_PRODUCTS.getKey());

			if (rawStreamerProducts == null) {
				return;
			}

			CopyOnWriteArrayList<StreamerProduct> newStreamerProducts = new CopyOnWriteArrayList<>();

			rawStreamerProducts.forEach((element) -> {
				try {
					JsonObject rawStreamerProduct = element.getAsJsonObject();
					StreamerProduct streamerProduct = gson.fromJson(rawStreamerProduct, StreamerProduct.class);
					newStreamerProducts.add(streamerProduct);
				} catch (Exception exception) {
					// empty
				}
			});

			streamerProducts = newStreamerProducts;
		} catch (Exception exception) {
			plugin.logSupport("Could not parse the raw streamer products to a valid set of products:", exception);
		}
	}

	/**
	 * Update the available effects and their configuration from the Twitch EBS.
	 */
	public void updateAsyncEbsProducts()
	{

		// guard: skip when already fetching
		if (isFetchingEbsProducts)
		{
			return;
		}

		// guard: skip updating the EBS products when there are no streamer products found
		// this prevents requests to be made by streamers who have not configured the marketplace
		// NOTE: we do allow an initial fetch to get an initial set of EBS products in case the
		// streamer products are still being fetched
		if (streamerProducts.size() <= 0 && ebsProducts.size() > 0)
		{
			return;
		}

		try {
			isFetchingEbsProducts = true;
			twitchApi.fetchAsyncEbsProducts((Response response) -> {
				isFetchingEbsProducts = false;
				JsonObject result = (new JsonParser()).parse(response.body().string()).getAsJsonObject();
				boolean status = result.get("status").getAsBoolean();
				String message = result.get("message").getAsString();
				JsonArray products = result.getAsJsonArray("products");

				// guard: check if the status is valid
				// if not we want to keep the old products intact
				if (!status)
				{
					plugin.logSupport("Could not fetch EBS products from Twitch as the status is invalid with message: "+ message);
					return;
				}

				CopyOnWriteArrayList<EbsProduct> newEbsProducts = new CopyOnWriteArrayList<>();

				// try-catch for every parse, to not let all products crash on one misconfiguration
				products.forEach((product) -> {
					try {
						EbsProduct ebsProduct = gson.fromJson(product, EbsProduct.class);
						newEbsProducts.add(ebsProduct);
					} catch (Exception exception) {
						plugin.logSupport("Could not parse the raw EBS product to a valid product: ", exception);
					}
				});

				ebsProducts = newEbsProducts;
			}, (exception) -> {
				isFetchingEbsProducts = false;
			});
		} catch (Exception exception) {
			plugin.logSupport("Could not fetch the new EBS products due to the following error: ", exception);
		}
	}

	public void updateAsyncChannelPointRewards()
	{

		// guard: skip when already fetching
		if (isFetchingChannelPointRewards)
		{
			return;
		}

		isFetchingChannelPointRewards = true;
		twitchApi.fetchAsyncChannelPointRewards(
			(response) -> {
				isFetchingChannelPointRewards = false;
				JsonObject result = (new JsonParser()).parse(response.body().string()).getAsJsonObject();
				JsonArray rewards = result.getAsJsonArray("data");
				CopyOnWriteArrayList<ChannelPointReward> newChannelPointRewards = new CopyOnWriteArrayList<>();

				// guard: check if the rewards could be fetched
				// NOTE: on empty data we will reset the channel point rewards to make sure 'old' data is not synced up
				if (rewards == null)
				{
					channelPointRewards = newChannelPointRewards;
					plugin.logSupport("Could not find any valid Channel Point Rewards.");
					return;
				}

				// try-catch for every parse, to not let all products crash on one misconfiguration
				rewards.forEach((reward) -> {
					try {
						ChannelPointReward channelPointReward = gson.fromJson(reward, ChannelPointReward.class);

						// guard: skip any rewards that are not enabled
						if (!channelPointReward.is_enabled)
						{
							return;
						}

						newChannelPointRewards.add(channelPointReward);
					} catch (Exception exception) {
						plugin.logSupport("Could not parse the raw Channel Point Reward: ", exception);
					}
				});

				plugin.logSupport("Updated to new channel point rewards with amount: "+ newChannelPointRewards.size());
				channelPointRewards = newChannelPointRewards;
			},
			(error) -> {
				isFetchingChannelPointRewards = false;
			}
		);
	}

	/**
	 * Rebuild the marketplace panel completely
	 */
	private void updateMarketplacePanel()
	{
		plugin.getPluginPanel().getMarketplacePanel().requestRebuild();
	}

	/**
	 * Get a copied copy of the active products list to prevent mutations
	 */
	public CopyOnWriteArrayList<MarketplaceProduct> getActiveProducts()
	{
		return new CopyOnWriteArrayList<>(activeProducts);
	}

	/**
	 * Get a copy of the streamer products list to prevent mutations
	 */
	public CopyOnWriteArrayList<StreamerProduct> getStreamerProducts()
	{
		return new CopyOnWriteArrayList<>(streamerProducts);
	}

	/**
	 * Get a copy of the queued transactions list to prevent mutations
	 */
	public CopyOnWriteArrayList<TwitchTransaction> getQueuedTransactions()
	{
		return new CopyOnWriteArrayList<>(queuedTransactions);
	}

	/**
	 * Get a copy of the queued transactions list to prevent mutations
	 */
	public CopyOnWriteArrayList<TwitchTransaction> getArchivedTransactions()
	{
		return new CopyOnWriteArrayList<>(archivedTransactions);
	}

	/**
	 * Get a copy of the channel point rewards list to prevent mutations
	 */
	public CopyOnWriteArrayList<ChannelPointReward> getChannelPointRewards()
	{
		return new CopyOnWriteArrayList<>(channelPointRewards);
	}

	/**
	 * Handle player changes to update current animations or equipment transmogs.
	 */
	public void onPlayerChanged(PlayerChanged playerChanged)
	{

		// guard: make sure we are logged in
		if (!plugin.isLoggedIn())
		{
			return;
		}

		transmogManager.onPlayerChanged(playerChanged);
		animationManager.onPlayerChanged(playerChanged);
	}

	/**
	 * Handle game state changes to respawn all objects, because they are cleared
	 * when a new scene is being loaded.
	 */
	public void onGameStateChanged(GameStateChanged gameStateChanged)
	{
		spawnManager.onGameStateChanged(gameStateChanged);
		animationManager.onGameStateChanged(gameStateChanged);
		transmogManager.onGameStateChanged(gameStateChanged);
	}

	/**
	 * Handle a client tick for all active products for changes
	 * that need to happen really fast and are lightweight.
	 */
	public void onClientTick()
	{
		Instant now = Instant.now();

		// guard: don't do anything when not logged in
		if (!plugin.isLoggedIn())
		{
			return;
		}

		// custom timer running on client ticks every x ms for more heavy things to be executed
		// this is because the @Schedule is delaying very often and some of the processes in here are time-sensitive
		if (passTimerOnce(MarketplaceTimer.RESPAWNS, now))
		{
			// respawn all spawned objects that require it
			// due to for example the reloading of a scene
			spawnManager.respawnRequested();
		}

		if (passTimerOnce(MarketplaceTimer.RECORD_LOCATION, now))
		{
			// record a history of the player location that we can use
			// when spawning new objects that are relative in some way to the player
			spawnManager.recordPlayerLocation();
		}

		if (passTimerOnce(MarketplaceTimer.WIDGETS, now))
		{
			widgetManager.updateEffects();
		}

		if (passTimerOnce(MarketplaceTimer.DRAWS, now))
		{
			drawManager.updateEffects();
		}

		if (passTimerOnce(MarketplaceTimer.PRODUCT_BEHAVIOURS, now))
		{
			handleActiveProducts((marketplaceProduct) -> {
				marketplaceProduct.handleBehaviour();
			});
		}

		if (passTimerOnce(MarketplaceTimer.PRODUCT_EXPIRED_SPAWNS, now))
		{
			handleActiveProducts((marketplaceProduct) -> {
				marketplaceProduct.cleanExpiredSpawnedObjects();
			});
		}

		if (passTimerOnce(MarketplaceTimer.PRODUCT_SPAWN_ROTATIONS, now))
		{
			handleActiveProducts((marketplaceProduct) -> {
				marketplaceProduct.handleSpawnRotations();
			});
		}
	}

	/**
	 * Handle game ticks
	 */
	public void onGameTick()
	{
		notificationManager.onGameTick();
		menuManager.onGameTick();
		widgetManager.onGameTick();
		transmogManager.onGameTick();
		animationManager.onGameTick();
		spawnOverheadManager.onGameTick();
	}

	/**
	 * Handle on menu option clicks
	 */
	public void onMenuOptionClicked(MenuOptionClicked event)
	{
		menuManager.onMenuOptionClicked(event);
	}

	/**
	 * Add menu options based on which spawned object can be found with additional menu entries
	 */
	public void onMenuOpened(MenuOpened event)
	{
		Point mouseCanvasPoint = client.getMouseCanvasPosition();
		MenuEntry[] currentMenuEntries = client.getMenu().getMenuEntries();
		int firstAvailableMenuEntryIndex = 0;

		for (int menuEntryIndex = 0; menuEntryIndex < currentMenuEntries.length; menuEntryIndex++)
		{
			if (currentMenuEntries[menuEntryIndex].getOption().equals("Cancel"))
			{
				firstAvailableMenuEntryIndex = menuEntryIndex + 1;
				break;
			}
		}

		int finalFirstAvailableMenuEntryIndex = firstAvailableMenuEntryIndex;
		spawnManager.handleAllSpawnedObjects((spawnedObject) -> {
			MarketplaceProduct product = spawnedObject.getProduct();
			ArrayList<EbsMenuEntry> menuEntries = spawnedObject.getModelSet().menuEntries;

			if (menuEntries == null || menuEntries.isEmpty())
			{
				return;
			}

			// only calculate the polygon when there are menu entries
			SimplePolygon polygon = spawnedObject.calculatePolygon();

			// guard: skip when not in poly
			if (!polygon.contains(mouseCanvasPoint.getX(), mouseCanvasPoint.getY()))
			{
				return;
			}

			// add all menu entries in reverse order to make sure they are displayed correctly
			for (EbsMenuEntry menuEntry : menuEntries)
			{
				String option = menuEntry.option;
				String target = menuEntry.target;
				ArrayList<EbsEffect> onClickEffects = menuEntry.onClickEffects;
				String formattedOption = MarketplaceMessages.formatMessage(option, product, null);
				String formattedTarget = MarketplaceMessages.formatMessage(target, product, null);

				// guard: make sure the entry is valid
				if (option == null || target == null || option.isEmpty() || target.isEmpty())
				{
					continue;
				}

				client.getMenu().createMenuEntry(finalFirstAvailableMenuEntryIndex)
					.setOption(formattedOption)
					.setTarget(formattedTarget)
					.onClick((callback) -> {

						// guard: skip triggering the effects when the product is not active anymore
						if (!product.isActive())
						{
							return;
						}

						product.triggerEffects(onClickEffects, spawnedObject, 0);
					})
					.setType(MenuAction.RUNELITE)
					.setParam0(0)
					.setParam1(0)
					.setDeprioritized(true);
			}
		});
	}

	/**
	 * Handle on menu option clicks
	 */
	public boolean shouldDraw(Renderable renderable, boolean drawingUI)
	{
		return drawManager.shouldDraw(renderable, drawingUI);
	}

	private boolean passTimerOnce(MarketplaceTimer timer, Instant now)
	{

		// guard: make sure the timer name is valid
		if (timer == null)
		{
			return false;
		}

		String name = timer.getName();
		int delayMs = timer.getDelayMs();
		Instant lastTriggeredAt = timerLastTriggeredAt.get(name);
		boolean isPassed = lastTriggeredAt == null || now.isAfter(lastTriggeredAt.plusMillis((delayMs)));

		// update the timer when passed
		if (isPassed)
		{
			timerLastTriggeredAt.put(name, now);
		}

		return isPassed;
	}

	public StreamerProduct getStreamerProductByTransaction(TwitchTransaction transaction)
	{
		TwitchProduct twitchProduct = getTwitchProductByTransaction(transaction);
		boolean isTestTransaction = transaction.isTestTransaction();
		boolean isManualTransaction = transaction.isManualTransaction();
		boolean isEventSubTransaction = transaction.isEventSubTransaction();
		BaseMessage eventSubMessage = transaction.eventSubMessage;

		// guard: make sure the twitch product is valid
		if (twitchProduct == null)
		{
			return null;
		}

		// if this is a test transaction force the EBS product ID based on what is passed in the transaction
		if (isTestTransaction)
		{
			String ebsProductId = transaction.ebs_product_id;
			EbsProduct ebsProduct = getEbsProductById(ebsProductId);
			StreamerProduct testStreamerProduct = new StreamerProduct();
			testStreamerProduct.id = generateRandomTestId();
			testStreamerProduct.ebsProductId = transaction.ebs_product_id;
			testStreamerProduct.twitchProductSku = generateRandomTestId();
			testStreamerProduct.name = "[PREVIEW] "+ ebsProduct.name;
			testStreamerProduct.duration = config.testRandomEventsDuration();
			testStreamerProduct.cooldown = 0;

			return testStreamerProduct;
		}

		// if this is a manual transaction force the EBS product ID based on what is passed in the transaction
		if (isManualTransaction)
		{
			String ebsProductId = transaction.ebs_product_id;
			EbsProduct ebsProduct = getEbsProductById(ebsProductId);
			Integer ebsProductFixedDurationMs = ebsProduct.fixedDurationMs;
			int duration = (ebsProductFixedDurationMs != null ? (ebsProductFixedDurationMs / 1000) : config.testRandomEventsDuration());
			StreamerProduct manualStreamerProduct = new StreamerProduct();

			manualStreamerProduct.id = generateRandomTestId();
			manualStreamerProduct.ebsProductId = transaction.ebs_product_id;
			manualStreamerProduct.twitchProductSku = generateRandomTestId();
			manualStreamerProduct.name = "[MANUAL] "+ ebsProduct.name;
			manualStreamerProduct.duration = duration;
			manualStreamerProduct.cooldown = 0;

			return manualStreamerProduct;
		}

		String twitchProductSku = twitchProduct.sku;
		StreamerProduct streamerProduct = getStreamerProductBySku(twitchProductSku);

		// create a custom streamer product with a default EBS product only showing some messages
		// only do this when no streamer product is known for this event
		if (streamerProduct == null && isEventSubTransaction)
		{
			TwitchEventSubType eventSubType = transaction.eventSubType;
			boolean isEventSubMessageEnabled = eventSubType.getDefaultMessageEnabledGetter().execute(plugin, config, eventSubMessage);

			// guard: skip when the event sub message is not enabled
			if (!isEventSubMessageEnabled)
			{
				return null;
			}

            StreamerProduct eventSubStreamerProduct = new StreamerProduct();
			eventSubStreamerProduct.id = UUID.randomUUID().toString();
			eventSubStreamerProduct.ebsProductId = EVENT_SUB_DEFAULT_EBS_PRODUCT_ID;
			eventSubStreamerProduct.twitchProductSku = twitchProductSku;
			eventSubStreamerProduct.name = "Channel Event"; //eventSubType.getName();
			eventSubStreamerProduct.cooldown = 0;

			return eventSubStreamerProduct;
		}

		return streamerProduct;
	}

	public TwitchProduct getTwitchProductByTransaction(TwitchTransaction transaction)
	{

		// guard: make sure the transaction is valid
		if (transaction == null)
		{
			return null;
		}

		TwitchProduct twitchProduct = transaction.product_data;

		return twitchProduct;
	}

	private StreamerProduct getStreamerProductBySku(String twitchProductSku)
	{
		Iterator<StreamerProduct> iterator = streamerProducts.iterator();

		while(iterator.hasNext())
		{
			StreamerProduct candidateStreamerProduct = iterator.next();

			// guard: check if a match is found
			if (twitchProductSku.equals(candidateStreamerProduct.twitchProductSku))
			{
				return candidateStreamerProduct;
			}
		}

		return null;
	}

	private EbsProduct getEbsProductById(String ebsProductId)
	{
		EbsProduct ebsProduct = getEbsProductById(ebsProductId, ebsProducts);
		EbsProduct customEbsProduct = getEbsProductById(ebsProductId, customEbsProducts);

		// NOTE: prioritize the custom EBS product to allow overriding!
		return customEbsProduct != null ? customEbsProduct : ebsProduct;
	}

	private EbsProduct getEbsProductById(String ebsProductId, CopyOnWriteArrayList<EbsProduct> ebsProductCandidates)
	{
		Iterator<EbsProduct> iterator = ebsProductCandidates.iterator();

		while (iterator.hasNext())
		{
			EbsProduct candidateEbsProduct = iterator.next();

			// guard: check if a match is found
			if (ebsProductId.equals(candidateEbsProduct.id))
			{
				return candidateEbsProduct;
			}
		}

		return null;
	}

	public void addCustomEbsProduct(EbsProduct ebsProduct)
	{
		String newEbsProductId = ebsProduct.id;
		EbsProduct existingCustomEbsProduct = getEbsProductById(newEbsProductId, customEbsProducts);

		// remove the custom EBS product when the ID was already added
		if (existingCustomEbsProduct != null)
		{
			customEbsProducts.remove(existingCustomEbsProduct);
		}

		customEbsProducts.add(ebsProduct);
	}

	private ChannelPointReward getChannelPointRewardById(String channelPointRewardId)
	{
		Iterator<ChannelPointReward> iterator = channelPointRewards.iterator();

		while(iterator.hasNext())
		{
			ChannelPointReward candidateProduct = iterator.next();

			// guard: check if a match is found
			if (channelPointRewardId.equals(candidateProduct.id))
			{
				return candidateProduct;
			}
		}

		return null;
	}

	/**
	 * Force stop all active products
	 */
	public void forceStopActiveProducts()
	{
		handleActiveProducts((product) -> {
			product.stop(true);
		});
	}

	/**
	 * Pause all products
	 */
	public void pauseActiveProducts()
	{
		handleActiveProducts(MarketplaceProduct::pause);
		isActive = false;
	}

	/**
	 * Start all products
	 */
	public void playActiveProducts()
	{
		isActive = true;
		handleActiveProducts(MarketplaceProduct::play);

		// re-apply them manually because they are event based and the active flag is not checked periodically
		// TODO: consider doing this periodically for future side-effects
		transmogManager.applyActiveEffects();
		animationManager.applyActiveEffects();
	}

	/**
	 * Handle all active products using an iterator
	 */
	public void handleActiveProducts(LambdaIterator.ValueHandler<MarketplaceProduct> handler)
	{
		LambdaIterator.handleAll(activeProducts, handler);
	}

	public void enableTestMode()
	{
		testModeActivatedAt = Instant.now();
	}

	public void disableTestMode()
	{
		testModeActivatedAt = null;
	}

	public boolean isTestModeActive()
	{

		// in development allow testing when config enables it as well
		// this is an easy permanent testing mode setup
		if (IN_DEVELOPMENT && config.testRandomEventsEnabled())
		{
			return true;
		}

		return testModeActivatedAt != null && Instant.now().minusSeconds(TEST_MODE_EXPIRY_TIME_S).isBefore(testModeActivatedAt);
	}

	public void enableChaosMode()
	{
		chaosModeActivatedAt = Instant.now();
	}

	public void disableChaosMode()
	{
		chaosModeActivatedAt = null;
	}

	public boolean isChaosModeActive()
	{
		return chaosModeActivatedAt != null && Instant.now().minusSeconds(CHAOS_MODE_EXPIRY_TIME_S).isBefore(chaosModeActivatedAt);
	}

	public void enableFreeMode()
	{
		freeModeActivatedAt = Instant.now();
	}

	public void disableFreeMode()
	{
		freeModeActivatedAt = null;
	}

	public boolean isFreeModeActive()
	{
		return freeModeActivatedAt != null && Instant.now().minusSeconds(FREE_MODE_EXPIRY_TIME_S).isBefore(freeModeActivatedAt);
	}

	/**
	 * Handle marketplace disable
	 */
	public void disable()
	{
		forceStopActiveProducts();
		animationManager.forceCleanAllEffects();
		transmogManager.forceCleanAllEffects();
		drawManager.forceCleanAllEffects();
		menuManager.forceCleanAllEffects();
		widgetManager.forceCleanAllEffects();
		widgetManager.hideCoveringOverlays();
		notificationManager.forceHideOverheadText();
		spawnOverheadManager.forceCleanAllEffects();
	}

	/**
	 * Handle plugin shutdown
	 */
	public void shutDown()
	{
		disable();
		spawnOverheadManager.removeOverlay();
	}

	public interface EmptyHandler {
		public void execute();
	}

	public interface GetTimeHandler {
		public Instant execute();
	}

	public interface SpawnedObjectHandler {
		public void execute(SpawnedObject spawnedObject);
	}

	public interface PlayerHandler {
		public void execute(Player player);
	}
}

package com.twitchliveloadout.marketplace;

import lombok.Getter;

@Getter
public enum MarketplaceTimer {
	// NOTE: timers are distributed evenly across a game tick during the client ticks
	// if a timer is needed to be > 600ms in terms of timer then use a game tick
	PRODUCT_SPAWN_ROTATIONS("product-spawn-rotations", 75),
	WIDGETS("widgets", 100),
	DRAWS("draws", 200),
	RECORD_LOCATION("record-location", 200),
	RESPAWNS("respawns", 200),
	PRODUCT_BEHAVIOURS("product-behaviours", 300),
	PRODUCT_EXPIRED_SPAWNS("product-expired-spawns", 500),
	;

	private final String name;
	private final int delayMs;

	MarketplaceTimer(String name, int delayMs)
	{
		this.name = name;
		this.delayMs = delayMs;
	}
}


package com.twitchliveloadout.marketplace.animations;

import com.twitchliveloadout.TwitchLiveLoadoutPlugin;
import com.twitchliveloadout.marketplace.MarketplaceEffect;
import com.twitchliveloadout.marketplace.MarketplaceEffectManager;
import com.twitchliveloadout.marketplace.MarketplaceManager;
import com.twitchliveloadout.marketplace.products.EbsMovementFrame;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.ActorSpotAnim;
import net.runelite.api.Client;
import net.runelite.api.GameState;
import net.runelite.api.Player;
import net.runelite.api.events.GameStateChanged;
import net.runelite.api.events.PlayerChanged;

import java.time.Instant;
import java.util.concurrent.ConcurrentHashMap;

import static com.twitchliveloadout.marketplace.MarketplaceConstants.MOVEMENT_EFFECT_MAX_SIZE;

@Slf4j
public class AnimationManager extends MarketplaceEffectManager<EbsMovementFrame> {
	private final TwitchLiveLoadoutPlugin plugin;
	private final Client client;

	private final ConcurrentHashMap<ActorAnimation, Integer> originalMovementAnimations = new ConcurrentHashMap<>();
	private Instant animationLockedUntil;
	private Instant graphicLockedUntil;

	public AnimationManager(TwitchLiveLoadoutPlugin plugin, Client client)
	{
		super(MOVEMENT_EFFECT_MAX_SIZE);

		this.plugin = plugin;
		this.client = client;
	}

	public void onGameTick()
	{
		cleanInactiveEffects();
	}

	public void onPlayerChanged(PlayerChanged playerChanged)
	{
		Player player = playerChanged.getPlayer();
		Player localPlayer = client.getLocalPlayer();
		boolean isLocalPlayer = (localPlayer == player);

		// guard: for now we only support local players
		if (!isLocalPlayer)
		{
			return;
		}

		recordOriginalMovementAnimations();
		applyActiveEffects();
	}

	@Override
	protected void applyEffect(MarketplaceEffect<EbsMovementFrame> effect)
	{
		Player player = client.getLocalPlayer();
		EbsMovementFrame movementFrame = effect.getFrame();

		plugin.runOnClientThread(() -> {
			for (ActorAnimation animation : ActorAnimation.values())
			{
				final Integer animationId = getCurrentMovementAnimation(animation, movementFrame);

				// fallback to the original when no animation is found
				if (animationId == null || animationId < 0)
				{
					return;
				}

				animation.setAnimation(player, animationId);
			}
		});
	}

	@Override
	protected void restoreEffect(MarketplaceEffect<EbsMovementFrame> effect)
	{
		Player player = client.getLocalPlayer();

		// update to originals
		plugin.runOnClientThread(() -> {
			for (ActorAnimation animation : ActorAnimation.values())
			{

				// guard: make sure the animation is known
				if (!originalMovementAnimations.containsKey(animation))
				{
					continue;
				}

				int originalAnimationId = originalMovementAnimations.get(animation);
				animation.setAnimation(player, originalAnimationId);
			}
		});

		// after the original is restored there might be another one right up in the effect queue
		applyActiveEffects();
	}

	@Override
	protected void onAddEffect(MarketplaceEffect<EbsMovementFrame> effect)
	{
		// update immediately when effect is added
		// because this manager is not updating periodically, but event based
		applyActiveEffects();

		// check whether we should record the original movements for the first time
		// this is needed because it is possible a onPlayerChanged event was not yet triggered after logging in
		if (originalMovementAnimations.size() <= 0)
		{
			recordOriginalMovementAnimations();
		}
	}

	@Override
	protected void onDeleteEffect(MarketplaceEffect<EbsMovementFrame> effect)
	{
		// empty
	}

	private void recordOriginalMovementAnimations()
	{
		Player player = client.getLocalPlayer();

		originalMovementAnimations.clear();
		for (ActorAnimation animation : ActorAnimation.values())
		{
			originalMovementAnimations.put(animation, animation.getAnimation(player));
		}
	}

	public void setPlayerGraphic(int graphicKey, int graphicId, int graphicHeight, long delayMs, long durationMs)
	{
		handleLockedPlayerEffect(
			delayMs,
			durationMs,
			() -> graphicLockedUntil,
			() -> {
				// locking the player graphic is not needed anymore because multiple graphics (spot anims)
				// can be spawned on the player at once now! consider removing this completely with a next update
				// graphicLockedUntil = Instant.now().plusMillis(durationMs);
			},
			(player) -> {
				player.createSpotAnim(graphicKey, graphicId, graphicHeight, 0);
			}
		);
	}

	public void resetPlayerGraphic(int graphicKey, int delayMs)
	{
		handleLocalPlayer((player) -> {
			plugin.scheduleOnClientThread(() -> {
				player.removeSpotAnim(graphicKey);
			}, delayMs);
		});
	}

	public void setPlayerAnimation(int animationId, long delayMs, long durationMs)
	{
		handleLockedPlayerEffect(
			delayMs,
			durationMs,
			() -> animationLockedUntil,
			() -> {
				animationLockedUntil = Instant.now().plusMillis(durationMs);
			},
			(player) -> {
				player.setAnimationFrame(0);
				player.setAnimation(animationId);
			}
		);
	}

	public void resetPlayerAnimation(int delayMs)
	{
		handleLocalPlayer((player) -> {
			plugin.scheduleOnClientThread(() -> {
				player.setAnimation(-1);
				player.setAnimationFrame(0);
			}, delayMs);
		});
	}

	private void handleLockedPlayerEffect(long delayMs, long durationMs, MarketplaceManager.GetTimeHandler getLockedUntil, MarketplaceManager.EmptyHandler updateLockHandler, MarketplaceManager.PlayerHandler playerHandler)
	{
		handleLocalPlayer((player) -> {
			plugin.scheduleOnClientThread(() -> {
				Instant lockedUntil = getLockedUntil.execute();
				boolean isLocked = (lockedUntil != null && Instant.now().isBefore(lockedUntil));

				// guard: skip the request if we are not yet done with animating the previous one
				if (isLocked)
				{
					return;
				}

				updateLockHandler.execute();
				playerHandler.execute(player);
			}, delayMs);
		});
	}

	private void handleLocalPlayer(MarketplaceManager.PlayerHandler playerHandler)
	{
		Player player = client.getLocalPlayer();

		// guard: make sure the player is valid
		if (player == null)
		{
			return;
		}

		playerHandler.execute(player);
	}

	public int getCurrentMovementAnimation(ActorAnimation animation, EbsMovementFrame movementFrame)
	{
		int animationId = -1;
		int fallbackAnimationId = -1;

		if (movementFrame == null)
		{
			return animationId;
		}

		switch(animation)
		{
			case RUN:
				animationId = movementFrame.run;
				fallbackAnimationId = movementFrame.walk;
			 	break;
			case IDLE:
				animationId = movementFrame.idle;
				break;
			case IDLE_ROTATE_LEFT:
				animationId = movementFrame.idleRotateLeft;
				fallbackAnimationId = movementFrame.idle;
				break;
			case IDLE_ROTATE_RIGHT:
				animationId = movementFrame.idleRotateRight;
				fallbackAnimationId = movementFrame.idle;
				break;
			case WALK:
				animationId = movementFrame.walk;
				break;
			case WALK_ROTATE_180:
				animationId = movementFrame.walkRotate180;
				fallbackAnimationId = movementFrame.walk;
				break;
			case WALK_ROTATE_LEFT:
				animationId = movementFrame.walkRotateLeft;
				fallbackAnimationId = movementFrame.walk;
				break;
			case WALK_ROTATE_RIGHT:
				animationId = movementFrame.walkRotateRight;
				fallbackAnimationId = movementFrame.walk;
				break;
		}

		// guard: check if we need to use the fallback
		if (animationId < 0 && fallbackAnimationId >= 0)
		{
			return fallbackAnimationId;
		}

		return animationId;
	}
}

package com.twitchliveloadout.marketplace.animations;

import lombok.Getter;
import net.runelite.api.Actor;

public enum ActorAnimation
{
	IDLE(Actor::getIdlePoseAnimation, Actor::setIdlePoseAnimation),
	IDLE_ROTATE_LEFT(Actor::getIdleRotateLeft, Actor::setIdleRotateLeft),
	IDLE_ROTATE_RIGHT(Actor::getIdleRotateRight, Actor::setIdleRotateRight),
	WALK(Actor::getWalkAnimation, Actor::setWalkAnimation),
	WALK_ROTATE_180(Actor::getWalkRotate180, Actor::setWalkRotate180),
	WALK_ROTATE_LEFT(Actor::getWalkRotateLeft, Actor::setWalkRotateLeft),
	WALK_ROTATE_RIGHT(Actor::getWalkRotateRight, Actor::setWalkRotateRight),
	RUN(Actor::getRunAnimation, Actor::setRunAnimation),
	;

	interface AnimationGetter
	{
		int getAnimation(Actor actor);
	}

	interface AnimationSetter
	{
		void setAnimation(Actor actor, int animationId);
	}

	@Getter
	private final AnimationGetter animationGetter;
	private final AnimationSetter animationSetter;

	ActorAnimation(AnimationGetter animationGetter, AnimationSetter animationSetter)
	{
		this.animationGetter = animationGetter;
		this.animationSetter = animationSetter;
	}

	public int getAnimation(Actor actor)
	{
		if (actor == null) {
			return -1;
		}

		return animationGetter.getAnimation(actor);
	}

	public void setAnimation(Actor actor, int animationId)
	{
		animationSetter.setAnimation(actor, animationId);
	}
}

package com.twitchliveloadout.marketplace;

import com.twitchliveloadout.marketplace.products.*;

import java.util.ArrayList;
import java.util.Random;

public class MarketplaceRandomizers {

	public static <T> T getRandomEntryFromList(ArrayList<T> list)
	{
		if (list == null || list.size() <= 0)
		{
			return null;
		}

		Random selector = new Random();
		int randomIndex = selector.nextInt(list.size());
		T randomEntry = list.get(randomIndex);

		return randomEntry;
	}

	public static double getValidRandomNumberByRange(EbsRandomRange randomRange, double defaultMin, double defaultMax)
	{
		return getValidRandomNumberByRange(randomRange, defaultMin, defaultMax, Double.MIN_VALUE, Double.MAX_VALUE);
	}

	public static double getValidRandomNumberByRange(EbsRandomRange randomRange, double defaultMin, double defaultMax, double absoluteMin, double absoluteMax)
	{
		EbsRandomRange validRandomRange = new EbsRandomRange(defaultMin, defaultMax);

		if (randomRange != null) {
			if (randomRange.min != null) {
				validRandomRange.min = randomRange.min;
			}
			if (randomRange.max != null) {
				validRandomRange.max = randomRange.max;
			}
			if (randomRange.min != null && randomRange.max == null) {
				validRandomRange.max = randomRange.min;
			}

			// make sure the max is valid compared to the min
			if (validRandomRange.min > validRandomRange.max) {
				validRandomRange.max = validRandomRange.min;
			}
		}

		Double min = validRandomRange.min;
		Double max = validRandomRange.max;
		double randomValue = min + ((int) (Math.random() * ((float) Math.abs(max - min))));

		// guard: make sure absolute min and max are not exceeded
		if (randomValue < absoluteMin) {
			randomValue = absoluteMin;
		} else if (randomValue > absoluteMax) {
			randomValue = absoluteMax;
		}

		return randomValue;
	}

	public static boolean rollChance(Double chance)
	{
		double roll = Math.random();

		if (chance == null)
		{
			return true;
		}

		return chance >= roll;
	}

	public static EbsSpawnOption getSpawnBehaviourByChance(ArrayList<EbsSpawnOption> spawnBehaviourOptions)
	{

		// guard: make sure there are any options
		if (spawnBehaviourOptions == null || spawnBehaviourOptions.size() <= 0)
		{
			return null;
		}

		int attempts = 0;
		int maxAttempts = 50;
		int optionAmount = spawnBehaviourOptions.size();
		double defaultChance = (1d / ((double) optionAmount));

		// roll for x amount of times to select the option
		// TODO: see how this impacts the selection?
		while (attempts++ < maxAttempts)
		{
			for (EbsSpawnOption option : spawnBehaviourOptions)
			{
				Double chance = option.chance;
				Double validatedChance = (chance == null ? defaultChance : chance);

				// choose this option when the chance is not known or when the roll landed
				if (MarketplaceRandomizers.rollChance(validatedChance))
				{
					return option;
				}
			}
		}

		// get the first is no valid one is found
		return spawnBehaviourOptions.get(0);
	}
}

package com.twitchliveloadout.marketplace.spawns;

import com.twitchliveloadout.marketplace.MarketplaceEffect;
import com.twitchliveloadout.marketplace.MarketplaceEffectManager;
import com.twitchliveloadout.marketplace.products.EbsModelOverheadFrame;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.client.ui.overlay.OverlayManager;

import static com.twitchliveloadout.marketplace.MarketplaceConstants.*;

@Slf4j
public class SpawnOverheadManager extends MarketplaceEffectManager<EbsModelOverheadFrame> {
	private final OverlayManager overlayManager;
	private final OverheadTextOverlay overheadTextOverlay;

	public SpawnOverheadManager(Client client, OverlayManager overlayManager)
	{
		super(SPAWN_OVERHEAD_EFFECT_MAX_SIZE);

		this.overlayManager = overlayManager;
		this.overheadTextOverlay = new OverheadTextOverlay(client);

		// initialize the overlay
		overlayManager.add(overheadTextOverlay);
	}

	public void onGameTick()
	{
		updateEffects();
	}

	@Override
	protected void applyEffect(MarketplaceEffect<EbsModelOverheadFrame> effect)
	{
		String text = effect.getFrame().text;

		// guard: skip when already applied
		if (effect.isApplied())
		{
			return;
		}

		// add to the overlay when there is a text
		if (text != null && !text.isEmpty())
		{
			overheadTextOverlay.addEffect(effect);
		}
	}

	@Override
	protected void restoreEffect(MarketplaceEffect<EbsModelOverheadFrame> effect)
	{

		// guard: skip when already restored
		if (!effect.isApplied())
		{
			return;
		}

		// always attempt to remove the effect
		overheadTextOverlay.removeEffect(effect);
	}

	@Override
	protected void onAddEffect(MarketplaceEffect<EbsModelOverheadFrame> effect)
	{
		// empty
	}

	@Override
	protected void onDeleteEffect(MarketplaceEffect<EbsModelOverheadFrame> effect)
	{
		// empty
	}

	public void removeOverlay()
	{
		overlayManager.remove(overheadTextOverlay);
	}
}


package com.twitchliveloadout.marketplace.spawns;

import lombok.Getter;
import lombok.Setter;
import net.runelite.api.Client;
import net.runelite.api.WorldView;
import net.runelite.api.coords.LocalPoint;
import net.runelite.api.coords.WorldPoint;

@Getter
public class SpawnPoint {
	private final WorldPoint worldPoint;

	public SpawnPoint(WorldPoint worldPoint)
	{
		this.worldPoint = worldPoint;
	}

	public LocalPoint getLocalPoint(Client client)
	{
		final WorldView worldView = client.getTopLevelWorldView();
		final LocalPoint localPoint = LocalPoint.fromWorld(worldView, worldPoint);

		return localPoint;
	}

	public int getPlane()
	{
		return worldPoint.getPlane();
	}
}

package com.twitchliveloadout.marketplace.spawns;

import net.runelite.api.JagexColor;
import net.runelite.api.ModelData;

import lombok.extern.slf4j.Slf4j;

import java.awt.*;

import static com.twitchliveloadout.marketplace.MarketplaceConstants.RUNELITE_OBJECT_RADIUS_PER_TILE;

@Slf4j
public class SpawnUtilities {

	public static void scaleModel(ModelData model, double modelScale)
	{
		int modelSize = (int) (RUNELITE_OBJECT_RADIUS_PER_TILE * modelScale);

		model.cloneVertices();
		model.scale(modelSize, modelSize, modelSize);
	}

	public static void recolorAllFaces(ModelData model, Color color)
	{
		recolorAllFaces(model, color, 1.0d);
	}

	public static void recolorAllFaces(ModelData model, Color color, double brightness)
	{
		short[] faceColors = model.getFaceColors();

		for (int faceColorIndex = 0; faceColorIndex < faceColors.length; faceColorIndex++)
		{
			recolorFace(model, faceColorIndex, color, brightness);
		}
	}

	public static void recolorFace(ModelData model, int faceColorIndex, Color color, double brightness)
	{
		short[] faceColors = model.getFaceColors();
		int rgb = color.getRGB();

		if (faceColorIndex < 0 || faceColorIndex >= faceColors.length)
		{
			log.warn("An invalid face color index was requested for a recolor: ", faceColorIndex);
			return;
		}

		short faceColor = faceColors[faceColorIndex];
		model.cloneVertices();
		model.recolor(faceColor, JagexColor.rgbToHSL(rgb, brightness));
	}

	public static void rotateModel(ModelData modelData, double angleDegrees)
	{
		modelData.cloneVertices();

		double angleRadians = Math.toRadians(angleDegrees);
		for(int verticesIndex = 0; verticesIndex < modelData.getVerticesCount(); ++verticesIndex) {
			float[] xVertices = modelData.getVerticesX();
			float[] yVertices = modelData.getVerticesY();
			float[] zVertices = modelData.getVerticesZ();
			float x = xVertices[verticesIndex];
			float y = yVertices[verticesIndex];
			float z = zVertices[verticesIndex];

			xVertices[verticesIndex] = (float) (x*Math.cos(angleRadians) + z*Math.sin(angleRadians));
			yVertices[verticesIndex] = y;
			zVertices[verticesIndex] = (float) (z*Math.cos(angleRadians) - x*Math.sin(angleRadians));
		}
	}
}

package com.twitchliveloadout.marketplace.spawns;

import com.google.common.collect.EvictingQueue;
import com.twitchliveloadout.TwitchLiveLoadoutPlugin;
import com.twitchliveloadout.marketplace.MarketplaceManager;
import com.twitchliveloadout.marketplace.MarketplaceRandomizers;
import com.twitchliveloadout.marketplace.products.EbsModelPlacement;
import com.twitchliveloadout.marketplace.products.EbsRandomRange;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.*;
import net.runelite.api.coords.LocalPoint;
import net.runelite.api.coords.WorldArea;
import net.runelite.api.coords.WorldPoint;
import net.runelite.api.events.GameStateChanged;

import java.util.*;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.CopyOnWriteArrayList;

import static com.twitchliveloadout.marketplace.MarketplaceConstants.*;

@Slf4j
public class SpawnManager {
	private final TwitchLiveLoadoutPlugin plugin;
	private final Client client;
	private final MarketplaceManager manager;

	/**
	 * Lookup to see which world points are taken for future spawns
	 */
	private final ConcurrentHashMap<WorldPoint, CopyOnWriteArrayList<SpawnedObject>> objectPlacements = new ConcurrentHashMap<>();

	/**
	 * History of all the previous player tiles used for spawning relative to previous locations
	 */
	private EvictingQueue<WorldPoint> playerLocationHistory = EvictingQueue.create(PLAYER_TILE_HISTORY_SIZE);

	public SpawnManager(TwitchLiveLoadoutPlugin plugin, Client client, MarketplaceManager manager)
	{
		this.plugin = plugin;
		this.client = client;
		this.manager = manager;
	}

	/**
	 * Check if any active products need to be respawned in the scene
	 */
	public void respawnRequested()
	{
		ArrayList<SpawnedObject> respawnQueue = new ArrayList<>();

		// loop all spawned objects and check whether they should respawn
		handleAllSpawnedObjects((spawnedObject) -> {

			// only respawn if in viewport and a respawn is required
			// to prevent animations to be reset all the time
			if (spawnedObject.isRespawnRequired() && spawnedObject.isInRegion()) {
				respawnQueue.add(spawnedObject);
				spawnedObject.setRespawnRequired(false);
			}
		});

		// guard: skip the queue when it is empty
		if (respawnQueue.size() <= 0)
		{
			return;
		}

		// run all respawns at the same time
		plugin.runOnClientThread(() -> {
			for (SpawnedObject spawnedObject : respawnQueue)
			{
				spawnedObject.respawn();
			}
		});
	}

	public void onGameStateChanged(GameStateChanged gameStateChanged)
	{
		GameState newGameState = gameStateChanged.getGameState();

		// only respawn on the loading event
		// this means all spawned objects are removed from the scene
		// and need to be queued for a respawn, this is done periodically
		if (newGameState == GameState.LOADING)
		{
			registerDespawn();
		}
	}

	/**
	 * Register all spawned objects to require a respawn to show them again.
	 */
	private void registerDespawn()
	{
		// set all objects to require a respawn, because after a loading of
		// a new scene all custom objects are cleared
		handleAllSpawnedObjects((spawnedObject) -> {
			spawnedObject.setRespawnRequired(true);
		});
	}

	public void recordPlayerLocation()
	{
		LocalPoint currentLocalPoint = client.getLocalPlayer().getLocalLocation();
		WorldPoint currentWorldPoint = WorldPoint.fromLocal(client, currentLocalPoint);

		// guard: check if this location is already at the end of the cyclic list
		if (currentWorldPoint.equals(getCurrentPlayerLocation()))
		{
			return;
		}

		playerLocationHistory.add(currentWorldPoint);
	}

	public WorldPoint getCurrentPlayerLocation()
	{
		return getPlayerLocationByHistoryOffset(0);
	}

	public WorldPoint getPreviousPlayerLocation()
	{
		return getPlayerLocationByHistoryOffset(1);
	}

	private WorldPoint getPlayerLocationByHistoryOffset(int offset)
	{
		int size = playerLocationHistory.size();
		int requestedIndex = size - 1 - offset;

		// guard: make sure the index is valid
		if (requestedIndex < 0 || requestedIndex >= size)
		{
			return null;
		}

		WorldPoint requestedWorldPoint = playerLocationHistory.toArray(new WorldPoint[size])[requestedIndex];
		return requestedWorldPoint;
	}

	/**
	 * Register a collection of spawned objects to the placement lookup for easy access
	 * to all spawned objects and to keep track of which tiles are taken.
	 */
	public void registerSpawnedObjectPlacement(SpawnedObject spawnedObject)
	{
		WorldPoint worldPoint = spawnedObject.getSpawnPoint().getWorldPoint();

		// check whether this world point already has a spawned object to add to
		if (objectPlacements.containsKey(worldPoint)) {
			CopyOnWriteArrayList<SpawnedObject> existingObjects = objectPlacements.get(worldPoint);
			existingObjects.add(spawnedObject);
		} else {
			CopyOnWriteArrayList<SpawnedObject> existingObjects = new CopyOnWriteArrayList<>();
			existingObjects.add(spawnedObject);
			objectPlacements.put(worldPoint, existingObjects);
		}
	}

	/**
	 * Remove a collection of spawned objects from the placement lookup.
	 */
	public void deregisterSpawnedObjectPlacement(SpawnedObject spawnedObject)
	{
		WorldPoint worldPoint = spawnedObject.getSpawnPoint().getWorldPoint();

		// guard: check if the placements are known
		if (!objectPlacements.containsKey(worldPoint))
		{
			return;
		}

		// remove from the existing spawned objects
		CopyOnWriteArrayList<SpawnedObject> existingObjects = objectPlacements.get(worldPoint);
		existingObjects.remove(spawnedObject);

		// remove the placement if empty so this world point is free again
		if (existingObjects.size() <= 0)
		{
			objectPlacements.remove(worldPoint);
		}
	}

	public void moveSpawnedObject(SpawnedObject spawnedObject, SpawnPoint newSpawnPoint)
	{
		SpawnPoint previousSpawnPoint = spawnedObject.getSpawnPoint();

		// guard: make sure the spawn point really changed
		if (previousSpawnPoint.getWorldPoint().equals(newSpawnPoint.getWorldPoint()))
		{
			return;
		}

		// first deregister BEFORE changing the spawn point
		deregisterSpawnedObjectPlacement(spawnedObject);

		// update the spawn point
		spawnedObject.setSpawnPoint(newSpawnPoint);

		// (re)register to the updated one
		registerSpawnedObjectPlacement(spawnedObject);

		// finally re-render the object
		spawnedObject.respawn();
	}

	/**
	 * Shortcut to loop all the spawned objects
	 */
	public void handleAllSpawnedObjects(MarketplaceManager.SpawnedObjectHandler handler)
	{
		for (CopyOnWriteArrayList<SpawnedObject> spawnedObjects : objectPlacements.values())
		{
			Iterator<SpawnedObject> spawnedObjectIterator = spawnedObjects.iterator();

			while (spawnedObjectIterator.hasNext())
			{
				SpawnedObject spawnedObject = spawnedObjectIterator.next();

				handler.execute(spawnedObject);
			}
		}
	}

	public SpawnPoint getOutwardSpawnPoint(int minRadius, int maxRadius, int radiusStepSize, boolean inLineOfSight, boolean avoidExistingSpawns, boolean avoidPlayerLocation, boolean avoidInvalidOverlay, WorldPoint referenceWorldPoint)
	{
		for (int radius = minRadius; radius <= maxRadius; radius++)
		{
			int randomizedRadius = radius + (int) Math.round(Math.random() * ((float) radiusStepSize));
			int usedRadius = Math.min(randomizedRadius, maxRadius);
			SpawnPoint candidateSpawnPoint = getSpawnPoint(usedRadius, usedRadius, inLineOfSight, avoidExistingSpawns, avoidPlayerLocation, avoidInvalidOverlay, referenceWorldPoint);

			if (candidateSpawnPoint != null) {
				return candidateSpawnPoint;
			}
		}

		return null;
	}

	public SpawnPoint getSpawnPoint(EbsModelPlacement placement, WorldPoint modelWorldPoint)
	{

		// make sure there are valid placement parameters
		if (placement == null)
		{
			placement = new EbsModelPlacement();
		}

		EbsRandomRange radiusRange = placement.radiusRange;
		int minRadius = (int) (radiusRange == null ? DEFAULT_MIN_RADIUS : radiusRange.min);
		int maxRadius = (int) MarketplaceRandomizers.getValidRandomNumberByRange(radiusRange, DEFAULT_MIN_RADIUS, DEFAULT_MAX_RADIUS, ABSOLUTE_MIN_RADIUS, ABSOLUTE_MAX_RADIUS);
		int radiusStepSize  = placement.radiusStepSize;
		String radiusType = placement.radiusType;
		String locationType = placement.locationType;
		Boolean inLineOfSight = placement.inLineOfSight;
		Boolean avoidExistingSpawns = placement.avoidExistingSpawns;
		Boolean avoidPlayerLocation = placement.avoidPlayerLocation;
		Boolean avoidInvalidOverlay = placement.avoidInvalidOverlay;
		Integer worldPointX = placement.worldPointX;
		Integer worldPointY = placement.worldPointY;
		Integer deltaPointX = placement.deltaPointX;
		Integer deltaPointY = placement.deltaPointY;
		Integer worldPointPlane = placement.worldPointPlane;
		WorldPoint referenceWorldPoint = client.getLocalPlayer().getWorldLocation();

		if (manager.isChaosModeActive())
		{
			// only multiply the maximum radius, because we want to keep the minimum intact
			maxRadius *= manager.getConfig().chaosModeRangeMultiplier();
		}

		// check if we should change the reference to the previous tile
		// NOTE: current tile is not needed to be handled, because this is the default!
		if (PREVIOUS_TILE_LOCATION_TYPE.equals(locationType))
		{
			referenceWorldPoint = getPreviousPlayerLocation();

			if (referenceWorldPoint == null)
			{
				return null;
			}
		}

		if (MODEL_TILE_LOCATION_TYPE.equals(locationType) && modelWorldPoint != null)
		{
			referenceWorldPoint = modelWorldPoint;
		}

		if (ABSOLUTE_TILE_LOCATION_TYPE.equals(locationType)  && worldPointX != null && worldPointY != null)
		{
			if (worldPointPlane == null)
			{
				worldPointPlane = client.getTopLevelWorldView().getPlane();
			}

			referenceWorldPoint = new WorldPoint(worldPointX, worldPointY, worldPointPlane);
		}

		if (deltaPointX != null)
		{
			referenceWorldPoint = referenceWorldPoint.dx(deltaPointX);
		}

		if (deltaPointY != null)
		{
			referenceWorldPoint = referenceWorldPoint.dy(deltaPointY);
		}

		if (NO_RADIUS_TYPE.equals(radiusType))
		{
			return new SpawnPoint(referenceWorldPoint);
		}

		if (OUTWARD_RADIUS_TYPE.equals(radiusType))
		{
			return getOutwardSpawnPoint(minRadius, maxRadius, radiusStepSize, inLineOfSight, avoidExistingSpawns, avoidPlayerLocation, avoidInvalidOverlay, referenceWorldPoint);
		}

		return getSpawnPoint(minRadius, maxRadius, inLineOfSight, avoidExistingSpawns, avoidPlayerLocation, avoidInvalidOverlay, referenceWorldPoint);
	}

	public SpawnPoint getSpawnPoint(int minRadius, int maxRadius, boolean inLineOfSight, boolean avoidExistingSpawns, boolean avoidPlayerLocation, boolean avoidInvalidOverlay, WorldPoint referenceWorldPoint)
	{
		final ArrayList<SpawnPoint> candidateSpawnPoints = new ArrayList<>();
		final int[][] collisionFlags = getSceneCollisionFlags();
		final Player player = client.getLocalPlayer();
		final WorldView worldView = client.getTopLevelWorldView();
		final WorldArea playerArea = player.getWorldArea();
		final WorldPoint playerWorldPoint = player.getWorldLocation();

		// make sure the reference WORLD point is always valid
		if (referenceWorldPoint == null)
		{
			referenceWorldPoint = playerWorldPoint;
		}

		// make sure the max radius is valid
		if (maxRadius < minRadius)
		{
			maxRadius = minRadius;
		}

		LocalPoint referenceLocalPoint = LocalPoint.fromWorld(worldView, referenceWorldPoint);

		// guard: make sure the LOCAL point is always valid
		if (referenceLocalPoint == null)
		{
			referenceLocalPoint = client.getLocalPlayer().getLocalLocation();
		}
		
		final int plane = referenceWorldPoint.getPlane();
		final Scene scene = worldView.getScene();
		final short[][][] overlayIds = scene.getOverlayIds();
		final short[][][] underlayIds = scene.getUnderlayIds();
		final int sceneX = referenceLocalPoint.getSceneX();
		final int sceneY = referenceLocalPoint.getSceneY();

		// loop all the possible tiles for the requested radius and look for
		// the candidate tiles to spawn the object on
		for (int deltaX = -1 * maxRadius; deltaX <= maxRadius; deltaX++) {
			for (int deltaY = -1 * maxRadius; deltaY <= maxRadius; deltaY++) {
				int sceneAttemptX = sceneX + deltaX;
				int sceneAttemptY = sceneY + deltaY;
				double deltaDiagonal = Math.sqrt(Math.pow(deltaX, 2) + Math.pow(deltaY, 2));

				// guard: skip all tiles that are not distant enough
				if (Math.abs(deltaX) < minRadius && Math.abs(deltaY) < minRadius && deltaDiagonal < minRadius)
				{
					continue;
				}

				// guard: make sure the tile has collision flags
				if (
					sceneAttemptX < 0
					|| sceneAttemptX >= collisionFlags.length
					|| sceneAttemptY < 0
					|| sceneAttemptY >= collisionFlags[sceneAttemptX].length
				) {
					continue;
				}

				int flagData = collisionFlags[sceneAttemptX][sceneAttemptY];
				int blockedFlags = CollisionDataFlag.BLOCK_MOVEMENT_FULL;
				boolean isWalkable = (flagData & blockedFlags) == 0;
				int underlayOverlayIdOffset = (Constants.EXTENDED_SCENE_SIZE - Constants.SCENE_SIZE) / 2;
				int underlayOverlayAttemptX = sceneAttemptX + underlayOverlayIdOffset;
				int underlayOverlayAttemptY = sceneAttemptY + underlayOverlayIdOffset;
				short underlayId = underlayIds[plane][underlayOverlayAttemptX][underlayOverlayAttemptY];
				short overlayId = overlayIds[plane][underlayOverlayAttemptX][underlayOverlayAttemptY];
				boolean isBlackOnMinimap = (avoidInvalidOverlay && underlayId == 0 && overlayId == 0);

				// guard: make sure the tile is walkable
				if (!isWalkable || isBlackOnMinimap)
				{
					continue;
				}

				LocalPoint localPoint = LocalPoint.fromScene(sceneAttemptX, sceneAttemptY, scene);
				WorldPoint worldPoint = WorldPoint.fromLocal(client, localPoint);

				// guard: check if this world point is already taken by another spawned object
				if (avoidExistingSpawns && objectPlacements.containsKey(worldPoint))
				{
					continue;
				}

				// guard: skip candidates that are the current player location
				// because when rendering the model it is always on top of the player
				// which is almost always not looking very nice
				if (avoidPlayerLocation && worldPoint.equals(playerWorldPoint))
				{
					continue;
				}

				// guard: make sure the tile is in line of sight
				if (inLineOfSight && !playerArea.hasLineOfSightTo(client.getTopLevelWorldView(), worldPoint))
				{
					continue;
				}

				// we have found a walkable tile to spawn the object on
				candidateSpawnPoints.add(new SpawnPoint(worldPoint));
			}
		}

		// guard: make sure there are candidate spawn points to prevent the
		// random selection of one to trigger errors
		if (candidateSpawnPoints.size() <= 0)
		{
			return null;
		}

		final Random spawnPointSelector = new Random();
		final int spawnPointIndex = spawnPointSelector.nextInt(candidateSpawnPoints.size());
		final SpawnPoint spawnPoint = candidateSpawnPoints.get(spawnPointIndex);

		return spawnPoint;
	}

	private int[][] getSceneCollisionFlags() {
		WorldView worldView = client.getTopLevelWorldView();
		final CollisionData[] collisionMaps = worldView.getCollisionMaps();
		int[][] collisionFlags = new int[Constants.SCENE_SIZE][Constants.SCENE_SIZE];
		int plane = worldView.getPlane();

		// if we have map collision flags we populate the starting point with them
		if (collisionMaps != null) {
			collisionFlags = collisionMaps[plane].getFlags();
		}

		return collisionFlags;
	}
}

package com.twitchliveloadout.marketplace.spawns;

import com.twitchliveloadout.marketplace.*;
import com.twitchliveloadout.marketplace.products.*;
import lombok.Getter;
import lombok.Setter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.*;
import net.runelite.api.coords.LocalPoint;
import net.runelite.api.coords.WorldPoint;
import net.runelite.api.geometry.SimplePolygon;
import net.runelite.api.model.Jarvis;

import java.awt.*;
import java.time.Instant;
import java.util.ArrayList;
import java.util.concurrent.ConcurrentHashMap;

import static com.twitchliveloadout.marketplace.MarketplaceConstants.*;
import static net.runelite.api.Perspective.COSINE;
import static net.runelite.api.Perspective.SINE;

@Slf4j
public class SpawnedObject {

	@Getter
	private final Instant spawnedAt;

	@Getter
	private final Client client;

	@Getter
	private final RuneLiteObject object;

	@Getter
	private final EbsSpawn spawn;

	@Getter
	private EbsModelSet modelSet;

	@Getter
	private ModelData modelData;

	@Getter
	@Setter
	private SpawnPoint spawnPoint;

	@Getter
	private final MarketplaceProduct product;

	@Getter
	@Setter
	private boolean respawnRequired = false;

	@Getter
	private Instant expiredAt;

	@Getter
	private int randomEffectCounter = 0;

	@Getter
	private Instant lastRandomEffectAt;

	private double currentScale = -1;
	private double currentRotationDegrees = 0;
	private int currentTranslateX = 0;
	private int currentTranslateY = 0;
	private int currentTranslateZ = 0;
	private int currentAnimationId;
	private Instant lockAnimationUntil;

	private final ConcurrentHashMap<String, String> stateFrameValues = new ConcurrentHashMap<>();

	public SpawnedObject(MarketplaceProduct product, Client client, SpawnPoint spawnPoint, EbsSpawn spawn, EbsModelSet modelSet, Instant expiredAt)
	{
		this.spawnedAt = Instant.now();
		this.product = product;
		this.client = client;
		this.object = client.createRuneLiteObject();
		this.spawnPoint = spawnPoint;
		this.spawn = spawn;
		this.modelSet = modelSet;
		this.expiredAt = expiredAt;

		// first initialize the model set so we have proper model data
		// for the next initialisation methods
		updateModelSet(false);

		// setup one time settings
		initializeObject();

		// reset the animations to it will immediately show the idle animation if available
		resetAnimation();

		// set to initial spawn-point
		updateLocation();
	}

	public void setModelSet(EbsModelSet modelSet)
	{

		// guard: make sure the new one is valid
		if (modelSet == null)
		{
			return;
		}

		this.modelSet = modelSet;
	}

	public void updateModelSet(boolean preserveTransforms)
	{

		// guard: make sure the selected model set is valid
		if (modelSet == null)
		{
			return;
		}

		// get properties from model set
		ArrayList<Integer> modelIds = modelSet.ids;
		EbsModelPlacement modelPlacement = spawn.modelPlacement;
		EbsTranslation modelSetTranslation = modelSet.translation;

		if (modelPlacement == null)
		{
			modelPlacement = new EbsModelPlacement();
		}

		EbsTranslation modelPlacementTranslation = modelPlacement.translation;
		int translateX = mergeTranslations(TRANSLATE_X_AXIS, modelSetTranslation, modelPlacementTranslation);
		int translateY = mergeTranslations(TRANSLATE_Y_AXIS, modelSetTranslation, modelPlacementTranslation);
		int translateZ = mergeTranslations(TRANSLATE_Z_AXIS, modelSetTranslation, modelPlacementTranslation);
		double modelScale = MarketplaceRandomizers.getValidRandomNumberByRange(modelSet.scale, 1, 1, 0, MAX_MODEL_SCALE);
		double modelRotationDegrees = MarketplaceRandomizers.getValidRandomNumberByRange(modelPlacement.rotation, 0, 360, 0, 360);
		ArrayList<EbsRecolor> recolors = modelSet.recolors;
		ArrayList<ModelData> modelDataChunks = new ArrayList<>();
		boolean shouldScaleModel = (modelSet.scale != null);
		boolean shouldRotateModel = !NO_ROTATION_TYPE.equals(modelPlacement.rotationType);
		boolean shouldTranslateModel = (translateX != 0 || translateY != 0 || translateZ != 0);

		// load all the models if set
		if (modelIds != null)
		{
			modelIds.forEach((modelId) -> {
				modelDataChunks.add(client.loadModelData(modelId));
			});

			// merge all models into one
			modelData = client.mergeModels(modelDataChunks.toArray(new ModelData[modelDataChunks.size()]), modelDataChunks.size());
		}

		// guard: make sure the model data is valid before doing anything else
		if (modelData == null)
		{
			return;
		}

		// check for valid recolors
		if (recolors != null)
		{
			modelData.cloneColors();

			// apply recolors
			LambdaIterator.handleAll(recolors, (recolor) -> {
				recolor(recolor);
			});
		}

		// scale model
		// NOTE: don't include with preserve transform, because different model IDs might require a different scale
		if (shouldScaleModel) {
			scale(modelScale, false);
		}

		// rotate model
		if (preserveTransforms) {
			rotate(currentRotationDegrees, true);
		} else if (shouldRotateModel) {
			rotate(modelRotationDegrees, false);
		}

		// set the position
		// NOTE: don't include with preserve transform, because different model IDs might require a different scale
		if (shouldTranslateModel) {
			translate(translateX, translateY, translateZ, false);
		}

		// re-render after changes
		render();
	}

	private int mergeTranslations(String translateAxis, EbsTranslation translationOne, EbsTranslation translationTwo)
	{
		EbsRandomRange rangeOne = getTranslationRandomRange(translateAxis, translationOne);
		EbsRandomRange rangeTwo = getTranslationRandomRange(translateAxis, translationTwo);
		int amountOne = (int) MarketplaceRandomizers.getValidRandomNumberByRange(rangeOne, 0, 0, MIN_MODEL_TRANSLATE, MAX_MODEL_TRANSLATE);
		int amountTwo = (int) MarketplaceRandomizers.getValidRandomNumberByRange(rangeTwo, 0, 0, MIN_MODEL_TRANSLATE, MAX_MODEL_TRANSLATE);

		return amountOne + amountTwo;
	}

	private EbsRandomRange getTranslationRandomRange(String translateAxis, EbsTranslation translation)
	{

		// guard: make sure the passed params are valid
		if (translateAxis == null || translation == null)
		{
			return null;
		}

		switch (translateAxis)
		{
			case TRANSLATE_X_AXIS:
				return translation.x;
			case TRANSLATE_Y_AXIS:
				return translation.y;
			case TRANSLATE_Z_AXIS:
				return translation.z;
		}

		return null;
	}

	private void initializeObject()
	{
		object.setDrawFrontTilesFirst(true);
	}

	public void rotateTowards(LocalPoint targetPoint)
	{
		LocalPoint sourcePoint = spawnPoint.getLocalPoint(client);

		// guard: check if the source point is valid
		// if not that means it is not in the current scene
		if (sourcePoint == null)
		{
			return;
		}

		int deltaX = sourcePoint.getX() - targetPoint.getX();
		int deltaY = sourcePoint.getY() - targetPoint.getY();
		double angleRadians = Math.atan2(deltaX, deltaY);
		double angleDegrees = Math.toDegrees(angleRadians);

		rotate(angleDegrees, false);
	}

	public void translate(int x, int y, int z, boolean forceUpdate)
	{

		// guard: skip when there are no changes
		if (currentTranslateX == x && currentTranslateY == y && currentTranslateZ == z && !forceUpdate)
		{
			return;
		}

		currentTranslateX = x;
		currentTranslateY = y;
		currentTranslateZ = z;

		modelData.cloneVertices();
		modelData.translate(x, y, z);
	}

	public void rotate(double angleDegrees, boolean forceUpdate)
	{

		// guard: skip rotation if already rotated like this for performance
		if (currentRotationDegrees == angleDegrees && !forceUpdate)
		{
			return;
		}

		currentRotationDegrees = angleDegrees;

		// make sure rotation is not negative
		if (angleDegrees < 0) {
			angleDegrees = 360 + (angleDegrees % 360);
		}

		// make sure there are no multiple rotations
		if (angleDegrees > 360) {
			angleDegrees = angleDegrees % 360;
		}

		int orientation = (int) (angleDegrees * MarketplaceConstants.RUNELITE_OBJECT_FULL_ROTATION / 360d);
		setOrientation(orientation);
	}

	public void setOrientation(int orientation)
	{
		object.setOrientation(orientation);
	}

	public void scale(double scale, boolean forceUpdate)
	{
		int roundedScale = (int) scale;

		// guard: check if the scale is valid and changed
		if (roundedScale < 0 || (scale == currentScale && !forceUpdate))
		{
			return;
		}

		currentScale = scale;
		modelData.cloneVertices();
		modelData.scale(roundedScale, roundedScale, roundedScale);

		// only set the radius when it is set, because some radius values
		// can cause major frame drops, for this reason it needs to be tested
		// and hard-coded in the config and never automatically set!
		if (modelSet.scalePerOneTile != null)
		{
			double scalePerOneTile = modelSet.scalePerOneTile;
			double tileRadius = scale / scalePerOneTile;
			int radius = (int) (RUNELITE_OBJECT_RADIUS_PER_TILE * tileRadius);

			object.setRadius(radius);
		}
	}

	/**
	 * Recolor the model data through an EBS configured recolor.
	 * Note that cloning the colors and re-rendering the object is needed manually outside of this method!
	 */
	private void recolor(EbsRecolor recolor)
	{

		// guard: make sure the model and recolor is valid
		if (recolor == null || modelData == null)
		{
			return;
		}

		Integer sourceColorIndex = recolor.sourceColorIndex;
		Integer sourceColorHsl = recolor.sourceColorHsl;
		Integer targetColorHsl = recolor.targetColorHsl;
		Integer targetColorHex = recolor.targetColorHex;

		// check if a hex target color is passed which needs to be converted
		// NOTE: when also a HSL is padded the HSL takes priority
		if (targetColorHsl == null && targetColorHex != null)
		{
			targetColorHsl = MarketplaceColors.getColorHsl(targetColorHex);
		}

		// guard: skip when target is not valid
		if (targetColorHsl == null)
		{
			return;
		}

		// determine whether an index, specific color or everything is requested to be changed
		if (sourceColorHsl != null) {
			recolorByColor(sourceColorHsl, targetColorHsl);
		} else if (isValidColorIndex(sourceColorIndex)) {
			recolorByIndex(sourceColorIndex, targetColorHsl);
		} else {

			// recolor the whole model
			for (short color : modelData.getFaceColors())
			{
				recolorByColor(color, targetColorHsl);
			}
		}
	}

	private void recolorByColor(int sourceColorHsl, int targetColorHsl)
	{

		// guard: make sure the model is valid
		if (modelData == null)
		{
			return;
		}

		modelData.recolor((short) sourceColorHsl, (short) targetColorHsl);
	}

	private void recolorByIndex(int sourceColorIndex, int targetColorHsl)
	{

		// guard: make sure the index and color are valid
		if (!isValidColorIndex(sourceColorIndex))
		{
			return;
		}

		short[] colors = modelData.getFaceColors();
		short sourceColorHsl = colors[sourceColorIndex];

		modelData.recolor(sourceColorHsl, (short) targetColorHsl);
	}

	private boolean isValidColorIndex(int colorIndex)
	{
		// guard: make sure the model is valid
		if (modelData == null)
		{
			return false;
		}

		return colorIndex >= 0 && colorIndex < modelData.getFaceColors().length;
	}

	public void setAnimation(int animationId, boolean shouldLoop)
	{
		Animation animation = null;

		// guard: skip when the current animation
		if  (animationId == currentAnimationId)
		{
			return;
		}

		if (animationId >= 0)
		{
			animation = client.loadAnimation(animationId);
		}

		object.setShouldLoop(shouldLoop);
		object.setAnimation(animation);
		currentAnimationId = animationId;
	}

	public boolean isAnimationLocked()
	{
		return (lockAnimationUntil != null && Instant.now().isBefore(lockAnimationUntil));
	}

	public void lockAnimationUntil(long durationMs)
	{
		lockAnimationUntil = Instant.now().plusMillis(durationMs);
	}

	public void resetAnimation()
	{
		int idleAnimationId = getMovementAnimations().idle;

		// guard: set to no animation when there is no idle animation
		if (idleAnimationId < 0)  {
			setAnimation(-1, false);
			return;
		}

		setAnimation(idleAnimationId, true);
	}

	public EbsMovementFrame getMovementAnimations()
	{
		if (spawn.movementAnimations == null)
		{
			return new EbsMovementFrame();
		}

		return spawn.movementAnimations;
	}

	public String getStateFrameValue(String stateKey)
	{
		if (stateKey == null)
		{
			return null;
		}

		return stateFrameValues.get(stateKey);
	}

	public void setStateFrameValue(String stateKey, String stateValue)
	{
		if (stateKey == null)
		{
			return;
		}

		stateFrameValues.put(stateKey, stateValue);
	}

	public void show()
	{
		object.setActive(true);
		render();
	}

	public void hide()
	{
		object.setActive(false);
		object.setModel(null);
	}

	public boolean isInRegion()
	{
		return isInView(REGION_SIZE);
	}
	public boolean isInChunk()
	{
		return isInView(CHUNK_SIZE);
	}

	public boolean isInView(int radius)
	{
		final WorldPoint worldPoint = spawnPoint.getWorldPoint();
		final LocalPoint playerLocalPoint = client.getLocalPlayer().getLocalLocation();
		final WorldPoint playerWorldPoint = WorldPoint.fromLocal(client, playerLocalPoint);
		final int distanceToPlayer = worldPoint.distanceTo(playerWorldPoint);
		final boolean isInView = (distanceToPlayer <= radius);

		return isInView;
	}

	public void render()
	{

		// guard: make sure the model is valid
		if (modelData == null)
		{
			return;
		}

		object.setModel(modelData.light(64, 850, -30, -50, -30));
	}

	public void respawn()
	{

		// guard: location cannot be set to local point if not in region
		if (!isInRegion())
		{
			return;
		}

		// the location might've changed, so update
		updateLocation();

		// de-activate and re-activate again to force re-render
		hide();
		show();
	}

	public void updateLocation()
	{
		final LocalPoint localPoint = spawnPoint.getLocalPoint(client);
		final int plane = spawnPoint.getPlane();

		// guard: check if the point is valid
		// if not that means it is not in the current scene
		if (localPoint == null)
		{
			return;
		}

		// move the object to the new relative local point as the scene offset might be changed
		object.setLocation(localPoint, plane);
	}

	public void updateLastRandomEffectAt(boolean isTriggered)
	{
		EbsInterval randomInterval = spawn.randomEffectsInterval;
		Integer afterTriggerDelayMs = 0;

		// add extra time requested to delay the effect after a successful trigger
		if (randomInterval != null && isTriggered)
		{
			afterTriggerDelayMs = randomInterval.afterTriggerDelayMs;
		}

		lastRandomEffectAt = Instant.now().plusMillis(afterTriggerDelayMs);
	}

	public void registerRandomEffect()
	{
		randomEffectCounter += 1;
		updateLastRandomEffectAt(true);
	}

	public void expireNow()
	{
		expiredAt = Instant.now();
	}

	public boolean isExpired()
	{
		return expiredAt != null && Instant.now().isAfter(expiredAt);
	}

	public SimplePolygon calculatePolygon()
	{
		LocalPoint localPoint = spawnPoint.getLocalPoint(client);
		WorldView worldView = client.getTopLevelWorldView();
		Model model = object.getModel();
		int jauOrient = object.getOrientation();
		int x = localPoint.getX();
		int y = localPoint.getY();
		int z = worldView.getPlane();
		int zOff = Perspective.getTileHeight(client, localPoint, z);
		AABB aabb = model.getAABB(jauOrient);

		int x1 = aabb.getCenterX();
		int y1 = aabb.getCenterZ();
		int z1 = aabb.getCenterY() + zOff;

		int ex = aabb.getExtremeX();
		int ey = aabb.getExtremeZ();
		int ez = aabb.getExtremeY();

		int x2 = x1 + ex;
		int y2 = y1 + ey;
		int z2 = z1 + ez;

		x1 -= ex;
		y1 -= ey;
		z1 -= ez;

		float[] xa = new float[]{
				x1, x2, x1, x2,
				x1, x2, x1, x2
		};
		float[] ya = new float[]{
				y1, y1, y2, y2,
				y1, y1, y2, y2
		};
		float[] za = new float[]{
				z1, z1, z1, z1,
				z2, z2, z2, z2
		};

		int[] x2d = new int[8];
		int[] y2d = new int[8];

		modelToCanvasCpu(client, 8, x, y, z, 0, xa, ya, za, x2d, y2d);
		return Jarvis.convexHull(x2d, y2d);
	}

	private static void modelToCanvasCpu(Client client, int end, int x3dCenter, int y3dCenter, int z3dCenter, int rotate, float[] x3d, float[] y3d, float[] z3d, int[] x2d, int[] y2d) {
		int cameraPitch = client.getCameraPitch();
		int cameraYaw = client.getCameraYaw();
		int pitchSin = SINE[cameraPitch];
		int pitchCos = COSINE[cameraPitch];
		int yawSin = SINE[cameraYaw];
		int yawCos = COSINE[cameraYaw];
		int rotateSin = SINE[rotate];
		int rotateCos = COSINE[rotate];
		int cx = x3dCenter - client.getCameraX();
		int cy = y3dCenter - client.getCameraY();
		int cz = z3dCenter - client.getCameraZ();
		int viewportXMiddle = client.getViewportWidth() / 2;
		int viewportYMiddle = client.getViewportHeight() / 2;
		int viewportXOffset = client.getViewportXOffset();
		int viewportYOffset = client.getViewportYOffset();
		int zoom3d = client.getScale();

		for(int i = 0; i < end; ++i) {
			int x = (int)x3d[i];
			int y = (int)y3d[i];
			int z = (int)z3d[i];
			int x1;
			if (rotate != 0) {
				x1 = x;
				x = x * rotateCos + y * rotateSin >> 16;
				y = y * rotateCos - x1 * rotateSin >> 16;
			}

			x += cx;
			y += cy;
			z += cz;
			x1 = x * yawCos + y * yawSin >> 16;
			int y1 = y * yawCos - x * yawSin >> 16;
			int y2 = z * pitchCos - y1 * pitchSin >> 16;
			int z1 = y1 * pitchCos + z * pitchSin >> 16;
			int viewX;
			int viewY;
			if (z1 < 50) {
				viewX = Integer.MIN_VALUE;
				viewY = Integer.MIN_VALUE;
			} else {
				viewX = viewportXMiddle + x1 * zoom3d / z1 + viewportXOffset;
				viewY = viewportYMiddle + y2 * zoom3d / z1 + viewportYOffset;
			}

			x2d[i] = viewX;
			y2d[i] = viewY;
		}

	}
}

package com.twitchliveloadout.marketplace.spawns;

import com.twitchliveloadout.marketplace.MarketplaceColors;
import com.twitchliveloadout.marketplace.MarketplaceEffect;
import com.twitchliveloadout.marketplace.MarketplaceMessages;
import com.twitchliveloadout.marketplace.products.EbsModelOverheadFrame;
import com.twitchliveloadout.marketplace.products.MarketplaceProduct;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.Perspective;
import net.runelite.api.Point;
import net.runelite.api.WorldView;
import net.runelite.api.coords.LocalPoint;
import net.runelite.client.ui.FontManager;
import net.runelite.client.ui.overlay.*;

import java.awt.*;
import java.util.Iterator;
import java.util.concurrent.CopyOnWriteArrayList;

@Slf4j
public class OverheadTextOverlay extends Overlay {
	private final Client client;
	private final CopyOnWriteArrayList<MarketplaceEffect<EbsModelOverheadFrame>> activeEffects = new CopyOnWriteArrayList<>();

	public OverheadTextOverlay(Client client)
	{
		this.client = client;

		setMovable(false);
		setPosition(OverlayPosition.TOP_LEFT);
		setLayer(OverlayLayer.ABOVE_SCENE);
		setPriority(Overlay.PRIORITY_HIGHEST);
	}

	@Override
	public Dimension render(Graphics2D graphics)
	{
		Iterator<MarketplaceEffect<EbsModelOverheadFrame>> effectIterator = activeEffects.iterator();

		while (effectIterator.hasNext())
		{
			MarketplaceEffect<EbsModelOverheadFrame> effect = effectIterator.next();
			EbsModelOverheadFrame frame = effect.getFrame();
			String text = frame.text;
			Integer textHeight = frame.textHeight;
			Integer textColorHex = frame.textColorHex;
			SpawnedObject spawnedObject = effect.getSpawnedObject();
			MarketplaceProduct marketplaceProduct = effect.getMarketplaceProduct();

			// guard: ensure the effect is still active
			if (!effect.isActive())
			{
				continue;
			}

			// guard: make sure text and location are valid
			if (text == null || text.isEmpty() || textHeight == null || textColorHex == null || spawnedObject == null)
			{
				continue;
			}

			String formattedText = MarketplaceMessages.formatMessage(text, marketplaceProduct, effect);
			LocalPoint localPoint = spawnedObject.getSpawnPoint().getLocalPoint(client);

			// guard: check if the local point is still valid
			// it is possible it became invalid while the player is
			// teleporting and the spawned object is still in in its old place
			if (localPoint == null)
			{
				continue;
			}

			WorldView worldView = client.getTopLevelWorldView();
			Point textLocation = Perspective.localToCanvas(client, localPoint, worldView.getPlane(), textHeight);
			Color textColor = MarketplaceColors.getColorByHex(textColorHex);

			// guard: ensure a valid location for the text rendering
			if (textLocation == null)
			{
				continue;
			}

			Font chatFont = FontManager.getRunescapeBoldFont();
			FontMetrics metrics = graphics.getFontMetrics(chatFont);
			Point centeredTextLocation = new Point(textLocation.getX() - (metrics.stringWidth(formattedText) >>> 1), textLocation.getY());

			// guard: ensure a valid centered text location
			if (centeredTextLocation == null)
			{
				continue;
			}

			graphics.setFont(chatFont);
			OverlayUtil.renderTextLocation(graphics, centeredTextLocation, formattedText, textColor);
		}

		return null;
	}

	public void addEffect(MarketplaceEffect<EbsModelOverheadFrame> effect)
	{
		activeEffects.add(effect);
	}

	public void removeEffect(MarketplaceEffect<EbsModelOverheadFrame> effect)
	{
		activeEffects.remove(effect);
	}
}

package com.twitchliveloadout.marketplace.transactions;

import lombok.Getter;

@Getter
public enum TwitchTransactionProductType {
    BITS_IN_EXTENSION("BITS_IN_EXTENSION"),
    TEST("TEST"),
    FREE("FREE"),
    MANUAL("MANUAL"),
    ;

    final String type;

    TwitchTransactionProductType(String type) {
        this.type = type;
    }
}

package com.twitchliveloadout.marketplace.transactions;

import lombok.Getter;

@Getter
public enum TwitchTransactionOrigin {
    EBS("ebs"),
    EVENT_SUB("event_sub"),
    MANUAL("manual"),
    TEST("test"),
    FREE("free"),
    CHARITY("charity"),
    ;

    final String type;

    TwitchTransactionOrigin(String type) {
        this.type = type;
    }
}

package com.twitchliveloadout.marketplace.transactions;

import com.twitchliveloadout.marketplace.products.TwitchProduct;
import com.twitchliveloadout.twitch.eventsub.TwitchEventSubType;
import com.twitchliveloadout.twitch.eventsub.messages.BaseMessage;

import java.time.Instant;

public class TwitchTransaction {
	public String id;
	public String timestamp;
	public String broadcaster_id;
	public String broadcaster_login;
	public String broadcaster_name;
	public String user_id;
	public String user_login;
	public String user_name;
	public String product_type;
	public TwitchProduct product_data;
	public String ebs_product_id;
	public String handled_at;
	public final String loaded_at = Instant.now().toString();

	// support for alternative sources and extra information about them
	public TwitchTransactionOrigin origin = TwitchTransactionOrigin.EBS;
	public TwitchEventSubType eventSubType = null;
	public BaseMessage eventSubMessage = null;

	public boolean isEventSubTransaction()
	{
		return eventSubType != null && eventSubMessage != null;
	}

	public boolean isCurrencyTransaction()
	{
		return !isEventSubTransaction() && product_data != null && product_data.cost != null;
	}

	public boolean isFreeTransaction()
	{
		return TwitchTransactionProductType.FREE.getType().equals(product_type);
	}

	public boolean isTestTransaction()
	{
		return product_type.equals(TwitchTransactionProductType.TEST.getType());
	}

	public boolean isManualTransaction()
	{
		return product_type.equals(TwitchTransactionProductType.MANUAL.getType());
	}
}

package com.twitchliveloadout.marketplace;

import java.time.Duration;

public class MarketplaceDuration {
	public static String humanizeDurationMs(long ms)
	{
		long seconds = ms / 1000;
		return humanizeDuration(Duration.ofSeconds(seconds));
	}

	public static String humanizeDurationRounded(Duration duration)
	{
		// round up if there are a few nano seconds (at least 1ms) left as well, this creates the best
		// representation of the duration that is to be shown.
		int nano = duration.getNano();
		Duration roundedDuration = Duration.ofSeconds(duration.getSeconds() + (nano > 1000 ? 1 : 0));

		return humanizeDuration(roundedDuration);
	}

	public static String humanizeDuration(Duration duration)
	{

		// guard: make sure the duration is valid
		if (duration == null)
		{
			return "0s";
		}

		return duration.toString()
			.substring(2)
			.replaceAll("(\\d[HMS])(?!$)", "$1 ")
			.toLowerCase();
	}
}

package com.twitchliveloadout.marketplace;

import com.twitchliveloadout.marketplace.products.EbsEffectFrame;
import com.twitchliveloadout.marketplace.products.MarketplaceProduct;
import com.twitchliveloadout.marketplace.spawns.SpawnedObject;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.GameState;
import net.runelite.api.events.GameStateChanged;

import java.time.Instant;
import java.util.Iterator;
import java.util.concurrent.CopyOnWriteArrayList;

@Slf4j
public abstract class MarketplaceEffectManager<FrameType extends EbsEffectFrame> {

	/**
	 * The maximum amount of effects allowed to be active at once.
	 */
	private final int maxEffectAmount;

	/**
	 * Tracking of all the effects by any widget frames from any product. They are stored here and not in the
	 * marketplace products because they can also originate from periodic effects, where the marketplace products
	 * are unaware of and have no way of tracking.
	 */
	protected final CopyOnWriteArrayList<MarketplaceEffect<FrameType>> effects = new CopyOnWriteArrayList<>();

	public MarketplaceEffectManager(int maxEffectAmount)
	{
		this.maxEffectAmount = maxEffectAmount;
	}

	public void updateEffects()
	{
		cleanInactiveEffects();
		applyActiveEffects();
	}

	public void onGameStateChanged(GameStateChanged gameStateChanged)
	{
		GameState newGameState = gameStateChanged.getGameState();

		// apply all effects to handle teleports and such triggering a loading screen
		if (newGameState == GameState.LOGGED_IN)
		{
			applyActiveEffects();
		}
	}

	public void addEffect(MarketplaceProduct product, FrameType frame, SpawnedObject spawnedObject)
	{

		// guard: make sure the maximum is not exceeded for security and performance reasons
		if (effects.size() >= maxEffectAmount)
		{
			return;
		}

		// guard: make sure the widget frame is valid
		if (product == null || frame == null)
		{
			return;
		}

		// by default the expiry time is linked to the product, but can be overridden with a custom duration
		Integer durationMs = frame.durationMs;
		Double durationPercentage = frame.durationPercentage;
		long productExpiresInMs = product.getExpiresInMs();
		Instant expiresAt = Instant.now().plusMillis(productExpiresInMs);

		// override duration if there is a custom duration
		if (durationMs != null && durationMs >= 0)
		{
			expiresAt = Instant.now().plusMillis(durationMs);
		}
		else if (durationPercentage != null && durationPercentage >= 0)
		{
			long durationMsFromPercentage = (long) (((double) productExpiresInMs) * durationPercentage);
			expiresAt = Instant.now().plusMillis(durationMsFromPercentage);
		}

		// register the new effect
		// NOTE: perform add to list first!
		MarketplaceEffect<FrameType> effect = new MarketplaceEffect<FrameType>(product, frame, spawnedObject, expiresAt);
		effects.add(effect);
		onAddEffect(effect);
	}

	protected void cleanInactiveEffects()
	{
		cleanEffects(false);
	}

	public void forceCleanAllEffects()
	{
		cleanEffects(true);
	}

	private void cleanEffects(boolean forceStop)
	{
		Iterator<MarketplaceEffect<FrameType>> effectIterator = effects.iterator();

		while (effectIterator.hasNext())
		{
			MarketplaceEffect<FrameType> effect = effectIterator.next();
			MarketplaceProduct marketplaceProduct = effect.getMarketplaceProduct();
			boolean isExpired = effect.isExpired() || marketplaceProduct.isExpired();
			boolean isActive = marketplaceProduct.isActive();
			boolean isPaused = marketplaceProduct.isPaused();
			boolean isApplied = effect.isApplied();

			// check if we should remove this effect
			if (isExpired || forceStop)
			{

				// remove from the current effects
				// NOTE: perform remove from list first!
				effects.remove(effect);
				onDeleteEffect(effect);

				// always restore the effect
				restoreEffect(effect);
				effect.setApplied(false);
			}

			// check if we should only restore the effect for now, because the marketplace product is inactive
			// we also don't restore when the effect is not applied anymore and the product is paused
			else if (!isActive && (isApplied || !isPaused))
			{
				restoreEffect(effect);
				effect.setApplied(false);
			}
		}
	}

	protected void applyActiveEffects()
	{
		Iterator<MarketplaceEffect<FrameType>> effectIterator = effects.iterator();

		while (effectIterator.hasNext())
		{
			MarketplaceEffect<FrameType> effect = effectIterator.next();
			MarketplaceProduct marketplaceProduct = effect.getMarketplaceProduct();
			boolean isActive = marketplaceProduct.isActive();

			// guard: make sure the product is active
			if (!isActive)
			{
				continue;
			}

			applyEffect(effect);
			effect.setApplied(true);
		}
	}

	public boolean hasAnyEffectsActive()
	{
		return !effects.isEmpty();
	}

	protected abstract void onAddEffect(MarketplaceEffect<FrameType> effect);
	protected abstract void onDeleteEffect(MarketplaceEffect<FrameType> effect);
	protected abstract void restoreEffect(MarketplaceEffect<FrameType> effect);
	protected abstract void applyEffect(MarketplaceEffect<FrameType> effect);
}

package com.twitchliveloadout.marketplace;

import com.twitchliveloadout.marketplace.products.MarketplaceProduct;
import com.twitchliveloadout.marketplace.products.StreamerProduct;
import com.twitchliveloadout.marketplace.products.TwitchProduct;
import com.twitchliveloadout.marketplace.transactions.TwitchTransaction;
import com.twitchliveloadout.twitch.eventsub.TwitchEventSubType;
import com.twitchliveloadout.twitch.eventsub.messages.*;
import lombok.Getter;
import lombok.extern.slf4j.Slf4j;

import java.util.HashMap;

@Slf4j
public class MarketplaceMessages {
	public static String formatMessage(String message, MarketplaceProduct marketplaceProduct, MarketplaceEffect marketplaceEffect)
	{
		TwitchTransaction transaction = null;
		TwitchProduct twitchProduct = null;
		StreamerProduct streamerProduct = null;
		BaseMessage eventSubMessage = null;
		HashMap<MarketplaceMessageTemplate, String> templateLookup = new HashMap<>();

		if (marketplaceProduct != null) {
			transaction = marketplaceProduct.getTransaction();
			twitchProduct = marketplaceProduct.getTwitchProduct();
			streamerProduct = marketplaceProduct.getStreamerProduct();
		}

		// add defaults
		templateLookup.put(MarketplaceMessageTemplate.VIEWER_NAME, "viewer");
		templateLookup.put(MarketplaceMessageTemplate.CHANNEL_NAME, "streamer");
		templateLookup.put(MarketplaceMessageTemplate.PRODUCT_NAME, "Random Event");

		if (transaction != null) {
			templateLookup.put(MarketplaceMessageTemplate.VIEWER_NAME, transaction.user_name);
			templateLookup.put(MarketplaceMessageTemplate.CHANNEL_NAME, transaction.broadcaster_name);
			eventSubMessage = transaction.eventSubMessage;
		}

		if (streamerProduct != null) {
			templateLookup.put(MarketplaceMessageTemplate.PRODUCT_NAME, streamerProduct.name);
		}

		if (twitchProduct != null) {

			// make sure things such as '150.0' are displayed as '150'
			Double rawCurrencyAmount = twitchProduct.cost.amount;
			boolean hasDecimalPlaces = (rawCurrencyAmount % 1 != 0);
			String formattedCurrencyAmount = hasDecimalPlaces ? rawCurrencyAmount.toString() : Integer.toString(rawCurrencyAmount.intValue());

			templateLookup.put(MarketplaceMessageTemplate.CURRENCY_AMOUNT, formattedCurrencyAmount);
			templateLookup.put(MarketplaceMessageTemplate.CURRENCY_TYPE, twitchProduct.cost.type);
		}

		if (marketplaceEffect != null) {
			templateLookup.put(MarketplaceMessageTemplate.EFFECT_DURATION, MarketplaceDuration.humanizeDurationRounded(marketplaceEffect.getDuration()));
			templateLookup.put(MarketplaceMessageTemplate.EFFECT_DURATION_LEFT, MarketplaceDuration.humanizeDurationRounded(marketplaceEffect.getDurationLeft()));
		}

		if (marketplaceProduct != null) {
			templateLookup.put(MarketplaceMessageTemplate.PRODUCT_DURATION, MarketplaceDuration.humanizeDurationRounded(marketplaceProduct.getDuration()));
			templateLookup.put(MarketplaceMessageTemplate.PRODUCT_DURATION_LEFT, MarketplaceDuration.humanizeDurationRounded(marketplaceProduct.getDurationLeft()));
		}

		if (eventSubMessage instanceof BaseUserInfo) {
			BaseUserInfo baseUserInfo = (BaseUserInfo) eventSubMessage;
			templateLookup.put(MarketplaceMessageTemplate.VIEWER_NAME, baseUserInfo.user_name);
			templateLookup.put(MarketplaceMessageTemplate.CHANNEL_NAME, baseUserInfo.broadcaster_user_name);
		}

		if (eventSubMessage instanceof ChannelContinueSubscription) {
			ChannelContinueSubscription channelContinueSubscription = (ChannelContinueSubscription) eventSubMessage;
			templateLookup.put(MarketplaceMessageTemplate.SUB_MONTHS, channelContinueSubscription.duration_months.toString());
			templateLookup.put(MarketplaceMessageTemplate.SUB_TOTAL_MONTHS, channelContinueSubscription.cumulative_months.toString());
		}

		if (eventSubMessage instanceof ChannelGiftSubscription) {
			ChannelGiftSubscription channelGiftSubscription = (ChannelGiftSubscription) eventSubMessage;
			templateLookup.put(MarketplaceMessageTemplate.GIFTED_AMOUNT, channelGiftSubscription.total.toString());
			templateLookup.put(MarketplaceMessageTemplate.GIFTED_TOTAL_AMOUNT, channelGiftSubscription.cumulative_total.toString());
		}

		if (eventSubMessage instanceof ChannelRaid) {
			ChannelRaid channelRaid = (ChannelRaid) eventSubMessage;
			templateLookup.put(MarketplaceMessageTemplate.VIEWER_NAME, channelRaid.from_broadcaster_user_name);
			templateLookup.put(MarketplaceMessageTemplate.RAID_VIEWER_AMOUNT, channelRaid.viewers.toString());
			templateLookup.put(MarketplaceMessageTemplate.RAIDER_CHANNEL_NAME, channelRaid.from_broadcaster_user_name);
			templateLookup.put(MarketplaceMessageTemplate.RAIDED_CHANNEL_NAME, channelRaid.to_broadcaster_user_name);
		}

		if (eventSubMessage instanceof BaseCharityCampaignInfo) {
			BaseCharityCampaignInfo baseCharityCampaignInfo = (BaseCharityCampaignInfo) eventSubMessage;
			templateLookup.put(MarketplaceMessageTemplate.CHARITY_NAME, baseCharityCampaignInfo.charity_name);
		}

		if (eventSubMessage instanceof CharityCampaignAmountInfo) {
			CharityCampaignAmountInfo charityCampaignAmountInfo = (CharityCampaignAmountInfo) eventSubMessage;
			templateLookup.put(MarketplaceMessageTemplate.CHARITY_CURRENT_AMOUNT, charityCampaignAmountInfo.current_amount.getCurrencyAmount().toString());
			templateLookup.put(MarketplaceMessageTemplate.CHARITY_TARGET_AMOUNT, charityCampaignAmountInfo.target_amount.getCurrencyAmount().toString());
			templateLookup.put(MarketplaceMessageTemplate.CHARITY_CURRENT_CURRENCY, charityCampaignAmountInfo.current_amount.currency);
			templateLookup.put(MarketplaceMessageTemplate.CHARITY_TARGET_CURRENCY, charityCampaignAmountInfo.target_amount.currency);
		}

		if (eventSubMessage instanceof BaseHypeTrain) {
			BaseHypeTrain baseHypeTrain = (BaseHypeTrain) eventSubMessage;
			templateLookup.put(MarketplaceMessageTemplate.HYPE_TRAIN_TOTAL, baseHypeTrain.total.toString());
			templateLookup.put(MarketplaceMessageTemplate.HYPE_TRAIN_LEVEL, baseHypeTrain.level.toString());
		}

		if (eventSubMessage instanceof BaseHypeTrainWithGoal) {
			BaseHypeTrainWithGoal baseHypeTrainWithGoal = (BaseHypeTrainWithGoal) eventSubMessage;
			templateLookup.put(MarketplaceMessageTemplate.HYPE_TRAIN_GOAL, baseHypeTrainWithGoal.goal.toString());
			templateLookup.put(MarketplaceMessageTemplate.HYPE_TRAIN_PROGRESS, baseHypeTrainWithGoal.progress.toString());
		}

		// replace all the known template strings with their respective values
		for (MarketplaceMessageTemplate template : MarketplaceMessageTemplate.values())
		{
			String newContent = templateLookup.get(template);

			// when no value is set from the message or transaction default to an empty string
			// this ensures the removal of the template string
			// NOTE: we don't want to remove unknown template strings because we want the streamer to see it doesn't exist!
			if (newContent == null)
			{
				newContent = "";
			}

			message = message.replaceAll("\\{" + template.name + "\\}", newContent);
		}

		message = message.trim();

		return message;
	}

	@Getter
	public enum MarketplaceMessageTemplate {
		VIEWER_NAME("viewerName"),
		CHANNEL_NAME("channelName"),
		PRODUCT_NAME("productName"),
		CURRENCY_AMOUNT("currencyAmount"),
		CURRENCY_TYPE("currencyType"),
		PRODUCT_DURATION("productDuration"),
		PRODUCT_DURATION_LEFT("productDurationLeft"),
		EFFECT_DURATION("effectDuration"),
		EFFECT_DURATION_LEFT("effectDurationLeft"),
		SUB_MONTHS("subMonths"),
		SUB_TOTAL_MONTHS("subTotalMonths"),
		GIFTED_AMOUNT("giftedAmount"),
		GIFTED_TOTAL_AMOUNT("giftedTotalAmount"),
		RAIDER_CHANNEL_NAME("raiderChannelName"),
		RAIDED_CHANNEL_NAME("raidedChannelName"),
		RAID_VIEWER_AMOUNT("raidViewerAmount"),
		CHARITY_NAME("charityName"),
		CHARITY_CURRENT_AMOUNT("charityCurrentAmount"),
		CHARITY_CURRENT_CURRENCY("charityCurrentCurrency"),
		CHARITY_TARGET_AMOUNT("charityTargetAmount"),
		CHARITY_TARGET_CURRENCY("charityTargetCurrency"),
		HYPE_TRAIN_LEVEL("hypeTrainLevel"),
		HYPE_TRAIN_TOTAL("hypeTrainTotal"),
		HYPE_TRAIN_PROGRESS("hypeTrainProgress"),
		HYPE_TRAIN_GOAL("hypeTrainGoal"),
		;

		private final String name;

		MarketplaceMessageTemplate(String name)
		{
			this.name = name;
		}
	}
}

package com.twitchliveloadout.marketplace.interfaces;

import com.twitchliveloadout.TwitchLiveLoadoutPlugin;
import com.twitchliveloadout.marketplace.LambdaIterator;
import com.twitchliveloadout.marketplace.MarketplaceEffect;
import com.twitchliveloadout.marketplace.MarketplaceEffectManager;
import com.twitchliveloadout.marketplace.products.EbsInterfaceWidgetFrame;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.widgets.Widget;
import net.runelite.api.widgets.WidgetType;

import java.util.ArrayList;
import java.util.concurrent.ConcurrentHashMap;

import static com.twitchliveloadout.marketplace.MarketplaceConstants.*;

@Slf4j
public class WidgetManager extends MarketplaceEffectManager<EbsInterfaceWidgetFrame> {
	private final TwitchLiveLoadoutPlugin plugin;
	private final Client client;

	/**
	 * Track all the covering overlays that were initialized to show dark / snow / other overlay effects.
	 * This is a hashmap to support multiple client settings such as resized and fixed, which require different widgets
	 */
	private final ConcurrentHashMap<Widget, Widget> coveringOverlays = new ConcurrentHashMap<>();

	/**
	 * Separate, centralized store of the original widget states because it is possible that multiple active products
	 * change one widget at the same time. This prevents that original widget states are states changed by other products
	 * and with that make sure the true original state is being tracked. There is still a risk other game state changes are
	 * missed because of this and the state might be out of sync. Because of this we need to make sure to only adjust
	 * widgets that don't have this.
	 */
	private final ConcurrentHashMap<Widget, OriginalWidget> originalWidgets = new ConcurrentHashMap<>();

	public WidgetManager(TwitchLiveLoadoutPlugin plugin, Client client)
	{
		super(WIDGET_EFFECT_MAX_SIZE);

		this.plugin = plugin;
		this.client = client;
	}

	public void onGameTick()
	{
		ensureCoveringOverlays();
	}

	public void hideCoveringOverlays()
	{
		LambdaIterator.handleAllValues(coveringOverlays, (coveringOverlay) -> {
			coveringOverlay.setHidden(true);
		});
	}

	private void ensureCoveringOverlays()
	{
		plugin.runOnClientThread(() -> {
			boolean isResized = client.isResized();

			if (isResized) {
				ensureCoveringOverlay(CoveringOverlayType.RESIZED_CLASSIC);
				ensureCoveringOverlay(CoveringOverlayType.RESIZED_MODERN);
			} else {
				ensureCoveringOverlay(CoveringOverlayType.FIXED);
			}
		});
	}

	private void ensureCoveringOverlay(CoveringOverlayType overlayType)
	{
		plugin.runOnClientThread(() -> {
			final Widget parent = client.getWidget(overlayType.getWidgetGroupId(), overlayType.getWidgetChildId());

			if (parent == null) {
				return;
			}

			// get the overlay based on the parent instance because the parent
			// change across logins, this makes sure we always instantiate a new one
			Widget coveringOverlay = coveringOverlays.get(parent);

			// guard: check if already existing
			if (coveringOverlay != null)
			{

				// initialize the overlay in case it was set to hidden after shutdown
				if (coveringOverlay.isHidden())
				{
					initializeCoveringOverlay(coveringOverlay);
				}
				return;
			}

			// create child widget
			coveringOverlay = parent.createChild(WidgetType.RECTANGLE);
			coveringOverlays.put(parent, coveringOverlay);

			initializeCoveringOverlay(coveringOverlay);
		});
	}

	private void initializeCoveringOverlay(Widget coveringOverlay)
	{

		// guard: make sure overlay is valid
		if (coveringOverlay == null)
		{
			return;
		}

		// set to default properties
		coveringOverlay.setHidden(false);
		coveringOverlay.setFilled(true);
		coveringOverlay.setType(3);
		coveringOverlay.setOpacity(255);
		coveringOverlay.setWidthMode(1);
		coveringOverlay.setHeightMode(1);
		coveringOverlay.setXPositionMode(1);
		coveringOverlay.setYPositionMode(1);
		coveringOverlay.setModelType(1);
		coveringOverlay.setModelId(-1);
		coveringOverlay.setAnimationId(-1);
		coveringOverlay.setModelZoom(1);
		coveringOverlay.revalidate();
	}

	@Override
	protected void applyEffect(MarketplaceEffect<EbsInterfaceWidgetFrame> effect)
	{
		EbsInterfaceWidgetFrame widgetFrame = effect.getFrame();
		ArrayList<Widget> widgets = getWidgets(widgetFrame);

		// guard: make sure this widget is known and valid
		if (widgets.size() <= 0)
		{
			return;
		}

		// guard: disable overlay widget effects when dangerous effects are not allowed
		if (OVERLAY_INTERFACE_WIDGET_TYPE.equals(widgetFrame.effectType) && !plugin.canPerformDangerousEffects())
		{
			return;
		}

		LambdaIterator.handleAll(widgets, (widget) -> {

			// always make sure a potential original is stored
			registerOriginalWidget(widget);
			String effectType = widgetFrame.effectType;
			Integer widgetType = widgetFrame.widgetType;
			Integer contentType = widgetFrame.contentType;
			String text = widgetFrame.text;
			Integer textColor = widgetFrame.textColor;
			Integer opacity = widgetFrame.opacity;
			Integer itemId = widgetFrame.itemId;
			Integer itemQuantity = widgetFrame.itemQuantity;
			String name = widgetFrame.name;
			Integer spriteId = widgetFrame.spriteId;
			Integer modelId = widgetFrame.modelId;
			Integer modelZoom = widgetFrame.modelZoom;
			Integer animationId = widgetFrame.animationId;

			plugin.runOnClientThread(() -> {
				// only disable widgets dangerous effects are allowed
				if (DISABLE_INTERFACE_WIDGET_TYPE.equals(effectType) && plugin.canPerformDangerousEffects())
				{
					widget.setHidden(true);
					return;
				}

				if (widgetType != null)
				{
					widget.setType(widgetType);
				}

				if (contentType != null)
				{
					widget.setContentType(contentType);
				}

				if (text != null)
				{
					widget.setText(text);
				}

				if (textColor != null)
				{
					widget.setTextColor(textColor);
				}

				if (opacity != null)
				{
					widget.setOpacity(opacity);
				}

				if (itemId != null)
				{
					widget.setItemId(itemId);
				}

				if (itemQuantity != null)
				{
					widget.setItemQuantity(itemQuantity);
				}

				if (name != null)
				{
					widget.setName(name);
				}

				if (spriteId != null)
				{
					widget.setSpriteId(spriteId);
				}

				if (modelId != null)
				{
					widget.setModelId(modelId);
				}

				if (modelZoom != null)
				{
					widget.setModelZoom(modelZoom);
				}

				if (animationId != null)
				{
					widget.setAnimationId(animationId);
				}
			});
		});
	}

	@Override
	protected void restoreEffect(MarketplaceEffect<EbsInterfaceWidgetFrame> effect)
	{
		EbsInterfaceWidgetFrame widgetFrame = effect.getFrame();
		ArrayList<Widget> widgets = getWidgets(widgetFrame);

		LambdaIterator.handleAll(widgets, (widget) -> {

			// guard: make sure this widget is known and valid
			if (widget == null || !originalWidgets.containsKey(widget))
			{
				return;
			}

			OriginalWidget originalWidget = originalWidgets.get(widget);

			// restore the properties of the widget
			widget.setHidden(originalWidget.getHidden());
			widget.setType(originalWidget.getType());
			widget.setContentType(originalWidget.getContentType());
			widget.setText(originalWidget.getText());
			widget.setTextColor(originalWidget.getTextColor());
			widget.setOpacity(originalWidget.getOpacity());
			widget.setItemId(originalWidget.getItemId());
			widget.setItemQuantity(originalWidget.getItemQuantity());
			widget.setName(originalWidget.getName());
			widget.setSpriteId(originalWidget.getSpriteId());
			widget.setModelId(originalWidget.getModelId());
			widget.setModelZoom(originalWidget.getModelZoom());
			widget.setAnimationId(originalWidget.getAnimationId());
		});
	}

	private void registerOriginalWidget(Widget widget)
	{

		// guard: make sure the widget is valid and not known yet
		if (widget == null || originalWidgets.containsKey(widget))
		{
			return;
		}

		OriginalWidget originalWidget = new OriginalWidget(widget);
		originalWidgets.put(widget, originalWidget);
	}

	private ArrayList<Widget> getWidgets(EbsInterfaceWidgetFrame widgetFrame)
	{
		final ArrayList<Widget> widgets = new ArrayList<>();
		final String effectType = widgetFrame.effectType;

		if (OVERLAY_INTERFACE_WIDGET_TYPE.equals(effectType)) {

			// get all widgets for all screens because when restoring an effect
			// this should be done for ALL covering overlay widgets otherwise
			// one might keep on going on a certain effect when switching resizing mode
			widgets.addAll(coveringOverlays.values());
		} else {
			final Integer parentId = widgetFrame.parentId;
			final Integer childId = widgetFrame.childId;
			final Integer listIndex = widgetFrame.listIndex;
			Widget widget = getWidget(parentId, childId, listIndex);

			if (widget != null) {
				widgets.add(widget);
			}
		}

		return widgets;
	}

	private Widget getWidget(Integer parentId, Integer childId, Integer listIndex)
	{
		try {

			// guard: make sure the parent and child selectors are valid
			if (parentId < 0 || childId < 0)
			{
				return null;
			}

			Widget widget = client.getWidget(parentId, childId);

			// guard: check if no index is requested
			if (listIndex < 0)
			{
				return widget;
			}

			if (widget == null)
			{
				return null;
			}

			return widget.getChild(listIndex);
		} catch (Exception exception) {
			plugin.logSupport("Could not get a widget by widget frame, due to the following error:", exception);
		}

		return null;
	}

	@Override
	protected void onAddEffect(MarketplaceEffect<EbsInterfaceWidgetFrame> effect)
	{
		// empty
	}

	@Override
	protected void onDeleteEffect(MarketplaceEffect<EbsInterfaceWidgetFrame> effect)
	{
		// empty
	}
}

package com.twitchliveloadout.marketplace.interfaces;

import lombok.Getter;

public enum CoveringOverlayType {
	// NOTE: use the root level bottom widgets in the Widget inspector
	FIXED("fixed", 548, 26),
	RESIZED_CLASSIC("resized-classic", 161, 94),
	RESIZED_MODERN("resized-modern", 164, 91),
	;

	@Getter
	private final String name;

	@Getter
	private final int widgetGroupId;

	@Getter
	private final int widgetChildId;

	CoveringOverlayType(String name, int widgetGroupId, int widgetChildId)
	{
		this.name = name;
		this.widgetGroupId = widgetGroupId;
		this.widgetChildId = widgetChildId;
	}
}

package com.twitchliveloadout.marketplace.interfaces;

import com.twitchliveloadout.TwitchLiveLoadoutConfig;
import com.twitchliveloadout.TwitchLiveLoadoutPlugin;
import com.twitchliveloadout.marketplace.MarketplaceEffect;
import com.twitchliveloadout.marketplace.MarketplaceEffectManager;
import com.twitchliveloadout.marketplace.products.EbsCondition;
import com.twitchliveloadout.marketplace.products.EbsMenuOptionFrame;
import com.twitchliveloadout.marketplace.products.MarketplaceProduct;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.*;
import net.runelite.api.coords.LocalPoint;
import net.runelite.api.events.MenuOptionClicked;
import net.runelite.client.util.Text;

import java.util.ArrayList;
import java.util.Iterator;

import static com.twitchliveloadout.TwitchLiveLoadoutPlugin.IN_DEVELOPMENT;
import static com.twitchliveloadout.marketplace.MarketplaceConstants.*;

@Slf4j
public class MenuManager extends MarketplaceEffectManager<EbsMenuOptionFrame> {
	private final TwitchLiveLoadoutPlugin plugin;
	private final TwitchLiveLoadoutConfig config;
	private final Client client;

	public MenuManager(TwitchLiveLoadoutPlugin plugin, TwitchLiveLoadoutConfig config, Client client)
	{
		super(MENU_EFFECT_MAX_SIZE);

		this.plugin = plugin;
		this.config = config;
		this.client = client;
	}

	public void onGameTick()
	{
		updateEffects();
	}

	public void onMenuOptionClicked(MenuOptionClicked event)
	{
		MenuEntry menuEntry = event.getMenuEntry();
		String clickedOption = event.getMenuOption();
		String clickedTarget = event.getMenuTarget();
		String clickedEntityType = "";
		Actor clickedActor = event.getMenuEntry().getActor();
		LocalPoint clickedEntityLocation = clickedActor != null ? clickedActor.getLocalLocation() : null;
		TileObject clickedObject = null;
		Player localPlayer = client.getLocalPlayer();

		if (menuEntry != null)
		{

			// an item is also considered a widget, so for this reason
			// we need to check for a valid item ID first
			if (menuEntry.getItemId() >= 0) {
				clickedEntityType = ITEM_MENU_ENTITY_TYPE;
			} else if (menuEntry.getWidget() != null) {
				clickedEntityType = WIDGET_MENU_ENTITY_TYPE;
			} else if (menuEntry.getNpc() != null) {
				clickedEntityType = NPC_MENU_ENTITY_TYPE;
			} else if (menuEntry.getPlayer() != null) {
				clickedEntityType = PLAYER_MENU_ENTITY_TYPE;
			} else {

				switch (event.getMenuAction())
				{

					// game objects
					case WIDGET_TARGET_ON_GAME_OBJECT:
					case GAME_OBJECT_FIRST_OPTION:
					case GAME_OBJECT_SECOND_OPTION:
					case GAME_OBJECT_THIRD_OPTION:
					case GAME_OBJECT_FOURTH_OPTION:
					case GAME_OBJECT_FIFTH_OPTION:
					{
						int x = event.getParam0();
						int y = event.getParam1();
						int id = event.getId();
						clickedObject = findTileObject(x, y, id);

						// only fill properties when a valid object is found
						if (clickedObject != null)
						{
							clickedEntityType = OBJECT_MENU_ENTITY_TYPE;
							clickedEntityLocation = clickedObject.getLocalLocation();
						}
						break;
					}

//					// alternative player interactions
//					case WIDGET_TARGET_ON_PLAYER:
//						break;

					// ground items
					case WIDGET_TARGET_ON_GROUND_ITEM:
					case GROUND_ITEM_FIRST_OPTION:
					case GROUND_ITEM_SECOND_OPTION:
					case GROUND_ITEM_THIRD_OPTION:
					case GROUND_ITEM_FOURTH_OPTION:
					case GROUND_ITEM_FIFTH_OPTION:
						int x = event.getParam0();
						int y = event.getParam1();
						Tile tile = getSceneTile(x, y);

						// only fill properties when valid tile is found
						if (tile != null)
						{
							clickedEntityType = GROUND_ITEM_MENU_ENTITY_TYPE;
							clickedEntityLocation = tile.getLocalLocation();
						}
						break;
				}
			}
		}

		if (config.debugMenuOptionClicks() && IN_DEVELOPMENT)
		{
			log.info("MENU OPTION CLICKED:");
			log.info("clickedOption: "+ clickedOption);
			log.info("clickedTarget: "+ clickedTarget);
			log.info("clickedEntityType: "+ clickedEntityType);
			log.info("clickedEntityLocation: "+ clickedEntityLocation);
			log.info("getParam0: "+ event.getParam0());
			log.info("getParam1: "+ event.getParam1());
			log.info("getId: "+ event.getId());
		}

		boolean hasLocalPlayer = localPlayer != null;
		boolean hasClickedEntityLocation = clickedEntityLocation != null;
		Iterator<MarketplaceEffect<EbsMenuOptionFrame>> effectIterator = effects.iterator();

		// check if the event should be disabled
		while (effectIterator.hasNext())
		{
			MarketplaceEffect<EbsMenuOptionFrame> effect = effectIterator.next();

			// guard: skip when not active
			if (!effect.isActive())
			{
				continue;
			}

			MarketplaceProduct marketplaceProduct = effect.getMarketplaceProduct();
			EbsMenuOptionFrame menuOptionFrame = effect.getFrame();
			ArrayList<EbsCondition> generalConditions = menuOptionFrame.conditions;
			boolean satisfiesOptions = verifyPropertyMatch(clickedOption, menuOptionFrame.matchedOptions);
			boolean satisfiesTargets = verifyPropertyMatch(clickedTarget, menuOptionFrame.matchedTargets);
			boolean satisfiesEntityTypes = verifyPropertyMatch(clickedEntityType, menuOptionFrame.matchedEntityTypes);
			Integer minClickRange = menuOptionFrame.minClickRange;
			Integer maxClickRange = menuOptionFrame.maxClickRange;
			boolean hasClickRange = minClickRange != null || maxClickRange != null;
			boolean satisfiesClickRange = true;
			boolean satisfiesGeneralConditions = marketplaceProduct.verifyConditions(generalConditions);

			// guard: make sure the general marketplace product conditions are satisfied to handle this menu click option frame
			if (!satisfiesGeneralConditions)
			{
				continue;
			}

			if (hasLocalPlayer && hasClickedEntityLocation && hasClickRange)
			{
				LocalPoint localPlayerLocation = localPlayer.getLocalLocation();
				int distance = localPlayerLocation.distanceTo(clickedEntityLocation) / 128;

				// handle diagonal tiles where we will consider single tile distance diagonal as two tiles!
				// this is in practice two tiles distance when interacting with things!
				if (distance == 1)
				{
					int deltaX = localPlayerLocation.getX() - clickedEntityLocation.getX();
					int deltaY = localPlayerLocation.getY() - clickedEntityLocation.getY();
					boolean isDiagonal = Math.abs(deltaX) > 0 && Math.abs(deltaY) > 0;

					if (isDiagonal)
					{
						distance = 2;
					}
				}

				// when there is a click range the default is that it's not satisfied
				satisfiesClickRange = false;

				if (config.debugMenuOptionClicks() && IN_DEVELOPMENT)
				{
					log.info("Distance to menu click: "+ distance);
				}

				if (minClickRange != null && distance < minClickRange)
				{
					satisfiesClickRange = true;
				}

				if (maxClickRange != null && distance > maxClickRange)
				{
					satisfiesClickRange = true;
				}
			}

			// guard: if one of the conditions is not satisfied we will skip the effect!
			if (!satisfiesOptions || !satisfiesTargets || !satisfiesEntityTypes || !satisfiesClickRange)
			{
				continue;
			}

			// handle disable effects
			// NOTE: only when allowed to perform dangerous effects
			if (DISABLE_MENU_OPTION_TYPE.equals(menuOptionFrame.type) && plugin.canPerformDangerousEffects())
			{
				event.consume();
			}

			marketplaceProduct.triggerEffects(
				menuOptionFrame.onClickEffects,
				0,
				null,
				effect,
				false,
				null
			);
		}
	}

	private boolean verifyPropertyMatch(String property, ArrayList<String> candidates)
	{

		// guard: verify at once when there are no candidates
		// NOTE: an empty list is considered no matches!
		if (candidates == null)
		{
			return true;
		}

		// guard: make sure the property is valid if not, then we wont verify
		if (property == null)
		{
			return false;
		}

		String formattedProperty = Text.removeTags(property.toLowerCase().trim());

		// if at least one candidate matches it is verified!
		for (String candidate : candidates)
		{

			// guard: make sure the candidate is valid
			if (candidate == null)
			{
				continue;
			}

			String formattedCandidate = candidate.toLowerCase();
			if (formattedProperty.matches(formattedCandidate))
			{
				return true;
			}
		}

		return false;
	}

	/*
	 * Copyright (c) 2021, Adam <Adam@sigterm.info>
	 * All rights reserved.
	 *
	 * Redistribution and use in source and binary forms, with or without
	 * modification, are permitted provided that the following conditions are met:
	 *
	 * 1. Redistributions of source code must retain the above copyright notice, this
	 *    list of conditions and the following disclaimer.
	 * 2. Redistributions in binary form must reproduce the above copyright notice,
	 *    this list of conditions and the following disclaimer in the documentation
	 *    and/or other materials provided with the distribution.
	 *
	 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
	 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
	 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
	 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
	 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
	 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
	 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	 */
	private TileObject findTileObject(int x, int y, int id)
	{
		Tile tile = getSceneTile(x, y);

		if (tile != null)
		{
			for (GameObject gameObject : tile.getGameObjects())
			{
				if (gameObject != null && gameObject.getId() == id)
				{
					return gameObject;
				}
			}

			WallObject wallObject = tile.getWallObject();
			if (wallObject != null && wallObject.getId() == id)
			{
				return wallObject;
			}

			DecorativeObject decorativeObject = tile.getDecorativeObject();
			if (decorativeObject != null && decorativeObject.getId() == id)
			{
				return decorativeObject;
			}

			GroundObject groundObject = tile.getGroundObject();
			if (groundObject != null && groundObject.getId() == id)
			{
				return groundObject;
			}
		}
		return null;
	}

	private Tile getSceneTile(int x, int y)
	{
		try {
			x += (Constants.EXTENDED_SCENE_SIZE - Constants.SCENE_SIZE) / 2;
			y += (Constants.EXTENDED_SCENE_SIZE - Constants.SCENE_SIZE) / 2;
			WorldView worldView = client.getTopLevelWorldView();
			Scene scene = client.getTopLevelWorldView().getScene();
			Tile[][][] tiles = scene.getExtendedTiles();
			Tile tile = tiles[worldView.getPlane()][x][y];

			return tile;
		} catch (Exception exception) {
			log.error("Could not find a scene tile from a menu click location: ", exception);
		}

		return null;
	}

	@Override
	protected void onAddEffect(MarketplaceEffect<EbsMenuOptionFrame> effect)
	{
		// empty
	}

	@Override
	protected void onDeleteEffect(MarketplaceEffect<EbsMenuOptionFrame> effect)
	{
		// empty
	}

	@Override
	protected void restoreEffect(MarketplaceEffect<EbsMenuOptionFrame> effect)
	{
		// empty
	}

	@Override
	protected void applyEffect(MarketplaceEffect<EbsMenuOptionFrame> effect)
	{
		// empty
	}
}

package com.twitchliveloadout.marketplace.interfaces;

import lombok.Getter;
import net.runelite.api.widgets.Widget;

public class OriginalWidget {
	@Getter
	private final Widget widget;
	@Getter
	private final Boolean hidden;
	@Getter
	private final Integer type;
	@Getter
	private final Integer contentType;
	@Getter
	private final String text;
	@Getter
	private final Integer textColor;
	@Getter
	private final Integer opacity;
	@Getter
	private final Integer itemId;
	@Getter
	private final Integer itemQuantity;
	@Getter
	private final String name;
	@Getter
	private final Integer spriteId;
	@Getter
	private final Integer modelId;
	@Getter
	private final Integer modelZoom;
	@Getter
	private final Integer animationId;

	public OriginalWidget(Widget widget)
	{
		this.widget = widget;

		// initialize all originals
		this.hidden = widget.isSelfHidden();
		this.type = widget.getType();
		this.contentType = widget.getContentType();
		this.text = widget.getText();
		this.textColor = widget.getTextColor();
		this.opacity = widget.getOpacity();
		this.itemId = widget.getItemId();
		this.itemQuantity = widget.getItemQuantity();
		this.name = widget.getName();
		this.spriteId = widget.getSpriteId();
		this.modelId = widget.getModelId();
		this.modelZoom = widget.getModelZoom();
		this.animationId = widget.getAnimationId();
	}
}

package com.twitchliveloadout.marketplace.sounds;

import com.twitchliveloadout.TwitchLiveLoadoutConfig;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;

import java.time.Instant;
import java.util.concurrent.ConcurrentHashMap;

import static com.twitchliveloadout.marketplace.MarketplaceConstants.*;

@Slf4j
public class SoundManager {
	private final Client client;
	private final TwitchLiveLoadoutConfig config;

	private Instant globalLastPlayedAt;
	private ConcurrentHashMap<Integer, Instant> uniqueLastPlayedAtLookup = new ConcurrentHashMap<>();

	public SoundManager(Client client, TwitchLiveLoadoutConfig config)
	{
		this.client = client;
		this.config = config;
	}

	public void playSound(Integer soundId)
	{

		// guard: check if the marketplace sounds are enabled
		if (!config.marketplaceSoundsEnabled())
		{
			return;
		}

		// guard: make sure the sound is valid
		if (soundId == null || soundId < 0)
		{
			return;
		}

		Instant now = Instant.now();
		Instant uniqueLastPlayedAt = uniqueLastPlayedAtLookup.get(soundId);
		boolean hasUniqueBeenPlayedRecently = uniqueLastPlayedAt != null && now.minusMillis(UNIQUE_PLAY_SOUND_THROTTLE_MS).isBefore(uniqueLastPlayedAt);
		boolean hasGlobalBeenPlayedRecently = globalLastPlayedAt != null && now.minusMillis(GLOBAL_PLAY_SOUND_THROTTLE_MS).isBefore(globalLastPlayedAt);

		// guard: check if this sound is allowed to be played once again
		// this is to prevent many of the same sounds to trigger at once
		if (hasUniqueBeenPlayedRecently || hasGlobalBeenPlayedRecently)
		{
			log.debug("Skipping sound "+ soundId +", because it has been played recently. Unique: "+ hasUniqueBeenPlayedRecently + ", global: "+ hasGlobalBeenPlayedRecently);
			return;
		}

		// update the last played ats
		globalLastPlayedAt = now;
		uniqueLastPlayedAtLookup.put(soundId, now);

		client.playSoundEffect(soundId);
	}
}

package com.twitchliveloadout.marketplace.notifications;

import com.google.common.collect.EvictingQueue;
import com.twitchliveloadout.TwitchLiveLoadoutConfig;
import com.twitchliveloadout.TwitchLiveLoadoutPlugin;
import com.twitchliveloadout.marketplace.MarketplaceEffect;
import com.twitchliveloadout.marketplace.MarketplaceManager;
import com.twitchliveloadout.marketplace.MarketplaceMessages;
import com.twitchliveloadout.marketplace.products.EbsNotification;
import com.twitchliveloadout.marketplace.products.MarketplaceProduct;
import com.twitchliveloadout.marketplace.transactions.TwitchTransaction;
import com.twitchliveloadout.twitch.TwitchApi;
import com.twitchliveloadout.twitch.eventsub.TwitchEventSubType;
import com.twitchliveloadout.twitch.eventsub.messages.BaseMessage;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.ChatMessageType;
import net.runelite.api.Client;
import net.runelite.api.Player;
import net.runelite.api.WidgetNode;
import net.runelite.api.widgets.Widget;
import net.runelite.api.widgets.WidgetModalMode;
import net.runelite.client.chat.ChatColorType;
import net.runelite.client.chat.ChatMessageBuilder;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.chat.QueuedMessage;

import java.awt.*;
import java.time.Instant;
import java.util.ArrayList;
import java.util.concurrent.CopyOnWriteArrayList;
import java.util.concurrent.ScheduledFuture;

import static com.twitchliveloadout.marketplace.MarketplaceConstants.*;

@Slf4j
public class NotificationManager {
	public static final int POPUP_RESIZEABLE_CLASSIC_COMPONENT_ID = (161 << 16) | 13;
	public static final int POPUP_RESIZEABLE_MODERN_COMPONENT_ID = (164 << 16) | 13;
	public static final int POPUP_FIXED_COMPONENT_ID = (548 << 16) | 43;
	public static final int POPUP_INTERFACE_ID = 660;

	private final TwitchLiveLoadoutPlugin plugin;
	private final TwitchLiveLoadoutConfig config;
	private final ChatMessageManager chatMessageManager;
	private final Client client;
	private final TwitchApi twitchApi;
	private final MarketplaceManager manager;
	private Instant notificationsLockedUntil;
	private ScheduledFuture overheadResetTask;
	private final CopyOnWriteArrayList<String> twitchChatNotifiedTransactionIds = new CopyOnWriteArrayList<>();

	/**
	 * Queue of all the notifications that should be shown to the player
	 * Note that they can be queued per group of notifications that should trigger at the same time
	 * This is mainly used for triggering different types of notifications.
	 */
	private final EvictingQueue<ArrayList<Notification>> notificationGroupQueue = EvictingQueue.create(NOTIFICATION_QUEUE_MAX_SIZE);

	public NotificationManager(TwitchLiveLoadoutPlugin plugin, TwitchLiveLoadoutConfig config, ChatMessageManager chatMessageManager, Client client, TwitchApi twitchApi, MarketplaceManager manager)
	{
		this.plugin = plugin;
		this.config = config;
		this.chatMessageManager = chatMessageManager;
		this.client = client;
		this.twitchApi = twitchApi;
		this.manager = manager;
	}

	public void onGameTick()
	{
		handleNotificationsQueue();
	}

	public void handleEbsNotifications(MarketplaceProduct marketplaceProduct, MarketplaceEffect marketplaceEffect, ArrayList<EbsNotification> ebsNotifications)
	{
		if (ebsNotifications == null)
		{
			return;
		}

		ArrayList<Notification> notificationGroup = new ArrayList<>();

		for (EbsNotification ebsNotification : ebsNotifications)
		{
			Notification notification = new Notification(marketplaceProduct, marketplaceEffect, ebsNotification);

			// guard: check if this is a notification that should be sent immediately
			if (!ebsNotification.queue)
			{
				log.debug("Sending a notification instantly: "+ notification.ebsNotification.message);
				sendNotification(notification);
				continue;
			}

			log.debug("Queueing a notification: "+ notification.ebsNotification.message);

			// otherwise add to the queued group
			notificationGroup.add(notification);
		}

		// guard: only add if the group is valid
		if (notificationGroup.size() <= 0)
		{
			return;
		}

		notificationGroupQueue.add(notificationGroup);
	}

	private void handleNotificationsQueue()
	{

		// guard: make sure the marketplace is active
		if (!manager.isActive())
		{
			return;
		}

		// guard: check if we can send a new notification
		if (!canSendNotification())
		{
			return;
		}

		// get the first group from the queue
		ArrayList<Notification> notificationGroup = notificationGroupQueue.poll();

		// guard: make sure we have a valid notification group
		if (notificationGroup == null)
		{
			return;
		}

		// handle all notifications
		for (Notification notification: notificationGroup)
		{
			sendNotification(notification);
		}
	}

	private void sendNotification(Notification notification)
	{
		EbsNotification ebsNotification = notification.ebsNotification;
		String messageType = ebsNotification.messageType;

		plugin.logSupport("Sending notification with message (type: "+ notification.ebsNotification.messageType +"): "+ notification.ebsNotification.message);

		try {
			if (CHAT_NOTIFICATION_MESSAGE_TYPE.equals(messageType))
			{
				sendChatNotification(notification);
			}
			else if (OVERHEAD_NOTIFICATION_MESSAGE_TYPE.equals(messageType))
			{
				sendOverheadNotification(notification);
			}
			else if (POPUP_NOTIFICATION_MESSAGE_TYPE.equals(messageType))
			{
				sendPopupNotification(notification);
			}
			else if (TWITCH_CHAT_NOTIFICATION_MESSAGE_TYPE.equals(messageType))
			{
				sendTwitchChatNotification(notification);
			}

		} catch (Exception exception) {
			plugin.logSupport("Could not send notification due to an error: ", exception);
		}
	}

	private void sendChatNotification(Notification notification)
	{

		// guard: skip when the chat donation message is disabled
		if (notification.isDonationMessage() && !config.chatMessagesEnabled())
		{
			return;
		}

		String message = getMessage(notification);

		// guard: check if the message is valid
		if (message.isEmpty())
		{
			return;
		}

		final Color chatColor = config.chatMessageColor();
		final ChatMessageBuilder chatMessage = new ChatMessageBuilder()
			.append(ChatColorType.HIGHLIGHT)
			.append(chatColor, message)
			.append(ChatColorType.NORMAL);

		chatMessageManager.queue(QueuedMessage.builder()
			.type(ChatMessageType.GAMEMESSAGE)
			.runeLiteFormattedMessage(chatMessage.build())
			.build());

		lockNotificationsUntil(CHAT_NOTIFICATION_LOCKED_MS);
	}

	private void sendOverheadNotification(Notification notification)
	{

		// guard: skip when the overhead donation message is disabled
		if (notification.isDonationMessage() && !config.overheadMessagesEnabled())
		{
			return;
		}

		Player player = client.getLocalPlayer();
		String message = getMessage(notification);
		int overheadTextDurationMs = config.overheadMessageDurationS() * 1000;

		// guard: check if the message is valid
		if (message.isEmpty())
		{
			return;
		}

		// guard: skip on invalid player
		if (player == null)
		{
			return;
		}

		// make sure there is only one overhead reset task!
		if (overheadResetTask != null && !overheadResetTask.isDone())
		{
			overheadResetTask.cancel(false);
		}

		plugin.runOnClientThread(() -> {
			player.setOverheadText(message);
		});
		overheadResetTask = plugin.scheduleOnClientThread(() -> {
			player.setOverheadText("");
		}, overheadTextDurationMs);
		lockNotificationsUntil(overheadTextDurationMs + OVERHEAD_NOTIFICATION_PAUSE_MS);
	}

	private void sendPopupNotification(Notification notification)
	{

		// guard: skip when the popup donation message is disabled
		if (notification.isDonationMessage() && !config.popupMessagesEnabled())
		{
			return;
		}

		boolean hasCustomTitle = null != notification.ebsNotification.popupTitle;
		plugin.runOnClientThread(() -> {
			try {
				String message = getMessage(notification);

				// guard: check if the message is valid
				if (message.isEmpty())
				{
					return;
				}

				// check which widget can be found depending on which window mode is active
				Widget fixedPopupWidget = client.getWidget(POPUP_FIXED_COMPONENT_ID);
				Widget modernPopupWidget = client.getWidget(POPUP_RESIZEABLE_MODERN_COMPONENT_ID);
				Widget classicPopupWidget = client.getWidget(POPUP_RESIZEABLE_CLASSIC_COMPONENT_ID);
				Integer targetComponentId = null;

				// switch the target component ID based on which valid widget is found
				if (fixedPopupWidget != null) {
					targetComponentId = POPUP_FIXED_COMPONENT_ID;
				} else if (modernPopupWidget != null) {
					targetComponentId = POPUP_RESIZEABLE_MODERN_COMPONENT_ID;
				} else if (classicPopupWidget != null) {
					targetComponentId = POPUP_RESIZEABLE_CLASSIC_COMPONENT_ID;
				}

				// guard: ensure we can detect the layout mode
				if (targetComponentId == null) {
					log.error("Could not detect the correct layout mode when showing a pop-up message with text: "+ message);
					return;
				}

				// original: client.openInterface((161 << 16) | 13, 660, WidgetModalMode.MODAL_CLICKTHROUGH);
				// NOTE: there is a bug where after the pop-up has been shown once and you switch layout mode you cannot show it again.
				// how often will it happen that someone switches layout mode? A client restart fixes it.
				WidgetNode widgetNode = client.openInterface(targetComponentId, POPUP_INTERFACE_ID, WidgetModalMode.MODAL_CLICKTHROUGH);
				client.runScript(3343, hasCustomTitle ? notification.ebsNotification.popupTitle : POPUP_NOTIFICATION_TITLE, message, -1);

				plugin.runOnClientThread(() -> {
					Widget w = client.getWidget(POPUP_INTERFACE_ID, 1);
					if (w.getWidth() > 0) {
						return;
					}

					client.closeInterface(widgetNode, true);
				});
			} catch (Exception exception) {
				plugin.logSupport("Could not show pop up message: "+ exception.getMessage());
			}
		});
	}

	private void sendTwitchChatNotification(Notification notification)
	{

		// guard: skip when the Twitch chat messages are disabled
		if (!config.twitchChatBitsDonationMessageEnabled())
		{
			return;
		}

		try {
			String transactionId = notification.marketplaceProduct.getTransaction().id;
			String streamerProductName = notification.marketplaceProduct.getStreamerProduct().name;

			// guard: skip when message was already sent for this transaction
			// NOTE: this means each transaction can only send ONE message to avoid spam
			// we cannot think of a use-case right now when multiple messages would be nice
			if (twitchChatNotifiedTransactionIds.contains(transactionId))
			{
				return;
			}

			// register this transaction ID as being handled
			twitchChatNotifiedTransactionIds.add(transactionId);

			// send the message to the twitch api
			String message = "["+ streamerProductName +"] "+ getMessage(notification);
			twitchApi.sendChatMessage(message);
		} catch (Exception exception) {
			// empty
		}
	}

	public void forceHideOverheadText()
	{
		Player player = client.getLocalPlayer();

		// guard: skip on invalid player
		if (player == null)
		{
			return;
		}

		// guard: skip when there is no overhead text at the moment
		if (overheadResetTask == null || overheadResetTask.isDone())
		{
			return;
		}

		plugin.runOnClientThread(() -> {
			player.setOverheadText("");
		});
	}

	private String getMessage(Notification notification)
	{
		EbsNotification ebsNotification = notification.ebsNotification;
		String message = ebsNotification.message;
		String messageType = ebsNotification.messageType;
		final MarketplaceProduct marketplaceProduct = notification.marketplaceProduct;
		final MarketplaceEffect marketplaceEffect = notification.marketplaceEffect;

		// guard: make sure the product is valid
		if (marketplaceProduct == null)
		{
			return (message == null ? "Thank you!" : message);
		}

		final TwitchTransaction twitchTransaction = marketplaceProduct.getTransaction();
		final TwitchEventSubType eventSubType = twitchTransaction.eventSubType;
		final BaseMessage eventSubMessage = twitchTransaction.eventSubMessage;
		final boolean isEventSubTransaction = twitchTransaction.isEventSubTransaction();
		final boolean isCurrencyTransaction = twitchTransaction.isCurrencyTransaction();

		// ensure there is a message when it is not set
		if (message == null)
		{

			// get the message from the channel event sub type
			// or use the default bits donation message when this is an EBS bits transaction
			if (isEventSubTransaction) {

				// NOTE: don't check whether the default message is enabled or not via the RuneLite settings
				// this is because you could disable the event in RuneLite, but have it configured in the Twitch Extension.
				// in this scenario we would still like to show the correct message!
				// This avoids confusion when configuring a random event to the event, while disabling the default.
				message = eventSubType.getMessageGetter().execute(config);
			} else if (isCurrencyTransaction) {

				// override the default bits message when its the Twitch chat notification
				if (TWITCH_CHAT_NOTIFICATION_MESSAGE_TYPE.equals(messageType)) {
					message = config.twitchChatBitsDonationMessage();
				} else if (manager.isFreeModeActive()) {
					message = config.defaultFreeModeActivationMessage();
				} else {
					message = config.defaultBitsDonationMessage();
				}
			} else {
				message = "Thank you {viewerName}!";
			}

			// when default chat messages are sent prefix them with the name of the event
			if (message != null && CHAT_NOTIFICATION_MESSAGE_TYPE.equals(notification.ebsNotification.messageType))
			{
				String name = marketplaceProduct.getStreamerProduct().name;
				message = "["+ name +"] "+ message;
			}
		}

		String formattedMessage = MarketplaceMessages.formatMessage(message, marketplaceProduct, marketplaceEffect);

		return formattedMessage;
	}

	private boolean canSendNotification()
	{
		return notificationsLockedUntil == null || Instant.now().isAfter(notificationsLockedUntil);
	}

	private void lockNotificationsUntil(int durationMs)
	{
		Instant newLockedUntil = Instant.now().plusMillis(durationMs);

		// guard: skip new locked when not after old lock
		if (notificationsLockedUntil != null && newLockedUntil.isBefore(notificationsLockedUntil))
		{
			return;
		}

		notificationsLockedUntil = newLockedUntil;
	}
}

package com.twitchliveloadout.marketplace.notifications;

import com.twitchliveloadout.marketplace.MarketplaceEffect;
import com.twitchliveloadout.marketplace.products.EbsNotification;
import com.twitchliveloadout.marketplace.products.MarketplaceProduct;

public class Notification {
	public final MarketplaceProduct marketplaceProduct;
	public final MarketplaceEffect marketplaceEffect;
	public final EbsNotification ebsNotification;

	public Notification(MarketplaceProduct marketplaceProduct, MarketplaceEffect marketplaceEffect, EbsNotification ebsNotification)
	{
		this.marketplaceProduct = marketplaceProduct;
		this.marketplaceEffect = marketplaceEffect;
		this.ebsNotification = ebsNotification;
	}

	public boolean isDonationMessage()
	{
		return ebsNotification.message == null || ebsNotification.message.isEmpty();
	}
}

package com.twitchliveloadout.marketplace.transmogs;

import com.twitchliveloadout.TwitchLiveLoadoutPlugin;
import com.twitchliveloadout.marketplace.MarketplaceEffect;
import com.twitchliveloadout.marketplace.MarketplaceEffectManager;
import com.twitchliveloadout.marketplace.products.EbsEquipmentFrame;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.*;
import net.runelite.api.events.GameStateChanged;
import net.runelite.api.events.PlayerChanged;
import net.runelite.client.game.ItemManager;

import java.util.concurrent.ConcurrentHashMap;

import static com.twitchliveloadout.marketplace.MarketplaceConstants.TRANSMOG_EFFECT_MAX_SIZE;

@Slf4j
public class TransmogManager extends MarketplaceEffectManager<EbsEquipmentFrame> {
	private final TwitchLiveLoadoutPlugin plugin;
	private final Client client;
	private final ItemManager itemManager;

	/**
	 * Lookup for which original equipment Ids were present before applying the transmog.
	 * This is used to revert back to the original equipment when the effect expires.
	 * This can be done for multiple players to support transforming other players as well in the future.
	 */
	private final ConcurrentHashMap<String, int[]> originalEquipmentIdsLookup = new ConcurrentHashMap<>();

	public TransmogManager(TwitchLiveLoadoutPlugin plugin, Client client, ItemManager itemManager)
	{
		super(TRANSMOG_EFFECT_MAX_SIZE);
		this.plugin = plugin;
		this.client = client;
		this.itemManager = itemManager;
	}

	public void onGameTick()
	{
		cleanInactiveEffects();
	}

	public void onPlayerChanged(PlayerChanged playerChanged)
	{
		Player player = playerChanged.getPlayer();
		Player localPlayer = client.getLocalPlayer();
		boolean isLocalPlayer = (localPlayer == player);

		// guard: for now we only support changing local players
		if (!isLocalPlayer)
		{
			return;
		}

		// after a change always record the original equipment to revert to after effect are done
		registerOriginalEquipment(player);

		// only after registering the original equipment we apply all the effects
		applyActiveEffects();
	}

	@Override
	protected void applyEffect(MarketplaceEffect<EbsEquipmentFrame> effect)
	{
		Player player = client.getLocalPlayer();

		// guard: make sure the player is valid
		if (!verifyPlayer(player))
		{
			return;
		}

		// fetch the current equipment IDs so we can selectively transmog them
		// only when they are set in the effect, this allows us to have multiple
		// effects influencing different equipment slots, for example one that does a
		// head transmog and another doing the cape transmog
		PlayerComposition composition = player.getPlayerComposition();
		int[] currentEquipmentIds = composition.getEquipmentIds();
		EbsEquipmentFrame equipmentFrame = effect.getFrame();

		// guard: make sure the equipment ids are valid
		if (currentEquipmentIds == null)
		{
			return;
		}

		// make sure the original is known for this player, if not
		// then the current equipment is considered the original
		if (!hasOriginalEquipment(player))
		{
			registerOriginalEquipment(player);
		}

		// update all the slots that the effect has a transmog available for
		for (int slotId = 0; slotId < currentEquipmentIds.length; slotId++)
		{
			Integer newEquipmentId = equipmentFrame.getEquipmentIdBySlotId(slotId);

			// guard: skip override when equipment is not valid
			if (newEquipmentId == null || newEquipmentId < 0)
			{
				continue;
			}

			currentEquipmentIds[slotId] = newEquipmentId;
		}

		// update any NPC transmogs
		Integer npcId = equipmentFrame.npcId;

		if (npcId != null && npcId >= 0)
		{
			composition.setTransformedNpcId(npcId);
		}

		// apply the new equipment
		composition.setHash();
	}

	@Override
	protected void restoreEffect(MarketplaceEffect<EbsEquipmentFrame> effect)
	{
		Player player = client.getLocalPlayer();

		// guard: make sure the player is valid
		if (!verifyPlayer(player))
		{
			return;
		}

		String playerName = player.getName();
		PlayerComposition composition = player.getPlayerComposition();
		EbsEquipmentFrame equipmentFrame = effect.getFrame();
		int[] originalEquipmentIds = originalEquipmentIdsLookup.get(playerName);
		int[] currentEquipmentIds = composition.getEquipmentIds();
		Integer npcId = equipmentFrame.npcId;

		// reset any NPC transmogs
		if (npcId != null && npcId >= 0)
		{
			composition.setTransformedNpcId(-1);
		}

		// guard: make sure the equipment ids are valid
		if (originalEquipmentIds == null || currentEquipmentIds == null)
		{
			return;
		}

		System.arraycopy(originalEquipmentIds, 0, currentEquipmentIds, 0, currentEquipmentIds.length);

		// apply the original equipment
		composition.setHash();

		// after the original is restored there might be another one right up in the effect queue
		// for this reason after each restore we will trigger an update to apply a transmog of something that was
		// overridden by this effect
		applyActiveEffects();
	}

	@Override
	protected void onAddEffect(MarketplaceEffect effect)
	{
		// update immediately when effect is added
		// because this manager is not updating periodically, but is event based
		applyActiveEffects();
	}

	@Override
	protected void onDeleteEffect(MarketplaceEffect effect)
	{
		// empty
	}

	private void registerOriginalEquipment(Player player)
	{

		// guard: make sure the player is valid
		if (!verifyPlayer(player))
		{
			return;
		}

		String playerName = player.getName();
		PlayerComposition composition = player.getPlayerComposition();
		int[] equipmentIds = composition.getEquipmentIds();

		originalEquipmentIdsLookup.put(playerName, equipmentIds.clone());
	}

	private boolean hasOriginalEquipment(Player player)
	{
		// guard: make sure the player is valid
		if (!verifyPlayer(player))
		{
			return false;
		}

		String playerName = player.getName();

		return originalEquipmentIdsLookup.containsKey(playerName);
	}

	private boolean verifyPlayer(Player player)
	{
		// guard: make sure the player is valid
		if (player == null)
		{
			return false;
		}

		String playerName = player.getName();
		PlayerComposition composition = player.getPlayerComposition();

		// guard: make sure the player properties are valid
		if (playerName == null || composition == null)
		{
			return false;
		}

		int[] equipmentIds = composition.getEquipmentIds();

		if (equipmentIds == null)
		{
			return false;
		}

		return true;
	}
}

package com.twitchliveloadout.marketplace;

import net.runelite.api.JagexColor;

import java.awt.*;

public class MarketplaceColors {

	public static int getColorHsl(Integer colorHex)
	{
		Color color = getColorByHex(colorHex);
		short colorHsl = JagexColor.rgbToHSL(color.getRGB(), 1.0d);

		return colorHsl;
	}

	public static Color getColorByHex(Integer colorHex)
	{
		int r = (colorHex & 0xFF0000) >> 16;
		int g = (colorHex & 0xFF00) >> 8;
		int b = (colorHex & 0xFF);

		return new Color(r, g, b);
	}
}

package com.twitchliveloadout.marketplace;

import com.twitchliveloadout.marketplace.products.EbsEffectFrame;
import com.twitchliveloadout.marketplace.products.MarketplaceProduct;
import com.twitchliveloadout.marketplace.spawns.SpawnedObject;
import javax.annotation.Nullable;
import lombok.Getter;
import lombok.Setter;

import java.time.Duration;
import java.time.Instant;

/**
 * Generic class to handle applying and reverting marketplace effects, such as interface, menu, animation or equipment transmog effects.
 */
public class MarketplaceEffect<K extends EbsEffectFrame> {

	/**
	 * The marketplace product where the effect originates from.
	 */
	@Getter
	private final MarketplaceProduct marketplaceProduct;

	/**
	 * Reference to the original effect properties where at minimum it contains an optional duration.
	 */
	@Getter
	private final K frame;

	/**
	 * Optional spawned object this effect is applicable for.
	 */
	@Nullable
	@Getter
	private final SpawnedObject spawnedObject;

	/**
	 * The start time based on instancing of this class.
	 */
	private final Instant startedAt;

	/**
	 * The expiry based on either the custom duration or the one of the product.
	 */
	private final Instant expiresAt;

	/**
	 * Boolean to identify whether the effect is currently applied yes or no.
	 * This helps to filter out re-triggering of reverting the effect over and over again
	 * while it is already reverted. With some effects this impacts the user experience if it does otherwise.
	 */
	@Getter
	@Setter
	private boolean isApplied = false;

	public MarketplaceEffect(MarketplaceProduct marketplaceProduct, K frame, SpawnedObject spawnedObject, Instant expiresAt)
	{
		this.marketplaceProduct = marketplaceProduct;
		this.frame = frame;
		this.spawnedObject = spawnedObject;
		this.startedAt = Instant.now();
		this.expiresAt = expiresAt;
	}

	public boolean isActive()
	{
		return !isExpired() && marketplaceProduct.isActive();
	}

	public boolean isExpired()
	{
		return Instant.now().isAfter(expiresAt) || marketplaceProduct.isExpired();
	}

	/**
	 * Calculate how long in milliseconds this effect is going to be active
	 */
	public Duration getDuration()
	{
		return Duration.between(startedAt, expiresAt);
	}

	/**
	 * Calculate the amount of time in milliseconds this effect is still active
	 */
	public Duration getDurationLeft()
	{
		Instant now = Instant.now();

		return Duration.between(now, expiresAt);
	}
}

package com.twitchliveloadout.marketplace;

import java.util.Collection;
import java.util.Iterator;
import java.util.concurrent.ConcurrentHashMap;

public class LambdaIterator {

	/**
	 * Handle all values in an hashmap with an iterator
	 */
	public static <KeyType, ValueType> void handleAllValues(ConcurrentHashMap<KeyType, ValueType> map, ValueHandler<ValueType> handler)
	{

		// guard: check if map is valid
		if (map == null)
		{
			return;
		}

		Collection<ValueType> values = map.values();
		handleAll(values, handler);
	}

	/**
	 * Handle all values in an hashmap with an iterator
	 */
	public static <KeyType, ValueType> void handleAll(Collection<ValueType> collection, ValueHandler<ValueType> handler)
	{
		// guard: check if collection is valid
		if (collection == null)
		{
			return;
		}

		Iterator<ValueType> iterator = collection.iterator();

		while (iterator.hasNext())
		{
			ValueType value = iterator.next();
			handler.execute(value);
		}
	}

	public interface ValueHandler<ValueType> {
		public void execute(ValueType value);
	}
}

package com.twitchliveloadout.marketplace;

public class MarketplaceConstants {
	public static final boolean TEST_MODE_AVAILABLE = true;
	public static final boolean CHAOS_MODE_AVAILABLE = false;
	public static final boolean FREE_MODE_AVAILABLE = true;
	public static final boolean MANUAL_PRODUCTS_AVAILABLE = true;

	public static final int EBS_REQUIRED_PRODUCT_VERSION = 1;

	public static final int MAX_MARKETPLACE_PRODUCT_AMOUNT_IN_MEMORY = 50;
	public static final int MAX_TRANSACTION_AMOUNT_IN_MEMORY = 50;
	public static final int MAX_CUSTOM_RANDOM_PRODUCTS = 20;
	public static final int TRANSACTION_DELAY_CORRECTION_MS = 1000;
	public static final int TRANSACTION_EXPIRY_CLOCK_TOLERANCE_MS = 45 * 1000;
	public static final int TICK_DURATION_MS = 600;
	public static final int GAME_CYCLE_DURATION_MS = 20; // refer to client.getGameCycle()

	public static final String CURRENT_TILE_LOCATION_TYPE = "current-tile";
	public static final String PREVIOUS_TILE_LOCATION_TYPE = "previous-tile";
	public static final String MODEL_TILE_LOCATION_TYPE = "model-tile";
	public static final String INTERACTING_TILE_LOCATION_TYPE = "interacting-tile";
	public static final String ABSOLUTE_TILE_LOCATION_TYPE = "absolute-tile";

	public static final String NONE_FOLLOW_TYPE = "none";
	public static final String IN_RADIUS_FOLLOW_TYPE = "in-radius";
	public static final String PREVIOUS_TILE_FOLLOW_TYPE = "behind-player";

	public static final String TRANSLATE_X_AXIS = "x";
	public static final String TRANSLATE_Y_AXIS = "y";
	public static final String TRANSLATE_Z_AXIS = "z";

	public static final double RUNELITE_OBJECT_RADIUS_PER_TILE = 60d;
	public static final double RUNELITE_OBJECT_FULL_ROTATION = 2047d;
	public static final int REGION_SIZE = 64;
	public static final int CHUNK_SIZE = 8;

	public static final int DEFAULT_MIN_RADIUS = 1;
	public static final int DEFAULT_MAX_RADIUS = 15;
	public static final int ABSOLUTE_MIN_RADIUS = 0;
	public static final int ABSOLUTE_MAX_RADIUS = REGION_SIZE;
	public static final String DEFAULT_RADIUS_TYPE = "radius";
	public static final String OUTWARD_RADIUS_TYPE = "outward-radius";
	public static final String NO_RADIUS_TYPE = "no-radius";

	public static final String NO_ROTATION_TYPE = "none";
	public static final String FIXED_ROTATION_TYPE = "fixed";
	public static final String RANDOM_ROTATION_TYPE = "random";
	public static final String PLAYER_ROTATION_TYPE = "player";
	public static final String INTERACTING_ROTATION_TYPE = "interacting";
	public static final String MIRROR_PLAYER_ROTATION_TYPE = "mirror-player";
	public static final String MIRROR_INTERACTING_ROTATION_TYPE = "mirror-interacting";

	public static final int PLAYER_TILE_HISTORY_SIZE = 10;

	public static final int NOTIFICATION_QUEUE_MAX_SIZE = 200;
	public static final int END_NOTIFICATION_GRACE_PERIOD_MS = 7000; // keep it high due to internal delays
	public static final String NONE_NOTIFICATION_MESSAGE_TYPE = "none";
	public static final String CHAT_NOTIFICATION_MESSAGE_TYPE = "chat";
	public static final String OVERHEAD_NOTIFICATION_MESSAGE_TYPE = "overhead";
	public static final String POPUP_NOTIFICATION_MESSAGE_TYPE = "popup";
	public static final String TWITCH_CHAT_NOTIFICATION_MESSAGE_TYPE = "twitch-chat";

	public static final String POPUP_NOTIFICATION_TITLE = "Live Loadout";

	public static final String TILE_MARKER_NOTIFICATION_MESSAGE_TYPE = "tile-marker";

	public static final int WIDGET_EFFECT_MAX_SIZE = 100;
	public static final int MENU_EFFECT_MAX_SIZE = 100;
	public static final int SPAWN_OVERHEAD_EFFECT_MAX_SIZE = 100;
	public static final String DISABLE_MENU_OPTION_TYPE = "disable";
	public static final String DISABLE_INTERFACE_WIDGET_TYPE = "disable";
	public static final String ALTER_INTERFACE_WIDGET_TYPE = "alter";
	public static final String OVERLAY_INTERFACE_WIDGET_TYPE = "overlay";

	// NOTE: keep in sync with front-end!
	public static final String NPC_MENU_ENTITY_TYPE = "npc";
	public static final String ITEM_MENU_ENTITY_TYPE = "item";
	public static final String WIDGET_MENU_ENTITY_TYPE = "widget";
	public static final String PLAYER_MENU_ENTITY_TYPE = "player";
	public static final String OBJECT_MENU_ENTITY_TYPE = "object";
	public static final String GROUND_ITEM_MENU_ENTITY_TYPE = "ground-item";

	public static final int MAX_SPAWN_AMOUNT = 500;
	public static final String INDIVIDUAL_SPAWN_POINT_TYPE = "individual";
	public static final String GROUP_SPAWN_POINT_TYPE = "group";
	public static final int MAX_MODEL_SCALE = 500;
	public static final int MIN_MODEL_TRANSLATE = -1024;
	public static final int MAX_MODEL_TRANSLATE = 1024;

	public static final String PRODUCT_STATE_TYPE = "product";
	public static final String OBJECT_STATE_TYPE = "object";

	public static final String STRING_STATE_FORMAT = "string";
	public static final String INTEGER_STATE_FORMAT = "integer";

	public static final String SET_STATE_OPERATION = "set";
	public static final String ADD_STATE_OPERATION = "add";
	public static final String SUBTRACT_STATE_OPERATION = "subtract";
	public static final String MULTIPLY_STATE_OPERATION = "multiply";
	public static final String DIVIDE_STATE_OPERATION = "divide";

	public static final String EQUAL_STATE_COMPARISON = "equal";
	public static final String LARGER_THAN_STATE_COMPARISON = "larger-than";
	public static final String LARGER_EQUAL_THAN_STATE_COMPARISON = "larger-equal-than";
	public static final String SMALLER_THAN_STATE_COMPARISON = "smaller-than";
	public static final String SMALLER_EQUAL_THAN_STATE_COMPARISON = "smaller-equal-than";

	public static final int MOVEMENT_EFFECT_MAX_SIZE = 100;
	public static final int TRANSMOG_EFFECT_MAX_SIZE = 100;
	public static final int DRAW_EFFECT_MAX_SIZE = 100;

	public static final int CHAT_NOTIFICATION_LOCKED_MS = 1 * 1000;
	public static final int OVERHEAD_NOTIFICATION_PAUSE_MS = 1 * 1000;
	public static final int TILE_MARKER_NOTIFICATION_DURATION_MS = 0 * 1000;

	public static final int GLOBAL_PLAY_SOUND_THROTTLE_MS = 0;
	public static final int UNIQUE_PLAY_SOUND_THROTTLE_MS = 100;

	public static final String EVENT_SUB_DEFAULT_EBS_PRODUCT_ID = "all-notifications";

	public static final int MALE_GENDER_ID = 0;
	public static final int FEMALE_GENDER_ID = 1;

	public static final String EXTENSION_BITS_TWITCH_PRODUCT_TYPE = "EXTENSION_BITS";
	public static final String CHANNEL_POINTS_TWITCH_PRODUCT_TYPE = "CHANNEL_POINTS";
	public static final String CHANNEL_EVENT_TWITCH_PRODUCT_TYPE = "CHANNEL_EVENT";
}

package com.twitchliveloadout.marketplace.draws;

import com.twitchliveloadout.marketplace.MarketplaceEffect;
import com.twitchliveloadout.marketplace.MarketplaceEffectManager;
import com.twitchliveloadout.marketplace.products.EbsDrawFrame;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.*;

import java.util.Iterator;

import static com.twitchliveloadout.marketplace.MarketplaceConstants.DRAW_EFFECT_MAX_SIZE;

@Slf4j
public class DrawManager extends MarketplaceEffectManager<EbsDrawFrame> {
    private final Client client;

    /**
     * Flags of the current state to optimise the draw call without any effect lookup required.
     * These flags are updated when effects are added or removed.
     */
    private boolean anyEffectsActive = false;
    private boolean hideOthers = false;
    private boolean hideOthers2D = false;
    private boolean hideLocalPlayer = false;
    private boolean hideLocalPlayer2D = false;
    private boolean hideNPCs = false;
    private boolean hideNPCs2D = false;
    private boolean hideProjectiles = false;

    public DrawManager(Client client)
    {
        super(DRAW_EFFECT_MAX_SIZE);
        this.client = client;
    }

    public boolean shouldDraw(Renderable renderable, boolean drawingUI)
    {
        if (!anyEffectsActive)
        {
            return true;
        }

        if (renderable instanceof Player)
        {
            Player player = (Player) renderable;
            Player local = client.getLocalPlayer();

            if (player.getName() == null)
            {
                return true;
            }

            // Allow hiding local self in pvp, which is an established meta.
            // It is more advantageous than renderself due to being able to still render local player 2d
            if (player == local)
            {
                return !(drawingUI ? hideLocalPlayer2D : hideLocalPlayer);
            }

            return !(drawingUI ? hideOthers2D : hideOthers);
        }

        if (renderable instanceof NPC)
        {
            return !(drawingUI ? hideNPCs2D : hideNPCs);
        }

        if (renderable instanceof Projectile)
        {
            return !hideProjectiles;
        }

        return true;
    }

    private void updateState() {
        anyEffectsActive = hasAnyEffectsActive();

        // by default reset all the states to false
        // only active effects upon later check can set them to true again
        hideOthers = false;
        hideOthers2D = false;
        hideLocalPlayer = false;
        hideLocalPlayer2D = false;
        hideNPCs = false;
        hideNPCs2D = false;
        hideProjectiles = false;

        // guard: skip checks when nothing is active
        if (!anyEffectsActive) {
            return;
        }

        Iterator<MarketplaceEffect<EbsDrawFrame>> effectIterator = effects.iterator();

        while (effectIterator.hasNext()) {
            MarketplaceEffect<EbsDrawFrame> effect = effectIterator.next();
            EbsDrawFrame frame = effect.getFrame();

            // guard: skip inactive effects
            if (!effect.isActive() || !effect.isApplied())
            {
                continue;
            }

            if (frame.hideOthers) {
                hideOthers = true;
            }

            if (frame.hideOthers2D) {
                hideOthers2D = true;
            }

            if (frame.hideLocalPlayer) {
                hideLocalPlayer = true;
            }

            if (frame.hideLocalPlayer2D) {
                hideLocalPlayer2D = true;
            }

            if (frame.hideNPCs) {
                hideNPCs = true;
            }

            if (frame.hideNPCs2D) {
                hideNPCs2D = true;
            }

            if (frame.hideProjectiles) {
                hideProjectiles = true;
            }
        }
    }

    @Override
    protected void onAddEffect(MarketplaceEffect<EbsDrawFrame> effect) {
        updateState();
    }

    @Override
    protected void onDeleteEffect(MarketplaceEffect<EbsDrawFrame> effect) {
        updateState();
    }

    @Override
    protected void restoreEffect(MarketplaceEffect<EbsDrawFrame> effect) {
        updateState();
    }

    @Override
    protected void applyEffect(MarketplaceEffect<EbsDrawFrame> effect) {
        updateState();
    }
}

package com.twitchliveloadout.marketplace;

import com.twitchliveloadout.marketplace.products.MarketplaceProduct;

import java.time.Instant;
import java.util.Comparator;

public class MarketplaceProductSorter implements Comparator<MarketplaceProduct>
{
	public int compare(MarketplaceProduct p1, MarketplaceProduct p2)
	{
		Instant startedAt = p1.getStartedAt();
		Instant comparedStartedAt = p2.getStartedAt();
		long startedEpoch = (startedAt == null ? 0 : startedAt.getEpochSecond());
		long startedUpdateEpoch = (comparedStartedAt == null ? 0 : comparedStartedAt.getEpochSecond());
		boolean isLater = startedEpoch > startedUpdateEpoch;

		// check for equal
		if (startedEpoch == startedUpdateEpoch)
		{
			return 0;
		}

		// asc order, from first to new ones
		return !isLater ? -1 : 1;
	}
}

package com.twitchliveloadout.utilities;

import lombok.Getter;

public enum AccountType
{
	/**
	 * Normal account type.
	 */
	NORMAL(0, "NORMAL"),
	/**
	 * Ironman account type.
	 */
	IRONMAN(1, "IRONMAN"),
	/**
	 * Ultimate ironman account type.
	 */
	ULTIMATE_IRONMAN(2, "ULTIMATE_IRONMAN"),
	/**
	 * Hardcore ironman account type.
	 */
	HARDCORE_IRONMAN(3, "HARDCORE_IRONMAN"),
	/**
	 * Group ironman account type
	 */
	GROUP_IRONMAN(4, "GROUP_IRONMAN"),
	/**
	 * Hardcore group ironman account type
	 */
	HARDCORE_GROUP_IRONMAN(5, "HARDCORE_GROUP_IRONMAN"),

	/**
	 * Unranked group ironman account type
	 */
	UNRANKED_GROUP_IRONMAN(6, "UNRANKED_GROUP_IRONMAN");

	@Getter
	private final int id;

	@Getter
	private final String key;

	AccountType(int id, String key)
	{
		this.id = id;
		this.key = key;
	}
}

/*
 * Copyright (c) 2017, honeyhoney <https://github.com/honeyhoney>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.twitchliveloadout.fights;

import lombok.Getter;
import net.runelite.api.Skill;

public enum AttackStyle
{
    ACCURATE("Accurate", CombatStyle.MELEE, Skill.ATTACK),
    AGGRESSIVE("Aggressive", CombatStyle.MELEE, Skill.STRENGTH),
    DEFENSIVE("Defensive", CombatStyle.MELEE, Skill.DEFENCE),
    CONTROLLED("Controlled", CombatStyle.MELEE, Skill.ATTACK, Skill.STRENGTH, Skill.DEFENCE),
    RANGING("Ranging", CombatStyle.RANGED, Skill.RANGED),
    LONGRANGE("Longrange", CombatStyle.RANGED, Skill.RANGED, Skill.DEFENCE),
    CASTING("Casting", CombatStyle.MAGIC, Skill.MAGIC),
    DEFENSIVE_CASTING("Defensive Casting", CombatStyle.MAGIC, Skill.MAGIC, Skill.DEFENCE),
    OTHER("Other", CombatStyle.MELEE);

    @Getter
    private final String name;
    @Getter
    private final CombatStyle combatStyle;
    @Getter
    private final Skill[] skills;

    AttackStyle(String name, CombatStyle combatStyle, Skill... skills)
    {
        this.name = name;
        this.combatStyle = combatStyle;
        this.skills = skills;
    }
}

package com.twitchliveloadout.fights;

public enum FightStatisticProperty
{
	HIT_COUNTERS("hc"),
	MISS_COUNTERS("mc"),
	HIT_DAMAGES("hd"),
	MISS_DAMAGES("md"),
	DURATION_SECONDS("ds");

	private final String key;

	FightStatisticProperty(String key)
	{
		this.key = key;
	}

	public String getKey()
	{
		return key;
	}
}

package com.twitchliveloadout.fights;

import net.runelite.api.Skill;

import static com.twitchliveloadout.fights.FightStateManager.*;

public enum FightGraphic {
    ICE_BARRAGE(369, Skill.MAGIC, NO_SKILL, MULTI_ANCIENT_ANIMATION_ID, false, FightStatisticEntry.FREEZE, FightStatisticProperty.HIT_DAMAGES),
    ICE_BLITZ(367, Skill.MAGIC, NO_SKILL, SINGLE_ANCIENT_ANIMATION_ID, true, FightStatisticEntry.FREEZE, FightStatisticProperty.HIT_DAMAGES),
    ICE_BURST(363, Skill.MAGIC, NO_SKILL, MULTI_ANCIENT_ANIMATION_ID, false, FightStatisticEntry.FREEZE, FightStatisticProperty.HIT_DAMAGES),
    ICE_RUSH(361, Skill.MAGIC, NO_SKILL, SINGLE_ANCIENT_ANIMATION_ID, true, FightStatisticEntry.FREEZE, FightStatisticProperty.HIT_DAMAGES),

    BLOOD_BARRAGE(377, Skill.MAGIC, NO_SKILL, MULTI_ANCIENT_ANIMATION_ID, false, FightStatisticEntry.BLOOD_HEAL, FightStatisticProperty.HIT_DAMAGES),
    BLOOD_BLITZ(375, Skill.MAGIC, NO_SKILL, SINGLE_ANCIENT_ANIMATION_ID, true, FightStatisticEntry.BLOOD_HEAL, FightStatisticProperty.HIT_DAMAGES),
    BLOOD_BURST(376, Skill.MAGIC, NO_SKILL, MULTI_ANCIENT_ANIMATION_ID, false, FightStatisticEntry.BLOOD_HEAL, FightStatisticProperty.HIT_DAMAGES),
    BLOOD_RUSH(373, Skill.MAGIC, NO_SKILL, SINGLE_ANCIENT_ANIMATION_ID, true, FightStatisticEntry.BLOOD_HEAL, FightStatisticProperty.HIT_DAMAGES),

    ENTANGLE(179, Skill.MAGIC, NO_SKILL, ENTANGLE_ANIMATION_ID, true, FightStatisticEntry.ENTANGLE, FightStatisticProperty.HIT_DAMAGES),
    SNARE(180, Skill.MAGIC, NO_SKILL, ENTANGLE_ANIMATION_ID, true, FightStatisticEntry.ENTANGLE, FightStatisticProperty.HIT_DAMAGES),
    BIND(181, Skill.MAGIC, Skill.HITPOINTS, ENTANGLE_ANIMATION_ID, true, FightStatisticEntry.ENTANGLE, FightStatisticProperty.HIT_COUNTERS), // no hitsplat

    // Note that with the interaction required boolean to true splashes on multi-target enemies will not register (e.g. while barraging).
    // However, this is needed because otherwise splashes from other actors have a very high change to trigger false positives.
    // No invalid skill as multi-target spells can both hit and splash on enemies in the same attack.
    SPLASH(85, Skill.MAGIC, NO_SKILL, NO_ANIMATION_ID, true, FightStatisticEntry.SPELL, FightStatisticProperty.MISS_COUNTERS); // no hitsplat

    private final int graphicId;
    private final Skill requiredSkill;
    private final Skill invalidSkill;
    private final int animationId;
    private final boolean interactionRequired;
    private final FightStatisticEntry entry;
    private final FightStatisticProperty property;

    FightGraphic(int graphicId, Skill requiredSkill, Skill invalidSkill, int animationId, boolean interactionRequired, FightStatisticEntry entry, FightStatisticProperty property) {
        this.graphicId = graphicId;
        this.requiredSkill = requiredSkill;
        this.invalidSkill = invalidSkill;
        this.animationId = animationId;
        this.interactionRequired = interactionRequired;
        this.entry = entry;
        this.property = property;
    }

    public int getGraphicId()
    {
        return graphicId;
    }

    public Skill getRequiredSkill()
    {
        return requiredSkill;
    }

    public Skill getInvalidSkill()
    {
        return invalidSkill;
    }

    public int getAnimationId()
    {
        return animationId;
    }

    public boolean isInteractionRequired()
    {
        return interactionRequired;
    }

    public FightStatisticEntry getEntry()
    {
        return entry;
    }

    public FightStatisticProperty getProperty()
    {
        return property;
    }
}

package com.twitchliveloadout.fights;

import java.time.Instant;
import java.util.Comparator;

public class FightSorter implements Comparator<Fight>
{
	public int compare(Fight f1, Fight f2)
	{
		Instant lastUpdate = f1.getLastUpdate(true);
		Instant comparedLastUpdate = f2.getLastUpdate(true);
		long lastUpdateEpoch = (lastUpdate == null ? 0 : lastUpdate.getEpochSecond());
		long comparedLastUpdateEpoch = (comparedLastUpdate == null ? 0 : comparedLastUpdate.getEpochSecond());
		boolean isLater = lastUpdateEpoch > comparedLastUpdateEpoch;

		// check for equal
		if (lastUpdateEpoch == comparedLastUpdateEpoch)
		{
			return 0;
		}

		// descending order, from later to earlier fight
		return isLater ? -1 : 1;
	}
}

package com.twitchliveloadout.fights;

import lombok.Getter;

public enum FightStatisticEntry {
	TOTAL("total", true, true),
//	MELEE("melee", true, true),
//	MAGIC("magic", true, true),
//	RANGED("ranged", true, true),
	OTHER("other", true, false),

	FREEZE("freeze", true, true),
	ENTANGLE("entangle", true, true),
	HIT_HEAL("hitHeal", true, true),
	BLOOD_HEAL("bloodHeal", true, true),
	SPELL("spell", true, true),
	POISON("poison", false, true),
//	VENGEANCE("vengeance", true, true),
//	FOOD_HEAL("foodHeal", false, true),
//	SPECIAL_ATTACK("specialAttack", true, true),

//	PRAYER("prayer", false, true),
//	RANGED_PRAYER("rangedPrayer", false, true),
//	MELEE_PRAYER("meleePrayer", false, true),
//	MAGIC_PRAYER("magicPrayer", false, true),
	SMITE("smite", false, true);

	@Getter
	private final String key;

	@Getter
	private final boolean durationInfluencer;

	@Getter
	private final boolean updatedAtInfluencer;

	FightStatisticEntry(String key, boolean durationInfluencer, boolean updatedAtInfluencer)
	{
		this.key = key;
		this.durationInfluencer = durationInfluencer;
		this.updatedAtInfluencer = updatedAtInfluencer;
	}
}

package com.twitchliveloadout.fights;

import lombok.Getter;
import net.runelite.api.Skill;

public enum CombatStyle {
    MELEE("melee"),
    RANGED("ranged"),
    MAGIC("magic"),
    ;

    @Getter
    private final String key;

    CombatStyle(String key)
    {
        this.key = key;
    }
}

package com.twitchliveloadout.fights;

public final class HitsplatTypeID
{
	public static final int BLOCK_ME = 12;
	public static final int BLOCK_OTHER = 13;
	public static final int DAMAGE_ME = 16;
	public static final int DAMAGE_OTHER = 17;
	public static final int POISON = 65;
	public static final int DISEASE = 4;
	public static final int VENOM = 5;
	public static final int HEAL = 6;
	public static final int CYAN_UP = 11;
	public static final int CYAN_DOWN = 15;
	public static final int DAMAGE_ME_CYAN = 18;
	public static final int DAMAGE_OTHER_CYAN = 19;
	public static final int DAMAGE_ME_ORANGE = 20;
	public static final int DAMAGE_OTHER_ORANGE = 21;
	public static final int DAMAGE_ME_YELLOW = 22;
	public static final int DAMAGE_OTHER_YELLOW = 23;
	public static final int DAMAGE_ME_WHITE = 24;
	public static final int DAMAGE_OTHER_WHITE = 25;
	public static final int DAMAGE_MAX_ME = 43;
	public static final int DAMAGE_MAX_ME_CYAN = 44;
	public static final int DAMAGE_MAX_ME_ORANGE = 45;
	public static final int DAMAGE_MAX_ME_YELLOW = 46;
	public static final int DAMAGE_MAX_ME_WHITE = 47;
	public static final int DAMAGE_ME_POISE = 53;
	public static final int DAMAGE_OTHER_POISE = 54;
	public static final int DAMAGE_MAX_ME_POISE = 55;
	public static final int CORRUPTION = 0;
	public static final int PRAYER_DRAIN = 60;
	public static final int BLEED = 67;
	public static final int SANITY_DRAIN = 71;
	public static final int SANITY_RESTORE = 72;
	public static final int DOOM = 73;
	public static final int BURN = 74;
}

package com.twitchliveloadout.fights;

import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Actor;

import java.time.Instant;

@Slf4j
public class FightQueuedStatistic {
	private final Instant createdAt;
	private final Actor actor;
	private final FightStatisticEntry entry;
	private final FightStatisticProperty property;
	private final int expiryTimeMs;
	private boolean isRegistered = false;

	FightQueuedStatistic(Actor actor, FightStatisticEntry entry, FightStatisticProperty property, int expiryTimeMs)
	{
		this.createdAt = Instant.now();
		this.actor = actor;
		this.entry = entry;
		this.property = property;
		this.expiryTimeMs = expiryTimeMs;
	}

	public boolean isValid()
	{
		Instant now = Instant.now();
		Instant expiredAt = createdAt.plusMillis(expiryTimeMs);

		log.debug("Queued statistic time until expiry: {}", (expiredAt.toEpochMilli() - now.toEpochMilli()));

		return !isRegistered && !now.isAfter(expiredAt);
	}

	public void register()
	{
		isRegistered = true;
	}

	public Actor getActor()
	{
		return actor;
	}

	public FightStatisticEntry getEntry()
	{
		return entry;
	}

	public FightStatisticProperty getProperty()
	{
		return property;
	}
}

package com.twitchliveloadout.fights;

import java.time.Instant;

public class FightStatistic {
	private final FightSession session;

	private Instant firstUpdate;
	private Instant lastUpdate;
	private long hitDamage = 0;
	private long missDamage = 0;
	private long hitCounter = 0;
	private long missCounter = 0;

	public FightStatistic(FightSession session)
	{
		this.session = session;
	}

	public void registerHit(int damage)
	{
		hitDamage += damage;
		hitCounter ++;
		registerUpdate();
	}

	public void registerMiss(int damage)
	{
		missDamage += damage;
		missCounter ++;
		registerUpdate();
	}

	public void addStatistic(FightStatistic statistic)
	{
		Instant candidateFirstUpdate = statistic.getFirstUpdate();
		Instant candidateLastUpdate = statistic.getLastUpdate();

		hitDamage += statistic.getHitDamage();
		hitCounter += statistic.getHitCounter();
		missDamage += statistic.getMissDamage();
		missCounter += statistic.getMissCounter();

		if (firstUpdate == null || (candidateFirstUpdate != null && candidateFirstUpdate.isBefore(firstUpdate)))
		{
			firstUpdate = candidateFirstUpdate;
		}

		if (lastUpdate == null || (candidateLastUpdate != null && candidateLastUpdate.isAfter(lastUpdate)))
		{
			lastUpdate = candidateLastUpdate;
		}
	}

	public void registerUpdate()
	{
		final Instant now = Instant.now();

		if (firstUpdate == null)
		{
			firstUpdate = now;
		}

		lastUpdate = now;
		session.handleStatisticUpdate();
	}

	public long getDurationSeconds()
	{
		Instant lastUpdate = getLastUpdate();
		Instant firstUpdate = getFirstUpdate();

		if (lastUpdate == null || firstUpdate == null)
		{
			return 0;
		}

		return getLastUpdate().getEpochSecond() - getFirstUpdate().getEpochSecond();
	}

	public long getHitDamage()
	{
		return hitDamage;
	}

	public long getMissDamage()
	{
		return missDamage;
	}

	public long getHitCounter()
	{
		return hitCounter;
	}

	public long getMissCounter()
	{
		return missCounter;
	}

	public Instant getLastUpdate()
	{
		return lastUpdate;
	}

	public Instant getFirstUpdate()
	{
		return firstUpdate;
	}

	public boolean isEverUpdated()
	{
		return lastUpdate != null || firstUpdate != null;
	}

	public long getValueByProperty(FightStatisticProperty property)
	{
		final String key = property.getKey();

		if (key.equals(FightStatisticProperty.HIT_DAMAGES.getKey()))
		{
			return getHitDamage();
		}
		else if (key.equals(FightStatisticProperty.HIT_COUNTERS.getKey()))
		{
			return getHitCounter();
		}
		else if (key.equals(FightStatisticProperty.MISS_DAMAGES.getKey()))
		{
			return getMissDamage();
		}
		else if (key.equals(FightStatisticProperty.MISS_COUNTERS.getKey()))
		{
			return getMissCounter();
		}
		else if (key.equals(FightStatisticProperty.DURATION_SECONDS.getKey()))
		{
			return getDurationSeconds();
		}

		return 0;
	}

	public void reset()
	{
		hitDamage = 0;
		missDamage = 0;
		hitCounter = 0;
		missCounter = 0;

		firstUpdate = null;
		lastUpdate = null;
	}
}

package com.twitchliveloadout.fights;

import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Actor;
import net.runelite.api.GameObject;
import net.runelite.api.NPC;

import java.time.Instant;
import java.util.Collection;
import java.util.Iterator;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.CopyOnWriteArrayList;

import static com.twitchliveloadout.fights.FightStateManager.MAX_FINISHED_FIGHT_SESSION_AMOUNT;

@Slf4j
public class Fight {
	private final String actorName;
	private final int actorId;
	private final ActorType actorType;
	private final int actorCombatLevel;

	private final CopyOnWriteArrayList<FightQueuedStatistic> queuedStatistics = new CopyOnWriteArrayList<>();

	private final ConcurrentHashMap<Actor, FightSession> sessions = new ConcurrentHashMap<>();
	private final CopyOnWriteArrayList<FightSession> finishedSessions = new CopyOnWriteArrayList<>();

	// The session counter should not match the finished session list size,
	// because some finished sessions are not kills / deaths, separate counter for this.
	// For example when a fight expires due to time it should not register a kill / death.
	private int sessionCounter = 0;

	private long idleTickCounter = 0;
	private long idleQueuedTickCounter = 0;

	private Actor lastActor;
	private FightSession lastSession;

	public Fight(Actor actor, String actorName, boolean isLocalPlayer)
	{
		this.lastActor = actor;
		this.actorName = actorName;
		this.lastSession = ensureSession(actor);
		this.actorCombatLevel = actor.getCombatLevel();

		if (actor instanceof NPC)
		{
			actorId = ((NPC) actor).getId();
			actorType = ActorType.NPC;
		}
		else if (actor instanceof GameObject)
		{
			actorId = ((GameObject) actor).getId();
			actorType = ActorType.GAME_OBJECT;
		}
		else if (isLocalPlayer)
		{
			actorId = -1;
			actorType = ActorType.LOCAL_PLAYER;
		}
		else
		{
			actorId = -1;
			actorType = ActorType.PLAYER;
		}
	}

	public void queueStatistic(Actor actor, FightStatisticEntry entry, FightStatisticProperty property, int expiryTimeMs)
	{
		log.debug("Adding queued statistic: {} - {} - {} - {}", actor.getName(), entry.getKey(), property.getKey(), expiryTimeMs);
		FightQueuedStatistic queuedStatistic = new FightQueuedStatistic(actor, entry, property, expiryTimeMs);
		queuedStatistics.add(queuedStatistic);
		cleanQueuedStatistics();
	}

	public void registerQueuedStatistics(Actor actor, int hitsplatAmount)
	{
		log.debug("Checking queue statistics, queued size {} for hitsplat {}", queuedStatistics.size(), hitsplatAmount);

		// synchronized list does not seem to be needed here?
		Iterator<FightQueuedStatistic> iterator = queuedStatistics.iterator();
		while (iterator.hasNext())
		{
			FightQueuedStatistic queuedStatistic = iterator.next();
			Actor queuedActor = queuedStatistic.getActor();
			FightStatisticEntry entry = queuedStatistic.getEntry();
			FightStatisticProperty property = queuedStatistic.getProperty();

			log.debug("Attempt register queued statistic {} - {}", entry.getKey(), property.getKey());

			// Guard: check if this hitsplat is on the right actor
			if (actor != queuedActor)
			{
				log.debug("Skipping queued statistic because of wrong actor.");
				continue;
			}

			// Will prevent registering twice
			if (!queuedStatistic.isValid())
			{
				log.debug("Skipping queued statistic because of invalid.");
				continue;
			}

			FightStatistic statistic = ensureStatistic(actor, entry);

			if (property == FightStatisticProperty.MISS_DAMAGES || property == FightStatisticProperty.MISS_COUNTERS)
			{
				log.debug("Register queued statistic miss: {}", hitsplatAmount);
				statistic.registerMiss(hitsplatAmount);
			}
			else if (property == FightStatisticProperty.HIT_DAMAGES || property == FightStatisticProperty.HIT_COUNTERS)
			{
				log.debug("Register queued statistic hit: {}", hitsplatAmount);
				statistic.registerHit(hitsplatAmount);
			}

			// Flag to clean up later
			queuedStatistic.register();
		}
	}

	private void cleanQueuedStatistics()
	{
		Iterator<FightQueuedStatistic> iterator = queuedStatistics.iterator();

		while (iterator.hasNext()) {
			FightQueuedStatistic queuedStatistic = iterator.next();

			if (queuedStatistic.isValid()) {
				continue;
			}

			log.debug("Remove queued statistic {}", queuedStatistic.getEntry().getKey());
			queuedStatistics.remove(queuedStatistic);
		}
	}

	public FightStatistic ensureStatistic(Actor actor, FightStatisticEntry statisticEntry)
	{

		if (!sessions.containsKey(actor))
		{
			ensureSession(actor);
		}

		FightSession session = sessions.get(actor);

		return session.getStatistic(statisticEntry);
	}

	public void handleStatisticUpdate()
	{
		registerQueuedIdleTicks();
	}

	public void queueIdleTicks(long amount)
	{
		idleQueuedTickCounter += amount;
	}

	public void registerQueuedIdleTicks()
	{
		idleTickCounter += idleQueuedTickCounter;
		idleQueuedTickCounter = 0;
	}

	public long getIdleTickCounter()
	{
		return idleTickCounter;
	}

	public boolean hasSession(Actor actor)
	{
		return sessions.containsKey(actor);
	}

	public FightSession getSession(Actor actor)
	{
		return sessions.get(actor);
	}

	public FightSession ensureSession(Actor actor)
	{
		if (sessions.containsKey(actor))
		{
			return sessions.get(actor);
		}

		FightSession session = new FightSession(this);
		sessions.put(actor, session);

		return session;
	}

	public Instant getLastUpdate()
	{
		return getLastUpdate(false);
	}

	public Instant getLastUpdate(boolean updatedAtInfluencerOnly)
	{
		Instant maxLastUpdate = null;
		CopyOnWriteArrayList<FightSession> allSessions = getAllSessions();
		Iterator<FightSession> allSessionIterator = allSessions.iterator();

		while (allSessionIterator.hasNext())
		{
			FightSession session = allSessionIterator.next();
			Instant lastUpdate = session.getLastUpdate(updatedAtInfluencerOnly);

			if (lastUpdate == null)
			{
				continue;
			}

			if (maxLastUpdate == null || lastUpdate.isAfter(maxLastUpdate))
			{
				maxLastUpdate = lastUpdate;
			}
		}

		return maxLastUpdate;
	}

	public FightSession calculateTotalSession()
	{
		FightSession totalSession = new FightSession(this);
		CopyOnWriteArrayList<FightSession> allSessions = getAllSessions();
		Iterator<FightSession> allSessionIterator = allSessions.iterator();

		totalSession.addIdleTicks(idleTickCounter);

		while (allSessionIterator.hasNext())
		{
			FightSession session = allSessionIterator.next();
			totalSession.addInteractingTicks(session.getInteractingTickCounter());

			for (FightStatisticEntry statisticEntry : FightStatisticEntry.values())
			{
				FightStatistic totalStatistic = totalSession.getStatistic(statisticEntry);
				FightStatistic statistic = session.getStatistic(statisticEntry);

				totalStatistic.addStatistic(statistic);
			}
		}

		return totalSession;
	}

	public FightSession getLastSession()
	{
		return lastSession;
	}

	public boolean isIdling(CopyOnWriteArrayList<String> actorNames)
	{
		for (String actorName : actorNames)
		{

			// Not idling when the actor can be found in the surroundings
			// for some boss fights this would not work (e.g. The Gauntlet)
			// because often you are seeing the boss while prepping.
			// We accept these inconsistencies as it weighs out situations where
			// you are not interacting/attacking the boss due to a certain phase and
			// then we don't want idling to kick in to skew your DPS (e.g. certain Olm phases)
			if (this.actorName.equals(actorName))
			{
				return false;
			}
		}

		return true;
	}

	public void setLastActor(Actor actor)
	{
		this.lastActor = actor;
		this.lastSession = ensureSession(actor);
	}

	public void finishSession(Actor actor)
	{
		if (!hasSession(actor))
		{
			return;
		}

		FightSession session = getSession(actor);

		session.finish();

		// After finishing a session make sure the session
		// gets its dedicated key so that no new stats are added
		sessions.remove(actor);
		finishedSessions.add(session);

		if (finishedSessions.size() > MAX_FINISHED_FIGHT_SESSION_AMOUNT)
		{
			log.debug("Removing a finished session due to maximum amount reached...");
			finishedSessions.remove(0);
		}
	}

	public void increaseSessionCounter()
	{
		sessionCounter++;
	}

	public ActorType getActorType()
	{
		return actorType;
	}

	public Actor getLastActor()
	{
		return lastActor;
	}

	public int getActorId()
	{
		return actorId;
	}

	public String getActorName()
	{
		return actorName;
	}

	public int getActorCombatLevel()
	{
		return actorCombatLevel;
	}

	public int getSessionCounter()
	{
		return sessionCounter;
	}

	public Collection<FightSession> getOngoingSessions()
	{
		return sessions.values();
	}

	public CopyOnWriteArrayList<FightSession> getAllSessions()
	{
		CopyOnWriteArrayList<FightSession> allSessions = new CopyOnWriteArrayList<>();
		Iterator<FightSession> finishedSessionIterator = finishedSessions.iterator();
		Iterator<FightSession> sessionIterator = sessions.values().iterator();

		while (finishedSessionIterator.hasNext())
		{
			allSessions.add(finishedSessionIterator.next());
		}

		while (sessionIterator.hasNext())
		{
			allSessions.add(sessionIterator.next());
		}

		return allSessions;
	}
}

/*
 * Copyright (c) 2017, honeyhoney <https://github.com/honeyhoney>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.twitchliveloadout.fights;

import com.google.common.collect.Iterables;
import com.google.gson.JsonArray;
import com.google.gson.JsonObject;
import com.twitchliveloadout.TwitchLiveLoadoutConfig;
import com.twitchliveloadout.TwitchLiveLoadoutPlugin;
import com.twitchliveloadout.twitch.TwitchState;
import lombok.Getter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.*;
import net.runelite.api.events.*;

import java.time.Instant;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.CopyOnWriteArrayList;
import java.util.concurrent.ScheduledThreadPoolExecutor;
import java.util.concurrent.TimeUnit;

@Slf4j
public class FightStateManager
{
	@Getter
	private final ConcurrentHashMap<String, Fight> fights = new ConcurrentHashMap<>();
	private final TwitchLiveLoadoutPlugin plugin;
	private final TwitchLiveLoadoutConfig config;
	private final Client client;

	private static final int ON_GRAPHIC_CHANGED_DELAY = 200; // ms
	private final ScheduledThreadPoolExecutor scheduledExecutor = new ScheduledThreadPoolExecutor(1);

	public static final String HIDDEN_PLAYER_ACTOR_NAME = "__self__";
	public static final float GAME_TICK_DURATION = 0.6f; // seconds
	public static final int DEATH_ANIMATION_ID = 836;
	public static final int MAX_FIGHT_AMOUNT = 10;
	public static final int MAX_FINISHED_FIGHT_SESSION_AMOUNT = 1000;
	public static final int MAX_FIGHT_AMOUNT_IN_MEMORY = 50;
	public static final int MAX_FIGHT_DISTANCE = 15; // above max fight range on purpose

	public static final int GRAPHIC_HITSPLAT_EXPIRY_TIME_BASE = 1600; // ms
	public static final int GRAPHIC_HITSPLAT_EXPIRY_TIME_PER_SQUARE = 160; // ms, this varies for spell and enemy distance, this is an approximate

	public static final int GRAPHIC_SKILL_XP_DROP_EXPIRY_TIME = ON_GRAPHIC_CHANGED_DELAY + 50; // ms, takes around 5ms
	private final ConcurrentHashMap<Skill, Instant> lastSkillUpdates = new ConcurrentHashMap<>();
	private final ConcurrentHashMap<Skill, Integer> lastSkillXp = new ConcurrentHashMap<>();

	public static final int GRAPHIC_ANIMATION_EXPIRY_TIME = ON_GRAPHIC_CHANGED_DELAY + 50; // ms, takes around 5ms
	private final ConcurrentHashMap<Integer, Instant> lastAnimationUpdates = new ConcurrentHashMap<>();

	private static final int MAX_INTERACTING_ACTORS_HISTORY = 3;
	private static final int INTERACTING_ACTOR_EXPIRY_TIME = 3000; // ms
	private static final int DEATH_REGISTER_ACTOR_EXPIRY_TIME = 2 * 60000; // ms
	private static final boolean DEATH_REGISTER_MIN_DAMAGE_ENABLED = false;
	private static final float DEATH_REGISTER_MIN_DAMAGE_PERCENTAGE = 0.1f; // 0 to 1 scale
	private static final int INCOMING_FIGHT_SESSION_AUTO_EXPIRY_TIME = 60000; // ms
	private final ConcurrentHashMap<Actor, Instant> lastInteractingActors = new ConcurrentHashMap<>();

	private static final String ACTOR_NAME_KEY = "actorNames";
	private static final String ACTOR_TYPE_KEY = "actorTypes";
	private static final String ACTOR_ID_KEY = "actorIds";
	private static final String ACTOR_COMBAT_LEVEL_KEY = "actorCombatLevels";
	private static final String TOTAL_INTERACTING_TICKS_KEY = "totalInteractingTicks";
	private static final String LAST_INTERACTING_TICKS_KEY = "lastInteractingTicks";
	private static final String TOTAL_DURATIONS_KEY = "totalDurations";
	private static final String LAST_DURATIONS_KEY = "lastDurations";
	private static final String UPDATED_ATS_KEY = "updatedAts";
	private static final String SESSION_COUNTERS_KEY = "sessionCounters";
	private static final String STATISTICS_KEY = "statistics";

	public static final Skill NO_SKILL = null;
	public static final int NO_ANIMATION_ID = -1;
	public static final int SINGLE_ANCIENT_ANIMATION_ID = 1978;
	public static final int MULTI_ANCIENT_ANIMATION_ID = 1979;
	public static final int ENTANGLE_ANIMATION_ID = 1161;

	@Getter
	private int equippedWeaponTypeVarbit = -1;

	@Getter
	private AttackStyle currentAttackStyle;

	public FightStateManager(TwitchLiveLoadoutPlugin plugin, TwitchLiveLoadoutConfig config, Client client)
	{
		this.plugin = plugin;
		this.config = config;
		this.client = client;
	}

	public void shutDown()
	{
		clearScheduledUpdates();
		scheduledExecutor.shutdown();
	}

	public void onGraphicChanged(GraphicChanged event)
	{
		final Actor eventActor = event.getActor();
		final String eventActorName = getFormattedActorName(eventActor);
		final IterableHashTable<ActorSpotAnim> spotAnims = eventActor.getSpotAnims();

		// NOTE: collect this here to make sure the varbit and other things are fetched on the client thread
		final boolean isInMultiCombatArea = isInMultiCombatArea();
		final boolean otherPlayersPresent = otherPlayersPresent(eventActor);

		// guard: skip invalid graphics or actors
		if (spotAnims == null || eventActorName == null)
		{
			return;
		}

		final ArrayList<Integer> graphicIds = new ArrayList();

		// convert all the current graphic IDs to a fixed list
		// because the spot anims will mutate over time after the delayed action
		spotAnims.forEach((spotAnim) -> {
			graphicIds.add(spotAnim.getId());
		});

		log.debug("Scheduling delayed onGraphicChanged, graphic amount: {}", graphicIds.size());

		// delay the handler to make sure other events have time to also be triggered.
		// For example some graphics are translated to statistics, but require a certain skill
		// to receive XP for prevent various false positives when other players are around.
		// However, the XP events come in after the graphic event.
		scheduledExecutor.schedule(new Runnable()
		{
			public void run()
			{
				try {
					onGraphicChangedDelayed(eventActor, graphicIds, isInMultiCombatArea, otherPlayersPresent);
				} catch (Exception exception) {
					log.warn("Could not handle an delayed graphic on changed due to the following error: ", exception);
				}
			}
		}, ON_GRAPHIC_CHANGED_DELAY, TimeUnit.MILLISECONDS);
	}

	public void onVarbitChanged(VarbitChanged event)
	{
		if (event.getVarpId() == VarPlayer.ATTACK_STYLE
				|| event.getVarbitId() == Varbits.EQUIPPED_WEAPON_TYPE
				|| event.getVarbitId() == Varbits.DEFENSIVE_CASTING_MODE)
		{
			final int currentAttackStyleVarbit = client.getVarpValue(VarPlayer.ATTACK_STYLE);
			final int currentEquippedWeaponTypeVarbit = client.getVarbitValue(Varbits.EQUIPPED_WEAPON_TYPE);
			final int currentCastingModeVarbit = client.getVarbitValue(Varbits.DEFENSIVE_CASTING_MODE);

			equippedWeaponTypeVarbit = currentEquippedWeaponTypeVarbit;

			updateAttackStyle(equippedWeaponTypeVarbit, currentAttackStyleVarbit, currentCastingModeVarbit);
		}
	}

	public void clearScheduledUpdates()
	{
		scheduledExecutor.getQueue().clear();
	}

	public void onGraphicChangedDelayed(Actor eventActor, ArrayList<Integer> graphicIds, boolean isInMultiCombatArea, boolean otherPlayersPresent)
	{
		final Player localPlayer = client.getLocalPlayer();
		final boolean isLocalPlayer = (eventActor == localPlayer);

		log.debug("Handling delayed onGraphicChanged, graphic amount: {}", graphicIds.size());

		if (localPlayer == null)
		{
			return;
		}

		final Instant now = Instant.now();
		final Instant lastInteractedOn = lastInteractingActors.get(eventActor);
		final boolean lastInteractedWithExpired = (lastInteractedOn == null || lastInteractedOn.plusMillis(INTERACTING_ACTOR_EXPIRY_TIME).isBefore(now));
		final boolean validInteractingWith = !lastInteractedWithExpired;
		int distanceTo = localPlayer.getWorldLocation().distanceTo(eventActor.getWorldLocation());

		if (distanceTo > MAX_FIGHT_DISTANCE)
		{
			distanceTo = MAX_FIGHT_DISTANCE;
		}

		for (FightGraphic graphic : FightGraphic.values())
		{
			int fightGraphicId = graphic.getGraphicId();
			boolean interactionRequired = graphic.isInteractionRequired();
			FightStatisticProperty property = graphic.getProperty();
			FightStatisticEntry entry = graphic.getEntry();

			// Guard: check if this is the correct graphic
			if (!graphicIds.contains(fightGraphicId))
			{
				continue;
			}

			log.debug("Detected fight graphic, now validating... Graphic ID: {}", fightGraphicId);
			log.debug("Required skill time until expiry: {}", (lastInteractedOn == null ? "N/A" : (now.toEpochMilli() - lastInteractedOn.plusMillis(INTERACTING_ACTOR_EXPIRY_TIME).toEpochMilli())));

			// In singles interacting is always required.
			if (!isInMultiCombatArea)
			{
				interactionRequired = true;
			}

			// In multi-combat when there are no players the interaction is not required.
			// The one situation where this goes wrong is with NPC's that are also triggering graphics, such as splashes on other NPC's.
			// An example of this are the Spiritual Mages in GWD.
			if (!otherPlayersPresent && isInMultiCombatArea)
			{
				interactionRequired = false;
			}

			// Most checks only apply when the event target is not the local player
			if (!isLocalPlayer)
			{
				// Guard: single target spells can check whether the local player interacted with the actor.
				// In single combat area's interactions are always required
				if (interactionRequired && !validInteractingWith)
				{
					continue;
				}

				boolean validSkillUpdates = verifySkillsForFightGraphic(graphic);
				boolean validAnimationUpdates = verifyAnimationForFightGraphic(graphic);

				// Guard: check if the required skills and animations were recently updated.
				// This is to prevent false positives where for example another player is splashing on the enemy
				// and the local player is interacting with that enemy. By checking a skill xp drop we can filter
				// these false positives partially.
				if (!validSkillUpdates || !validAnimationUpdates)
				{
					continue;
				}
			}

			// When all checks passed make sure the fight exists
			Fight fight = ensureValidFight(eventActor);

			if (property == FightStatisticProperty.MISS_COUNTERS || property == FightStatisticProperty.MISS_DAMAGES)
			{
				FightStatistic statistic = fight.ensureStatistic(eventActor, entry);
				statistic.registerMiss(0);
			}
			else if (property == FightStatisticProperty.HIT_COUNTERS)
			{
				FightStatistic statistic = fight.ensureStatistic(eventActor, entry);
				statistic.registerHit(0);
			}
			else if (property == FightStatisticProperty.HIT_DAMAGES)
			{
				log.debug("The distance to the enemy for the queue expiry time was: {}", distanceTo);
				final int expiryTimeMs = GRAPHIC_HITSPLAT_EXPIRY_TIME_BASE + GRAPHIC_HITSPLAT_EXPIRY_TIME_PER_SQUARE * distanceTo;
				fight.queueStatistic(eventActor, entry, property, expiryTimeMs);
			}
		}
	}

	private boolean verifySkillsForFightGraphic(FightGraphic graphic)
	{
		Instant now = Instant.now();
		Skill requiredSkill = graphic.getRequiredSkill();
		Skill invalidSkill = graphic.getInvalidSkill();

		// Guard: skip spell tracking when disabled
		if (requiredSkill == Skill.MAGIC && !config.fightStatisticsSpellsEnabled())
		{
			return false;
		}

		if (requiredSkill != null)
		{
			Instant requiredSkillUpdate = lastSkillUpdates.get(requiredSkill);

			// Guard: skip when there was no update at all
			if (requiredSkillUpdate == null)
			{
				return false;
			}

			Instant requiredSkillExpiryTime = requiredSkillUpdate.plusMillis(GRAPHIC_SKILL_XP_DROP_EXPIRY_TIME);
			boolean requiredSkillIsExpired = now.isAfter(requiredSkillExpiryTime);

			log.debug("Required skill time until expiry: {}", (requiredSkillExpiryTime.toEpochMilli() - now.toEpochMilli()));

			if (requiredSkillIsExpired)
			{
				return false;
			}
		}

		if (invalidSkill != null)
		{
			Instant invalidSkillUpdate = lastSkillUpdates.get(invalidSkill);

			// Guard: skip when there was no update at all
			if (invalidSkillUpdate == null)
			{
				return true;
			}

			Instant invalidSkillExpiryTime = invalidSkillUpdate.plusMillis(GRAPHIC_SKILL_XP_DROP_EXPIRY_TIME);
			boolean invalidSkillIsExpired = now.isAfter(invalidSkillExpiryTime);

			log.debug("Invalid skill time until expiry: {}", (invalidSkillExpiryTime.toEpochMilli() - now.toEpochMilli()));

			if (!invalidSkillIsExpired)
			{
				return false;
			}
		}

		return true;
	}

	private boolean verifyAnimationForFightGraphic(FightGraphic graphic)
	{
		Instant now = Instant.now();
		int requiredAnimationId = graphic.getAnimationId();
		Instant requiredSkillUpdate = lastAnimationUpdates.get(requiredAnimationId);

		// Guard: check if an animation should be checked
		if (requiredAnimationId < 0)
		{
			return true;
		}

		// Guard: skip when there was no update at all
		if (requiredSkillUpdate == null)
		{
			return false;
		}

		Instant requiredAnimationExpiryTime = requiredSkillUpdate.plusMillis(GRAPHIC_ANIMATION_EXPIRY_TIME);
		boolean requiredAnimationIsExpired = now.isAfter(requiredAnimationExpiryTime);

		log.debug("Animation time until expiry: {}", (requiredAnimationExpiryTime.toEpochMilli() - now.toEpochMilli()));

		if (requiredAnimationIsExpired)
		{
			return false;
		}

		return true;
	}

	public void onAnimationChanged(AnimationChanged event)
	{
		Actor eventActor = event.getActor();
		int animationId = eventActor.getAnimation();
		Player localPlayer = client.getLocalPlayer();

		// Handle animation updates
		if (eventActor == localPlayer)
		{
			lastAnimationUpdates.put(animationId, Instant.now());
		}

		// Handle local player deaths as we cannot use the despawned event
		if (eventActor == localPlayer && animationId == DEATH_ANIMATION_ID)
		{
			if (!hasFight(eventActor))
			{
				return;
			}

			Fight fight = getFight(eventActor);

			fight.finishSession(eventActor);
			fight.increaseSessionCounter();
		}
	}

	public void onHitsplatApplied(HitsplatApplied event)
	{
		Actor eventActor = event.getActor();
		Hitsplat hitsplat = event.getHitsplat();
		Player player = client.getLocalPlayer();
		HeadIcon headIcon = player.getOverheadIcon();
		int hitsplatType = hitsplat.getHitsplatType();
		boolean isOnSelf = isLocalPlayer(eventActor);

		// Guard: some hitsplats can come from other sources and we will only handle them
		// when there is already a fight to prevent random fights to appear out of nowhere
		// because of activity of others.
		if (hitsplatType == HitsplatTypeID.POISON || hitsplatType == HitsplatTypeID.VENOM)
		{
			registerExistingFightHitsplat(eventActor, FightStatisticEntry.POISON, hitsplat);
			return;
		}

		if (hitsplatType == HitsplatTypeID.HEAL)
		{
			registerExistingFightHitsplat(eventActor, FightStatisticEntry.HIT_HEAL, hitsplat);
			return;
		}

		if (hitsplatType == HitsplatTypeID.DISEASE)
		{
			// not worth tracking
			return;
		}

		// Guard: check if the hitsplat is damage of the local player
		// if not we will register it as a hit from an 'other' source that is also useful
		// when showing the combat statistics
		if (!hitsplat.isMine())
		{
			if (config.fightStatisticsOthersEnabled())
			{
				registerExistingFightHitsplat(eventActor, FightStatisticEntry.OTHER, hitsplat);
			}
			return;
		}

		// TODO: later recognize what damage type was done (magic, ranged or melee).
		registerEnsuredFightHitsplat(eventActor, FightStatisticEntry.TOTAL, hitsplat);

		// Register damage done while having smite up and dealing damage to other entity
		if (!isOnSelf && isPlayer(eventActor) && headIcon == HeadIcon.SMITE)
		{
			registerEnsuredFightHitsplat(eventActor, FightStatisticEntry.SMITE, hitsplat);
		}
	}

	public void onNpcDespawned(NpcDespawned npcDespawned)
	{
		final NPC npc = npcDespawned.getNpc();
		final Actor eventActor = npcDespawned.getActor();

		if (!npc.isDead())
		{
			return;
		}

		onActorDespawned(eventActor);
	}

	public void onPlayerDespawned(PlayerDespawned playerDespawned)
	{
		final Player player = playerDespawned.getPlayer();
		final Actor eventActor = playerDespawned.getActor();

		// Guard: make sure the player died
		if (player.getHealthRatio() != 0)
		{
			return;
		}

		onActorDespawned(eventActor);
	}

	private void onActorDespawned(Actor eventActor)
	{

		if (!hasFight(eventActor))
		{
			return;
		}

		Instant now = Instant.now();
		Fight fight = getFight(eventActor);
		FightSession session = fight.getSession(eventActor);

		if (session == null)
		{
			return;
		}

		Instant lastUpdate = session.getLastUpdate(true);
		FightStatistic totalStatistic = session.getStatistic(FightStatisticEntry.TOTAL);
		FightStatistic otherStatistic = session.getStatistic(FightStatisticEntry.OTHER);
		double totalDamage = totalStatistic.getHitDamage();
		double otherDamage = otherStatistic.getHitDamage();
		double allDamage = totalDamage + otherDamage;
		boolean didEnoughDamage = allDamage > 0 && ((totalDamage / allDamage) > DEATH_REGISTER_MIN_DAMAGE_PERCENTAGE);

		if (DEATH_REGISTER_MIN_DAMAGE_ENABLED && !didEnoughDamage)
		{
			return;
		}

		// Guard: skip the register of the de-spawn if the local player activity was too long ago
		if (lastUpdate == null || lastUpdate.plusMillis(DEATH_REGISTER_ACTOR_EXPIRY_TIME).isBefore(now))
		{
			return;
		}

		fight.finishSession(eventActor);
		fight.increaseSessionCounter();
	}

	public void onInteractingChanged(InteractingChanged interactingChanged)
	{
		Actor source = interactingChanged.getSource();
		Actor target = interactingChanged.getTarget();
		Actor localPlayer = client.getLocalPlayer();

		if (source != localPlayer)
		{
			return;
		}

		if (target == null)
		{
			return;
		}

		log.debug("Adding last interacting target to {}", target.getName());

		lastInteractingActors.put(target, Instant.now());

		if (lastInteractingActors.size() > MAX_INTERACTING_ACTORS_HISTORY)
		{
			rotateOldestInteractingActor();
		}
	}

	private void rotateOldestInteractingActor()
	{
		Actor oldestActor = null;

		for (Actor interactingActor : lastInteractingActors.keySet())
		{
			Instant lastUpdate = lastInteractingActors.get(interactingActor);
			Instant oldestLastUpdate = (oldestActor == null ? null : lastInteractingActors.get(oldestActor));

			if (oldestLastUpdate == null || lastUpdate.isBefore(oldestLastUpdate))
			{
				oldestActor = interactingActor;
			}
		}

		if (oldestActor == null)
		{
			return;
		}

		lastInteractingActors.remove(oldestActor);
	}

	public void onStatChanged(StatChanged event)
	{
		Skill skill = event.getSkill();
		Integer newExperience = client.getSkillExperience(skill);
		Integer lastExperience = lastSkillXp.get(skill);

		// Guard: make sure experience was added
		// Note: we use the int object to allow for null
		if (newExperience.equals(lastExperience))
		{
			return;
		}

		lastSkillXp.put(skill, newExperience);
		registerSkillUpdate(skill);
	}

	public void onFakeXpDrop(FakeXpDrop event)
	{
		Skill skill = event.getSkill();

		registerSkillUpdate(skill);
	}

	public void onGameTick()
	{
		registerIdleGameTick();
		registerInteractingGameTick();
	}

	private void registerIdleGameTick()
	{
		if (!config.fightStatisticsAutoIdling())
		{
			return;
		}

		final boolean isLoggedIn = (client.getGameState() == GameState.LOGGED_IN);
		final CopyOnWriteArrayList<String> actorNames = getOtherActorNames();

		for (Fight fight : fights.values())
		{
			if (!fight.isIdling(actorNames) && isLoggedIn)
			{
				continue;
			}

			// add shared idle ticks for the total session
			fight.queueIdleTicks(1);

			// add a tick to all of the sessions that currently exist
			// to get the right duration of the last session
			for (FightSession session : fight.getOngoingSessions())
			{
				session.queueIdleTicks(1);
			}
		}
	}

	private void registerInteractingGameTick()
	{
		Player localPlayer = client.getLocalPlayer();

		if (localPlayer == null)
		{
			return;
		}

		Actor interactingActor = localPlayer.getInteracting();

		if (interactingActor == null)
		{
			return;
		}

		// Always update the current interacting actor to make sure it doesn't expire
		// while the local player is still interacting with them
		lastInteractingActors.put(interactingActor, Instant.now());

		// Guard: only handle game tick when a fight is initiated (which means one hitsplat was dealt).
		// This is to prevent non-attackable NPC's to also count interacting game ticks.
		if (!hasFight(interactingActor))
		{
			return;
		}

		Fight fight = getFight(interactingActor);

		if (!fight.hasSession(interactingActor))
		{
			return;
		}

		FightSession session = fight.getSession(interactingActor);
		session.addInteractingTicks(1);
	}

	private void registerExistingFightHitsplat(Actor actor, FightStatisticEntry statisticEntry, Hitsplat hitsplat)
	{
		Fight fight = getFight(actor);

		// Guard: check the fight is existing
		if (fight == null)
		{
			return;
		}

		// Guard: check if a session exists for this specific actor.
		// This will prevent hitsplats of others / poison / venom on actors
		// that were never attacked by the local player to be added
		if (!config.fightStatisticsUnattackedEnabled() && !fight.hasSession(actor))
		{
			return;
		}

		registerFightHitsplat(fight, actor, statisticEntry, hitsplat);
	}

	private void registerEnsuredFightHitsplat(Actor actor, FightStatisticEntry statisticEntry, Hitsplat hitsplat)
	{
		Fight fight = ensureValidFight(actor);

		registerFightHitsplat(fight, actor, statisticEntry, hitsplat);
	}

	private void registerFightHitsplat(Fight fight, Actor actor, FightStatisticEntry statisticEntry, Hitsplat hitsplat)
	{
		if (fight == null)
		{
			return;
		}

		Instant now = Instant.now();
		boolean isOnSelf = isLocalPlayer(actor);

		// check if we should automatically finish the last session for incoming damage
		// as it is timed out. This is because the incoming fight sessions are only finishing
		// when the local player died and this is not always indicating a fight ending.
		// An automatic timeout for this makes sense.
		if (isOnSelf)
		{
			Instant lastUpdate = fight.getLastUpdate();

			if (lastUpdate != null && lastUpdate.plusMillis(INCOMING_FIGHT_SESSION_AUTO_EXPIRY_TIME).isBefore(now))
			{
				fight.finishSession(actor);
			}
		}

		int amount = hitsplat.getAmount();
		int hitsplatType = hitsplat.getHitsplatType();

		// NOTE: get the statistic after the fight session was potentially ended!
		FightStatistic statistic = fight.ensureStatistic(actor, statisticEntry);

		// Only update the last actor when the damage is dealt by the local player
		// the other hitsplats are merely for statistic purposes
		if (hitsplat.isMine())
		{
			fight.setLastActor(actor);
		}

		// Handle this damage as being part of the queued statistics.
		// Note that only hitsplats by the local player are handled to
		// prevent other player hits to trigger the queueing
		if (hitsplat.isMine())
		{
			fight.registerQueuedStatistics(actor, amount);
		}

		// Check for block or damage
		// NOTE: we explicitly don't have a default
		// to make sure the behaviour is predictable after updates
		switch (hitsplatType)
		{
			case HitsplatTypeID.DISEASE:
				// not handled
				break;
			case HitsplatTypeID.BLOCK_ME:
			case HitsplatTypeID.BLOCK_OTHER:
				statistic.registerMiss(amount);
				break;
			case HitsplatTypeID.DAMAGE_ME:
			case HitsplatTypeID.DAMAGE_ME_CYAN:
			case HitsplatTypeID.DAMAGE_ME_ORANGE:
			case HitsplatTypeID.DAMAGE_ME_WHITE:
			case HitsplatTypeID.DAMAGE_ME_YELLOW:
			case HitsplatTypeID.DAMAGE_ME_POISE:
			case HitsplatTypeID.DAMAGE_OTHER:
			case HitsplatTypeID.DAMAGE_OTHER_CYAN:
			case HitsplatTypeID.DAMAGE_OTHER_ORANGE:
			case HitsplatTypeID.DAMAGE_OTHER_WHITE:
			case HitsplatTypeID.DAMAGE_OTHER_YELLOW:
			case HitsplatTypeID.DAMAGE_OTHER_POISE:
			case HitsplatTypeID.VENOM:
			case HitsplatTypeID.POISON:
			case HitsplatTypeID.HEAL:
			case HitsplatTypeID.DAMAGE_MAX_ME:
			case HitsplatTypeID.DAMAGE_MAX_ME_CYAN:
			case HitsplatTypeID.DAMAGE_MAX_ME_ORANGE:
			case HitsplatTypeID.DAMAGE_MAX_ME_WHITE:
			case HitsplatTypeID.DAMAGE_MAX_ME_YELLOW:
			case HitsplatTypeID.DAMAGE_MAX_ME_POISE:
			case HitsplatTypeID.DOOM:
			case HitsplatTypeID.BURN:
			case HitsplatTypeID.BLEED:
				statistic.registerHit(amount);
				break;
		}
	}

	private void registerSkillUpdate(Skill skill)
	{
		lastSkillUpdates.put(skill, Instant.now());
	}

	public Fight ensureValidFight(Actor actor)
	{
		if (!hasFight(actor))
		{
			createFight(actor);
		}

		Fight fight = getFight(actor);
		Instant now = Instant.now();
		Instant lastUpdate = fight.getLastUpdate();
		long expiryTime = config.fightStatisticsExpiryTime() * 60L;

		// refresh when fight is expired and the statistics will be non-representative
		if (lastUpdate != null)
		{
			long lastUpdateDelta = now.getEpochSecond() - lastUpdate.getEpochSecond();

			if (lastUpdateDelta > expiryTime)
			{
				deleteFight(fight);
				createFight(actor);
			}
		}

		return getFight(actor);
	}

	public Fight getFight(Actor actor)
	{
		String actorName = getFormattedActorName(actor);

		// guard: make sure the actor is valid
		if (actorName == null)
		{
			return null;
		}

		return fights.get(actorName);
	}

	public boolean hasFight(Actor actor)
	{
		String actorName = getFormattedActorName(actor);

		// guard: make sure the actor is valid
		if (actorName == null)
		{
			return false;
		}

		return fights.containsKey(actorName);
	}

	public void createFight(Actor actor)
	{
		String localPlayerName = client.getLocalPlayer().getName();
		boolean isLocalPlayer = (actor instanceof Player) && localPlayerName.equals(actor.getName());
		String actorName = getFormattedActorName(actor);
		Fight fight = new Fight(actor, actorName, isLocalPlayer);

		// Rotate fights to prevent memory leaks when the client is on for a long time
		while (fights.size() >= MAX_FIGHT_AMOUNT_IN_MEMORY)
		{
			rotateOldestFight();
		}

		log.debug("Creating new fight for actor {}", actorName);

		fights.put(actorName, fight);
		updateCombatPanel();
	}

	public void deleteFight(Fight fight)
	{

		// guard: check if the fight is valid
		if (fight == null)
		{
			return;
		}

		log.debug("Removing a fight for actor {}", fight.getActorName());

		String actorName = fight.getActorName();
		fights.remove(actorName);
		updateCombatPanel();
	}

	public void rotateOldestFight()
	{
		Instant oldestLastUpdate = null;
		Fight oldestFight = null;

		for (Fight fight : fights.values())
		{
			Instant lastUpdate = fight.getLastUpdate();

			if (oldestLastUpdate == null || lastUpdate == null || lastUpdate.isBefore(oldestLastUpdate))
			{
				oldestLastUpdate = lastUpdate;
				oldestFight = fight;
			}
		}

		if (oldestFight == null)
		{
			return;
		}

		deleteFight(oldestFight);
	}

	public void deleteAllFights()
	{
		fights.clear();
		updateCombatPanel();
	}

	private void updateCombatPanel()
	{
		plugin.getPluginPanel().getCombatPanel().rebuild();
	}

	public JsonObject getFightStatisticsState()
	{
		CopyOnWriteArrayList<Fight> includedFights = new CopyOnWriteArrayList<>();
		CopyOnWriteArrayList<FightStatisticEntry> includedStatisticEntries = new CopyOnWriteArrayList<>();

		final JsonObject state = new JsonObject();
		JsonObject statistics = new JsonObject();
		JsonArray actorNames = new JsonArray();
		JsonArray actorTypes = new JsonArray();
		JsonArray actorIds = new JsonArray();
		JsonArray actorCombatLevels = new JsonArray();
		JsonArray totalInteractingTicks = new JsonArray();
		JsonArray lastInteractingTicks = new JsonArray();
		JsonArray totalDurations = new JsonArray();
		JsonArray lastDurations = new JsonArray();
		JsonArray sessionCounters = new JsonArray();
		JsonArray updatedAts = new JsonArray();

		// prepare the default included fights
		for (Fight fight : fights.values())
		{
			String actorName = fight.getActorName();

			// guard: check if the actor name is valid
			// NOTE: it can somehow happen that something is attacked with an actor name of 'null'
			// this has been seen with various streamers.
			if (actorName == null || actorName.equals("null"))
			{
				continue;
			}

			includedFights.add(fight);
		}

		// override the included fights when we want to stress test the state
		if (TwitchState.STATE_STRESS_TEST_ENABLED && fights.size() > 0)
		{
			final int maxFightAmount = getMaxFightAmountInState();
			final Fight firstFight = fights.values().iterator().next();
			includedFights.clear();

			for (int fightIndex = 0; fightIndex < maxFightAmount; fightIndex++)
			{
				includedFights.add(firstFight);
			}
		}

		int fightAmount = includedFights.size();
		int maxFightAmountInState = getMaxFightAmountInState();

		if (fightAmount > maxFightAmountInState) {
			fightAmount = maxFightAmountInState;
		}

		// order by last update time
		includedFights.sort(new FightSorter());

		// only send a specific maximum to Twitch
		CopyOnWriteArrayList<Fight> slicedFights = new CopyOnWriteArrayList<>(includedFights.subList(0, fightAmount));

		state.add(ACTOR_NAME_KEY, actorNames);
		state.add(ACTOR_TYPE_KEY, actorTypes);
		state.add(ACTOR_ID_KEY, actorIds);
		state.add(ACTOR_COMBAT_LEVEL_KEY, actorCombatLevels);

		state.add(TOTAL_INTERACTING_TICKS_KEY, totalInteractingTicks);
		state.add(LAST_INTERACTING_TICKS_KEY, lastInteractingTicks);

		state.add(TOTAL_DURATIONS_KEY, totalDurations);
		state.add(LAST_DURATIONS_KEY, lastDurations);

		state.add(SESSION_COUNTERS_KEY, sessionCounters);
		state.add(UPDATED_ATS_KEY, updatedAts);

		state.add(STATISTICS_KEY, statistics);

		for (FightStatisticEntry statisticEntry : FightStatisticEntry.values())
		{
			JsonObject fightStatistic = new JsonObject();

			for (FightStatisticProperty property : FightStatisticProperty.values())
			{
				fightStatistic.add(property.getKey(), new JsonArray());
			}

			statistics.add(statisticEntry.getKey(), fightStatistic);
		}

		for (Fight fight : slicedFights)
		{
			FightSession totalSession = fight.calculateTotalSession();
			FightSession lastSession = fight.getLastSession();
			String actorName = fight.getActorName();
			Instant lastUpdate = fight.getLastUpdate(true);

			// Hide display name when this is not allowed to be published due to the config
			if (fight.getActorType() == ActorType.LOCAL_PLAYER && !config.playerInfoEnabled())
			{
				actorName = HIDDEN_PLAYER_ACTOR_NAME;
			}

			actorNames.add(actorName);
			actorTypes.add(fight.getActorType().getKey());
			actorIds.add(fight.getActorId());
			actorCombatLevels.add(fight.getActorCombatLevel());

			totalInteractingTicks.add(totalSession.getInteractingTickCounter());
			lastInteractingTicks.add(lastSession.getInteractingTickCounter());

			totalDurations.add(totalSession.getDurationSeconds());
			lastDurations.add(lastSession.getDurationSeconds());

			sessionCounters.add(fight.getSessionCounter());
			updatedAts.add(lastUpdate == null ? 0 : lastUpdate.getEpochSecond());

			for (FightStatisticEntry statisticEntry : FightStatisticEntry.values())
			{
				FightStatistic totalStatistic = totalSession.getStatistic(statisticEntry);
				FightStatistic lastStatistic = lastSession.getStatistic(statisticEntry);
				JsonObject statisticState = statistics.getAsJsonObject(statisticEntry.getKey());

				for (FightStatisticProperty property : FightStatisticProperty.values())
				{
					long totalValue = totalStatistic.getValueByProperty(property);
					long lastValue = lastStatistic.getValueByProperty(property);
					JsonArray totalAndLastValue = new JsonArray();

					// check if we need to test the maximum state
					if (TwitchState.STATE_STRESS_TEST_ENABLED)
					{
						totalValue = (int) (Math.random() * TwitchState.MAX_FIGHT_STATISTIC_VALUE);
						lastValue = (int) (Math.random() * TwitchState.MAX_FIGHT_STATISTIC_VALUE);
					}

					if (totalStatistic.isEverUpdated() || lastStatistic.isEverUpdated())
					{
						if (!includedStatisticEntries.contains(statisticEntry))
						{
							includedStatisticEntries.add(statisticEntry);
						}
					}

					totalAndLastValue.add(totalValue);
					totalAndLastValue.add(lastValue);
					statisticState.getAsJsonArray(property.getKey()).add(totalAndLastValue);
				}
			}
		}

		// Save space by filtering out the statistics that have only 0 values.
		// This happens quite often as for example the majority of activities don't
		// have any freezes, heals, blood heals, smite drains etc.
		for (FightStatisticEntry statisticEntry : FightStatisticEntry.values())
		{
			if (!includedStatisticEntries.contains(statisticEntry))
			{
				statistics.remove(statisticEntry.getKey());
			}
		}

		return state;
	}

	private boolean isPlayer(Actor actor)
	{
		return actor instanceof Player;
	}

	private boolean isLocalPlayer(Actor actor)
	{
		if (!isPlayer(actor))
		{
			return false;
		}

		Player player = (Player) actor;
		Player localPlayer = client.getLocalPlayer();

		return player == localPlayer;
	}

	public String getFormattedActorName(Actor actor)
	{
		if (actor == null)
		{
			return null;
		}

		String actorName = actor.getName();

		if (actorName == null)
		{
			return null;
		}

		// Remove any HTML-like tags from the actor name, this is the case
		// for example with objects getting a <col=00ffff>name</col> tag
		String formattedActorName = actorName.replaceAll("\\<[^>]*>","");

		return formattedActorName;
	}

	public boolean isInMultiCombatArea()
	{
		int multiCombatVarBit = client.getVarbitValue(Varbits.MULTICOMBAT_AREA);

		return multiCombatVarBit == 1;
	}

	public boolean otherPlayersPresent(Actor allowedActor)
	{
		// one is to account for the local player themselves
		int allowedPlayerAmount = 1;
		int playerAmount = Iterables.size(client.getTopLevelWorldView().players());

		// one for when the currently interacted actor is a player
		if (allowedActor instanceof Player) {
			allowedPlayerAmount += 1;
		}

		return playerAmount > allowedPlayerAmount;
	}

	public CopyOnWriteArrayList<String> getOtherActorNames()
	{
		final CopyOnWriteArrayList<String> actorNames = new CopyOnWriteArrayList<>();
		WorldView worldView = client.getTopLevelWorldView();
		Iterator<? extends NPC> npcIterator = worldView.npcs().iterator();
		Iterator<? extends Player> playerIterator = worldView.players().iterator();

		while (npcIterator.hasNext())
		{
			NPC npc = npcIterator.next();
			actorNames.add(npc.getName());
		}

		while (playerIterator.hasNext())
		{
			Player player = playerIterator.next();
			actorNames.add(player.getName());
		}

		return actorNames;
	}

	public int getMaxFightAmountInState()
	{
		int maxAmount = config.fightStatisticsMaxFightAmount();

		if (maxAmount > MAX_FIGHT_AMOUNT)
		{
			maxAmount = MAX_FIGHT_AMOUNT;
		}

		if (maxAmount < 0)
		{
			maxAmount = 0;
		}

		return maxAmount;
	}

	private void updateAttackStyle(int equippedWeaponType, int attackStyleIndex, int castingMode)
	{
		AttackStyle[] attackStyles = getWeaponTypeStyles(equippedWeaponType);
		if (attackStyleIndex < attackStyles.length)
		{
			// from script4525
			// Even though the client has 5 attack styles for Staffs, only attack styles 0-4 are used, with an additional
			// casting mode set for defensive casting
			if (attackStyleIndex == 4)
			{
				attackStyleIndex += castingMode;
			}

			currentAttackStyle = attackStyles[attackStyleIndex];
			if (currentAttackStyle == null)
			{
				currentAttackStyle = AttackStyle.OTHER;
			}
		}
	}

	private AttackStyle[] getWeaponTypeStyles(int weaponType)
	{
		// from script4525
		int weaponStyleEnum = client.getEnum(EnumID.WEAPON_STYLES).getIntValue(weaponType);
		int[] weaponStyleStructs = client.getEnum(weaponStyleEnum).getIntVals();

		AttackStyle[] styles = new AttackStyle[weaponStyleStructs.length];
		int i = 0;
		for (int style : weaponStyleStructs)
		{
			StructComposition attackStyleStruct = client.getStructComposition(style);
			String attackStyleName = attackStyleStruct.getStringValue(ParamID.ATTACK_STYLE_NAME);

			AttackStyle attackStyle = AttackStyle.valueOf(attackStyleName.toUpperCase());
			if (attackStyle == AttackStyle.OTHER)
			{
				// "Other" is used for no style
				++i;
				continue;
			}

			// "Defensive" is used for Defensive and also Defensive casting
			if (i == 5 && attackStyle == AttackStyle.DEFENSIVE)
			{
				attackStyle = AttackStyle.DEFENSIVE_CASTING;
			}

			styles[i++] = attackStyle;
		}
		return styles;
	}

	public boolean isCurrentCombatStyle(String combatStyleKey) {
		if (currentAttackStyle == null)
		{
			return CombatStyle.MELEE.getKey().equals(combatStyleKey);
		}

		return currentAttackStyle.getCombatStyle().getKey().equals(combatStyleKey);
	}
}

package com.twitchliveloadout.fights;

import java.time.Instant;
import java.util.concurrent.ConcurrentHashMap;
import java.util.Map;

import static com.twitchliveloadout.fights.FightStateManager.*;

public class FightSession {
	private final Fight fight;

	private ConcurrentHashMap<FightStatisticEntry, FightStatistic> statistics = new ConcurrentHashMap<>();
	private long interactingTickCounter = 0;
	private long idleTickCounter = 0;
	private long idleQueuedTickCounter = 0;
	private boolean finished = false;

	public FightSession(Fight fight)
	{
		this.fight = fight;

		for (FightStatisticEntry statisticEntry : FightStatisticEntry.values())
		{
			statistics.put(statisticEntry, new FightStatistic(this));
		}
	}

	public FightStatistic getStatistic(FightStatisticEntry statisticEntry)
	{
		return statistics.get(statisticEntry);
	}

	public void handleStatisticUpdate()
	{
		registerQueuedIdleTicks();
		fight.handleStatisticUpdate();
	}

	public void addInteractingTicks(long amount)
	{
		interactingTickCounter += amount;
	}

	public void addIdleTicks(long amount)
	{
		idleTickCounter += amount;
	}

	public void queueIdleTicks(long amount)
	{
		idleQueuedTickCounter += amount;
	}

	public void registerQueuedIdleTicks()
	{
		idleTickCounter += idleQueuedTickCounter;
		idleQueuedTickCounter = 0;
	}

	public long getInteractingTickCounter()
	{
		return interactingTickCounter;
	}

	public long getIdleTickCounter()
	{
		return idleTickCounter;
	}

	public long getIdleDuration()
	{
		return (long) (idleTickCounter * GAME_TICK_DURATION);
	}

	public long getDurationSeconds()
	{
		Instant lastUpdate = getLastUpdate();
		Instant firstUpdate = getFirstUpdate();

		if (lastUpdate == null || firstUpdate == null)
		{
			return 0;
		}

		return getLastUpdate().getEpochSecond() - getFirstUpdate().getEpochSecond() - getIdleDuration();
	}

	public void finish()
	{
		finished = true;
	}

	public boolean isFinished()
	{
		return finished;
	}

	public Instant getFirstUpdate()
	{
		Instant minFirstUpdate = null;

		for (Map.Entry<FightStatisticEntry, FightStatistic> entry : statistics.entrySet())
		{
			final FightStatisticEntry statisticEntry = entry.getKey();
			final FightStatistic statistic = entry.getValue();
			final Instant firstUpdate = statistic.getFirstUpdate();

			if (!statisticEntry.isDurationInfluencer() || firstUpdate == null)
			{
				continue;
			}

			if (minFirstUpdate == null || firstUpdate.isBefore(minFirstUpdate))
			{
				minFirstUpdate = firstUpdate;
			}
		}

		return minFirstUpdate;
	}

	public Instant getLastUpdate()
	{
		return getLastUpdate(false);
	}

	public Instant getLastUpdate(boolean updatedAtInfluencerOnly)
	{
		Instant maxLastUpdate = null;

		for (Map.Entry<FightStatisticEntry, FightStatistic> entry : statistics.entrySet())
		{
			final FightStatisticEntry statisticEntry = entry.getKey();
			final FightStatistic statistic = entry.getValue();
			final Instant lastUpdate = statistic.getLastUpdate();

			if (!statisticEntry.isDurationInfluencer() || lastUpdate == null)
			{
				continue;
			}

			if (!statisticEntry.isUpdatedAtInfluencer() && updatedAtInfluencerOnly)
			{
				continue;
			}

			if (maxLastUpdate == null || lastUpdate.isAfter(maxLastUpdate))
			{
				maxLastUpdate = lastUpdate;
			}
		}

		return maxLastUpdate;
	}
}

package com.twitchliveloadout.fights;

public enum ActorType {
    NPC("npc", "npc"),
    PLAYER("player", "player"),
    GAME_OBJECT("gameObject", "gameObject"),
    LOCAL_PLAYER("localPlayer", "self");

    private final String key;
    private final String name;

    ActorType(String key, String name) {
        this.key = key;
        this.name = name;
    }

    public String getKey()
    {
        return key;
    }

    public String getName()
    {
        return name;
    }
}

package com.twitchliveloadout.seasonals;

public class SeasonalItem {
    public Boolean active = true;
    public Boolean highlighted = false;
    public String title = "";
    public String spriteName;
    public Boolean spriteContain = true;
    public Integer progress;

    public SeasonalItem(String title)
    {
        this.title = title;
        this.highlighted = true;
    }

    public SeasonalItem(String title, String spriteName)
    {
        this.title = title;
        this.spriteName = spriteName;
    }

    public SeasonalItem(String title, int spriteId)
    {
        this.title = title;
        this.spriteName = spriteId +"-0.png";
    }
}

package com.twitchliveloadout.seasonals;

import com.google.gson.Gson;
import com.google.gson.JsonArray;
import com.google.gson.JsonElement;
import com.google.gson.reflect.TypeToken;
import com.twitchliveloadout.TwitchLiveLoadoutPlugin;
import com.twitchliveloadout.twitch.TwitchState;
import static com.twitchliveloadout.TwitchLiveLoadoutConfig.*;
import net.runelite.api.Client;
import net.runelite.api.events.ScriptPostFired;
import net.runelite.api.widgets.Widget;

import java.util.ArrayList;
import java.util.Collection;
import java.util.HashMap;
import java.util.List;
import java.util.concurrent.CopyOnWriteArrayList;

public class SeasonalManager {
    private final TwitchLiveLoadoutPlugin plugin;
    private final TwitchState twitchState;
    private final Client client;
    private final Gson gson;

    private final CopyOnWriteArrayList<SeasonalItem> activeRelics = new CopyOnWriteArrayList<>();
    private final CopyOnWriteArrayList<SeasonalItem> activeAreas = new CopyOnWriteArrayList<>();
    private final CopyOnWriteArrayList<SeasonalItem> activeMasteries = new CopyOnWriteArrayList<>();
    private final HashMap<Integer, SeasonalItem> areaHighlightLookup = new HashMap<>();
    private final static int INACTIVE_RELIC_TEXT_COLOR = 0xaaaaaa;
    private final static int INACTIVE_MASTERY_OPACITY = 255;
    private final static int RELIC_SCRIPT_ID = 3189;
    private final static int AREA_SCRIPT_ID = 3658;
    private final static int MASTERY_SCRIPT_ID = 3186; // FIND
    private final static int AREA_HIGHLIGHT_GROUP_ID = 512;
    private final static int AREA_HIGHLIGHT_CHILD_ID = 18;
    private final static int RELIC_GROUP_ID = 655;
    private final static int RELIC_TEXT_CHILD_ID = 21;
    private final static int RELIC_ICON_CHILD_ID = 19;
    private final static int MASTERY_GROUP_ID = 311;
    private final static int MASTERY_OPACITY_CHILD_ID = 32;
    private final static int MASTERY_ICON_CHILD_ID = 33;
    private final static int TOTALS_GROUP_ID = 656;
    private final static int TOTAL_POINTS_CHILD_ID = 28;
    private final static int TOTAL_TASKS_CHILD_ID = 26;

    public SeasonalManager(TwitchLiveLoadoutPlugin plugin, TwitchState twitchState, Client client, Gson gson)
    {
        this.plugin = plugin;
        this.twitchState = twitchState;
        this.client = client;
        this.gson = gson;

        initializeAreaHighlightLookup();
        onAccountChanged();
    }

    /**
     * Construct a lookup table where the background area highlight is mapped to the actual region
     * It is unfortunately not possible to dynamically get the names based on the highlight in the background.
     * Therefor a custom lookup is created, which needs to be adjusted for each league.
     */
    public void initializeAreaHighlightLookup()
    {
        areaHighlightLookup.put(5870, new SeasonalItem("Kandarin", 5907));
        areaHighlightLookup.put(5866, new SeasonalItem("Misthalin", 5901));
        areaHighlightLookup.put(5867, new SeasonalItem("Karamja", 5902));
        areaHighlightLookup.put(5871, new SeasonalItem("Desert", 5904));
        areaHighlightLookup.put(5875, new SeasonalItem("Kourend", 5910));
        areaHighlightLookup.put(5868, new SeasonalItem("Wilderness", 5906));
        areaHighlightLookup.put(5869, new SeasonalItem("Asgarnia", 5903));
        areaHighlightLookup.put(5872, new SeasonalItem("Fremennik", 5908));
        areaHighlightLookup.put(5873, new SeasonalItem("Tirannwn", 5909));
        areaHighlightLookup.put(5874, new SeasonalItem("Morytania", 5905));
        areaHighlightLookup.put(5876, new SeasonalItem("Varlamore", 5911));
    }

    public void onAccountChanged()
    {
        activeRelics.clear();
        activeAreas.clear();
        activeMasteries.clear();

        loadRelics();
        loadAreas();
        loadMasteries();
    }

//    ArrayList<Integer> seenScriptIds = new ArrayList<>();

    public void onScriptPostFired(ScriptPostFired scriptPostFired)
    {
        int scriptId = scriptPostFired.getScriptId();

//        if (!seenScriptIds.contains(scriptId))
//        {
//            seenScriptIds.add(scriptId);
//            System.out.println("NEW SCRIPT ID FOUND: "+ scriptId);
//        }

        switch (scriptId) {
            case RELIC_SCRIPT_ID:
                plugin.runOnClientThread(this::gatherRelics);
                break;
            case AREA_SCRIPT_ID:
                plugin.runOnClientThread(this::gatherAreas);
                break;
            case MASTERY_SCRIPT_ID:
                plugin.scheduleOnClientThread(this::gatherMasteries, 1000);
                break;
        }
    }

    private void gatherMasteries()
    {
        Widget masteryOpacityContainerWidget = client.getWidget(MASTERY_GROUP_ID, MASTERY_OPACITY_CHILD_ID);
        Widget masteryIconContainerWidget = client.getWidget(MASTERY_GROUP_ID, MASTERY_ICON_CHILD_ID);

        if (masteryOpacityContainerWidget == null || masteryIconContainerWidget == null)
        {
            return;
        }

        Widget[] opacityWidgets = masteryOpacityContainerWidget.getDynamicChildren();
        Widget[] iconWidgets = masteryIconContainerWidget.getDynamicChildren();

        // keep track of which style is in which tier, because we cannot extract the combat style names or any other titles
        HashMap<Integer, Integer> styleCounters = new HashMap<>();

        // keep track of only the last tiers as seasonal items for each style
        HashMap<Integer, SeasonalItem> lastTiersPerStyle = new HashMap<>();

        for (int masteryIndex = 0; masteryIndex < opacityWidgets.length; masteryIndex++)
        {
            Widget opacityWidget = opacityWidgets[masteryIndex];
            Widget iconWidget = iconWidgets[masteryIndex];
            int opacity = opacityWidget.getOpacity();
            int spriteId = iconWidget.getSpriteId();
            int stylePositionY = iconWidget.getOriginalY();
            boolean isActive = opacity != INACTIVE_MASTERY_OPACITY;

            // initialize the counter if needed
            // NOTE: set to 0 to make sure we start with 1 in the titles
            if (!styleCounters.containsKey(stylePositionY)) {
                styleCounters.put(stylePositionY, 0);
            }

            int currentStyleCounter = styleCounters.get(stylePositionY);
            int newStyleCounter = currentStyleCounter + 1;

            // always increase the style counter regardless of whether its active
            styleCounters.put(stylePositionY, newStyleCounter);

            if (!isActive)
            {
                continue;
            }

            SeasonalItem activeMastery = new SeasonalItem("Tier #"+ newStyleCounter, spriteId);
            lastTiersPerStyle.put(stylePositionY, activeMastery);
        }

        Collection<SeasonalItem> newActiveMasteries = lastTiersPerStyle.values();
        activeMasteries.clear();
        activeMasteries.addAll(newActiveMasteries);

        saveMasteries();
        updateSeasonalItems();
    }

    private void gatherAreas()
    {
        List<SeasonalItem> newActiveAreas = new ArrayList<>();
        Widget mapWidget = client.getWidget(AREA_HIGHLIGHT_GROUP_ID, AREA_HIGHLIGHT_CHILD_ID);

        if (mapWidget == null)
        {
            return;
        }

        Widget[] areaHighlightWidgets = mapWidget.getStaticChildren();

        for (Widget areaHighlightWidget : areaHighlightWidgets)
        {
            int spriteId = areaHighlightWidget.getSpriteId();
            SeasonalItem area = areaHighlightLookup.get(spriteId);

            if (area == null)
            {
                continue;
            }

            newActiveAreas.add(area);
        }

        activeAreas.clear();
        activeAreas.addAll(newActiveAreas);

        saveAreas();
        updateSeasonalItems();
    }

    private void gatherRelics()
    {
        List<SeasonalItem> newActiveRelics = new ArrayList<>();
        Widget relicTextsWidget = client.getWidget(RELIC_GROUP_ID, RELIC_TEXT_CHILD_ID);
        Widget relicIconsWidget = client.getWidget(RELIC_GROUP_ID, RELIC_ICON_CHILD_ID);

        if (relicTextsWidget == null || relicIconsWidget == null)
        {
            return;
        }

        Widget[] textWidgets = relicTextsWidget.getDynamicChildren();
        Widget[] iconWidgets = relicIconsWidget.getDynamicChildren();

        for (Widget textWidget : textWidgets)
        {
            int relicIndex = textWidget.getIndex();
            Widget spriteWidget = iconWidgets[relicIndex];
            String relicName = textWidget.getText();
            int spriteId = spriteWidget.getSpriteId();
            int textColor = textWidget.getTextColor();
            int tierPositionX = textWidget.getOriginalX();
            boolean foundInactiveInTier = false;
            boolean isActive = textColor != INACTIVE_RELIC_TEXT_COLOR;

            // check for the edge case where all relics in a specified tier have the 'active' text colour
            // this happens when artistically the text colours are set to the active one when the tier is not unlocked
            // in this case we'll force this whole tier to not have active relics
            // we detect the tier based on the x position of the text box
            for (Widget similarRelicTextWidget : textWidgets)
            {
                int similarRelicPositionX = similarRelicTextWidget.getOriginalX();
                int similarRelicTextColor = similarRelicTextWidget.getTextColor();
                boolean isSimilarTier = tierPositionX == similarRelicPositionX;
                boolean isSimilarRelicActive = similarRelicTextColor != INACTIVE_RELIC_TEXT_COLOR;

                // guard: skip when not in same tier
                if (!isSimilarTier)
                {
                    continue;
                }

                if (!isSimilarRelicActive)
                {
                    foundInactiveInTier = true;
                }
            }

            // guard: when there is no inactive relic in this tier then the tier is not unlocked!
            if (!foundInactiveInTier)
            {
                continue;
            }

            // guard: skip this relic when inactive
            if (!isActive)
            {
                continue;
            }

            SeasonalItem activeRelic = new SeasonalItem(relicName, spriteId);
            newActiveRelics.add(activeRelic);
        }

        activeRelics.clear();
        activeRelics.addAll(newActiveRelics);

        saveRelics();
        updateSeasonalItems();
    }

    private void updateSeasonalItems()
    {

        ArrayList<SeasonalItem> seasonalItems = new ArrayList<>();

        if (!activeRelics.isEmpty())
        {
            seasonalItems.add(new SeasonalItem("Relics"));
            seasonalItems.addAll(activeRelics);
        }

        if (!activeAreas.isEmpty())
        {
            seasonalItems.add(new SeasonalItem("Regions"));
            seasonalItems.addAll(activeAreas);
        }

        if (!activeMasteries.isEmpty())
        {
            seasonalItems.add(new SeasonalItem("Masteries"));
            seasonalItems.addAll(activeMasteries);
        }

        JsonElement seasonalItemsElement = convertItemsToJson(seasonalItems);

        if (!seasonalItemsElement.isJsonArray())
        {
            return;
        }

        JsonArray seasonalItemsJson = seasonalItemsElement.getAsJsonArray();
        twitchState.setSeasonalItems(seasonalItemsJson);
    }

    private void loadRelics()
    {
        plugin.loadFromConfiguration(SEASONAL_RELICS_CONFIG_KEY, (data) -> {
            ArrayList<SeasonalItem> newActiveRelics = gson.fromJson(data, new TypeToken<ArrayList<SeasonalItem>>(){}.getType());
            activeRelics.clear();
            activeRelics.addAll(newActiveRelics);
            updateSeasonalItems();
        });
    }

    private void loadAreas()
    {
        plugin.loadFromConfiguration(SEASONAL_AREAS_CONFIG_KEY, (data) -> {
            ArrayList<SeasonalItem> newActiveAreas = gson.fromJson(data, new TypeToken<ArrayList<SeasonalItem>>(){}.getType());
            activeAreas.clear();
            activeAreas.addAll(newActiveAreas);
            updateSeasonalItems();
        });
    }

    private void loadMasteries()
    {
        plugin.loadFromConfiguration(SEASONAL_MASTERIES_CONFIG_KEY, (data) -> {
            ArrayList<SeasonalItem> newActiveMasteries = gson.fromJson(data, new TypeToken<ArrayList<SeasonalItem>>(){}.getType());
            activeMasteries.clear();
            activeMasteries.addAll(newActiveMasteries);
            updateSeasonalItems();
        });
    }

    private void saveRelics()
    {
        plugin.setConfiguration(SEASONAL_RELICS_CONFIG_KEY, convertItemsToJson(activeRelics));
    }

    private void saveAreas()
    {
        plugin.setConfiguration(SEASONAL_AREAS_CONFIG_KEY, convertItemsToJson(activeAreas));
    }
    
    private void saveMasteries()
    {
        plugin.setConfiguration(SEASONAL_MASTERIES_CONFIG_KEY, convertItemsToJson(activeMasteries));
    }

    private JsonElement convertItemsToJson(List<SeasonalItem> seasonalItems)
    {
        return gson.toJsonTree(seasonalItems, new TypeToken<List<SeasonalItem>>() {}.getType());
    }
}

package com.twitchliveloadout.minimap;

import com.twitchliveloadout.TwitchLiveLoadoutPlugin;
import com.twitchliveloadout.twitch.TwitchState;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.SpritePixels;
import net.runelite.api.Tile;
import net.runelite.api.WorldView;
import net.runelite.api.coords.LocalPoint;

import javax.imageio.ImageIO;
import java.awt.image.BufferedImage;
import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.util.Base64;

@Slf4j
public class MinimapManager {
	private final TwitchLiveLoadoutPlugin plugin;
	private final TwitchState twitchState;
	private final Client client;

	public MinimapManager(TwitchLiveLoadoutPlugin plugin, TwitchState twitchState, Client client)
	{
		this.plugin = plugin;
		this.twitchState = twitchState;
		this.client = client;
	}

	public void updateMinimap()
	{
		plugin.runOnClientThread(() -> {
			try {
				// String miniMap = getMiniMapAsBase64();
			} catch (Exception exception) {
				log.warn("Could not update minimap when run on client thread: ", exception);
			}
		});
	}

	private String getMiniMapAsBase64() throws IOException
	{
		BufferedImage image = getMiniMapAsBufferedImage();

		if (image == null)
		{
			return null;
		}

		String base64Image = convertBufferedImageToBase64(image);
		return base64Image;
	}

	private BufferedImage getMiniMapAsBufferedImage()
	{
		if (!plugin.isLoggedIn())
		{
			return null;
		}

		WorldView worldView = client.getTopLevelWorldView();
		int tileSize = 4;
		int sceneSize = 104;
		int radiusAroundPlayer = 12;
		int plane = worldView.getPlane();
		Tile[][] planeTiles = worldView.getScene().getTiles()[plane];

		LocalPoint playerLocation = client.getLocalPlayer().getLocalLocation();
		int playerX = playerLocation.getSceneX();
		int playerY = (planeTiles[0].length - 1) - playerLocation.getSceneY(); // flip the y-axis

		SpritePixels map = client.drawInstanceMap(plane);
		int fullWidth = map.getWidth();
		int fullHeight = map.getHeight();
		int[] pixels = map.getPixels();

		BufferedImage image = new BufferedImage(fullWidth, fullHeight, BufferedImage.TYPE_INT_RGB);
		image.setRGB(0, 0, fullWidth, fullHeight, pixels, 0, fullWidth);

		// first crop to the scene
		image = image.getSubimage(48, 48, tileSize * sceneSize, tileSize * sceneSize);

		// now crop to the requested area
		image = image.getSubimage(
				(playerX - radiusAroundPlayer) * tileSize,
				(playerY - radiusAroundPlayer) * tileSize,
				radiusAroundPlayer * 2 * tileSize,
				radiusAroundPlayer * 2 * tileSize
		);

		return image;
	}

	private String convertBufferedImageToBase64(BufferedImage image) throws IOException
	{
		final ByteArrayOutputStream os = new ByteArrayOutputStream();
		ImageIO.write(image, "png", os);

		return Base64.getEncoder().encodeToString(os.toByteArray());
	}
}

package com.twitchliveloadout.raids;

import com.google.gson.JsonArray;
import com.google.gson.JsonObject;
import com.twitchliveloadout.TwitchLiveLoadoutPlugin;
import com.twitchliveloadout.twitch.TwitchState;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.Player;
import net.runelite.api.coords.LocalPoint;
import net.runelite.api.coords.WorldPoint;
import net.runelite.api.events.ScriptPostFired;
import net.runelite.api.widgets.Widget;

@Slf4j
public class InvocationsManager {
	private static final int LOBBY_REGION_ID = 13454;
	private static final int WIDGET_RAID_OVERLAY_PARENT_ID = 481;
	private static final int WIDGET_RAID_OVERLAY_CHILD_ID = 40;
	private static final int WIDGET_ID_INVOCATIONS_PARENT = 774;
	private static final int WIDGET_ID_INVOCATIONS_LIST = 52;
	private static final int WIDGET_ID_INVOCATIONS_HEADER = 3;
	private static final int WIDGET_ID_PARTY_MEMBERS_PARENT = 773;
	private static final int WIDGET_ID_PARTY_MEMBERS_LIST = 5;
	private static final int WIDGET_ID_INVOCATIONS_RAID_LEVEL = 73;
	private static final int SCRIPT_ID_BUILD_TOA_PARTY_INTERFACE = 6729;
	private static final int SCRIPT_ID_TOA_PARTY_TOGGLE_REWARD_PANEL = 6732;
	private static final int INVOCATION_ACTIVE_TEXT_COLOR = 13868852;
	private static final int INVOCATION_INACTIVE_TEXT_COLOR = 10461087;

	private final TwitchLiveLoadoutPlugin plugin;
	private final TwitchState twitchState;
	private final Client client;

	public InvocationsManager(TwitchLiveLoadoutPlugin plugin, TwitchState twitchState, Client client)
	{
		this.plugin = plugin;
		this.twitchState = twitchState;
		this.client = client;
	}

	public void onScriptPostFired(ScriptPostFired event)
	{
		// This is run when the party screen is brought up, whenever a tab is changed, and whenever an invocation is clicked
		if (event.getScriptId() != SCRIPT_ID_BUILD_TOA_PARTY_INTERFACE && event.getScriptId() != SCRIPT_ID_TOA_PARTY_TOGGLE_REWARD_PANEL)
		{
			return;
		}

		// guard: make sure the invocations interface that is open is the one of the current
		// party leader, this prevents syncing the wrong data when opening other parties you have not joined.
		if (!isJoinedPartyInterface())
		{
			return;
		}

		updateCurrentActiveInvocations();
		updateCurrentRaidLevel();
	}

	public boolean isJoinedPartyInterface()
	{
		Widget partyWidget = client.getWidget(WIDGET_ID_PARTY_MEMBERS_PARENT, WIDGET_ID_PARTY_MEMBERS_LIST);
		Widget headerWidget = client.getWidget(WIDGET_ID_INVOCATIONS_PARENT, WIDGET_ID_INVOCATIONS_HEADER);

		// guard: check if the main widgets are found
		if (partyWidget == null || headerWidget == null)
		{
			return false;
		}

		Widget[] headerChildren = headerWidget.getChildren();
		int headerWidgetTitleIndex = 1;

		// guard: check if the header widget content is valid
		if (headerChildren == null || headerChildren.length <= headerWidgetTitleIndex)
		{
			return false;
		}

		try {
			String partyText = partyWidget.getText();
			String headerText = headerWidget.getChild(headerWidgetTitleIndex).getText();
			String[] partyTextTokens = partyText.split("<br>");
			String[] headerTextTokens = headerText.split("Party of ");
			String leaderInParty = partyTextTokens[0]; // index 0, because party text is like: "NAME<br>-<br>-<br>-<br>-<br>-<br>-<br>-"
			String leaderInHeader = headerTextTokens[1]; // index 1, because header text is like: "Party of NAME"

			// when the names equal we know that we are currently in the joined party interface
			return leaderInParty.equals(leaderInHeader);
		} catch (Exception exception) {
			log.warn("Could not check party due the following error:", exception);
		}

		return false;
	}

	public void checkIfInToA()
	{
		plugin.runOnClientThread(() -> {
			Player localPlayer = client.getLocalPlayer();

			if (localPlayer == null)
			{
				return;
			}

			LocalPoint localPoint = localPlayer.getLocalLocation();
			Widget raidOverlayWidget = client.getWidget(WIDGET_RAID_OVERLAY_PARENT_ID, WIDGET_RAID_OVERLAY_CHILD_ID);

			if (localPoint == null)
			{
				return;
			}

			int currentRegionId = WorldPoint.fromLocalInstance(client, localPoint).getRegionID();

			boolean inLobby = (currentRegionId == LOBBY_REGION_ID);
			boolean hasOverlay = (raidOverlayWidget != null && !raidOverlayWidget.isHidden());
			boolean inToA = inLobby || hasOverlay;

			twitchState.setInToA(inToA);
		});
	}

	private void updateCurrentRaidLevel()
	{
		Widget raidLevelWidget = client.getWidget(WIDGET_ID_INVOCATIONS_PARENT, WIDGET_ID_INVOCATIONS_RAID_LEVEL);

		// guard: check if widget is valid
		if (raidLevelWidget == null)
		{
			return;
		}

		try {
			String raidLevelRaw = raidLevelWidget.getText();
			String[] raidLevelTokens = raidLevelRaw.split(" ");
			String raidLevel = raidLevelTokens[2];
			twitchState.setInvocationsRaidLevel(raidLevel);
		} catch (Exception exception) {
			log.warn("Could not get the raid level from one of the widgets due to the following error:", exception);
		}
	}

	private void updateCurrentActiveInvocations()
	{
		Widget invocationsWidget = client.getWidget(WIDGET_ID_INVOCATIONS_PARENT, WIDGET_ID_INVOCATIONS_LIST);

		// guard: skip if widget is not found
		if (invocationsWidget == null || invocationsWidget.isHidden() || invocationsWidget.getChildren() == null)
		{
			return;
		}

		JsonArray invocations = new JsonArray();
		Widget[] widgets = invocationsWidget.getChildren();

		for (int widgetIndex = 0; widgetIndex < widgets.length; widgetIndex++)
		{
			Widget spriteWidget = widgets[widgetIndex];

			if (spriteWidget == null)
			{
				continue;
			}

			int spriteId = spriteWidget.getSpriteId();
			boolean isInvocationIcon = spriteId > -1;
			int titleWidgetIndex = widgetIndex + 1;
			int activeWidgetIndex = widgetIndex - 1;

			// guard: only handle the icons
			if (!isInvocationIcon)
			{
				continue;
			}

			// guard: make sure the title and active widget exists
			if (titleWidgetIndex >= widgets.length && activeWidgetIndex >= 0)
			{
				continue;
			}

			Widget titleWidget = widgets[titleWidgetIndex];
			String title = titleWidget.getText();
			int titleColor = titleWidget.getTextColor();
			boolean isActive = (titleColor == INVOCATION_ACTIVE_TEXT_COLOR);

			JsonObject invocation = new JsonObject();
			invocation.addProperty("title", title);
			invocation.addProperty("spriteId", spriteId);
			invocation.addProperty("active", isActive);

			invocations.add(invocation);
		}

		twitchState.setInvocations(invocations);
	}
}

package com.twitchliveloadout.ui;

import lombok.extern.slf4j.Slf4j;
import com.twitchliveloadout.fights.Fight;
import com.twitchliveloadout.fights.FightSorter;
import com.twitchliveloadout.fights.FightStateManager;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.components.PluginErrorPanel;

import javax.swing.*;
import javax.swing.border.EmptyBorder;
import java.awt.*;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.util.Collections;
import java.util.concurrent.CopyOnWriteArrayList;

@Slf4j
public class CombatPanel extends JPanel
{
	private static final String FIGHT_LIST_PANEL = "FIGHT_LIST_PANEL";
	private static final String ERROR_PANEL = "ERROR_PANEL";

	private final GridBagConstraints constraints = new GridBagConstraints();
	private final GridBagConstraints fightListConstraints = new GridBagConstraints();
	private final CardLayout cardLayout = new CardLayout();
	private final JPanel wrapper = new JPanel(cardLayout);

	private final JPanel fightListPanel = new JPanel(new GridBagLayout());
	private final JPanel fightListWrapper = new JPanel(new BorderLayout());
	private final CopyOnWriteArrayList<FightPanel> fightPanels = new CopyOnWriteArrayList<>();
	private final JPanel deleteAllPanel = new JPanel(new BorderLayout());
	private final JLabel deleteAllLabel = new JLabel();

	private final PluginErrorPanel errorPanel = new PluginErrorPanel();
	private final JPanel errorWrapper = new JPanel(new BorderLayout());

	private final FightStateManager fightStateManager;

	public CombatPanel(FightStateManager fightStateManager)
	{
		super(new GridBagLayout());

		this.fightStateManager = fightStateManager;

		setLayout(new BorderLayout());
		setBorder(new EmptyBorder(10, 10, 10, 10));

		constraints.fill = GridBagConstraints.HORIZONTAL;
		constraints.weightx = 1;
		constraints.gridx = 0;
		constraints.gridy = 0;

		fightListConstraints.fill = GridBagConstraints.HORIZONTAL;
		fightListConstraints.weightx = 1;
		fightListConstraints.gridx = 0;
		fightListConstraints.gridy = 0;

		fightListPanel.setBorder(new EmptyBorder(10, 0, 10, 0));
		fightListPanel.setBackground(ColorScheme.DARK_GRAY_COLOR);

		deleteAllPanel.setLayout(new BorderLayout());
		deleteAllPanel.setBorder(new EmptyBorder(10, 10, 10, 10));
		deleteAllPanel.setBackground(ColorScheme.DARKER_GRAY_COLOR);
		deleteAllPanel.add(deleteAllLabel, BorderLayout.CENTER);
		Styles.styleBigLabel(deleteAllLabel, "Delete All Fights");
		deleteAllPanel.addMouseListener(new MouseAdapter()
		{
			@Override
			public void mousePressed(MouseEvent mouseEvent)
			{
				int confirm = JOptionPane.showConfirmDialog(CombatPanel.this,
						"Are you sure you want to reset ALL fights?",
						"Warning", JOptionPane.OK_CANCEL_OPTION);

				if (confirm == 0)
				{
					fightStateManager.deleteAllFights();
				}
			}

			@Override
			public void mouseEntered(MouseEvent mouseEvent)
			{
				deleteAllPanel.setBackground(ColorScheme.DARKER_GRAY_HOVER_COLOR);
				deleteAllPanel.setCursor(new Cursor(Cursor.HAND_CURSOR));
			}

			@Override
			public void mouseExited(MouseEvent mouseEvent)
			{
				deleteAllPanel.setBackground(ColorScheme.DARKER_GRAY_COLOR);
				deleteAllPanel.setCursor(new Cursor(Cursor.DEFAULT_CURSOR));
			}
		});

		fightListWrapper.setLayout(new GridBagLayout());
		fightListWrapper.setBorder(new EmptyBorder(10, 0, 10, 0));
		fightListWrapper.setBackground(ColorScheme.DARK_GRAY_COLOR);
		fightListWrapper.add(deleteAllPanel, constraints);
		constraints.gridy++;
		fightListWrapper.add(fightListPanel, constraints);
		constraints.gridy++;

		errorPanel.setBorder(new EmptyBorder(50, 20, 20, 20));
		errorPanel.setContent("No fights available", "Start combat with an enemy to manage the fights.");

		errorWrapper.setBackground(ColorScheme.DARK_GRAY_COLOR);
		errorWrapper.add(errorPanel, BorderLayout.NORTH);

		wrapper.add(fightListWrapper, FIGHT_LIST_PANEL);
		wrapper.add(errorWrapper, ERROR_PANEL);
		add(wrapper, BorderLayout.NORTH);

		// initialize all the fight panel slots without adding them to the UI
		for (int i = 0; i < FightStateManager.MAX_FIGHT_AMOUNT_IN_MEMORY; i++)
		{
			FightPanel fightPanel = new FightPanel(fightStateManager);
			fightPanels.add(fightPanel);
		}
	}

	public void rebuild()
	{
		rebuildFightList();
		repaint();
		revalidate();
	}

	public void rebuildFightList()
	{
		final CopyOnWriteArrayList<Fight> fights = new CopyOnWriteArrayList<>();
		int fightPanelIndex = 0;

		// add all fights by default
		fights.addAll(fightStateManager.getFights().values());

		// order by last update time
		Collections.sort(fights, new FightSorter());

		// guard: check if there are no fights to show
		if (fights.size() <= 0)
		{
			cardLayout.show(wrapper, ERROR_PANEL);
			return;
		}

		cardLayout.show(wrapper, FIGHT_LIST_PANEL);
		fightListPanel.removeAll();
		fightListConstraints.gridy = 0;

		// first clear all the fight in the panels
		for (FightPanel fightPanel : fightPanels)
		{
			fightPanel.setFight(null);
		}

		// directly add all the fights again in the new order
		for (Fight fight : fights)
		{
			FightPanel fightPanel = fightPanels.get(fightPanelIndex);

			// guard: check if the panel is valid
			if (fightPanel == null)
			{
				log.warn("An invalid fight panel index was requested: "+ fightPanelIndex);
				break;
			}

			fightPanel.setFight(fight);
			fightPanel.rebuild();
			fightPanelIndex ++;

			fightListPanel.add(fightPanel, fightListConstraints);
			fightListConstraints.gridy++;
		}
	}
}

package com.twitchliveloadout.ui;

import com.twitchliveloadout.marketplace.MarketplaceDuration;
import com.twitchliveloadout.marketplace.MarketplaceMessages;
import com.twitchliveloadout.marketplace.products.MarketplaceProduct;
import com.twitchliveloadout.marketplace.products.TwitchProductCost;
import com.twitchliveloadout.marketplace.transactions.TwitchTransaction;
import com.twitchliveloadout.twitch.eventsub.TwitchEventSubType;
import lombok.extern.slf4j.Slf4j;

import javax.swing.*;

@Slf4j
public class MarketplaceProductPanel extends EntityActionPanel<MarketplaceProduct> {

	public MarketplaceProductPanel(JPanel parentPanel) {
		super(
			parentPanel,
			"Invalid Random Event donation",
			false,
			"Are you sure you want to stop the effects of this donation?",
			"Stop Random Event",
			EntityActionPanel.DELETE_ICON,
			EntityActionPanel.DELETE_HOVER_ICON
		);
	}

	@Override
	protected String[] getLines() {
		MarketplaceProduct marketplaceProduct = getEntity();
		boolean isActive = marketplaceProduct.isActive();
		boolean isExpired = marketplaceProduct.isExpired();
		long expiresInMs = marketplaceProduct.getExpiresInMs();
		TwitchTransaction transaction = marketplaceProduct.getTransaction();
		String streamerProductName = marketplaceProduct.getStreamerProduct().name;
		String statusLine = "<b color='green'>ACTIVE</b>";
		String[] lines = {};
		String expiresInLine = "Expires in " + MarketplaceDuration.humanizeDurationMs(expiresInMs);
		String viewerLine = MarketplaceMessages.formatMessage("By <b color='yellow'>{viewerName}</b>", marketplaceProduct, null);

		if (isExpired) {
			statusLine = "<b color='red'>EXPIRED</b>";
		} else if (!isActive) {
			statusLine = "<b color='orange'>PAUSED</b>";
		}

		if (transaction.isCurrencyTransaction())
		{
			lines = new String[]{
				statusLine,
				"<b>" + streamerProductName + "</b>",
				MarketplaceMessages.formatMessage("Donation of <b color='yellow'>{currencyAmount} {currencyType}</b>", marketplaceProduct, null),
				viewerLine,
				expiresInLine
			};
		}

		if (transaction.isFreeTransaction())
		{
			lines = new String[]{
				statusLine,
				"<b>" + streamerProductName + "</b>",
				"FREE activation",
				viewerLine,
				expiresInLine
			};
		}

		if (transaction.isEventSubTransaction())
		{
			TwitchEventSubType eventSubType = transaction.eventSubType;

			lines = new String[]{
				statusLine,
				"<b>"+ eventSubType.getName() +"</b>",
				"<b color='yellow'>" + streamerProductName + "</b>",
				viewerLine,
				expiresInLine
			};
		}

		return lines;
	}

	@Override
	protected void executeAction() {
		MarketplaceProduct marketplaceProduct = getEntity();
		MarketplacePanel marketplacePanel = (MarketplacePanel) parentPanel;
		TwitchTransaction twitchTransaction = marketplaceProduct.getTransaction();
		String transactionId = (twitchTransaction != null ? twitchTransaction.id : "unknown");

		log.info("A marketplace product is manually requested to be stopped, transaction ID: "+ transactionId);
		marketplaceProduct.stop(false);
		marketplacePanel.rebuild();
	}

	@Override
	protected boolean canRunAction() {
		return true;
	}
}

package com.twitchliveloadout.ui;

import net.runelite.client.ui.FontManager;

import javax.swing.*;
import java.awt.*;

public class Styles
{
	public static void styleBigLabel(JLabel label, String text)
	{
		label.setText(text);
		label.setForeground(Color.WHITE);
	}

	public static void styleLabel(JLabel label, String text)
	{
		label.setText(text);
		label.setFont(FontManager.getRunescapeSmallFont());
		label.setForeground(Color.WHITE);
	}
}

package com.twitchliveloadout.ui;

import java.awt.*;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import javax.swing.*;
import javax.swing.border.EmptyBorder;

import com.google.gson.Gson;
import com.twitchliveloadout.TwitchLiveLoadoutConfig;
import com.twitchliveloadout.TwitchLiveLoadoutPlugin;
import com.twitchliveloadout.fights.FightStateManager;
import com.twitchliveloadout.marketplace.MarketplaceManager;
import com.twitchliveloadout.twitch.TwitchApi;
import com.twitchliveloadout.twitch.TwitchState;
import com.twitchliveloadout.twitch.eventsub.TwitchEventSubClient;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.PluginPanel;
import net.runelite.client.ui.components.materialtabs.MaterialTab;
import net.runelite.client.ui.components.materialtabs.MaterialTabGroup;

public class TwitchLiveLoadoutPanel extends PluginPanel
{
	private final JPanel mainPanel = new JPanel(new GridBagLayout());
	private final MaterialTabGroup tabGroup = new MaterialTabGroup(mainPanel);
	private final MaterialTab connectivityTab;
	private final MaterialTab combatTab;
	private final MaterialTab marketplaceTab;

	private final ConnectivityPanel connectivityPanel;
	private final CombatPanel combatPanel;
	private final MarketplacePanel marketplacePanel;

	public TwitchLiveLoadoutPanel(TwitchLiveLoadoutPlugin plugin, TwitchApi twitchApi, TwitchEventSubClient twitchEventSubClient, TwitchState twitchState, FightStateManager fightStateManager, MarketplaceManager marketplaceManager, CanvasListener canvasListener, TwitchLiveLoadoutConfig config, Gson gson)
	{
		super(true);
		setLayout(new BorderLayout());

		combatPanel = new CombatPanel(fightStateManager);
		connectivityPanel = new ConnectivityPanel(plugin, twitchApi, twitchEventSubClient, twitchState, canvasListener, config);
		marketplacePanel = new MarketplacePanel(marketplaceManager, gson, config);

		connectivityTab = new MaterialTab("Status", tabGroup, connectivityPanel);
		marketplaceTab = new MaterialTab("Events", tabGroup, marketplacePanel);
		combatTab = new MaterialTab("Combat", tabGroup, combatPanel);

		tabGroup.setBorder(new EmptyBorder(5, 0, 0, 0));
		tabGroup.addTab(connectivityTab);
		tabGroup.addTab(marketplaceTab);
		tabGroup.addTab(combatTab);

		tabGroup.select(connectivityTab);

		add(tabGroup, BorderLayout.NORTH);
		add(mainPanel, BorderLayout.CENTER);
	}

	public void onGameTick()
	{
		marketplacePanel.onGameTick();
	}

	public void rebuild()
	{
		connectivityPanel.rebuild();
		combatPanel.rebuild();
		marketplacePanel.rebuild();
		repaint();
		revalidate();
	}

	public CombatPanel getCombatPanel()
	{
		return combatPanel;
	}

	public ConnectivityPanel getConnectivityPanel()
	{
		return connectivityPanel;
	}

	public MarketplacePanel getMarketplacePanel()
	{
		return marketplacePanel;
	}

	public static void initializePanelButton(JPanel panel, JLabel label, String buttonTitle, ButtonCallback buttonCallback)
	{
		panel.setLayout(new BorderLayout());
		panel.setBorder(new EmptyBorder(10, 10, 10, 10));
		panel.setBackground(ColorScheme.DARKER_GRAY_COLOR);
		panel.add(label, BorderLayout.CENTER);
		Styles.styleBigLabel(label, buttonTitle);
		panel.addMouseListener(new MouseAdapter()
		{
			@Override
			public void mousePressed(MouseEvent mouseEvent)
			{
				buttonCallback.execute();
			}

			@Override
			public void mouseEntered(MouseEvent mouseEvent)
			{
				panel.setBackground(ColorScheme.DARKER_GRAY_HOVER_COLOR);
				panel.setCursor(new Cursor(Cursor.HAND_CURSOR));
			}

			@Override
			public void mouseExited(MouseEvent mouseEvent)
			{
				panel.setBackground(ColorScheme.DARKER_GRAY_COLOR);
				panel.setCursor(new Cursor(Cursor.DEFAULT_CURSOR));
			}
		});
	}

	public interface ButtonCallback {
		public void execute();
	}
}

package com.twitchliveloadout.ui;

import com.twitchliveloadout.TwitchLiveLoadoutConfig;
import lombok.Getter;

import java.awt.event.FocusEvent;
import java.awt.event.FocusListener;
import java.time.Duration;
import java.time.Instant;

public class CanvasListener implements FocusListener {

	private final TwitchLiveLoadoutConfig config;

	@Getter
	private boolean inFocus = false;
	private Instant lastInFocusAt = null;

	public CanvasListener(TwitchLiveLoadoutConfig config)
	{
		this.config = config;
	}

	@Override
	public void focusGained(FocusEvent event)
	{
		enableFocus();
	}

	@Override
	public void focusLost(FocusEvent event)
	{
		disableFocus();
	}

	public void enableFocus()
	{
		if (inFocus)
		{
			return;
		}

		inFocus = true;
		lastInFocusAt = Instant.now();
	}

	public void disableFocus()
	{
		if (!inFocus)
		{
			return;
		}

		inFocus = false;
	}

	public long getInFocusDurationMs()
	{

		// guard: check if this window is in focus and was ever in focus
		if (!inFocus || lastInFocusAt == null)
		{
			return 0;
		}

		final Instant now = Instant.now();
		final long duration = Duration.between(lastInFocusAt, now).toMillis();

		return duration;
	}
}

package com.twitchliveloadout.ui;

import com.google.gson.Gson;
import com.twitchliveloadout.TwitchLiveLoadoutConfig;
import com.twitchliveloadout.marketplace.LambdaIterator;
import com.twitchliveloadout.marketplace.MarketplaceConstants;
import com.twitchliveloadout.marketplace.MarketplaceManager;
import com.twitchliveloadout.marketplace.MarketplaceProductSorter;
import com.twitchliveloadout.marketplace.products.ChannelPointReward;
import com.twitchliveloadout.marketplace.products.EbsProduct;
import com.twitchliveloadout.marketplace.products.MarketplaceProduct;
import com.twitchliveloadout.marketplace.products.StreamerProduct;
import com.twitchliveloadout.marketplace.transactions.TwitchTransaction;
import lombok.extern.slf4j.Slf4j;
import net.runelite.client.ui.ColorScheme;

import javax.swing.*;
import javax.swing.border.EmptyBorder;
import java.awt.*;
import java.util.Collections;
import java.util.concurrent.CopyOnWriteArrayList;
import java.util.concurrent.atomic.AtomicInteger;

import static com.twitchliveloadout.marketplace.MarketplaceConstants.*;

/**
 * NOTE: this is very ugly code due to how ugly and cumbersome Swing is. LOL.
 */
@Slf4j
public class MarketplacePanel extends JPanel
{
	private static final String PLAYBACK_PANEL = "PLAYBACK_PANEL";
	private final static String SUCCESS_TEXT_COLOR = "#00ff00";
	private final static String WARNING_TEXT_COLOR = "#ffa500";
	private final static String ERROR_TEXT_COLOR = "#ff0000";

	private final GridBagConstraints constraints = new GridBagConstraints();
	private final GridBagConstraints productListConstraints = new GridBagConstraints();
	private final GridBagConstraints customProductListConstraints = new GridBagConstraints();
	private final GridBagConstraints transactionListConstraints = new GridBagConstraints();
	private final CardLayout cardLayout = new CardLayout();
	private final JPanel wrapper = new JPanel(cardLayout);

	private final GridBagConstraints playbackConstraints = new GridBagConstraints();
	private final TextPanel statusPanel = new TextPanel("Status:", "<html><b color='"+ WARNING_TEXT_COLOR +"'>SETTING UP</b></html>");
	private final TextPanel availableRandomEventsPanel = new TextPanel("Configured Random Events:", "<html>No Random Event are configured.</html>");
	private final TextPanel availableChannelPointRewardsPanel = new TextPanel("Configured Channel Point Rewards:", "<html>No Channel Point Rewards are configured.</html>");

	private final JPanel playbackWrapper = new JPanel(new BorderLayout());
	private final TextPanel playbackControlsPanel = new TextPanel("Playback Controls:", "<html>Pause and start to temporarily block distractions. Enable Preview Mode to temporarily test events from the Extension Configuration page in Twitch.</html>");
	private final JPanel startPanel = new JPanel(new BorderLayout());
	private final JLabel startLabel = new JLabel();
	private final JPanel testModePanel = new JPanel(new BorderLayout());
	private final JLabel testModeLabel = new JLabel();
	private final JPanel chaosModePanel = new JPanel(new BorderLayout());
	private final JLabel chaosModeLabel = new JLabel();
	private final JPanel freeModePanel = new JPanel(new BorderLayout());
	private final JLabel freeModeLabel = new JLabel();
	private final JPanel stateReloadPanel = new JPanel(new BorderLayout());
	private final JLabel stateReloadLabel = new JLabel();
	private final TextPanel queuedTransactionsPanel = new TextPanel("<html><h2>Queued Random Events:</h2></html>", "<html>No Random Events are queued.</html>");

	private final JPanel productListPanel = new JPanel(new GridBagLayout());
	private final TextPanel productListTitlePanel = new TextPanel("<html><h2>Active Random Events:</h2></html>", "<html>List of active random events.</html>");
	private final JPanel productListWrapper = new JPanel(new BorderLayout());
	private final CopyOnWriteArrayList<MarketplaceProductPanel> productPanels = new CopyOnWriteArrayList<>();

	private final TextField customProductInputField = new TextField();
	private final JPanel customProductListPanel = new JPanel(new GridBagLayout());
	private final TextPanel customProductListTitlePanel = new TextPanel("<html><h2>Manual Random Events:</h2></html>", "<html>Enter the script configuration of the Random Event below:</html>");
	private final JPanel customProductListWrapper = new JPanel(new BorderLayout());
	private final CopyOnWriteArrayList<EbsProductPanel> customProductPanels = new CopyOnWriteArrayList<>();

	private final JPanel transactionListPanel = new JPanel(new GridBagLayout());
	private final TextPanel transactionListTitlePanel = new TextPanel("<html><h2>Recent Random Events:</h2></html>", "<html>List of all recent Random Events.</html>");
	private final JPanel transactionListWrapper = new JPanel(new BorderLayout());
	private final CopyOnWriteArrayList<TwitchTransactionPanel> transactionPanels = new CopyOnWriteArrayList<>();

	private final MarketplaceManager marketplaceManager;
	private final Gson gson;
	private final TwitchLiveLoadoutConfig config;
	private boolean rebuildRequested = false;

	public MarketplacePanel(MarketplaceManager marketplaceManager, Gson gson, TwitchLiveLoadoutConfig config)
	{
		super(new GridBagLayout());

		this.marketplaceManager = marketplaceManager;
		this.gson = gson;
		this.config = config;

		initializeLayout();
	}

	public void onGameTick()
	{

		// sync the rebuild with the main thread
		if (rebuildRequested)
		{
			rebuild();
		}
	}

	public void requestRebuild()
	{
		rebuildRequested = true;
	}

	public void rebuild()
	{
		rebuildRequested = false;
		repopulatePanels();
		updateLayout();
		updateTexts();
	}

	private void initializeLayout()
	{
		setLayout(new BorderLayout());
		setBorder(new EmptyBorder(10, 10, 10, 10));

		constraints.fill = GridBagConstraints.HORIZONTAL;
		constraints.weightx = 1;
		constraints.gridx = 0;
		constraints.gridy = 0;

		playbackConstraints.fill = GridBagConstraints.HORIZONTAL;
		playbackConstraints.weightx = 1;
		playbackConstraints.gridx = 0;
		playbackConstraints.gridy = 0;

		productListConstraints.fill = GridBagConstraints.HORIZONTAL;
		productListConstraints.weightx = 1;
		productListConstraints.gridx = 0;
		productListConstraints.gridy = 0;

		transactionListConstraints.fill = GridBagConstraints.HORIZONTAL;
		transactionListConstraints.weightx = 1;
		transactionListConstraints.gridx = 0;
		transactionListConstraints.gridy = 0;

		customProductListConstraints.fill = GridBagConstraints.HORIZONTAL;
		customProductListConstraints.weightx = 1;
		customProductListConstraints.gridx = 0;
		customProductListConstraints.gridy = 0;

		playbackWrapper.setLayout(new GridBagLayout());
		playbackWrapper.setBorder(new EmptyBorder(10, 0, 10, 0));
		playbackWrapper.setBackground(ColorScheme.DARK_GRAY_COLOR);
		playbackWrapper.add(statusPanel, playbackConstraints);
		playbackConstraints.gridy++;
		playbackWrapper.add(playbackControlsPanel, playbackConstraints);
		playbackConstraints.gridy++;
		playbackWrapper.add(startPanel, playbackConstraints);
		playbackConstraints.gridy++;

		if (TEST_MODE_AVAILABLE)
		{
			playbackWrapper.add(testModePanel, playbackConstraints);
			playbackConstraints.gridy++;
		}

		if (CHAOS_MODE_AVAILABLE)
		{
			playbackWrapper.add(chaosModePanel, playbackConstraints);
			playbackConstraints.gridy++;
		}

		if (FREE_MODE_AVAILABLE)
		{
			playbackWrapper.add(freeModePanel, playbackConstraints);
			playbackConstraints.gridy++;
		}

		playbackWrapper.add(availableRandomEventsPanel, playbackConstraints);
		playbackConstraints.gridy++;
		playbackWrapper.add(availableChannelPointRewardsPanel, playbackConstraints);
		playbackConstraints.gridy++;
		playbackWrapper.add(stateReloadPanel, playbackConstraints);
		playbackConstraints.gridy++;
		playbackWrapper.add(queuedTransactionsPanel, playbackConstraints);
		playbackConstraints.gridy++;
		playbackWrapper.add(productListTitlePanel, playbackConstraints);
		playbackConstraints.gridy++;
		playbackWrapper.add(productListWrapper, playbackConstraints);
		playbackConstraints.gridy++;
		playbackWrapper.add(transactionListTitlePanel, playbackConstraints);
		playbackConstraints.gridy++;
		playbackWrapper.add(transactionListWrapper, playbackConstraints);
		playbackConstraints.gridy++;

		if (MANUAL_PRODUCTS_AVAILABLE)
		{
			playbackWrapper.add(customProductListTitlePanel, playbackConstraints);
			playbackConstraints.gridy++;
			playbackWrapper.add(customProductListWrapper, playbackConstraints);
			playbackConstraints.gridy++;
		}

		productListWrapper.setLayout(new GridBagLayout());
		productListWrapper.setBorder(new EmptyBorder(10, 0, 10, 0));
		productListWrapper.setBackground(ColorScheme.DARK_GRAY_COLOR);
		productListPanel.setBorder(new EmptyBorder(10, 0, 10, 0));
		productListPanel.setBackground(ColorScheme.DARK_GRAY_COLOR);
		productListWrapper.add(productListPanel, productListConstraints);
		productListConstraints.gridy++;

		customProductInputField.setBackground(ColorScheme.DARKER_GRAY_COLOR);
		customProductInputField.addActionListener(event -> {
			String rawEbsProduct = event.getActionCommand();

			try {
				EbsProduct ebsProduct = gson.fromJson(rawEbsProduct, EbsProduct.class);

				// force this EBS product to be dangerous always so that some accounts will not be at risk
				ebsProduct.dangerous = true;

				// guard: make sure the ebsProduct is valid
				if (ebsProduct.id == null || ebsProduct.behaviour == null || ebsProduct.name == null)
				{
					throw new Exception("Some of the properties were filled in correctly.");
				}

				customProductInputField.setBackground(ColorScheme.DARKER_GRAY_COLOR);
				marketplaceManager.addCustomEbsProduct(ebsProduct);
				rebuildCustomProductPanels();
			} catch (Exception exception) {
				log.warn("An invalid custom Random Event was passed through the input field. Could not parse it correctly:", exception);
				customProductInputField.setBackground(new Color(200, 50, 50));
			}

			// always clear on copy
			customProductInputField.setText("");
		});

		customProductListWrapper.setLayout(new GridBagLayout());
		customProductListWrapper.setBorder(new EmptyBorder(10, 0, 10, 0));
		customProductListWrapper.setBackground(ColorScheme.DARK_GRAY_COLOR);
		customProductListPanel.setBorder(new EmptyBorder(10, 0, 10, 0));
		customProductListPanel.setBackground(ColorScheme.DARK_GRAY_COLOR);
		customProductListWrapper.add(customProductInputField, customProductListConstraints);
		customProductListConstraints.gridy++;
		customProductListWrapper.add(customProductListPanel, customProductListConstraints);
		customProductListConstraints.gridy++;

		transactionListWrapper.setLayout(new GridBagLayout());
		transactionListWrapper.setBorder(new EmptyBorder(10, 0, 10, 0));
		transactionListWrapper.setBackground(ColorScheme.DARK_GRAY_COLOR);
		transactionListPanel.setBorder(new EmptyBorder(10, 0, 10, 0));
		transactionListPanel.setBackground(ColorScheme.DARK_GRAY_COLOR);
		transactionListWrapper.add(transactionListPanel, transactionListConstraints);
		transactionListConstraints.gridy++;

		wrapper.add(playbackWrapper, PLAYBACK_PANEL);
		constraints.gridy++;
		add(wrapper, BorderLayout.NORTH);

		// for now always show the playback panel
		cardLayout.show(wrapper, PLAYBACK_PANEL);

		TwitchLiveLoadoutPanel.initializePanelButton(startPanel, startLabel, getPlaybackButtonTitle(), () -> {
			final boolean isMarketplaceActive = marketplaceManager.isActive();

			if (isMarketplaceActive) {
				marketplaceManager.pauseActiveProducts();
			} else {
				marketplaceManager.playActiveProducts();
			}

			updateTexts();
			rebuildProductPanels();
		});

		TwitchLiveLoadoutPanel.initializePanelButton(testModePanel, testModeLabel, getTestModeButtonTitle(), () -> {
			final boolean isTestModeActive = marketplaceManager.isTestModeActive();

			if (isTestModeActive) {
				marketplaceManager.disableTestMode();
			} else {
				marketplaceManager.enableTestMode();
			}

			updateTexts();
			rebuildProductPanels();
		});

		TwitchLiveLoadoutPanel.initializePanelButton(chaosModePanel, chaosModeLabel, getChaosModeButtonTitle(), () -> {
			final boolean isChaosModeActive = marketplaceManager.isChaosModeActive();

			if (isChaosModeActive) {
				marketplaceManager.disableChaosMode();
			} else {
				marketplaceManager.enableChaosMode();
			}

			updateTexts();
			rebuildProductPanels();
			rebuildTransactionPanels();
		});

		TwitchLiveLoadoutPanel.initializePanelButton(freeModePanel, freeModeLabel, getFreeModeButtonTitle(), () -> {
			final boolean isFreeModeActive = marketplaceManager.isFreeModeActive();

			if (isFreeModeActive) {
				marketplaceManager.disableFreeMode();
			} else {
				marketplaceManager.enableFreeMode();
			}

			updateTexts();
			rebuildProductPanels();
			rebuildTransactionPanels();
		});

		// initialize all the panel slots
		for (int i = 0; i < MarketplaceConstants.MAX_MARKETPLACE_PRODUCT_AMOUNT_IN_MEMORY; i++)
		{
			MarketplaceProductPanel marketplaceProductPanel = new MarketplaceProductPanel(this);
			productPanels.add(marketplaceProductPanel);
			productListPanel.add(marketplaceProductPanel, productListConstraints);
			productListConstraints.gridy++;
			marketplaceProductPanel.rebuild();
		}

		// initialize all the transaction panel slots
		for (int i = 0; i < MarketplaceConstants.MAX_TRANSACTION_AMOUNT_IN_MEMORY; i++)
		{
			TwitchTransactionPanel twitchTransactionPanel = new TwitchTransactionPanel(this, marketplaceManager);
			transactionPanels.add(twitchTransactionPanel);
			transactionListPanel.add(twitchTransactionPanel, transactionListConstraints);
			transactionListConstraints.gridy++;
			twitchTransactionPanel.rebuild();
		}

		// initialize all the custom products panel slots
		for (int i = 0; i < MarketplaceConstants.MAX_CUSTOM_RANDOM_PRODUCTS; i++)
		{
			EbsProductPanel ebsProductPanel = new EbsProductPanel(this, marketplaceManager);
			customProductPanels.add(ebsProductPanel);
			customProductListPanel.add(ebsProductPanel, transactionListConstraints);
			transactionListConstraints.gridy++;
			ebsProductPanel.rebuild();
		}

		TwitchLiveLoadoutPanel.initializePanelButton(stateReloadPanel, stateReloadLabel, "Reload configurations", () -> {
			marketplaceManager.updateAsyncChannelPointRewards();
			marketplaceManager.updateStreamerProducts();
			marketplaceManager.updateAsyncEbsProducts();
		});

		repaint();
		revalidate();
	}

	public void updateLayout()
	{
		customProductListTitlePanel.setVisible(config.manualMarketplaceProductsEnabled());
		customProductListWrapper.setVisible(config.manualMarketplaceProductsEnabled());
	}

	private void repopulatePanels()
	{
		final CopyOnWriteArrayList<MarketplaceProduct> activeProducts = marketplaceManager.getActiveProducts();
		final CopyOnWriteArrayList<TwitchTransaction> archivedTransactions = marketplaceManager.getArchivedTransactions();

		int marketplaceProductPanelIndex = 0;
		int twitchTransactionPanelIndex = 0;

		// order by started at
		Collections.sort(activeProducts, new MarketplaceProductSorter());

		// first clear all the panels
		LambdaIterator.handleAll(productPanels, (productPanel) -> {
			productPanel.setEntity(null);
		});
		LambdaIterator.handleAll(transactionPanels, (transactionPanel) -> {
			transactionPanel.setEntity(null);
		});

		// directly add all the products again in the new order
		for (MarketplaceProduct marketplaceProduct : activeProducts)
		{
			MarketplaceProductPanel panel = productPanels.get(marketplaceProductPanelIndex);

			// guard: check if the panel is valid
			if (panel == null)
			{
				log.warn("An invalid marketplace product panel index was requested: "+ marketplaceProductPanelIndex);
				break;
			}

			panel.setEntity(marketplaceProduct);
			marketplaceProductPanelIndex ++;
		}

		// directly add all the products again in the new order
		for (TwitchTransaction twitchTransaction : archivedTransactions)
		{

			// guard: skip when too many transactions are there
			if (twitchTransactionPanelIndex >= transactionPanels.size()) {
				break;
			}

			TwitchTransactionPanel panel = transactionPanels.get(twitchTransactionPanelIndex);

			// guard: check if the panel is valid
			if (panel == null)
			{
				log.warn("An invalid transaction product panel index was requested: "+ twitchTransactionPanelIndex);
				break;
			}

			panel.setEntity(twitchTransaction);
			twitchTransactionPanelIndex ++;
		}

		// finally update the panels
		rebuildProductPanels();
		rebuildTransactionPanels();
	}

	public void rebuildProductPanels()
	{
		LambdaIterator.handleAll(productPanels, EntityActionPanel::rebuild);
	}

	public void rebuildTransactionPanels()
	{
		LambdaIterator.handleAll(transactionPanels, EntityActionPanel::rebuild);
	}

	public void rebuildCustomProductPanels()
	{
		AtomicInteger atomicIndex = new AtomicInteger();
		CopyOnWriteArrayList<EbsProduct> customEbsProducts = marketplaceManager.getCustomEbsProducts();

		LambdaIterator.handleAll(customProductPanels, (customProductPanel) -> {
			int index = atomicIndex.get();

			// guard: make sure we don't exceed the amount of custom products we have
			if (index >= customEbsProducts.size())
			{
				return;
			}

			EbsProduct customEbsProduct = customEbsProducts.get(index);
			customProductPanel.setEntity(customEbsProduct);
			customProductPanel.rebuild();
			atomicIndex.getAndIncrement();
		});
	}

	public void updateTexts()
	{
		final CopyOnWriteArrayList<MarketplaceProduct> activeProducts = marketplaceManager.getActiveProducts();
		final CopyOnWriteArrayList<StreamerProduct> streamerProducts = marketplaceManager.getStreamerProducts();
		final CopyOnWriteArrayList<ChannelPointReward> channelPointRewards = marketplaceManager.getChannelPointRewards();
		final CopyOnWriteArrayList<TwitchTransaction> queuedTransactions = marketplaceManager.getQueuedTransactions();
		final CopyOnWriteArrayList<TwitchTransaction> archivedTransactions = marketplaceManager.getArchivedTransactions();

		final int streamerProductAmount = streamerProducts.size();
		final int queuedTransactionAmount = queuedTransactions.size();
		final int activeProductAmount = activeProducts.size();
		final int archivedTransactionAmount = archivedTransactions.size();
		final int channelPointRewardAmount = channelPointRewards.size();
		final boolean areChannelEventsActive = !marketplaceManager.getConfig().twitchOAuthAccessToken().isEmpty();

		String statusText = "<html><b color='"+ SUCCESS_TEXT_COLOR +"'>Receiving Random Events is ACTIVE. Preview mode is disabled. Channel Events are "+ (areChannelEventsActive ? "ACTIVE" : "NOT SETUP") +".</b></html>";
		String availableRandomEventsText = "<html>You have <b color='"+ SUCCESS_TEXT_COLOR +"'>configured "+ streamerProductAmount +" Random Events</b>.</html>";
		String availableChannelPointRewardsText = "<html>You have <b color='"+ SUCCESS_TEXT_COLOR +"'>configured "+ channelPointRewardAmount +" Channel Point Rewards</b>.</html>";

		if (marketplaceManager.isTestModeActive())
		{
			statusText = "<html><b color='"+ WARNING_TEXT_COLOR +"'>Receiving preview Random Events is ACTIVE when you are logged in. Disable preview mode when done.</b></html>";
		}

		if (marketplaceManager.isChaosModeActive())
		{
			statusText = "<html><b color='"+ WARNING_TEXT_COLOR +"'>Chaos Mode is active, multiplying spawns and other things for Random Events. Disable chaos mode when done.</b></html>";
		}

		if (marketplaceManager.isFreeModeActive())
		{
			statusText = "<html><b color='"+ WARNING_TEXT_COLOR +"'>All configured Random Events are temporarily FREE for viewers. Disable free mode when done.</b></html>";
		}

		if (!marketplaceManager.isActive())
		{
			statusText = "<html><b color='"+ ERROR_TEXT_COLOR +"'>Random Events are temporarily PAUSED. Click PLAY ALL below to resume.</b></html>";
		}

		if (!marketplaceManager.getConfig().marketplaceEnabled())
		{
			statusText = "<html><b color='"+ ERROR_TEXT_COLOR +"'>Random Events are DISABLED in the plugin settings</b></html>";
		}

		if (marketplaceManager.isFetchingEbsTransactionsErrored())
		{
			statusText = "<html><b color='"+ ERROR_TEXT_COLOR +"'>Random Events are NOT AVAILABLE right now and therefore disabled. Contact support if the issue persists.</b></html>";
		}

		if (streamerProductAmount <= 0)
		{
			availableRandomEventsText = "<html>There are <b color='"+ ERROR_TEXT_COLOR +"'>no Random Events configured<b>. Go to the Live Loadout Twitch Extension configuration page where you copied your token to set them up.</html>";
		}

		if (channelPointRewardAmount <= 0)
		{
			availableChannelPointRewardsText = "<html>There are <b color='"+ WARNING_TEXT_COLOR +"'>no Channel Point Rewards available<b>. Go to your channel to set them up if you want Random Events to trigger when they are redeemed.</html>";
		}

		if (!areChannelEventsActive)
		{
			availableChannelPointRewardsText = "<html><b color='"+ WARNING_TEXT_COLOR +"'>No Channel Point Rewards can be fetched<b>. Configure the Twitch Channel Token if you want to enable Random Events triggered by Channel Points, follows, subscriptions, etc.</html>";
		}

		statusPanel.setText(statusText);
		startLabel.setText(getPlaybackButtonTitle());
		testModeLabel.setText(getTestModeButtonTitle());
		chaosModeLabel.setText(getChaosModeButtonTitle());
		freeModeLabel.setText(getFreeModeButtonTitle());
		availableRandomEventsPanel.setText(availableRandomEventsText);
		availableChannelPointRewardsPanel.setText(availableChannelPointRewardsText);
		queuedTransactionsPanel.setText("There are "+ queuedTransactionAmount +" Random Events queued.");
		productListTitlePanel.setText("There are "+ activeProductAmount +" Random Events active.");
		transactionListTitlePanel.setText("There are "+ archivedTransactionAmount +" recent Random Events.");
	}

	private String getPlaybackButtonTitle()
	{
		return "<html><b color='yellow'>"+ (marketplaceManager.isActive() ? "PAUSE ALL" : "PLAY ALL") +"</b></html>";
	}

	private String getTestModeButtonTitle()
	{
		return "<html><b color='"+ (marketplaceManager.isTestModeActive() ? "red" : "yellow") +"'>"+ (marketplaceManager.isTestModeActive() ? "DISABLE PREVIEW MODE" : "ENABLE PREVIEW MODE ("+ MarketplaceManager.TEST_MODE_EXPIRY_TIME_READABLE +")") +"</b></html>";
	}

	private String getChaosModeButtonTitle()
	{
		return "<html><b color='"+ (marketplaceManager.isChaosModeActive() ? "red" : "yellow") +"'>"+ (marketplaceManager.isChaosModeActive() ? "DISABLE CHAOS MODE" : "ENABLE CHAOS MODE ("+ MarketplaceManager.CHAOS_MODE_EXPIRY_TIME_READABLE +")") +"</b></html>";
	}

	private String getFreeModeButtonTitle()
	{
		return "<html><b color='"+ (marketplaceManager.isFreeModeActive() ? "red" : "yellow") +"'>"+ (marketplaceManager.isFreeModeActive() ? "DISABLE FREE MODE" : "ENABLE FREE MODE ("+ MarketplaceManager.FREE_MODE_EXPIRY_TIME_READABLE +")") +"</b></html>";
	}
}

package com.twitchliveloadout.ui;

import com.twitchliveloadout.marketplace.MarketplaceDuration;
import com.twitchliveloadout.marketplace.MarketplaceManager;
import com.twitchliveloadout.marketplace.MarketplaceMessages;
import com.twitchliveloadout.marketplace.products.EbsProduct;
import com.twitchliveloadout.marketplace.products.MarketplaceProduct;
import com.twitchliveloadout.marketplace.products.TwitchProductCost;
import com.twitchliveloadout.marketplace.transactions.TwitchTransaction;
import com.twitchliveloadout.marketplace.transactions.TwitchTransactionOrigin;
import com.twitchliveloadout.marketplace.transactions.TwitchTransactionProductType;
import com.twitchliveloadout.twitch.eventsub.TwitchEventSubType;
import lombok.extern.slf4j.Slf4j;

import javax.swing.*;
import java.time.Instant;
import java.time.ZoneId;
import java.time.format.DateTimeFormatter;

@Slf4j
public class EbsProductPanel extends EntityActionPanel<EbsProduct> {
    private final MarketplaceManager marketplaceManager;

    public EbsProductPanel(JPanel parentPanel, MarketplaceManager marketplaceManager) {
        super(
                parentPanel,
                "Invalid custom Random Event",
                false,
                "Are you sure you want to run this custom Random Event?",
                "Run custom Random Event",
                EntityActionPanel.RERUN_ICON,
                EntityActionPanel.RERUN_HOVER_ICON
        );
        this.marketplaceManager = marketplaceManager;
    }

    @Override
    protected String[] getLines() {
        EbsProduct ebsProduct = getEntity();
        Instant loadedAt = Instant.parse(ebsProduct.loaded_at);
        DateTimeFormatter formatter = DateTimeFormatter.ofPattern("HH:mm:ss - dd MMM yyyy").withZone(ZoneId.systemDefault());
        String formattedLoadedAt = formatter.format(loadedAt);
        String[] lines = new String[]{
                "<b>"+ ebsProduct.category +"</b>",
                "<b color='yellow'>" + ebsProduct.name + "</b>",
                "Updated: "+ formattedLoadedAt,
        };

        return lines;
    }

    @Override
    protected void executeAction() {
        EbsProduct ebsProduct = getEntity();
        MarketplacePanel marketplacePanel = (MarketplacePanel) parentPanel;
        String ebsProductId = ebsProduct.id;

        log.info("A manual EBS product is being run, ID: "+ ebsProductId);
        marketplaceManager.testEbsProduct(ebsProduct, TwitchTransactionProductType.MANUAL, TwitchTransactionOrigin.MANUAL);
        marketplacePanel.rebuild();
    }

    @Override
    protected boolean canRunAction() {
        return true;
    }
}

package com.twitchliveloadout.ui;

import com.twitchliveloadout.TwitchLiveLoadoutPlugin;
import com.twitchliveloadout.marketplace.MarketplaceDuration;
import com.twitchliveloadout.marketplace.MarketplaceManager;
import com.twitchliveloadout.marketplace.MarketplaceMessages;
import com.twitchliveloadout.marketplace.products.StreamerProduct;
import com.twitchliveloadout.marketplace.products.TwitchProductCost;
import com.twitchliveloadout.marketplace.transactions.TwitchTransaction;
import com.twitchliveloadout.twitch.eventsub.TwitchEventSubType;
import com.twitchliveloadout.twitch.eventsub.messages.BaseMessage;
import com.twitchliveloadout.twitch.eventsub.messages.BaseUserInfo;
import lombok.extern.slf4j.Slf4j;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.util.ImageUtil;

import javax.swing.*;
import javax.swing.border.EmptyBorder;
import java.awt.*;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.awt.image.BufferedImage;
import java.time.Duration;
import java.time.Instant;
import java.time.ZoneId;
import java.time.format.DateTimeFormatter;

@Slf4j
public class TwitchTransactionPanel extends EntityActionPanel<TwitchTransaction> {

	private final MarketplaceManager marketplaceManager;

	public TwitchTransactionPanel(JPanel parentPanel, MarketplaceManager marketplaceManager) {
		super(
			parentPanel,
			"Invalid Twitch Transaction",
			false,
			"Are you sure you want to rerun this donation Random Event?",
			"Rerun Random Event",
			EntityActionPanel.RERUN_ICON,
			EntityActionPanel.RERUN_HOVER_ICON
		);

		this.marketplaceManager = marketplaceManager;
	}

	@Override
	protected String[] getLines() {
		TwitchTransaction twitchTransaction = getEntity();
		StreamerProduct streamerProduct = marketplaceManager.getStreamerProductByTransaction(twitchTransaction);
		Instant transactionAt = Instant.parse(twitchTransaction.timestamp);
		DateTimeFormatter formatter = DateTimeFormatter.ofPattern("HH:mm:ss - dd MMM yyyy").withZone(ZoneId.systemDefault());
		String transactionAtString = formatter.format(transactionAt);
		String[] lines = {};
		String streamerProductName = "Unknown";

		if (streamerProduct != null)
		{
			streamerProductName = streamerProduct.name;
		}

		if (twitchTransaction.isCurrencyTransaction())
		{
			String viewerName = twitchTransaction.user_name;
			TwitchProductCost productCost = twitchTransaction.product_data.cost;
			Double costAmount = productCost.amount;
			String costCurrency = productCost.type;
			String currencyLine = twitchTransaction.isFreeTransaction() ? "FREE activation" : "Donation of <b color='yellow'>"+ costAmount +" "+ costCurrency +"</b>";

			lines = new String[]{
				"<b>"+ streamerProductName +"</b>",
				currencyLine,
				"By <b color='yellow'>"+ viewerName + "</b>",
				"At "+ transactionAtString,
			};
		}

		if (twitchTransaction.isEventSubTransaction())
		{
			TwitchEventSubType eventSubType = twitchTransaction.eventSubType;
			BaseMessage eventSubMessage = twitchTransaction.eventSubMessage;
			String viewerName = null;

			if (eventSubMessage instanceof BaseUserInfo)
			{
				BaseUserInfo baseUserInfo = (BaseUserInfo) eventSubMessage;
				viewerName = baseUserInfo.user_name;
			}

			if (viewerName == null)
			{
				viewerName = "unknown";
			}

			lines = new String[]{
				"<b>"+ eventSubType.getName() +"</b>",
				"<b color='yellow'>" + streamerProductName + "</b>",
				"By <b color='yellow'>"+ viewerName + "</b>",
				"At "+ transactionAtString,
			};
		}

		return lines;
	}

	@Override
	protected void executeAction() {
		TwitchTransaction twitchTransaction = getEntity();
		String transactionId = (twitchTransaction != null ? twitchTransaction.id : "unknown");

		log.info("A transaction is manually requested for a rerun, transaction ID: "+ transactionId);
		marketplaceManager.rerunTransaction(twitchTransaction);
	}

	@Override
	protected boolean canRunAction() {
		TwitchTransaction twitchTransaction = getEntity();

		if (twitchTransaction == null)
		{
			return false;
		}

		String transactionId = twitchTransaction.id;
		boolean isFreeTransaction = twitchTransaction.isFreeTransaction();
		boolean isAlreadyActive = marketplaceManager.isTransactionActive(transactionId);

		return !isAlreadyActive && (!isFreeTransaction || marketplaceManager.isFreeModeActive());
	}
}

package com.twitchliveloadout.ui;

import com.twitchliveloadout.TwitchLiveLoadoutPlugin;
import com.twitchliveloadout.marketplace.MarketplaceDuration;
import com.twitchliveloadout.marketplace.products.MarketplaceProduct;
import com.twitchliveloadout.marketplace.products.TwitchProductCost;
import lombok.Getter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.util.ImageUtil;

import javax.swing.*;
import javax.swing.border.EmptyBorder;
import java.awt.*;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.awt.image.BufferedImage;

@Slf4j
public abstract class EntityActionPanel<EntityType> extends JPanel {
	protected static final ImageIcon DELETE_ICON;
	protected static final ImageIcon DELETE_HOVER_ICON;
	protected static final ImageIcon RERUN_ICON;
	protected static final ImageIcon RERUN_HOVER_ICON;

	@Getter
	private EntityType entity;
	protected final JPanel parentPanel;
	protected final String invalidText;

	private final JPanel wrapper = new JPanel(new GridBagLayout());
	private final JLabel nameLabel = new JLabel();
	private final JLabel actionLabel = new JLabel();

	static
	{
		final BufferedImage deleteImg = ImageUtil.loadImageResource(TwitchLiveLoadoutPlugin.class, "/delete_icon.png");
		final BufferedImage rerunImg = ImageUtil.loadImageResource(TwitchLiveLoadoutPlugin.class, "/rerun_icon.png");
		DELETE_ICON = new ImageIcon(deleteImg);
		DELETE_HOVER_ICON = new ImageIcon(ImageUtil.alphaOffset(deleteImg, -100));
		RERUN_ICON = new ImageIcon(rerunImg);
		RERUN_HOVER_ICON = new ImageIcon(ImageUtil.alphaOffset(rerunImg, -100));
	}

	public EntityActionPanel(JPanel parentPanel, String invalidText, boolean enableConfirm, String confirmText, String actionTooltipText, ImageIcon actionIcon, ImageIcon actionHoverIcon)
	{
		this.parentPanel = parentPanel;
		this.invalidText = invalidText;

		setLayout(new BorderLayout());
		setBorder(new EmptyBorder(0, 0, 10, 0));

		Styles.styleBigLabel(nameLabel, "N/A");

		actionLabel.setIcon(actionIcon);
		actionLabel.setToolTipText(actionTooltipText);
		actionLabel.addMouseListener(new MouseAdapter()
		{
			@Override
			public void mousePressed(MouseEvent mouseEvent)
			{

				// guard: check if we should skip this action
				if (entity == null)
				{
					return;
				}

				// guard: immediately skip the confirm when disabled
				if (!enableConfirm)
				{
					executeAction();
					return;
				}

				int confirm = JOptionPane.showConfirmDialog(parentPanel,
					confirmText,
					"Warning",
					JOptionPane.OK_CANCEL_OPTION
				);

				if (confirm == 0)
				{
					executeAction();
				}
			}

			@Override
			public void mouseEntered(MouseEvent mouseEvent)
			{
				actionLabel.setIcon(actionHoverIcon);
				actionLabel.setCursor(new Cursor(Cursor.HAND_CURSOR));
			}

			@Override
			public void mouseExited(MouseEvent mouseEvent)
			{
				actionLabel.setIcon(actionIcon);
				actionLabel.setCursor(new Cursor(Cursor.DEFAULT_CURSOR));
			}
		});

		wrapper.setLayout(new BorderLayout());
		wrapper.setBorder(new EmptyBorder(10, 10, 10, 10));
		wrapper.setBackground(ColorScheme.DARKER_GRAY_COLOR);
		wrapper.add(nameLabel, BorderLayout.WEST);
		wrapper.add(actionLabel, BorderLayout.EAST);

		add(wrapper, BorderLayout.NORTH);
	}

	public void setEntity(EntityType entity)
	{
		this.entity = entity;
	}

	public void rebuild()
	{

		// guard: check if the entity is valid
		if (entity == null)
		{
			nameLabel.setText(invalidText);
			setVisible(false);
			return;
		}

		String[] lines = getLines();
		String name = String.join("<br/>", lines);

		setVisible(true);
		nameLabel.setText("<html>"+ name +"</html>");
		actionLabel.setVisible(canRunAction());
	}

	protected abstract String[] getLines();

	protected abstract void executeAction();
	protected abstract boolean canRunAction();
}

package com.twitchliveloadout.ui;

import net.runelite.client.ui.ColorScheme;

import javax.swing.*;
import javax.swing.border.EmptyBorder;
import java.awt.*;

public class TextPanel extends JPanel
{
	private final GridBagConstraints constraints = new GridBagConstraints();
	private final GridBagConstraints textConstraints = new GridBagConstraints();

	private final JPanel textWrapper = new JPanel(new GridBagLayout());

	private final JLabel titleLabel = new JLabel();
	private final JLabel textLabel = new JLabel();

	public TextPanel(String title, String text)
	{
		super(new GridBagLayout());
		setBorder(new EmptyBorder(10, 0, 5, 0));

		constraints.fill = GridBagConstraints.HORIZONTAL;
		constraints.weightx = 1;
		constraints.gridx = 0;
		constraints.gridy = 0;

		textConstraints.fill = GridBagConstraints.HORIZONTAL;
		textConstraints.weightx = 1;
		textConstraints.gridx = 0;
		textConstraints.gridy = 0;

		Styles.styleBigLabel(titleLabel, title);
		titleLabel.setBorder(new EmptyBorder(0, 0, 5, 0));
		Styles.styleLabel(textLabel, text);

		textWrapper.setLayout(new GridBagLayout());
		textWrapper.setBorder(new EmptyBorder(10, 10, 10, 10));
		textWrapper.setBackground(ColorScheme.DARKER_GRAY_COLOR);
		textWrapper.add(textLabel, textConstraints);

		add(titleLabel, constraints);
		constraints.gridy++;
		add(textWrapper, constraints);
		constraints.gridy++;
	}

	public void setText(String text)
	{
		if (text == null)
		{
			text = "";
		}

		textLabel.setText(text);
	}
}

package com.twitchliveloadout.ui;

import com.twitchliveloadout.fights.ActorType;
import com.twitchliveloadout.fights.Fight;
import com.twitchliveloadout.fights.FightStateManager;
import com.twitchliveloadout.TwitchLiveLoadoutPlugin;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.util.ImageUtil;

import javax.swing.*;
import javax.swing.border.EmptyBorder;
import java.awt.*;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.awt.image.BufferedImage;

public class FightPanel extends JPanel
{
	private final FightStateManager fightStateManager;
	private Fight fight;

	private static final ImageIcon DELETE_ICON;
	private static final ImageIcon DELETE_HOVER_ICON;

	private final JPanel wrapper = new JPanel(new GridBagLayout());
	private final JLabel actorNameLabel = new JLabel();
	private final JLabel deleteLabel = new JLabel();

	static
	{
		final BufferedImage deleteImg = ImageUtil.loadImageResource(TwitchLiveLoadoutPlugin.class, "/delete_icon.png");
		DELETE_ICON = new ImageIcon(deleteImg);
		DELETE_HOVER_ICON = new ImageIcon(ImageUtil.alphaOffset(deleteImg, -100));
	}

	public FightPanel(FightStateManager fightStateManager)
	{
		this.fightStateManager = fightStateManager;

		setLayout(new BorderLayout());
		setBorder(new EmptyBorder(0, 0, 10, 0));

		Styles.styleBigLabel(actorNameLabel, "N/A");

		deleteLabel.setIcon(DELETE_ICON);
		deleteLabel.setToolTipText("Reset fight statistics");
		deleteLabel.addMouseListener(new MouseAdapter()
		{
			@Override
			public void mousePressed(MouseEvent mouseEvent)
			{
				int confirm = JOptionPane.showConfirmDialog(FightPanel.this,
					"Are you sure you want to reset this fight?",
					"Warning", JOptionPane.OK_CANCEL_OPTION);

				if (confirm == 0)
				{
					fightStateManager.deleteFight(fight);
				}
			}

			@Override
			public void mouseEntered(MouseEvent mouseEvent)
			{
				deleteLabel.setIcon(DELETE_HOVER_ICON);
				deleteLabel.setCursor(new Cursor(Cursor.HAND_CURSOR));
			}

			@Override
			public void mouseExited(MouseEvent mouseEvent)
			{
				deleteLabel.setIcon(DELETE_ICON);
				deleteLabel.setCursor(new Cursor(Cursor.DEFAULT_CURSOR));
			}
		});

		wrapper.setLayout(new BorderLayout());
		wrapper.setBorder(new EmptyBorder(10, 10, 10, 10));
		wrapper.setBackground(ColorScheme.DARKER_GRAY_COLOR);
		wrapper.add(actorNameLabel, BorderLayout.WEST);
		wrapper.add(deleteLabel, BorderLayout.EAST);

		add(wrapper, BorderLayout.NORTH);
	}

	public void setFight(Fight fight)
	{
		this.fight = fight;
	}

	public void rebuild()
	{

		// guard: check if the fight is valid
		if (fight == null)
		{
			return;
		}

		final String actorName = fight.getActorName();
		final ActorType actorType = fight.getActorType();

		actorNameLabel.setText(actorName +" ("+ actorType.getName() +")");
	}
}

/*
 * Copyright (c) 2018 Abex
 * Copyright (c) 2018, Psikoi <https://github.com/psikoi>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.twitchliveloadout.ui;

import com.google.gson.JsonObject;
import com.twitchliveloadout.TwitchLiveLoadoutConfig;
import com.twitchliveloadout.TwitchLiveLoadoutPlugin;
import com.twitchliveloadout.twitch.TwitchApi;
import com.twitchliveloadout.twitch.TwitchState;
import com.twitchliveloadout.twitch.eventsub.TwitchEventSubClient;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.FontManager;
import net.runelite.client.util.ImageUtil;
import net.runelite.client.util.LinkBrowser;

import javax.swing.*;
import javax.swing.border.EmptyBorder;
import java.awt.*;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.time.Instant;
import java.time.ZoneId;
import java.time.format.DateTimeFormatter;
import org.apache.commons.lang3.tuple.Pair;

import static com.twitchliveloadout.TwitchLiveLoadoutConfig.PERSISTENT_STATE_CONFIG_KEYS;

public class ConnectivityPanel extends JPanel
{
	private final static String DEFAULT_TEXT_COLOR = "#ffffff";
	private final static String SUCCESS_TEXT_COLOR = "#00ff00";
	private final static String WARNING_TEXT_COLOR = "#ffa500";
	private final static String ERROR_TEXT_COLOR = "#ff0000";
	private final static int WARNING_BEFORE_EXPIRY = 60 * 5; // in seconds
	private static final ImageIcon ARROW_RIGHT_ICON;
	private static final ImageIcon DISCORD_ICON;
	private static final ImageIcon WIKI_ICON;
	private static final String SETUP_GUIDE_URL = "https://liveloadout.com/#get-started";
	private static final String DISCORD_INVITE_URL = "https://discord.gg/3Fjm5HTFGM";

	private final GridBagConstraints constraints = new GridBagConstraints();
	private final JPanel wrapper = new JPanel(new GridBagLayout());

	private final TextPanel syncingStatusPanel = new TextPanel("Syncing status", "N/A");
	private final TextPanel twitchStatusPanel = new TextPanel("Twitch Extension Status", "N/A");
	private final TextPanel twitchEventSubStatusPanel = new TextPanel("Twitch Channel Events Status", "N/A");

	private final TextPanel authPanel = new TextPanel("Twitch Token Validity", "N/A");
	private final TextPanel rateLimitPanel = new TextPanel("Twitch API Limit", "N/A");
	private final TextPanel statePanel = new TextPanel("Loadout State Size", "N/A");
	private final JPanel stateResetPanel = new JPanel(new BorderLayout());
	private final JLabel stateResetLabel = new JLabel();
	private JPanel actionsContainer = new JPanel();

	private final TwitchLiveLoadoutPlugin plugin;
	private final TwitchApi twitchApi;
	private final TwitchEventSubClient twitchEventSubClient;
	private final TwitchState twitchState;
	private final CanvasListener canvasListener;
	private final TwitchLiveLoadoutConfig config;

	static
	{
		ARROW_RIGHT_ICON = new ImageIcon(ImageUtil.loadImageResource(ConnectivityPanel.class, "/arrow_right.png"));
		DISCORD_ICON = new ImageIcon(ImageUtil.loadImageResource(ConnectivityPanel.class, "/discord_icon.png"));
		WIKI_ICON = new ImageIcon(ImageUtil.loadImageResource(ConnectivityPanel.class, "/wiki_icon.png"));
	}

	public ConnectivityPanel(TwitchLiveLoadoutPlugin plugin, TwitchApi twitchApi, TwitchEventSubClient twitchEventSubClient, TwitchState twitchState, CanvasListener canvasListener, TwitchLiveLoadoutConfig config)
	{
		super(new GridBagLayout());

		this.plugin = plugin;
		this.twitchApi = twitchApi;
		this.twitchEventSubClient = twitchEventSubClient;
		this.twitchState = twitchState;
		this.canvasListener = canvasListener;
		this.config = config;

		setLayout(new BorderLayout());
		setBorder(new EmptyBorder(10, 10, 10, 10));

		actionsContainer.setBorder(new EmptyBorder(10, 0, 0, 0));
		actionsContainer.setLayout(new GridLayout(0, 1, 0, 10));
		actionsContainer.add(buildLinkPanel(DISCORD_ICON, "Get support on the", "Discord server", () -> {
			LinkBrowser.browse(DISCORD_INVITE_URL);
		}));
		actionsContainer.add(buildLinkPanel(WIKI_ICON, "Go to online", "setup guide", () -> {
			LinkBrowser.browse(SETUP_GUIDE_URL);
		}));

		TwitchLiveLoadoutPanel.initializePanelButton(stateResetPanel, stateResetLabel, "Reset state", () -> {
			plugin.resetPersistentStateConfiguration();
			twitchState.resetState();
		});

		constraints.fill = GridBagConstraints.HORIZONTAL;
		constraints.weightx = 1;
		constraints.gridx = 0;
		constraints.gridy = 0;

		// add all panels
		wrapper.add(actionsContainer);
		constraints.gridy += 2;
		wrapper.add(twitchStatusPanel, constraints);
		constraints.gridy++;
		wrapper.add(twitchEventSubStatusPanel, constraints);
		constraints.gridy++;
		wrapper.add(syncingStatusPanel, constraints);
		constraints.gridy++;
		wrapper.add(authPanel, constraints);
		constraints.gridy++;
		wrapper.add(rateLimitPanel, constraints);
		constraints.gridy++;
		wrapper.add(statePanel, constraints);
		constraints.gridy++;
		wrapper.add(stateResetPanel, constraints);
		constraints.gridy++;

		add(wrapper, BorderLayout.NORTH);
	}

	public void rebuild()
	{
		final long unixTimestamp = System.currentTimeMillis() / 1000L;
		final int rateLimitRemaining = twitchApi.getLastRateLimitRemaining();
		String syncingStatusText = "The logged in account is currently syncing to Twitch.";
		String syncingStatusColor = SUCCESS_TEXT_COLOR;

		final int responseCode = twitchApi.getLastResponseCode();
		String twitchStatusText = twitchApi.getLastResponseMessage();
		String twitchStatusColor = SUCCESS_TEXT_COLOR;

		long tokenExpiry = 0;
		String authText = "No valid Twitch Token. See instructions above how to get a new token.";
		String authColor = ERROR_TEXT_COLOR;

		String rateLimitText = "There are "+ rateLimitRemaining +" request points available before hitting the Twitch API rate limit.";
		String rateLimitColor = DEFAULT_TEXT_COLOR;

		// update syncing status text
		if (!config.syncEnabled())
		{
			syncingStatusText = "Syncing is currently disabled in the plugin settings. Nothing is being sent to Twitch.";
			syncingStatusColor = ERROR_TEXT_COLOR;
		}
		else if (!plugin.isLoggedIn())
		{
			syncingStatusText = "This client is currently not logged into an account. Twitch only receives connectivity updates without any loadout information.";
			syncingStatusColor = WARNING_TEXT_COLOR;
		}

		var twitchPubSubStatus = getTwitchPubSubStatus();
		String twitchPubSubStatusText = twitchPubSubStatus.getLeft();
		String twitchPubSubStatusColor = twitchPubSubStatus.getRight();

		try {
			final JsonObject decodedToken = twitchApi.getDecodedToken();
			tokenExpiry = decodedToken.get("exp").getAsLong();
			final DateTimeFormatter formatter = DateTimeFormatter.ofPattern("dd MMMM YYYY, HH:mm");
			final String tokenExpiryFormatted = Instant.ofEpochSecond(tokenExpiry).atZone(ZoneId.systemDefault()).format(formatter);
			final long secondsUntilExpired = tokenExpiry - unixTimestamp;

			// check if the token is still valid
			if (secondsUntilExpired > 0)
			{
				authText = "Twitch Token is VALID and expires at: <br/>"+ tokenExpiryFormatted;
				authColor = (secondsUntilExpired > WARNING_BEFORE_EXPIRY ? DEFAULT_TEXT_COLOR : ERROR_TEXT_COLOR);
			}
			else
			{
				authText = "Token has EXPIRED at: <br/>"+ tokenExpiryFormatted;
			}
		} catch (Exception exception) {
			// empty, ignore any errors
		}

		// check if the token is not valid
		if (authColor.equals(ERROR_TEXT_COLOR))
		{
			twitchStatusText = "Could not send data to Twitch due to invalid token. Paste the new token in the 'Your copied Twitch Extension Token' setting of the plugin. To get a new token in Twitch navigate to: 'Creator Dashboard' > 'Extensions' > 'OSRS Live Loadout' > 'Configure' > 'Copy Token'.";
			twitchStatusColor = ERROR_TEXT_COLOR;
		}

		String state = twitchApi.getLastCompressedState();
		byte[] stateBytes = state.getBytes();
		float stateUsagePercentage = ((float) stateBytes.length) / ((float) TwitchApi.MAX_PAYLOAD_SIZE) * 100;
		String currentCyclicState = twitchState.getCurrentCyclicEntry().getKey();
		String stateText = String.format("%.2f", stateUsagePercentage) +"% used of Twitch storage for general data and part of "+ currentCyclicState +".";
		String stateColor = DEFAULT_TEXT_COLOR;

		if (twitchApi.isErrorResponseCode(responseCode))
		{
			twitchStatusText += "<br/><br/>An error occurred wth code: "+ responseCode;
			twitchStatusColor = ERROR_TEXT_COLOR;
		}

		if (stateUsagePercentage >= 100)
		{
			stateText += "<br/><br/>An error occurred: state is too large to send to Twitch (current slice: "+ currentCyclicState +"). Please disable some synced information via the plugin settings in RuneLite and report this to the plugin maintainer via the linked Discord above.";
			stateColor = ERROR_TEXT_COLOR;
		}

		if (rateLimitRemaining <= 10)
		{
			rateLimitText += "<br/><br/>Which is almost depleted! Consider having fewer RuneLite clients open at the same time with the plugin active.";
			rateLimitColor = ERROR_TEXT_COLOR;
		}

		syncingStatusPanel.setText(getTextInColor(syncingStatusText, syncingStatusColor));
		twitchStatusPanel.setText(getTextInColor(twitchStatusText, twitchStatusColor));
		twitchEventSubStatusPanel.setText(getTextInColor(twitchPubSubStatusText, twitchPubSubStatusColor));
		authPanel.setText(getTextInColor(authText, authColor));
		rateLimitPanel.setText(getTextInColor(rateLimitText, rateLimitColor));
		statePanel.setText(getTextInColor(stateText, stateColor));
	}

	public String getTextInColor(String text, String color)
	{
		return "<html><body style=\"color: "+ color +";\">"+ text +"</body></html>";
	}

	/**
	 * Builds a link panel with a given icon, text and callable to call.
	 */
	private static JPanel buildLinkPanel(ImageIcon icon, String topText, String bottomText, Runnable callback)
	{
		JPanel container = new JPanel();
		container.setBackground(ColorScheme.DARKER_GRAY_COLOR);
		container.setLayout(new BorderLayout());
		container.setBorder(new EmptyBorder(10, 10, 10, 10));

		final Color hoverColor = ColorScheme.DARKER_GRAY_HOVER_COLOR;
		final Color pressedColor = ColorScheme.DARKER_GRAY_COLOR.brighter();

		JLabel iconLabel = new JLabel(icon);
		container.add(iconLabel, BorderLayout.WEST);

		JPanel textContainer = new JPanel();
		textContainer.setBackground(ColorScheme.DARKER_GRAY_COLOR);
		textContainer.setLayout(new GridLayout(2, 1));
		textContainer.setBorder(new EmptyBorder(5, 10, 5, 10));

		container.addMouseListener(new MouseAdapter()
		{
			@Override
			public void mousePressed(MouseEvent mouseEvent)
			{
				container.setBackground(pressedColor);
				textContainer.setBackground(pressedColor);
			}

			@Override
			public void mouseReleased(MouseEvent e)
			{
				callback.run();
				container.setBackground(hoverColor);
				textContainer.setBackground(hoverColor);
			}

			@Override
			public void mouseEntered(MouseEvent e)
			{
				container.setBackground(hoverColor);
				textContainer.setBackground(hoverColor);
				container.setCursor(new Cursor(Cursor.HAND_CURSOR));
			}

			@Override
			public void mouseExited(MouseEvent e)
			{
				container.setBackground(ColorScheme.DARKER_GRAY_COLOR);
				textContainer.setBackground(ColorScheme.DARKER_GRAY_COLOR);
				container.setCursor(new Cursor(Cursor.DEFAULT_CURSOR));
			}
		});

		JLabel topLine = new JLabel(topText);
		topLine.setForeground(Color.WHITE);
		topLine.setFont(FontManager.getRunescapeSmallFont());

		JLabel bottomLine = new JLabel(bottomText);
		bottomLine.setForeground(Color.WHITE);
		bottomLine.setFont(FontManager.getRunescapeSmallFont());

		textContainer.add(topLine);
		textContainer.add(bottomLine);

		container.add(textContainer, BorderLayout.CENTER);

		JLabel arrowLabel = new JLabel(ARROW_RIGHT_ICON);
		container.add(arrowLabel, BorderLayout.EAST);

		return container;
	}

	private Pair<String, String> getTwitchPubSubStatus()
	{

		if (config.twitchOAuthAccessToken().isEmpty() || config.twitchOAuthRefreshToken().isEmpty()) {
			return Pair.of("Twitch Channel tokens are not set. Will not connect. Follow our setup guide if you want to enable Twitch Channel Events, such as in-game effects upon channel point redeems, follow, subscriptions, etc.", DEFAULT_TEXT_COLOR);
		}

		if (twitchEventSubClient != null) {
			if (twitchEventSubClient.isConnected()) {
				return Pair.of("Connected to Twitch Channel Events API.", SUCCESS_TEXT_COLOR);
			} else if (twitchEventSubClient.isConnecting()) {
				return Pair.of("Connecting to Twitch Channel Events API...", WARNING_TEXT_COLOR);
			}

			return Pair.of("Not connected to the Twitch Channel Events API.", ERROR_TEXT_COLOR);
		}

		return Pair.of("Could not initialise the Twitch Channel Events API. Try to setup the channel events tokens again.", ERROR_TEXT_COLOR);
	}
}

/*
 * Copyright (c) 2020, Pepijn Verburg <pepijn.verburg@gmail.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.twitchliveloadout;

import com.google.inject.Provides;
import com.twitchliveloadout.achievements.CombatAchievementsManager;
import com.twitchliveloadout.fights.FightStateManager;
import com.twitchliveloadout.items.CollectionLogManager;
import com.twitchliveloadout.items.ItemStateManager;
import com.twitchliveloadout.marketplace.MarketplaceManager;
import com.twitchliveloadout.minimap.MinimapManager;
import com.twitchliveloadout.quests.QuestManager;
import com.twitchliveloadout.raids.InvocationsManager;
import com.twitchliveloadout.seasonals.SeasonalManager;
import com.twitchliveloadout.skills.SkillStateManager;
import com.twitchliveloadout.twitch.TwitchApi;
import com.twitchliveloadout.twitch.TwitchSegmentType;
import com.twitchliveloadout.twitch.TwitchState;
import com.twitchliveloadout.twitch.TwitchStateEntry;
import com.twitchliveloadout.twitch.eventsub.TwitchEventSubClient;
import com.twitchliveloadout.twitch.eventsub.TwitchEventSubListener;
import com.twitchliveloadout.ui.CanvasListener;
import com.twitchliveloadout.utilities.AccountType;
import lombok.Getter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.*;
import net.runelite.api.coords.WorldPoint;
import net.runelite.api.events.*;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.callback.Hooks;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.events.ConfigChanged;
import net.runelite.client.events.NpcLootReceived;
import net.runelite.client.game.ItemManager;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.plugins.PluginDescriptor;
import com.twitchliveloadout.ui.TwitchLiveLoadoutPanel;
import net.runelite.client.task.Schedule;
import com.google.gson.*;
import net.runelite.client.ui.ClientToolbar;
import net.runelite.client.ui.NavigationButton;
import net.runelite.client.ui.overlay.OverlayManager;
import net.runelite.client.util.ImageUtil;
import okhttp3.*;

import javax.inject.Inject;
import java.awt.image.BufferedImage;
import java.sql.Array;
import java.time.temporal.ChronoUnit;
import java.util.ArrayList;
import java.util.EnumSet;
import java.util.concurrent.ScheduledFuture;
import java.util.concurrent.ScheduledThreadPoolExecutor;
import java.util.concurrent.TimeUnit;

import static com.twitchliveloadout.TwitchLiveLoadoutConfig.*;
import static com.twitchliveloadout.twitch.TwitchApi.TRIGGER_OAUTH_REFRESH_TOKEN_TIME_S;

/**
 * Manages polling and event listening mechanisms to synchronize the state
 * to the Twitch Configuration Service. All client data is fetched in this main entry point
 * and passed along to dedicated managers. Also, you will see that this class is fairly 'polluted'
 * with try-catch statements. This helps to make sure that any breaking changes to Oldschool Runescape and/or
 * RuneLite will less likely cause issues.
 *
 * Find events via: net.runelite.api.events
 */
@PluginDescriptor(
	name = "Twitch Live Loadout",
	description = "Show Twitch viewers your collection log, bank, inventory, combat statistics, equipment, skills and more.",
	enabledByDefault = true
)
@Slf4j
public class TwitchLiveLoadoutPlugin extends Plugin
{
	/**
	 * Environment flags
	 */
	public static final boolean IN_DEVELOPMENT = false;

	@Inject
	private TwitchLiveLoadoutConfig config;

	@Inject
	private Client client;

	@Inject
	private Hooks hooks;

	@Inject
	private ClientThread clientThread;

	@Inject
	private ItemManager itemManager;

	@Inject
	private ChatMessageManager chatMessageManager;

	@Inject
	private ConfigManager configManager;

	@Inject
	private OverlayManager overlayManager;

	@Inject
	private ClientToolbar clientToolbar;

	@Inject
	private OkHttpClient httpClient;

	@Inject
	private Gson gson;

	/**
	 * Scheduled executor that does not run on the client thread.
	 */
	private ScheduledThreadPoolExecutor scheduledExecutor;

	/**
	 * The plugin panel to manage data such as combat fights.
	 */
	private static final String ICON_FILE = "/panel_icon.png";
	@Getter
	private TwitchLiveLoadoutPanel pluginPanel;
	private NavigationButton navigationButton;

	/**
	 * Twitch Configuration Service state that can be mapped to a JSON.
	 */
	private TwitchState twitchState;

	/**
	 * Twitch Configuration Service API end-point helpers.
	 */
	private TwitchApi twitchApi;

	/**
	 * Twitch EventSub client
	 */
	@Getter
	private TwitchEventSubListener twitchEventSubListener;
	/**
	 * Twitch EventSub client
	 */
	private TwitchEventSubClient twitchEventSubClient;

	/**
	 * Dedicated manager for all fight information.
	 */
	private FightStateManager fightStateManager;

	/**
	 * Dedicated manager for all item information.
	 */
	private ItemStateManager itemStateManager;

	/**
	 * Dedicated manager for all skill / stat information.
	 */
	private SkillStateManager skillStateManager;

	/**
	 * Dedicated manager for collection log information.
	 */
	private CollectionLogManager collectionLogManager;

	/**
	 * Dedicated manager for marketplace products information.
	 */
	@Getter
	private MarketplaceManager marketplaceManager;

	/**
	 * Dedicated manager for minimap information.
	 */
	private MinimapManager minimapManager;

	/**
	 * Dedicated manager for ToA invocations raid information.
	 */
	private InvocationsManager invocationsManager;

	/**
	 * Dedicated manager for quests information.
	 */
	private QuestManager questManager;

	/**
	 * Dedicated manager for combat achievement information.
	 */
	private CombatAchievementsManager combatAchievementsManager;

	/**
	 * Dedicated manager for league information.
	 */
	private SeasonalManager seasonalManager;

	/**
	 * Hook to handle
	 */
	private final Hooks.RenderableDrawListener drawListener = this::shouldDraw;

	/**
	 * Cache to check for account identifiers (hash + world type) changes as game state is not reliable for this
	 */
	private String lastAccountIdentifier = null;

	/**
	 * Listener for any events of the canvas (e.g. focus and unfocus)
	 */
	private CanvasListener canvasListener = null;

	/**
	 * Temporary flags to disable features while still in staging
	 */
	private final static boolean ENABLE_MINIMAP = false;

	/**
	 * List of world types that should result in a unique profile of persistent data
	 */
	private final ArrayList<WorldType> distinctiveWorldTypes = new ArrayList<>();

	/**
	 * Initialize this plugin
	 */
	@Override
	protected void startUp() throws Exception
	{
		super.startUp();
		initializeDistinctiveWorldTypes();
		initializeExecutors();
		initializeCanvasListeners();
		initializeTwitch();
		initializeManagers();
		initializePanel();

		// tasks to execute immediately on boot
		updateMarketplaceStreamerProducts();
		updateMarketplaceEbsProducts();
		ensureValidTwitchOAuthToken();

		// trigger some other updates that need to be triggered when booting up the plugin
		// when someone is already logged in and e.g. disabling and enabling the plugin
		skillStateManager.updateSkills();
		syncPlayerInfo();

		// setup listeners, NOTE: do this last once all manager are initialized
		hooks.registerRenderableDrawListener(drawListener);

		log.info("Twitch Live Loadout has started!");
	}

	private void initializeDistinctiveWorldTypes()
	{
		distinctiveWorldTypes.add(WorldType.BETA_WORLD);
		distinctiveWorldTypes.add(WorldType.SEASONAL);
		distinctiveWorldTypes.add(WorldType.DEADMAN);
		distinctiveWorldTypes.add(WorldType.FRESH_START_WORLD);
		distinctiveWorldTypes.add(WorldType.TOURNAMENT_WORLD);
		distinctiveWorldTypes.add(WorldType.QUEST_SPEEDRUNNING);
		distinctiveWorldTypes.add(WorldType.PVP_ARENA);
	}

	private void initializeExecutors()
	{
		try {
			scheduledExecutor = new ScheduledThreadPoolExecutor(1);
		} catch (Exception exception) {
			log.warn("An error occurred when initializing the executors: ", exception);
		}
	}

	private void initializeTwitch()
	{
		try {
			twitchApi = new TwitchApi(this, client, config, chatMessageManager, httpClient, configManager);
			twitchEventSubListener = new TwitchEventSubListener(this, config, twitchApi, gson);
			twitchEventSubClient = new TwitchEventSubClient(this, config, twitchApi, gson, httpClient, twitchEventSubListener);
			twitchState = new TwitchState(this, config, twitchEventSubClient, canvasListener, gson);
		} catch (Exception exception) {
			log.warn("An error occurred when initializing Twitch: ", exception);
		}
	}

	private void initializeManagers()
	{
		try {
			fightStateManager = new FightStateManager(this, config, client);
			itemStateManager = new ItemStateManager(this, twitchState, client, itemManager, config);
			skillStateManager = new SkillStateManager(twitchState, client);
			collectionLogManager = new CollectionLogManager(this, twitchState, client);
			marketplaceManager = new MarketplaceManager(this, twitchApi, twitchState, client, config, chatMessageManager, itemManager, overlayManager, gson, fightStateManager);
			minimapManager = new MinimapManager(this, twitchState, client);
			invocationsManager = new InvocationsManager(this, twitchState, client);
			questManager = new QuestManager(this, twitchState, client);
			combatAchievementsManager = new CombatAchievementsManager(this, twitchState, client);
			seasonalManager = new SeasonalManager(this, twitchState, client, gson);
		} catch (Exception exception) {
			log.warn("An error occurred when initializing the managers: ", exception);
		}
	}

	private void initializePanel()
	{
		try {
			pluginPanel = new TwitchLiveLoadoutPanel(this, twitchApi, twitchEventSubClient, twitchState, fightStateManager, marketplaceManager, canvasListener, config, gson);
			pluginPanel.rebuild();

			final BufferedImage icon = ImageUtil.loadImageResource(getClass(), ICON_FILE);

			navigationButton = NavigationButton.builder()
					.tooltip("Twitch Live Loadout Status")
					.icon(icon)
					.priority(99)
					.panel(pluginPanel)
					.build();

			clientToolbar.addNavigation(navigationButton);
		} catch (Exception exception) {
			log.warn("An error occurred when initializing the UI panels: ", exception);
		}
	}

	private void initializeCanvasListeners()
	{
		try {
			canvasListener = new CanvasListener(config);
		} catch (Exception exception) {
			log.warn("An error occurred when initializing the canvas listeners: ", exception);
		}
	}

	/**
	 * Cleanup properly after disabling the plugin
	 */
	@Override
	protected void shutDown() throws Exception
	{
		super.shutDown();

		// unregister all hooks, NOTE: first to make sure other manager can be shutdown as well
		hooks.unregisterRenderableDrawListener(drawListener);

		shutDownPanels();
		shutDownManagers();
		shutDownTwitch();
		shutDownCanvasListeners();
		shutDownSchedulers();
		log.info("Twitch Live Loadout has stopped!");
	}

	private void shutDownCanvasListeners()
	{
		try {
			client.getCanvas().removeFocusListener(canvasListener);
		} catch (Exception exception) {
			log.warn("An error occurred when removing the canvas listeners: ", exception);
		}
	}

	private void shutDownTwitch()
	{
		try {
			// only the API requires dedicated shutdown
			twitchApi.shutDown();
		} catch (Exception exception) {
			log.warn("An error occurred when shutting down Twitch: ", exception);
		}
	}

	private void shutDownManagers()
	{
		try {
			// Only some managers require a shutdown as well
			fightStateManager.shutDown();
			marketplaceManager.shutDown();
		} catch (Exception exception) {
			log.warn("An error occurred when shutting down the managers: ", exception);
		}
	}

	private void shutDownPanels()
	{
		try {
			clientToolbar.removeNavigation(navigationButton);
		} catch (Exception exception) {
			log.warn("An error occurred when shutting down the UI panels: ", exception);
		}
	}

	private void shutDownSchedulers()
	{
		scheduledExecutor.getQueue().clear();
		scheduledExecutor.shutdown();
	}

	/**
	 * Polling mechanism to update the state only when it has changed.
	 */
	@Schedule(period = 500, unit = ChronoUnit.MILLIS, asynchronous = false)
	public void syncState()
	{
		try {

			// guard: check if enough time has passed and other conditions are valid
			if (!twitchApi.canScheduleState())
			{
				return;
			}

			final JsonObject filteredState = twitchState.getFilteredState();
			final String filteredStateString = filteredState.toString();
			final String newFilteredStateString = twitchState.getFilteredState().toString();

			// we will not verify whether the set was successful here
			// because it is possible that the request is being delayed
			// due to the custom streamer delay
			// also, it is safe to schedule this on the client thread, because
			// the actual request is done on another thread!
			twitchApi.scheduleBroadcasterState(filteredState);

			// guard: check if the state has changed in the mean time,
			// because the request takes some time, in this case we will
			// not acknowledge the change
			if (!filteredStateString.equals(newFilteredStateString))
			{
				return;
			}

			// when all is scheduled and there are no in-between changes we can move
			// to the next state slice
			twitchState.nextCyclicState();
		} catch (Exception exception) {
			logSupport("Could not sync the current state to Twitch due to the following error: ", exception);
		}
	}

	/**
	 * Polling mechanism to update the fight statistics as many
	 * events are continuously updating various properties (e.g. game ticks).
	 * This would overload the update life cycle too much so a
	 * small penalty in the form of the (polling) delay is worthwhile.
	 */
	@Schedule(period = 2, unit = ChronoUnit.SECONDS, asynchronous = true)
	public void syncFightStatisticsState()
	{
		try {
			if (shouldTrackFightStatistics())
			{
				JsonObject fightStatistics = fightStateManager.getFightStatisticsState();
				twitchState.setFightStatistics(fightStatistics);
			}
		} catch (Exception exception) {
			logSupport("Could not update the fight statistics due to the following error: ", exception);
		}
	}

	/**
	 * Polling mechanism to update the quests list
	 */
	@Schedule(period = 30, unit = ChronoUnit.SECONDS, asynchronous = true)
	public void updateQuests()
	{
		try {
			if (config.questsEnabled())
			{
				runOnClientThread(() -> questManager.updateQuests());
			}
		} catch (Exception exception) {
			logSupport("Could not sync quests due to the following error: ", exception);
		}
	}

	/**
	 * Polling mechanism to sync player info.
	 * We cannot use the game state update events as the player name is not loaded then.
	 */
	@Schedule(period = 1, unit = ChronoUnit.SECONDS, asynchronous = false)
	public void syncPlayerInfo()
	{
		try {
			// account type can only be fetched on client thread
			runOnClientThread(() -> {
				String accountIdentifier = getAccountIdentifier();
				long accountHash = client.getAccountHash();
				AccountType accountType = getAccountType();
				String playerName = getPlayerName();

				// only handle on account change
				if (!accountIdentifier.isEmpty() && !accountIdentifier.equals(lastAccountIdentifier))
				{
					if (config.playerInfoEnabled())
					{
						twitchState.setPlayerName(playerName);
					}

					twitchState.onAccountChanged();
					seasonalManager.onAccountChanged();
					lastAccountIdentifier = accountIdentifier;
				}

				if (isLoggedIn())
				{
					int regionId = WorldPoint.fromLocalInstance(client, client.getLocalPlayer().getLocalLocation()).getRegionID();
					twitchState.setRegionId(regionId);

					// update state at the marketplace manager as well that should be accessible to products
					marketplaceManager.setCurrentRegionId(regionId);
				}

				// update this information periodically because it is possible the plugin
				// is being installed or activated after e.g. the AccountHashChanged event fires
				twitchState.setAccountHash(accountHash);
				twitchState.setAccountType(accountType);

			});
		} catch (Exception exception) {
			logSupport("Could not sync player info to state due to the following error: ", exception);
		}
	}

	/**
	 * Polling mechanism to sync minimap as there is no update event for this.
	 */
	@Schedule(period = 2, unit = ChronoUnit.SECONDS, asynchronous = true)
	public void syncMiniMap()
	{
		try {
			if (ENABLE_MINIMAP && config.marketplaceEnabled())
			{
				minimapManager.updateMinimap();
			}
		} catch (Exception exception) {
			logSupport("Could not sync mini map: ", exception);
		}
	}

	/**
	 * Polling mechanism to update the configuration segment cache
	 * Note that this request is subject to rate limits by twitch of 20 times per minute.
	 * We keep it at a safe rate to also support the fetching when someone is alting.
	 * Documentation: https://dev.twitch.tv/docs/api/reference#get-extension-configuration-segment
	 */
	@Schedule(period = 10, unit = ChronoUnit.SECONDS, asynchronous = true)
	public void updateMarketplaceStreamerProducts()
	{
		try {
			if (config.syncEnabled())
			{
				twitchApi.fetchAsyncConfigurationSegment(TwitchSegmentType.BROADCASTER);
			}
			if (config.marketplaceEnabled())
			{
				// streamer products are based on the broadcaster configuration segment
				// making it dependant on the updating of the configuration segments
				marketplaceManager.updateStreamerProducts();
			}
		} catch (Exception exception) {
			logSupport("Could not update the configuration segments due to the following error: ", exception);
		}
	}

	/**
	 * Polling mechanism to update the EBS products configured in Twitch.
	 */
	@Schedule(period = (IN_DEVELOPMENT ? 1 : 60 * 5), unit = ChronoUnit.SECONDS, asynchronous = true)
	public void updateMarketplaceEbsProducts()
	{
		try {
			if (config.marketplaceEnabled())
			{
				// update the EBS products
				marketplaceManager.updateAsyncEbsProducts();
			}
		} catch (Exception exception) {
			logSupport("Could not update the EBS products due to the following error: ", exception);
		}
	}

	/**
	 * Polling mechanism to update the channel point rewards configured in Twitch.
	 */
	@Schedule(period = (IN_DEVELOPMENT ? 5 : 20), unit = ChronoUnit.SECONDS, asynchronous = true)
	public void updateChannelPointRewards()
	{
		try {
			if (config.marketplaceEnabled() && !config.twitchOAuthAccessToken().isEmpty())
			{
				marketplaceManager.updateAsyncChannelPointRewards();
			}
		} catch (Exception exception) {
			logSupport("Could not update the channel point rewards due to the following error: ", exception);
		}
	}

	/**
	 * Polling mechanism to get new Twitch transactions
	 */
	@Schedule(period = 3, unit = ChronoUnit.SECONDS, asynchronous = false)
	public void fetchMarketplaceTransactions()
	{
		try {
			if (config.marketplaceEnabled())
			{
				// get new transactions from Twitch
				marketplaceManager.fetchAsyncNewEbsTransactions();
			}
		} catch (Exception exception) {
			logSupport("Could not update the extension transactions due to the following error: ", exception);
		}
	}

	/**
	 * Polling mechanism to manage activation and de-activation of products
	 */
	@Schedule(period = 1, unit = ChronoUnit.SECONDS, asynchronous = false)
	public void applyMarketplaceTransactions()
	{
		try {
			if (config.marketplaceEnabled())
			{
				runOnClientThread(() -> {
					marketplaceManager.handleQueuedTransactions();
					marketplaceManager.cleanExpiredProducts();
				});
			}
		} catch (Exception exception) {
			logSupport("Could not apply and clean the extension transactions: ", exception);
		}
	}

	/**
	 * Polling mechanism to check whether we are in ToA
	 */
	@Schedule(period = 5, unit = ChronoUnit.SECONDS, asynchronous = true)
	public void checkIfInToA()
	{
		try {
			if (config.invocationsEnabled() && config.autoDetectInToaRaidEnabled())
			{
				invocationsManager.checkIfInToA();
			}
		} catch (Exception exception) {
			logSupport("Could not check if in ToA: ", exception);
		}
	}

	/**
	 * Polling mechanism to trigger automated end-to-end tests for the marketplace products
	 */
	@Schedule(period = 1, unit = ChronoUnit.SECONDS, asynchronous = true)
	public void testMarketplaceProducts()
	{
		try {
			if (IN_DEVELOPMENT && config.testRandomEventsEnabled())
			{
				marketplaceManager.testNextEbsProduct();
			}
		} catch (Exception exception) {
			logSupport("Could not test marketplace products: ", exception);
		}
	}

	/**
	 * Simulate game ticks when not logged in to still register for idling fight time when not logged in
	 */
	@Schedule(period = 600, unit = ChronoUnit.MILLIS, asynchronous = true)
	public void onLobbyGameTick()
	{
		try {
			if (client.getGameState() != GameState.LOGIN_SCREEN)
			{
				return;
			}

			if (shouldTrackFightStatistics())
			{
				fightStateManager.onGameTick();
			}
		} catch (Exception exception) {
			logSupport("Could not handle lobby game tick event: ", exception);
		}
	}

	/**
	 * Periodically check whether we are still connected to the Twitch EventSub API.
	 */
	@Schedule(period = 30, unit = ChronoUnit.SECONDS, asynchronous = true)
	public void checkTwitchEventSubConnection()
	{
		try {
			if (twitchEventSubClient == null) {
				return;
			}

			if (!twitchEventSubClient.isConnected()) {
				twitchEventSubClient.reconnect(TwitchEventSubClient.DEFAULT_TWITCH_WEBSOCKET_URL);
			}
		} catch (Exception exception) {
			log.warn("Could not check the Twitch Event Sub client connection: ", exception);
		}
	}

	/**
	 * Periodically check whether we should refresh the Twitch OAuth token
	 */
	@Schedule(period = TRIGGER_OAUTH_REFRESH_TOKEN_TIME_S / 2, unit = ChronoUnit.SECONDS, asynchronous = true)
	public void ensureValidTwitchOAuthToken()
	{
		try {
			twitchApi.ensureValidOAuthToken();
		} catch (Exception exception) {
			log.warn("Could not ensure we have a valid Twitch OAUth token: ", exception);
		}
	}

	@Subscribe
	public void onItemContainerChanged(ItemContainerChanged event)
	{
		try {
			itemStateManager.onItemContainerChanged(event);
		} catch (Exception exception) {
			log.warn("Could not handle item container change event: ", exception);
		}
	}

	@Subscribe
	public void onStatChanged(StatChanged event)
	{
		try {
			if (config.skillsEnabled())
			{
				skillStateManager.updateSkills();
			}

			if (shouldTrackFightStatistics())
			{
				fightStateManager.onStatChanged(event);
			}
		} catch (Exception exception) {
			log.warn("Could not handle stat change event: ", exception);
		}
	}

	@Subscribe
	public void onFakeXpDrop(FakeXpDrop event)
	{
		try {
			if (shouldTrackFightStatistics())
			{
				fightStateManager.onFakeXpDrop(event);
			}
		} catch (Exception exception) {
			log.warn("Could not handle fake XP drop event: ", exception);
		}
	}

	//@Subscribe
	public void onNpcLootReceived(NpcLootReceived event)
	{
		try {
			if (config.collectionLogEnabled())
			{
				collectionLogManager.onNpcLootReceived(event);
			}
		} catch (Exception exception) {
			log.warn("Could not handle on NPC loot received event: ", exception);
		}
	}

	@Subscribe
	public void onFocusChanged(FocusChanged event)
	{
		try {
			final boolean isFocused = event.isFocused();

			if (isFocused)
			{
				canvasListener.enableFocus();
			}
			else {
				canvasListener.disableFocus();
			}
		} catch (Exception exception) {
			log.warn("Could not handle on focus change event: ", exception);
		}
	}

	@Subscribe
	public void onMenuOptionClicked(MenuOptionClicked event)
	{
		try {
			// alternative method to enable focus on window if somehow the other focus listener
			// any menu click will enable focus, this includes walking and stuff
			canvasListener.enableFocus();

			if (config.marketplaceEnabled())
			{
				marketplaceManager.onMenuOptionClicked(event);
			}
		} catch (Exception exception) {
			log.warn("Could not handle menu option clicked event: ", exception);
		}
	}

	private boolean shouldDraw(Renderable renderable, boolean drawingUI)
	{
		// guard: ensure the marketplace manager is initialized
		// this should usually not be needed due to the hooks being initialized and shutdown
		// correctly in the life cycle of the plugin
		if (marketplaceManager == null)
		{
			return true;
		}

		return marketplaceManager.shouldDraw(renderable, drawingUI);
	}

	@Subscribe
	public void onAnimationChanged(AnimationChanged event)
	{
		try {
			if (shouldTrackFightStatistics())
			{
				fightStateManager.onAnimationChanged(event);
			}
		} catch (Exception exception) {
			log.warn("Could not handle animation change event: ", exception);
		}
	}

	@Subscribe
	public void onGraphicChanged(GraphicChanged event)
	{
		try {
			if (shouldTrackFightStatistics())
			{
				fightStateManager.onGraphicChanged(event);
			}
		} catch (Exception exception) {
			log.warn("Could not handle graphic change event: ", exception);
		}
	}

	@Subscribe
	public void onHitsplatApplied(HitsplatApplied event)
	{
		try {
			if (shouldTrackFightStatistics())
			{
				fightStateManager.onHitsplatApplied(event);
			}
		} catch (Exception exception) {
			log.warn("Could not handle hitsplat event: ", exception);
		}
	}

	@Subscribe
	public void onNpcDespawned(NpcDespawned npcDespawned)
	{
		try {
			if (shouldTrackFightStatistics())
			{
				fightStateManager.onNpcDespawned(npcDespawned);
			}
		} catch (Exception exception) {
			log.warn("Could not handle NPC despawned event: ", exception);
		}
	}

	@Subscribe
	public void onPlayerDespawned(PlayerDespawned playerDespawned)
	{
		try {
			if (shouldTrackFightStatistics())
			{
				fightStateManager.onPlayerDespawned(playerDespawned);
			}
		} catch (Exception exception) {
			log.warn("Could not handle player despawned event: ", exception);
		}
	}

	@Subscribe
	public void onInteractingChanged(InteractingChanged interactingChanged)
	{
		try {
			if (shouldTrackFightStatistics())
			{
				fightStateManager.onInteractingChanged(interactingChanged);
			}
		} catch (Exception exception) {
			log.warn("Could not handle interacting change event: ", exception);
		}
	}

	@Subscribe
	public void onGameTick(GameTick tick)
	{
		try {
			if (config.marketplaceEnabled())
			{
				marketplaceManager.onGameTick();
			}

			if (shouldTrackFightStatistics())
			{
				fightStateManager.onGameTick();
			}

			pluginPanel.onGameTick();
		} catch (Exception exception) {
			logSupport("Could not handle game tick event: ", exception);
		}
	}

	@Subscribe
	public void onClientTick(ClientTick tick)
	{
		try {
			if (config.marketplaceEnabled())
			{
				marketplaceManager.onClientTick();
			}
		} catch (Exception exception) {
			logSupport("Could not handle client tick event: ", exception);
		}
	}

	@Subscribe
	public void onGameStateChanged(GameStateChanged gameStateChanged)
	{
		try {
			if (config.marketplaceEnabled())
			{
				marketplaceManager.onGameStateChanged(gameStateChanged);
			}

			// always update on game state change as well to instantly react to logout and login
			twitchState.setAccountHash(client.getAccountHash());
			twitchState.setAccountType(getAccountType());

			// update quests when logged in
			if (gameStateChanged.getGameState() == GameState.LOGGED_IN)
			{
				updateQuests();
			}
		} catch (Exception exception) {
			log.warn("Could not handle game state event: ", exception);
		}
	}

	/**
	 * Handle account hash changes alongside the polling done for this as well
	 */
	@Subscribe
	public void onAccountHashChanged(AccountHashChanged accountHashChanged)
	{
		try {
			twitchState.setAccountHash(client.getAccountHash());
		} catch (Exception exception) {
			log.warn("Could not handle account hash event: ", exception);
		}
	}

	/**
	 * Handle player changes
	 */
	@Subscribe
	public void onPlayerChanged(PlayerChanged playerChanged)
	{
		try {
			if (config.marketplaceEnabled())
			{
				marketplaceManager.onPlayerChanged(playerChanged);
			}
		} catch (Exception exception) {
			log.warn("Could not handle player changed event: ", exception);
		}
	}

	@Subscribe
	public void onScriptPostFired(ScriptPostFired scriptPostFired)
	{
		try {
			if (config.collectionLogEnabled())
			{
				collectionLogManager.onScriptPostFired(scriptPostFired);
			}

			if (config.seasonalsEnabled() && isSeasonal())
			{
				seasonalManager.onScriptPostFired(scriptPostFired);
			}

			if (config.invocationsEnabled())
			{
				invocationsManager.onScriptPostFired(scriptPostFired);
			}

			if (config.combatAchievementsEnabled())
			{
				combatAchievementsManager.onScriptPostFired(scriptPostFired);
			}
		} catch (Exception exception) {
			logSupport("Could not handle script post fired event:", exception);
		}
	}

	@Subscribe
	public void onVarbitChanged(VarbitChanged event)
	{
		try {
			if (config.collectionLogEnabled())
			{
				collectionLogManager.onVarbitChanged(event);
			}
			if (config.fightStatisticsEnabled() || config.marketplaceEnabled())
			{
				// also handle when marketplace is enabled as some random events
				// might have dependencies on updated attack styles
				fightStateManager.onVarbitChanged(event);
			}
		} catch (Exception exception) {
			logSupport("Could not handle varbit change event: ", exception);
		}
	}

	@Subscribe
	public void onConfigChanged(ConfigChanged configChanged)
	{

		// guard: only handle config updates of the plugin itself
		if (!configChanged.getGroup().equals(TwitchLiveLoadoutConfig.PLUGIN_CONFIG_GROUP))
		{
			return;
		}

		try {
			String key = configChanged.getKey();

			// Handle keys that should trigger an update of the state as well.
			// Note that on load these events are not triggered, meaning that
			// in the constructor of the TwitchState class one should also load
			// this configuration value!
			switch (key) {

				// Always clear the scheduled state updates
				// when either the value is increased of decreased
				// it can mess up the state updates badly
				case "syncDelay":
					twitchApi.clearScheduledBroadcasterStates();
					break;
				case "overlayTopPosition":
					twitchState.setOverlayTopPosition(config.overlayTopPosition());
					break;
				case "virtualLevelsEnabled":
					twitchState.setVirtualLevelsEnabled(config.virtualLevelsEnabled());
					break;
				case "twitchTheme":
					twitchState.setTwitchTheme(config.twitchTheme());
					break;
				case "twitchVisibility":
					twitchState.setTwitchVisibility(config.twitchVisibility());
					break;
				case "marketplaceEnabled":
					pluginPanel.getMarketplacePanel().updateTexts();

					// if it is being disabled immediately remove all active products and effects
					// this is the most reliable to properly remove everything because ticks are based on this settting
					if (!config.marketplaceEnabled())
					{
						marketplaceManager.disable();
					}
					break;
				case "manualMarketplaceProductsEnabled":
					pluginPanel.getMarketplacePanel().updateLayout();
					break;
				case "twitchOAuthAccessToken":
				case "twitchOAuthRefreshToken":
					twitchEventSubClient.reconnect(TwitchEventSubClient.DEFAULT_TWITCH_WEBSOCKET_URL);
					break;
			}

			// somehow when in the settings tab the focus is lost, which means
			// that when changing configs the focus stays lost and it hard to get feedback
			// whether a setting is changed correctly. By overriding the focus flag when
			// changing configs the data is being synced anyways.
			canvasListener.enableFocus();
		} catch (Exception exception) {
			log.warn("Could not handle config change event: ", exception);
		}
	}

	@Subscribe
	public void onMenuOpened(MenuOpened event)
	{
		try {
			marketplaceManager.onMenuOpened(event);
		} catch (Exception exception) {
			logSupport("Could not menu opened event: ", exception);
		}
	}


//	@Subscribe
//	public void onProjectileMoved(ProjectileMoved projectileMoved)
//	{
//		Projectile projectile = projectileMoved.getProjectile();
//		log.info("----- NEW PROJECTILE -----");
//		log.info("getId: "+ projectile.getId());
//		log.info("getFloor: "+ projectile.getFloor());
//		log.info("getX1: "+ projectile.getAnimation());
//		log.info("getY1: "+ projectile.getY1());
//		log.info("getHeight: "+ projectile.getHeight());
//		log.info("getStartCycle: "+ projectile.getStartCycle());
//		log.info("getEndCycle: "+ projectile.getEndCycle());
//		log.info("getSlope: "+ projectile.getSlope());
//		log.info("getStartHeight: "+ projectile.getStartHeight());
//		log.info("getEndHeight: "+ projectile.getEndHeight());
//
//		int plane = client.getPlane();
//		int sceneX = client.getLocalPlayer().getLocalLocation().getSceneX();
//		int sceneY = client.getLocalPlayer().getLocalLocation().getSceneY();
//		int tileHeight = client.getTileHeights()[plane][sceneX][sceneY];
//		log.info("tileHeight: "+ tileHeight);
//		log.info("trueProjectileHeight: "+ (projectile.getHeight() - tileHeight));
//	}

	/**
	 * Periodically update the connectivity panel to show the latest status
	 */
	@Schedule(period = 2, unit = ChronoUnit.SECONDS, asynchronous = true)
	public void updateConnectivityPanel()
	{
		try {
			if (!hasValidPanels())
			{
				return;
			}

			pluginPanel.getConnectivityPanel().rebuild();
		} catch (Exception exception) {
			logSupport("Could not update the connectivity panel due to the following error: ", exception);
		}
	}

	/**
	 * Periodically update the marketplace panel to show the latest status
	 */
	@Schedule(period = 3, unit = ChronoUnit.SECONDS, asynchronous = true)
	public void updateMarketplaceActiveProductsPanel()
	{
		try {
			if (!hasValidPanels())
			{
				return;
			}

			// update periodically to update the expiry time and other texts
			// NOTE: it is important to not rebuild the whole layout because that causes
			// the scroll position in the panel to be reset
			pluginPanel.getMarketplacePanel().rebuildProductPanels();
			pluginPanel.getMarketplacePanel().updateTexts();
		} catch (Exception exception) {
			logSupport("Could not update the marketplace panel due to the following error: ", exception);
		}
	}

	public boolean hasValidPanels()
	{
		return pluginPanel != null;
	}

	public void runOnClientThread(ClientThreadAction action)
	{
		try {
			clientThread.invoke(new Runnable() {
				@Override
				public void run() {
					try {
						action.execute();
					} catch (Exception exception) {
						logSupport("Could not execute action on client thread: ", exception);
					}
				}
			});
		} catch (Exception exception) {
			logSupport("Could not invoke an action later on client thread: ", exception);
		}
	}

	public ScheduledFuture scheduleOnClientThread(ClientThreadAction action, long delayMs)
	{
		// guard: check if we should execute immediately
		if (delayMs <= 0)
		{
			try {
				runOnClientThread(action);
			} catch (Exception exception) {
				logSupport("Could not run an action on the client thread immediately: ", exception);
			}
			return null;
		}

		return scheduleOnPoolThread(() -> {
			runOnClientThread(action);
		}, delayMs);
	}

	public ScheduledFuture runOnPoolThread(ClientThreadAction action)
	{
		return scheduleOnPoolThread(action, 0);
	}

	public ScheduledFuture scheduleOnPoolThread(ClientThreadAction action, long delayMs)
	{
		try {
			return scheduledExecutor.schedule(new Runnable() {
				@Override
				public void run() {
					try {
						action.execute();
					} catch (Exception exception) {
						logSupport("Could not execute an action: ", exception);
					}
				}
			}, delayMs, TimeUnit.MILLISECONDS);
		} catch (Exception exception) {
			logSupport("Could not schedule an action (delay: "+ delayMs +"): ", exception);
		}

		return null;
	}

	public interface ClientThreadAction {
		public void execute();
	}

	public void setConfiguration(String configKey, Object payload)
	{
		try {
			String accountIdentifier = getAccountIdentifier();
			String scopedConfigKey = getScopedConfigKey(accountIdentifier, configKey);
			configManager.setConfiguration(PLUGIN_CONFIG_PROFILE_GROUP, scopedConfigKey, payload);
		} catch (Exception exception) {
			log.warn("Could not set the configuration due to the following error: ", exception);
		}
	}

	public void resetPersistentStateConfiguration()
	{
		for (String configKey : PERSISTENT_STATE_CONFIG_KEYS)
		{
			setConfiguration(configKey, "");
		}
	}

	public String getConfiguration(String configKey)
	{
		try {
			String accountIdentifier = getAccountIdentifier();
			String scopedConfigKey = getScopedConfigKey(accountIdentifier, configKey);
			String configuration = configManager.getConfiguration(PLUGIN_CONFIG_PROFILE_GROUP, scopedConfigKey);

			return configuration;
		} catch (Exception exception) {
			log.warn("Could not get the configuration due to the following error: ", exception);
		}

		return null;
	}

	public void loadFromConfiguration(String cacheKey, ConfigurationDataHandler handler)
	{
		String rawCacheData = getConfiguration(cacheKey);

		// guard: check if any data was found
		if (rawCacheData == null || rawCacheData.trim().isEmpty())
		{
			return;
		}

		try {
			handler.execute(rawCacheData);
		} catch (Exception exception) {
			log.warn("Could not handle cache data with from cache key '"+ cacheKey +"': ", exception);
		}
	}

	public interface ConfigurationDataHandler {
		void execute(String data);
	}

	/**
	 * Get the account identifier based on the account hash and whether there is a world type being used
	 * which requires the account identifier to be unique as well (in the case of a dedicated OSRS profile save).
	 */
	private String getAccountIdentifier() {
		String accountHash = Long.toString(client.getAccountHash());
		String worldTypeIdentifier = getWorldTypeIdentifier();

		return accountHash + worldTypeIdentifier;
	}

	/**
	 * Get an identifier based on in which type of world the account is logged is
	 */
	public String getWorldTypeIdentifier()
	{
		StringBuilder identifier = new StringBuilder();

		try {
			EnumSet<WorldType> worldTypes = client.getWorldType();

			for (WorldType worldType : worldTypes)
			{
				if (!distinctiveWorldTypes.contains(worldType))
				{
					continue;
				}

				identifier.append(worldType.name());
			}
		} catch (Exception error) {
			// empty
		}

		return identifier.toString();
	}

	private String getScopedConfigKey(String accountIdentifier, String configKey)
	{
		try {
			String accountIdentifierPrefix = accountIdentifier.replaceAll("\\s+","_").trim();
			String scopedConfigKey = accountIdentifierPrefix +"-"+ configKey;
			return scopedConfigKey;
		} catch (Exception exception) {
			log.warn("Could not get the scoped config key due to the following error: ", exception);
		}

		return null;
	}

	public String getPlayerName()
	{
		try {
			if (!isLoggedIn())
			{
				return null;
			}

			return client.getLocalPlayer().getName();
		} catch (Exception exception) {
			log.warn("Could not get the player name due to the following error: ", exception);
		}

		return null;
	}

	public boolean isDangerousAccountType()
	{
		JsonElement accountTypeRaw = twitchState.getState().get(TwitchStateEntry.ACCOUNT_TYPE.getKey());

		// guard: check if account type can be found
		// if not it can be due to logging in or switching accounts, to be sure we classify as dangerous
		if (accountTypeRaw == null)
		{
			// TRUE to make sure when no account type is known to disable any dangerous effects
			return true;
		}

		String accountType = accountTypeRaw.getAsString();

		if (accountType == null)
		{
			return false;
		}

		// guard: check if regular HC or HCGIM
		if (!accountType.equals(AccountType.HARDCORE_IRONMAN.getKey()) && !accountType.equals(AccountType.HARDCORE_GROUP_IRONMAN.getKey()))
		{
			return false;
		}

		return true;
	}

	public boolean shouldTrackFightStatistics()
	{
		boolean isDisabledGeneral = !config.fightStatisticsEnabled();
		boolean isDisabledDangerous = config.fightStatisticsProtectionEnabled() && isDangerousAccountType();

		return !isDisabledGeneral && !isDisabledDangerous;
	}

	public boolean canPerformDangerousEffects()
	{
		boolean isDisabledGeneral = !config.marketplaceEnabled();
		boolean isDisabledDangerous = config.marketplaceProtectionEnabled() && isDangerousAccountType();

		return !isDisabledGeneral && !isDisabledDangerous;
	}

	public boolean isLoggedIn()
	{
		return isLoggedIn(false);
	}

	public boolean isLoggedIn(boolean considerTwitchReviewMode)
	{
		final boolean forceIsLoggedIn = considerTwitchReviewMode && config.twitchReviewModeEnabled() && IN_DEVELOPMENT;

		if (forceIsLoggedIn)
		{
			return true;
		}

		try {
			JsonElement accountTypeRaw = twitchState.getState().get(TwitchStateEntry.ACCOUNT_TYPE.getKey());

			// guard: check game state
			if (client.getGameState() != GameState.LOGGED_IN)
			{
				return false;
			}

			// guard: check local player instance
			if (client.getLocalPlayer() == null)
			{
				return false;
			}

			// guard: check if account type is known
			// this ensures no marketplace things are handled until the account type is set
			// making sure that any dangerous account types are handled properly
			if (accountTypeRaw == null)
			{
				return false;
			}

			return true;
		} catch (Exception exception) {
			log.warn("Could not get the whether the player is logged in due to the following error: ", exception);
		}

		return false;
	}

	/**
	 * Get the account type enum from the varbit. Fallbacks to normal account.
	 * NOTE: can only run on client thread.
	 * @return AccountType
	 */
	public AccountType getAccountType()
	{
		try {
			// not using primitive, because it can be null while booting
			Integer accountTypeId = client.getVarbitValue(Varbits.ACCOUNT_TYPE);

			for (AccountType accountType : AccountType.values()) {
				if (accountTypeId == accountType.getId()) {
					return accountType;
				}
			}
		} catch (Exception error) {
			// empty
		}

		// IMPORTANT: return null to make sure while logging in non-normal account won't get classified as such a normal one
		return null;
	}

	public boolean isSeasonal()
	{
		try {
			return client.getWorldType().contains(WorldType.SEASONAL);
		} catch (Exception error) {
			// empty
		}

		return false;
	}

	public void logSupport(String message)
	{
		logSupport(message, null);
	}

	public void logSupport(String message, Exception exception)
	{

		// guard: skip when this type of logging is disabled
		if (!config.supportDebugEnabled())
		{
			return;
		}

		log.info("[SUPPORT] "+ message, exception);

		// add for some more extensive logging in dev
		if (IN_DEVELOPMENT && exception != null) {
			exception.printStackTrace();
		}
	}

	@Provides
	TwitchLiveLoadoutConfig provideConfig(ConfigManager configManager)
	{
		return configManager.getConfig(TwitchLiveLoadoutConfig.class);
	}
}

package com.twitchliveloadout.twitch;

import com.formdev.flatlaf.json.Json;
import com.google.gson.JsonArray;
import com.google.gson.JsonObject;
import com.google.gson.JsonParser;
import com.twitchliveloadout.TwitchLiveLoadoutConfig;
import com.twitchliveloadout.TwitchLiveLoadoutPlugin;
import javax.annotation.Nullable;

import com.twitchliveloadout.twitch.eventsub.TwitchEventSubType;
import lombok.Getter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.ChatMessageType;
import net.runelite.api.Client;
import net.runelite.api.GameState;
import net.runelite.client.chat.ChatColorType;
import net.runelite.client.chat.ChatMessageBuilder;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.chat.QueuedMessage;
import net.runelite.client.config.ConfigManager;
import okhttp3.*;

import static com.twitchliveloadout.TwitchLiveLoadoutConfig.*;
import static net.runelite.http.api.RuneLiteAPI.JSON;

import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.nio.charset.StandardCharsets;
import java.time.Instant;
import java.time.ZoneId;
import java.time.format.DateTimeFormatter;
import java.util.Base64;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ScheduledThreadPoolExecutor;
import java.util.concurrent.TimeUnit;
import java.util.zip.GZIPOutputStream;

@Slf4j
public class TwitchApi
{
	public final static int MAX_PAYLOAD_SIZE = 5120; // bytes

	// this delay supports two clients to sync fast enough while not exceeding the rate limit (1000ms)
	public final static int MIN_SCHEDULE_DEFAULT_DELAY = 1300; // ms
	public final static int MIN_SCHEDULE_LOGGED_OUT_DELAY = 6000; // ms
	public final static int MIN_SCHEDULE_GROUP_DELAY = 6000; // ms
	public final static int MAX_SCHEDULED_STATE_AMOUNT = 50;

	public final static String DEFAULT_EXTENSION_CLIENT_ID = "cuhr4y87yiqd92qebs1mlrj3z5xfp6";
	public final static String DEFAULT_TWITCH_EBS_BASE_URL = "https://liveloadout.com";
	public final static String DEFAULT_TWITCH_BASE_URL = "https://api.twitch.tv/helix/extensions";
	private final static String RATE_LIMIT_REMAINING_HEADER = "Ratelimit-Remaining";

	public final static int MIN_SYNC_DELAY = 0; // ms
	public final static int BASE_SYNC_DELAY = 1000; // ms
	public final static double LOW_RATE_LIMIT_DELAY_MULTIPLIER = 2d;
	public final static int LOW_RATE_LIMIT_REMAINING = 50;
	public final static double HIGH_RATE_LIMIT_DELAY_MULTIPLIER = 0.5d;
	public final static int HIGH_RATE_LIMIT_REMAINING = 90;

	public final static boolean NOTIFY_IN_CHAT_ENABLED = true;
	private final static int SEND_PUBSUB_TIMEOUT_MS = 10 * 1000;
	private final static int GET_CONFIGURATION_SERVICE_TIMEOUT_MS = 5 * 1000;
	private final static int GET_EBS_PRODUCTS_TIMEOUT_MS = 10 * 1000;
	private final static int GET_EBS_TRANSACTIONS_TIMEOUT_MS = 10 * 1000;
	private final static int ENSURE_OAUTH_TOKEN_TIMEOUT_MS = 10 * 1000;
	private final static int CHAT_MESSAGE_TIMEOUT_MS = 10 * 1000;

	private final static int CREATE_SUBSCRIPTION_TIMEOUT_MS = 10 * 1000;
	public final static int TRIGGER_OAUTH_REFRESH_TOKEN_TIME_S = 10 * 60; // refresh token x minutes before expiry
	private final static int ERROR_CHAT_MESSAGE_THROTTLE = 15 * 60 * 1000; // in ms
	private final static String USER_AGENT = "RuneLite";
	private final static String TWITCH_CREATE_SUBSCRIPTION_URL = "https://api.twitch.tv/helix/eventsub/subscriptions";
	public final static String TWITCH_VALIDATE_TOKEN_URL = "https://id.twitch.tv/oauth2/validate";
	public final static String TWITCH_GET_CHANNEL_POINT_REWARDS_URL = "https://api.twitch.tv/helix/channel_points/custom_rewards";
	public final static String DEFAULT_APP_CLIENT_ID = "qaljqu9cfow8biixuat6rbr303ocp2";
	public final static String DEFAULT_EXTENSION_VERSION = "2.2.0";

	/**
	 * Dedicated scheduler for sending the new state with a stream delay
	 */
	private final ScheduledThreadPoolExecutor scheduledExecutor = new ScheduledThreadPoolExecutor(1);

	/**
	 * Dedicated HTTP clients for every type of request
	 */
	private final OkHttpClient httpClientTemplate;
	private final ConfigManager configManager;
	private final OkHttpClient ebsTransactionsHttpClient;
	private final OkHttpClient configurationSegmentHttpClient;
	private final OkHttpClient pubSubHttpClient;
	final OkHttpClient ebsProductsHttpClient;

	private final OkHttpClient oAuthHttpClient;
	private final OkHttpClient chatMessageHttpClient;

	private final TwitchLiveLoadoutPlugin plugin;
	private final Client client;
	private final TwitchLiveLoadoutConfig config;
	private final ChatMessageManager chatMessageManager;
	private Instant lastScheduleStateTime = null;

	@Getter
	private String lastCompressedState = "";

	@Getter
	private int lastRateLimitRemaining = 100;

	@Getter
	private String lastResponseMessage = "Unknown status";

	@Getter
	private int lastResponseCode = 200;

	@Getter
	private long lastErrorChatMessage = 0;

	private final ConcurrentHashMap<TwitchSegmentType, JsonObject> configurationSegmentContents = new ConcurrentHashMap<>();

	public TwitchApi(TwitchLiveLoadoutPlugin plugin, Client client, TwitchLiveLoadoutConfig config, ChatMessageManager chatMessageManager, OkHttpClient httpClientTemplate, ConfigManager configManager)
	{
		this.plugin = plugin;
		this.client = client;
		this.config = config;
		this.chatMessageManager = chatMessageManager;
		this.httpClientTemplate = httpClientTemplate;
		this.configManager = configManager;

		// instantiate a HTTP client for every call with a different timeout
		ebsTransactionsHttpClient = createHttpClient(GET_EBS_TRANSACTIONS_TIMEOUT_MS);
		configurationSegmentHttpClient = createHttpClient(GET_CONFIGURATION_SERVICE_TIMEOUT_MS);
		pubSubHttpClient = createHttpClient(SEND_PUBSUB_TIMEOUT_MS);
		ebsProductsHttpClient = createHttpClient(GET_EBS_PRODUCTS_TIMEOUT_MS);
		oAuthHttpClient = createHttpClient(ENSURE_OAUTH_TOKEN_TIMEOUT_MS);
		chatMessageHttpClient = createHttpClient(CHAT_MESSAGE_TIMEOUT_MS);
	}

	public void shutDown()
	{
		clearScheduledBroadcasterStates();
		scheduledExecutor.shutdown();
	}

	public void scheduleBroadcasterState(final JsonObject state)
	{
		int delay = config.syncDelay() * 1000;

		// add the base delay, because every streamer
		// has some delay we want to take into account
		// to not show the future of the streamer too quickly
		delay += BASE_SYNC_DELAY;

		// make sure the min sync delay is set when
		// user inputs negative numbers in the config
		if (delay < MIN_SYNC_DELAY)
		{
			delay = MIN_SYNC_DELAY;
		}

		// schedule in the future, this also makes sure the HTTP requests are done on their own thread.
		scheduledExecutor.schedule(new Runnable()
		{
			public void run()
			{
				try {
					sendAsyncPubSubState(state);
				} catch (Exception exception) {
					plugin.logSupport("Could not send the pub sub state due to the following error: ", exception);
				}
			}
		}, delay, TimeUnit.MILLISECONDS);

		lastScheduleStateTime = Instant.now();
	}

	public boolean canScheduleState()
	{

		// guard: if the scheduler is shutdown block all future requests
		if (scheduledExecutor.isShutdown())
		{
			return false;
		}

		// guard: check if the queue is too large
		if (scheduledExecutor.getQueue().size() >= MAX_SCHEDULED_STATE_AMOUNT)
		{
			return false;
		}

		// guard: when state is never send it is allowed
		if (lastScheduleStateTime == null)
		{
			return true;
		}

		boolean isLoggedIn = plugin.isLoggedIn(true);
		Instant now = Instant.now();
		int delayMs = isLoggedIn ? MIN_SCHEDULE_DEFAULT_DELAY : MIN_SCHEDULE_LOGGED_OUT_DELAY;

		// multiply the delay time if the rate limit is decreasing too fast
		// this can be the case with many accounts logged in
		if (lastRateLimitRemaining < LOW_RATE_LIMIT_REMAINING)
		{
			delayMs *= LOW_RATE_LIMIT_DELAY_MULTIPLIER;
		}

		// decrease the delay when there are enough requests available
		// this can be the case with only one RL client open
		if (lastRateLimitRemaining > HIGH_RATE_LIMIT_REMAINING)
		{
			delayMs *= HIGH_RATE_LIMIT_DELAY_MULTIPLIER;
		}

		Instant minTime = lastScheduleStateTime.plusMillis(delayMs);

		return now.isAfter(minTime);
	}

	public void clearScheduledBroadcasterStates()
	{
		scheduledExecutor.getQueue().clear();
	}

	private boolean sendAsyncPubSubState(JsonObject state)
	{
		try {
			final JsonObject data = new JsonObject();
			final JsonArray targets = new JsonArray();
			final String channelId = getChannelId();

			// guard: make sure the channel ID is valid
			if (channelId == null)
			{
				return false;
			}

			targets.add(TwitchPubSubTargetType.BROADCAST.getTarget());
			String compressedState = compressState(state);

			data.addProperty("message", compressedState);
			data.addProperty("broadcaster_id", channelId);
			data.add("target", targets);

			sendAsyncPubSubMessage(data, (Response response) -> {
				verifyStateUpdateResponse("PubSub", response, compressedState);
			}, (exception) -> {
				plugin.logSupport("Could not send pub sub state due to the following error: ", exception);
			});

			lastCompressedState = compressedState;
		} catch (Exception exception) {
			plugin.logSupport("Could not send pub sub state due to the following error: ", exception);
			return false;
		}

		return true;
	}

	private void sendAsyncPubSubMessage(JsonObject data, HttpResponseHandler responseHandler, HttpErrorHandler errorHandler)
	{
		final String url = DEFAULT_TWITCH_BASE_URL +"/pubsub";

		// Documentation: https://dev.twitch.tv/docs/extensions/reference/#send-extension-pubsub-message
		performPostRequest(url, data, pubSubHttpClient, responseHandler, errorHandler);
	}

	public void fetchAsyncEbsProducts(HttpResponseHandler responseHandler, HttpErrorHandler errorHandler)
	{
		String url = DEFAULT_TWITCH_EBS_BASE_URL +"/api/marketplace-products";
		final JsonObject data = new JsonObject();

		performPostRequest(url, data, ebsProductsHttpClient, responseHandler, errorHandler);
	}

	public void fetchAsyncEbsTransactions(String lastTransactionId, HttpResponseHandler responseHandler, HttpErrorHandler errorHandler)
	{
		String url = DEFAULT_TWITCH_EBS_BASE_URL +"/api/marketplace-transactions";
		final JsonObject data = new JsonObject();

		// only add last checked at when it is valid
		if (lastTransactionId != null)
		{
			data.addProperty("lastTransactionId", lastTransactionId);
		}

		performPostRequest(url, data, ebsTransactionsHttpClient, responseHandler, errorHandler);
	}

	public void fetchAsyncConfigurationSegment(TwitchSegmentType segmentType) throws Exception
	{
		final String clientId = DEFAULT_EXTENSION_CLIENT_ID;
		final String channelId = getChannelId();
		final String baseUrl = DEFAULT_TWITCH_BASE_URL +"/configurations";

		// guard: make sure the channel ID is valid
		if (channelId == null)
		{
			return;
		}

		final String url = baseUrl +"?broadcaster_id="+ channelId +"&extension_id="+ clientId +"&segment="+ segmentType.getKey();

		// documentation: https://dev.twitch.tv/docs/api/reference#get-extension-configuration-segment
		performGetRequest(url, configurationSegmentHttpClient, (Response response) -> {

			// there is a fair chance the configuration segment is empty when nothing is configured yet
			// for this reason we silently ignore the error
			try {
				String rawSegmentResult = response.body().string();
				JsonObject segmentResult = parseJson(rawSegmentResult);
				String rawSegmentContent = segmentResult
					.getAsJsonArray("data")
					.get(0)
					.getAsJsonObject()
					.get("content")
					.getAsString();
				JsonObject segmentContent = parseJson(rawSegmentContent);

				// cache the response if valid
				configurationSegmentContents.put(segmentType, segmentContent);
			} catch (Exception exception) {
				// empty
			}
		}, (exception) -> {
			// empty
		});
	}

	public void fetchAsyncChannelPointRewards(HttpResponseHandler responseHandler, HttpErrorHandler errorHandler)
	{
		String token = config.twitchOAuthAccessToken();
		String channelId = getChannelId();

		// guard: make sure the authentication is valid
		if (channelId == null || token == null || token.isEmpty())
		{
			return;
		}

		final String url = TWITCH_GET_CHANNEL_POINT_REWARDS_URL +"?broadcaster_id="+ channelId;

		final Request request = new Request.Builder()
			.header("Client-ID", DEFAULT_APP_CLIENT_ID)
			.header("Authorization", "Bearer "+ token)
			.header("User-Agent", USER_AGENT)
			.header("Content-Type", "application/json")
			.get()
			.url(url)
			.build();

		performRequest(request, oAuthHttpClient, responseHandler, errorHandler);
	}

	public void sendChatMessage(String message)
	{
		String channelId = getChannelId();

		final String url = DEFAULT_TWITCH_BASE_URL +"/chat?broadcaster_id="+ channelId;
		final JsonObject data = new JsonObject();

		// add the required data, reference: https://dev.twitch.tv/docs/api/reference/#send-extension-chat-message
		data.addProperty("text", message);
		data.addProperty("extension_id", DEFAULT_EXTENSION_CLIENT_ID);
		data.addProperty("extension_version", DEFAULT_EXTENSION_VERSION);

		performPostRequest(
			url,
			data,
			chatMessageHttpClient,
			(response) -> {
				final int responseCode = response.code();

				if (responseCode != 204)
				{
					plugin.logSupport("Could not send notification to the Twitch chat (message: "+ message +") due to an error with code: "+ responseCode);
				}
			},
			(error) -> {
				plugin.logSupport("Could not send notification to the Twitch chat due to an error: "+ message, error);
			}
		);
	}

	private void verifyStateUpdateResponse(String type, Response response, String compressedState) throws Exception
	{
		final int responseCode = response.code();
		final String responseText = response.body().string();
		final int compressesStateSize = compressedState.getBytes("UTF-8").length;
		final long now = Instant.now().getEpochSecond();
		final DateTimeFormatter dateFormatter = DateTimeFormatter.ofPattern("HH:mm:ss");
		final String nowFormatted = Instant.ofEpochSecond(now).atZone(ZoneId.systemDefault()).format(dateFormatter);
		final long errorChatMessageDeltaTime = now - lastErrorChatMessage;
		final boolean isLoggedIn = client.getGameState() == GameState.LOGGED_IN;
		final boolean canSendErrorChatMessage = errorChatMessageDeltaTime > ERROR_CHAT_MESSAGE_THROTTLE;
		String responseCodeMessage = "An unknown error occurred. Please report this to the RuneLite plugin maintainer.";

		// handle specific errors
		switch (responseCode)
		{
			case 403: // forbidden
			case 401: // unauthorized
				responseCodeMessage = "Twitch Extension Token is expired. Get a new token via the Twitch extension configuration and copy it to the RuneLite plugin settings.";
				break;
			case 400: // bad request
			case 404: // not found
				responseCodeMessage = "Something has changed with Twitch. Please report this to the RuneLite plugin maintainer.";
				break;
		}

		// set default success message
		if (!isErrorResponseCode(responseCode))
		{
			responseCodeMessage = "The latest information is successfully synced to Twitch.";
		}

		// append the time
		responseCodeMessage += " The time of this message was: "+ nowFormatted;

		response.close();
		lastResponseMessage = responseCodeMessage;
		lastResponseCode = responseCode;
		lastRateLimitRemaining = Integer.parseInt(response.header(RATE_LIMIT_REMAINING_HEADER, "100"));

		if (isErrorResponseCode(responseCode))
		{
			log.debug("Could not update state via {}, http code was: {}", type, responseCode);
			log.debug("The state was ({} bytes compressed): ", compressesStateSize);
			log.debug("The response body was {}", responseText);

			// Only send a chat message when the token is not set or expired as other errors
			// also occur due to reliability of the Twitch servers (e.g. random 500's in between).
			// Normally they are good again for the next request.
			if (isAuthErrorResponseCode(responseCode) && NOTIFY_IN_CHAT_ENABLED && isLoggedIn && canSendErrorChatMessage) {
				final ChatMessageBuilder message = new ChatMessageBuilder()
					.append(ChatColorType.HIGHLIGHT)
					.append("Could not synchronize loadout to Twitch " + type + " (code: " + responseCode + "). ")
					.append(responseCodeMessage)
					.append(ChatColorType.NORMAL);

				chatMessageManager.queue(QueuedMessage.builder()
					.type(ChatMessageType.ITEM_EXAMINE)
					.runeLiteFormattedMessage(message.build())
					.build());
				lastErrorChatMessage = now;
			}

			throw new Exception("Could not set the Twitch PubSub State due to invalid response code: "+ responseCode);
		}

		log.debug("Successfully sent state with response code: {}", responseCode);
	}

	public void ensureValidOAuthToken()
	{
		final String accessToken = config.twitchOAuthAccessToken();
		final String refreshToken = config.twitchOAuthRefreshToken();

		// guard: skip this then there is no token set
		if (accessToken.isEmpty() || refreshToken.isEmpty())
		{
			return;
		}

		final Request validateRequest = new Request.Builder()
			.header("Authorization", "OAuth "+ accessToken)
			.header("User-Agent", USER_AGENT)
			.header("Content-Type", "application/json")
			.get()
			.url(TWITCH_VALIDATE_TOKEN_URL)
			.build();

		performRequest(
			validateRequest,
			oAuthHttpClient,
			(response) -> {
				int responseCode = response.code();

				// guard: skip when no valid body
				if (response.body() == null)
				{
					return;
				}

				// guard: when unauthorized the token is already expired!
				if (responseCode == 401)
				{
					plugin.logSupport("Twitch OAuth access token is already expired. Refreshing...");
					refreshOAuthToken();
					return;
				}

				JsonObject payload = parseJson(response.body().string());
				int expiresInS = payload.get("expires_in").getAsInt();
				boolean needsRefresh = expiresInS < TRIGGER_OAUTH_REFRESH_TOKEN_TIME_S;

				if (needsRefresh)
				{
					plugin.logSupport("Twitch OAuth access token almost expires in "+ expiresInS +" seconds. Refreshing...");
					refreshOAuthToken();
				}
			},
			(exception) -> {
				log.warn("Could not check whether the Twitch OAuth token is valid: ", exception);
			}
		);
	}

	private void refreshOAuthToken()
	{
		final String refreshToken = config.twitchOAuthRefreshToken();
		String url = DEFAULT_TWITCH_EBS_BASE_URL + "/api/refresh-oauth-token";

		// guard: check if the refresh token is valid
		if (refreshToken.isEmpty())
		{
			plugin.logSupport("Will not refresh the Twitch OAuth token because the refresh token is empty.");
			return;
		}

		final JsonObject data = new JsonObject();
		data.addProperty("refreshToken", refreshToken);

		final Request refreshRequest = new Request.Builder()
			.header("User-Agent", USER_AGENT)
			.header("Content-Type", "application/json")
			.post(RequestBody.create(JSON, data.toString()))
			.url(url)
			.build();

		plugin.logSupport("Attempting to refresh the Twitch OAuth token...");

		performRequest(
			refreshRequest,
				oAuthHttpClient,
			(response) -> {
				int responseCode = response.code();

				// guard: skip when no valid body
				if (response.body() == null)
				{
					plugin.logSupport("Could not refresh the Twitch OAuth token due to no body for response code: "+ responseCode);
					return;
				}

				String rawPayload = response.body().string();

				// guard: when unauthorized the token is already expired!
				if (responseCode != 200)
				{
					plugin.logSupport("Could not refresh the Twitch OAuth token due to unexpected response code: "+ responseCode);
					return;
				}

				JsonObject payload = parseJson(rawPayload);
				String newAccessToken = payload.get("access_token").getAsString();
				String newRefreshToken = payload.get("refresh_token").getAsString();

				// guard: make sure the new tokens are valid
				if (newAccessToken == null || newRefreshToken == null || newAccessToken.isEmpty() || newRefreshToken.isEmpty())
				{
					plugin.logSupport("The Twitch OAuth token could not be refreshed as it turns out to be empty.");
					return;
				}

				// when all is valid update the config in the plugin panel
				configManager.setConfiguration(config.PLUGIN_CONFIG_GROUP, TWITCH_OAUTH_ACCESS_TOKEN_KEY, newAccessToken);
				configManager.setConfiguration(config.PLUGIN_CONFIG_GROUP, TWITCH_OAUTH_REFRESH_TOKEN_KEY, newRefreshToken);
				plugin.logSupport("The Twitch OAuth tokens are successfully refreshed and stored in the config panel!");
			},
			(exception) -> {
				log.warn("Could not refresh the Twitch OAuth token: ", exception);
			}
		);
	}

	public void createEventSubSubscription(String sessionId, TwitchEventSubType subscriptionType, HttpResponseHandler onSuccess, HttpErrorHandler onError)
	{
		final String channelId = getChannelId();
		final String token = config.twitchOAuthAccessToken();
		final String type = subscriptionType.getType();
		final int version = subscriptionType.getVersion();

		// guard: check if the auth parameters are valid
		if (channelId == null || token == null) {
			return;
		}

		final JsonObject condition = new JsonObject();

		// check which conditions to add based on the type of event
		// usually we only need to add the broadcaster user ID, but there are some exceptions
		// reference: https://dev.twitch.tv/docs/eventsub/eventsub-subscription-types
		if (subscriptionType == TwitchEventSubType.EXTENSION_BITS_TRANSACTION) {

			// NOTE: this one doesn't actually work because oauth user tokens don't have access to these events...
			// maintain the code here for reference purposes
			condition.addProperty("extension_client_id", DEFAULT_EXTENSION_CLIENT_ID);
		} else if (subscriptionType == TwitchEventSubType.RAID) {
			condition.addProperty("to_broadcaster_user_id", channelId);
		} else if (subscriptionType == TwitchEventSubType.FOLLOW) {
			condition.addProperty("moderator_user_id", channelId);
			condition.addProperty("broadcaster_user_id", channelId);
		} else {
			condition.addProperty("broadcaster_user_id", channelId);
		}

		final JsonObject transport = new JsonObject();
		transport.addProperty("method", "websocket");
		transport.addProperty("session_id", sessionId);
		final JsonObject data = new JsonObject();
		data.addProperty("type", type);
		data.addProperty("version", version);
		data.add("condition", condition);
		data.add("transport", transport);

		final Request request = new Request.Builder()
			.header("Client-ID", DEFAULT_APP_CLIENT_ID)
			.header("Authorization", "Bearer "+ token)
			.header("User-Agent", USER_AGENT)
			.header("Content-Type", "application/json")
			.post(RequestBody.create(JSON, data.toString()))
			.url(TWITCH_CREATE_SUBSCRIPTION_URL)
			.build();

		oAuthHttpClient.newCall(request).enqueue(new Callback() {
			@Override
			public void onFailure(Call call, IOException exception) {
				plugin.logSupport("Could not create Twitch websocket subscription: "+ type);
				plugin.logSupport("The error that occurred was: ");
				plugin.logSupport(exception.getMessage());
				onError.execute(exception);
			}

			@Override
			public void onResponse(Call call, Response response) throws IOException {
				int responseCode = response.code();

				if (responseCode == 202) {
					plugin.logSupport("Successfully created Twitch websocket subscription for type: "+ type);
					try {
						onSuccess.execute(response);
					} catch (Exception exception) {
						onError.execute(exception);
					}
				} else {
					plugin.logSupport("Could not create Twitch websocket subscription (type: "+ type +") due to error code: "+ responseCode);
					plugin.logSupport("And response body: "+ response.body().string());
					onError.execute(new Exception("Could not create Twitch websocket subscription due to error code: "+ responseCode));
				}

				// always close the response to be sure there are no memory leaks
				response.close();
			}
		});
	}

	@Nullable
	public String getChannelId()
	{

		try {
			JsonObject decodedToken = getDecodedToken();
			return decodedToken.get("channel_id").getAsString();
		} catch (Exception exception) {
			// empty
		}

		return null;
	}

	public JsonObject getDecodedToken() throws Exception
	{
		String[] parts = splitToken(getToken());
		String payloadBase64String = parts[1];
		String payloadString = new String(Base64.getDecoder().decode(payloadBase64String), StandardCharsets.UTF_8);;
		JsonObject payload = parseJson(payloadString);

		return payload;
	}

	public JsonObject getConfigurationSegmentContent(TwitchSegmentType segmentType)
	{
		return configurationSegmentContents.get(segmentType);
	}

	private String[] splitToken(String token) throws Exception {
		String[] parts = token.split("\\.");

		if (parts.length == 2 && token.endsWith("."))
		{
			parts = new String[]{parts[0], parts[1], ""};
		}

		if (parts.length != 3)
		{
			throw new Exception(String.format("The token was expected to have 3 parts, but got %s.", parts.length));
		}

		return parts;
	}

	public String compressState(JsonObject state)
	{
		try {
			String jsonString = state.toString();
			byte[] compressedState = compress(jsonString);
			String compressedStateString = new String(Base64.getEncoder().encode(compressedState), StandardCharsets.UTF_8);

			return compressedStateString;
		} catch (Exception exception) {
			// empty?
		}

		return null;
	}

	public static byte[] compress(final String str) throws IOException
	{
		if ((str == null) || (str.length() == 0))
		{
			return null;
		}

		// Source: https://stackoverflow.com/questions/16351668/compression-and-decompression-of-string-data-in-java
		ByteArrayOutputStream obj = new ByteArrayOutputStream();
		GZIPOutputStream gzip = new GZIPOutputStream(obj);
		gzip.write(str.getBytes("UTF-8"));
		gzip.flush();
		gzip.close();
		return obj.toByteArray();
	}

	public boolean isAuthErrorResponseCode(int responseCode)
	{
		// it seems that 401 is also sometimes randomly triggered, 403 is most reliable
		return responseCode == 403;
	}

	public boolean isErrorResponseCode(int responseCode)
	{
		return responseCode > 299 || responseCode < 200;
	}

	private String getToken()
	{
		return config.twitchToken();
	}

	private JsonObject parseJson(String rawJson)
	{
		return (new JsonParser()).parse(rawJson).getAsJsonObject();
	}

	/**
	 * Perform a generic GET request to the Twitch API.
	 */
	public void performGetRequest(String url, OkHttpClient httpClient, HttpResponseHandler responseHandler, HttpErrorHandler errorHandler)
	{
		final String token = config.twitchToken();
		final Request request = new Request.Builder()
			.header("Client-ID", DEFAULT_EXTENSION_CLIENT_ID)
			.header("Authorization", "Bearer "+ token)
			.header("User-Agent", USER_AGENT)
			.header("Content-Type", "application/json")
			.get()
			.url(url)
			.build();

		performRequest(request, httpClient, responseHandler, errorHandler);
	}

	/**
	 * Perform a generic POST request to the Twitch API.
	 */
	public void performPostRequest(String url, JsonObject data, OkHttpClient httpClient, HttpResponseHandler responseHandler, HttpErrorHandler errorHandler)
	{
		final String token = config.twitchToken();
		final Request request = new Request.Builder()
			.header("Client-ID", DEFAULT_EXTENSION_CLIENT_ID)
			.header("Authorization", "Bearer "+ token)
			.header("User-Agent", USER_AGENT)
			.header("Content-Type", "application/json")
			.post(RequestBody.create(JSON, data.toString()))
			.url(url)
			.build();

		performRequest(request, httpClient, responseHandler, errorHandler);
	}

	/**
	 * Perform a generic request to the Twitch API.
	 */
	public void performRequest(Request request, OkHttpClient httpClient, HttpResponseHandler responseHandler, HttpErrorHandler errorHandler)
	{
		final HttpUrl url = request.url();

		// queue the request on the OkHttp thread pool to prevent blocking other threads
		httpClient.newCall(request).enqueue(new Callback() {
			@Override
			public void onFailure(Call call, IOException exception) {
				plugin.logSupport("Could not send request to: "+ url);
				plugin.logSupport("The error that occurred was: ");
				plugin.logSupport(exception.getMessage());
				errorHandler.execute(exception);
			}

			@Override
			public void onResponse(Call call, Response response) {
				try {
					responseHandler.execute(response);
				} catch (Exception exception) {
					plugin.logSupport("Could not handle the response that was received from: "+ url);
					plugin.logSupport(exception.getMessage());
				}

				// always close the response to be sure there are no memory leaks
				response.close();
			}
		});
	}

	/**
	 * Create a new HTTP client instance with a specific timeout
	 */
	public OkHttpClient createHttpClient(int timeoutMs)
	{
		return httpClientTemplate
			.newBuilder()
			.callTimeout(timeoutMs, TimeUnit.MILLISECONDS)
			.build();
	}

	public interface HttpResponseHandler {
		public void execute(Response response) throws Exception;
	}

	public interface HttpErrorHandler {
		public void execute(Exception error);
	}
}

package com.twitchliveloadout.twitch;

import lombok.Getter;

public enum TwitchStateEntry {
	CONTENT_ID("contentId"),
	CONNECTION_STATUS("connectionStatus"),
	ACCOUNT_HASH("accountHash"),
	ACCOUNT_TYPE("accountType"),
	PLAYER_NAME("playerName"),
	REGION_ID("regionId"),
	INVENTORY_ITEMS("inventory", true),
	INVENTORY_PRICE("inventoryPrice", true),
	EQUIPMENT_ITEMS("equipment", true),
	EQUIPMENT_PRICE("equipmentPrice", true),
	LOOTING_BAG_ITEMS("lootingBag", true),
	LOOTING_BAG_PRICE("lootingBagPrice", true),
	FIGHT_STATISTICS("fightStatistics", true),
	SKILL_EXPERIENCES("skillExperiences", true),
	BOOSTED_SKILL_LEVELS("boostedSkillLevels", true),
	VIRTUAL_LEVELS_ENABLED("virtualLevelsEnabled"),
	WEIGHT("weight", true),
	ITEM_GOALS("itemGoals", true),
	TOP_POSITION("topPosition"),
	THEME_TYPE("themeType"),
	VISIBILITY_TYPE("visibilityType"),
	BANK_TABBED_ITEMS("bankTabbedItems", true),
	BANK_PRICE("bankPrice", true),
	COLLECTION_LOG("collectionLog", true),
	COLLECTION_LOG_OBTAINED_AMOUNT("collectionLogObtainedAmount", true),
	COLLECTION_LOG_OBTAINABLE_AMOUNT("collectionLogObtainableAmount", true),
	INVOCATIONS("invocations", true),
	INVOCATIONS_RAID_LEVEL("invocationsRaidLevel", true),
	MARKETPLACE_ENABLED("marketplaceEnabled", true),
	MARKETPLACE_ACTIVE("marketplaceActive"),
	MARKETPLACE_CHANNEL_EVENTS_ACTIVE("marketplaceChannelEventsActive"),
	MARKETPLACE_TEST_MODE_ACTIVE("marketplaceTestModeActive"),
	MARKETPLACE_FREE_MODE_ACTIVE("marketplaceFreeModeActive"),
	MARKETPLACE_CHAOS_MODE_ACTIVE("marketplaceChaosModeActive"),
	MARKETPLACE_PROTECTION_ENABLED("marketplaceProtectionEnabled"),
	CURRENT_PRODUCT_COOLDOWNS("currentProductCooldowns", true),
	CURRENT_SHARED_COOLDOWN("currentSharedCooldown"),
	SHARED_COOLDOWN("sharedCooldown"),
	QUESTS("quests", true),
	COMBAT_ACHIEVEMENTS("combatAchievements", true),
	COMBAT_ACHIEVEMENT_PROGRESS("combatAchievementsProgress", true),
	SEASONAL_ITEMS("seasonalItems", true),
	STREAMER_PRODUCTS("streamerProducts"),
	CHANNEL_POINT_REWARDS("channelPointRewards"),
	;

	@Getter
	private final String key;
	@Getter
	private final boolean nullable;

	TwitchStateEntry(String key) {
		this.key = key;
		this.nullable = false;
	}

	TwitchStateEntry(String key, boolean nullable) {
		this.key = key;
		this.nullable = nullable;
	}
}

package com.twitchliveloadout.twitch;

import lombok.Getter;

public enum TwitchPubSubTargetType {
	BROADCAST("broadcast"),
	GLOBAL("global"),
	;

	@Getter
	private final String target;

	TwitchPubSubTargetType(String target) {
		this.target = target;
	}
}

package com.twitchliveloadout.twitch;

import lombok.Getter;

public enum TwitchSegmentType {
	BROADCASTER("broadcaster"),
	GLOBAL("global"),
	DEVELOPER("developer"),
	;

	@Getter
	private final String key;

	TwitchSegmentType(String key)
	{
		this.key = key;
	}
}


package com.twitchliveloadout.twitch;

import com.google.gson.*;
import com.twitchliveloadout.TwitchLiveLoadoutConfig;
import com.twitchliveloadout.TwitchLiveLoadoutPlugin;
import com.twitchliveloadout.marketplace.MarketplaceManager;
import com.twitchliveloadout.marketplace.products.ChannelPointReward;
import com.twitchliveloadout.twitch.eventsub.TwitchEventSubClient;
import com.twitchliveloadout.ui.CanvasListener;
import com.twitchliveloadout.utilities.AccountType;
import lombok.Getter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.*;

import java.time.Instant;
import java.util.Arrays;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.CopyOnWriteArrayList;
import java.util.concurrent.atomic.AtomicInteger;

import static com.twitchliveloadout.TwitchLiveLoadoutConfig.*;
import static com.twitchliveloadout.items.CollectionLogManager.ITEMS_KEY_NAME;

/**
 * In-memory state of all the data that is synced
 * to the Twitch Extension. All data is stored here
 * to allow each data type to be synced at different rates
 * and mechanisms (e.g. polling and event driven).
 *
 * Due to the fact we only have one entry ("broadcaster") to store
 * the data in the Twitch Configuration Service upon update of one
 * data type we need to send all the others as well. For this
 * an in-memory state is useful. Looks like this does not give significant
 * overhead.
 *
 * The Configuration and PubSub Service state do have limitations: it can only be a maximum of 5KB.
 *
 * Configuration Service documentation:
 * https://dev.twitch.tv/docs/extensions/reference/#set-extension-configuration-segment
 */
@Slf4j
public class TwitchState {

	private final TwitchLiveLoadoutPlugin plugin;
	private final TwitchLiveLoadoutConfig config;
	private final TwitchEventSubClient twitchEventSubClient;
	private final CanvasListener canvasListener;
	private final Gson gson;

	/**
	 * Enable this if you want to test the state with all its limits
	 * where we will fill the combat stats, item quantities, etc. with maxed out integers.
	 * This will help us gain insights in how many bank items and combat fights we can allow.
	 */
	public final static boolean STATE_STRESS_TEST_ENABLED = false && TwitchLiveLoadoutPlugin.IN_DEVELOPMENT;
	public final static int MAX_ITEM_QUANTITY = 8000;
	public final static int MAX_FIGHT_STATISTIC_VALUE = 700;
	public final static int MAX_SKILL_EXPERIENCE = 200000000;
	public final static int MAX_SKILL_LEVEL = 126;

	/**
	 * The current state that is queued to be sent out.
	 */
	private JsonObject currentState = new JsonObject();

	/**
	 * An additional cyclic state that cannot be sent out at once
	 * due to Twitch limitations, currently the bank and the collection log
	 * are sent in smaller parts via this state.
	 * NOTE: keep a minimum of 20% reserved for combat fights.
	 */
	private final static int MAX_BANK_ITEMS_PER_SLICE = 250;
	private final static int MAX_COLLECTION_LOG_ITEMS_PER_SLICE = 250;
	private final static int MAX_COMBAT_ACHIEVEMENTS_PER_SLICE = 175; // 250 is too much
	private final static String COLLECTION_LOG_FILTER_SEPARATOR = ",";
	private JsonObject cyclicState = new JsonObject();
	@Getter
	private TwitchStateEntry currentCyclicEntry = TwitchStateEntry.BANK_TABBED_ITEMS;
	private int currentCyclicSliceIndex = 0;

	/**
	 * Additional state variables not synced to the client but can determine syncing behaviour
	 */
	private final static int WAS_IN_TOA_DEBOUNCE = 20 * 1000; // ms
	private Instant lastWasInToA;

	public TwitchState(TwitchLiveLoadoutPlugin plugin, TwitchLiveLoadoutConfig config, TwitchEventSubClient twitchEventSubClient, CanvasListener canvasListener, Gson gson)
	{
		this.plugin = plugin;
		this.config = config;
		this.twitchEventSubClient = twitchEventSubClient;
		this.canvasListener = canvasListener;
		this.gson = gson;

		// initialize the states that are not directly synced with events
		setOverlayTopPosition(config.overlayTopPosition());
		setVirtualLevelsEnabled(config.virtualLevelsEnabled());
		setTwitchTheme(config.twitchTheme());
		setTwitchVisibility(config.twitchVisibility());

		// set initial items as no events are triggered when they are empty
		setInventoryItems(new Item[0], 0);
		setEquipmentItems(new Item[0], 0);
		setWeight(0);
	}

	public JsonObject getState()
	{
		return currentState;
	}

	public void setPlayerName(String playerName)
	{
		currentState.addProperty(TwitchStateEntry.PLAYER_NAME.getKey(), playerName);
	}

	public void setAccountHash(Long accountHash)
	{
		currentState.addProperty(TwitchStateEntry.ACCOUNT_HASH.getKey(), accountHash);
	}

	public void setAccountType(AccountType accountType)
	{

		// guard: reset account type when none is passed
		// this might happen while logging in or when switching account
		// this is important when switching from a main to a HC account to not have any events spawn
		// due to retrieving the account type taking some time
		if (accountType == null)
		{
			currentState.remove(TwitchStateEntry.ACCOUNT_TYPE.getKey());
			return;
		}

		currentState.addProperty(TwitchStateEntry.ACCOUNT_TYPE.getKey(), accountType.getKey());
	}

	public void setRegionId(int regionId)
	{
		currentState.addProperty(TwitchStateEntry.REGION_ID.getKey(), regionId);
	}

	public void setOverlayTopPosition(int overlayTopPosition)
	{
		if (overlayTopPosition < MIN_OVERLAY_TOP_POSITION)
		{
			overlayTopPosition = MIN_OVERLAY_TOP_POSITION;
		}
		else if (overlayTopPosition > MAX_OVERLAY_TOP_POSITION)
		{
			overlayTopPosition = MAX_OVERLAY_TOP_POSITION;
		}

		currentState.addProperty(TwitchStateEntry.TOP_POSITION.getKey(), overlayTopPosition);
	}

	public void setTwitchTheme(TwitchThemeEntry twitchTheme)
	{
		currentState.addProperty(TwitchStateEntry.THEME_TYPE.getKey(), twitchTheme.getKey());
	}

	public void setTwitchVisibility(TwitchVisibilityEntry twitchVisibility)
	{
		currentState.addProperty(TwitchStateEntry.VISIBILITY_TYPE.getKey(), twitchVisibility.getKey());
	}

	public void setWeight(Integer weight)
	{
		currentState.addProperty(TwitchStateEntry.WEIGHT.getKey(), weight);
	}

	public void setSkillExperiences(int[] skillExperiences)
	{
		currentState.add(TwitchStateEntry.SKILL_EXPERIENCES.getKey(), convertToJson(skillExperiences, MAX_SKILL_EXPERIENCE));
	}

	public void setBoostedSkillLevels(int[] boostedSkillLevels)
	{
		currentState.add(TwitchStateEntry.BOOSTED_SKILL_LEVELS.getKey(), convertToJson(boostedSkillLevels, MAX_SKILL_LEVEL));
	}

	public void setVirtualLevelsEnabled(boolean virtualLevelsEnabled)
	{
		currentState.addProperty(TwitchStateEntry.VIRTUAL_LEVELS_ENABLED.getKey(), virtualLevelsEnabled);
	}

	public void setFightStatistics(JsonObject fightStatistics)
	{
		currentState.add(TwitchStateEntry.FIGHT_STATISTICS.getKey(), fightStatistics);
	}

	public void setInventoryItems(Item[] items, long totalPrice)
	{
		setItems(TwitchStateEntry.INVENTORY_ITEMS.getKey(), items);
		setItemsPrice(TwitchStateEntry.INVENTORY_PRICE.getKey(), totalPrice);
	}

	public void setEquipmentItems(Item[] items, long totalPrice)
	{
		setItems(TwitchStateEntry.EQUIPMENT_ITEMS.getKey(), items);
		setItemsPrice(TwitchStateEntry.EQUIPMENT_PRICE.getKey(), totalPrice);
	}

	public void setLootingBagItems(Item[] items, long totalPrice)
	{
		setItems(TwitchStateEntry.LOOTING_BAG_ITEMS.getKey(), items);
		setItemsPrice(TwitchStateEntry.LOOTING_BAG_PRICE.getKey(), totalPrice);
		plugin.setConfiguration(LOOTING_BAG_ITEMS_CONFIG_KEY, convertToJson(items));
		plugin.setConfiguration(LOOTING_BAG_PRICE_CONFIG_KEY, totalPrice);
	}

	private void setItems(String itemsKey, Item[] items)
	{
		setItems(itemsKey, convertToJson(items));
	}

	private void setItems(String itemsKey, JsonArray items)
	{
		currentState.add(itemsKey, items);
	}

	private void setItemsPrice(String priceKey, String totalPrice)
	{
		setItemsPrice(priceKey, Long.parseLong(totalPrice));
	}

	private void setItemsPrice(String priceKey, long totalPrice)
	{
		currentState.addProperty(priceKey, totalPrice);
	}

	public void setCurrentProductCooldowns(ConcurrentHashMap<String, Instant> cooldownsUntil)
	{
		Instant now = Instant.now();
		JsonObject currentProductCooldowns = new JsonObject();

		// add each one of them
		cooldownsUntil.forEach((streamerProductId, cooldownUntil) -> {

			// guard: don't include cooldowns that have already passed
			// this ensures no old cooldowns are sent to the extension which might have
			// a new cooldown initialized via the PubSub messaging, which is faster than this one!
			if (now.isAfter(cooldownUntil))
			{
				return;
			}
			currentProductCooldowns.addProperty(streamerProductId, cooldownUntil.toString());
		});

		currentState.add(TwitchStateEntry.CURRENT_PRODUCT_COOLDOWNS.getKey(), currentProductCooldowns);
	}

	public void setCurrentSharedCooldown(Instant sharedCooldownUntil)
	{
		Instant now = Instant.now();

		// guard: don't include a cooldown that has passed
		if (sharedCooldownUntil == null || now.isAfter(sharedCooldownUntil))
		{
			return;
		}

		currentState.addProperty(TwitchStateEntry.CURRENT_SHARED_COOLDOWN.getKey(), sharedCooldownUntil.toString());
	}

	public void setInvocations(JsonArray invocations)
	{
		cyclicState.add(TwitchStateEntry.INVOCATIONS.getKey(), invocations);
		plugin.setConfiguration(INVOCATIONS_CONFIG_KEY, invocations);
	}

	public void setInvocationsRaidLevel(String raidLevel)
	{
		try {
			int parsedRaidLevel = Integer.parseInt(raidLevel);
			cyclicState.addProperty(TwitchStateEntry.INVOCATIONS_RAID_LEVEL.getKey(), parsedRaidLevel);
			plugin.setConfiguration(INVOCATIONS_RAID_LEVEL_CONFIG_KEY, parsedRaidLevel);
		} catch (Exception exception) {
			plugin.logSupport("Could not set invocations raid level due to the following error:", exception);
		}
	}

	public void setBankItems(Item[] items, int[] tabAmounts)
	{
		JsonArray tabbedBankItems = new JsonArray();
		int currentItemAmount = 0;

		// convert the client item structure to a nested array with the items
		for (final int tabAmount : tabAmounts) {
			final Item[] tabItems = Arrays.copyOfRange(items, currentItemAmount, currentItemAmount + tabAmount);

			tabbedBankItems.add(convertToJson(tabItems));
			currentItemAmount += tabAmount;
		}

		// get the remaining / zero tab and prepend it
		final Item[] zeroTabItems = Arrays.copyOfRange(items, currentItemAmount, items.length);
		JsonArray prependedTabbedBankItems = new JsonArray();
		prependedTabbedBankItems.add(convertToJson(zeroTabItems));
		prependedTabbedBankItems.addAll(tabbedBankItems);

		setBankItems(prependedTabbedBankItems);
	}

	public void setBankItems(JsonArray tabbedBankItems)
	{
		cyclicState.add(TwitchStateEntry.BANK_TABBED_ITEMS.getKey(), tabbedBankItems);
		plugin.setConfiguration(BANK_TABBED_ITEMS_CONFIG_KEY, tabbedBankItems);
	}

	public void setBankItemsPrice(long totalPrice)
	{
		cyclicState.addProperty(TwitchStateEntry.BANK_PRICE.getKey(), totalPrice);
		plugin.setConfiguration(BANK_PRICE_CONFIG_KEY, totalPrice);
	}

	public void setCollectionLog(JsonObject collectionLog)
	{
		cyclicState.add(TwitchStateEntry.COLLECTION_LOG.getKey(), collectionLog);
		plugin.setConfiguration(COLLECTION_LOG_CONFIG_KEY, collectionLog);
	}

	public void setCollectionLogAmounts(Integer obtainedAmount, Integer obtainableAmount)
	{
		cyclicState.addProperty(TwitchStateEntry.COLLECTION_LOG_OBTAINED_AMOUNT.getKey(), obtainedAmount);
		cyclicState.addProperty(TwitchStateEntry.COLLECTION_LOG_OBTAINABLE_AMOUNT.getKey(), obtainableAmount);
		plugin.setConfiguration(COLLECTION_LOG_OBTAINED_AMOUNT_CONFIG_KEY, obtainedAmount);
		plugin.setConfiguration(COLLECTION_LOG_OBTAINABLE_AMOUNT_CONFIG_KEY, obtainableAmount);
	}

	public void setQuests(JsonArray quests)
	{
		cyclicState.add(TwitchStateEntry.QUESTS.getKey(), quests);
		plugin.setConfiguration(QUESTS_CONFIG_KEY, quests);
	}

	public void setCombatAchievementsProgress(String progressTitle)
	{
		currentState.addProperty(TwitchStateEntry.COMBAT_ACHIEVEMENT_PROGRESS.getKey(), progressTitle);
		plugin.setConfiguration(COMBAT_ACHIEVEMENTS_PROGRESS_CONFIG_KEY, progressTitle);
	}

	public void setCombatAchievements(JsonObject combatAchievements)
	{
		cyclicState.add(TwitchStateEntry.COMBAT_ACHIEVEMENTS.getKey(), combatAchievements);
		plugin.setConfiguration(COMBAT_ACHIEVEMENTS_CONFIG_KEY, combatAchievements);
	}

	public void setSeasonalItems(JsonArray seasonalItems)
	{
		currentState.add(TwitchStateEntry.SEASONAL_ITEMS.getKey(), seasonalItems);
	}

	public JsonObject getCollectionLog()
	{
		return cyclicState.getAsJsonObject(TwitchStateEntry.COLLECTION_LOG.getKey());
	}
	public JsonObject getCombatAchievements()
	{
		return cyclicState.getAsJsonObject(TwitchStateEntry.COMBAT_ACHIEVEMENTS.getKey());
	}

	public JsonArray getTabbedBankItems()
	{
		return cyclicState.getAsJsonArray(TwitchStateEntry.BANK_TABBED_ITEMS.getKey());
	}

	public JsonObject getFilteredState()
	{
		JsonObject filteredState = getState().deepCopy();

		// add the state that is too big to sync at once
		filteredState = addCyclicState(filteredState);

		// add a unique content ID so the front-end knows
		// this is a message containing information for the tabs.
		// if it is only a connection status all of this is filtered
		// out in a later step.
		filteredState = addContentId(filteredState);

		// verify whether we can sync this RL window, based on the
		// anti multi-logging settings
		filteredState = verifyClientActivityStatus(filteredState);

		// always add a connection status, even when this RL window is not syncing
		// this gives the user proper feedback whether the client is connected in the
		// configuration view when installing the extension
		filteredState = addConnectionStatus(filteredState);

		// always add marketplace settings because we want to show them even if the
		// player is not yet logged in so that viewers can preview them
		// the isLoggedIn property determines whether they are clickable
		filteredState = addMarketplaceSettings(filteredState);

		// remove any states that are disabled in the settings
		filteredState = removeDisabledState(filteredState);

		return filteredState;
	}

	public JsonObject addCyclicState(JsonObject state)
	{

		// add the bank items when in this mode
		if (currentCyclicEntry == TwitchStateEntry.BANK_TABBED_ITEMS)
		{
			final String bankTabbedItemsKey = TwitchStateEntry.BANK_TABBED_ITEMS.getKey();
			final String bankPriceKey = TwitchStateEntry.BANK_PRICE.getKey();

			if (!cyclicState.has(bankTabbedItemsKey) || !cyclicState.has(bankPriceKey))
			{
				return state;
			}

			AtomicInteger currentItemAmount = new AtomicInteger();
			final JsonArray allTabbedBankItems = cyclicState.getAsJsonArray(bankTabbedItemsKey);
			final JsonArray slicedTabbedBankItems = new JsonArray();
			final JsonArray emptyItem = new JsonArray();
			emptyItem.add(-1); // item ID
			emptyItem.add(-1); // item quantity

			// loop all the bank items until we find the item where we need to start syncing
			for (int tabIndex = 0; tabIndex < allTabbedBankItems.size(); tabIndex++)
			{
				JsonArray tabItems = allTabbedBankItems.get(tabIndex).getAsJsonArray();
				JsonArray slicedTabItems = new JsonArray();

				for (int itemIndex = 0; itemIndex < tabItems.size(); itemIndex++)
				{
					final boolean afterSliceStart = currentItemAmount.get() >= currentCyclicSliceIndex;
					final boolean beforeSliceEnd = currentItemAmount.get() < (currentCyclicSliceIndex + MAX_BANK_ITEMS_PER_SLICE);
					currentItemAmount.addAndGet(1);

					// guard: add empty item when we are not in range
					if (!afterSliceStart || !beforeSliceEnd) {
						slicedTabItems.add(emptyItem);
						continue;
					}

					slicedTabItems.add(tabItems.get(itemIndex));
				}

				// add each sliced tab
				slicedTabbedBankItems.add(slicedTabItems);
			}

			state.add(bankTabbedItemsKey, slicedTabbedBankItems);
			state.addProperty(bankPriceKey, cyclicState.get(bankPriceKey).getAsLong());

			return state;
		}

		if (currentCyclicEntry == TwitchStateEntry.COLLECTION_LOG)
		{
			final JsonObject collectionLog = getCollectionLog();
			final JsonObject slicedCollectionLog = new JsonObject();
			Integer collectionLogObtainedAmount = null;
			Integer collectionLogObtainableAmount = null;
			AtomicInteger skippedItemAmount = new AtomicInteger();
			AtomicInteger includedItemAmount = new AtomicInteger();
			String collectionLogKey = TwitchStateEntry.COLLECTION_LOG.getKey();
			String obtainedAmountKey = TwitchStateEntry.COLLECTION_LOG_OBTAINED_AMOUNT.getKey();
			String obtainableAmountKey = TwitchStateEntry.COLLECTION_LOG_OBTAINABLE_AMOUNT.getKey();

			if (collectionLog == null)
			{
				return state;
			}

			if (cyclicState.has(obtainedAmountKey) && cyclicState.has(obtainableAmountKey))
			{
				collectionLogObtainedAmount = cyclicState.get(obtainedAmountKey).getAsInt();
				collectionLogObtainableAmount = cyclicState.get(obtainableAmountKey).getAsInt();
			}

			collectionLog.keySet().forEach(tabTitle ->
			{
				JsonObject categories = collectionLog.getAsJsonObject(tabTitle);

				categories.keySet().forEach(categoryTitle ->
				{
					JsonObject category = categories.getAsJsonObject(categoryTitle);
					JsonArray items = category.getAsJsonArray(ITEMS_KEY_NAME);

					if (items == null)
					{
						return;
					}

					// guard: skip any categories that should not be included because of the filter
					if (!shouldIncludeInCollectionLog(tabTitle, categoryTitle, items))
					{
						return;
					}

					int itemAmount = items.size();

					// guard: check if we already passed the amount of items that were included
					// in the last slice that is synced to the viewers
					if (skippedItemAmount.get() < currentCyclicSliceIndex)
					{
						skippedItemAmount.addAndGet(itemAmount);
						return;
					}

					// guard: check if we exceeded the maximum amount of items
					// TODO: check if overflow in items might cause the max payload to exceed.
					// this can for example happen with large categories, perhaps wise to set the
					// max log items per slice to a fairly safe maximum so this cannot happen?
					if (includedItemAmount.get() > MAX_COLLECTION_LOG_ITEMS_PER_SLICE)
					{
						return;
					}

					// now we can include this category
					includedItemAmount.addAndGet(itemAmount);

					// make sure the tab exists
					if (!slicedCollectionLog.has(tabTitle))
					{
						slicedCollectionLog.add(tabTitle, new JsonObject());
					}

					JsonObject tabLog = slicedCollectionLog.getAsJsonObject(tabTitle);
					tabLog.add(categoryTitle, category);
				});
			});

			state.add(collectionLogKey, slicedCollectionLog);
			state.addProperty(obtainedAmountKey, collectionLogObtainedAmount);
			state.addProperty(obtainableAmountKey, collectionLogObtainableAmount);
		}

		if (currentCyclicEntry == TwitchStateEntry.QUESTS)
		{
			// add all the quests in one go
			JsonArray quests = cyclicState.getAsJsonArray(TwitchStateEntry.QUESTS.getKey());
			state.add(TwitchStateEntry.QUESTS.getKey(), quests);
		}

		if (currentCyclicEntry == TwitchStateEntry.INVOCATIONS)
		{
			// add all the invocations in one go
			JsonArray invocations = cyclicState.getAsJsonArray(TwitchStateEntry.INVOCATIONS.getKey());
			JsonElement invocationsRaidLevelElement = cyclicState.get(TwitchStateEntry.INVOCATIONS_RAID_LEVEL.getKey());
			Integer invocationsRaidLevel = (invocationsRaidLevelElement == null ? null : invocationsRaidLevelElement.getAsInt());
			state.add(TwitchStateEntry.INVOCATIONS.getKey(), invocations);
			state.addProperty(TwitchStateEntry.INVOCATIONS_RAID_LEVEL.getKey(), invocationsRaidLevel);
		}

		if (currentCyclicEntry == TwitchStateEntry.CHANNEL_POINT_REWARDS)
		{
			// add all channel point rewards in one go with data filtered from them
			JsonArray simpleChannelPointRewards = new JsonArray();
			CopyOnWriteArrayList<ChannelPointReward> channelPointRewards =  plugin.getMarketplaceManager().getChannelPointRewards();

			for (ChannelPointReward channelPointReward : channelPointRewards)
			{
				JsonObject simpleChannelPointReward = new JsonObject();

				// only add these three properties to conserve on data usage
				simpleChannelPointReward.addProperty("id", channelPointReward.id);
				simpleChannelPointReward.addProperty("title", channelPointReward.title);
				simpleChannelPointReward.addProperty("cost", channelPointReward.cost);

				simpleChannelPointRewards.add(simpleChannelPointReward);
			}

			state.add(TwitchStateEntry.CHANNEL_POINT_REWARDS.getKey(), simpleChannelPointRewards);
		}

		if (currentCyclicEntry == TwitchStateEntry.COMBAT_ACHIEVEMENTS)
		{
			JsonObject combatAchievements = cyclicState.getAsJsonObject(TwitchStateEntry.COMBAT_ACHIEVEMENTS.getKey());
			AtomicInteger skippedItemAmount = new AtomicInteger();
			AtomicInteger includedItemAmount = new AtomicInteger();
			JsonObject partialCombatAchievements = new JsonObject();

			if (combatAchievements == null)
			{
				return state;
			}

			combatAchievements.keySet().forEach((achievementName) -> {
				JsonArray combatAchievement = combatAchievements.getAsJsonArray(achievementName);

				// guard: check if we already passed the amount of achievements that were included
				// in the last slice that is synced to the viewers
				if (skippedItemAmount.get() < currentCyclicSliceIndex)
				{
					skippedItemAmount.addAndGet(1);
					return;
				}

				// guard: check if we exceeded the maximum amount of achievements
				if (includedItemAmount.get() > MAX_COMBAT_ACHIEVEMENTS_PER_SLICE)
				{
					return;
				}

				partialCombatAchievements.add(achievementName, combatAchievement);
				includedItemAmount.addAndGet(1);
			});

			state.add(TwitchStateEntry.COMBAT_ACHIEVEMENTS.getKey(), partialCombatAchievements);
		}

		return state;
	}

	public JsonObject addContentId(JsonObject state)
	{
		state.addProperty(TwitchStateEntry.CONTENT_ID.getKey(), Long.toString(Instant.now().toEpochMilli()));

		return state;
	}

	private boolean shouldIncludeInCollectionLog(String tabTitle, String categoryTitle, JsonArray items)
	{
		final String filter = config.collectionLogFilter().trim().toLowerCase();
		final String[] filterPieces = filter.split(COLLECTION_LOG_FILTER_SEPARATOR);
		final String trimmedTabTitle = tabTitle.trim().toLowerCase();
		final String trimmedCategoryTitle = categoryTitle.trim().toLowerCase();

		if (config.collectionLogSkipEmpty())
		{
			boolean foundItem = false;

			// check all items whether something is obtained
			for (JsonElement rawItem : items)
			{
				JsonArray item = rawItem.getAsJsonArray();
				int itemQuantity = item.get(1).getAsInt();

				if (itemQuantity > 0)
				{
					foundItem = true;
				}
			}

			// guard: when none is found skip this log page
			if (!foundItem)
			{
				return false;
			}
		}

		if (filter.equals(""))
		{
			return true;
		}

		for (final String filterPiece : filterPieces)
		{
			final String trimmedFilterPiece = filterPiece.trim();

			if (trimmedTabTitle.contains((trimmedFilterPiece)) || trimmedCategoryTitle.contains((trimmedFilterPiece)))
			{
				return true;
			}
		}

		return false;
	}

	public void nextCyclicState()
	{

		// after bank items are synced we move to the collection log
		// we cannot sync the bank in one go either so we go through the slices
		if (currentCyclicEntry == TwitchStateEntry.BANK_TABBED_ITEMS)
		{
			final int itemAmount = getBankItemAmount();
			final int newSliceIndex = currentCyclicSliceIndex + MAX_BANK_ITEMS_PER_SLICE;
			currentCyclicSliceIndex = newSliceIndex;

			// if the current slices were already exceeding the current items
			// we can move to syncing the collection log once again
			if (!config.bankEnabled() || currentCyclicSliceIndex >= itemAmount)
			{
				currentCyclicEntry = TwitchStateEntry.COLLECTION_LOG;
				currentCyclicSliceIndex = 0;
			}
		}

		// the collection log is a bit more complex as we cannot sync 1351+ items
		// in one go, for this reason we move across the object category by category
		// after this we go to the quests
		else if (currentCyclicEntry == TwitchStateEntry.COLLECTION_LOG)
		{
			final int itemAmount = getCollectionLogItemAmount();
			final int newSliceIndex = currentCyclicSliceIndex + MAX_COLLECTION_LOG_ITEMS_PER_SLICE;
			currentCyclicSliceIndex = newSliceIndex;

			// if the current slices were already exceeding the current items
			// we can move to syncing the bank once again
			if (!config.collectionLogEnabled() || currentCyclicSliceIndex >= itemAmount)
			{
				currentCyclicEntry = TwitchStateEntry.QUESTS;
				currentCyclicSliceIndex = 0;
			}
		}

		// after quests we go to invocations
		else if (currentCyclicEntry == TwitchStateEntry.QUESTS)
		{
			currentCyclicEntry = TwitchStateEntry.INVOCATIONS;
			currentCyclicSliceIndex = 0;
		}

		// after invocations we go back to the channel point rewards
		else if (currentCyclicEntry == TwitchStateEntry.INVOCATIONS)
		{
			currentCyclicEntry = TwitchStateEntry.CHANNEL_POINT_REWARDS;
			currentCyclicSliceIndex = 0;
		}

		// after the channel point rewards go to the combat achievements
		else if (currentCyclicEntry == TwitchStateEntry.CHANNEL_POINT_REWARDS)
		{
			currentCyclicEntry = TwitchStateEntry.COMBAT_ACHIEVEMENTS;
			currentCyclicSliceIndex = 0;
		}

		// after the combat achievements go to the bank
		else if (currentCyclicEntry == TwitchStateEntry.COMBAT_ACHIEVEMENTS)
		{
			final int combatAchievementAmount = getCombatAchievementAmount();
			final int newSliceIndex = currentCyclicSliceIndex + MAX_COMBAT_ACHIEVEMENTS_PER_SLICE;
			currentCyclicSliceIndex = newSliceIndex;

			// if the current slices were already exceeding the current items
			// we can move to syncing the bank once again
			if (!config.combatAchievementsEnabled() || currentCyclicSliceIndex >= combatAchievementAmount)
			{
				currentCyclicEntry = TwitchStateEntry.BANK_TABBED_ITEMS;
				currentCyclicSliceIndex = 0;
			}
		}
	}

	private JsonObject verifyClientActivityStatus(JsonObject state)
	{
		final JsonElement accountHashElement = state.get(TwitchStateEntry.ACCOUNT_HASH.getKey());
		final JsonElement channelPointRewardsElement = state.get(TwitchStateEntry.CHANNEL_POINT_REWARDS.getKey());
		final Long accountHash = (accountHashElement == null ? -1 : accountHashElement.getAsLong());

		// only sync this account when a valid account hash
		if (accountHash == null || accountHash == -1)
		{
			state = new JsonObject();
		}

		// only sync this account when logged in
		if (!plugin.isLoggedIn(true))
		{
			state = new JsonObject();
		}

		// we need to make one exception for the cyclic state of the Channel Point Rewards
		// that should be synced regardless of whether we are logged in or not
		// TODO: look into refactor as this feels a bit weird to place here as one exception...
		if (channelPointRewardsElement != null) {
			state.add(TwitchStateEntry.CHANNEL_POINT_REWARDS.getKey(), channelPointRewardsElement);
		}

		return state;
	}

	private JsonObject addConnectionStatus(JsonObject state)
	{
		final JsonObject connectionStatus = new JsonObject();
		final boolean isLoggedIn = plugin.isLoggedIn(true);

		// for now always true?
		connectionStatus.addProperty("status", true);
		connectionStatus.addProperty("isLoggedIn", isLoggedIn);

		state.add(TwitchStateEntry.CONNECTION_STATUS.getKey(), connectionStatus);
		return state;
	}

	private JsonObject addMarketplaceSettings(JsonObject state)
	{

		// also get whether the marketplace manager is active because this can temporarily disable
		// donations via the playback buttons, it feel more natural to fetch it actively than to move some of that
		// state also to this class. NOTE: check whether it is not null because this class is initialized first.
		MarketplaceManager marketplaceManager = plugin.getMarketplaceManager();
		boolean isEnabled = config.marketplaceEnabled();
		boolean channelEventsActive = config.marketplaceChannelEventsEnabled() && twitchEventSubClient.isConnected() && !config.twitchOAuthAccessToken().isEmpty() && !config.twitchOAuthRefreshToken().isEmpty();
		boolean isActive = false;
		boolean isTestModeActive = false;
		boolean isFreeModeActive = false;
		boolean isChaosModeActive = false;
		int sharedCooldownS = 0;

		if (marketplaceManager != null)
		{
			isActive = marketplaceManager.isActive() && !marketplaceManager.isFetchingEbsTransactionsErrored();
			isTestModeActive = marketplaceManager.isTestModeActive();
			isFreeModeActive = marketplaceManager.isFreeModeActive();
			isChaosModeActive = marketplaceManager.isChaosModeActive();
			sharedCooldownS = marketplaceManager.getSharedCooldownS();
		}

		state.addProperty(TwitchStateEntry.MARKETPLACE_ENABLED.getKey(), isEnabled);
		state.addProperty(TwitchStateEntry.MARKETPLACE_ACTIVE.getKey(), isActive);
		state.addProperty(TwitchStateEntry.MARKETPLACE_CHANNEL_EVENTS_ACTIVE.getKey(), channelEventsActive);
		state.addProperty(TwitchStateEntry.MARKETPLACE_TEST_MODE_ACTIVE.getKey(), isTestModeActive);
		state.addProperty(TwitchStateEntry.MARKETPLACE_FREE_MODE_ACTIVE.getKey(), isFreeModeActive);
		state.addProperty(TwitchStateEntry.MARKETPLACE_CHAOS_MODE_ACTIVE.getKey(), isChaosModeActive);
		state.addProperty(TwitchStateEntry.MARKETPLACE_PROTECTION_ENABLED.getKey(), config.marketplaceProtectionEnabled());
		state.addProperty(TwitchStateEntry.SHARED_COOLDOWN.getKey(), sharedCooldownS);
		return state;
	}

	private JsonObject removeDisabledState(JsonObject state)
	{

		// clear everything when sync is not enabled to clear everything for all viewers
		if (!config.syncEnabled())
		{

			// set null for all keys to make sure all viewers have their state cleared as well
			for (TwitchStateEntry stateEntry : TwitchStateEntry.values())
			{
				if (!stateEntry.isNullable())
				{
					continue;
				}

				state.add(stateEntry.getKey(), null);
			}
		}

		if (!config.playerInfoEnabled())
		{
			state.add(TwitchStateEntry.PLAYER_NAME.getKey(), null);
		}

		if (!config.inventoryEnabled())
		{
			state.add(TwitchStateEntry.INVENTORY_ITEMS.getKey(), null);
			state.add(TwitchStateEntry.INVENTORY_PRICE.getKey(), null);
		}

		if (!config.equipmentEnabled())
		{
			state.add(TwitchStateEntry.EQUIPMENT_ITEMS.getKey(), null);
			state.add(TwitchStateEntry.EQUIPMENT_PRICE.getKey(), null);
		}

		if (!config.lootingBagEnabled())
		{
			state.add(TwitchStateEntry.LOOTING_BAG_ITEMS.getKey(), null);
			state.add(TwitchStateEntry.LOOTING_BAG_PRICE.getKey(), null);
		}

		if (!config.bankEnabled())
		{
			state.add(TwitchStateEntry.BANK_TABBED_ITEMS.getKey(), null);
			state.add(TwitchStateEntry.BANK_PRICE.getKey(), null);
		}

		if (!config.bankPriceEnabled())
		{
			state.add(TwitchStateEntry.BANK_PRICE.getKey(), null);
		}

		if (!config.collectionLogEnabled())
		{
			state.add(TwitchStateEntry.COLLECTION_LOG.getKey(), null);
		}

		if (!config.fightStatisticsEnabled())
		{
			state.add(TwitchStateEntry.FIGHT_STATISTICS.getKey(), null);
		}

		if (!config.itemGoalsEnabled())
		{
			state.add(TwitchStateEntry.ITEM_GOALS.getKey(), null);
		}

		if (!config.skillsEnabled())
		{
			state.add(TwitchStateEntry.SKILL_EXPERIENCES.getKey(), null);
			state.add(TwitchStateEntry.BOOSTED_SKILL_LEVELS.getKey(), null);
		}

		if (!config.weightEnabled())
		{
			state.add(TwitchStateEntry.WEIGHT.getKey(), null);
		}

		if (!config.marketplaceEnabled())
		{
			state.addProperty(TwitchStateEntry.MARKETPLACE_ENABLED.getKey(), false);
			state.add(TwitchStateEntry.CURRENT_PRODUCT_COOLDOWNS.getKey(), null);
		}

		if (!config.invocationsEnabled())
		{
			state.add(TwitchStateEntry.INVOCATIONS.getKey(), null);
		}

		if (!config.invocationsEnabled() || !config.invocationsRaidLevelEnabled())
		{
			state.add(TwitchStateEntry.INVOCATIONS_RAID_LEVEL.getKey(), null);
		}

		if (!config.questsEnabled())
		{
			state.add(TwitchStateEntry.QUESTS.getKey(), null);
		}

		if (!config.combatAchievementsEnabled())
		{
			state.add(TwitchStateEntry.COMBAT_ACHIEVEMENT_PROGRESS.getKey(), null);
			state.add(TwitchStateEntry.COMBAT_ACHIEVEMENTS.getKey(), null);
		}

		if (!config.seasonalsEnabled() || !plugin.isSeasonal())
		{
			state.add(TwitchStateEntry.SEASONAL_ITEMS.getKey(), null);
		}

		// reset the invocations for the current viewers when we are not in ToA anymore
		// note that this should only be done for the window that is active long enough
		// otherwise it is possible to have an alt window resetting the invocations for the main window
		if (plugin.isLoggedIn() &&
			config.autoDetectInToaRaidEnabled() &&
			!wasInToaDebounced() &&
			state.has(TwitchStateEntry.INVOCATIONS.getKey()))
		{
			final boolean hasInvocations = state.get(TwitchStateEntry.INVOCATIONS.getKey()).isJsonArray();

			if (hasInvocations)
			{
				state.add(TwitchStateEntry.INVOCATIONS.getKey(), null);
				state.add(TwitchStateEntry.INVOCATIONS_RAID_LEVEL.getKey(), null);
			}
		}

		return state;
	}

	private JsonArray convertToJson(Item[] items)
	{
		JsonArray itemsJson = new JsonArray();

		if (items == null) {
			return itemsJson;
		}

		for (Item item : items) {
			JsonArray itemJson = new JsonArray();
			final int id = item.getId();
			int quantity = item.getQuantity();

			if (TwitchState.STATE_STRESS_TEST_ENABLED)
			{
				quantity = (int) (Math.random() * TwitchState.MAX_ITEM_QUANTITY);
			}

			itemJson.add(id);
			itemJson.add(quantity);

			itemsJson.add(itemJson);
		}

		return itemsJson;
	}

	private JsonArray convertToJson(int[] array, int maxValue)
	{
		final int length = array.length;
		final int[] copiedArray = new int[length];

		// Prevent the original array to be mutated with testing mode
		// as it can be an array that is used for rendering.
		System.arraycopy(array, 0, copiedArray, 0, length);

		if (STATE_STRESS_TEST_ENABLED && maxValue > 0) {
			for (int i = 0; i < array.length; i++) {
				copiedArray[i] = (int) (Math.random() * maxValue);
			}
		}

		JsonArray json = gson.toJsonTree(copiedArray).getAsJsonArray();
		return json;
	}

	private int getCollectionLogItemAmount()
	{
		final JsonObject collectionLog = getCollectionLog();
		AtomicInteger amount = new AtomicInteger();

		if (collectionLog == null)
		{
			return amount.get();
		}

		collectionLog.keySet().forEach(tabTitle ->
		{
			JsonObject categories = collectionLog.getAsJsonObject(tabTitle);

			categories.keySet().forEach(categoryTitle ->
			{
				JsonObject category = categories.getAsJsonObject(categoryTitle);
				JsonArray items = category.getAsJsonArray(ITEMS_KEY_NAME);

				if (items == null)
				{
					return;
				}

				// guard: skip any categories that should not be included because of the filter
				if (!shouldIncludeInCollectionLog(tabTitle, categoryTitle, items))
				{
					return;
				}

				amount.addAndGet(items.size());
			});
		});

		return amount.get();
	}

	private int getBankItemAmount()
	{
		final JsonArray tabbedBankItems = getTabbedBankItems();
		int amount = 0;

		if (tabbedBankItems == null) {
			return amount;
		}

		for (int tabIndex = 0; tabIndex < tabbedBankItems.size(); tabIndex++)
		{
			JsonArray tabItems = tabbedBankItems.get(tabIndex).getAsJsonArray();
			amount += tabItems.size();
		}

		return amount;
	}

	private int getCombatAchievementAmount()
	{
		JsonObject combatAchievements = getCombatAchievements();

		if (combatAchievements == null)
		{
			return 0;
		}

		int achievementAmount = combatAchievements.keySet().size();
		return achievementAmount;
	}

	public void onAccountChanged()
	{
		reloadConfiguration();
	}

	private void reloadConfiguration()
	{
		// when another account logs in the cache should be updated to that account
		// first we reset the data and after that check the cache
		cyclicState.remove(TwitchStateEntry.COLLECTION_LOG.getKey());
		cyclicState.remove(TwitchStateEntry.BANK_TABBED_ITEMS.getKey());
		cyclicState.remove(TwitchStateEntry.BANK_PRICE.getKey());
		cyclicState.remove(TwitchStateEntry.QUESTS.getKey());
		cyclicState.remove(TwitchStateEntry.INVOCATIONS.getKey());
		cyclicState.remove(TwitchStateEntry.INVOCATIONS_RAID_LEVEL.getKey());

		currentState.add(TwitchStateEntry.LOOTING_BAG_ITEMS.getKey(), null);
		currentState.addProperty(TwitchStateEntry.LOOTING_BAG_PRICE.getKey(), 0);

		plugin.loadFromConfiguration(COLLECTION_LOG_CONFIG_KEY, (String rawCollectionLog) -> {
			JsonObject parsedCollectionLog = new JsonParser().parse(rawCollectionLog).getAsJsonObject();
			setCollectionLog(parsedCollectionLog);
		});

		plugin.loadFromConfiguration(COLLECTION_LOG_OBTAINED_AMOUNT_CONFIG_KEY, (String rawObtainedAmount) -> {
			plugin.loadFromConfiguration(COLLECTION_LOG_OBTAINABLE_AMOUNT_CONFIG_KEY, (String rawObtainableAmount) -> {
				Integer obtainedAmount = Integer.parseInt(rawObtainedAmount);
				Integer obtainableAmount = Integer.parseInt(rawObtainableAmount);
				setCollectionLogAmounts(obtainedAmount, obtainableAmount);
			});
		});

		plugin.loadFromConfiguration(BANK_TABBED_ITEMS_CONFIG_KEY, (String rawItems) -> {
			JsonArray parsedTabbedItems = new JsonParser().parse(rawItems).getAsJsonArray();
			setBankItems(parsedTabbedItems);
		});

		plugin.loadFromConfiguration(BANK_PRICE_CONFIG_KEY, (String price) -> {
			setBankItemsPrice(Long.parseLong(price));
		});

		plugin.loadFromConfiguration(QUESTS_CONFIG_KEY, (String rawQuests) -> {
			JsonArray parsedQuests = new JsonParser().parse(rawQuests).getAsJsonArray();
			setQuests(parsedQuests);
		});

		plugin.loadFromConfiguration(COMBAT_ACHIEVEMENTS_CONFIG_KEY, (String rawCombatAchievements) -> {
			JsonObject parsedCombatAchievements = new JsonParser().parse(rawCombatAchievements).getAsJsonObject();
			setCombatAchievements(parsedCombatAchievements);
		});

		plugin.loadFromConfiguration(COMBAT_ACHIEVEMENTS_PROGRESS_CONFIG_KEY, (String progressTitle) -> {
			setCombatAchievementsProgress(progressTitle);
		});

		plugin.loadFromConfiguration(LOOTING_BAG_ITEMS_CONFIG_KEY, (String rawItems) -> {
			JsonArray parsedItems = new JsonParser().parse(rawItems).getAsJsonArray();
			setItems(TwitchStateEntry.LOOTING_BAG_ITEMS.getKey(), parsedItems);
		});

		plugin.loadFromConfiguration(LOOTING_BAG_PRICE_CONFIG_KEY, (String price) -> {
			setItemsPrice(TwitchStateEntry.LOOTING_BAG_PRICE.getKey(), price);
		});

		plugin.loadFromConfiguration(INVOCATIONS_CONFIG_KEY, (String rawInvocations) -> {
			JsonArray parsedInvocations = new JsonParser().parse(rawInvocations).getAsJsonArray();
			setInvocations(parsedInvocations);
		});

		plugin.loadFromConfiguration(INVOCATIONS_RAID_LEVEL_CONFIG_KEY, (String raidLevel) -> {
			setInvocationsRaidLevel(raidLevel);
		});
	}

	public void resetState()
	{
		currentState = new JsonObject();
		cyclicState = new JsonObject();
	}

	public void setInToA(boolean isInToA)
	{
		if (isInToA)
		{
			lastWasInToA = Instant.now();
		}
	}

	private boolean wasInToaDebounced()
	{
		if (lastWasInToA == null)
		{
			return false;
		}

		return Instant.now().minusMillis(WAS_IN_TOA_DEBOUNCE).isBefore(lastWasInToA);
	}
}

package com.twitchliveloadout.twitch.eventsub;

import com.twitchliveloadout.TwitchLiveLoadoutConfig;
import com.twitchliveloadout.TwitchLiveLoadoutPlugin;
import com.twitchliveloadout.twitch.eventsub.messages.*;
import lombok.Getter;
import lombok.extern.slf4j.Slf4j;

/**
 * Reference: https://dev.twitch.tv/docs/eventsub/eventsub-subscription-types/
 */
@Getter
@Slf4j
public enum TwitchEventSubType {
    CHANNEL_POINTS_REDEEM("channel.channel_points_custom_reward_redemption.add", "Channel Points Redeem", true, 1, ChannelPointsRedeem.class, (p, c, m) -> true, TwitchLiveLoadoutConfig::channelPointsRedeemEventMessage, (plugin, config, message) -> config.channelPointsRedeemEventMessageEnabled()),
    START_SUBSCRIPTION(
        "channel.subscribe", "Sub", true, 1, ChannelStartSubscription.class, (p, c, m) -> true, TwitchLiveLoadoutConfig::subscribeEventMessage,
        (plugin, config, message) -> {
            boolean isMessageEnabled = config.subscribeEventMessageEnabled();

            // guard: also check whether the sub should be shown when it was gifted
            if (message instanceof ChannelStartSubscription) {
                ChannelStartSubscription channelStartSubscription = (ChannelStartSubscription) message;
                boolean isGifted = channelStartSubscription.is_gift;
                boolean shouldShowMessageOnGifted = config.subscribeEventMessageOnGiftEnabled();

                return isMessageEnabled && (!isGifted || shouldShowMessageOnGifted);
            }

            return isMessageEnabled;
        }
    ),
    CONTINUE_SUBSCRIPTION("channel.subscription.message", "Resub", true, 1, ChannelContinueSubscription.class, (p, c, m) -> true, TwitchLiveLoadoutConfig::resubscribeEventMessage, (plugin, config, message) -> config.resubscribeEventMessageEnabled()),
    GIFT_SUBSCRIPTION("channel.subscription.gift", "Gift", true, 1, ChannelGiftSubscription.class, (p, c, m) -> true, TwitchLiveLoadoutConfig::giftSubscriptionEventMessage, (plugin, config, message) -> config.giftSubscriptionEventMessageEnabled()),
    RAID("channel.raid", "Raid", true, 1, ChannelRaid.class, (p, c, m) -> true, TwitchLiveLoadoutConfig::raidEventMessage, (plugin, config, message) -> config.raidEventMessageEnabled()),
    FOLLOW(
    "channel.follow", "Follow", true, 2, ChannelFollow.class,
        (plugin, config, message) -> {
            ChannelFollow followMessage = (ChannelFollow) message;
            String followerId = followMessage.user_id;
            TwitchEventSubListener twitchEventSubListener = plugin.getTwitchEventSubListener();

            // guard: check if this follower has already followed recently
            if (twitchEventSubListener.hasHandledFollowerId(followerId))
            {
                log.info("An EventSub follow event was skipped, because the user has already followed the channel recently, follower username: "+ followMessage.user_name);
                return false;
            }

            twitchEventSubListener.handleFollowerId(followerId);
            return true;
        },
        TwitchLiveLoadoutConfig::followEventMessage, (plugin, config, message) -> config.followEventMessageEnabled()),
    ADD_MODERATOR("channel.moderator.add", "Add Mod", true, 1, ChannelAddModerator.class,  (p, c, m) -> true,TwitchLiveLoadoutConfig::addedModMessage, (plugin, config, message) -> config.addedModMessageEnabled()),
    REMOVE_MODERATOR("channel.moderator.remove", "Remove Mod", true, 1, ChannelRemoveModerator.class, (p, c, m) -> true, TwitchLiveLoadoutConfig::removedModMessage, (plugin, config, message) -> config.removedModMessageEnabled()),
    HYPE_TRAIN_BEGIN("channel.hype_train.begin", "Start Hype Train", true, 1, HypeTrainBegin.class, (p, c, m) -> true, TwitchLiveLoadoutConfig::beginHypeTrainMessage, (plugin, config, message) -> config.beginHypeTrainMessageEnabled()),
    HYPE_TRAIN_PROGRESS("channel.hype_train.progress", "Increase Hype Train", true, 1, HypeTrainProgress.class, (p, c, m) -> true, TwitchLiveLoadoutConfig::progressHypeTrainMessage, (plugin, config, message) -> config.progressHypeTrainMessageEnabled()),
    HYPE_TRAIN_END("channel.hype_train.end", "Stop Hype Train", true, 1, HypeTrainEnd.class, (p, c, m) -> true, TwitchLiveLoadoutConfig::endHypeTrainMessage, (plugin, config, message) -> config.endHypeTrainMessageEnabled()),
    CHARITY_CAMPAIGN_DONATE("channel.charity_campaign.donate", "Charity Donation", true, 1, CharityCampaignDonate.class, (p, c, m) -> true, TwitchLiveLoadoutConfig::donateCharityCampaignMessage, (plugin, config, message) -> config.donateCharityCampaignMessageEnabled()),
    CHARITY_CAMPAIGN_START("channel.charity_campaign.start", "Start Charity Campaign", true, 1, CharityCampaignStart.class, (p, c, m) -> true, TwitchLiveLoadoutConfig::startCharityCampaignMessage, (plugin, config, message) -> config.startCharityCampaignMessageEnabled()),
    CHARITY_CAMPAIGN_PROGRESS("channel.charity_campaign.progress", "Progress Charity Campaign", true, 1, CharityCampaignProgress.class, (p, c, m) -> true, TwitchLiveLoadoutConfig::progressCharityCampaignMessage, (plugin, config, message) -> config.progressCharityCampaignMessageEnabled()),
    CHARITY_CAMPAIGN_STOP("channel.charity_campaign.stop", "Stop Charity Campaign", true, 1, CharityCampaignStop.class, (p, c, m) -> true, TwitchLiveLoadoutConfig::stopCharityCampaignMessage, (plugin, config, message) -> config.stopCharityCampaignMessageEnabled()),

    // disabled for now because it requires extension token
    EXTENSION_BITS_TRANSACTION("extension.bits_transaction.create", "Bits Donation", false, 1, ExtensionBitsTransaction.class, (p, c, m) -> true, c -> null, (p, c, m) -> false),

    // disabled for now because it requires full moderation access, which might a bit too much (with the token being able to do moderation)
    BAN("channel.ban", "Ban Viewer", false, 1, ChannelBan.class, (p, c, m) -> true, c -> null, (p, c, m) -> false),
    UNBAN("channel.unban", "Unban Viewer", false, 1, ChannelUnban.class, (p, c, m) -> true, c -> null, (p, c, m) -> false),
    ;

    private final String type;
    private final String name;
    private final boolean enabled;
    private final int version;
    private final BooleanConfigValueGetter shouldHandleEventGetter;
    private final Class<? extends BaseMessage> messageClass;
    private final StringConfigValueGetter messageGetter;
    private final BooleanConfigValueGetter defaultMessageEnabledGetter;

    TwitchEventSubType(String type, String name, boolean enabled, int version, Class<? extends BaseMessage> messageClass, BooleanConfigValueGetter shouldHandleEventGetter, StringConfigValueGetter messageGetter, BooleanConfigValueGetter defaultMessageEnabledGetter)
    {
        this.type = type;
        this.name = name;
        this.enabled = enabled;
        this.version = version;
        this.shouldHandleEventGetter = shouldHandleEventGetter;
        this.messageClass = messageClass;
        this.messageGetter = messageGetter;
        this.defaultMessageEnabledGetter = defaultMessageEnabledGetter;
    }

    public static TwitchEventSubType getByType(String rawType)
    {
        for (TwitchEventSubType type : TwitchEventSubType.values())
        {
          if (type.getType().equals(rawType))
          {
              return type;
          }
        }

        return null;
    }

    public interface StringConfigValueGetter {
        String execute(TwitchLiveLoadoutConfig config);
    }

    public interface BooleanConfigValueGetter {
        Boolean execute(TwitchLiveLoadoutPlugin plugin, TwitchLiveLoadoutConfig config, BaseMessage eventSubMessage);
    }
}

package com.twitchliveloadout.twitch.eventsub;

import com.google.gson.Gson;
import com.google.gson.JsonObject;
import com.google.gson.JsonParser;
import com.twitchliveloadout.TwitchLiveLoadoutConfig;
import com.twitchliveloadout.TwitchLiveLoadoutPlugin;
import com.twitchliveloadout.twitch.TwitchApi;
import lombok.extern.slf4j.Slf4j;
import okhttp3.*;

import java.time.Instant;
import java.util.concurrent.TimeUnit;

@Slf4j
public class TwitchEventSubClient {
   public final static String DEFAULT_TWITCH_WEBSOCKET_URL = "wss://eventsub.wss.twitch.tv/ws";
//public final static String DEFAULT_TWITCH_WEBSOCKET_URL = "ws://127.0.0.1:8080/ws";

    private final TwitchLiveLoadoutPlugin plugin;
    private final TwitchLiveLoadoutConfig config;
    private final TwitchApi twitchApi;
    private final Gson gson;
    private final OkHttpClient httpClientTemplate;
    private WebSocket webSocket;
    private String sessionId = "";
    private int keepAliveTimeoutS = 20;
    private Instant lastKeepAliveAt = Instant.now();
    private boolean socketOpen = false;

    private final TwitchEventSubListener listener;

    public TwitchEventSubClient(TwitchLiveLoadoutPlugin plugin, TwitchLiveLoadoutConfig config, TwitchApi twitchApi, Gson gson, OkHttpClient httpClientTemplate, TwitchEventSubListener listener)
    {
        this.plugin = plugin;
        this.config = config;
        this.twitchApi = twitchApi;
        this.gson = gson;
        this.httpClientTemplate = httpClientTemplate;
        this.listener = listener;

        // instantly attempt to connect
        connect(DEFAULT_TWITCH_WEBSOCKET_URL);
    }

    private synchronized void connect(String webSocketUrl)
    {
        plugin.logSupport("Initialising the websocket for url: "+ webSocketUrl);

        // guard: disconnect when one already exists
        if (webSocket != null) {
            disconnect();
        }

        OkHttpClient client = createHttpClient(10_000);
        Request request = new Request.Builder().url(webSocketUrl).build();
        webSocket = client.newWebSocket(request, webSocketListener);
    }

    public synchronized void reconnect(String webSocketUrl)
    {
        connect(webSocketUrl);
    }

    public void disconnect()
    {
        if (socketOpen) {
            webSocket.close(1000, null);
        }
    }

    private final WebSocketListener webSocketListener = new WebSocketListener() {
        @Override
        public void onOpen(WebSocket webSocket, Response response)
        {
            plugin.logSupport("Successfully opened Twitch websocket...");
            listener.clearActiveSubscriptionTypes();
            socketOpen = true;
        }

        @Override
        public void onMessage(WebSocket webSocket, String rawMessage) {
            try {
                plugin.logSupport("Received new Twitch websocket message: "+ rawMessage);

                JsonObject message = (new JsonParser()).parse(rawMessage).getAsJsonObject();
                JsonObject metadata = message.getAsJsonObject("metadata");
                JsonObject payload = message.getAsJsonObject("payload");
                String messageId = metadata.get("message_id").getAsString();
                String messageType = metadata.get("message_type").getAsString();

                plugin.logSupport("Handling Twitch websocket message with type: "+ messageType);
                switch (messageType) {

                    // acknowledge that this client works and store the session ID for future subscriptions
                    case "session_welcome":
                        JsonObject welcomeSession = payload.getAsJsonObject("session");
                        sessionId = welcomeSession.get("id").getAsString();
                        keepAliveTimeoutS = welcomeSession.get("keepalive_timeout_seconds").getAsInt();

                        // the socket is ready when a session ID has been received
                        listener.onReady(sessionId);
                        break;

                    // keepalive message from the server to show it is still a valid connection
                    case "session_keepalive":
                        lastKeepAliveAt = Instant.now();
                        break;

                    // force the session to reconnect to a new URL
                    case "session_reconnect":
                        JsonObject reconnectSession = payload.getAsJsonObject("session");
                        String reconnectUrl = reconnectSession.get("reconnect_url").getAsString();

                        // override to the new URL and reconnect
                        reconnect(reconnectUrl);
                        break;

                    // message when a subscription was revoked for whatever reason
                    case "revocation":
                        String rawSubscriptionType = metadata.get("subscription_type").getAsString();
                        TwitchEventSubType subscriptionType = TwitchEventSubType.getByType(rawSubscriptionType);
                        log.info("A subscription was revoked from the Twitch websocket: "+ rawSubscriptionType);
                        listener.revokeActiveSubscriptionType(subscriptionType);
                        break;

                    // message for an event we've been subscribed to
                    case "notification":
                        String rawEventType = metadata.get("subscription_type").getAsString();
                        TwitchEventSubType eventType = TwitchEventSubType.getByType(rawEventType);
                        JsonObject eventPayload = payload.getAsJsonObject("event");

                        if (eventType == null)
                        {
                            plugin.logSupport("Could not find known Twitch EventSub type in enum, skipping it: "+ rawEventType);
                            return;
                        }

                        listener.onEvent(messageId, eventType, eventPayload);
                        break;
                }
            } catch (Exception exception) {
                log.warn("Could not handle Twitch websocket message due to error: ", exception);
                log.warn("The websocket message that was skipped is: {}", rawMessage);
            }
        }

        @Override
        public void onClosing(WebSocket webSocket, int code, String reason) {
            plugin.logSupport("Twitch websocket is closing due to: "+ reason);
        }

        @Override
        public void onClosed(WebSocket webSocket, int code, String reason) {
            plugin.logSupport("Twitch websocket was closed due to: "+ reason);
            listener.clearActiveSubscriptionTypes();
            socketOpen = false;
        }

        @Override
        public void onFailure(WebSocket webSocket, Throwable t, Response response) {
            plugin.logSupport("Twitch websocket failed with error: "+ t.getMessage());
        }
    };

    public boolean isConnected()
    {
        return webSocket != null
            && socketOpen
            && !sessionId.isEmpty()
            && listener.hasActiveSubscriptions()
            && Instant.now().minusSeconds(keepAliveTimeoutS).isBefore(lastKeepAliveAt);
    }

    public boolean isConnecting()
    {
        return webSocket != null
            && socketOpen
            && (sessionId.isEmpty() || !listener.hasActiveSubscriptions());
    }

    private OkHttpClient createHttpClient(int timeoutMs)
    {
        return httpClientTemplate
            .newBuilder()
            .callTimeout(timeoutMs, TimeUnit.MILLISECONDS)
            .build();
    }
}

package com.twitchliveloadout.twitch.eventsub.messages;

public class ChannelRaid extends BaseMessage {
    public String from_broadcaster_user_id;
    public String from_broadcaster_user_login;
    public String from_broadcaster_user_name;
    public String to_broadcaster_user_id;
    public String to_broadcaster_user_login;
    public String to_broadcaster_user_name;
    public Integer viewers;
}

package com.twitchliveloadout.twitch.eventsub.messages;

public class CharityCampaignAmount {
    public Integer value = 0;
    public Integer decimal_places = 0;
    public String currency;

    /**
     * The amount of with decimal places to get the real amount. Reference:
     * https://dev.twitch.tv/docs/eventsub/eventsub-reference/#charity-donation-event
     */
    public Double getCurrencyAmount() {
        return value / Math.pow(10, decimal_places);
    }
}

package com.twitchliveloadout.twitch.eventsub.messages;

public class ChannelContinueSubscription extends BaseUserInfo {
    public String tier;
    public ChannelMessage message;
    public Integer cumulative_months;
    public Integer streak_months;
    public Integer duration_months;
}

package com.twitchliveloadout.twitch.eventsub.messages;

public class ChannelPointsReward {
    public String id;
    public String title;
    public Integer cost;
    public String prompt;
}

package com.twitchliveloadout.twitch.eventsub.messages;

public class HypeTrainProgress extends BaseHypeTrainWithGoal {
    public String expires_at;
    public HypeTrainContribution last_contribution;
}

package com.twitchliveloadout.twitch.eventsub.messages;

public class ChannelPointsRedeem extends BaseUserInfo {
    public String user_input;
    public String status;
    public ChannelPointsReward reward;
    public String redeemed_at;
}

package com.twitchliveloadout.twitch.eventsub.messages;

import java.util.ArrayList;

public class BaseHypeTrain extends BaseBroadcasterInfo {
    public Integer level;
    public Integer total;
    public ArrayList<HypeTrainContribution> top_contributions;
    public String started_at;
}

package com.twitchliveloadout.twitch.eventsub.messages;

public class BaseBroadcasterInfo extends BaseMessage {
    public String broadcaster_user_id;
    public String broadcaster_user_login;
    public String broadcaster_user_name;
}

package com.twitchliveloadout.twitch.eventsub.messages;

public class ChannelUnban extends ModeratorUserInfo {
}

package com.twitchliveloadout.twitch.eventsub.messages;

public class CharityCampaignAmountInfo extends BaseCharityCampaignInfo {
    public CharityCampaignAmount current_amount;
    public CharityCampaignAmount target_amount;
}

package com.twitchliveloadout.twitch.eventsub.messages;

public class BaseMessage {
    public String id;
}

package com.twitchliveloadout.twitch.eventsub.messages;

public class BaseHypeTrainWithGoal extends BaseHypeTrain {
    public Integer goal;
    public Integer progress;
}

package com.twitchliveloadout.twitch.eventsub.messages;

public class ChannelFollow extends BaseUserInfo {
    public String followed_at;
}

package com.twitchliveloadout.twitch.eventsub.messages;

public class CharityCampaignStart extends CharityCampaignAmountInfo {
    public String started_at;
}

package com.twitchliveloadout.twitch.eventsub.messages;

public class ChannelEmote {
    public int begin;
    public int end;
    public String id;
}

package com.twitchliveloadout.twitch.eventsub.messages;

public class ChannelGiftSubscription extends BaseUserInfo {
    public Integer total;
    public String tier;
    public Integer cumulative_total;
    public Boolean is_anonymous;
}

package com.twitchliveloadout.twitch.eventsub.messages;

public class ChannelStartSubscription extends BaseUserInfo {
    public String tier;
    public Boolean is_gift; // always false?
}

package com.twitchliveloadout.twitch.eventsub.messages;

import java.util.ArrayList;

public class ChannelMessage {
    public String text;
    public ArrayList<ChannelEmote> emotes;
}

package com.twitchliveloadout.twitch.eventsub.messages;

public class HypeTrainBegin extends BaseHypeTrainWithGoal {
    public String expires_at;
    public HypeTrainContribution last_contribution;
}

package com.twitchliveloadout.twitch.eventsub.messages;

public class HypeTrainEnd extends BaseHypeTrain {
    public String ended_at;
    public String cooldown_ends_at;

}

package com.twitchliveloadout.twitch.eventsub.messages;

public class ChannelBan extends ModeratorUserInfo {
    public String reason;
    public String banned_at;
    public String ends_at;
    public Boolean is_permanent;
}

package com.twitchliveloadout.twitch.eventsub.messages;

public class CharityCampaignDonate extends BaseCharityCampaignInfo {
    public String campaign_id;
    public CharityCampaignAmount amount;
}

package com.twitchliveloadout.twitch.eventsub.messages;

public class ExtensionBitsProduct {
    public String name;
    public String sku;
    public Integer bits;
    public Boolean in_development;
}

package com.twitchliveloadout.twitch.eventsub.messages;

public class HypeTrainContribution {
    public String user_id;
    public String user_login;
    public String user_name;
    public String type;
    public int total;
}

package com.twitchliveloadout.twitch.eventsub.messages;

public class ChannelRemoveModerator extends BaseUserInfo {
    // empty
}

package com.twitchliveloadout.twitch.eventsub.messages;

public class ExtensionBitsTransaction extends BaseUserInfo {
    public String extension_client_id;
    public ExtensionBitsProduct product;
}

package com.twitchliveloadout.twitch.eventsub.messages;

public class CharityCampaignProgress extends CharityCampaignAmountInfo {

}

package com.twitchliveloadout.twitch.eventsub.messages;

public class BaseCharityCampaignInfo extends BaseUserInfo {
    public String charity_name;
    public String charity_description;
    public String charity_logo;
    public String charity_website;
}

package com.twitchliveloadout.twitch.eventsub.messages;

public class ModeratorUserInfo extends BaseUserInfo {
    public String moderator_user_id;
    public String moderator_user_login;
    public String moderator_user_name;
}

package com.twitchliveloadout.twitch.eventsub.messages;

public class BaseUserInfo extends BaseBroadcasterInfo {
    public String user_id;
    public String user_login;
    public String user_name;
}

package com.twitchliveloadout.twitch.eventsub.messages;

public class CharityCampaignStop extends CharityCampaignAmountInfo {
    public String stopped_at;
}

package com.twitchliveloadout.twitch.eventsub.messages;

public class ChannelAddModerator extends BaseUserInfo {
    // empty
}

package com.twitchliveloadout.twitch.eventsub;

import com.google.gson.Gson;
import com.google.gson.JsonObject;
import com.twitchliveloadout.TwitchLiveLoadoutConfig;
import com.twitchliveloadout.TwitchLiveLoadoutPlugin;
import com.twitchliveloadout.marketplace.MarketplaceManager;
import com.twitchliveloadout.marketplace.products.TwitchProduct;
import com.twitchliveloadout.marketplace.products.TwitchProductCost;
import com.twitchliveloadout.marketplace.transactions.TwitchTransaction;
import com.twitchliveloadout.marketplace.transactions.TwitchTransactionOrigin;
import com.twitchliveloadout.twitch.TwitchApi;
import com.twitchliveloadout.twitch.eventsub.messages.*;
import lombok.extern.slf4j.Slf4j;

import java.time.Instant;
import java.util.concurrent.CopyOnWriteArrayList;

import static com.twitchliveloadout.TwitchLiveLoadoutConfig.EVENT_SUB_HANDLED_FOLLOWER_IDS;

@Slf4j
public class TwitchEventSubListener {
    private final TwitchLiveLoadoutPlugin plugin;
    private final TwitchLiveLoadoutConfig config;
    private final TwitchApi twitchApi;
    private final Gson gson;

    /**
     * List of all handled follow events this session, identified by follower ID as it's very easy to duplicate the event.
     * This is the dedup mechanism, which can only be done client-side.
     */
    private final CopyOnWriteArrayList<String> handledFollowerIds = new CopyOnWriteArrayList<>();

    /**
     * List of all the active Twitch EventSub types
     */
    private final CopyOnWriteArrayList<TwitchEventSubType> activeSubscriptionTypes = new CopyOnWriteArrayList<>();

    public TwitchEventSubListener(TwitchLiveLoadoutPlugin plugin, TwitchLiveLoadoutConfig config, TwitchApi twitchApi, Gson gson)
    {
        this.plugin = plugin;
        this.config = config;
        this.twitchApi = twitchApi;
        this.gson = gson;
    }

    public void onReady(String sessionId)
    {

        // once the socket is ready we can create the subscriptions
        for (TwitchEventSubType type : TwitchEventSubType.values())
        {

            // guard: skip when it is not enabled
            if (!type.isEnabled())
            {
                continue;
            }

            twitchApi.createEventSubSubscription(
                sessionId,
                type,
                (response) -> {
                    activeSubscriptionTypes.add(type);
                },
                (error) -> {
                    activeSubscriptionTypes.remove(type);
                }
            );
        }
    }

    public void onEvent(String messageId, TwitchEventSubType type, JsonObject payload)
    {
        BaseMessage message = gson.fromJson(payload, type.getMessageClass());
        TwitchTransaction twitchTransaction = createTransactionFromEventMessage(messageId, type, message);

        // guard: check whether the settings for handling events are disabled
        if (!config.marketplaceChannelEventsEnabled())
        {
            log.info("Skipped an EventSub event because it is disabled globally, type: "+ type.getName());
            return;
        }

        // guard: check whether this event in particular should be handled
        if (!type.getShouldHandleEventGetter().execute(plugin, config, message))
        {
            log.info("Skipped an EventSub event through a specific message check, type: "+ type.getName());
            return;
        }

        // handle types that need to extend the twitch transaction in any way
        switch (type) {
            case CHANNEL_POINTS_REDEEM:
                expandTransactionForChannelPointsRedeem(twitchTransaction, (ChannelPointsRedeem) message);
                break;
            case CHARITY_CAMPAIGN_DONATE:
                expandTransactionForCharityCampaignDonation(twitchTransaction, (CharityCampaignDonate) message);
                break;
        }

        addTwitchTransaction(twitchTransaction);
    }

    private void expandTransactionForChannelPointsRedeem(TwitchTransaction twitchTransaction, ChannelPointsRedeem redeem)
    {
        ChannelPointsReward reward = redeem.reward;
        TwitchProduct twitchProduct = twitchTransaction.product_data;
        TwitchProductCost twitchProductCost = twitchProduct.cost;

        // overrides specific for channel points redeem
        twitchTransaction.id = redeem.id;
        twitchProductCost.amount = reward.cost.doubleValue();
        twitchProductCost.type = "channel points";
        twitchProduct.sku = reward.id;
        twitchProduct.displayName = reward.title;
    }

    private void expandTransactionForCharityCampaignDonation(TwitchTransaction twitchTransaction, CharityCampaignDonate donation)
    {
        CharityCampaignAmount amount = donation.amount;
        String charityName = donation.charity_name;
        TwitchProduct twitchProduct = twitchTransaction.product_data;
        TwitchProductCost twitchProductCost = twitchProduct.cost;

        // overrides specific for charity donations
        twitchTransaction.id = donation.id;
        twitchProductCost.amount = amount.getCurrencyAmount();
        twitchProductCost.type = amount.currency;
        twitchProduct.sku = donation.id;
        twitchProduct.displayName = "Donation to "+ charityName;
    }

    private void addTwitchTransaction(TwitchTransaction transaction)
    {
        MarketplaceManager marketplaceManager = plugin.getMarketplaceManager();

        // guard: check whether the parameters are valid to handle the transaction
        if (marketplaceManager == null || transaction == null)
        {
            return;
        }

        plugin.logSupport("Adding a new Twitch transaction based on an EventSub event, transaction ID: "+ transaction.id);
        marketplaceManager.handleCustomTransaction(transaction);
    }

    private <T extends BaseMessage> TwitchTransaction createTransactionFromEventMessage(String messageId, TwitchEventSubType eventType, T message)
    {
        String nowString = Instant.now().toString();
        TwitchTransaction twitchTransaction = new TwitchTransaction();
        TwitchProduct twitchProduct = new TwitchProduct();
        TwitchProductCost twitchProductCost = new TwitchProductCost();

        twitchTransaction.id = messageId;
        twitchTransaction.timestamp = nowString;

        twitchProduct.sku = eventType.getType();
        twitchProduct.cost = twitchProductCost;
        twitchTransaction.product_data = twitchProduct;
        twitchTransaction.product_type = eventType.getType();

        twitchTransaction.handled_at = Instant.now().toString();
        twitchTransaction.origin = TwitchTransactionOrigin.EVENT_SUB;
        twitchTransaction.eventSubType = eventType;
        twitchTransaction.eventSubMessage = message;

        // add user info when available
        if (message instanceof BaseUserInfo)
        {
            BaseUserInfo baseUserInfo = (BaseUserInfo) message;
            twitchTransaction.broadcaster_id = baseUserInfo.broadcaster_user_id;
            twitchTransaction.broadcaster_login = baseUserInfo.broadcaster_user_login;
            twitchTransaction.broadcaster_name = baseUserInfo.broadcaster_user_name;
            twitchTransaction.user_id = baseUserInfo.user_id;
            twitchTransaction.user_login = baseUserInfo.user_login;
            twitchTransaction.user_name = baseUserInfo.user_name;
        }

        return twitchTransaction;
    }

    public void revokeActiveSubscriptionType(TwitchEventSubType type)
    {
        activeSubscriptionTypes.remove(type);
    }

    public void clearActiveSubscriptionTypes()
    {
        activeSubscriptionTypes.clear();
    }

    public boolean hasActiveSubscriptions()
    {
        return !activeSubscriptionTypes.isEmpty();
    }

    public void handleFollowerId(String followerId)
    {
        handledFollowerIds.add(followerId);

        // TODO: consider making this persistent to prevent people unfollowing + following upon each RL session.
        // currently viewers can trigger a valid follow event each fresh RL session.
        // plugin.setConfiguration(EVENT_SUB_HANDLED_FOLLOWER_IDS);
    }

    public boolean hasHandledFollowerId(String followerId)
    {
        return handledFollowerIds.contains(followerId);
    }
}

package com.twitchliveloadout.twitch;

import lombok.Getter;

public enum TwitchVisibilityEntry {
    ALWAYS("normal"),
    HOVER("hover");

    @Getter
    private final String key;

    TwitchVisibilityEntry(String key)
    {
        this.key = key;
    }
}

package com.twitchliveloadout.twitch;

import lombok.Getter;

public enum TwitchThemeEntry {
	LIGHT("light"),
	DARK("dark");

	@Getter
	private final String key;

	TwitchThemeEntry(String key)
	{
		this.key = key;
	}
}

package com.twitchliveloadout.items;

import net.runelite.api.Item;

public class PricedItem
{
	private final Item item;
	private final long price;
	private final int slotId;
	private final int tabId;

	PricedItem(Item item, long price, int slotId, int tabId)
	{
		this.item = item;
		this.price = price;
		this.slotId = slotId;
		this.tabId = tabId;
	}

	public Item getItem() {
		return item;
	}

	public long getPrice() {
		return price;
	}

	public int getSlotId()
	{
		return slotId;
	}

	public int getTabId()
	{
		return tabId;
	}
}

package com.twitchliveloadout.items;

import com.twitchliveloadout.TwitchLiveLoadoutConfig;
import com.twitchliveloadout.TwitchLiveLoadoutPlugin;
import com.twitchliveloadout.twitch.TwitchState;
import net.runelite.api.*;
import net.runelite.api.events.ItemContainerChanged;
import net.runelite.client.game.ItemManager;

import java.util.Arrays;
import java.util.Collections;
import java.util.List;
import java.util.concurrent.CopyOnWriteArrayList;

public class ItemStateManager {

	public final static int MAX_BANK_ITEMS = 5000;
	public final static int LOOTING_BAG_CONTAINER_ID = 516;

	private final TwitchLiveLoadoutPlugin plugin;
	private final TwitchState twitchState;
	private final Client client;
	private final ItemManager itemManager;
	private final TwitchLiveLoadoutConfig config;

	private static final List<Integer> BANK_TAB_VARBITS = Arrays.asList(
			Varbits.BANK_TAB_ONE_COUNT,
			Varbits.BANK_TAB_TWO_COUNT,
			Varbits.BANK_TAB_THREE_COUNT,
			Varbits.BANK_TAB_FOUR_COUNT,
			Varbits.BANK_TAB_FIVE_COUNT,
			Varbits.BANK_TAB_SIX_COUNT,
			Varbits.BANK_TAB_SEVEN_COUNT,
			Varbits.BANK_TAB_EIGHT_COUNT,
			Varbits.BANK_TAB_NINE_COUNT
	);

	public ItemStateManager(TwitchLiveLoadoutPlugin plugin, TwitchState twitchState, Client client, ItemManager itemManager, TwitchLiveLoadoutConfig config)
	{
		this.plugin = plugin;
		this.twitchState = twitchState;
		this.client = client;
		this.itemManager = itemManager;
		this.config = config;
	}

	public void onItemContainerChanged(ItemContainerChanged event)
	{
		final ItemContainer container = event.getItemContainer();
		final boolean isInventory = isItemContainer(event, InventoryID.INVENTORY);
		final boolean isEquipment = isItemContainer(event, InventoryID.EQUIPMENT);
		final boolean isBank = isItemContainer(event, InventoryID.BANK);
		final boolean isLootingBag = isItemContainer(event, LOOTING_BAG_CONTAINER_ID);

		// guard: block item containers that are not applicable for the state
		if (!isInventory && !isEquipment && !isBank && !isLootingBag)
		{
			return;
		}

		final Item[] items = container.getItems();
		long totalPrice = getTotalPrice(items);

		if (config.inventoryEnabled() && isInventory)
		{
			twitchState.setInventoryItems(items, totalPrice);
		}
		else if (config.equipmentEnabled() && isEquipment)
		{
			twitchState.setEquipmentItems(items, totalPrice);
		}
		else if (config.bankEnabled() && isBank)
		{
			setSlicedBankItems(items, totalPrice);
		}
		else if (config.lootingBagEnabled() && isLootingBag)
		{
			twitchState.setLootingBagItems(items, totalPrice);
		}

		// update the weight for specific container changes
		// NOTE: looting bag does not add weight
		if (config.weightEnabled() && (isInventory || isEquipment))
		{
			final int weight = client.getWeight();
			twitchState.setWeight(weight);
		}
	}

	public int[] getBankTabAmounts()
	{
		final int tabAmount = BANK_TAB_VARBITS.size();
		final int[] amounts = new int[tabAmount];

		for (int tabIndex = 0; tabIndex < tabAmount; tabIndex++)
		{
			final int itemAmount = client.getVarbitValue(BANK_TAB_VARBITS.get(tabIndex));
			amounts[tabIndex] = itemAmount;
		}

		return amounts;
	}

	public boolean isItemContainer(ItemContainerChanged event, InventoryID container)
	{
		return isItemContainer(event, container.getId());
	}

	public boolean isItemContainer(ItemContainerChanged event, int containerId)
	{
		final int eventContainerId = event.getContainerId();
		return eventContainerId == containerId;
	}

	public void setSlicedBankItems(Item[] items, long totalPrice)
	{
		final int[] tabAmounts = getBankTabAmounts();
		final int maxItemAmount = getMaxBankItemAmount();
		final List<PricedItem> highestPricedItems = getHighestPricedItems(items, tabAmounts, maxItemAmount);
		final Item[] selectedItems = new Item[highestPricedItems.size()];
		final int[] selectedTabAmounts = new int[tabAmounts.length];

		// deduce the tab amounts based on the new selected items
		// and convert the list to a plain Item array
		for (int pricedItemIndex = 0; pricedItemIndex < highestPricedItems.size(); pricedItemIndex++)
		{
			PricedItem pricedItem = highestPricedItems.get(pricedItemIndex);
			final Item selectedItem = pricedItem.getItem();
			final int tabId = pricedItem.getTabId();

			selectedItems[pricedItemIndex] = selectedItem;

			if (tabId >= 0) {
				selectedTabAmounts[tabId] += 1;
			}
		}

		twitchState.setBankItems(selectedItems, selectedTabAmounts);
		twitchState.setBankItemsPrice(totalPrice);
	}

	public CopyOnWriteArrayList<PricedItem> getPricedItems(Item[] items)
	{
		return getPricedItems(items, new int[0]);
	}

	public CopyOnWriteArrayList<PricedItem> getPricedItems(Item[] items, int[] tabAmounts)
	{
		final CopyOnWriteArrayList<PricedItem> pricedItems = new CopyOnWriteArrayList<>();

		for (int slotId = 0; slotId < items.length; slotId++)
		{
			Item item = items[slotId];
			int itemId = item.getId();
			int itemQuantity = item.getQuantity();

			// translate placeholder IDs to their actual items
			if (isPlaceholderItem(itemId))
			{
				itemId = itemManager.getItemComposition(itemId).getPlaceholderId();
				itemQuantity = 0;
				item = new Item(itemId, itemQuantity);
			}

			final long itemPrice = ((long) itemManager.getItemPrice(itemId)) * itemQuantity;
			final int tabId = getItemTabId(slotId, tabAmounts);
			final PricedItem pricedItem = new PricedItem(item, itemPrice, slotId, tabId);

			pricedItems.add(pricedItem);
		}

		return pricedItems;
	}

	public boolean isPlaceholderItem(int itemId)
	{
		return itemManager.getItemComposition(itemId).getPlaceholderTemplateId() != -1;
	}

	public int getItemTabId(int slotId, int[] tabAmounts)
	{
		int totalAmount = 0;
		int remainingTabId = -1;

		for (int tabId = 0; tabId < tabAmounts.length; tabId++)
		{
			final int tabAmount = tabAmounts[tabId];
			totalAmount += tabAmount;

			if (slotId < totalAmount) {
				return tabId;
			}
		}

		return remainingTabId;
	}

	public long getTotalPrice(Item[] items)
	{
		long totalPrice = 0;
		final CopyOnWriteArrayList<PricedItem> pricedItems = getPricedItems(items);

		for (PricedItem pricedItem : pricedItems)
		{
			totalPrice += pricedItem.getPrice();
		}

		return totalPrice;
	}

	public List<PricedItem> getHighestPricedItems(Item[] items, int[] tabAmounts, int maxAmount)
	{
		final CopyOnWriteArrayList<PricedItem> pricedItems = getPricedItems(items, tabAmounts);
		pricedItems.sort(new ItemPriceSorter());
		final int itemAmount = pricedItems.size();

		if (maxAmount > itemAmount)
		{
			maxAmount = itemAmount;
		}

		final List<PricedItem> highestPricedItems = pricedItems.subList(0, maxAmount);
		highestPricedItems.sort(new ItemSlotIdSorter());

		return highestPricedItems;
	}

	public int getMaxBankItemAmount()
	{
		int maxAmount = config.bankItemsAmount();

		if (maxAmount > MAX_BANK_ITEMS)
		{
			maxAmount = MAX_BANK_ITEMS;
		}

		if (maxAmount < 0)
		{
			maxAmount = 0;
		}

		return maxAmount;
	}
}

package com.twitchliveloadout.items;

import net.runelite.api.widgets.Widget;

public class CollectionLogItem {
	private final int id;
	private final int quantity;

	public CollectionLogItem(Widget itemWidget)
	{
		id = itemWidget.getItemId();
		quantity = itemWidget.getOpacity() == 0 ? itemWidget.getItemQuantity() : 0;
	}

	public int getId()
	{
		return id;
	}

	public int getQuantity()
	{
		return quantity;
	}
}

package com.twitchliveloadout.items;

import com.google.gson.*;
import com.twitchliveloadout.TwitchLiveLoadoutPlugin;
import com.twitchliveloadout.twitch.TwitchState;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.ScriptID;
import net.runelite.api.events.ScriptPostFired;
import net.runelite.api.events.VarbitChanged;
import net.runelite.api.widgets.ComponentID;
import net.runelite.api.widgets.Widget;
import net.runelite.client.events.NpcLootReceived;

import java.util.*;
import java.util.concurrent.CopyOnWriteArrayList;
import java.util.concurrent.ScheduledFuture;

@Slf4j
public class CollectionLogManager {
	private final TwitchLiveLoadoutPlugin plugin;
	private final TwitchState twitchState;
	private final Client client;

	private static final int COLLECTION_LOG_ID = 621;
	private static final int COLLECTION_LOG_CONTAINER_ID = 1;
	private static final int COLLECTION_LOG_TITLE_INDEX = 1;
	private static final int COLLECTION_LOG_BOSSES_TAB = 4;
	private static final int COLLECTION_LOG_RAIDS_TAB = 5;
	private static final int COLLECTION_LOG_CLUES_TAB = 6;
	private static final int COLLECTION_LOG_MINIGAMES_TAB = 7;
	private static final int COLLECTION_LOG_TAB_TEXT_INDEX = 3;
	private static final int COLLECTION_LOG_TAB_INACTIVE_COLOR = 16750623;
	private static final int COLLECTION_LOG_TAB_ACTIVE_COLOR = 16754735;
	private static final int COLLECTION_LOG_OTHER_TAB = 8;
	private static final int[] COLLECTION_LOG_CATEGORY_VARBIT_IDS = {6905, 6906};
	private static final int[] COLLECTION_LOG_TABS = {
		COLLECTION_LOG_BOSSES_TAB,
		COLLECTION_LOG_RAIDS_TAB,
		COLLECTION_LOG_CLUES_TAB,
		COLLECTION_LOG_MINIGAMES_TAB,
		COLLECTION_LOG_OTHER_TAB,
	};
	private ScheduledFuture scheduledUpdateCurrentCategory = null;
	public static final String COUNTERS_KEY_NAME = "c";
	public static final String ITEMS_KEY_NAME = "i";

	public CollectionLogManager(TwitchLiveLoadoutPlugin plugin, TwitchState twitchState, Client client)
	{
		this.plugin = plugin;
		this.twitchState = twitchState;
		this.client = client;
	}

	public void onScriptPostFired(ScriptPostFired scriptPostFired)
	{
		if (scriptPostFired.getScriptId() == ScriptID.COLLECTION_DRAW_LIST)
		{
			scheduleUpdateCurrentCategory();
		}
	}

	public void onVarbitChanged(VarbitChanged varbitChanged)
	{
		int varbitId = varbitChanged.getVarbitId();

		for (int candidateVarbitId : COLLECTION_LOG_CATEGORY_VARBIT_IDS)
		{
			if (candidateVarbitId == varbitId)
			{
				scheduleUpdateCurrentCategory();
				return;
			}
		}
	}

	public void onNpcLootReceived(NpcLootReceived event)
	{
		//JsonObject collectionLog = twitchState.getCollectionLog();
		// TODO: implement updating of log
	}

	private Widget getCategoryHead()
	{
		Widget categoryHead = client.getWidget(ComponentID.COLLECTION_LOG_ENTRY_HEADER);

		return categoryHead;
	}

	private String getCategoryTitle(Widget categoryHead)
	{
		if (categoryHead == null)
		{
			return null;
		}

		final Widget[] children = categoryHead.getDynamicChildren();

		if (children == null || children.length <= 0)
		{
			return null;
		}

		String categoryTitle = children[0].getText();

		return categoryTitle;
	}

	/**
	 * Get the tab the current collection log selection in (bosses / raids / clues / minigames / other)
	 */
	private String getTabTitle()
	{
		for (int tabId : COLLECTION_LOG_TABS)
		{
			final Widget tabWidget = client.getWidget(COLLECTION_LOG_ID, tabId);

			if (tabWidget == null)
			{
				continue;
			}

			final Widget[] children = tabWidget.getDynamicChildren();

			if (children == null || COLLECTION_LOG_TAB_TEXT_INDEX >= children.length)
			{
				continue;
			}

			final Widget titleWidget = children[COLLECTION_LOG_TAB_TEXT_INDEX];
			final String title = titleWidget.getText();
			final int color = titleWidget.getTextColor();

			if (color == COLLECTION_LOG_TAB_ACTIVE_COLOR) {
				return title;
			}
		}

		return null;
	}

	/**
	 * Somehow there is a race condition within the client when reading the kill counts
	 * When inspecting the widgets for the kill counts is possible when they are read that the kill count
	 * from the previous category is concatenated to the name of the new category. So for example in the situation of:
	 * - You have a KC of 1 for Scorpia
	 * - You have a KC of 0 for Scurrius
	 *
	 * When switching the tabs really fast the client can actually return a raw KC string for Scurrius with:
	 * "Scurrius kills: 1"
	 *
	 * This is then split on the ":" and will result in the wrong KC for that boss. This is very strange behaviour,
	 * because you would expect this whole string to be updated as a whole. It however looks like first the name part is updated
	 * and after that the KC part. With the assumption this is a race condition a tiny delay is added below to update the current category.
	 * When testing this has resolved the issue right now.
	 *
	 * This delay does mean we should cancel any other scheduled updates in the past when a new update is requested within the delay time.
	 */
	private void scheduleUpdateCurrentCategory()
	{
		if (scheduledUpdateCurrentCategory != null && !scheduledUpdateCurrentCategory.isDone())
		{
			scheduledUpdateCurrentCategory.cancel(true);
		}

		// NOTE: make sure to add a delay here to fix the race condition mentioned above
		// this race condition can not be fixed within the plugin as it is part of the client
		scheduledUpdateCurrentCategory = plugin.scheduleOnClientThread(
				() -> {
					updateCurrentCategory();
					updateObtainedAmounts();
				},
			100
		);
	}

	/**
	 * Handle a change of selected category to collect the current items and quantities.
	 */
	private void updateCurrentCategory()
	{
		// debug errors because this method is run on the client thread
		try {
			final CopyOnWriteArrayList<CollectionLogItem> items = getCurrentItems();
			final Widget categoryHead = getCategoryHead();
			final JsonObject counters = getCurrentCounters(categoryHead);
			final String categoryTitle = getCategoryTitle(categoryHead);
			final String tabTitle = getTabTitle();
			JsonObject collectionLog = twitchState.getCollectionLog();

			if (collectionLog == null) {
				collectionLog = new JsonObject();
			}

			if (items == null || categoryTitle == null || tabTitle == null) {
				return;
			}

			if (!collectionLog.has(tabTitle)) {
				collectionLog.add(tabTitle, new JsonObject());
			}

			final JsonObject tabLog = collectionLog.getAsJsonObject(tabTitle);

			// always overwrite with new category log to make sure
			// new data structures in versioning are directly supported
			final JsonObject categoryLog = new JsonObject();
			final JsonArray serializedItems = new JsonArray();

			// serialize all items to arrays to be space efficient like:
			// [[itemId, quantity]] = [[995, 1], [2949, 2], [12304, 1]]
			for (CollectionLogItem item : items) {
				final JsonArray serializedItem = new JsonArray();
				serializedItem.add(item.getId());
				serializedItem.add(item.getQuantity());
				serializedItems.add(serializedItem);
			}

			categoryLog.add(COUNTERS_KEY_NAME, counters);
			categoryLog.add(ITEMS_KEY_NAME, serializedItems);
			tabLog.add(categoryTitle, categoryLog);

//			log.info("-------------------");
//			log.info("CATEGORY TITLE: "+ categoryTitle);
//			log.info("COUNTERS: "+ counters.toString());

			// update the twitch state
			twitchState.setCollectionLog(collectionLog);
		} catch (Exception exception) {
			log.warn("Could not update the collection log due to the following error: ", exception);
		}
	}

	private void updateObtainedAmounts()
	{
		try {
			Widget containerWidget = client.getWidget(COLLECTION_LOG_ID, COLLECTION_LOG_CONTAINER_ID);
			Widget titleWidget = containerWidget.getChild(COLLECTION_LOG_TITLE_INDEX);
			String title = titleWidget.getText();
			String[] titlePieces = title.split(" - ");

			if (titlePieces.length <= 1)
			{
				return;
			}

			String obtainedAmountFraction = titlePieces[1];
			String[] obtainedAmountPieces = obtainedAmountFraction.split("/");
			Integer obtainedAmount = Integer.parseInt(obtainedAmountPieces[0]);
			Integer obtainableAmount = Integer.parseInt(obtainedAmountPieces[1]);

			twitchState.setCollectionLogAmounts(obtainedAmount, obtainableAmount);
		} catch (Exception exception) {
			// empty
		}
	}

	private CopyOnWriteArrayList<CollectionLogItem> getCurrentItems()
	{
		final Widget itemsContainer = client.getWidget(ComponentID.COLLECTION_LOG_ENTRY_ITEMS);

		if (itemsContainer == null)
		{
			return null;
		}

		final Widget[] widgetItems = itemsContainer.getDynamicChildren();
		final CopyOnWriteArrayList<CollectionLogItem> items = new CopyOnWriteArrayList<>();

		for (Widget widgetItem : widgetItems)
		{
			items.add(new CollectionLogItem(widgetItem));
		}

		return items;
	}

	private JsonObject getCurrentCounters(Widget categoryHead)
	{
		final JsonObject counters = new JsonObject();

		if (categoryHead == null)
		{
			return counters;
		}

		final Widget[] children = categoryHead.getDynamicChildren();

		if (children == null || children.length < 3)
		{
			return counters;
		}

		// add all counters of all lines in the widget (starting from child index 2)
		for (int childIndex = 2; childIndex < children.length; childIndex++)
		{
			final String rawCounter = children[childIndex].getText();
			final String[] counterPieces = rawCounter.split(": ");

			// guard: make sure this is a KC line
			if (counterPieces.length <= 1)
			{
				continue;
			}

			final String counterTitle = counterPieces[0];
			final String counterAmount = counterPieces[1]
				.split(">")[1]
				.split("<")[0]
				.replace(",", "");

			try {
				counters.addProperty(counterTitle, Integer.parseInt(counterAmount));
			} catch (Exception error) {
				// empty?
			}
		}

		return counters;
	}
}

package com.twitchliveloadout.items;

import java.util.Comparator;

public class ItemSlotIdSorter implements Comparator<PricedItem>
{
	public int compare(PricedItem p1, PricedItem p2)
	{
		long slotId = p1.getSlotId();
		long comparedSlotId = p2.getSlotId();
		boolean isHigherSlotId = slotId > comparedSlotId;

		// check for same slot id
		if (slotId == comparedSlotId)
		{
			return 0;
		}

		// ascending order
		return isHigherSlotId ? 1 : -1;
	}
}

package com.twitchliveloadout.items;

import java.util.Comparator;

public class ItemPriceSorter implements Comparator<PricedItem>
{
	public int compare(PricedItem p1, PricedItem p2)
	{
		long price = p1.getPrice();
		long comparedPrice = p2.getPrice();
		boolean isMoreExpensive = price > comparedPrice;

		// check for equal
		if (price == comparedPrice)
		{
			return 0;
		}

		// descending order, from high to low price
		return isMoreExpensive ? -1 : 1;
	}
}

/*
 * Copyright (c) 2020, Pepijn Verburg <pepijn.verburg@gmail.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.twitchliveloadout;

import com.twitchliveloadout.fights.FightStateManager;
import com.twitchliveloadout.items.ItemStateManager;
import com.twitchliveloadout.marketplace.MarketplaceConstants;
import com.twitchliveloadout.twitch.TwitchThemeEntry;
import com.twitchliveloadout.twitch.TwitchVisibilityEntry;
import net.runelite.client.config.*;

import java.awt.Color;

import static com.twitchliveloadout.marketplace.MarketplaceConstants.CHAOS_MODE_AVAILABLE;
import static com.twitchliveloadout.marketplace.MarketplaceConstants.FREE_MODE_AVAILABLE;

@ConfigGroup("twitchstreamer")
public interface TwitchLiveLoadoutConfig extends Config
{
	public final static String PLUGIN_CONFIG_GROUP = "twitchstreamer";
	public final static String PLUGIN_CONFIG_PROFILE_GROUP = "twitch-live-loadout";

	public final static String TWITCH_OAUTH_ACCESS_TOKEN_KEY = "twitchOAuthAccessToken";
	public final static String TWITCH_OAUTH_REFRESH_TOKEN_KEY = "twitchOAuthRefreshToken";

	public final static String COLLECTION_LOG_CONFIG_KEY = "collection-log";
	public final static String COLLECTION_LOG_OBTAINED_AMOUNT_CONFIG_KEY = "collection-log-obtained-amount";
	public final static String COLLECTION_LOG_OBTAINABLE_AMOUNT_CONFIG_KEY = "collection-log-obtainable-amount";
	public final static String LOOTING_BAG_ITEMS_CONFIG_KEY = "looting-bag-items";
	public final static String LOOTING_BAG_PRICE_CONFIG_KEY = "looting-bag-price";
	public final static String BANK_TABBED_ITEMS_CONFIG_KEY = "bank-items";
	public final static String BANK_PRICE_CONFIG_KEY = "bank-price";
	public final static String INVOCATIONS_CONFIG_KEY = "invocations";
	public final static String INVOCATIONS_RAID_LEVEL_CONFIG_KEY = "invocations-raid-level";
	public final static String QUESTS_CONFIG_KEY = "quests";
	public final static String COMBAT_ACHIEVEMENTS_CONFIG_KEY = "combat-achievements";
	public final static String COMBAT_ACHIEVEMENTS_PROGRESS_CONFIG_KEY = "combat-achievements-progress";
	public final static String SEASONAL_RELICS_CONFIG_KEY = "seasonal-relics";
	public final static String SEASONAL_AREAS_CONFIG_KEY = "seasonal-areas";
	public final static String SEASONAL_MASTERIES_CONFIG_KEY = "seasonal-masteries";

	public final static String EVENT_SUB_HANDLED_FOLLOWER_IDS = "event-sub-handled-follower-ids";
	public final static String[] PERSISTENT_STATE_CONFIG_KEYS = new String[]{
		COLLECTION_LOG_CONFIG_KEY,
		COLLECTION_LOG_OBTAINED_AMOUNT_CONFIG_KEY,
		COLLECTION_LOG_OBTAINABLE_AMOUNT_CONFIG_KEY,
		LOOTING_BAG_ITEMS_CONFIG_KEY,
		LOOTING_BAG_PRICE_CONFIG_KEY,
		BANK_TABBED_ITEMS_CONFIG_KEY,
		BANK_PRICE_CONFIG_KEY,
		INVOCATIONS_CONFIG_KEY,
		INVOCATIONS_RAID_LEVEL_CONFIG_KEY,
		QUESTS_CONFIG_KEY,
		COMBAT_ACHIEVEMENTS_CONFIG_KEY,
		COMBAT_ACHIEVEMENTS_PROGRESS_CONFIG_KEY,
		SEASONAL_RELICS_CONFIG_KEY,
		SEASONAL_AREAS_CONFIG_KEY,
	};

	public final static int MIN_OVERLAY_TOP_POSITION = 25;
	public final static int MAX_OVERLAY_TOP_POSITION = 75;

	@ConfigSection(
			name = "Twitch Extension",
			description = "Authentication and layout config for the extension on Twitch.",
			position = 0
	)
	String twitchSection = "twitch";

	@ConfigItem(
			keyName = "twitchToken",
			name = "<html><body style=\"color: #fdff00;\">Your copied Twitch Extension Token</body></html>",
			description = "This token is copied when configuring the Twitch Extension.",
			secret = true,
			position = 2,
			section = twitchSection
	)
	default String twitchToken()
	{
		return "";
	}

	@Range(
			min = MIN_OVERLAY_TOP_POSITION,
			max = MAX_OVERLAY_TOP_POSITION
	)
	@ConfigItem(
			keyName = "overlayTopPosition",
			name = "Vertical position",
			description = "The position from the top left of the overlay in % of the screen height. Should be between "+ MIN_OVERLAY_TOP_POSITION +" and "+ MAX_OVERLAY_TOP_POSITION +".",
			position = 4,
			section = twitchSection
	)
	@Units(Units.PERCENT)
	default int overlayTopPosition()
	{
		return 35;
	}

	@ConfigItem(
			keyName = "twitchTheme",
			name = "Extension theme",
			description = "The theme of the Twitch Extension interface for viewers",
			position = 6,
			section = twitchSection
	)
	default TwitchThemeEntry twitchTheme()
	{
		return TwitchThemeEntry.LIGHT;
	}

	@ConfigItem(
			keyName = "twitchVisibility",
			name = "Extension visibility",
			description = "Always show extension or only when viewers hover the video stream",
			position = 8,
			hidden = false,
			section = twitchSection
	)
	default TwitchVisibilityEntry twitchVisibility()
	{
		return TwitchVisibilityEntry.ALWAYS;
	}

	@ConfigSection(
			name = "Data Syncing",
			description = "Syncing conditions and multi-account settings",
			position = 4,
			closedByDefault = true
	)
	String syncingSection = "syncing";

	@ConfigItem(
			keyName = "syncEnabled",
			name = "Enable data syncing",
			description = "Toggle off to disable all syncing, hide extension to viewers and clear data.",
			position = 0,
			section = syncingSection
	)
	default boolean syncEnabled()
	{
		return true;
	}

	@Range(
			min = 0,
			max = 120
	)
	@ConfigItem(
			keyName = "syncDelay",
			name = "Stream delay",
			description = "The amount of seconds to delay the sending of data to match your stream delay.",
			position = 2,
			section = syncingSection
	)
	@Units(Units.SECONDS)
	default int syncDelay()
	{
		return 0;
	}

	@ConfigSection(
			name = "Items",
			description = "Syncing of items in inventory, equipment and bank.",
			position = 15,
			closedByDefault = true
	)
	String itemsSection = "items";

	@ConfigItem(
			keyName = "inventoryEnabled",
			name = "Sync inventory items",
			description = "Synchronize all inventory items.",
			position = 2,
			section = itemsSection
	)
	default boolean inventoryEnabled()
	{
		return true;
	}

	@ConfigItem(
			keyName = "equipmentEnabled",
			name = "Sync equipment items",
			description = "Synchronize all equipment items.",
			position = 4,
			section = itemsSection
	)
	default boolean equipmentEnabled()
	{
		return true;
	}

	@ConfigItem(
			keyName = "lootingBagEnabled",
			name = "Sync looting bag items",
			description = "Synchronize all looting bag items.",
			position = 5,
			section = itemsSection
	)
	default boolean lootingBagEnabled()
	{
		return true;
	}

	@ConfigItem(
			keyName = "bankEnabled",
			name = "Sync bank items",
			description = "Synchronize bank value and top items based on GE value and configured maximum amount.",
			position = 6,
			section = itemsSection
	)
	default boolean bankEnabled()
	{
		return true;
	}

	@Range(
			min = 0,
			max = ItemStateManager.MAX_BANK_ITEMS
	)
	@ConfigItem(
			keyName = "bankItemsAmount",
			name = "Max bank items",
			description = "Maximum amount of items chosen by stack value.",
			position = 10,
			section = itemsSection
	)
	default int bankItemsAmount()
	{
		return ItemStateManager.MAX_BANK_ITEMS;
	}

	@ConfigItem(
			keyName = "bankPriceEnabled",
			name = "Sync bank value",
			description = "Synchronize bank value of all items.",
			position = 11,
			section = itemsSection
	)
	default boolean bankPriceEnabled()
	{
		return true;
	}

	@ConfigItem(
			keyName = "collectionLogEnabled",
			name = "Sync collection log",
			description = "Synchronize the collection log quantities and kill counts.",
			position = 12,
			section = itemsSection
	)
	default boolean collectionLogEnabled()
	{
		return true;
	}

	@ConfigItem(
			keyName = "collectionLogFilter",
			name = "Collection log filter (comma separated)",
			description = "Only include entry titles that include one of the keywords separated with a comma (e.g. 'abyssal, raids')",
			position = 14,
			section = itemsSection
	)
	default String collectionLogFilter()
	{
		return "";
	}

	@ConfigItem(
			keyName = "collectionLogSkipEmpty",
			name = "Skip empty collection logs",
			description = "Skip collection log pages where no items are logged yet.",
			position = 16,
			section = itemsSection
	)
	default boolean collectionLogSkipEmpty()
	{
		return false;
	}

	@ConfigSection(
			name = "Combat",
			description = "Syncing of weapon damage, smite drains, poison damage, etc. per enemy.",
			position = 14,
			closedByDefault = true
	)
	String combatSection = "combat";

	@ConfigItem(
			keyName = "fightStatisticsEnabled",
			name = "Sync combat statistics",
			description = "Synchronize statistics about PvM and PvP, such as DPS, freezes, splashes, etc.",
			position = 2,
			section = combatSection
	)
	default boolean fightStatisticsEnabled()
	{
		return true;
	}

	@ConfigItem(
			keyName = "fightStatisticsSpellsEnabled",
			name = "Track magic spells",
			description = "Enable tracking of freezes, entangles, blood spells and splashes.",
			position = 4,
			section = combatSection
	)
	default boolean fightStatisticsSpellsEnabled()
	{
		return true;
	}

	@ConfigItem(
			keyName = "fightStatisticsOthersEnabled",
			name = "Track damage by others",
			description = "Enable tracking of hitsplats of other players.",
			position = 6,
			section = combatSection
	)
	default boolean fightStatisticsOthersEnabled()
	{
		return true;
	}

	@ConfigItem(
			keyName = "fightStatisticsUnattackedEnabled",
			name = "Track un-attacked enemies",
			description = "Enable tracking of hitsplats on enemies you have not attacked, recommended in team settings such as Cox and ToB.",
			position = 8,
			section = combatSection
	)
	default boolean fightStatisticsUnattackedEnabled()
	{
		return false;
	}

	@Range(
			min = 0,
			max = FightStateManager.MAX_FIGHT_AMOUNT
	)
	@ConfigItem(
			keyName = "fightStatisticsMaxFightAmount",
			name = "Max combat fights",
			description = "Maximum amount of tracked fights with fixed upper limit of "+ FightStateManager.MAX_FIGHT_AMOUNT +".",
			position = 10,
			section = combatSection
	)
	default int fightStatisticsMaxFightAmount()
	{
		return FightStateManager.MAX_FIGHT_AMOUNT;
	}

	@Range(
			min = 0,
			max = 24 * 60
	)
	@ConfigItem(
			keyName = "fightStatisticsExpiryTime",
			name = "Fight expiry time",
			description = "Reset a fight after the configured minutes of inactivity.",
			position = 12,
			section = combatSection
	)
	@Units(Units.MINUTES)
	default int fightStatisticsExpiryTime()
	{
		return 180;
	}

	@ConfigItem(
			keyName = "fightStatisticsAutoIdling",
			name = "Auto idling of fight timer",
			description = "Stop fight timer when logged out or enemy is not visible.",
			position = 14,
			section = combatSection
	)
	default boolean fightStatisticsAutoIdling()
	{
		return true;
	}

	@ConfigItem(
			keyName = "fightStatisticsProtectionEnabled",
			name = "Disable tracking on Hardcores",
			description = "Disable tracking of fight stats on Hardcore Ironmen to interfere as little as possible with combat.",
			position = 16,
			section = combatSection,
			warning = "Are you sure you want to toggle fight stats to be tracked on Hardcore Ironmen?"
	)
	default boolean fightStatisticsProtectionEnabled()
	{
		return true;
	}

	@ConfigSection(
			name = "Raids",
			description = "Syncing of invocations",
			position = 16,
			closedByDefault = true
	)
	String raidsSection = "raids";

	@ConfigItem(
			keyName = "invocationsEnabled",
			name = "Sync ToA Invocations",
			description = "Synchronize Tombs of Amascut raids invocations.",
			position = 2,
			section = raidsSection
	)
	default boolean invocationsEnabled()
	{
		return true;
	}

	@ConfigItem(
			keyName = "invocationsRaidLevelEnabled",
			name = "Sync ToA Raid Level",
			description = "Synchronize Tombs of Amascut raids level.",
			position = 4,
			section = raidsSection
	)
	default boolean invocationsRaidLevelEnabled()
	{
		return true;
	}

	@ConfigItem(
			keyName = "autoDetectInToaRaidEnabled",
			name = "Only Sync in ToA Raid",
			description = "Only synchronize invocations when in the ToA raid.",
			position = 6,
			section = raidsSection
	)
	default boolean autoDetectInToaRaidEnabled()
	{
		return true;
	}

	@ConfigSection(
			name = "Skills",
			description = "Syncing of skill experience, virtual levels, etc.",
			position = 16,
			closedByDefault = true
	)
	String skillsSection = "skills";

	@ConfigItem(
			keyName = "skillsEnabled",
			name = "Sync skill levels",
			description = "Synchronize skill experience, level boosts and combat level.",
			position = 2,
			section = skillsSection
	)
	default boolean skillsEnabled()
	{
		return true;
	}

	@ConfigItem(
			keyName = "virtualLevelsEnabled",
			name = "Virtual levels",
			description = "Use maximum level of 126 instead of 99.",
			position = 4,
			section = skillsSection
	)
	default boolean virtualLevelsEnabled()
	{
		return true;
	}

	@ConfigSection(
			name = "Quests",
			description = "Syncing of quests and their status.",
			position = 17,
			closedByDefault = true
	)
	String questsSection = "quests";

	@ConfigItem(
			keyName = "questsEnabled",
			name = "Sync quests",
			description = "Synchronize quests and their completion status.",
			position = 2,
			section = questsSection
	)
	default boolean questsEnabled()
	{
		return true;
	}

	@ConfigSection(
			name = "Seasonals",
			description = "Syncing of seasonal stats",
			position = 18,
			closedByDefault = true
	)
	String seasonalsSection = "seasonals";

	@ConfigItem(
			keyName = "seasonalsEnabled",
			name = "Sync seasonals",
			description = "Synchronize leagues/DMM info, such as regions and relics.",
			position = 2,
			section = seasonalsSection
	)
	default boolean seasonalsEnabled()
	{
		return true;
	}

	@ConfigSection(
			name = "Combat Achievements",
			description = "Syncing of combat achievements",
			position = 19,
			closedByDefault = true
	)
	String combatAchievementsSection = "combat-achievements";

	@ConfigItem(
			keyName = "combatAchievementsEnabled",
			name = "Sync combat achievements",
			description = "Synchronize total points and completion of individual tasks per tier",
			position = 2,
			section = combatAchievementsSection
	)
	default boolean combatAchievementsEnabled()
	{
		return true;
	}

	@ConfigSection(
			name = "General info",
			description = "Syncing of display name, player weight, etc.",
			position = 20,
			closedByDefault = true
	)
	String generalInfoSection = "general-info";

	@ConfigItem(
			keyName = "playerInfoEnabled",
			name = "Sync display name",
			description = "Synchronize basic player info such as display name.",
			position = 2,
			section = generalInfoSection
	)
	default boolean playerInfoEnabled()
	{
		return true;
	}

	@ConfigItem(
			keyName = "weightEnabled",
			name = "Sync weight of carried items",
			description = "Synchronize the weight of the equipment and inventory items, including weight reduction.",
			position = 4,
			section = generalInfoSection
	)
	default boolean weightEnabled()
	{
		return true;
	}

	@ConfigItem(
			keyName = "itemGoalsEnabled",
			name = "Sync item goals",
			description = "Synchronize the configured item wanted items, progress is automatic from inventory, gear and bank items.",
			position = 14,
			hidden = true,
			section = itemsSection
	)
	default boolean itemGoalsEnabled()
	{
		return false;
	}

	@ConfigSection(
			name = "Random Events",
			description = "Settings for the Random Event triggered by donations or channel events",
			position = 6,
			closedByDefault = true
	)
	String marketplaceSection = "donations";

	@ConfigItem(
			keyName = "marketplaceEnabled",
			name = "Enable Random Events",
			description = "Enable viewers to make donations or channel events to trigger in-game Random Events (requires Twitch Extension configuration!).",
			position = 4,
			hidden = false,
			section = marketplaceSection
	)
	default boolean marketplaceEnabled()
	{
		return true;
	}

	@ConfigItem(
			keyName = "marketplaceProtectionEnabled",
			name = "Enable Hardcore protection",
			description = "Automatically disable random events that could be dangerous for Hardcore Ironmen.",
			position = 6,
			hidden = false,
			section = marketplaceSection,
			warning = "Disabling this allows Random Events that are potentially dangerous in terms of gameplay to be activated by viewers when you have them configured. Are you sure?"
	)
	default boolean marketplaceProtectionEnabled()
	{
		return true;
	}

	@ConfigItem(
			keyName = "marketplaceSoundsEnabled",
			name = "Enable sounds",
			description = "Disable to not play any sounds triggered by the random event effects.",
			position = 8,
			hidden = false,
			section = marketplaceSection
	)
	default boolean marketplaceSoundsEnabled()
	{
		return true;
	}

	@ConfigItem(
			keyName = "marketplaceStartOnLoadedAt",
			name = "Correct transaction delay",
			description = "Base the expiry of the effects when it is received and not the transaction time, which can have delays.",
			position = 10,
			hidden = true,
			section = marketplaceSection
	)
	default boolean marketplaceStartOnLoadedAt()
	{
		return true;
	}

	@Range(
			min = 1,
			max = 50
	)
	@ConfigItem(
			keyName = "marketplaceMaxActiveProducts",
			name = "Max active amount",
			description = "How many random events can be active at once. New ones are queued when maximum is exceeded.",
			position = 12,
			hidden = false,
			section = marketplaceSection
	)
	default int marketplaceMaxActiveProducts()
	{
		return 25;
	}

	@Range(
			min = 1,
			max = MarketplaceConstants.MAX_TRANSACTION_AMOUNT_IN_MEMORY
	)
	@ConfigItem(
			keyName = "marketplaceTransactionHistoryAmount",
			name = "Transaction history amount",
			description = "How many transactions are shown in the 'recent donations' panel.",
			position = 16,
			hidden = true,
			section = marketplaceSection
	)
	default int marketplaceTransactionHistoryAmount()
	{
		return MarketplaceConstants.MAX_TRANSACTION_AMOUNT_IN_MEMORY;
	}

	@Range(
			min = 5,
			max = 60 * 5
	)
	@ConfigItem(
			keyName = "testRandomEventsDuration_v2", // NOTE: different key to force update to new default
			name = "Preview duration",
			description = "Duration of the Random Event when requested as a preview.",
			position = 20,
			section = marketplaceSection
	)
	@Units(Units.SECONDS)
	default int testRandomEventsDuration()
	{
		return 30;
	}

	@ConfigItem(
			keyName = "chaosModeSpawnMultiplier",
			name = "Chaos Mode spawn multiplier",
			description = "The amount all NPC/item spawns are multiplied when Chaos Mode is enabled.",
			position = 24,
			section = marketplaceSection,
			hidden = !CHAOS_MODE_AVAILABLE
	)
	default int chaosModeSpawnMultiplier()
	{
		return 3;
	}

	@ConfigItem(
			keyName = "chaosModeRangeMultiplier",
			name = "Chaos Mode range multiplier",
			description = "The multiplier for the distance where the spawns allowed to be put. When you have a spawn multiplier increasing the range as well is recommended.",
			position = 28,
			section = marketplaceSection,
			hidden = !CHAOS_MODE_AVAILABLE
	)
	default int chaosModeRangeMultiplier()
	{
		return 2;
	}

	@Range(
			min = 0,
			max = 60 * 30 // half hour max?
	)
	@ConfigItem(
			keyName = "marketplaceNormalModeCooldownS",
			name = "Base cooldown",
			description = "Cooldown time shared between all random events. This works together with the cooldown time per random event configured in Twitch.",
			position = 30,
			hidden = false,
			section = marketplaceSection
	)
	@Units(Units.SECONDS)
	default int marketplaceNormalModeCooldownS()
	{
		return 0;
	}

	@Range(
			min = 0,
			max = 60 * 30 // half hour max?
	)
	@ConfigItem(
			keyName = "marketplaceFreeModeCooldownS",
			name = "Free mode cooldown",
			description = "Cooldown time shared between all random events when in free mode. This adds towards the base cooldown.",
			position = 32,
			hidden = !FREE_MODE_AVAILABLE,
			section = marketplaceSection
	)
	@Units(Units.SECONDS)
	default int marketplaceFreeModeCooldownS()
	{
		return 0;
	}

	@Range(
			min = 0,
			max = 60 * 30 // half hour max?
	)
	@ConfigItem(
			keyName = "marketplaceChaosModeCooldownS",
			name = "Chaos mode cooldown",
			description = "Cooldown time shared between all random events when in chaos mode. This adds towards the base cooldown.",
			position = 34,
			hidden = !CHAOS_MODE_AVAILABLE,
			section = marketplaceSection
	)
	@Units(Units.SECONDS)
	default int marketplaceChaosModeCooldownS()
	{
		return 0;
	}

	@ConfigSection(
			name = "Channel Events",
			description = "Authentication and configuration for channel events, such as follows, subs, etc.",
			position = 10,
			closedByDefault = true
	)
	String channelEventsSection = "channel-events";

	@ConfigItem(
			keyName = "marketplaceChannelEventsEnabled",
			name = "Enable Channel Events",
			description = "Enable listening to channel events, such as follows and subs to activate Random Events",
			position = 1,
			hidden = false,
			section = channelEventsSection
	)
	default boolean marketplaceChannelEventsEnabled()
	{
		return true;
	}

	@ConfigItem(
			keyName = TWITCH_OAUTH_ACCESS_TOKEN_KEY,
			name = "Twitch Channel Token (optional)",
			description = "Optional token to access events such as channel point redeems, subscriptions, etc.",
			secret = true,
			position = 2,
			section = channelEventsSection
	)
	default String twitchOAuthAccessToken()
	{
		return "";
	}

	@ConfigItem(
			keyName = TWITCH_OAUTH_REFRESH_TOKEN_KEY,
			name = "Twitch Channel Refresh Token (optional)",
			description = "Optional refresh token to access events such as channel point redeems, subscriptions, etc.",
			secret = true,
			position = 4,
			section = channelEventsSection
	)
	default String twitchOAuthRefreshToken()
	{
		return "";
	}

	@ConfigSection(
			name = "Notifications",
			description = "enable and disable specific notifications along with customised colours and messages",
			position = 12,
			closedByDefault = true
	)
	String notificationsSection = "notifications";

	@ConfigItem(
			keyName = "overheadDonationMessageEnabled",
			name = "Enable overhead messages",
			description = "Enable messages for Random Events as overhead text.",
			position = 4,
			section = notificationsSection
	)
	default boolean overheadMessagesEnabled()
	{
		return true;
	}

	@ConfigItem(
			keyName = "popupDonationMessageEnabled",
			name = "Enable pop-up messages",
			description = "Enable messages for Random Events as a pop-up.",
			position = 8,
			section = notificationsSection
	)
	default boolean popupMessagesEnabled()
	{
		return true;
	}

	@ConfigItem(
			keyName = "chatDonationMessageEnabled",
			name = "Enable in-game chat messages",
			description = "Enable messages for Random Events as in-game chat messages.",
			position = 12,
			section = notificationsSection
	)
	default boolean chatMessagesEnabled()
	{
		return true;
	}

	@ConfigItem(
			keyName = "twitchChatBitsDonationMessageEnabled",
			name = "Enable Twitch chat messages",
			description = "Enable messages for Random Events as Twitch Chat messages.",
			position = 14,
			section = notificationsSection
	)
	default boolean twitchChatBitsDonationMessageEnabled()
	{
		return false;
	}

	@ConfigItem(
			keyName = "chatMessageColor",
			name = "Chat message color",
			description = "The color in which the in-game chat messages are shown.",
			position = 16,
			section = notificationsSection
	)
	default Color chatMessageColor()
	{
		// return new Color(145, 70, 255); // light purple
		return new Color(96, 33, 191); // dark purple
	}

	@Range(
			min = 1,
			max = 10
	)
	@ConfigItem(
			keyName = "overheadMessageDurationS",
			name = "Overhead text duration",
			description = "How long overhead notifications, such as thank you's above the player.",
			position = 20,
			hidden = false,
			section = notificationsSection
	)
	@Units(Units.SECONDS)
	default int overheadMessageDurationS()
	{
		return 2;
	}

	@ConfigItem(
			keyName = "marketplaceDefaultDonationMessage", // NOTE: keep old key for migration purposes
			name = "Default bits donation message",
			description = "Default message when bits are donated. Use '{viewerName}', '{currencyAmount}' and '{currencyType}' to replace with values from the transaction.",
			position = 24,
			section = notificationsSection
	)
	default String defaultBitsDonationMessage()
	{
		return "Thank you {viewerName} for donating {currencyAmount} {currencyType}!";
	}

	@ConfigItem(
			keyName = "twitchChatBitsDonationMessage",
			name = "Twitch Chat bits donation message",
			description = "Enable sending a Twitch Chat message with details of the bits donation.",
			position = 26,
			section = notificationsSection
	)
	default String twitchChatBitsDonationMessage()
	{
		return "{viewerName} just activated \"{productName}\" for {currencyAmount} {currencyType}!";
	}

	@ConfigItem(
			keyName = "defaultFreeModeActivationMessage", // NOTE: keep old key for migration purposes
			name = "Default free mode activation message",
			description = "Default message when an event is activated when free mode is on. Use '{viewerName}' and {productName} to replace with values from the transaction.",
			position = 28,
			section = notificationsSection
	)
	default String defaultFreeModeActivationMessage()
	{
		return "Thank you {viewerName} for activating {productName}!";
	}

	@ConfigItem(
			keyName = "followEventMessageEnabled-v2",
			name = "1. Enable follow message",
			description = "Enable follow event message",
			position = 36,
			section = notificationsSection
	)
	default boolean followEventMessageEnabled()
	{
		return false;
	}

	@ConfigItem(
			keyName = "followEventMessage",
			name = "Message on follow",
			description = "Message shown when there is a new channel follower.",
			position = 40,
			section = notificationsSection
	)
	default String followEventMessage()
	{
		return "Thanks {viewerName} for following!";
	}

	@ConfigItem(
			keyName = "channelPointsRedeemEventMessageEnabled-v2",
			name = "2. Enable channel point message",
			description = "Enable message shown when there is a channel point redeem.",
			position = 44,
			section = notificationsSection
	)
	default boolean channelPointsRedeemEventMessageEnabled()
	{
		return false;
	}

	@ConfigItem(
			keyName = "channelPointsRedeemEventMessage",
			name = "Message on channel point redeem",
			description = "Message shown when there is a channel point redeem.",
			position = 48,
			section = notificationsSection
	)
	default String channelPointsRedeemEventMessage()
	{
		return "Thanks {viewerName} for redeeming {currencyAmount} channel points!";
	}

	@ConfigItem(
			keyName = "subscribeEventMessageEnabled",
			name = "3a. Enable sub message",
			description = "Enable message shown when there is a new sub.",
			position = 52,
			section = notificationsSection
	)
	default boolean subscribeEventMessageEnabled()
	{
		return true;
	}

	@ConfigItem(
			keyName = "subscribeEventMessageOnGiftEnabled",
			name = "3b. Enable sub message when gifted",
			description = "Enable message when the sub is gifted.",
			position = 56,
			section = notificationsSection
	)
	default boolean subscribeEventMessageOnGiftEnabled()
	{
		return true;
	}

	@ConfigItem(
			keyName = "subscribeEventMessage",
			name = "Message on new sub",
			description = "Message shown when there is a new sub.",
			position = 60,
			section = notificationsSection
	)
	default String subscribeEventMessage()
	{
		return "Thanks {viewerName} for the sub!";
	}

	@ConfigItem(
			keyName = "resubscribeEventMessageEnabled",
			name = "4. Enable resub message",
			description = "Enable message shown when there is a resub.",
			position = 64,
			section = notificationsSection
	)
	default boolean resubscribeEventMessageEnabled()
	{
		return true;
	}

	@ConfigItem(
			keyName = "resubscribeEventMessage",
			name = "Message on resub",
			description = "Message shown when there is a resub.",
			position = 68,
			section = notificationsSection
	)
	default String resubscribeEventMessage()
	{
		return "Thanks {viewerName} for the {subMonths} month resub for a total of {subTotalMonths}!";
	}

	@ConfigItem(
			keyName = "giftSubscriptionEventMessageEnabled",
			name = "5. Enable gift sub message",
			description = "Enable message shown when there is a gift subscription.",
			position = 72,
			section = notificationsSection
	)
	default boolean giftSubscriptionEventMessageEnabled()
	{
		return true;
	}

	@ConfigItem(
			keyName = "giftSubscriptionEventMessage",
			name = "Message on gift",
			description = "Message shown when there is a gift subscription.",
			position = 76,
			section = notificationsSection
	)
	default String giftSubscriptionEventMessage()
	{
		return "Thanks {viewerName} for the {giftedAmount} gifted for a total of {giftedTotalAmount}!";
	}

	@ConfigItem(
			keyName = "raidEventMessageEnabled",
			name = "6. Enable raid message",
			description = "Enable message shown when there is a raid.",
			position = 80,
			section = notificationsSection
	)
	default boolean raidEventMessageEnabled()
	{
		return true;
	}

	@ConfigItem(
			keyName = "raidEventMessage",
			name = "Message on raid",
			description = "Message shown when you receive a raid.",
			position = 84,
			section = notificationsSection
	)
	default String raidEventMessage()
	{
		return "Thanks {raiderChannelName} for the raid with {raidViewerAmount} viewers!";
	}

	@ConfigItem(
			keyName = "addedModMessageEnabled",
			name = "7. Enable add mod message",
			description = "Enable message shown a user is promoted to mod.",
			position = 88,
			section = notificationsSection
	)
	default boolean addedModMessageEnabled()
	{
		return true;
	}

	@ConfigItem(
			keyName = "addedModMessage",
			name = "Message on mod added",
			description = "Message shown a user is promoted to mod.",
			position = 92,
			section = notificationsSection
	)
	default String addedModMessage()
	{
		return "Congrats {viewerName} with the promotion!";
	}

	@ConfigItem(
			keyName = "removedModMessageEnabled",
			name = "8. Enable remove mod message",
			description = "Enable message shown when a user is demoted from mod.",
			position = 96,
			section = notificationsSection
	)
	default boolean removedModMessageEnabled()
	{
		return true;
	}

	@ConfigItem(
			keyName = "removedModMessage",
			name = "Message on mod removal",
			description = "Message shown when a user is demoted from mod.",
			position = 100,
			section = notificationsSection
	)
	default String removedModMessage()
	{
		return "No mod for you anymore, {viewerName}!";
	}

	@ConfigItem(
			keyName = "beginHypeTrainMessageEnabled",
			name = "9. Enable hype train begin message",
			description = "Enable message when a hype train begins.",
			position = 104,
			section = notificationsSection
	)
	default boolean beginHypeTrainMessageEnabled()
	{
		return true;
	}

	@ConfigItem(
			keyName = "beginHypeTrainMessage",
			name = "Message on hype train begin",
			description = "Message when a hype train begins",
			position = 108,
			section = notificationsSection
	)
	default String beginHypeTrainMessage()
	{
		return "Thanks all for starting the level {hypeTrainLevel} hype train!";
	}

	@ConfigItem(
			keyName = "progressHypeTrainMessageEnabled-v2",
			name = "10. Enable hype train progression message",
			description = "Enable message when a hype train progresses in percentage or level.",
			position = 112,
			section = notificationsSection
	)
	default boolean progressHypeTrainMessageEnabled()
	{
		return false;
	}

	@ConfigItem(
			keyName = "progressHypeTrainMessage",
			name = "Message on hype train progression",
			description = "Message when a hype train progresses in percentage or level.",
			position = 116,
			section = notificationsSection
	)
	default String progressHypeTrainMessage()
	{
		return "Thanks all for contributing to the level {hypeTrainLevel} hype train!";
	}

	@ConfigItem(
			keyName = "endHypeTrainMessageEnabled",
			name = "11. Enable hype train end message",
			description = "Enable message when a hype train ends.",
			position = 120,
			section = notificationsSection
	)
	default boolean endHypeTrainMessageEnabled()
	{
		return true;
	}

	@ConfigItem(
			keyName = "endHypeTrainMessage",
			name = "Message on hype train end",
			description = "Message when a hype train ends.",
			position = 124,
			section = notificationsSection
	)
	default String endHypeTrainMessage()
	{
		return "Thanks all for the level {hypeTrainLevel} hype train!";
	}

	@ConfigItem(
			keyName = "donateCharityCampaignMessageEnabled",
			name = "12. Enable charity donation message",
			description = "Enable message when a charity campaign receives a donation.",
			position = 128,
			section = notificationsSection
	)
	default boolean donateCharityCampaignMessageEnabled()
	{
		return true;
	}

	@ConfigItem(
			keyName = "donateCharityCampaignMessage",
			name = "Message on charity donation",
			description = "Message when a charity campaign receives a donation.",
			position = 132,
			section = notificationsSection
	)
	default String donateCharityCampaignMessage()
	{
		return "Thanks {viewerName} for donating {currencyAmount} {currencyType} to {charityName}!";
	}

	@ConfigItem(
			keyName = "startCharityCampaignMessageEnabled",
			name = "13. Enable charity start message",
			description = "Enable message when a charity campaign starts.",
			position = 136,
			section = notificationsSection
	)
	default boolean startCharityCampaignMessageEnabled()
	{
		return true;
	}

	@ConfigItem(
			keyName = "startCharityCampaignMessage",
			name = "Message on charity start",
			description = "Message when a charity campaign starts",
			position = 140,
			section = notificationsSection
	)
	default String startCharityCampaignMessage()
	{
		return "Welcome to the charity campaign for {charityName} with a goal of {charityTargetAmount} {charityTargetCurrency}!";
	}

	@ConfigItem(
			keyName = "progressCharityCampaignMessageEnabled",
			name = "14. Enable charity progression message",
			description = "Enable message when a charity progresses in amount donated.",
			position = 144,
			section = notificationsSection
	)
	default boolean progressCharityCampaignMessageEnabled()
	{
		return true;
	}

	@ConfigItem(
			keyName = "progressCharityCampaignMessage",
			name = "Message on charity progression",
			description = "Message when a charity progresses in amount donated.",
			position = 148,
			section = notificationsSection
	)
	default String progressCharityCampaignMessage()
	{
		return "Thanks all for donating {charityCurrentAmount} {charityCurrentCurrency} up until now towards our goal of {charityTargetAmount} {charityTargetCurrency}!";
	}

	@ConfigItem(
			keyName = "stopCharityCampaignMessageEnabled",
			name = "15. Enable charity end message",
			description = "Enable message when a charity campaign ends.",
			position = 152,
			section = notificationsSection
	)
	default boolean stopCharityCampaignMessageEnabled()
	{
		return true;
	}

	@ConfigItem(
			keyName = "stopCharityCampaignMessage",
			name = "Message on charity end",
			description = "Message when a charity campaign ends.",
			position = 156,
			section = notificationsSection
	)
	default String stopCharityCampaignMessage()
	{
		return "Thanks all for donating {charityCurrentAmount} {charityCurrentCurrency} to the charity! It's a wrap!";
	}

	@ConfigSection(
			name = "Advanced",
			description = "Settings for advanced usage",
			position = 99,
			closedByDefault = true
	)
	String advancedSection = "advanced";

	@ConfigItem(
			keyName = "supportDebugEnabled",
			name = "Support debug mode",
			description = "Enable more extensive logging for support purposes.",
			position = 0,
			section = advancedSection
	)
	default boolean supportDebugEnabled()
	{
		return false;
	}

	@ConfigItem(
			keyName = "manualMarketplaceProductsEnabled",
			name = "Enable manual Random Events",
			description = "Allow custom JSON configurations for Random Events for testing purposes (see Event tab in the plugin panel).",
			position = 1,
			section = advancedSection,
			warning = "Make sure you know what Random Event configuration you're entering manually before executing it. Are you sure you want to enable this feature?"
	)
	default boolean manualMarketplaceProductsEnabled()
	{
		return false;
	}

	@ConfigItem(
			keyName = "twitchReviewModeEnabled",
			name = "Twitch review mode",
			description = "Force syncing of data while being logged out, meant for the Twitch review process.",
			position = 2,
			hidden = !TwitchLiveLoadoutPlugin.IN_DEVELOPMENT,
			section = advancedSection
	)
	default boolean twitchReviewModeEnabled()
	{
		return false;
	}

	@ConfigItem(
			keyName = "debugMenuOptionClicks",
			name = "Debug menu clicks",
			description = "Debug menu option click events.",
			position = 4,
			hidden = !TwitchLiveLoadoutPlugin.IN_DEVELOPMENT,
			section = advancedSection
	)
	default boolean debugMenuOptionClicks()
	{
		return false;
	}

	@ConfigItem(
			keyName = "testRandomEvents",
			name = "Test Random Events",
			description = "Periodically spawn a random event and move to the next one.",
			position = 6,
			hidden = !TwitchLiveLoadoutPlugin.IN_DEVELOPMENT,
			section = advancedSection
	)
	default boolean testRandomEventsEnabled()
	{
		return false;
	}

	@ConfigItem(
			keyName = "testRandomEventsRandomly",
			name = "Test Randomly",
			description = "True when selecting randomly instead of cyclic.",
			position = 8,
			hidden = !TwitchLiveLoadoutPlugin.IN_DEVELOPMENT,
			section = advancedSection
	)
	default boolean testRandomEventsRandomly()
	{
		return false;
	}

	@ConfigItem(
			keyName = "testRandomEventsDelay",
			name = "Test Delay",
			description = "The amount of time before the next Random Event is tested.",
			position = 12,
			hidden = !TwitchLiveLoadoutPlugin.IN_DEVELOPMENT,
			section = advancedSection
	)
	@Units(Units.SECONDS)
	default int testRandomEventsDelay()
	{
		return 5;
	}
}

package com.twitchliveloadout.achievements;

import com.google.gson.JsonArray;
import com.google.gson.JsonObject;
import com.twitchliveloadout.TwitchLiveLoadoutPlugin;
import com.twitchliveloadout.twitch.TwitchState;
import net.runelite.api.Client;
import net.runelite.api.events.ScriptPostFired;
import net.runelite.api.widgets.Widget;
import net.runelite.client.util.Text;

public class CombatAchievementsManager {
    private static final int ACHIEVEMENTS_SCRIPT_ID = 4817;
    private static final int LIST_GROUP_ID = 715;
    private static final int PROGRESS_BAR_CHILD_ID = 3;
    private static final int PROGRESS_BAR_INDEX = 3;
    private static final int NAME_LIST_CHILD_ID = 10;
    private static final int NPC_LIST_CHILD_ID = 12;
    private static final int TIER_LIST_CHILD_ID = 15;

    private final TwitchLiveLoadoutPlugin plugin;
    private final TwitchState twitchState;
    private final Client client;

    public CombatAchievementsManager(TwitchLiveLoadoutPlugin plugin, TwitchState twitchState, Client client)
    {
        this.plugin = plugin;
        this.twitchState = twitchState;
        this.client = client;
    }

    public void onScriptPostFired(ScriptPostFired scriptPostFired)
    {
        if (scriptPostFired.getScriptId() == ACHIEVEMENTS_SCRIPT_ID) {
            plugin.scheduleOnClientThread(this::updateCombatAchievements, 200);
        }
    }

    public void updateCombatAchievements()
    {
        Widget progressBarWidget = client.getWidget(LIST_GROUP_ID, PROGRESS_BAR_CHILD_ID);
        Widget namesListWidget = client.getWidget(LIST_GROUP_ID, NAME_LIST_CHILD_ID);
        Widget npcsListWidget = client.getWidget(LIST_GROUP_ID, NPC_LIST_CHILD_ID);
        Widget tierListWidget = client.getWidget(LIST_GROUP_ID, TIER_LIST_CHILD_ID);

        // guard: check if the widgets are valid
        if (progressBarWidget == null || namesListWidget == null || npcsListWidget == null || tierListWidget == null)
        {
            return;
        }

        // get the current state to allow expanding of the achievements if the user is opening the tiers one by one for example
        JsonObject combatAchievementsState = twitchState.getCombatAchievements();

        if (combatAchievementsState == null)
        {
            combatAchievementsState = new JsonObject();
        }

        Widget[] nameWidgets = namesListWidget.getDynamicChildren();
        String progressTitle = null;
        Widget progressTextWidget = progressBarWidget.getChild(PROGRESS_BAR_INDEX);

        if (progressTextWidget != null)
        {
            progressTitle = progressTextWidget.getText();
        }

        for (int nameWidgetIndex = 0; nameWidgetIndex < nameWidgets.length; nameWidgetIndex++)
        {
            Widget nameWidget = nameWidgets[nameWidgetIndex];
            Widget npcWidget = npcsListWidget.getChild(nameWidgetIndex);
            Widget tierWidget = tierListWidget.getChild(nameWidgetIndex);
            JsonArray combatAchievementEntry = new JsonArray();

            // guard: skip if all widgets are not found
            if (nameWidget == null || npcWidget == null || tierWidget == null)
            {
                continue;
            }

            String name = nameWidget.getText();
            String formattedNpcName = Text.removeTags(npcWidget.getText()).replaceAll("Monster: ","");

            // create array tuple instead of an object to maximize storage usage
            // add the color directly because we GZIP it anyways
            // so it will become more efficient in terms of transfer
            // the reason why we do this is, because colours might change in the future
            combatAchievementEntry.add(nameWidget.getTextColor()); // indicates completion status
            combatAchievementEntry.add(formattedNpcName); // name of the monster
            combatAchievementEntry.add(tierWidget.getSpriteId()); // sprite ID of the tier

            // the name of the achievement is the key to allow for overwriting and expanding
            // when a user is opening the tiers one by one
            combatAchievementsState.add(name, combatAchievementEntry);
        }

        twitchState.setCombatAchievementsProgress(progressTitle);
        twitchState.setCombatAchievements(combatAchievementsState);

        // debug in support
        plugin.logSupport("Combat achievement title: "+ progressTitle);
        plugin.logSupport("Combat achievement content: "+ combatAchievementsState.toString());
    }
}

package com.twitchliveloadout;

import net.runelite.client.RuneLite;
import net.runelite.client.externalplugins.ExternalPluginManager;

public class TwitchLiveLoadoutPluginTest
{
	public static void main(String[] args) throws Exception
	{
		ExternalPluginManager.loadBuiltin(TwitchLiveLoadoutPlugin.class);
		RuneLite.main(args);
	}
}
