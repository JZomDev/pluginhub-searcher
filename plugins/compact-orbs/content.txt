/*
 * Copyright (c) 2025, cue <https://github.com/its-cue>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

package com.compactorbs.util;

import lombok.Getter;

@Getter
public class SetValue
{
	private final Integer original;
	private final Integer[] modified;

	public SetValue(Integer original, Integer... modified)
	{
		this.original = original;
		this.modified = modified;
	}

	//same function as before, but should allow for multiple 'modified sets' (original, mod_vertical, mod_horizontal, etc) instead of just 1
	public Integer get(boolean modify, int index)
	{
		if (!modify || original == null)
		{
			return original;
		}

		if (modified != null && modified.length > 0)
		{
			if (index >= 0 && index < modified.length && modified[index] != null)
			{
				return modified[index];
			}
			return modified[0];
		}

		return original;
	}

}

/*
 * Copyright (c) 2025, cue <https://github.com/its-cue>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

package com.compactorbs.util;

public enum ValueKey
{
	X,
	Y,
	X_POSITION_MODE,
	Y_POSITION_MODE
}

/*
 * Copyright (c) 2025, cue <https://github.com/its-cue>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

package com.compactorbs;

import com.compactorbs.CompactOrbsConfig.OrbLayout;
import com.compactorbs.CompactOrbsConfig.HorizontalPosition;
import com.compactorbs.CompactOrbsConfig.VerticalPosition;
import static com.compactorbs.CompactOrbsConstants.ConfigGroup.GROUP_NAME;
import com.compactorbs.CompactOrbsConstants.ConfigGroup;
import com.compactorbs.CompactOrbsConstants.ConfigKeys;
import com.compactorbs.CompactOrbsConstants.Layout;
import com.compactorbs.CompactOrbsConstants.Menu;
import com.compactorbs.CompactOrbsConstants.Script;
import com.compactorbs.CompactOrbsConstants.Sprite;
import com.compactorbs.CompactOrbsConstants.Widgets.Classic;
import com.compactorbs.CompactOrbsConstants.Widgets.Modern;
import com.compactorbs.CompactOrbsConstants.Widgets.Orb;
import com.compactorbs.widget.TargetWidget;
import com.compactorbs.widget.WidgetManager;
import com.compactorbs.widget.elements.Compass;
import com.compactorbs.widget.elements.Minimap;
import com.compactorbs.widget.elements.Orbs;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.function.Supplier;
import javax.inject.Inject;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.GameState;
import net.runelite.api.widgets.Widget;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.util.ColorUtil;

@Slf4j
public class CompactOrbsManager
{
	@Inject
	private Client client;

	@Inject
	private ConfigManager configManager;

	@Inject
	private CompactOrbsConfig config;

	@Inject
	private WidgetManager widgetManager;

	//store the parent id from the previous widget (modern vs classic): -1 = no parent
	private int previousParentId = -1;

	//offsets for vertical and horizontal layout
	public static int verticalOffset = 0;
	public static int horizontalOffset = 0;

	//offset used to hide the world map outside the container
	public static int worldMapOffset = 0;

	//in-game native minimap hiding
	public boolean minimapMinimized;

	//custom widgets created when in compact layout
	private Widget compassFrame = null;
	private Widget minimapButton = null;
	private Widget compassButton = null;

	private final Map<String, Map.Entry<Supplier<Boolean>, TargetWidget[]>> hideByConfigMap = new HashMap<>();
	private final Map<Integer, Map.Entry<Supplier<Boolean>, TargetWidget[]>> hideByScriptMap = new HashMap<>();

	public void init(int scriptId)
	{
		updateWikiBanner(config.hideWiki());
		updateOrbByScript(scriptId);

		if (!client.isResized())
		{
			updateWorldMap(true);

			//revert changes made when in, or switching to, fixed mode
			if (previousParentId != -1)
			{
				widgetManager.remapTargets(Orbs.FIXED, false, Script.FORCE_UPDATE);
				previousParentId = -1;
			}
			return;
		}

		build(scriptId);
	}

	private void build(int scriptId)
	{
		if (!client.isResized())
		{
			return;
		}

		getLayoutOffsets();

		if (scriptId == Script.FORCE_UPDATE)
		{
			createCustomChildren();

			widgetManager.setTargetsHidden(isMinimapHidden(), Minimap.values());
			widgetManager.setTargetsHidden((isMinimapHidden() && isCompassHidden()), Compass.values());
			widgetManager.remapTargets(Compass.ALL, isMinimapHidden(), Script.FORCE_UPDATE);
			widgetManager.remapTargets(Orbs.ALL, isMinimapHidden(), Script.FORCE_UPDATE);

			updateCustomChildren();
		}
		else
		{
			widgetManager.remapTargets(Orbs.ALL, isMinimapHidden(), scriptId);
		}
	}

	public void reset()
	{
		verticalOffset = 0;
		horizontalOffset = 0;
		worldMapOffset = 0;
		updateWikiBanner(false);

		clearCustomChildren();

		hideByConfigMap.clear();
		hideByScriptMap.clear();

		//set all orbs to visible
		widgetManager.setTargetsHidden(false, Orbs.values());

		if (!client.isResized())
		{
			updateWorldMap(false);
		}

		if (isMinimapHidden())
		{
			widgetManager.setTargetsHidden(false, Minimap.values());

			if (isCompassHidden())
			{
				widgetManager.setTargetsHidden(false, Compass.values());
			}

			widgetManager.remapTargets(Compass.ALL, false, Script.FORCE_UPDATE);
		}

		//protect certain fixed mode orbs from being changed when in fixed mode
		widgetManager.remapTargets((client.isResized() ? Orbs.ALL : Orbs.FIXED), false, Script.FORCE_UPDATE);
	}

	//toggle the minimap visibility, and update related widgets when using the custom toggle button
	private void onMinimapToggle()
	{
		boolean toggle = !isMinimapHidden();
		boolean remapCondition = toggle && !isCompassHidden();
		boolean hiddenCondition = toggle && isCompassHidden();
		executeToggle(
			config::hideMinimap, ConfigKeys.MINIMAP,
			this::getLayoutOffsets,
			() -> widgetManager.setTargetsHidden(toggle, Minimap.values()),
			() -> widgetManager.remapTargets(Compass.ALL, remapCondition, Script.FORCE_UPDATE),
			() -> widgetManager.setTargetsHidden(hiddenCondition, Compass.values()),
			() -> widgetManager.remapTargets(Orbs.ALL, toggle, Script.FORCE_UPDATE),
			this::updateCustomChildren
		);
	}

	//toggle the compass visibility, and update related widgets when using the custom toggle button
	private void onCompassToggle()
	{
		boolean toggle = !isCompassHidden();
		boolean remapCondition = toggle || isMinimapHidden();
		executeToggle(
			config::hideCompass, ConfigKeys.COMPASS,
			this::getLayoutOffsets,
			() -> widgetManager.remapTargets(Compass.ALL, remapCondition, Script.FORCE_UPDATE),
			() -> widgetManager.setTargetsHidden(toggle, Compass.values()),
			this::updateCustomChildren
		);
	}

	//flip the config (key) and execute the chain of actions when using the custom toggle buttons
	private void executeToggle(Supplier<Boolean> getter, String key, Runnable... actions)
	{
		configManager.setConfiguration(GROUP_NAME, key, !Boolean.TRUE.equals(getter.get()));

		for (Runnable action : actions)
		{
			action.run();
		}
	}

	//create the compass frame and toggle buttons, clearing them if the parent id changed,
	//and only creating widgets if missing from the current parent
	public void createCustomChildren()
	{
		Widget parent = widgetManager.getCurrentParent();

		if (parent == null || parent.getId() != previousParentId)
		{
			clearCustomChildren();
			previousParentId = parent != null ? parent.getId() : -1;
			if (parent == null)
			{
				return;
			}
		}

		if (widgetManager.isMissing(compassFrame, parent))
		{
			compassFrame = widgetManager.createGraphic(
				parent,
				0, 0, //handled in updateCustomChildren()
				Layout.FRAME_WIDTH, Layout.FRAME_HEIGHT,
				Layout.OPACITY,
				Sprite.COMPASS_FRAME
			);
		}

		if (widgetManager.isMissing(minimapButton, parent))
		{
			minimapButton = widgetManager.createToggleButton(
				parent,
				Layout.MINIMAP_BUTTON_X, Layout.MINIMAP_BUTTON_Y,
				Layout.TOGGLE_BUTTON_WIDTH, Layout.TOGGLE_BUTTON_HEIGHT,
				Layout.OPACITY,
				getSpriteId(isMinimapHidden()),
				getMenuOption(ConfigKeys.MINIMAP),
				e -> onMinimapToggle(),
				e -> minimapButton.setOpacity(Layout.OPACITY_HOVER),
				e -> minimapButton.setOpacity(Layout.OPACITY)
			);
		}

		if (widgetManager.isMissing(compassButton, parent))
		{
			compassButton = widgetManager.createToggleButton(
				parent,
				0, 0, //handled in updateCustomChildren()
				Layout.TOGGLE_BUTTON_WIDTH, Layout.TOGGLE_BUTTON_HEIGHT,
				Layout.OPACITY,
				getSpriteId(isCompassHidden()),
				getMenuOption(ConfigKeys.COMPASS),
				e -> onCompassToggle(),
				e -> compassButton.setOpacity(Layout.OPACITY_HOVER),
				e -> compassButton.setOpacity(Layout.OPACITY)
			);
		}
	}

	//handle dynamic widget changes for visibility, positions, sprites, and menu actions for the
	//compass frame and toggle buttons (logout X being an exception in native minimap hiding)
	public void updateCustomChildren()
	{
		boolean hideFrame = !isMinimapHidden() || isCompassHidden() || isMinimized();
		boolean hideToggles = (config.hideMinimapToggle() && config.hideCompassToggle()) || isMinimized();

		if (isMinimized())
		{
			//put logout button back when switching to native hiding
			widgetManager.remapTargets(
				List.of(Orbs.LOGOUT_X_ICON, Orbs.LOGOUT_X_STONE),
				false, Script.FORCE_UPDATE);
		}

		if (compassFrame != null)
		{
			compassFrame.setHidden(hideFrame);

			widgetManager.updateValue(compassFrame::getOriginalX, compassFrame::setOriginalX,
				(getCompassX() - Layout.FRAME_X_OFFSET) - verticalOffset);

			widgetManager.updateValue(compassFrame::getOriginalY, compassFrame::setOriginalY,
				(getCompassY() - (Layout.FRAME_Y_OFFSET)) + horizontalOffset);

			compassFrame.revalidate();
		}

		if (minimapButton != null)
		{
			minimapButton.setSpriteId(getSpriteId(!isMinimapHidden()));
			minimapButton.setHidden(hideToggles || config.hideMinimapToggle());
			minimapButton.setAction(0, getMenuOption(ConfigKeys.MINIMAP));

			int minimapButtonX =
				(isVerticalLayout() && isMinimapHidden()) ?
					Layout.MINIMAP_BUTTON_X - verticalOffset : Layout.MINIMAP_BUTTON_X;

			int minimapButtonY =
				(isHorizontalLayout() && isMinimapHidden()) ?
					(Layout.MINIMAP_BUTTON_Y / 2) + horizontalOffset : Layout.MINIMAP_BUTTON_Y;

			widgetManager.updateValue(minimapButton::getOriginalX, minimapButton::setOriginalX, minimapButtonX);
			widgetManager.updateValue(minimapButton::getOriginalY, minimapButton::setOriginalY, minimapButtonY);
			minimapButton.revalidate();
		}

		if (compassButton != null)
		{
			compassButton.setSpriteId(getSpriteId(!isCompassHidden()));
			compassButton.setHidden((hideToggles || config.hideCompassToggle()) || !isMinimapHidden());
			compassButton.setAction(0, getMenuOption(ConfigKeys.COMPASS));

			final int compassButtonX = getCompassX() + (isHorizontalLayout() ?
				Layout.COMPASS_BUTTON_HORIZONTAL_X_OFFSET : 0) + Layout.COMPASS_BUTTON_X_OFFSET;

			final int compassButtonY = getCompassY() - (isHorizontalLayout() ?
				Layout.COMPASS_BUTTON_HORIZONTAL_Y_OFFSET : 0) + Layout.COMPASS_BUTTON_Y_OFFSET;

			widgetManager.updateValue(compassButton::getOriginalX, compassButton::setOriginalX,
				compassButtonX - verticalOffset);

			widgetManager.updateValue(compassButton::getOriginalY, compassButton::setOriginalY,
				compassButtonY + horizontalOffset);

			compassButton.revalidate();
		}
	}

	//clear any created children and reset previous parent id
	private void clearCustomChildren()
	{
		widgetManager.clearChildren(Modern.ORBS);
		widgetManager.clearChildren(Classic.ORBS);

		previousParentId = -1;

		compassFrame = null;
		minimapButton = null;
		compassButton = null;
	}

	//show or hide the wiki banner (vanilla or plugin) based on which exists
	//vanilla = official wiki banner
	public void updateWikiBanner(boolean hidden)
	{
		boolean wikiPluginActive = Boolean.TRUE.equals(
			configManager.getConfiguration(ConfigGroup.RuneLite.GROUP_NAME,
				ConfigKeys.RuneLite.WIKI_PLUGIN, Boolean.class)
		);

		boolean showWikiMinimapButton =
			configManager.getConfiguration(ConfigGroup.Wiki.GROUP_NAME,
				ConfigKeys.Wiki.SHOW_WIKI_MINIMAP_BUTTON, Boolean.class
			);

		//container holding the vanilla or wiki banner
		Widget container = widgetManager.getTargetWidget(Orbs.WIKI_ICON_CONTAINER);
		if (container == null)
		{
			return;
		}

		Widget banner = null;
		boolean vanilla = true;

		//check to see if wiki banner exists
		if (container.getDynamicChildren() != null &&
			container.getDynamicChildren().length > 0)
		{
			banner = container.getChild(0);
			vanilla = false;
		}

		//wiki plugin banner doesn't exist, check vanilla
		if (banner == null)
		{
			banner = widgetManager.getTargetWidget(Orbs.WIKI_VANILLA);
		}

		//guard if either are null
		if (banner == null)
		{
			return;
		}

		boolean shouldHide = hidden || (wikiPluginActive && showWikiMinimapButton && vanilla);
		banner.setHidden(shouldHide);
	}

	//hide world map without breaking the 'Ctrl+M' hotkey; resizable x/y handled via remapTargets
	//@modify - if changes should be made
	public void updateWorldMap(boolean modify)
	{
		//get the worldMapOffset for fixed/resizable
		getWorldMapOffset();

		//prevent fixed mode changes in resizable
		if (client.isResized())
		{
			return;
		}

		Widget worldMap = client.getWidget(Orb.WORLD_MAP);
		if (worldMap == null)
		{
			return;
		}

		int x = config.hideWorld() && modify ? worldMapOffset : Layout.FIXED_WORLD_MAP_X;
		int y = config.hideWorld() && modify ? worldMapOffset : Layout.FIXED_WORLD_MAP_Y;

		widgetManager.updateValue(worldMap::getOriginalX, worldMap::setOriginalX, x);
		widgetManager.updateValue(worldMap::getOriginalY, worldMap::setOriginalY, y);
		worldMap.revalidate();
	}

	private void getLayoutOffsets()
	{
		if (client.getGameState() != GameState.LOGGED_IN)
		{
			return;
		}

		verticalOffset = Layout.Vertical.RIGHT_OFFSET;
		horizontalOffset = Layout.Horizontal.TOP_OFFSET;

		if (isVerticalLayout() &&
			config.verticalPosition() == VerticalPosition.LEFT)
		{
			verticalOffset = (client.isResized() && isMinimapHidden()) ?
				Layout.Vertical.LEFT_OFFSET : Layout.Vertical.RIGHT_OFFSET;
		}

		if (isHorizontalLayout() &&
			config.horizontalPosition() == HorizontalPosition.BOTTOM)
		{
			horizontalOffset = (client.isResized() && isMinimapHidden()) ?
				Layout.Horizontal.BOTTOM_OFFSET : Layout.Horizontal.TOP_OFFSET;
		}

		getWorldMapOffset();
	}

	private void getWorldMapOffset()
	{
		worldMapOffset = (config.hideWorld() ? 1 - Layout.WORLD_MAP_CONTAINER_WIDTH : 0);
	}

	private int getSpriteId(boolean hidden)
	{
		return hidden ? Sprite.VISIBLE : Sprite.HIDDEN;
	}

	private String getMenuOption(String key)
	{
		final boolean isMinimap = ConfigKeys.MINIMAP.equals(key);
		final boolean isHidden = isMinimap ? isMinimapHidden() : isCompassHidden();

		String target = isMinimap ? Menu.SUFFIX_MINIMAP : Menu.SUFFIX_COMPASS;
		String action = isHidden ? Menu.PREFIX_SHOW : Menu.PREFIX_HIDE;

		return action + " " + ColorUtil.wrapWithColorTag(target, Menu.COLOR);
	}

	private boolean isVerticalLayout()
	{
		return config.layout() == OrbLayout.VERTICAL;
	}

	private boolean isHorizontalLayout()
	{
		return config.layout() == OrbLayout.HORIZONTAL;
	}

	private int getCompassX()
	{
		switch (config.layout())
		{
			case VERTICAL: return Layout.Vertical.COMPASS_X;
			case HORIZONTAL: return Layout.Horizontal.COMPASS_X;
			default: return Layout.Original.COMPASS_X;
		}
	}

	private int getCompassY()
	{
		switch (config.layout())
		{
			case VERTICAL: return Layout.Vertical.COMPASS_Y;
			case HORIZONTAL: return Layout.Horizontal.COMPASS_Y;
			default: return Layout.Original.COMPASS_Y;
		}
	}

	public boolean isMinimapHidden()
	{
		return config.hideMinimap();
	}

	private boolean isCompassHidden()
	{
		return config.hideCompass();
	}

	//in-game native minimap hiding
	public boolean isMinimized()
	{
		return minimapMinimized;
	}

	//register an orb toggle entry in the config and script maps
	public void registerOrbToggle(String key, Supplier<Boolean> toggle, TargetWidget... targets)
	{
		hideByConfigMap.put(key, Map.entry(toggle, targets));

		int scriptId = Script.FORCE_UPDATE;
		for (TargetWidget target : targets)
		{
			if (target instanceof Orbs)
			{
				scriptId = target.getScriptId();
				break;
			}
		}

		if (scriptId != Script.FORCE_UPDATE)
		{
			hideByScriptMap.put(scriptId, Map.entry(toggle, targets));
		}
	}

	//apply toggle setting to orbs based on the fired script id; pass FORCE_UPDATE for all toggles
	private void updateOrbByScript(int scriptId)
	{
		(scriptId == Script.FORCE_UPDATE ? hideByConfigMap : hideByScriptMap).forEach(
			(key, value) ->
				widgetManager.setTargetsHidden(value.getKey().get(), value.getValue())
		);
	}

	//apply toggle setting to orbs based on the config key in onConfigChanged
	public void updateOrbByConfig(String key)
	{
		Map.Entry<Supplier<Boolean>, TargetWidget[]> entry = hideByConfigMap.get(key);
		if (entry != null)
		{
			widgetManager.setTargetsHidden(entry.getKey().get(), entry.getValue());
		}
	}

}

/*
 * Copyright (c) 2025, cue <https://github.com/its-cue>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

package com.compactorbs;

import static com.compactorbs.CompactOrbsConstants.ConfigGroup.GROUP_NAME;
import com.compactorbs.CompactOrbsConstants.ConfigKeys;
import com.compactorbs.CompactOrbsConstants.Script;
import com.compactorbs.CompactOrbsConstants.Varbit;
import com.compactorbs.CompactOrbsConstants.VarbitValue;
import com.compactorbs.CompactOrbsConstants.Widgets.Classic;
import com.compactorbs.CompactOrbsConstants.Widgets.Modern;
import com.compactorbs.CompactOrbsConstants.Widgets.Orb;
import com.compactorbs.widget.WidgetManager;
import com.compactorbs.widget.elements.Orbs;
import com.google.inject.Provides;
import javax.inject.Inject;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.GameState;
import net.runelite.api.events.GameStateChanged;
import net.runelite.api.events.ScriptPostFired;
import net.runelite.api.events.VarbitChanged;
import net.runelite.api.events.WidgetLoaded;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.events.ConfigChanged;
import net.runelite.client.input.KeyManager;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.plugins.PluginDescriptor;
import net.runelite.client.util.HotkeyListener;

@Slf4j
@PluginDescriptor(
	name = "Compact Orbs",
	description = "Collapse the minimap orbs into a compact view.",
	tags = {"compact", "orbs", "hide", "minimap", "resizable", "classic", "modern", "world", "map", "wiki"},
	conflicts = {"Fixed Resizable Hybrid", "Orb Hider", "Minimap Hider"}
)
public class CompactOrbsPlugin extends Plugin
{
	@Inject
	private Client client;

	@Inject
	private ClientThread clientThread;

	@Inject
	private CompactOrbsConfig config;

	@Inject
	private CompactOrbsManager manager;

	@Inject
	private ConfigManager configManager;

	@Inject
	private KeyManager keyManager;

	@Inject
	private WidgetManager widgetManager;

	@Override
	protected void startUp() throws Exception
	{
		keyManager.registerKeyListener(hotkeyListener);

		registerOrbToggleEntries();

		if (client.getGameState() == GameState.LOGGED_IN)
		{
			clientThread.invoke(() -> manager.minimapMinimized = (client.getVarbitValue(Varbit.MINIMAP_TOGGLE) == VarbitValue.MINIMAP_MINIMIZED));

			clientThread.invokeLater(() -> manager.init(Script.FORCE_UPDATE));
		}
	}

	@Override
	protected void shutDown() throws Exception
	{
		keyManager.unregisterKeyListener(hotkeyListener);

		clientThread.invoke(manager::reset);
	}

	@Subscribe
	public void onGameStateChanged(GameStateChanged event)
	{
		if (client.getGameState() == GameState.LOGGED_IN)
		{
			manager.createCustomChildren();
		}
	}

	@Subscribe
	public void onScriptPostFired(ScriptPostFired event)
	{
		int scriptId = event.getScriptId();

		//make sure the logout X stays hidden
		if (scriptId == Script.TOP_LEVEL_REDRAW || scriptId == Script.TOP_LEVEL_SIDE_CUSTOMIZE)
		{
			if (config.hideLogout() && !manager.isMinimized())
			{
				widgetManager.setTargetsHidden(config.hideLogout(), Orbs.LOGOUT_X_ICON, Orbs.LOGOUT_X_STONE);
			}
		}

		if (!Script.MINIMAP_UPDATE_SCRIPTS.contains(scriptId) || manager.isMinimized())
		{
			return;
		}

		//override the in-game settings
		if (scriptId == Script.ACTIVITY_ORB_UPDATE &&
			client.getVarbitValue(Varbit.ACTIVITY_ORB_TOGGLE) == VarbitValue.ACTIVITY_ORB_VISIBLE &&
			config.hideActivity())
		{
			widgetManager.setHidden(Orbs.ACTIVITY_ORB_CONTAINER, config.hideActivity());
			return;
		}

		//override the in-game settings
		if (scriptId == Script.STORE_ORB_UPDATE &&
			client.getVarbitValue(Varbit.STORE_ORB_TOGGLE) == VarbitValue.STORE_ORB_VISIBLE &&
			config.hideStore())
		{
			widgetManager.setHidden(Orbs.STORE_ORB_CONTAINER, config.hideStore());
			return;
		}

		if (scriptId == Script.WIKI_ICON_UPDATE || scriptId == Script.WIKI_CONTAINER_UPDATE)
		{
			manager.updateWikiBanner(config.hideWiki());
		}

		manager.init(scriptId);
	}

	@Subscribe
	public void onVarbitChanged(VarbitChanged event)
	{
		int id = event.getVarbitId();

		if (id == Varbit.MINIMAP_TOGGLE)
		{
			//hide custom buttons when native minimap hiding is active
			manager.minimapMinimized = (event.getValue() == VarbitValue.MINIMAP_MINIMIZED);
			manager.updateCustomChildren();
		}
	}

	@Subscribe
	public void onWidgetLoaded(WidgetLoaded event)
	{
		int id = event.getGroupId();

		if (id == WidgetManager.getInterfaceId(Orb.UNIVERSE) ||
			id == WidgetManager.getInterfaceId(Classic.ORBS) ||
			id == WidgetManager.getInterfaceId(Modern.ORBS))
		{
			manager.init(Script.FORCE_UPDATE);
		}
	}

	@Subscribe
	public void onConfigChanged(ConfigChanged event)
	{
		String group = event.getGroup();
		String key = event.getKey();

		if (group.equals(GROUP_NAME))
		{
			switch (key)
			{
				case ConfigKeys.MINIMAP_TOGGLE_BUTTON:
				case ConfigKeys.COMPASS_TOGGLE_BUTTON:
					clientThread.invokeLater(manager::updateCustomChildren);
					break;

				case ConfigKeys.ORB_LAYOUT:
				case ConfigKeys.HORIZONTAL:
				case ConfigKeys.VERTICAL:
					clientThread.invokeLater(() -> manager.init(Script.FORCE_UPDATE));
					break;

				case ConfigKeys.HIDE_WIKI:
					clientThread.invokeLater(() -> manager.updateWikiBanner(config.hideWiki()));
					break;

				case ConfigKeys.HIDE_WORLD:
					//returns early if !client.isResized, but still gets worldMapOffset for both
					clientThread.invokeLater(() -> manager.updateWorldMap(true));

					if (client.isResized())
					{
						clientThread.invokeLater(() -> widgetManager.remapTarget(Orbs.WORLD_MAP_CONTAINER, manager.isMinimapHidden()));
					}
					break;

				default:
					clientThread.invokeLater(() -> manager.updateOrbByConfig(event.getKey()));
					break;
			}
		}
	}

	//register all orb toggles on startup
	public void registerOrbToggleEntries()
	{
		manager.registerOrbToggle(ConfigKeys.HIDE_HP, config::hideHp, Orbs.HP_ORB_CONTAINER);
		manager.registerOrbToggle(ConfigKeys.HIDE_PRAYER, config::hidePray, Orbs.PRAYER_ORB_CONTAINER);
		manager.registerOrbToggle(ConfigKeys.HIDE_RUN, config::hideRun, Orbs.RUN_ORB_CONTAINER);
		manager.registerOrbToggle(ConfigKeys.HIDE_SPEC, config::hideSpec, Orbs.SPEC_ORB_CONTAINER);
		manager.registerOrbToggle(ConfigKeys.HIDE_XP, config::hideXp, Orbs.XP_DROPS_CONTAINER);
		manager.registerOrbToggle(ConfigKeys.HIDE_ACTIVITY, config::hideActivity, Orbs.ACTIVITY_ORB_CONTAINER);
		manager.registerOrbToggle(ConfigKeys.HIDE_STORE, config::hideStore, Orbs.STORE_ORB_CONTAINER);
		manager.registerOrbToggle(ConfigKeys.HIDE_LOGOUT_X, config::hideLogout, Orbs.LOGOUT_X_ICON, Orbs.LOGOUT_X_STONE);
		manager.registerOrbToggle(ConfigKeys.HIDE_GRID, config::hideGrid, Orbs.GRID_MASTER_ORB_CONTAINER);
		//wiki banner and world map are excluded for special handling; updateWikiBanner, updateWorldMap
	}

	private final HotkeyListener hotkeyListener = new HotkeyListener(() -> config.toggleButtonHotkey())
	{
		@Override
		public void hotkeyPressed()
		{
			boolean hidden = !(config.hideMinimapToggle() || config.hideCompassToggle());

			configManager.setConfiguration(GROUP_NAME, ConfigKeys.MINIMAP_TOGGLE_BUTTON, hidden);
			configManager.setConfiguration(GROUP_NAME, ConfigKeys.COMPASS_TOGGLE_BUTTON, hidden);

			clientThread.invokeLater(manager::updateCustomChildren);
		}
	};

	@Provides
	CompactOrbsConfig provideConfig(ConfigManager configManager)
	{
		return configManager.getConfig(CompactOrbsConfig.class);
	}
}

/*
 * Copyright (c) 2025, cue <https://github.com/its-cue>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

package com.compactorbs;

import java.awt.Color;
import java.util.Set;
import net.runelite.api.ScriptID;
import net.runelite.api.gameval.InterfaceID;
import net.runelite.api.gameval.SpriteID;
import net.runelite.api.gameval.VarbitID;

public class CompactOrbsConstants
{
	public static final class ConfigGroup
	{
		public static final String GROUP_NAME = "compactorbs";

		public static final class Wiki
		{
			public static final String GROUP_NAME = "wiki";
		}

		public static final class RuneLite
		{
			public static final String GROUP_NAME = "runelite";
		}
	}

	public static final class ConfigKeys
	{
		public static final String MINIMAP = "hideMinimap";
		public static final String COMPASS = "hideCompass";
		public static final String HOTKEY_TOGGLE = "hotkeyToggle";
		public static final String MINIMAP_TOGGLE_BUTTON = "hideMinimapButton";
		public static final String COMPASS_TOGGLE_BUTTON = "hideCompassButton";
		public static final String ORB_LAYOUT = "orbLayout";
		public static final String HORIZONTAL = "horizontalPosition";
		public static final String VERTICAL = "verticalPosition";
		public static final String HIDE_HP = "hideHp";
		public static final String HIDE_PRAYER = "hidePrayer";
		public static final String HIDE_RUN = "hideRun";
		public static final String HIDE_SPEC = "hideSpec";
		public static final String HIDE_XP = "hideXp";
		public static final String HIDE_WORLD = "hideWorld";
		public static final String HIDE_ACTIVITY = "hideActivity";
		public static final String HIDE_STORE = "hideStore";
		public static final String HIDE_WIKI = "hideWiki";
		public static final String HIDE_LOGOUT_X = "hideLogoutX";
		public static final String HIDE_GRID = "hideGrid";

		public static final class Wiki
		{
			public static final String SHOW_WIKI_MINIMAP_BUTTON = "showWikiMinimapButton";
		}

		public static final class RuneLite
		{
			public static final String WIKI_PLUGIN = "wikiplugin";
		}
	}

	public static final class Varbit
	{
		public static final int MINIMAP_TOGGLE = VarbitID.MINIMAP_TOGGLE;
		public static final int ACTIVITY_ORB_TOGGLE = VarbitID.OPTION_CONTENT_RECOMMENDER_HIDE;
		public static final int STORE_ORB_TOGGLE = VarbitID.TLI_STOREBUTTON_TOGGLE_DESKTOP;
	}

	public static final class VarbitValue
	{
		// 1 (is minimized), 0 (not minimized)
		public static final int MINIMAP_MINIMIZED = 1;

		// 0 (is visible), 1 (not visible)
		public static final int ACTIVITY_ORB_VISIBLE = 0;

		// 1 (is visible), 0 (not visible)
		public static final int STORE_ORB_VISIBLE = 1;
	}

	public static final class Script
	{
		//custom flag, used to trigger remapping without scriptId matching
		public static final int FORCE_UPDATE = -1;

		//logout X redraw when opening tabs/using hotkey
		public static final int TOP_LEVEL_REDRAW = ScriptID.TOPLEVEL_REDRAW;
		public static final int TOP_LEVEL_SIDE_CUSTOMIZE = 919;

		//relevant update scripts for the target orbs
		public static final int WORLD_MAP_UPDATE = 1700;
		public static final int STORE_ORB_UPDATE = 2396;
		public static final int ACTIVITY_ORB_UPDATE = 2480;
		public static final int WIKI_CONTAINER_UPDATE = 3305;
		public static final int WIKI_ICON_UPDATE = ScriptID.WIKI_ICON_UPDATE;
		public static final int GRID_MASTER_ORB_UPDATE = 8222;

		public static final Set<Integer> MINIMAP_UPDATE_SCRIPTS =
			Set.of(
				WORLD_MAP_UPDATE,
				STORE_ORB_UPDATE,
				ACTIVITY_ORB_UPDATE,
				WIKI_CONTAINER_UPDATE,
				WIKI_ICON_UPDATE,
				GRID_MASTER_ORB_UPDATE
			);
	}

	/* Layout positions, dimensions, and other style changes */
	public static final class Layout
	{
		/* Original positions for orb/compass widgets */
		public static final class Original
		{
			public static final int XP_DROPS_X = 0;
			public static final int XP_DROPS_Y = 17;

			public static final int HP_ORB_X = 0;
			public static final int HP_ORB_Y = 37;

			public static final int PRAYER_ORB_X = 0;
			public static final int PRAYER_ORB_Y = 71;

			public static final int RUN_ORB_X = 10;
			public static final int RUN_ORB_Y = 103;

			public static final int SPEC_ORB_X = 32;
			public static final int SPEC_ORB_Y = 128;

			public static final int STORE_ORB_X = 85;
			public static final int STORE_ORB_Y = 143;

			public static final int ACTIVITY_ORB_X = 55;
			public static final int ACTIVITY_ORB_Y = 162;

			public static final int WORLD_MAP_X = 0;
			public static final int WORLD_MAP_Y = 115;

			public static final int WIKI_ICON_X = 0;
			public static final int WIKI_ICON_Y = 135;

			public static final int WIKI_VANILLA_X = 0;
			public static final int WIKI_VANILLA_Y = 10;

			public static final int LOGOUT_X = 2;
			public static final int LOGOUT_Y = 2;

			public static final int COMPASS_X = 34;
			public static final int COMPASS_Y = 5;
		}

		/* Vertical positions for orb/compass widgets */
		public static final class Vertical
		{
			public static final int XP_DROPS_X = 68;
			public static final int XP_DROPS_Y = 44;

			public static final int HP_ORB_X = 0;
			public static final int HP_ORB_Y = 41;

			public static final int PRAYER_ORB_X = 0;
			public static final int PRAYER_ORB_Y = 76;

			public static final int RUN_ORB_X = 0;
			public static final int RUN_ORB_Y = 111;

			public static final int SPEC_ORB_X = 0;
			public static final int SPEC_ORB_Y = 146;

			public static final int STORE_ORB_X = 64;
			public static final int STORE_ORB_Y = 103;

			public static final int ACTIVITY_ORB_X = 64;
			public static final int ACTIVITY_ORB_Y = 138;

			public static final int WORLD_MAP_X = 66;
			public static final int WORLD_MAP_Y = 72;

			public static final int WIKI_ICON_X = 20;
			public static final int WIKI_ICON_Y = 172;

			public static final int WIKI_VANILLA_X = 0;
			public static final int WIKI_VANILLA_Y = 5;

			public static final int LOGOUT_X = 8;
			public static final int LOGOUT_Y = 22;

			public static final int COMPASS_X = Original.COMPASS_X + 94;
			public static final int COMPASS_Y = Original.COMPASS_Y + 13;

			//vertical offset
			public static final int LEFT_OFFSET = 108;
			public static final int RIGHT_OFFSET = 0;
		}

		/* Horizontal positions for orb/compass widgets */
		public static final class Horizontal
		{
			public static final int XP_DROPS_X = 179;
			public static final int XP_DROPS_Y = 27;

			public static final int HP_ORB_X = 35;
			public static final int HP_ORB_Y = 35;

			public static final int PRAYER_ORB_X = 35;
			public static final int PRAYER_ORB_Y = 70;

			public static final int RUN_ORB_X = 92;
			public static final int RUN_ORB_Y = 35;

			public static final int SPEC_ORB_X = 92;
			public static final int SPEC_ORB_Y = 70;

			public static final int STORE_ORB_X = 0;
			public static final int STORE_ORB_Y = 35;

			public static final int ACTIVITY_ORB_X = 0;
			public static final int ACTIVITY_ORB_Y = 70;

			public static final int WORLD_MAP_X = 31;//148
			public static final int WORLD_MAP_Y = 16;

			public static final int WIKI_ICON_X = 149;
			public static final int WIKI_ICON_Y = 82;

			public static final int WIKI_VANILLA_X = 0;
			public static final int WIKI_VANILLA_Y = 5;

			public static final int LOGOUT_X = 1;
			public static final int LOGOUT_Y = 2;

			public static final int COMPASS_X = Original.COMPASS_X + 117;
			public static final int COMPASS_Y = Original.COMPASS_Y + 57;

			//horizontal offset
			public static final int TOP_OFFSET = 0;
			public static final int BOTTOM_OFFSET = 90;
		}

		//world map x and y when in fixed mode
		public static final int FIXED_WORLD_MAP_X = 10;
		public static final int FIXED_WORLD_MAP_Y = 115;

		//used when hiding the world map orb, to calc the offset so the hotkey still works
		public static final int WORLD_MAP_CONTAINER_WIDTH = 30;

		//compass menu op offset
		public static final int COMPASS_OPTIONS_OFFSET = 2;

		//offsets used to anchor the frame around the compass
		public static final int FRAME_X_OFFSET = 4;
		public static final int FRAME_Y_OFFSET = 14;

		//offsets used to anchor the toggle button around the compass sprite
		public static final int COMPASS_BUTTON_X_OFFSET = 31;
		public static final int COMPASS_BUTTON_Y_OFFSET = 14;

		//offsets used in horizontal layout, to position the compass button
		public static final int COMPASS_BUTTON_HORIZONTAL_X_OFFSET = 4;
		public static final int COMPASS_BUTTON_HORIZONTAL_Y_OFFSET = 22;

		//location of the minimap toggle button
		public static final int MINIMAP_BUTTON_X = 190;
		public static final int MINIMAP_BUTTON_Y = 180;

		//toggle button dimensions
		public static final int TOGGLE_BUTTON_WIDTH = 17;
		public static final int TOGGLE_BUTTON_HEIGHT = 17;

		//compass frame dimensions
		public static final int FRAME_WIDTH = 43;
		public static final int FRAME_HEIGHT = 43;

		//toggle button opacity when onMouseOver || onMouseLeave
		public static final int OPACITY = 0;
		public static final int OPACITY_HOVER = 130;
	}

	public static final class Menu
	{
		//prefix menu options for the toggle buttons
		public static final String PREFIX_SHOW = "Show";
		public static final String PREFIX_HIDE = "Hide";

		//suffix menu options for the toggle buttons
		public static final String SUFFIX_MINIMAP = "Minimap";
		public static final String SUFFIX_COMPASS = "Compass";

		//suffix menu color for the toggle buttons
		public static final Color COLOR = new Color(0xFF9040);
	}

	public static final class Sprite
	{
		//border frame for the compass when the minimap is hidden
		public static final int COMPASS_FRAME = SpriteID.COMPASS_OUTLINE;

		//toggle button sprites
		public static final int HIDDEN = SpriteID.GroundItemsVisibility._1;
		public static final int VISIBLE = SpriteID.GroundItemsVisibility._0;

		//widget inspector sprite
		public static final int WIDGET_INSPECTOR = SpriteID.OptionsIcons._50;
	}

	public static final class Widgets
	{
		public static final class Orb
		{
			//orbs container interface
			public static final int UNIVERSE = InterfaceID.Orbs.UNIVERSE;

			//orb containers
			public static final int XP_DROPS = InterfaceID.Orbs.XP_DROPS;
			public static final int HP_ORB = InterfaceID.Orbs.ORB_HEALTH;
			public static final int PRAY_ORB = InterfaceID.Orbs.ORB_PRAYER;
			public static final int RUN_ORB = InterfaceID.Orbs.ORB_RUNENERGY;
			public static final int SPEC_ORB = InterfaceID.Orbs.ORB_SPECENERGY;
			public static final int ACTIVITY_ORB = InterfaceID.Orbs.ORB_CONTENTRECOM;
			public static final int STORE_ORB = InterfaceID.Orbs.ORB_STORE;
			public static final int WIKI_ICON = InterfaceID.Orbs.WIKI;
			public static final int WIKI_ICON_VANILLA = InterfaceID.Orbs.WIKI_ICON;
			public static final int WORLD_MAP = InterfaceID.Orbs.ORB_WORLDMAP;
		}

		//classic-resizable widgets
		public static final class Classic
		{
			public static final int ORBS = InterfaceID.ToplevelOsrsStretch.ORBS;

			public static final int MAP_NOCLICK_0 = InterfaceID.ToplevelOsrsStretch.MAP_NOCLICK_0;
			public static final int MAP_NOCLICK_1 = InterfaceID.ToplevelOsrsStretch.MAP_NOCLICK_1;
			public static final int MAP_NOCLICK_2 = InterfaceID.ToplevelOsrsStretch.MAP_NOCLICK_2;
			public static final int MAP_NOCLICK_3 = InterfaceID.ToplevelOsrsStretch.MAP_NOCLICK_3;
			public static final int MAP_NOCLICK_4 = InterfaceID.ToplevelOsrsStretch.MAP_NOCLICK_4;
			public static final int MAP_NOCLICK_5 = InterfaceID.ToplevelOsrsStretch.MAP_NOCLICK_5;

			public static final int MINIMAP_MASK = InterfaceID.ToplevelOsrsStretch.MINIMAP;
			public static final int MINIMAP = InterfaceID.ToplevelOsrsStretch.MAP_MINIMAP_GRAPHIC9;

			public static final int COMPASS = InterfaceID.ToplevelOsrsStretch.MAP_MINIMAP_GRAPHIC6;
			public static final int COMPASS_OPTIONS = InterfaceID.ToplevelOsrsStretch.COMPASSCLICK;

			public static final int COMPASS_PARENT = InterfaceID.ToplevelOsrsStretch.MAP_MINIMAP;
		}

		//modern-resizable widgets
		public static final class Modern
		{
			public static final int ORBS = InterfaceID.ToplevelPreEoc.ORBS;

			public static final int MAP_NOCLICK_0 = InterfaceID.ToplevelPreEoc.MAP_NOCLICK_0;
			public static final int MAP_NOCLICK_1 = InterfaceID.ToplevelPreEoc.MAP_NOCLICK_1;
			public static final int MAP_NOCLICK_2 = InterfaceID.ToplevelPreEoc.MAP_NOCLICK_2;
			public static final int MAP_NOCLICK_3 = InterfaceID.ToplevelPreEoc.MAP_NOCLICK_3;
			public static final int MAP_NOCLICK_4 = InterfaceID.ToplevelPreEoc.MAP_NOCLICK_4;
			public static final int MAP_NOCLICK_5 = InterfaceID.ToplevelPreEoc.MAP_NOCLICK_5;

			public static final int MINIMAP_MASK = InterfaceID.ToplevelPreEoc.MINIMAP;
			public static final int MINIMAP = InterfaceID.ToplevelPreEoc.MAP_MINIMAP_GRAPHIC9;

			public static final int COMPASS = InterfaceID.ToplevelPreEoc.MAP_MINIMAP_GRAPHIC6;
			public static final int COMPASS_OPTIONS = InterfaceID.ToplevelPreEoc.COMPASSCLICK;

			public static final int COMPASS_PARENT = InterfaceID.ToplevelPreEoc.MAP_MINIMAP;

			public static final int LOGOUT_X_ICON = InterfaceID.ToplevelPreEoc.ICON10;
			public static final int LOGOUT_X_STONE = InterfaceID.ToplevelPreEoc.STONE10;
		}
	}
}

/*
 * Copyright (c) 2025, cue <https://github.com/its-cue>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

package com.compactorbs;

import static com.compactorbs.CompactOrbsConstants.ConfigGroup.GROUP_NAME;
import com.compactorbs.CompactOrbsConstants.ConfigKeys;
import java.awt.event.KeyEvent;
import lombok.Getter;
import lombok.RequiredArgsConstructor;
import net.runelite.client.config.Config;
import net.runelite.client.config.ConfigGroup;
import net.runelite.client.config.ConfigItem;
import net.runelite.client.config.ConfigSection;
import net.runelite.client.config.Keybind;

@ConfigGroup(GROUP_NAME)
public interface CompactOrbsConfig extends Config
{
	@Getter
	@RequiredArgsConstructor
	enum OrbLayout
	{
		VERTICAL(0),
		HORIZONTAL(1);

		private final int index;
	}

	enum VerticalPosition
	{
		LEFT, RIGHT;
	}

	enum HorizontalPosition
	{
		TOP, BOTTOM;
	}

	@ConfigSection(
		name = "Compact Settings",
		description = "Options to modify the layout and toggle buttons",
		position = 0
	)
	String compact = "compact";

	@ConfigItem(
		keyName = ConfigKeys.MINIMAP,
		name = "Hide minimap",
		description = "Enable the ability to collapse the minimap to reposition the orbs",
		hidden = true
	)
	default boolean hideMinimap()
	{
		return false;
	}

	@ConfigItem(
		keyName = ConfigKeys.COMPASS,
		name = "Hide compass",
		description = "Enable the ability to hide the compass, only when the minimap is hidden",
		hidden = true
	)
	default boolean hideCompass()
	{
		return false;
	}

	@ConfigItem(
		keyName = ConfigKeys.HOTKEY_TOGGLE,
		name = "Hotkey",
		description = "Toggle the visibility of the in-game toggle buttons via hotkey",
		section = compact,
		position = 1
	)
	default Keybind toggleButtonHotkey()
	{
		return new Keybind(KeyEvent.VK_INSERT, KeyEvent.SHIFT_DOWN_MASK);
	}

	@ConfigItem(
		keyName = ConfigKeys.MINIMAP_TOGGLE_BUTTON,
		name = "Hide minimap button",
		description = "Toggle the visibility of toggle button for the minimap",
		section = compact,
		position = 2
	)
	default boolean hideMinimapToggle()
	{
		return false;
	}

	@ConfigItem(
		keyName = ConfigKeys.COMPASS_TOGGLE_BUTTON,
		name = "Hide compass button",
		description = "Toggle the visibility of toggle button for the compass",
		section = compact,
		position = 3
	)
	default boolean hideCompassToggle()
	{
		return false;
	}

	@ConfigItem(
		keyName = ConfigKeys.ORB_LAYOUT,
		name = "Layout",
		description = "Switch between a compact vertical or horizontal layout",
		section = compact,
		position = 4
	)
	default OrbLayout layout()
	{
		return OrbLayout.VERTICAL;
	}

	@ConfigItem(
		keyName = ConfigKeys.HORIZONTAL,
		name = "Horizontal position",
		description = "Draw orbs from the top or bottom when using the compact horizontal layout",
		section = compact,
		position = 5
	)
	default HorizontalPosition horizontalPosition()
	{
		return HorizontalPosition.BOTTOM;
	}

	@ConfigItem(
		keyName = ConfigKeys.VERTICAL,
		name = "Vertical position",
		description = "Draw orbs from left or right when using the compact vertical layout",
		section = compact,
		position = 6
	)
	default VerticalPosition verticalPosition()
	{
		return VerticalPosition.RIGHT;
	}

	@ConfigItem(
		keyName = ConfigKeys.HIDE_HP,
		name = "Hide Hp",
		description = "Toggle visibility of the HP orb",
		position = 1
	)
	default boolean hideHp()
	{
		return false;
	}

	@ConfigItem(
		keyName = ConfigKeys.HIDE_PRAYER,
		name = "Hide Prayer",
		description = "Toggle visibility of the Prayer orb",
		position = 2
	)
	default boolean hidePray()
	{
		return false;
	}

	@ConfigItem(
		keyName = ConfigKeys.HIDE_RUN,
		name = "Hide Run",
		description = "Toggle visibility of the Run energy orb",
		position = 3
	)
	default boolean hideRun()
	{
		return false;
	}

	@ConfigItem(
		keyName = ConfigKeys.HIDE_SPEC,
		name = "Hide Special",
		description = "Toggle visibility of the Special attack energy orb",
		position = 4
	)
	default boolean hideSpec()
	{
		return false;
	}

	@ConfigItem(
		keyName = ConfigKeys.HIDE_XP,
		name = "Hide XP",
		description = "Toggle visibility of the XP drops orb",
		position = 5
	)
	default boolean hideXp()
	{
		return false;
	}

	@ConfigItem(
		keyName = ConfigKeys.HIDE_WORLD,
		name = "Hide World Map",
		description = "Toggle the visibility of the World Map <br>"
			+ " Will retain hotkey functionality 'Ctrl + M', if in-game setting is enabled",
		position = 6
	)
	default boolean hideWorld()
	{
		return false;
	}

	@ConfigItem(
		keyName = ConfigKeys.HIDE_ACTIVITY,
		name = "Hide Activity Advisor",
		description = "Toggle the visibility of the Activity Advisor orb <br>"
			+ "In-game setting must be be enabled",
		position = 7
	)
	default boolean hideActivity()
	{
		return false;
	}

	@ConfigItem(
		keyName = ConfigKeys.HIDE_STORE,
		name = "Hide Store",
		description = "Toggle the visibility of the Store orb <br>"
			+ "In-game setting must be be enabled",
		position = 8
	)
	default boolean hideStore()
	{
		return false;
	}

	@ConfigItem(
		keyName = ConfigKeys.HIDE_WIKI,
		name = "Hide Wiki banner",
		description = "Toggle the visibility of the Wiki banner <br>"
			+ "In-game setting must be be enabled",
		position = 9
	)
	default boolean hideWiki()
	{
		return false;
	}

	@ConfigItem(
		keyName = ConfigKeys.HIDE_LOGOUT_X,
		name = "Hide Logout X",
		description = "Toggle the visibility of the Logout-X when in resizable-modern display mode",
		position = 10
	)
	default boolean hideLogout()
	{
		return false;
	}

	@ConfigItem(
		keyName = ConfigKeys.HIDE_GRID,
		name = "Hide Grid Master",
		description = "Toggle the visibility of the Grid Master orb",
		position = 11
	)
	default boolean hideGrid()
	{
		return false;
	}

}

/*
 * Copyright (c) 2025, cue <https://github.com/its-cue>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

package com.compactorbs.widget;

import com.compactorbs.CompactOrbsConfig;
import com.compactorbs.CompactOrbsConstants;
import com.compactorbs.CompactOrbsConstants.Script;
import com.compactorbs.CompactOrbsConstants.Widgets.Classic;
import com.compactorbs.CompactOrbsConstants.Widgets.Modern;
import com.compactorbs.CompactOrbsConstants.Widgets.Orb;
import static com.compactorbs.CompactOrbsManager.horizontalOffset;
import static com.compactorbs.CompactOrbsManager.verticalOffset;
import static com.compactorbs.CompactOrbsManager.worldMapOffset;
import com.compactorbs.util.SetValue;
import com.compactorbs.util.ValueKey;
import com.compactorbs.widget.elements.Orbs;
import java.util.function.IntConsumer;
import java.util.function.IntSupplier;
import javax.inject.Inject;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.widgets.JavaScriptCallback;
import net.runelite.api.widgets.Widget;
import net.runelite.api.widgets.WidgetType;

@Slf4j
public class WidgetManager
{
	@Inject
	private Client client;

	@Inject
	private CompactOrbsConfig config;

	public boolean targetRemapped = false;

	//update multiple widgets that match the script id (FORCE_UPDATE bypasses the check)
	public void remapTargets(Iterable<? extends TargetWidget> widgets, boolean modify, int scriptId)
	{
		for (TargetWidget target : widgets)
		{
			if (!shouldUpdateTarget(target, scriptId))
			{
				continue;
			}

			remapTarget(target, modify);
		}
	}

	//update a target widgets X/Y or position mode, based on layout, if necessary
	public void remapTarget(TargetWidget target, boolean modify)
	{
		Widget widget = getTargetWidget(target);
		if (widget == null)
		{
			return;
		}

		targetRemapped = false;

		//ignore the widget inspector (shares same container/index as grid master)
		if (target == Orbs.GRID_MASTER_ORB_CONTAINER &&
			widget.getSpriteId() == CompactOrbsConstants.Sprite.WIDGET_INSPECTOR)
		{
			return;
		}

		target.getPositions().forEach((key, value) ->
			setValue(widget, key, value, modify)
		);

		if (targetRemapped)
		{
			widget.revalidate();
		}
	}

	//sets the widgets X/Y or position mode as necessary
	private void setValue(Widget widget, ValueKey key, SetValue value, boolean modify)
	{
		if (value == null)
		{
			return;
		}

		//@index for the modified value, tied to enum OrbLayout()
		Integer v = value.get(modify, config.layout().getIndex());
		if (v == null)
		{
			return;
		}

		//handle dynamic offsets for widgets, based on layout and config settings
		int offset = getOffset(widget, key, v, modify);

		switch (key)
		{
			case X:
				updateValue(widget::getOriginalX, widget::setOriginalX, offset);
				break;
			case Y:
				updateValue(widget::getOriginalY, widget::setOriginalY, offset);
				break;
			case X_POSITION_MODE:
				updateValue(widget::getXPositionMode, widget::setXPositionMode, v);
				break;
			case Y_POSITION_MODE:
				updateValue(widget::getYPositionMode, widget::setYPositionMode, v);
				break;
		}
	}

	//sets a value only if it has changed
	public void updateValue(IntSupplier getter, IntConsumer setter, int value)
	{
		if (getter.getAsInt() != value)
		{
			setter.accept(value);
			targetRemapped = true;
		}
	}

	//returns the widgets offset based on key, layout, and config settings
	private int getOffset(Widget widget, ValueKey key, int value, boolean modify)
	{
		boolean isCompass = widget.getParentId() == Modern.COMPASS_PARENT || widget.getParentId() == Classic.COMPASS_PARENT;
		boolean isWikiBanner = widget.getParentId() == Orb.WIKI_ICON;
		boolean isWorldMap = widget.getId() == Orb.WORLD_MAP;

		if (isWikiBanner)
		{
			return value;
		}

		int offset = (key == ValueKey.X ? verticalOffset : horizontalOffset);

		if (isCompass && key == ValueKey.X)
		{
			return value - offset;
		}

		if (isWorldMap)
		{
			int v = (modify ? (config.hideWorld() ? 0 : value + offset) : value);
			return v + worldMapOffset;
		}

		return (!modify ? value : value + offset);
	}

	//set visibility for target widgets, excluding the wiki banner (handled in updateWikiBanner)
	public void setTargetsHidden(boolean hidden, TargetWidget... widgets)
	{
		for (TargetWidget target : widgets)
		{
			if (target == Orbs.WIKI_VANILLA || target == Orbs.WIKI_ICON_CONTAINER)
			{
				continue;
			}

			setHidden(target, hidden);
		}
	}

	//set visibility for a target widget and its children (if they exist), if necessary
	public void setHidden(TargetWidget target, boolean hidden)
	{
		Widget widget = getTargetWidget(target);
		if (widget == null)
		{
			return;
		}

		if (target == Orbs.GRID_MASTER_ORB_CONTAINER &&
			widget.getSpriteId() == CompactOrbsConstants.Sprite.WIDGET_INSPECTOR)
		{
			return;
		}

		if (hidden != widget.isHidden())
		{
			widget.setHidden(hidden);

			//specifically for compass menu options (could be others?)
			if (widget.getChildren() != null)
			{
				for (Widget child : widget.getChildren())
				{
					if (child != null)
					{
						child.setHidden(hidden);
					}
				}
			}
		}
	}

	//get the widget for the given TargetWidget
	public Widget getTargetWidget(TargetWidget target)
	{
		Widget widget = client.getWidget(target.getComponentId());
		if (widget == null)
		{
			return null;
		}
		if (target.getArrayId() == -1)
		{
			return widget;
		}
		return widget.getChild(target.getArrayId());
	}

	//returns the current visible parent widget
	public Widget getCurrentParent()
	{
		Widget parent = getParent(Modern.ORBS);
		if (parent != null && !parent.isHidden())
		{
			return parent;
		}

		return getParent(Classic.ORBS);
	}

	//returns the parent widget for the given component ID
	//can exist and be hidden, so making sure to check for visibility
	public Widget getParent(int componentId)
	{
		Widget parent = client.getWidget(componentId);
		if (parent != null && !parent.isHidden())
		{
			return parent;
		}

		return null;
	}

	//remove all children from the given component id (if they exist, used for custom children)
	public void clearChildren(int componentId)
	{
		Widget widget = client.getWidget(componentId);
		if (widget != null)
		{
			Widget child = widget.getChild(0);
			if (child != null)
			{
				widget.deleteAllChildren();
			}
		}
	}

	//check if a target widget should be updated based on script id (or FORCE_UPDATE)
	private boolean shouldUpdateTarget(TargetWidget target, int scriptId)
	{
		return (scriptId == Script.FORCE_UPDATE) || target.getScriptId() == scriptId;
	}

	//check if the child is missing, or not a child of the given parent widget
	public boolean isMissing(Widget child, Widget parent)
	{
		return child == null || child.getParentId() != parent.getId();
	}

	//return the interface id from the component id
	public static int getInterfaceId(int componentId)
	{
		return componentId >> 16;
	}

	//return the child id from the component id
	public static int getChildId(int componentId)
	{
		return componentId & 0xff;
	}

	//create a simple graphic widget
	public Widget createGraphic(
		Widget parent,
		int x, int y,
		int width, int height,
		int opacity,
		int spriteId)
	{
		Widget graphic = parent.createChild(-1, WidgetType.GRAPHIC);
		graphic
			.setOriginalX(x)
			.setOriginalY(y)
			.setOriginalWidth(width)
			.setOriginalHeight(height)
			.setOpacity(opacity)
			.setHidden(false)
			.setSpriteId(spriteId);

		return graphic;
	}

	//create an interactive toggle button (with sprite, menu option, and optional event listeners)
	public Widget createToggleButton(
		Widget parent,
		int x, int y,
		int width, int height,
		int opacity,
		int spriteId,
		String menuOp,
		JavaScriptCallback opListener,
		JavaScriptCallback mouseOver,
		JavaScriptCallback mouseLeave)
	{
		Widget button = createGraphic(parent, x, y, width, height, opacity, spriteId);
		button.setHasListener(true);
		button.setNoClickThrough(true);

		if (menuOp != null)
		{
			button.setAction(0, menuOp);
		}
		if (opListener != null)
		{
			button.setOnOpListener(opListener);
		}
		if (mouseOver != null)
		{
			button.setOnMouseOverListener(mouseOver);
		}
		if (mouseLeave != null)
		{
			button.setOnMouseLeaveListener(mouseLeave);
		}

		return button;
	}
}

/*
 * Copyright (c) 2025, cue <https://github.com/its-cue>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

package com.compactorbs.widget;

import com.compactorbs.util.SetValue;
import com.compactorbs.util.ValueKey;
import java.util.Map;

public interface TargetWidget
{
	int getComponentId();

	default int getArrayId()
	{
		return -1;
	}

	default int getScriptId()
	{
		return -1;
	}

	default Map<ValueKey, SetValue> getPositions()
	{
		return Map.of();
	}
}

/*
 * Copyright (c) 2025, cue <https://github.com/its-cue>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

package com.compactorbs.widget.elements;

import com.compactorbs.CompactOrbsConstants.Layout.Horizontal;
import com.compactorbs.CompactOrbsConstants.Layout.Original;
import com.compactorbs.CompactOrbsConstants.Layout.Vertical;
import com.compactorbs.CompactOrbsConstants.Script;
import com.compactorbs.CompactOrbsConstants.Widgets.Modern;
import com.compactorbs.CompactOrbsConstants.Widgets.Orb;
import com.compactorbs.util.SetValue;
import com.compactorbs.util.ValueKey;
import static com.compactorbs.util.ValueKey.X;
import static com.compactorbs.util.ValueKey.X_POSITION_MODE;
import static com.compactorbs.util.ValueKey.Y;
import static com.compactorbs.util.ValueKey.Y_POSITION_MODE;
import com.compactorbs.widget.TargetWidget;
import java.util.EnumSet;
import java.util.Map;
import java.util.Set;
import lombok.Getter;
import lombok.RequiredArgsConstructor;
import net.runelite.api.widgets.WidgetPositionMode;

@Getter
@RequiredArgsConstructor
public enum Orbs implements TargetWidget
{
	XP_DROPS_CONTAINER(
		Orb.XP_DROPS,
		Map.of(
			X, new SetValue(
				Original.XP_DROPS_X,
				Vertical.XP_DROPS_X,
				Horizontal.XP_DROPS_X
			),
			Y, new SetValue(
				Original.XP_DROPS_Y,
				Vertical.XP_DROPS_Y,
				Horizontal.XP_DROPS_Y
			),
			X_POSITION_MODE, new SetValue(
				WidgetPositionMode.ABSOLUTE_LEFT,
				WidgetPositionMode.ABSOLUTE_RIGHT,
				WidgetPositionMode.ABSOLUTE_LEFT
			)
		)
	),
	HP_ORB_CONTAINER(
		Orb.HP_ORB,
		Map.of(
			X, new SetValue(
				Original.HP_ORB_X,
				Vertical.HP_ORB_X,
				Horizontal.HP_ORB_X
			),
			Y, new SetValue(
				Original.HP_ORB_Y,
				Vertical.HP_ORB_Y,
				Horizontal.HP_ORB_Y
			),
			X_POSITION_MODE, new SetValue(
				WidgetPositionMode.ABSOLUTE_LEFT,
				WidgetPositionMode.ABSOLUTE_RIGHT,
				WidgetPositionMode.ABSOLUTE_LEFT
			)
		)
	),
	PRAYER_ORB_CONTAINER(
		Orb.PRAY_ORB,
		Map.of(
			X, new SetValue(
				Original.PRAYER_ORB_X,
				Vertical.PRAYER_ORB_X,
				Horizontal.PRAYER_ORB_X
			),
			Y, new SetValue(
				Original.PRAYER_ORB_Y,
				Vertical.PRAYER_ORB_Y,
				Horizontal.PRAYER_ORB_Y
			),
			X_POSITION_MODE, new SetValue(
				WidgetPositionMode.ABSOLUTE_LEFT,
				WidgetPositionMode.ABSOLUTE_RIGHT,
				WidgetPositionMode.ABSOLUTE_LEFT
			)
		)
	),
	RUN_ORB_CONTAINER(
		Orb.RUN_ORB,
		Map.of(
			X, new SetValue(
				Original.RUN_ORB_X,
				Vertical.RUN_ORB_X,
				Horizontal.RUN_ORB_X),
			Y, new SetValue(
				Original.RUN_ORB_Y,
				Vertical.RUN_ORB_Y,
				Horizontal.RUN_ORB_Y
			),
			X_POSITION_MODE, new SetValue(
				WidgetPositionMode.ABSOLUTE_LEFT,
				WidgetPositionMode.ABSOLUTE_RIGHT,
				WidgetPositionMode.ABSOLUTE_LEFT
			)
		)
	),
	SPEC_ORB_CONTAINER(
		Orb.SPEC_ORB,
		Map.of(
			X, new SetValue(
				Original.SPEC_ORB_X,
				Vertical.SPEC_ORB_X,
				Horizontal.SPEC_ORB_X
			),
			Y, new SetValue(
				Original.SPEC_ORB_Y,
				Vertical.SPEC_ORB_Y,
				Horizontal.SPEC_ORB_Y
			),
			X_POSITION_MODE, new SetValue(
				WidgetPositionMode.ABSOLUTE_LEFT,
				WidgetPositionMode.ABSOLUTE_RIGHT,
				WidgetPositionMode.ABSOLUTE_LEFT
			)
		)
	),
	STORE_ORB_CONTAINER(
		Orb.STORE_ORB,
		Script.STORE_ORB_UPDATE,
		Map.of(
			X, new SetValue(
				Original.STORE_ORB_X,
				Vertical.STORE_ORB_X,
				Horizontal.STORE_ORB_X
			),
			Y, new SetValue(
				Original.STORE_ORB_Y,
				Vertical.STORE_ORB_Y,
				Horizontal.STORE_ORB_Y
			),
			X_POSITION_MODE, new SetValue(
				WidgetPositionMode.ABSOLUTE_LEFT,
				WidgetPositionMode.ABSOLUTE_RIGHT,
				WidgetPositionMode.ABSOLUTE_LEFT
			)
		)
	),
	ACTIVITY_ORB_CONTAINER(
		Orb.ACTIVITY_ORB,
		Script.ACTIVITY_ORB_UPDATE,
		Map.of(
			X, new SetValue(
				Original.ACTIVITY_ORB_X,
				Vertical.ACTIVITY_ORB_X,
				Horizontal.ACTIVITY_ORB_X
			),
			Y, new SetValue(
				Original.ACTIVITY_ORB_Y,
				Vertical.ACTIVITY_ORB_Y,
				Horizontal.ACTIVITY_ORB_Y
			),
			X_POSITION_MODE, new SetValue(
				WidgetPositionMode.ABSOLUTE_LEFT,
				WidgetPositionMode.ABSOLUTE_RIGHT,
				WidgetPositionMode.ABSOLUTE_LEFT
			)
		)
	),
	WORLD_MAP_CONTAINER(
		Orb.WORLD_MAP,
		Script.WORLD_MAP_UPDATE,
		Map.of(
			X, new SetValue(
				Original.WORLD_MAP_X,
				Vertical.WORLD_MAP_X,
				Horizontal.WORLD_MAP_X
			),
			Y, new SetValue(
				Original.WORLD_MAP_Y,
				Vertical.WORLD_MAP_Y,
				Horizontal.WORLD_MAP_Y
			)
		)
	),
	//wiki plugin banner
	WIKI_ICON_CONTAINER(
		Orb.WIKI_ICON,
		Script.WIKI_ICON_UPDATE,
		Map.of(
			X, new SetValue(
				Original.WIKI_ICON_X,
				Vertical.WIKI_ICON_X,
				Horizontal.WIKI_ICON_X
			),
			Y, new SetValue(
				Original.WIKI_ICON_Y,
				Vertical.WIKI_ICON_Y,
				Horizontal.WIKI_ICON_Y
			),
			X_POSITION_MODE, new SetValue(
				WidgetPositionMode.ABSOLUTE_RIGHT,
				WidgetPositionMode.ABSOLUTE_RIGHT,
				WidgetPositionMode.ABSOLUTE_LEFT
			),
			Y_POSITION_MODE, new SetValue(
				WidgetPositionMode.ABSOLUTE_TOP,
				WidgetPositionMode.ABSOLUTE_TOP
			)
		)
	),
	//vanilla wiki banner
	WIKI_VANILLA(
		Orb.WIKI_ICON_VANILLA,
		Script.WIKI_ICON_UPDATE,
		Map.of(
			X, new SetValue(
				Original.WIKI_VANILLA_X,
				Vertical.WIKI_VANILLA_X,
				Horizontal.WIKI_VANILLA_X
			),
			Y, new SetValue(
				Original.WIKI_VANILLA_Y,
				Vertical.WIKI_VANILLA_Y,
				Horizontal.WIKI_VANILLA_Y
			),
			X_POSITION_MODE, new SetValue(
				WidgetPositionMode.ABSOLUTE_CENTER,
				WidgetPositionMode.ABSOLUTE_RIGHT,
				WidgetPositionMode.ABSOLUTE_LEFT
			),
			Y_POSITION_MODE, new SetValue(
				WidgetPositionMode.ABSOLUTE_CENTER,
				WidgetPositionMode.ABSOLUTE_RIGHT
			)
		)
	),
	LOGOUT_X_ICON(
		Modern.LOGOUT_X_ICON,
		Map.of(
			X, new SetValue(
				Original.LOGOUT_X,
				Vertical.LOGOUT_X,
				Horizontal.LOGOUT_X
			),
			Y, new SetValue(
				Original.LOGOUT_Y,
				Vertical.LOGOUT_Y,
				Horizontal.LOGOUT_Y
			)
		)
	),
	LOGOUT_X_STONE(
		Modern.LOGOUT_X_STONE,
		Map.of(
			X, new SetValue(
				Original.LOGOUT_X,
				Vertical.LOGOUT_X,
				Horizontal.LOGOUT_X
			),
			Y, new SetValue(
				Original.LOGOUT_Y,
				Vertical.LOGOUT_Y,
				Horizontal.LOGOUT_Y
			)
		)
	),
	GRID_MASTER_ORB_CONTAINER(
		Orb.UNIVERSE, 0,
		Script.GRID_MASTER_ORB_UPDATE,
		Map.of(
			X, new SetValue(
				Original.ACTIVITY_ORB_X,
				Vertical.ACTIVITY_ORB_X,
				Horizontal.ACTIVITY_ORB_X
			),
			Y, new SetValue(
				Original.ACTIVITY_ORB_Y,
				Vertical.ACTIVITY_ORB_Y,
				Horizontal.ACTIVITY_ORB_Y
			),
			X_POSITION_MODE, new SetValue(
				WidgetPositionMode.ABSOLUTE_LEFT,
				WidgetPositionMode.ABSOLUTE_RIGHT,
				WidgetPositionMode.ABSOLUTE_LEFT
			)
		)
	);

	private final int componentId, arrayId, scriptId;

	private final Map<ValueKey, SetValue> positions;

	Orbs(int componentId, int scriptId, Map<ValueKey, SetValue> positions)
	{
		this.componentId = componentId;
		this.arrayId = -1;
		this.scriptId = scriptId;
		this.positions = positions;
	}

	Orbs(int componentId, Map<ValueKey, SetValue> positions)
	{
		this.componentId = componentId;
		this.arrayId = -1;
		this.scriptId = -1;
		this.positions = positions;
	}

	//only includes widgets that require updating
	public static final Set<Orbs> FIXED = EnumSet.of(
		HP_ORB_CONTAINER,
		PRAYER_ORB_CONTAINER,
		RUN_ORB_CONTAINER,
		SPEC_ORB_CONTAINER,
		XP_DROPS_CONTAINER
	);

	public static final Set<Orbs> ALL = EnumSet.allOf(Orbs.class);

}

/*
 * Copyright (c) 2025, cue <https://github.com/its-cue>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

package com.compactorbs.widget.elements;

import com.compactorbs.CompactOrbsConstants.Layout;
import com.compactorbs.CompactOrbsConstants.Layout.Original;
import com.compactorbs.CompactOrbsConstants.Layout.Vertical;
import com.compactorbs.CompactOrbsConstants.Layout.Horizontal;
import com.compactorbs.CompactOrbsConstants.Widgets.Classic;
import com.compactorbs.CompactOrbsConstants.Widgets.Modern;
import com.compactorbs.util.SetValue;
import com.compactorbs.util.ValueKey;
import static com.compactorbs.util.ValueKey.X;
import static com.compactorbs.util.ValueKey.Y;
import com.compactorbs.widget.TargetWidget;
import java.util.EnumSet;
import java.util.Map;
import java.util.Set;
import lombok.Getter;
import lombok.RequiredArgsConstructor;

@Getter
@RequiredArgsConstructor
public enum Compass implements TargetWidget
{
	CLASSIC_COMPASS(
		Classic.COMPASS,
		Map.of(
			X, new SetValue(
				Original.COMPASS_X,
				Vertical.COMPASS_X,
				Horizontal.COMPASS_X
			),
			Y, new SetValue(
				Original.COMPASS_Y,
				Vertical.COMPASS_Y,
				Horizontal.COMPASS_Y
			)
		)
	),
	CLASSIC_COMPASS_OPTIONS(
		Classic.COMPASS_OPTIONS,
		Map.of(
			X, new SetValue(
				Original.COMPASS_X - Layout.COMPASS_OPTIONS_OFFSET,
				Vertical.COMPASS_X - Layout.COMPASS_OPTIONS_OFFSET,
				Horizontal.COMPASS_X - Layout.COMPASS_OPTIONS_OFFSET
			),
			Y, new SetValue(
				Original.COMPASS_Y - Layout.COMPASS_OPTIONS_OFFSET,
				Vertical.COMPASS_Y - Layout.COMPASS_OPTIONS_OFFSET,
				Horizontal.COMPASS_Y - Layout.COMPASS_OPTIONS_OFFSET
			)
		)
	),

	MODERN_COMPASS(
		Modern.COMPASS,
		Map.of(
			X, new SetValue(
				Original.COMPASS_X,
				Vertical.COMPASS_X,
				Horizontal.COMPASS_X
			),
			Y, new SetValue(
				Original.COMPASS_Y,
				Vertical.COMPASS_Y,
				Horizontal.COMPASS_Y
			)
		)
	),
	MODERN_COMPASS_OPTIONS(
		Modern.COMPASS_OPTIONS,
		Map.of(
			X, new SetValue(
				Original.COMPASS_X - Layout.COMPASS_OPTIONS_OFFSET,
				Vertical.COMPASS_X - Layout.COMPASS_OPTIONS_OFFSET,
				Horizontal.COMPASS_X - Layout.COMPASS_OPTIONS_OFFSET
			),
			Y, new SetValue(
				Original.COMPASS_Y - Layout.COMPASS_OPTIONS_OFFSET,
				Vertical.COMPASS_Y - Layout.COMPASS_OPTIONS_OFFSET,
				Horizontal.COMPASS_Y - Layout.COMPASS_OPTIONS_OFFSET
			)
		)
	);

	private final int componentId;

	private final Map<ValueKey, SetValue> positions;

	public static final Set<Compass> ALL = EnumSet.allOf(Compass.class);

}

/*
 * Copyright (c) 2025, cue <https://github.com/its-cue>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

package com.compactorbs.widget.elements;

import com.compactorbs.CompactOrbsConstants.Widgets.Classic;
import com.compactorbs.CompactOrbsConstants.Widgets.Modern;
import com.compactorbs.widget.TargetWidget;
import lombok.Getter;
import lombok.RequiredArgsConstructor;

@Getter
@RequiredArgsConstructor
public enum Minimap implements TargetWidget
{
	//classic-resizable
	CLASSIC_NO_CLICK_0(Classic.MAP_NOCLICK_0),
	CLASSIC_NO_CLICK_1(Classic.MAP_NOCLICK_1),
	CLASSIC_NO_CLICK_2(Classic.MAP_NOCLICK_2),
	CLASSIC_NO_CLICK_3(Classic.MAP_NOCLICK_3),
	CLASSIC_NO_CLICK_4(Classic.MAP_NOCLICK_4),
	CLASSIC_NO_CLICK_5(Classic.MAP_NOCLICK_5),
	CLASSIC_MINIMAP_MASK(Classic.MINIMAP_MASK),
	CLASSIC_MINIMAP(Classic.MINIMAP),

	//modern-resizable
	MODERN_NO_CLICK_0(Modern.MAP_NOCLICK_0),
	MODERN_NO_CLICK_1(Modern.MAP_NOCLICK_1),
	MODERN_NO_CLICK_2(Modern.MAP_NOCLICK_2),
	MODERN_NO_CLICK_3(Modern.MAP_NOCLICK_3),
	MODERN_NO_CLICK_4(Modern.MAP_NOCLICK_4),
	MODERN_NO_CLICK_5(Modern.MAP_NOCLICK_5),
	MODERN_MINIMAP_MASK(Modern.MINIMAP_MASK),
	MODERN_MINIMAP(Modern.MINIMAP);

	private final int componentId;

}

package com.compactorbs;

import net.runelite.client.RuneLite;
import net.runelite.client.externalplugins.ExternalPluginManager;

public class CompactOrbsPluginTest
{
	public static void main(String[] args) throws Exception
	{
		ExternalPluginManager.loadBuiltin(CompactOrbsPlugin.class);
		RuneLite.main(args);
	}
}
