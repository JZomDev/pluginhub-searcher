/*
 * Copyright (c) 2025, cue <https://github.com/its-cue>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

package com.compactorbs;

import static com.compactorbs.CompactOrbsConstants.ConfigGroup.GROUP_NAME;
import com.compactorbs.CompactOrbsConstants.ConfigKeys;
import com.compactorbs.CompactOrbsConstants.Layout;
import java.awt.event.KeyEvent;
import lombok.Getter;
import lombok.RequiredArgsConstructor;
import net.runelite.client.config.Config;
import net.runelite.client.config.ConfigGroup;
import net.runelite.client.config.ConfigItem;
import net.runelite.client.config.ConfigSection;
import net.runelite.client.config.Keybind;

@ConfigGroup(GROUP_NAME)
public interface CompactOrbsConfig extends Config
{
	@Getter
	@RequiredArgsConstructor
	enum OrbLayout
	{
		VERTICAL(0),
		HORIZONTAL(1);

		private final int index;
	}

	enum VerticalPosition
	{
		LEFT, RIGHT
	}

	enum HorizontalPosition
	{
		TOP, BOTTOM
	}

	//limit which slots can be swapped
	@RequiredArgsConstructor
	enum FilteredOrb
	{
		//must match Orbs enum naming,
		//ex: Orbs.HP_ORB_CONTAINER == FilteredOrb.HP_ORB_CONTAINER
		HP_ORB_CONTAINER("Hp"),
		PRAYER_ORB_CONTAINER("Prayer"),
		RUN_ORB_CONTAINER("Run"),
		SPEC_ORB_CONTAINER("Special");

		private final String name;

		@Override
		public String toString()
		{
			return name;
		}
	}

	@Getter
	@RequiredArgsConstructor
	enum TogglePlacement
	{
		DEFAULT(Layout.DEFAULT_MINIMAP_BUTTON_X, Layout.DEFAULT_MINIMAP_BUTTON_Y),
		ABOVE_XP(Layout.ABOVE_XP_MINIMAP_BUTTON_X, Layout.ABOVE_XP_MINIMAP_BUTTON_Y),
		BELOW_MAP(Layout.BELOW_MAP_MINIMAP_BUTTON_X, Layout.BELOW_MAP_MINIMAP_BUTTON_Y),
		BELOW_X(Layout.BELOW_X_MINIMAP_BUTTON_x, Layout.BELOW_X_MINIMAP_BUTTON_Y);

		private final int x;
		private final int y;
	}

	@ConfigItem(
		keyName = ConfigKeys.MINIMAP,
		name = "Hide minimap",
		description = "Enable the ability to collapse the minimap to reposition the orbs",
		hidden = true
	)
	default boolean hideMinimap()
	{
		return false;
	}

	@ConfigItem(
		keyName = ConfigKeys.COMPASS,
		name = "Hide compass",
		description = "Enable the ability to hide the compass, only when the minimap is hidden",
		hidden = true
	)
	default boolean hideCompass()
	{
		return false;
	}

	@ConfigSection(
		name = "Layout",
		description = "Options for modifying the layouts and toggle buttons",
		position = 0
	)
	String compact = "compact";

	@ConfigItem(
		keyName = ConfigKeys.MINIMAP_BUTTON_PLACEMENT,
		name = "Toggle location",
		description = "Change the location of the minimap toggle button when the minimap is visible <br>" +
			"DEFAULT: bottom right, below the minimap <br>" +
			"ABOVE_XP: above the XP drops orb <br>" +
			"BELOW_MAP: centered below the minimap, next to the Store orb <br>" +
			"BELOW_X: right below where the Logout X would be"
		,
		section = compact,
		position = 1
	)
	default TogglePlacement minimapTogglePlacement()
	{
		return TogglePlacement.DEFAULT;
	}

	@ConfigItem(
		keyName = ConfigKeys.MINIMAP_TOGGLE_BUTTON,
		name = "Hide minimap button",
		description = "Toggle the visibility of the toggle button for the minimap",
		section = compact,
		position = 2
	)
	default boolean hideMinimapToggle()
	{
		return false;
	}

	@ConfigItem(
		keyName = ConfigKeys.COMPASS_TOGGLE_BUTTON,
		name = "Hide compass button",
		description = "Toggle the visibility of the toggle button for the compass",
		section = compact,
		position = 3
	)
	default boolean hideCompassToggle()
	{
		return false;
	}

	@ConfigItem(
		keyName = ConfigKeys.ORB_LAYOUT,
		name = "Layout",
		description = "Switch between a compact vertical or horizontal layout",
		section = compact,
		position = 4
	)
	default OrbLayout layout()
	{
		return OrbLayout.VERTICAL;
	}

	@ConfigItem(
		keyName = ConfigKeys.HORIZONTAL,
		name = "Horizontal direction",
		description = "Shift orbs from top-down, or bottom-up <br>"
			+ "Also dictates layouts position in the minimap container",
		section = compact,
		position = 5
	)
	default HorizontalPosition horizontalPosition()
	{
		return HorizontalPosition.BOTTOM;
	}

	//change to account for alignment, not position
	@ConfigItem(
		keyName = ConfigKeys.VERTICAL,
		name = "Vertical direction",
		description = "Shift orbs from left, or right <br>"
			+ "Also dictates layouts position in the minimap container",
		section = compact,
		position = 6
	)
	default VerticalPosition verticalPosition()
	{
		return VerticalPosition.RIGHT;
	}

	@ConfigItem(
		keyName = ConfigKeys.DISABLE_REORDERING,
		name = "Disable orb reordering",
		description = "Prevents the automatic reordering of visible orbs filling gaps left by hidden orbs <br>"
			+ "Vertical-LEFT: will reorder orbs from right to left <br>"
			+ "Vertical-RIGHT: will reorder orbs from left to right <br>"
			+ "Horizontal-TOP: will reorder orbs from top to bottom <br>"
			+ "Horizontal-BOTTOM: will reorder orbs from bottom to top <br>",
		section = compact,
		position = 7
	)
	default boolean disableReordering()
	{
		return false;
	}

	@ConfigItem(
		keyName = ConfigKeys.LEAVE_EMPTY_SPACE,
		name = "Leave empty space",
		description = "Preserves the empty space between reordered orbs, and non-reordered UI elements, for a `floating` effect",
		section = compact,
		position = 8
	)
	default boolean leaveEmptySpace()
	{
		return false;
	}

	@ConfigSection(
		name = "Hotkey",
		description = "Hotkey settings",
		closedByDefault = true,
		position = 1
	)
	String hotkey = "hotkey";

	@ConfigItem(
		keyName = ConfigKeys.HOTKEY_TOGGLE,
		name = "Hotkey",
		description = "Configurable hotkey that hides/shows the toggle-button eyes, or the minimap (with `Toggle minimap via Hotkey` enabled) <br>"
			+ "default: shift + insert",
		section = hotkey,
		position = 0
	)
	default Keybind toggleButtonHotkey()
	{
		return new Keybind(KeyEvent.VK_INSERT, KeyEvent.SHIFT_DOWN_MASK);
	}

	@ConfigItem(
		keyName = ConfigKeys.HOTKEY_MINIMAP,
		name = "Toggle minimap via Hotkey",
		description = "Repurpose the Hotkey to toggle the visibility of the minimap, without the use of the toggle button",
		section = hotkey,
		position = 1
	)
	default boolean minimapHotkey()
	{
		return false;
	}

	@ConfigSection(
		name = "Orb Swapping",
		description = "Options to swap orbs around",
		closedByDefault = true,
		position = 2
	)
	String swapping = "swapping";

	@ConfigItem(
		keyName = ConfigKeys.ENABLE_ORB_SWAPPING,
		name = "Enable orb swapping",
		description = "Allow orb swapping via slot configuration",
		section = swapping,
		position = 0
	)
	default boolean enableOrbSwapping()
	{
		return false;
	}

	@ConfigItem(
		keyName = "",
		name = "Compact slots:",
		description = "Slot order when in compact-view <br>" +
			"Note: each slot must contain a unique orb (otherwise slots will reset to defaults)",
		section = swapping,
		position = 1
	)
	default void compactHeader()
	{
	}

	@ConfigItem(
		keyName = ConfigKeys.HP_ORB_SLOT,
		name = "  HP",
		description = "Select an orb to be in this slot",
		section = swapping,
		position = 2
	)
	default FilteredOrb orbInHPSlot()
	{
		return FilteredOrb.HP_ORB_CONTAINER;
	}

	@ConfigItem(
		keyName = ConfigKeys.PRAYER_ORB_SLOT,
		name = "  Prayer",
		description = "Select an orb to be in this slot",
		section = swapping,
		position = 3
	)
	default FilteredOrb orbInPrayerSlot()
	{
		return FilteredOrb.PRAYER_ORB_CONTAINER;
	}

	@ConfigItem(
		keyName = ConfigKeys.RUN_ORB_SLOT,
		name = "  Run",
		description = "Select an orb to be in this slot",
		section = swapping,
		position = 4
	)
	default FilteredOrb orbInRunSlot()
	{
		return FilteredOrb.RUN_ORB_CONTAINER;
	}

	@ConfigItem(
		keyName = ConfigKeys.SPECIAL_ORB_SLOT,
		name = "  Special",
		description = "Select an orb to be in this slot",
		section = swapping,
		position = 5
	)
	default FilteredOrb orbInSpecialSlot()
	{
		return FilteredOrb.SPEC_ORB_CONTAINER;
	}

	@ConfigItem(
		keyName = "",
		name = "\u200B",
		description = "",
		section = swapping,
		position = 6
	)
	default void slotDivider()
	{
	}

	@ConfigItem(
		keyName = "",
		name = "Vanilla slots:",
		description = "Slot order when not in compact-view <br>" +
			"Note: each slot must contain a unique orb (otherwise slots will reset to defaults)",
		section = swapping,
		position = 7
	)
	default void vanillaHeader()
	{
	}

	@ConfigItem(
		keyName = ConfigKeys.HP_ORB_SLOT_VANILLA,
		name = "  HP",
		description = "Select an orb to be in this slot",
		section = swapping,
		position = 8
	)
	default FilteredOrb orbInHpSlotVanilla()
	{
		return FilteredOrb.HP_ORB_CONTAINER;
	}

	@ConfigItem(
		keyName = ConfigKeys.PRAYER_ORB_SLOT_VANILLA,
		name = "  Prayer",
		description = "Select an orb to be in this slot",
		section = swapping,
		position = 9
	)
	default FilteredOrb orbInPrayerSlotVanilla()
	{
		return FilteredOrb.PRAYER_ORB_CONTAINER;
	}

	@ConfigItem(
		keyName = ConfigKeys.RUN_ORB_SLOT_VANILLA,
		name = "  Run",
		description = "Select an orb to be in this slot",
		section = swapping,
		position = 10
	)
	default FilteredOrb orbInRunSlotVanilla()
	{
		return FilteredOrb.RUN_ORB_CONTAINER;
	}

	@ConfigItem(
		keyName = ConfigKeys.SPECIAL_ORB_SLOT_VANILLA,
		name = "  Special",
		description = "Select an orb to be in this slot",
		section = swapping,
		position = 11
	)
	default FilteredOrb orbInSpecialSlotVanilla()
	{
		return FilteredOrb.SPEC_ORB_CONTAINER;
	}

	@ConfigSection(
		name = "Orb Visibility",
		description = "Options to hide or show orbs",
		closedByDefault = true,
		position = 3
	)
	String visibility = "visibility";

	@ConfigItem(
		keyName = ConfigKeys.HIDE_HP,
		name = "Hide Hp",
		description = "Toggle visibility of the HP orb",
		section = visibility,
		position = 0
	)
	default boolean hideHp()
	{
		return false;
	}

	@ConfigItem(
		keyName = ConfigKeys.HIDE_PRAYER,
		name = "Hide Prayer",
		description = "Toggle visibility of the Prayer orb",
		section = visibility,
		position = 1
	)
	default boolean hidePray()
	{
		return false;
	}

	@ConfigItem(
		keyName = ConfigKeys.HIDE_RUN,
		name = "Hide Run",
		description = "Toggle visibility of the Run energy orb",
		section = visibility,
		position = 2
	)
	default boolean hideRun()
	{
		return false;
	}

	@ConfigItem(
		keyName = ConfigKeys.HIDE_SPEC,
		name = "Hide Special",
		description = "Toggle visibility of the Special attack energy orb",
		section = visibility,
		position = 3
	)
	default boolean hideSpec()
	{
		return false;
	}

	@ConfigItem(
		keyName = ConfigKeys.HIDE_XP,
		name = "Hide XP",
		description = "Toggle visibility of the XP drops orb",
		section = visibility,
		position = 4
	)
	default boolean hideXp()
	{
		return false;
	}

	@ConfigItem(
		keyName = ConfigKeys.HIDE_WORLD,
		name = "Hide World Map",
		description = "Toggle the visibility of the World Map <br>"
			+ " Will retain hotkey functionality 'Ctrl + M', if in-game setting is enabled",
		section = visibility,
		position = 5
	)
	default boolean hideWorld()
	{
		return false;
	}

	@ConfigItem(
		keyName = ConfigKeys.HIDE_STORE,
		name = "Hide Store",
		description = "Toggle the visibility of the Store orb <br>"
			+ "In-game setting must be be enabled",
		section = visibility,
		position = 6
	)
	default boolean hideStore()
	{
		return false;
	}

	@ConfigItem(
		keyName = ConfigKeys.HIDE_ACTIVITY,
		name = "Hide Activity Advisor",
		description = "Toggle the visibility of the Activity Advisor orb <br>"
			+ "In-game setting must be be enabled",
		section = visibility,
		position = 7
	)
	default boolean hideActivity()
	{
		return false;
	}

	@ConfigItem(
		keyName = ConfigKeys.HIDE_WIKI,
		name = "Hide Wiki banner",
		description = "Toggle the visibility of the Wiki banner <br>"
			+ "In-game setting must be be enabled",
		section = visibility,
		position = 8
	)
	default boolean hideWiki()
	{
		return false;
	}

	@ConfigItem(
		keyName = ConfigKeys.HIDE_LOGOUT_X,
		name = "Hide Logout X",
		description = "Toggle the visibility of the Logout-X when in resizable-modern display mode",
		section = visibility,
		position = 9
	)
	default boolean hideLogout()
	{
		return false;
	}

	@ConfigItem(
		keyName = ConfigKeys.HIDE_GRID,
		name = "Hide Grid Master",
		description = "Toggle the visibility of the Grid Master orb (temporary game-mode)",
		section = visibility,
		position = 10
	)
	default boolean hideGrid()
	{
		return false;
	}

	@ConfigSection(
		name = "Misc.",
		description = "Experimental",
		closedByDefault = true,
		position = 99
	)
	String misc = "misc";

	@ConfigItem(
		keyName = ConfigKeys.ENABLE_MINIMAP_OVERLAY,
		name = "Show minimap in compact view",
		description = "Show a separate minimap overlay, only during compact view <br>" +
			"NOTE: overlay functions identically to the Vanilla minimap (will NOT show overlays, marked tiles, names, etc.)",
		section = misc,
		position = 0
	)
	default boolean showMinimapInCompactView()
	{
		return false;
	}
}

/*
 * Copyright (c) 2025, cue <https://github.com/its-cue>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

package com.compactorbs;

import java.awt.Color;
import java.util.Set;
import net.runelite.api.ScriptID;
import net.runelite.api.gameval.InterfaceID;
import net.runelite.api.gameval.SpriteID;
import net.runelite.api.gameval.VarbitID;
import net.runelite.client.ui.JagexColors;

public class CompactOrbsConstants
{
	public static final class ConfigGroup
	{
		public static final String GROUP_NAME = "compactorbs";

		public static final class Wiki
		{
			public static final String GROUP_NAME = "wiki";
		}

		public static final class RuneLite
		{
			public static final String GROUP_NAME = "runelite";
		}
	}

	public static final class ConfigKeys
	{
		public static final String MINIMAP = "hideMinimap";
		public static final String COMPASS = "hideCompass";
		public static final String HOTKEY_TOGGLE = "hotkeyToggle";
		public static final String HOTKEY_MINIMAP = "hotkeyMinimap";
		public static final String MINIMAP_TOGGLE_BUTTON = "hideMinimapButton";
		public static final String COMPASS_TOGGLE_BUTTON = "hideCompassButton";
		public static final String MINIMAP_BUTTON_PLACEMENT = "minimapButtonPlacement";
		public static final String ORB_LAYOUT = "orbLayout";
		public static final String HORIZONTAL = "horizontalPosition";
		public static final String VERTICAL = "verticalPosition";
		public static final String DISABLE_REORDERING = "disableReordering";
		public static final String LEAVE_EMPTY_SPACE = "leaveEmptySpace";
		public static final String ENABLE_ORB_SWAPPING = "enableOrbSwapping";
		public static final String HP_ORB_SLOT = "hpOrbSlot";
		public static final String PRAYER_ORB_SLOT = "prayerOrbSlot";
		public static final String RUN_ORB_SLOT = "runOrbSlot";
		public static final String SPECIAL_ORB_SLOT = "specialOrbSlot";
		public static final String HP_ORB_SLOT_VANILLA = "hpOrbSlotVanilla";
		public static final String PRAYER_ORB_SLOT_VANILLA = "prayerOrbSlotVanilla";
		public static final String RUN_ORB_SLOT_VANILLA = "runOrbSlotVanilla";
		public static final String SPECIAL_ORB_SLOT_VANILLA = "specialOrbSlotVanilla";
		public static final String HIDE_HP = "hideHp";
		public static final String HIDE_PRAYER = "hidePrayer";
		public static final String HIDE_RUN = "hideRun";
		public static final String HIDE_SPEC = "hideSpec";
		public static final String HIDE_XP = "hideXp";
		public static final String HIDE_WORLD = "hideWorld";
		public static final String HIDE_ACTIVITY = "hideActivity";
		public static final String HIDE_STORE = "hideStore";
		public static final String HIDE_WIKI = "hideWiki";
		public static final String HIDE_LOGOUT_X = "hideLogoutX";
		public static final String HIDE_GRID = "hideGrid";
		public static final String ENABLE_MINIMAP_OVERLAY = "enableMinimapOverlay";

		public static final class Wiki
		{
			public static final String SHOW_WIKI_MINIMAP_BUTTON = "showWikiMinimapButton";
		}

		public static final class RuneLite
		{
			public static final String WIKI_PLUGIN = "wikiplugin";
		}
	}

	public static final class Varbit
	{
		public static final int MINIMAP_TOGGLE = VarbitID.MINIMAP_TOGGLE;
		public static final int ACTIVITY_ORB_TOGGLE = VarbitID.OPTION_CONTENT_RECOMMENDER_HIDE;
		public static final int STORE_ORB_TOGGLE = VarbitID.TLI_STOREBUTTON_TOGGLE_DESKTOP;
		public static final int CUTSCENE_STATUS = VarbitID.CUTSCENE_STATUS;
	}

	public static final class VarbitValue
	{
		// 1 (is minimized), 0 (not minimized)
		public static final int MINIMAP_MINIMIZED = 1;

		// 0 (is visible), 1 (not visible)
		public static final int ACTIVITY_ORB_VISIBLE = 0;

		// 1 (is visible), 0 (not visible)
		public static final int STORE_ORB_VISIBLE = 1;

		// 1 (active), 0 (inactive)
		public static final int CUTSCENE_ACTIVE = 1;
	}

	public static final class Script
	{
		//custom flag, used to trigger remapping without scriptId matching
		public static final int FORCE_UPDATE = -1;

		//logout X redraw when opening tabs/using hotkey
		public static final int TOP_LEVEL_REDRAW = ScriptID.TOPLEVEL_REDRAW;
		public static final int TOP_LEVEL_SIDE_CUSTOMIZE = 919;

		//buff bar widget, used for the minimap overlay
		public static final int BUFF_BAR_CONTENT_UPDATE = 4730;

		//relevant update scripts for the target orbs
		public static final int WORLD_MAP_UPDATE = 1700;
		public static final int STORE_ORB_UPDATE = 2396;
		public static final int ACTIVITY_ORB_UPDATE = 2480;
		public static final int WIKI_ICON_UPDATE = ScriptID.WIKI_ICON_UPDATE;
		public static final int GRID_MASTER_ORB_UPDATE = 8222;

		public static final Set<Integer> MINIMAP_UPDATE_SCRIPTS =
			Set.of(
				//orbs
				WORLD_MAP_UPDATE,
				STORE_ORB_UPDATE,
				ACTIVITY_ORB_UPDATE,
				WIKI_ICON_UPDATE,
				GRID_MASTER_ORB_UPDATE
			);
	}

	/* Layout positions, dimensions, and other style changes */
	public static final class Layout
	{
		/* Original positions for orb/compass widgets */
		public static final class Original
		{
			public static final int XP_DROPS_X = 0;
			public static final int XP_DROPS_Y = 17;

			public static final int HP_ORB_X = 0;
			public static final int HP_ORB_Y = 37;

			public static final int PRAYER_ORB_X = 0;
			public static final int PRAYER_ORB_Y = 71;

			public static final int RUN_ORB_X = 10;
			public static final int RUN_ORB_Y = 103;

			public static final int SPEC_ORB_X = 32;
			public static final int SPEC_ORB_Y = 128;

			public static final int STORE_ORB_X = 85;
			public static final int STORE_ORB_Y = 143;

			public static final int ACTIVITY_ORB_X = 55;
			public static final int ACTIVITY_ORB_Y = 162;

			public static final int WORLD_MAP_X = 0;
			public static final int WORLD_MAP_Y = 115;

			public static final int WIKI_ICON_X = 0;
			public static final int WIKI_ICON_Y = 135;

			public static final int WIKI_VANILLA_X = 0;
			public static final int WIKI_VANILLA_Y = 0;

			public static final int LOGOUT_X = 2;
			public static final int LOGOUT_Y = 2;

			public static final int COMPASS_X = 34;
			public static final int COMPASS_Y = 5;
			public static final int COMPASS_DIMENSION = 35;

			public static final int MINIMAP_X = 6;
			public static final int MINIMAP_Y = 8;
			public static final int MINIMAP_DIMENSION = 152;
		}

		/* Vertical positions for orb/compass widgets */
		public static final class Vertical
		{
			public static final int XP_DROPS_X = 68;
			public static final int XP_DROPS_Y = 44;

			public static final int HP_ORB_X = 0;
			public static final int HP_ORB_Y = 41;

			public static final int PRAYER_ORB_X = 0;
			public static final int PRAYER_ORB_Y = 76;

			public static final int RUN_ORB_X = 0;
			public static final int RUN_ORB_Y = 111;

			public static final int SPEC_ORB_X = 0;
			public static final int SPEC_ORB_Y = 146;

			public static final int STORE_ORB_X = 64;
			public static final int STORE_ORB_Y = 103;

			public static final int ACTIVITY_ORB_X = 64;
			public static final int ACTIVITY_ORB_Y = 138;

			public static final int WORLD_MAP_X = 66;
			public static final int WORLD_MAP_Y = 72;

			public static final int WIKI_ICON_X = 20;
			public static final int WIKI_ICON_Y = 171;

			public static final int WIKI_VANILLA_X = 0;
			public static final int WIKI_VANILLA_Y = 10;

			public static final int LOGOUT_X = 8;
			public static final int LOGOUT_Y = 22;

			public static final int COMPASS_X = Original.COMPASS_X + 94;
			public static final int COMPASS_Y = Original.COMPASS_Y + 13;

			//vertical offset
			public static final int LEFT_OFFSET = 108;
			public static final int RIGHT_OFFSET = 0;
		}

		/* Horizontal positions for orb/compass widgets */
		public static final class Horizontal
		{
			public static final int XP_DROPS_X = 179;
			public static final int XP_DROPS_Y = 15;

			public static final int HP_ORB_X = 35;
			public static final int HP_ORB_Y = 25;

			public static final int PRAYER_ORB_X = 35;
			public static final int PRAYER_ORB_Y = 60;

			public static final int RUN_ORB_X = 92;
			public static final int RUN_ORB_Y = 25;

			public static final int SPEC_ORB_X = 92;
			public static final int SPEC_ORB_Y = 60;

			public static final int STORE_ORB_X = 0;
			public static final int STORE_ORB_Y = 25;

			public static final int ACTIVITY_ORB_X = 0;
			public static final int ACTIVITY_ORB_Y = 60;

			public static final int WORLD_MAP_X = 31;//148
			public static final int WORLD_MAP_Y = 6;

			public static final int WIKI_ICON_X = 149;
			public static final int WIKI_ICON_Y = 71;

			public static final int WIKI_VANILLA_X = 0;
			public static final int WIKI_VANILLA_Y = 10;

			public static final int LOGOUT_X = 1;
			public static final int LOGOUT_Y = 1;

			public static final int COMPASS_X = Original.COMPASS_X + 117;
			public static final int COMPASS_Y = Original.COMPASS_Y + 47;

			//horizontal offset
			public static final int TOP_OFFSET = 0;
			public static final int BOTTOM_OFFSET = 100;
		}

		public static final class MinimapOverlay
		{
			public static final int CONTAINER_WIDTH = 182;
			public static final int CONTAINER_HEIGHT = 166;

			//difference between original width, and clone width
			public static final int WIDTH_DIFF = 29;

			public static final int NO_CLICK_X = 0;
			public static final int[] NO_CLICK_Y =
				{
					4, 44, 100, 125, 140, 155
				};

			public static final int[] NO_CLICK_WIDTH =
				{
					178, 166, 161, 151, 141, 121
				};

			public static final int[] NO_CLICK_HEIGHT =
				{
					40, 56, 25, 15, 15, 11
				};

			public static final int MINIMAP_CONTENT = 1338;
			public static final int COMPASS_CONTENT = 1339;
		}

		//world map x and y when in fixed mode
		public static final int FIXED_WORLD_MAP_X = 10;
		public static final int FIXED_WORLD_MAP_Y = 115;

		//used when hiding the world map orb, to calc the offset so the hotkey still works
		public static final int WORLD_MAP_CONTAINER_WIDTH = 30;

		//compass menu op offset
		public static final int COMPASS_OPTIONS_OFFSET = 2;

		//offsets used to anchor the frame around the compass
		public static final int FRAME_X_OFFSET = 2;
		public static final int FRAME_Y_OFFSET = 12;

		//offsets used to anchor the toggle button around the compass sprite
		public static final int COMPASS_BUTTON_X_OFFSET = 31;
		public static final int COMPASS_BUTTON_Y_OFFSET = 14;

		//offsets used in horizontal layout, to position the compass button
		public static final int COMPASS_BUTTON_HORIZONTAL_X_OFFSET = 4;
		public static final int COMPASS_BUTTON_HORIZONTAL_Y_OFFSET = 22;

		//minimap toggle button locations @ToggleLocation
		public static final int DEFAULT_MINIMAP_BUTTON_X = 190;
		public static final int DEFAULT_MINIMAP_BUTTON_Y = 180;

		public static final int ABOVE_XP_MINIMAP_BUTTON_X = 8;
		public static final int ABOVE_XP_MINIMAP_BUTTON_Y = 0;

		public static final int BELOW_MAP_MINIMAP_BUTTON_X = 120;
		public static final int BELOW_MAP_MINIMAP_BUTTON_Y = 155;

		public static final int BELOW_X_MINIMAP_BUTTON_x = DEFAULT_MINIMAP_BUTTON_X;
		public static final int BELOW_X_MINIMAP_BUTTON_Y = 15;

		//toggle button dimensions
		public static final int TOGGLE_BUTTON_WIDTH = 17;
		public static final int TOGGLE_BUTTON_HEIGHT = 17;

		//compass frame dimensions
		public static final int FRAME_WIDTH = 43;
		public static final int FRAME_HEIGHT = 43;

		//toggle button opacity when onMouseOver || onMouseLeave
		public static final int OPACITY = 0;
		public static final int OPACITY_HOVER = 130;
	}

	public static final class Menu
	{
		//prefix menu options for the toggle buttons
		public static final String PREFIX_SHOW = "Show";
		public static final String PREFIX_HIDE = "Hide";

		//suffix menu options for the toggle buttons
		public static final String SUFFIX_MINIMAP = "Minimap";
		public static final String SUFFIX_COMPASS = "Compass";

		//suffix menu color for the toggle buttons
		public static final Color COLOR = JagexColors.MENU_TARGET;
	}

	public static final class Sprite
	{
		//minimap clone sprites
		public static final int COMPASS_MASK = SpriteID.RESIZE_COMPASS_MASK;
		public static final int MINIMAP_MASK = SpriteID.RESIZE_MAP_MASK;
		public static final int MINIMAP_FRAME = SpriteID.OSRS_STRETCH_MAPSURROUND;

		//border frame for the compass when the minimap is hidden
		public static final int COMPASS_FRAME = SpriteID.COMPASS_OUTLINE;

		//toggle button sprites
		public static final int HIDDEN = SpriteID.GroundItemsVisibility._1;
		public static final int VISIBLE = SpriteID.GroundItemsVisibility._0;

		//widget inspector sprite
		public static final int WIDGET_INSPECTOR = SpriteID.OptionsIcons._50;
	}

	public static final class Widgets
	{
		public static final class MinimapOverlay
		{
			//unused widget layer (official client only?) BuffBar (651.0)
			public static final int UNIVERSE = InterfaceID.BuffBar.UNIVERSE;
		}

		public static final class Orb
		{
			//orbs container interface
			public static final int UNIVERSE = InterfaceID.Orbs.UNIVERSE;

			//orb containers
			public static final int XP_DROPS = InterfaceID.Orbs.XP_DROPS;
			public static final int HP_ORB = InterfaceID.Orbs.ORB_HEALTH;
			public static final int PRAY_ORB = InterfaceID.Orbs.ORB_PRAYER;
			public static final int RUN_ORB = InterfaceID.Orbs.ORB_RUNENERGY;
			public static final int SPEC_ORB = InterfaceID.Orbs.ORB_SPECENERGY;
			public static final int ACTIVITY_ORB = InterfaceID.Orbs.ORB_CONTENTRECOM;
			public static final int STORE_ORB = InterfaceID.Orbs.ORB_STORE;
			public static final int WIKI_ICON = InterfaceID.Orbs.WIKI;
			public static final int WIKI_CONTAINER_VANILLA = InterfaceID.Orbs.WIKI_ICON;
			public static final int WIKI_ICON_VANILLA = InterfaceID.Orbs.WIKI_ICON_GRAPHIC;
			public static final int WORLD_MAP = InterfaceID.Orbs.ORB_WORLDMAP;
		}

		//classic-resizable widgets
		public static final class Classic
		{
			public static final int ORBS = InterfaceID.ToplevelOsrsStretch.ORBS;

			public static final int MAP_NOCLICK_0 = InterfaceID.ToplevelOsrsStretch.MAP_NOCLICK_0;
			public static final int MAP_NOCLICK_1 = InterfaceID.ToplevelOsrsStretch.MAP_NOCLICK_1;
			public static final int MAP_NOCLICK_2 = InterfaceID.ToplevelOsrsStretch.MAP_NOCLICK_2;
			public static final int MAP_NOCLICK_3 = InterfaceID.ToplevelOsrsStretch.MAP_NOCLICK_3;
			public static final int MAP_NOCLICK_4 = InterfaceID.ToplevelOsrsStretch.MAP_NOCLICK_4;
			public static final int MAP_NOCLICK_5 = InterfaceID.ToplevelOsrsStretch.MAP_NOCLICK_5;

			public static final int MINIMAP_MASK = InterfaceID.ToplevelOsrsStretch.MINIMAP;
			public static final int MINIMAP = InterfaceID.ToplevelOsrsStretch.MAP_MINIMAP_GRAPHIC9;

			public static final int COMPASS = InterfaceID.ToplevelOsrsStretch.MAP_MINIMAP_GRAPHIC6;
			public static final int COMPASS_OPTIONS = InterfaceID.ToplevelOsrsStretch.COMPASSCLICK;

			public static final int COMPASS_PARENT = InterfaceID.ToplevelOsrsStretch.MAP_MINIMAP;
		}

		//modern-resizable widgets
		public static final class Modern
		{
			public static final int ORBS = InterfaceID.ToplevelPreEoc.ORBS;

			public static final int MAP_NOCLICK_0 = InterfaceID.ToplevelPreEoc.MAP_NOCLICK_0;
			public static final int MAP_NOCLICK_1 = InterfaceID.ToplevelPreEoc.MAP_NOCLICK_1;
			public static final int MAP_NOCLICK_2 = InterfaceID.ToplevelPreEoc.MAP_NOCLICK_2;
			public static final int MAP_NOCLICK_3 = InterfaceID.ToplevelPreEoc.MAP_NOCLICK_3;
			public static final int MAP_NOCLICK_4 = InterfaceID.ToplevelPreEoc.MAP_NOCLICK_4;
			public static final int MAP_NOCLICK_5 = InterfaceID.ToplevelPreEoc.MAP_NOCLICK_5;

			public static final int MINIMAP_MASK = InterfaceID.ToplevelPreEoc.MINIMAP;
			public static final int MINIMAP = InterfaceID.ToplevelPreEoc.MAP_MINIMAP_GRAPHIC9;

			public static final int COMPASS = InterfaceID.ToplevelPreEoc.MAP_MINIMAP_GRAPHIC6;
			public static final int COMPASS_OPTIONS = InterfaceID.ToplevelPreEoc.COMPASSCLICK;

			public static final int COMPASS_PARENT = InterfaceID.ToplevelPreEoc.MAP_MINIMAP;

			public static final int LOGOUT_X_ICON = InterfaceID.ToplevelPreEoc.ICON10;
			public static final int LOGOUT_X_STONE = InterfaceID.ToplevelPreEoc.STONE10;
		}
	}
}

/*
 * Copyright (c) 2025, cue <https://github.com/its-cue>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

package com.compactorbs;

import com.compactorbs.CompactOrbsConfig.OrbLayout;
import com.compactorbs.CompactOrbsConfig.HorizontalPosition;
import com.compactorbs.CompactOrbsConfig.VerticalPosition;
import com.compactorbs.CompactOrbsConfig.TogglePlacement;
import com.compactorbs.CompactOrbsConstants.ConfigGroup;
import com.compactorbs.CompactOrbsConstants.ConfigKeys;
import com.compactorbs.CompactOrbsConstants.Layout;
import com.compactorbs.CompactOrbsConstants.Menu;
import com.compactorbs.CompactOrbsConstants.Script;
import com.compactorbs.CompactOrbsConstants.Sprite;
import com.compactorbs.CompactOrbsConstants.Varbit;
import com.compactorbs.CompactOrbsConstants.VarbitValue;
import com.compactorbs.CompactOrbsConstants.Widgets.Classic;
import com.compactorbs.CompactOrbsConstants.Widgets.Modern;
import com.compactorbs.CompactOrbsConstants.Widgets.MinimapOverlay;
import com.compactorbs.CompactOrbsConstants.Widgets.Orb;
import com.compactorbs.widget.TargetWidget;
import com.compactorbs.widget.WidgetManager;
import com.compactorbs.widget.elements.Compass;
import com.compactorbs.widget.elements.Minimap;
import com.compactorbs.widget.elements.Orbs;
import com.compactorbs.widget.offset.Offsets;
import com.compactorbs.widget.slot.Slot;
import com.compactorbs.widget.slot.SlotConfig;
import com.compactorbs.widget.slot.SlotManager;
import java.util.HashMap;
import java.util.Map;
import java.util.function.Supplier;
import javax.inject.Inject;
import javax.inject.Singleton;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.GameState;
import net.runelite.api.widgets.Widget;
import net.runelite.api.widgets.WidgetPositionMode;
import net.runelite.api.widgets.WidgetSizeMode;
import net.runelite.api.widgets.WidgetType;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.util.ColorUtil;

@Slf4j
@Singleton
public class CompactOrbsManager
{
	@Inject
	private Client client;

	@Inject
	private ConfigManager configManager;

	@Inject
	private CompactOrbsConfig config;

	@Inject
	private WidgetManager widgetManager;

	@Inject
	private SlotManager slotManager;

	//store the parent id from the previous widget (modern vs classic): -1 = no parent
	private int previousParentId = -1;

	//offsets for vertical and horizontal layout
	public int verticalOffset;
	public int horizontalOffset;

	//reset shutdown flag for the world map orb
	public boolean hideWorldMap;

	//update flag for the custom widgets
	public boolean pendingChildrenUpdate;

	//minimap overlay flag, when layer is ready for children
	public boolean pendingMinimapOverlayChildren;

	//custom widgets created when in compact layout
	private Widget compassFrame;
	private Widget minimapButton;
	private Widget compassButton;

	private final Map<String, Map.Entry<Supplier<Boolean>, TargetWidget[]>> hideByConfigMap = new HashMap<>();
	private final Map<Integer, Map.Entry<Supplier<Boolean>, TargetWidget[]>> hideByScriptMap = new HashMap<>();

	public final Map<TargetWidget, Supplier<Boolean>> orbToToggle = new HashMap<>();

	public void init(int scriptId)
	{
		if (!isLoggedIn())
		{
			return;
		}

		updateWikiBanner(config.hideWiki());

		updateOrbByScript(scriptId);

		if (!isResized())
		{
			if (previousParentId != -1 || slotManager.allowFixedModeUpdate)
			{
				//update on initial load, when in fixed mode
				widgetManager.remapTargets(false, Script.FORCE_UPDATE, Orbs.FIXED.toArray(Orbs[]::new));
				widgetManager.remapTarget(Orbs.WORLD_MAP_CONTAINER, false);

				//always hide the minimap overlay in fixed mode
				widgetManager.setHidden(CompactOrbsConstants.Widgets.MinimapOverlay.UNIVERSE, true);

				//reset update flags
				previousParentId = -1;
				slotManager.allowFixedModeUpdate = false;
			}
			return;
		}

		build(scriptId);
	}

	private void build(int scriptId)
	{
		if (!isResized())
		{
			return;
		}

		getLayoutOffsets();

		createCustomChildren();

		if (scriptId == Script.FORCE_UPDATE)
		{
			widgetManager.setTargetsHidden(isMinimapHidden(), Minimap.values());
			widgetManager.setTargetsHidden((isMinimapHidden() && isCompassHidden()), Compass.values());
			widgetManager.remapTargets(isMinimapHidden(), Script.FORCE_UPDATE, Compass.values());
			widgetManager.remapTargets(isMinimapHidden(), Script.FORCE_UPDATE, Orbs.values());//?
		}
		else
		{
			widgetManager.remapTargets(isMinimapHidden(), scriptId, Orbs.values());
		}

		updateCustomChildren(pendingChildrenUpdate || scriptId == Script.FORCE_UPDATE);
	}

	public void reset()
	{
		verticalOffset = 0;
		horizontalOffset = 0;

		hideWorldMap = false;

		updateWikiBanner(false);

		clearCustomChildren();

		hideByConfigMap.clear();
		hideByScriptMap.clear();

		//set all orbs to visible
		widgetManager.setTargetsHidden(false, Orbs.values());

		slotManager.reset();

		if (!isResized())
		{
			widgetManager.remapTargets(false, Script.FORCE_UPDATE, Orbs.WORLD_MAP_CONTAINER);
		}

		if (isMinimapHidden())
		{
			widgetManager.setTargetsHidden(false, Minimap.values());

			if (isCompassHidden())
			{
				widgetManager.setTargetsHidden(false, Compass.values());
			}

			widgetManager.remapTargets(false, Script.FORCE_UPDATE, Compass.values());
		}

		resetMinimapOverlayContainer();

		//protect certain fixed mode orbs from being changed when in fixed mode
		widgetManager.remapTargets(false, Script.FORCE_UPDATE,
			(isResized() ? Orbs.values() : Orbs.FIXED.toArray(Orbs[]::new)));
	}

	//toggle the minimap visibility, and update related widgets when using the custom toggle button
	public void onMinimapToggle()
	{
		boolean toggle = !isMinimapHidden();
		boolean remapCondition = toggle && !isCompassHidden();
		boolean hiddenCondition = toggle && isCompassHidden();
		executeToggle(
			config::hideMinimap, ConfigKeys.MINIMAP,
			this::getLayoutOffsets,
			() -> widgetManager.setTargetsHidden(toggle, Minimap.values()),
			() -> widgetManager.remapTargets(remapCondition, Script.FORCE_UPDATE, Compass.values()),
			() -> widgetManager.setTargetsHidden(hiddenCondition, Compass.values()),
			() -> widgetManager.remapTargets(toggle, Script.FORCE_UPDATE, Orbs.values()),
			() -> updateCustomChildren(true)
		);
	}

	//toggle the compass visibility, and update related widgets when using the custom toggle button
	private void onCompassToggle()
	{
		boolean toggle = !isCompassHidden();
		boolean remapCondition = toggle || isMinimapHidden();
		executeToggle(
			config::hideCompass, ConfigKeys.COMPASS,
			this::getLayoutOffsets,
			() -> widgetManager.remapTargets(remapCondition, Script.FORCE_UPDATE, Compass.values()),
			() -> widgetManager.setTargetsHidden(toggle, Compass.values()),
			() -> updateCustomChildren(true)
		);
	}

	//flip the config (key) and execute the chain of actions when using the custom toggle buttons
	private void executeToggle(Supplier<Boolean> getter, String key, Runnable... actions)
	{
		configManager.setConfiguration(ConfigGroup.GROUP_NAME, key, !Boolean.TRUE.equals(getter.get()));

		for (Runnable action : actions)
		{
			action.run();
		}
	}

	//create the compass frame and toggle buttons, clearing them if the parent id changed,
	//and only creating widgets if missing from the current parent
	public void createCustomChildren()
	{
		Widget parent = widgetManager.getCurrentParent();

		if (parent == null || parent.getId() != previousParentId)
		{
			clearCustomChildren();
			previousParentId = parent != null ? parent.getId() : -1;
			if (parent == null)
			{
				return;
			}
		}

		if (widgetManager.isMissing(compassFrame, parent))
		{
			compassFrame = widgetManager.createGraphic(
				parent,
				0, 0, //handled in updateCustomChildren()
				Layout.FRAME_WIDTH, Layout.FRAME_HEIGHT,
				Layout.OPACITY,
				Sprite.COMPASS_FRAME
			);
		}

		if (widgetManager.isMissing(minimapButton, parent))
		{
			minimapButton = widgetManager.createToggleButton(
				parent,
				0, 0, //handled in updateCustomChildren()
				Layout.TOGGLE_BUTTON_WIDTH, Layout.TOGGLE_BUTTON_HEIGHT,
				Layout.OPACITY,
				getSpriteId(isMinimapHidden()),
				getMenuOption(ConfigKeys.MINIMAP),
				e -> onMinimapToggle(),
				e -> minimapButton.setOpacity(Layout.OPACITY_HOVER),
				e -> minimapButton.setOpacity(Layout.OPACITY)
			);
		}

		if (widgetManager.isMissing(compassButton, parent))
		{
			compassButton = widgetManager.createToggleButton(
				parent,
				0, 0, //handled in updateCustomChildren()
				Layout.TOGGLE_BUTTON_WIDTH, Layout.TOGGLE_BUTTON_HEIGHT,
				Layout.OPACITY,
				getSpriteId(isCompassHidden()),
				getMenuOption(ConfigKeys.COMPASS),
				e -> onCompassToggle(),
				e -> compassButton.setOpacity(Layout.OPACITY_HOVER),
				e -> compassButton.setOpacity(Layout.OPACITY)
			);

			//prevent de-sync
			pendingChildrenUpdate = true;
		}
	}

	//handle dynamic widget changes for visibility, positions, sprites, and menu actions for the
	//compass frame and toggle buttons (logout X being an exception in native minimap hiding)
	public void updateCustomChildren(boolean shouldUpdate)
	{
		//missing children -> create them; prevent updates until all exist
		if (compassFrame == null || compassButton == null || minimapButton == null)
		{
			//will trigger pendingChildrenUpdate when custom widgets are created
			//for the next updateCustomChildren call
			createCustomChildren();
			return;
		}

		if (isMinimized())
		{
			//put logout button back when switching to native hiding
			widgetManager.remapTargets(false, Script.FORCE_UPDATE, Orbs.LOGOUT_X_ICON, Orbs.LOGOUT_X_STONE);
		}

		//make changes when pendingChildrenUpdate (or shouldUpdate = true is passed)
		if (shouldUpdate)
		{
			updateCompassFrameChild();
			updateMinimapToggleButton();
			updateCompassToggleButton();

			//treat minimap overlay as 'custom'
			updateMinimapOverlayVisibility();

			//clear update flag
			pendingChildrenUpdate = false;
		}
	}

	public void updateCompassFrameChild()
	{
		compassFrame.setHidden(hideCompassFrame());
		widgetManager.updateValue(compassFrame::getOriginalX, compassFrame::setOriginalX, getCompassFrameX());
		widgetManager.updateValue(compassFrame::getOriginalY, compassFrame::setOriginalY, getCompassFrameY());
		compassFrame.revalidate();
	}

	public void updateMinimapToggleButton()
	{
		minimapButton.setSpriteId(getSpriteId(!isMinimapHidden()));
		minimapButton.setHidden(hideCustomToggles() || config.hideMinimapToggle());
		minimapButton.setAction(0, getMenuOption(ConfigKeys.MINIMAP));
		widgetManager.updateValue(minimapButton::getOriginalX, minimapButton::setOriginalX, getMinimapButtonX());
		widgetManager.updateValue(minimapButton::getOriginalY, minimapButton::setOriginalY, getMinimapButtonY());
		minimapButton.revalidate();
	}

	public void updateCompassToggleButton()
	{
		compassButton.setSpriteId(getSpriteId(!isCompassHidden()));
		compassButton.setHidden((hideCustomToggles() || config.hideCompassToggle()) || !isMinimapHidden());
		compassButton.setAction(0, getMenuOption(ConfigKeys.COMPASS));
		widgetManager.updateValue(compassButton::getOriginalX, compassButton::setOriginalX, getCompassButtonX());
		widgetManager.updateValue(compassButton::getOriginalY, compassButton::setOriginalY, getCompassButtonY());
		compassButton.revalidate();
	}

	//clear any created children and reset previous parent id
	private void clearCustomChildren()
	{
		widgetManager.clearChildren(Modern.ORBS);
		widgetManager.clearChildren(Classic.ORBS);

		previousParentId = -1;

		compassFrame = null;
		minimapButton = null;
		compassButton = null;
	}

	//update visibility of the minimap overlay
	public void updateMinimapOverlayVisibility()
	{
		widgetManager.setHidden(CompactOrbsConstants.Widgets.MinimapOverlay.UNIVERSE, hideMinimapOverlay());
	}

	//set hooked layer back to default
	private void resetMinimapOverlayContainer()
	{
		configureMinimapOverlayContainer(false);
		widgetManager.clearChildren(MinimapOverlay.UNIVERSE);
	}

	//initial setup for the minimap overlay
	//@enabled - for startup/shutdown behaviour
	public void configureMinimapOverlayContainer(boolean enabled)
	{
		Widget parent = client.getWidget(CompactOrbsConstants.Widgets.MinimapOverlay.UNIVERSE);
		if (parent == null)
		{
			return;
		}

		//don't modify if it already has been modified
		if (enabled && parent.getXPositionMode() == 2)
		{
			return;
		}

		if (!enabled)
		{
			parent.setForcedPosition(-1, -1);
			parent.setHidden(false);
		}

		//set layer to be used for the minimap overlay
		parent.
			setOriginalWidth(enabled ? Layout.MinimapOverlay.CONTAINER_WIDTH : 0).
			setOriginalHeight(enabled ? Layout.MinimapOverlay.CONTAINER_HEIGHT : 0).
			setWidthMode(enabled ? WidgetSizeMode.ABSOLUTE : WidgetSizeMode.MINUS).
			setHeightMode(enabled ? WidgetSizeMode.ABSOLUTE : WidgetSizeMode.MINUS).
			setXPositionMode(enabled ? WidgetPositionMode.ABSOLUTE_RIGHT : WidgetPositionMode.ABSOLUTE_CENTER).
			setYPositionMode(enabled ? WidgetPositionMode.ABSOLUTE_TOP : WidgetPositionMode.ABSOLUTE_CENTER);

		//update changes
		parent.revalidate();

		//flagged as ready for children
		pendingMinimapOverlayChildren = true;
	}

	//create necessary widgets for the minimap overlay
	public void createMinimapOverlayChildren()
	{
		Widget parent = client.getWidget(MinimapOverlay.UNIVERSE);
		if (parent == null)
		{
			return;
		}

		//add no_click layers
		for (int index = 0; index < Layout.MinimapOverlay.NO_CLICK_Y.length; index++)
		{
			widgetManager.createMinimapNoClickLayer(
				parent, index,
				Layout.MinimapOverlay.NO_CLICK_Y[index],
				Layout.MinimapOverlay.NO_CLICK_WIDTH[index],
				Layout.MinimapOverlay.NO_CLICK_HEIGHT[index]
			);
		}

		//add compass
		widgetManager.createMinimapElement(
			parent, 6,
			Layout.MinimapOverlay.COMPASS_CONTENT,
			Sprite.COMPASS_MASK,
			Layout.Original.COMPASS_X - Layout.MinimapOverlay.WIDTH_DIFF, //difference between original width, and overlay widget
			Layout.Original.COMPASS_Y,
			Layout.Original.COMPASS_DIMENSION,
			Layout.Original.COMPASS_DIMENSION,
			WidgetPositionMode.ABSOLUTE_LEFT,
			WidgetPositionMode.ABSOLUTE_TOP
		);

		//add minimap
		widgetManager.createMinimapElement(
			parent, 7,
			Layout.MinimapOverlay.MINIMAP_CONTENT,
			Sprite.MINIMAP_MASK,
			Layout.Original.MINIMAP_X,
			Layout.Original.MINIMAP_Y,
			Layout.Original.MINIMAP_DIMENSION,
			Layout.Original.MINIMAP_DIMENSION,
			WidgetPositionMode.ABSOLUTE_RIGHT,
			WidgetPositionMode.ABSOLUTE_TOP
		);

		//add minimap frame
		Widget frame = parent.createChild(8, WidgetType.GRAPHIC);
		frame.setSpriteId(Sprite.MINIMAP_FRAME).
			setXPositionMode(WidgetPositionMode.ABSOLUTE_RIGHT).
			setYPositionMode(WidgetPositionMode.ABSOLUTE_TOP).
			setOriginalWidth(Layout.MinimapOverlay.CONTAINER_WIDTH).
			setOriginalHeight(Layout.MinimapOverlay.CONTAINER_HEIGHT).
			revalidate();
	}

	//show or hide the wiki banner (vanilla or plugin) based on which exists
	//vanilla = official wiki banner
	public void updateWikiBanner(boolean hidden)
	{
		if (!isLoggedIn())
		{
			return;
		}

		boolean wikiPluginActive = Boolean.TRUE.equals(
			configManager.getConfiguration(ConfigGroup.RuneLite.GROUP_NAME,
				ConfigKeys.RuneLite.WIKI_PLUGIN, Boolean.class)
		);

		boolean showWikiMinimapButton =
			configManager.getConfiguration(ConfigGroup.Wiki.GROUP_NAME,
				ConfigKeys.Wiki.SHOW_WIKI_MINIMAP_BUTTON, Boolean.class
			);

		//container holding the vanilla or wiki banner
		Widget container = widgetManager.getTargetWidget(Orbs.WIKI_ICON_CONTAINER);
		if (container == null)
		{
			return;
		}

		Widget banner = null;
		boolean vanilla = true;

		//check to see if wiki banner exists
		if (isPluginWikiBanner(container))
		{
			banner = container.getChild(0);
			vanilla = false;
		}

		//wiki plugin banner doesn't exist, check vanilla
		if (banner == null)
		{
			banner = widgetManager.getTargetWidget(Orbs.WIKI_VANILLA_CONTAINER);
		}

		//guard if either are null
		if (banner == null)
		{
			return;
		}

		boolean shouldHide = hidden || (wikiPluginActive && showWikiMinimapButton && vanilla);
		banner.setHidden(shouldHide);
	}

	public boolean isPluginWikiBanner(Widget container)
	{
		if (container == null)
		{
			return false;
		}
		return (container.getDynamicChildren() != null || container.getDynamicChildren().length > 0);
	}

	private void getLayoutOffsets()
	{
		if (!isLoggedIn())
		{
			return;
		}

		boolean isCompactLayout = (isResized() && isMinimapHidden());

		//zero out
		verticalOffset = 0;

		if (isVerticalLayout())
		{
			if (isCompactLayout)
			{
				if (isVerticalLeft())
				{
					verticalOffset = Layout.Vertical.LEFT_OFFSET;
				}
				else
				{
					verticalOffset = Layout.Vertical.RIGHT_OFFSET;
				}
			}
		}

		//zero out
		horizontalOffset = 0;

		if (isHorizontalLayout())
		{
			if (isCompactLayout)
			{
				if (isHorizontalBottom())
				{
					horizontalOffset = Layout.Horizontal.BOTTOM_OFFSET;
				}
				else
				{
					horizontalOffset = Layout.Horizontal.TOP_OFFSET;
				}
			}
		}

		getWorldMapOffset();
	}

	public boolean updateWorldMap()
	{
		if (isResized())
		{
			return hideWorldMap;
		}

		Widget worldMap = client.getWidget(Orb.WORLD_MAP);
		if (worldMap == null)
		{
			return false;
		}

		return hideWorldMap;
	}

	public int getWorldMapOffset()
	{
		return (hideWorldMap ? 1 - Layout.WORLD_MAP_CONTAINER_WIDTH : 0);
	}

	private int getSpriteId(boolean hidden)
	{
		return hidden ? Sprite.VISIBLE : Sprite.HIDDEN;
	}

	private String getMenuOption(String key)
	{
		final boolean isMinimap = ConfigKeys.MINIMAP.equals(key);
		final boolean isHidden = isMinimap ? isMinimapHidden() : isCompassHidden();

		String target = isMinimap ? Menu.SUFFIX_MINIMAP : Menu.SUFFIX_COMPASS;
		String action = isHidden ? Menu.PREFIX_SHOW : Menu.PREFIX_HIDE;

		return action + " " + ColorUtil.wrapWithColorTag(target, Menu.COLOR);
	}

	//returns true if client is in resizable mode
	public boolean isResized()
	{
		return client.isResized();
	}

	public boolean isLoggedIn()
	{
		return client.getGameState() == GameState.LOGGED_IN;
	}

	public boolean activityOrbIsVisibleSetting()
	{
		return client.getVarbitValue(Varbit.ACTIVITY_ORB_TOGGLE) == VarbitValue.ACTIVITY_ORB_VISIBLE;
	}

	public boolean storeOrbIsVisibleSetting()
	{
		return client.getVarbitValue(Varbit.STORE_ORB_TOGGLE) == VarbitValue.STORE_ORB_VISIBLE;
	}

	//returns the current layout (vertical or horizontal)
	public int getLayout()
	{
		return config.layout().getIndex();
	}

	//return true if in compact view
	public boolean isCompactMode()
	{
		return isResized() && isMinimapHidden();
	}

	//returns true if orb swapping is enabled
	public boolean enableOrbSwapping()
	{
		return config.enableOrbSwapping();
	}

	//returns true if layout is vertical
	public boolean isVerticalLayout()
	{
		return config.layout() == OrbLayout.VERTICAL;
	}

	//returns true if position is vertical left
	public boolean isVerticalLeft()
	{
		return config.verticalPosition() == VerticalPosition.LEFT;
	}

	//returns true if position is vertical right
	public boolean isVerticalRight()
	{
		return config.verticalPosition() == VerticalPosition.RIGHT;
	}

	//returns true if layout is horizontal
	public boolean isHorizontalLayout()
	{
		return config.layout() == OrbLayout.HORIZONTAL;
	}

	//returns true if position is horizontal bottom
	public boolean isHorizontalBottom()
	{
		return config.horizontalPosition() == HorizontalPosition.BOTTOM;
	}

	//returns true if layout is horizontal top
	public boolean isHorizontalTop()
	{
		return config.horizontalPosition() == HorizontalPosition.TOP;
	}

	public boolean preventReordering()
	{
		return config.disableReordering();
	}

	public boolean leaveEmptySpace()
	{
		return config.leaveEmptySpace();
	}

	//returns true if minimap is hidden
	public boolean isMinimapHidden()
	{
		return config.hideMinimap();
	}

	//returns true if compass is hidden
	public boolean isCompassHidden()
	{
		return config.hideCompass();
	}

	//returns true if the xp drop orb is hidden
	public boolean isXpDropHidden()
	{
		return config.hideXp();
	}

	//returns true when compass frame should be hidden
	private boolean hideCompassFrame()
	{
		return !isMinimapHidden() || isCompassHidden() || isMinimized();
	}

	//returns true when toggle buttons should be hidden
	private boolean hideCustomToggles()
	{
		return (config.hideMinimapToggle() && config.hideCompassToggle()) || isMinimized();
	}

	//change to hideOverlay
	public boolean hideMinimapOverlay()
	{
		return !(isMinimapOverlayEnabled() && isMinimapHidden() && !isMinimized()) || !isResized();
	}

	public boolean isMinimapOverlayEnabled()
	{
		return config.showMinimapInCompactView();
	}

	//in-game native minimap hiding
	public boolean isMinimized()
	{
		return client.getVarbitValue(Varbit.MINIMAP_TOGGLE) == VarbitValue.MINIMAP_MINIMIZED;
	}

	//check if a cutscene is active
	public boolean isCutSceneActive()
	{
		return client.getVarbitValue(Varbit.CUTSCENE_STATUS) == VarbitValue.CUTSCENE_ACTIVE;
	}

	//custom children offset handling~ similar to OffsetTarget interface
	private int getCompassFrameX()
	{
		return Offsets.COMPASS.offsetTarget().getOffsetX() - Layout.FRAME_X_OFFSET;
	}

	private int getCompassFrameY()
	{
		return Offsets.COMPASS.offsetTarget().getOffsetY() - Layout.FRAME_Y_OFFSET;
	}

	private int getMinimapButtonX()
	{
		boolean vertical = isVerticalLayout() && isMinimapHidden();
		boolean horizontal = isHorizontalLayout() && isMinimapHidden();

		int x = config.minimapTogglePlacement().getX();

		if (config.minimapTogglePlacement() == TogglePlacement.BELOW_MAP
			&& config.hideStore()
			&& !isMinimapHidden())
		{
			//offset when store is hidden, and minimap is visible
			x -= 33;
		}

		if (vertical)
		{
			return Layout.DEFAULT_MINIMAP_BUTTON_X - verticalOffset;
		}

		if (horizontal)
		{
			x = Layout.DEFAULT_MINIMAP_BUTTON_X;

			if (config.hideWiki() && !preventReordering())
			{
				//offset when wiki is hidden, in horizontal layout
				x -= 40;
			}

			if (isVerticalLeft())
			{
				int hiddenWidth = slotManager.getHorizontalHiddenWidth();
				x -= hiddenWidth;
			}

			return x;
		}

		return x;
	}

	private int getMinimapButtonY()
	{
		boolean vertical = isVerticalLayout() && isMinimapHidden();
		boolean horizontal = isHorizontalLayout() && isMinimapHidden();

		int y = config.minimapTogglePlacement().getY();

		if (config.minimapTogglePlacement() == TogglePlacement.BELOW_MAP
			&& config.hideStore()
			&& !isMinimapHidden())
		{
			//offset when store is hidden and minimap is visible
			y -= 5;
		}

		if (vertical)
		{
			//original vertical y
			y = Layout.DEFAULT_MINIMAP_BUTTON_Y;

			if (isHorizontalTop())
			{
				y += horizontalOffset;

				//anchor minimap button to wiki icon container in vertical
				y = slotManager.applyHiddenYOffset(Orbs.WIKI_ICON_CONTAINER, y);

				//apply an offset when the amount hidden, leaves wiki slot as the last
				//0-HP, 1-Pray, 2-Run, 3-Spec, 4-Wiki
				if (slotManager.getHiddenCountAbove(Orbs.WIKI_ICON_CONTAINER) == Slot.VERTICAL_RIGHT_COLUMN.indexOf(Slot.WIKI_SLOT)
					&& !preventReordering())
				{
					//match wiki container offset @WikiContainerOffset
					y += 10;

					if (config.hideWiki())
					{
						//offset if wiki is hidden
						y -= 20;

						if (config.hideLogout())
						{
							//align to compass toggle, when X is hidden
							y -= 4;
						}
					}
				}
			}
			return y;
		}

		if (horizontal)
		{
			return ((Layout.DEFAULT_MINIMAP_BUTTON_Y) / 2) + horizontalOffset - 10; //- 10: apply the horizontal Y change in constants
		}

		return y;
	}

	private int getCompassButtonX()
	{
		int x = Offsets.COMPASS.offsetTarget().getOffsetX()
			+ Layout.COMPASS_BUTTON_X_OFFSET;

		if (isHorizontalLayout())
		{
			x += Layout.COMPASS_BUTTON_HORIZONTAL_X_OFFSET;
		}
		return x;
	}

	private int getCompassButtonY()
	{
		int y = Offsets.COMPASS.offsetTarget().getOffsetY()
			+ Layout.COMPASS_BUTTON_Y_OFFSET;

		if (isHorizontalLayout())
		{
			y -= Layout.COMPASS_BUTTON_HORIZONTAL_Y_OFFSET;
		}

		return y;
	}

	//register an orb toggle entry in the config and script maps
	public void registerOrbToggle(String key, Supplier<Boolean> toggle, TargetWidget... targets)
	{
		hideByConfigMap.put(key, Map.entry(toggle, targets));

		int scriptId = Script.FORCE_UPDATE;

		for (TargetWidget target : targets)
		{
			//match orb to toggle, used for slots
			orbToToggle.put(target, toggle);

			if (scriptId == Script.FORCE_UPDATE && target instanceof Orbs)
			{
				scriptId = target.getScriptId();
			}
		}

		if (scriptId != Script.FORCE_UPDATE)
		{
			hideByScriptMap.put(scriptId, Map.entry(toggle, targets));
		}
	}

	//apply toggle setting to orbs based on the fired script id; pass FORCE_UPDATE for all toggles
	private void updateOrbByScript(int scriptId)
	{
		(scriptId == Script.FORCE_UPDATE ? hideByConfigMap : hideByScriptMap).forEach(
			(key, value) ->
			{
				//don't actually hide, since handled elsewhere
				if (key.equals(ConfigKeys.HIDE_WORLD) ||
					key.equals(ConfigKeys.HIDE_WIKI) ||
					key.equals(Script.WORLD_MAP_UPDATE) ||
					key.equals(Script.WIKI_ICON_UPDATE))
				{
					return;
				}

				widgetManager.setTargetsHidden(value.getKey().get(), value.getValue());
			}
		);
	}

	//apply toggle setting to orbs based on the config key in onConfigChanged
	public void updateOrbByConfig(String key)
	{
		//world map config handling for onConfigChanged
		if (key.equals(ConfigKeys.HIDE_WORLD))
		{
			hideWorldMap = config.hideWorld();
			widgetManager.remapTarget(Orbs.WORLD_MAP_CONTAINER, isMinimapHidden() && isResized());
		}
		//wiki banner config handling for onConfigChanged
		else if (key.equals(ConfigKeys.HIDE_WIKI))
		{
			updateWikiBanner(config.hideWiki());

			//update the minimap toggle button when in horizontal layout,
			//and minimap is hidden (offset is applied that needs updated)
			if (isHorizontalLayout() && isMinimapHidden())
			{
				updateMinimapToggleButton();
			}
		}
		else
		{
			Map.Entry<Supplier<Boolean>, TargetWidget[]> entry = hideByConfigMap.get(key);
			if (entry != null)
			{
				//set orb visibility based on config
				widgetManager.setTargetsHidden(entry.getKey().get(), entry.getValue());

				//update the minimap toggle button when hiding/showing store orb,
				//while minimap is hidden, and button position is below map
				if (key.equals(ConfigKeys.HIDE_STORE)
					&& config.minimapTogglePlacement() == TogglePlacement.BELOW_MAP
					&& !isMinimapHidden() && isLoggedIn())
				{
					updateMinimapToggleButton();
				}
			}
		}
	}

	//update a slots config for the passed widget value @SlotManager
	public void updateConfigForSlot(Slot key, TargetWidget value, SlotManager.SlotLayoutMode layout)
	{
		SlotConfig entry = key.getSlotConfigMap().get(layout);
		if (entry != null && entry.getConfigKey() != null)
		{
			configManager.setConfiguration(ConfigGroup.GROUP_NAME, entry.getConfigKey(), value);
		}
	}
}

/*
 * Copyright (c) 2025, cue <https://github.com/its-cue>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

package com.compactorbs;

import static com.compactorbs.CompactOrbsConstants.ConfigGroup.GROUP_NAME;
import com.compactorbs.CompactOrbsConstants.ConfigKeys;
import com.compactorbs.CompactOrbsConstants.Script;
import com.compactorbs.CompactOrbsConstants.Varbit;
import com.compactorbs.CompactOrbsConstants.Widgets.Classic;
import com.compactorbs.CompactOrbsConstants.Widgets.Modern;
import com.compactorbs.CompactOrbsConstants.Widgets.Orb;
import com.compactorbs.widget.elements.Compass;
import com.compactorbs.widget.overlay.MinimapOverlay;
import com.compactorbs.widget.slot.SlotLayout;
import com.compactorbs.widget.slot.SlotManager;
import com.compactorbs.widget.WidgetManager;
import com.compactorbs.widget.elements.Orbs;
import com.compactorbs.widget.slot.Slot;
import com.google.inject.Provides;
import javax.inject.Inject;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.events.GameStateChanged;
import net.runelite.api.events.ScriptPostFired;
import net.runelite.api.events.VarbitChanged;
import net.runelite.api.events.WidgetLoaded;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.events.ConfigChanged;
import net.runelite.client.input.KeyManager;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.plugins.PluginDescriptor;
import net.runelite.client.ui.overlay.OverlayManager;
import net.runelite.client.util.HotkeyListener;

@Slf4j
@PluginDescriptor(
	name = "Compact Orbs",
	description = "Collapse the minimap orbs into a compact view.",
	tags = {"compact", "orbs", "layout", "hide", "minimap", "resizable", "classic", "modern", "world", "map", "wiki", "swap"},
	conflicts = {"Fixed Resizable Hybrid", "Orb Hider", "Minimap Hider"}
)
public class CompactOrbsPlugin extends Plugin
{
	@Inject
	private Client client;

	@Inject
	private ClientThread clientThread;

	@Inject
	private CompactOrbsConfig config;

	@Inject
	private CompactOrbsManager manager;

	@Inject
	private ConfigManager configManager;

	@Inject
	private KeyManager keyManager;

	@Inject
	private MinimapOverlay minimapOverlay;

	@Inject
	private OverlayManager overlayManager;

	@Inject
	private WidgetManager widgetManager;

	@Inject
	private SlotManager slotManager;

	@Override
	protected void startUp() throws Exception
	{
		overlayManager.add(minimapOverlay);

		keyManager.registerKeyListener(hotkeyListener);

		registerOrbToggleEntries();

		manager.pendingChildrenUpdate = false;

		manager.hideWorldMap = config.hideWorld();

		clientThread.invoke(() ->
		{
			slotManager.initSlots();

			if (manager.isLoggedIn())
			{
				manager.init(Script.FORCE_UPDATE);
				manager.configureMinimapOverlayContainer(true);
			}
		});
	}

	@Override
	protected void shutDown() throws Exception
	{
		overlayManager.remove(minimapOverlay);

		keyManager.unregisterKeyListener(hotkeyListener);

		clientThread.invoke(manager::reset);
	}

	@Subscribe
	public void onGameStateChanged(GameStateChanged event)
	{
		if (manager.isLoggedIn())
		{
			manager.createCustomChildren();

			slotManager.allowFixedModeUpdate = true;
		}
	}

	@Subscribe
	public void onScriptPostFired(ScriptPostFired event)
	{
		int scriptId = event.getScriptId();

		if (scriptId == Script.TOP_LEVEL_REDRAW || scriptId == Script.TOP_LEVEL_SIDE_CUSTOMIZE)
		{
			//keep the logout X hidden
			if (config.hideLogout() && !manager.isMinimized())
			{
				widgetManager.setTargetsHidden(config.hideLogout(), Orbs.LOGOUT_X_ICON, Orbs.LOGOUT_X_STONE);
			}

			//flag updates for custom widgets when a cutscene is active
			if (scriptId == Script.TOP_LEVEL_REDRAW)
			{
				manager.pendingChildrenUpdate = manager.isCutSceneActive();
			}
		}

		//buff bar content script, fires frequently (lazy reset)
		if (scriptId == Script.BUFF_BAR_CONTENT_UPDATE)
		{
			if (minimapOverlay.hasUpdatedBounds() && manager.pendingMinimapOverlayChildren)
			{
				log.debug("buff bar is ready for children");

				manager.pendingMinimapOverlayChildren = false;
				clientThread.invokeLater(manager::createMinimapOverlayChildren);
			}
		}

		//don't make changes unless a script updates the minimap widgets,
		// or if the minimap is natively minimized
		if (!Script.MINIMAP_UPDATE_SCRIPTS.contains(scriptId) || manager.isMinimized())
		{
			return;
		}

		//override the in-game settings if enabled
		if (scriptId == Script.ACTIVITY_ORB_UPDATE &&
			manager.activityOrbIsVisibleSetting() &&
			config.hideActivity())
		{
			widgetManager.setHidden(Orbs.ACTIVITY_ORB_CONTAINER, config.hideActivity());
			return;
		}

		//override the in-game settings if enabled
		if (scriptId == Script.STORE_ORB_UPDATE &&
			manager.storeOrbIsVisibleSetting() &&
			config.hideStore())
		{
			widgetManager.setHidden(Orbs.STORE_ORB_CONTAINER, config.hideStore());
			return;
		}

		//identify the current wiki banner (vanilla vs plugin) and update accordingly
		if (scriptId == Script.WIKI_ICON_UPDATE)
		{
			manager.updateWikiBanner(config.hideWiki());
		}

		if (scriptId == Script.WORLD_MAP_UPDATE && manager.hideWorldMap)
		{
			widgetManager.remapTarget(Orbs.WORLD_MAP_CONTAINER, manager.isMinimapHidden() && manager.isResized());
			return;
		}

		manager.init(scriptId);
	}

	@Subscribe
	public void onVarbitChanged(VarbitChanged event)
	{
		int id = event.getVarbitId();

		if (id == Varbit.MINIMAP_TOGGLE)
		{
			manager.updateCustomChildren(true);
		}
	}

	@Subscribe
	public void onWidgetLoaded(WidgetLoaded event)
	{
		int id = event.getGroupId();

		if (id == WidgetManager.getInterfaceId(Orb.UNIVERSE) ||
			id == WidgetManager.getInterfaceId(Classic.ORBS) ||
			id == WidgetManager.getInterfaceId(Modern.ORBS))
		{
			manager.init(Script.FORCE_UPDATE);
			manager.configureMinimapOverlayContainer(true);
		}
	}

	@Subscribe
	public void onConfigChanged(ConfigChanged event)
	{
		String group = event.getGroup();
		String key = event.getKey();

		if (!group.equals(GROUP_NAME))
		{
			return;
		}

		SlotLayout slotLayout = Slot.getSlotByConfigKey(event.getKey());
		if (slotLayout != null)
		{
			clientThread.invokeLater(() ->
				slotManager.applySlotSwap(slotLayout.getSlot(), slotLayout.getLayout())
			);
			return;
		}

		switch (key)
		{
			case ConfigKeys.MINIMAP:
			case ConfigKeys.COMPASS:
			case ConfigKeys.HOTKEY_TOGGLE:
			case ConfigKeys.HOTKEY_MINIMAP:
				//do nothing (prevent default behaviour)
				break;

			case ConfigKeys.MINIMAP_BUTTON_PLACEMENT:
				clientThread.invokeLater(manager::updateMinimapToggleButton);
				break;

			case ConfigKeys.MINIMAP_TOGGLE_BUTTON:
			case ConfigKeys.COMPASS_TOGGLE_BUTTON:
				if (!manager.isLoggedIn())
				{
					return;
				}

				clientThread.invokeLater(() -> manager.updateCustomChildren(true));
				break;

			//update all slots
			case ConfigKeys.ENABLE_ORB_SWAPPING:
				clientThread.invoke(() -> slotManager.generateSlots(true));
				break;

			case ConfigKeys.ORB_LAYOUT:
			case ConfigKeys.HORIZONTAL:
			case ConfigKeys.VERTICAL:
				clientThread.invokeLater(() -> manager.init(Script.FORCE_UPDATE));
				break;

			case ConfigKeys.ENABLE_MINIMAP_OVERLAY:
				clientThread.invokeLater(() -> manager.updateMinimapOverlayVisibility());
				break;

			default:
				clientThread.invokeLater(() ->
				{
					manager.updateOrbByConfig(event.getKey());

					//return early if not logged in
					if (!manager.isLoggedIn())
					{
						return;
					}

					//when in compact layouts
					if (manager.isCompactMode())
					{
						//update the orbs positions when hiding/showing
						widgetManager.remapTargets(true, Script.FORCE_UPDATE, Orbs.values());

						//update the compass positions - to enable repositioning based on hidden/shown orbs
						widgetManager.remapTargets(true, Script.FORCE_UPDATE, Compass.values());

						//update custom children
						manager.updateCompassFrameChild();
						manager.updateCompassToggleButton();
						manager.updateMinimapToggleButton();
					}
				});
				break;
		}
	}

	//register all orb hiding toggles on startup
	public void registerOrbToggleEntries()
	{
		manager.registerOrbToggle(ConfigKeys.HIDE_HP, config::hideHp, Orbs.HP_ORB_CONTAINER);
		manager.registerOrbToggle(ConfigKeys.HIDE_PRAYER, config::hidePray, Orbs.PRAYER_ORB_CONTAINER);
		manager.registerOrbToggle(ConfigKeys.HIDE_RUN, config::hideRun, Orbs.RUN_ORB_CONTAINER);
		manager.registerOrbToggle(ConfigKeys.HIDE_SPEC, config::hideSpec, Orbs.SPEC_ORB_CONTAINER);
		manager.registerOrbToggle(ConfigKeys.HIDE_XP, config::hideXp, Orbs.XP_DROPS_CONTAINER);
		manager.registerOrbToggle(ConfigKeys.HIDE_ACTIVITY, config::hideActivity, Orbs.ACTIVITY_ORB_CONTAINER);
		manager.registerOrbToggle(ConfigKeys.HIDE_STORE, config::hideStore, Orbs.STORE_ORB_CONTAINER);
		manager.registerOrbToggle(ConfigKeys.HIDE_LOGOUT_X, config::hideLogout, Orbs.LOGOUT_X_ICON, Orbs.LOGOUT_X_STONE);
		manager.registerOrbToggle(ConfigKeys.HIDE_GRID, config::hideGrid, Orbs.GRID_MASTER_ORB_CONTAINER);
		manager.registerOrbToggle(ConfigKeys.HIDE_WORLD, config::hideWorld, Orbs.WORLD_MAP_CONTAINER);
		manager.registerOrbToggle(ConfigKeys.HIDE_WIKI, config::hideWiki, Orbs.WIKI_VANILLA_GRAPHIC, Orbs.WIKI_VANILLA_CONTAINER, Orbs.WIKI_ICON_CONTAINER);
	}

	private final HotkeyListener hotkeyListener = new HotkeyListener(() -> config.toggleButtonHotkey())
	{
		@Override
		public void hotkeyPressed()
		{
			//prevent hotkey in fixed mode
			if (!manager.isResized())
			{
				return;
			}

			if (config.minimapHotkey())
			{
				clientThread.invokeLater(manager::onMinimapToggle);
				return;
			}

			boolean hidden = !(config.hideMinimapToggle() || config.hideCompassToggle());

			configManager.setConfiguration(GROUP_NAME, ConfigKeys.MINIMAP_TOGGLE_BUTTON, hidden);
			configManager.setConfiguration(GROUP_NAME, ConfigKeys.COMPASS_TOGGLE_BUTTON, hidden);

			clientThread.invokeLater(() -> manager.updateCustomChildren(true));
		}
	};

	@Provides
	CompactOrbsConfig provideConfig(ConfigManager configManager)
	{
		return configManager.getConfig(CompactOrbsConfig.class);
	}
}

/*
 * Copyright (c) 2025, cue <https://github.com/its-cue>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

package com.compactorbs.util;

import lombok.Getter;

@Getter
public class SetValue
{
	private final Integer original;
	private final Integer[] modified;

	public SetValue(Integer original, Integer... modified)
	{
		this.original = original;
		this.modified = modified;
	}

	//same function as before, but should allow for multiple 'modified sets' (original, mod_vertical, mod_horizontal, etc) instead of just 1
	public Integer get(boolean compactLayout, int index)
	{
		if (!compactLayout || original == null)
		{
			return original;
		}

		if (modified != null && modified.length > 0)
		{
			if (index >= 0 && index < modified.length && modified[index] != null)
			{
				return modified[index];
			}
			return modified[0];
		}

		return original;
	}

}

/*
 * Copyright (c) 2025, cue <https://github.com/its-cue>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

package com.compactorbs.util;

public enum ValueKey
{
	X,
	Y,
	WIDTH,
	HEIGHT,
	X_POSITION_MODE,
	Y_POSITION_MODE,
	WIDTH_MODE,
	HEIGHT_MODE

}

/*
 * Copyright (c) 2025, cue <https://github.com/its-cue>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

package com.compactorbs.widget.elements;

import com.compactorbs.CompactOrbsConstants.Layout;
import com.compactorbs.CompactOrbsConstants.Layout.Original;
import com.compactorbs.CompactOrbsConstants.Layout.Vertical;
import com.compactorbs.CompactOrbsConstants.Layout.Horizontal;
import com.compactorbs.CompactOrbsConstants.Widgets.Classic;
import com.compactorbs.CompactOrbsConstants.Widgets.Modern;
import com.compactorbs.util.SetValue;
import com.compactorbs.util.ValueKey;
import static com.compactorbs.util.ValueKey.X;
import static com.compactorbs.util.ValueKey.Y;
import com.compactorbs.widget.TargetWidget;
import java.util.Map;
import lombok.Getter;
import lombok.RequiredArgsConstructor;

@Getter
@RequiredArgsConstructor
public enum Compass implements TargetWidget
{
	CLASSIC_COMPASS(
		Classic.COMPASS,
		Map.of(
			X, new SetValue(
				Original.COMPASS_X,
				Vertical.COMPASS_X,
				Horizontal.COMPASS_X
			),
			Y, new SetValue(
				Original.COMPASS_Y,
				Vertical.COMPASS_Y,
				Horizontal.COMPASS_Y
			)
		)
	),
	CLASSIC_COMPASS_OPTIONS(
		Classic.COMPASS_OPTIONS,
		Map.of(
			X, new SetValue(
				Original.COMPASS_X - Layout.COMPASS_OPTIONS_OFFSET,
				Vertical.COMPASS_X - Layout.COMPASS_OPTIONS_OFFSET,
				Horizontal.COMPASS_X - Layout.COMPASS_OPTIONS_OFFSET
			),
			Y, new SetValue(
				Original.COMPASS_Y - Layout.COMPASS_OPTIONS_OFFSET,
				Vertical.COMPASS_Y - Layout.COMPASS_OPTIONS_OFFSET,
				Horizontal.COMPASS_Y - Layout.COMPASS_OPTIONS_OFFSET
			)
		)
	),

	MODERN_COMPASS(
		Modern.COMPASS,
		Map.of(
			X, new SetValue(
				Original.COMPASS_X,
				Vertical.COMPASS_X,
				Horizontal.COMPASS_X
			),
			Y, new SetValue(
				Original.COMPASS_Y,
				Vertical.COMPASS_Y,
				Horizontal.COMPASS_Y
			)
		)
	),
	MODERN_COMPASS_OPTIONS(
		Modern.COMPASS_OPTIONS,
		Map.of(
			X, new SetValue(
				Original.COMPASS_X - Layout.COMPASS_OPTIONS_OFFSET,
				Vertical.COMPASS_X - Layout.COMPASS_OPTIONS_OFFSET,
				Horizontal.COMPASS_X - Layout.COMPASS_OPTIONS_OFFSET
			),
			Y, new SetValue(
				Original.COMPASS_Y - Layout.COMPASS_OPTIONS_OFFSET,
				Vertical.COMPASS_Y - Layout.COMPASS_OPTIONS_OFFSET,
				Horizontal.COMPASS_Y - Layout.COMPASS_OPTIONS_OFFSET
			)
		)
	);

	private final int componentId;

	private final Map<ValueKey, SetValue> valueMap;

}

/*
 * Copyright (c) 2025, cue <https://github.com/its-cue>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

package com.compactorbs.widget.elements;

import com.compactorbs.CompactOrbsConstants.Widgets.Classic;
import com.compactorbs.CompactOrbsConstants.Widgets.Modern;
import com.compactorbs.util.SetValue;
import com.compactorbs.util.ValueKey;
import com.compactorbs.widget.TargetWidget;
import java.util.Map;
import lombok.Getter;
import lombok.RequiredArgsConstructor;

@Getter
@RequiredArgsConstructor
public enum Minimap implements TargetWidget
{
	//classic-resizable
	CLASSIC_NO_CLICK_0(Classic.MAP_NOCLICK_0),
	CLASSIC_NO_CLICK_1(Classic.MAP_NOCLICK_1),
	CLASSIC_NO_CLICK_2(Classic.MAP_NOCLICK_2),
	CLASSIC_NO_CLICK_3(Classic.MAP_NOCLICK_3),
	CLASSIC_NO_CLICK_4(Classic.MAP_NOCLICK_4),
	CLASSIC_NO_CLICK_5(Classic.MAP_NOCLICK_5),
	CLASSIC_MINIMAP_MASK(Classic.MINIMAP_MASK),
	CLASSIC_MINIMAP(Classic.MINIMAP),

	//modern-resizable
	MODERN_NO_CLICK_0(Modern.MAP_NOCLICK_0),
	MODERN_NO_CLICK_1(Modern.MAP_NOCLICK_1),
	MODERN_NO_CLICK_2(Modern.MAP_NOCLICK_2),
	MODERN_NO_CLICK_3(Modern.MAP_NOCLICK_3),
	MODERN_NO_CLICK_4(Modern.MAP_NOCLICK_4),
	MODERN_NO_CLICK_5(Modern.MAP_NOCLICK_5),
	MODERN_MINIMAP_MASK(Modern.MINIMAP_MASK),
	MODERN_MINIMAP(Modern.MINIMAP);

	private final int componentId;

	private final Map<ValueKey, SetValue> valueMap;

	Minimap(int componentId)
	{
		this(componentId, Map.of());
	}

}

/*
 * Copyright (c) 2025, cue <https://github.com/its-cue>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

package com.compactorbs.widget.elements;

import com.compactorbs.CompactOrbsConstants.Layout.Horizontal;
import com.compactorbs.CompactOrbsConstants.Layout.Original;
import com.compactorbs.CompactOrbsConstants.Layout.Vertical;
import com.compactorbs.CompactOrbsConstants.Script;
import com.compactorbs.CompactOrbsConstants.Widgets.Modern;
import com.compactorbs.CompactOrbsConstants.Widgets.Orb;
import com.compactorbs.util.SetValue;
import com.compactorbs.util.ValueKey;
import static com.compactorbs.util.ValueKey.X;
import static com.compactorbs.util.ValueKey.X_POSITION_MODE;
import static com.compactorbs.util.ValueKey.Y;
import static com.compactorbs.util.ValueKey.Y_POSITION_MODE;
import com.compactorbs.widget.TargetWidget;
import java.util.EnumSet;
import java.util.Map;
import java.util.Set;
import lombok.Getter;
import lombok.RequiredArgsConstructor;
import net.runelite.api.widgets.WidgetPositionMode;

@Getter
@RequiredArgsConstructor
public enum Orbs implements TargetWidget
{
	XP_DROPS_CONTAINER(
		Orb.XP_DROPS,
		Map.of(
			X, new SetValue(
				Original.XP_DROPS_X,
				Vertical.XP_DROPS_X,
				Horizontal.XP_DROPS_X
			),
			Y, new SetValue(
				Original.XP_DROPS_Y,
				Vertical.XP_DROPS_Y,
				Horizontal.XP_DROPS_Y
			),
			X_POSITION_MODE, new SetValue(
				WidgetPositionMode.ABSOLUTE_LEFT,
				WidgetPositionMode.ABSOLUTE_RIGHT,
				WidgetPositionMode.ABSOLUTE_LEFT
			)
		)
	),
	HP_ORB_CONTAINER(
		Orb.HP_ORB,
		Map.of(
			X, new SetValue(
				Original.HP_ORB_X,
				Vertical.HP_ORB_X,
				Horizontal.HP_ORB_X
			),
			Y, new SetValue(
				Original.HP_ORB_Y,
				Vertical.HP_ORB_Y,
				Horizontal.HP_ORB_Y
			),
			X_POSITION_MODE, new SetValue(
				WidgetPositionMode.ABSOLUTE_LEFT,
				WidgetPositionMode.ABSOLUTE_RIGHT,
				WidgetPositionMode.ABSOLUTE_LEFT
			)
		)
	),
	PRAYER_ORB_CONTAINER(
		Orb.PRAY_ORB,
		Map.of(
			X, new SetValue(
				Original.PRAYER_ORB_X,
				Vertical.PRAYER_ORB_X,
				Horizontal.PRAYER_ORB_X
			),
			Y, new SetValue(
				Original.PRAYER_ORB_Y,
				Vertical.PRAYER_ORB_Y,
				Horizontal.PRAYER_ORB_Y
			),
			X_POSITION_MODE, new SetValue(
				WidgetPositionMode.ABSOLUTE_LEFT,
				WidgetPositionMode.ABSOLUTE_RIGHT,
				WidgetPositionMode.ABSOLUTE_LEFT
			)
		)
	),
	RUN_ORB_CONTAINER(
		Orb.RUN_ORB,
		Map.of(
			X, new SetValue(
				Original.RUN_ORB_X,
				Vertical.RUN_ORB_X,
				Horizontal.RUN_ORB_X),
			Y, new SetValue(
				Original.RUN_ORB_Y,
				Vertical.RUN_ORB_Y,
				Horizontal.RUN_ORB_Y
			),
			X_POSITION_MODE, new SetValue(
				WidgetPositionMode.ABSOLUTE_LEFT,
				WidgetPositionMode.ABSOLUTE_RIGHT,
				WidgetPositionMode.ABSOLUTE_LEFT
			)
		)
	),
	SPEC_ORB_CONTAINER(
		Orb.SPEC_ORB,
		Map.of(
			X, new SetValue(
				Original.SPEC_ORB_X,
				Vertical.SPEC_ORB_X,
				Horizontal.SPEC_ORB_X
			),
			Y, new SetValue(
				Original.SPEC_ORB_Y,
				Vertical.SPEC_ORB_Y,
				Horizontal.SPEC_ORB_Y
			),
			X_POSITION_MODE, new SetValue(
				WidgetPositionMode.ABSOLUTE_LEFT,
				WidgetPositionMode.ABSOLUTE_RIGHT,
				WidgetPositionMode.ABSOLUTE_LEFT
			)
		)
	),
	STORE_ORB_CONTAINER(
		Orb.STORE_ORB,
		Script.STORE_ORB_UPDATE,
		Map.of(
			X, new SetValue(
				Original.STORE_ORB_X,
				Vertical.STORE_ORB_X,
				Horizontal.STORE_ORB_X
			),
			Y, new SetValue(
				Original.STORE_ORB_Y,
				Vertical.STORE_ORB_Y,
				Horizontal.STORE_ORB_Y
			),
			X_POSITION_MODE, new SetValue(
				WidgetPositionMode.ABSOLUTE_LEFT,
				WidgetPositionMode.ABSOLUTE_RIGHT,
				WidgetPositionMode.ABSOLUTE_LEFT
			)
		)
	),
	ACTIVITY_ORB_CONTAINER(
		Orb.ACTIVITY_ORB,
		Script.ACTIVITY_ORB_UPDATE,
		Map.of(
			X, new SetValue(
				Original.ACTIVITY_ORB_X,
				Vertical.ACTIVITY_ORB_X,
				Horizontal.ACTIVITY_ORB_X
			),
			Y, new SetValue(
				Original.ACTIVITY_ORB_Y,
				Vertical.ACTIVITY_ORB_Y,
				Horizontal.ACTIVITY_ORB_Y
			),
			X_POSITION_MODE, new SetValue(
				WidgetPositionMode.ABSOLUTE_LEFT,
				WidgetPositionMode.ABSOLUTE_RIGHT,
				WidgetPositionMode.ABSOLUTE_LEFT
			)
		)
	),
	WORLD_MAP_CONTAINER(
		Orb.WORLD_MAP,
		Script.WORLD_MAP_UPDATE,
		Map.of(
			X, new SetValue(
				Original.WORLD_MAP_X,
				Vertical.WORLD_MAP_X,
				Horizontal.WORLD_MAP_X
			),
			Y, new SetValue(
				Original.WORLD_MAP_Y,
				Vertical.WORLD_MAP_Y,
				Horizontal.WORLD_MAP_Y
			)
		)
	),
	//wiki plugin banner is child 0, otherwise it's the main container
	WIKI_ICON_CONTAINER(
		Orb.WIKI_ICON,
		Script.WIKI_ICON_UPDATE,
		Map.of(
			X, new SetValue(
				Original.WIKI_ICON_X,
				Vertical.WIKI_ICON_X,
				Horizontal.WIKI_ICON_X
			),
			Y, new SetValue(
				Original.WIKI_ICON_Y,
				Vertical.WIKI_ICON_Y,
				Horizontal.WIKI_ICON_Y
			),
			X_POSITION_MODE, new SetValue(
				WidgetPositionMode.ABSOLUTE_RIGHT,
				WidgetPositionMode.ABSOLUTE_RIGHT,
				WidgetPositionMode.ABSOLUTE_LEFT
			),
			Y_POSITION_MODE, new SetValue(
				WidgetPositionMode.ABSOLUTE_TOP,
				WidgetPositionMode.ABSOLUTE_TOP,
				WidgetPositionMode.ABSOLUTE_TOP
			)
		)
	),
	WIKI_VANILLA_CONTAINER(
		Orb.WIKI_CONTAINER_VANILLA,
		Script.WIKI_ICON_UPDATE,
		Map.of(
			X, new SetValue(
				Original.WIKI_VANILLA_X,
				Vertical.WIKI_VANILLA_X,
				Horizontal.WIKI_VANILLA_X
			),
			Y, new SetValue(
				Original.WIKI_VANILLA_Y,
				Vertical.WIKI_VANILLA_Y,
				Horizontal.WIKI_VANILLA_Y
			),
			X_POSITION_MODE, new SetValue(
				WidgetPositionMode.ABSOLUTE_CENTER,
				WidgetPositionMode.ABSOLUTE_RIGHT,
				WidgetPositionMode.ABSOLUTE_LEFT
			),
			Y_POSITION_MODE, new SetValue(
				WidgetPositionMode.ABSOLUTE_CENTER,
				WidgetPositionMode.ABSOLUTE_TOP,
				WidgetPositionMode.ABSOLUTE_TOP
			)
		)
	),
	WIKI_VANILLA_GRAPHIC(
		Orb.WIKI_ICON_VANILLA,
		Script.WIKI_ICON_UPDATE,
		Map.of(
			X, new SetValue(
				Original.WIKI_VANILLA_X,
				Vertical.WIKI_VANILLA_X,
				Horizontal.WIKI_VANILLA_X
			),
			Y, new SetValue(
				Original.WIKI_VANILLA_Y,
				Vertical.WIKI_VANILLA_Y,
				Horizontal.WIKI_VANILLA_Y
			),
			X_POSITION_MODE, new SetValue(
				WidgetPositionMode.ABSOLUTE_CENTER,
				WidgetPositionMode.ABSOLUTE_RIGHT,
				WidgetPositionMode.ABSOLUTE_LEFT
			),
			Y_POSITION_MODE, new SetValue(
				WidgetPositionMode.ABSOLUTE_CENTER,
				WidgetPositionMode.ABSOLUTE_TOP,
				WidgetPositionMode.ABSOLUTE_TOP
			)
		)
	),
	LOGOUT_X_ICON(
		Modern.LOGOUT_X_ICON,
		Map.of(
			X, new SetValue(
				Original.LOGOUT_X,
				Vertical.LOGOUT_X,
				Horizontal.LOGOUT_X
			),
			Y, new SetValue(
				Original.LOGOUT_Y,
				Vertical.LOGOUT_Y,
				Horizontal.LOGOUT_Y
			)
		)
	),
	LOGOUT_X_STONE(
		Modern.LOGOUT_X_STONE,
		Map.of(
			X, new SetValue(
				Original.LOGOUT_X,
				Vertical.LOGOUT_X,
				Horizontal.LOGOUT_X
			),
			Y, new SetValue(
				Original.LOGOUT_Y,
				Vertical.LOGOUT_Y,
				Horizontal.LOGOUT_Y
			)
		)
	),
	GRID_MASTER_ORB_CONTAINER(
		Orb.UNIVERSE, 0,
		Script.GRID_MASTER_ORB_UPDATE,
		Map.of(
			X, new SetValue(
				Original.ACTIVITY_ORB_X,
				Vertical.ACTIVITY_ORB_X,
				Horizontal.ACTIVITY_ORB_X
			),
			Y, new SetValue(
				Original.ACTIVITY_ORB_Y,
				Vertical.ACTIVITY_ORB_Y,
				Horizontal.ACTIVITY_ORB_Y
			),
			X_POSITION_MODE, new SetValue(
				WidgetPositionMode.ABSOLUTE_LEFT,
				WidgetPositionMode.ABSOLUTE_RIGHT,
				WidgetPositionMode.ABSOLUTE_LEFT
			)
		)
	);

	private final int componentId, arrayId, scriptId;

	private final Map<ValueKey, SetValue> valueMap;

	Orbs(int componentId, int scriptId, Map<ValueKey, SetValue> valueMap)
	{
		this(componentId, -1, scriptId, valueMap);
	}

	Orbs(int componentId, Map<ValueKey, SetValue> valueMap)
	{
		this(componentId, -1, -1, valueMap);
	}

	//only includes widgets that require updating
	public static final Set<Orbs> FIXED = EnumSet.of(
		HP_ORB_CONTAINER,
		PRAYER_ORB_CONTAINER,
		RUN_ORB_CONTAINER,
		SPEC_ORB_CONTAINER,
		XP_DROPS_CONTAINER,
		WIKI_VANILLA_CONTAINER,
		WIKI_VANILLA_GRAPHIC
	);

	public static final Set<Orbs> SWAPPABLE_ORBS = EnumSet.of(
		HP_ORB_CONTAINER,
		PRAYER_ORB_CONTAINER,
		RUN_ORB_CONTAINER,
		SPEC_ORB_CONTAINER
	);

}

/*
 * Copyright (c) 2025, cue <https://github.com/its-cue>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

package com.compactorbs.widget.offset.impl;

import com.compactorbs.CompactOrbsManager;
import com.compactorbs.widget.elements.Orbs;
import com.compactorbs.widget.offset.OffsetTarget;
import com.compactorbs.widget.slot.SlotManager;
import lombok.Getter;

@Getter
public class ActivityOrbOffset implements OffsetTarget
{
	@Override
	public int xOffset(int value, boolean compactLayout, CompactOrbsManager manager, SlotManager slotManager)
	{
		int x = value + manager.verticalOffset;

		if (!compactLayout)
		{
			return value;
		}

		if (manager.isHorizontalLayout())
		{
			x = slotManager.applyHiddenXOffset(Orbs.ACTIVITY_ORB_CONTAINER, x);
		}

		return x;
	}

	@Override
	public int yOffset(int value, boolean compactLayout, CompactOrbsManager manager, SlotManager slotManager)
	{
		int y = value + manager.horizontalOffset;

		if (!compactLayout)
		{
			return value;
		}

		if (manager.isVerticalLayout())
		{
			y = slotManager.applyHiddenYOffset(Orbs.ACTIVITY_ORB_CONTAINER, y);
		}

		return y;
	}
}

/*
 * Copyright (c) 2025, cue <https://github.com/its-cue>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

package com.compactorbs.widget.offset.impl;

import com.compactorbs.CompactOrbsManager;
import com.compactorbs.widget.offset.OffsetTarget;
import com.compactorbs.widget.slot.SlotManager;
import lombok.Getter;

@Getter
public class CompassOffset implements OffsetTarget
{
	private int offsetX;

	private int offsetY;

	@Override
	public int xOffset(int value, boolean compactLayout, CompactOrbsManager manager, SlotManager slotManager)
	{
		int x = value - manager.verticalOffset;

		if (!compactLayout)
		{
			return value;
		}

		if (manager.isHorizontalLayout()
			&& manager.isVerticalLeft())
		{
			int hiddenWidth = slotManager.getHorizontalHiddenWidth();
			x -= hiddenWidth;

			if (hiddenWidth >= 148) //sum of hidden width, in horizontal mode
			{
				x += 2; //small offset to avoid full left cut-off
			}
		}

		offsetX = x;
		return offsetX;
	}

	@Override
	public int yOffset(int value, boolean compactLayout, CompactOrbsManager manager, SlotManager slotManager)
	{
		int y = value + manager.horizontalOffset;

		if (!compactLayout)
		{
			return value;
		}

		if (manager.isVerticalLayout()
			&& manager.isHorizontalBottom())
		{
			int hiddenHeight = slotManager.getVerticalHiddenHeight();
			y += hiddenHeight;

		}

		offsetY = y;
		return offsetY;
	}
}

/*
 * Copyright (c) 2025, cue <https://github.com/its-cue>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

package com.compactorbs.widget.offset.impl;

import com.compactorbs.CompactOrbsManager;
import com.compactorbs.widget.elements.Orbs;
import com.compactorbs.widget.offset.OffsetTarget;
import com.compactorbs.widget.slot.SlotManager;
import lombok.Getter;

@Getter
public class HPOrbOffset implements OffsetTarget
{
	@Override
	public int xOffset(int value, boolean compactLayout, CompactOrbsManager manager, SlotManager slotManager)
	{
		int x = value + manager.verticalOffset;

		if (!compactLayout)
		{
			return value;
		}

		if (manager.isHorizontalLayout())
		{
			x = slotManager.applyHiddenXOffset(Orbs.HP_ORB_CONTAINER, x);
		}

		return x;
	}

	@Override
	public int yOffset(int value, boolean compactLayout, CompactOrbsManager manager, SlotManager slotManager)
	{
		int y = value + manager.horizontalOffset;

		if (!compactLayout)
		{
			return value;
		}

		if (manager.isVerticalLayout())
		{
			y = slotManager.applyHiddenYOffset(Orbs.HP_ORB_CONTAINER, y);
		}

		return y;
	}
}

/*
 * Copyright (c) 2025, cue <https://github.com/its-cue>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

package com.compactorbs.widget.offset.impl;

import com.compactorbs.CompactOrbsManager;
import com.compactorbs.widget.offset.OffsetTarget;
import com.compactorbs.widget.slot.SlotManager;
import lombok.Getter;

@Getter
public class LogoutXOffset implements OffsetTarget
{
	@Override
	public int xOffset(int value, boolean compactLayout, CompactOrbsManager manager, SlotManager slotManager)
	{
		int x = value + manager.verticalOffset;

		if (!compactLayout)
		{
			return value;
		}

		if (manager.isHorizontalLayout()
			&& manager.isVerticalLeft())
		{
			int hiddenWidth = slotManager.getHorizontalHiddenWidth();
			x += hiddenWidth;
		}

		return x;
	}

	@Override
	public int yOffset(int value, boolean compactLayout, CompactOrbsManager manager, SlotManager slotManager)
	{
		int y = value + manager.horizontalOffset;

		if (!compactLayout)
		{
			return value;
		}

		if (manager.isVerticalLayout()
			&& manager.isHorizontalBottom())
		{
			int hiddenHeight = slotManager.getVerticalHiddenHeight();
			y += hiddenHeight;
		}

		//maybe just let it bypass - !manager.preventOrbReordering()
		if (manager.isHorizontalLayout())
		{
			if (manager.isXpDropHidden() || manager.hideWorldMap)
			{
				y += 19;
			}
		}

		return y;
	}
}

/*
 * Copyright (c) 2025, cue <https://github.com/its-cue>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

package com.compactorbs.widget.offset.impl;

import com.compactorbs.CompactOrbsManager;
import com.compactorbs.widget.elements.Orbs;
import com.compactorbs.widget.offset.OffsetTarget;
import com.compactorbs.widget.slot.SlotManager;
import lombok.Getter;

@Getter
public class PrayerOrbOffset implements OffsetTarget
{
	@Override
	public int xOffset(int value, boolean compactLayout, CompactOrbsManager manager, SlotManager slotManager)
	{
		int x = value + manager.verticalOffset;

		if (!compactLayout)
		{
			return value;
		}

		if (manager.isHorizontalLayout())
		{
			x = slotManager.applyHiddenXOffset(Orbs.PRAYER_ORB_CONTAINER, x);
		}

		return x;
	}

	@Override
	public int yOffset(int value, boolean compactLayout, CompactOrbsManager manager, SlotManager slotManager)
	{
		int y = value + manager.horizontalOffset;

		if (!compactLayout)
		{
			return value;
		}

		if (manager.isVerticalLayout())
		{
			y = slotManager.applyHiddenYOffset(Orbs.PRAYER_ORB_CONTAINER, y);
		}

		return y;
	}
}

/*
 * Copyright (c) 2025, cue <https://github.com/its-cue>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

package com.compactorbs.widget.offset.impl;

import com.compactorbs.CompactOrbsManager;
import com.compactorbs.widget.elements.Orbs;
import com.compactorbs.widget.offset.OffsetTarget;
import com.compactorbs.widget.slot.SlotManager;
import lombok.Getter;

@Getter
public class RunOrbOffset implements OffsetTarget
{
	@Override
	public int xOffset(int value, boolean compactLayout, CompactOrbsManager manager, SlotManager slotManager)
	{
		int x = value + manager.verticalOffset;

		if (!compactLayout)
		{
			return value;
		}

		if (manager.isHorizontalLayout())
		{
			x = slotManager.applyHiddenXOffset(Orbs.RUN_ORB_CONTAINER, x);
		}

		return x;
	}

	@Override
	public int yOffset(int value, boolean compactLayout, CompactOrbsManager manager, SlotManager slotManager)
	{
		int y = value + manager.horizontalOffset;

		if (!compactLayout)
		{
			return value;
		}

		if (manager.isVerticalLayout())
		{
			y = slotManager.applyHiddenYOffset(Orbs.RUN_ORB_CONTAINER, y);
		}

		return y;
	}
}

/*
 * Copyright (c) 2025, cue <https://github.com/its-cue>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

package com.compactorbs.widget.offset.impl;

import com.compactorbs.CompactOrbsManager;
import com.compactorbs.widget.elements.Orbs;
import com.compactorbs.widget.offset.OffsetTarget;
import com.compactorbs.widget.slot.SlotManager;
import lombok.Getter;

@Getter
public class SpecOrbOffset implements OffsetTarget
{
	@Override
	public int xOffset(int value, boolean compactLayout, CompactOrbsManager manager, SlotManager slotManager)
	{
		int x = value + manager.verticalOffset;

		if (!compactLayout)
		{
			return value;
		}

		if (manager.isHorizontalLayout())
		{
			x = slotManager.applyHiddenXOffset(Orbs.SPEC_ORB_CONTAINER, x);
		}

		return x;
	}

	@Override
	public int yOffset(int value, boolean compactLayout, CompactOrbsManager manager, SlotManager slotManager)
	{
		int y = value + manager.horizontalOffset;

		if (!compactLayout)
		{
			return value;
		}

		if (manager.isVerticalLayout())
		{
			y = slotManager.applyHiddenYOffset(Orbs.SPEC_ORB_CONTAINER, y);
		}

		return y;
	}
}

/*
 * Copyright (c) 2025, cue <https://github.com/its-cue>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

package com.compactorbs.widget.offset.impl;

import com.compactorbs.CompactOrbsManager;
import com.compactorbs.widget.elements.Orbs;
import com.compactorbs.widget.offset.OffsetTarget;
import com.compactorbs.widget.slot.SlotManager;
import lombok.Getter;

@Getter
public class StoreOrbOffset implements OffsetTarget
{
	@Override
	public int xOffset(int value, boolean compactLayout, CompactOrbsManager manager, SlotManager slotManager)
	{
		int x = value + manager.verticalOffset;

		if (!compactLayout)
		{
			return value;
		}

		if (manager.isHorizontalLayout())
		{
			x = slotManager.applyHiddenXOffset(Orbs.STORE_ORB_CONTAINER, x);
		}
		return x;
	}

	@Override
	public int yOffset(int value, boolean compactLayout, CompactOrbsManager manager, SlotManager slotManager)
	{
		int y = value + manager.horizontalOffset;

		if (!compactLayout)
		{
			return value;
		}

		if (manager.isVerticalLayout())
		{
			y = slotManager.applyHiddenYOffset(Orbs.STORE_ORB_CONTAINER, y);
		}

		return y;
	}
}

/*
 * Copyright (c) 2025, cue <https://github.com/its-cue>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

package com.compactorbs.widget.offset.impl;

import com.compactorbs.CompactOrbsManager;
import com.compactorbs.widget.elements.Orbs;
import com.compactorbs.widget.offset.OffsetTarget;
import com.compactorbs.widget.slot.Slot;
import com.compactorbs.widget.slot.SlotManager;
import lombok.Getter;

@Getter
public class WikiContainerOffset implements OffsetTarget
{
	@Override
	public int xOffset(int value, boolean compactLayout, CompactOrbsManager manager, SlotManager slotManager)
	{
		int x = value + manager.verticalOffset;

		if (!compactLayout)
		{
			return value;
		}

		if (manager.isHorizontalLayout()
			&& manager.isVerticalLeft())
		{
			int hiddenWidth = slotManager.getHorizontalHiddenWidth();
			x -= hiddenWidth;
		}

		return x;
	}

	@Override
	public int yOffset(int value, boolean compactLayout, CompactOrbsManager manager, SlotManager slotManager)
	{
		int y = value + manager.horizontalOffset;

		if (!compactLayout)
		{
			return value;
		}

		if (manager.isVerticalLayout())
		{
			y = slotManager.applyHiddenYOffset(Orbs.WIKI_ICON_CONTAINER, y);

			if (manager.isHorizontalTop())
			{
				//apply an offset when the amount hidden, leaves wiki slot as the last
				//0-HP, 1-Pray, 2-Run, 3-Spec, 4-Wiki
				if (slotManager.getHiddenCountAbove(Orbs.WIKI_ICON_CONTAINER) == Slot.VERTICAL_RIGHT_COLUMN.indexOf(Slot.WIKI_SLOT)
					&& !manager.preventReordering())
				{
					y += 10;
				}
			}
		}

		return y;
	}
}

/*
 * Copyright (c) 2025, cue <https://github.com/its-cue>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

package com.compactorbs.widget.offset.impl;

import com.compactorbs.CompactOrbsManager;
import com.compactorbs.widget.offset.OffsetTarget;
import com.compactorbs.widget.slot.SlotManager;
import lombok.Getter;

@Getter
public class WikiOffset implements OffsetTarget
{
	@Override
	public int xOffset(int value, boolean compactLayout, CompactOrbsManager manager, SlotManager slotManager)
	{
		return value;
	}

	@Override
	public int yOffset(int value, boolean compactLayout, CompactOrbsManager manager, SlotManager slotManager)
	{
		return value;
	}
}

/*
 * Copyright (c) 2025, cue <https://github.com/its-cue>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

package com.compactorbs.widget.offset.impl;

import com.compactorbs.CompactOrbsManager;
import com.compactorbs.widget.offset.OffsetTarget;
import com.compactorbs.widget.slot.SlotManager;
import lombok.Getter;

@Getter
public class WikiVanillaOffset implements OffsetTarget
{
	@Override
	public int xOffset(int value, boolean compactLayout, CompactOrbsManager manager, SlotManager slotManager)
	{
		int x = 0;

		if (!compactLayout)
		{
			return value;
		}

		//graphic icon should be at the top of the container, x0
		//to help prevent overlapping menu options with other elements
		//during compact layouts
		return x;
	}

	@Override
	public int yOffset(int value, boolean compactLayout, CompactOrbsManager manager, SlotManager slotManager)
	{
		int y = 0;

		if (!compactLayout)
		{
			return value;
		}

		//graphic icon should be at the top of the container, y0
		//to help prevent overlapping menu options with other elements
		//during compact layouts
		return y;
	}
}

/*
 * Copyright (c) 2025, cue <https://github.com/its-cue>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

package com.compactorbs.widget.offset.impl;

import com.compactorbs.CompactOrbsConstants;
import com.compactorbs.CompactOrbsManager;
import com.compactorbs.widget.elements.Orbs;
import com.compactorbs.widget.offset.OffsetTarget;
import com.compactorbs.widget.slot.SlotManager;
import lombok.Getter;

@Getter
public class WorldMapOffset implements OffsetTarget
{
	@Override
	public int xOffset(int value, boolean compactLayout, CompactOrbsManager manager, SlotManager slotManager)
	{
		int x = CompactOrbsConstants.Layout.FIXED_WORLD_MAP_X;
		int v = value;

		if (!compactLayout)
		{
			v = (manager.updateWorldMap()
				? manager.getWorldMapOffset() : !manager.isResized()
				? x : v
			);

			return v;
		}

		if (manager.hideWorldMap)
		{
			return manager.getWorldMapOffset();
		}

		v = v + manager.verticalOffset;

		if (manager.isHorizontalLayout()
			&& manager.isVerticalLeft())
		{
			int hiddenWidth = slotManager.getHorizontalHiddenWidth();
			v += hiddenWidth;
		}

		return v + manager.getWorldMapOffset();
	}

	@Override
	public int yOffset(int value, boolean compactLayout, CompactOrbsManager manager, SlotManager slotManager)
	{
		int y = CompactOrbsConstants.Layout.FIXED_WORLD_MAP_Y;

		int v = value;

		if (!compactLayout)
		{
			v = (manager.updateWorldMap()
				? manager.getWorldMapOffset() : !manager.isResized()
				? y : v
			);

			return v;
		}

		if (manager.hideWorldMap)
		{
			return manager.getWorldMapOffset();
		}

		y = v + manager.horizontalOffset;

		if (manager.isVerticalLayout())
		{
			y = slotManager.applyHiddenYOffset(Orbs.WORLD_MAP_CONTAINER, y);
		}

		return y + manager.getWorldMapOffset();
	}
}

/*
 * Copyright (c) 2025, cue <https://github.com/its-cue>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

package com.compactorbs.widget.offset.impl;

import com.compactorbs.CompactOrbsManager;
import com.compactorbs.widget.elements.Orbs;
import com.compactorbs.widget.offset.OffsetTarget;
import com.compactorbs.widget.slot.SlotManager;
import lombok.Getter;

@Getter
public class XPOrbOffset implements OffsetTarget
{
	@Override
	public int xOffset(int value, boolean compactLayout, CompactOrbsManager manager, SlotManager slotManager)
	{
		int x = value + manager.verticalOffset;

		if (!compactLayout)
		{
			return value;
		}

		if (manager.isHorizontalLayout())
		{
			if (manager.isVerticalLeft())
			{
				int hiddenWidth = slotManager.getHorizontalHiddenWidth();
				x -= hiddenWidth;
			}

			if (manager.hideWorldMap)
			{
				x -= 31;
			}
		}

		return x;
	}

	@Override
	public int yOffset(int value, boolean compactLayout, CompactOrbsManager manager, SlotManager slotManager)
	{
		int y = value + manager.horizontalOffset;

		if (!compactLayout)
		{
			return value;
		}

		if (manager.isVerticalLayout())
		{
			y = slotManager.applyHiddenYOffset(Orbs.XP_DROPS_CONTAINER, y);
		}

		if (manager.isHorizontalLayout())
		{
			if (manager.hideWorldMap)
			{
				y -= 6;
			}
		}

		return y;
	}
}

/*
 * Copyright (c) 2025, cue <https://github.com/its-cue>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

package com.compactorbs.widget.offset;

import com.compactorbs.CompactOrbsManager;
import com.compactorbs.util.ValueKey;
import com.compactorbs.widget.slot.SlotManager;
import net.runelite.api.widgets.Widget;

public class OffsetManager
{
	public static int getTargetOffset(Widget widget, ValueKey valueKey, int value, boolean compactLayout, CompactOrbsManager manager, SlotManager slotManager)
	{
		OffsetTarget offsetTarget = getTarget(widget);
		if (offsetTarget == null)
		{
			return getDefault(valueKey, value, compactLayout, manager.verticalOffset, manager.horizontalOffset);
		}

		return getOffset(offsetTarget, valueKey, value, compactLayout, manager, slotManager);
	}

	private static OffsetTarget getTarget(Widget widget)
	{
		Offsets offsets = Offsets.fromWidget(widget);
		return offsets != null ? offsets.offsetTarget() : null;
	}

	private static int getDefault(ValueKey valueKey, int value, boolean compactLayout, int xOffset, int yOffset)
	{
		if (!compactLayout)
		{
			return value;
		}
		return value + (valueKey == ValueKey.X ? xOffset : yOffset);
	}

	private static int getOffset(OffsetTarget target, ValueKey key, int value, boolean compactLayout, CompactOrbsManager manager, SlotManager slotManager)
	{
		return key == ValueKey.X
			? target.xOffset(value, compactLayout, manager, slotManager)
			: target.yOffset(value, compactLayout, manager, slotManager);
	}
}

/*
 * Copyright (c) 2025, cue <https://github.com/its-cue>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

package com.compactorbs.widget.offset;

import com.compactorbs.CompactOrbsConstants.Widgets.Classic;
import com.compactorbs.CompactOrbsConstants.Widgets.Modern;
import com.compactorbs.widget.elements.Orbs;
import com.compactorbs.widget.offset.impl.ActivityOrbOffset;
import com.compactorbs.widget.offset.impl.CompassOffset;
import com.compactorbs.widget.offset.impl.HPOrbOffset;
import com.compactorbs.widget.offset.impl.LogoutXOffset;
import com.compactorbs.widget.offset.impl.PrayerOrbOffset;
import com.compactorbs.widget.offset.impl.RunOrbOffset;
import com.compactorbs.widget.offset.impl.SpecOrbOffset;
import com.compactorbs.widget.offset.impl.StoreOrbOffset;
import com.compactorbs.widget.offset.impl.WikiContainerOffset;
import com.compactorbs.widget.offset.impl.WikiOffset;
import com.compactorbs.widget.offset.impl.WikiVanillaOffset;
import com.compactorbs.widget.offset.impl.WorldMapOffset;
import com.compactorbs.widget.offset.impl.XPOrbOffset;
import java.util.HashMap;
import java.util.Map;
import lombok.Getter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.widgets.Widget;

@Slf4j
@Getter
public enum Offsets
{
	COMPASS(new CompassOffset(),
		new int[]{Modern.COMPASS_PARENT, Classic.COMPASS_PARENT}
	),
	WIKI(new WikiOffset(),
		new int[]{Orbs.WIKI_ICON_CONTAINER.getComponentId()}
	),
	WIKI_VANILLA(new WikiVanillaOffset(),
		new int[]{Orbs.WIKI_VANILLA_CONTAINER.getComponentId()}
	),
	WIKI_CONTAINER(new WikiContainerOffset(),
		Orbs.WIKI_ICON_CONTAINER.getComponentId()
	),
	LOGOUT(new LogoutXOffset(),
		Orbs.LOGOUT_X_ICON.getComponentId(),
		Orbs.LOGOUT_X_STONE.getComponentId()
	),
	HP(new HPOrbOffset(),
		Orbs.HP_ORB_CONTAINER.getComponentId()
	),
	PRAYER(new PrayerOrbOffset(),
		Orbs.PRAYER_ORB_CONTAINER.getComponentId()
	),
	RUN(new RunOrbOffset(),
		Orbs.RUN_ORB_CONTAINER.getComponentId()
	),
	SPEC(new SpecOrbOffset(),
		Orbs.SPEC_ORB_CONTAINER.getComponentId()
	),
	STORE(new StoreOrbOffset(),
		Orbs.STORE_ORB_CONTAINER.getComponentId()
	),
	ACTIVITY(new ActivityOrbOffset(),
		Orbs.ACTIVITY_ORB_CONTAINER.getComponentId()
	),
	XP(new XPOrbOffset(),
		Orbs.XP_DROPS_CONTAINER.getComponentId()
	),
	WORLD_MAP(new WorldMapOffset(),
		Orbs.WORLD_MAP_CONTAINER.getComponentId()
	);

	private final OffsetTarget offset;
	private final int[] parent;
	private final Integer[] id;

	public OffsetTarget offsetTarget()
	{
		return offset;
	}

	Offsets(OffsetTarget offsetTarget, int[] parent, Integer... id)
	{
		this.offset = offsetTarget;
		this.parent = parent;
		this.id = id;
	}

	Offsets(OffsetTarget offsetTarget, Integer... id)
	{
		this(offsetTarget, new int[]{-1}, id);
	}

	private static final Map<Integer, Offsets> BY_PARENT_ID = new HashMap<>();
	private static final Map<Integer, Offsets> BY_WIDGET_ID = new HashMap<>();

	static
	{
		for (Offsets key : values())
		{
			if (key.parent != null)
			{
				for (int parentId : key.parent)
				{
					if (parentId != -1)
					{
						BY_PARENT_ID.put(parentId, key);
					}
				}
			}

			if (key.id != null)
			{
				for (Integer widgetId : key.id)
				{
					if (widgetId != null)
					{
						BY_WIDGET_ID.put(widgetId, key);
					}
				}
			}
		}
	}

	public static Offsets fromWidget(Widget widget)
	{
		if (widget == null)
		{
			log.debug("Offsets widget is null");
			return null;
		}

		Offsets key = BY_PARENT_ID.get(widget.getParentId());
		if (key != null)
		{
			return key;
		}

		return BY_WIDGET_ID.get(widget.getId());
	}
}

/*
 * Copyright (c) 2025, cue <https://github.com/its-cue>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

package com.compactorbs.widget.offset;

import com.compactorbs.CompactOrbsManager;
import com.compactorbs.widget.slot.SlotManager;

public interface OffsetTarget
{
	default int getOffsetX()
	{
		return 0;
	}

	default int getOffsetY()
	{
		return 0;
	}

	int xOffset(int value, boolean compactLayout, CompactOrbsManager manager, SlotManager slotManager);

	int yOffset(int value, boolean compactLayout, CompactOrbsManager manager, SlotManager slotManager);
}

/*
 * Copyright (c) 2018, Tomas Slusny <slusnucky@gmail.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.compactorbs.widget.overlay;

import com.compactorbs.CompactOrbsConstants.Widgets;
import com.compactorbs.CompactOrbsManager;
import java.awt.Dimension;
import java.awt.Graphics2D;
import java.awt.Rectangle;
import javax.inject.Inject;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.widgets.Widget;
import net.runelite.client.ui.overlay.Overlay;
import net.runelite.client.ui.overlay.OverlayLayer;
import net.runelite.client.ui.overlay.OverlayPosition;

@Slf4j
public class MinimapOverlay extends Overlay
{
	private final Client client;
	private final CompactOrbsManager manager;

	private final int componentId = Widgets.MinimapOverlay.UNIVERSE;
	private final Rectangle parentBounds = new Rectangle();
	private boolean revalidate;

	@Inject
	private MinimapOverlay(Client client, CompactOrbsManager manager)
	{
		this.client = client;
		this.manager = manager;
		setPriority(Overlay.PRIORITY_HIGHEST);
		setLayer(OverlayLayer.UNDER_WIDGETS);
		setPosition(OverlayPosition.CANVAS_TOP_RIGHT);
		setMovable(true);
		setSnappable(true);
	}

	@Override
	public String getName()
	{
		return "COMPACT_ORBS_MINIMAP_OVERLAY";
	}

	@Override
	public Dimension render(Graphics2D graphics)
	{
		final Widget widget = client.getWidget(componentId);
		if (widget == null)
		{
			return null;
		}

		final Rectangle parent = getParentBounds(widget);
		if (parent.isEmpty())
		{
			return null;
		}

		if (!manager.isMinimapOverlayEnabled() //not enabled
			|| !manager.isMinimapHidden() //map is visible
			|| !manager.isResized() //fixed mode
			|| manager.isMinimized()) //native minimized map
		{
			return null;
		}

		final Rectangle bounds = getBounds();

		// OverlayRenderer sets the overlay bounds to where it would like the overlay to render at prior to calling
		// render(). If the overlay has a preferred location or position set we update the widget position to that.
		if (getPreferredLocation() != null || getPreferredPosition() != null)
		{
			// The widget relative pos is relative to the parent
			widget.setForcedPosition(bounds.x - parent.x, bounds.y - parent.y);
		}
		else
		{
			if (revalidate)
			{
				revalidate = false;
				log.debug("Revalidating : {}", getName());
				widget.setForcedPosition(-1, -1);
				// Revalidate the widget to reposition it back to its normal location after an overlay reset
				widget.revalidate();
			}

			// Update the overlay bounds to the widget bounds so the drag overlay renders correctly.
			// Note OverlayManager uses original bounds reference to render managing mode and for
			// onMouseOver, so update the existing bounds vs. replacing the reference.
			Rectangle widgetBounds = widget.getBounds();
			bounds.setBounds(widgetBounds.x, widgetBounds.y, widgetBounds.width, widgetBounds.height);
		}

		return new Dimension(widget.getWidth(), widget.getHeight());
	}

	//returns true if overlay bounds matches widget bounds
	public boolean hasUpdatedBounds()
	{
		final Widget widget = client.getWidget(componentId);
		if (widget == null)
		{
			return false;
		}

		final Rectangle overlay = getBounds();
		return overlay.equals(widget.getBounds());
	}

	private Rectangle getParentBounds(final Widget widget)
	{
		if (widget == null)
		{
			parentBounds.setBounds(new Rectangle());
			return parentBounds;
		}

		final Widget parent = widget.getParent();
		final Rectangle bounds;

		if (parent == null)
		{
			bounds = new Rectangle(client.getRealDimensions());
		}
		else
		{
			bounds = parent.getBounds();
		}

		parentBounds.setBounds(bounds);
		return bounds;
	}

	@Override
	public Rectangle getParentBounds()
	{
		if (!client.isClientThread())
		{
			// During overlay drag this is called on the EDT, so we just
			// cache and reuse the last known parent bounds.
			return parentBounds;
		}

		final Widget widget = client.getWidget(componentId);
		return getParentBounds(widget);
	}

	@Override
	public void revalidate()
	{
		// Revalidate must be called on the client thread, so defer til next frame
		revalidate = true;
	}
}

/*
 * Copyright (c) 2025, cue <https://github.com/its-cue>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

package com.compactorbs.widget.slot;

import com.compactorbs.CompactOrbsConfig;
import com.compactorbs.CompactOrbsConfig.FilteredOrb;
import com.compactorbs.CompactOrbsConstants.ConfigKeys;
import com.compactorbs.widget.TargetWidget;
import com.compactorbs.widget.elements.Orbs;
import com.compactorbs.widget.elements.Compass;
import com.compactorbs.widget.slot.SlotManager.SlotLayoutMode;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import lombok.Getter;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;

@Slf4j
@Getter
@RequiredArgsConstructor
public enum Slot
{
	HP_SLOT(
		Map.of(
			SlotLayoutMode.COMPACT, new SlotConfig(
				ConfigKeys.HP_ORB_SLOT,
				CompactOrbsConfig::orbInHPSlot
			),
			SlotLayoutMode.VANILLA, new SlotConfig(
				ConfigKeys.HP_ORB_SLOT_VANILLA,
				CompactOrbsConfig::orbInHpSlotVanilla
			)
		),
		Orbs.HP_ORB_CONTAINER
	),
	PRAYER_SLOT(
		Map.of(
			SlotLayoutMode.COMPACT, new SlotConfig(
				ConfigKeys.PRAYER_ORB_SLOT,
				CompactOrbsConfig::orbInPrayerSlot
			),
			SlotLayoutMode.VANILLA, new SlotConfig(
				ConfigKeys.PRAYER_ORB_SLOT_VANILLA,
				CompactOrbsConfig::orbInPrayerSlotVanilla
			)
		),
		Orbs.PRAYER_ORB_CONTAINER
	),
	RUN_SLOT(
		Map.of(
			SlotLayoutMode.COMPACT, new SlotConfig(
				ConfigKeys.RUN_ORB_SLOT,
				CompactOrbsConfig::orbInRunSlot
			),
			SlotLayoutMode.VANILLA, new SlotConfig(
				ConfigKeys.RUN_ORB_SLOT_VANILLA,
				CompactOrbsConfig::orbInRunSlotVanilla
			)
		),
		Orbs.RUN_ORB_CONTAINER
	),
	SPEC_SLOT(
		Map.of(
			SlotLayoutMode.COMPACT, new SlotConfig(
				ConfigKeys.SPECIAL_ORB_SLOT,
				CompactOrbsConfig::orbInSpecialSlot
			),
			SlotLayoutMode.VANILLA, new SlotConfig(
				ConfigKeys.SPECIAL_ORB_SLOT_VANILLA,
				CompactOrbsConfig::orbInSpecialSlotVanilla
			)
		),
		Orbs.SPEC_ORB_CONTAINER
	),
	XP_SLOT(
		Orbs.XP_DROPS_CONTAINER
	),
	WORLD_MAP_SLOT(
		Orbs.WORLD_MAP_CONTAINER
	),
	STORE_SLOT(
		Orbs.STORE_ORB_CONTAINER
	),
	ACTIVITY_SLOT(
		Orbs.ACTIVITY_ORB_CONTAINER
	),
	WIKI_SLOT(
		Orbs.WIKI_ICON_CONTAINER
	),
	//compass modern/classic share same x/y/width/height, so either works
	COMPASS_SLOT(
		Compass.CLASSIC_COMPASS
	),
	//logout icon/stone share same x/y/width/height, so either works
	LOGOUT_X_SLOT(
		Orbs.LOGOUT_X_ICON
	);

	private final Map<SlotLayoutMode, SlotConfig> slotConfigMap;
	private final TargetWidget original;

	Slot(TargetWidget original)
	{
		this(Map.of(), original);
	}

	public TargetWidget getOrbByConfig(CompactOrbsConfig config, SlotLayoutMode layout)
	{
		SlotConfig entry = slotConfigMap.get(layout);
		if (entry == null)
		{
			return original;
		}

		FilteredOrb filtered = entry.getGetter().apply(config);
		if (filtered == null)
		{
			return original;
		}

		try
		{
			return Orbs.valueOf(filtered.name());
		}
		catch (IllegalArgumentException ex)
		{
			return original;
		}
	}

	private static final Map<String, SlotLayout> CONFIG_LOOKUP;

	public static final List<Slot> VERTICAL_LEFT_COLUMN;
	public static final List<Slot> VERTICAL_RIGHT_COLUMN;
	public static final List<Slot> HORIZONTAL_TOP_ROW;
	public static final List<Slot> HORIZONTAL_BOTTOM_ROW;

	private static final Map<Slot, List<Slot>> VERTICAL_LOOKUP;
	private static final Map<Slot, List<Slot>> HORIZONTAL_LOOKUP;

	public static List<Slot> getColumnSlots(Slot slot)
	{
		return VERTICAL_LOOKUP.get(slot);
	}

	public static List<Slot> getRowSlots(Slot slot)
	{
		return HORIZONTAL_LOOKUP.get(slot);
	}

	//get a slot by its configKey (used in onConfigChanged)
	public static SlotLayout getSlotByConfigKey(String configKey)
	{
		return CONFIG_LOOKUP.get(configKey);
	}

	@SafeVarargs
	private static Map<Slot, List<Slot>> buildLookup(List<Slot>... layout)
	{
		Map<Slot, List<Slot>> lookup = new HashMap<>();
		for (List<Slot> group : layout)
		{
			for (Slot slot : group)
			{
				lookup.put(slot, group);
			}
		}
		return Map.copyOf(lookup);
	}

	private static Map<String, SlotLayout> buildConfigLookup()
	{
		Map<String, SlotLayout> lookup = new HashMap<>();
		for (SlotLayoutMode layout : SlotLayoutMode.values())
		{
			for (Slot slot : Slot.values())
			{
				SlotConfig entry = slot.slotConfigMap.get(layout);
				if (entry != null)
				{
					lookup.put(entry.getConfigKey(), new SlotLayout(slot, layout));
				}
			}
		}
		return Map.copyOf(lookup);
	}

	static
	{
		VERTICAL_LEFT_COLUMN = List.of(
			XP_SLOT,
			WORLD_MAP_SLOT,
			STORE_SLOT,
			ACTIVITY_SLOT
		);

		VERTICAL_RIGHT_COLUMN = List.of(
			HP_SLOT,
			PRAYER_SLOT,
			RUN_SLOT,
			SPEC_SLOT,
			WIKI_SLOT
		);

		HORIZONTAL_TOP_ROW = List.of(
			STORE_SLOT,
			HP_SLOT,
			RUN_SLOT
		);

		HORIZONTAL_BOTTOM_ROW = List.of(
			ACTIVITY_SLOT,
			PRAYER_SLOT,
			SPEC_SLOT
		);

		VERTICAL_LOOKUP = buildLookup(
			VERTICAL_LEFT_COLUMN,
			VERTICAL_RIGHT_COLUMN
		);

		HORIZONTAL_LOOKUP = buildLookup(
			HORIZONTAL_TOP_ROW,
			HORIZONTAL_BOTTOM_ROW
		);

		CONFIG_LOOKUP = buildConfigLookup();
	}
}

/*
 * Copyright (c) 2025, cue <https://github.com/its-cue>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

package com.compactorbs.widget.slot;

import com.compactorbs.CompactOrbsConfig;
import com.compactorbs.CompactOrbsConfig.FilteredOrb;
import java.util.function.Function;
import lombok.Getter;
import lombok.RequiredArgsConstructor;

@Getter
@RequiredArgsConstructor
public class SlotConfig
{
	//key for the given slot
	private final String configKey;

	//function to read the current orb from the config
	private final Function<CompactOrbsConfig, FilteredOrb> getter;
}

/*
 * Copyright (c) 2025, cue <https://github.com/its-cue>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

package com.compactorbs.widget.slot;

import com.compactorbs.widget.slot.SlotManager.SlotLayoutMode;
import lombok.Getter;
import lombok.RequiredArgsConstructor;

@Getter
@RequiredArgsConstructor
public class SlotLayout
{
	//slot being referenced
	public final Slot slot;

	//layout the slot belongs to
	public final SlotLayoutMode layout;
}

/*
 * Copyright (c) 2025, cue <https://github.com/its-cue>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

package com.compactorbs.widget.slot;

import com.compactorbs.CompactOrbsConfig;
import com.compactorbs.CompactOrbsConstants;
import com.compactorbs.CompactOrbsManager;
import com.compactorbs.widget.TargetWidget;
import com.compactorbs.widget.WidgetManager;
import com.compactorbs.widget.elements.Orbs;
import java.util.EnumMap;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.function.Supplier;
import javax.inject.Inject;
import javax.inject.Singleton;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.widgets.Widget;

@Slf4j
@Singleton
public class SlotManager
{
	@Inject
	private CompactOrbsConfig config;

	@Inject
	private CompactOrbsManager manager;

	@Inject
	private WidgetManager widgetManager;

	public SlotLayoutMode currentSlotLayoutMode;

	public enum SlotLayoutMode
	{
		COMPACT,
		VANILLA
	}

	//if previousId is -1, additional check to apply an update if in fixed mode atleast once
	public boolean allowFixedModeUpdate;

	//map of slots and their target widget per layout mode
	private final EnumMap<SlotLayoutMode, EnumMap<Slot, TargetWidget>> slotLayoutMap = new EnumMap<>(SlotLayoutMode.class);

	public void initSlots()
	{
		validateSlotConfig();
		generateSlots(manager.enableOrbSwapping());
	}

	public void reset()
	{
		slotLayoutMap.clear();
	}

	public void generateSlots(boolean updateVisual)
	{
		reset();

		for (SlotLayoutMode layout : SlotLayoutMode.values())
		{
			for (Slot slot : Slot.values())
			{
				getSlotsByLayout(layout).put(slot, getOrbBySlot(slot, layout));
			}
		}

		remapTargetsForUpdate(updateVisual);
	}

	//handle config change event, swap orb to desired slot and update visuals if swapping is enabled
	public void applySlotSwap(Slot slot, SlotLayoutMode layout)
	{
		TargetWidget desired = slot.getOrbByConfig(config, layout);
		TargetWidget current = getSlotsByLayout(layout).get(slot);

		if (desired == current)
		{
			return;
		}

		swapSlots(layout, slot, desired, current);
		remapTargetsForUpdate(manager.enableOrbSwapping());
	}

	//place the incoming orb at current slot, move outgoing orb to source slot
	//update config for the slot receiving the outgoing orb
	private void swapSlots(SlotLayoutMode layout, Slot targetSlot, TargetWidget incoming, TargetWidget outgoing)
	{
		Slot sourceSlot = findSlotByOrb(incoming, layout);

		getSlotsByLayout(layout).put(targetSlot, incoming);

		if (sourceSlot != null && sourceSlot != targetSlot)
		{
			getSlotsByLayout(layout).put(sourceSlot, outgoing);
			manager.updateConfigForSlot(sourceSlot, outgoing, layout);
		}
	}

	//apply visual updates if swapping is enabled
	private void remapTargetsForUpdate(boolean updateVisual)
	{
		if (updateVisual)
		{
			widgetManager.remapTargets(
				manager.isMinimapHidden() && manager.isResized(),
				CompactOrbsConstants.Script.FORCE_UPDATE,
				Orbs.SWAPPABLE_ORBS.toArray(Orbs[]::new)
			);
		}
	}

	//return the height of the hidden orbs above
	public int getHiddenDimensionsAbove(TargetWidget target)
	{
		return computeHiddenOffset(target, false, false);
	}

	//return the height of the hidden orbs below
	public int getHiddenDimensionsBelow(TargetWidget target)
	{
		return computeHiddenOffset(target, false, true);
	}

	//return a count of the hidden orbs above
	public int getHiddenCountAbove(TargetWidget target)
	{
		return computeHiddenOffset(target, true, false);
	}

	//return a count of the hidden orbs below
	public int getHiddenCountBelow(TargetWidget target)
	{
		return computeHiddenOffset(target, true, true);
	}

	//return the amount of hidden orbs above or below a target widget
	// @dimension return hidden orb dimensions
	// @below returns hidden orb count (for above, or below)
	public int computeHiddenOffset(TargetWidget target, boolean count, boolean isBelow)
	{
		if (target == null)
		{
			return 0;
		}

		Slot targetSlot = findSlotByOrb(target, SlotLayoutMode.COMPACT);
		if (targetSlot == null)
		{
			return 0;
		}

		List<Slot> columnOrRow = (manager.isHorizontalLayout()
			? Slot.getRowSlots(targetSlot)
			: Slot.getColumnSlots(targetSlot));

		int targetIndex = columnOrRow.indexOf(targetSlot);
		if (targetIndex < 0)
		{
			return 0;
		}

		return isBelow
			? hiddenBelowOffset(columnOrRow, targetIndex, count)
			: hiddenAboveOffset(columnOrRow, targetIndex, count);
	}

	private int hiddenAboveOffset(List<Slot> columnOrRow, int targetIndex, boolean count)
	{
		int total = 0;

		for (int index = 0; index < targetIndex; index++)
		{
			TargetWidget orbInSlot = getCurrentSlots().get(columnOrRow.get(index));
			if (isOrbHidden(orbInSlot))
			{
				total += count ? 1 : getSlotSize(columnOrRow.get(index));
			}
		}

		return total;
	}

	private int hiddenBelowOffset(List<Slot> columnOrRow, int targetIndex, boolean count)
	{
		int total = 0;

		for (int index = targetIndex + 1; index < columnOrRow.size(); index++)
		{
			Slot slot = columnOrRow.get(index);
			if (slot == Slot.WIKI_SLOT)
			{
				continue;
			}

			TargetWidget orbInSlot = getCurrentSlots().get(slot);
			if (isOrbHidden(orbInSlot))
			{
				total += count ? 1 : getSlotSize(slot);
			}
		}

		return total;
	}

	private int getSlotSize(Slot slot)
	{
		TargetWidget target = getCurrentSlots().get(slot);
		if (target == null)
		{
			return 0;
		}

		Widget widget = widgetManager.getTargetWidget(target);
		if (widget == null)
		{
			return 0;
		}

		return manager.isHorizontalLayout()
			? widget.getOriginalWidth()
			: widget.getOriginalHeight();
	}

	public int getVerticalHiddenHeight()
	{
		if (manager.leaveEmptySpace() || manager.preventReordering())
		{
			return 0;
		}

		return Math.min(
			sumHiddenSize(Slot.VERTICAL_LEFT_COLUMN),
			sumHiddenSize(Slot.VERTICAL_RIGHT_COLUMN)
		);
	}

	public int getHorizontalHiddenWidth()
	{
		if (manager.leaveEmptySpace() || manager.preventReordering())
		{
			return 0;
		}

		return Math.min(
			sumHiddenSize(Slot.HORIZONTAL_TOP_ROW),
			sumHiddenSize(Slot.HORIZONTAL_BOTTOM_ROW)
		);
	}

	private int sumHiddenSize(List<Slot> columnOrRow)
	{
		int total = 0;

		for (Slot slot : columnOrRow)
		{
			if (slot == Slot.WIKI_SLOT)
			{
				continue;
			}

			TargetWidget target = getCurrentSlots().get(slot);

			if (isOrbHidden(target))
			{
				total += getSlotSize(slot);
			}
		}

		return total;
	}

	private int hiddenAboveOffset(TargetWidget target, int value)
	{
		if (target != null)
		{
			int sum = getHiddenDimensionsAbove(target);
			value -= sum;
		}

		return value;
	}

	private int hiddenBelowOffset(TargetWidget target, int value)
	{
		if (target != null)
		{
			int sum = getHiddenDimensionsBelow(target);
			value += sum;
		}

		return value;
	}

	public int applyHiddenYOffset(TargetWidget target, int y)
	{
		if (!manager.preventReordering())
		{
			if (manager.isHorizontalTop())
			{
				return hiddenAboveOffset(target, y);
			}
			else if (manager.isHorizontalBottom())
			{
				return hiddenBelowOffset(target, y);
			}
		}

		return y;
	}

	public int applyHiddenXOffset(TargetWidget target, int x)
	{
		if (!manager.preventReordering())
		{
			if (manager.isVerticalLeft())
			{
				return hiddenAboveOffset(target, x);
			}
			else if (manager.isVerticalRight())
			{
				return hiddenBelowOffset(target, x);
			}
		}

		return x;
	}

	private boolean isOrbHidden(TargetWidget target)
	{
		if (target == null)
		{
			return false;
		}

		Supplier<Boolean> entry = manager.orbToToggle.get(target);
		return entry != null && entry.get();
	}

	public Slot findSlotByOrb(TargetWidget target, SlotLayoutMode layout)
	{
		Map<Slot, TargetWidget> map = getSlotsByLayout(layout);
		if (map == null || map.isEmpty())
		{
			return null;
		}

		for (Map.Entry<Slot, TargetWidget> entry : map.entrySet())
		{
			if (entry.getValue() == target)
			{
				return entry.getKey();
			}
		}

		return null;
	}

	private TargetWidget getOrbBySlot(Slot slot, SlotLayoutMode layout)
	{
		TargetWidget target = slot.getOriginal();
		if (target instanceof Orbs && manager.enableOrbSwapping())
		{
			TargetWidget configured = slot.getOrbByConfig(config, layout);
			if (configured != null)
			{
				return configured;
			}
		}
		return target;
	}

	private Map<Slot, TargetWidget> getSlotsByLayout(SlotLayoutMode layout)
	{
		return slotLayoutMap.computeIfAbsent(layout, k -> new EnumMap<>(Slot.class));
	}

	private Map<Slot, TargetWidget> getCurrentSlots()
	{
		if (currentSlotLayoutMode == null)
		{
			updateCurrentSlotLayout();
		}

		return getSlotsByLayout(currentSlotLayoutMode);
	}

	public void updateCurrentSlotLayout()
	{
		if (manager.isCompactMode())
		{
			currentSlotLayoutMode = SlotLayoutMode.COMPACT;
			return;
		}

		currentSlotLayoutMode = SlotLayoutMode.VANILLA;
	}

	//validate each slot in the config has a unique orb per layout
	private void validateSlotConfig()
	{
		for (SlotLayoutMode layout : SlotLayoutMode.values())
		{
			Map<TargetWidget, Slot> seen = new HashMap<>();
			boolean repeat = false;

			for (Slot slot : Slot.values())
			{
				if (slot.getSlotConfigMap().isEmpty())
				{
					continue;
				}

				TargetWidget orb = slot.getOrbByConfig(config, layout);
				if (seen.containsKey(orb))
				{
					log.debug("Non-unique orb {} found in layout: {}", orb, layout);
					repeat = true;
					break;
				}

				seen.put(orb, slot);
			}

			//should only happen if config changes were made while plugin was inactive
			//and slots in the same layout contain a repeat orb
			if (repeat)
			{
				for (Slot slot : Slot.values())
				{
					if (slot.getSlotConfigMap().isEmpty())
					{
						continue;
					}

					//reset all configs to default
					manager.updateConfigForSlot(slot, slot.getOriginal(), layout);
				}
			}
		}
	}
}

/*
 * Copyright (c) 2025, cue <https://github.com/its-cue>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

package com.compactorbs.widget;

import com.compactorbs.util.SetValue;
import com.compactorbs.util.ValueKey;
import java.util.Map;

public interface TargetWidget
{
	int getComponentId();

	default int getArrayId()
	{
		return -1;
	}

	default int getScriptId()
	{
		return -1;
	}

	Map<ValueKey, SetValue> getValueMap();
}

/*
 * Copyright (c) 2025, cue <https://github.com/its-cue>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

package com.compactorbs.widget;

import com.compactorbs.CompactOrbsConstants;
import com.compactorbs.CompactOrbsConstants.Script;
import com.compactorbs.CompactOrbsConstants.Widgets.Classic;
import com.compactorbs.CompactOrbsConstants.Widgets.Modern;
import com.compactorbs.CompactOrbsManager;
import com.compactorbs.util.SetValue;
import com.compactorbs.util.ValueKey;
import com.compactorbs.widget.elements.Orbs;
import com.compactorbs.widget.offset.OffsetManager;
import com.compactorbs.widget.slot.SlotManager;
import com.compactorbs.widget.slot.Slot;
import java.util.function.IntConsumer;
import java.util.function.IntSupplier;
import javax.inject.Inject;
import javax.inject.Singleton;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.widgets.JavaScriptCallback;
import net.runelite.api.widgets.Widget;
import net.runelite.api.widgets.WidgetPositionMode;
import net.runelite.api.widgets.WidgetType;

@Slf4j
@Singleton
public class WidgetManager
{
	@Inject
	private Client client;

	@Inject
	private CompactOrbsManager manager;

	@Inject
	private SlotManager slotManager;

	private boolean targetRemapped = false;

	//update multiple widgets that match the script id (FORCE_UPDATE bypasses the check)
	public void remapTargets(boolean compactLayout, int scriptId, TargetWidget... widgets)
	{
		//prevent visual changes when not logged in
		if (!manager.isLoggedIn())
		{
			return;
		}

		//ensure slot layout correctness before remapping
		slotManager.updateCurrentSlotLayout();

		for (TargetWidget target : widgets)
		{
			if (!shouldUpdateTarget(target, scriptId))
			{
				continue;
			}

			remapTarget(target, compactLayout);
		}
	}

	//update a target widgets X/Y or position mode, based on layout, if necessary
	public void remapTarget(TargetWidget target, boolean compactLayout)
	{
		Widget widget = getTargetWidget(target);
		if (widget == null)
		{
			return;
		}

		targetRemapped = false;

		//ignore the widget inspector (shares same container/index as grid master)
		if (target == Orbs.GRID_MASTER_ORB_CONTAINER &&
			widget.getSpriteId() == CompactOrbsConstants.Sprite.WIDGET_INSPECTOR)
		{
			return;
		}

		getTarget(target).getValueMap().forEach((key, value) ->
			setValue(widget, key, value, compactLayout)
		);

		if (targetRemapped)
		{
			widget.revalidate();
		}
	}

	//returns a target widget
	private TargetWidget getTarget(TargetWidget target)
	{
		if (target instanceof Orbs)
		{
			return getSlotTarget(target);
		}

		return target;
	}

	//returns which orb the target should reference
	public TargetWidget getSlotTarget(TargetWidget target)
	{
		if (!Orbs.SWAPPABLE_ORBS.contains((Orbs) target) || !manager.enableOrbSwapping())
		{
			return target;
		}

		Slot slot = slotManager.findSlotByOrb(target, slotManager.currentSlotLayoutMode);
		if (slot == null)
		{
			return target;
		}

		return slot.getOriginal();
	}

	//sets the widgets X/Y or position mode as necessary
	private void setValue(Widget widget, ValueKey key, SetValue value, boolean compactLayout)
	{
		if (value == null)
		{
			return;
		}

		Integer v = value.get(compactLayout, manager.getLayout());
		if (v == null)
		{
			return;
		}

		switch (key)
		{
			case X:
				updateValue(widget::getOriginalX, widget::setOriginalX,
					OffsetManager.getTargetOffset(widget, key, v, compactLayout, manager, slotManager));
				break;
			case Y:
				updateValue(widget::getOriginalY, widget::setOriginalY,
					OffsetManager.getTargetOffset(widget, key, v, compactLayout, manager, slotManager));
				break;
			case WIDTH:
				updateValue(widget::getOriginalWidth, widget::setOriginalWidth, v);
				break;
			case HEIGHT:
				updateValue(widget::getOriginalHeight, widget::setOriginalHeight, v);
				break;
			case X_POSITION_MODE:
				updateValue(widget::getXPositionMode, widget::setXPositionMode, v);
				break;
			case Y_POSITION_MODE:
				updateValue(widget::getYPositionMode, widget::setYPositionMode, v);
				break;
			case WIDTH_MODE:
				updateValue(widget::getWidthMode, widget::setWidthMode, v);
				break;
			case HEIGHT_MODE:
				updateValue(widget::getHeightMode, widget::setHeightMode, v);
				break;

			default:
				throw new IllegalStateException("Unhandled ValueKey: " + key);
		}
	}

	//sets a value only if it has changed
	public void updateValue(IntSupplier getter, IntConsumer setter, int value)
	{
		if (getter.getAsInt() != value)
		{
			setter.accept(value);
			targetRemapped = true;
		}
	}

	//set visibility for target widgets, excluding the wiki banner (handled in updateWikiBanner)
	public void setTargetsHidden(boolean hidden, TargetWidget... widgets)
	{
		if (!manager.isLoggedIn())
		{
			return;
		}

		for (TargetWidget target : widgets)
		{
			if (target == Orbs.WIKI_VANILLA_CONTAINER || target == Orbs.WIKI_ICON_CONTAINER)
			{
				continue;
			}

			setHidden(target, hidden);
		}
	}

	//set visibility for a target widget and its children (if they exist), if necessary
	public void setHidden(TargetWidget target, boolean hidden)
	{
		Widget widget = getTargetWidget(target);
		if (widget == null)
		{
			return;
		}

		if (target == Orbs.GRID_MASTER_ORB_CONTAINER &&
			widget.getSpriteId() == CompactOrbsConstants.Sprite.WIDGET_INSPECTOR)
		{
			return;
		}

		if (hidden != widget.isHidden())
		{
			widget.setHidden(hidden);

			//specifically for compass menu options (could be others?)
			if (widget.getChildren() != null)
			{
				for (Widget child : widget.getChildren())
				{
					if (child != null)
					{
						child.setHidden(hidden);
					}
				}
			}
		}
	}

	public void setHidden(int componentId, boolean hidden)
	{
		Widget widget = client.getWidget(componentId);
		if (widget == null)
		{
			return;
		}

		widget.setHidden(hidden);
	}

	//get the widget for the given TargetWidget
	public Widget getTargetWidget(TargetWidget target)
	{
		Widget widget = client.getWidget(target.getComponentId());
		if (widget == null)
		{
			return null;
		}
		if (target.getArrayId() == -1)
		{
			return widget;
		}
		return widget.getChild(target.getArrayId());
	}

	//returns the current visible parent widget
	public Widget getCurrentParent()
	{
		Widget parent = getParent(Modern.ORBS);
		if (parent != null && !parent.isHidden())
		{
			return parent;
		}

		return getParent(Classic.ORBS);
	}

	//returns the parent widget for the given component ID
	//can exist and be hidden, so check for visibility
	public Widget getParent(int componentId)
	{
		Widget parent = client.getWidget(componentId);
		if (parent != null && !parent.isHidden())
		{
			return parent;
		}

		return null;
	}

	//remove all children from the given component id (if they exist, used for custom children)
	public void clearChildren(int componentId)
	{
		Widget widget = client.getWidget(componentId);
		if (widget != null)
		{
			Widget child = widget.getChild(0);
			if (child != null)
			{
				widget.deleteAllChildren();
			}
		}
	}

	//check if a target widget should be updated based on script id (or FORCE_UPDATE)
	private boolean shouldUpdateTarget(TargetWidget target, int scriptId)
	{
		return (scriptId == Script.FORCE_UPDATE) || target.getScriptId() == scriptId;
	}

	//check if the child is missing, or not a child of the given parent widget
	public boolean isMissing(Widget child, Widget parent)
	{
		return child == null || child.getParentId() != parent.getId();
	}

	//return the interface id from the component id
	public static int getInterfaceId(int componentId)
	{
		return componentId >> 16;
	}

	//return the child id from the component id
	public static int getChildId(int componentId)
	{
		return componentId & 0xff;
	}

	//create a simple graphic widget
	public Widget createGraphic(
		Widget parent,
		int x, int y,
		int width, int height,
		int opacity,
		int spriteId)
	{
		Widget graphic = parent.createChild(-1, WidgetType.GRAPHIC);
		graphic
			.setOriginalX(x)
			.setOriginalY(y)
			.setOriginalWidth(width)
			.setOriginalHeight(height)
			.setOpacity(opacity)
			.setHidden(false)
			.setSpriteId(spriteId);

		return graphic;
	}

	//create an interactive toggle button (with sprite, menu option, and optional event listeners)
	public Widget createToggleButton(
		Widget parent,
		int x, int y,
		int width, int height,
		int opacity,
		int spriteId,
		String menuOp,
		JavaScriptCallback opListener,
		JavaScriptCallback mouseOver,
		JavaScriptCallback mouseLeave)
	{
		Widget button = createGraphic(parent, x, y, width, height, opacity, spriteId);
		button.setHasListener(true);
		button.setNoClickThrough(true);

		if (menuOp != null)
		{
			button.setAction(0, menuOp);
		}
		if (opListener != null)
		{
			button.setOnOpListener(opListener);
		}
		if (mouseOver != null)
		{
			button.setOnMouseOverListener(mouseOver);
		}
		if (mouseLeave != null)
		{
			button.setOnMouseLeaveListener(mouseLeave);
		}

		return button;
	}

	public void createMinimapNoClickLayer(Widget parent, int index, int y, int width, int height)
	{
		Widget widget = parent.createChild(index, WidgetType.LAYER);
		widget
			.setOriginalX(CompactOrbsConstants.Layout.MinimapOverlay.NO_CLICK_X)
			.setOriginalY(y)
			.setOriginalWidth(width)
			.setOriginalHeight(height)
			.setXPositionMode(WidgetPositionMode.ABSOLUTE_RIGHT)
			.setYPositionMode(WidgetPositionMode.ABSOLUTE_TOP)
			.setNoClickThrough(true);

		widget.revalidate();
	}

	public void createMinimapElement(
		Widget parent, int index,
		int contentType,
		int spriteId,
		int x, int y,
		int width, int height,
		int xPosMode, int yPosMode)
	{
		Widget clone = parent.createChild(index, WidgetType.GRAPHIC);
		clone
			.setContentType(contentType)
			.setOriginalX(x)
			.setOriginalY(y)
			.setOriginalWidth(width)
			.setOriginalHeight(height)
			.setSpriteId(spriteId)
			.setXPositionMode(xPosMode)
			.setYPositionMode(yPosMode);

		clone.revalidate();
	}
}

package com.compactorbs;

import net.runelite.client.RuneLite;
import net.runelite.client.externalplugins.ExternalPluginManager;

public class CompactOrbsPluginTest
{
	public static void main(String[] args) throws Exception
	{
		ExternalPluginManager.loadBuiltin(CompactOrbsPlugin.class);
		RuneLite.main(args);
	}
}
