package com.lootledger.drops;

import lombok.Getter;
import lombok.Setter;

import java.util.Arrays;
import java.util.Locale;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.stream.Collectors;

@Setter
@Getter
public class DropItem
{
    private int itemId;
    private String name;
    private String rarity;

    // e.g., "12.5%"
    private static final Pattern PCT      = Pattern.compile("^(\\d+(?:\\.\\d+)?)%$");
    // e.g., "2 x 1 / 128"  or  "2x1/128"
    private static final Pattern MULT     = Pattern.compile("^(\\d+(?:\\.\\d+)?)\\s*[xX]\\s*(\\d+(?:\\.\\d+)?)\\s*/\\s*(\\d+(?:\\.\\d+)?)$");
    // e.g., "1/128"
    private static final Pattern FRAC     = Pattern.compile("^(\\d+(?:\\.\\d+)?)\\s*/\\s*(\\d+(?:\\.\\d+)?)$");
    // strip trailing parenthetical, e.g., "1/128 (without ring)"
    private static final Pattern PAREN    = Pattern.compile("\\s*\\([^)]*\\)$", Pattern.UNICODE_CASE);
    // replace "in" with '/', e.g., "1 in 128"
    private static final Pattern IN_SYNT  = Pattern.compile("\\bin\\b", Pattern.CASE_INSENSITIVE);
    // remove bracketed annotations like "[confirmation needed]"
    private static final Pattern BRACKETS = Pattern.compile("\\[[^\\]]*\\]");

    public DropItem(int itemId, String name, String rarity)
    {
        this.itemId = itemId;
        this.name = name;
        this.rarity = rarity;
    }

    /**
     * Convert a raw rarity string like "2/128" (or "1 in 128", "12.5%", ranges) into
     * normalized one-over form, preserving ranges, e.g., "1/64" or "1/64–1/32".
     */
    public String getOneOverRarity()
    {
        if (rarity == null) return "";
        String[] parts = rarity.split("\\s*;\\s*|,\\s+");
        return Arrays.stream(parts)
                .map(this::normalizeSegment)
                .collect(Collectors.joining("; "));
    }

    /**
     * Parse the rarity and return its numeric denominator. Unknown/unsupported
     * values become POSITIVE_INFINITY so they sort as the rarest.
     */
    public double getRarityValue()
    {
        String oneOver = getOneOverRarity();
        if (oneOver.isEmpty())
        {
            return Double.POSITIVE_INFINITY;
        }

        Matcher m = Pattern.compile("1/(\\d+(?:\\.\\d+)?)").matcher(oneOver);
        if (m.find())
        {
            try { return Double.parseDouble(m.group(1)); }
            catch (NumberFormatException ex) { return Double.POSITIVE_INFINITY; }
        }

        if (oneOver.equalsIgnoreCase("Always"))
        {
            return 0d;
        }

        return Double.POSITIVE_INFINITY;
    }

    private String normalizeSegment(String raw)
    {
        String cleaned = raw == null ? "" : raw;
        cleaned = BRACKETS.matcher(cleaned).replaceAll("");
        cleaned = cleaned
                .replace("×", "x")
                .replace(",", "")
                .replace("≈", "")
                .replace("~", "")
                .replaceAll(PAREN.pattern(), "")
                .replaceAll(IN_SYNT.pattern(), "/")
                .trim();

        // Handle ranges like "1/128 – 1/64"
        String[] range = cleaned.split("\\s*[–—-]\\s*");
        if (range.length > 1)
        {
            return Arrays.stream(range)
                    .map(this::simplifySingle)
                    .collect(Collectors.joining("–"));
        }

        return simplifySingle(cleaned);
    }

    private String simplifySingle(String s)
    {
        if (s == null || s.isEmpty())
        {
            return "";
        }

        Matcher m;

        m = PCT.matcher(s);
        if (m.matches())
        {
            double pct = safeDouble(m.group(1));
            if (pct == 0) return "0";
            return formatOneOver(100.0 / pct);
        }

        m = MULT.matcher(s);
        if (m.matches())
        {
            double factor = safeDouble(m.group(1));
            double a = safeDouble(m.group(2));
            double b = safeDouble(m.group(3));
            if (factor != 0 && a != 0)
            {
                return formatOneOver(b / (a * factor));
            }
        }

        m = FRAC.matcher(s);
        if (m.matches())
        {
            double a = safeDouble(m.group(1));
            double b = safeDouble(m.group(2));
            if (a != 0)
            {
                return formatOneOver(b / a);
            }
        }

        // fallback to cleaned input
        return s;
    }

    private double safeDouble(String s)
    {
        try { return Double.parseDouble(s); }
        catch (Exception e) { return Double.NaN; }
    }

    private String formatOneOver(double val)
    {
        if (Double.isNaN(val) || Double.isInfinite(val))
        {
            return "";
        }
        if (Math.abs(val - Math.round(val)) < 0.01)
        {
            return "1/" + Math.round(val);
        }
        return String.format(Locale.ROOT, "1/%.2f", val);
    }
}

package com.lootledger.drops;

import lombok.Getter;
import lombok.Setter;

import java.util.List;

@Setter
@Getter
public class DropTableSection
{
    private String header;
    private List<DropItem> items;

    public DropTableSection(String header, List<DropItem> items)
    {
        this.header = header;
        this.items = items;
    }

}
package com.lootledger.drops;

import static net.runelite.client.RuneLite.RUNELITE_DIR;

import com.lootledger.account.AccountManager;
import com.google.gson.Gson;
import lombok.extern.slf4j.Slf4j;
import com.google.common.util.concurrent.ThreadFactoryBuilder;

import javax.inject.Inject;
import javax.inject.Singleton;
import java.io.IOException;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.StandardCopyOption;
import java.nio.file.StandardOpenOption;
import java.time.Duration;
import java.time.Instant;
import java.util.*;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.TimeUnit;
import java.util.stream.Collectors;
import java.util.stream.Stream;

/**
 * Persistent droptable cache backed by JSON files in the user's RuneLite
 * directory. The cache is mirrored in memory to make name based lookups and
 * searches effectively instantaneous.
 */
@Slf4j
@Singleton
public class DropCache
{
    private final Gson gson;
    private final AccountManager accountManager;
    private final DropFetcher dropFetcher;
    private static final Duration MAX_AGE = Duration.ofDays(7);
    private final Map<Path, Object> writeLocks = new ConcurrentHashMap<>();
    private final Map<Path, NpcDropData> cache = new ConcurrentHashMap<>();
    private final Map<String, Path> nameIndex = new ConcurrentHashMap<>();
    private volatile boolean indexLoaded = false;
    private final ExecutorService ioExecutor = java.util.concurrent.Executors.newFixedThreadPool(
            Math.max(2, Runtime.getRuntime().availableProcessors() / 2),
            new ThreadFactoryBuilder().setNameFormat("dropcache-io-%d").build()
    );

    @Inject
    public DropCache(Gson gson, AccountManager accountManager, DropFetcher dropFetcher)
    {
        this.gson = gson;
        this.accountManager = accountManager;
        this.dropFetcher = dropFetcher;
    }

    /**
     * Preloads the on-disk index and prunes stale cache entries.
     */
    public void startUp()
    {
        String player = accountManager.getPlayerName();
        if (player == null || player.isEmpty()) { return; }
        loadIndex();
        pruneOldCaches();
    }
    /**
     * Load from disk if possible; otherwise fetch from the wiki, write the
     * JSON, and return the data. Results without droptable sections are
     * discarded and never cached.
     */
    public CompletableFuture<NpcDropData> get(int npcId, String name, int level)
    {
        loadIndex();
        final String safeName = name.replaceAll("[^A-Za-z0-9]", "_");
        final Path file;
        try
        {
            file = npcId == 0
                    ? findExistingCacheFile(safeName, level)
                    : getCacheFile(npcId, name, level);
        }
        catch (IOException ex)
        {
            log.error("Could not resolve cache file for {} ({}, lvl {})", npcId, name, level, ex);
            return CompletableFuture.failedFuture(ex);
        }

        return CompletableFuture.supplyAsync(() ->
        {
            if (file != null)
            {
                NpcDropData cached = cache.get(file);
                if (cached != null && Files.exists(file) && isFresh(file))
                {
                    return cached;
                }

                // stale or missing entry, clean up
                try
                {
                    Files.deleteIfExists(file);
                }
                catch (IOException ignore) { }
                removeIndex(file);
            }
            return null;
        }, ioExecutor).thenComposeAsync(cached ->
        {
            if (cached != null)
            {
                return CompletableFuture.completedFuture(cached);
            }

            return dropFetcher.fetch(npcId, name, level)
                    .thenApplyAsync(data ->
                    {
                        try
                        {
                            if (data == null || data.getDropTableSections().isEmpty())
                            {
                                return null;
                            }

                            Path out = getCacheFile(data.getNpcId(), data.getName(), data.getLevel());
                            Files.createDirectories(out.getParent());
                            String json = gson.toJson(data);

                            Object lock = writeLocks.computeIfAbsent(out, p -> new Object());
                            synchronized (lock)
                            {
                                Path tmp = out.resolveSibling(out.getFileName() + ".tmp");
                                try
                                {
                                    Files.writeString(
                                            tmp,
                                            json,
                                            StandardCharsets.UTF_8,
                                            StandardOpenOption.CREATE,
                                            StandardOpenOption.TRUNCATE_EXISTING
                                    );
                                    Files.move(tmp, out, StandardCopyOption.REPLACE_EXISTING, StandardCopyOption.ATOMIC_MOVE);
                                }
                                finally
                                {
                                    writeLocks.remove(out);
                                    try { Files.deleteIfExists(tmp); } catch (IOException ignored) {}
                                }
                            }

                            cache.put(out, data);
                            nameIndex.put(buildNameKey(data.getName(), data.getLevel()), out);

                            if (npcId == 0 && data.getNpcId() != 0)
                            {
                                Path old = findExistingCacheFile(safeName, data.getLevel());
                                if (old != null && !old.equals(out))
                                {
                                    Files.deleteIfExists(old);
                                    removeIndex(old);
                                }
                            }
                        }
                        catch (Exception e)
                        {
                            log.error("Failed to write cache file for {}", name, e);
                        }
                        return data;
                    }, ioExecutor)
                    .exceptionally(ex ->
                    {
                        log.error("Error fetching drop data for NPC {}", npcId, ex);
                        return null;
                    });
        },ioExecutor);
    }

    /**
     * @return a collection of all cached NPC drop data in memory
     */
    public Collection<NpcDropData> getAllNpcData()
    {
        loadIndex();
        return new ArrayList<>(cache.values());
    }

    /**
     * Return a list of NPC names containing the supplied query. Matches from
     * the local cache are combined with wiki search results to ensure partial
     * lookups surface all relevant NPCs.
     */
    public CompletableFuture<List<String>> searchNpcNames(String query)
    {
        return CompletableFuture.supplyAsync(() ->
        {
            String lc = query.toLowerCase(Locale.ROOT).trim();
            loadIndex();

            // Preserve insertion order while de-duplicating names
            Set<String> names = cache.values().stream()
                    .map(NpcDropData::getName)
                    .filter(Objects::nonNull)
                    .filter(n -> n.toLowerCase(Locale.ROOT).contains(lc))
                    .collect(Collectors.toCollection(LinkedHashSet::new));

            try
            {
                names.addAll(dropFetcher.searchNpcNames(query));
            }
            catch (Exception ex)
            {
                log.error("Wiki search failed for {}", query, ex);
            }

            return new ArrayList<>(names);
        }, ioExecutor);
    }

    private boolean isFresh(Path file)
    {
        try
        {
            Instant cutoff = Instant.now().minus(MAX_AGE);
            return Files.getLastModifiedTime(file).toInstant().isAfter(cutoff);
        }
        catch (IOException e)
        {
            return false;
        }
    }

    /** Locate an existing cache file by name and level regardless of stored ID. */
    private Path findExistingCacheFile(String safeName, int level) throws IOException
    {
        String key = safeName + "_" + level;
        Path p = nameIndex.get(key);
        if (p != null && Files.exists(p))
        {
            if (isFresh(p))
            {
                return p;
            }
            Files.deleteIfExists(p);
            removeIndex(p);
        }
        return null;
    }

    private Path getCacheDir() throws IOException
    {
        String player = accountManager.getPlayerName();
        if (player == null)
        {
            throw new IOException("Player name is not available");
        }
        return RUNELITE_DIR.toPath()
                .resolve("lootledger")
                .resolve(player)
                .resolve("drops");
    }

    /** Resolve the on-disk cache path for a specific NPC. */
    private Path getCacheFile(int npcId, String name, int level) throws IOException
    {
        String safeName = name.replaceAll("[^A-Za-z0-9]", "_");
        Path dir = getCacheDir();
        Files.createDirectories(dir);
        String fn = npcId + "_" + safeName + "_" + level + ".json";
        return dir.resolve(fn);
    }

    /**
     * Deletes cached drop table files older than {@link #MAX_AGE} and purges
     * them from the in-memory index.
     */
    public void pruneOldCaches()
    {
        String player = accountManager.getPlayerName();
        if (player == null)
        {
            return;
        }

        Path dir = RUNELITE_DIR.toPath()
                .resolve("lootledger")
                .resolve(player)
                .resolve("drops");

        if (!Files.exists(dir))
        {
            return;
        }

        Instant cutoff = Instant.now().minus(MAX_AGE);
        try (Stream<Path> files = Files.list(dir))
        {
            files.filter(Files::isRegularFile)
                    .forEach(p ->
                    {
                        try
                        {
                            Instant mod = Files.getLastModifiedTime(p).toInstant();
                            if (mod.isBefore(cutoff))
                            {
                                Files.deleteIfExists(p);
                                removeIndex(p);
                            }
                        }
                        catch (IOException ex)
                        {
                            log.error("Failed to delete old drop cache {}", p, ex);
                        }
                    });
        }
        catch (IOException ex)
        {
            log.error("Error pruning drop cache directory {}", dir, ex);
        }
    }

    /**
     * Deletes all cached drop table files for the current player and clears the
     * in-memory index.
     */
    public void clearAllCaches()
    {
        String player = accountManager.getPlayerName();
        if (player == null) return;

        Path dir = RUNELITE_DIR.toPath()
                .resolve("lootledger")
                .resolve(player)
                .resolve("drops");

        if (Files.exists(dir))
        {
            try (Stream<Path> files = Files.list(dir))
            {
                files.filter(Files::isRegularFile)
                        .forEach(p ->
                        {
                            try
                            {
                                Files.deleteIfExists(p);
                            }
                            catch (IOException ex)
                            {
                                log.error("Failed to delete drop cache {}", p, ex);
                            }
                        });
            }
            catch (IOException ex)
            {
                log.error("Error clearing drop cache directory {}", dir, ex);
            }
        }

        cache.clear();
        nameIndex.clear();
        indexLoaded = true;
    }

    /** Remove the given file from the in-memory indices. */
    private void removeIndex(Path p)
    {
        NpcDropData data = cache.remove(p);
        if (data != null)
        {
            nameIndex.remove(buildNameKey(data.getName(), data.getLevel()));
        }
    }

    /** Lazily populate the in-memory indices from existing cache files. */
    private void loadIndex()
    {
        if (indexLoaded)
        {
            return;
        }
        synchronized (this)
        {
            if (indexLoaded)
            {
                return;
            }
            try
            {
                Path dir = getCacheDir();
                if (Files.exists(dir))
                {
                    try (Stream<Path> files = Files.list(dir))
                    {
                        for (Path p : files.filter(Files::isRegularFile).collect(Collectors.toList()))
                        {
                            if (!isFresh(p))
                            {
                                Files.deleteIfExists(p);
                                continue;
                            }
                            try
                            {
                                String json = Files.readString(p, StandardCharsets.UTF_8);
                                NpcDropData data = gson.fromJson(json, NpcDropData.class);
                                if (data != null && data.getDropTableSections() != null && !data.getDropTableSections().isEmpty())
                                {
                                    cache.put(p, data);
                                    nameIndex.put(buildNameKey(data.getName(), data.getLevel()), p);
                                }
                                else
                                {
                                    Files.deleteIfExists(p);
                                }
                            }
                            catch (Exception e)
                            {
                                log.error("Skipping bad cache file {}", p, e);
                                Files.deleteIfExists(p);
                            }
                        }
                    }
                }
            }
            catch (IOException e)
            {
                log.error("Error loading cache index", e);
            }
            indexLoaded = true;
        }
    }

    public void shutdown() {
        ioExecutor.shutdown();
    }


    private String buildNameKey(String name, int level)
    {
        return name.replaceAll("[^A-Za-z0-9]", "_") + "_" + level;
    }
}

package com.lootledger.drops;

import com.google.common.util.concurrent.ThreadFactoryBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonElement;
import com.google.gson.JsonParser;
import com.lootledger.items.ItemIdIndex;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.ItemComposition;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.game.ItemManager;
import net.runelite.http.api.item.ItemPrice;
import okhttp3.OkHttpClient;
import okhttp3.Request;
import okhttp3.Response;
import org.jsoup.Jsoup;
import org.jsoup.nodes.Document;
import org.jsoup.nodes.Element;
import org.jsoup.select.Elements;

import javax.inject.Inject;
import javax.inject.Singleton;
import java.io.IOException;
import java.io.UncheckedIOException;
import java.net.URLDecoder;
import java.net.URLEncoder;
import java.nio.charset.StandardCharsets;
import java.util.*;
import java.util.concurrent.*;

/**
 * Retrieves NPC drop information from the wiki and resolves item + NPC IDs.
 */
@Slf4j
@Singleton
public class DropFetcher
{
    private static final String USER_AGENT = "RuneLite-LootLedger/1.0.0";

    private final OkHttpClient httpClient;
    private final ItemManager itemManager;
    private final ClientThread clientThread;
    private ExecutorService fetchExecutor;

    @Inject
    public DropFetcher(OkHttpClient httpClient, ItemManager itemManager, ClientThread clientThread)
    {
        this.httpClient = httpClient;
        this.itemManager  = itemManager;
        this.clientThread = clientThread;
    }

    /**
     * Asynchronously fetch an NPC's drop table from the wiki.
     */
    public CompletableFuture<NpcDropData> fetch(int npcId, String name, int level)
    {
        ensureExecutor();
        return CompletableFuture.supplyAsync(() -> {
            String url = buildWikiUrl(npcId, name);
            String html = fetchHtml(url);
            Document doc = Jsoup.parse(html);

            String actualName = name;
            Element heading = doc.selectFirst("h1#firstHeading");
            if (heading != null) {
                actualName = heading.text();
            }

            int resolvedLevel = level > 0 ? level : parseCombatLevel(doc);
            int actualId = resolveNpcId(doc);
            List<DropTableSection> sections = parseSections(doc);
            if (sections.isEmpty()) {
                return null; // skip NPCs without drop tables
            }
            return new NpcDropData(actualId, actualName, resolvedLevel, sections);
        }, fetchExecutor).thenCompose(data -> {
            if (data == null) {
                return CompletableFuture.completedFuture(null);
            }

            CompletableFuture<NpcDropData> resolved = new CompletableFuture<>();
            clientThread.invoke(() -> {
                // Resolve item IDs on client thread via ItemManager + Items.json index
                for (DropTableSection sec : data.getDropTableSections()) {
                    List<DropItem> items = sec.getItems();
                    for (DropItem d : items) {
                        String itemName = d.getName();
                        d.setItemId(resolveItemId(itemName));
                    }
                }
                resolved.complete(data);
            });
            return resolved;
        });
    }

    /** Resolve an item name to an ID using Items.json first, then fallback to GE-backed search. */
    private int resolveItemId(String itemName)
    {
        if (itemName == null || itemName.isEmpty()) {
            return 0;
        }
        // Skip known non-items
        String lower = itemName.trim().toLowerCase(Locale.ROOT);
        if ("nothing".equals(lower) || "unknown".equals(lower)) {
            return 0;
        }

        // try Items.json index (handles non-tradeables)
        int[] candidates = ItemIdIndex.findIdsFlex(itemName);
        if (candidates.length > 0) {
            int best = ItemIdIndex.pickBestId(itemManager, candidates);
            if (best > 0) {
                return itemManager.canonicalize(best);
            }
        }

        // fallback to ItemManager.search (tradeables only)
        try {
            List<ItemPrice> results = itemManager.search(itemName);
            for (ItemPrice result : results) {
                int id = result.getId();
                ItemComposition comp = itemManager.getItemComposition(id);
                if (comp.getName() != null && comp.getName().equalsIgnoreCase(itemName)) {
                    return itemManager.canonicalize(id);
                }
            }
        } catch (Exception ex) {
            // Ignore
        }

        return 0;
    }

    /** Extract drop table sections */
    private List<DropTableSection> parseSections(Document doc)
    {
        Elements tables = doc.select("table.item-drops");
        List<DropTableSection> sections = new ArrayList<>();

        for (Element table : tables)
        {
            String header = "Drops";
            Element prev = table.previousElementSibling();
            while (prev != null) {
                String tag = prev.tagName();
                if (tag != null && tag.matches("h[2-4]")) {
                    header = prev.text();
                    break;
                }
                prev = prev.previousElementSibling();
            }

            List<DropItem> items = new ArrayList<>();
            Elements rows = table.select("tbody > tr");
            for (Element row : rows) {
                Elements tds = row.select("td");
                if (tds.size() < 6) {
                    continue;
                }
                String name = tds.get(1).text().replace("(m)", "").trim();
                if (name.equalsIgnoreCase("nothing")) {
                    continue;
                }
                String rarity = tds.get(3).text().trim();
                items.add(new DropItem(0, name, rarity));
            }

            if (!items.isEmpty()) {
                sections.add(new DropTableSection(header, items));
            }
        }
        return sections;
    }

    /** Attempt to parse the combat level from the NPC infobox. */
    private int parseCombatLevel(Document doc)
    {
        Element infobox = doc.selectFirst("table.infobox");
        if (infobox == null) {
            return 0;
        }
        Elements rows = infobox.select("tr");
        for (Element row : rows) {
            Element th = row.selectFirst("th");
            Element td = row.selectFirst("td");
            if (th != null && td != null) {
                String thText = th.text();
                if (thText != null && thText.toLowerCase(Locale.ROOT).contains("combat level")) {
                    String txt = td.text();
                    String[] parts = txt.split("[^0-9]+");
                    for (String part : parts) {
                        if (part != null && !part.isEmpty()) {
                            try {
                                return Integer.parseInt(part);
                            } catch (NumberFormatException nfe) {
                                log.error("Failed to parse number in drop table", nfe);
                            }
                        }
                    }
                }
            }
        }
        return 0;
    }

    /** Resolve the canonical wiki page ID for the provided document. */
    private int resolveNpcId(Document doc)
    {
        Element link = doc.selectFirst("link[rel=canonical]");
        if (link == null) {
            return 0;
        }

        String href = link.attr("href");
        String title = href.substring(href.lastIndexOf('/') + 1);
        title = URLDecoder.decode(title, StandardCharsets.UTF_8);
        title = title.replace(' ', '_');
        String apiUrl = "https://oldschool.runescape.wiki/api.php?action=query&format=json&prop=info&titles="
                + URLEncoder.encode(title, StandardCharsets.UTF_8);

        Request req = new Request.Builder()
                .url(apiUrl)
                .header("User-Agent", USER_AGENT)
                .build();

        try (Response res = httpClient.newCall(req).execute())
        {
            if (!res.isSuccessful()) {
                log.warn("Failed to resolve NPC ID for {}: HTTP {}", title, res.code());
                return 0;
            }

            assert res.body() != null;
            String body = res.body().string();
            JsonElement root = new JsonParser().parse(body);
            JsonElement pages = root.getAsJsonObject()
                    .getAsJsonObject("query")
                    .getAsJsonObject("pages");

            for (Map.Entry<String, JsonElement> entry : pages.getAsJsonObject().entrySet()) {
                JsonElement page = entry.getValue();
                if (page.getAsJsonObject().has("pageid")) {
                    return page.getAsJsonObject().get("pageid").getAsInt();
                }
            }

            log.error("No page ID found for title {}", title);
        }
        catch (IOException ex)
        {
            log.error("Error resolving NPC ID for {}", title, ex);
        }
        return 0;
    }

    /** Query the wiki's search API for NPC names matching the provided text. */
    public List<String> searchNpcNames(String query)
    {
        String url = "https://oldschool.runescape.wiki/api.php?action=opensearch&format=json&limit=20&namespace=0&search="
                + URLEncoder.encode(query, StandardCharsets.UTF_8);
        Request req = new Request.Builder()
                .url(url)
                .header("User-Agent", USER_AGENT)
                .build();
        try (Response res = httpClient.newCall(req).execute())
        {
            if (!res.isSuccessful()) {
                throw new IOException("HTTP " + res.code());
            }
            assert res.body() != null;
            String body = res.body().string();
            JsonArray arr = new JsonParser().parse(body).getAsJsonArray();
            JsonArray titles = arr.get(1).getAsJsonArray();
            List<String> names = new ArrayList<>();
            for (int i = 0; i < titles.size(); i++) {
                names.add(titles.get(i).getAsString());
            }
            return names;
        }
        catch (IOException ex)
        {
            throw new UncheckedIOException(ex);
        }
    }

    private String buildWikiUrl(int npcId, String name)
    {
        String fallback = URLEncoder.encode(name.replace(' ', '_'), StandardCharsets.UTF_8);
        StringBuilder url = new StringBuilder("https://oldschool.runescape.wiki/w/Special:Lookup?type=npc");

        if (npcId > 0) {
            url.append("&id=").append(npcId);
        }
        if (!fallback.isEmpty()) {
            url.append("&name=").append(fallback);
        }
        url.append("#Drops");
        return url.toString();
    }

    private String fetchHtml(String url)
    {
        Request req = new Request.Builder()
                .url(url)
                .header("User-Agent", USER_AGENT)
                .build();
        try (Response res = httpClient.newCall(req).execute())
        {
            if (!res.isSuccessful()) {
                throw new IOException("HTTP " + res.code());
            }
            assert res.body() != null;
            return res.body().string();
        }
        catch (IOException ex)
        {
            throw new UncheckedIOException(ex);
        }
    }

    /** Creates the fetch executor if it is missing or has been shut down. */
    public void startUp()
    {
        if (fetchExecutor == null || fetchExecutor.isShutdown() || fetchExecutor.isTerminated())
        {
            fetchExecutor = Executors.newFixedThreadPool(
                    4, new ThreadFactoryBuilder().setNameFormat("dropfetch-%d").setDaemon(true).build()
            );
        }
    }

    /** Shut down the executor service (non-blocking, graceful). */
    public void shutdown()
    {
        if (fetchExecutor != null)
        {
            fetchExecutor.shutdown();
            fetchExecutor = null;
        }
    }

    /** Ensure we have a usable executor before submitting async work. */
    private synchronized void ensureExecutor()
    {
        if (fetchExecutor == null || fetchExecutor.isShutdown() || fetchExecutor.isTerminated())
        {
            fetchExecutor = Executors.newFixedThreadPool(
                    4, new ThreadFactoryBuilder().setNameFormat("dropfetch-%d").setDaemon(true).build()
            );
        }
    }
}

package com.lootledger.drops;

import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

import java.util.List;

@Setter
@Getter
@NoArgsConstructor
public class NpcDropData
{
    private int npcId;
    private String name;
    private int level;
    private List<DropTableSection> dropTableSections;

    public NpcDropData(int npcId, String name, int level, List<DropTableSection> dropTableSections)
    {
        this.npcId = npcId;
        this.name = name;
        this.level = level;
        this.dropTableSections = dropTableSections;
    }
}

package com.lootledger.managers;

import com.google.gson.Gson;
import com.lootledger.account.AccountManager;
import lombok.extern.slf4j.Slf4j;

import javax.inject.Inject;
import javax.inject.Singleton;
import java.io.BufferedWriter;
import java.io.IOException;
import java.io.Reader;
import java.nio.charset.StandardCharsets;
import java.nio.file.*;
import java.text.SimpleDateFormat;
import java.util.*;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.ScheduledFuture;

import static net.runelite.client.RuneLite.RUNELITE_DIR;

/**
 * Obtained-items persistence with atomic writes and rotating backups (per account).
 *
 * <p>JSON lives at: ~/.runelite/lootledger/<account>/obtained.json
 * Backups are stored under ~/.runelite/lootledger/<account>/backups (keeps 10).
 */
@Slf4j
@Singleton
public class ObtainedItemsManager
{
    public enum Scope { PER_ACCOUNT, PER_NPC }

    @Inject private AccountManager accountManager;
    @Inject private Gson gson;

    private final ExecutorService io =
            Executors.newSingleThreadExecutor(r -> {
                Thread t = new Thread(r, "obtained-io");
                t.setDaemon(true);
                return t;
            });
    private final ScheduledExecutorService scheduler =
            Executors.newSingleThreadScheduledExecutor(r -> {
                Thread t = new Thread(r, "obtained-flush");
                t.setDaemon(true);
                return t;
            });
    private volatile ScheduledFuture<?> pendingFlush;
    private static final long FLUSH_DELAY_MS = 300;

    // In-memory state keyed by account. Only ever load/save the current account.
    private final Map<String, AccountRecord> data = Collections.synchronizedMap(new LinkedHashMap<>());

    private static final String FILE_NAME = "obtained.json";
    private static final int MAX_BACKUPS = 10;

    public static final class AccountRecord {
        public final Set<Integer> all = Collections.synchronizedSet(new LinkedHashSet<>());
        public final Map<String, Set<Integer>> npcs = Collections.synchronizedMap(new LinkedHashMap<>()); // npcName -> itemIds
    }

    /** Load the current account's file into memory (creates empty file on first run). */
    public synchronized void load()
    {
        final String account = accountManager.getPlayerName();
        if (account == null || account.isEmpty()) {
            log.error("ObtainedItemsManager.load: no account yet");
            return;
        }

        final Path file = fileFor(account);
        try {
            Files.createDirectories(file.getParent());
            AccountRecord rec = new AccountRecord();
            if (Files.exists(file)) {
                try (Reader r = Files.newBufferedReader(file, StandardCharsets.UTF_8)) {
                    AccountRecord loaded = gson.fromJson(r, AccountRecord.class);
                    if (loaded != null) rec = sanitize(loaded);
                }
            }
            data.put(account, rec);
        } catch (IOException e) {
            log.warn("Failed to load obtained file for {}", account, e);
            data.putIfAbsent(account, new AccountRecord());
        }
    }

    /** Persist the current account's record asynchronously with atomic replace + rotating backups. */
    public void save()
    {
        final String account = accountManager.getPlayerName();
        if (account == null || account.isEmpty()) return;
        final AccountRecord rec;
        synchronized (this) {
            rec = data.computeIfAbsent(account, k -> new AccountRecord());
        }

        io.submit(() -> doSave(account, rec));
    }

    private void doSave(String account, AccountRecord rec)
    {
        final Path file = fileFor(account);
        try {
            Files.createDirectories(file.getParent());

            // Rotate existing file to backups
            if (Files.exists(file)) {
                Path backups = file.getParent().resolve("backups");
                Files.createDirectories(backups);
                String ts = new SimpleDateFormat("yyyyMMddHHmmss").format(new Date());
                Path bak = backups.resolve(FILE_NAME + "." + ts + ".bak");
                safeMove(file, bak, StandardCopyOption.ATOMIC_MOVE, StandardCopyOption.REPLACE_EXISTING);

                // Prune old backups
                try {
                    Files.list(backups)
                            .filter(p -> p.getFileName().toString().startsWith(FILE_NAME + "."))
                            .sorted(Comparator.comparing(Path::getFileName).reversed())
                            .skip(MAX_BACKUPS)
                            .forEach(p -> {
                                try { Files.deleteIfExists(p); } catch (IOException ignore) {}
                            });
                } catch (IOException ignore) { }
            }

            // Write JSON to tmp then atomically replace
            Path tmp = file.resolveSibling(FILE_NAME + ".tmp");
            try (BufferedWriter w = Files.newBufferedWriter(tmp, StandardCharsets.UTF_8)) {
                gson.toJson(rec, w);
            }
            safeMove(tmp, file, StandardCopyOption.ATOMIC_MOVE, StandardCopyOption.REPLACE_EXISTING);
        }
        catch (IOException e) {
            log.error("Failed to save obtained items for {}", account, e);
        }
    }

    private synchronized void requestFlush()
    {
        if (pendingFlush != null) {
            pendingFlush.cancel(false);
            pendingFlush = null;
        }
        pendingFlush = scheduler.schedule(this::save, FLUSH_DELAY_MS, java.util.concurrent.TimeUnit.MILLISECONDS);
    }

    private static void safeMove(Path source, Path target, CopyOption... opts) throws IOException
    {
        try {
            Files.move(source, target, opts);
        } catch (AtomicMoveNotSupportedException | AccessDeniedException ex) {
            // Retry without ATOMIC_MOVE but with REPLACE_EXISTING
            Set<CopyOption> fallback = new HashSet<>(Arrays.asList(opts));
            fallback.remove(StandardCopyOption.ATOMIC_MOVE);
            fallback.add(StandardCopyOption.REPLACE_EXISTING);
            Files.move(source, target, fallback.toArray(new CopyOption[0]));
        }
    }

    private static AccountRecord sanitize(AccountRecord r)
    {
        AccountRecord out = new AccountRecord();
        if (r == null) return out;
        // copy PER_ACCOUNT set
        out.all.addAll(r.all);
        // copy PER_NPC map (and wrap each set)
        for (Map.Entry<String, Set<Integer>> e : r.npcs.entrySet()) {
            Set<Integer> src = (e.getValue() != null) ? e.getValue() : Collections.emptySet();
            out.npcs.put(e.getKey(), Collections.synchronizedSet(new LinkedHashSet<>(src)));
        }
        return out;
    }

    private static Path baseDirFor(String account)
    {
        return RUNELITE_DIR.toPath().resolve("lootledger").resolve(account);
    }

    private static Path fileFor(String account)
    {
        return baseDirFor(account).resolve(FILE_NAME);
    }

    public synchronized boolean isObtained(String account, String npcName, int itemId, Scope scope)
    {
        AccountRecord r = data.computeIfAbsent(account, k -> new AccountRecord());
        if (scope == Scope.PER_ACCOUNT) {
            return r.all.contains(itemId);
        }
        return r.npcs.getOrDefault(npcName, Collections.emptySet()).contains(itemId);
    }

    public synchronized void markObtained(String account, String npcName, int itemId, Scope scope)
    {
        AccountRecord r = data.computeIfAbsent(account, k -> new AccountRecord());
        if (scope == Scope.PER_ACCOUNT) {
            r.all.add(itemId);
        } else {
            r.npcs.computeIfAbsent(npcName, x -> Collections.synchronizedSet(new LinkedHashSet<>())).add(itemId);
        }
        requestFlush();
    }

    public synchronized void unmarkObtained(String account, String npcName, int itemId, Scope scope)
    {
        AccountRecord r = data.computeIfAbsent(account, k -> new AccountRecord());
        if (scope == Scope.PER_ACCOUNT) {
            r.all.remove(itemId);
        } else {
            Set<Integer> set = r.npcs.get(npcName);
            if (set != null) {
                set.remove(itemId);
                if (set.isEmpty()) {
                    r.npcs.remove(npcName);
                }
            }
        }
        requestFlush();
    }

    /** Toggle obtained state; returns the new state (true if now obtained). */
    public synchronized boolean toggleObtained(String account, String npcName, int itemId, Scope scope)
    {
        boolean currently = isObtained(account, npcName, itemId, scope);
        if (currently) {
            unmarkObtained(account, npcName, itemId, scope);
            return false;
        } else {
            markObtained(account, npcName, itemId, scope);
            return true;
        }
    }

    public synchronized Set<Integer> getObtainedSet(String account, String npcName, Scope scope)
    {
        AccountRecord r = data.computeIfAbsent(account, k -> new AccountRecord());
        Set<Integer> out = new LinkedHashSet<>();
        if (scope == Scope.PER_ACCOUNT) {
            out.addAll(r.all);
        } else {
            out.addAll(r.npcs.getOrDefault(npcName, Collections.emptySet()));
        }
        return out;
    }

    public void shutdown() {
        final ScheduledFuture<?> pf = pendingFlush;
        if (pf != null) { pf.cancel(false); }
        scheduler.shutdown();
        io.shutdown();
    }
}

package com.lootledger;

import net.runelite.client.config.*;

@ConfigGroup("lootledger")
public interface LootLedgerConfig extends Config
{
    enum Scope { PER_ACCOUNT, PER_NPC }
    enum ObtainedView { ALL, HIDE_OBTAINED, ONLY_OBTAINED }

    @ConfigItem(
            keyName = "trackObtained",
            name = "Track obtained items",
            description = "Enable tracking of items you loot. Uses the scope below.",
            position = 0
    )
    default boolean trackObtained() { return false; }

    @ConfigItem(
            keyName = "obtainedScope",
            name = "Tracking scope",
            description = "Store obtained items per account or per NPC.",
            position = 1
    )
    default Scope obtainedScope() { return Scope.PER_ACCOUNT; }

    @ConfigItem(
            keyName = "obtainedView",
            name = "Obtained visibility",
            description = "How to display obtained drops in the Music tab.",
            position = 2
    )
    default ObtainedView obtainedView() { return ObtainedView.ALL; }

    // Existing options kept (gem/RDT + sort)
    @ConfigItem(
            keyName = "showRareDropTable",
            name = "Show Rare Drop Table",
            description = "Include RDT sections in drop lists.",
            position = 10
    )
    default boolean showRareDropTable() { return true; }

    @ConfigItem(
            keyName = "showGemDropTable",
            name = "Show Gem Drop Table",
            description = "Include gem table sections in drop lists.",
            position = 11
    )
    default boolean showGemDropTable() { return true; }

    @ConfigItem(
            keyName = "sortDropsByRarity",
            name = "Sort by rarity",
            description = "Sort drops from common to rare (unknowns last).",
            position = 12
    )
    default boolean sortDropsByRarity() { return true; }
}

package com.lootledger.ui;

import com.lootledger.LootLedgerConfig;
import com.lootledger.account.AccountManager;
import com.lootledger.drops.DropItem;
import com.lootledger.drops.NpcDropData;
import com.lootledger.managers.ObtainedItemsManager;
import lombok.Getter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.ScriptEvent;
import net.runelite.api.widgets.ItemQuantityMode;
import net.runelite.api.widgets.JavaScriptCallback;
import net.runelite.api.widgets.Widget;
import net.runelite.api.widgets.WidgetType;
import net.runelite.client.callback.ClientThread;

import javax.inject.Inject;
import javax.inject.Singleton;
import javax.swing.*;
import java.util.*;
import java.util.stream.Collectors;

@Slf4j
@Singleton
public class MusicWidgetController
{
    private static final int MUSIC_GROUP = 239;
    private static final int ICON_SIZE = 32;
    private static final int PADDING = 4;
    private static final int COLUMNS = 4;
    private static final int MARGIN_X = 8;
    private static final int MARGIN_Y = 8;
    private static final int BAR_HEIGHT = 15;
    private static final float WIDTH_RATIO = 0.7f;
    private static final int EYE_SIZE = 20;
    private static final int SEARCH_SPRITE = 1113;

    private final Client client;
    private final ClientThread clientThread;
    private final ObtainedItemsManager obtainedItemsManager;
    private final AccountManager accountManager;
    private final SpriteOverrideManager spriteOverrideManager;
    private final ItemSpriteCache itemSpriteCache;
    private final LootLedgerConfig config;
    private final NpcSearchService searchService;

    private NpcDropData currentDrops = null;
    private List<Widget> backupJukeboxStaticKids = null;
    private List<Widget> backupJukeboxDynamicKids = null;
    private List<Widget> backupScrollStaticKids = null;
    private List<Widget> backupScrollDynamicKids = null;
    private String originalTitleText = null;
    @Getter private final Map<Widget, DropItem> iconItemMap = new LinkedHashMap<>();
    @Getter private boolean overrideActive = false;
    private boolean hideObtainedItems = false;

    @Inject
    public MusicWidgetController(
            Client client,
            ClientThread clientThread,
            ObtainedItemsManager obtainedItemsManager,
            AccountManager accountManager,
            SpriteOverrideManager spriteOverrideManager,
            ItemSpriteCache itemSpriteCache,
            LootLedgerConfig config,
            NpcSearchService searchService)
    {
        this.client = client;
        this.clientThread = clientThread;
        this.obtainedItemsManager = obtainedItemsManager;
        this.accountManager = accountManager;
        this.spriteOverrideManager = spriteOverrideManager;
        this.itemSpriteCache = itemSpriteCache;
        this.config = config;
        this.searchService = searchService;
    }

    public boolean hasData() { return currentDrops != null; }
    public NpcDropData getCurrentData() { return currentDrops; }

    /** Replace the music widget with a drop table view for the given NPC. */
    public void override(NpcDropData dropData)
    {
        if (dropData == null) { return; }
        currentDrops = dropData;
        hideObtainedItems = false;
        if (!overrideActive)
        {
            overrideActive = true;
            clientThread.invokeLater(() ->
            {
                applyOverride(dropData);
                spriteOverrideManager.register();
            });
        }
        else
        {
            clientThread.invokeLater(() -> applyOverride(dropData));
        }
    }

    /** Remove the drop table overlay and restore the original music widget. */
    public void restore()
    {
        if (!overrideActive) { return; }
        spriteOverrideManager.unregister();
        itemSpriteCache.clear();
        hideObtainedItems = false;
        clientThread.invokeLater(this::revertOverride);
    }

    private boolean isTracking() { return config.trackObtained(); }

    private Set<Integer> getObtainedIdsForCurrent()
    {
        if (!isTracking()) { return Collections.emptySet(); }
        if (currentDrops == null) { return Collections.emptySet(); }
        final String account = accountManager.getPlayerName();
        if (account == null) { return Collections.emptySet(); }
        return obtainedItemsManager.getObtainedSet(
                account,
                currentDrops.getName(),
                mapScope(config.obtainedScope())
        );
    }

    private void updateIconsVisibilityAndLayout()
    {
        if (currentDrops == null) { return; }

        final Set<Integer> obtainedIds = getObtainedIdsForCurrent();

        Widget scrollable = client.getWidget(MUSIC_GROUP, 4);
        Widget scrollbar = client.getWidget(MUSIC_GROUP, 7);

        int displayIndex = 0;
        for (Map.Entry<Widget, DropItem> e : iconItemMap.entrySet())
        {
            Widget icon = e.getKey();
            DropItem d = e.getValue();
            boolean obtained = obtainedIds.contains(d.getItemId());

            if (hideObtainedItems && obtained)
            {
                icon.setHidden(true);
            }
            else
            {
                icon.setHidden(false);
                int col = displayIndex % COLUMNS;
                int row = displayIndex / COLUMNS;
                int x = MARGIN_X + col * (ICON_SIZE + PADDING);
                int y = MARGIN_Y + row * (ICON_SIZE + PADDING);
                icon.setOriginalX(x);
                icon.setOriginalY(y);
                // When tracking is off, show everything fully opaque (no dimming)
                icon.setOpacity(!isTracking() ? 0 : (obtained ? 0 : 150));
                icon.revalidate();
                displayIndex++;
            }
        }

        int rows = (displayIndex + COLUMNS - 1) / COLUMNS;
        if (scrollable != null)
        {
            scrollable.setScrollHeight(MARGIN_Y * 2 + rows * (ICON_SIZE + PADDING));
            scrollable.revalidate();
        }
        if (scrollbar != null)
        {
            scrollbar.revalidateScroll();
        }
    }

    private static List<Widget> copyChildren(Widget parent, boolean dynamic)
    {
        if (parent == null) { return new ArrayList<>(); }
        Widget[] kids = dynamic ? parent.getDynamicChildren() : parent.getChildren();
        return kids != null ? new ArrayList<>(Arrays.asList(kids)) : new ArrayList<>();
    }

    private static void restoreChildren(Widget parent, List<Widget> staticKids, List<Widget> dynamicKids)
    {
        if (parent == null) { return; }

        Widget[] currentStatic = parent.getChildren();
        if (currentStatic != null)
        {
            for (Widget w : currentStatic) { w.setHidden(true); }
        }

        Widget[] currentDyn = parent.getDynamicChildren();
        if (currentDyn != null)
        {
            for (Widget w : currentDyn) { w.setHidden(true); }
        }

        if (staticKids != null)
        {
            for (Widget w : staticKids) { w.setHidden(false); }
        }
        if (dynamicKids != null)
        {
            for (Widget w : dynamicKids) { w.setHidden(false); }
        }

        parent.revalidate();
    }

    private Widget updateTitle(NpcDropData dropData)
    {
        Widget title = client.getWidget(MUSIC_GROUP, 8);
        if (title != null)
        {
            if (originalTitleText == null) { originalTitleText = title.getText(); }
            title.setText(dropData.getName());
            title.revalidate();
        }
        return title;
    }

    private void drawProgressBarAndToggle(Widget root, Widget title, NpcDropData dropData, int obtainedCount, int totalDrops)
    {
        int fontId = title != null ? title.getFontId() : 0;
        boolean shadowed = title != null && title.getTextShadowed();

        int lvlX = Objects.requireNonNull(title).getOriginalX() + title.getOriginalWidth() + 83;
        int lvlY = title.getOriginalY();

        Widget lvl = root.createChild(-1);
        lvl.setHidden(false);
        lvl.setType(WidgetType.TEXT);
        lvl.setText(String.format("Lvl %d", dropData.getLevel()));
        lvl.setFontId(fontId);
        lvl.setTextShadowed(shadowed);
        lvl.setTextColor(0x00b33c);
        lvl.setOriginalX(lvlX);
        lvl.setOriginalY(lvlY);
        lvl.setOriginalWidth(title.getOriginalWidth());
        lvl.setOriginalHeight(title.getOriginalHeight());
        lvl.revalidate();

        Widget oldBar = client.getWidget(MUSIC_GROUP, 9);
        if (oldBar == null) { return; }
        int xOld = oldBar.getOriginalX();
        int yOld = oldBar.getOriginalY();
        int wOld = oldBar.getOriginalWidth();
        int hOld = oldBar.getOriginalHeight();

        int newW = Math.round(wOld * WIDTH_RATIO);
        int newY = yOld + (hOld - BAR_HEIGHT) / 2;

        Widget bg = root.createChild(-1);
        bg.setHidden(false);
        bg.setType(WidgetType.RECTANGLE);
        bg.setOriginalX(xOld);
        bg.setOriginalY(newY);
        bg.setOriginalWidth(newW);
        bg.setOriginalHeight(BAR_HEIGHT);
        bg.setFilled(true);
        bg.setTextColor(0x000000);
        bg.revalidate();

        final int border = 1;
        int innerWidth = newW - border * 2;
        int fillW = totalDrops > 0 ? Math.round(innerWidth * (float) obtainedCount / totalDrops) : 0;

        Widget fill = root.createChild(-1);
        fill.setHidden(false);
        fill.setType(WidgetType.RECTANGLE);
        fill.setOriginalX(xOld + border);
        fill.setOriginalY(newY + border);
        fill.setOriginalWidth(fillW);
        fill.setOriginalHeight(BAR_HEIGHT - border * 2);
        fill.setFilled(true);
        fill.setTextColor(0x00b33c);
        fill.revalidate();

        String txt = String.format("%d/%d", obtainedCount, totalDrops);
        Widget label = root.createChild(-1);
        label.setHidden(false);
        label.setType(WidgetType.TEXT);
        label.setText(txt);
        label.setTextColor(0xFFFFFF);
        label.setFontId(fontId);
        label.setTextShadowed(shadowed);
        label.setOriginalWidth(newW);
        label.setOriginalHeight(BAR_HEIGHT);
        label.setOriginalX(xOld + (newW / 2) - (txt.length() * 4));
        label.setOriginalY(newY + (BAR_HEIGHT / 2) - 6);
        label.revalidate();

        int eyeX = xOld + newW + 4;
        int eyeY = newY + (BAR_HEIGHT / 2) - (EYE_SIZE / 2);

        Widget eye = root.createChild(-1);
        eye.setHidden(false);
        eye.setType(WidgetType.GRAPHIC);
        eye.setOriginalX(eyeX);
        eye.setOriginalY(eyeY);
        eye.setOriginalWidth(EYE_SIZE);
        eye.setOriginalHeight(EYE_SIZE);
        eye.setSpriteId(hideObtainedItems ? 2222 : 2221);
        eye.revalidate();
        if (isTracking())
        {
            eye.setAction(0, "Toggle obtained items");
            eye.setOnOpListener((JavaScriptCallback) (ScriptEvent ev) ->
            {
                hideObtainedItems = !hideObtainedItems;
                updateIconsVisibilityAndLayout();
                eye.setSpriteId(hideObtainedItems ? 2222 : 2221);
                eye.revalidate();
            });
            eye.setHasListener(true);
        }
        else
        {
            eye.setAction(0, "Enable tracking in settings to filter");
            eye.setHasListener(false);
        }

        int searchX = eyeX + EYE_SIZE + PADDING;
        int searchY = eyeY;

        Widget search = root.createChild(-1);
        search.setHidden(false);
        search.setType(WidgetType.GRAPHIC);
        search.setOriginalX(searchX);
        search.setOriginalY(searchY);
        search.setOriginalWidth(EYE_SIZE);
        search.setOriginalHeight(EYE_SIZE);
        search.setSpriteId(SEARCH_SPRITE);
        search.revalidate();
        search.setAction(0, "Search Drops");
        search.setOnOpListener((JavaScriptCallback) ev -> showSearchDialog());
        search.setHasListener(true);

        root.revalidate();
    }

    /** Display a Swing dialog prompting the user for an NPC name or ID, then load and show. */
    private void showSearchDialog()
    {
        SwingUtilities.invokeLater(() ->
        {
            String query = JOptionPane.showInputDialog(
                    null,
                    "Enter NPC name or ID:",
                    "Search NPC",
                    JOptionPane.PLAIN_MESSAGE
            );
            if (query == null || query.trim().isEmpty()) { return; }

            final String q = query.trim();
            if (q.isEmpty()) { return; }
            Thread t = new Thread(() -> {
                List<NpcDropData> results = searchService.search(q);

                SwingUtilities.invokeLater(() -> {
                    if (results.isEmpty())
                    {
                        JOptionPane.showMessageDialog(
                                null,
                                "No NPCs found for: " + q,
                                "Search NPC",
                                JOptionPane.INFORMATION_MESSAGE
                        );
                        return;
                    }

                    List<NpcDropData> limited = results.stream().limit(5).collect(Collectors.toList());
                    String[] choices = limited.stream()
                            .map(n -> String.format("%s (ID %d, Lvl %d)", n.getName(), n.getNpcId(), n.getLevel()))
                            .toArray(String[]::new);
                    int idx = JOptionPane.showOptionDialog(
                            null,
                            "Select NPC:",
                            "Search Results",
                            JOptionPane.DEFAULT_OPTION,
                            JOptionPane.PLAIN_MESSAGE,
                            null,
                            choices,
                            choices[0]
                    );
                    if (idx >= 0 && idx < limited.size())
                    {
                        override(limited.get(idx));
                    }
                });
            },"lootledger-search");
            t.setDaemon(true);
            t.start();
        });
    }

    private void drawDropIcons(Widget scrollable, Widget scrollbar, Widget jukebox, List<DropItem> drops, Set<Integer> obtainedIds)
    {
        if (scrollable == null || scrollbar == null) { return; }

        if (backupJukeboxStaticKids == null && jukebox != null) { backupJukeboxStaticKids = copyChildren(jukebox, false); }
        if (backupJukeboxDynamicKids == null && jukebox != null) { backupJukeboxDynamicKids = copyChildren(jukebox, true); }
        if (backupScrollStaticKids == null) { backupScrollStaticKids = copyChildren(scrollable, false); }
        if (backupScrollDynamicKids == null) { backupScrollDynamicKids = copyChildren(scrollable, true); }

        if (jukebox != null) WidgetUtils.hideAllChildrenSafely(jukebox);
        WidgetUtils.hideAllChildrenSafely(scrollable);

        boolean trackingOn = isTracking();

        for (DropItem d : drops)
        {
            final int itemId = d.getItemId();
            final boolean isObt = obtainedIds.contains(itemId);

            Widget icon = scrollable.createChild(-1);
            icon.setHidden(false);
            icon.setType(WidgetType.GRAPHIC);
            int spriteId = itemSpriteCache.getSpriteId(itemId);
            icon.setSpriteId(spriteId);
            icon.setItemQuantityMode(ItemQuantityMode.NEVER);
            icon.setOriginalX(MARGIN_X);
            icon.setOriginalY(MARGIN_Y);
            icon.setOriginalWidth(ICON_SIZE);
            icon.setOriginalHeight(ICON_SIZE);
            // Only dim when tracking is enabled; otherwise show fully opaque.
            icon.setOpacity(trackingOn ? (isObt ? 0 : 150) : 0);
            icon.revalidate();

            // Click/Context action to toggle obtained state when tracking is enabled
            if (trackingOn)
            {
                icon.setAction(0, isObt ? "Mark as Unobtained" : "Mark as Obtained");
                icon.setOnOpListener((JavaScriptCallback) (ScriptEvent ev) -> toggleObtained(itemId));
                icon.setHasListener(true);
            }
            else
            {
                icon.setAction(0, "Enable tracking in settings to toggle");
                icon.setHasListener(false);
            }

            iconItemMap.put(icon, d);
        }

        updateIconsVisibilityAndLayout();
    }

    private void toggleObtained(int itemId)
    {
        if (!isTracking()) { return; }
        if (currentDrops == null) { return; }
        final String account = accountManager.getPlayerName();
        if (account == null) { return; }

        final ObtainedItemsManager.Scope scope = mapScope(config.obtainedScope());
        final String npcName = currentDrops.getName();
        boolean already = obtainedItemsManager.isObtained(account, npcName, itemId, scope);
        if (already)
        {
            obtainedItemsManager.unmarkObtained(account, npcName, itemId, scope);
        }
        else
        {
            obtainedItemsManager.markObtained(account, npcName, itemId, scope);
        }

        // Re-render to update progress bar, opacity, and actions
        override(currentDrops);
    }

    private void applyOverride(NpcDropData dropData)
    {
        iconItemMap.clear();
        int[] toHide = {9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19};
        for (int childId : toHide)
        {
            Widget w = client.getWidget(MUSIC_GROUP, childId);
            if (w != null) { w.setHidden(true); }
        }

        List<DropItem> drops = dropData.getDropTableSections().stream()
                .filter(sec ->
                {
                    String h = sec.getHeader();
                    if (h == null) { return true; }
                    String lower = h.toLowerCase();
                    if (lower.contains("rare and gem drop table")) { return config.showRareDropTable() && config.showGemDropTable(); }
                    if (!config.showRareDropTable() && lower.contains("rare drop table")) { return false; }
                    if (!config.showGemDropTable() && lower.contains("gem drop table")) { return false; }
                    return true;
                })
                .flatMap(sec -> sec.getItems().stream())
                .collect(Collectors.toList());
        drops = WidgetUtils.dedupeAndSort(drops, config.sortDropsByRarity());

        final Set<Integer> obtainedIds = getObtainedIdsForCurrent();

        int totalDrops = drops.size();
        int obtainedCount = !isTracking() ? totalDrops : (int) drops.stream().filter(d -> obtainedIds.contains(d.getItemId())).count();

        Widget root = client.getWidget(MUSIC_GROUP, 0);
        Widget title = updateTitle(dropData);

        if (root != null)
        {
            root.setHidden(false);
            root.setType(WidgetType.LAYER);
            WidgetUtils.hideAllChildrenSafely(root);

            drawProgressBarAndToggle(root, title, dropData, obtainedCount, totalDrops);
        }

        Widget scrollable = client.getWidget(MUSIC_GROUP, 4);
        Widget jukebox = client.getWidget(MUSIC_GROUP, 6);
        Widget scrollbar = client.getWidget(MUSIC_GROUP, 7);

        drawDropIcons(scrollable, scrollbar, jukebox, drops, obtainedIds);

        if (root != null) { root.revalidate(); }
    }

    private void revertOverride()
    {
        if (!overrideActive) { return; }

        Widget root = client.getWidget(MUSIC_GROUP, 0);
        Widget scrollable = client.getWidget(MUSIC_GROUP, 4);
        Widget jukebox = client.getWidget(MUSIC_GROUP, 6);

        if (root != null)
        {
            Widget[] dynRoot = root.getDynamicChildren();
            if (dynRoot != null)
            {
                for (Widget w : dynRoot)
                {
                    w.setHidden(true);
                    w.revalidate();
                }
            }
        }

        restoreChildren(scrollable, backupScrollStaticKids, backupScrollDynamicKids);
        restoreChildren(jukebox, backupJukeboxStaticKids, backupJukeboxDynamicKids);

        Widget title = client.getWidget(MUSIC_GROUP, 8);
        Widget overlay = client.getWidget(MUSIC_GROUP, 5);
        Widget scrollbar = client.getWidget(MUSIC_GROUP, 7);
        Widget progress = client.getWidget(MUSIC_GROUP, 9);

        if (title != null && originalTitleText != null)
        {
            title.setText(originalTitleText);
            title.revalidate();
            for (int id = 9; id <= 19; id++)
            {
                Widget w = client.getWidget(MUSIC_GROUP, id);
                if (w != null)
                {
                    w.setHidden(false);
                    w.revalidate();
                }
            }
        }

        if (overlay != null) { overlay.setHidden(false); overlay.revalidate(); }
        if (scrollbar != null) { scrollbar.setHidden(false); scrollbar.revalidate(); }
        if (progress != null) { progress.setHidden(false); progress.revalidate(); }

        if (root != null && root.getOnLoadListener() != null)
        { client.createScriptEvent(root.getOnLoadListener()).setSource(root).run(); root.revalidate(); }
        if (overlay != null && overlay.getOnLoadListener() != null)
        { client.createScriptEvent(overlay.getOnLoadListener()).setSource(overlay).run(); overlay.revalidate(); }
        if (scrollbar != null && scrollbar.getOnLoadListener() != null)
        { client.createScriptEvent(scrollbar.getOnLoadListener()).setSource(scrollbar).run(); scrollbar.revalidate(); }
        if (jukebox != null && jukebox.getOnLoadListener() != null)
        { client.createScriptEvent(jukebox.getOnLoadListener()).setSource(jukebox).run(); jukebox.revalidate(); }

        originalTitleText = null;
        currentDrops = null;
        overrideActive = false;
        backupJukeboxStaticKids = null;
        backupJukeboxDynamicKids = null;
        backupScrollStaticKids = null;
        backupScrollDynamicKids = null;
        iconItemMap.clear();
    }

    private ObtainedItemsManager.Scope mapScope(LootLedgerConfig.Scope s)
    {
        return s == LootLedgerConfig.Scope.PER_NPC ? ObtainedItemsManager.Scope.PER_NPC : ObtainedItemsManager.Scope.PER_ACCOUNT;
    }
}

package com.lootledger.ui;

import com.lootledger.drops.DropCache;
import lombok.extern.slf4j.Slf4j;

import javax.inject.Inject;
import javax.inject.Singleton;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

import net.runelite.api.Client;
import net.runelite.api.MenuAction;
import net.runelite.api.MenuEntry;
import net.runelite.api.NPC;
import net.runelite.api.events.MenuOpened;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.eventbus.Subscribe;

@Slf4j
@Singleton
public class DropsMenuListener
{
    private final Client client;
    private final ClientThread clientThread;
    private final DropCache dropCache;
    private final MusicWidgetController widgetController;

    @Inject
    public DropsMenuListener(
            Client client,
            ClientThread clientThread,
            DropCache dropCache,
            MusicWidgetController widgetController
    )
    {
        this.client = client;
        this.clientThread = clientThread;
        this.dropCache = dropCache;
        this.widgetController = widgetController;
    }

    @Subscribe
    public void onMenuOpened(MenuOpened event)
    {
        final List<MenuEntry> entries = new ArrayList<>(Arrays.asList(event.getMenuEntries()));

        NPC target = null;
        MenuEntry anchorEntry = null; // fallback anchor (any NPC entry)
        int anchorIdx = -1;

        MenuEntry attackEntry = null;  // preferred anchor if present
        int attackIdx = -1;

        for (int i = 0; i < entries.size(); i++)
        {
            final MenuEntry e = entries.get(i);
            final MenuAction type = e.getType();

            // Consider any NPC option line as a valid anchor
            if (isNpcMenuAction(type))
            {
                // Resolve the NPC by identifier; guard for bad indices
                try
                {
                    NPC possible = client.getTopLevelWorldView().npcs().byIndex(e.getIdentifier());
                    if (possible != null)
                    {
                        // Record the first NPC entry as a general anchor
                        if (anchorEntry == null)
                        {
                            anchorEntry = e;
                            anchorIdx = i;
                            target = possible;
                        }

                        // If this line is Attack, prefer it
                        if ("Attack".equalsIgnoreCase(e.getOption()))
                        {
                            attackEntry = e;
                            attackIdx = i;
                            target = possible;
                            break; // Prefer Attack; stop scanning
                        }
                    }
                }
                catch (ArrayIndexOutOfBoundsException ex)
                {
                    // ignore invalid indices
                }
            }
        }

        // Choose the best available anchor
        final MenuEntry useEntry = (attackEntry != null ? attackEntry : anchorEntry);
        final int useIdx = (attackEntry != null ? attackIdx : anchorIdx);

        if (useEntry == null || target == null)
        {
            return; // no NPC line in the menu
        }

        final int id = target.getId();
        final String name = target.getName();
        final int level = target.getCombatLevel();

        // Build our custom menu entry; position near the anchor line
        final MenuEntry showDrops = WidgetUtils.createShowDropsEntry(
                client,
                Math.max(0, useIdx - 1),
                useEntry
        );
        showDrops.onClick(me -> fetchAndDisplayDrops(id, name, level, 1));

        entries.add(useIdx + 1, showDrops);
        event.setMenuEntries(entries.toArray(new MenuEntry[0]));
    }

    private static boolean isNpcMenuAction(MenuAction type)
    {
        return type == MenuAction.NPC_FIRST_OPTION
                || type == MenuAction.NPC_SECOND_OPTION
                || type == MenuAction.NPC_THIRD_OPTION
                || type == MenuAction.NPC_FOURTH_OPTION
                || type == MenuAction.NPC_FIFTH_OPTION
                || type == MenuAction.EXAMINE_NPC;
    }

    private void fetchAndDisplayDrops(int id, String name, int level, int attemptsLeft)
    {
        dropCache.get(id, name, level)
                .whenComplete((dropData, ex) ->
                {
                    if (dropData != null && ex == null)
                    {
                        clientThread.invokeLater(() -> widgetController.override(dropData));
                        return;
                    }

                    if (attemptsLeft > 0)
                    {
                        fetchAndDisplayDrops(id, name, level, attemptsLeft - 1);
                    }
                    else
                    {
                        if (ex != null) {
                            log.error("Failed to fetch drop data for {}", name, ex);
                        } else {
                            log.error("Failed to fetch drop data for {} (no error cause)", name);
                        }
                    }
                });
    }
}

package com.lootledger.ui;

import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.SpriteID;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.game.SpriteManager;
import net.runelite.client.game.SpriteOverride;

import javax.inject.Inject;
import javax.inject.Singleton;

/**
 * Overrides the RuneLite music tab sprite with drops.png.
 * Call register() when showing drops and unregister() to restore the original.
 * Clears the widget sprite cache to force the client to pick up the new override.
 */
@Slf4j
@Singleton
public class SpriteOverrideManager implements SpriteOverride
{
    private static final int SPRITE_ID = SpriteID.TAB_MUSIC;
    private static final String RESOURCE_PATH = "/com/lootledger/loot_ledger.png";

    private final SpriteManager spriteManager;
    private final Client client;
    private final ClientThread clientThread;

    @Inject
    public SpriteOverrideManager(SpriteManager spriteManager, Client client, ClientThread clientThread)
    {
        this.spriteManager = spriteManager;
        this.client = client;
        this.clientThread = clientThread;
    }

    /**
     * Apply the custom drops icon override.
     */
    public void register()
    {
        spriteManager.addSpriteOverrides(new SpriteOverride[]{this});
        clientThread.invokeLater(() -> {
            client.getWidgetSpriteCache().reset();
        });
    }

    /**
     * Remove the override, restoring the original music tab icon.
     */
    public void unregister()
    {
        spriteManager.removeSpriteOverrides(new SpriteOverride[]{this});
        clientThread.invokeLater(() -> {
            client.getWidgetSpriteCache().reset();
        });
    }

    @Override
    public int getSpriteId()
    {
        return SPRITE_ID;
    }

    @Override
    public String getFileName()
    {
        // Resource path relative to the classpath
        return RESOURCE_PATH;
    }
}

package com.lootledger.ui;

import java.awt.Dimension;
import java.awt.Graphics2D;
import java.awt.FontMetrics;
import java.awt.Color;
import java.awt.Rectangle;
import java.util.Map;
import javax.inject.Inject;
import javax.inject.Singleton;

import com.lootledger.drops.DropItem;

import net.runelite.api.Client;
import net.runelite.api.Point;
import net.runelite.api.widgets.Widget;
import net.runelite.client.ui.overlay.Overlay;
import net.runelite.client.ui.overlay.OverlayLayer;
import net.runelite.client.ui.overlay.OverlayPosition;

/**
 * Overlay that displays item name tooltips when hovering drop icons
 * injected into the music tab by {@link MusicWidgetController}.
 */
@Singleton
public class DropsTooltipOverlay extends Overlay
{
    private final Client client;
    private final MusicWidgetController widgetController;

    @Inject
    public DropsTooltipOverlay(
            Client client,
            MusicWidgetController widgetController
    )
    {
        this.client = client;
        this.widgetController = widgetController;
        setPosition(OverlayPosition.DYNAMIC);
        setLayer(OverlayLayer.ABOVE_WIDGETS);
    }

    @Override
    public Dimension render(Graphics2D graphics)
    {
        if (!widgetController.isOverrideActive())
        {
            return null;
        }

        final Point mouse = client.getMouseCanvasPosition();
        for (Map.Entry<Widget, DropItem> entry : widgetController.getIconItemMap().entrySet())
        {
            final Widget w = entry.getKey();
            if (w == null || w.isHidden())
            {
                continue;
            }
            final Rectangle bounds = w.getBounds();
            if (bounds != null && bounds.contains(mouse.getX(), mouse.getY()))
            {
                final DropItem drop = entry.getValue();
                drawTooltip(graphics, drop.getName(), drop.getOneOverRarity(), mouse);
                break;
            }
        }
        return null;
    }

    private void drawTooltip(Graphics2D g, String name, String rarity, Point mouse)
    {
        if (name == null) name = "";
        if (rarity == null) rarity = "";

        final FontMetrics fm = g.getFontMetrics();
        final int padding = 4;
        final int gap = 2;
        final int lineH  = fm.getHeight();

        final String rateText = "Rate: " + rarity;

        final int nameW = fm.stringWidth(name);
        final int rateW = fm.stringWidth(rateText);

        final int nameBoxW = nameW + padding * 2;
        final int rateBoxW = rateW + padding * 2;
        final int boxH     = lineH + padding * 2;
        final int totalH   = boxH * 2 + gap;
        final int clampW   = Math.max(nameBoxW, rateBoxW);

        int x = mouse.getX() + 10;
        int y = mouse.getY() - 10;

        Rectangle clip = g.getClipBounds();
        if (clip == null)
        {
            // Fallback to game canvas size if clip is null
            clip = new Rectangle(0, 0, client.getCanvasWidth(), client.getCanvasHeight());
        }

        x = Math.max(clip.x, Math.min(x, clip.x + clip.width  - clampW));
        y = Math.max(clip.y + totalH, Math.min(y, clip.y + clip.height));

        final int nameTop = y - totalH;
        drawBox(g, x, nameTop, nameBoxW, boxH);
        drawBox(g, x, y - boxH, rateBoxW, boxH);

        g.setColor(Color.WHITE);
        final int base = nameTop + padding + fm.getAscent();
        g.drawString(name, x + padding, base);

        final int rateBase = y - boxH + padding + fm.getAscent();
        final String prefix = "Rate: ";
        final int prefixW = fm.stringWidth(prefix);

        g.setColor(Color.WHITE);
        g.drawString(prefix, x + padding, rateBase);

        g.setColor(Color.ORANGE);
        g.drawString(rarity, x + padding + prefixW, rateBase);
    }

    private void drawBox(Graphics2D g, int x, int y, int w, int h)
    {
        g.setColor(new Color(0, 0, 0, 160));
        g.fillRect(x, y, w, h);
        g.setColor(new Color(50, 50, 50, 220));
        g.drawRect(x, y, w, h);
    }
}

package com.lootledger.ui;

import com.lootledger.drops.DropItem;
import net.runelite.api.Client;
import net.runelite.api.MenuAction;
import net.runelite.api.MenuEntry;
import net.runelite.api.widgets.Widget;

import java.util.Comparator;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Objects;
import java.util.stream.Collectors;

public final class WidgetUtils
{
    private WidgetUtils() {}

    /**
     * Creates a "Show Drops" menu entry modeled after the given anchor entry.
     * Ensures a non-negative insert index and mirrors target/identifier/params
     * so the line sits near the source action.
     */
    public static MenuEntry createShowDropsEntry(
            Client client,
            int insertIndex,
            MenuEntry anchorEntry
    )
    {
        Objects.requireNonNull(client, "client");
        Objects.requireNonNull(anchorEntry, "anchorEntry");

        final int idx = Math.max(0, insertIndex);
        return client.getMenu()
                .createMenuEntry(idx)
                .setOption("Show Drops")
                .setTarget(anchorEntry.getTarget())
                .setIdentifier(anchorEntry.getIdentifier())
                .setParam0(anchorEntry.getParam0())
                .setParam1(anchorEntry.getParam1())
                .setType(MenuAction.RUNELITE);
    }

    /**
     * Hides all static and dynamic children of the given widget, if any exist,
     * and requests a revalidate on the parent.
     */
    public static void hideAllChildrenSafely(Widget widget)
    {
        if (widget == null)
        {
            return;
        }

        Widget[] staticKids = widget.getChildren();
        if (staticKids != null)
        {
            for (Widget child : staticKids)
            {
                if (child != null) child.setHidden(true);
            }
        }

        Widget[] dynamicKids = widget.getDynamicChildren();
        if (dynamicKids != null)
        {
            for (Widget child : dynamicKids)
            {
                if (child != null) child.setHidden(true);
            }
        }

        widget.revalidate();
    }

    /**
     * Deduplicates a list of DropItems by item ID and optionally sorts them by rarity.
     * <p>
     * When sorting by rarity, the resulting list is ordered from most common to rarest.
     * Unknown/unsupported rarities are treated as rarest.
     */
    public static List<DropItem> dedupeAndSort(List<DropItem> drops, boolean sortByRarity)
    {
        return drops.stream()
                .filter(d -> d != null && d.getItemId() > 0)
                .collect(Collectors.toMap(
                        DropItem::getItemId,
                        d -> d,
                        (first, second) -> first,
                        LinkedHashMap::new
                ))
                .values().stream()
                .sorted(sortByRarity
                        ? Comparator.comparingDouble(DropItem::getRarityValue)
                        .thenComparingInt(DropItem::getItemId)
                        : Comparator.comparingInt(DropItem::getItemId))
                .collect(Collectors.toList());
    }
}

package com.lootledger.ui;

import com.lootledger.drops.DropCache;
import com.lootledger.drops.NpcDropData;

import javax.inject.Inject;
import javax.inject.Singleton;
import java.util.*;
import java.util.concurrent.CompletableFuture;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.stream.Collectors;

/**
 * Provides fuzzy search over available NPC drop data. The cache is consulted
 * first and any misses fall back to a wiki lookup. Results without drop tables
 * are discarded and lookups for multiple candidates are performed in parallel
 * to keep searches snappy.
 */
@Singleton
public class NpcSearchService
{
    private static final Pattern ID_LEVEL_PATTERN  = Pattern.compile("^(\\d+)\\s+(?:lvl|level)?\\s*(\\d+)$", Pattern.CASE_INSENSITIVE);
    private static final Pattern NAME_LVL_PATTERN  = Pattern.compile("^(.*)\\s+(?:lvl|level)\\s*(\\d+)$",       Pattern.CASE_INSENSITIVE);
    private static final Pattern LVL_NAME_PATTERN  = Pattern.compile("^(?:lvl|level)\\s*(\\d+)\\s+(.*)$",       Pattern.CASE_INSENSITIVE);
    private static final Pattern NAME_NUM_PATTERN  = Pattern.compile("^(.*\\D)\\s+(\\d+)$");
    private static final Pattern NUM_NAME_PATTERN  = Pattern.compile("^(\\d+)\\s+(\\D.*)$");

    private static final int NAME_FETCH_LIMIT = 10;

    private final DropCache dropCache;

    @Inject
    public NpcSearchService(DropCache dropCache)
    {
        this.dropCache = dropCache;
    }

    private static final class ParsedQuery
    {
        Integer npcId;
        Integer level;
        String  name;
    }

    private static ParsedQuery parse(String q)
    {
        if (q == null) return null;
        String s = q.trim();
        if (s.isEmpty()) return null;

        ParsedQuery pq = new ParsedQuery();
        Matcher m;

        // pure ID
        if (s.matches("\\d+"))
        {
            pq.npcId = Integer.valueOf(s);
            return pq;
        }
        // ID + level
        m = ID_LEVEL_PATTERN.matcher(s);
        if (m.matches())
        {
            pq.npcId = Integer.valueOf(m.group(1));
            pq.level = Integer.valueOf(m.group(2));
            return pq;
        }
        // name + level
        m = NAME_LVL_PATTERN.matcher(s);
        if (m.matches())
        {
            pq.name  = m.group(1).trim();
            pq.level = Integer.valueOf(m.group(2));
            return pq;
        }
        // level + name
        m = LVL_NAME_PATTERN.matcher(s);
        if (m.matches())
        {
            pq.level = Integer.valueOf(m.group(1));
            pq.name  = m.group(2).trim();
            return pq;
        }
        // trailing number = level
        m = NAME_NUM_PATTERN.matcher(s);
        if (m.matches())
        {
            pq.name  = m.group(1).trim();
            pq.level = Integer.valueOf(m.group(2));
            return pq;
        }
        // leading number = level
        m = NUM_NAME_PATTERN.matcher(s);
        if (m.matches())
        {
            pq.level = Integer.valueOf(m.group(1));
            pq.name  = m.group(2).trim();
            return pq;
        }

        // fallback to pure name
        pq.name = s;
        return pq;
    }

    /**
     * Search by partial name, level, or ID. Results are limited and ordered by
     * Levenshtein distance when appropriate.
     */
    public List<NpcDropData> search(String query)
    {
        ParsedQuery pq = parse(query);
        if (pq == null)
        {
            return Collections.emptyList();
        }

        // 1) name only → fetch all candidates by name
        if (pq.npcId == null && pq.level == null && pq.name != null)
        {
            List<String> names = safeJoin(dropCache.searchNpcNames(pq.name), Collections.emptyList());
            List<NpcDropData> fetched = fetchAll(names.stream().limit(NAME_FETCH_LIMIT).collect(Collectors.toList()), 0);
            final String key = pq.name.toLowerCase(Locale.ROOT);
            return dedupeById(fetched).stream()
                    .sorted(Comparator.comparingInt(d -> levenshtein(d.getName().toLowerCase(Locale.ROOT), key)))
                    .collect(Collectors.toList());
        }

        // 2) ID only → fetch by ID
        if (pq.npcId != null && pq.name == null)
        {
            int lvl = (pq.level != null ? pq.level : 0);
            NpcDropData d = safeJoin(dropCache.get(pq.npcId, "", lvl), null);
            if (d == null || d.getDropTableSections() == null || d.getDropTableSections().isEmpty())
            {
                return Collections.emptyList();
            }
            return Collections.singletonList(d);
        }

        // 3) mixed or partial → fuzzy search
        String nameFilter = (pq.name != null ? pq.name : "");
        int    lvlFilter  = (pq.level != null ? pq.level : -1);

        List<String> candidates = safeJoin(dropCache.searchNpcNames(nameFilter), Collections.emptyList());
        List<NpcDropData> all = fetchAll(candidates.stream().limit(NAME_FETCH_LIMIT).collect(Collectors.toList()),
                lvlFilter > -1 ? lvlFilter : 0);

        // if ID also provided, filter it
        if (pq.npcId != null)
        {
            all = all.stream().filter(d -> d.getNpcId() == pq.npcId).collect(Collectors.toList());
        }

        final int lvl = lvlFilter;
        final String key = nameFilter.toLowerCase(Locale.ROOT);
        return dedupeById(all).stream()
                .filter(d -> lvl < 0 || d.getLevel() == lvl)
                .sorted(Comparator.comparingInt(d -> levenshtein(d.getName().toLowerCase(Locale.ROOT), key)))
                .collect(Collectors.toList());
    }

    /** Fetch drop data for a list of names concurrently (exception-safe). */
    private List<NpcDropData> fetchAll(List<String> names, int level)
    {
        List<CompletableFuture<NpcDropData>> futures = names.stream()
                .map(n -> dropCache.get(0, n, level))
                .collect(Collectors.toList());

        // Wait for *all* without propagating the first failure
        CompletableFuture.allOf(futures.toArray(new CompletableFuture[0])).join();

        return futures.stream()
                .map(f -> f.exceptionally(ex -> null).join())
                .filter(Objects::nonNull)
                .filter(d -> d.getDropTableSections() != null && !d.getDropTableSections().isEmpty())
                .collect(Collectors.toList());
    }

    private static <T> T safeJoin(CompletableFuture<T> f, T fallback)
    {
        try { return f.join(); }
        catch (Exception ignored) { return fallback; }
    }

    private static List<NpcDropData> dedupeById(List<NpcDropData> list)
    {
        Map<Integer, NpcDropData> byId = new LinkedHashMap<>();
        for (NpcDropData d : list)
        {
            // Keep the first occurrence per NPC ID
            byId.putIfAbsent(d.getNpcId(), d);
        }
        return new ArrayList<>(byId.values());
    }

    // simple DP Levenshtein
    private static int levenshtein(String a, String b)
    {
        int[][] dp = new int[a.length()+1][b.length()+1];
        for (int i = 0; i <= a.length(); i++) dp[i][0] = i;
        for (int j = 0; j <= b.length(); j++) dp[0][j] = j;
        for (int i = 1; i <= a.length(); i++)
            for (int j = 1; j <= b.length(); j++)
                dp[i][j] = Math.min(
                        Math.min(dp[i-1][j] + 1, dp[i][j-1] + 1),
                        dp[i-1][j-1] + (a.charAt(i-1)==b.charAt(j-1) ? 0 : 1)
                );
        return dp[a.length()][b.length()];
    }
}

package com.lootledger.ui;

import javax.inject.Inject;
import javax.inject.Singleton;
import java.awt.image.BufferedImage;
import java.util.HashMap;
import java.util.Map;

import net.runelite.api.Client;
import net.runelite.api.SpritePixels;
import net.runelite.client.game.ItemManager;
import net.runelite.client.util.ImageUtil;

/**
 * Caches custom item sprites scaled for widget display.
 */
@Singleton
public class ItemSpriteCache
{
    private static final int ICON_SIZE = 32;

    private final ItemManager itemManager;
    private final Client client;
    private final Map<Integer, Integer> spriteIds = new HashMap<>();
    private int nextGeneratedSpriteId = 0x10000;

    @Inject
    public ItemSpriteCache(ItemManager itemManager, Client client)
    {
        this.itemManager = itemManager;
        this.client = client;
    }

    private int generateNextId()
    {
        return nextGeneratedSpriteId++;
    }

    /**
     * Returns a sprite ID for the given item. If the item image cannot be
     * resolved, returns -1 and does not register a sprite override.
     */
    public int getSpriteId(int itemId)
    {
        return spriteIds.computeIfAbsent(itemId, id ->
        {
            BufferedImage img = itemManager.getImage(id, 1, false);
            if (img == null)
            {
                return -1;
            }

            // resize to ICON_SIZE x ICON_SIZE
            BufferedImage resized = ImageUtil.resizeImage(img, ICON_SIZE, ICON_SIZE);

            // convert to SpritePixels for the client's override map
            SpritePixels pixels = ImageUtil.getImageSpritePixels(resized, client);
            if (pixels == null)
            {
                return -1;
            }

            // generate a unique sprite ID and register the override
            int spriteId = generateNextId();
            client.getSpriteOverrides().put(spriteId, pixels);

            return spriteId;
        });
    }

    /**
     * Clears all cached sprites and unregisters them from the client's override map.
     */
    public void clear()
    {
        spriteIds.values().forEach(id -> {
            try { client.getSpriteOverrides().remove(id); } catch (Exception ignored) {}
        });
        spriteIds.clear();
        nextGeneratedSpriteId = 0x10000;
    }
}

package com.lootledger.ui;

import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.VarClientInt;
import net.runelite.api.events.VarClientIntChanged;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.eventbus.Subscribe;

import javax.inject.Inject;
import javax.inject.Singleton;

@Slf4j
@Singleton
public class TabListener
{
    private final Client client;
    private final ClientThread clientThread;
    private final MusicWidgetController widgetController;

    @Inject
    public TabListener(
            Client client,
            ClientThread clientThread,
            MusicWidgetController widgetController
    )
    {
        this.client = client;
        this.clientThread = clientThread;
        this.widgetController = widgetController;
    }

    @Subscribe
    public void onVarClientIntChanged(VarClientIntChanged ev)
    {
        if (ev.getIndex() != VarClientInt.INVENTORY_TAB) return;

        int newTab = client.getVarcIntValue(VarClientInt.INVENTORY_TAB);
        if (widgetController.isOverrideActive() && newTab != 13)
        {
            clientThread.invokeLater(widgetController::restore);
        }
        else if (!widgetController.isOverrideActive() && newTab == 13 && widgetController.hasData())
        {
            clientThread.invokeLater(() ->
                    widgetController.override(widgetController.getCurrentData())
            );
        }
    }
}

package com.lootledger.account;

import lombok.Getter;
import lombok.Setter;
import net.runelite.api.Client;
import net.runelite.api.GameState;
import net.runelite.api.Player;
import net.runelite.api.events.AccountHashChanged;
import net.runelite.api.events.ClientTick;
import net.runelite.api.events.GameStateChanged;
import net.runelite.client.eventbus.EventBus;
import net.runelite.client.eventbus.Subscribe;

import javax.inject.Inject;
import javax.inject.Singleton;

/**
 * Monitors for account changes and updates the stored display name.
 */
@Singleton
public class AccountManager
{
	@Inject private Client client;
	@Inject private EventBus eventBus;

	private long hash = -1;
	@Getter @Setter private volatile String playerName;
	private boolean nameSet = false;

	public boolean ready() { return hash != -1 && nameSet; }

	public void init()
	{
		if (client.getGameState() == GameState.LOGGED_IN && client.getAccountHash() != -1)
		{
			hash = client.getAccountHash();
			nameSet = false;
		}
	}

	@Subscribe
	public void onAccountHashChanged(AccountHashChanged event)
	{
		long newHash = client.getAccountHash();
		if (hash != newHash)
		{
			hash = newHash;
			nameSet = false; // Player is null at this point, so name is set in onClientTick
		}
	}

	@Subscribe
	public void onClientTick(ClientTick event)
	{
		if (client.getGameState().getState() < GameState.LOADING.getState()) return;
		if (hash == -1) return;
		if (nameSet) return;

		Player player = client.getLocalPlayer();
		if (player == null) return;

		String name = player.getName();
		if (name == null) return;

		setPlayerName(name);
		nameSet = true;
		emit();
	}

	@Subscribe
	public void onGameStateChanged(GameStateChanged event)
	{
		if (event.getGameState() == GameState.LOGIN_SCREEN && hash != -1)
		{
			reset();
		}
	}

	public void reset() {
		hash = -1;
		setPlayerName(null);
		emit();
	}

	private void emit()
	{
		eventBus.post(new AccountChanged(hash, playerName));
	}
}

package com.lootledger.account;

import lombok.EqualsAndHashCode;
import lombok.Getter;
import lombok.ToString;

@Getter
@ToString
@EqualsAndHashCode
public final class AccountChanged
{
	public static final long NO_ACCOUNT = -1L;

	private final long hash;
	private final String playerName;

	public AccountChanged(long hash, String playerName)
	{
		this.hash = hash;
		this.playerName = playerName;
	}

	public boolean isLoggedIn()
	{
		return hash != NO_ACCOUNT;
	}
}

package com.lootledger.items;

import com.google.gson.Gson;
import com.google.gson.reflect.TypeToken;
import lombok.extern.slf4j.Slf4j;
import net.runelite.client.game.ItemManager;

import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.Reader;
import java.lang.reflect.Type;
import java.nio.charset.StandardCharsets;
import java.util.*;

/**
 * Loads a resource JSON mapping of ITEM_NAME -> [itemIds...] and offers
 * flexible lookups that handle both "Foo (Bar)" and "Foo#Bar" variants.
 */
@Slf4j
public final class ItemIdIndex
{
    private static final String RESOURCE_PATH = "/com/lootledger/Items.json"; // classpath resource
    private static volatile Gson GSON;
    private static final Type TYPE = new TypeToken<Map<String, List<Integer>>>() {}.getType();

    // normalized name -> primitive int[] (fast, heap-friendly)
    private static volatile Map<String, int[]> index = Collections.emptyMap();

    private ItemIdIndex() {}

    public static void setGson(Gson gson) {
        GSON = Objects.requireNonNull(gson, "gson");
    }

    public static synchronized void load() {
        if (GSON == null) {
            throw new IllegalStateException("ItemIdIndex Gson not set");
        }
        try (InputStream is = ItemIdIndex.class.getResourceAsStream(RESOURCE_PATH)) {
            if (is == null) {
                log.warn("Items.json not found on classpath at {}", RESOURCE_PATH);
                index = Collections.emptyMap();
                return;
            }
            try (Reader reader = new InputStreamReader(is, StandardCharsets.UTF_8)) {
                Map<String, List<Integer>> raw = GSON.fromJson(reader, TYPE);
                Map<String, int[]> tmp = new HashMap<>(raw.size());
                for (Map.Entry<String, List<Integer>> e : raw.entrySet()) {
                    String key = normalize(e.getKey());
                    List<Integer> ids = e.getValue();
                    if (ids == null || ids.isEmpty()) { continue; }
                    int[] arr = new int[ids.size()];
                    for (int i = 0; i < ids.size(); i++) arr[i] = ids.get(i);
                    tmp.put(key, arr);
                }
                index = Collections.unmodifiableMap(tmp);
                log.info("Loaded {} item-name keys from Items.json", index.size());
            }
        } catch (Exception ex) {
            log.error("Failed to load Items.json", ex);
            index = Collections.emptyMap();
        }
    }

    /** Returns candidate IDs for an item name, trying several key variations. */
    public static int[] findIdsFlex(String itemName)
    {
        if (itemName == null || itemName.isEmpty()) return new int[0];
        String n = normalize(itemName);

        // Try exact
        int[] ids = index.get(n);
        if (ids != null) return ids;

        // Try converting "Foo (Bar)" → "Foo#Bar"
        String hashVariant = toHashVariant(n);
        if (!hashVariant.equals(n))
        {
            ids = index.get(hashVariant);
            if (ids != null) return ids;
        }

        // Try removing trailing decorations after '#'
        int hash = n.indexOf('#');
        if (hash > 0)
        {
            String base = n.substring(0, hash).trim();
            ids = index.get(base);
            if (ids != null) return ids;
        }

        // As a last resort, try stripping all parentheses
        String parenStripped = n.replaceAll("\\s*\\([^)]*\\)", "").trim();
        if (!parenStripped.equals(n))
        {
            ids = index.get(parenStripped);
            if (ids != null) return ids;
        }

        return new int[0];
    }

    /**
     * Picks the most suitable ID from a set, preferring canonical (non-noted/non-placeholder) IDs
     * using ItemManager#canonicalize to avoid API differences across RuneLite versions.
     */
    public static int pickBestId(ItemManager itemManager, int[] candidates)
    {
        if (candidates == null || candidates.length == 0) return 0;
        int fallback = candidates[0];
        if (itemManager == null) return fallback;

        int firstCanonical = 0;
        for (int id : candidates)
        {
            try
            {
                int canon = itemManager.canonicalize(id);
                if (firstCanonical == 0) firstCanonical = canon;
                // Prefer IDs that are already canonical (i.e., not noted/placeholders)
                if (canon == id)
                {
                    return id;
                }
            }
            catch (Exception ignored) {}
        }
        // If none were already canonical, return the first canonical version as a reasonable default
        return firstCanonical != 0 ? firstCanonical : fallback;
    }

    private static String normalize(String s)
    {
        return s.toLowerCase(Locale.ROOT).replace('\u00A0', ' ').trim(); // collapse nbsp → space
    }

    /** Convert "foo (bar)" to "foo#bar" for keys that use hash disambiguators. */
    private static String toHashVariant(String s)
    {
        // e.g. "adamant dagger (p++)" → "adamant dagger#(p++)"
        int i = s.indexOf('(');
        if (i > 0 && s.endsWith(")"))
        {
            String base = s.substring(0, i).trim();
            String paren = s.substring(i).replace(" (", "#");
            return (base + paren).trim();
        }
        return s;
    }
}

package com.lootledger;

import com.google.inject.Provides;
import com.google.gson.Gson;
import com.lootledger.account.AccountManager;
import com.lootledger.drops.DropCache;
import com.lootledger.drops.DropFetcher;
import com.lootledger.items.ItemIdIndex;
import com.lootledger.managers.ObtainedItemsManager;
import com.lootledger.ui.DropsMenuListener;
import com.lootledger.ui.MusicWidgetController;
import com.lootledger.ui.DropsTooltipOverlay;
import com.lootledger.ui.TabListener;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Item;
import net.runelite.api.ItemContainer;
import net.runelite.api.TileItem;
import net.runelite.api.events.ItemContainerChanged;
import net.runelite.api.events.ItemSpawned;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.eventbus.EventBus;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.events.ConfigChanged;
import net.runelite.client.game.ItemManager;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.plugins.PluginDescriptor;
import net.runelite.client.ui.overlay.OverlayManager;
import net.runelite.api.GameState;
import net.runelite.api.events.GameStateChanged;


import javax.inject.Inject;
import java.util.HashSet;
import java.util.Set;

@Slf4j
@PluginDescriptor(
        name = "Loot Ledger",
        description = "Show drop tables in the Music tab with obtained tracking",
        tags = {"drops","loot","wiki"}
)
public class LootLedgerPlugin extends Plugin
{
    @Inject private Gson gson;
    @Inject private ItemManager itemManager;
    @Inject private LootLedgerConfig config;
    @Inject private AccountManager accountManager;
    @Inject private DropFetcher dropFetcher;
    @Inject private DropCache dropCache;
    @Inject private MusicWidgetController musicWidgetController;
    @Inject private DropsMenuListener dropsMenuListener;
    @Inject private TabListener tabListener;
    @Inject private ObtainedItemsManager obtainedItems;
    @Inject private EventBus eventBus;
    @Inject private OverlayManager overlayManager;
    @Inject private DropsTooltipOverlay dropsTooltipOverlay;

    @Provides
    LootLedgerConfig provideConfig(ConfigManager cm) { return cm.getConfig(LootLedgerConfig.class); }

    @Override protected void startUp()
    {
        ItemIdIndex.setGson(gson);
        ItemIdIndex.load();
        accountManager.init();
        dropFetcher.startUp();
        eventBus.register(accountManager);
        eventBus.register(tabListener);
        eventBus.register(dropsMenuListener);
        overlayManager.add(dropsTooltipOverlay);
    }

    @Override protected void shutDown()
    {
        musicWidgetController.restore();
        obtainedItems.save();
        obtainedItems.shutdown();
        eventBus.unregister(accountManager);
        eventBus.unregister(tabListener);
        eventBus.unregister(dropsMenuListener);
        overlayManager.remove(dropsTooltipOverlay);
        dropCache.shutdown();
        dropFetcher.shutdown();
    }

    @Subscribe
    public void onGameStateChanged(GameStateChanged e)
    {
        if (e.getGameState() == GameState.LOGGED_IN)
        {
            try { dropCache.startUp(); } catch (Exception ex) { log.error("dropCache.startUp failed", ex); }
            try { obtainedItems.load(); } catch (Exception ex) { log.error("obtainedItems.load failed", ex); }
        }
    }

    // Refresh the viewer live when relevant config toggles change
    @Subscribe
    public void onConfigChanged(ConfigChanged e)
    {
        if (!"lootledger".equals(e.getGroup()))
        {
            return;
        }
        // Any of these affect visibility/ordering of items; re-render if open
        String k = e.getKey();
        if ("trackObtained".equals(k)
                || "obtainedScope".equals(k)
                || "obtainedView".equals(k)
                || "showRareDropTable".equals(k)
                || "showGemDropTable".equals(k)
                || "sortDropsByRarity".equals(k))
        {
            refreshIfShowing();
        }
    }

    @Subscribe
    public void onItemSpawned(ItemSpawned event)
    {
        if (!config.trackObtained()) return;

        final TileItem tileItem = event.getItem();
        if (tileItem.getOwnership() != TileItem.OWNERSHIP_SELF)
        {
            return;
        }

        final int canonicalId = itemManager.canonicalize(tileItem.getId());
        final String account = accountManager.getPlayerName();
        if (account == null)
        {
            return;
        }

        final ObtainedItemsManager.Scope scope = mapScope(config.obtainedScope());
        final String npcNameContext = musicWidgetController.hasData() && musicWidgetController.getCurrentData() != null
                ? musicWidgetController.getCurrentData().getName() : "";

        if (!obtainedItems.isObtained(account, npcNameContext, canonicalId, scope))
        {
            obtainedItems.markObtained(account, npcNameContext, canonicalId, scope);
            refreshIfShowing();
        }
    }

    @Subscribe
    public void onItemContainerChanged(ItemContainerChanged event)
    {
        if (!config.trackObtained()) return;

        // 93 = inventory
        if (event.getContainerId() != 93)
        {
            return;
        }

        final String account = accountManager.getPlayerName();
        if (account == null)
        {
            return;
        }

        final Set<Integer> processed = new HashSet<>();
        final ItemContainer c = event.getItemContainer();
        if (c == null)
        {
            return;
        }

        final ObtainedItemsManager.Scope scope = mapScope(config.obtainedScope());
        final String npcNameContext = musicWidgetController.hasData() && musicWidgetController.getCurrentData() != null
                ? musicWidgetController.getCurrentData().getName() : "";

        for (Item item : c.getItems())
        {
            if (item == null) continue;
            final int canonicalId = itemManager.canonicalize(item.getId());
            if (processed.contains(canonicalId))
            {
                continue;
            }

            if (!obtainedItems.isObtained(account, npcNameContext, canonicalId, scope))
            {
                obtainedItems.markObtained(account, npcNameContext, canonicalId, scope);
                processed.add(canonicalId);
            }
        }

        if (!processed.isEmpty())
        {
            refreshIfShowing();
        }
    }

    private void refreshIfShowing()
    {
        if (musicWidgetController.hasData() && musicWidgetController.getCurrentData() != null)
        {
            musicWidgetController.override(musicWidgetController.getCurrentData());
        }
    }

    private ObtainedItemsManager.Scope mapScope(LootLedgerConfig.Scope s)
    {
        return s == LootLedgerConfig.Scope.PER_NPC ?
                ObtainedItemsManager.Scope.PER_NPC :
                ObtainedItemsManager.Scope.PER_ACCOUNT;
    }
}

package com.example;

import com.lootledger.LootLedgerPlugin;
import net.runelite.client.RuneLite;
import net.runelite.client.externalplugins.ExternalPluginManager;

@SuppressWarnings("ALL")
public class ExamplePluginTest
{
	public static void main(String[] args) throws Exception
	{
		ExternalPluginManager.loadBuiltin(LootLedgerPlugin.class);
		RuneLite.main(args);
	}
}
