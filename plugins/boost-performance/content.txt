package com.boostperformance;

import net.runelite.client.RuneLite;
import net.runelite.client.externalplugins.ExternalPluginManager;

public class BoostPerformancePluginTest
{
	public static void main(String[] args) throws Exception
	{
		ExternalPluginManager.loadBuiltin(BoostPerformancePlugin.class);
		RuneLite.main(args);
	}
}
package com.boostperformance;

public class DynamicBossDataJson
{
    private int bossSpawnFormId;
    private String bossName;
    private int ehb;

    public int getBossSpawnFormId() {
        return bossSpawnFormId;
    }

    public String getBossName() {
        return bossName;
    }

    public int getEhb() {
        return ehb;
    }

}
package com.boostperformance;

import lombok.Getter;

import java.util.Set;

public class AdditionalBossDataJson
{
    @Getter
    private int spawnFormId;

    @Getter
    private int finalFormId;

    @Getter
    private Set<Integer> validPartners;

    @Getter
    private String shortName;

    @Getter
    private String fullName;

    @Getter
    private double spawnSeconds;

    @Getter
    private int deathAnimationId;

    @Getter
    private double ehb;

}
package com.boostperformance;

import com.boostperformance.messages.BoostPerformanceMemberUpdate;
import com.boostperformance.messages.BoostPerformanceDespawnUpdate;
import com.boostperformance.messages.BoostPerformanceSnipeUpdate;
import com.boostperformance.messages.BoostPerformanceSpawnUpdate;
import com.google.gson.Gson;
import com.google.inject.Provides;
import com.google.common.collect.BiMap;
import com.google.common.collect.HashBiMap;
import javax.inject.Inject;
import javax.swing.*;

import lombok.extern.slf4j.Slf4j;
import net.runelite.api.*;
import net.runelite.api.coords.WorldPoint;
import net.runelite.api.events.*;
import net.runelite.client.chat.ChatColorType;
import net.runelite.client.chat.ChatMessageBuilder;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.chat.QueuedMessage;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.events.ConfigChanged;
import net.runelite.client.events.PartyChanged;
import net.runelite.client.events.RuneScapeProfileChanged;
import net.runelite.client.party.PartyService;
import net.runelite.client.party.WSClient;
import net.runelite.client.party.events.UserJoin;
import net.runelite.client.party.events.UserPart;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.plugins.PluginDescriptor;
import net.runelite.client.ui.ClientToolbar;
import net.runelite.client.ui.NavigationButton;
import net.runelite.client.util.ExecutorServiceExceptionLogger;
import net.runelite.client.util.ImageUtil;
import net.runelite.client.util.Text;

import java.awt.*;
import java.awt.image.BufferedImage;
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.net.URL;
import java.time.Instant;
import java.util.Arrays;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Set;
import java.util.concurrent.*;
import java.util.regex.Matcher;
import java.util.regex.Pattern;


@Slf4j
@PluginDescriptor(
	name = "Boost Performance",
	description = "Track performance of a boost session or clan event as a participant or bystander"
)
public class BoostPerformancePlugin extends Plugin
{
	@Inject
	private Client client;

	@Inject
	private BoostPerformanceConfig config;

	@Inject
	private ChatMessageManager chatMessageManager;

	@Inject
	private PartyService partyService;

	@Inject
	private WSClient wsClient;

	@Inject
	private ClientToolbar clientToolbar;

	@Inject
	private Gson gson;

	final Color BAD_HIGHLIGHT = new Color(90,90,90);
	final Color GOOD_HIGHLIGHT = new Color(239,16,32);

	final int SECONDS_FOR_GOOD_ESTIMATE = 1200;
	private final String DYNAMIC_BOSS_DATA_URL = "https://1defence.github.io/resources/data.json";

	private final String ADDITIONAL_BOSS_DATA_URL = "https://1defence.github.io/resources/additionalData.json";
	String KC_REGEX = "^Your (.+?) kill count is";
	Pattern KC_REGEX_PATTERN = Pattern.compile(KC_REGEX);

	private ExecutorService bossDataExecutorService;

	BiMap<Long, String> partyMembers = HashBiMap.create();
	public HashMap<Integer, Set<Integer>> worldsActive = new HashMap<>();

	Instant killStartTime,
			currentStartTime = null;

	String recentKillName;

	long currentFastestKill = -1;
	int currentBossKills,currentSnipes = 0;
	int worldOfPreviousKill,worldOfRecentKill,recentKillId = -1;
	Set<Integer> currentPartnerBosses = null;
	BoostPerformancePanel boostPerformancePanel;
	private NavigationButton navButton;

	public enum PERFORMANCE_SECTION {CURRENT,OVERALL}

	public Utils utils;

	private boolean queuedUpdate = false;
	private String currentLocalUsername;

	@Provides
	BoostPerformanceConfig provideConfig(ConfigManager configManager)
	{
		return configManager.getConfig(BoostPerformanceConfig.class);
	}

	@Override
	protected void startUp() throws Exception
	{
		currentStartTime = null;
		currentPartnerBosses = null;
		currentBossKills = currentSnipes = 0;
		currentFastestKill = recentKillId = -1;
		worldOfRecentKill = -1;
		worldOfPreviousKill = -1;
		queuedUpdate = true;
		PerformanceStats.Clear(this);
		utils = new Utils(this);

		wsClient.registerMessage(BoostPerformanceSpawnUpdate.class);
		wsClient.registerMessage(BoostPerformanceDespawnUpdate.class);
		wsClient.registerMessage(BoostPerformanceSnipeUpdate.class);
		wsClient.registerMessage(BoostPerformanceMemberUpdate.class);

		bossDataExecutorService = new ExecutorServiceExceptionLogger(Executors.newSingleThreadScheduledExecutor());
		bossDataExecutorService.execute(this::FetchBossData);

		//request a sync from party members, dont inform join, the queuedUpdate will do this.
		SendMemberUpdate(false,false,true,null);
	}

	@Override
	protected void shutDown() throws Exception
	{
		//inform party members to remove us, in future add a heart-beat check to handle X-ing out on the client
		SendMemberUpdate(false,true,false,null);

		wsClient.unregisterMessage(BoostPerformanceSpawnUpdate.class);
		wsClient.unregisterMessage(BoostPerformanceDespawnUpdate.class);
		wsClient.unregisterMessage(BoostPerformanceSnipeUpdate.class);
		wsClient.unregisterMessage(BoostPerformanceMemberUpdate.class);

		clientToolbar.removeNavigation(navButton);

		bossDataExecutorService.shutdown();
		bossDataExecutorService = null;
	}
	/**
	 * Grab up to date EHB rates from github IO page
	 * allows data to stay up to date without redundant update PRs
	 * will in future include all boss data to allow new bosses to be added seemlessly
	 */
	private void FetchBossData(){
		SwingUtilities.invokeLater(() ->
		{
			BufferedReader reader;
			try
			{
				reader = new BufferedReader(new InputStreamReader(new URL(ADDITIONAL_BOSS_DATA_URL).openStream()));
				AdditionalBossDataJson[] fetchedAdditionalData = gson.fromJson(reader, AdditionalBossDataJson[].class);
				for (AdditionalBossDataJson data : fetchedAdditionalData)
				{
					BossData.AddBoss(
							data.getSpawnFormId(),
							data.getFinalFormId(),
							data.getValidPartners(),
							data.getShortName(),
							data.getFullName(),
							data.getSpawnSeconds(),
							data.getDeathAnimationId(),
							data.getEhb());
				}
				reader.close();

				reader = new BufferedReader(new InputStreamReader(new URL(DYNAMIC_BOSS_DATA_URL).openStream()));
				DynamicBossDataJson[] fetchedDynamicData = gson.fromJson(reader, DynamicBossDataJson[].class);
				for (DynamicBossDataJson data : fetchedDynamicData)
				{
					BossData.SetBossEHB(data.getBossSpawnFormId(),data.getEhb());
				}
				reader.close();

				//data gathered, can initiate panel.
				InitiatePanel();

			} catch (IOException e)
			{
				throw new RuntimeException(e);
			}
		});


	}

	/**
	 * Build and register the panel
	 */
	void InitiatePanel(){
		boostPerformancePanel = new BoostPerformancePanel(this);

		final BufferedImage icon_panel = ImageUtil.loadImageResource(getClass(), "icon_Panel.png");
		navButton = NavigationButton.builder()
				.tooltip("Boost Performance")
				.icon(icon_panel)
				.priority(1)
				.panel(boostPerformancePanel)
				.build();

		clientToolbar.addNavigation(navButton);
	}
	/**
	 * Party left, reset tracked members
	 */
	@Subscribe
	public void onPartyChanged(PartyChanged partyChanged)
	{
		partyMembers.clear();
	}
	/**
	 * Party member left, remove from list of tracked members
	 */
	@Subscribe
	public void onUserPart(final UserPart event) {
		partyMembers.remove(event.getMemberId());
	}
	/**
	 * Party member joined, request an update for the next registered game tick
	 */
	@Subscribe
	public void onUserJoin(final UserJoin message)
	{
		queuedUpdate = true;
	}
	/**
	 * User changed accounts, request an update for the next registered game tick
	 */
	@Subscribe
	public void onRuneScapeProfileChanged(RuneScapeProfileChanged runeScapeProfileChanged)
	{
		queuedUpdate = true;
	}
	/**
	 * Party member requested an update, either joining leaving or syncing, this custom packet ensures the party member is using this plugin.
	 * A traditonal party-leave event is normally good enough for leaves, but this will also cover turning the plugin off
	 */
	@Subscribe
	public void onBoostPerformanceMemberUpdate(final BoostPerformanceMemberUpdate update){
		if(update.isUserJoining())
		{
			partyMembers.put(update.getMemberId(), update.getName());
		}
		else if(update.isUserLeaving())
		{
			partyMembers.remove(update.getMemberId());
		}
		else if(update.isUserRequestingSync()){
			queuedUpdate = true;
		}
	}

	void SendMemberUpdate(boolean userJoining, boolean userLeaving, boolean userRequestingSync, String name){
		if(partyService.getLocalMember() != null)
		{
			partyService.send(new BoostPerformanceMemberUpdate(userJoining,userLeaving,userRequestingSync,name));
		}
	}

	/**
	 * Update personal best kill
	 * returns boolean indicating whether or not the passed killspeed is the new personal best
	 */
	public boolean UpdateFastest(long killSpeed)
	{
		boolean isFastest = false;
		if((killSpeed < currentFastestKill) || currentFastestKill == -1)
		{
			currentFastestKill = killSpeed;
			isFastest = true;
		}
		if((killSpeed < PerformanceStats.overallStats.pb) || PerformanceStats.overallStats.pb  == -1)
		{
			PerformanceStats.overallStats.pb = killSpeed;
			isFastest = true;
		}
		return isFastest;
	}

	/**
	 * Convenience function to send a game message when resetting.
	 */
	void SendResetGameMessage(String contents){
		if(config.getDisplayResetMessage())
		{

			String message = new ChatMessageBuilder()
					.append(ChatColorType.HIGHLIGHT)
					.append(contents)
					.build();
			chatMessageManager.queue(QueuedMessage.builder()
					.type(ChatMessageType.CONSOLE)
					.runeLiteFormattedMessage(message)
					.build());
		}
	}
	/**
	 * Convenience function to send a game message when user-error occurs
	 */
	void SendErrorGameMessage(String contents){
			String message = new ChatMessageBuilder()
					.append(BAD_HIGHLIGHT,contents)
					.build();
			chatMessageManager.queue(QueuedMessage.builder()
					.type(ChatMessageType.CONSOLE)
					.runeLiteFormattedMessage(message)
					.build());
	}

	/**
	 * Add current to overall stored data
	 * Reset current data and update panel
	 */
	public void ResetCurrent()
	{
		if(!CurrentKillHasStarted())
			return;

		if(currentBossKills != 0)
		{
			PerformanceStats.Add(recentKillId,
					utils.GetKillsPerHourDouble(PERFORMANCE_SECTION.CURRENT, true),
					currentBossKills,
					currentSnipes,
					utils.GetEHBGained(PERFORMANCE_SECTION.CURRENT),
					currentFastestKill,
					currentStartTime,
					killStartTime
					);
		}

		currentStartTime = null;
		currentPartnerBosses = null;
		currentBossKills = currentSnipes = 0;
		currentFastestKill = recentKillId = -1;

		UpdateCurrent(true);
		UpdateOverall(true);
		SendResetGameMessage("Current Kill Speed resetting...");
	}
	/**
	 * Reset overall data and updates panel
	 * Only resets the historical stored data
	 * Doesn't reset current so overall will still be equal to current if present.
	 */
	public void ResetOverall()
	{
		PerformanceStats.Clear(this);
		UpdateCurrent(false);
		UpdateOverall(true);
		SendResetGameMessage("Total Kill Speed resetting...");
		boostPerformancePanel.SetInvalidOverall(false);

	}
	/**
	 * Update panel fields with CURRENT Information
	 */
	public void UpdateCurrent(boolean forceDuration)
	{
		boostPerformancePanel.SetKC(PERFORMANCE_SECTION.CURRENT);
		boostPerformancePanel.SetKPH(PERFORMANCE_SECTION.CURRENT);
		boostPerformancePanel.SetSnipes(PERFORMANCE_SECTION.CURRENT);
		boostPerformancePanel.SetEHB(PERFORMANCE_SECTION.CURRENT);
		boostPerformancePanel.SetPB(PERFORMANCE_SECTION.CURRENT);
		if(config.getPreventFallOff() || forceDuration)
		{
			boostPerformancePanel.SetDuration(PERFORMANCE_SECTION.CURRENT,true);
		}
	}
	/**
	 * Update panel fields with OVERALL Information
	 */
	public void UpdateOverall(boolean forceDuration)
	{
		boostPerformancePanel.SetKC(PERFORMANCE_SECTION.OVERALL);
		boostPerformancePanel.SetKPH(PERFORMANCE_SECTION.OVERALL);
		boostPerformancePanel.SetSnipes(PERFORMANCE_SECTION.OVERALL);
		boostPerformancePanel.SetEHB(PERFORMANCE_SECTION.OVERALL);
		boostPerformancePanel.SetPB(PERFORMANCE_SECTION.OVERALL);
		if(config.getPreventFallOff() || forceDuration)
		{
			boostPerformancePanel.SetDuration(PERFORMANCE_SECTION.OVERALL,true);
		}
	}
	/**
	 * Inform all party members that boss has spawned
	 */
	public void SendBossSpawn(int world, int spawnId)
	{
		if(partyService.getLocalMember() != null)
		{
			partyService.send(new BoostPerformanceSpawnUpdate(world,spawnId));
		}
	}
	/**
	 * Party member saw the boss spawn, send off to attempt processing
	 */
	@Subscribe
	public void onBoostPerformanceSpawnUpdate(BoostPerformanceSpawnUpdate update)
	{
		ProcessBossSpawn(update.getWorld(),update.getSpawnId());
	}
	/**
	 * Checks if a spawn event is allowed to occur
	 * Event can occur if the current world isn't present or the current world isn't tracking this boss in specific
	 */
	public boolean CanSpawn(int world, int spawnId)
	{
		Set<Integer> activeBossIds = worldsActive.get(world);
		if(activeBossIds == null)
			return true;
		return !activeBossIds.contains(spawnId);
	}
	/**
	 * Process spawn packet
	 * Set world active
	 */
	public void ProcessBossSpawn(int world, int spawnId)
	{
		if(CanSpawn(world,spawnId))
		{
			SetWorldActive(world,spawnId);
			//System.out.println("spawn "+world+":"+spawnId);
		}
	}
	/**
	 * Inform all party members that boss has died
	 */
	public void SendBossDeath(int world, String bossName, int spawnId)
	{
		if(partyService.getLocalMember() != null)
		{
			partyService.send(new BoostPerformanceDespawnUpdate(world,bossName,spawnId));
		}
	}
	/**
	 * Party member saw the boss die, send off to attempt processing
	 */
	@Subscribe
	public void onBoostPerformanceDespawnUpdate(BoostPerformanceDespawnUpdate update)
	{
		ProcessBossDeath(update.getWorld(),update.getBossName(),update.getBossSpawnId());
	}
	/**
	 * Checks if a despawn event is allowed to occur
	 * Event can occur if the current world has the current boss spawn tracked
	 */
	public boolean CanDespawn(int world, int spawnId)
	{
		Set<Integer> activeBossIds = worldsActive.get(world);
		if(activeBossIds == null)
			return false;
		return activeBossIds.contains(spawnId);
	}
	/**
	 * Process death packet
	 * First kill is a burner, tracking occurs after this
	 * Update current statistics
	 * Set world inactive
	 */
	public void ProcessBossDeath(int world, String bossName, int spawnId)
	{
		//world already dead
		if(!CanDespawn(world,spawnId))
			return;

		//System.out.println("death "+world+":"+spawnId);

		if(recentKillId != -1 && recentKillId != spawnId){
			BossData boss = BossData.FindSpawnForm(recentKillId);

			boolean hasPartner = boss.hasPartner(spawnId);
			/*Almost all of the following partner code is due to DKS, to handle single dk, or any combination of the 3, as thats what players with >0/3 pets will be doing*/
			if(hasPartner){
				boolean partnerSetUpdated = false;
				if(currentPartnerBosses == null)
				{
					//this kill is a partner of our previous kill, set partner bosses
					//this defaults the set to the previous boss and the current boss, future partner kills will add to this list
					currentPartnerBosses = new HashSet<>(Arrays.asList(recentKillId, spawnId));
					partnerSetUpdated = true;
				}
				else
				{
					if(!currentPartnerBosses.contains(spawnId)){
						//new partner was killed
						currentPartnerBosses.add(spawnId);
						partnerSetUpdated = true;
					}
				}
				if(partnerSetUpdated){
					//set of killed partners has increased, update name to reflect current kill set
					boostPerformancePanel.SetBossName();
				}
			}
			//end of DKS checking
			if(!hasPartner){
				//previously killed boss has no partner therefor this kill requires a reset
				//when a new boss is killed we add the current to overall, and set the header to reflect that it's now "mixed"
				boolean hadKillsTracked = currentBossKills > 0;
				ResetCurrent();
				if(hadKillsTracked)
				{
					boostPerformancePanel.SetInvalidOverall(true);
				}
			}
		}

		this.recentKillName = bossName;
		this.recentKillId = spawnId;
		this.worldOfRecentKill = world;

		SetWorldInactive(world,spawnId);

		String killMessage = "";

		Color highlight = utils.GetElapsedSeconds(PERFORMANCE_SECTION.CURRENT, false) > SECONDS_FOR_GOOD_ESTIMATE ? GOOD_HIGHLIGHT : BAD_HIGHLIGHT;

		if(currentStartTime == null)
		{

			currentStartTime = Instant.now();
			currentBossKills = 0;
			boostPerformancePanel.SetBossName();
			killMessage = new ChatMessageBuilder()
					.append(ChatColorType.HIGHLIGHT)
					.append("Kill Speed now tracking, kill "+bossName+" again to estimate the rate")
					.build();

		}
		else
		{
			currentBossKills++;

			long killSpeedL = utils.GetRecentKillSpeed();
			String killSpeedS = utils.GetKillSpeedFromLong(killSpeedL);
			boolean newFastest = UpdateFastest(killSpeedL);
			String killsPerHour = utils.GetKillsPerHourGameMessage();

			if(config.getDisplayKillMessage())
			{
				killMessage = new ChatMessageBuilder()
						.append(ChatColorType.NORMAL)
						.append("Kills per hour: ")
						.append(highlight, killsPerHour)
						.append(ChatColorType.NORMAL)
						.append(", Fight duration: ")
						.append(ChatColorType.HIGHLIGHT)
						.append(killSpeedS)
						.append(ChatColorType.NORMAL)
						.append(newFastest ? " (new personal best)" : "").build();
			}

		}

		if(!killMessage.isEmpty())
		{
			chatMessageManager.queue(QueuedMessage.builder()
					.type(ChatMessageType.CONSOLE)
					.runeLiteFormattedMessage(killMessage)
					.build());
		}

		killStartTime = Instant.now();
		this.worldOfPreviousKill = world;

		UpdateCurrent(true);
		UpdateOverall(true);
	}

	/**
	 * Only one present player should report the spawn and death of the boss to prevent unnecessary packets
	 * Checks what party members are close enough to see the Boss
	 * Of said close players, determines the lowest PID player
	 * If we're the lowest PID player, we send the packet.
	 */
	boolean ShouldSendPacket(NPC npc)
	{
		Player localPlayer = client.getLocalPlayer();

		if(localPlayer == null)
			return false;
		int lowestCheckedId = Integer.MAX_VALUE;
		BiMap<String, Long> partyMembersByName = partyMembers.inverse();


		for (Player player : client.getPlayers())
		{
			String name = SanitizeName(player.getName());
			if(!partyMembersByName.containsKey(name))
				continue;
			if(!CanSeeNpc(player,npc))
				continue;
			int checkId = player.getId();
			if(checkId >= lowestCheckedId)
				continue;
			lowestCheckedId = checkId;
		}
		if(lowestCheckedId == Integer.MAX_VALUE)
		{
			//the player has just logged in for the very first time on their client, allow a potential extra packet...
			//rare situation, remove if issues in future.
			lowestCheckedId = localPlayer.getId();
		}
		return lowestCheckedId == localPlayer.getId();
	}
	/**
	 * If a player is within 15 tiles of an NPC, they are renderring the boss and can see death/spawn events
	 */
	boolean CanSeeNpc(Player player,NPC npc)
	{
		return IsWithinDistance(player,npc,15);
	}

	/**
	 * Checks the distance accounting for npc size, that a player is away from a given boss.
	 */
	public static boolean IsWithinDistance(Player player, NPC npc, int distance)
	{
		WorldPoint positionA = player.getWorldLocation();
		WorldPoint positionB = npc.getWorldLocation();

		int npcSizeOffSet = npc.getComposition().getSize();
		if(npcSizeOffSet <= 1)
		{
			npcSizeOffSet = 0;
		}

		int deltaX;
		int deltaY;

		if (positionA.getX() >= positionB.getX())
		{
			// Player is positioned in positive X direction, use size
			deltaX = Math.abs(positionA.getX() - (positionB.getX() + npcSizeOffSet));
		}
		else
		{
			// Player is positioned in negative X direction, don't use size
			deltaX = Math.abs(positionA.getX() - positionB.getX());
		}

		if (positionA.getY() >= positionB.getY())
		{
			// Player is positioned in positive Y direction, use size
			deltaY = Math.abs(positionA.getY() - (positionB.getY() + npcSizeOffSet));
		}
		else
		{
			// Player is positioned in negative Y direction, don't use size
			deltaY = Math.abs(positionA.getY() - positionB.getY());
		}

		return deltaX <= distance && deltaY <= distance;
	}

	/**
	 * Indicates that the burner kill has occured and current is tracking statistics.
	 */
	public boolean CurrentKillHasStarted(){
		return currentStartTime != null;
	}
	/**
	 * Remove tags and convert to Jagex name
	 * @param name Local players raw name
	 */
	String SanitizeName(String name)
	{
		return Text.removeTags(Text.toJagexName(name));
	}
	/**
	 * Track that a boss has spawned and is currently present in a specific world
	 */
	public void SetWorldActive(int worldId, int id) {
		worldsActive.computeIfAbsent(worldId, k -> new HashSet<>()).add(id);
	}
	/**
	 * Track that a boss has died and is no longer present in a specific world
	 */
	public void SetWorldInactive(int worldId, int id) {
		worldsActive.computeIfAbsent(worldId, k -> new HashSet<>()).remove(id);
	}

	/**
	 * Under valid conditions, attempt to send packet of a boss dying
	 */
	@Subscribe
	public void onNpcDespawned(NpcDespawned npcDespawned)
	{
		final NPC npc = npcDespawned.getNpc();
		if(npc == null)
			return;

		int world = client.getWorld();


		BossData finalBoss = BossData.FindFinalForm(npc.getId());
		if(finalBoss == null)
			return;


		int spawnId = finalBoss.getSpawnFormId();
		String bossName = npc.getName();

		if(!CanDespawn(world,spawnId))
			return;

		if(!BossData.IsValidDeath(npc))
			return;

		/**FAILSAFE:
		 * process locally prior to party messages, prevents issues when party down/slow
		 * additionally makes plugin work without party if desired
		 */
		ProcessBossDeath(world,bossName,spawnId);

		if(!ShouldSendPacket(npc))
			return;

		SendBossDeath(world, bossName, spawnId);

	}
	/**
	 * Under valid conditions, attempt to send packet of a boss spawning
	 */
	@Subscribe
	public void onNpcSpawned(NpcSpawned npcSpawned)
	{
		NPC npc = npcSpawned.getNpc();
		if(npc == null)
			return;

		int world = client.getWorld();

		int spawnId = npc.getId();

		if(!CanSpawn(world,spawnId))
			return;

		if(!BossData.IsValidBossSpawn(npc))
		{
			if(BossData.IsMidKillBossSpawn(npc)){
				SendErrorGameMessage("Warning, the spawn viewed was mid kill and won't count. in the case of Sire ensure your vent-killer or any viewer has this plugin enabled and is in your party.");
			}
			return;
		}

		/**FAILSAFE:
		 * process locally prior to party messages, prevents issues when party down/slow
		 * additionally makes plugin work without party if desired
		 */
		ProcessBossSpawn(world,spawnId);

		if(!ShouldSendPacket(npc))
			return;

		SendBossSpawn(client.getWorld(),spawnId);

	}

	/**
	 * Inform all party members that someone has sniped
	 */
	public void SendSnipe()
	{
		if(partyService.getLocalMember() != null)
		{
			partyService.send(new BoostPerformanceSnipeUpdate());
		}
	}
	/**
	 * Party member sniped, increment snipes
	 */
	@Subscribe
	public void onBoostPerformanceSnipeUpdate(BoostPerformanceSnipeUpdate update)
	{
		currentSnipes++;
		boostPerformancePanel.SetSnipes(PERFORMANCE_SECTION.CURRENT);
		boostPerformancePanel.SetSnipes(PERFORMANCE_SECTION.OVERALL);
	}
	/**
	 * User gained kill credit, when config dicates that user is not the intended recipient. send packet informing party of our snipe
	 */
	@Subscribe
	public void onChatMessage(ChatMessage event)
	{

		if (event.getType() == ChatMessageType.GAMEMESSAGE)
		{
			if (event.getMessage().contains("kill count is"))
			{
				Matcher matcher = KC_REGEX_PATTERN.matcher(event.getMessage());
				if (matcher.find()){
					String nameOfBoss = matcher.group(1);
					int finalIDOfBoss = BossData.FindBossIDByName(nameOfBoss);
					if(finalIDOfBoss != -1)
					{
						SendBossDeath(client.getWorld(), nameOfBoss, finalIDOfBoss);
						if (!config.isMain())
						{
							SendSnipe();
						}
					}
				}
			}

		}
	}

	/**
	 * Assuming user wants falloff, we update the current and overall durations
	 */
	@Subscribe
	public void onGameTick(GameTick tick)
	{
		if (queuedUpdate && client.getLocalPlayer() != null && partyService.isInParty() && partyService.getLocalMember() != null)
		{
			currentLocalUsername = SanitizeName(client.getLocalPlayer().getName());
			String partyName = partyService.getMemberById(partyService.getLocalMember().getMemberId()).getDisplayName();
			//dont send unless the partyname has updated to the local name
			if (currentLocalUsername != null && currentLocalUsername.equals(partyName))
			{
				//inform party members we have joined, update in the list
				SendMemberUpdate(true,false,false,currentLocalUsername);
				queuedUpdate = false;
			}
		}

		if(!config.getPreventFallOff() && currentStartTime != null)
		{
			boostPerformancePanel.SetDuration(PERFORMANCE_SECTION.CURRENT,false);
			boostPerformancePanel.SetDuration(PERFORMANCE_SECTION.OVERALL,false);
		}
	}
	/**
	 * User changed Falloff settings, update duration
	 */
	@Subscribe
	public void onConfigChanged(ConfigChanged configChanged)
	{
		if (!configChanged.getGroup().equals("boostperformance"))
		{
			return;
		}

		if(configChanged.getKey().equals("preventFalloff")){
			boostPerformancePanel.SetDuration(PERFORMANCE_SECTION.CURRENT,config.getPreventFallOff());
			boostPerformancePanel.SetDuration(PERFORMANCE_SECTION.OVERALL,config.getPreventFallOff());
		}

	}

}

package com.boostperformance.messages;

import lombok.EqualsAndHashCode;
import lombok.Value;
import net.runelite.client.party.messages.PartyMemberMessage;


@Value
@EqualsAndHashCode(callSuper = true)
public class BoostPerformanceSpawnUpdate extends PartyMemberMessage
{
    int world;
    int spawnId;
}

package com.boostperformance.messages;

import lombok.EqualsAndHashCode;
import lombok.Value;
import net.runelite.client.party.messages.PartyMemberMessage;


@Value
@EqualsAndHashCode(callSuper = true)
public class BoostPerformanceDespawnUpdate extends PartyMemberMessage
{
    int world;
    String bossName;
    int bossSpawnId;
}

package com.boostperformance.messages;

import lombok.EqualsAndHashCode;
import lombok.Value;
import net.runelite.client.party.messages.PartyMemberMessage;


@Value
@EqualsAndHashCode(callSuper = true)
public class BoostPerformanceMemberUpdate extends PartyMemberMessage
{
    boolean userJoining;
    boolean userLeaving;
    boolean userRequestingSync;
    String name;
}

package com.boostperformance.messages;

import lombok.EqualsAndHashCode;
import lombok.Value;
import net.runelite.client.party.messages.PartyMemberMessage;


@Value
@EqualsAndHashCode(callSuper = true)
public class BoostPerformanceSnipeUpdate extends PartyMemberMessage
{
}

package com.boostperformance;

import java.text.DecimalFormat;
import java.time.Duration;
import java.time.Instant;
import java.time.LocalTime;
import java.time.format.DateTimeFormatter;

import static com.boostperformance.BoostPerformancePlugin.PERFORMANCE_SECTION;

public class Utils
{

    private final static String baseKPHString = "KPH: ";
    private final static String baseKCString = "KC: ";
    private final static String baseSnipeString = "Snipes: ";
    private final static String baseEHBString = "EHB: ";
    private final static String baseDurationString = "🕑 ";
    private final static  String basePBString = "PB: ";
    private final static String invalidResultString = "--";

    BoostPerformancePlugin plugin;
    public Utils(BoostPerformancePlugin plugin){
        this.plugin = plugin;
    }
    /**
     * Calc KPH based on duration and kills
     */
    public double GetKillsPerHourDouble(PERFORMANCE_SECTION section, boolean preventFall){
        double seconds = GetElapsedSeconds(section,preventFall);
        double kills = GetKC(section);
        if(kills == 0)
            return  0;
        double secondsPerKill = seconds / kills;
        return (3600d / secondsPerKill);
    }
    /**
     * Format KPH string -- used for panel
     */
    public String GetKillsPerHourString(PERFORMANCE_SECTION section, boolean preventFall){
        DecimalFormat df = new DecimalFormat("0.00");
        double kph = GetKillsPerHourDouble(section,preventFall);
        if(kph == 0)
            return baseKPHString+invalidResultString;
        return baseKPHString+df.format(kph);
    }
    /**
     * Format KPH value -- used for game message
     */
    public String GetKillsPerHourGameMessage(){
        DecimalFormat df = new DecimalFormat("0.00");
        double kph = GetKillsPerHourDouble(PERFORMANCE_SECTION.CURRENT,false);
        return df.format(kph);
    }
    /**
     * Calc Duration for given section
     * prevent falloff removes the excess time since our most recent kill
     */
    public long GetElapsedSeconds(PERFORMANCE_SECTION section, boolean preventFall){
        Duration duration = GetDuration(section,preventFall);
        if(duration == null)
            return 0;

        return duration.getSeconds();
    }
    /**
     * Calc kill speed of recent kill
     * Removes respawn time if applicable
     */
    public long GetRecentKillSpeed(){
        if(plugin.killStartTime == null)
            return  0;
        boolean sameWorldAsLast = plugin.worldOfRecentKill == plugin.worldOfPreviousKill;
        Duration elapsed = Duration.between(plugin.killStartTime, Instant.now());
        long respawnOffSet = sameWorldAsLast  && plugin.currentPartnerBosses == null ? (long) BossData.FindSpawnForm(plugin.recentKillId).getSpawnSeconds() : 0;
        return Math.max(elapsed.getSeconds()-respawnOffSet,0);
    }
    /**
     * Converts a long into a formatted kill speed string
     */
    public String GetKillSpeedFromLong(long killSpeed){
        LocalTime time = LocalTime.ofSecondOfDay(killSpeed);
        if (time.getHour() > 0)
        {
            return time.format(DateTimeFormatter.ofPattern("HH:mm"));
        }

        return time.format(DateTimeFormatter.ofPattern("m:ss"));
    }
    /**
     * Format KC value -- used for panel
     */
    public String GetKCString(PERFORMANCE_SECTION section){
        int ignoredKC = GetIgnoredKC(section);
        return baseKCString + (GetKC(section) + ignoredKC) + (ignoredKC > 0 ? " (-"+ignoredKC+")" : "");
    }
    /**
     * Iniital kc is a burner, we still want to know how many of these burners have occued
     * for current it'll effectively be 0 or 1
     * for overall there will be 1 burner kc per current-reset or rather 1 per object in the collection
     */
    public int GetIgnoredKC(PERFORMANCE_SECTION section){
        boolean killStarted = plugin.CurrentKillHasStarted();
        boolean current = section == PERFORMANCE_SECTION.CURRENT;
        int currentIgnored = killStarted ? 1 : 0;
        int totalIgnored = currentIgnored + PerformanceStats.statsCollection.size();
        return current ? currentIgnored : totalIgnored;
    }
    /**
     * Format Snipe string -- used for panel
     * On top of displaying the number of snipes, display it as a fraction with the numerator always aiming to be 1, additionally the percentage of snipes
     */
    public String GetSnipeString(PERFORMANCE_SECTION section){
        DecimalFormat df = new DecimalFormat("0.00");
        int kills = GetKC(section) + GetIgnoredKC(section);
        int snipes = GetSnipes(section);
        if(snipes == 0)
            return baseSnipeString+"0";
        if(snipes > kills)
            return baseSnipeString+snipes;
        int snipeFractionDenominator = snipes > 0 ? (int)Math.floor((double)kills/(double)snipes) : kills;
        int snipeFractionNumerator = snipes > 0 ? 1 : 0;
        double snipePercentage = ((double)snipes/(double)kills)*100d;
        return baseSnipeString+snipes+", "+snipeFractionNumerator+"/"+snipeFractionDenominator+" ("+df.format(snipePercentage)+"%)";
    }
    /**
     * Format EHB string -- used for panel
     */
    public String GetEHBString(PERFORMANCE_SECTION section){
        DecimalFormat df = new DecimalFormat("0.00");
        double ehbGained = GetEHBGained(section);
        if(ehbGained == 0)
            return baseEHBString+invalidResultString;
        double scaledEhbRate = GetScaledEHBRate(section,ehbGained);
        return baseEHBString+df.format(ehbGained)+" ("+df.format(scaledEhbRate)+"x)";
    }
    /**
     * Calc gained EHB
     * Based on duration, EHB rate and kills of given section
     */
    public double GetEHBGained(PERFORMANCE_SECTION section){
        boolean current = section == PERFORMANCE_SECTION.CURRENT;
        int bossKills = GetKC(PERFORMANCE_SECTION.CURRENT);
        if(current && bossKills == 0)
            return 0;
        BossData boss = BossData.FindFinalForm(plugin.recentKillId);

        double currentEHBGained = 0;
        if (boss != null)
        {
             double currentEHBRate = boss.ehb;
             currentEHBGained = (double) (bossKills)/currentEHBRate;
        }


        double overallEHBGained = PerformanceStats.overallStats.ehb + currentEHBGained;
        return current ? currentEHBGained : overallEHBGained;
    }
    /**
     * Calc scaled EHB Rate - what % over or under the standard EHB rate the section is
     * Based on EHB Gained and duration of given section
     */
    public double GetScaledEHBRate(PERFORMANCE_SECTION section, double ehbGained){
        double hoursSpent = (GetElapsedSeconds(section,true)/3600d);
        return ehbGained/hoursSpent;
    }
    /**
     * Format Duration string -- used for panel
     */
    public String GetDurationString(PERFORMANCE_SECTION section, boolean preventFall) {
        Duration duration = GetDuration(section,preventFall);
        if(duration == null)
            return baseDurationString+invalidResultString;

        long seconds = duration.getSeconds();
        long absSeconds = Math.abs(seconds);
        return baseDurationString+String.format(
                "%d:%02d:%02d",
                absSeconds / 3600,
                (absSeconds % 3600) / 60,
                absSeconds % 60);
    }
    /**
     * Format Personal Best string -- used for panel
     */
    public String GetPBString(PERFORMANCE_SECTION section) {
        long pb = GetPB(section);
        if(pb == -1)
            return basePBString+invalidResultString;
        return basePBString+ GetKillSpeedFromLong(pb);
    }
    /**
     * Get KC of a given section
     * overall includes current
     */
    public int GetKC(PERFORMANCE_SECTION section){
        boolean current = section == PERFORMANCE_SECTION.CURRENT;
        return current ? plugin.currentBossKills : PerformanceStats.overallStats.kc+plugin.currentBossKills;
    }
    /**
     * Get Snipes of a given section
     * overall includes current
     */
    public int GetSnipes(PERFORMANCE_SECTION section){
        boolean current = section == PERFORMANCE_SECTION.CURRENT;
        return current ? plugin.currentSnipes : PerformanceStats.overallStats.snipes+plugin.currentSnipes;
    }
    /**
     * Get Personal Best of a given section
     * overall includes current
     */
    public long GetPB(PERFORMANCE_SECTION section){
        boolean current = section == PERFORMANCE_SECTION.CURRENT;
        return current ? plugin.currentFastestKill : PerformanceStats.overallStats.pb;
    }
    /**
     * Get Duration of a given section
     * overall includes current
     */
    public Duration GetDuration(PERFORMANCE_SECTION section,boolean preventFall){
        boolean current = section == PERFORMANCE_SECTION.CURRENT;
        boolean killStarted = plugin.killStartTime != null;
        Instant start = plugin.currentStartTime;
        Instant now = (preventFall && killStarted) ? plugin.killStartTime : Instant.now();
        if(current && start == null)
            return Duration.ZERO;

        Duration currentDuration = start != null ? Duration.between(start,now) : Duration.ZERO;
        Duration totalDurationBeforeCurrent = PerformanceStats.overallStats.duration;

        return current ? currentDuration : currentDuration.plus(totalDurationBeforeCurrent);
    }

}

package com.boostperformance;

import net.runelite.client.ui.PluginPanel;
import net.runelite.client.ui.FontManager;
import net.runelite.client.util.ImageUtil;

import javax.swing.*;
import java.awt.*;

import static com.boostperformance.BoostPerformancePlugin.PERFORMANCE_SECTION;
public class BoostPerformancePanel extends PluginPanel
{
    BoostPerformancePlugin plugin;

    Utils utils;

    private JPanel panelBossHeader, panelCurrentHeader, panelCurrentInfo, panelOverallHeader, panelOverallInfo;
    private CustomLabel labelBossHeader, labelCurrentHeaderTitle, labelCurrentInfoKPH, labelCurrentInfoKC, labelCurrentInfoSnipes, labelCurrentInfoEHB, labelCurrentInfoPB, labelCurrentInfoDuration,
            labelOverallHeaderTitle, labelOverallInfoKPH, labelOverallInfoKC, labelOverallInfoSnipes, labelOverallInfoEHB, labelOverallInfoPB, labelOverallInfoDuration;
    private JSeparator separatorCurrent, separatorOverall;
    private JButton buttonCurrentReset, buttonOverallReset;

    private final Dimension SUB_PANEL_DIMENSIONS = new Dimension(155,145);
    private final Color SUB_PANEL_COLOR_MAIN = new Color(51, 51, 51);
    private final Color SUB_PANEL_COLOR_HEADER = new Color(25, 25, 25);

    private final Font titleFont = FontManager.getRunescapeBoldFont().deriveFont(20f);

    private final ImageIcon resetImage = new ImageIcon(ImageUtil.loadImageResource(getClass(), "icon_Reset.png"));

    BoostPerformancePanel(BoostPerformancePlugin plugin) {
        super();
        this.plugin = plugin;
        this.utils = plugin.utils;
        InitComponents();

        /*Boss Section Start*/
        SetUpHeaderPanel(panelBossHeader,labelBossHeader,"Kill a boss...",66);

        /*Current Section Start*/
        SetUpHeaderPanel(panelCurrentHeader,labelCurrentHeaderTitle,"Current",40);
        SetUpInfoPanel(panelCurrentInfo,separatorCurrent,labelCurrentInfoKPH,labelCurrentInfoKC,labelCurrentInfoSnipes,labelCurrentInfoEHB,labelCurrentInfoPB,labelCurrentInfoDuration,buttonCurrentReset);

        /*Overall Section Start*/
        SetUpHeaderPanel(panelOverallHeader,labelOverallHeaderTitle,"Overall",40);
        SetUpInfoPanel(panelOverallInfo,separatorOverall,labelOverallInfoKPH,labelOverallInfoKC,labelOverallInfoSnipes,labelOverallInfoEHB,labelOverallInfoPB,labelOverallInfoDuration,buttonOverallReset);

        /*Add all to screen*/
        GroupLayout layout = new GroupLayout(this);
        this.setLayout(layout);
        layout.setHorizontalGroup(layout.createSequentialGroup()
                                .addContainerGap()
                                .addGroup(layout.createParallelGroup()
                                        .addComponent(panelOverallInfo)
                                        .addComponent(panelOverallHeader)
                                        .addComponent(panelBossHeader)
                                        .addComponent(panelCurrentInfo)
                                        .addComponent(panelCurrentHeader))
                                .addContainerGap()

        );
        layout.setVerticalGroup(
                layout.createSequentialGroup()
                        .addContainerGap()
                        .addComponent(panelBossHeader)
                        .addPreferredGap(LayoutStyle.ComponentPlacement.RELATED, GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                        .addComponent(panelCurrentHeader)
                        .addComponent(panelCurrentInfo, GroupLayout.PREFERRED_SIZE, GroupLayout.DEFAULT_SIZE, GroupLayout.PREFERRED_SIZE)
                        .addPreferredGap(LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(panelOverallHeader)
                        .addComponent(panelOverallInfo, GroupLayout.PREFERRED_SIZE, GroupLayout.DEFAULT_SIZE, GroupLayout.PREFERRED_SIZE)
                        .addContainerGap()
        );
    }

    /**
     * Initiate Components
     *
     */
    void InitComponents(){

        panelBossHeader = new JPanel();
        labelBossHeader = new CustomLabel();
        panelCurrentHeader = new JPanel();
        labelCurrentHeaderTitle = new CustomLabel();
        panelCurrentInfo = new JPanel();
        labelCurrentInfoKPH = new CustomLabel();
        labelCurrentInfoKC = new CustomLabel();
        labelCurrentInfoSnipes = new CustomLabel();
        labelCurrentInfoEHB = new CustomLabel();
        labelCurrentInfoPB = new CustomLabel();
        separatorCurrent = new JSeparator();
        labelCurrentInfoDuration = new CustomLabel();
        buttonCurrentReset = new JButton(resetImage);
        panelOverallHeader = new JPanel();
        labelOverallHeaderTitle = new CustomLabel();
        panelOverallInfo = new JPanel();
        labelOverallInfoKPH = new CustomLabel();
        labelOverallInfoKC = new CustomLabel();
        labelOverallInfoSnipes = new CustomLabel();
        labelOverallInfoEHB = new CustomLabel();
        labelOverallInfoPB = new CustomLabel();
        separatorOverall = new JSeparator();
        labelOverallInfoDuration = new CustomLabel();
        buttonOverallReset = new JButton(resetImage);

        buttonCurrentReset.setFocusPainted(false);
        buttonCurrentReset.addActionListener(e ->
                plugin.ResetCurrent());

        buttonOverallReset.setFocusPainted(false);
        buttonOverallReset.addActionListener(e ->
                plugin.ResetOverall());

    }

    /**
     * Initial setup of Header panel
     * Sets color,label data and grid layout settings
     *
     */
    private void SetUpHeaderPanel(JPanel headerPanel, CustomLabel titleLabel, String header, int headerSizeV){
        headerPanel.setBackground(SUB_PANEL_COLOR_HEADER);
        titleLabel.setData(SwingConstants.CENTER,header,titleFont);

        GroupLayout layout = new GroupLayout(headerPanel);
        headerPanel.setLayout(layout);
        layout.setHorizontalGroup(
                layout.createParallelGroup(GroupLayout.Alignment.LEADING)
                        .addGroup(layout.createSequentialGroup()
                                .addComponent(titleLabel, GroupLayout.DEFAULT_SIZE, GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                        )
        );
        layout.setVerticalGroup(
                layout.createParallelGroup(GroupLayout.Alignment.LEADING)
                        .addGroup(layout.createSequentialGroup()
                                .addComponent(titleLabel, GroupLayout.DEFAULT_SIZE, headerSizeV, Short.MAX_VALUE)
                        )
        );
    }
    /**
     * Initial setup of Info panel
     * Sets color,dimension,label defaults and grid layout settings
     *
     */
    private void SetUpInfoPanel(JPanel infoPanel, Component separator, CustomLabel kph, CustomLabel kc, CustomLabel snipes, CustomLabel ehb, CustomLabel pb, CustomLabel duration, JButton button){

        infoPanel.setBackground(SUB_PANEL_COLOR_MAIN);
        infoPanel.setPreferredSize(SUB_PANEL_DIMENSIONS);


        kph.setText("KPH: --");
        kc.setText("KC: 0");
        snipes.setText("Snipes: 0");
        ehb.setText("EHB: --");
        duration.setText("🕑 0:00:00");
        pb.setText("PB: --");

        GroupLayout gridLayout = new GroupLayout(infoPanel);
        infoPanel.setLayout(gridLayout);

        int buttonSize = 24;

        gridLayout.setHorizontalGroup(
                gridLayout.createParallelGroup(GroupLayout.Alignment.LEADING)
                        .addComponent(separator)
                        .addGroup(gridLayout.createSequentialGroup()
                                .addContainerGap()
                                .addGroup(gridLayout.createParallelGroup(GroupLayout.Alignment.LEADING)
                                        .addGroup(gridLayout.createSequentialGroup()
                                                .addGroup(gridLayout.createParallelGroup(GroupLayout.Alignment.LEADING)
                                                        .addComponent(kph)
                                                        .addComponent(kc)
                                                        .addComponent(snipes)
                                                        .addComponent(ehb)
                                                        .addComponent(pb)
                                                ))
                                        .addGroup(gridLayout.createSequentialGroup()
                                                .addComponent(duration, GroupLayout.DEFAULT_SIZE, GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                                                .addPreferredGap(LayoutStyle.ComponentPlacement.RELATED)
                                                .addComponent(button, GroupLayout.PREFERRED_SIZE, buttonSize, GroupLayout.PREFERRED_SIZE))))
        );
        gridLayout.setVerticalGroup(
                gridLayout.createParallelGroup(GroupLayout.Alignment.LEADING)
                        .addGroup(gridLayout.createSequentialGroup()
                                .addContainerGap()
                                .addComponent(kph)
                                .addPreferredGap(LayoutStyle.ComponentPlacement.RELATED)
                                .addComponent(kc)
                                .addPreferredGap(LayoutStyle.ComponentPlacement.RELATED)
                                .addComponent(snipes)
                                .addPreferredGap(LayoutStyle.ComponentPlacement.RELATED)
                                .addComponent(ehb)
                                .addPreferredGap(LayoutStyle.ComponentPlacement.RELATED)
                                .addComponent(pb)
                                .addPreferredGap(LayoutStyle.ComponentPlacement.RELATED)
                                .addGroup(gridLayout.createParallelGroup(GroupLayout.Alignment.TRAILING)
                                        .addGroup(gridLayout.createSequentialGroup()
                                                .addComponent(separator, GroupLayout.PREFERRED_SIZE, GroupLayout.PREFERRED_SIZE, GroupLayout.PREFERRED_SIZE)
                                                .addPreferredGap(LayoutStyle.ComponentPlacement.RELATED)
                                                .addComponent(duration))
                                        .addComponent(button, GroupLayout.PREFERRED_SIZE, buttonSize, GroupLayout.PREFERRED_SIZE))
                                .addContainerGap(GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
        );
    }

    /**
     * Set KPH Text of given section
     */
    public void SetKPH(PERFORMANCE_SECTION section){
        String kphText = utils.GetKillsPerHourString(section,true);
        boolean current = section == PERFORMANCE_SECTION.CURRENT;
        if(current){
            labelCurrentInfoKPH.setText(kphText);
        }else{
            labelOverallInfoKPH.setText(kphText);
        }
    }
    /**
     * Set KC Text of given section
     */
    public void SetKC(PERFORMANCE_SECTION section){
        String kcText = utils.GetKCString(section);
        boolean current = section == PERFORMANCE_SECTION.CURRENT;
        if(current){
            labelCurrentInfoKC.setText(kcText);
        }else{
            labelOverallInfoKC.setText(kcText);
        }
    }
    /**
     * Set Snipe Text of given section
     */
    public void SetSnipes(PERFORMANCE_SECTION section){
        String snipeText = utils.GetSnipeString(section);
        boolean current = section == PERFORMANCE_SECTION.CURRENT;
        if(current){
            labelCurrentInfoSnipes.setText(snipeText);
        }else{
            labelOverallInfoSnipes.setText(snipeText);
        }
    }
    /**
     * Set EHB Text of given section
     */
    public void SetEHB(PERFORMANCE_SECTION section){
        String ehbText = utils.GetEHBString(section);
        boolean current = section == PERFORMANCE_SECTION.CURRENT;
        if(current){
            labelCurrentInfoEHB.setText(ehbText);
        }else{
            labelOverallInfoEHB.setText(ehbText);
        }
    }
    /**
     * Set Duration Text of given section
     */
    public void SetDuration(PERFORMANCE_SECTION section, boolean preventFall){
        String durationText = utils.GetDurationString(section,preventFall);
        boolean current = section == PERFORMANCE_SECTION.CURRENT;
        if(current){
            labelCurrentInfoDuration.setText(durationText);
        }else{
            labelOverallInfoDuration.setText(durationText);
        }
    }
    /**
     * Set PB Text of given section
     */
    public void SetPB(PERFORMANCE_SECTION section){
        String pbText = utils.GetPBString(section);
        boolean current = section == PERFORMANCE_SECTION.CURRENT;
        if(current){
            labelCurrentInfoPB.setText(pbText);
        }else{
            labelOverallInfoPB.setText(pbText);
        }
    }

    /**
     * Set Boss header to the recent boss name
     * For dks and other potential partner bosses, we generate a name based on the current partners short-names
     * EX dks multi: Dagannoth Rex and Dagannoth Prime would be "Rex,Prime"
     * EX dks single: Dagannoth Rex would be "Dagannoth Rex"
     */
    public void SetBossName(){
        if(plugin.currentPartnerBosses != null){
            labelBossHeader.setText(BossData.GetBossName(plugin.currentPartnerBosses));
        }else
        {
            labelBossHeader.setText(plugin.recentKillName);
        }
    }

    /**
     * Sets Overall section to be invalid/mixed
     * Differing bosses that aren't partners(dks) are tracked in overall
     * To prevent confusion/fake inflated values, indicate to the user that overall tracking has multiple different sessions
     */
    public void SetInvalidOverall(boolean invalid){
        labelOverallHeaderTitle.setText(invalid ? "Mixed Overall" : "Overall");
    }


}

package com.boostperformance;
import lombok.Getter;
import net.runelite.api.NpcID;

import java.util.Set;

enum BossDataStatics
{
    CORPOREAL_BEAST(NpcID.CORPOREAL_BEAST,-1,null,"Corp","Corporeal Beast",30.0, 1676, 60.0),
    GENERAL_GRAARDOR(NpcID.GENERAL_GRAARDOR,-1,null,"Bandos","General Graardor",90.0, 7020, 58.0),
    KRIL_TSUTSAROTH(NpcID.KRIL_TSUTSAROTH,-1,null,"Zammy","K'ril Tsutsaroth", 90.0, 6949, 65.0),
    KREEARRA(NpcID.KREEARRA,-1,null,"Arma","Kree'arra", 90.0, 6979, 40.0),
    COMMANDER_ZILYANA(NpcID.COMMANDER_ZILYANA,-1,null,"Sara","Commander Zilyana", 90.0, 6968, 60.0),
    SARACHNIS(NpcID.SARACHNIS,-1,null,"Sarachnis","Sarachnis", 9.6, 8318, 80.0),
    SCORPIA(NpcID.SCORPIA,-1,null,"Scorpia","Scorpia", 9.6, 6256, 130.0),
    GIANT_MOLE(NpcID.GIANT_MOLE,-1,null,"Mole","Giant Mole", 9.0,3310, 125.0),
    KING_BLACK_DRAGON(NpcID.KING_BLACK_DRAGON,-1,null,"KBD","King Black Dragon",9.0, 92, 130.0),
    CHAOS_ELEMENTAL(NpcID.CHAOS_ELEMENTAL,-1,null,"Chaos Ele","Chaos Elemental", 60.0, 3147, 120.0),
    KALPHITE_QUEEN(NpcID.KALPHITE_QUEEN_963,NpcID.KALPHITE_QUEEN_965,null,"KQ","Kalphite Queen", 30.0, 6233, 55.0),
    CERBERUS(NpcID.CERBERUS_5863,NpcID.CERBERUS,null,"Cerberus","Cerberus", 9.0, 4495, 65.0),
    ABYSSAL_SIRE(NpcID.ABYSSAL_SIRE,NpcID.ABYSSAL_SIRE_5908,null,"Sire","Abyssal Sire", 0.6, 7100, 45.0),
    THERMONUCLEAR_SMOKE_DEVIL(NpcID.THERMONUCLEAR_SMOKE_DEVIL,-1,null,"Thermy","Thermonuclear smoke devil", 0.6, 3849, 150.0),
    KRAKEN(NpcID.WHIRLPOOL_496,NpcID.KRAKEN,null,"Kraken","Kraken", 8.4, 3993, 100.0),
    SCURRIUS(NpcID.SCURRIUS,-1,null,"Scurrius","Scurrius",18.0, 10705, 85.0),
    DAGANNOTH_SUPREME(NpcID.DAGANNOTH_SUPREME,-1,Set.of(NpcID.DAGANNOTH_REX, NpcID.DAGANNOTH_PRIME),"Supreme","Dagannoth Supreme", 90.0, 2856, 105.0),
    DAGANNOTH_PRIME(NpcID.DAGANNOTH_PRIME,-1,Set.of(NpcID.DAGANNOTH_REX, NpcID.DAGANNOTH_SUPREME),"Prime","Dagannoth Prime", 90.0, 2856, 105.0),
    DAGANNOTH_REX(NpcID.DAGANNOTH_REX,-1,Set.of(NpcID.DAGANNOTH_SUPREME, NpcID.DAGANNOTH_PRIME),"Rex","Dagannoth Rex", 90.0, 2856, 105.0);

    @Getter
    private final int spawnFormId;
    @Getter
    private final int finalFormId;
    @Getter
    private final Set<Integer> validPartners;
    @Getter
    private final String shortName;
    @Getter
    private final String fullName;
    @Getter
    private final double spawnSeconds;
    @Getter
    private final int deathAnimationId;
    @Getter
    private final double ehb;
    public static final Set<Integer> midKillBossSpawns = Set.of(NpcID.ABYSSAL_SIRE_5887, NpcID.ABYSSAL_SIRE_5888, NpcID.ABYSSAL_SIRE_5889,NpcID.ABYSSAL_SIRE_5890,NpcID.ABYSSAL_SIRE_5891, NpcID.ABYSSAL_SIRE_5908);

    /**
     * Set Boss data based on static values
     * set final form to be identical to spawn form if no final form specified
     * EHB WILL BE OVERWRITTEN VIA SUCCESSFUL WEB CALL
     */
    BossDataStatics(int spawnFormId, int finalFormId, Set<Integer> validPartners, String shortName, String fullName, double spawnSeconds, int deathAnimationId, double ehb)
    {
        this.spawnFormId = spawnFormId;
        this.finalFormId = finalFormId == -1 ? spawnFormId : finalFormId;
        this.spawnSeconds = spawnSeconds;
        this.validPartners = validPartners;
        this.shortName = shortName;
        this.fullName = fullName;
        this.deathAnimationId = deathAnimationId;
        this.ehb = ehb;
    }
}


package com.boostperformance;

import java.time.Duration;
import java.time.Instant;
import java.util.ArrayList;
import java.util.List;

public class PerformanceStats
{
    //collection of tracked currents.
    public static List<PerformanceStats> statsCollection = new ArrayList<>();
    //overall sum of collection
    public static PerformanceStats overallStats = new PerformanceStats();

    int bossId;
    double kph;
    int kc;
    int snipes;
    double ehb;
    long pb;
    Duration duration;

    public PerformanceStats(){
        this.bossId = 0;
        this.kph = 0;
        this.kc = 0;
        this.snipes = 0;
        this.ehb = 0;
        this.pb = -1;
        this.duration = Duration.ZERO;
    }
    public PerformanceStats(int bossId,double kph,int kc,int snipes,double ehb, long pb,Duration duration){
        this.bossId = bossId;
        this.kph = kph;
        this.kc = kc;
        this.snipes = snipes;
        this.ehb = ehb;
        this.pb = pb;
        this.duration = duration;

        overallStats.kc += kc;
        overallStats.snipes += snipes;
        overallStats.ehb += ehb;
        overallStats.duration = overallStats.duration.plus(duration);

        if(pb != -1 && pb < overallStats.pb)
            overallStats.pb = pb;

        double secondsPerKill = (double)overallStats.duration.getSeconds() / (double)overallStats.kc;
        overallStats.kph = (3600d / secondsPerKill);

    }

    public static void Add(int bossId, double kph, int kc, int snipes, double ehb, long pb, Instant startTime, Instant killStartTime){
        statsCollection.add(new PerformanceStats(bossId,kph,kc,snipes,ehb,pb,Duration.between(startTime,killStartTime)));
    }

    public static void Clear(BoostPerformancePlugin plugin){
        statsCollection.clear();
        overallStats = new PerformanceStats();
        overallStats.pb = plugin.currentFastestKill;
    }


}

package com.boostperformance;

import net.runelite.client.config.Config;
import net.runelite.client.config.ConfigGroup;
import net.runelite.client.config.ConfigItem;

@ConfigGroup("boostperformance")
public interface BoostPerformanceConfig extends Config
{
    @ConfigItem(
            keyName = "isMain",
            name = "Is Main",
            description = "You should be getting the drops (multiple may be the main, only necessary if main in party)",
            position = 1
    )
    default boolean isMain()
    {
        return false;
    }

    @ConfigItem(
            position = 2,
            keyName = "displayKillMessage",
            name = "Display Kill Message",
            description = "Display game message with information about the kill upon boss death."
    )
    default boolean getDisplayKillMessage()
    {
        return false;
    }

    @ConfigItem(
            position = 3,
            keyName = "displayKillMessage",
            name = "Display Reset Message",
            description = "Display game message when a reset has occured."
    )
    default boolean getDisplayResetMessage()
    {
        return true;
    }

    @ConfigItem(
            keyName = "preventFalloff",
            name = "Prevent Falloff",
            description = "Current & overall duration only update on kill for more accuracy.",
            position = 4
    )
    default boolean getPreventFallOff()
    {
        return true;
    }

}

package com.boostperformance;

import javax.swing.*;
import net.runelite.client.ui.FontManager;

import java.awt.*;

public class CustomLabel extends JLabel
{
    final Font boldFont  = FontManager.getRunescapeBoldFont();
    public CustomLabel(String text)
    {
        super(text);
        this.setFont(boldFont);
    }

    public CustomLabel()
    {
        super("");
        this.setFont(boldFont);
    }

    public void setData(int alignment, String text, Font font){
        setHorizontalAlignment(alignment);
        setText(text);
        setFont(font);
    }



}

package com.boostperformance;

import net.runelite.api.NPC;

import java.util.HashMap;
import java.util.Map;
import java.util.Set;

public class BossData
{
    private final int spawnFormId;
    private final int finalFormId;

    private final Set<Integer> validPartners;
    private final String shortName;
    private final String fullName;
    private final double spawnSeconds;
    private final int deathAnimationId;
    public double ehb;
    public static final Map<Integer, BossData> spawnFormBosses = new HashMap<>();
    public static final Map<Integer, BossData> finalFormBosses = new HashMap<>();
    public static final Map<String, BossData> bossesByName = new HashMap<>();

    static
    {
        for (BossDataStatics boss : BossDataStatics.values())
        {
            BossData.AddBoss(
                    boss.getSpawnFormId(),
                    boss.getFinalFormId(),
                    boss.getValidPartners(),
                    boss.getShortName(),
                    boss.getFullName(),
                    boss.getSpawnSeconds(),
                    boss.getDeathAnimationId(),
                    boss.getEhb());
        }
    }
    BossData(int spawnFormId, int finalFormId, Set<Integer> validPartners, String shortName, String fullName, double spawnSeconds, int deathAnimationId, double ehb)
    {
        this.spawnFormId = spawnFormId;
        this.finalFormId = finalFormId == -1 ? spawnFormId : finalFormId;
        this.spawnSeconds = spawnSeconds;
        this.validPartners = validPartners;
        this.shortName = shortName;
        this.fullName = fullName;
        this.deathAnimationId = deathAnimationId;
        this.ehb = ehb;
    }

    public int getSpawnFormId()
    {
        return spawnFormId;
    }

    public int getFinalFormId()
    {
        return finalFormId;
    }

    public String getFullName()
    {
        return fullName;
    }
    /**
     * Check if passed boss ID is a partner of the current boss (DKS)
     */
    public boolean hasPartner(int partnerId){
        if(validPartners == null)
            return false;
        return validPartners.contains(partnerId);
    }

    public double getSpawnSeconds()
    {
        return spawnSeconds;
    }
    /**
     * Find Boss of given ID in the spawnForm list
     */
    public static BossData FindSpawnForm(int id)
    {
        return spawnFormBosses.get(id);
    }
    /**
     * Find Boss of given ID in the finalForm list
     */
    public static BossData FindFinalForm(int id)
    {
        return finalFormBosses.get(id);
    }
    /**
     * Find Boss ID of given name in bossesByName list
     */
    public static int FindBossIDByName(String bossName)
    {
        BossData boss = bossesByName.get(bossName);
        return boss != null ? boss.finalFormId : -1;
    }
    /**
     * Validate the death of an NPC - ONLY CALLED DURING DESPAWN EVENT
     * ensure boss is in its final form and animation is the death animation
     * this prevents overkill issues and rendering issues from causing false positives
     */
    public static boolean IsValidDeath(NPC npc){
        BossData boss = FindFinalForm(npc.getId());
        if(boss != null)
            return (npc.getAnimation() == boss.deathAnimationId);

        return false;
    }
    /**
     * Validate the spawn of an NPC
     * ensure boss is in its starting form
     */
    public static boolean IsValidBossSpawn(NPC npc){
        return FindSpawnForm(npc.getId()) != null;
    }

    /**
     * In the case of the users first spawn event being a mid-kill boss, mostly applies to sire when using a vent-killer
     */
    public static boolean IsMidKillBossSpawn(NPC npc){
        return (BossDataStatics.midKillBossSpawns.contains(npc.getId()));
    }
    /**
     * Set EHB of a bosses spawn and final forms
     * Used to update the existing static values from web-generated data
     */
    public static void SetBossEHB(int spawnFormId, double ehb){
        BossData boss = FindSpawnForm(spawnFormId);
        spawnFormBosses.get(boss.spawnFormId).ehb = ehb;
        finalFormBosses.get(boss.finalFormId).ehb = ehb;
    }
    /**
     * Adds bossdata to lists of valid bosses, used both with initial hardcoded values & additional web values
     * Allows list of bosses to be up to date when new bosses are released while not creating an unnecessary amount of traffic
     */
    public static void AddBoss(int spawnFormId, int finalFormId, Set<Integer> validPartners, String shortName, String fullName, double spawnSeconds, int deathAnimationId, double ehb)
    {
        if(spawnFormBosses.containsKey(spawnFormId))
            return;

        if(spawnFormId == -1)
            return;

        BossData boss = new BossData(spawnFormId,finalFormId,validPartners,shortName,fullName,spawnSeconds,deathAnimationId,ehb);
        BossData.spawnFormBosses.put(spawnFormId,boss);
        BossData.finalFormBosses.put(finalFormId,boss);
        BossData.bossesByName.put(fullName,boss);
    }

    /**
     * Get combined boss name based on current partners
     * For dks and other potential partner bosses, we generate a name based on the current partners short-names
     * EX dks multi: Dagannoth Rex and Dagannoth Prime would be "Rex,Prime"
     * EX dks single: Dagannoth Rex would be "Dagannoth Rex"
     */
    public static String GetBossName(Set<Integer> partners){
        StringBuilder conName = new StringBuilder();
        if(partners != null){
            for (int partnerId : partners)
            {
                conName.append(FindSpawnForm(partnerId).shortName).append(",");
            }
            conName.deleteCharAt(conName.length() - 1);
        }
        return conName.toString();
    }
}

