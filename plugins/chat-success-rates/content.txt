package com.chatsuccessrates;

import com.google.gson.Gson;
import java.awt.BorderLayout;
import java.awt.Color;
import java.awt.Dimension;
import java.awt.Toolkit;
import java.awt.datatransfer.StringSelection;
import java.util.ArrayList;
import java.util.Comparator;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import javax.swing.Box;
import javax.swing.BoxLayout;
import javax.swing.JButton;
import javax.swing.JComboBox;
import javax.swing.JLabel;
import javax.swing.JOptionPane;
import javax.swing.JPanel;
import javax.swing.SwingConstants;
import javax.swing.border.EmptyBorder;
import lombok.Getter;
import net.runelite.api.Client;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.eventbus.EventBus;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.FontManager;
import net.runelite.client.ui.PluginPanel;
import net.runelite.client.ui.components.TitleCaseListCellRenderer;

class ChatSuccessRatesPluginPanel extends PluginPanel
{
	private final JPanel successRatesPanel = new JPanel();
	private final JComboBox<ChatSuccessRatesSkill> skillSelection = new JComboBox<>();
	private final JComboBox<ChatSuccessRatesTracker> trackerSelection = new JComboBox<>();

	private final ChatSuccessRatesConfig config;
	private final ChatSuccessRatesPlugin plugin;
	private final Client client;
	private final ConfigManager configManager;
	private final Gson gson;
	private final EventBus eventBus;

	@Getter
	private Map<ChatSuccessRatesSkill, List<ChatSuccessRatesTracker>> trackers = new HashMap<>();

	public ChatSuccessRatesPluginPanel(ChatSuccessRatesConfig config, ChatSuccessRatesPlugin plugin, Client client,
		ConfigManager configManager, Gson gson, EventBus eventBus)
	{
		this.config = config;
		this.plugin = plugin;
		this.client = client;
		this.configManager = configManager;
		this.gson = gson;
		this.eventBus = eventBus;

		setLayout(new BorderLayout());
		setBorder(new EmptyBorder(10, 10, 10, 10));

		JLabel title = new JLabel("Chat Success Rates");
		title.setForeground(Color.WHITE);

		JPanel titlePanel = new JPanel(new BorderLayout());
		titlePanel.setBorder(new EmptyBorder(1, 3, 10, 0));
		titlePanel.add(title, BorderLayout.WEST);

		JPanel settingsPanel = new JPanel(new BorderLayout());
		settingsPanel.setBorder(new EmptyBorder(5, 0, 0, 0));
		JButton deleteButton = new JButton("Reset data");
		JButton exportButton = new JButton("Export to clipboard");
		deleteButton.setPreferredSize(new Dimension(85, 25));
		exportButton.setPreferredSize(new Dimension(128, 25));
		deleteButton.setForeground(Color.WHITE);
		exportButton.setForeground(Color.WHITE);
		deleteButton.setFont(FontManager.getRunescapeSmallFont());
		exportButton.setFont(FontManager.getRunescapeSmallFont());
		deleteButton.addActionListener(actionEvent ->
		{
			int confirm = JOptionPane.showConfirmDialog(ChatSuccessRatesPluginPanel.this,
				"Are you sure you want to permanently delete the data associated with this tracker?",
				"Warning", JOptionPane.OK_CANCEL_OPTION);

			if (confirm == 0)
			{
				if (trackerSelection.getSelectedItem() == null)
				{
					return;
				}
				ChatSuccessRatesTracker tracker = (ChatSuccessRatesTracker) trackerSelection.getSelectedItem();
				tracker.reset();
			}
		});
		exportButton.addActionListener(actionEvent ->
		{
			if (trackerSelection.getSelectedItem() == null)
			{
				return;
			}
			ChatSuccessRatesTracker tracker = (ChatSuccessRatesTracker) trackerSelection.getSelectedItem();
			StringBuilder text = new StringBuilder(tracker.toString() + ":\nLevel\tSuccesses\tFailures");
			for (ChatSuccessRatesBar bar : tracker.getTrackerBars())
			{
				text.append(text.length() > 0 ? "\n" : "").append(bar.toString());
			}
			Toolkit.getDefaultToolkit().getSystemClipboard().setContents(new StringSelection(text.toString()), null);
		});
		settingsPanel.add(deleteButton, BorderLayout.WEST);
		settingsPanel.add(exportButton, BorderLayout.EAST);

		JPanel headerPanel = new JPanel(new BorderLayout());
		headerPanel.setBorder(new EmptyBorder(5, 0, 0, 0));

		JLabel[] headerLabels = new JLabel[]
		{
			new JLabel("Successes"),
			new JLabel("Level"),
			new JLabel("Failures")
		};

		for (JLabel label : headerLabels)
		{
			label.setForeground(Color.WHITE);
			label.setHorizontalAlignment(SwingConstants.CENTER);
			label.setVerticalAlignment(SwingConstants.TOP);
			label.setFont(FontManager.getRunescapeSmallFont());
			label.setPreferredSize(new Dimension(PluginPanel.PANEL_WIDTH / headerLabels.length, 10));
		}

		headerPanel.add(headerLabels[0], BorderLayout.WEST);
		headerPanel.add(headerLabels[1], BorderLayout.CENTER);
		headerPanel.add(headerLabels[2], BorderLayout.EAST);

		JPanel optionPanel = new JPanel();
		optionPanel.setLayout(new BoxLayout(optionPanel, BoxLayout.Y_AXIS));
		optionPanel.setBorder(new EmptyBorder(0, 0, 10, 0));

		successRatesPanel.setLayout(new BoxLayout(successRatesPanel, BoxLayout.Y_AXIS));
		successRatesPanel.setBackground(ColorScheme.DARK_GRAY_COLOR);

		skillSelection.setRenderer(new TitleCaseListCellRenderer());
		trackerSelection.setRenderer(new TitleCaseListCellRenderer());

		loadTrackers();

		skillSelection.addActionListener(e ->
		{
			if (skillSelection.getSelectedItem() != null)
			{
				final ChatSuccessRatesSkill skill = (ChatSuccessRatesSkill) skillSelection.getSelectedItem();
				trackerSelection.removeAllItems();
				for (ChatSuccessRatesTracker tracker : trackers.get(skill))
				{
					trackerSelection.addItem(tracker);
				}
			}
		});

		trackerSelection.addActionListener(e -> displaySelectedTracker());

		skillSelection.setSelectedIndex(skillSelection.getItemCount() > config.indexSkill() ? config.indexSkill() : 0);

		trackerSelection.setSelectedIndex(trackerSelection.getItemCount() > config.indexTracker() ? config.indexTracker() : 0);

		optionPanel.add(titlePanel);
		optionPanel.add(skillSelection);
		optionPanel.add(Box.createRigidArea(new Dimension(0, 5)));
		optionPanel.add(trackerSelection);
		optionPanel.add(settingsPanel);
		optionPanel.add(headerPanel);

		add(optionPanel, BorderLayout.NORTH);
		add(successRatesPanel, BorderLayout.CENTER);
	}

	private void loadTrackers()
	{
		ChatSuccessRatesAction[] allTrackers = ChatSuccessRatesAction.values();

		for (ChatSuccessRatesAction action : allTrackers)
		{
			ChatSuccessRatesTracker tracker = action.getTracker();

			// Start tracker
			tracker.register(eventBus, client, config, plugin, configManager, gson);
			tracker.loadTrackerData();

			final Map<Integer, ChatSuccessRatesBar> trackerBars = new HashMap<>();
			for (Map.Entry<Integer, Integer[]> levelRate : tracker.getLevelRates().entrySet())
			{
				final ChatSuccessRatesBar bar = new ChatSuccessRatesBar(levelRate.getKey(), tracker.getColor());
				bar.update(levelRate.getValue()[0], levelRate.getValue()[1]);
				trackerBars.put(levelRate.getKey(), bar);
			}
			tracker.setTrackerBars(trackerBars);

			// Prepare selections
			List<ChatSuccessRatesTracker> skillTrackers = new ArrayList<>();
			if (trackers.containsKey(tracker.getSkill()))
			{
				skillTrackers = trackers.get(tracker.getSkill());
			}
			skillTrackers.add(tracker);
			skillTrackers.sort(null);
			trackers.put(tracker.getSkill(), skillTrackers);
		}

		// Populate skill selection
		List<ChatSuccessRatesSkill> skills = new ArrayList<>(trackers.keySet());
		skills.sort(Comparator.comparing(ChatSuccessRatesSkill::ordinal));
		skillSelection.removeAllItems();
		for (ChatSuccessRatesSkill skill : skills)
		{
			skillSelection.addItem(skill);
		}
	}

	public void displaySelectedTracker()
	{
		config.indexSkill(skillSelection.getSelectedIndex());
		config.indexTracker(trackerSelection.getSelectedIndex());

		if (trackerSelection.getSelectedItem() == null)
		{
			return;
		}
		ChatSuccessRatesTracker tracker = (ChatSuccessRatesTracker) trackerSelection.getSelectedItem();

		successRatesPanel.removeAll();

		for (ChatSuccessRatesBar bar : tracker.getTrackerBars())
		{
			successRatesPanel.add(bar);
		}

		repaint();
		revalidate();
	}
}

package com.chatsuccessrates.trackers;

import com.chatsuccessrates.ChatSuccessRatesSkill;
import com.chatsuccessrates.ChatSuccessRatesTracker;
import java.awt.Color;
import java.util.HashSet;
import java.util.Set;
import lombok.RequiredArgsConstructor;
import net.runelite.api.events.ChatMessage;
import net.runelite.client.eventbus.Subscribe;
import org.apache.commons.lang3.StringUtils;
import org.apache.commons.text.WordUtils;
import static com.chatsuccessrates.ChatSuccessRatesPlugin.COLLAPSIBLE_MESSAGETYPES;

@RequiredArgsConstructor
public class CatchingPetfish extends ChatSuccessRatesTracker
{
	public static final String TYPE_BLUE = "Bluefish";
	public static final String TYPE_GREEN = "Greenfish";
	public static final String TYPE_SPINE = "Spinefish";

	private final String type;

	private String getMessageSuccess(String type)
	{
		return "...and you catch a Tiny " + type + "!";
	}

	private Set<String> getMessagesFailure()
	{
		Set<String> failures = new HashSet<>();
		for (String type : new String[] { TYPE_BLUE, TYPE_GREEN, TYPE_SPINE })
		{
			if (!type.equals(this.type))
			{
				failures.add(getMessageSuccess(type));
			}
		}
		return failures;
	}

	@Override
	public ChatSuccessRatesSkill getSkill()
	{
		return ChatSuccessRatesSkill.FISHING;
	}

	@Override
	public Color getColor()
	{
		switch (type)
		{
			default:
				return new Color(27, 165, 227);
			case TYPE_GREEN:
				return new Color(0, 255, 0);
			case TYPE_SPINE:
				return new Color(255, 150, 0);
		}
	}

	@Subscribe
	public void onChatMessage(final ChatMessage event)
	{
		if (!COLLAPSIBLE_MESSAGETYPES.contains(event.getType()))
		{
			return;
		}

		final String message = event.getMessage();
		final int level = (config != null && config.useBoostedLevel())
			? client.getBoostedSkillLevel(getSkill().getSkill())
			: client.getRealSkillLevel(getSkill().getSkill());

		if (getMessageSuccess(type).equals(message))
		{
			update(level, 1, 0);
		}
		else if (getMessagesFailure().contains(message))
		{
			update(level, 0, 1);
		}
	}

	@Override
	public String getTrackerName()
	{
		return "CatchingTiny" + StringUtils.deleteWhitespace(WordUtils.capitalize(type)) + "Pets";
	}
}

package com.chatsuccessrates.trackers;

import org.apache.commons.lang3.StringUtils;
import org.apache.commons.text.WordUtils;
import com.chatsuccessrates.ChatSuccessRatesSkill;
import com.chatsuccessrates.ChatSuccessRatesTracker;
import lombok.RequiredArgsConstructor;
import net.runelite.api.ChatMessageType;
import net.runelite.api.InventoryID;
import net.runelite.api.ItemContainer;
import net.runelite.api.ItemID;
import net.runelite.api.events.ChatMessage;
import net.runelite.client.eventbus.Subscribe;

@RequiredArgsConstructor
public class MiningRock extends ChatSuccessRatesTracker
{
	private static final String ATTEMPT = "You swing your pick at the rock.";

	private final String ore;
	private int start = 0;

	private String getMessageSuccess()
	{
		return "You manage to mine some " + ore + ".";
	}

	@Override
	public ChatSuccessRatesSkill getSkill()
	{
		return ChatSuccessRatesSkill.MINING;
	}

	@Subscribe
	public void onChatMessage(final ChatMessage event)
	{
		if (!ChatMessageType.SPAM.equals(event.getType()))
		{
			return;
		}

		final String message = event.getMessage();
		final int level = client.getBoostedSkillLevel(getSkill().getSkill());

		if (ATTEMPT.equals(message))
		{
			start = client.getTickCount();
		}
		else if (getMessageSuccess().equals(message))
		{
			// -1 for arrive delay, but does not change number of fails when
			// there is no arrive delay because no pickaxe has 1 tick interval
			int fails = (client.getTickCount() - start - 1) / getPickaxeInterval(level);
			update(level, 1, fails);
		}
	}

	@Override
	public String getTrackerName()
	{
		return "Mining" + StringUtils.deleteWhitespace(WordUtils.capitalize(ore));
	}

	private int getPickaxeInterval(int level)
	{
		ItemContainer inventory = client.getItemContainer(InventoryID.INVENTORY);
		ItemContainer equipment = client.getItemContainer(InventoryID.EQUIPMENT);
		if (inventory == null && equipment == null)
		{
			return -1;
		}
		for (Pickaxe pickaxe : Pickaxe.values())
		{
			if (level < pickaxe.level)
			{
				continue;
			}
			for (int itemId : pickaxe.itemIds)
			{
				if ((inventory != null && inventory.find(itemId) >= 0) ||
					(equipment != null && equipment.find(itemId) >= 0))
				{
					return pickaxe.interval;
				}
			}
		}
		return -1;
	}

	private static enum Pickaxe
	{
		CRYSTAL(71, 3, ItemID.CRYSTAL_PICKAXE, ItemID.CRYSTAL_PICKAXE_23863),
		DRAGON(61, 3, ItemID.DRAGON_PICKAXE, ItemID.DRAGON_PICKAXE_12797, ItemID.DRAGON_PICKAXE_OR, ItemID.DRAGON_PICKAXE_OR_25376),
		GILDED(41, 3, ItemID.GILDED_PICKAXE),
		RUNE(41, 3, ItemID.RUNE_PICKAXE),
		ADAMANT(31, 4, ItemID.ADAMANT_PICKAXE),
		MITHRIL(21, 5, ItemID.MITHRIL_PICKAXE),
		BLACK(11, 5, ItemID.BLACK_PICKAXE),
		STEEL(6, 6, ItemID.STEEL_PICKAXE),
		IRON(1, 7, ItemID.IRON_PICKAXE),
		BRONZE(1, 8, ItemID.BRONZE_PICKAXE),
		;

		private final int level;
		private final int interval;
		private final int[] itemIds;

		Pickaxe(int level, int interval, int... itemIds)
		{
			this.level = level;
			this.interval = interval;
			this.itemIds = itemIds;
		}
	}
}

package com.chatsuccessrates.trackers;

import org.apache.commons.lang3.StringUtils;
import org.apache.commons.text.WordUtils;
import com.chatsuccessrates.ChatSuccessRatesSkill;
import com.chatsuccessrates.ChatSuccessRatesTracker;
import lombok.RequiredArgsConstructor;
import net.runelite.api.ChatMessageType;
import net.runelite.api.events.ChatMessage;
import net.runelite.client.eventbus.Subscribe;

@RequiredArgsConstructor
public class PickingLock extends ChatSuccessRatesTracker
{
	private final String objectSuccess;
	private final String object;
	private final int objectId;

	private String getMessageSuccess()
	{
		return "You pick the lock on the " + objectSuccess + ".";
	}

	private String getMessageAttempt()
	{
		return "You attempt to pick the lock on the " + object + ".";
	}

	@Override
	public ChatSuccessRatesSkill getSkill()
	{
		return ChatSuccessRatesSkill.THIEVING;
	}

	@Subscribe
	public void onChatMessage(final ChatMessage event)
	{
		if (!ChatMessageType.SPAM.equals(event.getType()))
		{
			return;
		}

		final String message = event.getMessage();
		final int level = client.getBoostedSkillLevel(getSkill().getSkill());

		if (getMessageAttempt().equals(message))
		{
			update(level, 0, 1);
		}
		else if (getMessageSuccess().equals(message))
		{
			// -1 fails because the last attempt is a success
			update(level, 1, -1);
		}
	}

	@Override
	public String getTrackerName()
	{
		return "Picking" + StringUtils.deleteWhitespace(WordUtils.capitalize(object)) + objectId + "Lock";
	}
}

package com.chatsuccessrates.trackers;

import com.chatsuccessrates.ChatSuccessRatesSkill;
import com.chatsuccessrates.ChatSuccessRatesTracker;
import lombok.RequiredArgsConstructor;
import net.runelite.api.ChatMessageType;
import net.runelite.api.events.ChatMessage;
import net.runelite.client.eventbus.Subscribe;
import org.apache.commons.lang3.StringUtils;
import org.apache.commons.text.WordUtils;

@RequiredArgsConstructor
public class Pickpocketing extends ChatSuccessRatesTracker
{
	private final String target;

	private String getMessageSuccess()
	{
		return "You pick the " + target + "'s pocket";
	}

	private String getMessageFailure()
	{
		return "You fail to pick the " + target + "'s pocket.";
	}

	@Override
	public ChatSuccessRatesSkill getSkill()
	{
		return ChatSuccessRatesSkill.THIEVING;
	}

	@Subscribe
	public void onChatMessage(final ChatMessage event)
	{
		if (!ChatMessageType.SPAM.equals(event.getType()))
		{
			return;
		}

		final String message = event.getMessage();
		final int level = client.getBoostedSkillLevel(getSkill().getSkill());

		if (message.startsWith(getMessageSuccess()))
		{
			update(level, 1, 0);
		}
		else if (getMessageFailure().equals(message))
		{
			update(level, 0, 1);
		}
	}

	@Override
	public String getTrackerName()
	{
		return "Pickpocketing" + StringUtils.deleteWhitespace(WordUtils.capitalize(target));
	}
}

package com.chatsuccessrates.trackers;

import com.chatsuccessrates.ChatSuccessRatesSkill;
import com.chatsuccessrates.ChatSuccessRatesTracker;
import net.runelite.api.Actor;
import net.runelite.api.AnimationID;
import net.runelite.api.ChatMessageType;
import net.runelite.api.events.AnimationChanged;
import net.runelite.api.events.ChatMessage;
import net.runelite.client.eventbus.Subscribe;

/*
 * This approach will produce skewed data if you cancel a firemaking attempt
 */
public class LightingLogs extends ChatSuccessRatesTracker
{
	private static final int IDLE = AnimationID.IDLE;
	private static final int FIREMAKING = AnimationID.FIREMAKING;
	private static final int FIREMAKING_DURATION = 4;
	private static final int FIREMAKING_DURATION_FIRST = 3;
	private static final int FIREMAKING_CHAT_MESSAGE_OFFSET = 1;
	private static final String FIREMAKING_CHAT_MESSAGE = "The fire catches and the logs begin to burn.";

	private int lastId;
	private int lastTick;

	private int lastLevel;
	private int lastSuccesses;
	private int lastFailures;

	@Override
	public ChatSuccessRatesSkill getSkill()
	{
		return ChatSuccessRatesSkill.FIREMAKING;
	}

	@Subscribe
	public void onAnimationChanged(AnimationChanged event)
	{
		if (client == null || plugin == null)
		{
			return;
		}
		Actor actor = event.getActor();
		Actor player = client.getLocalPlayer();

		if (player == null || !player.equals(actor))
		{
			return;
		}

		final int id = actor.getAnimation();
		final int tick = client.getTickCount();
		final int lvl = client.getBoostedSkillLevel(getSkill().getSkill());

		final int deltaTick = tick - lastTick;

		if (id == IDLE && lastId == IDLE && deltaTick == FIREMAKING_DURATION)
		{
			// Success when firemaking in a chain
			lastLevel = lvl;
			lastSuccesses = 1;
			lastFailures = 0;
		}
		else if (id == IDLE && lastId == FIREMAKING && deltaTick >= FIREMAKING_DURATION_FIRST)
		{
			if (((deltaTick - FIREMAKING_DURATION_FIRST) % FIREMAKING_DURATION) == 0)
			{
				// Fail(s) into a success when firemaking from a proper idle state
				final int fails = (deltaTick - FIREMAKING_DURATION_FIRST) / FIREMAKING_DURATION;
				lastLevel = lvl;
				lastSuccesses = 1;
				lastFailures = fails;
			}
			else if ((deltaTick % FIREMAKING_DURATION) == 0)
			{
				// Fail(s) into a success when firemaking in a chain
				final int fails = deltaTick / FIREMAKING_DURATION;
				lastLevel = lvl;
				lastSuccesses = 1;
				lastFailures = fails;
			}
		}

		lastId = id;
		lastTick = tick;
	}

	@Subscribe
	public void onChatMessage(ChatMessage event)
	{
		final int deltaTick = client.getTickCount() - lastTick;

		if (deltaTick == FIREMAKING_CHAT_MESSAGE_OFFSET && ChatMessageType.SPAM.equals(event.getType()) &&
			FIREMAKING_CHAT_MESSAGE.equals(event.getMessage()))
		{
			update(lastLevel, lastSuccesses, lastFailures);
		}
	}
}

package com.chatsuccessrates.trackers;

import com.chatsuccessrates.ChatSuccessRatesSkill;
import com.chatsuccessrates.ChatSuccessRatesTracker;
import java.awt.Color;
import net.runelite.api.events.ChatMessage;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.ui.SkillColor;
import static com.chatsuccessrates.ChatSuccessRatesPlugin.COLLAPSIBLE_MESSAGETYPES;
import static com.chatsuccessrates.ChatSuccessRatesPlugin.MESSAGE_DELIM;
import static net.runelite.api.ChatMessageType.MESBOX;

public class CustomConfig extends ChatSuccessRatesTracker
{
	@Override
	public ChatSuccessRatesSkill getSkill()
	{
		return ChatSuccessRatesSkill.CUSTOM;
	}

	@Override
	public Color getColor()
	{
		return config == null
			? super.getColor()
			: (ChatSuccessRatesSkill.CUSTOM.equals(config.levelPrefix())
				? Color.RED
				: SkillColor.find(config.levelPrefix().getSkill()).getColor());
	}

	@Override
	public String getTrackerName()
	{
		return "Config";
	}

	@Subscribe
	public void onChatMessage(final ChatMessage event)
	{
		if (config == null || !COLLAPSIBLE_MESSAGETYPES.contains(event.getType()) || event.getType() == MESBOX)
		{
			return;
		}

		final String message = event.getMessage();
		final ChatSuccessRatesSkill skill = config.levelPrefix();
		final int level = ChatSuccessRatesSkill.CUSTOM.equals(skill) ? client.getTotalLevel() :
			(config.useBoostedLevel() ? client.getBoostedSkillLevel(skill.getSkill()) : client.getRealSkillLevel(skill.getSkill()));

		for (String successMessage : config.messageSuccess().split(MESSAGE_DELIM))
		{
			if (message.equals(successMessage))
			{
				update(level, 1, 0);
				return;
			}
		}
		for (String failureMessage : config.messageFailure().split(MESSAGE_DELIM))
		{
			if (message.equals(failureMessage))
			{
				update(level, 0, 1);
				return;
			}
		}
	}
}

package com.chatsuccessrates.trackers;

import com.chatsuccessrates.ChatSuccessRatesSkill;
import com.chatsuccessrates.ChatSuccessRatesTracker;
import lombok.RequiredArgsConstructor;
import net.runelite.api.ChatMessageType;
import net.runelite.api.events.ChatMessage;
import net.runelite.client.eventbus.Subscribe;
import org.apache.commons.lang3.StringUtils;
import org.apache.commons.text.WordUtils;

@RequiredArgsConstructor
public class FiringPottery extends ChatSuccessRatesTracker
{
	private final String item;

	private String getMessageSuccess()
	{
		return "You remove the " + item + " from the oven.";
	}

	private String getMessageFailure()
	{
		return "The " + item + " cracks in the oven.";
	}

	@Override
	public ChatSuccessRatesSkill getSkill()
	{
		return ChatSuccessRatesSkill.CRAFTING;
	}

	@Subscribe
	public void onChatMessage(final ChatMessage event)
	{
		if (!ChatMessageType.SPAM.equals(event.getType()))
		{
			return;
		}

		final String message = event.getMessage();
		final int level = client.getBoostedSkillLevel(getSkill().getSkill());

		if (getMessageSuccess().equals(message))
		{
			update(level, 1, 0);
		}
		else if (getMessageFailure().equals(message))
		{
			update(level, 0, 1);
		}
	}

	@Override
	public String getTrackerName()
	{
		return "Firing" + StringUtils.deleteWhitespace(WordUtils.capitalize(item));
	}
}

package com.chatsuccessrates.trackers;

import com.chatsuccessrates.ChatSuccessRatesSkill;
import com.chatsuccessrates.ChatSuccessRatesTracker;
import net.runelite.api.InventoryID;
import net.runelite.api.Item;
import net.runelite.api.ItemContainer;
import net.runelite.api.ItemID;
import net.runelite.api.events.ChatMessage;
import net.runelite.api.events.ItemContainerChanged;
import net.runelite.client.eventbus.Subscribe;
import static com.chatsuccessrates.ChatSuccessRatesPlugin.COLLAPSIBLE_MESSAGETYPES;

public class BendingNails extends ChatSuccessRatesTracker
{
	private static final String NAIL_SUCCESS = "You use a nail.";
	private static final String NAIL_FAILURE = "You accidentally bend a nail.";

	private final int nailType;

	private int nailQuantity = 0;
	private String message = null;
	private int messageTick;

	public BendingNails(int nailType)
	{
		this.nailType = nailType;
		updateNailQuantity();
	}

	@Override
	public ChatSuccessRatesSkill getSkill()
	{
		return ChatSuccessRatesSkill.CONSTRUCTION;
	}

	@Override
	public String getTrackerName()
	{
		final String PREFIX = "Bending";
		final String SUFFIX = "Nails";
		switch (nailType)
		{
			case ItemID.BRONZE_NAILS:
				return PREFIX + "Bronze" + SUFFIX;
			case ItemID.IRON_NAILS:
				return PREFIX + "Iron" + SUFFIX;
			case ItemID.STEEL_NAILS:
				return PREFIX + "Steel" + SUFFIX;
			case ItemID.BLACK_NAILS:
				return PREFIX + "Black" + SUFFIX;
			case ItemID.MITHRIL_NAILS:
				return PREFIX + "Mithril" + SUFFIX;
			case ItemID.ADAMANTITE_NAILS:
				return PREFIX + "Adamantite" + SUFFIX;
			case ItemID.RUNE_NAILS:
				return PREFIX + "Rune" + SUFFIX;
		}
		return PREFIX + "Unknown" + SUFFIX;
	}

	private int crystalSawBoost()
	{
		final ItemContainer inventory = client.getItemContainer(InventoryID.INVENTORY);
		if (inventory != null && inventory.contains(ItemID.CRYSTAL_SAW))
		{
			return 3;
		}
		return 0;
	}

	private int updateNailQuantity()
	{
		if (client == null)
		{
			return 0;
		}

		final ItemContainer inventory = client.getItemContainer(InventoryID.INVENTORY);
		if (inventory == null || !inventory.contains(nailType))
		{
			return 0;
		}

		int quantity = 0;
		for (Item item : inventory.getItems())
		{
			if (item.getId() == nailType)
			{
				quantity = item.getQuantity();
				if (quantity == Integer.MAX_VALUE)
				{
					continue;
				}
				break;
			}
		}

		int diff = quantity - nailQuantity;
		nailQuantity = quantity;

		return diff;
	}

	@Subscribe
	public void onChatMessage(final ChatMessage event)
	{
		if (!COLLAPSIBLE_MESSAGETYPES.contains(event.getType()))
		{
			return;
		}

		message = event.getMessage();
		messageTick = client.getTickCount();
	}

	@Subscribe
	public void onItemContainerChanged(final ItemContainerChanged event)
	{
		if (event.getContainerId() != InventoryID.INVENTORY.getId())
		{
			return;
		}

		if (updateNailQuantity() <= -1 && messageTick == client.getTickCount())
		{
			final int level = client.getBoostedSkillLevel(getSkill().getSkill()) + crystalSawBoost();

			if (NAIL_SUCCESS.equals(message))
			{
				update(level, 1, 0);
			}
			else if (NAIL_FAILURE.equals(message))
			{
				update(level, 0, 1);
			}
		}
	}
}

package com.chatsuccessrates;

import net.runelite.client.config.Config;
import net.runelite.client.config.ConfigGroup;
import net.runelite.client.config.ConfigItem;

@ConfigGroup(ChatSuccessRatesPlugin.CONFIG_GROUP)
public interface ChatSuccessRatesConfig extends Config
{
	@ConfigItem(
		keyName = "addLevelPrefix",
		name = "Add level prefix",
		description = "Whether to add a skill level prefix/identifier to the tracked custom chat messages",
		position = 0
	)
	default boolean addLevelPrefix()
	{
		return true;
	}

	@ConfigItem(
		keyName = "useBoostedLevel",
		name = "Use boosted level",
		description = "Whether to use the boosted skill level (numerator) or the static base skill level (denominator)",
		position = 1
	)
	default boolean useBoostedLevel()
	{
		return true;
	}

	@ConfigItem(
		keyName = "levelPrefix",
		name = "Level prefix",
		description = "The skill level prefix/identifier on the tracked custom chat messages.<br>Custom uses total level",
		position = 2
	)
	default ChatSuccessRatesSkill levelPrefix()
	{
		return ChatSuccessRatesSkill.CUSTOM;
	}

	@ConfigItem(
		keyName = "messageSuccess",
		name = "Custom success message",
		description = "The chat message used to track the success of a custom skilling action." +
			"<br>Multiple messages can be tracked by delimiting with a line break.",
		position = 3
	)
	default String messageSuccess()
	{
		return "";
	}

	@ConfigItem(
		keyName = "messageFailure",
		name = "Custom failure message",
		description = "The chat message used to track the failure of a custom skilling action." +
			"<br>Multiple messages can be tracked by delimiting with a line break.",
		position = 4
	)
	default String messageFailure()
	{
		return "";
	}

	@ConfigItem(
		keyName = "currentSkill",
		name = "Current skill",
		description = "The current skill that is being displayed",
		position = 5,
		hidden = true
	)
	default int indexSkill()
	{
		return 0;
	}

	@ConfigItem(
		keyName = "currentTracker",
		name = "Current tracker",
		description = "The current tracker that is being displayed",
		position = 6,
		hidden = true
	)
	default int indexTracker()
	{
		return 0;
	}

	@ConfigItem(
		keyName = "currentSkill",
		name = "Set current skill",
		description = ""
	)
	void indexSkill(int idx);

	@ConfigItem(
		keyName = "currentTracker",
		name = "Set current tracker",
		description = ""
	)
	void indexTracker(int idx);
}

package com.chatsuccessrates;

import lombok.Getter;
import lombok.RequiredArgsConstructor;
import net.runelite.api.Skill;

@RequiredArgsConstructor
public enum ChatSuccessRatesSkill
{
	CUSTOM(null),
	AGILITY(Skill.AGILITY),
	ATTACK(Skill.ATTACK),
	CONSTRUCTION(Skill.CONSTRUCTION),
	COOKING(Skill.COOKING),
	CRAFTING(Skill.CRAFTING),
	DEFENCE(Skill.DEFENCE),
	FARMING(Skill.FARMING),
	FIREMAKING(Skill.FIREMAKING),
	FISHING(Skill.FISHING),
	FLETCHING(Skill.FLETCHING),
	HERBLORE(Skill.HERBLORE),
	HITPOINTS(Skill.HITPOINTS),
	HUNTER(Skill.HUNTER),
	MAGIC(Skill.MAGIC),
	MINING(Skill.MINING),
	PRAYER(Skill.PRAYER),
	RANGED(Skill.RANGED),
	RUNECRAFT(Skill.RUNECRAFT),
	SLAYER(Skill.SLAYER),
	SMITHING(Skill.SMITHING),
	STRENGTH(Skill.STRENGTH),
	THIEVING(Skill.THIEVING),
	WOODCUTTING(Skill.WOODCUTTING);

	@Getter
	private final Skill skill;
}

package com.chatsuccessrates;

import com.chatsuccessrates.trackers.BendingNails;
import com.chatsuccessrates.trackers.CatchingPetfish;
import com.chatsuccessrates.trackers.CustomConfig;
import com.chatsuccessrates.trackers.FiringPottery;
import com.chatsuccessrates.trackers.LightingLogs;
import com.chatsuccessrates.trackers.MiningRock;
import com.chatsuccessrates.trackers.PickingLock;
import com.chatsuccessrates.trackers.Pickpocketing;
import lombok.Getter;
import lombok.RequiredArgsConstructor;
import net.runelite.api.ItemID;

@RequiredArgsConstructor
public enum ChatSuccessRatesAction
{
	// Construction
	BENDING_BRONZE_NAILS(new BendingNails(ItemID.BRONZE_NAILS)),
	BENDING_IRON_NAILS(new BendingNails(ItemID.IRON_NAILS)),
	BENDING_STEEL_NAILS(new BendingNails(ItemID.STEEL_NAILS)),
	BENDING_BLACK_NAILS(new BendingNails(ItemID.BLACK_NAILS)),
	BENDING_MITHRIL_NAILS(new BendingNails(ItemID.MITHRIL_NAILS)),
	BENDING_ADAMANTITE_NAILS(new BendingNails(ItemID.ADAMANTITE_NAILS)),
	BENDING_RUNE_NAILS(new BendingNails(ItemID.RUNE_NAILS)),

	// Crafting
	FIRING_BOWL(new FiringPottery("bowl")),
	FIRING_PIE_DISH(new FiringPottery("pie dish")),
	FIRING_POT(new FiringPottery("pot")),

	// Firemaking
	LIGHTING_LOGS(new LightingLogs()),

	// Fishing
	CATCHING_BLUEFISH(new CatchingPetfish(CatchingPetfish.TYPE_BLUE)),
	CATCHING_GREENFISH(new CatchingPetfish(CatchingPetfish.TYPE_GREEN)),
	CATCHING_SPINEFISH(new CatchingPetfish(CatchingPetfish.TYPE_SPINE)),

	// Mining
	MINING_ADAMANTITE(new MiningRock("adamantite")),
	MINING_BLURITE(new MiningRock("blurite")),
	MINING_CLAY(new MiningRock("clay")),
	MINING_COAL(new MiningRock("coal")),
	MINING_COPPER(new MiningRock("copper")),
	MINING_GOLD(new MiningRock("gold")),
	MINING_IRON(new MiningRock("iron")),
	MINING_MITHRIL(new MiningRock("mithril")),
	MINING_RUNITE(new MiningRock("runite")),
	MINING_SILVER(new MiningRock("silver")),
	MINING_TIN(new MiningRock("tin")),

	// Thieving
	LOCKPICKING_PORT_SARIM_JAIL(new PickingLock("prison door", "door", 9565)),
	PICKPOCKETING_ELF(new Pickpocketing("elf")),
	PICKPOCKETING_GNOME(new Pickpocketing("gnome")),
	PICKPOCKETING_HERO(new Pickpocketing("hero")),
	PICKPOCKETING_KNIGHT(new Pickpocketing("knight")),
	PICKPOCKETING_MAN(new Pickpocketing("man")),
	PICKPOCKETING_MASTER_FARMER(new Pickpocketing("Master Farmer")),
	PICKPOCKETING_PALADIN(new Pickpocketing("paladin")),
	PICKPOCKETING_TZHAAR_HUR(new Pickpocketing("TzHaar-Hur")),
	PICKPOCKETING_VYRE(new Pickpocketing("vyre")),
	PICKPOCKETING_WARRIOR(new Pickpocketing("warrior")),
	PICKPOCKETING_WOMAN(new Pickpocketing("woman")),

	// Other
	CUSTOM_CONFIG(new CustomConfig());

	@Getter
	private final ChatSuccessRatesTracker tracker;
}

package com.chatsuccessrates;

import java.awt.BorderLayout;
import java.awt.Color;
import javax.swing.JPanel;
import javax.swing.border.EmptyBorder;
import net.runelite.client.ui.components.ProgressBar;

class ChatSuccessRatesBar extends JPanel implements Comparable<ChatSuccessRatesBar>
{
	private int successes;
	private int failures;

	private final int level;

	private final ProgressBar progressBar = new ProgressBar();

	ChatSuccessRatesBar(int level, Color color)
	{
		this.level = level;

		setLayout(new BorderLayout());
		setBorder(new EmptyBorder(0, 0, 2, 0));

		progressBar.setBackground(new Color(61, 56, 49));
		progressBar.setForeground(color);

		progressBar.setCenterLabel("" + level);

		updateInfo();

		add(progressBar);
	}

	private void updateInfo()
	{
		progressBar.setMaximumValue(getTotal());
		progressBar.setValue(successes);
		progressBar.setLeftLabel("" + successes);
		progressBar.setRightLabel("" + failures);

		progressBar.setToolTipText("<html>" +
			"Level: " + level + "<br>" +
			"Successes: " + String.format("%.2f", getSuccessPercentage()) + " %" + "<br>" +
			"Failures: " + String.format("%.2f", getFailurePercentage()) + " %" + "</html>");

		setVisible(!isEmpty());
	}

	private boolean isEmpty()
	{
		return getTotal() <= 0;
	}

	private int getTotal()
	{
		return successes + failures;
	}

	private double getSuccessPercentage()
	{
		return 100.0 * successes / getTotal();
	}

	private double getFailurePercentage()
	{
		return 100.0 * failures / getTotal();
	}

	public void update(int deltaSuccesses, int deltaFailures)
	{
		successes += deltaSuccesses;
		failures += deltaFailures;

		updateInfo();
	}

	@Override
	public String toString()
	{
		return level + "\t" + successes + "\t" + failures;
	}

	@Override
	public int compareTo(ChatSuccessRatesBar other)
	{
		return Integer.compare(level, other.level);
	}
}

package com.chatsuccessrates;

import com.google.common.collect.ImmutableSet;
import com.google.gson.Gson;
import com.google.inject.Inject;
import com.google.inject.Provides;
import java.awt.Toolkit;
import java.awt.datatransfer.StringSelection;
import java.awt.image.BufferedImage;
import java.util.HashMap;
import java.util.LinkedHashMap;
import java.util.Map;
import java.util.Set;
import net.runelite.api.ChatMessageType;
import net.runelite.api.Client;
import net.runelite.api.MenuAction;
import net.runelite.api.MessageNode;
import net.runelite.api.events.ChatMessage;
import net.runelite.api.events.MenuOpened;
import net.runelite.api.events.ScriptCallbackEvent;
import net.runelite.api.widgets.ComponentID;
import net.runelite.api.widgets.Widget;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.eventbus.EventBus;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.events.ConfigChanged;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.plugins.PluginDescriptor;
import net.runelite.client.ui.ClientToolbar;
import net.runelite.client.ui.NavigationButton;
import net.runelite.client.util.ImageUtil;
import static net.runelite.api.ChatMessageType.CONSOLE;
import static net.runelite.api.ChatMessageType.DIALOG;
import static net.runelite.api.ChatMessageType.GAMEMESSAGE;
import static net.runelite.api.ChatMessageType.ENGINE;
import static net.runelite.api.ChatMessageType.MESBOX;
import static net.runelite.api.ChatMessageType.SPAM;

@PluginDescriptor(
	name = "Chat Success Rates",
	description = "Track and display skilling success rates",
	tags = {"skilling", "level", "success", "failure", "rate", "tracking", "counter", "distribution"}
)
public class ChatSuccessRatesPlugin extends Plugin
{
	public static final Set<ChatMessageType> COLLAPSIBLE_MESSAGETYPES = ImmutableSet.of(
		CONSOLE,
		DIALOG,
		GAMEMESSAGE,
		ENGINE,
		MESBOX,
		SPAM
	);
	public static final String CONFIG_GROUP = "chatsuccessrates";
	public static final String MESSAGE_DELIM = "\n";
	private static final String DUPLICATE_PREFIX = " (";
	private static final String DUPLICATE_SUFFIX = ")";
	private static final String LEVEL_DELIMITER = ": ";
	private static final String COPY_TO_CLIPBOARD_OPTION = "Copy";
	private static final String COPY_TO_CLIPBOARD_TARGET = "Chat success rates";

	private static final Map<ChatMessageType, EvictingLinkedHashMap<String, Duplicate>> DUPLICATE_CACHE = new HashMap<>();

	static
	{
		for (ChatMessageType chatMessageType : COLLAPSIBLE_MESSAGETYPES)
		{
			DUPLICATE_CACHE.put(chatMessageType, new EvictingLinkedHashMap<String, Duplicate>());
		}
		DUPLICATE_CACHE.get(MESBOX).MAX_ENTRIES = 300;
	}

	private static class Duplicate
	{
		int messageId;
		int count;
	}

	private static class EvictingLinkedHashMap<E, V> extends LinkedHashMap<E, V>
	{
		int MAX_ENTRIES = 100;

		@Override
		protected boolean removeEldestEntry(Map.Entry<E, V> eldest)
		{
			return size() > MAX_ENTRIES;
		}
	}

	private NavigationButton navigationButton;
	private ChatSuccessRatesPluginPanel pluginPanel;

	@Inject
	private Gson gson;

	@Inject
	private Client client;

	@Inject
	private EventBus eventBus;

	@Inject
	private ConfigManager configManager;

	@Inject
	private ClientToolbar clientToolbar;

	@Inject
	private ChatSuccessRatesConfig config;

	@Provides
	ChatSuccessRatesConfig providesConfig(ConfigManager configManager)
	{
		return configManager.getConfig(ChatSuccessRatesConfig.class);
	}

	@Override
	protected void startUp() throws Exception
	{
		client.refreshChat();

		pluginPanel = new ChatSuccessRatesPluginPanel(config, this, client, configManager, gson, eventBus);

		final BufferedImage icon = ImageUtil.loadImageResource(getClass(), "chat_success_rates_icon.png");

		navigationButton = NavigationButton.builder()
			.tooltip("Chat Success Rates")
			.icon(icon)
			.priority(5)
			.panel(pluginPanel)
			.build();

		clientToolbar.addNavigation(navigationButton);
	}

	@Override
	protected void shutDown() throws Exception
	{
		for (ChatSuccessRatesSkill skill : pluginPanel.getTrackers().keySet())
		{
			for (ChatSuccessRatesTracker tracker : pluginPanel.getTrackers().get(skill))
			{
				tracker.unregister();
			}
		}

		clientToolbar.removeNavigation(navigationButton);

		pluginPanel = null;
		navigationButton = null;

		for (ChatMessageType chatMessageType : DUPLICATE_CACHE.keySet())
		{
			DUPLICATE_CACHE.get(chatMessageType).clear();
		}
		client.refreshChat();
	}

	@Subscribe
	public void onConfigChanged(ConfigChanged event)
	{
		if (!CONFIG_GROUP.equals(event.getGroup()))
		{
			return;
		}

		client.refreshChat();
	}

	@Subscribe
	public void onScriptCallbackEvent(ScriptCallbackEvent event)
	{
		if (!"chatFilterCheck".equals(event.getEventName()))
		{
			return;
		}

		int[] intStack = client.getIntStack();
		int intStackSize = client.getIntStackSize();
		String[] stringStack = client.getStringStack();
		int stringStackSize = client.getStringStackSize();

		final int messageId = intStack[intStackSize - 1];
		String message = stringStack[stringStackSize - 1];

		Duplicate duplicate = null;
		for (ChatMessageType chatMessageType : DUPLICATE_CACHE.keySet())
		{
			Duplicate candidate = DUPLICATE_CACHE.get(chatMessageType).get(message);
			if (candidate != null)
			{
				duplicate = candidate;
				break;
			}
		}
		if (duplicate == null)
		{
			return;
		}

		final boolean blockMessage = messageId < duplicate.messageId;

		if (blockMessage)
		{
			intStack[intStackSize - 3] = 0;
		}
		else if (duplicate.count > 1)
		{
			stringStack[stringStackSize - 1] = message + DUPLICATE_PREFIX + duplicate.count + DUPLICATE_SUFFIX;
		}
	}

	@Subscribe(priority = -2)
	public void onChatMessage(ChatMessage event)
	{
		String message = event.getMessage();
		ChatMessageType messageType = event.getType();
		if (isTrackedMessage(message, messageType))
		{
			MessageNode node;
			if (messageType == MESBOX)
			{
				node = client.addChatMessage(GAMEMESSAGE, "", message, "");
			}
			else
			{
				node = event.getMessageNode();
			}

			message = formatMessage(message);
			node.setValue(message);

			Duplicate duplicate = DUPLICATE_CACHE.get(messageType).remove(message);
			if (duplicate == null)
			{
				duplicate = new Duplicate();
			}

			duplicate.count++;
			duplicate.messageId = event.getMessageNode().getId();
			DUPLICATE_CACHE.get(messageType).put(message, duplicate);
		}
	}

	@Subscribe
	public void onMenuOpened(MenuOpened event)
	{
		final Widget chatboxMessageLines = client.getWidget(ComponentID.CHATBOX_MESSAGE_LINES);
		if (chatboxMessageLines == null ||
			chatboxMessageLines.isHidden() ||
			isEmpty(DUPLICATE_CACHE) ||
			!chatboxMessageLines.contains(client.getMouseCanvasPosition()))
		{
			return;
		}

		client.createMenuEntry(1)
			.setOption(COPY_TO_CLIPBOARD_OPTION)
			.setTarget(COPY_TO_CLIPBOARD_TARGET)
			.setType(MenuAction.RUNELITE)
			.onClick(e ->
			{
				final StringSelection stringSelection = new StringSelection(chatSuccessRatesSummary());
				Toolkit.getDefaultToolkit().getSystemClipboard().setContents(stringSelection, null);
			});
	}

	private String chatSuccessRatesSummary()
	{
		StringBuilder summary = new StringBuilder();
		for (ChatMessageType messageType : new ChatMessageType[]{GAMEMESSAGE, SPAM})
		{
			Map<String, Duplicate> duplicateCache = DUPLICATE_CACHE.get(messageType);
			for (String key : duplicateCache.keySet())
			{
				summary.append(summary.length() > 0 ? "\n" : "")
					.append(key)
					.append(DUPLICATE_PREFIX)
					.append(duplicateCache.get(key).count)
					.append(DUPLICATE_SUFFIX);
			}
		}
		return summary.toString();
	}

	private boolean isEmpty(Map<ChatMessageType, EvictingLinkedHashMap<String, Duplicate>> duplicateCache)
	{
		for (ChatMessageType chatMessageType : duplicateCache.keySet())
		{
			if (!duplicateCache.get(chatMessageType).isEmpty())
			{
				return false;
			}
		}
		return true;
	}

	private boolean isTrackedMessage(String message, ChatMessageType type)
	{
		if (COLLAPSIBLE_MESSAGETYPES.contains(type))
		{
			for (String successMessage : config.messageSuccess().split(MESSAGE_DELIM))
			{
				if (message.equals(successMessage))
				{
					return true;
				}
			}
			for (String failureMessage : config.messageFailure().split(MESSAGE_DELIM))
			{
				if (message.equals(failureMessage))
				{
					return true;
				}
			}
		}
		return false;
	}

	private String formatMessage(String message)
	{
		if (config.addLevelPrefix())
		{
			final ChatSuccessRatesSkill skill = config.levelPrefix();
			final int level = ChatSuccessRatesSkill.CUSTOM.equals(skill)
				? client.getTotalLevel()
				: (config.useBoostedLevel()
					? client.getBoostedSkillLevel(skill.getSkill())
					: client.getRealSkillLevel(skill.getSkill()));
			message = level + LEVEL_DELIMITER + message;
		}
		return message;
	}

	public void updatePanel()
	{
		pluginPanel.repaint();
		pluginPanel.revalidate();
	}

	public void rebuildPanel()
	{
		pluginPanel.displaySelectedTracker();
	}
}

package com.chatsuccessrates;

import com.google.common.base.Strings;
import com.google.gson.Gson;
import com.google.gson.reflect.TypeToken;
import java.awt.Color;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import javax.swing.SwingUtilities;
import lombok.Getter;
import lombok.Setter;
import net.runelite.api.Client;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.eventbus.EventBus;
import net.runelite.client.ui.SkillColor;
import org.apache.commons.lang3.StringUtils;
import static com.chatsuccessrates.ChatSuccessRatesPlugin.CONFIG_GROUP;

public abstract class ChatSuccessRatesTracker implements Comparable<ChatSuccessRatesTracker>
{
	private static final String CONFIG_DELIM = "_";

	public Client client;
	public ChatSuccessRatesConfig config;
	public ChatSuccessRatesPlugin plugin;

	private ConfigManager configManager;
	private EventBus eventBus;
	private Gson gson;

	@Getter
	private Map<Integer, Integer[]> levelRates = new HashMap<>();

	@Setter
	private Map<Integer, ChatSuccessRatesBar> trackerBars = new HashMap<>();

	public List<ChatSuccessRatesBar> getTrackerBars()
	{
		List<ChatSuccessRatesBar> bars = new ArrayList<>(trackerBars.values());
		bars.sort(null);
		return bars;
	}

	public abstract ChatSuccessRatesSkill getSkill();

	public Color getColor()
	{
		return ChatSuccessRatesSkill.CUSTOM.equals(getSkill()) ? Color.RED : SkillColor.find(getSkill().getSkill()).getColor();
	}

	public void register(EventBus eventBus, Client client, ChatSuccessRatesConfig config,
		ChatSuccessRatesPlugin plugin, ConfigManager configManager, Gson gson)
	{
		this.eventBus = eventBus;
		this.client = client;
		this.config = config;
		this.plugin = plugin;
		this.configManager = configManager;
		this.gson = gson;

		eventBus.register(this);
	}

	public void unregister()
	{
		eventBus.unregister(this);
	}

	public void update(int lvl, int successes, int fails)
	{
		ChatSuccessRatesBar bar = trackerBars.get(lvl);
		if (bar == null)
		{
			SwingUtilities.invokeLater(() ->
			{
				ChatSuccessRatesBar newBar = new ChatSuccessRatesBar(lvl, getColor());
				trackerBars.put(lvl, newBar);
				newBar.update(successes, fails);
				if (plugin != null)
				{
					plugin.rebuildPanel();
				}
			});
		}
		else
		{
			bar.update(successes, fails);
			if (plugin != null)
			{
				plugin.updatePanel();
			}
		}

		updateTrackerData(lvl, successes, fails);

		saveTrackerData();
	}

	public void updateTrackerData(int level, int successes, int failures)
	{
		int previousSuccesses = 0;
		int previousFailures = 0;

		if (levelRates.containsKey(level))
		{
			Integer[] data = levelRates.get(level);
			previousSuccesses = data[0];
			previousFailures = data[1];
		}

		levelRates.put(level, new Integer[]{previousSuccesses + successes, previousFailures + failures});
	}

	public void loadTrackerData()
	{
		final String key = getSkill() + CONFIG_DELIM + getTrackerName();

		String json = configManager.getConfiguration(CONFIG_GROUP, key);

		if (Strings.isNullOrEmpty(json))
		{
			return;
		}

		levelRates = gson.fromJson(json, new TypeToken<Map<Integer, Integer[]>>(){}.getType());
	}

	private void saveTrackerData()
	{
		final String key = getSkill() + CONFIG_DELIM + getTrackerName();

		if (levelRates == null || levelRates.isEmpty())
		{
			configManager.unsetConfiguration(CONFIG_GROUP, key);
			return;
		}

		configManager.setConfiguration(CONFIG_GROUP, key, gson.toJson(levelRates));
	}

	public void reset()
	{
		levelRates.clear();
		trackerBars.clear();
		saveTrackerData();
		if (plugin != null)
		{
			plugin.rebuildPanel();
		}
	}

	public String getTrackerName()
	{
		return getClass().getSimpleName();
	}

	@Override
	public String toString()
	{
		return StringUtils.capitalize(
			StringUtils.join(StringUtils.splitByCharacterTypeCamelCase(getTrackerName()), " ").toLowerCase());
	}

	@Override
	public int compareTo(ChatSuccessRatesTracker other)
	{
		return toString().compareTo(other.toString());
	}
}

package com.chatsuccessrates;

import net.runelite.client.RuneLite;
import net.runelite.client.externalplugins.ExternalPluginManager;

public class ChatSuccessRatesPluginTest
{
	public static void main(String[] args) throws Exception
	{
		ExternalPluginManager.loadBuiltin(ChatSuccessRatesPlugin.class);
		RuneLite.main(args);
	}
}
