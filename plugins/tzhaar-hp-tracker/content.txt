/*
 * Copyright (c) 2023, Buchus <http://github.com/MoreBuchus>
 * Copyright (c) 2023, geheur <http://github.com/geheur>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.tzhaarhptracker;

import com.google.common.base.Strings;
import java.awt.*;
import java.awt.geom.Point2D;
import java.util.ArrayList;
import java.util.Objects;
import javax.inject.Inject;

import net.runelite.api.*;
import net.runelite.api.Point;
import net.runelite.api.coords.LocalPoint;
import net.runelite.client.game.NpcUtil;
import net.runelite.client.ui.overlay.Overlay;
import net.runelite.client.ui.overlay.OverlayLayer;
import net.runelite.client.ui.overlay.OverlayPosition;
import net.runelite.client.ui.overlay.OverlayPriority;
import net.runelite.client.ui.overlay.OverlayUtil;
import net.runelite.client.ui.overlay.outline.ModelOutlineRenderer;
import static net.runelite.api.NpcID.*;

public class TzhaarHPTrackerOverlay extends Overlay
{
	private final TzhaarHPTrackerPlugin plugin;
	private final TzhaarHPTrackerConfig config;
	private final Client client;
	private final ModelOutlineRenderer modelOutlineRenderer;
	private final NpcUtil npcUtil;

	private static final int ACTOR_OVERHEAD_TEXT_MARGIN = 40;
	private static final int ACTOR_HORIZONTAL_TEXT_MARGIN = 10;

	@Inject
	private TzhaarHPTrackerOverlay(TzhaarHPTrackerPlugin plugin, TzhaarHPTrackerConfig config, Client client,
								   ModelOutlineRenderer modelOutlineRenderer, NpcUtil npcUtil)
	{
		this.plugin = plugin;
		this.config = config;
		this.client = client;
		this.modelOutlineRenderer = modelOutlineRenderer;
		this.npcUtil = npcUtil;
		setPosition(OverlayPosition.DYNAMIC);
		setPriority(OverlayPriority.HIGHEST);
		setLayer(OverlayLayer.UNDER_WIDGETS);
	}

	@Override
	public Dimension render(Graphics2D graphics)
	{
		if (plugin.isInAllowedCaves())
		{
			if (plugin.getFont() == null)
			{
				plugin.loadFont();
			}

			ArrayList<NPC> stackedNpcs = new ArrayList<>();

			for (TzhaarNPC n : plugin.getNpcs())
			{
				if (shouldHighlight(n.getNpc()))
				{
					Color line = !n.isDead() ? config.highlightAliveColor() : config.highlightDeadColor();
					Color fill = !n.isDead() ? config.fillAliveColor() : config.fillDeadColor();

					if (config.dynamicColor() == TzhaarHPTrackerConfig.DynamicColor.BOTH || config.dynamicColor() == TzhaarHPTrackerConfig.DynamicColor.HIGHLIGHT)
					{
						line = plugin.getDynamicColor(n, true);
						fill = plugin.getDynamicColor(n, false);
					}

					NPCComposition npcComposition = n.getNpc().getTransformedComposition();
					if (npcComposition != null)
					{
						int size = npcComposition.getSize();

						//Only highlights NPCs - not pillars
						if (n.getNpc().getId() != ROCKY_SUPPORT)
						{
							if (config.highlightStyle().contains(TzhaarHPTrackerConfig.HighlightStyle.TILE))
							{
								LocalPoint lp = n.getNpc().getLocalLocation();
								if (lp != null)
								{
									Polygon tilePoly = Perspective.getCanvasTileAreaPoly(client, lp, size);
									if (tilePoly != null)
									{
										switch (config.tileLines())
										{
											case REG:
												renderPoly(graphics, line, fill, tilePoly, config.highlightThiCC());
												break;
											case DASH:
												renderPolygonDashed(graphics, line, fill, tilePoly, config.highlightThiCC(), size);
												break;
											case CORNER:
												renderPolygonCorners(graphics, line, fill, tilePoly, config.highlightThiCC());
												break;
										}
									}
								}
							}

							if (config.highlightStyle().contains(TzhaarHPTrackerConfig.HighlightStyle.TRUE_TILE))
							{
								LocalPoint lp = LocalPoint.fromWorld(client, n.getNpc().getWorldLocation());
								if (lp != null)
								{
									lp = new LocalPoint(lp.getX() + size * 128 / 2 - 64, lp.getY() + size * 128 / 2 - 64);
									Polygon tilePoly = Perspective.getCanvasTileAreaPoly(client, lp, size);
									if (tilePoly != null)
									{
										switch (config.tileLines())
										{
											case REG:
												renderPoly(graphics, line, fill, tilePoly, config.highlightThiCC());
												break;
											case DASH:
												renderPolygonDashed(graphics, line, fill, tilePoly, config.highlightThiCC(), size);
												break;
											case CORNER:
												renderPolygonCorners(graphics, line, fill, tilePoly, config.highlightThiCC());
												break;
										}
									}
								}
							}

							if (config.highlightStyle().contains(TzhaarHPTrackerConfig.HighlightStyle.SW_TILE))
							{
								LocalPoint lp = n.getNpc().getLocalLocation();
								if (lp != null)
								{
									int x = lp.getX() - (size - 1) * 128 / 2;
									int y = lp.getY() - (size - 1) * 128 / 2;
									Polygon tilePoly = Perspective.getCanvasTilePoly(client, new LocalPoint(x, y));
									if (tilePoly != null)
									{
										switch (config.tileLines())
										{
											case REG:
												renderPoly(graphics, line, fill, tilePoly, config.highlightThiCC());
												break;
											case DASH:
												renderPolygonDashed(graphics, line, fill, tilePoly, config.highlightThiCC(), size);
												break;
											case CORNER:
												renderPolygonCorners(graphics, line, fill, tilePoly, config.highlightThiCC());
												break;
										}
									}
								}
							}

							if (config.highlightStyle().contains(TzhaarHPTrackerConfig.HighlightStyle.SW_TRUE_TILE))
							{
								LocalPoint lp = LocalPoint.fromWorld(client, n.getNpc().getWorldLocation());
								if (lp != null)
								{
									Polygon tilePoly = Perspective.getCanvasTilePoly(client, lp);
									switch (config.tileLines())
									{
										case REG:
											renderPoly(graphics, line, fill, tilePoly, config.highlightThiCC());
											break;
										case DASH:
											renderPolygonDashed(graphics, line, fill, tilePoly, config.highlightThiCC(), size);
											break;
										case CORNER:
											renderPolygonCorners(graphics, line, fill, tilePoly, config.highlightThiCC());
											break;
									}
								}
							}

							if (config.highlightStyle().contains(TzhaarHPTrackerConfig.HighlightStyle.HULL))
							{
								Shape hull = n.getNpc().getConvexHull();
								if (hull != null)
								{
									renderPoly(graphics, line, fill, hull, config.highlightThiCC());
								}
							}

							if (config.highlightStyle().contains(TzhaarHPTrackerConfig.HighlightStyle.OUTLINE))
							{
								modelOutlineRenderer.drawOutline(n.getNpc(), (int) config.highlightThiCC(), line, 4);
							}
						}

						if ((config.showHp() != TzhaarHPTrackerConfig.HpLocation.OFF && n.getNpc().getId() != ROCKY_SUPPORT)
							|| (config.showPillarHp() != TzhaarHPTrackerConfig.HpLocation.OFF && n.getNpc().getId() == ROCKY_SUPPORT))
						{
							drawHp(graphics, stackedNpcs, n);
						}
					}
				}
			}
		}
		return null;
	}

	private void renderPoly(Graphics2D g, Color outlineColor, Color fillColor, Shape polygon, double width)
	{
		if (polygon != null)
		{
			g.setRenderingHint(RenderingHints.KEY_ANTIALIASING, config.antiAlias() ? RenderingHints.VALUE_ANTIALIAS_ON : RenderingHints.VALUE_ANTIALIAS_OFF);
			g.setColor(outlineColor);
			g.setStroke(new BasicStroke((float) width));
			g.draw(polygon);
			g.setColor(fillColor);
			g.fill(polygon);
		}
	}

	/**
	 * Draws only the corners of NPC tile highlights - Made by Geheur
	 *
	 * @param graphics
	 * @param outlineColor
	 * @param fillColor
	 * @param poly
	 * @param width
	 */
	private void renderPolygonCorners(Graphics2D graphics, Color outlineColor, Color fillColor, Shape poly, double width)
	{
		if (poly instanceof Polygon)
		{
			Polygon p = (Polygon) poly;
			graphics.setRenderingHint(RenderingHints.KEY_ANTIALIASING, config.antiAlias() ? RenderingHints.VALUE_ANTIALIAS_ON : RenderingHints.VALUE_ANTIALIAS_OFF);
			graphics.setColor(outlineColor);
			graphics.setStroke(new BasicStroke((float) width));

			int divisor = 7;
			for (int i = 0; i < p.npoints; i++)
			{
				int ptx = p.xpoints[i];
				int pty = p.ypoints[i];
				int prev = (i - 1) < 0 ? 3 : (i - 1);
				int next = (i + 1) > 3 ? 0 : (i + 1);
				int ptxN = ((p.xpoints[next]) - ptx) / divisor + ptx;
				int ptyN = ((p.ypoints[next]) - pty) / divisor + pty;
				int ptxP = ((p.xpoints[prev]) - ptx) / divisor + ptx;
				int ptyP = ((p.ypoints[prev]) - pty) / divisor + pty;
				graphics.drawLine(ptx, pty, ptxN, ptyN);
				graphics.drawLine(ptx, pty, ptxP, ptyP);
			}

			graphics.setColor(fillColor);
			graphics.fill(poly);
		}
	}

	/**
	 * Draws the corners and dashed lines along each side of NPC tile highlights - Made by Geheur
	 *
	 * @param graphics
	 * @param outlineColor
	 * @param fillColor
	 * @param poly
	 * @param width
	 * @param tiles
	 */
	private void renderPolygonDashed(Graphics2D graphics, Color outlineColor, Color fillColor, Shape poly, double width, int tiles)
	{
		if (poly instanceof Polygon)
		{
			Polygon p = (Polygon) poly;
			graphics.setRenderingHint(RenderingHints.KEY_ANTIALIASING, config.antiAlias() ? RenderingHints.VALUE_ANTIALIAS_ON : RenderingHints.VALUE_ANTIALIAS_OFF);
			graphics.setColor(outlineColor);
			graphics.setStroke(new BasicStroke((float) width));

			int divisor = 7 * tiles;
			for (int i = 0; i < p.npoints; i++)
			{
				int ptx = p.xpoints[i];
				int pty = p.ypoints[i];
				int next = (i + 1) > 3 ? 0 : (i + 1);
				int ptxN = (p.xpoints[next]) - ptx;
				int ptyN = (p.ypoints[next]) - pty;
				float length = (float) Point2D.distance(ptx, pty, ptx + ptxN, pty + ptyN);
				float dashLength = length * 2f / divisor;
				float spaceLength = length * 5f / divisor;
				Stroke s = new BasicStroke((float) width, BasicStroke.CAP_SQUARE, BasicStroke.JOIN_MITER, 10, new float[]{dashLength, spaceLength}, dashLength / 2);
				graphics.setStroke(s);
				graphics.drawLine(ptx, pty, ptx + ptxN, pty + ptyN);
			}

			graphics.setColor(fillColor);
			graphics.fill(poly);
		}
	}

	private void drawHp(Graphics2D graphics, ArrayList<NPC> stackedNpcs, TzhaarNPC n)
	{
		int offset = 0;
		NPC firstStack = null;
		for (NPC npc : stackedNpcs)
		{
			if (npc.getWorldLocation().getX() == n.getNpc().getWorldLocation().getX() && npc.getWorldLocation().getY() == n.getNpc().getWorldLocation().getY())
			{
				if (firstStack == null)
				{
					firstStack = npc;
				}
				offset += graphics.getFontMetrics().getHeight();
			}
		}

		final int zOffset;
		int npcOffset = firstStack != null ? firstStack.getLogicalHeight() : n.getNpc().getLogicalHeight();
		if (n.getNpc().getId() != ROCKY_SUPPORT)
		{
			switch (config.showHp())
			{
				case CENTER:
					zOffset = npcOffset / 2;
					break;
				case FEET:
					zOffset = 0;
					break;
				default:
					//Zuk is too tall for above HP bar to be seen by most players -> Set it to center if HP bar is selected
					zOffset = !Objects.equals(n.getNpc().getName(), "TzKal-Zuk") ? npcOffset + ACTOR_OVERHEAD_TEXT_MARGIN : npcOffset / 2;
			}
		}
		else
		{
			switch (config.showPillarHp())
			{
				case CENTER:
					zOffset = npcOffset / 2;
					break;
				case FEET:
					zOffset = 0;
					break;
				default:
					zOffset = npcOffset + ACTOR_OVERHEAD_TEXT_MARGIN;
			}
		}
		stackedNpcs.add(n.getNpc());
		String hp = n.getHp() < 0 ? "0" : Integer.toString(n.getHp());
		Point textLocation = offset > 0 ? firstStack.getCanvasTextLocation(graphics, hp, zOffset) : n.getNpc().getCanvasTextLocation(graphics, hp, zOffset);

		if (textLocation != null)
		{
			Point offsetLocation = new Point(textLocation.getX(), textLocation.getY() - offset);
			Color color = !n.isDead() ? config.highlightAliveColor() : config.highlightDeadColor();

			if (config.dynamicColor() == TzhaarHPTrackerConfig.DynamicColor.BOTH || config.dynamicColor() == TzhaarHPTrackerConfig.DynamicColor.HP)
			{
				color = plugin.getDynamicColor(n, true);
			}

			if (config.hpFontAlpha() > 0)
			{
				color = new Color(color.getRed(), color.getGreen(), color.getBlue(), config.hpFontAlpha());
			}

			graphics.setRenderingHint(RenderingHints.KEY_ANTIALIASING, config.antiAlias() ? RenderingHints.VALUE_ANTIALIAS_ON : RenderingHints.VALUE_ANTIALIAS_OFF);
			Font oldFont = graphics.getFont();
			graphics.setFont(plugin.getFont());
			drawText(graphics, offsetLocation.getX(), offsetLocation.getY(), hp, color);
			graphics.setFont(oldFont);
		}
	}

	public void drawText(Graphics2D graphics, int textX, int textY, String text, Color color)
	{
		if (!Strings.isNullOrEmpty(text))
		{
			graphics.setColor(Color.BLACK);
			drawTextBackground(graphics, new Point(textX, textY), text, color.getAlpha());

			graphics.setColor(color);
			graphics.drawString(text, textX, textY);
		}
	}

	private void drawTextBackground(Graphics2D graphics, Point textLoc, String text, int fontAlpha)
	{
		Color shadow = new Color(0, 0, 0, fontAlpha);
		switch (config.fontBackground())
		{
			case OUTLINE:
			{
				OverlayUtil.renderTextLocation(graphics, new Point(textLoc.getX(), textLoc.getY() + 1), text, shadow);
				OverlayUtil.renderTextLocation(graphics, new Point(textLoc.getX(), textLoc.getY() - 1), text, shadow);
				OverlayUtil.renderTextLocation(graphics, new Point(textLoc.getX() + 1, textLoc.getY()), text, shadow);
				OverlayUtil.renderTextLocation(graphics, new Point(textLoc.getX() - 1, textLoc.getY()), text, shadow);
				break;
			}
			case SHADOW:
			{
				OverlayUtil.renderTextLocation(graphics, new Point(textLoc.getX() + 1, textLoc.getY() + 1), text, shadow);
				break;
			}
			default:
				break;
		}
	}

	private boolean shouldHighlight(NPC n)
	{
		final NPCComposition c = n.getTransformedComposition();
		if (c != null && c.isFollower())
		{
			return false;
		}
		return plugin.getNpcs().stream().anyMatch(npc -> npc.getNpc().getIndex() == n.getIndex());
	}
}

package com.tzhaarhptracker;

import com.google.inject.Singleton;
import javax.inject.Inject;

@Singleton
public abstract class InfoHandler
{
	protected final TzhaarHPTrackerPlugin plugin;
	protected final TzhaarHPTrackerConfig config;

	@Inject
	protected InfoHandler(TzhaarHPTrackerPlugin plugin, TzhaarHPTrackerConfig config)
	{
		this.plugin = plugin;
		this.config = config;
	}

	public void init()
	{
	}

	public void load()
	{
	}

	public void unload()
	{
	}
}

/*
 * Copyright (c) 2023, Buchus <http://github.com/MoreBuchus>
 * Copyright (c) 2021, InfernoStats <http://github.com/InfernoStats>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.tzhaarhptracker;

import com.google.common.collect.ImmutableSet;
import java.awt.Color;
import java.awt.Font;
import java.util.Collections;
import java.util.Set;

import lombok.Getter;
import lombok.RequiredArgsConstructor;
import net.runelite.client.config.*;

@ConfigGroup(TzhaarHPTrackerConfig.GROUP)
public interface TzhaarHPTrackerConfig extends Config
{
	String GROUP = "TzhaarHPTracker";

	//------------------------------------------------------------//
	// Highlight Settings
	//------------------------------------------------------------//
	@ConfigSection(
		name = "Highlight Settings",
		description = "Settings for highlighting",
		position = 1,
		closedByDefault = true
	)
	String highlightSection = "highlightSection";

	@ConfigItem(
		position = 1,
		keyName = "highlightStyle",
		name = "Highlight Style",
		description = "Picks the highlight style you want for selected Tzhaar NPCs",
		section = highlightSection
	)
	default Set<HighlightStyle> highlightStyle()
	{
		return Collections.emptySet();
	}

	@Alpha
	@ConfigItem(
		position = 2,
		keyName = "highlightAliveColor",
		name = "Alive NPC Color",
		description = "Sets color of alive npc tile outline",
		section = highlightSection
	)
	default Color highlightAliveColor()
	{
		return new Color(0, 255, 48, 255);
	}

	@Alpha
	@ConfigItem(
		position = 3,
		keyName = "fillAliveColor",
		name = "Alive NPC Fill",
		description = "Sets the fill color of alive npc hightlights",
		section = highlightSection
	)
	default Color fillAliveColor()
	{
		return new Color(0, 255, 48, 20);
	}

	@Alpha
	@ConfigItem(
		position = 4,
		keyName = "highlightDeadColor",
		name = "Dead NPC Color",
		description = "Sets color of dead npc tile outline",
		section = highlightSection
	)
	default Color highlightDeadColor()
	{
		return new Color(224, 0, 0, 255);
	}

	@Alpha
	@ConfigItem(
		position = 5,
		keyName = "fillDeadColor",
		name = "Dead NPC Fill",
		description = "Sets the fill color of dead npc hightlights",
		section = highlightSection
	)
	default Color fillDeadColor()
	{
		return new Color(255, 0, 0, 60);
	}

	@Range(min = 0, max = 50)
	@ConfigItem(
		position = 6,
		keyName = "highlightThiCC",
		name = "Highlight Width",
		description = "Sets the width of npc highlights",
		section = highlightSection
	)
	default double highlightThiCC()
	{
		return 2;
	}

	@ConfigItem(
		position = 7,
		keyName = "tileLines",
		name = "Tile Line Type",
		description = "Sets the tile outline to regular, dashed, or corners only",
		section = highlightSection
	)
	default lineType tileLines()
	{
		return lineType.REG;
	}

	@ConfigItem(
		position = 8,
		keyName = "antiAlias",
		name = "Anti-Aliasing",
		description = "Turns on anti-aliasing for the overlays. Makes them smoother.",
		section = highlightSection
	)
	default boolean antiAlias()
	{
		return true;
	}

	@ConfigItem(
		position = 9,
		keyName = "showHp",
		name = "Show HP",
		description = "Show hp above npc heads",
		section = highlightSection
	)
	default HpLocation showHp()
	{
		return HpLocation.HP_BAR;
	}

	@ConfigItem(
		position = 10,
		keyName = "showPillarHp",
		name = "Show Pillar HP",
		description = "Show hp for Inferno pillars",
		section = highlightSection
	)
	default HpLocation showPillarHp()
	{
		return HpLocation.OFF;
	}

	@ConfigItem(
		position = 11,
		keyName = "dynamicHpColor",
		name = "Dynamic HP Color",
		description = "Changes the color of the HP dynamically",
		section = highlightSection
	)
	default DynamicColor dynamicColor()
	{
		return DynamicColor.OFF;
	}

	@ConfigItem(
		position = 12,
		keyName = "recolorMenu",
		name = "Recolor Menu",
		description = "Recolors the right click menus",
		section = highlightSection
	)
	default boolean recolorMenu()
	{
		return true;
	}

	@ConfigItem(
		position = 13,
		keyName = "hideDead",
		name = "Hide Dead NPCs",
		description = "Hides Tzhaar NPCs that are predicted to die",
		section = highlightSection
	)
	default boolean hideDead()
	{
		return false;
	}

	@Units(" ms")
	@ConfigItem(
		position = 14,
		keyName = "lagProtection",
		name = "Lag Protection",
		description = "Unhides hidden NPCs after a big lag spike",
		section = highlightSection
	)
	default int lagProtection()
	{
		return 1000;
	}

	//------------------------------------------------------------//
	// Font Settings
	//------------------------------------------------------------//
	@ConfigSection(
		name = "Font Settings",
		description = "Settings for font",
		position = 2,
		closedByDefault = true
	)
	String fontSection = "fontSection";

	@ConfigItem(
		position = 0,
		keyName = "overlayFontType",
		name = "Font Type",
		description = "",
		section = fontSection
	)
	default FontType overlayFontType()
	{
		return FontType.BOLD;
	}

	@ConfigItem(
		position = 1,
		keyName = "overlayFontName",
		name = "Font Name",
		description = "Custom font override for overlays",
		section = fontSection
	)
	default String overlayFontName()
	{
		return "";
	}

	@ConfigItem(
		position = 2,
		keyName = "overlayFontSize",
		name = "Font Size",
		description = "",
		section = fontSection
	)
	default int overlayFontSize()
	{
		return 11;
	}

	@ConfigItem(
		position = 3,
		keyName = "overlayFontWeight",
		name = "Font Weight",
		description = "Sets the custom font weight for overlays",
		section = fontSection
	)
	default FontWeight overlayFontWeight()
	{
		return FontWeight.PLAIN;
	}

	@ConfigItem(
		position = 4,
		name = "Font Background",
		keyName = "fontBackground",
		description = "Background of the XP drop text",
		section = fontSection
	)
	default Background fontBackground()
	{
		return Background.SHADOW;
	}

	@Range(min = 0, max = 255)
	@ConfigItem(
		position = 5,
		keyName = "hpFontAlpha",
		name = "HP Font Alpha",
		description = "Sets the alpha for text overlays <br>0 will use the alpha of the Alive/Dead or Dynamic colors",
		section = fontSection
	)
	default int hpFontAlpha()
	{
		return 0;
	}

	//------------------------------------------------------------//
	// XP Settings
	//------------------------------------------------------------//
	@ConfigSection(
		name = "Xp Settings",
		description = "Settings for xp",
		position = 4,
		closedByDefault = true
	)
	String xpSection = "xpSection";

	@ConfigItem(
		position = 0,
		keyName = "xpMultiplier",
		name = "Xp multiplier",
		description = "The bonus xp multiplier (from season game mode for example) that should be factored when calculating the hit",
		section = xpSection
	)
	default double xpMultiplier()
	{
		return 1;
	}

	// For Raging Echoes League
	@ConfigItem(
		position = 1,
		keyName = "equilibriumRelic",
		name = "Equilibrium",
		description = "The bonus flat xp obtained from the Equilibrium relic in the Raging Echoes League that should be factored when calculating the hit",
		section = xpSection
	)
	default boolean equilibriumRelic() { return false; }

	// For Raging Echoes League
	@Range(min = 32, max = 2277)
	@ConfigItem(
			position = 2,
			keyName = "totalLevel",
			name = "Total Level",
			description = "Total level used to calculate equilibrium xp drops",
			section = xpSection
	)
	default int totalLevel() { return 2277; }

	//------------------------------------------------------------//
	// Reminder Settings
	//------------------------------------------------------------//
	@ConfigSection(
		name = "Reminder Settings",
		description = "Settings for reminders",
		position = 5,
		closedByDefault = true
	)
	String reminderSection = "reminderSection";

	@ConfigItem(
		position = 0,
		keyName = "spellbookWarning",
		name = "Spellbook Warning",
		description = "Warning if the local player is on the wrong spellbook " +
			"<br>Colors the entrances to inferno and fight caves the warning color if the player is on the wrong spellbook" +
			"<br>'Remove Enter' removes options to enter if the player is on the wrong spellbook",
		section = reminderSection
	)
	default spellbookWarningMode spellbookWarning()
	{
		return spellbookWarningMode.OFF;
	}

	@ConfigItem(
		position = 1,
		keyName = "spellbookCheck",
		name = "Allowed Spellbooks",
		description = "Spellbooks the player wishes to enter the inferno with.",
		section = reminderSection
	)
	default Set<spellbook> spellbookCheck()
	{
		return ImmutableSet.of(spellbook.NORMAL, spellbook.ANCIENT, spellbook.LUNAR, spellbook.ARCEUUS);
	}

	@Alpha
	@ConfigItem(
		position = 2,
		keyName = "spellbookColor",
		name = "Warning Color",
		description = "The color to highlight cave entrances with on the wrong spellbook.",
		section = reminderSection
	)
	default Color spellbookColor()
	{
		return new Color(255, 0, 0, 50);
	}

	//------------------------------------------------------------//
	// Highlight Enums
	//------------------------------------------------------------//
	@Getter
	@RequiredArgsConstructor
	enum HighlightStyle
	{
		TILE("Tile"),
		TRUE_TILE("True Tile"),
		SW_TILE("SW Tile"),
		SW_TRUE_TILE("SW True Tile"),
		HULL("Hull"),
		OUTLINE("Outline");

		@Getter
		private final String group;

		@Override
		public String toString()
		{
			return group;
		}
	}

	@Getter
	@RequiredArgsConstructor
	enum lineType
	{
		REG("Regular"),
		DASH("Dashed"),
		CORNER("Corners"),
		;

		@Getter
		private final String group;

		@Override
		public String toString()
		{
			return group;
		}
	}

	@Getter
	@RequiredArgsConstructor
	enum HpLocation
	{
		OFF("Off"),
		HP_BAR("Above HP Bar"),
		CENTER("Center of NPC"),
		FEET("Bottom of NPC");

		@Getter
		private final String group;

		@Override
		public String toString()
		{
			return group;
		}
	}

	@Getter
	@RequiredArgsConstructor
	enum DynamicColor
	{
		OFF("Off"),
		HIGHLIGHT("Highlight"),
		HP("Hitpoints"),
		BOTH("Both");

		@Getter
		private final String group;

		@Override
		public String toString()
		{
			return group;
		}
	}

	//------------------------------------------------------------//
	// Font Enums
	//------------------------------------------------------------//
	@Getter
	@RequiredArgsConstructor
	enum FontType
	{
		SMALL("RS Small"),
		REGULAR("RS Regular"),
		BOLD("RS Bold"),
		CUSTOM("Custom");

		private final String name;

		@Override
		public String toString()
		{
			return name;
		}
	}

	enum FontWeight
	{
		PLAIN(Font.PLAIN),
		BOLD(Font.BOLD),
		ITALIC(Font.ITALIC),
		BOLD_ITALIC(Font.BOLD | Font.ITALIC);

		@Getter
		private final int weight;

		FontWeight(int i)
		{
			weight = i;
		}
	}

	@Getter
	@RequiredArgsConstructor
	enum Background
	{
		OFF("Off"),
		SHADOW("Shadow"),
		OUTLINE("Outline"),
		;

		@Getter
		private final String group;

		@Override
		public String toString()
		{
			return group;
		}
	}

	//------------------------------------------------------------//
	// Reminder Enums
	//------------------------------------------------------------//
	@Getter
	@RequiredArgsConstructor
	enum spellbookWarningMode
	{
		OFF("Off"),
		OVERLAY("Overlay"),
		REMOVE("Remove Enter"),
		BOTH("Both");

		private final String name;

		@Override
		public String toString()
		{
			return name;
		}
	}

	@Getter
	@RequiredArgsConstructor
	enum spellbook
	{
		NORMAL("Normal"),
		ANCIENT("Ancient"),
		LUNAR("Lunar"),
		ARCEUUS("Arceuus");

		private final String name;

		@Override
		public String toString()
		{
			return name;
		}
	}
}

/*
 * Copyright (c) 2017, honeyhoney <https://github.com/honeyhoney>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.tzhaarhptracker.attackstyles;

import lombok.Getter;
import net.runelite.api.Skill;

public enum AttackStyle
{
	ACCURATE("Accurate", Skill.ATTACK),
	AGGRESSIVE("Aggressive", Skill.STRENGTH),
	DEFENSIVE("Defensive", Skill.DEFENCE),
	CONTROLLED("Controlled", Skill.ATTACK, Skill.STRENGTH, Skill.DEFENCE),
	RANGING("Ranging", Skill.RANGED),
	LONGRANGE("Longrange", Skill.RANGED, Skill.DEFENCE),
	CASTING("Casting", Skill.MAGIC),
	DEFENSIVE_CASTING("Defensive Casting", Skill.MAGIC, Skill.DEFENCE),
	OTHER("Other");

	@Getter
	private final String name;
	@Getter
	private final Skill[] skills;

	AttackStyle(String name, Skill... skills)
	{
		this.name = name;
		this.skills = skills;
	}
}

package com.tzhaarhptracker.attackstyles;

import java.util.HashMap;
import net.runelite.api.ItemID;

public class WeaponMap
{
	public static HashMap<Integer, WeaponStyle> StyleMap = new HashMap<>();

	static
	{
		//Melee
		StyleMap.put(ItemID._3RD_AGE_AXE, WeaponStyle.MELEE);
		StyleMap.put(ItemID._3RD_AGE_FELLING_AXE, WeaponStyle.MELEE);
		StyleMap.put(ItemID._3RD_AGE_LONGSWORD, WeaponStyle.MELEE);
		StyleMap.put(ItemID._3RD_AGE_PICKAXE, WeaponStyle.MELEE);
		StyleMap.put(ItemID.ABYSSAL_BLUDGEON, WeaponStyle.MELEE);
		StyleMap.put(ItemID.ABYSSAL_DAGGER, WeaponStyle.MELEE);
		StyleMap.put(ItemID.ABYSSAL_DAGGER_P, WeaponStyle.MELEE);
		StyleMap.put(ItemID.ABYSSAL_DAGGER_P_13269, WeaponStyle.MELEE);
		StyleMap.put(ItemID.ABYSSAL_DAGGER_P_13271, WeaponStyle.MELEE);
		StyleMap.put(ItemID.ABYSSAL_DAGGER_BH, WeaponStyle.MELEE);
		StyleMap.put(ItemID.ABYSSAL_DAGGER_BHP, WeaponStyle.MELEE);
		StyleMap.put(ItemID.ABYSSAL_DAGGER_BHP_27865, WeaponStyle.MELEE);
		StyleMap.put(ItemID.ABYSSAL_DAGGER_BHP_27867, WeaponStyle.MELEE);
		StyleMap.put(ItemID.ABYSSAL_TENTACLE, WeaponStyle.MELEE);
		StyleMap.put(ItemID.ABYSSAL_TENTACLE_OR, WeaponStyle.MELEE);
		StyleMap.put(ItemID.ABYSSAL_WHIP, WeaponStyle.MELEE);
		StyleMap.put(ItemID.ABYSSAL_WHIP_20405, WeaponStyle.MELEE);
		StyleMap.put(ItemID.ABYSSAL_WHIP_OR, WeaponStyle.MELEE);
		StyleMap.put(ItemID.ADAMANT_2H_SWORD, WeaponStyle.MELEE);
		StyleMap.put(ItemID.ADAMANT_AXE, WeaponStyle.MELEE);
		StyleMap.put(ItemID.ADAMANT_FELLING_AXE, WeaponStyle.MELEE);
		StyleMap.put(ItemID.ADAMANT_BATTLEAXE, WeaponStyle.MELEE);
		StyleMap.put(ItemID.ADAMANT_CANE, WeaponStyle.MELEE);
		StyleMap.put(ItemID.ADAMANT_CLAWS, WeaponStyle.MELEE);
		StyleMap.put(ItemID.ADAMANT_DAGGER, WeaponStyle.MELEE);
		StyleMap.put(ItemID.ADAMANT_DAGGERP, WeaponStyle.MELEE);
		StyleMap.put(ItemID.ADAMANT_DAGGERP_5676, WeaponStyle.MELEE);
		StyleMap.put(ItemID.ADAMANT_DAGGERP_5694, WeaponStyle.MELEE);
		StyleMap.put(ItemID.ADAMANT_HALBERD, WeaponStyle.MELEE);
		StyleMap.put(ItemID.ADAMANT_HASTA, WeaponStyle.MELEE);
		StyleMap.put(ItemID.ADAMANT_LONGSWORD, WeaponStyle.MELEE);
		StyleMap.put(ItemID.ADAMANT_MACE, WeaponStyle.MELEE);
		StyleMap.put(ItemID.ADAMANT_PICKAXE, WeaponStyle.MELEE);
		StyleMap.put(ItemID.ADAMANT_SCIMITAR, WeaponStyle.MELEE);
		StyleMap.put(ItemID.ADAMANT_SPEAR, WeaponStyle.MELEE);
		StyleMap.put(ItemID.ADAMANT_SPEARP, WeaponStyle.MELEE);
		StyleMap.put(ItemID.ADAMANT_SPEARP_5712, WeaponStyle.MELEE);
		StyleMap.put(ItemID.ADAMANT_SPEARP_5726, WeaponStyle.MELEE);
		StyleMap.put(ItemID.ADAMANT_SWORD, WeaponStyle.MELEE);
		StyleMap.put(ItemID.ADAMANT_WARHAMMER, WeaponStyle.MELEE);
		StyleMap.put(ItemID.ALE_OF_THE_GODS, WeaponStyle.MELEE);
		StyleMap.put(ItemID.ANCIENT_MACE, WeaponStyle.MELEE);
		StyleMap.put(ItemID.ANCIENT_GODSWORD, WeaponStyle.MELEE);
		StyleMap.put(ItemID.ANCIENT_GODSWORD_27184, WeaponStyle.MELEE);
		StyleMap.put(ItemID.ANGER_BATTLEAXE, WeaponStyle.MELEE);
		StyleMap.put(ItemID.ANGER_MACE, WeaponStyle.MELEE);
		StyleMap.put(ItemID.ANGER_SPEAR, WeaponStyle.MELEE);
		StyleMap.put(ItemID.ANGER_SWORD, WeaponStyle.MELEE);
		StyleMap.put(ItemID.AMYS_SAW, WeaponStyle.MELEE);
		StyleMap.put(ItemID.ARCEUUS_BANNER, WeaponStyle.MELEE);
		StyleMap.put(ItemID.ARCLIGHT, WeaponStyle.MELEE);
		StyleMap.put(ItemID.ARMADYL_GODSWORD, WeaponStyle.MELEE);
		StyleMap.put(ItemID.ARMADYL_GODSWORD_20593, WeaponStyle.MELEE);
		StyleMap.put(ItemID.ARMADYL_GODSWORD_22665, WeaponStyle.MELEE);
		StyleMap.put(ItemID.ARMADYL_GODSWORD_OR, WeaponStyle.MELEE);
		StyleMap.put(ItemID.ASSORTED_FLOWERS, WeaponStyle.MELEE);
		StyleMap.put(ItemID.BANDOS_GODSWORD, WeaponStyle.MELEE);
		StyleMap.put(ItemID.BANDOS_GODSWORD_20782, WeaponStyle.MELEE);
		StyleMap.put(ItemID.BANDOS_GODSWORD_21060, WeaponStyle.MELEE);
		StyleMap.put(ItemID.BANDOS_GODSWORD_OR, WeaponStyle.MELEE);
		StyleMap.put(ItemID.BARBTAIL_HARPOON, WeaponStyle.MELEE);
		StyleMap.put(ItemID.BARRELCHEST_ANCHOR, WeaponStyle.MELEE);
		StyleMap.put(ItemID.BARRELCHEST_ANCHOR_10888, WeaponStyle.MELEE);
		StyleMap.put(ItemID.BARRELCHEST_ANCHOR_BH, WeaponStyle.MELEE);
		StyleMap.put(ItemID.BEACH_BOXING_GLOVES, WeaponStyle.MELEE);
		StyleMap.put(ItemID.BEACH_BOXING_GLOVES_11706, WeaponStyle.MELEE);
		StyleMap.put(ItemID.BIRTHDAY_BALLOONS, WeaponStyle.MELEE);
		StyleMap.put(ItemID.BIRTHDAY_CAKE, WeaponStyle.MELEE);
		StyleMap.put(ItemID.BLACK_2H_SWORD, WeaponStyle.MELEE);
		StyleMap.put(ItemID.BLACK_AXE, WeaponStyle.MELEE);
		StyleMap.put(ItemID.BLACK_FELLING_AXE, WeaponStyle.MELEE);
		StyleMap.put(ItemID.BLACK_BATTLEAXE, WeaponStyle.MELEE);
		StyleMap.put(ItemID.BLACK_CANE, WeaponStyle.MELEE);
		StyleMap.put(ItemID.BLACK_CLAWS, WeaponStyle.MELEE);
		StyleMap.put(ItemID.BLACK_DAGGER, WeaponStyle.MELEE);
		StyleMap.put(ItemID.BLACK_DAGGERP, WeaponStyle.MELEE);
		StyleMap.put(ItemID.BLACK_DAGGERP_5682, WeaponStyle.MELEE);
		StyleMap.put(ItemID.BLACK_DAGGERP_5700, WeaponStyle.MELEE);
		StyleMap.put(ItemID.BLACK_FLOWERS, WeaponStyle.MELEE);
		StyleMap.put(ItemID.BLACK_HALBERD, WeaponStyle.MELEE);
		StyleMap.put(ItemID.BLACK_LONGSWORD, WeaponStyle.MELEE);
		StyleMap.put(ItemID.BLACK_MACE, WeaponStyle.MELEE);
		StyleMap.put(ItemID.BLACK_PICKAXE, WeaponStyle.MELEE);
		StyleMap.put(ItemID.BLACK_SALAMANDER, WeaponStyle.MELEE);
		StyleMap.put(ItemID.BLACK_SCIMITAR, WeaponStyle.MELEE);
		StyleMap.put(ItemID.BLACK_SPEAR, WeaponStyle.MELEE);
		StyleMap.put(ItemID.BLACK_SPEARP, WeaponStyle.MELEE);
		StyleMap.put(ItemID.BLACK_SPEARP_5734, WeaponStyle.MELEE);
		StyleMap.put(ItemID.BLACK_SPEARP_5736, WeaponStyle.MELEE);
		StyleMap.put(ItemID.BLACK_SWORD, WeaponStyle.MELEE);
		StyleMap.put(ItemID.BLACK_WARHAMMER, WeaponStyle.MELEE);
		StyleMap.put(ItemID.BLADE_OF_SAELDOR, WeaponStyle.MELEE);
		StyleMap.put(ItemID.BLADE_OF_SAELDOR_C, WeaponStyle.MELEE);
		StyleMap.put(ItemID.BLADE_OF_SAELDOR_INACTIVE, WeaponStyle.MELEE);
		StyleMap.put(ItemID.BLADE_OF_SAELDOR_C_25870, WeaponStyle.MELEE);
		StyleMap.put(ItemID.BLADE_OF_SAELDOR_C_25872, WeaponStyle.MELEE);
		StyleMap.put(ItemID.BLADE_OF_SAELDOR_C_25874, WeaponStyle.MELEE);
		StyleMap.put(ItemID.BLADE_OF_SAELDOR_C_25876, WeaponStyle.MELEE);
		StyleMap.put(ItemID.BLADE_OF_SAELDOR_C_25878, WeaponStyle.MELEE);
		StyleMap.put(ItemID.BLADE_OF_SAELDOR_C_25880, WeaponStyle.MELEE);
		StyleMap.put(ItemID.BLADE_OF_SAELDOR_C_25882, WeaponStyle.MELEE);
		StyleMap.put(ItemID.BLESSED_AXE, WeaponStyle.MELEE);
		StyleMap.put(ItemID.BLISTERWOOD_SICKLE, WeaponStyle.MELEE);
		StyleMap.put(ItemID.BLUE_FLOWERS, WeaponStyle.MELEE);
		StyleMap.put(ItemID.BLUE_FLOWERS_8936, WeaponStyle.MELEE);
		StyleMap.put(ItemID.BLURITE_SWORD, WeaponStyle.MELEE);
		StyleMap.put(ItemID.BONE_CLUB, WeaponStyle.MELEE);
		StyleMap.put(ItemID.BONE_DAGGER, WeaponStyle.MELEE);
		StyleMap.put(ItemID.BONE_DAGGER_P, WeaponStyle.MELEE);
		StyleMap.put(ItemID.BONE_DAGGER_P_8876, WeaponStyle.MELEE);
		StyleMap.put(ItemID.BONE_DAGGER_P_8878, WeaponStyle.MELEE);
		StyleMap.put(ItemID.BONE_SPEAR, WeaponStyle.MELEE);
		StyleMap.put(ItemID.BOXING_GLOVES, WeaponStyle.MELEE);
		StyleMap.put(ItemID.BOXING_GLOVES_7673, WeaponStyle.MELEE);
		StyleMap.put(ItemID.BRINE_SABRE, WeaponStyle.MELEE);
		StyleMap.put(ItemID.BRONZE_2H_SWORD, WeaponStyle.MELEE);
		StyleMap.put(ItemID.BRONZE_AXE, WeaponStyle.MELEE);
		StyleMap.put(ItemID.BRONZE_FELLING_AXE, WeaponStyle.MELEE);
		StyleMap.put(ItemID.BRONZE_BATTLEAXE, WeaponStyle.MELEE);
		StyleMap.put(ItemID.BRONZE_CLAWS, WeaponStyle.MELEE);
		StyleMap.put(ItemID.BRONZE_DAGGER, WeaponStyle.MELEE);
		StyleMap.put(ItemID.BRONZE_DAGGERP, WeaponStyle.MELEE);
		StyleMap.put(ItemID.BRONZE_DAGGERP_5670, WeaponStyle.MELEE);
		StyleMap.put(ItemID.BRONZE_DAGGERP_5688, WeaponStyle.MELEE);
		StyleMap.put(ItemID.BRONZE_HALBERD, WeaponStyle.MELEE);
		StyleMap.put(ItemID.BRONZE_HASTA, WeaponStyle.MELEE);
		StyleMap.put(ItemID.BRONZE_LONGSWORD, WeaponStyle.MELEE);
		StyleMap.put(ItemID.BRONZE_MACE, WeaponStyle.MELEE);
		StyleMap.put(ItemID.BRONZE_PICKAXE, WeaponStyle.MELEE);
		StyleMap.put(ItemID.BRONZE_SCIMITAR, WeaponStyle.MELEE);
		StyleMap.put(ItemID.BRONZE_SPEAR, WeaponStyle.MELEE);
		StyleMap.put(ItemID.BRONZE_SPEARP, WeaponStyle.MELEE);
		StyleMap.put(ItemID.BRONZE_SPEARP_5704, WeaponStyle.MELEE);
		StyleMap.put(ItemID.BRONZE_SPEARP_5718, WeaponStyle.MELEE);
		StyleMap.put(ItemID.BRONZE_SWORD, WeaponStyle.MELEE);
		StyleMap.put(ItemID.BRONZE_WARHAMMER, WeaponStyle.MELEE);
		StyleMap.put(ItemID.BRUMA_TORCH, WeaponStyle.MELEE);
		StyleMap.put(ItemID.BUTTERFLY_NET, WeaponStyle.MELEE);
		StyleMap.put(ItemID.CANDY_CANE, WeaponStyle.MELEE);
		StyleMap.put(ItemID.CATTLEPROD, WeaponStyle.MELEE);
		StyleMap.put(ItemID.CHAOTIC_HANDEGG, WeaponStyle.MELEE);
		StyleMap.put(ItemID.CLEAVER, WeaponStyle.MELEE);
		StyleMap.put(ItemID.COLOSSAL_BLADE, WeaponStyle.MELEE);
		StyleMap.put(ItemID.CORRUPTED_ARMADYL_GODSWORD, WeaponStyle.MELEE);
		StyleMap.put(ItemID.CORRUPTED_AXE, WeaponStyle.MELEE);
		StyleMap.put(ItemID.CORRUPTED_DRAGON_CLAWS, WeaponStyle.MELEE);
		StyleMap.put(ItemID.CORRUPTED_HALBERD_ATTUNED, WeaponStyle.MELEE);
		StyleMap.put(ItemID.CORRUPTED_HALBERD_BASIC, WeaponStyle.MELEE);
		StyleMap.put(ItemID.CORRUPTED_HALBERD_PERFECTED, WeaponStyle.MELEE);
		StyleMap.put(ItemID.CORRUPTED_HARPOON, WeaponStyle.MELEE);
		StyleMap.put(ItemID.CORRUPTED_PICKAXE, WeaponStyle.MELEE);
		StyleMap.put(ItemID.CORRUPTED_SCEPTRE, WeaponStyle.MELEE);
		StyleMap.put(ItemID.CORRUPTED_VOIDWAKER, WeaponStyle.MELEE);
		StyleMap.put(ItemID.CRIER_BELL, WeaponStyle.MELEE);
		StyleMap.put(ItemID.CRYSTAL_AXE, WeaponStyle.MELEE);
		StyleMap.put(ItemID.CRYSTAL_AXE_23862, WeaponStyle.MELEE);
		StyleMap.put(ItemID.CRYSTAL_AXE_INACTIVE, WeaponStyle.MELEE);
		StyleMap.put(ItemID.CRYSTAL_DAGGER_PERFECTED, WeaponStyle.MELEE);
		StyleMap.put(ItemID.CRYSTAL_FELLING_AXE, WeaponStyle.MELEE);
		StyleMap.put(ItemID.CRYSTAL_FELLING_AXE_INACTIVE, WeaponStyle.MELEE);
		StyleMap.put(ItemID.CRYSTAL_HALBERD, WeaponStyle.MELEE);
		StyleMap.put(ItemID.CRYSTAL_HALBERD_110, WeaponStyle.MELEE);
		StyleMap.put(ItemID.CRYSTAL_HALBERD_110_I, WeaponStyle.MELEE);
		StyleMap.put(ItemID.CRYSTAL_HALBERD_210, WeaponStyle.MELEE);
		StyleMap.put(ItemID.CRYSTAL_HALBERD_210_I, WeaponStyle.MELEE);
		StyleMap.put(ItemID.CRYSTAL_HALBERD_24125, WeaponStyle.MELEE);
		StyleMap.put(ItemID.CRYSTAL_HALBERD_310, WeaponStyle.MELEE);
		StyleMap.put(ItemID.CRYSTAL_HALBERD_310_I, WeaponStyle.MELEE);
		StyleMap.put(ItemID.CRYSTAL_HALBERD_410, WeaponStyle.MELEE);
		StyleMap.put(ItemID.CRYSTAL_HALBERD_410_I, WeaponStyle.MELEE);
		StyleMap.put(ItemID.CRYSTAL_HALBERD_510, WeaponStyle.MELEE);
		StyleMap.put(ItemID.CRYSTAL_HALBERD_510_I, WeaponStyle.MELEE);
		StyleMap.put(ItemID.CRYSTAL_HALBERD_610, WeaponStyle.MELEE);
		StyleMap.put(ItemID.CRYSTAL_HALBERD_610_I, WeaponStyle.MELEE);
		StyleMap.put(ItemID.CRYSTAL_HALBERD_710, WeaponStyle.MELEE);
		StyleMap.put(ItemID.CRYSTAL_HALBERD_710_I, WeaponStyle.MELEE);
		StyleMap.put(ItemID.CRYSTAL_HALBERD_810, WeaponStyle.MELEE);
		StyleMap.put(ItemID.CRYSTAL_HALBERD_810_I, WeaponStyle.MELEE);
		StyleMap.put(ItemID.CRYSTAL_HALBERD_910, WeaponStyle.MELEE);
		StyleMap.put(ItemID.CRYSTAL_HALBERD_910_I, WeaponStyle.MELEE);
		StyleMap.put(ItemID.CRYSTAL_HALBERD_ATTUNED, WeaponStyle.MELEE);
		StyleMap.put(ItemID.CRYSTAL_HALBERD_BASIC, WeaponStyle.MELEE);
		StyleMap.put(ItemID.CRYSTAL_HALBERD_FULL, WeaponStyle.MELEE);
		StyleMap.put(ItemID.CRYSTAL_HALBERD_FULL_I, WeaponStyle.MELEE);
		StyleMap.put(ItemID.CRYSTAL_HALBERD_INACTIVE, WeaponStyle.MELEE);
		StyleMap.put(ItemID.CRYSTAL_HALBERD_PERFECTED, WeaponStyle.MELEE);
		StyleMap.put(ItemID.CRYSTAL_HARPOON, WeaponStyle.MELEE);
		StyleMap.put(ItemID.CRYSTAL_HARPOON_23864, WeaponStyle.MELEE);
		StyleMap.put(ItemID.CRYSTAL_HARPOON_INACTIVE, WeaponStyle.MELEE);
		StyleMap.put(ItemID.CRYSTAL_PICKAXE, WeaponStyle.MELEE);
		StyleMap.put(ItemID.CRYSTAL_PICKAXE_23863, WeaponStyle.MELEE);
		StyleMap.put(ItemID.CRYSTAL_PICKAXE_INACTIVE, WeaponStyle.MELEE);
		StyleMap.put(ItemID.CRYSTAL_SCEPTRE, WeaponStyle.MELEE);
		StyleMap.put(ItemID.CURSED_GOBLIN_HAMMER, WeaponStyle.MELEE);
		StyleMap.put(ItemID.DARKLIGHT, WeaponStyle.MELEE);
		StyleMap.put(ItemID.DARK_DAGGER, WeaponStyle.MELEE);
		StyleMap.put(ItemID.DECORATIVE_SWORD, WeaponStyle.MELEE);
		StyleMap.put(ItemID.DECORATIVE_SWORD_4503, WeaponStyle.MELEE);
		StyleMap.put(ItemID.DECORATIVE_SWORD_4508, WeaponStyle.MELEE);
		StyleMap.put(ItemID.DHAROKS_GREATAXE, WeaponStyle.MELEE);
		StyleMap.put(ItemID.DHAROKS_GREATAXE_0, WeaponStyle.MELEE);
		StyleMap.put(ItemID.DHAROKS_GREATAXE_100, WeaponStyle.MELEE);
		StyleMap.put(ItemID.DHAROKS_GREATAXE_25, WeaponStyle.MELEE);
		StyleMap.put(ItemID.DHAROKS_GREATAXE_25516, WeaponStyle.MELEE);
		StyleMap.put(ItemID.DHAROKS_GREATAXE_50, WeaponStyle.MELEE);
		StyleMap.put(ItemID.DHAROKS_GREATAXE_75, WeaponStyle.MELEE);
		StyleMap.put(ItemID.DINHS_BULWARK, WeaponStyle.MELEE);
		StyleMap.put(ItemID.DINHS_BLAZING_BULWARK, WeaponStyle.MELEE);
		StyleMap.put(ItemID.DRAGON_2H_SWORD, WeaponStyle.MELEE);
		StyleMap.put(ItemID.DRAGON_2H_SWORD_20559, WeaponStyle.MELEE);
		StyleMap.put(ItemID.DRAGON_2H_SWORD_CR, WeaponStyle.MELEE);
		StyleMap.put(ItemID.DRAGON_AXE, WeaponStyle.MELEE);
		StyleMap.put(ItemID.DRAGON_FELLING_AXE, WeaponStyle.MELEE);
		StyleMap.put(ItemID.DRAGON_AXE_OR, WeaponStyle.MELEE);
		StyleMap.put(ItemID.DRAGON_AXE_OR_30352, WeaponStyle.MELEE);
		StyleMap.put(ItemID.DRAGON_BATTLEAXE, WeaponStyle.MELEE);
		StyleMap.put(ItemID.DRAGON_BATTLEAXE_CR, WeaponStyle.MELEE);
		StyleMap.put(ItemID.DRAGON_CANE, WeaponStyle.MELEE);
		StyleMap.put(ItemID.DRAGON_CLAWS, WeaponStyle.MELEE);
		StyleMap.put(ItemID.DRAGON_CLAWS_20784, WeaponStyle.MELEE);
		StyleMap.put(ItemID.DRAGON_CLAWS_CR, WeaponStyle.MELEE);
		StyleMap.put(ItemID.DRAGON_CLAWS_OR, WeaponStyle.MELEE);
		StyleMap.put(ItemID.DRAGON_DAGGER, WeaponStyle.MELEE);
		StyleMap.put(ItemID.DRAGON_DAGGER_20407, WeaponStyle.MELEE);
		StyleMap.put(ItemID.DRAGON_DAGGERP, WeaponStyle.MELEE);
		StyleMap.put(ItemID.DRAGON_DAGGERP_5680, WeaponStyle.MELEE);
		StyleMap.put(ItemID.DRAGON_DAGGERP_5698, WeaponStyle.MELEE);
		StyleMap.put(ItemID.DRAGON_DAGGER_CR, WeaponStyle.MELEE);
		StyleMap.put(ItemID.DRAGON_DAGGER_PCR, WeaponStyle.MELEE);
		StyleMap.put(ItemID.DRAGON_DAGGER_PCR_28023, WeaponStyle.MELEE);
		StyleMap.put(ItemID.DRAGON_DAGGER_PCR_28025, WeaponStyle.MELEE);
		StyleMap.put(ItemID.DRAGON_HALBERD, WeaponStyle.MELEE);
		StyleMap.put(ItemID.DRAGON_HALBERD_CR, WeaponStyle.MELEE);
		StyleMap.put(ItemID.DRAGON_HARPOON, WeaponStyle.MELEE);
		StyleMap.put(ItemID.DRAGON_HARPOON_OR, WeaponStyle.MELEE);
		StyleMap.put(ItemID.DRAGON_HARPOON_OR_30349, WeaponStyle.MELEE);
		StyleMap.put(ItemID.DRAGON_HASTA, WeaponStyle.MELEE);
		StyleMap.put(ItemID.DRAGON_HASTAKP, WeaponStyle.MELEE);
		StyleMap.put(ItemID.DRAGON_HASTAP, WeaponStyle.MELEE);
		StyleMap.put(ItemID.DRAGON_HASTAP_22737, WeaponStyle.MELEE);
		StyleMap.put(ItemID.DRAGON_HASTAP_22740, WeaponStyle.MELEE);
		StyleMap.put(ItemID.DRAGON_HUNTER_LANCE, WeaponStyle.MELEE);
		StyleMap.put(ItemID.DRAGON_LONGSWORD, WeaponStyle.MELEE);
		StyleMap.put(ItemID.DRAGON_LONGSWORD_BH, WeaponStyle.MELEE);
		StyleMap.put(ItemID.DRAGON_LONGSWORD_CR, WeaponStyle.MELEE);
		StyleMap.put(ItemID.DRAGON_MACE, WeaponStyle.MELEE);
		StyleMap.put(ItemID.DRAGON_MACE_BH, WeaponStyle.MELEE);
		StyleMap.put(ItemID.DRAGON_MACE_CR, WeaponStyle.MELEE);
		StyleMap.put(ItemID.DRAGON_PICKAXE, WeaponStyle.MELEE);
		StyleMap.put(ItemID.DRAGON_PICKAXE_12797, WeaponStyle.MELEE);
		StyleMap.put(ItemID.DRAGON_PICKAXE_OR, WeaponStyle.MELEE);
		StyleMap.put(ItemID.DRAGON_PICKAXE_OR_25376, WeaponStyle.MELEE);
		StyleMap.put(ItemID.DRAGON_PICKAXE_OR_30351, WeaponStyle.MELEE);
		StyleMap.put(ItemID.DRAGON_SCIMITAR, WeaponStyle.MELEE);
		StyleMap.put(ItemID.DRAGON_SCIMITAR_20406, WeaponStyle.MELEE);
		StyleMap.put(ItemID.DRAGON_SCIMITAR_CR, WeaponStyle.MELEE);
		StyleMap.put(ItemID.DRAGON_SCIMITAR_OR, WeaponStyle.MELEE);
		StyleMap.put(ItemID.DRAGON_SPEAR, WeaponStyle.MELEE);
		StyleMap.put(ItemID.DRAGON_SPEARP, WeaponStyle.MELEE);
		StyleMap.put(ItemID.DRAGON_SPEARP_5716, WeaponStyle.MELEE);
		StyleMap.put(ItemID.DRAGON_SPEARP_5730, WeaponStyle.MELEE);
		StyleMap.put(ItemID.DRAGON_SPEAR_CR, WeaponStyle.MELEE);
		StyleMap.put(ItemID.DRAGON_SPEAR_PCR, WeaponStyle.MELEE);
		StyleMap.put(ItemID.DRAGON_SPEAR_PCR_28045, WeaponStyle.MELEE);
		StyleMap.put(ItemID.DRAGON_SPEAR_PCR_28047, WeaponStyle.MELEE);
		StyleMap.put(ItemID.DRAGON_SWORD, WeaponStyle.MELEE);
		StyleMap.put(ItemID.DRAGON_SWORD_21206, WeaponStyle.MELEE);
		StyleMap.put(ItemID.DRAGON_SWORD_CR, WeaponStyle.MELEE);
		StyleMap.put(ItemID.DRAGON_WARHAMMER, WeaponStyle.MELEE);
		StyleMap.put(ItemID.DRAGON_WARHAMMER_20785, WeaponStyle.MELEE);
		StyleMap.put(ItemID.DRAGON_WARHAMMER_CR, WeaponStyle.MELEE);
		StyleMap.put(ItemID.DRAGON_WARHAMMER_OR, WeaponStyle.MELEE);
		StyleMap.put(ItemID.DUAL_MACUAHUITL, WeaponStyle.MELEE);
		StyleMap.put(ItemID.DUAL_SAI, WeaponStyle.MELEE);
		StyleMap.put(ItemID.EASTER_BASKET, WeaponStyle.MELEE);
		StyleMap.put(ItemID.EGG_WHISK, WeaponStyle.MELEE);
		StyleMap.put(ItemID.ELDER_MAUL, WeaponStyle.MELEE);
		StyleMap.put(ItemID.ELDER_MAUL_21205, WeaponStyle.MELEE);
		StyleMap.put(ItemID.ELDER_MAUL_OR, WeaponStyle.MELEE);
		StyleMap.put(ItemID.ENCHANTED_LYRE, WeaponStyle.MELEE);
		StyleMap.put(ItemID.ENCHANTED_LYRE1, WeaponStyle.MELEE);
		StyleMap.put(ItemID.ENCHANTED_LYRE2, WeaponStyle.MELEE);
		StyleMap.put(ItemID.ENCHANTED_LYRE3, WeaponStyle.MELEE);
		StyleMap.put(ItemID.ENCHANTED_LYRE4, WeaponStyle.MELEE);
		StyleMap.put(ItemID.ENCHANTED_LYRE5, WeaponStyle.MELEE);
		StyleMap.put(ItemID.EXCALIBUR, WeaponStyle.MELEE);
		StyleMap.put(ItemID.EXCALIBUR_8280, WeaponStyle.MELEE);
		StyleMap.put(ItemID.FLAMTAER_HAMMER, WeaponStyle.MELEE);
		StyleMap.put(ItemID.FREMENNIK_BLADE, WeaponStyle.MELEE);
		StyleMap.put(ItemID.FROZEN_ABYSSAL_WHIP, WeaponStyle.MELEE);
		StyleMap.put(ItemID.GADDERHAMMER, WeaponStyle.MELEE);
		StyleMap.put(ItemID.GHRAZI_RAPIER, WeaponStyle.MELEE);
		StyleMap.put(ItemID.GHRAZI_RAPIER_23628, WeaponStyle.MELEE);
		StyleMap.put(ItemID.GIANT_BRONZE_DAGGER, WeaponStyle.MELEE);
		StyleMap.put(ItemID.GILDED_2H_SWORD, WeaponStyle.MELEE);
		StyleMap.put(ItemID.GILDED_HASTA, WeaponStyle.MELEE);
		StyleMap.put(ItemID.GILDED_SCIMITAR, WeaponStyle.MELEE);
		StyleMap.put(ItemID.GILDED_SPEAR, WeaponStyle.MELEE);
		StyleMap.put(ItemID.GLACIAL_TEMOTLI, WeaponStyle.MELEE);
		StyleMap.put(ItemID.GLOWING_DAGGER, WeaponStyle.MELEE);
		StyleMap.put(ItemID.GOLDEN_TENCH, WeaponStyle.MELEE);
		StyleMap.put(ItemID.GRANITE_HAMMER, WeaponStyle.MELEE);
		StyleMap.put(ItemID.GRANITE_LONGSWORD, WeaponStyle.MELEE);
		StyleMap.put(ItemID.GRANITE_MAUL, WeaponStyle.MELEE);
		StyleMap.put(ItemID.GRANITE_MAUL_12848, WeaponStyle.MELEE);
		StyleMap.put(ItemID.GRANITE_MAUL_20557, WeaponStyle.MELEE);
		StyleMap.put(ItemID.GRANITE_MAUL_24225, WeaponStyle.MELEE);
		StyleMap.put(ItemID.GRANITE_MAUL_24227, WeaponStyle.MELEE);
		StyleMap.put(ItemID.GREEN_BANNER, WeaponStyle.MELEE);
		StyleMap.put(ItemID.GUTHANS_WARSPEAR, WeaponStyle.MELEE);
		StyleMap.put(ItemID.GUTHANS_WARSPEAR_0, WeaponStyle.MELEE);
		StyleMap.put(ItemID.GUTHANS_WARSPEAR_100, WeaponStyle.MELEE);
		StyleMap.put(ItemID.GUTHANS_WARSPEAR_25, WeaponStyle.MELEE);
		StyleMap.put(ItemID.GUTHANS_WARSPEAR_50, WeaponStyle.MELEE);
		StyleMap.put(ItemID.GUTHANS_WARSPEAR_75, WeaponStyle.MELEE);
		StyleMap.put(ItemID.HALBERD, WeaponStyle.MELEE);
		StyleMap.put(ItemID.HARRYS_CUTLASS, WeaponStyle.MELEE);
		StyleMap.put(ItemID.HAM_JOINT, WeaponStyle.MELEE);
		StyleMap.put(ItemID.HAND_FAN, WeaponStyle.MELEE);
		StyleMap.put(ItemID.HILL_GIANT_CLUB, WeaponStyle.MELEE);
		StyleMap.put(ItemID.HOLY_HANDEGG, WeaponStyle.MELEE);
		StyleMap.put(ItemID.HOLY_GHRAZI_RAPIER, WeaponStyle.MELEE);
		StyleMap.put(ItemID.HOSIDIUS_BANNER, WeaponStyle.MELEE);
		StyleMap.put(ItemID.INFERNAL_AXE, WeaponStyle.MELEE);
		StyleMap.put(ItemID.INFERNAL_AXE_UNCHARGED, WeaponStyle.MELEE);
		StyleMap.put(ItemID.INFERNAL_AXE_UNCHARGED_25371, WeaponStyle.MELEE);
		StyleMap.put(ItemID.INFERNAL_AXE_UNCHARGED_30348, WeaponStyle.MELEE);
		StyleMap.put(ItemID.INFERNAL_AXE_OR, WeaponStyle.MELEE);
		StyleMap.put(ItemID.INFERNAL_AXE_OR_30347, WeaponStyle.MELEE);
		StyleMap.put(ItemID.INFERNAL_HARPOON, WeaponStyle.MELEE);
		StyleMap.put(ItemID.INFERNAL_HARPOON_UNCHARGED, WeaponStyle.MELEE);
		StyleMap.put(ItemID.INFERNAL_HARPOON_UNCHARGED_25367, WeaponStyle.MELEE);
		StyleMap.put(ItemID.INFERNAL_HARPOON_UNCHARGED_30343, WeaponStyle.MELEE);
		StyleMap.put(ItemID.INFERNAL_HARPOON_OR, WeaponStyle.MELEE);
		StyleMap.put(ItemID.INFERNAL_HARPOON_OR_30342, WeaponStyle.MELEE);
		StyleMap.put(ItemID.INFERNAL_PICKAXE, WeaponStyle.MELEE);
		StyleMap.put(ItemID.INFERNAL_PICKAXE_UNCHARGED, WeaponStyle.MELEE);
		StyleMap.put(ItemID.INFERNAL_PICKAXE_UNCHARGED_25369, WeaponStyle.MELEE);
		StyleMap.put(ItemID.INFERNAL_PICKAXE_UNCHARGED_30346, WeaponStyle.MELEE);
		StyleMap.put(ItemID.INFERNAL_PICKAXE_OR, WeaponStyle.MELEE);
		StyleMap.put(ItemID.INFERNAL_PICKAXE_OR_30345, WeaponStyle.MELEE);
		StyleMap.put(ItemID.INQUISITORS_MACE, WeaponStyle.MELEE);
		StyleMap.put(ItemID.INQUISITORS_MACE_27198, WeaponStyle.MELEE);
		StyleMap.put(ItemID.IRON_2H_SWORD, WeaponStyle.MELEE);
		StyleMap.put(ItemID.IRON_AXE, WeaponStyle.MELEE);
		StyleMap.put(ItemID.IRON_FELLING_AXE, WeaponStyle.MELEE);
		StyleMap.put(ItemID.IRON_BATTLEAXE, WeaponStyle.MELEE);
		StyleMap.put(ItemID.IRON_CLAWS, WeaponStyle.MELEE);
		StyleMap.put(ItemID.IRON_DAGGER, WeaponStyle.MELEE);
		StyleMap.put(ItemID.IRON_DAGGERP, WeaponStyle.MELEE);
		StyleMap.put(ItemID.IRON_DAGGERP_5668, WeaponStyle.MELEE);
		StyleMap.put(ItemID.IRON_DAGGERP_5686, WeaponStyle.MELEE);
		StyleMap.put(ItemID.IRON_HALBERD, WeaponStyle.MELEE);
		StyleMap.put(ItemID.IRON_HASTA, WeaponStyle.MELEE);
		StyleMap.put(ItemID.IRON_LONGSWORD, WeaponStyle.MELEE);
		StyleMap.put(ItemID.IRON_MACE, WeaponStyle.MELEE);
		StyleMap.put(ItemID.IRON_PICKAXE, WeaponStyle.MELEE);
		StyleMap.put(ItemID.IRON_SCIMITAR, WeaponStyle.MELEE);
		StyleMap.put(ItemID.IRON_SPEAR, WeaponStyle.MELEE);
		StyleMap.put(ItemID.IRON_SPEARP, WeaponStyle.MELEE);
		StyleMap.put(ItemID.IRON_SPEARP_5706, WeaponStyle.MELEE);
		StyleMap.put(ItemID.IRON_SPEARP_5720, WeaponStyle.MELEE);
		StyleMap.put(ItemID.IRON_SWORD, WeaponStyle.MELEE);
		StyleMap.put(ItemID.IRON_WARHAMMER, WeaponStyle.MELEE);
		StyleMap.put(ItemID.JADE_MACHETE, WeaponStyle.MELEE);
		StyleMap.put(ItemID.KATANA, WeaponStyle.MELEE);
		StyleMap.put(ItemID.KITCHEN_KNIFE, WeaponStyle.MELEE);
		StyleMap.put(ItemID.KERIS, WeaponStyle.MELEE);
		StyleMap.put(ItemID.KERISP_10583, WeaponStyle.MELEE);
		StyleMap.put(ItemID.KERISP_10584, WeaponStyle.MELEE);
		StyleMap.put(ItemID.KERIS_PARTISAN, WeaponStyle.MELEE);
		StyleMap.put(ItemID.KERIS_PARTISAN_OF_BREACHING, WeaponStyle.MELEE);
		StyleMap.put(ItemID.KERIS_PARTISAN_OF_CORRUPTION, WeaponStyle.MELEE);
		StyleMap.put(ItemID.KERIS_PARTISAN_OF_THE_SUN, WeaponStyle.MELEE);
		StyleMap.put(ItemID.LARGE_SPADE, WeaponStyle.MELEE);
		StyleMap.put(ItemID.LEAFBLADED_BATTLEAXE, WeaponStyle.MELEE);
		StyleMap.put(ItemID.LEAFBLADED_SPEAR, WeaponStyle.MELEE);
		StyleMap.put(ItemID.LEAFBLADED_SPEAR_4159, WeaponStyle.MELEE);
		StyleMap.put(ItemID.LEAFBLADED_SWORD, WeaponStyle.MELEE);
		StyleMap.put(ItemID.LOVAKENGJ_BANNER, WeaponStyle.MELEE);
		StyleMap.put(ItemID.LUCKY_CUTLASS, WeaponStyle.MELEE);
		StyleMap.put(ItemID.LYRE, WeaponStyle.MELEE);
		StyleMap.put(ItemID.MACE, WeaponStyle.MELEE);
		StyleMap.put(ItemID.MACHETE, WeaponStyle.MELEE);
		StyleMap.put(ItemID.MAGIC_BUTTERFLY_NET, WeaponStyle.MELEE);
		StyleMap.put(ItemID.MAGIC_SECATEURS, WeaponStyle.MELEE);
		StyleMap.put(ItemID.MAGIC_SECATEURS_NZ, WeaponStyle.MELEE);
		StyleMap.put(ItemID.MAPLE_BLACKJACK, WeaponStyle.MELEE);
		StyleMap.put(ItemID.MAPLE_BLACKJACKD, WeaponStyle.MELEE);
		StyleMap.put(ItemID.MAPLE_BLACKJACKO, WeaponStyle.MELEE);
		StyleMap.put(ItemID.MEAT_TENDERISER, WeaponStyle.MELEE);
		StyleMap.put(ItemID.MERFOLK_TRIDENT, WeaponStyle.MELEE);
		StyleMap.put(ItemID.MITHRIL_2H_SWORD, WeaponStyle.MELEE);
		StyleMap.put(ItemID.MITHRIL_AXE, WeaponStyle.MELEE);
		StyleMap.put(ItemID.MITHRIL_FELLING_AXE, WeaponStyle.MELEE);
		StyleMap.put(ItemID.MITHRIL_BATTLEAXE, WeaponStyle.MELEE);
		StyleMap.put(ItemID.MITHRIL_CLAWS, WeaponStyle.MELEE);
		StyleMap.put(ItemID.MITHRIL_DAGGER, WeaponStyle.MELEE);
		StyleMap.put(ItemID.MITHRIL_DAGGERP, WeaponStyle.MELEE);
		StyleMap.put(ItemID.MITHRIL_DAGGERP_5674, WeaponStyle.MELEE);
		StyleMap.put(ItemID.MITHRIL_DAGGERP_5692, WeaponStyle.MELEE);
		StyleMap.put(ItemID.MITHRIL_HALBERD, WeaponStyle.MELEE);
		StyleMap.put(ItemID.MITHRIL_HASTA, WeaponStyle.MELEE);
		StyleMap.put(ItemID.MITHRIL_LONGSWORD, WeaponStyle.MELEE);
		StyleMap.put(ItemID.MITHRIL_MACE, WeaponStyle.MELEE);
		StyleMap.put(ItemID.MITHRIL_PICKAXE, WeaponStyle.MELEE);
		StyleMap.put(ItemID.MITHRIL_SCIMITAR, WeaponStyle.MELEE);
		StyleMap.put(ItemID.MITHRIL_SPEAR, WeaponStyle.MELEE);
		StyleMap.put(ItemID.MITHRIL_SPEARP, WeaponStyle.MELEE);
		StyleMap.put(ItemID.MITHRIL_SPEARP_5710, WeaponStyle.MELEE);
		StyleMap.put(ItemID.MITHRIL_SPEARP_5724, WeaponStyle.MELEE);
		StyleMap.put(ItemID.MITHRIL_SWORD, WeaponStyle.MELEE);
		StyleMap.put(ItemID.MITHRIL_WARHAMMER, WeaponStyle.MELEE);
		StyleMap.put(ItemID.MIXED_FLOWERS, WeaponStyle.MELEE);
		StyleMap.put(ItemID.MOUSE_TOY, WeaponStyle.MELEE);
		StyleMap.put(ItemID.NATURES_REPRISAL, WeaponStyle.MELEE);
		StyleMap.put(ItemID.NATURES_REPRISAL_UNCHARGED, WeaponStyle.MELEE);
		StyleMap.put(ItemID.NEW_CRYSTAL_HALBERD_FULL, WeaponStyle.MELEE);
		StyleMap.put(ItemID.NEW_CRYSTAL_HALBERD_FULL_I, WeaponStyle.MELEE);
		StyleMap.put(ItemID.NEW_CRYSTAL_HALBERD_FULL_16893, WeaponStyle.MELEE);
		StyleMap.put(ItemID.NEW_CRYSTAL_HALBERD_FULL_I_16892, WeaponStyle.MELEE);
		StyleMap.put(ItemID.NOOSE_WAND, WeaponStyle.MELEE);
		StyleMap.put(ItemID.NOXIOUS_HALBERD, WeaponStyle.MELEE);
		StyleMap.put(ItemID.NUNCHAKU, WeaponStyle.MELEE);
		StyleMap.put(ItemID.OAK_BLACKJACK, WeaponStyle.MELEE);
		StyleMap.put(ItemID.OAK_BLACKJACKD, WeaponStyle.MELEE);
		StyleMap.put(ItemID.OAK_BLACKJACKO, WeaponStyle.MELEE);
		StyleMap.put(ItemID.OILY_FISHING_ROD, WeaponStyle.MELEE);
		StyleMap.put(ItemID.OILY_PEARL_FISHING_ROD, WeaponStyle.MELEE);
		StyleMap.put(ItemID.OPAL_MACHETE, WeaponStyle.MELEE);
		StyleMap.put(ItemID.ORANGE_FLOWERS, WeaponStyle.MELEE);
		StyleMap.put(ItemID.ORANGE_SALAMANDER, WeaponStyle.MELEE);
		StyleMap.put(ItemID.OSMUMTENS_FANG, WeaponStyle.MELEE);
		StyleMap.put(ItemID.OSMUMTENS_FANG_OR, WeaponStyle.MELEE);
		StyleMap.put(ItemID.PEACEFUL_HANDEGG, WeaponStyle.MELEE);
		StyleMap.put(ItemID.PET_ROCK, WeaponStyle.MELEE);
		StyleMap.put(ItemID.PISCARILIUS_BANNER, WeaponStyle.MELEE);
		StyleMap.put(ItemID.PROP_SWORD, WeaponStyle.MELEE);
		StyleMap.put(ItemID.PURPLE_FLOWERS, WeaponStyle.MELEE);
		StyleMap.put(ItemID.RAGING_ECHOES_CANE, WeaponStyle.MELEE);
		StyleMap.put(ItemID.RAPIER, WeaponStyle.MELEE);
		StyleMap.put(ItemID.RAT_POLE, WeaponStyle.MELEE);
		StyleMap.put(ItemID.RAT_POLE_6774, WeaponStyle.MELEE);
		StyleMap.put(ItemID.RAT_POLE_6775, WeaponStyle.MELEE);
		StyleMap.put(ItemID.RAT_POLE_6776, WeaponStyle.MELEE);
		StyleMap.put(ItemID.RAT_POLE_6777, WeaponStyle.MELEE);
		StyleMap.put(ItemID.RAT_POLE_6778, WeaponStyle.MELEE);
		StyleMap.put(ItemID.RAT_POLE_6779, WeaponStyle.MELEE);
		StyleMap.put(ItemID.RED_FLOWERS, WeaponStyle.MELEE);
		StyleMap.put(ItemID.RED_FLOWERS_8938, WeaponStyle.MELEE);
		StyleMap.put(ItemID.RED_SALAMANDER, WeaponStyle.MELEE);
		StyleMap.put(ItemID.RED_TOPAZ_MACHETE, WeaponStyle.MELEE);
		StyleMap.put(ItemID.ROCK_HAMMER, WeaponStyle.MELEE);
		StyleMap.put(ItemID.ROYAL_SCEPTRE, WeaponStyle.MELEE);
		StyleMap.put(ItemID.RUBBER_CHICKEN, WeaponStyle.MELEE);
		StyleMap.put(ItemID.RUBBER_CHICKEN_22666, WeaponStyle.MELEE);
		StyleMap.put(ItemID.RUNE_2H_SWORD, WeaponStyle.MELEE);
		StyleMap.put(ItemID.RUNE_AXE, WeaponStyle.MELEE);
		StyleMap.put(ItemID.RUNE_FELLING_AXE, WeaponStyle.MELEE);
		StyleMap.put(ItemID.RUNE_BATTLEAXE, WeaponStyle.MELEE);
		StyleMap.put(ItemID.RUNE_BATTLEAXE_20552, WeaponStyle.MELEE);
		StyleMap.put(ItemID.RUNE_CANE, WeaponStyle.MELEE);
		StyleMap.put(ItemID.RUNE_CLAWS, WeaponStyle.MELEE);
		StyleMap.put(ItemID.RUNE_DAGGER, WeaponStyle.MELEE);
		StyleMap.put(ItemID.RUNE_DAGGERP, WeaponStyle.MELEE);
		StyleMap.put(ItemID.RUNE_DAGGERP_5678, WeaponStyle.MELEE);
		StyleMap.put(ItemID.RUNE_DAGGERP_5696, WeaponStyle.MELEE);
		StyleMap.put(ItemID.RUNE_HALBERD, WeaponStyle.MELEE);
		StyleMap.put(ItemID.RUNE_HASTA, WeaponStyle.MELEE);
		StyleMap.put(ItemID.RUNE_LONGSWORD, WeaponStyle.MELEE);
		StyleMap.put(ItemID.RUNE_MACE, WeaponStyle.MELEE);
		StyleMap.put(ItemID.RUNE_PICKAXE, WeaponStyle.MELEE);
		StyleMap.put(ItemID.RUNE_SCIMITAR, WeaponStyle.MELEE);
		StyleMap.put(ItemID.RUNE_SCIMITAR_20402, WeaponStyle.MELEE);
		StyleMap.put(ItemID.RUNE_SCIMITAR_23330, WeaponStyle.MELEE);
		StyleMap.put(ItemID.RUNE_SCIMITAR_23332, WeaponStyle.MELEE);
		StyleMap.put(ItemID.RUNE_SCIMITAR_23334, WeaponStyle.MELEE);
		StyleMap.put(ItemID.RUNE_SPEAR, WeaponStyle.MELEE);
		StyleMap.put(ItemID.RUNE_SPEARP, WeaponStyle.MELEE);
		StyleMap.put(ItemID.RUNE_SPEARP_5714, WeaponStyle.MELEE);
		StyleMap.put(ItemID.RUNE_SPEARP_5728, WeaponStyle.MELEE);
		StyleMap.put(ItemID.RUNE_SWORD, WeaponStyle.MELEE);
		StyleMap.put(ItemID.RUNE_WARHAMMER, WeaponStyle.MELEE);
		StyleMap.put(ItemID.SARADOMINS_BLESSED_SWORD, WeaponStyle.MELEE);
		StyleMap.put(ItemID.SARADOMIN_GODSWORD, WeaponStyle.MELEE);
		StyleMap.put(ItemID.SARADOMIN_GODSWORD_OR, WeaponStyle.MELEE);
		StyleMap.put(ItemID.SARADOMIN_MJOLNIR, WeaponStyle.MELEE);
		StyleMap.put(ItemID.SARADOMIN_SWORD, WeaponStyle.MELEE);
		StyleMap.put(ItemID.SARAS_BLESSED_SWORD_FULL, WeaponStyle.MELEE);
		StyleMap.put(ItemID.SCYTHE, WeaponStyle.MELEE);
		StyleMap.put(ItemID.SECRET_SANTA_PRESENT_RED, WeaponStyle.MELEE);
		StyleMap.put(ItemID.SECRET_SANTA_PRESENT_BLUE, WeaponStyle.MELEE);
		StyleMap.put(ItemID.SECRET_SANTA_PRESENT_GREEN, WeaponStyle.MELEE);
		StyleMap.put(ItemID.SECRET_SANTA_PRESENT_BLACK, WeaponStyle.MELEE);
		StyleMap.put(ItemID.SECRET_SANTA_PRESENT_GOLD, WeaponStyle.MELEE);
		StyleMap.put(ItemID.SEVERED_LEG_24792, WeaponStyle.MELEE);
		StyleMap.put(ItemID.SHADOW_SWORD, WeaponStyle.MELEE);
		StyleMap.put(ItemID.SHAYZIEN_BANNER, WeaponStyle.MELEE);
		StyleMap.put(ItemID.SILVERLIGHT, WeaponStyle.MELEE);
		StyleMap.put(ItemID.SILVERLIGHT_6745, WeaponStyle.MELEE);
		StyleMap.put(ItemID.SILVERLIGHT_8279, WeaponStyle.MELEE);
		StyleMap.put(ItemID.SILVER_SICKLE, WeaponStyle.MELEE);
		StyleMap.put(ItemID.SILVER_SICKLE_B, WeaponStyle.MELEE);
		StyleMap.put(ItemID.SNOWBALL, WeaponStyle.MELEE);
		StyleMap.put(ItemID.SPEAR, WeaponStyle.MELEE);
		StyleMap.put(ItemID.SOULREAPER_AXE, WeaponStyle.MELEE);
		StyleMap.put(ItemID.SOULREAPER_AXE_28338, WeaponStyle.MELEE);
		StyleMap.put(ItemID.STALE_BAGUETTE, WeaponStyle.MELEE);
		StyleMap.put(ItemID.STARTER_SWORD, WeaponStyle.MELEE);
		StyleMap.put(ItemID.STARTER_SWORD_28559, WeaponStyle.MELEE);
		StyleMap.put(ItemID.STATIUSS_WARHAMMER, WeaponStyle.MELEE);
		StyleMap.put(ItemID.STATIUSS_WARHAMMER_23620, WeaponStyle.MELEE);
		StyleMap.put(ItemID.STATIUSS_WARHAMMER_BH, WeaponStyle.MELEE);
		StyleMap.put(ItemID.STATIUSS_WARHAMMER_BHINACTIVE, WeaponStyle.MELEE);
		StyleMap.put(ItemID.STEEL_2H_SWORD, WeaponStyle.MELEE);
		StyleMap.put(ItemID.STEEL_AXE, WeaponStyle.MELEE);
		StyleMap.put(ItemID.STEEL_FELLING_AXE, WeaponStyle.MELEE);
		StyleMap.put(ItemID.STEEL_BATTLEAXE, WeaponStyle.MELEE);
		StyleMap.put(ItemID.STEEL_CLAWS, WeaponStyle.MELEE);
		StyleMap.put(ItemID.STEEL_DAGGER, WeaponStyle.MELEE);
		StyleMap.put(ItemID.STEEL_DAGGERP, WeaponStyle.MELEE);
		StyleMap.put(ItemID.STEEL_DAGGERP_5672, WeaponStyle.MELEE);
		StyleMap.put(ItemID.STEEL_DAGGERP_5690, WeaponStyle.MELEE);
		StyleMap.put(ItemID.STEEL_HALBERD, WeaponStyle.MELEE);
		StyleMap.put(ItemID.STEEL_HASTA, WeaponStyle.MELEE);
		StyleMap.put(ItemID.STEEL_LONGSWORD, WeaponStyle.MELEE);
		StyleMap.put(ItemID.STEEL_PICKAXE, WeaponStyle.MELEE);
		StyleMap.put(ItemID.STEEL_SCIMITAR, WeaponStyle.MELEE);
		StyleMap.put(ItemID.STEEL_SPEAR, WeaponStyle.MELEE);
		StyleMap.put(ItemID.STEEL_SPEARP, WeaponStyle.MELEE);
		StyleMap.put(ItemID.STEEL_SPEARP_5708, WeaponStyle.MELEE);
		StyleMap.put(ItemID.STEEL_SPEARP_5722, WeaponStyle.MELEE);
		StyleMap.put(ItemID.STEEL_SWORD, WeaponStyle.MELEE);
		StyleMap.put(ItemID.STEEL_WARHAMMER, WeaponStyle.MELEE);
		StyleMap.put(ItemID.STONE_BOWL, WeaponStyle.MELEE);
		StyleMap.put(ItemID.SUNLIGHT_SPEAR, WeaponStyle.MELEE);
		StyleMap.put(ItemID.SWAMP_LIZARD, WeaponStyle.MELEE);
		StyleMap.put(ItemID.SWIFT_BLADE, WeaponStyle.MELEE);
		StyleMap.put(ItemID.THE_DOGSWORD, WeaponStyle.MELEE);
		StyleMap.put(ItemID.THUNDER_KHOPESH, WeaponStyle.MELEE);
		StyleMap.put(ItemID.TOKTZXILAK, WeaponStyle.MELEE);
		StyleMap.put(ItemID.TOKTZXILAK_20554, WeaponStyle.MELEE);
		StyleMap.put(ItemID.TOKTZXILEK, WeaponStyle.MELEE);
		StyleMap.put(ItemID.TORAGS_HAMMERS, WeaponStyle.MELEE);
		StyleMap.put(ItemID.TORAGS_HAMMERS_0, WeaponStyle.MELEE);
		StyleMap.put(ItemID.TORAGS_HAMMERS_100, WeaponStyle.MELEE);
		StyleMap.put(ItemID.TORAGS_HAMMERS_25, WeaponStyle.MELEE);
		StyleMap.put(ItemID.TORAGS_HAMMERS_50, WeaponStyle.MELEE);
		StyleMap.put(ItemID.TORAGS_HAMMERS_75, WeaponStyle.MELEE);
		StyleMap.put(ItemID.TRAINING_SWORD, WeaponStyle.MELEE);
		StyleMap.put(ItemID.TRAILBLAZER_ADAMANT_TROPHY, WeaponStyle.MELEE);
		StyleMap.put(ItemID.ECHO_AXE, WeaponStyle.MELEE);
		StyleMap.put(ItemID.TRAILBLAZER_BANNER, WeaponStyle.MELEE);
		StyleMap.put(ItemID.TRAILBLAZER_BRONZE_TROPHY, WeaponStyle.MELEE);
		StyleMap.put(ItemID.TRAILBLAZER_CANE, WeaponStyle.MELEE);
		StyleMap.put(ItemID.TRAILBLAZER_DRAGON_TROPHY, WeaponStyle.MELEE);
		StyleMap.put(ItemID.ECHO_HARPOON, WeaponStyle.MELEE);
		StyleMap.put(ItemID.TRAILBLAZER_IRON_TROPHY, WeaponStyle.MELEE);
		StyleMap.put(ItemID.TRAILBLAZER_MITHRIL_TROPHY, WeaponStyle.MELEE);
		StyleMap.put(ItemID.ECHO_PICKAXE, WeaponStyle.MELEE);
		StyleMap.put(ItemID.TRAILBLAZER_RUNE_TROPHY, WeaponStyle.MELEE);
		StyleMap.put(ItemID.TRAILBLAZER_STEEL_TROPHY, WeaponStyle.MELEE);
		StyleMap.put(ItemID.TRAILBLAZER_RELOADED_ADAMANT_TROPHY, WeaponStyle.MELEE);
		StyleMap.put(ItemID.TRAILBLAZER_RELOADED_BANNER, WeaponStyle.MELEE);
		StyleMap.put(ItemID.TRAILBLAZER_RELOADED_BRONZE_TROPHY, WeaponStyle.MELEE);
		StyleMap.put(ItemID.TRAILBLAZER_RELOADED_DRAGON_TROPHY, WeaponStyle.MELEE);
		StyleMap.put(ItemID.TRAILBLAZER_RELOADED_IRON_TROPHY, WeaponStyle.MELEE);
		StyleMap.put(ItemID.TRAILBLAZER_RELOADED_MITHRIL_TROPHY, WeaponStyle.MELEE);
		StyleMap.put(ItemID.TRAILBLAZER_RELOADED_RUNE_TROPHY, WeaponStyle.MELEE);
		StyleMap.put(ItemID.TRAILBLAZER_RELOADED_STEEL_TROPHY, WeaponStyle.MELEE);
		StyleMap.put(ItemID.TRAILBLAZER_RELOADED_TORCH, WeaponStyle.MELEE);
		StyleMap.put(ItemID.TROLLWEISS, WeaponStyle.MELEE);
		StyleMap.put(ItemID.TWISTED_BANNER, WeaponStyle.MELEE);
		StyleMap.put(ItemID.TZHAARKETEM, WeaponStyle.MELEE);
		StyleMap.put(ItemID.TZHAARKETOM, WeaponStyle.MELEE);
		StyleMap.put(ItemID.TZHAARKETOM_T, WeaponStyle.MELEE);
		StyleMap.put(ItemID.URSINE_CHAINMACE, WeaponStyle.MELEE);
		StyleMap.put(ItemID.URSINE_CHAINMACE_U, WeaponStyle.MELEE);
		StyleMap.put(ItemID.VERACS_FLAIL, WeaponStyle.MELEE);
		StyleMap.put(ItemID.VERACS_FLAIL_0, WeaponStyle.MELEE);
		StyleMap.put(ItemID.VERACS_FLAIL_100, WeaponStyle.MELEE);
		StyleMap.put(ItemID.VERACS_FLAIL_25, WeaponStyle.MELEE);
		StyleMap.put(ItemID.VERACS_FLAIL_50, WeaponStyle.MELEE);
		StyleMap.put(ItemID.VERACS_FLAIL_75, WeaponStyle.MELEE);
		StyleMap.put(ItemID.VERACS_FLAIL_27189, WeaponStyle.MELEE);
		StyleMap.put(ItemID.VESTAS_BLIGHTED_LONGSWORD, WeaponStyle.MELEE);
		StyleMap.put(ItemID.VESTAS_LONGSWORD_INACTIVE, WeaponStyle.MELEE);
		StyleMap.put(ItemID.VESTAS_LONGSWORD, WeaponStyle.MELEE);
		StyleMap.put(ItemID.VESTAS_LONGSWORD_23615, WeaponStyle.MELEE);
		StyleMap.put(ItemID.VESTAS_LONGSWORD_BH, WeaponStyle.MELEE);
		StyleMap.put(ItemID.VESTAS_LONGSWORD_BHINACTIVE, WeaponStyle.MELEE);
		StyleMap.put(ItemID.VESTAS_SPEAR, WeaponStyle.MELEE);
		StyleMap.put(ItemID.VESTAS_SPEAR_BH, WeaponStyle.MELEE);
		StyleMap.put(ItemID.VESTAS_SPEAR_BHINACTIVE, WeaponStyle.MELEE);
		StyleMap.put(ItemID.VIGGORAS_CHAINMACE, WeaponStyle.MELEE);
		StyleMap.put(ItemID.VIGGORAS_CHAINMACE_U, WeaponStyle.MELEE);
		StyleMap.put(ItemID.VOIDWAKER, WeaponStyle.MELEE);
		StyleMap.put(ItemID.VOLCANIC_ABYSSAL_WHIP, WeaponStyle.MELEE);
		StyleMap.put(ItemID.WESTERN_BANNER_1, WeaponStyle.MELEE);
		StyleMap.put(ItemID.WESTERN_BANNER_2, WeaponStyle.MELEE);
		StyleMap.put(ItemID.WESTERN_BANNER_3, WeaponStyle.MELEE);
		StyleMap.put(ItemID.WESTERN_BANNER_4, WeaponStyle.MELEE);
		StyleMap.put(ItemID.WHITE_2H_SWORD, WeaponStyle.MELEE);
		StyleMap.put(ItemID.WHITE_BATTLEAXE, WeaponStyle.MELEE);
		StyleMap.put(ItemID.WHITE_CLAWS, WeaponStyle.MELEE);
		StyleMap.put(ItemID.WHITE_DAGGER, WeaponStyle.MELEE);
		StyleMap.put(ItemID.WHITE_DAGGERP, WeaponStyle.MELEE);
		StyleMap.put(ItemID.WHITE_DAGGERP_6595, WeaponStyle.MELEE);
		StyleMap.put(ItemID.WHITE_DAGGERP_6597, WeaponStyle.MELEE);
		StyleMap.put(ItemID.WHITE_FLOWERS, WeaponStyle.MELEE);
		StyleMap.put(ItemID.WHITE_HALBERD, WeaponStyle.MELEE);
		StyleMap.put(ItemID.WHITE_LONGSWORD, WeaponStyle.MELEE);
		StyleMap.put(ItemID.WHITE_MACE, WeaponStyle.MELEE);
		StyleMap.put(ItemID.WHITE_SCIMITAR, WeaponStyle.MELEE);
		StyleMap.put(ItemID.WHITE_SWORD, WeaponStyle.MELEE);
		StyleMap.put(ItemID.WHITE_WARHAMMER, WeaponStyle.MELEE);
		StyleMap.put(ItemID.WILDERNESS_SWORD_1, WeaponStyle.MELEE);
		StyleMap.put(ItemID.WILDERNESS_SWORD_2, WeaponStyle.MELEE);
		StyleMap.put(ItemID.WILDERNESS_SWORD_3, WeaponStyle.MELEE);
		StyleMap.put(ItemID.WILDERNESS_SWORD_4, WeaponStyle.MELEE);
		StyleMap.put(ItemID.WILLOW_BLACKJACK, WeaponStyle.MELEE);
		StyleMap.put(ItemID.WILLOW_BLACKJACKD, WeaponStyle.MELEE);
		StyleMap.put(ItemID.WILLOW_BLACKJACKO, WeaponStyle.MELEE);
		StyleMap.put(ItemID.WOLFBANE, WeaponStyle.MELEE);
		StyleMap.put(ItemID.WOODEN_SPOON, WeaponStyle.MELEE);
		StyleMap.put(ItemID.WOODEN_SWORD, WeaponStyle.MELEE);
		StyleMap.put(ItemID.YELLOW_FLOWERS, WeaponStyle.MELEE);
		StyleMap.put(ItemID.ZAMORAKIAN_HASTA, WeaponStyle.MELEE);
		StyleMap.put(ItemID.ZAMORAKIAN_SPEAR, WeaponStyle.MELEE);
		StyleMap.put(ItemID.ZAMORAK_GODSWORD, WeaponStyle.MELEE);
		StyleMap.put(ItemID.ZAMORAK_GODSWORD_OR, WeaponStyle.MELEE);
		StyleMap.put(ItemID.ZOMBIE_HEAD, WeaponStyle.MELEE);
		StyleMap.put(-1, WeaponStyle.MELEE); //hands and feet

		//Scythes
		StyleMap.put(ItemID.CORRUPTED_SCYTHE_OF_VITUR, WeaponStyle.SCYTHES);
		StyleMap.put(ItemID.CORRUPTED_SCYTHE_OF_VITUR_UNCHARGED, WeaponStyle.SCYTHES);
		StyleMap.put(ItemID.HOLY_SCYTHE_OF_VITUR, WeaponStyle.SCYTHES);
		StyleMap.put(ItemID.HOLY_SCYTHE_OF_VITUR_UNCHARGED, WeaponStyle.SCYTHES);
		StyleMap.put(ItemID.SANGUINE_SCYTHE_OF_VITUR, WeaponStyle.SCYTHES);
		StyleMap.put(ItemID.SANGUINE_SCYTHE_OF_VITUR_UNCHARGED, WeaponStyle.SCYTHES);
		StyleMap.put(ItemID.SCYTHE_OF_VITUR, WeaponStyle.SCYTHES);
		StyleMap.put(ItemID.SCYTHE_OF_VITUR_22664, WeaponStyle.SCYTHES);
		StyleMap.put(ItemID.SCYTHE_OF_VITUR_UNCHARGED, WeaponStyle.SCYTHES);

		//Ranged
		StyleMap.put(ItemID._3RD_AGE_BOW, WeaponStyle.RANGE);
		StyleMap.put(ItemID.ADAMANT_CROSSBOW, WeaponStyle.RANGE);
		StyleMap.put(ItemID.ADAMANT_DART, WeaponStyle.RANGE);
		StyleMap.put(ItemID.ADAMANT_DARTP, WeaponStyle.RANGE);
		StyleMap.put(ItemID.ADAMANT_DARTP_5633, WeaponStyle.RANGE);
		StyleMap.put(ItemID.ADAMANT_DARTP_5640, WeaponStyle.RANGE);
		StyleMap.put(ItemID.ADAMANT_KNIFE, WeaponStyle.RANGE);
		StyleMap.put(ItemID.ADAMANT_KNIFEP, WeaponStyle.RANGE);
		StyleMap.put(ItemID.ADAMANT_KNIFEP_5659, WeaponStyle.RANGE);
		StyleMap.put(ItemID.ADAMANT_KNIFEP_5666, WeaponStyle.RANGE);
		StyleMap.put(ItemID.ADAMANT_THROWNAXE, WeaponStyle.RANGE);
		StyleMap.put(ItemID.AMETHYST_DART, WeaponStyle.RANGE);
		StyleMap.put(ItemID.AMETHYST_DARTP, WeaponStyle.RANGE);
		StyleMap.put(ItemID.AMETHYST_DARTP_25855, WeaponStyle.RANGE);
		StyleMap.put(ItemID.AMETHYST_DARTP_25857, WeaponStyle.RANGE);
		StyleMap.put(ItemID.ARMADYL_CROSSBOW, WeaponStyle.RANGE);
		StyleMap.put(ItemID.ARMADYL_CROSSBOW_23611, WeaponStyle.RANGE);
		StyleMap.put(ItemID.BLACK_DART, WeaponStyle.RANGE);
		StyleMap.put(ItemID.BLACK_DARTP, WeaponStyle.RANGE);
		StyleMap.put(ItemID.BLACK_DARTP_5631, WeaponStyle.RANGE);
		StyleMap.put(ItemID.BLACK_DARTP_5638, WeaponStyle.RANGE);
		StyleMap.put(ItemID.BLACK_KNIFE, WeaponStyle.RANGE);
		StyleMap.put(ItemID.BLACK_KNIFEP, WeaponStyle.RANGE);
		StyleMap.put(ItemID.BLACK_KNIFEP_5658, WeaponStyle.RANGE);
		StyleMap.put(ItemID.BLACK_KNIFEP_5665, WeaponStyle.RANGE);
		StyleMap.put(ItemID.BLAZING_BLOWPIPE, WeaponStyle.RANGE);
		StyleMap.put(ItemID.BLAZING_BLOWPIPE_EMPTY, WeaponStyle.RANGE);
		StyleMap.put(ItemID.BLURITE_CROSSBOW, WeaponStyle.RANGE);
		StyleMap.put(ItemID.BRONZE_CROSSBOW, WeaponStyle.RANGE);
		StyleMap.put(ItemID.BRONZE_DART, WeaponStyle.RANGE);
		StyleMap.put(ItemID.BRONZE_DARTP, WeaponStyle.RANGE);
		StyleMap.put(ItemID.BRONZE_DARTP_5628, WeaponStyle.RANGE);
		StyleMap.put(ItemID.BRONZE_DARTP_5635, WeaponStyle.RANGE);
		StyleMap.put(ItemID.BRONZE_KNIFE, WeaponStyle.RANGE);
		StyleMap.put(ItemID.BRONZE_KNIFEP, WeaponStyle.RANGE);
		StyleMap.put(ItemID.BRONZE_KNIFEP_5654, WeaponStyle.RANGE);
		StyleMap.put(ItemID.BRONZE_KNIFEP_5661, WeaponStyle.RANGE);
		StyleMap.put(ItemID.BRONZE_THROWNAXE, WeaponStyle.RANGE);
		StyleMap.put(ItemID.BOW_OF_FAERDHINEN_INACTIVE, WeaponStyle.RANGE);
		StyleMap.put(ItemID.BOW_OF_FAERDHINEN, WeaponStyle.RANGE);
		StyleMap.put(ItemID.BOW_OF_FAERDHINEN_C, WeaponStyle.RANGE);
		StyleMap.put(ItemID.BOW_OF_FAERDHINEN_C_25869, WeaponStyle.RANGE);
		StyleMap.put(ItemID.BOW_OF_FAERDHINEN_C_25884, WeaponStyle.RANGE);
		StyleMap.put(ItemID.BOW_OF_FAERDHINEN_C_25886, WeaponStyle.RANGE);
		StyleMap.put(ItemID.BOW_OF_FAERDHINEN_C_25888, WeaponStyle.RANGE);
		StyleMap.put(ItemID.BOW_OF_FAERDHINEN_C_25890, WeaponStyle.RANGE);
		StyleMap.put(ItemID.BOW_OF_FAERDHINEN_C_25892, WeaponStyle.RANGE);
		StyleMap.put(ItemID.BOW_OF_FAERDHINEN_C_25894, WeaponStyle.RANGE);
		StyleMap.put(ItemID.BOW_OF_FAERDHINEN_C_25896, WeaponStyle.RANGE);
		StyleMap.put(ItemID.BOW_OF_FAERDHINEN_27187, WeaponStyle.RANGE);
		StyleMap.put(ItemID.COMP_OGRE_BOW, WeaponStyle.RANGE);
		StyleMap.put(ItemID.CORRUPTED_BOW_ATTUNED, WeaponStyle.RANGE);
		StyleMap.put(ItemID.CORRUPTED_BOW_BASIC, WeaponStyle.RANGE);
		StyleMap.put(ItemID.CORRUPTED_BOW_PERFECTED, WeaponStyle.RANGE);
		StyleMap.put(ItemID.CORRUPTED_TWISTED_BOW, WeaponStyle.RANGE);
		StyleMap.put(ItemID.CRAWS_BOW, WeaponStyle.RANGE);
		StyleMap.put(ItemID.CRAWS_BOW_U, WeaponStyle.RANGE);
		StyleMap.put(ItemID.CROSSBOW, WeaponStyle.RANGE);
		StyleMap.put(ItemID.CRYSTAL_BOW, WeaponStyle.RANGE);
		StyleMap.put(ItemID.CRYSTAL_BOW_110, WeaponStyle.RANGE);
		StyleMap.put(ItemID.CRYSTAL_BOW_110_I, WeaponStyle.RANGE);
		StyleMap.put(ItemID.CRYSTAL_BOW_210, WeaponStyle.RANGE);
		StyleMap.put(ItemID.CRYSTAL_BOW_210_I, WeaponStyle.RANGE);
		StyleMap.put(ItemID.CRYSTAL_BOW_310, WeaponStyle.RANGE);
		StyleMap.put(ItemID.CRYSTAL_BOW_310_I, WeaponStyle.RANGE);
		StyleMap.put(ItemID.CRYSTAL_BOW_410, WeaponStyle.RANGE);
		StyleMap.put(ItemID.CRYSTAL_BOW_410_I, WeaponStyle.RANGE);
		StyleMap.put(ItemID.CRYSTAL_BOW_510, WeaponStyle.RANGE);
		StyleMap.put(ItemID.CRYSTAL_BOW_510_I, WeaponStyle.RANGE);
		StyleMap.put(ItemID.CRYSTAL_BOW_610, WeaponStyle.RANGE);
		StyleMap.put(ItemID.CRYSTAL_BOW_610_I, WeaponStyle.RANGE);
		StyleMap.put(ItemID.CRYSTAL_BOW_710, WeaponStyle.RANGE);
		StyleMap.put(ItemID.CRYSTAL_BOW_710_I, WeaponStyle.RANGE);
		StyleMap.put(ItemID.CRYSTAL_BOW_810, WeaponStyle.RANGE);
		StyleMap.put(ItemID.CRYSTAL_BOW_810_I, WeaponStyle.RANGE);
		StyleMap.put(ItemID.CRYSTAL_BOW_910, WeaponStyle.RANGE);
		StyleMap.put(ItemID.CRYSTAL_BOW_910_I, WeaponStyle.RANGE);
		StyleMap.put(ItemID.CRYSTAL_BOW_24123, WeaponStyle.RANGE);
		StyleMap.put(ItemID.CRYSTAL_BOW_ATTUNED, WeaponStyle.RANGE);
		StyleMap.put(ItemID.CRYSTAL_BOW_BASIC, WeaponStyle.RANGE);
		StyleMap.put(ItemID.CRYSTAL_BOW_FULL, WeaponStyle.RANGE);
		StyleMap.put(ItemID.CRYSTAL_BOW_FULL_I, WeaponStyle.RANGE);
		StyleMap.put(ItemID.CRYSTAL_BOW_INACTIVE, WeaponStyle.RANGE);
		StyleMap.put(ItemID.CRYSTAL_BOW_PERFECTED, WeaponStyle.RANGE);
		StyleMap.put(ItemID.CURSED_GOBLIN_BOW, WeaponStyle.RANGE);
		StyleMap.put(ItemID.DARK_BOW, WeaponStyle.RANGE);
		StyleMap.put(ItemID.DARK_BOW_12765, WeaponStyle.RANGE);
		StyleMap.put(ItemID.DARK_BOW_12766, WeaponStyle.RANGE);
		StyleMap.put(ItemID.DARK_BOW_12767, WeaponStyle.RANGE);
		StyleMap.put(ItemID.DARK_BOW_12768, WeaponStyle.RANGE);
		StyleMap.put(ItemID.DARK_BOW_20408, WeaponStyle.RANGE);
		StyleMap.put(ItemID.DARK_BOW_BH, WeaponStyle.RANGE);
		StyleMap.put(ItemID.DART, WeaponStyle.RANGE);
		StyleMap.put(ItemID.DORGESHUUN_CROSSBOW, WeaponStyle.RANGE);
		StyleMap.put(ItemID.DRAGON_CROSSBOW, WeaponStyle.RANGE);
		StyleMap.put(ItemID.DRAGON_CROSSBOW_CR, WeaponStyle.RANGE);
		StyleMap.put(ItemID.DRAGON_DART, WeaponStyle.RANGE);
		StyleMap.put(ItemID.DRAGON_DARTP, WeaponStyle.RANGE);
		StyleMap.put(ItemID.DRAGON_DARTP_11233, WeaponStyle.RANGE);
		StyleMap.put(ItemID.DRAGON_DARTP_11234, WeaponStyle.RANGE);
		StyleMap.put(ItemID.DRAGON_HUNTER_CROSSBOW, WeaponStyle.RANGE);
		StyleMap.put(ItemID.DRAGON_HUNTER_CROSSBOW_B, WeaponStyle.RANGE);
		StyleMap.put(ItemID.DRAGON_HUNTER_CROSSBOW_T, WeaponStyle.RANGE);
		StyleMap.put(ItemID.DRAGON_KNIFE, WeaponStyle.RANGE);
		StyleMap.put(ItemID.DRAGON_KNIFE_22812, WeaponStyle.RANGE);
		StyleMap.put(ItemID.DRAGON_KNIFE_22814, WeaponStyle.RANGE);
		StyleMap.put(ItemID.DRAGON_KNIFEP, WeaponStyle.RANGE);
		StyleMap.put(ItemID.DRAGON_KNIFEP_22808, WeaponStyle.RANGE);
		StyleMap.put(ItemID.DRAGON_KNIFEP_22810, WeaponStyle.RANGE);
		StyleMap.put(ItemID.DRAGON_THROWNAXE, WeaponStyle.RANGE);
		StyleMap.put(ItemID.DRYGORE_BLOWPIPE, WeaponStyle.RANGE);
		StyleMap.put(ItemID.DRYGORE_BLOWPIPE_EMPTY, WeaponStyle.RANGE);
		StyleMap.put(ItemID.ECHO_VENATOR_BOW, WeaponStyle.RANGE);
		StyleMap.put(ItemID.ECHO_VENATOR_BOW_UNCHARGED, WeaponStyle.RANGE);
		StyleMap.put(ItemID.ECLIPSE_ATLATL, WeaponStyle.RANGE);
		StyleMap.put(ItemID.HEAVY_BALLISTA, WeaponStyle.RANGE);
		StyleMap.put(ItemID.HEAVY_BALLISTA_23630, WeaponStyle.RANGE);
		StyleMap.put(ItemID.HEAVY_BALLISTA_OR, WeaponStyle.RANGE);
		StyleMap.put(ItemID.HOLY_WATER, WeaponStyle.RANGE);
		StyleMap.put(ItemID.HUNTERS_CROSSBOW, WeaponStyle.RANGE);
		StyleMap.put(ItemID.IRON_CROSSBOW, WeaponStyle.RANGE);
		StyleMap.put(ItemID.IRON_DART, WeaponStyle.RANGE);
		StyleMap.put(ItemID.IRON_DARTP, WeaponStyle.RANGE);
		StyleMap.put(ItemID.IRON_DART_P, WeaponStyle.RANGE);
		StyleMap.put(ItemID.IRON_DARTP_5636, WeaponStyle.RANGE);
		StyleMap.put(ItemID.IRON_KNIFE, WeaponStyle.RANGE);
		StyleMap.put(ItemID.IRON_KNIFEP, WeaponStyle.RANGE);
		StyleMap.put(ItemID.IRON_KNIFEP_5655, WeaponStyle.RANGE);
		StyleMap.put(ItemID.IRON_KNIFEP_5662, WeaponStyle.RANGE);
		StyleMap.put(ItemID.IRON_THROWNAXE, WeaponStyle.RANGE);
		StyleMap.put(ItemID.KARILS_CROSSBOW, WeaponStyle.RANGE);
		StyleMap.put(ItemID.KARILS_CROSSBOW_0, WeaponStyle.RANGE);
		StyleMap.put(ItemID.KARILS_CROSSBOW_100, WeaponStyle.RANGE);
		StyleMap.put(ItemID.KARILS_CROSSBOW_25, WeaponStyle.RANGE);
		StyleMap.put(ItemID.KARILS_CROSSBOW_50, WeaponStyle.RANGE);
		StyleMap.put(ItemID.KARILS_CROSSBOW_75, WeaponStyle.RANGE);
		StyleMap.put(ItemID.LIGHT_BALLISTA, WeaponStyle.RANGE);
		StyleMap.put(ItemID.LIGHT_BALLISTA_27188, WeaponStyle.RANGE);
		StyleMap.put(ItemID.LONGBOW, WeaponStyle.RANGE);
		StyleMap.put(ItemID.MAGIC_COMP_BOW, WeaponStyle.RANGE);
		StyleMap.put(ItemID.MAGIC_LONGBOW, WeaponStyle.RANGE);
		StyleMap.put(ItemID.MAGIC_SHORTBOW, WeaponStyle.RANGE);
		StyleMap.put(ItemID.MAGIC_SHORTBOW_20558, WeaponStyle.RANGE);
		StyleMap.put(ItemID.MAGIC_SHORTBOW_I, WeaponStyle.RANGE);
		StyleMap.put(ItemID.MAPLE_LONGBOW, WeaponStyle.RANGE);
		StyleMap.put(ItemID.MAPLE_SHORTBOW, WeaponStyle.RANGE);
		StyleMap.put(ItemID.MITHRIL_DART, WeaponStyle.RANGE);
		StyleMap.put(ItemID.MITHRIL_DARTP, WeaponStyle.RANGE);
		StyleMap.put(ItemID.MITHRIL_DARTP_5632, WeaponStyle.RANGE);
		StyleMap.put(ItemID.MITHRIL_DARTP_5639, WeaponStyle.RANGE);
		StyleMap.put(ItemID.MITHRIL_KNIFE, WeaponStyle.RANGE);
		StyleMap.put(ItemID.MITHRIL_KNIFEP, WeaponStyle.RANGE);
		StyleMap.put(ItemID.MITHRIL_KNIFEP_5657, WeaponStyle.RANGE);
		StyleMap.put(ItemID.MITHRIL_KNIFEP_5664, WeaponStyle.RANGE);
		StyleMap.put(ItemID.MITHRIL_THROWNAXE, WeaponStyle.RANGE);
		StyleMap.put(ItemID.MITHRIL_CROSSBOW, WeaponStyle.RANGE);
		StyleMap.put(ItemID.MONKEY_TALISMAN, WeaponStyle.RANGE);
		StyleMap.put(ItemID.MORRIGANS_JAVELIN, WeaponStyle.RANGE);
		StyleMap.put(ItemID.MORRIGANS_JAVELIN_23619, WeaponStyle.RANGE);
		StyleMap.put(ItemID.MORRIGANS_JAVELIN_BH, WeaponStyle.RANGE);
		StyleMap.put(ItemID.MORRIGANS_JAVELIN_BHINACTIVE, WeaponStyle.RANGE);
		StyleMap.put(ItemID.MORRIGANS_THROWING_AXE, WeaponStyle.RANGE);
		StyleMap.put(ItemID.MORRIGANS_THROWING_AXE_BH, WeaponStyle.RANGE);
		StyleMap.put(ItemID.MORRIGANS_THROWING_AXE_BHINACTIVE, WeaponStyle.RANGE);
		StyleMap.put(ItemID.MUD_PIE, WeaponStyle.RANGE);
		StyleMap.put(ItemID.NEW_CRYSTAL_BOW, WeaponStyle.RANGE);
		StyleMap.put(ItemID.NEW_CRYSTAL_BOW_4213, WeaponStyle.RANGE);
		StyleMap.put(ItemID.NEW_CRYSTAL_BOW_16888, WeaponStyle.RANGE);
		StyleMap.put(ItemID.NEW_CRYSTAL_BOW_I, WeaponStyle.RANGE);
		StyleMap.put(ItemID.NEW_CRYSTAL_BOW_I_16889, WeaponStyle.RANGE);
		StyleMap.put(ItemID.OAK_LONGBOW, WeaponStyle.RANGE);
		StyleMap.put(ItemID.OAK_SHORTBOW, WeaponStyle.RANGE);
		StyleMap.put(ItemID.OGRE_BOW, WeaponStyle.RANGE);
		StyleMap.put(ItemID.PHOENIX_CROSSBOW, WeaponStyle.RANGE);
		StyleMap.put(ItemID.RUNE_CROSSBOW, WeaponStyle.RANGE);
		StyleMap.put(ItemID.RUNE_CROSSBOW_OR, WeaponStyle.RANGE);
		StyleMap.put(ItemID.RUNE_CROSSBOW_23601, WeaponStyle.RANGE);
		StyleMap.put(ItemID.RUNE_DART, WeaponStyle.RANGE);
		StyleMap.put(ItemID.RUNE_DARTP, WeaponStyle.RANGE);
		StyleMap.put(ItemID.RUNE_DARTP_5634, WeaponStyle.RANGE);
		StyleMap.put(ItemID.RUNE_DARTP_5641, WeaponStyle.RANGE);
		StyleMap.put(ItemID.RUNE_KNIFE, WeaponStyle.RANGE);
		StyleMap.put(ItemID.RUNE_KNIFEP, WeaponStyle.RANGE);
		StyleMap.put(ItemID.RUNE_KNIFEP_5660, WeaponStyle.RANGE);
		StyleMap.put(ItemID.RUNE_KNIFEP_5667, WeaponStyle.RANGE);
		StyleMap.put(ItemID.RUNE_THROWNAXE, WeaponStyle.RANGE);
		StyleMap.put(ItemID.SAGES_AXE, WeaponStyle.RANGE);
		StyleMap.put(ItemID.SEERCULL, WeaponStyle.RANGE);
		StyleMap.put(ItemID.SHORTBOW, WeaponStyle.RANGE);
		StyleMap.put(ItemID.SIGNED_OAK_BOW, WeaponStyle.RANGE);
		StyleMap.put(ItemID.STARTER_BOW, WeaponStyle.RANGE);
		StyleMap.put(ItemID.STARTER_BOW_28555, WeaponStyle.RANGE);
		StyleMap.put(ItemID.STEEL_CROSSBOW, WeaponStyle.RANGE);
		StyleMap.put(ItemID.STEEL_DART, WeaponStyle.RANGE);
		StyleMap.put(ItemID.STEEL_DARTP, WeaponStyle.RANGE);
		StyleMap.put(ItemID.STEEL_DARTP_5630, WeaponStyle.RANGE);
		StyleMap.put(ItemID.STEEL_DARTP_5637, WeaponStyle.RANGE);
		StyleMap.put(ItemID.STEEL_KNIFE, WeaponStyle.RANGE);
		StyleMap.put(ItemID.STEEL_KNIFEP, WeaponStyle.RANGE);
		StyleMap.put(ItemID.STEEL_KNIFEP_5656, WeaponStyle.RANGE);
		StyleMap.put(ItemID.STEEL_KNIFEP_5663, WeaponStyle.RANGE);
		StyleMap.put(ItemID.STEEL_THROWNAXE, WeaponStyle.RANGE);
		StyleMap.put(ItemID.TONALZTICS_OF_RALOS, WeaponStyle.RANGE);
		StyleMap.put(ItemID.TOKTZXILUL, WeaponStyle.RANGE);
		StyleMap.put(ItemID.TOXIC_BLOWPIPE, WeaponStyle.RANGE);
		StyleMap.put(ItemID.TOXIC_BLOWPIPE_EMPTY, WeaponStyle.RANGE);
		StyleMap.put(ItemID.TRAINING_BOW, WeaponStyle.RANGE);
		StyleMap.put(ItemID.TWISTED_BOW, WeaponStyle.RANGE);
		StyleMap.put(ItemID.WEBWEAVER_BOW, WeaponStyle.RANGE);
		StyleMap.put(ItemID.WEBWEAVER_BOW_U, WeaponStyle.RANGE);
		StyleMap.put(ItemID.WILLOW_COMP_BOW, WeaponStyle.RANGE);
		StyleMap.put(ItemID.WILLOW_LONGBOW, WeaponStyle.RANGE);
		StyleMap.put(ItemID.WILLOW_SHORTBOW, WeaponStyle.RANGE);
		StyleMap.put(ItemID.YEW_COMP_BOW, WeaponStyle.RANGE);
		StyleMap.put(ItemID.YEW_LONGBOW, WeaponStyle.RANGE);
		StyleMap.put(ItemID.YEW_SHORTBOW, WeaponStyle.RANGE);
		StyleMap.put(ItemID.VENATOR_BOW, WeaponStyle.RANGE);
		StyleMap.put(ItemID.VENATOR_BOW_UNCHARGED, WeaponStyle.RANGE);
		StyleMap.put(ItemID.ZARYTE_BOW, WeaponStyle.RANGE);
		StyleMap.put(ItemID.ZARYTE_BOW_26239, WeaponStyle.RANGE);
		StyleMap.put(ItemID.ZARYTE_CROSSBOW, WeaponStyle.RANGE);
		StyleMap.put(ItemID.ZARYTE_CROSSBOW_27186, WeaponStyle.RANGE);

		//Chins
		StyleMap.put(ItemID.BLACK_CHINCHOMPA, WeaponStyle.CHINS);
		StyleMap.put(ItemID.CHINCHOMPA, WeaponStyle.CHINS);
		StyleMap.put(ItemID.CHINCHOMPA_10033, WeaponStyle.CHINS);
		StyleMap.put(ItemID.RED_CHINCHOMPA, WeaponStyle.CHINS);
		StyleMap.put(ItemID.RED_CHINCHOMPA_10034, WeaponStyle.CHINS);

		//Magic
		StyleMap.put(ItemID._3RD_AGE_WAND, WeaponStyle.MAGIC);
		StyleMap.put(ItemID.ACCURSED_SCEPTRE, WeaponStyle.TRIDENTS);
		StyleMap.put(ItemID.ACCURSED_SCEPTRE_U, WeaponStyle.TRIDENTS);
		StyleMap.put(ItemID.AHRIMS_STAFF, WeaponStyle.MAGIC);
		StyleMap.put(ItemID.AHRIMS_STAFF_0, WeaponStyle.MAGIC);
		StyleMap.put(ItemID.AHRIMS_STAFF_100, WeaponStyle.MAGIC);
		StyleMap.put(ItemID.AHRIMS_STAFF_25, WeaponStyle.MAGIC);
		StyleMap.put(ItemID.AHRIMS_STAFF_50, WeaponStyle.MAGIC);
		StyleMap.put(ItemID.AHRIMS_STAFF_75, WeaponStyle.MAGIC);
		StyleMap.put(ItemID.AHRIMS_STAFF_23653, WeaponStyle.MAGIC);
		StyleMap.put(ItemID.AIR_BATTLESTAFF, WeaponStyle.MAGIC);
		StyleMap.put(ItemID.ANCIENT_CROZIER, WeaponStyle.MAGIC);
		StyleMap.put(ItemID.ANCIENT_SCEPTRE, WeaponStyle.MAGIC);
		StyleMap.put(ItemID.ANCIENT_SCEPTRE_L, WeaponStyle.MAGIC);
		StyleMap.put(ItemID.BLOOD_ANCIENT_SCEPTRE, WeaponStyle.MAGIC);
		StyleMap.put(ItemID.BLOOD_ANCIENT_SCEPTRE_28260, WeaponStyle.MAGIC);
		StyleMap.put(ItemID.BLOOD_ANCIENT_SCEPTRE_L, WeaponStyle.MAGIC);
		StyleMap.put(ItemID.BLUE_MOON_SPEAR, WeaponStyle.MAGIC);
		StyleMap.put(ItemID.ICE_ANCIENT_SCEPTRE, WeaponStyle.MAGIC);
		StyleMap.put(ItemID.ICE_ANCIENT_SCEPTRE_28262, WeaponStyle.MAGIC);
		StyleMap.put(ItemID.ICE_ANCIENT_SCEPTRE_L, WeaponStyle.MAGIC);
		StyleMap.put(ItemID.SHADOW_ANCIENT_SCEPTRE, WeaponStyle.MAGIC);
		StyleMap.put(ItemID.SHADOW_ANCIENT_SCEPTRE_28266, WeaponStyle.MAGIC);
		StyleMap.put(ItemID.SHADOW_ANCIENT_SCEPTRE_L, WeaponStyle.MAGIC);
		StyleMap.put(ItemID.SMOKE_ANCIENT_SCEPTRE, WeaponStyle.MAGIC);
		StyleMap.put(ItemID.SMOKE_ANCIENT_SCEPTRE_28264, WeaponStyle.MAGIC);
		StyleMap.put(ItemID.SMOKE_ANCIENT_SCEPTRE_L, WeaponStyle.MAGIC);
		StyleMap.put(ItemID.ANCIENT_STAFF, WeaponStyle.MAGIC);
		StyleMap.put(ItemID.APPRENTICE_WAND, WeaponStyle.MAGIC);
		StyleMap.put(ItemID.ARMADYL_CROZIER, WeaponStyle.MAGIC);
		StyleMap.put(ItemID.BANDOS_CROZIER, WeaponStyle.MAGIC);
		StyleMap.put(ItemID.BATTLESTAFF, WeaponStyle.MAGIC);
		StyleMap.put(ItemID.BEGINNER_WAND, WeaponStyle.MAGIC);
		StyleMap.put(ItemID.BLISTERWOOD_FLAIL, WeaponStyle.MAGIC);
		StyleMap.put(ItemID.BROKEN_STAFF, WeaponStyle.MAGIC);
		StyleMap.put(ItemID.BRYOPHYTAS_STAFF, WeaponStyle.MAGIC);
		StyleMap.put(ItemID.BRYOPHYTAS_STAFF_UNCHARGED, WeaponStyle.MAGIC);
		StyleMap.put(ItemID.CORRUPTED_STAFF_ATTUNED, WeaponStyle.MAGIC);
		StyleMap.put(ItemID.CORRUPTED_STAFF_BASIC, WeaponStyle.MAGIC);
		StyleMap.put(ItemID.CORRUPTED_STAFF_PERFECTED, WeaponStyle.MAGIC);
		StyleMap.put(ItemID.CRYSTAL_STAFF_ATTUNED, WeaponStyle.MAGIC);
		StyleMap.put(ItemID.CRYSTAL_STAFF_BASIC, WeaponStyle.MAGIC);
		StyleMap.put(ItemID.CRYSTAL_STAFF_PERFECTED, WeaponStyle.MAGIC);
		StyleMap.put(ItemID.CURSED_GOBLIN_STAFF, WeaponStyle.MAGIC);
		StyleMap.put(ItemID.DAWNBRINGER, WeaponStyle.MAGIC);
		StyleMap.put(ItemID.DRAGON_HUNTER_WAND, WeaponStyle.MAGIC);
		StyleMap.put(ItemID.DRAMEN_STAFF, WeaponStyle.MAGIC);
		StyleMap.put(ItemID.DUST_BATTLESTAFF, WeaponStyle.MAGIC);
		StyleMap.put(ItemID.EARTH_BATTLESTAFF, WeaponStyle.MAGIC);
		StyleMap.put(ItemID.ELDRITCH_NIGHTMARE_STAFF, WeaponStyle.MAGIC);
		StyleMap.put(ItemID.FIRE_BATTLESTAFF, WeaponStyle.MAGIC);
		StyleMap.put(ItemID.GUTHIX_CROZIER, WeaponStyle.MAGIC);
		StyleMap.put(ItemID.GUTHIX_STAFF, WeaponStyle.MAGIC);
		StyleMap.put(ItemID.HARMONISED_NIGHTMARE_STAFF, WeaponStyle.MAGIC);
		StyleMap.put(ItemID.IBANS_STAFF, WeaponStyle.MAGIC);
		StyleMap.put(ItemID.IBANS_STAFF_1410, WeaponStyle.MAGIC);
		StyleMap.put(ItemID.IBANS_STAFF_U, WeaponStyle.MAGIC);
		StyleMap.put(ItemID.IVANDIS_FLAIL, WeaponStyle.MAGIC);
		StyleMap.put(ItemID.KODAI_WAND, WeaponStyle.MAGIC);
		StyleMap.put(ItemID.KODAI_WAND_23626, WeaponStyle.MAGIC);
		StyleMap.put(ItemID.LAVA_BATTLESTAFF, WeaponStyle.MAGIC);
		StyleMap.put(ItemID.LAVA_BATTLESTAFF_21198, WeaponStyle.MAGIC);
		StyleMap.put(ItemID.LUNAR_STAFF, WeaponStyle.MAGIC);
		StyleMap.put(ItemID.MAGIC_STAFF, WeaponStyle.MAGIC);
		StyleMap.put(ItemID.MASTER_WAND, WeaponStyle.MAGIC);
		StyleMap.put(ItemID.MASTER_WAND_20560, WeaponStyle.MAGIC);
		StyleMap.put(ItemID.MIST_BATTLESTAFF, WeaponStyle.MAGIC);
		StyleMap.put(ItemID.MUD_BATTLESTAFF, WeaponStyle.MAGIC);
		StyleMap.put(ItemID.MYSTIC_AIR_STAFF, WeaponStyle.MAGIC);
		StyleMap.put(ItemID.MYSTIC_DUST_STAFF, WeaponStyle.MAGIC);
		StyleMap.put(ItemID.MYSTIC_EARTH_STAFF, WeaponStyle.MAGIC);
		StyleMap.put(ItemID.MYSTIC_FIRE_STAFF, WeaponStyle.MAGIC);
		StyleMap.put(ItemID.MYSTIC_LAVA_STAFF, WeaponStyle.MAGIC);
		StyleMap.put(ItemID.MYSTIC_LAVA_STAFF_21200, WeaponStyle.MAGIC);
		StyleMap.put(ItemID.MYSTIC_MIST_STAFF, WeaponStyle.MAGIC);
		StyleMap.put(ItemID.MYSTIC_MUD_STAFF, WeaponStyle.MAGIC);
		StyleMap.put(ItemID.MYSTIC_SMOKE_STAFF, WeaponStyle.MAGIC);
		StyleMap.put(ItemID.MYSTIC_STEAM_STAFF, WeaponStyle.MAGIC);
		StyleMap.put(ItemID.MYSTIC_STEAM_STAFF_12796, WeaponStyle.MAGIC);
		StyleMap.put(ItemID.MYSTIC_WATER_STAFF, WeaponStyle.MAGIC);
		StyleMap.put(ItemID.NIGHTMARE_STAFF, WeaponStyle.MAGIC);
		StyleMap.put(ItemID.PHARAOHS_SCEPTRE, WeaponStyle.MAGIC);
		StyleMap.put(ItemID.PHARAOHS_SCEPTRE_9045, WeaponStyle.MAGIC);
		StyleMap.put(ItemID.PHARAOHS_SCEPTRE_9046, WeaponStyle.MAGIC);
		StyleMap.put(ItemID.PHARAOHS_SCEPTRE_9047, WeaponStyle.MAGIC);
		StyleMap.put(ItemID.PHARAOHS_SCEPTRE_9048, WeaponStyle.MAGIC);
		StyleMap.put(ItemID.PHARAOHS_SCEPTRE_9049, WeaponStyle.MAGIC);
		StyleMap.put(ItemID.PHARAOHS_SCEPTRE_9050, WeaponStyle.MAGIC);
		StyleMap.put(ItemID.PHARAOHS_SCEPTRE_9051, WeaponStyle.MAGIC);
		StyleMap.put(ItemID.PHARAOHS_SCEPTRE_13074, WeaponStyle.MAGIC);
		StyleMap.put(ItemID.PHARAOHS_SCEPTRE_13075, WeaponStyle.MAGIC);
		StyleMap.put(ItemID.PHARAOHS_SCEPTRE_13077, WeaponStyle.MAGIC);
		StyleMap.put(ItemID.PHARAOHS_SCEPTRE_13078, WeaponStyle.MAGIC);
		StyleMap.put(ItemID.PHARAOHS_SCEPTRE_16176, WeaponStyle.MAGIC);
		StyleMap.put(ItemID.PHARAOHS_SCEPTRE_21445, WeaponStyle.MAGIC);
		StyleMap.put(ItemID.PHARAOHS_SCEPTRE_21446, WeaponStyle.MAGIC);
		StyleMap.put(ItemID.PHARAOHS_SCEPTRE_26948, WeaponStyle.MAGIC);
		StyleMap.put(ItemID.PHARAOHS_SCEPTRE_26950, WeaponStyle.MAGIC);
		StyleMap.put(ItemID.ROD_OF_IVANDIS_1, WeaponStyle.MAGIC);
		StyleMap.put(ItemID.ROD_OF_IVANDIS_10, WeaponStyle.MAGIC);
		StyleMap.put(ItemID.ROD_OF_IVANDIS_2, WeaponStyle.MAGIC);
		StyleMap.put(ItemID.ROD_OF_IVANDIS_3, WeaponStyle.MAGIC);
		StyleMap.put(ItemID.ROD_OF_IVANDIS_4, WeaponStyle.MAGIC);
		StyleMap.put(ItemID.ROD_OF_IVANDIS_5, WeaponStyle.MAGIC);
		StyleMap.put(ItemID.ROD_OF_IVANDIS_6, WeaponStyle.MAGIC);
		StyleMap.put(ItemID.ROD_OF_IVANDIS_7, WeaponStyle.MAGIC);
		StyleMap.put(ItemID.ROD_OF_IVANDIS_8, WeaponStyle.MAGIC);
		StyleMap.put(ItemID.ROD_OF_IVANDIS_9, WeaponStyle.MAGIC);
		StyleMap.put(ItemID.SARADOMIN_CROZIER, WeaponStyle.MAGIC);
		StyleMap.put(ItemID.SARADOMIN_STAFF, WeaponStyle.MAGIC);
		StyleMap.put(ItemID.SKULL_SCEPTRE, WeaponStyle.MAGIC);
		StyleMap.put(ItemID.SKULL_SCEPTRE_I, WeaponStyle.MAGIC);
		StyleMap.put(ItemID.SLAYERS_STAFF, WeaponStyle.MAGIC);
		StyleMap.put(ItemID.SLAYERS_STAFF_E, WeaponStyle.MAGIC);
		StyleMap.put(ItemID.SMOKE_BATTLESTAFF, WeaponStyle.MAGIC);
		StyleMap.put(ItemID.STAFF, WeaponStyle.MAGIC);
		StyleMap.put(ItemID.STAFF_OF_AIR, WeaponStyle.MAGIC);
		StyleMap.put(ItemID.STAFF_OF_BALANCE, WeaponStyle.MAGIC);
		StyleMap.put(ItemID.STAFF_OF_BOB_THE_CAT, WeaponStyle.MAGIC);
		StyleMap.put(ItemID.STAFF_OF_EARTH, WeaponStyle.MAGIC);
		StyleMap.put(ItemID.STAFF_OF_FIRE, WeaponStyle.MAGIC);
		StyleMap.put(ItemID.STAFF_OF_LIGHT, WeaponStyle.MAGIC);
		StyleMap.put(ItemID.STAFF_OF_THE_DEAD, WeaponStyle.MAGIC);
		StyleMap.put(ItemID.STAFF_OF_THE_DEAD_23613, WeaponStyle.MAGIC);
		StyleMap.put(ItemID.STAFF_OF_WATER, WeaponStyle.MAGIC);
		StyleMap.put(ItemID.STEAM_BATTLESTAFF, WeaponStyle.MAGIC);
		StyleMap.put(ItemID.STEAM_BATTLESTAFF_12795, WeaponStyle.MAGIC);
		StyleMap.put(ItemID.TEACHER_WAND, WeaponStyle.MAGIC);
		StyleMap.put(ItemID.THAMMARONS_SCEPTRE, WeaponStyle.MAGIC);
		StyleMap.put(ItemID.THAMMARONS_SCEPTRE_U, WeaponStyle.MAGIC);
		StyleMap.put(ItemID.TOKTZMEJTAL, WeaponStyle.MAGIC);
		StyleMap.put(ItemID.TOXIC_STAFF_OF_THE_DEAD, WeaponStyle.MAGIC);
		StyleMap.put(ItemID.TOXIC_STAFF_UNCHARGED, WeaponStyle.MAGIC);
		StyleMap.put(ItemID.VOID_KNIGHT_MACE, WeaponStyle.MAGIC);
		StyleMap.put(ItemID.VOID_KNIGHT_MACE_BROKEN, WeaponStyle.MAGIC);
		StyleMap.put(ItemID.VOLATILE_NIGHTMARE_STAFF, WeaponStyle.MAGIC);
		StyleMap.put(ItemID.VOLATILE_NIGHTMARE_STAFF_25517, WeaponStyle.MAGIC);
		StyleMap.put(ItemID.WAND, WeaponStyle.MAGIC);
		StyleMap.put(ItemID.WATER_BATTLESTAFF, WeaponStyle.MAGIC);
		StyleMap.put(ItemID.WHITE_MAGIC_STAFF, WeaponStyle.MAGIC);
		StyleMap.put(ItemID.ZAMORAK_CROZIER, WeaponStyle.MAGIC);
		StyleMap.put(ItemID.ZAMORAK_STAFF, WeaponStyle.MAGIC);
		StyleMap.put(ItemID.ZURIELS_STAFF, WeaponStyle.MAGIC);
		StyleMap.put(ItemID.ZURIELS_STAFF_23617, WeaponStyle.MAGIC);
		StyleMap.put(ItemID.ZURIELS_STAFF_BH, WeaponStyle.MAGIC);
		StyleMap.put(ItemID.ZURIELS_STAFF_BHINACTIVE, WeaponStyle.MAGIC);
		//why?
		StyleMap.put(ItemID.GNOMEBALL, WeaponStyle.MAGIC);

		//Tridents
		StyleMap.put(ItemID.ACCURSED_SCEPTRE_A, WeaponStyle.TRIDENTS);
		StyleMap.put(ItemID.ACCURSED_SCEPTRE_AU, WeaponStyle.TRIDENTS);
		StyleMap.put(ItemID.CORRUPTED_TUMEKENS_SHADOW, WeaponStyle.TRIDENTS);
		StyleMap.put(ItemID.CORRUPTED_TUMEKENS_SHADOW_UNCHARGED, WeaponStyle.TRIDENTS);
		StyleMap.put(ItemID.HOLY_SANGUINESTI_STAFF, WeaponStyle.TRIDENTS);
		StyleMap.put(ItemID.HOLY_SANGUINESTI_STAFF_UNCHARGED, WeaponStyle.TRIDENTS);
		StyleMap.put(ItemID.SANGUINESTI_STAFF, WeaponStyle.TRIDENTS);
		StyleMap.put(ItemID.SANGUINESTI_STAFF_UNCHARGED, WeaponStyle.TRIDENTS);
		StyleMap.put(ItemID.STARTER_STAFF, WeaponStyle.TRIDENTS);
		StyleMap.put(ItemID.STARTER_STAFF_28557, WeaponStyle.TRIDENTS);
		StyleMap.put(ItemID.THAMMARONS_SCEPTRE_A, WeaponStyle.TRIDENTS);
		StyleMap.put(ItemID.THAMMARONS_SCEPTRE_AU, WeaponStyle.TRIDENTS);
		StyleMap.put(ItemID.TRIDENT_OF_THE_SEAS, WeaponStyle.TRIDENTS);
		StyleMap.put(ItemID.TRIDENT_OF_THE_SEAS_E, WeaponStyle.TRIDENTS);
		StyleMap.put(ItemID.TRIDENT_OF_THE_SEAS_FULL, WeaponStyle.TRIDENTS);
		StyleMap.put(ItemID.TRIDENT_OF_THE_SWAMP, WeaponStyle.TRIDENTS);
		StyleMap.put(ItemID.TRIDENT_OF_THE_SWAMP_E, WeaponStyle.TRIDENTS);
		StyleMap.put(ItemID.TUMEKENS_SHADOW, WeaponStyle.TRIDENTS);
		StyleMap.put(ItemID.TUMEKENS_SHADOW_UNCHARGED, WeaponStyle.TRIDENTS);
		StyleMap.put(ItemID.UNCHARGED_TOXIC_TRIDENT, WeaponStyle.TRIDENTS);
		StyleMap.put(ItemID.UNCHARGED_TOXIC_TRIDENT_E, WeaponStyle.TRIDENTS);
		StyleMap.put(ItemID.UNCHARGED_TRIDENT, WeaponStyle.TRIDENTS);
		StyleMap.put(ItemID.UNCHARGED_TRIDENT_E, WeaponStyle.TRIDENTS);
		StyleMap.put(ItemID.WARPED_SCEPTRE, WeaponStyle.TRIDENTS);
		StyleMap.put(ItemID.WARPED_SCEPTRE_UNCHARGED, WeaponStyle.TRIDENTS);
	}
}

/*
 * Copyright (c) 2017, honeyhoney <https://github.com/honeyhoney>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.tzhaarhptracker.attackstyles;

import com.google.common.collect.ImmutableMap;
import lombok.Getter;

import java.util.Map;

import static com.tzhaarhptracker.attackstyles.AttackStyle.*;

public enum WeaponType
{
	TYPE_0(ACCURATE, AGGRESSIVE, null, DEFENSIVE),
	TYPE_1(ACCURATE, AGGRESSIVE, AGGRESSIVE, DEFENSIVE),
	TYPE_2(ACCURATE, AGGRESSIVE, null, DEFENSIVE),
	TYPE_3(RANGING, RANGING, null, LONGRANGE),
	TYPE_4(ACCURATE, AGGRESSIVE, CONTROLLED, DEFENSIVE),
	TYPE_5(RANGING, RANGING, null, LONGRANGE),
	TYPE_6(AGGRESSIVE, RANGING, CASTING, null),
	TYPE_7(RANGING, RANGING, null, LONGRANGE),
	TYPE_8(OTHER, AGGRESSIVE, null, null),
	TYPE_9(ACCURATE, AGGRESSIVE, CONTROLLED, DEFENSIVE),
	TYPE_10(ACCURATE, AGGRESSIVE, AGGRESSIVE, DEFENSIVE),
	TYPE_11(ACCURATE, AGGRESSIVE, AGGRESSIVE, DEFENSIVE),
	TYPE_12(CONTROLLED, AGGRESSIVE, null, DEFENSIVE),
	TYPE_13(ACCURATE, AGGRESSIVE, null, DEFENSIVE),
	TYPE_14(ACCURATE, AGGRESSIVE, AGGRESSIVE, DEFENSIVE),
	TYPE_15(CONTROLLED, CONTROLLED, CONTROLLED, DEFENSIVE),
	TYPE_16(ACCURATE, AGGRESSIVE, CONTROLLED, DEFENSIVE),
	TYPE_17(ACCURATE, AGGRESSIVE, AGGRESSIVE, DEFENSIVE),
	TYPE_18(ACCURATE, AGGRESSIVE, null, DEFENSIVE, CASTING, DEFENSIVE_CASTING),
	TYPE_19(RANGING, RANGING, null, LONGRANGE),
	TYPE_20(ACCURATE, CONTROLLED, null, DEFENSIVE),
	TYPE_21(ACCURATE, AGGRESSIVE, null, DEFENSIVE, CASTING, DEFENSIVE_CASTING),
	TYPE_22(ACCURATE, AGGRESSIVE, AGGRESSIVE, DEFENSIVE),
	TYPE_23(CASTING, CASTING, null, DEFENSIVE_CASTING),
	TYPE_24(ACCURATE, AGGRESSIVE, CONTROLLED, DEFENSIVE),
	TYPE_25(CONTROLLED, AGGRESSIVE, null, DEFENSIVE),
	TYPE_26(AGGRESSIVE, AGGRESSIVE, null, AGGRESSIVE),
	TYPE_27(ACCURATE, null, null, OTHER),
	TYPE_28(ACCURATE, ACCURATE, null, LONGRANGE),
	TYPE_29(ACCURATE, AGGRESSIVE, AGGRESSIVE, DEFENSIVE);

	@Getter
	private final AttackStyle[] attackStyles;

	private static final Map<Integer, WeaponType> weaponTypes;

	static
	{
		ImmutableMap.Builder<Integer, WeaponType> builder = new ImmutableMap.Builder<>();

		for (WeaponType weaponType : values())
		{
			builder.put(weaponType.ordinal(), weaponType);
		}

		weaponTypes = builder.build();
	}

	WeaponType(AttackStyle... attackStyles)
	{
		this.attackStyles = attackStyles;
	}

	public static WeaponType getWeaponType(int id)
	{
		return weaponTypes.get(id);
	}
}

package com.tzhaarhptracker.attackstyles;

public enum WeaponStyle
{
	MAGIC, RANGE, MELEE, CHINS, TRIDENTS, SCYTHES
}

/*
 * Copyright (c) 2023, Buchus <http://github.com/MoreBuchus>
 * Copyright (c) 2023, geheur <http://github.com/geheur>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.tzhaarhptracker;

import java.awt.*;
import java.util.Collection;
import javax.inject.Inject;
import net.runelite.api.*;
import net.runelite.api.Point;
import net.runelite.client.ui.overlay.Overlay;
import net.runelite.client.ui.overlay.OverlayLayer;
import net.runelite.client.ui.overlay.OverlayPosition;
import net.runelite.client.ui.overlay.OverlayPriority;
import net.runelite.client.ui.overlay.outline.ModelOutlineRenderer;

public class ReminderOverlay extends Overlay
{
	private final TzhaarHPTrackerPlugin plugin;
	private final TzhaarHPTrackerConfig config;
	private final Client client;
	private final ModelOutlineRenderer modelOutlineRenderer;

	@Inject
	private ReminderOverlay(TzhaarHPTrackerPlugin plugin, TzhaarHPTrackerConfig config, Client client, ModelOutlineRenderer modelOutlineRenderer)
	{
		this.plugin = plugin;
		this.config = config;
		this.client = client;
		this.modelOutlineRenderer = modelOutlineRenderer;
		setPosition(OverlayPosition.DYNAMIC);
		setPriority(OverlayPriority.HIGHEST);
		setLayer(OverlayLayer.UNDER_WIDGETS);
	}

	@Override
	public Dimension render(Graphics2D graphics)
	{
		if (plugin.isInAllowedBanks() && config.spellbookWarning() != TzhaarHPTrackerConfig.spellbookWarningMode.OFF)
		{
			if (config.spellbookWarning() == TzhaarHPTrackerConfig.spellbookWarningMode.OVERLAY || config.spellbookWarning() == TzhaarHPTrackerConfig.spellbookWarningMode.BOTH)
			{
				Collection<GameObject> gameObjects = plugin.getCaveEntrances();
				for (GameObject obj : gameObjects)
				{
					Color color = null;
					if ((!config.spellbookCheck().contains(TzhaarHPTrackerConfig.spellbook.NORMAL) && plugin.getSpellbookType().equals("NORMAL"))
						|| (!config.spellbookCheck().contains(TzhaarHPTrackerConfig.spellbook.ANCIENT) && plugin.getSpellbookType().equals("ANCIENT"))
						|| (!config.spellbookCheck().contains(TzhaarHPTrackerConfig.spellbook.LUNAR) && plugin.getSpellbookType().equals("LUNAR"))
						|| (!config.spellbookCheck().contains(TzhaarHPTrackerConfig.spellbook.ARCEUUS) && plugin.getSpellbookType().equals("ARCEUUS")))
					{
						color = config.spellbookColor();
					}

					Shape clickbox = obj.getClickbox();
					if (color != null && clickbox != null)
					{
						Point mousePos = client.getMouseCanvasPosition();
						if (mousePos != null && clickbox.contains(mousePos.getX(), mousePos.getY()))
						{
							color = color.darker();
						}
						graphics.setColor(color);
						graphics.fill(clickbox);
						graphics.setColor(new Color(color.getRed(), color.getGreen(), color.getBlue()));
						graphics.draw(clickbox);
					}
				}
			}
		}
		return null;
	}
}
/*
 * Copyright (c) 2023, Buchus <http://github.com/MoreBuchus>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.tzhaarhptracker;

import com.google.common.annotations.VisibleForTesting;
import com.google.common.collect.ImmutableSet;
import com.google.inject.Provides;
import com.tzhaarhptracker.info.TzhaarHP;
import java.awt.*;
import java.util.*;
import java.util.regex.Pattern;
import java.util.stream.Collectors;
import javax.inject.Inject;
import lombok.Getter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.*;
import net.runelite.api.events.*;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.callback.Hooks;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.eventbus.EventBus;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.events.ConfigChanged;
import net.runelite.client.game.NPCManager;
import net.runelite.client.game.NpcUtil;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.plugins.PluginDescriptor;
import com.tzhaarhptracker.info.DamageHandler;
import net.runelite.client.ui.FontManager;
import net.runelite.client.ui.overlay.OverlayManager;
import net.runelite.client.util.ColorUtil;
import net.runelite.client.util.Text;
import org.apache.commons.lang3.ArrayUtils;

@Slf4j
@PluginDescriptor(
	name = "Tzhaar HP Tracker",
	description = "Marks Tzhaar NPCs and shows their current HP remaining",
	tags = {"inferno", "fight", "cave", "tzhaar", "jad", "zuk", "hp", "tracking", "dead", "npc", "indicator"}
)
public class TzhaarHPTrackerPlugin extends Plugin
{
	@Inject
	private Client client;

	@Inject
	private OverlayManager overlayManager;

	@Inject
	private TzhaarHPTrackerConfig config;

	@Inject
	private NPCManager npcManager;

	@Inject
	private TzhaarHPTrackerOverlay overlay;

	@Inject
	private ReminderOverlay reminderOverlay;

	@Inject
	private ClientThread clientThread;

	@Inject
	private NpcUtil npcUtil;

	@Inject
	private Hooks hooks;

	@Inject
	private DamageHandler handleDamage;

	@Getter
	private InfoHandler[] infoHandlers = null;

	@Inject
	private EventBus eventBus;

	private static final Set<MenuAction> NPC_MENU_ACTIONS = ImmutableSet.of(
		MenuAction.NPC_FIRST_OPTION, MenuAction.NPC_SECOND_OPTION, MenuAction.NPC_THIRD_OPTION, MenuAction.NPC_FOURTH_OPTION,
		MenuAction.NPC_FIFTH_OPTION, MenuAction.WIDGET_TARGET_ON_NPC, MenuAction.ITEM_USE_ON_NPC
	);

	@Getter
	private final ArrayList<TzhaarNPC> npcs = new ArrayList<>();

	@Getter
	private final ArrayList<TzhaarNPC> hiddenNPCs = new ArrayList<>();

	@Getter
	private static final Set<String> FIGHT_CAVE_NPC = ImmutableSet.of(
		"tz-kih", "tz-kek", "tok-xil", "yt-mejkot", "ket-zek", "yt-hurkot", "tztok-jad"
	);

	@Getter
	private static final Set<String> INFERNO_NPC = ImmutableSet.of(
		"jal-nib", "jal-mejrah", "jal-ak", "jal-akrek-xil", "jal-akrek-mej", "jal-akrek-ket", "jal-imkot", "jal-xil", "jal-zek",
		"jaltok-jad", "yt-hurkot", "tzkal-zuk", "jal-mejjak", "<col=00ffff>rocky support</col>"
	);

	@Getter
	private static final Set<String> EXCLUDED_NPC = ImmutableSet.of(
		"yt-hurkot", "tztok-jad", "jaltok-jad", "jal-mejjak", "tzkal-zuk"
	);

	@Getter
	private static final Set<String> REVIVABLE_NPC = ImmutableSet.of(
		"jal-mejrah", "jal-ak", "jal-imkot", "jal-xil", "jal-zek"
	);

	private static final int FIGHT_CAVES_REGION = 9551;
	private static final int INFERNO_REGION = 9043;
	private static final int JAD_CHALLENGE_VAR = 11878; // 0 = out, 1 = in

	@Getter
	private String spellbookType = "";

	private boolean waveStarted = false;
	private int waveStartTick = -1;
	@Getter
	private final Map<String, Integer> currentWave = new HashMap<>();

	private static final Pattern WAVE_START_PATTERN = Pattern.compile(".*Wave: (\\d+).*");
	private static final String TZHAAR_WAVE_COMPLETE = "Wave completed!";
	private static final String ZUK_KC_MESSAGE = "Your TzKal-Zuk kill count is:";
	private static final String JAD_KC_MESSAGE = "Your TzTok-Jad kill count is:";
	private static final String DEATH_MESSAGE = "You have been defeated!";

	@Getter
	Font font;

	private long lastTickNS = 0;
	@Getter
	private int lastTickDurMS = 0;

	private final Hooks.RenderableDrawListener drawListener = this::shouldDraw;

	@Provides
	TzhaarHPTrackerConfig provideConfig(ConfigManager configManager)
	{
		return configManager.getConfig(TzhaarHPTrackerConfig.class);
	}

	protected void startUp() throws Exception
	{
		npcs.clear();
		hiddenNPCs.clear();
		currentWave.clear();
		loadFont();
		overlayManager.add(overlay);
		overlayManager.add(reminderOverlay);
		hooks.registerRenderableDrawListener(drawListener);

		if (infoHandlers == null)
		{
			infoHandlers = new InfoHandler[]{handleDamage};

			for (InfoHandler info : infoHandlers)
			{
				info.init();
			}
		}

		for (InfoHandler info : infoHandlers)
		{
			info.load();
			eventBus.register(info);
		}

		if (client.getGameState() == GameState.LOGGED_IN && isInAllowedCaves() && npcs.isEmpty())
		{
			for (NPC npc : client.getNpcs())
			{
				if (npc.getName() != null && (INFERNO_NPC.contains(npc.getName()) || FIGHT_CAVE_NPC.contains(npc.getName())))
				{
					try
					{
						if (TzhaarHP.getNPC(npc.getId()) != null)
						{
							int hp = TzhaarHP.getMaxHP(npc.getId()) != 0 ? TzhaarHP.getMaxHP(npc.getId()) : npcManager.getHealth(npc.getId());
							if (hp != 0)
							{
								TzhaarNPC newNPC = new TzhaarNPC(npc, hp, hp, client.getTickCount());
								//Set healed to true -> use ratio + scale to estimate NPCs HP who spawned before plugin startup
								newNPC.setHealed(true);
								npcs.add(newNPC);
							}
						}
					}
					catch (NullPointerException ignored)
					{
					}
				}
			}
		}
	}

	protected void shutDown() throws Exception
	{
		npcs.clear();
		hiddenNPCs.clear();
		currentWave.clear();
		overlayManager.remove(overlay);
		overlayManager.remove(reminderOverlay);
		hooks.unregisterRenderableDrawListener(drawListener);

		for (InfoHandler info : infoHandlers)
		{
			eventBus.unregister(info);
			info.unload();
		}
	}

	@Subscribe
	public void onNpcSpawned(NpcSpawned e)
	{
		if (isInAllowedCaves())
		{
			NPC npc = e.getNpc();
			int tick = client.getTickCount();

			if (npc.getName() != null && (INFERNO_NPC.contains(npc.getName().toLowerCase()) || FIGHT_CAVE_NPC.contains(npc.getName().toLowerCase())))
			{
				try
				{
					if (TzhaarHP.getNPC(npc.getId()) != null)
					{
						int hp = TzhaarHP.getMaxHP(npc.getId()) != 0 ? TzhaarHP.getMaxHP(npc.getId()) : npcManager.getHealth(npc.getId());
						if (hp != 0)
						{
							int currentHp = hp;
							//Do not get half HP for Zuk sets
							if (isInInferno() && waveStarted && waveStartTick != -1 && tick > waveStartTick && REVIVABLE_NPC.contains(npc.getName().toLowerCase())
								&& currentWave.containsKey("inferno") && currentWave.get("inferno") != 69)
							{
								currentHp = TzhaarHP.getRespawnedHP(npc.getId()) != 0 ? TzhaarHP.getRespawnedHP(npc.getId()) : (int) Math.ceil((double) hp / 2);
							}
							npcs.add(new TzhaarNPC(npc, currentHp, hp, tick));
						}
					}
				}
				catch (NullPointerException ignored)
				{
				}
			}
		}
	}

	@Subscribe
	public void onNpcDespawned(NpcDespawned e)
	{
		npcs.removeIf(n -> n.getNpc().getIndex() == e.getNpc().getIndex());
		hiddenNPCs.removeIf(h -> h.getNpc().getIndex() == e.getNpc().getIndex());
	}

	@Subscribe
	public void onChatMessage(ChatMessage e)
	{
		if (e.getType() == ChatMessageType.GAMEMESSAGE && isInAllowedCaves())
		{
			final String message = Text.removeTags(e.getMessage());
			if (WAVE_START_PATTERN.matcher(message).matches())
			{
				String cave = isInInferno() ? "inferno" : "fc";
				String wave = message.split(": ")[1];
				currentWave.put(cave, Integer.parseInt(wave));

				waveStarted = true;
				waveStartTick = client.getTickCount();
			}
			else if (TZHAAR_WAVE_COMPLETE.equals(message))
			{
				waveStarted = false;
				waveStartTick = -1;
			}
			else if (message.startsWith(JAD_KC_MESSAGE) || message.startsWith(ZUK_KC_MESSAGE) || message.equals(DEATH_MESSAGE))
			{
				waveStarted = false;
				waveStartTick = -1;
				currentWave.clear();
			}
		}
	}

	@Subscribe
	public void onMenuEntryAdded(MenuEntryAdded e)
	{
		final MenuEntry menuEntry = e.getMenuEntry();
		String option = Text.removeTags(e.getOption()).toLowerCase();
		String target = Text.removeTags(e.getTarget()).toLowerCase();

		if (config.recolorMenu() && isInAllowedCaves())
		{
			NPC npc = client.getCachedNPCs()[e.getIdentifier()];
			for (TzhaarNPC n : npcs)
			{
				if (npc != null && npc.getName() != null && n.getNpc() == npc && !EXCLUDED_NPC.contains(npc.getName().toLowerCase()))
				{
					Color color = null;
					if (npcUtil.isDying(n.getNpc()) || n.isDead())
					{
						color = config.highlightDeadColor();
					}

					if (color == null && (!npcUtil.isDying(npc) || !n.isDead()))
					{
						color = config.highlightAliveColor();
					}

					if (config.dynamicColor() != TzhaarHPTrackerConfig.DynamicColor.OFF)
					{
						color = getDynamicColor(n, true);
					}

					if (color != null)
					{
						final String tzhaar = ColorUtil.prependColorTag(Text.removeTags(e.getTarget()), color);
						menuEntry.setTarget(tzhaar);
					}
				}
			}
		}

		if (isInAllowedBanks() && (config.spellbookWarning() == TzhaarHPTrackerConfig.spellbookWarningMode.REMOVE
			|| config.spellbookWarning() == TzhaarHPTrackerConfig.spellbookWarningMode.BOTH))
		{
			if ((option.contains("jump-in") && target.contains("the inferno")) || (option.contains("enter") && target.contains("cave entrance")))
			{
				if (!config.spellbookCheck().contains(TzhaarHPTrackerConfig.spellbook.NORMAL) && spellbookType.equals("NORMAL"))
				{
					client.setMenuEntries(Arrays.copyOf(client.getMenuEntries(), client.getMenuEntries().length - 1));
				}
				else if (!config.spellbookCheck().contains(TzhaarHPTrackerConfig.spellbook.ANCIENT) && spellbookType.equals("ANCIENT"))
				{
					client.setMenuEntries(Arrays.copyOf(client.getMenuEntries(), client.getMenuEntries().length - 1));
				}
				else if (!config.spellbookCheck().contains(TzhaarHPTrackerConfig.spellbook.LUNAR) && spellbookType.equals("LUNAR"))
				{
					client.setMenuEntries(Arrays.copyOf(client.getMenuEntries(), client.getMenuEntries().length - 1));
				}
				else if (!config.spellbookCheck().contains(TzhaarHPTrackerConfig.spellbook.ARCEUUS) && spellbookType.equals("ARCEUUS"))
				{
					client.setMenuEntries(Arrays.copyOf(client.getMenuEntries(), client.getMenuEntries().length - 1));
				}
			}
		}
	}

	@Subscribe
	public void onGameStateChanged(GameStateChanged e)
	{
		if (e.getGameState() != GameState.LOGGED_IN && e.getGameState() != GameState.LOADING)
		{
			npcs.clear();
			hiddenNPCs.clear();
		}
		else
		{
			if (!isInAllowedCaves())
			{
				if (!currentWave.isEmpty())
				{
					currentWave.clear();
				}

				if (!npcs.isEmpty())
				{
					npcs.clear();
				}

				if (!hiddenNPCs.isEmpty())
				{
					hiddenNPCs.clear();
				}
			}
		}
	}

	@Subscribe
	private void onConfigChanged(ConfigChanged e)
	{
		if (e.getGroup().equals(config.GROUP))
		{
			switch (e.getKey())
			{
				case "overlayFontType":
				case "overlayFontName":
				case "overlayFontSize":
				case "overlayFontWeight":
					loadFont();
					break;
			}
		}
	}

	public Color getDynamicColor(TzhaarNPC n, boolean line)
	{
		if (n.getHp() <= 0)
		{
			return line ? config.highlightDeadColor() : config.fillDeadColor();
		}

		double healthRatio = Math.min(1.0, (double) n.getHp() / n.getMaxHp());
		return ColorUtil.colorLerp(line ? config.highlightDeadColor() : config.fillDeadColor(), line ? config.highlightAliveColor() : config.fillAliveColor(), healthRatio);
	}

	public void loadFont()
	{
		switch (config.overlayFontType())
		{
			case SMALL:
				font = FontManager.getRunescapeSmallFont();
				break;
			case REGULAR:
				font = FontManager.getRunescapeFont();
				break;
			case BOLD:
				font = FontManager.getRunescapeBoldFont();
				break;
			case CUSTOM:
				if (!config.overlayFontName().equals(""))
				{
					font = new Font(config.overlayFontName(), config.overlayFontWeight().getWeight(), config.overlayFontSize());
				}
				break;
		}
	}

	public Collection<GameObject> getCaveEntrances()
	{
		Collection<GameObject> objects = new ArrayList<>();
		Tile[][] tiles = client.getScene().getTiles()[client.getPlane()];
		for (Tile[] tile : tiles)
		{
			for (Tile t : tile)
			{
				if (t != null)
				{
					GameObject[] gameObjects = t.getGameObjects();
					if (gameObjects != null)
					{
						objects.addAll(Arrays.stream(gameObjects).filter(o -> o != null && (o.getId() == 11833 || o.getId() == 30352)
							&& o.getWorldLocation().distanceTo(client.getLocalPlayer().getWorldLocation()) <= 30 && !objects.contains(o)).collect(Collectors.toList()));
					}
				}
			}
		}
		return objects;
	}

	@Subscribe
	public void onGameTick(GameTick e)
	{
		if (isInAllowedCaves())
		{
			long time = System.nanoTime();
			lastTickDurMS = (int) ((time - lastTickNS) / 1000000L);
			lastTickNS = time;

			//Clear Hidden NPCs if lag spike over the set amount
			if (lastTickDurMS >= config.lagProtection())
			{
				hiddenNPCs.clear();
			}
		}

		if (isInAllowedBanks())
		{
			int spellbook = client.getVarbitValue(4070);
			if (spellbook == 0)
			{
				spellbookType = "NORMAL";
			}
			else if (spellbook == 1 && !spellbookType.equals("ANCIENT"))
			{
				spellbookType = "ANCIENT";
			}
			else if (spellbook == 2 && !spellbookType.equals("LUNAR"))
			{
				spellbookType = "LUNAR";
			}
			else if (spellbook == 3 && !spellbookType.equals("ARCEUUS"))
			{
				spellbookType = "ARCEUUS";
			}
		}
	}

	@VisibleForTesting
	boolean shouldDraw(Renderable renderable, boolean drawingUI)
	{
		if (config.hideDead())
		{
			if (renderable instanceof NPC)
			{
				//Excluded NPCs should not be hidden -> too much HP + healing
				return hiddenNPCs.stream().noneMatch(n -> n.getNpc().getIndex() == ((NPC) renderable).getIndex() && n.isDead()
					&& !EXCLUDED_NPC.contains(Objects.requireNonNull(n.getNpc().getName()).toLowerCase()));
			}
		}
		return true;
	}

	public boolean isInAllowedCaves()
	{
		return isInFightCaves() || isInInferno();
	}

	public boolean isInFightCaves()
	{
		return ArrayUtils.contains(client.getMapRegions(), FIGHT_CAVES_REGION);
	}

	public boolean isInInferno()
	{
		return ArrayUtils.contains(client.getMapRegions(), INFERNO_REGION);
	}

	//10063-10065 is inferno bank region
	//9808 is fight caves bank area, 9552 is fight pits area
	public boolean isInAllowedBanks()
	{
		return client.getMapRegions() != null && client.getMapRegions().length > 0 && Arrays.stream(client.getMapRegions()).anyMatch(new ArrayList<>
			(Arrays.asList(9808, 9552, 10063, 10064, 10065))::contains);
	}

	public boolean isInJadChallenge()
	{
		return ArrayUtils.contains(client.getMapRegions(), INFERNO_REGION) && client.getVarbitValue(JAD_CHALLENGE_VAR) == 1;
	}
}

/*
 * Copyright (c) 2023, Buchus <http://github.com/MoreBuchus>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.tzhaarhptracker;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.Getter;
import lombok.Setter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.NPC;

@Slf4j
@Data
@AllArgsConstructor
@Getter
@Setter
public class TzhaarNPC
{
	private NPC npc;
	private int hp;
	private boolean dead = false;
	private int maxHp;
	private int spawnTick;
	private int deathTick;
	private boolean healed = false;
	private int queuedDamage = 0;

	public TzhaarNPC(NPC npc, int currentHp, int maxHp, int tick)
	{
		this.npc = npc;
		this.hp = currentHp;
		this.spawnTick = tick;
		this.maxHp = maxHp;
	}

	public void addHp(int hp)
	{
		this.hp += hp;
	}

	public void removeHp(int hp)
	{
		this.hp -= hp;
	}
}

/*
 * Copyright (c) 2023, Buchus <http://github.com/MoreBuchus>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.tzhaarhptracker.info;

import com.google.common.collect.Sets;
import java.util.Set;
import lombok.Getter;
import static net.runelite.api.NpcID.*;

enum XPModifiers
{
	//Fight Caves -> All have +0% xp mods
	FC_BAT(0, TZKIH_3116, TZKIH_3117),
	FC_BLOB(0, TZKEK_3118, TZKEK_3119, TZKEK_3120), //All blobs have 0 xp mod
	FC_RANGE(0, TOKXIL_3121, TOKXIL_3122),
	FC_MELEE(0, YTMEJKOT, YTMEJKOT_3124),
	FC_MAGE(0, KETZEK, KETZEK_3126),
	TZTOK_JAD(0, TZTOKJAD),
	FC_JAD_HEALER(0, YTHURKOT),

	//Inferno
	NIBBLER(0, JALNIB),
	BAT(0, JALMEJRAH),
	BLOB(2.5, JALAK),
	BLOBLETS(0, JALAKREKMEJ, JALAKREKXIL, JALAKREKKET),
	MELEE(7.5, JALIMKOT),
	RANGE(0, JALXIL, JALXIL_7702),
	MAGE(0, JALZEK, JALZEK_7703),
	INFERNO_JAD(0, JALTOKJAD, JALTOKJAD_7704),
	TZKAL_ZUK(57.5, TZKALZUK),
	ZUK_HEALER(0, JALMEJJAK),
	INFERNO_JAD_HEALERS(0, YTHURKOT_7701, YTHURKOT_7705),
	PILLAR(0, ROCKY_SUPPORT) //7710 is just as it is dying
	;

	@Getter
	private final double xpMod;
	@Getter
	private final Set<Integer> ids;

	XPModifiers(double xpMod, Integer... ids)
	{
		this.xpMod = xpMod;
		this.ids = Sets.newHashSet(ids);
	}

	static XPModifiers getNPC(int id)
	{
		for (XPModifiers npc : values())
		{
			if (npc.ids.stream().anyMatch(i -> i == id))
			{
				return npc;
			}
		}
		return null;
	}

	static double getXpMod(int id)
	{
		XPModifiers npc = getNPC(id);
		if (npc != null)
		{
			return npc.xpMod;
		}
		return 0;
	}
}

/*
 * Copyright (c) 2022, l2- <https://github.com/l2->
 * Copyright (c) 2021, InfernoStats <https://github.com/InfernoStats>
 * Copyright (c) 2023, Buchus <http://github.com/MoreBuchus>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.tzhaarhptracker.info;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.EnumMap;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import javax.inject.Inject;
import lombok.Getter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Actor;
import net.runelite.api.Client;
import net.runelite.api.GameState;
import net.runelite.api.HitsplatID;
import net.runelite.api.MenuAction;
import net.runelite.api.NPC;
import net.runelite.api.Skill;
import net.runelite.api.VarPlayer;
import net.runelite.api.Varbits;
import net.runelite.api.events.FakeXpDrop;
import net.runelite.api.events.GameStateChanged;
import net.runelite.api.events.GameTick;
import net.runelite.api.events.HitsplatApplied;
import net.runelite.api.events.InteractingChanged;
import net.runelite.api.events.MenuOptionClicked;
import net.runelite.api.events.StatChanged;
import net.runelite.api.events.VarbitChanged;
import net.runelite.api.kit.KitType;
import net.runelite.api.widgets.InterfaceID;
import net.runelite.api.widgets.Widget;
import net.runelite.api.widgets.WidgetUtil;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.game.NpcUtil;
import net.runelite.client.game.SkillIconManager;
import com.tzhaarhptracker.TzhaarHPTrackerConfig;
import com.tzhaarhptracker.TzhaarHPTrackerPlugin;
import com.tzhaarhptracker.attackstyles.WeaponMap;
import com.tzhaarhptracker.InfoHandler;
import com.tzhaarhptracker.TzhaarNPC;
import com.tzhaarhptracker.attackstyles.AttackStyle;
import com.tzhaarhptracker.attackstyles.WeaponStyle;
import com.tzhaarhptracker.attackstyles.WeaponType;
import net.runelite.client.ui.overlay.OverlayManager;
import net.runelite.client.util.Text;
import org.apache.commons.lang3.ObjectUtils;
import static net.runelite.api.NpcID.*;

@Slf4j
public class DamageHandler extends InfoHandler
{
	@Inject
	private Client client;
	@Inject
	private OverlayManager overlayManager;
	@Inject
	private ClientThread clientThread;
	@Inject
	private NpcUtil npcUtil;
	@Inject
	private SkillIconManager skillIconManager;

	//XP drops
	@Getter
	private static final int[] previous_exp = new int[Skill.values().length];
	@Getter
	private final Map<Skill, Integer> fakeXpMap = new EnumMap<>(Skill.class);

	@Getter
	private Actor lastOpponent;
	@Getter
	private int lastOpponentID = -1;

	private int attackStyleVarbit = -1;
	private int equippedWeaponTypeVarbit = -1;
	private int castingModeVarbit = -1;

	@Getter
	private AttackStyle attackStyle;
	@Getter
	private WeaponStyle weaponStyle;
	private boolean skipTickCheck = false;

	@Getter
	private boolean processedThisTick = false;
	@Getter
	private boolean aoeSpellQueued = false;

	//444 -> healing graphic without purple hitsplats
	private static final int HEALING_GRAPHIC = 444;

	private static final int BARRAGE = 1979;

	@Inject
	protected DamageHandler(TzhaarHPTrackerPlugin plugin, TzhaarHPTrackerConfig config)
	{
		super(plugin, config);
	}

	public void load()
	{
		if (client.getGameState() == GameState.LOGGED_IN)
		{
			clientThread.invokeLater(() ->
			{
				int[] xps = client.getSkillExperiences();
				System.arraycopy(xps, 0, previous_exp, 0, previous_exp.length);

				initAttackStyles();
			});
		}
		else
		{
			Arrays.fill(previous_exp, 0);
		}
	}

	public void unload()
	{

	}

	private void initAttackStyles()
	{
		attackStyleVarbit = client.getVarpValue(VarPlayer.ATTACK_STYLE);
		equippedWeaponTypeVarbit = client.getVarbitValue(Varbits.EQUIPPED_WEAPON_TYPE);
		castingModeVarbit = client.getVarbitValue(Varbits.DEFENSIVE_CASTING_MODE);
		updateAttackStyle(equippedWeaponTypeVarbit, attackStyleVarbit, castingModeVarbit);
	}

	private void updateAttackStyle(int equippedWeaponType, int attackStyleIndex, int castingMode)
	{
		AttackStyle[] attackStyles = WeaponType.getWeaponType(equippedWeaponType).getAttackStyles();
		if (attackStyleIndex < attackStyles.length)
		{
			attackStyle = attackStyles[attackStyleIndex];
			if (attackStyle == null)
			{
				attackStyle = AttackStyle.OTHER;
			}
			else if ((attackStyle == AttackStyle.CASTING) && (castingMode == 1))
			{
				attackStyle = AttackStyle.DEFENSIVE_CASTING;
			}
		}
	}

	@Subscribe
	protected void onGameStateChanged(GameStateChanged e)
	{
		if (e.getGameState() == GameState.LOGIN_SCREEN || e.getGameState() == GameState.HOPPING)
		{
			Arrays.fill(previous_exp, 0);
		}
	}

	@Subscribe
	private void onVarbitChanged(VarbitChanged e)
	{
		if (plugin.isInAllowedCaves())
		{
			int currentAttackStyleVarbit = client.getVarpValue(VarPlayer.ATTACK_STYLE);
			int currentEquippedWeaponTypeVarbit = client.getVarbitValue(Varbits.EQUIPPED_WEAPON_TYPE);
			int currentCastingModeVarbit = client.getVarbitValue(Varbits.DEFENSIVE_CASTING_MODE);

			if (attackStyleVarbit != currentAttackStyleVarbit || equippedWeaponTypeVarbit != currentEquippedWeaponTypeVarbit || castingModeVarbit != currentCastingModeVarbit)
			{
				attackStyleVarbit = currentAttackStyleVarbit;
				equippedWeaponTypeVarbit = currentEquippedWeaponTypeVarbit;
				castingModeVarbit = currentCastingModeVarbit;

				updateAttackStyle(equippedWeaponTypeVarbit, attackStyleVarbit, castingModeVarbit);
			}
		}
	}

	@Subscribe
	private void onHitsplatApplied(HitsplatApplied e)
	{
		if (plugin.isInAllowedCaves())
		{
			Actor actor = e.getActor();
			int hitsplat = e.getHitsplat().getAmount();

			if (actor != null && actor.getName() != null && actor instanceof NPC)
			{
				NPC splatNpc = (NPC) actor;

				for (TzhaarNPC n : plugin.getNpcs())
				{
					if (n.getNpc().equals(splatNpc))
					{
						if (!Objects.equals(n.getNpc().getName(), "TzKal-Zuk") || !zukWidgetActive())
						{
							if (e.getHitsplat().getHitsplatType() == HitsplatID.HEAL)
							{
								n.addHp(hitsplat);
							}
							else
							{
								if (hitsplat != 0)
								{
									if (!n.isHealed())
									{
										n.removeHp(hitsplat);
										//Only set to dead if it has not been set to dead yet
										if (!n.isDead())
										{
											//n.setDead(n.getHp() <= 0);
											handleDead(n, n.getHp() <= 0);
										}
									}

									//Set the death tick on hitsplat when it is predicted to die
									if (n.isDead())
									{
										n.setDeathTick(client.getTickCount());
									}

									//If the npc is not set to dead, but the death tick was tracked -> reset to 0
									if (!n.isDead() && n.getDeathTick() > 0)
									{
										n.setDeathTick(0);
									}

									n.setQueuedDamage(Math.max(0, n.getQueuedDamage() - hitsplat));
								}
							}
						}
						//Track death tick and queued damage for Zuk if HP widget is active
						else
						{
							//Set the death tick on hitsplat when it is predicted to die
							if (n.isDead())
							{
								n.setDeathTick(client.getTickCount());
							}

							//If the npc is not set to dead, but the death tick was tracked -> reset to 0
							if (!n.isDead() && n.getDeathTick() > 0)
							{
								n.setDeathTick(0);
							}

							n.setQueuedDamage(Math.max(0, n.getQueuedDamage() - hitsplat));
						}
					}
				}
			}
		}
	}

	@Subscribe
	private void onGameTick(GameTick e)
	{
		if (plugin.isInAllowedCaves())
		{
			processedThisTick = false;

			// Group FakeXP drops and process them every game tick
			for (Map.Entry<Skill, Integer> xp : fakeXpMap.entrySet())
			{
				int hit;
				Actor interacted = Objects.requireNonNull(client.getLocalPlayer()).getInteracting();
				if (interacted instanceof NPC && lastOpponent == null)
				{
					lastOpponent = interacted;
				}

				if (lastOpponent != null)
				{
					switch (xp.getKey())
					{
						case ATTACK:
						case STRENGTH:
						case DEFENCE:
						case RANGED:
							//Long range should be calculated with range only
							hit = calculateHitOnNpc(lastOpponentID, attackStyle == AttackStyle.LONGRANGE ? Skill.RANGED : xp.getKey(), xp.getValue(), attackStyle, weaponStyle);
							processHit(hit, xp.getKey(), attackStyle, weaponStyle, (NPC) lastOpponent);
							break;
						case HITPOINTS:
							if (attackStyle == AttackStyle.CASTING)
							{
								//Only calculate magic damage using hitpoints if it's not defensive casting
								hit = calculateHitOnNpc(lastOpponentID, xp.getKey(), xp.getValue(), attackStyle, weaponStyle);
								processHit(hit, xp.getKey(), attackStyle, weaponStyle, (NPC) lastOpponent);
							}
							break;
					}
				}
			}
			fakeXpMap.clear();

			//Handle HP recalculating and regen
			if (!plugin.getNpcs().isEmpty() && client.getLocalPlayer() != null)
			{
				for (TzhaarNPC n : plugin.getNpcs())
				{
					int currentTick = client.getTickCount();
					int spawnTick = n.getSpawnTick();
					if (currentTick - spawnTick >= 100 && n.getNpc().getId() != ROCKY_SUPPORT)
					{
						if (n.getHp() != n.getMaxHp())
						{
							n.addHp(1);
							n.setSpawnTick(currentTick);
						}
					}

					//Recalculate HP 2 ticks after 1st hitsplat after being set to dead if still alive
					if (n.isDead() && n.getDeathTick() != 0 && client.getTickCount() >= n.getDeathTick() + 2 && !npcUtil.isDying(n.getNpc()))
					{
						n.setDead(false);
						recalcHP(n, n.getNpc().getHealthRatio(), n.getNpc().getHealthScale());
					}
					else
					{
						if (n.getHp() > 0 && npcUtil.isDying(n.getNpc()))
						{
							n.setHp(0);
							handleDead(n, true);
						}
					}

					//Healing graphic without healing hitsplats
					if (n.getNpc().hasSpotAnim(HEALING_GRAPHIC))
					{
						n.setHealed(true);
					}

					//Recalculate HP for NPCs with healing graphic
					//Zuk HP handled by widget
					if (n.isHealed() && !Objects.equals(n.getNpc().getName(), "TzKal-Zuk"))
					{
						recalcHP(n, n.getNpc().getHealthRatio(), n.getNpc().getHealthScale());
					}

					if (Objects.equals(n.getNpc().getName(), "TzKal-Zuk") && zukWidgetActive() && plugin.getCurrentWave().containsKey("inferno")
						&& plugin.getCurrentWave().get("inferno") == 69)
					{
						n.setHp(getZukHPfromWidget());
					}
				}
			}

			if (skipTickCheck)
			{
				skipTickCheck = false;
			}
			else
			{
				if (client.getLocalPlayer() != null && client.getLocalPlayer().getPlayerComposition() != null)
				{
					int equippedWeapon = ObjectUtils.defaultIfNull(client.getLocalPlayer().getPlayerComposition().getEquipmentId(KitType.WEAPON), -1);
					weaponStyle = WeaponMap.StyleMap.get(equippedWeapon);
				}
			}
		}
	}

	@Subscribe
	public void onMenuOptionClicked(MenuOptionClicked e)
	{
		if (plugin.isInAllowedCaves())
		{
			String target = Text.removeTags(e.getMenuTarget());
			String option = Text.removeTags(e.getMenuOption());

			if (option.equalsIgnoreCase("wield"))
			{
				WeaponStyle newStyle = WeaponMap.StyleMap.get(e.getItemId());
				if (newStyle != null)
				{
					skipTickCheck = true;
					weaponStyle = newStyle;
				}
			}

			switch (e.getMenuAction())
			{
				//Any menu click that targets an NPC
				case WIDGET_TARGET_ON_NPC:
				case NPC_FIRST_OPTION:
				case NPC_SECOND_OPTION:
				case NPC_THIRD_OPTION:
				case NPC_FOURTH_OPTION:
				case NPC_FIFTH_OPTION:
					lastOpponent = e.getMenuEntry().getNpc();
					if (e.getMenuAction() == MenuAction.WIDGET_TARGET_ON_NPC && WidgetUtil.componentToInterface(client.getSelectedWidget().getId()) == InterfaceID.SPELLBOOK)
					{
						attackStyle = (client.getVarbitValue(Varbits.DEFENSIVE_CASTING_MODE) == 1 || attackStyle == AttackStyle.DEFENSIVE_CASTING) ?
							AttackStyle.DEFENSIVE_CASTING : AttackStyle.CASTING;

						String[] aoeSpells = {
							"ice barrage", "ice burst", "blood barrage", "blood burst",
							"smoke barrage", "smoke burst", "shadow barrage", "shadow burst"
						};
						for (String spell : aoeSpells)
						{
							if (target.toLowerCase().startsWith(spell + " ->") && e.getMenuEntry().getNpc() != null && e.getMenuEntry().getNpc().getName() != null
								&& (TzhaarHPTrackerPlugin.getINFERNO_NPC().contains(e.getMenuEntry().getNpc().getName().toLowerCase())
								|| TzhaarHPTrackerPlugin.getFIGHT_CAVE_NPC().contains(e.getMenuEntry().getNpc().getName().toLowerCase())))
							{
								aoeSpellQueued = true;
							}
						}
					}
					else
					{
						initAttackStyles();
						aoeSpellQueued = false;
					}
					break;
				//Any menu click which clears an interaction
				case WALK:
				case WIDGET_TARGET_ON_WIDGET:
				case WIDGET_TARGET_ON_GROUND_ITEM:
				case WIDGET_TARGET_ON_PLAYER:
				case GROUND_ITEM_FIRST_OPTION:
				case GROUND_ITEM_SECOND_OPTION:
				case GROUND_ITEM_THIRD_OPTION:
				case GROUND_ITEM_FOURTH_OPTION:
				case GROUND_ITEM_FIFTH_OPTION:
					lastOpponent = null;
					aoeSpellQueued = false;
					break;
				default:
					if (e.isItemOp())
					{
						lastOpponent = null;
						aoeSpellQueued = false;
					}
					break;
			}
		}
	}

	@Subscribe
	private void onInteractingChanged(InteractingChanged e)
	{
		if (plugin.isInAllowedCaves())
		{
			if (e.getSource() == client.getLocalPlayer())
			{
				if (e.getTarget() instanceof NPC)
				{
					NPC npc = (NPC) e.getTarget();
					lastOpponent = npc;
					lastOpponentID = npc.getId();
				}
				else
				{
					lastOpponent = null;
					lastOpponentID = -1;
				}
			}
		}
	}

	@Subscribe
	protected void onStatChanged(StatChanged e)
	{
		int currentXp = e.getXp();
		int previousXp = previous_exp[e.getSkill().ordinal()];
		if (previousXp > 0 && currentXp - previousXp > 0)
		{
			int hit;

			Actor interacted = Objects.requireNonNull(client.getLocalPlayer()).getInteracting();
			if (interacted instanceof NPC && lastOpponent == null)
			{
				lastOpponent = interacted;
			}

			if (plugin.isInAllowedCaves() && lastOpponent != null)
			{
				switch (e.getSkill())
				{
					case ATTACK:
					case STRENGTH:
					case DEFENCE:
					case RANGED:
						//Long range should be calculated with range only
						hit = calculateHitOnNpc(lastOpponentID, attackStyle == AttackStyle.LONGRANGE ? Skill.RANGED : e.getSkill(),
							currentXp - previousXp, attackStyle, weaponStyle);
						processHit(hit, e.getSkill(), attackStyle, weaponStyle, (NPC) lastOpponent);
						break;
					case HITPOINTS:
						if (attackStyle == AttackStyle.CASTING)
						{
							hit = calculateHitOnNpc(lastOpponentID, e.getSkill(), currentXp - previousXp, attackStyle, weaponStyle);
							processHit(hit, e.getSkill(), attackStyle, weaponStyle, (NPC) lastOpponent);
						}
						break;
				}
			}
		}

		previous_exp[e.getSkill().ordinal()] = e.getXp();
	}

	@Subscribe
	protected void onFakeXpDrop(FakeXpDrop e)
	{
		switch (e.getSkill())
		{
			case ATTACK:
			case STRENGTH:
			case DEFENCE:
			case RANGED:
			case HITPOINTS: //HP used instead of magic
				final int currentXp = fakeXpMap.getOrDefault(e.getSkill(), 0);
				fakeXpMap.put(e.getSkill(), currentXp + e.getXp());
				break;
		}
	}

	// For Raging Echoes League
	private double calculateEquilibriumXpDrop(int totalLevel)
	{
		return totalLevel / 10.0d;
	}

	public int calculateHitOnNpc(int id, Skill skill, int xpDiff, AttackStyle attackStyle, WeaponStyle weaponStyle)
	{
		double modifier = 1.0;

		if (XPModifiers.getNPC(id) != null)
		{
			modifier = (XPModifiers.getXpMod(id) + 100) / 100.0d;
		}

		return calculateHit(skill, xpDiff, attackStyle, weaponStyle, modifier, config.xpMultiplier());
	}


	private int calculateHit(Skill skill, int xpDiff, AttackStyle attackStyle, WeaponStyle weaponStyle, double modifier, double configModifier)
	{
		double damage = 0;


		// For Raging Echoes League
		if (config.equilibriumRelic())
		{
			xpDiff -= calculateEquilibriumXpDrop(config.totalLevel());
		}

		if (Math.abs(configModifier) < 1e-6)
		{
			configModifier = 1e-6;
		}

		if (modifier < 1e-6)
		{
			return 0;
		}

		switch (skill)
		{
			case ATTACK:
			case STRENGTH:
			case DEFENCE:
				switch (attackStyle)
				{
					case ACCURATE:
					case AGGRESSIVE:
					case DEFENSIVE:
						damage = xpDiff / 4.0D;
						break;
					case CONTROLLED:
						damage = xpDiff / 1.33D;
						break;
					case DEFENSIVE_CASTING:
						damage = xpDiff;
						break;
				}
				break;
			case HITPOINTS:
				if (attackStyle == AttackStyle.CASTING)
				{
					damage = xpDiff / 1.33D;
					break;
				}
				break;
			case RANGED:
				switch (attackStyle)
				{
					case RANGING:
						damage = xpDiff / 4.0D;
						break;
					case LONGRANGE:
						damage = xpDiff / 2.0D;
						break;
				}
				break;
		}

		//Rounding at end more accurate
		return (int) Math.round(damage / modifier / configModifier);
	}

	private void processHit(int damage, Skill skill, AttackStyle attackStyle, WeaponStyle style, NPC interacting)
	{
		if (!processedThisTick && damage > 0 && skill != null)
		{
			processedThisTick = true;
			boolean isAoe = style == WeaponStyle.CHINS || (client.getLocalPlayer().getAnimation() == BARRAGE || aoeSpellQueued);
			checkIfInteractingDead(damage, isAoe, interacting.getIndex(), attackStyle, style);
		}
	}

	private void checkIfInteractingDead(int damage, boolean isAoe, int index, AttackStyle attackStyle, WeaponStyle style)
	{
		clientThread.invokeLater(() -> {
			if (damage != -1)
			{
				TzhaarNPC target = findTargetByIndex(index);
				if (target != null)
				{
					List<TzhaarNPC> clump = getNearbyTzhaarNpcs(target);
					handleTargetDeath(target, damage, isAoe, attackStyle, style, clump);
				}
				aoeSpellQueued = false;
			}
		});
	}

	private TzhaarNPC findTargetByIndex(int index)
	{
		for (TzhaarNPC n : plugin.getNpcs())
		{
			if (n.getNpc().getIndex() == index)
			{
				return n;
			}
		}
		return null;
	}

	private List<TzhaarNPC> getNearbyTzhaarNpcs(TzhaarNPC target)
	{
		List<TzhaarNPC> clump = new ArrayList<>();
		for (TzhaarNPC n : plugin.getNpcs())
		{
			if (!n.isDead() && n.getNpc().getId() != ROCKY_SUPPORT && n.getNpc().getWorldLocation().distanceTo(target.getNpc().getWorldLocation()) <= 1)
			{
				clump.add(n);
			}
		}
		return clump;
	}

	private void handleTargetDeath(TzhaarNPC target, int damage, boolean isAoe, AttackStyle attackStyle, WeaponStyle style, List<TzhaarNPC> clump)
	{
		if (!isAoe || clump.size() == 1 || client.getVarbitValue(Varbits.MULTICOMBAT_AREA) == 0 || (style == WeaponStyle.SCYTHES && attackStyle != AttackStyle.CASTING))
		{
			// Handle normally (clump size = 1) or single combat if AoE
			target.setQueuedDamage(target.getQueuedDamage() + damage);
			handleDead(target, target.getQueuedDamage() >= target.getHp());
		}
		else
		{
			// Handle clump (clump size > 1)
			if (clump.stream().mapToInt(TzhaarNPC::getHp).sum() <= damage)
			{
				clump.forEach(npc -> handleDead(npc, true));
			}
		}
	}

	private void handleDead(TzhaarNPC npc, boolean dead)
	{
		for (TzhaarNPC n : plugin.getNpcs())
		{
			if (n.getNpc().getIndex() == npc.getNpc().getIndex())
			{
				if (dead)
				{
					n.setDead(true);
				}

				boolean isHidden = plugin.getHiddenNPCs().stream().anyMatch(h -> h.getNpc().getIndex() == n.getNpc().getIndex());
				if (n.isDead() && !isHidden)
				{
					plugin.getHiddenNPCs().add(n);
				}

				if (!n.isDead() && isHidden)
				{
					plugin.getHiddenNPCs().remove(n);
				}
			}
		}
	}

	// Copied from Opponent Info
	private void recalcHP(TzhaarNPC n, int lastRatio, int lastHealthScale)
	{
		int health;
		if (lastRatio > 0)
		{
			int minHealth = 1;
			int maxHealth;
			if (lastHealthScale > 1)
			{
				if (lastRatio > 1)
				{
					minHealth = (n.getMaxHp() * (lastRatio - 1) + lastHealthScale - 2) / (lastHealthScale - 1);
				}
				maxHealth = (n.getMaxHp() * lastRatio - 1) / (lastHealthScale - 1);
				if (maxHealth > n.getMaxHp())
				{
					maxHealth = n.getMaxHp();
				}
			}
			else
			{
				maxHealth = n.getMaxHp();
			}

			health = (minHealth + maxHealth + 1) / 2;

			n.setHp(health);
			handleDead(n, health <= 0);

			//If the npc is not set to dead, but the death tick was tracked -> reset to 0
			if (!n.isDead() && n.getDeathTick() > 0)
			{
				n.setDeathTick(0);
			}
		}
	}

	// Set Zuk's hp off of the widget
	private int getZukHPfromWidget()
	{
		Widget widget = client.getWidget(596, 9);
		if (widget != null && !widget.isHidden())
		{
			return Integer.parseInt(widget.getText().substring(0, widget.getText().indexOf("/")).trim());
		}
		return -1;
	}

	// Check if the hp widget is active for Zuk
	private boolean zukWidgetActive()
	{
		Widget widget = client.getWidget(596, 9);
		return widget != null && !widget.isHidden();
	}
}

package com.tzhaarhptracker.info;

import com.google.common.collect.Sets;
import java.util.Set;
import lombok.Getter;
import static net.runelite.api.NpcID.*;

public enum TzhaarHP
{
	//Fight Caves
	FC_BAT(10, TZKIH_3116, TZKIH_3117),
	FC_BIG_BLOB(20, TZKEK_3118, TZKEK_3119),
	FC_BLOBLETS(10, TZKEK_3120),
	FC_RANGE(40, TOKXIL_3121, TOKXIL_3122),
	FC_MELEE(80, YTMEJKOT, YTMEJKOT_3124),
	FC_MAGE(160, KETZEK, KETZEK_3126),
	TZTOK_JAD(250, TZTOKJAD),
	FC_JAD_HEALER(60, YTHURKOT),

	//Inferno
	NIBBLER(10, JALNIB),
	BAT(25, JALMEJRAH),
	BLOB(40, JALAK),
	BLOBLETS(15, JALAKREKMEJ, JALAKREKXIL, JALAKREKKET),
	MELEE(75, JALIMKOT),
	RANGE(125, JALXIL, JALXIL_7702),
	MAGE(220, JALZEK, JALZEK_7703),
	INFERNO_JAD(350, JALTOKJAD, JALTOKJAD_7704),
	TZKAL_ZUK(1200, TZKALZUK),
	ZUK_HEALER(75, JALMEJJAK),
	INFERNO_JAD_HEALERS(90, YTHURKOT_7701, YTHURKOT_7705),
	PILLAR(255, ROCKY_SUPPORT) //7710 is just as it is dying
	;

	@Getter
	private final int maxHP;
	@Getter
	private final Set<Integer> ids;

	TzhaarHP(int maxHP, Integer... ids)
	{
		this.maxHP = maxHP;
		this.ids = Sets.newHashSet(ids);
	}

	public static TzhaarHP getNPC(int id)
	{
		for (TzhaarHP npc : values())
		{
			if (npc.ids.stream().anyMatch(i -> i == id))
			{
				return npc;
			}
		}
		return null;
	}

	public static int getMaxHP(int id)
	{
		TzhaarHP npc = getNPC(id);
		if (npc != null)
		{
			return npc.maxHP;
		}
		return 0;
	}

	public static int getRespawnedHP(int id)
	{
		TzhaarHP npc = getNPC(id);
		if (npc != null)
		{
			return (int) Math.ceil((double) npc.maxHP / 2);
		}
		return 0;
	}
}

package com.tzhaarhptracker;

import net.runelite.client.RuneLite;
import net.runelite.client.externalplugins.ExternalPluginManager;

public class ExamplePluginTest
{
	public static void main(String[] args) throws Exception
	{
		ExternalPluginManager.loadBuiltin(TzhaarHPTrackerPlugin.class);
		RuneLite.main(args);
	}
}
