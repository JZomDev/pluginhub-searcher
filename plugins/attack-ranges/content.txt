package com.attackranges;

import java.util.Set;
import net.runelite.api.Actor;
import net.runelite.api.Client;
import net.runelite.api.coords.LocalPoint;
import net.runelite.api.coords.WorldPoint;

public class Regions
{
	public static final int FIGHT_CAVES = 9551;
	public static final int INFERNO = 9043;
	public static final int GAUNTLET = 7512;
	public static final int CORRUPTED_GAUNTLET = 7768;
	public static final int FORTIS_COLOSSEUM = 7216;

	public static final Set<Integer> SUPPORTED_REGIONS = Set.of(
		FIGHT_CAVES,
		INFERNO,
		GAUNTLET,
		CORRUPTED_GAUNTLET,
		FORTIS_COLOSSEUM
	);

	public static boolean isInRegion(Client client, int regionId)
	{
		Integer playerRegionId = getPlayerRegionId(client);
		return playerRegionId != null && playerRegionId == regionId;
	}

	public static Integer getPlayerRegionId(Client client)
	{
		return getActorRegionId(client, client.getLocalPlayer());
	}

	public static Integer getActorRegionId(Client client, Actor actor)
	{
		WorldPoint wp = actor.getWorldLocation();
		LocalPoint lp = LocalPoint.fromWorld(client.getLocalPlayer().getWorldView(), wp);

		if (lp == null)
		{
			return null;
		}

		return WorldPoint.fromLocalInstance(client, lp).getRegionID();
	}
}

package com.attackranges;

import net.runelite.client.config.Alpha;
import net.runelite.client.config.Config;
import net.runelite.client.config.ConfigGroup;
import net.runelite.client.config.ConfigItem;
import net.runelite.client.config.ConfigSection;

import java.awt.Color;
import net.runelite.client.config.Keybind;

@ConfigGroup("attackRanges")
public interface AttackRangesConfig extends Config
{
	String ATTACK_RANGES_GROUP = "attackRanges";

	@ConfigSection(
		name = "Options",
		description = "Attack range options",
		position = 1
	)
	String options = "options";

	@ConfigSection(
		name = "Styles",
		description = "Visual styles",
		position = 2
	)
	String styles = "styles";

	@ConfigItem(
		keyName = "playerEnableState",
		name = "Display Overlay",
		description = "When the overlay will be shown",
		section = options,
		position = 1
	)
	default EnableState playerEnableState()
	{
		return EnableState.ON;
	}

	@ConfigItem(
		keyName = "npcHighlightEnableState",
		name = "Highlight NPCs",
		description = "When to highlight NPCs that can be targeted",
		section = options,
		position = 2
	)
	default EnableState npcHighlightEnableState()
	{
		return EnableState.OFF;
	}

	@ConfigItem(
		keyName = "displayHotkey",
		name = "Display Hotkey",
		description = "Hotkey to press to display the overlay",
		section = options,
		position = 3
	)
	default Keybind displayHotkey()
	{
		return Keybind.NOT_SET;
	}

	@ConfigItem(
		keyName = "displayHotkeyMode",
		name = "Hotkey Mode",
		description = "Whether the hotkey is toggle or hold to display the overlay",
		section = options,
		position = 4
	)
	default DisplayHotkeyMode displayHotkeyMode()
	{
		return DisplayHotkeyMode.TOGGLE;
	}

	@ConfigItem(
		keyName = "allowListedWeapons",
		name = "Rendered weapons",
		description = "List of items you want displayed. Supports wildcards. Example: Trident*, rune crossbow",
		section = options,
		position = 5
	)
	default String getAllowListedWeapons()
	{
		return "";
	}

	@ConfigItem(
		keyName = "showManualCasting",
		name = "Display manual casting",
		description = "Display cast range for weapons when not auto casting",
		section = options,
		position = 6
	)
	default boolean getManualCastingMode()
	{
		return false;
	}

	@ConfigItem(
		keyName = "showMeleeWeapons",
		name = "Display melee",
		description = "Display the range with melee weapons",
		section = options,
		position = 7
	)
	default boolean getShowDisplayMelee()
	{
		return false;
	}

	@ConfigItem(
		keyName = "showSpecialAttack",
		name = "Display special attack",
		description = "Display ranges for special attacks, such as Dinh's Bulwark",
		section = options,
		position = 8
	)
	default boolean getShowSpecialAttack()
	{
		return true;
	}

	@ConfigItem(
		keyName = "dragProtection",
		name = "Enable drag protection",
		description = "Hides the Attack option on NPCs not in attack range",
		section = options,
		position = 9
	)
	default boolean getDragProtection()
	{
		return false;
	}

	@ConfigItem(
		keyName = "displayMode",
		name = "Display Mode",
		description = "How the attack range is displayed",
		section = styles
	)
	default DisplayMode displayMode()
	{
		return DisplayMode.BORDER;
	}

	@Alpha
	@ConfigItem(
		keyName = "rangeBorderColor",
		name = "Border Color",
		description = "The color of the your attack range border",
		position = 1,
		section = styles
	)
	default Color rangeBorderColor()
	{
		return new Color(86, 234, 103, 102);
	}

	@Alpha
	@ConfigItem(
		keyName = "rangeFillColor",
		name = "Fill Color",
		description = "The inner color of the your attack range section",
		position = 2,
		section = styles
	)
	default Color rangeFillColor()
	{
		return new Color(0, 0, 0, 50);
	}

	@ConfigItem(
		keyName = "borderSize",
		name = "Border Size",
		description = "Thickness of your attack range border",
		position = 3,
		section = styles
	)
	default int borderSize()
	{
		return 1;
	}

	@Alpha
	@ConfigItem(
		keyName = "npcHighlightOutlineColor",
		name = "NPC Outline Color",
		description = "The outline color of targetable NPCs",
		position = 4,
		section = styles
	)
	default Color npcHighlightOutlineColor()
	{
		return new Color(0x9000FFFF, true);
	}

	@Alpha
	@ConfigItem(
		keyName = "npcHighlightFillColor",
		name = "NPC Fill Color",
		description = "The inner color of highlighted NPCs",
		position = 5,
		section = styles
	)
	default Color npcHighlightFillColor()
	{
		return new Color(0x4400FFFF, true);
	}

	@ConfigItem(
		keyName = "npcHighlightOutlineThickness",
		name = "NPC Outline Thickness",
		description = "Thickness of the highlighted NPCs outline",
		position = 6,
		section = styles
	)
	default int npcOutlineSize()
	{
		return 3;
	}


	enum DisplayMode
	{
		TILES,
		BORDER,
		EDGE_TILES,
	}

	enum EnableState
	{
		ON,
		OFF,
		INSTANCES_ONLY,
		HOTKEY_MODE
	}

	enum DisplayHotkeyMode
	{
		TOGGLE,
		HOLD
	}
}

package com.attackranges.weapons;

public class Longbow extends Weapon
{
	public Longbow(int id)
	{
		super(id);
		range = 10;
		longRangeModifier = 0;
	}
}

package com.attackranges.weapons;

import java.util.List;

public class GenericThrown extends Weapon
{
	public GenericThrown(List<Integer> weaponData)
	{
		super(weaponData);
	}
}

package com.attackranges.weapons;

import java.util.List;

public class Dart extends Weapon
{
	public Dart(int id)
	{
		super(id);
		range = 3;
	}

	public Dart(List<Integer> weaponData)
	{
		super(weaponData);
	}
}

package com.attackranges.weapons;

public class Shortbow extends Weapon
{
	public Shortbow(int id)
	{
		super(id);
		range = 7;
	}
}

package com.attackranges.weapons;

import java.util.List;

public class Melee extends Weapon
{
	public Melee(List<Integer> weaponData) { super(weaponData); }

	public Integer getSpecialAttackRange() { return this.getRange() + this.getLongRangeModifier(); }
}

package com.attackranges.weapons;

public class Staff extends ManualCastable
{
	public Staff(int id)
	{
		super(id);
		range = 10;
	}

}

package com.attackranges.weapons;

import java.util.List;

public class Bow extends Weapon
{
	public Bow(List<Integer> weaponData)
	{
		super(weaponData);
	}
}

package com.attackranges.weapons;

public class Compbow extends Weapon
{
	public Compbow(int id)
	{
		super(id);
		range = 10;
		longRangeModifier = 0;
	}
}

package com.attackranges.weapons;

import java.util.List;

public class Crossbow extends Weapon
{
	public Crossbow(int id)
	{
		super(id);
		range = 7;
	}

	public Crossbow(List<Integer> weaponData)
	{
		super(weaponData);
	}
}

package com.attackranges.weapons;

public class Thrownaxe extends Weapon
{
	public Thrownaxe(int id)
	{
		super(id);
		range = 4;
	}
}

package com.attackranges.weapons;

public class Halberd extends Weapon
{
	public Halberd(int id)
	{
		super(id);
		range = 2;
		longRangeModifier = 0;
	}
}

package com.attackranges.weapons;

import java.util.List;

public class PoweredStaff extends Weapon
{
	public PoweredStaff(int id)
	{
		super(id);
		range = 7;
	}

	public PoweredStaff(List<Integer> weaponData)
	{
		super(weaponData);
	}


	public int getRange(String attackStyle)
	{
		return attackStyle.equals("Defensive") ? range + longRangeModifier : range;
	}
}

package com.attackranges.weapons;

import lombok.Data;

import java.util.List;

@Data
public class Weapon
{
	int id;
	int range;
	int longRangeModifier = 2;

	public Weapon(int id)
	{
		this.id = id;
	}

	public Weapon(List<Integer> weaponData)
	{
		this.id = weaponData.get(0);
		this.range = weaponData.get(1);
		if (weaponData.size() == 3)
		{
			this.longRangeModifier = weaponData.get(2);
		}
	}

	public int getRange(String attackStyle)
	{
		return attackStyle.equals("Longrange") ? range + longRangeModifier : range;
	}
}
package com.attackranges.weapons;

import lombok.Getter;
import org.apache.commons.lang3.tuple.Pair;

import java.util.HashSet;
import java.util.List;
import java.util.Set;
import java.util.function.Function;

@Getter
public class WeaponIds
{
	// Standard Weapons
	// Weapons that are the same type and share a common range
	// Groups mostly determined from what is listed on the wiki
	private static final Set<Integer> BALLISTAE = Set.of(
		19478,
		19481,
		23630,
		26712,
		27188
	);
	private static final Set<Integer> BLOWPIPES = Set.of(
		12926,
		28688
	);
	private static final Set<Integer> CROSSBOWS = Set.of(
		9174,
		9176,
		9177,
		9179,
		9181,
		9183,
		9185,
		21902,
		23601,
		25916,
		25918,
		26486,
		28053,
		21012
	);
	private static final Set<Integer> SHORTBOWS = Set.of(
		841,
		843,
		849,
		853,
		857,
		861,
		12788,
		20401,
		20403,
		20558,
		28794,
		22333,
		28555,
		23357,
		9705);
	private static final Set<Integer> LONGBOWS = Set.of(
		839,
		845,
		847,
		851,
		855,
		859,
		2883,
		11235, // Dark bow variants
		12765,
		12766,
		12767,
		12768,
		20408,
		27853,
		29599,
		29611);
	private static final Set<Integer> DARTS = Set.of(
		806, // Smithable darts and p variants
		807,
		808,
		809,
		810,
		811,
		812,
		813,
		814,
		815,
		816,
		817,
		818,
		3093, // Black darts and p
		3094,
		5628, // Smithable p+ and p++
		5629,
		5630,
		5631,
		5632,
		5633,
		5634,
		5635,
		5636,
		5637,
		5638,
		5639,
		5640,
		5641,
		11230, // Dragon
		11231,
		11233,
		11234,
		25849,
		25851,
		25855,
		25857);
	private static final Set<Integer> KNIVES = Set.of(
		863,
		864,
		865,
		866,
		867,
		868,
		869,
		870,
		871,
		872,
		873,
		874,
		875,
		876,
		5654,
		5655,
		5656,
		5657,
		5658,
		5659,
		5660,
		5661,
		5662,
		5663,
		5664,
		5665,
		5667,
		22804,
		22806,
		22808,
		22810);
	private static final Set<Integer> THROWNAXES = Set.of(
		800,
		801,
		802,
		803,
		804,
		805,
		20849,
		21207,
		22634,
		27912,
		27914);
	private static final Set<Integer> CHINCHOMPAS = Set.of(10033, 10034, 11959);
	private static final Set<Integer> COMP_BOWS = Set.of(
		10280,
		10282,
		10284,
		23983,
		23985,
		23901, // Gauntlet
		23902,
		23903,
		23855, // Corrupted Gauntlet
		23856,
		23857,
		25862, // Bowfa variants
		25865,
		25867,
		25869,
		25884,
		25886,
		25888,
		25890,
		25892,
		25894,
		25896,
		27187,
		20997, // Twisted bows
		28540
	);
	private static final Set<Integer> POWERED_STAVES = Set.of(
		11905,
		11907,
		11908,
		12899,
		12900,
		22288,
		22290,
		22292,
		22294,
		28583,
		28585,
		22552,
		22555,
		27662,
		27665,
		22323,
		22481,
		25731,
		25733,
		22516
	);
	private static final Set<Integer> STAVES = Set.of(
		1381,
		1383,
		1385,
		1387,
		1391,
		1393,
		1395,
		1397,
		1401,
		1403,
		1405,
		1407,
		3054,
		6563,
		11789,
		12000,
		12796,
		20733,
		20739,
		21200,
		11399,
		3053,
		6562,
		11787,
		11998,
		12795,
		20730,
		20736,
		21198,
		11791,
		12904,
		22296,
		23613,
		24144,
		28988, // Blue Moon Spear
		29849, // Blue Moon Spear
		10440,
		10442,
		10444,
		12199,
		12263,
		12275,
		4170,
		21255,
		2415,
		2416,
		2417,
		1409,
		12658,
		29594,
		24422,
		24423,
		24424,
		24425,
		25517,
		29602,
		29609,
		4710,
		4862,
		4863,
		4864,
		4865,
		23653,
		4675,
		20431,
		25489,
		25490,
		25491,
		25492,
		27624,
		27626,
		28260,
		28262,
		28264,
		28266,
		28473,
		28474,
		28475,
		28476,
		27785, // Thammaron's/Accursed sceptre (a) variants act more like regular staves
		27788,
		27676,
		27679,
		7639, // Rod of Ivandis
		7640,
		7641,
		7642,
		7643,
		7644,
		7645,
		7646,
		7647,
		7648,
		22398, // Ivandis flail
		24699, // Blisterwood flail
		30634 // Twinflame staff
	);
	private static final Set<Integer> WANDS = Set.of(
		6908,
		6910,
		6912,
		6914,
		12422,
		20553,
		20556,
		20560,
		21006,
		23626,
		30070 // Dragon hunter wand
	);
	private static final Set<Integer> HALBERDS = Set.of(
		1413,
		3190,
		3192,
		3194,
		3196,
		3198,
		3200,
		3204,
		6599,
		23849, // Corrupted Gauntlet Halberd
		23850,
		23851,
		23895, // Gauntlet Halberd
		23896,
		23897,
		23987,
		23989,
		24125,
		28049,
		29796 // Noxious halberd
	);
	// Non standard Weapons
	// Weapons that have different values than the typical weapon in that class or where there is no standard
	// values in List are [id, range, [longRangeModifier]]
	// Modifier only included if it is not the standard value of 2
	private static final Set<List<Integer>> NON_STANDARD_CROSSBOWS = Set.of(
		List.of(837, 10, 0), // Crossbow
		List.of(767, 5), // Phoenix crossbow
		List.of(11165, 5), // Phoenix crossbow
		List.of(11167, 5), // Phoenix crossbow
		List.of(8880, 6), // Dorgeshuun crossbow
		List.of(10156, 8), // Hunters' crossbow
		List.of(28869, 8), // Hunters' sunlight crossbow
		List.of(4734, 8), // Karil's crossbow
		List.of(4934, 8), // Karil's crossbow
		List.of(4935, 8), // Karil's crossbow
		List.of(4936, 8), // Karil's crossbow
		List.of(4937, 8), // Karil's crossbow
		List.of(23611, 8), // Armadyl crossbow
		List.of(11785, 8), // Armadyl crossbow
		List.of(26374, 8), // Zaryte crossbow
		List.of(27186, 8) // Zaryte crossbow
	);
	private static final Set<List<Integer>> NON_STANDARD_BOWS = Set.of(
		List.of(11708, 6), // Cursed goblin bow
		List.of(22547, 9, 1), // Craw's bow
		List.of(22550, 9, 1), // Craw's bow
		List.of(27652, 9, 1), // Webweaver bow
		List.of(27655, 9, 1), // Webweaver bow
		List.of(4827, 5), // Comp ogre bow
		List.of(29591, 10, 0), // Scorching bow
		List.of(27612, 6), // Venator bow
		List.of(27610, 6), // Venator bow
		List.of(30434, 6), // Echo Venator bow
		List.of(30436, 6) // Echo Venator bow
	);
	private static final Set<List<Integer>> NON_STANDARD_POWERED_STAVES = Set.of(
		List.of(22335, 6), // Starter staff
		List.of(28557, 6), // Starter Staff
		List.of(31113, 6), // Eye of ayak
		List.of(31115, 6), // Eye of ayak (uncharged)
		List.of(28796, 8), // Bone staff
		List.of(27275, 8), // Tumeken's shadow
		List.of(27277, 8), // Tumeken's shadow
		List.of(28547, 8), // Tumeken's shadow
		List.of(28549, 8), // Tumeken's shadow
		List.of(23898, 10, 0), // Crystal Staff
		List.of(23899, 10, 0), // Crystal Staff
		List.of(23900, 10, 0), // Crystal Staff
		List.of(23852, 10, 0), // Corrupted Staff
		List.of(23853, 10, 0), // Corrupted Staff
		List.of(23854, 10, 0) // Corrupted Staff
	);
	private static final Set<List<Integer>> NON_STANDARD_THROWN = Set.of(
		List.of(6522, 7), // Toktz-xil-ul
		List.of(29000, 6), // Eclipse atlatl
		List.of(28919, 5), // Tonalztics of ralos
		List.of(28922, 5), // Tonalztics of ralos
		List.of(30390, 7, 0), // Nature's reprisal
		List.of(30392, 7, 0), // Nature's reprisal
		List.of(30373, 6), // Drygore blowpipe
		List.of(30374, 6) // Drygore blowpipe
	);
	private static final Set<List<Integer>> NON_STANDARD_MELEE = Set.of(
		List.of(21015, 1, 4) // Dinh's Bulwark
	);

	public final Set<Pair<Set<Integer>, Function<Integer, Weapon>>> standardWeapons = new HashSet<>();
	public final Set<Pair<Set<List<Integer>>, Function<List<Integer>, Weapon>>> nonStandardWeapons = new HashSet<>();

	WeaponIds()
	{
		standardWeapons.add(Pair.of(SHORTBOWS, Shortbow::new));
		standardWeapons.add(Pair.of(LONGBOWS, Longbow::new));
		standardWeapons.add(Pair.of(DARTS, Dart::new));
		standardWeapons.add(Pair.of(KNIVES, Knife::new));
		standardWeapons.add(Pair.of(THROWNAXES, Thrownaxe::new));
		standardWeapons.add(Pair.of(CHINCHOMPAS, Chinchompa::new));
		standardWeapons.add(Pair.of(COMP_BOWS, Compbow::new));
		standardWeapons.add(Pair.of(CROSSBOWS, Crossbow::new));
		standardWeapons.add(Pair.of(BALLISTAE, Ballista::new));
		standardWeapons.add(Pair.of(BLOWPIPES, Blowpipe::new));
		standardWeapons.add(Pair.of(POWERED_STAVES, PoweredStaff::new));
		standardWeapons.add(Pair.of(STAVES, Staff::new));
		standardWeapons.add(Pair.of(WANDS, Wand::new));
		standardWeapons.add(Pair.of(HALBERDS, Halberd::new));

		nonStandardWeapons.add(Pair.of(NON_STANDARD_CROSSBOWS, Crossbow::new));
		nonStandardWeapons.add(Pair.of(NON_STANDARD_POWERED_STAVES, PoweredStaff::new));
		nonStandardWeapons.add(Pair.of(NON_STANDARD_BOWS, Bow::new));
		nonStandardWeapons.add(Pair.of(NON_STANDARD_THROWN, GenericThrown::new));
		nonStandardWeapons.add(Pair.of(NON_STANDARD_MELEE, Melee::new));
	}

}

package com.attackranges.weapons;

public class Chinchompa extends Weapon
{
	public Chinchompa(int id)
	{
		super(id);
		range = 9;
		longRangeModifier = 1;
	}
}

package com.attackranges.weapons;

public class Blowpipe extends Weapon
{
	public Blowpipe(int id)
	{
		super(id);
		range = 5;
	}
}

package com.attackranges.weapons;

public class Knife extends Weapon
{
	public Knife(int id)
	{
		super(id);
		range = 4;
	}
}

package com.attackranges.weapons;

import lombok.extern.slf4j.Slf4j;

@Slf4j
public class ManualCastable extends Weapon
{
	public ManualCastable(int id)
	{
		super(id);
	}

	public int getRange(String attackStyle, boolean showWhileManualCasting)
	{
		// Only display while auto-casting, unless user wants to see it always
		return attackStyle.equals("Casting") || showWhileManualCasting ? range : 0;
	}
}

package com.attackranges.weapons;

public class Ballista extends Weapon
{
	public Ballista(int id)
	{
		super(id);
		range = 9;
		longRangeModifier = 1;
	}
}

package com.attackranges.weapons;

import lombok.Getter;
import lombok.extern.slf4j.Slf4j;
import org.apache.commons.lang3.tuple.Pair;

import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.function.Function;

@Slf4j
@Getter
public class WeaponsGenerator
{
	private static final WeaponIds weaponIds = new WeaponIds();

	public static Map<Integer, Weapon> generate()
	{
		final Map<Integer, Weapon> standardWeapons = generateStandard(weaponIds.getStandardWeapons());
		final Map<Integer, Weapon> nonStandardWeapons = generateNonstandard(weaponIds.getNonStandardWeapons());
		final Map<Integer, Weapon> weapons = new HashMap<>();
		weapons.putAll(standardWeapons);
		weapons.putAll(nonStandardWeapons);
		return weapons;
	}

	private static Map<Integer, Weapon> generateStandard(
		Set<Pair<Set<Integer>, Function<Integer, Weapon>>> standardWeapons)
	{
		final Map<Integer, Weapon> weapons = new HashMap<>();
		for (Pair<Set<Integer>, Function<Integer, Weapon>> idsConstructorPair : standardWeapons)
		{
			for (Integer weaponId : idsConstructorPair.getLeft())
			{
				Weapon weapon = idsConstructorPair.getRight().apply(weaponId);
				if (weapon != null)
				{
					if (weapons.containsKey(weapon.id))
					{
						log.debug("Duplicate weapon entry.");
						log.debug("Trying to insert {}, Existing {}", weapon, weapons.get(weapon.id));
					}
					weapons.put(weapon.id, weapon);
				}
			}
		}
		return weapons;
	}

	private static Map<Integer, Weapon> generateNonstandard(
		Set<Pair<Set<List<Integer>>, Function<List<Integer>, Weapon>>> nonStandardWeapons)
	{
		final Map<Integer, Weapon> weapons = new HashMap<>();
		for (Pair<Set<List<Integer>>, Function<List<Integer>, Weapon>> idsConstructorPair : nonStandardWeapons)
		{
			for (List<Integer> weaponData : idsConstructorPair.getLeft())
			{
				Weapon weapon = idsConstructorPair.getRight().apply(weaponData);
				if (weapon != null)
				{
					weapons.put(weapon.id, weapon);
				}
			}
		}
		return weapons;
	}
}

package com.attackranges.weapons;

public class Wand extends ManualCastable
{
	public Wand(int id)
	{
		super(id);
		range = 10;
	}
}

package com.attackranges;

import static com.attackranges.Regions.SUPPORTED_REGIONS;
import static com.attackranges.Regions.getPlayerRegionId;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;
import lombok.Getter;
import lombok.Setter;
import net.runelite.api.Actor;
import net.runelite.api.Client;
import net.runelite.api.Item;
import net.runelite.api.ItemComposition;
import net.runelite.api.MenuEntry;
import net.runelite.api.NPC;
import net.runelite.api.WorldView;
import net.runelite.api.coords.WorldArea;
import net.runelite.api.coords.WorldPoint;
import net.runelite.client.util.WildcardMatcher;

public class AttackRangesUtils
{
	@Getter
	private static final Set<NPC> targetableNpcs = new HashSet<>();
	@Getter
	private static final Map<WorldPoint, Set<NPC>> npcPointMap = new HashMap<>();

	@Getter
	@Setter
	private static boolean isHotkeyRenderEnabled = false;

	public static Map<WorldPoint, Set<NPC>> mapNpcsToPoints(Client client)
	{
		Map<WorldPoint, Set<NPC>> npcPointMap = new HashMap<>();

		client.getLocalPlayer().getWorldView().npcs().stream()
			.filter(npc -> {
				String[] actions = npc.getComposition().getActions();
				return actions != null && actions.length > 1 && actions[1] != null;
			})
			.forEach(npc -> {
				List<WorldPoint> npcPoints = npc.getWorldArea().toWorldPointList();
				for (WorldPoint npcPoint : npcPoints) {
					Set<NPC> npcSet = npcPointMap.computeIfAbsent(npcPoint, k -> new HashSet<>());
					npcSet.add(npc);
				}
			});

		return npcPointMap;
	}

	public static boolean isAllowlistedWeapon(Item weapon, List<String> allowListedWeapons, Client client)
	{
		if (allowListedWeapons.isEmpty())
		{
			return true;
		}

		if (weapon == null)
		{
			return false;
		}

		ItemComposition weaponComposition = client.getItemDefinition(weapon.getId());
		for (String pattern : allowListedWeapons)
		{
			if (WildcardMatcher.matches(pattern, weaponComposition.getName()))
			{
				return true;
			}
		}
		return false;
	}

	public static WorldPoint[][] getVisiblePoints(Actor actor, int dist, Client client)
	{
		targetableNpcs.clear();
		npcPointMap.clear();

		if (dist < 1)
		{
			return new WorldPoint[0][0];
		}
		npcPointMap.putAll(mapNpcsToPoints(client));

		final WorldArea wa = actor.getWorldArea();
		final WorldView wv = actor.getWorldView();
		final int areaWidth = wa.getWidth() + (dist * 2);
		final int areaHeight = wa.getHeight() + (dist * 2);
		final WorldPoint[][] points = new WorldPoint[areaWidth][areaHeight];

		int startX = wa.getX() - dist;
		int startY = wa.getY() - dist;
		int maxX = wa.getX() + wa.getWidth() + dist - 1;
		int maxY = wa.getY() + wa.getHeight() + dist - 1;

		for (int x = startX, i = 0; x < maxX + 1; x++, i++)
		{
			for (int y = startY, j = 0; y < maxY + 1; y++, j++)
			{
				WorldPoint currentPoint = new WorldPoint(x, y, wa.getPlane());
				if (currentPoint.isInArea(wa) || wa.hasLineOfSightTo(wv, currentPoint))
				{
					points[i][j] = currentPoint;
					if (npcPointMap.containsKey(currentPoint))
					{
						targetableNpcs.addAll(npcPointMap.get(currentPoint));
					}
				}
			}
		}
		return points;
	}

	public static boolean shouldRender(
		AttackRangesPlugin plugin,
		Client client,
		AttackRangesConfig config,
		AttackRangesConfig.EnableState enableState)
	{
		if (plugin.playerAttackRange < 1
			|| !isAllowlistedWeapon(
			plugin.getEquippedWeapon(),
			plugin.getAllowListedWeapons(),
			client)
			|| (!config.getShowDisplayMelee() && plugin.playerAttackRange == 1)
		)
		{
			return false;
		}

		switch (enableState)
		{
			case ON:
				return true;
			case HOTKEY_MODE:
				return isHotkeyRenderEnabled;
			case INSTANCES_ONLY:
				Integer regionId = getPlayerRegionId(client);
				return regionId != null && SUPPORTED_REGIONS.contains(regionId);
			case OFF:
			default:
				return false;
		}
	}

	public static boolean isOuterTile(WorldPoint[][] points, int i, int j)
	{
		boolean isTopEdge = j == 0 || points[i][j - 1] == null;
		boolean isBottomEdge = j == points.length - 1 || points[i][j + 1] == null;
		boolean isLeftEdge = i == 0 || points[i - 1][j] == null;
		boolean isRightEdge = i == points[0].length - 1 || points[i + 1][j] == null;

		return isTopEdge || isBottomEdge || isLeftEdge || isRightEdge;
	}

	public static void handleDragProtection(MenuEntry[] menuEntries, Client client)
	{
		MenuEntry topEntry = menuEntries[menuEntries.length - 1];
		NPC target = topEntry.getNpc();

		if (target == null || !topEntry.getOption().equals("Attack"))
		{
			return;
		}

		int examineEntryIndex = -1;
		for (int i = 0; i < menuEntries.length; i++)
		{
			if (menuEntries[i].getOption().equals("Examine"))
			{
				examineEntryIndex = i;
				break;
			}

		}

		if (examineEntryIndex == -1 || targetableNpcs.contains(target))
		{
			return;
		}

		swapOptions(menuEntries, menuEntries.length - 1, examineEntryIndex);
		client.getMenu().setMenuEntries(menuEntries);
	}

	private static void swapOptions(MenuEntry[] entries, int i, int j)
	{
		MenuEntry temp = entries[i];
		entries[i] = entries[j];
		entries[j] = temp;
	}
}
package com.attackranges;

import static com.attackranges.AttackRangesUtils.getVisiblePoints;
import static com.attackranges.AttackRangesUtils.handleDragProtection;
import static com.attackranges.Regions.isInRegion;
import com.attackranges.weapons.ManualCastable;
import com.attackranges.weapons.Melee;
import com.attackranges.weapons.Weapon;
import com.attackranges.weapons.WeaponsGenerator;
import com.google.common.base.Splitter;
import com.google.inject.Provides;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import javax.inject.Inject;
import lombok.Getter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.EnumID;
import net.runelite.api.EquipmentInventorySlot;
import net.runelite.api.GameState;
import net.runelite.api.Item;
import net.runelite.api.ItemContainer;
import net.runelite.api.MenuEntry;
import net.runelite.api.ParamID;
import net.runelite.api.StructComposition;
import net.runelite.api.coords.WorldPoint;
import net.runelite.api.events.GameStateChanged;
import net.runelite.api.events.GameTick;
import net.runelite.api.events.ItemContainerChanged;
import net.runelite.api.events.NpcDespawned;
import net.runelite.api.events.PostMenuSort;
import net.runelite.api.events.VarbitChanged;
import net.runelite.api.gameval.InventoryID;
import net.runelite.api.gameval.NpcID;
import net.runelite.api.gameval.VarPlayerID;
import net.runelite.api.gameval.VarbitID;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.events.ConfigChanged;
import net.runelite.client.input.KeyManager;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.plugins.PluginDescriptor;
import net.runelite.client.ui.overlay.OverlayManager;
import net.runelite.client.util.HotkeyListener;

@Slf4j
@PluginDescriptor(
	name = "Attack Ranges"
)
public class AttackRangesPlugin extends Plugin
{
	private final Map<Integer, Weapon> weaponsMap = new HashMap<>();
	@Inject
	private net.runelite.api.Client client;
	@Inject
	private AttackRangesConfig config;
	@Inject
	private ConfigManager configManager;
	@Inject
	private AttackRangesOverlay overlay;
	@Inject
	private OverlayManager overlayManager;
	@Inject
	private ClientThread clientThread;
	@Inject
	private KeyManager keyManager;
	@Inject
	private UpdateManager updateManager;

	private final Splitter allowListSplitter = Splitter.on(',').omitEmptyStrings().trimResults();
	@Getter
	private Item equippedWeapon;
	@Getter
	private List<String> allowListedWeapons = new ArrayList<>();
	public WorldPoint[][] playerVisiblePoints;
	public Integer playerAttackRange = -1;
	public Integer externalRangeModifier = 0;

	private static final int MYOPIA_LEVEL_VARBIT_ID = 9795;
	// private static final int RELENTLESS_LEVEL_VARBIT_ID = 9798;

	private final String OVERLAY_RENDER_ENABLED_KEY = "player-overlay-render-enabled";

	@Override
	protected void startUp()
	{
		overlayManager.add(overlay);
		weaponsMap.putAll(WeaponsGenerator.generate());
		keyManager.registerKeyListener(playerOverlayEnabledHotkeyListener);

		allowListedWeapons = allowListSplitter.splitToList(config.getAllowListedWeapons());

		String savedRenderState = configManager.getConfiguration(
			AttackRangesConfig.ATTACK_RANGES_GROUP,
			OVERLAY_RENDER_ENABLED_KEY);

		if (savedRenderState != null)
		{
			AttackRangesUtils.setHotkeyRenderEnabled(Boolean.parseBoolean(savedRenderState));
		}
	}

	@Override
	protected void shutDown()
	{
		reset();
	}

	@Subscribe
	public void onConfigChanged(ConfigChanged event)
	{
		if (!AttackRangesConfig.ATTACK_RANGES_GROUP.equals(event.getGroup()))
		{
			return;
		}

		switch (event.getKey())
		{
			case "npcHighlightEnableState":
			case "playerEnableState":
				if (Objects.equals(event.getNewValue(), AttackRangesConfig.EnableState.HOTKEY_MODE.toString()))
				{
					if (config.displayHotkeyMode() == AttackRangesConfig.DisplayHotkeyMode.HOLD)
					{
						AttackRangesUtils.setHotkeyRenderEnabled(false);
					}
				}
				return;
			case "displayHotkeyMode":
				if (Objects.equals(event.getNewValue(), AttackRangesConfig.DisplayHotkeyMode.HOLD.name()))
				{
					AttackRangesUtils.setHotkeyRenderEnabled(false);
				}
				return;
			case "allowListedWeapons":
				allowListedWeapons = allowListSplitter.splitToList(event.getNewValue());
			case "showManualCasting":
			case "showSpecialAttack":
				clientThread.invoke(() -> {
					updatePlayerAttackRange();
					playerVisiblePoints = getVisiblePoints(client.getLocalPlayer(), playerAttackRange, client);
				});
		}
	}

	@Subscribe
	public void onGameStateChanged(GameStateChanged event)
	{
		final GameState state = event.getGameState();

		if (state == GameState.LOGGED_IN && !updateManager.hasLatestVersion())
		{
			updateManager.sendUpdateMessage();
		}
	}

	@Subscribe
	protected void onGameTick(GameTick event)
	{
		playerVisiblePoints = getVisiblePoints(client.getLocalPlayer(), playerAttackRange, client);

		if (!isInRegion(client, Regions.FORTIS_COLOSSEUM) && externalRangeModifier != 0)
		{
			externalRangeModifier = 0;
			updatePlayerAttackRange();
		}
	}

	@Subscribe(priority = -1)
	public void onPostMenuSort(PostMenuSort event)
	{
		MenuEntry[] menuEntries = client.getMenu().getMenuEntries();
		if (menuEntries.length == 0 || !config.getDragProtection())
		{
			return;
		}

		handleDragProtection(menuEntries, client);
	}

	@Subscribe
	public void onNpcDespawned(NpcDespawned event)
	{
		if (event.getNpc().getId() != NpcID.COLOSSEUM_MASTER)
		{
			return;
		}

		int myopiaLevel = 0;

		try
		{
			myopiaLevel = client.getVarbitValue(MYOPIA_LEVEL_VARBIT_ID);
		}
		catch (Exception e)
		{
			log.debug("Failed to get myopia level");
		}

		externalRangeModifier = myopiaLevel * -2;
		updatePlayerAttackRange();
	}

	@Subscribe
	public void onVarbitChanged(VarbitChanged event)
	{
		if (event.getVarpId() == VarPlayerID.COM_MODE || event.getVarbitId() == VarbitID.COMBAT_WEAPON_CATEGORY)
		{
			updatePlayerAttackRange();
		}
	}

	@Subscribe
	public void onItemContainerChanged(ItemContainerChanged event)
	{
		final ItemContainer equipment = client.getItemContainer(InventoryID.WORN);
		if (equipment == null)
		{
			equippedWeapon = null;
			return;
		}

		equippedWeapon = equipment.getItem(EquipmentInventorySlot.WEAPON.getSlotIdx());
		updatePlayerAttackRange();
	}

	private final HotkeyListener playerOverlayEnabledHotkeyListener = new HotkeyListener(() -> config.displayHotkey())
	{
		@Override
		public void hotkeyPressed()
		{
			if (config.playerEnableState() != AttackRangesConfig.EnableState.HOTKEY_MODE &&
				config.npcHighlightEnableState() != AttackRangesConfig.EnableState.HOTKEY_MODE)
			{
				return;
			}

			if (config.displayHotkeyMode() == AttackRangesConfig.DisplayHotkeyMode.HOLD)
			{
				AttackRangesUtils.setHotkeyRenderEnabled(true);
			}
			else
			{
				AttackRangesUtils.setHotkeyRenderEnabled(!AttackRangesUtils.isHotkeyRenderEnabled());
			}
		}

		@Override
		public void hotkeyReleased()
		{
			if (config.playerEnableState() != AttackRangesConfig.EnableState.HOTKEY_MODE &&
				config.npcHighlightEnableState() != AttackRangesConfig.EnableState.HOTKEY_MODE)
			{
				return;
			}
			if (config.displayHotkeyMode() == AttackRangesConfig.DisplayHotkeyMode.HOLD)
			{
				AttackRangesUtils.setHotkeyRenderEnabled(false);
			}
		}
	};

	@Provides
	AttackRangesConfig provideConfig(ConfigManager configManager)
	{
		return configManager.getConfig(AttackRangesConfig.class);
	}

	private void updatePlayerAttackRange()
	{
		final int attackStyleVarbit = client.getVarpValue(VarPlayerID.COM_MODE);
		final int weaponTypeVarbit = client.getVarbitValue(VarbitID.COMBAT_WEAPON_CATEGORY);
		if (equippedWeapon == null)
		{
			playerAttackRange = 1;
			return;
		}

		if (!weaponsMap.containsKey(equippedWeapon.getId()))
		{
			playerAttackRange = 1;
			return;
		}

		Weapon weapon = weaponsMap.get(equippedWeapon.getId());
		String attackStyle = getWeaponAttackStyle(attackStyleVarbit, weaponTypeVarbit);

		int unmodifiedRange = 1;

		if (weapon instanceof ManualCastable)
		{
			unmodifiedRange = ((ManualCastable) weapon).getRange(attackStyle, config.getManualCastingMode());
		}
		else if (weapon instanceof Melee)
		{
			unmodifiedRange = config.getShowSpecialAttack() ? ((Melee) weapon).getSpecialAttackRange() : 1;
			playerAttackRange = unmodifiedRange;
			return;
		}
		else
		{
			unmodifiedRange = weapon.getRange(attackStyle);
		}

		playerAttackRange = Math.max(unmodifiedRange + externalRangeModifier, 1);
	}

	private String getWeaponAttackStyle(Integer attackStyleVarbit, Integer weaponTypeVarbit)
	{
		int weaponStyleEnum = client.getEnum(EnumID.WEAPON_STYLES).getIntValue(weaponTypeVarbit);
		int[] weaponStyleStructs = client.getEnum(weaponStyleEnum).getIntVals();
		StructComposition attackStylesStruct = client.getStructComposition(weaponStyleStructs[attackStyleVarbit]);
		return attackStylesStruct.getStringValue(ParamID.ATTACK_STYLE_NAME);
	}

	private void reset()
	{
		overlayManager.remove(overlay);
		configManager.setConfiguration(AttackRangesConfig.ATTACK_RANGES_GROUP, OVERLAY_RENDER_ENABLED_KEY, AttackRangesUtils.isHotkeyRenderEnabled());
		keyManager.unregisterKeyListener(playerOverlayEnabledHotkeyListener);
		AttackRangesUtils.getTargetableNpcs().clear();
		AttackRangesUtils.getNpcPointMap().clear();
		weaponsMap.clear();
	}
}


package com.attackranges;

import com.google.inject.Inject;
import net.runelite.api.ChatMessageType;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.chat.QueuedMessage;
import net.runelite.client.config.ConfigManager;

public class UpdateManager
{
	@Inject
	private ChatMessageManager chatMessageManager;

	@Inject
	private ConfigManager configManager;

	private final String LAST_VERSION_SEEN_CONFIG_KEY = "last-version";
	private final String UPDATE_TEXT = "Attack Ranges has been updated to 1.3 and can now display the Bulwark special attack range";
	private final String LATEST_VERSION = "1.3";

	public void sendUpdateMessage()
	{
		if (hasLatestVersion())
		{
			return;
		}

		configManager.setConfiguration(AttackRangesConfig.ATTACK_RANGES_GROUP, LAST_VERSION_SEEN_CONFIG_KEY, LATEST_VERSION);

		chatMessageManager.queue(QueuedMessage.builder()
			.type(ChatMessageType.GAMEMESSAGE)
			.runeLiteFormattedMessage(UPDATE_TEXT)
			.build());
	}

	public boolean hasLatestVersion()
	{
		String lastVersionChecked = configManager.getConfiguration(AttackRangesConfig.ATTACK_RANGES_GROUP, LAST_VERSION_SEEN_CONFIG_KEY);
		return lastVersionChecked != null && lastVersionChecked.equals(LATEST_VERSION);
	}
}

package com.attackranges;

import static com.attackranges.AttackRangesUtils.isOuterTile;
import static com.attackranges.AttackRangesUtils.shouldRender;
import com.google.inject.Inject;
import java.awt.Shape;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Actor;
import net.runelite.api.Client;
import net.runelite.api.NPC;
import net.runelite.api.Perspective;
import net.runelite.api.Point;
import net.runelite.api.WorldView;
import net.runelite.api.coords.LocalPoint;
import net.runelite.api.coords.WorldPoint;
import net.runelite.client.ui.overlay.Overlay;
import net.runelite.client.ui.overlay.OverlayPosition;
import net.runelite.client.ui.overlay.OverlayUtil;

import java.awt.BasicStroke;
import java.awt.Color;
import java.awt.Dimension;
import java.awt.Graphics2D;
import java.awt.Polygon;

@Slf4j
class AttackRangesOverlay extends Overlay
{
	private final Client client;
	private final AttackRangesConfig config;
	private final AttackRangesPlugin plugin;

	@Inject
	private AttackRangesOverlay(Client client, AttackRangesConfig config, AttackRangesPlugin plugin)
	{
		this.client = client;
		this.config = config;
		this.plugin = plugin;
		setPosition(OverlayPosition.DYNAMIC);
	}

	@Override
	public Dimension render(Graphics2D graphics)
	{
		if (shouldRender(plugin, client, config, config.playerEnableState()))
		{
			renderPlayer(graphics);
		}

		if (shouldRender(plugin, client, config, config.npcHighlightEnableState()))
		{
			renderTargetableNpcs(graphics);
		}
		return null;
	}

	private void renderTargetableNpcs(Graphics2D graphics)
	{
		for (NPC npc : AttackRangesUtils.getTargetableNpcs())
		{
			Shape npcClickbox = npc.getConvexHull();
			renderPoly(
				graphics,
				config.npcHighlightOutlineColor(),
				config.npcOutlineSize(),
				config.npcHighlightFillColor(),
				npcClickbox);
		}
	}

	private void renderPlayer(Graphics2D graphics)
	{
		drawAttackableSquares(graphics, client.getLocalPlayer(), plugin.playerVisiblePoints, config.rangeBorderColor());
	}

	private void drawAttackableSquares(Graphics2D graphics, Actor actor, WorldPoint[][] points, Color color)
	{
		if (points == null)
		{
			return;
		}

		WorldView wv = actor.getWorldView();
		for (int i = 0; i < points.length; i++)
		{
			for (int j = 0; j < points[i].length; j++)
			{
				WorldPoint wp = points[i][j];
				if (wp == null)
				{
					continue;
				}
				switch (config.displayMode())
				{
					case TILES:
						drawTile(graphics, wp, wv, color);
						continue;
					case EDGE_TILES:
						drawTile(graphics, wp, wv, points, i, j, color);
						continue;
					case BORDER:
						drawBorders(graphics, wp, wv, points, i, j, color);
				}
			}
		}
	}

	private void drawTile(Graphics2D graphics, WorldPoint wp, WorldView wv, Color borderColor)
	{
		LocalPoint lp = LocalPoint.fromWorld(wv, wp);
		if (lp != null)
		{
			Polygon p = Perspective.getCanvasTilePoly(client, lp);
			if (p != null)
			{
				OverlayUtil.renderPolygon(
					graphics,
					p,
					borderColor,
					config.rangeFillColor(),
					new BasicStroke(config.borderSize()));
			}
		}
	}
	private void drawTile(
		Graphics2D graphics, WorldPoint wp, WorldView wv, WorldPoint[][] points, int i, int j, Color borderColor)
	{
		if (!isOuterTile(points, i, j))
		{
			return;
		}

		drawTile(graphics, wp, wv, borderColor);
	}


	private void drawBorders(
		Graphics2D graphics, WorldPoint wp, WorldView wv, WorldPoint[][] points, int i, int j, Color borderColor)
	{
		graphics.setColor(borderColor);
		graphics.setStroke(new BasicStroke(config.borderSize()));
		drawTopBorder(graphics, wp, wv, points, i, j);
		drawBottomBorder(graphics, wp, wv, points, i, j);
		drawLeftBorder(graphics, wp, wv, points, i, j);
		drawRightBorder(graphics, wp, wv, points, i, j);

		LocalPoint lp = LocalPoint.fromWorld(wv, wp);
		if (lp != null)
		{
			graphics.setColor(config.rangeFillColor());
			Polygon p = Perspective.getCanvasTilePoly(client, lp);
			if (p != null)
			{
				graphics.fill(p);
			}
		}
	}

	private void drawTopBorder(Graphics2D graphics, WorldPoint wp, WorldView wv, WorldPoint[][] points, int i, int j)
	{
		LocalPoint lp = LocalPoint.fromWorld(wv, wp);
		if (lp != null && (j == points.length - 1 || points[i][j + 1] == null))
		{
			Point start = Perspective.localToCanvas(client, new LocalPoint(
					lp.getX() + Perspective.LOCAL_HALF_TILE_SIZE,
					lp.getY() + Perspective.LOCAL_HALF_TILE_SIZE - 1,
					wv),
				wp.getPlane());
			Point end = Perspective.localToCanvas(client,
				new LocalPoint(
					lp.getX() - Perspective.LOCAL_HALF_TILE_SIZE + 1,
					lp.getY() + Perspective.LOCAL_HALF_TILE_SIZE,
					wv),
				wp.getPlane());
			drawLine(graphics, start, end);
		}
	}

	private void drawBottomBorder(Graphics2D graphics, WorldPoint wp, WorldView wv, WorldPoint[][] points, int i, int j)
	{
		LocalPoint lp = LocalPoint.fromWorld(wv, wp);
		if (lp != null && (j == 0 || points[i][j - 1] == null))
		{
			Point start = Perspective.localToCanvas(client, new LocalPoint(
					lp.getX() + Perspective.LOCAL_HALF_TILE_SIZE - 1,
					lp.getY() - Perspective.LOCAL_HALF_TILE_SIZE,
					wv),
				wp.getPlane());
			Point end = Perspective.localToCanvas(client, new LocalPoint(
					lp.getX() - Perspective.LOCAL_HALF_TILE_SIZE + 1,
					lp.getY() - Perspective.LOCAL_HALF_TILE_SIZE,
					wv),
				wp.getPlane());
			drawLine(graphics, start, end);
		}
	}

	private void drawLeftBorder(Graphics2D graphics, WorldPoint wp, WorldView wv, WorldPoint[][] points, int i, int j)
	{
		LocalPoint lp = LocalPoint.fromWorld(wv, wp);
		if (lp != null && (i == points.length - 1 || points[i + 1][j] == null))
		{
			Point start = Perspective.localToCanvas(client, new LocalPoint(
					lp.getX() + Perspective.LOCAL_HALF_TILE_SIZE,
					lp.getY() - Perspective.LOCAL_HALF_TILE_SIZE + 1,
					wv),
				wp.getPlane());
			Point end = Perspective.localToCanvas(client, new LocalPoint(
					lp.getX() + Perspective.LOCAL_HALF_TILE_SIZE,
					lp.getY() + Perspective.LOCAL_HALF_TILE_SIZE - 1,
					wv),
				wp.getPlane());
			drawLine(graphics, start, end);
		}
	}

	private void drawRightBorder(Graphics2D graphics, WorldPoint wp, WorldView wv, WorldPoint[][] points, int i, int j)
	{
		LocalPoint lp = LocalPoint.fromWorld(wv, wp);
		if (lp != null && (i == 0 || points[i - 1][j] == null))
		{
			Point start = Perspective.localToCanvas(client, new LocalPoint(
					lp.getX() - Perspective.LOCAL_HALF_TILE_SIZE,
					lp.getY() - Perspective.LOCAL_HALF_TILE_SIZE + 1,
					wv),
				wp.getPlane());
			Point end = Perspective.localToCanvas(client, new LocalPoint(
					lp.getX() - Perspective.LOCAL_HALF_TILE_SIZE,
					lp.getY() + Perspective.LOCAL_HALF_TILE_SIZE - 1,
					wv),
				wp.getPlane());
			drawLine(graphics, start, end);
		}
	}

	private void drawLine(Graphics2D graphics, Point start, Point end)
	{
		if (start == null || end == null)
		{
			return;
		}
		graphics.drawLine(start.getX(), start.getY(), end.getX(), end.getY());
	}

	private void renderPoly(Graphics2D graphics, Color borderColor, float borderWidth, Color fillColor, Shape polygon)
	{
		if (polygon != null)
		{
			graphics.setColor(borderColor);
			graphics.setStroke(new BasicStroke(borderWidth));
			graphics.draw(polygon);
			graphics.setColor(fillColor);
			graphics.fill(polygon);
		}
	}
}


package com.attackranges;

import net.runelite.client.RuneLite;
import net.runelite.client.externalplugins.ExternalPluginManager;

public class AttackRangesPluginTest
{
	public static void main(String[] args) throws Exception
	{
		ExternalPluginManager.loadBuiltin(AttackRangesPlugin.class);
		RuneLite.main(args);
	}
}
