package com.cluejuggler;

import java.awt.Color;
import net.runelite.client.config.Alpha;
import net.runelite.client.config.Config;
import net.runelite.client.config.ConfigGroup;
import net.runelite.client.config.ConfigItem;
import net.runelite.client.config.ConfigSection;

@ConfigGroup("cluejuggler")
public interface ClueJugglerConfig extends Config
{
	@ConfigItem(
		keyName = "showIndicator",
		name = "Show Clue Indicator",
		description = "Display whether clues are good, bad, or unsure",
		position = 0
	)
	default boolean showIndicator()
	{
		return true;
	}

	@ConfigSection(
		name = "Clue Highlighter",
		description = "Settings for highlighting clue tiles",
		position = 10
	)
	String clueHighlighterSection = "clueHighlighterSection";

	@ConfigItem(
		keyName = "clueHighlights",
		name = "Enable Clue Highlights",
		description = "Highlight the clue tile and show good/bad/unsure text on top of it",
		section = clueHighlighterSection,
		position = 1
	)
	default boolean clueHighlights()
	{
		return true;
	}

	@Alpha
	@ConfigItem(
		keyName = "goodClueTileColor",
		name = "Good Clue Tile Color",
		description = "Color for highlighting good clue tiles",
		section = clueHighlighterSection,
		position = 2
	)
	default Color goodClueTileColor()
	{
		return new Color(0, 255, 0, 100);
	}

	@Alpha
	@ConfigItem(
		keyName = "badClueTileColor",
		name = "Bad Clue Tile Color",
		description = "Color for highlighting bad clue tiles",
		section = clueHighlighterSection,
		position = 3
	)
	default Color badClueTileColor()
	{
		return new Color(255, 0, 0, 100);
	}

	@Alpha
	@ConfigItem(
		keyName = "unsureClueTileColor",
		name = "Unsure Clue Tile Color",
		description = "Color for highlighting unsure clue tiles",
		section = clueHighlighterSection,
		position = 4
	)
	default Color unsureClueTileColor()
	{
		return new Color(255, 255, 0, 100);
	}

	@Alpha
	@ConfigItem(
		keyName = "goodClueTextColor",
		name = "Good Clue Text Color",
		description = "Color for good clue text",
		section = clueHighlighterSection,
		position = 5
	)
	default Color goodClueTextColor()
	{
		return Color.GREEN;
	}

	@Alpha
	@ConfigItem(
		keyName = "badClueTextColor",
		name = "Bad Clue Text Color",
		description = "Color for bad clue text",
		section = clueHighlighterSection,
		position = 6
	)
	default Color badClueTextColor()
	{
		return Color.RED;
	}

	@Alpha
	@ConfigItem(
		keyName = "unsureClueTextColor",
		name = "Unsure Clue Text Color",
		description = "Color for unsure clue text",
		section = clueHighlighterSection,
		position = 7
	)
	default Color unsureClueTextColor()
	{
		return Color.YELLOW;
	}

	@ConfigItem(
		keyName = "deprioritizeBadClues",
		name = "Deprioritize Bad Clues",
		description = "Makes 'Walk here' the default action for bad clues to prevent accidental pickup",
		position = 20
	)
	default boolean deprioritizeBadClues()
	{
		return true;
	}

	@ConfigItem(
		keyName = "customLists",
		name = "Custom Lists",
		description = "JSON string of custom clue lists",
		hidden = true
	)
	default String customLists()
	{
		return "[]";
	}
}


package com.cluejuggler;

import com.cluejuggler.model.ClueList;
import com.cluejuggler.overlay.ClueJugglerOverlay;
import com.cluejuggler.overlay.ClueJugglerWorldOverlay;
import com.cluejuggler.service.ClueListService;
import com.cluejuggler.service.ClueLookupService;
import com.cluejuggler.service.ClueTextService;
import com.cluejuggler.service.ClueTrackingService;
import com.cluejuggler.ui.ClueJugglerPanel;
import com.google.inject.Provides;
import java.awt.image.BufferedImage;
import java.util.Map;
import javax.inject.Inject;
import lombok.Getter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.ItemComposition;
import net.runelite.api.MenuEntry;
import net.runelite.api.TileItem;
import net.runelite.api.coords.WorldPoint;
import net.runelite.api.events.GameTick;
import net.runelite.api.events.ItemDespawned;
import net.runelite.api.events.MenuEntryAdded;
import net.runelite.api.events.MenuOptionClicked;
import net.runelite.api.events.WidgetLoaded;
import net.runelite.api.gameval.InterfaceID;
import net.runelite.api.gameval.ItemID;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.game.ItemManager;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.plugins.PluginDependency;
import net.runelite.client.plugins.PluginDescriptor;
import net.runelite.client.plugins.cluescrolls.ClueScrollConfig;
import net.runelite.client.plugins.cluescrolls.ClueScrollPlugin;
import net.runelite.client.plugins.cluescrolls.clues.ClueScroll;
import net.runelite.client.ui.ClientToolbar;
import net.runelite.client.ui.NavigationButton;
import net.runelite.client.ui.overlay.OverlayManager;
import net.runelite.client.util.ImageUtil;

@Slf4j
@PluginDescriptor(
	name = "Clue Juggler",
	description = "Track good and bad clue steps for juggling",
	tags = {"clues", "juggling", "tracker"}
)
@PluginDependency(ClueScrollPlugin.class)
public class ClueJugglerPlugin extends Plugin
{
	@Inject
	private Client client;

	@Inject
	private ClientToolbar clientToolbar;

	@Inject
	private ClientThread clientThread;

	@Inject
	private ItemManager itemManager;

	@Inject
	private OverlayManager overlayManager;

	@Inject
	private ClueJugglerOverlay overlay;

	@Inject
	private ClueJugglerWorldOverlay worldOverlay;

	@Inject
	private ClueScrollPlugin clueScrollPlugin;

	@Inject
	@Getter
	private ClueJugglerConfig config;

	@Inject
	private ConfigManager configManager;

	@Inject
	@Getter
	private ClueTextService textService;

	@Inject
	@Getter
	private ClueTrackingService trackingService;

	@Inject
	@Getter
	private ClueListService listService;

	@Inject
	@Getter
	private ClueLookupService lookupService;

	@Getter
	private ClueJugglerPanel panel;
	private NavigationButton navButton;
	private String currentClueText = null;

	@Override
	protected void startUp() throws Exception
	{
		panel = injector.getInstance(ClueJugglerPanel.class);
		panel.setPlugin(this);

		BufferedImage icon = ImageUtil.loadImageResource(getClass(), "/cluejuggler.png");

		navButton = NavigationButton.builder()
			.tooltip("Clue Juggler")
			.icon(icon)
			.priority(5)
			.panel(panel)
			.build();

		clientToolbar.addNavigation(navButton);
		overlayManager.add(overlay);
		overlayManager.add(worldOverlay);
	}

	@Override
	protected void shutDown() throws Exception
	{
		clientToolbar.removeNavigation(navButton);
		overlayManager.remove(overlay);
		overlayManager.remove(worldOverlay);
		currentClueText = null;
		trackingService.clearTrackedClues();
	}

	@Subscribe
	public void onWidgetLoaded(WidgetLoaded event)
	{
		if (event.getGroupId() >= InterfaceID.TRAIL_MAP01 && event.getGroupId() <= InterfaceID.TRAIL_MAP11)
		{
			updateClueTextFromWidget();
		}
		else if (event.getGroupId() == InterfaceID.TRAIL_CLUETEXT)
		{
			updateClueTextFromWidget();
		}
	}

	@Subscribe
	public void onGameTick(GameTick event)
	{
		ClueScroll clue = clueScrollPlugin.getClue();
		if (clue != null && clue != trackingService.getLastProcessedClue())
		{
			trackingService.setLastProcessedClue(clue);
			trackingService.setLastClueWasTracked(false);
			clientThread.invokeLater(this::updateClueTextFromWidget);
		}
		else if (clue == null)
		{
			trackingService.setLastProcessedClue(null);
			trackingService.setLastClueWasTracked(false);
		}
	}

	private void updateClueTextFromWidget()
	{
		ClueScroll clue = clueScrollPlugin.getClue();
		if (clue == null)
		{
			return;
		}

		if (!shouldTrackOnPickup() && !trackingService.wasLastClueTracked())
		{
			net.runelite.api.ItemContainer inventory = client.getItemContainer(net.runelite.api.gameval.InventoryID.INV);
			if (inventory != null)
			{
				for (net.runelite.api.Item item : inventory.getItems())
				{
					if (item == null || item.getId() <= 0)
					{
						continue;
					}

					ItemComposition itemComp = itemManager.getItemComposition(item.getId());
					if (itemComp != null && (itemComp.getName().startsWith("Clue scroll")
						|| itemComp.getName().startsWith("Challenge scroll")
						|| itemComp.getName().startsWith("Treasure scroll")))
					{
						ClueScroll foundClue = lookupService.findClueScroll(item.getId());
						boolean shouldTrack = false;

						if (foundClue == clue)
						{
							shouldTrack = true;
						}
						else if ((item.getId() == ItemID.TRAIL_CLUE_BEGINNER || item.getId() == 23182) &&
							(clue instanceof net.runelite.client.plugins.cluescrolls.clues.BeginnerMapClue ||
							 clue instanceof net.runelite.client.plugins.cluescrolls.clues.AnagramClue))
						{
							shouldTrack = true;
						}
						else if (item.getId() == ItemID.TRAIL_CLUE_MASTER &&
							!(clue instanceof net.runelite.client.plugins.cluescrolls.clues.CrypticClue ||
							  clue instanceof net.runelite.client.plugins.cluescrolls.clues.CipherClue ||
							  clue instanceof net.runelite.client.plugins.cluescrolls.clues.AnagramClue ||
							  clue instanceof net.runelite.client.plugins.cluescrolls.clues.CoordinateClue ||
							  clue instanceof net.runelite.client.plugins.cluescrolls.clues.MusicClue ||
							  clue instanceof net.runelite.client.plugins.cluescrolls.clues.EmoteClue ||
							  clue instanceof net.runelite.client.plugins.cluescrolls.clues.MapClue ||
							  clue instanceof net.runelite.client.plugins.cluescrolls.clues.BeginnerMapClue))
						{
							shouldTrack = true;
						}

						if (shouldTrack)
						{
							if (item.getId() == ItemID.TRAIL_CLUE_BEGINNER || item.getId() == ItemID.TRAIL_CLUE_MASTER)
							{
								String clueText = textService.generateClueTextFromClue(clue);
								if (clueText != null && !clueText.isEmpty())
								{
									trackingService.trackClueByText(clueText, clue);
								}
							}
							else
							{
								trackingService.trackClue(item.getId(), clue);
							}
							trackingService.setLastClueWasTracked(true);
							break;
						}
					}
				}
			}
		}

		clientThread.invokeLater(() ->
		{
			String difficulty = textService.getClueDifficulty(clue, lookupService, trackingService);
			String formattedText = textService.generateFormattedClueText(clue);

			if (formattedText != null && !formattedText.isEmpty())
			{
				currentClueText = formattedText;
				panel.setCurrentStep(difficulty, formattedText);
				
				String identifier = lookupService.getClueIdentifier(clue, trackingService);
				if (identifier == null || identifier.isEmpty())
				{
					identifier = "text:" + formattedText.hashCode();
				}
				
				trackingService.setCurrentlyReadClueText(formattedText);
				trackingService.setCurrentlyReadClueIdentifier(identifier);
			}
		});
	}

	@Subscribe
	public void onMenuEntryAdded(MenuEntryAdded event)
	{
		if (!config.deprioritizeBadClues())
		{
			return;
		}

		if (!event.getOption().equals("Take"))
		{
			return;
		}

		int itemId = event.getIdentifier();
		if (itemId <= 0)
		{
			return;
		}

		boolean isClueScroll = false;
		if (itemId == ItemID.TRAIL_CLUE_BEGINNER || itemId == ItemID.TRAIL_CLUE_MASTER || itemId == 23182)
		{
			isClueScroll = true;
		}
		else
		{
			ItemComposition itemComposition = itemManager.getItemComposition(itemId);
			if (itemComposition != null)
			{
				String itemName = itemComposition.getName();
				if (itemName != null && (itemName.startsWith("Clue scroll")
					|| itemName.startsWith("Challenge scroll")
					|| itemName.startsWith("Treasure scroll")))
				{
					isClueScroll = true;
				}
			}
		}

		if (!isClueScroll)
		{
			return;
		}

		boolean shouldDeprioritize = false;
		
		WorldPoint tilePosition = WorldPoint.fromScene(client, event.getActionParam0(), event.getActionParam1(), client.getPlane());
		ClueTrackingService.DroppedClueInfo info = trackingService.getDroppedClueInfo(tilePosition);
		
		if (info != null)
		{
			if (info.isGood != null && !info.isGood)
			{
				shouldDeprioritize = true;
			}
			else if (info.customList != null && info.customList.isDeprioritize())
			{
				shouldDeprioritize = true;
			}
		}
		else
		{
			ClueScroll clue = lookupService.findClueScroll(itemId);
			if (clue != null)
			{
				String clueIdentifier = lookupService.getClueIdentifier(clue, trackingService);
				if (clueIdentifier != null && !clueIdentifier.isEmpty())
				{
					if (listService.isBadClueByIdentifier(clueIdentifier))
					{
						shouldDeprioritize = true;
					}
					else
					{
						ClueList customList = listService.getCustomListForClue(clueIdentifier);
						if (customList != null && customList.isDeprioritize())
						{
							shouldDeprioritize = true;
						}
					}
				}
			}
		}

		if (shouldDeprioritize)
		{
			MenuEntry[] menuEntries = client.getMenuEntries();
			int takeIndex = -1;
			int walkHereIndex = -1;

			for (int i = 0; i < menuEntries.length; i++)
			{
				MenuEntry entry = menuEntries[i];
				if (entry.getIdentifier() == itemId && entry.getOption().equals("Take"))
				{
					takeIndex = i;
				}
				else if (entry.getOption().equals("Walk here"))
				{
					walkHereIndex = i;
				}
			}

			if (takeIndex >= 0 && walkHereIndex >= 0 && takeIndex < walkHereIndex)
			{
				MenuEntry takeEntry = menuEntries[takeIndex];
				MenuEntry walkEntry = menuEntries[walkHereIndex];
				menuEntries[takeIndex] = walkEntry;
				menuEntries[walkHereIndex] = takeEntry;
				client.setMenuEntries(menuEntries);
			}
			else if (takeIndex >= 0)
			{
				menuEntries[takeIndex].setDeprioritized(true);
			}
		}
	}


	@Subscribe
	public void onItemDespawned(ItemDespawned event)
	{
		TileItem item = event.getItem();
		if (item == null)
		{
			return;
		}

		int itemId = item.getId();
		
		boolean isClueScroll = false;
		if (itemId == ItemID.TRAIL_CLUE_BEGINNER || itemId == ItemID.TRAIL_CLUE_MASTER || itemId == 23182)
		{
			isClueScroll = true;
		}
		else
		{
			ItemComposition itemComp = itemManager.getItemComposition(itemId);
			if (itemComp != null)
			{
				String itemName = itemComp.getName();
				if (itemName != null && (itemName.startsWith("Clue scroll")
					|| itemName.startsWith("Challenge scroll")
					|| itemName.startsWith("Treasure scroll")))
				{
					isClueScroll = true;
				}
			}
		}
		
		if (!isClueScroll)
		{
			return;
		}

		java.util.List<TileItem> remainingItems = event.getTile().getGroundItems();
		boolean hasRemainingClues = false;
		
		if (remainingItems != null)
		{
			for (TileItem remaining : remainingItems)
			{
				if (remaining == null || remaining == item)
				{
					continue;
				}
				
				int remainingId = remaining.getId();
				if (remainingId == ItemID.TRAIL_CLUE_BEGINNER || remainingId == ItemID.TRAIL_CLUE_MASTER || remainingId == 23182)
				{
					hasRemainingClues = true;
					break;
				}
				
				ItemComposition remainingComp = itemManager.getItemComposition(remainingId);
				if (remainingComp != null)
				{
					String remainingName = remainingComp.getName();
					if (remainingName != null && (remainingName.startsWith("Clue scroll")
						|| remainingName.startsWith("Challenge scroll")
						|| remainingName.startsWith("Treasure scroll")))
					{
						hasRemainingClues = true;
						break;
					}
				}
			}
		}
		
		if (!hasRemainingClues)
		{
			WorldPoint tilePosition = event.getTile().getWorldLocation();
			trackingService.clearDroppedClue(tilePosition);
			log.debug("Clue despawned at {}, no more clues on tile", tilePosition);
		}
	}

	@Subscribe
	public void onMenuOptionClicked(MenuOptionClicked event)
	{
		if (event.getMenuOption() == null)
		{
			return;
		}

		String menuOption = event.getMenuOption();
		
		if (menuOption.equals("Drop"))
		{
			int itemId = event.getItemId();
			if (itemId <= 0)
			{
				return;
			}
			
			boolean isClueScroll = false;
			if (itemId == ItemID.TRAIL_CLUE_BEGINNER || itemId == ItemID.TRAIL_CLUE_MASTER || itemId == 23182)
			{
				isClueScroll = true;
			}
			else
			{
				ItemComposition itemComp = itemManager.getItemComposition(itemId);
				if (itemComp != null)
				{
					String itemName = itemComp.getName();
					if (itemName != null && (itemName.startsWith("Clue scroll")
						|| itemName.startsWith("Challenge scroll")
						|| itemName.startsWith("Treasure scroll")))
					{
						isClueScroll = true;
					}
				}
			}
			
			if (isClueScroll && client.getLocalPlayer() != null)
			{
				String clueText = trackingService.getCurrentlyReadClueText();
				String clueIdentifier = trackingService.getCurrentlyReadClueIdentifier();
				
				if (clueText != null && !clueText.isEmpty() && clueIdentifier != null && !clueIdentifier.isEmpty())
				{
					WorldPoint playerPosition = client.getLocalPlayer().getWorldLocation();
					
					listService.ensureListsLoaded();
					boolean isGood = listService.isGoodClueByIdentifier(clueIdentifier);
					boolean isBad = listService.isBadClueByIdentifier(clueIdentifier);
					ClueList customList = null;
					if (!isGood && !isBad)
					{
						customList = listService.getCustomListForClue(clueIdentifier);
					}
					
					Boolean goodBadStatus = null;
					if (isGood)
					{
						goodBadStatus = true;
					}
					else if (isBad)
					{
						goodBadStatus = false;
					}
					
					trackingService.markDroppedClue(playerPosition, clueText, goodBadStatus, customList);
					log.debug("Clue dropped via menu at {}: identifier={}, isGood={}, isBad={}, customList={}", 
						playerPosition, clueIdentifier, isGood, isBad, customList != null ? customList.getName() : "null");
				}
			}
			return;
		}
		
		boolean shouldTrack = false;

		if (menuOption.equals("Take") && shouldTrackOnPickup())
		{
			shouldTrack = true;
		}
		else if (menuOption.equals("Read") && !shouldTrackOnPickup())
		{
			shouldTrack = true;
			trackingService.setLastClueWasTracked(false);
			clientThread.invokeLater(this::updateClueTextFromWidget);
		}

		if (shouldTrack)
		{
			int itemId = event.getItemId();
			if (itemId <= 0)
			{
				return;
			}

			ItemComposition itemComposition = itemManager.getItemComposition(itemId);
			if (itemComposition != null && (itemComposition.getName().startsWith("Clue scroll")
				|| itemComposition.getName().startsWith("Challenge scroll")
				|| itemComposition.getName().startsWith("Treasure scroll")))
			{
				if (menuOption.equals("Take"))
				{
					ClueScroll clue = lookupService.findClueScroll(itemId);
					if (clue != null)
					{
						trackingService.trackClue(itemId, clue);
					}
				}
			}
		}
	}

	private boolean shouldTrackOnPickup()
	{
		ClueScrollConfig clueScrollConfig = configManager.getConfig(ClueScrollConfig.class);
		return clueScrollConfig.identify() == ClueScrollConfig.IdentificationMode.ON_PICKUP;
	}

	public String getCurrentClueText()
	{
		return currentClueText;
	}

	public ClueScrollPlugin getClueScrollPlugin()
	{
		return clueScrollPlugin;
	}

	public Client getClient()
	{
		return client;
	}

	public ClientThread getClientThread()
	{
		return clientThread;
	}

	public ItemManager getItemManager()
	{
		return itemManager;
	}

	@Provides
	ClueJugglerConfig provideConfig(ConfigManager configManager)
	{
		return configManager.getConfig(ClueJugglerConfig.class);
	}

	// Legacy methods for backward compatibility with panel and overlays
	public String generateClueTextFromClue(ClueScroll clue)
	{
		return textService.generateClueTextFromClue(clue);
	}

	public String getClueIdentifier(ClueScroll clue)
	{
		return lookupService.getClueIdentifier(clue, trackingService);
	}

	public Map<Integer, ClueScroll> getTrackedClues()
	{
		return trackingService.getTrackedClues();
	}

	public Map<String, ClueScroll> getTrackedCluesByText()
	{
		return trackingService.getTrackedCluesByText();
	}

	public void ensureClueTracked()
	{
		if (!client.isClientThread())
		{
			clientThread.invokeLater(this::ensureClueTracked);
			return;
		}

		net.runelite.api.ItemContainer inventory = client.getItemContainer(net.runelite.api.gameval.InventoryID.INV);
		if (inventory == null)
		{
			return;
		}

		for (net.runelite.api.Item item : inventory.getItems())
		{
			if (item == null || item.getId() <= 0)
			{
				continue;
			}

			ItemComposition itemComp = itemManager.getItemComposition(item.getId());
			if (itemComp == null)
			{
				continue;
			}

			String itemName = itemComp.getName();
			if (itemName != null && (itemName.startsWith("Clue scroll")
				|| itemName.startsWith("Challenge scroll")
				|| itemName.startsWith("Treasure scroll")))
			{
				ClueScroll foundClue = lookupService.findClueScroll(item.getId());
				if (foundClue != null)
				{
					trackingService.trackClue(item.getId(), foundClue);
				}
			}
		}
	}
}

package com.cluejuggler.model;

import java.awt.Color;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

public class ClueList
{
	private String name;
	private int textColorRGB;
	private int tileColorRGB;
	private int overlayTextColorRGB;
	private boolean deprioritize = false;
	private final List<String> clues = new ArrayList<>();
	private final Map<String, String> clueIdentifiers = new HashMap<>();
	
	public ClueList()
	{
	}
	
	public ClueList(String name, Color textColor, Color tileColor, Color overlayTextColor)
	{
		this.name = name;
		this.textColorRGB = textColor != null ? textColor.getRGB() : Color.WHITE.getRGB();
		this.tileColorRGB = tileColor != null ? tileColor.getRGB() : new Color(255, 255, 255, 100).getRGB();
		this.overlayTextColorRGB = overlayTextColor != null ? overlayTextColor.getRGB() : Color.WHITE.getRGB();
		this.deprioritize = false;
	}
	
	public boolean isDeprioritize()
	{
		return deprioritize;
	}
	
	public void setDeprioritize(boolean deprioritize)
	{
		this.deprioritize = deprioritize;
	}
	
	public String getName()
	{
		return name;
	}
	
	public void setName(String name)
	{
		this.name = name;
	}
	
	public Color getTextColor()
	{
		return new Color(textColorRGB);
	}
	
	public void setTextColor(Color textColor)
	{
		this.textColorRGB = textColor != null ? textColor.getRGB() : Color.WHITE.getRGB();
	}
	
	public Color getTileColor()
	{
		return new Color(tileColorRGB, true);
	}
	
	public void setTileColor(Color tileColor)
	{
		if (tileColor != null)
		{
			int r = tileColor.getRed();
			int g = tileColor.getGreen();
			int b = tileColor.getBlue();
			int a = tileColor.getAlpha();
			this.tileColorRGB = (a << 24) | (r << 16) | (g << 8) | b;
		}
		else
		{
			this.tileColorRGB = new Color(255, 255, 255, 100).getRGB();
		}
	}
	
	public Color getOverlayTextColor()
	{
		return new Color(overlayTextColorRGB);
	}
	
	public void setOverlayTextColor(Color overlayTextColor)
	{
		this.overlayTextColorRGB = overlayTextColor != null ? overlayTextColor.getRGB() : Color.WHITE.getRGB();
	}
	
	public List<String> getClues()
	{
		return clues;
	}
	
	public Map<String, String> getClueIdentifiers()
	{
		return clueIdentifiers;
	}
	
	public int getTextColorRGB()
	{
		return textColorRGB;
	}
	
	public void setTextColorRGB(int rgb)
	{
		this.textColorRGB = rgb;
	}
	
	public int getTileColorRGB()
	{
		return tileColorRGB;
	}
	
	public void setTileColorRGB(int rgb)
	{
		this.tileColorRGB = rgb;
	}
	
	public int getOverlayTextColorRGB()
	{
		return overlayTextColorRGB;
	}
	
	public void setOverlayTextColorRGB(int rgb)
	{
		this.overlayTextColorRGB = rgb;
	}
}


package com.cluejuggler.model;

public enum ClueStatus
{
	GOOD(1),
	BAD(-1),
	UNSURE(0),
	CUSTOM(2);
	
	private final int value;
	
	ClueStatus(int value)
	{
		this.value = value;
	}
	
	public int getValue()
	{
		return value;
	}
	
	public static ClueStatus fromValue(int value)
	{
		for (ClueStatus status : values())
		{
			if (status.value == value)
			{
				return status;
			}
		}
		return UNSURE;
	}
}


package com.cluejuggler.model;

import net.runelite.client.plugins.cluescrolls.clues.ClueScroll;

public class TrackedClue
{
	private final int itemId;
	private final String clueText;
	private final String identifier;
	private final ClueScroll clueScroll;
	private ClueStatus status;
	private ClueList customList;
	
	public TrackedClue(int itemId, String clueText, String identifier, ClueScroll clueScroll)
	{
		this.itemId = itemId;
		this.clueText = clueText;
		this.identifier = identifier;
		this.clueScroll = clueScroll;
		this.status = ClueStatus.UNSURE;
	}
	
	public int getItemId()
	{
		return itemId;
	}
	
	public String getClueText()
	{
		return clueText;
	}
	
	public String getIdentifier()
	{
		return identifier;
	}
	
	public ClueScroll getClueScroll()
	{
		return clueScroll;
	}
	
	public ClueStatus getStatus()
	{
		return status;
	}
	
	public void setStatus(ClueStatus status)
	{
		this.status = status;
	}
	
	public ClueList getCustomList()
	{
		return customList;
	}
	
	public void setCustomList(ClueList customList)
	{
		this.customList = customList;
		if (customList != null)
		{
			this.status = ClueStatus.CUSTOM;
		}
	}
	
	public boolean isBeginnerOrMaster()
	{
		return identifier != null && (identifier.startsWith("beginner:") || identifier.startsWith("master:"));
	}
}


package com.cluejuggler.overlay;

import com.cluejuggler.ClueJugglerPlugin;
import com.cluejuggler.model.ClueList;
import com.cluejuggler.service.ClueListService;
import com.cluejuggler.service.ClueLookupService;
import java.awt.Color;
import java.awt.Dimension;
import java.awt.Graphics2D;
import javax.inject.Inject;
import net.runelite.client.plugins.cluescrolls.ClueScrollPlugin;
import net.runelite.client.plugins.cluescrolls.clues.ClueScroll;
import net.runelite.client.ui.overlay.OverlayPanel;
import net.runelite.client.ui.overlay.OverlayPosition;
import net.runelite.client.ui.overlay.components.LineComponent;

public class ClueJugglerOverlay extends OverlayPanel
{
	private final ClueJugglerPlugin plugin;

	@Inject
	private ClueJugglerOverlay(ClueJugglerPlugin plugin)
	{
		super(plugin);
		this.plugin = plugin;
		setPosition(OverlayPosition.TOP_LEFT);
		setPriority(PRIORITY_HIGH);
	}

	@Override
	public Dimension render(Graphics2D graphics)
	{
		if (!plugin.getConfig().showIndicator())
		{
			return null;
		}

		ClueScrollPlugin clueScrollPlugin = plugin.getClueScrollPlugin();
		if (clueScrollPlugin == null)
		{
			return null;
		}

		ClueScroll clue = clueScrollPlugin.getClue();
		if (clue == null)
		{
			return null;
		}

		ClueListService listService = plugin.getListService();
		ClueLookupService lookupService = plugin.getLookupService();
		
		String clueIdentifier = lookupService.getClueIdentifier(clue, plugin.getTrackingService());
		
		boolean isGood = false;
		boolean isBad = false;
		ClueList customList = null;
		
		if (clueIdentifier != null && !clueIdentifier.isEmpty())
		{
			isGood = listService.isGoodClueByIdentifier(clueIdentifier);
			isBad = listService.isBadClueByIdentifier(clueIdentifier);
			if (!isGood && !isBad)
			{
				customList = listService.getCustomListForClue(clueIdentifier);
			}
		}

		String text;
		Color color;
		
		if (customList != null)
		{
			text = customList.getName();
			color = customList.getTextColor();
		}
		else if (isGood)
		{
			text = "Good Clue";
			color = Color.GREEN;
		}
		else if (isBad)
		{
			text = "Bad Clue";
			color = Color.RED;
		}
		else
		{
			text = "Unsure";
			color = Color.YELLOW;
		}

		panelComponent.getChildren().add(LineComponent.builder()
			.left("Clue Status:")
			.right(text)
			.rightColor(color)
			.build());

		return super.render(graphics);
	}
}


package com.cluejuggler.overlay;

import com.cluejuggler.ClueJugglerConfig;
import com.cluejuggler.ClueJugglerPlugin;
import com.cluejuggler.model.ClueList;
import com.cluejuggler.service.ClueListService;
import com.cluejuggler.service.ClueTrackingService;
import com.cluejuggler.service.ClueTrackingService.DroppedClueInfo;
import java.awt.Color;
import java.awt.Dimension;
import java.awt.FontMetrics;
import java.awt.Graphics2D;
import java.awt.Polygon;
import javax.inject.Inject;
import net.runelite.api.Client;
import net.runelite.api.ItemComposition;
import net.runelite.api.Perspective;
import net.runelite.api.Scene;
import net.runelite.api.Tile;
import net.runelite.api.TileItem;
import net.runelite.api.coords.LocalPoint;
import net.runelite.api.coords.WorldPoint;
import net.runelite.api.gameval.ItemID;
import net.runelite.client.ui.overlay.Overlay;
import net.runelite.client.ui.overlay.OverlayLayer;
import net.runelite.client.ui.overlay.OverlayPosition;
import net.runelite.client.ui.overlay.OverlayUtil;

public class ClueJugglerWorldOverlay extends Overlay
{
	private final ClueJugglerPlugin plugin;
	private final Client client;

	@Inject
	private ClueJugglerWorldOverlay(ClueJugglerPlugin plugin, Client client)
	{
		setPosition(OverlayPosition.DYNAMIC);
		setLayer(OverlayLayer.ABOVE_SCENE);
		this.plugin = plugin;
		this.client = client;
	}

	@Override
	public Dimension render(Graphics2D graphics)
	{
		if (!plugin.getConfig().clueHighlights())
		{
			return null;
		}

		ClueTrackingService trackingService = plugin.getTrackingService();
		ClueListService listService = plugin.getListService();
		ClueJugglerConfig config = plugin.getConfig();
		
		if (trackingService.getDroppedClues().isEmpty())
		{
			return null;
		}

		Scene scene = client.getScene();
		if (scene == null)
		{
			return null;
		}

		Tile[][][] tiles = scene.getTiles();
		if (tiles == null)
		{
			return null;
		}

		int plane = client.getPlane();

		for (int x = 0; x < 104; x++)
		{
			for (int y = 0; y < 104; y++)
			{
				Tile tile = tiles[plane][x][y];
				if (tile == null)
				{
					continue;
				}
				
				java.util.List<TileItem> groundItems = tile.getGroundItems();
				if (groundItems == null || groundItems.isEmpty())
				{
					continue;
				}

				boolean hasClueOnTile = false;
				for (TileItem item : groundItems)
				{
					if (item == null)
					{
						continue;
					}

					int itemId = item.getId();
					if (itemId == ItemID.TRAIL_CLUE_BEGINNER || 
						itemId == ItemID.TRAIL_CLUE_MASTER ||
						itemId == 23182)
					{
						hasClueOnTile = true;
						break;
					}
					
					ItemComposition itemComp = client.getItemDefinition(itemId);
					if (itemComp != null)
					{
						String itemName = itemComp.getName();
						if (itemName != null && (itemName.startsWith("Clue scroll")
							|| itemName.startsWith("Challenge scroll")
							|| itemName.startsWith("Treasure scroll")))
						{
							hasClueOnTile = true;
							break;
						}
					}
				}
				
				if (!hasClueOnTile)
				{
					continue;
				}
				
				WorldPoint tileWorldPoint = tile.getWorldLocation();
				DroppedClueInfo info = trackingService.getDroppedClueInfo(tileWorldPoint);
				
				if (info == null)
				{
					continue;
				}
				
				Color tileColor;
				Color textColor;
				String text;
				
				if (info.customList != null)
				{
					tileColor = info.customList.getTileColor();
					textColor = info.customList.getOverlayTextColor();
					text = info.customList.getName();
				}
				else if (info.isGood != null)
				{
					if (info.isGood)
					{
						tileColor = config.goodClueTileColor();
						textColor = config.goodClueTextColor();
						text = "Good";
					}
					else
					{
						tileColor = config.badClueTileColor();
						textColor = config.badClueTextColor();
						text = "Bad";
					}
				}
				else
				{
					tileColor = config.unsureClueTileColor();
					textColor = config.unsureClueTextColor();
					text = "Unsure";
				}
				
				if (!tileWorldPoint.isInScene(client))
				{
					continue;
				}
				
				LocalPoint localPoint = LocalPoint.fromWorld(client, tileWorldPoint);
				if (localPoint == null)
				{
					continue;
				}
				
				Polygon tilePoly = Perspective.getCanvasTilePoly(client, localPoint);
				if (tilePoly != null)
				{
					OverlayUtil.renderPolygon(graphics, tilePoly, tileColor);
				}

				net.runelite.api.Point textPoint = Perspective.localToCanvas(client, localPoint, client.getPlane(), 50);
				if (textPoint != null)
				{
					FontMetrics fontMetrics = graphics.getFontMetrics();
					int textWidth = fontMetrics.stringWidth(text);
					net.runelite.api.Point centeredTextPoint = new net.runelite.api.Point(
						textPoint.getX() - textWidth / 2,
						textPoint.getY()
					);
					OverlayUtil.renderTextLocation(graphics, centeredTextPoint, text, textColor);
				}
			}
		}

		return null;
	}
}


package com.cluejuggler.service;

import com.cluejuggler.model.ClueList;
import com.google.gson.Gson;
import com.google.gson.JsonObject;
import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.File;
import java.io.FileReader;
import java.io.FileWriter;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import javax.inject.Inject;
import javax.inject.Singleton;
import lombok.Getter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.client.config.ConfigManager;

@Slf4j
@Singleton
public class ClueListService
{
	private final ConfigManager configManager;
	private final Gson gson;
	
	@Getter
	private final Map<String, String> goodClueIdentifiers = new ConcurrentHashMap<>();
	@Getter
	private final Map<String, String> badClueIdentifiers = new ConcurrentHashMap<>();
	@Getter
	private final List<ClueList> customLists = new ArrayList<>();
	
	private boolean listsLoaded = false;
	private boolean customListsLoaded = false;
	
	@Inject
	public ClueListService(ConfigManager configManager, Gson gson)
	{
		this.configManager = configManager;
		this.gson = gson;
	}
	
	public void loadLists()
	{
		if (configManager == null || listsLoaded)
		{
			return;
		}
		
		String goodStepsData = configManager.getConfiguration("cluejuggler", "goodSteps");
		String badStepsData = configManager.getConfiguration("cluejuggler", "badSteps");
		
		goodClueIdentifiers.clear();
		badClueIdentifiers.clear();
		
		if (goodStepsData != null && !goodStepsData.isEmpty())
		{
			parseListData(goodStepsData, goodClueIdentifiers);
		}
		
		if (badStepsData != null && !badStepsData.isEmpty())
		{
			parseListData(badStepsData, badClueIdentifiers);
		}
		
		listsLoaded = true;
	}
	
	private void parseListData(String data, Map<String, String> targetMap)
	{
		String[] items = data.split("\\|");
		for (String item : items)
		{
			item = item.trim();
			if (!item.isEmpty())
			{
				String[] parts = item.split("::", 2);
				String text;
				String identifier;
				if (parts.length == 2)
				{
					text = parts[0].trim();
					identifier = parts[1].trim();
				}
				else
				{
					text = item;
					identifier = "text:" + text.hashCode();
				}
				if (!text.isEmpty() && !identifier.isEmpty())
				{
					targetMap.put(identifier, text);
				}
			}
		}
	}
	
	public void saveLists()
	{
		if (configManager == null)
		{
			return;
		}
		
		String goodData = buildListData(goodClueIdentifiers);
		String badData = buildListData(badClueIdentifiers);
		
		configManager.setConfiguration("cluejuggler", "goodSteps", goodData);
		configManager.setConfiguration("cluejuggler", "badSteps", badData);
	}
	
	private String buildListData(Map<String, String> sourceMap)
	{
		StringBuilder builder = new StringBuilder();
		boolean first = true;
		for (Map.Entry<String, String> entry : sourceMap.entrySet())
		{
			if (!first)
			{
				builder.append("|");
			}
			first = false;
			builder.append(entry.getValue()).append("::").append(entry.getKey());
		}
		return builder.toString();
	}
	
	public void loadCustomLists()
	{
		if (configManager == null)
		{
			return;
		}
		
		if (customListsLoaded && !customLists.isEmpty())
		{
			return;
		}
		
		if (customListsLoaded && customLists.isEmpty())
		{
			String customListsJson = configManager.getConfiguration("cluejuggler", "customLists");
			if (customListsJson != null && !customListsJson.isEmpty() && !customListsJson.equals("[]"))
			{
				customListsLoaded = false;
			}
			else
			{
				return;
			}
		}
		
		if (customListsLoaded)
		{
			return;
		}
		
		String customListsJson = configManager.getConfiguration("cluejuggler", "customLists");
		if (customListsJson == null || customListsJson.isEmpty())
		{
			customListsJson = "[]";
		}
		
		try
		{
			ClueList[] loaded = gson.fromJson(customListsJson, ClueList[].class);
			if (loaded != null)
			{
				customLists.clear();
				customLists.addAll(Arrays.asList(loaded));
			}
			customListsLoaded = true;
		}
		catch (Exception e)
		{
			log.warn("Failed to load custom lists", e);
			customLists.clear();
			customListsLoaded = true;
		}
	}
	
	public void saveCustomLists()
	{
		if (configManager == null)
		{
			return;
		}
		
		try
		{
			String json = gson.toJson(customLists);
			configManager.setConfiguration("cluejuggler", "customLists", json);
			customListsLoaded = true;
		}
		catch (Exception e)
		{
			log.warn("Failed to save custom lists", e);
		}
	}
	
	public void ensureListsLoaded()
	{
		if (!listsLoaded)
		{
			loadLists();
		}
		if (!customListsLoaded)
		{
			loadCustomLists();
		}
	}
	
	public void addGoodClue(String identifier, String text)
	{
		ensureListsLoaded();
		removeFromBad(identifier);
		removeFromCustomLists(identifier);
		goodClueIdentifiers.put(identifier, text);
		saveLists();
	}
	
	public void addBadClue(String identifier, String text)
	{
		ensureListsLoaded();
		removeFromGood(identifier);
		removeFromCustomLists(identifier);
		badClueIdentifiers.put(identifier, text);
		saveLists();
	}
	
	public void addToCustomList(ClueList list, String identifier, String text)
	{
		ensureListsLoaded();
		removeFromGood(identifier);
		removeFromBad(identifier);
		removeFromCustomLists(identifier);
		list.getClueIdentifiers().put(identifier, text);
		list.getClues().add(text);
		saveCustomLists();
	}
	
	public void removeFromGood(String identifier)
	{
		goodClueIdentifiers.remove(identifier);
	}
	
	public void removeFromBad(String identifier)
	{
		badClueIdentifiers.remove(identifier);
	}
	
	public void removeFromCustomLists(String identifier)
	{
		for (ClueList list : customLists)
		{
			String text = list.getClueIdentifiers().remove(identifier);
			if (text != null)
			{
				list.getClues().remove(text);
			}
		}
	}
	
	public boolean isGoodClue(String clueText)
	{
		ensureListsLoaded();
		return goodClueIdentifiers.containsValue(clueText);
	}
	
	public boolean isBadClue(String clueText)
	{
		ensureListsLoaded();
		return badClueIdentifiers.containsValue(clueText);
	}
	
	public boolean isGoodClueByIdentifier(String identifier)
	{
		ensureListsLoaded();
		return goodClueIdentifiers.containsKey(identifier);
	}
	
	public boolean isBadClueByIdentifier(String identifier)
	{
		ensureListsLoaded();
		return badClueIdentifiers.containsKey(identifier);
	}
	
	public ClueList getCustomListForClue(String identifier)
	{
		ensureListsLoaded();
		for (ClueList list : customLists)
		{
			if (list.getClueIdentifiers().containsKey(identifier))
			{
				return list;
			}
		}
		return null;
	}
	
	public ClueList getCustomListForClueByText(String clueText)
	{
		ensureListsLoaded();
		for (ClueList list : customLists)
		{
			if (list.getClues().contains(clueText))
			{
				return list;
			}
		}
		return null;
	}
	
	public ClueList findCustomListByName(String name)
	{
		ensureListsLoaded();
		for (ClueList list : customLists)
		{
			if (list.getName().equals(name))
			{
				return list;
			}
		}
		return null;
	}
	
	public void createCustomList(String name, java.awt.Color textColor, java.awt.Color tileColor, java.awt.Color overlayTextColor)
	{
		ensureListsLoaded();
		ClueList newList = new ClueList(name, textColor, tileColor, overlayTextColor);
		customLists.add(newList);
		saveCustomLists();
	}
	
	public void deleteCustomList(ClueList list)
	{
		customLists.remove(list);
		saveCustomLists();
	}
	
	public boolean hasAnyCluesInLists()
	{
		ensureListsLoaded();
		if (!goodClueIdentifiers.isEmpty() || !badClueIdentifiers.isEmpty())
		{
			return true;
		}
		for (ClueList list : customLists)
		{
			if (!list.getClueIdentifiers().isEmpty())
			{
				return true;
			}
		}
		return false;
	}
	
	public String exportListsToJson()
	{
		ensureListsLoaded();
		
		java.util.Map<String, Object> exportData = new java.util.HashMap<>();
		exportData.put("goodClues", goodClueIdentifiers);
		exportData.put("badClues", badClueIdentifiers);
		exportData.put("customLists", customLists);
		
		return gson.toJson(exportData);
	}
	
	public void importListsFromJson(String json)
	{
		try
		{
			JsonObject importData = gson.fromJson(json, JsonObject.class);
			
			if (importData.has("goodClues"))
			{
				JsonObject goodData = importData.getAsJsonObject("goodClues");
				goodClueIdentifiers.clear();
				for (String key : goodData.keySet())
				{
					goodClueIdentifiers.put(key, goodData.get(key).getAsString());
				}
			}
			
			if (importData.has("badClues"))
			{
				JsonObject badData = importData.getAsJsonObject("badClues");
				badClueIdentifiers.clear();
				for (String key : badData.keySet())
				{
					badClueIdentifiers.put(key, badData.get(key).getAsString());
				}
			}
			
			if (importData.has("customLists"))
			{
				String customListsJson = importData.get("customLists").toString();
				ClueList[] imported = gson.fromJson(customListsJson, ClueList[].class);
				if (imported != null)
				{
					customLists.clear();
					customLists.addAll(Arrays.asList(imported));
				}
			}
			
			saveLists();
			saveCustomLists();
		}
		catch (Exception e)
		{
			log.warn("Failed to import lists from JSON", e);
		}
	}
	
	public void exportToFile(File file)
	{
		try (BufferedWriter writer = new BufferedWriter(new FileWriter(file)))
		{
			writer.write(exportListsToJson());
		}
		catch (Exception e)
		{
			log.warn("Failed to export lists to file", e);
		}
	}
	
	public void importFromFile(File file)
	{
		try (BufferedReader reader = new BufferedReader(new FileReader(file)))
		{
			StringBuilder sb = new StringBuilder();
			String line;
			while ((line = reader.readLine()) != null)
			{
				sb.append(line);
			}
			importListsFromJson(sb.toString());
		}
		catch (Exception e)
		{
			log.warn("Failed to import lists from file", e);
		}
	}
	
	public void clearGoodSteps()
	{
		goodClueIdentifiers.clear();
		saveLists();
	}
	
	public void clearBadSteps()
	{
		badClueIdentifiers.clear();
		saveLists();
	}
	
	public void forceReload()
	{
		listsLoaded = false;
		customListsLoaded = false;
		loadLists();
		loadCustomLists();
	}
}


package com.cluejuggler.service;

import java.util.Map;
import javax.inject.Inject;
import javax.inject.Singleton;
import net.runelite.api.Client;
import net.runelite.api.ItemComposition;
import net.runelite.api.gameval.ItemID;
import net.runelite.client.game.ItemManager;
import net.runelite.client.plugins.cluescrolls.ClueScrollPlugin;
import net.runelite.client.plugins.cluescrolls.clues.AnagramClue;
import net.runelite.client.plugins.cluescrolls.clues.BeginnerMapClue;
import net.runelite.client.plugins.cluescrolls.clues.CipherClue;
import net.runelite.client.plugins.cluescrolls.clues.ClueScroll;
import net.runelite.client.plugins.cluescrolls.clues.CoordinateClue;
import net.runelite.client.plugins.cluescrolls.clues.CrypticClue;
import net.runelite.client.plugins.cluescrolls.clues.EmoteClue;
import net.runelite.client.plugins.cluescrolls.clues.FairyRingClue;
import net.runelite.client.plugins.cluescrolls.clues.MapClue;
import net.runelite.client.plugins.cluescrolls.clues.MusicClue;

@Singleton
public class ClueLookupService
{
	private final Client client;
	private final ItemManager itemManager;
	private final ClueScrollPlugin clueScrollPlugin;
	private final ClueTextService textService;
	
	@Inject
	public ClueLookupService(Client client, ItemManager itemManager, ClueScrollPlugin clueScrollPlugin, ClueTextService textService)
	{
		this.client = client;
		this.itemManager = itemManager;
		this.clueScrollPlugin = clueScrollPlugin;
		this.textService = textService;
	}
	
	public ClueScroll findClueScroll(int itemId)
	{
		if (itemId == ItemID.TRAIL_CLUE_BEGINNER || itemId == ItemID.TRAIL_CLUE_MASTER)
		{
			return null;
		}
		
		ClueScroll clue = MapClue.forItemId(itemId);
		if (clue != null)
		{
			return clue;
		}
		
		clue = MusicClue.forItemId(itemId);
		if (clue != null)
		{
			return clue;
		}
		
		clue = CoordinateClue.forItemId(itemId);
		if (clue != null)
		{
			return clue;
		}
		
		clue = AnagramClue.forItemId(itemId);
		if (clue != null)
		{
			return clue;
		}
		
		clue = CipherClue.forItemId(itemId);
		if (clue != null)
		{
			return clue;
		}
		
		clue = CrypticClue.forItemId(itemId);
		if (clue != null)
		{
			return clue;
		}
		
		clue = EmoteClue.forItemId(itemId);
		if (clue != null)
		{
			return clue;
		}
		
		clue = FairyRingClue.forItemId(itemId);
		if (clue != null)
		{
			return clue;
		}
		
		return null;
	}
	
	public String getClueIdentifier(ClueScroll clue, ClueTrackingService trackingService)
	{
		if (clue == null)
		{
			return null;
		}
		
		int itemId = getCurrentClueItemId(trackingService);
		if (itemId > 0 && itemId != ItemID.TRAIL_CLUE_BEGINNER && itemId != ItemID.TRAIL_CLUE_MASTER)
		{
			return "item:" + itemId;
		}
		
		if (clue instanceof BeginnerMapClue)
		{
			String clueText = textService.generateClueTextFromClue(clue);
			if (clueText != null && !clueText.isEmpty())
			{
				return "beginner:" + clueText.hashCode();
			}
			return "beginner:" + Integer.toHexString(clue.hashCode());
		}
		
		String clueText = textService.generateClueTextFromClue(clue);
		if (clueText != null && !clueText.isEmpty())
		{
			return "master:" + clueText.hashCode();
		}
		
		return "clue:" + Integer.toHexString(clue.hashCode());
	}
	
	public int getCurrentClueItemId(ClueTrackingService trackingService)
	{
		if (!client.isClientThread())
		{
			return -1;
		}
		
		if (clueScrollPlugin == null)
		{
			return -1;
		}
		
		ClueScroll currentClue = clueScrollPlugin.getClue();
		if (currentClue == null)
		{
			return -1;
		}
		
		if (currentClue instanceof BeginnerMapClue)
		{
			net.runelite.api.ItemContainer inventory = client.getItemContainer(net.runelite.api.gameval.InventoryID.INV);
			if (inventory != null)
			{
				for (net.runelite.api.Item item : inventory.getItems())
				{
					if (item == null || item.getId() <= 0)
					{
						continue;
					}
					
					if (item.getId() == ItemID.TRAIL_CLUE_BEGINNER || item.getId() == 23182)
					{
						ItemComposition itemComp = itemManager.getItemComposition(item.getId());
						if (itemComp != null && (itemComp.getName().startsWith("Clue scroll")
							|| itemComp.getName().startsWith("Challenge scroll")
							|| itemComp.getName().startsWith("Treasure scroll")))
						{
							return item.getId();
						}
					}
				}
			}
			return ItemID.TRAIL_CLUE_BEGINNER;
		}
		
		String currentClueText = textService.generateClueTextFromClue(currentClue);
		if (currentClueText != null && !currentClueText.isEmpty() && trackingService.isTrackedByText(currentClueText))
		{
			for (Map.Entry<Integer, ClueScroll> entry : trackingService.getTrackedClues().entrySet())
			{
				ClueScroll trackedClue = entry.getValue();
				if (trackedClue == null)
				{
					continue;
				}
				String trackedClueText = textService.generateClueTextFromClue(trackedClue);
				if (trackedClueText != null && trackedClueText.equals(currentClueText))
				{
					return entry.getKey();
				}
			}
		}
		
		if (currentClueText == null || currentClueText.isEmpty())
		{
			return -1;
		}
		
		for (Map.Entry<Integer, ClueScroll> entry : trackingService.getTrackedClues().entrySet())
		{
			ClueScroll trackedClue = entry.getValue();
			if (trackedClue == null)
			{
				continue;
			}
			
			String trackedClueText = textService.generateClueTextFromClue(trackedClue);
			if (trackedClueText != null && trackedClueText.equals(currentClueText))
			{
				return entry.getKey();
			}
		}
		
		return -1;
	}
	
	public boolean isClueScrollItem(int itemId)
	{
		if (itemId == ItemID.TRAIL_CLUE_BEGINNER || 
			itemId == ItemID.TRAIL_CLUE_MASTER || 
			itemId == 23182)
		{
			return true;
		}
		
		ItemComposition itemComp = itemManager.getItemComposition(itemId);
		if (itemComp != null)
		{
			String itemName = itemComp.getName();
			if (itemName != null && (itemName.startsWith("Clue scroll")
				|| itemName.startsWith("Challenge scroll")
				|| itemName.startsWith("Treasure scroll")))
			{
				return true;
			}
		}
		
		return false;
	}
	
	public boolean isBeginnerOrMasterClue(int itemId)
	{
		return itemId == ItemID.TRAIL_CLUE_BEGINNER || 
			itemId == ItemID.TRAIL_CLUE_MASTER || 
			itemId == 23182;
	}
	
	public ClueScroll getCurrentClue()
	{
		return clueScrollPlugin != null ? clueScrollPlugin.getClue() : null;
	}
}


package com.cluejuggler.service;

import javax.inject.Inject;
import javax.inject.Singleton;
import net.runelite.api.Client;
import net.runelite.api.ItemComposition;
import net.runelite.api.gameval.ItemID;
import net.runelite.client.game.ItemManager;
import net.runelite.client.plugins.cluescrolls.ClueScrollPlugin;
import net.runelite.client.plugins.cluescrolls.clues.ClueScroll;
import net.runelite.client.plugins.cluescrolls.clues.AnagramClue;
import net.runelite.client.plugins.cluescrolls.clues.BeginnerMapClue;
import net.runelite.client.plugins.cluescrolls.clues.CipherClue;
import net.runelite.client.plugins.cluescrolls.clues.CoordinateClue;
import net.runelite.client.plugins.cluescrolls.clues.CrypticClue;
import net.runelite.client.plugins.cluescrolls.clues.EmoteClue;
import net.runelite.client.plugins.cluescrolls.clues.FaloTheBardClue;
import net.runelite.client.plugins.cluescrolls.clues.HotColdClue;
import net.runelite.client.plugins.cluescrolls.clues.MapClue;
import net.runelite.client.plugins.cluescrolls.clues.MusicClue;
import net.runelite.client.plugins.cluescrolls.clues.SkillChallengeClue;
import net.runelite.client.plugins.cluescrolls.clues.ThreeStepCrypticClue;
import net.runelite.client.plugins.cluescrolls.clues.item.ItemRequirement;

@Singleton
public class ClueTextService
{
	private final Client client;
	private final ItemManager itemManager;
	private final ClueScrollPlugin clueScrollPlugin;
	
	@Inject
	public ClueTextService(Client client, ItemManager itemManager, ClueScrollPlugin clueScrollPlugin)
	{
		this.client = client;
		this.itemManager = itemManager;
		this.clueScrollPlugin = clueScrollPlugin;
	}
	
	public String generateClueTextFromClue(ClueScroll clue)
	{
		String clueType = getClueTypeName(clue);
		String description = null;
		
		if (clue instanceof CrypticClue)
		{
			description = ((CrypticClue) clue).getText();
		}
		else if (clue instanceof CipherClue)
		{
			description = ((CipherClue) clue).getText();
		}
		else if (clue instanceof FaloTheBardClue)
		{
			description = ((FaloTheBardClue) clue).getText();
		}
		else if (clue instanceof ThreeStepCrypticClue)
		{
			description = ((ThreeStepCrypticClue) clue).getText();
		}
		else if (clue instanceof EmoteClue)
		{
			description = ((EmoteClue) clue).getText();
		}
		else if (clue instanceof BeginnerMapClue || clue instanceof MapClue)
		{
			description = generateMapClueText(clue);
		}
		
		if (description != null && !description.isEmpty())
		{
			String shortDesc = description.length() > 50 ? description.substring(0, 47) + "..." : description;
			return clueType + ": " + shortDesc;
		}
		
		return clueType;
	}
	
	public String generateFormattedClueText(ClueScroll clue)
	{
		StringBuilder sb = new StringBuilder();
		
		String clueType = getClueTypeName(clue);
		sb.append(clueType);
		
		String npcName = getNpcName(clue);
		if (npcName != null && !npcName.isEmpty())
		{
			sb.append("\n").append("NPC: ").append(npcName);
		}
		
		String locationText = getLocationText(clue);
		if (locationText != null && !locationText.isEmpty())
		{
			sb.append("\n").append(locationText);
		}
		
		String itemRequirements = getItemRequirements(clue);
		if (itemRequirements != null && !itemRequirements.isEmpty())
		{
			sb.append("\n").append(itemRequirements);
		}
		
		return sb.toString();
	}
	
	public String getClueDifficulty(ClueScroll clue, ClueLookupService lookupService, ClueTrackingService trackingService)
	{
		if (clueScrollPlugin == null)
		{
			return "Unknown";
		}
		
		if (clue instanceof BeginnerMapClue)
		{
			return "Beginner";
		}
		
		if (!client.isClientThread())
		{
			return "Unknown";
		}
		
		int itemId = -1;
		net.runelite.api.ItemContainer inventory = client.getItemContainer(net.runelite.api.gameval.InventoryID.INV);
		if (inventory != null)
		{
			for (net.runelite.api.Item item : inventory.getItems())
			{
				if (item == null || item.getId() <= 0)
				{
					continue;
				}
				
				ItemComposition itemComp = itemManager.getItemComposition(item.getId());
				if (itemComp != null && (itemComp.getName().startsWith("Clue scroll")
					|| itemComp.getName().startsWith("Challenge scroll")
					|| itemComp.getName().startsWith("Treasure scroll")))
				{
					ClueScroll foundClue = lookupService.findClueScroll(item.getId());
					if (foundClue == clue)
					{
						itemId = item.getId();
						break;
					}
					else if (item.getId() == ItemID.TRAIL_CLUE_BEGINNER || item.getId() == 23182)
					{
						if (clue instanceof BeginnerMapClue)
						{
							itemId = item.getId();
							break;
						}
						String itemName = itemComp.getName();
						if (itemName != null && itemName.toLowerCase().contains("beginner"))
						{
							itemId = item.getId();
							break;
						}
					}
				}
			}
		}
		
		if (itemId <= 0)
		{
			itemId = lookupService.getCurrentClueItemId(trackingService);
		}
		
		if (itemId > 0)
		{
			if (itemId == ItemID.TRAIL_CLUE_BEGINNER || itemId == 23182)
			{
				return "Beginner";
			}
			
			ItemComposition itemComp = itemManager.getItemComposition(itemId);
			if (itemComp != null)
			{
				String itemName = itemComp.getName();
				if (itemName != null)
				{
					if (itemName.toLowerCase().contains("beginner"))
					{
						return "Beginner";
					}
					else if (itemName.contains("(easy)"))
					{
						return "Easy";
					}
					else if (itemName.contains("(medium)"))
					{
						return "Medium";
					}
					else if (itemName.contains("(hard)"))
					{
						return "Hard";
					}
					else if (itemName.contains("(elite)"))
					{
						return "Elite";
					}
					else if (itemName.contains("(master)"))
					{
						return "Master";
					}
				}
			}
		}
		
		if (inventory != null)
		{
			for (net.runelite.api.Item item : inventory.getItems())
			{
				if (item == null || item.getId() <= 0)
				{
					continue;
				}
				
				ItemComposition itemComp = itemManager.getItemComposition(item.getId());
				if (itemComp != null)
				{
					String itemName = itemComp.getName();
					if (itemName != null && (itemName.startsWith("Clue scroll")
						|| itemName.startsWith("Challenge scroll")
						|| itemName.startsWith("Treasure scroll")))
					{
						if (itemName.toLowerCase().contains("beginner"))
						{
							return "Beginner";
						}
					}
				}
			}
		}
		
		String currentClueText = generateClueTextFromClue(clue);
		if (currentClueText != null && trackingService.isTrackedByText(currentClueText))
		{
			for (java.util.Map.Entry<Integer, ClueScroll> entry : trackingService.getTrackedClues().entrySet())
			{
				ClueScroll trackedClue = entry.getValue();
				if (trackedClue == null)
				{
					continue;
				}
				String trackedClueText = generateClueTextFromClue(trackedClue);
				if (trackedClueText != null && trackedClueText.equals(currentClueText))
				{
					return "Unknown";
				}
			}
			return "Master";
		}
		
		return "Unknown";
	}
	
	public String getClueTypeName(ClueScroll clue)
	{
		if (clue instanceof BeginnerMapClue)
		{
			return "Beginner Clue";
		}
		else if (clue instanceof MapClue)
		{
			return "Map Clue";
		}
		else if (clue instanceof CrypticClue)
		{
			return "Cryptic Clue";
		}
		else if (clue instanceof CipherClue)
		{
			return "Cipher Clue";
		}
		else if (clue instanceof EmoteClue)
		{
			return "Emote Clue";
		}
		else if (clue instanceof FaloTheBardClue)
		{
			return "Falo Clue";
		}
		else if (clue instanceof ThreeStepCrypticClue)
		{
			return "Three Step";
		}
		else if (clue instanceof AnagramClue)
		{
			return "Anagram Clue";
		}
		else if (clue instanceof CoordinateClue)
		{
			return "Coordinate Clue";
		}
		else if (clue instanceof MusicClue)
		{
			return "Music Clue";
		}
		else if (clue instanceof HotColdClue)
		{
			return "Hot/Cold Clue";
		}
		else
		{
			return "Clue";
		}
	}
	
	public String getNpcName(ClueScroll clue)
	{
		if (clue instanceof AnagramClue)
		{
			AnagramClue anagramClue = (AnagramClue) clue;
			try
			{
				String[] npcs = anagramClue.getNpcs(clueScrollPlugin);
				if (npcs != null && npcs.length > 0 && npcs[0] != null && !npcs[0].isEmpty())
				{
					return npcs[0];
				}
			}
			catch (Exception e)
			{
			}
		}
		else if (clue instanceof CipherClue)
		{
			CipherClue cipherClue = (CipherClue) clue;
			try
			{
				String[] npcs = cipherClue.getNpcs(clueScrollPlugin);
				if (npcs != null && npcs.length > 0 && npcs[0] != null && !npcs[0].isEmpty())
				{
					return npcs[0];
				}
			}
			catch (Exception e)
			{
			}
		}
		else if (clue instanceof CrypticClue)
		{
			CrypticClue crypticClue = (CrypticClue) clue;
			try
			{
				String[] npcs = crypticClue.getNpcs(clueScrollPlugin);
				if (npcs != null && npcs.length > 0 && npcs[0] != null && !npcs[0].isEmpty())
				{
					return npcs[0];
				}
			}
			catch (Exception e)
			{
			}
		}
		
		return null;
	}
	
	public String getLocationText(ClueScroll clue)
	{
		if (clue instanceof MapClue || clue instanceof BeginnerMapClue)
		{
			return generateMapClueText(clue);
		}
		else if (clue instanceof CrypticClue)
		{
			CrypticClue crypticClue = (CrypticClue) clue;
			String solution = crypticClue.getSolution(clueScrollPlugin);
			if (solution != null && !solution.isEmpty())
			{
				return solution;
			}
			return crypticClue.getText();
		}
		else if (clue instanceof CipherClue)
		{
			CipherClue cipherClue = (CipherClue) clue;
			try
			{
				net.runelite.api.coords.WorldPoint location = cipherClue.getLocation(clueScrollPlugin);
				if (location != null)
				{
					return location.getX() + ", " + location.getY();
				}
			}
			catch (Exception e)
			{
			}
			return cipherClue.getText();
		}
		else if (clue instanceof AnagramClue)
		{
			AnagramClue anagramClue = (AnagramClue) clue;
			net.runelite.api.coords.WorldPoint location = anagramClue.getLocation(clueScrollPlugin);
			if (location != null)
			{
				return "Location: " + location.getX() + ", " + location.getY();
			}
			return "Anagram Clue";
		}
		else if (clue instanceof CoordinateClue)
		{
			CoordinateClue coordClue = (CoordinateClue) clue;
			net.runelite.api.coords.WorldPoint location = coordClue.getLocation(clueScrollPlugin);
			if (location != null)
			{
				return location.getX() + ", " + location.getY();
			}
		}
		else if (clue instanceof MusicClue)
		{
			MusicClue musicClue = (MusicClue) clue;
			return musicClue.getSong();
		}
		else if (clue instanceof EmoteClue)
		{
			EmoteClue emoteClue = (EmoteClue) clue;
			return emoteClue.getText();
		}
		
		return null;
	}
	
	public String getItemRequirements(ClueScroll clue)
	{
		if (clue instanceof EmoteClue)
		{
			EmoteClue emoteClue = (EmoteClue) clue;
			ItemRequirement[] requirements = emoteClue.getItemRequirements();
			if (requirements != null && requirements.length > 0)
			{
				StringBuilder sb = new StringBuilder();
				for (int i = 0; i < requirements.length; i++)
				{
					if (i > 0)
					{
						sb.append(", ");
					}
					sb.append(requirements[i].getCollectiveName(clueScrollPlugin.getClient()));
				}
				return sb.toString();
			}
		}
		else if (clue instanceof SkillChallengeClue)
		{
			SkillChallengeClue skillClue = (SkillChallengeClue) clue;
			ItemRequirement[] requirements = skillClue.getItemRequirements();
			if (requirements != null && requirements.length > 0)
			{
				StringBuilder sb = new StringBuilder();
				for (int i = 0; i < requirements.length; i++)
				{
					if (i > 0)
					{
						sb.append(", ");
					}
					sb.append(requirements[i].getCollectiveName(clueScrollPlugin.getClient()));
				}
				return sb.toString();
			}
		}
		
		if (clue.isRequiresSpade())
		{
			return "Requires: Spade";
		}
		
		return null;
	}
	
	public String generateMapClueText(ClueScroll clue)
	{
		if (clue instanceof MapClue)
		{
			MapClue mapClue = (MapClue) clue;
			net.runelite.api.coords.WorldPoint location = mapClue.getLocation(clueScrollPlugin);
			if (location != null)
			{
				return "Map: " + location.getX() + ", " + location.getY();
			}
		}
		else if (clue instanceof BeginnerMapClue)
		{
			BeginnerMapClue beginnerMapClue = (BeginnerMapClue) clue;
			net.runelite.api.coords.WorldPoint location = beginnerMapClue.getLocation(clueScrollPlugin);
			if (location != null)
			{
				return "Map: " + location.getX() + ", " + location.getY();
			}
		}
		
		return "Map Clue";
	}
}


package com.cluejuggler.service;

import com.cluejuggler.model.ClueList;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import javax.inject.Inject;
import javax.inject.Singleton;
import lombok.Getter;
import lombok.Setter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.coords.WorldPoint;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.plugins.cluescrolls.clues.ClueScroll;

@Slf4j
@Singleton
public class ClueTrackingService
{
	private final Client client;
	private final ClientThread clientThread;
	
	@Getter
	private final Map<Integer, ClueScroll> trackedClues = new ConcurrentHashMap<>();
	
	@Getter
	private final Map<String, ClueScroll> trackedCluesByText = new ConcurrentHashMap<>();
	
	private final Map<Object, Object> clueStatusCache = new ConcurrentHashMap<>();
	private final Map<Integer, String> itemIdToIdentifier = new ConcurrentHashMap<>();
	private final Map<WorldPoint, DroppedClueInfo> droppedClues = new ConcurrentHashMap<>();
	
	@Getter @Setter
	private String currentlyReadClueText = null;
	@Getter @Setter
	private String currentlyReadClueIdentifier = null;
	
	public static class DroppedClueInfo
	{
		public final String clueText;
		public final Boolean isGood; // true=good, false=bad, null=unsure or custom
		public final ClueList customList; // non-null if in custom list
		
		public DroppedClueInfo(String clueText, Boolean isGood, ClueList customList)
		{
			this.clueText = clueText;
			this.isGood = isGood;
			this.customList = customList;
		}
	}
	
	private ClueScroll lastProcessedClue = null;
	private boolean lastClueWasTracked = false;
	
	@Inject
	public ClueTrackingService(Client client, ClientThread clientThread)
	{
		this.client = client;
		this.clientThread = clientThread;
	}
	
	public void trackClue(int itemId, ClueScroll clue)
	{
		if (itemId > 0 && clue != null)
		{
			trackedClues.put(itemId, clue);
		}
	}
	
	public void trackClueByText(String clueText, ClueScroll clue)
	{
		if (clueText != null && !clueText.isEmpty() && clue != null)
		{
			trackedCluesByText.put(clueText, clue);
		}
	}
	
	public boolean isTrackedByText(String clueText)
	{
		return clueText != null && trackedCluesByText.containsKey(clueText);
	}
	
	public void clearTrackedClues()
	{
		trackedClues.clear();
		trackedCluesByText.clear();
		droppedClues.clear();
	}
	
	public ClueScroll getLastProcessedClue()
	{
		return lastProcessedClue;
	}
	
	public void setLastProcessedClue(ClueScroll clue)
	{
		this.lastProcessedClue = clue;
	}
	
	public boolean wasLastClueTracked()
	{
		return lastClueWasTracked;
	}
	
	public void setLastClueWasTracked(boolean tracked)
	{
		this.lastClueWasTracked = tracked;
	}
	
	public void markDroppedClue(WorldPoint position, String clueText, Boolean isGood, ClueList customList)
	{
		if (position != null && clueText != null)
		{
			droppedClues.put(position, new DroppedClueInfo(clueText, isGood, customList));
			log.debug("Marked dropped clue at {}: text={}, isGood={}, customList={}", 
				position, clueText, isGood, customList != null ? customList.getName() : "null");
		}
	}
	
	public DroppedClueInfo getDroppedClueInfo(WorldPoint position)
	{
		if (position == null)
		{
			return null;
		}
		return droppedClues.get(position);
	}
	
	public void clearDroppedClue(WorldPoint position)
	{
		if (position != null)
		{
			droppedClues.remove(position);
		}
	}
	
	public Map<WorldPoint, DroppedClueInfo> getDroppedClues()
	{
		return droppedClues;
	}
	
	public void clearAllDroppedClues()
	{
		droppedClues.clear();
	}
	
	public void clearClueStatusCache()
	{
		clueStatusCache.clear();
	}
	
	public Integer getCachedClueStatus(Object key)
	{
		Object value = clueStatusCache.get(key);
		if (value instanceof Integer)
		{
			return (Integer) value;
		}
		return null;
	}
	
	public Object getCachedClueStatusObject(Object key)
	{
		return clueStatusCache.get(key);
	}
	
	public void cacheClueStatus(Object key, Object status)
	{
		clueStatusCache.put(key, status);
	}
	
	public void clearClueStatusCacheEntry(Object key)
	{
		clueStatusCache.remove(key);
	}
	
	public void cacheItemIdToIdentifier(int itemId, String identifier)
	{
		if (itemId > 0 && identifier != null && !identifier.isEmpty())
		{
			itemIdToIdentifier.put(itemId, identifier);
		}
	}
	
	public String getIdentifierForItemId(int itemId)
	{
		return itemIdToIdentifier.get(itemId);
	}
	
}


package com.cluejuggler.ui;

import com.cluejuggler.ClueJugglerPlugin;
import com.cluejuggler.model.ClueList;
import com.cluejuggler.service.ClueListService;
import com.cluejuggler.ui.panel.CurrentStepPanel;
import com.cluejuggler.ui.panel.HeaderPanel;
import com.cluejuggler.ui.panel.ListsSectionPanel;
import com.cluejuggler.ui.view.BadListView;
import com.cluejuggler.ui.view.CustomListView;
import com.cluejuggler.ui.view.GoodListView;
import com.cluejuggler.ui.view.SettingsView;
import java.awt.BorderLayout;
import java.awt.CardLayout;
import java.awt.Color;
import java.awt.Dimension;
import java.awt.FlowLayout;
import java.io.File;
import javax.inject.Inject;
import javax.swing.Box;
import javax.swing.BoxLayout;
import javax.swing.JButton;
import javax.swing.JColorChooser;
import javax.swing.JFileChooser;
import javax.swing.JLabel;
import javax.swing.JOptionPane;
import javax.swing.JPanel;
import javax.swing.JScrollPane;
import javax.swing.JTextField;
import javax.swing.border.EmptyBorder;
import javax.swing.border.LineBorder;
import javax.swing.filechooser.FileNameExtensionFilter;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.ui.PluginPanel;

public class ClueJugglerPanel extends PluginPanel
{
	private static final String MAIN_VIEW = "MAIN";
	private static final String SETTINGS_VIEW = "SETTINGS";
	private static final String GOOD_LIST_VIEW = "GOOD_LIST";
	private static final String BAD_LIST_VIEW = "BAD_LIST";
	private static final String CUSTOM_LIST_VIEW = "CUSTOM_LIST";
	
	private final CardLayout cardLayout = new CardLayout();
	private final JPanel cardPanel = new JPanel(cardLayout);
	
	private ClueJugglerPlugin plugin;
	
	@Inject
	private ConfigManager configManager;
	
	private HeaderPanel headerPanel;
	private CurrentStepPanel currentStepPanel;
	private ListsSectionPanel listsSectionPanel;
	private GoodListView goodListView;
	private BadListView badListView;
	private CustomListView customListView;
	private SettingsView settingsView;
	
	private boolean initialized = false;

	public ClueJugglerPanel()
	{
		super();
		setLayout(new BorderLayout());
		setBorder(new EmptyBorder(5, 0, 5, 0));
		setBackground(new Color(26, 26, 26));
	}
	
	public void setPlugin(ClueJugglerPlugin plugin)
	{
		this.plugin = plugin;
		initializeUI();
	}
	
	private void initializeUI()
	{
		if (initialized || plugin == null)
		{
			return;
		}
		
		ClueListService listService = plugin.getListService();
		
		JPanel mainPanel = new JPanel();
		mainPanel.setLayout(new BoxLayout(mainPanel, BoxLayout.Y_AXIS));
		mainPanel.setBackground(new Color(26, 26, 26));
		
		headerPanel = new HeaderPanel();
		headerPanel.setAlignmentX(0.0f);
		headerPanel.setOnSettingsClick(() -> {
			settingsView.refresh();
			cardLayout.show(cardPanel, SETTINGS_VIEW);
		});
		mainPanel.add(headerPanel);
		
		currentStepPanel = new CurrentStepPanel();
		currentStepPanel.setOnGoodClick((text, identifier) -> addToGoodList(text, identifier));
		currentStepPanel.setOnBadClick((text, identifier) -> addToBadList(text, identifier));
		mainPanel.add(currentStepPanel);
		
		listsSectionPanel = new ListsSectionPanel();
		listsSectionPanel.setOnGoodListClick(() -> {
			goodListView.refresh();
			cardLayout.show(cardPanel, GOOD_LIST_VIEW);
		});
		listsSectionPanel.setOnBadListClick(() -> {
			badListView.refresh();
			cardLayout.show(cardPanel, BAD_LIST_VIEW);
		});
		listsSectionPanel.setOnAddListClick(this::showCreateListDialog);
		listsSectionPanel.setOnCustomListClick(list -> {
			customListView.setList(list);
			cardLayout.show(cardPanel, CUSTOM_LIST_VIEW);
		});
		listsSectionPanel.setOnDeleteCustomList(list -> {
			int result = javax.swing.JOptionPane.showConfirmDialog(
						this,
				"Delete list '" + list.getName() + "'?",
				"Confirm Delete",
				javax.swing.JOptionPane.YES_NO_OPTION
			);
			if (result == javax.swing.JOptionPane.YES_OPTION)
			{
				plugin.getListService().deleteCustomList(list);
				listsSectionPanel.refreshCustomLists(plugin.getListService().getCustomLists());
				refreshCustomListButtons();
			}
		});
		mainPanel.add(listsSectionPanel);
		
		mainPanel.add(Box.createVerticalStrut(5));
		
		JPanel importExportPanel = new JPanel(new FlowLayout(FlowLayout.LEFT, 5, 0));
		importExportPanel.setBackground(new Color(26, 26, 26));
		importExportPanel.setAlignmentX(0.0f);
		importExportPanel.setMaximumSize(new Dimension(Integer.MAX_VALUE, 35));
		
		JButton exportButton = new JButton("Export");
		exportButton.setBackground(new Color(60, 60, 60));
		exportButton.setForeground(Color.WHITE);
		exportButton.setFocusPainted(false);
		exportButton.addActionListener(e -> exportLists());
		importExportPanel.add(exportButton);
		
		JButton importButton = new JButton("Import");
		importButton.setBackground(new Color(60, 60, 60));
		importButton.setForeground(Color.WHITE);
		importButton.setFocusPainted(false);
		importButton.addActionListener(e -> importLists());
		importExportPanel.add(importButton);
		
		mainPanel.add(importExportPanel);
		
		JScrollPane mainScrollPane = new JScrollPane(mainPanel);
		mainScrollPane.setBackground(new Color(26, 26, 26));
		mainScrollPane.getViewport().setBackground(new Color(26, 26, 26));
		mainScrollPane.setBorder(null);
		mainScrollPane.setHorizontalScrollBarPolicy(JScrollPane.HORIZONTAL_SCROLLBAR_NEVER);
		
		goodListView = new GoodListView(listService);
		goodListView.setOnBackClick(() -> cardLayout.show(cardPanel, MAIN_VIEW));
		
		badListView = new BadListView(listService);
		badListView.setOnBackClick(() -> cardLayout.show(cardPanel, MAIN_VIEW));
		
		customListView = new CustomListView(listService);
		customListView.setOnBackClick(() -> {
			listsSectionPanel.refreshCustomLists(listService.getCustomLists());
			cardLayout.show(cardPanel, MAIN_VIEW);
		});
		
		settingsView = new SettingsView(listService, configManager);
		settingsView.setOnBackClick(() -> cardLayout.show(cardPanel, MAIN_VIEW));
		
		cardPanel.add(mainScrollPane, MAIN_VIEW);
		cardPanel.add(goodListView, GOOD_LIST_VIEW);
		cardPanel.add(badListView, BAD_LIST_VIEW);
		cardPanel.add(customListView, CUSTOM_LIST_VIEW);
		cardPanel.add(settingsView, SETTINGS_VIEW);
		cardPanel.setBackground(new Color(26, 26, 26));
		
		add(cardPanel, BorderLayout.CENTER);
		
		listService.ensureListsLoaded();
		listsSectionPanel.refreshCustomLists(listService.getCustomLists());
		refreshCustomListButtons();
		
		initialized = true;
	}
	
	private void addToGoodList(String text, String identifier)
	{
		if (text == null || text.isEmpty())
		{
			return;
		}
		
		ClueListService listService = plugin.getListService();
		if (identifier == null || identifier.isEmpty())
		{
			identifier = "text:" + text.hashCode();
		}
		
		listService.addGoodClue(identifier, text);
		plugin.getTrackingService().clearClueStatusCacheEntry(identifier);
		plugin.getTrackingService().clearClueStatusCache();
		updateButtonStates(text);
	}
	
	private void addToBadList(String text, String identifier)
	{
		if (text == null || text.isEmpty())
		{
			return;
		}
		
		ClueListService listService = plugin.getListService();
			if (identifier == null || identifier.isEmpty())
			{
				identifier = "text:" + text.hashCode();
			}
			
		listService.addBadClue(identifier, text);
		plugin.getTrackingService().clearClueStatusCacheEntry(identifier);
		plugin.getTrackingService().clearClueStatusCache();
		updateButtonStates(text);
	}
	
	private void updateButtonStates(String text)
	{
		if (text == null)
		{
			return;
		}
		
		ClueListService listService = plugin.getListService();
		boolean isGood = listService.isGoodClue(text);
		boolean isBad = listService.isBadClue(text);
		ClueList customList = listService.getCustomListForClueByText(text);
		
		currentStepPanel.updateButtonStates(isGood, isBad, customList);
	}
	
	private void refreshCustomListButtons()
	{
		if (currentStepPanel != null && plugin != null)
		{
			ClueListService listService = plugin.getListService();
			currentStepPanel.refreshCustomListButtons(listService.getCustomLists(), (list, identifier) -> {
				String text = currentStepPanel.getCurrentClueText();
		if (text != null && !text.isEmpty())
		{
			if (identifier == null || identifier.isEmpty())
			{
				identifier = "text:" + text.hashCode();
			}
					listService.addToCustomList(list, identifier, text);
					plugin.getTrackingService().clearClueStatusCacheEntry(identifier);
					plugin.getTrackingService().clearClueStatusCache();
			updateButtonStates(text);
				}
			});
		}
	}

	private void showCreateListDialog()
	{
		JPanel dialogPanel = new JPanel();
		dialogPanel.setLayout(new BoxLayout(dialogPanel, BoxLayout.Y_AXIS));
		dialogPanel.setBorder(new EmptyBorder(10, 10, 10, 10));
		dialogPanel.setBackground(new Color(26, 26, 26));

		JLabel nameLabel = new JLabel("List Name:");
		nameLabel.setForeground(Color.WHITE);
		dialogPanel.add(nameLabel);

		JTextField nameField = new JTextField(20);
		nameField.setBackground(new Color(20, 20, 20));
		nameField.setForeground(Color.WHITE);
		nameField.setBorder(new EmptyBorder(5, 5, 5, 5));
		dialogPanel.add(nameField);
		dialogPanel.add(Box.createVerticalStrut(10));

		JLabel textColorLabel = new JLabel("Text Color:");
		textColorLabel.setForeground(Color.WHITE);
		dialogPanel.add(textColorLabel);

		final Color[] selectedTextColor = {Color.WHITE};
		javax.swing.JButton textColorButton = new javax.swing.JButton();
		textColorButton.setPreferredSize(new Dimension(60, 30));
		textColorButton.setMaximumSize(new Dimension(60, 30));
		textColorButton.setBackground(selectedTextColor[0]);
		textColorButton.setBorder(new LineBorder(Color.WHITE, 1));
		textColorButton.setFocusPainted(false);
		textColorButton.addActionListener(e -> {
			Color newColor = JColorChooser.showDialog(dialogPanel, "Choose Text Color", selectedTextColor[0]);
			if (newColor != null)
			{
				textColorButton.setBackground(newColor);
				selectedTextColor[0] = newColor;
			}
		});
		dialogPanel.add(textColorButton);
		dialogPanel.add(Box.createVerticalStrut(10));

		JLabel tileColorLabel = new JLabel("Tile Color:");
		tileColorLabel.setForeground(Color.WHITE);
		dialogPanel.add(tileColorLabel);

		final Color[] selectedTileColor = {new Color(255, 255, 255, 100)};
		javax.swing.JButton tileColorButton = new javax.swing.JButton();
		tileColorButton.setPreferredSize(new Dimension(60, 30));
		tileColorButton.setMaximumSize(new Dimension(60, 30));
		tileColorButton.setBackground(selectedTileColor[0]);
		tileColorButton.setBorder(new LineBorder(Color.WHITE, 1));
		tileColorButton.setFocusPainted(false);
		tileColorButton.addActionListener(e -> {
			Color newColor = JColorChooser.showDialog(dialogPanel, "Choose Tile Color", selectedTileColor[0]);
			if (newColor != null)
			{
				int alpha = selectedTileColor[0].getAlpha();
				if (alpha == 255)
				{
					alpha = 100;
				}
				Color colorWithAlpha = new Color(newColor.getRed(), newColor.getGreen(), newColor.getBlue(), alpha);
				tileColorButton.setBackground(colorWithAlpha);
				selectedTileColor[0] = colorWithAlpha;
			}
		});
		dialogPanel.add(tileColorButton);

		int result = JOptionPane.showConfirmDialog(
			this,
			dialogPanel,
			"Create New List",
			JOptionPane.OK_CANCEL_OPTION,
			JOptionPane.PLAIN_MESSAGE
		);

		if (result == JOptionPane.OK_OPTION)
		{
			String listName = nameField.getText().trim();
			if (listName.isEmpty())
			{
				JOptionPane.showMessageDialog(this, "List name cannot be empty!", "Error", JOptionPane.ERROR_MESSAGE);
				return;
			}

			ClueListService listService = plugin.getListService();
			if (listService.findCustomListByName(listName) != null)
			{
				JOptionPane.showMessageDialog(this, "A list with that name already exists!", "Error", JOptionPane.ERROR_MESSAGE);
				return;
			}

			listService.createCustomList(listName, selectedTextColor[0], selectedTileColor[0], selectedTextColor[0]);
			listsSectionPanel.refreshCustomLists(listService.getCustomLists());
			refreshCustomListButtons();
		}
	}

	private void exportLists()
	{
		if (plugin == null)
		{
			return;
		}
		
		JFileChooser fileChooser = new JFileChooser();
		fileChooser.setDialogTitle("Export All Lists");
		fileChooser.setFileFilter(new FileNameExtensionFilter("JSON Files", "json"));
		fileChooser.setSelectedFile(new File("cluejuggler-lists.json"));
		
		if (fileChooser.showSaveDialog(this) == JFileChooser.APPROVE_OPTION)
		{
			File file = fileChooser.getSelectedFile();
			if (!file.getName().endsWith(".json"))
			{
				file = new File(file.getAbsolutePath() + ".json");
			}
			plugin.getListService().exportToFile(file);
			JOptionPane.showMessageDialog(this, "Export successful!", "Success", JOptionPane.INFORMATION_MESSAGE);
		}
	}
	
	private void importLists()
	{
		if (plugin == null)
		{
			return;
		}

		JFileChooser fileChooser = new JFileChooser();
		fileChooser.setDialogTitle("Import Lists");
		fileChooser.setFileFilter(new FileNameExtensionFilter("JSON Files", "json"));
		
		if (fileChooser.showOpenDialog(this) == JFileChooser.APPROVE_OPTION)
		{
			File file = fileChooser.getSelectedFile();
			plugin.getListService().importFromFile(file);
			listsSectionPanel.refreshCustomLists(plugin.getListService().getCustomLists());
			refreshCustomListButtons();
			JOptionPane.showMessageDialog(this, "Import successful!", "Success", JOptionPane.INFORMATION_MESSAGE);
		}
	}

	public void setCurrentStep(String difficulty, String clueText)
	{
		if (currentStepPanel != null)
		{
			currentStepPanel.setCurrentStep(difficulty, clueText);
			
			if (plugin != null)
			{
				net.runelite.client.plugins.cluescrolls.clues.ClueScroll clue = plugin.getClueScrollPlugin().getClue();
							if (clue != null)
							{
					String identifier = plugin.getClueIdentifier(clue);
					currentStepPanel.setCurrentClueIdentifier(identifier);
				}
			}
			
			updateButtonStates(clueText);
		}
	}
	
	public void setCurrentStep(String clueText)
	{
		setCurrentStep("Unknown", clueText);
	}
	
	public boolean isGoodClue(String clueText)
	{
		return plugin != null && plugin.getListService().isGoodClue(clueText);
	}
	
	public boolean isBadClue(String clueText)
	{
		return plugin != null && plugin.getListService().isBadClue(clueText);
	}
	
	public boolean isGoodClueByIdentifier(String identifier)
	{
		return plugin != null && plugin.getListService().isGoodClueByIdentifier(identifier);
	}
	
	public boolean isBadClueByIdentifier(String identifier)
	{
		return plugin != null && plugin.getListService().isBadClueByIdentifier(identifier);
	}
	
	public ClueList getCustomListForClue(String identifier)
	{
		return plugin != null ? plugin.getListService().getCustomListForClue(identifier) : null;
	}
	
	public ClueList getCustomListForClueByText(String clueText)
	{
		return plugin != null ? plugin.getListService().getCustomListForClueByText(clueText) : null;
	}
	
	public boolean hasAnyCluesInLists()
	{
		return plugin != null && plugin.getListService().hasAnyCluesInLists();
	}
	
	public void ensureListsLoaded()
	{
		if (plugin != null)
		{
			plugin.getListService().ensureListsLoaded();
		}
	}
	
	public void ensureCustomListsLoaded()
	{
			if (plugin != null)
			{
			plugin.getListService().loadCustomLists();
		}
	}
}


package com.cluejuggler.ui.component;

import java.awt.BorderLayout;
import java.awt.Color;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.util.function.BiConsumer;
import javax.swing.JMenuItem;
import javax.swing.JPanel;
import javax.swing.JPopupMenu;
import javax.swing.JScrollPane;
import javax.swing.JTable;
import javax.swing.table.DefaultTableModel;
import javax.swing.table.TableColumn;

public class ClueTableComponent extends JPanel
{
	private final JTable table;
	private final DefaultTableModel model;
	private BiConsumer<String, String> onDeleteClue;
	private BiConsumer<String, String> onMoveClue;
	
	public ClueTableComponent()
	{
		setLayout(new BorderLayout());
		setBackground(new Color(26, 26, 26));
		
		model = new DefaultTableModel(new String[]{"Clue", "Identifier"}, 0);
		table = new JTable(model);
		table.setBackground(new Color(20, 20, 20));
		table.setForeground(Color.WHITE);
		table.setGridColor(new Color(40, 40, 40));
		table.getTableHeader().setBackground(new Color(30, 30, 30));
		table.getTableHeader().setForeground(Color.WHITE);
		table.setRowHeight(25);
		
		TableColumn identifierColumn = table.getColumnModel().getColumn(1);
		identifierColumn.setPreferredWidth(0);
		identifierColumn.setMinWidth(0);
		identifierColumn.setMaxWidth(0);
		identifierColumn.setWidth(0);
		
		setupContextMenu();
		
		JScrollPane scrollPane = new JScrollPane(table);
		scrollPane.setBackground(new Color(26, 26, 26));
		scrollPane.getViewport().setBackground(new Color(20, 20, 20));
		add(scrollPane, BorderLayout.CENTER);
	}
	
	private void setupContextMenu()
	{
		JPopupMenu contextMenu = new JPopupMenu();
		
		JMenuItem deleteItem = new JMenuItem("Delete");
		deleteItem.addActionListener(e -> {
			int selectedRow = table.getSelectedRow();
			if (selectedRow >= 0)
			{
				String text = (String) model.getValueAt(selectedRow, 0);
				String identifier = (String) model.getValueAt(selectedRow, 1);
				if (onDeleteClue != null)
				{
					onDeleteClue.accept(text, identifier);
				}
				model.removeRow(selectedRow);
			}
		});
		contextMenu.add(deleteItem);
		
		table.addMouseListener(new MouseAdapter()
		{
			@Override
			public void mousePressed(MouseEvent e)
			{
				if (e.isPopupTrigger())
				{
					showPopup(e);
				}
			}
			
			@Override
			public void mouseReleased(MouseEvent e)
			{
				if (e.isPopupTrigger())
				{
					showPopup(e);
				}
			}
			
			private void showPopup(MouseEvent e)
			{
				int row = table.rowAtPoint(e.getPoint());
				if (row >= 0 && row < table.getRowCount())
				{
					table.setRowSelectionInterval(row, row);
					contextMenu.show(e.getComponent(), e.getX(), e.getY());
				}
			}
		});
	}
	
	public void addRow(String text, String identifier)
	{
		model.addRow(new Object[]{text, identifier});
	}
	
	public void removeRow(int index)
	{
		if (index >= 0 && index < model.getRowCount())
		{
			model.removeRow(index);
		}
	}
	
	public void clear()
	{
		model.setRowCount(0);
	}
	
	public int getRowCount()
	{
		return model.getRowCount();
	}
	
	public String getTextAt(int row)
	{
		return (String) model.getValueAt(row, 0);
	}
	
	public String getIdentifierAt(int row)
	{
		return (String) model.getValueAt(row, 1);
	}
	
	public DefaultTableModel getModel()
	{
		return model;
	}
	
	public JTable getTable()
	{
		return table;
	}
	
	public void setOnDeleteClue(BiConsumer<String, String> onDeleteClue)
	{
		this.onDeleteClue = onDeleteClue;
	}
	
	public void setOnMoveClue(BiConsumer<String, String> onMoveClue)
	{
		this.onMoveClue = onMoveClue;
	}
}


package com.cluejuggler.ui.component;

import java.awt.Color;
import java.awt.Dimension;
import java.awt.FlowLayout;
import java.util.function.Consumer;
import javax.swing.JButton;
import javax.swing.JColorChooser;
import javax.swing.JLabel;
import javax.swing.JPanel;
import javax.swing.border.EmptyBorder;
import javax.swing.border.LineBorder;

public class ColorPickerRow extends JPanel
{
	private final JButton colorButton;
	private Color currentColor;
	private final Consumer<Color> onColorChange;
	
	public ColorPickerRow(String name, String description, Color initialColor, Consumer<Color> onColorChange)
	{
		this.currentColor = initialColor;
		this.onColorChange = onColorChange;
		
		setLayout(new FlowLayout(FlowLayout.LEFT, 0, 0));
		setBackground(new Color(26, 26, 26));
		setBorder(new EmptyBorder(5, 0, 5, 0));
		setMaximumSize(new Dimension(Integer.MAX_VALUE, 40));
		setAlignmentX(0.0f);
		
		JLabel nameLabel = new JLabel(name + ": ");
		nameLabel.setForeground(Color.WHITE);
		nameLabel.setToolTipText(description);
		add(nameLabel);
		
		colorButton = new JButton();
		colorButton.setPreferredSize(new Dimension(30, 20));
		colorButton.setBackground(initialColor);
		colorButton.setBorder(new LineBorder(Color.WHITE, 1));
		colorButton.setFocusPainted(false);
		colorButton.addActionListener(e -> showColorChooser());
		add(colorButton);
	}
	
	private void showColorChooser()
	{
		Color newColor = JColorChooser.showDialog(this, "Choose Color", currentColor);
		if (newColor != null)
		{
			if (currentColor.getAlpha() != 255)
			{
				newColor = new Color(newColor.getRed(), newColor.getGreen(), newColor.getBlue(), currentColor.getAlpha());
			}
			currentColor = newColor;
			colorButton.setBackground(currentColor);
			if (onColorChange != null)
			{
				onColorChange.accept(currentColor);
			}
		}
	}
	
	public Color getCurrentColor()
	{
		return currentColor;
	}
	
	public void setCurrentColor(Color color)
	{
		this.currentColor = color;
		colorButton.setBackground(color);
	}
}


package com.cluejuggler.ui.component;

import java.awt.BorderLayout;
import java.awt.Color;
import java.awt.Cursor;
import java.awt.Dimension;
import java.awt.FlowLayout;
import java.awt.Font;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.awt.image.BufferedImage;
import javax.swing.ImageIcon;
import javax.swing.JButton;
import javax.swing.JLabel;
import javax.swing.JPanel;
import javax.swing.border.EmptyBorder;
import net.runelite.client.util.ImageUtil;

public class ListCardComponent extends JPanel
{
	private final JLabel titleLabel;
	private Runnable onClick;
	private Runnable onDelete;
	private boolean isCustomList;
	
	public ListCardComponent(String title, Color titleColor, boolean isCustomList)
	{
		this.isCustomList = isCustomList;
		setLayout(new BorderLayout());
		setBorder(new EmptyBorder(8, 8, 8, 8));
		setBackground(new Color(40, 40, 40));
		setCursor(new Cursor(Cursor.HAND_CURSOR));
		setMaximumSize(new Dimension(Integer.MAX_VALUE, 40));
		setPreferredSize(new Dimension(190, 40));
		
		titleLabel = new JLabel(title);
		titleLabel.setForeground(titleColor);
		titleLabel.setFont(new Font(titleLabel.getFont().getName(), Font.BOLD, 13));
		add(titleLabel, BorderLayout.WEST);
		
		JPanel rightPanel = new JPanel(new FlowLayout(FlowLayout.RIGHT, 5, 0));
		rightPanel.setOpaque(false);
		
		if (isCustomList)
		{
			JButton deleteButton = new JButton();
			try
			{
				BufferedImage deleteIcon = ImageUtil.loadImageResource(getClass(), "/delete.png");
				if (deleteIcon != null)
				{
					deleteButton.setIcon(new ImageIcon(deleteIcon));
				}
				else
				{
					deleteButton.setText("");
					deleteButton.setFont(new Font(deleteButton.getFont().getName(), Font.BOLD, 10));
				}
			}
			catch (Exception ex)
			{
				deleteButton.setText("");
				deleteButton.setFont(new Font(deleteButton.getFont().getName(), Font.BOLD, 10));
			}
			deleteButton.setForeground(new Color(180, 80, 80));
			deleteButton.setBackground(new Color(60, 60, 60));
			deleteButton.setBorderPainted(false);
			deleteButton.setFocusPainted(false);
			deleteButton.setContentAreaFilled(false);
			deleteButton.setCursor(new Cursor(Cursor.HAND_CURSOR));
			deleteButton.addActionListener(e -> {
				if (onDelete != null)
				{
					onDelete.run();
				}
			});
			rightPanel.add(deleteButton);
		}
		
		JLabel arrow = new JLabel();
		try
		{
			BufferedImage arrowIcon = ImageUtil.loadImageResource(getClass(), "/open_arrow.png");
			if (arrowIcon != null)
			{
				arrow.setIcon(new ImageIcon(arrowIcon));
			}
			else
			{
				arrow.setText("");
				arrow.setForeground(new Color(120, 120, 120));
			}
		}
		catch (Exception ex)
		{
			arrow.setText("");
			arrow.setForeground(new Color(120, 120, 120));
		}
		rightPanel.add(arrow);
		
		add(rightPanel, BorderLayout.EAST);
		
		addMouseListener(new MouseAdapter()
		{
			@Override
			public void mouseClicked(MouseEvent e)
			{
				if (onClick != null)
				{
					onClick.run();
				}
			}
			
			@Override
			public void mouseEntered(MouseEvent e)
			{
				setBackground(new Color(50, 50, 50));
			}
			
			@Override
			public void mouseExited(MouseEvent e)
			{
				setBackground(new Color(40, 40, 40));
			}
		});
	}
	
	public void setOnClick(Runnable onClick)
	{
		this.onClick = onClick;
	}
	
	public void setOnDelete(Runnable onDelete)
	{
		this.onDelete = onDelete;
	}
	
	public void setTitle(String title)
	{
		titleLabel.setText(title);
	}
	
	public void setTitleColor(Color color)
	{
		titleLabel.setForeground(color);
	}
	
	public String getTitle()
	{
		return titleLabel.getText();
	}
	
	public boolean isCustomList()
	{
		return isCustomList;
	}
}


package com.cluejuggler.ui.panel;

import com.cluejuggler.model.ClueList;
import java.awt.Color;
import java.awt.Dimension;
import java.awt.FlowLayout;
import java.awt.Font;
import java.util.HashMap;
import java.util.Map;
import java.util.function.BiConsumer;
import javax.swing.BoxLayout;
import javax.swing.JButton;
import javax.swing.JLabel;
import javax.swing.JPanel;
import javax.swing.JTextArea;
import javax.swing.border.EmptyBorder;

public class CurrentStepPanel extends JPanel
{
	private final JLabel clueTypeLabel;
	private final JTextArea currentStepArea;
	private final JButton goodButton;
	private final JButton badButton;
	private final JPanel buttonPanel;
	private final Map<String, JButton> customListButtons = new HashMap<>();
	
	private String currentClueText;
	private String currentClueIdentifier;
	private BiConsumer<String, String> onGoodClick;
	private BiConsumer<String, String> onBadClick;
	
	public CurrentStepPanel()
	{
		setLayout(new BoxLayout(this, BoxLayout.Y_AXIS));
		setBackground(new Color(26, 26, 26));
		setBorder(new EmptyBorder(0, 0, 5, 0));
		setAlignmentX(0.0f);
		
		JLabel headerLabel = new JLabel("Current Step");
		headerLabel.setForeground(Color.WHITE);
		headerLabel.setFont(new Font(headerLabel.getFont().getName(), Font.BOLD, 14));
		headerLabel.setBorder(new EmptyBorder(0, 0, 8, 0));
		headerLabel.setAlignmentX(0.0f);
		add(headerLabel);
		
		clueTypeLabel = new JLabel("Clue Type: Unknown");
		clueTypeLabel.setForeground(new Color(180, 180, 180));
		clueTypeLabel.setFont(new Font(clueTypeLabel.getFont().getName(), Font.PLAIN, 12));
		clueTypeLabel.setBorder(new EmptyBorder(0, 0, 5, 0));
		clueTypeLabel.setAlignmentX(0.0f);
		add(clueTypeLabel);
		
		currentStepArea = new JTextArea(4, 20);
		currentStepArea.setEditable(false);
		currentStepArea.setLineWrap(true);
		currentStepArea.setWrapStyleWord(true);
		currentStepArea.setBackground(new Color(20, 20, 20));
		currentStepArea.setForeground(Color.WHITE);
		currentStepArea.setBorder(new EmptyBorder(8, 8, 8, 8));
		currentStepArea.setText("Read a clue scroll to see the current step here.");
		currentStepArea.setAlignmentX(0.0f);
		currentStepArea.setMaximumSize(new Dimension(Integer.MAX_VALUE, 100));
		add(currentStepArea);
		
		buttonPanel = new JPanel(new FlowLayout(FlowLayout.LEFT, 3, 3));
		buttonPanel.setBackground(new Color(26, 26, 26));
		buttonPanel.setAlignmentX(0.0f);
		buttonPanel.setMaximumSize(new Dimension(Integer.MAX_VALUE, 60));
		
		goodButton = new JButton("Good");
		goodButton.setBackground(new Color(0, 100, 0));
		goodButton.setForeground(Color.WHITE);
		goodButton.setFocusPainted(false);
		goodButton.setPreferredSize(new Dimension(60, 24));
		goodButton.addActionListener(e -> {
			if (onGoodClick != null && currentClueText != null)
			{
				onGoodClick.accept(currentClueText, currentClueIdentifier);
			}
		});
		buttonPanel.add(goodButton);
		
		badButton = new JButton("Bad");
		badButton.setBackground(new Color(100, 0, 0));
		badButton.setForeground(Color.WHITE);
		badButton.setFocusPainted(false);
		badButton.setPreferredSize(new Dimension(60, 24));
		badButton.addActionListener(e -> {
			if (onBadClick != null && currentClueText != null)
			{
				onBadClick.accept(currentClueText, currentClueIdentifier);
			}
		});
		buttonPanel.add(badButton);
		
		add(buttonPanel);
	}
	
	public void setCurrentStep(String difficulty, String clueText)
	{
		this.currentClueText = clueText;
		clueTypeLabel.setText("Clue Type: " + difficulty);
		currentStepArea.setText(clueText);
	}
	
	public void setCurrentClueIdentifier(String identifier)
	{
		this.currentClueIdentifier = identifier;
	}
	
	public void setOnGoodClick(BiConsumer<String, String> onGoodClick)
	{
		this.onGoodClick = onGoodClick;
	}
	
	public void setOnBadClick(BiConsumer<String, String> onBadClick)
	{
		this.onBadClick = onBadClick;
	}
	
	public void updateButtonStates(boolean isGood, boolean isBad, ClueList customList)
	{
		if (isGood)
		{
			goodButton.setBackground(new Color(0, 150, 0));
			badButton.setBackground(new Color(100, 0, 0));
		}
		else if (isBad)
		{
			goodButton.setBackground(new Color(0, 100, 0));
			badButton.setBackground(new Color(150, 0, 0));
		}
		else
		{
			goodButton.setBackground(new Color(0, 100, 0));
			badButton.setBackground(new Color(100, 0, 0));
		}
		
		for (Map.Entry<String, JButton> entry : customListButtons.entrySet())
		{
			JButton button = entry.getValue();
			if (customList != null && customList.getName().equals(entry.getKey()))
			{
				button.setBackground(customList.getTextColor().brighter());
			}
			else
			{
				button.setBackground(new Color(60, 60, 60));
			}
		}
	}
	
	public void refreshCustomListButtons(java.util.List<ClueList> customLists, java.util.function.BiConsumer<ClueList, String> onCustomListClick)
	{
		for (JButton button : customListButtons.values())
		{
			buttonPanel.remove(button);
		}
		customListButtons.clear();
		
		for (ClueList list : customLists)
		{
			JButton listButton = new JButton(list.getName());
			listButton.setBackground(new Color(60, 60, 60));
			listButton.setForeground(list.getTextColor());
			listButton.setFocusPainted(false);
			listButton.setPreferredSize(new Dimension(60, 24));
			listButton.addActionListener(e -> {
				if (onCustomListClick != null && currentClueText != null)
				{
					onCustomListClick.accept(list, currentClueIdentifier);
				}
			});
			customListButtons.put(list.getName(), listButton);
			buttonPanel.add(listButton);
		}
		
		buttonPanel.revalidate();
		buttonPanel.repaint();
	}
	
	public String getCurrentClueText()
	{
		return currentClueText;
	}
	
	public String getCurrentClueIdentifier()
	{
		return currentClueIdentifier;
	}
}


package com.cluejuggler.ui.panel;

import java.awt.BorderLayout;
import java.awt.Color;
import java.awt.Dimension;
import java.awt.Font;
import java.awt.image.BufferedImage;
import javax.swing.ImageIcon;
import javax.swing.JButton;
import javax.swing.JLabel;
import javax.swing.JPanel;
import javax.swing.border.EmptyBorder;
import net.runelite.client.util.ImageUtil;

public class HeaderPanel extends JPanel
{
	private final JLabel headerLabel;
	private final JButton settingsButton;
	private Runnable onSettingsClick;
	
	public HeaderPanel()
	{
		setLayout(new BorderLayout());
		setBorder(new EmptyBorder(0, 0, 8, 0));
		setBackground(new Color(26, 26, 26));
		setMaximumSize(new Dimension(Integer.MAX_VALUE, 48));
		setPreferredSize(new Dimension(190, 48));
		
		JPanel leftPanel = new JPanel(new BorderLayout());
		leftPanel.setBackground(new Color(26, 26, 26));
		
		try
		{
			BufferedImage iconImage = ImageUtil.loadImageResource(getClass(), "/cluejuggler.png");
			if (iconImage != null)
			{
				ImageIcon icon = new ImageIcon(iconImage.getScaledInstance(32, 32, java.awt.Image.SCALE_SMOOTH));
				JLabel iconLabel = new JLabel(icon);
				iconLabel.setBorder(new EmptyBorder(0, 0, 0, 10));
				leftPanel.add(iconLabel, BorderLayout.WEST);
			}
		}
		catch (Exception e)
		{
		}
		
		JPanel titlePanel = new JPanel(new BorderLayout());
		titlePanel.setBackground(new Color(26, 26, 26));
		
		headerLabel = new JLabel("Clue Juggler");
		headerLabel.setFont(new Font(headerLabel.getFont().getName(), Font.BOLD, 18));
		headerLabel.setForeground(Color.WHITE);
		titlePanel.add(headerLabel, BorderLayout.NORTH);
		
		JLabel creditLabel = new JLabel("by: [RSN] Rocket Money");
		creditLabel.setFont(new Font(creditLabel.getFont().getName(), Font.PLAIN, 11));
		creditLabel.setForeground(new Color(150, 150, 150));
		creditLabel.setBorder(new EmptyBorder(2, 0, 0, 0));
		titlePanel.add(creditLabel, BorderLayout.CENTER);
		
		leftPanel.add(titlePanel, BorderLayout.CENTER);
		add(leftPanel, BorderLayout.CENTER);
		
		settingsButton = new JButton();
		try
		{
			BufferedImage settingsIcon = ImageUtil.loadImageResource(getClass(), "/settings.png");
			if (settingsIcon != null)
			{
				settingsButton.setIcon(new ImageIcon(settingsIcon.getScaledInstance(20, 20, java.awt.Image.SCALE_SMOOTH)));
			}
			else
			{
				settingsButton.setText("");
			}
		}
		catch (Exception e)
		{
			settingsButton.setText("");
		}
		settingsButton.setBackground(new Color(60, 60, 60));
		settingsButton.setForeground(Color.WHITE);
		settingsButton.setFocusPainted(false);
		settingsButton.setBorderPainted(false);
		settingsButton.setContentAreaFilled(false);
		settingsButton.setPreferredSize(new Dimension(24, 24));
		settingsButton.addActionListener(e -> {
			if (onSettingsClick != null)
			{
				onSettingsClick.run();
			}
		});
		
		JPanel settingsPanel = new JPanel(new BorderLayout());
		settingsPanel.setBackground(new Color(26, 26, 26));
		settingsPanel.setBorder(new EmptyBorder(0, 0, 0, 5));
		settingsPanel.add(settingsButton, BorderLayout.CENTER);
		add(settingsPanel, BorderLayout.EAST);
	}
	
	public void setOnSettingsClick(Runnable onSettingsClick)
	{
		this.onSettingsClick = onSettingsClick;
	}
	
	public void setHeaderText(String text)
	{
		headerLabel.setText(text);
	}
}


package com.cluejuggler.ui.panel;

import com.cluejuggler.model.ClueList;
import com.cluejuggler.ui.component.ListCardComponent;
import java.awt.Color;
import java.awt.Font;
import java.util.ArrayList;
import java.util.List;
import javax.swing.Box;
import javax.swing.BoxLayout;
import javax.swing.JButton;
import javax.swing.JLabel;
import javax.swing.JPanel;
import javax.swing.border.EmptyBorder;

public class ListsSectionPanel extends JPanel
{
	private final List<ListCardComponent> customListCards = new ArrayList<>();
	private final List<java.awt.Component> customListSpacers = new ArrayList<>();
	private JButton addListButton;
	private java.awt.Component buttonSpacer;
	private Runnable onGoodListClick;
	private Runnable onBadListClick;
	private Runnable onAddListClick;
	private java.util.function.Consumer<ClueList> onCustomListClick;
	private java.util.function.Consumer<ClueList> onDeleteCustomList;
	
	public ListsSectionPanel()
	{
		setLayout(new BoxLayout(this, BoxLayout.Y_AXIS));
		setBackground(new Color(26, 26, 26));
		setAlignmentX(0.0f);
		
		JLabel headerLabel = new JLabel("Lists");
		headerLabel.setForeground(Color.WHITE);
		headerLabel.setFont(new Font(headerLabel.getFont().getName(), Font.BOLD, 14));
		headerLabel.setBorder(new EmptyBorder(0, 0, 8, 0));
		headerLabel.setAlignmentX(0.0f);
		add(headerLabel);
		
		ListCardComponent goodCard = new ListCardComponent("Good Steps", new Color(0, 150, 0), false);
		goodCard.setAlignmentX(0.0f);
		goodCard.setOnClick(() -> {
			if (onGoodListClick != null)
			{
				onGoodListClick.run();
			}
		});
		add(goodCard);
		
		add(Box.createVerticalStrut(5));
		
		ListCardComponent badCard = new ListCardComponent("Bad Steps", new Color(150, 0, 0), false);
		badCard.setAlignmentX(0.0f);
		badCard.setOnClick(() -> {
			if (onBadListClick != null)
			{
				onBadListClick.run();
			}
		});
		add(badCard);
		
		buttonSpacer = Box.createVerticalStrut(10);
		add(buttonSpacer);
		
		addListButton = new JButton("+ Add List");
		addListButton.setBackground(new Color(60, 60, 60));
		addListButton.setForeground(Color.WHITE);
		addListButton.setFocusPainted(false);
		addListButton.setAlignmentX(0.0f);
		addListButton.addActionListener(e -> {
			if (onAddListClick != null)
			{
				onAddListClick.run();
			}
		});
		add(addListButton);
	}
	
	public void setOnGoodListClick(Runnable onGoodListClick)
	{
		this.onGoodListClick = onGoodListClick;
	}
	
	public void setOnBadListClick(Runnable onBadListClick)
	{
		this.onBadListClick = onBadListClick;
	}
	
	public void setOnAddListClick(Runnable onAddListClick)
	{
		this.onAddListClick = onAddListClick;
	}
	
	public void setOnCustomListClick(java.util.function.Consumer<ClueList> onCustomListClick)
	{
		this.onCustomListClick = onCustomListClick;
	}
	
	public void setOnDeleteCustomList(java.util.function.Consumer<ClueList> onDeleteCustomList)
	{
		this.onDeleteCustomList = onDeleteCustomList;
	}
	
	public void refreshCustomLists(List<ClueList> customLists)
	{
		for (ListCardComponent card : customListCards)
		{
			remove(card);
		}
		customListCards.clear();
		
		for (java.awt.Component spacer : customListSpacers)
		{
			remove(spacer);
		}
		customListSpacers.clear();
		
		remove(buttonSpacer);
		remove(addListButton);
		
		for (ClueList list : customLists)
		{
			java.awt.Component spacer = Box.createVerticalStrut(5);
			customListSpacers.add(spacer);
			add(spacer);
			
			ListCardComponent card = new ListCardComponent(list.getName(), list.getTextColor(), true);
			card.setAlignmentX(0.0f);
			card.setOnClick(() -> {
				if (onCustomListClick != null)
				{
					onCustomListClick.accept(list);
				}
			});
			card.setOnDelete(() -> {
				if (onDeleteCustomList != null)
				{
					onDeleteCustomList.accept(list);
				}
			});
			customListCards.add(card);
			add(card);
		}
		
		buttonSpacer = Box.createVerticalStrut(10);
		add(buttonSpacer);
		add(addListButton);
		
		revalidate();
		repaint();
	}
}


package com.cluejuggler.ui.view;

import com.cluejuggler.service.ClueListService;
import com.cluejuggler.ui.component.ClueTableComponent;
import java.awt.BorderLayout;
import java.awt.Color;
import java.awt.FlowLayout;
import java.awt.Font;
import java.awt.image.BufferedImage;
import java.io.File;
import javax.swing.ImageIcon;
import javax.swing.JButton;
import javax.swing.JFileChooser;
import javax.swing.JLabel;
import javax.swing.JOptionPane;
import javax.swing.JPanel;
import javax.swing.border.EmptyBorder;
import javax.swing.filechooser.FileNameExtensionFilter;
import net.runelite.client.util.ImageUtil;

public class BadListView extends JPanel
{
	private final ClueTableComponent tableComponent;
	private final ClueListService listService;
	private Runnable onBackClick;
	
	public BadListView(ClueListService listService)
	{
		this.listService = listService;
		setLayout(new BorderLayout());
		setBorder(new EmptyBorder(5, 0, 5, 0));
		setBackground(new Color(26, 26, 26));
		
		JPanel headerPanel = new JPanel(new BorderLayout());
		headerPanel.setBorder(new EmptyBorder(0, 0, 10, 0));
		headerPanel.setBackground(new Color(26, 26, 26));
		
		JPanel leftPanel = new JPanel(new BorderLayout());
		leftPanel.setBackground(new Color(26, 26, 26));
		
		try
		{
			BufferedImage iconImage = ImageUtil.loadImageResource(getClass(), "/cluejuggler.png");
			if (iconImage != null)
			{
				ImageIcon icon = new ImageIcon(iconImage.getScaledInstance(32, 32, java.awt.Image.SCALE_SMOOTH));
				JLabel iconLabel = new JLabel(icon);
				iconLabel.setBorder(new EmptyBorder(0, 0, 0, 10));
				leftPanel.add(iconLabel, BorderLayout.WEST);
			}
		}
		catch (Exception e)
		{
		}
		
		JLabel titleLabel = new JLabel("Bad Steps");
		titleLabel.setFont(new Font(titleLabel.getFont().getName(), Font.BOLD, 18));
		titleLabel.setForeground(new Color(150, 0, 0));
		leftPanel.add(titleLabel, BorderLayout.CENTER);
		
		headerPanel.add(leftPanel, BorderLayout.CENTER);
		
		JButton backButton = new JButton(" Back");
		backButton.setBackground(new Color(60, 60, 60));
		backButton.setForeground(Color.WHITE);
		backButton.setFocusPainted(false);
		backButton.addActionListener(e -> {
			if (onBackClick != null)
			{
				onBackClick.run();
			}
		});
		headerPanel.add(backButton, BorderLayout.EAST);
		
		add(headerPanel, BorderLayout.NORTH);
		
		tableComponent = new ClueTableComponent();
		tableComponent.setOnDeleteClue((text, identifier) -> {
			listService.removeFromBad(identifier);
			listService.saveLists();
		});
		add(tableComponent, BorderLayout.CENTER);
		
		JPanel buttonPanel = new JPanel(new FlowLayout(FlowLayout.LEFT));
		buttonPanel.setBackground(new Color(26, 26, 26));
		
		JButton exportButton = new JButton("Export");
		exportButton.setBackground(new Color(60, 60, 60));
		exportButton.setForeground(Color.WHITE);
		exportButton.setFocusPainted(false);
		exportButton.addActionListener(e -> exportList());
		buttonPanel.add(exportButton);
		
		JButton importButton = new JButton("Import");
		importButton.setBackground(new Color(60, 60, 60));
		importButton.setForeground(Color.WHITE);
		importButton.setFocusPainted(false);
		importButton.addActionListener(e -> importList());
		buttonPanel.add(importButton);
		
		JButton clearButton = new JButton("Clear All");
		clearButton.setBackground(new Color(100, 0, 0));
		clearButton.setForeground(Color.WHITE);
		clearButton.setFocusPainted(false);
		clearButton.addActionListener(e -> clearList());
		buttonPanel.add(clearButton);
		
		add(buttonPanel, BorderLayout.SOUTH);
	}
	
	public void setOnBackClick(Runnable onBackClick)
	{
		this.onBackClick = onBackClick;
	}
	
	public void refresh()
	{
		tableComponent.clear();
		for (java.util.Map.Entry<String, String> entry : listService.getBadClueIdentifiers().entrySet())
		{
			tableComponent.addRow(entry.getValue(), entry.getKey());
		}
	}
	
	private void exportList()
	{
		JFileChooser fileChooser = new JFileChooser();
		fileChooser.setDialogTitle("Export Bad Steps");
		fileChooser.setFileFilter(new FileNameExtensionFilter("JSON Files", "json"));
		
		if (fileChooser.showSaveDialog(this) == JFileChooser.APPROVE_OPTION)
		{
			File file = fileChooser.getSelectedFile();
			if (!file.getName().endsWith(".json"))
			{
				file = new File(file.getAbsolutePath() + ".json");
			}
			listService.exportToFile(file);
			JOptionPane.showMessageDialog(this, "Export successful!", "Success", JOptionPane.INFORMATION_MESSAGE);
		}
	}
	
	private void importList()
	{
		JFileChooser fileChooser = new JFileChooser();
		fileChooser.setDialogTitle("Import Bad Steps");
		fileChooser.setFileFilter(new FileNameExtensionFilter("JSON Files", "json"));
		
		if (fileChooser.showOpenDialog(this) == JFileChooser.APPROVE_OPTION)
		{
			File file = fileChooser.getSelectedFile();
			listService.importFromFile(file);
			refresh();
			JOptionPane.showMessageDialog(this, "Import successful!", "Success", JOptionPane.INFORMATION_MESSAGE);
		}
	}
	
	private void clearList()
	{
		int result = JOptionPane.showConfirmDialog(this, "Are you sure you want to clear all bad steps?", "Confirm Clear", JOptionPane.YES_NO_OPTION);
		if (result == JOptionPane.YES_OPTION)
		{
			listService.clearBadSteps();
			tableComponent.clear();
		}
	}
}


package com.cluejuggler.ui.view;

import com.cluejuggler.model.ClueList;
import com.cluejuggler.service.ClueListService;
import com.cluejuggler.ui.component.ClueTableComponent;
import java.awt.BorderLayout;
import java.awt.Color;
import java.awt.FlowLayout;
import java.awt.Font;
import java.awt.image.BufferedImage;
import javax.swing.BoxLayout;
import javax.swing.ImageIcon;
import javax.swing.JButton;
import javax.swing.JCheckBox;
import javax.swing.JLabel;
import javax.swing.JOptionPane;
import javax.swing.JPanel;
import javax.swing.border.EmptyBorder;
import net.runelite.client.util.ImageUtil;

public class CustomListView extends JPanel
{
	private final ClueTableComponent tableComponent;
	private final ClueListService listService;
	private final JLabel titleLabel;
	private final JCheckBox deprioritizeCheckbox;
	private ClueList currentList;
	private Runnable onBackClick;
	
	public CustomListView(ClueListService listService)
	{
		this.listService = listService;
		setLayout(new BorderLayout());
		setBorder(new EmptyBorder(5, 0, 5, 0));
		setBackground(new Color(26, 26, 26));
		
		JPanel topPanel = new JPanel();
		topPanel.setLayout(new BoxLayout(topPanel, BoxLayout.Y_AXIS));
		topPanel.setBackground(new Color(26, 26, 26));
		
		JPanel headerPanel = new JPanel(new BorderLayout());
		headerPanel.setBorder(new EmptyBorder(0, 0, 10, 0));
		headerPanel.setBackground(new Color(26, 26, 26));
		
		JPanel leftPanel = new JPanel(new BorderLayout());
		leftPanel.setBackground(new Color(26, 26, 26));
		
		try
		{
			BufferedImage iconImage = ImageUtil.loadImageResource(getClass(), "/cluejuggler.png");
			if (iconImage != null)
			{
				ImageIcon icon = new ImageIcon(iconImage.getScaledInstance(32, 32, java.awt.Image.SCALE_SMOOTH));
				JLabel iconLabel = new JLabel(icon);
				iconLabel.setBorder(new EmptyBorder(0, 0, 0, 10));
				leftPanel.add(iconLabel, BorderLayout.WEST);
			}
		}
		catch (Exception e)
		{
		}
		
		titleLabel = new JLabel("Custom List");
		titleLabel.setFont(new Font(titleLabel.getFont().getName(), Font.BOLD, 18));
		titleLabel.setForeground(Color.WHITE);
		leftPanel.add(titleLabel, BorderLayout.CENTER);
		
		headerPanel.add(leftPanel, BorderLayout.CENTER);
		
		JButton backButton = new JButton(" Back");
		backButton.setBackground(new Color(60, 60, 60));
		backButton.setForeground(Color.WHITE);
		backButton.setFocusPainted(false);
		backButton.addActionListener(e -> {
			if (onBackClick != null)
			{
				onBackClick.run();
			}
		});
		headerPanel.add(backButton, BorderLayout.EAST);
		
		topPanel.add(headerPanel);
		
		JPanel optionsPanel = new JPanel(new FlowLayout(FlowLayout.LEFT, 0, 0));
		optionsPanel.setBackground(new Color(26, 26, 26));
		optionsPanel.setBorder(new EmptyBorder(0, 0, 10, 0));
		
		deprioritizeCheckbox = new JCheckBox("Deprioritize (treat as bad)");
		deprioritizeCheckbox.setBackground(new Color(26, 26, 26));
		deprioritizeCheckbox.setForeground(Color.WHITE);
		deprioritizeCheckbox.setFocusPainted(false);
		deprioritizeCheckbox.addActionListener(e -> {
			if (currentList != null)
			{
				currentList.setDeprioritize(deprioritizeCheckbox.isSelected());
				listService.saveCustomLists();
			}
		});
		optionsPanel.add(deprioritizeCheckbox);
		
		topPanel.add(optionsPanel);
		
		add(topPanel, BorderLayout.NORTH);
		
		tableComponent = new ClueTableComponent();
		tableComponent.setOnDeleteClue((text, identifier) -> {
			if (currentList != null)
			{
				currentList.getClueIdentifiers().remove(identifier);
				currentList.getClues().remove(text);
				listService.saveCustomLists();
			}
		});
		add(tableComponent, BorderLayout.CENTER);
		
		JPanel buttonPanel = new JPanel(new FlowLayout(FlowLayout.LEFT));
		buttonPanel.setBackground(new Color(26, 26, 26));
		
		JButton clearButton = new JButton("Clear All");
		clearButton.setBackground(new Color(100, 0, 0));
		clearButton.setForeground(Color.WHITE);
		clearButton.setFocusPainted(false);
		clearButton.addActionListener(e -> clearList());
		buttonPanel.add(clearButton);
		
		JButton deleteListButton = new JButton("Delete List");
		deleteListButton.setBackground(new Color(100, 0, 0));
		deleteListButton.setForeground(Color.WHITE);
		deleteListButton.setFocusPainted(false);
		deleteListButton.addActionListener(e -> deleteList());
		buttonPanel.add(deleteListButton);
		
		add(buttonPanel, BorderLayout.SOUTH);
	}
	
	public void setOnBackClick(Runnable onBackClick)
	{
		this.onBackClick = onBackClick;
	}
	
	public void setList(ClueList list)
	{
		this.currentList = list;
		if (list != null)
		{
			titleLabel.setText(list.getName());
			titleLabel.setForeground(list.getTextColor());
			deprioritizeCheckbox.setSelected(list.isDeprioritize());
			refresh();
		}
	}
	
	public void refresh()
	{
		tableComponent.clear();
		if (currentList != null)
		{
			for (java.util.Map.Entry<String, String> entry : currentList.getClueIdentifiers().entrySet())
			{
				tableComponent.addRow(entry.getValue(), entry.getKey());
			}
		}
	}
	
	private void clearList()
	{
		if (currentList == null)
		{
			return;
		}
		
		int result = JOptionPane.showConfirmDialog(this, "Are you sure you want to clear all clues from " + currentList.getName() + "?", "Confirm Clear", JOptionPane.YES_NO_OPTION);
		if (result == JOptionPane.YES_OPTION)
		{
			currentList.getClueIdentifiers().clear();
			currentList.getClues().clear();
			listService.saveCustomLists();
			tableComponent.clear();
		}
	}
	
	private void deleteList()
	{
		if (currentList == null)
		{
			return;
		}
		
		int result = JOptionPane.showConfirmDialog(this, "Are you sure you want to delete the list '" + currentList.getName() + "'?", "Confirm Delete", JOptionPane.YES_NO_OPTION);
		if (result == JOptionPane.YES_OPTION)
		{
			listService.deleteCustomList(currentList);
			if (onBackClick != null)
			{
				onBackClick.run();
			}
		}
	}
	
	public ClueList getCurrentList()
	{
		return currentList;
	}
}


package com.cluejuggler.ui.view;

import com.cluejuggler.service.ClueListService;
import com.cluejuggler.ui.component.ClueTableComponent;
import java.awt.BorderLayout;
import java.awt.Color;
import java.awt.FlowLayout;
import java.awt.Font;
import java.awt.image.BufferedImage;
import java.io.File;
import javax.swing.ImageIcon;
import javax.swing.JButton;
import javax.swing.JFileChooser;
import javax.swing.JLabel;
import javax.swing.JOptionPane;
import javax.swing.JPanel;
import javax.swing.border.EmptyBorder;
import javax.swing.filechooser.FileNameExtensionFilter;
import net.runelite.client.util.ImageUtil;

public class GoodListView extends JPanel
{
	private final ClueTableComponent tableComponent;
	private final ClueListService listService;
	private Runnable onBackClick;
	
	public GoodListView(ClueListService listService)
	{
		this.listService = listService;
		setLayout(new BorderLayout());
		setBorder(new EmptyBorder(5, 0, 5, 0));
		setBackground(new Color(26, 26, 26));
		
		JPanel headerPanel = new JPanel(new BorderLayout());
		headerPanel.setBorder(new EmptyBorder(0, 0, 10, 0));
		headerPanel.setBackground(new Color(26, 26, 26));
		
		JPanel leftPanel = new JPanel(new BorderLayout());
		leftPanel.setBackground(new Color(26, 26, 26));
		
		try
		{
			BufferedImage iconImage = ImageUtil.loadImageResource(getClass(), "/cluejuggler.png");
			if (iconImage != null)
			{
				ImageIcon icon = new ImageIcon(iconImage.getScaledInstance(32, 32, java.awt.Image.SCALE_SMOOTH));
				JLabel iconLabel = new JLabel(icon);
				iconLabel.setBorder(new EmptyBorder(0, 0, 0, 10));
				leftPanel.add(iconLabel, BorderLayout.WEST);
			}
		}
		catch (Exception e)
		{
		}
		
		JLabel titleLabel = new JLabel("Good Steps");
		titleLabel.setFont(new Font(titleLabel.getFont().getName(), Font.BOLD, 18));
		titleLabel.setForeground(new Color(0, 150, 0));
		leftPanel.add(titleLabel, BorderLayout.CENTER);
		
		headerPanel.add(leftPanel, BorderLayout.CENTER);
		
		JButton backButton = new JButton(" Back");
		backButton.setBackground(new Color(60, 60, 60));
		backButton.setForeground(Color.WHITE);
		backButton.setFocusPainted(false);
		backButton.addActionListener(e -> {
			if (onBackClick != null)
			{
				onBackClick.run();
			}
		});
		headerPanel.add(backButton, BorderLayout.EAST);
		
		add(headerPanel, BorderLayout.NORTH);
		
		tableComponent = new ClueTableComponent();
		tableComponent.setOnDeleteClue((text, identifier) -> {
			listService.removeFromGood(identifier);
			listService.saveLists();
		});
		add(tableComponent, BorderLayout.CENTER);
		
		JPanel buttonPanel = new JPanel(new FlowLayout(FlowLayout.LEFT));
		buttonPanel.setBackground(new Color(26, 26, 26));
		
		JButton exportButton = new JButton("Export");
		exportButton.setBackground(new Color(60, 60, 60));
		exportButton.setForeground(Color.WHITE);
		exportButton.setFocusPainted(false);
		exportButton.addActionListener(e -> exportList());
		buttonPanel.add(exportButton);
		
		JButton importButton = new JButton("Import");
		importButton.setBackground(new Color(60, 60, 60));
		importButton.setForeground(Color.WHITE);
		importButton.setFocusPainted(false);
		importButton.addActionListener(e -> importList());
		buttonPanel.add(importButton);
		
		JButton clearButton = new JButton("Clear All");
		clearButton.setBackground(new Color(100, 0, 0));
		clearButton.setForeground(Color.WHITE);
		clearButton.setFocusPainted(false);
		clearButton.addActionListener(e -> clearList());
		buttonPanel.add(clearButton);
		
		add(buttonPanel, BorderLayout.SOUTH);
	}
	
	public void setOnBackClick(Runnable onBackClick)
	{
		this.onBackClick = onBackClick;
	}
	
	public void refresh()
	{
		tableComponent.clear();
		for (java.util.Map.Entry<String, String> entry : listService.getGoodClueIdentifiers().entrySet())
		{
			tableComponent.addRow(entry.getValue(), entry.getKey());
		}
	}
	
	private void exportList()
	{
		JFileChooser fileChooser = new JFileChooser();
		fileChooser.setDialogTitle("Export Good Steps");
		fileChooser.setFileFilter(new FileNameExtensionFilter("JSON Files", "json"));
		
		if (fileChooser.showSaveDialog(this) == JFileChooser.APPROVE_OPTION)
		{
			File file = fileChooser.getSelectedFile();
			if (!file.getName().endsWith(".json"))
			{
				file = new File(file.getAbsolutePath() + ".json");
			}
			listService.exportToFile(file);
			JOptionPane.showMessageDialog(this, "Export successful!", "Success", JOptionPane.INFORMATION_MESSAGE);
		}
	}
	
	private void importList()
	{
		JFileChooser fileChooser = new JFileChooser();
		fileChooser.setDialogTitle("Import Good Steps");
		fileChooser.setFileFilter(new FileNameExtensionFilter("JSON Files", "json"));
		
		if (fileChooser.showOpenDialog(this) == JFileChooser.APPROVE_OPTION)
		{
			File file = fileChooser.getSelectedFile();
			listService.importFromFile(file);
			refresh();
			JOptionPane.showMessageDialog(this, "Import successful!", "Success", JOptionPane.INFORMATION_MESSAGE);
		}
	}
	
	private void clearList()
	{
		int result = JOptionPane.showConfirmDialog(this, "Are you sure you want to clear all good steps?", "Confirm Clear", JOptionPane.YES_NO_OPTION);
		if (result == JOptionPane.YES_OPTION)
		{
			listService.clearGoodSteps();
			tableComponent.clear();
		}
	}
}


package com.cluejuggler.ui.view;

import com.cluejuggler.model.ClueList;
import com.cluejuggler.service.ClueListService;
import com.cluejuggler.ui.component.ColorPickerRow;
import java.awt.BorderLayout;
import java.awt.Color;
import java.awt.Dimension;
import java.awt.Font;
import java.awt.image.BufferedImage;
import java.util.List;
import javax.swing.Box;
import javax.swing.BoxLayout;
import javax.swing.ImageIcon;
import javax.swing.JButton;
import javax.swing.JCheckBox;
import javax.swing.JLabel;
import javax.swing.JPanel;
import javax.swing.JScrollPane;
import javax.swing.border.EmptyBorder;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.util.ImageUtil;

public class SettingsView extends JPanel
{
	private final ClueListService listService;
	private final ConfigManager configManager;
	private final JPanel contentPanel;
	private Runnable onBackClick;
	
	public SettingsView(ClueListService listService, ConfigManager configManager)
	{
		this.listService = listService;
		this.configManager = configManager;
		
		setLayout(new BorderLayout());
		setBorder(new EmptyBorder(5, 0, 5, 0));
		setBackground(new Color(26, 26, 26));
		
		JPanel headerPanel = new JPanel(new BorderLayout());
		headerPanel.setBorder(new EmptyBorder(0, 0, 10, 0));
		headerPanel.setBackground(new Color(26, 26, 26));
		
		JPanel leftPanel = new JPanel(new BorderLayout());
		leftPanel.setBackground(new Color(26, 26, 26));
		
		try
		{
			BufferedImage iconImage = ImageUtil.loadImageResource(getClass(), "/cluejuggler.png");
			if (iconImage != null)
			{
				ImageIcon icon = new ImageIcon(iconImage.getScaledInstance(32, 32, java.awt.Image.SCALE_SMOOTH));
				JLabel iconLabel = new JLabel(icon);
				iconLabel.setBorder(new EmptyBorder(0, 0, 0, 10));
				leftPanel.add(iconLabel, BorderLayout.WEST);
			}
		}
		catch (Exception e)
		{
		}
		
		JLabel titleLabel = new JLabel("Settings");
		titleLabel.setFont(new Font(titleLabel.getFont().getName(), Font.BOLD, 18));
		titleLabel.setForeground(Color.WHITE);
		leftPanel.add(titleLabel, BorderLayout.CENTER);
		
		headerPanel.add(leftPanel, BorderLayout.CENTER);
		
		JButton backButton = new JButton(" Back");
		backButton.setBackground(new Color(60, 60, 60));
		backButton.setForeground(Color.WHITE);
		backButton.setFocusPainted(false);
		backButton.addActionListener(e -> {
			if (onBackClick != null)
			{
				onBackClick.run();
			}
		});
		headerPanel.add(backButton, BorderLayout.EAST);
		
		add(headerPanel, BorderLayout.NORTH);
		
		contentPanel = new JPanel();
		contentPanel.setLayout(new BoxLayout(contentPanel, BoxLayout.Y_AXIS));
		contentPanel.setBackground(new Color(26, 26, 26));
		
		JScrollPane scrollPane = new JScrollPane(contentPanel);
		scrollPane.setBackground(new Color(26, 26, 26));
		scrollPane.getViewport().setBackground(new Color(26, 26, 26));
		scrollPane.setBorder(null);
		add(scrollPane, BorderLayout.CENTER);
	}
	
	public void setOnBackClick(Runnable onBackClick)
	{
		this.onBackClick = onBackClick;
	}
	
	public void refresh()
	{
		contentPanel.removeAll();
		
		JLabel generalLabel = new JLabel("General");
		generalLabel.setFont(new Font(generalLabel.getFont().getName(), Font.BOLD, 14));
		generalLabel.setForeground(Color.WHITE);
		generalLabel.setBorder(new EmptyBorder(0, 0, 10, 0));
		contentPanel.add(generalLabel);
		
		JCheckBox showIndicatorCheck = new JCheckBox("Show Clue Indicator");
		showIndicatorCheck.setBackground(new Color(26, 26, 26));
		showIndicatorCheck.setForeground(Color.WHITE);
		showIndicatorCheck.setSelected(getBooleanConfig("showIndicator", true));
		showIndicatorCheck.addActionListener(e -> 
			configManager.setConfiguration("cluejuggler", "showIndicator", showIndicatorCheck.isSelected()));
		contentPanel.add(showIndicatorCheck);
		
		JCheckBox deprioritizeCheck = new JCheckBox("Deprioritize Bad Clues");
		deprioritizeCheck.setBackground(new Color(26, 26, 26));
		deprioritizeCheck.setForeground(Color.WHITE);
		deprioritizeCheck.setSelected(getBooleanConfig("deprioritizeBadClues", true));
		deprioritizeCheck.addActionListener(e -> 
			configManager.setConfiguration("cluejuggler", "deprioritizeBadClues", deprioritizeCheck.isSelected()));
		contentPanel.add(deprioritizeCheck);
		
		contentPanel.add(Box.createVerticalStrut(20));
		
		JLabel highlighterLabel = new JLabel("Clue Highlighter");
		highlighterLabel.setFont(new Font(highlighterLabel.getFont().getName(), Font.BOLD, 14));
		highlighterLabel.setForeground(Color.WHITE);
		highlighterLabel.setBorder(new EmptyBorder(0, 0, 10, 0));
		contentPanel.add(highlighterLabel);
		
		JCheckBox enableHighlightsCheck = new JCheckBox("Enable Clue Highlights");
		enableHighlightsCheck.setBackground(new Color(26, 26, 26));
		enableHighlightsCheck.setForeground(Color.WHITE);
		enableHighlightsCheck.setSelected(getBooleanConfig("clueHighlights", true));
		enableHighlightsCheck.addActionListener(e -> 
			configManager.setConfiguration("cluejuggler", "clueHighlights", enableHighlightsCheck.isSelected()));
		contentPanel.add(enableHighlightsCheck);
		
		contentPanel.add(Box.createVerticalStrut(10));
		
		ColorPickerRow goodTileColor = new ColorPickerRow("Good Tile Color", "Color for good clue tiles", 
			getColorConfig("goodClueTileColor", new Color(0, 255, 0, 100)),
			color -> setColorConfig("goodClueTileColor", color));
		contentPanel.add(goodTileColor);
		
		ColorPickerRow badTileColor = new ColorPickerRow("Bad Tile Color", "Color for bad clue tiles", 
			getColorConfig("badClueTileColor", new Color(255, 0, 0, 100)),
			color -> setColorConfig("badClueTileColor", color));
		contentPanel.add(badTileColor);
		
		ColorPickerRow unsureTileColor = new ColorPickerRow("Unsure Tile Color", "Color for unsure clue tiles", 
			getColorConfig("unsureClueTileColor", new Color(255, 255, 0, 100)),
			color -> setColorConfig("unsureClueTileColor", color));
		contentPanel.add(unsureTileColor);
		
		contentPanel.add(Box.createVerticalStrut(10));
		
		ColorPickerRow goodTextColor = new ColorPickerRow("Good Text Color", "Color for good clue text", 
			getColorConfig("goodClueTextColor", Color.GREEN),
			color -> setColorConfig("goodClueTextColor", color));
		contentPanel.add(goodTextColor);
		
		ColorPickerRow badTextColor = new ColorPickerRow("Bad Text Color", "Color for bad clue text", 
			getColorConfig("badClueTextColor", Color.RED),
			color -> setColorConfig("badClueTextColor", color));
		contentPanel.add(badTextColor);
		
		ColorPickerRow unsureTextColor = new ColorPickerRow("Unsure Text Color", "Color for unsure clue text", 
			getColorConfig("unsureClueTextColor", Color.YELLOW),
			color -> setColorConfig("unsureClueTextColor", color));
		contentPanel.add(unsureTextColor);
		
		List<ClueList> customLists = listService.getCustomLists();
		if (!customLists.isEmpty())
		{
			contentPanel.add(Box.createVerticalStrut(20));
			
			JLabel customListsLabel = new JLabel("Custom Lists");
			customListsLabel.setFont(new Font(customListsLabel.getFont().getName(), Font.BOLD, 14));
			customListsLabel.setForeground(Color.WHITE);
			customListsLabel.setBorder(new EmptyBorder(0, 0, 10, 0));
			contentPanel.add(customListsLabel);
			
			for (ClueList list : customLists)
			{
				JLabel listNameLabel = new JLabel(list.getName());
				listNameLabel.setForeground(list.getTextColor());
				listNameLabel.setBorder(new EmptyBorder(5, 0, 5, 0));
				contentPanel.add(listNameLabel);
				
				ColorPickerRow listTileColor = new ColorPickerRow("Tile Color", "Tile color for " + list.getName(), 
					list.getTileColor(),
					color -> {
						list.setTileColor(color);
						listService.saveCustomLists();
					});
				contentPanel.add(listTileColor);
				
				ColorPickerRow listTextColor = new ColorPickerRow("Text Color", "Text color for " + list.getName(), 
					list.getTextColor(),
					color -> {
						list.setTextColor(color);
						list.setOverlayTextColor(color);
						listService.saveCustomLists();
					});
				contentPanel.add(listTextColor);
			}
		}
		
		contentPanel.revalidate();
		contentPanel.repaint();
	}
	
	private boolean getBooleanConfig(String key, boolean defaultValue)
	{
		String value = configManager.getConfiguration("cluejuggler", key);
		if (value == null)
		{
			return defaultValue;
		}
		return Boolean.parseBoolean(value);
	}
	
	private Color getColorConfig(String key, Color defaultValue)
	{
		String value = configManager.getConfiguration("cluejuggler", key);
		if (value == null)
		{
			return defaultValue;
		}
		try
		{
			return Color.decode(value);
		}
		catch (Exception e)
		{
			return defaultValue;
		}
	}
	
	private void setColorConfig(String key, Color color)
	{
		String value = String.format("#%02x%02x%02x", color.getRed(), color.getGreen(), color.getBlue());
		configManager.setConfiguration("cluejuggler", key, value);
	}
}


package com.cluejuggler;

import net.runelite.client.RuneLite;
import net.runelite.client.externalplugins.ExternalPluginManager;

public class ClueJugglerPluginTest
{
	public static void main(String[] args) throws Exception
	{
		ExternalPluginManager.loadBuiltin(ClueJugglerPlugin.class);
		RuneLite.main(args);
	}
}


