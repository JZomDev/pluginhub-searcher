package com.itemlocker;

import net.runelite.client.config.Config;
import net.runelite.client.config.ConfigGroup;
import net.runelite.client.config.ConfigItem;

@ConfigGroup("itemlocker")
public interface ItemLockerConfig extends Config
{
    @ConfigItem(
        keyName = "unlockedItems",
        name = "Unlocked Items",
        description = "Stores all unlocked items as a CSV"
    )
    default String unlockedItems()
    {
        return "";
    }
}

package com.itemlocker;

import com.google.common.cache.Cache;
import com.google.common.cache.CacheBuilder;
import java.awt.Color;
import java.awt.Graphics2D;
import java.awt.Image;
import java.awt.Rectangle;
import javax.inject.Inject;

import net.runelite.api.gameval.InterfaceID;
import net.runelite.api.widgets.WidgetItem;
import net.runelite.client.game.ItemManager;
import net.runelite.client.ui.overlay.WidgetItemOverlay;
import net.runelite.client.util.ColorUtil;
import net.runelite.client.util.ImageUtil;

class ItemLockerOverlay extends WidgetItemOverlay
{
	private final ItemManager itemManager;
	private final ItemLockerPlugin plugin;
	private final Cache<Long, Image> fillCache;
    private final Cache<Integer, Boolean> unlockCache;

	@Inject
	private ItemLockerOverlay(ItemManager itemManager, ItemLockerPlugin plugin, ItemLockerConfig config)
	{
		this.itemManager = itemManager;
		this.plugin = plugin;
		showOnEquipment();
		showOnInventory();
		showOnInterfaces(
			InterfaceID.BANKMAIN,
			InterfaceID.RAIDS_STORAGE_SIDE,
			InterfaceID.RAIDS_STORAGE_SHARED,
			InterfaceID.RAIDS_STORAGE_PRIVATE,
			InterfaceID.GRAVESTONE_RETRIEVAL,
			InterfaceID.GRAVESTONE_GENERIC,
			InterfaceID.BANK_DEPOSITBOX
		);
		fillCache = CacheBuilder.newBuilder()
			.concurrencyLevel(1)
			.maximumSize(32)
			.build();
        unlockCache = CacheBuilder.newBuilder()
            .concurrencyLevel(1)
            .maximumSize(39)
            .build();
	}

	@Override
	public void renderItemOverlay(Graphics2D graphics, int itemId, WidgetItem widgetItem)
	{
        final boolean unlocked = getUnlocked(itemId);
        if (unlocked) {
            return;
        }

		final Color color = Color.RED;

		Rectangle bounds = widgetItem.getCanvasBounds();

        final Image image = getFillImage(color, widgetItem.getId(), widgetItem.getQuantity());
        graphics.drawImage(image, (int) bounds.getX(), (int) bounds.getY(), null);
	}

    private boolean getUnlocked(int itemId)
    {
        Boolean unlocked = unlockCache.getIfPresent(itemId);
        if (unlocked == null) {
            unlocked = plugin.getUnlocked(itemId);
            unlockCache.put(itemId, unlocked);
        }
        return unlocked;
    }

	private Image getFillImage(Color color, int itemId, int qty)
	{
		long key = (((long) itemId) << 32) | qty;
		Image image = fillCache.getIfPresent(key);
		if (image == null)
		{
			final Color fillColor = ColorUtil.colorWithAlpha(color, 64);
			image = ImageUtil.fillImage(itemManager.getImage(itemId, qty, false), fillColor);
			fillCache.put(key, image);
		}
		return image;
	}

	void invalidateCache()
	{
		fillCache.invalidateAll();
        unlockCache.invalidateAll();
	}
}
package com.itemlocker;

import com.google.inject.Provides;

import java.util.Arrays;
import java.util.HashSet;
import java.util.Objects;
import java.util.Set;
import java.util.stream.Collectors;

import javax.inject.Inject;

import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.KeyCode;
import net.runelite.api.Menu;
import net.runelite.api.MenuAction;
import net.runelite.api.MenuEntry;
import net.runelite.api.events.MenuOpened;
import net.runelite.api.events.PostMenuSort;
import net.runelite.api.gameval.InterfaceID;
import net.runelite.api.widgets.Widget;
import net.runelite.api.widgets.WidgetUtil;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.events.ConfigChanged;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.plugins.PluginDescriptor;
import net.runelite.client.ui.overlay.OverlayManager;
import net.runelite.client.util.Text;

@Slf4j
@PluginDescriptor(
	name = "Item Locker"
)
public class ItemLockerPlugin extends Plugin
{
	@Inject
	private Client client;

	@Inject
	private ConfigManager configManager;

	@Inject
	private ItemLockerOverlay overlay;

	@Inject
	private OverlayManager overlayManager;

	private Set<Integer> unlockedItems = new HashSet<>();

	@Provides
	ItemLockerConfig provideConfig(ConfigManager configManager)
	{
		return configManager.getConfig(ItemLockerConfig.class);
	}

	@Override
	protected void startUp() throws Exception
	{
		String csv = configManager.getConfiguration("itemlocker", "unlockedItems");
		if (csv != null && !csv.isEmpty()) {
			this.unlockedItems = Arrays.stream(csv.split(","))
			.map(String::trim)
			.filter(s -> !s.isEmpty())
			.map(s -> {
				try {
					return Integer.parseInt(s);
				} catch (NumberFormatException e) {
					return null;
				}
			})
			.filter(Objects::nonNull)
			.collect(Collectors.toSet());
		}
		overlayManager.add(overlay);
	}

	@Override
	protected void shutDown() throws Exception
	{
		overlayManager.remove(overlay);
	}

	boolean getUnlocked(int itemId)
	{
		return this.unlockedItems.contains(itemId);
	}

	private void saveUnlockedItems() {
		configManager.setConfiguration
		("itemlocker",
		"unlockedItems",
		this.unlockedItems.stream()
			.map(String::valueOf)
			.collect(Collectors.joining(","))
		);
	}

	void setUnlocked(int itemId)
	{
		this.unlockedItems.add(itemId);
		this.saveUnlockedItems();
	}

	void setLocked(int itemId)
	{
		this.unlockedItems.remove(itemId);
		this.saveUnlockedItems();
	}

	@Subscribe
	public void onConfigChanged(ConfigChanged configChanged)
	{
		if (configChanged.getGroup().equals("itemlocker"))
		{
			overlay.invalidateCache();
		}
	}

	@Subscribe
	public void onMenuOpened(final MenuOpened event)
	{
		if (!client.isKeyPressed(KeyCode.KC_SHIFT))
		{
			return;
		}

		final MenuEntry[] entries = event.getMenuEntries();
		for (int idx = entries.length - 1; idx >= 0; --idx)
		{
			final MenuEntry entry = entries[idx];
			final Widget w = entry.getWidget();

			if (w != null && WidgetUtil.componentToInterface(w.getId()) == InterfaceID.INVENTORY
				&& "Examine".equals(entry.getOption()) && entry.getIdentifier() == 10)
			{
				final int itemId = w.getItemId();
				final boolean unlocked = getUnlocked(itemId);

				client.getMenu().createMenuEntry(idx)
					.setOption(unlocked ? "Lock" : "Unlock")
					.setTarget(entry.getTarget())
					.setType(MenuAction.RUNELITE)
					.onClick(e ->
					{
						if (unlocked) {
							setLocked(itemId);
						} else {
							setUnlocked(itemId);
						}
					});
			}
		}
	}

	@Subscribe
	public void onPostMenuSort(PostMenuSort postMenuSort)
	{
		if (client.isMenuOpen())
		{
			return;
		}
		Menu root = client.getMenu();
		MenuEntry[] menuEntries = root.getMenuEntries();
		
		if (menuEntries.length == 0) {
			return;
		}

		MenuEntry leftClickEntry = menuEntries[menuEntries.length - 1];

		if (getUnlocked(leftClickEntry.getItemId())) {
			return;
		}

		Widget w = leftClickEntry.getWidget();

		if (w == null || WidgetUtil.componentToInterface(w.getId()) != InterfaceID.INVENTORY) {
			return;
		}
		
		MenuEntry newLeftClickEntry = root.createMenuEntry(-1);

		newLeftClickEntry.setOption("Locked");
		newLeftClickEntry.setType(MenuAction.CANCEL);
	}
}

package com.itemlocker;

import net.runelite.client.RuneLite;
import net.runelite.client.externalplugins.ExternalPluginManager;

public class ItemLockerPluginTest
{
	public static void main(String[] args) throws Exception
	{
		ExternalPluginManager.loadBuiltin(ItemLockerPlugin.class);
		RuneLite.main(args);
	}
}
