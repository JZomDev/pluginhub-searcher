package com.choicer.chanceman.drops;

import lombok.Getter;
import lombok.Setter;

import java.util.Arrays;
import java.util.Locale;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.stream.Collectors;

@Setter
@Getter
public class DropItem
{
    private int itemId;
    private String name;
    private String rarity;

    // Anchored patterns for correctness & speed
    private static final Pattern PCT       = Pattern.compile("^(\\d+(?:\\.\\d+)?)%$");
    private static final Pattern MULT      = Pattern.compile("^(\\d+(?:\\.\\d+)?)\\s*[xX]\\s*(\\d+(?:\\.\\d+)?)\\s*/\\s*(\\d+(?:\\.\\d+)?)$");
    private static final Pattern FRAC      = Pattern.compile("^(\\d+(?:\\.\\d+)?)\\s*/\\s*(\\d+(?:\\.\\d+)?)$");
    private static final Pattern PAREN     = Pattern.compile("\\s*\\([^)]*\\)$", Pattern.UNICODE_CASE);
    private static final Pattern IN_SYNT   = Pattern.compile("\\bin\\b", Pattern.CASE_INSENSITIVE);
    private static final Pattern BRACKETS  = Pattern.compile("\\[[^\\]]*\\]");
    private static final Pattern ONE_OVER  = Pattern.compile("1/(\\d+(?:\\.\\d+)?)");

    public DropItem(int itemId, String name, String rarity)
    {
        this.itemId = itemId;
        this.name = name;
        this.rarity = rarity;
    }

    /** Convert raw rarity to normalized one-over form (preserves ranges like “1/64–1/32”). */
    public String getOneOverRarity()
    {
        if (rarity == null) return "";
        String[] parts = rarity.split("\\s*;\\s*|,\\s+");
        return Arrays.stream(parts)
                .map(this::normalizeSegment)
                .collect(Collectors.joining("; "));
    }

    /**
     * Parse rarity and return the denominator (e.g., “1/128” -> 128).
     * Unknown values sort as rarest (POSITIVE_INFINITY). “Always” -> 0.
     */
    public double getRarityValue()
    {
        String oneOver = getOneOverRarity();
        if (oneOver.isEmpty())
        {
            return Double.POSITIVE_INFINITY;
        }

        Matcher m = ONE_OVER.matcher(oneOver);
        if (m.find())
        {
            try { return Double.parseDouble(m.group(1)); }
            catch (NumberFormatException ignored) { return Double.POSITIVE_INFINITY; }
        }

        if (oneOver.equalsIgnoreCase("Always"))
        {
            return 0d;
        }

        return Double.POSITIVE_INFINITY;
    }

    private String normalizeSegment(String raw)
    {
        String cleaned = raw == null ? "" : raw;
        cleaned = BRACKETS.matcher(cleaned).replaceAll("");
        cleaned = cleaned
                .replace("×", "x")
                .replace(",", "")
                .replace("≈", "")
                .replace("~", "")
                .replaceAll(PAREN.pattern(), "")
                .replaceAll(IN_SYNT.pattern(), "/")
                .trim();

        // Handle ranges like "1/128 – 1/64"
        String[] range = cleaned.split("\\s*[–—-]\\s*");
        if (range.length > 1)
        {
            return Arrays.stream(range)
                    .map(this::simplifySingle)
                    .collect(Collectors.joining("–"));
        }

        return simplifySingle(cleaned);
    }

    private String simplifySingle(String s)
    {
        if (s == null || s.isEmpty())
        {
            return "";
        }

        Matcher m;

        // 12.5%
        m = PCT.matcher(s);
        if (m.matches())
        {
            double pct = safeDouble(m.group(1));
            if (pct == 0) return "0";
            return formatOneOver(100.0 / pct);
        }

        // 2 x 1 / 128
        m = MULT.matcher(s);
        if (m.matches())
        {
            double factor = safeDouble(m.group(1));
            double a = safeDouble(m.group(2));
            double b = safeDouble(m.group(3));
            if (factor != 0 && a != 0)
            {
                return formatOneOver(b / (a * factor));
            }
        }

        // 1/128
        m = FRAC.matcher(s);
        if (m.matches())
        {
            double a = safeDouble(m.group(1));
            double b = safeDouble(m.group(2));
            if (a != 0)
            {
                return formatOneOver(b / a);
            }
        }

        // fallback to cleaned input
        return s;
    }

    private double safeDouble(String s)
    {
        try { return Double.parseDouble(s); }
        catch (Exception e) { return Double.NaN; }
    }

    private String formatOneOver(double val)
    {
        if (Double.isNaN(val) || Double.isInfinite(val))
        {
            return "";
        }
        if (Math.abs(val - Math.round(val)) < 0.01)
        {
            return "1/" + Math.round(val);
        }
        return String.format(Locale.ROOT, "1/%.2f", val);
    }
}

package com.choicer.chanceman.drops;

import lombok.Getter;
import lombok.Setter;

import java.util.List;

@Setter
@Getter
public class DropTableSection
{
    private String header;
    private List<DropItem> items;

    public DropTableSection(String header, List<DropItem> items)
    {
        this.header = header;
        this.items = items;
    }

}
package com.choicer.chanceman.drops;

import static net.runelite.client.RuneLite.RUNELITE_DIR;

import com.choicer.chanceman.account.AccountManager;
import com.google.gson.Gson;
import com.google.common.util.concurrent.ThreadFactoryBuilder;
import lombok.extern.slf4j.Slf4j;

import javax.inject.Inject;
import javax.inject.Singleton;
import java.io.IOException;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.StandardCopyOption;
import java.nio.file.StandardOpenOption;
import java.time.Duration;
import java.time.Instant;
import java.util.*;
import java.util.concurrent.*;
import java.util.stream.Collectors;
import java.util.stream.Stream;

/**
 * Persistent drop-table cache backed by JSON files in the user's RuneLite
 * directory. The cache is mirrored in memory to make name-based lookups and
 * searches effectively instantaneous.
 */
@Slf4j
@Singleton
public class DropCache
{
    private final Gson gson;
    private final AccountManager accountManager;
    private final DropFetcher dropFetcher;
    private static final Duration MAX_AGE = Duration.ofDays(7);
    private final Map<Path, Object> writeLocks = new ConcurrentHashMap<>();
    private final Map<Path, NpcDropData> cache = new ConcurrentHashMap<>();
    private final Map<String, Path> nameIndex = new ConcurrentHashMap<>();
    private volatile boolean indexLoaded = false;

    // Dedicated IO executor so we dont block the common ForkJoinPool with file ops
    private ExecutorService ioExecutor;

    @Inject
    public DropCache(Gson gson, AccountManager accountManager, DropFetcher dropFetcher)
    {
        this.gson = gson;
        this.accountManager = accountManager;
        this.dropFetcher = dropFetcher;
    }

    /** Preload on-disk index and prune stale cache entries. */
    public void startUp()
    {
        ensureExecutor();
        String player = accountManager.getPlayerName();
        if (player == null || player.isEmpty()) { return; }
        loadIndex();
        pruneOldCaches();
    }

    /**
     * Load from disk if possible; otherwise fetch from the wiki, write the
     * JSON, and return the data. Results without drop-table sections are
     * discarded and never cached.
     */
    public CompletableFuture<NpcDropData> get(int npcId, String name, int level)
    {
        loadIndex();
        final String safeName = name.replaceAll("[^A-Za-z0-9]", "_");
        final Path file;
        try
        {
            file = npcId == 0
                    ? findExistingCacheFile(safeName, level)
                    : getCacheFile(npcId, name, level);
        }
        catch (IOException ex)
        {
            log.error("Could not resolve cache file for {} ({}, lvl {})", npcId, name, level, ex);
            return CompletableFuture.failedFuture(ex);
        }

        ExecutorService executor = ensureExecutor();
        return CompletableFuture.supplyAsync(() ->
        {
            if (file != null)
            {
                NpcDropData cached = cache.get(file);
                if (cached != null && Files.exists(file) && isFresh(file))
                {
                    return cached;
                }

                // stale or missing entry, clean up
                try
                {
                    Files.deleteIfExists(file);
                }
                catch (IOException ignore) { }
                removeIndex(file);
            }
            return null;
        }, executor).thenComposeAsync(cached ->
        {
            if (cached != null)
            {
                return CompletableFuture.completedFuture(cached);
            }

            return dropFetcher.fetch(npcId, name, level)
                    .thenApplyAsync(data ->
                    {
                        try
                        {
                            if (data == null || data.getDropTableSections().isEmpty())
                            {
                                return null;
                            }

                            Path out = getCacheFile(data.getNpcId(), data.getName(), data.getLevel());
                            Files.createDirectories(out.getParent());
                            String json = gson.toJson(data);

                            Object lock = writeLocks.computeIfAbsent(out, p -> new Object());
                            synchronized (lock)
                            {
                                Path tmp = out.resolveSibling(out.getFileName() + ".tmp");
                                try
                                {
                                    Files.writeString(
                                            tmp,
                                            json,
                                            StandardCharsets.UTF_8,
                                            StandardOpenOption.CREATE,
                                            StandardOpenOption.TRUNCATE_EXISTING
                                    );
                                    Files.move(tmp, out, StandardCopyOption.REPLACE_EXISTING, StandardCopyOption.ATOMIC_MOVE);
                                }
                                finally
                                {
                                    writeLocks.remove(out);
                                    try { Files.deleteIfExists(tmp); } catch (IOException ignored) {}
                                }
                            }

                            cache.put(out, data);
                            nameIndex.put(buildNameKey(data.getName(), data.getLevel()), out);

                            if (npcId == 0 && data.getNpcId() != 0)
                            {
                                // Remove old 0_id placeholder if present
                                Path old = findExistingCacheFile(safeName, data.getLevel());
                                if (old != null && !old.equals(out))
                                {
                                    Files.deleteIfExists(old);
                                    removeIndex(old);
                                }
                            }
                        }
                        catch (Exception e)
                        {
                            log.error("Failed to write cache file for {}", name, e);
                        }
                        return data;
                    }, executor)
                    .exceptionally(ex ->
                    {
                        log.error("Error fetching drop data for NPC {}", npcId, ex);
                        return null;
                    });
        }, executor);
    }

    /**
     * @return a collection of all cached NPC drop data in memory
     */
    public Collection<NpcDropData> getAllNpcData()
    {
        loadIndex();
        return new ArrayList<>(cache.values());
    }

    /**
     * Return a list of NPC names containing the supplied query. Matches from
     * the local cache are combined with wiki search results to ensure partial
     * lookups surface all relevant NPCs.
     */
    public CompletableFuture<List<String>> searchNpcNames(String query)
    {
        ExecutorService executor = ensureExecutor();
        return CompletableFuture.supplyAsync(() ->
        {
            String lc = query.toLowerCase(Locale.ROOT).trim();
            loadIndex();

            // Preserve insertion order while de-duplicating names
            Set<String> names = cache.values().stream()
                    .map(NpcDropData::getName)
                    .filter(Objects::nonNull)
                    .filter(name -> name.toLowerCase(Locale.ROOT).contains(lc))
                    .collect(Collectors.toCollection(LinkedHashSet::new));

            try
            {
                names.addAll(dropFetcher.searchNpcNames(query));
            }
            catch (Exception ex)
            {
                log.debug("Wiki search failed for {}", query, ex);
            }

            return new ArrayList<>(names);
        }, executor);
    }

    private boolean isFresh(Path file)
    {
        try
        {
            Instant cutoff = Instant.now().minus(MAX_AGE);
            return Files.getLastModifiedTime(file).toInstant().isAfter(cutoff);
        }
        catch (IOException e)
        {
            return false;
        }
    }

    /**
     * Locate an existing cache file by name and level regardless of stored ID.
     */
    private Path findExistingCacheFile(String safeName, int level) throws IOException
    {
        String key = safeName + "_" + level;
        Path p = nameIndex.get(key);
        if (p != null && Files.exists(p))
        {
            if (isFresh(p))
            {
                return p;
            }
            Files.deleteIfExists(p);
            removeIndex(p);
        }
        return null;
    }

    private Path getCacheDir() throws IOException
    {
        String player = accountManager.getPlayerName();
        if (player == null)
        {
            throw new IOException("Player name is not available");
        }
        return RUNELITE_DIR.toPath()
                .resolve("chanceman")
                .resolve(player)
                .resolve("drops");
    }

    /** Resolve the on-disk cache path for a specific NPC. */
    private Path getCacheFile(int npcId, String name, int level) throws IOException
    {
        String safeName = name.replaceAll("[^A-Za-z0-9]", "_");
        Path dir = getCacheDir();
        Files.createDirectories(dir);
        String fn = npcId + "_" + safeName + "_" + level + ".json";
        return dir.resolve(fn);
    }

    /**
     * Deletes cached drop table files older than {@link #MAX_AGE} and purges
     * them from the in-memory index.
     */
    public void pruneOldCaches()
    {
        String player = accountManager.getPlayerName();
        if (player == null)
        {
            return;
        }

        Path dir = RUNELITE_DIR.toPath()
                .resolve("chanceman")
                .resolve(player)
                .resolve("drops");

        if (!Files.exists(dir))
        {
            return;
        }

        Instant cutoff = Instant.now().minus(MAX_AGE);
        try (Stream<Path> files = Files.list(dir))
        {
            files.filter(Files::isRegularFile)
                    .forEach(p ->
                    {
                        try
                        {
                            Instant mod = Files.getLastModifiedTime(p).toInstant();
                            if (mod.isBefore(cutoff))
                            {
                                Files.deleteIfExists(p);
                                removeIndex(p);
                            }
                        }
                        catch (IOException ex)
                        {
                            log.debug("Failed to delete old drop cache {}", p, ex);
                        }
                    });
        }
        catch (IOException ex)
        {
            log.debug("Error pruning drop cache directory {}", dir, ex);
        }
    }

    /**
     * Deletes all cached drop table files for the current player and clears the
     * in-memory index.
     */
    public void clearAllCaches()
    {
        String player = accountManager.getPlayerName();
        if (player == null) return;

        Path dir = RUNELITE_DIR.toPath()
                .resolve("chanceman")
                .resolve(player)
                .resolve("drops");

        if (Files.exists(dir))
        {
            try (Stream<Path> files = Files.list(dir))
            {
                files.filter(Files::isRegularFile)
                        .forEach(p ->
                        {
                            try
                            {
                                Files.deleteIfExists(p);
                            }
                            catch (IOException ex)
                            {
                                log.debug("Failed to delete drop cache {}", p, ex);
                            }
                        });
            }
            catch (IOException ex)
            {
                log.debug("Error clearing drop cache directory {}", dir, ex);
            }
        }

        cache.clear();
        nameIndex.clear();
        indexLoaded = true;
    }

    /** Remove the given file from the in-memory indices. */
    private void removeIndex(Path p)
    {
        NpcDropData data = cache.remove(p);
        if (data != null)
        {
            nameIndex.remove(buildNameKey(data.getName(), data.getLevel()));
        }
    }

    /** Lazily populate the in-memory indices from existing cache files. */
    private void loadIndex()
    {
        if (indexLoaded)
        {
            return;
        }
        synchronized (this)
        {
            if (indexLoaded)
            {
                return;
            }
            try
            {
                Path dir = getCacheDir();
                if (Files.exists(dir))
                {
                    try (Stream<Path> files = Files.list(dir))
                    {
                        for (Path p : files.filter(Files::isRegularFile).collect(Collectors.toList()))
                        {
                            if (!isFresh(p))
                            {
                                Files.deleteIfExists(p);
                                continue;
                            }
                            try
                            {
                                String json = Files.readString(p, StandardCharsets.UTF_8);
                                NpcDropData data = gson.fromJson(json, NpcDropData.class);
                                if (data != null && data.getDropTableSections() != null && !data.getDropTableSections().isEmpty())
                                {
                                    cache.put(p, data);
                                    nameIndex.put(buildNameKey(data.getName(), data.getLevel()), p);
                                }
                                else
                                {
                                    Files.deleteIfExists(p);
                                }
                            }
                            catch (Exception e)
                            {
                                log.warn("Skipping bad cache file {}", p, e);
                                Files.deleteIfExists(p);
                            }
                        }
                    }
                }
            }
            catch (IOException e)
            {
                log.debug("Error loading cache index", e);
            }
            indexLoaded = true;
        }
    }

    /** Gracefully shutdown IO executor. */
    public void shutdown() {
        ExecutorService executor = ioExecutor;
        if (executor == null) {
            return;
        }

        executor.shutdownNow();
        ioExecutor = null;
        cache.clear();
        nameIndex.clear();
        indexLoaded = false;
    }

    private synchronized ExecutorService ensureExecutor() {
        if (ioExecutor == null || ioExecutor.isShutdown() || ioExecutor.isTerminated()) {
            ioExecutor = Executors.newFixedThreadPool(
                    Math.max(2, Runtime.getRuntime().availableProcessors() / 2),
                    new ThreadFactoryBuilder().setNameFormat("dropcache-io-%d").build()
            );
        }
        return ioExecutor;
    }

    private String buildNameKey(String name, int level)
    {
        return name.replaceAll("[^A-Za-z0-9]", "_") + "_" + level;
    }
}
package com.choicer.chanceman.drops;

import com.google.common.util.concurrent.ThreadFactoryBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonElement;
import com.google.gson.JsonParser;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.ItemComposition;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.game.ItemManager;
import net.runelite.http.api.item.ItemPrice;
import okhttp3.OkHttpClient;
import okhttp3.Request;
import okhttp3.Response;
import org.jsoup.Jsoup;
import org.jsoup.nodes.Document;
import org.jsoup.nodes.Element;
import org.jsoup.select.Elements;

import javax.inject.Inject;
import javax.inject.Singleton;
import java.io.IOException;
import java.io.UncheckedIOException;
import java.net.URLDecoder;
import java.net.URLEncoder;
import java.nio.charset.StandardCharsets;
import java.util.*;
import java.util.concurrent.*;

/**
 * Retrieves NPC drop information from the wiki and
 * resolves item and NPC IDs.
 */
@Slf4j
@Singleton
public class DropFetcher
{
    private static final String USER_AGENT = "RuneLite-ChanceMan/2.8.2";
    private final OkHttpClient httpClient;
    private final ItemManager itemManager;
    private final ClientThread clientThread;
    private ExecutorService fetchExecutor;

    @Inject
    public DropFetcher(OkHttpClient httpClient, ItemManager itemManager, ClientThread clientThread)
    {
        this.httpClient = httpClient;
        this.itemManager  = itemManager;
        this.clientThread = clientThread;
    }

    /**
     * Asynchronously fetch an NPC's drop table from the wiki.
     * 1) Download + parse document (BG thread)
     * 2) Resolve item IDs on client thread using ItemManager.search (canonicalized)
     */
    public CompletableFuture<NpcDropData> fetch(int npcId, String name, int level)
    {
        return CompletableFuture.supplyAsync(() -> {
            String url = buildWikiUrl(npcId, name);
            String html = fetchHtml(url);
            Document doc = Jsoup.parse(html);

            String actualName = name;
            Element heading = doc.selectFirst("h1#firstHeading");
            if (heading != null) {
                actualName = heading.text();
            }

            int resolvedLevel = level > 0 ? level : parseCombatLevel(doc);
            int actualId = resolveNpcId(doc);
            List<DropTableSection> sections = parseSections(doc);
            if (sections.isEmpty()) {
                return null; // skip NPCs without drop tables
            }
            return new NpcDropData(actualId, actualName, resolvedLevel, sections);
        }, fetchExecutor).thenCompose(data -> {
            if (data == null) {
                return CompletableFuture.completedFuture(null);
            }

            CompletableFuture<NpcDropData> resolved = new CompletableFuture<>();
            clientThread.invoke(() -> {
                for (DropTableSection sec : data.getDropTableSections()) {
                    List<DropItem> items = sec.getItems();
                    for (int i = 0; i < items.size(); i++) {
                        DropItem d = items.get(i);
                        d.setItemId(resolveItemId(d.getName()));
                    }
                }
                resolved.complete(data);
            });
            return resolved;
        });
    }

    /** Resolve an item name to an ID using ItemManager.search only (canonicalized). */
    private int resolveItemId(String itemName)
    {
        if (itemName == null || itemName.isEmpty()) {
            return 0;
        }
        String lower = itemName.trim().toLowerCase(Locale.ROOT);
        if ("nothing".equals(lower) || "unknown".equals(lower)) {
            return 0;
        }

        try {
            List<ItemPrice> results = itemManager.search(itemName);
            for (int j = 0; j < results.size(); j++) {
                int id = results.get(j).getId();
                ItemComposition comp = itemManager.getItemComposition(id);
                if (comp != null && comp.getName() != null && comp.getName().equalsIgnoreCase(itemName)) {
                    return itemManager.canonicalize(id);
                }
            }
        } catch (Exception ex) {
            // ignore; fall through
        }

        return 0;
    }

    /** Extract drop table sections (skips Nothing rows). */
    private List<DropTableSection> parseSections(Document doc)
    {
        Elements tables = doc.select("table.item-drops");

        List<DropTableSection> sections = new ArrayList<>();

        for (Element table : tables)
        {
            String header = "Drops";
            Element prev = table.previousElementSibling();
            while (prev != null)
            {
                String tag = prev.tagName();
                if (tag != null && tag.matches("h[2-4]")) {
                    header = prev.text();
                    break;
                }
                prev = prev.previousElementSibling();
            }

            List<DropItem> items = new ArrayList<>();
            Elements rows = table.select("tbody > tr");
            for (Element row : rows) {
                Elements tds = row.select("td");
                if (tds.size() < 6) {
                    continue;
                }
                String name = tds.get(1).text().replace("(m)", "").trim();
                if (name.equalsIgnoreCase("nothing")) {
                    continue;
                }
                String rarity = tds.get(3).text().trim();
                items.add(new DropItem(0, name, rarity));
            }

            if (!items.isEmpty())
            {
                sections.add(new DropTableSection(header, items));
            }
        }

        return sections;
    }

    /** Attempt to parse the combat level from the NPC infobox. */
    private int parseCombatLevel(Document doc)
    {
        Element infobox = doc.selectFirst("table.infobox");
        if (infobox == null)
        {
            return 0;
        }
        Elements rows = infobox.select("tr");
        for (Element row : rows)
        {
            Element th = row.selectFirst("th");
            Element td = row.selectFirst("td");
            if (th != null && td != null) {
                String thText = th.text();
                if (thText != null && thText.toLowerCase(Locale.ROOT).contains("combat level")) {
                    String txt = td.text();
                    String[] parts = txt.split("[^0-9]+");
                    for (String part : parts) {
                        if (part != null && part.length() > 0) {
                            try {
                                return Integer.parseInt(part);
                            } catch (NumberFormatException nfe) {
                                log.warn("Failed to parse combat level: {}", txt);
                            }
                        }
                    }
                }
            }
        }
        return 0;
    }

    /** Resolve the canonical wiki page ID for the provided document. */
    private int resolveNpcId(Document doc)
    {
        Element link = doc.selectFirst("link[rel=canonical]");
        if (link == null)
        {
            return 0;
        }

        String href = link.attr("href");
        String title = href.substring(href.lastIndexOf('/') + 1);
        title = URLDecoder.decode(title, StandardCharsets.UTF_8);
        title = title.replace(' ', '_');
        String apiUrl = "https://oldschool.runescape.wiki/api.php?action=query&format=json&prop=info&titles="
                + URLEncoder.encode(title, StandardCharsets.UTF_8);

        Request req = new Request.Builder()
                .url(apiUrl)
                .header("User-Agent", USER_AGENT)
                .build();

        try (Response res = httpClient.newCall(req).execute())
        {
            if (!res.isSuccessful())
            {
                log.warn("Failed to resolve NPC ID for {}: HTTP {}", title, res.code());
                return 0;
            }

            String body = res.body().string();
            JsonElement root = new JsonParser().parse(body);
            JsonElement pages = root.getAsJsonObject()
                    .getAsJsonObject("query")
                    .getAsJsonObject("pages");

            for (Map.Entry<String, JsonElement> entry : pages.getAsJsonObject().entrySet())
            {
                JsonElement page = entry.getValue();
                if (page.getAsJsonObject().has("pageid"))
                {
                    return page.getAsJsonObject().get("pageid").getAsInt();
                }
            }

            log.warn("No page ID found for title {}", title);
        }
        catch (IOException ex)
        {
            log.warn("Error resolving NPC ID for {}", title, ex);
        }
        return 0;
    }

    /** Query the wiki's search API for NPC names matching the provided text. */
    public List<String> searchNpcNames(String query)
    {
        String url = "https://oldschool.runescape.wiki/api.php?action=opensearch&format=json&limit=20&namespace=0&search="
                + URLEncoder.encode(query, StandardCharsets.UTF_8);
        Request req = new Request.Builder()
                .url(url)
                .header("User-Agent", USER_AGENT)
                .build();
        try (Response res = httpClient.newCall(req).execute())
        {
            if (!res.isSuccessful())
            {
                throw new IOException("HTTP " + res.code());
            }
            String body = res.body().string();
            JsonArray arr = new JsonParser().parse(body).getAsJsonArray();
            JsonArray titles = arr.get(1).getAsJsonArray();
            List<String> names = new ArrayList<>();
            for (int i = 0; i < titles.size(); i++) {
                names.add(titles.get(i).getAsString());
            }
            return names;
        }
        catch (IOException ex)
        {
            throw new UncheckedIOException(ex);
        }
    }

    private String buildWikiUrl(int npcId, String name)
    {
        String fallback = URLEncoder.encode(name.replace(' ', '_'), StandardCharsets.UTF_8);
        StringBuilder url = new StringBuilder("https://oldschool.runescape.wiki/w/Special:Lookup?type=npc");

        if (npcId > 0)
        {
            url.append("&id=").append(npcId);
        }

        if (!fallback.isEmpty())
        {
            url.append("&name=").append(fallback);
        }

        url.append("#Drops");
        return url.toString();
    }

    private String fetchHtml(String url)
    {
        Request req = new Request.Builder()
                .url(url)
                .header("User-Agent", USER_AGENT)
                .build();
        try (Response res = httpClient.newCall(req).execute())
        {
            if (!res.isSuccessful()) throw new IOException("HTTP " + res.code());
            return res.body().string();
        }
        catch (IOException ex)
        {
            throw new UncheckedIOException(ex);
        }
    }

    /** Creates the fetch executor if it is missing or has been shut down. */
    public void startUp()
    {
        if (fetchExecutor == null || fetchExecutor.isShutdown() || fetchExecutor.isTerminated())
        {
            fetchExecutor = Executors.newFixedThreadPool(
                    4,
                    new ThreadFactoryBuilder().setNameFormat("dropfetch-%d").build()
            );
        }
    }

    /** Shut down the executor service. */
    public void shutdown()
    {
        if (fetchExecutor != null)
        {
            fetchExecutor.shutdownNow();
            fetchExecutor = null;
        }
    }
}
package com.choicer.chanceman.drops;

import lombok.Getter;
import lombok.Setter;

import java.util.List;

@Setter
@Getter
public class NpcDropData
{
    private int npcId;
    private String name;
    private int level;
    private List<DropTableSection> dropTableSections;

    public NpcDropData(int npcId, String name, int level, List<DropTableSection> dropTableSections)
    {
        this.npcId = npcId;
        this.name = name;
        this.level = level;
        this.dropTableSections = dropTableSections;
    }

}

package com.choicer.chanceman.persist;

import com.google.gson.Gson;
import com.google.gson.reflect.TypeToken;
import net.runelite.client.config.ConfigManager;

import javax.inject.Inject;
import javax.inject.Singleton;
import java.lang.reflect.Type;
import java.util.LinkedHashSet;
import java.util.Set;

/**
 * Mirrors ChanceMan state into RuneLite ConfigManager so it can sync across machines
 * via RuneLite's profile/cloud sync.
 * Uses stamped read/write: each set is stored with a last-write timestamp
 * to support last-writer-wins (LWW) reconciliation across machines.
 */
@Singleton
public final class ConfigPersistence
{
    private static final String GROUP = "chanceman";
    private static final String DATA_SUFFIX = ".data";
    private static final String TS_SUFFIX = ".ts";
    private static final Type SET_TYPE = new TypeToken<Set<Integer>>(){}.getType();

    private final ConfigManager configManager;
    private final Gson gson;

    @Inject
    public ConfigPersistence(ConfigManager configManager, Gson gson)
    {
        this.configManager = configManager;
        this.gson = gson;
    }
    private static String dataKey(String key, String player) { return key + "." + player + DATA_SUFFIX; }
    private static String tsKey(String key, String player)   { return key + "." + player + TS_SUFFIX; }
    /** Value class for stamped set reads. */
    public static final class StampedSet
    {
        public final Set<Integer> data;
        public final long ts; // epoch millis; 0 means "unknown/not set"

        public StampedSet(Set<Integer> data, long ts)
        {
            this.data = (data != null) ? new LinkedHashSet<>(data) : new LinkedHashSet<>();
            this.ts = Math.max(0L, ts);
        }
    }

    /**
     * Read a stamped set from ConfigManager.
     * Returns empty set + ts=0 if absent or malformed.
     */
    public StampedSet readStampedSet(String player, String key)
    {
        if (isBlank(player) || isBlank(key))
        {
            return new StampedSet(new LinkedHashSet<>(), 0L);
        }

        String rawData = configManager.getConfiguration(GROUP, dataKey(key, player));
        String rawTs   = configManager.getConfiguration(GROUP, tsKey(key, player));

        if (isBlank(rawData) || isBlank(rawTs))
        {
            return new StampedSet(new LinkedHashSet<>(), 0L);
        }

        try
        {
            Set<Integer> parsed = gson.fromJson(rawData, SET_TYPE);
            long ts = parseLongSafe(rawTs);
            return new StampedSet((parsed != null) ? parsed : new LinkedHashSet<>(), ts);
        }
        catch (Exception ignored)
        {
            return new StampedSet(new LinkedHashSet<>(), 0L);
        }
    }

    /**
     * Write a stamped set to ConfigManager (unconditional).
     *
     * @param timestampMillis epoch millis representing the authoritative write time
     */
    public void writeStampedSet(String player, String key, Set<Integer> data, long timestampMillis)
    {
        if (isBlank(player) || isBlank(key)) return;

        String dataJson = gson.toJson((data != null) ? data : new LinkedHashSet<>());
        String tsStr    = String.valueOf(Math.max(0L, timestampMillis));

        // Two separate keys: value and timestamp
        configManager.setConfiguration(GROUP, dataKey(key, player), dataJson);
        configManager.setConfiguration(GROUP, tsKey(key, player), tsStr);
    }

    /**
     * Write only if the provided timestamp is >= the currently stored timestamp.
     * This is a simple guard against out-of-order writes when multiple machines
     * or threads may be updating the cloud state.
     *
     * @return true if a write occurred, false if skipped
     */
    public boolean writeStampedSetIfNewer(String player, String key, Set<Integer> data, long timestampMillis)
    {
        if (isBlank(player) || isBlank(key)) return false;

        long existingTs = parseLongSafe(configManager.getConfiguration(GROUP, tsKey(key, player)));
        if (timestampMillis < existingTs)
        {
            // Skip stale write
            return false;
        }
        writeStampedSet(player, key, data, timestampMillis);
        return true;
    }

    private static boolean isBlank(String s) { return s == null || s.isEmpty(); }

    private static long parseLongSafe(String s)
    {
        if (isBlank(s)) return 0L;
        try { return Long.parseLong(s.trim()); } catch (NumberFormatException e) { return 0L; }
    }
}

package com.choicer.chanceman;

import java.util.function.Supplier;

/**
 * Common contract for roll overlays so the animation manager can swap them.
 */
public interface RollOverlay
{
    void startRollAnimation(int dummy, int rollDurationMs, Supplier<Integer> randomLockedItemSupplier);

    int getFinalItem();

    int getHighlightDurationMs();

    /**
     * Optional hook for overlays to stop rendering immediately (no-op by default).
     */
    default void stopAnimation()
    {
    }
}

package com.choicer.chanceman.managers;

import com.choicer.chanceman.ChanceManConfig;
import com.choicer.chanceman.ChanceManOverlay;
import com.choicer.chanceman.ChanceManPanel;
import com.choicer.chanceman.ChoicemanOverlay;
import com.choicer.chanceman.RollOverlay;
import lombok.Getter;
import lombok.Setter;
import net.runelite.api.ChatMessageType;
import net.runelite.api.Client;
import net.runelite.api.ItemComposition;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.game.ItemManager;
import net.runelite.client.input.MouseAdapter;
import net.runelite.client.input.MouseManager;
import net.runelite.client.util.ColorUtil;

import javax.inject.Inject;
import javax.inject.Singleton;
import javax.swing.SwingUtilities;
import java.awt.event.MouseEvent;
import java.util.*;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.ConcurrentLinkedQueue;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

/**
 * Manages the roll animation for unlocking items.
 * It processes roll requests asynchronously and handles the roll animation through the overlay.
 */
@Singleton
public class RollAnimationManager
{
    @Inject private ItemManager itemManager;
    @Inject private Client client;
    @Inject private ClientThread clientThread;
    @Inject private UnlockedItemsManager unlockedManager;
    @Inject private ChanceManOverlay chanceManOverlay;
    @Inject private ChoicemanOverlay choicemanOverlay;
    @Inject private ChanceManConfig config;
    @Inject private MouseManager mouseManager;
    @Setter private ChanceManPanel chanceManPanel;

    private HashSet<Integer> allTradeableItems;
    private volatile Set<Integer> strictlyTradeableItems = Collections.emptySet();
    private final Queue<Integer> rollQueue = new ConcurrentLinkedQueue<>();
    private ExecutorService executor = Executors.newSingleThreadExecutor();
    private volatile boolean isRolling = false;
    private static final int SNAP_WINDOW_MS = 350;
    private final Random random = new Random();
    private volatile RollOverlay activeOverlayRef;

    @Getter
    @Setter
    private volatile boolean manualRoll = false;

    public synchronized void setAllTradeableItems(HashSet<Integer> allTradeableItems)
    {
        this.allTradeableItems = allTradeableItems;
        if (allTradeableItems == null || allTradeableItems.isEmpty())
        {
            strictlyTradeableItems = Collections.emptySet();
            return;
        }

        HashSet<Integer> tradeableOnly = new HashSet<>();
        for (int id : allTradeableItems)
        {
            ItemComposition comp = itemManager.getItemComposition(id);
            if (comp != null && comp.isTradeable())
            {
                tradeableOnly.add(id);
            }
        }
        strictlyTradeableItems = tradeableOnly;
    }

    /**
     * Enqueues an item ID for the roll animation.
     *
     * @param itemId The item ID to be rolled.
     */
    public void enqueueRoll(int itemId)
    {
        rollQueue.offer(itemId);
    }

    /**
     * Processes the roll queue by initiating a roll animation if not already rolling.
     */
    public void process()
    {
        if (!isRolling && !rollQueue.isEmpty())
        {
            int queuedItemId = rollQueue.poll();
            isRolling = true;
            executor.submit(() -> performRoll(queuedItemId));
        }
    }

    /**
     * Performs the roll animation.
     * Now announces/unlocks as soon as the item is selected (after the snap),
     * while still letting the highlight finish visually before accepting another roll.
     */
    private void performRoll(int queuedItemId)
    {
        int rollDuration = 3000;
        List<Integer> choicemanOptions = Collections.emptyList();
        boolean choicemanActive = false;
        if (config.enableChoiceman())
        {
            List<Integer> generated = buildChoicemanOptions(queuedItemId);
            if (generated.size() >= 2)
            {
                choicemanOptions = Collections.unmodifiableList(generated);
                choicemanOverlay.setChoicemanOptions(choicemanOptions);
                choicemanActive = true;
            }
            else
            {
                choicemanOverlay.setChoicemanOptions(Collections.emptyList());
            }
        }
        else
        {
            choicemanOverlay.setChoicemanOptions(Collections.emptyList());
        }

        RollOverlay activeOverlay = choicemanActive ? choicemanOverlay : chanceManOverlay;
        activeOverlayRef = activeOverlay;
        activeOverlay.startRollAnimation(0, rollDuration, this::getRandomLockedItem);

        try
        {
            Thread.sleep(rollDuration + SNAP_WINDOW_MS);
        }
        catch (InterruptedException e)
        {
            Thread.currentThread().interrupt();
        }

        int finalRolledItem = activeOverlay.getFinalItem();
        int itemToUnlock;
        if (choicemanActive)
        {
            choicemanOverlay.setSelectionPending(true);
            try
            {
                itemToUnlock = waitForChoicemanSelection(choicemanOptions, finalRolledItem);
            }
            finally
            {
                choicemanOverlay.setSelectionPending(false);
                choicemanOverlay.stopAnimation();
            }
        }
        else
        {
            itemToUnlock = finalRolledItem;
        }

        if (!choicemanActive)
        {
            int remainingHighlight = Math.max(0, activeOverlay.getHighlightDurationMs() - SNAP_WINDOW_MS);
            if (remainingHighlight > 0)
            {
                try
                {
                    Thread.sleep(remainingHighlight);
                }
                catch (InterruptedException e)
                {
                    Thread.currentThread().interrupt();
                }
            }
        }

        if (itemToUnlock != 0)
        {
            unlockedManager.unlockItem(itemToUnlock);
        }

        final boolean wasManualRoll = isManualRoll();
        final int finalItemToAnnounce = itemToUnlock != 0 ? itemToUnlock : finalRolledItem;
        final boolean announceChoiceman = choicemanActive;
        final int choiceCount = choicemanOptions.size();
        final int queuedId = queuedItemId;
        clientThread.invoke(() -> {
            String unlockedTag = ColorUtil.wrapWithColorTag(getItemName(finalItemToAnnounce), config.unlockedItemColor());
            String message;
            if (wasManualRoll)
            {
                String pressTag = ColorUtil.wrapWithColorTag("pressing a button", config.rolledItemColor());
                message = announceChoiceman
                        ? "Choiceman unlocked " + unlockedTag + " after " + pressTag + " presented "
                        + choiceCount + " choices."
                        : "Unlocked " + unlockedTag + " by " + pressTag;
            }
            else
            {
                String rolledTag = ColorUtil.wrapWithColorTag(getItemName(queuedId), config.rolledItemColor());
                message = announceChoiceman
                        ? "Choiceman unlocked " + unlockedTag + " after rolling " + choiceCount
                        + " choices (first was " + rolledTag + ")."
                        : "Unlocked " + unlockedTag + " by rolling " + rolledTag;
            }
            client.addChatMessage(ChatMessageType.GAMEMESSAGE, "", message, null);
            if (chanceManPanel != null) {
                SwingUtilities.invokeLater(() -> chanceManPanel.updatePanel());
            }
        });

        setManualRoll(false);
        isRolling = false;
        activeOverlayRef = null;
    }

    /**
     * Checks if a roll animation is currently in progress.
     *
     * @return true if a roll is in progress, false otherwise.
     */
    public boolean isRolling() {
        return isRolling;
    }

    /**
     * Retrieves a random locked item from the list of tradeable items.
     *
     * @return A random locked item ID, or a fallback if all items are unlocked.
     */
    public int getRandomLockedItem()
    {
        List<Integer> locked = new ArrayList<>();
        for (int id : allTradeableItems)
        {
            if (!unlockedManager.isUnlocked(id))
            {
                locked.add(id);
            }
        }
        if (locked.isEmpty())
        {
            // Fallback: keep showing the current center item
            RollOverlay overlayRef = activeOverlayRef != null ? activeOverlayRef : chanceManOverlay;
            return overlayRef.getFinalItem();
        }
        return locked.get(random.nextInt(locked.size()));
    }

    public String getItemName(int itemId)
    {
        ItemComposition comp = itemManager.getItemComposition(itemId);
        if (comp == null)
        {
            return "";
        }
        String name = comp.getName();
        if (name == null)
        {
            return "";
        }
        name = name.trim();
        if (name.isEmpty() || name.equalsIgnoreCase("null") || name.equalsIgnoreCase("Members") || name.equalsIgnoreCase("(Members)") || name.matches("(?i)null\\s*\\(Members\\)"))
        {
            return "";
        }
        return name;
    }

    public void startUp() {
        if (executor == null || executor.isShutdown() || executor.isTerminated()) {
            executor = Executors.newSingleThreadExecutor();
        }
    }

    /**
     * Shuts down the roll animation executor service.
     */
    public void shutdown()
    {
        executor.shutdownNow();
    }

    private List<Integer> buildChoicemanOptions(int guaranteedItemId)
    {
        int target = Math.max(2, Math.min(5, config.choicemanOptionCount()));
        LinkedHashSet<Integer> options = new LinkedHashSet<>();
        boolean hasTradeableOption = isTradeableItem(guaranteedItemId);
        if (guaranteedItemId != 0)
        {
            options.add(guaranteedItemId);
        }

        int attemptsLeft = Math.max(target * 3, allTradeableItems != null ? allTradeableItems.size() : target * 3);
        while (options.size() < target && attemptsLeft-- > 0)
        {
            int candidate = getRandomLockedItem();
            if (candidate == 0)
            {
                break;
            }
            options.add(candidate);
            if (isTradeableItem(candidate))
            {
                hasTradeableOption = true;
            }
        }

        if (!hasTradeableOption)
        {
            int failsafe = getRandomTradeableItem();
            if (failsafe != 0 && !options.contains(failsafe))
            {
                if (options.size() >= target)
                {
                    Iterator<Integer> iterator = options.iterator();
                    boolean removed = false;
                    while (iterator.hasNext())
                    {
                        int itemId = iterator.next();
                        if (!isTradeableItem(itemId))
                        {
                            iterator.remove();
                            removed = true;
                            break;
                        }
                    }
                    if (!removed)
                    {
                        Iterator<Integer> fallbackIterator = options.iterator();
                        if (fallbackIterator.hasNext())
                        {
                            fallbackIterator.next();
                            fallbackIterator.remove();
                        }
                    }
                }
                if (options.size() < target)
                {
                    options.add(failsafe);
                    hasTradeableOption = true;
                }
            }
        }

        return new ArrayList<>(options);
    }

    private boolean isTradeableItem(int itemId)
    {
        return itemId != 0 && strictlyTradeableItems.contains(itemId);
    }

    private int getRandomTradeableItem()
    {
        if (strictlyTradeableItems == null || strictlyTradeableItems.isEmpty())
        {
            return 0;
        }
        int index = random.nextInt(strictlyTradeableItems.size());
        int i = 0;
        for (int id : strictlyTradeableItems)
        {
            if (i++ == index)
            {
                return id;
            }
        }
        return strictlyTradeableItems.iterator().next();
    }

    private int waitForChoicemanSelection(List<Integer> options, int fallbackItemId)
    {
        if (options.isEmpty())
        {
            return fallbackItemId;
        }
        if (client.getCanvas() == null)
        {
            return options.get(0);
        }
        CompletableFuture<Integer> future = new CompletableFuture<>();
        MouseAdapter listener = new MouseAdapter()
        {
            private Integer blockIfOverButton(MouseEvent e)
            {
                Integer hit = choicemanOverlay.getOptionAt(e.getX(), e.getY());
                if (hit != null)
                {
                    e.consume();
                }
                return hit;
            }

            @Override
            public MouseEvent mousePressed(MouseEvent e)
            {
                blockIfOverButton(e);
                return e;
            }

            @Override
            public MouseEvent mouseClicked(MouseEvent e)
            {
                blockIfOverButton(e);
                return e;
            }

            @Override
            public MouseEvent mouseReleased(MouseEvent e)
            {
                Integer hit = blockIfOverButton(e);
                if (hit != null)
                {
                    future.complete(hit);
                }
                return e;
            }
        };
        // Register after any coordinate translators (eg. Stretched Mode) so click coords line up with overlays.
        mouseManager.registerMouseListener(listener);
        try
        {
            Integer result = future.get();
            return result != null ? result : fallbackItemId;
        }
        catch (InterruptedException e)
        {
            Thread.currentThread().interrupt();
            return fallbackItemId;
        }
        catch (ExecutionException e)
        {
            return fallbackItemId;
        }
        finally
        {
            mouseManager.unregisterMouseListener(listener);
        }
    }
}

package com.choicer.chanceman.managers;

import com.choicer.chanceman.account.AccountManager;
import com.choicer.chanceman.persist.ConfigPersistence;
import com.google.gson.Gson;
import com.google.gson.reflect.TypeToken;
import lombok.Setter;
import lombok.extern.slf4j.Slf4j;

import javax.inject.Inject;
import javax.inject.Singleton;
import java.io.BufferedWriter;
import java.io.IOException;
import java.io.Reader;
import java.lang.reflect.Type;
import java.nio.file.*;
import java.text.SimpleDateFormat;
import java.util.*;
import java.util.concurrent.ExecutorService;

import static net.runelite.client.RuneLite.RUNELITE_DIR;

@Slf4j
@Singleton
public class RolledItemsManager
{
    private static final int MAX_BACKUPS = 10;
    private static final String CFG_KEY = "rolled";
    private static final String BACKUP_TS_PATTERN = "yyyyMMddHHmmss";
    private static final long CONFIG_DEBOUNCE_MS = 3000L;
    private static final long SELF_WRITE_GRACE_MS = 1500L;
    private static final long FS_DEBOUNCE_MS = 200L;
    private static final String FILE_NAME = "chanceman_rolled.json";
    private static final Type SET_TYPE = new TypeToken<Set<Integer>>(){}.getType();
    private final Set<Integer> rolledItems = Collections.synchronizedSet(new LinkedHashSet<>());
    @Inject private AccountManager accountManager;
    @Inject private Gson gson;
    @Inject private ConfigPersistence configPersistence;
    @Setter private ExecutorService executor; // file writes & cloud mirror
    @Setter private Runnable onChange; // optional UI refresh
    private volatile long lastConfigWriteMs = 0L;
    private volatile boolean configWriteWarned = false;
    private volatile boolean dirty = false;
    private WatchService watchService;
    private volatile boolean watcherRunning = false;
    private volatile long lastSelfWriteMs = 0L;
    private Thread watcherThread;

    public boolean isRolled(int itemId) { return rolledItems.contains(itemId); }

    /** Return an immutable snapshot to avoid leaking the synchronizedSet. */
    public Set<Integer> getRolledItems() {
        synchronized (rolledItems) {
            return Collections.unmodifiableSet(new LinkedHashSet<>(rolledItems));
        }
    }

    public void markRolled(int itemId)
    {
        if (rolledItems.add(itemId))
        {
            dirty = true;
            safeNotifyChange();
            saveRolledItems();
        }
    }

    /** Initial load + LWW reconciliation. */
    public void loadRolledItems()
    {
        reconcileWithCloud(false);
        safeNotifyChange();
    }

    /** Normal save: disk + debounced cloud with current time. */
    public void saveRolledItems()
    {
        saveInternal(System.currentTimeMillis(), true);
    }

    /** Start watching the JSON on a dedicated daemon thread. */
    public void startWatching()
    {
        if (watcherRunning) return;
        Path file = safeGetFilePathOrNull();
        if (file == null) return;

        try
        {
            watchService = FileSystems.getDefault().newWatchService();
            file.getParent().register(
                    watchService,
                    StandardWatchEventKinds.ENTRY_CREATE,
                    StandardWatchEventKinds.ENTRY_MODIFY,
                    StandardWatchEventKinds.ENTRY_DELETE
            );
        }
        catch (IOException e)
        {
            closeWatchServiceQuietly();
            log.error("Rolled watcher: could not register", e);
            return;
        }

        watcherRunning = true;
        final String target = file.getFileName().toString();

        watcherThread = new Thread(() -> runWatcherLoop(target), "ChanceMan-Rolled-Watcher");
        watcherThread.setDaemon(true);
        watcherThread.start();
    }

    /** Stop watching the JSON. */
    public void stopWatching()
    {
        watcherRunning = false;
        if (watcherThread != null) watcherThread.interrupt();
        closeWatchServiceQuietly();
        watcherThread = null;
    }

    /** Flush synchronously on shutdown if dirty. */
    public void flushIfDirtyOnExit()
    {
        if (!dirty) return;
        Path file = safeGetFilePathOrNull();
        if (file == null) return;

        try
        {
            rotateBackupIfExists(file);
            Set<Integer> snap = snapshotRolled();
            writeJsonAtomic(file, snap);
            mirrorToCloud(System.currentTimeMillis(), false, snap);
            dirty = false;
        }
        catch (IOException e)
        {
            log.error("Shutdown flush failed for rolled items (local saves may be stale).", e);
        }
        catch (Exception e)
        {
            log.error("Shutdown flush: failed to mirror rolled set to ConfigManager.", e);
        }
    }

    private void reconcileWithCloud(boolean runtime)
    {
        String player = accountManager.getPlayerName();
        if (player == null) return;

        Path file = safeGetFilePathOrNull();
        if (file == null) return;

        boolean fileExisted = Files.exists(file);

        Set<Integer> local = readLocalJson(file);
        long localMtime = fileExisted ? safeLastModified(file) : 0L;

        ConfigPersistence.StampedSet cloudStamped = readCloud(player);
        Set<Integer> cloud = new LinkedHashSet<>(cloudStamped.data);
        long cloudTs = cloudStamped.ts;

        // LWW
        Set<Integer> winner;
        Long winnerStamp = null;
        boolean needPersist;

        if (localMtime > cloudTs) { winner = local;  winnerStamp = localMtime; needPersist = true; } // push to cloud
        else if (cloudTs > localMtime) { winner = cloud;  winnerStamp = cloudTs;    needPersist = true; } // pull to disk
        else { winner = local;  needPersist = !fileExisted; } // create disk if missing

        synchronized (rolledItems) {
            rolledItems.clear();
            rolledItems.addAll(winner);
        }

        if (needPersist)
        {
            long stamp = (winnerStamp != null) ? winnerStamp : System.currentTimeMillis();
            saveInternal(stamp, false); // bypass debounce during reconcile
        }
        dirty = false;
    }

    /** Disk write + cloud mirror (debounced or immediate). */
    private void saveInternal(long stampMillis, boolean debounced)
    {
        if (!isExecutorAvailable())
        {
            log.error("RolledItemsManager: executor unavailable; skipping save");
            return;
        }

        executor.submit(() -> {
            Path file = safeGetFilePathOrNull();
            if (file == null)
            {
                log.error("RolledItemsManager: file path unavailable; skipping save");
                return;
            }
            try
            {
                rotateBackupIfExists(file);
                Set<Integer> snap = snapshotRolled();
                writeJsonAtomic(file, snap);
                mirrorToCloud(stampMillis, debounced, snap);
                dirty = false;
            }
            catch (IOException e)
            {
                log.error("Error saving rolled items", e);
            }
        });
    }

    /** Mirror to cloud, optionally debounced; uses provided snapshot to avoid re-locking. */
    private void mirrorToCloud(long stampMillis, boolean debounced, Set<Integer> snapshot)
    {
        long now = System.currentTimeMillis();
        if (debounced && (now - lastConfigWriteMs < CONFIG_DEBOUNCE_MS)) return;
        lastConfigWriteMs = now;

        String player = accountManager.getPlayerName();
        if (player == null || player.isEmpty() || executor == null) return;

        Set<Integer> snap = (snapshot != null) ? snapshot : snapshotRolled();
        executor.submit(() -> {
            try
            {
                // Guard against out-of-order writes across machines/threads
                configPersistence.writeStampedSetIfNewer(player, CFG_KEY, snap, stampMillis);
            }
            catch (Exception e)
            {
                if (!configWriteWarned)
                {
                    configWriteWarned = true;
                    log.error("ChanceMan: failed to mirror rolled set to ConfigManager (local saves intact).", e);
                }
            }
        });
    }

    private boolean isExecutorAvailable()
    {
        if (executor == null) return false;
        if (executor instanceof java.util.concurrent.ThreadPoolExecutor) {
            java.util.concurrent.ThreadPoolExecutor tpe =
                    (java.util.concurrent.ThreadPoolExecutor) executor;
            return !tpe.isShutdown() && !tpe.isTerminated();
        }
        return true;
    }

    private void safeNotifyChange()
    {
        Runnable cb = onChange;
        if (cb != null) { try { cb.run(); } catch (Throwable t) { log.error("onChange threw", t); } }
    }

    private Path getFilePath() throws IOException
    {
        String name = accountManager.getPlayerName();
        if (name == null) throw new IOException("Player name is null");
        Path dir = RUNELITE_DIR.toPath().resolve("chanceman").resolve(name);
        Files.createDirectories(dir);
        return dir.resolve(FILE_NAME);
    }

    private Path safeGetFilePathOrNull()
    {
        try { return getFilePath(); } catch (IOException ioe) { return null; }
    }

    /** Windows-safe: COPY current file to a timestamped backup with small retries; then prune. */
    private void rotateBackupIfExists(Path file) throws IOException
    {
        if (!Files.exists(file)) return;

        Path backups = file.getParent().resolve("backups");
        Files.createDirectories(backups);

        String ts = new SimpleDateFormat(BACKUP_TS_PATTERN).format(new Date());
        Path bak = backups.resolve(file.getFileName() + "." + ts + ".bak");

        final int maxAttempts = 5;
        for (int attempt = 1; ; attempt++)
        {
            try
            {
                Files.copy(file, bak, StandardCopyOption.REPLACE_EXISTING);
                break;
            }
            catch (FileSystemException fse)
            {
                if (attempt >= maxAttempts)
                {
                    log.error("Backup copy failed after {} attempts for {}", attempt, file, fse);
                    break; // give up on backup, continue save
                }
                try { Thread.sleep(50L * attempt); } catch (InterruptedException ie) { Thread.currentThread().interrupt(); break; }
            }
        }

        try (java.util.stream.Stream<Path> stream = Files.list(backups))
        {
            stream
                    .filter(p -> p.getFileName().toString().startsWith(file.getFileName() + "."))
                    .sorted(Comparator.comparing(Path::getFileName).reversed())
                    .skip(MAX_BACKUPS)
                    .forEach(p -> { try { Files.deleteIfExists(p); } catch (IOException ignored) {} });
        }
    }

    /** Write JSON to .tmp and atomically replace the main file; mark self-write for watcher echo suppression. */
    private void writeJsonAtomic(Path file, Set<Integer> data) throws IOException
    {
        Path tmp = file.resolveSibling(file.getFileName() + ".tmp");
        try (BufferedWriter w = Files.newBufferedWriter(tmp)) { gson.toJson(data, w); }
        safeMove(tmp, file, StandardCopyOption.ATOMIC_MOVE, StandardCopyOption.REPLACE_EXISTING);
        lastSelfWriteMs = System.currentTimeMillis();
    }

    private long safeLastModified(Path file)
    {
        try { return Files.getLastModifiedTime(file).toMillis(); } catch (IOException e) { return 0L; }
    }

    private Set<Integer> readLocalJson(Path file)
    {
        Set<Integer> local = new LinkedHashSet<>();
        if (!Files.exists(file)) return local;
        try (Reader r = Files.newBufferedReader(file))
        {
            Set<Integer> loaded = gson.fromJson(r, SET_TYPE);
            if (loaded != null) local.addAll(loaded);
        }
        catch (IOException e)
        {
            log.error("Error reading rolled items JSON", e);
        }
        return local;
    }

    private ConfigPersistence.StampedSet readCloud(String player)
    {
        try { return configPersistence.readStampedSet(player, CFG_KEY); }
        catch (Exception e) { return new ConfigPersistence.StampedSet(new LinkedHashSet<>(), 0L); }
    }

    private void closeWatchServiceQuietly()
    {
        try { if (watchService != null) watchService.close(); } catch (IOException ignored) {}
        watchService = null;
    }

    private void runWatcherLoop(String target)
    {
        long lastHandled = 0L;
        try
        {
            while (watcherRunning)
            {
                WatchKey key;
                try { key = watchService.take(); }
                catch (InterruptedException | ClosedWatchServiceException ie) { break; }

                boolean relevant = false;
                for (WatchEvent<?> ev : key.pollEvents())
                {
                    Object ctx = ev.context();
                    if (ctx instanceof Path && ((Path) ctx).getFileName().toString().equals(target))
                    {
                        relevant = true;
                    }
                }
                if (!key.reset()) break; // exit if key becomes invalid
                if (!relevant) continue;

                long now = System.currentTimeMillis();
                if (now - lastSelfWriteMs <= SELF_WRITE_GRACE_MS) continue;
                if (now - lastHandled < FS_DEBOUNCE_MS) continue;
                lastHandled = now;

                try
                {
                    reconcileWithCloud(true);
                    safeNotifyChange();
                }
                catch (Throwable t)
                {
                    log.error("Rolled watcher reconcile failed", t);
                }
            }
        }
        finally
        {
            closeWatchServiceQuietly();
            watcherRunning = false;
        }
    }

    /** Move with fallback when ATOMIC_MOVE not supported. */
    private void safeMove(Path source, Path target, CopyOption... opts) throws IOException
    {
        try { Files.move(source, target, opts); }
        catch (AtomicMoveNotSupportedException | AccessDeniedException ex)
        {
            Set<CopyOption> fallback = new HashSet<>(Arrays.asList(opts));
            fallback.remove(StandardCopyOption.ATOMIC_MOVE);
            fallback.add(StandardCopyOption.REPLACE_EXISTING);
            Files.move(source, target, fallback.toArray(new CopyOption[0]));
        }
    }

    /** Take a consistent snapshot under the set's monitor. */
    private Set<Integer> snapshotRolled() {
        synchronized (rolledItems) {
            return new LinkedHashSet<>(rolledItems);
        }
    }
}
package com.choicer.chanceman.managers;

import com.choicer.chanceman.account.AccountManager;
import com.choicer.chanceman.persist.ConfigPersistence;
import com.google.gson.Gson;
import com.google.gson.reflect.TypeToken;
import lombok.Setter;
import lombok.extern.slf4j.Slf4j;

import javax.inject.Inject;
import javax.inject.Singleton;
import java.io.BufferedWriter;
import java.io.IOException;
import java.io.Reader;
import java.lang.reflect.Type;
import java.nio.file.*;
import java.text.SimpleDateFormat;
import java.util.*;
import java.util.concurrent.ExecutorService;

import static net.runelite.client.RuneLite.RUNELITE_DIR;

@Slf4j
@Singleton
public class UnlockedItemsManager
{
    private static final int MAX_BACKUPS = 10;
    private static final String CFG_KEY = "unlocked";
    private static final String BACKUP_TS_PATTERN = "yyyyMMddHHmmss";
    private static final long CONFIG_DEBOUNCE_MS = 3000L;
    private static final long SELF_WRITE_GRACE_MS = 1500L;
    private static final long FS_DEBOUNCE_MS = 200L;
    private static final String FILE_NAME = "chanceman_unlocked.json";
    private static final Type SET_TYPE = new TypeToken<Set<Integer>>(){}.getType();
    private final Set<Integer> unlockedItems = Collections.synchronizedSet(new LinkedHashSet<>());
    @Inject private AccountManager accountManager;
    @Inject private Gson gson;
    @Inject private ConfigPersistence configPersistence;
    @Setter private ExecutorService executor; // file writes & cloud mirror
    @Setter private Runnable onChange;
    private volatile long lastConfigWriteMs = 0L;
    private volatile boolean configWriteWarned = false;
    private volatile boolean dirty = false;
    private WatchService watchService;
    private volatile boolean watcherRunning = false;
    private volatile long lastSelfWriteMs = 0L;
    private Thread watcherThread;

    public boolean ready() { return accountManager.getPlayerName() != null; }
    public boolean isUnlocked(int itemId) { return unlockedItems.contains(itemId); }

    /** Return an immutable snapshot to avoid leaking the synchronizedSet. */
    public Set<Integer> getUnlockedItems() {
        synchronized (unlockedItems) {
            return Collections.unmodifiableSet(new LinkedHashSet<>(unlockedItems));
        }
    }

    public void unlockItem(int itemId)
    {
        if (unlockedItems.add(itemId))
        {
            dirty = true;
            saveUnlockedItems();
            safeNotifyChange();
        }
    }

    public void loadUnlockedItems()
    {
        reconcileWithCloud(false);
        safeNotifyChange();
    }

    /** Normal save: disk + debounced cloud with current time. */
    public void saveUnlockedItems()
    {
        saveInternal(System.currentTimeMillis(), true);
    }

    /** Live-reload: start watching the JSON for CREATE/MODIFY/DELETE. */
    public void startWatching()
    {
        if (watcherRunning) return;
        Path file = safeGetFilePathOrNull();
        if (file == null) return;

        try
        {
            watchService = FileSystems.getDefault().newWatchService();
            file.getParent().register(
                    watchService,
                    StandardWatchEventKinds.ENTRY_CREATE,
                    StandardWatchEventKinds.ENTRY_MODIFY,
                    StandardWatchEventKinds.ENTRY_DELETE
            );
        }
        catch (IOException e)
        {
            closeWatchServiceQuietly();
            log.error("Unlocked watcher: could not register", e);
            return;
        }

        watcherRunning = true;
        final String target = file.getFileName().toString();

        watcherThread = new Thread(() -> runWatcherLoop(target), "ChanceMan-Unlocked-Watcher");
        watcherThread.setDaemon(true);
        watcherThread.start();
    }

    public void stopWatching()
    {
        watcherRunning = false;
        if (watcherThread != null) watcherThread.interrupt();
        closeWatchServiceQuietly();
        watcherThread = null;
    }

    /** Flush synchronously on shutdown if dirty. */
    public void flushIfDirtyOnExit()
    {
        if (!dirty) return;
        Path file = safeGetFilePathOrNull();
        if (file == null) return;

        try
        {
            rotateBackupIfExists(file);
            Set<Integer> snap = snapshotUnlocked();
            writeJsonAtomic(file, snap);
            mirrorToCloud(System.currentTimeMillis(), false, snap);
            dirty = false;
        }
        catch (IOException e)
        {
            log.error("Shutdown flush failed for unlocked items (local saves may be stale).", e);
        }
        catch (Exception e)
        {
            log.error("Shutdown flush: failed to mirror unlocked set to ConfigManager.", e);
        }
    }

    private void reconcileWithCloud(boolean runtime)
    {
        String player = accountManager.getPlayerName();
        if (player == null) return;

        Path file = safeGetFilePathOrNull();
        if (file == null) return;

        boolean fileExisted = Files.exists(file);
        Set<Integer> local = readLocalJson(file);
        long localMtime = fileExisted ? safeLastModified(file) : 0L;

        ConfigPersistence.StampedSet cloudStamped = readCloud(player);
        Set<Integer> cloud = new LinkedHashSet<>(cloudStamped.data);
        long cloudTs = cloudStamped.ts;

        // LWW
        Set<Integer> winner;
        Long winnerStamp = null;
        boolean needPersist;

        if (localMtime > cloudTs) { winner = local;  winnerStamp = localMtime; needPersist = true; } // push to cloud
        else if (cloudTs > localMtime) { winner = cloud;  winnerStamp = cloudTs;    needPersist = true; } // pull to disk
        else { winner = local;  needPersist = !fileExisted; } // create disk if missing

        synchronized (unlockedItems) {
            unlockedItems.clear();
            unlockedItems.addAll(winner);
        }

        if (needPersist)
        {
            long stamp = (winnerStamp != null) ? winnerStamp : System.currentTimeMillis();
            saveInternal(stamp, false); // bypass debounce during reconcile
        }
        dirty = false;
    }

    /** Disk write + cloud mirror (debounced or immediate). */
    private void saveInternal(long stampMillis, boolean debounced)
    {
        if (!isExecutorAvailable())
        {
            log.error("UnlockedItemsManager: executor unavailable; skipping save");
            return;
        }

        executor.submit(() -> {
            Path file = safeGetFilePathOrNull();
            if (file == null)
            {
                log.error("UnlockedItemsManager: file path unavailable; skipping save");
                return;
            }
            try
            {
                rotateBackupIfExists(file);
                Set<Integer> snap = snapshotUnlocked();
                writeJsonAtomic(file, snap);
                mirrorToCloud(stampMillis, debounced, snap);
                dirty = false;
            }
            catch (IOException e)
            {
                log.error("Error saving unlocked items", e);
            }
        });
    }

    /** Mirror to cloud, optionally debounced; uses provided snapshot to avoid re-locking. */
    private void mirrorToCloud(long stampMillis, boolean debounced, Set<Integer> snapshot)
    {
        long now = System.currentTimeMillis();
        if (debounced && (now - lastConfigWriteMs < CONFIG_DEBOUNCE_MS)) return;
        lastConfigWriteMs = now;

        String player = accountManager.getPlayerName();
        if (player == null || player.isEmpty() || executor == null) return;

        final Set<Integer> snap = (snapshot != null) ? snapshot : snapshotUnlocked();
        executor.submit(() -> {
            try
            {
                // Guard against out-of-order writes across machines/threads
                configPersistence.writeStampedSetIfNewer(player, CFG_KEY, snap, stampMillis);
            }
            catch (Exception e)
            {
                if (!configWriteWarned)
                {
                    configWriteWarned = true;
                    log.error("ChanceMan: failed to mirror unlocked set to ConfigManager (local saves intact).", e);
                }
            }
        });
    }

    private boolean isExecutorAvailable()
    {
        if (executor == null) return false;
        if (executor instanceof java.util.concurrent.ThreadPoolExecutor) {
            java.util.concurrent.ThreadPoolExecutor tpe =
                    (java.util.concurrent.ThreadPoolExecutor) executor;
            return !tpe.isShutdown() && !tpe.isTerminated();
        }
        return true;
    }

    private void safeNotifyChange()
    {
        Runnable cb = onChange;
        if (cb != null) { try { cb.run(); } catch (Throwable t) { log.error("onChange threw", t); } }
    }

    private Path getFilePath() throws IOException
    {
        String name = accountManager.getPlayerName();
        if (name == null) throw new IOException("Player name is null");
        Path dir = RUNELITE_DIR.toPath().resolve("chanceman").resolve(name);
        Files.createDirectories(dir);
        return dir.resolve(FILE_NAME);
    }

    private Path safeGetFilePathOrNull()
    {
        try { return getFilePath(); } catch (IOException ioe) { return null; }
    }

    /** Windows-safe: COPY current file to a timestamped backup with small retries; then prune. */
    private void rotateBackupIfExists(Path file) throws IOException
    {
        if (!Files.exists(file)) return;

        Path backups = file.getParent().resolve("backups");
        Files.createDirectories(backups);

        String ts = new SimpleDateFormat(BACKUP_TS_PATTERN).format(new Date());
        Path bak = backups.resolve(file.getFileName() + "." + ts + ".bak");

        final int maxAttempts = 5;
        for (int attempt = 1; ; attempt++)
        {
            try
            {
                Files.copy(file, bak, StandardCopyOption.REPLACE_EXISTING);
                break;
            }
            catch (FileSystemException fse)
            {
                if (attempt >= maxAttempts)
                {
                    log.error("Backup copy failed after {} attempts for {}", attempt, file, fse);
                    break; // give up on backup, continue save
                }
                try { Thread.sleep(50L * attempt); } catch (InterruptedException ie) { Thread.currentThread().interrupt(); break; }
            }
        }

        try (java.util.stream.Stream<Path> stream = Files.list(backups))
        {
            stream
                    .filter(p -> p.getFileName().toString().startsWith(file.getFileName() + "."))
                    .sorted(Comparator.comparing(Path::getFileName).reversed())
                    .skip(MAX_BACKUPS)
                    .forEach(p -> { try { Files.deleteIfExists(p); } catch (IOException ignored) {} });
        }
    }

    /** Write JSON to .tmp and atomically replace the main file; mark self-write for watcher echo suppression. */
    private void writeJsonAtomic(Path file, Set<Integer> data) throws IOException
    {
        Path tmp = file.resolveSibling(file.getFileName() + ".tmp");
        try (BufferedWriter w = Files.newBufferedWriter(tmp)) { gson.toJson(data, w); }
        safeMove(tmp, file, StandardCopyOption.ATOMIC_MOVE, StandardCopyOption.REPLACE_EXISTING);
        lastSelfWriteMs = System.currentTimeMillis(); // mark AFTER swap
    }

    private long safeLastModified(Path file)
    {
        try { return Files.getLastModifiedTime(file).toMillis(); } catch (IOException e) { return 0L; }
    }

    private Set<Integer> readLocalJson(Path file)
    {
        Set<Integer> local = new LinkedHashSet<>();
        if (!Files.exists(file)) return local;
        try (Reader r = Files.newBufferedReader(file))
        {
            Set<Integer> loaded = gson.fromJson(r, SET_TYPE);
            if (loaded != null) local.addAll(loaded);
        }
        catch (IOException e)
        {
            log.error("Error reading unlocked items JSON", e);
        }
        return local;
    }

    private ConfigPersistence.StampedSet readCloud(String player)
    {
        try { return configPersistence.readStampedSet(player, CFG_KEY); }
        catch (Exception e) { return new ConfigPersistence.StampedSet(new LinkedHashSet<>(), 0L); }
    }

    private void closeWatchServiceQuietly()
    {
        try { if (watchService != null) watchService.close(); } catch (IOException ignored) {}
        watchService = null;
    }

    private void runWatcherLoop(String target)
    {
        long lastHandled = 0L;
        try
        {
            while (watcherRunning)
            {
                WatchKey key;
                try { key = watchService.take(); }
                catch (InterruptedException | ClosedWatchServiceException ie) { break; }

                boolean relevant = false;
                for (WatchEvent<?> ev : key.pollEvents())
                {
                    Object ctx = ev.context();
                    if (ctx instanceof Path && ((Path) ctx).getFileName().toString().equals(target))
                    {
                        relevant = true;
                    }
                }
                if (!key.reset()) break; // exit if key becomes invalid
                if (!relevant) continue;

                long now = System.currentTimeMillis();
                if (now - lastSelfWriteMs <= SELF_WRITE_GRACE_MS) continue; // our own write
                if (now - lastHandled < FS_DEBOUNCE_MS) continue;
                lastHandled = now;

                try
                {
                    reconcileWithCloud(true);
                    safeNotifyChange();
                }
                catch (Throwable t)
                {
                    log.error("Unlocked watcher reconcile failed", t);
                }
            }
        }
        finally
        {
            closeWatchServiceQuietly();
            watcherRunning = false;
        }
    }

    /** Move with fallback when ATOMIC_MOVE not supported. */
    private void safeMove(Path source, Path target, CopyOption... opts) throws IOException
    {
        try
        {
            Files.move(source, target, opts);
        }
        catch (AtomicMoveNotSupportedException | AccessDeniedException ex)
        {
            Set<CopyOption> fallback = new HashSet<>(Arrays.asList(opts));
            fallback.remove(StandardCopyOption.ATOMIC_MOVE);
            fallback.add(StandardCopyOption.REPLACE_EXISTING);
            Files.move(source, target, fallback.toArray(new CopyOption[0]));
        }
    }

    /** Take a consistent snapshot under the set's monitor. */
    private Set<Integer> snapshotUnlocked() {
        synchronized (unlockedItems) {
            return new LinkedHashSet<>(unlockedItems);
        }
    }
}

package com.choicer.chanceman;

import com.choicer.chanceman.filters.QuestItemAllowlist;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.ItemComposition;
import net.runelite.api.Point;
import net.runelite.client.audio.AudioPlayer;
import net.runelite.client.game.ItemManager;
import net.runelite.client.ui.overlay.Overlay;
import net.runelite.client.ui.overlay.OverlayLayer;
import net.runelite.client.ui.overlay.OverlayPosition;
import net.runelite.client.util.ImageUtil;

import javax.inject.Inject;
import javax.inject.Singleton;
import javax.sound.sampled.LineUnavailableException;
import javax.sound.sampled.UnsupportedAudioFileException;
import java.awt.*;
import java.awt.geom.Ellipse2D;
import java.awt.geom.Point2D;
import java.awt.geom.RoundRectangle2D;
import java.awt.image.BufferedImage;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashSet;
import java.util.List;
import java.util.Random;
import java.util.Set;
import java.util.concurrent.CompletableFuture;
import java.awt.event.MouseEvent;
import java.util.function.Supplier;

/**
 * Alternate overlay used when Choiceman mode is enabled.
 * Presents the roll strip vertically with a configurable number of visible slots.
 */
@Singleton
@Slf4j
public class ChoicemanOverlay extends Overlay implements RollOverlay
{
    private static final float SNAP_NEXT_THRESHOLD = 0.55f;
    private static final long SNAP_DURATION_MS = 350L;
    private static final long HIGHLIGHT_DURATION_MS = 3000L;
    private static final float INITIAL_SPEED = 820f;
    private static final float MIN_SPEED = 95f;
    private static final float MAX_DT = 0.05f;

    private static final int ICON_W = 32;
    private static final int ICON_H = 32;
    private static final int SPACING = 5;

    private static final int FRAME_CONTENT_INSET = 2;
    private static final int SLOT_PADDING_X = 10;
    private static final int SLOT_PADDING_Y = 8;
    private static final int SELECTION_TOP_MARGIN = 15;
    private static final float CHOICE_SLOT_SCALE = 1.0f;
    private static final int MIN_CHOICE_SLOT_WIDTH = 110;
    private static final int MIN_CHOICE_SLOT_HEIGHT = 80;
    // Keep scroll slots as wide as the eventual choice buttons so icon centers align.
    private static final int MIN_SCROLL_SLOT_WIDTH = MIN_CHOICE_SLOT_WIDTH;
    private static final int SCROLL_ICON_TARGET = 48;
    private static final int SCROLL_ICON_TARGET_COMPACT = 36;
    private static final int SCROLL_ITEM_GAP = 6;
    private static final float DEFAULT_STEP = SCROLL_ICON_TARGET + SCROLL_ITEM_GAP;
    private static final Color SLOT_BORDER = new Color(201, 168, 92, 230);
    private static final Color SLOT_FILL_TOP = new Color(22, 22, 22, 235);
    private static final Color SLOT_FILL_BOTTOM = new Color(10, 10, 10, 235);
    private static final Font LABEL_FONT = new Font("SansSerif", Font.BOLD, 11);
    private static final Color TRADEABLE_GLOW_INNER = new Color(255, 255, 160, 150);
    private static final Color TRADEABLE_GLOW_OUTER = new Color(255, 255, 160, 0);
    private static final Color UNTRADEABLE_GLOW_INNER = new Color(140, 210, 255, 160);
    private static final Color UNTRADEABLE_GLOW_OUTER = new Color(140, 210, 255, 0);
    private static final Color[] TRADEABLE_GLOW = new Color[]{TRADEABLE_GLOW_INNER, TRADEABLE_GLOW_OUTER};
    private static final Color[] UNTRADEABLE_GLOW = new Color[]{UNTRADEABLE_GLOW_INNER, UNTRADEABLE_GLOW_OUTER};

    private static final int ICON_COUNT = 3;
    private static final int DRAW_COUNT = ICON_COUNT + 1;
    // Ensure scroll frames mirror the spacing seen in the final choice buttons.
    private static final int COLUMN_SPACING = 24;
    private static final int VISIBLE_ROLLING_ITEM_COUNT = 3;
    private static final int CHOICE_BUTTON_CORNER_RADIUS = 12;
    private static final int CHOICE_BUTTON_INSET = 6;
    private static final int CHOICE_BUTTON_VERTICAL_OFFSET = 10;
    private static final Color CHOICE_BUTTON_FILL_TOP = new Color(28, 28, 28, 235);
    private static final Color CHOICE_BUTTON_FILL_BOTTOM = new Color(10, 10, 10, 235);
    private static final Color CHOICE_BUTTON_BORDER = SLOT_BORDER;
    private static final Color CHOICE_BUTTON_BORDER_HOVER = new Color(255, 220, 140, 245);
    private static final Color CHOICE_BUTTON_BORDER_INNER = new Color(30, 30, 30, 210);
    private static final Color CHOICE_BUTTON_SHADOW = new Color(0, 0, 0, 90);

    private final Client client;
    private final ItemManager itemManager;

    private final List<List<Integer>> rollingColumns = Collections.synchronizedList(new ArrayList<>());
    private final float[] columnOffsetAdjust = new float[5];
    private final float[] columnSpeedScale = new float[5];
    private final Random spinRandom = new Random();
    private final Set<Integer> uniqueRollItems = Collections.synchronizedSet(new HashSet<>());

    @Inject private AudioPlayer audioPlayer;
    @Inject private ChanceManConfig config;

    private final BufferedImage iconFrameImage =
            ImageUtil.loadImageResource(getClass(), "/com/choicer/chanceman/icon_slot.png");

    private volatile boolean isAnimating = false;
    private long rollDurationMs;
    private long rollStartMs = 0L;

    private float rollOffset = 0f;
    private float currentSpeed = INITIAL_SPEED;
    private Supplier<Integer> randomLockedItemSupplier;
    private long lastUpdateNanos = 0L;

    private boolean isSnapping = false;
    private long snapStartMs = 0L;
    private float snapBase;
    private float snapResidualStart;
    private float snapTarget;
    private int winnerDelta = 0;
    private int columnCount = 2;
    private final List<Rectangle> columnHitboxes = new ArrayList<>();
    private volatile boolean selectionPending = false;

    private List<Integer> currentOptions = Collections.emptyList();

    public void setChoicemanOptions(List<Integer> options)
    {
        if (options == null)
        {
            currentOptions = Collections.emptyList();
        }
        else
        {
            currentOptions = new ArrayList<>(options);
        }
        columnCount = determineColumnCount();
        for (int i = 0; i < columnOffsetAdjust.length; i++)
        {
            columnOffsetAdjust[i] = spinRandom.nextFloat() * DEFAULT_STEP;
            columnSpeedScale[i] = 0.75f + spinRandom.nextFloat() * 0.45f; // 0.75x – 1.2x
        }
    }

    private int determineColumnCount()
    {
        if (currentOptions == null || currentOptions.isEmpty())
        {
            return 2;
        }
        int capped = Math.max(2, Math.min(5, currentOptions.size()));
        if (currentOptions.size() > capped)
        {
            currentOptions = new ArrayList<>(currentOptions.subList(0, capped));
        }
        return capped;
    }

    public void setSelectionPending(boolean pending)
    {
        this.selectionPending = pending;
        if (pending)
        {
            syncSelectionOptionsWithColumns();
        }
        else
        {
            synchronized (columnHitboxes)
            {
                columnHitboxes.clear();
            }
        }
    }

    public boolean isSelectionPending()
    {
        return selectionPending;
    }

    public Integer getOptionAt(int x, int y)
    {
        synchronized (columnHitboxes)
        {
            for (int i = 0; i < columnHitboxes.size(); i++)
            {
                Rectangle rect = columnHitboxes.get(i);
                RoundRectangle2D.Float buttonShape = new RoundRectangle2D.Float(
                    rect.x,
                    rect.y,
                    rect.width,
                    rect.height,
                    CHOICE_BUTTON_CORNER_RADIUS,
                    CHOICE_BUTTON_CORNER_RADIUS
                );
                if (buttonShape.contains(x, y) && i < currentOptions.size())
                {
                    return currentOptions.get(i);
                }
            }
        }
        return null;
    }

    /**
     * Exposes the current hitboxes for tests without leaking the internal list.
     */
    List<Rectangle> getCurrentHitboxes()
    {
        synchronized (columnHitboxes)
        {
            List<Rectangle> copy = new ArrayList<>(columnHitboxes.size());
            for (Rectangle rect : columnHitboxes)
            {
                copy.add(new Rectangle(rect));
            }
            return copy;
        }
    }

    private void syncSelectionOptionsWithColumns()
    {
        List<Integer> snapped = captureSnappedItems();
        if (!snapped.isEmpty())
        {
            currentOptions = snapped;
        }
    }

    private List<Integer> captureSnappedItems()
    {
        List<Integer> snapped = new ArrayList<>();
        synchronized (rollingColumns)
        {
            if (rollingColumns.isEmpty())
            {
                return snapped;
            }
            final int centerIndex = ICON_COUNT / 2;
            final int columns = Math.min(columnCount, rollingColumns.size());
            for (int col = 0; col < columns; col++)
            {
                List<Integer> column = rollingColumns.get(col);
                if (column.isEmpty())
                {
                    snapped.add(0);
                    continue;
                }
                final int winnerIndex = Math.min(centerIndex + winnerDelta, column.size() - 1);
                if (winnerIndex >= 0 && winnerIndex < column.size())
                {
                    snapped.add(column.get(winnerIndex));
                }
                else
                {
                    snapped.add(0);
                }
            }
        }
        return snapped;
    }

    /**
     * Allows tests (or other non-DI contexts) to provide a config instance.
     */
    public void setConfig(ChanceManConfig config)
    {
        this.config = config;
    }

    @Inject
    public ChoicemanOverlay(Client client, ItemManager itemManager)
    {
        this.client = client;
        this.itemManager = itemManager;
        setPosition(OverlayPosition.DYNAMIC);
        setLayer(OverlayLayer.ABOVE_WIDGETS);
    }

    private static float toDb(int percent) {
        int p = Math.max(0, Math.min(100, percent));
        if (p == 0) {
            return -80.0f;
        }
        double lin = p / 100.0;
        return (float) (20.0 * Math.log10(lin));
    }

    @Override
    public void startRollAnimation(int dummy, int rollDurationMs, Supplier<Integer> randomLockedItemSupplier)
    {
        setSelectionPending(false);
        if (config.enableRollSounds()) {
            try {
                float volumeDb = toDb(config.rollSoundVolume());
                audioPlayer.play(ChoicemanOverlay.class, "/com/choicer/chanceman/tick.wav", volumeDb);
            } catch (IOException | UnsupportedAudioFileException | LineUnavailableException ex) {
                log.warn("Choiceman: failed to play tick.wav", ex);
            }
        }

        columnCount = determineColumnCount();

        this.rollDurationMs = rollDurationMs;
        this.rollStartMs = System.currentTimeMillis();
        this.rollOffset = 0f;
        this.currentSpeed = INITIAL_SPEED;
        this.randomLockedItemSupplier = randomLockedItemSupplier;
        this.isAnimating = true;
        this.lastUpdateNanos = System.nanoTime();

        this.isSnapping = false;
        this.snapStartMs = 0L;
        this.snapBase = 0f;
        this.snapResidualStart = 0f;
        this.snapTarget = 0f;
        this.winnerDelta = 0;
        uniqueRollItems.clear();

        synchronized (rollingColumns) {
            rollingColumns.clear();
            for (int c = 0; c < columnCount; c++)
            {
                List<Integer> column = new ArrayList<>();
                for (int i = 0; i < DRAW_COUNT; i++) {
                    column.add(nextUniqueRollItem());
                }
                rollingColumns.add(column);
            }
        }
    }

    @Override
    public int getFinalItem()
    {
        if (!currentOptions.isEmpty())
        {
            return currentOptions.get(0);
        }
        synchronized (rollingColumns) {
            if (rollingColumns.isEmpty()) {
                return 0;
            }
            List<Integer> firstColumn = rollingColumns.get(0);
            int centerIndex = ICON_COUNT / 2;
            int idx = Math.min(centerIndex + winnerDelta, firstColumn.size() - 1);
            if (idx >= 0 && idx < firstColumn.size()) {
                return firstColumn.get(idx);
            }
        }
        return 0;
    }

    @Override
    public int getHighlightDurationMs()
    {
        return (int) HIGHLIGHT_DURATION_MS;
    }

    @Override
    public void stopAnimation()
    {
        isAnimating = false;
    }

    @Override
    public Dimension render(Graphics2D g)
    {
        if (!isAnimating && !selectionPending) {
            return null;
        }
        
        final Shape oldClip = g.getClip();

        g.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);
        g.setRenderingHint(RenderingHints.KEY_INTERPOLATION, RenderingHints.VALUE_INTERPOLATION_BILINEAR);

        final long nowMs = System.currentTimeMillis();
        final long elapsed = nowMs - rollStartMs;
        final boolean clickableSelection = selectionPending && !currentOptions.isEmpty();
        final boolean highlightPhase = clickableSelection || (elapsed > rollDurationMs);

        if (clickableSelection && currentOptions.size() < columnCount)
        {
            syncSelectionOptionsWithColumns();
        }

        if (!clickableSelection && elapsed > rollDurationMs + HIGHLIGHT_DURATION_MS) {
            isAnimating = false;
            return null;
        }

        final long nowNanos = System.nanoTime();
        float dt = 0f;
        if (lastUpdateNanos != 0L) {
            dt = (nowNanos - lastUpdateNanos) / 1_000_000_000f;
            if (dt > MAX_DT) dt = MAX_DT;
        }
        lastUpdateNanos = nowNanos;

        if (!highlightPhase) {
            final float t = (rollDurationMs > 0) ? Math.min(1f, elapsed / (float) rollDurationMs) : 1f;
            final float eased = (float) Math.pow(1f - t, 3);
            currentSpeed = MIN_SPEED + (INITIAL_SPEED - MIN_SPEED) * eased;
        }

        final int vpX = client.getViewportXOffset();
        final int vpY = client.getViewportYOffset();
        final int vpWidth = client.getViewportWidth();
        final int centerX = vpX + (vpWidth / 2);

        final float slotScale = CHOICE_SLOT_SCALE;
        final int baseSlotWidth = ICON_W + SLOT_PADDING_X * 2;
        final int baseSlotHeight = ICON_H + SLOT_PADDING_Y * 2;
        final int rollingVisibleItems = Math.max(2, VISIBLE_ROLLING_ITEM_COUNT);
        final float iconTargetSize = clickableSelection ? SCROLL_ICON_TARGET : SCROLL_ICON_TARGET_COMPACT;
        final int rollingContentSpan = Math.round(
                iconTargetSize * rollingVisibleItems
                        + SCROLL_ITEM_GAP * (rollingVisibleItems - 1)
        );
        final int minSlotWidth = clickableSelection ? MIN_CHOICE_SLOT_WIDTH : MIN_SCROLL_SLOT_WIDTH;
        final int slotWidth = Math.max(Math.round(baseSlotWidth * slotScale), minSlotWidth);
        final int scaledSlotHeight = Math.max(Math.round(baseSlotHeight * slotScale), MIN_CHOICE_SLOT_HEIGHT);
        final int slotHeight = Math.max(scaledSlotHeight, rollingContentSpan + SLOT_PADDING_Y * 2);
        final int spacing = Math.max(14, Math.round(COLUMN_SPACING * slotScale));
        final int totalWidth = columnCount * slotWidth + (columnCount - 1) * spacing;
        final int slotsLeftX = centerX - ( totalWidth / 2 );
        final int slotTopY = vpY + SELECTION_TOP_MARGIN;

        final float middleIndex = (ICON_COUNT - 1) / 2f;
        final float scrollGap = SCROLL_ITEM_GAP;
        final float maxIconWidth = slotWidth - SLOT_PADDING_X * 2f;
        final float maxIconHeight = (slotHeight - SLOT_PADDING_Y * 2f - (rollingVisibleItems - 1) * scrollGap) / rollingVisibleItems;
        final float rollingIconSize = Math.max(ICON_W, Math.min(maxIconWidth, maxIconHeight));
        final int iconSize = Math.max(1, Math.round(rollingIconSize));
        final float activeStep = iconSize + scrollGap;
        final int iconPadX = Math.max(SLOT_PADDING_X, (slotWidth - iconSize) / 2);
        final int iconPadY = SLOT_PADDING_Y;
        final int rollingContentHeight = slotHeight - iconPadY * 2;
        final float contentCenterY = slotTopY + iconPadY + rollingContentHeight / 2f;
        final float iconsTopYF = contentCenterY - middleIndex * activeStep - iconSize / 2f;
        final int[] columnXs = new int[columnCount];
        for (int col = 0; col < columnCount; col++)
        {
            columnXs[col] = slotsLeftX + col * (slotWidth + spacing);
        }

        final int centerIndex = ICON_COUNT / 2;
        final int innerBoxXInset = FRAME_CONTENT_INSET;
        final int innerBoxYInset = FRAME_CONTENT_INSET;
        final int innerBoxW = iconSize - innerBoxXInset * 2;
        final int innerBoxH = iconSize - innerBoxYInset * 2;

        if (!clickableSelection)
        {
            for (int col = 0; col < columnCount; col++)
            {
                drawSlotWindow(g, columnXs[col], slotTopY, slotWidth, slotHeight, slotScale);
            }

            for (int col = 0; col < columnCount; col++)
            {
                float adjust = columnOffsetAdjust[col];
                if (!highlightPhase && !isSnapping)
                {
                    adjust += (columnSpeedScale[col] - 1f) * currentSpeed * dt;
                    adjust = normalizeStep(adjust, activeStep);
                }
                else if (isSnapping)
                {
                    adjust *= 0.82f;
                    if (Math.abs(adjust) < 0.01f)
                    {
                        adjust = 0f;
                    }
                }
                else if (highlightPhase)
                {
                    adjust *= 0.9f;
                    if (Math.abs(adjust) < 0.01f)
                    {
                        adjust = 0f;
                    }
                }
                columnOffsetAdjust[col] = adjust;
            }

            g.setClip(slotsLeftX, slotTopY, totalWidth, slotHeight);

            synchronized (columnHitboxes)
            {
                columnHitboxes.clear();
            }

            synchronized (rollingColumns)
            {
                if (!highlightPhase && !isSnapping && (rollStartMs + rollDurationMs - nowMs) <= SNAP_DURATION_MS) {
                    isSnapping = true;
                    snapStartMs = nowMs;

                    final float k = (float) Math.floor(rollOffset / activeStep);
                    snapBase = k * activeStep;
                    snapResidualStart = rollOffset - snapBase;
                    final boolean goNext = (snapResidualStart / activeStep) >= SNAP_NEXT_THRESHOLD;
                    winnerDelta = goNext ? 1 : 0;
                    snapTarget = goNext ? (snapBase + activeStep) : snapBase;
                }

                if (!highlightPhase) {
                    if (isSnapping) {
                        final float u = Math.min(1f, (nowMs - snapStartMs) / (float) SNAP_DURATION_MS);
                        final float s = u * u * (3f - 2f * u);
                        final float start = rollOffset;
                        final float end = snapTarget;
                        rollOffset = start + (end - start) * s;

                        if (rollOffset >= activeStep) {
                            normalizeOnce(activeStep);
                            winnerDelta = 0;
                            snapBase = 0f;
                            snapTarget = 0f;
                            snapResidualStart = 0f;
                        }
                    } else {
                        rollOffset += currentSpeed * dt;
                        while (rollOffset >= activeStep) {
                            normalizeOnce(activeStep);
                        }
                    }
                } else if (isSnapping) {
                    rollOffset = snapTarget;
                    if (rollOffset >= activeStep) {
                        normalizeOnce(activeStep);
                        winnerDelta = 0;
                    }
                }

                for (int col = 0; col < columnCount; col++)
                {
                    List<Integer> column = col < rollingColumns.size() ? rollingColumns.get(col) : Collections.emptyList();
                    final int iconsX = columnXs[col] + iconPadX;
                    final int itemsToDraw = Math.min(column.size(), DRAW_COUNT);
                    for (int i = 0; i < itemsToDraw; i++) {
                        final int itemId = column.get(i);
                        final BufferedImage image = itemManager.getImage(itemId, 1, false);
                        if (image == null) continue;

                        final float columnOffset = rollOffset + columnOffsetAdjust[col];
                        final float drawYF = iconsTopYF + i * activeStep - columnOffset;
                        final int drawY = Math.round(drawYF);

                        if (iconFrameImage != null) {
                            g.drawImage(iconFrameImage, iconsX, drawY, iconSize, iconSize, null);
                        }

                        final int x = iconsX + innerBoxXInset;
                        final int y = drawY + innerBoxYInset;
                        g.drawImage(image, x, y, innerBoxW, innerBoxH, null);
                    }
                }

                if (highlightPhase) {
                    for (int col = 0; col < columnCount; col++)
                    {
                        List<Integer> column = col < rollingColumns.size() ? rollingColumns.get(col) : Collections.emptyList();
                        final int winnerIndex = Math.min(centerIndex + winnerDelta, column.size() - 1);
                        if (winnerIndex < 0 || winnerIndex >= column.size())
                        {
                            continue;
                        }

                        final int centerItemId = column.get(winnerIndex);
                        final float columnOffset = rollOffset + columnOffsetAdjust[col];
                        final float columnBaseF = iconsTopYF + centerIndex * activeStep - columnOffset;
                        final int columnBaseY = Math.round(columnBaseF);
                        drawHighlight(g, columnXs[col] + iconPadX, columnBaseY, centerItemId, iconSize, false);
                        if (clickableSelection && col < currentOptions.size()) {
                            final int iconX = columnXs[col] + iconPadX;
                            final int iconY = columnBaseY;
                            Rectangle rect = new Rectangle(iconX, iconY, iconSize, iconSize);
                            synchronized (columnHitboxes) {
                                columnHitboxes.add(rect);
                            }
                        }
                    }
                }
            }
        }
        else
        {
            renderSelectionButtons(g, columnXs, slotTopY, slotWidth, slotHeight, iconSize, iconPadX);
        }

        g.setClip(oldClip);

        if (clickableSelection)
        {
            Point mouse = client.getMouseCanvasPosition();
            if (mouse != null)
            {
                Integer hoveredItem = getOptionAt(mouse.getX(), mouse.getY());
                if (hoveredItem != null)
                {
                    String hoverText = buildHoverText(hoveredItem);
                    if (!hoverText.isEmpty())
                    {
                        drawHoverTooltip(g, hoverText, mouse, oldClip);
                    }
                }
            }
            return new Dimension(totalWidth, slotHeight);
        }
        return null;
    }

    private void renderSelectionButtons(
            Graphics2D g,
            int[] columnXs,
            int topY,
            int slotWidth,
            int slotHeight,
            int iconSize,
            int iconPadX)
    {
        List<Integer> optionsSnapshot = currentOptions == null
                ? Collections.emptyList()
                : new ArrayList<>(currentOptions);
        final int availableSlots = columnXs == null ? 0 : columnXs.length;
        final int drawCount = Math.min(optionsSnapshot.size(), availableSlots);
        if (drawCount <= 0)
        {
            synchronized (columnHitboxes)
            {
                columnHitboxes.clear();
            }
            return;
        }

        List<Rectangle> buttonRects = new ArrayList<>(drawCount);
        List<Rectangle> hitboxRects = new ArrayList<>(drawCount);
        List<Rectangle> iconRects = new ArrayList<>(drawCount);
        final int insetX = CHOICE_BUTTON_INSET;
        final int insetY = CHOICE_BUTTON_INSET;
        final int slotBottom = topY + slotHeight - insetY;
        final int iconPaddingTop = 14;
        final int iconPaddingBottom = 14;
        final int iconY = topY + (slotHeight - iconSize) / 2 - CHOICE_BUTTON_VERTICAL_OFFSET;
        for (int i = 0; i < drawCount; i++)
        {
            final int iconX = columnXs[i] + iconPadX;
            Rectangle iconRect = new Rectangle(iconX, iconY, iconSize, iconSize);
            iconRects.add(iconRect);

            final int buttonTop = Math.max(topY + insetY, iconY - iconPaddingTop);
            final int buttonBottom = Math.min(slotBottom, iconY + iconSize + iconPaddingBottom);
            int x = columnXs[i] + insetX;
            int y = buttonTop;
            int width = Math.max(1, slotWidth - insetX * 2);
            int height = Math.max(1, buttonBottom - buttonTop);

            Rectangle drawRect = new Rectangle(x, y, width, height);
            buttonRects.add(drawRect);

            hitboxRects.add(drawRect);
        }

        Point mouse = client.getMouseCanvasPosition();
        int hoveredIndex = -1;
        if (mouse != null)
        {
            for (int i = 0; i < buttonRects.size(); i++)
            {
                Rectangle rect = buttonRects.get(i);
                RoundRectangle2D.Float buttonShape = new RoundRectangle2D.Float(
                    rect.x,
                    rect.y,
                    rect.width,
                    rect.height,
                    CHOICE_BUTTON_CORNER_RADIUS,
                    CHOICE_BUTTON_CORNER_RADIUS
                );
                if (buttonShape.contains(new java.awt.Point(mouse.getX(), mouse.getY())))
                {
                    hoveredIndex = i;
                    break;
                }
            }
        }

        synchronized (columnHitboxes)
        {
            columnHitboxes.clear();
            columnHitboxes.addAll(hitboxRects);
        }

        for (int i = 0; i < drawCount; i++)
        {
            boolean hovered = (i == hoveredIndex);
            drawChoiceButton(g, buttonRects.get(i), iconRects.get(i), optionsSnapshot.get(i), hovered);
        }
    }

    private void drawChoiceButton(
            Graphics2D g,
            Rectangle rect,
            Rectangle iconRect,
            int itemId,
            boolean hovered)
    {
        Paint previousPaint = g.getPaint();
        Stroke previousStroke = g.getStroke();
        Composite previousComposite = g.getComposite();

        final float cornerRadius = CHOICE_BUTTON_CORNER_RADIUS;
        RoundRectangle2D.Float buttonShape = new RoundRectangle2D.Float(
                rect.x,
                rect.y,
                rect.width,
                rect.height,
                cornerRadius,
                cornerRadius
        );

        RoundRectangle2D.Float shadowShape = new RoundRectangle2D.Float(
                rect.x + 1,
                rect.y + 3,
                rect.width,
                rect.height,
                cornerRadius + 4,
                cornerRadius + 4
        );
        g.setColor(CHOICE_BUTTON_SHADOW);
        g.fill(shadowShape);

        Color top = hovered
                ? blendColors(CHOICE_BUTTON_FILL_TOP, Color.WHITE, 0.15f)
                : CHOICE_BUTTON_FILL_TOP;
        Color bottom = hovered
                ? blendColors(CHOICE_BUTTON_FILL_BOTTOM, Color.WHITE, 0.12f)
                : CHOICE_BUTTON_FILL_BOTTOM;
        GradientPaint paint = new GradientPaint(
                rect.x,
                rect.y,
                top,
                rect.x,
                rect.y + rect.height,
                bottom
        );
        g.setPaint(paint);
        g.fill(buttonShape);

        g.setColor(hovered ? CHOICE_BUTTON_BORDER_HOVER : CHOICE_BUTTON_BORDER);
        g.setStroke(new BasicStroke(hovered ? 3f : 2f));
        g.draw(buttonShape);

        RoundRectangle2D.Float innerBorder = new RoundRectangle2D.Float(
                rect.x + 2,
                rect.y + 2,
                rect.width - 4,
                rect.height - 4,
                Math.max(4f, cornerRadius - 4f),
                Math.max(4f, cornerRadius - 4f)
        );
        g.setColor(CHOICE_BUTTON_BORDER_INNER);
        g.setStroke(new BasicStroke(1.4f));
        g.draw(innerBorder);

        g.setPaint(previousPaint);
        g.setStroke(previousStroke);
        g.setComposite(previousComposite);

        drawIconGlow(g, iconRect, itemId, hovered);

        final int iconSize = iconRect.width;
        final int iconX = iconRect.x;
        final int iconY = iconRect.y;
        BufferedImage icon = itemManager.getImage(itemId, 1, false);
        if (icon != null)
        {
            g.drawImage(icon, iconX, iconY, iconSize, iconSize, null);
        }

    }

    private Color blendColors(Color base, Color accent, float mix)
    {
        mix = Math.max(0f, Math.min(1f, mix));
        final float inv = 1f - mix;
        int r = Math.round(base.getRed() * inv + accent.getRed() * mix);
        int g = Math.round(base.getGreen() * inv + accent.getGreen() * mix);
        int b = Math.round(base.getBlue() * inv + accent.getBlue() * mix);
        int a = Math.round(base.getAlpha() * inv + accent.getAlpha() * mix);
        r = Math.min(255, Math.max(0, r));
        g = Math.min(255, Math.max(0, g));
        b = Math.min(255, Math.max(0, b));
        a = Math.min(255, Math.max(0, a));
        return new Color(r, g, b, a);
    }

    private void drawIconGlow(Graphics2D g, Rectangle iconRect, int itemId, boolean hovered)
    {
        Color[] palette = getHighlightPalette(itemId);
        final float cx = iconRect.x + iconRect.width / 2f;
        final float cy = iconRect.y + iconRect.height / 2f;
        final float radius = Math.max(iconRect.width, iconRect.height) * (hovered ? 0.95f : 0.82f);
        final Color centerColor = blendColors(
                new Color(30, 30, 30, hovered ? 230 : 210),
                palette[0],
                hovered ? 0.6f : 0.45f
        );
        final Color midColor = new Color(
                palette[0].getRed(),
                palette[0].getGreen(),
                palette[0].getBlue(),
                hovered ? 150 : 120
        );
        final Color edgeColor = new Color(
                palette[1].getRed(),
                palette[1].getGreen(),
                palette[1].getBlue(),
                0
        );
        final RadialGradientPaint glow = new RadialGradientPaint(
                new Point2D.Float(cx, cy),
                radius,
                new float[]{0f, 0.7f, 1f},
                new Color[]{centerColor, midColor, edgeColor}
        );
        Composite oldComposite = g.getComposite();
        g.setComposite(AlphaComposite.SrcOver.derive(0.9f));
        g.setPaint(glow);
        g.fill(new Ellipse2D.Float(
                cx - radius,
                cy - radius,
                radius * 2f,
                radius * 2f
        ));
        g.setComposite(oldComposite);
    }

    private void normalizeOnce(float step)
    {
        if (rollOffset >= step) {
            rollOffset -= step;
            if (!rollingColumns.isEmpty()) {
                for (List<Integer> column : rollingColumns) {
                    if (column == null || column.isEmpty()) {
                        continue;
                    }
                    column.remove(0);
                    if (randomLockedItemSupplier != null) {
                        column.add(nextUniqueRollItem());
                    }
                }
            }
        }
    }

    private int nextUniqueRollItem()
    {
        if (randomLockedItemSupplier == null)
        {
            return 0;
        }

        final int maxAttempts = Math.max(10, columnCount * DRAW_COUNT);
        int fallback = 0;

        for (int attempt = 0; attempt < maxAttempts; attempt++)
        {
            Integer rolled = randomLockedItemSupplier.get();
            int candidate = rolled != null ? rolled : 0;
            fallback = candidate;
            if (candidate == 0)
            {
                break;
            }
            if (uniqueRollItems.add(candidate))
            {
                return candidate;
            }
        }

        if (fallback != 0)
        {
            uniqueRollItems.add(fallback);
        }
        return fallback;
    }

    private float normalizeStep(float value, float step)
    {
        if (step == 0f)
        {
            return 0f;
        }
        float adjusted = value % step;
        if (adjusted < 0)
        {
            adjusted += step;
        }
        return adjusted;
    }

    private void drawSlotWindow(Graphics2D g, int x, int y, int width, int height, float scale)
    {
        float radius = Math.max(18f, 18f * scale * 0.9f);
        RoundRectangle2D.Float frame = new RoundRectangle2D.Float(x, y, width, height, radius, radius);
        GradientPaint paint = new GradientPaint(
                x,
                y,
                SLOT_FILL_TOP,
                x,
                y + height,
                SLOT_FILL_BOTTOM
        );
        Paint oldPaint = g.getPaint();
        Stroke oldStroke = g.getStroke();
        g.setPaint(paint);
        g.fill(frame);

        // inner glossy stroke
        RoundRectangle2D.Float inner = new RoundRectangle2D.Float(
                x + 3,
                y + 3,
                width - 6,
                height - 6,
                Math.max(12f, radius * 0.8f),
                Math.max(12f, radius * 0.8f)
        );
        g.setPaint(new Color(255, 255, 255, scale > 1f ? 80 : 45));
        g.setStroke(new BasicStroke(2f));
        g.draw(inner);

        g.setPaint(SLOT_BORDER);
        g.setStroke(new BasicStroke(scale > 1f ? 3f : 2f));
        g.draw(frame);
        g.setPaint(oldPaint);
        g.setStroke(oldStroke);
    }

    private void drawHoverTooltip(Graphics2D g, String text, Point mouse, Shape clipShape)
    {
        if (text == null || text.isEmpty())
        {
            return;
        }
        Font oldFont = g.getFont();
        g.setFont(LABEL_FONT);
        FontMetrics fm = g.getFontMetrics();
        int padding = 6;
        int width = fm.stringWidth(text) + padding * 2;
        int height = fm.getHeight() + padding * 2;

        Rectangle clipBounds = clipShape != null ? clipShape.getBounds()
                : new Rectangle(0, 0, client.getCanvasWidth(), client.getCanvasHeight());

        int x = mouse.getX() + 12;
        int y = mouse.getY() - 12;
        x = Math.max(clipBounds.x, Math.min(x, clipBounds.x + clipBounds.width - width));
        y = Math.max(clipBounds.y + height, Math.min(y, clipBounds.y + clipBounds.height));
        int top = y - height;

        g.setColor(new Color(0, 0, 0, 190));
        g.fillRoundRect(x, top, width, height, 8, 8);
        g.setColor(new Color(200, 200, 200, 220));
        g.drawRoundRect(x, top, width, height, 8, 8);

        g.setColor(Color.WHITE);
        g.drawString(text, x + padding, top + padding + fm.getAscent());
        g.setFont(oldFont);
    }

    private String getItemNameSafe(int itemId)
    {
        if (itemId <= 0)
        {
            return "";
        }
        ItemComposition composition = itemManager.getItemComposition(itemId);
        if (composition == null)
        {
            return "";
        }
        String name = composition.getName();
        if (name == null)
        {
            return "";
        }
        name = name.trim();
        if (name.isEmpty() || name.equalsIgnoreCase("null") || name.equalsIgnoreCase("Members") || name.equalsIgnoreCase("(Members)") || name.matches("(?i)null\\s*\\(Members\\)"))
        {
            return "";
        }
        return name;
    }

    private String buildHoverText(int itemId)
    {
        String baseName = getItemNameSafe(itemId);
        String questName = QuestItemAllowlist.getQuestNameForItem(itemId);
        if (questName == null || questName.trim().isEmpty())
        {
            return baseName;
        }
        if (baseName.isEmpty())
        {
            return questName;
        }
        return baseName + " (" + questName + ")";
    }

    private void drawHighlight(Graphics2D g, int iconsX, int baseY, int itemId, int iconDimension, boolean emphasize)
    {
        final float glowScale = emphasize ? 1.8f : 1.4f;
        final float glowHeightScale = emphasize ? 2.0f : 1.6f;
        final int glowW = (int) (iconDimension * glowScale);
        final int glowH = (int) (iconDimension * glowHeightScale);
        final float cx = iconsX + iconDimension / 2f;
        final float cy = baseY + iconDimension / 2f;

        final Color[] glowPalette = getHighlightPalette(itemId);
        final RadialGradientPaint glow = new RadialGradientPaint(
                new Point2D.Float(cx, cy),
                glowH / 2f,
                new float[]{0f, 1f},
                new Color[]{
                        glowPalette[0],
                        glowPalette[1]
                }
        );
        final Composite old = g.getComposite();
        g.setComposite(AlphaComposite.SrcOver.derive(0.75f));
        g.setPaint(glow);
        g.fill(new Ellipse2D.Float(cx - glowW / 2f, cy - glowH / 2f, glowW, glowH));
        g.setComposite(old);

        final float centerScale = emphasize ? 1.25f : 1.05f;
        final int innerBoxXInset = FRAME_CONTENT_INSET;
        final int innerBoxYInset = FRAME_CONTENT_INSET;
        final int innerBoxW = iconDimension - innerBoxXInset * 2;
        final int innerBoxH = iconDimension - innerBoxYInset * 2;

        final int innerBoxX = iconsX + innerBoxXInset;
        final int innerBoxY = baseY + innerBoxYInset;

        final int scaledW = (int) (innerBoxW * centerScale);
        final int scaledH = (int) (innerBoxH * centerScale);
        final int scaledX = innerBoxX + (innerBoxW - scaledW) / 2;
        final int scaledY = innerBoxY + (innerBoxH - scaledH) / 2;

        final BufferedImage centerImg = itemManager.getImage(itemId, 1, false);
        if (centerImg != null) {
            g.drawImage(centerImg, scaledX, scaledY, scaledW, scaledH, null);
        }
    }

    private Color[] getHighlightPalette(int itemId)
    {
        return isTradeableItem(itemId) ? TRADEABLE_GLOW : UNTRADEABLE_GLOW;
    }

    private volatile CompletableFuture<Integer> selectionFuture;

    public void setSelectionFuture(CompletableFuture<Integer> future)
    {
        this.selectionFuture = future;
    }



    private final java.awt.event.MouseListener mouseListener = new java.awt.event.MouseAdapter()
    {
        @Override
        public void mouseClicked(MouseEvent e)
        {
            if (selectionPending && getOptionAt(e.getX(), e.getY()) != null)
            {
                e.consume();
            }
        }

        @Override
        public void mousePressed(MouseEvent e)
        {
            if (selectionPending && getOptionAt(e.getX(), e.getY()) != null)
            {
                e.consume();
            }
        }

        @Override
        public void mouseReleased(MouseEvent e)
        {
            if (!selectionPending)
            {
                return;
            }

            Integer hit = getOptionAt(e.getX(), e.getY());
            if (hit != null)
            {
                if (selectionFuture != null && !selectionFuture.isDone())
                {
                    selectionFuture.complete(hit);
                }
                e.consume();
            }
        }
    };

    public java.awt.event.MouseListener getMouseListener()
    {
        return mouseListener;
    }

    private boolean isTradeableItem(int itemId)
    {
        if (itemId <= 0)
        {
            return true;
        }
        ItemComposition composition = itemManager.getItemComposition(itemId);
        return composition == null || composition.isTradeable();
    }
}

package com.choicer.chanceman;

import net.runelite.client.config.Config;
import net.runelite.client.config.ConfigGroup;
import net.runelite.client.config.ConfigItem;
import java.awt.Color;

@ConfigGroup("chanceman")
public interface ChanceManConfig extends Config
{
    @ConfigItem(
            keyName = "freeToPlay",
            name = "Free To Play Mode",
            description = "Only allow free-to-play items",
            position = 1
    )
    default boolean freeToPlay()
    {
        return false;
    }

    @ConfigItem(
            keyName = "includeF2PTradeOnlyItems",
            name = "Include F2P trade-only items",
            description = "When Free-to-Play mode is enabled, also roll items that can only " +
                    "be obtained via trading or the Grand Exchange.",
            position = 2
    )
    default boolean includeF2PTradeOnlyItems() { return false; }

    @ConfigItem(
            keyName = "enableItemSets",
            name = "Roll Item Sets",
            description = "Include item set items in the rollable items list. Disabling this will exclude any" +
                    " item set items from random rolls.",
            position = 3
    )
    default boolean enableItemSets() { return false; }

    @ConfigItem(
            keyName = "enableFlatpacks",
            name = "Roll Flatpacks",
            description = "Include flatpacks in the rollable items list. Disabling this will prevent" +
                    " flatpacks from being rolled.",
            position = 4
    )
    default boolean enableFlatpacks() { return false; }

    @ConfigItem(
            keyName = "requireWeaponPoison",
            name = "Weapon Poison Unlock Requirements",
            description = "Force poison variants to roll only if both the base weapon and the corresponding" +
                    " weapon poison are unlocked. (Disabling this will allow poisoned variants to roll even if " +
                    "the poison is locked.)",
            position = 5
    )
    default boolean requireWeaponPoison() { return true; }

    @ConfigItem(
            keyName = "enableRollSounds",
            name = "Enable Roll Sounds",
            description = "Toggle Roll Sound",
            position = 6
    )
    default boolean enableRollSounds() { return true; }

    @net.runelite.client.config.Range(min = 0, max = 100)
    @ConfigItem(
            keyName = "rollSoundVolume",
            name = "Roll Sound Volume",
            description = "Volume of the roll sound (0–100%).",
            position = 7
    )
    default int rollSoundVolume() { return 50; }


    @ConfigItem(
            keyName = "requireRolledUnlockedForGe",
            name = "GE Requires Rolled and Unlocked",
            description = "Only allow Grand Exchange purchases once items are both rolled and unlocked.",
            position = 8
    )
    default boolean requireRolledUnlockedForGe() { return true; }


    @ConfigItem(
            keyName = "sortDropsByRarity",
            name = "Sort Drops by Rarity",
            description = "Order drops in the Show Drops menu by rarity instead of item ID.",
            position = 9
    )
    default boolean sortDropsByRarity() { return true; }

    @ConfigItem(
            keyName = "showRareDropTable",
            name = "Show Rare Drop Table",
            description = "Include rare drop table items in the Show Drops menu.",
            position = 10
    )
    default boolean showRareDropTable() { return true; }

    @ConfigItem(
            keyName = "showGemDropTable",
            name = "Show Gem Drop Table",
            description = "Include gem drop table items in the Show Drops menu.",
            position = 11
    )
    default boolean showGemDropTable() { return true; }

    @ConfigItem(
            keyName = "deprioritizeLockedOptions",
            name = "Deprioritize Locked Menu Options",
            description = "Sorts locked menu options below the Walk Here option.",
            position = 12
    )
    default boolean deprioritizeLockedOptions() { return true; }

    @ConfigItem(
            keyName = "unlockedItemColor",
            name = "Unlocked Item Color",
            description = "Color of the unlocked item name in chat messages.",
            position = 13
    )
    default Color unlockedItemColor()
    {
        return Color.decode("#267567");
    }

    @ConfigItem(
            keyName = "rolledItemColor",
            name = "Rolled Item Color",
            description = "Color of the item used to unlock another item.",
            position = 14
    )
    default Color rolledItemColor()
    {
        return Color.decode("#ff0000");
    }

    @ConfigItem(
            keyName = "dimLockedItemsEnabled",
            name = "Dim locked items",
            description = "Dim any item icons that have not been unlocked.",
            position = 15
    )
    default boolean dimLockedItemsEnabled()
    {
        return true;
    }

    @ConfigItem(
    keyName = "includeUntradeable",
    name = "Include Untradeable Items",
    description = "Enable to include untradeable items in the rolling system",
    position = 17  // Position after the dimLockedItemsOpacity config
)
default boolean includeUntradeable() {
    return false;  // Default to false to maintain current behavior
}

    @net.runelite.client.config.Range(min = 0, max = 255)
    @ConfigItem(
            keyName = "dimLockedItemsOpacity",
            name = "Dim opacity",
            description = "0 = no dim (fully visible), 255 = fully transparent.",
            position = 16
    )
    default int dimLockedItemsOpacity()
    {
        return 150;
    }

    @ConfigItem(
            keyName = "includeQuestItems",
            name = "Include Quest Items",
            description = "Enable to include quest items in the rolling system",
            position = 20,
            hidden = true
    )
    default boolean includeQuestItems()
    {
        return false;
    }

      @ConfigItem(
            keyName = "enableChoiceman",
            name = "Enable Choiceman",
            description = "Roll multiple options and pick one to unlock.",
            position = 18
    )
    default boolean enableChoiceman()
    {
        return false;
    }
    @net.runelite.client.config.Range(min = 2, max = 5)
    @ConfigItem(
            keyName = "choicemanOptionCount",
            name = "Choiceman Options",
            description = "Number of choices presented when Choiceman is enabled.",
            position = 19
    )
    default int choicemanOptionCount()
    {
        return 5;
    }
}

package com.choicer.chanceman.ui;

import com.choicer.chanceman.ChanceManConfig;
import com.choicer.chanceman.drops.DropItem;
import com.choicer.chanceman.drops.NpcDropData;
import com.choicer.chanceman.managers.RolledItemsManager;

import java.util.*;
import java.util.stream.Collectors;
import javax.inject.Inject;
import javax.inject.Singleton;
import javax.swing.*;

import lombok.Getter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.ScriptEvent;
import net.runelite.api.events.WidgetLoaded;
import net.runelite.api.widgets.ItemQuantityMode;
import net.runelite.api.widgets.JavaScriptCallback;
import net.runelite.api.widgets.Widget;
import net.runelite.api.widgets.WidgetType;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.eventbus.Subscribe;

@Slf4j
@Singleton
public class MusicWidgetController
{
    private static final int MUSIC_GROUP = 239;
    private static final int ICON_SIZE = 32;
    private static final int PADDING = 4;
    private static final int COLUMNS = 4;
    private static final int MARGIN_X = 8;
    private static final int MARGIN_Y = 8;
    private static final int BAR_HEIGHT = 15;
    private static final float WIDTH_RATIO = 0.7f;
    private static final int EYE_SIZE = 20;
    private static final int SEARCH_SPRITE = 1113;

    private final Client client;
    private final ClientThread clientThread;
    private final RolledItemsManager rolledItemsManager;
    private final SpriteOverrideManager spriteOverrideManager;
    private final ItemSpriteCache itemSpriteCache;
    private final ChanceManConfig config;
    private final NpcSearchService searchService;

    private NpcDropData currentDrops = null;
    private List<Widget> backupJukeboxStaticKids = null;
    private List<Widget> backupJukeboxDynamicKids = null;
    private List<Widget> backupScrollStaticKids = null;
    private List<Widget> backupScrollDynamicKids = null;
    private List<Widget> backupRootStaticKids = null;
    private List<Widget> backupRootDynamicKids = null;
    private final List<Widget> overrideRootWidgets = new ArrayList<>();
    private final List<Widget> overrideScrollWidgets = new ArrayList<>();
    private Integer originalRootType = null;
    private String originalTitleText = null;
    @Getter private final Map<Widget, DropItem> iconItemMap = new LinkedHashMap<>();
    @Getter private boolean overrideActive = false;
    @Inject private MusicSearchButton musicSearchButton;
    private boolean hideRolledItems = false;

    @Inject
    public MusicWidgetController(
            Client client,
            ClientThread clientThread,
            RolledItemsManager rolledItemsManager,
            SpriteOverrideManager spriteOverrideManager,
            ItemSpriteCache itemSpriteCache,
            ChanceManConfig config,
            NpcSearchService searchService)
    {
        this.client = client;
        this.clientThread = clientThread;
        this.rolledItemsManager = rolledItemsManager;
        this.spriteOverrideManager = spriteOverrideManager;
        this.itemSpriteCache = itemSpriteCache;
        this.config = config;
        this.searchService = searchService;
    }

    public boolean hasData()
    {
        return currentDrops != null;
    }

    public NpcDropData getCurrentData()
    {
        return currentDrops;
    }

    /**
     * Replace the music widget with a drop table view for the given NPC.
     * If an override is already active, it will be updated
     */
    public void override(NpcDropData dropData)
    {
        if (dropData == null)
        {
            return;
        }
        currentDrops = dropData;
        hideRolledItems = false;
        musicSearchButton.onOverrideActivated();
        if (!overrideActive)
        {
            overrideActive = true;
            clientThread.invokeLater(() ->
            {
                applyOverride(dropData);
                spriteOverrideManager.register();
            });
        }
        else
        {
            clientThread.invokeLater(() -> applyOverride(dropData));
        }
    }

    /**
     * Remove the drop table overlay and restore the original music widget.
     */
    public void restore()
    {
        if (!overrideActive)
        {
            return;
        }
        spriteOverrideManager.unregister();
        itemSpriteCache.clear();
        hideRolledItems = false;
        clientThread.invokeLater(this::revertOverride);
    }

    private void updateIconsVisibilityAndLayout()
    {
        Set<Integer> rolledIds = rolledItemsManager.getRolledItems();
        Widget scrollable = client.getWidget(MUSIC_GROUP, 4);
        Widget scrollbar = client.getWidget(MUSIC_GROUP, 7);

        int displayIndex = 0;

        for (Map.Entry<Widget, DropItem> e : iconItemMap.entrySet())
        {
            Widget icon = e.getKey();
            DropItem d = e.getValue();
            boolean rolled = rolledIds.contains(d.getItemId());

            if (hideRolledItems && rolled)
            {
                icon.setHidden(true);
            }
            else
            {
                icon.setHidden(false);
                int col = displayIndex % COLUMNS;
                int row = displayIndex / COLUMNS;
                int x = MARGIN_X + col * (ICON_SIZE + PADDING);
                int y = MARGIN_Y + row * (ICON_SIZE + PADDING);
                icon.setOriginalX(x);
                icon.setOriginalY(y);
                icon.revalidate();
                displayIndex++;
            }
        }

        int rows = (displayIndex + COLUMNS - 1) / COLUMNS;
        if (scrollable != null)
        {
            scrollable.setScrollHeight(MARGIN_Y * 2 + rows * (ICON_SIZE + PADDING));
            scrollable.revalidate();
        }
        if (scrollbar != null)
        {
            scrollbar.revalidateScroll();
        }
    }

    private static List<Widget> copyChildren(Widget parent, boolean dynamic)
    {
        if (parent == null)
        {
            return new ArrayList<>();
        }
        Widget[] kids = dynamic ? parent.getDynamicChildren() : parent.getChildren();
        if (kids == null) {
            return new ArrayList<>();
        }
        List<Widget> out = new ArrayList<>(kids.length);
        for (Widget k : kids) {
            if (k != null) out.add(k);
        }
        return out;
    }

    private static void restoreChildren(Widget parent, List<Widget> staticKids, List<Widget> dynamicKids)
    {
        if (parent == null)
        {
            return;
        }

        Widget[] currentStatic = parent.getChildren();
        if (currentStatic != null)
        {
            for (Widget w : currentStatic)
            {
                if (w != null) {
                    w.setHidden(true);
                }
            }
        }

        Widget[] currentDyn = parent.getDynamicChildren();
        if (currentDyn != null)
        {
            for (Widget w : currentDyn)
            {
                if (w != null) {
                    w.setHidden(true);
                }
            }
        }

        if (staticKids != null)
        {
            for (Widget w : staticKids)
            {
                if (w != null && w.getType() != 0) {
                    w.setHidden(false);
                }
            }
        }
        if (dynamicKids != null)
        {
            for (Widget w : dynamicKids)
            {
                if (w != null && w.getType() != 0) {
                    w.setHidden(false);
                }
            }
        }

        parent.revalidate();
    }

    private Widget updateTitle(NpcDropData dropData)
    {
        Widget title = client.getWidget(MUSIC_GROUP, 8);
        if (title != null)
        {
            if (originalTitleText == null)
            {
                originalTitleText = title.getText();
            }
            title.setText(dropData.getName());
            title.revalidate();
        }
        return title;
    }

    private void drawProgressBarAndToggle(Widget root, Widget title, NpcDropData dropData, int rolledCount, int totalDrops)
    {
        int fontId = title != null ? title.getFontId() : 0;
        boolean shadowed = title != null && title.getTextShadowed();

        int lvlX = Objects.requireNonNull(title).getOriginalX() + title.getOriginalWidth() + 83;
        int lvlY = title.getOriginalY();

        Widget lvl = root.createChild(-1);
        lvl.setHidden(false);
        lvl.setType(WidgetType.TEXT);
        lvl.setText(String.format("Lvl %d", dropData.getLevel()));
        lvl.setFontId(fontId);
        lvl.setTextShadowed(shadowed);
        lvl.setTextColor(0x00b33c);
        lvl.setOriginalX(lvlX);
        lvl.setOriginalY(lvlY);
        lvl.setOriginalWidth(title.getOriginalWidth());
        lvl.setOriginalHeight(title.getOriginalHeight());
        lvl.revalidate();
        overrideRootWidgets.add(lvl);

        Widget oldBar = client.getWidget(MUSIC_GROUP, 9);
        if (oldBar == null)
        {
            return;
        }
        int xOld = oldBar.getOriginalX();
        int yOld = oldBar.getOriginalY();
        int wOld = oldBar.getOriginalWidth();
        int hOld = oldBar.getOriginalHeight();

        int newW = Math.round(wOld * WIDTH_RATIO);
        int newY = yOld + (hOld - BAR_HEIGHT) / 2;

        Widget bg = root.createChild(-1);
        bg.setHidden(false);
        bg.setType(WidgetType.RECTANGLE);
        bg.setOriginalX(xOld);
        bg.setOriginalY(newY);
        bg.setOriginalWidth(newW);
        bg.setOriginalHeight(BAR_HEIGHT);
        bg.setFilled(true);
        bg.setTextColor(0x000000);
        bg.revalidate();
        overrideRootWidgets.add(bg);

        final int border = 1;
        int innerWidth = newW - border * 2;
        int fillW = Math.round(innerWidth * (float) rolledCount / totalDrops);

        Widget fill = root.createChild(-1);
        fill.setHidden(false);
        fill.setType(WidgetType.RECTANGLE);
        fill.setOriginalX(xOld + border);
        fill.setOriginalY(newY + border);
        fill.setOriginalWidth(fillW);
        fill.setOriginalHeight(BAR_HEIGHT - border * 2);
        fill.setFilled(true);
        fill.setTextColor(0x00b33c);
        fill.revalidate();
        overrideRootWidgets.add(fill);

        String txt = String.format("%d/%d", rolledCount, totalDrops);
        Widget label = root.createChild(-1);
        label.setHidden(false);
        label.setType(WidgetType.TEXT);
        label.setText(txt);
        label.setTextColor(0xFFFFFF);
        label.setFontId(fontId);
        label.setTextShadowed(shadowed);
        label.setOriginalWidth(newW);
        label.setOriginalHeight(BAR_HEIGHT);
        label.setOriginalX(xOld + (newW / 2) - (txt.length() * 4));
        label.setOriginalY(newY + (BAR_HEIGHT / 2) - 6);
        label.revalidate();
        overrideRootWidgets.add(label);

        int eyeX = xOld + newW + 4;
        int eyeY = newY + (BAR_HEIGHT / 2) - (EYE_SIZE / 2);

        Widget eye = root.createChild(-1);
        eye.setHidden(false);
        eye.setType(WidgetType.GRAPHIC);
        eye.setOriginalX(eyeX);
        eye.setOriginalY(eyeY);
        eye.setOriginalWidth(EYE_SIZE);
        eye.setOriginalHeight(EYE_SIZE);
        eye.setSpriteId(hideRolledItems ? 2222 : 2221);
        eye.revalidate();
        eye.setAction(0, "Toggle rolled items");

        overrideRootWidgets.add(eye);
        eye.setOnOpListener((JavaScriptCallback) (ScriptEvent ev) ->
        {
            hideRolledItems = !hideRolledItems;
            updateIconsVisibilityAndLayout();
            eye.setSpriteId(hideRolledItems ? 2222 : 2221);
            eye.revalidate();
        });
        eye.setHasListener(true);

        int searchX = eyeX + EYE_SIZE + PADDING;

        Widget search = root.createChild(-1);
        search.setHidden(false);
        search.setType(WidgetType.GRAPHIC);
        search.setOriginalX(searchX);
        search.setOriginalY(eyeY);
        search.setOriginalWidth(EYE_SIZE);
        search.setOriginalHeight(EYE_SIZE);
        search.setSpriteId(SEARCH_SPRITE);
        search.revalidate();
        search.setAction(0, "Search Drops");
        overrideRootWidgets.add(search);

        search.setOnOpListener((JavaScriptCallback) ev -> showSearchDialog());
        search.setHasListener(true);

        root.revalidate();
    }

    /**
     * Display a Swing dialog prompting the user for an NPC name or ID. The
     * potentially long running search executes on a background thread so the
     * UI remains responsive. Selecting a result will override the widget with
     * the chosen drop table.
     */
    private void showSearchDialog()
    {
        SwingUtilities.invokeLater(() ->
        {
            String query = JOptionPane.showInputDialog(
                    null,
                    "Enter NPC name or ID:",
                    "Search NPC",
                    JOptionPane.PLAIN_MESSAGE
            );
            if (query == null || query.trim().isEmpty())
            {
                return;
            }

            new Thread(() -> {
                List<NpcDropData> results = searchService.search(query.trim());

                SwingUtilities.invokeLater(() -> {
                    if (results.isEmpty())
                    {
                        JOptionPane.showMessageDialog(
                                null,
                                "No NPCs found for: " + query,
                                "Search NPC",
                                JOptionPane.INFORMATION_MESSAGE
                        );
                        return;
                    }

                    List<NpcDropData> limited = results.stream().limit(5).collect(Collectors.toList());
                    String[] choices = limited.stream()
                            .map(n -> String.format("%s (ID %d, Lvl %d)", n.getName(), n.getNpcId(), n.getLevel()))
                            .toArray(String[]::new);
                    int idx = JOptionPane.showOptionDialog(
                            null,
                            "Select NPC:",
                            "Search Results",
                            JOptionPane.DEFAULT_OPTION,
                            JOptionPane.PLAIN_MESSAGE,
                            null,
                            choices,
                            choices[0]
                    );
                    if (idx >= 0 && idx < limited.size())
                    {
                        override(limited.get(idx));
                    }
                });
            }).start();
        });
    }

    public void openDropsSearch()
    {
        showSearchDialog();
    }

    private void drawDropIcons(Widget scrollable, Widget scrollbar, Widget jukebox, List<DropItem> drops, Set<Integer> rolledIds)
    {
        if (scrollable == null || scrollbar == null)
        {
            return;
        }

        if (backupJukeboxStaticKids == null && jukebox != null)
        {
            backupJukeboxStaticKids = copyChildren(jukebox, false);
        }
        if (backupJukeboxDynamicKids == null && jukebox != null)
        {
            backupJukeboxDynamicKids = copyChildren(jukebox, true);
        }
        if (backupScrollStaticKids == null)
        {
            backupScrollStaticKids = copyChildren(scrollable, false);
        }
        if (backupScrollDynamicKids == null)
        {
            backupScrollDynamicKids = copyChildren(scrollable, true);
        }

        WidgetUtils.hideAllChildrenSafely(jukebox);
        WidgetUtils.hideAllChildrenSafely(scrollable);

        for (DropItem d : drops)
        {
            int itemId = d.getItemId();
            Widget icon = scrollable.createChild(-1);
            icon.setHidden(false);
            icon.setType(WidgetType.GRAPHIC);
            int spriteId = itemSpriteCache.getSpriteId(itemId);
            icon.setSpriteId(spriteId);
            icon.setItemQuantityMode(ItemQuantityMode.NEVER);
            icon.setOriginalX(MARGIN_X);
            icon.setOriginalY(MARGIN_Y);
            icon.setOriginalWidth(ICON_SIZE);
            icon.setOriginalHeight(ICON_SIZE);
            icon.setOpacity(rolledIds.contains(itemId) ? 0 : 150);
            icon.revalidate();

            iconItemMap.put(icon, d);
            overrideScrollWidgets.add(icon);
        }

        updateIconsVisibilityAndLayout();
    }

    private void applyOverride(NpcDropData dropData)
    {
        purgeOverrideWidgets();
        iconItemMap.clear();
        int[] toHide = {9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19};
        for (int childId : toHide)
        {
            Widget w = client.getWidget(MUSIC_GROUP, childId);
            if (w != null)
            {
                w.setHidden(true);
            }
        }

        Widget root = client.getWidget(MUSIC_GROUP, 0);
        if (backupRootStaticKids == null && root != null)
        {
            backupRootStaticKids = copyChildren(root, false);
        }
        if (backupRootDynamicKids == null && root != null)
        {
            backupRootDynamicKids = copyChildren(root, true);
        }
        overrideRootWidgets.clear();
        overrideScrollWidgets.clear();

        List<DropItem> drops = dropData.getDropTableSections().stream()
                .filter(sec ->
                {
                    String h = sec.getHeader();
                    if (h == null)
                    {
                        return true;
                    }
                    String lower = h.toLowerCase();
                    if (lower.contains("rare and gem drop table"))
                    {
                        return config.showRareDropTable() && config.showGemDropTable();
                    }
                    if (!config.showRareDropTable() && lower.contains("rare drop table"))
                    {
                        return false;
                    }
                    if (!config.showGemDropTable() && lower.contains("gem drop table"))
                    {
                        return false;
                    }
                    return true;
                })
                .flatMap(sec -> sec.getItems().stream())
                .collect(Collectors.toList());
        drops = WidgetUtils.dedupeAndSort(drops, config.sortDropsByRarity());

        Set<Integer> rolledIds = rolledItemsManager.getRolledItems();
        int totalDrops = drops.size();
        int rolledCount = (int) drops.stream()
                .filter(d -> rolledIds.contains(d.getItemId()))
                .count();

        Widget title = updateTitle(dropData);

        if (root != null)
        {
            root.setHidden(false);
            if (originalRootType == null)
            {
                originalRootType = root.getType();
            }
            root.setType(WidgetType.LAYER);
            WidgetUtils.hideAllChildrenSafely(root);

            drawProgressBarAndToggle(root, title, dropData, rolledCount, totalDrops);
        }

        Widget scrollable = client.getWidget(MUSIC_GROUP, 4);
        Widget jukebox = client.getWidget(MUSIC_GROUP, 6);
        Widget scrollbar = client.getWidget(MUSIC_GROUP, 7);

        drawDropIcons(scrollable, scrollbar, jukebox, drops, rolledIds);

        if (root != null)
        {
            root.revalidate();
        }
    }

    private void revertOverride()
    {
        if (!overrideActive)
        {
            return;
        }

        Widget root = client.getWidget(MUSIC_GROUP, 0);
        Widget scrollable = client.getWidget(MUSIC_GROUP, 4);
        Widget jukebox = client.getWidget(MUSIC_GROUP, 6);

        purgeWidgets(overrideRootWidgets);
        purgeWidgets(overrideScrollWidgets);
        overrideRootWidgets.clear();
        overrideScrollWidgets.clear();

        if (root != null)
        {
            restoreChildren(root, backupRootStaticKids, backupRootDynamicKids);
            if (originalRootType != null)
            {
                root.setType(originalRootType);
            }
        }

        restoreChildren(scrollable, backupScrollStaticKids, backupScrollDynamicKids);
        restoreChildren(jukebox, backupJukeboxStaticKids, backupJukeboxDynamicKids);

        Widget title = client.getWidget(MUSIC_GROUP, 8);
        Widget overlay = client.getWidget(MUSIC_GROUP, 5);
        Widget scrollbar = client.getWidget(MUSIC_GROUP, 7);
        Widget progress = client.getWidget(MUSIC_GROUP, 9);

        if (title != null && originalTitleText != null)
        {
            title.setText(originalTitleText);
            title.revalidate();
            for (int id = 9; id <= 19; id++)
            {
                Widget w = client.getWidget(MUSIC_GROUP, id);
                if (w != null)
                {
                    w.setHidden(false);
                    w.revalidate();
                }
            }
        }

        if (overlay != null)
        {
            overlay.setHidden(false);
            overlay.revalidate();
        }
        if (scrollbar != null)
        {
            scrollbar.setHidden(false);
            scrollbar.revalidate();
        }
        if (progress != null)
        {
            progress.setHidden(false);
            progress.revalidate();
        }

        if (root != null && root.getOnLoadListener() != null)
        {
            client.createScriptEvent(root.getOnLoadListener())
                    .setSource(root)
                    .run();
            root.revalidate();
        }
        if (overlay != null && overlay.getOnLoadListener() != null)
        {
            client.createScriptEvent(overlay.getOnLoadListener())
                    .setSource(overlay)
                    .run();
            overlay.revalidate();
        }
        if (scrollbar != null && scrollbar.getOnLoadListener() != null)
        {
            client.createScriptEvent(scrollbar.getOnLoadListener())
                    .setSource(scrollbar)
                    .run();
            scrollbar.revalidate();
        }
        if (jukebox != null && jukebox.getOnLoadListener() != null)
        {
            client.createScriptEvent(jukebox.getOnLoadListener())
                    .setSource(jukebox)
                    .run();
            jukebox.revalidate();
        }

        originalTitleText = null;
        currentDrops = null;
        overrideActive = false;
        backupRootStaticKids = null;
        backupRootDynamicKids = null;
        originalRootType = null;
        backupJukeboxStaticKids = null;
        backupJukeboxDynamicKids = null;
        backupScrollStaticKids = null;
        backupScrollDynamicKids = null;
        iconItemMap.clear();
        musicSearchButton.onOverrideDeactivated();
    }

    @Subscribe
    private void onWidgetLoaded(WidgetLoaded event)
    {
        if (event.getGroupId() != MUSIC_GROUP)
        {
            return;
        }

        if (!overrideActive || currentDrops == null)
        {
            return;
        }

        clientThread.invokeLater(() ->
        {
            if (!overrideActive || currentDrops == null)
            {
                return;
            }

            resetWidgetCaches();
            applyOverride(currentDrops);
        });
    }

    private void resetWidgetCaches()
    {
        purgeOverrideWidgets();
        backupRootStaticKids = null;
        backupRootDynamicKids = null;
        backupScrollStaticKids = null;
        backupScrollDynamicKids = null;
        backupJukeboxStaticKids = null;
        backupJukeboxDynamicKids = null;
        originalRootType = null;
        originalTitleText = null;
    }

    private void purgeOverrideWidgets()
    {
        purgeWidgets(overrideRootWidgets);
        purgeWidgets(overrideScrollWidgets);
        overrideRootWidgets.clear();
        overrideScrollWidgets.clear();
    }

    /**
     * Forcefully removes widgets we created during override so they cannot
     * be resurrected by the music tab's onLoad() which tends to unhide children.
     */
    private static void purgeWidgets(List<Widget> widgets)
    {
        if (widgets == null)
        {
            return;
        }
        for (Widget w : widgets)
        {
            if (w == null)
            {
                continue;
            }
            try {
                w.setOnOpListener((JavaScriptCallback) null);
                w.setHasListener(false);
                w.setHidden(true);
                w.setType(0);
                w.revalidate();
            } catch (Exception ignored) {}
        }
    }
}
package com.choicer.chanceman.ui;


import javax.inject.Inject;
import javax.inject.Singleton;
import lombok.extern.slf4j.Slf4j;
import net.runelite.client.eventbus.EventBus;

@Slf4j
@Singleton
public class DropsTabUI
{
    private final EventBus eventBus;
    private final DropsMenuListener menuListener;
    private final TabListener tabListener;

    @Inject
    public DropsTabUI(
            EventBus eventBus,
            DropsMenuListener menuListener,
            TabListener tabListener
    )
    {
        this.eventBus = eventBus;
        this.menuListener = menuListener;
        this.tabListener = tabListener;
    }

    public void startUp()
    {
        eventBus.register(menuListener);
        eventBus.register(tabListener);
    }

    public void shutDown()
    {
        eventBus.unregister(menuListener);
        eventBus.unregister(tabListener);
    }
}

package com.choicer.chanceman.ui;

import com.choicer.chanceman.drops.DropCache;
import lombok.extern.slf4j.Slf4j;
import javax.inject.Inject;
import javax.inject.Singleton;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import net.runelite.api.Client;
import net.runelite.api.MenuAction;
import net.runelite.api.MenuEntry;
import net.runelite.api.NPC;
import net.runelite.api.events.MenuOpened;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.eventbus.Subscribe;

@Slf4j
@Singleton
public class DropsMenuListener
{
    private final Client client;
    private final ClientThread clientThread;
    private final DropCache dropCache;
    private final MusicWidgetController widgetController;

    @Inject
    public DropsMenuListener(
            Client client,
            ClientThread clientThread,
            DropCache dropCache,
            MusicWidgetController widgetController
    )
    {
        this.client = client;
        this.clientThread = clientThread;
        this.dropCache = dropCache;
        this.widgetController = widgetController;
    }

    @Subscribe
    public void onMenuOpened(MenuOpened event)
    {
        List<MenuEntry> entries = new ArrayList<>(Arrays.asList(event.getMenuEntries()));
        NPC target = null;
        MenuEntry attackEntry = null;
        int attackIdx = -1;

        for (int i = 0; i < entries.size(); i++)
        {
            MenuEntry e = entries.get(i);
            if (e.getType() == MenuAction.NPC_SECOND_OPTION && "Attack".equals(e.getOption()))
            {
                try
                {
                    NPC possible = client.getTopLevelWorldView()
                            .npcs()
                            .byIndex(e.getIdentifier());
                    if (possible != null && possible.getCombatLevel() > 0)
                    {
                        target = possible;
                        attackEntry = e;
                        attackIdx = i;
                        break;
                    }
                }
                catch (ArrayIndexOutOfBoundsException ex)
                {
                    // ignore invalid indices
                }
            }
        }
        if (attackEntry == null || target == null)
        {
            return;
        }

        int id = target.getId();
        String name = target.getName();
        int level = target.getCombatLevel();

        MenuEntry showDrops = WidgetUtils.createShowDropsEntry(
                client,
                attackIdx - 1,
                attackEntry
        );
        showDrops.onClick(me -> fetchAndDisplayDrops(id, name, level, 1));

        entries.add(attackIdx + 1, showDrops);
        event.setMenuEntries(entries.toArray(new MenuEntry[0]));
    }
    private void fetchAndDisplayDrops(int id, String name, int level, int attemptsLeft)
    {
        dropCache.get(id, name, level)
                .whenComplete((dropData, ex) ->
                {
                    if (dropData != null && ex == null)
                    {
                        clientThread.invokeLater(() -> widgetController.override(dropData));
                        return;
                    }

                    if (attemptsLeft > 0) fetchAndDisplayDrops(id, name, level, attemptsLeft - 1);
                    else log.error("Failed to fetch drop data for {}", name, ex);

                });
    }
}
package com.choicer.chanceman.ui;

import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.game.SpriteManager;
import net.runelite.client.game.SpriteOverride;

import javax.inject.Inject;
import javax.inject.Singleton;

/**
 * Overrides the RuneLite music tab sprite with drops.png.
 * Call register() when showing drops and unregister() to restore the original.
 * Clears the widget sprite cache to force the client to pick up the new override.
 */
@Slf4j
@Singleton
public class SpriteOverrideManager implements SpriteOverride
{
    private static final int SPRITE_ID = 910;
    private static final String RESOURCE_PATH = "/com/choicer/chanceman/drops.png";

    private final SpriteManager spriteManager;
    private final Client client;
    private final ClientThread clientThread;

    @Inject
    public SpriteOverrideManager(SpriteManager spriteManager, Client client, ClientThread clientThread)
    {
        this.spriteManager = spriteManager;
        this.client = client;
        this.clientThread = clientThread;
    }

    /**
     * Apply the custom drops icon override.
     */
    public void register()
    {
        spriteManager.addSpriteOverrides(new SpriteOverride[]{this});
        clientThread.invokeLater(() -> {
            client.getWidgetSpriteCache().reset();
        });
    }

    /**
     * Remove the override, restoring the original music tab icon.
     */
    public void unregister()
    {
        spriteManager.removeSpriteOverrides(new SpriteOverride[]{this});
        clientThread.invokeLater(() -> {
            client.getWidgetSpriteCache().reset();
        });
    }

    @Override
    public int getSpriteId()
    {
        return SPRITE_ID;
    }

    @Override
    public String getFileName()
    {
        // Resource path relative to the classpath
        return RESOURCE_PATH;
    }
}

package com.choicer.chanceman.ui;

import java.awt.Dimension;
import java.awt.Graphics2D;
import java.awt.FontMetrics;
import java.awt.Color;
import java.awt.Rectangle;
import java.util.Map;
import javax.inject.Inject;
import javax.inject.Singleton;

import com.choicer.chanceman.drops.DropItem;

import net.runelite.api.Client;
import net.runelite.api.Point;
import net.runelite.api.widgets.Widget;
import net.runelite.client.ui.overlay.Overlay;
import net.runelite.client.ui.overlay.OverlayLayer;
import net.runelite.client.ui.overlay.OverlayPosition;

/**
 * Overlay that displays item name tooltips when hovering drop icons
 * injected into the music tab by {@link MusicWidgetController}.
 */
@Singleton
public class DropsTooltipOverlay extends Overlay
{
    private final Client client;
    private final MusicWidgetController widgetController;

    @Inject
    public DropsTooltipOverlay(
            Client client,
            MusicWidgetController widgetController
    )
    {
        this.client = client;
        this.widgetController = widgetController;
        setPosition(OverlayPosition.DYNAMIC);
        setLayer(OverlayLayer.ABOVE_WIDGETS);
    }

    @Override
    public Dimension render(Graphics2D graphics)
    {
        if (!widgetController.isOverrideActive()) {return null;}

        Point mouse = client.getMouseCanvasPosition();
        for (Map.Entry<Widget, DropItem> entry : widgetController.getIconItemMap().entrySet())
        {
            Widget w = entry.getKey();
            if (w == null || w.isHidden()) {continue;}
            Rectangle bounds = w.getBounds();
            if (bounds.contains(mouse.getX(), mouse.getY()))
            {
                DropItem drop = entry.getValue();
                drawTooltip(graphics, drop.getName(), drop.getOneOverRarity(), mouse);
                break;
            }
        }
        return null;
    }

    private void drawTooltip(Graphics2D g, String name, String rarity, Point mouse)
    {
        FontMetrics fm = g.getFontMetrics();
        int padding = 4;
        int gap = 2;
        int lineH  = fm.getHeight();

        String rateText = "Rate: " + rarity;

        int nameW = fm.stringWidth(name);
        int rateW = fm.stringWidth(rateText);

        int nameBoxW = nameW + padding * 2;
        int rateBoxW = rateW + padding * 2;
        int boxH     = lineH + padding * 2;
        int totalH   = boxH * 2 + gap;
        int clampW   = Math.max(nameBoxW, rateBoxW);

        int x = mouse.getX() + 10;
        int y = mouse.getY() - 10;

        Rectangle clip = g.getClipBounds();
        x = Math.max(clip.x, Math.min(x, clip.x + clip.width  - clampW));
        y = Math.max(clip.y + totalH, Math.min(y, clip.y + clip.height));

        int nameTop = y - totalH;
        drawBox(g, x, nameTop, nameBoxW, boxH);
        drawBox(g, x, y - boxH, rateBoxW, boxH);

        g.setColor(Color.WHITE);
        int base = nameTop + padding + fm.getAscent();
        g.drawString(name, x + padding, base);

        int rateBase = y - boxH + padding + fm.getAscent();
        String prefix = "Rate: ";
        int prefixW = fm.stringWidth(prefix);

        g.setColor(Color.WHITE);
        g.drawString(prefix, x + padding, rateBase);

        g.setColor(Color.ORANGE);
        g.drawString(rarity, x + padding + prefixW, rateBase);
    }

    private void drawBox(Graphics2D g, int x, int y, int w, int h)
    {
        g.setColor(new Color(0, 0, 0, 100));
        g.fillRect(x, y, w, h);
        g.setColor(new Color(50, 50, 50, 200));
        g.drawRect(x, y, w, h);
    }
}

package com.choicer.chanceman.ui;

import com.choicer.chanceman.drops.DropItem;
import net.runelite.api.Client;
import net.runelite.api.MenuEntry;
import net.runelite.api.MenuAction;
import net.runelite.api.widgets.Widget;

import java.util.*;
import java.util.stream.Collectors;
import java.util.LinkedHashMap;

public final class WidgetUtils
{
    /**
     * Creates a "Show Drops" menu entry identical to the original Attack entry.
     *
     * @param client      The RuneLite client.
     * @param insertIndex The index at which to insert the new entry.
     * @param attackEntry The original "Attack" menu entry to clone.
     * @return A configured MenuEntry that runs a custom drop display.
     */
    public static MenuEntry createShowDropsEntry(
            Client client,
            int insertIndex,
            MenuEntry attackEntry
    )
    {
        return client.getMenu()
                .createMenuEntry(insertIndex)
                .setOption("Show Drops")
                .setTarget(attackEntry.getTarget())
                .setIdentifier(attackEntry.getIdentifier())
                .setParam0(attackEntry.getParam0())
                .setParam1(attackEntry.getParam1())
                .setType(MenuAction.RUNELITE);
    }

    /**
     * Hides all static and dynamic children of the given widget, if any exist.
     *
     * @param widget The widget whose children should be hidden.
     */
    public static void hideAllChildrenSafely(Widget widget)
    {
        if (widget == null)
            return;

        Widget[] staticKids = widget.getChildren();
        if (staticKids != null)
        {
            for (Widget child : staticKids)
            {
                if (child != null) child.setHidden(true);
            }
        }

        Widget[] dynamicKids = widget.getDynamicChildren();
        if (dynamicKids != null)
        {
            for (Widget child : dynamicKids)
            {
                if (child != null) child.setHidden(true);
            }
        }
    }

    /**
     * Deduplicates a list of DropItems by item ID and optionally sorts them by rarity.
     *
     * <p>When sorting by rarity, the resulting list is ordered from most common
     * to rarest. Unknown rarities are treated as the rarest drops.</p>
     *
     * @param drops        The list of DropItems to process.
     * @param sortByRarity If {@code true}, sort by rarity; otherwise sort by item ID.
     * @return A new sorted, deduplicated list.
     */
    public static List<DropItem> dedupeAndSort(List<DropItem> drops, boolean sortByRarity)
    {
        return drops.stream()
                .filter(d -> d.getItemId() > 0)
                .collect(Collectors.toMap(
                        DropItem::getItemId,
                        d -> d,
                        (first, second) -> first,
                        LinkedHashMap::new
                ))
                .values().stream()
                .sorted(sortByRarity
                        ? Comparator.comparingDouble(DropItem::getRarityValue)
                        .thenComparingInt(DropItem::getItemId)
                        : Comparator.comparingInt(DropItem::getItemId))
                .collect(Collectors.toList());
    }
}

package com.choicer.chanceman.ui;

import com.choicer.chanceman.drops.DropCache;
import com.choicer.chanceman.drops.NpcDropData;

import javax.inject.Inject;
import javax.inject.Singleton;
import java.util.*;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.stream.Collectors;
import java.util.concurrent.CompletableFuture;

/**
 * Provides fuzzy search over available NPC drop data. The cache is consulted
 * first and any misses fall back to a wiki lookup. Results without drop tables
 * are discarded and lookups for multiple candidates are performed in parallel
 * to keep searches snappy.
 */
@Singleton
public class NpcSearchService
{
    private static final Pattern ID_LEVEL_PATTERN = Pattern.compile("^(\\d+)\\s+(?:lvl|level)?\\s*(\\d+)$", Pattern.CASE_INSENSITIVE);
    private static final Pattern NAME_LVL_PATTERN = Pattern.compile("^(.*)\\s+(?:lvl|level)\\s*(\\d+)$", Pattern.CASE_INSENSITIVE);
    private static final Pattern LVL_NAME_PATTERN = Pattern.compile("^(?:lvl|level)\\s*(\\d+)\\s+(.*)$", Pattern.CASE_INSENSITIVE);
    private static final Pattern NAME_NUM_PATTERN = Pattern.compile("^(.*\\D)\\s+(\\d+)$");
    private static final Pattern NUM_NAME_PATTERN = Pattern.compile("^(\\d+)\\s+(\\D.*)$");

    private final DropCache dropCache;

    @Inject
    public NpcSearchService(DropCache dropCache)
    {
        this.dropCache = dropCache;
    }

    private static class ParsedQuery
    {
        Integer npcId;
        Integer level;
        String  name;
    }

    private static ParsedQuery parse(String q)
    {
        if (q == null) return null;
        String lower = q.trim().toLowerCase(Locale.ROOT);
        if (lower.isEmpty()) return null;

        ParsedQuery pq = new ParsedQuery();
        Matcher m;

        // pure ID
        if (lower.matches("\\d+"))
        {
            pq.npcId = Integer.valueOf(lower);
            return pq;
        }
        // ID + level
        if ((m = ID_LEVEL_PATTERN.matcher(lower)).matches())
        {
            pq.npcId = Integer.valueOf(m.group(1));
            pq.level = Integer.valueOf(m.group(2));
            return pq;
        }
        // name + level
        if ((m = NAME_LVL_PATTERN.matcher(lower)).matches())
        {
            pq.name  = m.group(1).trim();
            pq.level = Integer.valueOf(m.group(2));
            return pq;
        }
        // level + name
        if ((m = LVL_NAME_PATTERN.matcher(lower)).matches())
        {
            pq.level = Integer.valueOf(m.group(1));
            pq.name  = m.group(2).trim();
            return pq;
        }
        // trailing number = level
        if ((m = NAME_NUM_PATTERN.matcher(lower)).matches())
        {
            pq.name  = m.group(1).trim();
            pq.level = Integer.valueOf(m.group(2));
            return pq;
        }
        // leading number = level
        if ((m = NUM_NAME_PATTERN.matcher(lower)).matches())
        {
            pq.level = Integer.valueOf(m.group(1));
            pq.name  = m.group(2).trim();
            return pq;
        }

        // fallback to pure name
        pq.name = lower;
        return pq;
    }

    /**
     * Search by partial name, level, or ID. Results are limited and ordered by
     * Levenshtein distance when appropriate.
     */
    public List<NpcDropData> search(String query)
    {
        ParsedQuery pq = parse(query);
        if (pq == null)
        {
            return Collections.emptyList();
        }

        // 1) name only → fetch all candidates by name
        if (pq.npcId == null && pq.level == null && pq.name != null)
        {
            List<String> names = dropCache.searchNpcNames(pq.name).join();
            List<NpcDropData> fetched = fetchAll(names.stream().limit(10).collect(Collectors.toList()), 0);
            return fetched.stream()
                    .sorted(Comparator.comparingInt(d ->
                            levenshtein(d.getName().toLowerCase(Locale.ROOT), pq.name)))
                    .collect(Collectors.toList());
        }

        // 2) ID only → fetch by ID
        if (pq.npcId != null && pq.name == null)
        {
            int lvl = (pq.level != null ? pq.level : 0);
            NpcDropData d = dropCache.get(pq.npcId, "", lvl).join();
            if (d == null || d.getDropTableSections().isEmpty())
            {
                return Collections.emptyList();
            }
            return Collections.singletonList(d);
        }

        // 3) mixed or partial → fuzzy search
        String nameFilter = (pq.name != null ? pq.name : "");
        int lvlFilter = (pq.level != null ? pq.level : -1);

        List<String> candidates = dropCache.searchNpcNames(nameFilter).join();
        List<NpcDropData> all = fetchAll(candidates.stream().limit(10).collect(Collectors.toList()),
                lvlFilter > -1 ? lvlFilter : 0);

        // if ID also provided, filter it
        if (pq.npcId != null)
        {
            all = all.stream()
                    .filter(d -> d.getNpcId() == pq.npcId)
                    .collect(Collectors.toList());
        }

        // filter by level + sort by name distance
        final int lvl = lvlFilter;
        return all.stream()
                .filter(d -> lvl < 0 || d.getLevel() == lvl)
                .sorted(Comparator.comparingInt(d ->
                        levenshtein(d.getName().toLowerCase(Locale.ROOT), nameFilter)))
                .collect(Collectors.toList());
    }

    /**
     * Fetch drop data for a list of names concurrently.
     */
    private List<NpcDropData> fetchAll(List<String> names, int level)
    {
        List<CompletableFuture<NpcDropData>> futures = names.stream()
                .map(n -> dropCache.get(0, n, level))
                .collect(Collectors.toList());

        CompletableFuture.allOf(futures.toArray(new CompletableFuture[0])).join();

        return futures.stream()
                .map(CompletableFuture::join)
                .filter(Objects::nonNull)
                .filter(d -> !d.getDropTableSections().isEmpty())
                .collect(Collectors.toList());
    }

    // simple DP Levenshtein
    private static int levenshtein(String a, String b)
    {
        int[][] dp = new int[a.length()+1][b.length()+1];
        for (int i = 0; i <= a.length(); i++) dp[i][0] = i;
        for (int j = 0; j <= b.length(); j++) dp[0][j] = j;
        for (int i = 1; i <= a.length(); i++)
            for (int j = 1; j <= b.length(); j++)
                dp[i][j] = Math.min(
                        Math.min(dp[i-1][j] + 1, dp[i][j-1] + 1),
                        dp[i-1][j-1] + (a.charAt(i-1)==b.charAt(j-1) ? 0 : 1)
                );
        return dp[a.length()][b.length()];
    }
}
package com.choicer.chanceman.ui;

import javax.inject.Inject;
import javax.inject.Singleton;
import java.awt.image.BufferedImage;
import java.util.HashMap;
import java.util.Map;

import net.runelite.api.Client;
import net.runelite.api.SpritePixels;
import net.runelite.client.game.ItemManager;
import net.runelite.client.util.ImageUtil;

/**
 * Caches custom item sprites scaled for widget display.
 */
@Singleton
public class ItemSpriteCache
{
    private static final int ICON_SIZE = 32;

    private final ItemManager itemManager;
    private final Client client;
    private final Map<Integer, Integer> spriteIds = new HashMap<>();
    private int nextGeneratedSpriteId = 0x10000;

    @Inject
    public ItemSpriteCache(ItemManager itemManager, Client client)
    {
        this.itemManager = itemManager;
        this.client = client;
    }

    private int generateNextId()
    {
        return nextGeneratedSpriteId++;
    }

    /**
     * Returns a sprite ID for the given item
     */
    public int getSpriteId(int itemId)
    {
        return spriteIds.computeIfAbsent(itemId, id ->
        {
            BufferedImage img = itemManager.getImage(id, 1, false);
            if (img == null)
            {
                return -1;
            }

            // resize to ICON_SIZE x ICON_SIZE
            BufferedImage resized = ImageUtil.resizeImage(img, ICON_SIZE, ICON_SIZE);

            // convert to SpritePixels for the client's override map
            SpritePixels pixels = ImageUtil.getImageSpritePixels(resized, client);

            // generate a unique sprite ID and register the override
            int spriteId = generateNextId();
            client.getSpriteOverrides().put(spriteId, pixels);

            return spriteId;
        });
    }

    /**
     * Clears all cached sprites and unregisters them from the client's override map.
     */
    public void clear()
    {
        spriteIds.values().forEach(client.getSpriteOverrides()::remove);
        spriteIds.clear();
        nextGeneratedSpriteId = 0x10000;
    }
}

package com.choicer.chanceman.ui;

import lombok.Getter;
import net.runelite.api.Client;
import net.runelite.api.events.WidgetLoaded;
import net.runelite.api.widgets.JavaScriptCallback;
import net.runelite.api.widgets.Widget;
import net.runelite.api.widgets.WidgetPositionMode;
import net.runelite.api.widgets.WidgetType;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.eventbus.Subscribe;

import javax.inject.Inject;
import javax.inject.Singleton;

@Singleton
public class MusicSearchButton {
    private static final int MUSIC_GROUP = 239;
    private static final int CONTENTS = 1; // Music.CONTENTS
    private static final int FRAME = 2; // Music.FRAME

    private static final int SPRITE_SEARCH = 1970;
    private static final int W = 14, H = 14;

    private static final int GAP = 4;
    private static final int NUDGE_LEFT = 26;
    private static final int NUDGE_DOWN = 0;

    private final Client client;
    private final ClientThread clientThread;
    private final MusicWidgetController musicWidgetController;

    private Widget icon;
    @Getter private boolean overrideActive = false;

    @Inject
    public MusicSearchButton(Client client, ClientThread clientThread, MusicWidgetController musicWidgetController) {
        this.client = client;
        this.clientThread = clientThread;
        this.musicWidgetController = musicWidgetController;
    }

    public void onStart() { clientThread.invokeLater(this::placeSearchIcon); }
    public void onStop() { clientThread.invokeLater(this::hide); }
    public void onOverrideActivated() { overrideActive = true; clientThread.invokeLater(this::hide); }
    public void onOverrideDeactivated() { overrideActive = false; clientThread.invokeLater(this::placeSearchIcon); }

    @Subscribe
    public void onWidgetLoaded(WidgetLoaded e) {
        if (e.getGroupId() == MUSIC_GROUP) clientThread.invokeLater(this::placeSearchIcon);
    }

    // Create/position the search icon next to "Toggle all"
    public void placeSearchIcon() {
        if (overrideActive) { hide(); return; }
        Widget contents = client.getWidget(MUSIC_GROUP, CONTENTS);
        Widget frame = client.getWidget(MUSIC_GROUP, FRAME);
        if (contents == null || frame == null) return;

        Widget root = client.getWidget(MUSIC_GROUP, 0);
        Widget toggleAll = findByAction(root, "Toggle all");

        int x, y;
        if (toggleAll != null) {
            x = toggleAll.getOriginalX() - W - GAP - NUDGE_LEFT;
            y = toggleAll.getOriginalY() + (toggleAll.getOriginalHeight() - H) / 2;
        } else {
            int frameRight = frame.getOriginalX() + frame.getOriginalWidth();
            x = frameRight - W - (GAP + 10) - NUDGE_LEFT;
            y = Math.max(6, frame.getOriginalY() - H - GAP);
        }

        if (icon != null && icon.getParentId() != contents.getId()) {
            icon = null;
        }

        if (icon == null) {
            icon = contents.createChild(-1, WidgetType.GRAPHIC);
            icon.setHasListener(true);
            icon.setAction(0, "Search Drops");
            icon.setOnOpListener((JavaScriptCallback) ev -> musicWidgetController.openDropsSearch());
        }

        icon.setHidden(false);
        icon.setSpriteId(SPRITE_SEARCH);
        move(icon, x, y, W, H);
        icon.revalidate();
    }

    public void hide() { if (icon != null) icon.setHidden(true); }

    private void move(Widget w, int x, int y, int width, int height) {
        w.setOriginalX(x);
        w.setOriginalY(y);
        w.setOriginalWidth(width);
        w.setOriginalHeight(height);
        w.setXPositionMode(WidgetPositionMode.ABSOLUTE_LEFT);
        w.setYPositionMode(WidgetPositionMode.ABSOLUTE_TOP);
    }

    // Find any widget under parent that exposes the given right-click action text
    private Widget findByAction(Widget parent, String action) {
        if (parent == null) return null;
        Widget[] kids = merge(parent.getChildren(), parent.getDynamicChildren());
        if (kids == null) return null;
        for (Widget c : kids) {
            if (c == null) continue;
            String[] actions = c.getActions();
            if (actions != null) {
                for (String a : actions) if (a != null && a.equalsIgnoreCase(action)) return c;
            }
            Widget deeper = findByAction(c, action);
            if (deeper != null) return deeper;
        }
        return null;
    }

    private static Widget[] merge(Widget[] a, Widget[] b) {
        if (a == null) return b;
        if (b == null) return a;
        Widget[] out = new Widget[a.length + b.length];
        System.arraycopy(a, 0, out, 0, a.length);
        System.arraycopy(b, 0, out, a.length, b.length);
        return out;
    }
}

package com.choicer.chanceman.ui;

import com.choicer.chanceman.ChoicemanPlugin;
import com.choicer.chanceman.filters.EnsouledHeadMapping;
import com.choicer.chanceman.menus.EnabledUI;
import com.choicer.chanceman.managers.UnlockedItemsManager;
import lombok.Setter;
import net.runelite.api.Client;
import net.runelite.api.GameState;
import net.runelite.api.ItemComposition;
import net.runelite.api.events.BeforeRender;
import net.runelite.api.widgets.Widget;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.game.ItemManager;

import javax.inject.Inject;
import javax.inject.Singleton;
import java.util.HashMap;
import java.util.LinkedHashSet;
import java.util.Map;
import java.util.Set;

/**
 * Dims any tracked-and-locked item widgets.
 * Runs at BeforeRender so scripts in the same frame can't overwrite opacity.
 */
@Singleton
public class ItemDimmerController {
    private final Client client;
    private final UnlockedItemsManager unlockedItemsManager;
    private final ItemManager itemManager;
    private final ChoicemanPlugin plugin;

    // Cache (per-frame) for "should dim?" decisions by raw item id
    private final Map<Integer, Boolean> dimDecisionCache = new HashMap<>(256);

    private volatile int dimOpacity = 150;
    @Setter
    private volatile boolean enabled = true;

    @Inject
    public ItemDimmerController(
            Client client,
            UnlockedItemsManager unlockedItemsManager,
            ItemManager itemManager,
            ChoicemanPlugin plugin
    ) {
        this.client = client;
        this.unlockedItemsManager = unlockedItemsManager;
        this.itemManager = itemManager;
        this.plugin = plugin;
    }

    public void setDimOpacity(int opacity) {
        this.dimOpacity = Math.max(0, Math.min(255, opacity));
    }

    private boolean isCollectionLogWidget(Widget w)
    {
        return w != null && w.getId() >>> 16 == 621;
    }

    /**
     * Last chance before drawing this frame; safe place to enforce opacity without races.
     */
    @Subscribe
    public void onBeforeRender(BeforeRender e) {
        if (!enabled || client.getGameState() != GameState.LOGGED_IN) return;

        dimDecisionCache.clear();
        dimAllRoots();
    }

    private void dimAllRoots() {
        final Widget[] roots = client.getWidgetRoots();
        if (roots == null) return;

        for (Widget root : roots) {
            if (root != null) {
                walkAndDim(root);
            }
        }
    }

    private void walkAndDim(Widget w) {
        if (w == null || w.isHidden()) return;

        // Don't dim item icons in EnabledUIs configured to not grey locked items
        int groupId = w.getId() >>> 16;
        EnabledUI ui = EnabledUI.fromGroupId(groupId);
        if (ui != null && !ui.isGreyLockedItems()) {
            Widget[] dyn = w.getDynamicChildren();
            if (dyn != null) for (Widget c : dyn) walkAndDim(c);
            Widget[] stat = w.getStaticChildren();
            if (stat != null) for (Widget c : stat) walkAndDim(c);
            Widget[] nest = w.getNestedChildren();
            if (nest != null) for (Widget c : nest) walkAndDim(c);
            return;
        }

        if (isCollectionLogWidget(w)) return;
        final int itemId = w.getItemId();
        if (itemId > 0) {
            // Don’t override the game’s own dim on bank placeholders
            if (!isBankPlaceholderWidget(w)) {
                final int target = shouldDimMemoized(itemId) ? dimOpacity : 0;
                if (w.getOpacity() != target) {
                    w.setOpacity(target);
                }
            }
        }

        final Widget[] dyn = w.getDynamicChildren();
        if (dyn != null) for (Widget c : dyn) walkAndDim(c);
        final Widget[] stat = w.getStaticChildren();
        if (stat != null) for (Widget c : stat) walkAndDim(c);
        final Widget[] nest = w.getNestedChildren();
        if (nest != null) for (Widget c : nest) walkAndDim(c);
    }

    private boolean shouldDimMemoized(int rawItemId) {
        final int key = EnsouledHeadMapping.toTradeableId(rawItemId); // normalize cache key
        final Boolean cached = dimDecisionCache.get(key);
        if (cached != null) return cached;

        final boolean result = shouldDim(rawItemId);
        dimDecisionCache.put(key, result);
        return result;
    }

    private boolean shouldDim(int rawItemId) {
        final int mappedItemId = EnsouledHeadMapping.toTradeableId(rawItemId);
        final int canonicalItemId = canonicalize(mappedItemId);
        if (canonicalItemId <= 0) return false;
        if (!plugin.isInPlay(canonicalItemId)) return false;
        return !isUnlocked(mappedItemId, canonicalItemId);
    }

    private int canonicalize(int rawItemId) {
        try {
            return itemManager.canonicalize(rawItemId);
        } catch (Exception e) {
            // Fall back to the raw ID if canonicalization fails
            return rawItemId;
        }
    }

    private boolean isUnlocked(int normalizedItemId, int canonicalItemId) {
        if (unlockedItemsManager == null) return true; // fail open if manager missing

        try {
            // Fast paths: raw or canonical known unlocked
            if (normalizedItemId > 0 && unlockedItemsManager.isUnlocked(normalizedItemId)) return true;
            if (canonicalItemId > 0 && normalizedItemId != canonicalItemId && unlockedItemsManager.isUnlocked(canonicalItemId))
                return true;

            // Slower path: related ids (placeholders / noted variants)
            final Set<Integer> candidates = new LinkedHashSet<>(4);
            candidates.add(normalizedItemId);
            candidates.add(canonicalItemId);

            collectRelatedIds(normalizedItemId, candidates);
            if (canonicalItemId != normalizedItemId) {
                collectRelatedIds(canonicalItemId, candidates);
            }

            for (int id : candidates) {
                if (id > 0 && unlockedItemsManager.isUnlocked(id)) {
                    return true;
                }
            }
        } catch (Exception e) {
            return true; // fail open on unexpected errors
        }

        return false;
    }

    private void collectRelatedIds(int itemId, Set<Integer> sink) {
        if (itemId <= 0) return;

        try {
            final ItemComposition comp = itemManager.getItemComposition(itemId);
            if (comp == null) return;

            // Placeholder
            if (comp.getPlaceholderTemplateId() != -1) {
                sink.add(comp.getPlaceholderId());
            }

            // Noted/unnoted pair
            final int linkedNoteId = comp.getLinkedNoteId();
            if (linkedNoteId > 0 && linkedNoteId != itemId) {
                sink.add(linkedNoteId);
            }
        } catch (Exception ignored) {
            // ignore bad compositions, rely on other IDs
        }
    }

    private boolean isBankPlaceholderWidget(Widget w) {
        return w != null && w.getItemId() > 0 && w.getItemQuantity() == 0;
    }

}

package com.choicer.chanceman.ui;

import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.events.VarClientIntChanged;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.eventbus.Subscribe;

import javax.inject.Inject;
import javax.inject.Singleton;

@Slf4j
@Singleton
public class TabListener
{
    private final Client client;
    private final ClientThread clientThread;
    private final MusicWidgetController widgetController;

    @Inject
    public TabListener(
            Client client,
            ClientThread clientThread,
            MusicWidgetController widgetController
    )
    {
        this.client = client;
        this.clientThread = clientThread;
        this.widgetController = widgetController;
    }

    @Subscribe
    public void onVarClientIntChanged(VarClientIntChanged ev)
    {
        if (ev.getIndex() != 171) return;

        int newTab = client.getVarcIntValue(171);
        if (widgetController.isOverrideActive() && newTab != 13)
        {
            clientThread.invokeLater(widgetController::restore);
        }
        else if (!widgetController.isOverrideActive() && newTab == 13 && widgetController.hasData())
        {
            clientThread.invokeLater(() ->
                    widgetController.override(widgetController.getCurrentData())
            );
        }
    }
}

package com.choicer.chanceman.account;

import com.choicer.chanceman.managers.RolledItemsManager;
import com.choicer.chanceman.managers.UnlockedItemsManager;
import lombok.Getter;
import lombok.Setter;
import net.runelite.api.Client;
import net.runelite.api.GameState;
import net.runelite.api.Player;
import net.runelite.api.events.AccountHashChanged;
import net.runelite.api.events.ClientTick;
import net.runelite.api.events.GameStateChanged;
import net.runelite.client.eventbus.EventBus;
import net.runelite.client.eventbus.Subscribe;

import javax.inject.Inject;
import javax.inject.Singleton;

/**
 * Monitors for account changes and updates the stored display name.
 */
@Singleton
public class AccountManager
{

	@Inject
	private Client client;

	@Inject
	private UnlockedItemsManager unlockedItemsManager;

	@Inject
	private RolledItemsManager rolledItemsManager;

	@Inject
	private EventBus eventBus;

	private long hash = -1;
	@Getter @Setter private volatile String playerName;
	private boolean nameSet = false;

	public boolean ready() { return hash != -1 && nameSet; }

	public void init()
	{
		if (client.getGameState() == GameState.LOGGED_IN && client.getAccountHash() != -1)
		{
			hash = client.getAccountHash();
			nameSet = false;
		}
	}

	@Subscribe
	private void onAccountHashChanged(AccountHashChanged event)
	{
		long newHash = client.getAccountHash();
		if (hash != newHash)
		{
			hash = newHash;
			nameSet = false; // Player is null at this point, so name is set in onClientTick
		}
	}

	@Subscribe
	private void onClientTick(ClientTick event)
	{
		if (client.getGameState().getState() < GameState.LOADING.getState()) return;
		if (hash == -1) return;
		if (nameSet) return;

		Player player = client.getLocalPlayer();
		if (player == null) return;

		String name = player.getName();
		if (name == null) return;

		setPlayerName(name);
		nameSet = true;
		emit();
	}

	@Subscribe
	private void onGameStateChanged(GameStateChanged event)
	{
		if (event.getGameState() == GameState.LOGIN_SCREEN && hash != -1)
		{
			reset();
		}
	}

	public void reset() {
		hash = -1;
		setPlayerName(null);
		emit();
	}

	private void emit()
	{
		eventBus.post(new AccountChanged(hash, playerName));
	}
}

package com.choicer.chanceman.account;

import lombok.Getter;

@Getter
public class AccountChanged
{
	private final long hash;
	private final String playerName;
	private final boolean loggedIn;

	public AccountChanged(long hash, String playerName)
	{
		this.hash = hash;
		this.playerName = playerName;
		this.loggedIn = hash != -1;
	}

	@Override
	public String toString() {
		return "AccountChanged{" +
				"hash=" + hash +
				", playerName='" + playerName + '\'' +
				", loggedIn=" + loggedIn +
				'}';
	}
}

package com.choicer.chanceman;

import com.choicer.chanceman.account.AccountChanged;
import com.choicer.chanceman.account.AccountManager;
import com.choicer.chanceman.drops.DropFetcher;
import com.choicer.chanceman.drops.DropCache;
import com.choicer.chanceman.filters.EnsouledHeadMapping;
import com.choicer.chanceman.menus.ActionHandler;
import com.choicer.chanceman.filters.ItemsFilter;
import com.choicer.chanceman.filters.ItemAttributes;
import com.choicer.chanceman.filters.ItemEligibility;
import com.choicer.chanceman.ui.DropsTabUI;
import com.choicer.chanceman.ui.DropsTooltipOverlay;
import com.choicer.chanceman.ui.MusicWidgetController;
import com.choicer.chanceman.ui.NpcSearchService;
import com.choicer.chanceman.ui.MusicSearchButton;
import com.choicer.chanceman.ui.ItemDimmerController;
import com.google.gson.Gson;
import com.google.inject.Provides;
import lombok.Getter;
import lombok.extern.slf4j.Slf4j;
import com.choicer.chanceman.managers.RollAnimationManager;
import com.choicer.chanceman.managers.RolledItemsManager;
import com.choicer.chanceman.managers.UnlockedItemsManager;
import net.runelite.api.*;
import net.runelite.api.events.*;
import net.runelite.api.widgets.Widget;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.eventbus.EventBus;
import net.runelite.client.game.ItemManager;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.plugins.PluginDescriptor;
import net.runelite.client.ui.ClientToolbar;
import net.runelite.client.ui.NavigationButton;
import net.runelite.client.ui.overlay.OverlayManager;
import net.runelite.client.util.ImageUtil;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.config.ConfigManager;

import javax.inject.Inject;
import javax.swing.*;
import java.awt.image.BufferedImage;
import java.util.*;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

@Slf4j
@PluginDescriptor(
        name = "Choicer",
        description = "Extended ChanceMan with choices",
        tags = {"chance", "roll", "lock", "unlock", "luck", "game of chance", "goc", "choices"}
)
public class ChoicemanPlugin extends Plugin
{
    @Inject private Client client;
    @Inject private ClientThread clientThread;
    @Inject private ClientToolbar clientToolbar;
    @Inject private OverlayManager overlayManager;
    @Inject private ChatMessageManager chatMessageManager;
    @Getter @Inject private ItemManager itemManager;
    @Inject private ChanceManOverlay chanceManOverlay;
    @Inject private ChoicemanOverlay choicemanOverlay;
    @Inject private DropsTooltipOverlay dropsTooltipOverlay;
    @Inject private Gson gson;
    @Inject private ChanceManConfig config;
    @Inject private ConfigManager configManager;
    @Inject private AccountManager accountManager;
    @Inject private UnlockedItemsManager unlockedItemsManager;
    @Inject private RolledItemsManager rolledItemsManager;
    @Inject private RollAnimationManager rollAnimationManager;
    @Inject private EventBus eventBus;
    @Inject private ItemsFilter itemsFilter;
    @Inject private DropsTabUI dropsTabUI;
    @Inject private DropFetcher dropFetcher;
    @Inject private DropCache dropCache;
    @Inject private MusicWidgetController musicWidgetController;
    @Inject private NpcSearchService npcSearchService;
    @Inject private MusicSearchButton musicSearchButton;
    @Inject private ItemDimmerController itemDimmerController;

    private ChanceManPanel chanceManPanel;
    private NavigationButton navButton;
    private ExecutorService fileExecutor;
    @Getter private final HashSet<Integer> allTradeableItems = new LinkedHashSet<>();
    private static final int GE_SEARCH_BUILD_SCRIPT = 751;
    private boolean tradeableItemsInitialized = false;
    private boolean featuresActive = false;

    @Provides
    ChanceManConfig provideConfig(ConfigManager configManager)
    {
        return configManager.getConfig(ChanceManConfig.class);
    }

    @Override
    protected void startUp() throws Exception
    {
        eventBus.register(this);
        if (isNormalWorld()) enableFeatures();
    }

    @Override
    protected void shutDown() throws Exception
    {
        if (featuresActive) disableFeatures();
        eventBus.unregister(this);
    }

    private void enableFeatures()
    {
        if (featuresActive) return;
        featuresActive = true;

        getInjector().getInstance(ActionHandler.class).startUp();
        accountManager.init();
        dropFetcher.startUp();
        dropCache.startUp();
        dropCache.getAllNpcData();
        eventBus.register(accountManager);
        overlayManager.add(chanceManOverlay);
        overlayManager.add(choicemanOverlay);
        overlayManager.add(dropsTooltipOverlay);

        fileExecutor = Executors.newSingleThreadExecutor(r -> {
            Thread t = new Thread(r, "ChanceMan-FileIO");
            t.setDaemon(true);
            return t;
        });
        unlockedItemsManager.setExecutor(fileExecutor);
        rolledItemsManager.setExecutor(fileExecutor);

        if (accountManager.ready())
        {
            Runnable refreshPanel = () -> {
                if (chanceManPanel != null) {
                    SwingUtilities.invokeLater(chanceManPanel::updatePanel);
                }
                refreshDropsViewerIfOpen();
            };
            unlockedItemsManager.setOnChange(refreshPanel);
            rolledItemsManager.setOnChange(refreshPanel);

            unlockedItemsManager.loadUnlockedItems();
            rolledItemsManager.loadRolledItems();
        }

        itemDimmerController.setEnabled(config.dimLockedItemsEnabled());
        itemDimmerController.setDimOpacity(config.dimLockedItemsOpacity());
        eventBus.register(itemDimmerController);
        rollAnimationManager.startUp();
        dropsTabUI.startUp();

        chanceManPanel = new ChanceManPanel(
                unlockedItemsManager,
                rolledItemsManager,
                itemManager,
                allTradeableItems,
                clientThread,
                rollAnimationManager
        );
        rollAnimationManager.setChanceManPanel(chanceManPanel);

        SwingUtilities.invokeLater(chanceManPanel::updatePanel);

        if (accountManager.ready())
        {
            unlockedItemsManager.startWatching();
            rolledItemsManager.startWatching();
        }

        BufferedImage icon = ImageUtil.loadImageResource(
                getClass(), "/com/choicer/chanceman/icon.png"
        );
        navButton = NavigationButton.builder()
                .tooltip("ChanceMan")
                .icon(icon)
                .priority(5)
                .panel(chanceManPanel)
                .build();
        clientToolbar.addNavigation(navButton);

        eventBus.register(musicWidgetController);
        eventBus.register(musicSearchButton);
        musicSearchButton.onStart();
    }

    private void disableFeatures()
    {
        if (!featuresActive) return;
        featuresActive = false;

        try
        {
            if (unlockedItemsManager != null) unlockedItemsManager.stopWatching();
            if (rolledItemsManager != null)   rolledItemsManager.stopWatching();
            if (unlockedItemsManager != null) unlockedItemsManager.flushIfDirtyOnExit();
            if (rolledItemsManager != null) rolledItemsManager.flushIfDirtyOnExit();
        }
        catch (Exception ignored) { /* Non-fatal */ }

        clientThread.invokeLater(musicWidgetController::restore);
        musicSearchButton.onStop();
        eventBus.unregister(musicSearchButton);
        eventBus.unregister(musicWidgetController);
        dropsTabUI.shutDown();
        eventBus.unregister(itemDimmerController);
        eventBus.unregister(accountManager);
        getInjector().getInstance(ActionHandler.class).shutDown();

        if (clientToolbar != null && navButton != null)
        {
            clientToolbar.removeNavigation(navButton);
            navButton = null;
        }
        if (overlayManager != null)
        {
            overlayManager.remove(chanceManOverlay);
            overlayManager.remove(choicemanOverlay);
            overlayManager.remove(dropsTooltipOverlay);
        }
        if (rollAnimationManager != null)
        {
            rollAnimationManager.shutdown();
        }
        if (fileExecutor != null)
        {
            fileExecutor.shutdownNow();
            fileExecutor = null;

            if (unlockedItemsManager != null)
            {
                unlockedItemsManager.setExecutor(null);
                unlockedItemsManager.setOnChange(null);
            }
            if (rolledItemsManager != null)
            {
                rolledItemsManager.setExecutor(null);
                rolledItemsManager.setOnChange(null);
            }
        }
        dropFetcher.shutdown();
        dropCache.shutdown();

        // reset panel/tradeable state
        chanceManPanel = null;
        allTradeableItems.clear();
        tradeableItemsInitialized = false;
        accountManager.reset();
    }

    @Subscribe
    public void onWorldChanged(WorldChanged event)
    {
        if (isNormalWorld()) enableFeatures();
        else disableFeatures();
    }

    /** Refreshes the list of tradeable item IDs based on the current configuration. */
    public void refreshTradeableItems() {
        clientThread.invokeLater(() -> {
            Set<Integer> unlockedSnapshot = unlockedItemsManager.getUnlockedItems();
            allTradeableItems.clear();
            for (int i = 0; i < 40000; i++) {
                ItemComposition comp = itemManager.getItemComposition(i);
                if (isEligibleForLocking(i, comp, unlockedSnapshot)) {
                    allTradeableItems.add(i);
                }
            }
            rollAnimationManager.setAllTradeableItems(allTradeableItems);
            if (chanceManPanel != null) {
                SwingUtilities.invokeLater(() -> chanceManPanel.updatePanel());
            }
        });
    }

    @Subscribe
    public void onConfigChanged(net.runelite.client.events.ConfigChanged event)
    {
        if (!featuresActive) return;
        if (!event.getGroup().equals("chanceman")) return;
        switch (event.getKey())
        {
            case "freeToPlay":
            case "includeF2PTradeOnlyItems":
            case "enableFlatpacks":
            case "enableItemSets":
            case "requireWeaponPoison":
            case "includeUntradeable":
            case "includeQuestItems":
                refreshTradeableItems();
                break;
            case "showRareDropTable":
            case "showGemDropTable":
                dropCache.clearAllCaches();
                refreshDropsViewerIfOpen();
                break;
            case "sortDropsByRarity":
                refreshDropsViewerIfOpen();
                break;
            case "dimLockedItemsEnabled":
            case "dimLockedItemsOpacity":
                itemDimmerController.setEnabled(config.dimLockedItemsEnabled());
                itemDimmerController.setDimOpacity(config.dimLockedItemsOpacity());
                break;
        }
    }

    @Subscribe
    private void onAccountChanged(AccountChanged event)
    {
        if (!featuresActive) return;
        dropCache.pruneOldCaches();

        // Stop watchers around the reload
        unlockedItemsManager.stopWatching();
        rolledItemsManager.stopWatching();

        // Reload data
        unlockedItemsManager.loadUnlockedItems();
        rolledItemsManager.loadRolledItems();

        // Ensure UI reflects new account state
        if (chanceManPanel != null)
        {
            SwingUtilities.invokeLater(() -> chanceManPanel.updatePanel());
        }

        // Restart watchers
        unlockedItemsManager.startWatching();
        rolledItemsManager.startWatching();
    }

    @Subscribe
    public void onGameTick(GameTick event)
    {
        if (!featuresActive) return;
        if (!tradeableItemsInitialized && client.getGameState() == GameState.LOGGED_IN)
        {
            refreshTradeableItems();
            tradeableItemsInitialized = true;
        }

        rollAnimationManager.process();
    }

    @Subscribe
    public void onScriptPostFired(ScriptPostFired event)
    {
        if (!featuresActive) return;
        if (event.getScriptId() == GE_SEARCH_BUILD_SCRIPT) { killSearchResults(); }
    }

    private void killSearchResults() {
        Widget geSearchResults = client.getWidget(162, 51);
        if (geSearchResults == null) {
            return;
        }
        Widget[] children = geSearchResults.getDynamicChildren();
        if (children == null || children.length < 2 || children.length % 3 != 0) {
            return;
        }
        Set<Integer> unlocked = unlockedItemsManager.getUnlockedItems();
        Set<Integer> rolled = rolledItemsManager.getRolledItems();
        boolean requireRolled = config.requireRolledUnlockedForGe();
        for (int i = 0; i < children.length; i += 3) {
            int offerItemId = children[i + 2].getItemId();
            boolean isUnlocked = unlocked.contains(offerItemId);
            boolean isRolled = rolled.contains(offerItemId);
            boolean hide = requireRolled ? !(isUnlocked && isRolled) : !isUnlocked;
            if (hide) {
                children[i].setHidden(true);
                children[i + 1].setOpacity(70);
                children[i + 2].setOpacity(70);
            }
        }
    }

    @Subscribe
    public void onItemSpawned(ItemSpawned event)
    {
        if (!featuresActive) return;
        if (!accountManager.ready()) return;

        TileItem tileItem = (TileItem) event.getItem();
        int itemId = EnsouledHeadMapping.toTradeableId(tileItem.getId());
        int canonicalItemId = itemManager.canonicalize(itemId);
        if (!isEligibleForLocking(canonicalItemId))
        {
            return;
        }
        if (tileItem.getOwnership() != TileItem.OWNERSHIP_SELF)
        {
            return;
        }
        if (rolledItemsManager == null)
        {
            return;
        }
        if (!rolledItemsManager.isRolled(canonicalItemId))
        {
            rollAnimationManager.enqueueRoll(canonicalItemId);
            rolledItemsManager.markRolled(canonicalItemId);
            refreshDropsViewerIfOpen();
        }
    }

    @Subscribe
    public void onItemContainerChanged(ItemContainerChanged event)
    {
        if (!featuresActive) return;
        if (!accountManager.ready()) return;

        if (event.getContainerId() == 93)
        {
            Set<Integer> processed = new HashSet<>();
            for (net.runelite.api.Item item : event.getItemContainer().getItems())
            {
                int rawItemId = item.getId();
                int mapped = EnsouledHeadMapping.toTradeableId(rawItemId);
                int canonicalId = itemManager.canonicalize(mapped);
                if (!isEligibleForLocking(canonicalId))
                {
                    continue;
                }
                if (!processed.contains(canonicalId) && !rolledItemsManager.isRolled(canonicalId))
                {
                    rollAnimationManager.enqueueRoll(canonicalId);
                    rolledItemsManager.markRolled(canonicalId);
                    processed.add(canonicalId);
                }
            }
            if (!processed.isEmpty()) refreshDropsViewerIfOpen();
        }
    }

    public boolean isNormalWorld()
    {
        EnumSet<WorldType> worldTypes = client.getWorldType();
        return !(worldTypes.contains(WorldType.DEADMAN)
                || worldTypes.contains(WorldType.SEASONAL)
                || worldTypes.contains(WorldType.BETA_WORLD)
                || worldTypes.contains(WorldType.PVP_ARENA)
                || worldTypes.contains(WorldType.QUEST_SPEEDRUNNING)
                || worldTypes.contains(WorldType.TOURNAMENT_WORLD));
    }

    private void refreshDropsViewerIfOpen()
    {
        if (musicWidgetController != null
                && musicWidgetController.hasData()
                && musicWidgetController.getCurrentData() != null)
        {
            musicWidgetController.override(musicWidgetController.getCurrentData());
        }
    }

    public boolean isTradeable(int itemId)
    {
        ItemComposition comp = itemManager.getItemComposition(itemId);
        return comp != null && comp.isTradeable();
    }

    private boolean isEligibleForLocking(int itemId)
    {
        ItemComposition comp = itemManager.getItemComposition(itemId);
        return isEligibleForLocking(itemId, comp);
    }

    private boolean isEligibleForLocking(int itemId, ItemComposition comp)
    {
        return isEligibleForLocking(itemId, comp, null);
    }

    private boolean isEligibleForLocking(int itemId, ItemComposition comp, Set<Integer> unlockedSnapshot)
    {
        if (comp == null)
        {
            return false;
        }
        int canonicalItemId = itemManager.canonicalize(itemId);
        Set<Integer> unlocked = unlockedSnapshot != null ? unlockedSnapshot : unlockedItemsManager.getUnlockedItems();
        ItemAttributes attributes = ItemAttributes.from(comp);
        return ItemEligibility.shouldInclude(
                attributes,
                itemId,
                canonicalItemId,
                config,
                unlocked,
                this::isNotTracked
        );
    }

    public boolean isNotTracked(int itemId)
    {
        return itemId == 995 || itemId == 13191 || itemId == 13190 ||
                itemId == 7587 || itemId == 7588 || itemId == 7589 || itemId == 7590 || itemId == 7591;
    }

    public boolean isInPlay(int itemId)
    {
        return allTradeableItems.contains(itemId);
    }
}

package com.choicer.chanceman;

import com.choicer.chanceman.managers.RollAnimationManager;
import com.choicer.chanceman.managers.RolledItemsManager;
import com.choicer.chanceman.managers.UnlockedItemsManager;
import net.runelite.api.ItemComposition;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.game.ItemManager;
import net.runelite.client.ui.PluginPanel;
import net.runelite.client.util.LinkBrowser;

import javax.swing.*;
import javax.swing.DefaultListModel;
import javax.swing.JList;
import javax.swing.JScrollPane;
import javax.swing.ListSelectionModel;
import javax.swing.ListCellRenderer;
import javax.swing.SwingUtilities;
import javax.swing.border.*;
import java.awt.Component;
import java.awt.*;
import java.awt.event.KeyAdapter;
import java.awt.event.KeyEvent;
import java.awt.image.BufferedImage;
import java.util.*;
import java.util.List;
import java.util.function.Consumer;

/**
 * Panel for displaying rolled and unlocked items.
 * It provides UI for manual roll actions, search/filter functionality,
 * and displays each item with its icon and full item name.
 * Each item panel shows a tooltip on both the icon and the panel with the item name.
 */
public class ChanceManPanel extends PluginPanel
{
    private final UnlockedItemsManager unlockedItemsManager;
    private final RolledItemsManager rolledItemsManager;
    private final ItemManager itemManager;
    private final HashSet<Integer> allTradeableItems;
    private final ClientThread clientThread;
    private final RollAnimationManager rollAnimationManager;

    // Caches for item icons and names
    private final Map<Integer, ImageIcon> itemIconCache = new HashMap<>();
    private final Map<Integer, String> itemNameCache = new HashMap<>();

    // CardLayout panel to show either Rolled or Unlocked view
    private final JPanel centerCardPanel = new JPanel(new CardLayout());
    private final DefaultListModel<Integer> rolledModel = new DefaultListModel<>();
    private final JList<Integer> rolledList = new JList<>(rolledModel);
    private final DefaultListModel<Integer> unlockedModel = new DefaultListModel<>();
    private final JList<Integer> unlockedList = new JList<>(unlockedModel);

    // View selection row: 3 buttons (swap, filter unlocked-not-rolled, filter unlocked-and-rolled)
    private final JButton swapViewButton = new JButton("🔄");
    private final JToggleButton filterUnlockedNotRolledButton = new JToggleButton("🔓");
    private final JToggleButton filterUnlockedAndRolledButton = new JToggleButton("🔀");

    // Flag for current view: true = showing Unlocked, false = showing Rolled
    private boolean showingUnlocked = true;

    // Search text
    private String searchText = "";

    // Single count label at the bottom
    private final JLabel countLabel = new JLabel("Unlocked: 0/0");

    // Roll button for manual roll actions
    private final JButton rollButton = new JButton("Roll");

    // Active filter: "NONE", "UNLOCKED_NOT_ROLLED", or "UNLOCKED_AND_ROLLED"
    private String activeFilter = "NONE";

    // Join Discord Button links to discord invite
    private final JButton discordButton = new JButton();

    // Default color for item text
    private final Color defaultItemTextColor = new Color(220, 220, 220);

    /**
     * Constructs a ChanceManPanel.
     *
     * @param unlockedItemsManager Manager for unlocked items.
     * @param rolledItemsManager   Manager for rolled items.
     * @param itemManager          The item manager.
     * @param allTradeableItems    List of all tradeable item IDs.
     * @param clientThread         The client thread for scheduling UI updates.
     * @param rollAnimationManager The roll animation manager to trigger animations.
     */
    public ChanceManPanel(
            UnlockedItemsManager unlockedItemsManager,
            RolledItemsManager rolledItemsManager,
            ItemManager itemManager,
            HashSet<Integer> allTradeableItems,
            ClientThread clientThread,
            RollAnimationManager rollAnimationManager
    )
    {
        this.unlockedItemsManager = unlockedItemsManager;
        this.rolledItemsManager = rolledItemsManager;
        this.itemManager = itemManager;
        this.allTradeableItems = allTradeableItems;
        this.clientThread = clientThread;
        this.rollAnimationManager = rollAnimationManager;
        init();
    }

    /**
     * Initializes the panel UI components.
     */
    private void init()
    {
        setLayout(new BorderLayout());
        setBorder(new EmptyBorder(15, 15, 15, 15));
        setBackground(new Color(37, 37, 37));

        // ========== TOP PANEL (Header, Search, Buttons Row) ==========
        JPanel topPanel = new JPanel();
        topPanel.setLayout(new BoxLayout(topPanel, BoxLayout.Y_AXIS));
        topPanel.setOpaque(false);

        // Header
        topPanel.add(buildHeaderPanel());
        topPanel.add(Box.createVerticalStrut(10));

        // Search Bar
        topPanel.add(buildSearchBar());
        topPanel.add(Box.createVerticalStrut(10));

        // Button row: 3 columns, each for one button
        JPanel buttonRowPanel = new JPanel(new GridLayout(1, 3, 10, 0));
        buttonRowPanel.setOpaque(false);

        // Style the 3 buttons identically
        styleButton(swapViewButton);
        styleToggleButton(filterUnlockedNotRolledButton);
        styleToggleButton(filterUnlockedAndRolledButton);

        // Tooltips & actions
        swapViewButton.setToolTipText("Swap between Unlocked and Rolled views");
        swapViewButton.addActionListener(e -> toggleView());

        filterUnlockedNotRolledButton.setToolTipText("Filter: Show items that are unlocked but not rolled");
        filterUnlockedNotRolledButton.addActionListener(e ->
        {
            if (filterUnlockedNotRolledButton.isSelected())
            {
                activeFilter = "UNLOCKED_NOT_ROLLED";
                filterUnlockedAndRolledButton.setSelected(false);
            }
            else
            {
                activeFilter = "NONE";
            }
            updatePanel();
        });

        filterUnlockedAndRolledButton.setToolTipText("Filter: Show items that are both unlocked and rolled");
        filterUnlockedAndRolledButton.addActionListener(e ->
        {
            if (filterUnlockedAndRolledButton.isSelected())
            {
                activeFilter = "UNLOCKED_AND_ROLLED";
                filterUnlockedNotRolledButton.setSelected(false);
            }
            else
            {
                activeFilter = "NONE";
            }
            updatePanel();
        });

        // Add them in left->right order
        buttonRowPanel.add(swapViewButton);
        buttonRowPanel.add(filterUnlockedNotRolledButton);
        buttonRowPanel.add(filterUnlockedAndRolledButton);

        // Add the row to the top panel
        topPanel.add(buttonRowPanel);

        // EXTRA SPACE between the buttons row and the icon panel
        topPanel.add(Box.createVerticalStrut(10));

        add(topPanel, BorderLayout.NORTH);

        // ========== CENTER PANEL (CardLayout) ==========
        rolledList.setCellRenderer(new ItemCellRenderer());
        rolledList.setVisibleRowCount(10);
        rolledList.setSelectionMode(ListSelectionModel.SINGLE_SELECTION);
        JScrollPane rolledScroll = new JScrollPane(
                rolledList,
                JScrollPane.VERTICAL_SCROLLBAR_AS_NEEDED,
                JScrollPane.HORIZONTAL_SCROLLBAR_NEVER
        );
        rolledScroll.setPreferredSize(new Dimension(250, 300));
        JPanel rolledContainer = createTitledPanel("Rolled Items", rolledScroll);

        // Use a custom cell renderer that can handle long text
        unlockedList.setCellRenderer(new ItemCellRenderer());
        unlockedList.setSelectionMode(ListSelectionModel.SINGLE_SELECTION);
        unlockedList.setLayoutOrientation(JList.VERTICAL);
        unlockedList.setVisibleRowCount(-1);
        
        // Create a scroll pane with horizontal scrolling enabled
        JScrollPane unlockedScroll = new JScrollPane(
            unlockedList,
            JScrollPane.VERTICAL_SCROLLBAR_AS_NEEDED,
            JScrollPane.HORIZONTAL_SCROLLBAR_AS_NEEDED
        );
        unlockedScroll.setPreferredSize(new Dimension(250, 300)); // Set a reasonable default size
        unlockedScroll.setWheelScrollingEnabled(true);
        JPanel unlockedContainer = createTitledPanel("Unlocked Items", unlockedScroll);

        centerCardPanel.add(rolledContainer, "ROLLED");
        centerCardPanel.add(unlockedContainer, "UNLOCKED");
        add(centerCardPanel, BorderLayout.CENTER);

        // ========== BOTTOM PANEL (Count + Roll) ==========
        JPanel bottomPanel = new JPanel();
        bottomPanel.setLayout(new BoxLayout(bottomPanel, BoxLayout.Y_AXIS));
        bottomPanel.setOpaque(false);

        // Single count label
        JPanel countPanel = new JPanel(new FlowLayout(FlowLayout.CENTER, 0, 0));
        countPanel.setOpaque(false);
        countLabel.setFont(new Font("Arial", Font.BOLD, 11));
        countLabel.setForeground(new Color(220, 220, 220));
        countPanel.add(countLabel);
        bottomPanel.add(countPanel);
        bottomPanel.add(Box.createVerticalStrut(10));

        // Roll button
        JPanel rollButtonPanel = new JPanel(new FlowLayout(FlowLayout.CENTER));
        rollButtonPanel.setOpaque(false);
        rollButton.setPreferredSize(new Dimension(100, 30));
        rollButton.setFocusPainted(false);
        rollButton.setBackground(new Color(60, 63, 65));
        rollButton.setForeground(Color.WHITE);
        rollButton.setFont(new Font("SansSerif", Font.BOLD, 12));
        rollButton.addActionListener(this::performManualRoll);
        rollButtonPanel.add(rollButton);
        bottomPanel.add(rollButtonPanel);

        add(bottomPanel, BorderLayout.SOUTH);

        // Default to Unlocked view
        showingUnlocked = true;
        ((CardLayout) centerCardPanel.getLayout()).show(centerCardPanel, "UNLOCKED");
        updatePanel();
    }

    /**
     * Renders each item ID as an icon + name in the JList.
     */
    private class ItemCellRenderer extends JPanel implements ListCellRenderer<Integer>
    {
        private final JLabel iconLabel = new JLabel();
        private final JLabel nameLabel = new JLabel();
        private final int PREFERRED_HEIGHT = 32; // Height for each row

        public ItemCellRenderer()
        {
            setLayout(new BorderLayout(5, 0));
            setOpaque(true);
            add(iconLabel, BorderLayout.WEST);
            add(nameLabel, BorderLayout.CENTER);
            nameLabel.setFont(new Font("SansSerif", Font.PLAIN, 11));
        }

        @Override
        public Dimension getPreferredSize()
        {
            Dimension preferred = super.getPreferredSize();
            preferred.height = PREFERRED_HEIGHT;
            return preferred;
        }

        @Override
        public Component getListCellRendererComponent(JList<? extends Integer> list,
                                                      Integer itemId,
                                                      int index,
                                                      boolean isSelected,
                                                      boolean cellHasFocus)
        {
            // icon
            iconLabel.setIcon(getItemIcon(itemId));

            // name (async load if missing)
            String name = itemNameCache.get(itemId);
            if (name == null)
            {
                nameLabel.setText("Loading…");
                getItemNameAsync(itemId, n ->
                {
                    itemNameCache.put(itemId, n);
                    list.repaint(list.getCellBounds(index, index));
                });
            }
            else
            {
                nameLabel.setText(name);
            }

            // selection styling
            if (isSelected)
            {
                setBackground(list.getSelectionBackground());
                setForeground(list.getSelectionForeground());
            }
            else
            {
                setBackground(new Color(60, 63, 65));
                nameLabel.setForeground(defaultItemTextColor);
            }

            // Let Swing compute width from the label's preferred size
            nameLabel.setPreferredSize(null);
            setPreferredSize(null);

            return this;
        }
    }

    /**
     * Toggles between Unlocked view and Rolled view.
     */
    private void toggleView()
    {
        showingUnlocked = !showingUnlocked;
        CardLayout cl = (CardLayout) centerCardPanel.getLayout();
        if (showingUnlocked)
        {
            cl.show(centerCardPanel, "UNLOCKED");
        }
        else
        {
            cl.show(centerCardPanel, "ROLLED");
        }
        updatePanel();
    }

    /**
     * Creates a titled container panel that wraps the given content panel.
     *
     * @param title        The title to display on the border.
     * @return The container panel.
     */
    private JPanel createTitledPanel(String title, Component content)
    {
        JPanel container = new JPanel(new BorderLayout());
        container.setOpaque(false);

        Border line = new LineBorder(new Color(80, 80, 80));
        Border empty = new EmptyBorder(5, 5, 5, 5);
        TitledBorder titled = BorderFactory.createTitledBorder(line, title);
        titled.setTitleColor(new Color(200, 200, 200));
        container.setBorder(new CompoundBorder(titled, empty));

        // Wrap content in a panel with FlowLayout to prevent horizontal stretching
        JPanel contentWrapper = new JPanel(new BorderLayout());
        contentWrapper.setOpaque(false);
        contentWrapper.add(content, BorderLayout.CENTER);
        
        // Add the wrapper to the container
        container.add(contentWrapper, BorderLayout.CENTER);
        return container;
    }

    /**
     * Styles a general JButton to match the design.
     *
     * @param button The button to style.
     */
    private void styleButton(JButton button)
    {
        button.setFocusPainted(false);
        button.setBackground(new Color(60, 63, 65));
        button.setForeground(Color.WHITE);
        button.setFont(new Font("SansSerif", Font.BOLD, 12));
        button.setPreferredSize(new Dimension(50, 30));
    }

    /**
     * Styles a JToggleButton to match the design.
     *
     * @param button The toggle button to style.
     */
    private void styleToggleButton(JToggleButton button)
    {
        button.setFocusPainted(false);
        button.setBackground(new Color(60, 63, 65));
        button.setForeground(Color.WHITE);
        button.setFont(new Font("SansSerif", Font.BOLD, 12));
        button.setPreferredSize(new Dimension(50, 30));
    }

    /**
     * Builds the header panel with an icon and title.
     *
     * @return The header panel.
     */
    private JPanel buildHeaderPanel()
    {
        JPanel headerPanel = new JPanel(new FlowLayout(FlowLayout.LEFT));
        headerPanel.setOpaque(false);

        // Header icon
        ImageIcon headerIcon = new ImageIcon(getClass().getResource("/com/choicer/chanceman/icon.png"));
        JLabel iconLabel = new JLabel(headerIcon);

        // Title label
        JLabel titleLabel = new JLabel("Chance Man");
        titleLabel.setFont(new Font("SansSerif", Font.BOLD, 18));
        titleLabel.setForeground(new Color(220, 220, 220));

        // Create the Discord button
        JButton discordButton = new JButton();
        discordButton.setToolTipText("Join The Chance Man Discord");
        // Scale the Discord icon to 16x16
        ImageIcon discordIcon = new ImageIcon(getClass().getResource("/com/choicer/chanceman/discord.png"));
        Image scaledImage = discordIcon.getImage().getScaledInstance(20, 20, Image.SCALE_SMOOTH);
        discordButton.setIcon(new ImageIcon(scaledImage));
        // Make the button look flat (no border or background)
        discordButton.setOpaque(false);
        discordButton.setContentAreaFilled(false);
        discordButton.setBorderPainted(false);
        // Add an action to open the Discord link
        discordButton.addActionListener(e -> LinkBrowser.browse("https://discord.gg/TMkAYXxncU"));

        // Assemble the header panel
        headerPanel.add(iconLabel);
        headerPanel.add(Box.createHorizontalStrut(10));
        headerPanel.add(titleLabel);
        headerPanel.add(discordButton);

        return headerPanel;
    }

    /**
     * Builds the search bar panel.
     *
     * @return The search bar panel.
     */
    private JPanel buildSearchBar()
    {
        JPanel searchBarPanel = new JPanel(new BorderLayout());
        searchBarPanel.setOpaque(false);
        searchBarPanel.setBorder(new EmptyBorder(5, 5, 5, 5));

        JPanel searchContainer = new JPanel(new BorderLayout());
        searchContainer.setBackground(new Color(30, 30, 30));
        searchContainer.setBorder(BorderFactory.createEmptyBorder(2, 5, 2, 5));

        // Search icon
        JLabel searchIcon = new JLabel("\uD83D\uDD0D");
        searchIcon.setForeground(new Color(200, 200, 200));
        searchIcon.setBorder(new EmptyBorder(0, 5, 0, 5));
        searchContainer.add(searchIcon, BorderLayout.WEST);

        // Search field
        JTextField searchField = new JTextField();
        searchField.setBackground(new Color(45, 45, 45));
        searchField.setForeground(Color.WHITE);
        searchField.setBorder(null);
        searchField.setCaretColor(Color.WHITE);
        searchField.setMaximumSize(new Dimension(Integer.MAX_VALUE, 24));
        searchField.addKeyListener(new KeyAdapter()
        {
            @Override
            public void keyReleased(KeyEvent e)
            {
                SwingUtilities.invokeLater(() ->
                {
                    searchText = searchField.getText().toLowerCase();
                    updatePanel();
                });
            }
        });
        searchContainer.add(searchField, BorderLayout.CENTER);

        // Clear label to reset search
        JLabel clearLabel = new JLabel("❌");
        clearLabel.setFont(new Font("SansSerif", Font.PLAIN, 9));
        clearLabel.setForeground(Color.RED);
        clearLabel.setBorder(new EmptyBorder(0, 6, 0, 6));
        clearLabel.setCursor(Cursor.getPredefinedCursor(Cursor.HAND_CURSOR));
        clearLabel.addMouseListener(new java.awt.event.MouseAdapter()
        {
            @Override
            public void mouseClicked(java.awt.event.MouseEvent e)
            {
                searchField.setText("");
                searchText = "";
                updatePanel();
            }
        });
        searchContainer.add(clearLabel, BorderLayout.EAST);

        searchBarPanel.add(searchContainer, BorderLayout.CENTER);
        return searchBarPanel;
    }

    /**
     * Triggers a manual roll animation when the Roll button is clicked.
     *
     * @param e The action event.
     */
    private void performManualRoll(java.awt.event.ActionEvent e)
    {
        if (rollAnimationManager.isRolling())
        {
            return;
        }
        List<Integer> locked = new ArrayList<>();
        for (int id : allTradeableItems)
        {
            if (!unlockedItemsManager.isUnlocked(id))
            {
                locked.add(id);
            }
        }
        if (locked.isEmpty())
        {
            JOptionPane.showMessageDialog(
                    this,
                    "All items are unlocked!",
                    "ChanceMan",
                    JOptionPane.INFORMATION_MESSAGE
            );
            return;
        }
        int randomItemId = locked.get(new Random().nextInt(locked.size()));
        rollAnimationManager.setManualRoll(true);
        rollAnimationManager.enqueueRoll(randomItemId);
    }

    /**
     * Main update routine: filters the active set (Unlocked or Rolled), applies search text and filter toggles,
     * updates the single count label, and then builds the item list without trailing gaps.
     */
    public void updatePanel()
    {
        clientThread.invokeLater(() ->
        {
            // Build filtered lists
            List<Integer> filteredRolled = new ArrayList<>();
            for (Integer id : rolledItemsManager.getRolledItems())
            {
                ItemComposition comp = itemManager.getItemComposition(id);
                String sanitizedName = sanitizeItemName(comp != null ? comp.getName() : null);
                if (sanitizedName == null)
                {
                    continue;
                }
                String lowerName = sanitizedName.toLowerCase();
                if (searchText.isEmpty() || lowerName.contains(searchText))
                {
                    filteredRolled.add(id);
                }
            }

            Collections.reverse(filteredRolled);

            List<Integer> filteredUnlocked = new ArrayList<>();
            for (Integer id : unlockedItemsManager.getUnlockedItems())
            {
                ItemComposition comp = itemManager.getItemComposition(id);
                String sanitizedName = sanitizeItemName(comp != null ? comp.getName() : null);
                if (sanitizedName == null)
                {
                    continue;
                }
                String lowerName = sanitizedName.toLowerCase();
                if (searchText.isEmpty() || lowerName.contains(searchText))
                {
                    filteredUnlocked.add(id);
                }
            }

            Collections.reverse(filteredUnlocked);

            // Apply active filter toggles
            if (activeFilter.equals("UNLOCKED_NOT_ROLLED"))
            {
                filteredUnlocked.removeIf(id -> rolledItemsManager.getRolledItems().contains(id));
                filteredRolled.clear();
            }
            else if (activeFilter.equals("UNLOCKED_AND_ROLLED"))
            {
                filteredUnlocked.removeIf(id -> !rolledItemsManager.getRolledItems().contains(id));
                filteredRolled.removeIf(id -> !unlockedItemsManager.getUnlockedItems().contains(id));
            }

            SwingUtilities.invokeLater(() ->
            {
                rolledModel.clear();
                for (int id : filteredRolled)
                {
                    rolledModel.addElement(id);
                }

                unlockedModel.clear();
                for (int id : filteredUnlocked)
                {
                    unlockedModel.addElement(id);
                }

                int total = allTradeableItems.size();
                countLabel.setText(showingUnlocked
                        ? "Unlocked: " + unlockedModel.size() + "/" + total
                        : "Rolled:  " + rolledModel.size()   + "/" + total);
            });
        });
    }

    /**
     * Retrieves (and caches) the item icon for a given item ID.
     *
     * @param itemId The item ID.
     * @return The ImageIcon for the item, or null if not available.
     */
    private ImageIcon getItemIcon(int itemId)
    {
        if (itemIconCache.containsKey(itemId))
        {
            return itemIconCache.get(itemId);
        }
        BufferedImage image = itemManager.getImage(itemId, 1, false);
        if (image == null)
        {
            return null;
        }
        ImageIcon icon = new ImageIcon(image);
        itemIconCache.put(itemId, icon);
        return icon;
    }

    /**
     * Asynchronously retrieves the item name for a given item ID and passes it to the callback.
     *
     * @param itemId   The item ID.
     * @param callback Consumer to receive the item name.
     */
    private void getItemNameAsync(int itemId, Consumer<String> callback)
    {
        clientThread.invokeLater(() -> {
            ItemComposition comp = itemManager.getItemComposition(itemId);
            String name = sanitizeItemName(comp != null ? comp.getName() : null);
            SwingUtilities.invokeLater(() -> callback.accept(name != null ? name : "Unknown"));
        });
    }

    private String sanitizeItemName(String rawName)
    {
        if (rawName == null)
        {
            return null;
        }
        String trimmed = rawName.trim();
        if (trimmed.isEmpty()
                || trimmed.equalsIgnoreCase("null")
                || trimmed.equalsIgnoreCase("Members")
                || trimmed.equalsIgnoreCase("(Members)")
                || trimmed.matches("(?i)null\\s*\\(Members\\)"))
        {
            return null;
        }
        return trimmed;
    }
}

package com.choicer.chanceman.filters;

import net.runelite.api.ItemComposition;

/**
 * Immutable snapshot of the minimal item metadata needed when evaluating
 * whether an item can participate in ChanceMan rolls.
 */
public final class ItemAttributes
{
    private final String name;
    private final boolean tradeable;
    private final boolean members;
    private final int placeholderTemplateId;

    public ItemAttributes(String name, boolean tradeable, boolean members, int placeholderTemplateId)
    {
        this.name = name;
        this.tradeable = tradeable;
        this.members = members;
        this.placeholderTemplateId = placeholderTemplateId;
    }

    public static ItemAttributes from(ItemComposition comp)
    {
        return new ItemAttributes(
                comp.getName(),
                comp.isTradeable(),
                comp.isMembers(),
                comp.getPlaceholderTemplateId()
        );
    }

    public String getName()
    {
        return name;
    }

    public boolean isTradeable()
    {
        return tradeable;
    }

    public boolean isMembers()
    {
        return members;
    }

    public int getPlaceholderTemplateId()
    {
        return placeholderTemplateId;
    }
}

package com.choicer.chanceman.filters;

import lombok.Getter;
import net.runelite.api.gameval.ItemID;
import java.util.Collections;
import java.util.HashSet;
import java.util.Set;

/**
 * Enum representing every poisonable weapon and its four variants:
 *   - Base (unpoisoned)
 *   - (p)
 *   - (p+)
 *   - (p++)
 */
@Getter
public enum PoisonWeapons {
    // Global prerequisites for poisonable weapons
    WEAPON_POISON(ItemID.WEAPON_POISON),
    WEAPON_POISON_(ItemID.WEAPON_POISON_),
    WEAPON_POISON__(ItemID.WEAPON_POISON__),

    // --- Daggers ---
    BRONZE_DAGGER(ItemID.BRONZE_DAGGER, ItemID.BRONZE_DAGGER_P, ItemID.BRONZE_DAGGER_P_, ItemID.BRONZE_DAGGER_P__),
    IRON_DAGGER(ItemID.IRON_DAGGER, ItemID.IRON_DAGGER_P, ItemID.IRON_DAGGER_P_, ItemID.IRON_DAGGER_P__),
    BONE_DAGGER(ItemID.DTTD_BONE_DAGGER, ItemID.DTTD_BONE_DAGGER_P, ItemID.DTTD_BONE_DAGGER_P_,
            ItemID.DTTD_BONE_DAGGER_P__),
    BLACK_DAGGER(ItemID.BLACK_DAGGER, ItemID.BLACK_DAGGER_P, ItemID.BLACK_DAGGER_P_, ItemID.BLACK_DAGGER_P__),
    WHITE_DAGGER(ItemID.WHITE_DAGGER, ItemID.WHITE_DAGGER_P, ItemID.WHITE_DAGGER_P_, ItemID.WHITE_DAGGER_P__),
    STEEL_DAGGER(ItemID.STEEL_DAGGER, ItemID.STEEL_DAGGER_P, ItemID.STEEL_DAGGER_P_, ItemID.STEEL_DAGGER_P__),
    MITHRIL_DAGGER(ItemID.MITHRIL_DAGGER, ItemID.MITHRIL_DAGGER_P, ItemID.MITHRIL_DAGGER_P_, ItemID.MITHRIL_DAGGER_P__),
    ADAMANT_DAGGER(ItemID.ADAMANT_DAGGER, ItemID.ADAMANT_DAGGER_P, ItemID.ADAMANT_DAGGER_P_, ItemID.ADAMANT_DAGGER_P__),
    RUNE_DAGGER(ItemID.RUNE_DAGGER, ItemID.RUNE_DAGGER_P, ItemID.RUNE_DAGGER_P_, ItemID.RUNE_DAGGER_P__),
    DRAGON_DAGGER(ItemID.DRAGON_DAGGER, ItemID.DRAGON_DAGGER_P, ItemID.DRAGON_DAGGER_P_, ItemID.DRAGON_DAGGER_P__),
    ABYSSAL_DAGGER(ItemID.ABYSSAL_DAGGER, ItemID.ABYSSAL_DAGGER_P, ItemID.ABYSSAL_DAGGER_P_, ItemID.ABYSSAL_DAGGER_P__),

    // --- Javelins ---
    BRONZE_JAVELIN(ItemID.BRONZE_JAVELIN, ItemID.BRONZE_JAVELIN_P, ItemID.BRONZE_JAVELIN_P_, ItemID.BRONZE_JAVELIN_P__),
    IRON_JAVELIN(ItemID.IRON_JAVELIN, ItemID.IRON_JAVELIN_P, ItemID.IRON_JAVELIN_P_, ItemID.IRON_JAVELIN_P__),
    STEEL_JAVELIN(ItemID.STEEL_JAVELIN, ItemID.STEEL_JAVELIN_P, ItemID.STEEL_JAVELIN_P_, ItemID.STEEL_JAVELIN_P__),
    MITHRIL_JAVELIN(ItemID.MITHRIL_JAVELIN, ItemID.MITHRIL_JAVELIN_P, ItemID.MITHRIL_JAVELIN_P_,
            ItemID.MITHRIL_JAVELIN_P__),
    ADAMANT_JAVELIN(ItemID.ADAMANT_JAVELIN, ItemID.ADAMANT_JAVELIN_P, ItemID.ADAMANT_JAVELIN_P_,
            ItemID.ADAMANT_JAVELIN_P__),
    RUNE_JAVELIN(ItemID.RUNE_JAVELIN, ItemID.RUNE_JAVELIN_P, ItemID.RUNE_JAVELIN_P_, ItemID.RUNE_JAVELIN_P__),
    DRAGON_JAVELIN(ItemID.DRAGON_JAVELIN, ItemID.DRAGON_JAVELIN_P, ItemID.DRAGON_JAVELIN_P_, ItemID.DRAGON_JAVELIN_P__),
    AMETHYST_JAVELIN(ItemID.AMETHYST_JAVELIN, ItemID.AMETHYST_JAVELIN_P, ItemID.AMETHYST_JAVELIN_P_,
            ItemID.AMETHYST_JAVELIN_P__),

    // --- Spears ---
    BRONZE_SPEAR(ItemID.BRONZE_SPEAR, ItemID.BRONZE_SPEAR_P, ItemID.BRONZE_SPEAR_P_, ItemID.BRONZE_SPEAR_P__),
    IRON_SPEAR(ItemID.IRON_SPEAR, ItemID.IRON_SPEAR_P, ItemID.IRON_SPEAR_P_, ItemID.IRON_SPEAR_P__),
    BLACK_SPEAR(ItemID.BLACK_SPEAR, ItemID.BLACK_SPEAR_P, ItemID.BLACK_SPEAR_P_, ItemID.BLACK_SPEAR_P__),
    STEEL_SPEAR(ItemID.STEEL_SPEAR, ItemID.STEEL_SPEAR_P, ItemID.STEEL_SPEAR_P_, ItemID.STEEL_SPEAR_P__),
    MITHRIL_SPEAR(ItemID.MITHRIL_SPEAR, ItemID.MITHRIL_SPEAR_P, ItemID.MITHRIL_SPEAR_P_, ItemID.MITHRIL_SPEAR_P__),
    ADAMANT_SPEAR(ItemID.ADAMANT_SPEAR, ItemID.ADAMANT_SPEAR_P, ItemID.ADAMANT_SPEAR_P_, ItemID.ADAMANT_SPEAR_P__),
    RUNE_SPEAR(ItemID.RUNE_SPEAR, ItemID.RUNE_SPEAR_P, ItemID.RUNE_SPEAR_P_, ItemID.RUNE_SPEAR_P__),
    DRAGON_SPEAR(ItemID.DRAGON_SPEAR, ItemID.DRAGON_SPEAR_P, ItemID.DRAGON_SPEAR_P_, ItemID.DRAGON_SPEAR_P__),

    // --- Hastas ---
    BRONZE_HASTA(ItemID.BRUT_BRONZE_SPEAR, ItemID.BRUT_BRONZE_SPEAR_P, ItemID.BRUT_BRONZE_SPEAR_P_,
            ItemID.BRUT_BRONZE_SPEAR_P__),
    IRON_HASTA(ItemID.BRUT_IRON_SPEAR, ItemID.BRUT_IRON_SPEAR_P, ItemID.BRUT_IRON_SPEAR_P_,
            ItemID.BRUT_IRON_SPEAR_P__),
    STEEL_HASTA(ItemID.BRUT_STEEL_SPEAR, ItemID.BRUT_STEEL_SPEAR_P, ItemID.BRUT_STEEL_SPEAR_P_,
            ItemID.BRUT_STEEL_SPEAR_P__),
    MITHRIL_HASTA(ItemID.BRUT_MITHRIL_SPEAR, ItemID.BRUT_MITHRIL_SPEAR_P, ItemID.BRUT_MITHRIL_SPEAR_P_,
            ItemID.BRUT_MITHRIL_SPEAR_P__),
    ADAMANT_HASTA(ItemID.BRUT_ADAMANT_SPEAR, ItemID.BRUT_ADAMANT_SPEAR_P, ItemID.BRUT_ADAMANT_SPEAR_P_,
            ItemID.BRUT_ADAMANT_SPEAR_P__),
    RUNE_HASTA(ItemID.BRUT_RUNE_SPEAR, ItemID.BRUT_RUNE_SPEAR_P, ItemID.BRUT_RUNE_SPEAR_P_,
            ItemID.BRUT_RUNE_SPEAR_P__),
    DRAGON_HASTA(ItemID.BRUT_DRAGON_SPEAR, ItemID.BRUT_DRAGON_SPEAR_P, ItemID.BRUT_DRAGON_SPEAR_P_,
            ItemID.BRUT_DRAGON_SPEAR_P__),

    // --- Darts ---
    BRONZE_DART(ItemID.BRONZE_DART, ItemID.BRONZE_DART_P, ItemID.BRONZE_DART_P_, ItemID.BRONZE_DART_P__),
    IRON_DART(ItemID.IRON_DART, ItemID.IRON_DART_P, ItemID.IRON_DART_P_, ItemID.IRON_DART_P__),
    BLACK_DART(ItemID.BLACK_DART, ItemID.BLACK_DART_P, ItemID.BLACK_DART_P_, ItemID.BLACK_DART_P__),
    STEEL_DART(ItemID.STEEL_DART, ItemID.STEEL_DART_P, ItemID.STEEL_DART_P_, ItemID.STEEL_DART_P__),
    MITHRIL_DART(ItemID.MITHRIL_DART, ItemID.MITHRIL_DART_P, ItemID.MITHRIL_DART_P_, ItemID.MITHRIL_DART_P__),
    ADAMANT_DART(ItemID.ADAMANT_DART, ItemID.ADAMANT_DART_P, ItemID.ADAMANT_DART_P_, ItemID.ADAMANT_DART_P__),
    RUNE_DART(ItemID.RUNE_DART, ItemID.RUNE_DART_P, ItemID.RUNE_DART_P_, ItemID.RUNE_DART_P__),
    DRAGON_DART(ItemID.DRAGON_DART, ItemID.DRAGON_DART_P, ItemID.DRAGON_DART_P_, ItemID.DRAGON_DART_P__),
    AMETHYST_DART(ItemID.AMETHYST_DART, ItemID.AMETHYST_DART_P, ItemID.AMETHYST_DART_P_, ItemID.AMETHYST_DART_P__),

    // --- Knives ---
    BRONZE_KNIFE(ItemID.BRONZE_KNIFE, ItemID.BRONZE_KNIFE_P, ItemID.BRONZE_KNIFE_P_, ItemID.BRONZE_KNIFE_P__),
    IRON_KNIFE(ItemID.IRON_KNIFE, ItemID.IRON_KNIFE_P, ItemID.IRON_KNIFE_P_, ItemID.IRON_KNIFE_P__),
    BLACK_KNIFE(ItemID.BLACK_KNIFE, ItemID.BLACK_KNIFE_P, ItemID.BLACK_KNIFE_P_, ItemID.BLACK_KNIFE_P__),
    STEEL_KNIFE(ItemID.STEEL_KNIFE, ItemID.STEEL_KNIFE_P, ItemID.STEEL_KNIFE_P_, ItemID.STEEL_KNIFE_P__),
    MITHRIL_KNIFE(ItemID.MITHRIL_KNIFE, ItemID.MITHRIL_KNIFE_P, ItemID.MITHRIL_KNIFE_P_, ItemID.MITHRIL_KNIFE_P__),
    ADAMANT_KNIFE(ItemID.ADAMANT_KNIFE, ItemID.ADAMANT_KNIFE_P, ItemID.ADAMANT_KNIFE_P_, ItemID.ADAMANT_KNIFE_P__),
    RUNE_KNIFE(ItemID.RUNE_KNIFE, ItemID.RUNE_KNIFE_P, ItemID.RUNE_KNIFE_P_, ItemID.RUNE_KNIFE_P__),
    DRAGON_KNIFE(ItemID.DRAGON_KNIFE, ItemID.DRAGON_KNIFE_P, ItemID.DRAGON_KNIFE_P_, ItemID.DRAGON_KNIFE_P__),

    // --- Arrows ---
    BRONZE_ARROW(ItemID.BRONZE_ARROW, ItemID.BRONZE_ARROW_P, ItemID.BRONZE_ARROW_P_, ItemID.BRONZE_ARROW_P__),
    IRON_ARROW(ItemID.IRON_ARROW, ItemID.IRON_ARROW_P, ItemID.IRON_ARROW_P_, ItemID.IRON_ARROW_P__),
    STEEL_ARROW(ItemID.STEEL_ARROW, ItemID.STEEL_ARROW_P, ItemID.STEEL_ARROW_P_, ItemID.STEEL_ARROW_P__),
    MITHRIL_ARROW(ItemID.MITHRIL_ARROW, ItemID.MITHRIL_ARROW_P, ItemID.MITHRIL_ARROW_P_, ItemID.MITHRIL_ARROW_P__),
    ADAMANT_ARROW(ItemID.ADAMANT_ARROW, ItemID.ADAMANT_ARROW_P, ItemID.ADAMANT_ARROW_P_, ItemID.ADAMANT_ARROW_P__),
    RUNE_ARROW(ItemID.RUNE_ARROW, ItemID.RUNE_ARROW_P, ItemID.RUNE_ARROW_P_, ItemID.RUNE_ARROW_P__),
    DRAGON_ARROW(ItemID.DRAGON_ARROW, ItemID.DRAGON_ARROW_P, ItemID.DRAGON_ARROW_P_, ItemID.DRAGON_ARROW_P__),
    AMETHYST_ARROW(ItemID.AMETHYST_ARROW, ItemID.AMETHYST_ARROW_P, ItemID.AMETHYST_ARROW_P_, ItemID.AMETHYST_ARROW_P__),

    // --- Bolts ---
    BRONZE_BOLTS(ItemID.BOLT, ItemID.POISON_BOLT, ItemID.POISON_BOLT_, ItemID.POISON_BOLT__),
    IRON_BOLTS(ItemID.XBOWS_CROSSBOW_BOLTS_IRON, ItemID.XBOWS_CROSSBOW_BOLTS_IRON_POISONED,
            ItemID.XBOWS_CROSSBOW_BOLTS_IRON_POISONED_, ItemID.XBOWS_CROSSBOW_BOLTS_IRON_POISONED__),
    SILVER_BOLTS(ItemID.XBOWS_CROSSBOW_BOLTS_SILVER, ItemID.XBOWS_CROSSBOW_BOLTS_SILVER_POISONED,
            ItemID.XBOWS_CROSSBOW_BOLTS_SILVER_POISONED_, ItemID.XBOWS_CROSSBOW_BOLTS_SILVER_POISONED__),
    STEEL_BOLTS(ItemID.XBOWS_CROSSBOW_BOLTS_STEEL, ItemID.XBOWS_CROSSBOW_BOLTS_STEEL_POISONED,
            ItemID.XBOWS_CROSSBOW_BOLTS_STEEL_POISONED_, ItemID.XBOWS_CROSSBOW_BOLTS_STEEL_POISONED__),
    MITHRIL_BOLTS(ItemID.XBOWS_CROSSBOW_BOLTS_MITHRIL, ItemID.XBOWS_CROSSBOW_BOLTS_MITHRIL_POISONED,
            ItemID.XBOWS_CROSSBOW_BOLTS_MITHRIL_POISONED_, ItemID.XBOWS_CROSSBOW_BOLTS_MITHRIL_POISONED__),
    ADAMANTITE_BOLTS(ItemID.XBOWS_CROSSBOW_BOLTS_ADAMANTITE, ItemID.XBOWS_CROSSBOW_BOLTS_ADAMANTITE_POISONED,
            ItemID.XBOWS_CROSSBOW_BOLTS_ADAMANTITE_POISONED_, ItemID.XBOWS_CROSSBOW_BOLTS_ADAMANTITE_POISONED__),
    RUNITE_BOLTS(ItemID.XBOWS_CROSSBOW_BOLTS_RUNITE, ItemID.XBOWS_CROSSBOW_BOLTS_RUNITE_POISONED,
            ItemID.XBOWS_CROSSBOW_BOLTS_RUNITE_POISONED_, ItemID.XBOWS_CROSSBOW_BOLTS_RUNITE_POISONED__),
    DRAGON_BOLTS(ItemID.DRAGON_BOLTS, ItemID.DRAGON_BOLTS_P, ItemID.DRAGON_BOLTS_P_, ItemID.DRAGON_BOLTS_P__);

    private final int baseId;
    private final int poisonId;
    private final int poisonPlusId;
    private final int poisonPlusPlusId;

    // Overloaded constructor for global prerequisites
    PoisonWeapons(int id) {
        this.baseId = id;
        this.poisonId = id;
        this.poisonPlusId = id;
        this.poisonPlusPlusId = id;
    }

    // Constructor for weapons with distinct variant IDs.
    PoisonWeapons(int baseId, int poisonId, int poisonPlusId, int poisonPlusPlusId) {
        this.baseId = baseId;
        this.poisonId = poisonId;
        this.poisonPlusId = poisonPlusId;
        this.poisonPlusPlusId = poisonPlusPlusId;
    }

    /**
     * Checks whether the given item id matches any variant of this weapon.
     *
     * @param id the item id to check.
     * @return true if the id matches base, poison, poison+ or poison++.
     */
    public boolean matches(int id) {
        return id == baseId || id == poisonId || id == poisonPlusId || id == poisonPlusPlusId;
    }

    /**
     * Returns an unmodifiable set of all base weapon ids from poisonable weapons, excluding poison constants.
     */
    public static Set<Integer> getAllBaseWeaponIds() {
        Set<Integer> ids = new HashSet<>();
        for (PoisonWeapons weapon : values()) {
            if (!weapon.name().startsWith("WEAPON_POISON")) {
                ids.add(weapon.getBaseId());
            }
        }
        return Collections.unmodifiableSet(ids);
    }

    /**
     * Checks if a given item id is a poisonable weapon variant.
     *
     * @param itemId the item id to check.
     * @return true if it matches any poisonable weapon variant.
     */
    public static boolean isPoisonableWeapon(int itemId) {
        for (PoisonWeapons weapon : values()) {
            if (weapon.name().startsWith("WEAPON_POISON")) continue;
            if (weapon.matches(itemId)) {
                return true;
            }
        }
        return false;
    }

    /**
     * Checks if a poisonable weapon variant is eligible.
     * Base weapons are always eligible.
     * For poisoned variants:
     *   - (p) requires WEAPON_POISON,
     *   - (p+) requires WEAPON_POISON_,
     *   - (p++) requires WEAPON_POISON__,
     * to be unlocked along with the base weapon.
     * @param itemId the item ID to check
     * @param requireWeaponPoison if true, the corresponding global poison must be unlocked
     * @param unlockedItems the set of unlocked item IDs
     * @return true if eligible; false otherwise
     */
    public static boolean isPoisonVariantEligible(int itemId, boolean requireWeaponPoison, Set<Integer> unlockedItems) {
        PoisonWeapons matchingWeapon = null;
        for (PoisonWeapons weapon : values()) {
            if (weapon.name().startsWith("WEAPON_POISON")) continue;
            if (weapon.matches(itemId)) {
                matchingWeapon = weapon;
                break;
            }
        }
        if (matchingWeapon == null) {
            return true;
        }
        // Base weapon is always eligible.
        if (itemId == matchingWeapon.getBaseId()) {
            return true;
        }
        if (!requireWeaponPoison) {
            return true;
        }
        int requiredGlobalId;
        if (itemId == matchingWeapon.getPoisonId()) {
            requiredGlobalId = PoisonWeapons.WEAPON_POISON.getBaseId();
        } else if (itemId == matchingWeapon.getPoisonPlusId()) {
            requiredGlobalId = PoisonWeapons.WEAPON_POISON_.getBaseId();
        } else if (itemId == matchingWeapon.getPoisonPlusPlusId()) {
            requiredGlobalId = PoisonWeapons.WEAPON_POISON__.getBaseId();
        } else {
            return true;
        }
        boolean eligible = unlockedItems.contains(matchingWeapon.getBaseId()) && unlockedItems.contains(requiredGlobalId);
        return eligible;
    }

}

package com.choicer.chanceman.filters;

import lombok.Getter;
import net.runelite.api.gameval.ItemID;
import java.util.Collections;
import java.util.HashSet;
import java.util.Set;

/**
 * Enum representing all POH flatpack items.
 */
public enum Flatpacks {
    // Chair variants
    Crudechair(ItemID.POH_FLATPACK_ARMCHAIR1),
    Woodenchair(ItemID.POH_FLATPACK_ARMCHAIR2),
    Rockingchair(ItemID.POH_FLATPACK_ARMCHAIR3),
    Oakchair(ItemID.POH_FLATPACK_ARMCHAIR4),
    Oakarmchair(ItemID.POH_FLATPACK_ARMCHAIR5),
    Teakarmchair(ItemID.POH_FLATPACK_ARMCHAIR6),
    Mahoganyarmchair(ItemID.POH_FLATPACK_ARMCHAIR7),

    // Bookcase variants
    Bookcase(ItemID.POH_FLATPACK_BOOKCASE1),
    Oakbookcase(ItemID.POH_FLATPACK_BOOKCASE2),
    Mahoganybookcase(ItemID.POH_FLATPACK_BOOKCASE3),

    // Beer barrel variants
    Beerbarrel(ItemID.POH_FLATPACK_BEERBARREL1),
    Ciderbarrel(ItemID.POH_FLATPACK_BEERBARREL2),
    Asgarnianale(ItemID.POH_FLATPACK_BEERBARREL3),
    Greensmansale(ItemID.POH_FLATPACK_BEERBARREL4),
    Dragonbitter(ItemID.POH_FLATPACK_BEERBARREL5),
    Chefsdelight(ItemID.POH_FLATPACK_BEERBARREL6),

    // Kitchen table variants
    Kitchentable(ItemID.POH_FLATPACK_KITCHENTABLE1),
    Oakkitchentable(ItemID.POH_FLATPACK_KITCHENTABLE2),
    Teakkitchentable(ItemID.POH_FLATPACK_KITCHENTABLE3),

    // Dining table variants
    Wooddiningtable(ItemID.POH_FLATPACK_DININGTABLE1),
    Oakdiningtable(ItemID.POH_FLATPACK_DININGTABLE2),
    Carvedoaktable(ItemID.POH_FLATPACK_DININGTABLE3),
    Teaktable(ItemID.POH_FLATPACK_DININGTABLE4),
    Carvedteaktable(ItemID.POH_FLATPACK_DININGTABLE5),
    Mahoganytable(ItemID.POH_FLATPACK_DININGTABLE6),
    OpulentsTable(ItemID.POH_FLATPACK_DININGTABLE7),

    // Dining chair (bench) variants
    Woodenbench(ItemID.POH_FLATPACK_DININGCHAIR1),
    Oakbench(ItemID.POH_FLATPACK_DININGCHAIR2),
    Carvedoakbench(ItemID.POH_FLATPACK_DININGCHAIR3),
    Teakdiningbench(ItemID.POH_FLATPACK_DININGCHAIR4),
    Carvedteakbench(ItemID.POH_FLATPACK_DININGCHAIR5),
    Mahoganybench(ItemID.POH_FLATPACK_DININGCHAIR6),
    Gildedbench(ItemID.POH_FLATPACK_DININGCHAIR7),

    // Bed variants
    Woodenbed(ItemID.POH_FLATPACK_BED1),
    Oakbed(ItemID.POH_FLATPACK_BED2),
    Largeoakbed(ItemID.POH_FLATPACK_BED3),
    Teakbed(ItemID.POH_FLATPACK_BED4),
    Largeteakbed(ItemID.POH_FLATPACK_BED5),
    Fourposterbed(ItemID.POH_FLATPACK_BED6),
    Gildedfourposter(ItemID.POH_FLATPACK_BED7),

    // Clock variants
    Oakclock(ItemID.POH_FLATPACK_CLOCK1),
    Teakclock(ItemID.POH_FLATPACK_CLOCK2),
    Gildedclock(ItemID.POH_FLATPACK_CLOCK3),

    // Dresser variants
    Shavingstand(ItemID.POH_FLATPACK_DRESSER1),
    Oakshavingstand(ItemID.POH_FLATPACK_DRESSER2),
    Oakdresser(ItemID.POH_FLATPACK_DRESSER3),
    Teakdresser(ItemID.POH_FLATPACK_DRESSER4),
    Fancyteakdresser(ItemID.POH_FLATPACK_DRESSER5),
    Mahoganydresser(ItemID.POH_FLATPACK_DRESSER6),
    Gildeddresser(ItemID.POH_FLATPACK_DRESSER7),

    // Wardrobe variants
    Shoebox(ItemID.POH_FLATPACK_WARDROBE1),
    Oakdrawers(ItemID.POH_FLATPACK_WARDROBE2),
    Oakwardrobe(ItemID.POH_FLATPACK_WARDROBE3),
    Teakdrawers(ItemID.POH_FLATPACK_WARDROBE4),
    Teakwardrobe(ItemID.POH_FLATPACK_WARDROBE5),
    Mahoganywardrobe(ItemID.POH_FLATPACK_WARDROBE6),
    Gildedwardrobe(ItemID.POH_FLATPACK_WARDROBE7),

    // Cape rack variants
    Oakcaperack(ItemID.POH_FLATPACK_CAPE_RACK),
    Teakcaperack(ItemID.POH_FLATPACK_CAPE_RACK2),
    Mahoganycaperack(ItemID.POH_FLATPACK_CAPE_RACK3),
    Gildedcaperack(ItemID.POH_FLATPACK_CAPE_RACK4),
    Marblecaperack(ItemID.POH_FLATPACK_CAPE_RACK5),
    Magiccaperack(ItemID.POH_FLATPACK_CAPE_RACK6),

    // Toy box variants
    Oaktoybox(ItemID.POH_FLATPACK_TOY_BOX),
    Teaktoybox(ItemID.POH_FLATPACK_TOY_BOX2),
    Mahoganytoybox(ItemID.POH_FLATPACK_TOY_BOX3),

    // Magic wardrobe variants
    Oakmagicwardrobe(ItemID.POH_FLATPACK_MAGIC_WARDROBE),
    Carvedoakmagicwardrobe(ItemID.POH_FLATPACK_MAGIC_WARDROBE2),
    Teakmagicwardrobe(ItemID.POH_FLATPACK_MAGIC_WARDROBE3),
    Carvedteakmagicwardrobe(ItemID.POH_FLATPACK_MAGIC_WARDROBE4),
    Mahoganymagicwardrobe(ItemID.POH_FLATPACK_MAGIC_WARDROBE5),
    Gildedmagicwardrobe(ItemID.POH_FLATPACK_MAGIC_WARDROBE6),
    Marblemagicwardrobe(ItemID.POH_FLATPACK_MAGIC_WARDROBE7),

    // Armour case variants
    Oakarmourcase(ItemID.POH_FLATPACK_ARMOUR_CASE),
    Teakarmourcase(ItemID.POH_FLATPACK_ARMOUR_CASE2),
    Mahoganyarmourcase(ItemID.POH_FLATPACK_ARMOUR_CASE3),

    // Treasure chest variants
    Oaktreasurechest(ItemID.POH_FLATPACK_TREASURE_CHEST),
    Teaktreasurechest(ItemID.POH_FLATPACK_TREASURE_CHEST2),
    Magictreasurechest(ItemID.POH_FLATPACK_TREASURE_CHEST3),

    // Fancy dress box variants
    Oakfancydressbox(ItemID.POH_FLATPACK_FANCY_DRESS_BOX),
    Teakfancydressbox(ItemID.POH_FLATPACK_FANCY_DRESS_BOX2),
    Mahoganyfancydressbox(ItemID.POH_FLATPACK_FANCY_DRESS_BOX3);

    @Getter
    private final int id;

    Flatpacks(int id) {
        this.id = id;
    }

    /**
     * Returns an unmodifiable set of all flatpack item IDs.
     */
    public static Set<Integer> getAllFlatpackIds() {
        Set<Integer> ids = new HashSet<>();
        for (Flatpacks fp : Flatpacks.values()) {
            ids.add(fp.getId());
        }
        return Collections.unmodifiableSet(ids);
    }

    /**
     * Checks if the given item ID is a flatpack.
     *
     * @param id the item id to check.
     * @return true if the id is a flatpack, false otherwise.
     */
    public static boolean isFlatpack(int id) {
        return getAllFlatpackIds().contains(id);
    }
}

package com.choicer.chanceman.filters;

import lombok.Getter;
import net.runelite.api.gameval.ItemID;

import java.util.Collections;
import java.util.HashSet;
import java.util.Set;

public enum FreeToPlayBlockedItems {

    // Random
    Charcoal(ItemID.CHARCOAL),
    RawBoarMeat(ItemID.RAW_BOAR_MEAT),
    PureEssence(ItemID.BLANKRUNE_HIGH),
    CastleWarsBracelet3(ItemID.JEWL_CASTLEWARS_BRACELET3),
    CursedAmuletOfMagic(ItemID.AMULET_OF_MAGIC_CURSED),
    Dust(ItemID.DUST),
    Fur(ItemID.FUR),
    SwiftBlade(ItemID.SWIFT_BLADE),

    // Dyed boots and gloves
    GreyBoots(ItemID.WOLFENBOOTS_GREY),
    RedBoots(ItemID.WOLFENBOOTS_CRIMSON),
    YellowBoots(ItemID.WOLFENBOOTS_TANGERINE),
    TealBoots(ItemID.WOLFENBOOTS_OCEAN),
    PurpleBoots(ItemID.WOLFENBOOTS_PURPLE),
    GreyGloves(ItemID.WOLFENGLOVES_GREY),
    RedGloves(ItemID.WOLFENGLOVES_CRIMSON),
    YellowGloves(ItemID.WOLFENGLOVES_TANGERINE),
    TealGloves(ItemID.WOLFENGLOVES_OCEAN),
    PurpleGloves(ItemID.WOLFENGLOVES_PURPLE),

    // Shade
    ShadeRobeTop(ItemID.BLACKROBETOP),
    ShadeRobe(ItemID.BLACKROBEBOTTOM),

    // Elven wear
    ElvenTop(ItemID.PRIF_ELVEN_CLOTHES_TOP_1),
    ElvenSkirt(ItemID.PRIF_ELVEN_CLOTHES_BOTTOMS_1),
    ElvenTop2(ItemID.PRIF_ELVEN_CLOTHES_TOP_2),
    ElvenSkirt2(ItemID.PRIF_ELVEN_CLOTHES_BOTTOMS_2),
    ElvenTop3(ItemID.PRIF_ELVEN_CLOTHES_TOP_3),
    ElvenLegwear(ItemID.PRIF_ELVEN_CLOTHES_BOTTOMS_3),
    ElvenTop4(ItemID.PRIF_ELVEN_CLOTHES_TOP_4),

    // Dragonstone
    DragonstoneFullHelm(ItemID.DRAGONSTONE_HELMET),
    DragonstonePlatebody(ItemID.DRAGONSTONE_PLATEBODY),
    DragonstonePlatelegs(ItemID.DRAGONSTONE_PLATELEGS),

    // Wilderness capes (the rest are accessible on f2p)
    Team4Cape(ItemID.WILDERNESS_CAPE_4),
    Team5Cape(ItemID.WILDERNESS_CAPE_5),
    Team14Cape(ItemID.WILDERNESS_CAPE_14),
    Team15Cape(ItemID.WILDERNESS_CAPE_15),
    Team24Cape(ItemID.WILDERNESS_CAPE_24),
    Team25Cape(ItemID.WILDERNESS_CAPE_25),
    Team34Cape(ItemID.WILDERNESS_CAPE_34),
    Team35Cape(ItemID.WILDERNESS_CAPE_35),
    Team44Cape(ItemID.WILDERNESS_CAPE_44),
    Team45Cape(ItemID.WILDERNESS_CAPE_45),

    // Clue Scroll - Random
    WillowCompBow(ItemID.TRAIL_COMPOSITE_BOW_WILLOW),
    HamJoint(ItemID.JOINT_OF_HAM),
    WoodenShieldG(ItemID.WOODEN_SHIELD_GOLD),

    // Clue Scroll - Random Gilded
    GildedScimitar(ItemID.RUNE_SCIMITAR_GOLD),
    Gilded2HSword(ItemID.RUNE_2H_SWORD_GOLD),
    GoldenChefsHat(ItemID.CHEFS_HAT_GOLD),
    GoldenApron(ItemID.GOLDEN_APRON),
    GildedPickaxe(ItemID.TRAIL_GILDED_PICKAXE),
    GildedAxe(ItemID.TRAIL_GILDED_AXE),
    GildedSpade(ItemID.TRAIL_GILDED_SPADE),

    // Clue Scroll - Cape
    TeamCapeZero(ItemID.WILDERNESS_CAPE_ZERO),
    TeamCapeX(ItemID.WILDERNESS_CAPE_X),
    TeamCapeI(ItemID.WILDERNESS_CAPE_I),
    WolfCloak(ItemID.WOLF_CLOAK),

    // Clue Scroll - Amulet
    StrengthAmuletT(ItemID.TRAIL_AMULET_OF_STRENGTH),
    AmuletOfMagicT(ItemID.TRAIL_AMULET_OF_MAGIC),
    AmuletOfPowerT(ItemID.TRAIL_POWER_AMMY),

    // Clue Scroll - Ring
    RingOfNature(ItemID.RING_OF_NATURE),
    RingOfCoins(ItemID.RING_OF_COINS),
    RingOf3RdAge(ItemID.RING_OF_3RD_AGE),

    // Clue Scroll - Bronze Armor
    BronzePlatebodyG(ItemID.BRONZE_PLATEBODY_GOLD),
    BronzePlatelegsG(ItemID.BRONZE_PLATELEGS_GOLD),
    BronzePlateskirtG(ItemID.BRONZE_PLATESKIRT_GOLD),
    BronzeFullHelmG(ItemID.BRONZE_FULL_HELM_GOLD),
    BronzeKiteshieldG(ItemID.BRONZE_KITESHIELD_GOLD),
    BronzePlatebodyT(ItemID.BRONZE_PLATEBODY_TRIM),
    BronzePlatelegsT(ItemID.BRONZE_PLATELEGS_TRIM),
    BronzePlateskirtT(ItemID.BRONZE_PLATESKIRT_TRIM),
    BronzeFullHelmT(ItemID.BRONZE_FULL_HELM_TRIM),
    BronzeKiteshieldT(ItemID.BRONZE_KITESHIELD_TRIM),

    // Clue Scroll - Iron Armor
    IronPlatebodyT(ItemID.IRON_PLATEBODY_TRIM),
    IronPlatelegsT(ItemID.IRON_PLATELEGS_TRIM),
    IronPlateskirtT(ItemID.IRON_PLATESKIRT_TRIM),
    IronFullHelmT(ItemID.IRON_FULL_HELM_TRIM),
    IronKiteshieldT(ItemID.IRON_KITESHIELD_TRIM),
    IronPlatebodyG(ItemID.IRON_PLATEBODY_GOLD),
    IronPlatelegsG(ItemID.IRON_PLATELEGS_GOLD),
    IronPlateskirtG(ItemID.IRON_PLATESKIRT_GOLD),
    IronFullHelmG(ItemID.IRON_FULL_HELM_GOLD),
    IronKiteshieldG(ItemID.IRON_KITESHIELD_GOLD),

    // Clue Scroll - Steel Armor
    SteelPlatebodyG(ItemID.STEEL_PLATEBODY_GOLD),
    SteelPlatelegsG(ItemID.STEEL_PLATELEGS_GOLD),
    SteelPlateskirtG(ItemID.STEEL_PLATESKIRT_GOLD),
    SteelFullHelmG(ItemID.STEEL_FULL_HELM_GOLD),
    SteelKiteshieldG(ItemID.STEEL_KITESHIELD_GOLD),
    SteelPlatebodyT(ItemID.STEEL_PLATEBODY_TRIM),
    SteelPlatelegsT(ItemID.STEEL_PLATELEGS_TRIM),
    SteelPlateskirtT(ItemID.STEEL_PLATESKIRT_TRIM),
    SteelFullHelmT(ItemID.STEEL_FULL_HELM_TRIM),
    SteelKiteshieldT(ItemID.STEEL_KITESHIELD_TRIM),

    // Clue Scroll - Mithril Armor
    MithrilPlatebodyG(ItemID.MITHRIL_PLATEBODY_GOLD),
    MithrilPlatelegsG(ItemID.MITHRIL_PLATELEGS_GOLD),
    MithrilKiteshieldG(ItemID.MITHRIL_KITESHIELD_GOLD),
    MithrilFullHelmG(ItemID.MITHRIL_FULL_HELM_GOLD),
    MithrilPlateskirtG(ItemID.MITHRIL_PLATESKIRT_GOLD),
    MithrilPlatebodyT(ItemID.MITHRIL_PLATEBODY_TRIM),
    MithrilPlatelegsT(ItemID.MITHRIL_PLATELEGS_TRIM),
    MithrilKiteshieldT(ItemID.MITHRIL_KITESHIELD_TRIM),
    MithrilFullHelmT(ItemID.MITHRIL_FULL_HELM_TRIM),
    MithrilPlateskirtT(ItemID.MITHRIL_PLATESKIRT_TRIM),

    // Clue Scroll - Black Armor
    BlackPlatebodyT(ItemID.BLACK_PLATEBODY_TRIM),
    BlackPlatelegsT(ItemID.BLACK_PLATELEGS_TRIM),
    BlackFullHelmT(ItemID.BLACK_FULL_HELM_TRIM),
    BlackKiteshieldT(ItemID.BLACK_KITESHIELD_TRIM),
    BlackPlateskirtT(ItemID.BLACK_PLATESKIRT_TRIM),
    BlackPlatebodyG(ItemID.BLACK_PLATEBODY_GOLD),
    BlackPlatelegsG(ItemID.BLACK_PLATELEGS_GOLD),
    BlackFullHelmG(ItemID.BLACK_FULL_HELM_GOLD),
    BlackKiteshieldG(ItemID.BLACK_KITESHIELD_GOLD),
    BlackPlateskirtG(ItemID.BLACK_PLATESKIRT_GOLD),
    BlackShieldH1(ItemID.BLACK_HERALDIC_KITESHIELD1),
    BlackShieldH2(ItemID.BLACK_HERALDIC_KITESHIELD2),
    BlackShieldH3(ItemID.BLACK_HERALDIC_KITESHIELD3),
    BlackShieldH4(ItemID.BLACK_HERALDIC_KITESHIELD4),
    BlackShieldH5(ItemID.BLACK_HERALDIC_KITESHIELD5),
    BlackHelmH1(ItemID.TRAIL_HERALDIC_HELM_1_BLACK),
    BlackHelmH2(ItemID.TRAIL_HERALDIC_HELM_2_BLACK),
    BlackHelmH3(ItemID.TRAIL_HERALDIC_HELM_3_BLACK),
    BlackHelmH4(ItemID.TRAIL_HERALDIC_HELM_4_BLACK),
    BlackHelmH5(ItemID.TRAIL_HERALDIC_HELM_5_BLACK),
    BlackPlatebodyH1(ItemID.BLACK_PLATEBODY_H1),
    BlackPlatebodyH2(ItemID.BLACK_PLATEBODY_H2),
    BlackPlatebodyH3(ItemID.BLACK_PLATEBODY_H3),
    BlackPlatebodyH4(ItemID.BLACK_PLATEBODY_H4),
    BlackPlatebodyH5(ItemID.BLACK_PLATEBODY_H5),

    // Clue Scroll - Adamant Armor
    AdamantPlatebodyT(ItemID.ADAMANT_PLATEBODY_TRIM),
    AdamantPlatelegsT(ItemID.ADAMANT_PLATELEGS_TRIM),
    AdamantKiteshieldT(ItemID.ADAMANT_KITESHIELD_TRIM),
    AdamantFullHelmT(ItemID.ADAMANT_FULL_HELM_TRIM),
    AdamantPlateskirtT(ItemID.ADAMANT_PLATESKIRT_TRIM),
    AdamantPlatebodyG(ItemID.ADAMANT_PLATEBODY_GOLD),
    AdamantPlatelegsG(ItemID.ADAMANT_PLATELEGS_GOLD),
    AdamantKiteshieldG(ItemID.ADAMANT_KITESHIELD_GOLD),
    AdamantFullHelmG(ItemID.ADAMANT_FULL_HELM_GOLD),
    AdamantPlateskirtG(ItemID.ADAMANT_PLATESKIRT_GOLD),
    AdamantShieldH1(ItemID.ADAMANT_HERALDIC_KITESHIELD1),
    AdamantShieldH2(ItemID.ADAMANT_HERALDIC_KITESHIELD2),
    AdamantShieldH3(ItemID.ADAMANT_HERALDIC_KITESHIELD3),
    AdamantShieldH4(ItemID.ADAMANT_HERALDIC_KITESHIELD4),
    AdamantShieldH5(ItemID.ADAMANT_HERALDIC_KITESHIELD5),
    AdamantHelmH1(ItemID.TRAIL_HERALDIC_HELM_1_ADAMANT),
    AdamantHelmH2(ItemID.TRAIL_HERALDIC_HELM_2_ADAMANT),
    AdamantHelmH3(ItemID.TRAIL_HERALDIC_HELM_3_ADAMANT),
    AdamantHelmH4(ItemID.TRAIL_HERALDIC_HELM_4_ADAMANT),
    AdamantHelmH5(ItemID.TRAIL_HERALDIC_HELM_5_ADAMANT),
    AdamantPlatebodyH1(ItemID.ADAMANT_PLATEBODY_H1),
    AdamantPlatebodyH2(ItemID.ADAMANT_PLATEBODY_H2),
    AdamantPlatebodyH3(ItemID.ADAMANT_PLATEBODY_H3),
    AdamantPlatebodyH4(ItemID.ADAMANT_PLATEBODY_H4),
    AdamantPlatebodyH5(ItemID.ADAMANT_PLATEBODY_H5),

    // Clue Scroll - Rune Armor
    RunePlatebodyT(ItemID.RUNE_PLATEBODY_TRIM),
    RunePlatelegsT(ItemID.RUNE_PLATELEGS_TRIM),
    RuneFullHelmT(ItemID.RUNE_FULL_HELM_TRIM),
    RuneKiteshieldT(ItemID.RUNE_KITESHIELD_TRIM),
    RunePlateskirtT(ItemID.RUNE_PLATESKIRT_TRIM),
    RunePlatebodyG(ItemID.RUNE_PLATEBODY_GOLD),
    RunePlatelegsG(ItemID.RUNE_PLATELEGS_GOLD),
    RuneFullHelmG(ItemID.RUNE_FULL_HELM_GOLD),
    RuneKiteshieldG(ItemID.RUNE_KITESHIELD_GOLD),
    RunePlateskirtG(ItemID.RUNE_PLATESKIRT_GOLD),
    RuneShieldH1(ItemID.RUNE_HERALDIC_KITESHIELD1),
    RuneShieldH2(ItemID.RUNE_HERALDIC_KITESHIELD2),
    RuneShieldH3(ItemID.RUNE_HERALDIC_KITESHIELD3),
    RuneShieldH4(ItemID.RUNE_HERALDIC_KITESHIELD4),
    RuneShieldH5(ItemID.RUNE_HERALDIC_KITESHIELD5),
    RuneHelmH1(ItemID.TRAIL_HERALDIC_HELM_1_RUNE),
    RuneHelmH2(ItemID.TRAIL_HERALDIC_HELM_2_RUNE),
    RuneHelmH3(ItemID.TRAIL_HERALDIC_HELM_3_RUNE),
    RuneHelmH4(ItemID.TRAIL_HERALDIC_HELM_4_RUNE),
    RuneHelmH5(ItemID.TRAIL_HERALDIC_HELM_5_RUNE),
    RunePlatebodyH1(ItemID.RUNE_PLATEBODY_H1),
    RunePlatebodyH2(ItemID.RUNE_PLATEBODY_H2),
    RunePlatebodyH3(ItemID.RUNE_PLATEBODY_H3),
    RunePlatebodyH4(ItemID.RUNE_PLATEBODY_H4),
    RunePlatebodyH5(ItemID.RUNE_PLATEBODY_H5),

    // Clue Scroll - God Armor
    ZamorakPlatebody(ItemID.RUNE_PLATEBODY_ZAMORAK),
    ZamorakPlatelegs(ItemID.RUNE_PLATELEGS_ZAMORAK),
    ZamorakFullHelm(ItemID.RUNE_FULL_HELM_ZAMORAK),
    ZamorakKiteshield(ItemID.RUNE_KITESHIELD_ZAMORAK),
    ZamorakPlateskirt(ItemID.RUNE_PLATESKIRT_ZAMORAK),
    SaradominPlatebody(ItemID.RUNE_PLATEBODY_SARADOMIN),
    SaradominPlatelegs(ItemID.RUNE_PLATELEGS_SARADOMIN),
    SaradominFullHelm(ItemID.RUNE_FULL_HELM_SARADOMIN),
    SaradominKiteshield(ItemID.RUNE_KITESHIELD_SARADOMIN),
    SaradominPlateskirt(ItemID.RUNE_PLATESKIRT_SARADOMIN),
    GuthixPlatebody(ItemID.RUNE_PLATEBODY_GUTHIX),
    GuthixPlatelegs(ItemID.RUNE_PLATELEGS_GUTHIX),
    GuthixFullHelm(ItemID.RUNE_FULL_HELM_GUTHIX),
    GuthixKiteshield(ItemID.RUNE_KITESHIELD_GUTHIX),
    GuthixPlateskirt(ItemID.RUNE_PLATESKIRT_GUTHIX),
    AncientPlatebody(ItemID.RUNE_PLATEBODY_ANCIENT),
    AncientPlatelegs(ItemID.RUNE_PLATELEGS_ANCIENT),
    AncientPlateskirt(ItemID.RUNE_PLATESKIRT_ANCIENT),
    AncientFullHelm(ItemID.RUNE_FULL_HELM_ANCIENT),
    AncientKiteshield(ItemID.RUNE_KITESHIELD_ANCIENT),
    ArmadylPlatebody(ItemID.RUNE_PLATEBODY_ARMADYL),
    ArmadylPlatelegs(ItemID.RUNE_PLATELEGS_ARMADYL),
    ArmadylPlateskirt(ItemID.RUNE_PLATESKIRT_ARMADYL),
    ArmadylFullHelm(ItemID.RUNE_FULL_HELM_ARMADYL),
    ArmadylKiteshield(ItemID.RUNE_KITESHIELD_ARMADYL),
    BandosPlatebody(ItemID.RUNE_PLATEBODY_BANDOS),
    BandosPlatelegs(ItemID.RUNE_PLATELEGS_BANDOS),
    BandosPlateskirt(ItemID.RUNE_PLATESKIRT_BANDOS),
    BandosFullHelm(ItemID.RUNE_FULL_HELM_BANDOS),
    BandosKiteshield(ItemID.RUNE_KITESHIELD_BANDOS),

    // Clue Scroll - Gilded Armor
    GildedPlatebody(ItemID.RUNE_PLATEBODY_GOLDPLATE),
    GildedPlatelegs(ItemID.RUNE_PLATELEGS_GOLDPLATE),
    GildedPlateskirt(ItemID.RUNE_PLATESKIRT_GOLDPLATE),
    GildedFullHelm(ItemID.RUNE_FULL_HELM_GOLDPLATE),
    GildedKiteshield(ItemID.RUNE_KITESHIELD_GOLDPLATE),
    GildedMedHelm(ItemID.RUNE_MED_HELM_GOLD),
    GildedChainbody(ItemID.RUNE_CHAINBODY_GOLD),
    GildedSqShield(ItemID.RUNE_SQ_SHIELD_GOLD),
    GildedDhideVambraces(ItemID.TRAIL_GILDED_DHIDE_VAMBRACES),
    GildedDhideBody(ItemID.TRAIL_GILDED_DHIDE_TOP),
    GildedDhideChaps(ItemID.TRAIL_GILDED_DHIDE_CHAPS),

    // Clue Scroll - Ranged Armor
    StuddedBodyG(ItemID.STUDDED_BODY_TRIM_GOLD),
    StuddedBodyT(ItemID.STUDDED_BODY_TRIM_FUR),
    StuddedChapsG(ItemID.STUDDED_CHAPS_TRIM_GOLD),
    StuddedChapsT(ItemID.STUDDED_CHAPS_TRIM_FUR),
    GreenDhideBodyG(ItemID.DRAGONHIDE_BODY_TRIM_GOLD),
    GreenDhideBodyT(ItemID.DRAGONHIDE_BODY_TRIM),
    GreenDhideChapsG(ItemID.DRAGONHIDE_CHAPS_TRIM_GOLD),
    GreenDhideChapsT(ItemID.DRAGONHIDE_CHAPS_TRIM),
    LeatherBodyG(ItemID.LEATHER_ARMOUR_TRIM_GOLD),
    LeatherChapsG(ItemID.LEATHER_CHAPS_TRIM_GOLD),

    // Clue Scroll - Magic Armor
    BlueSkirtG(ItemID.BLUE_SKIRT_TRIM_GOLD),
    BlueSkirtT(ItemID.BLUE_SKIRT_TRIM),
    BlueWizardRobeG(ItemID.WIZARDS_ROBE_TRIM_GOLD),
    BlueWizardRobeT(ItemID.WIZARDS_ROBE_TRIM),
    BlueWizardHatG(ItemID.BLUEWIZHAT_TRIM_GOLD),
    BlueWizardHatT(ItemID.BLUEWIZHAT_TRIM),
    BlackSkirtG(ItemID.BLACK_SKIRT_GOLD),
    BlackSkirtT(ItemID.BLACK_SKIRT_TRIM),
    BlackWizardRobeG(ItemID.BLACK_WIZARDS_ROBE_GOLD),
    BlackWizardRobeT(ItemID.BLACK_WIZARDS_ROBE_TRIM),
    BlackWizardHatG(ItemID.BLACKWIZHAT_GOLD),
    BlackWizardHatT(ItemID.BLACKWIZHAT_TRIM),

    // Clue Scroll - Prayer Armor
    MonksRobeTopG(ItemID.MONK_ROBETOP_GOLD),
    MonksRobeG(ItemID.MONK_ROBEBOTTOM_GOLD),

    // Item Sets
    BronzeLegsTrim(ItemID.SET_BRONZE_LEGS_TRIM),
    BronzeSkirtTrim(ItemID.SET_BRONZE_SKIRT_TRIM),
    BronzeLegsGold(ItemID.SET_BRONZE_LEGS_GOLD),
    BronzeSkirtGold(ItemID.SET_BRONZE_SKIRT_GOLD),
    IronLegsTrim(ItemID.SET_IRON_LEGS_TRIM),
    IronSkirtTrim(ItemID.SET_IRON_SKIRT_TRIM),
    IronLegsGold(ItemID.SET_IRON_LEGS_GOLD),
    IronSkirtGold(ItemID.SET_IRON_SKIRT_GOLD),
    SteelLegsTrim(ItemID.SET_STEEL_LEGS_TRIM),
    SteelSkirtTrim(ItemID.SET_STEEL_SKIRT_TRIM),
    SteelLegsGold(ItemID.SET_STEEL_LEGS_GOLD),
    SteelSkirtGold(ItemID.SET_STEEL_SKIRT_GOLD),
    BlackLegsTrim(ItemID.SET_BLACK_LEGS_TRIM),
    BlackSkirtTrim(ItemID.SET_BLACK_SKIRT_TRIM),
    BlackLegsGold(ItemID.SET_BLACK_LEGS_GOLD),
    BlackSkirtGold(ItemID.SET_BLACK_SKIRT_GOLD),
    MithrilLegsTrim(ItemID.SET_MITHRIL_LEGS_TRIM),
    MithrilSkirtTrim(ItemID.SET_MITHRIL_SKIRT_TRIM),
    MithrilLegsGold(ItemID.SET_MITHRIL_LEGS_GOLD),
    MithrilSkirtGold(ItemID.SET_MITHRIL_SKIRT_GOLD),
    AdamantLegsTrim(ItemID.SET_ADAMANT_LEGS_TRIM),
    AdamantSkirtTrim(ItemID.SET_ADAMANT_SKIRT_TRIM),
    AdamantLegsGold(ItemID.SET_ADAMANT_LEGS_GOLD),
    AdamantSkirtGold(ItemID.SET_ADAMANT_SKIRT_GOLD),
    RuneLegsTrim(ItemID.SET_RUNE_LEGS_TRIM),
    RuneSkirtTrim(ItemID.SET_RUNE_SKIRT_TRIM),
    RuneLegsGold(ItemID.SET_RUNE_LEGS_GOLD),
    RuneSkirtGold(ItemID.SET_RUNE_SKIRT_GOLD),
    GildedArmourLegs(ItemID.SET_RUNE_LEGS_GOLDPLATE),
    GildedArmourSkirt(ItemID.SET_RUNE_SKIRT_GOLDPLATE),
    SaradominLegs(ItemID.SET_RUNE_LEGS_SARADOMIN),
    SaradominSkirt(ItemID.SET_RUNE_SKIRT_SARADOMIN),
    ZamorakLegs(ItemID.SET_RUNE_LEGS_ZAMORAK),
    ZamorakSkirt(ItemID.SET_RUNE_SKIRT_ZAMORAK),
    GuthixLegs(ItemID.SET_RUNE_LEGS_GUTHIX),
    GuthixSkirt(ItemID.SET_RUNE_SKIRT_GUTHIX),
    ArmadylLegs(ItemID.SET_RUNE_LEGS_ARMADYL),
    ArmadylSkirt(ItemID.SET_RUNE_SKIRT_ARMADYL),
    BandosLegs(ItemID.SET_RUNE_LEGS_BANDOS),
    BandosSkirt(ItemID.SET_RUNE_SKIRT_BANDOS),
    AncientLegs(ItemID.SET_RUNE_LEGS_ANCIENT),
    AncientSkirt(ItemID.SET_RUNE_SKIRT_ANCIENT),
    GildedDragonhide(ItemID.SET_DHIDE_GILDED),
;

    @Getter
    private final int id;
    private static final Set<Integer> ids;
    static {
        Set<Integer> idsBuilder = new HashSet<>();
        for (FreeToPlayBlockedItems as : FreeToPlayBlockedItems.values()) {
            idsBuilder.add(as.getId());
        }
        ids = Collections.unmodifiableSet(idsBuilder);
    }

    FreeToPlayBlockedItems(int id) {
        this.id = id;
    }

    /**
     * Returns an unmodifiable set of all item set item IDs.
     */
    public static Set<Integer> getFreeToPlayTradeOnlyItemIds() {
        return ids;
    }

    /**
     * Checks if the given item ID is one of the items that cannot be self-sufficiently
     * obtained on a free to play server.
     *
     * @param id the item id to check.
     * @return true if the id cannot be self-sufficiently obtained, false otherwise.
     */
    public static boolean isFreeToPlayTradeOnlyItem(int id) {
        return getFreeToPlayTradeOnlyItemIds().contains(id);
    }
}

package com.choicer.chanceman.filters;

import lombok.Getter;

import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.LinkedHashMap;
import java.util.Map;
import java.util.Set;

/**
 * Tracks quest item IDs that require the Quest Items toggle to participate in rolls.
 * The list is intentionally empty for now and can be populated as IDs become available.
 */
public final class QuestItemAllowlist
{
    private static final Set<Integer> QUEST_ITEM_IDS = new HashSet<>();
    private static final Map<Integer, String> QUEST_NAME_BY_ITEM = new HashMap<>();
    private static final Map<String, Set<Integer>> QUEST_ITEMS_BY_QUEST = new LinkedHashMap<>();

    @Getter
    private static final Set<Integer> ALLOWED_QUEST_ITEMS;

    static
    {
        // Example usage for future quest items:
        // registerQuestItems("Cook's Assistant", ItemID.POT_OF_FLOUR);
        ALLOWED_QUEST_ITEMS = Collections.unmodifiableSet(QUEST_ITEM_IDS);
    }

    private QuestItemAllowlist()
    {
        // utility class
    }

    static void registerQuestItemForTesting(int itemId)
    {
        registerQuestItems("Test Quest", itemId);
    }

    private static void registerQuestItems(String questName, int... itemIds)
    {
        if (questName == null || questName.trim().isEmpty() || itemIds == null)
        {
            return;
        }

        final String normalizedQuestName = questName.trim();
        Set<Integer> questItems = QUEST_ITEMS_BY_QUEST.computeIfAbsent(normalizedQuestName, q -> new HashSet<>());
        for (int itemId : itemIds)
        {
            if (itemId <= 0)
            {
                continue;
            }
            QUEST_ITEM_IDS.add(itemId);
            QUEST_NAME_BY_ITEM.put(itemId, normalizedQuestName);
            questItems.add(itemId);
        }
    }

    public static String getQuestNameForItem(int itemId)
    {
        return QUEST_NAME_BY_ITEM.get(itemId);
    }

    static void clearForTesting()
    {
        QUEST_ITEM_IDS.clear();
        QUEST_NAME_BY_ITEM.clear();
        QUEST_ITEMS_BY_QUEST.clear();
    }
}

package com.choicer.chanceman.filters;

import com.choicer.chanceman.ChanceManConfig;

import java.util.Collections;
import java.util.Set;
import java.util.function.IntPredicate;

/**
 * Centralizes the item eligibility logic so it can be tested without the plugin runtime.
 */
public final class ItemEligibility
{
    private ItemEligibility() { }

    public static boolean shouldInclude(
            ItemAttributes attributes,
            int itemId,
            int canonicalItemId,
            ChanceManConfig config,
            Set<Integer> unlockedItems,
            IntPredicate notTrackedPredicate
    )
    {
        if (attributes == null)
        {
            return false;
        }
        String name = attributes.getName();
        if (name == null)
        {
            return false;
        }
        name = name.trim();
        if (name.isEmpty()
                || name.equalsIgnoreCase("null")
                || name.equalsIgnoreCase("Members")
                || name.equalsIgnoreCase("(Members)")
                || name.matches("(?i)null\\s*\\(Members\\)"))
        {
            return false;
        }
        if (attributes.getPlaceholderTemplateId() != -1)
        {
            return false;
        }
        if (!attributes.isTradeable())
        {
            if (!config.includeUntradeable())
            {
                return false;
            }
            if (!ItemsFilter.isUntradeableAllowlisted(canonicalItemId))
            {
                return false;
            }
        }
        if (ItemsFilter.isQuestItem(canonicalItemId) && !config.includeQuestItems())
        {
            return false;
        }
        if (notTrackedPredicate != null && notTrackedPredicate.test(itemId))
        {
            return false;
        }
        if (ItemsFilter.isBlocked(itemId, config))
        {
            return false;
        }
        if (config.freeToPlay() && attributes.isMembers())
        {
            return false;
        }
        Set<Integer> unlockedSnapshot = unlockedItems != null ? unlockedItems : Collections.emptySet();
        return ItemsFilter.isPoisonEligible(
                itemId,
                config.requireWeaponPoison(),
                unlockedSnapshot
        );
    }
}

package com.choicer.chanceman.filters;

import lombok.Getter;

import java.util.Collections;
import java.util.HashSet;
import java.util.Set;
import net.runelite.api.gameval.ItemID;


public final class BlockedItems {
    @Getter private static final Set<Integer> BLOCKED_ITEMS;

    static {
        Set<Integer> blocked = new HashSet<>();
        //Dead Man Mode
        blocked.add(ItemID.DEADMAN_BLIGHTED_AGS); // Corrupted Armadyl Godsword
        blocked.add(ItemID.DEADMAN_BLIGHTED_DARK_BOW); // Corrupted Dark Bow
        blocked.add(ItemID.DEADMAN_BLIGHTED_DRAGON_CLAWS); // Corrupted Dragon Claws
        blocked.add(ItemID.DEADMAN_BLIGHTED_TWISTED_BOW); // Corrupted Twisted Bow
        blocked.add(ItemID.DEADMAN_BLIGHTED_VOIDWAKER); // Corrupted Voidwaker
        blocked.add(ItemID.DEADMAN_BLIGHTED_VOLATILE_STAFF); // Corrupted Volatile Nightmare Staff
        blocked.add(ItemID.DEADMAN_BLIGHTED_TUMEKENS_SHADOW_UNCHARGED); // Corrupted Tumeken's Shadow (uncharged)
        blocked.add(ItemID.DEADMAN_BLIGHTED_SCYTHE_OF_VITUR_UNCHARGED);// Corrupted Scythe of Vitur (uncharged)
        blocked.add(ItemID.DEADMAN_NIMBLENESS_CHARM); // Nimbleness Charm
        blocked.add(ItemID.DEADMAN_STOCKPILING_CHARM); // Stockpiling Charm
        blocked.add(ItemID.DEADMAN_ACCUMULATION_CHARM); // Accumulation Charm
        blocked.add(ItemID.DEADMAN_VULNERABILITY_CHARM); // Vulnerability Charm
        blocked.add(ItemID.DEADMAN_2024_HOME_TELEPORT_SCROLL); // Armageddon Teleport Scroll
        blocked.add(ItemID.DEADMAN_2024_CAPE_ORNAMENT_SCROLL); // Armageddon Cape Fabric
        blocked.add(ItemID.DEADMAN_2024_WEAPON_ORNAMENT_SCROLL); // Armageddon Weapon Scroll
        blocked.add(ItemID.DEADMAN_RUG); // Armageddon Rug
        blocked.add(ItemID.DEADMAN1DOSEOVERLOAD); // Blighted Overload (1)
        blocked.add(ItemID.DEADMAN2DOSEOVERLOAD); // Blighted Overload (2)
        blocked.add(ItemID.DEADMAN3DOSEOVERLOAD); // Blighted Overload (3)
        blocked.add(ItemID.DEADMAN4DOSEOVERLOAD); // Blighted Overload (4)
        blocked.add(ItemID.DEADMAN_OVERLOAD_CHITIN); // Chitin
        blocked.add(ItemID.DEADMAN_STARTER_BOW); // Starter Bow
        blocked.add(ItemID.DEADMAN_STARTER_STAFF); // Starter Staff
        blocked.add(ItemID.DEADMAN_STARTER_SWORD); // Starter Sword
        blocked.add(ItemID.MAGIC_ROCK_OF_WEAPONS); // Trinket of Advanced Weaponry
        blocked.add(ItemID.MAGIC_ROCK_OF_FAIRIES); // Trinket of Fairies
        blocked.add(ItemID.MAGIC_ROCK_OF_UNDEAD); // Trinket of Undead
        blocked.add(ItemID.MAGIC_ROCK_OF_VENGEANCE); // Trinket of Vengeance
        blocked.add(ItemID.MORRIGANS_COIF); // Morrigan's Coif
        blocked.add(ItemID.MORRIGANS_LEATHER_BODY); // Morrigan's Leather Body
        blocked.add(ItemID.MORRIGANS_LEATHER_CHAPS); // Morrigan's Leather Chaps
        blocked.add(ItemID.MORRIGANS_THROWNAXE); // Morrigan's Thrown axe
        blocked.add(ItemID.MORRIGANS_JAVELIN); // Morrigan's Javelin
        blocked.add(ItemID.STATIUS_FULL_HELM); // Statius' Full Helm
        blocked.add(ItemID.STATIUS_PLATEBODY); // Statius' Platebody
        blocked.add(ItemID.STATIUS_PLATELEGS); // Statius' Platelegs
        blocked.add(ItemID.STATIUS_WARHAMMER); // Statius' Warhammer
        blocked.add(ItemID.VESTAS_CHAINBODY); // Vesta's Chainbody
        blocked.add(ItemID.VESTAS_PLATESKIRT); // Vesta's Plateskirt
        blocked.add(ItemID.VESTAS_LONGSWORD); // Vesta's Longsword
        blocked.add(ItemID.VESTAS_SPEAR); // Vesta's Spear
        blocked.add(ItemID.ZURIELS_HOOD); // Zuriel's Hood
        blocked.add(ItemID.ZURIELS_ROBE_TOP); // Zuriel's Robe Top
        blocked.add(ItemID.ZURIELS_ROBE_BOTTOM); // Zuriel's Robe Bottom
        blocked.add(ItemID.ZURIELS_STAFF); // Zuriel's Staff
        blocked.add(ItemID.SIGIL_OF_ADROIT_UNATTUNED); // Sigil Of Adroit
        blocked.add(ItemID.SIGIL_OF_AGGRESSION_UNATTUNED); // Sigil Of Aggression
        blocked.add(ItemID.SIGIL_OF_AGILE_FORTUNE_UNATTUNED); // Sigil Of Agile Fortune
        blocked.add(ItemID.SIGIL_OF_ARCANE_SWIFTNESS_UNATTUNED); // Sigil Of Arcane Swiftness
        blocked.add(ItemID.SIGIL_OF_BARROWS_UNATTUNED); // Sigil Of Barrows
        blocked.add(ItemID.SIGIL_OF_BINDING_UNATTUNED); // Sigil Of Binding
        blocked.add(ItemID.SIGIL_OF_CONSISTENCY_UNATTUNED); // Sigil Of Consistency
        blocked.add(ItemID.SIGIL_OF_DECEPTION_UNATTUNED); // Sigil Of Deception
        blocked.add(ItemID.SIGIL_OF_DEFT_STRIKES_UNATTUNED); // Sigil Of Deft Strikes
        blocked.add(ItemID.SIGIL_OF_DEVOTION_UNATTUNED); // Sigil Of Devotion
        blocked.add(ItemID.SIGIL_OF_ENHANCED_HARVEST_UNATTUNED); // Sigil Of Enhanced Harvest
        blocked.add(ItemID.SIGIL_OF_ESCAPING_UNATTUNED); // Sigil Of Escaping
        blocked.add(ItemID.SIGIL_OF_EXAGGERATION_UNATTUNED); // Sigil Of Exaggeration
        blocked.add(ItemID.SIGIL_OF_FAITH_UNATTUNED); // Sigil Of Faith
        blocked.add(ItemID.SIGIL_OF_FINALITY_UNATTUNED); // Sigil Of Finality
        blocked.add(ItemID.SIGIL_OF_FORTIFICATION_UNATTUNED); // Sigil Of Fortification
        blocked.add(ItemID.SIGIL_OF_FREEDOM_UNATTUNED); // Sigil Of Freedom
        blocked.add(ItemID.SIGIL_OF_GARMENTS_UNATTUNED); // Sigil Of Garments
        blocked.add(ItemID.SIGIL_OF_GUNSLINGER_UNATTUNED); // Sigil Of Gunslinger
        blocked.add(ItemID.SIGIL_OF_HOARDING_UNATTUNED); // Sigil Of Hoarding
        blocked.add(ItemID.SIGIL_OF_LAST_RECALL_UNATTUNED); // Sigil Of Last Recall
        blocked.add(ItemID.SIGIL_OF_LITHE_UNATTUNED); // Sigil Of Lithe
        blocked.add(ItemID.SIGIL_OF_METICULOUSNESS_UNATTUNED); // Sigil Of Meticulousness
        blocked.add(ItemID.SIGIL_OF_MOBILITY_UNATTUNED); // Sigil Of Mobility
        blocked.add(ItemID.SIGIL_OF_NATURE_UNATTUNED); // Sigil Of Nature
        blocked.add(ItemID.SIGIL_OF_ONSLAUGHT_UNATTUNED); // Sigil Of Onslaught
        blocked.add(ItemID.SIGIL_OF_PIOUS_PROTECTION_UNATTUNED); // Sigil Of Pious Protection
        blocked.add(ItemID.SIGIL_OF_PRECISION_UNATTUNED); // Sigil Of Precision
        blocked.add(ItemID.SIGIL_OF_PRESERVATION_UNATTUNED); // Sigil Of Preservation
        blocked.add(ItemID.SIGIL_OF_PROSPERITY_UNATTUNED); // Sigil Of Prosperity
        blocked.add(ItemID.SIGIL_OF_RAMPAGE_UNATTUNED); // Sigil Of Rampage
        blocked.add(ItemID.SIGIL_OF_RAMPART_UNATTUNED); // Sigil Of Rampart
        blocked.add(ItemID.SIGIL_OF_REMOTE_STORAGE_UNATTUNED); // Sigil Of Remote Storage
        blocked.add(ItemID.SIGIL_OF_RESILIENCE_UNATTUNED); // Sigil Of Resilience
        blocked.add(ItemID.SIGIL_OF_RESISTANCE_UNATTUNED); // Sigil Of Resistance
        blocked.add(ItemID.SIGIL_OF_RESTORATION_UNATTUNED); // Sigil Of Restoration
        blocked.add(ItemID.SIGIL_OF_REVOKED_LIMITATION_UNATTUNED); // Sigil Of Revoked Limitations
        blocked.add(ItemID.SIGIL_OF_SLAUGHTER_UNATTUNED); // Sigil Of Slaughter
        blocked.add(ItemID.SIGIL_OF_SPECIALISED_STRIKES_UNATTUNED); // Sigil Of Specialised Strikes
        blocked.add(ItemID.SIGIL_OF_STAMINA_UNATTUNED); // Sigil Of Stamina
        blocked.add(ItemID.SIGIL_OF_STORAGE_UNATTUNED); // Sigil Of Storage
        blocked.add(ItemID.SIGIL_OF_SUPREME_STAMINA_UNATTUNED); // Sigil Of Supreme Stamina
        blocked.add(ItemID.SIGIL_OF_SUSTENANCE_UNATTUNED); // Sigil Of Sustenance
        blocked.add(ItemID.SIGIL_OF_SWASHBUCKLER_UNATTUNED); // Sigil Of Swashbuckler
        blocked.add(ItemID.SIGIL_OF_THE_ABYSS_UNATTUNED); // Sigil Of The Abyss
        blocked.add(ItemID.SIGIL_OF_THE_ALCHEMIST_UNATTUNED); // Sigil Of The Alchemist
        blocked.add(ItemID.SIGIL_OF_THE_ALCHEMANIAC_UNATTUNED); // Sigil Of The Alchemaniac
        blocked.add(ItemID.SIGIL_OF_THE_AUGMENTED_THRALL_UNATTUNED); // Sigil Of The Augmented Thrall
        blocked.add(ItemID.SIGIL_OF_THE_BARBARIANS_UNATTUNED); // Sigil Of The Barbarians
        blocked.add(ItemID.SIGIL_OF_THE_BLOODHOUND_UNATTUNED); // Sigil Of The Bloodhound
        blocked.add(ItemID.SIGIL_OF_THE_CHEF_UNATTUNED); // Sigil Of The Chef
        blocked.add(ItemID.SIGIL_OF_THE_CRAFTER_UNATTUNED); // Sigil Of The Craftsman
        blocked.add(ItemID.SIGIL_OF_THE_DWARVES_UNATTUNED); // Sigil Of The Dwarves
        blocked.add(ItemID.SIGIL_OF_THE_ELVES_UNATTUNED); // Sigil Of The Elves
        blocked.add(ItemID.SIGIL_OF_THE_ETERNAL_JEWELLER_UNATTUNED); // Sigil Of The Eternal Jeweller
        blocked.add(ItemID.SIGIL_OF_THE_FERAL_FIGHTER_UNATTUNED); // Sigil Of The Feral Fighter
        blocked.add(ItemID.SIGIL_OF_THE_FLETCHER_UNATTUNED); // Sigil Of The Fletcher
        blocked.add(ItemID.SIGIL_OF_THE_FOOD_MASTER_UNATTUNED); // Sigil Of The Food Master
        blocked.add(ItemID.SIGIL_OF_THE_FORAGER_UNATTUNED); // Sigil Of The Forger
        blocked.add(ItemID.SIGIL_OF_THE_FORMIDABLE_FIGHTER_UNATTUNED); // Sigil Of The Formidable Fighter
        blocked.add(ItemID.SIGIL_OF_THE_FORTUNE_FARMER_UNATTUNED); // Sigil Of The Fortune Farmer
        blocked.add(ItemID.SIGIL_OF_THE_GNOMES_UNATTUNED); // Sigil Of The Gnomes
        blocked.add(ItemID.SIGIL_OF_THE_GUARDIAN_ANGEL_UNATTUNED); // Sigil Of The Guardian Angel
        blocked.add(ItemID.SIGIL_OF_THE_HUNTER_UNATTUNED); // Sigil Of The Hunter
        blocked.add(ItemID.SIGIL_OF_THE_INFERNAL_CHEF_UNATTUNED); // Sigil Of The Infernal Chef
        blocked.add(ItemID.SIGIL_OF_THE_INFERNAL_SMITH_UNATTUNED); // Sigil Of The Infernal Smith
        blocked.add(ItemID.SIGIL_OF_THE_LIGHTBEARER_UNATTUNED); // Sigil Of The Lighterbearer
        blocked.add(ItemID.SIGIL_OF_THE_MENACING_MAGE_UNATTUNED); // Sigil Of The Menacing Mage
        blocked.add(ItemID.SIGIL_OF_THE_METICULOUS_MAGE_UNATTUNED); // Sigil Of The Meticulous Mage
        blocked.add(ItemID.SIGIL_OF_THE_NINJA_UNATTUNED); // Sigil Of The Ninja
        blocked.add(ItemID.SIGIL_OF_THE_PORCUPINE_UNATTUNED); // Sigil Of The Porcupine
        blocked.add(ItemID.SIGIL_OF_THE_POTION_MASTER_UNATTUNED); // Sigil Of The Potion Master
        blocked.add(ItemID.SIGIL_OF_THE_RIGOROUS_RANGER_UNATTUNED); // Sigil Of The Rigorous Ranger
        blocked.add(ItemID.SIGIL_OF_THE_RUTHLESS_RANGER_UNATTUNED); // Sigil Of The Ruthless Ranger
        blocked.add(ItemID.SIGIL_OF_THE_SERPENT_UNATTUNED); // Sigil Of The Serpent
        blocked.add(ItemID.SIGIL_OF_THE_SKILLER_UNATTUNED); // Sigil Of The Skiller
        blocked.add(ItemID.SIGIL_OF_THE_SMITH_UNATTUNED); // Sigil Of The Smith
        blocked.add(ItemID.SIGIL_OF_THE_TREASURE_HUNTER_UNATTUNED); // Sigil Of The Treasure Hunter
        blocked.add(ItemID.SIGIL_OF_THE_WELL_FED_UNATTUNED); // Sigil Of The Well-Fed
        blocked.add(ItemID.SIGIL_OF_TITANIUM_UNATTUNED); // Sigil Of Titanium
        blocked.add(ItemID.SIGIL_OF_VERSATILITY_UNATTUNED); // Sigil Of Versatility
        blocked.add(ItemID.SIGIL_OF_WOODCRAFT_UNATTUNED); // Sigil Of Woodcraft

        // Twisted Leagues Rewards
        blocked.add(ItemID.TWISTED_BANNER); // Twisted Banner
        blocked.add(ItemID.TWISTED_BLUEPRINTS); // Twisted Blueprints
        blocked.add(ItemID.TWISTED_CANE); // Twisted Cane
        blocked.add(ItemID.TWISTED_RELIC_HUNTER_HAT_T1); // Twisted Hat (t1)
        blocked.add(ItemID.TWISTED_RELIC_HUNTER_HAT_T2); // Twisted Hat (t2)
        blocked.add(ItemID.TWISTED_RELIC_HUNTER_HAT_T3); // Twisted Hat (t3)
        blocked.add(ItemID.TWISTED_HORNS); // Twisted Horns
        blocked.add(ItemID.TWISTED_RELIC_HUNTER_TOP_T1); // Twisted Coat (t1)
        blocked.add(ItemID.TWISTED_RELIC_HUNTER_TOP_T2); // Twisted Coat (t2)
        blocked.add(ItemID.TWISTED_RELIC_HUNTER_TOP_T3); // Twisted Coat (t3)
        blocked.add(ItemID.TWISTED_RELIC_HUNTER_LEGS_T1); // Twisted Trouser (t1)
        blocked.add(ItemID.TWISTED_RELIC_HUNTER_LEGS_T2); // Twisted Trouser (t2)
        blocked.add(ItemID.TWISTED_RELIC_HUNTER_LEGS_T3); // Twisted Trouser (t3)
        blocked.add(ItemID.TWISTED_RELIC_HUNTER_BOOTS_T1); // Twisted Boots (t1)
        blocked.add(ItemID.TWISTED_RELIC_HUNTER_BOOTS_T2); // Twisted Boots (t2)
        blocked.add(ItemID.TWISTED_RELIC_HUNTER_BOOTS_T3); // Twisted Boots (t3)
        blocked.add(ItemID.SET_TWISTED_RELICHUNTER_T1); // Twisted Relic Hunter (t1) Armour Set
        blocked.add(ItemID.SET_TWISTED_RELICHUNTER_T2); // Twisted Relic Hunter (t2) Armour Set
        blocked.add(ItemID.SET_TWISTED_RELICHUNTER_T3); // Twisted Relic Hunter (t3) Armour Set
        blocked.add(ItemID.TWISTED_HOME_TELEPORT_SCROLL); // Twisted Teleport Scroll

        // Trailblazer Leagues Rewards
        blocked.add(ItemID.TRAILBLAZER_BANNER); // Trailblazer Banner
        blocked.add(ItemID.TRAILBLAZER_HOME_TELEPORT_SCROLL); // Trailblazer Teleport Scroll
        blocked.add(ItemID.TRAILBLAZER_TOOL_ORNAMENTKIT); // Trailblazer Tool Ornament Kit
        blocked.add(ItemID.TRAILBLAZER_GRACEFUL_KIT); // Trailblazer Graceful Ornament Kit
        blocked.add(ItemID.TRAILBLAZER_STATUE); // Trailblazer Globe
        blocked.add(ItemID.TRAILBLAZER_RUG); // Trailblazer Rug
        blocked.add(ItemID.TRAILBLAZER_CANE); // Trailblazer Cane
        blocked.add(ItemID.TRAILBLAZER_RELIC_HUNTER_HOOD_T1); // Trailblazer Hood (t1)
        blocked.add(ItemID.TRAILBLAZER_RELIC_HUNTER_HOOD_T2); // Trailblazer Hood (t2)
        blocked.add(ItemID.TRAILBLAZER_RELIC_HUNTER_HOOD_T3); // Trailblazer Hood (t3)
        blocked.add(ItemID.TRAILBLAZER_RELIC_HUNTER_TOP_T1); // Trailblazer Top (t1)
        blocked.add(ItemID.TRAILBLAZER_RELIC_HUNTER_TOP_T2); // Trailblazer Top (t2)
        blocked.add(ItemID.TRAILBLAZER_RELIC_HUNTER_TOP_T3); // Trailblazer Top (t3)
        blocked.add(ItemID.TRAILBLAZER_RELIC_HUNTER_LEGS_T1); // Trailblazer Trousers (t1)
        blocked.add(ItemID.TRAILBLAZER_RELIC_HUNTER_LEGS_T2); // Trailblazer Trousers (t2)
        blocked.add(ItemID.TRAILBLAZER_RELIC_HUNTER_LEGS_T3); // Trailblazer Trouser (t3)
        blocked.add(ItemID.TRAILBLAZER_RELIC_HUNTER_BOOTS_T1); // Trailblazer Boots (t1)
        blocked.add(ItemID.TRAILBLAZER_RELIC_HUNTER_BOOTS_T2); // Trailblazer Boots (t2)
        blocked.add(ItemID.TRAILBLAZER_RELIC_HUNTER_BOOTS_T3); // Trailblazer Boots (t3)
        blocked.add(ItemID.SET_TRAILBLAZER_RELICHUNTER_T1); // Trailblazer Relic Hunter (t1) Armour Set
        blocked.add(ItemID.SET_TRAILBLAZER_RELICHUNTER_T2); // Trailblazer Relic Hunter (t2) Armour Set
        blocked.add(ItemID.SET_TRAILBLAZER_RELICHUNTER_T3); // Trailblazer Relic Hunter (t3) Armour Set

        // Shattered Leagues Rewards
        blocked.add(ItemID.LEAGUE_3_BANNER); // Shattered Banner
        blocked.add(ItemID.LEAGUE_3_HOME_TELEPORT_SCROLL); // Shattered Teleport Scroll
        blocked.add(ItemID.LEAGUE_3_CANE); // Shattered Cane
        blocked.add(ItemID.LEAGUE_3_WEAPON_VARIETY_PACK); // Shattered Relics Variety Ornament Kit
        blocked.add(ItemID.LEAGUE_3_VOID_KIT); // Shattered Relics Void Ornament Kit
        blocked.add(ItemID.LEAGUE_3_MYSTIC_ORNAMENT_PACK); // Shattered Relics Mystic Ornament Kit
        blocked.add(ItemID.LEAGUE_3_MULTICANNON_PACK); // Shattered Cannon Ornament Kit
        blocked.add(ItemID.LEAGUE_3_RELIC_HUNTER_HOOD_T1); // Shattered Hood (t1)
        blocked.add(ItemID.LEAGUE_3_RELIC_HUNTER_HOOD_T2); // Shattered Hood (t2)
        blocked.add(ItemID.LEAGUE_3_RELIC_HUNTER_HOOD_T3); // Shattered Hood (t3)
        blocked.add(ItemID.LEAGUE_3_RELIC_HUNTER_TOP_T1); // Shattered Top (t1)
        blocked.add(ItemID.LEAGUE_3_RELIC_HUNTER_TOP_T2); // Shattered Top (t2)
        blocked.add(ItemID.LEAGUE_3_RELIC_HUNTER_TOP_T3); // Shattered Top (t3)
        blocked.add(ItemID.LEAGUE_3_RELIC_HUNTER_LEGS_T1); // Shattered Trousers (t1)
        blocked.add(ItemID.LEAGUE_3_RELIC_HUNTER_LEGS_T2); // Shattered Trousers (t2)
        blocked.add(ItemID.LEAGUE_3_RELIC_HUNTER_LEGS_T3); // Shattered Trousers (t3)
        blocked.add(ItemID.LEAGUE_3_RELIC_HUNTER_BOOTS_T1); // Shattered Boots (t1)
        blocked.add(ItemID.LEAGUE_3_RELIC_HUNTER_BOOTS_T2); // Shattered Boots (t2)
        blocked.add(ItemID.LEAGUE_3_RELIC_HUNTER_BOOTS_T3); // Shattered Boots (t3)
        blocked.add(ItemID.SET_LEAGUE_3_RELICHUNTER_T1); // Shattered Relic Hunter (t1) Armour Set
        blocked.add(ItemID.SET_LEAGUE_3_RELICHUNTER_T2); // Shattered Relic Hunter (t2) Armour Set
        blocked.add(ItemID.SET_LEAGUE_3_RELICHUNTER_T3); // Shattered Relic Hunter (t3) Armour Set

        // Trailblazer Reloaded Leagues Rewards
        blocked.add(ItemID.LEAGUE_4_BANNER); // Trailblazer Reloaded Banner
        blocked.add(ItemID.LEAGUE_4_HOME_TELEPORT_SCROLL); // Trailblazer Reloaded Home Teleport Scroll
        blocked.add(ItemID.LEAGUE_4_DEATH_SCROLL); // Trailblazer Reloaded Death Scroll
        blocked.add(ItemID.LEAGUE_4_ALCHEMY_SCROLL); // Trailblazer Reloaded Alchemy Scroll
        blocked.add(ItemID.LEAGUE_4_VENGEANCE_SCROLL); // Trailblazer Reloaded Vengeance Scroll
        blocked.add(ItemID.LEAGUE_4_REJUVINATION_POOL_SCROLL); // Trailblazer Reloaded Rejuvenation Pool Scroll
        blocked.add(ItemID.LEAGUE_4_TORCH); // Trailblazer Reloaded Torch
        blocked.add(ItemID.TOXIC_BLOWPIPE_ORNAMENT_KIT); // Trailblazer Reloaded Blowpipe Ornament Kit
        blocked.add(ItemID.DINHS_BULWARK_ORNAMENT_KIT); // Trailblazer Reloaded Banner Bulwark Ornament Kit
        blocked.add(ItemID.LEAGUE_4_RELIC_HUNTER_HAT_T1); // Trailblazer Reloaded Headband (t1)
        blocked.add(ItemID.LEAGUE_4_RELIC_HUNTER_HAT_T2); // Trailblazer Reloaded Headband (t2)
        blocked.add(ItemID.LEAGUE_4_RELIC_HUNTER_HAT_T3); // Trailblazer Reloaded Headband (t3)
        blocked.add(ItemID.LEAGUE_4_RELIC_HUNTER_TOP_T1); // Trailblazer Reloaded Top (t1)
        blocked.add(ItemID.LEAGUE_4_RELIC_HUNTER_TOP_T2); // Trailblazer Reloaded Top (t2)
        blocked.add(ItemID.LEAGUE_4_RELIC_HUNTER_TOP_T3); // Trailblazer Reloaded Top (t3)
        blocked.add(ItemID.LEAGUE_4_RELIC_HUNTER_LEGS_T1); // Trailblazer Reloaded Trousers (t1)
        blocked.add(ItemID.LEAGUE_4_RELIC_HUNTER_LEGS_T2); // Trailblazer Reloaded Trousers (t2)
        blocked.add(ItemID.LEAGUE_4_RELIC_HUNTER_LEGS_T3); // Trailblazer Reloaded Trousers (t3)
        blocked.add(ItemID.LEAGUE_4_RELIC_HUNTER_BOOTS_T1); // Trailblazer Reloaded Boots (t1)
        blocked.add(ItemID.LEAGUE_4_RELIC_HUNTER_BOOTS_T2); // Trailblazer Reloaded Boots (t2)
        blocked.add(ItemID.LEAGUE_4_RELIC_HUNTER_BOOTS_T3); // Trailblazer Reloaded Boots (t3)
        blocked.add(ItemID.SET_LEAGUE_4_RELICHUNTER_T1); // Trailblazer Reloaded Relic Hunter (t1) Armour Set
        blocked.add(ItemID.SET_LEAGUE_4_RELICHUNTER_T2); // Trailblazer Reloaded Relic Hunter (t2) Armour Set
        blocked.add(ItemID.SET_LEAGUE_4_RELICHUNTER_T3); // Trailblazer Reloaded Relic Hunter (t3) Armour Set

        // Raging Echoes Leagues Rewards
        blocked.add(ItemID.LEAGUE_5_BANNER); // Raging Echoes
        blocked.add(ItemID.LEAGUE_5_RUG); // Raging Echoes Rug
        blocked.add(ItemID.LEAGUE_5_CURTAINS); // Raging Echoes Curtains
        blocked.add(ItemID.LEAGUE_5_SPIRIT_TREE_SCROLL); // Raging Echoes Spirit Tree Scroll
        blocked.add(ItemID.LEAGUE_5_NEXUS_SCROLL); // Raging Echoes Portal Nexus Scroll
        blocked.add(ItemID.LEAGUE_5_SCRYING_SCROLL); // Raging Echoes Scrying Pool Scroll
        blocked.add(ItemID.LEAGUE_5_PORTAL_SCROLL); // Raging Echoes Portal Scroll
        blocked.add(ItemID.LEAGUE_5_HOME_TELEPORT_SCROLL); // Raging Echoes Home Teleport
        blocked.add(ItemID.LEAGUE_5_DEATH_SCROLL); // Raging Echoes Death Scroll
        blocked.add(ItemID.LEAGUE_5_CONTACT_SCROLL); // Raging Echoes NPC Contact Scroll
        blocked.add(ItemID.LEAGUE5_RELIC_HUNTER_CANE); // Raging Echoes Cane
        blocked.add(ItemID.BARROWS_AHRIM_ORNAMENT_KIT); // Echo Ahrim's Robes Ornament Kit
        blocked.add(ItemID.BARROWS_AHRIM_WEAPON); // Echo Ahrim's Staff Ornament Kit
        blocked.add(ItemID.VIRTUS_ORNAMENT_KIT); // Echo Virtus Robes Ornament Kit
        blocked.add(ItemID.VENATOR_BOW_ORNAMENT_KIT); // Echo Venator Bow Ornament Kit
        blocked.add(ItemID.LEAGUE5_RELIC_HUNTER_HAT_T1); // Raging Echoes Hat (t1)
        blocked.add(ItemID.LEAGUE5_RELIC_HUNTER_HAT_T2); // Raging Echoes Hat (t2)
        blocked.add(ItemID.LEAGUE5_RELIC_HUNTER_HAT_T3); // Raging Echoes Hat (t3)
        blocked.add(ItemID.LEAGUE5_RELIC_HUNTER_TOP_T1); // Raging Echoes Top (t1)
        blocked.add(ItemID.LEAGUE5_RELIC_HUNTER_TOP_T2); // Raging Echoes Top (t2)
        blocked.add(ItemID.LEAGUE5_RELIC_HUNTER_TOP_T3); // Raging Echoes Top (t3)
        blocked.add(ItemID.LEAGUE5_RELIC_HUNTER_LEGS_T1); // Raging Echoes Robeskirt (t1)
        blocked.add(ItemID.LEAGUE5_RELIC_HUNTER_LEGS_T2); // Raging Echoes Robeskirt (t2)
        blocked.add(ItemID.LEAGUE5_RELIC_HUNTER_LEGS_T3); // Raging Echoes Robeskirt (t3)
        blocked.add(ItemID.LEAGUE5_RELIC_HUNTER_BOOTS_T1); // Raging Echoes Boots (t1)
        blocked.add(ItemID.LEAGUE5_RELIC_HUNTER_BOOTS_T2); // Raging Echoes Boots (t2)
        blocked.add(ItemID.LEAGUE5_RELIC_HUNTER_BOOTS_T3); // Raging Echoes Boots (t3)
        blocked.add(ItemID.SET_LEAGUE_5_RELICHUNTER_T1); // Raging Echoes Relic Hunter (t1) Armour Set
        blocked.add(ItemID.SET_LEAGUE_5_RELICHUNTER_T2); // Raging Echoes Relic Hunter (t2) Armour Set
        blocked.add(ItemID.SET_LEAGUE_5_RELICHUNTER_T3); // Raging Echoes Relic Hunter (t3) Armour Set

        //Gridmaster Rewards
        blocked.add(ItemID.BINGO_TABARD); // Grid master tabard
        blocked.add(ItemID.BINGO_TABARD_BLACK); // Grid master tabard (b)
        blocked.add(ItemID.BINGO_TABARD_PINK); // Grid master tabard (p)
        blocked.add(ItemID.BINGO_TABARD_GREEN); // Grid master tabard (g)
        blocked.add(ItemID.BINGO_SWORDS); // Swords and emblem
        blocked.add(ItemID.BINGO_SWORDS_BLACK); // Swords and emblem (b)
        blocked.add(ItemID.BINGO_SWORDS_PINK); // Swords and emblem (p)
        blocked.add(ItemID.BINGO_SWORDS_GREEN); // Swords and emblem (g)
        blocked.add(ItemID.BINGO_ALTAR_ICON_SCROLL); // Grid master altar icon scroll
        blocked.add(ItemID.BINGO_TORCH_SCROLL); // Grid master torch scroll

        // Unobtainable Items
        blocked.add(ItemID.BALL_OF_COTTON);
        blocked.add(ItemID.CHOMPY_COOKED); // Cooked Chompy (roasted)
        blocked.add(ItemID.CHICKENQUEST_CORNFLOUR); // Cornflour
        blocked.add(ItemID.POH_FLATPACK_CRYSTALBALL1); // Crystal Ball (FLATPACK)
        blocked.add(ItemID.POH_FLATPACK_CRYSTALBALL2); // Elemental Sphere (FLATPACK)
        blocked.add(ItemID.POH_FLATPACK_CRYSTALBALL3); // Crystal Of Power (FLATPACK)
        blocked.add(ItemID.POH_FLATPACK_GLOBE1); // Globe (FLATPACK)
        blocked.add(ItemID.POH_FLATPACK_GLOBE2); // Ornamental Globe (FLATPACK)
        blocked.add(ItemID.POH_FLATPACK_GLOBE3); // Lunar Globe (FLATPACK)
        blocked.add(ItemID.POH_FLATPACK_GLOBE4); // Celestial Globe (FLATPACK)
        blocked.add(ItemID.POH_FLATPACK_GLOBE5); // Armillary Globe (FLATPACK)
        blocked.add(ItemID.POH_FLATPACK_GLOBE6); // Small Orrery (FLATPACK)
        blocked.add(ItemID.POH_FLATPACK_GLOBE7); // Large Orrery (FLATPACK)
        blocked.add(ItemID.POH_FLATPACK_TELESCOPE1); // Oak Telescope (FLATPACK)
        blocked.add(ItemID.POH_FLATPACK_TELESCOPE2); // Teak Telescope (FLATPACK)
        blocked.add(ItemID.POH_FLATPACK_TELESCOPE3); // Mahogany (FLATPACK)
        blocked.add(ItemID.UNFINISHED_WORM_CRUNCHIES); // Rock-Climbing Boots
        blocked.add(ItemID.OSB9_REPORT); // Osman's Report
        blocked.add(ItemID.FEUD_KARIDIAN_FAKEBEARD_AND_HAT); // Karidian Disguise
        blocked.add(ItemID.POH_FLATPACK_LECTURN1); // Oak Lectern (FLATPACK)
        blocked.add(ItemID.POH_FLATPACK_LECTURN2); // Eagle Lectern (FLATPACK)
        blocked.add(ItemID.POH_FLATPACK_LECTURN3); // Demon Lectern (FLATPACK)
        blocked.add(ItemID.POH_FLATPACK_LECTURN4); // Teak Eagle Lectern (FLATPACK)
        blocked.add(ItemID.POH_FLATPACK_LECTURN5); // Teak Demon Lectern (FLATPACK)
        blocked.add(ItemID.POH_FLATPACK_LECTURN6); // Mahogany Eagle (FLATPACK)
        blocked.add(ItemID.POH_FLATPACK_LECTURN7); // Mahogany Demon (FLATPACK)
        blocked.add(ItemID.BH_SUPPLY_CRATE); // Bounty Supply Crate
        BLOCKED_ITEMS = Collections.unmodifiableSet(blocked);
    }
}

package com.choicer.chanceman.filters;

import lombok.Getter;
import net.runelite.api.gameval.ItemID;
import java.util.Collections;
import java.util.HashSet;
import java.util.Set;

public enum ItemSets {

    // Items are sorted in the same order as displayed on the Grand Exchange interface
    DwarfCannon(ItemID.SET_CANNON),

    // Dragonhide sets
    GreenDragonhide(ItemID.SET_DHIDE_GREEN),
    BlueDragonhide(ItemID.SET_DHIDE_BLUE),
    RedDragonhide(ItemID.SET_DHIDE_RED),
    BlackDragonhide(ItemID.SET_DHIDE_BLACK),

    // Barrows armour sets
    Guthans(ItemID.SET_BARROWS_GUTHAN),
    Veracs(ItemID.SET_BARROWS_VERAC),
    Dharoks(ItemID.SET_BARROWS_DHAROK),
    Torags(ItemID.SET_BARROWS_TORAG),
    Ahrims(ItemID.SET_BARROWS_AHRIM),
    Karils(ItemID.SET_BARROWS_KARIL),

    // Potion sets
    CombatPotion(ItemID.SET_COMBAT_POTION),
    SuperPotion(ItemID.SET_SUPERCOMBAT_POTION),

    // Base metal armour sets
    BronzeLegs(ItemID.SET_BRONZE_LEGS),
    BronzeSkirt(ItemID.SET_BRONZE_SKIRT),

    IronLegs(ItemID.SET_IRON_LEGS),
    IronSkirt(ItemID.SET_IRON_SKIRT),

    SteelLegs(ItemID.SET_STEEL_LEGS),
    SteelSkirt(ItemID.SET_STEEL_SKIRT),

    BlackLegs(ItemID.SET_BLACK_LEGS),
    BlackSkirt(ItemID.SET_BLACK_SKIRT),

    MithrilLegs(ItemID.SET_MITHRIL_LEGS),
    MithrilSkirt(ItemID.SET_MITHRIL_SKIRT),

    AdamantLegs(ItemID.SET_ADAMANT_LEGS),
    AdamantSkirt(ItemID.SET_ADAMANT_SKIRT),

    RuneLegs(ItemID.SET_RUNE_LEGS),
    RuneSkirt(ItemID.SET_RUNE_SKIRT),

    // Trimmed and gilded base metal armour sets

    BronzeLegsTrim(ItemID.SET_BRONZE_LEGS_TRIM),
    BronzeSkirtTrim(ItemID.SET_BRONZE_SKIRT_TRIM),
    BronzeLegsGold(ItemID.SET_BRONZE_LEGS_GOLD),
    BronzeSkirtGold(ItemID.SET_BRONZE_SKIRT_GOLD),

    IronLegsTrim(ItemID.SET_IRON_LEGS_TRIM),
    IronSkirtTrim(ItemID.SET_IRON_SKIRT_TRIM),
    IronLegsGold(ItemID.SET_IRON_LEGS_GOLD),
    IronSkirtGold(ItemID.SET_IRON_SKIRT_GOLD),

    SteelLegsTrim(ItemID.SET_STEEL_LEGS_TRIM),
    SteelSkirtTrim(ItemID.SET_STEEL_SKIRT_TRIM),
    SteelLegsGold(ItemID.SET_STEEL_LEGS_GOLD),
    SteelSkirtGold(ItemID.SET_STEEL_SKIRT_GOLD),

    BlackLegsTrim(ItemID.SET_BLACK_LEGS_TRIM),
    BlackSkirtTrim(ItemID.SET_BLACK_SKIRT_TRIM),
    BlackLegsGold(ItemID.SET_BLACK_LEGS_GOLD),
    BlackSkirtGold(ItemID.SET_BLACK_SKIRT_GOLD),

    MithrilLegsTrim(ItemID.SET_MITHRIL_LEGS_TRIM),
    MithrilSkirtTrim(ItemID.SET_MITHRIL_SKIRT_TRIM),
    MithrilLegsGold(ItemID.SET_MITHRIL_LEGS_GOLD),
    MithrilSkirtGold(ItemID.SET_MITHRIL_SKIRT_GOLD),

    AdamantLegsTrim(ItemID.SET_ADAMANT_LEGS_TRIM),
    AdamantSkirtTrim(ItemID.SET_ADAMANT_SKIRT_TRIM),
    AdamantLegsGold(ItemID.SET_ADAMANT_LEGS_GOLD),
    AdamantSkirtGold(ItemID.SET_ADAMANT_SKIRT_GOLD),

    RuneLegsTrim(ItemID.SET_RUNE_LEGS_TRIM),
    RuneSkirtTrim(ItemID.SET_RUNE_SKIRT_TRIM),
    RuneLegsGold(ItemID.SET_RUNE_LEGS_GOLD),
    RuneSkirtGold(ItemID.SET_RUNE_SKIRT_GOLD),

    // Dragon armour sets
    DragonLegs(ItemID.SET_DRAGON_LEGS),
    DragonSkirt(ItemID.SET_DRAGON_SKIRT),

    // God rune armour sets
    SaradominLegs(ItemID.SET_RUNE_LEGS_SARADOMIN),
    SaradominSkirt(ItemID.SET_RUNE_SKIRT_SARADOMIN),

    ZamorakLegs(ItemID.SET_RUNE_LEGS_ZAMORAK),
    ZamorakSkirt(ItemID.SET_RUNE_SKIRT_ZAMORAK),

    GuthixLegs(ItemID.SET_RUNE_LEGS_GUTHIX),
    GuthixSkirt(ItemID.SET_RUNE_SKIRT_GUTHIX),

    ArmadylLegs(ItemID.SET_RUNE_LEGS_ARMADYL),
    ArmadylSkirt(ItemID.SET_RUNE_SKIRT_ARMADYL),

    BandosLegs(ItemID.SET_RUNE_LEGS_BANDOS),
    BandosSkirt(ItemID.SET_RUNE_SKIRT_BANDOS),

    AncientLegs(ItemID.SET_RUNE_LEGS_ANCIENT),
    AncientSkirt(ItemID.SET_RUNE_SKIRT_ANCIENT),

    // Gilded armour sets
    GildedArmourLegs(ItemID.SET_RUNE_LEGS_GOLDPLATE),
    GildedArmourSkirt(ItemID.SET_RUNE_SKIRT_GOLDPLATE),

    // God book page sets
    HolyBookPage(ItemID.SET_HOLY_BOOK),
    UnholyBookPage(ItemID.SET_UNHOLY_BOOK),
    BookBalancePage(ItemID.SET_BOOK_BALANCE),
    BookWarPage(ItemID.SET_BOOK_WAR),
    BookLawPage(ItemID.SET_BOOK_LAW),
    BookDarknessPage(ItemID.SET_BOOK_DARKNESS),

    // Dragonhide sets
    GildedDragonhide(ItemID.SET_DHIDE_GILDED),
    ZamorakDragonhide(ItemID.SET_DHIDE_ZAMORAK),
    SaradominDragonhide(ItemID.SET_DHIDE_SARADOMIN),
    GuthixDragonhide(ItemID.SET_DHIDE_GUTHIX),
    BandosDragonhide(ItemID.SET_DHIDE_BANDOS),
    ArmadylDragonhide(ItemID.SET_DHIDE_ARMADYL),
    AncientDragonhide(ItemID.SET_DHIDE_ANCIENT),

    // Miscellaneous sets
    OathplateSet(ItemID.SET_OATHPLATE_ARMOUR),
    BloodMoonSet(31136),
    BlueMoonSet(31139),
    EclipseMoonSet(31142),
    TorvaSet(31145),
    VirtusSet(31148),
    RockShellSet(31151),
    SkeletalSet(31154),
    SpinedSet(31157),
    SwampBarkSet(31160),
    BloodBarkSet(31163),
    MixedHideSet(31166),
    HueyHideSet(31169),
    PartyhatSet(ItemID.SET_PARTYHAT),
    HalloweenMaskSet(ItemID.SET_HALLOWEEN_MASK),
    AncestralRobes(ItemID.SET_ANCESTRAL_ROBES),
    ObsidianArmour(ItemID.SET_OBSIDIAN_ARMOUR),
    JusticiarArmour(ItemID.SET_JUSTICIAR_ARMOUR),
    MysticLight(ItemID.SET_MYSTIC_LIGHT),
    MysticBlue(ItemID.SET_MYSTIC_BLUE),
    MysticDark(ItemID.SET_MYSTIC_DARK),
    MysticDusk(ItemID.SET_MYSTIC_DUSK),
    DragonstoneArmour(ItemID.SET_DRAGONSTONE_ARMOUR),
    DagonhaiRobes(ItemID.SET_DAGONHAI_ROBES),
    InquisitorsArmour(ItemID.SET_INQUISITORS_ARMOUR),
    MasoriFortified(ItemID.SET_MASORI_FORTIFIED),
    // Leagues item sets are omitted as they are globally blocked
    SunfireFanatic(ItemID.SET_SUNFIRE_FANATIC);

    @Getter
    private final int id;

    ItemSets(int id) {
        this.id = id;
    }

    /**
     * Returns an unmodifiable set of all item set item IDs.
     */
    public static Set<Integer> getAllItemSetIds() {
        Set<Integer> ids = new HashSet<>();
        for (ItemSets as : ItemSets.values()) {
            ids.add(as.getId());
        }
        return Collections.unmodifiableSet(ids);
    }

    /**
     * Checks if the given item ID is one of the item set items.
     *
     * @param id the item id to check.
     * @return true if the id belongs to an item set, false otherwise.
     */
    public static boolean isItemSet(int id) {
        return getAllItemSetIds().contains(id);
    }
}

package com.choicer.chanceman.filters;

import lombok.Getter;

import java.util.Collections;
import java.util.HashSet;
import java.util.Set;

/**
 * Tracks the set of untradeable item IDs that can participate in ChanceMan rolls
 * when the Include Untradeable config toggle is enabled.
 */
public final class UntradeableAllowlist
{
    @Getter
    private static final Set<Integer> ALLOWED_UNTRADEABLE_ITEMS;

    static
    {
        Set<Integer> items = new HashSet<>();

        items.add(7453);
        items.add(7454);
        items.add(7455);
        items.add(7456);
        items.add(7457);
        items.add(7458);
        items.add(7459);
        items.add(7460);
        items.add(7461);
        items.add(7462);
        items.add(19675);
        items.add(6746);
        items.add(2402);
        items.add(4081);
        items.add(13121);
        items.add(13122);
        items.add(13123);
        items.add(13124);
        items.add(13117);
        items.add(13118);
        items.add(13119);
        items.add(13120);
        items.add(13129);
        items.add(13130);
        items.add(13131);
        items.add(13132);
        items.add(13137);
        items.add(13138);
        items.add(13139);
        items.add(13140);
        items.add(11136);
        items.add(11138);
        items.add(11140);
        items.add(13103);
        items.add(22941);
        items.add(22943);
        items.add(22945);
        items.add(22947);
        items.add(13125);
        items.add(13126);
        items.add(13127);
        items.add(13128);
        items.add(13112);
        items.add(13113);
        items.add(13114);
        items.add(13115);
        items.add(13104);
        items.add(13105);
        items.add(13106);
        items.add(13107);
        items.add(13141);
        items.add(13142);
        items.add(13143);
        items.add(13144);
        items.add(13108);
        items.add(13109);
        items.add(13110);
        items.add(13111);
        items.add(22109);
        items.add(10499);
        items.add(10498);
        items.add(10887);
        items.add(13357);
        items.add(13358);
        items.add(13359);
        items.add(13360);
        items.add(13361);
        items.add(13362);
        items.add(13363);
        items.add(13364);
        items.add(13365);
        items.add(13366);
        items.add(13367);
        items.add(13368);
        items.add(13369);
        items.add(13370);
        items.add(13371);
        items.add(13372);
        items.add(13373);
        items.add(13374);
        items.add(13375);
        items.add(13376);
        items.add(13377);
        items.add(13378);
        items.add(13379);
        items.add(13380);
        items.add(13381);
        items.add(11850);
        items.add(11852);
        items.add(11854);
        items.add(11856);
        items.add(11858);
        items.add(11860);
        items.add(29309);
        items.add(29263);
        items.add(29265);
        items.add(29267);
        items.add(29269);
        items.add(28173);
        items.add(28169);
        items.add(28171);
        items.add(28175);
        items.add(28630);
        items.add(28140);
        items.add(28613);
        items.add(28136);
        items.add(8844);
        items.add(8845);
        items.add(8846);
        items.add(8847);
        items.add(8848);
        items.add(8849);
        items.add(8850);
        items.add(12954);
        items.add(22846);
        items.add(22844);
        items.add(22842);
        items.add(13258);
        items.add(13259);
        items.add(13260);
        items.add(13261);
        items.add(12013);
        items.add(12014);
        items.add(12015);
        items.add(12016);
        items.add(12019);
        items.add(12020);
        items.add(31043);
        items.add(31052);
        items.add(13646);
        items.add(13643);
        items.add(13640);
        items.add(13644);
        items.add(13639);
        items.add(13353);
        items.add(13226);
        items.add(10941);
        items.add(10939);
        items.add(10940);
        items.add(10933);
        items.add(25344);
        items.add(25438);
        items.add(25434);
        items.add(25436);
        items.add(25440);
        items.add(25474);
        items.add(25476);
        items.add(5554);
        items.add(5553);
        items.add(5556);
        items.add(5555);
        items.add(5557);
        items.add(8841);
        items.add(8839);
        items.add(8840);
        items.add(8842);
        items.add(11665);
        items.add(11664);
        items.add(11663);
        items.add(13073);
        items.add(13072);
        items.add(24721);
        items.add(24723);
        items.add(24725);
        items.add(24719);
        items.add(24727);
        items.add(24731);
        items.add(26813);
        items.add(26822);
        items.add(26850);
        items.add(26852);
        items.add(26854);
        items.add(26856);
        items.add(27021);
        items.add(10548);
        items.add(10550);
        items.add(10547);
        items.add(10549);
        items.add(10551);
        items.add(10555);
        items.add(10552);
        items.add(10553);
        items.add(13273);
        items.add(13275);
        items.add(13274);
        items.add(13276);
        items.add(22971);
        items.add(22973);
        items.add(22969);
        items.add(29799);
        items.add(29794);
        items.add(29790);
        items.add(29792);
        items.add(29589);
        items.add(29594);
        items.add(29591);
        items.add(12727);
        items.add(27873);
        items.add(28321);
        items.add(28281);
        items.add(28270);
        items.add(6570);
        items.add(2412);
        items.add(2414);
        items.add(2413);
        items.add(21791);
        items.add(21795);
        items.add(21793);
        items.add(22114);
        items.add(28951);
        items.add(23973);
        items.add(23977);
        items.add(23981);
        items.add(21295);
        items.add(30955);
        items.add(28792);
        items.add(28794);
        items.add(28796);
        items.add(28325);
        items.add(28283);
        items.add(28274);
        items.add(27627);
        items.add(30626);
        items.add(30627);
        items.add(28798);
        items.add(25592);
        items.add(25594);
        items.add(25596);
        items.add(25598);
        items.add(25580);
        items.add(25582);
        items.add(28319);
        items.add(28285);
        items.add(28268);
        items.add(21907);
        items.add(28279);
        items.add(28323);
        items.add(28272);
        items.add(20708);
        items.add(20704);
        items.add(20706);
        items.add(20710);
        items.add(20712);
        items.add(20720);
        items.add(27279);
        items.add(27285);
        items.add(27289);
        items.add(27283);
        items.add(30893);
        items.add(25979);
        items.add(30902);
        items.add(30904);
        items.add(30906);
        items.add(30908);
        items.add(30910);
        items.add(30912);
        items.add(30914);
        items.add(30916);
        items.add(30918);
        items.add(30920);
        items.add(30922);
        items.add(30924);
        items.add(30926);
        items.add(9096);
        items.add(9097);
        items.add(9098);
        items.add(9099);
        items.add(9100);
        items.add(9101);
        items.add(9102);
        items.add(9104);
        items.add(9084);
        items.add(772);
        items.add(24872);
        items.add(24874);
        items.add(24876);
        items.add(24878);
        items.add(29974);
        items.add(29978);
        items.add(29982);
        items.add(29986);
        items.add(1409);
        items.add(7409);
        items.add(7637);
        items.add(7639);
        items.add(22398);
        items.add(24699);
        items.add(24123);
        items.add(24127);
        items.add(24125);
        items.add(777);
        items.add(778);
        items.add(776);
        items.add(775);
        items.add(1580);
        items.add(1052);
        items.add(24266);
        items.add(13133);
        items.add(13134);
        items.add(13135);
        items.add(13136);


        ALLOWED_UNTRADEABLE_ITEMS = Collections.unmodifiableSet(items);
    }

    private UntradeableAllowlist()
    {
        // Utility class
    }
}

package com.choicer.chanceman.filters;

import lombok.Getter;

import java.util.Collections;
import java.util.HashMap;
import java.util.Map;

import net.runelite.api.gameval.ItemID;

/**
 * Maps ensouled head item IDs (including untradeable drop IDs) to their tradeable IDs.
 * Non-ensouled or unknown IDs are returned unchanged by {@link #toTradeableId(int)}.
 */
public final class EnsouledHeadMapping {

    @Getter
    public static final Map<Integer, Integer> ENSOULED_CANONICAL_ID;

    static {
        Map<Integer, Integer> idMap = new HashMap<>();

        java.util.function.BiConsumer<Integer, Integer> pair = (untradeable, tradeable) -> {
            idMap.put(untradeable, tradeable);
            idMap.put(tradeable, tradeable);
        };

        pair.accept(ItemID.ARCEUUS_CORPSE_GOBLIN_INITIAL, ItemID.ARCEUUS_CORPSE_GOBLIN); // Goblin
        pair.accept(ItemID.ARCEUUS_CORPSE_MONKEY_INITIAL, ItemID.ARCEUUS_CORPSE_MONKEY); // Monkey
        pair.accept(ItemID.ARCEUUS_CORPSE_IMP_INITIAL, ItemID.ARCEUUS_CORPSE_IMP); // Imp
        pair.accept(ItemID.ARCEUUS_CORPSE_MINOTAUR_INITIAL, ItemID.ARCEUUS_CORPSE_MINOTAUR); // Minotaur
        pair.accept(ItemID.ARCEUUS_CORPSE_SCORPION_INITIAL, ItemID.ARCEUUS_CORPSE_SCORPION); // Scorpion
        pair.accept(ItemID.ARCEUUS_CORPSE_BEAR_INITIAL, ItemID.ARCEUUS_CORPSE_BEAR); // Bear
        pair.accept(ItemID.ARCEUUS_CORPSE_UNICORN_INITIAL, ItemID.ARCEUUS_CORPSE_UNICORN ); // Unicorn
        pair.accept(ItemID.ARCEUUS_CORPSE_DOG_INITIAL, ItemID.ARCEUUS_CORPSE_DOG); // Dog
        pair.accept(ItemID.ARCEUUS_CORPSE_CHAOSDRUID_INITIAL, ItemID.ARCEUUS_CORPSE_CHAOSDRUID); // Chaos Druid
        pair.accept(ItemID.ARCEUUS_CORPSE_GIANT_INITIAL, ItemID.ARCEUUS_CORPSE_GIANT); // Giant
        pair.accept(ItemID.ARCEUUS_CORPSE_OGRE_INITIAL, ItemID.ARCEUUS_CORPSE_OGRE); // Ogre
        pair.accept(ItemID.ARCEUUS_CORPSE_ELF_INITIAL, ItemID.ARCEUUS_CORPSE_ELF); // Elf
        pair.accept(ItemID.ARCEUUS_CORPSE_TROLL_INITIAL, ItemID.ARCEUUS_CORPSE_TROLL); // Troll
        pair.accept(ItemID.ARCEUUS_CORPSE_HORROR_INITIAL, ItemID.ARCEUUS_CORPSE_HORROR); // Horror
        pair.accept(ItemID.ARCEUUS_CORPSE_KALPHITE_INITIAL, ItemID.ARCEUUS_CORPSE_KALPHITE); // Kalphite
        pair.accept(ItemID.ARCEUUS_CORPSE_DAGANNOTH_INITIAL, ItemID.ARCEUUS_CORPSE_DAGANNOTH); // Dagannoth
        pair.accept(ItemID.ARCEUUS_CORPSE_BLOODVELD_INITIAL, ItemID.ARCEUUS_CORPSE_BLOODVELD); // Bloodveld
        pair.accept(ItemID.ARCEUUS_CORPSE_TZHAAR_INITIAL, ItemID.ARCEUUS_CORPSE_TZHAAR); // TzHaar
        pair.accept(ItemID.ARCEUUS_CORPSE_DEMON_INITIAL, ItemID.ARCEUUS_CORPSE_DEMON); // Demon
        pair.accept(ItemID.ARCEUUS_CORPSE_AVIANSIE_INITIAL, ItemID.ARCEUUS_CORPSE_AVIANSIE); //Aviansie
        pair.accept(ItemID.ARCEUUS_CORPSE_ABYSSAL_INITIAL, ItemID.ARCEUUS_CORPSE_ABYSSAL); // Abyssal
        pair.accept(ItemID.ARCEUUS_CORPSE_DRAGON_INITIAL, ItemID.ARCEUUS_CORPSE_DRAGON); // Dragon
        pair.accept(ItemID.ARCEUUS_CORPSE_HELLHOUND_INITIAL, ItemID.ARCEUUS_CORPSE_HELLHOUND); // Hellhound

        ENSOULED_CANONICAL_ID = Collections.unmodifiableMap(idMap);
    }

    private EnsouledHeadMapping() { /* utility class, no instances */ }

    /**
     * Returns the tradeable ID for any ensouled head item ID.
     * If the ID is already tradeable or not recognized as an ensouled head, it's returned unchanged.
     */
    public static int toTradeableId(int itemId) {
        return ENSOULED_CANONICAL_ID.getOrDefault(itemId, itemId);
    }
}

package com.choicer.chanceman.filters;

import com.choicer.chanceman.ChanceManConfig;

import java.util.Set;

/**
 * Utility class for additional item filtering logic.
 */
public class ItemsFilter {

    /**
     * Checks if an item is blocked.
     * An item is blocked if it is in the blocked set,
     * or if it is a flatpack and flatpacks are disabled,
     * or if it is an item set and item sets are disabled.
     *
     * @param itemId the item id
     * @param config determines if item sets, flatpacks, and/or trade-only f2p items
     *               should be blocked
     * @return true if the item is blocked; false otherwise
     */
    public static boolean isBlocked(int itemId, ChanceManConfig config) {
        return (!config.enableFlatpacks() && Flatpacks.isFlatpack(itemId))
                || (!config.enableItemSets() && ItemSets.isItemSet(itemId))
                || BlockedItems.getBLOCKED_ITEMS().contains(itemId)
                || (config.freeToPlay() && isBlockedOnFreeToPlay(itemId, config));
    }

    private static boolean isBlockedOnFreeToPlay(int itemId, ChanceManConfig config) {
        return !config.includeF2PTradeOnlyItems() &&
                FreeToPlayBlockedItems.isFreeToPlayTradeOnlyItem(itemId);
    }

    /**
     * Checks if a poisonable weapon variant is eligible for rolling.
     * Base weapons are always eligible; for poisoned variants, if requireWeaponPoison is true,
     * the corresponding global weapon poison must also be unlocked.
     *
     * @param itemId the item id to check
     * @param requireWeaponPoison if true, the matching global poison must be unlocked
     * @param unlockedItems the set of unlocked item ids
     * @return true if eligible; false otherwise
     */
    public static boolean isPoisonEligible(int itemId, boolean requireWeaponPoison, Set<Integer> unlockedItems) {
        return PoisonWeapons.isPoisonVariantEligible(itemId, requireWeaponPoison, unlockedItems);
    }

    private static boolean isGlobalWeaponPoison(int itemId) {
        return itemId == PoisonWeapons.WEAPON_POISON.getBaseId() ||
                itemId == PoisonWeapons.WEAPON_POISON_.getBaseId() ||
                itemId == PoisonWeapons.WEAPON_POISON__.getBaseId();
    }

    /**
     * Returns true if this item ID is on the allowlist of untradeables that can participate
     * in rolling/unlocking when the Include Untradeable toggle is enabled.
     *
     * @param itemId canonical item id to check
     * @return true if the item is allowlisted
     */
    public static boolean isUntradeableAllowlisted(int itemId) {
        return UntradeableAllowlist.getALLOWED_UNTRADEABLE_ITEMS().contains(itemId);
    }

    /**
     * Returns true if this item ID is in the quest item allowlist. Quest items are only considered
     * when the Include Quest Items toggle is enabled.
     *
     * @param itemId canonical item id to check
     * @return true if the item is a quest item
     */
    public static boolean isQuestItem(int itemId) {
        return QuestItemAllowlist.getALLOWED_QUEST_ITEMS().contains(itemId);
    }
}

package com.choicer.chanceman;

import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.ItemComposition;
import net.runelite.client.audio.AudioPlayer;
import net.runelite.client.game.ItemManager;
import net.runelite.client.ui.overlay.Overlay;
import net.runelite.client.ui.overlay.OverlayLayer;
import net.runelite.client.ui.overlay.OverlayPosition;
import net.runelite.client.util.ImageUtil;

import javax.inject.Inject;
import javax.inject.Singleton;
import javax.sound.sampled.LineUnavailableException;
import javax.sound.sampled.UnsupportedAudioFileException;
import java.awt.*;
import java.awt.geom.Ellipse2D;
import java.awt.geom.Point2D;
import java.awt.image.BufferedImage;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.function.Supplier;

/**
 * Renders and animates the ChanceMan rolling strip overlay.
 * <p>Flow:</p>
 * <ol>
 *   <li>{@link #startRollAnimation(int, int, Supplier)} primes the strip and starts the spin timer.</li>
 *   <li>{@link #render(Graphics2D)} scrolls items, snaps to a slot near the end, then highlights the winner.</li>
 *   <li>{@link #getFinalItem()} returns the centered item after snap/highlight.</li>
 */
@Singleton
@Slf4j
public class ChanceManOverlay extends Overlay implements RollOverlay {
    // Snap behavior and timing
    private static final float SNAP_NEXT_THRESHOLD = 0.55f;
    private static final long SNAP_DURATION_MS = 350L;

    // Timing / motion
    private static final long HIGHLIGHT_DURATION_MS = 3000L;
    private static final float INITIAL_SPEED = 975f; // px/s at t=0
    private static final float MIN_SPEED = 120f; // px/s near end
    private static final float MAX_DT = 0.05f;  // clamp large frame gaps

    // Layout
    private static final int ICON_COUNT = 5;
    private static final int DRAW_COUNT = ICON_COUNT + 1;
    private static final int ICON_W = 32;
    private static final int ICON_H = 32;
    private static final int SPACING = 5;
    private static final float STEP = ICON_W + SPACING;

    // Box / visual tweaks
    private static final int EXTRA_WIDTH_BUFFER = 16;
    private static final int OUTER_PAD = 5;
    private static final int OFFSET_TOP = 20;
    private static final int BOX_SHIFT_X = -26;
    private static final int CENTER_NUDGE_PX = 17;
    private static final int FRAME_CONTENT_INSET = 4;
    private static final Color SHADE_BOTTOM = new Color(0, 0, 0, 60);
    private static final Color SHADE_TOP = new Color(255, 255, 255, 25);
    private static final Color TRADEABLE_GLOW_INNER = new Color(255, 255, 160, 150);
    private static final Color TRADEABLE_GLOW_OUTER = new Color(255, 255, 160, 0);
    private static final Color UNTRADEABLE_GLOW_INNER = new Color(140, 210, 255, 160);
    private static final Color UNTRADEABLE_GLOW_OUTER = new Color(140, 210, 255, 0);
    private static final Color[] TRADEABLE_GLOW = new Color[]{TRADEABLE_GLOW_INNER, TRADEABLE_GLOW_OUTER};
    private static final Color[] UNTRADEABLE_GLOW = new Color[]{UNTRADEABLE_GLOW_INNER, UNTRADEABLE_GLOW_OUTER};

    private final Client client;
    private final ItemManager itemManager;

    private final List<Integer> rollingItems = Collections.synchronizedList(new ArrayList<>());

    private static float toDb(int percent) {
        int p = Math.max(0, Math.min(100, percent));
        if (p == 0) {
            return -80.0f; // effectively mute
        }
        double lin = p / 100.0;
        return (float) (20.0 * Math.log10(lin));
    }

    // Textures
    private final BufferedImage rollBoxImage =
            ImageUtil.loadImageResource(getClass(), "/com/choicer/chanceman/roll_box.png");
    private final BufferedImage iconFrameImage =
            ImageUtil.loadImageResource(getClass(), "/com/choicer/chanceman/icon_slot.png");

    @Inject
    private AudioPlayer audioPlayer;
    @Inject
    private ChanceManConfig config;

    // Animation state
    private volatile boolean isAnimating = false;
    private volatile long rollDurationMs;
    private volatile long rollStartNs = 0L;

    // Motion state
    private float rollOffset = 0f; // cumulative horizontal scroll in px
    private float currentSpeed = INITIAL_SPEED; // px/s
    private Supplier<Integer> randomLockedItemSupplier;
    private volatile long lastUpdateNanos = 0L;

    // Snap state
    private boolean isSnapping = false;
    private long snapStartNs = 0L;
    private float snapBase;
    private float snapResidualStart;
    private float snapTarget;
    private int winnerDelta = 0;

    /**
     * Constructs the overlay (dynamic position, above widgets).
     */
    @Inject
    public ChanceManOverlay(Client client, ItemManager itemManager) {
        this.client = client;
        this.itemManager = itemManager;
        setPosition(OverlayPosition.DYNAMIC);
        setLayer(OverlayLayer.ABOVE_WIDGETS);
    }

    /**
     * Starts the roll animation. Populates the strip and resets timers/state.
     *
     * @param dummy reserved; kept for API compatibility
     * @param rollDurationMs spin duration (ms) before highlight
     * @param randomLockedItemSupplier supplier of random locked item ids
     */
    public void startRollAnimation(int dummy, int rollDurationMs, Supplier<Integer> randomLockedItemSupplier) {
        if (config.enableRollSounds()) {
            try {
                float volumeDb = toDb(config.rollSoundVolume());
                audioPlayer.play( ChanceManOverlay.class, "/com/choicer/chanceman/tick.wav", volumeDb);
            } catch (IOException | UnsupportedAudioFileException | LineUnavailableException ex) {
                log.warn("ChanceMan: failed to play tick.wav", ex);
            }
        }

        this.rollDurationMs = rollDurationMs;
        this.rollStartNs = System.nanoTime();
        this.rollOffset = 0f;
        this.currentSpeed = INITIAL_SPEED;
        this.randomLockedItemSupplier = randomLockedItemSupplier;
        this.isAnimating = true;
        this.lastUpdateNanos = System.nanoTime();

        this.isSnapping = false;
        this.snapStartNs = 0L;
        this.snapBase = 0f;
        this.snapResidualStart = 0f;
        this.snapTarget = 0f;
        this.winnerDelta = 0;

        synchronized (rollingItems) {
            rollingItems.clear();
            for (int i = 0; i < DRAW_COUNT; i++) {
                rollingItems.add(randomLockedItemSupplier.get());
            }
        }
    }

    /**
     * Returns the centered (winning) item after snap/highlight.
     *
     * @return item id, or 0 if unavailable
     */
    public int getFinalItem() {
        synchronized (rollingItems) {
            int centerIndex = ICON_COUNT / 2;
            int idx = Math.min(centerIndex + winnerDelta, rollingItems.size() - 1);
            if (idx >= 0 && idx < rollingItems.size()) {
                return rollingItems.get(idx);
            }
        }
        return 0;
    }

    /**
     * @return highlight duration in ms.
     */
    public int getHighlightDurationMs() {
        return (int) HIGHLIGHT_DURATION_MS;
    }

    /**
     * Advances the animation and draws the strip. Returns null (overlay API).
     */
    @Override
    public Dimension render(Graphics2D g) {
        if (!isAnimating) {
            return null;
        }

        // Rendering hints once per frame
        g.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);
        g.setRenderingHint(RenderingHints.KEY_INTERPOLATION, RenderingHints.VALUE_INTERPOLATION_BILINEAR);

        final long nowNs = System.nanoTime();
        final long elapsedMs = (nowNs - rollStartNs) / 1_000_000L;
        final boolean inHighlightPhase = (elapsedMs > rollDurationMs);

        // Stop after highlight
        if (elapsedMs > rollDurationMs + HIGHLIGHT_DURATION_MS) {
            isAnimating = false;
            return null;
        }

        // Compute clamped dt and ease the speed (quintic-ish falloff via (1 - t)^3)
        final long nowNanos = System.nanoTime();
        float dt = 0f;
        if (lastUpdateNanos != 0L) {
            dt = (nowNs - lastUpdateNanos) / 1_000_000_000f;
            if (dt > MAX_DT) dt = MAX_DT;
        }
        lastUpdateNanos = nowNs;

        final float t = (rollDurationMs > 0) ? Math.min(1f, elapsedMs / (float) rollDurationMs) : 1f;
        final float eased = (float) Math.pow(1f - t, 3);
        currentSpeed = MIN_SPEED + (INITIAL_SPEED - MIN_SPEED) * eased;

        // Viewport + box geometry
        final int vpX = client.getViewportXOffset();
        final int vpY = client.getViewportYOffset();
        final int vpWidth = client.getViewportWidth();
        final int centerX = vpX + (vpWidth / 2);
        final int boxTopY = vpY + OFFSET_TOP;

        final int totalIconsWidth = ICON_COUNT * ICON_W + (ICON_COUNT - 1) * SPACING;
        final int totalWidthWithBuffer = totalIconsWidth + EXTRA_WIDTH_BUFFER;
        final int boxWidth = totalWidthWithBuffer + OUTER_PAD * 2;
        final int boxHeight = ICON_H + OUTER_PAD * 2;
        final int boxLeftX = centerX - (boxWidth / 2) + BOX_SHIFT_X;

        // Content rect
        final int contentLeftX = boxLeftX + OUTER_PAD;
        final int innerWidth = boxWidth - OUTER_PAD * 2;
        final float contentCenterX = contentLeftX + innerWidth / 2f + CENTER_NUDGE_PX;
        final float middleIndex = ICON_COUNT / 2f;
        final float iconsLeftXF = contentCenterX - middleIndex * STEP - ICON_W / 2f;
        final int iconsY = boxTopY + OUTER_PAD;

        // Background frame + subtle lines
        if (rollBoxImage != null) {
            final Composite prev = g.getComposite();
            g.setComposite(AlphaComposite.SrcOver.derive(0.95f));
            g.drawImage(rollBoxImage, boxLeftX, boxTopY, boxWidth, boxHeight, null);
            g.setComposite(prev);

            g.setColor(SHADE_BOTTOM);
            g.fillRect(boxLeftX, boxTopY + boxHeight - 2, boxWidth, 2);
            g.setColor(SHADE_TOP);
            g.drawLine(boxLeftX + 2, boxTopY + 2, boxLeftX + boxWidth - 3, boxTopY + 2);
        }

        // Clip to the strip content
        final Shape oldClip = g.getClip();
        g.setClip(contentLeftX, boxTopY + OUTER_PAD, innerWidth, ICON_H);

        synchronized (rollingItems) {
            // Begin snap near the end of spin (or immediately if we already hit highlight)
            final long remainingMs = rollDurationMs - elapsedMs;
            if (!isSnapping && (remainingMs <= SNAP_DURATION_MS || inHighlightPhase)) {
                startSnap(nowNs);
            }

            // Advance motion
            if (!inHighlightPhase) {
                if (isSnapping) {
                    // Smoothstep to the target slot
                    final long snapElapsedNs = nowNs - snapStartNs;
                    final float u = Math.min(1f, snapElapsedNs / (SNAP_DURATION_MS * 1_000_000f));
                    final float s = u * u * (3f - 2f * u);
                    final float start = rollOffset;
                    final float end = snapTarget;
                    rollOffset = start + (end - start) * s;

                    if (rollOffset >= STEP) {
                        normalizeOnce();
                        winnerDelta = 0;
                        snapBase = 0f;
                        snapTarget = 0f;
                        snapResidualStart = 0f;
                    }
                } else {
                    rollOffset += currentSpeed * dt;
                    while (rollOffset >= STEP) {
                        normalizeOnce();
                    }
                }
            } else {
                // During highlight, ensure exact snap
                if (isSnapping) {
                    rollOffset = snapTarget;
                    if (rollOffset >= STEP) {
                        normalizeOnce();
                        winnerDelta = 0;
                    }
                }
            }

            // Inner content area of the frame
            final int innerBoxXInset = FRAME_CONTENT_INSET;
            final int innerBoxYInset = FRAME_CONTENT_INSET;
            final int innerBoxW = ICON_W - innerBoxXInset * 2;
            final int innerBoxH = ICON_H - innerBoxYInset * 2;

            // Draw items
            final int itemsToDraw = Math.min(rollingItems.size(), DRAW_COUNT);
            for (int i = 0; i < itemsToDraw; i++) {
                final int itemId = rollingItems.get(i);
                final BufferedImage image = itemManager.getImage(itemId, 1, false);
                if (image == null) continue;

                final float drawXF = iconsLeftXF + i * STEP - rollOffset;
                final int drawX = Math.round(drawXF);

                if (iconFrameImage != null) {
                    g.drawImage(iconFrameImage, drawX, iconsY, ICON_W, ICON_H, null);
                }

                final int x = drawX + innerBoxXInset;
                final int y = iconsY + innerBoxYInset;
                g.drawImage(image, x, y, innerBoxW, innerBoxH, null);
            }

            // Highlight winner
            if (inHighlightPhase) {
                final int centerIndex = ICON_COUNT / 2;
                final int winnerIndex = Math.min(centerIndex + winnerDelta, rollingItems.size() - 1);

                final float baseXF = iconsLeftXF + centerIndex * STEP - rollOffset;
                final int baseX = Math.round(baseXF);

                final int glowW = (int) (ICON_W * 2.2);
                final int glowH = (int) (ICON_H * 2.2);
                final float cx = baseX + ICON_W / 2f;
                final float cy = iconsY + ICON_H / 2f;

                final int centerItemId = rollingItems.get(winnerIndex);
                final Color[] glowPalette = getHighlightPalette(centerItemId);

                // Radial glow
                final RadialGradientPaint glow = new RadialGradientPaint(
                        new Point2D.Float(cx, cy),
                        glowW / 2f,
                        new float[]{0f, 1f},
                        new Color[]{
                                glowPalette[0],
                                glowPalette[1]
                        }
                );
                final Composite old = g.getComposite();
                g.setComposite(AlphaComposite.SrcOver.derive(0.85f));
                g.setPaint(glow);
                g.fill(new Ellipse2D.Float(cx - glowW / 2f, cy - glowH / 2f, glowW, glowH));
                g.setComposite(old);

                // Slightly larger winner icon, centered inside the frame
                final float centerScale = 1.12f;
                final int innerBoxX = baseX + innerBoxXInset;
                final int innerBoxY = iconsY + innerBoxYInset;

                final int scaledW = (int) (innerBoxW * centerScale);
                final int scaledH = (int) (innerBoxH * centerScale);
                final int scaledX = innerBoxX + (innerBoxW - scaledW) / 2;
                final int scaledY = innerBoxY + (innerBoxH - scaledH) / 2;

                final BufferedImage centerImg = itemManager.getImage(centerItemId, 1, false);
                if (centerImg != null) {
                    g.drawImage(centerImg, scaledX, scaledY, scaledW, scaledH, null);
                }
            }
        }

        g.setClip(oldClip);
        return null;
    }

    private Color[] getHighlightPalette(int itemId) {
        return isTradeableItem(itemId) ? TRADEABLE_GLOW : UNTRADEABLE_GLOW;
    }

    private boolean isTradeableItem(int itemId) {
        if (itemId <= 0) {
            return true;
        }
        ItemComposition composition = itemManager.getItemComposition(itemId);
        return composition == null || composition.isTradeable();
    }

    /**
     * Advances the strip by one slot when a full step is crossed.
     * Removes the left-most item and appends one from the supplier.
     */
    private void normalizeOnce() {
        if (rollOffset >= STEP) {
            rollOffset -= STEP;
            if (!rollingItems.isEmpty()) {
                rollingItems.remove(0);
            }
            if (randomLockedItemSupplier != null) {
                rollingItems.add(randomLockedItemSupplier.get());
            }
        }
    }
    /**
     * Initializes snap state targeting the nearest slot boundary.
     * Ensures roll always aligns to a slot even if the highlight phase began before the snap window ticked.
     */
    private void startSnap(long nowNs) {
        isSnapping = true;
        snapStartNs = nowNs;

        final float k = (float) Math.floor(rollOffset / STEP);
        snapBase = k * STEP;
        snapResidualStart = rollOffset - snapBase; // [0, STEP)
        final boolean goNext = (snapResidualStart / STEP) >= SNAP_NEXT_THRESHOLD;
        winnerDelta = goNext ? 1 : 0;
        snapTarget = goNext ? (snapBase + STEP) : snapBase;
    }
}

package com.choicer.chanceman.menus;

import lombok.Getter;

import java.util.HashMap;
import java.util.HashSet;

@Getter
public enum SkillOp
{
	CHOP_DOWN("Chop down"),
	MINE("Mine"),
	NET("Net"),
	CAGE("Cage"),
	BAIT("Bait"),
	LURE("Lure"),
	RAKE("Rake"),
	PRUNE("Prune"),
	CURE("Cure"),
	GRIND("Grind"),
	SMITH("Smith"),
	SMELT("Smelt"),
	SHEAR("Shear"),
	CLEAN("Clean"),
	FIRE("Fire"),
	CRAFT_RUNE("Craft-rune");

	private final String option;

	SkillOp(String option)
	{
		this.option = option;
	}

	private static final HashSet<String> ALL_SKILL_OPS = new HashSet<>();
	private static final HashMap<String, SkillOp> STRING_TO_OP = new HashMap<>();

	static
	{
		for (SkillOp skillOp : SkillOp.values())
		{
			ALL_SKILL_OPS.add(skillOp.option);
			STRING_TO_OP.put(skillOp.option, skillOp);
		}
	}

	public static boolean isSkillOp(String option)
	{
		return ALL_SKILL_OPS.contains(option);
	}

	public static SkillOp fromString(String option)
	{
		if (!isSkillOp(option)) return null;
		return STRING_TO_OP.get(option);
	}
}

package com.choicer.chanceman.menus;

import com.choicer.chanceman.ChanceManConfig;
import com.choicer.chanceman.ChoicemanPlugin;
import com.choicer.chanceman.filters.EnsouledHeadMapping;
import com.choicer.chanceman.managers.UnlockedItemsManager;
import lombok.Getter;
import lombok.Setter;
import net.runelite.api.Client;
import net.runelite.api.GameState;
import net.runelite.api.MenuAction;
import net.runelite.api.MenuEntry;
import net.runelite.api.events.MenuOptionClicked;
import net.runelite.api.events.MenuEntryAdded;
import net.runelite.api.events.WidgetClosed;
import net.runelite.api.events.WidgetLoaded;
import net.runelite.api.gameval.InterfaceID;
import net.runelite.client.eventbus.EventBus;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.game.ItemManager;
import net.runelite.client.util.Text;

import javax.inject.Inject;
import javax.inject.Singleton;
import java.util.EnumSet;
import java.util.HashSet;
import java.util.Set;
import java.util.function.Consumer;

@Singleton
public class ActionHandler {


	private static final Set<MenuAction> disabledActions = EnumSet.of(
			MenuAction.CC_OP,               // inventory “Use” on locked
			MenuAction.WIDGET_TARGET,       // “Use” on widgets
			MenuAction.WIDGET_TARGET_ON_WIDGET  // “Use” on widget -> widget
	);

	private static final Set<MenuAction> GROUND_ACTIONS = EnumSet.of(
			MenuAction.GROUND_ITEM_FIRST_OPTION,
			MenuAction.GROUND_ITEM_SECOND_OPTION,
			MenuAction.GROUND_ITEM_THIRD_OPTION,
			MenuAction.GROUND_ITEM_FOURTH_OPTION,
			MenuAction.GROUND_ITEM_FIFTH_OPTION
	);

	private static final int ORBS_GROUP = (InterfaceID.Orbs.UNIVERSE >>> 16);

	/**
	 * Normalize a MenuEntryAdded into the base item ID.
	 */
	private int getItemId(MenuEntryAdded event, MenuEntry entry) {
		MenuAction type = entry.getType();
		boolean hasItemId = entry.getItemId() > 0 || event.getItemId() > 0;
		if (!GROUND_ACTIONS.contains(type) && !hasItemId) {
			return -1;
		}
		int raw = GROUND_ACTIONS.contains(type)
				? event.getIdentifier()
				: Math.max(event.getItemId(), entry.getItemId());
		int mapped = EnsouledHeadMapping.toTradeableId(raw);
		return plugin.getItemManager().canonicalize(mapped);
	}

	private final HashSet<Integer> enabledUIs = new HashSet<>() {{
		for (EnabledUI ui : EnabledUI.values()) add(ui.getId());
	}};

	@Inject
	private Client client;
	@Inject
	private EventBus eventBus;
    @Inject
    private ChanceManConfig config;
	@Inject
	private ChoicemanPlugin plugin;
	@Inject
	private Restrictions restrictions;
	@Inject
	private UnlockedItemsManager unlockedItemsManager;
	@Getter
	@Setter
	private int enabledUIOpen = -1;

	// A no-op click handler that marks a menu entry as disabled.
	private final Consumer<MenuEntry> DISABLED = e -> { };

	public void startUp() {
		eventBus.register(this);
		eventBus.register(restrictions);
	}

	public void shutDown() {
		eventBus.unregister(this);
		eventBus.unregister(restrictions);
	}

	private boolean enabledUiOpen() {
		return enabledUIOpen != -1;
	}

	private EnabledUI currentEnabledUi()
	{
		return enabledUIOpen == -1 ? null : EnabledUI.fromGroupId(enabledUIOpen);
	}

	private boolean inactive() {
		if (!unlockedItemsManager.ready()) return true;
		return client.getGameState().getState() < GameState.LOADING.getState();
	}

	@Subscribe
	public void onWidgetClosed(WidgetClosed event) {
		if (event.getGroupId() == enabledUIOpen) enabledUIOpen = -1;
	}

	@Subscribe
	public void onWidgetLoaded(WidgetLoaded event) {
		if (enabledUIs.contains(event.getGroupId()))
			enabledUIOpen = event.getGroupId();
	}

	@Subscribe
	public void onMenuEntryAdded(MenuEntryAdded event) {
		if (inactive()) return;

		EnabledUI ui = currentEnabledUi();
		if (ui != null && !ui.isGreyLockedItems())
		{
			return;
		}

		MenuEntry entry = event.getMenuEntry();
		MenuAction action = entry.getType();
		int id = getItemId(event, entry);
		boolean enabled;
		// Check if the entry looks like it's for a ground item.
		if (isGroundItem(entry)) {
			enabled = !isLockedGroundItem(id);
		} else {
			enabled = isEnabled(id, entry, action);
		}
		// If not enabled, grey out the text and set the click handler to DISABLED.
		if (!enabled) {
			String option = Text.removeTags(entry.getOption());
			String target = Text.removeTags(entry.getTarget());
			entry.setOption("<col=808080>" + option);
			entry.setTarget("<col=808080>" + target);
			entry.onClick(DISABLED);
            if (config.deprioritizeLockedOptions()) {
                entry.setDeprioritized(true);
            }
		}
	}

	@Subscribe
	public void onMenuOptionClicked(MenuOptionClicked event) {
		// If the entry is disabled, consume the event.
		if (event.getMenuEntry().onClick() == DISABLED) {
			event.consume();
			return;
		}
		// Extra safeguard for ground items.
		handleGroundItems(plugin.getItemManager(), unlockedItemsManager, event, plugin);
	}

	/**
	 * Returns true if the entry appears to be for a ground item.
	 */
	private boolean isGroundItem(MenuEntry entry)
	{
		return GROUND_ACTIONS.contains(entry.getType());
	}

	/**
	 * @param itemId canonicalized item ID of a ground item
	 * @return true if it’s tracked by the plugin and still locked
	 */
	private boolean isLockedGroundItem(int itemId)
	{
		return plugin.isInPlay(itemId)
				&& !unlockedItemsManager.isUnlocked(itemId);
	}

	private boolean isHealthOrbCure(MenuEntry entry)
	{
		if (entry.getType() != MenuAction.CC_OP)
			return false;

		if (!"cure".equalsIgnoreCase(Text.removeTags(entry.getOption())))
			return false;

		int w1 = entry.getParam1();
		int w0 = entry.getParam0();

		return (w1 >>> 16) == ORBS_GROUP || (w0 >>> 16) == ORBS_GROUP;
	}

	/**
	 * This method handles non-ground items (or any other cases) by checking if the item is enabled.
	 * It returns true if the action should be allowed.
	 */
	private boolean isEnabled(int id, MenuEntry entry, MenuAction action) {
		if (isHealthOrbCure(entry))
		{
			return true;
		}

		String option = Text.removeTags(entry.getOption());
		String target = Text.removeTags(entry.getTarget());

		EnabledUI ui = currentEnabledUi();
		if (ui != null && ui.isAllowAllActions())
		{
			return true;
		}

		// Always allow "Drop"
		if (option.equalsIgnoreCase("drop") || option.equalsIgnoreCase("check"))
			return true;
		if (option.equalsIgnoreCase("clean") || option.equalsIgnoreCase("rub"))
		{
			if (!plugin.isInPlay(id)) { return true; }
			return unlockedItemsManager.isUnlocked(id);
		}
		if (SkillOp.isSkillOp(option))
			return restrictions.isSkillOpEnabled(option);
		if (Spell.isSpell(option))
			return restrictions.isSpellOpEnabled(option);
		if (Spell.isSpell(target))
			return restrictions.isSpellOpEnabled(target);

		boolean enabled = !disabledActions.contains(action);
		if (enabled)
			return true;
		if (id == 0 || id == -1 || !plugin.isInPlay(id))
			return true;
		return unlockedItemsManager.isUnlocked(id);
	}

	/**
	 * A static helper to further safeguard ground item actions.
	 * If a ground item is locked, this method consumes the event.
	 */
	public static void handleGroundItems(ItemManager itemManager, UnlockedItemsManager unlockedItemsManager,
										 MenuOptionClicked event, ChoicemanPlugin plugin) {
		if (event.getMenuAction() != null && GROUND_ACTIONS.contains(event.getMenuAction())) {
			int rawItemId = event.getId() != -1
					? event.getId()
					: event.getMenuEntry().getItemId();
			int mapped = EnsouledHeadMapping.toTradeableId(rawItemId);
			int canonicalGroundId = itemManager.canonicalize(mapped);
			if (plugin.isInPlay(canonicalGroundId)
					&& unlockedItemsManager != null
					&& !unlockedItemsManager.isUnlocked(canonicalGroundId)) {
				event.consume();
			}
		}
	}
}

package com.choicer.chanceman.menus;

import lombok.Getter;
import net.runelite.api.gameval.ItemID;

import java.util.Arrays;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;

@Getter
public enum BlightedSack
{
    ENTANGLE(
            ItemID.BLIGHTED_SACK_ENTANGLE,
            Collections.unmodifiableSet(new HashSet<>(Arrays.asList(
                    "Snare", "Entangle", "Bind"
            )))
    ),
    SURGE(
            ItemID.BLIGHTED_SACK_SURGE,
            Collections.unmodifiableSet(new HashSet<>(Arrays.asList(
                    "Wind Surge", "Water Surge", "Earth Surge", "Fire Surge",
                    "Wind Wave",  "Water Wave",  "Earth Wave",  "Fire Wave"
            )))
    ),
    TELEBLOCK(
            ItemID.BLIGHTED_SACK_TELEBLOCK,
            Collections.unmodifiableSet(new HashSet<>(Arrays.asList(
                    "Tele Block", "Teleport to Target"
            )))
    ),
    VENGEANCE(
            ItemID.BLIGHTED_SACK_VENGEANCE,
            Collections.unmodifiableSet(new HashSet<>(Arrays.asList(
                    "Vengeance", "Vengeance Other"
            )))
    ),
    ANCIENT_ICE(
            ItemID.BLIGHTED_SACK_ICEBARRAGE,
            Collections.unmodifiableSet(new HashSet<>(Arrays.asList(
                    "Ice Rush", "Ice Burst", "Ice Blitz", "Ice Barrage"
            )))
    );

    private final int sackItemId;
    private final Set<String> allowedSpells;
    private static final Map<String, BlightedSack> SPELL_TO_SACK;
    static
    {
        Map<String, BlightedSack> map = new HashMap<>();
        for (BlightedSack sack : values())
        {
            for (String spell : sack.allowedSpells)
            {
                map.put(spell, sack);
            }
        }
        SPELL_TO_SACK = Collections.unmodifiableMap(map);
    }

    BlightedSack(int sackItemId, Set<String> allowedSpells)
    {
        this.sackItemId = sackItemId;
        this.allowedSpells = allowedSpells;
    }

    /**
     * @return the BlightedSack that grants this spell, or null if none.
     */
    public static BlightedSack fromSpell(String spellName)
    {
        return SPELL_TO_SACK.get(spellName);
    }
}

package com.choicer.chanceman.menus;

import lombok.Getter;

import java.util.HashSet;

@Getter
public enum Spell
{
	// STANDARD
	WIND_STRIKE("Wind Strike"),
	WATER_STRIKE("Water Strike"),
	EARTH_STRIKE("Earth Strike"),
	FIRE_STRIKE("Fire Strike"),
	WIND_BOLT("Wind Bolt"),
	WATER_BOLT("Water Bolt"),
	EARTH_BOLT("Earth Bolt"),
	FIRE_BOLT("Fire Bolt"),
	WIND_BLAST("Wind Blast"),
	WATER_BLAST("Water Blast"),
	EARTH_BLAST("Earth Blast"),
	FIRE_BLAST("Fire Blast"),
	WIND_WAVE("Wind Wave"),
	WATER_WAVE("Water Wave"),
	EARTH_WAVE("Earth Wave"),
	FIRE_WAVE("Fire Wave"),
	WIND_SURGE("Wind Surge"),
	WATER_SURGE("Water Surge"),
	EARTH_SURGE("Earth Surge"),
	FIRE_SURGE("Fire Surge"),
	SARADOMIN_STRIKE("Saradomin Strike"),
	CLAWS_OF_GUTHIX("Claws of Guthix"),
	FLAMES_OF_ZAMORAK("Flames of Zamorak"),
	CHARGE("Charge"),
	TELEBLOCK("Tele Block"),
	WEAKEN("Weaken"),
	CONFUSE("Confuse"),
	CURSE("Curse"),
	STUN("Stun"),
	VULNERABILITY("Vulnerability"),
	ENFEEBLE("Enfeeble"),
	BIND("Bind"),
	SNARE("Snare"),
	ENTANGLE("Entangle"),
	LOW_LEVEL_ALCHEMY("Low Level Alchemy"),
	HIGH_LEVEL_ALCHEMY("High Level Alchemy"),
	TELEKINETIC_GRAB("Telekinetic Grab"),
	VARROCK_TELEPORT("Varrock Teleport"),
	LUMBRIDGE_TELEPORT("Lumbridge Teleport"),
	FALADOR_TELEPORT("Falador Teleport"),
	CAMELOT_TELEPORT("Camelot Teleport"),
	ARDOUGNE_TELEPORT("Ardougne Teleport"),
	CIVITAS_ILLA_FORTIS_TELEPORT("Civitas illa Fortis Teleport"),
	TROLLHEIM_TELEPORT("Trollheim Teleport"),
	WATCHTOWER_TELEPORT("Watchtower Teleport"),
	TELEPORT_TO_HOUSE("Teleport to House"),
	APE_ATOLL_TELEPORT("Ape Atoll Teleport"),
	KOUREND_CASTLE_TELEPORT("Kourend Castle Teleport"),
	LVL_1_ENCHANT("Lvl-1 Enchant"),
	LVL_2_ENCHANT("Lvl-2 Enchant"),
	LVL_3_ENCHANT("Lvl-3 Enchant"),
	LVL_4_ENCHANT("Lvl-4 Enchant"),
	LVL_5_ENCHANT("Lvl-5 Enchant"),
	LVL_6_ENCHANT("Lvl-6 Enchant"),
	LVL_7_ENCHANT("Lvl-7 Enchant"),
	CRUMBLE_UNDEAD("Crumble Undead"),
	MAGIC_DART("Magic Dart"),
	IBAN_BLAST("Iban Blast"),
	BONES_TO_BANANAS("Bones to Bananas"),
	BONES_TO_PEACHES("Bones to Peaches"),
	SUPERHEAT_ITEM("Superheat Item"),
	TELEOTHER_LUMBRIDGE("Teleother Lumbridge"),
	TELEOTHER_VARROCK("Teleother Varrock"),
	TELEOTHER_FALADOR("Teleother Falador"),
	TELEOTHER_CAMELOT("Teleother Camelot"),
	CHARGE_WATER_ORB("Charge Water Orb"),
	CHARGE_EARTH_ORB("Charge Earth Orb"),
	CHARGE_FIRE_ORB("Charge Fire Orb"),
	CHARGE_AIR_ORB("Charge Air Orb"),
	MONSTER_INSPECT("Monster Inspect"),

	// ANCIENT
	SMOKE_RUSH("Smoke Rush"),
	SHADOW_RUSH("Shadow Rush"),
	BLOOD_RUSH("Blood Rush"),
	ICE_RUSH("Ice Rush"),
	SMOKE_BURST("Smoke Burst"),
	SHADOW_BURST("Shadow Burst"),
	BLOOD_BURST("Blood Burst"),
	ICE_BURST("Ice Burst"),
	SMOKE_BLITZ("Smoke Blitz"),
	SHADOW_BLITZ("Shadow Blitz"),
	BLOOD_BLITZ("Blood Blitz"),
	ICE_BLITZ("Ice Blitz"),
	SMOKE_BARRAGE("Smoke Barrage"),
	SHADOW_BARRAGE("Shadow Barrage"),
	BLOOD_BARRAGE("Blood Barrage"),
	ICE_BARRAGE("Ice Barrage"),
	PADDEWWA_TELEPORT("Paddewwa Teleport"),
	SENNTISTEN_TELEPORT("Senntisten Teleport"),
	KHARYRLL_TELEPORT("Kharyrll Teleport"),
	LASSAR_TELEPORT("Lassar Teleport"),
	DAREEYAK_TELEPORT("Dareeyak Teleport"),
	CARRALLANGER_TELEPORT("Carrallanger Teleport"),
	TELEPORT_TO_TARGET("Teleport to Target"),
	ANNAKARL_TELEPORT("Annakarl Teleport"),
	GHORROCK_TELEPORT("Ghorrock Teleport"),

	// ARCEUUS
	ARCEUUS_LIBRARY_TELEPORT("Arceuus Library Teleport"),
	DRAYNOR_MANOR_TELEPORT("Draynor Manor Teleport"),
	BATTLEFRONT_TELEPORT("Battlefront Teleport"),
	MIND_ALTAR_TELEPORT("Mind Altar Teleport"),
	RESPAWN_TELEPORT("Respawn Teleport"),
	SALVE_GRAVEYARD_TELEPORT("Salve Graveyard Teleport"),
	FENKENSTRAINS_CASTLE_TELEPORT("Fenkenstrain's Castle Teleport"),
	WEST_ARDOUGNE_TELEPORT("West Ardougne Teleport"),
	HARMONY_ISLAND_TELEPORT("Harmony Island Teleport"),
	CEMETERY_TELEPORT("Cemetery Teleport"),
	BARROWS_TELEPORT("Barrows Teleport"),
	TELEPORT_TO_TARGET_ARC("Teleport to Target"),
	GHOSTLY_GRASP("Ghostly Grasp"),
	SKELETAL_GRASP("Skeletal Grasp"),
	UNDEAD_GRASP("Undead Grasp"),
	INFERIOR_DEMONBANE("Inferior Demonbane"),
	SUPERIOR_DEMONBANE("Superior Demonbane"),
	DARK_DEMONBANE("Dark Demonbane"),
	LESSER_CORRUPTION("Lesser Corruption"),
	GREATER_CORRUPTION("Greater Corruption"),
	RESURRECT_LESSER_GHOST("Resurrect Lesser Ghost"),
	RESURRECT_LESSER_SKELETON("Resurrect Lesser Skeleton"),
	RESURRECT_LESSER_ZOMBIE("Resurrect Lesser Zombie"),
	RESURRECT_SUPERIOR_GHOST("Resurrect Superior Ghost"),
	RESURRECT_SUPERIOR_SKELETON("Resurrect Superior Skeleton"),
	RESURRECT_SUPERIOR_ZOMBIE("Resurrect Superior Zombie"),
	RESURRECT_GREATER_GHOST("Resurrect Greater Ghost"),
	RESURRECT_GREATER_SKELETON("Resurrect Greater Skeleton"),
	RESURRECT_GREATER_ZOMBIE("Resurrect Greater Zombie"),
	DARK_LURE("Dark Lure"),
	MARK_OF_DARKNESS("Mark of Darkness"),
	WARD_OF_ARCEUUS("Ward of Arceuus"),
	BASIC_REANIMATION("Basic Reanimation"),
	ADEPT_REANIMATION("Adept Reanimation"),
	EXPERT_REANIMATION("Expert Reanimation"),
	MASTER_REANIMATION("Master Reanimation"),
	DEMONIC_OFFERING("Demonic Offering"),
	SINISTER_OFFERING("Sinister Offering"),
	SHADOW_VEIL("Shadow Veil"),
	VILE_VIGOUR("Vile Vigour"),
	DEGRIME("Degrime"),
	RESURRECT_CROPS("Resurrect Crops"),
	DEATH_CHARGE("Death Charge");

	private final String spellName;

	Spell(String spellName)
	{
		this.spellName = spellName;
	}

	private static final HashSet<String> ALL_SPELLS = new HashSet<>();

	static
	{
		for (Spell spell : Spell.values())
		{
			ALL_SPELLS.add(spell.getSpellName());
		}
	}

	public static boolean isSpell(String target)
	{
		return ALL_SPELLS.contains(target);
	}
}

package com.choicer.chanceman.menus;

import lombok.Getter;

import java.util.HashSet;
import java.util.HashMap;

@Getter
public enum SkillItem
{

	BRONZE_AXE(1351, SkillOp.CHOP_DOWN),
	IRON_AXE(1349, SkillOp.CHOP_DOWN),
	STEEL_AXE(1353, SkillOp.CHOP_DOWN),
	BLACK_AXE(1361, SkillOp.CHOP_DOWN),
	MITHRIL_AXE(1355, SkillOp.CHOP_DOWN),
	ADAMANT_AXE(1357, SkillOp.CHOP_DOWN),
	RUNE_AXE(1359, SkillOp.CHOP_DOWN),
	DRAGON_AXE(6739, SkillOp.CHOP_DOWN),
	GILDED_AXE(23279, SkillOp.CHOP_DOWN),
	THIRD_AGE_AXE(20011, SkillOp.CHOP_DOWN),

	BRONZE_FELLING_AXE(28196, SkillOp.CHOP_DOWN),
	IRON_FELLING_AXE(28199, SkillOp.CHOP_DOWN),
	STEEL_FELLING_AXE(28202, SkillOp.CHOP_DOWN),
	BLACK_FELLING_AXE(28205, SkillOp.CHOP_DOWN),
	MITHRIL_FELLING_AXE(28208, SkillOp.CHOP_DOWN),
	ADAMANT_FELLING_AXE(28211, SkillOp.CHOP_DOWN),
	RUNE_FELLING_AXE(28214, SkillOp.CHOP_DOWN),
	DRAGON_FELLING_AXE(28217, SkillOp.CHOP_DOWN),
	THIRD_AGE_FELLING_AXE(28226, SkillOp.CHOP_DOWN),

	BRONZE_PICKAXE(1265, SkillOp.MINE),
	IRON_PICKAXE(1267, SkillOp.MINE),
	STEEL_PICKAXE(1269, SkillOp.MINE),
	BLACK_PICKAXE(12297, SkillOp.MINE),
	MITHRIL_PICKAXE(1273, SkillOp.MINE),
	ADAMANT_PICKAXE(1271, SkillOp.MINE),
	RUNE_PICKAXE(1275, SkillOp.MINE),
	DRAGON_PICKAXE(11920,SkillOp.MINE),
	GILDED_PICKAXE(23276, SkillOp.MINE),
	THIRD_AGE_PICKAXE(20014, SkillOp.MINE),

	SMALL_FISHING_NET(303, SkillOp.NET),
	BIG_FISHING_NET(305, SkillOp.NET),
	LOBSTER_POT(301, SkillOp.CAGE),
	FISHING_BAIT(313, SkillOp.BAIT),
	FLY_FISHING_ROD(309, SkillOp.LURE),
	RAKE(5341, SkillOp.RAKE),
	SHEARS(1735, SkillOp.SHEAR),
	SECATEURS(5329, SkillOp.PRUNE),

	BRONZE_BAR(2349, SkillOp.SMITH),
	IRON_BAR(2351, SkillOp.SMITH),
	STEEL_BAR(2353, SkillOp.SMITH),
	MITHRIL_BAR(2359, SkillOp.SMITH),
	ADAMANTITE_BAR(2361, SkillOp.SMITH),
	RUNITE_BAR(2363, SkillOp.SMITH),

	TIN_ORE(438, SkillOp.SMELT),
	COPPER_ORE(436, SkillOp.SMELT),
	IRON_ORE(440, SkillOp.SMELT),
	COAL(453, SkillOp.SMELT),
	MITHRIL_ORE(447, SkillOp.SMELT),
	RUNITE_ORE(451, SkillOp.SMELT),
	SILVER_ORE(442, SkillOp.SMELT),
	SILVER_BAR(2355,SkillOp.SMELT),
	GOLD_ORE(444, SkillOp.SMELT),
	GOLD_BAR(2357, SkillOp.SMELT),

	GRIMY_GUAM_LEAF(199, SkillOp.CLEAN),
	GRIMY_MARRENTILL(201, SkillOp.CLEAN),
	GRIMY_TARROMIN(203, SkillOp.CLEAN),
	GRIMY_HARRALANDER(205, SkillOp.CLEAN),
	GRIMY_RANARR_WEED(207, SkillOp.CLEAN),
	GRIMY_IRIT_LEAF(209, SkillOp.CLEAN),
	GRIMY_AVANTOE(211, SkillOp.CLEAN),
	GRIMY_KWUARM(213, SkillOp.CLEAN),
	GRIMY_CADANTINE(215, SkillOp.CLEAN),
	GRIMY_DWARF_WEED(217, SkillOp.CLEAN),
	GRIMY_TORSTOL(219, SkillOp.CLEAN),
	GRIMY_LANTADYME(2485, SkillOp.CLEAN),
	GRIMY_TOADFLAX(3049, SkillOp.CLEAN),
	GRIMY_SNAPDRAGON(3051, SkillOp.CLEAN),

	UNFIRED_BOWL(1791, SkillOp.FIRE),
	UNFIRED_CUP(28193, SkillOp.FIRE),
	UNFIRED_PIE_DISH(1789, SkillOp.FIRE),
	UNFIRED_PLANT_POT(5352, SkillOp.FIRE),
	UNFIRED_POT(1787, SkillOp.FIRE),
	UNFIRED_POT_LID(4438, SkillOp.FIRE),

	RUNE_ESSENCE(1436, SkillOp.CRAFT_RUNE),
	PURE_ESSENCE(7936, SkillOp.CRAFT_RUNE),
	GUARDIAN_ESSENCE(26879, SkillOp.CRAFT_RUNE),

	//Blackjacks
	OAK_BLACKJACK_O(6408, SkillOp.LURE),
	OAK_BLACKJACK_D(6410, SkillOp.LURE),
	WILLOW_BLACKJACK(4600, SkillOp.LURE),
	WILLOW_BLACKJACK_O(6412, SkillOp.LURE),
	WILLOW_BLACKJACK_D(6414, SkillOp.LURE),
	MAPLE_BLACKJACK(6416, SkillOp.LURE),
	MAPLE_BLACKJACK_O(6418, SkillOp.LURE),
	MAPLE_BLACKJACK_D(6420, SkillOp.LURE),

	// Untradeables that conflict
	OAK_BLACKJACK(4599, SkillOp.LURE, false),
	RED_VINE_WORMS(25, SkillOp.BAIT, false),
	BOBS_NET(6209, SkillOp.NET, false);

	private final int id;
	private final SkillOp option;
	private final boolean requiresUnlock;

	SkillItem(int id, SkillOp option)
	{
		this(id, option, true);
	}

	SkillItem(int id, SkillOp option, boolean requiresUnlock)
	{
		this.id = id;
		this.option = option;
		this.requiresUnlock = requiresUnlock;
	}

	public SkillOp getSkillOp()
	{
		return option;
	}

	private static final HashSet<Integer> ALL_SKILL_ITEMS = new HashSet<>();
	private static final HashMap<Integer, SkillItem> ID_TO_ITEM = new HashMap<>();

	static
	{
		for (SkillItem skillItem : SkillItem.values())
		{
			ALL_SKILL_ITEMS.add(skillItem.getId());
			ID_TO_ITEM.put(skillItem.getId(), skillItem);
		}
	}

	public static boolean isSkillItem(int id)
	{
		return ALL_SKILL_ITEMS.contains(id);
	}

	public static SkillItem fromId(int id)
	{
		return ID_TO_ITEM.get(id);
	}
}

package com.choicer.chanceman.menus;

import lombok.Getter;
import net.runelite.api.gameval.ItemID;

import java.util.HashMap;
import java.util.HashSet;

@Getter
public enum RuneProvider
{
	// Banana (yeah)
	BANANA(ItemID.BANANA),

	// Runes
	AIR_RUNE(ItemID.AIRRUNE),
	WATER_RUNE(ItemID.WATERRUNE),
	EARTH_RUNE(ItemID.EARTHRUNE),
	FIRE_RUNE(ItemID.FIRERUNE),
	MIND_RUNE(ItemID.MINDRUNE),
	BODY_RUNE(ItemID.BODYRUNE),
	COSMIC_RUNE(ItemID.COSMICRUNE),
	CHAOS_RUNE(ItemID.CHAOSRUNE),
	NATURE_RUNE(ItemID.NATURERUNE),
	LAW_RUNE(ItemID.LAWRUNE),
	DEATH_RUNE(ItemID.DEATHRUNE),
	BLOOD_RUNE(ItemID.BLOODRUNE),
	SOUL_RUNE(ItemID.SOULRUNE),
	WRATH_RUNE(ItemID.WRATHRUNE),
	SUNFIRE_RUNE(false, ItemID.SUNFIRERUNE, FIRE_RUNE),

	// Elemental equipment
	AIR_STAFF(true, ItemID.STAFF_OF_AIR, AIR_RUNE),
	MYSTIC_AIR_STAFF(true, ItemID.MYSTIC_AIR_STAFF, AIR_RUNE),
	WATER_STAFF(true, ItemID.STAFF_OF_WATER, WATER_RUNE),
	MYSTIC_WATER_STAFF(true, ItemID.MYSTIC_AIR_STAFF, WATER_RUNE),
	EARTH_STAFF(true, ItemID.STAFF_OF_EARTH, EARTH_RUNE),
	MYSTIC_EARTH_STAFF(true, ItemID.MYSTIC_EARTH_STAFF, EARTH_RUNE),
	FIRE_STAFF(true, ItemID.STAFF_OF_FIRE, FIRE_RUNE),
	MYSTIC_FIRE_STAFF(true, ItemID.MYSTIC_FIRE_STAFF, FIRE_RUNE),
	AIR_BATTLESTAFF(true, ItemID.AIR_BATTLESTAFF, AIR_RUNE),
	WATER_BATTLESTAFF(true, ItemID.WATER_BATTLESTAFF, WATER_RUNE),
	KODAI_WAND(true, ItemID.KODAI_WAND, WATER_RUNE),
	EARTH_BATTLESTAFF(true, ItemID.EARTH_BATTLESTAFF, EARTH_RUNE),
	FIRE_BATTLESTAFF(true, ItemID.FIRE_BATTLESTAFF, FIRE_RUNE),
	TOME_OF_FIRE(true, ItemID.TOME_OF_FIRE, FIRE_RUNE),
	TOME_OF_WATER(true, ItemID.TOME_OF_WATER, WATER_RUNE),
	TOME_OF_EARTH(true, ItemID.TOME_OF_EARTH, EARTH_RUNE),

	// Combo runes
	AETHER_RUNE(false,ItemID.AETHERRUNE,COSMIC_RUNE, SOUL_RUNE),
	MIST_RUNE(false, ItemID.MISTRUNE, AIR_RUNE, WATER_RUNE),
	DUST_RUNE(false, ItemID.DUSTRUNE, AIR_RUNE, EARTH_RUNE),
	MUD_RUNE(false, ItemID.MUDRUNE, WATER_RUNE, EARTH_RUNE),
	SMOKE_RUNE(false, ItemID.SMOKERUNE, FIRE_RUNE, AIR_RUNE),
	STEAM_RUNE(false, ItemID.STEAMRUNE, WATER_RUNE, FIRE_RUNE),
	LAVA_RUNE(false, ItemID.LAVARUNE, EARTH_RUNE, FIRE_RUNE),

	// Combo staves
	MIST_STAFF(true, ItemID.MIST_BATTLESTAFF, AIR_RUNE, WATER_RUNE),
	MYSTIC_MIST_STAFF(true, ItemID.MYSTIC_MIST_BATTLESTAFF, AIR_RUNE, WATER_RUNE),
	DUST_STAFF(true, ItemID.DUST_BATTLESTAFF, AIR_RUNE, EARTH_RUNE),
	MYSTIC_DUST_STAFF(true, ItemID.MYSTIC_DUST_BATTLESTAFF, AIR_RUNE, EARTH_RUNE),
	MUD_STAFF(true, ItemID.MUD_BATTLESTAFF, WATER_RUNE, EARTH_RUNE),
	MYSTIC_MUD_STAFF(true, ItemID.MYSTIC_MUD_STAFF, WATER_RUNE, EARTH_RUNE),
	SMOKE_STAFF(true, ItemID.SMOKE_BATTLESTAFF, FIRE_RUNE, AIR_RUNE),
	MYSTIC_SMOKE_STAFF(true, ItemID.MYSTIC_SMOKE_BATTLESTAFF, FIRE_RUNE, AIR_RUNE),
	STEAM_STAFF(true, ItemID.STEAM_BATTLESTAFF, WATER_RUNE, FIRE_RUNE),
	STEAM_STAFF_OR(true, ItemID.STEAM_BATTLESTAFF_PRETTY, WATER_RUNE, FIRE_RUNE),
	MYSTIC_STEAM_STAFF(true, ItemID.MYSTIC_STEAM_BATTLESTAFF, WATER_RUNE, FIRE_RUNE),
	MYSTIC_STEAM_STAFF_OR(true, ItemID.MYSTIC_STEAM_BATTLESTAFF_PRETTY, WATER_RUNE, FIRE_RUNE),
	LAVA_STAFF(true, ItemID.LAVA_BATTLESTAFF, EARTH_RUNE, FIRE_RUNE),
	LAVA_STAFF_OR(true, ItemID.LAVA_BATTLESTAFF_PRETTY, EARTH_RUNE, FIRE_RUNE),
	MYSTIC_LAVA_STAFF(true, ItemID.MYSTIC_LAVA_STAFF, EARTH_RUNE, FIRE_RUNE),
	MYSTIC_LAVA_STAFF_OR(true, ItemID.MYSTIC_LAVA_STAFF_PRETTY, EARTH_RUNE, FIRE_RUNE),
	TWINFLAME_STAFF(true, ItemID.TWINFLAME_STAFF, WATER_RUNE, FIRE_RUNE),

	// Other
	BRYOPHYTAS_STAFF_CHARGED(true, ItemID.NATURE_STAFF_CHARGED, NATURE_RUNE);

	private final boolean requiresEquipped;
	private final int id;
	private final HashSet<Integer> provides = new HashSet<>();

	RuneProvider(int id)
	{
		this.requiresEquipped = false;
		this.id = id;
		this.provides.add(id);
	}

	RuneProvider(boolean requiresEquipped, int id, RuneProvider... provides)
	{
		this.requiresEquipped = requiresEquipped;
		this.id = id;
		for (RuneProvider runeProvider : provides) this.provides.addAll(runeProvider.getProvides());
	}

	private static final HashSet<Integer> EQUIPPED_PROVIDERS = new HashSet<>();
	private static final HashSet<Integer> INV_PROVIDERS = new HashSet<>();
	private static final HashMap<Integer, HashSet<Integer>> PROVIDER_TO_PROVIDED = new HashMap<>();

	static
	{
		for (RuneProvider runeProvider : RuneProvider.values())
		{
			PROVIDER_TO_PROVIDED.put(runeProvider.getId(), runeProvider.getProvides());
			if (runeProvider.isRequiresEquipped())
			{
				EQUIPPED_PROVIDERS.add(runeProvider.getId());
			} else {
				INV_PROVIDERS.add(runeProvider.getId());
			}
		}
	}

	public static boolean isEquippedProvider(int id) { return EQUIPPED_PROVIDERS.contains(id); }
	public static boolean isInvProvider(int id) { return INV_PROVIDERS.contains(id); }
	public static HashSet<Integer> getProvidedRunes(int id) { return PROVIDER_TO_PROVIDED.get(id); }
}

package com.choicer.chanceman.menus;

import com.choicer.chanceman.ChoicemanPlugin;
import com.choicer.chanceman.managers.UnlockedItemsManager;
import net.runelite.api.*;
import net.runelite.api.coords.WorldArea;
import net.runelite.api.coords.WorldPoint;
import net.runelite.api.gameval.InventoryID;
import net.runelite.api.gameval.InterfaceID;
import net.runelite.api.gameval.ItemID;
import net.runelite.api.events.GameTick;
import net.runelite.api.widgets.Widget;
import net.runelite.client.eventbus.Subscribe;

import javax.inject.Inject;
import javax.inject.Singleton;
import java.util.*;

@Singleton
public class Restrictions
{
	private static final int[] RUNE_POUCH_TYPE_VARBITS = {
			29,    // RUNE_POUCH_RUNE1
			1622,  // RUNE_POUCH_RUNE2
			1623,  // RUNE_POUCH_RUNE3
			14285, // RUNE_POUCH_RUNE4
			15373, // RUNE_POUCH_RUNE5
			15374  // RUNE_POUCH_RUNE6
	};

	private static final int[] RUNE_POUCH_AMOUNT_VARBITS = {
			1624,  // RUNE_POUCH_AMOUNT1
			1625,  // RUNE_POUCH_AMOUNT2
			1626,  // RUNE_POUCH_AMOUNT3
			14286, // RUNE_POUCH_AMOUNT4
			15375, // RUNE_POUCH_AMOUNT5
			15376  // RUNE_POUCH_AMOUNT6
	};

	private static final WorldArea FOUNTAIN_OF_RUNE_AREA =
			new WorldArea(3367, 3890, 13, 9, 0);

	private boolean isInFountainArea()
	{
		WorldPoint lp = client.getLocalPlayer().getWorldLocation();
		return FOUNTAIN_OF_RUNE_AREA.contains(lp);
	}

	private boolean isInLMS()
	{
		EnumSet<WorldType> worldTypes = client.getWorldType();
		return (worldTypes.contains(WorldType.LAST_MAN_STANDING));

	}

	public static final int SPELL_REQUIREMENT_OVERLAY_NORMAL = InterfaceID.MagicSpellbook.TOOLTIP;
	public static final int AUTOCAST_REQUIREMENT_OVERLAY_NORMAL = InterfaceID.Autocast.INFO;

	@Inject private ChoicemanPlugin plugin;
	@Inject private Client client;
	@Inject private UnlockedItemsManager unlockedItemsManager;
	private final Set<SkillOp> enabledSkillOps = EnumSet.noneOf(SkillOp.class);
	private final HashSet<Integer> availableRunes = new HashSet<>();

	@Subscribe
	public void onGameTick(GameTick event)
	{
		if (!unlockedItemsManager.ready()) return;
		enabledSkillOps.clear();
		availableRunes.clear();

		ItemContainer equippedItems = client.getItemContainer(InventoryID.WORN);
		ItemContainer inventoryItems = client.getItemContainer(InventoryID.INV);

		if (equippedItems != null)
		{
			Arrays.stream(equippedItems.getItems()).forEach(item -> {
				int id = item.getId();
				SkillItem skillItem = SkillItem.fromId(id);
				if (skillItem != null && !skillItem.isRequiresUnlock())
				{
					enabledSkillOps.add(skillItem.getSkillOp());
					return;
				}

				if (shouldSkipItem(id)) return;
				if (RuneProvider.isEquippedProvider(id))
					availableRunes.addAll(RuneProvider.getProvidedRunes(id));
				if (skillItem != null) enabledSkillOps.add(skillItem.getSkillOp());
			});
		}

		if (inventoryItems != null)
		{
			Arrays.stream(inventoryItems.getItems()).forEach(item -> {
				int id = item.getId();
				SkillItem skillItem = SkillItem.fromId(id);
				if (skillItem != null && !skillItem.isRequiresUnlock())
				{
					enabledSkillOps.add(skillItem.getSkillOp());
					return;
				}

				if (shouldSkipItem(id)) return;
				if (RuneProvider.isInvProvider(id))
					availableRunes.addAll(RuneProvider.getProvidedRunes(id));
				if (skillItem != null) enabledSkillOps.add(skillItem.getSkillOp());
			});
		}

		EnumComposition pouchEnum = client.getEnum(EnumID.RUNEPOUCH_RUNE);
		for (int i = 0; i < 6; i++)
		{
			int qty     = client.getVarbitValue(RUNE_POUCH_AMOUNT_VARBITS[i]);
			int typeIdx = client.getVarbitValue(RUNE_POUCH_TYPE_VARBITS[i]);
			if (qty <= 0)
			{
				continue;
			}

			int runeId = pouchEnum.getIntValue(typeIdx);
			if (shouldSkipItem(runeId))
			{
				continue;
			}

			if (RuneProvider.isInvProvider(runeId))
			{
				availableRunes.addAll(RuneProvider.getProvidedRunes(runeId));
			}
		}
	}

	public boolean isSkillOpEnabled(String option)
	{
		SkillOp op = SkillOp.fromString(option);
		return enabledSkillOps.contains(op);
	}

	private boolean shouldSkipItem(int id)
	{
		if (!plugin.isInPlay(id))
		{
			return !(RuneProvider.isEquippedProvider(id)
					|| RuneProvider.isInvProvider(id));
		}
		return !unlockedItemsManager.isUnlocked(id);
	}

	public boolean isSpellOpEnabled(String spellName)
	{
		if (isInFountainArea() || isInLMS()) { return true; }
		BlightedSack sack = BlightedSack.fromSpell(spellName);
		if (sack != null)
		{
			int sackId = sack.getSackItemId();
			ItemContainer inv = client.getItemContainer(InventoryID.INV);
			if (inv != null	&& (sackId == ItemID.BLIGHTED_SACK_SURGE || unlockedItemsManager.isUnlocked(sackId)))
			{
				for (Item item : inv.getItems())
				{
					if (item.getId() == sackId)
					{
						return true;
					}
				}
			}
		}

		Widget autocastOverlay = client.getWidget(AUTOCAST_REQUIREMENT_OVERLAY_NORMAL);
		if (autocastOverlay != null) return processChildren(autocastOverlay);

		Widget spellOverlay = client.getWidget(SPELL_REQUIREMENT_OVERLAY_NORMAL);
		if (spellOverlay != null) return processChildren(spellOverlay);
		return false;
	}

	public boolean processChildren(Widget widget)
	{
		Widget[] children = widget.getDynamicChildren();
		if (children == null) return true;

		for (Widget child : children)
		{
			int id = child.getItemId();
			if (id == -1) continue;

			if (plugin.isInPlay(id) && !availableRunes.contains(id))
				return false;
		}
		return true;
	}
}

package com.choicer.chanceman.menus;

import lombok.Getter;
import net.runelite.api.gameval.InterfaceID;

@Getter
public enum EnabledUI
{
	BANK(InterfaceID.BANKMAIN, true, true),
	DEPOSIT_BOX(InterfaceID.BANK_DEPOSITBOX, true, true),
	CUSTOM_FUR_STORE(InterfaceID.HuntingCustomfurs.CONTENT, false, true),
	Crafting_Gold(InterfaceID.CraftingGold.UNIVERSE, false, true),
	TTREK_REWARDS(InterfaceID.TREK_REWARDS,false, true),
	RUNEDOKU(InterfaceID.ROGUETRADER_SUDOKU, false, true);

	private final int id; // group id
	private final boolean greyLockedItems; // should grey/disable locked items in this UI
	private final boolean allowAllActions; // should bypass action restrictions in this UI

	EnabledUI(int id, boolean greyLockedItems, boolean allowAllActions)
	{
		this.id = (id > 0xFFFF) ? (id >>> 16) : id;
		this.greyLockedItems = greyLockedItems;
		this.allowAllActions = allowAllActions;
	}

	public static EnabledUI fromGroupId(int groupId)
	{
		for (EnabledUI ui : values())
		{
			if (ui.id == groupId) return ui;
		}
		return null;
	}
}

package com.choicer.chanceman;

import com.choicer.chanceman.ChoicemanPlugin;

import net.runelite.client.RuneLite;
import net.runelite.client.externalplugins.ExternalPluginManager;

public class ChoicemanPluginTest
{
	public static void main(String[] args) throws Exception
	{
		ExternalPluginManager.loadBuiltin(ChoicemanPlugin.class);
		RuneLite.main(args);
	}
}
package com.choicer.chanceman.filters;

import com.choicer.chanceman.ChanceManConfig;
import com.choicer.chanceman.filters.ItemAttributes;
import com.choicer.chanceman.filters.ItemEligibility;
import com.choicer.chanceman.filters.QuestItemAllowlist;

import net.runelite.api.ItemID;
import org.junit.Before;
import org.junit.Test;

import java.util.Collections;
import java.util.function.IntPredicate;

import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertTrue;
import static org.mockito.Mockito.mock;
import static org.mockito.Mockito.when;

/**
 * Verifies that quest items are only eligible when the Include Quest Items toggle is enabled.
 */
public class QuestItemFilteringTest
{
    private static final int QUEST_ITEM_ID = ItemID.ABYSSAL_WHIP;

    private ChanceManConfig config;
    private final IntPredicate neverTracked = id -> false;

    @Before
    public void setUp()
    {
        config = mock(ChanceManConfig.class);
        when(config.enableFlatpacks()).thenReturn(true);
        when(config.enableItemSets()).thenReturn(true);
        when(config.requireWeaponPoison()).thenReturn(false);
        when(config.freeToPlay()).thenReturn(false);
        when(config.includeF2PTradeOnlyItems()).thenReturn(false);
        when(config.includeUntradeable()).thenReturn(false);

        QuestItemAllowlist.clearForTesting();
        QuestItemAllowlist.registerQuestItemForTesting(QUEST_ITEM_ID);
    }

    @Test
    public void questItemsBlockedWhenToggleDisabled()
    {
        when(config.includeQuestItems()).thenReturn(false);

        ItemAttributes attributes = new ItemAttributes("Quest Item", true, false, -1);

        boolean eligible = ItemEligibility.shouldInclude(
                attributes,
                QUEST_ITEM_ID,
                QUEST_ITEM_ID,
                config,
                Collections.emptySet(),
                neverTracked
        );

        assertFalse(eligible);
    }

    @Test
    public void questItemsAllowedWhenToggleEnabled()
    {
        when(config.includeQuestItems()).thenReturn(true);

        ItemAttributes attributes = new ItemAttributes("Quest Item", true, false, -1);

        boolean eligible = ItemEligibility.shouldInclude(
                attributes,
                QUEST_ITEM_ID,
                QUEST_ITEM_ID,
                config,
                Collections.emptySet(),
                neverTracked
        );

        assertTrue(eligible);
    }
}

package com.choicer.chanceman;

import net.runelite.api.Client;
import net.runelite.client.game.ItemManager;
import net.runelite.client.ui.overlay.OverlayPosition;

import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.mockito.Mock;
import org.mockito.junit.MockitoJUnitRunner;

import java.awt.*;
import java.util.Collections;
import java.util.List;

import static org.junit.Assert.*;
import static org.mockito.Mockito.*;

import com.choicer.chanceman.ChanceManConfig;
import com.choicer.chanceman.ChoicemanOverlay;

@RunWith(MockitoJUnitRunner.class)
public class ChoicemanOverlayHitboxTest {

    @Mock
    private Client client;

    @Mock
    private ItemManager itemManager;

    @Mock
    private ChanceManConfig config;

    private ChoicemanOverlay choicemanOverlay;

    @Before
    public void setUp() {
        // Initialize the overlay with all required dependencies
        choicemanOverlay = new ChoicemanOverlay(client, itemManager);
        choicemanOverlay.setConfig(config);
        choicemanOverlay = spy(choicemanOverlay);
        
        // Set overlay position and mock bounds
        choicemanOverlay.setPosition(OverlayPosition.DYNAMIC);
        doReturn(new Rectangle(100, 100, 400, 200)).when(choicemanOverlay).getBounds();
    }

    @Test
    public void testHitboxDetectionWithSingleOption() {
        // Setup test data
        List<Integer> options = Collections.singletonList(123); // Test item ID
        choicemanOverlay.setChoicemanOptions(options);
        choicemanOverlay.setSelectionPending(true);

        // Simulate render call which will set up hitboxes
        choicemanOverlay.render(mock(Graphics2D.class));

        List<Rectangle> hitboxes = choicemanOverlay.getCurrentHitboxes();
        assertEquals("Should create a single hitbox", 1, hitboxes.size());
        Point hitPoint = getCenterOfScreenHitbox(hitboxes.get(0));

        // Test hit detection at different positions
        Integer result = choicemanOverlay.getOptionAt(hitPoint.x, hitPoint.y);
        assertNotNull("Should detect click on first button", result);
        assertEquals("Should return the correct item ID", (Integer) 123, result);

        // Click outside any button
        Rectangle bounds = choicemanOverlay.getBounds();
        result = choicemanOverlay.getOptionAt(bounds.x - 20, bounds.y - 20);
        assertNull("Should not detect click outside buttons", result);
    }

    @Test
    public void testHitboxDetectionWithMultipleOptions() {
        // Setup test data with 3 options
        List<Integer> options = List.of(123, 456, 789);
        choicemanOverlay.setChoicemanOptions(options);
        choicemanOverlay.setSelectionPending(true);

        // Simulate render call which will set up hitboxes
        choicemanOverlay.render(mock(Graphics2D.class));

        List<Rectangle> hitboxes = choicemanOverlay.getCurrentHitboxes();
        assertEquals("Hitboxes should match option count", options.size(), hitboxes.size());

        // Test hit detection for each button
        for (int i = 0; i < hitboxes.size(); i++) {
            Point center = getCenterOfScreenHitbox(hitboxes.get(i));
            Integer result = choicemanOverlay.getOptionAt(center.x, center.y);
            assertNotNull("Should detect click on button " + (i + 1), result);
            assertEquals("Should return the correct item ID", options.get(i), result);
        }

        // Click between first and second buttons
        Rectangle bounds = choicemanOverlay.getBounds();
        Rectangle first = hitboxes.get(0);
        Rectangle second = hitboxes.get(1);
        int betweenX = bounds.x + first.x + first.width + gapBetween(first, second) / 2;
        int betweenY = bounds.y + first.y + first.height / 2;
        Integer result = choicemanOverlay.getOptionAt(betweenX, betweenY);
        assertNull("Should not detect click between buttons", result);
    }

    @Test
    public void testHitboxEdgeCases() {
        // Setup test data with 2 options
        List<Integer> options = List.of(123, 456);
        choicemanOverlay.setChoicemanOptions(options);
        choicemanOverlay.setSelectionPending(true);

        // Simulate render call which will set up hitboxes
        choicemanOverlay.render(mock(Graphics2D.class));

        List<Rectangle> hitboxes = choicemanOverlay.getCurrentHitboxes();
        assertEquals("Should create hitboxes for each option", options.size(), hitboxes.size());
        Rectangle bounds = choicemanOverlay.getBounds();

        // Test edge of first button (top-left corner)
        Rectangle first = hitboxes.get(0);
        Integer result = choicemanOverlay.getOptionAt(bounds.x + first.x, bounds.y + first.y);
        assertNotNull("Should detect click on edge of first button", result);
        assertEquals("Should return the first item ID", (Integer) 123, result);

        // Test between buttons (should not register)
        Rectangle second = hitboxes.get(1);
        int betweenX = bounds.x + first.x + first.width + gapBetween(first, second) / 2;
        int betweenY = bounds.y + first.y + first.height / 2;
        result = choicemanOverlay.getOptionAt(betweenX, betweenY);
        assertNull("Should not detect click between buttons", result);
    }

    @Test
    public void testNoHitboxWhenNotPending() {
        // Setup test data but don't set selection pending
        List<Integer> options = Collections.singletonList(123);
        choicemanOverlay.setChoicemanOptions(options);
        // selectionPending is false by default

        // Simulate render call which would normally set up hitboxes
        choicemanOverlay.render(mock(Graphics2D.class));

        // Should not detect any hits even when clicking where a button would be
        Integer result = choicemanOverlay.getOptionAt(150, 150);
        assertNull("Should not detect any hits when selection is not pending", result);
    }

    private Point getCenterOfScreenHitbox(Rectangle hitbox) {
        Rectangle bounds = choicemanOverlay.getBounds();
        int x = bounds.x + hitbox.x + hitbox.width / 2;
        int y = bounds.y + hitbox.y + hitbox.height / 2;
        return new Point(x, y);
    }

    private int gapBetween(Rectangle left, Rectangle right) {
        return Math.max(1, right.x - (left.x + left.width));
    }
}

package com.choicer.chanceman;

import com.choicer.chanceman.ChanceManConfig;
import com.choicer.chanceman.filters.ItemAttributes;
import com.choicer.chanceman.filters.ItemEligibility;
import net.runelite.api.ItemID;
import org.junit.Before;
import org.junit.Test;

import java.util.Collections;
import java.util.function.IntPredicate;

import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertTrue;
import static org.mockito.Mockito.mock;
import static org.mockito.Mockito.when;

/**
 * Verifies that the Free-to-Play, trade-only, and untradeable config toggles interact correctly
 * when determining if an item can participate in ChanceMan rolls.
 */
public class ChanceManFilteringTest
{
    private static final int UNTRADEABLE_ALLOWLIST_ID = 8844;

    private ChanceManConfig config;
    private final IntPredicate neverTracked = id -> false;

    @Before
    public void setUp()
    {
        config = mock(ChanceManConfig.class);
        when(config.enableFlatpacks()).thenReturn(true);
        when(config.enableItemSets()).thenReturn(true);
        when(config.requireWeaponPoison()).thenReturn(false);
    }

    @Test
    public void freeToPlayBlocksTradeOnlyItemsWhenNotIncluded()
    {
        when(config.freeToPlay()).thenReturn(true);
        when(config.includeF2PTradeOnlyItems()).thenReturn(false);
        when(config.includeUntradeable()).thenReturn(false);

        ItemAttributes attributes = new ItemAttributes("Test Item", true, false, -1);

        boolean eligible = ItemEligibility.shouldInclude(
                attributes,
                ItemID.RING_OF_COINS,
                ItemID.RING_OF_COINS,
                config,
                Collections.emptySet(),
                neverTracked
        );

        assertFalse(eligible);
    }

    @Test
    public void freeToPlayAllowsTradeOnlyItemsWhenIncluded()
    {
        when(config.freeToPlay()).thenReturn(true);
        when(config.includeF2PTradeOnlyItems()).thenReturn(true);
        when(config.includeUntradeable()).thenReturn(false);

        ItemAttributes attributes = new ItemAttributes("Test Item", true, false, -1);

        boolean eligible = ItemEligibility.shouldInclude(
                attributes,
                ItemID.RING_OF_COINS,
                ItemID.RING_OF_COINS,
                config,
                Collections.emptySet(),
                neverTracked
        );

        assertTrue(eligible);
    }

    @Test
    public void freeToPlayStillAllowsAllowlistedUntradeables()
    {
        when(config.freeToPlay()).thenReturn(true);
        when(config.includeF2PTradeOnlyItems()).thenReturn(false);
        when(config.includeUntradeable()).thenReturn(true);

        ItemAttributes attributes = new ItemAttributes("Test Item", false, false, -1);

        boolean eligible = ItemEligibility.shouldInclude(
                attributes,
                UNTRADEABLE_ALLOWLIST_ID,
                UNTRADEABLE_ALLOWLIST_ID,
                config,
                Collections.emptySet(),
                neverTracked
        );

        assertTrue(eligible);
    }
}

